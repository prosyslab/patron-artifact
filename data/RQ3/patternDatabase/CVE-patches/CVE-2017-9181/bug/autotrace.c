/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 51 "/usr/include/locale.h"
struct lconv {
   char *decimal_point ;
   char *thousands_sep ;
   char *grouping ;
   char *int_curr_symbol ;
   char *currency_symbol ;
   char *mon_decimal_point ;
   char *mon_thousands_sep ;
   char *mon_grouping ;
   char *positive_sign ;
   char *negative_sign ;
   char int_frac_digits ;
   char frac_digits ;
   char p_cs_precedes ;
   char p_sep_by_space ;
   char n_cs_precedes ;
   char n_sep_by_space ;
   char p_sign_posn ;
   char n_sign_posn ;
   char int_p_cs_precedes ;
   char int_p_sep_by_space ;
   char int_n_cs_precedes ;
   char int_n_sep_by_space ;
   char int_p_sign_posn ;
   char int_n_sign_posn ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
struct __locale_data ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
struct __locale_struct {
   struct __locale_data *__locales[13] ;
   unsigned short const   *__ctype_b ;
   int const   *__ctype_tolower ;
   int const   *__ctype_toupper ;
   char const   *__names[13] ;
};
#line 41 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
typedef struct __locale_struct *__locale_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h"
typedef __locale_t locale_t;
#line 209 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h"
typedef unsigned long size_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 31 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __u_char;
#line 32 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __u_short;
#line 33 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __u_int;
#line 34 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_long;
#line 37 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef signed char __int8_t;
#line 38 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __uint8_t;
#line 39 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef short __int16_t;
#line 40 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __uint16_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __int32_t;
#line 42 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uint32_t;
#line 44 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __int64_t;
#line 45 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uint64_t;
#line 52 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int8_t __int_least8_t;
#line 53 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint8_t __uint_least8_t;
#line 54 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int16_t __int_least16_t;
#line 55 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint16_t __uint_least16_t;
#line 56 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int32_t __int_least32_t;
#line 57 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint32_t __uint_least32_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int64_t __int_least64_t;
#line 59 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint64_t __uint_least64_t;
#line 63 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __quad_t;
#line 64 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_quad_t;
#line 72 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intmax_t;
#line 73 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uintmax_t;
#line 145 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 146 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 147 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino64_t;
#line 150 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 151 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 152 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 154 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 155 "/usr/include/x86_64-linux-gnu/bits/types.h"
struct __anonstruct_0 {
   int __val[2] ;
};
#line 155 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef struct __anonstruct_0 __fsid_t;
#line 156 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 157 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim64_t;
#line 159 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __id_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 161 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 163 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds64_t;
#line 165 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __daddr_t;
#line 166 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __key_t;
#line 169 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __clockid_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef void *__timer_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 180 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 181 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt64_t;
#line 184 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt_t;
#line 185 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt64_t;
#line 188 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt64_t;
#line 192 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __fsword_t;
#line 194 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 197 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 199 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __syscall_ulong_t;
#line 203 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __off64_t __loff_t;
#line 204 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 207 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intptr_t;
#line 210 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 215 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __sig_atomic_t;
#line 16 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
union __anonunion_2 {
   unsigned int __wch ;
   char __wchb[4] ;
};
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
struct __anonstruct_1 {
   int __count ;
   union __anonunion_2 __value ;
};
#line 21 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
typedef struct __anonstruct_1 __mbstate_t;
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h"
struct _G_fpos_t {
   __off_t __pos ;
   __mbstate_t __state ;
};
#line 14 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h"
typedef struct _G_fpos_t __fpos_t;
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h"
struct _G_fpos64_t {
   __off64_t __pos ;
   __mbstate_t __state ;
};
#line 14 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h"
typedef struct _G_fpos64_t __fpos64_t;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE ;
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
typedef struct _IO_FILE __FILE;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_marker ;
#line 37
struct _IO_codecvt ;
#line 38
struct _IO_wide_data ;
#line 43 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
typedef void _IO_lock_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[20] ;
};
#line 52 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 63 "/usr/include/stdio.h"
typedef __off_t off_t;
#line 77 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 84 "/usr/include/stdio.h"
typedef __fpos_t fpos_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int8_t int8_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int16_t int16_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int32_t int32_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int64_t int64_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint8_t uint8_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint16_t uint16_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint32_t uint32_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint64_t uint64_t;
#line 43 "/usr/include/stdint.h"
typedef __int_least8_t int_least8_t;
#line 44 "/usr/include/stdint.h"
typedef __int_least16_t int_least16_t;
#line 45 "/usr/include/stdint.h"
typedef __int_least32_t int_least32_t;
#line 46 "/usr/include/stdint.h"
typedef __int_least64_t int_least64_t;
#line 49 "/usr/include/stdint.h"
typedef __uint_least8_t uint_least8_t;
#line 50 "/usr/include/stdint.h"
typedef __uint_least16_t uint_least16_t;
#line 51 "/usr/include/stdint.h"
typedef __uint_least32_t uint_least32_t;
#line 52 "/usr/include/stdint.h"
typedef __uint_least64_t uint_least64_t;
#line 58 "/usr/include/stdint.h"
typedef signed char int_fast8_t;
#line 60 "/usr/include/stdint.h"
typedef long int_fast16_t;
#line 61 "/usr/include/stdint.h"
typedef long int_fast32_t;
#line 62 "/usr/include/stdint.h"
typedef long int_fast64_t;
#line 71 "/usr/include/stdint.h"
typedef unsigned char uint_fast8_t;
#line 73 "/usr/include/stdint.h"
typedef unsigned long uint_fast16_t;
#line 74 "/usr/include/stdint.h"
typedef unsigned long uint_fast32_t;
#line 75 "/usr/include/stdint.h"
typedef unsigned long uint_fast64_t;
#line 87 "/usr/include/stdint.h"
typedef long intptr_t;
#line 90 "/usr/include/stdint.h"
typedef unsigned long uintptr_t;
#line 101 "/usr/include/stdint.h"
typedef __intmax_t intmax_t;
#line 102 "/usr/include/stdint.h"
typedef __uintmax_t uintmax_t;
#line 143 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h"
typedef long ptrdiff_t;
#line 321 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h"
typedef int wchar_t;
#line 415 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h"
struct __anonstruct_3 {
   long long __max_align_ll ;
   long double __max_align_ld ;
};
#line 426 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h"
typedef struct __anonstruct_3 max_align_t;
#line 42 "/usr/lib/x86_64-linux-gnu/glib-2.0/include/glibconfig.h"
typedef signed char gint8;
#line 43 "/usr/lib/x86_64-linux-gnu/glib-2.0/include/glibconfig.h"
typedef unsigned char guint8;
#line 45 "/usr/lib/x86_64-linux-gnu/glib-2.0/include/glibconfig.h"
typedef short gint16;
#line 46 "/usr/lib/x86_64-linux-gnu/glib-2.0/include/glibconfig.h"
typedef unsigned short guint16;
#line 53 "/usr/lib/x86_64-linux-gnu/glib-2.0/include/glibconfig.h"
typedef int gint32;
#line 54 "/usr/lib/x86_64-linux-gnu/glib-2.0/include/glibconfig.h"
typedef unsigned int guint32;
#line 63 "/usr/lib/x86_64-linux-gnu/glib-2.0/include/glibconfig.h"
typedef long gint64;
#line 64 "/usr/lib/x86_64-linux-gnu/glib-2.0/include/glibconfig.h"
typedef unsigned long guint64;
#line 79 "/usr/lib/x86_64-linux-gnu/glib-2.0/include/glibconfig.h"
typedef long gssize;
#line 80 "/usr/lib/x86_64-linux-gnu/glib-2.0/include/glibconfig.h"
typedef unsigned long gsize;
#line 90 "/usr/lib/x86_64-linux-gnu/glib-2.0/include/glibconfig.h"
typedef gint64 goffset;
#line 106 "/usr/lib/x86_64-linux-gnu/glib-2.0/include/glibconfig.h"
typedef long gintptr;
#line 107 "/usr/lib/x86_64-linux-gnu/glib-2.0/include/glibconfig.h"
typedef unsigned long guintptr;
#line 199 "/usr/lib/x86_64-linux-gnu/glib-2.0/include/glibconfig.h"
typedef int GPid;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/clock_t.h"
typedef __clock_t clock_t;
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h"
typedef __time_t time_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 11 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h"
typedef __clockid_t clockid_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/timer_t.h"
typedef __timer_t timer_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h"
struct itimerspec {
   struct timespec it_interval ;
   struct timespec it_value ;
};
#line 49 "/usr/include/time.h"
struct sigevent ;
#line 54 "/usr/include/time.h"
typedef __pid_t pid_t;
#line 46 "/usr/include/glib-2.0/glib/gtypes.h"
typedef char gchar;
#line 47 "/usr/include/glib-2.0/glib/gtypes.h"
typedef short gshort;
#line 48 "/usr/include/glib-2.0/glib/gtypes.h"
typedef long glong;
#line 49 "/usr/include/glib-2.0/glib/gtypes.h"
typedef int gint;
#line 50 "/usr/include/glib-2.0/glib/gtypes.h"
typedef gint gboolean;
#line 52 "/usr/include/glib-2.0/glib/gtypes.h"
typedef unsigned char guchar;
#line 53 "/usr/include/glib-2.0/glib/gtypes.h"
typedef unsigned short gushort;
#line 54 "/usr/include/glib-2.0/glib/gtypes.h"
typedef unsigned long gulong;
#line 55 "/usr/include/glib-2.0/glib/gtypes.h"
typedef unsigned int guint;
#line 57 "/usr/include/glib-2.0/glib/gtypes.h"
typedef float gfloat;
#line 58 "/usr/include/glib-2.0/glib/gtypes.h"
typedef double gdouble;
#line 103 "/usr/include/glib-2.0/glib/gtypes.h"
typedef void *gpointer;
#line 104 "/usr/include/glib-2.0/glib/gtypes.h"
typedef void const   *gconstpointer;
#line 106 "/usr/include/glib-2.0/glib/gtypes.h"
typedef gint (*GCompareFunc)(gconstpointer  , gconstpointer  );
#line 108 "/usr/include/glib-2.0/glib/gtypes.h"
typedef gint (*GCompareDataFunc)(gconstpointer  , gconstpointer  , gpointer  );
#line 111 "/usr/include/glib-2.0/glib/gtypes.h"
typedef gboolean (*GEqualFunc)(gconstpointer  , gconstpointer  );
#line 113 "/usr/include/glib-2.0/glib/gtypes.h"
typedef void (*GDestroyNotify)(gpointer  );
#line 114 "/usr/include/glib-2.0/glib/gtypes.h"
typedef void (*GFunc)(gpointer  , gpointer  );
#line 116 "/usr/include/glib-2.0/glib/gtypes.h"
typedef guint (*GHashFunc)(gconstpointer  );
#line 117 "/usr/include/glib-2.0/glib/gtypes.h"
typedef void (*GHFunc)(gpointer  , gpointer  , gpointer  );
#line 133 "/usr/include/glib-2.0/glib/gtypes.h"
typedef gpointer (*GCopyFunc)(gconstpointer  , gpointer  );
#line 143 "/usr/include/glib-2.0/glib/gtypes.h"
typedef void (*GFreeFunc)(gpointer  );
#line 157 "/usr/include/glib-2.0/glib/gtypes.h"
typedef gchar *(*GTranslateFunc)(gchar * , gpointer  );
#line 501
union _GDoubleIEEE754 ;
#line 501 "/usr/include/glib-2.0/glib/gtypes.h"
typedef union _GDoubleIEEE754 GDoubleIEEE754;
#line 502
union _GFloatIEEE754 ;
#line 502 "/usr/include/glib-2.0/glib/gtypes.h"
typedef union _GFloatIEEE754 GFloatIEEE754;
#line 511 "/usr/include/glib-2.0/glib/gtypes.h"
struct __anonstruct_4 {
   guint mantissa ;
   guint biased_exponent ;
   guint sign ;
};
#line 508 "/usr/include/glib-2.0/glib/gtypes.h"
union _GFloatIEEE754 {
   gfloat v_float ;
   struct __anonstruct_4 mpn ;
};
#line 520 "/usr/include/glib-2.0/glib/gtypes.h"
struct __anonstruct_5 {
   guint mantissa_low ;
   guint mantissa_high ;
   guint biased_exponent ;
   guint sign ;
};
#line 517 "/usr/include/glib-2.0/glib/gtypes.h"
union _GDoubleIEEE754 {
   gdouble v_double ;
   struct __anonstruct_5 mpn ;
};
#line 551
struct _GTimeVal ;
#line 551 "/usr/include/glib-2.0/glib/gtypes.h"
typedef struct _GTimeVal GTimeVal;
#line 553 "/usr/include/glib-2.0/glib/gtypes.h"
struct _GTimeVal {
   glong tv_sec ;
   glong tv_usec ;
};
#line 559 "/usr/include/glib-2.0/glib/gtypes.h"
typedef gint grefcount;
#line 560 "/usr/include/glib-2.0/glib/gtypes.h"
typedef gint gatomicrefcount;
#line 36 "/usr/include/glib-2.0/glib/garray.h"
struct _GBytes ;
#line 36 "/usr/include/glib-2.0/glib/garray.h"
typedef struct _GBytes GBytes;
#line 37
struct _GArray ;
#line 37 "/usr/include/glib-2.0/glib/garray.h"
typedef struct _GArray GArray;
#line 38
struct _GByteArray ;
#line 38 "/usr/include/glib-2.0/glib/garray.h"
typedef struct _GByteArray GByteArray;
#line 39
struct _GPtrArray ;
#line 39 "/usr/include/glib-2.0/glib/garray.h"
typedef struct _GPtrArray GPtrArray;
#line 41 "/usr/include/glib-2.0/glib/garray.h"
struct _GArray {
   gchar *data ;
   guint len ;
};
#line 47 "/usr/include/glib-2.0/glib/garray.h"
struct _GByteArray {
   guint8 *data ;
   guint len ;
};
#line 53 "/usr/include/glib-2.0/glib/garray.h"
struct _GPtrArray {
   gpointer *pdata ;
   guint len ;
};
#line 36 "/usr/include/glib-2.0/glib/gquark.h"
typedef guint32 GQuark;
#line 41 "/usr/include/glib-2.0/glib/gerror.h"
struct _GError ;
#line 41 "/usr/include/glib-2.0/glib/gerror.h"
typedef struct _GError GError;
#line 43 "/usr/include/glib-2.0/glib/gerror.h"
struct _GError {
   GQuark domain ;
   gint code ;
   gchar *message ;
};
#line 140 "/usr/include/glib-2.0/glib/gerror.h"
typedef void (*GErrorInitFunc)(GError * );
#line 158 "/usr/include/glib-2.0/glib/gerror.h"
typedef void (*GErrorCopyFunc)(GError * , GError * );
#line 173 "/usr/include/glib-2.0/glib/gerror.h"
typedef void (*GErrorClearFunc)(GError * );
#line 252 "/usr/include/glib-2.0/glib/gutils.h"
enum __anonenum__6 {
    G_USER_DIRECTORY_DESKTOP = 0,
    G_USER_DIRECTORY_DOCUMENTS = 1,
    G_USER_DIRECTORY_DOWNLOAD = 2,
    G_USER_DIRECTORY_MUSIC = 3,
    G_USER_DIRECTORY_PICTURES = 4,
    G_USER_DIRECTORY_PUBLIC_SHARE = 5,
    G_USER_DIRECTORY_TEMPLATES = 6,
    G_USER_DIRECTORY_VIDEOS = 7,
    G_USER_N_DIRECTORIES = 8
} ;
#line 263 "/usr/include/glib-2.0/glib/gutils.h"
typedef enum __anonenum__6 GUserDirectory;
#line 276
struct _GDebugKey ;
#line 276 "/usr/include/glib-2.0/glib/gutils.h"
typedef struct _GDebugKey GDebugKey;
#line 277 "/usr/include/glib-2.0/glib/gutils.h"
struct _GDebugKey {
   gchar *key ;
   guint value ;
};
#line 305
enum __anonenum__7 {
    G_FORMAT_SIZE_DEFAULT = 0,
    G_FORMAT_SIZE_LONG_FORMAT = 1,
    G_FORMAT_SIZE_IEC_UNITS = 2,
    G_FORMAT_SIZE_BITS = 4
} ;
#line 311 "/usr/include/glib-2.0/glib/gutils.h"
typedef enum __anonenum__7 GFormatSizeFlags;
#line 333 "/usr/include/glib-2.0/glib/gutils.h"
typedef void (*GVoidFunc)(void);
#line 59 "/usr/include/stdlib.h"
struct __anonstruct_8 {
   int quot ;
   int rem ;
};
#line 63 "/usr/include/stdlib.h"
typedef struct __anonstruct_8 div_t;
#line 67 "/usr/include/stdlib.h"
struct __anonstruct_9 {
   long quot ;
   long rem ;
};
#line 71 "/usr/include/stdlib.h"
typedef struct __anonstruct_9 ldiv_t;
#line 77 "/usr/include/stdlib.h"
struct __anonstruct_10 {
   long long quot ;
   long long rem ;
};
#line 81 "/usr/include/stdlib.h"
typedef struct __anonstruct_10 lldiv_t;
#line 33 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_char u_char;
#line 34 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_short u_short;
#line 35 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_int u_int;
#line 36 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_long u_long;
#line 37 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __quad_t quad_t;
#line 38 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_quad_t u_quad_t;
#line 39 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsid_t fsid_t;
#line 42 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __loff_t loff_t;
#line 47 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ino_t ino_t;
#line 59 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __dev_t dev_t;
#line 64 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __gid_t gid_t;
#line 69 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 74 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __nlink_t nlink_t;
#line 79 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 103 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __id_t id_t;
#line 114 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __daddr_t daddr_t;
#line 115 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __caddr_t caddr_t;
#line 121 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __key_t key_t;
#line 148 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned long ulong;
#line 149 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned short ushort;
#line 150 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int uint;
#line 158 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint8_t u_int8_t;
#line 159 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint16_t u_int16_t;
#line 160 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint32_t u_int32_t;
#line 161 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint64_t u_int64_t;
#line 164 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef long register_t;
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
struct __anonstruct_11 {
   unsigned long __val[16] ;
};
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
typedef struct __anonstruct_11 __sigset_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h"
typedef __sigset_t sigset_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 43 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __suseconds_t suseconds_t;
#line 49 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 59 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_12 {
   __fd_mask __fds_bits[16] ;
};
#line 70 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_12 fd_set;
#line 77 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __fd_mask fd_mask;
#line 185 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __blksize_t blksize_t;
#line 192 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __blkcnt_t blkcnt_t;
#line 196 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsblkcnt_t fsblkcnt_t;
#line 200 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsfilcnt_t fsfilcnt_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h"
struct __anonstruct_14 {
   unsigned int __low ;
   unsigned int __high ;
};
#line 25 "/usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h"
union __anonunion_13 {
   unsigned long long __value64 ;
   struct __anonstruct_14 __value32 ;
};
#line 33 "/usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h"
typedef union __anonunion_13 __atomic_wide_counter;
#line 51 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 55 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 57 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_internal_slist {
   struct __pthread_internal_slist *__next ;
};
#line 60 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef struct __pthread_internal_slist __pthread_slist_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
#line 23 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h"
struct __pthread_rwlock_arch_t {
   unsigned int __readers ;
   unsigned int __writers ;
   unsigned int __wrphase_futex ;
   unsigned int __writers_futex ;
   unsigned int __pad3 ;
   unsigned int __pad4 ;
   int __cur_writer ;
   int __shared ;
   signed char __rwelision ;
   unsigned char __pad1[7] ;
   unsigned long __pad2 ;
   unsigned int __flags ;
};
#line 94 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_cond_s {
   __atomic_wide_counter __wseq ;
   __atomic_wide_counter __g1_start ;
   unsigned int __g_refs[2] ;
   unsigned int __g_size[2] ;
   unsigned int __g1_orig_size ;
   unsigned int __wrefs ;
   unsigned int __g_signals[2] ;
};
#line 105 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef unsigned int __tss_t;
#line 106 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef unsigned long __thrd_t;
#line 108 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __anonstruct_15 {
   int __data ;
};
#line 111 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef struct __anonstruct_15 __once_flag;
#line 27 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_16 {
   char __size[4] ;
   int __align ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_16 pthread_mutexattr_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_17 {
   char __size[4] ;
   int __align ;
};
#line 45 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_17 pthread_condattr_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned int pthread_key_t;
#line 53 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef int pthread_once_t;
#line 56 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union pthread_attr_t pthread_attr_t;
#line 67 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_18 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 72 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_18 pthread_mutex_t;
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_19 {
   struct __pthread_cond_s __data ;
   char __size[48] ;
   long long __align ;
};
#line 80 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_19 pthread_cond_t;
#line 86 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_20 {
   struct __pthread_rwlock_arch_t __data ;
   char __size[56] ;
   long __align ;
};
#line 91 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_20 pthread_rwlock_t;
#line 93 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_21 {
   char __size[8] ;
   long __align ;
};
#line 97 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_21 pthread_rwlockattr_t;
#line 103 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef int pthread_spinlock_t;
#line 108 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_22 {
   char __size[32] ;
   long __align ;
};
#line 112 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_22 pthread_barrier_t;
#line 114 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_23 {
   char __size[4] ;
   int __align ;
};
#line 118 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_23 pthread_barrierattr_t;
#line 424 "/usr/include/stdlib.h"
struct random_data {
   int32_t *fptr ;
   int32_t *rptr ;
   int32_t *state ;
   int rand_type ;
   int rand_deg ;
   int rand_sep ;
   int32_t *end_ptr ;
};
#line 491 "/usr/include/stdlib.h"
struct drand48_data {
   unsigned short __x[3] ;
   unsigned short __old_x[3] ;
   unsigned short __c ;
   unsigned short __init ;
   unsigned long long __a ;
};
#line 816 "/usr/include/stdlib.h"
typedef int (*__compar_fn_t)(void const   * , void const   * );
#line 42 "/usr/include/glib-2.0/glib/gthread.h"
enum __anonenum__24 {
    G_THREAD_ERROR_AGAIN = 0
} ;
#line 45 "/usr/include/glib-2.0/glib/gthread.h"
typedef enum __anonenum__24 GThreadError;
#line 47 "/usr/include/glib-2.0/glib/gthread.h"
typedef gpointer (*GThreadFunc)(gpointer  );
#line 49
struct _GThread ;
#line 49 "/usr/include/glib-2.0/glib/gthread.h"
typedef struct _GThread GThread;
#line 51
union _GMutex ;
#line 51 "/usr/include/glib-2.0/glib/gthread.h"
typedef union _GMutex GMutex;
#line 52
struct _GRecMutex ;
#line 52 "/usr/include/glib-2.0/glib/gthread.h"
typedef struct _GRecMutex GRecMutex;
#line 53
struct _GRWLock ;
#line 53 "/usr/include/glib-2.0/glib/gthread.h"
typedef struct _GRWLock GRWLock;
#line 54
struct _GCond ;
#line 54 "/usr/include/glib-2.0/glib/gthread.h"
typedef struct _GCond GCond;
#line 55
struct _GPrivate ;
#line 55 "/usr/include/glib-2.0/glib/gthread.h"
typedef struct _GPrivate GPrivate;
#line 56
struct _GOnce ;
#line 56 "/usr/include/glib-2.0/glib/gthread.h"
typedef struct _GOnce GOnce;
#line 58 "/usr/include/glib-2.0/glib/gthread.h"
union _GMutex {
   gpointer p ;
   guint i[2] ;
};
#line 65 "/usr/include/glib-2.0/glib/gthread.h"
struct _GRWLock {
   gpointer p ;
   guint i[2] ;
};
#line 72 "/usr/include/glib-2.0/glib/gthread.h"
struct _GCond {
   gpointer p ;
   guint i[2] ;
};
#line 79 "/usr/include/glib-2.0/glib/gthread.h"
struct _GRecMutex {
   gpointer p ;
   guint i[2] ;
};
#line 87 "/usr/include/glib-2.0/glib/gthread.h"
struct _GPrivate {
   gpointer p ;
   GDestroyNotify notify ;
   gpointer future[2] ;
};
#line 95
enum __anonenum__25 {
    G_ONCE_STATUS_NOTCALLED = 0,
    G_ONCE_STATUS_PROGRESS = 1,
    G_ONCE_STATUS_READY = 2
} ;
#line 100 "/usr/include/glib-2.0/glib/gthread.h"
typedef enum __anonenum__25 GOnceStatus;
#line 103 "/usr/include/glib-2.0/glib/gthread.h"
struct _GOnce {
   GOnceStatus status ;
   gpointer retval ;
};
#line 285 "/usr/include/glib-2.0/glib/gthread.h"
typedef void GMutexLocker;
#line 360 "/usr/include/glib-2.0/glib/gthread.h"
typedef void GRecMutexLocker;
#line 439 "/usr/include/glib-2.0/glib/gthread.h"
typedef void GRWLockWriterLocker;
#line 550 "/usr/include/glib-2.0/glib/gthread.h"
typedef void GRWLockReaderLocker;
#line 36 "/usr/include/glib-2.0/glib/gasyncqueue.h"
struct _GAsyncQueue ;
#line 36 "/usr/include/glib-2.0/glib/gasyncqueue.h"
typedef struct _GAsyncQueue GAsyncQueue;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/sig_atomic_t.h"
typedef __sig_atomic_t sig_atomic_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/types/__sigval_t.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/types/__sigval_t.h"
typedef union sigval __sigval_t;
#line 56 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_28 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 63 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_29 {
   int si_tid ;
   int si_overrun ;
   __sigval_t si_sigval ;
};
#line 71 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_30 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   __sigval_t si_sigval ;
};
#line 79 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_31 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
#line 97 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_34 {
   void *_lower ;
   void *_upper ;
};
#line 94 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
union __anonunion_33 {
   struct __anonstruct_34 _addr_bnd ;
   __uint32_t _pkey ;
};
#line 89 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_32 {
   void *si_addr ;
   short si_addr_lsb ;
   union __anonunion_33 _bounds ;
};
#line 108 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_35 {
   long si_band ;
   int si_fd ;
};
#line 116 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_36 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 51 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
union __anonunion_27 {
   int _pad[28] ;
   struct __anonstruct_28 _kill ;
   struct __anonstruct_29 _timer ;
   struct __anonstruct_30 _rt ;
   struct __anonstruct_31 _sigchld ;
   struct __anonstruct_32 _sigfault ;
   struct __anonstruct_35 _sigpoll ;
   struct __anonstruct_36 _sigsys ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_26 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   int __pad0 ;
   union __anonunion_27 _sifields ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
typedef struct __anonstruct_26 siginfo_t;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__37 {
    SI_ASYNCNL = -60,
    SI_DETHREAD = -7,
    SI_TKILL = -6,
    SI_SIGIO = -5,
    SI_ASYNCIO = -4,
    SI_MESGQ = -3,
    SI_TIMER = -2,
    SI_QUEUE = -1,
    SI_USER = 0,
    SI_KERNEL = 128
} ;
#line 71
enum __anonenum__38 {
    ILL_ILLOPC = 1,
    ILL_ILLOPN = 2,
    ILL_ILLADR = 3,
    ILL_ILLTRP = 4,
    ILL_PRVOPC = 5,
    ILL_PRVREG = 6,
    ILL_COPROC = 7,
    ILL_BADSTK = 8,
    ILL_BADIADDR = 9
} ;
#line 94
enum __anonenum__39 {
    FPE_INTDIV = 1,
    FPE_INTOVF = 2,
    FPE_FLTDIV = 3,
    FPE_FLTOVF = 4,
    FPE_FLTUND = 5,
    FPE_FLTRES = 6,
    FPE_FLTINV = 7,
    FPE_FLTSUB = 8,
    FPE_FLTUNK = 14,
    FPE_CONDTRAP = 15
} ;
#line 119
enum __anonenum__40 {
    SEGV_MAPERR = 1,
    SEGV_ACCERR = 2,
    SEGV_BNDERR = 3,
    SEGV_PKUERR = 4,
    SEGV_ACCADI = 5,
    SEGV_ADIDERR = 6,
    SEGV_ADIPERR = 7,
    SEGV_MTEAERR = 8,
    SEGV_MTESERR = 9
} ;
#line 142
enum __anonenum__41 {
    BUS_ADRALN = 1,
    BUS_ADRERR = 2,
    BUS_OBJERR = 3,
    BUS_MCEERR_AR = 4,
    BUS_MCEERR_AO = 5
} ;
#line 176
enum __anonenum__42 {
    CLD_EXITED = 1,
    CLD_KILLED = 2,
    CLD_DUMPED = 3,
    CLD_TRAPPED = 4,
    CLD_STOPPED = 5,
    CLD_CONTINUED = 6
} ;
#line 193
enum __anonenum__43 {
    POLL_IN = 1,
    POLL_OUT = 2,
    POLL_MSG = 3,
    POLL_ERR = 4,
    POLL_PRI = 5,
    POLL_HUP = 6
} ;
#line 16 "/usr/include/x86_64-linux-gnu/bits/types/sigval_t.h"
typedef __sigval_t sigval_t;
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h"
struct __anonstruct_45 {
   void (*_function)(__sigval_t  ) ;
   pthread_attr_t *_attribute ;
};
#line 28 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h"
union __anonunion_44 {
   int _pad[12] ;
   __pid_t _tid ;
   struct __anonstruct_45 _sigev_thread ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h"
struct sigevent {
   __sigval_t sigev_value ;
   int sigev_signo ;
   int sigev_notify ;
   union __anonunion_44 _sigev_un ;
};
#line 42 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h"
typedef struct sigevent sigevent_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__46 {
    SIGEV_SIGNAL = 0,
    SIGEV_NONE = 1,
    SIGEV_THREAD = 2,
    SIGEV_THREAD_ID = 4
} ;
#line 72 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 193 "/usr/include/signal.h"
typedef __sighandler_t sig_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion_47 {
   __sighandler_t sa_handler ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion_47 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _fpx_sw_bytes {
   __uint32_t magic1 ;
   __uint32_t extended_size ;
   __uint64_t xstate_bv ;
   __uint32_t xstate_size ;
   __uint32_t __glibc_reserved1[7] ;
};
#line 40 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _fpreg {
   unsigned short significand[4] ;
   unsigned short exponent ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _fpxreg {
   unsigned short significand[4] ;
   unsigned short exponent ;
   unsigned short __glibc_reserved1[3] ;
};
#line 53 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _xmmreg {
   __uint32_t element[4] ;
};
#line 123 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _fpstate {
   __uint16_t cwd ;
   __uint16_t swd ;
   __uint16_t ftw ;
   __uint16_t fop ;
   __uint64_t rip ;
   __uint64_t rdp ;
   __uint32_t mxcsr ;
   __uint32_t mxcr_mask ;
   struct _fpxreg _st[8] ;
   struct _xmmreg _xmm[16] ;
   __uint32_t __glibc_reserved1[24] ;
};
#line 167 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
union __anonunion_48 {
   struct _fpstate *fpstate ;
   __uint64_t __fpstate_word ;
};
#line 139 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct sigcontext {
   __uint64_t r8 ;
   __uint64_t r9 ;
   __uint64_t r10 ;
   __uint64_t r11 ;
   __uint64_t r12 ;
   __uint64_t r13 ;
   __uint64_t r14 ;
   __uint64_t r15 ;
   __uint64_t rdi ;
   __uint64_t rsi ;
   __uint64_t rbp ;
   __uint64_t rbx ;
   __uint64_t rdx ;
   __uint64_t rax ;
   __uint64_t rcx ;
   __uint64_t rsp ;
   __uint64_t rip ;
   __uint64_t eflags ;
   unsigned short cs ;
   unsigned short gs ;
   unsigned short fs ;
   unsigned short __pad0 ;
   __uint64_t err ;
   __uint64_t trapno ;
   __uint64_t oldmask ;
   __uint64_t cr2 ;
   union __anonunion_48  ;
   struct _fpstate *fpstate ;
   __uint64_t __fpstate_word ;
   __uint64_t __reserved1[8] ;
};
#line 177 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _xsave_hdr {
   __uint64_t xstate_bv ;
   __uint64_t __glibc_reserved1[2] ;
   __uint64_t __glibc_reserved2[5] ;
};
#line 184 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _ymmh_state {
   __uint32_t ymmh_space[64] ;
};
#line 189 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _xstate {
   struct _fpstate fpstate ;
   struct _xsave_hdr xstate_hdr ;
   struct _ymmh_state ymmh ;
};
#line 26 "/usr/include/x86_64-linux-gnu/bits/types/stack_t.h"
struct __anonstruct_49 {
   void *ss_sp ;
   int ss_flags ;
   size_t ss_size ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/stack_t.h"
typedef struct __anonstruct_49 stack_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
typedef long long greg_t;
#line 46 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
typedef greg_t gregset_t[23];
#line 101 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
struct _libc_fpxreg {
   unsigned short significand[4] ;
   unsigned short exponent ;
   unsigned short __glibc_reserved1[3] ;
};
#line 108 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
struct _libc_xmmreg {
   __uint32_t element[4] ;
};
#line 113 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
struct _libc_fpstate {
   __uint16_t cwd ;
   __uint16_t swd ;
   __uint16_t ftw ;
   __uint16_t fop ;
   __uint64_t rip ;
   __uint64_t rdp ;
   __uint32_t mxcsr ;
   __uint32_t mxcr_mask ;
   struct _libc_fpxreg _st[8] ;
   struct _libc_xmmreg _xmm[16] ;
   __uint32_t __glibc_reserved1[24] ;
};
#line 130 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
typedef struct _libc_fpstate *fpregset_t;
#line 133 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
struct __anonstruct_50 {
   gregset_t gregs ;
   fpregset_t fpregs ;
   unsigned long long __reserved1[8] ;
};
#line 139 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
typedef struct __anonstruct_50 mcontext_t;
#line 142 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
struct ucontext_t {
   unsigned long uc_flags ;
   struct ucontext_t *uc_link ;
   stack_t uc_stack ;
   mcontext_t uc_mcontext ;
   sigset_t uc_sigmask ;
   struct _libc_fpstate __fpregs_mem ;
   unsigned long long __ssp[4] ;
};
#line 151 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
typedef struct ucontext_t ucontext_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__51 {
    SS_ONSTACK = 1,
    SS_DISABLE = 2
} ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/types/struct_sigstack.h"
struct sigstack {
   void *ss_sp ;
   int ss_onstack ;
};
#line 32 "/usr/include/glib-2.0/glib/gtimezone.h"
struct _GTimeZone ;
#line 32 "/usr/include/glib-2.0/glib/gtimezone.h"
typedef struct _GTimeZone GTimeZone;
#line 49
enum __anonenum__52 {
    G_TIME_TYPE_STANDARD = 0,
    G_TIME_TYPE_DAYLIGHT = 1,
    G_TIME_TYPE_UNIVERSAL = 2
} ;
#line 54 "/usr/include/glib-2.0/glib/gtimezone.h"
typedef enum __anonenum__52 GTimeType;
#line 87 "/usr/include/glib-2.0/glib/gdatetime.h"
typedef gint64 GTimeSpan;
#line 96
struct _GDateTime ;
#line 96 "/usr/include/glib-2.0/glib/gdatetime.h"
typedef struct _GDateTime GDateTime;
#line 58 "/usr/include/glib-2.0/glib/gbookmarkfile.h"
enum __anonenum__53 {
    G_BOOKMARK_FILE_ERROR_INVALID_URI = 0,
    G_BOOKMARK_FILE_ERROR_INVALID_VALUE = 1,
    G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED = 2,
    G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND = 3,
    G_BOOKMARK_FILE_ERROR_READ = 4,
    G_BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING = 5,
    G_BOOKMARK_FILE_ERROR_WRITE = 6,
    G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND = 7
} ;
#line 68 "/usr/include/glib-2.0/glib/gbookmarkfile.h"
typedef enum __anonenum__53 GBookmarkFileError;
#line 78
struct _GBookmarkFile ;
#line 78 "/usr/include/glib-2.0/glib/gbookmarkfile.h"
typedef struct _GBookmarkFile GBookmarkFile;
#line 47 "/usr/include/glib-2.0/glib/gchecksum.h"
enum __anonenum__54 {
    G_CHECKSUM_MD5 = 0,
    G_CHECKSUM_SHA1 = 1,
    G_CHECKSUM_SHA256 = 2,
    G_CHECKSUM_SHA512 = 3,
    G_CHECKSUM_SHA384 = 4
} ;
#line 53 "/usr/include/glib-2.0/glib/gchecksum.h"
typedef enum __anonenum__54 GChecksumType;
#line 65
struct _GChecksum ;
#line 65 "/usr/include/glib-2.0/glib/gchecksum.h"
typedef struct _GChecksum GChecksum;
#line 54 "/usr/include/glib-2.0/glib/gconvert.h"
enum __anonenum__55 {
    G_CONVERT_ERROR_NO_CONVERSION = 0,
    G_CONVERT_ERROR_ILLEGAL_SEQUENCE = 1,
    G_CONVERT_ERROR_FAILED = 2,
    G_CONVERT_ERROR_PARTIAL_INPUT = 3,
    G_CONVERT_ERROR_BAD_URI = 4,
    G_CONVERT_ERROR_NOT_ABSOLUTE_PATH = 5,
    G_CONVERT_ERROR_NO_MEMORY = 6,
    G_CONVERT_ERROR_EMBEDDED_NUL = 7
} ;
#line 64 "/usr/include/glib-2.0/glib/gconvert.h"
typedef enum __anonenum__55 GConvertError;
#line 83
struct _GIConv ;
#line 83 "/usr/include/glib-2.0/glib/gconvert.h"
typedef struct _GIConv *GIConv;
#line 36 "/usr/include/glib-2.0/glib/gdataset.h"
struct _GData ;
#line 36 "/usr/include/glib-2.0/glib/gdataset.h"
typedef struct _GData GData;
#line 38 "/usr/include/glib-2.0/glib/gdataset.h"
typedef void (*GDataForeachFunc)(GQuark  , gpointer  , gpointer  );
#line 57 "/usr/include/glib-2.0/glib/gdataset.h"
typedef gpointer (*GDuplicateFunc)(gpointer  , gpointer  );
#line 48 "/usr/include/glib-2.0/glib/gdate.h"
typedef gint32 GTime;
#line 49 "/usr/include/glib-2.0/glib/gdate.h"
typedef guint16 GDateYear;
#line 50 "/usr/include/glib-2.0/glib/gdate.h"
typedef guint8 GDateDay;
#line 51
struct _GDate ;
#line 51 "/usr/include/glib-2.0/glib/gdate.h"
typedef struct _GDate GDate;
#line 54
enum __anonenum__56 {
    G_DATE_DAY = 0,
    G_DATE_MONTH = 1,
    G_DATE_YEAR = 2
} ;
#line 59 "/usr/include/glib-2.0/glib/gdate.h"
typedef enum __anonenum__56 GDateDMY;
#line 62
enum __anonenum__57 {
    G_DATE_BAD_WEEKDAY = 0,
    G_DATE_MONDAY = 1,
    G_DATE_TUESDAY = 2,
    G_DATE_WEDNESDAY = 3,
    G_DATE_THURSDAY = 4,
    G_DATE_FRIDAY = 5,
    G_DATE_SATURDAY = 6,
    G_DATE_SUNDAY = 7
} ;
#line 72 "/usr/include/glib-2.0/glib/gdate.h"
typedef enum __anonenum__57 GDateWeekday;
#line 73
enum __anonenum__58 {
    G_DATE_BAD_MONTH = 0,
    G_DATE_JANUARY = 1,
    G_DATE_FEBRUARY = 2,
    G_DATE_MARCH = 3,
    G_DATE_APRIL = 4,
    G_DATE_MAY = 5,
    G_DATE_JUNE = 6,
    G_DATE_JULY = 7,
    G_DATE_AUGUST = 8,
    G_DATE_SEPTEMBER = 9,
    G_DATE_OCTOBER = 10,
    G_DATE_NOVEMBER = 11,
    G_DATE_DECEMBER = 12
} ;
#line 88 "/usr/include/glib-2.0/glib/gdate.h"
typedef enum __anonenum__58 GDateMonth;
#line 99 "/usr/include/glib-2.0/glib/gdate.h"
struct _GDate {
   guint julian_days ;
   guint julian ;
   guint dmy ;
   guint day ;
   guint month ;
   guint year ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 97 "/usr/include/dirent.h"
enum __anonenum__59 {
    DT_UNKNOWN = 0,
    DT_FIFO = 1,
    DT_CHR = 2,
    DT_DIR = 4,
    DT_BLK = 6,
    DT_REG = 8,
    DT_LNK = 10,
    DT_SOCK = 12,
    DT_WHT = 14
} ;
#line 127
struct __dirstream ;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 37 "/usr/include/glib-2.0/glib/gdir.h"
struct _GDir ;
#line 37 "/usr/include/glib-2.0/glib/gdir.h"
typedef struct _GDir GDir;
#line 33 "/usr/include/glib-2.0/glib/gfileutils.h"
enum __anonenum__60 {
    G_FILE_ERROR_EXIST = 0,
    G_FILE_ERROR_ISDIR = 1,
    G_FILE_ERROR_ACCES = 2,
    G_FILE_ERROR_NAMETOOLONG = 3,
    G_FILE_ERROR_NOENT = 4,
    G_FILE_ERROR_NOTDIR = 5,
    G_FILE_ERROR_NXIO = 6,
    G_FILE_ERROR_NODEV = 7,
    G_FILE_ERROR_ROFS = 8,
    G_FILE_ERROR_TXTBSY = 9,
    G_FILE_ERROR_FAULT = 10,
    G_FILE_ERROR_LOOP = 11,
    G_FILE_ERROR_NOSPC = 12,
    G_FILE_ERROR_NOMEM = 13,
    G_FILE_ERROR_MFILE = 14,
    G_FILE_ERROR_NFILE = 15,
    G_FILE_ERROR_BADF = 16,
    G_FILE_ERROR_INVAL = 17,
    G_FILE_ERROR_PIPE = 18,
    G_FILE_ERROR_AGAIN = 19,
    G_FILE_ERROR_INTR = 20,
    G_FILE_ERROR_IO = 21,
    G_FILE_ERROR_PERM = 22,
    G_FILE_ERROR_NOSYS = 23,
    G_FILE_ERROR_FAILED = 24
} ;
#line 60 "/usr/include/glib-2.0/glib/gfileutils.h"
typedef enum __anonenum__60 GFileError;
#line 66
enum __anonenum__61 {
    G_FILE_TEST_IS_REGULAR = 1,
    G_FILE_TEST_IS_SYMLINK = 2,
    G_FILE_TEST_IS_DIR = 4,
    G_FILE_TEST_IS_EXECUTABLE = 8,
    G_FILE_TEST_EXISTS = 16
} ;
#line 73 "/usr/include/glib-2.0/glib/gfileutils.h"
typedef enum __anonenum__61 GFileTest;
#line 99
enum __anonenum__62 {
    G_FILE_SET_CONTENTS_NONE = 0,
    G_FILE_SET_CONTENTS_CONSISTENT = 1,
    G_FILE_SET_CONTENTS_DURABLE = 2,
    G_FILE_SET_CONTENTS_ONLY_EXISTING = 4
} ;
#line 105 "/usr/include/glib-2.0/glib/gfileutils.h"
typedef enum __anonenum__62 GFileSetContentsFlags;
#line 52 "/usr/include/glib-2.0/glib/gmem.h"
struct _GMemVTable ;
#line 52 "/usr/include/glib-2.0/glib/gmem.h"
typedef struct _GMemVTable GMemVTable;
#line 380 "/usr/include/glib-2.0/glib/gmem.h"
struct _GMemVTable {
   gpointer (*malloc)(gsize  ) ;
   gpointer (*realloc)(gpointer  , gsize  ) ;
   void (*free)(gpointer  ) ;
   gpointer (*calloc)(gsize  , gsize  ) ;
   gpointer (*try_malloc)(gsize  ) ;
   gpointer (*try_realloc)(gpointer  , gsize  ) ;
};
#line 36 "/usr/include/glib-2.0/glib/gnode.h"
struct _GNode ;
#line 36 "/usr/include/glib-2.0/glib/gnode.h"
typedef struct _GNode GNode;
#line 39
enum __anonenum__63 {
    G_TRAVERSE_LEAVES = 1,
    G_TRAVERSE_NON_LEAVES = 2,
    G_TRAVERSE_ALL = 3,
    G_TRAVERSE_MASK = 3,
    G_TRAVERSE_LEAFS = 1,
    G_TRAVERSE_NON_LEAFS = 2
} ;
#line 47 "/usr/include/glib-2.0/glib/gnode.h"
typedef enum __anonenum__63 GTraverseFlags;
#line 50
enum __anonenum__64 {
    G_IN_ORDER = 0,
    G_PRE_ORDER = 1,
    G_POST_ORDER = 2,
    G_LEVEL_ORDER = 3
} ;
#line 56 "/usr/include/glib-2.0/glib/gnode.h"
typedef enum __anonenum__64 GTraverseType;
#line 58 "/usr/include/glib-2.0/glib/gnode.h"
typedef gboolean (*GNodeTraverseFunc)(GNode * , gpointer  );
#line 60 "/usr/include/glib-2.0/glib/gnode.h"
typedef void (*GNodeForeachFunc)(GNode * , gpointer  );
#line 65 "/usr/include/glib-2.0/glib/gnode.h"
struct _GNode {
   gpointer data ;
   GNode *next ;
   GNode *prev ;
   GNode *parent ;
   GNode *children ;
};
#line 37 "/usr/include/glib-2.0/glib/glist.h"
struct _GList ;
#line 37 "/usr/include/glib-2.0/glib/glist.h"
typedef struct _GList GList;
#line 39 "/usr/include/glib-2.0/glib/glist.h"
struct _GList {
   gpointer data ;
   GList *next ;
   GList *prev ;
};
#line 37 "/usr/include/glib-2.0/glib/ghash.h"
struct _GHashTable ;
#line 37 "/usr/include/glib-2.0/glib/ghash.h"
typedef struct _GHashTable GHashTable;
#line 39 "/usr/include/glib-2.0/glib/ghash.h"
typedef gboolean (*GHRFunc)(gpointer  , gpointer  , gpointer  );
#line 43
struct _GHashTableIter ;
#line 43 "/usr/include/glib-2.0/glib/ghash.h"
typedef struct _GHashTableIter GHashTableIter;
#line 45 "/usr/include/glib-2.0/glib/ghash.h"
struct _GHashTableIter {
   gpointer dummy1 ;
   gpointer dummy2 ;
   gpointer dummy3 ;
   int dummy4 ;
   gboolean dummy5 ;
   gpointer dummy6 ;
};
#line 40 "/usr/include/glib-2.0/glib/ghmac.h"
struct _GHmac ;
#line 40 "/usr/include/glib-2.0/glib/ghmac.h"
typedef struct _GHmac GHmac;
#line 38 "/usr/include/glib-2.0/glib/ghook.h"
struct _GHook ;
#line 38 "/usr/include/glib-2.0/glib/ghook.h"
typedef struct _GHook GHook;
#line 39
struct _GHookList ;
#line 39 "/usr/include/glib-2.0/glib/ghook.h"
typedef struct _GHookList GHookList;
#line 41 "/usr/include/glib-2.0/glib/ghook.h"
typedef gint (*GHookCompareFunc)(GHook * , GHook * );
#line 43 "/usr/include/glib-2.0/glib/ghook.h"
typedef gboolean (*GHookFindFunc)(GHook * , gpointer  );
#line 45 "/usr/include/glib-2.0/glib/ghook.h"
typedef void (*GHookMarshaller)(GHook * , gpointer  );
#line 47 "/usr/include/glib-2.0/glib/ghook.h"
typedef gboolean (*GHookCheckMarshaller)(GHook * , gpointer  );
#line 49 "/usr/include/glib-2.0/glib/ghook.h"
typedef void (*GHookFunc)(gpointer  );
#line 50 "/usr/include/glib-2.0/glib/ghook.h"
typedef gboolean (*GHookCheckFunc)(gpointer  );
#line 51 "/usr/include/glib-2.0/glib/ghook.h"
typedef void (*GHookFinalizeFunc)(GHookList * , GHook * );
#line 53
enum __anonenum__65 {
    G_HOOK_FLAG_ACTIVE = 1,
    G_HOOK_FLAG_IN_CALL = 2,
    G_HOOK_FLAG_MASK = 15
} ;
#line 58 "/usr/include/glib-2.0/glib/ghook.h"
typedef enum __anonenum__65 GHookFlagMask;
#line 63 "/usr/include/glib-2.0/glib/ghook.h"
struct _GHookList {
   gulong seq_id ;
   guint hook_size ;
   guint is_setup ;
   GHook *hooks ;
   gpointer dummy3 ;
   GHookFinalizeFunc finalize_hook ;
   gpointer dummy[2] ;
};
#line 73 "/usr/include/glib-2.0/glib/ghook.h"
struct _GHook {
   gpointer data ;
   GHook *next ;
   GHook *prev ;
   guint ref_count ;
   gulong hook_id ;
   guint flags ;
   gpointer func ;
   GDestroyNotify destroy ;
};
#line 59 "/usr/include/glib-2.0/glib/gpoll.h"
struct _GPollFD ;
#line 59 "/usr/include/glib-2.0/glib/gpoll.h"
typedef struct _GPollFD GPollFD;
#line 74 "/usr/include/glib-2.0/glib/gpoll.h"
typedef gint (*GPollFunc)(GPollFD * , guint  , gint  );
#line 91 "/usr/include/glib-2.0/glib/gpoll.h"
struct _GPollFD {
   gint fd ;
   gushort events ;
   gushort revents ;
};
#line 37 "/usr/include/glib-2.0/glib/gslist.h"
struct _GSList ;
#line 37 "/usr/include/glib-2.0/glib/gslist.h"
typedef struct _GSList GSList;
#line 39 "/usr/include/glib-2.0/glib/gslist.h"
struct _GSList {
   gpointer data ;
   GSList *next ;
};
#line 31 "/usr/include/glib-2.0/glib/gmain.h"
enum __anonenum__66 {
    G_IO_IN = 1,
    G_IO_OUT = 4,
    G_IO_PRI = 2,
    G_IO_ERR = 8,
    G_IO_HUP = 16,
    G_IO_NVAL = 32
} ;
#line 39 "/usr/include/glib-2.0/glib/gmain.h"
typedef enum __anonenum__66 GIOCondition;
#line 55
enum __anonenum__67 {
    G_MAIN_CONTEXT_FLAGS_NONE = 0,
    G_MAIN_CONTEXT_FLAGS_OWNERLESS_POLLING = 1
} ;
#line 59 "/usr/include/glib-2.0/glib/gmain.h"
typedef enum __anonenum__67 GMainContextFlags;
#line 68
struct _GMainContext ;
#line 68 "/usr/include/glib-2.0/glib/gmain.h"
typedef struct _GMainContext GMainContext;
#line 76
struct _GMainLoop ;
#line 76 "/usr/include/glib-2.0/glib/gmain.h"
typedef struct _GMainLoop GMainLoop;
#line 84
struct _GSource ;
#line 84 "/usr/include/glib-2.0/glib/gmain.h"
typedef struct _GSource GSource;
#line 85
struct _GSourcePrivate ;
#line 85 "/usr/include/glib-2.0/glib/gmain.h"
typedef struct _GSourcePrivate GSourcePrivate;
#line 97
struct _GSourceCallbackFuncs ;
#line 97 "/usr/include/glib-2.0/glib/gmain.h"
typedef struct _GSourceCallbackFuncs GSourceCallbackFuncs;
#line 153
struct _GSourceFuncs ;
#line 153 "/usr/include/glib-2.0/glib/gmain.h"
typedef struct _GSourceFuncs GSourceFuncs;
#line 193 "/usr/include/glib-2.0/glib/gmain.h"
typedef gboolean (*GSourceFunc)(gpointer  );
#line 228 "/usr/include/glib-2.0/glib/gmain.h"
typedef void (*GChildWatchFunc)(GPid  , gint  , gpointer  );
#line 243 "/usr/include/glib-2.0/glib/gmain.h"
typedef void (*GSourceDisposeFunc)(GSource * );
#line 245 "/usr/include/glib-2.0/glib/gmain.h"
struct _GSource {
   gpointer callback_data ;
   GSourceCallbackFuncs *callback_funcs ;
   GSourceFuncs *source_funcs ;
   guint ref_count ;
   GMainContext *context ;
   gint priority ;
   guint flags ;
   guint source_id ;
   GSList *poll_fds ;
   GSource *prev ;
   GSource *next ;
   char *name ;
   GSourcePrivate *priv ;
};
#line 270 "/usr/include/glib-2.0/glib/gmain.h"
struct _GSourceCallbackFuncs {
   void (*ref)(gpointer  ) ;
   void (*unref)(gpointer  ) ;
   void (*get)(gpointer  , GSource * , GSourceFunc * , gpointer * ) ;
};
#line 286 "/usr/include/glib-2.0/glib/gmain.h"
typedef void (*GSourceDummyMarshal)(void);
#line 288 "/usr/include/glib-2.0/glib/gmain.h"
struct _GSourceFuncs {
   gboolean (*prepare)(GSource * , gint * ) ;
   gboolean (*check)(GSource * ) ;
   gboolean (*dispatch)(GSource * , GSourceFunc  , gpointer  ) ;
   void (*finalize)(GSource * ) ;
   GSourceFunc closure_callback ;
   GSourceDummyMarshal closure_marshal ;
};
#line 482 "/usr/include/glib-2.0/glib/gmain.h"
typedef void GMainContextPusher;
#line 741 "/usr/include/glib-2.0/glib/gmain.h"
typedef void (*GClearHandleFunc)(guint  );
#line 59 "/usr/include/glib-2.0/glib/gunicode.h"
typedef guint32 gunichar;
#line 77 "/usr/include/glib-2.0/glib/gunicode.h"
typedef guint16 gunichar2;
#line 116
enum __anonenum__68 {
    G_UNICODE_CONTROL = 0,
    G_UNICODE_FORMAT = 1,
    G_UNICODE_UNASSIGNED = 2,
    G_UNICODE_PRIVATE_USE = 3,
    G_UNICODE_SURROGATE = 4,
    G_UNICODE_LOWERCASE_LETTER = 5,
    G_UNICODE_MODIFIER_LETTER = 6,
    G_UNICODE_OTHER_LETTER = 7,
    G_UNICODE_TITLECASE_LETTER = 8,
    G_UNICODE_UPPERCASE_LETTER = 9,
    G_UNICODE_SPACING_MARK = 10,
    G_UNICODE_ENCLOSING_MARK = 11,
    G_UNICODE_NON_SPACING_MARK = 12,
    G_UNICODE_DECIMAL_NUMBER = 13,
    G_UNICODE_LETTER_NUMBER = 14,
    G_UNICODE_OTHER_NUMBER = 15,
    G_UNICODE_CONNECT_PUNCTUATION = 16,
    G_UNICODE_DASH_PUNCTUATION = 17,
    G_UNICODE_CLOSE_PUNCTUATION = 18,
    G_UNICODE_FINAL_PUNCTUATION = 19,
    G_UNICODE_INITIAL_PUNCTUATION = 20,
    G_UNICODE_OTHER_PUNCTUATION = 21,
    G_UNICODE_OPEN_PUNCTUATION = 22,
    G_UNICODE_CURRENCY_SYMBOL = 23,
    G_UNICODE_MODIFIER_SYMBOL = 24,
    G_UNICODE_MATH_SYMBOL = 25,
    G_UNICODE_OTHER_SYMBOL = 26,
    G_UNICODE_LINE_SEPARATOR = 27,
    G_UNICODE_PARAGRAPH_SEPARATOR = 28,
    G_UNICODE_SPACE_SEPARATOR = 29
} ;
#line 148 "/usr/include/glib-2.0/glib/gunicode.h"
typedef enum __anonenum__68 GUnicodeType;
#line 213
enum __anonenum__69 {
    G_UNICODE_BREAK_MANDATORY = 0,
    G_UNICODE_BREAK_CARRIAGE_RETURN = 1,
    G_UNICODE_BREAK_LINE_FEED = 2,
    G_UNICODE_BREAK_COMBINING_MARK = 3,
    G_UNICODE_BREAK_SURROGATE = 4,
    G_UNICODE_BREAK_ZERO_WIDTH_SPACE = 5,
    G_UNICODE_BREAK_INSEPARABLE = 6,
    G_UNICODE_BREAK_NON_BREAKING_GLUE = 7,
    G_UNICODE_BREAK_CONTINGENT = 8,
    G_UNICODE_BREAK_SPACE = 9,
    G_UNICODE_BREAK_AFTER = 10,
    G_UNICODE_BREAK_BEFORE = 11,
    G_UNICODE_BREAK_BEFORE_AND_AFTER = 12,
    G_UNICODE_BREAK_HYPHEN = 13,
    G_UNICODE_BREAK_NON_STARTER = 14,
    G_UNICODE_BREAK_OPEN_PUNCTUATION = 15,
    G_UNICODE_BREAK_CLOSE_PUNCTUATION = 16,
    G_UNICODE_BREAK_QUOTATION = 17,
    G_UNICODE_BREAK_EXCLAMATION = 18,
    G_UNICODE_BREAK_IDEOGRAPHIC = 19,
    G_UNICODE_BREAK_NUMERIC = 20,
    G_UNICODE_BREAK_INFIX_SEPARATOR = 21,
    G_UNICODE_BREAK_SYMBOL = 22,
    G_UNICODE_BREAK_ALPHABETIC = 23,
    G_UNICODE_BREAK_PREFIX = 24,
    G_UNICODE_BREAK_POSTFIX = 25,
    G_UNICODE_BREAK_COMPLEX_CONTEXT = 26,
    G_UNICODE_BREAK_AMBIGUOUS = 27,
    G_UNICODE_BREAK_UNKNOWN = 28,
    G_UNICODE_BREAK_NEXT_LINE = 29,
    G_UNICODE_BREAK_WORD_JOINER = 30,
    G_UNICODE_BREAK_HANGUL_L_JAMO = 31,
    G_UNICODE_BREAK_HANGUL_V_JAMO = 32,
    G_UNICODE_BREAK_HANGUL_T_JAMO = 33,
    G_UNICODE_BREAK_HANGUL_LV_SYLLABLE = 34,
    G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE = 35,
    G_UNICODE_BREAK_CLOSE_PARANTHESIS = 36,
    G_UNICODE_BREAK_CLOSE_PARENTHESIS = 36,
    G_UNICODE_BREAK_CONDITIONAL_JAPANESE_STARTER = 37,
    G_UNICODE_BREAK_HEBREW_LETTER = 38,
    G_UNICODE_BREAK_REGIONAL_INDICATOR = 39,
    G_UNICODE_BREAK_EMOJI_BASE = 40,
    G_UNICODE_BREAK_EMOJI_MODIFIER = 41,
    G_UNICODE_BREAK_ZERO_WIDTH_JOINER = 42
} ;
#line 259 "/usr/include/glib-2.0/glib/gunicode.h"
typedef enum __anonenum__69 GUnicodeBreakType;
#line 449
enum __anonenum__70 {
    G_UNICODE_SCRIPT_INVALID_CODE = -1,
    G_UNICODE_SCRIPT_COMMON = 0,
    G_UNICODE_SCRIPT_INHERITED = 1,
    G_UNICODE_SCRIPT_ARABIC = 2,
    G_UNICODE_SCRIPT_ARMENIAN = 3,
    G_UNICODE_SCRIPT_BENGALI = 4,
    G_UNICODE_SCRIPT_BOPOMOFO = 5,
    G_UNICODE_SCRIPT_CHEROKEE = 6,
    G_UNICODE_SCRIPT_COPTIC = 7,
    G_UNICODE_SCRIPT_CYRILLIC = 8,
    G_UNICODE_SCRIPT_DESERET = 9,
    G_UNICODE_SCRIPT_DEVANAGARI = 10,
    G_UNICODE_SCRIPT_ETHIOPIC = 11,
    G_UNICODE_SCRIPT_GEORGIAN = 12,
    G_UNICODE_SCRIPT_GOTHIC = 13,
    G_UNICODE_SCRIPT_GREEK = 14,
    G_UNICODE_SCRIPT_GUJARATI = 15,
    G_UNICODE_SCRIPT_GURMUKHI = 16,
    G_UNICODE_SCRIPT_HAN = 17,
    G_UNICODE_SCRIPT_HANGUL = 18,
    G_UNICODE_SCRIPT_HEBREW = 19,
    G_UNICODE_SCRIPT_HIRAGANA = 20,
    G_UNICODE_SCRIPT_KANNADA = 21,
    G_UNICODE_SCRIPT_KATAKANA = 22,
    G_UNICODE_SCRIPT_KHMER = 23,
    G_UNICODE_SCRIPT_LAO = 24,
    G_UNICODE_SCRIPT_LATIN = 25,
    G_UNICODE_SCRIPT_MALAYALAM = 26,
    G_UNICODE_SCRIPT_MONGOLIAN = 27,
    G_UNICODE_SCRIPT_MYANMAR = 28,
    G_UNICODE_SCRIPT_OGHAM = 29,
    G_UNICODE_SCRIPT_OLD_ITALIC = 30,
    G_UNICODE_SCRIPT_ORIYA = 31,
    G_UNICODE_SCRIPT_RUNIC = 32,
    G_UNICODE_SCRIPT_SINHALA = 33,
    G_UNICODE_SCRIPT_SYRIAC = 34,
    G_UNICODE_SCRIPT_TAMIL = 35,
    G_UNICODE_SCRIPT_TELUGU = 36,
    G_UNICODE_SCRIPT_THAANA = 37,
    G_UNICODE_SCRIPT_THAI = 38,
    G_UNICODE_SCRIPT_TIBETAN = 39,
    G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL = 40,
    G_UNICODE_SCRIPT_YI = 41,
    G_UNICODE_SCRIPT_TAGALOG = 42,
    G_UNICODE_SCRIPT_HANUNOO = 43,
    G_UNICODE_SCRIPT_BUHID = 44,
    G_UNICODE_SCRIPT_TAGBANWA = 45,
    G_UNICODE_SCRIPT_BRAILLE = 46,
    G_UNICODE_SCRIPT_CYPRIOT = 47,
    G_UNICODE_SCRIPT_LIMBU = 48,
    G_UNICODE_SCRIPT_OSMANYA = 49,
    G_UNICODE_SCRIPT_SHAVIAN = 50,
    G_UNICODE_SCRIPT_LINEAR_B = 51,
    G_UNICODE_SCRIPT_TAI_LE = 52,
    G_UNICODE_SCRIPT_UGARITIC = 53,
    G_UNICODE_SCRIPT_NEW_TAI_LUE = 54,
    G_UNICODE_SCRIPT_BUGINESE = 55,
    G_UNICODE_SCRIPT_GLAGOLITIC = 56,
    G_UNICODE_SCRIPT_TIFINAGH = 57,
    G_UNICODE_SCRIPT_SYLOTI_NAGRI = 58,
    G_UNICODE_SCRIPT_OLD_PERSIAN = 59,
    G_UNICODE_SCRIPT_KHAROSHTHI = 60,
    G_UNICODE_SCRIPT_UNKNOWN = 61,
    G_UNICODE_SCRIPT_BALINESE = 62,
    G_UNICODE_SCRIPT_CUNEIFORM = 63,
    G_UNICODE_SCRIPT_PHOENICIAN = 64,
    G_UNICODE_SCRIPT_PHAGS_PA = 65,
    G_UNICODE_SCRIPT_NKO = 66,
    G_UNICODE_SCRIPT_KAYAH_LI = 67,
    G_UNICODE_SCRIPT_LEPCHA = 68,
    G_UNICODE_SCRIPT_REJANG = 69,
    G_UNICODE_SCRIPT_SUNDANESE = 70,
    G_UNICODE_SCRIPT_SAURASHTRA = 71,
    G_UNICODE_SCRIPT_CHAM = 72,
    G_UNICODE_SCRIPT_OL_CHIKI = 73,
    G_UNICODE_SCRIPT_VAI = 74,
    G_UNICODE_SCRIPT_CARIAN = 75,
    G_UNICODE_SCRIPT_LYCIAN = 76,
    G_UNICODE_SCRIPT_LYDIAN = 77,
    G_UNICODE_SCRIPT_AVESTAN = 78,
    G_UNICODE_SCRIPT_BAMUM = 79,
    G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS = 80,
    G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC = 81,
    G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI = 82,
    G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN = 83,
    G_UNICODE_SCRIPT_JAVANESE = 84,
    G_UNICODE_SCRIPT_KAITHI = 85,
    G_UNICODE_SCRIPT_LISU = 86,
    G_UNICODE_SCRIPT_MEETEI_MAYEK = 87,
    G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN = 88,
    G_UNICODE_SCRIPT_OLD_TURKIC = 89,
    G_UNICODE_SCRIPT_SAMARITAN = 90,
    G_UNICODE_SCRIPT_TAI_THAM = 91,
    G_UNICODE_SCRIPT_TAI_VIET = 92,
    G_UNICODE_SCRIPT_BATAK = 93,
    G_UNICODE_SCRIPT_BRAHMI = 94,
    G_UNICODE_SCRIPT_MANDAIC = 95,
    G_UNICODE_SCRIPT_CHAKMA = 96,
    G_UNICODE_SCRIPT_MEROITIC_CURSIVE = 97,
    G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS = 98,
    G_UNICODE_SCRIPT_MIAO = 99,
    G_UNICODE_SCRIPT_SHARADA = 100,
    G_UNICODE_SCRIPT_SORA_SOMPENG = 101,
    G_UNICODE_SCRIPT_TAKRI = 102,
    G_UNICODE_SCRIPT_BASSA_VAH = 103,
    G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN = 104,
    G_UNICODE_SCRIPT_DUPLOYAN = 105,
    G_UNICODE_SCRIPT_ELBASAN = 106,
    G_UNICODE_SCRIPT_GRANTHA = 107,
    G_UNICODE_SCRIPT_KHOJKI = 108,
    G_UNICODE_SCRIPT_KHUDAWADI = 109,
    G_UNICODE_SCRIPT_LINEAR_A = 110,
    G_UNICODE_SCRIPT_MAHAJANI = 111,
    G_UNICODE_SCRIPT_MANICHAEAN = 112,
    G_UNICODE_SCRIPT_MENDE_KIKAKUI = 113,
    G_UNICODE_SCRIPT_MODI = 114,
    G_UNICODE_SCRIPT_MRO = 115,
    G_UNICODE_SCRIPT_NABATAEAN = 116,
    G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN = 117,
    G_UNICODE_SCRIPT_OLD_PERMIC = 118,
    G_UNICODE_SCRIPT_PAHAWH_HMONG = 119,
    G_UNICODE_SCRIPT_PALMYRENE = 120,
    G_UNICODE_SCRIPT_PAU_CIN_HAU = 121,
    G_UNICODE_SCRIPT_PSALTER_PAHLAVI = 122,
    G_UNICODE_SCRIPT_SIDDHAM = 123,
    G_UNICODE_SCRIPT_TIRHUTA = 124,
    G_UNICODE_SCRIPT_WARANG_CITI = 125,
    G_UNICODE_SCRIPT_AHOM = 126,
    G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS = 127,
    G_UNICODE_SCRIPT_HATRAN = 128,
    G_UNICODE_SCRIPT_MULTANI = 129,
    G_UNICODE_SCRIPT_OLD_HUNGARIAN = 130,
    G_UNICODE_SCRIPT_SIGNWRITING = 131,
    G_UNICODE_SCRIPT_ADLAM = 132,
    G_UNICODE_SCRIPT_BHAIKSUKI = 133,
    G_UNICODE_SCRIPT_MARCHEN = 134,
    G_UNICODE_SCRIPT_NEWA = 135,
    G_UNICODE_SCRIPT_OSAGE = 136,
    G_UNICODE_SCRIPT_TANGUT = 137,
    G_UNICODE_SCRIPT_MASARAM_GONDI = 138,
    G_UNICODE_SCRIPT_NUSHU = 139,
    G_UNICODE_SCRIPT_SOYOMBO = 140,
    G_UNICODE_SCRIPT_ZANABAZAR_SQUARE = 141,
    G_UNICODE_SCRIPT_DOGRA = 142,
    G_UNICODE_SCRIPT_GUNJALA_GONDI = 143,
    G_UNICODE_SCRIPT_HANIFI_ROHINGYA = 144,
    G_UNICODE_SCRIPT_MAKASAR = 145,
    G_UNICODE_SCRIPT_MEDEFAIDRIN = 146,
    G_UNICODE_SCRIPT_OLD_SOGDIAN = 147,
    G_UNICODE_SCRIPT_SOGDIAN = 148,
    G_UNICODE_SCRIPT_ELYMAIC = 149,
    G_UNICODE_SCRIPT_NANDINAGARI = 150,
    G_UNICODE_SCRIPT_NYIAKENG_PUACHUE_HMONG = 151,
    G_UNICODE_SCRIPT_WANCHO = 152,
    G_UNICODE_SCRIPT_CHORASMIAN = 153,
    G_UNICODE_SCRIPT_DIVES_AKURU = 154,
    G_UNICODE_SCRIPT_KHITAN_SMALL_SCRIPT = 155,
    G_UNICODE_SCRIPT_YEZIDI = 156,
    G_UNICODE_SCRIPT_CYPRO_MINOAN = 157,
    G_UNICODE_SCRIPT_OLD_UYGHUR = 158,
    G_UNICODE_SCRIPT_TANGSA = 159,
    G_UNICODE_SCRIPT_TOTO = 160,
    G_UNICODE_SCRIPT_VITHKUQI = 161,
    G_UNICODE_SCRIPT_MATH = 162
} ;
#line 647 "/usr/include/glib-2.0/glib/gunicode.h"
typedef enum __anonenum__70 GUnicodeScript;
#line 930
enum __anonenum__71 {
    G_NORMALIZE_DEFAULT = 0,
    G_NORMALIZE_NFD = 0,
    G_NORMALIZE_DEFAULT_COMPOSE = 1,
    G_NORMALIZE_NFC = 1,
    G_NORMALIZE_ALL = 2,
    G_NORMALIZE_NFKD = 2,
    G_NORMALIZE_ALL_COMPOSE = 3,
    G_NORMALIZE_NFKC = 3
} ;
#line 939 "/usr/include/glib-2.0/glib/gunicode.h"
typedef enum __anonenum__71 GNormalizeMode;
#line 39 "/usr/include/glib-2.0/glib/gstring.h"
struct _GString ;
#line 39 "/usr/include/glib-2.0/glib/gstring.h"
typedef struct _GString GString;
#line 41 "/usr/include/glib-2.0/glib/gstring.h"
struct _GString {
   gchar *str ;
   gsize len ;
   gsize allocated_len ;
};
#line 41 "/usr/include/glib-2.0/glib/giochannel.h"
struct _GIOChannel ;
#line 41 "/usr/include/glib-2.0/glib/giochannel.h"
typedef struct _GIOChannel GIOChannel;
#line 42
struct _GIOFuncs ;
#line 42 "/usr/include/glib-2.0/glib/giochannel.h"
typedef struct _GIOFuncs GIOFuncs;
#line 44
enum __anonenum__72 {
    G_IO_ERROR_NONE = 0,
    G_IO_ERROR_AGAIN = 1,
    G_IO_ERROR_INVAL = 2,
    G_IO_ERROR_UNKNOWN = 3
} ;
#line 50 "/usr/include/glib-2.0/glib/giochannel.h"
typedef enum __anonenum__72 GIOError;
#line 54
enum __anonenum__73 {
    G_IO_CHANNEL_ERROR_FBIG = 0,
    G_IO_CHANNEL_ERROR_INVAL = 1,
    G_IO_CHANNEL_ERROR_IO = 2,
    G_IO_CHANNEL_ERROR_ISDIR = 3,
    G_IO_CHANNEL_ERROR_NOSPC = 4,
    G_IO_CHANNEL_ERROR_NXIO = 5,
    G_IO_CHANNEL_ERROR_OVERFLOW = 6,
    G_IO_CHANNEL_ERROR_PIPE = 7,
    G_IO_CHANNEL_ERROR_FAILED = 8
} ;
#line 67 "/usr/include/glib-2.0/glib/giochannel.h"
typedef enum __anonenum__73 GIOChannelError;
#line 69
enum __anonenum__74 {
    G_IO_STATUS_ERROR = 0,
    G_IO_STATUS_NORMAL = 1,
    G_IO_STATUS_EOF = 2,
    G_IO_STATUS_AGAIN = 3
} ;
#line 75 "/usr/include/glib-2.0/glib/giochannel.h"
typedef enum __anonenum__74 GIOStatus;
#line 77
enum __anonenum__75 {
    G_SEEK_CUR = 0,
    G_SEEK_SET = 1,
    G_SEEK_END = 2
} ;
#line 82 "/usr/include/glib-2.0/glib/giochannel.h"
typedef enum __anonenum__75 GSeekType;
#line 84
enum __anonenum__76 {
    G_IO_FLAG_APPEND = 1,
    G_IO_FLAG_NONBLOCK = 2,
    G_IO_FLAG_IS_READABLE = 4,
    G_IO_FLAG_IS_WRITABLE = 8,
    G_IO_FLAG_IS_WRITEABLE = 8,
    G_IO_FLAG_IS_SEEKABLE = 16,
    G_IO_FLAG_MASK = 31,
    G_IO_FLAG_GET_MASK = 31,
    G_IO_FLAG_SET_MASK = 3
} ;
#line 95 "/usr/include/glib-2.0/glib/giochannel.h"
typedef enum __anonenum__76 GIOFlags;
#line 97 "/usr/include/glib-2.0/glib/giochannel.h"
struct _GIOChannel {
   gint ref_count ;
   GIOFuncs *funcs ;
   gchar *encoding ;
   GIConv read_cd ;
   GIConv write_cd ;
   gchar *line_term ;
   guint line_term_len ;
   gsize buf_size ;
   GString *read_buf ;
   GString *encoded_read_buf ;
   GString *write_buf ;
   gchar partial_write_buf[6] ;
   guint use_buffer ;
   guint do_encode ;
   guint close_on_unref ;
   guint is_readable ;
   guint is_writeable ;
   guint is_seekable ;
   gpointer reserved1 ;
   gpointer reserved2 ;
};
#line 128 "/usr/include/glib-2.0/glib/giochannel.h"
typedef gboolean (*GIOFunc)(GIOChannel * , GIOCondition  , gpointer  );
#line 131 "/usr/include/glib-2.0/glib/giochannel.h"
struct _GIOFuncs {
   GIOStatus (*io_read)(GIOChannel * , gchar * , gsize  , gsize * , GError ** ) ;
   GIOStatus (*io_write)(GIOChannel * , gchar * , gsize  , gsize * , GError ** ) ;
   GIOStatus (*io_seek)(GIOChannel * , gint64  , GSeekType  , GError ** ) ;
   GIOStatus (*io_close)(GIOChannel * , GError ** ) ;
   GSource *(*io_create_watch)(GIOChannel * , GIOCondition  ) ;
   void (*io_free)(GIOChannel * ) ;
   GIOStatus (*io_set_flags)(GIOChannel * , GIOFlags  , GError ** ) ;
   GIOFlags (*io_get_flags)(GIOChannel * ) ;
};
#line 33 "/usr/include/glib-2.0/glib/gkeyfile.h"
enum __anonenum__77 {
    G_KEY_FILE_ERROR_UNKNOWN_ENCODING = 0,
    G_KEY_FILE_ERROR_PARSE = 1,
    G_KEY_FILE_ERROR_NOT_FOUND = 2,
    G_KEY_FILE_ERROR_KEY_NOT_FOUND = 3,
    G_KEY_FILE_ERROR_GROUP_NOT_FOUND = 4,
    G_KEY_FILE_ERROR_INVALID_VALUE = 5
} ;
#line 41 "/usr/include/glib-2.0/glib/gkeyfile.h"
typedef enum __anonenum__77 GKeyFileError;
#line 48
struct _GKeyFile ;
#line 48 "/usr/include/glib-2.0/glib/gkeyfile.h"
typedef struct _GKeyFile GKeyFile;
#line 50
enum __anonenum__78 {
    G_KEY_FILE_NONE = 0,
    G_KEY_FILE_KEEP_COMMENTS = 1,
    G_KEY_FILE_KEEP_TRANSLATIONS = 2
} ;
#line 55 "/usr/include/glib-2.0/glib/gkeyfile.h"
typedef enum __anonenum__78 GKeyFileFlags;
#line 32 "/usr/include/glib-2.0/glib/gmappedfile.h"
struct _GMappedFile ;
#line 32 "/usr/include/glib-2.0/glib/gmappedfile.h"
typedef struct _GMappedFile GMappedFile;
#line 49 "/usr/include/glib-2.0/glib/gmarkup.h"
enum __anonenum__79 {
    G_MARKUP_ERROR_BAD_UTF8 = 0,
    G_MARKUP_ERROR_EMPTY = 1,
    G_MARKUP_ERROR_PARSE = 2,
    G_MARKUP_ERROR_UNKNOWN_ELEMENT = 3,
    G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE = 4,
    G_MARKUP_ERROR_INVALID_CONTENT = 5,
    G_MARKUP_ERROR_MISSING_ATTRIBUTE = 6
} ;
#line 61 "/usr/include/glib-2.0/glib/gmarkup.h"
typedef enum __anonenum__79 GMarkupError;
#line 95
enum __anonenum__80 {
    G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG = 1,
    G_MARKUP_TREAT_CDATA_AS_TEXT = 2,
    G_MARKUP_PREFIX_ERROR_POSITION = 4,
    G_MARKUP_IGNORE_QUALIFIED = 8
} ;
#line 101 "/usr/include/glib-2.0/glib/gmarkup.h"
typedef enum __anonenum__80 GMarkupParseFlags;
#line 112
struct _GMarkupParseContext ;
#line 112 "/usr/include/glib-2.0/glib/gmarkup.h"
typedef struct _GMarkupParseContext GMarkupParseContext;
#line 113
struct _GMarkupParser ;
#line 113 "/usr/include/glib-2.0/glib/gmarkup.h"
typedef struct _GMarkupParser GMarkupParser;
#line 143 "/usr/include/glib-2.0/glib/gmarkup.h"
struct _GMarkupParser {
   void (*start_element)(GMarkupParseContext * , gchar * , gchar ** , gchar ** , gpointer  ,
                         GError ** ) ;
   void (*end_element)(GMarkupParseContext * , gchar * , gpointer  , GError ** ) ;
   void (*text)(GMarkupParseContext * , gchar * , gsize  , gpointer  , GError ** ) ;
   void (*passthrough)(GMarkupParseContext * , gchar * , gsize  , gpointer  , GError ** ) ;
   void (*error)(GMarkupParseContext * , GError * , gpointer  ) ;
};
#line 237
enum __anonenum__81 {
    G_MARKUP_COLLECT_INVALID = 0,
    G_MARKUP_COLLECT_STRING = 1,
    G_MARKUP_COLLECT_STRDUP = 2,
    G_MARKUP_COLLECT_BOOLEAN = 3,
    G_MARKUP_COLLECT_TRISTATE = 4,
    G_MARKUP_COLLECT_OPTIONAL = 65536
} ;
#line 246 "/usr/include/glib-2.0/glib/gmarkup.h"
typedef enum __anonenum__81 GMarkupCollectType;
#line 41 "/usr/include/glib-2.0/glib/gvarianttype.h"
struct _GVariantType ;
#line 41 "/usr/include/glib-2.0/glib/gvarianttype.h"
typedef struct _GVariantType GVariantType;
#line 34 "/usr/include/glib-2.0/glib/gvariant.h"
struct _GVariant ;
#line 34 "/usr/include/glib-2.0/glib/gvariant.h"
typedef struct _GVariant GVariant;
#line 36
enum __anonenum__82 {
    G_VARIANT_CLASS_BOOLEAN = 98,
    G_VARIANT_CLASS_BYTE = 121,
    G_VARIANT_CLASS_INT16 = 110,
    G_VARIANT_CLASS_UINT16 = 113,
    G_VARIANT_CLASS_INT32 = 105,
    G_VARIANT_CLASS_UINT32 = 117,
    G_VARIANT_CLASS_INT64 = 120,
    G_VARIANT_CLASS_UINT64 = 116,
    G_VARIANT_CLASS_HANDLE = 104,
    G_VARIANT_CLASS_DOUBLE = 100,
    G_VARIANT_CLASS_STRING = 115,
    G_VARIANT_CLASS_OBJECT_PATH = 111,
    G_VARIANT_CLASS_SIGNATURE = 103,
    G_VARIANT_CLASS_VARIANT = 118,
    G_VARIANT_CLASS_MAYBE = 109,
    G_VARIANT_CLASS_ARRAY = 97,
    G_VARIANT_CLASS_TUPLE = 40,
    G_VARIANT_CLASS_DICT_ENTRY = 123
} ;
#line 56 "/usr/include/glib-2.0/glib/gvariant.h"
typedef enum __anonenum__82 GVariantClass;
#line 268
struct _GVariantIter ;
#line 268 "/usr/include/glib-2.0/glib/gvariant.h"
typedef struct _GVariantIter GVariantIter;
#line 269 "/usr/include/glib-2.0/glib/gvariant.h"
struct _GVariantIter {
   gsize x[16] ;
};
#line 297
struct _GVariantBuilder ;
#line 297 "/usr/include/glib-2.0/glib/gvariant.h"
typedef struct _GVariantBuilder GVariantBuilder;
#line 302 "/usr/include/glib-2.0/glib/gvariant.h"
struct __anonstruct_84 {
   gsize partial_magic ;
   GVariantType *type ;
   gsize y[14] ;
};
#line 300 "/usr/include/glib-2.0/glib/gvariant.h"
union __anonunion_83 {
   struct __anonstruct_84 s ;
   gsize x[16] ;
};
#line 298 "/usr/include/glib-2.0/glib/gvariant.h"
struct _GVariantBuilder {
   union __anonunion_83 u ;
};
#line 311
enum __anonenum__85 {
    G_VARIANT_PARSE_ERROR_FAILED = 0,
    G_VARIANT_PARSE_ERROR_BASIC_TYPE_EXPECTED = 1,
    G_VARIANT_PARSE_ERROR_CANNOT_INFER_TYPE = 2,
    G_VARIANT_PARSE_ERROR_DEFINITE_TYPE_EXPECTED = 3,
    G_VARIANT_PARSE_ERROR_INPUT_NOT_AT_END = 4,
    G_VARIANT_PARSE_ERROR_INVALID_CHARACTER = 5,
    G_VARIANT_PARSE_ERROR_INVALID_FORMAT_STRING = 6,
    G_VARIANT_PARSE_ERROR_INVALID_OBJECT_PATH = 7,
    G_VARIANT_PARSE_ERROR_INVALID_SIGNATURE = 8,
    G_VARIANT_PARSE_ERROR_INVALID_TYPE_STRING = 9,
    G_VARIANT_PARSE_ERROR_NO_COMMON_TYPE = 10,
    G_VARIANT_PARSE_ERROR_NUMBER_OUT_OF_RANGE = 11,
    G_VARIANT_PARSE_ERROR_NUMBER_TOO_BIG = 12,
    G_VARIANT_PARSE_ERROR_TYPE_ERROR = 13,
    G_VARIANT_PARSE_ERROR_UNEXPECTED_TOKEN = 14,
    G_VARIANT_PARSE_ERROR_UNKNOWN_KEYWORD = 15,
    G_VARIANT_PARSE_ERROR_UNTERMINATED_STRING_CONSTANT = 16,
    G_VARIANT_PARSE_ERROR_VALUE_EXPECTED = 17,
    G_VARIANT_PARSE_ERROR_RECURSION = 18
} ;
#line 332 "/usr/include/glib-2.0/glib/gvariant.h"
typedef enum __anonenum__85 GVariantParseError;
#line 446
struct _GVariantDict ;
#line 446 "/usr/include/glib-2.0/glib/gvariant.h"
typedef struct _GVariantDict GVariantDict;
#line 451 "/usr/include/glib-2.0/glib/gvariant.h"
struct __anonstruct_87 {
   GVariant *asv ;
   gsize partial_magic ;
   gsize y[14] ;
};
#line 449 "/usr/include/glib-2.0/glib/gvariant.h"
union __anonunion_86 {
   struct __anonstruct_87 s ;
   gsize x[16] ;
};
#line 447 "/usr/include/glib-2.0/glib/gvariant.h"
struct _GVariantDict {
   union __anonunion_86 u ;
};
#line 53 "/usr/include/glib-2.0/glib/gmessages.h"
enum __anonenum__88 {
    G_LOG_FLAG_RECURSION = 1,
    G_LOG_FLAG_FATAL = 2,
    G_LOG_LEVEL_ERROR = 4,
    G_LOG_LEVEL_CRITICAL = 8,
    G_LOG_LEVEL_WARNING = 16,
    G_LOG_LEVEL_MESSAGE = 32,
    G_LOG_LEVEL_INFO = 64,
    G_LOG_LEVEL_DEBUG = 128,
    G_LOG_LEVEL_MASK = -4
} ;
#line 68 "/usr/include/glib-2.0/glib/gmessages.h"
typedef enum __anonenum__88 GLogLevelFlags;
#line 73 "/usr/include/glib-2.0/glib/gmessages.h"
typedef void (*GLogFunc)(gchar * , GLogLevelFlags  , gchar * , gpointer  );
#line 134
enum __anonenum__89 {
    G_LOG_WRITER_HANDLED = 1,
    G_LOG_WRITER_UNHANDLED = 0
} ;
#line 138 "/usr/include/glib-2.0/glib/gmessages.h"
typedef enum __anonenum__89 GLogWriterOutput;
#line 156
struct _GLogField ;
#line 156 "/usr/include/glib-2.0/glib/gmessages.h"
typedef struct _GLogField GLogField;
#line 157 "/usr/include/glib-2.0/glib/gmessages.h"
struct _GLogField {
   gchar *key ;
   gconstpointer value ;
   gssize length ;
};
#line 195 "/usr/include/glib-2.0/glib/gmessages.h"
typedef GLogWriterOutput (*GLogWriterFunc)(GLogLevelFlags  , GLogField * , gsize  ,
                                           gpointer  );
#line 515 "/usr/include/glib-2.0/glib/gmessages.h"
typedef void (*GPrintFunc)(gchar * );
#line 38 "/usr/include/glib-2.0/glib/goption.h"
struct _GOptionContext ;
#line 38 "/usr/include/glib-2.0/glib/goption.h"
typedef struct _GOptionContext GOptionContext;
#line 51
struct _GOptionGroup ;
#line 51 "/usr/include/glib-2.0/glib/goption.h"
typedef struct _GOptionGroup GOptionGroup;
#line 52
struct _GOptionEntry ;
#line 52 "/usr/include/glib-2.0/glib/goption.h"
typedef struct _GOptionEntry GOptionEntry;
#line 81
enum __anonenum__90 {
    G_OPTION_FLAG_NONE = 0,
    G_OPTION_FLAG_HIDDEN = 1,
    G_OPTION_FLAG_IN_MAIN = 2,
    G_OPTION_FLAG_REVERSE = 4,
    G_OPTION_FLAG_NO_ARG = 8,
    G_OPTION_FLAG_FILENAME = 16,
    G_OPTION_FLAG_OPTIONAL_ARG = 32,
    G_OPTION_FLAG_NOALIAS = 64
} ;
#line 91 "/usr/include/glib-2.0/glib/goption.h"
typedef enum __anonenum__90 GOptionFlags;
#line 119
enum __anonenum__91 {
    G_OPTION_ARG_NONE = 0,
    G_OPTION_ARG_STRING = 1,
    G_OPTION_ARG_INT = 2,
    G_OPTION_ARG_CALLBACK = 3,
    G_OPTION_ARG_FILENAME = 4,
    G_OPTION_ARG_STRING_ARRAY = 5,
    G_OPTION_ARG_FILENAME_ARRAY = 6,
    G_OPTION_ARG_DOUBLE = 7,
    G_OPTION_ARG_INT64 = 8
} ;
#line 130 "/usr/include/glib-2.0/glib/goption.h"
typedef enum __anonenum__91 GOptionArg;
#line 149 "/usr/include/glib-2.0/glib/goption.h"
typedef gboolean (*GOptionArgFunc)(gchar * , gchar * , gpointer  , GError ** );
#line 167 "/usr/include/glib-2.0/glib/goption.h"
typedef gboolean (*GOptionParseFunc)(GOptionContext * , GOptionGroup * , gpointer  ,
                                     GError ** );
#line 182 "/usr/include/glib-2.0/glib/goption.h"
typedef void (*GOptionErrorFunc)(GOptionContext * , GOptionGroup * , gpointer  , GError ** );
#line 206
enum __anonenum__92 {
    G_OPTION_ERROR_UNKNOWN_OPTION = 0,
    G_OPTION_ERROR_BAD_VALUE = 1,
    G_OPTION_ERROR_FAILED = 2
} ;
#line 211 "/usr/include/glib-2.0/glib/goption.h"
typedef enum __anonenum__92 GOptionError;
#line 258 "/usr/include/glib-2.0/glib/goption.h"
struct _GOptionEntry {
   gchar *long_name ;
   gchar short_name ;
   gint flags ;
   GOptionArg arg ;
   gpointer arg_data ;
   gchar *description ;
   gchar *arg_description ;
};
#line 30 "/usr/include/glib-2.0/glib/gpattern.h"
struct _GPatternSpec ;
#line 30 "/usr/include/glib-2.0/glib/gpattern.h"
typedef struct _GPatternSpec GPatternSpec;
#line 36 "/usr/include/glib-2.0/glib/gqueue.h"
struct _GQueue ;
#line 36 "/usr/include/glib-2.0/glib/gqueue.h"
typedef struct _GQueue GQueue;
#line 47 "/usr/include/glib-2.0/glib/gqueue.h"
struct _GQueue {
   GList *head ;
   GList *tail ;
   guint length ;
};
#line 36 "/usr/include/glib-2.0/glib/grand.h"
struct _GRand ;
#line 36 "/usr/include/glib-2.0/glib/grand.h"
typedef struct _GRand GRand;
#line 55 "/usr/include/glib-2.0/glib/grefstring.h"
typedef char GRefString;
#line 140 "/usr/include/glib-2.0/glib/gregex.h"
enum __anonenum__93 {
    G_REGEX_ERROR_COMPILE = 0,
    G_REGEX_ERROR_OPTIMIZE = 1,
    G_REGEX_ERROR_REPLACE = 2,
    G_REGEX_ERROR_MATCH = 3,
    G_REGEX_ERROR_INTERNAL = 4,
    G_REGEX_ERROR_STRAY_BACKSLASH = 101,
    G_REGEX_ERROR_MISSING_CONTROL_CHAR = 102,
    G_REGEX_ERROR_UNRECOGNIZED_ESCAPE = 103,
    G_REGEX_ERROR_QUANTIFIERS_OUT_OF_ORDER = 104,
    G_REGEX_ERROR_QUANTIFIER_TOO_BIG = 105,
    G_REGEX_ERROR_UNTERMINATED_CHARACTER_CLASS = 106,
    G_REGEX_ERROR_INVALID_ESCAPE_IN_CHARACTER_CLASS = 107,
    G_REGEX_ERROR_RANGE_OUT_OF_ORDER = 108,
    G_REGEX_ERROR_NOTHING_TO_REPEAT = 109,
    G_REGEX_ERROR_UNRECOGNIZED_CHARACTER = 112,
    G_REGEX_ERROR_POSIX_NAMED_CLASS_OUTSIDE_CLASS = 113,
    G_REGEX_ERROR_UNMATCHED_PARENTHESIS = 114,
    G_REGEX_ERROR_INEXISTENT_SUBPATTERN_REFERENCE = 115,
    G_REGEX_ERROR_UNTERMINATED_COMMENT = 118,
    G_REGEX_ERROR_EXPRESSION_TOO_LARGE = 120,
    G_REGEX_ERROR_MEMORY_ERROR = 121,
    G_REGEX_ERROR_VARIABLE_LENGTH_LOOKBEHIND = 125,
    G_REGEX_ERROR_MALFORMED_CONDITION = 126,
    G_REGEX_ERROR_TOO_MANY_CONDITIONAL_BRANCHES = 127,
    G_REGEX_ERROR_ASSERTION_EXPECTED = 128,
    G_REGEX_ERROR_UNKNOWN_POSIX_CLASS_NAME = 130,
    G_REGEX_ERROR_POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED = 131,
    G_REGEX_ERROR_HEX_CODE_TOO_LARGE = 134,
    G_REGEX_ERROR_INVALID_CONDITION = 135,
    G_REGEX_ERROR_SINGLE_BYTE_MATCH_IN_LOOKBEHIND = 136,
    G_REGEX_ERROR_INFINITE_LOOP = 140,
    G_REGEX_ERROR_MISSING_SUBPATTERN_NAME_TERMINATOR = 142,
    G_REGEX_ERROR_DUPLICATE_SUBPATTERN_NAME = 143,
    G_REGEX_ERROR_MALFORMED_PROPERTY = 146,
    G_REGEX_ERROR_UNKNOWN_PROPERTY = 147,
    G_REGEX_ERROR_SUBPATTERN_NAME_TOO_LONG = 148,
    G_REGEX_ERROR_TOO_MANY_SUBPATTERNS = 149,
    G_REGEX_ERROR_INVALID_OCTAL_VALUE = 151,
    G_REGEX_ERROR_TOO_MANY_BRANCHES_IN_DEFINE = 154,
    G_REGEX_ERROR_DEFINE_REPETION = 155,
    G_REGEX_ERROR_INCONSISTENT_NEWLINE_OPTIONS = 156,
    G_REGEX_ERROR_MISSING_BACK_REFERENCE = 157,
    G_REGEX_ERROR_INVALID_RELATIVE_REFERENCE = 158,
    G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_FORBIDDEN = 159,
    G_REGEX_ERROR_UNKNOWN_BACKTRACKING_CONTROL_VERB = 160,
    G_REGEX_ERROR_NUMBER_TOO_BIG = 161,
    G_REGEX_ERROR_MISSING_SUBPATTERN_NAME = 162,
    G_REGEX_ERROR_MISSING_DIGIT = 163,
    G_REGEX_ERROR_INVALID_DATA_CHARACTER = 164,
    G_REGEX_ERROR_EXTRA_SUBPATTERN_NAME = 165,
    G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_REQUIRED = 166,
    G_REGEX_ERROR_INVALID_CONTROL_CHAR = 168,
    G_REGEX_ERROR_MISSING_NAME = 169,
    G_REGEX_ERROR_NOT_SUPPORTED_IN_CLASS = 171,
    G_REGEX_ERROR_TOO_MANY_FORWARD_REFERENCES = 172,
    G_REGEX_ERROR_NAME_TOO_LONG = 175,
    G_REGEX_ERROR_CHARACTER_VALUE_TOO_LARGE = 176
} ;
#line 201 "/usr/include/glib-2.0/glib/gregex.h"
typedef enum __anonenum__93 GRegexError;
#line 296
enum __anonenum__94 {
    G_REGEX_CASELESS = 1,
    G_REGEX_MULTILINE = 2,
    G_REGEX_DOTALL = 4,
    G_REGEX_EXTENDED = 8,
    G_REGEX_ANCHORED = 16,
    G_REGEX_DOLLAR_ENDONLY = 32,
    G_REGEX_UNGREEDY = 512,
    G_REGEX_RAW = 2048,
    G_REGEX_NO_AUTO_CAPTURE = 4096,
    G_REGEX_OPTIMIZE = 8192,
    G_REGEX_FIRSTLINE = 262144,
    G_REGEX_DUPNAMES = 524288,
    G_REGEX_NEWLINE_CR = 1048576,
    G_REGEX_NEWLINE_LF = 2097152,
    G_REGEX_NEWLINE_CRLF = 3145728,
    G_REGEX_NEWLINE_ANYCRLF = 5242880,
    G_REGEX_BSR_ANYCRLF = 8388608,
    G_REGEX_JAVASCRIPT_COMPAT = 33554432
} ;
#line 316 "/usr/include/glib-2.0/glib/gregex.h"
typedef enum __anonenum__94 GRegexCompileFlags;
#line 386
enum __anonenum__95 {
    G_REGEX_MATCH_ANCHORED = 16,
    G_REGEX_MATCH_NOTBOL = 128,
    G_REGEX_MATCH_NOTEOL = 256,
    G_REGEX_MATCH_NOTEMPTY = 1024,
    G_REGEX_MATCH_PARTIAL = 32768,
    G_REGEX_MATCH_NEWLINE_CR = 1048576,
    G_REGEX_MATCH_NEWLINE_LF = 2097152,
    G_REGEX_MATCH_NEWLINE_CRLF = 3145728,
    G_REGEX_MATCH_NEWLINE_ANY = 4194304,
    G_REGEX_MATCH_NEWLINE_ANYCRLF = 5242880,
    G_REGEX_MATCH_BSR_ANYCRLF = 8388608,
    G_REGEX_MATCH_BSR_ANY = 16777216,
    G_REGEX_MATCH_PARTIAL_SOFT = 32768,
    G_REGEX_MATCH_PARTIAL_HARD = 134217728,
    G_REGEX_MATCH_NOTEMPTY_ATSTART = 268435456
} ;
#line 403 "/usr/include/glib-2.0/glib/gregex.h"
typedef enum __anonenum__95 GRegexMatchFlags;
#line 413
struct _GRegex ;
#line 413 "/usr/include/glib-2.0/glib/gregex.h"
typedef struct _GRegex GRegex;
#line 422
struct _GMatchInfo ;
#line 422 "/usr/include/glib-2.0/glib/gregex.h"
typedef struct _GMatchInfo GMatchInfo;
#line 441 "/usr/include/glib-2.0/glib/gregex.h"
typedef gboolean (*GRegexEvalCallback)(GMatchInfo * , GString * , gpointer  );
#line 37 "/usr/include/glib-2.0/glib/gscanner.h"
struct _GScanner ;
#line 37 "/usr/include/glib-2.0/glib/gscanner.h"
typedef struct _GScanner GScanner;
#line 38
struct _GScannerConfig ;
#line 38 "/usr/include/glib-2.0/glib/gscanner.h"
typedef struct _GScannerConfig GScannerConfig;
#line 39
union _GTokenValue ;
#line 39 "/usr/include/glib-2.0/glib/gscanner.h"
typedef union _GTokenValue GTokenValue;
#line 41 "/usr/include/glib-2.0/glib/gscanner.h"
typedef void (*GScannerMsgFunc)(GScanner * , gchar * , gboolean  );
#line 62
enum __anonenum__96 {
    G_ERR_UNKNOWN = 0,
    G_ERR_UNEXP_EOF = 1,
    G_ERR_UNEXP_EOF_IN_STRING = 2,
    G_ERR_UNEXP_EOF_IN_COMMENT = 3,
    G_ERR_NON_DIGIT_IN_CONST = 4,
    G_ERR_DIGIT_RADIX = 5,
    G_ERR_FLOAT_RADIX = 6,
    G_ERR_FLOAT_MALFORMED = 7
} ;
#line 72 "/usr/include/glib-2.0/glib/gscanner.h"
typedef enum __anonenum__96 GErrorType;
#line 75
enum __anonenum__97 {
    G_TOKEN_EOF = 0,
    G_TOKEN_LEFT_PAREN = 40,
    G_TOKEN_RIGHT_PAREN = 41,
    G_TOKEN_LEFT_CURLY = 123,
    G_TOKEN_RIGHT_CURLY = 125,
    G_TOKEN_LEFT_BRACE = 91,
    G_TOKEN_RIGHT_BRACE = 93,
    G_TOKEN_EQUAL_SIGN = 61,
    G_TOKEN_COMMA = 44,
    G_TOKEN_NONE = 256,
    G_TOKEN_ERROR = 257,
    G_TOKEN_CHAR = 258,
    G_TOKEN_BINARY = 259,
    G_TOKEN_OCTAL = 260,
    G_TOKEN_INT = 261,
    G_TOKEN_HEX = 262,
    G_TOKEN_FLOAT = 263,
    G_TOKEN_STRING = 264,
    G_TOKEN_SYMBOL = 265,
    G_TOKEN_IDENTIFIER = 266,
    G_TOKEN_IDENTIFIER_NULL = 267,
    G_TOKEN_COMMENT_SINGLE = 268,
    G_TOKEN_COMMENT_MULTI = 269,
    G_TOKEN_LAST = 270
} ;
#line 109 "/usr/include/glib-2.0/glib/gscanner.h"
typedef enum __anonenum__97 GTokenType;
#line 111 "/usr/include/glib-2.0/glib/gscanner.h"
union _GTokenValue {
   gpointer v_symbol ;
   gchar *v_identifier ;
   gulong v_binary ;
   gulong v_octal ;
   gulong v_int ;
   guint64 v_int64 ;
   gdouble v_float ;
   gulong v_hex ;
   gchar *v_string ;
   gchar *v_comment ;
   guchar v_char ;
   guint v_error ;
};
#line 127 "/usr/include/glib-2.0/glib/gscanner.h"
struct _GScannerConfig {
   gchar *cset_skip_characters ;
   gchar *cset_identifier_first ;
   gchar *cset_identifier_nth ;
   gchar *cpair_comment_single ;
   guint case_sensitive ;
   guint skip_comment_multi ;
   guint skip_comment_single ;
   guint scan_comment_multi ;
   guint scan_identifier ;
   guint scan_identifier_1char ;
   guint scan_identifier_NULL ;
   guint scan_symbols ;
   guint scan_binary ;
   guint scan_octal ;
   guint scan_float ;
   guint scan_hex ;
   guint scan_hex_dollar ;
   guint scan_string_sq ;
   guint scan_string_dq ;
   guint numbers_2_int ;
   guint int_2_float ;
   guint identifier_2_string ;
   guint char_2_token ;
   guint symbol_2_token ;
   guint scope_0_fallback ;
   guint store_int64 ;
   guint padding_dummy ;
};
#line 169 "/usr/include/glib-2.0/glib/gscanner.h"
struct _GScanner {
   gpointer user_data ;
   guint max_parse_errors ;
   guint parse_errors ;
   gchar *input_name ;
   GData *qdata ;
   GScannerConfig *config ;
   GTokenType token ;
   GTokenValue value ;
   guint line ;
   guint position ;
   GTokenType next_token ;
   GTokenValue next_value ;
   guint next_line ;
   guint next_position ;
   GHashTable *symbol_table ;
   gint input_fd ;
   gchar *text ;
   gchar *text_end ;
   gchar *buffer ;
   guint scope_id ;
   GScannerMsgFunc msg_handler ;
};
#line 30 "/usr/include/glib-2.0/glib/gsequence.h"
struct _GSequence ;
#line 30 "/usr/include/glib-2.0/glib/gsequence.h"
typedef struct _GSequence GSequence;
#line 31
struct _GSequenceNode ;
#line 31 "/usr/include/glib-2.0/glib/gsequence.h"
typedef struct _GSequenceNode GSequenceIter;
#line 33 "/usr/include/glib-2.0/glib/gsequence.h"
typedef gint (*GSequenceIterCompareFunc)(GSequenceIter * , GSequenceIter * , gpointer  );
#line 32 "/usr/include/glib-2.0/glib/gshell.h"
enum __anonenum__98 {
    G_SHELL_ERROR_BAD_QUOTING = 0,
    G_SHELL_ERROR_EMPTY_STRING = 1,
    G_SHELL_ERROR_FAILED = 2
} ;
#line 39 "/usr/include/glib-2.0/glib/gshell.h"
typedef enum __anonenum__98 GShellError;
#line 92 "/usr/include/glib-2.0/glib/gslice.h"
enum __anonenum__99 {
    G_SLICE_CONFIG_ALWAYS_MALLOC = 1,
    G_SLICE_CONFIG_BYPASS_MAGAZINES = 2,
    G_SLICE_CONFIG_WORKING_SET_MSECS = 3,
    G_SLICE_CONFIG_COLOR_INCREMENT = 4,
    G_SLICE_CONFIG_CHUNK_SIZES = 5,
    G_SLICE_CONFIG_CONTENTION_COUNTER = 6
} ;
#line 99 "/usr/include/glib-2.0/glib/gslice.h"
typedef enum __anonenum__99 GSliceConfig;
#line 68 "/usr/include/glib-2.0/glib/gspawn.h"
enum __anonenum__100 {
    G_SPAWN_ERROR_FORK = 0,
    G_SPAWN_ERROR_READ = 1,
    G_SPAWN_ERROR_CHDIR = 2,
    G_SPAWN_ERROR_ACCES = 3,
    G_SPAWN_ERROR_PERM = 4,
    G_SPAWN_ERROR_TOO_BIG = 5,
    G_SPAWN_ERROR_2BIG = 5,
    G_SPAWN_ERROR_NOEXEC = 6,
    G_SPAWN_ERROR_NAMETOOLONG = 7,
    G_SPAWN_ERROR_NOENT = 8,
    G_SPAWN_ERROR_NOMEM = 9,
    G_SPAWN_ERROR_NOTDIR = 10,
    G_SPAWN_ERROR_LOOP = 11,
    G_SPAWN_ERROR_TXTBUSY = 12,
    G_SPAWN_ERROR_IO = 13,
    G_SPAWN_ERROR_NFILE = 14,
    G_SPAWN_ERROR_MFILE = 15,
    G_SPAWN_ERROR_INVAL = 16,
    G_SPAWN_ERROR_ISDIR = 17,
    G_SPAWN_ERROR_LIBBAD = 18,
    G_SPAWN_ERROR_FAILED = 19
} ;
#line 93 "/usr/include/glib-2.0/glib/gspawn.h"
typedef enum __anonenum__100 GSpawnError;
#line 138 "/usr/include/glib-2.0/glib/gspawn.h"
typedef void (*GSpawnChildSetupFunc)(gpointer  );
#line 168
enum __anonenum__101 {
    G_SPAWN_DEFAULT = 0,
    G_SPAWN_LEAVE_DESCRIPTORS_OPEN = 1,
    G_SPAWN_DO_NOT_REAP_CHILD = 2,
    G_SPAWN_SEARCH_PATH = 4,
    G_SPAWN_STDOUT_TO_DEV_NULL = 8,
    G_SPAWN_STDERR_TO_DEV_NULL = 16,
    G_SPAWN_CHILD_INHERITS_STDIN = 32,
    G_SPAWN_FILE_AND_ARGV_ZERO = 64,
    G_SPAWN_SEARCH_PATH_FROM_ENVP = 128,
    G_SPAWN_CLOEXEC_PIPES = 256
} ;
#line 182 "/usr/include/glib-2.0/glib/gspawn.h"
typedef enum __anonenum__101 GSpawnFlags;
#line 40 "/usr/include/glib-2.0/glib/gstrfuncs.h"
enum __anonenum__102 {
    G_ASCII_ALNUM = 1,
    G_ASCII_ALPHA = 2,
    G_ASCII_CNTRL = 4,
    G_ASCII_DIGIT = 8,
    G_ASCII_GRAPH = 16,
    G_ASCII_LOWER = 32,
    G_ASCII_PRINT = 64,
    G_ASCII_PUNCT = 128,
    G_ASCII_SPACE = 256,
    G_ASCII_UPPER = 512,
    G_ASCII_XDIGIT = 1024
} ;
#line 52 "/usr/include/glib-2.0/glib/gstrfuncs.h"
typedef enum __anonenum__102 GAsciiType;
#line 273 "/usr/include/glib-2.0/glib/gstrfuncs.h"
typedef gchar **GStrv;
#line 329
enum __anonenum__103 {
    G_NUMBER_PARSER_ERROR_INVALID = 0,
    G_NUMBER_PARSER_ERROR_OUT_OF_BOUNDS = 1
} ;
#line 333 "/usr/include/glib-2.0/glib/gstrfuncs.h"
typedef enum __anonenum__103 GNumberParserError;
#line 36 "/usr/include/glib-2.0/glib/gstringchunk.h"
struct _GStringChunk ;
#line 36 "/usr/include/glib-2.0/glib/gstringchunk.h"
typedef struct _GStringChunk GStringChunk;
#line 39 "/usr/include/glib-2.0/glib/gstrvbuilder.h"
struct _GStrvBuilder ;
#line 39 "/usr/include/glib-2.0/glib/gstrvbuilder.h"
typedef struct _GStrvBuilder GStrvBuilder;
#line 35 "/usr/include/glib-2.0/glib/gtestutils.h"
struct GTestCase ;
#line 35 "/usr/include/glib-2.0/glib/gtestutils.h"
typedef struct GTestCase GTestCase;
#line 36
struct GTestSuite ;
#line 36 "/usr/include/glib-2.0/glib/gtestutils.h"
typedef struct GTestSuite GTestSuite;
#line 37 "/usr/include/glib-2.0/glib/gtestutils.h"
typedef void (*GTestFunc)(void);
#line 38 "/usr/include/glib-2.0/glib/gtestutils.h"
typedef void (*GTestDataFunc)(gconstpointer  );
#line 39 "/usr/include/glib-2.0/glib/gtestutils.h"
typedef void (*GTestFixtureFunc)(gpointer  , gconstpointer  );
#line 445
enum __anonenum__104 {
    G_TEST_TRAP_SILENCE_STDOUT = 128,
    G_TEST_TRAP_SILENCE_STDERR = 256,
    G_TEST_TRAP_INHERIT_STDIN = 512
} ;
#line 449 "/usr/include/glib-2.0/glib/gtestutils.h"
typedef enum __anonenum__104 GTestTrapFlags;
#line 459
enum __anonenum__105 {
    G_TEST_SUBPROCESS_INHERIT_STDIN = 1,
    G_TEST_SUBPROCESS_INHERIT_STDOUT = 2,
    G_TEST_SUBPROCESS_INHERIT_STDERR = 4
} ;
#line 463 "/usr/include/glib-2.0/glib/gtestutils.h"
typedef enum __anonenum__105 GTestSubprocessFlags;
#line 590 "/usr/include/glib-2.0/glib/gtestutils.h"
struct __anonstruct_106 {
   gboolean test_initialized ;
   gboolean test_quick ;
   gboolean test_perf ;
   gboolean test_verbose ;
   gboolean test_quiet ;
   gboolean test_undefined ;
};
#line 597 "/usr/include/glib-2.0/glib/gtestutils.h"
typedef struct __anonstruct_106 GTestConfig;
#line 601
enum __anonenum__107 {
    G_TEST_RUN_SUCCESS = 0,
    G_TEST_RUN_SKIPPED = 1,
    G_TEST_RUN_FAILURE = 2,
    G_TEST_RUN_INCOMPLETE = 3
} ;
#line 606 "/usr/include/glib-2.0/glib/gtestutils.h"
typedef enum __anonenum__107 GTestResult;
#line 608
enum __anonenum__108 {
    G_TEST_LOG_NONE = 0,
    G_TEST_LOG_ERROR = 1,
    G_TEST_LOG_START_BINARY = 2,
    G_TEST_LOG_LIST_CASE = 3,
    G_TEST_LOG_SKIP_CASE = 4,
    G_TEST_LOG_START_CASE = 5,
    G_TEST_LOG_STOP_CASE = 6,
    G_TEST_LOG_MIN_RESULT = 7,
    G_TEST_LOG_MAX_RESULT = 8,
    G_TEST_LOG_MESSAGE = 9,
    G_TEST_LOG_START_SUITE = 10,
    G_TEST_LOG_STOP_SUITE = 11
} ;
#line 621 "/usr/include/glib-2.0/glib/gtestutils.h"
typedef enum __anonenum__108 GTestLogType;
#line 623 "/usr/include/glib-2.0/glib/gtestutils.h"
struct __anonstruct_109 {
   GTestLogType log_type ;
   guint n_strings ;
   gchar **strings ;
   guint n_nums ;
   long double *nums ;
};
#line 629 "/usr/include/glib-2.0/glib/gtestutils.h"
typedef struct __anonstruct_109 GTestLogMsg;
#line 630 "/usr/include/glib-2.0/glib/gtestutils.h"
struct __anonstruct_110 {
   GString *data ;
   GSList *msgs ;
};
#line 634 "/usr/include/glib-2.0/glib/gtestutils.h"
typedef struct __anonstruct_110 GTestLogBuffer;
#line 664 "/usr/include/glib-2.0/glib/gtestutils.h"
typedef gboolean (*GTestLogFatalFunc)(gchar * , GLogLevelFlags  , gchar * , gpointer  );
#line 683
enum __anonenum__111 {
    G_TEST_DIST = 0,
    G_TEST_BUILT = 1
} ;
#line 687 "/usr/include/glib-2.0/glib/gtestutils.h"
typedef enum __anonenum__111 GTestFileType;
#line 36 "/usr/include/glib-2.0/glib/gthreadpool.h"
struct _GThreadPool ;
#line 36 "/usr/include/glib-2.0/glib/gthreadpool.h"
typedef struct _GThreadPool GThreadPool;
#line 41 "/usr/include/glib-2.0/glib/gthreadpool.h"
struct _GThreadPool {
   GFunc func ;
   gpointer user_data ;
   gboolean exclusive ;
};
#line 40 "/usr/include/glib-2.0/glib/gtimer.h"
struct _GTimer ;
#line 40 "/usr/include/glib-2.0/glib/gtimer.h"
typedef struct _GTimer GTimer;
#line 38 "/usr/include/glib-2.0/glib/gtrashstack.h"
struct _GTrashStack ;
#line 38 "/usr/include/glib-2.0/glib/gtrashstack.h"
typedef struct _GTrashStack GTrashStack;
#line 39 "/usr/include/glib-2.0/glib/gtrashstack.h"
struct _GTrashStack {
   GTrashStack *next ;
};
#line 38 "/usr/include/glib-2.0/glib/gtree.h"
struct _GTree ;
#line 38 "/usr/include/glib-2.0/glib/gtree.h"
typedef struct _GTree GTree;
#line 47
struct _GTreeNode ;
#line 47 "/usr/include/glib-2.0/glib/gtree.h"
typedef struct _GTreeNode GTreeNode;
#line 49 "/usr/include/glib-2.0/glib/gtree.h"
typedef gboolean (*GTraverseFunc)(gpointer  , gpointer  , gpointer  );
#line 66 "/usr/include/glib-2.0/glib/gtree.h"
typedef gboolean (*GTraverseNodeFunc)(GTreeNode * , gpointer  );
#line 31 "/usr/include/glib-2.0/glib/guri.h"
struct _GUri ;
#line 31 "/usr/include/glib-2.0/glib/guri.h"
typedef struct _GUri GUri;
#line 80
enum __anonenum__112 {
    G_URI_FLAGS_NONE = 0,
    G_URI_FLAGS_PARSE_RELAXED = 1,
    G_URI_FLAGS_HAS_PASSWORD = 2,
    G_URI_FLAGS_HAS_AUTH_PARAMS = 4,
    G_URI_FLAGS_ENCODED = 8,
    G_URI_FLAGS_NON_DNS = 16,
    G_URI_FLAGS_ENCODED_QUERY = 32,
    G_URI_FLAGS_ENCODED_PATH = 64,
    G_URI_FLAGS_ENCODED_FRAGMENT = 128,
    G_URI_FLAGS_SCHEME_NORMALIZE = 256
} ;
#line 91 "/usr/include/glib-2.0/glib/guri.h"
typedef enum __anonenum__112 GUriFlags;
#line 205
enum __anonenum__113 {
    G_URI_HIDE_NONE = 0,
    G_URI_HIDE_USERINFO = 1,
    G_URI_HIDE_PASSWORD = 2,
    G_URI_HIDE_AUTH_PARAMS = 4,
    G_URI_HIDE_QUERY = 8,
    G_URI_HIDE_FRAGMENT = 16
} ;
#line 212 "/usr/include/glib-2.0/glib/guri.h"
typedef enum __anonenum__113 GUriHideFlags;
#line 257
enum __anonenum__114 {
    G_URI_PARAMS_NONE = 0,
    G_URI_PARAMS_CASE_INSENSITIVE = 1,
    G_URI_PARAMS_WWW_FORM = 2,
    G_URI_PARAMS_PARSE_RELAXED = 4
} ;
#line 262 "/usr/include/glib-2.0/glib/guri.h"
typedef enum __anonenum__114 GUriParamsFlags;
#line 271
struct _GUriParamsIter ;
#line 271 "/usr/include/glib-2.0/glib/guri.h"
typedef struct _GUriParamsIter GUriParamsIter;
#line 273 "/usr/include/glib-2.0/glib/guri.h"
struct _GUriParamsIter {
   gint dummy0 ;
   gpointer dummy1 ;
   gpointer dummy2 ;
   guint8 dummy3[256] ;
};
#line 326
enum __anonenum__115 {
    G_URI_ERROR_FAILED = 0,
    G_URI_ERROR_BAD_SCHEME = 1,
    G_URI_ERROR_BAD_USER = 2,
    G_URI_ERROR_BAD_PASSWORD = 3,
    G_URI_ERROR_BAD_AUTH_PARAMS = 4,
    G_URI_ERROR_BAD_HOST = 5,
    G_URI_ERROR_BAD_PORT = 6,
    G_URI_ERROR_BAD_PATH = 7,
    G_URI_ERROR_BAD_QUERY = 8,
    G_URI_ERROR_BAD_FRAGMENT = 9
} ;
#line 337 "/usr/include/glib-2.0/glib/guri.h"
typedef enum __anonenum__115 GUriError;
#line 27 "/usr/include/glib-2.0/glib/deprecated/gallocator.h"
struct _GAllocator ;
#line 27 "/usr/include/glib-2.0/glib/deprecated/gallocator.h"
typedef struct _GAllocator GAllocator;
#line 28
struct _GMemChunk ;
#line 28 "/usr/include/glib-2.0/glib/deprecated/gallocator.h"
typedef struct _GMemChunk GMemChunk;
#line 36 "/usr/include/glib-2.0/glib/deprecated/gcache.h"
struct _GCache ;
#line 36 "/usr/include/glib-2.0/glib/deprecated/gcache.h"
typedef struct _GCache GCache;
#line 38 "/usr/include/glib-2.0/glib/deprecated/gcache.h"
typedef gpointer (*GCacheNewFunc)(gpointer  );
#line 39 "/usr/include/glib-2.0/glib/deprecated/gcache.h"
typedef gpointer (*GCacheDupFunc)(gpointer  );
#line 40 "/usr/include/glib-2.0/glib/deprecated/gcache.h"
typedef void (*GCacheDestroyFunc)(gpointer  );
#line 36 "/usr/include/glib-2.0/glib/deprecated/gcompletion.h"
struct _GCompletion ;
#line 36 "/usr/include/glib-2.0/glib/deprecated/gcompletion.h"
typedef struct _GCompletion GCompletion;
#line 38 "/usr/include/glib-2.0/glib/deprecated/gcompletion.h"
typedef gchar *(*GCompletionFunc)(gpointer  );
#line 43 "/usr/include/glib-2.0/glib/deprecated/gcompletion.h"
typedef gint (*GCompletionStrncmpFunc)(gchar * , gchar * , gsize  );
#line 47 "/usr/include/glib-2.0/glib/deprecated/gcompletion.h"
struct _GCompletion {
   GList *items ;
   GCompletionFunc func ;
   gchar *prefix ;
   GList *cache ;
   GCompletionStrncmpFunc strncmp_func ;
};
#line 36 "/usr/include/glib-2.0/glib/deprecated/grel.h"
struct _GRelation ;
#line 36 "/usr/include/glib-2.0/glib/deprecated/grel.h"
typedef struct _GRelation GRelation;
#line 37
struct _GTuples ;
#line 37 "/usr/include/glib-2.0/glib/deprecated/grel.h"
typedef struct _GTuples GTuples;
#line 39 "/usr/include/glib-2.0/glib/deprecated/grel.h"
struct _GTuples {
   guint len ;
};
#line 38 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
enum __anonenum__116 {
    G_THREAD_PRIORITY_LOW = 0,
    G_THREAD_PRIORITY_NORMAL = 1,
    G_THREAD_PRIORITY_HIGH = 2,
    G_THREAD_PRIORITY_URGENT = 3
} ;
#line 44 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
typedef enum __anonenum__116 GThreadPriority;
#line 46 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
struct _GThread {
   GThreadFunc func ;
   gpointer data ;
   gboolean joinable ;
   GThreadPriority priority ;
};
#line 55
struct _GThreadFunctions ;
#line 55 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
typedef struct _GThreadFunctions GThreadFunctions;
#line 56 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
struct _GThreadFunctions {
   GMutex *(*mutex_new)(void) ;
   void (*mutex_lock)(GMutex * ) ;
   gboolean (*mutex_trylock)(GMutex * ) ;
   void (*mutex_unlock)(GMutex * ) ;
   void (*mutex_free)(GMutex * ) ;
   GCond *(*cond_new)(void) ;
   void (*cond_signal)(GCond * ) ;
   void (*cond_broadcast)(GCond * ) ;
   void (*cond_wait)(GCond * , GMutex * ) ;
   gboolean (*cond_timed_wait)(GCond * , GMutex * , GTimeVal * ) ;
   void (*cond_free)(GCond * ) ;
   GPrivate *(*private_new)(GDestroyNotify  ) ;
   gpointer (*private_get)(GPrivate * ) ;
   void (*private_set)(GPrivate * , gpointer  ) ;
   void (*thread_create)(GThreadFunc  , gpointer  , gulong  , gboolean  , gboolean  ,
                         GThreadPriority  , gpointer  , GError ** ) ;
   void (*thread_yield)(void) ;
   void (*thread_join)(gpointer  ) ;
   void (*thread_exit)(void) ;
   void (*thread_set_priority)(gpointer  , GThreadPriority  ) ;
   void (*thread_self)(gpointer  ) ;
   gboolean (*thread_equal)(gpointer  , gpointer  ) ;
};
#line 23 "/usr/include/x86_64-linux-gnu/bits/types/struct_sched_param.h"
struct sched_param {
   int sched_priority ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h"
typedef unsigned long __cpu_mask;
#line 39 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h"
struct __anonstruct_117 {
   __cpu_mask __bits[16] ;
};
#line 42 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h"
typedef struct __anonstruct_117 cpu_set_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 26 "/usr/include/x86_64-linux-gnu/bits/types/struct___jmp_buf_tag.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 37 "/usr/include/pthread.h"
enum __anonenum__118 {
    PTHREAD_CREATE_JOINABLE = 0,
    PTHREAD_CREATE_DETACHED = 1
} ;
#line 47
enum __anonenum__119 {
    PTHREAD_MUTEX_TIMED_NP = 0,
    PTHREAD_MUTEX_RECURSIVE_NP = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP = 3,
    PTHREAD_MUTEX_NORMAL = 0,
    PTHREAD_MUTEX_RECURSIVE = 1,
    PTHREAD_MUTEX_ERRORCHECK = 2,
    PTHREAD_MUTEX_DEFAULT = 0
} ;
#line 69
enum __anonenum__120 {
    PTHREAD_MUTEX_STALLED = 0,
    PTHREAD_MUTEX_STALLED_NP = 0,
    PTHREAD_MUTEX_ROBUST = 1,
    PTHREAD_MUTEX_ROBUST_NP = 1
} ;
#line 81
enum __anonenum__121 {
    PTHREAD_PRIO_NONE = 0,
    PTHREAD_PRIO_INHERIT = 1,
    PTHREAD_PRIO_PROTECT = 2
} ;
#line 104
enum __anonenum__122 {
    PTHREAD_RWLOCK_PREFER_READER_NP = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP = 2,
    PTHREAD_RWLOCK_DEFAULT_NP = 0
} ;
#line 124
enum __anonenum__123 {
    PTHREAD_INHERIT_SCHED = 0,
    PTHREAD_EXPLICIT_SCHED = 1
} ;
#line 134
enum __anonenum__124 {
    PTHREAD_SCOPE_SYSTEM = 0,
    PTHREAD_SCOPE_PROCESS = 1
} ;
#line 144
enum __anonenum__125 {
    PTHREAD_PROCESS_PRIVATE = 0,
    PTHREAD_PROCESS_SHARED = 1
} ;
#line 159 "/usr/include/pthread.h"
struct _pthread_cleanup_buffer {
   void (*__routine)(void * ) ;
   void *__arg ;
   int __canceltype ;
   struct _pthread_cleanup_buffer *__prev ;
};
#line 168
enum __anonenum__126 {
    PTHREAD_CANCEL_ENABLE = 0,
    PTHREAD_CANCEL_DISABLE = 1
} ;
#line 175
enum __anonenum__127 {
    PTHREAD_CANCEL_DEFERRED = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS = 1
} ;
#line 538 "/usr/include/pthread.h"
struct __cancel_jmp_buf_tag {
   __jmp_buf __cancel_jmp_buf ;
   int __mask_was_saved ;
};
#line 544 "/usr/include/pthread.h"
struct __anonstruct_128 {
   struct __cancel_jmp_buf_tag __cancel_jmp_buf[1] ;
   void *__pad[4] ;
};
#line 548 "/usr/include/pthread.h"
typedef struct __anonstruct_128 __pthread_unwind_buf_t;
#line 557 "/usr/include/pthread.h"
struct __pthread_cleanup_frame {
   void (*__cancel_routine)(void * ) ;
   void *__cancel_arg ;
   int __do_it ;
   int __cancel_type ;
};
#line 133 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
struct __anonstruct_129 {
   GMutex *mutex ;
   pthread_mutex_t unused ;
};
#line 140 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
typedef struct __anonstruct_129 GStaticMutex;
#line 156
struct _GStaticRecMutex ;
#line 156 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
typedef struct _GStaticRecMutex GStaticRecMutex;
#line 164 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
union __anonunion_130 {
   pthread_t owner ;
   gdouble dummy ;
};
#line 157 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
struct _GStaticRecMutex {
   GStaticMutex mutex ;
   guint depth ;
   union __anonunion_130 unused ;
};
#line 197
struct _GStaticRWLock ;
#line 197 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
typedef struct _GStaticRWLock GStaticRWLock;
#line 198 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
struct _GStaticRWLock {
   GStaticMutex mutex ;
   GCond *read_cond ;
   GCond *write_cond ;
   guint read_counter ;
   gboolean have_writer ;
   guint want_to_read ;
   guint want_to_write ;
};
#line 239
struct _GStaticPrivate ;
#line 239 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
typedef struct _GStaticPrivate GStaticPrivate;
#line 240 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
struct _GStaticPrivate {
   guint index ;
};
#line 45 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GAsyncQueue *GAsyncQueue_autoptr;
#line 45 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GAsyncQueue_listautoptr;
#line 45 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GAsyncQueue_slistautoptr;
#line 45 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GAsyncQueue_queueautoptr;
#line 46 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GBookmarkFile *GBookmarkFile_autoptr;
#line 46 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GBookmarkFile_listautoptr;
#line 46 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GBookmarkFile_slistautoptr;
#line 46 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GBookmarkFile_queueautoptr;
#line 47 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GBytes *GBytes_autoptr;
#line 47 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GBytes_listautoptr;
#line 47 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GBytes_slistautoptr;
#line 47 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GBytes_queueautoptr;
#line 48 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GChecksum *GChecksum_autoptr;
#line 48 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GChecksum_listautoptr;
#line 48 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GChecksum_slistautoptr;
#line 48 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GChecksum_queueautoptr;
#line 49 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GDateTime *GDateTime_autoptr;
#line 49 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GDateTime_listautoptr;
#line 49 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GDateTime_slistautoptr;
#line 49 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GDateTime_queueautoptr;
#line 50 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GDate *GDate_autoptr;
#line 50 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GDate_listautoptr;
#line 50 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GDate_slistautoptr;
#line 50 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GDate_queueautoptr;
#line 51 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GDir *GDir_autoptr;
#line 51 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GDir_listautoptr;
#line 51 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GDir_slistautoptr;
#line 51 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GDir_queueautoptr;
#line 52 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GError *GError_autoptr;
#line 52 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GError_listautoptr;
#line 52 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GError_slistautoptr;
#line 52 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GError_queueautoptr;
#line 53 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GHashTable *GHashTable_autoptr;
#line 53 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GHashTable_listautoptr;
#line 53 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GHashTable_slistautoptr;
#line 53 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GHashTable_queueautoptr;
#line 54 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GHmac *GHmac_autoptr;
#line 54 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GHmac_listautoptr;
#line 54 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GHmac_slistautoptr;
#line 54 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GHmac_queueautoptr;
#line 55 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GIOChannel *GIOChannel_autoptr;
#line 55 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GIOChannel_listautoptr;
#line 55 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GIOChannel_slistautoptr;
#line 55 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GIOChannel_queueautoptr;
#line 56 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GKeyFile *GKeyFile_autoptr;
#line 56 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GKeyFile_listautoptr;
#line 56 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GKeyFile_slistautoptr;
#line 56 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GKeyFile_queueautoptr;
#line 57 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GList_autoptr;
#line 57 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GList_listautoptr;
#line 57 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GList_slistautoptr;
#line 57 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GList_queueautoptr;
#line 58 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GArray *GArray_autoptr;
#line 58 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GArray_listautoptr;
#line 58 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GArray_slistautoptr;
#line 58 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GArray_queueautoptr;
#line 59 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GPtrArray *GPtrArray_autoptr;
#line 59 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GPtrArray_listautoptr;
#line 59 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GPtrArray_slistautoptr;
#line 59 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GPtrArray_queueautoptr;
#line 60 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GByteArray *GByteArray_autoptr;
#line 60 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GByteArray_listautoptr;
#line 60 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GByteArray_slistautoptr;
#line 60 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GByteArray_queueautoptr;
#line 61 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GMainContext *GMainContext_autoptr;
#line 61 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GMainContext_listautoptr;
#line 61 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GMainContext_slistautoptr;
#line 61 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GMainContext_queueautoptr;
#line 62 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GMainContextPusher *GMainContextPusher_autoptr;
#line 62 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GMainContextPusher_listautoptr;
#line 62 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GMainContextPusher_slistautoptr;
#line 62 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GMainContextPusher_queueautoptr;
#line 63 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GMainLoop *GMainLoop_autoptr;
#line 63 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GMainLoop_listautoptr;
#line 63 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GMainLoop_slistautoptr;
#line 63 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GMainLoop_queueautoptr;
#line 64 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSource *GSource_autoptr;
#line 64 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GSource_listautoptr;
#line 64 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GSource_slistautoptr;
#line 64 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GSource_queueautoptr;
#line 65 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GMappedFile *GMappedFile_autoptr;
#line 65 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GMappedFile_listautoptr;
#line 65 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GMappedFile_slistautoptr;
#line 65 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GMappedFile_queueautoptr;
#line 66 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GMarkupParseContext *GMarkupParseContext_autoptr;
#line 66 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GMarkupParseContext_listautoptr;
#line 66 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GMarkupParseContext_slistautoptr;
#line 66 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GMarkupParseContext_queueautoptr;
#line 67 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GNode *GNode_autoptr;
#line 67 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GNode_listautoptr;
#line 67 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GNode_slistautoptr;
#line 67 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GNode_queueautoptr;
#line 68 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GOptionContext *GOptionContext_autoptr;
#line 68 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GOptionContext_listautoptr;
#line 68 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GOptionContext_slistautoptr;
#line 68 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GOptionContext_queueautoptr;
#line 69 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GOptionGroup *GOptionGroup_autoptr;
#line 69 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GOptionGroup_listautoptr;
#line 69 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GOptionGroup_slistautoptr;
#line 69 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GOptionGroup_queueautoptr;
#line 70 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GPatternSpec *GPatternSpec_autoptr;
#line 70 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GPatternSpec_listautoptr;
#line 70 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GPatternSpec_slistautoptr;
#line 70 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GPatternSpec_queueautoptr;
#line 71 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GQueue_autoptr;
#line 71 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GQueue_listautoptr;
#line 71 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GQueue_slistautoptr;
#line 71 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GQueue_queueautoptr;
#line 73 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GRand *GRand_autoptr;
#line 73 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GRand_listautoptr;
#line 73 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GRand_slistautoptr;
#line 73 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GRand_queueautoptr;
#line 74 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GRegex *GRegex_autoptr;
#line 74 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GRegex_listautoptr;
#line 74 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GRegex_slistautoptr;
#line 74 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GRegex_queueautoptr;
#line 75 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GMatchInfo *GMatchInfo_autoptr;
#line 75 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GMatchInfo_listautoptr;
#line 75 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GMatchInfo_slistautoptr;
#line 75 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GMatchInfo_queueautoptr;
#line 76 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GScanner *GScanner_autoptr;
#line 76 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GScanner_listautoptr;
#line 76 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GScanner_slistautoptr;
#line 76 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GScanner_queueautoptr;
#line 77 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSequence *GSequence_autoptr;
#line 77 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GSequence_listautoptr;
#line 77 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GSequence_slistautoptr;
#line 77 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GSequence_queueautoptr;
#line 78 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GSList_autoptr;
#line 78 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GSList_listautoptr;
#line 78 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GSList_slistautoptr;
#line 78 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GSList_queueautoptr;
#line 79 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GString *GString_autoptr;
#line 79 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GString_listautoptr;
#line 79 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GString_slistautoptr;
#line 79 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GString_queueautoptr;
#line 80 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GStringChunk *GStringChunk_autoptr;
#line 80 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GStringChunk_listautoptr;
#line 80 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GStringChunk_slistautoptr;
#line 80 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GStringChunk_queueautoptr;
#line 81 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GStrvBuilder *GStrvBuilder_autoptr;
#line 81 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GStrvBuilder_listautoptr;
#line 81 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GStrvBuilder_slistautoptr;
#line 81 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GStrvBuilder_queueautoptr;
#line 82 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GThread *GThread_autoptr;
#line 82 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GThread_listautoptr;
#line 82 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GThread_slistautoptr;
#line 82 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GThread_queueautoptr;
#line 84 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GMutexLocker *GMutexLocker_autoptr;
#line 84 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GMutexLocker_listautoptr;
#line 84 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GMutexLocker_slistautoptr;
#line 84 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GMutexLocker_queueautoptr;
#line 85 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GRecMutexLocker *GRecMutexLocker_autoptr;
#line 85 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GRecMutexLocker_listautoptr;
#line 85 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GRecMutexLocker_slistautoptr;
#line 85 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GRecMutexLocker_queueautoptr;
#line 86 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GRWLockWriterLocker *GRWLockWriterLocker_autoptr;
#line 86 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GRWLockWriterLocker_listautoptr;
#line 86 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GRWLockWriterLocker_slistautoptr;
#line 86 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GRWLockWriterLocker_queueautoptr;
#line 87 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GRWLockReaderLocker *GRWLockReaderLocker_autoptr;
#line 87 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GRWLockReaderLocker_listautoptr;
#line 87 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GRWLockReaderLocker_slistautoptr;
#line 87 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GRWLockReaderLocker_queueautoptr;
#line 89 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GTimer *GTimer_autoptr;
#line 89 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GTimer_listautoptr;
#line 89 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GTimer_slistautoptr;
#line 89 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GTimer_queueautoptr;
#line 90 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GTimeZone *GTimeZone_autoptr;
#line 90 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GTimeZone_listautoptr;
#line 90 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GTimeZone_slistautoptr;
#line 90 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GTimeZone_queueautoptr;
#line 91 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GTree *GTree_autoptr;
#line 91 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GTree_listautoptr;
#line 91 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GTree_slistautoptr;
#line 91 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GTree_queueautoptr;
#line 92 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GVariant *GVariant_autoptr;
#line 92 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GVariant_listautoptr;
#line 92 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GVariant_slistautoptr;
#line 92 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GVariant_queueautoptr;
#line 93 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GVariantBuilder *GVariantBuilder_autoptr;
#line 93 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GVariantBuilder_listautoptr;
#line 93 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GVariantBuilder_slistautoptr;
#line 93 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GVariantBuilder_queueautoptr;
#line 95 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GVariantIter *GVariantIter_autoptr;
#line 95 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GVariantIter_listautoptr;
#line 95 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GVariantIter_slistautoptr;
#line 95 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GVariantIter_queueautoptr;
#line 96 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GVariantDict *GVariantDict_autoptr;
#line 96 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GVariantDict_listautoptr;
#line 96 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GVariantDict_slistautoptr;
#line 96 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GVariantDict_queueautoptr;
#line 98 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GVariantType *GVariantType_autoptr;
#line 98 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GVariantType_listautoptr;
#line 98 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GVariantType_slistautoptr;
#line 98 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GVariantType_queueautoptr;
#line 100 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GRefString *GRefString_autoptr;
#line 100 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GRefString_listautoptr;
#line 100 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GRefString_slistautoptr;
#line 100 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GRefString_queueautoptr;
#line 101 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GUri *GUri_autoptr;
#line 101 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GUri_listautoptr;
#line 101 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GUri_slistautoptr;
#line 101 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GUri_queueautoptr;
#line 31 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/types.h"
struct _at_coord {
   gushort x ;
   gushort y ;
};
#line 33 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/types.h"
typedef struct _at_coord at_coord;
#line 35 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/types.h"
struct _at_real_coord {
   gfloat x ;
   gfloat y ;
   gfloat z ;
};
#line 37 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/types.h"
typedef struct _at_real_coord at_real_coord;
#line 400 "/usr/include/glib-2.0/gobject/gtype.h"
typedef gsize GType;
#line 404
struct _GValue ;
#line 404 "/usr/include/glib-2.0/gobject/gtype.h"
typedef struct _GValue GValue;
#line 405
union _GTypeCValue ;
#line 405 "/usr/include/glib-2.0/gobject/gtype.h"
typedef union _GTypeCValue GTypeCValue;
#line 406
struct _GTypePlugin ;
#line 406 "/usr/include/glib-2.0/gobject/gtype.h"
typedef struct _GTypePlugin GTypePlugin;
#line 407
struct _GTypeClass ;
#line 407 "/usr/include/glib-2.0/gobject/gtype.h"
typedef struct _GTypeClass GTypeClass;
#line 408
struct _GTypeInterface ;
#line 408 "/usr/include/glib-2.0/gobject/gtype.h"
typedef struct _GTypeInterface GTypeInterface;
#line 409
struct _GTypeInstance ;
#line 409 "/usr/include/glib-2.0/gobject/gtype.h"
typedef struct _GTypeInstance GTypeInstance;
#line 410
struct _GTypeInfo ;
#line 410 "/usr/include/glib-2.0/gobject/gtype.h"
typedef struct _GTypeInfo GTypeInfo;
#line 411
struct _GTypeFundamentalInfo ;
#line 411 "/usr/include/glib-2.0/gobject/gtype.h"
typedef struct _GTypeFundamentalInfo GTypeFundamentalInfo;
#line 412
struct _GInterfaceInfo ;
#line 412 "/usr/include/glib-2.0/gobject/gtype.h"
typedef struct _GInterfaceInfo GInterfaceInfo;
#line 413
struct _GTypeValueTable ;
#line 413 "/usr/include/glib-2.0/gobject/gtype.h"
typedef struct _GTypeValueTable GTypeValueTable;
#line 414
struct _GTypeQuery ;
#line 414 "/usr/include/glib-2.0/gobject/gtype.h"
typedef struct _GTypeQuery GTypeQuery;
#line 424 "/usr/include/glib-2.0/gobject/gtype.h"
struct _GTypeClass {
   GType g_type ;
};
#line 434 "/usr/include/glib-2.0/gobject/gtype.h"
struct _GTypeInstance {
   GTypeClass *g_class ;
};
#line 444 "/usr/include/glib-2.0/gobject/gtype.h"
struct _GTypeInterface {
   GType g_type ;
   GType g_instance_type ;
};
#line 461 "/usr/include/glib-2.0/gobject/gtype.h"
struct _GTypeQuery {
   GType type ;
   gchar *type_name ;
   guint class_size ;
   guint instance_size ;
};
#line 697
enum __anonenum__131 {
    G_TYPE_DEBUG_NONE = 0,
    G_TYPE_DEBUG_OBJECTS = 1,
    G_TYPE_DEBUG_SIGNALS = 2,
    G_TYPE_DEBUG_INSTANCE_COUNT = 4,
    G_TYPE_DEBUG_MASK = 7
} ;
#line 704 "/usr/include/glib-2.0/gobject/gtype.h"
typedef enum __anonenum__131 GTypeDebugFlags;
#line 794 "/usr/include/glib-2.0/gobject/gtype.h"
typedef void (*GBaseInitFunc)(gpointer  );
#line 808 "/usr/include/glib-2.0/gobject/gtype.h"
typedef void (*GBaseFinalizeFunc)(gpointer  );
#line 912 "/usr/include/glib-2.0/gobject/gtype.h"
typedef void (*GClassInitFunc)(gpointer  , gpointer  );
#line 929 "/usr/include/glib-2.0/gobject/gtype.h"
typedef void (*GClassFinalizeFunc)(gpointer  , gpointer  );
#line 951 "/usr/include/glib-2.0/gobject/gtype.h"
typedef void (*GInstanceInitFunc)(GTypeInstance * , gpointer  );
#line 967 "/usr/include/glib-2.0/gobject/gtype.h"
typedef void (*GInterfaceInitFunc)(gpointer  , gpointer  );
#line 979 "/usr/include/glib-2.0/gobject/gtype.h"
typedef void (*GInterfaceFinalizeFunc)(gpointer  , gpointer  );
#line 1001 "/usr/include/glib-2.0/gobject/gtype.h"
typedef gboolean (*GTypeClassCacheFunc)(gpointer  , GTypeClass * );
#line 1015 "/usr/include/glib-2.0/gobject/gtype.h"
typedef void (*GTypeInterfaceCheckFunc)(gpointer  , gpointer  );
#line 1027
enum __anonenum__132 {
    G_TYPE_FLAG_CLASSED = 1,
    G_TYPE_FLAG_INSTANTIATABLE = 2,
    G_TYPE_FLAG_DERIVABLE = 4,
    G_TYPE_FLAG_DEEP_DERIVABLE = 8
} ;
#line 1033 "/usr/include/glib-2.0/gobject/gtype.h"
typedef enum __anonenum__132 GTypeFundamentalFlags;
#line 1046
enum __anonenum__133 {
    G_TYPE_FLAG_ABSTRACT = 16,
    G_TYPE_FLAG_VALUE_ABSTRACT = 32,
    G_TYPE_FLAG_FINAL = 64
} ;
#line 1051 "/usr/include/glib-2.0/gobject/gtype.h"
typedef enum __anonenum__133 GTypeFlags;
#line 1083 "/usr/include/glib-2.0/gobject/gtype.h"
struct _GTypeInfo {
   guint16 class_size ;
   GBaseInitFunc base_init ;
   GBaseFinalizeFunc base_finalize ;
   GClassInitFunc class_init ;
   GClassFinalizeFunc class_finalize ;
   gconstpointer class_data ;
   guint16 instance_size ;
   guint16 n_preallocs ;
   GInstanceInitFunc instance_init ;
   GTypeValueTable *value_table ;
};
#line 1111 "/usr/include/glib-2.0/gobject/gtype.h"
struct _GTypeFundamentalInfo {
   GTypeFundamentalFlags type_flags ;
};
#line 1124 "/usr/include/glib-2.0/gobject/gtype.h"
struct _GInterfaceInfo {
   GInterfaceInitFunc interface_init ;
   GInterfaceFinalizeFunc interface_finalize ;
   gpointer interface_data ;
};
#line 1284 "/usr/include/glib-2.0/gobject/gtype.h"
struct _GTypeValueTable {
   void (*value_init)(GValue * ) ;
   void (*value_free)(GValue * ) ;
   void (*value_copy)(GValue * , GValue * ) ;
   gpointer (*value_peek_pointer)(GValue * ) ;
   gchar *collect_format ;
   gchar *(*collect_value)(GValue * , guint  , GTypeCValue * , guint  ) ;
   gchar *lcopy_format ;
   gchar *(*lcopy_value)(GValue * , guint  , GTypeCValue * , guint  ) ;
};
#line 95 "/usr/include/glib-2.0/gobject/gvalue.h"
typedef void (*GValueTransform)(GValue * , GValue * );
#line 117 "/usr/include/glib-2.0/gobject/gvalue.h"
union __anonunion_134 {
   gint v_int ;
   guint v_uint ;
   glong v_long ;
   gulong v_ulong ;
   gint64 v_int64 ;
   guint64 v_uint64 ;
   gfloat v_float ;
   gdouble v_double ;
   gpointer v_pointer ;
};
#line 111 "/usr/include/glib-2.0/gobject/gvalue.h"
struct _GValue {
   GType g_type ;
   union __anonunion_134 data[2] ;
};
#line 152 "/usr/include/glib-2.0/gobject/gparam.h"
enum __anonenum__135 {
    G_PARAM_READABLE = 1,
    G_PARAM_WRITABLE = 2,
    G_PARAM_READWRITE = 3,
    G_PARAM_CONSTRUCT = 4,
    G_PARAM_CONSTRUCT_ONLY = 8,
    G_PARAM_LAX_VALIDATION = 16,
    G_PARAM_STATIC_NAME = 32,
    G_PARAM_PRIVATE = 32,
    G_PARAM_STATIC_NICK = 64,
    G_PARAM_STATIC_BLURB = 128,
    G_PARAM_EXPLICIT_NOTIFY = 1073741824,
    G_PARAM_DEPRECATED = (-0x7FFFFFFF-1)
} ;
#line 168 "/usr/include/glib-2.0/gobject/gparam.h"
typedef enum __anonenum__135 GParamFlags;
#line 194
struct _GParamSpec ;
#line 194 "/usr/include/glib-2.0/gobject/gparam.h"
typedef struct _GParamSpec GParamSpec;
#line 195
struct _GParamSpecClass ;
#line 195 "/usr/include/glib-2.0/gobject/gparam.h"
typedef struct _GParamSpecClass GParamSpecClass;
#line 196
struct _GParameter ;
#line 196 "/usr/include/glib-2.0/gobject/gparam.h"
typedef struct _GParameter GParameter;
#line 197
struct _GParamSpecPool ;
#line 197 "/usr/include/glib-2.0/gobject/gparam.h"
typedef struct _GParamSpecPool GParamSpecPool;
#line 209 "/usr/include/glib-2.0/gobject/gparam.h"
struct _GParamSpec {
   GTypeInstance g_type_instance ;
   gchar *name ;
   GParamFlags flags ;
   GType value_type ;
   GType owner_type ;
   gchar *_nick ;
   gchar *_blurb ;
   GData *qdata ;
   guint ref_count ;
   guint param_id ;
};
#line 244 "/usr/include/glib-2.0/gobject/gparam.h"
struct _GParamSpecClass {
   GTypeClass g_type_class ;
   GType value_type ;
   void (*finalize)(GParamSpec * ) ;
   void (*value_set_default)(GParamSpec * , GValue * ) ;
   gboolean (*value_validate)(GParamSpec * , GValue * ) ;
   gint (*values_cmp)(GParamSpec * , GValue * , GValue * ) ;
   gpointer dummy[4] ;
};
#line 273 "/usr/include/glib-2.0/gobject/gparam.h"
struct _GParameter {
   gchar *name ;
   GValue value ;
};
#line 353
struct _GParamSpecTypeInfo ;
#line 353 "/usr/include/glib-2.0/gobject/gparam.h"
typedef struct _GParamSpecTypeInfo GParamSpecTypeInfo;
#line 379 "/usr/include/glib-2.0/gobject/gparam.h"
struct _GParamSpecTypeInfo {
   guint16 instance_size ;
   guint16 n_preallocs ;
   void (*instance_init)(GParamSpec * ) ;
   GType value_type ;
   void (*finalize)(GParamSpec * ) ;
   void (*value_set_default)(GParamSpec * , GValue * ) ;
   gboolean (*value_validate)(GParamSpec * , GValue * ) ;
   gint (*values_cmp)(GParamSpec * , GValue * , GValue * ) ;
};
#line 75 "/usr/include/glib-2.0/gobject/gclosure.h"
struct _GClosure ;
#line 75 "/usr/include/glib-2.0/gobject/gclosure.h"
typedef struct _GClosure GClosure;
#line 76
struct _GClosureNotifyData ;
#line 76 "/usr/include/glib-2.0/gobject/gclosure.h"
typedef struct _GClosureNotifyData GClosureNotifyData;
#line 90 "/usr/include/glib-2.0/gobject/gclosure.h"
typedef void (*GCallback)(void);
#line 99 "/usr/include/glib-2.0/gobject/gclosure.h"
typedef void (*GClosureNotify)(gpointer  , GClosure * );
#line 119 "/usr/include/glib-2.0/gobject/gclosure.h"
typedef void (*GClosureMarshal)(GClosure * , GValue * , guint  , GValue * , gpointer  ,
                                gpointer  );
#line 146 "/usr/include/glib-2.0/gobject/gclosure.h"
typedef void (*GVaClosureMarshal)(GClosure * , GValue * , gpointer  , va_list  , gpointer  ,
                                  int  , GType * );
#line 161
struct _GCClosure ;
#line 161 "/usr/include/glib-2.0/gobject/gclosure.h"
typedef struct _GCClosure GCClosure;
#line 165 "/usr/include/glib-2.0/gobject/gclosure.h"
struct _GClosureNotifyData {
   gpointer data ;
   GClosureNotify notify ;
};
#line 179 "/usr/include/glib-2.0/gobject/gclosure.h"
struct _GClosure {
   guint ref_count ;
   guint meta_marshal_nouse ;
   guint n_guards ;
   guint n_fnotifiers ;
   guint n_inotifiers ;
   guint in_inotify ;
   guint floating ;
   guint derivative_flag ;
   guint in_marshal ;
   guint is_invalid ;
   void (*marshal)(GClosure * , GValue * , guint  , GValue * , gpointer  , gpointer  ) ;
   gpointer data ;
   GClosureNotifyData *notifiers ;
};
#line 220 "/usr/include/glib-2.0/gobject/gclosure.h"
struct _GCClosure {
   GClosure closure ;
   gpointer callback ;
};
#line 32 "/usr/include/glib-2.0/gobject/gsignal.h"
struct _GSignalQuery ;
#line 32 "/usr/include/glib-2.0/gobject/gsignal.h"
typedef struct _GSignalQuery GSignalQuery;
#line 33
struct _GSignalInvocationHint ;
#line 33 "/usr/include/glib-2.0/gobject/gsignal.h"
typedef struct _GSignalInvocationHint GSignalInvocationHint;
#line 45 "/usr/include/glib-2.0/gobject/gsignal.h"
typedef GClosureMarshal GSignalCMarshaller;
#line 53 "/usr/include/glib-2.0/gobject/gsignal.h"
typedef GVaClosureMarshal GSignalCVaMarshaller;
#line 73 "/usr/include/glib-2.0/gobject/gsignal.h"
typedef gboolean (*GSignalEmissionHook)(GSignalInvocationHint * , guint  , GValue * ,
                                        gpointer  );
#line 101 "/usr/include/glib-2.0/gobject/gsignal.h"
typedef gboolean (*GSignalAccumulator)(GSignalInvocationHint * , GValue * , GValue * ,
                                       gpointer  );
#line 136
enum __anonenum__136 {
    G_SIGNAL_RUN_FIRST = 1,
    G_SIGNAL_RUN_LAST = 2,
    G_SIGNAL_RUN_CLEANUP = 4,
    G_SIGNAL_NO_RECURSE = 8,
    G_SIGNAL_DETAILED = 16,
    G_SIGNAL_ACTION = 32,
    G_SIGNAL_NO_HOOKS = 64,
    G_SIGNAL_MUST_COLLECT = 128,
    G_SIGNAL_DEPRECATED = 256,
    G_SIGNAL_ACCUMULATOR_FIRST_RUN = 131072
} ;
#line 149 "/usr/include/glib-2.0/gobject/gsignal.h"
typedef enum __anonenum__136 GSignalFlags;
#line 166
enum __anonenum__137 {
    G_CONNECT_AFTER = 1,
    G_CONNECT_SWAPPED = 2
} ;
#line 170 "/usr/include/glib-2.0/gobject/gsignal.h"
typedef enum __anonenum__137 GConnectFlags;
#line 184
enum __anonenum__138 {
    G_SIGNAL_MATCH_ID = 1,
    G_SIGNAL_MATCH_DETAIL = 2,
    G_SIGNAL_MATCH_CLOSURE = 4,
    G_SIGNAL_MATCH_FUNC = 8,
    G_SIGNAL_MATCH_DATA = 16,
    G_SIGNAL_MATCH_UNBLOCKED = 32
} ;
#line 192 "/usr/include/glib-2.0/gobject/gsignal.h"
typedef enum __anonenum__138 GSignalMatchType;
#line 236 "/usr/include/glib-2.0/gobject/gsignal.h"
struct _GSignalInvocationHint {
   guint signal_id ;
   GQuark detail ;
   GSignalFlags run_type ;
};
#line 263 "/usr/include/glib-2.0/gobject/gsignal.h"
struct _GSignalQuery {
   guint signal_id ;
   gchar *signal_name ;
   GType itype ;
   GSignalFlags signal_flags ;
   GType return_type ;
   guint n_params ;
   GType *param_types ;
};
#line 56 "/usr/include/glib-2.0/gobject/gboxed.h"
typedef gpointer (*GBoxedCopyFunc)(gpointer  );
#line 65 "/usr/include/glib-2.0/gobject/gboxed.h"
typedef void (*GBoxedFreeFunc)(gpointer  );
#line 190 "/usr/include/glib-2.0/gobject/gobject.h"
struct _GObject ;
#line 190 "/usr/include/glib-2.0/gobject/gobject.h"
typedef struct _GObject GObject;
#line 191
struct _GObjectClass ;
#line 191 "/usr/include/glib-2.0/gobject/gobject.h"
typedef struct _GObjectClass GObjectClass;
#line 192 "/usr/include/glib-2.0/gobject/gobject.h"
typedef struct _GObject GInitiallyUnowned;
#line 193 "/usr/include/glib-2.0/gobject/gobject.h"
typedef struct _GObjectClass GInitiallyUnownedClass;
#line 194
struct _GObjectConstructParam ;
#line 194 "/usr/include/glib-2.0/gobject/gobject.h"
typedef struct _GObjectConstructParam GObjectConstructParam;
#line 205 "/usr/include/glib-2.0/gobject/gobject.h"
typedef void (*GObjectGetPropertyFunc)(GObject * , guint  , GValue * , GParamSpec * );
#line 219 "/usr/include/glib-2.0/gobject/gobject.h"
typedef void (*GObjectSetPropertyFunc)(GObject * , guint  , GValue * , GParamSpec * );
#line 229 "/usr/include/glib-2.0/gobject/gobject.h"
typedef void (*GObjectFinalizeFunc)(GObject * );
#line 247 "/usr/include/glib-2.0/gobject/gobject.h"
typedef void (*GWeakNotify)(gpointer  , GObject * );
#line 265 "/usr/include/glib-2.0/gobject/gobject.h"
struct _GObject {
   GTypeInstance g_type_instance ;
   guint ref_count ;
   GData *qdata ;
};
#line 335 "/usr/include/glib-2.0/gobject/gobject.h"
struct _GObjectClass {
   GTypeClass g_type_class ;
   GSList *construct_properties ;
   GObject *(*constructor)(GType  , guint  , GObjectConstructParam * ) ;
   void (*set_property)(GObject * , guint  , GValue * , GParamSpec * ) ;
   void (*get_property)(GObject * , guint  , GValue * , GParamSpec * ) ;
   void (*dispose)(GObject * ) ;
   void (*finalize)(GObject * ) ;
   void (*dispatch_properties_changed)(GObject * , guint  , GParamSpec ** ) ;
   void (*notify)(GObject * , GParamSpec * ) ;
   void (*constructed)(GObject * ) ;
   gsize flags ;
   gpointer pdummy[6] ;
};
#line 384 "/usr/include/glib-2.0/gobject/gobject.h"
struct _GObjectConstructParam {
   GParamSpec *pspec ;
   GValue *value ;
};
#line 559 "/usr/include/glib-2.0/gobject/gobject.h"
typedef void (*GToggleNotify)(gpointer  , GObject * , gboolean  );
#line 930 "/usr/include/glib-2.0/gobject/gobject.h"
union __anonunion_140 {
   gpointer p ;
};
#line 928 "/usr/include/glib-2.0/gobject/gobject.h"
struct __anonstruct_139 {
   union __anonunion_140 priv ;
};
#line 931 "/usr/include/glib-2.0/gobject/gobject.h"
typedef struct __anonstruct_139 GWeakRef;
#line 47 "/usr/include/glib-2.0/gobject/gbinding.h"
struct _GBinding ;
#line 47 "/usr/include/glib-2.0/gobject/gbinding.h"
typedef struct _GBinding GBinding;
#line 69 "/usr/include/glib-2.0/gobject/gbinding.h"
typedef gboolean (*GBindingTransformFunc)(GBinding * , GValue * , GValue * , gpointer  );
#line 97
enum __anonenum__141 {
    G_BINDING_DEFAULT = 0,
    G_BINDING_BIDIRECTIONAL = 1,
    G_BINDING_SYNC_CREATE = 2,
    G_BINDING_INVERT_BOOLEAN = 4
} ;
#line 103 "/usr/include/glib-2.0/gobject/gbinding.h"
typedef enum __anonenum__141 GBindingFlags;
#line 47 "/usr/include/glib-2.0/gobject/gbindinggroup.h"
struct _GBindingGroup ;
#line 47 "/usr/include/glib-2.0/gobject/gbindinggroup.h"
typedef struct _GBindingGroup GBindingGroup;
#line 138 "/usr/include/glib-2.0/gobject/genums.h"
struct _GEnumClass ;
#line 138 "/usr/include/glib-2.0/gobject/genums.h"
typedef struct _GEnumClass GEnumClass;
#line 139
struct _GFlagsClass ;
#line 139 "/usr/include/glib-2.0/gobject/genums.h"
typedef struct _GFlagsClass GFlagsClass;
#line 140
struct _GEnumValue ;
#line 140 "/usr/include/glib-2.0/gobject/genums.h"
typedef struct _GEnumValue GEnumValue;
#line 141
struct _GFlagsValue ;
#line 141 "/usr/include/glib-2.0/gobject/genums.h"
typedef struct _GFlagsValue GFlagsValue;
#line 155 "/usr/include/glib-2.0/gobject/genums.h"
struct _GEnumClass {
   GTypeClass g_type_class ;
   gint minimum ;
   gint maximum ;
   guint n_values ;
   GEnumValue *values ;
};
#line 176 "/usr/include/glib-2.0/gobject/genums.h"
struct _GFlagsClass {
   GTypeClass g_type_class ;
   guint mask ;
   guint n_values ;
   GFlagsValue *values ;
};
#line 194 "/usr/include/glib-2.0/gobject/genums.h"
struct _GEnumValue {
   gint value ;
   gchar *value_name ;
   gchar *value_nick ;
};
#line 209 "/usr/include/glib-2.0/gobject/genums.h"
struct _GFlagsValue {
   guint value ;
   gchar *value_name ;
   gchar *value_nick ;
};
#line 586 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecChar ;
#line 586 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecChar GParamSpecChar;
#line 587
struct _GParamSpecUChar ;
#line 587 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecUChar GParamSpecUChar;
#line 588
struct _GParamSpecBoolean ;
#line 588 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecBoolean GParamSpecBoolean;
#line 589
struct _GParamSpecInt ;
#line 589 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecInt GParamSpecInt;
#line 590
struct _GParamSpecUInt ;
#line 590 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecUInt GParamSpecUInt;
#line 591
struct _GParamSpecLong ;
#line 591 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecLong GParamSpecLong;
#line 592
struct _GParamSpecULong ;
#line 592 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecULong GParamSpecULong;
#line 593
struct _GParamSpecInt64 ;
#line 593 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecInt64 GParamSpecInt64;
#line 594
struct _GParamSpecUInt64 ;
#line 594 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecUInt64 GParamSpecUInt64;
#line 595
struct _GParamSpecUnichar ;
#line 595 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecUnichar GParamSpecUnichar;
#line 596
struct _GParamSpecEnum ;
#line 596 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecEnum GParamSpecEnum;
#line 597
struct _GParamSpecFlags ;
#line 597 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecFlags GParamSpecFlags;
#line 598
struct _GParamSpecFloat ;
#line 598 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecFloat GParamSpecFloat;
#line 599
struct _GParamSpecDouble ;
#line 599 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecDouble GParamSpecDouble;
#line 600
struct _GParamSpecString ;
#line 600 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecString GParamSpecString;
#line 601
struct _GParamSpecParam ;
#line 601 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecParam GParamSpecParam;
#line 602
struct _GParamSpecBoxed ;
#line 602 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecBoxed GParamSpecBoxed;
#line 603
struct _GParamSpecPointer ;
#line 603 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecPointer GParamSpecPointer;
#line 604
struct _GParamSpecValueArray ;
#line 604 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecValueArray GParamSpecValueArray;
#line 605
struct _GParamSpecObject ;
#line 605 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecObject GParamSpecObject;
#line 606
struct _GParamSpecOverride ;
#line 606 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecOverride GParamSpecOverride;
#line 607
struct _GParamSpecGType ;
#line 607 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecGType GParamSpecGType;
#line 608
struct _GParamSpecVariant ;
#line 608 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecVariant GParamSpecVariant;
#line 619 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecChar {
   GParamSpec parent_instance ;
   gint8 minimum ;
   gint8 maximum ;
   gint8 default_value ;
};
#line 636 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecUChar {
   GParamSpec parent_instance ;
   guint8 minimum ;
   guint8 maximum ;
   guint8 default_value ;
};
#line 651 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecBoolean {
   GParamSpec parent_instance ;
   gboolean default_value ;
};
#line 666 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecInt {
   GParamSpec parent_instance ;
   gint minimum ;
   gint maximum ;
   gint default_value ;
};
#line 683 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecUInt {
   GParamSpec parent_instance ;
   guint minimum ;
   guint maximum ;
   guint default_value ;
};
#line 700 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecLong {
   GParamSpec parent_instance ;
   glong minimum ;
   glong maximum ;
   glong default_value ;
};
#line 717 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecULong {
   GParamSpec parent_instance ;
   gulong minimum ;
   gulong maximum ;
   gulong default_value ;
};
#line 734 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecInt64 {
   GParamSpec parent_instance ;
   gint64 minimum ;
   gint64 maximum ;
   gint64 default_value ;
};
#line 751 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecUInt64 {
   GParamSpec parent_instance ;
   guint64 minimum ;
   guint64 maximum ;
   guint64 default_value ;
};
#line 766 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecUnichar {
   GParamSpec parent_instance ;
   gunichar default_value ;
};
#line 781 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecEnum {
   GParamSpec parent_instance ;
   GEnumClass *enum_class ;
   gint default_value ;
};
#line 797 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecFlags {
   GParamSpec parent_instance ;
   GFlagsClass *flags_class ;
   guint default_value ;
};
#line 815 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecFloat {
   GParamSpec parent_instance ;
   gfloat minimum ;
   gfloat maximum ;
   gfloat default_value ;
   gfloat epsilon ;
};
#line 835 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecDouble {
   GParamSpec parent_instance ;
   gdouble minimum ;
   gdouble maximum ;
   gdouble default_value ;
   gdouble epsilon ;
};
#line 857 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecString {
   GParamSpec parent_instance ;
   gchar *default_value ;
   gchar *cset_first ;
   gchar *cset_nth ;
   gchar substitutor ;
   guint null_fold_if_empty ;
   guint ensure_non_null ;
};
#line 875 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecParam {
   GParamSpec parent_instance ;
};
#line 885 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecBoxed {
   GParamSpec parent_instance ;
};
#line 895 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecPointer {
   GParamSpec parent_instance ;
};
#line 907 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecValueArray {
   GParamSpec parent_instance ;
   GParamSpec *element_spec ;
   guint fixed_n_elements ;
};
#line 919 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecObject {
   GParamSpec parent_instance ;
};
#line 940 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecOverride {
   GParamSpec parent_instance ;
   GParamSpec *overridden ;
};
#line 955 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecGType {
   GParamSpec parent_instance ;
   GType is_a_type ;
};
#line 976 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecVariant {
   GParamSpec parent_instance ;
   GVariantType *type ;
   GVariant *default_value ;
   gpointer padding[4] ;
};
#line 47 "/usr/include/glib-2.0/gobject/gsignalgroup.h"
struct _GSignalGroup ;
#line 47 "/usr/include/glib-2.0/gobject/gsignalgroup.h"
typedef struct _GSignalGroup GSignalGroup;
#line 29 "/usr/include/glib-2.0/gobject/gtypemodule.h"
struct _GTypeModule ;
#line 29 "/usr/include/glib-2.0/gobject/gtypemodule.h"
typedef struct _GTypeModule GTypeModule;
#line 30
struct _GTypeModuleClass ;
#line 30 "/usr/include/glib-2.0/gobject/gtypemodule.h"
typedef struct _GTypeModuleClass GTypeModuleClass;
#line 39 "/usr/include/glib-2.0/gobject/gtypemodule.h"
typedef GTypeModule *GTypeModule_autoptr;
#line 39 "/usr/include/glib-2.0/gobject/gtypemodule.h"
typedef GList *GTypeModule_listautoptr;
#line 39 "/usr/include/glib-2.0/gobject/gtypemodule.h"
typedef GSList *GTypeModule_slistautoptr;
#line 39 "/usr/include/glib-2.0/gobject/gtypemodule.h"
typedef GQueue *GTypeModule_queueautoptr;
#line 48 "/usr/include/glib-2.0/gobject/gtypemodule.h"
struct _GTypeModule {
   GObject parent_instance ;
   guint use_count ;
   GSList *type_infos ;
   GSList *interface_infos ;
   gchar *name ;
};
#line 70 "/usr/include/glib-2.0/gobject/gtypemodule.h"
struct _GTypeModuleClass {
   GObjectClass parent_class ;
   gboolean (*load)(GTypeModule * ) ;
   void (*unload)(GTypeModule * ) ;
   void (*reserved1)(void) ;
   void (*reserved2)(void) ;
   void (*reserved3)(void) ;
   void (*reserved4)(void) ;
};
#line 38 "/usr/include/glib-2.0/gobject/gtypeplugin.h"
struct _GTypePluginClass ;
#line 38 "/usr/include/glib-2.0/gobject/gtypeplugin.h"
typedef struct _GTypePluginClass GTypePluginClass;
#line 46 "/usr/include/glib-2.0/gobject/gtypeplugin.h"
typedef void (*GTypePluginUse)(GTypePlugin * );
#line 53 "/usr/include/glib-2.0/gobject/gtypeplugin.h"
typedef void (*GTypePluginUnuse)(GTypePlugin * );
#line 63 "/usr/include/glib-2.0/gobject/gtypeplugin.h"
typedef void (*GTypePluginCompleteTypeInfo)(GTypePlugin * , GType  , GTypeInfo * ,
                                            GTypeValueTable * );
#line 77 "/usr/include/glib-2.0/gobject/gtypeplugin.h"
typedef void (*GTypePluginCompleteInterfaceInfo)(GTypePlugin * , GType  , GType  ,
                                                 GInterfaceInfo * );
#line 101 "/usr/include/glib-2.0/gobject/gtypeplugin.h"
struct _GTypePluginClass {
   GTypeInterface base_iface ;
   GTypePluginUse use_plugin ;
   GTypePluginUnuse unuse_plugin ;
   GTypePluginCompleteTypeInfo complete_type_info ;
   GTypePluginCompleteInterfaceInfo complete_interface_info ;
};
#line 41 "/usr/include/glib-2.0/gobject/gvaluearray.h"
struct _GValueArray ;
#line 41 "/usr/include/glib-2.0/gobject/gvaluearray.h"
typedef struct _GValueArray GValueArray;
#line 49 "/usr/include/glib-2.0/gobject/gvaluearray.h"
struct _GValueArray {
   guint n_values ;
   GValue *values ;
   guint n_prealloced ;
};
#line 311 "/usr/include/glib-2.0/gobject/gvaluetypes.h"
typedef gchar *gchararray;
#line 24 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GClosure *GClosure_autoptr;
#line 24 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GList *GClosure_listautoptr;
#line 24 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GSList *GClosure_slistautoptr;
#line 24 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GQueue *GClosure_queueautoptr;
#line 25 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GEnumClass *GEnumClass_autoptr;
#line 25 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GList *GEnumClass_listautoptr;
#line 25 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GSList *GEnumClass_slistautoptr;
#line 25 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GQueue *GEnumClass_queueautoptr;
#line 26 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GFlagsClass *GFlagsClass_autoptr;
#line 26 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GList *GFlagsClass_listautoptr;
#line 26 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GSList *GFlagsClass_slistautoptr;
#line 26 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GQueue *GFlagsClass_queueautoptr;
#line 27 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GObject *GObject_autoptr;
#line 27 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GList *GObject_listautoptr;
#line 27 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GSList *GObject_slistautoptr;
#line 27 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GQueue *GObject_queueautoptr;
#line 28 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GInitiallyUnowned *GInitiallyUnowned_autoptr;
#line 28 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GList *GInitiallyUnowned_listautoptr;
#line 28 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GSList *GInitiallyUnowned_slistautoptr;
#line 28 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GQueue *GInitiallyUnowned_queueautoptr;
#line 29 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GParamSpec *GParamSpec_autoptr;
#line 29 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GList *GParamSpec_listautoptr;
#line 29 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GSList *GParamSpec_slistautoptr;
#line 29 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GQueue *GParamSpec_queueautoptr;
#line 30 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GTypeClass *GTypeClass_autoptr;
#line 30 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GList *GTypeClass_listautoptr;
#line 30 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GSList *GTypeClass_slistautoptr;
#line 30 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GQueue *GTypeClass_queueautoptr;
#line 27 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/color.h"
struct _at_color ;
#line 27 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/color.h"
typedef struct _at_color at_color;
#line 28 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/color.h"
struct _at_color {
   guint8 r ;
   guint8 g ;
   guint8 b ;
};
#line 42 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/autotrace.h"
enum _at_polynomial_degree {
    AT_LINEARTYPE = 1,
    AT_QUADRATICTYPE = 2,
    AT_CUBICTYPE = 3,
    AT_PARALLELELLIPSETYPE = 4,
    AT_ELLIPSETYPE = 5,
    AT_CIRCLETYPE = 6
} ;
#line 53
enum _at_msg_type {
    AT_MSG_NOT_SET = 0,
    AT_MSG_FATAL = 1,
    AT_MSG_WARNING = 2
} ;
#line 59
struct _at_fitting_opts_type ;
#line 59 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/autotrace.h"
typedef struct _at_fitting_opts_type at_fitting_opts_type;
#line 60
struct _at_input_opts_type ;
#line 60 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/autotrace.h"
typedef struct _at_input_opts_type at_input_opts_type;
#line 61
struct _at_output_opts_type ;
#line 61 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/autotrace.h"
typedef struct _at_output_opts_type at_output_opts_type;
#line 62
struct _at_bitmap ;
#line 62 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/autotrace.h"
typedef struct _at_bitmap at_bitmap;
#line 63 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/autotrace.h"
typedef enum _at_polynomial_degree at_polynomial_degree;
#line 64
struct _at_spline_type ;
#line 64 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/autotrace.h"
typedef struct _at_spline_type at_spline_type;
#line 65
struct _at_spline_list_type ;
#line 65 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/autotrace.h"
typedef struct _at_spline_list_type at_spline_list_type;
#line 66
struct _at_spline_list_array_type ;
#line 66 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/autotrace.h"
typedef struct _at_spline_list_array_type at_spline_list_array_type;
#line 68 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/autotrace.h"
typedef enum _at_msg_type at_msg_type;
#line 75 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/autotrace.h"
struct _at_spline_type {
   at_real_coord v[4] ;
   at_polynomial_degree degree ;
   gfloat linearity ;
};
#line 83 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/autotrace.h"
struct _at_spline_list_type {
   at_spline_type *data ;
   unsigned int length ;
   gboolean clockwise ;
   at_color color ;
   gboolean open ;
};
#line 93 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/autotrace.h"
struct _at_spline_list_array_type {
   at_spline_list_type *data ;
   unsigned int length ;
   unsigned short height ;
   unsigned short width ;
   at_color *background_color ;
   gboolean centerline ;
   gboolean preserve_width ;
   gfloat width_weight_factor ;
};
#line 112 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/autotrace.h"
struct _at_fitting_opts_type {
   at_color *background_color ;
   unsigned int charcode ;
   unsigned int color_count ;
   gfloat corner_always_threshold ;
   unsigned int corner_surround ;
   gfloat corner_threshold ;
   gfloat error_threshold ;
   unsigned int filter_iterations ;
   gfloat line_reversion_threshold ;
   gfloat line_threshold ;
   gboolean remove_adjacent_corners ;
   unsigned int tangent_surround ;
   unsigned int despeckle_level ;
   gfloat despeckle_tightness ;
   gfloat noise_removal ;
   gboolean centerline ;
   gboolean preserve_width ;
   gfloat width_weight_factor ;
};
#line 207 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/autotrace.h"
struct _at_input_opts_type {
   at_color *background_color ;
   unsigned int charcode ;
};
#line 212 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/autotrace.h"
struct _at_output_opts_type {
   int dpi ;
};
#line 216 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/autotrace.h"
struct _at_bitmap {
   unsigned short height ;
   unsigned short width ;
   unsigned char *bitmap ;
   unsigned int np ;
};
#line 224 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/autotrace.h"
typedef void (*at_msg_func)(gchar * , at_msg_type  , gpointer  );
#line 236
struct _at_bitmap_reader ;
#line 236 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/autotrace.h"
typedef struct _at_bitmap_reader at_bitmap_reader;
#line 239
struct _at_spline_writer ;
#line 239 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/autotrace.h"
typedef struct _at_spline_writer at_spline_writer;
#line 246 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/autotrace.h"
typedef void (*at_progress_func)(gfloat  , gpointer  );
#line 252 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/autotrace.h"
typedef gboolean (*at_testcancel_func)(gpointer  );
#line 18 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/exception.h"
struct _at_exception_type ;
#line 18 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/exception.h"
typedef struct _at_exception_type at_exception_type;
#line 19 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/exception.h"
struct _at_exception_type {
   at_msg_type msg_type ;
   at_msg_func client_func ;
   gpointer client_data ;
};
#line 32
enum __anonenum__142 {
    AT_ERROR_WRONG_COLOR_STRING = 0
} ;
#line 34 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/exception.h"
typedef enum __anonenum__142 AtError;
#line 36 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input.h"
typedef at_bitmap (*at_input_func)(gchar * , at_input_opts_type * , at_msg_func  ,
                                   gpointer  , gpointer  );
#line 33 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output.h"
typedef int (*at_output_func)(FILE * , gchar * , int  , int  , int  , int  , at_output_opts_type * ,
                              at_spline_list_array_type  , at_msg_func  , gpointer  ,
                              gpointer  );
#line 80 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output.h"
typedef void (*AtSplineListForeachFunc)(at_spline_list_type * , at_spline_type * ,
                                        int  , gpointer  );
#line 81 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output.h"
typedef void (*AtSplineListArrayForeachFunc)(at_spline_list_array_type * , at_spline_list_type * ,
                                             int  , gpointer  );
#line 29 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/private.h"
struct _at_bitmap_reader {
   at_input_func func ;
   gpointer data ;
};
#line 34 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/private.h"
struct _at_spline_writer {
   at_output_func func ;
   gpointer data ;
};
#line 11 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/spline.h"
typedef at_polynomial_degree polynomial_degree;
#line 12 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/spline.h"
typedef at_spline_type spline_type;
#line 38 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/spline.h"
typedef at_spline_list_type spline_list_type;
#line 163 "/usr/include/math.h"
typedef float float_t;
#line 164 "/usr/include/math.h"
typedef double double_t;
#line 934
enum __anonenum__144 {
    FP_NAN = 0,
    FP_INFINITE = 1,
    FP_ZERO = 2,
    FP_SUBNORMAL = 3,
    FP_NORMAL = 4
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__179 {
    SI_ASYNCNL___0 = -60,
    SI_DETHREAD___0 = -7,
    SI_TKILL___0 = -6,
    SI_SIGIO___0 = -5,
    SI_ASYNCIO___0 = -4,
    SI_MESGQ___0 = -3,
    SI_TIMER___0 = -2,
    SI_QUEUE___0 = -1,
    SI_USER___0 = 0,
    SI_KERNEL___0 = 128
} ;
#line 71
enum __anonenum__180 {
    ILL_ILLOPC___0 = 1,
    ILL_ILLOPN___0 = 2,
    ILL_ILLADR___0 = 3,
    ILL_ILLTRP___0 = 4,
    ILL_PRVOPC___0 = 5,
    ILL_PRVREG___0 = 6,
    ILL_COPROC___0 = 7,
    ILL_BADSTK___0 = 8,
    ILL_BADIADDR___0 = 9
} ;
#line 94
enum __anonenum__181 {
    FPE_INTDIV___0 = 1,
    FPE_INTOVF___0 = 2,
    FPE_FLTDIV___0 = 3,
    FPE_FLTOVF___0 = 4,
    FPE_FLTUND___0 = 5,
    FPE_FLTRES___0 = 6,
    FPE_FLTINV___0 = 7,
    FPE_FLTSUB___0 = 8,
    FPE_FLTUNK___0 = 14,
    FPE_CONDTRAP___0 = 15
} ;
#line 119
enum __anonenum__182 {
    SEGV_MAPERR___0 = 1,
    SEGV_ACCERR___0 = 2,
    SEGV_BNDERR___0 = 3,
    SEGV_PKUERR___0 = 4,
    SEGV_ACCADI___0 = 5,
    SEGV_ADIDERR___0 = 6,
    SEGV_ADIPERR___0 = 7,
    SEGV_MTEAERR___0 = 8,
    SEGV_MTESERR___0 = 9
} ;
#line 142
enum __anonenum__183 {
    BUS_ADRALN___0 = 1,
    BUS_ADRERR___0 = 2,
    BUS_OBJERR___0 = 3,
    BUS_MCEERR_AR___0 = 4,
    BUS_MCEERR_AO___0 = 5
} ;
#line 176
enum __anonenum__184 {
    CLD_EXITED___0 = 1,
    CLD_KILLED___0 = 2,
    CLD_DUMPED___0 = 3,
    CLD_TRAPPED___0 = 4,
    CLD_STOPPED___0 = 5,
    CLD_CONTINUED___0 = 6
} ;
#line 193
enum __anonenum__185 {
    POLL_IN___0 = 1,
    POLL_OUT___0 = 2,
    POLL_MSG___0 = 3,
    POLL_ERR___0 = 4,
    POLL_PRI___0 = 5,
    POLL_HUP___0 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__188 {
    SIGEV_SIGNAL___0 = 0,
    SIGEV_NONE___0 = 1,
    SIGEV_THREAD___0 = 2,
    SIGEV_THREAD_ID___0 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__193 {
    SS_ONSTACK___0 = 1,
    SS_DISABLE___0 = 2
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__201 {
    DT_UNKNOWN___0 = 0,
    DT_FIFO___0 = 1,
    DT_CHR___0 = 2,
    DT_DIR___0 = 4,
    DT_BLK___0 = 6,
    DT_REG___0 = 8,
    DT_LNK___0 = 10,
    DT_SOCK___0 = 12,
    DT_WHT___0 = 14
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__260 {
    PTHREAD_CREATE_JOINABLE___0 = 0,
    PTHREAD_CREATE_DETACHED___0 = 1
} ;
#line 47
enum __anonenum__261 {
    PTHREAD_MUTEX_TIMED_NP___0 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___0 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___0 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___0 = 3,
    PTHREAD_MUTEX_NORMAL___0 = 0,
    PTHREAD_MUTEX_RECURSIVE___0 = 1,
    PTHREAD_MUTEX_ERRORCHECK___0 = 2,
    PTHREAD_MUTEX_DEFAULT___0 = 0
} ;
#line 69
enum __anonenum__262 {
    PTHREAD_MUTEX_STALLED___0 = 0,
    PTHREAD_MUTEX_STALLED_NP___0 = 0,
    PTHREAD_MUTEX_ROBUST___0 = 1,
    PTHREAD_MUTEX_ROBUST_NP___0 = 1
} ;
#line 81
enum __anonenum__263 {
    PTHREAD_PRIO_NONE___0 = 0,
    PTHREAD_PRIO_INHERIT___0 = 1,
    PTHREAD_PRIO_PROTECT___0 = 2
} ;
#line 104
enum __anonenum__264 {
    PTHREAD_RWLOCK_PREFER_READER_NP___0 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___0 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___0 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___0 = 0
} ;
#line 124
enum __anonenum__265 {
    PTHREAD_INHERIT_SCHED___0 = 0,
    PTHREAD_EXPLICIT_SCHED___0 = 1
} ;
#line 134
enum __anonenum__266 {
    PTHREAD_SCOPE_SYSTEM___0 = 0,
    PTHREAD_SCOPE_PROCESS___0 = 1
} ;
#line 144
enum __anonenum__267 {
    PTHREAD_PROCESS_PRIVATE___0 = 0,
    PTHREAD_PROCESS_SHARED___0 = 1
} ;
#line 168
enum __anonenum__268 {
    PTHREAD_CANCEL_ENABLE___0 = 0,
    PTHREAD_CANCEL_DISABLE___0 = 1
} ;
#line 175
enum __anonenum__269 {
    PTHREAD_CANCEL_DEFERRED___0 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___0 = 1
} ;
#line 9 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/image-proc.h"
struct __anonstruct_287 {
   unsigned int height ;
   unsigned int width ;
   float **weight ;
   float **d ;
};
#line 13 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/image-proc.h"
typedef struct __anonstruct_287 at_distance_map;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__325 {
    SI_ASYNCNL___1 = -60,
    SI_DETHREAD___1 = -7,
    SI_TKILL___1 = -6,
    SI_SIGIO___1 = -5,
    SI_ASYNCIO___1 = -4,
    SI_MESGQ___1 = -3,
    SI_TIMER___1 = -2,
    SI_QUEUE___1 = -1,
    SI_USER___1 = 0,
    SI_KERNEL___1 = 128
} ;
#line 71
enum __anonenum__326 {
    ILL_ILLOPC___1 = 1,
    ILL_ILLOPN___1 = 2,
    ILL_ILLADR___1 = 3,
    ILL_ILLTRP___1 = 4,
    ILL_PRVOPC___1 = 5,
    ILL_PRVREG___1 = 6,
    ILL_COPROC___1 = 7,
    ILL_BADSTK___1 = 8,
    ILL_BADIADDR___1 = 9
} ;
#line 94
enum __anonenum__327 {
    FPE_INTDIV___1 = 1,
    FPE_INTOVF___1 = 2,
    FPE_FLTDIV___1 = 3,
    FPE_FLTOVF___1 = 4,
    FPE_FLTUND___1 = 5,
    FPE_FLTRES___1 = 6,
    FPE_FLTINV___1 = 7,
    FPE_FLTSUB___1 = 8,
    FPE_FLTUNK___1 = 14,
    FPE_CONDTRAP___1 = 15
} ;
#line 119
enum __anonenum__328 {
    SEGV_MAPERR___1 = 1,
    SEGV_ACCERR___1 = 2,
    SEGV_BNDERR___1 = 3,
    SEGV_PKUERR___1 = 4,
    SEGV_ACCADI___1 = 5,
    SEGV_ADIDERR___1 = 6,
    SEGV_ADIPERR___1 = 7,
    SEGV_MTEAERR___1 = 8,
    SEGV_MTESERR___1 = 9
} ;
#line 142
enum __anonenum__329 {
    BUS_ADRALN___1 = 1,
    BUS_ADRERR___1 = 2,
    BUS_OBJERR___1 = 3,
    BUS_MCEERR_AR___1 = 4,
    BUS_MCEERR_AO___1 = 5
} ;
#line 176
enum __anonenum__330 {
    CLD_EXITED___1 = 1,
    CLD_KILLED___1 = 2,
    CLD_DUMPED___1 = 3,
    CLD_TRAPPED___1 = 4,
    CLD_STOPPED___1 = 5,
    CLD_CONTINUED___1 = 6
} ;
#line 193
enum __anonenum__331 {
    POLL_IN___1 = 1,
    POLL_OUT___1 = 2,
    POLL_MSG___1 = 3,
    POLL_ERR___1 = 4,
    POLL_PRI___1 = 5,
    POLL_HUP___1 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__334 {
    SIGEV_SIGNAL___1 = 0,
    SIGEV_NONE___1 = 1,
    SIGEV_THREAD___1 = 2,
    SIGEV_THREAD_ID___1 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__339 {
    SS_ONSTACK___1 = 1,
    SS_DISABLE___1 = 2
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__347 {
    DT_UNKNOWN___1 = 0,
    DT_FIFO___1 = 1,
    DT_CHR___1 = 2,
    DT_DIR___1 = 4,
    DT_BLK___1 = 6,
    DT_REG___1 = 8,
    DT_LNK___1 = 10,
    DT_SOCK___1 = 12,
    DT_WHT___1 = 14
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__406 {
    PTHREAD_CREATE_JOINABLE___1 = 0,
    PTHREAD_CREATE_DETACHED___1 = 1
} ;
#line 47
enum __anonenum__407 {
    PTHREAD_MUTEX_TIMED_NP___1 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___1 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___1 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___1 = 3,
    PTHREAD_MUTEX_NORMAL___1 = 0,
    PTHREAD_MUTEX_RECURSIVE___1 = 1,
    PTHREAD_MUTEX_ERRORCHECK___1 = 2,
    PTHREAD_MUTEX_DEFAULT___1 = 0
} ;
#line 69
enum __anonenum__408 {
    PTHREAD_MUTEX_STALLED___1 = 0,
    PTHREAD_MUTEX_STALLED_NP___1 = 0,
    PTHREAD_MUTEX_ROBUST___1 = 1,
    PTHREAD_MUTEX_ROBUST_NP___1 = 1
} ;
#line 81
enum __anonenum__409 {
    PTHREAD_PRIO_NONE___1 = 0,
    PTHREAD_PRIO_INHERIT___1 = 1,
    PTHREAD_PRIO_PROTECT___1 = 2
} ;
#line 104
enum __anonenum__410 {
    PTHREAD_RWLOCK_PREFER_READER_NP___1 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___1 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___1 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___1 = 0
} ;
#line 124
enum __anonenum__411 {
    PTHREAD_INHERIT_SCHED___1 = 0,
    PTHREAD_EXPLICIT_SCHED___1 = 1
} ;
#line 134
enum __anonenum__412 {
    PTHREAD_SCOPE_SYSTEM___1 = 0,
    PTHREAD_SCOPE_PROCESS___1 = 1
} ;
#line 144
enum __anonenum__413 {
    PTHREAD_PROCESS_PRIVATE___1 = 0,
    PTHREAD_PROCESS_SHARED___1 = 1
} ;
#line 168
enum __anonenum__414 {
    PTHREAD_CANCEL_ENABLE___1 = 0,
    PTHREAD_CANCEL_DISABLE___1 = 1
} ;
#line 175
enum __anonenum__415 {
    PTHREAD_CANCEL_DEFERRED___1 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___1 = 1
} ;
#line 934 "/usr/include/math.h"
enum __anonenum__144___0 {
    FP_NAN___0 = 0,
    FP_INFINITE___0 = 1,
    FP_ZERO___0 = 2,
    FP_SUBNORMAL___0 = 3,
    FP_NORMAL___0 = 4
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__467 {
    SI_ASYNCNL___2 = -60,
    SI_DETHREAD___2 = -7,
    SI_TKILL___2 = -6,
    SI_SIGIO___2 = -5,
    SI_ASYNCIO___2 = -4,
    SI_MESGQ___2 = -3,
    SI_TIMER___2 = -2,
    SI_QUEUE___2 = -1,
    SI_USER___2 = 0,
    SI_KERNEL___2 = 128
} ;
#line 71
enum __anonenum__468 {
    ILL_ILLOPC___2 = 1,
    ILL_ILLOPN___2 = 2,
    ILL_ILLADR___2 = 3,
    ILL_ILLTRP___2 = 4,
    ILL_PRVOPC___2 = 5,
    ILL_PRVREG___2 = 6,
    ILL_COPROC___2 = 7,
    ILL_BADSTK___2 = 8,
    ILL_BADIADDR___2 = 9
} ;
#line 94
enum __anonenum__469 {
    FPE_INTDIV___2 = 1,
    FPE_INTOVF___2 = 2,
    FPE_FLTDIV___2 = 3,
    FPE_FLTOVF___2 = 4,
    FPE_FLTUND___2 = 5,
    FPE_FLTRES___2 = 6,
    FPE_FLTINV___2 = 7,
    FPE_FLTSUB___2 = 8,
    FPE_FLTUNK___2 = 14,
    FPE_CONDTRAP___2 = 15
} ;
#line 119
enum __anonenum__470 {
    SEGV_MAPERR___2 = 1,
    SEGV_ACCERR___2 = 2,
    SEGV_BNDERR___2 = 3,
    SEGV_PKUERR___2 = 4,
    SEGV_ACCADI___2 = 5,
    SEGV_ADIDERR___2 = 6,
    SEGV_ADIPERR___2 = 7,
    SEGV_MTEAERR___2 = 8,
    SEGV_MTESERR___2 = 9
} ;
#line 142
enum __anonenum__471 {
    BUS_ADRALN___2 = 1,
    BUS_ADRERR___2 = 2,
    BUS_OBJERR___2 = 3,
    BUS_MCEERR_AR___2 = 4,
    BUS_MCEERR_AO___2 = 5
} ;
#line 176
enum __anonenum__472 {
    CLD_EXITED___2 = 1,
    CLD_KILLED___2 = 2,
    CLD_DUMPED___2 = 3,
    CLD_TRAPPED___2 = 4,
    CLD_STOPPED___2 = 5,
    CLD_CONTINUED___2 = 6
} ;
#line 193
enum __anonenum__473 {
    POLL_IN___2 = 1,
    POLL_OUT___2 = 2,
    POLL_MSG___2 = 3,
    POLL_ERR___2 = 4,
    POLL_PRI___2 = 5,
    POLL_HUP___2 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__476 {
    SIGEV_SIGNAL___2 = 0,
    SIGEV_NONE___2 = 1,
    SIGEV_THREAD___2 = 2,
    SIGEV_THREAD_ID___2 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__481 {
    SS_ONSTACK___2 = 1,
    SS_DISABLE___2 = 2
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__489 {
    DT_UNKNOWN___2 = 0,
    DT_FIFO___2 = 1,
    DT_CHR___2 = 2,
    DT_DIR___2 = 4,
    DT_BLK___2 = 6,
    DT_REG___2 = 8,
    DT_LNK___2 = 10,
    DT_SOCK___2 = 12,
    DT_WHT___2 = 14
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__547 {
    PTHREAD_CREATE_JOINABLE___2 = 0,
    PTHREAD_CREATE_DETACHED___2 = 1
} ;
#line 47
enum __anonenum__548 {
    PTHREAD_MUTEX_TIMED_NP___2 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___2 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___2 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___2 = 3,
    PTHREAD_MUTEX_NORMAL___2 = 0,
    PTHREAD_MUTEX_RECURSIVE___2 = 1,
    PTHREAD_MUTEX_ERRORCHECK___2 = 2,
    PTHREAD_MUTEX_DEFAULT___2 = 0
} ;
#line 69
enum __anonenum__549 {
    PTHREAD_MUTEX_STALLED___2 = 0,
    PTHREAD_MUTEX_STALLED_NP___2 = 0,
    PTHREAD_MUTEX_ROBUST___2 = 1,
    PTHREAD_MUTEX_ROBUST_NP___2 = 1
} ;
#line 81
enum __anonenum__550 {
    PTHREAD_PRIO_NONE___2 = 0,
    PTHREAD_PRIO_INHERIT___2 = 1,
    PTHREAD_PRIO_PROTECT___2 = 2
} ;
#line 104
enum __anonenum__551 {
    PTHREAD_RWLOCK_PREFER_READER_NP___2 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___2 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___2 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___2 = 0
} ;
#line 124
enum __anonenum__552 {
    PTHREAD_INHERIT_SCHED___2 = 0,
    PTHREAD_EXPLICIT_SCHED___2 = 1
} ;
#line 134
enum __anonenum__553 {
    PTHREAD_SCOPE_SYSTEM___2 = 0,
    PTHREAD_SCOPE_PROCESS___2 = 1
} ;
#line 144
enum __anonenum__554 {
    PTHREAD_PROCESS_PRIVATE___2 = 0,
    PTHREAD_PROCESS_SHARED___2 = 1
} ;
#line 168
enum __anonenum__555 {
    PTHREAD_CANCEL_ENABLE___2 = 0,
    PTHREAD_CANCEL_DISABLE___2 = 1
} ;
#line 175
enum __anonenum__556 {
    PTHREAD_CANCEL_DEFERRED___2 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___2 = 1
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__607 {
    SI_ASYNCNL___3 = -60,
    SI_DETHREAD___3 = -7,
    SI_TKILL___3 = -6,
    SI_SIGIO___3 = -5,
    SI_ASYNCIO___3 = -4,
    SI_MESGQ___3 = -3,
    SI_TIMER___3 = -2,
    SI_QUEUE___3 = -1,
    SI_USER___3 = 0,
    SI_KERNEL___3 = 128
} ;
#line 71
enum __anonenum__608 {
    ILL_ILLOPC___3 = 1,
    ILL_ILLOPN___3 = 2,
    ILL_ILLADR___3 = 3,
    ILL_ILLTRP___3 = 4,
    ILL_PRVOPC___3 = 5,
    ILL_PRVREG___3 = 6,
    ILL_COPROC___3 = 7,
    ILL_BADSTK___3 = 8,
    ILL_BADIADDR___3 = 9
} ;
#line 94
enum __anonenum__609 {
    FPE_INTDIV___3 = 1,
    FPE_INTOVF___3 = 2,
    FPE_FLTDIV___3 = 3,
    FPE_FLTOVF___3 = 4,
    FPE_FLTUND___3 = 5,
    FPE_FLTRES___3 = 6,
    FPE_FLTINV___3 = 7,
    FPE_FLTSUB___3 = 8,
    FPE_FLTUNK___3 = 14,
    FPE_CONDTRAP___3 = 15
} ;
#line 119
enum __anonenum__610 {
    SEGV_MAPERR___3 = 1,
    SEGV_ACCERR___3 = 2,
    SEGV_BNDERR___3 = 3,
    SEGV_PKUERR___3 = 4,
    SEGV_ACCADI___3 = 5,
    SEGV_ADIDERR___3 = 6,
    SEGV_ADIPERR___3 = 7,
    SEGV_MTEAERR___3 = 8,
    SEGV_MTESERR___3 = 9
} ;
#line 142
enum __anonenum__611 {
    BUS_ADRALN___3 = 1,
    BUS_ADRERR___3 = 2,
    BUS_OBJERR___3 = 3,
    BUS_MCEERR_AR___3 = 4,
    BUS_MCEERR_AO___3 = 5
} ;
#line 176
enum __anonenum__612 {
    CLD_EXITED___3 = 1,
    CLD_KILLED___3 = 2,
    CLD_DUMPED___3 = 3,
    CLD_TRAPPED___3 = 4,
    CLD_STOPPED___3 = 5,
    CLD_CONTINUED___3 = 6
} ;
#line 193
enum __anonenum__613 {
    POLL_IN___3 = 1,
    POLL_OUT___3 = 2,
    POLL_MSG___3 = 3,
    POLL_ERR___3 = 4,
    POLL_PRI___3 = 5,
    POLL_HUP___3 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__616 {
    SIGEV_SIGNAL___3 = 0,
    SIGEV_NONE___3 = 1,
    SIGEV_THREAD___3 = 2,
    SIGEV_THREAD_ID___3 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__621 {
    SS_ONSTACK___3 = 1,
    SS_DISABLE___3 = 2
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__629 {
    DT_UNKNOWN___3 = 0,
    DT_FIFO___3 = 1,
    DT_CHR___3 = 2,
    DT_DIR___3 = 4,
    DT_BLK___3 = 6,
    DT_REG___3 = 8,
    DT_LNK___3 = 10,
    DT_SOCK___3 = 12,
    DT_WHT___3 = 14
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__688 {
    PTHREAD_CREATE_JOINABLE___3 = 0,
    PTHREAD_CREATE_DETACHED___3 = 1
} ;
#line 47
enum __anonenum__689 {
    PTHREAD_MUTEX_TIMED_NP___3 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___3 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___3 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___3 = 3,
    PTHREAD_MUTEX_NORMAL___3 = 0,
    PTHREAD_MUTEX_RECURSIVE___3 = 1,
    PTHREAD_MUTEX_ERRORCHECK___3 = 2,
    PTHREAD_MUTEX_DEFAULT___3 = 0
} ;
#line 69
enum __anonenum__690 {
    PTHREAD_MUTEX_STALLED___3 = 0,
    PTHREAD_MUTEX_STALLED_NP___3 = 0,
    PTHREAD_MUTEX_ROBUST___3 = 1,
    PTHREAD_MUTEX_ROBUST_NP___3 = 1
} ;
#line 81
enum __anonenum__691 {
    PTHREAD_PRIO_NONE___3 = 0,
    PTHREAD_PRIO_INHERIT___3 = 1,
    PTHREAD_PRIO_PROTECT___3 = 2
} ;
#line 104
enum __anonenum__692 {
    PTHREAD_RWLOCK_PREFER_READER_NP___3 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___3 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___3 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___3 = 0
} ;
#line 124
enum __anonenum__693 {
    PTHREAD_INHERIT_SCHED___3 = 0,
    PTHREAD_EXPLICIT_SCHED___3 = 1
} ;
#line 134
enum __anonenum__694 {
    PTHREAD_SCOPE_SYSTEM___3 = 0,
    PTHREAD_SCOPE_PROCESS___3 = 1
} ;
#line 144
enum __anonenum__695 {
    PTHREAD_PROCESS_PRIVATE___3 = 0,
    PTHREAD_PROCESS_SHARED___3 = 1
} ;
#line 168
enum __anonenum__696 {
    PTHREAD_CANCEL_ENABLE___3 = 0,
    PTHREAD_CANCEL_DISABLE___3 = 1
} ;
#line 175
enum __anonenum__697 {
    PTHREAD_CANCEL_DEFERRED___3 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___3 = 1
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__325___0 {
    SI_ASYNCNL___4 = -60,
    SI_DETHREAD___4 = -7,
    SI_TKILL___4 = -6,
    SI_SIGIO___4 = -5,
    SI_ASYNCIO___4 = -4,
    SI_MESGQ___4 = -3,
    SI_TIMER___4 = -2,
    SI_QUEUE___4 = -1,
    SI_USER___4 = 0,
    SI_KERNEL___4 = 128
} ;
#line 71
enum __anonenum__326___0 {
    ILL_ILLOPC___4 = 1,
    ILL_ILLOPN___4 = 2,
    ILL_ILLADR___4 = 3,
    ILL_ILLTRP___4 = 4,
    ILL_PRVOPC___4 = 5,
    ILL_PRVREG___4 = 6,
    ILL_COPROC___4 = 7,
    ILL_BADSTK___4 = 8,
    ILL_BADIADDR___4 = 9
} ;
#line 94
enum __anonenum__327___0 {
    FPE_INTDIV___4 = 1,
    FPE_INTOVF___4 = 2,
    FPE_FLTDIV___4 = 3,
    FPE_FLTOVF___4 = 4,
    FPE_FLTUND___4 = 5,
    FPE_FLTRES___4 = 6,
    FPE_FLTINV___4 = 7,
    FPE_FLTSUB___4 = 8,
    FPE_FLTUNK___4 = 14,
    FPE_CONDTRAP___4 = 15
} ;
#line 119
enum __anonenum__328___0 {
    SEGV_MAPERR___4 = 1,
    SEGV_ACCERR___4 = 2,
    SEGV_BNDERR___4 = 3,
    SEGV_PKUERR___4 = 4,
    SEGV_ACCADI___4 = 5,
    SEGV_ADIDERR___4 = 6,
    SEGV_ADIPERR___4 = 7,
    SEGV_MTEAERR___4 = 8,
    SEGV_MTESERR___4 = 9
} ;
#line 142
enum __anonenum__329___0 {
    BUS_ADRALN___4 = 1,
    BUS_ADRERR___4 = 2,
    BUS_OBJERR___4 = 3,
    BUS_MCEERR_AR___4 = 4,
    BUS_MCEERR_AO___4 = 5
} ;
#line 176
enum __anonenum__330___0 {
    CLD_EXITED___4 = 1,
    CLD_KILLED___4 = 2,
    CLD_DUMPED___4 = 3,
    CLD_TRAPPED___4 = 4,
    CLD_STOPPED___4 = 5,
    CLD_CONTINUED___4 = 6
} ;
#line 193
enum __anonenum__331___0 {
    POLL_IN___4 = 1,
    POLL_OUT___4 = 2,
    POLL_MSG___4 = 3,
    POLL_ERR___4 = 4,
    POLL_PRI___4 = 5,
    POLL_HUP___4 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__334___0 {
    SIGEV_SIGNAL___4 = 0,
    SIGEV_NONE___4 = 1,
    SIGEV_THREAD___4 = 2,
    SIGEV_THREAD_ID___4 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__339___0 {
    SS_ONSTACK___4 = 1,
    SS_DISABLE___4 = 2
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__347___0 {
    DT_UNKNOWN___4 = 0,
    DT_FIFO___4 = 1,
    DT_CHR___4 = 2,
    DT_DIR___4 = 4,
    DT_BLK___4 = 6,
    DT_REG___4 = 8,
    DT_LNK___4 = 10,
    DT_SOCK___4 = 12,
    DT_WHT___4 = 14
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__406___0 {
    PTHREAD_CREATE_JOINABLE___4 = 0,
    PTHREAD_CREATE_DETACHED___4 = 1
} ;
#line 47
enum __anonenum__407___0 {
    PTHREAD_MUTEX_TIMED_NP___4 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___4 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___4 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___4 = 3,
    PTHREAD_MUTEX_NORMAL___4 = 0,
    PTHREAD_MUTEX_RECURSIVE___4 = 1,
    PTHREAD_MUTEX_ERRORCHECK___4 = 2,
    PTHREAD_MUTEX_DEFAULT___4 = 0
} ;
#line 69
enum __anonenum__408___0 {
    PTHREAD_MUTEX_STALLED___4 = 0,
    PTHREAD_MUTEX_STALLED_NP___4 = 0,
    PTHREAD_MUTEX_ROBUST___4 = 1,
    PTHREAD_MUTEX_ROBUST_NP___4 = 1
} ;
#line 81
enum __anonenum__409___0 {
    PTHREAD_PRIO_NONE___4 = 0,
    PTHREAD_PRIO_INHERIT___4 = 1,
    PTHREAD_PRIO_PROTECT___4 = 2
} ;
#line 104
enum __anonenum__410___0 {
    PTHREAD_RWLOCK_PREFER_READER_NP___4 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___4 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___4 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___4 = 0
} ;
#line 124
enum __anonenum__411___0 {
    PTHREAD_INHERIT_SCHED___4 = 0,
    PTHREAD_EXPLICIT_SCHED___4 = 1
} ;
#line 134
enum __anonenum__412___0 {
    PTHREAD_SCOPE_SYSTEM___4 = 0,
    PTHREAD_SCOPE_PROCESS___4 = 1
} ;
#line 144
enum __anonenum__413___0 {
    PTHREAD_PROCESS_PRIVATE___4 = 0,
    PTHREAD_PROCESS_SHARED___4 = 1
} ;
#line 168
enum __anonenum__414___0 {
    PTHREAD_CANCEL_ENABLE___4 = 0,
    PTHREAD_CANCEL_DISABLE___4 = 1
} ;
#line 175
enum __anonenum__415___0 {
    PTHREAD_CANCEL_DEFERRED___4 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___4 = 1
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__738 {
    SI_ASYNCNL___5 = -60,
    SI_DETHREAD___5 = -7,
    SI_TKILL___5 = -6,
    SI_SIGIO___5 = -5,
    SI_ASYNCIO___5 = -4,
    SI_MESGQ___5 = -3,
    SI_TIMER___5 = -2,
    SI_QUEUE___5 = -1,
    SI_USER___5 = 0,
    SI_KERNEL___5 = 128
} ;
#line 71
enum __anonenum__739 {
    ILL_ILLOPC___5 = 1,
    ILL_ILLOPN___5 = 2,
    ILL_ILLADR___5 = 3,
    ILL_ILLTRP___5 = 4,
    ILL_PRVOPC___5 = 5,
    ILL_PRVREG___5 = 6,
    ILL_COPROC___5 = 7,
    ILL_BADSTK___5 = 8,
    ILL_BADIADDR___5 = 9
} ;
#line 94
enum __anonenum__740 {
    FPE_INTDIV___5 = 1,
    FPE_INTOVF___5 = 2,
    FPE_FLTDIV___5 = 3,
    FPE_FLTOVF___5 = 4,
    FPE_FLTUND___5 = 5,
    FPE_FLTRES___5 = 6,
    FPE_FLTINV___5 = 7,
    FPE_FLTSUB___5 = 8,
    FPE_FLTUNK___5 = 14,
    FPE_CONDTRAP___5 = 15
} ;
#line 119
enum __anonenum__741 {
    SEGV_MAPERR___5 = 1,
    SEGV_ACCERR___5 = 2,
    SEGV_BNDERR___5 = 3,
    SEGV_PKUERR___5 = 4,
    SEGV_ACCADI___5 = 5,
    SEGV_ADIDERR___5 = 6,
    SEGV_ADIPERR___5 = 7,
    SEGV_MTEAERR___5 = 8,
    SEGV_MTESERR___5 = 9
} ;
#line 142
enum __anonenum__742 {
    BUS_ADRALN___5 = 1,
    BUS_ADRERR___5 = 2,
    BUS_OBJERR___5 = 3,
    BUS_MCEERR_AR___5 = 4,
    BUS_MCEERR_AO___5 = 5
} ;
#line 176
enum __anonenum__743 {
    CLD_EXITED___5 = 1,
    CLD_KILLED___5 = 2,
    CLD_DUMPED___5 = 3,
    CLD_TRAPPED___5 = 4,
    CLD_STOPPED___5 = 5,
    CLD_CONTINUED___5 = 6
} ;
#line 193
enum __anonenum__744 {
    POLL_IN___5 = 1,
    POLL_OUT___5 = 2,
    POLL_MSG___5 = 3,
    POLL_ERR___5 = 4,
    POLL_PRI___5 = 5,
    POLL_HUP___5 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__747 {
    SIGEV_SIGNAL___5 = 0,
    SIGEV_NONE___5 = 1,
    SIGEV_THREAD___5 = 2,
    SIGEV_THREAD_ID___5 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__752 {
    SS_ONSTACK___5 = 1,
    SS_DISABLE___5 = 2
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__760 {
    DT_UNKNOWN___5 = 0,
    DT_FIFO___5 = 1,
    DT_CHR___5 = 2,
    DT_DIR___5 = 4,
    DT_BLK___5 = 6,
    DT_REG___5 = 8,
    DT_LNK___5 = 10,
    DT_SOCK___5 = 12,
    DT_WHT___5 = 14
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__819 {
    PTHREAD_CREATE_JOINABLE___5 = 0,
    PTHREAD_CREATE_DETACHED___5 = 1
} ;
#line 47
enum __anonenum__820 {
    PTHREAD_MUTEX_TIMED_NP___5 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___5 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___5 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___5 = 3,
    PTHREAD_MUTEX_NORMAL___5 = 0,
    PTHREAD_MUTEX_RECURSIVE___5 = 1,
    PTHREAD_MUTEX_ERRORCHECK___5 = 2,
    PTHREAD_MUTEX_DEFAULT___5 = 0
} ;
#line 69
enum __anonenum__821 {
    PTHREAD_MUTEX_STALLED___5 = 0,
    PTHREAD_MUTEX_STALLED_NP___5 = 0,
    PTHREAD_MUTEX_ROBUST___5 = 1,
    PTHREAD_MUTEX_ROBUST_NP___5 = 1
} ;
#line 81
enum __anonenum__822 {
    PTHREAD_PRIO_NONE___5 = 0,
    PTHREAD_PRIO_INHERIT___5 = 1,
    PTHREAD_PRIO_PROTECT___5 = 2
} ;
#line 104
enum __anonenum__823 {
    PTHREAD_RWLOCK_PREFER_READER_NP___5 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___5 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___5 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___5 = 0
} ;
#line 124
enum __anonenum__409___1 {
    PTHREAD_INHERIT_SCHED___5 = 0,
    PTHREAD_EXPLICIT_SCHED___5 = 1
} ;
#line 134
enum __anonenum__824 {
    PTHREAD_SCOPE_SYSTEM___5 = 0,
    PTHREAD_SCOPE_PROCESS___5 = 1
} ;
#line 144
enum __anonenum__825 {
    PTHREAD_PROCESS_PRIVATE___5 = 0,
    PTHREAD_PROCESS_SHARED___5 = 1
} ;
#line 168
enum __anonenum__826 {
    PTHREAD_CANCEL_ENABLE___5 = 0,
    PTHREAD_CANCEL_DISABLE___5 = 1
} ;
#line 175
enum __anonenum__827 {
    PTHREAD_CANCEL_DEFERRED___5 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___5 = 1
} ;
#line 37 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/thin-image.c"
typedef unsigned char Pixel[3];
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__876 {
    SI_ASYNCNL___6 = -60,
    SI_DETHREAD___6 = -7,
    SI_TKILL___6 = -6,
    SI_SIGIO___6 = -5,
    SI_ASYNCIO___6 = -4,
    SI_MESGQ___6 = -3,
    SI_TIMER___6 = -2,
    SI_QUEUE___6 = -1,
    SI_USER___6 = 0,
    SI_KERNEL___6 = 128
} ;
#line 71
enum __anonenum__877 {
    ILL_ILLOPC___6 = 1,
    ILL_ILLOPN___6 = 2,
    ILL_ILLADR___6 = 3,
    ILL_ILLTRP___6 = 4,
    ILL_PRVOPC___6 = 5,
    ILL_PRVREG___6 = 6,
    ILL_COPROC___6 = 7,
    ILL_BADSTK___6 = 8,
    ILL_BADIADDR___6 = 9
} ;
#line 94
enum __anonenum__878 {
    FPE_INTDIV___6 = 1,
    FPE_INTOVF___6 = 2,
    FPE_FLTDIV___6 = 3,
    FPE_FLTOVF___6 = 4,
    FPE_FLTUND___6 = 5,
    FPE_FLTRES___6 = 6,
    FPE_FLTINV___6 = 7,
    FPE_FLTSUB___6 = 8,
    FPE_FLTUNK___6 = 14,
    FPE_CONDTRAP___6 = 15
} ;
#line 119
enum __anonenum__879 {
    SEGV_MAPERR___6 = 1,
    SEGV_ACCERR___6 = 2,
    SEGV_BNDERR___6 = 3,
    SEGV_PKUERR___6 = 4,
    SEGV_ACCADI___6 = 5,
    SEGV_ADIDERR___6 = 6,
    SEGV_ADIPERR___6 = 7,
    SEGV_MTEAERR___6 = 8,
    SEGV_MTESERR___6 = 9
} ;
#line 142
enum __anonenum__880 {
    BUS_ADRALN___6 = 1,
    BUS_ADRERR___6 = 2,
    BUS_OBJERR___6 = 3,
    BUS_MCEERR_AR___6 = 4,
    BUS_MCEERR_AO___6 = 5
} ;
#line 176
enum __anonenum__881 {
    CLD_EXITED___6 = 1,
    CLD_KILLED___6 = 2,
    CLD_DUMPED___6 = 3,
    CLD_TRAPPED___6 = 4,
    CLD_STOPPED___6 = 5,
    CLD_CONTINUED___6 = 6
} ;
#line 193
enum __anonenum__882 {
    POLL_IN___6 = 1,
    POLL_OUT___6 = 2,
    POLL_MSG___6 = 3,
    POLL_ERR___6 = 4,
    POLL_PRI___6 = 5,
    POLL_HUP___6 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__885 {
    SIGEV_SIGNAL___6 = 0,
    SIGEV_NONE___6 = 1,
    SIGEV_THREAD___6 = 2,
    SIGEV_THREAD_ID___6 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__890 {
    SS_ONSTACK___6 = 1,
    SS_DISABLE___6 = 2
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__898 {
    DT_UNKNOWN___6 = 0,
    DT_FIFO___6 = 1,
    DT_CHR___6 = 2,
    DT_DIR___6 = 4,
    DT_BLK___6 = 6,
    DT_REG___6 = 8,
    DT_LNK___6 = 10,
    DT_SOCK___6 = 12,
    DT_WHT___6 = 14
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__819___0 {
    PTHREAD_CREATE_JOINABLE___6 = 0,
    PTHREAD_CREATE_DETACHED___6 = 1
} ;
#line 47
enum __anonenum__820___0 {
    PTHREAD_MUTEX_TIMED_NP___6 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___6 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___6 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___6 = 3,
    PTHREAD_MUTEX_NORMAL___6 = 0,
    PTHREAD_MUTEX_RECURSIVE___6 = 1,
    PTHREAD_MUTEX_ERRORCHECK___6 = 2,
    PTHREAD_MUTEX_DEFAULT___6 = 0
} ;
#line 69
enum __anonenum__821___0 {
    PTHREAD_MUTEX_STALLED___6 = 0,
    PTHREAD_MUTEX_STALLED_NP___6 = 0,
    PTHREAD_MUTEX_ROBUST___6 = 1,
    PTHREAD_MUTEX_ROBUST_NP___6 = 1
} ;
#line 81
enum __anonenum__822___0 {
    PTHREAD_PRIO_NONE___6 = 0,
    PTHREAD_PRIO_INHERIT___6 = 1,
    PTHREAD_PRIO_PROTECT___6 = 2
} ;
#line 104
enum __anonenum__823___0 {
    PTHREAD_RWLOCK_PREFER_READER_NP___6 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___6 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___6 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___6 = 0
} ;
#line 124
enum __anonenum__409___2 {
    PTHREAD_INHERIT_SCHED___6 = 0,
    PTHREAD_EXPLICIT_SCHED___6 = 1
} ;
#line 134
enum __anonenum__824___0 {
    PTHREAD_SCOPE_SYSTEM___6 = 0,
    PTHREAD_SCOPE_PROCESS___6 = 1
} ;
#line 144
enum __anonenum__825___0 {
    PTHREAD_PROCESS_PRIVATE___6 = 0,
    PTHREAD_PROCESS_SHARED___6 = 1
} ;
#line 168
enum __anonenum__826___0 {
    PTHREAD_CANCEL_ENABLE___6 = 0,
    PTHREAD_CANCEL_DISABLE___6 = 1
} ;
#line 175
enum __anonenum__827___0 {
    PTHREAD_CANCEL_DEFERRED___6 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___6 = 1
} ;
#line 38 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/quantize.h"
typedef unsigned long ColorFreq;
#line 39 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/quantize.h"
typedef ColorFreq *Histogram;
#line 41 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/quantize.h"
struct __anonstruct_916 {
   int desired_number_of_colors ;
   int actual_number_of_colors ;
   at_color cmap[256] ;
   ColorFreq freq[256] ;
   Histogram histogram ;
};
#line 47 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/quantize.h"
typedef struct __anonstruct_916 QuantizeObj;
#line 51 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/median.c"
struct __anonstruct_917 {
   int Rmin ;
   int Rmax ;
   int Gmin ;
   int Gmax ;
   int Bmin ;
   int Bmax ;
   int volume ;
   long colorcount ;
};
#line 60 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/median.c"
typedef struct __anonstruct_917 box;
#line 60 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/median.c"
typedef struct __anonstruct_917 *boxptr;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__325___1 {
    SI_ASYNCNL___7 = -60,
    SI_DETHREAD___7 = -7,
    SI_TKILL___7 = -6,
    SI_SIGIO___7 = -5,
    SI_ASYNCIO___7 = -4,
    SI_MESGQ___7 = -3,
    SI_TIMER___7 = -2,
    SI_QUEUE___7 = -1,
    SI_USER___7 = 0,
    SI_KERNEL___7 = 128
} ;
#line 71
enum __anonenum__326___1 {
    ILL_ILLOPC___7 = 1,
    ILL_ILLOPN___7 = 2,
    ILL_ILLADR___7 = 3,
    ILL_ILLTRP___7 = 4,
    ILL_PRVOPC___7 = 5,
    ILL_PRVREG___7 = 6,
    ILL_COPROC___7 = 7,
    ILL_BADSTK___7 = 8,
    ILL_BADIADDR___7 = 9
} ;
#line 94
enum __anonenum__327___1 {
    FPE_INTDIV___7 = 1,
    FPE_INTOVF___7 = 2,
    FPE_FLTDIV___7 = 3,
    FPE_FLTOVF___7 = 4,
    FPE_FLTUND___7 = 5,
    FPE_FLTRES___7 = 6,
    FPE_FLTINV___7 = 7,
    FPE_FLTSUB___7 = 8,
    FPE_FLTUNK___7 = 14,
    FPE_CONDTRAP___7 = 15
} ;
#line 119
enum __anonenum__328___1 {
    SEGV_MAPERR___7 = 1,
    SEGV_ACCERR___7 = 2,
    SEGV_BNDERR___7 = 3,
    SEGV_PKUERR___7 = 4,
    SEGV_ACCADI___7 = 5,
    SEGV_ADIDERR___7 = 6,
    SEGV_ADIPERR___7 = 7,
    SEGV_MTEAERR___7 = 8,
    SEGV_MTESERR___7 = 9
} ;
#line 142
enum __anonenum__329___1 {
    BUS_ADRALN___7 = 1,
    BUS_ADRERR___7 = 2,
    BUS_OBJERR___7 = 3,
    BUS_MCEERR_AR___7 = 4,
    BUS_MCEERR_AO___7 = 5
} ;
#line 176
enum __anonenum__330___1 {
    CLD_EXITED___7 = 1,
    CLD_KILLED___7 = 2,
    CLD_DUMPED___7 = 3,
    CLD_TRAPPED___7 = 4,
    CLD_STOPPED___7 = 5,
    CLD_CONTINUED___7 = 6
} ;
#line 193
enum __anonenum__331___1 {
    POLL_IN___7 = 1,
    POLL_OUT___7 = 2,
    POLL_MSG___7 = 3,
    POLL_ERR___7 = 4,
    POLL_PRI___7 = 5,
    POLL_HUP___7 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__334___1 {
    SIGEV_SIGNAL___7 = 0,
    SIGEV_NONE___7 = 1,
    SIGEV_THREAD___7 = 2,
    SIGEV_THREAD_ID___7 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__339___1 {
    SS_ONSTACK___7 = 1,
    SS_DISABLE___7 = 2
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__347___1 {
    DT_UNKNOWN___7 = 0,
    DT_FIFO___7 = 1,
    DT_CHR___7 = 2,
    DT_DIR___7 = 4,
    DT_BLK___7 = 6,
    DT_REG___7 = 8,
    DT_LNK___7 = 10,
    DT_SOCK___7 = 12,
    DT_WHT___7 = 14
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__406___1 {
    PTHREAD_CREATE_JOINABLE___7 = 0,
    PTHREAD_CREATE_DETACHED___7 = 1
} ;
#line 47
enum __anonenum__407___1 {
    PTHREAD_MUTEX_TIMED_NP___7 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___7 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___7 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___7 = 3,
    PTHREAD_MUTEX_NORMAL___7 = 0,
    PTHREAD_MUTEX_RECURSIVE___7 = 1,
    PTHREAD_MUTEX_ERRORCHECK___7 = 2,
    PTHREAD_MUTEX_DEFAULT___7 = 0
} ;
#line 69
enum __anonenum__408___1 {
    PTHREAD_MUTEX_STALLED___7 = 0,
    PTHREAD_MUTEX_STALLED_NP___7 = 0,
    PTHREAD_MUTEX_ROBUST___7 = 1,
    PTHREAD_MUTEX_ROBUST_NP___7 = 1
} ;
#line 81
enum __anonenum__409___3 {
    PTHREAD_PRIO_NONE___7 = 0,
    PTHREAD_PRIO_INHERIT___7 = 1,
    PTHREAD_PRIO_PROTECT___7 = 2
} ;
#line 104
enum __anonenum__410___1 {
    PTHREAD_RWLOCK_PREFER_READER_NP___7 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___7 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___7 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___7 = 0
} ;
#line 124
enum __anonenum__411___1 {
    PTHREAD_INHERIT_SCHED___7 = 0,
    PTHREAD_EXPLICIT_SCHED___7 = 1
} ;
#line 134
enum __anonenum__412___1 {
    PTHREAD_SCOPE_SYSTEM___7 = 0,
    PTHREAD_SCOPE_PROCESS___7 = 1
} ;
#line 144
enum __anonenum__413___1 {
    PTHREAD_PROCESS_PRIVATE___7 = 0,
    PTHREAD_PROCESS_SHARED___7 = 1
} ;
#line 168
enum __anonenum__414___1 {
    PTHREAD_CANCEL_ENABLE___7 = 0,
    PTHREAD_CANCEL_DISABLE___7 = 1
} ;
#line 175
enum __anonenum__415___1 {
    PTHREAD_CANCEL_DEFERRED___7 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___7 = 1
} ;
#line 12 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/pxl-outline.h"
struct __anonstruct_923 {
   at_coord *data ;
   unsigned int length ;
   gboolean clockwise ;
   at_color color ;
   gboolean open ;
};
#line 18 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/pxl-outline.h"
typedef struct __anonstruct_923 pixel_outline_type;
#line 38 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/pxl-outline.h"
struct __anonstruct_924 {
   pixel_outline_type *data ;
   unsigned int length ;
};
#line 41 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/pxl-outline.h"
typedef struct __anonstruct_924 pixel_outline_list_type;
#line 27 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/pxl-outline.c"
enum __anonenum__925 {
    TOP = 1,
    LEFT = 2,
    BOTTOM = 3,
    RIGHT = 0,
    NO_EDGE = 4
} ;
#line 29 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/pxl-outline.c"
typedef enum __anonenum__925 edge_type;
#line 36
enum __anonenum__926 {
    NORTH = 0,
    NORTHWEST = 1,
    WEST = 2,
    SOUTHWEST = 3,
    SOUTH = 4,
    SOUTHEAST = 5,
    EAST = 6,
    NORTHEAST = 7
} ;
#line 39 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/pxl-outline.c"
typedef enum __anonenum__926 direction_type;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__325___2 {
    SI_ASYNCNL___8 = -60,
    SI_DETHREAD___8 = -7,
    SI_TKILL___8 = -6,
    SI_SIGIO___8 = -5,
    SI_ASYNCIO___8 = -4,
    SI_MESGQ___8 = -3,
    SI_TIMER___8 = -2,
    SI_QUEUE___8 = -1,
    SI_USER___8 = 0,
    SI_KERNEL___8 = 128
} ;
#line 71
enum __anonenum__326___2 {
    ILL_ILLOPC___8 = 1,
    ILL_ILLOPN___8 = 2,
    ILL_ILLADR___8 = 3,
    ILL_ILLTRP___8 = 4,
    ILL_PRVOPC___8 = 5,
    ILL_PRVREG___8 = 6,
    ILL_COPROC___8 = 7,
    ILL_BADSTK___8 = 8,
    ILL_BADIADDR___8 = 9
} ;
#line 94
enum __anonenum__327___2 {
    FPE_INTDIV___8 = 1,
    FPE_INTOVF___8 = 2,
    FPE_FLTDIV___8 = 3,
    FPE_FLTOVF___8 = 4,
    FPE_FLTUND___8 = 5,
    FPE_FLTRES___8 = 6,
    FPE_FLTINV___8 = 7,
    FPE_FLTSUB___8 = 8,
    FPE_FLTUNK___8 = 14,
    FPE_CONDTRAP___8 = 15
} ;
#line 119
enum __anonenum__328___2 {
    SEGV_MAPERR___8 = 1,
    SEGV_ACCERR___8 = 2,
    SEGV_BNDERR___8 = 3,
    SEGV_PKUERR___8 = 4,
    SEGV_ACCADI___8 = 5,
    SEGV_ADIDERR___8 = 6,
    SEGV_ADIPERR___8 = 7,
    SEGV_MTEAERR___8 = 8,
    SEGV_MTESERR___8 = 9
} ;
#line 142
enum __anonenum__329___2 {
    BUS_ADRALN___8 = 1,
    BUS_ADRERR___8 = 2,
    BUS_OBJERR___8 = 3,
    BUS_MCEERR_AR___8 = 4,
    BUS_MCEERR_AO___8 = 5
} ;
#line 176
enum __anonenum__330___2 {
    CLD_EXITED___8 = 1,
    CLD_KILLED___8 = 2,
    CLD_DUMPED___8 = 3,
    CLD_TRAPPED___8 = 4,
    CLD_STOPPED___8 = 5,
    CLD_CONTINUED___8 = 6
} ;
#line 193
enum __anonenum__331___2 {
    POLL_IN___8 = 1,
    POLL_OUT___8 = 2,
    POLL_MSG___8 = 3,
    POLL_ERR___8 = 4,
    POLL_PRI___8 = 5,
    POLL_HUP___8 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__334___2 {
    SIGEV_SIGNAL___8 = 0,
    SIGEV_NONE___8 = 1,
    SIGEV_THREAD___8 = 2,
    SIGEV_THREAD_ID___8 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__339___2 {
    SS_ONSTACK___8 = 1,
    SS_DISABLE___8 = 2
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__347___2 {
    DT_UNKNOWN___8 = 0,
    DT_FIFO___8 = 1,
    DT_CHR___8 = 2,
    DT_DIR___8 = 4,
    DT_BLK___8 = 6,
    DT_REG___8 = 8,
    DT_LNK___8 = 10,
    DT_SOCK___8 = 12,
    DT_WHT___8 = 14
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__406___2 {
    PTHREAD_CREATE_JOINABLE___8 = 0,
    PTHREAD_CREATE_DETACHED___8 = 1
} ;
#line 47
enum __anonenum__407___2 {
    PTHREAD_MUTEX_TIMED_NP___8 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___8 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___8 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___8 = 3,
    PTHREAD_MUTEX_NORMAL___8 = 0,
    PTHREAD_MUTEX_RECURSIVE___8 = 1,
    PTHREAD_MUTEX_ERRORCHECK___8 = 2,
    PTHREAD_MUTEX_DEFAULT___8 = 0
} ;
#line 69
enum __anonenum__408___2 {
    PTHREAD_MUTEX_STALLED___8 = 0,
    PTHREAD_MUTEX_STALLED_NP___8 = 0,
    PTHREAD_MUTEX_ROBUST___8 = 1,
    PTHREAD_MUTEX_ROBUST_NP___8 = 1
} ;
#line 81
enum __anonenum__409___4 {
    PTHREAD_PRIO_NONE___8 = 0,
    PTHREAD_PRIO_INHERIT___8 = 1,
    PTHREAD_PRIO_PROTECT___8 = 2
} ;
#line 104
enum __anonenum__410___2 {
    PTHREAD_RWLOCK_PREFER_READER_NP___8 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___8 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___8 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___8 = 0
} ;
#line 124
enum __anonenum__411___2 {
    PTHREAD_INHERIT_SCHED___8 = 0,
    PTHREAD_EXPLICIT_SCHED___8 = 1
} ;
#line 134
enum __anonenum__412___2 {
    PTHREAD_SCOPE_SYSTEM___8 = 0,
    PTHREAD_SCOPE_PROCESS___8 = 1
} ;
#line 144
enum __anonenum__413___2 {
    PTHREAD_PROCESS_PRIVATE___8 = 0,
    PTHREAD_PROCESS_SHARED___8 = 1
} ;
#line 168
enum __anonenum__414___2 {
    PTHREAD_CANCEL_ENABLE___8 = 0,
    PTHREAD_CANCEL_DISABLE___8 = 1
} ;
#line 175
enum __anonenum__415___2 {
    PTHREAD_CANCEL_DEFERRED___8 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___8 = 1
} ;
#line 33 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input.c"
struct _at_input_format_entry ;
#line 33 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input.c"
typedef struct _at_input_format_entry at_input_format_entry;
#line 34 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input.c"
struct _at_input_format_entry {
   at_bitmap_reader reader ;
   gchar *descr ;
   GDestroyNotify user_data_destroy_func ;
};
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__325___3 {
    SI_ASYNCNL___9 = -60,
    SI_DETHREAD___9 = -7,
    SI_TKILL___9 = -6,
    SI_SIGIO___9 = -5,
    SI_ASYNCIO___9 = -4,
    SI_MESGQ___9 = -3,
    SI_TIMER___9 = -2,
    SI_QUEUE___9 = -1,
    SI_USER___9 = 0,
    SI_KERNEL___9 = 128
} ;
#line 71
enum __anonenum__326___3 {
    ILL_ILLOPC___9 = 1,
    ILL_ILLOPN___9 = 2,
    ILL_ILLADR___9 = 3,
    ILL_ILLTRP___9 = 4,
    ILL_PRVOPC___9 = 5,
    ILL_PRVREG___9 = 6,
    ILL_COPROC___9 = 7,
    ILL_BADSTK___9 = 8,
    ILL_BADIADDR___9 = 9
} ;
#line 94
enum __anonenum__327___3 {
    FPE_INTDIV___9 = 1,
    FPE_INTOVF___9 = 2,
    FPE_FLTDIV___9 = 3,
    FPE_FLTOVF___9 = 4,
    FPE_FLTUND___9 = 5,
    FPE_FLTRES___9 = 6,
    FPE_FLTINV___9 = 7,
    FPE_FLTSUB___9 = 8,
    FPE_FLTUNK___9 = 14,
    FPE_CONDTRAP___9 = 15
} ;
#line 119
enum __anonenum__328___3 {
    SEGV_MAPERR___9 = 1,
    SEGV_ACCERR___9 = 2,
    SEGV_BNDERR___9 = 3,
    SEGV_PKUERR___9 = 4,
    SEGV_ACCADI___9 = 5,
    SEGV_ADIDERR___9 = 6,
    SEGV_ADIPERR___9 = 7,
    SEGV_MTEAERR___9 = 8,
    SEGV_MTESERR___9 = 9
} ;
#line 142
enum __anonenum__329___3 {
    BUS_ADRALN___9 = 1,
    BUS_ADRERR___9 = 2,
    BUS_OBJERR___9 = 3,
    BUS_MCEERR_AR___9 = 4,
    BUS_MCEERR_AO___9 = 5
} ;
#line 176
enum __anonenum__330___3 {
    CLD_EXITED___9 = 1,
    CLD_KILLED___9 = 2,
    CLD_DUMPED___9 = 3,
    CLD_TRAPPED___9 = 4,
    CLD_STOPPED___9 = 5,
    CLD_CONTINUED___9 = 6
} ;
#line 193
enum __anonenum__331___3 {
    POLL_IN___9 = 1,
    POLL_OUT___9 = 2,
    POLL_MSG___9 = 3,
    POLL_ERR___9 = 4,
    POLL_PRI___9 = 5,
    POLL_HUP___9 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__334___3 {
    SIGEV_SIGNAL___9 = 0,
    SIGEV_NONE___9 = 1,
    SIGEV_THREAD___9 = 2,
    SIGEV_THREAD_ID___9 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__339___3 {
    SS_ONSTACK___9 = 1,
    SS_DISABLE___9 = 2
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__347___3 {
    DT_UNKNOWN___9 = 0,
    DT_FIFO___9 = 1,
    DT_CHR___9 = 2,
    DT_DIR___9 = 4,
    DT_BLK___9 = 6,
    DT_REG___9 = 8,
    DT_LNK___9 = 10,
    DT_SOCK___9 = 12,
    DT_WHT___9 = 14
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__406___3 {
    PTHREAD_CREATE_JOINABLE___9 = 0,
    PTHREAD_CREATE_DETACHED___9 = 1
} ;
#line 47
enum __anonenum__407___3 {
    PTHREAD_MUTEX_TIMED_NP___9 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___9 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___9 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___9 = 3,
    PTHREAD_MUTEX_NORMAL___9 = 0,
    PTHREAD_MUTEX_RECURSIVE___9 = 1,
    PTHREAD_MUTEX_ERRORCHECK___9 = 2,
    PTHREAD_MUTEX_DEFAULT___9 = 0
} ;
#line 69
enum __anonenum__408___3 {
    PTHREAD_MUTEX_STALLED___9 = 0,
    PTHREAD_MUTEX_STALLED_NP___9 = 0,
    PTHREAD_MUTEX_ROBUST___9 = 1,
    PTHREAD_MUTEX_ROBUST_NP___9 = 1
} ;
#line 81
enum __anonenum__409___5 {
    PTHREAD_PRIO_NONE___9 = 0,
    PTHREAD_PRIO_INHERIT___9 = 1,
    PTHREAD_PRIO_PROTECT___9 = 2
} ;
#line 104
enum __anonenum__410___3 {
    PTHREAD_RWLOCK_PREFER_READER_NP___9 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___9 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___9 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___9 = 0
} ;
#line 124
enum __anonenum__411___3 {
    PTHREAD_INHERIT_SCHED___9 = 0,
    PTHREAD_EXPLICIT_SCHED___9 = 1
} ;
#line 134
enum __anonenum__412___3 {
    PTHREAD_SCOPE_SYSTEM___9 = 0,
    PTHREAD_SCOPE_PROCESS___9 = 1
} ;
#line 144
enum __anonenum__413___3 {
    PTHREAD_PROCESS_PRIVATE___9 = 0,
    PTHREAD_PROCESS_SHARED___9 = 1
} ;
#line 168
enum __anonenum__414___3 {
    PTHREAD_CANCEL_ENABLE___9 = 0,
    PTHREAD_CANCEL_DISABLE___9 = 1
} ;
#line 175
enum __anonenum__415___3 {
    PTHREAD_CANCEL_DEFERRED___9 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___9 = 1
} ;
#line 35 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output.c"
struct _at_output_format_entry ;
#line 35 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output.c"
typedef struct _at_output_format_entry at_output_format_entry;
#line 36 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output.c"
struct _at_output_format_entry {
   at_spline_writer writer ;
   char const   *descr ;
   GDestroyNotify user_data_destroy_func ;
};
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__37___0 {
    SI_ASYNCNL___10 = -60,
    SI_DETHREAD___10 = -7,
    SI_TKILL___10 = -6,
    SI_SIGIO___10 = -5,
    SI_ASYNCIO___10 = -4,
    SI_MESGQ___10 = -3,
    SI_TIMER___10 = -2,
    SI_QUEUE___10 = -1,
    SI_USER___10 = 0,
    SI_KERNEL___10 = 128
} ;
#line 71
enum __anonenum__38___0 {
    ILL_ILLOPC___10 = 1,
    ILL_ILLOPN___10 = 2,
    ILL_ILLADR___10 = 3,
    ILL_ILLTRP___10 = 4,
    ILL_PRVOPC___10 = 5,
    ILL_PRVREG___10 = 6,
    ILL_COPROC___10 = 7,
    ILL_BADSTK___10 = 8,
    ILL_BADIADDR___10 = 9
} ;
#line 94
enum __anonenum__39___0 {
    FPE_INTDIV___10 = 1,
    FPE_INTOVF___10 = 2,
    FPE_FLTDIV___10 = 3,
    FPE_FLTOVF___10 = 4,
    FPE_FLTUND___10 = 5,
    FPE_FLTRES___10 = 6,
    FPE_FLTINV___10 = 7,
    FPE_FLTSUB___10 = 8,
    FPE_FLTUNK___10 = 14,
    FPE_CONDTRAP___10 = 15
} ;
#line 119
enum __anonenum__40___0 {
    SEGV_MAPERR___10 = 1,
    SEGV_ACCERR___10 = 2,
    SEGV_BNDERR___10 = 3,
    SEGV_PKUERR___10 = 4,
    SEGV_ACCADI___10 = 5,
    SEGV_ADIDERR___10 = 6,
    SEGV_ADIPERR___10 = 7,
    SEGV_MTEAERR___10 = 8,
    SEGV_MTESERR___10 = 9
} ;
#line 142
enum __anonenum__41___0 {
    BUS_ADRALN___10 = 1,
    BUS_ADRERR___10 = 2,
    BUS_OBJERR___10 = 3,
    BUS_MCEERR_AR___10 = 4,
    BUS_MCEERR_AO___10 = 5
} ;
#line 176
enum __anonenum__42___0 {
    CLD_EXITED___10 = 1,
    CLD_KILLED___10 = 2,
    CLD_DUMPED___10 = 3,
    CLD_TRAPPED___10 = 4,
    CLD_STOPPED___10 = 5,
    CLD_CONTINUED___10 = 6
} ;
#line 193
enum __anonenum__43___0 {
    POLL_IN___10 = 1,
    POLL_OUT___10 = 2,
    POLL_MSG___10 = 3,
    POLL_ERR___10 = 4,
    POLL_PRI___10 = 5,
    POLL_HUP___10 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__46___0 {
    SIGEV_SIGNAL___10 = 0,
    SIGEV_NONE___10 = 1,
    SIGEV_THREAD___10 = 2,
    SIGEV_THREAD_ID___10 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__51___0 {
    SS_ONSTACK___10 = 1,
    SS_DISABLE___10 = 2
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__59___0 {
    DT_UNKNOWN___10 = 0,
    DT_FIFO___10 = 1,
    DT_CHR___10 = 2,
    DT_DIR___10 = 4,
    DT_BLK___10 = 6,
    DT_REG___10 = 8,
    DT_LNK___10 = 10,
    DT_SOCK___10 = 12,
    DT_WHT___10 = 14
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__118___0 {
    PTHREAD_CREATE_JOINABLE___10 = 0,
    PTHREAD_CREATE_DETACHED___10 = 1
} ;
#line 47
enum __anonenum__119___0 {
    PTHREAD_MUTEX_TIMED_NP___10 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___10 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___10 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___10 = 3,
    PTHREAD_MUTEX_NORMAL___10 = 0,
    PTHREAD_MUTEX_RECURSIVE___10 = 1,
    PTHREAD_MUTEX_ERRORCHECK___10 = 2,
    PTHREAD_MUTEX_DEFAULT___10 = 0
} ;
#line 69
enum __anonenum__120___0 {
    PTHREAD_MUTEX_STALLED___10 = 0,
    PTHREAD_MUTEX_STALLED_NP___10 = 0,
    PTHREAD_MUTEX_ROBUST___10 = 1,
    PTHREAD_MUTEX_ROBUST_NP___10 = 1
} ;
#line 81
enum __anonenum__121___0 {
    PTHREAD_PRIO_NONE___10 = 0,
    PTHREAD_PRIO_INHERIT___10 = 1,
    PTHREAD_PRIO_PROTECT___10 = 2
} ;
#line 104
enum __anonenum__122___0 {
    PTHREAD_RWLOCK_PREFER_READER_NP___10 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___10 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___10 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___10 = 0
} ;
#line 124
enum __anonenum__123___0 {
    PTHREAD_INHERIT_SCHED___10 = 0,
    PTHREAD_EXPLICIT_SCHED___10 = 1
} ;
#line 134
enum __anonenum__124___0 {
    PTHREAD_SCOPE_SYSTEM___10 = 0,
    PTHREAD_SCOPE_PROCESS___10 = 1
} ;
#line 144
enum __anonenum__125___0 {
    PTHREAD_PROCESS_PRIVATE___10 = 0,
    PTHREAD_PROCESS_SHARED___10 = 1
} ;
#line 168
enum __anonenum__126___0 {
    PTHREAD_CANCEL_ENABLE___10 = 0,
    PTHREAD_CANCEL_DISABLE___10 = 1
} ;
#line 175
enum __anonenum__127___0 {
    PTHREAD_CANCEL_DEFERRED___10 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___10 = 1
} ;
#line 14 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/fit.h"
typedef at_fitting_opts_type fitting_opts_type;
#line 11 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/image-header.h"
struct __anonstruct_930 {
   unsigned short hres ;
   unsigned short vres ;
   unsigned short width ;
   unsigned short height ;
   unsigned short depth ;
   unsigned int format ;
};
#line 16 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/image-header.h"
typedef struct __anonstruct_930 image_header_type;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__967 {
    SI_ASYNCNL___11 = -60,
    SI_DETHREAD___11 = -7,
    SI_TKILL___11 = -6,
    SI_SIGIO___11 = -5,
    SI_ASYNCIO___11 = -4,
    SI_MESGQ___11 = -3,
    SI_TIMER___11 = -2,
    SI_QUEUE___11 = -1,
    SI_USER___11 = 0,
    SI_KERNEL___11 = 128
} ;
#line 71
enum __anonenum__968 {
    ILL_ILLOPC___11 = 1,
    ILL_ILLOPN___11 = 2,
    ILL_ILLADR___11 = 3,
    ILL_ILLTRP___11 = 4,
    ILL_PRVOPC___11 = 5,
    ILL_PRVREG___11 = 6,
    ILL_COPROC___11 = 7,
    ILL_BADSTK___11 = 8,
    ILL_BADIADDR___11 = 9
} ;
#line 94
enum __anonenum__969 {
    FPE_INTDIV___11 = 1,
    FPE_INTOVF___11 = 2,
    FPE_FLTDIV___11 = 3,
    FPE_FLTOVF___11 = 4,
    FPE_FLTUND___11 = 5,
    FPE_FLTRES___11 = 6,
    FPE_FLTINV___11 = 7,
    FPE_FLTSUB___11 = 8,
    FPE_FLTUNK___11 = 14,
    FPE_CONDTRAP___11 = 15
} ;
#line 119
enum __anonenum__970 {
    SEGV_MAPERR___11 = 1,
    SEGV_ACCERR___11 = 2,
    SEGV_BNDERR___11 = 3,
    SEGV_PKUERR___11 = 4,
    SEGV_ACCADI___11 = 5,
    SEGV_ADIDERR___11 = 6,
    SEGV_ADIPERR___11 = 7,
    SEGV_MTEAERR___11 = 8,
    SEGV_MTESERR___11 = 9
} ;
#line 142
enum __anonenum__971 {
    BUS_ADRALN___11 = 1,
    BUS_ADRERR___11 = 2,
    BUS_OBJERR___11 = 3,
    BUS_MCEERR_AR___11 = 4,
    BUS_MCEERR_AO___11 = 5
} ;
#line 176
enum __anonenum__972 {
    CLD_EXITED___11 = 1,
    CLD_KILLED___11 = 2,
    CLD_DUMPED___11 = 3,
    CLD_TRAPPED___11 = 4,
    CLD_STOPPED___11 = 5,
    CLD_CONTINUED___11 = 6
} ;
#line 193
enum __anonenum__973 {
    POLL_IN___11 = 1,
    POLL_OUT___11 = 2,
    POLL_MSG___11 = 3,
    POLL_ERR___11 = 4,
    POLL_PRI___11 = 5,
    POLL_HUP___11 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__976 {
    SIGEV_SIGNAL___11 = 0,
    SIGEV_NONE___11 = 1,
    SIGEV_THREAD___11 = 2,
    SIGEV_THREAD_ID___11 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__981 {
    SS_ONSTACK___11 = 1,
    SS_DISABLE___11 = 2
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__989 {
    DT_UNKNOWN___11 = 0,
    DT_FIFO___11 = 1,
    DT_CHR___11 = 2,
    DT_DIR___11 = 4,
    DT_BLK___11 = 6,
    DT_REG___11 = 8,
    DT_LNK___11 = 10,
    DT_SOCK___11 = 12,
    DT_WHT___11 = 14
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__1048 {
    PTHREAD_CREATE_JOINABLE___11 = 0,
    PTHREAD_CREATE_DETACHED___11 = 1
} ;
#line 47
enum __anonenum__1049 {
    PTHREAD_MUTEX_TIMED_NP___11 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___11 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___11 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___11 = 3,
    PTHREAD_MUTEX_NORMAL___11 = 0,
    PTHREAD_MUTEX_RECURSIVE___11 = 1,
    PTHREAD_MUTEX_ERRORCHECK___11 = 2,
    PTHREAD_MUTEX_DEFAULT___11 = 0
} ;
#line 69
enum __anonenum__1050 {
    PTHREAD_MUTEX_STALLED___11 = 0,
    PTHREAD_MUTEX_STALLED_NP___11 = 0,
    PTHREAD_MUTEX_ROBUST___11 = 1,
    PTHREAD_MUTEX_ROBUST_NP___11 = 1
} ;
#line 81
enum __anonenum__1051 {
    PTHREAD_PRIO_NONE___11 = 0,
    PTHREAD_PRIO_INHERIT___11 = 1,
    PTHREAD_PRIO_PROTECT___11 = 2
} ;
#line 104
enum __anonenum__1052 {
    PTHREAD_RWLOCK_PREFER_READER_NP___11 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___11 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___11 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___11 = 0
} ;
#line 124
enum __anonenum__1053 {
    PTHREAD_INHERIT_SCHED___11 = 0,
    PTHREAD_EXPLICIT_SCHED___11 = 1
} ;
#line 134
enum __anonenum__1054 {
    PTHREAD_SCOPE_SYSTEM___11 = 0,
    PTHREAD_SCOPE_PROCESS___11 = 1
} ;
#line 144
enum __anonenum__1055 {
    PTHREAD_PROCESS_PRIVATE___11 = 0,
    PTHREAD_PROCESS_SHARED___11 = 1
} ;
#line 168
enum __anonenum__1056 {
    PTHREAD_CANCEL_ENABLE___11 = 0,
    PTHREAD_CANCEL_DISABLE___11 = 1
} ;
#line 175
enum __anonenum__1057 {
    PTHREAD_CANCEL_DEFERRED___11 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___11 = 1
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__607___0 {
    SI_ASYNCNL___12 = -60,
    SI_DETHREAD___12 = -7,
    SI_TKILL___12 = -6,
    SI_SIGIO___12 = -5,
    SI_ASYNCIO___12 = -4,
    SI_MESGQ___12 = -3,
    SI_TIMER___12 = -2,
    SI_QUEUE___12 = -1,
    SI_USER___12 = 0,
    SI_KERNEL___12 = 128
} ;
#line 71
enum __anonenum__608___0 {
    ILL_ILLOPC___12 = 1,
    ILL_ILLOPN___12 = 2,
    ILL_ILLADR___12 = 3,
    ILL_ILLTRP___12 = 4,
    ILL_PRVOPC___12 = 5,
    ILL_PRVREG___12 = 6,
    ILL_COPROC___12 = 7,
    ILL_BADSTK___12 = 8,
    ILL_BADIADDR___12 = 9
} ;
#line 94
enum __anonenum__609___0 {
    FPE_INTDIV___12 = 1,
    FPE_INTOVF___12 = 2,
    FPE_FLTDIV___12 = 3,
    FPE_FLTOVF___12 = 4,
    FPE_FLTUND___12 = 5,
    FPE_FLTRES___12 = 6,
    FPE_FLTINV___12 = 7,
    FPE_FLTSUB___12 = 8,
    FPE_FLTUNK___12 = 14,
    FPE_CONDTRAP___12 = 15
} ;
#line 119
enum __anonenum__610___0 {
    SEGV_MAPERR___12 = 1,
    SEGV_ACCERR___12 = 2,
    SEGV_BNDERR___12 = 3,
    SEGV_PKUERR___12 = 4,
    SEGV_ACCADI___12 = 5,
    SEGV_ADIDERR___12 = 6,
    SEGV_ADIPERR___12 = 7,
    SEGV_MTEAERR___12 = 8,
    SEGV_MTESERR___12 = 9
} ;
#line 142
enum __anonenum__611___0 {
    BUS_ADRALN___12 = 1,
    BUS_ADRERR___12 = 2,
    BUS_OBJERR___12 = 3,
    BUS_MCEERR_AR___12 = 4,
    BUS_MCEERR_AO___12 = 5
} ;
#line 176
enum __anonenum__612___0 {
    CLD_EXITED___12 = 1,
    CLD_KILLED___12 = 2,
    CLD_DUMPED___12 = 3,
    CLD_TRAPPED___12 = 4,
    CLD_STOPPED___12 = 5,
    CLD_CONTINUED___12 = 6
} ;
#line 193
enum __anonenum__613___0 {
    POLL_IN___12 = 1,
    POLL_OUT___12 = 2,
    POLL_MSG___12 = 3,
    POLL_ERR___12 = 4,
    POLL_PRI___12 = 5,
    POLL_HUP___12 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__616___0 {
    SIGEV_SIGNAL___12 = 0,
    SIGEV_NONE___12 = 1,
    SIGEV_THREAD___12 = 2,
    SIGEV_THREAD_ID___12 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__621___0 {
    SS_ONSTACK___12 = 1,
    SS_DISABLE___12 = 2
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__629___0 {
    DT_UNKNOWN___12 = 0,
    DT_FIFO___12 = 1,
    DT_CHR___12 = 2,
    DT_DIR___12 = 4,
    DT_BLK___12 = 6,
    DT_REG___12 = 8,
    DT_LNK___12 = 10,
    DT_SOCK___12 = 12,
    DT_WHT___12 = 14
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__688___0 {
    PTHREAD_CREATE_JOINABLE___12 = 0,
    PTHREAD_CREATE_DETACHED___12 = 1
} ;
#line 47
enum __anonenum__689___0 {
    PTHREAD_MUTEX_TIMED_NP___12 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___12 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___12 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___12 = 3,
    PTHREAD_MUTEX_NORMAL___12 = 0,
    PTHREAD_MUTEX_RECURSIVE___12 = 1,
    PTHREAD_MUTEX_ERRORCHECK___12 = 2,
    PTHREAD_MUTEX_DEFAULT___12 = 0
} ;
#line 69
enum __anonenum__690___0 {
    PTHREAD_MUTEX_STALLED___12 = 0,
    PTHREAD_MUTEX_STALLED_NP___12 = 0,
    PTHREAD_MUTEX_ROBUST___12 = 1,
    PTHREAD_MUTEX_ROBUST_NP___12 = 1
} ;
#line 81
enum __anonenum__691___0 {
    PTHREAD_PRIO_NONE___12 = 0,
    PTHREAD_PRIO_INHERIT___12 = 1,
    PTHREAD_PRIO_PROTECT___12 = 2
} ;
#line 104
enum __anonenum__692___0 {
    PTHREAD_RWLOCK_PREFER_READER_NP___12 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___12 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___12 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___12 = 0
} ;
#line 124
enum __anonenum__693___0 {
    PTHREAD_INHERIT_SCHED___12 = 0,
    PTHREAD_EXPLICIT_SCHED___12 = 1
} ;
#line 134
enum __anonenum__694___0 {
    PTHREAD_SCOPE_SYSTEM___12 = 0,
    PTHREAD_SCOPE_PROCESS___12 = 1
} ;
#line 144
enum __anonenum__695___0 {
    PTHREAD_PROCESS_PRIVATE___12 = 0,
    PTHREAD_PROCESS_SHARED___12 = 1
} ;
#line 168
enum __anonenum__696___0 {
    PTHREAD_CANCEL_ENABLE___12 = 0,
    PTHREAD_CANCEL_DISABLE___12 = 1
} ;
#line 175
enum __anonenum__697___0 {
    PTHREAD_CANCEL_DEFERRED___12 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___12 = 1
} ;
#line 11 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/vector.h"
struct __anonstruct_1089 {
   gfloat dx ;
   gfloat dy ;
   gfloat dz ;
};
#line 13 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/vector.h"
typedef struct __anonstruct_1089 vector_type;
#line 934 "/usr/include/math.h"
enum __anonenum__1090 {
    FP_NAN___1 = 0,
    FP_INFINITE___1 = 1,
    FP_ZERO___1 = 2,
    FP_SUBNORMAL___1 = 3,
    FP_NORMAL___1 = 4
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__607___1 {
    SI_ASYNCNL___13 = -60,
    SI_DETHREAD___13 = -7,
    SI_TKILL___13 = -6,
    SI_SIGIO___13 = -5,
    SI_ASYNCIO___13 = -4,
    SI_MESGQ___13 = -3,
    SI_TIMER___13 = -2,
    SI_QUEUE___13 = -1,
    SI_USER___13 = 0,
    SI_KERNEL___13 = 128
} ;
#line 71
enum __anonenum__608___1 {
    ILL_ILLOPC___13 = 1,
    ILL_ILLOPN___13 = 2,
    ILL_ILLADR___13 = 3,
    ILL_ILLTRP___13 = 4,
    ILL_PRVOPC___13 = 5,
    ILL_PRVREG___13 = 6,
    ILL_COPROC___13 = 7,
    ILL_BADSTK___13 = 8,
    ILL_BADIADDR___13 = 9
} ;
#line 94
enum __anonenum__609___1 {
    FPE_INTDIV___13 = 1,
    FPE_INTOVF___13 = 2,
    FPE_FLTDIV___13 = 3,
    FPE_FLTOVF___13 = 4,
    FPE_FLTUND___13 = 5,
    FPE_FLTRES___13 = 6,
    FPE_FLTINV___13 = 7,
    FPE_FLTSUB___13 = 8,
    FPE_FLTUNK___13 = 14,
    FPE_CONDTRAP___13 = 15
} ;
#line 119
enum __anonenum__610___1 {
    SEGV_MAPERR___13 = 1,
    SEGV_ACCERR___13 = 2,
    SEGV_BNDERR___13 = 3,
    SEGV_PKUERR___13 = 4,
    SEGV_ACCADI___13 = 5,
    SEGV_ADIDERR___13 = 6,
    SEGV_ADIPERR___13 = 7,
    SEGV_MTEAERR___13 = 8,
    SEGV_MTESERR___13 = 9
} ;
#line 142
enum __anonenum__611___1 {
    BUS_ADRALN___13 = 1,
    BUS_ADRERR___13 = 2,
    BUS_OBJERR___13 = 3,
    BUS_MCEERR_AR___13 = 4,
    BUS_MCEERR_AO___13 = 5
} ;
#line 176
enum __anonenum__612___1 {
    CLD_EXITED___13 = 1,
    CLD_KILLED___13 = 2,
    CLD_DUMPED___13 = 3,
    CLD_TRAPPED___13 = 4,
    CLD_STOPPED___13 = 5,
    CLD_CONTINUED___13 = 6
} ;
#line 193
enum __anonenum__613___1 {
    POLL_IN___13 = 1,
    POLL_OUT___13 = 2,
    POLL_MSG___13 = 3,
    POLL_ERR___13 = 4,
    POLL_PRI___13 = 5,
    POLL_HUP___13 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__616___1 {
    SIGEV_SIGNAL___13 = 0,
    SIGEV_NONE___13 = 1,
    SIGEV_THREAD___13 = 2,
    SIGEV_THREAD_ID___13 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__621___1 {
    SS_ONSTACK___13 = 1,
    SS_DISABLE___13 = 2
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__629___1 {
    DT_UNKNOWN___13 = 0,
    DT_FIFO___13 = 1,
    DT_CHR___13 = 2,
    DT_DIR___13 = 4,
    DT_BLK___13 = 6,
    DT_REG___13 = 8,
    DT_LNK___13 = 10,
    DT_SOCK___13 = 12,
    DT_WHT___13 = 14
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__688___1 {
    PTHREAD_CREATE_JOINABLE___13 = 0,
    PTHREAD_CREATE_DETACHED___13 = 1
} ;
#line 47
enum __anonenum__689___1 {
    PTHREAD_MUTEX_TIMED_NP___13 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___13 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___13 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___13 = 3,
    PTHREAD_MUTEX_NORMAL___13 = 0,
    PTHREAD_MUTEX_RECURSIVE___13 = 1,
    PTHREAD_MUTEX_ERRORCHECK___13 = 2,
    PTHREAD_MUTEX_DEFAULT___13 = 0
} ;
#line 69
enum __anonenum__690___1 {
    PTHREAD_MUTEX_STALLED___13 = 0,
    PTHREAD_MUTEX_STALLED_NP___13 = 0,
    PTHREAD_MUTEX_ROBUST___13 = 1,
    PTHREAD_MUTEX_ROBUST_NP___13 = 1
} ;
#line 81
enum __anonenum__691___1 {
    PTHREAD_PRIO_NONE___13 = 0,
    PTHREAD_PRIO_INHERIT___13 = 1,
    PTHREAD_PRIO_PROTECT___13 = 2
} ;
#line 104
enum __anonenum__692___1 {
    PTHREAD_RWLOCK_PREFER_READER_NP___13 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___13 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___13 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___13 = 0
} ;
#line 124
enum __anonenum__693___1 {
    PTHREAD_INHERIT_SCHED___13 = 0,
    PTHREAD_EXPLICIT_SCHED___13 = 1
} ;
#line 134
enum __anonenum__694___1 {
    PTHREAD_SCOPE_SYSTEM___13 = 0,
    PTHREAD_SCOPE_PROCESS___13 = 1
} ;
#line 144
enum __anonenum__695___1 {
    PTHREAD_PROCESS_PRIVATE___13 = 0,
    PTHREAD_PROCESS_SHARED___13 = 1
} ;
#line 168
enum __anonenum__696___1 {
    PTHREAD_CANCEL_ENABLE___13 = 0,
    PTHREAD_CANCEL_DISABLE___13 = 1
} ;
#line 175
enum __anonenum__697___1 {
    PTHREAD_CANCEL_DEFERRED___13 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___13 = 1
} ;
#line 934 "/usr/include/math.h"
enum __anonenum__1091 {
    FP_NAN___2 = 0,
    FP_INFINITE___2 = 1,
    FP_ZERO___2 = 2,
    FP_SUBNORMAL___2 = 3,
    FP_NORMAL___2 = 4
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__325___4 {
    SI_ASYNCNL___14 = -60,
    SI_DETHREAD___14 = -7,
    SI_TKILL___14 = -6,
    SI_SIGIO___14 = -5,
    SI_ASYNCIO___14 = -4,
    SI_MESGQ___14 = -3,
    SI_TIMER___14 = -2,
    SI_QUEUE___14 = -1,
    SI_USER___14 = 0,
    SI_KERNEL___14 = 128
} ;
#line 71
enum __anonenum__326___4 {
    ILL_ILLOPC___14 = 1,
    ILL_ILLOPN___14 = 2,
    ILL_ILLADR___14 = 3,
    ILL_ILLTRP___14 = 4,
    ILL_PRVOPC___14 = 5,
    ILL_PRVREG___14 = 6,
    ILL_COPROC___14 = 7,
    ILL_BADSTK___14 = 8,
    ILL_BADIADDR___14 = 9
} ;
#line 94
enum __anonenum__327___4 {
    FPE_INTDIV___14 = 1,
    FPE_INTOVF___14 = 2,
    FPE_FLTDIV___14 = 3,
    FPE_FLTOVF___14 = 4,
    FPE_FLTUND___14 = 5,
    FPE_FLTRES___14 = 6,
    FPE_FLTINV___14 = 7,
    FPE_FLTSUB___14 = 8,
    FPE_FLTUNK___14 = 14,
    FPE_CONDTRAP___14 = 15
} ;
#line 119
enum __anonenum__328___4 {
    SEGV_MAPERR___14 = 1,
    SEGV_ACCERR___14 = 2,
    SEGV_BNDERR___14 = 3,
    SEGV_PKUERR___14 = 4,
    SEGV_ACCADI___14 = 5,
    SEGV_ADIDERR___14 = 6,
    SEGV_ADIPERR___14 = 7,
    SEGV_MTEAERR___14 = 8,
    SEGV_MTESERR___14 = 9
} ;
#line 142
enum __anonenum__329___4 {
    BUS_ADRALN___14 = 1,
    BUS_ADRERR___14 = 2,
    BUS_OBJERR___14 = 3,
    BUS_MCEERR_AR___14 = 4,
    BUS_MCEERR_AO___14 = 5
} ;
#line 176
enum __anonenum__330___4 {
    CLD_EXITED___14 = 1,
    CLD_KILLED___14 = 2,
    CLD_DUMPED___14 = 3,
    CLD_TRAPPED___14 = 4,
    CLD_STOPPED___14 = 5,
    CLD_CONTINUED___14 = 6
} ;
#line 193
enum __anonenum__331___4 {
    POLL_IN___14 = 1,
    POLL_OUT___14 = 2,
    POLL_MSG___14 = 3,
    POLL_ERR___14 = 4,
    POLL_PRI___14 = 5,
    POLL_HUP___14 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__334___4 {
    SIGEV_SIGNAL___14 = 0,
    SIGEV_NONE___14 = 1,
    SIGEV_THREAD___14 = 2,
    SIGEV_THREAD_ID___14 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__339___4 {
    SS_ONSTACK___14 = 1,
    SS_DISABLE___14 = 2
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__347___4 {
    DT_UNKNOWN___14 = 0,
    DT_FIFO___14 = 1,
    DT_CHR___14 = 2,
    DT_DIR___14 = 4,
    DT_BLK___14 = 6,
    DT_REG___14 = 8,
    DT_LNK___14 = 10,
    DT_SOCK___14 = 12,
    DT_WHT___14 = 14
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__406___4 {
    PTHREAD_CREATE_JOINABLE___14 = 0,
    PTHREAD_CREATE_DETACHED___14 = 1
} ;
#line 47
enum __anonenum__407___4 {
    PTHREAD_MUTEX_TIMED_NP___14 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___14 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___14 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___14 = 3,
    PTHREAD_MUTEX_NORMAL___14 = 0,
    PTHREAD_MUTEX_RECURSIVE___14 = 1,
    PTHREAD_MUTEX_ERRORCHECK___14 = 2,
    PTHREAD_MUTEX_DEFAULT___14 = 0
} ;
#line 69
enum __anonenum__408___4 {
    PTHREAD_MUTEX_STALLED___14 = 0,
    PTHREAD_MUTEX_STALLED_NP___14 = 0,
    PTHREAD_MUTEX_ROBUST___14 = 1,
    PTHREAD_MUTEX_ROBUST_NP___14 = 1
} ;
#line 81
enum __anonenum__409___6 {
    PTHREAD_PRIO_NONE___14 = 0,
    PTHREAD_PRIO_INHERIT___14 = 1,
    PTHREAD_PRIO_PROTECT___14 = 2
} ;
#line 104
enum __anonenum__410___4 {
    PTHREAD_RWLOCK_PREFER_READER_NP___14 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___14 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___14 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___14 = 0
} ;
#line 124
enum __anonenum__411___4 {
    PTHREAD_INHERIT_SCHED___14 = 0,
    PTHREAD_EXPLICIT_SCHED___14 = 1
} ;
#line 134
enum __anonenum__412___4 {
    PTHREAD_SCOPE_SYSTEM___14 = 0,
    PTHREAD_SCOPE_PROCESS___14 = 1
} ;
#line 144
enum __anonenum__413___4 {
    PTHREAD_PROCESS_PRIVATE___14 = 0,
    PTHREAD_PROCESS_SHARED___14 = 1
} ;
#line 168
enum __anonenum__414___4 {
    PTHREAD_CANCEL_ENABLE___14 = 0,
    PTHREAD_CANCEL_DISABLE___14 = 1
} ;
#line 175
enum __anonenum__415___4 {
    PTHREAD_CANCEL_DEFERRED___14 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___14 = 1
} ;
#line 15 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/curve.h"
struct __anonstruct_1093 {
   at_real_coord coord ;
   gfloat t ;
};
#line 18 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/curve.h"
typedef struct __anonstruct_1093 point_type;
#line 24 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/curve.h"
struct curve {
   point_type *point_list ;
   unsigned int length ;
   gboolean cyclic ;
   vector_type *start_tangent ;
   vector_type *end_tangent ;
   struct curve *previous ;
   struct curve *next ;
};
#line 34 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/curve.h"
typedef struct curve *curve_type;
#line 91 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/curve.h"
struct __anonstruct_1094 {
   curve_type *data ;
   unsigned int length ;
   gboolean clockwise ;
   gboolean open ;
};
#line 96 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/curve.h"
typedef struct __anonstruct_1094 curve_list_type;
#line 116 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/curve.h"
struct __anonstruct_1095 {
   curve_list_type *data ;
   unsigned int length ;
};
#line 119 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/curve.h"
typedef struct __anonstruct_1095 curve_list_array_type;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__325___5 {
    SI_ASYNCNL___15 = -60,
    SI_DETHREAD___15 = -7,
    SI_TKILL___15 = -6,
    SI_SIGIO___15 = -5,
    SI_ASYNCIO___15 = -4,
    SI_MESGQ___15 = -3,
    SI_TIMER___15 = -2,
    SI_QUEUE___15 = -1,
    SI_USER___15 = 0,
    SI_KERNEL___15 = 128
} ;
#line 71
enum __anonenum__326___5 {
    ILL_ILLOPC___15 = 1,
    ILL_ILLOPN___15 = 2,
    ILL_ILLADR___15 = 3,
    ILL_ILLTRP___15 = 4,
    ILL_PRVOPC___15 = 5,
    ILL_PRVREG___15 = 6,
    ILL_COPROC___15 = 7,
    ILL_BADSTK___15 = 8,
    ILL_BADIADDR___15 = 9
} ;
#line 94
enum __anonenum__327___5 {
    FPE_INTDIV___15 = 1,
    FPE_INTOVF___15 = 2,
    FPE_FLTDIV___15 = 3,
    FPE_FLTOVF___15 = 4,
    FPE_FLTUND___15 = 5,
    FPE_FLTRES___15 = 6,
    FPE_FLTINV___15 = 7,
    FPE_FLTSUB___15 = 8,
    FPE_FLTUNK___15 = 14,
    FPE_CONDTRAP___15 = 15
} ;
#line 119
enum __anonenum__328___5 {
    SEGV_MAPERR___15 = 1,
    SEGV_ACCERR___15 = 2,
    SEGV_BNDERR___15 = 3,
    SEGV_PKUERR___15 = 4,
    SEGV_ACCADI___15 = 5,
    SEGV_ADIDERR___15 = 6,
    SEGV_ADIPERR___15 = 7,
    SEGV_MTEAERR___15 = 8,
    SEGV_MTESERR___15 = 9
} ;
#line 142
enum __anonenum__329___5 {
    BUS_ADRALN___15 = 1,
    BUS_ADRERR___15 = 2,
    BUS_OBJERR___15 = 3,
    BUS_MCEERR_AR___15 = 4,
    BUS_MCEERR_AO___15 = 5
} ;
#line 176
enum __anonenum__330___5 {
    CLD_EXITED___15 = 1,
    CLD_KILLED___15 = 2,
    CLD_DUMPED___15 = 3,
    CLD_TRAPPED___15 = 4,
    CLD_STOPPED___15 = 5,
    CLD_CONTINUED___15 = 6
} ;
#line 193
enum __anonenum__331___5 {
    POLL_IN___15 = 1,
    POLL_OUT___15 = 2,
    POLL_MSG___15 = 3,
    POLL_ERR___15 = 4,
    POLL_PRI___15 = 5,
    POLL_HUP___15 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__334___5 {
    SIGEV_SIGNAL___15 = 0,
    SIGEV_NONE___15 = 1,
    SIGEV_THREAD___15 = 2,
    SIGEV_THREAD_ID___15 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__339___5 {
    SS_ONSTACK___15 = 1,
    SS_DISABLE___15 = 2
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__347___5 {
    DT_UNKNOWN___15 = 0,
    DT_FIFO___15 = 1,
    DT_CHR___15 = 2,
    DT_DIR___15 = 4,
    DT_BLK___15 = 6,
    DT_REG___15 = 8,
    DT_LNK___15 = 10,
    DT_SOCK___15 = 12,
    DT_WHT___15 = 14
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__406___5 {
    PTHREAD_CREATE_JOINABLE___15 = 0,
    PTHREAD_CREATE_DETACHED___15 = 1
} ;
#line 47
enum __anonenum__407___5 {
    PTHREAD_MUTEX_TIMED_NP___15 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___15 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___15 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___15 = 3,
    PTHREAD_MUTEX_NORMAL___15 = 0,
    PTHREAD_MUTEX_RECURSIVE___15 = 1,
    PTHREAD_MUTEX_ERRORCHECK___15 = 2,
    PTHREAD_MUTEX_DEFAULT___15 = 0
} ;
#line 69
enum __anonenum__408___5 {
    PTHREAD_MUTEX_STALLED___15 = 0,
    PTHREAD_MUTEX_STALLED_NP___15 = 0,
    PTHREAD_MUTEX_ROBUST___15 = 1,
    PTHREAD_MUTEX_ROBUST_NP___15 = 1
} ;
#line 81
enum __anonenum__409___7 {
    PTHREAD_PRIO_NONE___15 = 0,
    PTHREAD_PRIO_INHERIT___15 = 1,
    PTHREAD_PRIO_PROTECT___15 = 2
} ;
#line 104
enum __anonenum__410___5 {
    PTHREAD_RWLOCK_PREFER_READER_NP___15 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___15 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___15 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___15 = 0
} ;
#line 124
enum __anonenum__411___5 {
    PTHREAD_INHERIT_SCHED___15 = 0,
    PTHREAD_EXPLICIT_SCHED___15 = 1
} ;
#line 134
enum __anonenum__412___5 {
    PTHREAD_SCOPE_SYSTEM___15 = 0,
    PTHREAD_SCOPE_PROCESS___15 = 1
} ;
#line 144
enum __anonenum__413___5 {
    PTHREAD_PROCESS_PRIVATE___15 = 0,
    PTHREAD_PROCESS_SHARED___15 = 1
} ;
#line 168
enum __anonenum__414___5 {
    PTHREAD_CANCEL_ENABLE___15 = 0,
    PTHREAD_CANCEL_DISABLE___15 = 1
} ;
#line 175
enum __anonenum__415___5 {
    PTHREAD_CANCEL_DEFERRED___15 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___15 = 1
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__325___6 {
    SI_ASYNCNL___16 = -60,
    SI_DETHREAD___16 = -7,
    SI_TKILL___16 = -6,
    SI_SIGIO___16 = -5,
    SI_ASYNCIO___16 = -4,
    SI_MESGQ___16 = -3,
    SI_TIMER___16 = -2,
    SI_QUEUE___16 = -1,
    SI_USER___16 = 0,
    SI_KERNEL___16 = 128
} ;
#line 71
enum __anonenum__326___6 {
    ILL_ILLOPC___16 = 1,
    ILL_ILLOPN___16 = 2,
    ILL_ILLADR___16 = 3,
    ILL_ILLTRP___16 = 4,
    ILL_PRVOPC___16 = 5,
    ILL_PRVREG___16 = 6,
    ILL_COPROC___16 = 7,
    ILL_BADSTK___16 = 8,
    ILL_BADIADDR___16 = 9
} ;
#line 94
enum __anonenum__327___6 {
    FPE_INTDIV___16 = 1,
    FPE_INTOVF___16 = 2,
    FPE_FLTDIV___16 = 3,
    FPE_FLTOVF___16 = 4,
    FPE_FLTUND___16 = 5,
    FPE_FLTRES___16 = 6,
    FPE_FLTINV___16 = 7,
    FPE_FLTSUB___16 = 8,
    FPE_FLTUNK___16 = 14,
    FPE_CONDTRAP___16 = 15
} ;
#line 119
enum __anonenum__328___6 {
    SEGV_MAPERR___16 = 1,
    SEGV_ACCERR___16 = 2,
    SEGV_BNDERR___16 = 3,
    SEGV_PKUERR___16 = 4,
    SEGV_ACCADI___16 = 5,
    SEGV_ADIDERR___16 = 6,
    SEGV_ADIPERR___16 = 7,
    SEGV_MTEAERR___16 = 8,
    SEGV_MTESERR___16 = 9
} ;
#line 142
enum __anonenum__329___6 {
    BUS_ADRALN___16 = 1,
    BUS_ADRERR___16 = 2,
    BUS_OBJERR___16 = 3,
    BUS_MCEERR_AR___16 = 4,
    BUS_MCEERR_AO___16 = 5
} ;
#line 176
enum __anonenum__330___6 {
    CLD_EXITED___16 = 1,
    CLD_KILLED___16 = 2,
    CLD_DUMPED___16 = 3,
    CLD_TRAPPED___16 = 4,
    CLD_STOPPED___16 = 5,
    CLD_CONTINUED___16 = 6
} ;
#line 193
enum __anonenum__331___6 {
    POLL_IN___16 = 1,
    POLL_OUT___16 = 2,
    POLL_MSG___16 = 3,
    POLL_ERR___16 = 4,
    POLL_PRI___16 = 5,
    POLL_HUP___16 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__334___6 {
    SIGEV_SIGNAL___16 = 0,
    SIGEV_NONE___16 = 1,
    SIGEV_THREAD___16 = 2,
    SIGEV_THREAD_ID___16 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__339___6 {
    SS_ONSTACK___16 = 1,
    SS_DISABLE___16 = 2
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__347___6 {
    DT_UNKNOWN___16 = 0,
    DT_FIFO___16 = 1,
    DT_CHR___16 = 2,
    DT_DIR___16 = 4,
    DT_BLK___16 = 6,
    DT_REG___16 = 8,
    DT_LNK___16 = 10,
    DT_SOCK___16 = 12,
    DT_WHT___16 = 14
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__406___6 {
    PTHREAD_CREATE_JOINABLE___16 = 0,
    PTHREAD_CREATE_DETACHED___16 = 1
} ;
#line 47
enum __anonenum__407___6 {
    PTHREAD_MUTEX_TIMED_NP___16 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___16 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___16 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___16 = 3,
    PTHREAD_MUTEX_NORMAL___16 = 0,
    PTHREAD_MUTEX_RECURSIVE___16 = 1,
    PTHREAD_MUTEX_ERRORCHECK___16 = 2,
    PTHREAD_MUTEX_DEFAULT___16 = 0
} ;
#line 69
enum __anonenum__408___6 {
    PTHREAD_MUTEX_STALLED___16 = 0,
    PTHREAD_MUTEX_STALLED_NP___16 = 0,
    PTHREAD_MUTEX_ROBUST___16 = 1,
    PTHREAD_MUTEX_ROBUST_NP___16 = 1
} ;
#line 81
enum __anonenum__409___8 {
    PTHREAD_PRIO_NONE___16 = 0,
    PTHREAD_PRIO_INHERIT___16 = 1,
    PTHREAD_PRIO_PROTECT___16 = 2
} ;
#line 104
enum __anonenum__410___6 {
    PTHREAD_RWLOCK_PREFER_READER_NP___16 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___16 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___16 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___16 = 0
} ;
#line 124
enum __anonenum__411___6 {
    PTHREAD_INHERIT_SCHED___16 = 0,
    PTHREAD_EXPLICIT_SCHED___16 = 1
} ;
#line 134
enum __anonenum__412___6 {
    PTHREAD_SCOPE_SYSTEM___16 = 0,
    PTHREAD_SCOPE_PROCESS___16 = 1
} ;
#line 144
enum __anonenum__413___6 {
    PTHREAD_PROCESS_PRIVATE___16 = 0,
    PTHREAD_PROCESS_SHARED___16 = 1
} ;
#line 168
enum __anonenum__414___6 {
    PTHREAD_CANCEL_ENABLE___16 = 0,
    PTHREAD_CANCEL_DISABLE___16 = 1
} ;
#line 175
enum __anonenum__415___6 {
    PTHREAD_CANCEL_DEFERRED___16 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___16 = 1
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__325___7 {
    SI_ASYNCNL___17 = -60,
    SI_DETHREAD___17 = -7,
    SI_TKILL___17 = -6,
    SI_SIGIO___17 = -5,
    SI_ASYNCIO___17 = -4,
    SI_MESGQ___17 = -3,
    SI_TIMER___17 = -2,
    SI_QUEUE___17 = -1,
    SI_USER___17 = 0,
    SI_KERNEL___17 = 128
} ;
#line 71
enum __anonenum__326___7 {
    ILL_ILLOPC___17 = 1,
    ILL_ILLOPN___17 = 2,
    ILL_ILLADR___17 = 3,
    ILL_ILLTRP___17 = 4,
    ILL_PRVOPC___17 = 5,
    ILL_PRVREG___17 = 6,
    ILL_COPROC___17 = 7,
    ILL_BADSTK___17 = 8,
    ILL_BADIADDR___17 = 9
} ;
#line 94
enum __anonenum__327___7 {
    FPE_INTDIV___17 = 1,
    FPE_INTOVF___17 = 2,
    FPE_FLTDIV___17 = 3,
    FPE_FLTOVF___17 = 4,
    FPE_FLTUND___17 = 5,
    FPE_FLTRES___17 = 6,
    FPE_FLTINV___17 = 7,
    FPE_FLTSUB___17 = 8,
    FPE_FLTUNK___17 = 14,
    FPE_CONDTRAP___17 = 15
} ;
#line 119
enum __anonenum__328___7 {
    SEGV_MAPERR___17 = 1,
    SEGV_ACCERR___17 = 2,
    SEGV_BNDERR___17 = 3,
    SEGV_PKUERR___17 = 4,
    SEGV_ACCADI___17 = 5,
    SEGV_ADIDERR___17 = 6,
    SEGV_ADIPERR___17 = 7,
    SEGV_MTEAERR___17 = 8,
    SEGV_MTESERR___17 = 9
} ;
#line 142
enum __anonenum__329___7 {
    BUS_ADRALN___17 = 1,
    BUS_ADRERR___17 = 2,
    BUS_OBJERR___17 = 3,
    BUS_MCEERR_AR___17 = 4,
    BUS_MCEERR_AO___17 = 5
} ;
#line 176
enum __anonenum__330___7 {
    CLD_EXITED___17 = 1,
    CLD_KILLED___17 = 2,
    CLD_DUMPED___17 = 3,
    CLD_TRAPPED___17 = 4,
    CLD_STOPPED___17 = 5,
    CLD_CONTINUED___17 = 6
} ;
#line 193
enum __anonenum__331___7 {
    POLL_IN___17 = 1,
    POLL_OUT___17 = 2,
    POLL_MSG___17 = 3,
    POLL_ERR___17 = 4,
    POLL_PRI___17 = 5,
    POLL_HUP___17 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__334___7 {
    SIGEV_SIGNAL___17 = 0,
    SIGEV_NONE___17 = 1,
    SIGEV_THREAD___17 = 2,
    SIGEV_THREAD_ID___17 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__339___7 {
    SS_ONSTACK___17 = 1,
    SS_DISABLE___17 = 2
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__347___7 {
    DT_UNKNOWN___17 = 0,
    DT_FIFO___17 = 1,
    DT_CHR___17 = 2,
    DT_DIR___17 = 4,
    DT_BLK___17 = 6,
    DT_REG___17 = 8,
    DT_LNK___17 = 10,
    DT_SOCK___17 = 12,
    DT_WHT___17 = 14
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__406___7 {
    PTHREAD_CREATE_JOINABLE___17 = 0,
    PTHREAD_CREATE_DETACHED___17 = 1
} ;
#line 47
enum __anonenum__407___7 {
    PTHREAD_MUTEX_TIMED_NP___17 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___17 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___17 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___17 = 3,
    PTHREAD_MUTEX_NORMAL___17 = 0,
    PTHREAD_MUTEX_RECURSIVE___17 = 1,
    PTHREAD_MUTEX_ERRORCHECK___17 = 2,
    PTHREAD_MUTEX_DEFAULT___17 = 0
} ;
#line 69
enum __anonenum__408___7 {
    PTHREAD_MUTEX_STALLED___17 = 0,
    PTHREAD_MUTEX_STALLED_NP___17 = 0,
    PTHREAD_MUTEX_ROBUST___17 = 1,
    PTHREAD_MUTEX_ROBUST_NP___17 = 1
} ;
#line 81
enum __anonenum__409___9 {
    PTHREAD_PRIO_NONE___17 = 0,
    PTHREAD_PRIO_INHERIT___17 = 1,
    PTHREAD_PRIO_PROTECT___17 = 2
} ;
#line 104
enum __anonenum__410___7 {
    PTHREAD_RWLOCK_PREFER_READER_NP___17 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___17 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___17 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___17 = 0
} ;
#line 124
enum __anonenum__411___7 {
    PTHREAD_INHERIT_SCHED___17 = 0,
    PTHREAD_EXPLICIT_SCHED___17 = 1
} ;
#line 134
enum __anonenum__412___7 {
    PTHREAD_SCOPE_SYSTEM___17 = 0,
    PTHREAD_SCOPE_PROCESS___17 = 1
} ;
#line 144
enum __anonenum__413___7 {
    PTHREAD_PROCESS_PRIVATE___17 = 0,
    PTHREAD_PROCESS_SHARED___17 = 1
} ;
#line 168
enum __anonenum__414___7 {
    PTHREAD_CANCEL_ENABLE___17 = 0,
    PTHREAD_CANCEL_DISABLE___17 = 1
} ;
#line 175
enum __anonenum__415___7 {
    PTHREAD_CANCEL_DEFERRED___17 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___17 = 1
} ;
#line 934 "/usr/include/math.h"
enum __anonenum__1104 {
    FP_NAN___3 = 0,
    FP_INFINITE___3 = 1,
    FP_ZERO___3 = 2,
    FP_SUBNORMAL___3 = 3,
    FP_NORMAL___3 = 4
} ;
#line 53 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/fit.c"
struct index_list {
   unsigned int *data ;
   unsigned int length ;
};
#line 56 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/fit.c"
typedef struct index_list index_list_type;
#line 35 "/usr/include/x86_64-linux-gnu/bits/fcntl.h"
struct flock {
   short l_type ;
   short l_whence ;
   __off_t l_start ;
   __off_t l_len ;
   __pid_t l_pid ;
};
#line 26 "/usr/include/x86_64-linux-gnu/bits/struct_stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 934 "/usr/include/math.h"
enum __anonenum__1105 {
    FP_NAN___4 = 0,
    FP_INFINITE___4 = 1,
    FP_ZERO___4 = 2,
    FP_SUBNORMAL___4 = 3,
    FP_NORMAL___4 = 4
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__1142 {
    SI_ASYNCNL___18 = -60,
    SI_DETHREAD___18 = -7,
    SI_TKILL___18 = -6,
    SI_SIGIO___18 = -5,
    SI_ASYNCIO___18 = -4,
    SI_MESGQ___18 = -3,
    SI_TIMER___18 = -2,
    SI_QUEUE___18 = -1,
    SI_USER___18 = 0,
    SI_KERNEL___18 = 128
} ;
#line 71
enum __anonenum__1143 {
    ILL_ILLOPC___18 = 1,
    ILL_ILLOPN___18 = 2,
    ILL_ILLADR___18 = 3,
    ILL_ILLTRP___18 = 4,
    ILL_PRVOPC___18 = 5,
    ILL_PRVREG___18 = 6,
    ILL_COPROC___18 = 7,
    ILL_BADSTK___18 = 8,
    ILL_BADIADDR___18 = 9
} ;
#line 94
enum __anonenum__1144 {
    FPE_INTDIV___18 = 1,
    FPE_INTOVF___18 = 2,
    FPE_FLTDIV___18 = 3,
    FPE_FLTOVF___18 = 4,
    FPE_FLTUND___18 = 5,
    FPE_FLTRES___18 = 6,
    FPE_FLTINV___18 = 7,
    FPE_FLTSUB___18 = 8,
    FPE_FLTUNK___18 = 14,
    FPE_CONDTRAP___18 = 15
} ;
#line 119
enum __anonenum__1145 {
    SEGV_MAPERR___18 = 1,
    SEGV_ACCERR___18 = 2,
    SEGV_BNDERR___18 = 3,
    SEGV_PKUERR___18 = 4,
    SEGV_ACCADI___18 = 5,
    SEGV_ADIDERR___18 = 6,
    SEGV_ADIPERR___18 = 7,
    SEGV_MTEAERR___18 = 8,
    SEGV_MTESERR___18 = 9
} ;
#line 142
enum __anonenum__1146 {
    BUS_ADRALN___18 = 1,
    BUS_ADRERR___18 = 2,
    BUS_OBJERR___18 = 3,
    BUS_MCEERR_AR___18 = 4,
    BUS_MCEERR_AO___18 = 5
} ;
#line 176
enum __anonenum__1147 {
    CLD_EXITED___18 = 1,
    CLD_KILLED___18 = 2,
    CLD_DUMPED___18 = 3,
    CLD_TRAPPED___18 = 4,
    CLD_STOPPED___18 = 5,
    CLD_CONTINUED___18 = 6
} ;
#line 193
enum __anonenum__1148 {
    POLL_IN___18 = 1,
    POLL_OUT___18 = 2,
    POLL_MSG___18 = 3,
    POLL_ERR___18 = 4,
    POLL_PRI___18 = 5,
    POLL_HUP___18 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__1151 {
    SIGEV_SIGNAL___18 = 0,
    SIGEV_NONE___18 = 1,
    SIGEV_THREAD___18 = 2,
    SIGEV_THREAD_ID___18 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__1156 {
    SS_ONSTACK___18 = 1,
    SS_DISABLE___18 = 2
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__1164 {
    DT_UNKNOWN___18 = 0,
    DT_FIFO___18 = 1,
    DT_CHR___18 = 2,
    DT_DIR___18 = 4,
    DT_BLK___18 = 6,
    DT_REG___18 = 8,
    DT_LNK___18 = 10,
    DT_SOCK___18 = 12,
    DT_WHT___18 = 14
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__1222 {
    PTHREAD_CREATE_JOINABLE___18 = 0,
    PTHREAD_CREATE_DETACHED___18 = 1
} ;
#line 47
enum __anonenum__1223 {
    PTHREAD_MUTEX_TIMED_NP___18 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___18 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___18 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___18 = 3,
    PTHREAD_MUTEX_NORMAL___18 = 0,
    PTHREAD_MUTEX_RECURSIVE___18 = 1,
    PTHREAD_MUTEX_ERRORCHECK___18 = 2,
    PTHREAD_MUTEX_DEFAULT___18 = 0
} ;
#line 69
enum __anonenum__1224 {
    PTHREAD_MUTEX_STALLED___18 = 0,
    PTHREAD_MUTEX_STALLED_NP___18 = 0,
    PTHREAD_MUTEX_ROBUST___18 = 1,
    PTHREAD_MUTEX_ROBUST_NP___18 = 1
} ;
#line 81
enum __anonenum__1225 {
    PTHREAD_PRIO_NONE___18 = 0,
    PTHREAD_PRIO_INHERIT___18 = 1,
    PTHREAD_PRIO_PROTECT___18 = 2
} ;
#line 104
enum __anonenum__1226 {
    PTHREAD_RWLOCK_PREFER_READER_NP___18 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___18 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___18 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___18 = 0
} ;
#line 124
enum __anonenum__1227 {
    PTHREAD_INHERIT_SCHED___18 = 0,
    PTHREAD_EXPLICIT_SCHED___18 = 1
} ;
#line 134
enum __anonenum__1228 {
    PTHREAD_SCOPE_SYSTEM___18 = 0,
    PTHREAD_SCOPE_PROCESS___18 = 1
} ;
#line 144
enum __anonenum__1229 {
    PTHREAD_PROCESS_PRIVATE___18 = 0,
    PTHREAD_PROCESS_SHARED___18 = 1
} ;
#line 168
enum __anonenum__1230 {
    PTHREAD_CANCEL_ENABLE___18 = 0,
    PTHREAD_CANCEL_DISABLE___18 = 1
} ;
#line 175
enum __anonenum__1231 {
    PTHREAD_CANCEL_DEFERRED___18 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___18 = 1
} ;
#line 66 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-ild.c"
struct tagLaserPoint {
   void *next ;
   short x ;
   short y ;
   short z ;
   unsigned char attrib ;
   unsigned char r ;
   unsigned char g ;
   unsigned char b ;
};
#line 75 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-ild.c"
typedef struct tagLaserPoint LaserPoint;
#line 77 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-ild.c"
typedef LaserPoint *pLaserPoint;
#line 79 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-ild.c"
struct tagLaserFrame {
   void *next ;
   void *previous ;
   LaserPoint *point_first ;
   LaserPoint *point_last ;
   int count ;
   char *name ;
};
#line 86 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-ild.c"
typedef struct tagLaserFrame LaserFrame;
#line 88 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-ild.c"
typedef LaserFrame *pLaserFrame;
#line 90 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-ild.c"
struct tagLaserSequence {
   LaserFrame *frame_first ;
   LaserFrame *frame_last ;
   int frame_count ;
};
#line 94 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-ild.c"
typedef struct tagLaserSequence LaserSequence;
#line 96 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-ild.c"
typedef LaserSequence *pLaserSequence;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__325___8 {
    SI_ASYNCNL___19 = -60,
    SI_DETHREAD___19 = -7,
    SI_TKILL___19 = -6,
    SI_SIGIO___19 = -5,
    SI_ASYNCIO___19 = -4,
    SI_MESGQ___19 = -3,
    SI_TIMER___19 = -2,
    SI_QUEUE___19 = -1,
    SI_USER___19 = 0,
    SI_KERNEL___19 = 128
} ;
#line 71
enum __anonenum__326___8 {
    ILL_ILLOPC___19 = 1,
    ILL_ILLOPN___19 = 2,
    ILL_ILLADR___19 = 3,
    ILL_ILLTRP___19 = 4,
    ILL_PRVOPC___19 = 5,
    ILL_PRVREG___19 = 6,
    ILL_COPROC___19 = 7,
    ILL_BADSTK___19 = 8,
    ILL_BADIADDR___19 = 9
} ;
#line 94
enum __anonenum__327___8 {
    FPE_INTDIV___19 = 1,
    FPE_INTOVF___19 = 2,
    FPE_FLTDIV___19 = 3,
    FPE_FLTOVF___19 = 4,
    FPE_FLTUND___19 = 5,
    FPE_FLTRES___19 = 6,
    FPE_FLTINV___19 = 7,
    FPE_FLTSUB___19 = 8,
    FPE_FLTUNK___19 = 14,
    FPE_CONDTRAP___19 = 15
} ;
#line 119
enum __anonenum__328___8 {
    SEGV_MAPERR___19 = 1,
    SEGV_ACCERR___19 = 2,
    SEGV_BNDERR___19 = 3,
    SEGV_PKUERR___19 = 4,
    SEGV_ACCADI___19 = 5,
    SEGV_ADIDERR___19 = 6,
    SEGV_ADIPERR___19 = 7,
    SEGV_MTEAERR___19 = 8,
    SEGV_MTESERR___19 = 9
} ;
#line 142
enum __anonenum__329___8 {
    BUS_ADRALN___19 = 1,
    BUS_ADRERR___19 = 2,
    BUS_OBJERR___19 = 3,
    BUS_MCEERR_AR___19 = 4,
    BUS_MCEERR_AO___19 = 5
} ;
#line 176
enum __anonenum__330___8 {
    CLD_EXITED___19 = 1,
    CLD_KILLED___19 = 2,
    CLD_DUMPED___19 = 3,
    CLD_TRAPPED___19 = 4,
    CLD_STOPPED___19 = 5,
    CLD_CONTINUED___19 = 6
} ;
#line 193
enum __anonenum__331___8 {
    POLL_IN___19 = 1,
    POLL_OUT___19 = 2,
    POLL_MSG___19 = 3,
    POLL_ERR___19 = 4,
    POLL_PRI___19 = 5,
    POLL_HUP___19 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__334___8 {
    SIGEV_SIGNAL___19 = 0,
    SIGEV_NONE___19 = 1,
    SIGEV_THREAD___19 = 2,
    SIGEV_THREAD_ID___19 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__339___8 {
    SS_ONSTACK___19 = 1,
    SS_DISABLE___19 = 2
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__347___8 {
    DT_UNKNOWN___19 = 0,
    DT_FIFO___19 = 1,
    DT_CHR___19 = 2,
    DT_DIR___19 = 4,
    DT_BLK___19 = 6,
    DT_REG___19 = 8,
    DT_LNK___19 = 10,
    DT_SOCK___19 = 12,
    DT_WHT___19 = 14
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__406___8 {
    PTHREAD_CREATE_JOINABLE___19 = 0,
    PTHREAD_CREATE_DETACHED___19 = 1
} ;
#line 47
enum __anonenum__407___8 {
    PTHREAD_MUTEX_TIMED_NP___19 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___19 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___19 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___19 = 3,
    PTHREAD_MUTEX_NORMAL___19 = 0,
    PTHREAD_MUTEX_RECURSIVE___19 = 1,
    PTHREAD_MUTEX_ERRORCHECK___19 = 2,
    PTHREAD_MUTEX_DEFAULT___19 = 0
} ;
#line 69
enum __anonenum__408___8 {
    PTHREAD_MUTEX_STALLED___19 = 0,
    PTHREAD_MUTEX_STALLED_NP___19 = 0,
    PTHREAD_MUTEX_ROBUST___19 = 1,
    PTHREAD_MUTEX_ROBUST_NP___19 = 1
} ;
#line 81
enum __anonenum__409___10 {
    PTHREAD_PRIO_NONE___19 = 0,
    PTHREAD_PRIO_INHERIT___19 = 1,
    PTHREAD_PRIO_PROTECT___19 = 2
} ;
#line 104
enum __anonenum__410___8 {
    PTHREAD_RWLOCK_PREFER_READER_NP___19 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___19 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___19 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___19 = 0
} ;
#line 124
enum __anonenum__411___8 {
    PTHREAD_INHERIT_SCHED___19 = 0,
    PTHREAD_EXPLICIT_SCHED___19 = 1
} ;
#line 134
enum __anonenum__412___8 {
    PTHREAD_SCOPE_SYSTEM___19 = 0,
    PTHREAD_SCOPE_PROCESS___19 = 1
} ;
#line 144
enum __anonenum__413___8 {
    PTHREAD_PROCESS_PRIVATE___19 = 0,
    PTHREAD_PROCESS_SHARED___19 = 1
} ;
#line 168
enum __anonenum__414___8 {
    PTHREAD_CANCEL_ENABLE___19 = 0,
    PTHREAD_CANCEL_DISABLE___19 = 1
} ;
#line 175
enum __anonenum__415___8 {
    PTHREAD_CANCEL_DEFERRED___19 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___19 = 1
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__607___2 {
    SI_ASYNCNL___20 = -60,
    SI_DETHREAD___20 = -7,
    SI_TKILL___20 = -6,
    SI_SIGIO___20 = -5,
    SI_ASYNCIO___20 = -4,
    SI_MESGQ___20 = -3,
    SI_TIMER___20 = -2,
    SI_QUEUE___20 = -1,
    SI_USER___20 = 0,
    SI_KERNEL___20 = 128
} ;
#line 71
enum __anonenum__608___2 {
    ILL_ILLOPC___20 = 1,
    ILL_ILLOPN___20 = 2,
    ILL_ILLADR___20 = 3,
    ILL_ILLTRP___20 = 4,
    ILL_PRVOPC___20 = 5,
    ILL_PRVREG___20 = 6,
    ILL_COPROC___20 = 7,
    ILL_BADSTK___20 = 8,
    ILL_BADIADDR___20 = 9
} ;
#line 94
enum __anonenum__609___2 {
    FPE_INTDIV___20 = 1,
    FPE_INTOVF___20 = 2,
    FPE_FLTDIV___20 = 3,
    FPE_FLTOVF___20 = 4,
    FPE_FLTUND___20 = 5,
    FPE_FLTRES___20 = 6,
    FPE_FLTINV___20 = 7,
    FPE_FLTSUB___20 = 8,
    FPE_FLTUNK___20 = 14,
    FPE_CONDTRAP___20 = 15
} ;
#line 119
enum __anonenum__610___2 {
    SEGV_MAPERR___20 = 1,
    SEGV_ACCERR___20 = 2,
    SEGV_BNDERR___20 = 3,
    SEGV_PKUERR___20 = 4,
    SEGV_ACCADI___20 = 5,
    SEGV_ADIDERR___20 = 6,
    SEGV_ADIPERR___20 = 7,
    SEGV_MTEAERR___20 = 8,
    SEGV_MTESERR___20 = 9
} ;
#line 142
enum __anonenum__611___2 {
    BUS_ADRALN___20 = 1,
    BUS_ADRERR___20 = 2,
    BUS_OBJERR___20 = 3,
    BUS_MCEERR_AR___20 = 4,
    BUS_MCEERR_AO___20 = 5
} ;
#line 176
enum __anonenum__612___2 {
    CLD_EXITED___20 = 1,
    CLD_KILLED___20 = 2,
    CLD_DUMPED___20 = 3,
    CLD_TRAPPED___20 = 4,
    CLD_STOPPED___20 = 5,
    CLD_CONTINUED___20 = 6
} ;
#line 193
enum __anonenum__613___2 {
    POLL_IN___20 = 1,
    POLL_OUT___20 = 2,
    POLL_MSG___20 = 3,
    POLL_ERR___20 = 4,
    POLL_PRI___20 = 5,
    POLL_HUP___20 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__616___2 {
    SIGEV_SIGNAL___20 = 0,
    SIGEV_NONE___20 = 1,
    SIGEV_THREAD___20 = 2,
    SIGEV_THREAD_ID___20 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__621___2 {
    SS_ONSTACK___20 = 1,
    SS_DISABLE___20 = 2
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__629___2 {
    DT_UNKNOWN___20 = 0,
    DT_FIFO___20 = 1,
    DT_CHR___20 = 2,
    DT_DIR___20 = 4,
    DT_BLK___20 = 6,
    DT_REG___20 = 8,
    DT_LNK___20 = 10,
    DT_SOCK___20 = 12,
    DT_WHT___20 = 14
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__688___2 {
    PTHREAD_CREATE_JOINABLE___20 = 0,
    PTHREAD_CREATE_DETACHED___20 = 1
} ;
#line 47
enum __anonenum__689___2 {
    PTHREAD_MUTEX_TIMED_NP___20 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___20 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___20 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___20 = 3,
    PTHREAD_MUTEX_NORMAL___20 = 0,
    PTHREAD_MUTEX_RECURSIVE___20 = 1,
    PTHREAD_MUTEX_ERRORCHECK___20 = 2,
    PTHREAD_MUTEX_DEFAULT___20 = 0
} ;
#line 69
enum __anonenum__690___2 {
    PTHREAD_MUTEX_STALLED___20 = 0,
    PTHREAD_MUTEX_STALLED_NP___20 = 0,
    PTHREAD_MUTEX_ROBUST___20 = 1,
    PTHREAD_MUTEX_ROBUST_NP___20 = 1
} ;
#line 81
enum __anonenum__691___2 {
    PTHREAD_PRIO_NONE___20 = 0,
    PTHREAD_PRIO_INHERIT___20 = 1,
    PTHREAD_PRIO_PROTECT___20 = 2
} ;
#line 104
enum __anonenum__692___2 {
    PTHREAD_RWLOCK_PREFER_READER_NP___20 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___20 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___20 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___20 = 0
} ;
#line 124
enum __anonenum__693___2 {
    PTHREAD_INHERIT_SCHED___20 = 0,
    PTHREAD_EXPLICIT_SCHED___20 = 1
} ;
#line 134
enum __anonenum__694___2 {
    PTHREAD_SCOPE_SYSTEM___20 = 0,
    PTHREAD_SCOPE_PROCESS___20 = 1
} ;
#line 144
enum __anonenum__695___2 {
    PTHREAD_PROCESS_PRIVATE___20 = 0,
    PTHREAD_PROCESS_SHARED___20 = 1
} ;
#line 168
enum __anonenum__696___2 {
    PTHREAD_CANCEL_ENABLE___20 = 0,
    PTHREAD_CANCEL_DISABLE___20 = 1
} ;
#line 175
enum __anonenum__697___2 {
    PTHREAD_CANCEL_DEFERRED___20 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___20 = 1
} ;
#line 934 "/usr/include/math.h"
enum __anonenum__1274 {
    FP_NAN___5 = 0,
    FP_INFINITE___5 = 1,
    FP_ZERO___5 = 2,
    FP_SUBNORMAL___5 = 3,
    FP_NORMAL___5 = 4
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__876___0 {
    SI_ASYNCNL___21 = -60,
    SI_DETHREAD___21 = -7,
    SI_TKILL___21 = -6,
    SI_SIGIO___21 = -5,
    SI_ASYNCIO___21 = -4,
    SI_MESGQ___21 = -3,
    SI_TIMER___21 = -2,
    SI_QUEUE___21 = -1,
    SI_USER___21 = 0,
    SI_KERNEL___21 = 128
} ;
#line 71
enum __anonenum__877___0 {
    ILL_ILLOPC___21 = 1,
    ILL_ILLOPN___21 = 2,
    ILL_ILLADR___21 = 3,
    ILL_ILLTRP___21 = 4,
    ILL_PRVOPC___21 = 5,
    ILL_PRVREG___21 = 6,
    ILL_COPROC___21 = 7,
    ILL_BADSTK___21 = 8,
    ILL_BADIADDR___21 = 9
} ;
#line 94
enum __anonenum__878___0 {
    FPE_INTDIV___21 = 1,
    FPE_INTOVF___21 = 2,
    FPE_FLTDIV___21 = 3,
    FPE_FLTOVF___21 = 4,
    FPE_FLTUND___21 = 5,
    FPE_FLTRES___21 = 6,
    FPE_FLTINV___21 = 7,
    FPE_FLTSUB___21 = 8,
    FPE_FLTUNK___21 = 14,
    FPE_CONDTRAP___21 = 15
} ;
#line 119
enum __anonenum__879___0 {
    SEGV_MAPERR___21 = 1,
    SEGV_ACCERR___21 = 2,
    SEGV_BNDERR___21 = 3,
    SEGV_PKUERR___21 = 4,
    SEGV_ACCADI___21 = 5,
    SEGV_ADIDERR___21 = 6,
    SEGV_ADIPERR___21 = 7,
    SEGV_MTEAERR___21 = 8,
    SEGV_MTESERR___21 = 9
} ;
#line 142
enum __anonenum__880___0 {
    BUS_ADRALN___21 = 1,
    BUS_ADRERR___21 = 2,
    BUS_OBJERR___21 = 3,
    BUS_MCEERR_AR___21 = 4,
    BUS_MCEERR_AO___21 = 5
} ;
#line 176
enum __anonenum__881___0 {
    CLD_EXITED___21 = 1,
    CLD_KILLED___21 = 2,
    CLD_DUMPED___21 = 3,
    CLD_TRAPPED___21 = 4,
    CLD_STOPPED___21 = 5,
    CLD_CONTINUED___21 = 6
} ;
#line 193
enum __anonenum__882___0 {
    POLL_IN___21 = 1,
    POLL_OUT___21 = 2,
    POLL_MSG___21 = 3,
    POLL_ERR___21 = 4,
    POLL_PRI___21 = 5,
    POLL_HUP___21 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__885___0 {
    SIGEV_SIGNAL___21 = 0,
    SIGEV_NONE___21 = 1,
    SIGEV_THREAD___21 = 2,
    SIGEV_THREAD_ID___21 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__890___0 {
    SS_ONSTACK___21 = 1,
    SS_DISABLE___21 = 2
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__898___0 {
    DT_UNKNOWN___21 = 0,
    DT_FIFO___21 = 1,
    DT_CHR___21 = 2,
    DT_DIR___21 = 4,
    DT_BLK___21 = 6,
    DT_REG___21 = 8,
    DT_LNK___21 = 10,
    DT_SOCK___21 = 12,
    DT_WHT___21 = 14
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__819___1 {
    PTHREAD_CREATE_JOINABLE___21 = 0,
    PTHREAD_CREATE_DETACHED___21 = 1
} ;
#line 47
enum __anonenum__820___1 {
    PTHREAD_MUTEX_TIMED_NP___21 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___21 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___21 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___21 = 3,
    PTHREAD_MUTEX_NORMAL___21 = 0,
    PTHREAD_MUTEX_RECURSIVE___21 = 1,
    PTHREAD_MUTEX_ERRORCHECK___21 = 2,
    PTHREAD_MUTEX_DEFAULT___21 = 0
} ;
#line 69
enum __anonenum__821___1 {
    PTHREAD_MUTEX_STALLED___21 = 0,
    PTHREAD_MUTEX_STALLED_NP___21 = 0,
    PTHREAD_MUTEX_ROBUST___21 = 1,
    PTHREAD_MUTEX_ROBUST_NP___21 = 1
} ;
#line 81
enum __anonenum__822___1 {
    PTHREAD_PRIO_NONE___21 = 0,
    PTHREAD_PRIO_INHERIT___21 = 1,
    PTHREAD_PRIO_PROTECT___21 = 2
} ;
#line 104
enum __anonenum__823___1 {
    PTHREAD_RWLOCK_PREFER_READER_NP___21 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___21 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___21 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___21 = 0
} ;
#line 124
enum __anonenum__409___11 {
    PTHREAD_INHERIT_SCHED___21 = 0,
    PTHREAD_EXPLICIT_SCHED___21 = 1
} ;
#line 134
enum __anonenum__824___1 {
    PTHREAD_SCOPE_SYSTEM___21 = 0,
    PTHREAD_SCOPE_PROCESS___21 = 1
} ;
#line 144
enum __anonenum__825___1 {
    PTHREAD_PROCESS_PRIVATE___21 = 0,
    PTHREAD_PROCESS_SHARED___21 = 1
} ;
#line 168
enum __anonenum__826___1 {
    PTHREAD_CANCEL_ENABLE___21 = 0,
    PTHREAD_CANCEL_DISABLE___21 = 1
} ;
#line 175
enum __anonenum__827___1 {
    PTHREAD_CANCEL_DEFERRED___21 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___21 = 1
} ;
#line 53 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-dr2d.c"
struct Chunk {
   char ID[4] ;
   unsigned int Size ;
   unsigned char *Data ;
};
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__607___3 {
    SI_ASYNCNL___22 = -60,
    SI_DETHREAD___22 = -7,
    SI_TKILL___22 = -6,
    SI_SIGIO___22 = -5,
    SI_ASYNCIO___22 = -4,
    SI_MESGQ___22 = -3,
    SI_TIMER___22 = -2,
    SI_QUEUE___22 = -1,
    SI_USER___22 = 0,
    SI_KERNEL___22 = 128
} ;
#line 71
enum __anonenum__608___3 {
    ILL_ILLOPC___22 = 1,
    ILL_ILLOPN___22 = 2,
    ILL_ILLADR___22 = 3,
    ILL_ILLTRP___22 = 4,
    ILL_PRVOPC___22 = 5,
    ILL_PRVREG___22 = 6,
    ILL_COPROC___22 = 7,
    ILL_BADSTK___22 = 8,
    ILL_BADIADDR___22 = 9
} ;
#line 94
enum __anonenum__609___3 {
    FPE_INTDIV___22 = 1,
    FPE_INTOVF___22 = 2,
    FPE_FLTDIV___22 = 3,
    FPE_FLTOVF___22 = 4,
    FPE_FLTUND___22 = 5,
    FPE_FLTRES___22 = 6,
    FPE_FLTINV___22 = 7,
    FPE_FLTSUB___22 = 8,
    FPE_FLTUNK___22 = 14,
    FPE_CONDTRAP___22 = 15
} ;
#line 119
enum __anonenum__610___3 {
    SEGV_MAPERR___22 = 1,
    SEGV_ACCERR___22 = 2,
    SEGV_BNDERR___22 = 3,
    SEGV_PKUERR___22 = 4,
    SEGV_ACCADI___22 = 5,
    SEGV_ADIDERR___22 = 6,
    SEGV_ADIPERR___22 = 7,
    SEGV_MTEAERR___22 = 8,
    SEGV_MTESERR___22 = 9
} ;
#line 142
enum __anonenum__611___3 {
    BUS_ADRALN___22 = 1,
    BUS_ADRERR___22 = 2,
    BUS_OBJERR___22 = 3,
    BUS_MCEERR_AR___22 = 4,
    BUS_MCEERR_AO___22 = 5
} ;
#line 176
enum __anonenum__612___3 {
    CLD_EXITED___22 = 1,
    CLD_KILLED___22 = 2,
    CLD_DUMPED___22 = 3,
    CLD_TRAPPED___22 = 4,
    CLD_STOPPED___22 = 5,
    CLD_CONTINUED___22 = 6
} ;
#line 193
enum __anonenum__613___3 {
    POLL_IN___22 = 1,
    POLL_OUT___22 = 2,
    POLL_MSG___22 = 3,
    POLL_ERR___22 = 4,
    POLL_PRI___22 = 5,
    POLL_HUP___22 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__616___3 {
    SIGEV_SIGNAL___22 = 0,
    SIGEV_NONE___22 = 1,
    SIGEV_THREAD___22 = 2,
    SIGEV_THREAD_ID___22 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__621___3 {
    SS_ONSTACK___22 = 1,
    SS_DISABLE___22 = 2
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__629___3 {
    DT_UNKNOWN___22 = 0,
    DT_FIFO___22 = 1,
    DT_CHR___22 = 2,
    DT_DIR___22 = 4,
    DT_BLK___22 = 6,
    DT_REG___22 = 8,
    DT_LNK___22 = 10,
    DT_SOCK___22 = 12,
    DT_WHT___22 = 14
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__688___3 {
    PTHREAD_CREATE_JOINABLE___22 = 0,
    PTHREAD_CREATE_DETACHED___22 = 1
} ;
#line 47
enum __anonenum__689___3 {
    PTHREAD_MUTEX_TIMED_NP___22 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___22 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___22 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___22 = 3,
    PTHREAD_MUTEX_NORMAL___22 = 0,
    PTHREAD_MUTEX_RECURSIVE___22 = 1,
    PTHREAD_MUTEX_ERRORCHECK___22 = 2,
    PTHREAD_MUTEX_DEFAULT___22 = 0
} ;
#line 69
enum __anonenum__690___3 {
    PTHREAD_MUTEX_STALLED___22 = 0,
    PTHREAD_MUTEX_STALLED_NP___22 = 0,
    PTHREAD_MUTEX_ROBUST___22 = 1,
    PTHREAD_MUTEX_ROBUST_NP___22 = 1
} ;
#line 81
enum __anonenum__691___3 {
    PTHREAD_PRIO_NONE___22 = 0,
    PTHREAD_PRIO_INHERIT___22 = 1,
    PTHREAD_PRIO_PROTECT___22 = 2
} ;
#line 104
enum __anonenum__692___3 {
    PTHREAD_RWLOCK_PREFER_READER_NP___22 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___22 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___22 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___22 = 0
} ;
#line 124
enum __anonenum__693___3 {
    PTHREAD_INHERIT_SCHED___22 = 0,
    PTHREAD_EXPLICIT_SCHED___22 = 1
} ;
#line 134
enum __anonenum__694___3 {
    PTHREAD_SCOPE_SYSTEM___22 = 0,
    PTHREAD_SCOPE_PROCESS___22 = 1
} ;
#line 144
enum __anonenum__695___3 {
    PTHREAD_PROCESS_PRIVATE___22 = 0,
    PTHREAD_PROCESS_SHARED___22 = 1
} ;
#line 168
enum __anonenum__696___3 {
    PTHREAD_CANCEL_ENABLE___22 = 0,
    PTHREAD_CANCEL_DISABLE___22 = 1
} ;
#line 175
enum __anonenum__697___3 {
    PTHREAD_CANCEL_DEFERRED___22 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___22 = 1
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__607___4 {
    SI_ASYNCNL___23 = -60,
    SI_DETHREAD___23 = -7,
    SI_TKILL___23 = -6,
    SI_SIGIO___23 = -5,
    SI_ASYNCIO___23 = -4,
    SI_MESGQ___23 = -3,
    SI_TIMER___23 = -2,
    SI_QUEUE___23 = -1,
    SI_USER___23 = 0,
    SI_KERNEL___23 = 128
} ;
#line 71
enum __anonenum__608___4 {
    ILL_ILLOPC___23 = 1,
    ILL_ILLOPN___23 = 2,
    ILL_ILLADR___23 = 3,
    ILL_ILLTRP___23 = 4,
    ILL_PRVOPC___23 = 5,
    ILL_PRVREG___23 = 6,
    ILL_COPROC___23 = 7,
    ILL_BADSTK___23 = 8,
    ILL_BADIADDR___23 = 9
} ;
#line 94
enum __anonenum__609___4 {
    FPE_INTDIV___23 = 1,
    FPE_INTOVF___23 = 2,
    FPE_FLTDIV___23 = 3,
    FPE_FLTOVF___23 = 4,
    FPE_FLTUND___23 = 5,
    FPE_FLTRES___23 = 6,
    FPE_FLTINV___23 = 7,
    FPE_FLTSUB___23 = 8,
    FPE_FLTUNK___23 = 14,
    FPE_CONDTRAP___23 = 15
} ;
#line 119
enum __anonenum__610___4 {
    SEGV_MAPERR___23 = 1,
    SEGV_ACCERR___23 = 2,
    SEGV_BNDERR___23 = 3,
    SEGV_PKUERR___23 = 4,
    SEGV_ACCADI___23 = 5,
    SEGV_ADIDERR___23 = 6,
    SEGV_ADIPERR___23 = 7,
    SEGV_MTEAERR___23 = 8,
    SEGV_MTESERR___23 = 9
} ;
#line 142
enum __anonenum__611___4 {
    BUS_ADRALN___23 = 1,
    BUS_ADRERR___23 = 2,
    BUS_OBJERR___23 = 3,
    BUS_MCEERR_AR___23 = 4,
    BUS_MCEERR_AO___23 = 5
} ;
#line 176
enum __anonenum__612___4 {
    CLD_EXITED___23 = 1,
    CLD_KILLED___23 = 2,
    CLD_DUMPED___23 = 3,
    CLD_TRAPPED___23 = 4,
    CLD_STOPPED___23 = 5,
    CLD_CONTINUED___23 = 6
} ;
#line 193
enum __anonenum__613___4 {
    POLL_IN___23 = 1,
    POLL_OUT___23 = 2,
    POLL_MSG___23 = 3,
    POLL_ERR___23 = 4,
    POLL_PRI___23 = 5,
    POLL_HUP___23 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__616___4 {
    SIGEV_SIGNAL___23 = 0,
    SIGEV_NONE___23 = 1,
    SIGEV_THREAD___23 = 2,
    SIGEV_THREAD_ID___23 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__621___4 {
    SS_ONSTACK___23 = 1,
    SS_DISABLE___23 = 2
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__629___4 {
    DT_UNKNOWN___23 = 0,
    DT_FIFO___23 = 1,
    DT_CHR___23 = 2,
    DT_DIR___23 = 4,
    DT_BLK___23 = 6,
    DT_REG___23 = 8,
    DT_LNK___23 = 10,
    DT_SOCK___23 = 12,
    DT_WHT___23 = 14
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__688___4 {
    PTHREAD_CREATE_JOINABLE___23 = 0,
    PTHREAD_CREATE_DETACHED___23 = 1
} ;
#line 47
enum __anonenum__689___4 {
    PTHREAD_MUTEX_TIMED_NP___23 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___23 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___23 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___23 = 3,
    PTHREAD_MUTEX_NORMAL___23 = 0,
    PTHREAD_MUTEX_RECURSIVE___23 = 1,
    PTHREAD_MUTEX_ERRORCHECK___23 = 2,
    PTHREAD_MUTEX_DEFAULT___23 = 0
} ;
#line 69
enum __anonenum__690___4 {
    PTHREAD_MUTEX_STALLED___23 = 0,
    PTHREAD_MUTEX_STALLED_NP___23 = 0,
    PTHREAD_MUTEX_ROBUST___23 = 1,
    PTHREAD_MUTEX_ROBUST_NP___23 = 1
} ;
#line 81
enum __anonenum__691___4 {
    PTHREAD_PRIO_NONE___23 = 0,
    PTHREAD_PRIO_INHERIT___23 = 1,
    PTHREAD_PRIO_PROTECT___23 = 2
} ;
#line 104
enum __anonenum__692___4 {
    PTHREAD_RWLOCK_PREFER_READER_NP___23 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___23 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___23 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___23 = 0
} ;
#line 124
enum __anonenum__693___4 {
    PTHREAD_INHERIT_SCHED___23 = 0,
    PTHREAD_EXPLICIT_SCHED___23 = 1
} ;
#line 134
enum __anonenum__694___4 {
    PTHREAD_SCOPE_SYSTEM___23 = 0,
    PTHREAD_SCOPE_PROCESS___23 = 1
} ;
#line 144
enum __anonenum__695___4 {
    PTHREAD_PROCESS_PRIVATE___23 = 0,
    PTHREAD_PROCESS_SHARED___23 = 1
} ;
#line 168
enum __anonenum__696___4 {
    PTHREAD_CANCEL_ENABLE___23 = 0,
    PTHREAD_CANCEL_DISABLE___23 = 1
} ;
#line 175
enum __anonenum__697___4 {
    PTHREAD_CANCEL_DEFERRED___23 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___23 = 1
} ;
#line 934 "/usr/include/math.h"
enum __anonenum__1277 {
    FP_NAN___6 = 0,
    FP_INFINITE___6 = 1,
    FP_ZERO___6 = 2,
    FP_SUBNORMAL___6 = 3,
    FP_NORMAL___6 = 4
} ;
#line 34 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-mif.c"
struct __anonstruct_1278 {
   char *tag ;
   at_color c ;
};
#line 37 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-mif.c"
typedef struct __anonstruct_1278 ColorT;
#line 39 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-mif.c"
struct __anonstruct_1279 {
   int llx ;
   int lly ;
   int urx ;
   int ury ;
   gfloat dpi ;
};
#line 45 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-mif.c"
typedef struct __anonstruct_1279 BboxT;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__607___5 {
    SI_ASYNCNL___24 = -60,
    SI_DETHREAD___24 = -7,
    SI_TKILL___24 = -6,
    SI_SIGIO___24 = -5,
    SI_ASYNCIO___24 = -4,
    SI_MESGQ___24 = -3,
    SI_TIMER___24 = -2,
    SI_QUEUE___24 = -1,
    SI_USER___24 = 0,
    SI_KERNEL___24 = 128
} ;
#line 71
enum __anonenum__608___5 {
    ILL_ILLOPC___24 = 1,
    ILL_ILLOPN___24 = 2,
    ILL_ILLADR___24 = 3,
    ILL_ILLTRP___24 = 4,
    ILL_PRVOPC___24 = 5,
    ILL_PRVREG___24 = 6,
    ILL_COPROC___24 = 7,
    ILL_BADSTK___24 = 8,
    ILL_BADIADDR___24 = 9
} ;
#line 94
enum __anonenum__609___5 {
    FPE_INTDIV___24 = 1,
    FPE_INTOVF___24 = 2,
    FPE_FLTDIV___24 = 3,
    FPE_FLTOVF___24 = 4,
    FPE_FLTUND___24 = 5,
    FPE_FLTRES___24 = 6,
    FPE_FLTINV___24 = 7,
    FPE_FLTSUB___24 = 8,
    FPE_FLTUNK___24 = 14,
    FPE_CONDTRAP___24 = 15
} ;
#line 119
enum __anonenum__610___5 {
    SEGV_MAPERR___24 = 1,
    SEGV_ACCERR___24 = 2,
    SEGV_BNDERR___24 = 3,
    SEGV_PKUERR___24 = 4,
    SEGV_ACCADI___24 = 5,
    SEGV_ADIDERR___24 = 6,
    SEGV_ADIPERR___24 = 7,
    SEGV_MTEAERR___24 = 8,
    SEGV_MTESERR___24 = 9
} ;
#line 142
enum __anonenum__611___5 {
    BUS_ADRALN___24 = 1,
    BUS_ADRERR___24 = 2,
    BUS_OBJERR___24 = 3,
    BUS_MCEERR_AR___24 = 4,
    BUS_MCEERR_AO___24 = 5
} ;
#line 176
enum __anonenum__612___5 {
    CLD_EXITED___24 = 1,
    CLD_KILLED___24 = 2,
    CLD_DUMPED___24 = 3,
    CLD_TRAPPED___24 = 4,
    CLD_STOPPED___24 = 5,
    CLD_CONTINUED___24 = 6
} ;
#line 193
enum __anonenum__613___5 {
    POLL_IN___24 = 1,
    POLL_OUT___24 = 2,
    POLL_MSG___24 = 3,
    POLL_ERR___24 = 4,
    POLL_PRI___24 = 5,
    POLL_HUP___24 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__616___5 {
    SIGEV_SIGNAL___24 = 0,
    SIGEV_NONE___24 = 1,
    SIGEV_THREAD___24 = 2,
    SIGEV_THREAD_ID___24 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__621___5 {
    SS_ONSTACK___24 = 1,
    SS_DISABLE___24 = 2
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__629___5 {
    DT_UNKNOWN___24 = 0,
    DT_FIFO___24 = 1,
    DT_CHR___24 = 2,
    DT_DIR___24 = 4,
    DT_BLK___24 = 6,
    DT_REG___24 = 8,
    DT_LNK___24 = 10,
    DT_SOCK___24 = 12,
    DT_WHT___24 = 14
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__688___5 {
    PTHREAD_CREATE_JOINABLE___24 = 0,
    PTHREAD_CREATE_DETACHED___24 = 1
} ;
#line 47
enum __anonenum__689___5 {
    PTHREAD_MUTEX_TIMED_NP___24 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___24 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___24 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___24 = 3,
    PTHREAD_MUTEX_NORMAL___24 = 0,
    PTHREAD_MUTEX_RECURSIVE___24 = 1,
    PTHREAD_MUTEX_ERRORCHECK___24 = 2,
    PTHREAD_MUTEX_DEFAULT___24 = 0
} ;
#line 69
enum __anonenum__690___5 {
    PTHREAD_MUTEX_STALLED___24 = 0,
    PTHREAD_MUTEX_STALLED_NP___24 = 0,
    PTHREAD_MUTEX_ROBUST___24 = 1,
    PTHREAD_MUTEX_ROBUST_NP___24 = 1
} ;
#line 81
enum __anonenum__691___5 {
    PTHREAD_PRIO_NONE___24 = 0,
    PTHREAD_PRIO_INHERIT___24 = 1,
    PTHREAD_PRIO_PROTECT___24 = 2
} ;
#line 104
enum __anonenum__692___5 {
    PTHREAD_RWLOCK_PREFER_READER_NP___24 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___24 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___24 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___24 = 0
} ;
#line 124
enum __anonenum__693___5 {
    PTHREAD_INHERIT_SCHED___24 = 0,
    PTHREAD_EXPLICIT_SCHED___24 = 1
} ;
#line 134
enum __anonenum__694___5 {
    PTHREAD_SCOPE_SYSTEM___24 = 0,
    PTHREAD_SCOPE_PROCESS___24 = 1
} ;
#line 144
enum __anonenum__695___5 {
    PTHREAD_PROCESS_PRIVATE___24 = 0,
    PTHREAD_PROCESS_SHARED___24 = 1
} ;
#line 168
enum __anonenum__696___5 {
    PTHREAD_CANCEL_ENABLE___24 = 0,
    PTHREAD_CANCEL_DISABLE___24 = 1
} ;
#line 175
enum __anonenum__697___5 {
    PTHREAD_CANCEL_DEFERRED___24 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___24 = 1
} ;
#line 934 "/usr/include/math.h"
enum __anonenum__1277___0 {
    FP_NAN___7 = 0,
    FP_INFINITE___7 = 1,
    FP_ZERO___7 = 2,
    FP_SUBNORMAL___7 = 3,
    FP_NORMAL___7 = 4
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__607___6 {
    SI_ASYNCNL___25 = -60,
    SI_DETHREAD___25 = -7,
    SI_TKILL___25 = -6,
    SI_SIGIO___25 = -5,
    SI_ASYNCIO___25 = -4,
    SI_MESGQ___25 = -3,
    SI_TIMER___25 = -2,
    SI_QUEUE___25 = -1,
    SI_USER___25 = 0,
    SI_KERNEL___25 = 128
} ;
#line 71
enum __anonenum__608___6 {
    ILL_ILLOPC___25 = 1,
    ILL_ILLOPN___25 = 2,
    ILL_ILLADR___25 = 3,
    ILL_ILLTRP___25 = 4,
    ILL_PRVOPC___25 = 5,
    ILL_PRVREG___25 = 6,
    ILL_COPROC___25 = 7,
    ILL_BADSTK___25 = 8,
    ILL_BADIADDR___25 = 9
} ;
#line 94
enum __anonenum__609___6 {
    FPE_INTDIV___25 = 1,
    FPE_INTOVF___25 = 2,
    FPE_FLTDIV___25 = 3,
    FPE_FLTOVF___25 = 4,
    FPE_FLTUND___25 = 5,
    FPE_FLTRES___25 = 6,
    FPE_FLTINV___25 = 7,
    FPE_FLTSUB___25 = 8,
    FPE_FLTUNK___25 = 14,
    FPE_CONDTRAP___25 = 15
} ;
#line 119
enum __anonenum__610___6 {
    SEGV_MAPERR___25 = 1,
    SEGV_ACCERR___25 = 2,
    SEGV_BNDERR___25 = 3,
    SEGV_PKUERR___25 = 4,
    SEGV_ACCADI___25 = 5,
    SEGV_ADIDERR___25 = 6,
    SEGV_ADIPERR___25 = 7,
    SEGV_MTEAERR___25 = 8,
    SEGV_MTESERR___25 = 9
} ;
#line 142
enum __anonenum__611___6 {
    BUS_ADRALN___25 = 1,
    BUS_ADRERR___25 = 2,
    BUS_OBJERR___25 = 3,
    BUS_MCEERR_AR___25 = 4,
    BUS_MCEERR_AO___25 = 5
} ;
#line 176
enum __anonenum__612___6 {
    CLD_EXITED___25 = 1,
    CLD_KILLED___25 = 2,
    CLD_DUMPED___25 = 3,
    CLD_TRAPPED___25 = 4,
    CLD_STOPPED___25 = 5,
    CLD_CONTINUED___25 = 6
} ;
#line 193
enum __anonenum__613___6 {
    POLL_IN___25 = 1,
    POLL_OUT___25 = 2,
    POLL_MSG___25 = 3,
    POLL_ERR___25 = 4,
    POLL_PRI___25 = 5,
    POLL_HUP___25 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__616___6 {
    SIGEV_SIGNAL___25 = 0,
    SIGEV_NONE___25 = 1,
    SIGEV_THREAD___25 = 2,
    SIGEV_THREAD_ID___25 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__621___6 {
    SS_ONSTACK___25 = 1,
    SS_DISABLE___25 = 2
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__629___6 {
    DT_UNKNOWN___25 = 0,
    DT_FIFO___25 = 1,
    DT_CHR___25 = 2,
    DT_DIR___25 = 4,
    DT_BLK___25 = 6,
    DT_REG___25 = 8,
    DT_LNK___25 = 10,
    DT_SOCK___25 = 12,
    DT_WHT___25 = 14
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__688___6 {
    PTHREAD_CREATE_JOINABLE___25 = 0,
    PTHREAD_CREATE_DETACHED___25 = 1
} ;
#line 47
enum __anonenum__689___6 {
    PTHREAD_MUTEX_TIMED_NP___25 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___25 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___25 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___25 = 3,
    PTHREAD_MUTEX_NORMAL___25 = 0,
    PTHREAD_MUTEX_RECURSIVE___25 = 1,
    PTHREAD_MUTEX_ERRORCHECK___25 = 2,
    PTHREAD_MUTEX_DEFAULT___25 = 0
} ;
#line 69
enum __anonenum__690___6 {
    PTHREAD_MUTEX_STALLED___25 = 0,
    PTHREAD_MUTEX_STALLED_NP___25 = 0,
    PTHREAD_MUTEX_ROBUST___25 = 1,
    PTHREAD_MUTEX_ROBUST_NP___25 = 1
} ;
#line 81
enum __anonenum__691___6 {
    PTHREAD_PRIO_NONE___25 = 0,
    PTHREAD_PRIO_INHERIT___25 = 1,
    PTHREAD_PRIO_PROTECT___25 = 2
} ;
#line 104
enum __anonenum__692___6 {
    PTHREAD_RWLOCK_PREFER_READER_NP___25 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___25 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___25 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___25 = 0
} ;
#line 124
enum __anonenum__693___6 {
    PTHREAD_INHERIT_SCHED___25 = 0,
    PTHREAD_EXPLICIT_SCHED___25 = 1
} ;
#line 134
enum __anonenum__694___6 {
    PTHREAD_SCOPE_SYSTEM___25 = 0,
    PTHREAD_SCOPE_PROCESS___25 = 1
} ;
#line 144
enum __anonenum__695___6 {
    PTHREAD_PROCESS_PRIVATE___25 = 0,
    PTHREAD_PROCESS_SHARED___25 = 1
} ;
#line 168
enum __anonenum__696___6 {
    PTHREAD_CANCEL_ENABLE___25 = 0,
    PTHREAD_CANCEL_DISABLE___25 = 1
} ;
#line 175
enum __anonenum__697___6 {
    PTHREAD_CANCEL_DEFERRED___25 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___25 = 1
} ;
#line 934 "/usr/include/math.h"
enum __anonenum__1280 {
    FP_NAN___8 = 0,
    FP_INFINITE___8 = 1,
    FP_ZERO___8 = 2,
    FP_SUBNORMAL___8 = 3,
    FP_NORMAL___8 = 4
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__607___7 {
    SI_ASYNCNL___26 = -60,
    SI_DETHREAD___26 = -7,
    SI_TKILL___26 = -6,
    SI_SIGIO___26 = -5,
    SI_ASYNCIO___26 = -4,
    SI_MESGQ___26 = -3,
    SI_TIMER___26 = -2,
    SI_QUEUE___26 = -1,
    SI_USER___26 = 0,
    SI_KERNEL___26 = 128
} ;
#line 71
enum __anonenum__608___7 {
    ILL_ILLOPC___26 = 1,
    ILL_ILLOPN___26 = 2,
    ILL_ILLADR___26 = 3,
    ILL_ILLTRP___26 = 4,
    ILL_PRVOPC___26 = 5,
    ILL_PRVREG___26 = 6,
    ILL_COPROC___26 = 7,
    ILL_BADSTK___26 = 8,
    ILL_BADIADDR___26 = 9
} ;
#line 94
enum __anonenum__609___7 {
    FPE_INTDIV___26 = 1,
    FPE_INTOVF___26 = 2,
    FPE_FLTDIV___26 = 3,
    FPE_FLTOVF___26 = 4,
    FPE_FLTUND___26 = 5,
    FPE_FLTRES___26 = 6,
    FPE_FLTINV___26 = 7,
    FPE_FLTSUB___26 = 8,
    FPE_FLTUNK___26 = 14,
    FPE_CONDTRAP___26 = 15
} ;
#line 119
enum __anonenum__610___7 {
    SEGV_MAPERR___26 = 1,
    SEGV_ACCERR___26 = 2,
    SEGV_BNDERR___26 = 3,
    SEGV_PKUERR___26 = 4,
    SEGV_ACCADI___26 = 5,
    SEGV_ADIDERR___26 = 6,
    SEGV_ADIPERR___26 = 7,
    SEGV_MTEAERR___26 = 8,
    SEGV_MTESERR___26 = 9
} ;
#line 142
enum __anonenum__611___7 {
    BUS_ADRALN___26 = 1,
    BUS_ADRERR___26 = 2,
    BUS_OBJERR___26 = 3,
    BUS_MCEERR_AR___26 = 4,
    BUS_MCEERR_AO___26 = 5
} ;
#line 176
enum __anonenum__612___7 {
    CLD_EXITED___26 = 1,
    CLD_KILLED___26 = 2,
    CLD_DUMPED___26 = 3,
    CLD_TRAPPED___26 = 4,
    CLD_STOPPED___26 = 5,
    CLD_CONTINUED___26 = 6
} ;
#line 193
enum __anonenum__613___7 {
    POLL_IN___26 = 1,
    POLL_OUT___26 = 2,
    POLL_MSG___26 = 3,
    POLL_ERR___26 = 4,
    POLL_PRI___26 = 5,
    POLL_HUP___26 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__616___7 {
    SIGEV_SIGNAL___26 = 0,
    SIGEV_NONE___26 = 1,
    SIGEV_THREAD___26 = 2,
    SIGEV_THREAD_ID___26 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__621___7 {
    SS_ONSTACK___26 = 1,
    SS_DISABLE___26 = 2
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__629___7 {
    DT_UNKNOWN___26 = 0,
    DT_FIFO___26 = 1,
    DT_CHR___26 = 2,
    DT_DIR___26 = 4,
    DT_BLK___26 = 6,
    DT_REG___26 = 8,
    DT_LNK___26 = 10,
    DT_SOCK___26 = 12,
    DT_WHT___26 = 14
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__688___7 {
    PTHREAD_CREATE_JOINABLE___26 = 0,
    PTHREAD_CREATE_DETACHED___26 = 1
} ;
#line 47
enum __anonenum__689___7 {
    PTHREAD_MUTEX_TIMED_NP___26 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___26 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___26 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___26 = 3,
    PTHREAD_MUTEX_NORMAL___26 = 0,
    PTHREAD_MUTEX_RECURSIVE___26 = 1,
    PTHREAD_MUTEX_ERRORCHECK___26 = 2,
    PTHREAD_MUTEX_DEFAULT___26 = 0
} ;
#line 69
enum __anonenum__690___7 {
    PTHREAD_MUTEX_STALLED___26 = 0,
    PTHREAD_MUTEX_STALLED_NP___26 = 0,
    PTHREAD_MUTEX_ROBUST___26 = 1,
    PTHREAD_MUTEX_ROBUST_NP___26 = 1
} ;
#line 81
enum __anonenum__691___7 {
    PTHREAD_PRIO_NONE___26 = 0,
    PTHREAD_PRIO_INHERIT___26 = 1,
    PTHREAD_PRIO_PROTECT___26 = 2
} ;
#line 104
enum __anonenum__692___7 {
    PTHREAD_RWLOCK_PREFER_READER_NP___26 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___26 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___26 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___26 = 0
} ;
#line 124
enum __anonenum__693___7 {
    PTHREAD_INHERIT_SCHED___26 = 0,
    PTHREAD_EXPLICIT_SCHED___26 = 1
} ;
#line 134
enum __anonenum__694___7 {
    PTHREAD_SCOPE_SYSTEM___26 = 0,
    PTHREAD_SCOPE_PROCESS___26 = 1
} ;
#line 144
enum __anonenum__695___7 {
    PTHREAD_PROCESS_PRIVATE___26 = 0,
    PTHREAD_PROCESS_SHARED___26 = 1
} ;
#line 168
enum __anonenum__696___7 {
    PTHREAD_CANCEL_ENABLE___26 = 0,
    PTHREAD_CANCEL_DISABLE___26 = 1
} ;
#line 175
enum __anonenum__697___7 {
    PTHREAD_CANCEL_DEFERRED___26 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___26 = 1
} ;
#line 934 "/usr/include/math.h"
enum __anonenum__1277___1 {
    FP_NAN___9 = 0,
    FP_INFINITE___9 = 1,
    FP_ZERO___9 = 2,
    FP_SUBNORMAL___9 = 3,
    FP_NORMAL___9 = 4
} ;
#line 52 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-dxf.c"
enum __anonstruct_1278 {
    NATURAL = 0,
    TANGENT = 1,
    PERIODIC = 2,
    CYCLIC = 3,
    ANTICYCLIC = 4
} ;
#line 53 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-dxf.c"
typedef enum __anonstruct_1278 SPLINE_END_TYPE;
#line 59 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-dxf.c"
struct xypnt_t {
   int xp ;
   int yp ;
};
#line 61 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-dxf.c"
typedef struct xypnt_t xypnt;
#line 63 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-dxf.c"
struct xypnt_point_t {
   xypnt point ;
   struct xypnt_point_t *next_point ;
};
#line 66 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-dxf.c"
typedef struct xypnt_point_t xypnt_point_rec;
#line 68 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-dxf.c"
struct xypnt_head_t {
   xypnt_point_rec *first_point ;
   xypnt_point_rec *last_point ;
   xypnt_point_rec *current_point ;
   struct xypnt_head_t *next_head ;
};
#line 71 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-dxf.c"
typedef struct xypnt_head_t xypnt_head_rec;
#line 73 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-dxf.c"
struct Colors_t {
   int red ;
   int green ;
   int blue ;
};
#line 75 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-dxf.c"
typedef struct Colors_t Colors;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__325___9 {
    SI_ASYNCNL___27 = -60,
    SI_DETHREAD___27 = -7,
    SI_TKILL___27 = -6,
    SI_SIGIO___27 = -5,
    SI_ASYNCIO___27 = -4,
    SI_MESGQ___27 = -3,
    SI_TIMER___27 = -2,
    SI_QUEUE___27 = -1,
    SI_USER___27 = 0,
    SI_KERNEL___27 = 128
} ;
#line 71
enum __anonenum__326___9 {
    ILL_ILLOPC___27 = 1,
    ILL_ILLOPN___27 = 2,
    ILL_ILLADR___27 = 3,
    ILL_ILLTRP___27 = 4,
    ILL_PRVOPC___27 = 5,
    ILL_PRVREG___27 = 6,
    ILL_COPROC___27 = 7,
    ILL_BADSTK___27 = 8,
    ILL_BADIADDR___27 = 9
} ;
#line 94
enum __anonenum__327___9 {
    FPE_INTDIV___27 = 1,
    FPE_INTOVF___27 = 2,
    FPE_FLTDIV___27 = 3,
    FPE_FLTOVF___27 = 4,
    FPE_FLTUND___27 = 5,
    FPE_FLTRES___27 = 6,
    FPE_FLTINV___27 = 7,
    FPE_FLTSUB___27 = 8,
    FPE_FLTUNK___27 = 14,
    FPE_CONDTRAP___27 = 15
} ;
#line 119
enum __anonenum__328___9 {
    SEGV_MAPERR___27 = 1,
    SEGV_ACCERR___27 = 2,
    SEGV_BNDERR___27 = 3,
    SEGV_PKUERR___27 = 4,
    SEGV_ACCADI___27 = 5,
    SEGV_ADIDERR___27 = 6,
    SEGV_ADIPERR___27 = 7,
    SEGV_MTEAERR___27 = 8,
    SEGV_MTESERR___27 = 9
} ;
#line 142
enum __anonenum__329___9 {
    BUS_ADRALN___27 = 1,
    BUS_ADRERR___27 = 2,
    BUS_OBJERR___27 = 3,
    BUS_MCEERR_AR___27 = 4,
    BUS_MCEERR_AO___27 = 5
} ;
#line 176
enum __anonenum__330___9 {
    CLD_EXITED___27 = 1,
    CLD_KILLED___27 = 2,
    CLD_DUMPED___27 = 3,
    CLD_TRAPPED___27 = 4,
    CLD_STOPPED___27 = 5,
    CLD_CONTINUED___27 = 6
} ;
#line 193
enum __anonenum__331___9 {
    POLL_IN___27 = 1,
    POLL_OUT___27 = 2,
    POLL_MSG___27 = 3,
    POLL_ERR___27 = 4,
    POLL_PRI___27 = 5,
    POLL_HUP___27 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__334___9 {
    SIGEV_SIGNAL___27 = 0,
    SIGEV_NONE___27 = 1,
    SIGEV_THREAD___27 = 2,
    SIGEV_THREAD_ID___27 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__339___9 {
    SS_ONSTACK___27 = 1,
    SS_DISABLE___27 = 2
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__347___9 {
    DT_UNKNOWN___27 = 0,
    DT_FIFO___27 = 1,
    DT_CHR___27 = 2,
    DT_DIR___27 = 4,
    DT_BLK___27 = 6,
    DT_REG___27 = 8,
    DT_LNK___27 = 10,
    DT_SOCK___27 = 12,
    DT_WHT___27 = 14
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__406___9 {
    PTHREAD_CREATE_JOINABLE___27 = 0,
    PTHREAD_CREATE_DETACHED___27 = 1
} ;
#line 47
enum __anonenum__407___9 {
    PTHREAD_MUTEX_TIMED_NP___27 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___27 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___27 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___27 = 3,
    PTHREAD_MUTEX_NORMAL___27 = 0,
    PTHREAD_MUTEX_RECURSIVE___27 = 1,
    PTHREAD_MUTEX_ERRORCHECK___27 = 2,
    PTHREAD_MUTEX_DEFAULT___27 = 0
} ;
#line 69
enum __anonenum__408___9 {
    PTHREAD_MUTEX_STALLED___27 = 0,
    PTHREAD_MUTEX_STALLED_NP___27 = 0,
    PTHREAD_MUTEX_ROBUST___27 = 1,
    PTHREAD_MUTEX_ROBUST_NP___27 = 1
} ;
#line 81
enum __anonenum__409___12 {
    PTHREAD_PRIO_NONE___27 = 0,
    PTHREAD_PRIO_INHERIT___27 = 1,
    PTHREAD_PRIO_PROTECT___27 = 2
} ;
#line 104
enum __anonenum__410___9 {
    PTHREAD_RWLOCK_PREFER_READER_NP___27 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___27 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___27 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___27 = 0
} ;
#line 124
enum __anonenum__411___9 {
    PTHREAD_INHERIT_SCHED___27 = 0,
    PTHREAD_EXPLICIT_SCHED___27 = 1
} ;
#line 134
enum __anonenum__412___9 {
    PTHREAD_SCOPE_SYSTEM___27 = 0,
    PTHREAD_SCOPE_PROCESS___27 = 1
} ;
#line 144
enum __anonenum__413___9 {
    PTHREAD_PROCESS_PRIVATE___27 = 0,
    PTHREAD_PROCESS_SHARED___27 = 1
} ;
#line 168
enum __anonenum__414___9 {
    PTHREAD_CANCEL_ENABLE___27 = 0,
    PTHREAD_CANCEL_DISABLE___27 = 1
} ;
#line 175
enum __anonenum__415___9 {
    PTHREAD_CANCEL_DEFERRED___27 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___27 = 1
} ;
#line 78 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-emf.c"
struct EMFColorListType {
   uint32_t colref ;
   struct EMFColorListType *next ;
};
#line 81 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-emf.c"
typedef struct EMFColorListType EMFColorList;
#line 85 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-emf.c"
struct __anonstruct_1281 {
   int ncolors ;
   int nrecords ;
   int filesize ;
};
#line 89 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-emf.c"
typedef struct __anonstruct_1281 EMFStats;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__607___8 {
    SI_ASYNCNL___28 = -60,
    SI_DETHREAD___28 = -7,
    SI_TKILL___28 = -6,
    SI_SIGIO___28 = -5,
    SI_ASYNCIO___28 = -4,
    SI_MESGQ___28 = -3,
    SI_TIMER___28 = -2,
    SI_QUEUE___28 = -1,
    SI_USER___28 = 0,
    SI_KERNEL___28 = 128
} ;
#line 71
enum __anonenum__608___8 {
    ILL_ILLOPC___28 = 1,
    ILL_ILLOPN___28 = 2,
    ILL_ILLADR___28 = 3,
    ILL_ILLTRP___28 = 4,
    ILL_PRVOPC___28 = 5,
    ILL_PRVREG___28 = 6,
    ILL_COPROC___28 = 7,
    ILL_BADSTK___28 = 8,
    ILL_BADIADDR___28 = 9
} ;
#line 94
enum __anonenum__609___8 {
    FPE_INTDIV___28 = 1,
    FPE_INTOVF___28 = 2,
    FPE_FLTDIV___28 = 3,
    FPE_FLTOVF___28 = 4,
    FPE_FLTUND___28 = 5,
    FPE_FLTRES___28 = 6,
    FPE_FLTINV___28 = 7,
    FPE_FLTSUB___28 = 8,
    FPE_FLTUNK___28 = 14,
    FPE_CONDTRAP___28 = 15
} ;
#line 119
enum __anonenum__610___8 {
    SEGV_MAPERR___28 = 1,
    SEGV_ACCERR___28 = 2,
    SEGV_BNDERR___28 = 3,
    SEGV_PKUERR___28 = 4,
    SEGV_ACCADI___28 = 5,
    SEGV_ADIDERR___28 = 6,
    SEGV_ADIPERR___28 = 7,
    SEGV_MTEAERR___28 = 8,
    SEGV_MTESERR___28 = 9
} ;
#line 142
enum __anonenum__611___8 {
    BUS_ADRALN___28 = 1,
    BUS_ADRERR___28 = 2,
    BUS_OBJERR___28 = 3,
    BUS_MCEERR_AR___28 = 4,
    BUS_MCEERR_AO___28 = 5
} ;
#line 176
enum __anonenum__612___8 {
    CLD_EXITED___28 = 1,
    CLD_KILLED___28 = 2,
    CLD_DUMPED___28 = 3,
    CLD_TRAPPED___28 = 4,
    CLD_STOPPED___28 = 5,
    CLD_CONTINUED___28 = 6
} ;
#line 193
enum __anonenum__613___8 {
    POLL_IN___28 = 1,
    POLL_OUT___28 = 2,
    POLL_MSG___28 = 3,
    POLL_ERR___28 = 4,
    POLL_PRI___28 = 5,
    POLL_HUP___28 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__616___8 {
    SIGEV_SIGNAL___28 = 0,
    SIGEV_NONE___28 = 1,
    SIGEV_THREAD___28 = 2,
    SIGEV_THREAD_ID___28 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__621___8 {
    SS_ONSTACK___28 = 1,
    SS_DISABLE___28 = 2
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__629___8 {
    DT_UNKNOWN___28 = 0,
    DT_FIFO___28 = 1,
    DT_CHR___28 = 2,
    DT_DIR___28 = 4,
    DT_BLK___28 = 6,
    DT_REG___28 = 8,
    DT_LNK___28 = 10,
    DT_SOCK___28 = 12,
    DT_WHT___28 = 14
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__688___8 {
    PTHREAD_CREATE_JOINABLE___28 = 0,
    PTHREAD_CREATE_DETACHED___28 = 1
} ;
#line 47
enum __anonenum__689___8 {
    PTHREAD_MUTEX_TIMED_NP___28 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___28 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___28 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___28 = 3,
    PTHREAD_MUTEX_NORMAL___28 = 0,
    PTHREAD_MUTEX_RECURSIVE___28 = 1,
    PTHREAD_MUTEX_ERRORCHECK___28 = 2,
    PTHREAD_MUTEX_DEFAULT___28 = 0
} ;
#line 69
enum __anonenum__690___8 {
    PTHREAD_MUTEX_STALLED___28 = 0,
    PTHREAD_MUTEX_STALLED_NP___28 = 0,
    PTHREAD_MUTEX_ROBUST___28 = 1,
    PTHREAD_MUTEX_ROBUST_NP___28 = 1
} ;
#line 81
enum __anonenum__691___8 {
    PTHREAD_PRIO_NONE___28 = 0,
    PTHREAD_PRIO_INHERIT___28 = 1,
    PTHREAD_PRIO_PROTECT___28 = 2
} ;
#line 104
enum __anonenum__692___8 {
    PTHREAD_RWLOCK_PREFER_READER_NP___28 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___28 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___28 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___28 = 0
} ;
#line 124
enum __anonenum__693___8 {
    PTHREAD_INHERIT_SCHED___28 = 0,
    PTHREAD_EXPLICIT_SCHED___28 = 1
} ;
#line 134
enum __anonenum__694___8 {
    PTHREAD_SCOPE_SYSTEM___28 = 0,
    PTHREAD_SCOPE_PROCESS___28 = 1
} ;
#line 144
enum __anonenum__695___8 {
    PTHREAD_PROCESS_PRIVATE___28 = 0,
    PTHREAD_PROCESS_SHARED___28 = 1
} ;
#line 168
enum __anonenum__696___8 {
    PTHREAD_CANCEL_ENABLE___28 = 0,
    PTHREAD_CANCEL_DISABLE___28 = 1
} ;
#line 175
enum __anonenum__697___8 {
    PTHREAD_CANCEL_DEFERRED___28 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___28 = 1
} ;
#line 934 "/usr/include/math.h"
enum __anonenum__1274___0 {
    FP_NAN___10 = 0,
    FP_INFINITE___10 = 1,
    FP_ZERO___10 = 2,
    FP_SUBNORMAL___10 = 3,
    FP_NORMAL___10 = 4
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__325___10 {
    SI_ASYNCNL___29 = -60,
    SI_DETHREAD___29 = -7,
    SI_TKILL___29 = -6,
    SI_SIGIO___29 = -5,
    SI_ASYNCIO___29 = -4,
    SI_MESGQ___29 = -3,
    SI_TIMER___29 = -2,
    SI_QUEUE___29 = -1,
    SI_USER___29 = 0,
    SI_KERNEL___29 = 128
} ;
#line 71
enum __anonenum__326___10 {
    ILL_ILLOPC___29 = 1,
    ILL_ILLOPN___29 = 2,
    ILL_ILLADR___29 = 3,
    ILL_ILLTRP___29 = 4,
    ILL_PRVOPC___29 = 5,
    ILL_PRVREG___29 = 6,
    ILL_COPROC___29 = 7,
    ILL_BADSTK___29 = 8,
    ILL_BADIADDR___29 = 9
} ;
#line 94
enum __anonenum__327___10 {
    FPE_INTDIV___29 = 1,
    FPE_INTOVF___29 = 2,
    FPE_FLTDIV___29 = 3,
    FPE_FLTOVF___29 = 4,
    FPE_FLTUND___29 = 5,
    FPE_FLTRES___29 = 6,
    FPE_FLTINV___29 = 7,
    FPE_FLTSUB___29 = 8,
    FPE_FLTUNK___29 = 14,
    FPE_CONDTRAP___29 = 15
} ;
#line 119
enum __anonenum__328___10 {
    SEGV_MAPERR___29 = 1,
    SEGV_ACCERR___29 = 2,
    SEGV_BNDERR___29 = 3,
    SEGV_PKUERR___29 = 4,
    SEGV_ACCADI___29 = 5,
    SEGV_ADIDERR___29 = 6,
    SEGV_ADIPERR___29 = 7,
    SEGV_MTEAERR___29 = 8,
    SEGV_MTESERR___29 = 9
} ;
#line 142
enum __anonenum__329___10 {
    BUS_ADRALN___29 = 1,
    BUS_ADRERR___29 = 2,
    BUS_OBJERR___29 = 3,
    BUS_MCEERR_AR___29 = 4,
    BUS_MCEERR_AO___29 = 5
} ;
#line 176
enum __anonenum__330___10 {
    CLD_EXITED___29 = 1,
    CLD_KILLED___29 = 2,
    CLD_DUMPED___29 = 3,
    CLD_TRAPPED___29 = 4,
    CLD_STOPPED___29 = 5,
    CLD_CONTINUED___29 = 6
} ;
#line 193
enum __anonenum__331___10 {
    POLL_IN___29 = 1,
    POLL_OUT___29 = 2,
    POLL_MSG___29 = 3,
    POLL_ERR___29 = 4,
    POLL_PRI___29 = 5,
    POLL_HUP___29 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__334___10 {
    SIGEV_SIGNAL___29 = 0,
    SIGEV_NONE___29 = 1,
    SIGEV_THREAD___29 = 2,
    SIGEV_THREAD_ID___29 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__339___10 {
    SS_ONSTACK___29 = 1,
    SS_DISABLE___29 = 2
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__347___10 {
    DT_UNKNOWN___29 = 0,
    DT_FIFO___29 = 1,
    DT_CHR___29 = 2,
    DT_DIR___29 = 4,
    DT_BLK___29 = 6,
    DT_REG___29 = 8,
    DT_LNK___29 = 10,
    DT_SOCK___29 = 12,
    DT_WHT___29 = 14
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__406___10 {
    PTHREAD_CREATE_JOINABLE___29 = 0,
    PTHREAD_CREATE_DETACHED___29 = 1
} ;
#line 47
enum __anonenum__407___10 {
    PTHREAD_MUTEX_TIMED_NP___29 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___29 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___29 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___29 = 3,
    PTHREAD_MUTEX_NORMAL___29 = 0,
    PTHREAD_MUTEX_RECURSIVE___29 = 1,
    PTHREAD_MUTEX_ERRORCHECK___29 = 2,
    PTHREAD_MUTEX_DEFAULT___29 = 0
} ;
#line 69
enum __anonenum__408___10 {
    PTHREAD_MUTEX_STALLED___29 = 0,
    PTHREAD_MUTEX_STALLED_NP___29 = 0,
    PTHREAD_MUTEX_ROBUST___29 = 1,
    PTHREAD_MUTEX_ROBUST_NP___29 = 1
} ;
#line 81
enum __anonenum__409___13 {
    PTHREAD_PRIO_NONE___29 = 0,
    PTHREAD_PRIO_INHERIT___29 = 1,
    PTHREAD_PRIO_PROTECT___29 = 2
} ;
#line 104
enum __anonenum__410___10 {
    PTHREAD_RWLOCK_PREFER_READER_NP___29 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___29 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___29 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___29 = 0
} ;
#line 124
enum __anonenum__411___10 {
    PTHREAD_INHERIT_SCHED___29 = 0,
    PTHREAD_EXPLICIT_SCHED___29 = 1
} ;
#line 134
enum __anonenum__412___10 {
    PTHREAD_SCOPE_SYSTEM___29 = 0,
    PTHREAD_SCOPE_PROCESS___29 = 1
} ;
#line 144
enum __anonenum__413___10 {
    PTHREAD_PROCESS_PRIVATE___29 = 0,
    PTHREAD_PROCESS_SHARED___29 = 1
} ;
#line 168
enum __anonenum__414___10 {
    PTHREAD_CANCEL_ENABLE___29 = 0,
    PTHREAD_CANCEL_DISABLE___29 = 1
} ;
#line 175
enum __anonenum__415___10 {
    PTHREAD_CANCEL_DEFERRED___29 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___29 = 1
} ;
#line 934 "/usr/include/math.h"
enum __anonenum__1282 {
    FP_NAN___11 = 0,
    FP_INFINITE___11 = 1,
    FP_ZERO___11 = 2,
    FP_SUBNORMAL___11 = 3,
    FP_NORMAL___11 = 4
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__325___11 {
    SI_ASYNCNL___30 = -60,
    SI_DETHREAD___30 = -7,
    SI_TKILL___30 = -6,
    SI_SIGIO___30 = -5,
    SI_ASYNCIO___30 = -4,
    SI_MESGQ___30 = -3,
    SI_TIMER___30 = -2,
    SI_QUEUE___30 = -1,
    SI_USER___30 = 0,
    SI_KERNEL___30 = 128
} ;
#line 71
enum __anonenum__326___11 {
    ILL_ILLOPC___30 = 1,
    ILL_ILLOPN___30 = 2,
    ILL_ILLADR___30 = 3,
    ILL_ILLTRP___30 = 4,
    ILL_PRVOPC___30 = 5,
    ILL_PRVREG___30 = 6,
    ILL_COPROC___30 = 7,
    ILL_BADSTK___30 = 8,
    ILL_BADIADDR___30 = 9
} ;
#line 94
enum __anonenum__327___11 {
    FPE_INTDIV___30 = 1,
    FPE_INTOVF___30 = 2,
    FPE_FLTDIV___30 = 3,
    FPE_FLTOVF___30 = 4,
    FPE_FLTUND___30 = 5,
    FPE_FLTRES___30 = 6,
    FPE_FLTINV___30 = 7,
    FPE_FLTSUB___30 = 8,
    FPE_FLTUNK___30 = 14,
    FPE_CONDTRAP___30 = 15
} ;
#line 119
enum __anonenum__328___11 {
    SEGV_MAPERR___30 = 1,
    SEGV_ACCERR___30 = 2,
    SEGV_BNDERR___30 = 3,
    SEGV_PKUERR___30 = 4,
    SEGV_ACCADI___30 = 5,
    SEGV_ADIDERR___30 = 6,
    SEGV_ADIPERR___30 = 7,
    SEGV_MTEAERR___30 = 8,
    SEGV_MTESERR___30 = 9
} ;
#line 142
enum __anonenum__329___11 {
    BUS_ADRALN___30 = 1,
    BUS_ADRERR___30 = 2,
    BUS_OBJERR___30 = 3,
    BUS_MCEERR_AR___30 = 4,
    BUS_MCEERR_AO___30 = 5
} ;
#line 176
enum __anonenum__330___11 {
    CLD_EXITED___30 = 1,
    CLD_KILLED___30 = 2,
    CLD_DUMPED___30 = 3,
    CLD_TRAPPED___30 = 4,
    CLD_STOPPED___30 = 5,
    CLD_CONTINUED___30 = 6
} ;
#line 193
enum __anonenum__331___11 {
    POLL_IN___30 = 1,
    POLL_OUT___30 = 2,
    POLL_MSG___30 = 3,
    POLL_ERR___30 = 4,
    POLL_PRI___30 = 5,
    POLL_HUP___30 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__334___11 {
    SIGEV_SIGNAL___30 = 0,
    SIGEV_NONE___30 = 1,
    SIGEV_THREAD___30 = 2,
    SIGEV_THREAD_ID___30 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__339___11 {
    SS_ONSTACK___30 = 1,
    SS_DISABLE___30 = 2
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__347___11 {
    DT_UNKNOWN___30 = 0,
    DT_FIFO___30 = 1,
    DT_CHR___30 = 2,
    DT_DIR___30 = 4,
    DT_BLK___30 = 6,
    DT_REG___30 = 8,
    DT_LNK___30 = 10,
    DT_SOCK___30 = 12,
    DT_WHT___30 = 14
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__406___11 {
    PTHREAD_CREATE_JOINABLE___30 = 0,
    PTHREAD_CREATE_DETACHED___30 = 1
} ;
#line 47
enum __anonenum__407___11 {
    PTHREAD_MUTEX_TIMED_NP___30 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___30 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___30 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___30 = 3,
    PTHREAD_MUTEX_NORMAL___30 = 0,
    PTHREAD_MUTEX_RECURSIVE___30 = 1,
    PTHREAD_MUTEX_ERRORCHECK___30 = 2,
    PTHREAD_MUTEX_DEFAULT___30 = 0
} ;
#line 69
enum __anonenum__408___11 {
    PTHREAD_MUTEX_STALLED___30 = 0,
    PTHREAD_MUTEX_STALLED_NP___30 = 0,
    PTHREAD_MUTEX_ROBUST___30 = 1,
    PTHREAD_MUTEX_ROBUST_NP___30 = 1
} ;
#line 81
enum __anonenum__409___14 {
    PTHREAD_PRIO_NONE___30 = 0,
    PTHREAD_PRIO_INHERIT___30 = 1,
    PTHREAD_PRIO_PROTECT___30 = 2
} ;
#line 104
enum __anonenum__410___11 {
    PTHREAD_RWLOCK_PREFER_READER_NP___30 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___30 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___30 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___30 = 0
} ;
#line 124
enum __anonenum__411___11 {
    PTHREAD_INHERIT_SCHED___30 = 0,
    PTHREAD_EXPLICIT_SCHED___30 = 1
} ;
#line 134
enum __anonenum__412___11 {
    PTHREAD_SCOPE_SYSTEM___30 = 0,
    PTHREAD_SCOPE_PROCESS___30 = 1
} ;
#line 144
enum __anonenum__413___11 {
    PTHREAD_PROCESS_PRIVATE___30 = 0,
    PTHREAD_PROCESS_SHARED___30 = 1
} ;
#line 168
enum __anonenum__414___11 {
    PTHREAD_CANCEL_ENABLE___30 = 0,
    PTHREAD_CANCEL_DISABLE___30 = 1
} ;
#line 175
enum __anonenum__415___11 {
    PTHREAD_CANCEL_DEFERRED___30 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___30 = 1
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__325___12 {
    SI_ASYNCNL___31 = -60,
    SI_DETHREAD___31 = -7,
    SI_TKILL___31 = -6,
    SI_SIGIO___31 = -5,
    SI_ASYNCIO___31 = -4,
    SI_MESGQ___31 = -3,
    SI_TIMER___31 = -2,
    SI_QUEUE___31 = -1,
    SI_USER___31 = 0,
    SI_KERNEL___31 = 128
} ;
#line 71
enum __anonenum__326___12 {
    ILL_ILLOPC___31 = 1,
    ILL_ILLOPN___31 = 2,
    ILL_ILLADR___31 = 3,
    ILL_ILLTRP___31 = 4,
    ILL_PRVOPC___31 = 5,
    ILL_PRVREG___31 = 6,
    ILL_COPROC___31 = 7,
    ILL_BADSTK___31 = 8,
    ILL_BADIADDR___31 = 9
} ;
#line 94
enum __anonenum__327___12 {
    FPE_INTDIV___31 = 1,
    FPE_INTOVF___31 = 2,
    FPE_FLTDIV___31 = 3,
    FPE_FLTOVF___31 = 4,
    FPE_FLTUND___31 = 5,
    FPE_FLTRES___31 = 6,
    FPE_FLTINV___31 = 7,
    FPE_FLTSUB___31 = 8,
    FPE_FLTUNK___31 = 14,
    FPE_CONDTRAP___31 = 15
} ;
#line 119
enum __anonenum__328___12 {
    SEGV_MAPERR___31 = 1,
    SEGV_ACCERR___31 = 2,
    SEGV_BNDERR___31 = 3,
    SEGV_PKUERR___31 = 4,
    SEGV_ACCADI___31 = 5,
    SEGV_ADIDERR___31 = 6,
    SEGV_ADIPERR___31 = 7,
    SEGV_MTEAERR___31 = 8,
    SEGV_MTESERR___31 = 9
} ;
#line 142
enum __anonenum__329___12 {
    BUS_ADRALN___31 = 1,
    BUS_ADRERR___31 = 2,
    BUS_OBJERR___31 = 3,
    BUS_MCEERR_AR___31 = 4,
    BUS_MCEERR_AO___31 = 5
} ;
#line 176
enum __anonenum__330___12 {
    CLD_EXITED___31 = 1,
    CLD_KILLED___31 = 2,
    CLD_DUMPED___31 = 3,
    CLD_TRAPPED___31 = 4,
    CLD_STOPPED___31 = 5,
    CLD_CONTINUED___31 = 6
} ;
#line 193
enum __anonenum__331___12 {
    POLL_IN___31 = 1,
    POLL_OUT___31 = 2,
    POLL_MSG___31 = 3,
    POLL_ERR___31 = 4,
    POLL_PRI___31 = 5,
    POLL_HUP___31 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__334___12 {
    SIGEV_SIGNAL___31 = 0,
    SIGEV_NONE___31 = 1,
    SIGEV_THREAD___31 = 2,
    SIGEV_THREAD_ID___31 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__339___12 {
    SS_ONSTACK___31 = 1,
    SS_DISABLE___31 = 2
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__347___12 {
    DT_UNKNOWN___31 = 0,
    DT_FIFO___31 = 1,
    DT_CHR___31 = 2,
    DT_DIR___31 = 4,
    DT_BLK___31 = 6,
    DT_REG___31 = 8,
    DT_LNK___31 = 10,
    DT_SOCK___31 = 12,
    DT_WHT___31 = 14
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__406___12 {
    PTHREAD_CREATE_JOINABLE___31 = 0,
    PTHREAD_CREATE_DETACHED___31 = 1
} ;
#line 47
enum __anonenum__407___12 {
    PTHREAD_MUTEX_TIMED_NP___31 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___31 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___31 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___31 = 3,
    PTHREAD_MUTEX_NORMAL___31 = 0,
    PTHREAD_MUTEX_RECURSIVE___31 = 1,
    PTHREAD_MUTEX_ERRORCHECK___31 = 2,
    PTHREAD_MUTEX_DEFAULT___31 = 0
} ;
#line 69
enum __anonenum__408___12 {
    PTHREAD_MUTEX_STALLED___31 = 0,
    PTHREAD_MUTEX_STALLED_NP___31 = 0,
    PTHREAD_MUTEX_ROBUST___31 = 1,
    PTHREAD_MUTEX_ROBUST_NP___31 = 1
} ;
#line 81
enum __anonenum__409___15 {
    PTHREAD_PRIO_NONE___31 = 0,
    PTHREAD_PRIO_INHERIT___31 = 1,
    PTHREAD_PRIO_PROTECT___31 = 2
} ;
#line 104
enum __anonenum__410___12 {
    PTHREAD_RWLOCK_PREFER_READER_NP___31 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___31 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___31 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___31 = 0
} ;
#line 124
enum __anonenum__411___12 {
    PTHREAD_INHERIT_SCHED___31 = 0,
    PTHREAD_EXPLICIT_SCHED___31 = 1
} ;
#line 134
enum __anonenum__412___12 {
    PTHREAD_SCOPE_SYSTEM___31 = 0,
    PTHREAD_SCOPE_PROCESS___31 = 1
} ;
#line 144
enum __anonenum__413___12 {
    PTHREAD_PROCESS_PRIVATE___31 = 0,
    PTHREAD_PROCESS_SHARED___31 = 1
} ;
#line 168
enum __anonenum__414___12 {
    PTHREAD_CANCEL_ENABLE___31 = 0,
    PTHREAD_CANCEL_DISABLE___31 = 1
} ;
#line 175
enum __anonenum__415___12 {
    PTHREAD_CANCEL_DEFERRED___31 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___31 = 1
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__325___13 {
    SI_ASYNCNL___32 = -60,
    SI_DETHREAD___32 = -7,
    SI_TKILL___32 = -6,
    SI_SIGIO___32 = -5,
    SI_ASYNCIO___32 = -4,
    SI_MESGQ___32 = -3,
    SI_TIMER___32 = -2,
    SI_QUEUE___32 = -1,
    SI_USER___32 = 0,
    SI_KERNEL___32 = 128
} ;
#line 71
enum __anonenum__326___13 {
    ILL_ILLOPC___32 = 1,
    ILL_ILLOPN___32 = 2,
    ILL_ILLADR___32 = 3,
    ILL_ILLTRP___32 = 4,
    ILL_PRVOPC___32 = 5,
    ILL_PRVREG___32 = 6,
    ILL_COPROC___32 = 7,
    ILL_BADSTK___32 = 8,
    ILL_BADIADDR___32 = 9
} ;
#line 94
enum __anonenum__327___13 {
    FPE_INTDIV___32 = 1,
    FPE_INTOVF___32 = 2,
    FPE_FLTDIV___32 = 3,
    FPE_FLTOVF___32 = 4,
    FPE_FLTUND___32 = 5,
    FPE_FLTRES___32 = 6,
    FPE_FLTINV___32 = 7,
    FPE_FLTSUB___32 = 8,
    FPE_FLTUNK___32 = 14,
    FPE_CONDTRAP___32 = 15
} ;
#line 119
enum __anonenum__328___13 {
    SEGV_MAPERR___32 = 1,
    SEGV_ACCERR___32 = 2,
    SEGV_BNDERR___32 = 3,
    SEGV_PKUERR___32 = 4,
    SEGV_ACCADI___32 = 5,
    SEGV_ADIDERR___32 = 6,
    SEGV_ADIPERR___32 = 7,
    SEGV_MTEAERR___32 = 8,
    SEGV_MTESERR___32 = 9
} ;
#line 142
enum __anonenum__329___13 {
    BUS_ADRALN___32 = 1,
    BUS_ADRERR___32 = 2,
    BUS_OBJERR___32 = 3,
    BUS_MCEERR_AR___32 = 4,
    BUS_MCEERR_AO___32 = 5
} ;
#line 176
enum __anonenum__330___13 {
    CLD_EXITED___32 = 1,
    CLD_KILLED___32 = 2,
    CLD_DUMPED___32 = 3,
    CLD_TRAPPED___32 = 4,
    CLD_STOPPED___32 = 5,
    CLD_CONTINUED___32 = 6
} ;
#line 193
enum __anonenum__331___13 {
    POLL_IN___32 = 1,
    POLL_OUT___32 = 2,
    POLL_MSG___32 = 3,
    POLL_ERR___32 = 4,
    POLL_PRI___32 = 5,
    POLL_HUP___32 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__334___13 {
    SIGEV_SIGNAL___32 = 0,
    SIGEV_NONE___32 = 1,
    SIGEV_THREAD___32 = 2,
    SIGEV_THREAD_ID___32 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__339___13 {
    SS_ONSTACK___32 = 1,
    SS_DISABLE___32 = 2
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__347___13 {
    DT_UNKNOWN___32 = 0,
    DT_FIFO___32 = 1,
    DT_CHR___32 = 2,
    DT_DIR___32 = 4,
    DT_BLK___32 = 6,
    DT_REG___32 = 8,
    DT_LNK___32 = 10,
    DT_SOCK___32 = 12,
    DT_WHT___32 = 14
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__406___13 {
    PTHREAD_CREATE_JOINABLE___32 = 0,
    PTHREAD_CREATE_DETACHED___32 = 1
} ;
#line 47
enum __anonenum__407___13 {
    PTHREAD_MUTEX_TIMED_NP___32 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___32 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___32 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___32 = 3,
    PTHREAD_MUTEX_NORMAL___32 = 0,
    PTHREAD_MUTEX_RECURSIVE___32 = 1,
    PTHREAD_MUTEX_ERRORCHECK___32 = 2,
    PTHREAD_MUTEX_DEFAULT___32 = 0
} ;
#line 69
enum __anonenum__408___13 {
    PTHREAD_MUTEX_STALLED___32 = 0,
    PTHREAD_MUTEX_STALLED_NP___32 = 0,
    PTHREAD_MUTEX_ROBUST___32 = 1,
    PTHREAD_MUTEX_ROBUST_NP___32 = 1
} ;
#line 81
enum __anonenum__409___16 {
    PTHREAD_PRIO_NONE___32 = 0,
    PTHREAD_PRIO_INHERIT___32 = 1,
    PTHREAD_PRIO_PROTECT___32 = 2
} ;
#line 104
enum __anonenum__410___13 {
    PTHREAD_RWLOCK_PREFER_READER_NP___32 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___32 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___32 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___32 = 0
} ;
#line 124
enum __anonenum__411___13 {
    PTHREAD_INHERIT_SCHED___32 = 0,
    PTHREAD_EXPLICIT_SCHED___32 = 1
} ;
#line 134
enum __anonenum__412___13 {
    PTHREAD_SCOPE_SYSTEM___32 = 0,
    PTHREAD_SCOPE_PROCESS___32 = 1
} ;
#line 144
enum __anonenum__413___13 {
    PTHREAD_PROCESS_PRIVATE___32 = 0,
    PTHREAD_PROCESS_SHARED___32 = 1
} ;
#line 168
enum __anonenum__414___13 {
    PTHREAD_CANCEL_ENABLE___32 = 0,
    PTHREAD_CANCEL_DISABLE___32 = 1
} ;
#line 175
enum __anonenum__415___13 {
    PTHREAD_CANCEL_DEFERRED___32 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___32 = 1
} ;
#line 55 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-fig.c"
struct __anonstruct_1283 {
   unsigned int colour ;
   unsigned int alternate ;
};
#line 60 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-fig.c"
struct __anonstruct_1284 {
   at_color c ;
   int alternate ;
};
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__607___9 {
    SI_ASYNCNL___33 = -60,
    SI_DETHREAD___33 = -7,
    SI_TKILL___33 = -6,
    SI_SIGIO___33 = -5,
    SI_ASYNCIO___33 = -4,
    SI_MESGQ___33 = -3,
    SI_TIMER___33 = -2,
    SI_QUEUE___33 = -1,
    SI_USER___33 = 0,
    SI_KERNEL___33 = 128
} ;
#line 71
enum __anonenum__608___9 {
    ILL_ILLOPC___33 = 1,
    ILL_ILLOPN___33 = 2,
    ILL_ILLADR___33 = 3,
    ILL_ILLTRP___33 = 4,
    ILL_PRVOPC___33 = 5,
    ILL_PRVREG___33 = 6,
    ILL_COPROC___33 = 7,
    ILL_BADSTK___33 = 8,
    ILL_BADIADDR___33 = 9
} ;
#line 94
enum __anonenum__609___9 {
    FPE_INTDIV___33 = 1,
    FPE_INTOVF___33 = 2,
    FPE_FLTDIV___33 = 3,
    FPE_FLTOVF___33 = 4,
    FPE_FLTUND___33 = 5,
    FPE_FLTRES___33 = 6,
    FPE_FLTINV___33 = 7,
    FPE_FLTSUB___33 = 8,
    FPE_FLTUNK___33 = 14,
    FPE_CONDTRAP___33 = 15
} ;
#line 119
enum __anonenum__610___9 {
    SEGV_MAPERR___33 = 1,
    SEGV_ACCERR___33 = 2,
    SEGV_BNDERR___33 = 3,
    SEGV_PKUERR___33 = 4,
    SEGV_ACCADI___33 = 5,
    SEGV_ADIDERR___33 = 6,
    SEGV_ADIPERR___33 = 7,
    SEGV_MTEAERR___33 = 8,
    SEGV_MTESERR___33 = 9
} ;
#line 142
enum __anonenum__611___9 {
    BUS_ADRALN___33 = 1,
    BUS_ADRERR___33 = 2,
    BUS_OBJERR___33 = 3,
    BUS_MCEERR_AR___33 = 4,
    BUS_MCEERR_AO___33 = 5
} ;
#line 176
enum __anonenum__612___9 {
    CLD_EXITED___33 = 1,
    CLD_KILLED___33 = 2,
    CLD_DUMPED___33 = 3,
    CLD_TRAPPED___33 = 4,
    CLD_STOPPED___33 = 5,
    CLD_CONTINUED___33 = 6
} ;
#line 193
enum __anonenum__613___9 {
    POLL_IN___33 = 1,
    POLL_OUT___33 = 2,
    POLL_MSG___33 = 3,
    POLL_ERR___33 = 4,
    POLL_PRI___33 = 5,
    POLL_HUP___33 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__616___9 {
    SIGEV_SIGNAL___33 = 0,
    SIGEV_NONE___33 = 1,
    SIGEV_THREAD___33 = 2,
    SIGEV_THREAD_ID___33 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__621___9 {
    SS_ONSTACK___33 = 1,
    SS_DISABLE___33 = 2
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__629___9 {
    DT_UNKNOWN___33 = 0,
    DT_FIFO___33 = 1,
    DT_CHR___33 = 2,
    DT_DIR___33 = 4,
    DT_BLK___33 = 6,
    DT_REG___33 = 8,
    DT_LNK___33 = 10,
    DT_SOCK___33 = 12,
    DT_WHT___33 = 14
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__688___9 {
    PTHREAD_CREATE_JOINABLE___33 = 0,
    PTHREAD_CREATE_DETACHED___33 = 1
} ;
#line 47
enum __anonenum__689___9 {
    PTHREAD_MUTEX_TIMED_NP___33 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___33 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___33 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___33 = 3,
    PTHREAD_MUTEX_NORMAL___33 = 0,
    PTHREAD_MUTEX_RECURSIVE___33 = 1,
    PTHREAD_MUTEX_ERRORCHECK___33 = 2,
    PTHREAD_MUTEX_DEFAULT___33 = 0
} ;
#line 69
enum __anonenum__690___9 {
    PTHREAD_MUTEX_STALLED___33 = 0,
    PTHREAD_MUTEX_STALLED_NP___33 = 0,
    PTHREAD_MUTEX_ROBUST___33 = 1,
    PTHREAD_MUTEX_ROBUST_NP___33 = 1
} ;
#line 81
enum __anonenum__691___9 {
    PTHREAD_PRIO_NONE___33 = 0,
    PTHREAD_PRIO_INHERIT___33 = 1,
    PTHREAD_PRIO_PROTECT___33 = 2
} ;
#line 104
enum __anonenum__692___9 {
    PTHREAD_RWLOCK_PREFER_READER_NP___33 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___33 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___33 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___33 = 0
} ;
#line 124
enum __anonenum__693___9 {
    PTHREAD_INHERIT_SCHED___33 = 0,
    PTHREAD_EXPLICIT_SCHED___33 = 1
} ;
#line 134
enum __anonenum__694___9 {
    PTHREAD_SCOPE_SYSTEM___33 = 0,
    PTHREAD_SCOPE_PROCESS___33 = 1
} ;
#line 144
enum __anonenum__695___9 {
    PTHREAD_PROCESS_PRIVATE___33 = 0,
    PTHREAD_PROCESS_SHARED___33 = 1
} ;
#line 168
enum __anonenum__696___9 {
    PTHREAD_CANCEL_ENABLE___33 = 0,
    PTHREAD_CANCEL_DISABLE___33 = 1
} ;
#line 175
enum __anonenum__697___9 {
    PTHREAD_CANCEL_DEFERRED___33 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___33 = 1
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__607___10 {
    SI_ASYNCNL___34 = -60,
    SI_DETHREAD___34 = -7,
    SI_TKILL___34 = -6,
    SI_SIGIO___34 = -5,
    SI_ASYNCIO___34 = -4,
    SI_MESGQ___34 = -3,
    SI_TIMER___34 = -2,
    SI_QUEUE___34 = -1,
    SI_USER___34 = 0,
    SI_KERNEL___34 = 128
} ;
#line 71
enum __anonenum__608___10 {
    ILL_ILLOPC___34 = 1,
    ILL_ILLOPN___34 = 2,
    ILL_ILLADR___34 = 3,
    ILL_ILLTRP___34 = 4,
    ILL_PRVOPC___34 = 5,
    ILL_PRVREG___34 = 6,
    ILL_COPROC___34 = 7,
    ILL_BADSTK___34 = 8,
    ILL_BADIADDR___34 = 9
} ;
#line 94
enum __anonenum__609___10 {
    FPE_INTDIV___34 = 1,
    FPE_INTOVF___34 = 2,
    FPE_FLTDIV___34 = 3,
    FPE_FLTOVF___34 = 4,
    FPE_FLTUND___34 = 5,
    FPE_FLTRES___34 = 6,
    FPE_FLTINV___34 = 7,
    FPE_FLTSUB___34 = 8,
    FPE_FLTUNK___34 = 14,
    FPE_CONDTRAP___34 = 15
} ;
#line 119
enum __anonenum__610___10 {
    SEGV_MAPERR___34 = 1,
    SEGV_ACCERR___34 = 2,
    SEGV_BNDERR___34 = 3,
    SEGV_PKUERR___34 = 4,
    SEGV_ACCADI___34 = 5,
    SEGV_ADIDERR___34 = 6,
    SEGV_ADIPERR___34 = 7,
    SEGV_MTEAERR___34 = 8,
    SEGV_MTESERR___34 = 9
} ;
#line 142
enum __anonenum__611___10 {
    BUS_ADRALN___34 = 1,
    BUS_ADRERR___34 = 2,
    BUS_OBJERR___34 = 3,
    BUS_MCEERR_AR___34 = 4,
    BUS_MCEERR_AO___34 = 5
} ;
#line 176
enum __anonenum__612___10 {
    CLD_EXITED___34 = 1,
    CLD_KILLED___34 = 2,
    CLD_DUMPED___34 = 3,
    CLD_TRAPPED___34 = 4,
    CLD_STOPPED___34 = 5,
    CLD_CONTINUED___34 = 6
} ;
#line 193
enum __anonenum__613___10 {
    POLL_IN___34 = 1,
    POLL_OUT___34 = 2,
    POLL_MSG___34 = 3,
    POLL_ERR___34 = 4,
    POLL_PRI___34 = 5,
    POLL_HUP___34 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__616___10 {
    SIGEV_SIGNAL___34 = 0,
    SIGEV_NONE___34 = 1,
    SIGEV_THREAD___34 = 2,
    SIGEV_THREAD_ID___34 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__621___10 {
    SS_ONSTACK___34 = 1,
    SS_DISABLE___34 = 2
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__629___10 {
    DT_UNKNOWN___34 = 0,
    DT_FIFO___34 = 1,
    DT_CHR___34 = 2,
    DT_DIR___34 = 4,
    DT_BLK___34 = 6,
    DT_REG___34 = 8,
    DT_LNK___34 = 10,
    DT_SOCK___34 = 12,
    DT_WHT___34 = 14
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__688___10 {
    PTHREAD_CREATE_JOINABLE___34 = 0,
    PTHREAD_CREATE_DETACHED___34 = 1
} ;
#line 47
enum __anonenum__689___10 {
    PTHREAD_MUTEX_TIMED_NP___34 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___34 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___34 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___34 = 3,
    PTHREAD_MUTEX_NORMAL___34 = 0,
    PTHREAD_MUTEX_RECURSIVE___34 = 1,
    PTHREAD_MUTEX_ERRORCHECK___34 = 2,
    PTHREAD_MUTEX_DEFAULT___34 = 0
} ;
#line 69
enum __anonenum__690___10 {
    PTHREAD_MUTEX_STALLED___34 = 0,
    PTHREAD_MUTEX_STALLED_NP___34 = 0,
    PTHREAD_MUTEX_ROBUST___34 = 1,
    PTHREAD_MUTEX_ROBUST_NP___34 = 1
} ;
#line 81
enum __anonenum__691___10 {
    PTHREAD_PRIO_NONE___34 = 0,
    PTHREAD_PRIO_INHERIT___34 = 1,
    PTHREAD_PRIO_PROTECT___34 = 2
} ;
#line 104
enum __anonenum__692___10 {
    PTHREAD_RWLOCK_PREFER_READER_NP___34 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___34 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___34 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___34 = 0
} ;
#line 124
enum __anonenum__693___10 {
    PTHREAD_INHERIT_SCHED___34 = 0,
    PTHREAD_EXPLICIT_SCHED___34 = 1
} ;
#line 134
enum __anonenum__694___10 {
    PTHREAD_SCOPE_SYSTEM___34 = 0,
    PTHREAD_SCOPE_PROCESS___34 = 1
} ;
#line 144
enum __anonenum__695___10 {
    PTHREAD_PROCESS_PRIVATE___34 = 0,
    PTHREAD_PROCESS_SHARED___34 = 1
} ;
#line 168
enum __anonenum__696___10 {
    PTHREAD_CANCEL_ENABLE___34 = 0,
    PTHREAD_CANCEL_DISABLE___34 = 1
} ;
#line 175
enum __anonenum__697___10 {
    PTHREAD_CANCEL_DEFERRED___34 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___34 = 1
} ;
#line 934 "/usr/include/math.h"
enum __anonenum__1280___0 {
    FP_NAN___12 = 0,
    FP_INFINITE___12 = 1,
    FP_ZERO___12 = 2,
    FP_SUBNORMAL___12 = 3,
    FP_NORMAL___12 = 4
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__876___1 {
    SI_ASYNCNL___35 = -60,
    SI_DETHREAD___35 = -7,
    SI_TKILL___35 = -6,
    SI_SIGIO___35 = -5,
    SI_ASYNCIO___35 = -4,
    SI_MESGQ___35 = -3,
    SI_TIMER___35 = -2,
    SI_QUEUE___35 = -1,
    SI_USER___35 = 0,
    SI_KERNEL___35 = 128
} ;
#line 71
enum __anonenum__877___1 {
    ILL_ILLOPC___35 = 1,
    ILL_ILLOPN___35 = 2,
    ILL_ILLADR___35 = 3,
    ILL_ILLTRP___35 = 4,
    ILL_PRVOPC___35 = 5,
    ILL_PRVREG___35 = 6,
    ILL_COPROC___35 = 7,
    ILL_BADSTK___35 = 8,
    ILL_BADIADDR___35 = 9
} ;
#line 94
enum __anonenum__878___1 {
    FPE_INTDIV___35 = 1,
    FPE_INTOVF___35 = 2,
    FPE_FLTDIV___35 = 3,
    FPE_FLTOVF___35 = 4,
    FPE_FLTUND___35 = 5,
    FPE_FLTRES___35 = 6,
    FPE_FLTINV___35 = 7,
    FPE_FLTSUB___35 = 8,
    FPE_FLTUNK___35 = 14,
    FPE_CONDTRAP___35 = 15
} ;
#line 119
enum __anonenum__879___1 {
    SEGV_MAPERR___35 = 1,
    SEGV_ACCERR___35 = 2,
    SEGV_BNDERR___35 = 3,
    SEGV_PKUERR___35 = 4,
    SEGV_ACCADI___35 = 5,
    SEGV_ADIDERR___35 = 6,
    SEGV_ADIPERR___35 = 7,
    SEGV_MTEAERR___35 = 8,
    SEGV_MTESERR___35 = 9
} ;
#line 142
enum __anonenum__880___1 {
    BUS_ADRALN___35 = 1,
    BUS_ADRERR___35 = 2,
    BUS_OBJERR___35 = 3,
    BUS_MCEERR_AR___35 = 4,
    BUS_MCEERR_AO___35 = 5
} ;
#line 176
enum __anonenum__881___1 {
    CLD_EXITED___35 = 1,
    CLD_KILLED___35 = 2,
    CLD_DUMPED___35 = 3,
    CLD_TRAPPED___35 = 4,
    CLD_STOPPED___35 = 5,
    CLD_CONTINUED___35 = 6
} ;
#line 193
enum __anonenum__882___1 {
    POLL_IN___35 = 1,
    POLL_OUT___35 = 2,
    POLL_MSG___35 = 3,
    POLL_ERR___35 = 4,
    POLL_PRI___35 = 5,
    POLL_HUP___35 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__885___1 {
    SIGEV_SIGNAL___35 = 0,
    SIGEV_NONE___35 = 1,
    SIGEV_THREAD___35 = 2,
    SIGEV_THREAD_ID___35 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__890___1 {
    SS_ONSTACK___35 = 1,
    SS_DISABLE___35 = 2
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__898___1 {
    DT_UNKNOWN___35 = 0,
    DT_FIFO___35 = 1,
    DT_CHR___35 = 2,
    DT_DIR___35 = 4,
    DT_BLK___35 = 6,
    DT_REG___35 = 8,
    DT_LNK___35 = 10,
    DT_SOCK___35 = 12,
    DT_WHT___35 = 14
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__819___2 {
    PTHREAD_CREATE_JOINABLE___35 = 0,
    PTHREAD_CREATE_DETACHED___35 = 1
} ;
#line 47
enum __anonenum__820___2 {
    PTHREAD_MUTEX_TIMED_NP___35 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___35 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___35 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___35 = 3,
    PTHREAD_MUTEX_NORMAL___35 = 0,
    PTHREAD_MUTEX_RECURSIVE___35 = 1,
    PTHREAD_MUTEX_ERRORCHECK___35 = 2,
    PTHREAD_MUTEX_DEFAULT___35 = 0
} ;
#line 69
enum __anonenum__821___2 {
    PTHREAD_MUTEX_STALLED___35 = 0,
    PTHREAD_MUTEX_STALLED_NP___35 = 0,
    PTHREAD_MUTEX_ROBUST___35 = 1,
    PTHREAD_MUTEX_ROBUST_NP___35 = 1
} ;
#line 81
enum __anonenum__822___2 {
    PTHREAD_PRIO_NONE___35 = 0,
    PTHREAD_PRIO_INHERIT___35 = 1,
    PTHREAD_PRIO_PROTECT___35 = 2
} ;
#line 104
enum __anonenum__823___2 {
    PTHREAD_RWLOCK_PREFER_READER_NP___35 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___35 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___35 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___35 = 0
} ;
#line 124
enum __anonenum__409___17 {
    PTHREAD_INHERIT_SCHED___35 = 0,
    PTHREAD_EXPLICIT_SCHED___35 = 1
} ;
#line 134
enum __anonenum__824___2 {
    PTHREAD_SCOPE_SYSTEM___35 = 0,
    PTHREAD_SCOPE_PROCESS___35 = 1
} ;
#line 144
enum __anonenum__825___2 {
    PTHREAD_PROCESS_PRIVATE___35 = 0,
    PTHREAD_PROCESS_SHARED___35 = 1
} ;
#line 168
enum __anonenum__826___2 {
    PTHREAD_CANCEL_ENABLE___35 = 0,
    PTHREAD_CANCEL_DISABLE___35 = 1
} ;
#line 175
enum __anonenum__827___2 {
    PTHREAD_CANCEL_DEFERRED___35 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___35 = 1
} ;
#line 32 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag jmp_buf[1];
#line 70 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag sigjmp_buf[1];
#line 481 "/usr/include/pngconf.h"
typedef unsigned char png_byte;
#line 489 "/usr/include/pngconf.h"
typedef short png_int_16;
#line 497 "/usr/include/pngconf.h"
typedef unsigned short png_uint_16;
#line 503 "/usr/include/pngconf.h"
typedef int png_int_32;
#line 511 "/usr/include/pngconf.h"
typedef unsigned int png_uint_32;
#line 523 "/usr/include/pngconf.h"
typedef size_t png_size_t;
#line 524 "/usr/include/pngconf.h"
typedef ptrdiff_t png_ptrdiff_t;
#line 557 "/usr/include/pngconf.h"
typedef size_t png_alloc_size_t;
#line 574 "/usr/include/pngconf.h"
typedef png_int_32 png_fixed_point;
#line 577 "/usr/include/pngconf.h"
typedef void *png_voidp;
#line 578 "/usr/include/pngconf.h"
typedef void const   *png_const_voidp;
#line 579 "/usr/include/pngconf.h"
typedef png_byte *png_bytep;
#line 580 "/usr/include/pngconf.h"
typedef png_byte *png_const_bytep;
#line 581 "/usr/include/pngconf.h"
typedef png_uint_32 *png_uint_32p;
#line 582 "/usr/include/pngconf.h"
typedef png_uint_32 *png_const_uint_32p;
#line 583 "/usr/include/pngconf.h"
typedef png_int_32 *png_int_32p;
#line 584 "/usr/include/pngconf.h"
typedef png_int_32 *png_const_int_32p;
#line 585 "/usr/include/pngconf.h"
typedef png_uint_16 *png_uint_16p;
#line 586 "/usr/include/pngconf.h"
typedef png_uint_16 *png_const_uint_16p;
#line 587 "/usr/include/pngconf.h"
typedef png_int_16 *png_int_16p;
#line 588 "/usr/include/pngconf.h"
typedef png_int_16 *png_const_int_16p;
#line 589 "/usr/include/pngconf.h"
typedef char *png_charp;
#line 590 "/usr/include/pngconf.h"
typedef char const   *png_const_charp;
#line 591 "/usr/include/pngconf.h"
typedef png_fixed_point *png_fixed_point_p;
#line 592 "/usr/include/pngconf.h"
typedef png_fixed_point *png_const_fixed_point_p;
#line 593 "/usr/include/pngconf.h"
typedef size_t *png_size_tp;
#line 594 "/usr/include/pngconf.h"
typedef size_t *png_const_size_tp;
#line 597 "/usr/include/pngconf.h"
typedef FILE *png_FILE_p;
#line 601 "/usr/include/pngconf.h"
typedef double *png_doublep;
#line 602 "/usr/include/pngconf.h"
typedef double const   *png_const_doublep;
#line 606 "/usr/include/pngconf.h"
typedef png_byte **png_bytepp;
#line 607 "/usr/include/pngconf.h"
typedef png_uint_32 **png_uint_32pp;
#line 608 "/usr/include/pngconf.h"
typedef png_int_32 **png_int_32pp;
#line 609 "/usr/include/pngconf.h"
typedef png_uint_16 **png_uint_16pp;
#line 610 "/usr/include/pngconf.h"
typedef png_int_16 **png_int_16pp;
#line 611 "/usr/include/pngconf.h"
typedef char const   **png_const_charpp;
#line 612 "/usr/include/pngconf.h"
typedef char **png_charpp;
#line 613 "/usr/include/pngconf.h"
typedef png_fixed_point **png_fixed_point_pp;
#line 615 "/usr/include/pngconf.h"
typedef double **png_doublepp;
#line 619 "/usr/include/pngconf.h"
typedef char ***png_charppp;
#line 446 "/usr/include/png.h"
typedef char *png_libpng_version_1_6_37;
#line 454
struct png_struct_def ;
#line 454 "/usr/include/png.h"
typedef struct png_struct_def png_struct;
#line 455 "/usr/include/png.h"
typedef png_struct *png_const_structp;
#line 456 "/usr/include/png.h"
typedef png_struct *png_structp;
#line 457 "/usr/include/png.h"
typedef png_struct **png_structpp;
#line 468
struct png_info_def ;
#line 468 "/usr/include/png.h"
typedef struct png_info_def png_info;
#line 469 "/usr/include/png.h"
typedef png_info *png_infop;
#line 470 "/usr/include/png.h"
typedef png_info *png_const_infop;
#line 471 "/usr/include/png.h"
typedef png_info **png_infopp;
#line 484 "/usr/include/png.h"
typedef png_struct *png_structrp;
#line 485 "/usr/include/png.h"
typedef png_struct *png_const_structrp;
#line 486 "/usr/include/png.h"
typedef png_info *png_inforp;
#line 487 "/usr/include/png.h"
typedef png_info *png_const_inforp;
#line 493 "/usr/include/png.h"
struct png_color_struct {
   png_byte red ;
   png_byte green ;
   png_byte blue ;
};
#line 498 "/usr/include/png.h"
typedef struct png_color_struct png_color;
#line 499 "/usr/include/png.h"
typedef png_color *png_colorp;
#line 500 "/usr/include/png.h"
typedef png_color *png_const_colorp;
#line 501 "/usr/include/png.h"
typedef png_color **png_colorpp;
#line 503 "/usr/include/png.h"
struct png_color_16_struct {
   png_byte index ;
   png_uint_16 red ;
   png_uint_16 green ;
   png_uint_16 blue ;
   png_uint_16 gray ;
};
#line 510 "/usr/include/png.h"
typedef struct png_color_16_struct png_color_16;
#line 511 "/usr/include/png.h"
typedef png_color_16 *png_color_16p;
#line 512 "/usr/include/png.h"
typedef png_color_16 *png_const_color_16p;
#line 513 "/usr/include/png.h"
typedef png_color_16 **png_color_16pp;
#line 515 "/usr/include/png.h"
struct png_color_8_struct {
   png_byte red ;
   png_byte green ;
   png_byte blue ;
   png_byte gray ;
   png_byte alpha ;
};
#line 522 "/usr/include/png.h"
typedef struct png_color_8_struct png_color_8;
#line 523 "/usr/include/png.h"
typedef png_color_8 *png_color_8p;
#line 524 "/usr/include/png.h"
typedef png_color_8 *png_const_color_8p;
#line 525 "/usr/include/png.h"
typedef png_color_8 **png_color_8pp;
#line 531 "/usr/include/png.h"
struct png_sPLT_entry_struct {
   png_uint_16 red ;
   png_uint_16 green ;
   png_uint_16 blue ;
   png_uint_16 alpha ;
   png_uint_16 frequency ;
};
#line 538 "/usr/include/png.h"
typedef struct png_sPLT_entry_struct png_sPLT_entry;
#line 539 "/usr/include/png.h"
typedef png_sPLT_entry *png_sPLT_entryp;
#line 540 "/usr/include/png.h"
typedef png_sPLT_entry *png_const_sPLT_entryp;
#line 541 "/usr/include/png.h"
typedef png_sPLT_entry **png_sPLT_entrypp;
#line 548 "/usr/include/png.h"
struct png_sPLT_struct {
   png_charp name ;
   png_byte depth ;
   png_sPLT_entryp entries ;
   png_int_32 nentries ;
};
#line 554 "/usr/include/png.h"
typedef struct png_sPLT_struct png_sPLT_t;
#line 555 "/usr/include/png.h"
typedef png_sPLT_t *png_sPLT_tp;
#line 556 "/usr/include/png.h"
typedef png_sPLT_t *png_const_sPLT_tp;
#line 557 "/usr/include/png.h"
typedef png_sPLT_t **png_sPLT_tpp;
#line 577 "/usr/include/png.h"
struct png_text_struct {
   int compression ;
   png_charp key ;
   png_charp text ;
   size_t text_length ;
   size_t itxt_length ;
   png_charp lang ;
   png_charp lang_key ;
};
#line 593 "/usr/include/png.h"
typedef struct png_text_struct png_text;
#line 594 "/usr/include/png.h"
typedef png_text *png_textp;
#line 595 "/usr/include/png.h"
typedef png_text *png_const_textp;
#line 596 "/usr/include/png.h"
typedef png_text **png_textpp;
#line 615 "/usr/include/png.h"
struct png_time_struct {
   png_uint_16 year ;
   png_byte month ;
   png_byte day ;
   png_byte hour ;
   png_byte minute ;
   png_byte second ;
};
#line 623 "/usr/include/png.h"
typedef struct png_time_struct png_time;
#line 624 "/usr/include/png.h"
typedef png_time *png_timep;
#line 625 "/usr/include/png.h"
typedef png_time *png_const_timep;
#line 626 "/usr/include/png.h"
typedef png_time **png_timepp;
#line 637 "/usr/include/png.h"
struct png_unknown_chunk_t {
   png_byte name[5] ;
   png_byte *data ;
   size_t size ;
   png_byte location ;
};
#line 651 "/usr/include/png.h"
typedef struct png_unknown_chunk_t png_unknown_chunk;
#line 653 "/usr/include/png.h"
typedef png_unknown_chunk *png_unknown_chunkp;
#line 654 "/usr/include/png.h"
typedef png_unknown_chunk *png_const_unknown_chunkp;
#line 655 "/usr/include/png.h"
typedef png_unknown_chunk **png_unknown_chunkpp;
#line 773 "/usr/include/png.h"
struct png_row_info_struct {
   png_uint_32 width ;
   size_t rowbytes ;
   png_byte color_type ;
   png_byte bit_depth ;
   png_byte channels ;
   png_byte pixel_depth ;
};
#line 781 "/usr/include/png.h"
typedef struct png_row_info_struct png_row_info;
#line 783 "/usr/include/png.h"
typedef png_row_info *png_row_infop;
#line 784 "/usr/include/png.h"
typedef png_row_info **png_row_infopp;
#line 794 "/usr/include/png.h"
typedef void (*png_error_ptr)(png_structp  , png_const_charp  );
#line 795 "/usr/include/png.h"
typedef void (*png_rw_ptr)(png_structp  , png_bytep  , size_t  );
#line 796 "/usr/include/png.h"
typedef void (*png_flush_ptr)(png_structp  );
#line 797 "/usr/include/png.h"
typedef void (*png_read_status_ptr)(png_structp  , png_uint_32  , int  );
#line 799 "/usr/include/png.h"
typedef void (*png_write_status_ptr)(png_structp  , png_uint_32  , int  );
#line 803 "/usr/include/png.h"
typedef void (*png_progressive_info_ptr)(png_structp  , png_infop  );
#line 804 "/usr/include/png.h"
typedef void (*png_progressive_end_ptr)(png_structp  , png_infop  );
#line 806 "/usr/include/png.h"
typedef void (*png_progressive_frame_ptr)(png_structp  , png_uint_32  );
#line 820 "/usr/include/png.h"
typedef void (*png_progressive_row_ptr)(png_structp  , png_bytep  , png_uint_32  ,
                                        int  );
#line 826 "/usr/include/png.h"
typedef void (*png_user_transform_ptr)(png_structp  , png_row_infop  , png_bytep  );
#line 831 "/usr/include/png.h"
typedef int (*png_user_chunk_ptr)(png_structp  , png_unknown_chunkp  );
#line 851 "/usr/include/png.h"
typedef void (*png_longjmp_ptr)(jmp_buf  , int  );
#line 890 "/usr/include/png.h"
typedef png_voidp (*png_malloc_ptr)(png_structp  , png_alloc_size_t  );
#line 892 "/usr/include/png.h"
typedef void (*png_free_ptr)(png_structp  , png_voidp  );
#line 2694
struct png_control ;
#line 2694 "/usr/include/png.h"
typedef struct png_control *png_controlp;
#line 2695 "/usr/include/png.h"
struct __anonstruct_1285 {
   png_controlp opaque ;
   png_uint_32 version ;
   png_uint_32 width ;
   png_uint_32 height ;
   png_uint_32 format ;
   png_uint_32 flags ;
   png_uint_32 colormap_entries ;
   png_uint_32 warning_or_error ;
   char message[64] ;
};
#line 2731 "/usr/include/png.h"
typedef struct __anonstruct_1285 png_image;
#line 2731 "/usr/include/png.h"
typedef struct __anonstruct_1285 *png_imagep;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__876___2 {
    SI_ASYNCNL___36 = -60,
    SI_DETHREAD___36 = -7,
    SI_TKILL___36 = -6,
    SI_SIGIO___36 = -5,
    SI_ASYNCIO___36 = -4,
    SI_MESGQ___36 = -3,
    SI_TIMER___36 = -2,
    SI_QUEUE___36 = -1,
    SI_USER___36 = 0,
    SI_KERNEL___36 = 128
} ;
#line 71
enum __anonenum__877___2 {
    ILL_ILLOPC___36 = 1,
    ILL_ILLOPN___36 = 2,
    ILL_ILLADR___36 = 3,
    ILL_ILLTRP___36 = 4,
    ILL_PRVOPC___36 = 5,
    ILL_PRVREG___36 = 6,
    ILL_COPROC___36 = 7,
    ILL_BADSTK___36 = 8,
    ILL_BADIADDR___36 = 9
} ;
#line 94
enum __anonenum__878___2 {
    FPE_INTDIV___36 = 1,
    FPE_INTOVF___36 = 2,
    FPE_FLTDIV___36 = 3,
    FPE_FLTOVF___36 = 4,
    FPE_FLTUND___36 = 5,
    FPE_FLTRES___36 = 6,
    FPE_FLTINV___36 = 7,
    FPE_FLTSUB___36 = 8,
    FPE_FLTUNK___36 = 14,
    FPE_CONDTRAP___36 = 15
} ;
#line 119
enum __anonenum__879___2 {
    SEGV_MAPERR___36 = 1,
    SEGV_ACCERR___36 = 2,
    SEGV_BNDERR___36 = 3,
    SEGV_PKUERR___36 = 4,
    SEGV_ACCADI___36 = 5,
    SEGV_ADIDERR___36 = 6,
    SEGV_ADIPERR___36 = 7,
    SEGV_MTEAERR___36 = 8,
    SEGV_MTESERR___36 = 9
} ;
#line 142
enum __anonenum__880___2 {
    BUS_ADRALN___36 = 1,
    BUS_ADRERR___36 = 2,
    BUS_OBJERR___36 = 3,
    BUS_MCEERR_AR___36 = 4,
    BUS_MCEERR_AO___36 = 5
} ;
#line 176
enum __anonenum__881___2 {
    CLD_EXITED___36 = 1,
    CLD_KILLED___36 = 2,
    CLD_DUMPED___36 = 3,
    CLD_TRAPPED___36 = 4,
    CLD_STOPPED___36 = 5,
    CLD_CONTINUED___36 = 6
} ;
#line 193
enum __anonenum__882___2 {
    POLL_IN___36 = 1,
    POLL_OUT___36 = 2,
    POLL_MSG___36 = 3,
    POLL_ERR___36 = 4,
    POLL_PRI___36 = 5,
    POLL_HUP___36 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__885___2 {
    SIGEV_SIGNAL___36 = 0,
    SIGEV_NONE___36 = 1,
    SIGEV_THREAD___36 = 2,
    SIGEV_THREAD_ID___36 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__890___2 {
    SS_ONSTACK___36 = 1,
    SS_DISABLE___36 = 2
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__898___2 {
    DT_UNKNOWN___36 = 0,
    DT_FIFO___36 = 1,
    DT_CHR___36 = 2,
    DT_DIR___36 = 4,
    DT_BLK___36 = 6,
    DT_REG___36 = 8,
    DT_LNK___36 = 10,
    DT_SOCK___36 = 12,
    DT_WHT___36 = 14
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__819___3 {
    PTHREAD_CREATE_JOINABLE___36 = 0,
    PTHREAD_CREATE_DETACHED___36 = 1
} ;
#line 47
enum __anonenum__820___3 {
    PTHREAD_MUTEX_TIMED_NP___36 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___36 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___36 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___36 = 3,
    PTHREAD_MUTEX_NORMAL___36 = 0,
    PTHREAD_MUTEX_RECURSIVE___36 = 1,
    PTHREAD_MUTEX_ERRORCHECK___36 = 2,
    PTHREAD_MUTEX_DEFAULT___36 = 0
} ;
#line 69
enum __anonenum__821___3 {
    PTHREAD_MUTEX_STALLED___36 = 0,
    PTHREAD_MUTEX_STALLED_NP___36 = 0,
    PTHREAD_MUTEX_ROBUST___36 = 1,
    PTHREAD_MUTEX_ROBUST_NP___36 = 1
} ;
#line 81
enum __anonenum__822___3 {
    PTHREAD_PRIO_NONE___36 = 0,
    PTHREAD_PRIO_INHERIT___36 = 1,
    PTHREAD_PRIO_PROTECT___36 = 2
} ;
#line 104
enum __anonenum__823___3 {
    PTHREAD_RWLOCK_PREFER_READER_NP___36 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___36 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___36 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___36 = 0
} ;
#line 124
enum __anonenum__409___18 {
    PTHREAD_INHERIT_SCHED___36 = 0,
    PTHREAD_EXPLICIT_SCHED___36 = 1
} ;
#line 134
enum __anonenum__824___3 {
    PTHREAD_SCOPE_SYSTEM___36 = 0,
    PTHREAD_SCOPE_PROCESS___36 = 1
} ;
#line 144
enum __anonenum__825___3 {
    PTHREAD_PROCESS_PRIVATE___36 = 0,
    PTHREAD_PROCESS_SHARED___36 = 1
} ;
#line 168
enum __anonenum__826___3 {
    PTHREAD_CANCEL_ENABLE___36 = 0,
    PTHREAD_CANCEL_DISABLE___36 = 1
} ;
#line 175
enum __anonenum__827___3 {
    PTHREAD_CANCEL_DEFERRED___36 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___36 = 1
} ;
#line 74 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-gf.c"
struct _gf_char_t {
   unsigned char charcode ;
   long h_escapement ;
   long tfm_width ;
   long char_pointer ;
};
#line 79 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-gf.c"
typedef struct _gf_char_t gf_locator_t;
#line 81 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-gf.c"
struct _gf_font_t {
   char *input_filename ;
   FILE *input_file ;
   double design_size ;
   unsigned long checksum ;
   double h_pixels_per_point ;
   double v_pixels_per_point ;
   long bbox_min_col ;
   long bbox_max_col ;
   long bbox_min_row ;
   long bbox_max_row ;
   gf_locator_t char_loc[256] ;
};
#line 92 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-gf.c"
typedef struct _gf_font_t gf_font_t;
#line 96 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-gf.c"
struct __anonstruct_1286 {
   gf_font_t *font ;
   unsigned char charcode ;
   long bbox_min_col ;
   long bbox_max_col ;
   long bbox_min_row ;
   long bbox_max_row ;
   long h_escapement ;
   long tfm_width ;
   unsigned short height ;
   unsigned short width ;
   char *bitmap ;
};
#line 107 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-gf.c"
typedef struct __anonstruct_1286 gf_char_t;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__876___3 {
    SI_ASYNCNL___37 = -60,
    SI_DETHREAD___37 = -7,
    SI_TKILL___37 = -6,
    SI_SIGIO___37 = -5,
    SI_ASYNCIO___37 = -4,
    SI_MESGQ___37 = -3,
    SI_TIMER___37 = -2,
    SI_QUEUE___37 = -1,
    SI_USER___37 = 0,
    SI_KERNEL___37 = 128
} ;
#line 71
enum __anonenum__877___3 {
    ILL_ILLOPC___37 = 1,
    ILL_ILLOPN___37 = 2,
    ILL_ILLADR___37 = 3,
    ILL_ILLTRP___37 = 4,
    ILL_PRVOPC___37 = 5,
    ILL_PRVREG___37 = 6,
    ILL_COPROC___37 = 7,
    ILL_BADSTK___37 = 8,
    ILL_BADIADDR___37 = 9
} ;
#line 94
enum __anonenum__878___3 {
    FPE_INTDIV___37 = 1,
    FPE_INTOVF___37 = 2,
    FPE_FLTDIV___37 = 3,
    FPE_FLTOVF___37 = 4,
    FPE_FLTUND___37 = 5,
    FPE_FLTRES___37 = 6,
    FPE_FLTINV___37 = 7,
    FPE_FLTSUB___37 = 8,
    FPE_FLTUNK___37 = 14,
    FPE_CONDTRAP___37 = 15
} ;
#line 119
enum __anonenum__879___3 {
    SEGV_MAPERR___37 = 1,
    SEGV_ACCERR___37 = 2,
    SEGV_BNDERR___37 = 3,
    SEGV_PKUERR___37 = 4,
    SEGV_ACCADI___37 = 5,
    SEGV_ADIDERR___37 = 6,
    SEGV_ADIPERR___37 = 7,
    SEGV_MTEAERR___37 = 8,
    SEGV_MTESERR___37 = 9
} ;
#line 142
enum __anonenum__880___3 {
    BUS_ADRALN___37 = 1,
    BUS_ADRERR___37 = 2,
    BUS_OBJERR___37 = 3,
    BUS_MCEERR_AR___37 = 4,
    BUS_MCEERR_AO___37 = 5
} ;
#line 176
enum __anonenum__881___3 {
    CLD_EXITED___37 = 1,
    CLD_KILLED___37 = 2,
    CLD_DUMPED___37 = 3,
    CLD_TRAPPED___37 = 4,
    CLD_STOPPED___37 = 5,
    CLD_CONTINUED___37 = 6
} ;
#line 193
enum __anonenum__882___3 {
    POLL_IN___37 = 1,
    POLL_OUT___37 = 2,
    POLL_MSG___37 = 3,
    POLL_ERR___37 = 4,
    POLL_PRI___37 = 5,
    POLL_HUP___37 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__885___3 {
    SIGEV_SIGNAL___37 = 0,
    SIGEV_NONE___37 = 1,
    SIGEV_THREAD___37 = 2,
    SIGEV_THREAD_ID___37 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__890___3 {
    SS_ONSTACK___37 = 1,
    SS_DISABLE___37 = 2
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__898___3 {
    DT_UNKNOWN___37 = 0,
    DT_FIFO___37 = 1,
    DT_CHR___37 = 2,
    DT_DIR___37 = 4,
    DT_BLK___37 = 6,
    DT_REG___37 = 8,
    DT_LNK___37 = 10,
    DT_SOCK___37 = 12,
    DT_WHT___37 = 14
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__819___4 {
    PTHREAD_CREATE_JOINABLE___37 = 0,
    PTHREAD_CREATE_DETACHED___37 = 1
} ;
#line 47
enum __anonenum__820___4 {
    PTHREAD_MUTEX_TIMED_NP___37 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___37 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___37 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___37 = 3,
    PTHREAD_MUTEX_NORMAL___37 = 0,
    PTHREAD_MUTEX_RECURSIVE___37 = 1,
    PTHREAD_MUTEX_ERRORCHECK___37 = 2,
    PTHREAD_MUTEX_DEFAULT___37 = 0
} ;
#line 69
enum __anonenum__821___4 {
    PTHREAD_MUTEX_STALLED___37 = 0,
    PTHREAD_MUTEX_STALLED_NP___37 = 0,
    PTHREAD_MUTEX_ROBUST___37 = 1,
    PTHREAD_MUTEX_ROBUST_NP___37 = 1
} ;
#line 81
enum __anonenum__822___4 {
    PTHREAD_PRIO_NONE___37 = 0,
    PTHREAD_PRIO_INHERIT___37 = 1,
    PTHREAD_PRIO_PROTECT___37 = 2
} ;
#line 104
enum __anonenum__823___4 {
    PTHREAD_RWLOCK_PREFER_READER_NP___37 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___37 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___37 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___37 = 0
} ;
#line 124
enum __anonenum__409___19 {
    PTHREAD_INHERIT_SCHED___37 = 0,
    PTHREAD_EXPLICIT_SCHED___37 = 1
} ;
#line 134
enum __anonenum__824___4 {
    PTHREAD_SCOPE_SYSTEM___37 = 0,
    PTHREAD_SCOPE_PROCESS___37 = 1
} ;
#line 144
enum __anonenum__825___4 {
    PTHREAD_PROCESS_PRIVATE___37 = 0,
    PTHREAD_PROCESS_SHARED___37 = 1
} ;
#line 168
enum __anonenum__826___4 {
    PTHREAD_CANCEL_ENABLE___37 = 0,
    PTHREAD_CANCEL_DISABLE___37 = 1
} ;
#line 175
enum __anonenum__827___4 {
    PTHREAD_CANCEL_DEFERRED___37 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___37 = 1
} ;
#line 54 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-tga.c"
struct tga_header {
   unsigned char idLength ;
   unsigned char colorMapType ;
   unsigned char imageType ;
   unsigned char colorMapIndexLo ;
   unsigned char colorMapIndexHi ;
   unsigned char colorMapLengthLo ;
   unsigned char colorMapLengthHi ;
   unsigned char colorMapSize ;
   unsigned char xOriginLo ;
   unsigned char xOriginHi ;
   unsigned char yOriginLo ;
   unsigned char yOriginHi ;
   unsigned char widthLo ;
   unsigned char widthHi ;
   unsigned char heightLo ;
   unsigned char heightHi ;
   unsigned char bpp ;
   unsigned char descriptor ;
};
#line 95 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-tga.c"
struct __anonstruct_1287 {
   unsigned int extensionAreaOffset ;
   unsigned int developerDirectoryOffset ;
   char signature[16] ;
   char dot ;
   char null ;
};
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__876___4 {
    SI_ASYNCNL___38 = -60,
    SI_DETHREAD___38 = -7,
    SI_TKILL___38 = -6,
    SI_SIGIO___38 = -5,
    SI_ASYNCIO___38 = -4,
    SI_MESGQ___38 = -3,
    SI_TIMER___38 = -2,
    SI_QUEUE___38 = -1,
    SI_USER___38 = 0,
    SI_KERNEL___38 = 128
} ;
#line 71
enum __anonenum__877___4 {
    ILL_ILLOPC___38 = 1,
    ILL_ILLOPN___38 = 2,
    ILL_ILLADR___38 = 3,
    ILL_ILLTRP___38 = 4,
    ILL_PRVOPC___38 = 5,
    ILL_PRVREG___38 = 6,
    ILL_COPROC___38 = 7,
    ILL_BADSTK___38 = 8,
    ILL_BADIADDR___38 = 9
} ;
#line 94
enum __anonenum__878___4 {
    FPE_INTDIV___38 = 1,
    FPE_INTOVF___38 = 2,
    FPE_FLTDIV___38 = 3,
    FPE_FLTOVF___38 = 4,
    FPE_FLTUND___38 = 5,
    FPE_FLTRES___38 = 6,
    FPE_FLTINV___38 = 7,
    FPE_FLTSUB___38 = 8,
    FPE_FLTUNK___38 = 14,
    FPE_CONDTRAP___38 = 15
} ;
#line 119
enum __anonenum__879___4 {
    SEGV_MAPERR___38 = 1,
    SEGV_ACCERR___38 = 2,
    SEGV_BNDERR___38 = 3,
    SEGV_PKUERR___38 = 4,
    SEGV_ACCADI___38 = 5,
    SEGV_ADIDERR___38 = 6,
    SEGV_ADIPERR___38 = 7,
    SEGV_MTEAERR___38 = 8,
    SEGV_MTESERR___38 = 9
} ;
#line 142
enum __anonenum__880___4 {
    BUS_ADRALN___38 = 1,
    BUS_ADRERR___38 = 2,
    BUS_OBJERR___38 = 3,
    BUS_MCEERR_AR___38 = 4,
    BUS_MCEERR_AO___38 = 5
} ;
#line 176
enum __anonenum__881___4 {
    CLD_EXITED___38 = 1,
    CLD_KILLED___38 = 2,
    CLD_DUMPED___38 = 3,
    CLD_TRAPPED___38 = 4,
    CLD_STOPPED___38 = 5,
    CLD_CONTINUED___38 = 6
} ;
#line 193
enum __anonenum__882___4 {
    POLL_IN___38 = 1,
    POLL_OUT___38 = 2,
    POLL_MSG___38 = 3,
    POLL_ERR___38 = 4,
    POLL_PRI___38 = 5,
    POLL_HUP___38 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__885___4 {
    SIGEV_SIGNAL___38 = 0,
    SIGEV_NONE___38 = 1,
    SIGEV_THREAD___38 = 2,
    SIGEV_THREAD_ID___38 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__890___4 {
    SS_ONSTACK___38 = 1,
    SS_DISABLE___38 = 2
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__898___4 {
    DT_UNKNOWN___38 = 0,
    DT_FIFO___38 = 1,
    DT_CHR___38 = 2,
    DT_DIR___38 = 4,
    DT_BLK___38 = 6,
    DT_REG___38 = 8,
    DT_LNK___38 = 10,
    DT_SOCK___38 = 12,
    DT_WHT___38 = 14
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__819___5 {
    PTHREAD_CREATE_JOINABLE___38 = 0,
    PTHREAD_CREATE_DETACHED___38 = 1
} ;
#line 47
enum __anonenum__820___5 {
    PTHREAD_MUTEX_TIMED_NP___38 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___38 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___38 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___38 = 3,
    PTHREAD_MUTEX_NORMAL___38 = 0,
    PTHREAD_MUTEX_RECURSIVE___38 = 1,
    PTHREAD_MUTEX_ERRORCHECK___38 = 2,
    PTHREAD_MUTEX_DEFAULT___38 = 0
} ;
#line 69
enum __anonenum__821___5 {
    PTHREAD_MUTEX_STALLED___38 = 0,
    PTHREAD_MUTEX_STALLED_NP___38 = 0,
    PTHREAD_MUTEX_ROBUST___38 = 1,
    PTHREAD_MUTEX_ROBUST_NP___38 = 1
} ;
#line 81
enum __anonenum__822___5 {
    PTHREAD_PRIO_NONE___38 = 0,
    PTHREAD_PRIO_INHERIT___38 = 1,
    PTHREAD_PRIO_PROTECT___38 = 2
} ;
#line 104
enum __anonenum__823___5 {
    PTHREAD_RWLOCK_PREFER_READER_NP___38 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___38 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___38 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___38 = 0
} ;
#line 124
enum __anonenum__409___20 {
    PTHREAD_INHERIT_SCHED___38 = 0,
    PTHREAD_EXPLICIT_SCHED___38 = 1
} ;
#line 134
enum __anonenum__824___5 {
    PTHREAD_SCOPE_SYSTEM___38 = 0,
    PTHREAD_SCOPE_PROCESS___38 = 1
} ;
#line 144
enum __anonenum__825___5 {
    PTHREAD_PROCESS_PRIVATE___38 = 0,
    PTHREAD_PROCESS_SHARED___38 = 1
} ;
#line 168
enum __anonenum__826___5 {
    PTHREAD_CANCEL_ENABLE___38 = 0,
    PTHREAD_CANCEL_DISABLE___38 = 1
} ;
#line 175
enum __anonenum__827___5 {
    PTHREAD_CANCEL_DEFERRED___38 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___38 = 1
} ;
#line 38 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-bmp.c"
struct Bitmap_File_Head_Struct {
   char zzMagic[2] ;
   unsigned long bfSize ;
   unsigned short zzHotX ;
   unsigned short zzHotY ;
   unsigned long bfOffs ;
   unsigned long biSize ;
};
#line 47 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-bmp.c"
struct Bitmap_Head_Struct {
   unsigned long biWidth ;
   unsigned long biHeight ;
   unsigned short biPlanes ;
   unsigned short biBitCnt ;
   unsigned long biCompr ;
   unsigned long biSizeIm ;
   unsigned long biXPels ;
   unsigned long biYPels ;
   unsigned long biClrUsed ;
   unsigned long biClrImp ;
};
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__607___11 {
    SI_ASYNCNL___39 = -60,
    SI_DETHREAD___39 = -7,
    SI_TKILL___39 = -6,
    SI_SIGIO___39 = -5,
    SI_ASYNCIO___39 = -4,
    SI_MESGQ___39 = -3,
    SI_TIMER___39 = -2,
    SI_QUEUE___39 = -1,
    SI_USER___39 = 0,
    SI_KERNEL___39 = 128
} ;
#line 71
enum __anonenum__608___11 {
    ILL_ILLOPC___39 = 1,
    ILL_ILLOPN___39 = 2,
    ILL_ILLADR___39 = 3,
    ILL_ILLTRP___39 = 4,
    ILL_PRVOPC___39 = 5,
    ILL_PRVREG___39 = 6,
    ILL_COPROC___39 = 7,
    ILL_BADSTK___39 = 8,
    ILL_BADIADDR___39 = 9
} ;
#line 94
enum __anonenum__609___11 {
    FPE_INTDIV___39 = 1,
    FPE_INTOVF___39 = 2,
    FPE_FLTDIV___39 = 3,
    FPE_FLTOVF___39 = 4,
    FPE_FLTUND___39 = 5,
    FPE_FLTRES___39 = 6,
    FPE_FLTINV___39 = 7,
    FPE_FLTSUB___39 = 8,
    FPE_FLTUNK___39 = 14,
    FPE_CONDTRAP___39 = 15
} ;
#line 119
enum __anonenum__610___11 {
    SEGV_MAPERR___39 = 1,
    SEGV_ACCERR___39 = 2,
    SEGV_BNDERR___39 = 3,
    SEGV_PKUERR___39 = 4,
    SEGV_ACCADI___39 = 5,
    SEGV_ADIDERR___39 = 6,
    SEGV_ADIPERR___39 = 7,
    SEGV_MTEAERR___39 = 8,
    SEGV_MTESERR___39 = 9
} ;
#line 142
enum __anonenum__611___11 {
    BUS_ADRALN___39 = 1,
    BUS_ADRERR___39 = 2,
    BUS_OBJERR___39 = 3,
    BUS_MCEERR_AR___39 = 4,
    BUS_MCEERR_AO___39 = 5
} ;
#line 176
enum __anonenum__612___11 {
    CLD_EXITED___39 = 1,
    CLD_KILLED___39 = 2,
    CLD_DUMPED___39 = 3,
    CLD_TRAPPED___39 = 4,
    CLD_STOPPED___39 = 5,
    CLD_CONTINUED___39 = 6
} ;
#line 193
enum __anonenum__613___11 {
    POLL_IN___39 = 1,
    POLL_OUT___39 = 2,
    POLL_MSG___39 = 3,
    POLL_ERR___39 = 4,
    POLL_PRI___39 = 5,
    POLL_HUP___39 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__616___11 {
    SIGEV_SIGNAL___39 = 0,
    SIGEV_NONE___39 = 1,
    SIGEV_THREAD___39 = 2,
    SIGEV_THREAD_ID___39 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__621___11 {
    SS_ONSTACK___39 = 1,
    SS_DISABLE___39 = 2
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__629___11 {
    DT_UNKNOWN___39 = 0,
    DT_FIFO___39 = 1,
    DT_CHR___39 = 2,
    DT_DIR___39 = 4,
    DT_BLK___39 = 6,
    DT_REG___39 = 8,
    DT_LNK___39 = 10,
    DT_SOCK___39 = 12,
    DT_WHT___39 = 14
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__688___11 {
    PTHREAD_CREATE_JOINABLE___39 = 0,
    PTHREAD_CREATE_DETACHED___39 = 1
} ;
#line 47
enum __anonenum__689___11 {
    PTHREAD_MUTEX_TIMED_NP___39 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___39 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___39 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___39 = 3,
    PTHREAD_MUTEX_NORMAL___39 = 0,
    PTHREAD_MUTEX_RECURSIVE___39 = 1,
    PTHREAD_MUTEX_ERRORCHECK___39 = 2,
    PTHREAD_MUTEX_DEFAULT___39 = 0
} ;
#line 69
enum __anonenum__690___11 {
    PTHREAD_MUTEX_STALLED___39 = 0,
    PTHREAD_MUTEX_STALLED_NP___39 = 0,
    PTHREAD_MUTEX_ROBUST___39 = 1,
    PTHREAD_MUTEX_ROBUST_NP___39 = 1
} ;
#line 81
enum __anonenum__691___11 {
    PTHREAD_PRIO_NONE___39 = 0,
    PTHREAD_PRIO_INHERIT___39 = 1,
    PTHREAD_PRIO_PROTECT___39 = 2
} ;
#line 104
enum __anonenum__692___11 {
    PTHREAD_RWLOCK_PREFER_READER_NP___39 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___39 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___39 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___39 = 0
} ;
#line 124
enum __anonenum__693___11 {
    PTHREAD_INHERIT_SCHED___39 = 0,
    PTHREAD_EXPLICIT_SCHED___39 = 1
} ;
#line 134
enum __anonenum__694___11 {
    PTHREAD_SCOPE_SYSTEM___39 = 0,
    PTHREAD_SCOPE_PROCESS___39 = 1
} ;
#line 144
enum __anonenum__695___11 {
    PTHREAD_PROCESS_PRIVATE___39 = 0,
    PTHREAD_PROCESS_SHARED___39 = 1
} ;
#line 168
enum __anonenum__696___11 {
    PTHREAD_CANCEL_ENABLE___39 = 0,
    PTHREAD_CANCEL_DISABLE___39 = 1
} ;
#line 175
enum __anonenum__697___11 {
    PTHREAD_CANCEL_DEFERRED___39 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___39 = 1
} ;
#line 934 "/usr/include/math.h"
enum __anonenum__1288 {
    FP_NAN___13 = 0,
    FP_INFINITE___13 = 1,
    FP_ZERO___13 = 2,
    FP_SUBNORMAL___13 = 3,
    FP_NORMAL___13 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__1289 {
    _ISupper = 256,
    _ISlower = 512,
    _ISalpha = 1024,
    _ISdigit = 2048,
    _ISxdigit = 4096,
    _ISspace = 8192,
    _ISprint = 16384,
    _ISgraph = 32768,
    _ISblank = 1,
    _IScntrl = 2,
    _ISpunct = 4,
    _ISalnum = 8
} ;
#line 42 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-pnm.c"
struct _PNMScanner {
   FILE *fd ;
   char cur ;
   int eof ;
   char *inbuf ;
   int inbufsize ;
   int inbufvalidsize ;
   int inbufpos ;
};
#line 50 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-pnm.c"
typedef struct _PNMScanner PNMScanner;
#line 52 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-pnm.c"
struct _PNMInfo {
   unsigned int xres ;
   unsigned int yres ;
   int maxval ;
   int np ;
   int asciibody ;
   void (*loader)(PNMScanner * , struct _PNMInfo * , unsigned char * , at_exception_type * ) ;
};
#line 60 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-pnm.c"
typedef struct _PNMInfo PNMInfo;
#line 87 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-pnm.c"
struct struct_pnm_types {
   char name ;
   int np ;
   int asciibody ;
   int maxval ;
   void (*loader)(PNMScanner * , struct _PNMInfo * , unsigned char * , at_exception_type * ) ;
};
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__325___14 {
    SI_ASYNCNL___40 = -60,
    SI_DETHREAD___40 = -7,
    SI_TKILL___40 = -6,
    SI_SIGIO___40 = -5,
    SI_ASYNCIO___40 = -4,
    SI_MESGQ___40 = -3,
    SI_TIMER___40 = -2,
    SI_QUEUE___40 = -1,
    SI_USER___40 = 0,
    SI_KERNEL___40 = 128
} ;
#line 71
enum __anonenum__326___14 {
    ILL_ILLOPC___40 = 1,
    ILL_ILLOPN___40 = 2,
    ILL_ILLADR___40 = 3,
    ILL_ILLTRP___40 = 4,
    ILL_PRVOPC___40 = 5,
    ILL_PRVREG___40 = 6,
    ILL_COPROC___40 = 7,
    ILL_BADSTK___40 = 8,
    ILL_BADIADDR___40 = 9
} ;
#line 94
enum __anonenum__327___14 {
    FPE_INTDIV___40 = 1,
    FPE_INTOVF___40 = 2,
    FPE_FLTDIV___40 = 3,
    FPE_FLTOVF___40 = 4,
    FPE_FLTUND___40 = 5,
    FPE_FLTRES___40 = 6,
    FPE_FLTINV___40 = 7,
    FPE_FLTSUB___40 = 8,
    FPE_FLTUNK___40 = 14,
    FPE_CONDTRAP___40 = 15
} ;
#line 119
enum __anonenum__328___14 {
    SEGV_MAPERR___40 = 1,
    SEGV_ACCERR___40 = 2,
    SEGV_BNDERR___40 = 3,
    SEGV_PKUERR___40 = 4,
    SEGV_ACCADI___40 = 5,
    SEGV_ADIDERR___40 = 6,
    SEGV_ADIPERR___40 = 7,
    SEGV_MTEAERR___40 = 8,
    SEGV_MTESERR___40 = 9
} ;
#line 142
enum __anonenum__329___14 {
    BUS_ADRALN___40 = 1,
    BUS_ADRERR___40 = 2,
    BUS_OBJERR___40 = 3,
    BUS_MCEERR_AR___40 = 4,
    BUS_MCEERR_AO___40 = 5
} ;
#line 176
enum __anonenum__330___14 {
    CLD_EXITED___40 = 1,
    CLD_KILLED___40 = 2,
    CLD_DUMPED___40 = 3,
    CLD_TRAPPED___40 = 4,
    CLD_STOPPED___40 = 5,
    CLD_CONTINUED___40 = 6
} ;
#line 193
enum __anonenum__331___14 {
    POLL_IN___40 = 1,
    POLL_OUT___40 = 2,
    POLL_MSG___40 = 3,
    POLL_ERR___40 = 4,
    POLL_PRI___40 = 5,
    POLL_HUP___40 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__334___14 {
    SIGEV_SIGNAL___40 = 0,
    SIGEV_NONE___40 = 1,
    SIGEV_THREAD___40 = 2,
    SIGEV_THREAD_ID___40 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__339___14 {
    SS_ONSTACK___40 = 1,
    SS_DISABLE___40 = 2
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__347___14 {
    DT_UNKNOWN___40 = 0,
    DT_FIFO___40 = 1,
    DT_CHR___40 = 2,
    DT_DIR___40 = 4,
    DT_BLK___40 = 6,
    DT_REG___40 = 8,
    DT_LNK___40 = 10,
    DT_SOCK___40 = 12,
    DT_WHT___40 = 14
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__406___14 {
    PTHREAD_CREATE_JOINABLE___40 = 0,
    PTHREAD_CREATE_DETACHED___40 = 1
} ;
#line 47
enum __anonenum__407___14 {
    PTHREAD_MUTEX_TIMED_NP___40 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___40 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___40 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___40 = 3,
    PTHREAD_MUTEX_NORMAL___40 = 0,
    PTHREAD_MUTEX_RECURSIVE___40 = 1,
    PTHREAD_MUTEX_ERRORCHECK___40 = 2,
    PTHREAD_MUTEX_DEFAULT___40 = 0
} ;
#line 69
enum __anonenum__408___14 {
    PTHREAD_MUTEX_STALLED___40 = 0,
    PTHREAD_MUTEX_STALLED_NP___40 = 0,
    PTHREAD_MUTEX_ROBUST___40 = 1,
    PTHREAD_MUTEX_ROBUST_NP___40 = 1
} ;
#line 81
enum __anonenum__409___21 {
    PTHREAD_PRIO_NONE___40 = 0,
    PTHREAD_PRIO_INHERIT___40 = 1,
    PTHREAD_PRIO_PROTECT___40 = 2
} ;
#line 104
enum __anonenum__410___14 {
    PTHREAD_RWLOCK_PREFER_READER_NP___40 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___40 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___40 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___40 = 0
} ;
#line 124
enum __anonenum__411___14 {
    PTHREAD_INHERIT_SCHED___40 = 0,
    PTHREAD_EXPLICIT_SCHED___40 = 1
} ;
#line 134
enum __anonenum__412___14 {
    PTHREAD_SCOPE_SYSTEM___40 = 0,
    PTHREAD_SCOPE_PROCESS___40 = 1
} ;
#line 144
enum __anonenum__413___14 {
    PTHREAD_PROCESS_PRIVATE___40 = 0,
    PTHREAD_PROCESS_SHARED___40 = 1
} ;
#line 168
enum __anonenum__414___14 {
    PTHREAD_CANCEL_ENABLE___40 = 0,
    PTHREAD_CANCEL_DISABLE___40 = 1
} ;
#line 175
enum __anonenum__415___14 {
    PTHREAD_CANCEL_DEFERRED___40 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___40 = 1
} ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/getopt_ext.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 934 "/usr/include/math.h"
enum __anonenum__1291 {
    FP_NAN___14 = 0,
    FP_INFINITE___14 = 1,
    FP_ZERO___14 = 2,
    FP_SUBNORMAL___14 = 3,
    FP_NORMAL___14 = 4
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__325___15 {
    SI_ASYNCNL___41 = -60,
    SI_DETHREAD___41 = -7,
    SI_TKILL___41 = -6,
    SI_SIGIO___41 = -5,
    SI_ASYNCIO___41 = -4,
    SI_MESGQ___41 = -3,
    SI_TIMER___41 = -2,
    SI_QUEUE___41 = -1,
    SI_USER___41 = 0,
    SI_KERNEL___41 = 128
} ;
#line 71
enum __anonenum__326___15 {
    ILL_ILLOPC___41 = 1,
    ILL_ILLOPN___41 = 2,
    ILL_ILLADR___41 = 3,
    ILL_ILLTRP___41 = 4,
    ILL_PRVOPC___41 = 5,
    ILL_PRVREG___41 = 6,
    ILL_COPROC___41 = 7,
    ILL_BADSTK___41 = 8,
    ILL_BADIADDR___41 = 9
} ;
#line 94
enum __anonenum__327___15 {
    FPE_INTDIV___41 = 1,
    FPE_INTOVF___41 = 2,
    FPE_FLTDIV___41 = 3,
    FPE_FLTOVF___41 = 4,
    FPE_FLTUND___41 = 5,
    FPE_FLTRES___41 = 6,
    FPE_FLTINV___41 = 7,
    FPE_FLTSUB___41 = 8,
    FPE_FLTUNK___41 = 14,
    FPE_CONDTRAP___41 = 15
} ;
#line 119
enum __anonenum__328___15 {
    SEGV_MAPERR___41 = 1,
    SEGV_ACCERR___41 = 2,
    SEGV_BNDERR___41 = 3,
    SEGV_PKUERR___41 = 4,
    SEGV_ACCADI___41 = 5,
    SEGV_ADIDERR___41 = 6,
    SEGV_ADIPERR___41 = 7,
    SEGV_MTEAERR___41 = 8,
    SEGV_MTESERR___41 = 9
} ;
#line 142
enum __anonenum__329___15 {
    BUS_ADRALN___41 = 1,
    BUS_ADRERR___41 = 2,
    BUS_OBJERR___41 = 3,
    BUS_MCEERR_AR___41 = 4,
    BUS_MCEERR_AO___41 = 5
} ;
#line 176
enum __anonenum__330___15 {
    CLD_EXITED___41 = 1,
    CLD_KILLED___41 = 2,
    CLD_DUMPED___41 = 3,
    CLD_TRAPPED___41 = 4,
    CLD_STOPPED___41 = 5,
    CLD_CONTINUED___41 = 6
} ;
#line 193
enum __anonenum__331___15 {
    POLL_IN___41 = 1,
    POLL_OUT___41 = 2,
    POLL_MSG___41 = 3,
    POLL_ERR___41 = 4,
    POLL_PRI___41 = 5,
    POLL_HUP___41 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__334___15 {
    SIGEV_SIGNAL___41 = 0,
    SIGEV_NONE___41 = 1,
    SIGEV_THREAD___41 = 2,
    SIGEV_THREAD_ID___41 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__339___15 {
    SS_ONSTACK___41 = 1,
    SS_DISABLE___41 = 2
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__347___15 {
    DT_UNKNOWN___41 = 0,
    DT_FIFO___41 = 1,
    DT_CHR___41 = 2,
    DT_DIR___41 = 4,
    DT_BLK___41 = 6,
    DT_REG___41 = 8,
    DT_LNK___41 = 10,
    DT_SOCK___41 = 12,
    DT_WHT___41 = 14
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__406___15 {
    PTHREAD_CREATE_JOINABLE___41 = 0,
    PTHREAD_CREATE_DETACHED___41 = 1
} ;
#line 47
enum __anonenum__407___15 {
    PTHREAD_MUTEX_TIMED_NP___41 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___41 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___41 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___41 = 3,
    PTHREAD_MUTEX_NORMAL___41 = 0,
    PTHREAD_MUTEX_RECURSIVE___41 = 1,
    PTHREAD_MUTEX_ERRORCHECK___41 = 2,
    PTHREAD_MUTEX_DEFAULT___41 = 0
} ;
#line 69
enum __anonenum__408___15 {
    PTHREAD_MUTEX_STALLED___41 = 0,
    PTHREAD_MUTEX_STALLED_NP___41 = 0,
    PTHREAD_MUTEX_ROBUST___41 = 1,
    PTHREAD_MUTEX_ROBUST_NP___41 = 1
} ;
#line 81
enum __anonenum__409___22 {
    PTHREAD_PRIO_NONE___41 = 0,
    PTHREAD_PRIO_INHERIT___41 = 1,
    PTHREAD_PRIO_PROTECT___41 = 2
} ;
#line 104
enum __anonenum__410___15 {
    PTHREAD_RWLOCK_PREFER_READER_NP___41 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___41 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___41 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___41 = 0
} ;
#line 124
enum __anonenum__411___15 {
    PTHREAD_INHERIT_SCHED___41 = 0,
    PTHREAD_EXPLICIT_SCHED___41 = 1
} ;
#line 134
enum __anonenum__412___15 {
    PTHREAD_SCOPE_SYSTEM___41 = 0,
    PTHREAD_SCOPE_PROCESS___41 = 1
} ;
#line 144
enum __anonenum__413___15 {
    PTHREAD_PROCESS_PRIVATE___41 = 0,
    PTHREAD_PROCESS_SHARED___41 = 1
} ;
#line 168
enum __anonenum__414___15 {
    PTHREAD_CANCEL_ENABLE___41 = 0,
    PTHREAD_CANCEL_DISABLE___41 = 1
} ;
#line 175
enum __anonenum__415___15 {
    PTHREAD_CANCEL_DEFERRED___41 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___41 = 1
} ;
#line 39 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *gettext(char const   *__msgid ) ;
#line 44
extern  __attribute__((__nothrow__)) char *dgettext(char const   *__domainname , char const   *__msgid ) ;
#line 46
extern  __attribute__((__nothrow__)) char *__dgettext(char const   *__domainname ,
                                                      char const   *__msgid ) ;
#line 51
extern  __attribute__((__nothrow__)) char *dcgettext(char const   *__domainname ,
                                                     char const   *__msgid , int __category ) ;
#line 54
extern  __attribute__((__nothrow__)) char *__dcgettext(char const   *__domainname ,
                                                       char const   *__msgid , int __category ) ;
#line 61
extern  __attribute__((__nothrow__)) char *ngettext(char const   *__msgid1 , char const   *__msgid2 ,
                                                    unsigned long __n ) ;
#line 67
extern  __attribute__((__nothrow__)) char *dngettext(char const   *__domainname ,
                                                     char const   *__msgid1 , char const   *__msgid2 ,
                                                     unsigned long __n ) ;
#line 73
extern  __attribute__((__nothrow__)) char *dcngettext(char const   *__domainname ,
                                                      char const   *__msgid1 , char const   *__msgid2 ,
                                                      unsigned long __n , int __category ) ;
#line 82
extern  __attribute__((__nothrow__)) char *textdomain(char const   *__domainname ) ;
#line 86
extern  __attribute__((__nothrow__)) char *bindtextdomain(char const   *__domainname ,
                                                          char const   *__dirname ) ;
#line 91
extern  __attribute__((__nothrow__)) char *bind_textdomain_codeset(char const   *__domainname ,
                                                                   char const   *__codeset ) ;
#line 122 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *setlocale(int __category , char const   *__locale ) ;
#line 125
extern  __attribute__((__nothrow__)) struct lconv *localeconv(void) ;
#line 141
extern  __attribute__((__nothrow__)) locale_t newlocale(int __category_mask , char const   *__locale ,
                                                        locale_t __base ) ;
#line 176
extern  __attribute__((__nothrow__)) locale_t duplocale(locale_t __dataset ) ;
#line 180
extern  __attribute__((__nothrow__)) void freelocale(locale_t __dataset ) ;
#line 187
extern  __attribute__((__nothrow__)) locale_t uselocale(locale_t __dataset ) ;
#line 143 "/usr/include/stdio.h"
extern FILE *stdin ;
#line 144
extern FILE *stdout ;
#line 145
extern FILE *stderr ;
#line 152
extern  __attribute__((__nothrow__)) int remove(char const   *__filename ) ;
#line 154
extern  __attribute__((__nothrow__)) int rename(char const   *__old , char const   *__new ) ;
#line 158
extern  __attribute__((__nothrow__)) int renameat(int __oldfd , char const   *__old ,
                                                  int __newfd , char const   *__new ) ;
#line 178
extern int fclose(FILE *__stream ) ;
#line 188
extern FILE *tmpfile(void) ;
#line 205
extern  __attribute__((__nothrow__)) char *tmpnam(char [20] ) ;
#line 210
extern  __attribute__((__nothrow__)) char *tmpnam_r(char __s[20] ) ;
#line 222
extern  __attribute__((__nothrow__)) char *tempnam(char const   *__dir , char const   *__pfx ) ;
#line 230
extern int fflush(FILE *__stream ) ;
#line 239
extern int fflush_unlocked(FILE *__stream ) ;
#line 258
extern FILE *fopen(char const   *__filename , char const   *__modes ) ;
#line 265
extern FILE *freopen(char const   *__filename , char const   *__modes , FILE *__stream ) ;
#line 293
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
#line 308
extern  __attribute__((__nothrow__)) FILE *fmemopen(void *__s , size_t __len , char const   *__modes ) ;
#line 314
extern  __attribute__((__nothrow__)) FILE *open_memstream(char **__bufloc , size_t *__sizeloc ) ;
#line 328
extern  __attribute__((__nothrow__)) void setbuf(FILE *__stream , char *__buf ) ;
#line 332
extern  __attribute__((__nothrow__)) int setvbuf(FILE *__stream , char *__buf , int __modes ,
                                                 size_t __n ) ;
#line 338
extern  __attribute__((__nothrow__)) void setbuffer(FILE *__stream , char *__buf ,
                                                    size_t __size ) ;
#line 342
extern  __attribute__((__nothrow__)) void setlinebuf(FILE *__stream ) ;
#line 350
__inline extern int fprintf(FILE *__stream , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 356
__inline extern int printf(char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 358
__inline extern  __attribute__((__nothrow__)) int sprintf(char *__s , char const   *__fmt 
                                                          , ...)  __attribute__((__gnu_inline__)) ;
#line 365
__inline extern int vfprintf(FILE *__stream , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 371
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 373
__inline extern  __attribute__((__nothrow__)) int vsprintf(char *__s , char const   *__fmt ,
                                                           __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 378
__inline extern  __attribute__((__nothrow__)) int snprintf(char *__s , size_t __n ,
                                                           char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 382
__inline extern  __attribute__((__nothrow__)) int vsnprintf(char *__s , size_t __n ,
                                                            char const   *__fmt ,
                                                            __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 403
__inline extern int vdprintf(int __fd , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 406
__inline extern int dprintf(int __fd , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 415
extern int fscanf(FILE *__stream , char const   *__format  , ...) ;
#line 421
extern int scanf(char const   *__format  , ...) ;
#line 423
extern  __attribute__((__nothrow__)) int sscanf(char const   *__s , char const   *__format 
                                                , ...) ;
#line 459
extern int vfscanf(FILE *__s , char const   *__format , __gnuc_va_list __arg ) ;
#line 467
extern int vscanf(char const   *__format , __gnuc_va_list __arg ) ;
#line 471
extern  __attribute__((__nothrow__)) int vsscanf(char const   *__s , char const   *__format ,
                                                 __gnuc_va_list __arg ) ;
#line 513
extern int fgetc(FILE *__stream ) ;
#line 514
extern int getc(FILE *__stream ) ;
#line 520
__inline extern int getchar(void)  __attribute__((__gnu_inline__)) ;
#line 527
__inline extern int getc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 528
__inline extern int getchar_unlocked(void)  __attribute__((__gnu_inline__)) ;
#line 538
__inline extern int fgetc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 549
extern int fputc(int __c , FILE *__stream ) ;
#line 550
extern int putc(int __c , FILE *__stream ) ;
#line 556
__inline extern int putchar(int __c )  __attribute__((__gnu_inline__)) ;
#line 565
__inline extern int fputc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 573
__inline extern int putc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 574
__inline extern int putchar_unlocked(int __c )  __attribute__((__gnu_inline__)) ;
#line 581
extern int getw(FILE *__stream ) ;
#line 584
extern int putw(int __w , FILE *__stream ) ;
#line 592
__inline extern char *fgets(char *__s , int __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 632
extern __ssize_t __getdelim(char **__lineptr , size_t *__n , int __delimiter , FILE *__stream ) ;
#line 635
extern __ssize_t getdelim(char **__lineptr , size_t *__n , int __delimiter , FILE *__stream ) ;
#line 645
extern __ssize_t getline(char **__lineptr , size_t *__n , FILE *__stream ) ;
#line 655
extern int fputs(char const   *__s , FILE *__stream ) ;
#line 661
extern int puts(char const   *__s ) ;
#line 668
extern int ungetc(int __c , FILE *__stream ) ;
#line 675
__inline extern unsigned long fread(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 681
extern unsigned long fwrite(void const   *__ptr , size_t __size , size_t __n , FILE *__s ) ;
#line 702
__inline extern size_t fread_unlocked(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 704
extern size_t fwrite_unlocked(void const   *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 713
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 718
extern long ftell(FILE *__stream ) ;
#line 723
extern void rewind(FILE *__stream ) ;
#line 736
extern int fseeko(FILE *__stream , __off_t __off , int __whence ) ;
#line 741
extern __off_t ftello(FILE *__stream ) ;
#line 760
extern int fgetpos(FILE *__stream , fpos_t *__pos ) ;
#line 765
extern int fsetpos(FILE *__stream , fpos_t *__pos ) ;
#line 786
extern  __attribute__((__nothrow__)) void clearerr(FILE *__stream ) ;
#line 788
extern  __attribute__((__nothrow__)) int feof(FILE *__stream ) ;
#line 790
extern  __attribute__((__nothrow__)) int ferror(FILE *__stream ) ;
#line 794
extern  __attribute__((__nothrow__)) void clearerr_unlocked(FILE *__stream ) ;
#line 795
__inline extern  __attribute__((__nothrow__)) int feof_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 796
__inline extern  __attribute__((__nothrow__)) int ferror_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 804
extern void perror(char const   *__s ) ;
#line 809
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 814
extern  __attribute__((__nothrow__)) int fileno_unlocked(FILE *__stream ) ;
#line 823
extern int pclose(FILE *__stream ) ;
#line 829
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 837
extern  __attribute__((__nothrow__)) char *ctermid(char *__s ) ;
#line 867
extern  __attribute__((__nothrow__)) void flockfile(FILE *__stream ) ;
#line 871
extern  __attribute__((__nothrow__)) int ftrylockfile(FILE *__stream ) ;
#line 874
extern  __attribute__((__nothrow__)) void funlockfile(FILE *__stream ) ;
#line 885
extern int __uflow(FILE * ) ;
#line 886
extern int __overflow(FILE * , int  ) ;
#line 47 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar(void)  __attribute__((__gnu_inline__)) ;
#line 47 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar(void) 
{ 
  int __cil_tmp1 ;

  {
  {
#line 49
  __cil_tmp1 = getc(stdin);
  }
#line 49
  return (__cil_tmp1);
}
}
#line 56
__inline extern int fgetc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 56 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int fgetc_unlocked(FILE *__fp ) 
{ 
  long __cil_tmp2 ;
  int __cil_tmp3 ;
  char *__cil_tmp4 ;
  int tmp ;

  {
  {
#line 58
  __cil_tmp2 = __builtin_expect((long )(__fp->_IO_read_ptr >= __fp->_IO_read_end),
                                (long )0);
  }
#line 58
  if (__cil_tmp2) {
    {
#line 58
    __cil_tmp3 = __uflow(__fp);
#line 58
    tmp = __cil_tmp3;
    }
  } else {
#line 58
    (__fp->_IO_read_ptr) ++;
#line 58
    tmp = (int )*((unsigned char *)__fp->_IO_read_ptr);
  }
#line 58
  return (tmp);
}
}
#line 73
__inline extern int getchar_unlocked(void)  __attribute__((__gnu_inline__)) ;
#line 73 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar_unlocked(void) 
{ 
  long __cil_tmp1 ;
  int __cil_tmp2 ;
  char *__cil_tmp3 ;
  int tmp ;

  {
  {
#line 75
  __cil_tmp1 = __builtin_expect((long )(stdin->_IO_read_ptr >= stdin->_IO_read_end),
                                (long )0);
  }
#line 75
  if (__cil_tmp1) {
    {
#line 75
    __cil_tmp2 = __uflow(stdin);
#line 75
    tmp = __cil_tmp2;
    }
  } else {
#line 75
    (stdin->_IO_read_ptr) ++;
#line 75
    tmp = (int )*((unsigned char *)stdin->_IO_read_ptr);
  }
#line 75
  return (tmp);
}
}
#line 82
__inline extern int putchar(int __c )  __attribute__((__gnu_inline__)) ;
#line 82 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int putchar(int __c ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 84
  __cil_tmp2 = putc(__c, stdout);
  }
#line 84
  return (__cil_tmp2);
}
}
#line 91
__inline extern int fputc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 91 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int fputc_unlocked(int __c , FILE *__stream ) 
{ 
  long __cil_tmp3 ;
  int __cil_tmp4 ;
  char *__cil_tmp5 ;
  int tmp ;

  {
  {
#line 93
  __cil_tmp3 = __builtin_expect((long )(__stream->_IO_write_ptr >= __stream->_IO_write_end),
                                (long )0);
  }
#line 93
  if (__cil_tmp3) {
    {
#line 93
    __cil_tmp4 = __overflow(__stream, (int )((unsigned char )__c));
#line 93
    tmp = __cil_tmp4;
    }
  } else {
#line 93
    __cil_tmp5 = __stream->_IO_write_ptr;
#line 93
    (__stream->_IO_write_ptr) ++;
#line 93
    *__cil_tmp5 = (char )__c;
#line 93
    tmp = (int )((unsigned char )*__cil_tmp5);
  }
#line 93
  return (tmp);
}
}
#line 108
__inline extern int putchar_unlocked(int __c )  __attribute__((__gnu_inline__)) ;
#line 108 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int putchar_unlocked(int __c ) 
{ 
  long __cil_tmp2 ;
  int __cil_tmp3 ;
  char *__cil_tmp4 ;
  int tmp ;

  {
  {
#line 110
  __cil_tmp2 = __builtin_expect((long )(stdout->_IO_write_ptr >= stdout->_IO_write_end),
                                (long )0);
  }
#line 110
  if (__cil_tmp2) {
    {
#line 110
    __cil_tmp3 = __overflow(stdout, (int )((unsigned char )__c));
#line 110
    tmp = __cil_tmp3;
    }
  } else {
#line 110
    __cil_tmp4 = stdout->_IO_write_ptr;
#line 110
    (stdout->_IO_write_ptr) ++;
#line 110
    *__cil_tmp4 = (char )__c;
#line 110
    tmp = (int )((unsigned char )*__cil_tmp4);
  }
#line 110
  return (tmp);
}
}
#line 128
__inline extern  __attribute__((__nothrow__)) int feof_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 128 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int feof_unlocked(FILE *__stream ) 
{ 


  {
#line 130
  return ((__stream->_flags & 16) != 0);
}
}
#line 135
__inline extern  __attribute__((__nothrow__)) int ferror_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 135 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ferror_unlocked(FILE *__stream ) 
{ 


  {
#line 137
  return ((__stream->_flags & 32) != 0);
}
}
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
extern  __attribute__((__nothrow__)) int __sprintf_chk(char *__s , int __flag , size_t __slen ,
                                                       char const   *__format  , ...) ;
#line 29
extern  __attribute__((__nothrow__)) int __vsprintf_chk(char *__s , int __flag , size_t __slen ,
                                                        char const   *__format , __gnuc_va_list __ap ) ;
#line 36
__inline extern  __attribute__((__nothrow__)) int sprintf(char *__s , char const   *__fmt 
                                                          , ...)  __attribute__((__gnu_inline__)) ;
#line 36 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int sprintf(char *__s , char const   *__fmt  , ...) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 38
  __cil_tmp3 = __builtin_object_size(__s, 1);
  }
  {
#line 38
  __cil_tmp4 = __builtin_va_arg_pack();
#line 38
  __cil_tmp5 = __builtin___sprintf_chk(__s, 1, __cil_tmp3, __fmt, __cil_tmp4);
  }
#line 38
  return (__cil_tmp5);
}
}
#line 49
__inline extern  __attribute__((__nothrow__)) int vsprintf(char *__s , char const   *__fmt ,
                                                           __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 49 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vsprintf(char *__s , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 52
  __cil_tmp4 = __builtin_object_size(__s, 1);
#line 52
  __cil_tmp5 = __builtin___vsprintf_chk(__s, 1, __cil_tmp4, __fmt, __ap);
  }
#line 52
  return (__cil_tmp5);
}
}
#line 58
extern  __attribute__((__nothrow__)) int __snprintf_chk(char *__s , size_t __n , int __flag ,
                                                        size_t __slen , char const   *__format 
                                                        , ...) ;
#line 62
extern  __attribute__((__nothrow__)) int __vsnprintf_chk(char *__s , size_t __n ,
                                                         int __flag , size_t __slen ,
                                                         char const   *__format ,
                                                         __gnuc_va_list __ap ) ;
#line 68
__inline extern  __attribute__((__nothrow__)) int snprintf(char *__s , size_t __n ,
                                                           char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 68 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int snprintf(char *__s , size_t __n , char const   *__fmt  , ...) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 71
  __cil_tmp4 = __builtin_object_size(__s, 1);
  }
  {
#line 71
  __cil_tmp5 = __builtin_va_arg_pack();
#line 71
  __cil_tmp6 = __builtin___snprintf_chk(__s, __n, 1, __cil_tmp4, __fmt, __cil_tmp5);
  }
#line 71
  return (__cil_tmp6);
}
}
#line 82
__inline extern  __attribute__((__nothrow__)) int vsnprintf(char *__s , size_t __n ,
                                                            char const   *__fmt ,
                                                            __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 82 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vsnprintf(char *__s , size_t __n , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 85
  __cil_tmp5 = __builtin_object_size(__s, 1);
#line 85
  __cil_tmp6 = __builtin___vsnprintf_chk(__s, __n, 1, __cil_tmp5, __fmt, __ap);
  }
#line 85
  return (__cil_tmp6);
}
}
#line 93
extern int __fprintf_chk(FILE *__stream , int __flag , char const   *__format  , ...) ;
#line 95
extern int __printf_chk(int __flag , char const   *__format  , ...) ;
#line 96
extern int __vfprintf_chk(FILE *__stream , int __flag , char const   *__format , __gnuc_va_list __ap ) ;
#line 98
extern int __vprintf_chk(int __flag , char const   *__format , __gnuc_va_list __ap ) ;
#line 103
__inline extern int fprintf(FILE *__stream , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 103 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int fprintf(FILE *__stream , char const   *__fmt  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 105
  __cil_tmp3 = __builtin_va_arg_pack();
#line 105
  __cil_tmp4 = __fprintf_chk(__stream, 1, __fmt, __cil_tmp3);
  }
#line 105
  return (__cil_tmp4);
}
}
#line 110
__inline extern int printf(char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 110 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int printf(char const   *__fmt  , ...) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;

  {
  {
#line 112
  __cil_tmp2 = __builtin_va_arg_pack();
#line 112
  __cil_tmp3 = __printf_chk(1, __fmt, __cil_tmp2);
  }
#line 112
  return (__cil_tmp3);
}
}
#line 122
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 122 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 125
  __cil_tmp3 = __vfprintf_chk(stdout, 1, __fmt, __ap);
  }
#line 125
  return (__cil_tmp3);
}
}
#line 132
__inline extern int vfprintf(FILE *__stream , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 132 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vfprintf(FILE *__stream , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 135
  __cil_tmp4 = __vfprintf_chk(__stream, 1, __fmt, __ap);
  }
#line 135
  return (__cil_tmp4);
}
}
#line 139
extern int __dprintf_chk(int __fd , int __flag , char const   *__fmt  , ...) ;
#line 141
extern int __vdprintf_chk(int __fd , int __flag , char const   *__fmt , __gnuc_va_list __arg ) ;
#line 147
__inline extern int dprintf(int __fd , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 147 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int dprintf(int __fd , char const   *__fmt  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 149
  __cil_tmp3 = __builtin_va_arg_pack();
#line 149
  __cil_tmp4 = __dprintf_chk(__fd, 1, __fmt, __cil_tmp3);
  }
#line 149
  return (__cil_tmp4);
}
}
#line 158
__inline extern int vdprintf(int __fd , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 158 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vdprintf(int __fd , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 160
  __cil_tmp4 = __vdprintf_chk(__fd, 1, __fmt, __ap);
  }
#line 160
  return (__cil_tmp4);
}
}
#line 248
extern char *__fgets_chk(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 251
extern char *__fgets_alias(char *__s , int __n , FILE *__stream ) ;
#line 255
extern char *__fgets_chk_warn(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 262
__inline extern char *fgets(char *__s , int __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 262 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern char *fgets(char *__s , int __n , FILE *__stream ) 
{ 
  size_t sz ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  char *__cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 264
  __cil_tmp5 = __builtin_object_size(__s, 1);
#line 264
  sz = __cil_tmp5;
#line 265
  __cil_tmp7 = __builtin_constant_p((unsigned long )__n <= sz / sizeof(char ));
  }
  {
#line 265
  __cil_tmp6 = __builtin_constant_p(__n);
  }
#line 265
  if (__cil_tmp6) {
#line 265
    if (__n > 0) {
#line 265
      if (__cil_tmp7) {
#line 265
        if ((unsigned long )__n <= sz / sizeof(char )) {
          {
#line 266
          __cil_tmp8 = __fgets_alias(__s, __n, __stream);
          }
#line 266
          return (__cil_tmp8);
        }
      }
    }
  }
  {
#line 267
  __cil_tmp10 = __builtin_constant_p((unsigned long )__n <= sz / sizeof(char ));
  }
  {
#line 267
  __cil_tmp9 = __builtin_constant_p(__n);
  }
#line 267
  if (__cil_tmp9) {
#line 267
    if (__n > 0) {
#line 267
      if (__cil_tmp10) {
#line 267
        if (! ((unsigned long )__n <= sz / sizeof(char ))) {
          {
#line 268
          __cil_tmp11 = __fgets_chk_warn(__s, sz, __n, __stream);
          }
#line 268
          return (__cil_tmp11);
        }
      }
    }
  }
  {
#line 269
  __cil_tmp12 = __fgets_chk(__s, sz, __n, __stream);
  }
#line 269
  return (__cil_tmp12);
}
}
#line 272
extern size_t __fread_chk(void *__ptr , size_t __ptrlen , size_t __size , size_t __n ,
                          FILE *__stream ) ;
#line 275
extern size_t __fread_alias(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 279
extern size_t __fread_chk_warn(void *__ptr , size_t __ptrlen , size_t __size , size_t __n ,
                               FILE *__stream ) ;
#line 288
__inline extern unsigned long fread(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 288 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern unsigned long fread(void *__ptr , size_t __size , size_t __n , FILE *__stream ) 
{ 
  size_t sz ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  size_t __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  size_t __cil_tmp12 ;
  size_t __cil_tmp13 ;

  {
  {
#line 291
  __cil_tmp6 = __builtin_object_size(__ptr, 0);
#line 291
  sz = __cil_tmp6;
#line 292
  __cil_tmp8 = __builtin_constant_p((unsigned long )__n <= sz / __size);
  }
  {
#line 292
  __cil_tmp7 = __builtin_constant_p(__n);
  }
#line 292
  if (__cil_tmp8) {
#line 292
    if ((unsigned long )__n <= sz / __size) {
      {
#line 293
      __cil_tmp9 = __fread_alias(__ptr, __size, __n, __stream);
      }
#line 293
      return (__cil_tmp9);
    }
  }
  {
#line 294
  __cil_tmp11 = __builtin_constant_p((unsigned long )__n <= sz / __size);
  }
  {
#line 294
  __cil_tmp10 = __builtin_constant_p(__n);
  }
#line 294
  if (__cil_tmp11) {
#line 294
    if (! ((unsigned long )__n <= sz / __size)) {
      {
#line 295
      __cil_tmp12 = __fread_chk_warn(__ptr, sz, __size, __n, __stream);
      }
#line 295
      return (__cil_tmp12);
    }
  }
  {
#line 296
  __cil_tmp13 = __fread_chk(__ptr, sz, __size, __n, __stream);
  }
#line 296
  return (__cil_tmp13);
}
}
#line 327
extern size_t __fread_unlocked_chk(void *__ptr , size_t __ptrlen , size_t __size ,
                                   size_t __n , FILE *__stream ) ;
#line 330
extern size_t __fread_unlocked_alias(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 334
extern size_t __fread_unlocked_chk_warn(void *__ptr , size_t __ptrlen , size_t __size ,
                                        size_t __n , FILE *__stream ) ;
#line 343
__inline extern size_t fread_unlocked(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 343 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern size_t fread_unlocked(void *__ptr , size_t __size , size_t __n , FILE *__stream ) 
{ 
  size_t sz ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  size_t __cnt ;
  char *__cptr ;
  int __c ;
  int __cil_tmp14 ;
  char *__cil_tmp15 ;
  size_t __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  size_t __cil_tmp19 ;
  size_t __cil_tmp20 ;

  {
  {
#line 346
  __cil_tmp6 = __builtin_object_size(__ptr, 0);
#line 346
  sz = __cil_tmp6;
#line 347
  __cil_tmp8 = __builtin_constant_p((unsigned long )__n <= sz / __size);
  }
  {
#line 347
  __cil_tmp7 = __builtin_constant_p(__n);
  }
#line 347
  if (__cil_tmp8) {
#line 347
    if ((unsigned long )__n <= sz / __size) {
      {
#line 350
      __cil_tmp10 = __builtin_constant_p(__n);
      }
      {
#line 350
      __cil_tmp9 = __builtin_constant_p(__size);
      }
#line 350
      if (__cil_tmp9) {
#line 350
        if (__cil_tmp10) {
#line 350
          if ((__size | __n) < 1UL << (8UL * sizeof(size_t )) / 2UL) {
#line 350
            if (__size * __n <= 8UL) {
#line 355
              __cnt = __size * __n;
#line 356
              __cptr = (char *)__ptr;
#line 357
              if (__cnt == 0UL) {
#line 358
                return ((size_t )0);
              }
              {
#line 360
              while (1) {
                while_continue: /* CIL Label */ ;
#line 360
                if (! (__cnt > 0UL)) {
#line 360
                  goto while_break;
                }
                {
#line 362
                __cil_tmp14 = getc_unlocked(__stream);
#line 362
                __c = __cil_tmp14;
                }
#line 363
                if (__c == -1) {
#line 364
                  goto while_break;
                }
#line 365
                __cil_tmp15 = __cptr;
#line 365
                __cptr ++;
#line 365
                *__cil_tmp15 = (char )__c;
#line 360
                __cnt --;
              }
              while_break: /* CIL Label */ ;
              }
#line 367
              return ((unsigned long )(__cptr - (char *)__ptr) / __size);
            }
          }
        }
      }
      {
#line 370
      __cil_tmp16 = __fread_unlocked_alias(__ptr, __size, __n, __stream);
      }
#line 370
      return (__cil_tmp16);
    }
  }
  {
#line 372
  __cil_tmp18 = __builtin_constant_p((unsigned long )__n <= sz / __size);
  }
  {
#line 372
  __cil_tmp17 = __builtin_constant_p(__n);
  }
#line 372
  if (__cil_tmp18) {
#line 372
    if (! ((unsigned long )__n <= sz / __size)) {
      {
#line 373
      __cil_tmp19 = __fread_unlocked_chk_warn(__ptr, sz, __size, __n, __stream);
      }
#line 373
      return (__cil_tmp19);
    }
  }
  {
#line 374
  __cil_tmp20 = __fread_unlocked_chk(__ptr, sz, __size, __n, __stream);
  }
#line 374
  return (__cil_tmp20);
}
}
#line 72 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) clock_t clock(void) ;
#line 76
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 79
extern  __attribute__((__nothrow__)) double difftime(time_t __time1 , time_t __time0 ) ;
#line 83
extern  __attribute__((__nothrow__)) time_t mktime(struct tm *__tp ) ;
#line 100
extern  __attribute__((__nothrow__)) size_t strftime(char *__s , size_t __maxsize ,
                                                     char const   *__format , struct tm *__tp ) ;
#line 116
extern  __attribute__((__nothrow__)) size_t strftime_l(char *__s , size_t __maxsize ,
                                                       char const   *__format , struct tm *__tp ,
                                                       locale_t __loc ) ;
#line 132
extern  __attribute__((__nothrow__)) struct tm *gmtime(time_t *__timer ) ;
#line 136
extern  __attribute__((__nothrow__)) struct tm *localtime(time_t *__timer ) ;
#line 154
extern  __attribute__((__nothrow__)) struct tm *gmtime_r(time_t *__timer , struct tm *__tp ) ;
#line 159
extern  __attribute__((__nothrow__)) struct tm *localtime_r(time_t *__timer , struct tm *__tp ) ;
#line 179
extern  __attribute__((__nothrow__)) char *asctime(struct tm *__tp ) ;
#line 183
extern  __attribute__((__nothrow__)) char *ctime(time_t *__timer ) ;
#line 197
extern  __attribute__((__nothrow__)) char *asctime_r(struct tm *__tp , char *__buf ) ;
#line 202
extern  __attribute__((__nothrow__)) char *ctime_r(time_t *__timer , char *__buf ) ;
#line 217
extern char *__tzname[2] ;
#line 218
extern int __daylight ;
#line 219
extern long __timezone ;
#line 224
extern char *tzname[2] ;
#line 228
extern  __attribute__((__nothrow__)) void tzset(void) ;
#line 232
extern int daylight ;
#line 233
extern long timezone ;
#line 249
extern  __attribute__((__nothrow__)) time_t timegm(struct tm *__tp ) ;
#line 251
extern  __attribute__((__nothrow__)) time_t timelocal(struct tm *__tp ) ;
#line 262
extern  __attribute__((__nothrow__)) int dysize(int __year ) ;
#line 272
extern int nanosleep(struct timespec *__requested_time , struct timespec *__remaining ) ;
#line 276
extern  __attribute__((__nothrow__)) int clock_getres(clockid_t __clock_id , struct timespec *__res ) ;
#line 279
extern  __attribute__((__nothrow__)) int clock_gettime(clockid_t __clock_id , struct timespec *__tp ) ;
#line 282
extern  __attribute__((__nothrow__)) int clock_settime(clockid_t __clock_id , struct timespec *__tp ) ;
#line 311
extern int clock_nanosleep(clockid_t __clock_id , int __flags , struct timespec *__req ,
                           struct timespec *__rem ) ;
#line 326
extern  __attribute__((__nothrow__)) int clock_getcpuclockid(pid_t __pid , clockid_t *__clock_id ) ;
#line 331
extern  __attribute__((__nothrow__)) int timer_create(clockid_t __clock_id , struct sigevent *__evp ,
                                                      timer_t *__timerid ) ;
#line 336
extern  __attribute__((__nothrow__)) int timer_delete(timer_t __timerid ) ;
#line 340
extern  __attribute__((__nothrow__)) int timer_settime(timer_t __timerid , int __flags ,
                                                       struct itimerspec *__value ,
                                                       struct itimerspec *__ovalue ) ;
#line 345
extern  __attribute__((__nothrow__)) int timer_gettime(timer_t __timerid , struct itimerspec *__value ) ;
#line 364
extern  __attribute__((__nothrow__)) int timer_getoverrun(timer_t __timerid ) ;
#line 371
extern  __attribute__((__nothrow__)) int timespec_get(struct timespec *__ts , int __base ) ;
#line 43 "/usr/include/string.h"
__inline extern  __attribute__((__nothrow__)) void *memcpy(void *__dest , void const   *__src ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 47
__inline extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 54
extern  __attribute__((__nothrow__)) void *memccpy(void *__dest , void const   *__src ,
                                                   int __c , size_t __n ) ;
#line 61
__inline extern  __attribute__((__nothrow__)) void *memset(void *__dest , int __ch ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 64
extern  __attribute__((__nothrow__)) int memcmp(void const   *__s1 , void const   *__s2 ,
                                                size_t __n ) ;
#line 80
extern  __attribute__((__nothrow__)) int __memcmpeq(void const   *__s1 , void const   *__s2 ,
                                                    size_t __n ) ;
#line 107
extern  __attribute__((__nothrow__)) void *memchr(void const   *__s , int __c , size_t __n ) ;
#line 141
__inline extern  __attribute__((__nothrow__)) char *strcpy(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 144
__inline extern  __attribute__((__nothrow__)) char *strncpy(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 149
__inline extern  __attribute__((__nothrow__)) char *strcat(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 152
__inline extern  __attribute__((__nothrow__)) char *strncat(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 156
extern  __attribute__((__nothrow__)) int strcmp(char const   *__s1 , char const   *__s2 ) ;
#line 159
extern  __attribute__((__nothrow__)) int strncmp(char const   *__s1 , char const   *__s2 ,
                                                 size_t __n ) ;
#line 163
extern  __attribute__((__nothrow__)) int strcoll(char const   *__s1 , char const   *__s2 ) ;
#line 166
extern  __attribute__((__nothrow__)) unsigned long strxfrm(char *__dest , char const   *__src ,
                                                           size_t __n ) ;
#line 175
extern  __attribute__((__nothrow__)) int strcoll_l(char const   *__s1 , char const   *__s2 ,
                                                   locale_t __l ) ;
#line 179
extern  __attribute__((__nothrow__)) size_t strxfrm_l(char *__dest , char const   *__src ,
                                                      size_t __n , locale_t __l ) ;
#line 187
extern  __attribute__((__nothrow__)) char *strdup(char const   *__s ) ;
#line 195
extern  __attribute__((__nothrow__)) char *strndup(char const   *__string , size_t __n ) ;
#line 246
extern  __attribute__((__nothrow__)) char *strchr(char const   *__s , int __c ) ;
#line 273
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c ) ;
#line 293
extern  __attribute__((__nothrow__)) unsigned long strcspn(char const   *__s , char const   *__reject ) ;
#line 297
extern  __attribute__((__nothrow__)) unsigned long strspn(char const   *__s , char const   *__accept ) ;
#line 323
extern  __attribute__((__nothrow__)) char *strpbrk(char const   *__s , char const   *__accept ) ;
#line 350
extern  __attribute__((__nothrow__)) char *strstr(char const   *__haystack , char const   *__needle ) ;
#line 356
extern  __attribute__((__nothrow__)) char *strtok(char *__s , char const   *__delim ) ;
#line 361
extern  __attribute__((__nothrow__)) char *__strtok_r(char *__s , char const   *__delim ,
                                                      char **__save_ptr ) ;
#line 366
extern  __attribute__((__nothrow__)) char *strtok_r(char *__s , char const   *__delim ,
                                                    char **__save_ptr ) ;
#line 407
extern  __attribute__((__nothrow__)) unsigned long strlen(char const   *__s ) ;
#line 413
extern  __attribute__((__nothrow__)) size_t strnlen(char const   *__string , size_t __maxlen ) ;
#line 419
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 432
extern  __attribute__((__nothrow__)) int strerror_r(int __errnum , char *__buf , size_t __buflen ) ;
#line 458
extern  __attribute__((__nothrow__)) char *strerror_l(int __errnum , locale_t __l ) ;
#line 34 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) int bcmp(void const   *__s1 , void const   *__s2 ,
                                              size_t __n ) ;
#line 38
__inline extern  __attribute__((__nothrow__)) void bcopy(void const   *__src , void *__dest ,
                                                         size_t __len )  __attribute__((__gnu_inline__)) ;
#line 42
__inline extern  __attribute__((__nothrow__)) void bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 68
extern  __attribute__((__nothrow__)) char *index(char const   *__s , int __c ) ;
#line 96
extern  __attribute__((__nothrow__)) char *rindex(char const   *__s , int __c ) ;
#line 104
extern  __attribute__((__nothrow__)) int ffs(int __i ) ;
#line 110
extern  __attribute__((__nothrow__)) int ffsl(long __l ) ;
#line 111
extern  __attribute__((__nothrow__)) int ffsll(long long __ll ) ;
#line 116
extern  __attribute__((__nothrow__)) int strcasecmp(char const   *__s1 , char const   *__s2 ) ;
#line 120
extern  __attribute__((__nothrow__)) int strncasecmp(char const   *__s1 , char const   *__s2 ,
                                                     size_t __n ) ;
#line 128
extern  __attribute__((__nothrow__)) int strcasecmp_l(char const   *__s1 , char const   *__s2 ,
                                                      locale_t __loc ) ;
#line 133
extern  __attribute__((__nothrow__)) int strncasecmp_l(char const   *__s1 , char const   *__s2 ,
                                                       size_t __n , locale_t __loc ) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern  __attribute__((__nothrow__)) void bcopy(void const   *__src , void *__dest ,
                                                         size_t __len )  __attribute__((__gnu_inline__)) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern void bcopy(void const   *__src , void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;

  {
  {
#line 25
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 25
  __builtin___memmove_chk(__dest, __src, __len, __cil_tmp4);
  }
  return;
}
}
#line 30
__inline extern  __attribute__((__nothrow__)) void bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 30 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern void bzero(void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp3 ;

  {
  {
#line 32
  __cil_tmp3 = __builtin_object_size(__dest, 0);
#line 32
  __builtin___memset_chk(__dest, '\000', __len, __cil_tmp3);
  }
  return;
}
}
#line 466 "/usr/include/string.h"
__inline extern  __attribute__((__nothrow__)) void explicit_bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 471
extern  __attribute__((__nothrow__)) char *strsep(char **__stringp , char const   *__delim ) ;
#line 478
extern  __attribute__((__nothrow__)) char *strsignal(int __sig ) ;
#line 489
extern  __attribute__((__nothrow__)) char *__stpcpy(char *__dest , char const   *__src ) ;
#line 491
__inline extern  __attribute__((__nothrow__)) char *stpcpy(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 496
extern  __attribute__((__nothrow__)) char *__stpncpy(char *__dest , char const   *__src ,
                                                     size_t __n ) ;
#line 499
__inline extern  __attribute__((__nothrow__)) char *stpncpy(char *__dest , char const   *__src ,
                                                            size_t __n )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 26 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern  __attribute__((__nothrow__)) void *memcpy(void *__dest , void const   *__src ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 26 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *memcpy(void *__dest , void const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 29
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 29
  __cil_tmp5 = __builtin___memcpy_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 29
  return (__cil_tmp5);
}
}
#line 34
__inline extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 34 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *memmove(void *__dest , void const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 36
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 36
  __cil_tmp5 = __builtin___memmove_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 36
  return (__cil_tmp5);
}
}
#line 57
__inline extern  __attribute__((__nothrow__)) void *memset(void *__dest , int __ch ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 57 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *memset(void *__dest , int __ch , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 59
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 59
  __cil_tmp5 = __builtin___memset_chk(__dest, __ch, __len, __cil_tmp4);
  }
#line 59
  return (__cil_tmp5);
}
}
#line 66
 __attribute__((__nothrow__)) void __explicit_bzero_chk(void *__dest , size_t __len ,
                                                        size_t __destlen ) ;
#line 70
__inline extern  __attribute__((__nothrow__)) void explicit_bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 70 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void explicit_bzero(void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp3 ;

  {
  {
#line 72
  __cil_tmp3 = __builtin_object_size(__dest, 0);
#line 72
  __explicit_bzero_chk(__dest, __len, __cil_tmp3);
  }
  return;
}
}
#line 77
__inline extern  __attribute__((__nothrow__)) char *strcpy(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 77 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strcpy(char *__dest , char const   *__src ) 
{ 
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 79
  __cil_tmp3 = __builtin_object_size(__dest, 1);
#line 79
  __cil_tmp4 = __builtin___strcpy_chk(__dest, __src, __cil_tmp3);
  }
#line 79
  return (__cil_tmp4);
}
}
#line 84
__inline extern  __attribute__((__nothrow__)) char *stpcpy(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 84 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *stpcpy(char *__dest , char const   *__src ) 
{ 
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 86
  __cil_tmp3 = __builtin_object_size(__dest, 1);
#line 86
  __cil_tmp4 = __builtin___stpcpy_chk(__dest, __src, __cil_tmp3);
  }
#line 86
  return (__cil_tmp4);
}
}
#line 92
__inline extern  __attribute__((__nothrow__)) char *strncpy(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 92 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strncpy(char *__dest , char const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 95
  __cil_tmp4 = __builtin_object_size(__dest, 1);
#line 95
  __cil_tmp5 = __builtin___strncpy_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 95
  return (__cil_tmp5);
}
}
#line 102
__inline extern  __attribute__((__nothrow__)) char *stpncpy(char *__dest , char const   *__src ,
                                                            size_t __n )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 102 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *stpncpy(char *__dest , char const   *__src , size_t __n ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 104
  __cil_tmp4 = __builtin_object_size(__dest, 1);
#line 104
  __cil_tmp5 = __builtin___stpncpy_chk(__dest, __src, __n, __cil_tmp4);
  }
#line 104
  return (__cil_tmp5);
}
}
#line 128
__inline extern  __attribute__((__nothrow__)) char *strcat(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 128 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strcat(char *__dest , char const   *__src ) 
{ 
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 130
  __cil_tmp3 = __builtin_object_size(__dest, 1);
#line 130
  __cil_tmp4 = __builtin___strcat_chk(__dest, __src, __cil_tmp3);
  }
#line 130
  return (__cil_tmp4);
}
}
#line 135
__inline extern  __attribute__((__nothrow__)) char *strncat(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 135 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strncat(char *__dest , char const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 138
  __cil_tmp4 = __builtin_object_size(__dest, 1);
#line 138
  __cil_tmp5 = __builtin___strncat_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 138
  return (__cil_tmp5);
}
}
#line 70 "/usr/include/glib-2.0/glib/garray.h"
extern GArray *g_array_new(gboolean zero_terminated , gboolean clear_ , guint element_size ) ;
#line 74
extern gpointer g_array_steal(GArray *array , gsize *len ) ;
#line 77
extern GArray *g_array_sized_new(gboolean zero_terminated , gboolean clear_ , guint element_size ,
                                 guint reserved_size ) ;
#line 82
extern GArray *g_array_copy(GArray *array ) ;
#line 84
extern gchar *g_array_free(GArray *array , gboolean free_segment ) ;
#line 87
extern GArray *g_array_ref(GArray *array ) ;
#line 89
extern void g_array_unref(GArray *array ) ;
#line 91
extern guint g_array_get_element_size(GArray *array ) ;
#line 93
extern GArray *g_array_append_vals(GArray *array , gconstpointer data , guint len ) ;
#line 97
extern GArray *g_array_prepend_vals(GArray *array , gconstpointer data , guint len ) ;
#line 101
extern GArray *g_array_insert_vals(GArray *array , guint index_ , gconstpointer data ,
                                   guint len ) ;
#line 106
extern GArray *g_array_set_size(GArray *array , guint length ) ;
#line 109
extern GArray *g_array_remove_index(GArray *array , guint index_ ) ;
#line 112
extern GArray *g_array_remove_index_fast(GArray *array , guint index_ ) ;
#line 115
extern GArray *g_array_remove_range(GArray *array , guint index_ , guint length ) ;
#line 119
extern void g_array_sort(GArray *array , GCompareFunc compare_func ) ;
#line 122
extern void g_array_sort_with_data(GArray *array , GCompareDataFunc compare_func ,
                                   gpointer user_data ) ;
#line 126
extern gboolean g_array_binary_search(GArray *array , gconstpointer target , GCompareFunc compare_func ,
                                      guint *out_match_index ) ;
#line 131
extern void g_array_set_clear_func(GArray *array , GDestroyNotify clear_func ) ;
#line 140
extern GPtrArray *g_ptr_array_new(void) ;
#line 142
extern GPtrArray *g_ptr_array_new_with_free_func(GDestroyNotify element_free_func ) ;
#line 144
extern gpointer *g_ptr_array_steal(GPtrArray *array , gsize *len ) ;
#line 147
extern GPtrArray *g_ptr_array_copy(GPtrArray *array , GCopyFunc func , gpointer user_data ) ;
#line 151
extern GPtrArray *g_ptr_array_sized_new(guint reserved_size ) ;
#line 153
extern GPtrArray *g_ptr_array_new_full(guint reserved_size , GDestroyNotify element_free_func ) ;
#line 156
extern gpointer *g_ptr_array_free(GPtrArray *array , gboolean free_seg ) ;
#line 159
extern GPtrArray *g_ptr_array_ref(GPtrArray *array ) ;
#line 161
extern void g_ptr_array_unref(GPtrArray *array ) ;
#line 163
extern void g_ptr_array_set_free_func(GPtrArray *array , GDestroyNotify element_free_func ) ;
#line 166
extern void g_ptr_array_set_size(GPtrArray *array , gint length ) ;
#line 169
extern gpointer g_ptr_array_remove_index(GPtrArray *array , guint index_ ) ;
#line 172
extern gpointer g_ptr_array_remove_index_fast(GPtrArray *array , guint index_ ) ;
#line 175
extern gpointer g_ptr_array_steal_index(GPtrArray *array , guint index_ ) ;
#line 178
extern gpointer g_ptr_array_steal_index_fast(GPtrArray *array , guint index_ ) ;
#line 181
extern gboolean g_ptr_array_remove(GPtrArray *array , gpointer data ) ;
#line 184
extern gboolean g_ptr_array_remove_fast(GPtrArray *array , gpointer data ) ;
#line 187
extern GPtrArray *g_ptr_array_remove_range(GPtrArray *array , guint index_ , guint length ) ;
#line 191
extern void g_ptr_array_add(GPtrArray *array , gpointer data ) ;
#line 194
extern void g_ptr_array_extend(GPtrArray *array_to_extend , GPtrArray *array , GCopyFunc func ,
                               gpointer user_data ) ;
#line 199
extern void g_ptr_array_extend_and_steal(GPtrArray *array_to_extend , GPtrArray *array ) ;
#line 202
extern void g_ptr_array_insert(GPtrArray *array , gint index_ , gpointer data ) ;
#line 206
extern void g_ptr_array_sort(GPtrArray *array , GCompareFunc compare_func ) ;
#line 209
extern void g_ptr_array_sort_with_data(GPtrArray *array , GCompareDataFunc compare_func ,
                                       gpointer user_data ) ;
#line 213
extern void g_ptr_array_foreach(GPtrArray *array , GFunc func , gpointer user_data ) ;
#line 217
extern gboolean g_ptr_array_find(GPtrArray *haystack , gconstpointer needle , guint *index_ ) ;
#line 221
extern gboolean g_ptr_array_find_with_equal_func(GPtrArray *haystack , gconstpointer needle ,
                                                 GEqualFunc equal_func , guint *index_ ) ;
#line 232
extern GByteArray *g_byte_array_new(void) ;
#line 234
extern GByteArray *g_byte_array_new_take(guint8 *data , gsize len ) ;
#line 237
extern guint8 *g_byte_array_steal(GByteArray *array , gsize *len ) ;
#line 240
extern GByteArray *g_byte_array_sized_new(guint reserved_size ) ;
#line 242
extern guint8 *g_byte_array_free(GByteArray *array , gboolean free_segment ) ;
#line 245
extern GBytes *g_byte_array_free_to_bytes(GByteArray *array ) ;
#line 247
extern GByteArray *g_byte_array_ref(GByteArray *array ) ;
#line 249
extern void g_byte_array_unref(GByteArray *array ) ;
#line 251
extern GByteArray *g_byte_array_append(GByteArray *array , guint8 *data , guint len ) ;
#line 255
extern GByteArray *g_byte_array_prepend(GByteArray *array , guint8 *data , guint len ) ;
#line 259
extern GByteArray *g_byte_array_set_size(GByteArray *array , guint length ) ;
#line 262
extern GByteArray *g_byte_array_remove_index(GByteArray *array , guint index_ ) ;
#line 265
extern GByteArray *g_byte_array_remove_index_fast(GByteArray *array , guint index_ ) ;
#line 268
extern GByteArray *g_byte_array_remove_range(GByteArray *array , guint index_ , guint length ) ;
#line 272
extern void g_byte_array_sort(GByteArray *array , GCompareFunc compare_func ) ;
#line 275
extern void g_byte_array_sort_with_data(GByteArray *array , GCompareDataFunc compare_func ,
                                        gpointer user_data ) ;
#line 33 "/usr/include/glib-2.0/glib/gatomic.h"
extern gint g_atomic_int_get(gint *atomic ) ;
#line 35
extern void g_atomic_int_set(gint *atomic , gint newval ) ;
#line 38
extern void g_atomic_int_inc(gint *atomic ) ;
#line 40
extern gboolean g_atomic_int_dec_and_test(gint *atomic ) ;
#line 42
extern gboolean g_atomic_int_compare_and_exchange(gint *atomic , gint oldval , gint newval ) ;
#line 46
extern gint g_atomic_int_add(gint *atomic , gint val ) ;
#line 49
extern guint g_atomic_int_and(guint *atomic , guint val ) ;
#line 52
extern guint g_atomic_int_or(guint *atomic , guint val ) ;
#line 55
extern guint g_atomic_int_xor(guint *atomic , guint val ) ;
#line 59
extern gpointer g_atomic_pointer_get(void const   *atomic ) ;
#line 61
extern void g_atomic_pointer_set(void *atomic , gpointer newval ) ;
#line 64
extern gboolean g_atomic_pointer_compare_and_exchange(void *atomic , gpointer oldval ,
                                                      gpointer newval ) ;
#line 68
extern gssize g_atomic_pointer_add(void *atomic , gssize val ) ;
#line 71
extern gsize g_atomic_pointer_and(void *atomic , gsize val ) ;
#line 74
extern gsize g_atomic_pointer_or(void *atomic , gsize val ) ;
#line 77
extern gsize g_atomic_pointer_xor(void *atomic , gsize val ) ;
#line 81
extern gint g_atomic_int_exchange_and_add(gint *atomic , gint val ) ;
#line 41 "/usr/include/glib-2.0/glib/gquark.h"
extern GQuark g_quark_try_string(gchar *string ) ;
#line 43
extern GQuark g_quark_from_static_string(gchar *string ) ;
#line 45
extern GQuark g_quark_from_string(gchar *string ) ;
#line 47
extern gchar *g_quark_to_string(GQuark quark ) ;
#line 62
extern gchar *g_intern_string(gchar *string ) ;
#line 64
extern gchar *g_intern_static_string(gchar *string ) ;
#line 176 "/usr/include/glib-2.0/glib/gerror.h"
extern GQuark g_error_domain_register_static(char const   *error_type_name , gsize error_type_private_size ,
                                             GErrorInitFunc error_type_init , GErrorCopyFunc error_type_copy ,
                                             GErrorClearFunc error_type_clear ) ;
#line 183
extern GQuark g_error_domain_register(char const   *error_type_name , gsize error_type_private_size ,
                                      GErrorInitFunc error_type_init , GErrorCopyFunc error_type_copy ,
                                      GErrorClearFunc error_type_clear ) ;
#line 190
extern GError *g_error_new(GQuark domain , gint code , gchar *format  , ...) ;
#line 196
extern GError *g_error_new_literal(GQuark domain , gint code , gchar *message ) ;
#line 200
extern GError *g_error_new_valist(GQuark domain , gint code , gchar *format , va_list args ) ;
#line 206
extern void g_error_free(GError *error ) ;
#line 208
extern GError *g_error_copy(GError *error ) ;
#line 211
extern gboolean g_error_matches(GError *error , GQuark domain , gint code ) ;
#line 219
extern void g_set_error(GError **err , GQuark domain , gint code , gchar *format 
                        , ...) ;
#line 226
extern void g_set_error_literal(GError **err , GQuark domain , gint code , gchar *message ) ;
#line 234
extern void g_propagate_error(GError **dest , GError *src ) ;
#line 239
extern void g_clear_error(GError **err ) ;
#line 243
extern void g_prefix_error(GError **err , gchar *format  , ...) ;
#line 249
extern void g_prefix_error_literal(GError **err , gchar *prefix ) ;
#line 254
extern void g_propagate_prefixed_error(GError **dest , GError *src , gchar *format 
                                       , ...) ;
#line 51 "/usr/include/glib-2.0/glib/gutils.h"
extern gchar *g_get_user_name(void) ;
#line 53
extern gchar *g_get_real_name(void) ;
#line 55
extern gchar *g_get_home_dir(void) ;
#line 57
extern gchar *g_get_tmp_dir(void) ;
#line 59
extern gchar *g_get_host_name(void) ;
#line 61
extern gchar *g_get_prgname(void) ;
#line 63
extern void g_set_prgname(gchar *prgname ) ;
#line 65
extern gchar *g_get_application_name(void) ;
#line 67
extern void g_set_application_name(gchar *application_name ) ;
#line 69
extern gchar *g_get_os_info(gchar *key_name ) ;
#line 193
extern void g_reload_user_special_dirs_cache(void) ;
#line 195
extern gchar *g_get_user_data_dir(void) ;
#line 197
extern gchar *g_get_user_config_dir(void) ;
#line 199
extern gchar *g_get_user_cache_dir(void) ;
#line 201
extern gchar *g_get_user_state_dir(void) ;
#line 203
extern gchar * const  *g_get_system_data_dirs(void) ;
#line 225
extern gchar * const  *g_get_system_config_dirs(void) ;
#line 228
extern gchar *g_get_user_runtime_dir(void) ;
#line 266
extern gchar *g_get_user_special_dir(GUserDirectory directory ) ;
#line 286
extern guint g_parse_debug_string(gchar *string , GDebugKey *keys , guint nkeys ) ;
#line 291
extern gint g_snprintf(gchar *string , gulong n , gchar *format  , ...) ;
#line 296
extern gint g_vsnprintf(gchar *string , gulong n , gchar *format , va_list args ) ;
#line 303
extern void g_nullify_pointer(gpointer *nullify_location ) ;
#line 314
extern gchar *g_format_size_full(guint64 size , GFormatSizeFlags flags ) ;
#line 317
extern gchar *g_format_size(guint64 size ) ;
#line 320
extern gchar *g_format_size_for_display(goffset size ) ;
#line 338
extern void g_atexit(GVoidFunc func ) ;
#line 357
extern gchar *g_find_program_in_path(gchar *program ) ;
#line 375
extern gint g_bit_nth_lsf(gulong mask , gint nth_bit ) ;
#line 378
extern gint g_bit_nth_msf(gulong mask , gint nth_bit ) ;
#line 381
extern guint g_bit_storage(gulong number ) ;
#line 384 "/usr/include/glib-2.0/glib/gutils.h"
__inline static gint g_bit_nth_lsf_impl(gulong mask , gint nth_bit ) 
{ 
  long __cil_tmp3 ;
  gint __cil_tmp4 ;

  {
  {
#line 387
  __cil_tmp3 = __builtin_expect((long )0, (long )0);
  }
#line 387
  if (__cil_tmp3) {
#line 388
    nth_bit = - 1;
  }
  {
#line 389
  while (1) {
    while_continue: /* CIL Label */ ;
#line 389
    if (! (nth_bit < 63)) {
#line 389
      goto while_break;
    }
#line 391
    nth_bit ++;
#line 392
    if (mask & (1UL << nth_bit)) {
#line 393
      return (nth_bit);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 395
  return (- 1);
}
}
#line 399 "/usr/include/glib-2.0/glib/gutils.h"
__inline static gint g_bit_nth_msf_impl(gulong mask , gint nth_bit ) 
{ 
  long __cil_tmp3 ;
  gint __cil_tmp4 ;

  {
  {
#line 402
  __cil_tmp3 = __builtin_expect((long )0, (long )0);
  }
#line 402
  if (nth_bit < 0) {
#line 403
    nth_bit = 64;
  } else
#line 402
  if (__cil_tmp3) {
#line 403
    nth_bit = 64;
  }
  {
#line 404
  while (1) {
    while_continue: /* CIL Label */ ;
#line 404
    if (! (nth_bit > 0)) {
#line 404
      goto while_break;
    }
#line 406
    __cil_tmp4 = nth_bit;
#line 406
    nth_bit --;
#line 407
    if (mask & (1UL << nth_bit)) {
#line 408
      return (nth_bit);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 410
  return (- 1);
}
}
#line 414 "/usr/include/glib-2.0/glib/gutils.h"
__inline static guint g_bit_storage_impl(gulong number ) 
{ 
  long __cil_tmp2 ;
  int __cil_tmp3 ;
  unsigned int tmp ;

  {
  {
#line 417
  __cil_tmp2 = __builtin_expect((long )0, (long )1);
  }
#line 417
  if (__cil_tmp2) {
    {
#line 417
    __cil_tmp3 = __builtin_clzl(number);
#line 417
    tmp = (63U ^ (guint )__cil_tmp3) + 1U;
    }
  } else {
#line 417
    tmp = (unsigned int )1;
  }
#line 417
  return (tmp);
}
}
#line 98 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) size_t __ctype_get_mb_cur_max(void) ;
#line 102
__inline extern  __attribute__((__nothrow__)) double atof(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 105
__inline extern  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 108
__inline extern  __attribute__((__nothrow__)) long atol(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 113
__inline extern  __attribute__((__nothrow__)) long long atoll(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 118
extern  __attribute__((__nothrow__)) double strtod(char const   *__nptr , char **__endptr ) ;
#line 124
extern  __attribute__((__nothrow__)) float strtof(char const   *__nptr , char **__endptr ) ;
#line 127
extern  __attribute__((__nothrow__)) long double strtold(char const   *__nptr , char **__endptr ) ;
#line 177
extern  __attribute__((__nothrow__)) long strtol(char const   *__nptr , char **__endptr ,
                                                 int __base ) ;
#line 181
extern  __attribute__((__nothrow__)) unsigned long strtoul(char const   *__nptr ,
                                                           char **__endptr , int __base ) ;
#line 188
extern  __attribute__((__nothrow__)) long long strtoq(char const   *__nptr , char **__endptr ,
                                                      int __base ) ;
#line 193
extern  __attribute__((__nothrow__)) unsigned long long strtouq(char const   *__nptr ,
                                                                char **__endptr ,
                                                                int __base ) ;
#line 201
extern  __attribute__((__nothrow__)) long long strtoll(char const   *__nptr , char **__endptr ,
                                                       int __base ) ;
#line 206
extern  __attribute__((__nothrow__)) unsigned long long strtoull(char const   *__nptr ,
                                                                 char **__endptr ,
                                                                 int __base ) ;
#line 362
__inline extern  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 362 "/usr/include/stdlib.h"
__inline extern int atoi(char const   *__nptr ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 364
  __cil_tmp2 = strtol(__nptr, (char **)((void *)0), 10);
  }
#line 364
  return ((int )__cil_tmp2);
}
}
#line 367
__inline extern  __attribute__((__nothrow__)) long atol(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 367 "/usr/include/stdlib.h"
__inline extern long atol(char const   *__nptr ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 369
  __cil_tmp2 = strtol(__nptr, (char **)((void *)0), 10);
  }
#line 369
  return (__cil_tmp2);
}
}
#line 374
__inline extern  __attribute__((__nothrow__)) long long atoll(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 374 "/usr/include/stdlib.h"
__inline extern long long atoll(char const   *__nptr ) 
{ 
  long long __cil_tmp2 ;

  {
  {
#line 376
  __cil_tmp2 = strtoll(__nptr, (char **)((void *)0), 10);
  }
#line 376
  return (__cil_tmp2);
}
}
#line 386
extern  __attribute__((__nothrow__)) char *l64a(long __n ) ;
#line 389
extern  __attribute__((__nothrow__)) long a64l(char const   *__s ) ;
#line 34 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint16_t __bswap_16(__uint16_t __bsx ) 
{ 
  short __cil_tmp2 ;

  {
  {
#line 37
  __cil_tmp2 = __builtin_bswap16(__bsx);
  }
#line 37
  return (__cil_tmp2);
}
}
#line 49 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint32_t __bswap_32(__uint32_t __bsx ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 52
  __cil_tmp2 = __builtin_bswap32(__bsx);
  }
#line 52
  return (__cil_tmp2);
}
}
#line 70 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint64_t __bswap_64(__uint64_t __bsx ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 73
  __cil_tmp2 = __builtin_bswap64(__bsx);
  }
#line 73
  return (__cil_tmp2);
}
}
#line 33 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__inline static __uint16_t __uint16_identity(__uint16_t __x ) 
{ 


  {
#line 35
  return (__x);
}
}
#line 39 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__inline static __uint32_t __uint32_identity(__uint32_t __x ) 
{ 


  {
#line 41
  return (__x);
}
}
#line 45 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__inline static __uint64_t __uint64_identity(__uint64_t __x ) 
{ 


  {
#line 47
  return (__x);
}
}
#line 102 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set *__readfds , fd_set *__writefds , fd_set *__exceptfds ,
                  struct timeval *__timeout ) ;
#line 127
extern int pselect(int __nfds , fd_set *__readfds , fd_set *__writefds , fd_set *__exceptfds ,
                   struct timespec *__timeout , __sigset_t *__sigmask ) ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/select2.h"
extern long __fdelt_chk(long __d ) ;
#line 25
extern long __fdelt_warn(long __d ) ;
#line 402 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long random(void) ;
#line 405
extern  __attribute__((__nothrow__)) void srandom(unsigned int __seed ) ;
#line 411
extern  __attribute__((__nothrow__)) char *initstate(unsigned int __seed , char *__statebuf ,
                                                     size_t __statelen ) ;
#line 416
extern  __attribute__((__nothrow__)) char *setstate(char *__statebuf ) ;
#line 435
extern  __attribute__((__nothrow__)) int random_r(struct random_data *__buf , int32_t *__result ) ;
#line 438
extern  __attribute__((__nothrow__)) int srandom_r(unsigned int __seed , struct random_data *__buf ) ;
#line 441
extern  __attribute__((__nothrow__)) int initstate_r(unsigned int __seed , char *__statebuf ,
                                                     size_t __statelen , struct random_data *__buf ) ;
#line 446
extern  __attribute__((__nothrow__)) int setstate_r(char *__statebuf , struct random_data *__buf ) ;
#line 454
extern  __attribute__((__nothrow__)) int rand(void) ;
#line 456
extern  __attribute__((__nothrow__)) void srand(unsigned int __seed ) ;
#line 460
extern  __attribute__((__nothrow__)) int rand_r(unsigned int *__seed ) ;
#line 468
extern  __attribute__((__nothrow__)) double drand48(void) ;
#line 469
extern  __attribute__((__nothrow__)) double erand48(unsigned short __xsubi[3] ) ;
#line 472
extern  __attribute__((__nothrow__)) long lrand48(void) ;
#line 473
extern  __attribute__((__nothrow__)) long nrand48(unsigned short __xsubi[3] ) ;
#line 477
extern  __attribute__((__nothrow__)) long mrand48(void) ;
#line 478
extern  __attribute__((__nothrow__)) long jrand48(unsigned short __xsubi[3] ) ;
#line 482
extern  __attribute__((__nothrow__)) void srand48(long __seedval ) ;
#line 483
extern  __attribute__((__nothrow__)) unsigned short *seed48(unsigned short __seed16v[3] ) ;
#line 485
extern  __attribute__((__nothrow__)) void lcong48(unsigned short __param[7] ) ;
#line 502
extern  __attribute__((__nothrow__)) int drand48_r(struct drand48_data *__buffer ,
                                                   double *__result ) ;
#line 504
extern  __attribute__((__nothrow__)) int erand48_r(unsigned short __xsubi[3] , struct drand48_data *__buffer ,
                                                   double *__result ) ;
#line 509
extern  __attribute__((__nothrow__)) int lrand48_r(struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 512
extern  __attribute__((__nothrow__)) int nrand48_r(unsigned short __xsubi[3] , struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 518
extern  __attribute__((__nothrow__)) int mrand48_r(struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 521
extern  __attribute__((__nothrow__)) int jrand48_r(unsigned short __xsubi[3] , struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 527
extern  __attribute__((__nothrow__)) int srand48_r(long __seedval , struct drand48_data *__buffer ) ;
#line 530
extern  __attribute__((__nothrow__)) int seed48_r(unsigned short __seed16v[3] , struct drand48_data *__buffer ) ;
#line 533
extern  __attribute__((__nothrow__)) int lcong48_r(unsigned short __param[7] , struct drand48_data *__buffer ) ;
#line 540
extern  __attribute__((__nothrow__)) void *malloc(size_t __size ) ;
#line 543
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size ) ;
#line 551
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size ) ;
#line 555
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 563
extern  __attribute__((__nothrow__)) void *reallocarray(void *__ptr , size_t __nmemb ,
                                                        size_t __size ) ;
#line 32 "/usr/include/alloca.h"
extern  __attribute__((__nothrow__)) void *alloca(size_t __size ) ;
#line 580 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *valloc(size_t __size ) ;
#line 586
extern  __attribute__((__nothrow__)) int posix_memalign(void **__memptr , size_t __alignment ,
                                                        size_t __size ) ;
#line 592
extern  __attribute__((__nothrow__)) void *aligned_alloc(size_t __alignment , size_t __size ) ;
#line 598
extern  __attribute__((__nothrow__)) void abort(void) ;
#line 602
extern  __attribute__((__nothrow__)) int atexit(void (*__func)(void) ) ;
#line 610
extern  __attribute__((__nothrow__)) int at_quick_exit(void (*__func)(void) ) ;
#line 617
extern  __attribute__((__nothrow__)) int on_exit(void (*__func)(int  , void * ) ,
                                                 void *__arg ) ;
#line 624
extern  __attribute__((__nothrow__)) void exit(int __status ) ;
#line 630
extern  __attribute__((__nothrow__)) void quick_exit(int __status ) ;
#line 636
extern  __attribute__((__nothrow__)) void _Exit(int __status ) ;
#line 641
extern  __attribute__((__nothrow__)) char *getenv(char const   *__name ) ;
#line 654
extern  __attribute__((__nothrow__)) int putenv(char *__string ) ;
#line 660
extern  __attribute__((__nothrow__)) int setenv(char const   *__name , char const   *__value ,
                                                int __replace ) ;
#line 664
extern  __attribute__((__nothrow__)) int unsetenv(char const   *__name ) ;
#line 671
extern  __attribute__((__nothrow__)) int clearenv(void) ;
#line 682
extern  __attribute__((__nothrow__)) char *mktemp(char *__template ) ;
#line 695
extern int mkstemp(char *__template ) ;
#line 717
extern int mkstemps(char *__template , int __suffixlen ) ;
#line 738
extern  __attribute__((__nothrow__)) char *mkdtemp(char *__template ) ;
#line 791
extern int system(char const   *__command ) ;
#line 808
__inline extern  __attribute__((__nothrow__)) char *realpath(char const   *__name ,
                                                             char *__resolved )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 828
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar )  __attribute__((__gnu_inline__)) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h"
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar )  __attribute__((__gnu_inline__)) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h"
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar ) 
{ 
  size_t __l ;
  size_t __u ;
  size_t __idx ;
  void const   *__p ;
  int __comparison ;
  int __cil_tmp11 ;

  {
#line 27
  __l = (size_t )0;
#line 28
  __u = __nmemb;
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;
#line 29
    if (! (__l < __u)) {
#line 29
      goto while_break;
    }
    {
#line 31
    __idx = (__l + __u) / 2UL;
#line 32
    __p = (void const   *)((char const   *)__base + __idx * __size);
#line 33
    __comparison = (*__compar)(__key, __p);
    }
#line 34
    if (__comparison < 0) {
#line 35
      __u = __idx;
    } else
#line 36
    if (__comparison > 0) {
#line 37
      __l = __idx + 1UL;
    } else {
#line 44
      return ((void *)__p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 51
  return ((void *)0);
}
}
#line 838 "/usr/include/stdlib.h"
extern void qsort(void *__base , size_t __nmemb , size_t __size , __compar_fn_t __compar ) ;
#line 848
extern  __attribute__((__nothrow__)) int abs(int __x ) ;
#line 849
extern  __attribute__((__nothrow__)) long labs(long __x ) ;
#line 852
extern  __attribute__((__nothrow__)) long long llabs(long long __x ) ;
#line 860
extern  __attribute__((__nothrow__)) div_t div(int __numer , int __denom ) ;
#line 862
extern  __attribute__((__nothrow__)) ldiv_t ldiv(long __numer , long __denom ) ;
#line 866
extern  __attribute__((__nothrow__)) lldiv_t lldiv(long long __numer , long long __denom ) ;
#line 880
extern  __attribute__((__nothrow__)) char *ecvt(double __value , int __ndigit , int *__decpt ,
                                                int *__sign ) ;
#line 886
extern  __attribute__((__nothrow__)) char *fcvt(double __value , int __ndigit , int *__decpt ,
                                                int *__sign ) ;
#line 892
extern  __attribute__((__nothrow__)) char *gcvt(double __value , int __ndigit , char *__buf ) ;
#line 898
extern  __attribute__((__nothrow__)) char *qecvt(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign ) ;
#line 901
extern  __attribute__((__nothrow__)) char *qfcvt(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign ) ;
#line 904
extern  __attribute__((__nothrow__)) char *qgcvt(long double __value , int __ndigit ,
                                                 char *__buf ) ;
#line 910
extern  __attribute__((__nothrow__)) int ecvt_r(double __value , int __ndigit , int *__decpt ,
                                                int *__sign , char *__buf , size_t __len ) ;
#line 913
extern  __attribute__((__nothrow__)) int fcvt_r(double __value , int __ndigit , int *__decpt ,
                                                int *__sign , char *__buf , size_t __len ) ;
#line 917
extern  __attribute__((__nothrow__)) int qecvt_r(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign , char *__buf ,
                                                 size_t __len ) ;
#line 921
extern  __attribute__((__nothrow__)) int qfcvt_r(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign , char *__buf ,
                                                 size_t __len ) ;
#line 930
extern  __attribute__((__nothrow__)) int mblen(char const   *__s , size_t __n ) ;
#line 933
extern  __attribute__((__nothrow__)) int mbtowc(wchar_t *__pwc , char const   *__s ,
                                                size_t __n ) ;
#line 937
__inline extern  __attribute__((__nothrow__)) int wctomb(char *__s , wchar_t __wchar )  __attribute__((__gnu_inline__)) ;
#line 941
__inline extern  __attribute__((__nothrow__)) size_t mbstowcs(wchar_t *__dst , char const   *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 945
__inline extern  __attribute__((__nothrow__)) size_t wcstombs(char *__dst , wchar_t *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 956
extern  __attribute__((__nothrow__)) int rpmatch(char const   *__response ) ;
#line 967
extern  __attribute__((__nothrow__)) int getsubopt(char **__optionp , char * const  *__tokens ,
                                                   char **__valuep ) ;
#line 1013
extern  __attribute__((__nothrow__)) int getloadavg(double __loadavg[] , int __nelem ) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern  __attribute__((__nothrow__)) double atof(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern double atof(char const   *__nptr ) 
{ 
  double __cil_tmp2 ;

  {
  {
#line 27
  __cil_tmp2 = strtod(__nptr, (char **)((void *)0));
  }
#line 27
  return (__cil_tmp2);
}
}
#line 23 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
extern  __attribute__((__nothrow__)) char *__realpath_chk(char const   *__name , char *__resolved ,
                                                          size_t __resolvedlen ) ;
#line 26
extern  __attribute__((__nothrow__)) char *__realpath_alias(char const   *__name ,
                                                            char *__resolved ) ;
#line 29
extern  __attribute__((__nothrow__)) char *__realpath_chk_warn(char const   *__name ,
                                                               char *__resolved ,
                                                               size_t __resolvedlen ) ;
#line 37
__inline extern  __attribute__((__nothrow__)) char *realpath(char const   *__name ,
                                                             char *__resolved )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 37 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern char *realpath(char const   *__name , char *__resolved ) 
{ 
  size_t sz ;
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 39
  __cil_tmp4 = __builtin_object_size(__resolved, 1);
#line 39
  sz = __cil_tmp4;
  }
#line 41
  if (sz == 0xffffffffffffffffUL) {
    {
#line 42
    __cil_tmp5 = __realpath_alias(__name, __resolved);
    }
#line 42
    return (__cil_tmp5);
  }
  {
#line 45
  __cil_tmp7 = __builtin_constant_p(4096UL <= sz / sizeof(char ));
  }
  {
#line 45
  __cil_tmp6 = __builtin_constant_p(4096);
  }
#line 45
  if (__cil_tmp6) {
#line 45
    if (__cil_tmp7) {
#line 45
      if (! (4096UL <= sz / sizeof(char ))) {
        {
#line 46
        __cil_tmp8 = __realpath_chk_warn(__name, __resolved, sz);
        }
#line 46
        return (__cil_tmp8);
      }
    }
  }
  {
#line 48
  __cil_tmp9 = __realpath_chk(__name, __resolved, sz);
  }
#line 48
  return (__cil_tmp9);
}
}
#line 52
extern  __attribute__((__nothrow__)) int __ptsname_r_chk(int __fd , char *__buf ,
                                                         size_t __buflen , size_t __nreal ) ;
#line 55
extern  __attribute__((__nothrow__)) int __ptsname_r_alias(int __fd , char *__buf ,
                                                           size_t __buflen ) ;
#line 58
extern  __attribute__((__nothrow__)) int __ptsname_r_chk_warn(int __fd , char *__buf ,
                                                              size_t __buflen , size_t __nreal ) ;
#line 65
__inline extern  __attribute__((__nothrow__)) int ptsname_r(int __fd , char *__buf ,
                                                            size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 65 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int ptsname_r(int __fd , char *__buf , size_t __buflen ) 
{ 
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  int __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  int __cil_tmp16 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 67
  __cil_tmp7 = __builtin_object_size(__buf, 1);
  }
  {
#line 67
  __cil_tmp5 = __builtin_object_size(__buf, 1);
#line 67
  __cil_tmp6 = __builtin_constant_p((unsigned long )__buflen <= __cil_tmp5 / sizeof(char ));
  }
  {
#line 67
  __cil_tmp4 = __builtin_constant_p(__buflen);
  }
#line 67
  if (__cil_tmp6 && (unsigned long )__buflen <= __cil_tmp7 / sizeof(char )) {
    {
#line 67
    __cil_tmp8 = __ptsname_r_alias(__fd, __buf, __buflen);
#line 67
    tmp___0 = __cil_tmp8;
    }
  } else {
    {
#line 67
    __cil_tmp12 = __builtin_object_size(__buf, 1);
    }
    {
#line 67
    __cil_tmp10 = __builtin_object_size(__buf, 1);
#line 67
    __cil_tmp11 = __builtin_constant_p((unsigned long )__buflen <= __cil_tmp10 / sizeof(char ));
    }
    {
#line 67
    __cil_tmp9 = __builtin_constant_p(__buflen);
    }
#line 67
    if (__cil_tmp11 && ! ((unsigned long )__buflen <= __cil_tmp12 / sizeof(char ))) {
      {
#line 67
      __cil_tmp13 = __builtin_object_size(__buf, 1);
#line 67
      __cil_tmp14 = __ptsname_r_chk_warn(__fd, __buf, __buflen, __cil_tmp13);
#line 67
      tmp = __cil_tmp14;
      }
    } else {
      {
#line 67
      __cil_tmp15 = __builtin_object_size(__buf, 1);
#line 67
      __cil_tmp16 = __ptsname_r_chk(__fd, __buf, __buflen, __cil_tmp15);
#line 67
      tmp = __cil_tmp16;
      }
    }
#line 67
    tmp___0 = tmp;
  }
#line 67
  return (tmp___0);
}
}
#line 73
extern  __attribute__((__nothrow__)) int __wctomb_chk(char *__s , wchar_t __wchar ,
                                                      size_t __buflen ) ;
#line 75
extern  __attribute__((__nothrow__)) int __wctomb_alias(char *__s , wchar_t __wchar ) ;
#line 79
__inline extern  __attribute__((__nothrow__)) int wctomb(char *__s , wchar_t __wchar )  __attribute__((__gnu_inline__)) ;
#line 79 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int wctomb(char *__s , wchar_t __wchar ) 
{ 
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 88
  __cil_tmp4 = __builtin_object_size(__s, 1);
  }
  {
#line 88
  __cil_tmp3 = __builtin_object_size(__s, 1);
  }
#line 88
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
#line 88
    if (16UL > __cil_tmp4) {
      {
#line 90
      __cil_tmp5 = __builtin_object_size(__s, 1);
#line 90
      __cil_tmp6 = __wctomb_chk(__s, __wchar, __cil_tmp5);
      }
#line 90
      return (__cil_tmp6);
    }
  }
  {
#line 91
  __cil_tmp7 = __wctomb_alias(__s, __wchar);
  }
#line 91
  return (__cil_tmp7);
}
}
#line 95
extern  __attribute__((__nothrow__)) size_t __mbstowcs_chk(wchar_t *__dst , char const   *__src ,
                                                           size_t __len , size_t __dstlen ) ;
#line 99
extern  __attribute__((__nothrow__)) size_t __mbstowcs_alias(wchar_t *__dst , char const   *__src ,
                                                             size_t __len ) ;
#line 104
extern  __attribute__((__nothrow__)) size_t __mbstowcs_chk_warn(wchar_t *__dst , char const   *__src ,
                                                                size_t __len , size_t __dstlen ) ;
#line 112
__inline extern  __attribute__((__nothrow__)) size_t mbstowcs(wchar_t *__dst , char const   *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 112 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t mbstowcs(wchar_t *__dst , char const   *__src , size_t __len ) 
{ 
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  size_t __cil_tmp8 ;
  int __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  size_t __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  size_t __cil_tmp16 ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 115
  __cil_tmp7 = __builtin_object_size(__dst, 1);
  }
  {
#line 115
  __cil_tmp5 = __builtin_object_size(__dst, 1);
#line 115
  __cil_tmp6 = __builtin_constant_p((unsigned long )__len <= __cil_tmp5 / sizeof(wchar_t ));
  }
  {
#line 115
  __cil_tmp4 = __builtin_constant_p(__len);
  }
#line 115
  if (__cil_tmp6 && (unsigned long )__len <= __cil_tmp7 / sizeof(wchar_t )) {
    {
#line 115
    __cil_tmp8 = __mbstowcs_alias(__dst, __src, __len);
#line 115
    tmp___0 = __cil_tmp8;
    }
  } else {
    {
#line 115
    __cil_tmp12 = __builtin_object_size(__dst, 1);
    }
    {
#line 115
    __cil_tmp10 = __builtin_object_size(__dst, 1);
#line 115
    __cil_tmp11 = __builtin_constant_p((unsigned long )__len <= __cil_tmp10 / sizeof(wchar_t ));
    }
    {
#line 115
    __cil_tmp9 = __builtin_constant_p(__len);
    }
#line 115
    if (__cil_tmp11 && ! ((unsigned long )__len <= __cil_tmp12 / sizeof(wchar_t ))) {
      {
#line 115
      __cil_tmp13 = __builtin_object_size(__dst, 1);
#line 115
      __cil_tmp14 = __mbstowcs_chk_warn(__dst, __src, __len, __cil_tmp13 / sizeof(wchar_t ));
#line 115
      tmp = __cil_tmp14;
      }
    } else {
      {
#line 115
      __cil_tmp15 = __builtin_object_size(__dst, 1);
#line 115
      __cil_tmp16 = __mbstowcs_chk(__dst, __src, __len, __cil_tmp15 / sizeof(wchar_t ));
#line 115
      tmp = __cil_tmp16;
      }
    }
#line 115
    tmp___0 = tmp;
  }
#line 115
  return (tmp___0);
}
}
#line 121
extern  __attribute__((__nothrow__)) size_t __wcstombs_chk(char *__dst , wchar_t *__src ,
                                                           size_t __len , size_t __dstlen ) ;
#line 125
extern  __attribute__((__nothrow__)) size_t __wcstombs_alias(char *__dst , wchar_t *__src ,
                                                             size_t __len ) ;
#line 130
extern  __attribute__((__nothrow__)) size_t __wcstombs_chk_warn(char *__dst , wchar_t *__src ,
                                                                size_t __len , size_t __dstlen ) ;
#line 137
__inline extern  __attribute__((__nothrow__)) size_t wcstombs(char *__dst , wchar_t *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 137 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t wcstombs(char *__dst , wchar_t *__src , size_t __len ) 
{ 
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  size_t __cil_tmp8 ;
  int __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  size_t __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  size_t __cil_tmp16 ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 140
  __cil_tmp7 = __builtin_object_size(__dst, 1);
  }
  {
#line 140
  __cil_tmp5 = __builtin_object_size(__dst, 1);
#line 140
  __cil_tmp6 = __builtin_constant_p((unsigned long )__len <= __cil_tmp5 / sizeof(char ));
  }
  {
#line 140
  __cil_tmp4 = __builtin_constant_p(__len);
  }
#line 140
  if (__cil_tmp6 && (unsigned long )__len <= __cil_tmp7 / sizeof(char )) {
    {
#line 140
    __cil_tmp8 = __wcstombs_alias(__dst, __src, __len);
#line 140
    tmp___0 = __cil_tmp8;
    }
  } else {
    {
#line 140
    __cil_tmp12 = __builtin_object_size(__dst, 1);
    }
    {
#line 140
    __cil_tmp10 = __builtin_object_size(__dst, 1);
#line 140
    __cil_tmp11 = __builtin_constant_p((unsigned long )__len <= __cil_tmp10 / sizeof(char ));
    }
    {
#line 140
    __cil_tmp9 = __builtin_constant_p(__len);
    }
#line 140
    if (__cil_tmp11 && ! ((unsigned long )__len <= __cil_tmp12 / sizeof(char ))) {
      {
#line 140
      __cil_tmp13 = __builtin_object_size(__dst, 1);
#line 140
      __cil_tmp14 = __wcstombs_chk_warn(__dst, __src, __len, __cil_tmp13);
#line 140
      tmp = __cil_tmp14;
      }
    } else {
      {
#line 140
      __cil_tmp15 = __builtin_object_size(__dst, 1);
#line 140
      __cil_tmp16 = __wcstombs_chk(__dst, __src, __len, __cil_tmp15);
#line 140
      tmp = __cil_tmp16;
      }
    }
#line 140
    tmp___0 = tmp;
  }
#line 140
  return (tmp___0);
}
}
#line 40 "/usr/include/glib-2.0/glib/gthread.h"
extern GQuark g_thread_error_quark(void) ;
#line 141
extern GThread *g_thread_ref(GThread *thread ) ;
#line 143
extern void g_thread_unref(GThread *thread ) ;
#line 145
extern GThread *g_thread_new(gchar *name , GThreadFunc func , gpointer data ) ;
#line 149
extern GThread *g_thread_try_new(gchar *name , GThreadFunc func , gpointer data ,
                                 GError **error ) ;
#line 154
extern GThread *g_thread_self(void) ;
#line 156
extern void g_thread_exit(gpointer retval ) ;
#line 158
extern gpointer g_thread_join(GThread *thread ) ;
#line 160
extern void g_thread_yield(void) ;
#line 164
extern void g_mutex_init(GMutex *mutex ) ;
#line 166
extern void g_mutex_clear(GMutex *mutex ) ;
#line 168
extern void g_mutex_lock(GMutex *mutex ) ;
#line 170
extern gboolean g_mutex_trylock(GMutex *mutex ) ;
#line 172
extern void g_mutex_unlock(GMutex *mutex ) ;
#line 175
extern void g_rw_lock_init(GRWLock *rw_lock ) ;
#line 177
extern void g_rw_lock_clear(GRWLock *rw_lock ) ;
#line 179
extern void g_rw_lock_writer_lock(GRWLock *rw_lock ) ;
#line 181
extern gboolean g_rw_lock_writer_trylock(GRWLock *rw_lock ) ;
#line 183
extern void g_rw_lock_writer_unlock(GRWLock *rw_lock ) ;
#line 185
extern void g_rw_lock_reader_lock(GRWLock *rw_lock ) ;
#line 187
extern gboolean g_rw_lock_reader_trylock(GRWLock *rw_lock ) ;
#line 189
extern void g_rw_lock_reader_unlock(GRWLock *rw_lock ) ;
#line 192
extern void g_rec_mutex_init(GRecMutex *rec_mutex ) ;
#line 194
extern void g_rec_mutex_clear(GRecMutex *rec_mutex ) ;
#line 196
extern void g_rec_mutex_lock(GRecMutex *rec_mutex ) ;
#line 198
extern gboolean g_rec_mutex_trylock(GRecMutex *rec_mutex ) ;
#line 200
extern void g_rec_mutex_unlock(GRecMutex *rec_mutex ) ;
#line 203
extern void g_cond_init(GCond *cond ) ;
#line 205
extern void g_cond_clear(GCond *cond ) ;
#line 207
extern void g_cond_wait(GCond *cond , GMutex *mutex ) ;
#line 210
extern void g_cond_signal(GCond *cond ) ;
#line 212
extern void g_cond_broadcast(GCond *cond ) ;
#line 214
extern gboolean g_cond_wait_until(GCond *cond , GMutex *mutex , gint64 end_time ) ;
#line 219
extern gpointer g_private_get(GPrivate *key ) ;
#line 221
extern void g_private_set(GPrivate *key , gpointer value ) ;
#line 224
extern void g_private_replace(GPrivate *key , gpointer value ) ;
#line 228
extern gpointer g_once_impl(GOnce *once , GThreadFunc func , gpointer arg ) ;
#line 232
extern gboolean g_once_init_enter(void *location ) ;
#line 234
extern void g_once_init_leave(void *location , gsize result ) ;
#line 277
extern guint g_get_num_processors(void) ;
#line 331 "/usr/include/glib-2.0/glib/gthread.h"
__inline static GMutexLocker *g_mutex_locker_new(GMutex *mutex ) 
{ 


  {
  {
#line 333
  g_mutex_lock(mutex);
  }
#line 334
  return ((GMutexLocker *)mutex);
}
}
#line 349 "/usr/include/glib-2.0/glib/gthread.h"
__inline static void g_mutex_locker_free(GMutexLocker *locker ) 
{ 


  {
  {
#line 351
  g_mutex_unlock((GMutex *)locker);
  }
  return;
}
}
#line 407 "/usr/include/glib-2.0/glib/gthread.h"
__inline static GRecMutexLocker *g_rec_mutex_locker_new(GRecMutex *rec_mutex ) 
{ 


  {
  {
#line 409
  g_rec_mutex_lock(rec_mutex);
  }
#line 410
  return ((GRecMutexLocker *)rec_mutex);
}
}
#line 427 "/usr/include/glib-2.0/glib/gthread.h"
__inline static void g_rec_mutex_locker_free(GRecMutexLocker *locker ) 
{ 


  {
  {
#line 429
  g_rec_mutex_unlock((GRecMutex *)locker);
  }
  return;
}
}
#line 517 "/usr/include/glib-2.0/glib/gthread.h"
__inline static GRWLockWriterLocker *g_rw_lock_writer_locker_new(GRWLock *rw_lock ) 
{ 


  {
  {
#line 519
  g_rw_lock_writer_lock(rw_lock);
  }
#line 520
  return ((GRWLockWriterLocker *)rw_lock);
}
}
#line 538 "/usr/include/glib-2.0/glib/gthread.h"
__inline static void g_rw_lock_writer_locker_free(GRWLockWriterLocker *locker ) 
{ 


  {
  {
#line 540
  g_rw_lock_writer_unlock((GRWLock *)locker);
  }
  return;
}
}
#line 572 "/usr/include/glib-2.0/glib/gthread.h"
__inline static GRWLockReaderLocker *g_rw_lock_reader_locker_new(GRWLock *rw_lock ) 
{ 


  {
  {
#line 574
  g_rw_lock_reader_lock(rw_lock);
  }
#line 575
  return ((GRWLockReaderLocker *)rw_lock);
}
}
#line 593 "/usr/include/glib-2.0/glib/gthread.h"
__inline static void g_rw_lock_reader_locker_free(GRWLockReaderLocker *locker ) 
{ 


  {
  {
#line 595
  g_rw_lock_reader_unlock((GRWLock *)locker);
  }
  return;
}
}
#line 39 "/usr/include/glib-2.0/glib/gasyncqueue.h"
extern GAsyncQueue *g_async_queue_new(void) ;
#line 41
extern GAsyncQueue *g_async_queue_new_full(GDestroyNotify item_free_func ) ;
#line 43
extern void g_async_queue_lock(GAsyncQueue *queue ) ;
#line 45
extern void g_async_queue_unlock(GAsyncQueue *queue ) ;
#line 47
extern GAsyncQueue *g_async_queue_ref(GAsyncQueue *queue ) ;
#line 49
extern void g_async_queue_unref(GAsyncQueue *queue ) ;
#line 52
extern void g_async_queue_ref_unlocked(GAsyncQueue *queue ) ;
#line 55
extern void g_async_queue_unref_and_unlock(GAsyncQueue *queue ) ;
#line 58
extern void g_async_queue_push(GAsyncQueue *queue , gpointer data ) ;
#line 61
extern void g_async_queue_push_unlocked(GAsyncQueue *queue , gpointer data ) ;
#line 64
extern void g_async_queue_push_sorted(GAsyncQueue *queue , gpointer data , GCompareDataFunc func ,
                                      gpointer user_data ) ;
#line 69
extern void g_async_queue_push_sorted_unlocked(GAsyncQueue *queue , gpointer data ,
                                               GCompareDataFunc func , gpointer user_data ) ;
#line 74
extern gpointer g_async_queue_pop(GAsyncQueue *queue ) ;
#line 76
extern gpointer g_async_queue_pop_unlocked(GAsyncQueue *queue ) ;
#line 78
extern gpointer g_async_queue_try_pop(GAsyncQueue *queue ) ;
#line 80
extern gpointer g_async_queue_try_pop_unlocked(GAsyncQueue *queue ) ;
#line 82
extern gpointer g_async_queue_timeout_pop(GAsyncQueue *queue , guint64 timeout ) ;
#line 85
extern gpointer g_async_queue_timeout_pop_unlocked(GAsyncQueue *queue , guint64 timeout ) ;
#line 88
extern gint g_async_queue_length(GAsyncQueue *queue ) ;
#line 90
extern gint g_async_queue_length_unlocked(GAsyncQueue *queue ) ;
#line 92
extern void g_async_queue_sort(GAsyncQueue *queue , GCompareDataFunc func , gpointer user_data ) ;
#line 96
extern void g_async_queue_sort_unlocked(GAsyncQueue *queue , GCompareDataFunc func ,
                                        gpointer user_data ) ;
#line 101
extern gboolean g_async_queue_remove(GAsyncQueue *queue , gpointer item ) ;
#line 104
extern gboolean g_async_queue_remove_unlocked(GAsyncQueue *queue , gpointer item ) ;
#line 107
extern void g_async_queue_push_front(GAsyncQueue *queue , gpointer item ) ;
#line 110
extern void g_async_queue_push_front_unlocked(GAsyncQueue *queue , gpointer item ) ;
#line 115
extern gpointer g_async_queue_timed_pop(GAsyncQueue *queue , GTimeVal *end_time ) ;
#line 118
extern gpointer g_async_queue_timed_pop_unlocked(GAsyncQueue *queue , GTimeVal *end_time ) ;
#line 77 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t __sysv_signal(int __sig , __sighandler_t __handler ) ;
#line 88
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , __sighandler_t __handler ) ;
#line 112
extern  __attribute__((__nothrow__)) int kill(__pid_t __pid , int __sig ) ;
#line 119
extern  __attribute__((__nothrow__)) int killpg(__pid_t __pgrp , int __sig ) ;
#line 123
extern  __attribute__((__nothrow__)) int raise(int __sig ) ;
#line 127
extern  __attribute__((__nothrow__)) __sighandler_t ssignal(int __sig , __sighandler_t __handler ) ;
#line 129
extern  __attribute__((__nothrow__)) int gsignal(int __sig ) ;
#line 134
extern void psignal(int __sig , char const   *__s ) ;
#line 137
extern void psiginfo(siginfo_t *__pinfo , char const   *__s ) ;
#line 173
extern  __attribute__((__nothrow__)) int sigblock(int __mask ) ;
#line 176
extern  __attribute__((__nothrow__)) int sigsetmask(int __mask ) ;
#line 179
extern  __attribute__((__nothrow__)) int siggetmask(void) ;
#line 199
extern  __attribute__((__nothrow__)) int sigemptyset(sigset_t *__set ) ;
#line 202
extern  __attribute__((__nothrow__)) int sigfillset(sigset_t *__set ) ;
#line 205
extern  __attribute__((__nothrow__)) int sigaddset(sigset_t *__set , int __signo ) ;
#line 208
extern  __attribute__((__nothrow__)) int sigdelset(sigset_t *__set , int __signo ) ;
#line 211
extern  __attribute__((__nothrow__)) int sigismember(sigset_t *__set , int __signo ) ;
#line 232
extern  __attribute__((__nothrow__)) int sigprocmask(int __how , sigset_t *__set ,
                                                     sigset_t *__oset ) ;
#line 240
extern int sigsuspend(sigset_t *__set ) ;
#line 243
extern  __attribute__((__nothrow__)) int sigaction(int __sig , struct sigaction *__act ,
                                                   struct sigaction *__oact ) ;
#line 247
extern  __attribute__((__nothrow__)) int sigpending(sigset_t *__set ) ;
#line 255
extern int sigwait(sigset_t *__set , int *__sig ) ;
#line 264
extern int sigwaitinfo(sigset_t *__set , siginfo_t *__info ) ;
#line 273
extern int sigtimedwait(sigset_t *__set , siginfo_t *__info , struct timespec *__timeout ) ;
#line 292
extern  __attribute__((__nothrow__)) int sigqueue(__pid_t __pid , int __sig , union sigval __val ) ;
#line 304
extern  __attribute__((__nothrow__)) int sigreturn(struct sigcontext *__scp ) ;
#line 324
extern  __attribute__((__nothrow__)) int siginterrupt(int __sig , int __interrupt ) ;
#line 333
extern  __attribute__((__nothrow__)) int sigaltstack(stack_t *__ss , stack_t *__oss ) ;
#line 347
extern  __attribute__((__nothrow__)) int sigstack(struct sigstack *__ss , struct sigstack *__oss ) ;
#line 31 "/usr/include/x86_64-linux-gnu/bits/sigthread.h"
extern  __attribute__((__nothrow__)) int pthread_sigmask(int __how , __sigset_t *__newmask ,
                                                         __sigset_t *__oldmask ) ;
#line 36
extern  __attribute__((__nothrow__)) int pthread_kill(pthread_t __threadid , int __signo ) ;
#line 383 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int __libc_current_sigrtmin(void) ;
#line 385
extern  __attribute__((__nothrow__)) int __libc_current_sigrtmax(void) ;
#line 41 "/usr/include/glib-2.0/glib/gbacktrace.h"
extern void g_on_error_query(gchar *prg_name ) ;
#line 43
extern void g_on_error_stack_trace(gchar *prg_name ) ;
#line 31 "/usr/include/glib-2.0/glib/gbase64.h"
extern gsize g_base64_encode_step(guchar *in , gsize len , gboolean break_lines ,
                                  gchar *out , gint *state , gint *save ) ;
#line 38
extern gsize g_base64_encode_close(gboolean break_lines , gchar *out , gint *state ,
                                   gint *save ) ;
#line 43
extern gchar *g_base64_encode(guchar *data , gsize len ) ;
#line 46
extern gsize g_base64_decode_step(gchar *in , gsize len , guchar *out , gint *state ,
                                  guint *save ) ;
#line 52
extern guchar *g_base64_decode(gchar *text , gsize *out_len ) ;
#line 55
extern guchar *g_base64_decode_inplace(gchar *text , gsize *out_len ) ;
#line 33 "/usr/include/glib-2.0/glib/gbitlock.h"
extern void g_bit_lock(gint *address , gint lock_bit ) ;
#line 36
extern gboolean g_bit_trylock(gint *address , gint lock_bit ) ;
#line 39
extern void g_bit_unlock(gint *address , gint lock_bit ) ;
#line 43
extern void g_pointer_bit_lock(void *address , gint lock_bit ) ;
#line 46
extern gboolean g_pointer_bit_trylock(void *address , gint lock_bit ) ;
#line 49
extern void g_pointer_bit_unlock(void *address , gint lock_bit ) ;
#line 57 "/usr/include/glib-2.0/glib/gtimezone.h"
extern GTimeZone *g_time_zone_new(gchar *identifier ) ;
#line 59
extern GTimeZone *g_time_zone_new_identifier(gchar *identifier ) ;
#line 61
extern GTimeZone *g_time_zone_new_utc(void) ;
#line 63
extern GTimeZone *g_time_zone_new_local(void) ;
#line 65
extern GTimeZone *g_time_zone_new_offset(gint32 seconds ) ;
#line 68
extern GTimeZone *g_time_zone_ref(GTimeZone *tz ) ;
#line 70
extern void g_time_zone_unref(GTimeZone *tz ) ;
#line 73
extern gint g_time_zone_find_interval(GTimeZone *tz , GTimeType type , gint64 time_ ) ;
#line 78
extern gint g_time_zone_adjust_time(GTimeZone *tz , GTimeType type , gint64 *time_ ) ;
#line 83
extern gchar *g_time_zone_get_abbreviation(GTimeZone *tz , gint interval ) ;
#line 86
extern gint32 g_time_zone_get_offset(GTimeZone *tz , gint interval ) ;
#line 89
extern gboolean g_time_zone_is_dst(GTimeZone *tz , gint interval ) ;
#line 92
extern gchar *g_time_zone_get_identifier(GTimeZone *tz ) ;
#line 99 "/usr/include/glib-2.0/glib/gdatetime.h"
extern void g_date_time_unref(GDateTime *datetime ) ;
#line 101
extern GDateTime *g_date_time_ref(GDateTime *datetime ) ;
#line 104
extern GDateTime *g_date_time_new_now(GTimeZone *tz ) ;
#line 106
extern GDateTime *g_date_time_new_now_local(void) ;
#line 108
extern GDateTime *g_date_time_new_now_utc(void) ;
#line 111
extern GDateTime *g_date_time_new_from_unix_local(gint64 t ) ;
#line 113
extern GDateTime *g_date_time_new_from_unix_utc(gint64 t ) ;
#line 117
extern GDateTime *g_date_time_new_from_timeval_local(GTimeVal *tv ) ;
#line 119
extern GDateTime *g_date_time_new_from_timeval_utc(GTimeVal *tv ) ;
#line 123
extern GDateTime *g_date_time_new_from_iso8601(gchar *text , GTimeZone *default_tz ) ;
#line 127
extern GDateTime *g_date_time_new(GTimeZone *tz , gint year , gint month , gint day ,
                                  gint hour , gint minute , gdouble seconds ) ;
#line 135
extern GDateTime *g_date_time_new_local(gint year , gint month , gint day , gint hour ,
                                        gint minute , gdouble seconds ) ;
#line 142
extern GDateTime *g_date_time_new_utc(gint year , gint month , gint day , gint hour ,
                                      gint minute , gdouble seconds ) ;
#line 151
extern GDateTime *g_date_time_add(GDateTime *datetime , GTimeSpan timespan ) ;
#line 156
extern GDateTime *g_date_time_add_years(GDateTime *datetime , gint years ) ;
#line 160
extern GDateTime *g_date_time_add_months(GDateTime *datetime , gint months ) ;
#line 164
extern GDateTime *g_date_time_add_weeks(GDateTime *datetime , gint weeks ) ;
#line 168
extern GDateTime *g_date_time_add_days(GDateTime *datetime , gint days ) ;
#line 173
extern GDateTime *g_date_time_add_hours(GDateTime *datetime , gint hours ) ;
#line 177
extern GDateTime *g_date_time_add_minutes(GDateTime *datetime , gint minutes ) ;
#line 181
extern GDateTime *g_date_time_add_seconds(GDateTime *datetime , gdouble seconds ) ;
#line 186
extern GDateTime *g_date_time_add_full(GDateTime *datetime , gint years , gint months ,
                                       gint days , gint hours , gint minutes , gdouble seconds ) ;
#line 195
extern gint g_date_time_compare(gconstpointer dt1 , gconstpointer dt2 ) ;
#line 198
extern GTimeSpan g_date_time_difference(GDateTime *end , GDateTime *begin ) ;
#line 201
extern guint g_date_time_hash(gconstpointer datetime ) ;
#line 203
extern gboolean g_date_time_equal(gconstpointer dt1 , gconstpointer dt2 ) ;
#line 207
extern void g_date_time_get_ymd(GDateTime *datetime , gint *year , gint *month , gint *day ) ;
#line 213
extern gint g_date_time_get_year(GDateTime *datetime ) ;
#line 215
extern gint g_date_time_get_month(GDateTime *datetime ) ;
#line 217
extern gint g_date_time_get_day_of_month(GDateTime *datetime ) ;
#line 220
extern gint g_date_time_get_week_numbering_year(GDateTime *datetime ) ;
#line 222
extern gint g_date_time_get_week_of_year(GDateTime *datetime ) ;
#line 224
extern gint g_date_time_get_day_of_week(GDateTime *datetime ) ;
#line 227
extern gint g_date_time_get_day_of_year(GDateTime *datetime ) ;
#line 230
extern gint g_date_time_get_hour(GDateTime *datetime ) ;
#line 232
extern gint g_date_time_get_minute(GDateTime *datetime ) ;
#line 234
extern gint g_date_time_get_second(GDateTime *datetime ) ;
#line 236
extern gint g_date_time_get_microsecond(GDateTime *datetime ) ;
#line 238
extern gdouble g_date_time_get_seconds(GDateTime *datetime ) ;
#line 241
extern gint64 g_date_time_to_unix(GDateTime *datetime ) ;
#line 244
extern gboolean g_date_time_to_timeval(GDateTime *datetime , GTimeVal *tv ) ;
#line 249
extern GTimeSpan g_date_time_get_utc_offset(GDateTime *datetime ) ;
#line 251
extern GTimeZone *g_date_time_get_timezone(GDateTime *datetime ) ;
#line 253
extern gchar *g_date_time_get_timezone_abbreviation(GDateTime *datetime ) ;
#line 255
extern gboolean g_date_time_is_daylight_savings(GDateTime *datetime ) ;
#line 258
extern GDateTime *g_date_time_to_timezone(GDateTime *datetime , GTimeZone *tz ) ;
#line 261
extern GDateTime *g_date_time_to_local(GDateTime *datetime ) ;
#line 263
extern GDateTime *g_date_time_to_utc(GDateTime *datetime ) ;
#line 266
extern gchar *g_date_time_format(GDateTime *datetime , gchar *format ) ;
#line 269
extern gchar *g_date_time_format_iso8601(GDateTime *datetime ) ;
#line 71 "/usr/include/glib-2.0/glib/gbookmarkfile.h"
extern GQuark g_bookmark_file_error_quark(void) ;
#line 81
extern GBookmarkFile *g_bookmark_file_new(void) ;
#line 83
extern void g_bookmark_file_free(GBookmarkFile *bookmark ) ;
#line 86
extern gboolean g_bookmark_file_load_from_file(GBookmarkFile *bookmark , gchar *filename ,
                                               GError **error ) ;
#line 90
extern gboolean g_bookmark_file_load_from_data(GBookmarkFile *bookmark , gchar *data ,
                                               gsize length , GError **error ) ;
#line 95
extern gboolean g_bookmark_file_load_from_data_dirs(GBookmarkFile *bookmark , gchar *file ,
                                                    gchar **full_path , GError **error ) ;
#line 100
extern gchar *g_bookmark_file_to_data(GBookmarkFile *bookmark , gsize *length , GError **error ) ;
#line 104
extern gboolean g_bookmark_file_to_file(GBookmarkFile *bookmark , gchar *filename ,
                                        GError **error ) ;
#line 109
extern void g_bookmark_file_set_title(GBookmarkFile *bookmark , gchar *uri , gchar *title ) ;
#line 113
extern gchar *g_bookmark_file_get_title(GBookmarkFile *bookmark , gchar *uri , GError **error ) ;
#line 117
extern void g_bookmark_file_set_description(GBookmarkFile *bookmark , gchar *uri ,
                                            gchar *description ) ;
#line 121
extern gchar *g_bookmark_file_get_description(GBookmarkFile *bookmark , gchar *uri ,
                                              GError **error ) ;
#line 125
extern void g_bookmark_file_set_mime_type(GBookmarkFile *bookmark , gchar *uri , gchar *mime_type ) ;
#line 129
extern gchar *g_bookmark_file_get_mime_type(GBookmarkFile *bookmark , gchar *uri ,
                                            GError **error ) ;
#line 133
extern void g_bookmark_file_set_groups(GBookmarkFile *bookmark , gchar *uri , gchar **groups ,
                                       gsize length ) ;
#line 138
extern void g_bookmark_file_add_group(GBookmarkFile *bookmark , gchar *uri , gchar *group ) ;
#line 142
extern gboolean g_bookmark_file_has_group(GBookmarkFile *bookmark , gchar *uri , gchar *group ,
                                          GError **error ) ;
#line 147
extern gchar **g_bookmark_file_get_groups(GBookmarkFile *bookmark , gchar *uri , gsize *length ,
                                          GError **error ) ;
#line 152
extern void g_bookmark_file_add_application(GBookmarkFile *bookmark , gchar *uri ,
                                            gchar *name , gchar *exec ) ;
#line 157
extern gboolean g_bookmark_file_has_application(GBookmarkFile *bookmark , gchar *uri ,
                                                gchar *name , GError **error ) ;
#line 162
extern gchar **g_bookmark_file_get_applications(GBookmarkFile *bookmark , gchar *uri ,
                                                gsize *length , GError **error ) ;
#line 167
extern gboolean g_bookmark_file_set_app_info(GBookmarkFile *bookmark , gchar *uri ,
                                             gchar *name , gchar *exec , gint count ,
                                             time_t stamp , GError **error ) ;
#line 175
extern gboolean g_bookmark_file_set_application_info(GBookmarkFile *bookmark , char const   *uri ,
                                                     char const   *name , char const   *exec ,
                                                     int count , GDateTime *stamp ,
                                                     GError **error ) ;
#line 183
extern gboolean g_bookmark_file_get_app_info(GBookmarkFile *bookmark , gchar *uri ,
                                             gchar *name , gchar **exec , guint *count ,
                                             time_t *stamp , GError **error ) ;
#line 191
extern gboolean g_bookmark_file_get_application_info(GBookmarkFile *bookmark , char const   *uri ,
                                                     char const   *name , char **exec ,
                                                     unsigned int *count , GDateTime **stamp ,
                                                     GError **error ) ;
#line 199
extern void g_bookmark_file_set_is_private(GBookmarkFile *bookmark , gchar *uri ,
                                           gboolean is_private ) ;
#line 203
extern gboolean g_bookmark_file_get_is_private(GBookmarkFile *bookmark , gchar *uri ,
                                               GError **error ) ;
#line 207
extern void g_bookmark_file_set_icon(GBookmarkFile *bookmark , gchar *uri , gchar *href ,
                                     gchar *mime_type ) ;
#line 212
extern gboolean g_bookmark_file_get_icon(GBookmarkFile *bookmark , gchar *uri , gchar **href ,
                                         gchar **mime_type , GError **error ) ;
#line 218
extern void g_bookmark_file_set_added(GBookmarkFile *bookmark , gchar *uri , time_t added ) ;
#line 222
extern void g_bookmark_file_set_added_date_time(GBookmarkFile *bookmark , char const   *uri ,
                                                GDateTime *added ) ;
#line 226
extern time_t g_bookmark_file_get_added(GBookmarkFile *bookmark , gchar *uri , GError **error ) ;
#line 230
extern GDateTime *g_bookmark_file_get_added_date_time(GBookmarkFile *bookmark , char const   *uri ,
                                                      GError **error ) ;
#line 234
extern void g_bookmark_file_set_modified(GBookmarkFile *bookmark , gchar *uri , time_t modified ) ;
#line 238
extern void g_bookmark_file_set_modified_date_time(GBookmarkFile *bookmark , char const   *uri ,
                                                   GDateTime *modified ) ;
#line 242
extern time_t g_bookmark_file_get_modified(GBookmarkFile *bookmark , gchar *uri ,
                                           GError **error ) ;
#line 246
extern GDateTime *g_bookmark_file_get_modified_date_time(GBookmarkFile *bookmark ,
                                                         char const   *uri , GError **error ) ;
#line 250
extern void g_bookmark_file_set_visited(GBookmarkFile *bookmark , gchar *uri , time_t visited ) ;
#line 254
extern void g_bookmark_file_set_visited_date_time(GBookmarkFile *bookmark , char const   *uri ,
                                                  GDateTime *visited ) ;
#line 258
extern time_t g_bookmark_file_get_visited(GBookmarkFile *bookmark , gchar *uri , GError **error ) ;
#line 262
extern GDateTime *g_bookmark_file_get_visited_date_time(GBookmarkFile *bookmark ,
                                                        char const   *uri , GError **error ) ;
#line 266
extern gboolean g_bookmark_file_has_item(GBookmarkFile *bookmark , gchar *uri ) ;
#line 269
extern gint g_bookmark_file_get_size(GBookmarkFile *bookmark ) ;
#line 271
extern gchar **g_bookmark_file_get_uris(GBookmarkFile *bookmark , gsize *length ) ;
#line 274
extern gboolean g_bookmark_file_remove_group(GBookmarkFile *bookmark , gchar *uri ,
                                             gchar *group , GError **error ) ;
#line 279
extern gboolean g_bookmark_file_remove_application(GBookmarkFile *bookmark , gchar *uri ,
                                                   gchar *name , GError **error ) ;
#line 284
extern gboolean g_bookmark_file_remove_item(GBookmarkFile *bookmark , gchar *uri ,
                                            GError **error ) ;
#line 288
extern gboolean g_bookmark_file_move_item(GBookmarkFile *bookmark , gchar *old_uri ,
                                          gchar *new_uri , GError **error ) ;
#line 35 "/usr/include/glib-2.0/glib/gbytes.h"
extern GBytes *g_bytes_new(gconstpointer data , gsize size ) ;
#line 39
extern GBytes *g_bytes_new_take(gpointer data , gsize size ) ;
#line 43
extern GBytes *g_bytes_new_static(gconstpointer data , gsize size ) ;
#line 47
extern GBytes *g_bytes_new_with_free_func(gconstpointer data , gsize size , GDestroyNotify free_func ,
                                          gpointer user_data ) ;
#line 53
extern GBytes *g_bytes_new_from_bytes(GBytes *bytes , gsize offset , gsize length ) ;
#line 58
extern gconstpointer g_bytes_get_data(GBytes *bytes , gsize *size ) ;
#line 62
extern gsize g_bytes_get_size(GBytes *bytes ) ;
#line 65
extern GBytes *g_bytes_ref(GBytes *bytes ) ;
#line 68
extern void g_bytes_unref(GBytes *bytes ) ;
#line 71
extern gpointer g_bytes_unref_to_data(GBytes *bytes , gsize *size ) ;
#line 75
extern GByteArray *g_bytes_unref_to_array(GBytes *bytes ) ;
#line 78
extern guint g_bytes_hash(gconstpointer bytes ) ;
#line 81
extern gboolean g_bytes_equal(gconstpointer bytes1 , gconstpointer bytes2 ) ;
#line 85
extern gint g_bytes_compare(gconstpointer bytes1 , gconstpointer bytes2 ) ;
#line 89
extern gconstpointer g_bytes_get_region(GBytes *bytes , gsize element_size , gsize offset ,
                                        gsize n_elements ) ;
#line 31 "/usr/include/glib-2.0/glib/gcharset.h"
extern gboolean g_get_charset(char const   **charset ) ;
#line 33
extern gchar *g_get_codeset(void) ;
#line 35
extern gboolean g_get_console_charset(char const   **charset ) ;
#line 38
extern gchar * const  *g_get_language_names(void) ;
#line 40
extern gchar * const  *g_get_language_names_with_category(gchar *category_name ) ;
#line 43
extern gchar **g_get_locale_variants(gchar *locale ) ;
#line 68 "/usr/include/glib-2.0/glib/gchecksum.h"
extern gssize g_checksum_type_get_length(GChecksumType checksum_type ) ;
#line 71
extern GChecksum *g_checksum_new(GChecksumType checksum_type ) ;
#line 73
extern void g_checksum_reset(GChecksum *checksum ) ;
#line 75
extern GChecksum *g_checksum_copy(GChecksum *checksum ) ;
#line 77
extern void g_checksum_free(GChecksum *checksum ) ;
#line 79
extern void g_checksum_update(GChecksum *checksum , guchar *data , gssize length ) ;
#line 83
extern gchar *g_checksum_get_string(GChecksum *checksum ) ;
#line 85
extern void g_checksum_get_digest(GChecksum *checksum , guint8 *buffer , gsize *digest_len ) ;
#line 90
extern gchar *g_compute_checksum_for_data(GChecksumType checksum_type , guchar *data ,
                                          gsize length ) ;
#line 94
extern gchar *g_compute_checksum_for_string(GChecksumType checksum_type , gchar *str ,
                                            gssize length ) ;
#line 99
extern gchar *g_compute_checksum_for_bytes(GChecksumType checksum_type , GBytes *data ) ;
#line 75 "/usr/include/glib-2.0/glib/gconvert.h"
extern GQuark g_convert_error_quark(void) ;
#line 86
extern GIConv g_iconv_open(gchar *to_codeset , gchar *from_codeset ) ;
#line 89
extern gsize g_iconv(GIConv converter , gchar **inbuf , gsize *inbytes_left , gchar **outbuf ,
                     gsize *outbytes_left ) ;
#line 95
extern gint g_iconv_close(GIConv converter ) ;
#line 99
extern gchar *g_convert(gchar *str , gssize len , gchar *to_codeset , gchar *from_codeset ,
                        gsize *bytes_read , gsize *bytes_written , GError **error ) ;
#line 107
extern gchar *g_convert_with_iconv(gchar *str , gssize len , GIConv converter , gsize *bytes_read ,
                                   gsize *bytes_written , GError **error ) ;
#line 114
extern gchar *g_convert_with_fallback(gchar *str , gssize len , gchar *to_codeset ,
                                      gchar *from_codeset , gchar *fallback , gsize *bytes_read ,
                                      gsize *bytes_written , GError **error ) ;
#line 127
extern gchar *g_locale_to_utf8(gchar *opsysstring , gssize len , gsize *bytes_read ,
                               gsize *bytes_written , GError **error ) ;
#line 133
extern gchar *g_locale_from_utf8(gchar *utf8string , gssize len , gsize *bytes_read ,
                                 gsize *bytes_written , GError **error ) ;
#line 143
extern gchar *g_filename_to_utf8(gchar *opsysstring , gssize len , gsize *bytes_read ,
                                 gsize *bytes_written , GError **error ) ;
#line 149
extern gchar *g_filename_from_utf8(gchar *utf8string , gssize len , gsize *bytes_read ,
                                   gsize *bytes_written , GError **error ) ;
#line 156
extern gchar *g_filename_from_uri(gchar *uri , gchar **hostname , GError **error ) ;
#line 161
extern gchar *g_filename_to_uri(gchar *filename , gchar *hostname , GError **error ) ;
#line 165
extern gchar *g_filename_display_name(gchar *filename ) ;
#line 167
extern gboolean g_get_filename_charsets(gchar ***filename_charsets ) ;
#line 170
extern gchar *g_filename_display_basename(gchar *filename ) ;
#line 173
extern gchar **g_uri_list_extract_uris(gchar *uri_list ) ;
#line 45 "/usr/include/glib-2.0/glib/gdataset.h"
extern void g_datalist_init(GData **datalist ) ;
#line 47
extern void g_datalist_clear(GData **datalist ) ;
#line 49
extern gpointer g_datalist_id_get_data(GData **datalist , GQuark key_id ) ;
#line 52
extern void g_datalist_id_set_data_full(GData **datalist , GQuark key_id , gpointer data ,
                                        GDestroyNotify destroy_func ) ;
#line 60
extern gpointer g_datalist_id_dup_data(GData **datalist , GQuark key_id , GDuplicateFunc dup_func ,
                                       gpointer user_data ) ;
#line 65
extern gboolean g_datalist_id_replace_data(GData **datalist , GQuark key_id , gpointer oldval ,
                                           gpointer newval , GDestroyNotify destroy ,
                                           GDestroyNotify *old_destroy ) ;
#line 73
extern gpointer g_datalist_id_remove_no_notify(GData **datalist , GQuark key_id ) ;
#line 76
extern void g_datalist_foreach(GData **datalist , GDataForeachFunc func , gpointer user_data ) ;
#line 90
extern void g_datalist_set_flags(GData **datalist , guint flags ) ;
#line 93
extern void g_datalist_unset_flags(GData **datalist , guint flags ) ;
#line 96
extern guint g_datalist_get_flags(GData **datalist ) ;
#line 114
extern void g_dataset_destroy(gconstpointer dataset_location ) ;
#line 116
extern gpointer g_dataset_id_get_data(gconstpointer dataset_location , GQuark key_id ) ;
#line 119
extern gpointer g_datalist_get_data(GData **datalist , gchar *key ) ;
#line 122
extern void g_dataset_id_set_data_full(gconstpointer dataset_location , GQuark key_id ,
                                       gpointer data , GDestroyNotify destroy_func ) ;
#line 127
extern gpointer g_dataset_id_remove_no_notify(gconstpointer dataset_location , GQuark key_id ) ;
#line 130
extern void g_dataset_foreach(gconstpointer dataset_location , GDataForeachFunc func ,
                              gpointer user_data ) ;
#line 121 "/usr/include/glib-2.0/glib/gdate.h"
extern GDate *g_date_new(void) ;
#line 123
extern GDate *g_date_new_dmy(GDateDay day , GDateMonth month , GDateYear year ) ;
#line 127
extern GDate *g_date_new_julian(guint32 julian_day ) ;
#line 129
extern void g_date_free(GDate *date ) ;
#line 131
extern GDate *g_date_copy(GDate *date ) ;
#line 139
extern gboolean g_date_valid(GDate *date ) ;
#line 141
extern gboolean g_date_valid_day(GDateDay day ) ;
#line 143
extern gboolean g_date_valid_month(GDateMonth month ) ;
#line 145
extern gboolean g_date_valid_year(GDateYear year ) ;
#line 147
extern gboolean g_date_valid_weekday(GDateWeekday weekday ) ;
#line 149
extern gboolean g_date_valid_julian(guint32 julian_date ) ;
#line 151
extern gboolean g_date_valid_dmy(GDateDay day , GDateMonth month , GDateYear year ) ;
#line 156
extern GDateWeekday g_date_get_weekday(GDate *date ) ;
#line 158
extern GDateMonth g_date_get_month(GDate *date ) ;
#line 160
extern GDateYear g_date_get_year(GDate *date ) ;
#line 162
extern GDateDay g_date_get_day(GDate *date ) ;
#line 164
extern guint32 g_date_get_julian(GDate *date ) ;
#line 166
extern guint g_date_get_day_of_year(GDate *date ) ;
#line 174
extern guint g_date_get_monday_week_of_year(GDate *date ) ;
#line 176
extern guint g_date_get_sunday_week_of_year(GDate *date ) ;
#line 178
extern guint g_date_get_iso8601_week_of_year(GDate *date ) ;
#line 185
extern void g_date_clear(GDate *date , guint n_dates ) ;
#line 193
extern void g_date_set_parse(GDate *date , gchar *str ) ;
#line 196
extern void g_date_set_time_t(GDate *date , time_t timet ) ;
#line 200
extern void g_date_set_time_val(GDate *date , GTimeVal *timeval ) ;
#line 203
extern void g_date_set_time(GDate *date , GTime time_ ) ;
#line 207
extern void g_date_set_month(GDate *date , GDateMonth month ) ;
#line 210
extern void g_date_set_day(GDate *date , GDateDay day ) ;
#line 213
extern void g_date_set_year(GDate *date , GDateYear year ) ;
#line 216
extern void g_date_set_dmy(GDate *date , GDateDay day , GDateMonth month , GDateYear y ) ;
#line 221
extern void g_date_set_julian(GDate *date , guint32 julian_date ) ;
#line 224
extern gboolean g_date_is_first_of_month(GDate *date ) ;
#line 226
extern gboolean g_date_is_last_of_month(GDate *date ) ;
#line 230
extern void g_date_add_days(GDate *date , guint n_days ) ;
#line 233
extern void g_date_subtract_days(GDate *date , guint n_days ) ;
#line 238
extern void g_date_add_months(GDate *date , guint n_months ) ;
#line 241
extern void g_date_subtract_months(GDate *date , guint n_months ) ;
#line 246
extern void g_date_add_years(GDate *date , guint n_years ) ;
#line 249
extern void g_date_subtract_years(GDate *date , guint n_years ) ;
#line 252
extern gboolean g_date_is_leap_year(GDateYear year ) ;
#line 254
extern guint8 g_date_get_days_in_month(GDateMonth month , GDateYear year ) ;
#line 257
extern guint8 g_date_get_monday_weeks_in_year(GDateYear year ) ;
#line 259
extern guint8 g_date_get_sunday_weeks_in_year(GDateYear year ) ;
#line 264
extern gint g_date_days_between(GDate *date1 , GDate *date2 ) ;
#line 269
extern gint g_date_compare(GDate *lhs , GDate *rhs ) ;
#line 272
extern void g_date_to_struct_tm(GDate *date , struct tm *tm ) ;
#line 276
extern void g_date_clamp(GDate *date , GDate *min_date , GDate *max_date ) ;
#line 282
extern void g_date_order(GDate *date1 , GDate *date2 ) ;
#line 288
extern gsize g_date_strftime(gchar *s , gsize slen , gchar *format , GDate *date ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *opendir(char const   *__name ) ;
#line 141
extern DIR *fdopendir(int __fd ) ;
#line 149
extern int closedir(DIR *__dirp ) ;
#line 162
extern struct dirent *readdir(DIR *__dirp ) ;
#line 183
extern int readdir_r(DIR *__dirp , struct dirent *__entry , struct dirent **__result ) ;
#line 209
extern  __attribute__((__nothrow__)) void rewinddir(DIR *__dirp ) ;
#line 215
extern  __attribute__((__nothrow__)) void seekdir(DIR *__dirp , long __pos ) ;
#line 218
extern  __attribute__((__nothrow__)) long telldir(DIR *__dirp ) ;
#line 224
extern  __attribute__((__nothrow__)) int dirfd(DIR *__dirp ) ;
#line 255
extern int scandir(char const   *__dir , struct dirent ***__namelist , int (*__selector)(struct dirent * ) ,
                   int (*__cmp)(struct dirent ** , struct dirent ** ) ) ;
#line 325
extern  __attribute__((__nothrow__)) int alphasort(struct dirent **__e1 , struct dirent **__e2 ) ;
#line 353
extern  __attribute__((__nothrow__)) __ssize_t getdirentries(int __fd , char *__buf ,
                                                             size_t __nbytes , __off_t *__basep ) ;
#line 40 "/usr/include/glib-2.0/glib/gdir.h"
extern GDir *g_dir_open(gchar *path , guint flags , GError **error ) ;
#line 44
extern gchar *g_dir_read_name(GDir *dir ) ;
#line 46
extern void g_dir_rewind(GDir *dir ) ;
#line 48
extern void g_dir_close(GDir *dir ) ;
#line 37 "/usr/include/glib-2.0/glib/genviron.h"
extern gchar *g_getenv(gchar *variable ) ;
#line 39
extern gboolean g_setenv(gchar *variable , gchar *value , gboolean overwrite ) ;
#line 43
extern void g_unsetenv(gchar *variable ) ;
#line 45
extern gchar **g_listenv(void) ;
#line 48
extern gchar **g_get_environ(void) ;
#line 50
extern gchar *g_environ_getenv(gchar **envp , gchar *variable ) ;
#line 53
extern gchar **g_environ_setenv(gchar **envp , gchar *variable , gchar *value , gboolean overwrite ) ;
#line 58
extern gchar **g_environ_unsetenv(gchar **envp , gchar *variable ) ;
#line 109 "/usr/include/glib-2.0/glib/gfileutils.h"
extern GQuark g_file_error_quark(void) ;
#line 112
extern GFileError g_file_error_from_errno(gint err_no ) ;
#line 115
extern gboolean g_file_test(gchar *filename , GFileTest test ) ;
#line 118
extern gboolean g_file_get_contents(gchar *filename , gchar **contents , gsize *length ,
                                    GError **error ) ;
#line 123
extern gboolean g_file_set_contents(gchar *filename , gchar *contents , gssize length ,
                                    GError **error ) ;
#line 129
extern gboolean g_file_set_contents_full(gchar *filename , gchar *contents , gssize length ,
                                         GFileSetContentsFlags flags , int mode ,
                                         GError **error ) ;
#line 137
extern gchar *g_file_read_link(gchar *filename , GError **error ) ;
#line 142
extern gchar *g_mkdtemp(gchar *tmpl ) ;
#line 144
extern gchar *g_mkdtemp_full(gchar *tmpl , gint mode ) ;
#line 149
extern gint g_mkstemp(gchar *tmpl ) ;
#line 151
extern gint g_mkstemp_full(gchar *tmpl , gint flags , gint mode ) ;
#line 157
extern gint g_file_open_tmp(gchar *tmpl , gchar **name_used , GError **error ) ;
#line 161
extern gchar *g_dir_make_tmp(gchar *tmpl , GError **error ) ;
#line 165
extern gchar *g_build_path(gchar *separator , gchar *first_element  , ...) ;
#line 169
extern gchar *g_build_pathv(gchar *separator , gchar **args ) ;
#line 173
extern gchar *g_build_filename(gchar *first_element  , ...) ;
#line 176
extern gchar *g_build_filenamev(gchar **args ) ;
#line 178
extern gchar *g_build_filename_valist(gchar *first_element , va_list *args ) ;
#line 182
extern gint g_mkdir_with_parents(gchar *pathname , gint mode ) ;
#line 200
extern gboolean g_path_is_absolute(gchar *file_name ) ;
#line 202
extern gchar *g_path_skip_root(gchar *file_name ) ;
#line 205
extern gchar *g_basename(gchar *file_name ) ;
#line 209
extern gchar *g_get_current_dir(void) ;
#line 211
extern gchar *g_path_get_basename(gchar *file_name ) ;
#line 213
extern gchar *g_path_get_dirname(gchar *file_name ) ;
#line 216
extern gchar *g_canonicalize_filename(gchar *filename , gchar *relative_to ) ;
#line 37 "/usr/include/glib-2.0/glib/ggettext.h"
extern gchar *g_strip_context(gchar *msgid , gchar *msgval ) ;
#line 41
extern gchar *g_dgettext(gchar *domain , gchar *msgid ) ;
#line 44
extern gchar *g_dcgettext(gchar *domain , gchar *msgid , gint category ) ;
#line 48
extern gchar *g_dngettext(gchar *domain , gchar *msgid , gchar *msgid_plural , gulong n ) ;
#line 53
extern gchar *g_dpgettext(gchar *domain , gchar *msgctxtid , gsize msgidoffset ) ;
#line 57
extern gchar *g_dpgettext2(gchar *domain , gchar *context , gchar *msgid ) ;
#line 72 "/usr/include/glib-2.0/glib/gmem.h"
extern void g_free(gpointer mem ) ;
#line 75
extern void g_clear_pointer(gpointer *pp , GDestroyNotify destroy ) ;
#line 79
extern gpointer g_malloc(gsize n_bytes ) ;
#line 81
extern gpointer g_malloc0(gsize n_bytes ) ;
#line 83
extern gpointer g_realloc(gpointer mem , gsize n_bytes ) ;
#line 86
extern gpointer g_try_malloc(gsize n_bytes ) ;
#line 88
extern gpointer g_try_malloc0(gsize n_bytes ) ;
#line 90
extern gpointer g_try_realloc(gpointer mem , gsize n_bytes ) ;
#line 94
extern gpointer g_malloc_n(gsize n_blocks , gsize n_block_bytes ) ;
#line 97
extern gpointer g_malloc0_n(gsize n_blocks , gsize n_block_bytes ) ;
#line 100
extern gpointer g_realloc_n(gpointer mem , gsize n_blocks , gsize n_block_bytes ) ;
#line 104
extern gpointer g_try_malloc_n(gsize n_blocks , gsize n_block_bytes ) ;
#line 107
extern gpointer g_try_malloc0_n(gsize n_blocks , gsize n_block_bytes ) ;
#line 110
extern gpointer g_try_realloc_n(gpointer mem , gsize n_blocks , gsize n_block_bytes ) ;
#line 115
extern gpointer g_aligned_alloc(gsize n_blocks , gsize n_block_bytes , gsize alignment ) ;
#line 119
extern gpointer g_aligned_alloc0(gsize n_blocks , gsize n_block_bytes , gsize alignment ) ;
#line 123
extern void g_aligned_free(gpointer mem ) ;
#line 216 "/usr/include/glib-2.0/glib/gmem.h"
__inline static gpointer g_steal_pointer(gpointer pp ) 
{ 
  gpointer *ptr ;
  gpointer ref ;

  {
#line 218
  ptr = (gpointer *)pp;
#line 221
  ref = *ptr;
#line 222
  *ptr = (void *)0;
#line 224
  return (ref);
}
}
#line 393
extern void g_mem_set_vtable(GMemVTable *vtable ) ;
#line 395
extern gboolean g_mem_is_system_malloc(void) ;
#line 397
extern gboolean g_mem_gc_friendly ;
#line 401
extern GMemVTable *glib_mem_profiler_table ;
#line 403
extern void g_mem_profile(void) ;
#line 99 "/usr/include/glib-2.0/glib/gnode.h"
extern GNode *g_node_new(gpointer data ) ;
#line 101
extern void g_node_destroy(GNode *root ) ;
#line 103
extern void g_node_unlink(GNode *node ) ;
#line 105
extern GNode *g_node_copy_deep(GNode *node , GCopyFunc copy_func , gpointer data ) ;
#line 109
extern GNode *g_node_copy(GNode *node ) ;
#line 111
extern GNode *g_node_insert(GNode *parent , gint position , GNode *node ) ;
#line 115
extern GNode *g_node_insert_before(GNode *parent , GNode *sibling , GNode *node ) ;
#line 119
extern GNode *g_node_insert_after(GNode *parent , GNode *sibling , GNode *node ) ;
#line 123
extern GNode *g_node_prepend(GNode *parent , GNode *node ) ;
#line 126
extern guint g_node_n_nodes(GNode *root , GTraverseFlags flags ) ;
#line 129
extern GNode *g_node_get_root(GNode *node ) ;
#line 131
extern gboolean g_node_is_ancestor(GNode *node , GNode *descendant ) ;
#line 134
extern guint g_node_depth(GNode *node ) ;
#line 136
extern GNode *g_node_find(GNode *root , GTraverseType order , GTraverseFlags flags ,
                          gpointer data ) ;
#line 224
extern void g_node_traverse(GNode *root , GTraverseType order , GTraverseFlags flags ,
                            gint max_depth , GNodeTraverseFunc func , gpointer data ) ;
#line 237
extern guint g_node_max_height(GNode *root ) ;
#line 240
extern void g_node_children_foreach(GNode *node , GTraverseFlags flags , GNodeForeachFunc func ,
                                    gpointer data ) ;
#line 245
extern void g_node_reverse_children(GNode *node ) ;
#line 247
extern guint g_node_n_children(GNode *node ) ;
#line 249
extern GNode *g_node_nth_child(GNode *node , guint n ) ;
#line 252
extern GNode *g_node_last_child(GNode *node ) ;
#line 254
extern GNode *g_node_find_child(GNode *node , GTraverseFlags flags , gpointer data ) ;
#line 258
extern gint g_node_child_position(GNode *node , GNode *child ) ;
#line 261
extern gint g_node_child_index(GNode *node , gpointer data ) ;
#line 265
extern GNode *g_node_first_sibling(GNode *node ) ;
#line 267
extern GNode *g_node_last_sibling(GNode *node ) ;
#line 49 "/usr/include/glib-2.0/glib/glist.h"
extern GList *g_list_alloc(void) ;
#line 51
extern void g_list_free(GList *list ) ;
#line 53
extern void g_list_free_1(GList *list ) ;
#line 56
extern void g_list_free_full(GList *list , GDestroyNotify free_func ) ;
#line 59
extern GList *g_list_append(GList *list , gpointer data ) ;
#line 62
extern GList *g_list_prepend(GList *list , gpointer data ) ;
#line 65
extern GList *g_list_insert(GList *list , gpointer data , gint position ) ;
#line 69
extern GList *g_list_insert_sorted(GList *list , gpointer data , GCompareFunc func ) ;
#line 73
extern GList *g_list_insert_sorted_with_data(GList *list , gpointer data , GCompareDataFunc func ,
                                             gpointer user_data ) ;
#line 78
extern GList *g_list_insert_before(GList *list , GList *sibling , gpointer data ) ;
#line 82
extern GList *g_list_insert_before_link(GList *list , GList *sibling , GList *link_ ) ;
#line 86
extern GList *g_list_concat(GList *list1 , GList *list2 ) ;
#line 89
extern GList *g_list_remove(GList *list , gconstpointer data ) ;
#line 92
extern GList *g_list_remove_all(GList *list , gconstpointer data ) ;
#line 95
extern GList *g_list_remove_link(GList *list , GList *llink ) ;
#line 98
extern GList *g_list_delete_link(GList *list , GList *link_ ) ;
#line 101
extern GList *g_list_reverse(GList *list ) ;
#line 103
extern GList *g_list_copy(GList *list ) ;
#line 106
extern GList *g_list_copy_deep(GList *list , GCopyFunc func , gpointer user_data ) ;
#line 111
extern GList *g_list_nth(GList *list , guint n ) ;
#line 114
extern GList *g_list_nth_prev(GList *list , guint n ) ;
#line 117
extern GList *g_list_find(GList *list , gconstpointer data ) ;
#line 120
extern GList *g_list_find_custom(GList *list , gconstpointer data , GCompareFunc func ) ;
#line 124
extern gint g_list_position(GList *list , GList *llink ) ;
#line 127
extern gint g_list_index(GList *list , gconstpointer data ) ;
#line 130
extern GList *g_list_last(GList *list ) ;
#line 132
extern GList *g_list_first(GList *list ) ;
#line 134
extern guint g_list_length(GList *list ) ;
#line 136
extern void g_list_foreach(GList *list , GFunc func , gpointer user_data ) ;
#line 140
extern GList *g_list_sort(GList *list , GCompareFunc compare_func ) ;
#line 143
extern GList *g_list_sort_with_data(GList *list , GCompareDataFunc compare_func ,
                                    gpointer user_data ) ;
#line 147
extern gpointer g_list_nth_data(GList *list , guint n ) ;
#line 151
extern void g_clear_list(GList **list_ptr , GDestroyNotify destroy ) ;
#line 57 "/usr/include/glib-2.0/glib/ghash.h"
extern GHashTable *g_hash_table_new(GHashFunc hash_func , GEqualFunc key_equal_func ) ;
#line 60
extern GHashTable *g_hash_table_new_full(GHashFunc hash_func , GEqualFunc key_equal_func ,
                                         GDestroyNotify key_destroy_func , GDestroyNotify value_destroy_func ) ;
#line 65
extern GHashTable *g_hash_table_new_similar(GHashTable *other_hash_table ) ;
#line 67
extern void g_hash_table_destroy(GHashTable *hash_table ) ;
#line 69
extern gboolean g_hash_table_insert(GHashTable *hash_table , gpointer key , gpointer value ) ;
#line 73
extern gboolean g_hash_table_replace(GHashTable *hash_table , gpointer key , gpointer value ) ;
#line 77
extern gboolean g_hash_table_add(GHashTable *hash_table , gpointer key ) ;
#line 80
extern gboolean g_hash_table_remove(GHashTable *hash_table , gconstpointer key ) ;
#line 83
extern void g_hash_table_remove_all(GHashTable *hash_table ) ;
#line 85
extern gboolean g_hash_table_steal(GHashTable *hash_table , gconstpointer key ) ;
#line 88
extern gboolean g_hash_table_steal_extended(GHashTable *hash_table , gconstpointer lookup_key ,
                                            gpointer *stolen_key , gpointer *stolen_value ) ;
#line 93
extern void g_hash_table_steal_all(GHashTable *hash_table ) ;
#line 95
extern gpointer g_hash_table_lookup(GHashTable *hash_table , gconstpointer key ) ;
#line 98
extern gboolean g_hash_table_contains(GHashTable *hash_table , gconstpointer key ) ;
#line 101
extern gboolean g_hash_table_lookup_extended(GHashTable *hash_table , gconstpointer lookup_key ,
                                             gpointer *orig_key , gpointer *value ) ;
#line 106
extern void g_hash_table_foreach(GHashTable *hash_table , GHFunc func , gpointer user_data ) ;
#line 110
extern gpointer g_hash_table_find(GHashTable *hash_table , GHRFunc predicate , gpointer user_data ) ;
#line 114
extern guint g_hash_table_foreach_remove(GHashTable *hash_table , GHRFunc func , gpointer user_data ) ;
#line 118
extern guint g_hash_table_foreach_steal(GHashTable *hash_table , GHRFunc func , gpointer user_data ) ;
#line 122
extern guint g_hash_table_size(GHashTable *hash_table ) ;
#line 124
extern GList *g_hash_table_get_keys(GHashTable *hash_table ) ;
#line 126
extern GList *g_hash_table_get_values(GHashTable *hash_table ) ;
#line 128
extern gpointer *g_hash_table_get_keys_as_array(GHashTable *hash_table , guint *length ) ;
#line 132
extern void g_hash_table_iter_init(GHashTableIter *iter , GHashTable *hash_table ) ;
#line 135
extern gboolean g_hash_table_iter_next(GHashTableIter *iter , gpointer *key , gpointer *value ) ;
#line 139
extern GHashTable *g_hash_table_iter_get_hash_table(GHashTableIter *iter ) ;
#line 141
extern void g_hash_table_iter_remove(GHashTableIter *iter ) ;
#line 143
extern void g_hash_table_iter_replace(GHashTableIter *iter , gpointer value ) ;
#line 146
extern void g_hash_table_iter_steal(GHashTableIter *iter ) ;
#line 149
extern GHashTable *g_hash_table_ref(GHashTable *hash_table ) ;
#line 151
extern void g_hash_table_unref(GHashTable *hash_table ) ;
#line 159
extern gboolean g_str_equal(gconstpointer v1 , gconstpointer v2 ) ;
#line 162
extern guint g_str_hash(gconstpointer v ) ;
#line 165
extern gboolean g_int_equal(gconstpointer v1 , gconstpointer v2 ) ;
#line 168
extern guint g_int_hash(gconstpointer v ) ;
#line 171
extern gboolean g_int64_equal(gconstpointer v1 , gconstpointer v2 ) ;
#line 174
extern guint g_int64_hash(gconstpointer v ) ;
#line 177
extern gboolean g_double_equal(gconstpointer v1 , gconstpointer v2 ) ;
#line 180
extern guint g_double_hash(gconstpointer v ) ;
#line 183
extern guint g_direct_hash(gconstpointer v ) ;
#line 185
extern gboolean g_direct_equal(gconstpointer v1 , gconstpointer v2 ) ;
#line 43 "/usr/include/glib-2.0/glib/ghmac.h"
extern GHmac *g_hmac_new(GChecksumType digest_type , guchar *key , gsize key_len ) ;
#line 47
extern GHmac *g_hmac_copy(GHmac *hmac ) ;
#line 49
extern GHmac *g_hmac_ref(GHmac *hmac ) ;
#line 51
extern void g_hmac_unref(GHmac *hmac ) ;
#line 53
extern void g_hmac_update(GHmac *hmac , guchar *data , gssize length ) ;
#line 57
extern gchar *g_hmac_get_string(GHmac *hmac ) ;
#line 59
extern void g_hmac_get_digest(GHmac *hmac , guint8 *buffer , gsize *digest_len ) ;
#line 64
extern gchar *g_compute_hmac_for_data(GChecksumType digest_type , guchar *key , gsize key_len ,
                                      guchar *data , gsize length ) ;
#line 70
extern gchar *g_compute_hmac_for_string(GChecksumType digest_type , guchar *key ,
                                        gsize key_len , gchar *str , gssize length ) ;
#line 76
extern gchar *g_compute_hmac_for_bytes(GChecksumType digest_type , GBytes *key , GBytes *data ) ;
#line 105 "/usr/include/glib-2.0/glib/ghook.h"
extern void g_hook_list_init(GHookList *hook_list , guint hook_size ) ;
#line 108
extern void g_hook_list_clear(GHookList *hook_list ) ;
#line 110
extern GHook *g_hook_alloc(GHookList *hook_list ) ;
#line 112
extern void g_hook_free(GHookList *hook_list , GHook *hook ) ;
#line 115
extern GHook *g_hook_ref(GHookList *hook_list , GHook *hook ) ;
#line 118
extern void g_hook_unref(GHookList *hook_list , GHook *hook ) ;
#line 121
extern gboolean g_hook_destroy(GHookList *hook_list , gulong hook_id ) ;
#line 124
extern void g_hook_destroy_link(GHookList *hook_list , GHook *hook ) ;
#line 127
extern void g_hook_prepend(GHookList *hook_list , GHook *hook ) ;
#line 130
extern void g_hook_insert_before(GHookList *hook_list , GHook *sibling , GHook *hook ) ;
#line 134
extern void g_hook_insert_sorted(GHookList *hook_list , GHook *hook , GHookCompareFunc func ) ;
#line 138
extern GHook *g_hook_get(GHookList *hook_list , gulong hook_id ) ;
#line 141
extern GHook *g_hook_find(GHookList *hook_list , gboolean need_valids , GHookFindFunc func ,
                          gpointer data ) ;
#line 146
extern GHook *g_hook_find_data(GHookList *hook_list , gboolean need_valids , gpointer data ) ;
#line 150
extern GHook *g_hook_find_func(GHookList *hook_list , gboolean need_valids , gpointer func ) ;
#line 154
extern GHook *g_hook_find_func_data(GHookList *hook_list , gboolean need_valids ,
                                    gpointer func , gpointer data ) ;
#line 160
extern GHook *g_hook_first_valid(GHookList *hook_list , gboolean may_be_in_call ) ;
#line 166
extern GHook *g_hook_next_valid(GHookList *hook_list , GHook *hook , gboolean may_be_in_call ) ;
#line 171
extern gint g_hook_compare_ids(GHook *new_hook , GHook *sibling ) ;
#line 179
extern void g_hook_list_invoke(GHookList *hook_list , gboolean may_recurse ) ;
#line 185
extern void g_hook_list_invoke_check(GHookList *hook_list , gboolean may_recurse ) ;
#line 190
extern void g_hook_list_marshal(GHookList *hook_list , gboolean may_recurse , GHookMarshaller marshaller ,
                                gpointer marshal_data ) ;
#line 195
extern void g_hook_list_marshal_check(GHookList *hook_list , gboolean may_recurse ,
                                      GHookCheckMarshaller marshaller , gpointer marshal_data ) ;
#line 30 "/usr/include/glib-2.0/glib/ghostutils.h"
extern gboolean g_hostname_is_non_ascii(gchar *hostname ) ;
#line 32
extern gboolean g_hostname_is_ascii_encoded(gchar *hostname ) ;
#line 34
extern gboolean g_hostname_is_ip_address(gchar *hostname ) ;
#line 37
extern gchar *g_hostname_to_ascii(gchar *hostname ) ;
#line 39
extern gchar *g_hostname_to_unicode(gchar *hostname ) ;
#line 114 "/usr/include/glib-2.0/glib/gpoll.h"
extern gint g_poll(GPollFD *fds , guint nfds , gint timeout ) ;
#line 48 "/usr/include/glib-2.0/glib/gslist.h"
extern GSList *g_slist_alloc(void) ;
#line 50
extern void g_slist_free(GSList *list ) ;
#line 52
extern void g_slist_free_1(GSList *list ) ;
#line 55
extern void g_slist_free_full(GSList *list , GDestroyNotify free_func ) ;
#line 58
extern GSList *g_slist_append(GSList *list , gpointer data ) ;
#line 61
extern GSList *g_slist_prepend(GSList *list , gpointer data ) ;
#line 64
extern GSList *g_slist_insert(GSList *list , gpointer data , gint position ) ;
#line 68
extern GSList *g_slist_insert_sorted(GSList *list , gpointer data , GCompareFunc func ) ;
#line 72
extern GSList *g_slist_insert_sorted_with_data(GSList *list , gpointer data , GCompareDataFunc func ,
                                               gpointer user_data ) ;
#line 77
extern GSList *g_slist_insert_before(GSList *slist , GSList *sibling , gpointer data ) ;
#line 81
extern GSList *g_slist_concat(GSList *list1 , GSList *list2 ) ;
#line 84
extern GSList *g_slist_remove(GSList *list , gconstpointer data ) ;
#line 87
extern GSList *g_slist_remove_all(GSList *list , gconstpointer data ) ;
#line 90
extern GSList *g_slist_remove_link(GSList *list , GSList *link_ ) ;
#line 93
extern GSList *g_slist_delete_link(GSList *list , GSList *link_ ) ;
#line 96
extern GSList *g_slist_reverse(GSList *list ) ;
#line 98
extern GSList *g_slist_copy(GSList *list ) ;
#line 101
extern GSList *g_slist_copy_deep(GSList *list , GCopyFunc func , gpointer user_data ) ;
#line 105
extern GSList *g_slist_nth(GSList *list , guint n ) ;
#line 108
extern GSList *g_slist_find(GSList *list , gconstpointer data ) ;
#line 111
extern GSList *g_slist_find_custom(GSList *list , gconstpointer data , GCompareFunc func ) ;
#line 115
extern gint g_slist_position(GSList *list , GSList *llink ) ;
#line 118
extern gint g_slist_index(GSList *list , gconstpointer data ) ;
#line 121
extern GSList *g_slist_last(GSList *list ) ;
#line 123
extern guint g_slist_length(GSList *list ) ;
#line 125
extern void g_slist_foreach(GSList *list , GFunc func , gpointer user_data ) ;
#line 129
extern GSList *g_slist_sort(GSList *list , GCompareFunc compare_func ) ;
#line 132
extern GSList *g_slist_sort_with_data(GSList *list , GCompareDataFunc compare_func ,
                                      gpointer user_data ) ;
#line 136
extern gpointer g_slist_nth_data(GSList *list , guint n ) ;
#line 140
extern void g_clear_slist(GSList **slist_ptr , GDestroyNotify destroy ) ;
#line 380 "/usr/include/glib-2.0/glib/gmain.h"
extern GMainContext *g_main_context_new(void) ;
#line 383
extern GMainContext *g_main_context_new_with_flags(GMainContextFlags flags ) ;
#line 386
extern GMainContext *g_main_context_ref(GMainContext *context ) ;
#line 388
extern void g_main_context_unref(GMainContext *context ) ;
#line 390
extern GMainContext *g_main_context_default(void) ;
#line 393
extern gboolean g_main_context_iteration(GMainContext *context , gboolean may_block ) ;
#line 396
extern gboolean g_main_context_pending(GMainContext *context ) ;
#line 401
extern GSource *g_main_context_find_source_by_id(GMainContext *context , guint source_id ) ;
#line 404
extern GSource *g_main_context_find_source_by_user_data(GMainContext *context , gpointer user_data ) ;
#line 407
extern GSource *g_main_context_find_source_by_funcs_user_data(GMainContext *context ,
                                                              GSourceFuncs *funcs ,
                                                              gpointer user_data ) ;
#line 414
extern void g_main_context_wakeup(GMainContext *context ) ;
#line 416
extern gboolean g_main_context_acquire(GMainContext *context ) ;
#line 418
extern void g_main_context_release(GMainContext *context ) ;
#line 420
extern gboolean g_main_context_is_owner(GMainContext *context ) ;
#line 422
extern gboolean g_main_context_wait(GMainContext *context , GCond *cond , GMutex *mutex ) ;
#line 427
extern gboolean g_main_context_prepare(GMainContext *context , gint *priority ) ;
#line 430
extern gint g_main_context_query(GMainContext *context , gint max_priority , gint *timeout_ ,
                                 GPollFD *fds , gint n_fds ) ;
#line 436
extern gboolean g_main_context_check(GMainContext *context , gint max_priority , GPollFD *fds ,
                                     gint n_fds ) ;
#line 441
extern void g_main_context_dispatch(GMainContext *context ) ;
#line 444
extern void g_main_context_set_poll_func(GMainContext *context , GPollFunc func ) ;
#line 447
extern GPollFunc g_main_context_get_poll_func(GMainContext *context ) ;
#line 452
extern void g_main_context_add_poll(GMainContext *context , GPollFD *fd , gint priority ) ;
#line 456
extern void g_main_context_remove_poll(GMainContext *context , GPollFD *fd ) ;
#line 460
extern gint g_main_depth(void) ;
#line 462
extern GSource *g_main_current_source(void) ;
#line 467
extern void g_main_context_push_thread_default(GMainContext *context ) ;
#line 469
extern void g_main_context_pop_thread_default(GMainContext *context ) ;
#line 471
extern GMainContext *g_main_context_get_thread_default(void) ;
#line 473
extern GMainContext *g_main_context_ref_thread_default(void) ;
#line 532 "/usr/include/glib-2.0/glib/gmain.h"
__inline static GMainContextPusher *g_main_context_pusher_new(GMainContext *main_context ) 
{ 


  {
  {
#line 534
  g_main_context_push_thread_default(main_context);
  }
#line 535
  return ((GMainContextPusher *)main_context);
}
}
#line 554 "/usr/include/glib-2.0/glib/gmain.h"
__inline static void g_main_context_pusher_free(GMainContextPusher *pusher ) 
{ 


  {
  {
#line 556
  g_main_context_pop_thread_default((GMainContext *)pusher);
  }
  return;
}
}
#line 563
extern GMainLoop *g_main_loop_new(GMainContext *context , gboolean is_running ) ;
#line 566
extern void g_main_loop_run(GMainLoop *loop ) ;
#line 568
extern void g_main_loop_quit(GMainLoop *loop ) ;
#line 570
extern GMainLoop *g_main_loop_ref(GMainLoop *loop ) ;
#line 572
extern void g_main_loop_unref(GMainLoop *loop ) ;
#line 574
extern gboolean g_main_loop_is_running(GMainLoop *loop ) ;
#line 576
extern GMainContext *g_main_loop_get_context(GMainLoop *loop ) ;
#line 581
extern GSource *g_source_new(GSourceFuncs *source_funcs , guint struct_size ) ;
#line 586
extern void g_source_set_dispose_function(GSource *source , GSourceDisposeFunc dispose ) ;
#line 591
extern GSource *g_source_ref(GSource *source ) ;
#line 593
extern void g_source_unref(GSource *source ) ;
#line 596
extern guint g_source_attach(GSource *source , GMainContext *context ) ;
#line 599
extern void g_source_destroy(GSource *source ) ;
#line 602
extern void g_source_set_priority(GSource *source , gint priority ) ;
#line 605
extern gint g_source_get_priority(GSource *source ) ;
#line 607
extern void g_source_set_can_recurse(GSource *source , gboolean can_recurse ) ;
#line 610
extern gboolean g_source_get_can_recurse(GSource *source ) ;
#line 612
extern guint g_source_get_id(GSource *source ) ;
#line 615
extern GMainContext *g_source_get_context(GSource *source ) ;
#line 618
extern void g_source_set_callback(GSource *source , GSourceFunc func , gpointer data ,
                                  GDestroyNotify notify ) ;
#line 624
extern void g_source_set_funcs(GSource *source , GSourceFuncs *funcs ) ;
#line 627
extern gboolean g_source_is_destroyed(GSource *source ) ;
#line 630
extern void g_source_set_name(GSource *source , char const   *name ) ;
#line 633
extern void g_source_set_static_name(GSource *source , char const   *name ) ;
#line 636
extern char const   *g_source_get_name(GSource *source ) ;
#line 638
extern void g_source_set_name_by_id(guint tag , char const   *name ) ;
#line 642
extern void g_source_set_ready_time(GSource *source , gint64 ready_time ) ;
#line 645
extern gint64 g_source_get_ready_time(GSource *source ) ;
#line 649
extern gpointer g_source_add_unix_fd(GSource *source , gint fd , GIOCondition events ) ;
#line 653
extern void g_source_modify_unix_fd(GSource *source , gpointer tag , GIOCondition new_events ) ;
#line 657
extern void g_source_remove_unix_fd(GSource *source , gpointer tag ) ;
#line 660
extern GIOCondition g_source_query_unix_fd(GSource *source , gpointer tag ) ;
#line 666
extern void g_source_set_callback_indirect(GSource *source , gpointer callback_data ,
                                           GSourceCallbackFuncs *callback_funcs ) ;
#line 671
extern void g_source_add_poll(GSource *source , GPollFD *fd ) ;
#line 674
extern void g_source_remove_poll(GSource *source , GPollFD *fd ) ;
#line 678
extern void g_source_add_child_source(GSource *source , GSource *child_source ) ;
#line 681
extern void g_source_remove_child_source(GSource *source , GSource *child_source ) ;
#line 686
extern void g_source_get_current_time(GSource *source , GTimeVal *timeval ) ;
#line 691
extern gint64 g_source_get_time(GSource *source ) ;
#line 700
extern GSource *g_idle_source_new(void) ;
#line 702
extern GSource *g_child_watch_source_new(GPid pid ) ;
#line 704
extern GSource *g_timeout_source_new(guint interval ) ;
#line 706
extern GSource *g_timeout_source_new_seconds(guint interval ) ;
#line 712
extern void g_get_current_time(GTimeVal *result ) ;
#line 716
extern gint64 g_get_monotonic_time(void) ;
#line 718
extern gint64 g_get_real_time(void) ;
#line 723
extern gboolean g_source_remove(guint tag ) ;
#line 725
extern gboolean g_source_remove_by_user_data(gpointer user_data ) ;
#line 727
extern gboolean g_source_remove_by_funcs_user_data(GSourceFuncs *funcs , gpointer user_data ) ;
#line 744
extern void g_clear_handle_id(guint *tag_ptr , GClearHandleFunc clear_func ) ;
#line 764
extern guint g_timeout_add_full(gint priority , guint interval , GSourceFunc function ,
                                gpointer data , GDestroyNotify notify ) ;
#line 770
extern guint g_timeout_add(guint interval , GSourceFunc function , gpointer data ) ;
#line 774
extern guint g_timeout_add_seconds_full(gint priority , guint interval , GSourceFunc function ,
                                        gpointer data , GDestroyNotify notify ) ;
#line 780
extern guint g_timeout_add_seconds(guint interval , GSourceFunc function , gpointer data ) ;
#line 784
extern guint g_child_watch_add_full(gint priority , GPid pid , GChildWatchFunc function ,
                                    gpointer data , GDestroyNotify notify ) ;
#line 790
extern guint g_child_watch_add(GPid pid , GChildWatchFunc function , gpointer data ) ;
#line 794
extern guint g_idle_add(GSourceFunc function , gpointer data ) ;
#line 797
extern guint g_idle_add_full(gint priority , GSourceFunc function , gpointer data ,
                             GDestroyNotify notify ) ;
#line 802
extern gboolean g_idle_remove_by_data(gpointer data ) ;
#line 805
extern void g_main_context_invoke_full(GMainContext *context , gint priority , GSourceFunc function ,
                                       gpointer data , GDestroyNotify notify ) ;
#line 811
extern void g_main_context_invoke(GMainContext *context , GSourceFunc function , gpointer data ) ;
#line 817 "/usr/include/glib-2.0/glib/gmain.h"
__inline static int g_steal_fd(int *fd_ptr ) 
{ 
  int fd ;

  {
#line 819
  fd = *fd_ptr;
#line 820
  *fd_ptr = - 1;
#line 821
  return (fd);
}
}
#line 825
extern GSourceFuncs g_timeout_funcs ;
#line 826
extern GSourceFuncs g_child_watch_funcs ;
#line 827
extern GSourceFuncs g_idle_funcs ;
#line 829
extern GSourceFuncs g_unix_signal_funcs ;
#line 830
extern GSourceFuncs g_unix_fd_source_funcs ;
#line 650 "/usr/include/glib-2.0/glib/gunicode.h"
extern guint32 g_unicode_script_to_iso15924(GUnicodeScript script ) ;
#line 652
extern GUnicodeScript g_unicode_script_from_iso15924(guint32 iso15924 ) ;
#line 657
extern gboolean g_unichar_isalnum(gunichar c ) ;
#line 659
extern gboolean g_unichar_isalpha(gunichar c ) ;
#line 661
extern gboolean g_unichar_iscntrl(gunichar c ) ;
#line 663
extern gboolean g_unichar_isdigit(gunichar c ) ;
#line 665
extern gboolean g_unichar_isgraph(gunichar c ) ;
#line 667
extern gboolean g_unichar_islower(gunichar c ) ;
#line 669
extern gboolean g_unichar_isprint(gunichar c ) ;
#line 671
extern gboolean g_unichar_ispunct(gunichar c ) ;
#line 673
extern gboolean g_unichar_isspace(gunichar c ) ;
#line 675
extern gboolean g_unichar_isupper(gunichar c ) ;
#line 677
extern gboolean g_unichar_isxdigit(gunichar c ) ;
#line 679
extern gboolean g_unichar_istitle(gunichar c ) ;
#line 681
extern gboolean g_unichar_isdefined(gunichar c ) ;
#line 683
extern gboolean g_unichar_iswide(gunichar c ) ;
#line 685
extern gboolean g_unichar_iswide_cjk(gunichar c ) ;
#line 687
extern gboolean g_unichar_iszerowidth(gunichar c ) ;
#line 689
extern gboolean g_unichar_ismark(gunichar c ) ;
#line 694
extern gunichar g_unichar_toupper(gunichar c ) ;
#line 696
extern gunichar g_unichar_tolower(gunichar c ) ;
#line 698
extern gunichar g_unichar_totitle(gunichar c ) ;
#line 703
extern gint g_unichar_digit_value(gunichar c ) ;
#line 706
extern gint g_unichar_xdigit_value(gunichar c ) ;
#line 710
extern GUnicodeType g_unichar_type(gunichar c ) ;
#line 714
extern GUnicodeBreakType g_unichar_break_type(gunichar c ) ;
#line 718
extern gint g_unichar_combining_class(gunichar uc ) ;
#line 721
extern gboolean g_unichar_get_mirror_char(gunichar ch , gunichar *mirrored_ch ) ;
#line 725
extern GUnicodeScript g_unichar_get_script(gunichar ch ) ;
#line 729
extern gboolean g_unichar_validate(gunichar ch ) ;
#line 733
extern gboolean g_unichar_compose(gunichar a , gunichar b , gunichar *ch ) ;
#line 737
extern gboolean g_unichar_decompose(gunichar ch , gunichar *a , gunichar *b ) ;
#line 742
extern gsize g_unichar_fully_decompose(gunichar ch , gboolean compat , gunichar *result ,
                                       gsize result_len ) ;
#line 763
extern void g_unicode_canonical_ordering(gunichar *string , gsize len ) ;
#line 768
extern gunichar *g_unicode_canonical_decomposition(gunichar ch , gsize *result_len ) ;
#line 773
extern gchar * const  g_utf8_skip ;
#line 794
extern gunichar g_utf8_get_char(gchar *p ) ;
#line 796
extern gunichar g_utf8_get_char_validated(gchar *p , gssize max_len ) ;
#line 800
extern gchar *g_utf8_offset_to_pointer(gchar *str , glong offset ) ;
#line 803
extern glong g_utf8_pointer_to_offset(gchar *str , gchar *pos ) ;
#line 806
extern gchar *g_utf8_prev_char(gchar *p ) ;
#line 808
extern gchar *g_utf8_find_next_char(gchar *p , gchar *end ) ;
#line 811
extern gchar *g_utf8_find_prev_char(gchar *str , gchar *p ) ;
#line 815
extern glong g_utf8_strlen(gchar *p , gssize max ) ;
#line 819
extern gchar *g_utf8_substring(gchar *str , glong start_pos , glong end_pos ) ;
#line 824
extern gchar *g_utf8_strncpy(gchar *dest , gchar *src , gsize n ) ;
#line 831
extern gchar *g_utf8_strchr(gchar *p , gssize len , gunichar c ) ;
#line 835
extern gchar *g_utf8_strrchr(gchar *p , gssize len , gunichar c ) ;
#line 839
extern gchar *g_utf8_strreverse(gchar *str , gssize len ) ;
#line 843
extern gunichar2 *g_utf8_to_utf16(gchar *str , glong len , glong *items_read , glong *items_written ,
                                  GError **error ) ;
#line 849
extern gunichar *g_utf8_to_ucs4(gchar *str , glong len , glong *items_read , glong *items_written ,
                                GError **error ) ;
#line 855
extern gunichar *g_utf8_to_ucs4_fast(gchar *str , glong len , glong *items_written ) ;
#line 859
extern gunichar *g_utf16_to_ucs4(gunichar2 *str , glong len , glong *items_read ,
                                 glong *items_written , GError **error ) ;
#line 865
extern gchar *g_utf16_to_utf8(gunichar2 *str , glong len , glong *items_read , glong *items_written ,
                              GError **error ) ;
#line 871
extern gunichar2 *g_ucs4_to_utf16(gunichar *str , glong len , glong *items_read ,
                                  glong *items_written , GError **error ) ;
#line 877
extern gchar *g_ucs4_to_utf8(gunichar *str , glong len , glong *items_read , glong *items_written ,
                             GError **error ) ;
#line 884
extern gint g_unichar_to_utf8(gunichar c , gchar *outbuf ) ;
#line 888
extern gboolean g_utf8_validate(gchar *str , gssize max_len , gchar **end ) ;
#line 892
extern gboolean g_utf8_validate_len(gchar *str , gsize max_len , gchar **end ) ;
#line 897
extern gchar *g_utf8_strup(gchar *str , gssize len ) ;
#line 900
extern gchar *g_utf8_strdown(gchar *str , gssize len ) ;
#line 903
extern gchar *g_utf8_casefold(gchar *str , gssize len ) ;
#line 942
extern gchar *g_utf8_normalize(gchar *str , gssize len , GNormalizeMode mode ) ;
#line 947
extern gint g_utf8_collate(gchar *str1 , gchar *str2 ) ;
#line 950
extern gchar *g_utf8_collate_key(gchar *str , gssize len ) ;
#line 953
extern gchar *g_utf8_collate_key_for_filename(gchar *str , gssize len ) ;
#line 957
extern gchar *g_utf8_make_valid(gchar *str , gssize len ) ;
#line 49 "/usr/include/glib-2.0/glib/gstring.h"
extern GString *g_string_new(gchar *init ) ;
#line 51
extern GString *g_string_new_len(gchar *init , gssize len ) ;
#line 54
extern GString *g_string_sized_new(gsize dfl_size ) ;
#line 56
extern gchar *g_string_free(GString *string , gboolean free_segment ) ;
#line 59
extern GBytes *g_string_free_to_bytes(GString *string ) ;
#line 61
extern gboolean g_string_equal(GString *v , GString *v2 ) ;
#line 64
extern guint g_string_hash(GString *str ) ;
#line 66
extern GString *g_string_assign(GString *string , gchar *rval ) ;
#line 69
extern GString *g_string_truncate(GString *string , gsize len ) ;
#line 72
extern GString *g_string_set_size(GString *string , gsize len ) ;
#line 75
extern GString *g_string_insert_len(GString *string , gssize pos , gchar *val , gssize len ) ;
#line 80
extern GString *g_string_append(GString *string , gchar *val ) ;
#line 83
extern GString *g_string_append_len(GString *string , gchar *val , gssize len ) ;
#line 87
extern GString *g_string_append_c(GString *string , gchar c ) ;
#line 90
extern GString *g_string_append_unichar(GString *string , gunichar wc ) ;
#line 93
extern GString *g_string_prepend(GString *string , gchar *val ) ;
#line 96
extern GString *g_string_prepend_c(GString *string , gchar c ) ;
#line 99
extern GString *g_string_prepend_unichar(GString *string , gunichar wc ) ;
#line 102
extern GString *g_string_prepend_len(GString *string , gchar *val , gssize len ) ;
#line 106
extern GString *g_string_insert(GString *string , gssize pos , gchar *val ) ;
#line 110
extern GString *g_string_insert_c(GString *string , gssize pos , gchar c ) ;
#line 114
extern GString *g_string_insert_unichar(GString *string , gssize pos , gunichar wc ) ;
#line 118
extern GString *g_string_overwrite(GString *string , gsize pos , gchar *val ) ;
#line 122
extern GString *g_string_overwrite_len(GString *string , gsize pos , gchar *val ,
                                       gssize len ) ;
#line 127
extern GString *g_string_erase(GString *string , gssize pos , gssize len ) ;
#line 131
extern guint g_string_replace(GString *string , gchar *find , gchar *replace , guint limit ) ;
#line 136
extern GString *g_string_ascii_down(GString *string ) ;
#line 138
extern GString *g_string_ascii_up(GString *string ) ;
#line 140
extern void g_string_vprintf(GString *string , gchar *format , va_list args ) ;
#line 145
extern void g_string_printf(GString *string , gchar *format  , ...) ;
#line 149
extern void g_string_append_vprintf(GString *string , gchar *format , va_list args ) ;
#line 154
extern void g_string_append_printf(GString *string , gchar *format  , ...) ;
#line 158
extern GString *g_string_append_uri_escaped(GString *string , gchar *unescaped , gchar *reserved_chars_allowed ,
                                            gboolean allow_utf8 ) ;
#line 166 "/usr/include/glib-2.0/glib/gstring.h"
__inline static GString *g_string_append_c_inline(GString *gstring , gchar c ) 
{ 
  gsize __cil_tmp3 ;

  {
#line 169
  if (gstring->len + 1UL < gstring->allocated_len) {
#line 171
    __cil_tmp3 = gstring->len;
#line 171
    (gstring->len) ++;
#line 171
    *(gstring->str + __cil_tmp3) = c;
#line 172
    *(gstring->str + gstring->len) = (gchar )0;
  } else {
    {
#line 175
    g_string_insert_c(gstring, (gssize )(- 1), c);
    }
  }
#line 176
  return (gstring);
}
}
#line 183
extern GString *g_string_down(GString *string ) ;
#line 185
extern GString *g_string_up(GString *string ) ;
#line 159 "/usr/include/glib-2.0/glib/giochannel.h"
extern void g_io_channel_init(GIOChannel *channel ) ;
#line 161
extern GIOChannel *g_io_channel_ref(GIOChannel *channel ) ;
#line 163
extern void g_io_channel_unref(GIOChannel *channel ) ;
#line 166
extern GIOError g_io_channel_read(GIOChannel *channel , gchar *buf , gsize count ,
                                  gsize *bytes_read ) ;
#line 172
extern GIOError g_io_channel_write(GIOChannel *channel , gchar *buf , gsize count ,
                                   gsize *bytes_written ) ;
#line 178
extern GIOError g_io_channel_seek(GIOChannel *channel , gint64 offset , GSeekType type ) ;
#line 183
extern void g_io_channel_close(GIOChannel *channel ) ;
#line 186
extern GIOStatus g_io_channel_shutdown(GIOChannel *channel , gboolean flush , GError **err ) ;
#line 190
extern guint g_io_add_watch_full(GIOChannel *channel , gint priority , GIOCondition condition ,
                                 GIOFunc func , gpointer user_data , GDestroyNotify notify ) ;
#line 197
extern GSource *g_io_create_watch(GIOChannel *channel , GIOCondition condition ) ;
#line 200
extern guint g_io_add_watch(GIOChannel *channel , GIOCondition condition , GIOFunc func ,
                            gpointer user_data ) ;
#line 209
extern void g_io_channel_set_buffer_size(GIOChannel *channel , gsize size ) ;
#line 212
extern gsize g_io_channel_get_buffer_size(GIOChannel *channel ) ;
#line 214
extern GIOCondition g_io_channel_get_buffer_condition(GIOChannel *channel ) ;
#line 216
extern GIOStatus g_io_channel_set_flags(GIOChannel *channel , GIOFlags flags , GError **error ) ;
#line 220
extern GIOFlags g_io_channel_get_flags(GIOChannel *channel ) ;
#line 222
extern void g_io_channel_set_line_term(GIOChannel *channel , gchar *line_term , gint length ) ;
#line 226
extern gchar *g_io_channel_get_line_term(GIOChannel *channel , gint *length ) ;
#line 229
extern void g_io_channel_set_buffered(GIOChannel *channel , gboolean buffered ) ;
#line 232
extern gboolean g_io_channel_get_buffered(GIOChannel *channel ) ;
#line 234
extern GIOStatus g_io_channel_set_encoding(GIOChannel *channel , gchar *encoding ,
                                           GError **error ) ;
#line 238
extern gchar *g_io_channel_get_encoding(GIOChannel *channel ) ;
#line 240
extern void g_io_channel_set_close_on_unref(GIOChannel *channel , gboolean do_close ) ;
#line 243
extern gboolean g_io_channel_get_close_on_unref(GIOChannel *channel ) ;
#line 247
extern GIOStatus g_io_channel_flush(GIOChannel *channel , GError **error ) ;
#line 250
extern GIOStatus g_io_channel_read_line(GIOChannel *channel , gchar **str_return ,
                                        gsize *length , gsize *terminator_pos , GError **error ) ;
#line 256
extern GIOStatus g_io_channel_read_line_string(GIOChannel *channel , GString *buffer ,
                                               gsize *terminator_pos , GError **error ) ;
#line 261
extern GIOStatus g_io_channel_read_to_end(GIOChannel *channel , gchar **str_return ,
                                          gsize *length , GError **error ) ;
#line 266
extern GIOStatus g_io_channel_read_chars(GIOChannel *channel , gchar *buf , gsize count ,
                                         gsize *bytes_read , GError **error ) ;
#line 272
extern GIOStatus g_io_channel_read_unichar(GIOChannel *channel , gunichar *thechar ,
                                           GError **error ) ;
#line 276
extern GIOStatus g_io_channel_write_chars(GIOChannel *channel , gchar *buf , gssize count ,
                                          gsize *bytes_written , GError **error ) ;
#line 282
extern GIOStatus g_io_channel_write_unichar(GIOChannel *channel , gunichar thechar ,
                                            GError **error ) ;
#line 286
extern GIOStatus g_io_channel_seek_position(GIOChannel *channel , gint64 offset ,
                                            GSeekType type , GError **error ) ;
#line 291
extern GIOChannel *g_io_channel_new_file(gchar *filename , gchar *mode , GError **error ) ;
#line 298
extern GQuark g_io_channel_error_quark(void) ;
#line 300
extern GIOChannelError g_io_channel_error_from_errno(gint en ) ;
#line 321
extern GIOChannel *g_io_channel_unix_new(int fd ) ;
#line 323
extern gint g_io_channel_unix_get_fd(GIOChannel *channel ) ;
#line 327
extern GSourceFuncs g_io_watch_funcs ;
#line 46 "/usr/include/glib-2.0/glib/gkeyfile.h"
extern GQuark g_key_file_error_quark(void) ;
#line 58
extern GKeyFile *g_key_file_new(void) ;
#line 60
extern GKeyFile *g_key_file_ref(GKeyFile *key_file ) ;
#line 62
extern void g_key_file_unref(GKeyFile *key_file ) ;
#line 64
extern void g_key_file_free(GKeyFile *key_file ) ;
#line 66
extern void g_key_file_set_list_separator(GKeyFile *key_file , gchar separator ) ;
#line 69
extern gboolean g_key_file_load_from_file(GKeyFile *key_file , gchar *file , GKeyFileFlags flags ,
                                          GError **error ) ;
#line 74
extern gboolean g_key_file_load_from_data(GKeyFile *key_file , gchar *data , gsize length ,
                                          GKeyFileFlags flags , GError **error ) ;
#line 80
extern gboolean g_key_file_load_from_bytes(GKeyFile *key_file , GBytes *bytes , GKeyFileFlags flags ,
                                           GError **error ) ;
#line 85
extern gboolean g_key_file_load_from_dirs(GKeyFile *key_file , gchar *file , gchar **search_dirs ,
                                          gchar **full_path , GKeyFileFlags flags ,
                                          GError **error ) ;
#line 92
extern gboolean g_key_file_load_from_data_dirs(GKeyFile *key_file , gchar *file ,
                                               gchar **full_path , GKeyFileFlags flags ,
                                               GError **error ) ;
#line 98
extern gchar *g_key_file_to_data(GKeyFile *key_file , gsize *length , GError **error ) ;
#line 102
extern gboolean g_key_file_save_to_file(GKeyFile *key_file , gchar *filename , GError **error ) ;
#line 106
extern gchar *g_key_file_get_start_group(GKeyFile *key_file ) ;
#line 108
extern gchar **g_key_file_get_groups(GKeyFile *key_file , gsize *length ) ;
#line 111
extern gchar **g_key_file_get_keys(GKeyFile *key_file , gchar *group_name , gsize *length ,
                                   GError **error ) ;
#line 116
extern gboolean g_key_file_has_group(GKeyFile *key_file , gchar *group_name ) ;
#line 119
extern gboolean g_key_file_has_key(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                   GError **error ) ;
#line 124
extern gchar *g_key_file_get_value(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                   GError **error ) ;
#line 129
extern void g_key_file_set_value(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                 gchar *value ) ;
#line 134
extern gchar *g_key_file_get_string(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                    GError **error ) ;
#line 139
extern void g_key_file_set_string(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                  gchar *string ) ;
#line 144
extern gchar *g_key_file_get_locale_string(GKeyFile *key_file , gchar *group_name ,
                                           gchar *key , gchar *locale , GError **error ) ;
#line 150
extern gchar *g_key_file_get_locale_for_key(GKeyFile *key_file , gchar *group_name ,
                                            gchar *key , gchar *locale ) ;
#line 155
extern void g_key_file_set_locale_string(GKeyFile *key_file , gchar *group_name ,
                                         gchar *key , gchar *locale , gchar *string ) ;
#line 161
extern gboolean g_key_file_get_boolean(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                       GError **error ) ;
#line 166
extern void g_key_file_set_boolean(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                   gboolean value ) ;
#line 171
extern gint g_key_file_get_integer(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                   GError **error ) ;
#line 176
extern void g_key_file_set_integer(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                   gint value ) ;
#line 181
extern gint64 g_key_file_get_int64(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                   GError **error ) ;
#line 186
extern void g_key_file_set_int64(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                 gint64 value ) ;
#line 191
extern guint64 g_key_file_get_uint64(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                     GError **error ) ;
#line 196
extern void g_key_file_set_uint64(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                  guint64 value ) ;
#line 201
extern gdouble g_key_file_get_double(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                     GError **error ) ;
#line 206
extern void g_key_file_set_double(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                  gdouble value ) ;
#line 211
extern gchar **g_key_file_get_string_list(GKeyFile *key_file , gchar *group_name ,
                                          gchar *key , gsize *length , GError **error ) ;
#line 217
extern void g_key_file_set_string_list(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                       gchar * const  list[] , gsize length ) ;
#line 223
extern gchar **g_key_file_get_locale_string_list(GKeyFile *key_file , gchar *group_name ,
                                                 gchar *key , gchar *locale , gsize *length ,
                                                 GError **error ) ;
#line 230
extern void g_key_file_set_locale_string_list(GKeyFile *key_file , gchar *group_name ,
                                              gchar *key , gchar *locale , gchar * const  list[] ,
                                              gsize length ) ;
#line 237
extern gboolean *g_key_file_get_boolean_list(GKeyFile *key_file , gchar *group_name ,
                                             gchar *key , gsize *length , GError **error ) ;
#line 243
extern void g_key_file_set_boolean_list(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                        gboolean list[] , gsize length ) ;
#line 249
extern gint *g_key_file_get_integer_list(GKeyFile *key_file , gchar *group_name ,
                                         gchar *key , gsize *length , GError **error ) ;
#line 255
extern void g_key_file_set_double_list(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                       gdouble list[] , gsize length ) ;
#line 261
extern gdouble *g_key_file_get_double_list(GKeyFile *key_file , gchar *group_name ,
                                           gchar *key , gsize *length , GError **error ) ;
#line 267
extern void g_key_file_set_integer_list(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                        gint list[] , gsize length ) ;
#line 273
extern gboolean g_key_file_set_comment(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                       gchar *comment , GError **error ) ;
#line 279
extern gchar *g_key_file_get_comment(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                     GError **error ) ;
#line 285
extern gboolean g_key_file_remove_comment(GKeyFile *key_file , gchar *group_name ,
                                          gchar *key , GError **error ) ;
#line 290
extern gboolean g_key_file_remove_key(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                      GError **error ) ;
#line 295
extern gboolean g_key_file_remove_group(GKeyFile *key_file , gchar *group_name , GError **error ) ;
#line 35 "/usr/include/glib-2.0/glib/gmappedfile.h"
extern GMappedFile *g_mapped_file_new(gchar *filename , gboolean writable , GError **error ) ;
#line 39
extern GMappedFile *g_mapped_file_new_from_fd(gint fd , gboolean writable , GError **error ) ;
#line 43
extern gsize g_mapped_file_get_length(GMappedFile *file ) ;
#line 45
extern gchar *g_mapped_file_get_contents(GMappedFile *file ) ;
#line 47
extern GBytes *g_mapped_file_get_bytes(GMappedFile *file ) ;
#line 49
extern GMappedFile *g_mapped_file_ref(GMappedFile *file ) ;
#line 51
extern void g_mapped_file_unref(GMappedFile *file ) ;
#line 54
extern void g_mapped_file_free(GMappedFile *file ) ;
#line 73 "/usr/include/glib-2.0/glib/gmarkup.h"
extern GQuark g_markup_error_quark(void) ;
#line 187
extern GMarkupParseContext *g_markup_parse_context_new(GMarkupParser *parser , GMarkupParseFlags flags ,
                                                       gpointer user_data , GDestroyNotify user_data_dnotify ) ;
#line 192
extern GMarkupParseContext *g_markup_parse_context_ref(GMarkupParseContext *context ) ;
#line 194
extern void g_markup_parse_context_unref(GMarkupParseContext *context ) ;
#line 196
extern void g_markup_parse_context_free(GMarkupParseContext *context ) ;
#line 198
extern gboolean g_markup_parse_context_parse(GMarkupParseContext *context , gchar *text ,
                                             gssize text_len , GError **error ) ;
#line 203
extern void g_markup_parse_context_push(GMarkupParseContext *context , GMarkupParser *parser ,
                                        gpointer user_data ) ;
#line 207
extern gpointer g_markup_parse_context_pop(GMarkupParseContext *context ) ;
#line 210
extern gboolean g_markup_parse_context_end_parse(GMarkupParseContext *context , GError **error ) ;
#line 213
extern gchar *g_markup_parse_context_get_element(GMarkupParseContext *context ) ;
#line 215
extern GSList *g_markup_parse_context_get_element_stack(GMarkupParseContext *context ) ;
#line 219
extern void g_markup_parse_context_get_position(GMarkupParseContext *context , gint *line_number ,
                                                gint *char_number ) ;
#line 223
extern gpointer g_markup_parse_context_get_user_data(GMarkupParseContext *context ) ;
#line 227
extern gchar *g_markup_escape_text(gchar *text , gssize length ) ;
#line 231
extern gchar *g_markup_printf_escaped(char const   *format  , ...) ;
#line 234
extern gchar *g_markup_vprintf_escaped(char const   *format , va_list args ) ;
#line 251
extern gboolean g_markup_collect_attributes(gchar *element_name , gchar **attribute_names ,
                                            gchar **attribute_values , GError **error ,
                                            GMarkupCollectType first_type , gchar *first_attr 
                                            , ...) ;
#line 296 "/usr/include/glib-2.0/glib/gvarianttype.h"
extern gboolean g_variant_type_string_is_valid(gchar *type_string ) ;
#line 298
extern gboolean g_variant_type_string_scan(gchar *string , gchar *limit , gchar **endptr ) ;
#line 304
extern void g_variant_type_free(GVariantType *type ) ;
#line 306
extern GVariantType *g_variant_type_copy(GVariantType *type ) ;
#line 308
extern GVariantType *g_variant_type_new(gchar *type_string ) ;
#line 312
extern gsize g_variant_type_get_string_length(GVariantType *type ) ;
#line 314
extern gchar *g_variant_type_peek_string(GVariantType *type ) ;
#line 316
extern gchar *g_variant_type_dup_string(GVariantType *type ) ;
#line 320
extern gboolean g_variant_type_is_definite(GVariantType *type ) ;
#line 322
extern gboolean g_variant_type_is_container(GVariantType *type ) ;
#line 324
extern gboolean g_variant_type_is_basic(GVariantType *type ) ;
#line 326
extern gboolean g_variant_type_is_maybe(GVariantType *type ) ;
#line 328
extern gboolean g_variant_type_is_array(GVariantType *type ) ;
#line 330
extern gboolean g_variant_type_is_tuple(GVariantType *type ) ;
#line 332
extern gboolean g_variant_type_is_dict_entry(GVariantType *type ) ;
#line 334
extern gboolean g_variant_type_is_variant(GVariantType *type ) ;
#line 338
extern guint g_variant_type_hash(gconstpointer type ) ;
#line 340
extern gboolean g_variant_type_equal(gconstpointer type1 , gconstpointer type2 ) ;
#line 345
extern gboolean g_variant_type_is_subtype_of(GVariantType *type , GVariantType *supertype ) ;
#line 350
extern GVariantType *g_variant_type_element(GVariantType *type ) ;
#line 352
extern GVariantType *g_variant_type_first(GVariantType *type ) ;
#line 354
extern GVariantType *g_variant_type_next(GVariantType *type ) ;
#line 356
extern gsize g_variant_type_n_items(GVariantType *type ) ;
#line 358
extern GVariantType *g_variant_type_key(GVariantType *type ) ;
#line 360
extern GVariantType *g_variant_type_value(GVariantType *type ) ;
#line 364
extern GVariantType *g_variant_type_new_array(GVariantType *element ) ;
#line 366
extern GVariantType *g_variant_type_new_maybe(GVariantType *element ) ;
#line 368
extern GVariantType *g_variant_type_new_tuple(GVariantType * const  *items , gint length ) ;
#line 371
extern GVariantType *g_variant_type_new_dict_entry(GVariantType *key , GVariantType *value ) ;
#line 376
extern GVariantType *g_variant_type_checked_(gchar * ) ;
#line 378
extern gsize g_variant_type_string_get_depth_(gchar *type_string ) ;
#line 59 "/usr/include/glib-2.0/glib/gvariant.h"
extern void g_variant_unref(GVariant *value ) ;
#line 61
extern GVariant *g_variant_ref(GVariant *value ) ;
#line 63
extern GVariant *g_variant_ref_sink(GVariant *value ) ;
#line 65
extern gboolean g_variant_is_floating(GVariant *value ) ;
#line 67
extern GVariant *g_variant_take_ref(GVariant *value ) ;
#line 70
extern GVariantType *g_variant_get_type(GVariant *value ) ;
#line 72
extern gchar *g_variant_get_type_string(GVariant *value ) ;
#line 74
extern gboolean g_variant_is_of_type(GVariant *value , GVariantType *type ) ;
#line 77
extern gboolean g_variant_is_container(GVariant *value ) ;
#line 79
extern GVariantClass g_variant_classify(GVariant *value ) ;
#line 81
extern GVariant *g_variant_new_boolean(gboolean value ) ;
#line 83
extern GVariant *g_variant_new_byte(guint8 value ) ;
#line 85
extern GVariant *g_variant_new_int16(gint16 value ) ;
#line 87
extern GVariant *g_variant_new_uint16(guint16 value ) ;
#line 89
extern GVariant *g_variant_new_int32(gint32 value ) ;
#line 91
extern GVariant *g_variant_new_uint32(guint32 value ) ;
#line 93
extern GVariant *g_variant_new_int64(gint64 value ) ;
#line 95
extern GVariant *g_variant_new_uint64(guint64 value ) ;
#line 97
extern GVariant *g_variant_new_handle(gint32 value ) ;
#line 99
extern GVariant *g_variant_new_double(gdouble value ) ;
#line 101
extern GVariant *g_variant_new_string(gchar *string ) ;
#line 103
extern GVariant *g_variant_new_take_string(gchar *string ) ;
#line 105
extern GVariant *g_variant_new_printf(gchar *format_string  , ...) ;
#line 108
extern GVariant *g_variant_new_object_path(gchar *object_path ) ;
#line 110
extern gboolean g_variant_is_object_path(gchar *string ) ;
#line 112
extern GVariant *g_variant_new_signature(gchar *signature ) ;
#line 114
extern gboolean g_variant_is_signature(gchar *string ) ;
#line 116
extern GVariant *g_variant_new_variant(GVariant *value ) ;
#line 118
extern GVariant *g_variant_new_strv(gchar * const  *strv , gssize length ) ;
#line 121
extern GVariant *g_variant_new_objv(gchar * const  *strv , gssize length ) ;
#line 124
extern GVariant *g_variant_new_bytestring(gchar *string ) ;
#line 126
extern GVariant *g_variant_new_bytestring_array(gchar * const  *strv , gssize length ) ;
#line 129
extern GVariant *g_variant_new_fixed_array(GVariantType *element_type , gconstpointer elements ,
                                           gsize n_elements , gsize element_size ) ;
#line 134
extern gboolean g_variant_get_boolean(GVariant *value ) ;
#line 136
extern guint8 g_variant_get_byte(GVariant *value ) ;
#line 138
extern gint16 g_variant_get_int16(GVariant *value ) ;
#line 140
extern guint16 g_variant_get_uint16(GVariant *value ) ;
#line 142
extern gint32 g_variant_get_int32(GVariant *value ) ;
#line 144
extern guint32 g_variant_get_uint32(GVariant *value ) ;
#line 146
extern gint64 g_variant_get_int64(GVariant *value ) ;
#line 148
extern guint64 g_variant_get_uint64(GVariant *value ) ;
#line 150
extern gint32 g_variant_get_handle(GVariant *value ) ;
#line 152
extern gdouble g_variant_get_double(GVariant *value ) ;
#line 154
extern GVariant *g_variant_get_variant(GVariant *value ) ;
#line 156
extern gchar *g_variant_get_string(GVariant *value , gsize *length ) ;
#line 159
extern gchar *g_variant_dup_string(GVariant *value , gsize *length ) ;
#line 162
extern gchar **g_variant_get_strv(GVariant *value , gsize *length ) ;
#line 165
extern gchar **g_variant_dup_strv(GVariant *value , gsize *length ) ;
#line 168
extern gchar **g_variant_get_objv(GVariant *value , gsize *length ) ;
#line 171
extern gchar **g_variant_dup_objv(GVariant *value , gsize *length ) ;
#line 174
extern gchar *g_variant_get_bytestring(GVariant *value ) ;
#line 176
extern gchar *g_variant_dup_bytestring(GVariant *value , gsize *length ) ;
#line 179
extern gchar **g_variant_get_bytestring_array(GVariant *value , gsize *length ) ;
#line 182
extern gchar **g_variant_dup_bytestring_array(GVariant *value , gsize *length ) ;
#line 186
extern GVariant *g_variant_new_maybe(GVariantType *child_type , GVariant *child ) ;
#line 189
extern GVariant *g_variant_new_array(GVariantType *child_type , GVariant * const  *children ,
                                     gsize n_children ) ;
#line 193
extern GVariant *g_variant_new_tuple(GVariant * const  *children , gsize n_children ) ;
#line 196
extern GVariant *g_variant_new_dict_entry(GVariant *key , GVariant *value ) ;
#line 200
extern GVariant *g_variant_get_maybe(GVariant *value ) ;
#line 202
extern gsize g_variant_n_children(GVariant *value ) ;
#line 204
extern void g_variant_get_child(GVariant *value , gsize index_ , gchar *format_string 
                                , ...) ;
#line 209
extern GVariant *g_variant_get_child_value(GVariant *value , gsize index_ ) ;
#line 212
extern gboolean g_variant_lookup(GVariant *dictionary , gchar *key , gchar *format_string 
                                 , ...) ;
#line 217
extern GVariant *g_variant_lookup_value(GVariant *dictionary , gchar *key , GVariantType *expected_type ) ;
#line 221
extern gconstpointer g_variant_get_fixed_array(GVariant *value , gsize *n_elements ,
                                               gsize element_size ) ;
#line 226
extern gsize g_variant_get_size(GVariant *value ) ;
#line 228
extern gconstpointer g_variant_get_data(GVariant *value ) ;
#line 230
extern GBytes *g_variant_get_data_as_bytes(GVariant *value ) ;
#line 232
extern void g_variant_store(GVariant *value , gpointer data ) ;
#line 236
extern gchar *g_variant_print(GVariant *value , gboolean type_annotate ) ;
#line 239
extern GString *g_variant_print_string(GVariant *value , GString *string , gboolean type_annotate ) ;
#line 244
extern guint g_variant_hash(gconstpointer value ) ;
#line 246
extern gboolean g_variant_equal(gconstpointer one , gconstpointer two ) ;
#line 250
extern GVariant *g_variant_get_normal_form(GVariant *value ) ;
#line 252
extern gboolean g_variant_is_normal_form(GVariant *value ) ;
#line 254
extern GVariant *g_variant_byteswap(GVariant *value ) ;
#line 257
extern GVariant *g_variant_new_from_bytes(GVariantType *type , GBytes *bytes , gboolean trusted ) ;
#line 261
extern GVariant *g_variant_new_from_data(GVariantType *type , gconstpointer data ,
                                         gsize size , gboolean trusted , GDestroyNotify notify ,
                                         gpointer user_data ) ;
#line 275
extern GVariantIter *g_variant_iter_new(GVariant *value ) ;
#line 277
extern gsize g_variant_iter_init(GVariantIter *iter , GVariant *value ) ;
#line 280
extern GVariantIter *g_variant_iter_copy(GVariantIter *iter ) ;
#line 282
extern gsize g_variant_iter_n_children(GVariantIter *iter ) ;
#line 284
extern void g_variant_iter_free(GVariantIter *iter ) ;
#line 286
extern GVariant *g_variant_iter_next_value(GVariantIter *iter ) ;
#line 288
extern gboolean g_variant_iter_next(GVariantIter *iter , gchar *format_string  , ...) ;
#line 292
extern gboolean g_variant_iter_loop(GVariantIter *iter , gchar *format_string  , ...) ;
#line 336
extern GQuark g_variant_parser_get_error_quark(void) ;
#line 339
extern GQuark g_variant_parse_error_quark(void) ;
#line 375
extern GVariantBuilder *g_variant_builder_new(GVariantType *type ) ;
#line 377
extern void g_variant_builder_unref(GVariantBuilder *builder ) ;
#line 379
extern GVariantBuilder *g_variant_builder_ref(GVariantBuilder *builder ) ;
#line 381
extern void g_variant_builder_init(GVariantBuilder *builder , GVariantType *type ) ;
#line 384
extern GVariant *g_variant_builder_end(GVariantBuilder *builder ) ;
#line 386
extern void g_variant_builder_clear(GVariantBuilder *builder ) ;
#line 388
extern void g_variant_builder_open(GVariantBuilder *builder , GVariantType *type ) ;
#line 391
extern void g_variant_builder_close(GVariantBuilder *builder ) ;
#line 393
extern void g_variant_builder_add_value(GVariantBuilder *builder , GVariant *value ) ;
#line 396
extern void g_variant_builder_add(GVariantBuilder *builder , gchar *format_string 
                                  , ...) ;
#line 400
extern void g_variant_builder_add_parsed(GVariantBuilder *builder , gchar *format 
                                         , ...) ;
#line 405
extern GVariant *g_variant_new(gchar *format_string  , ...) ;
#line 408
extern void g_variant_get(GVariant *value , gchar *format_string  , ...) ;
#line 412
extern GVariant *g_variant_new_va(gchar *format_string , gchar **endptr , va_list *app ) ;
#line 416
extern void g_variant_get_va(GVariant *value , gchar *format_string , gchar **endptr ,
                             va_list *app ) ;
#line 421
extern gboolean g_variant_check_format_string(GVariant *value , gchar *format_string ,
                                              gboolean copy_only ) ;
#line 426
extern GVariant *g_variant_parse(GVariantType *type , gchar *text , gchar *limit ,
                                 gchar **endptr , GError **error ) ;
#line 432
extern GVariant *g_variant_new_parsed(gchar *format  , ...) ;
#line 435
extern GVariant *g_variant_new_parsed_va(gchar *format , va_list *app ) ;
#line 439
extern gchar *g_variant_parse_error_print_context(GError *error , gchar *source_str ) ;
#line 443
extern gint g_variant_compare(gconstpointer one , gconstpointer two ) ;
#line 498
extern GVariantDict *g_variant_dict_new(GVariant *from_asv ) ;
#line 501
extern void g_variant_dict_init(GVariantDict *dict , GVariant *from_asv ) ;
#line 505
extern gboolean g_variant_dict_lookup(GVariantDict *dict , gchar *key , gchar *format_string 
                                      , ...) ;
#line 510
extern GVariant *g_variant_dict_lookup_value(GVariantDict *dict , gchar *key , GVariantType *expected_type ) ;
#line 514
extern gboolean g_variant_dict_contains(GVariantDict *dict , gchar *key ) ;
#line 517
extern void g_variant_dict_insert(GVariantDict *dict , gchar *key , gchar *format_string 
                                  , ...) ;
#line 522
extern void g_variant_dict_insert_value(GVariantDict *dict , gchar *key , GVariant *value ) ;
#line 526
extern gboolean g_variant_dict_remove(GVariantDict *dict , gchar *key ) ;
#line 529
extern void g_variant_dict_clear(GVariantDict *dict ) ;
#line 531
extern GVariant *g_variant_dict_end(GVariantDict *dict ) ;
#line 533
extern GVariantDict *g_variant_dict_ref(GVariantDict *dict ) ;
#line 535
extern void g_variant_dict_unref(GVariantDict *dict ) ;
#line 43 "/usr/include/glib-2.0/glib/gmessages.h"
extern gsize g_printf_string_upper_bound(gchar *format , va_list args ) ;
#line 81
extern guint g_log_set_handler(gchar *log_domain , GLogLevelFlags log_levels , GLogFunc log_func ,
                               gpointer user_data ) ;
#line 86
extern guint g_log_set_handler_full(gchar *log_domain , GLogLevelFlags log_levels ,
                                    GLogFunc log_func , gpointer user_data , GDestroyNotify destroy ) ;
#line 92
extern void g_log_remove_handler(gchar *log_domain , guint handler_id ) ;
#line 95
extern void g_log_default_handler(gchar *log_domain , GLogLevelFlags log_level , gchar *message ,
                                  gpointer unused_data ) ;
#line 100
extern GLogFunc g_log_set_default_handler(GLogFunc log_func , gpointer user_data ) ;
#line 103
extern void g_log(gchar *log_domain , GLogLevelFlags log_level , gchar *format  , ...) ;
#line 108
extern void g_logv(gchar *log_domain , GLogLevelFlags log_level , gchar *format ,
                   va_list args ) ;
#line 113
extern GLogLevelFlags g_log_set_fatal_mask(gchar *log_domain , GLogLevelFlags fatal_mask ) ;
#line 116
extern GLogLevelFlags g_log_set_always_fatal(GLogLevelFlags fatal_mask ) ;
#line 201
extern void g_log_structured(gchar *log_domain , GLogLevelFlags log_level  , ...) ;
#line 205
extern void g_log_structured_array(GLogLevelFlags log_level , GLogField *fields ,
                                   gsize n_fields ) ;
#line 210
extern void g_log_variant(gchar *log_domain , GLogLevelFlags log_level , GVariant *fields ) ;
#line 215
extern void g_log_set_writer_func(GLogWriterFunc func , gpointer user_data , GDestroyNotify user_data_free ) ;
#line 220
extern gboolean g_log_writer_supports_color(gint output_fd ) ;
#line 222
extern gboolean g_log_writer_is_journald(gint output_fd ) ;
#line 225
extern gchar *g_log_writer_format_fields(GLogLevelFlags log_level , GLogField *fields ,
                                         gsize n_fields , gboolean use_color ) ;
#line 231
extern GLogWriterOutput g_log_writer_journald(GLogLevelFlags log_level , GLogField *fields ,
                                              gsize n_fields , gpointer user_data ) ;
#line 236
extern GLogWriterOutput g_log_writer_standard_streams(GLogLevelFlags log_level , GLogField *fields ,
                                                      gsize n_fields , gpointer user_data ) ;
#line 241
extern GLogWriterOutput g_log_writer_default(GLogLevelFlags log_level , GLogField *fields ,
                                             gsize n_fields , gpointer user_data ) ;
#line 247
extern void g_log_writer_default_set_use_stderr(gboolean use_stderr ) ;
#line 249
extern gboolean g_log_writer_default_would_drop(GLogLevelFlags log_level , char const   *log_domain ) ;
#line 254
extern gboolean g_log_get_debug_enabled(void) ;
#line 256
extern void g_log_set_debug_enabled(gboolean enabled ) ;
#line 276
void _g_log_fallback_handler(gchar *log_domain , GLogLevelFlags log_level , gchar *message ,
                             gpointer unused_data ) ;
#line 283
extern void g_return_if_fail_warning(char const   *log_domain , char const   *pretty_function ,
                                     char const   *expression ) ;
#line 287
extern void g_warn_message(char const   *domain , char const   *file , int line ,
                           char const   *func , char const   *warnexpr ) ;
#line 294
extern void g_assert_warning(char const   *log_domain , char const   *file , int const   line ,
                             char const   *pretty_function , char const   *expression ) ;
#line 301
extern void g_log_structured_standard(gchar *log_domain , GLogLevelFlags log_level ,
                                      gchar *file , gchar *line , gchar *func , gchar *message_format 
                                      , ...) ;
#line 517
extern void g_print(gchar *format  , ...) ;
#line 520
extern GPrintFunc g_set_print_handler(GPrintFunc func ) ;
#line 522
extern void g_printerr(gchar *format  , ...) ;
#line 525
extern GPrintFunc g_set_printerr_handler(GPrintFunc func ) ;
#line 214 "/usr/include/glib-2.0/glib/goption.h"
extern GQuark g_option_error_quark(void) ;
#line 308
extern GOptionContext *g_option_context_new(gchar *parameter_string ) ;
#line 310
extern void g_option_context_set_summary(GOptionContext *context , gchar *summary ) ;
#line 313
extern gchar *g_option_context_get_summary(GOptionContext *context ) ;
#line 315
extern void g_option_context_set_description(GOptionContext *context , gchar *description ) ;
#line 318
extern gchar *g_option_context_get_description(GOptionContext *context ) ;
#line 320
extern void g_option_context_free(GOptionContext *context ) ;
#line 322
extern void g_option_context_set_help_enabled(GOptionContext *context , gboolean help_enabled ) ;
#line 325
extern gboolean g_option_context_get_help_enabled(GOptionContext *context ) ;
#line 327
extern void g_option_context_set_ignore_unknown_options(GOptionContext *context ,
                                                        gboolean ignore_unknown ) ;
#line 330
extern gboolean g_option_context_get_ignore_unknown_options(GOptionContext *context ) ;
#line 333
extern void g_option_context_set_strict_posix(GOptionContext *context , gboolean strict_posix ) ;
#line 336
extern gboolean g_option_context_get_strict_posix(GOptionContext *context ) ;
#line 339
extern void g_option_context_add_main_entries(GOptionContext *context , GOptionEntry *entries ,
                                              gchar *translation_domain ) ;
#line 343
extern gboolean g_option_context_parse(GOptionContext *context , gint *argc , gchar ***argv ,
                                       GError **error ) ;
#line 348
extern gboolean g_option_context_parse_strv(GOptionContext *context , gchar ***arguments ,
                                            GError **error ) ;
#line 352
extern void g_option_context_set_translate_func(GOptionContext *context , GTranslateFunc func ,
                                                gpointer data , GDestroyNotify destroy_notify ) ;
#line 357
extern void g_option_context_set_translation_domain(GOptionContext *context , gchar *domain ) ;
#line 361
extern void g_option_context_add_group(GOptionContext *context , GOptionGroup *group ) ;
#line 364
extern void g_option_context_set_main_group(GOptionContext *context , GOptionGroup *group ) ;
#line 367
extern GOptionGroup *g_option_context_get_main_group(GOptionContext *context ) ;
#line 369
extern gchar *g_option_context_get_help(GOptionContext *context , gboolean main_help ,
                                        GOptionGroup *group ) ;
#line 374
extern GOptionGroup *g_option_group_new(gchar *name , gchar *description , gchar *help_description ,
                                        gpointer user_data , GDestroyNotify destroy ) ;
#line 380
extern void g_option_group_set_parse_hooks(GOptionGroup *group , GOptionParseFunc pre_parse_func ,
                                           GOptionParseFunc post_parse_func ) ;
#line 384
extern void g_option_group_set_error_hook(GOptionGroup *group , GOptionErrorFunc error_func ) ;
#line 387
extern void g_option_group_free(GOptionGroup *group ) ;
#line 389
extern GOptionGroup *g_option_group_ref(GOptionGroup *group ) ;
#line 391
extern void g_option_group_unref(GOptionGroup *group ) ;
#line 393
extern void g_option_group_add_entries(GOptionGroup *group , GOptionEntry *entries ) ;
#line 396
extern void g_option_group_set_translate_func(GOptionGroup *group , GTranslateFunc func ,
                                              gpointer data , GDestroyNotify destroy_notify ) ;
#line 401
extern void g_option_group_set_translation_domain(GOptionGroup *group , gchar *domain ) ;
#line 33 "/usr/include/glib-2.0/glib/gpattern.h"
extern GPatternSpec *g_pattern_spec_new(gchar *pattern ) ;
#line 35
extern void g_pattern_spec_free(GPatternSpec *pspec ) ;
#line 37
extern GPatternSpec *g_pattern_spec_copy(GPatternSpec *pspec ) ;
#line 39
extern gboolean g_pattern_spec_equal(GPatternSpec *pspec1 , GPatternSpec *pspec2 ) ;
#line 42
extern gboolean g_pattern_spec_match(GPatternSpec *pspec , gsize string_length , gchar *string ,
                                     gchar *string_reversed ) ;
#line 47
extern gboolean g_pattern_spec_match_string(GPatternSpec *pspec , gchar *string ) ;
#line 50
extern gboolean g_pattern_match(GPatternSpec *pspec , guint string_length , gchar *string ,
                                gchar *string_reversed ) ;
#line 55
extern gboolean g_pattern_match_string(GPatternSpec *pspec , gchar *string ) ;
#line 58
extern gboolean g_pattern_match_simple(gchar *pattern , gchar *string ) ;
#line 46 "/usr/include/glib-2.0/glib/gprimes.h"
extern guint g_spaced_primes_closest(guint num ) ;
#line 37 "/usr/include/glib-2.0/glib/gqsort.h"
extern void g_qsort_with_data(gconstpointer pbase , gint total_elems , gsize size ,
                              GCompareDataFunc compare_func , gpointer user_data ) ;
#line 73 "/usr/include/glib-2.0/glib/gqueue.h"
extern GQueue *g_queue_new(void) ;
#line 75
extern void g_queue_free(GQueue *queue ) ;
#line 77
extern void g_queue_free_full(GQueue *queue , GDestroyNotify free_func ) ;
#line 80
extern void g_queue_init(GQueue *queue ) ;
#line 82
extern void g_queue_clear(GQueue *queue ) ;
#line 84
extern gboolean g_queue_is_empty(GQueue *queue ) ;
#line 86
extern void g_queue_clear_full(GQueue *queue , GDestroyNotify free_func ) ;
#line 89
extern guint g_queue_get_length(GQueue *queue ) ;
#line 91
extern void g_queue_reverse(GQueue *queue ) ;
#line 93
extern GQueue *g_queue_copy(GQueue *queue ) ;
#line 95
extern void g_queue_foreach(GQueue *queue , GFunc func , gpointer user_data ) ;
#line 99
extern GList *g_queue_find(GQueue *queue , gconstpointer data ) ;
#line 102
extern GList *g_queue_find_custom(GQueue *queue , gconstpointer data , GCompareFunc func ) ;
#line 106
extern void g_queue_sort(GQueue *queue , GCompareDataFunc compare_func , gpointer user_data ) ;
#line 111
extern void g_queue_push_head(GQueue *queue , gpointer data ) ;
#line 114
extern void g_queue_push_tail(GQueue *queue , gpointer data ) ;
#line 117
extern void g_queue_push_nth(GQueue *queue , gpointer data , gint n ) ;
#line 121
extern gpointer g_queue_pop_head(GQueue *queue ) ;
#line 123
extern gpointer g_queue_pop_tail(GQueue *queue ) ;
#line 125
extern gpointer g_queue_pop_nth(GQueue *queue , guint n ) ;
#line 128
extern gpointer g_queue_peek_head(GQueue *queue ) ;
#line 130
extern gpointer g_queue_peek_tail(GQueue *queue ) ;
#line 132
extern gpointer g_queue_peek_nth(GQueue *queue , guint n ) ;
#line 135
extern gint g_queue_index(GQueue *queue , gconstpointer data ) ;
#line 138
extern gboolean g_queue_remove(GQueue *queue , gconstpointer data ) ;
#line 141
extern guint g_queue_remove_all(GQueue *queue , gconstpointer data ) ;
#line 144
extern void g_queue_insert_before(GQueue *queue , GList *sibling , gpointer data ) ;
#line 148
extern void g_queue_insert_before_link(GQueue *queue , GList *sibling , GList *link_ ) ;
#line 153
extern void g_queue_insert_after(GQueue *queue , GList *sibling , gpointer data ) ;
#line 157
extern void g_queue_insert_after_link(GQueue *queue , GList *sibling , GList *link_ ) ;
#line 162
extern void g_queue_insert_sorted(GQueue *queue , gpointer data , GCompareDataFunc func ,
                                  gpointer user_data ) ;
#line 168
extern void g_queue_push_head_link(GQueue *queue , GList *link_ ) ;
#line 171
extern void g_queue_push_tail_link(GQueue *queue , GList *link_ ) ;
#line 174
extern void g_queue_push_nth_link(GQueue *queue , gint n , GList *link_ ) ;
#line 178
extern GList *g_queue_pop_head_link(GQueue *queue ) ;
#line 180
extern GList *g_queue_pop_tail_link(GQueue *queue ) ;
#line 182
extern GList *g_queue_pop_nth_link(GQueue *queue , guint n ) ;
#line 185
extern GList *g_queue_peek_head_link(GQueue *queue ) ;
#line 187
extern GList *g_queue_peek_tail_link(GQueue *queue ) ;
#line 189
extern GList *g_queue_peek_nth_link(GQueue *queue , guint n ) ;
#line 192
extern gint g_queue_link_index(GQueue *queue , GList *link_ ) ;
#line 195
extern void g_queue_unlink(GQueue *queue , GList *link_ ) ;
#line 198
extern void g_queue_delete_link(GQueue *queue , GList *link_ ) ;
#line 48 "/usr/include/glib-2.0/glib/grand.h"
extern GRand *g_rand_new_with_seed(guint32 seed ) ;
#line 50
extern GRand *g_rand_new_with_seed_array(guint32 *seed , guint seed_length ) ;
#line 53
extern GRand *g_rand_new(void) ;
#line 55
extern void g_rand_free(GRand *rand_ ) ;
#line 57
extern GRand *g_rand_copy(GRand *rand_ ) ;
#line 59
extern void g_rand_set_seed(GRand *rand_ , guint32 seed ) ;
#line 62
extern void g_rand_set_seed_array(GRand *rand_ , guint32 *seed , guint seed_length ) ;
#line 69
extern guint32 g_rand_int(GRand *rand_ ) ;
#line 71
extern gint32 g_rand_int_range(GRand *rand_ , gint32 begin , gint32 end ) ;
#line 75
extern gdouble g_rand_double(GRand *rand_ ) ;
#line 77
extern gdouble g_rand_double_range(GRand *rand_ , gdouble begin , gdouble end ) ;
#line 81
extern void g_random_set_seed(guint32 seed ) ;
#line 86
extern guint32 g_random_int(void) ;
#line 88
extern gint32 g_random_int_range(gint32 begin , gint32 end ) ;
#line 91
extern gdouble g_random_double(void) ;
#line 93
extern gdouble g_random_double_range(gdouble begin , gdouble end ) ;
#line 31 "/usr/include/glib-2.0/glib/grcbox.h"
extern gpointer g_rc_box_alloc(gsize block_size ) ;
#line 33
extern gpointer g_rc_box_alloc0(gsize block_size ) ;
#line 35
extern gpointer g_rc_box_dup(gsize block_size , gconstpointer mem_block ) ;
#line 38
extern gpointer g_rc_box_acquire(gpointer mem_block ) ;
#line 40
extern void g_rc_box_release(gpointer mem_block ) ;
#line 42
extern void g_rc_box_release_full(gpointer mem_block , GDestroyNotify clear_func ) ;
#line 46
extern gsize g_rc_box_get_size(gpointer mem_block ) ;
#line 49
extern gpointer g_atomic_rc_box_alloc(gsize block_size ) ;
#line 51
extern gpointer g_atomic_rc_box_alloc0(gsize block_size ) ;
#line 53
extern gpointer g_atomic_rc_box_dup(gsize block_size , gconstpointer mem_block ) ;
#line 56
extern gpointer g_atomic_rc_box_acquire(gpointer mem_block ) ;
#line 58
extern void g_atomic_rc_box_release(gpointer mem_block ) ;
#line 60
extern void g_atomic_rc_box_release_full(gpointer mem_block , GDestroyNotify clear_func ) ;
#line 64
extern gsize g_atomic_rc_box_get_size(gpointer mem_block ) ;
#line 32 "/usr/include/glib-2.0/glib/grefcount.h"
extern void g_ref_count_init(grefcount *rc ) ;
#line 34
extern void g_ref_count_inc(grefcount *rc ) ;
#line 36
extern gboolean g_ref_count_dec(grefcount *rc ) ;
#line 38
extern gboolean g_ref_count_compare(grefcount *rc , gint val ) ;
#line 42
extern void g_atomic_ref_count_init(gatomicrefcount *arc ) ;
#line 44
extern void g_atomic_ref_count_inc(gatomicrefcount *arc ) ;
#line 46
extern gboolean g_atomic_ref_count_dec(gatomicrefcount *arc ) ;
#line 48
extern gboolean g_atomic_ref_count_compare(gatomicrefcount *arc , gint val ) ;
#line 27 "/usr/include/glib-2.0/glib/grefstring.h"
extern char *g_ref_string_new(char const   *str ) ;
#line 29
extern char *g_ref_string_new_len(char const   *str , gssize len ) ;
#line 32
extern char *g_ref_string_new_intern(char const   *str ) ;
#line 35
extern char *g_ref_string_acquire(char *str ) ;
#line 37
extern void g_ref_string_release(char *str ) ;
#line 40
extern gsize g_ref_string_length(char *str ) ;
#line 215 "/usr/include/glib-2.0/glib/gregex.h"
extern GQuark g_regex_error_quark(void) ;
#line 447
extern GRegex *g_regex_new(gchar *pattern , GRegexCompileFlags compile_options , GRegexMatchFlags match_options ,
                           GError **error ) ;
#line 452
extern GRegex *g_regex_ref(GRegex *regex ) ;
#line 454
extern void g_regex_unref(GRegex *regex ) ;
#line 456
extern gchar *g_regex_get_pattern(GRegex *regex ) ;
#line 458
extern gint g_regex_get_max_backref(GRegex *regex ) ;
#line 460
extern gint g_regex_get_capture_count(GRegex *regex ) ;
#line 462
extern gboolean g_regex_get_has_cr_or_lf(GRegex *regex ) ;
#line 464
extern gint g_regex_get_max_lookbehind(GRegex *regex ) ;
#line 466
extern gint g_regex_get_string_number(GRegex *regex , gchar *name ) ;
#line 469
extern gchar *g_regex_escape_string(gchar *string , gint length ) ;
#line 472
extern gchar *g_regex_escape_nul(gchar *string , gint length ) ;
#line 476
extern GRegexCompileFlags g_regex_get_compile_flags(GRegex *regex ) ;
#line 478
extern GRegexMatchFlags g_regex_get_match_flags(GRegex *regex ) ;
#line 482
extern gboolean g_regex_match_simple(gchar *pattern , gchar *string , GRegexCompileFlags compile_options ,
                                     GRegexMatchFlags match_options ) ;
#line 487
extern gboolean g_regex_match(GRegex *regex , gchar *string , GRegexMatchFlags match_options ,
                              GMatchInfo **match_info ) ;
#line 492
extern gboolean g_regex_match_full(GRegex *regex , gchar *string , gssize string_len ,
                                   gint start_position , GRegexMatchFlags match_options ,
                                   GMatchInfo **match_info , GError **error ) ;
#line 500
extern gboolean g_regex_match_all(GRegex *regex , gchar *string , GRegexMatchFlags match_options ,
                                  GMatchInfo **match_info ) ;
#line 505
extern gboolean g_regex_match_all_full(GRegex *regex , gchar *string , gssize string_len ,
                                       gint start_position , GRegexMatchFlags match_options ,
                                       GMatchInfo **match_info , GError **error ) ;
#line 515
extern gchar **g_regex_split_simple(gchar *pattern , gchar *string , GRegexCompileFlags compile_options ,
                                    GRegexMatchFlags match_options ) ;
#line 520
extern gchar **g_regex_split(GRegex *regex , gchar *string , GRegexMatchFlags match_options ) ;
#line 524
extern gchar **g_regex_split_full(GRegex *regex , gchar *string , gssize string_len ,
                                  gint start_position , GRegexMatchFlags match_options ,
                                  gint max_tokens , GError **error ) ;
#line 534
extern gchar *g_regex_replace(GRegex *regex , gchar *string , gssize string_len ,
                              gint start_position , gchar *replacement , GRegexMatchFlags match_options ,
                              GError **error ) ;
#line 542
extern gchar *g_regex_replace_literal(GRegex *regex , gchar *string , gssize string_len ,
                                      gint start_position , gchar *replacement , GRegexMatchFlags match_options ,
                                      GError **error ) ;
#line 550
extern gchar *g_regex_replace_eval(GRegex *regex , gchar *string , gssize string_len ,
                                   gint start_position , GRegexMatchFlags match_options ,
                                   GRegexEvalCallback eval , gpointer user_data ,
                                   GError **error ) ;
#line 559
extern gboolean g_regex_check_replacement(gchar *replacement , gboolean *has_references ,
                                          GError **error ) ;
#line 565
extern GRegex *g_match_info_get_regex(GMatchInfo *match_info ) ;
#line 567
extern gchar *g_match_info_get_string(GMatchInfo *match_info ) ;
#line 570
extern GMatchInfo *g_match_info_ref(GMatchInfo *match_info ) ;
#line 572
extern void g_match_info_unref(GMatchInfo *match_info ) ;
#line 574
extern void g_match_info_free(GMatchInfo *match_info ) ;
#line 576
extern gboolean g_match_info_next(GMatchInfo *match_info , GError **error ) ;
#line 579
extern gboolean g_match_info_matches(GMatchInfo *match_info ) ;
#line 581
extern gint g_match_info_get_match_count(GMatchInfo *match_info ) ;
#line 583
extern gboolean g_match_info_is_partial_match(GMatchInfo *match_info ) ;
#line 585
extern gchar *g_match_info_expand_references(GMatchInfo *match_info , gchar *string_to_expand ,
                                             GError **error ) ;
#line 589
extern gchar *g_match_info_fetch(GMatchInfo *match_info , gint match_num ) ;
#line 592
extern gboolean g_match_info_fetch_pos(GMatchInfo *match_info , gint match_num , gint *start_pos ,
                                       gint *end_pos ) ;
#line 597
extern gchar *g_match_info_fetch_named(GMatchInfo *match_info , gchar *name ) ;
#line 600
extern gboolean g_match_info_fetch_named_pos(GMatchInfo *match_info , gchar *name ,
                                             gint *start_pos , gint *end_pos ) ;
#line 605
extern gchar **g_match_info_fetch_all(GMatchInfo *match_info ) ;
#line 214 "/usr/include/glib-2.0/glib/gscanner.h"
extern GScanner *g_scanner_new(GScannerConfig *config_templ ) ;
#line 216
extern void g_scanner_destroy(GScanner *scanner ) ;
#line 218
extern void g_scanner_input_file(GScanner *scanner , gint input_fd ) ;
#line 221
extern void g_scanner_sync_file_offset(GScanner *scanner ) ;
#line 223
extern void g_scanner_input_text(GScanner *scanner , gchar *text , guint text_len ) ;
#line 227
extern GTokenType g_scanner_get_next_token(GScanner *scanner ) ;
#line 229
extern GTokenType g_scanner_peek_next_token(GScanner *scanner ) ;
#line 231
extern GTokenType g_scanner_cur_token(GScanner *scanner ) ;
#line 233
extern GTokenValue g_scanner_cur_value(GScanner *scanner ) ;
#line 235
extern guint g_scanner_cur_line(GScanner *scanner ) ;
#line 237
extern guint g_scanner_cur_position(GScanner *scanner ) ;
#line 239
extern gboolean g_scanner_eof(GScanner *scanner ) ;
#line 241
extern guint g_scanner_set_scope(GScanner *scanner , guint scope_id ) ;
#line 244
extern void g_scanner_scope_add_symbol(GScanner *scanner , guint scope_id , gchar *symbol ,
                                       gpointer value ) ;
#line 249
extern void g_scanner_scope_remove_symbol(GScanner *scanner , guint scope_id , gchar *symbol ) ;
#line 253
extern gpointer g_scanner_scope_lookup_symbol(GScanner *scanner , guint scope_id ,
                                              gchar *symbol ) ;
#line 257
extern void g_scanner_scope_foreach_symbol(GScanner *scanner , guint scope_id , GHFunc func ,
                                           gpointer user_data ) ;
#line 262
extern gpointer g_scanner_lookup_symbol(GScanner *scanner , gchar *symbol ) ;
#line 265
extern void g_scanner_unexp_token(GScanner *scanner , GTokenType expected_token ,
                                  gchar *identifier_spec , gchar *symbol_spec , gchar *symbol_name ,
                                  gchar *message , gint is_error ) ;
#line 273
extern void g_scanner_error(GScanner *scanner , gchar *format  , ...) ;
#line 277
extern void g_scanner_warn(GScanner *scanner , gchar *format  , ...) ;
#line 40 "/usr/include/glib-2.0/glib/gsequence.h"
extern GSequence *g_sequence_new(GDestroyNotify data_destroy ) ;
#line 42
extern void g_sequence_free(GSequence *seq ) ;
#line 44
extern gint g_sequence_get_length(GSequence *seq ) ;
#line 46
extern void g_sequence_foreach(GSequence *seq , GFunc func , gpointer user_data ) ;
#line 50
extern void g_sequence_foreach_range(GSequenceIter *begin , GSequenceIter *end , GFunc func ,
                                     gpointer user_data ) ;
#line 55
extern void g_sequence_sort(GSequence *seq , GCompareDataFunc cmp_func , gpointer cmp_data ) ;
#line 59
extern void g_sequence_sort_iter(GSequence *seq , GSequenceIterCompareFunc cmp_func ,
                                 gpointer cmp_data ) ;
#line 63
extern gboolean g_sequence_is_empty(GSequence *seq ) ;
#line 68
extern GSequenceIter *g_sequence_get_begin_iter(GSequence *seq ) ;
#line 70
extern GSequenceIter *g_sequence_get_end_iter(GSequence *seq ) ;
#line 72
extern GSequenceIter *g_sequence_get_iter_at_pos(GSequence *seq , gint pos ) ;
#line 75
extern GSequenceIter *g_sequence_append(GSequence *seq , gpointer data ) ;
#line 78
extern GSequenceIter *g_sequence_prepend(GSequence *seq , gpointer data ) ;
#line 81
extern GSequenceIter *g_sequence_insert_before(GSequenceIter *iter , gpointer data ) ;
#line 84
extern void g_sequence_move(GSequenceIter *src , GSequenceIter *dest ) ;
#line 87
extern void g_sequence_swap(GSequenceIter *a , GSequenceIter *b ) ;
#line 90
extern GSequenceIter *g_sequence_insert_sorted(GSequence *seq , gpointer data , GCompareDataFunc cmp_func ,
                                               gpointer cmp_data ) ;
#line 95
extern GSequenceIter *g_sequence_insert_sorted_iter(GSequence *seq , gpointer data ,
                                                    GSequenceIterCompareFunc iter_cmp ,
                                                    gpointer cmp_data ) ;
#line 100
extern void g_sequence_sort_changed(GSequenceIter *iter , GCompareDataFunc cmp_func ,
                                    gpointer cmp_data ) ;
#line 104
extern void g_sequence_sort_changed_iter(GSequenceIter *iter , GSequenceIterCompareFunc iter_cmp ,
                                         gpointer cmp_data ) ;
#line 108
extern void g_sequence_remove(GSequenceIter *iter ) ;
#line 110
extern void g_sequence_remove_range(GSequenceIter *begin , GSequenceIter *end ) ;
#line 113
extern void g_sequence_move_range(GSequenceIter *dest , GSequenceIter *begin , GSequenceIter *end ) ;
#line 117
extern GSequenceIter *g_sequence_search(GSequence *seq , gpointer data , GCompareDataFunc cmp_func ,
                                        gpointer cmp_data ) ;
#line 122
extern GSequenceIter *g_sequence_search_iter(GSequence *seq , gpointer data , GSequenceIterCompareFunc iter_cmp ,
                                             gpointer cmp_data ) ;
#line 127
extern GSequenceIter *g_sequence_lookup(GSequence *seq , gpointer data , GCompareDataFunc cmp_func ,
                                        gpointer cmp_data ) ;
#line 132
extern GSequenceIter *g_sequence_lookup_iter(GSequence *seq , gpointer data , GSequenceIterCompareFunc iter_cmp ,
                                             gpointer cmp_data ) ;
#line 140
extern gpointer g_sequence_get(GSequenceIter *iter ) ;
#line 142
extern void g_sequence_set(GSequenceIter *iter , gpointer data ) ;
#line 147
extern gboolean g_sequence_iter_is_begin(GSequenceIter *iter ) ;
#line 149
extern gboolean g_sequence_iter_is_end(GSequenceIter *iter ) ;
#line 151
extern GSequenceIter *g_sequence_iter_next(GSequenceIter *iter ) ;
#line 153
extern GSequenceIter *g_sequence_iter_prev(GSequenceIter *iter ) ;
#line 155
extern gint g_sequence_iter_get_position(GSequenceIter *iter ) ;
#line 157
extern GSequenceIter *g_sequence_iter_move(GSequenceIter *iter , gint delta ) ;
#line 160
extern GSequence *g_sequence_iter_get_sequence(GSequenceIter *iter ) ;
#line 165
extern gint g_sequence_iter_compare(GSequenceIter *a , GSequenceIter *b ) ;
#line 168
extern GSequenceIter *g_sequence_range_get_midpoint(GSequenceIter *begin , GSequenceIter *end ) ;
#line 42 "/usr/include/glib-2.0/glib/gshell.h"
extern GQuark g_shell_error_quark(void) ;
#line 45
extern gchar *g_shell_quote(gchar *unquoted_string ) ;
#line 47
extern gchar *g_shell_unquote(gchar *quoted_string , GError **error ) ;
#line 50
extern gboolean g_shell_parse_argv(gchar *command_line , gint *argcp , gchar ***argvp ,
                                   GError **error ) ;
#line 33 "/usr/include/glib-2.0/glib/gslice.h"
extern gpointer g_slice_alloc(gsize block_size ) ;
#line 35
extern gpointer g_slice_alloc0(gsize block_size ) ;
#line 37
extern gpointer g_slice_copy(gsize block_size , gconstpointer mem_block ) ;
#line 40
extern void g_slice_free1(gsize block_size , gpointer mem_block ) ;
#line 43
extern void g_slice_free_chain_with_offset(gsize block_size , gpointer mem_chain ,
                                           gsize next_offset ) ;
#line 102
extern void g_slice_set_config(GSliceConfig ckey , gint64 value ) ;
#line 104
extern gint64 g_slice_get_config(GSliceConfig ckey ) ;
#line 106
extern gint64 *g_slice_get_config_state(GSliceConfig ckey , gint64 address , guint *n_values ) ;
#line 185 "/usr/include/glib-2.0/glib/gspawn.h"
extern GQuark g_spawn_error_quark(void) ;
#line 187
extern GQuark g_spawn_exit_error_quark(void) ;
#line 190
extern gboolean g_spawn_async(gchar *working_directory , gchar **argv , gchar **envp ,
                              GSpawnFlags flags , GSpawnChildSetupFunc child_setup ,
                              gpointer user_data , GPid *child_pid , GError **error ) ;
#line 204
extern gboolean g_spawn_async_with_pipes(gchar *working_directory , gchar **argv ,
                                         gchar **envp , GSpawnFlags flags , GSpawnChildSetupFunc child_setup ,
                                         gpointer user_data , GPid *child_pid , gint *standard_input ,
                                         gint *standard_output , gint *standard_error ,
                                         GError **error ) ;
#line 217
extern gboolean g_spawn_async_with_pipes_and_fds(gchar *working_directory , gchar * const  *argv ,
                                                 gchar * const  *envp , GSpawnFlags flags ,
                                                 GSpawnChildSetupFunc child_setup ,
                                                 gpointer user_data , gint stdin_fd ,
                                                 gint stdout_fd , gint stderr_fd ,
                                                 gint *source_fds , gint *target_fds ,
                                                 gsize n_fds , GPid *child_pid_out ,
                                                 gint *stdin_pipe_out , gint *stdout_pipe_out ,
                                                 gint *stderr_pipe_out , GError **error ) ;
#line 237
extern gboolean g_spawn_async_with_fds(gchar *working_directory , gchar **argv , gchar **envp ,
                                       GSpawnFlags flags , GSpawnChildSetupFunc child_setup ,
                                       gpointer user_data , GPid *child_pid , gint stdin_fd ,
                                       gint stdout_fd , gint stderr_fd , GError **error ) ;
#line 254
extern gboolean g_spawn_sync(gchar *working_directory , gchar **argv , gchar **envp ,
                             GSpawnFlags flags , GSpawnChildSetupFunc child_setup ,
                             gpointer user_data , gchar **standard_output , gchar **standard_error ,
                             gint *wait_status , GError **error ) ;
#line 266
extern gboolean g_spawn_command_line_sync(gchar *command_line , gchar **standard_output ,
                                          gchar **standard_error , gint *wait_status ,
                                          GError **error ) ;
#line 272
extern gboolean g_spawn_command_line_async(gchar *command_line , GError **error ) ;
#line 276
extern gboolean g_spawn_check_wait_status(gint wait_status , GError **error ) ;
#line 280
extern gboolean g_spawn_check_exit_status(gint wait_status , GError **error ) ;
#line 284
extern void g_spawn_close_pid(GPid pid ) ;
#line 54 "/usr/include/glib-2.0/glib/gstrfuncs.h"
extern guint16 * const  g_ascii_table ;
#line 90
extern gchar g_ascii_tolower(gchar c ) ;
#line 92
extern gchar g_ascii_toupper(gchar c ) ;
#line 95
extern gint g_ascii_digit_value(gchar c ) ;
#line 97
extern gint g_ascii_xdigit_value(gchar c ) ;
#line 104
extern gchar *g_strdelimit(gchar *string , gchar *delimiters , gchar new_delimiter ) ;
#line 108
extern gchar *g_strcanon(gchar *string , gchar *valid_chars , gchar substitutor ) ;
#line 112
extern gchar *g_strerror(gint errnum ) ;
#line 114
extern gchar *g_strsignal(gint signum ) ;
#line 116
extern gchar *g_strreverse(gchar *string ) ;
#line 118
extern gsize g_strlcpy(gchar *dest , gchar *src , gsize dest_size ) ;
#line 122
extern gsize g_strlcat(gchar *dest , gchar *src , gsize dest_size ) ;
#line 126
extern gchar *g_strstr_len(gchar *haystack , gssize haystack_len , gchar *needle ) ;
#line 130
extern gchar *g_strrstr(gchar *haystack , gchar *needle ) ;
#line 133
extern gchar *g_strrstr_len(gchar *haystack , gssize haystack_len , gchar *needle ) ;
#line 138
extern gboolean g_str_has_suffix(gchar *str , gchar *suffix ) ;
#line 141
extern gboolean g_str_has_prefix(gchar *str , gchar *prefix ) ;
#line 147
extern gdouble g_strtod(gchar *nptr , gchar **endptr ) ;
#line 150
extern gdouble g_ascii_strtod(gchar *nptr , gchar **endptr ) ;
#line 153
extern guint64 g_ascii_strtoull(gchar *nptr , gchar **endptr , guint base ) ;
#line 157
extern gint64 g_ascii_strtoll(gchar *nptr , gchar **endptr , guint base ) ;
#line 165
extern gchar *g_ascii_dtostr(gchar *buffer , gint buf_len , gdouble d ) ;
#line 169
extern gchar *g_ascii_formatd(gchar *buffer , gint buf_len , gchar *format , gdouble d ) ;
#line 176
extern gchar *g_strchug(gchar *string ) ;
#line 179
extern gchar *g_strchomp(gchar *string ) ;
#line 184
extern gint g_ascii_strcasecmp(gchar *s1 , gchar *s2 ) ;
#line 187
extern gint g_ascii_strncasecmp(gchar *s1 , gchar *s2 , gsize n ) ;
#line 191
extern gchar *g_ascii_strdown(gchar *str , gssize len ) ;
#line 194
extern gchar *g_ascii_strup(gchar *str , gssize len ) ;
#line 198
extern gboolean g_str_is_ascii(gchar *str ) ;
#line 201
extern gint g_strcasecmp(gchar *s1 , gchar *s2 ) ;
#line 204
extern gint g_strncasecmp(gchar *s1 , gchar *s2 , guint n ) ;
#line 208
extern gchar *g_strdown(gchar *string ) ;
#line 210
extern gchar *g_strup(gchar *string ) ;
#line 217
extern gchar *g_strdup(gchar *str ) ;
#line 219
extern gchar *g_strdup_printf(gchar *format  , ...) ;
#line 222
extern gchar *g_strdup_vprintf(gchar *format , va_list args ) ;
#line 225
extern gchar *g_strndup(gchar *str , gsize n ) ;
#line 228
extern gchar *g_strnfill(gsize length , gchar fill_char ) ;
#line 231
extern gchar *g_strconcat(gchar *string1  , ...) ;
#line 234
extern gchar *g_strjoin(gchar *separator  , ...) ;
#line 242
extern gchar *g_strcompress(gchar *source ) ;
#line 253
extern gchar *g_strescape(gchar *source , gchar *exceptions ) ;
#line 257
extern gpointer g_memdup(gconstpointer mem , guint byte_size ) ;
#line 261
extern gpointer g_memdup2(gconstpointer mem , gsize byte_size ) ;
#line 275
extern gchar **g_strsplit(gchar *string , gchar *delimiter , gint max_tokens ) ;
#line 279
extern gchar **g_strsplit_set(gchar *string , gchar *delimiters , gint max_tokens ) ;
#line 283
extern gchar *g_strjoinv(gchar *separator , gchar **str_array ) ;
#line 286
extern void g_strfreev(gchar **str_array ) ;
#line 288
extern gchar **g_strdupv(gchar **str_array ) ;
#line 290
extern guint g_strv_length(gchar **str_array ) ;
#line 293
extern gchar *g_stpcpy(gchar *dest , char const   *src ) ;
#line 297
extern gchar *g_str_to_ascii(gchar *str , gchar *from_locale ) ;
#line 301
extern gchar **g_str_tokenize_and_fold(gchar *string , gchar *translit_locale , gchar ***ascii_alternates ) ;
#line 306
extern gboolean g_str_match_string(gchar *search_term , gchar *potential_hit , gboolean accept_alternates ) ;
#line 311
extern gboolean g_strv_contains(gchar * const  *strv , gchar *str ) ;
#line 315
extern gboolean g_strv_equal(gchar * const  *strv1 , gchar * const  *strv2 ) ;
#line 346
extern GQuark g_number_parser_error_quark(void) ;
#line 349
extern gboolean g_ascii_string_to_signed(gchar *str , guint base , gint64 min , gint64 max ,
                                         gint64 *out_num , GError **error ) ;
#line 357
extern gboolean g_ascii_string_to_unsigned(gchar *str , guint base , guint64 min ,
                                           guint64 max , guint64 *out_num , GError **error ) ;
#line 39 "/usr/include/glib-2.0/glib/gstringchunk.h"
extern GStringChunk *g_string_chunk_new(gsize size ) ;
#line 41
extern void g_string_chunk_free(GStringChunk *chunk ) ;
#line 43
extern void g_string_chunk_clear(GStringChunk *chunk ) ;
#line 45
extern gchar *g_string_chunk_insert(GStringChunk *chunk , gchar *string ) ;
#line 48
extern gchar *g_string_chunk_insert_len(GStringChunk *chunk , gchar *string , gssize len ) ;
#line 52
extern gchar *g_string_chunk_insert_const(GStringChunk *chunk , gchar *string ) ;
#line 42 "/usr/include/glib-2.0/glib/gstrvbuilder.h"
extern GStrvBuilder *g_strv_builder_new(void) ;
#line 45
extern void g_strv_builder_unref(GStrvBuilder *builder ) ;
#line 48
extern GStrvBuilder *g_strv_builder_ref(GStrvBuilder *builder ) ;
#line 51
extern void g_strv_builder_add(GStrvBuilder *builder , char const   *value ) ;
#line 55
extern void g_strv_builder_addv(GStrvBuilder *builder , char const   **value ) ;
#line 59
extern void g_strv_builder_add_many(GStrvBuilder *builder  , ...) ;
#line 63
extern GStrv g_strv_builder_end(GStrvBuilder *builder ) ;
#line 37 "/usr/include/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void) ;
#line 239 "/usr/include/glib-2.0/glib/gtestutils.h"
extern int g_strcmp0(char const   *str1 , char const   *str2 ) ;
#line 244
extern void g_test_minimized_result(double minimized_quantity , char const   *format 
                                    , ...) ;
#line 248
extern void g_test_maximized_result(double maximized_quantity , char const   *format 
                                    , ...) ;
#line 254
extern void g_test_init(int *argc , char ***argv  , ...) ;
#line 321
extern gboolean g_test_subprocess(void) ;
#line 325
extern int g_test_run(void) ;
#line 328
extern void g_test_add_func(char const   *testpath , GTestFunc test_func ) ;
#line 332
extern void g_test_add_data_func(char const   *testpath , gconstpointer test_data ,
                                 GTestDataFunc test_func ) ;
#line 337
extern void g_test_add_data_func_full(char const   *testpath , gpointer test_data ,
                                      GTestDataFunc test_func , GDestroyNotify data_free_func ) ;
#line 344
extern char const   *g_test_get_path(void) ;
#line 348
extern void g_test_fail(void) ;
#line 350
extern void g_test_fail_printf(char const   *format  , ...) ;
#line 353
extern void g_test_incomplete(gchar *msg ) ;
#line 355
extern void g_test_incomplete_printf(char const   *format  , ...) ;
#line 358
extern void g_test_skip(gchar *msg ) ;
#line 360
extern void g_test_skip_printf(char const   *format  , ...) ;
#line 363
extern gboolean g_test_failed(void) ;
#line 365
extern void g_test_set_nonfatal_assertions(void) ;
#line 400
extern void g_test_message(char const   *format  , ...) ;
#line 403
extern void g_test_bug_base(char const   *uri_pattern ) ;
#line 405
extern void g_test_bug(char const   *bug_uri_snippet ) ;
#line 407
extern void g_test_summary(char const   *summary ) ;
#line 410
extern void g_test_timer_start(void) ;
#line 412
extern double g_test_timer_elapsed(void) ;
#line 414
extern double g_test_timer_last(void) ;
#line 418
extern void g_test_queue_free(gpointer gfree_pointer ) ;
#line 420
extern void g_test_queue_destroy(GDestroyNotify destroy_func , gpointer destroy_data ) ;
#line 454
extern gboolean g_test_trap_fork(guint64 usec_timeout , GTestTrapFlags test_trap_flags ) ;
#line 466
extern void g_test_trap_subprocess(char const   *test_path , guint64 usec_timeout ,
                                   GTestSubprocessFlags test_flags ) ;
#line 471
extern gboolean g_test_trap_has_passed(void) ;
#line 473
extern gboolean g_test_trap_reached_timeout(void) ;
#line 484
extern gint32 g_test_rand_int(void) ;
#line 486
extern gint32 g_test_rand_int_range(gint32 begin , gint32 end ) ;
#line 489
extern double g_test_rand_double(void) ;
#line 491
extern double g_test_rand_double_range(double range_start , double range_end ) ;
#line 500
extern GTestCase *g_test_create_case(char const   *test_name , gsize data_size , gconstpointer test_data ,
                                     GTestFixtureFunc data_setup , GTestFixtureFunc data_test ,
                                     GTestFixtureFunc data_teardown ) ;
#line 507
extern GTestSuite *g_test_create_suite(char const   *suite_name ) ;
#line 509
extern GTestSuite *g_test_get_root(void) ;
#line 511
extern void g_test_suite_add(GTestSuite *suite , GTestCase *test_case ) ;
#line 514
extern void g_test_suite_add_suite(GTestSuite *suite , GTestSuite *nestedsuite ) ;
#line 517
extern int g_test_run_suite(GTestSuite *suite ) ;
#line 520
extern void g_test_case_free(GTestCase *test_case ) ;
#line 523
extern void g_test_suite_free(GTestSuite *suite ) ;
#line 526
extern void g_test_trap_assertions(char const   *domain , char const   *file , int line ,
                                   char const   *func , guint64 assertion_flags ,
                                   char const   *pattern ) ;
#line 533
extern void g_assertion_message(char const   *domain , char const   *file , int line ,
                                char const   *func , char const   *message ) ;
#line 540
extern void g_assertion_message_expr(char const   *domain , char const   *file , int line ,
                                     char const   *func , char const   *expr ) ;
#line 546
extern void g_assertion_message_cmpstr(char const   *domain , char const   *file ,
                                       int line , char const   *func , char const   *expr ,
                                       char const   *arg1 , char const   *cmp , char const   *arg2 ) ;
#line 556
extern void g_assertion_message_cmpstrv(char const   *domain , char const   *file ,
                                        int line , char const   *func , char const   *expr ,
                                        char const   * const  *arg1 , char const   * const  *arg2 ,
                                        gsize first_wrong_idx ) ;
#line 565
extern void g_assertion_message_cmpnum(char const   *domain , char const   *file ,
                                       int line , char const   *func , char const   *expr ,
                                       long double arg1 , char const   *cmp , long double arg2 ,
                                       char numtype ) ;
#line 575
extern void g_assertion_message_error(char const   *domain , char const   *file ,
                                      int line , char const   *func , char const   *expr ,
                                      GError *error , GQuark error_domain , int error_code ) ;
#line 584
extern void g_test_add_vtable(char const   *testpath , gsize data_size , gconstpointer test_data ,
                              GTestFixtureFunc data_setup , GTestFixtureFunc data_test ,
                              GTestFixtureFunc data_teardown ) ;
#line 598
extern GTestConfig * const  g_test_config_vars ;
#line 637
extern char const   *g_test_log_type_name(GTestLogType log_type ) ;
#line 639
extern GTestLogBuffer *g_test_log_buffer_new(void) ;
#line 641
extern void g_test_log_buffer_free(GTestLogBuffer *tbuffer ) ;
#line 643
extern void g_test_log_buffer_push(GTestLogBuffer *tbuffer , guint n_bytes , guint8 *bytes ) ;
#line 647
extern GTestLogMsg *g_test_log_buffer_pop(GTestLogBuffer *tbuffer ) ;
#line 649
extern void g_test_log_msg_free(GTestLogMsg *tmsg ) ;
#line 670
extern void g_test_log_set_fatal_handler(GTestLogFatalFunc log_func , gpointer user_data ) ;
#line 674
extern void g_test_expect_message(gchar *log_domain , GLogLevelFlags log_level , gchar *pattern ) ;
#line 678
extern void g_test_assert_expected_messages_internal(char const   *domain , char const   *file ,
                                                     int line , char const   *func ) ;
#line 690
extern gchar *g_test_build_filename(GTestFileType file_type , gchar *first_path  , ...) ;
#line 694
extern gchar *g_test_get_dir(GTestFileType file_type ) ;
#line 696
extern gchar *g_test_get_filename(GTestFileType file_type , gchar *first_path  , ...) ;
#line 49 "/usr/include/glib-2.0/glib/gthreadpool.h"
extern GThreadPool *g_thread_pool_new(GFunc func , gpointer user_data , gint max_threads ,
                                      gboolean exclusive , GError **error ) ;
#line 55
extern GThreadPool *g_thread_pool_new_full(GFunc func , gpointer user_data , GDestroyNotify item_free_func ,
                                           gint max_threads , gboolean exclusive ,
                                           GError **error ) ;
#line 62
extern void g_thread_pool_free(GThreadPool *pool , gboolean immediate , gboolean wait_ ) ;
#line 66
extern gboolean g_thread_pool_push(GThreadPool *pool , gpointer data , GError **error ) ;
#line 70
extern guint g_thread_pool_unprocessed(GThreadPool *pool ) ;
#line 72
extern void g_thread_pool_set_sort_function(GThreadPool *pool , GCompareDataFunc func ,
                                            gpointer user_data ) ;
#line 76
extern gboolean g_thread_pool_move_to_front(GThreadPool *pool , gpointer data ) ;
#line 80
extern gboolean g_thread_pool_set_max_threads(GThreadPool *pool , gint max_threads ,
                                              GError **error ) ;
#line 84
extern gint g_thread_pool_get_max_threads(GThreadPool *pool ) ;
#line 86
extern guint g_thread_pool_get_num_threads(GThreadPool *pool ) ;
#line 89
extern void g_thread_pool_set_max_unused_threads(gint max_threads ) ;
#line 91
extern gint g_thread_pool_get_max_unused_threads(void) ;
#line 93
extern guint g_thread_pool_get_num_unused_threads(void) ;
#line 95
extern void g_thread_pool_stop_unused_threads(void) ;
#line 97
extern void g_thread_pool_set_max_idle_time(guint interval ) ;
#line 99
extern guint g_thread_pool_get_max_idle_time(void) ;
#line 45 "/usr/include/glib-2.0/glib/gtimer.h"
extern GTimer *g_timer_new(void) ;
#line 47
extern void g_timer_destroy(GTimer *timer ) ;
#line 49
extern void g_timer_start(GTimer *timer ) ;
#line 51
extern void g_timer_stop(GTimer *timer ) ;
#line 53
extern void g_timer_reset(GTimer *timer ) ;
#line 55
extern void g_timer_continue(GTimer *timer ) ;
#line 57
extern gdouble g_timer_elapsed(GTimer *timer , gulong *microseconds ) ;
#line 60
extern gboolean g_timer_is_active(GTimer *timer ) ;
#line 63
extern void g_usleep(gulong microseconds ) ;
#line 67
extern void g_time_val_add(GTimeVal *time_ , glong microseconds ) ;
#line 70
extern gboolean g_time_val_from_iso8601(gchar *iso_date , GTimeVal *time_ ) ;
#line 73
extern gchar *g_time_val_to_iso8601(GTimeVal *time_ ) ;
#line 45 "/usr/include/glib-2.0/glib/gtrashstack.h"
extern void g_trash_stack_push(GTrashStack **stack_p , gpointer data_p ) ;
#line 48
extern gpointer g_trash_stack_pop(GTrashStack **stack_p ) ;
#line 50
extern gpointer g_trash_stack_peek(GTrashStack **stack_p ) ;
#line 52
extern guint g_trash_stack_height(GTrashStack **stack_p ) ;
#line 72 "/usr/include/glib-2.0/glib/gtree.h"
extern GTree *g_tree_new(GCompareFunc key_compare_func ) ;
#line 74
extern GTree *g_tree_new_with_data(GCompareDataFunc key_compare_func , gpointer key_compare_data ) ;
#line 77
extern GTree *g_tree_new_full(GCompareDataFunc key_compare_func , gpointer key_compare_data ,
                              GDestroyNotify key_destroy_func , GDestroyNotify value_destroy_func ) ;
#line 82
extern GTreeNode *g_tree_node_first(GTree *tree ) ;
#line 84
extern GTreeNode *g_tree_node_last(GTree *tree ) ;
#line 86
extern GTreeNode *g_tree_node_previous(GTreeNode *node ) ;
#line 88
extern GTreeNode *g_tree_node_next(GTreeNode *node ) ;
#line 90
extern GTree *g_tree_ref(GTree *tree ) ;
#line 92
extern void g_tree_unref(GTree *tree ) ;
#line 94
extern void g_tree_destroy(GTree *tree ) ;
#line 96
extern GTreeNode *g_tree_insert_node(GTree *tree , gpointer key , gpointer value ) ;
#line 100
extern void g_tree_insert(GTree *tree , gpointer key , gpointer value ) ;
#line 104
extern GTreeNode *g_tree_replace_node(GTree *tree , gpointer key , gpointer value ) ;
#line 108
extern void g_tree_replace(GTree *tree , gpointer key , gpointer value ) ;
#line 112
extern gboolean g_tree_remove(GTree *tree , gconstpointer key ) ;
#line 116
extern void g_tree_remove_all(GTree *tree ) ;
#line 119
extern gboolean g_tree_steal(GTree *tree , gconstpointer key ) ;
#line 122
extern gpointer g_tree_node_key(GTreeNode *node ) ;
#line 124
extern gpointer g_tree_node_value(GTreeNode *node ) ;
#line 126
extern GTreeNode *g_tree_lookup_node(GTree *tree , gconstpointer key ) ;
#line 129
extern gpointer g_tree_lookup(GTree *tree , gconstpointer key ) ;
#line 132
extern gboolean g_tree_lookup_extended(GTree *tree , gconstpointer lookup_key , gpointer *orig_key ,
                                       gpointer *value ) ;
#line 137
extern void g_tree_foreach(GTree *tree , GTraverseFunc func , gpointer user_data ) ;
#line 141
extern void g_tree_foreach_node(GTree *tree , GTraverseNodeFunc func , gpointer user_data ) ;
#line 146
extern void g_tree_traverse(GTree *tree , GTraverseFunc traverse_func , GTraverseType traverse_type ,
                            gpointer user_data ) ;
#line 152
extern GTreeNode *g_tree_search_node(GTree *tree , GCompareFunc search_func , gconstpointer user_data ) ;
#line 156
extern gpointer g_tree_search(GTree *tree , GCompareFunc search_func , gconstpointer user_data ) ;
#line 160
extern GTreeNode *g_tree_lower_bound(GTree *tree , gconstpointer key ) ;
#line 163
extern GTreeNode *g_tree_upper_bound(GTree *tree , gconstpointer key ) ;
#line 166
extern gint g_tree_height(GTree *tree ) ;
#line 168
extern gint g_tree_nnodes(GTree *tree ) ;
#line 34 "/usr/include/glib-2.0/glib/guri.h"
extern GUri *g_uri_ref(GUri *uri ) ;
#line 36
extern void g_uri_unref(GUri *uri ) ;
#line 94
extern gboolean g_uri_split(gchar *uri_ref , GUriFlags flags , gchar **scheme , gchar **userinfo ,
                            gchar **host , gint *port , gchar **path , gchar **query ,
                            gchar **fragment , GError **error ) ;
#line 105
extern gboolean g_uri_split_with_user(gchar *uri_ref , GUriFlags flags , gchar **scheme ,
                                      gchar **user , gchar **password , gchar **auth_params ,
                                      gchar **host , gint *port , gchar **path , gchar **query ,
                                      gchar **fragment , GError **error ) ;
#line 118
extern gboolean g_uri_split_network(gchar *uri_string , GUriFlags flags , gchar **scheme ,
                                    gchar **host , gint *port , GError **error ) ;
#line 126
extern gboolean g_uri_is_valid(gchar *uri_string , GUriFlags flags , GError **error ) ;
#line 131
extern gchar *g_uri_join(GUriFlags flags , gchar *scheme , gchar *userinfo , gchar *host ,
                         gint port , gchar *path , gchar *query , gchar *fragment ) ;
#line 140
extern gchar *g_uri_join_with_user(GUriFlags flags , gchar *scheme , gchar *user ,
                                   gchar *password , gchar *auth_params , gchar *host ,
                                   gint port , gchar *path , gchar *query , gchar *fragment ) ;
#line 152
extern GUri *g_uri_parse(gchar *uri_string , GUriFlags flags , GError **error ) ;
#line 156
extern GUri *g_uri_parse_relative(GUri *base_uri , gchar *uri_ref , GUriFlags flags ,
                                  GError **error ) ;
#line 162
extern gchar *g_uri_resolve_relative(gchar *base_uri_string , gchar *uri_ref , GUriFlags flags ,
                                     GError **error ) ;
#line 168
extern GUri *g_uri_build(GUriFlags flags , gchar *scheme , gchar *userinfo , gchar *host ,
                         gint port , gchar *path , gchar *query , gchar *fragment ) ;
#line 177
extern GUri *g_uri_build_with_user(GUriFlags flags , gchar *scheme , gchar *user ,
                                   gchar *password , gchar *auth_params , gchar *host ,
                                   gint port , gchar *path , gchar *query , gchar *fragment ) ;
#line 215
extern char *g_uri_to_string(GUri *uri ) ;
#line 217
extern char *g_uri_to_string_partial(GUri *uri , GUriHideFlags flags ) ;
#line 221
extern gchar *g_uri_get_scheme(GUri *uri ) ;
#line 223
extern gchar *g_uri_get_userinfo(GUri *uri ) ;
#line 225
extern gchar *g_uri_get_user(GUri *uri ) ;
#line 227
extern gchar *g_uri_get_password(GUri *uri ) ;
#line 229
extern gchar *g_uri_get_auth_params(GUri *uri ) ;
#line 231
extern gchar *g_uri_get_host(GUri *uri ) ;
#line 233
extern gint g_uri_get_port(GUri *uri ) ;
#line 235
extern gchar *g_uri_get_path(GUri *uri ) ;
#line 237
extern gchar *g_uri_get_query(GUri *uri ) ;
#line 239
extern gchar *g_uri_get_fragment(GUri *uri ) ;
#line 241
extern GUriFlags g_uri_get_flags(GUri *uri ) ;
#line 265
extern GHashTable *g_uri_parse_params(gchar *params , gssize length , gchar *separators ,
                                      GUriParamsFlags flags , GError **error ) ;
#line 283
extern void g_uri_params_iter_init(GUriParamsIter *iter , gchar *params , gssize length ,
                                   gchar *separators , GUriParamsFlags flags ) ;
#line 290
extern gboolean g_uri_params_iter_next(GUriParamsIter *iter , gchar **attribute ,
                                       gchar **value , GError **error ) ;
#line 306
extern GQuark g_uri_error_quark(void) ;
#line 388
extern char *g_uri_unescape_string(char const   *escaped_string , char const   *illegal_characters ) ;
#line 391
extern char *g_uri_unescape_segment(char const   *escaped_string , char const   *escaped_string_end ,
                                    char const   *illegal_characters ) ;
#line 396
extern char *g_uri_parse_scheme(char const   *uri ) ;
#line 398
extern char const   *g_uri_peek_scheme(char const   *uri ) ;
#line 401
extern char *g_uri_escape_string(char const   *unescaped , char const   *reserved_chars_allowed ,
                                 gboolean allow_utf8 ) ;
#line 406
extern GBytes *g_uri_unescape_bytes(char const   *escaped_string , gssize length ,
                                    char const   *illegal_characters , GError **error ) ;
#line 412
extern char *g_uri_escape_bytes(guint8 *unescaped , gsize length , char const   *reserved_chars_allowed ) ;
#line 35 "/usr/include/glib-2.0/glib/guuid.h"
extern gboolean g_uuid_string_is_valid(gchar *str ) ;
#line 38
extern gchar *g_uuid_string_random(void) ;
#line 36 "/usr/include/glib-2.0/glib/gversion.h"
extern guint glib_major_version ;
#line 37
extern guint glib_minor_version ;
#line 38
extern guint glib_micro_version ;
#line 39
extern guint glib_interface_age ;
#line 40
extern guint glib_binary_age ;
#line 43
extern gchar *glib_check_version(guint required_major , guint required_minor , guint required_micro ) ;
#line 43 "/usr/include/glib-2.0/glib/deprecated/gallocator.h"
extern GMemChunk *g_mem_chunk_new(gchar *name , gint atom_size , gsize area_size ,
                                  gint type ) ;
#line 48
extern void g_mem_chunk_destroy(GMemChunk *mem_chunk ) ;
#line 50
extern gpointer g_mem_chunk_alloc(GMemChunk *mem_chunk ) ;
#line 52
extern gpointer g_mem_chunk_alloc0(GMemChunk *mem_chunk ) ;
#line 54
extern void g_mem_chunk_free(GMemChunk *mem_chunk , gpointer mem ) ;
#line 57
extern void g_mem_chunk_clean(GMemChunk *mem_chunk ) ;
#line 59
extern void g_mem_chunk_reset(GMemChunk *mem_chunk ) ;
#line 61
extern void g_mem_chunk_print(GMemChunk *mem_chunk ) ;
#line 63
extern void g_mem_chunk_info(void) ;
#line 65
extern void g_blow_chunks(void) ;
#line 69
extern GAllocator *g_allocator_new(gchar *name , guint n_preallocs ) ;
#line 72
extern void g_allocator_free(GAllocator *allocator ) ;
#line 74
extern void g_list_push_allocator(GAllocator *allocator ) ;
#line 76
extern void g_list_pop_allocator(void) ;
#line 78
extern void g_slist_push_allocator(GAllocator *allocator ) ;
#line 80
extern void g_slist_pop_allocator(void) ;
#line 82
extern void g_node_push_allocator(GAllocator *allocator ) ;
#line 84
extern void g_node_pop_allocator(void) ;
#line 47 "/usr/include/glib-2.0/glib/deprecated/gcache.h"
extern GCache *g_cache_new(GCacheNewFunc value_new_func , GCacheDestroyFunc value_destroy_func ,
                           GCacheDupFunc key_dup_func , GCacheDestroyFunc key_destroy_func ,
                           GHashFunc hash_key_func , GHashFunc hash_value_func , GEqualFunc key_equal_func ) ;
#line 55
extern void g_cache_destroy(GCache *cache ) ;
#line 57
extern gpointer g_cache_insert(GCache *cache , gpointer key ) ;
#line 60
extern void g_cache_remove(GCache *cache , gconstpointer value ) ;
#line 63
extern void g_cache_key_foreach(GCache *cache , GHFunc func , gpointer user_data ) ;
#line 67
extern void g_cache_value_foreach(GCache *cache , GHFunc func , gpointer user_data ) ;
#line 58 "/usr/include/glib-2.0/glib/deprecated/gcompletion.h"
extern GCompletion *g_completion_new(GCompletionFunc func ) ;
#line 60
extern void g_completion_add_items(GCompletion *cmp , GList *items ) ;
#line 63
extern void g_completion_remove_items(GCompletion *cmp , GList *items ) ;
#line 66
extern void g_completion_clear_items(GCompletion *cmp ) ;
#line 68
extern GList *g_completion_complete(GCompletion *cmp , gchar *prefix , gchar **new_prefix ) ;
#line 72
extern GList *g_completion_complete_utf8(GCompletion *cmp , gchar *prefix , gchar **new_prefix ) ;
#line 76
extern void g_completion_set_compare(GCompletion *cmp , GCompletionStrncmpFunc strncmp_func ) ;
#line 79
extern void g_completion_free(GCompletion *cmp ) ;
#line 68 "/usr/include/glib-2.0/glib/deprecated/grel.h"
extern GRelation *g_relation_new(gint fields ) ;
#line 70
extern void g_relation_destroy(GRelation *relation ) ;
#line 72
extern void g_relation_index(GRelation *relation , gint field , GHashFunc hash_func ,
                             GEqualFunc key_equal_func ) ;
#line 77
extern void g_relation_insert(GRelation *relation  , ...) ;
#line 80
extern gint g_relation_delete(GRelation *relation , gconstpointer key , gint field ) ;
#line 84
extern GTuples *g_relation_select(GRelation *relation , gconstpointer key , gint field ) ;
#line 88
extern gint g_relation_count(GRelation *relation , gconstpointer key , gint field ) ;
#line 92
extern gboolean g_relation_exists(GRelation *relation  , ...) ;
#line 95
extern void g_relation_print(GRelation *relation ) ;
#line 97
extern void g_tuples_destroy(GTuples *tuples ) ;
#line 99
extern gpointer g_tuples_index(GTuples *tuples , gint index_ , gint field ) ;
#line 94 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
extern GThreadFunctions g_thread_functions_for_glib_use ;
#line 95
extern gboolean g_thread_use_default_impl ;
#line 97
extern guint64 (*g_thread_gettime)(void) ;
#line 100
extern GThread *g_thread_create(GThreadFunc func , gpointer data , gboolean joinable ,
                                GError **error ) ;
#line 106
extern GThread *g_thread_create_full(GThreadFunc func , gpointer data , gulong stack_size ,
                                     gboolean joinable , gboolean bound , GThreadPriority priority ,
                                     GError **error ) ;
#line 115
extern void g_thread_set_priority(GThread *thread , GThreadPriority priority ) ;
#line 119
extern void g_thread_foreach(GFunc thread_func , gpointer user_data ) ;
#line 117 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h"
extern  __attribute__((__nothrow__)) int __sched_cpucount(size_t __setsize , cpu_set_t *__setp ) ;
#line 119
extern  __attribute__((__nothrow__)) cpu_set_t *__sched_cpualloc(size_t __count ) ;
#line 120
extern  __attribute__((__nothrow__)) void __sched_cpufree(cpu_set_t *__set ) ;
#line 54 "/usr/include/sched.h"
extern  __attribute__((__nothrow__)) int sched_setparam(__pid_t __pid , struct sched_param *__param ) ;
#line 58
extern  __attribute__((__nothrow__)) int sched_getparam(__pid_t __pid , struct sched_param *__param ) ;
#line 61
extern  __attribute__((__nothrow__)) int sched_setscheduler(__pid_t __pid , int __policy ,
                                                            struct sched_param *__param ) ;
#line 65
extern  __attribute__((__nothrow__)) int sched_getscheduler(__pid_t __pid ) ;
#line 68
extern  __attribute__((__nothrow__)) int sched_yield(void) ;
#line 71
extern  __attribute__((__nothrow__)) int sched_get_priority_max(int __algorithm ) ;
#line 74
extern  __attribute__((__nothrow__)) int sched_get_priority_min(int __algorithm ) ;
#line 78
extern  __attribute__((__nothrow__)) int sched_rr_get_interval(__pid_t __pid , struct timespec *__t ) ;
#line 202 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int pthread_create(pthread_t *__newthread , pthread_attr_t *__attr ,
                                                        void *(*__start_routine)(void * ) ,
                                                        void *__arg ) ;
#line 211
extern void pthread_exit(void *__retval ) ;
#line 219
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
#line 269
extern  __attribute__((__nothrow__)) int pthread_detach(pthread_t __th ) ;
#line 273
extern  __attribute__((__nothrow__)) pthread_t pthread_self(void) ;
#line 276
__inline extern  __attribute__((__nothrow__)) int pthread_equal(pthread_t __thread1 ,
                                                                pthread_t __thread2 )  __attribute__((__gnu_inline__)) ;
#line 285
extern  __attribute__((__nothrow__)) int pthread_attr_init(pthread_attr_t *__attr ) ;
#line 288
extern  __attribute__((__nothrow__)) int pthread_attr_destroy(pthread_attr_t *__attr ) ;
#line 292
extern  __attribute__((__nothrow__)) int pthread_attr_getdetachstate(pthread_attr_t *__attr ,
                                                                     int *__detachstate ) ;
#line 297
extern  __attribute__((__nothrow__)) int pthread_attr_setdetachstate(pthread_attr_t *__attr ,
                                                                     int __detachstate ) ;
#line 303
extern  __attribute__((__nothrow__)) int pthread_attr_getguardsize(pthread_attr_t *__attr ,
                                                                   size_t *__guardsize ) ;
#line 308
extern  __attribute__((__nothrow__)) int pthread_attr_setguardsize(pthread_attr_t *__attr ,
                                                                   size_t __guardsize ) ;
#line 314
extern  __attribute__((__nothrow__)) int pthread_attr_getschedparam(pthread_attr_t *__attr ,
                                                                    struct sched_param *__param ) ;
#line 319
extern  __attribute__((__nothrow__)) int pthread_attr_setschedparam(pthread_attr_t *__attr ,
                                                                    struct sched_param *__param ) ;
#line 324
extern  __attribute__((__nothrow__)) int pthread_attr_getschedpolicy(pthread_attr_t *__attr ,
                                                                     int *__policy ) ;
#line 329
extern  __attribute__((__nothrow__)) int pthread_attr_setschedpolicy(pthread_attr_t *__attr ,
                                                                     int __policy ) ;
#line 333
extern  __attribute__((__nothrow__)) int pthread_attr_getinheritsched(pthread_attr_t *__attr ,
                                                                      int *__inherit ) ;
#line 338
extern  __attribute__((__nothrow__)) int pthread_attr_setinheritsched(pthread_attr_t *__attr ,
                                                                      int __inherit ) ;
#line 344
extern  __attribute__((__nothrow__)) int pthread_attr_getscope(pthread_attr_t *__attr ,
                                                               int *__scope ) ;
#line 349
extern  __attribute__((__nothrow__)) int pthread_attr_setscope(pthread_attr_t *__attr ,
                                                               int __scope ) ;
#line 353
extern  __attribute__((__nothrow__)) int pthread_attr_getstackaddr(pthread_attr_t *__attr ,
                                                                   void **__stackaddr ) ;
#line 361
extern  __attribute__((__nothrow__)) int pthread_attr_setstackaddr(pthread_attr_t *__attr ,
                                                                   void *__stackaddr ) ;
#line 366
extern  __attribute__((__nothrow__)) int pthread_attr_getstacksize(pthread_attr_t *__attr ,
                                                                   size_t *__stacksize ) ;
#line 373
extern  __attribute__((__nothrow__)) int pthread_attr_setstacksize(pthread_attr_t *__attr ,
                                                                   size_t __stacksize ) ;
#line 379
extern  __attribute__((__nothrow__)) int pthread_attr_getstack(pthread_attr_t *__attr ,
                                                               void **__stackaddr ,
                                                               size_t *__stacksize ) ;
#line 387
extern  __attribute__((__nothrow__)) int pthread_attr_setstack(pthread_attr_t *__attr ,
                                                               void *__stackaddr ,
                                                               size_t __stacksize ) ;
#line 441
extern  __attribute__((__nothrow__)) int pthread_setschedparam(pthread_t __target_thread ,
                                                               int __policy , struct sched_param *__param ) ;
#line 446
extern  __attribute__((__nothrow__)) int pthread_getschedparam(pthread_t __target_thread ,
                                                               int *__policy , struct sched_param *__param ) ;
#line 452
extern  __attribute__((__nothrow__)) int pthread_setschedprio(pthread_t __target_thread ,
                                                              int __prio ) ;
#line 509
extern int pthread_once(pthread_once_t *__once_control , void (*__init_routine)(void) ) ;
#line 521
extern int pthread_setcancelstate(int __state , int *__oldstate ) ;
#line 525
extern int pthread_setcanceltype(int __type , int *__oldtype ) ;
#line 528
extern int pthread_cancel(pthread_t __th ) ;
#line 533
extern void pthread_testcancel(void) ;
#line 697
extern void __pthread_register_cancel(__pthread_unwind_buf_t *__buf ) ;
#line 709
extern void __pthread_unregister_cancel(__pthread_unwind_buf_t *__buf ) ;
#line 750
extern void __pthread_unwind_next(__pthread_unwind_buf_t *__buf ) ;
#line 766
extern  __attribute__((__nothrow__)) int __sigsetjmp_cancel(struct __cancel_jmp_buf_tag __env[1] ,
                                                            int __savemask ) ;
#line 781
extern  __attribute__((__nothrow__)) int pthread_mutex_init(pthread_mutex_t *__mutex ,
                                                            pthread_mutexattr_t *__mutexattr ) ;
#line 786
extern  __attribute__((__nothrow__)) int pthread_mutex_destroy(pthread_mutex_t *__mutex ) ;
#line 790
extern  __attribute__((__nothrow__)) int pthread_mutex_trylock(pthread_mutex_t *__mutex ) ;
#line 794
extern  __attribute__((__nothrow__)) int pthread_mutex_lock(pthread_mutex_t *__mutex ) ;
#line 800
extern  __attribute__((__nothrow__)) int pthread_mutex_timedlock(pthread_mutex_t *__mutex ,
                                                                 struct timespec *__abstime ) ;
#line 835
extern  __attribute__((__nothrow__)) int pthread_mutex_unlock(pthread_mutex_t *__mutex ) ;
#line 840
extern  __attribute__((__nothrow__)) int pthread_mutex_getprioceiling(pthread_mutex_t *__mutex ,
                                                                      int *__prioceiling ) ;
#line 847
extern  __attribute__((__nothrow__)) int pthread_mutex_setprioceiling(pthread_mutex_t *__mutex ,
                                                                      int __prioceiling ,
                                                                      int *__old_ceiling ) ;
#line 855
extern  __attribute__((__nothrow__)) int pthread_mutex_consistent(pthread_mutex_t *__mutex ) ;
#line 874
extern  __attribute__((__nothrow__)) int pthread_mutexattr_init(pthread_mutexattr_t *__attr ) ;
#line 878
extern  __attribute__((__nothrow__)) int pthread_mutexattr_destroy(pthread_mutexattr_t *__attr ) ;
#line 882
extern  __attribute__((__nothrow__)) int pthread_mutexattr_getpshared(pthread_mutexattr_t *__attr ,
                                                                      int *__pshared ) ;
#line 888
extern  __attribute__((__nothrow__)) int pthread_mutexattr_setpshared(pthread_mutexattr_t *__attr ,
                                                                      int __pshared ) ;
#line 894
extern  __attribute__((__nothrow__)) int pthread_mutexattr_gettype(pthread_mutexattr_t *__attr ,
                                                                   int *__kind ) ;
#line 901
extern  __attribute__((__nothrow__)) int pthread_mutexattr_settype(pthread_mutexattr_t *__attr ,
                                                                   int __kind ) ;
#line 906
extern  __attribute__((__nothrow__)) int pthread_mutexattr_getprotocol(pthread_mutexattr_t *__attr ,
                                                                       int *__protocol ) ;
#line 913
extern  __attribute__((__nothrow__)) int pthread_mutexattr_setprotocol(pthread_mutexattr_t *__attr ,
                                                                       int __protocol ) ;
#line 918
extern  __attribute__((__nothrow__)) int pthread_mutexattr_getprioceiling(pthread_mutexattr_t *__attr ,
                                                                          int *__prioceiling ) ;
#line 924
extern  __attribute__((__nothrow__)) int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *__attr ,
                                                                          int __prioceiling ) ;
#line 930
extern  __attribute__((__nothrow__)) int pthread_mutexattr_getrobust(pthread_mutexattr_t *__attr ,
                                                                     int *__robustness ) ;
#line 946
extern  __attribute__((__nothrow__)) int pthread_mutexattr_setrobust(pthread_mutexattr_t *__attr ,
                                                                     int __robustness ) ;
#line 967
extern  __attribute__((__nothrow__)) int pthread_rwlock_init(pthread_rwlock_t *__rwlock ,
                                                             pthread_rwlockattr_t *__attr ) ;
#line 972
extern  __attribute__((__nothrow__)) int pthread_rwlock_destroy(pthread_rwlock_t *__rwlock ) ;
#line 976
extern  __attribute__((__nothrow__)) int pthread_rwlock_rdlock(pthread_rwlock_t *__rwlock ) ;
#line 980
extern  __attribute__((__nothrow__)) int pthread_rwlock_tryrdlock(pthread_rwlock_t *__rwlock ) ;
#line 986
extern  __attribute__((__nothrow__)) int pthread_rwlock_timedrdlock(pthread_rwlock_t *__rwlock ,
                                                                    struct timespec *__abstime ) ;
#line 1023
extern  __attribute__((__nothrow__)) int pthread_rwlock_wrlock(pthread_rwlock_t *__rwlock ) ;
#line 1027
extern  __attribute__((__nothrow__)) int pthread_rwlock_trywrlock(pthread_rwlock_t *__rwlock ) ;
#line 1033
extern  __attribute__((__nothrow__)) int pthread_rwlock_timedwrlock(pthread_rwlock_t *__rwlock ,
                                                                    struct timespec *__abstime ) ;
#line 1071
extern  __attribute__((__nothrow__)) int pthread_rwlock_unlock(pthread_rwlock_t *__rwlock ) ;
#line 1078
extern  __attribute__((__nothrow__)) int pthread_rwlockattr_init(pthread_rwlockattr_t *__attr ) ;
#line 1082
extern  __attribute__((__nothrow__)) int pthread_rwlockattr_destroy(pthread_rwlockattr_t *__attr ) ;
#line 1086
extern  __attribute__((__nothrow__)) int pthread_rwlockattr_getpshared(pthread_rwlockattr_t *__attr ,
                                                                       int *__pshared ) ;
#line 1092
extern  __attribute__((__nothrow__)) int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *__attr ,
                                                                       int __pshared ) ;
#line 1097
extern  __attribute__((__nothrow__)) int pthread_rwlockattr_getkind_np(pthread_rwlockattr_t *__attr ,
                                                                       int *__pref ) ;
#line 1103
extern  __attribute__((__nothrow__)) int pthread_rwlockattr_setkind_np(pthread_rwlockattr_t *__attr ,
                                                                       int __pref ) ;
#line 1112
extern  __attribute__((__nothrow__)) int pthread_cond_init(pthread_cond_t *__cond ,
                                                           pthread_condattr_t *__cond_attr ) ;
#line 1117
extern  __attribute__((__nothrow__)) int pthread_cond_destroy(pthread_cond_t *__cond ) ;
#line 1121
extern  __attribute__((__nothrow__)) int pthread_cond_signal(pthread_cond_t *__cond ) ;
#line 1125
extern  __attribute__((__nothrow__)) int pthread_cond_broadcast(pthread_cond_t *__cond ) ;
#line 1133
extern int pthread_cond_wait(pthread_cond_t *__cond , pthread_mutex_t *__mutex ) ;
#line 1145
extern int pthread_cond_timedwait(pthread_cond_t *__cond , pthread_mutex_t *__mutex ,
                                  struct timespec *__abstime ) ;
#line 1194
extern  __attribute__((__nothrow__)) int pthread_condattr_init(pthread_condattr_t *__attr ) ;
#line 1198
extern  __attribute__((__nothrow__)) int pthread_condattr_destroy(pthread_condattr_t *__attr ) ;
#line 1202
extern  __attribute__((__nothrow__)) int pthread_condattr_getpshared(pthread_condattr_t *__attr ,
                                                                     int *__pshared ) ;
#line 1208
extern  __attribute__((__nothrow__)) int pthread_condattr_setpshared(pthread_condattr_t *__attr ,
                                                                     int __pshared ) ;
#line 1213
extern  __attribute__((__nothrow__)) int pthread_condattr_getclock(pthread_condattr_t *__attr ,
                                                                   __clockid_t *__clock_id ) ;
#line 1219
extern  __attribute__((__nothrow__)) int pthread_condattr_setclock(pthread_condattr_t *__attr ,
                                                                   __clockid_t __clock_id ) ;
#line 1230
extern  __attribute__((__nothrow__)) int pthread_spin_init(pthread_spinlock_t *__lock ,
                                                           int __pshared ) ;
#line 1234
extern  __attribute__((__nothrow__)) int pthread_spin_destroy(pthread_spinlock_t *__lock ) ;
#line 1238
extern  __attribute__((__nothrow__)) int pthread_spin_lock(pthread_spinlock_t *__lock ) ;
#line 1242
extern  __attribute__((__nothrow__)) int pthread_spin_trylock(pthread_spinlock_t *__lock ) ;
#line 1246
extern  __attribute__((__nothrow__)) int pthread_spin_unlock(pthread_spinlock_t *__lock ) ;
#line 1254
extern  __attribute__((__nothrow__)) int pthread_barrier_init(pthread_barrier_t *__barrier ,
                                                              pthread_barrierattr_t *__attr ,
                                                              unsigned int __count ) ;
#line 1260
extern  __attribute__((__nothrow__)) int pthread_barrier_destroy(pthread_barrier_t *__barrier ) ;
#line 1264
extern  __attribute__((__nothrow__)) int pthread_barrier_wait(pthread_barrier_t *__barrier ) ;
#line 1269
extern  __attribute__((__nothrow__)) int pthread_barrierattr_init(pthread_barrierattr_t *__attr ) ;
#line 1273
extern  __attribute__((__nothrow__)) int pthread_barrierattr_destroy(pthread_barrierattr_t *__attr ) ;
#line 1277
extern  __attribute__((__nothrow__)) int pthread_barrierattr_getpshared(pthread_barrierattr_t *__attr ,
                                                                        int *__pshared ) ;
#line 1283
extern  __attribute__((__nothrow__)) int pthread_barrierattr_setpshared(pthread_barrierattr_t *__attr ,
                                                                        int __pshared ) ;
#line 1297
extern  __attribute__((__nothrow__)) int pthread_key_create(pthread_key_t *__key ,
                                                            void (*__destr_function)(void * ) ) ;
#line 1302
extern  __attribute__((__nothrow__)) int pthread_key_delete(pthread_key_t __key ) ;
#line 1305
extern  __attribute__((__nothrow__)) void *pthread_getspecific(pthread_key_t __key ) ;
#line 1308
extern  __attribute__((__nothrow__)) int pthread_setspecific(pthread_key_t __key ,
                                                             void const   *__pointer ) ;
#line 1315
extern  __attribute__((__nothrow__)) int pthread_getcpuclockid(pthread_t __thread_id ,
                                                               __clockid_t *__clock_id ) ;
#line 1332
extern  __attribute__((__nothrow__)) int pthread_atfork(void (*__prepare)(void) ,
                                                        void (*__parent)(void) , void (*__child)(void) ) ;
#line 1340
__inline extern  __attribute__((__nothrow__)) int pthread_equal(pthread_t __thread1 ,
                                                                pthread_t __thread2 )  __attribute__((__gnu_inline__)) ;
#line 1340 "/usr/include/pthread.h"
__inline extern int pthread_equal(pthread_t __thread1 , pthread_t __thread2 ) 
{ 


  {
#line 1342
  return (__thread1 == __thread2);
}
}
#line 150 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
extern void g_static_mutex_init(GStaticMutex *mutex ) ;
#line 152
extern void g_static_mutex_free(GStaticMutex *mutex ) ;
#line 154
extern GMutex *g_static_mutex_get_mutex_impl(GStaticMutex *mutex ) ;
#line 176
extern void g_static_rec_mutex_init(GStaticRecMutex *mutex ) ;
#line 179
extern void g_static_rec_mutex_lock(GStaticRecMutex *mutex ) ;
#line 182
extern gboolean g_static_rec_mutex_trylock(GStaticRecMutex *mutex ) ;
#line 185
extern void g_static_rec_mutex_unlock(GStaticRecMutex *mutex ) ;
#line 188
extern void g_static_rec_mutex_lock_full(GStaticRecMutex *mutex , guint depth ) ;
#line 192
extern guint g_static_rec_mutex_unlock_full(GStaticRecMutex *mutex ) ;
#line 195
extern void g_static_rec_mutex_free(GStaticRecMutex *mutex ) ;
#line 213
extern void g_static_rw_lock_init(GStaticRWLock *lock ) ;
#line 216
extern void g_static_rw_lock_reader_lock(GStaticRWLock *lock ) ;
#line 219
extern gboolean g_static_rw_lock_reader_trylock(GStaticRWLock *lock ) ;
#line 222
extern void g_static_rw_lock_reader_unlock(GStaticRWLock *lock ) ;
#line 225
extern void g_static_rw_lock_writer_lock(GStaticRWLock *lock ) ;
#line 228
extern gboolean g_static_rw_lock_writer_trylock(GStaticRWLock *lock ) ;
#line 231
extern void g_static_rw_lock_writer_unlock(GStaticRWLock *lock ) ;
#line 234
extern void g_static_rw_lock_free(GStaticRWLock *lock ) ;
#line 237
extern GPrivate *g_private_new(GDestroyNotify notify ) ;
#line 248
extern void g_static_private_init(GStaticPrivate *private_key ) ;
#line 251
extern gpointer g_static_private_get(GStaticPrivate *private_key ) ;
#line 254
extern void g_static_private_set(GStaticPrivate *private_key , gpointer data , GDestroyNotify notify ) ;
#line 259
extern void g_static_private_free(GStaticPrivate *private_key ) ;
#line 262
extern gboolean g_once_init_enter_impl(gsize *location ) ;
#line 265
extern void g_thread_init(gpointer vtable ) ;
#line 267
extern void g_thread_init_with_errorcheck_mutexes(gpointer vtable ) ;
#line 270
extern gboolean g_thread_get_initialized(void) ;
#line 272
extern gboolean g_threads_got_initialized ;
#line 277
extern GMutex *g_mutex_new(void) ;
#line 279
extern void g_mutex_free(GMutex *mutex ) ;
#line 281
extern GCond *g_cond_new(void) ;
#line 283
extern void g_cond_free(GCond *cond ) ;
#line 285
extern gboolean g_cond_timed_wait(GCond *cond , GMutex *mutex , GTimeVal *timeval ) ;
#line 25 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void g_autoptr_cleanup_generic_gfree(void *p ) 
{ 
  void **pp ;

  {
  {
#line 27
  pp = (void **)p;
#line 28
  g_free(*pp);
  }
  return;
}
}
#line 32 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void g_autoptr_cleanup_gstring_free(GString *string ) 
{ 


  {
#line 34
  if (string) {
    {
#line 35
    g_string_free(string, ! 0);
    }
  }
  return;
}
}
#line 45 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GAsyncQueue(GAsyncQueue *_ptr ) 
{ 


  {
#line 45
  if (_ptr) {
    {
#line 45
    g_async_queue_unref((GAsyncQueue *)_ptr);
    }
  }
  return;
}
}
#line 45 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GAsyncQueue(GAsyncQueue **_ptr ) 
{ 


  {
  {
#line 45
  glib_autoptr_clear_GAsyncQueue(*_ptr);
  }
  return;
}
}
#line 45 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GAsyncQueue(GList **_l ) 
{ 


  {
  {
#line 45
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_async_queue_unref)));
  }
  return;
}
}
#line 45 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GAsyncQueue(GSList **_l ) 
{ 


  {
  {
#line 45
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_async_queue_unref)));
  }
  return;
}
}
#line 45 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GAsyncQueue(GQueue **_q ) 
{ 


  {
#line 45
  if (*_q) {
    {
#line 45
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_async_queue_unref)));
    }
  }
  return;
}
}
#line 46 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GBookmarkFile(GBookmarkFile *_ptr ) 
{ 


  {
#line 46
  if (_ptr) {
    {
#line 46
    g_bookmark_file_free((GBookmarkFile *)_ptr);
    }
  }
  return;
}
}
#line 46 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GBookmarkFile(GBookmarkFile **_ptr ) 
{ 


  {
  {
#line 46
  glib_autoptr_clear_GBookmarkFile(*_ptr);
  }
  return;
}
}
#line 46 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GBookmarkFile(GList **_l ) 
{ 


  {
  {
#line 46
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_bookmark_file_free)));
  }
  return;
}
}
#line 46 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GBookmarkFile(GSList **_l ) 
{ 


  {
  {
#line 46
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_bookmark_file_free)));
  }
  return;
}
}
#line 46 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GBookmarkFile(GQueue **_q ) 
{ 


  {
#line 46
  if (*_q) {
    {
#line 46
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_bookmark_file_free)));
    }
  }
  return;
}
}
#line 47 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GBytes(GBytes *_ptr ) 
{ 


  {
#line 47
  if (_ptr) {
    {
#line 47
    g_bytes_unref((GBytes *)_ptr);
    }
  }
  return;
}
}
#line 47 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GBytes(GBytes **_ptr ) 
{ 


  {
  {
#line 47
  glib_autoptr_clear_GBytes(*_ptr);
  }
  return;
}
}
#line 47 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GBytes(GList **_l ) 
{ 


  {
  {
#line 47
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_bytes_unref)));
  }
  return;
}
}
#line 47 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GBytes(GSList **_l ) 
{ 


  {
  {
#line 47
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_bytes_unref)));
  }
  return;
}
}
#line 47 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GBytes(GQueue **_q ) 
{ 


  {
#line 47
  if (*_q) {
    {
#line 47
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_bytes_unref)));
    }
  }
  return;
}
}
#line 48 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GChecksum(GChecksum *_ptr ) 
{ 


  {
#line 48
  if (_ptr) {
    {
#line 48
    g_checksum_free((GChecksum *)_ptr);
    }
  }
  return;
}
}
#line 48 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GChecksum(GChecksum **_ptr ) 
{ 


  {
  {
#line 48
  glib_autoptr_clear_GChecksum(*_ptr);
  }
  return;
}
}
#line 48 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GChecksum(GList **_l ) 
{ 


  {
  {
#line 48
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_checksum_free)));
  }
  return;
}
}
#line 48 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GChecksum(GSList **_l ) 
{ 


  {
  {
#line 48
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_checksum_free)));
  }
  return;
}
}
#line 48 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GChecksum(GQueue **_q ) 
{ 


  {
#line 48
  if (*_q) {
    {
#line 48
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_checksum_free)));
    }
  }
  return;
}
}
#line 49 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GDateTime(GDateTime *_ptr ) 
{ 


  {
#line 49
  if (_ptr) {
    {
#line 49
    g_date_time_unref((GDateTime *)_ptr);
    }
  }
  return;
}
}
#line 49 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GDateTime(GDateTime **_ptr ) 
{ 


  {
  {
#line 49
  glib_autoptr_clear_GDateTime(*_ptr);
  }
  return;
}
}
#line 49 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GDateTime(GList **_l ) 
{ 


  {
  {
#line 49
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_date_time_unref)));
  }
  return;
}
}
#line 49 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GDateTime(GSList **_l ) 
{ 


  {
  {
#line 49
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_date_time_unref)));
  }
  return;
}
}
#line 49 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GDateTime(GQueue **_q ) 
{ 


  {
#line 49
  if (*_q) {
    {
#line 49
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_date_time_unref)));
    }
  }
  return;
}
}
#line 50 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GDate(GDate *_ptr ) 
{ 


  {
#line 50
  if (_ptr) {
    {
#line 50
    g_date_free((GDate *)_ptr);
    }
  }
  return;
}
}
#line 50 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GDate(GDate **_ptr ) 
{ 


  {
  {
#line 50
  glib_autoptr_clear_GDate(*_ptr);
  }
  return;
}
}
#line 50 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GDate(GList **_l ) 
{ 


  {
  {
#line 50
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_date_free)));
  }
  return;
}
}
#line 50 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GDate(GSList **_l ) 
{ 


  {
  {
#line 50
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_date_free)));
  }
  return;
}
}
#line 50 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GDate(GQueue **_q ) 
{ 


  {
#line 50
  if (*_q) {
    {
#line 50
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_date_free)));
    }
  }
  return;
}
}
#line 51 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GDir(GDir *_ptr ) 
{ 


  {
#line 51
  if (_ptr) {
    {
#line 51
    g_dir_close((GDir *)_ptr);
    }
  }
  return;
}
}
#line 51 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GDir(GDir **_ptr ) 
{ 


  {
  {
#line 51
  glib_autoptr_clear_GDir(*_ptr);
  }
  return;
}
}
#line 51 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GDir(GList **_l ) 
{ 


  {
  {
#line 51
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_dir_close)));
  }
  return;
}
}
#line 51 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GDir(GSList **_l ) 
{ 


  {
  {
#line 51
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_dir_close)));
  }
  return;
}
}
#line 51 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GDir(GQueue **_q ) 
{ 


  {
#line 51
  if (*_q) {
    {
#line 51
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_dir_close)));
    }
  }
  return;
}
}
#line 52 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GError(GError *_ptr ) 
{ 


  {
#line 52
  if (_ptr) {
    {
#line 52
    g_error_free((GError *)_ptr);
    }
  }
  return;
}
}
#line 52 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GError(GError **_ptr ) 
{ 


  {
  {
#line 52
  glib_autoptr_clear_GError(*_ptr);
  }
  return;
}
}
#line 52 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GError(GList **_l ) 
{ 


  {
  {
#line 52
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_error_free)));
  }
  return;
}
}
#line 52 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GError(GSList **_l ) 
{ 


  {
  {
#line 52
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_error_free)));
  }
  return;
}
}
#line 52 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GError(GQueue **_q ) 
{ 


  {
#line 52
  if (*_q) {
    {
#line 52
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_error_free)));
    }
  }
  return;
}
}
#line 53 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GHashTable(GHashTable *_ptr ) 
{ 


  {
#line 53
  if (_ptr) {
    {
#line 53
    g_hash_table_unref((GHashTable *)_ptr);
    }
  }
  return;
}
}
#line 53 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GHashTable(GHashTable **_ptr ) 
{ 


  {
  {
#line 53
  glib_autoptr_clear_GHashTable(*_ptr);
  }
  return;
}
}
#line 53 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GHashTable(GList **_l ) 
{ 


  {
  {
#line 53
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_hash_table_unref)));
  }
  return;
}
}
#line 53 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GHashTable(GSList **_l ) 
{ 


  {
  {
#line 53
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_hash_table_unref)));
  }
  return;
}
}
#line 53 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GHashTable(GQueue **_q ) 
{ 


  {
#line 53
  if (*_q) {
    {
#line 53
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_hash_table_unref)));
    }
  }
  return;
}
}
#line 54 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GHmac(GHmac *_ptr ) 
{ 


  {
#line 54
  if (_ptr) {
    {
#line 54
    g_hmac_unref((GHmac *)_ptr);
    }
  }
  return;
}
}
#line 54 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GHmac(GHmac **_ptr ) 
{ 


  {
  {
#line 54
  glib_autoptr_clear_GHmac(*_ptr);
  }
  return;
}
}
#line 54 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GHmac(GList **_l ) 
{ 


  {
  {
#line 54
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_hmac_unref)));
  }
  return;
}
}
#line 54 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GHmac(GSList **_l ) 
{ 


  {
  {
#line 54
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_hmac_unref)));
  }
  return;
}
}
#line 54 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GHmac(GQueue **_q ) 
{ 


  {
#line 54
  if (*_q) {
    {
#line 54
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_hmac_unref)));
    }
  }
  return;
}
}
#line 55 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GIOChannel(GIOChannel *_ptr ) 
{ 


  {
#line 55
  if (_ptr) {
    {
#line 55
    g_io_channel_unref((GIOChannel *)_ptr);
    }
  }
  return;
}
}
#line 55 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GIOChannel(GIOChannel **_ptr ) 
{ 


  {
  {
#line 55
  glib_autoptr_clear_GIOChannel(*_ptr);
  }
  return;
}
}
#line 55 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GIOChannel(GList **_l ) 
{ 


  {
  {
#line 55
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_io_channel_unref)));
  }
  return;
}
}
#line 55 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GIOChannel(GSList **_l ) 
{ 


  {
  {
#line 55
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_io_channel_unref)));
  }
  return;
}
}
#line 55 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GIOChannel(GQueue **_q ) 
{ 


  {
#line 55
  if (*_q) {
    {
#line 55
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_io_channel_unref)));
    }
  }
  return;
}
}
#line 56 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GKeyFile(GKeyFile *_ptr ) 
{ 


  {
#line 56
  if (_ptr) {
    {
#line 56
    g_key_file_unref((GKeyFile *)_ptr);
    }
  }
  return;
}
}
#line 56 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GKeyFile(GKeyFile **_ptr ) 
{ 


  {
  {
#line 56
  glib_autoptr_clear_GKeyFile(*_ptr);
  }
  return;
}
}
#line 56 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GKeyFile(GList **_l ) 
{ 


  {
  {
#line 56
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_key_file_unref)));
  }
  return;
}
}
#line 56 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GKeyFile(GSList **_l ) 
{ 


  {
  {
#line 56
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_key_file_unref)));
  }
  return;
}
}
#line 56 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GKeyFile(GQueue **_q ) 
{ 


  {
#line 56
  if (*_q) {
    {
#line 56
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_key_file_unref)));
    }
  }
  return;
}
}
#line 57 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GList(GList *_ptr ) 
{ 


  {
#line 57
  if (_ptr) {
    {
#line 57
    g_list_free((GList *)_ptr);
    }
  }
  return;
}
}
#line 57 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GList(GList **_ptr ) 
{ 


  {
  {
#line 57
  glib_autoptr_clear_GList(*_ptr);
  }
  return;
}
}
#line 57 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GList(GList **_l ) 
{ 


  {
  {
#line 57
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_list_free)));
  }
  return;
}
}
#line 57 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GList(GSList **_l ) 
{ 


  {
  {
#line 57
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_list_free)));
  }
  return;
}
}
#line 57 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GList(GQueue **_q ) 
{ 


  {
#line 57
  if (*_q) {
    {
#line 57
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_list_free)));
    }
  }
  return;
}
}
#line 58 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GArray(GArray *_ptr ) 
{ 


  {
#line 58
  if (_ptr) {
    {
#line 58
    g_array_unref((GArray *)_ptr);
    }
  }
  return;
}
}
#line 58 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GArray(GArray **_ptr ) 
{ 


  {
  {
#line 58
  glib_autoptr_clear_GArray(*_ptr);
  }
  return;
}
}
#line 58 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GArray(GList **_l ) 
{ 


  {
  {
#line 58
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_array_unref)));
  }
  return;
}
}
#line 58 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GArray(GSList **_l ) 
{ 


  {
  {
#line 58
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_array_unref)));
  }
  return;
}
}
#line 58 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GArray(GQueue **_q ) 
{ 


  {
#line 58
  if (*_q) {
    {
#line 58
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_array_unref)));
    }
  }
  return;
}
}
#line 59 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GPtrArray(GPtrArray *_ptr ) 
{ 


  {
#line 59
  if (_ptr) {
    {
#line 59
    g_ptr_array_unref((GPtrArray *)_ptr);
    }
  }
  return;
}
}
#line 59 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GPtrArray(GPtrArray **_ptr ) 
{ 


  {
  {
#line 59
  glib_autoptr_clear_GPtrArray(*_ptr);
  }
  return;
}
}
#line 59 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GPtrArray(GList **_l ) 
{ 


  {
  {
#line 59
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_ptr_array_unref)));
  }
  return;
}
}
#line 59 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GPtrArray(GSList **_l ) 
{ 


  {
  {
#line 59
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_ptr_array_unref)));
  }
  return;
}
}
#line 59 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GPtrArray(GQueue **_q ) 
{ 


  {
#line 59
  if (*_q) {
    {
#line 59
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_ptr_array_unref)));
    }
  }
  return;
}
}
#line 60 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GByteArray(GByteArray *_ptr ) 
{ 


  {
#line 60
  if (_ptr) {
    {
#line 60
    g_byte_array_unref((GByteArray *)_ptr);
    }
  }
  return;
}
}
#line 60 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GByteArray(GByteArray **_ptr ) 
{ 


  {
  {
#line 60
  glib_autoptr_clear_GByteArray(*_ptr);
  }
  return;
}
}
#line 60 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GByteArray(GList **_l ) 
{ 


  {
  {
#line 60
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_byte_array_unref)));
  }
  return;
}
}
#line 60 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GByteArray(GSList **_l ) 
{ 


  {
  {
#line 60
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_byte_array_unref)));
  }
  return;
}
}
#line 60 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GByteArray(GQueue **_q ) 
{ 


  {
#line 60
  if (*_q) {
    {
#line 60
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_byte_array_unref)));
    }
  }
  return;
}
}
#line 61 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GMainContext(GMainContext *_ptr ) 
{ 


  {
#line 61
  if (_ptr) {
    {
#line 61
    g_main_context_unref((GMainContext *)_ptr);
    }
  }
  return;
}
}
#line 61 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GMainContext(GMainContext **_ptr ) 
{ 


  {
  {
#line 61
  glib_autoptr_clear_GMainContext(*_ptr);
  }
  return;
}
}
#line 61 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GMainContext(GList **_l ) 
{ 


  {
  {
#line 61
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_main_context_unref)));
  }
  return;
}
}
#line 61 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GMainContext(GSList **_l ) 
{ 


  {
  {
#line 61
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_main_context_unref)));
  }
  return;
}
}
#line 61 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GMainContext(GQueue **_q ) 
{ 


  {
#line 61
  if (*_q) {
    {
#line 61
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_main_context_unref)));
    }
  }
  return;
}
}
#line 62 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GMainContextPusher(GMainContextPusher *_ptr ) 
{ 


  {
#line 62
  if (_ptr) {
    {
#line 62
    g_main_context_pusher_free((GMainContextPusher *)_ptr);
    }
  }
  return;
}
}
#line 62 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GMainContextPusher(GMainContextPusher **_ptr ) 
{ 


  {
  {
#line 62
  glib_autoptr_clear_GMainContextPusher(*_ptr);
  }
  return;
}
}
#line 62 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GMainContextPusher(GList **_l ) 
{ 


  {
  {
#line 62
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_main_context_pusher_free)));
  }
  return;
}
}
#line 62 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GMainContextPusher(GSList **_l ) 
{ 


  {
  {
#line 62
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_main_context_pusher_free)));
  }
  return;
}
}
#line 62 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GMainContextPusher(GQueue **_q ) 
{ 


  {
#line 62
  if (*_q) {
    {
#line 62
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_main_context_pusher_free)));
    }
  }
  return;
}
}
#line 63 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GMainLoop(GMainLoop *_ptr ) 
{ 


  {
#line 63
  if (_ptr) {
    {
#line 63
    g_main_loop_unref((GMainLoop *)_ptr);
    }
  }
  return;
}
}
#line 63 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GMainLoop(GMainLoop **_ptr ) 
{ 


  {
  {
#line 63
  glib_autoptr_clear_GMainLoop(*_ptr);
  }
  return;
}
}
#line 63 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GMainLoop(GList **_l ) 
{ 


  {
  {
#line 63
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_main_loop_unref)));
  }
  return;
}
}
#line 63 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GMainLoop(GSList **_l ) 
{ 


  {
  {
#line 63
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_main_loop_unref)));
  }
  return;
}
}
#line 63 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GMainLoop(GQueue **_q ) 
{ 


  {
#line 63
  if (*_q) {
    {
#line 63
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_main_loop_unref)));
    }
  }
  return;
}
}
#line 64 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GSource(GSource *_ptr ) 
{ 


  {
#line 64
  if (_ptr) {
    {
#line 64
    g_source_unref((GSource *)_ptr);
    }
  }
  return;
}
}
#line 64 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GSource(GSource **_ptr ) 
{ 


  {
  {
#line 64
  glib_autoptr_clear_GSource(*_ptr);
  }
  return;
}
}
#line 64 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GSource(GList **_l ) 
{ 


  {
  {
#line 64
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_source_unref)));
  }
  return;
}
}
#line 64 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GSource(GSList **_l ) 
{ 


  {
  {
#line 64
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_source_unref)));
  }
  return;
}
}
#line 64 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GSource(GQueue **_q ) 
{ 


  {
#line 64
  if (*_q) {
    {
#line 64
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_source_unref)));
    }
  }
  return;
}
}
#line 65 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GMappedFile(GMappedFile *_ptr ) 
{ 


  {
#line 65
  if (_ptr) {
    {
#line 65
    g_mapped_file_unref((GMappedFile *)_ptr);
    }
  }
  return;
}
}
#line 65 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GMappedFile(GMappedFile **_ptr ) 
{ 


  {
  {
#line 65
  glib_autoptr_clear_GMappedFile(*_ptr);
  }
  return;
}
}
#line 65 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GMappedFile(GList **_l ) 
{ 


  {
  {
#line 65
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_mapped_file_unref)));
  }
  return;
}
}
#line 65 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GMappedFile(GSList **_l ) 
{ 


  {
  {
#line 65
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_mapped_file_unref)));
  }
  return;
}
}
#line 65 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GMappedFile(GQueue **_q ) 
{ 


  {
#line 65
  if (*_q) {
    {
#line 65
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_mapped_file_unref)));
    }
  }
  return;
}
}
#line 66 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GMarkupParseContext(GMarkupParseContext *_ptr ) 
{ 


  {
#line 66
  if (_ptr) {
    {
#line 66
    g_markup_parse_context_unref((GMarkupParseContext *)_ptr);
    }
  }
  return;
}
}
#line 66 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GMarkupParseContext(GMarkupParseContext **_ptr ) 
{ 


  {
  {
#line 66
  glib_autoptr_clear_GMarkupParseContext(*_ptr);
  }
  return;
}
}
#line 66 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GMarkupParseContext(GList **_l ) 
{ 


  {
  {
#line 66
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_markup_parse_context_unref)));
  }
  return;
}
}
#line 66 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GMarkupParseContext(GSList **_l ) 
{ 


  {
  {
#line 66
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_markup_parse_context_unref)));
  }
  return;
}
}
#line 66 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GMarkupParseContext(GQueue **_q ) 
{ 


  {
#line 66
  if (*_q) {
    {
#line 66
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_markup_parse_context_unref)));
    }
  }
  return;
}
}
#line 67 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GNode(GNode *_ptr ) 
{ 


  {
#line 67
  if (_ptr) {
    {
#line 67
    g_node_destroy((GNode *)_ptr);
    }
  }
  return;
}
}
#line 67 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GNode(GNode **_ptr ) 
{ 


  {
  {
#line 67
  glib_autoptr_clear_GNode(*_ptr);
  }
  return;
}
}
#line 67 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GNode(GList **_l ) 
{ 


  {
  {
#line 67
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_node_destroy)));
  }
  return;
}
}
#line 67 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GNode(GSList **_l ) 
{ 


  {
  {
#line 67
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_node_destroy)));
  }
  return;
}
}
#line 67 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GNode(GQueue **_q ) 
{ 


  {
#line 67
  if (*_q) {
    {
#line 67
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_node_destroy)));
    }
  }
  return;
}
}
#line 68 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GOptionContext(GOptionContext *_ptr ) 
{ 


  {
#line 68
  if (_ptr) {
    {
#line 68
    g_option_context_free((GOptionContext *)_ptr);
    }
  }
  return;
}
}
#line 68 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GOptionContext(GOptionContext **_ptr ) 
{ 


  {
  {
#line 68
  glib_autoptr_clear_GOptionContext(*_ptr);
  }
  return;
}
}
#line 68 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GOptionContext(GList **_l ) 
{ 


  {
  {
#line 68
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_option_context_free)));
  }
  return;
}
}
#line 68 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GOptionContext(GSList **_l ) 
{ 


  {
  {
#line 68
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_option_context_free)));
  }
  return;
}
}
#line 68 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GOptionContext(GQueue **_q ) 
{ 


  {
#line 68
  if (*_q) {
    {
#line 68
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_option_context_free)));
    }
  }
  return;
}
}
#line 69 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GOptionGroup(GOptionGroup *_ptr ) 
{ 


  {
#line 69
  if (_ptr) {
    {
#line 69
    g_option_group_unref((GOptionGroup *)_ptr);
    }
  }
  return;
}
}
#line 69 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GOptionGroup(GOptionGroup **_ptr ) 
{ 


  {
  {
#line 69
  glib_autoptr_clear_GOptionGroup(*_ptr);
  }
  return;
}
}
#line 69 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GOptionGroup(GList **_l ) 
{ 


  {
  {
#line 69
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_option_group_unref)));
  }
  return;
}
}
#line 69 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GOptionGroup(GSList **_l ) 
{ 


  {
  {
#line 69
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_option_group_unref)));
  }
  return;
}
}
#line 69 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GOptionGroup(GQueue **_q ) 
{ 


  {
#line 69
  if (*_q) {
    {
#line 69
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_option_group_unref)));
    }
  }
  return;
}
}
#line 70 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GPatternSpec(GPatternSpec *_ptr ) 
{ 


  {
#line 70
  if (_ptr) {
    {
#line 70
    g_pattern_spec_free((GPatternSpec *)_ptr);
    }
  }
  return;
}
}
#line 70 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GPatternSpec(GPatternSpec **_ptr ) 
{ 


  {
  {
#line 70
  glib_autoptr_clear_GPatternSpec(*_ptr);
  }
  return;
}
}
#line 70 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GPatternSpec(GList **_l ) 
{ 


  {
  {
#line 70
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_pattern_spec_free)));
  }
  return;
}
}
#line 70 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GPatternSpec(GSList **_l ) 
{ 


  {
  {
#line 70
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_pattern_spec_free)));
  }
  return;
}
}
#line 70 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GPatternSpec(GQueue **_q ) 
{ 


  {
#line 70
  if (*_q) {
    {
#line 70
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_pattern_spec_free)));
    }
  }
  return;
}
}
#line 71 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GQueue(GQueue *_ptr ) 
{ 


  {
#line 71
  if (_ptr) {
    {
#line 71
    g_queue_free((GQueue *)_ptr);
    }
  }
  return;
}
}
#line 71 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GQueue(GQueue **_ptr ) 
{ 


  {
  {
#line 71
  glib_autoptr_clear_GQueue(*_ptr);
  }
  return;
}
}
#line 71 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GQueue(GList **_l ) 
{ 


  {
  {
#line 71
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_queue_free)));
  }
  return;
}
}
#line 71 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GQueue(GSList **_l ) 
{ 


  {
  {
#line 71
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_queue_free)));
  }
  return;
}
}
#line 71 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GQueue(GQueue **_q ) 
{ 


  {
#line 71
  if (*_q) {
    {
#line 71
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_queue_free)));
    }
  }
  return;
}
}
#line 72 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_auto_cleanup_GQueue(GQueue *_ptr ) 
{ 


  {
  {
#line 72
  g_queue_clear(_ptr);
  }
  return;
}
}
#line 73 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GRand(GRand *_ptr ) 
{ 


  {
#line 73
  if (_ptr) {
    {
#line 73
    g_rand_free((GRand *)_ptr);
    }
  }
  return;
}
}
#line 73 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GRand(GRand **_ptr ) 
{ 


  {
  {
#line 73
  glib_autoptr_clear_GRand(*_ptr);
  }
  return;
}
}
#line 73 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GRand(GList **_l ) 
{ 


  {
  {
#line 73
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_rand_free)));
  }
  return;
}
}
#line 73 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GRand(GSList **_l ) 
{ 


  {
  {
#line 73
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_rand_free)));
  }
  return;
}
}
#line 73 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GRand(GQueue **_q ) 
{ 


  {
#line 73
  if (*_q) {
    {
#line 73
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_rand_free)));
    }
  }
  return;
}
}
#line 74 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GRegex(GRegex *_ptr ) 
{ 


  {
#line 74
  if (_ptr) {
    {
#line 74
    g_regex_unref((GRegex *)_ptr);
    }
  }
  return;
}
}
#line 74 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GRegex(GRegex **_ptr ) 
{ 


  {
  {
#line 74
  glib_autoptr_clear_GRegex(*_ptr);
  }
  return;
}
}
#line 74 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GRegex(GList **_l ) 
{ 


  {
  {
#line 74
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_regex_unref)));
  }
  return;
}
}
#line 74 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GRegex(GSList **_l ) 
{ 


  {
  {
#line 74
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_regex_unref)));
  }
  return;
}
}
#line 74 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GRegex(GQueue **_q ) 
{ 


  {
#line 74
  if (*_q) {
    {
#line 74
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_regex_unref)));
    }
  }
  return;
}
}
#line 75 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GMatchInfo(GMatchInfo *_ptr ) 
{ 


  {
#line 75
  if (_ptr) {
    {
#line 75
    g_match_info_unref((GMatchInfo *)_ptr);
    }
  }
  return;
}
}
#line 75 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GMatchInfo(GMatchInfo **_ptr ) 
{ 


  {
  {
#line 75
  glib_autoptr_clear_GMatchInfo(*_ptr);
  }
  return;
}
}
#line 75 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GMatchInfo(GList **_l ) 
{ 


  {
  {
#line 75
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_match_info_unref)));
  }
  return;
}
}
#line 75 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GMatchInfo(GSList **_l ) 
{ 


  {
  {
#line 75
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_match_info_unref)));
  }
  return;
}
}
#line 75 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GMatchInfo(GQueue **_q ) 
{ 


  {
#line 75
  if (*_q) {
    {
#line 75
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_match_info_unref)));
    }
  }
  return;
}
}
#line 76 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GScanner(GScanner *_ptr ) 
{ 


  {
#line 76
  if (_ptr) {
    {
#line 76
    g_scanner_destroy((GScanner *)_ptr);
    }
  }
  return;
}
}
#line 76 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GScanner(GScanner **_ptr ) 
{ 


  {
  {
#line 76
  glib_autoptr_clear_GScanner(*_ptr);
  }
  return;
}
}
#line 76 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GScanner(GList **_l ) 
{ 


  {
  {
#line 76
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_scanner_destroy)));
  }
  return;
}
}
#line 76 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GScanner(GSList **_l ) 
{ 


  {
  {
#line 76
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_scanner_destroy)));
  }
  return;
}
}
#line 76 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GScanner(GQueue **_q ) 
{ 


  {
#line 76
  if (*_q) {
    {
#line 76
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_scanner_destroy)));
    }
  }
  return;
}
}
#line 77 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GSequence(GSequence *_ptr ) 
{ 


  {
#line 77
  if (_ptr) {
    {
#line 77
    g_sequence_free((GSequence *)_ptr);
    }
  }
  return;
}
}
#line 77 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GSequence(GSequence **_ptr ) 
{ 


  {
  {
#line 77
  glib_autoptr_clear_GSequence(*_ptr);
  }
  return;
}
}
#line 77 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GSequence(GList **_l ) 
{ 


  {
  {
#line 77
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_sequence_free)));
  }
  return;
}
}
#line 77 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GSequence(GSList **_l ) 
{ 


  {
  {
#line 77
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_sequence_free)));
  }
  return;
}
}
#line 77 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GSequence(GQueue **_q ) 
{ 


  {
#line 77
  if (*_q) {
    {
#line 77
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_sequence_free)));
    }
  }
  return;
}
}
#line 78 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GSList(GSList *_ptr ) 
{ 


  {
#line 78
  if (_ptr) {
    {
#line 78
    g_slist_free((GSList *)_ptr);
    }
  }
  return;
}
}
#line 78 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GSList(GSList **_ptr ) 
{ 


  {
  {
#line 78
  glib_autoptr_clear_GSList(*_ptr);
  }
  return;
}
}
#line 78 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GSList(GList **_l ) 
{ 


  {
  {
#line 78
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_slist_free)));
  }
  return;
}
}
#line 78 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GSList(GSList **_l ) 
{ 


  {
  {
#line 78
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_slist_free)));
  }
  return;
}
}
#line 78 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GSList(GQueue **_q ) 
{ 


  {
#line 78
  if (*_q) {
    {
#line 78
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_slist_free)));
    }
  }
  return;
}
}
#line 79 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GString(GString *_ptr ) 
{ 


  {
#line 79
  if (_ptr) {
    {
#line 79
    g_autoptr_cleanup_gstring_free((GString *)_ptr);
    }
  }
  return;
}
}
#line 79 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GString(GString **_ptr ) 
{ 


  {
  {
#line 79
  glib_autoptr_clear_GString(*_ptr);
  }
  return;
}
}
#line 79 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GString(GList **_l ) 
{ 


  {
  {
#line 79
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_autoptr_cleanup_gstring_free)));
  }
  return;
}
}
#line 79 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GString(GSList **_l ) 
{ 


  {
  {
#line 79
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_autoptr_cleanup_gstring_free)));
  }
  return;
}
}
#line 79 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GString(GQueue **_q ) 
{ 


  {
#line 79
  if (*_q) {
    {
#line 79
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_autoptr_cleanup_gstring_free)));
    }
  }
  return;
}
}
#line 80 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GStringChunk(GStringChunk *_ptr ) 
{ 


  {
#line 80
  if (_ptr) {
    {
#line 80
    g_string_chunk_free((GStringChunk *)_ptr);
    }
  }
  return;
}
}
#line 80 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GStringChunk(GStringChunk **_ptr ) 
{ 


  {
  {
#line 80
  glib_autoptr_clear_GStringChunk(*_ptr);
  }
  return;
}
}
#line 80 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GStringChunk(GList **_l ) 
{ 


  {
  {
#line 80
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_string_chunk_free)));
  }
  return;
}
}
#line 80 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GStringChunk(GSList **_l ) 
{ 


  {
  {
#line 80
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_string_chunk_free)));
  }
  return;
}
}
#line 80 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GStringChunk(GQueue **_q ) 
{ 


  {
#line 80
  if (*_q) {
    {
#line 80
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_string_chunk_free)));
    }
  }
  return;
}
}
#line 81 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GStrvBuilder(GStrvBuilder *_ptr ) 
{ 


  {
#line 81
  if (_ptr) {
    {
#line 81
    g_strv_builder_unref((GStrvBuilder *)_ptr);
    }
  }
  return;
}
}
#line 81 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GStrvBuilder(GStrvBuilder **_ptr ) 
{ 


  {
  {
#line 81
  glib_autoptr_clear_GStrvBuilder(*_ptr);
  }
  return;
}
}
#line 81 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GStrvBuilder(GList **_l ) 
{ 


  {
  {
#line 81
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_strv_builder_unref)));
  }
  return;
}
}
#line 81 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GStrvBuilder(GSList **_l ) 
{ 


  {
  {
#line 81
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_strv_builder_unref)));
  }
  return;
}
}
#line 81 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GStrvBuilder(GQueue **_q ) 
{ 


  {
#line 81
  if (*_q) {
    {
#line 81
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_strv_builder_unref)));
    }
  }
  return;
}
}
#line 82 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GThread(GThread *_ptr ) 
{ 


  {
#line 82
  if (_ptr) {
    {
#line 82
    g_thread_unref((GThread *)_ptr);
    }
  }
  return;
}
}
#line 82 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GThread(GThread **_ptr ) 
{ 


  {
  {
#line 82
  glib_autoptr_clear_GThread(*_ptr);
  }
  return;
}
}
#line 82 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GThread(GList **_l ) 
{ 


  {
  {
#line 82
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_thread_unref)));
  }
  return;
}
}
#line 82 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GThread(GSList **_l ) 
{ 


  {
  {
#line 82
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_thread_unref)));
  }
  return;
}
}
#line 82 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GThread(GQueue **_q ) 
{ 


  {
#line 82
  if (*_q) {
    {
#line 82
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_thread_unref)));
    }
  }
  return;
}
}
#line 83 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_auto_cleanup_GMutex(GMutex *_ptr ) 
{ 


  {
  {
#line 83
  g_mutex_clear(_ptr);
  }
  return;
}
}
#line 84 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GMutexLocker(GMutexLocker *_ptr ) 
{ 


  {
#line 84
  if (_ptr) {
    {
#line 84
    g_mutex_locker_free((GMutexLocker *)_ptr);
    }
  }
  return;
}
}
#line 84 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GMutexLocker(GMutexLocker **_ptr ) 
{ 


  {
  {
#line 84
  glib_autoptr_clear_GMutexLocker(*_ptr);
  }
  return;
}
}
#line 84 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GMutexLocker(GList **_l ) 
{ 


  {
  {
#line 84
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_mutex_locker_free)));
  }
  return;
}
}
#line 84 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GMutexLocker(GSList **_l ) 
{ 


  {
  {
#line 84
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_mutex_locker_free)));
  }
  return;
}
}
#line 84 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GMutexLocker(GQueue **_q ) 
{ 


  {
#line 84
  if (*_q) {
    {
#line 84
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_mutex_locker_free)));
    }
  }
  return;
}
}
#line 85 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GRecMutexLocker(GRecMutexLocker *_ptr ) 
{ 


  {
#line 85
  if (_ptr) {
    {
#line 85
    g_rec_mutex_locker_free((GRecMutexLocker *)_ptr);
    }
  }
  return;
}
}
#line 85 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GRecMutexLocker(GRecMutexLocker **_ptr ) 
{ 


  {
  {
#line 85
  glib_autoptr_clear_GRecMutexLocker(*_ptr);
  }
  return;
}
}
#line 85 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GRecMutexLocker(GList **_l ) 
{ 


  {
  {
#line 85
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_rec_mutex_locker_free)));
  }
  return;
}
}
#line 85 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GRecMutexLocker(GSList **_l ) 
{ 


  {
  {
#line 85
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_rec_mutex_locker_free)));
  }
  return;
}
}
#line 85 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GRecMutexLocker(GQueue **_q ) 
{ 


  {
#line 85
  if (*_q) {
    {
#line 85
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_rec_mutex_locker_free)));
    }
  }
  return;
}
}
#line 86 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GRWLockWriterLocker(GRWLockWriterLocker *_ptr ) 
{ 


  {
#line 86
  if (_ptr) {
    {
#line 86
    g_rw_lock_writer_locker_free((GRWLockWriterLocker *)_ptr);
    }
  }
  return;
}
}
#line 86 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GRWLockWriterLocker(GRWLockWriterLocker **_ptr ) 
{ 


  {
  {
#line 86
  glib_autoptr_clear_GRWLockWriterLocker(*_ptr);
  }
  return;
}
}
#line 86 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GRWLockWriterLocker(GList **_l ) 
{ 


  {
  {
#line 86
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_rw_lock_writer_locker_free)));
  }
  return;
}
}
#line 86 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GRWLockWriterLocker(GSList **_l ) 
{ 


  {
  {
#line 86
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_rw_lock_writer_locker_free)));
  }
  return;
}
}
#line 86 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GRWLockWriterLocker(GQueue **_q ) 
{ 


  {
#line 86
  if (*_q) {
    {
#line 86
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_rw_lock_writer_locker_free)));
    }
  }
  return;
}
}
#line 87 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GRWLockReaderLocker(GRWLockReaderLocker *_ptr ) 
{ 


  {
#line 87
  if (_ptr) {
    {
#line 87
    g_rw_lock_reader_locker_free((GRWLockReaderLocker *)_ptr);
    }
  }
  return;
}
}
#line 87 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GRWLockReaderLocker(GRWLockReaderLocker **_ptr ) 
{ 


  {
  {
#line 87
  glib_autoptr_clear_GRWLockReaderLocker(*_ptr);
  }
  return;
}
}
#line 87 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GRWLockReaderLocker(GList **_l ) 
{ 


  {
  {
#line 87
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_rw_lock_reader_locker_free)));
  }
  return;
}
}
#line 87 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GRWLockReaderLocker(GSList **_l ) 
{ 


  {
  {
#line 87
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_rw_lock_reader_locker_free)));
  }
  return;
}
}
#line 87 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GRWLockReaderLocker(GQueue **_q ) 
{ 


  {
#line 87
  if (*_q) {
    {
#line 87
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_rw_lock_reader_locker_free)));
    }
  }
  return;
}
}
#line 88 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_auto_cleanup_GCond(GCond *_ptr ) 
{ 


  {
  {
#line 88
  g_cond_clear(_ptr);
  }
  return;
}
}
#line 89 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GTimer(GTimer *_ptr ) 
{ 


  {
#line 89
  if (_ptr) {
    {
#line 89
    g_timer_destroy((GTimer *)_ptr);
    }
  }
  return;
}
}
#line 89 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GTimer(GTimer **_ptr ) 
{ 


  {
  {
#line 89
  glib_autoptr_clear_GTimer(*_ptr);
  }
  return;
}
}
#line 89 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GTimer(GList **_l ) 
{ 


  {
  {
#line 89
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_timer_destroy)));
  }
  return;
}
}
#line 89 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GTimer(GSList **_l ) 
{ 


  {
  {
#line 89
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_timer_destroy)));
  }
  return;
}
}
#line 89 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GTimer(GQueue **_q ) 
{ 


  {
#line 89
  if (*_q) {
    {
#line 89
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_timer_destroy)));
    }
  }
  return;
}
}
#line 90 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GTimeZone(GTimeZone *_ptr ) 
{ 


  {
#line 90
  if (_ptr) {
    {
#line 90
    g_time_zone_unref((GTimeZone *)_ptr);
    }
  }
  return;
}
}
#line 90 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GTimeZone(GTimeZone **_ptr ) 
{ 


  {
  {
#line 90
  glib_autoptr_clear_GTimeZone(*_ptr);
  }
  return;
}
}
#line 90 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GTimeZone(GList **_l ) 
{ 


  {
  {
#line 90
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_time_zone_unref)));
  }
  return;
}
}
#line 90 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GTimeZone(GSList **_l ) 
{ 


  {
  {
#line 90
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_time_zone_unref)));
  }
  return;
}
}
#line 90 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GTimeZone(GQueue **_q ) 
{ 


  {
#line 90
  if (*_q) {
    {
#line 90
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_time_zone_unref)));
    }
  }
  return;
}
}
#line 91 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GTree(GTree *_ptr ) 
{ 


  {
#line 91
  if (_ptr) {
    {
#line 91
    g_tree_unref((GTree *)_ptr);
    }
  }
  return;
}
}
#line 91 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GTree(GTree **_ptr ) 
{ 


  {
  {
#line 91
  glib_autoptr_clear_GTree(*_ptr);
  }
  return;
}
}
#line 91 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GTree(GList **_l ) 
{ 


  {
  {
#line 91
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_tree_unref)));
  }
  return;
}
}
#line 91 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GTree(GSList **_l ) 
{ 


  {
  {
#line 91
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_tree_unref)));
  }
  return;
}
}
#line 91 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GTree(GQueue **_q ) 
{ 


  {
#line 91
  if (*_q) {
    {
#line 91
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_tree_unref)));
    }
  }
  return;
}
}
#line 92 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GVariant(GVariant *_ptr ) 
{ 


  {
#line 92
  if (_ptr) {
    {
#line 92
    g_variant_unref((GVariant *)_ptr);
    }
  }
  return;
}
}
#line 92 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GVariant(GVariant **_ptr ) 
{ 


  {
  {
#line 92
  glib_autoptr_clear_GVariant(*_ptr);
  }
  return;
}
}
#line 92 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GVariant(GList **_l ) 
{ 


  {
  {
#line 92
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_variant_unref)));
  }
  return;
}
}
#line 92 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GVariant(GSList **_l ) 
{ 


  {
  {
#line 92
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_variant_unref)));
  }
  return;
}
}
#line 92 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GVariant(GQueue **_q ) 
{ 


  {
#line 92
  if (*_q) {
    {
#line 92
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_variant_unref)));
    }
  }
  return;
}
}
#line 93 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GVariantBuilder(GVariantBuilder *_ptr ) 
{ 


  {
#line 93
  if (_ptr) {
    {
#line 93
    g_variant_builder_unref((GVariantBuilder *)_ptr);
    }
  }
  return;
}
}
#line 93 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GVariantBuilder(GVariantBuilder **_ptr ) 
{ 


  {
  {
#line 93
  glib_autoptr_clear_GVariantBuilder(*_ptr);
  }
  return;
}
}
#line 93 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GVariantBuilder(GList **_l ) 
{ 


  {
  {
#line 93
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_variant_builder_unref)));
  }
  return;
}
}
#line 93 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GVariantBuilder(GSList **_l ) 
{ 


  {
  {
#line 93
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_variant_builder_unref)));
  }
  return;
}
}
#line 93 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GVariantBuilder(GQueue **_q ) 
{ 


  {
#line 93
  if (*_q) {
    {
#line 93
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_variant_builder_unref)));
    }
  }
  return;
}
}
#line 94 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_auto_cleanup_GVariantBuilder(GVariantBuilder *_ptr ) 
{ 


  {
  {
#line 94
  g_variant_builder_clear(_ptr);
  }
  return;
}
}
#line 95 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GVariantIter(GVariantIter *_ptr ) 
{ 


  {
#line 95
  if (_ptr) {
    {
#line 95
    g_variant_iter_free((GVariantIter *)_ptr);
    }
  }
  return;
}
}
#line 95 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GVariantIter(GVariantIter **_ptr ) 
{ 


  {
  {
#line 95
  glib_autoptr_clear_GVariantIter(*_ptr);
  }
  return;
}
}
#line 95 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GVariantIter(GList **_l ) 
{ 


  {
  {
#line 95
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_variant_iter_free)));
  }
  return;
}
}
#line 95 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GVariantIter(GSList **_l ) 
{ 


  {
  {
#line 95
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_variant_iter_free)));
  }
  return;
}
}
#line 95 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GVariantIter(GQueue **_q ) 
{ 


  {
#line 95
  if (*_q) {
    {
#line 95
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_variant_iter_free)));
    }
  }
  return;
}
}
#line 96 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GVariantDict(GVariantDict *_ptr ) 
{ 


  {
#line 96
  if (_ptr) {
    {
#line 96
    g_variant_dict_unref((GVariantDict *)_ptr);
    }
  }
  return;
}
}
#line 96 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GVariantDict(GVariantDict **_ptr ) 
{ 


  {
  {
#line 96
  glib_autoptr_clear_GVariantDict(*_ptr);
  }
  return;
}
}
#line 96 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GVariantDict(GList **_l ) 
{ 


  {
  {
#line 96
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_variant_dict_unref)));
  }
  return;
}
}
#line 96 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GVariantDict(GSList **_l ) 
{ 


  {
  {
#line 96
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_variant_dict_unref)));
  }
  return;
}
}
#line 96 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GVariantDict(GQueue **_q ) 
{ 


  {
#line 96
  if (*_q) {
    {
#line 96
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_variant_dict_unref)));
    }
  }
  return;
}
}
#line 97 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_auto_cleanup_GVariantDict(GVariantDict *_ptr ) 
{ 


  {
  {
#line 97
  g_variant_dict_clear(_ptr);
  }
  return;
}
}
#line 98 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GVariantType(GVariantType *_ptr ) 
{ 


  {
#line 98
  if (_ptr) {
    {
#line 98
    g_variant_type_free((GVariantType *)_ptr);
    }
  }
  return;
}
}
#line 98 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GVariantType(GVariantType **_ptr ) 
{ 


  {
  {
#line 98
  glib_autoptr_clear_GVariantType(*_ptr);
  }
  return;
}
}
#line 98 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GVariantType(GList **_l ) 
{ 


  {
  {
#line 98
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_variant_type_free)));
  }
  return;
}
}
#line 98 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GVariantType(GSList **_l ) 
{ 


  {
  {
#line 98
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_variant_type_free)));
  }
  return;
}
}
#line 98 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GVariantType(GQueue **_q ) 
{ 


  {
#line 98
  if (*_q) {
    {
#line 98
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_variant_type_free)));
    }
  }
  return;
}
}
#line 99 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_auto_cleanup_GStrv(GStrv *_ptr ) 
{ 


  {
#line 99
  if (*_ptr != (void *)0) {
    {
#line 99
    g_strfreev(*_ptr);
    }
  }
  return;
}
}
#line 100 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GRefString(GRefString *_ptr ) 
{ 


  {
#line 100
  if (_ptr) {
    {
#line 100
    g_ref_string_release((GRefString *)_ptr);
    }
  }
  return;
}
}
#line 100 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GRefString(GRefString **_ptr ) 
{ 


  {
  {
#line 100
  glib_autoptr_clear_GRefString(*_ptr);
  }
  return;
}
}
#line 100 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GRefString(GList **_l ) 
{ 


  {
  {
#line 100
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_ref_string_release)));
  }
  return;
}
}
#line 100 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GRefString(GSList **_l ) 
{ 


  {
  {
#line 100
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_ref_string_release)));
  }
  return;
}
}
#line 100 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GRefString(GQueue **_q ) 
{ 


  {
#line 100
  if (*_q) {
    {
#line 100
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_ref_string_release)));
    }
  }
  return;
}
}
#line 101 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GUri(GUri *_ptr ) 
{ 


  {
#line 101
  if (_ptr) {
    {
#line 101
    g_uri_unref((GUri *)_ptr);
    }
  }
  return;
}
}
#line 101 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GUri(GUri **_ptr ) 
{ 


  {
  {
#line 101
  glib_autoptr_clear_GUri(*_ptr);
  }
  return;
}
}
#line 101 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GUri(GList **_l ) 
{ 


  {
  {
#line 101
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_uri_unref)));
  }
  return;
}
}
#line 101 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GUri(GSList **_l ) 
{ 


  {
  {
#line 101
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_uri_unref)));
  }
  return;
}
}
#line 101 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GUri(GQueue **_q ) 
{ 


  {
#line 101
  if (*_q) {
    {
#line 101
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_uri_unref)));
    }
  }
  return;
}
}
#line 710 "/usr/include/glib-2.0/gobject/gtype.h"
extern void g_type_init(void) ;
#line 712
extern void g_type_init_with_debug_flags(GTypeDebugFlags debug_flags ) ;
#line 716
extern gchar *g_type_name(GType type ) ;
#line 718
extern GQuark g_type_qname(GType type ) ;
#line 720
extern GType g_type_from_name(gchar *name ) ;
#line 722
extern GType g_type_parent(GType type ) ;
#line 724
extern guint g_type_depth(GType type ) ;
#line 726
extern GType g_type_next_base(GType leaf_type , GType root_type ) ;
#line 729
extern gboolean g_type_is_a(GType type , GType is_a_type ) ;
#line 732
extern gpointer g_type_class_ref(GType type ) ;
#line 734
extern gpointer g_type_class_peek(GType type ) ;
#line 736
extern gpointer g_type_class_peek_static(GType type ) ;
#line 738
extern void g_type_class_unref(gpointer g_class ) ;
#line 740
extern gpointer g_type_class_peek_parent(gpointer g_class ) ;
#line 742
extern gpointer g_type_interface_peek(gpointer instance_class , GType iface_type ) ;
#line 745
extern gpointer g_type_interface_peek_parent(gpointer g_iface ) ;
#line 748
extern gpointer g_type_default_interface_ref(GType g_type ) ;
#line 750
extern gpointer g_type_default_interface_peek(GType g_type ) ;
#line 752
extern void g_type_default_interface_unref(gpointer g_iface ) ;
#line 756
extern GType *g_type_children(GType type , guint *n_children ) ;
#line 759
extern GType *g_type_interfaces(GType type , guint *n_interfaces ) ;
#line 764
extern void g_type_set_qdata(GType type , GQuark quark , gpointer data ) ;
#line 768
extern gpointer g_type_get_qdata(GType type , GQuark quark ) ;
#line 771
extern void g_type_query(GType type , GTypeQuery *query ) ;
#line 775
extern int g_type_get_instance_count(GType type ) ;
#line 1304
extern GType g_type_register_static(GType parent_type , gchar *type_name , GTypeInfo *info ,
                                    GTypeFlags flags ) ;
#line 1309
extern GType g_type_register_static_simple(GType parent_type , gchar *type_name ,
                                           guint class_size , GClassInitFunc class_init ,
                                           guint instance_size , GInstanceInitFunc instance_init ,
                                           GTypeFlags flags ) ;
#line 1318
extern GType g_type_register_dynamic(GType parent_type , gchar *type_name , GTypePlugin *plugin ,
                                     GTypeFlags flags ) ;
#line 1323
extern GType g_type_register_fundamental(GType type_id , gchar *type_name , GTypeInfo *info ,
                                         GTypeFundamentalInfo *finfo , GTypeFlags flags ) ;
#line 1329
extern void g_type_add_interface_static(GType instance_type , GType interface_type ,
                                        GInterfaceInfo *info ) ;
#line 1333
extern void g_type_add_interface_dynamic(GType instance_type , GType interface_type ,
                                         GTypePlugin *plugin ) ;
#line 1337
extern void g_type_interface_add_prerequisite(GType interface_type , GType prerequisite_type ) ;
#line 1340
extern GType *g_type_interface_prerequisites(GType interface_type , guint *n_prerequisites ) ;
#line 1343
extern GType g_type_interface_instantiatable_prerequisite(GType interface_type ) ;
#line 1346
extern void g_type_class_add_private(gpointer g_class , gsize private_size ) ;
#line 1349
extern gint g_type_add_instance_private(GType class_type , gsize private_size ) ;
#line 1352
extern gpointer g_type_instance_get_private(GTypeInstance *instance , GType private_type ) ;
#line 1355
extern void g_type_class_adjust_private_offset(gpointer g_class , gint *private_size_or_offset ) ;
#line 1359
extern void g_type_add_class_private(GType class_type , gsize private_size ) ;
#line 1362
extern gpointer g_type_class_get_private(GTypeClass *klass , GType private_type ) ;
#line 1365
extern gint g_type_class_get_instance_private_offset(gpointer g_class ) ;
#line 1368
extern void g_type_ensure(GType type ) ;
#line 1370
extern guint g_type_get_type_registration_serial(void) ;
#line 2385
extern GTypePlugin *g_type_get_plugin(GType type ) ;
#line 2387
extern GTypePlugin *g_type_interface_get_plugin(GType instance_type , GType interface_type ) ;
#line 2390
extern GType g_type_fundamental_next(void) ;
#line 2392
extern GType g_type_fundamental(GType type_id ) ;
#line 2394
extern GTypeInstance *g_type_create_instance(GType type ) ;
#line 2396
extern void g_type_free_instance(GTypeInstance *instance ) ;
#line 2399
extern void g_type_add_class_cache_func(gpointer cache_data , GTypeClassCacheFunc cache_func ) ;
#line 2402
extern void g_type_remove_class_cache_func(gpointer cache_data , GTypeClassCacheFunc cache_func ) ;
#line 2405
extern void g_type_class_unref_uncached(gpointer g_class ) ;
#line 2408
extern void g_type_add_interface_check(gpointer check_data , GTypeInterfaceCheckFunc check_func ) ;
#line 2411
extern void g_type_remove_interface_check(gpointer check_data , GTypeInterfaceCheckFunc check_func ) ;
#line 2415
extern GTypeValueTable *g_type_value_table_peek(GType type ) ;
#line 2420
extern gboolean g_type_check_instance(GTypeInstance *instance ) ;
#line 2422
extern GTypeInstance *g_type_check_instance_cast(GTypeInstance *instance , GType iface_type ) ;
#line 2425
extern gboolean g_type_check_instance_is_a(GTypeInstance *instance , GType iface_type ) ;
#line 2428
extern gboolean g_type_check_instance_is_fundamentally_a(GTypeInstance *instance ,
                                                         GType fundamental_type ) ;
#line 2431
extern GTypeClass *g_type_check_class_cast(GTypeClass *g_class , GType is_a_type ) ;
#line 2434
extern gboolean g_type_check_class_is_a(GTypeClass *g_class , GType is_a_type ) ;
#line 2437
extern gboolean g_type_check_is_value_type(GType type ) ;
#line 2439
extern gboolean g_type_check_value(GValue *value ) ;
#line 2441
extern gboolean g_type_check_value_holds(GValue *value , GType type ) ;
#line 2444
extern gboolean g_type_test_flags(GType type , guint flags ) ;
#line 2450
extern gchar *g_type_name_from_instance(GTypeInstance *instance ) ;
#line 2452
extern gchar *g_type_name_from_class(GTypeClass *g_class ) ;
#line 133 "/usr/include/glib-2.0/gobject/gvalue.h"
extern GValue *g_value_init(GValue *value , GType g_type ) ;
#line 136
extern void g_value_copy(GValue *src_value , GValue *dest_value ) ;
#line 139
extern GValue *g_value_reset(GValue *value ) ;
#line 141
extern void g_value_unset(GValue *value ) ;
#line 143
extern void g_value_set_instance(GValue *value , gpointer instance ) ;
#line 146
extern void g_value_init_from_instance(GValue *value , gpointer instance ) ;
#line 152
extern gboolean g_value_fits_pointer(GValue *value ) ;
#line 154
extern gpointer g_value_peek_pointer(GValue *value ) ;
#line 159
extern gboolean g_value_type_compatible(GType src_type , GType dest_type ) ;
#line 162
extern gboolean g_value_type_transformable(GType src_type , GType dest_type ) ;
#line 165
extern gboolean g_value_transform(GValue *src_value , GValue *dest_value ) ;
#line 168
extern void g_value_register_transform_func(GType src_type , GType dest_type , GValueTransform transform_func ) ;
#line 282 "/usr/include/glib-2.0/gobject/gparam.h"
extern GParamSpec *g_param_spec_ref(GParamSpec *pspec ) ;
#line 284
extern void g_param_spec_unref(GParamSpec *pspec ) ;
#line 286
extern void g_param_spec_sink(GParamSpec *pspec ) ;
#line 288
extern GParamSpec *g_param_spec_ref_sink(GParamSpec *pspec ) ;
#line 290
extern gpointer g_param_spec_get_qdata(GParamSpec *pspec , GQuark quark ) ;
#line 293
extern void g_param_spec_set_qdata(GParamSpec *pspec , GQuark quark , gpointer data ) ;
#line 297
extern void g_param_spec_set_qdata_full(GParamSpec *pspec , GQuark quark , gpointer data ,
                                        GDestroyNotify destroy ) ;
#line 302
extern gpointer g_param_spec_steal_qdata(GParamSpec *pspec , GQuark quark ) ;
#line 305
extern GParamSpec *g_param_spec_get_redirect_target(GParamSpec *pspec ) ;
#line 308
extern void g_param_value_set_default(GParamSpec *pspec , GValue *value ) ;
#line 311
extern gboolean g_param_value_defaults(GParamSpec *pspec , GValue *value ) ;
#line 314
extern gboolean g_param_value_validate(GParamSpec *pspec , GValue *value ) ;
#line 317
extern gboolean g_param_value_convert(GParamSpec *pspec , GValue *src_value , GValue *dest_value ,
                                      gboolean strict_validation ) ;
#line 322
extern gint g_param_values_cmp(GParamSpec *pspec , GValue *value1 , GValue *value2 ) ;
#line 326
extern gchar *g_param_spec_get_name(GParamSpec *pspec ) ;
#line 328
extern gchar *g_param_spec_get_nick(GParamSpec *pspec ) ;
#line 330
extern gchar *g_param_spec_get_blurb(GParamSpec *pspec ) ;
#line 332
extern void g_value_set_param(GValue *value , GParamSpec *param ) ;
#line 335
extern GParamSpec *g_value_get_param(GValue *value ) ;
#line 337
extern GParamSpec *g_value_dup_param(GValue *value ) ;
#line 341
extern void g_value_take_param(GValue *value , GParamSpec *param ) ;
#line 344
extern void g_value_set_param_take_ownership(GValue *value , GParamSpec *param ) ;
#line 347
extern GValue *g_param_spec_get_default_value(GParamSpec *pspec ) ;
#line 350
extern GQuark g_param_spec_get_name_quark(GParamSpec *pspec ) ;
#line 398
extern GType g_param_type_register_static(gchar *name , GParamSpecTypeInfo *pspec_info ) ;
#line 402
extern gboolean g_param_spec_is_valid_name(gchar *name ) ;
#line 405
GType _g_param_type_register_static_constant(gchar *name , GParamSpecTypeInfo *pspec_info ,
                                             GType opt_type ) ;
#line 412
extern gpointer g_param_spec_internal(GType param_type , gchar *name , gchar *nick ,
                                      gchar *blurb , GParamFlags flags ) ;
#line 418
extern GParamSpecPool *g_param_spec_pool_new(gboolean type_prefixing ) ;
#line 420
extern void g_param_spec_pool_insert(GParamSpecPool *pool , GParamSpec *pspec , GType owner_type ) ;
#line 424
extern void g_param_spec_pool_remove(GParamSpecPool *pool , GParamSpec *pspec ) ;
#line 427
extern GParamSpec *g_param_spec_pool_lookup(GParamSpecPool *pool , gchar *param_name ,
                                            GType owner_type , gboolean walk_ancestors ) ;
#line 432
extern GList *g_param_spec_pool_list_owned(GParamSpecPool *pool , GType owner_type ) ;
#line 435
extern GParamSpec **g_param_spec_pool_list(GParamSpecPool *pool , GType owner_type ,
                                           guint *n_pspecs_p ) ;
#line 229 "/usr/include/glib-2.0/gobject/gclosure.h"
extern GClosure *g_cclosure_new(GCallback callback_func , gpointer user_data , GClosureNotify destroy_data ) ;
#line 233
extern GClosure *g_cclosure_new_swap(GCallback callback_func , gpointer user_data ,
                                     GClosureNotify destroy_data ) ;
#line 237
extern GClosure *g_signal_type_cclosure_new(GType itype , guint struct_offset ) ;
#line 243
extern GClosure *g_closure_ref(GClosure *closure ) ;
#line 245
extern void g_closure_sink(GClosure *closure ) ;
#line 247
extern void g_closure_unref(GClosure *closure ) ;
#line 250
extern GClosure *g_closure_new_simple(guint sizeof_closure , gpointer data ) ;
#line 253
extern void g_closure_add_finalize_notifier(GClosure *closure , gpointer notify_data ,
                                            GClosureNotify notify_func ) ;
#line 257
extern void g_closure_remove_finalize_notifier(GClosure *closure , gpointer notify_data ,
                                               GClosureNotify notify_func ) ;
#line 261
extern void g_closure_add_invalidate_notifier(GClosure *closure , gpointer notify_data ,
                                              GClosureNotify notify_func ) ;
#line 265
extern void g_closure_remove_invalidate_notifier(GClosure *closure , gpointer notify_data ,
                                                 GClosureNotify notify_func ) ;
#line 269
extern void g_closure_add_marshal_guards(GClosure *closure , gpointer pre_marshal_data ,
                                         GClosureNotify pre_marshal_notify , gpointer post_marshal_data ,
                                         GClosureNotify post_marshal_notify ) ;
#line 275
extern void g_closure_set_marshal(GClosure *closure , GClosureMarshal marshal ) ;
#line 278
extern void g_closure_set_meta_marshal(GClosure *closure , gpointer marshal_data ,
                                       GClosureMarshal meta_marshal ) ;
#line 282
extern void g_closure_invalidate(GClosure *closure ) ;
#line 284
extern void g_closure_invoke(GClosure *closure , GValue *return_value , guint n_param_values ,
                             GValue *param_values , gpointer invocation_hint ) ;
#line 302
extern void g_cclosure_marshal_generic(GClosure *closure , GValue *return_gvalue ,
                                       guint n_param_values , GValue *param_values ,
                                       gpointer invocation_hint , gpointer marshal_data ) ;
#line 310
extern void g_cclosure_marshal_generic_va(GClosure *closure , GValue *return_value ,
                                          gpointer instance , va_list args_list ,
                                          gpointer marshal_data , int n_params , GType *param_types ) ;
#line 24 "/usr/include/glib-2.0/gobject/gmarshal.h"
extern void g_cclosure_marshal_VOID__VOID(GClosure *closure , GValue *return_value ,
                                          guint n_param_values , GValue *param_values ,
                                          gpointer invocation_hint , gpointer marshal_data ) ;
#line 31
extern void g_cclosure_marshal_VOID__VOIDv(GClosure *closure , GValue *return_value ,
                                           gpointer instance , va_list args , gpointer marshal_data ,
                                           int n_params , GType *param_types ) ;
#line 41
extern void g_cclosure_marshal_VOID__BOOLEAN(GClosure *closure , GValue *return_value ,
                                             guint n_param_values , GValue *param_values ,
                                             gpointer invocation_hint , gpointer marshal_data ) ;
#line 48
extern void g_cclosure_marshal_VOID__BOOLEANv(GClosure *closure , GValue *return_value ,
                                              gpointer instance , va_list args , gpointer marshal_data ,
                                              int n_params , GType *param_types ) ;
#line 58
extern void g_cclosure_marshal_VOID__CHAR(GClosure *closure , GValue *return_value ,
                                          guint n_param_values , GValue *param_values ,
                                          gpointer invocation_hint , gpointer marshal_data ) ;
#line 65
extern void g_cclosure_marshal_VOID__CHARv(GClosure *closure , GValue *return_value ,
                                           gpointer instance , va_list args , gpointer marshal_data ,
                                           int n_params , GType *param_types ) ;
#line 75
extern void g_cclosure_marshal_VOID__UCHAR(GClosure *closure , GValue *return_value ,
                                           guint n_param_values , GValue *param_values ,
                                           gpointer invocation_hint , gpointer marshal_data ) ;
#line 82
extern void g_cclosure_marshal_VOID__UCHARv(GClosure *closure , GValue *return_value ,
                                            gpointer instance , va_list args , gpointer marshal_data ,
                                            int n_params , GType *param_types ) ;
#line 92
extern void g_cclosure_marshal_VOID__INT(GClosure *closure , GValue *return_value ,
                                         guint n_param_values , GValue *param_values ,
                                         gpointer invocation_hint , gpointer marshal_data ) ;
#line 99
extern void g_cclosure_marshal_VOID__INTv(GClosure *closure , GValue *return_value ,
                                          gpointer instance , va_list args , gpointer marshal_data ,
                                          int n_params , GType *param_types ) ;
#line 109
extern void g_cclosure_marshal_VOID__UINT(GClosure *closure , GValue *return_value ,
                                          guint n_param_values , GValue *param_values ,
                                          gpointer invocation_hint , gpointer marshal_data ) ;
#line 116
extern void g_cclosure_marshal_VOID__UINTv(GClosure *closure , GValue *return_value ,
                                           gpointer instance , va_list args , gpointer marshal_data ,
                                           int n_params , GType *param_types ) ;
#line 126
extern void g_cclosure_marshal_VOID__LONG(GClosure *closure , GValue *return_value ,
                                          guint n_param_values , GValue *param_values ,
                                          gpointer invocation_hint , gpointer marshal_data ) ;
#line 133
extern void g_cclosure_marshal_VOID__LONGv(GClosure *closure , GValue *return_value ,
                                           gpointer instance , va_list args , gpointer marshal_data ,
                                           int n_params , GType *param_types ) ;
#line 143
extern void g_cclosure_marshal_VOID__ULONG(GClosure *closure , GValue *return_value ,
                                           guint n_param_values , GValue *param_values ,
                                           gpointer invocation_hint , gpointer marshal_data ) ;
#line 150
extern void g_cclosure_marshal_VOID__ULONGv(GClosure *closure , GValue *return_value ,
                                            gpointer instance , va_list args , gpointer marshal_data ,
                                            int n_params , GType *param_types ) ;
#line 160
extern void g_cclosure_marshal_VOID__ENUM(GClosure *closure , GValue *return_value ,
                                          guint n_param_values , GValue *param_values ,
                                          gpointer invocation_hint , gpointer marshal_data ) ;
#line 167
extern void g_cclosure_marshal_VOID__ENUMv(GClosure *closure , GValue *return_value ,
                                           gpointer instance , va_list args , gpointer marshal_data ,
                                           int n_params , GType *param_types ) ;
#line 177
extern void g_cclosure_marshal_VOID__FLAGS(GClosure *closure , GValue *return_value ,
                                           guint n_param_values , GValue *param_values ,
                                           gpointer invocation_hint , gpointer marshal_data ) ;
#line 184
extern void g_cclosure_marshal_VOID__FLAGSv(GClosure *closure , GValue *return_value ,
                                            gpointer instance , va_list args , gpointer marshal_data ,
                                            int n_params , GType *param_types ) ;
#line 194
extern void g_cclosure_marshal_VOID__FLOAT(GClosure *closure , GValue *return_value ,
                                           guint n_param_values , GValue *param_values ,
                                           gpointer invocation_hint , gpointer marshal_data ) ;
#line 201
extern void g_cclosure_marshal_VOID__FLOATv(GClosure *closure , GValue *return_value ,
                                            gpointer instance , va_list args , gpointer marshal_data ,
                                            int n_params , GType *param_types ) ;
#line 211
extern void g_cclosure_marshal_VOID__DOUBLE(GClosure *closure , GValue *return_value ,
                                            guint n_param_values , GValue *param_values ,
                                            gpointer invocation_hint , gpointer marshal_data ) ;
#line 218
extern void g_cclosure_marshal_VOID__DOUBLEv(GClosure *closure , GValue *return_value ,
                                             gpointer instance , va_list args , gpointer marshal_data ,
                                             int n_params , GType *param_types ) ;
#line 228
extern void g_cclosure_marshal_VOID__STRING(GClosure *closure , GValue *return_value ,
                                            guint n_param_values , GValue *param_values ,
                                            gpointer invocation_hint , gpointer marshal_data ) ;
#line 235
extern void g_cclosure_marshal_VOID__STRINGv(GClosure *closure , GValue *return_value ,
                                             gpointer instance , va_list args , gpointer marshal_data ,
                                             int n_params , GType *param_types ) ;
#line 245
extern void g_cclosure_marshal_VOID__PARAM(GClosure *closure , GValue *return_value ,
                                           guint n_param_values , GValue *param_values ,
                                           gpointer invocation_hint , gpointer marshal_data ) ;
#line 252
extern void g_cclosure_marshal_VOID__PARAMv(GClosure *closure , GValue *return_value ,
                                            gpointer instance , va_list args , gpointer marshal_data ,
                                            int n_params , GType *param_types ) ;
#line 262
extern void g_cclosure_marshal_VOID__BOXED(GClosure *closure , GValue *return_value ,
                                           guint n_param_values , GValue *param_values ,
                                           gpointer invocation_hint , gpointer marshal_data ) ;
#line 269
extern void g_cclosure_marshal_VOID__BOXEDv(GClosure *closure , GValue *return_value ,
                                            gpointer instance , va_list args , gpointer marshal_data ,
                                            int n_params , GType *param_types ) ;
#line 279
extern void g_cclosure_marshal_VOID__POINTER(GClosure *closure , GValue *return_value ,
                                             guint n_param_values , GValue *param_values ,
                                             gpointer invocation_hint , gpointer marshal_data ) ;
#line 286
extern void g_cclosure_marshal_VOID__POINTERv(GClosure *closure , GValue *return_value ,
                                              gpointer instance , va_list args , gpointer marshal_data ,
                                              int n_params , GType *param_types ) ;
#line 296
extern void g_cclosure_marshal_VOID__OBJECT(GClosure *closure , GValue *return_value ,
                                            guint n_param_values , GValue *param_values ,
                                            gpointer invocation_hint , gpointer marshal_data ) ;
#line 303
extern void g_cclosure_marshal_VOID__OBJECTv(GClosure *closure , GValue *return_value ,
                                             gpointer instance , va_list args , gpointer marshal_data ,
                                             int n_params , GType *param_types ) ;
#line 313
extern void g_cclosure_marshal_VOID__VARIANT(GClosure *closure , GValue *return_value ,
                                             guint n_param_values , GValue *param_values ,
                                             gpointer invocation_hint , gpointer marshal_data ) ;
#line 320
extern void g_cclosure_marshal_VOID__VARIANTv(GClosure *closure , GValue *return_value ,
                                              gpointer instance , va_list args , gpointer marshal_data ,
                                              int n_params , GType *param_types ) ;
#line 330
extern void g_cclosure_marshal_VOID__UINT_POINTER(GClosure *closure , GValue *return_value ,
                                                  guint n_param_values , GValue *param_values ,
                                                  gpointer invocation_hint , gpointer marshal_data ) ;
#line 337
extern void g_cclosure_marshal_VOID__UINT_POINTERv(GClosure *closure , GValue *return_value ,
                                                   gpointer instance , va_list args ,
                                                   gpointer marshal_data , int n_params ,
                                                   GType *param_types ) ;
#line 347
extern void g_cclosure_marshal_BOOLEAN__FLAGS(GClosure *closure , GValue *return_value ,
                                              guint n_param_values , GValue *param_values ,
                                              gpointer invocation_hint , gpointer marshal_data ) ;
#line 354
extern void g_cclosure_marshal_BOOLEAN__FLAGSv(GClosure *closure , GValue *return_value ,
                                               gpointer instance , va_list args ,
                                               gpointer marshal_data , int n_params ,
                                               GType *param_types ) ;
#line 382
extern void g_cclosure_marshal_STRING__OBJECT_POINTER(GClosure *closure , GValue *return_value ,
                                                      guint n_param_values , GValue *param_values ,
                                                      gpointer invocation_hint , gpointer marshal_data ) ;
#line 389
extern void g_cclosure_marshal_STRING__OBJECT_POINTERv(GClosure *closure , GValue *return_value ,
                                                       gpointer instance , va_list args ,
                                                       gpointer marshal_data , int n_params ,
                                                       GType *param_types ) ;
#line 399
extern void g_cclosure_marshal_BOOLEAN__BOXED_BOXED(GClosure *closure , GValue *return_value ,
                                                    guint n_param_values , GValue *param_values ,
                                                    gpointer invocation_hint , gpointer marshal_data ) ;
#line 406
extern void g_cclosure_marshal_BOOLEAN__BOXED_BOXEDv(GClosure *closure , GValue *return_value ,
                                                     gpointer instance , va_list args ,
                                                     gpointer marshal_data , int n_params ,
                                                     GType *param_types ) ;
#line 277 "/usr/include/glib-2.0/gobject/gsignal.h"
extern guint g_signal_newv(gchar *signal_name , GType itype , GSignalFlags signal_flags ,
                           GClosure *class_closure , GSignalAccumulator accumulator ,
                           gpointer accu_data , GSignalCMarshaller c_marshaller ,
                           GType return_type , guint n_params , GType *param_types ) ;
#line 288
extern guint g_signal_new_valist(gchar *signal_name , GType itype , GSignalFlags signal_flags ,
                                 GClosure *class_closure , GSignalAccumulator accumulator ,
                                 gpointer accu_data , GSignalCMarshaller c_marshaller ,
                                 GType return_type , guint n_params , va_list args ) ;
#line 299
extern guint g_signal_new(gchar *signal_name , GType itype , GSignalFlags signal_flags ,
                          guint class_offset , GSignalAccumulator accumulator , gpointer accu_data ,
                          GSignalCMarshaller c_marshaller , GType return_type , guint n_params 
                          , ...) ;
#line 310
extern guint g_signal_new_class_handler(gchar *signal_name , GType itype , GSignalFlags signal_flags ,
                                        GCallback class_handler , GSignalAccumulator accumulator ,
                                        gpointer accu_data , GSignalCMarshaller c_marshaller ,
                                        GType return_type , guint n_params  , ...) ;
#line 321
extern void g_signal_set_va_marshaller(guint signal_id , GType instance_type , GSignalCVaMarshaller va_marshaller ) ;
#line 326
extern void g_signal_emitv(GValue *instance_and_params , guint signal_id , GQuark detail ,
                           GValue *return_value ) ;
#line 331
extern void g_signal_emit_valist(gpointer instance , guint signal_id , GQuark detail ,
                                 va_list var_args ) ;
#line 336
extern void g_signal_emit(gpointer instance , guint signal_id , GQuark detail  , ...) ;
#line 341
extern void g_signal_emit_by_name(gpointer instance , gchar *detailed_signal  , ...) ;
#line 345
extern guint g_signal_lookup(gchar *name , GType itype ) ;
#line 348
extern gchar *g_signal_name(guint signal_id ) ;
#line 350
extern void g_signal_query(guint signal_id , GSignalQuery *query ) ;
#line 353
extern guint *g_signal_list_ids(GType itype , guint *n_ids ) ;
#line 356
extern gboolean g_signal_is_valid_name(gchar *name ) ;
#line 358
extern gboolean g_signal_parse_name(gchar *detailed_signal , GType itype , guint *signal_id_p ,
                                    GQuark *detail_p , gboolean force_detail_quark ) ;
#line 364
extern GSignalInvocationHint *g_signal_get_invocation_hint(gpointer instance ) ;
#line 369
extern void g_signal_stop_emission(gpointer instance , guint signal_id , GQuark detail ) ;
#line 373
extern void g_signal_stop_emission_by_name(gpointer instance , gchar *detailed_signal ) ;
#line 376
extern gulong g_signal_add_emission_hook(guint signal_id , GQuark detail , GSignalEmissionHook hook_func ,
                                         gpointer hook_data , GDestroyNotify data_destroy ) ;
#line 382
extern void g_signal_remove_emission_hook(guint signal_id , gulong hook_id ) ;
#line 388
extern gboolean g_signal_has_handler_pending(gpointer instance , guint signal_id ,
                                             GQuark detail , gboolean may_be_blocked ) ;
#line 393
extern gulong g_signal_connect_closure_by_id(gpointer instance , guint signal_id ,
                                             GQuark detail , GClosure *closure , gboolean after ) ;
#line 399
extern gulong g_signal_connect_closure(gpointer instance , gchar *detailed_signal ,
                                       GClosure *closure , gboolean after ) ;
#line 404
extern gulong g_signal_connect_data(gpointer instance , gchar *detailed_signal , GCallback c_handler ,
                                    gpointer data , GClosureNotify destroy_data ,
                                    GConnectFlags connect_flags ) ;
#line 411
extern void g_signal_handler_block(gpointer instance , gulong handler_id ) ;
#line 414
extern void g_signal_handler_unblock(gpointer instance , gulong handler_id ) ;
#line 417
extern void g_signal_handler_disconnect(gpointer instance , gulong handler_id ) ;
#line 420
extern gboolean g_signal_handler_is_connected(gpointer instance , gulong handler_id ) ;
#line 423
extern gulong g_signal_handler_find(gpointer instance , GSignalMatchType mask , guint signal_id ,
                                    GQuark detail , GClosure *closure , gpointer func ,
                                    gpointer data ) ;
#line 431
extern guint g_signal_handlers_block_matched(gpointer instance , GSignalMatchType mask ,
                                             guint signal_id , GQuark detail , GClosure *closure ,
                                             gpointer func , gpointer data ) ;
#line 439
extern guint g_signal_handlers_unblock_matched(gpointer instance , GSignalMatchType mask ,
                                               guint signal_id , GQuark detail , GClosure *closure ,
                                               gpointer func , gpointer data ) ;
#line 447
extern guint g_signal_handlers_disconnect_matched(gpointer instance , GSignalMatchType mask ,
                                                  guint signal_id , GQuark detail ,
                                                  GClosure *closure , gpointer func ,
                                                  gpointer data ) ;
#line 456
extern void g_clear_signal_handler(gulong *handler_id_ptr , gpointer instance ) ;
#line 475
extern void g_signal_override_class_closure(guint signal_id , GType instance_type ,
                                            GClosure *class_closure ) ;
#line 479
extern void g_signal_override_class_handler(gchar *signal_name , GType instance_type ,
                                            GCallback class_handler ) ;
#line 483
extern void g_signal_chain_from_overridden(GValue *instance_and_params , GValue *return_value ) ;
#line 486
extern void g_signal_chain_from_overridden_handler(gpointer instance  , ...) ;
#line 622
extern gboolean g_signal_accumulator_true_handled(GSignalInvocationHint *ihint , GValue *return_accu ,
                                                  GValue *handler_return , gpointer dummy ) ;
#line 628
extern gboolean g_signal_accumulator_first_wins(GSignalInvocationHint *ihint , GValue *return_accu ,
                                                GValue *handler_return , gpointer dummy ) ;
#line 635
extern void g_signal_handlers_destroy(gpointer instance ) ;
#line 636
void _g_signals_destroy(GType itype ) ;
#line 328 "/usr/include/glib-2.0/gobject/glib-types.h"
extern GType g_date_get_type(void) ;
#line 330
extern GType g_strv_get_type(void) ;
#line 332
extern GType g_gstring_get_type(void) ;
#line 334
extern GType g_hash_table_get_type(void) ;
#line 336
extern GType g_array_get_type(void) ;
#line 338
extern GType g_byte_array_get_type(void) ;
#line 340
extern GType g_ptr_array_get_type(void) ;
#line 342
extern GType g_bytes_get_type(void) ;
#line 344
extern GType g_variant_type_get_gtype(void) ;
#line 346
extern GType g_regex_get_type(void) ;
#line 348
extern GType g_match_info_get_type(void) ;
#line 350
extern GType g_error_get_type(void) ;
#line 352
extern GType g_date_time_get_type(void) ;
#line 354
extern GType g_time_zone_get_type(void) ;
#line 356
extern GType g_io_channel_get_type(void) ;
#line 358
extern GType g_io_condition_get_type(void) ;
#line 360
extern GType g_variant_builder_get_type(void) ;
#line 362
extern GType g_variant_dict_get_type(void) ;
#line 364
extern GType g_key_file_get_type(void) ;
#line 366
extern GType g_main_loop_get_type(void) ;
#line 368
extern GType g_main_context_get_type(void) ;
#line 370
extern GType g_source_get_type(void) ;
#line 372
extern GType g_pollfd_get_type(void) ;
#line 374
extern GType g_thread_get_type(void) ;
#line 376
extern GType g_checksum_get_type(void) ;
#line 378
extern GType g_markup_parse_context_get_type(void) ;
#line 380
extern GType g_mapped_file_get_type(void) ;
#line 382
extern GType g_option_group_get_type(void) ;
#line 384
extern GType g_uri_get_type(void) ;
#line 386
extern GType g_tree_get_type(void) ;
#line 388
extern GType g_pattern_spec_get_type(void) ;
#line 391
extern GType g_variant_get_gtype(void) ;
#line 70 "/usr/include/glib-2.0/gobject/gboxed.h"
extern gpointer g_boxed_copy(GType boxed_type , gconstpointer src_boxed ) ;
#line 73
extern void g_boxed_free(GType boxed_type , gpointer boxed ) ;
#line 76
extern void g_value_set_boxed(GValue *value , gconstpointer v_boxed ) ;
#line 79
extern void g_value_set_static_boxed(GValue *value , gconstpointer v_boxed ) ;
#line 82
extern void g_value_take_boxed(GValue *value , gconstpointer v_boxed ) ;
#line 85
extern void g_value_set_boxed_take_ownership(GValue *value , gconstpointer v_boxed ) ;
#line 88
extern gpointer g_value_get_boxed(GValue *value ) ;
#line 90
extern gpointer g_value_dup_boxed(GValue *value ) ;
#line 95
extern GType g_boxed_type_register_static(gchar *name , GBoxedCopyFunc boxed_copy ,
                                          GBoxedFreeFunc boxed_free ) ;
#line 116
extern GType g_closure_get_type(void) ;
#line 118
extern GType g_value_get_type(void) ;
#line 407 "/usr/include/glib-2.0/gobject/gobject.h"
extern GType g_initially_unowned_get_type(void) ;
#line 409
extern void g_object_class_install_property(GObjectClass *oclass , guint property_id ,
                                            GParamSpec *pspec ) ;
#line 413
extern GParamSpec *g_object_class_find_property(GObjectClass *oclass , gchar *property_name ) ;
#line 416
extern GParamSpec **g_object_class_list_properties(GObjectClass *oclass , guint *n_properties ) ;
#line 419
extern void g_object_class_override_property(GObjectClass *oclass , guint property_id ,
                                             gchar *name ) ;
#line 423
extern void g_object_class_install_properties(GObjectClass *oclass , guint n_pspecs ,
                                              GParamSpec **pspecs ) ;
#line 428
extern void g_object_interface_install_property(gpointer g_iface , GParamSpec *pspec ) ;
#line 431
extern GParamSpec *g_object_interface_find_property(gpointer g_iface , gchar *property_name ) ;
#line 434
extern GParamSpec **g_object_interface_list_properties(gpointer g_iface , guint *n_properties_p ) ;
#line 438
extern GType g_object_get_type(void) ;
#line 440
extern gpointer g_object_new(GType object_type , gchar *first_property_name  , ...) ;
#line 444
extern GObject *g_object_new_with_properties(GType object_type , guint n_properties ,
                                             char const   *names[] , GValue values[] ) ;
#line 452
extern gpointer g_object_newv(GType object_type , guint n_parameters , GParameter *parameters ) ;
#line 459
extern GObject *g_object_new_valist(GType object_type , gchar *first_property_name ,
                                    va_list var_args ) ;
#line 463
extern void g_object_set(gpointer object , gchar *first_property_name  , ...) ;
#line 467
extern void g_object_get(gpointer object , gchar *first_property_name  , ...) ;
#line 471
extern gpointer g_object_connect(gpointer object , gchar *signal_spec  , ...) ;
#line 475
extern void g_object_disconnect(gpointer object , gchar *signal_spec  , ...) ;
#line 479
extern void g_object_setv(GObject *object , guint n_properties , gchar *names[] ,
                          GValue values[] ) ;
#line 484
extern void g_object_set_valist(GObject *object , gchar *first_property_name , va_list var_args ) ;
#line 488
extern void g_object_getv(GObject *object , guint n_properties , gchar *names[] ,
                          GValue values[] ) ;
#line 493
extern void g_object_get_valist(GObject *object , gchar *first_property_name , va_list var_args ) ;
#line 497
extern void g_object_set_property(GObject *object , gchar *property_name , GValue *value ) ;
#line 501
extern void g_object_get_property(GObject *object , gchar *property_name , GValue *value ) ;
#line 505
extern void g_object_freeze_notify(GObject *object ) ;
#line 507
extern void g_object_notify(GObject *object , gchar *property_name ) ;
#line 510
extern void g_object_notify_by_pspec(GObject *object , GParamSpec *pspec ) ;
#line 513
extern void g_object_thaw_notify(GObject *object ) ;
#line 515
extern gboolean g_object_is_floating(gpointer object ) ;
#line 517
extern gpointer g_object_ref_sink(gpointer object ) ;
#line 519
extern gpointer g_object_take_ref(gpointer object ) ;
#line 521
extern gpointer g_object_ref(gpointer object ) ;
#line 523
extern void g_object_unref(gpointer object ) ;
#line 525
extern void g_object_weak_ref(GObject *object , GWeakNotify notify , gpointer data ) ;
#line 529
extern void g_object_weak_unref(GObject *object , GWeakNotify notify , gpointer data ) ;
#line 533
extern void g_object_add_weak_pointer(GObject *object , gpointer *weak_pointer_location ) ;
#line 536
extern void g_object_remove_weak_pointer(GObject *object , gpointer *weak_pointer_location ) ;
#line 564
extern void g_object_add_toggle_ref(GObject *object , GToggleNotify notify , gpointer data ) ;
#line 568
extern void g_object_remove_toggle_ref(GObject *object , GToggleNotify notify , gpointer data ) ;
#line 573
extern gpointer g_object_get_qdata(GObject *object , GQuark quark ) ;
#line 576
extern void g_object_set_qdata(GObject *object , GQuark quark , gpointer data ) ;
#line 580
extern void g_object_set_qdata_full(GObject *object , GQuark quark , gpointer data ,
                                    GDestroyNotify destroy ) ;
#line 585
extern gpointer g_object_steal_qdata(GObject *object , GQuark quark ) ;
#line 589
extern gpointer g_object_dup_qdata(GObject *object , GQuark quark , GDuplicateFunc dup_func ,
                                   gpointer user_data ) ;
#line 594
extern gboolean g_object_replace_qdata(GObject *object , GQuark quark , gpointer oldval ,
                                       gpointer newval , GDestroyNotify destroy ,
                                       GDestroyNotify *old_destroy ) ;
#line 602
extern gpointer g_object_get_data(GObject *object , gchar *key ) ;
#line 605
extern void g_object_set_data(GObject *object , gchar *key , gpointer data ) ;
#line 609
extern void g_object_set_data_full(GObject *object , gchar *key , gpointer data ,
                                   GDestroyNotify destroy ) ;
#line 614
extern gpointer g_object_steal_data(GObject *object , gchar *key ) ;
#line 618
extern gpointer g_object_dup_data(GObject *object , gchar *key , GDuplicateFunc dup_func ,
                                  gpointer user_data ) ;
#line 623
extern gboolean g_object_replace_data(GObject *object , gchar *key , gpointer oldval ,
                                      gpointer newval , GDestroyNotify destroy , GDestroyNotify *old_destroy ) ;
#line 632
extern void g_object_watch_closure(GObject *object , GClosure *closure ) ;
#line 635
extern GClosure *g_cclosure_new_object(GCallback callback_func , GObject *object ) ;
#line 638
extern GClosure *g_cclosure_new_object_swap(GCallback callback_func , GObject *object ) ;
#line 641
extern GClosure *g_closure_new_object(guint sizeof_closure , GObject *object ) ;
#line 644
extern void g_value_set_object(GValue *value , gpointer v_object ) ;
#line 647
extern gpointer g_value_get_object(GValue *value ) ;
#line 649
extern gpointer g_value_dup_object(GValue *value ) ;
#line 651
extern gulong g_signal_connect_object(gpointer instance , gchar *detailed_signal ,
                                      GCallback c_handler , gpointer gobject , GConnectFlags connect_flags ) ;
#line 659
extern void g_object_force_floating(GObject *object ) ;
#line 661
extern void g_object_run_dispose(GObject *object ) ;
#line 665
extern void g_value_take_object(GValue *value , gpointer v_object ) ;
#line 668
extern void g_value_set_object_take_ownership(GValue *value , gpointer v_object ) ;
#line 672
extern gsize g_object_compat_control(gsize what , gpointer data ) ;
#line 702
extern void g_clear_object(GObject **object_ptr ) ;
#line 742 "/usr/include/glib-2.0/gobject/gobject.h"
__inline static gboolean g_set_object(GObject **object_ptr , GObject *new_object ) 
{ 
  GObject *old_object ;
  gpointer __cil_tmp4 ;

  {
#line 745
  old_object = *object_ptr;
#line 753
  if (old_object == new_object) {
#line 754
    return (0);
  }
#line 756
  if (new_object != (void *)0) {
    {
#line 757
    __cil_tmp4 = g_object_ref(new_object);
    }
  }
#line 759
  *object_ptr = new_object;
#line 761
  if (old_object != (void *)0) {
    {
#line 762
    g_object_unref(old_object);
    }
  }
#line 764
  return (! 0);
}
}
#line 808 "/usr/include/glib-2.0/gobject/gobject.h"
__inline static void g_assert_finalize_object(GObject *object ) 
{ 
  gpointer weak_pointer ;
  long __cil_tmp3 ;
  long __cil_tmp4 ;

  {
#line 810
  weak_pointer = object;
  {
#line 812
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 812
    __cil_tmp3 = __builtin_expect((long )0, (long )1);
    }
#line 812
    if (__cil_tmp3) {

    } else {
      {
#line 812
      g_assertion_message((char const   *)((gchar *)0), "/usr/include/glib-2.0/gobject/gobject.h",
                          812, (char const   *)"g_assert_finalize_object\312\001@",
                          "\'G_IS_OBJECT (weak_pointer)\' should be TRUE");
      }
    }
#line 812
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 813
  g_object_add_weak_pointer(object, & weak_pointer);
#line 814
  g_object_unref(weak_pointer);
  }
  {
#line 815
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 815
    __cil_tmp4 = __builtin_expect((long )0, (long )1);
    }
#line 815
    if (__cil_tmp4) {

    } else {
      {
#line 815
      g_assertion_message((char const   *)((gchar *)0), "/usr/include/glib-2.0/gobject/gobject.h",
                          815, (char const   *)"g_assert_finalize_object\312\001@",
                          "\'weak_pointer\' should be NULL");
      }
    }
#line 815
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 843 "/usr/include/glib-2.0/gobject/gobject.h"
__inline static void g_clear_weak_pointer(gpointer *weak_pointer_location ) 
{ 
  GObject *object ;

  {
#line 845
  object = (GObject *)*weak_pointer_location;
#line 847
  if (object != (void *)0) {
    {
#line 849
    g_object_remove_weak_pointer(object, weak_pointer_location);
#line 850
    *weak_pointer_location = (void *)0;
    }
  }
  return;
}
}
#line 898 "/usr/include/glib-2.0/gobject/gobject.h"
__inline static gboolean g_set_weak_pointer(gpointer *weak_pointer_location , GObject *new_object ) 
{ 
  GObject *old_object ;

  {
#line 901
  old_object = (GObject *)*weak_pointer_location;
#line 908
  if (old_object == new_object) {
#line 909
    return (0);
  }
#line 911
  if (old_object != (void *)0) {
    {
#line 912
    g_object_remove_weak_pointer(old_object, weak_pointer_location);
    }
  }
#line 914
  *weak_pointer_location = new_object;
#line 916
  if (new_object != (void *)0) {
    {
#line 917
    g_object_add_weak_pointer(new_object, weak_pointer_location);
    }
  }
#line 919
  return (! 0);
}
}
#line 934
extern void g_weak_ref_init(GWeakRef *weak_ref , gpointer object ) ;
#line 937
extern void g_weak_ref_clear(GWeakRef *weak_ref ) ;
#line 939
extern gpointer g_weak_ref_get(GWeakRef *weak_ref ) ;
#line 941
extern void g_weak_ref_set(GWeakRef *weak_ref , gpointer object ) ;
#line 106 "/usr/include/glib-2.0/gobject/gbinding.h"
extern GType g_binding_flags_get_type(void) ;
#line 108
extern GType g_binding_get_type(void) ;
#line 111
extern GBindingFlags g_binding_get_flags(GBinding *binding ) ;
#line 113
extern GObject *g_binding_get_source(GBinding *binding ) ;
#line 115
extern GObject *g_binding_dup_source(GBinding *binding ) ;
#line 117
extern GObject *g_binding_get_target(GBinding *binding ) ;
#line 119
extern GObject *g_binding_dup_target(GBinding *binding ) ;
#line 121
extern gchar *g_binding_get_source_property(GBinding *binding ) ;
#line 123
extern gchar *g_binding_get_target_property(GBinding *binding ) ;
#line 125
extern void g_binding_unbind(GBinding *binding ) ;
#line 128
extern GBinding *g_object_bind_property(gpointer source , gchar *source_property ,
                                        gpointer target , gchar *target_property ,
                                        GBindingFlags flags ) ;
#line 134
extern GBinding *g_object_bind_property_full(gpointer source , gchar *source_property ,
                                             gpointer target , gchar *target_property ,
                                             GBindingFlags flags , GBindingTransformFunc transform_to ,
                                             GBindingTransformFunc transform_from ,
                                             gpointer user_data , GDestroyNotify notify ) ;
#line 144
extern GBinding *g_object_bind_property_with_closures(gpointer source , gchar *source_property ,
                                                      gpointer target , gchar *target_property ,
                                                      GBindingFlags flags , GClosure *transform_to ,
                                                      GClosure *transform_from ) ;
#line 50 "/usr/include/glib-2.0/gobject/gbindinggroup.h"
extern GType g_binding_group_get_type(void) ;
#line 52
extern GBindingGroup *g_binding_group_new(void) ;
#line 54
extern gpointer g_binding_group_dup_source(GBindingGroup *self ) ;
#line 56
extern void g_binding_group_set_source(GBindingGroup *self , gpointer source ) ;
#line 59
extern void g_binding_group_bind(GBindingGroup *self , gchar *source_property , gpointer target ,
                                 gchar *target_property , GBindingFlags flags ) ;
#line 65
extern void g_binding_group_bind_full(GBindingGroup *self , gchar *source_property ,
                                      gpointer target , gchar *target_property , GBindingFlags flags ,
                                      GBindingTransformFunc transform_to , GBindingTransformFunc transform_from ,
                                      gpointer user_data , GDestroyNotify user_data_destroy ) ;
#line 75
extern void g_binding_group_bind_with_closures(GBindingGroup *self , gchar *source_property ,
                                               gpointer target , gchar *target_property ,
                                               GBindingFlags flags , GClosure *transform_to ,
                                               GClosure *transform_from ) ;
#line 219 "/usr/include/glib-2.0/gobject/genums.h"
extern GEnumValue *g_enum_get_value(GEnumClass *enum_class , gint value ) ;
#line 222
extern GEnumValue *g_enum_get_value_by_name(GEnumClass *enum_class , gchar *name ) ;
#line 225
extern GEnumValue *g_enum_get_value_by_nick(GEnumClass *enum_class , gchar *nick ) ;
#line 228
extern GFlagsValue *g_flags_get_first_value(GFlagsClass *flags_class , guint value ) ;
#line 231
extern GFlagsValue *g_flags_get_value_by_name(GFlagsClass *flags_class , gchar *name ) ;
#line 234
extern GFlagsValue *g_flags_get_value_by_nick(GFlagsClass *flags_class , gchar *nick ) ;
#line 237
extern gchar *g_enum_to_string(GType g_enum_type , gint value ) ;
#line 240
extern gchar *g_flags_to_string(GType flags_type , guint value ) ;
#line 243
extern void g_value_set_enum(GValue *value , gint v_enum ) ;
#line 246
extern gint g_value_get_enum(GValue *value ) ;
#line 248
extern void g_value_set_flags(GValue *value , guint v_flags ) ;
#line 251
extern guint g_value_get_flags(GValue *value ) ;
#line 260
extern GType g_enum_register_static(gchar *name , GEnumValue *const_static_values ) ;
#line 263
extern GType g_flags_register_static(gchar *name , GFlagsValue *const_static_values ) ;
#line 269
extern void g_enum_complete_type_info(GType g_enum_type , GTypeInfo *info , GEnumValue *const_values ) ;
#line 273
extern void g_flags_complete_type_info(GType g_flags_type , GTypeInfo *info , GFlagsValue *const_values ) ;
#line 12 "/usr/include/glib-2.0/gobject/glib-enumtypes.h"
extern GType g_unicode_type_get_type(void) ;
#line 14
extern GType g_unicode_break_type_get_type(void) ;
#line 16
extern GType g_unicode_script_get_type(void) ;
#line 18
extern GType g_normalize_mode_get_type(void) ;
#line 988 "/usr/include/glib-2.0/gobject/gparamspecs.h"
extern GParamSpec *g_param_spec_char(gchar *name , gchar *nick , gchar *blurb , gint8 minimum ,
                                     gint8 maximum , gint8 default_value , GParamFlags flags ) ;
#line 996
extern GParamSpec *g_param_spec_uchar(gchar *name , gchar *nick , gchar *blurb , guint8 minimum ,
                                      guint8 maximum , guint8 default_value , GParamFlags flags ) ;
#line 1004
extern GParamSpec *g_param_spec_boolean(gchar *name , gchar *nick , gchar *blurb ,
                                        gboolean default_value , GParamFlags flags ) ;
#line 1010
extern GParamSpec *g_param_spec_int(gchar *name , gchar *nick , gchar *blurb , gint minimum ,
                                    gint maximum , gint default_value , GParamFlags flags ) ;
#line 1018
extern GParamSpec *g_param_spec_uint(gchar *name , gchar *nick , gchar *blurb , guint minimum ,
                                     guint maximum , guint default_value , GParamFlags flags ) ;
#line 1026
extern GParamSpec *g_param_spec_long(gchar *name , gchar *nick , gchar *blurb , glong minimum ,
                                     glong maximum , glong default_value , GParamFlags flags ) ;
#line 1034
extern GParamSpec *g_param_spec_ulong(gchar *name , gchar *nick , gchar *blurb , gulong minimum ,
                                      gulong maximum , gulong default_value , GParamFlags flags ) ;
#line 1042
extern GParamSpec *g_param_spec_int64(gchar *name , gchar *nick , gchar *blurb , gint64 minimum ,
                                      gint64 maximum , gint64 default_value , GParamFlags flags ) ;
#line 1050
extern GParamSpec *g_param_spec_uint64(gchar *name , gchar *nick , gchar *blurb ,
                                       guint64 minimum , guint64 maximum , guint64 default_value ,
                                       GParamFlags flags ) ;
#line 1058
extern GParamSpec *g_param_spec_unichar(gchar *name , gchar *nick , gchar *blurb ,
                                        gunichar default_value , GParamFlags flags ) ;
#line 1064
extern GParamSpec *g_param_spec_enum(gchar *name , gchar *nick , gchar *blurb , GType enum_type ,
                                     gint default_value , GParamFlags flags ) ;
#line 1071
extern GParamSpec *g_param_spec_flags(gchar *name , gchar *nick , gchar *blurb , GType flags_type ,
                                      guint default_value , GParamFlags flags ) ;
#line 1078
extern GParamSpec *g_param_spec_float(gchar *name , gchar *nick , gchar *blurb , gfloat minimum ,
                                      gfloat maximum , gfloat default_value , GParamFlags flags ) ;
#line 1086
extern GParamSpec *g_param_spec_double(gchar *name , gchar *nick , gchar *blurb ,
                                       gdouble minimum , gdouble maximum , gdouble default_value ,
                                       GParamFlags flags ) ;
#line 1094
extern GParamSpec *g_param_spec_string(gchar *name , gchar *nick , gchar *blurb ,
                                       gchar *default_value , GParamFlags flags ) ;
#line 1100
extern GParamSpec *g_param_spec_param(gchar *name , gchar *nick , gchar *blurb , GType param_type ,
                                      GParamFlags flags ) ;
#line 1106
extern GParamSpec *g_param_spec_boxed(gchar *name , gchar *nick , gchar *blurb , GType boxed_type ,
                                      GParamFlags flags ) ;
#line 1112
extern GParamSpec *g_param_spec_pointer(gchar *name , gchar *nick , gchar *blurb ,
                                        GParamFlags flags ) ;
#line 1117
extern GParamSpec *g_param_spec_value_array(gchar *name , gchar *nick , gchar *blurb ,
                                            GParamSpec *element_spec , GParamFlags flags ) ;
#line 1123
extern GParamSpec *g_param_spec_object(gchar *name , gchar *nick , gchar *blurb ,
                                       GType object_type , GParamFlags flags ) ;
#line 1129
extern GParamSpec *g_param_spec_override(gchar *name , GParamSpec *overridden ) ;
#line 1132
extern GParamSpec *g_param_spec_gtype(gchar *name , gchar *nick , gchar *blurb , GType is_a_type ,
                                      GParamFlags flags ) ;
#line 1138
extern GParamSpec *g_param_spec_variant(gchar *name , gchar *nick , gchar *blurb ,
                                        GVariantType *type , GVariant *default_value ,
                                        GParamFlags flags ) ;
#line 1169
extern GType *g_param_spec_types ;
#line 50 "/usr/include/glib-2.0/gobject/gsignalgroup.h"
extern GType g_signal_group_get_type(void) ;
#line 52
extern GSignalGroup *g_signal_group_new(GType target_type ) ;
#line 54
extern void g_signal_group_set_target(GSignalGroup *self , gpointer target ) ;
#line 57
extern gpointer g_signal_group_dup_target(GSignalGroup *self ) ;
#line 59
extern void g_signal_group_block(GSignalGroup *self ) ;
#line 61
extern void g_signal_group_unblock(GSignalGroup *self ) ;
#line 63
extern void g_signal_group_connect_object(GSignalGroup *self , gchar *detailed_signal ,
                                          GCallback c_handler , gpointer object ,
                                          GConnectFlags flags ) ;
#line 69
extern void g_signal_group_connect_data(GSignalGroup *self , gchar *detailed_signal ,
                                        GCallback c_handler , gpointer data , GClosureNotify notify ,
                                        GConnectFlags flags ) ;
#line 76
extern void g_signal_group_connect(GSignalGroup *self , gchar *detailed_signal , GCallback c_handler ,
                                   gpointer data ) ;
#line 81
extern void g_signal_group_connect_after(GSignalGroup *self , gchar *detailed_signal ,
                                         GCallback c_handler , gpointer data ) ;
#line 86
extern void g_signal_group_connect_swapped(GSignalGroup *self , gchar *detailed_signal ,
                                           GCallback c_handler , gpointer data ) ;
#line 30 "/usr/include/glib-2.0/gobject/gsourceclosure.h"
extern void g_source_set_closure(GSource *source , GClosure *closure ) ;
#line 34
extern void g_source_set_dummy_callback(GSource *source ) ;
#line 39 "/usr/include/glib-2.0/gobject/gtypemodule.h"
__inline static void glib_autoptr_clear_GTypeModule(GTypeModule *_ptr ) 
{ 


  {
#line 39
  if (_ptr) {
    {
#line 39
    g_object_unref((GTypeModule *)_ptr);
    }
  }
  return;
}
}
#line 39 "/usr/include/glib-2.0/gobject/gtypemodule.h"
__inline static void glib_autoptr_cleanup_GTypeModule(GTypeModule **_ptr ) 
{ 


  {
  {
#line 39
  glib_autoptr_clear_GTypeModule(*_ptr);
  }
  return;
}
}
#line 39 "/usr/include/glib-2.0/gobject/gtypemodule.h"
__inline static void glib_listautoptr_cleanup_GTypeModule(GList **_l ) 
{ 


  {
  {
#line 39
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_object_unref)));
  }
  return;
}
}
#line 39 "/usr/include/glib-2.0/gobject/gtypemodule.h"
__inline static void glib_slistautoptr_cleanup_GTypeModule(GSList **_l ) 
{ 


  {
  {
#line 39
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_object_unref)));
  }
  return;
}
}
#line 39 "/usr/include/glib-2.0/gobject/gtypemodule.h"
__inline static void glib_queueautoptr_cleanup_GTypeModule(GQueue **_q ) 
{ 


  {
#line 39
  if (*_q) {
    {
#line 39
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_object_unref)));
    }
  }
  return;
}
}
#line 270
extern GType g_type_module_get_type(void) ;
#line 272
extern gboolean g_type_module_use(GTypeModule *module ) ;
#line 274
extern void g_type_module_unuse(GTypeModule *module ) ;
#line 276
extern void g_type_module_set_name(GTypeModule *module , gchar *name ) ;
#line 279
extern GType g_type_module_register_type(GTypeModule *module , GType parent_type ,
                                         gchar *type_name , GTypeInfo *type_info ,
                                         GTypeFlags flags ) ;
#line 285
extern void g_type_module_add_interface(GTypeModule *module , GType instance_type ,
                                        GType interface_type , GInterfaceInfo *interface_info ) ;
#line 290
extern GType g_type_module_register_enum(GTypeModule *module , gchar *name , GEnumValue *const_static_values ) ;
#line 294
extern GType g_type_module_register_flags(GTypeModule *module , gchar *name , GFlagsValue *const_static_values ) ;
#line 116 "/usr/include/glib-2.0/gobject/gtypeplugin.h"
extern GType g_type_plugin_get_type(void) ;
#line 118
extern void g_type_plugin_use(GTypePlugin *plugin ) ;
#line 120
extern void g_type_plugin_unuse(GTypePlugin *plugin ) ;
#line 122
extern void g_type_plugin_complete_type_info(GTypePlugin *plugin , GType g_type ,
                                             GTypeInfo *info , GTypeValueTable *value_table ) ;
#line 127
extern void g_type_plugin_complete_interface_info(GTypePlugin *plugin , GType instance_type ,
                                                  GType interface_type , GInterfaceInfo *info ) ;
#line 60 "/usr/include/glib-2.0/gobject/gvaluearray.h"
extern GType g_value_array_get_type(void) ;
#line 63
extern GValue *g_value_array_get_nth(GValueArray *value_array , guint index_ ) ;
#line 67
extern GValueArray *g_value_array_new(guint n_prealloced ) ;
#line 70
extern void g_value_array_free(GValueArray *value_array ) ;
#line 73
extern GValueArray *g_value_array_copy(GValueArray *value_array ) ;
#line 76
extern GValueArray *g_value_array_prepend(GValueArray *value_array , GValue *value ) ;
#line 80
extern GValueArray *g_value_array_append(GValueArray *value_array , GValue *value ) ;
#line 84
extern GValueArray *g_value_array_insert(GValueArray *value_array , guint index_ ,
                                         GValue *value ) ;
#line 89
extern GValueArray *g_value_array_remove(GValueArray *value_array , guint index_ ) ;
#line 93
extern GValueArray *g_value_array_sort(GValueArray *value_array , GCompareFunc compare_func ) ;
#line 97
extern GValueArray *g_value_array_sort_with_data(GValueArray *value_array , GCompareDataFunc compare_func ,
                                                 gpointer user_data ) ;
#line 192 "/usr/include/glib-2.0/gobject/gvaluetypes.h"
extern void g_value_set_char(GValue *value , gchar v_char ) ;
#line 195
extern gchar g_value_get_char(GValue *value ) ;
#line 197
extern void g_value_set_schar(GValue *value , gint8 v_char ) ;
#line 200
extern gint8 g_value_get_schar(GValue *value ) ;
#line 202
extern void g_value_set_uchar(GValue *value , guchar v_uchar ) ;
#line 205
extern guchar g_value_get_uchar(GValue *value ) ;
#line 207
extern void g_value_set_boolean(GValue *value , gboolean v_boolean ) ;
#line 210
extern gboolean g_value_get_boolean(GValue *value ) ;
#line 212
extern void g_value_set_int(GValue *value , gint v_int ) ;
#line 215
extern gint g_value_get_int(GValue *value ) ;
#line 217
extern void g_value_set_uint(GValue *value , guint v_uint ) ;
#line 220
extern guint g_value_get_uint(GValue *value ) ;
#line 222
extern void g_value_set_long(GValue *value , glong v_long ) ;
#line 225
extern glong g_value_get_long(GValue *value ) ;
#line 227
extern void g_value_set_ulong(GValue *value , gulong v_ulong ) ;
#line 230
extern gulong g_value_get_ulong(GValue *value ) ;
#line 232
extern void g_value_set_int64(GValue *value , gint64 v_int64 ) ;
#line 235
extern gint64 g_value_get_int64(GValue *value ) ;
#line 237
extern void g_value_set_uint64(GValue *value , guint64 v_uint64 ) ;
#line 240
extern guint64 g_value_get_uint64(GValue *value ) ;
#line 242
extern void g_value_set_float(GValue *value , gfloat v_float ) ;
#line 245
extern gfloat g_value_get_float(GValue *value ) ;
#line 247
extern void g_value_set_double(GValue *value , gdouble v_double ) ;
#line 250
extern gdouble g_value_get_double(GValue *value ) ;
#line 252
extern void g_value_set_string(GValue *value , gchar *v_string ) ;
#line 255
extern void g_value_set_static_string(GValue *value , gchar *v_string ) ;
#line 258
extern void g_value_set_interned_string(GValue *value , gchar *v_string ) ;
#line 261
extern gchar *g_value_get_string(GValue *value ) ;
#line 263
extern gchar *g_value_dup_string(GValue *value ) ;
#line 265
extern void g_value_set_pointer(GValue *value , gpointer v_pointer ) ;
#line 268
extern gpointer g_value_get_pointer(GValue *value ) ;
#line 270
extern GType g_gtype_get_type(void) ;
#line 272
extern void g_value_set_gtype(GValue *value , GType v_gtype ) ;
#line 275
extern GType g_value_get_gtype(GValue *value ) ;
#line 277
extern void g_value_set_variant(GValue *value , GVariant *variant ) ;
#line 280
extern void g_value_take_variant(GValue *value , GVariant *variant ) ;
#line 283
extern GVariant *g_value_get_variant(GValue *value ) ;
#line 285
extern GVariant *g_value_dup_variant(GValue *value ) ;
#line 290
extern GType g_pointer_type_register_static(gchar *name ) ;
#line 294
extern gchar *g_strdup_value_contents(GValue *value ) ;
#line 298
extern void g_value_take_string(GValue *value , gchar *v_string ) ;
#line 301
extern void g_value_set_string_take_ownership(GValue *value , gchar *v_string ) ;
#line 24 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_autoptr_clear_GClosure(GClosure *_ptr ) 
{ 


  {
#line 24
  if (_ptr) {
    {
#line 24
    g_closure_unref((GClosure *)_ptr);
    }
  }
  return;
}
}
#line 24 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_autoptr_cleanup_GClosure(GClosure **_ptr ) 
{ 


  {
  {
#line 24
  glib_autoptr_clear_GClosure(*_ptr);
  }
  return;
}
}
#line 24 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GClosure(GList **_l ) 
{ 


  {
  {
#line 24
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_closure_unref)));
  }
  return;
}
}
#line 24 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GClosure(GSList **_l ) 
{ 


  {
  {
#line 24
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_closure_unref)));
  }
  return;
}
}
#line 24 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GClosure(GQueue **_q ) 
{ 


  {
#line 24
  if (*_q) {
    {
#line 24
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_closure_unref)));
    }
  }
  return;
}
}
#line 25 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_autoptr_clear_GEnumClass(GEnumClass *_ptr ) 
{ 


  {
#line 25
  if (_ptr) {
    {
#line 25
    g_type_class_unref((GEnumClass *)_ptr);
    }
  }
  return;
}
}
#line 25 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_autoptr_cleanup_GEnumClass(GEnumClass **_ptr ) 
{ 


  {
  {
#line 25
  glib_autoptr_clear_GEnumClass(*_ptr);
  }
  return;
}
}
#line 25 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GEnumClass(GList **_l ) 
{ 


  {
  {
#line 25
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_type_class_unref)));
  }
  return;
}
}
#line 25 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GEnumClass(GSList **_l ) 
{ 


  {
  {
#line 25
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_type_class_unref)));
  }
  return;
}
}
#line 25 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GEnumClass(GQueue **_q ) 
{ 


  {
#line 25
  if (*_q) {
    {
#line 25
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_type_class_unref)));
    }
  }
  return;
}
}
#line 26 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_autoptr_clear_GFlagsClass(GFlagsClass *_ptr ) 
{ 


  {
#line 26
  if (_ptr) {
    {
#line 26
    g_type_class_unref((GFlagsClass *)_ptr);
    }
  }
  return;
}
}
#line 26 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_autoptr_cleanup_GFlagsClass(GFlagsClass **_ptr ) 
{ 


  {
  {
#line 26
  glib_autoptr_clear_GFlagsClass(*_ptr);
  }
  return;
}
}
#line 27 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_autoptr_clear_GObject(GObject *_ptr ) 
{ 


  {
#line 27
  if (_ptr) {
    {
#line 27
    g_object_unref((GObject *)_ptr);
    }
  }
  return;
}
}
#line 27 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_autoptr_cleanup_GObject(GObject **_ptr ) 
{ 


  {
  {
#line 27
  glib_autoptr_clear_GObject(*_ptr);
  }
  return;
}
}
#line 28 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_autoptr_clear_GInitiallyUnowned(GInitiallyUnowned *_ptr ) 
{ 


  {
#line 28
  if (_ptr) {
    {
#line 28
    g_object_unref((GInitiallyUnowned *)_ptr);
    }
  }
  return;
}
}
#line 28 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_autoptr_cleanup_GInitiallyUnowned(GInitiallyUnowned **_ptr ) 
{ 


  {
  {
#line 28
  glib_autoptr_clear_GInitiallyUnowned(*_ptr);
  }
  return;
}
}
#line 29 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_autoptr_clear_GParamSpec(GParamSpec *_ptr ) 
{ 


  {
#line 29
  if (_ptr) {
    {
#line 29
    g_param_spec_unref((GParamSpec *)_ptr);
    }
  }
  return;
}
}
#line 29 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_autoptr_cleanup_GParamSpec(GParamSpec **_ptr ) 
{ 


  {
  {
#line 29
  glib_autoptr_clear_GParamSpec(*_ptr);
  }
  return;
}
}
#line 29 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GParamSpec(GList **_l ) 
{ 


  {
  {
#line 29
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_param_spec_unref)));
  }
  return;
}
}
#line 29 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GParamSpec(GSList **_l ) 
{ 


  {
  {
#line 29
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_param_spec_unref)));
  }
  return;
}
}
#line 29 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GParamSpec(GQueue **_q ) 
{ 


  {
#line 29
  if (*_q) {
    {
#line 29
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_param_spec_unref)));
    }
  }
  return;
}
}
#line 30 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_autoptr_clear_GTypeClass(GTypeClass *_ptr ) 
{ 


  {
#line 30
  if (_ptr) {
    {
#line 30
    g_type_class_unref((GTypeClass *)_ptr);
    }
  }
  return;
}
}
#line 30 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_autoptr_cleanup_GTypeClass(GTypeClass **_ptr ) 
{ 


  {
  {
#line 30
  glib_autoptr_clear_GTypeClass(*_ptr);
  }
  return;
}
}
#line 31 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_auto_cleanup_GValue(GValue *_ptr ) 
{ 


  {
  {
#line 31
  g_value_unset(_ptr);
  }
  return;
}
}
#line 34 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/color.h"
at_color *at_color_new(unsigned char r , unsigned char g , unsigned char b ) ;
#line 35
at_color *at_color_parse(gchar *string , GError **err ) ;
#line 36
at_color *at_color_copy(at_color *original ) ;
#line 37
gboolean at_color_equal(at_color *c1 , at_color *c2 ) ;
#line 38
void at_color_set(at_color *c , unsigned char r , unsigned char g , unsigned char b ) ;
#line 40
unsigned char at_color_luminance(at_color *color ) ;
#line 41
void at_color_free(at_color *color ) ;
#line 43
GType at_color_get_type(void) ;
#line 230 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/autotrace.h"
void autotrace_init(void) ;
#line 263
at_fitting_opts_type *at_fitting_opts_new(void) ;
#line 264
at_fitting_opts_type *at_fitting_opts_copy(at_fitting_opts_type *original ) ;
#line 265
void at_fitting_opts_free(at_fitting_opts_type *opts ) ;
#line 270
char const   *at_fitting_opts_doc_func(char *string ) ;
#line 277
at_input_opts_type *at_input_opts_new(void) ;
#line 278
at_input_opts_type *at_input_opts_copy(at_input_opts_type *original ) ;
#line 279
void at_input_opts_free(at_input_opts_type *opts ) ;
#line 286
at_output_opts_type *at_output_opts_new(void) ;
#line 287
at_output_opts_type *at_output_opts_copy(at_output_opts_type *original ) ;
#line 288
void at_output_opts_free(at_output_opts_type *opts ) ;
#line 306
at_bitmap *at_bitmap_read(at_bitmap_reader *reader , gchar *filename , at_input_opts_type *opts ,
                          at_msg_func msg_func , gpointer msg_data ) ;
#line 307
at_bitmap *at_bitmap_new(unsigned short width , unsigned short height , unsigned int planes ) ;
#line 308
at_bitmap *at_bitmap_copy(at_bitmap *src ) ;
#line 313
unsigned short at_bitmap_get_width(at_bitmap *bitmap ) ;
#line 314
unsigned short at_bitmap_get_height(at_bitmap *bitmap ) ;
#line 315
unsigned short at_bitmap_get_planes(at_bitmap *bitmap ) ;
#line 316
void at_bitmap_get_color(at_bitmap *bitmap , unsigned int row , unsigned int col ,
                         at_color *color ) ;
#line 317
gboolean at_bitmap_equal_color(at_bitmap *bitmap , unsigned int row , unsigned int col ,
                               at_color *color ) ;
#line 318
void at_bitmap_free(at_bitmap *bitmap ) ;
#line 336
at_spline_list_array_type *at_splines_new(at_bitmap *bitmap , at_fitting_opts_type *opts ,
                                          at_msg_func msg_func , gpointer msg_data ) ;
#line 361
at_spline_list_array_type *at_splines_new_full(at_bitmap *bitmap , at_fitting_opts_type *opts ,
                                               at_msg_func msg_func , gpointer msg_data ,
                                               at_progress_func notify_progress ,
                                               gpointer progress_data , at_testcancel_func test_cancel ,
                                               gpointer testcancel_data ) ;
#line 363
void at_splines_write(at_spline_writer *writer , FILE *writeto , gchar *file_name ,
                      at_output_opts_type *opts , at_spline_list_array_type *splines ,
                      at_msg_func msg_func , gpointer msg_data ) ;
#line 365
void at_splines_free(at_spline_list_array_type *splines ) ;
#line 370
at_bitmap_reader *at_input_get_handler(gchar *filename ) ;
#line 371
at_bitmap_reader *at_input_get_handler_by_suffix(gchar *suffix ) ;
#line 373
char const   **at_input_list_new(void) ;
#line 374
void at_input_list_free(char const   **list ) ;
#line 378
char *at_input_shortlist(void) ;
#line 383
at_spline_writer *at_output_get_handler(gchar *filename ) ;
#line 384
at_spline_writer *at_output_get_handler_by_suffix(gchar *suffix ) ;
#line 385
char const   **at_output_list_new(void) ;
#line 386
void at_output_list_free(char const   **list ) ;
#line 390
char *at_output_shortlist(void) ;
#line 403
char const   *at_version(gboolean long_format ) ;
#line 408
char const   *at_home_site(void) ;
#line 25 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/exception.h"
at_exception_type at_exception_new(at_msg_func client_func , gpointer client_data ) ;
#line 26
gboolean at_exception_got_fatal(at_exception_type *exception ) ;
#line 27
void at_exception_fatal(at_exception_type *exception , gchar *message ) ;
#line 28
void at_exception_warning(at_exception_type *exception , gchar *message ) ;
#line 31
GQuark at_error_quark(void) ;
#line 41 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input.h"
int at_input_add_handler(gchar *suffix , gchar *description , at_input_func reader ) ;
#line 46
int at_input_add_handler_full(gchar *suffix , gchar *description , at_input_func reader ,
                              gboolean override , gpointer user_data , GDestroyNotify user_data_destroy_func ) ;
#line 68
at_bitmap at_bitmap_init(unsigned char *area , unsigned short width , unsigned short height ,
                         unsigned int planes ) ;
#line 35 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output.h"
int at_output_add_handler(gchar *suffix , gchar *description , at_output_func writer ) ;
#line 37
int at_output_add_handler_full(gchar *suffix , gchar *description , at_output_func writer ,
                               gboolean override , gpointer user_data , GDestroyNotify user_data_destroy_func ) ;
#line 83
void at_spline_list_foreach(at_spline_list_type *list , AtSplineListForeachFunc func ,
                            gpointer user_data ) ;
#line 84
void at_spline_list_array_foreach(at_spline_list_array_type *list_array , AtSplineListArrayForeachFunc func ,
                                  gpointer user_data ) ;
#line 39 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/private.h"
int at_input_init(void) ;
#line 40
int at_output_init(void) ;
#line 41
int at_param_init(void) ;
#line 42
int at_module_init(void) ;
#line 25 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-pnm.h"
at_bitmap input_pnm_reader(gchar *filename , at_input_opts_type *opts , at_msg_func msg_func ,
                           gpointer msg_data , gpointer user_data ) ;
#line 25 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-bmp.h"
at_bitmap input_bmp_reader(gchar *filename , at_input_opts_type *opts , at_msg_func msg_func ,
                           gpointer msg_data , gpointer user_data ) ;
#line 25 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-tga.h"
at_bitmap input_tga_reader(gchar *filename , at_input_opts_type *opts , at_msg_func msg_func ,
                           gpointer msg_data , gpointer user_data ) ;
#line 25 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-gf.h"
at_bitmap input_gf_reader(gchar *filename , at_input_opts_type *opts , at_msg_func msg_func ,
                          gpointer msg_data , gpointer user_data ) ;
#line 27 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-png.h"
at_bitmap input_png_reader(gchar *filename , at_input_opts_type *opts , at_msg_func msg_func ,
                           gpointer msg_data , gpointer user_data ) ;
#line 41 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/module.c"
int install_input_magick_readers(void) 
{ 


  {
#line 43
  return (0);
}
}
#line 25 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-eps.h"
int output_eps_writer(FILE *ps_file , gchar *name , int llx , int lly , int urx ,
                      int ury , at_output_opts_type *opts , at_spline_list_array_type shape ,
                      at_msg_func msg_func , gpointer msg_data , gpointer user_data ) ;
#line 25 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-er.h"
int output_er_writer(FILE *file , gchar *name , int llx , int lly , int urx , int ury ,
                     at_output_opts_type *opts , at_spline_list_array_type shape ,
                     at_msg_func msg_func , gpointer msg_data , gpointer user_data ) ;
#line 25 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-p2e.h"
int output_p2e_writer(FILE *ps_file , gchar *name , int llx , int lly , int urx ,
                      int ury , at_output_opts_type *opts , at_spline_list_array_type shape ,
                      at_msg_func msg_func , gpointer msg_data , gpointer user_data ) ;
#line 25 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-sk.h"
int output_sk_writer(FILE *file , gchar *name , int llx , int lly , int urx , int ury ,
                     at_output_opts_type *opts , at_spline_list_array_type shape ,
                     at_msg_func msg_func , gpointer msg_data , gpointer user_data ) ;
#line 25 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-svg.h"
int output_svg_writer(FILE *file , gchar *name , int llx , int lly , int urx , int ury ,
                      at_output_opts_type *opts , at_spline_list_array_type shape ,
                      at_msg_func msg_func , gpointer msg_data , gpointer user_data ) ;
#line 25 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-ugs.h"
int output_ugs_writer(FILE *file , gchar *name , int llx , int lly , int urx , int ury ,
                      at_output_opts_type *opts , at_spline_list_array_type shape ,
                      at_msg_func msg_func , gpointer msg_data , gpointer usar_data ) ;
#line 27
long ugs_charcode ;
#line 28
long ugs_design_pixels ;
#line 29
long ugs_advance_width ;
#line 30
long ugs_left_bearing ;
#line 30
long ugs_descend ;
#line 31
long ugs_max_col ;
#line 31
long ugs_max_row ;
#line 25 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-fig.h"
int output_fig_writer(FILE *file , gchar *name , int llx , int lly , int urx , int ury ,
                      at_output_opts_type *opts , at_spline_list_array_type shape ,
                      at_msg_func msg_func , gpointer msg_data , gpointer user_data ) ;
#line 25 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-emf.h"
int output_emf_writer(FILE *file , gchar *name , int llx , int lly , int urx , int ury ,
                      at_output_opts_type *opts , at_spline_list_array_type shape ,
                      at_msg_func msg_func , gpointer msg_data , gpointer user_data ) ;
#line 25 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-mif.h"
int output_mif_writer(FILE *ps_file , gchar *name , int llx , int lly , int urx ,
                      int ury , at_output_opts_type *opts , at_spline_list_array_type shape ,
                      at_msg_func msg_func , gpointer msg_data , gpointer user_data ) ;
#line 25 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-dxf.h"
int output_dxf12_writer(FILE *dxf_file , gchar *name , int llx , int lly , int urx ,
                        int ury , at_output_opts_type *opts , at_spline_list_array_type shape ,
                        at_msg_func msg_func , gpointer msg_data , gpointer user_data ) ;
#line 26 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-epd.h"
int output_epd_writer(FILE *epd_file , gchar *name , int llx , int lly , int urx ,
                      int ury , at_output_opts_type *opts , at_spline_list_array_type shape ,
                      at_msg_func msg_func , gpointer msg_data , gpointer user_data ) ;
#line 30 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/spline.h"
void print_spline(spline_type s ) ;
#line 33
at_real_coord evaluate_spline(spline_type s , gfloat t ) ;
#line 63
spline_list_type *new_spline_list(void) ;
#line 64
spline_list_type empty_spline_list(void) ;
#line 65
spline_list_type *new_spline_list_with_spline(spline_type spline ) ;
#line 66
void free_spline_list(spline_list_type spline_list ) ;
#line 69
void append_spline(spline_list_type *l , spline_type s ) ;
#line 72
void concat_spline_lists(spline_list_type *s1 , spline_list_type s2 ) ;
#line 84
at_spline_list_array_type new_spline_list_array(void) ;
#line 85
void append_spline_list(at_spline_list_array_type *l , spline_list_type s ) ;
#line 86
void free_spline_list_array(at_spline_list_array_type *spline_list_array ) ;
#line 29 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-pdf.h"
int output_pdf_writer(FILE *pdf_file , gchar *name , int llx , int lly , int urx ,
                      int ury , at_output_opts_type *opts , at_spline_list_array_type shape ,
                      at_msg_func msg_func , gpointer msg_data , gpointer user_data ) ;
#line 25 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-cgm.h"
int output_cgm_writer(FILE *cgm_file , gchar *name , int llx , int lly , int urx ,
                      int ury , at_output_opts_type *opts , at_spline_list_array_type shape ,
                      at_msg_func msg_func , gpointer msg_data , gpointer user_data ) ;
#line 25 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-dr2d.h"
int output_dr2d_writer(FILE *file , gchar *name , int llx , int lly , int urx , int ury ,
                       at_output_opts_type *opts , at_spline_list_array_type shape ,
                       at_msg_func msg_func , gpointer msg_data , gpointer user_data ) ;
#line 67 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/module.c"
int install_output_pstoedit_writers(void) 
{ 


  {
#line 69
  return (0);
}
}
#line 25 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-pov.h"
int output_pov_writer(FILE *pov_file , gchar *name , int llx , int lly , int urx ,
                      int ury , at_output_opts_type *opts , at_spline_list_array_type shape ,
                      at_msg_func msg_func , gpointer msg_data , gpointer user_data ) ;
#line 25 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-plt.h"
int output_plt_writer(FILE *file , gchar *name , int llx , int lly , int urx , int ury ,
                      at_output_opts_type *opts , at_spline_list_array_type shape ,
                      at_msg_func msg_func , gpointer msg_data , gpointer user_data ) ;
#line 26 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-ild.h"
int output_ild_writer(FILE *file , gchar *name , int llx , int lly , int urx , int ury ,
                      at_output_opts_type *opts , at_spline_list_array_type shape ,
                      at_msg_func msg_func , gpointer msg_data , gpointer user_data ) ;
#line 76 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/module.c"
static int install_input_readers(void) ;
#line 77
static int install_output_writers(void) ;
#line 79 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/module.c"
int at_module_init(void) 
{ 
  int r ;
  int w ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 84
  r = install_input_readers();
#line 85
  w = install_output_writers();
  }
#line 86
  return ((int )((r << 2) | w));
}
}
#line 89 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/module.c"
static int install_input_readers(void) 
{ 
  int __cil_tmp1 ;

  {
  {
#line 92
  at_input_add_handler((gchar *)"PNG", (gchar *)"Portable network graphics", & input_png_reader);
#line 94
  at_input_add_handler((gchar *)"TGA", (gchar *)"Truevision Targa image", & input_tga_reader);
#line 95
  at_input_add_handler((gchar *)"BMP", (gchar *)"Microsoft Windows bitmap image",
                       & input_bmp_reader);
#line 97
  at_input_add_handler_full((gchar *)"PBM", (gchar *)"Portable bitmap format", & input_pnm_reader,
                            0, "PBM", (GDestroyNotify )((void *)0));
#line 98
  at_input_add_handler_full((gchar *)"PNM", (gchar *)"Portable anymap format", & input_pnm_reader,
                            0, "PNM", (GDestroyNotify )((void *)0));
#line 99
  at_input_add_handler_full((gchar *)"PGM", (gchar *)"Portable graymap format", & input_pnm_reader,
                            0, "PGM", (GDestroyNotify )((void *)0));
#line 100
  at_input_add_handler_full((gchar *)"PPM", (gchar *)"Portable pixmap format", & input_pnm_reader,
                            0, "PPM", (GDestroyNotify )((void *)0));
#line 102
  at_input_add_handler((gchar *)"GF", (gchar *)"TeX raster font", & input_gf_reader);
#line 104
  __cil_tmp1 = install_input_magick_readers();
  }
#line 104
  return (__cil_tmp1);
}
}
#line 107 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/module.c"
static int install_output_writers(void) 
{ 
  int __cil_tmp1 ;

  {
  {
#line 109
  at_output_add_handler((gchar *)"EPS", (gchar *)"Encapsulated PostScript", & output_eps_writer);
#line 110
  at_output_add_handler((gchar *)"AI", (gchar *)"Adobe Illustrator", & output_eps_writer);
#line 111
  at_output_add_handler((gchar *)"P2E", (gchar *)"pstoedit frontend format\230", & output_p2e_writer);
#line 112
  at_output_add_handler((gchar *)"SK", (gchar *)"Sketch", & output_sk_writer);
#line 113
  at_output_add_handler((gchar *)"SVG", (gchar *)"Scalable Vector Graphics\230", & output_svg_writer);
#line 114
  at_output_add_handler((gchar *)"UGS", (gchar *)"Unicode glyph source", & output_ugs_writer);
#line 115
  at_output_add_handler((gchar *)"FIG", (gchar *)"XFIG 3.2\230", & output_fig_writer);
#line 121
  at_output_add_handler((gchar *)"EMF", (gchar *)"Enhanced Metafile format\230", & output_emf_writer);
#line 122
  at_output_add_handler((gchar *)"MIF", (gchar *)"FrameMaker MIF format", & output_mif_writer);
#line 123
  at_output_add_handler((gchar *)"ER", (gchar *)"Elastic Reality Shape file", & output_er_writer);
#line 124
  at_output_add_handler((gchar *)"DXF", (gchar *)"DXF format (without splines)", & output_dxf12_writer);
#line 125
  at_output_add_handler((gchar *)"EPD", (gchar *)"EPD format", & output_epd_writer);
#line 126
  at_output_add_handler((gchar *)"PDF", (gchar *)"PDF format", & output_pdf_writer);
#line 127
  at_output_add_handler((gchar *)"CGM", (gchar *)"Computer Graphics Metafile", & output_cgm_writer);
#line 128
  at_output_add_handler((gchar *)"DR2D", (gchar *)"IFF DR2D format", & output_dr2d_writer);
#line 129
  at_output_add_handler((gchar *)"POV", (gchar *)"Povray format", & output_pov_writer);
#line 130
  at_output_add_handler((gchar *)"POV", (gchar *)"Povray format", & output_pov_writer);
#line 131
  at_output_add_handler((gchar *)"PLT", (gchar *)"HPGL format", & output_plt_writer);
#line 132
  at_output_add_handler((gchar *)"ILD", (gchar *)"ILDA format", & output_ild_writer);
#line 134
  __cil_tmp1 = install_output_pstoedit_writers();
  }
#line 134
  return (__cil_tmp1);
}
}
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__)) void __assert_fail(char const   *__assertion ,
                                                        char const   *__file , unsigned int __line ,
                                                        char const   *__function ) ;
#line 74
extern  __attribute__((__nothrow__)) void __assert_perror_fail(int __errnum , char const   *__file ,
                                                               unsigned int __line ,
                                                               char const   *__function ) ;
#line 81
extern  __attribute__((__nothrow__)) void __assert(char const   *__assertion , char const   *__file ,
                                                   int __line ) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassify(double __value ) ;
#line 24
extern  __attribute__((__nothrow__)) int __signbit(double __value ) ;
#line 29
extern  __attribute__((__nothrow__)) int __isinf(double __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finite(double __value ) ;
#line 37
extern  __attribute__((__nothrow__)) int __isnan(double __value ) ;
#line 41
extern  __attribute__((__nothrow__)) int __iseqsig(double __x , double __y ) ;
#line 44
extern  __attribute__((__nothrow__)) int __issignaling(double __value ) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double acos(double __x ) ;
#line 53
extern  __attribute__((__nothrow__)) double __acos(double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) double asin(double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) double __asin(double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) double atan(double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) double __atan(double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) double atan2(double __y , double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) double __atan2(double __y , double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) double cos(double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) double __cos(double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) double sin(double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) double __sin(double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) double tan(double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) double __tan(double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) double cosh(double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) double __cosh(double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) double sinh(double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) double __sinh(double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) double tanh(double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) double __tanh(double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) double acosh(double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) double __acosh(double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) double asinh(double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) double __asinh(double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) double atanh(double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) double __atanh(double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) double exp(double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) double __exp(double __x ) ;
#line 98
extern  __attribute__((__nothrow__)) double frexp(double __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) double __frexp(double __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) double ldexp(double __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) double __ldexp(double __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) double log(double __x ) ;
#line 104
extern  __attribute__((__nothrow__)) double __log(double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) double log10(double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) double __log10(double __x ) ;
#line 110
extern  __attribute__((__nothrow__)) double modf(double __x , double *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) double __modf(double __x , double *__iptr ) ;
#line 119
extern  __attribute__((__nothrow__)) double expm1(double __x ) ;
#line 119
extern  __attribute__((__nothrow__)) double __expm1(double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) double log1p(double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) double __log1p(double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) double logb(double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) double __logb(double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) double exp2(double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) double __exp2(double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) double log2(double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) double __log2(double __x ) ;
#line 140
extern  __attribute__((__nothrow__)) double pow(double __x , double __y ) ;
#line 140
extern  __attribute__((__nothrow__)) double __pow(double __x , double __y ) ;
#line 143
extern  __attribute__((__nothrow__)) double sqrt(double __x ) ;
#line 143
extern  __attribute__((__nothrow__)) double __sqrt(double __x ) ;
#line 147
extern  __attribute__((__nothrow__)) double hypot(double __x , double __y ) ;
#line 147
extern  __attribute__((__nothrow__)) double __hypot(double __x , double __y ) ;
#line 152
extern  __attribute__((__nothrow__)) double cbrt(double __x ) ;
#line 152
extern  __attribute__((__nothrow__)) double __cbrt(double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) double ceil(double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) double __ceil(double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) double fabs(double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) double __fabs(double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) double floor(double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) double __floor(double __x ) ;
#line 168
extern  __attribute__((__nothrow__)) double fmod(double __x , double __y ) ;
#line 168
extern  __attribute__((__nothrow__)) double __fmod(double __x , double __y ) ;
#line 177
extern  __attribute__((__nothrow__)) int isinf(double __value ) ;
#line 183
extern  __attribute__((__nothrow__)) int finite(double __value ) ;
#line 187
extern  __attribute__((__nothrow__)) double drem(double __x , double __y ) ;
#line 187
extern  __attribute__((__nothrow__)) double __drem(double __x , double __y ) ;
#line 191
extern  __attribute__((__nothrow__)) double significand(double __x ) ;
#line 191
extern  __attribute__((__nothrow__)) double __significand(double __x ) ;
#line 198
extern  __attribute__((__nothrow__)) double copysign(double __x , double __y ) ;
#line 198
extern  __attribute__((__nothrow__)) double __copysign(double __x , double __y ) ;
#line 203
extern  __attribute__((__nothrow__)) double nan(char const   *__tagb ) ;
#line 203
extern  __attribute__((__nothrow__)) double __nan(char const   *__tagb ) ;
#line 213
extern  __attribute__((__nothrow__)) int isnan(double __value ) ;
#line 220
extern  __attribute__((__nothrow__)) double j0(double  ) ;
#line 220
extern  __attribute__((__nothrow__)) double __j0(double  ) ;
#line 221
extern  __attribute__((__nothrow__)) double j1(double  ) ;
#line 221
extern  __attribute__((__nothrow__)) double __j1(double  ) ;
#line 222
extern  __attribute__((__nothrow__)) double jn(int  , double  ) ;
#line 222
extern  __attribute__((__nothrow__)) double __jn(int  , double  ) ;
#line 223
extern  __attribute__((__nothrow__)) double y0(double  ) ;
#line 223
extern  __attribute__((__nothrow__)) double __y0(double  ) ;
#line 224
extern  __attribute__((__nothrow__)) double y1(double  ) ;
#line 224
extern  __attribute__((__nothrow__)) double __y1(double  ) ;
#line 225
extern  __attribute__((__nothrow__)) double yn(int  , double  ) ;
#line 225
extern  __attribute__((__nothrow__)) double __yn(int  , double  ) ;
#line 231
extern  __attribute__((__nothrow__)) double erf(double  ) ;
#line 231
extern  __attribute__((__nothrow__)) double __erf(double  ) ;
#line 232
extern  __attribute__((__nothrow__)) double erfc(double  ) ;
#line 232
extern  __attribute__((__nothrow__)) double __erfc(double  ) ;
#line 233
extern  __attribute__((__nothrow__)) double lgamma(double  ) ;
#line 233
extern  __attribute__((__nothrow__)) double __lgamma(double  ) ;
#line 238
extern  __attribute__((__nothrow__)) double tgamma(double  ) ;
#line 238
extern  __attribute__((__nothrow__)) double __tgamma(double  ) ;
#line 244
extern  __attribute__((__nothrow__)) double gamma(double  ) ;
#line 244
extern  __attribute__((__nothrow__)) double __gamma(double  ) ;
#line 252
extern  __attribute__((__nothrow__)) double lgamma_r(double  , int *__signgamp ) ;
#line 252
extern  __attribute__((__nothrow__)) double __lgamma_r(double  , int *__signgamp ) ;
#line 259
extern  __attribute__((__nothrow__)) double rint(double __x ) ;
#line 259
extern  __attribute__((__nothrow__)) double __rint(double __x ) ;
#line 262
extern  __attribute__((__nothrow__)) double nextafter(double __x , double __y ) ;
#line 262
extern  __attribute__((__nothrow__)) double __nextafter(double __x , double __y ) ;
#line 264
extern  __attribute__((__nothrow__)) double nexttoward(double __x , long double __y ) ;
#line 264
extern  __attribute__((__nothrow__)) double __nexttoward(double __x , long double __y ) ;
#line 275
extern  __attribute__((__nothrow__)) double remainder(double __x , double __y ) ;
#line 275
extern  __attribute__((__nothrow__)) double __remainder(double __x , double __y ) ;
#line 279
extern  __attribute__((__nothrow__)) double scalbn(double __x , int __n ) ;
#line 279
extern  __attribute__((__nothrow__)) double __scalbn(double __x , int __n ) ;
#line 283
extern  __attribute__((__nothrow__)) int ilogb(double __x ) ;
#line 283
extern  __attribute__((__nothrow__)) int __ilogb(double __x ) ;
#line 293
extern  __attribute__((__nothrow__)) double scalbln(double __x , long __n ) ;
#line 293
extern  __attribute__((__nothrow__)) double __scalbln(double __x , long __n ) ;
#line 297
extern  __attribute__((__nothrow__)) double nearbyint(double __x ) ;
#line 297
extern  __attribute__((__nothrow__)) double __nearbyint(double __x ) ;
#line 301
extern  __attribute__((__nothrow__)) double round(double __x ) ;
#line 301
extern  __attribute__((__nothrow__)) double __round(double __x ) ;
#line 305
extern  __attribute__((__nothrow__)) double trunc(double __x ) ;
#line 305
extern  __attribute__((__nothrow__)) double __trunc(double __x ) ;
#line 310
extern  __attribute__((__nothrow__)) double remquo(double __x , double __y , int *__quo ) ;
#line 310
extern  __attribute__((__nothrow__)) double __remquo(double __x , double __y , int *__quo ) ;
#line 317
extern  __attribute__((__nothrow__)) long lrint(double __x ) ;
#line 317
extern  __attribute__((__nothrow__)) long __lrint(double __x ) ;
#line 319
extern  __attribute__((__nothrow__)) long long llrint(double __x ) ;
#line 319
extern  __attribute__((__nothrow__)) long long __llrint(double __x ) ;
#line 323
extern  __attribute__((__nothrow__)) long lround(double __x ) ;
#line 323
extern  __attribute__((__nothrow__)) long __lround(double __x ) ;
#line 325
extern  __attribute__((__nothrow__)) long long llround(double __x ) ;
#line 325
extern  __attribute__((__nothrow__)) long long __llround(double __x ) ;
#line 329
extern  __attribute__((__nothrow__)) double fdim(double __x , double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) double __fdim(double __x , double __y ) ;
#line 333
extern  __attribute__((__nothrow__)) double fmax(double __x , double __y ) ;
#line 333
extern  __attribute__((__nothrow__)) double __fmax(double __x , double __y ) ;
#line 336
extern  __attribute__((__nothrow__)) double fmin(double __x , double __y ) ;
#line 336
extern  __attribute__((__nothrow__)) double __fmin(double __x , double __y ) ;
#line 340
extern  __attribute__((__nothrow__)) double fma(double __x , double __y , double __z ) ;
#line 340
extern  __attribute__((__nothrow__)) double __fma(double __x , double __y , double __z ) ;
#line 435
extern  __attribute__((__nothrow__)) double scalb(double __x , double __n ) ;
#line 435
extern  __attribute__((__nothrow__)) double __scalb(double __x , double __n ) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassifyf(float __value ) ;
#line 24
extern  __attribute__((__nothrow__)) int __signbitf(float __value ) ;
#line 29
extern  __attribute__((__nothrow__)) int __isinff(float __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finitef(float __value ) ;
#line 37
extern  __attribute__((__nothrow__)) int __isnanf(float __value ) ;
#line 41
extern  __attribute__((__nothrow__)) int __iseqsigf(float __x , float __y ) ;
#line 44
extern  __attribute__((__nothrow__)) int __issignalingf(float __value ) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) float acosf(float __x ) ;
#line 53
extern  __attribute__((__nothrow__)) float __acosf(float __x ) ;
#line 55
extern  __attribute__((__nothrow__)) float asinf(float __x ) ;
#line 55
extern  __attribute__((__nothrow__)) float __asinf(float __x ) ;
#line 57
extern  __attribute__((__nothrow__)) float atanf(float __x ) ;
#line 57
extern  __attribute__((__nothrow__)) float __atanf(float __x ) ;
#line 59
extern  __attribute__((__nothrow__)) float atan2f(float __y , float __x ) ;
#line 59
extern  __attribute__((__nothrow__)) float __atan2f(float __y , float __x ) ;
#line 62
extern  __attribute__((__nothrow__)) float cosf(float __x ) ;
#line 62
extern  __attribute__((__nothrow__)) float __cosf(float __x ) ;
#line 64
extern  __attribute__((__nothrow__)) float sinf(float __x ) ;
#line 64
extern  __attribute__((__nothrow__)) float __sinf(float __x ) ;
#line 66
extern  __attribute__((__nothrow__)) float tanf(float __x ) ;
#line 66
extern  __attribute__((__nothrow__)) float __tanf(float __x ) ;
#line 71
extern  __attribute__((__nothrow__)) float coshf(float __x ) ;
#line 71
extern  __attribute__((__nothrow__)) float __coshf(float __x ) ;
#line 73
extern  __attribute__((__nothrow__)) float sinhf(float __x ) ;
#line 73
extern  __attribute__((__nothrow__)) float __sinhf(float __x ) ;
#line 75
extern  __attribute__((__nothrow__)) float tanhf(float __x ) ;
#line 75
extern  __attribute__((__nothrow__)) float __tanhf(float __x ) ;
#line 85
extern  __attribute__((__nothrow__)) float acoshf(float __x ) ;
#line 85
extern  __attribute__((__nothrow__)) float __acoshf(float __x ) ;
#line 87
extern  __attribute__((__nothrow__)) float asinhf(float __x ) ;
#line 87
extern  __attribute__((__nothrow__)) float __asinhf(float __x ) ;
#line 89
extern  __attribute__((__nothrow__)) float atanhf(float __x ) ;
#line 89
extern  __attribute__((__nothrow__)) float __atanhf(float __x ) ;
#line 95
extern  __attribute__((__nothrow__)) float expf(float __x ) ;
#line 95
extern  __attribute__((__nothrow__)) float __expf(float __x ) ;
#line 98
extern  __attribute__((__nothrow__)) float frexpf(float __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) float __frexpf(float __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) float ldexpf(float __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) float __ldexpf(float __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) float logf(float __x ) ;
#line 104
extern  __attribute__((__nothrow__)) float __logf(float __x ) ;
#line 107
extern  __attribute__((__nothrow__)) float log10f(float __x ) ;
#line 107
extern  __attribute__((__nothrow__)) float __log10f(float __x ) ;
#line 110
extern  __attribute__((__nothrow__)) float modff(float __x , float *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) float __modff(float __x , float *__iptr ) ;
#line 119
extern  __attribute__((__nothrow__)) float expm1f(float __x ) ;
#line 119
extern  __attribute__((__nothrow__)) float __expm1f(float __x ) ;
#line 122
extern  __attribute__((__nothrow__)) float log1pf(float __x ) ;
#line 122
extern  __attribute__((__nothrow__)) float __log1pf(float __x ) ;
#line 125
extern  __attribute__((__nothrow__)) float logbf(float __x ) ;
#line 125
extern  __attribute__((__nothrow__)) float __logbf(float __x ) ;
#line 130
extern  __attribute__((__nothrow__)) float exp2f(float __x ) ;
#line 130
extern  __attribute__((__nothrow__)) float __exp2f(float __x ) ;
#line 133
extern  __attribute__((__nothrow__)) float log2f(float __x ) ;
#line 133
extern  __attribute__((__nothrow__)) float __log2f(float __x ) ;
#line 140
extern  __attribute__((__nothrow__)) float powf(float __x , float __y ) ;
#line 140
extern  __attribute__((__nothrow__)) float __powf(float __x , float __y ) ;
#line 143
extern  __attribute__((__nothrow__)) float sqrtf(float __x ) ;
#line 143
extern  __attribute__((__nothrow__)) float __sqrtf(float __x ) ;
#line 147
extern  __attribute__((__nothrow__)) float hypotf(float __x , float __y ) ;
#line 147
extern  __attribute__((__nothrow__)) float __hypotf(float __x , float __y ) ;
#line 152
extern  __attribute__((__nothrow__)) float cbrtf(float __x ) ;
#line 152
extern  __attribute__((__nothrow__)) float __cbrtf(float __x ) ;
#line 159
extern  __attribute__((__nothrow__)) float ceilf(float __x ) ;
#line 159
extern  __attribute__((__nothrow__)) float __ceilf(float __x ) ;
#line 162
extern  __attribute__((__nothrow__)) float fabsf(float __x ) ;
#line 162
extern  __attribute__((__nothrow__)) float __fabsf(float __x ) ;
#line 165
extern  __attribute__((__nothrow__)) float floorf(float __x ) ;
#line 165
extern  __attribute__((__nothrow__)) float __floorf(float __x ) ;
#line 168
extern  __attribute__((__nothrow__)) float fmodf(float __x , float __y ) ;
#line 168
extern  __attribute__((__nothrow__)) float __fmodf(float __x , float __y ) ;
#line 177
extern  __attribute__((__nothrow__)) int isinff(float __value ) ;
#line 183
extern  __attribute__((__nothrow__)) int finitef(float __value ) ;
#line 187
extern  __attribute__((__nothrow__)) float dremf(float __x , float __y ) ;
#line 187
extern  __attribute__((__nothrow__)) float __dremf(float __x , float __y ) ;
#line 191
extern  __attribute__((__nothrow__)) float significandf(float __x ) ;
#line 191
extern  __attribute__((__nothrow__)) float __significandf(float __x ) ;
#line 198
extern  __attribute__((__nothrow__)) float copysignf(float __x , float __y ) ;
#line 198
extern  __attribute__((__nothrow__)) float __copysignf(float __x , float __y ) ;
#line 203
extern  __attribute__((__nothrow__)) float nanf(char const   *__tagb ) ;
#line 203
extern  __attribute__((__nothrow__)) float __nanf(char const   *__tagb ) ;
#line 213
extern  __attribute__((__nothrow__)) int isnanf(float __value ) ;
#line 220
extern  __attribute__((__nothrow__)) float j0f(float  ) ;
#line 220
extern  __attribute__((__nothrow__)) float __j0f(float  ) ;
#line 221
extern  __attribute__((__nothrow__)) float j1f(float  ) ;
#line 221
extern  __attribute__((__nothrow__)) float __j1f(float  ) ;
#line 222
extern  __attribute__((__nothrow__)) float jnf(int  , float  ) ;
#line 222
extern  __attribute__((__nothrow__)) float __jnf(int  , float  ) ;
#line 223
extern  __attribute__((__nothrow__)) float y0f(float  ) ;
#line 223
extern  __attribute__((__nothrow__)) float __y0f(float  ) ;
#line 224
extern  __attribute__((__nothrow__)) float y1f(float  ) ;
#line 224
extern  __attribute__((__nothrow__)) float __y1f(float  ) ;
#line 225
extern  __attribute__((__nothrow__)) float ynf(int  , float  ) ;
#line 225
extern  __attribute__((__nothrow__)) float __ynf(int  , float  ) ;
#line 231
extern  __attribute__((__nothrow__)) float erff(float  ) ;
#line 231
extern  __attribute__((__nothrow__)) float __erff(float  ) ;
#line 232
extern  __attribute__((__nothrow__)) float erfcf(float  ) ;
#line 232
extern  __attribute__((__nothrow__)) float __erfcf(float  ) ;
#line 233
extern  __attribute__((__nothrow__)) float lgammaf(float  ) ;
#line 233
extern  __attribute__((__nothrow__)) float __lgammaf(float  ) ;
#line 238
extern  __attribute__((__nothrow__)) float tgammaf(float  ) ;
#line 238
extern  __attribute__((__nothrow__)) float __tgammaf(float  ) ;
#line 244
extern  __attribute__((__nothrow__)) float gammaf(float  ) ;
#line 244
extern  __attribute__((__nothrow__)) float __gammaf(float  ) ;
#line 252
extern  __attribute__((__nothrow__)) float lgammaf_r(float  , int *__signgamp ) ;
#line 252
extern  __attribute__((__nothrow__)) float __lgammaf_r(float  , int *__signgamp ) ;
#line 259
extern  __attribute__((__nothrow__)) float rintf(float __x ) ;
#line 259
extern  __attribute__((__nothrow__)) float __rintf(float __x ) ;
#line 262
extern  __attribute__((__nothrow__)) float nextafterf(float __x , float __y ) ;
#line 262
extern  __attribute__((__nothrow__)) float __nextafterf(float __x , float __y ) ;
#line 264
extern  __attribute__((__nothrow__)) float nexttowardf(float __x , long double __y ) ;
#line 264
extern  __attribute__((__nothrow__)) float __nexttowardf(float __x , long double __y ) ;
#line 275
extern  __attribute__((__nothrow__)) float remainderf(float __x , float __y ) ;
#line 275
extern  __attribute__((__nothrow__)) float __remainderf(float __x , float __y ) ;
#line 279
extern  __attribute__((__nothrow__)) float scalbnf(float __x , int __n ) ;
#line 279
extern  __attribute__((__nothrow__)) float __scalbnf(float __x , int __n ) ;
#line 283
extern  __attribute__((__nothrow__)) int ilogbf(float __x ) ;
#line 283
extern  __attribute__((__nothrow__)) int __ilogbf(float __x ) ;
#line 293
extern  __attribute__((__nothrow__)) float scalblnf(float __x , long __n ) ;
#line 293
extern  __attribute__((__nothrow__)) float __scalblnf(float __x , long __n ) ;
#line 297
extern  __attribute__((__nothrow__)) float nearbyintf(float __x ) ;
#line 297
extern  __attribute__((__nothrow__)) float __nearbyintf(float __x ) ;
#line 301
extern  __attribute__((__nothrow__)) float roundf(float __x ) ;
#line 301
extern  __attribute__((__nothrow__)) float __roundf(float __x ) ;
#line 305
extern  __attribute__((__nothrow__)) float truncf(float __x ) ;
#line 305
extern  __attribute__((__nothrow__)) float __truncf(float __x ) ;
#line 310
extern  __attribute__((__nothrow__)) float remquof(float __x , float __y , int *__quo ) ;
#line 310
extern  __attribute__((__nothrow__)) float __remquof(float __x , float __y , int *__quo ) ;
#line 317
extern  __attribute__((__nothrow__)) long lrintf(float __x ) ;
#line 317
extern  __attribute__((__nothrow__)) long __lrintf(float __x ) ;
#line 319
extern  __attribute__((__nothrow__)) long long llrintf(float __x ) ;
#line 319
extern  __attribute__((__nothrow__)) long long __llrintf(float __x ) ;
#line 323
extern  __attribute__((__nothrow__)) long lroundf(float __x ) ;
#line 323
extern  __attribute__((__nothrow__)) long __lroundf(float __x ) ;
#line 325
extern  __attribute__((__nothrow__)) long long llroundf(float __x ) ;
#line 325
extern  __attribute__((__nothrow__)) long long __llroundf(float __x ) ;
#line 329
extern  __attribute__((__nothrow__)) float fdimf(float __x , float __y ) ;
#line 329
extern  __attribute__((__nothrow__)) float __fdimf(float __x , float __y ) ;
#line 333
extern  __attribute__((__nothrow__)) float fmaxf(float __x , float __y ) ;
#line 333
extern  __attribute__((__nothrow__)) float __fmaxf(float __x , float __y ) ;
#line 336
extern  __attribute__((__nothrow__)) float fminf(float __x , float __y ) ;
#line 336
extern  __attribute__((__nothrow__)) float __fminf(float __x , float __y ) ;
#line 340
extern  __attribute__((__nothrow__)) float fmaf(float __x , float __y , float __z ) ;
#line 340
extern  __attribute__((__nothrow__)) float __fmaf(float __x , float __y , float __z ) ;
#line 435
extern  __attribute__((__nothrow__)) float scalbf(float __x , float __n ) ;
#line 435
extern  __attribute__((__nothrow__)) float __scalbf(float __x , float __n ) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassifyl(long double __value ) ;
#line 24
extern  __attribute__((__nothrow__)) int __signbitl(long double __value ) ;
#line 29
extern  __attribute__((__nothrow__)) int __isinfl(long double __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finitel(long double __value ) ;
#line 37
extern  __attribute__((__nothrow__)) int __isnanl(long double __value ) ;
#line 41
extern  __attribute__((__nothrow__)) int __iseqsigl(long double __x , long double __y ) ;
#line 44
extern  __attribute__((__nothrow__)) int __issignalingl(long double __value ) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) long double acosl(long double __x ) ;
#line 53
extern  __attribute__((__nothrow__)) long double __acosl(long double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) long double asinl(long double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) long double __asinl(long double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) long double atanl(long double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) long double __atanl(long double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) long double atan2l(long double __y , long double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) long double __atan2l(long double __y , long double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) long double cosl(long double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) long double __cosl(long double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) long double sinl(long double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) long double __sinl(long double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) long double tanl(long double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) long double __tanl(long double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) long double coshl(long double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) long double __coshl(long double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) long double sinhl(long double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) long double __sinhl(long double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) long double tanhl(long double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) long double __tanhl(long double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) long double acoshl(long double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) long double __acoshl(long double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) long double asinhl(long double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) long double __asinhl(long double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) long double atanhl(long double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) long double __atanhl(long double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) long double expl(long double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) long double __expl(long double __x ) ;
#line 98
extern  __attribute__((__nothrow__)) long double frexpl(long double __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) long double __frexpl(long double __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) long double ldexpl(long double __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) long double __ldexpl(long double __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) long double logl(long double __x ) ;
#line 104
extern  __attribute__((__nothrow__)) long double __logl(long double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) long double log10l(long double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) long double __log10l(long double __x ) ;
#line 110
extern  __attribute__((__nothrow__)) long double modfl(long double __x , long double *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) long double __modfl(long double __x , long double *__iptr ) ;
#line 119
extern  __attribute__((__nothrow__)) long double expm1l(long double __x ) ;
#line 119
extern  __attribute__((__nothrow__)) long double __expm1l(long double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) long double log1pl(long double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) long double __log1pl(long double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) long double logbl(long double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) long double __logbl(long double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) long double exp2l(long double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) long double __exp2l(long double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) long double log2l(long double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) long double __log2l(long double __x ) ;
#line 140
extern  __attribute__((__nothrow__)) long double powl(long double __x , long double __y ) ;
#line 140
extern  __attribute__((__nothrow__)) long double __powl(long double __x , long double __y ) ;
#line 143
extern  __attribute__((__nothrow__)) long double sqrtl(long double __x ) ;
#line 143
extern  __attribute__((__nothrow__)) long double __sqrtl(long double __x ) ;
#line 147
extern  __attribute__((__nothrow__)) long double hypotl(long double __x , long double __y ) ;
#line 147
extern  __attribute__((__nothrow__)) long double __hypotl(long double __x , long double __y ) ;
#line 152
extern  __attribute__((__nothrow__)) long double cbrtl(long double __x ) ;
#line 152
extern  __attribute__((__nothrow__)) long double __cbrtl(long double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) long double ceill(long double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) long double __ceill(long double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) long double fabsl(long double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) long double __fabsl(long double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) long double floorl(long double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) long double __floorl(long double __x ) ;
#line 168
extern  __attribute__((__nothrow__)) long double fmodl(long double __x , long double __y ) ;
#line 168
extern  __attribute__((__nothrow__)) long double __fmodl(long double __x , long double __y ) ;
#line 177
extern  __attribute__((__nothrow__)) int isinfl(long double __value ) ;
#line 183
extern  __attribute__((__nothrow__)) int finitel(long double __value ) ;
#line 187
extern  __attribute__((__nothrow__)) long double dreml(long double __x , long double __y ) ;
#line 187
extern  __attribute__((__nothrow__)) long double __dreml(long double __x , long double __y ) ;
#line 191
extern  __attribute__((__nothrow__)) long double significandl(long double __x ) ;
#line 191
extern  __attribute__((__nothrow__)) long double __significandl(long double __x ) ;
#line 198
extern  __attribute__((__nothrow__)) long double copysignl(long double __x , long double __y ) ;
#line 198
extern  __attribute__((__nothrow__)) long double __copysignl(long double __x , long double __y ) ;
#line 203
extern  __attribute__((__nothrow__)) long double nanl(char const   *__tagb ) ;
#line 203
extern  __attribute__((__nothrow__)) long double __nanl(char const   *__tagb ) ;
#line 213
extern  __attribute__((__nothrow__)) int isnanl(long double __value ) ;
#line 220
extern  __attribute__((__nothrow__)) long double j0l(long double  ) ;
#line 220
extern  __attribute__((__nothrow__)) long double __j0l(long double  ) ;
#line 221
extern  __attribute__((__nothrow__)) long double j1l(long double  ) ;
#line 221
extern  __attribute__((__nothrow__)) long double __j1l(long double  ) ;
#line 222
extern  __attribute__((__nothrow__)) long double jnl(int  , long double  ) ;
#line 222
extern  __attribute__((__nothrow__)) long double __jnl(int  , long double  ) ;
#line 223
extern  __attribute__((__nothrow__)) long double y0l(long double  ) ;
#line 223
extern  __attribute__((__nothrow__)) long double __y0l(long double  ) ;
#line 224
extern  __attribute__((__nothrow__)) long double y1l(long double  ) ;
#line 224
extern  __attribute__((__nothrow__)) long double __y1l(long double  ) ;
#line 225
extern  __attribute__((__nothrow__)) long double ynl(int  , long double  ) ;
#line 225
extern  __attribute__((__nothrow__)) long double __ynl(int  , long double  ) ;
#line 231
extern  __attribute__((__nothrow__)) long double erfl(long double  ) ;
#line 231
extern  __attribute__((__nothrow__)) long double __erfl(long double  ) ;
#line 232
extern  __attribute__((__nothrow__)) long double erfcl(long double  ) ;
#line 232
extern  __attribute__((__nothrow__)) long double __erfcl(long double  ) ;
#line 233
extern  __attribute__((__nothrow__)) long double lgammal(long double  ) ;
#line 233
extern  __attribute__((__nothrow__)) long double __lgammal(long double  ) ;
#line 238
extern  __attribute__((__nothrow__)) long double tgammal(long double  ) ;
#line 238
extern  __attribute__((__nothrow__)) long double __tgammal(long double  ) ;
#line 244
extern  __attribute__((__nothrow__)) long double gammal(long double  ) ;
#line 244
extern  __attribute__((__nothrow__)) long double __gammal(long double  ) ;
#line 252
extern  __attribute__((__nothrow__)) long double lgammal_r(long double  , int *__signgamp ) ;
#line 252
extern  __attribute__((__nothrow__)) long double __lgammal_r(long double  , int *__signgamp ) ;
#line 259
extern  __attribute__((__nothrow__)) long double rintl(long double __x ) ;
#line 259
extern  __attribute__((__nothrow__)) long double __rintl(long double __x ) ;
#line 262
extern  __attribute__((__nothrow__)) long double nextafterl(long double __x , long double __y ) ;
#line 262
extern  __attribute__((__nothrow__)) long double __nextafterl(long double __x , long double __y ) ;
#line 264
extern  __attribute__((__nothrow__)) long double nexttowardl(long double __x , long double __y ) ;
#line 264
extern  __attribute__((__nothrow__)) long double __nexttowardl(long double __x , long double __y ) ;
#line 275
extern  __attribute__((__nothrow__)) long double remainderl(long double __x , long double __y ) ;
#line 275
extern  __attribute__((__nothrow__)) long double __remainderl(long double __x , long double __y ) ;
#line 279
extern  __attribute__((__nothrow__)) long double scalbnl(long double __x , int __n ) ;
#line 279
extern  __attribute__((__nothrow__)) long double __scalbnl(long double __x , int __n ) ;
#line 283
extern  __attribute__((__nothrow__)) int ilogbl(long double __x ) ;
#line 283
extern  __attribute__((__nothrow__)) int __ilogbl(long double __x ) ;
#line 293
extern  __attribute__((__nothrow__)) long double scalblnl(long double __x , long __n ) ;
#line 293
extern  __attribute__((__nothrow__)) long double __scalblnl(long double __x , long __n ) ;
#line 297
extern  __attribute__((__nothrow__)) long double nearbyintl(long double __x ) ;
#line 297
extern  __attribute__((__nothrow__)) long double __nearbyintl(long double __x ) ;
#line 301
extern  __attribute__((__nothrow__)) long double roundl(long double __x ) ;
#line 301
extern  __attribute__((__nothrow__)) long double __roundl(long double __x ) ;
#line 305
extern  __attribute__((__nothrow__)) long double truncl(long double __x ) ;
#line 305
extern  __attribute__((__nothrow__)) long double __truncl(long double __x ) ;
#line 310
extern  __attribute__((__nothrow__)) long double remquol(long double __x , long double __y ,
                                                         int *__quo ) ;
#line 310
extern  __attribute__((__nothrow__)) long double __remquol(long double __x , long double __y ,
                                                           int *__quo ) ;
#line 317
extern  __attribute__((__nothrow__)) long lrintl(long double __x ) ;
#line 317
extern  __attribute__((__nothrow__)) long __lrintl(long double __x ) ;
#line 319
extern  __attribute__((__nothrow__)) long long llrintl(long double __x ) ;
#line 319
extern  __attribute__((__nothrow__)) long long __llrintl(long double __x ) ;
#line 323
extern  __attribute__((__nothrow__)) long lroundl(long double __x ) ;
#line 323
extern  __attribute__((__nothrow__)) long __lroundl(long double __x ) ;
#line 325
extern  __attribute__((__nothrow__)) long long llroundl(long double __x ) ;
#line 325
extern  __attribute__((__nothrow__)) long long __llroundl(long double __x ) ;
#line 329
extern  __attribute__((__nothrow__)) long double fdiml(long double __x , long double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) long double __fdiml(long double __x , long double __y ) ;
#line 333
extern  __attribute__((__nothrow__)) long double fmaxl(long double __x , long double __y ) ;
#line 333
extern  __attribute__((__nothrow__)) long double __fmaxl(long double __x , long double __y ) ;
#line 336
extern  __attribute__((__nothrow__)) long double fminl(long double __x , long double __y ) ;
#line 336
extern  __attribute__((__nothrow__)) long double __fminl(long double __x , long double __y ) ;
#line 340
extern  __attribute__((__nothrow__)) long double fmal(long double __x , long double __y ,
                                                      long double __z ) ;
#line 340
extern  __attribute__((__nothrow__)) long double __fmal(long double __x , long double __y ,
                                                        long double __z ) ;
#line 435
extern  __attribute__((__nothrow__)) long double scalbl(long double __x , long double __n ) ;
#line 435
extern  __attribute__((__nothrow__)) long double __scalbl(long double __x , long double __n ) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassifyf128(int __value ) ;
#line 24
extern  __attribute__((__nothrow__)) int __signbitf128(int __value ) ;
#line 29
extern  __attribute__((__nothrow__)) int __isinff128(int __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finitef128(int __value ) ;
#line 37
extern  __attribute__((__nothrow__)) int __isnanf128(int __value ) ;
#line 41
extern  __attribute__((__nothrow__)) int __iseqsigf128(int __x , int __y ) ;
#line 44
extern  __attribute__((__nothrow__)) int __issignalingf128(int __value ) ;
#line 854 "/usr/include/math.h"
extern int signgam ;
#line 19 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/logreport.h"
gboolean logging ;
#line 16 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/image-proc.h"
at_distance_map new_distance_map(at_bitmap *bitmap , unsigned char target_value ,
                                 gboolean padded , at_exception_type *exp___0 ) ;
#line 19
void free_distance_map(at_distance_map *dist ) ;
#line 40 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/image-proc.c"
at_distance_map new_distance_map(at_bitmap *bitmap , unsigned char target_value ,
                                 gboolean padded , at_exception_type *exp___0 ) 
{ 
  int x ;
  int y ;
  float d ;
  float min ;
  at_distance_map dist ;
  unsigned char *b ;
  unsigned int w ;
  unsigned int h ;
  unsigned int spp ;
  void *__cil_tmp14 ;
  int tmp ;
  void *__cil_tmp16 ;
  int tmp___0 ;
  void *__cil_tmp18 ;
  int tmp___1 ;
  void *__cil_tmp20 ;
  int tmp___2 ;
  int __cil_tmp22 ;
  int gray ;
  float fgray ;
  float tmp___3 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int gray___0 ;
  float fgray___0 ;
  float tmp___4 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;

  {
#line 45
  b = bitmap->bitmap;
#line 46
  w = (unsigned int )bitmap->width;
#line 47
  h = (unsigned int )bitmap->height;
#line 48
  spp = bitmap->np;
#line 50
  dist.height = h;
#line 51
  dist.width = w;
  {
#line 52
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 52
    __cil_tmp14 = malloc((unsigned long )h * sizeof(float *));
#line 52
    dist.d = (gpointer )__cil_tmp14;
    }
#line 52
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 53
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 53
    __cil_tmp16 = malloc((unsigned long )h * sizeof(float *));
#line 53
    dist.weight = (gpointer )__cil_tmp16;
    }
#line 53
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 54
  y = 0;
  {
#line 54
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 54
    if (! (y < (int )h)) {
#line 54
      goto while_break___1;
    }
    {
#line 55
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 55
      __cil_tmp18 = calloc((unsigned long )w * sizeof(float ), (unsigned long )1);
#line 55
      *(dist.d + y) = (gpointer )__cil_tmp18;
      }
#line 55
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 56
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 56
      __cil_tmp20 = malloc((unsigned long )w * sizeof(float ));
#line 56
      *(dist.weight + y) = (gpointer )__cil_tmp20;
      }
#line 56
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 54
    y ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 59
  if (spp == 3U) {
#line 60
    y = 0;
    {
#line 60
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 60
      if (! (y < (int )h)) {
#line 60
        goto while_break___4;
      }
#line 61
      x = 0;
      {
#line 61
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 61
        if (! (x < (int )w)) {
#line 61
          goto while_break___5;
        }
#line 64
        gray = (int )((((double )((int )*(b + 0)) * 0.3 + (double )((int )*(b + 1)) * 0.59) + (double )((int )*(b + 2)) * 0.110000000001) + 0.5);
#line 65
        if (gray == (int )target_value) {
#line 65
          tmp___3 = 0.f;
        } else {
#line 65
          tmp___3 = 10000000000.f;
        }
#line 65
        *(*(dist.d + y) + x) = tmp___3;
#line 66
        fgray = (float )gray * 0.00392156839371f;
#line 67
        *(*(dist.weight + y) + x) = 1.f - fgray;
#line 61
        b += spp;
#line 61
        __cil_tmp26 = x;
#line 61
        x ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 60
      y ++;
    }
    while_break___4: /* CIL Label */ ;
    }
  } else {
#line 73
    y = 0;
    {
#line 73
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 73
      if (! (y < (int )h)) {
#line 73
        goto while_break___6;
      }
#line 74
      x = 0;
      {
#line 74
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 74
        if (! (x < (int )w)) {
#line 74
          goto while_break___7;
        }
#line 77
        gray___0 = (int )*(b + 0);
#line 78
        if (gray___0 == (int )target_value) {
#line 78
          tmp___4 = 0.f;
        } else {
#line 78
          tmp___4 = 10000000000.f;
        }
#line 78
        *(*(dist.d + y) + x) = tmp___4;
#line 79
        fgray___0 = (float )gray___0 * 0.00392156839371f;
#line 80
        *(*(dist.weight + y) + x) = 1.f - fgray___0;
#line 74
        b += spp;
#line 74
        __cil_tmp31 = x;
#line 74
        x ++;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 73
      y ++;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
#line 89
  if (padded) {
#line 90
    y = 0;
    {
#line 90
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 90
      if (! (y < (int )h)) {
#line 90
        goto while_break___8;
      }
#line 91
      if (*(*(dist.d + y) + 0) > *(*(dist.weight + y) + 0)) {
#line 92
        *(*(dist.d + y) + 0) = *(*(dist.weight + y) + 0);
      }
#line 93
      if (*(*(dist.d + y) + (w - 1U)) > *(*(dist.weight + y) + (w - 1U))) {
#line 94
        *(*(dist.d + y) + (w - 1U)) = *(*(dist.weight + y) + (w - 1U));
      }
#line 90
      y ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 96
    x = 0;
    {
#line 96
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 96
      if (! (x < (int )w)) {
#line 96
        goto while_break___9;
      }
#line 97
      if (*(*(dist.d + 0) + x) > *(*(dist.weight + 0) + x)) {
#line 98
        *(*(dist.d + 0) + x) = *(*(dist.weight + 0) + x);
      }
#line 99
      if (*(*(dist.d + (h - 1U)) + x) > *(*(dist.weight + (h - 1U)) + x)) {
#line 100
        *(*(dist.d + (h - 1U)) + x) = *(*(dist.weight + (h - 1U)) + x);
      }
#line 96
      x ++;
    }
    while_break___9: /* CIL Label */ ;
    }
  }
#line 112
  y = 1;
  {
#line 112
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 112
    if (! (y < (int )h)) {
#line 112
      goto while_break___10;
    }
#line 113
    x = 1;
    {
#line 113
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 113
      if (! (x < (int )w)) {
#line 113
        goto while_break___11;
      }
#line 114
      if (*(*(dist.d + y) + x) == 0.f) {
#line 115
        goto while_continue___11;
      }
#line 117
      min = *(*(dist.d + y) + x);
#line 120
      d = *(*(dist.d + (y - 1)) + (x - 1)) + (float )1.41421356238 * *(*(dist.weight + y) + x);
#line 121
      if (d < min) {
#line 122
        *(*(dist.d + y) + x) = d;
#line 122
        min = *(*(dist.d + y) + x);
      }
#line 125
      d = *(*(dist.d + (y - 1)) + x) + *(*(dist.weight + y) + x);
#line 126
      if (d < min) {
#line 127
        *(*(dist.d + y) + x) = d;
#line 127
        min = *(*(dist.d + y) + x);
      }
#line 130
      d = *(*(dist.d + y) + (x - 1)) + *(*(dist.weight + y) + x);
#line 131
      if (d < min) {
#line 132
        *(*(dist.d + y) + x) = d;
#line 132
        min = *(*(dist.d + y) + x);
      }
#line 135
      if (x + 1 < (int )w) {
#line 136
        d = *(*(dist.d + (y - 1)) + (x + 1)) + (float )1.41421356238 * *(*(dist.weight + y) + x);
#line 137
        if (d < min) {
#line 138
          *(*(dist.d + y) + x) = d;
#line 138
          min = *(*(dist.d + y) + x);
        }
      }
#line 113
      x ++;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 112
    y ++;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 144
  y = (int )(h - 2U);
  {
#line 144
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 144
    if (! (y >= 0)) {
#line 144
      goto while_break___12;
    }
#line 145
    x = (int )(w - 2U);
    {
#line 145
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 145
      if (! (x >= 0)) {
#line 145
        goto while_break___13;
      }
#line 146
      min = *(*(dist.d + y) + x);
#line 149
      d = *(*(dist.d + (y + 1)) + (x + 1)) + (float )1.41421356238 * *(*(dist.weight + y) + x);
#line 150
      if (d < min) {
#line 151
        *(*(dist.d + y) + x) = d;
#line 151
        min = *(*(dist.d + y) + x);
      }
#line 154
      d = *(*(dist.d + (y + 1)) + x) + *(*(dist.weight + y) + x);
#line 155
      if (d < min) {
#line 156
        *(*(dist.d + y) + x) = d;
#line 156
        min = *(*(dist.d + y) + x);
      }
#line 159
      d = *(*(dist.d + y) + (x + 1)) + *(*(dist.weight + y) + x);
#line 160
      if (d < min) {
#line 161
        *(*(dist.d + y) + x) = d;
#line 161
        min = *(*(dist.d + y) + x);
      }
#line 164
      if (x - 1 >= 0) {
#line 165
        d = *(*(dist.d + (y + 1)) + (x - 1)) + (float )1.41421356238 * *(*(dist.weight + y) + x);
#line 166
        if (d < min) {
#line 167
          *(*(dist.d + y) + x) = d;
#line 167
          min = *(*(dist.d + y) + x);
        }
      }
#line 145
      __cil_tmp37 = x;
#line 145
      x --;
    }
    while_break___13: /* CIL Label */ ;
    }
#line 144
    __cil_tmp38 = y;
#line 144
    y --;
  }
  while_break___12: /* CIL Label */ ;
  }
#line 171
  return (dist);
}
}
#line 176 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/image-proc.c"
void free_distance_map(at_distance_map *dist ) 
{ 
  unsigned int y ;
  unsigned int h ;
  unsigned int __cil_tmp4 ;
  unsigned int __cil_tmp5 ;

  {
#line 180
  if (! dist) {
#line 181
    return;
  }
#line 183
  h = dist->height;
#line 185
  if (dist->d != (void *)0) {
#line 186
    y = (unsigned int )0;
    {
#line 186
    while (1) {
      while_continue: /* CIL Label */ ;
#line 186
      if (! (y < h)) {
#line 186
        goto while_break;
      }
      {
#line 187
      free((gpointer *)*(dist->d + y));
      }
#line 186
      y ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 188
    free((gpointer *)dist->d);
    }
  }
#line 190
  if (dist->weight != (void *)0) {
#line 191
    y = (unsigned int )0;
    {
#line 191
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 191
      if (! (y < h)) {
#line 191
        goto while_break___0;
      }
      {
#line 192
      free((gpointer *)*(dist->weight + y));
      }
#line 191
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 193
    free((gpointer *)dist->weight);
    }
  }
  return;
}
}
#line 291 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/image-proc.c"
void binarize(at_bitmap *bitmap ) 
{ 
  unsigned int i ;
  unsigned int npixels ;
  unsigned int spp ;
  unsigned char *b ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned int __cil_tmp9 ;
  unsigned char *rgb ;
  int tmp___2 ;
  unsigned int __cil_tmp12 ;
  gpointer new_mem ;
  void *__cil_tmp14 ;
  int tmp___3 ;
  void *__cil_tmp16 ;
  int tmp___4 ;

  {
#line 299
  b = bitmap->bitmap;
#line 300
  spp = bitmap->np;
#line 301
  npixels = (unsigned int )((int )bitmap->width * (int )bitmap->height);
#line 303
  if (spp == 1U) {
#line 304
    i = (unsigned int )0;
    {
#line 304
    while (1) {
      while_continue: /* CIL Label */ ;
#line 304
      if (! (i < npixels)) {
#line 304
        goto while_break;
      }
#line 305
      if ((int )*(b + i) > 225) {
#line 305
        tmp___1 = 255;
      } else {
#line 305
        tmp___1 = 0;
      }
#line 305
      *(b + i) = (unsigned char )tmp___1;
#line 304
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 306
  if (spp == 3U) {
#line 307
    rgb = b;
#line 308
    i = (unsigned int )0;
    {
#line 308
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 308
      if (! (i < npixels)) {
#line 308
        goto while_break___0;
      }
#line 309
      if ((((double )((int )*(rgb + 0)) * 0.3 + (double )((int )*(rgb + 1)) * 0.59) + (double )((int )*(rgb + 2)) * 0.110000000001) + 0.5 > (double )225) {
#line 309
        tmp___2 = 255;
      } else {
#line 309
        tmp___2 = 0;
      }
#line 309
      *(b + i) = (unsigned char )tmp___2;
#line 308
      rgb += 3;
#line 308
      __cil_tmp12 = i;
#line 308
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 311
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 311
      if (bitmap->bitmap == (void *)0) {
        {
#line 311
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 311
          __cil_tmp14 = malloc((unsigned long )npixels);
#line 311
          new_mem = (gpointer )__cil_tmp14;
          }
#line 311
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
      } else {
        {
#line 311
        __cil_tmp16 = realloc(bitmap->bitmap, (unsigned long )npixels);
#line 311
        new_mem = (gpointer )__cil_tmp16;
        }
      }
#line 311
      bitmap->bitmap = new_mem;
#line 311
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 312
    bitmap->np = (unsigned int )1;
  } else {
    {
#line 314
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 314
      fputs("warning: ", stderr);
      }
      {
#line 314
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 314
        if (logging) {
          {
#line 314
          fprintf(stdout, "warning: ");
          }
        }
#line 314
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 314
      fprintf(stderr, "binarize: %u-plane images are not supported\005\027V", spp);
      }
      {
#line 314
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 314
        if (logging) {
          {
#line 314
          fprintf(stdout, "binarize: %u-plane images are not supported\005\027V",
                  spp);
          }
        }
#line 314
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 314
      fputs(".\n", stderr);
      }
#line 314
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  return;
}
}
#line 808 "/usr/include/glib-2.0/gobject/gobject.h"
__inline static void g_assert_finalize_object___1(GObject *object ) 
{ 
  gpointer weak_pointer ;
  long __cil_tmp3 ;
  long __cil_tmp4 ;

  {
#line 810
  weak_pointer = object;
  {
#line 812
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 812
    __cil_tmp3 = __builtin_expect((long )0, (long )1);
    }
#line 812
    if (__cil_tmp3) {

    } else {
      {
#line 812
      g_assertion_message((char const   *)((gchar *)0), "/usr/include/glib-2.0/gobject/gobject.h",
                          812, (char const   *)"g_assert_finalize_object\312\001@",
                          "\'G_IS_OBJECT (weak_pointer)\' should be TRUE");
      }
    }
#line 812
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 813
  g_object_add_weak_pointer(object, & weak_pointer);
#line 814
  g_object_unref(weak_pointer);
  }
  {
#line 815
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 815
    __cil_tmp4 = __builtin_expect((long )0, (long )1);
    }
#line 815
    if (__cil_tmp4) {

    } else {
      {
#line 815
      g_assertion_message((char const   *)((gchar *)0), "/usr/include/glib-2.0/gobject/gobject.h",
                          815, (char const   *)"g_assert_finalize_object\312\001@\006\314\256\b",
                          "\'weak_pointer\' should be NULLV");
      }
    }
#line 815
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 7 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/exception.c"
at_exception_type at_exception_new(at_msg_func client_func , gpointer client_data ) 
{ 
  at_exception_type e ;

  {
#line 10
  e.msg_type = (at_msg_type )0;
#line 11
  e.client_func = client_func;
#line 12
  e.client_data = client_data;
#line 13
  return (e);
}
}
#line 16 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/exception.c"
gboolean at_exception_got_fatal(at_exception_type *exception ) 
{ 
  int tmp ;

  {
#line 18
  if ((unsigned int )exception->msg_type == 1U) {
#line 18
    tmp = ! 0;
  } else {
#line 18
    tmp = 0;
  }
#line 18
  return (tmp);
}
}
#line 21 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/exception.c"
void at_exception_fatal(at_exception_type *exception , gchar *message ) 
{ 


  {
#line 23
  if (! exception) {
#line 24
    return;
  }
#line 25
  exception->msg_type = (at_msg_type )1;
#line 26
  if (exception->client_func) {
    {
#line 27
    (*(exception->client_func))(message, (at_msg_type )1, exception->client_data);
    }
  }
  return;
}
}
#line 31 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/exception.c"
void at_exception_warning(at_exception_type *exception , gchar *message ) 
{ 


  {
#line 33
  if (! exception) {
#line 34
    return;
  }
#line 35
  exception->msg_type = (at_msg_type )2;
#line 36
  if (exception->client_func) {
    {
#line 37
    (*(exception->client_func))(message, (at_msg_type )2, exception->client_data);
    }
  }
  return;
}
}
#line 41 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/exception.c"
GQuark at_error_quark(void) 
{ 
  static GQuark q ;
  GQuark __cil_tmp2 ;

  {
#line 43
  q = (GQuark )0;
#line 44
  if (q == 0U) {
    {
#line 45
    q = g_quark_from_static_string((gchar *)"at-error-quark");
    }
  }
#line 46
  return (q);
}
}
#line 52 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/despeckle.h"
void despeckle(at_bitmap *bitmap , int level , gfloat tightness , gfloat noise_removal ,
               at_exception_type *excep ) ;
#line 43 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/despeckle.c"
static int calc_error(unsigned char *color1 , unsigned char *color2 ) 
{ 
  int the_error ;
  int temp ;

  {
#line 48
  temp = (int )*(color1 + 0) - (int )*(color2 + 0);
#line 49
  the_error = temp * temp;
#line 50
  temp = (int )*(color1 + 1) - (int )*(color2 + 1);
#line 51
  the_error += temp * temp;
#line 52
  temp = (int )*(color1 + 2) - (int )*(color2 + 2);
#line 53
  the_error += temp * temp;
#line 55
  return (the_error);
}
}
#line 67 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/despeckle.c"
static int calc_error_8(unsigned char *color1 , unsigned char *color2 ) 
{ 
  int the_error ;
  int __cil_tmp4 ;

  {
  {
#line 71
  the_error = abs((int )*(color1 + 0) - (int )*(color2 + 0));
  }
#line 73
  return (the_error);
}
}
#line 89 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/despeckle.c"
static int find_size(unsigned char *index___0 , int x , int y , int width , int height ,
                     unsigned char *bitmap , unsigned char *mask ) 
{ 
  int count ;
  int x1 ;
  int x2 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;

  {
#line 100
  if (y < 0) {
#line 101
    return (0);
  } else
#line 100
  if (y >= height) {
#line 101
    return (0);
  } else
#line 100
  if ((int )*(mask + (y * width + x)) == 1) {
#line 101
    return (0);
  } else
#line 100
  if ((int )*(bitmap + 3 * (y * width + x)) != (int )*(index___0 + 0)) {
#line 101
    return (0);
  } else
#line 100
  if ((int )*(bitmap + (3 * (y * width + x) + 1)) != (int )*(index___0 + 1)) {
#line 101
    return (0);
  } else
#line 100
  if ((int )*(bitmap + (3 * (y * width + x) + 2)) != (int )*(index___0 + 2)) {
#line 101
    return (0);
  }
#line 103
  x1 = x;
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    if (! ((((x1 >= 0 && (int )*(bitmap + 3 * (y * width + x1)) == (int )*(index___0 + 0)) && (int )*(bitmap + (3 * (y * width + x1) + 1)) == (int )*(index___0 + 1)) && (int )*(bitmap + (3 * (y * width + x1) + 2)) == (int )*(index___0 + 2)) && (int )*(mask + (y * width + x)) != 1)) {
#line 103
      goto while_break;
    }

#line 103
    __cil_tmp11 = x1;
#line 103
    x1 --;
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  x1 ++;
#line 106
  x2 = x;
  {
#line 106
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 106
    if (! ((((x2 < width && (int )*(bitmap + 3 * (y * width + x2)) == (int )*(index___0 + 0)) && (int )*(bitmap + (3 * (y * width + x2) + 1)) == (int )*(index___0 + 1)) && (int )*(bitmap + (3 * (y * width + x2) + 2)) == (int )*(index___0 + 2)) && (int )*(mask + (y * width + x)) != 1)) {
#line 106
      goto while_break___0;
    }

#line 106
    x2 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 107
  __cil_tmp14 = x2;
#line 107
  x2 --;
#line 109
  count = (x2 - x1) + 1;
#line 110
  x = x1;
  {
#line 110
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 110
    if (! (x <= x2)) {
#line 110
      goto while_break___1;
    }
#line 111
    *(mask + (y * width + x)) = (unsigned char )1;
#line 110
    x ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 113
  x = x1;
  {
#line 113
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 113
    if (! (x <= x2)) {
#line 113
      goto while_break___2;
    }
    {
#line 114
    __cil_tmp16 = find_size(index___0, x, y - 1, width, height, bitmap, mask);
    }
    {
#line 114
    count += __cil_tmp16;
#line 115
    __cil_tmp17 = find_size(index___0, x, y + 1, width, height, bitmap, mask);
    }
#line 115
    count += __cil_tmp17;
#line 113
    x ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 118
  return (count);
}
}
#line 134 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/despeckle.c"
static int find_size_8(unsigned char *index___0 , int x , int y , int width , int height ,
                       unsigned char *bitmap , unsigned char *mask ) 
{ 
  int count ;
  int x1 ;
  int x2 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;

  {
#line 145
  if (y < 0) {
#line 146
    return (0);
  } else
#line 145
  if (y >= height) {
#line 146
    return (0);
  } else
#line 145
  if ((int )*(mask + (y * width + x)) == 1) {
#line 146
    return (0);
  } else
#line 145
  if ((int )*(bitmap + (y * width + x)) != (int )*(index___0 + 0)) {
#line 146
    return (0);
  }
#line 148
  x1 = x;
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
#line 148
    if (! ((x1 >= 0 && (int )*(bitmap + (y * width + x1)) == (int )*(index___0 + 0)) && (int )*(mask + (y * width + x)) != 1)) {
#line 148
      goto while_break;
    }

#line 148
    __cil_tmp11 = x1;
#line 148
    x1 --;
  }
  while_break: /* CIL Label */ ;
  }
#line 149
  x1 ++;
#line 151
  x2 = x;
  {
#line 151
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 151
    if (! ((x2 < width && (int )*(bitmap + (y * width + x2)) == (int )*(index___0 + 0)) && (int )*(mask + (y * width + x)) != 1)) {
#line 151
      goto while_break___0;
    }

#line 151
    x2 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 152
  __cil_tmp14 = x2;
#line 152
  x2 --;
#line 154
  count = (x2 - x1) + 1;
#line 155
  x = x1;
  {
#line 155
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 155
    if (! (x <= x2)) {
#line 155
      goto while_break___1;
    }
#line 156
    *(mask + (y * width + x)) = (unsigned char )1;
#line 155
    x ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 158
  x = x1;
  {
#line 158
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 158
    if (! (x <= x2)) {
#line 158
      goto while_break___2;
    }
    {
#line 159
    __cil_tmp16 = find_size_8(index___0, x, y - 1, width, height, bitmap, mask);
    }
    {
#line 159
    count += __cil_tmp16;
#line 160
    __cil_tmp17 = find_size_8(index___0, x, y + 1, width, height, bitmap, mask);
    }
#line 160
    count += __cil_tmp17;
#line 158
    x ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 163
  return (count);
}
}
#line 182 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/despeckle.c"
static void find_most_similar_neighbor(unsigned char *index___0 , unsigned char **closest_index ,
                                       int *error_amt , int x , int y , int width ,
                                       int height , unsigned char *bitmap , unsigned char *mask ) 
{ 
  int x1 ;
  int x2 ;
  int temp_error ;
  unsigned char *value ;
  unsigned char *temp ;
  int tmp ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;

  {
#line 196
  if (y < 0) {
#line 197
    return;
  } else
#line 196
  if (y >= height) {
#line 197
    return;
  } else
#line 196
  if ((int )*(mask + (y * width + x)) == 2) {
#line 197
    return;
  }
#line 199
  temp = bitmap + 3 * (y * width + x);
#line 203
  if ((int )*(temp + 0) != (int )*(index___0 + 0)) {
    _L: /* CIL Label */ 
    _L___0: /* CIL Label */ 
    {
#line 204
    value = temp;
#line 206
    temp_error = calc_error(index___0, value);
    }
#line 208
    if (*closest_index == (void *)0) {
#line 209
      *error_amt = temp_error;
#line 209
      *closest_index = value;
    } else
#line 208
    if (temp_error < *error_amt) {
#line 209
      *error_amt = temp_error;
#line 209
      *closest_index = value;
    }
#line 211
    return;
  } else
#line 203
  if ((int )*(temp + 1) != (int )*(index___0 + 1)) {
#line 203
    goto _L;
  } else
#line 203
  if ((int )*(temp + 2) != (int )*(index___0 + 2)) {
#line 203
    goto _L;
  }
#line 214
  x1 = x;
  {
#line 214
  while (1) {
    while_continue: /* CIL Label */ ;
#line 214
    if (! (((x1 >= 0 && (int )*(bitmap + 3 * (y * width + x1)) == (int )*(index___0 + 0)) && (int )*(bitmap + (3 * (y * width + x1) + 1)) == (int )*(index___0 + 1)) && (int )*(bitmap + (3 * (y * width + x1) + 2)) == (int )*(index___0 + 2))) {
#line 214
      goto while_break;
    }

#line 214
    __cil_tmp17 = x1;
#line 214
    x1 --;
  }
  while_break: /* CIL Label */ ;
  }
#line 215
  x1 ++;
#line 217
  x2 = x;
  {
#line 217
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 217
    if (! (((x2 < width && (int )*(bitmap + 3 * (y * width + x2)) == (int )*(index___0 + 0)) && (int )*(bitmap + (3 * (y * width + x2) + 1)) == (int )*(index___0 + 1)) && (int )*(bitmap + (3 * (y * width + x2) + 2)) == (int )*(index___0 + 2))) {
#line 217
      goto while_break___0;
    }

#line 217
    x2 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 218
  __cil_tmp20 = x2;
#line 218
  x2 --;
#line 220
  if (x1 > 0) {
    {
#line 221
    value = bitmap + 3 * ((y * width + x1) - 1);
#line 223
    temp_error = calc_error(index___0, value);
    }
#line 225
    if (*closest_index == (void *)0) {
#line 226
      *error_amt = temp_error;
#line 226
      *closest_index = value;
    } else
#line 225
    if (temp_error < *error_amt) {
#line 226
      *error_amt = temp_error;
#line 226
      *closest_index = value;
    }
  }
#line 229
  if (x2 < width - 1) {
    {
#line 230
    value = bitmap + 3 * ((y * width + x2) + 1);
#line 232
    temp_error = calc_error(index___0, value);
    }
#line 234
    if (*closest_index == (void *)0) {
#line 235
      *error_amt = temp_error;
#line 235
      *closest_index = value;
    } else
#line 234
    if (temp_error < *error_amt) {
#line 235
      *error_amt = temp_error;
#line 235
      *closest_index = value;
    }
  }
#line 238
  x = x1;
  {
#line 238
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 238
    if (! (x <= x2)) {
#line 238
      goto while_break___1;
    }
#line 239
    *(mask + (y * width + x)) = (unsigned char )2;
#line 238
    x ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 241
  x = x1;
  {
#line 241
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 241
    if (! (x <= x2)) {
#line 241
      goto while_break___2;
    }
    {
#line 242
    find_most_similar_neighbor(index___0, closest_index, error_amt, x, y - 1, width,
                               height, bitmap, mask);
#line 243
    find_most_similar_neighbor(index___0, closest_index, error_amt, x, y + 1, width,
                               height, bitmap, mask);
    }
#line 241
    x ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  return;
}
}
#line 263 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/despeckle.c"
static void find_most_similar_neighbor_8(unsigned char *index___0 , unsigned char **closest_index ,
                                         int *error_amt , int x , int y , int width ,
                                         int height , unsigned char *bitmap , unsigned char *mask ) 
{ 
  int x1 ;
  int x2 ;
  int temp_error ;
  unsigned char *value ;
  unsigned char *temp ;
  int tmp ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;

  {
#line 277
  if (y < 0) {
#line 278
    return;
  } else
#line 277
  if (y >= height) {
#line 278
    return;
  } else
#line 277
  if ((int )*(mask + (y * width + x)) == 2) {
#line 278
    return;
  }
#line 280
  temp = bitmap + (y * width + x);
#line 284
  if ((int )*(temp + 0) != (int )*(index___0 + 0)) {
    {
#line 285
    value = temp;
#line 287
    temp_error = calc_error_8(index___0, value);
    }
#line 289
    if (*closest_index == (void *)0) {
#line 290
      *error_amt = temp_error;
#line 290
      *closest_index = value;
    } else
#line 289
    if (temp_error < *error_amt) {
#line 290
      *error_amt = temp_error;
#line 290
      *closest_index = value;
    }
#line 292
    return;
  }
#line 295
  x1 = x;
  {
#line 295
  while (1) {
    while_continue: /* CIL Label */ ;
#line 295
    if (! (x1 >= 0 && (int )*(bitmap + (y * width + x1)) == (int )*(index___0 + 0))) {
#line 295
      goto while_break;
    }

#line 295
    __cil_tmp17 = x1;
#line 295
    x1 --;
  }
  while_break: /* CIL Label */ ;
  }
#line 296
  x1 ++;
#line 298
  x2 = x;
  {
#line 298
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 298
    if (! (x2 < width && (int )*(bitmap + (y * width + x2)) == (int )*(index___0 + 0))) {
#line 298
      goto while_break___0;
    }

#line 298
    x2 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 299
  __cil_tmp20 = x2;
#line 299
  x2 --;
#line 301
  if (x1 > 0) {
    {
#line 302
    value = bitmap + ((y * width + x1) - 1);
#line 304
    temp_error = calc_error_8(index___0, value);
    }
#line 306
    if (*closest_index == (void *)0) {
#line 307
      *error_amt = temp_error;
#line 307
      *closest_index = value;
    } else
#line 306
    if (temp_error < *error_amt) {
#line 307
      *error_amt = temp_error;
#line 307
      *closest_index = value;
    }
  }
#line 310
  if (x2 < width - 1) {
    {
#line 311
    value = bitmap + ((y * width + x2) + 1);
#line 313
    temp_error = calc_error_8(index___0, value);
    }
#line 315
    if (*closest_index == (void *)0) {
#line 316
      *error_amt = temp_error;
#line 316
      *closest_index = value;
    } else
#line 315
    if (temp_error < *error_amt) {
#line 316
      *error_amt = temp_error;
#line 316
      *closest_index = value;
    }
  }
#line 319
  x = x1;
  {
#line 319
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 319
    if (! (x <= x2)) {
#line 319
      goto while_break___1;
    }
#line 320
    *(mask + (y * width + x)) = (unsigned char )2;
#line 319
    x ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 322
  x = x1;
  {
#line 322
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 322
    if (! (x <= x2)) {
#line 322
      goto while_break___2;
    }
    {
#line 323
    find_most_similar_neighbor_8(index___0, closest_index, error_amt, x, y - 1, width,
                                 height, bitmap, mask);
#line 324
    find_most_similar_neighbor_8(index___0, closest_index, error_amt, x, y + 1, width,
                                 height, bitmap, mask);
    }
#line 322
    x ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  return;
}
}
#line 337 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/despeckle.c"
static void fill(unsigned char *to_index , int x , int y , int width , int height ,
                 unsigned char *bitmap , unsigned char *mask ) 
{ 
  int x1 ;
  int x2 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int tmp ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;

  {
#line 347
  if (y < 0) {
#line 348
    return;
  } else
#line 347
  if (y >= height) {
#line 348
    return;
  } else
#line 347
  if ((int )*(mask + (y * width + x)) != 2) {
#line 348
    return;
  }
#line 350
  x1 = x;
  {
#line 350
  while (1) {
    while_continue: /* CIL Label */ ;
#line 350
    if (! (x1 >= 0 && (int )*(mask + (y * width + x1)) == 2)) {
#line 350
      goto while_break;
    }

#line 350
    __cil_tmp10 = x1;
#line 350
    x1 --;
  }
  while_break: /* CIL Label */ ;
  }
#line 351
  x1 ++;
#line 352
  x2 = x;
  {
#line 352
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 352
    if (! (x2 < width && (int )*(mask + (y * width + x2)) == 2)) {
#line 352
      goto while_break___0;
    }

#line 352
    x2 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 353
  __cil_tmp13 = x2;
#line 353
  x2 --;
#line 357
  x = x1;
  {
#line 357
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 357
    if (! (x <= x2)) {
#line 357
      goto while_break___1;
    }
#line 358
    *(bitmap + 3 * (y * width + x)) = *(to_index + 0);
#line 359
    *(bitmap + (3 * (y * width + x) + 1)) = *(to_index + 1);
#line 360
    *(bitmap + (3 * (y * width + x) + 2)) = *(to_index + 2);
#line 361
    *(mask + (y * width + x)) = (unsigned char )3;
#line 357
    x ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 364
  x = x1;
  {
#line 364
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 364
    if (! (x <= x2)) {
#line 364
      goto while_break___2;
    }
    {
#line 365
    fill(to_index, x, y - 1, width, height, bitmap, mask);
#line 366
    fill(to_index, x, y + 1, width, height, bitmap, mask);
    }
#line 364
    x ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  return;
}
}
#line 379 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/despeckle.c"
static void fill_8(unsigned char *to_index , int x , int y , int width , int height ,
                   unsigned char *bitmap , unsigned char *mask ) 
{ 
  int x1 ;
  int x2 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int tmp ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;

  {
#line 389
  if (y < 0) {
#line 390
    return;
  } else
#line 389
  if (y >= height) {
#line 390
    return;
  } else
#line 389
  if ((int )*(mask + (y * width + x)) != 2) {
#line 390
    return;
  }
#line 392
  x1 = x;
  {
#line 392
  while (1) {
    while_continue: /* CIL Label */ ;
#line 392
    if (! (x1 >= 0 && (int )*(mask + (y * width + x1)) == 2)) {
#line 392
      goto while_break;
    }

#line 392
    __cil_tmp10 = x1;
#line 392
    x1 --;
  }
  while_break: /* CIL Label */ ;
  }
#line 393
  x1 ++;
#line 394
  x2 = x;
  {
#line 394
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 394
    if (! (x2 < width && (int )*(mask + (y * width + x2)) == 2)) {
#line 394
      goto while_break___0;
    }

#line 394
    x2 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 395
  __cil_tmp13 = x2;
#line 395
  x2 --;
#line 399
  x = x1;
  {
#line 399
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 399
    if (! (x <= x2)) {
#line 399
      goto while_break___1;
    }
#line 400
    *(bitmap + (y * width + x)) = *(to_index + 0);
#line 401
    *(mask + (y * width + x)) = (unsigned char )3;
#line 399
    x ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 404
  x = x1;
  {
#line 404
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 404
    if (! (x <= x2)) {
#line 404
      goto while_break___2;
    }
    {
#line 405
    fill_8(to_index, x, y - 1, width, height, bitmap, mask);
#line 406
    fill_8(to_index, x, y + 1, width, height, bitmap, mask);
    }
#line 404
    x ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  return;
}
}
#line 416 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/despeckle.c"
static void ignore(int x , int y , int width , int height , unsigned char *mask ) 
{ 
  int x1 ;
  int x2 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int tmp ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;

  {
#line 424
  if (y < 0) {
#line 425
    return;
  } else
#line 424
  if (y >= height) {
#line 425
    return;
  } else
#line 424
  if ((int )*(mask + (y * width + x)) != 1) {
#line 425
    return;
  }
#line 427
  x1 = x;
  {
#line 427
  while (1) {
    while_continue: /* CIL Label */ ;
#line 427
    if (! (x1 >= 0 && (int )*(mask + (y * width + x1)) == 1)) {
#line 427
      goto while_break;
    }

#line 427
    __cil_tmp8 = x1;
#line 427
    x1 --;
  }
  while_break: /* CIL Label */ ;
  }
#line 428
  x1 ++;
#line 429
  x2 = x;
  {
#line 429
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 429
    if (! (x2 < width && (int )*(mask + (y * width + x2)) == 1)) {
#line 429
      goto while_break___0;
    }

#line 429
    x2 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 430
  __cil_tmp11 = x2;
#line 430
  x2 --;
#line 434
  x = x1;
  {
#line 434
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 434
    if (! (x <= x2)) {
#line 434
      goto while_break___1;
    }
#line 435
    *(mask + (y * width + x)) = (unsigned char )3;
#line 434
    x ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 437
  x = x1;
  {
#line 437
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 437
    if (! (x <= x2)) {
#line 437
      goto while_break___2;
    }
    {
#line 438
    ignore(x, y - 1, width, height, mask);
#line 439
    ignore(x, y + 1, width, height, mask);
    }
#line 437
    x ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  return;
}
}
#line 461 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/despeckle.c"
static gboolean recolor(double adaptive_tightness , int x , int y , int width , int height ,
                        unsigned char *bitmap , unsigned char *mask ) 
{ 
  unsigned char *index___1 ;
  unsigned char *to_index ;
  int error_amt ;
  int max_error ;
  int __cil_tmp12 ;

  {
  {
#line 472
  index___1 = bitmap + 3 * (y * width + x);
#line 473
  to_index = (unsigned char *)((void *)0);
#line 474
  error_amt = 0;
#line 475
  max_error = (int )((3. * adaptive_tightness) * adaptive_tightness);
#line 477
  find_most_similar_neighbor(index___1, & to_index, & error_amt, x, y, width, height,
                             bitmap, mask);
  }
#line 480
  if (to_index != (void *)0) {
    {
#line 487
    __cil_tmp12 = calc_error(index___1, to_index);
    }
#line 487
    if (__cil_tmp12 > max_error) {
      {
#line 488
      fill(index___1, x, y, width, height, bitmap, mask);
      }
    } else {
      {
#line 490
      fill(to_index, x, y, width, height, bitmap, mask);
      }
#line 492
      return (! 0);
    }
  }
#line 496
  return (0);
}
}
#line 517 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/despeckle.c"
static gboolean recolor_8(double adaptive_tightness , int x , int y , int width ,
                          int height , unsigned char *bitmap , unsigned char *mask ) 
{ 
  unsigned char *index___2 ;
  unsigned char *to_index ;
  int error_amt ;
  int __cil_tmp11 ;

  {
  {
#line 528
  index___2 = bitmap + (y * width + x);
#line 529
  to_index = (unsigned char *)((void *)0);
#line 530
  error_amt = 0;
#line 532
  find_most_similar_neighbor_8(index___2, & to_index, & error_amt, x, y, width, height,
                               bitmap, mask);
  }
#line 535
  if (to_index != (void *)0) {
    {
#line 542
    __cil_tmp11 = calc_error_8(index___2, to_index);
    }
#line 542
    if ((double )__cil_tmp11 > adaptive_tightness) {
      {
#line 543
      fill_8(index___2, x, y, width, height, bitmap, mask);
      }
    } else {
      {
#line 545
      fill_8(to_index, x, y, width, height, bitmap, mask);
      }
#line 547
      return (! 0);
    }
  }
#line 551
  return (0);
}
}
#line 565 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/despeckle.c"
static void despeckle_iteration(int level , double adaptive_tightness , double noise_max ,
                                int width , int height , unsigned char *bitmap ) 
{ 
  unsigned char *mask ;
  int x ;
  int y ;
  int current_size ;
  int tightness ;
  void *__cil_tmp12 ;
  int size ;
  int __cil_tmp14 ;
  int tmp ;
  gboolean __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;

  {
  {
#line 578
  current_size = 1 << level;
#line 579
  tightness = (int )(noise_max / (1. + adaptive_tightness * (double )level));
#line 581
  __cil_tmp12 = calloc((unsigned long )(width * height), sizeof(unsigned char ));
#line 581
  mask = (unsigned char *)__cil_tmp12;
#line 582
  y = 0;
  }
  {
#line 582
  while (1) {
    while_continue: /* CIL Label */ ;
#line 582
    if (! (y < height)) {
#line 582
      goto while_break;
    }
#line 583
    x = 0;
    {
#line 583
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 583
      if (! (x < width)) {
#line 583
        goto while_break___0;
      }
#line 584
      if ((int )*(mask + (y * width + x)) == 0) {
        {
#line 587
        size = find_size(bitmap + 3 * (y * width + x), x, y, width, height, bitmap,
                         mask);
        }
#line 591
        if (size < current_size) {
          {
#line 592
          __cil_tmp16 = recolor((double )tightness, x, y, width, height, bitmap, mask);
          }
#line 592
          if (__cil_tmp16) {
#line 593
            __cil_tmp17 = x;
#line 593
            x --;
          }
        } else {
          {
#line 595
          ignore(x, y, width, height, mask);
          }
        }
      }
#line 583
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 582
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 600
  free(mask);
  }
  return;
}
}
#line 614 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/despeckle.c"
static void despeckle_iteration_8(int level , double adaptive_tightness , double noise_max ,
                                  int width , int height , unsigned char *bitmap ) 
{ 
  unsigned char *mask ;
  int x ;
  int y ;
  int current_size ;
  int tightness ;
  void *__cil_tmp12 ;
  int size ;
  int __cil_tmp14 ;
  int tmp ;
  gboolean __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;

  {
  {
#line 627
  current_size = 1 << level;
#line 628
  tightness = (int )(noise_max / (1. + adaptive_tightness * (double )level));
#line 630
  __cil_tmp12 = calloc((unsigned long )(width * height), sizeof(unsigned char ));
#line 630
  mask = (unsigned char *)__cil_tmp12;
#line 631
  y = 0;
  }
  {
#line 631
  while (1) {
    while_continue: /* CIL Label */ ;
#line 631
    if (! (y < height)) {
#line 631
      goto while_break;
    }
#line 632
    x = 0;
    {
#line 632
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 632
      if (! (x < width)) {
#line 632
        goto while_break___0;
      }
#line 633
      if ((int )*(mask + (y * width + x)) == 0) {
        {
#line 636
        size = find_size_8(bitmap + (y * width + x), x, y, width, height, bitmap,
                           mask);
        }
#line 640
        if (size < current_size) {
          {
#line 641
          __cil_tmp16 = recolor_8((double )tightness, x, y, width, height, bitmap,
                                  mask);
          }
#line 641
          if (__cil_tmp16) {
#line 642
            __cil_tmp17 = x;
#line 642
            x --;
          }
        } else {
          {
#line 644
          ignore(x, y, width, height, mask);
          }
        }
      }
#line 632
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 631
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 649
  free(mask);
  }
  return;
}
}
#line 677 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/despeckle.c"
void despeckle(at_bitmap *bitmap , int level , gfloat tightness , gfloat noise_removal ,
               at_exception_type *excep ) 
{ 
  int i ;
  int planes ;
  int max_level ;
  short width ;
  short height ;
  unsigned char *bits ;
  double noise_max ;
  double adaptive_tightness ;
  double __cil_tmp14 ;
  double __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;

  {
  {
#line 688
  planes = (int )bitmap->np;
#line 689
  noise_max = (double )noise_removal * 255.;
#line 690
  width = (short )bitmap->width;
#line 691
  height = (short )bitmap->height;
#line 692
  bits = bitmap->bitmap;
#line 693
  __cil_tmp15 = log(2.);
  }
  {
#line 693
  __cil_tmp14 = log((double )((int )width * (int )height));
#line 693
  max_level = (int )(__cil_tmp14 / __cil_tmp15 - 0.5);
  }
#line 694
  if (level > max_level) {
#line 695
    level = max_level;
  }
#line 696
  adaptive_tightness = ((double )noise_removal * (1. + (double )(tightness * (float )level)) - 1.) / (double )level;
#line 698
  if (planes == 3) {
#line 699
    i = 0;
    {
#line 699
    while (1) {
      while_continue: /* CIL Label */ ;
#line 699
      if (! (i < level)) {
#line 699
        goto while_break;
      }
      {
#line 700
      despeckle_iteration(i, adaptive_tightness, noise_max, (int )width, (int )height,
                          bits);
      }
#line 699
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 701
  if (planes == 1) {
#line 702
    i = 0;
    {
#line 702
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 702
      if (! (i < level)) {
#line 702
        goto while_break___0;
      }
      {
#line 703
      despeckle_iteration_8(i, adaptive_tightness, noise_max, (int )width, (int )height,
                            bits);
      }
#line 702
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 705
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 705
      if (logging) {
        {
#line 705
        fprintf(stdout, "despeckle: %u-plane images are not supported", planes);
        }
      }
#line 705
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 706
    at_exception_fatal(excep, (gchar *)"despeckle: wrong plane images are passed\320!S\006\027V");
    }
#line 707
    return;
  }
  return;
}
}
#line 28 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/filename.h"
gchar *find_suffix(gchar *name ) ;
#line 32
gchar *extend_filename(gchar *name , gchar *default_suffix ) ;
#line 37
gchar *make_suffix(gchar *s , gchar *new_suffix ) ;
#line 40
gchar *remove_suffix(gchar *s ) ;
#line 33 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/filename.c"
static gchar *substring(gchar *source , unsigned int start , unsigned int limit ) ;
#line 36
static gchar *concat3(gchar *s1 , gchar *s2 , gchar *s3 ) ;
#line 38 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/filename.c"
gchar *find_suffix(gchar *name ) 
{ 
  gchar *dot_pos ;
  char *__cil_tmp3 ;
  gchar *slash_pos ;
  char *__cil_tmp5 ;
  gchar *tmp ;

  {
  {
#line 40
  __cil_tmp3 = strrchr((char const   *)name, '.');
#line 40
  dot_pos = __cil_tmp3;
#line 44
  __cil_tmp5 = strrchr((char const   *)name, '/');
#line 44
  slash_pos = __cil_tmp5;
  }
#line 48
  if (dot_pos == (void *)0 || dot_pos < slash_pos) {
#line 48
    tmp = (gchar *)((void *)0);
  } else {
#line 48
    tmp = dot_pos + 1;
  }
#line 48
  return (tmp);
}
}
#line 51 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/filename.c"
gchar *extend_filename(gchar *name , gchar *default_suffix ) 
{ 
  gchar *new_s ;
  gchar *suffix ;
  gchar *__cil_tmp5 ;
  gchar *__cil_tmp6 ;
  gchar *tmp ;

  {
  {
#line 54
  __cil_tmp5 = find_suffix(name);
#line 54
  suffix = __cil_tmp5;
  }
#line 56
  if (suffix == (void *)0) {
    {
#line 56
    __cil_tmp6 = concat3(name, ".", default_suffix);
#line 56
    tmp = __cil_tmp6;
    }
  } else {
#line 56
    tmp = name;
  }
#line 56
  new_s = tmp;
#line 57
  return (new_s);
}
}
#line 60 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/filename.c"
gchar *make_suffix(gchar *s , gchar *new_suffix ) 
{ 
  gchar *new_s ;
  gchar *old_suffix ;
  gchar *__cil_tmp5 ;
  gchar *__cil_tmp6 ;
  size_t length_through_dot ;
  unsigned long __cil_tmp8 ;
  void *__cil_tmp9 ;
  int tmp ;

  {
  {
#line 63
  __cil_tmp5 = find_suffix(s);
#line 63
  old_suffix = __cil_tmp5;
  }
#line 65
  if (old_suffix == (void *)0) {
    {
#line 66
    new_s = concat3(s, ".", new_suffix);
    }
  } else {
#line 68
    length_through_dot = (size_t )(old_suffix - s);
    {
#line 70
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 70
      __cil_tmp8 = strlen((char const   *)new_suffix);
#line 70
      __cil_tmp9 = malloc((length_through_dot + __cil_tmp8) + 1UL);
#line 70
      new_s = (gpointer )__cil_tmp9;
      }
#line 70
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 71
    strncpy(new_s, (char const   *)s, length_through_dot);
#line 72
    strcpy(new_s + length_through_dot, (char const   *)new_suffix);
    }
  }
#line 75
  return (new_s);
}
}
#line 78 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/filename.c"
gchar *remove_suffix(gchar *s ) 
{ 
  gchar *suffix ;
  gchar *__cil_tmp3 ;
  gchar *__cil_tmp4 ;
  gchar *tmp ;
  gchar *tmp___0 ;

  {
  {
#line 80
  __cil_tmp3 = find_suffix(s);
#line 80
  suffix = __cil_tmp3;
  }
#line 82
  if (suffix == (void *)0) {
#line 82
    tmp___0 = s;
  } else {
#line 82
    if ((suffix - 2) - s < 0L) {
#line 82
      tmp = (gchar *)((void *)0);
    } else {
      {
#line 82
      __cil_tmp4 = substring(s, (unsigned int )0, (unsigned int )((suffix - 2) - s));
#line 82
      tmp = __cil_tmp4;
      }
    }
#line 82
    tmp___0 = tmp;
  }
#line 82
  return (tmp___0);
}
}
#line 86 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/filename.c"
static gchar *substring(gchar *source , unsigned int start , unsigned int limit ) 
{ 
  gchar *result ;
  unsigned int this_char ;
  size_t length ;
  unsigned long __cil_tmp7 ;
  size_t lim ;
  void *__cil_tmp9 ;
  int tmp ;
  unsigned int __cil_tmp11 ;

  {
  {
#line 90
  __cil_tmp7 = strlen((char const   *)source);
#line 90
  length = __cil_tmp7;
#line 91
  lim = (size_t )limit;
  }
#line 94
  if (lim >= length) {
#line 95
    lim = length - 1UL;
  }
#line 98
  if ((unsigned long )start > lim) {
#line 99
    return ("\220");
  }
  {
#line 102
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 102
    __cil_tmp9 = malloc((lim - (unsigned long )start) + 2UL);
#line 102
    result = (gpointer )__cil_tmp9;
    }
#line 102
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  this_char = start;
  {
#line 104
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 104
    if (! ((unsigned long )this_char <= lim)) {
#line 104
      goto while_break___0;
    }
#line 105
    *(result + (this_char - start)) = *(source + this_char);
#line 104
    this_char ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 107
  *(result + (this_char - start)) = (gchar )0;
#line 109
  return (result);
}
}
#line 112 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/filename.c"
static gchar *concat3(gchar *s1 , gchar *s2 , gchar *s3 ) 
{ 
  gchar *answer ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  void *__cil_tmp8 ;
  int tmp ;

  {
  {
#line 115
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 115
    __cil_tmp7 = strlen((char const   *)s3);
    }
    {
#line 115
    __cil_tmp6 = strlen((char const   *)s2);
    }
    {
#line 115
    __cil_tmp5 = strlen((char const   *)s1);
#line 115
    __cil_tmp8 = malloc(((__cil_tmp5 + __cil_tmp6) + __cil_tmp7) + 1UL);
#line 115
    answer = (gpointer )__cil_tmp8;
    }
#line 115
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 116
  strcpy(answer, (char const   *)s1);
#line 117
  strcat(answer, (char const   *)s2);
#line 118
  strcat(answer, (char const   *)s3);
  }
#line 120
  return (answer);
}
}
#line 9 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/logreport.c"
gboolean logging  =    0;
#line 37 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern  __attribute__((__nothrow__)) char *realpath(char const   *__name ,
                                                             char *__resolved )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 37 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern char *realpath(char const   *__name , char *__resolved ) 
{ 
  size_t sz ;
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 39
  __cil_tmp4 = __builtin_object_size(__resolved, 1);
#line 39
  sz = __cil_tmp4;
  }
#line 41
  if (sz == 0xffffffffffffffffUL) {
    {
#line 42
    __cil_tmp5 = __realpath_alias(__name, __resolved);
    }
#line 42
    return (__cil_tmp5);
  }
  {
#line 48
  __cil_tmp6 = __realpath_chk(__name, __resolved, sz);
  }
#line 48
  return (__cil_tmp6);
}
}
#line 808 "/usr/include/glib-2.0/gobject/gobject.h"
__inline static void g_assert_finalize_object___3(GObject *object ) 
{ 
  gpointer weak_pointer ;
  long __cil_tmp3 ;
  long __cil_tmp4 ;

  {
#line 810
  weak_pointer = object;
  {
#line 812
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 812
    __cil_tmp3 = __builtin_expect((long )0, (long )1);
    }
#line 812
    if (__cil_tmp3) {

    } else {
      {
#line 812
      g_assertion_message((char const   *)((gchar *)0), "/usr/include/glib-2.0/gobject/gobject.h",
                          812, (char const   *)"g_assert_finalize_object\312\001@",
                          "\'G_IS_OBJECT (weak_pointer)\' should be TRUE");
      }
    }
#line 812
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 813
  g_object_add_weak_pointer(object, & weak_pointer);
#line 814
  g_object_unref(weak_pointer);
  }
  {
#line 815
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 815
    __cil_tmp4 = __builtin_expect((long )0, (long )1);
    }
#line 815
    if (__cil_tmp4) {

    } else {
      {
#line 815
      g_assertion_message((char const   *)((gchar *)0), "/usr/include/glib-2.0/gobject/gobject.h",
                          815, (char const   *)"g_assert_finalize_object\312\001@",
                          "\'weak_pointer\' should be NULLV");
      }
    }
#line 815
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 34 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/thin-image.h"
void thin_image(at_bitmap *image , at_color *bg , at_exception_type *exp___0 ) ;
#line 39 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/thin-image.c"
void thin3(at_bitmap *image , Pixel colour ) ;
#line 40
void thin1(at_bitmap *image , unsigned char colour ) ;
#line 55 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/thin-image.c"
static unsigned int masks[4]  = {      (unsigned int )128,      (unsigned int )2,      (unsigned int )32,      (unsigned int )8};
#line 67 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/thin-image.c"
static unsigned char todelete[512]  = 
#line 67
  {      (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )1, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )1,      (unsigned char )1, 
        (unsigned char )0,      (unsigned char )1,      (unsigned char )1,      (unsigned char )1, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )1,      (unsigned char )1, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )1,      (unsigned char )1, 
        (unsigned char )1,      (unsigned char )0,      (unsigned char )1,      (unsigned char )1, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )1,      (unsigned char )1, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )1,      (unsigned char )1, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )1,      (unsigned char )1,      (unsigned char )1,      (unsigned char )1, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )1,      (unsigned char )1, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )1,      (unsigned char )1, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )1,      (unsigned char )1, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )1,      (unsigned char )1,      (unsigned char )1,      (unsigned char )1, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )1,      (unsigned char )1, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )1,      (unsigned char )0,      (unsigned char )1,      (unsigned char )1, 
        (unsigned char )1,      (unsigned char )0,      (unsigned char )1,      (unsigned char )1, 
        (unsigned char )1,      (unsigned char )1,      (unsigned char )1,      (unsigned char )1, 
        (unsigned char )1,      (unsigned char )1,      (unsigned char )1,      (unsigned char )1, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )1,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )1,      (unsigned char )1,      (unsigned char )1,      (unsigned char )1, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )1,      (unsigned char )1, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )1,      (unsigned char )0,      (unsigned char )1,      (unsigned char )1, 
        (unsigned char )1,      (unsigned char )0,      (unsigned char )1,      (unsigned char )1, 
        (unsigned char )1,      (unsigned char )1,      (unsigned char )1,      (unsigned char )1, 
        (unsigned char )1,      (unsigned char )1,      (unsigned char )1,      (unsigned char )1, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )1,      (unsigned char )0,      (unsigned char )1,      (unsigned char )1, 
        (unsigned char )1,      (unsigned char )0,      (unsigned char )1,      (unsigned char )1, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )1,      (unsigned char )1, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )1,      (unsigned char )1, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )1,      (unsigned char )1, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )1,      (unsigned char )1, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )1,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )1,      (unsigned char )1,      (unsigned char )1,      (unsigned char )1, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )1,      (unsigned char )1, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )1,      (unsigned char )0,      (unsigned char )1,      (unsigned char )1, 
        (unsigned char )1,      (unsigned char )0,      (unsigned char )1,      (unsigned char )1, 
        (unsigned char )1,      (unsigned char )1,      (unsigned char )1,      (unsigned char )1, 
        (unsigned char )1,      (unsigned char )1,      (unsigned char )1,      (unsigned char )1, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )1,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )1,      (unsigned char )1,      (unsigned char )1,      (unsigned char )1, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )1,      (unsigned char )1, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )1,      (unsigned char )0,      (unsigned char )1,      (unsigned char )1, 
        (unsigned char )1,      (unsigned char )0,      (unsigned char )1,      (unsigned char )1, 
        (unsigned char )1,      (unsigned char )1,      (unsigned char )1,      (unsigned char )1, 
        (unsigned char )1,      (unsigned char )1,      (unsigned char )1,      (unsigned char )1};
#line 102 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/thin-image.c"
static at_color background  =    {(guint8 )255, (guint8 )255, (guint8 )255};
#line 104 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/thin-image.c"
void thin_image(at_bitmap *image , at_color *bg , at_exception_type *exp___0 ) 
{ 
  long m ;
  long n ;
  long num_pixels ;
  at_bitmap bm ;
  unsigned int spp ;
  unsigned int width ;
  unsigned int height ;
  void *__cil_tmp11 ;
  int tmp ;
  Pixel *ptr ;
  Pixel bg_color ;
  Pixel p ;
  unsigned char *ptr___0 ;
  unsigned char bg_color___0 ;
  unsigned char __cil_tmp18 ;
  unsigned char c ;

  {
#line 113
  spp = image->np;
#line 113
  width = (unsigned int )image->width;
#line 113
  height = (unsigned int )image->height;
#line 115
  if (bg) {
#line 116
    background = *bg;
  }
#line 118
  bm.height = image->height;
#line 119
  bm.width = image->width;
#line 120
  bm.np = image->np;
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 121
    __cil_tmp11 = malloc((unsigned long )((height * width) * spp));
#line 121
    bm.bitmap = (gpointer )__cil_tmp11;
    }
#line 121
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 122
  memcpy(bm.bitmap, image->bitmap, (unsigned long )((height * width) * spp));
#line 125
  num_pixels = (long )(height * width);
  }
  {
#line 127
  if (spp == (unsigned int )3) {
#line 127
    goto case_3;
  }
#line 152
  if (spp == (unsigned int )1) {
#line 152
    goto case_1;
  }
#line 175
  goto switch_default;
  case_3: /* CIL Label */ 
#line 129
  ptr = (Pixel *)bm.bitmap;
#line 131
  bg_color[0] = background.r;
#line 132
  bg_color[1] = background.g;
#line 133
  bg_color[2] = background.b;
#line 135
  n = num_pixels - 1L;
  {
#line 135
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 135
    if (! (n >= 0L)) {
#line 135
      goto while_break___0;
    }
    {
#line 138
    memcpy((unsigned char *)p, (unsigned char *)*(ptr + n), sizeof(Pixel ));
    }
#line 139
    if (! (((int )p[0] == (int )bg_color[0] && (int )p[1] == (int )bg_color[1]) && (int )p[2] == (int )bg_color[2])) {
      {
#line 141
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 141
        if (logging) {
          {
#line 141
          fprintf(stdout, "Thinning colour (%x, %x, %x)\nV", (int )p[0], (int )p[1],
                  (int )p[2]);
          }
        }
#line 141
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 142
      m = n - 1L;
      {
#line 142
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 142
        if (! (m >= 0L)) {
#line 142
          goto while_break___2;
        }
#line 143
        if ((int )(*(ptr + m))[0] == (int )p[0]) {
#line 143
          if ((int )(*(ptr + m))[1] == (int )p[1]) {
#line 143
            if ((int )(*(ptr + m))[2] == (int )p[2]) {
              {
#line 144
              memcpy((unsigned char *)*(ptr + m), (unsigned char *)bg_color, sizeof(Pixel ));
              }
            }
          }
        }
#line 142
        m --;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 146
      thin3(image, (unsigned char *)p);
      }
    }
#line 135
    n --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 149
  goto switch_break;
  case_1: /* CIL Label */ 
#line 154
  ptr___0 = bm.bitmap;
#line 157
  if ((int )background.r == (int )background.g) {
#line 157
    if ((int )background.g == (int )background.b) {
#line 158
      bg_color___0 = background.r;
    } else {
      {
      {
#line 160
      bg_color___0 = at_color_luminance(& background);
      }
      }
    }
  } else {
    {
    {
#line 160
    bg_color___0 = at_color_luminance(& background);
    }
    }
  }
#line 162
  n = num_pixels - 1L;
  {
#line 162
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 162
    if (! (n >= 0L)) {
#line 162
      goto while_break___3;
    }
#line 163
    c = *(ptr___0 + n);
#line 164
    if ((int )c != (int )bg_color___0) {
      {
#line 165
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 165
        if (logging) {
          {
#line 165
          fprintf(stdout, "Thinning colour %x\n", (int )c);
          }
        }
#line 165
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 166
      m = n - 1L;
      {
#line 166
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 166
        if (! (m >= 0L)) {
#line 166
          goto while_break___5;
        }
#line 167
        if ((int )*(ptr___0 + m) == (int )c) {
#line 168
          *(ptr___0 + m) = bg_color___0;
        }
#line 166
        m --;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 169
      thin1(image, c);
      }
    }
#line 162
    n --;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 172
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 177
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 177
    if (logging) {
      {
#line 177
      fprintf(stdout, "thin_image: %u-plane images are not supported", spp);
      }
    }
#line 177
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 178
  at_exception_fatal(exp___0, (gchar *)"thin_image: wrong plane images are passed");
  }
#line 179
  goto cleanup;
  switch_break: /* CIL Label */ ;
  }
  cleanup: 
  {
#line 183
  free(bm.bitmap);
  }
  return;
}
}
#line 186 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/thin-image.c"
void thin3(at_bitmap *image , Pixel colour ) 
{ 
  Pixel *ptr ;
  Pixel *y_ptr ;
  Pixel *y1_ptr ;
  Pixel bg_color ;
  unsigned int xsize ;
  unsigned int ysize ;
  unsigned int x ;
  unsigned int y ;
  unsigned int i ;
  unsigned int pc ;
  unsigned int count ;
  unsigned int p ;
  unsigned int q ;
  unsigned char *qb ;
  unsigned int m ;
  void *__cil_tmp18 ;
  int tmp ;
  unsigned int __cil_tmp20 ;
  unsigned int __cil_tmp21 ;
  unsigned int __cil_tmp22 ;
  unsigned int __cil_tmp23 ;
  unsigned int __cil_tmp24 ;
  unsigned int __cil_tmp25 ;
  unsigned int __cil_tmp26 ;
  unsigned int __cil_tmp27 ;
  unsigned int __cil_tmp28 ;

  {
#line 193
  pc = (unsigned int )0;
#line 194
  count = (unsigned int )1;
#line 201
  bg_color[0] = background.r;
#line 202
  bg_color[1] = background.g;
#line 203
  bg_color[2] = background.b;
  {
#line 205
  while (1) {
    while_continue: /* CIL Label */ ;
#line 205
    if (logging) {
      {
#line 205
      fprintf(stdout, " Thinning image.....\n ");
      }
    }
#line 205
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 206
  xsize = (unsigned int )image->width;
#line 207
  ysize = (unsigned int )image->height;
  {
#line 208
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 208
    __cil_tmp18 = malloc((unsigned long )xsize * sizeof(unsigned char ));
#line 208
    qb = (gpointer )__cil_tmp18;
    }
#line 208
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 209
  *(qb + (xsize - 1U)) = (unsigned char )0;
#line 210
  ptr = (Pixel *)image->bitmap;
  {
#line 212
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 212
    if (! count) {
#line 212
      goto while_break___1;
    }
#line 213
    pc ++;
#line 214
    count = (unsigned int )0;
#line 216
    i = (unsigned int )0;
    {
#line 216
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 216
      if (! (i < 4U)) {
#line 216
        goto while_break___2;
      }
#line 218
      m = masks[i];
#line 221
      p = (unsigned int )(((int )(*(ptr + 0))[0] == (int )colour[0] && (int )(*(ptr + 0))[1] == (int )colour[1]) && (int )(*(ptr + 0))[2] == (int )colour[2]);
#line 222
      x = (unsigned int )0;
      {
#line 222
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 222
        if (! (x < xsize - 1U)) {
#line 222
          goto while_break___3;
        }
#line 223
        p = ((p << 1) & 6U) | (unsigned int )(((int )(*(ptr + (x + 1U)))[0] == (int )colour[0] && (int )(*(ptr + (x + 1U)))[1] == (int )colour[1]) && (int )(*(ptr + (x + 1U)))[2] == (int )colour[2]);
#line 223
        *(qb + x) = (unsigned char )p;
#line 222
        x ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 226
      y_ptr = ptr;
#line 227
      y1_ptr = ptr + xsize;
#line 228
      y = (unsigned int )0;
      {
#line 228
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 228
        if (! (y < ysize - 1U)) {
#line 228
          goto while_break___4;
        }
#line 229
        q = (unsigned int )*(qb + 0);
#line 230
        p = ((q << 2) & 216U) | (unsigned int )(((int )(*(y1_ptr + 0))[0] == (int )colour[0] && (int )(*(y1_ptr + 0))[1] == (int )colour[1]) && (int )(*(y1_ptr + 0))[2] == (int )colour[2]);
#line 232
        x = (unsigned int )0;
        {
#line 232
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 232
          if (! (x < xsize - 1U)) {
#line 232
            goto while_break___5;
          }
#line 233
          q = (unsigned int )*(qb + x);
#line 234
          p = (((p << 1) & 438U) | ((q << 3) & 72U)) | (unsigned int )(((int )(*(y1_ptr + (x + 1U)))[0] == (int )colour[0] && (int )(*(y1_ptr + (x + 1U)))[1] == (int )colour[1]) && (int )(*(y1_ptr + (x + 1U)))[2] == (int )colour[2]);
#line 235
          *(qb + x) = (unsigned char )p;
#line 236
          if (i != 2U) {
            _L: /* CIL Label */ 
#line 236
            if ((p & m) == 0U) {
#line 236
              if ((int )todelete[p]) {
                {
#line 237
                count ++;
#line 238
                memcpy((unsigned char *)*(y_ptr + x), (unsigned char *)bg_color, sizeof(Pixel ));
                }
              }
            }
          } else
#line 236
          if (x != 0U) {
#line 236
            goto _L;
          }
#line 232
          x ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 243
        p = (p << 1) & 438U;
#line 244
        if (i != 3U) {
#line 244
          if ((p & m) == 0U) {
#line 244
            if ((int )todelete[p]) {
              {
#line 245
              count ++;
#line 246
              memcpy((unsigned char *)*(y_ptr + (xsize - 1U)), (unsigned char *)bg_color,
                     sizeof(Pixel ));
              }
            }
          }
        }
#line 228
        y1_ptr += xsize;
#line 228
        y_ptr += xsize;
#line 228
        __cil_tmp25 = y;
#line 228
        y ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 250
      if (i != 1U) {
#line 252
        q = (unsigned int )*(qb + 0);
#line 253
        p = (q << 2) & 216U;
#line 255
        y_ptr = ptr + xsize * (ysize - 1U);
#line 256
        x = (unsigned int )0;
        {
#line 256
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 256
          if (! (x < xsize)) {
#line 256
            goto while_break___6;
          }
#line 257
          q = (unsigned int )*(qb + x);
#line 258
          p = ((p << 1) & 438U) | ((q << 3) & 72U);
#line 259
          if (i != 2U) {
            _L___3: /* CIL Label */ 
#line 259
            if ((p & m) == 0U) {
#line 259
              if ((int )todelete[p]) {
                {
#line 260
                count ++;
#line 261
                memcpy((unsigned char *)*(y_ptr + x), (unsigned char *)bg_color, sizeof(Pixel ));
                }
              }
            }
          } else
#line 259
          if (x != 0U) {
#line 259
            goto _L___3;
          }
#line 256
          x ++;
        }
        while_break___6: /* CIL Label */ ;
        }
      }
#line 216
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 266
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 266
      if (logging) {
        {
#line 266
        fprintf(stdout, "ThinImage: pass %d, %d pixels deleted\n", pc, count);
        }
      }
#line 266
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 268
  free(qb);
  }
  return;
}
}
#line 271 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/thin-image.c"
void thin1(at_bitmap *image , unsigned char colour ) 
{ 
  unsigned char *ptr ;
  unsigned char *y_ptr ;
  unsigned char *y1_ptr ;
  unsigned char bg_color ;
  unsigned int xsize ;
  unsigned int ysize ;
  unsigned int x ;
  unsigned int y ;
  unsigned int i ;
  unsigned int pc ;
  unsigned int count ;
  unsigned int p ;
  unsigned int q ;
  unsigned char *qb ;
  unsigned int m ;
  unsigned char __cil_tmp18 ;
  void *__cil_tmp19 ;
  int tmp ;
  unsigned int __cil_tmp21 ;
  unsigned int __cil_tmp22 ;
  unsigned int __cil_tmp23 ;
  unsigned int __cil_tmp24 ;
  unsigned int __cil_tmp25 ;
  unsigned int __cil_tmp26 ;
  unsigned int __cil_tmp27 ;
  unsigned int __cil_tmp28 ;
  unsigned int __cil_tmp29 ;

  {
#line 278
  pc = (unsigned int )0;
#line 279
  count = (unsigned int )1;
#line 286
  if ((int )background.r == (int )background.g) {
#line 286
    if ((int )background.g == (int )background.b) {
#line 287
      bg_color = background.r;
    } else {
      {
      {
#line 289
      bg_color = at_color_luminance(& background);
      }
      }
    }
  } else {
    {
    {
#line 289
    bg_color = at_color_luminance(& background);
    }
    }
  }
  {
#line 291
  while (1) {
    while_continue: /* CIL Label */ ;
#line 291
    if (logging) {
      {
#line 291
      fprintf(stdout, " Thinning image.....\n ");
      }
    }
#line 291
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 292
  xsize = (unsigned int )image->width;
#line 293
  ysize = (unsigned int )image->height;
  {
#line 294
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 294
    __cil_tmp19 = malloc((unsigned long )xsize * sizeof(unsigned char ));
#line 294
    qb = (gpointer )__cil_tmp19;
    }
#line 294
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 295
  *(qb + (xsize - 1U)) = (unsigned char )0;
#line 296
  ptr = image->bitmap;
  {
#line 298
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 298
    if (! count) {
#line 298
      goto while_break___1;
    }
#line 299
    pc ++;
#line 300
    count = (unsigned int )0;
#line 302
    i = (unsigned int )0;
    {
#line 302
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 302
      if (! (i < 4U)) {
#line 302
        goto while_break___2;
      }
#line 304
      m = masks[i];
#line 307
      p = (unsigned int )((int )*(ptr + 0) == (int )colour);
#line 308
      x = (unsigned int )0;
      {
#line 308
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 308
        if (! (x < xsize - 1U)) {
#line 308
          goto while_break___3;
        }
#line 309
        p = ((p << 1) & 6U) | (unsigned int )((int )*(ptr + (x + 1U)) == (int )colour);
#line 309
        *(qb + x) = (unsigned char )p;
#line 308
        x ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 312
      y_ptr = ptr;
#line 313
      y1_ptr = ptr + xsize;
#line 314
      y = (unsigned int )0;
      {
#line 314
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 314
        if (! (y < ysize - 1U)) {
#line 314
          goto while_break___4;
        }
#line 315
        q = (unsigned int )*(qb + 0);
#line 316
        p = ((q << 2) & 216U) | (unsigned int )((int )*(y1_ptr + 0) == (int )colour);
#line 318
        x = (unsigned int )0;
        {
#line 318
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 318
          if (! (x < xsize - 1U)) {
#line 318
            goto while_break___5;
          }
#line 319
          q = (unsigned int )*(qb + x);
#line 320
          p = (((p << 1) & 438U) | ((q << 3) & 72U)) | (unsigned int )((int )*(y1_ptr + (x + 1U)) == (int )colour);
#line 321
          *(qb + x) = (unsigned char )p;
#line 322
          if ((p & m) == 0U) {
#line 322
            if ((int )todelete[p]) {
#line 323
              count ++;
#line 324
              *(y_ptr + x) = bg_color;
            }
          }
#line 318
          x ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 329
        p = (p << 1) & 438U;
#line 330
        if ((p & m) == 0U) {
#line 330
          if ((int )todelete[p]) {
#line 331
            count ++;
#line 332
            *(y_ptr + (xsize - 1U)) = bg_color;
          }
        }
#line 314
        y1_ptr += xsize;
#line 314
        y_ptr += xsize;
#line 314
        __cil_tmp26 = y;
#line 314
        y ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 337
      q = (unsigned int )*(qb + 0);
#line 338
      p = (q << 2) & 216U;
#line 340
      y_ptr = ptr + xsize * (ysize - 1U);
#line 341
      x = (unsigned int )0;
      {
#line 341
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 341
        if (! (x < xsize)) {
#line 341
          goto while_break___6;
        }
#line 342
        q = (unsigned int )*(qb + x);
#line 343
        p = ((p << 1) & 438U) | ((q << 3) & 72U);
#line 344
        if ((p & m) == 0U) {
#line 344
          if ((int )todelete[p]) {
#line 345
            count ++;
#line 346
            *(y_ptr + x) = bg_color;
          }
        }
#line 341
        x ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 302
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 350
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 350
      if (logging) {
        {
#line 350
        fprintf(stdout, "thin1: pass %d, %d pixels deleted\n", pc, count);
        }
      }
#line 350
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 352
  free(qb);
  }
  return;
}
}
#line 808 "/usr/include/glib-2.0/gobject/gobject.h"
__inline static void g_assert_finalize_object___4(GObject *object ) 
{ 
  gpointer weak_pointer ;
  long __cil_tmp3 ;
  long __cil_tmp4 ;

  {
#line 810
  weak_pointer = object;
  {
#line 812
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 812
    __cil_tmp3 = __builtin_expect((long )0, (long )1);
    }
#line 812
    if (__cil_tmp3) {

    } else {
      {
#line 812
      g_assertion_message((char const   *)((gchar *)0), "/usr/include/glib-2.0/gobject/gobject.h",
                          812, (char const   *)"g_assert_finalize_object\312\001@",
                          "\'G_IS_OBJECT (weak_pointer)\' should be TRUE\a\027V");
      }
    }
#line 812
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 813
  g_object_add_weak_pointer(object, & weak_pointer);
#line 814
  g_object_unref(weak_pointer);
  }
  {
#line 815
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 815
    __cil_tmp4 = __builtin_expect((long )0, (long )1);
    }
#line 815
    if (__cil_tmp4) {

    } else {
      {
#line 815
      g_assertion_message((char const   *)((gchar *)0), "/usr/include/glib-2.0/gobject/gobject.h",
                          815, (char const   *)"g_assert_finalize_object\312\001@\a\316\264\b",
                          "\'weak_pointer\' should be NULL");
      }
    }
#line 815
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 49 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/quantize.h"
void quantize(at_bitmap *image , long ncolors , at_color *bgColor , QuantizeObj **iQuant ,
              at_exception_type *exp___0 ) ;
#line 51
void quantize_object_free(QuantizeObj *quantobj ) ;
#line 62 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/median.c"
static void zero_histogram_rgb(Histogram histogram ) 
{ 
  int r ;
  int g ;
  int b ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 65
  r = 0;
  {
#line 65
  while (1) {
    while_continue: /* CIL Label */ ;
#line 65
    if (! (r < 1 << 7)) {
#line 65
      goto while_break;
    }
#line 66
    g = 0;
    {
#line 66
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 66
      if (! (g < 1 << 7)) {
#line 66
        goto while_break___0;
      }
#line 67
      b = 0;
      {
#line 67
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 67
        if (! (b < 1 << 7)) {
#line 67
          goto while_break___1;
        }
#line 68
        *(histogram + (((r * (1 << 7)) * (1 << 7) + g * (1 << 7)) + b)) = (ColorFreq )0;
#line 67
        b ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 66
      g ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 65
    r ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 71 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/median.c"
static void generate_histogram_rgb(Histogram histogram , at_bitmap *image , at_color *ignoreColor ) 
{ 
  unsigned char *src ;
  int num_elems ;
  ColorFreq *col ;
  int __cil_tmp7 ;
  ColorFreq __cil_tmp8 ;
  ColorFreq __cil_tmp9 ;

  {
  {
#line 73
  src = image->bitmap;
#line 77
  num_elems = (int )image->width * (int )image->height;
#line 78
  zero_histogram_rgb(histogram);
  }
  {
#line 81
  if (image->np == (unsigned int )3) {
#line 81
    goto case_3;
  }
#line 98
  if (image->np == (unsigned int )1) {
#line 98
    goto case_1;
  }
#line 106
  goto switch_default;
  case_3: /* CIL Label */ 
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    __cil_tmp7 = num_elems;
#line 82
    num_elems --;
#line 82
    if (! __cil_tmp7) {
#line 82
      goto while_break;
    }
#line 84
    if (ignoreColor) {
#line 85
      if ((int )*(src + 0) == (int )ignoreColor->r) {
#line 85
        if ((int )*(src + 1) == (int )ignoreColor->g) {
#line 85
          if ((int )*(src + 2) == (int )ignoreColor->b) {
#line 88
            src += 3;
#line 89
            goto while_continue;
          }
        }
      }
    }
#line 92
    col = histogram + (((((int )*(src + 0) >> 1) * (1 << 7)) * (1 << 7) + ((int )*(src + 1) >> 1) * (1 << 7)) + ((int )*(src + 2) >> 1));
#line 93
    (*col) ++;
#line 94
    src += 3;
  }
  while_break: /* CIL Label */ ;
  }
#line 96
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 99
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 99
    num_elems --;
#line 99
    if (! (num_elems >= 0)) {
#line 99
      goto while_break___0;
    }
#line 100
    if (ignoreColor) {
#line 100
      if ((int )*(src + num_elems) == (int )ignoreColor->r) {
#line 101
        goto while_continue___0;
      }
    }
#line 102
    col = histogram + (((((int )*(src + num_elems) >> 1) * (1 << 7)) * (1 << 7) + ((int )*(src + num_elems) >> 1) * (1 << 7)) + ((int )*(src + num_elems) >> 1));
#line 103
    (*col) ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 105
  goto switch_break;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
  return;
}
}
#line 111 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/median.c"
static boxptr find_biggest_volume(boxptr boxlist , int numboxes ) 
{ 
  boxptr boxp ;
  int i ;
  int maxv ;
  boxptr which ;
  int __cil_tmp7 ;
  boxptr __cil_tmp8 ;

  {
#line 117
  maxv = 0;
#line 118
  which = (boxptr )0;
#line 120
  boxp = boxlist;
#line 120
  i = 0;
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 120
    if (! (i < numboxes)) {
#line 120
      goto while_break;
    }
#line 121
    if (boxp->volume > maxv) {
#line 122
      which = boxp;
#line 123
      maxv = boxp->volume;
    }
#line 120
    __cil_tmp8 = boxp;
#line 120
    boxp ++;
#line 120
    __cil_tmp7 = i;
#line 120
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 127
  return (which);
}
}
#line 130 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/median.c"
static void update_box_rgb(Histogram histogram , boxptr boxp ) 
{ 
  ColorFreq *histp ;
  int R ;
  int G ;
  int B ;
  int Rmin ;
  int Rmax ;
  int Gmin ;
  int Gmax ;
  int Bmin ;
  int Bmax ;
  int dist0 ;
  int dist1 ;
  int dist2 ;
  long ccount ;
  ColorFreq *__cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  ColorFreq *__cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  ColorFreq *__cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  ColorFreq *__cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  long __cil_tmp39 ;
  int __cil_tmp40 ;
  ColorFreq *__cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;

  {
#line 140
  Rmin = boxp->Rmin;
#line 141
  Rmax = boxp->Rmax;
#line 142
  Gmin = boxp->Gmin;
#line 143
  Gmax = boxp->Gmax;
#line 144
  Bmin = boxp->Bmin;
#line 145
  Bmax = boxp->Bmax;
#line 147
  if (Rmax > Rmin) {
#line 148
    R = Rmin;
    {
#line 148
    while (1) {
      while_continue: /* CIL Label */ ;
#line 148
      if (! (R <= Rmax)) {
#line 148
        goto while_break;
      }
#line 149
      G = Gmin;
      {
#line 149
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 149
        if (! (G <= Gmax)) {
#line 149
          goto while_break___0;
        }
#line 150
        histp = ((histogram + (R * (1 << 7)) * (1 << 7)) + G * (1 << 7)) + Bmin;
#line 151
        B = Bmin;
        {
#line 151
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 151
          if (! (B <= Bmax)) {
#line 151
            goto while_break___1;
          }
#line 152
          __cil_tmp17 = histp;
#line 152
          histp ++;
#line 152
          if (*__cil_tmp17 != 0UL) {
#line 153
            Rmin = R;
#line 153
            boxp->Rmin = Rmin;
#line 154
            goto have_Rmin;
          }
#line 151
          B ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 149
        G ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 148
      R ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  have_Rmin: 
#line 158
  if (Rmax > Rmin) {
#line 159
    R = Rmax;
    {
#line 159
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 159
      if (! (R >= Rmin)) {
#line 159
        goto while_break___2;
      }
#line 160
      G = Gmin;
      {
#line 160
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 160
        if (! (G <= Gmax)) {
#line 160
          goto while_break___3;
        }
#line 161
        histp = ((histogram + (R * (1 << 7)) * (1 << 7)) + G * (1 << 7)) + Bmin;
#line 162
        B = Bmin;
        {
#line 162
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 162
          if (! (B <= Bmax)) {
#line 162
            goto while_break___4;
          }
#line 163
          __cil_tmp21 = histp;
#line 163
          histp ++;
#line 163
          if (*__cil_tmp21 != 0UL) {
#line 164
            Rmax = R;
#line 164
            boxp->Rmax = Rmax;
#line 165
            goto have_Rmax;
          }
#line 162
          B ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 160
        G ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 159
      __cil_tmp24 = R;
#line 159
      R --;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  have_Rmax: 
#line 169
  if (Gmax > Gmin) {
#line 170
    G = Gmin;
    {
#line 170
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 170
      if (! (G <= Gmax)) {
#line 170
        goto while_break___5;
      }
#line 171
      R = Rmin;
      {
#line 171
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 171
        if (! (R <= Rmax)) {
#line 171
          goto while_break___6;
        }
#line 172
        histp = ((histogram + (R * (1 << 7)) * (1 << 7)) + G * (1 << 7)) + Bmin;
#line 173
        B = Bmin;
        {
#line 173
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 173
          if (! (B <= Bmax)) {
#line 173
            goto while_break___7;
          }
#line 174
          __cil_tmp25 = histp;
#line 174
          histp ++;
#line 174
          if (*__cil_tmp25 != 0UL) {
#line 175
            Gmin = G;
#line 175
            boxp->Gmin = Gmin;
#line 176
            goto have_Gmin;
          }
#line 173
          B ++;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 171
        R ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 170
      G ++;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
  have_Gmin: 
#line 180
  if (Gmax > Gmin) {
#line 181
    G = Gmax;
    {
#line 181
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 181
      if (! (G >= Gmin)) {
#line 181
        goto while_break___8;
      }
#line 182
      R = Rmin;
      {
#line 182
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 182
        if (! (R <= Rmax)) {
#line 182
          goto while_break___9;
        }
#line 183
        histp = ((histogram + (R * (1 << 7)) * (1 << 7)) + G * (1 << 7)) + Bmin;
#line 184
        B = Bmin;
        {
#line 184
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 184
          if (! (B <= Bmax)) {
#line 184
            goto while_break___10;
          }
#line 185
          __cil_tmp29 = histp;
#line 185
          histp ++;
#line 185
          if (*__cil_tmp29 != 0UL) {
#line 186
            Gmax = G;
#line 186
            boxp->Gmax = Gmax;
#line 187
            goto have_Gmax;
          }
#line 184
          B ++;
        }
        while_break___10: /* CIL Label */ ;
        }
#line 182
        R ++;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 181
      __cil_tmp32 = G;
#line 181
      G --;
    }
    while_break___8: /* CIL Label */ ;
    }
  }
  have_Gmax: 
#line 191
  if (Bmax > Bmin) {
#line 192
    B = Bmin;
    {
#line 192
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 192
      if (! (B <= Bmax)) {
#line 192
        goto while_break___11;
      }
#line 193
      R = Rmin;
      {
#line 193
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 193
        if (! (R <= Rmax)) {
#line 193
          goto while_break___12;
        }
#line 194
        histp = ((histogram + (R * (1 << 7)) * (1 << 7)) + Gmin * (1 << 7)) + B;
#line 195
        G = Gmin;
        {
#line 195
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 195
          if (! (G <= Gmax)) {
#line 195
            goto while_break___13;
          }
#line 196
          if (*histp != 0UL) {
#line 197
            Bmin = B;
#line 197
            boxp->Bmin = Bmin;
#line 198
            goto have_Bmin;
          }
#line 195
          histp += 1 << 7;
#line 195
          __cil_tmp33 = G;
#line 195
          G ++;
        }
        while_break___13: /* CIL Label */ ;
        }
#line 193
        R ++;
      }
      while_break___12: /* CIL Label */ ;
      }
#line 192
      B ++;
    }
    while_break___11: /* CIL Label */ ;
    }
  }
  have_Bmin: 
#line 202
  if (Bmax > Bmin) {
#line 203
    B = Bmax;
    {
#line 203
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 203
      if (! (B >= Bmin)) {
#line 203
        goto while_break___14;
      }
#line 204
      R = Rmin;
      {
#line 204
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 204
        if (! (R <= Rmax)) {
#line 204
          goto while_break___15;
        }
#line 205
        histp = ((histogram + (R * (1 << 7)) * (1 << 7)) + Gmin * (1 << 7)) + B;
#line 206
        G = Gmin;
        {
#line 206
        while (1) {
          while_continue___16: /* CIL Label */ ;
#line 206
          if (! (G <= Gmax)) {
#line 206
            goto while_break___16;
          }
#line 207
          if (*histp != 0UL) {
#line 208
            Bmax = B;
#line 208
            boxp->Bmax = Bmax;
#line 209
            goto have_Bmax;
          }
#line 206
          histp += 1 << 7;
#line 206
          __cil_tmp36 = G;
#line 206
          G ++;
        }
        while_break___16: /* CIL Label */ ;
        }
#line 204
        R ++;
      }
      while_break___15: /* CIL Label */ ;
      }
#line 203
      __cil_tmp38 = B;
#line 203
      B --;
    }
    while_break___14: /* CIL Label */ ;
    }
  }
  have_Bmax: 
#line 222
  dist0 = Rmax - Rmin;
#line 223
  dist1 = Gmax - Gmin;
#line 224
  dist2 = Bmax - Bmin;
#line 225
  boxp->volume = (dist0 * dist0 + dist1 * dist1) + dist2 * dist2;
#line 228
  ccount = (long )0;
#line 229
  R = Rmin;
  {
#line 229
  while (1) {
    while_continue___17: /* CIL Label */ ;
#line 229
    if (! (R <= Rmax)) {
#line 229
      goto while_break___17;
    }
#line 230
    G = Gmin;
    {
#line 230
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 230
      if (! (G <= Gmax)) {
#line 230
        goto while_break___18;
      }
#line 231
      histp = ((histogram + (R * (1 << 7)) * (1 << 7)) + G * (1 << 7)) + Bmin;
#line 232
      B = Bmin;
      {
#line 232
      while (1) {
        while_continue___19: /* CIL Label */ ;
#line 232
        if (! (B <= Bmax)) {
#line 232
          goto while_break___19;
        }
#line 233
        if (*histp != 0UL) {
#line 234
          ccount ++;
        }
#line 232
        __cil_tmp41 = histp;
#line 232
        histp ++;
#line 232
        __cil_tmp40 = B;
#line 232
        B ++;
      }
      while_break___19: /* CIL Label */ ;
      }
#line 230
      G ++;
    }
    while_break___18: /* CIL Label */ ;
    }
#line 229
    R ++;
  }
  while_break___17: /* CIL Label */ ;
  }
#line 238
  boxp->colorcount = ccount;
  return;
}
}
#line 241 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/median.c"
static int median_cut_rgb(Histogram histogram , boxptr boxlist , int numboxes , int desired_colors ) 
{ 
  int n ;
  int lb ;
  int R ;
  int G ;
  int B ;
  int cmax ;
  boxptr b1 ;
  boxptr b2 ;
  boxptr __cil_tmp13 ;
  int __cil_tmp14 ;

  {
  {
#line 248
  while (1) {
    while_continue: /* CIL Label */ ;
#line 248
    if (! (numboxes < desired_colors)) {
#line 248
      goto while_break;
    }
    {
#line 252
    b1 = find_biggest_volume(boxlist, numboxes);
    }
#line 254
    if (b1 == (boxptr )0) {
#line 255
      goto while_break;
    }
#line 256
    b2 = boxlist + numboxes;
#line 258
    b2->Rmax = b1->Rmax;
#line 259
    b2->Gmax = b1->Gmax;
#line 260
    b2->Bmax = b1->Bmax;
#line 261
    b2->Rmin = b1->Rmin;
#line 262
    b2->Gmin = b1->Gmin;
#line 263
    b2->Bmin = b1->Bmin;
#line 268
    R = b1->Rmax - b1->Rmin;
#line 269
    G = b1->Gmax - b1->Gmin;
#line 270
    B = b1->Bmax - b1->Bmin;
#line 273
    cmax = G;
#line 274
    n = 1;
#line 275
    if (R > cmax) {
#line 276
      cmax = R;
#line 277
      n = 0;
    }
#line 279
    if (B > cmax) {
#line 280
      n = 2;
    }
    {
#line 289
    if (n == 0) {
#line 289
      goto case_0;
    }
#line 294
    if (n == 1) {
#line 294
      goto case_1;
    }
#line 299
    if (n == 2) {
#line 299
      goto case_2;
    }
#line 288
    goto switch_break;
    case_0: /* CIL Label */ 
#line 290
    lb = (b1->Rmax + b1->Rmin) / 2;
#line 291
    b1->Rmax = lb;
#line 292
    b2->Rmin = lb + 1;
#line 293
    goto switch_break;
    case_1: /* CIL Label */ 
#line 295
    lb = (b1->Gmax + b1->Gmin) / 2;
#line 296
    b1->Gmax = lb;
#line 297
    b2->Gmin = lb + 1;
#line 298
    goto switch_break;
    case_2: /* CIL Label */ 
#line 300
    lb = (b1->Bmax + b1->Bmin) / 2;
#line 301
    b1->Bmax = lb;
#line 302
    b2->Bmin = lb + 1;
#line 303
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 306
    update_box_rgb(histogram, b1);
#line 307
    update_box_rgb(histogram, b2);
#line 308
    numboxes ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 310
  return (numboxes);
}
}
#line 313 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/median.c"
static void compute_color_rgb(QuantizeObj *quantobj , Histogram histogram , boxptr boxp ,
                              int icolor ) 
{ 
  ColorFreq *histp ;
  int R ;
  int G ;
  int B ;
  int Rmin ;
  int Rmax ;
  int Gmin ;
  int Gmax ;
  int Bmin ;
  int Bmax ;
  unsigned long count ;
  unsigned long total ;
  unsigned long Rtotal ;
  unsigned long Gtotal ;
  unsigned long Btotal ;
  ColorFreq *__cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;

  {
#line 324
  total = (unsigned long )0;
#line 325
  Rtotal = (unsigned long )0;
#line 326
  Gtotal = (unsigned long )0;
#line 327
  Btotal = (unsigned long )0;
#line 329
  Rmin = boxp->Rmin;
#line 330
  Rmax = boxp->Rmax;
#line 331
  Gmin = boxp->Gmin;
#line 332
  Gmax = boxp->Gmax;
#line 333
  Bmin = boxp->Bmin;
#line 334
  Bmax = boxp->Bmax;
#line 336
  R = Rmin;
  {
#line 336
  while (1) {
    while_continue: /* CIL Label */ ;
#line 336
    if (! (R <= Rmax)) {
#line 336
      goto while_break;
    }
#line 337
    G = Gmin;
    {
#line 337
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 337
      if (! (G <= Gmax)) {
#line 337
        goto while_break___0;
      }
#line 338
      histp = ((histogram + (R * (1 << 7)) * (1 << 7)) + G * (1 << 7)) + Bmin;
#line 339
      B = Bmin;
      {
#line 339
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 339
        if (! (B <= Bmax)) {
#line 339
          goto while_break___1;
        }
#line 340
        __cil_tmp20 = histp;
#line 340
        histp ++;
#line 340
        count = *__cil_tmp20;
#line 340
        if (count != 0UL) {
#line 341
          total += count;
#line 342
          Rtotal += (unsigned long )((R << 1) + ((1 << 1) >> 1)) * count;
#line 343
          Gtotal += (unsigned long )((G << 1) + ((1 << 1) >> 1)) * count;
#line 344
          Btotal += (unsigned long )((B << 1) + ((1 << 1) >> 1)) * count;
        }
#line 339
        B ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 337
      G ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 336
    R ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 349
  quantobj->cmap[icolor].r = (unsigned char )((Rtotal + (total >> 1)) / total);
#line 350
  quantobj->cmap[icolor].g = (unsigned char )((Gtotal + (total >> 1)) / total);
#line 351
  quantobj->cmap[icolor].b = (unsigned char )((Btotal + (total >> 1)) / total);
#line 352
  quantobj->freq[icolor] = total;
  return;
}
}
#line 355 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/median.c"
static void select_colors_rgb(QuantizeObj *quantobj , Histogram histogram ) 
{ 
  boxptr boxlist ;
  int numboxes ;
  int desired ;
  int i ;
  void *__cil_tmp7 ;
  int tmp ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
#line 360
  desired = quantobj->desired_number_of_colors;
  {
#line 364
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 364
    __cil_tmp7 = malloc((unsigned long )desired * sizeof(box ));
#line 364
    boxlist = (gpointer )__cil_tmp7;
    }
#line 364
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 367
  numboxes = 1;
#line 368
  (boxlist + 0)->Rmin = 0;
#line 369
  (boxlist + 0)->Rmax = (1 << 7) - 1;
#line 370
  (boxlist + 0)->Gmin = 0;
#line 371
  (boxlist + 0)->Gmax = (1 << 7) - 1;
#line 372
  (boxlist + 0)->Bmin = 0;
#line 373
  (boxlist + 0)->Bmax = (1 << 7) - 1;
#line 375
  update_box_rgb(histogram, boxlist);
#line 377
  numboxes = median_cut_rgb(histogram, boxlist, numboxes, desired);
#line 378
  quantobj->actual_number_of_colors = numboxes;
#line 380
  i = 0;
  }
  {
#line 380
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 380
    if (! (i < numboxes)) {
#line 380
      goto while_break___0;
    }
    {
#line 381
    compute_color_rgb(quantobj, histogram, boxlist + i, i);
    }
#line 380
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 382
  free(boxlist);
  }
  return;
}
}
#line 461 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/median.c"
static int find_nearby_colors(QuantizeObj *quantobj , int minR , int minG , int minB ,
                              int *colorlist ) 
{ 
  int numcolors ;
  int maxR ;
  int maxG ;
  int maxB ;
  int centerR ;
  int centerG ;
  int centerB ;
  int i ;
  int x ;
  int ncolors ;
  int minmaxdist ;
  int min_dist ;
  int max_dist ;
  int tdist ;
  int mindist[256] ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;

  {
#line 471
  numcolors = quantobj->actual_number_of_colors;
#line 475
  min_dist = 0;
#line 484
  maxR = minR + ((1 << 5) - (1 << 1));
#line 485
  centerR = (minR + maxR) >> 1;
#line 486
  maxG = minG + ((1 << 5) - (1 << 1));
#line 487
  centerG = (minG + maxG) >> 1;
#line 488
  maxB = minB + ((1 << 5) - (1 << 1));
#line 489
  centerB = (minB + maxB) >> 1;
#line 499
  minmaxdist = (int )2147483647L;
#line 501
  i = 0;
  {
#line 501
  while (1) {
    while_continue: /* CIL Label */ ;
#line 501
    if (! (i < numcolors)) {
#line 501
      goto while_break;
    }
#line 503
    x = (int )quantobj->cmap[i].r;
#line 504
    if (x < minR) {
#line 505
      tdist = (x - minR) << 1;
#line 506
      min_dist = tdist * tdist;
#line 507
      tdist = (x - maxR) << 1;
#line 508
      max_dist = tdist * tdist;
    } else
#line 509
    if (x > maxR) {
#line 510
      tdist = (x - maxR) << 1;
#line 511
      min_dist = tdist * tdist;
#line 512
      tdist = (x - minR) << 1;
#line 513
      max_dist = tdist * tdist;
    } else {
#line 516
      min_dist = 0;
#line 517
      if (x <= centerR) {
#line 518
        tdist = (x - maxR) << 1;
#line 519
        max_dist = tdist * tdist;
      } else {
#line 521
        tdist = (x - minR) << 1;
#line 522
        max_dist = tdist * tdist;
      }
    }
#line 526
    x = (int )quantobj->cmap[i].g;
#line 527
    if (x < minG) {
#line 528
      tdist = (x - minG) * 3;
#line 529
      min_dist += tdist * tdist;
#line 530
      tdist = (x - maxG) * 3;
#line 531
      max_dist += tdist * tdist;
    } else
#line 532
    if (x > maxG) {
#line 533
      tdist = (x - maxG) * 3;
#line 534
      min_dist += tdist * tdist;
#line 535
      tdist = (x - minG) * 3;
#line 536
      max_dist += tdist * tdist;
    } else
#line 539
    if (x <= centerG) {
#line 540
      tdist = (x - maxG) * 3;
#line 541
      max_dist += tdist * tdist;
    } else {
#line 543
      tdist = (x - minG) * 3;
#line 544
      max_dist += tdist * tdist;
    }
#line 548
    x = (int )quantobj->cmap[i].b;
#line 549
    if (x < minB) {
#line 550
      tdist = x - minB;
#line 551
      min_dist += tdist * tdist;
#line 552
      tdist = x - maxB;
#line 553
      max_dist += tdist * tdist;
    } else
#line 554
    if (x > maxB) {
#line 555
      tdist = x - maxB;
#line 556
      min_dist += tdist * tdist;
#line 557
      tdist = x - minB;
#line 558
      max_dist += tdist * tdist;
    } else
#line 561
    if (x <= centerB) {
#line 562
      tdist = x - maxB;
#line 563
      max_dist += tdist * tdist;
    } else {
#line 565
      tdist = x - minB;
#line 566
      max_dist += tdist * tdist;
    }
#line 570
    mindist[i] = min_dist;
#line 571
    if (max_dist < minmaxdist) {
#line 572
      minmaxdist = max_dist;
    }
#line 501
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 579
  ncolors = 0;
#line 580
  i = 0;
  {
#line 580
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 580
    if (! (i < numcolors)) {
#line 580
      goto while_break___0;
    }
#line 581
    if (mindist[i] <= minmaxdist) {
#line 582
      __cil_tmp22 = ncolors;
#line 582
      ncolors ++;
#line 582
      *(colorlist + __cil_tmp22) = i;
    }
#line 580
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 584
  return (ncolors);
}
}
#line 587 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/median.c"
static void find_best_colors(QuantizeObj *quantobj , int minR , int minG , int minB ,
                             int numcolors , int *colorlist , int *bestcolor ) 
{ 
  int iR ;
  int iG ;
  int iB ;
  int i ;
  int icolor ;
  int *bptr ;
  int *cptr ;
  int dist0 ;
  int dist1 ;
  int dist2 ;
  int xx0 ;
  int xx1 ;
  int xx2 ;
  int inR ;
  int inG ;
  int inB ;
  int bestdist[4096] ;
  int *__cil_tmp25 ;
  int __cil_tmp26 ;
  int *__cil_tmp27 ;
  int *__cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;

  {
#line 609
  bptr = (int *)bestdist;
#line 610
  i = ((1 << 4) * (1 << 4)) * (1 << 4) - 1;
  {
#line 610
  while (1) {
    while_continue: /* CIL Label */ ;
#line 610
    if (! (i >= 0)) {
#line 610
      goto while_break;
    }
#line 611
    __cil_tmp25 = bptr;
#line 611
    bptr ++;
#line 611
    *__cil_tmp25 = (int )2147483647L;
#line 610
    __cil_tmp26 = i;
#line 610
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 623
  i = 0;
  {
#line 623
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 623
    if (! (i < numcolors)) {
#line 623
      goto while_break___0;
    }
#line 624
    icolor = *(colorlist + i);
#line 626
    inR = (minR - (int )quantobj->cmap[icolor].r) << 1;
#line 627
    dist0 = inR * inR;
#line 628
    inG = (minG - (int )quantobj->cmap[icolor].g) * 3;
#line 629
    dist0 += inG * inG;
#line 630
    inB = minB - (int )quantobj->cmap[icolor].b;
#line 631
    dist0 += inB * inB;
#line 633
    inR = inR * (2 * ((1 << 1) << 1)) + ((1 << 1) << 1) * ((1 << 1) << 1);
#line 634
    inG = inG * (2 * ((1 << 1) * 3)) + ((1 << 1) * 3) * ((1 << 1) * 3);
#line 635
    inB = inB * (2 * (1 << 1)) + (1 << 1) * (1 << 1);
#line 637
    bptr = (int *)bestdist;
#line 638
    cptr = bestcolor;
#line 639
    xx0 = inR;
#line 640
    iR = (1 << 4) - 1;
    {
#line 640
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 640
      if (! (iR >= 0)) {
#line 640
        goto while_break___1;
      }
#line 641
      dist1 = dist0;
#line 642
      xx1 = inG;
#line 643
      iG = (1 << 4) - 1;
      {
#line 643
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 643
        if (! (iG >= 0)) {
#line 643
          goto while_break___2;
        }
#line 644
        dist2 = dist1;
#line 645
        xx2 = inB;
#line 646
        iB = (1 << 4) - 1;
        {
#line 646
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 646
          if (! (iB >= 0)) {
#line 646
            goto while_break___3;
          }
#line 647
          if (dist2 < *bptr) {
#line 648
            *bptr = dist2;
#line 649
            *cptr = icolor;
          }
#line 651
          dist2 += xx2;
#line 652
          xx2 += (2 * (1 << 1)) * (1 << 1);
#line 653
          bptr ++;
#line 654
          cptr ++;
#line 646
          __cil_tmp29 = iB;
#line 646
          iB --;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 656
        dist1 += xx1;
#line 657
        xx1 += (2 * ((1 << 1) * 3)) * ((1 << 1) * 3);
#line 643
        __cil_tmp30 = iG;
#line 643
        iG --;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 659
      dist0 += xx0;
#line 660
      xx0 += (2 * ((1 << 1) << 1)) * ((1 << 1) << 1);
#line 640
      __cil_tmp31 = iR;
#line 640
      iR --;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 623
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 665 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/median.c"
static void fill_inverse_cmap_rgb(QuantizeObj *quantobj , Histogram histogram , int R ,
                                  int G , int B ) 
{ 
  int minR ;
  int minG ;
  int minB ;
  int iR ;
  int iG ;
  int iB ;
  int *cptr ;
  ColorFreq *cachep ;
  int colorlist[256] ;
  int numcolors ;
  int bestcolor[4096] ;
  int __cil_tmp17 ;
  ColorFreq *__cil_tmp18 ;
  int *__cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;

  {
  {
#line 681
  R >>= 4;
#line 682
  G >>= 4;
#line 683
  B >>= 4;
#line 689
  minR = (R << 5) + ((1 << 1) >> 1);
#line 690
  minG = (G << 5) + ((1 << 1) >> 1);
#line 691
  minB = (B << 5) + ((1 << 1) >> 1);
#line 696
  numcolors = find_nearby_colors(quantobj, minR, minG, minB, (int *)colorlist);
#line 699
  find_best_colors(quantobj, minR, minG, minB, numcolors, (int *)colorlist, (int *)bestcolor);
#line 702
  R <<= 4;
#line 703
  G <<= 4;
#line 704
  B <<= 4;
#line 705
  cptr = (int *)bestcolor;
#line 706
  iR = 0;
  }
  {
#line 706
  while (1) {
    while_continue: /* CIL Label */ ;
#line 706
    if (! (iR < 1 << 4)) {
#line 706
      goto while_break;
    }
#line 707
    iG = 0;
    {
#line 707
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 707
      if (! (iG < 1 << 4)) {
#line 707
        goto while_break___0;
      }
#line 708
      cachep = histogram + ((((R + iR) * (1 << 7)) * (1 << 7) + (G + iG) * (1 << 7)) + B);
#line 709
      iB = 0;
      {
#line 709
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 709
        if (! (iB < 1 << 4)) {
#line 709
          goto while_break___1;
        }
#line 710
        __cil_tmp19 = cptr;
#line 710
        cptr ++;
#line 710
        __cil_tmp18 = cachep;
#line 710
        cachep ++;
#line 710
        *__cil_tmp18 = (ColorFreq )(*__cil_tmp19 + 1);
#line 709
        iB ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 707
      iG ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 706
    iR ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 717 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/median.c"
static void median_cut_pass1_rgb(QuantizeObj *quantobj , at_bitmap *image , at_color *ignoreColor ) 
{ 


  {
  {
#line 719
  generate_histogram_rgb(quantobj->histogram, image, ignoreColor);
#line 720
  select_colors_rgb(quantobj, quantobj->histogram);
  }
  return;
}
}
#line 724 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/median.c"
static void median_cut_pass2_rgb(QuantizeObj *quantobj , at_bitmap *image , at_color *bgColor ) 
{ 
  Histogram histogram ;
  ColorFreq *cachep ;
  int R ;
  int G ;
  int B ;
  int origR ;
  int origG ;
  int origB ;
  int row ;
  int col ;
  int spp ;
  int width ;
  int height ;
  unsigned char *src ;
  unsigned char *dest ;
  at_color bg_color ;
  unsigned char *__cil_tmp20 ;
  unsigned char *__cil_tmp21 ;
  unsigned char *__cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  long idx ;

  {
#line 727
  histogram = quantobj->histogram;
#line 732
  spp = (int )image->np;
#line 733
  width = (int )image->width;
#line 734
  height = (int )image->height;
#line 736
  bg_color.r = (guint8 )255;
#line 736
  bg_color.g = (guint8 )255;
  {
#line 736
  bg_color.b = (guint8 )255;
#line 738
  zero_histogram_rgb(histogram);
  }
#line 740
  if (bgColor) {
#line 742
    R = (int )bgColor->r >> 1;
#line 743
    G = (int )bgColor->g >> 1;
#line 744
    B = (int )bgColor->b >> 1;
#line 745
    cachep = histogram + (((R * (1 << 7)) * (1 << 7) + G * (1 << 7)) + B);
#line 746
    if (*cachep == 0UL) {
      {
#line 747
      fill_inverse_cmap_rgb(quantobj, histogram, R, G, B);
      }
    }
#line 748
    bg_color = quantobj->cmap[*cachep - 1UL];
  }
#line 751
  dest = image->bitmap;
#line 751
  src = dest;
#line 752
  if (spp == 3) {
#line 753
    row = 0;
    {
#line 753
    while (1) {
      while_continue: /* CIL Label */ ;
#line 753
      if (! (row < height)) {
#line 753
        goto while_break;
      }
#line 754
      col = 0;
      {
#line 754
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 754
        if (! (col < width)) {
#line 754
          goto while_break___0;
        }
#line 756
        __cil_tmp20 = src;
#line 756
        src ++;
#line 756
        origR = (int )*__cil_tmp20;
#line 757
        __cil_tmp21 = src;
#line 757
        src ++;
#line 757
        origG = (int )*__cil_tmp21;
#line 758
        __cil_tmp22 = src;
#line 758
        src ++;
#line 758
        origB = (int )*__cil_tmp22;
#line 769
        R = origR >> 1;
#line 770
        G = origG >> 1;
#line 771
        B = origB >> 1;
#line 772
        cachep = histogram + (((R * (1 << 7)) * (1 << 7) + G * (1 << 7)) + B);
#line 775
        if (*cachep == 0UL) {
          {
#line 776
          fill_inverse_cmap_rgb(quantobj, histogram, R, G, B);
          }
        }
#line 779
        *(dest + 0) = quantobj->cmap[*cachep - 1UL].r;
#line 780
        *(dest + 1) = quantobj->cmap[*cachep - 1UL].g;
#line 781
        *(dest + 2) = quantobj->cmap[*cachep - 1UL].b;
#line 786
        if (bgColor) {
#line 786
          if ((int )*(dest + 0) == (int )bg_color.r) {
#line 786
            if ((int )*(dest + 1) == (int )bg_color.g) {
#line 786
              if ((int )*(dest + 2) == (int )bg_color.b) {
#line 787
                *(dest + 0) = bgColor->r;
#line 788
                *(dest + 1) = bgColor->g;
#line 789
                *(dest + 2) = bgColor->b;
              }
            }
          }
        }
#line 791
        dest += 3;
#line 754
        col ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 753
      row ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 794
  if (spp == 1) {
#line 795
    idx = (long )(width * height);
    {
#line 796
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 796
      idx --;
#line 796
      if (! (idx >= 0L)) {
#line 796
        goto while_break___1;
      }
#line 797
      origR = (int )*(src + idx);
#line 798
      R = origR >> 1;
#line 799
      G = origR >> 1;
#line 800
      B = origR >> 1;
#line 801
      cachep = histogram + (((R * (1 << 7)) * (1 << 7) + G * (1 << 7)) + B);
#line 802
      if (*cachep == 0UL) {
        {
#line 803
        fill_inverse_cmap_rgb(quantobj, histogram, R, G, B);
        }
      }
#line 805
      *(dest + idx) = quantobj->cmap[*cachep - 1UL].r;
#line 810
      if (bgColor) {
#line 810
        if ((int )*(dest + idx) == (int )bg_color.r) {
#line 811
          *(dest + idx) = bgColor->r;
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  return;
}
}
#line 816 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/median.c"
static QuantizeObj *initialize_median_cut(int num_colors ) 
{ 
  QuantizeObj *quantobj ;
  void *__cil_tmp3 ;
  int tmp ;
  void *__cil_tmp5 ;
  int tmp___0 ;

  {
  {
#line 821
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 821
    __cil_tmp3 = malloc(sizeof(QuantizeObj ));
#line 821
    quantobj = (gpointer )__cil_tmp3;
    }
#line 821
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 823
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 823
    __cil_tmp5 = malloc(((sizeof(ColorFreq ) * (unsigned long )(1 << 7)) * (unsigned long )(1 << 7)) * (unsigned long )(1 << 7));
#line 823
    quantobj->histogram = (gpointer )__cil_tmp5;
    }
#line 823
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 824
  quantobj->desired_number_of_colors = num_colors;
#line 826
  return (quantobj);
}
}
#line 829 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/median.c"
void quantize(at_bitmap *image , long ncolors , at_color *bgColor , QuantizeObj **iQuant ,
              at_exception_type *exp___0 ) 
{ 
  QuantizeObj *quantobj ;
  unsigned int spp ;
  QuantizeObj *__cil_tmp8 ;
  QuantizeObj *__cil_tmp9 ;

  {
#line 832
  spp = image->np;
#line 834
  if (spp != 3U) {
#line 834
    if (spp != 1U) {
      {
#line 835
      while (1) {
        while_continue: /* CIL Label */ ;
#line 835
        if (logging) {
          {
#line 835
          fprintf(stdout, "quantize: %u-plane images are not supported", spp);
          }
        }
#line 835
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 836
      at_exception_fatal(exp___0, (gchar *)"quantize: wrong plane images are passed");
      }
#line 837
      return;
    }
  }
#line 841
  if (iQuant) {
#line 842
    if (*iQuant == (void *)0) {
      {
#line 843
      quantobj = initialize_median_cut((int )ncolors);
#line 844
      median_cut_pass1_rgb(quantobj, image, bgColor);
#line 845
      *iQuant = quantobj;
      }
    } else {
#line 847
      quantobj = *iQuant;
    }
  } else {
    {
#line 849
    quantobj = initialize_median_cut((int )ncolors);
#line 850
    median_cut_pass1_rgb(quantobj, image, (at_color *)((void *)0));
    }
  }
  {
#line 853
  median_cut_pass2_rgb(quantobj, image, bgColor);
  }
#line 855
  if (iQuant == (void *)0) {
    {
#line 856
    quantize_object_free(quantobj);
    }
  }
  return;
}
}
#line 859 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/median.c"
void quantize_object_free(QuantizeObj *quantobj ) 
{ 


  {
  {
#line 861
  free(quantobj->histogram);
#line 862
  free(quantobj);
  }
  return;
}
}
#line 808 "/usr/include/glib-2.0/gobject/gobject.h"
__inline static void g_assert_finalize_object___5(GObject *object ) 
{ 
  gpointer weak_pointer ;
  long __cil_tmp3 ;
  long __cil_tmp4 ;

  {
#line 810
  weak_pointer = object;
  {
#line 812
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 812
    __cil_tmp3 = __builtin_expect((long )0, (long )1);
    }
#line 812
    if (__cil_tmp3) {

    } else {
      {
#line 812
      g_assertion_message((char const   *)((gchar *)0), "/usr/include/glib-2.0/gobject/gobject.h",
                          812, (char const   *)"g_assert_finalize_object\312\001@",
                          "\'G_IS_OBJECT (weak_pointer)\' should be TRUE");
      }
    }
#line 812
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 813
  g_object_add_weak_pointer(object, & weak_pointer);
#line 814
  g_object_unref(weak_pointer);
  }
  {
#line 815
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 815
    __cil_tmp4 = __builtin_expect((long )0, (long )1);
    }
#line 815
    if (__cil_tmp4) {

    } else {
      {
#line 815
      g_assertion_message((char const   *)((gchar *)0), "/usr/include/glib-2.0/gobject/gobject.h",
                          815, (char const   *)"g_assert_finalize_object\312\001\300\a\a\260\b",
                          "\'weak_pointer\' should be NULLV");
      }
    }
#line 815
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 50 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/pxl-outline.h"
pixel_outline_list_type find_outline_pixels(at_bitmap *bitmap , at_color *bg_color ,
                                            at_progress_func notify_progress , gpointer progress_data ,
                                            at_testcancel_func test_cancel , gpointer testcancel_data ,
                                            at_exception_type *exp___0 ) ;
#line 53
pixel_outline_list_type find_centerline_pixels(at_bitmap *bitmap , at_color bg_color ,
                                               at_progress_func notify_progress ,
                                               gpointer progress_data , at_testcancel_func test_cancel ,
                                               gpointer testcancel_data , at_exception_type *exp___0 ) ;
#line 56
void free_pixel_outline_list(pixel_outline_list_type *outline_list ) ;
#line 56 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/pxl-outline.c"
static pixel_outline_type find_one_outline(at_bitmap *bitmap , edge_type original_edge ,
                                           unsigned short original_row , unsigned short original_col ,
                                           at_bitmap *marked , gboolean clockwise ,
                                           gboolean ignore___0 , at_exception_type *exp___0 ) ;
#line 57
static pixel_outline_type find_one_centerline(at_bitmap *bitmap , direction_type search_dir ,
                                              unsigned short original_row , unsigned short original_col ,
                                              at_bitmap *marked ) ;
#line 58
static void append_pixel_outline(pixel_outline_list_type *outline_list , pixel_outline_type outline ) ;
#line 59
static pixel_outline_type new_pixel_outline(void) ;
#line 60
static void free_pixel_outline(pixel_outline_type *outline ) ;
#line 61
static void concat_pixel_outline(pixel_outline_type *o1 , pixel_outline_type *o2 ) ;
#line 62
static void append_outline_pixel(pixel_outline_type *o , at_coord c ) ;
#line 63
static gboolean is_marked_edge(edge_type edge , unsigned short row , unsigned short col ,
                               at_bitmap *marked ) ;
#line 64
static gboolean is_outline_edge(edge_type edge , at_bitmap *bitmap , unsigned short row ,
                                unsigned short col , at_color color , at_exception_type *exp___0 ) ;
#line 65
static gboolean is_unmarked_outline_edge(unsigned short row , unsigned short col ,
                                         edge_type edge , at_bitmap *bitmap , at_bitmap *marked ,
                                         at_color color , at_exception_type *exp___0 ) ;
#line 67
static void mark_edge(edge_type edge , unsigned short row , unsigned short col , at_bitmap *marked ) ;
#line 70
static gboolean is_marked_dir(unsigned short row , unsigned short col , direction_type dir ,
                              at_bitmap *marked ) ;
#line 71
static gboolean is_other_dir_marked(unsigned short row , unsigned short col , direction_type dir ,
                                    at_bitmap *marked ) ;
#line 72
static void mark_dir(unsigned short row , unsigned short col , direction_type dir ,
                     at_bitmap *marked ) ;
#line 73
static gboolean next_unmarked_pixel(unsigned short *row , unsigned short *col , direction_type *dir ,
                                    at_bitmap *bitmap , at_bitmap *marked ) ;
#line 75
gboolean is_valid_dir(unsigned short row , unsigned short col , direction_type dir ,
                      at_bitmap *bitmap , at_bitmap *marked ) ;
#line 77
static at_coord next_point(at_bitmap *bitmap , edge_type *edge , unsigned short *row ,
                           unsigned short *col , at_color color , gboolean clockwise ,
                           at_bitmap *marked , at_exception_type *exp___0 ) ;
#line 78
static unsigned int num_neighbors(unsigned short row , unsigned short col , at_bitmap *bitmap ) ;
#line 85 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/pxl-outline.c"
pixel_outline_list_type find_outline_pixels(at_bitmap *bitmap , at_color *bg_color ,
                                            at_progress_func notify_progress , gpointer progress_data ,
                                            at_testcancel_func test_cancel , gpointer testcancel_data ,
                                            at_exception_type *exp___0 ) 
{ 
  pixel_outline_list_type outline_list ;
  unsigned short row ;
  unsigned short col ;
  at_bitmap *marked ;
  at_bitmap *__cil_tmp12 ;
  unsigned int max_progress ;
  edge_type edge ;
  at_color color ;
  gboolean is_background ;
  gboolean __cil_tmp17 ;
  gboolean __cil_tmp18 ;
  pixel_outline_type outline ;
  gboolean __cil_tmp20 ;
  pixel_outline_type __cil_tmp21 ;
  gboolean __cil_tmp22 ;
  gboolean __cil_tmp23 ;
  gboolean __cil_tmp24 ;
  gboolean __cil_tmp25 ;
  pixel_outline_type outline___0 ;
  gboolean __cil_tmp27 ;
  pixel_outline_type __cil_tmp28 ;
  gboolean __cil_tmp29 ;
  pixel_outline_type __cil_tmp30 ;
  gboolean __cil_tmp31 ;
  gboolean __cil_tmp32 ;
  gboolean __cil_tmp33 ;
  unsigned short __cil_tmp34 ;
  unsigned short __cil_tmp35 ;
  gboolean __cil_tmp36 ;

  {
  {
#line 89
  __cil_tmp12 = at_bitmap_new(bitmap->width, bitmap->height, (unsigned int )1);
#line 89
  marked = __cil_tmp12;
#line 90
  max_progress = (unsigned int )((int )bitmap->height * (int )bitmap->width);
#line 92
  outline_list.length = (unsigned int )0;
#line 93
  outline_list.data = (pixel_outline_type *)((void *)0);
#line 95
  row = (unsigned short )0;
  }
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    if (! ((int )row < (int )bitmap->height)) {
#line 95
      goto while_break;
    }
#line 96
    col = (unsigned short )0;
    {
#line 96
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 96
      if (! ((int )col < (int )bitmap->width)) {
#line 96
        goto while_break___0;
      }
#line 101
      if (notify_progress) {
        {
#line 102
        (*notify_progress)((gfloat )((int )row * (int )bitmap->width + (int )col) / ((gfloat )max_progress * (gfloat )3.),
                           progress_data);
        }
      }
      {
#line 106
      at_bitmap_get_color(bitmap, (unsigned int )row, (unsigned int )col, & color);
#line 107
      edge = (edge_type )1;
#line 107
      __cil_tmp18 = is_unmarked_outline_edge(row, col, edge, bitmap, marked, color,
                                             exp___0);
      }
      {
#line 107
      __cil_tmp17 = at_color_equal(& color, bg_color);
#line 107
      is_background = (gboolean )(bg_color && __cil_tmp17);
      }
#line 107
      if (! is_background) {
#line 107
        if (__cil_tmp18) {
          {
#line 111
          __cil_tmp20 = at_exception_got_fatal(exp___0);
          }
#line 111
          if (__cil_tmp20) {
#line 111
            goto cleanup;
          }

          {
#line 113
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 113
            if (logging) {
              {
#line 113
              fprintf(stdout, "#%u: (counterclockwise)", outline_list.length);
              }
            }
#line 113
            goto while_break___1;
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 115
          outline = find_one_outline(bitmap, edge, row, col, marked, 0, 0, exp___0);
#line 116
          __cil_tmp22 = at_exception_got_fatal(exp___0);
          }
#line 116
          if (__cil_tmp22) {
#line 116
            goto cleanup;
          }
          {
#line 118
          outline.clockwise = 0;
#line 119
          append_pixel_outline(& outline_list, outline);
          }
          {
#line 121
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 121
            if (logging) {
              {
#line 121
              fprintf(stdout, " [%u].\n", outline.length);
              }
            }
#line 121
            goto while_break___2;
          }
          while_break___2: /* CIL Label */ ;
          }
        } else {
#line 107
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 123
        __cil_tmp23 = at_exception_got_fatal(exp___0);
        }
#line 123
        if (__cil_tmp23) {
#line 123
          goto cleanup;
        }
      }

#line 127
      if ((int )row != 0) {
        {
#line 128
        at_bitmap_get_color(bitmap, (unsigned int )((int )row - 1), (unsigned int )col,
                            & color);
#line 129
        edge = (edge_type )3;
#line 129
        __cil_tmp25 = is_unmarked_outline_edge((unsigned short )((int )row - 1), col,
                                               edge, bitmap, marked, color, exp___0);
        }
        {
#line 129
        __cil_tmp24 = at_color_equal(& color, bg_color);
        }
#line 129
        if (! (bg_color && __cil_tmp24)) {
#line 129
          if (__cil_tmp25) {
            {
#line 133
            __cil_tmp27 = at_exception_got_fatal(exp___0);
            }
#line 133
            if (__cil_tmp27) {
#line 133
              goto cleanup;
            }

#line 136
            if (is_background) {
              {
#line 137
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 137
                if (logging) {
                  {
#line 137
                  fprintf(stdout, "#%u: (clockwise)\230\001", outline_list.length);
                  }
                }
#line 137
                goto while_break___3;
              }
              while_break___3: /* CIL Label */ ;
              }
              {
#line 139
              outline___0 = find_one_outline(bitmap, edge, (unsigned short )((int )row - 1),
                                             col, marked, ! 0, 0, exp___0);
#line 140
              __cil_tmp29 = at_exception_got_fatal(exp___0);
              }
#line 140
              if (__cil_tmp29) {
#line 140
                goto cleanup;
              }
              {
#line 142
              outline___0.clockwise = ! 0;
#line 143
              append_pixel_outline(& outline_list, outline___0);
              }
              {
#line 145
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 145
                if (logging) {
                  {
#line 145
                  fprintf(stdout, " [%u].\n", outline___0.length);
                  }
                }
#line 145
                goto while_break___4;
              }
              while_break___4: /* CIL Label */ ;
              }
            } else {
              {
#line 147
              outline___0 = find_one_outline(bitmap, edge, (unsigned short )((int )row - 1),
                                             col, marked, ! 0, ! 0, exp___0);
#line 148
              __cil_tmp31 = at_exception_got_fatal(exp___0);
              }
#line 148
              if (__cil_tmp31) {
#line 148
                goto cleanup;
              }

            }
          } else {
#line 129
            goto _L___4;
          }
        } else {
          _L___4: /* CIL Label */ 
          {
#line 151
          __cil_tmp32 = at_exception_got_fatal(exp___0);
          }
#line 151
          if (__cil_tmp32) {
#line 151
            goto cleanup;
          }
        }

      }
      {
#line 153
      __cil_tmp33 = (*test_cancel)(testcancel_data);
      }
#line 153
      if (test_cancel) {
#line 153
        if (__cil_tmp33) {
          {
#line 154
          free_pixel_outline_list(& outline_list);
          }
#line 155
          goto cleanup;
        }
      }
#line 96
      col ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 95
    row ++;
  }
  while_break: /* CIL Label */ ;
  }
  cleanup: 
  {
#line 160
  at_bitmap_free(marked);
  }
  {
#line 161
  __cil_tmp36 = at_exception_got_fatal(exp___0);
  }
#line 161
  if (__cil_tmp36) {
    {
#line 162
    free_pixel_outline_list(& outline_list);
    }
  }
#line 163
  return (outline_list);
}
}
#line 170 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/pxl-outline.c"
static pixel_outline_type find_one_outline(at_bitmap *bitmap , edge_type original_edge ,
                                           unsigned short original_row , unsigned short original_col ,
                                           at_bitmap *marked , gboolean clockwise ,
                                           gboolean ignore___0 , at_exception_type *exp___0 ) 
{ 
  pixel_outline_type outline ;
  unsigned short row ;
  unsigned short col ;
  edge_type edge ;
  at_coord pos ;
  int tmp ;
  int tmp___0 ;
  pixel_outline_type __cil_tmp16 ;
  at_coord __cil_tmp17 ;
  gboolean __cil_tmp18 ;
  gboolean __cil_tmp19 ;

  {
#line 173
  row = original_row;
#line 173
  col = original_col;
#line 174
  edge = original_edge;
#line 177
  if ((unsigned int )edge == 0U || (unsigned int )edge == 3U) {
#line 177
    tmp = 1;
  } else {
#line 177
    tmp = 0;
  }
#line 177
  pos.x = (gushort )((int )col + tmp);
#line 178
  if ((unsigned int )edge == 1U || (unsigned int )edge == 0U) {
#line 178
    tmp___0 = 1;
  } else {
#line 178
    tmp___0 = 0;
  }
#line 178
  pos.y = (gushort )((((int )bitmap->height - (int )row) - 1) + tmp___0);
#line 180
  if (! ignore___0) {
    {
#line 181
    outline = new_pixel_outline();
    }
  }
  {
#line 182
  at_bitmap_get_color(bitmap, (unsigned int )row, (unsigned int )col, & outline.color);
  }
  {
#line 184
  while (1) {
    while_continue: /* CIL Label */ ;
#line 186
    if (! ignore___0) {
      {
#line 187
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 187
        if (logging) {
          {
#line 187
          fprintf(stdout, " (%d,%d)\230\001", (int )pos.x, (int )pos.y);
          }
        }
#line 187
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 188
      append_outline_pixel(& outline, pos);
      }
    }
    {
#line 191
    mark_edge(edge, row, col, marked);
#line 192
    pos = next_point(bitmap, & edge, & row, & col, outline.color, clockwise, marked,
                     exp___0);
#line 193
    __cil_tmp18 = at_exception_got_fatal(exp___0);
    }
#line 193
    if (__cil_tmp18) {
#line 193
      goto cleanup;
    }

#line 184
    if (! ((unsigned int )edge != 4U)) {
#line 184
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  cleanup: 
  {
#line 198
  __cil_tmp19 = at_exception_got_fatal(exp___0);
  }
#line 198
  if (__cil_tmp19) {
    {
#line 199
    free_pixel_outline(& outline);
    }
  }
#line 200
  return (outline);
}
}
#line 203 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/pxl-outline.c"
gboolean is_valid_dir(unsigned short row , unsigned short col , direction_type dir ,
                      at_bitmap *bitmap , at_bitmap *marked ) 
{ 
  at_color c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  gboolean __cil_tmp35 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  gboolean __cil_tmp64 ;

  {
#line 208
  if ((unsigned int )dir % 2U != 0U) {
#line 208
    if (((unsigned int )dir + 1U) % 8U == 2U) {
#line 208
      tmp___9 = - 1;
    } else {
#line 208
      if (((unsigned int )dir + 1U) % 8U == 6U) {
#line 208
        tmp___8 = 1;
      } else {
#line 208
        tmp___8 = 0;
      }
#line 208
      tmp___9 = tmp___8;
    }
#line 208
    if ((unsigned int )dir - 1U == 2U) {
#line 208
      tmp___7 = - 1;
    } else {
#line 208
      if ((unsigned int )dir - 1U == 6U) {
#line 208
        tmp___6 = 1;
      } else {
#line 208
        tmp___6 = 0;
      }
#line 208
      tmp___7 = tmp___6;
    }
#line 208
    tmp___12 = tmp___7 + tmp___9;
  } else {
#line 208
    if ((unsigned int )dir == 2U) {
#line 208
      tmp___11 = - 1;
    } else {
#line 208
      if ((unsigned int )dir == 6U) {
#line 208
        tmp___10 = 1;
      } else {
#line 208
        tmp___10 = 0;
      }
#line 208
      tmp___11 = tmp___10;
    }
#line 208
    tmp___12 = tmp___11;
  }
#line 208
  if ((unsigned int )dir % 2U != 0U) {
#line 208
    if (((unsigned int )dir + 1U) % 8U == 0U) {
#line 208
      tmp___2 = - 1;
    } else {
#line 208
      if (((unsigned int )dir + 1U) % 8U == 4U) {
#line 208
        tmp___1 = 1;
      } else {
#line 208
        tmp___1 = 0;
      }
#line 208
      tmp___2 = tmp___1;
    }
#line 208
    if ((unsigned int )dir - 1U == 0U) {
#line 208
      tmp___0 = - 1;
    } else {
#line 208
      if ((unsigned int )dir - 1U == 4U) {
#line 208
        tmp = 1;
      } else {
#line 208
        tmp = 0;
      }
#line 208
      tmp___0 = tmp;
    }
#line 208
    tmp___5 = tmp___0 + tmp___2;
  } else {
#line 208
    if ((unsigned int )dir == 0U) {
#line 208
      tmp___4 = - 1;
    } else {
#line 208
      if ((unsigned int )dir == 4U) {
#line 208
        tmp___3 = 1;
      } else {
#line 208
        tmp___3 = 0;
      }
#line 208
      tmp___4 = tmp___3;
    }
#line 208
    tmp___5 = tmp___4;
  }
#line 208
  if (tmp___5 + (int )row < 0) {
#line 209
    return (0);
  } else
#line 208
  if (tmp___12 + (int )col < 0) {
#line 209
    return (0);
  }
#line 211
  if ((unsigned int )dir % 2U != 0U) {
#line 211
    if (((unsigned int )dir + 1U) % 8U == 0U) {
#line 211
      tmp___16 = - 1;
    } else {
#line 211
      if (((unsigned int )dir + 1U) % 8U == 4U) {
#line 211
        tmp___15 = 1;
      } else {
#line 211
        tmp___15 = 0;
      }
#line 211
      tmp___16 = tmp___15;
    }
#line 211
    if ((unsigned int )dir - 1U == 0U) {
#line 211
      tmp___14 = - 1;
    } else {
#line 211
      if ((unsigned int )dir - 1U == 4U) {
#line 211
        tmp___13 = 1;
      } else {
#line 211
        tmp___13 = 0;
      }
#line 211
      tmp___14 = tmp___13;
    }
#line 211
    tmp___19 = tmp___14 + tmp___16;
  } else {
#line 211
    if ((unsigned int )dir == 0U) {
#line 211
      tmp___18 = - 1;
    } else {
#line 211
      if ((unsigned int )dir == 4U) {
#line 211
        tmp___17 = 1;
      } else {
#line 211
        tmp___17 = 0;
      }
#line 211
      tmp___18 = tmp___17;
    }
#line 211
    tmp___19 = tmp___18;
  }
#line 211
  if ((unsigned int )dir % 2U != 0U) {
#line 211
    if (((unsigned int )dir + 1U) % 8U == 2U) {
#line 211
      tmp___23 = - 1;
    } else {
#line 211
      if (((unsigned int )dir + 1U) % 8U == 6U) {
#line 211
        tmp___22 = 1;
      } else {
#line 211
        tmp___22 = 0;
      }
#line 211
      tmp___23 = tmp___22;
    }
#line 211
    if ((unsigned int )dir - 1U == 2U) {
#line 211
      tmp___21 = - 1;
    } else {
#line 211
      if ((unsigned int )dir - 1U == 6U) {
#line 211
        tmp___20 = 1;
      } else {
#line 211
        tmp___20 = 0;
      }
#line 211
      tmp___21 = tmp___20;
    }
#line 211
    tmp___26 = tmp___21 + tmp___23;
  } else {
#line 211
    if ((unsigned int )dir == 2U) {
#line 211
      tmp___25 = - 1;
    } else {
#line 211
      if ((unsigned int )dir == 6U) {
#line 211
        tmp___24 = 1;
      } else {
#line 211
        tmp___24 = 0;
      }
#line 211
      tmp___25 = tmp___24;
    }
#line 211
    tmp___26 = tmp___25;
  }
  {
#line 211
  at_bitmap_get_color(bitmap, (unsigned int )(tmp___19 + (int )row), (unsigned int )(tmp___26 + (int )col),
                      & c);
#line 212
  __cil_tmp64 = at_bitmap_equal_color(bitmap, (unsigned int )row, (unsigned int )col,
                                      & c);
  }
#line 212
  if ((unsigned int )dir % 2U != 0U) {
#line 212
    if (((unsigned int )dir + 1U) % 8U == 2U) {
#line 212
      tmp___51 = - 1;
    } else {
#line 212
      if (((unsigned int )dir + 1U) % 8U == 6U) {
#line 212
        tmp___50 = 1;
      } else {
#line 212
        tmp___50 = 0;
      }
#line 212
      tmp___51 = tmp___50;
    }
#line 212
    if ((unsigned int )dir - 1U == 2U) {
#line 212
      tmp___49 = - 1;
    } else {
#line 212
      if ((unsigned int )dir - 1U == 6U) {
#line 212
        tmp___48 = 1;
      } else {
#line 212
        tmp___48 = 0;
      }
#line 212
      tmp___49 = tmp___48;
    }
#line 212
    tmp___54 = tmp___49 + tmp___51;
  } else {
#line 212
    if ((unsigned int )dir == 2U) {
#line 212
      tmp___53 = - 1;
    } else {
#line 212
      if ((unsigned int )dir == 6U) {
#line 212
        tmp___52 = 1;
      } else {
#line 212
        tmp___52 = 0;
      }
#line 212
      tmp___53 = tmp___52;
    }
#line 212
    tmp___54 = tmp___53;
  }
#line 212
  if ((unsigned int )dir % 2U != 0U) {
#line 212
    if (((unsigned int )dir + 1U) % 8U == 0U) {
#line 212
      tmp___44 = - 1;
    } else {
#line 212
      if (((unsigned int )dir + 1U) % 8U == 4U) {
#line 212
        tmp___43 = 1;
      } else {
#line 212
        tmp___43 = 0;
      }
#line 212
      tmp___44 = tmp___43;
    }
#line 212
    if ((unsigned int )dir - 1U == 0U) {
#line 212
      tmp___42 = - 1;
    } else {
#line 212
      if ((unsigned int )dir - 1U == 4U) {
#line 212
        tmp___41 = 1;
      } else {
#line 212
        tmp___41 = 0;
      }
#line 212
      tmp___42 = tmp___41;
    }
#line 212
    tmp___47 = tmp___42 + tmp___44;
  } else {
#line 212
    if ((unsigned int )dir == 0U) {
#line 212
      tmp___46 = - 1;
    } else {
#line 212
      if ((unsigned int )dir == 4U) {
#line 212
        tmp___45 = 1;
      } else {
#line 212
        tmp___45 = 0;
      }
#line 212
      tmp___46 = tmp___45;
    }
#line 212
    tmp___47 = tmp___46;
  }
#line 212
  if ((unsigned int )dir % 2U != 0U) {
#line 212
    if (((unsigned int )dir + 1U) % 8U == 2U) {
#line 212
      tmp___37 = - 1;
    } else {
#line 212
      if (((unsigned int )dir + 1U) % 8U == 6U) {
#line 212
        tmp___36 = 1;
      } else {
#line 212
        tmp___36 = 0;
      }
#line 212
      tmp___37 = tmp___36;
    }
#line 212
    if ((unsigned int )dir - 1U == 2U) {
#line 212
      tmp___35 = - 1;
    } else {
#line 212
      if ((unsigned int )dir - 1U == 6U) {
#line 212
        tmp___34 = 1;
      } else {
#line 212
        tmp___34 = 0;
      }
#line 212
      tmp___35 = tmp___34;
    }
#line 212
    tmp___40 = tmp___35 + tmp___37;
  } else {
#line 212
    if ((unsigned int )dir == 2U) {
#line 212
      tmp___39 = - 1;
    } else {
#line 212
      if ((unsigned int )dir == 6U) {
#line 212
        tmp___38 = 1;
      } else {
#line 212
        tmp___38 = 0;
      }
#line 212
      tmp___39 = tmp___38;
    }
#line 212
    tmp___40 = tmp___39;
  }
#line 212
  if ((unsigned int )dir % 2U != 0U) {
#line 212
    if (((unsigned int )dir + 1U) % 8U == 0U) {
#line 212
      tmp___30 = - 1;
    } else {
#line 212
      if (((unsigned int )dir + 1U) % 8U == 4U) {
#line 212
        tmp___29 = 1;
      } else {
#line 212
        tmp___29 = 0;
      }
#line 212
      tmp___30 = tmp___29;
    }
#line 212
    if ((unsigned int )dir - 1U == 0U) {
#line 212
      tmp___28 = - 1;
    } else {
#line 212
      if ((unsigned int )dir - 1U == 4U) {
#line 212
        tmp___27 = 1;
      } else {
#line 212
        tmp___27 = 0;
      }
#line 212
      tmp___28 = tmp___27;
    }
#line 212
    tmp___33 = tmp___28 + tmp___30;
  } else {
#line 212
    if ((unsigned int )dir == 0U) {
#line 212
      tmp___32 = - 1;
    } else {
#line 212
      if ((unsigned int )dir == 4U) {
#line 212
        tmp___31 = 1;
      } else {
#line 212
        tmp___31 = 0;
      }
#line 212
      tmp___32 = tmp___31;
    }
#line 212
    tmp___33 = tmp___32;
  }
  {
#line 212
  __cil_tmp35 = is_marked_dir(row, col, dir, marked);
  }
#line 212
  return ((gboolean )((((! __cil_tmp35 && tmp___33 + (int )row > 0) && tmp___40 + (int )col > 0) && (tmp___47 + (int )row < (int )bitmap->height && tmp___54 + (int )col < (int )bitmap->width)) && __cil_tmp64));
}
}
#line 217 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/pxl-outline.c"
pixel_outline_list_type find_centerline_pixels(at_bitmap *bitmap , at_color bg_color ,
                                               at_progress_func notify_progress ,
                                               gpointer progress_data , at_testcancel_func test_cancel ,
                                               gpointer testcancel_data , at_exception_type *exp___0 ) 
{ 
  pixel_outline_list_type outline_list ;
  short row ;
  short col ;
  at_bitmap *marked ;
  at_bitmap *__cil_tmp12 ;
  unsigned int max_progress ;
  direction_type dir ;
  pixel_outline_type outline ;
  gboolean clockwise ;
  gboolean __cil_tmp17 ;
  short __cil_tmp18 ;
  gboolean __cil_tmp19 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  gboolean __cil_tmp34 ;
  unsigned int __cil_tmp35 ;
  unsigned int __cil_tmp36 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  unsigned int __cil_tmp51 ;
  gboolean __cil_tmp52 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  gboolean __cil_tmp67 ;
  gboolean __cil_tmp68 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  gboolean __cil_tmp83 ;
  unsigned int __cil_tmp84 ;
  unsigned int __cil_tmp85 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  unsigned int __cil_tmp100 ;
  gboolean __cil_tmp101 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  int tmp___74 ;
  int tmp___75 ;
  int tmp___76 ;
  int tmp___77 ;
  int tmp___78 ;
  int tmp___79 ;
  int tmp___80 ;
  int tmp___81 ;
  int tmp___82 ;
  gboolean __cil_tmp116 ;
  gboolean __cil_tmp117 ;
  int tmp___83 ;
  int tmp___84 ;
  int tmp___85 ;
  int tmp___86 ;
  int tmp___87 ;
  int tmp___88 ;
  int tmp___89 ;
  int tmp___90 ;
  int tmp___91 ;
  int tmp___92 ;
  int tmp___93 ;
  int tmp___94 ;
  int tmp___95 ;
  int tmp___96 ;
  gboolean __cil_tmp132 ;
  unsigned int __cil_tmp133 ;
  unsigned int __cil_tmp134 ;
  int tmp___97 ;
  int tmp___98 ;
  int tmp___99 ;
  int tmp___100 ;
  int tmp___101 ;
  int tmp___102 ;
  int tmp___103 ;
  int tmp___104 ;
  int tmp___105 ;
  int tmp___106 ;
  int tmp___107 ;
  int tmp___108 ;
  int tmp___109 ;
  int tmp___110 ;
  unsigned int __cil_tmp149 ;
  gboolean __cil_tmp150 ;
  int tmp___111 ;
  int tmp___112 ;
  int tmp___113 ;
  int tmp___114 ;
  int tmp___115 ;
  int tmp___116 ;
  int tmp___117 ;
  int tmp___118 ;
  int tmp___119 ;
  int tmp___120 ;
  int tmp___121 ;
  int tmp___122 ;
  int tmp___123 ;
  int tmp___124 ;
  gboolean __cil_tmp165 ;
  gboolean __cil_tmp166 ;
  int tmp___125 ;
  int tmp___126 ;
  int tmp___127 ;
  int tmp___128 ;
  int tmp___129 ;
  int tmp___130 ;
  int tmp___131 ;
  int tmp___132 ;
  int tmp___133 ;
  int tmp___134 ;
  int tmp___135 ;
  int tmp___136 ;
  int tmp___137 ;
  int tmp___138 ;
  gboolean __cil_tmp181 ;
  unsigned int __cil_tmp182 ;
  unsigned int __cil_tmp183 ;
  int tmp___139 ;
  int tmp___140 ;
  int tmp___141 ;
  int tmp___142 ;
  int tmp___143 ;
  int tmp___144 ;
  int tmp___145 ;
  int tmp___146 ;
  int tmp___147 ;
  int tmp___148 ;
  int tmp___149 ;
  int tmp___150 ;
  int tmp___151 ;
  int tmp___152 ;
  unsigned int __cil_tmp198 ;
  gboolean __cil_tmp199 ;
  int tmp___153 ;
  int tmp___154 ;
  int tmp___155 ;
  int tmp___156 ;
  int tmp___157 ;
  int tmp___158 ;
  int tmp___159 ;
  int tmp___160 ;
  int tmp___161 ;
  int tmp___162 ;
  int tmp___163 ;
  int tmp___164 ;
  int tmp___165 ;
  int tmp___166 ;
  gboolean __cil_tmp214 ;
  short __cil_tmp215 ;
  char const   *tmp___167 ;
  pixel_outline_type __cil_tmp217 ;
  pixel_outline_type partial_outline ;
  gboolean okay ;
  gboolean __cil_tmp220 ;
  gboolean __cil_tmp221 ;
  gboolean __cil_tmp222 ;
  gboolean __cil_tmp223 ;
  gboolean __cil_tmp224 ;
  gboolean __cil_tmp225 ;
  gboolean __cil_tmp226 ;
  gboolean __cil_tmp227 ;
  gboolean __cil_tmp228 ;
  gboolean __cil_tmp229 ;
  gboolean __cil_tmp230 ;
  gboolean __cil_tmp231 ;
  pixel_outline_type __cil_tmp232 ;
  short __cil_tmp233 ;
  char const   *tmp___168 ;
  short __cil_tmp235 ;
  gboolean __cil_tmp236 ;

  {
  {
#line 221
  __cil_tmp12 = at_bitmap_new(bitmap->width, bitmap->height, (unsigned int )1);
#line 221
  marked = __cil_tmp12;
#line 222
  max_progress = (unsigned int )((int )bitmap->height * (int )bitmap->width);
#line 224
  outline_list.length = (unsigned int )0;
#line 225
  outline_list.data = (pixel_outline_type *)((void *)0);
#line 227
  row = (short )0;
  }
  {
#line 227
  while (1) {
    while_continue: /* CIL Label */ ;
#line 227
    if (! ((int )row < (int )bitmap->height)) {
#line 227
      goto while_break;
    }
#line 228
    col = (short )0;
    {
#line 228
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 228
      if (! ((int )col < (int )bitmap->width)) {
#line 228
        goto while_break___0;
      }
#line 229
      dir = (direction_type )6;
#line 231
      clockwise = 0;
#line 233
      if (notify_progress) {
        {
#line 234
        (*notify_progress)((gfloat )((int )row * (int )bitmap->width + (int )col) / ((gfloat )max_progress * (gfloat )3.),
                           progress_data);
        }
      }
      {
#line 236
      __cil_tmp17 = at_bitmap_equal_color(bitmap, (unsigned int )row, (unsigned int )col,
                                          & bg_color);
      }
#line 236
      if (__cil_tmp17) {
#line 237
        col ++;
#line 238
        goto while_continue___0;
      }
#line 241
      if ((unsigned int )dir % 2U != 0U) {
#line 241
        if (((unsigned int )dir + 1U) % 8U == 0U) {
#line 241
          tmp___30 = - 1;
        } else {
#line 241
          if (((unsigned int )dir + 1U) % 8U == 4U) {
#line 241
            tmp___29 = 1;
          } else {
#line 241
            tmp___29 = 0;
          }
#line 241
          tmp___30 = tmp___29;
        }
#line 241
        if ((unsigned int )dir - 1U == 0U) {
#line 241
          tmp___28 = - 1;
        } else {
#line 241
          if ((unsigned int )dir - 1U == 4U) {
#line 241
            tmp___27 = 1;
          } else {
#line 241
            tmp___27 = 0;
          }
#line 241
          tmp___28 = tmp___27;
        }
#line 241
        tmp___33 = tmp___28 + tmp___30;
      } else {
#line 241
        if ((unsigned int )dir == 0U) {
#line 241
          tmp___32 = - 1;
        } else {
#line 241
          if ((unsigned int )dir == 4U) {
#line 241
            tmp___31 = 1;
          } else {
#line 241
            tmp___31 = 0;
          }
#line 241
          tmp___32 = tmp___31;
        }
#line 241
        tmp___33 = tmp___32;
      }
#line 241
      if ((unsigned int )dir % 2U != 0U) {
#line 241
        if (((unsigned int )dir + 1U) % 8U == 2U) {
#line 241
          tmp___37 = - 1;
        } else {
#line 241
          if (((unsigned int )dir + 1U) % 8U == 6U) {
#line 241
            tmp___36 = 1;
          } else {
#line 241
            tmp___36 = 0;
          }
#line 241
          tmp___37 = tmp___36;
        }
#line 241
        if ((unsigned int )dir - 1U == 2U) {
#line 241
          tmp___35 = - 1;
        } else {
#line 241
          if ((unsigned int )dir - 1U == 6U) {
#line 241
            tmp___34 = 1;
          } else {
#line 241
            tmp___34 = 0;
          }
#line 241
          tmp___35 = tmp___34;
        }
#line 241
        tmp___40 = tmp___35 + tmp___37;
      } else {
#line 241
        if ((unsigned int )dir == 2U) {
#line 241
          tmp___39 = - 1;
        } else {
#line 241
          if ((unsigned int )dir == 6U) {
#line 241
            tmp___38 = 1;
          } else {
#line 241
            tmp___38 = 0;
          }
#line 241
          tmp___39 = tmp___38;
        }
#line 241
        tmp___40 = tmp___39;
      }
      {
#line 241
      __cil_tmp67 = is_other_dir_marked((unsigned short )((int )row + tmp___33), (unsigned short )((int )col + tmp___40),
                                        dir, marked);
      }
      {
#line 241
      __cil_tmp52 = is_other_dir_marked((unsigned short )row, (unsigned short )col,
                                        dir, marked);
      }
#line 241
      if ((unsigned int )dir % 2U != 0U) {
#line 241
        if (((unsigned int )dir + 1U) % 8U == 0U) {
#line 241
          tmp___16 = - 1;
        } else {
#line 241
          if (((unsigned int )dir + 1U) % 8U == 4U) {
#line 241
            tmp___15 = 1;
          } else {
#line 241
            tmp___15 = 0;
          }
#line 241
          tmp___16 = tmp___15;
        }
#line 241
        if ((unsigned int )dir - 1U == 0U) {
#line 241
          tmp___14 = - 1;
        } else {
#line 241
          if ((unsigned int )dir - 1U == 4U) {
#line 241
            tmp___13 = 1;
          } else {
#line 241
            tmp___13 = 0;
          }
#line 241
          tmp___14 = tmp___13;
        }
#line 241
        tmp___19 = tmp___14 + tmp___16;
      } else {
#line 241
        if ((unsigned int )dir == 0U) {
#line 241
          tmp___18 = - 1;
        } else {
#line 241
          if ((unsigned int )dir == 4U) {
#line 241
            tmp___17 = 1;
          } else {
#line 241
            tmp___17 = 0;
          }
#line 241
          tmp___18 = tmp___17;
        }
#line 241
        tmp___19 = tmp___18;
      }
#line 241
      if ((unsigned int )dir % 2U != 0U) {
#line 241
        if (((unsigned int )dir + 1U) % 8U == 2U) {
#line 241
          tmp___23 = - 1;
        } else {
#line 241
          if (((unsigned int )dir + 1U) % 8U == 6U) {
#line 241
            tmp___22 = 1;
          } else {
#line 241
            tmp___22 = 0;
          }
#line 241
          tmp___23 = tmp___22;
        }
#line 241
        if ((unsigned int )dir - 1U == 2U) {
#line 241
          tmp___21 = - 1;
        } else {
#line 241
          if ((unsigned int )dir - 1U == 6U) {
#line 241
            tmp___20 = 1;
          } else {
#line 241
            tmp___20 = 0;
          }
#line 241
          tmp___21 = tmp___20;
        }
#line 241
        tmp___26 = tmp___21 + tmp___23;
      } else {
#line 241
        if ((unsigned int )dir == 2U) {
#line 241
          tmp___25 = - 1;
        } else {
#line 241
          if ((unsigned int )dir == 6U) {
#line 241
            tmp___24 = 1;
          } else {
#line 241
            tmp___24 = 0;
          }
#line 241
          tmp___25 = tmp___24;
        }
#line 241
        tmp___26 = tmp___25;
      }
      {
#line 241
      __cil_tmp51 = num_neighbors((unsigned short )(tmp___19 + (int )row), (unsigned short )(tmp___26 + (int )col),
                                  bitmap);
      }
      {
#line 241
      __cil_tmp36 = num_neighbors((unsigned short )row, (unsigned short )col, bitmap);
      }
      {
#line 241
      __cil_tmp35 = num_neighbors((unsigned short )row, (unsigned short )col, bitmap);
      }
#line 241
      if ((unsigned int )dir % 2U != 0U) {
#line 241
        if (((unsigned int )dir + 1U) % 8U == 0U) {
#line 241
          tmp___2 = - 1;
        } else {
#line 241
          if (((unsigned int )dir + 1U) % 8U == 4U) {
#line 241
            tmp___1 = 1;
          } else {
#line 241
            tmp___1 = 0;
          }
#line 241
          tmp___2 = tmp___1;
        }
#line 241
        if ((unsigned int )dir - 1U == 0U) {
#line 241
          tmp___0 = - 1;
        } else {
#line 241
          if ((unsigned int )dir - 1U == 4U) {
#line 241
            tmp = 1;
          } else {
#line 241
            tmp = 0;
          }
#line 241
          tmp___0 = tmp;
        }
#line 241
        tmp___5 = tmp___0 + tmp___2;
      } else {
#line 241
        if ((unsigned int )dir == 0U) {
#line 241
          tmp___4 = - 1;
        } else {
#line 241
          if ((unsigned int )dir == 4U) {
#line 241
            tmp___3 = 1;
          } else {
#line 241
            tmp___3 = 0;
          }
#line 241
          tmp___4 = tmp___3;
        }
#line 241
        tmp___5 = tmp___4;
      }
#line 241
      if ((unsigned int )dir % 2U != 0U) {
#line 241
        if (((unsigned int )dir + 1U) % 8U == 2U) {
#line 241
          tmp___9 = - 1;
        } else {
#line 241
          if (((unsigned int )dir + 1U) % 8U == 6U) {
#line 241
            tmp___8 = 1;
          } else {
#line 241
            tmp___8 = 0;
          }
#line 241
          tmp___9 = tmp___8;
        }
#line 241
        if ((unsigned int )dir - 1U == 2U) {
#line 241
          tmp___7 = - 1;
        } else {
#line 241
          if ((unsigned int )dir - 1U == 6U) {
#line 241
            tmp___6 = 1;
          } else {
#line 241
            tmp___6 = 0;
          }
#line 241
          tmp___7 = tmp___6;
        }
#line 241
        tmp___12 = tmp___7 + tmp___9;
      } else {
#line 241
        if ((unsigned int )dir == 2U) {
#line 241
          tmp___11 = - 1;
        } else {
#line 241
          if ((unsigned int )dir == 6U) {
#line 241
            tmp___10 = 1;
          } else {
#line 241
            tmp___10 = 0;
          }
#line 241
          tmp___11 = tmp___10;
        }
#line 241
        tmp___12 = tmp___11;
      }
      {
#line 241
      __cil_tmp34 = is_valid_dir((unsigned short )(tmp___5 + (int )row), (unsigned short )(tmp___12 + (int )col),
                                 dir, bitmap, marked);
      }
      {
#line 241
      __cil_tmp19 = is_valid_dir((unsigned short )row, (unsigned short )col, dir,
                                 bitmap, marked);
      }
#line 241
      if (! __cil_tmp19) {
        _L___15: /* CIL Label */ 
        _L___16: /* CIL Label */ 
        _L___17: /* CIL Label */ 
        _L___18: /* CIL Label */ 
#line 246
        dir = (direction_type )5;
#line 247
        if ((unsigned int )dir % 2U != 0U) {
#line 247
          if (((unsigned int )dir + 1U) % 8U == 0U) {
#line 247
            tmp___72 = - 1;
          } else {
#line 247
            if (((unsigned int )dir + 1U) % 8U == 4U) {
#line 247
              tmp___71 = 1;
            } else {
#line 247
              tmp___71 = 0;
            }
#line 247
            tmp___72 = tmp___71;
          }
#line 247
          if ((unsigned int )dir - 1U == 0U) {
#line 247
            tmp___70 = - 1;
          } else {
#line 247
            if ((unsigned int )dir - 1U == 4U) {
#line 247
              tmp___69 = 1;
            } else {
#line 247
              tmp___69 = 0;
            }
#line 247
            tmp___70 = tmp___69;
          }
#line 247
          tmp___75 = tmp___70 + tmp___72;
        } else {
#line 247
          if ((unsigned int )dir == 0U) {
#line 247
            tmp___74 = - 1;
          } else {
#line 247
            if ((unsigned int )dir == 4U) {
#line 247
              tmp___73 = 1;
            } else {
#line 247
              tmp___73 = 0;
            }
#line 247
            tmp___74 = tmp___73;
          }
#line 247
          tmp___75 = tmp___74;
        }
#line 247
        if ((unsigned int )dir % 2U != 0U) {
#line 247
          if (((unsigned int )dir + 1U) % 8U == 2U) {
#line 247
            tmp___79 = - 1;
          } else {
#line 247
            if (((unsigned int )dir + 1U) % 8U == 6U) {
#line 247
              tmp___78 = 1;
            } else {
#line 247
              tmp___78 = 0;
            }
#line 247
            tmp___79 = tmp___78;
          }
#line 247
          if ((unsigned int )dir - 1U == 2U) {
#line 247
            tmp___77 = - 1;
          } else {
#line 247
            if ((unsigned int )dir - 1U == 6U) {
#line 247
              tmp___76 = 1;
            } else {
#line 247
              tmp___76 = 0;
            }
#line 247
            tmp___77 = tmp___76;
          }
#line 247
          tmp___82 = tmp___77 + tmp___79;
        } else {
#line 247
          if ((unsigned int )dir == 2U) {
#line 247
            tmp___81 = - 1;
          } else {
#line 247
            if ((unsigned int )dir == 6U) {
#line 247
              tmp___80 = 1;
            } else {
#line 247
              tmp___80 = 0;
            }
#line 247
            tmp___81 = tmp___80;
          }
#line 247
          tmp___82 = tmp___81;
        }
        {
#line 247
        __cil_tmp116 = is_other_dir_marked((unsigned short )((int )row + tmp___75),
                                           (unsigned short )((int )col + tmp___82),
                                           dir, marked);
        }
        {
#line 247
        __cil_tmp101 = is_other_dir_marked((unsigned short )row, (unsigned short )col,
                                           dir, marked);
        }
#line 247
        if ((unsigned int )dir % 2U != 0U) {
#line 247
          if (((unsigned int )dir + 1U) % 8U == 0U) {
#line 247
            tmp___58 = - 1;
          } else {
#line 247
            if (((unsigned int )dir + 1U) % 8U == 4U) {
#line 247
              tmp___57 = 1;
            } else {
#line 247
              tmp___57 = 0;
            }
#line 247
            tmp___58 = tmp___57;
          }
#line 247
          if ((unsigned int )dir - 1U == 0U) {
#line 247
            tmp___56 = - 1;
          } else {
#line 247
            if ((unsigned int )dir - 1U == 4U) {
#line 247
              tmp___55 = 1;
            } else {
#line 247
              tmp___55 = 0;
            }
#line 247
            tmp___56 = tmp___55;
          }
#line 247
          tmp___61 = tmp___56 + tmp___58;
        } else {
#line 247
          if ((unsigned int )dir == 0U) {
#line 247
            tmp___60 = - 1;
          } else {
#line 247
            if ((unsigned int )dir == 4U) {
#line 247
              tmp___59 = 1;
            } else {
#line 247
              tmp___59 = 0;
            }
#line 247
            tmp___60 = tmp___59;
          }
#line 247
          tmp___61 = tmp___60;
        }
#line 247
        if ((unsigned int )dir % 2U != 0U) {
#line 247
          if (((unsigned int )dir + 1U) % 8U == 2U) {
#line 247
            tmp___65 = - 1;
          } else {
#line 247
            if (((unsigned int )dir + 1U) % 8U == 6U) {
#line 247
              tmp___64 = 1;
            } else {
#line 247
              tmp___64 = 0;
            }
#line 247
            tmp___65 = tmp___64;
          }
#line 247
          if ((unsigned int )dir - 1U == 2U) {
#line 247
            tmp___63 = - 1;
          } else {
#line 247
            if ((unsigned int )dir - 1U == 6U) {
#line 247
              tmp___62 = 1;
            } else {
#line 247
              tmp___62 = 0;
            }
#line 247
            tmp___63 = tmp___62;
          }
#line 247
          tmp___68 = tmp___63 + tmp___65;
        } else {
#line 247
          if ((unsigned int )dir == 2U) {
#line 247
            tmp___67 = - 1;
          } else {
#line 247
            if ((unsigned int )dir == 6U) {
#line 247
              tmp___66 = 1;
            } else {
#line 247
              tmp___66 = 0;
            }
#line 247
            tmp___67 = tmp___66;
          }
#line 247
          tmp___68 = tmp___67;
        }
        {
#line 247
        __cil_tmp100 = num_neighbors((unsigned short )(tmp___61 + (int )row), (unsigned short )(tmp___68 + (int )col),
                                     bitmap);
        }
        {
#line 247
        __cil_tmp85 = num_neighbors((unsigned short )row, (unsigned short )col, bitmap);
        }
        {
#line 247
        __cil_tmp84 = num_neighbors((unsigned short )row, (unsigned short )col, bitmap);
        }
#line 247
        if ((unsigned int )dir % 2U != 0U) {
#line 247
          if (((unsigned int )dir + 1U) % 8U == 0U) {
#line 247
            tmp___44 = - 1;
          } else {
#line 247
            if (((unsigned int )dir + 1U) % 8U == 4U) {
#line 247
              tmp___43 = 1;
            } else {
#line 247
              tmp___43 = 0;
            }
#line 247
            tmp___44 = tmp___43;
          }
#line 247
          if ((unsigned int )dir - 1U == 0U) {
#line 247
            tmp___42 = - 1;
          } else {
#line 247
            if ((unsigned int )dir - 1U == 4U) {
#line 247
              tmp___41 = 1;
            } else {
#line 247
              tmp___41 = 0;
            }
#line 247
            tmp___42 = tmp___41;
          }
#line 247
          tmp___47 = tmp___42 + tmp___44;
        } else {
#line 247
          if ((unsigned int )dir == 0U) {
#line 247
            tmp___46 = - 1;
          } else {
#line 247
            if ((unsigned int )dir == 4U) {
#line 247
              tmp___45 = 1;
            } else {
#line 247
              tmp___45 = 0;
            }
#line 247
            tmp___46 = tmp___45;
          }
#line 247
          tmp___47 = tmp___46;
        }
#line 247
        if ((unsigned int )dir % 2U != 0U) {
#line 247
          if (((unsigned int )dir + 1U) % 8U == 2U) {
#line 247
            tmp___51 = - 1;
          } else {
#line 247
            if (((unsigned int )dir + 1U) % 8U == 6U) {
#line 247
              tmp___50 = 1;
            } else {
#line 247
              tmp___50 = 0;
            }
#line 247
            tmp___51 = tmp___50;
          }
#line 247
          if ((unsigned int )dir - 1U == 2U) {
#line 247
            tmp___49 = - 1;
          } else {
#line 247
            if ((unsigned int )dir - 1U == 6U) {
#line 247
              tmp___48 = 1;
            } else {
#line 247
              tmp___48 = 0;
            }
#line 247
            tmp___49 = tmp___48;
          }
#line 247
          tmp___54 = tmp___49 + tmp___51;
        } else {
#line 247
          if ((unsigned int )dir == 2U) {
#line 247
            tmp___53 = - 1;
          } else {
#line 247
            if ((unsigned int )dir == 6U) {
#line 247
              tmp___52 = 1;
            } else {
#line 247
              tmp___52 = 0;
            }
#line 247
            tmp___53 = tmp___52;
          }
#line 247
          tmp___54 = tmp___53;
        }
        {
#line 247
        __cil_tmp83 = is_valid_dir((unsigned short )(tmp___47 + (int )row), (unsigned short )(tmp___54 + (int )col),
                                   dir, bitmap, marked);
        }
        {
#line 247
        __cil_tmp68 = is_valid_dir((unsigned short )row, (unsigned short )col, dir,
                                   bitmap, marked);
        }
#line 247
        if (! __cil_tmp68) {
          _L___10: /* CIL Label */ 
          _L___11: /* CIL Label */ 
          _L___12: /* CIL Label */ 
          _L___13: /* CIL Label */ 
#line 252
          dir = (direction_type )4;
#line 253
          if ((unsigned int )dir % 2U != 0U) {
#line 253
            if (((unsigned int )dir + 1U) % 8U == 0U) {
#line 253
              tmp___114 = - 1;
            } else {
#line 253
              if (((unsigned int )dir + 1U) % 8U == 4U) {
#line 253
                tmp___113 = 1;
              } else {
#line 253
                tmp___113 = 0;
              }
#line 253
              tmp___114 = tmp___113;
            }
#line 253
            if ((unsigned int )dir - 1U == 0U) {
#line 253
              tmp___112 = - 1;
            } else {
#line 253
              if ((unsigned int )dir - 1U == 4U) {
#line 253
                tmp___111 = 1;
              } else {
#line 253
                tmp___111 = 0;
              }
#line 253
              tmp___112 = tmp___111;
            }
#line 253
            tmp___117 = tmp___112 + tmp___114;
          } else {
#line 253
            if ((unsigned int )dir == 0U) {
#line 253
              tmp___116 = - 1;
            } else {
#line 253
              if ((unsigned int )dir == 4U) {
#line 253
                tmp___115 = 1;
              } else {
#line 253
                tmp___115 = 0;
              }
#line 253
              tmp___116 = tmp___115;
            }
#line 253
            tmp___117 = tmp___116;
          }
#line 253
          if ((unsigned int )dir % 2U != 0U) {
#line 253
            if (((unsigned int )dir + 1U) % 8U == 2U) {
#line 253
              tmp___121 = - 1;
            } else {
#line 253
              if (((unsigned int )dir + 1U) % 8U == 6U) {
#line 253
                tmp___120 = 1;
              } else {
#line 253
                tmp___120 = 0;
              }
#line 253
              tmp___121 = tmp___120;
            }
#line 253
            if ((unsigned int )dir - 1U == 2U) {
#line 253
              tmp___119 = - 1;
            } else {
#line 253
              if ((unsigned int )dir - 1U == 6U) {
#line 253
                tmp___118 = 1;
              } else {
#line 253
                tmp___118 = 0;
              }
#line 253
              tmp___119 = tmp___118;
            }
#line 253
            tmp___124 = tmp___119 + tmp___121;
          } else {
#line 253
            if ((unsigned int )dir == 2U) {
#line 253
              tmp___123 = - 1;
            } else {
#line 253
              if ((unsigned int )dir == 6U) {
#line 253
                tmp___122 = 1;
              } else {
#line 253
                tmp___122 = 0;
              }
#line 253
              tmp___123 = tmp___122;
            }
#line 253
            tmp___124 = tmp___123;
          }
          {
#line 253
          __cil_tmp165 = is_other_dir_marked((unsigned short )((int )row + tmp___117),
                                             (unsigned short )((int )col + tmp___124),
                                             dir, marked);
          }
          {
#line 253
          __cil_tmp150 = is_other_dir_marked((unsigned short )row, (unsigned short )col,
                                             dir, marked);
          }
#line 253
          if ((unsigned int )dir % 2U != 0U) {
#line 253
            if (((unsigned int )dir + 1U) % 8U == 0U) {
#line 253
              tmp___100 = - 1;
            } else {
#line 253
              if (((unsigned int )dir + 1U) % 8U == 4U) {
#line 253
                tmp___99 = 1;
              } else {
#line 253
                tmp___99 = 0;
              }
#line 253
              tmp___100 = tmp___99;
            }
#line 253
            if ((unsigned int )dir - 1U == 0U) {
#line 253
              tmp___98 = - 1;
            } else {
#line 253
              if ((unsigned int )dir - 1U == 4U) {
#line 253
                tmp___97 = 1;
              } else {
#line 253
                tmp___97 = 0;
              }
#line 253
              tmp___98 = tmp___97;
            }
#line 253
            tmp___103 = tmp___98 + tmp___100;
          } else {
#line 253
            if ((unsigned int )dir == 0U) {
#line 253
              tmp___102 = - 1;
            } else {
#line 253
              if ((unsigned int )dir == 4U) {
#line 253
                tmp___101 = 1;
              } else {
#line 253
                tmp___101 = 0;
              }
#line 253
              tmp___102 = tmp___101;
            }
#line 253
            tmp___103 = tmp___102;
          }
#line 253
          if ((unsigned int )dir % 2U != 0U) {
#line 253
            if (((unsigned int )dir + 1U) % 8U == 2U) {
#line 253
              tmp___107 = - 1;
            } else {
#line 253
              if (((unsigned int )dir + 1U) % 8U == 6U) {
#line 253
                tmp___106 = 1;
              } else {
#line 253
                tmp___106 = 0;
              }
#line 253
              tmp___107 = tmp___106;
            }
#line 253
            if ((unsigned int )dir - 1U == 2U) {
#line 253
              tmp___105 = - 1;
            } else {
#line 253
              if ((unsigned int )dir - 1U == 6U) {
#line 253
                tmp___104 = 1;
              } else {
#line 253
                tmp___104 = 0;
              }
#line 253
              tmp___105 = tmp___104;
            }
#line 253
            tmp___110 = tmp___105 + tmp___107;
          } else {
#line 253
            if ((unsigned int )dir == 2U) {
#line 253
              tmp___109 = - 1;
            } else {
#line 253
              if ((unsigned int )dir == 6U) {
#line 253
                tmp___108 = 1;
              } else {
#line 253
                tmp___108 = 0;
              }
#line 253
              tmp___109 = tmp___108;
            }
#line 253
            tmp___110 = tmp___109;
          }
          {
#line 253
          __cil_tmp149 = num_neighbors((unsigned short )(tmp___103 + (int )row), (unsigned short )(tmp___110 + (int )col),
                                       bitmap);
          }
          {
#line 253
          __cil_tmp134 = num_neighbors((unsigned short )row, (unsigned short )col,
                                       bitmap);
          }
          {
#line 253
          __cil_tmp133 = num_neighbors((unsigned short )row, (unsigned short )col,
                                       bitmap);
          }
#line 253
          if ((unsigned int )dir % 2U != 0U) {
#line 253
            if (((unsigned int )dir + 1U) % 8U == 0U) {
#line 253
              tmp___86 = - 1;
            } else {
#line 253
              if (((unsigned int )dir + 1U) % 8U == 4U) {
#line 253
                tmp___85 = 1;
              } else {
#line 253
                tmp___85 = 0;
              }
#line 253
              tmp___86 = tmp___85;
            }
#line 253
            if ((unsigned int )dir - 1U == 0U) {
#line 253
              tmp___84 = - 1;
            } else {
#line 253
              if ((unsigned int )dir - 1U == 4U) {
#line 253
                tmp___83 = 1;
              } else {
#line 253
                tmp___83 = 0;
              }
#line 253
              tmp___84 = tmp___83;
            }
#line 253
            tmp___89 = tmp___84 + tmp___86;
          } else {
#line 253
            if ((unsigned int )dir == 0U) {
#line 253
              tmp___88 = - 1;
            } else {
#line 253
              if ((unsigned int )dir == 4U) {
#line 253
                tmp___87 = 1;
              } else {
#line 253
                tmp___87 = 0;
              }
#line 253
              tmp___88 = tmp___87;
            }
#line 253
            tmp___89 = tmp___88;
          }
#line 253
          if ((unsigned int )dir % 2U != 0U) {
#line 253
            if (((unsigned int )dir + 1U) % 8U == 2U) {
#line 253
              tmp___93 = - 1;
            } else {
#line 253
              if (((unsigned int )dir + 1U) % 8U == 6U) {
#line 253
                tmp___92 = 1;
              } else {
#line 253
                tmp___92 = 0;
              }
#line 253
              tmp___93 = tmp___92;
            }
#line 253
            if ((unsigned int )dir - 1U == 2U) {
#line 253
              tmp___91 = - 1;
            } else {
#line 253
              if ((unsigned int )dir - 1U == 6U) {
#line 253
                tmp___90 = 1;
              } else {
#line 253
                tmp___90 = 0;
              }
#line 253
              tmp___91 = tmp___90;
            }
#line 253
            tmp___96 = tmp___91 + tmp___93;
          } else {
#line 253
            if ((unsigned int )dir == 2U) {
#line 253
              tmp___95 = - 1;
            } else {
#line 253
              if ((unsigned int )dir == 6U) {
#line 253
                tmp___94 = 1;
              } else {
#line 253
                tmp___94 = 0;
              }
#line 253
              tmp___95 = tmp___94;
            }
#line 253
            tmp___96 = tmp___95;
          }
          {
#line 253
          __cil_tmp132 = is_valid_dir((unsigned short )(tmp___89 + (int )row), (unsigned short )(tmp___96 + (int )col),
                                      dir, bitmap, marked);
          }
          {
#line 253
          __cil_tmp117 = is_valid_dir((unsigned short )row, (unsigned short )col,
                                      dir, bitmap, marked);
          }
#line 253
          if (! __cil_tmp117) {
            _L___5: /* CIL Label */ 
            _L___6: /* CIL Label */ 
            _L___7: /* CIL Label */ 
            _L___8: /* CIL Label */ 
#line 258
            dir = (direction_type )3;
#line 259
            if ((unsigned int )dir % 2U != 0U) {
#line 259
              if (((unsigned int )dir + 1U) % 8U == 0U) {
#line 259
                tmp___156 = - 1;
              } else {
#line 259
                if (((unsigned int )dir + 1U) % 8U == 4U) {
#line 259
                  tmp___155 = 1;
                } else {
#line 259
                  tmp___155 = 0;
                }
#line 259
                tmp___156 = tmp___155;
              }
#line 259
              if ((unsigned int )dir - 1U == 0U) {
#line 259
                tmp___154 = - 1;
              } else {
#line 259
                if ((unsigned int )dir - 1U == 4U) {
#line 259
                  tmp___153 = 1;
                } else {
#line 259
                  tmp___153 = 0;
                }
#line 259
                tmp___154 = tmp___153;
              }
#line 259
              tmp___159 = tmp___154 + tmp___156;
            } else {
#line 259
              if ((unsigned int )dir == 0U) {
#line 259
                tmp___158 = - 1;
              } else {
#line 259
                if ((unsigned int )dir == 4U) {
#line 259
                  tmp___157 = 1;
                } else {
#line 259
                  tmp___157 = 0;
                }
#line 259
                tmp___158 = tmp___157;
              }
#line 259
              tmp___159 = tmp___158;
            }
#line 259
            if ((unsigned int )dir % 2U != 0U) {
#line 259
              if (((unsigned int )dir + 1U) % 8U == 2U) {
#line 259
                tmp___163 = - 1;
              } else {
#line 259
                if (((unsigned int )dir + 1U) % 8U == 6U) {
#line 259
                  tmp___162 = 1;
                } else {
#line 259
                  tmp___162 = 0;
                }
#line 259
                tmp___163 = tmp___162;
              }
#line 259
              if ((unsigned int )dir - 1U == 2U) {
#line 259
                tmp___161 = - 1;
              } else {
#line 259
                if ((unsigned int )dir - 1U == 6U) {
#line 259
                  tmp___160 = 1;
                } else {
#line 259
                  tmp___160 = 0;
                }
#line 259
                tmp___161 = tmp___160;
              }
#line 259
              tmp___166 = tmp___161 + tmp___163;
            } else {
#line 259
              if ((unsigned int )dir == 2U) {
#line 259
                tmp___165 = - 1;
              } else {
#line 259
                if ((unsigned int )dir == 6U) {
#line 259
                  tmp___164 = 1;
                } else {
#line 259
                  tmp___164 = 0;
                }
#line 259
                tmp___165 = tmp___164;
              }
#line 259
              tmp___166 = tmp___165;
            }
            {
#line 259
            __cil_tmp214 = is_other_dir_marked((unsigned short )((int )row + tmp___159),
                                               (unsigned short )((int )col + tmp___166),
                                               dir, marked);
            }
            {
#line 259
            __cil_tmp199 = is_other_dir_marked((unsigned short )row, (unsigned short )col,
                                               dir, marked);
            }
#line 259
            if ((unsigned int )dir % 2U != 0U) {
#line 259
              if (((unsigned int )dir + 1U) % 8U == 0U) {
#line 259
                tmp___142 = - 1;
              } else {
#line 259
                if (((unsigned int )dir + 1U) % 8U == 4U) {
#line 259
                  tmp___141 = 1;
                } else {
#line 259
                  tmp___141 = 0;
                }
#line 259
                tmp___142 = tmp___141;
              }
#line 259
              if ((unsigned int )dir - 1U == 0U) {
#line 259
                tmp___140 = - 1;
              } else {
#line 259
                if ((unsigned int )dir - 1U == 4U) {
#line 259
                  tmp___139 = 1;
                } else {
#line 259
                  tmp___139 = 0;
                }
#line 259
                tmp___140 = tmp___139;
              }
#line 259
              tmp___145 = tmp___140 + tmp___142;
            } else {
#line 259
              if ((unsigned int )dir == 0U) {
#line 259
                tmp___144 = - 1;
              } else {
#line 259
                if ((unsigned int )dir == 4U) {
#line 259
                  tmp___143 = 1;
                } else {
#line 259
                  tmp___143 = 0;
                }
#line 259
                tmp___144 = tmp___143;
              }
#line 259
              tmp___145 = tmp___144;
            }
#line 259
            if ((unsigned int )dir % 2U != 0U) {
#line 259
              if (((unsigned int )dir + 1U) % 8U == 2U) {
#line 259
                tmp___149 = - 1;
              } else {
#line 259
                if (((unsigned int )dir + 1U) % 8U == 6U) {
#line 259
                  tmp___148 = 1;
                } else {
#line 259
                  tmp___148 = 0;
                }
#line 259
                tmp___149 = tmp___148;
              }
#line 259
              if ((unsigned int )dir - 1U == 2U) {
#line 259
                tmp___147 = - 1;
              } else {
#line 259
                if ((unsigned int )dir - 1U == 6U) {
#line 259
                  tmp___146 = 1;
                } else {
#line 259
                  tmp___146 = 0;
                }
#line 259
                tmp___147 = tmp___146;
              }
#line 259
              tmp___152 = tmp___147 + tmp___149;
            } else {
#line 259
              if ((unsigned int )dir == 2U) {
#line 259
                tmp___151 = - 1;
              } else {
#line 259
                if ((unsigned int )dir == 6U) {
#line 259
                  tmp___150 = 1;
                } else {
#line 259
                  tmp___150 = 0;
                }
#line 259
                tmp___151 = tmp___150;
              }
#line 259
              tmp___152 = tmp___151;
            }
            {
#line 259
            __cil_tmp198 = num_neighbors((unsigned short )(tmp___145 + (int )row),
                                         (unsigned short )(tmp___152 + (int )col),
                                         bitmap);
            }
            {
#line 259
            __cil_tmp183 = num_neighbors((unsigned short )row, (unsigned short )col,
                                         bitmap);
            }
            {
#line 259
            __cil_tmp182 = num_neighbors((unsigned short )row, (unsigned short )col,
                                         bitmap);
            }
#line 259
            if ((unsigned int )dir % 2U != 0U) {
#line 259
              if (((unsigned int )dir + 1U) % 8U == 0U) {
#line 259
                tmp___128 = - 1;
              } else {
#line 259
                if (((unsigned int )dir + 1U) % 8U == 4U) {
#line 259
                  tmp___127 = 1;
                } else {
#line 259
                  tmp___127 = 0;
                }
#line 259
                tmp___128 = tmp___127;
              }
#line 259
              if ((unsigned int )dir - 1U == 0U) {
#line 259
                tmp___126 = - 1;
              } else {
#line 259
                if ((unsigned int )dir - 1U == 4U) {
#line 259
                  tmp___125 = 1;
                } else {
#line 259
                  tmp___125 = 0;
                }
#line 259
                tmp___126 = tmp___125;
              }
#line 259
              tmp___131 = tmp___126 + tmp___128;
            } else {
#line 259
              if ((unsigned int )dir == 0U) {
#line 259
                tmp___130 = - 1;
              } else {
#line 259
                if ((unsigned int )dir == 4U) {
#line 259
                  tmp___129 = 1;
                } else {
#line 259
                  tmp___129 = 0;
                }
#line 259
                tmp___130 = tmp___129;
              }
#line 259
              tmp___131 = tmp___130;
            }
#line 259
            if ((unsigned int )dir % 2U != 0U) {
#line 259
              if (((unsigned int )dir + 1U) % 8U == 2U) {
#line 259
                tmp___135 = - 1;
              } else {
#line 259
                if (((unsigned int )dir + 1U) % 8U == 6U) {
#line 259
                  tmp___134 = 1;
                } else {
#line 259
                  tmp___134 = 0;
                }
#line 259
                tmp___135 = tmp___134;
              }
#line 259
              if ((unsigned int )dir - 1U == 2U) {
#line 259
                tmp___133 = - 1;
              } else {
#line 259
                if ((unsigned int )dir - 1U == 6U) {
#line 259
                  tmp___132 = 1;
                } else {
#line 259
                  tmp___132 = 0;
                }
#line 259
                tmp___133 = tmp___132;
              }
#line 259
              tmp___138 = tmp___133 + tmp___135;
            } else {
#line 259
              if ((unsigned int )dir == 2U) {
#line 259
                tmp___137 = - 1;
              } else {
#line 259
                if ((unsigned int )dir == 6U) {
#line 259
                  tmp___136 = 1;
                } else {
#line 259
                  tmp___136 = 0;
                }
#line 259
                tmp___137 = tmp___136;
              }
#line 259
              tmp___138 = tmp___137;
            }
            {
#line 259
            __cil_tmp181 = is_valid_dir((unsigned short )(tmp___131 + (int )row),
                                        (unsigned short )(tmp___138 + (int )col),
                                        dir, bitmap, marked);
            }
            {
#line 259
            __cil_tmp166 = is_valid_dir((unsigned short )row, (unsigned short )col,
                                        dir, bitmap, marked);
            }
#line 259
            if (! __cil_tmp166) {
#line 264
              col ++;
#line 265
              goto while_continue___0;
            } else
#line 259
            if (! __cil_tmp181) {
#line 259
              if (__cil_tmp182 > 2U) {
#line 264
                col ++;
#line 265
                goto while_continue___0;
              } else {
#line 259
                goto _L;
              }
            } else
            _L: /* CIL Label */ 
#line 259
            if (__cil_tmp183 > 4U) {
#line 264
              col ++;
#line 265
              goto while_continue___0;
            } else
#line 259
            if (__cil_tmp198 > 4U) {
#line 264
              col ++;
#line 265
              goto while_continue___0;
            } else
#line 259
            if (__cil_tmp199) {
#line 259
              if (__cil_tmp214) {
#line 264
                col ++;
#line 265
                goto while_continue___0;
              }
            }
          } else
#line 253
          if (! __cil_tmp132) {
#line 253
            if (__cil_tmp133 > 2U) {
#line 253
              goto _L___5;
            } else {
#line 253
              goto _L___9;
            }
          } else
          _L___9: /* CIL Label */ 
#line 253
          if (__cil_tmp134 > 4U) {
#line 253
            goto _L___5;
          } else
#line 253
          if (__cil_tmp149 > 4U) {
#line 253
            goto _L___5;
          } else
#line 253
          if (__cil_tmp150) {
#line 253
            if (__cil_tmp165) {
#line 253
              goto _L___5;
            }
          }
        } else
#line 247
        if (! __cil_tmp83) {
#line 247
          if (__cil_tmp84 > 2U) {
#line 247
            goto _L___10;
          } else {
#line 247
            goto _L___14;
          }
        } else
        _L___14: /* CIL Label */ 
#line 247
        if (__cil_tmp85 > 4U) {
#line 247
          goto _L___10;
        } else
#line 247
        if (__cil_tmp100 > 4U) {
#line 247
          goto _L___10;
        } else
#line 247
        if (__cil_tmp101) {
#line 247
          if (__cil_tmp116) {
#line 247
            goto _L___10;
          }
        }
      } else
#line 241
      if (! __cil_tmp34) {
#line 241
        if (__cil_tmp35 > 2U) {
#line 241
          goto _L___15;
        } else {
#line 241
          goto _L___19;
        }
      } else
      _L___19: /* CIL Label */ 
#line 241
      if (__cil_tmp36 > 4U) {
#line 241
        goto _L___15;
      } else
#line 241
      if (__cil_tmp51 > 4U) {
#line 241
        goto _L___15;
      } else
#line 241
      if (__cil_tmp52) {
#line 241
        if (__cil_tmp67) {
#line 241
          goto _L___15;
        }
      }
      {
#line 271
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 271
        if (logging) {
#line 271
          if (clockwise) {
#line 271
            tmp___167 = "\323\001 ";
          } else {
#line 271
            tmp___167 = "counter";
          }
          {
#line 271
          fprintf(stdout, "#%u: (%sclockwise) ", outline_list.length, tmp___167);
          }
        }
#line 271
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 273
      outline = find_one_centerline(bitmap, dir, (unsigned short )row, (unsigned short )col,
                                    marked);
      }
#line 279
      if (outline.open) {
#line 281
        okay = 0;
#line 283
        if ((unsigned int )dir == 6U) {
          {
#line 284
          dir = (direction_type )4;
#line 285
          okay = is_valid_dir((unsigned short )row, (unsigned short )col, dir, bitmap,
                              marked);
          }
#line 285
          if (! okay) {
            {
#line 286
            dir = (direction_type )3;
#line 287
            okay = is_valid_dir((unsigned short )row, (unsigned short )col, dir, bitmap,
                                marked);
            }
#line 287
            if (! okay) {
              {
#line 288
              dir = (direction_type )5;
#line 289
              okay = is_valid_dir((unsigned short )row, (unsigned short )col, dir,
                                  bitmap, marked);
              }
            }
          }
        } else
#line 292
        if ((unsigned int )dir == 5U) {
          {
#line 293
          dir = (direction_type )3;
#line 294
          okay = is_valid_dir((unsigned short )row, (unsigned short )col, dir, bitmap,
                              marked);
          }
#line 294
          if (! okay) {
            {
#line 295
            dir = (direction_type )6;
#line 296
            okay = is_valid_dir((unsigned short )row, (unsigned short )col, dir, bitmap,
                                marked);
            }
#line 296
            if (! okay) {
              {
#line 297
              dir = (direction_type )4;
#line 298
              okay = is_valid_dir((unsigned short )row, (unsigned short )col, dir,
                                  bitmap, marked);
              }
            }
          }
        } else
#line 301
        if ((unsigned int )dir == 4U) {
          {
#line 302
          dir = (direction_type )6;
#line 303
          okay = is_valid_dir((unsigned short )row, (unsigned short )col, dir, bitmap,
                              marked);
          }
#line 303
          if (! okay) {
            {
#line 304
            dir = (direction_type )5;
#line 305
            okay = is_valid_dir((unsigned short )row, (unsigned short )col, dir, bitmap,
                                marked);
            }
#line 305
            if (! okay) {
              {
#line 306
              dir = (direction_type )3;
#line 307
              okay = is_valid_dir((unsigned short )row, (unsigned short )col, dir,
                                  bitmap, marked);
              }
            }
          }
        } else
#line 310
        if ((unsigned int )dir == 3U) {
          {
#line 311
          dir = (direction_type )5;
#line 312
          okay = is_valid_dir((unsigned short )row, (unsigned short )col, dir, bitmap,
                              marked);
          }
#line 312
          if (! okay) {
            {
#line 313
            dir = (direction_type )6;
#line 314
            okay = is_valid_dir((unsigned short )row, (unsigned short )col, dir, bitmap,
                                marked);
            }
#line 314
            if (! okay) {
              {
#line 315
              dir = (direction_type )4;
#line 316
              okay = is_valid_dir((unsigned short )row, (unsigned short )col, dir,
                                  bitmap, marked);
              }
            }
          }
        }
#line 320
        if (okay) {
          {
#line 321
          partial_outline = find_one_centerline(bitmap, dir, (unsigned short )row,
                                                (unsigned short )col, marked);
#line 322
          concat_pixel_outline(& outline, & partial_outline);
          }
#line 323
          if (partial_outline.data) {
            {
#line 324
            free(partial_outline.data);
            }
          }
        } else {
#line 326
          col ++;
        }
      }
#line 333
      outline.clockwise = clockwise;
#line 334
      if (outline.length > 1U) {
        {
#line 335
        append_pixel_outline(& outline_list, outline);
        }
      }
      {
#line 336
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 336
        if (logging) {
#line 336
          if (outline.open) {
#line 336
            tmp___168 = " open";
          } else {
#line 336
            tmp___168 = " closed";
          }
          {
#line 336
          fprintf(stdout, "(%s)", tmp___168);
          }
        }
#line 336
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 337
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 337
        if (logging) {
          {
#line 337
          fprintf(stdout, " [%u].\n", outline.length);
          }
        }
#line 337
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 338
      if (outline.length == 1U) {
        {
#line 339
        free_pixel_outline(& outline);
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 227
    row ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 342
  __cil_tmp236 = (*test_cancel)(testcancel_data);
  }
#line 342
  if (test_cancel) {
#line 342
    if (__cil_tmp236) {
#line 343
      if (outline_list.length != 0U) {
        {
#line 344
        free_pixel_outline_list(& outline_list);
        }
      }
#line 345
      goto cleanup;
    }
  }
  cleanup: 
  {
#line 348
  at_bitmap_free(marked);
  }
#line 349
  return (outline_list);
}
}
#line 352 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/pxl-outline.c"
static pixel_outline_type find_one_centerline(at_bitmap *bitmap , direction_type search_dir ,
                                              unsigned short original_row , unsigned short original_col ,
                                              at_bitmap *marked ) 
{ 
  pixel_outline_type outline ;
  pixel_outline_type __cil_tmp7 ;
  direction_type original_dir ;
  unsigned short row ;
  unsigned short col ;
  unsigned short prev_row ;
  unsigned short prev_col ;
  at_coord pos ;
  gboolean __cil_tmp14 ;

  {
  {
#line 354
  __cil_tmp7 = new_pixel_outline();
#line 354
  outline = __cil_tmp7;
#line 355
  original_dir = search_dir;
#line 356
  row = original_row;
  }
  {
#line 356
  col = original_col;
#line 360
  outline.open = 0;
#line 361
  at_bitmap_get_color(bitmap, (unsigned int )row, (unsigned int )col, & outline.color);
#line 366
  pos.x = col;
#line 367
  pos.y = (gushort )(((int )bitmap->height - (int )row) - 1);
  }
  {
#line 368
  while (1) {
    while_continue: /* CIL Label */ ;
#line 368
    if (logging) {
      {
#line 368
      fprintf(stdout, " (%d,%d)\230\001", (int )pos.x, (int )pos.y);
      }
    }
#line 368
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 369
  append_outline_pixel(& outline, pos);
  }
  {
#line 371
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 371
    if (! 1) {
#line 371
      goto while_break___0;
    }
    {
#line 372
    prev_row = row;
#line 373
    prev_col = col;
#line 377
    __cil_tmp14 = next_unmarked_pixel(& row, & col, & search_dir, bitmap, marked);
    }
#line 377
    if (! __cil_tmp14) {
#line 378
      outline.open = ! 0;
#line 379
      goto while_break___0;
    }
#line 384
    if (! ((int )prev_row == (int )original_row && (int )prev_col == (int )original_col)) {
      {
#line 385
      mark_dir(prev_row, prev_col, search_dir, marked);
      }
    }
    {
#line 386
    mark_dir(row, col, (direction_type )(((unsigned int )search_dir + 4U) % 8U), marked);
    }
#line 389
    if ((int )row == (int )original_row) {
#line 389
      if ((int )col == (int )original_col) {
#line 390
        goto while_break___0;
      }
    }
#line 393
    pos.x = col;
#line 394
    pos.y = (gushort )(((int )bitmap->height - (int )row) - 1);
    {
#line 395
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 395
      if (logging) {
        {
#line 395
        fprintf(stdout, " (%d,%d)\230\001", (int )pos.x, (int )pos.y);
        }
      }
#line 395
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 396
    append_outline_pixel(& outline, pos);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 398
  mark_dir(original_row, original_col, original_dir, marked);
  }
#line 399
  return (outline);
}
}
#line 404 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/pxl-outline.c"
static void append_pixel_outline(pixel_outline_list_type *outline_list , pixel_outline_type outline ) 
{ 
  unsigned int __cil_tmp3 ;
  gpointer new_mem ;
  void *__cil_tmp5 ;
  int tmp ;
  void *__cil_tmp7 ;
  int tmp___0 ;

  {
#line 406
  (outline_list->length) ++;
  {
#line 407
  while (1) {
    while_continue: /* CIL Label */ ;
#line 407
    if (outline_list->data == (void *)0) {
      {
#line 407
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 407
        __cil_tmp5 = malloc((unsigned long )outline_list->length * sizeof(pixel_outline_type ));
#line 407
        new_mem = (gpointer )__cil_tmp5;
        }
#line 407
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 407
      __cil_tmp7 = realloc(outline_list->data, (unsigned long )outline_list->length * sizeof(pixel_outline_type ));
#line 407
      new_mem = (gpointer )__cil_tmp7;
      }
    }
#line 407
    outline_list->data = new_mem;
#line 407
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 408
  *(outline_list->data + (outline_list->length - 1U)) = outline;
  return;
}
}
#line 413 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/pxl-outline.c"
void free_pixel_outline_list(pixel_outline_list_type *outline_list ) 
{ 
  unsigned int this_outline ;
  pixel_outline_type o ;
  unsigned int __cil_tmp4 ;

  {
#line 417
  this_outline = (unsigned int )0;
  {
#line 417
  while (1) {
    while_continue: /* CIL Label */ ;
#line 417
    if (! (this_outline < outline_list->length)) {
#line 417
      goto while_break;
    }
    {
#line 418
    o = *(outline_list->data + this_outline);
#line 419
    free_pixel_outline(& o);
    }
#line 417
    this_outline ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 421
  free(outline_list->data);
#line 422
  outline_list->data = (pixel_outline_type *)((void *)0);
#line 423
  outline_list->length = (unsigned int )0;
  }
  return;
}
}
#line 428 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/pxl-outline.c"
static pixel_outline_type new_pixel_outline(void) 
{ 
  pixel_outline_type pixel_outline ;

  {
#line 432
  pixel_outline.length = (unsigned int )0;
#line 433
  pixel_outline.data = (at_coord *)((void *)0);
#line 434
  pixel_outline.open = 0;
#line 436
  return (pixel_outline);
}
}
#line 439 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/pxl-outline.c"
static void free_pixel_outline(pixel_outline_type *outline ) 
{ 


  {
  {
#line 441
  free(outline->data);
#line 442
  outline->data = (at_coord *)((void *)0);
#line 443
  outline->length = (unsigned int )0;
  }
  return;
}
}
#line 449 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/pxl-outline.c"
static void concat_pixel_outline(pixel_outline_type *o1 , pixel_outline_type *o2 ) 
{ 
  int src ;
  int dst ;
  unsigned int o1_length ;
  unsigned int o2_length ;
  gpointer new_mem ;
  void *__cil_tmp8 ;
  int tmp ;
  void *__cil_tmp10 ;
  int tmp___0 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;

  {
#line 453
  if (! o1) {
#line 454
    return;
  } else
#line 453
  if (! o2) {
#line 454
    return;
  } else
#line 453
  if (o2->length <= 1U) {
#line 454
    return;
  }
#line 456
  o1_length = o1->length;
#line 457
  o2_length = o2->length;
#line 458
  o1->length += o2_length - 1U;
  {
#line 461
  while (1) {
    while_continue: /* CIL Label */ ;
#line 461
    if (o1->data == (void *)0) {
      {
#line 461
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 461
        __cil_tmp8 = malloc((unsigned long )o1->length * sizeof(at_coord ));
#line 461
        new_mem = (gpointer )__cil_tmp8;
        }
#line 461
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 461
      __cil_tmp10 = realloc(o1->data, (unsigned long )o1->length * sizeof(at_coord ));
#line 461
      new_mem = (gpointer )__cil_tmp10;
      }
    }
#line 461
    o1->data = new_mem;
#line 461
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 464
  dst = (int )(o1->length - 1U);
#line 464
  src = (int )(o1_length - 1U);
  {
#line 464
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 464
    if (! (src >= 0)) {
#line 464
      goto while_break___1;
    }
#line 465
    *(o1->data + dst) = *(o1->data + src);
#line 464
    __cil_tmp13 = dst;
#line 464
    dst --;
#line 464
    __cil_tmp12 = src;
#line 464
    src --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 467
  dst = 0;
#line 467
  src = (int )(o2_length - 1U);
  {
#line 467
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 467
    if (! (src > 0)) {
#line 467
      goto while_break___2;
    }
#line 468
    *(o1->data + dst) = *(o2->data + src);
#line 467
    __cil_tmp15 = dst;
#line 467
    dst ++;
#line 467
    __cil_tmp14 = src;
#line 467
    src --;
  }
  while_break___2: /* CIL Label */ ;
  }
  return;
}
}
#line 473 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/pxl-outline.c"
static void append_outline_pixel(pixel_outline_type *o , at_coord c ) 
{ 
  unsigned int __cil_tmp3 ;
  gpointer new_mem ;
  void *__cil_tmp5 ;
  int tmp ;
  void *__cil_tmp7 ;
  int tmp___0 ;

  {
#line 475
  (o->length) ++;
  {
#line 476
  while (1) {
    while_continue: /* CIL Label */ ;
#line 476
    if (o->data == (void *)0) {
      {
#line 476
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 476
        __cil_tmp5 = malloc((unsigned long )o->length * sizeof(at_coord ));
#line 476
        new_mem = (gpointer )__cil_tmp5;
        }
#line 476
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 476
      __cil_tmp7 = realloc(o->data, (unsigned long )o->length * sizeof(at_coord ));
#line 476
      new_mem = (gpointer )__cil_tmp7;
      }
    }
#line 476
    o->data = new_mem;
#line 476
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 477
  *(o->data + (o->length - 1U)) = c;
  return;
}
}
#line 482 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/pxl-outline.c"
static gboolean is_unmarked_outline_edge(unsigned short row , unsigned short col ,
                                         edge_type edge , at_bitmap *bitmap , at_bitmap *marked ,
                                         at_color color , at_exception_type *exp___0 ) 
{ 
  gboolean __cil_tmp8 ;
  gboolean __cil_tmp9 ;

  {
  {
#line 484
  __cil_tmp9 = is_outline_edge(edge, bitmap, row, col, color, exp___0);
  }
  {
#line 484
  __cil_tmp8 = is_marked_edge(edge, row, col, marked);
  }
#line 484
  return ((gboolean )(! __cil_tmp8 && __cil_tmp9));
}
}
#line 491 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/pxl-outline.c"
static gboolean is_outline_edge(edge_type edge , at_bitmap *bitmap , unsigned short row ,
                                unsigned short col , at_color color , at_exception_type *exp___0 ) 
{ 
  gboolean __cil_tmp7 ;
  gboolean __cil_tmp8 ;
  gboolean __cil_tmp9 ;
  gboolean __cil_tmp10 ;
  gboolean __cil_tmp11 ;

  {
  {
#line 494
  __cil_tmp7 = at_bitmap_equal_color(bitmap, (unsigned int )row, (unsigned int )col,
                                     & color);
  }
#line 494
  if (! __cil_tmp7) {
#line 495
    return (0);
  }
  {
#line 498
  if ((unsigned int )edge == (unsigned int )2) {
#line 498
    goto case_2;
  }
#line 500
  if ((unsigned int )edge == (unsigned int )1) {
#line 500
    goto case_1;
  }
#line 503
  if ((unsigned int )edge == (unsigned int )0) {
#line 503
    goto case_0;
  }
#line 506
  if ((unsigned int )edge == (unsigned int )3) {
#line 506
    goto case_3;
  }
#line 509
  if ((unsigned int )edge == (unsigned int )4) {
#line 509
    goto case_4;
  }
#line 511
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 499
  __cil_tmp8 = at_bitmap_equal_color(bitmap, (unsigned int )row, (unsigned int )((int )col - 1),
                                     & color);
  }
#line 499
  return ((gboolean )((int )col == 0 || ! __cil_tmp8));
  case_1: /* CIL Label */ 
  {
#line 501
  __cil_tmp9 = at_bitmap_equal_color(bitmap, (unsigned int )((int )row - 1), (unsigned int )col,
                                     & color);
  }
#line 501
  return ((gboolean )((int )row == 0 || ! __cil_tmp9));
  case_0: /* CIL Label */ 
  {
#line 504
  __cil_tmp10 = at_bitmap_equal_color(bitmap, (unsigned int )row, (unsigned int )((int )col + 1),
                                      & color);
  }
#line 504
  return ((gboolean )((int )col == (int )bitmap->width - 1 || ! __cil_tmp10));
  case_3: /* CIL Label */ 
  {
#line 507
  __cil_tmp11 = at_bitmap_equal_color(bitmap, (unsigned int )((int )row + 1), (unsigned int )col,
                                      & color);
  }
#line 507
  return ((gboolean )((int )row == (int )bitmap->height - 1 || ! __cil_tmp11));
  case_4: /* CIL Label */ 
  {
#line 510
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 510
    g_assertion_message_expr((char const   *)((gchar *)0), "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/pxl-outline.c\204\227\a\027V",
                             510, (char const   *)"is_outline_edge", (char const   *)((void *)0));
    }
#line 510
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  switch_default: /* CIL Label */ 
  {
#line 512
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 512
    g_assertion_message_expr((char const   *)((gchar *)0), "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/pxl-outline.c",
                             512, (char const   *)"is_outline_edge", (char const   *)((void *)0));
    }
#line 512
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  switch_break: /* CIL Label */ ;
  }
#line 514
  return (0);
}
}
#line 521 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/pxl-outline.c"
static void mark_edge(edge_type edge , unsigned short row , unsigned short col , at_bitmap *marked ) 
{ 


  {
#line 523
  *((marked->bitmap + ((unsigned int )row * marked->np) * (unsigned int )marked->width) + (unsigned int )col * marked->np) |= 1 << (unsigned int )edge;
  return;
}
}
#line 528 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/pxl-outline.c"
static void mark_dir(unsigned short row , unsigned short col , direction_type dir ,
                     at_bitmap *marked ) 
{ 


  {
#line 530
  *((marked->bitmap + ((unsigned int )row * marked->np) * (unsigned int )marked->width) + (unsigned int )col * marked->np) |= 1 << (unsigned int )dir;
  return;
}
}
#line 535 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/pxl-outline.c"
static gboolean is_marked_dir(unsigned short row , unsigned short col , direction_type dir ,
                              at_bitmap *marked ) 
{ 


  {
#line 537
  return ((gboolean )(((int )*((marked->bitmap + ((unsigned int )row * marked->np) * (unsigned int )marked->width) + (unsigned int )col * marked->np) & (1 << (unsigned int )dir)) != 0));
}
}
#line 540 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/pxl-outline.c"
static gboolean is_other_dir_marked(unsigned short row , unsigned short col , direction_type dir ,
                                    at_bitmap *marked ) 
{ 


  {
#line 542
  return ((gboolean )(((int )*((marked->bitmap + ((unsigned int )row * marked->np) * (unsigned int )marked->width) + (unsigned int )col * marked->np) & ((255 - (1 << (unsigned int )dir)) - (1 << ((unsigned int )dir + 4U) % 8U))) != 0));
}
}
#line 545 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/pxl-outline.c"
static gboolean next_unmarked_pixel(unsigned short *row , unsigned short *col , direction_type *dir ,
                                    at_bitmap *bitmap , at_bitmap *marked ) 
{ 
  unsigned short orig_row ;
  unsigned short orig_col ;
  direction_type orig_dir ;
  direction_type test_dir ;
  gboolean __cil_tmp10 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  gboolean __cil_tmp25 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  gboolean __cil_tmp40 ;

  {
#line 547
  orig_row = *row;
#line 547
  orig_col = *col;
#line 548
  orig_dir = *dir;
#line 548
  test_dir = *dir;
  {
#line 550
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 551
    __cil_tmp10 = is_valid_dir(orig_row, orig_col, test_dir, bitmap, marked);
    }
#line 551
    if (__cil_tmp10) {
#line 552
      if ((unsigned int )test_dir % 2U != 0U) {
#line 552
        if (((unsigned int )test_dir + 1U) % 8U == 0U) {
#line 552
          tmp___2 = - 1;
        } else {
#line 552
          if (((unsigned int )test_dir + 1U) % 8U == 4U) {
#line 552
            tmp___1 = 1;
          } else {
#line 552
            tmp___1 = 0;
          }
#line 552
          tmp___2 = tmp___1;
        }
#line 552
        if ((unsigned int )test_dir - 1U == 0U) {
#line 552
          tmp___0 = - 1;
        } else {
#line 552
          if ((unsigned int )test_dir - 1U == 4U) {
#line 552
            tmp = 1;
          } else {
#line 552
            tmp = 0;
          }
#line 552
          tmp___0 = tmp;
        }
#line 552
        tmp___5 = tmp___0 + tmp___2;
      } else {
#line 552
        if ((unsigned int )test_dir == 0U) {
#line 552
          tmp___4 = - 1;
        } else {
#line 552
          if ((unsigned int )test_dir == 4U) {
#line 552
            tmp___3 = 1;
          } else {
#line 552
            tmp___3 = 0;
          }
#line 552
          tmp___4 = tmp___3;
        }
#line 552
        tmp___5 = tmp___4;
      }
#line 552
      *row = (unsigned short )((int )orig_row + tmp___5);
#line 553
      if ((unsigned int )test_dir % 2U != 0U) {
#line 553
        if (((unsigned int )test_dir + 1U) % 8U == 2U) {
#line 553
          tmp___9 = - 1;
        } else {
#line 553
          if (((unsigned int )test_dir + 1U) % 8U == 6U) {
#line 553
            tmp___8 = 1;
          } else {
#line 553
            tmp___8 = 0;
          }
#line 553
          tmp___9 = tmp___8;
        }
#line 553
        if ((unsigned int )test_dir - 1U == 2U) {
#line 553
          tmp___7 = - 1;
        } else {
#line 553
          if ((unsigned int )test_dir - 1U == 6U) {
#line 553
            tmp___6 = 1;
          } else {
#line 553
            tmp___6 = 0;
          }
#line 553
          tmp___7 = tmp___6;
        }
#line 553
        tmp___12 = tmp___7 + tmp___9;
      } else {
#line 553
        if ((unsigned int )test_dir == 2U) {
#line 553
          tmp___11 = - 1;
        } else {
#line 553
          if ((unsigned int )test_dir == 6U) {
#line 553
            tmp___10 = 1;
          } else {
#line 553
            tmp___10 = 0;
          }
#line 553
          tmp___11 = tmp___10;
        }
#line 553
        tmp___12 = tmp___11;
      }
#line 553
      *col = (unsigned short )((int )orig_col + tmp___12);
#line 554
      *dir = test_dir;
#line 555
      goto while_break;
    }
#line 558
    if ((unsigned int )orig_dir == (unsigned int )test_dir) {
#line 559
      test_dir = (direction_type )(((unsigned int )orig_dir + 2U) % 8U);
    } else
#line 560
    if (((unsigned int )orig_dir + 2U) % 8U == (unsigned int )test_dir) {
#line 561
      test_dir = (direction_type )(((unsigned int )orig_dir + 6U) % 8U);
    } else
#line 562
    if (((unsigned int )orig_dir + 6U) % 8U == (unsigned int )test_dir) {
#line 563
      test_dir = (direction_type )(((unsigned int )orig_dir + 1U) % 8U);
    } else
#line 564
    if (((unsigned int )orig_dir + 1U) % 8U == (unsigned int )test_dir) {
#line 565
      test_dir = (direction_type )(((unsigned int )orig_dir + 7U) % 8U);
    } else
#line 566
    if (((unsigned int )orig_dir + 7U) % 8U == (unsigned int )test_dir) {
#line 567
      test_dir = (direction_type )(((unsigned int )orig_dir + 3U) % 8U);
    } else
#line 568
    if (((unsigned int )orig_dir + 3U) % 8U == (unsigned int )test_dir) {
#line 569
      test_dir = (direction_type )(((unsigned int )orig_dir + 5U) % 8U);
    } else
#line 570
    if (((unsigned int )orig_dir + 5U) % 8U == (unsigned int )test_dir) {
#line 571
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 574
  if ((unsigned int )test_dir % 2U != 0U) {
#line 574
    if (((unsigned int )test_dir + 1U) % 8U == 0U) {
#line 574
      tmp___16 = - 1;
    } else {
#line 574
      if (((unsigned int )test_dir + 1U) % 8U == 4U) {
#line 574
        tmp___15 = 1;
      } else {
#line 574
        tmp___15 = 0;
      }
#line 574
      tmp___16 = tmp___15;
    }
#line 574
    if ((unsigned int )test_dir - 1U == 0U) {
#line 574
      tmp___14 = - 1;
    } else {
#line 574
      if ((unsigned int )test_dir - 1U == 4U) {
#line 574
        tmp___13 = 1;
      } else {
#line 574
        tmp___13 = 0;
      }
#line 574
      tmp___14 = tmp___13;
    }
#line 574
    tmp___19 = tmp___14 + tmp___16;
  } else {
#line 574
    if ((unsigned int )test_dir == 0U) {
#line 574
      tmp___18 = - 1;
    } else {
#line 574
      if ((unsigned int )test_dir == 4U) {
#line 574
        tmp___17 = 1;
      } else {
#line 574
        tmp___17 = 0;
      }
#line 574
      tmp___18 = tmp___17;
    }
#line 574
    tmp___19 = tmp___18;
  }
#line 574
  if ((unsigned int )test_dir % 2U != 0U) {
#line 574
    if (((unsigned int )test_dir + 1U) % 8U == 2U) {
#line 574
      tmp___23 = - 1;
    } else {
#line 574
      if (((unsigned int )test_dir + 1U) % 8U == 6U) {
#line 574
        tmp___22 = 1;
      } else {
#line 574
        tmp___22 = 0;
      }
#line 574
      tmp___23 = tmp___22;
    }
#line 574
    if ((unsigned int )test_dir - 1U == 2U) {
#line 574
      tmp___21 = - 1;
    } else {
#line 574
      if ((unsigned int )test_dir - 1U == 6U) {
#line 574
        tmp___20 = 1;
      } else {
#line 574
        tmp___20 = 0;
      }
#line 574
      tmp___21 = tmp___20;
    }
#line 574
    tmp___26 = tmp___21 + tmp___23;
  } else {
#line 574
    if ((unsigned int )test_dir == 2U) {
#line 574
      tmp___25 = - 1;
    } else {
#line 574
      if ((unsigned int )test_dir == 6U) {
#line 574
        tmp___24 = 1;
      } else {
#line 574
        tmp___24 = 0;
      }
#line 574
      tmp___25 = tmp___24;
    }
#line 574
    tmp___26 = tmp___25;
  }
  {
#line 574
  __cil_tmp40 = is_other_dir_marked((unsigned short )((int )orig_row + tmp___19),
                                    (unsigned short )((int )orig_col + tmp___26),
                                    test_dir, marked);
  }
  {
#line 574
  __cil_tmp25 = is_other_dir_marked(orig_row, orig_col, test_dir, marked);
  }
#line 574
  if ((int )*row != (int )orig_row) {
    _L: /* CIL Label */ 
#line 574
    if (! (__cil_tmp25 && __cil_tmp40)) {
#line 576
      return (! 0);
    } else {
#line 578
      return (0);
    }
  } else
#line 574
  if ((int )*col != (int )orig_col) {
#line 574
    goto _L;
  } else {
#line 578
    return (0);
  }
}
}
#line 583 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/pxl-outline.c"
static unsigned int num_neighbors(unsigned short row , unsigned short col , at_bitmap *bitmap ) 
{ 
  unsigned int dir ;
  unsigned int count ;
  at_color color ;
  int delta_r ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int delta_c ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  unsigned int test_row ;
  unsigned int test_col ;
  gboolean __cil_tmp25 ;
  unsigned int __cil_tmp26 ;

  {
  {
#line 585
  count = (unsigned int )0;
#line 588
  at_bitmap_get_color(bitmap, (unsigned int )row, (unsigned int )col, & color);
#line 589
  dir = (unsigned int )0;
  }
  {
#line 589
  while (1) {
    while_continue: /* CIL Label */ ;
#line 589
    if (! (dir <= 7U)) {
#line 589
      goto while_break;
    }
#line 590
    if (dir % 2U != 0U) {
#line 590
      if ((dir + 1U) % 8U == 0U) {
#line 590
        tmp___2 = - 1;
      } else {
#line 590
        if ((dir + 1U) % 8U == 4U) {
#line 590
          tmp___1 = 1;
        } else {
#line 590
          tmp___1 = 0;
        }
#line 590
        tmp___2 = tmp___1;
      }
#line 590
      if (dir - 1U == 0U) {
#line 590
        tmp___0 = - 1;
      } else {
#line 590
        if (dir - 1U == 4U) {
#line 590
          tmp = 1;
        } else {
#line 590
          tmp = 0;
        }
#line 590
        tmp___0 = tmp;
      }
#line 590
      tmp___5 = tmp___0 + tmp___2;
    } else {
#line 590
      if (dir == 0U) {
#line 590
        tmp___4 = - 1;
      } else {
#line 590
        if (dir == 4U) {
#line 590
          tmp___3 = 1;
        } else {
#line 590
          tmp___3 = 0;
        }
#line 590
        tmp___4 = tmp___3;
      }
#line 590
      tmp___5 = tmp___4;
    }
#line 590
    delta_r = tmp___5;
#line 591
    if (dir % 2U != 0U) {
#line 591
      if ((dir + 1U) % 8U == 2U) {
#line 591
        tmp___9 = - 1;
      } else {
#line 591
        if ((dir + 1U) % 8U == 6U) {
#line 591
          tmp___8 = 1;
        } else {
#line 591
          tmp___8 = 0;
        }
#line 591
        tmp___9 = tmp___8;
      }
#line 591
      if (dir - 1U == 2U) {
#line 591
        tmp___7 = - 1;
      } else {
#line 591
        if (dir - 1U == 6U) {
#line 591
          tmp___6 = 1;
        } else {
#line 591
          tmp___6 = 0;
        }
#line 591
        tmp___7 = tmp___6;
      }
#line 591
      tmp___12 = tmp___7 + tmp___9;
    } else {
#line 591
      if (dir == 2U) {
#line 591
        tmp___11 = - 1;
      } else {
#line 591
        if (dir == 6U) {
#line 591
          tmp___10 = 1;
        } else {
#line 591
          tmp___10 = 0;
        }
#line 591
        tmp___11 = tmp___10;
      }
#line 591
      tmp___12 = tmp___11;
    }
    {
#line 591
    delta_c = tmp___12;
#line 592
    test_row = (unsigned int )((int )row + delta_r);
#line 593
    test_col = (unsigned int )((int )col + delta_c);
#line 594
    __cil_tmp25 = at_bitmap_equal_color(bitmap, test_row, test_col, & color);
    }
#line 594
    if (test_row < (unsigned int )bitmap->height) {
#line 594
      if (test_col < (unsigned int )bitmap->width) {
#line 594
        if (__cil_tmp25) {
#line 596
          count ++;
        }
      }
    }
#line 589
    dir ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 598
  return (count);
}
}
#line 603 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/pxl-outline.c"
static gboolean is_marked_edge(edge_type edge , unsigned short row , unsigned short col ,
                               at_bitmap *marked ) 
{ 
  int tmp ;

  {
#line 605
  if ((unsigned int )edge == 4U) {
#line 605
    tmp = 0;
  } else {
#line 605
    tmp = ((int )*((marked->bitmap + ((unsigned int )row * marked->np) * (unsigned int )marked->width) + (unsigned int )col * marked->np) & (1 << (unsigned int )edge)) != 0;
  }
#line 605
  return ((gboolean )tmp);
}
}
#line 608 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/pxl-outline.c"
static at_coord next_point(at_bitmap *bitmap , edge_type *edge , unsigned short *row ,
                           unsigned short *col , at_color color , gboolean clockwise ,
                           at_bitmap *marked , at_exception_type *exp___0 ) 
{ 
  at_coord pos ;
  gboolean __cil_tmp10 ;
  gboolean __cil_tmp11 ;
  unsigned short __cil_tmp12 ;
  gboolean __cil_tmp13 ;
  gboolean __cil_tmp14 ;
  gboolean __cil_tmp15 ;
  gboolean __cil_tmp16 ;
  gboolean __cil_tmp17 ;
  gboolean __cil_tmp18 ;
  gboolean __cil_tmp19 ;
  unsigned short __cil_tmp20 ;
  unsigned short __cil_tmp21 ;
  gboolean __cil_tmp22 ;
  gboolean __cil_tmp23 ;
  gboolean __cil_tmp24 ;
  gboolean __cil_tmp25 ;
  gboolean __cil_tmp26 ;
  gboolean __cil_tmp27 ;
  unsigned short __cil_tmp28 ;
  gboolean __cil_tmp29 ;
  gboolean __cil_tmp30 ;
  gboolean __cil_tmp31 ;
  gboolean __cil_tmp32 ;
  gboolean __cil_tmp33 ;
  gboolean __cil_tmp34 ;
  gboolean __cil_tmp35 ;
  unsigned short __cil_tmp36 ;
  unsigned short __cil_tmp37 ;
  gboolean __cil_tmp38 ;
  gboolean __cil_tmp39 ;
  gboolean __cil_tmp40 ;
  gboolean __cil_tmp41 ;
  gboolean __cil_tmp42 ;
  gboolean __cil_tmp43 ;
  unsigned short __cil_tmp44 ;
  gboolean __cil_tmp45 ;
  gboolean __cil_tmp46 ;
  gboolean __cil_tmp47 ;
  gboolean __cil_tmp48 ;
  gboolean __cil_tmp49 ;
  gboolean __cil_tmp50 ;
  gboolean __cil_tmp51 ;
  unsigned short __cil_tmp52 ;
  unsigned short __cil_tmp53 ;
  gboolean __cil_tmp54 ;
  gboolean __cil_tmp55 ;
  gboolean __cil_tmp56 ;
  gboolean __cil_tmp57 ;
  gboolean __cil_tmp58 ;
  gboolean __cil_tmp59 ;
  unsigned short __cil_tmp60 ;
  gboolean __cil_tmp61 ;
  gboolean __cil_tmp62 ;
  gboolean __cil_tmp63 ;
  gboolean __cil_tmp64 ;
  gboolean __cil_tmp65 ;
  gboolean __cil_tmp66 ;
  gboolean __cil_tmp67 ;
  unsigned short __cil_tmp68 ;
  unsigned short __cil_tmp69 ;
  gboolean __cil_tmp70 ;
  gboolean __cil_tmp71 ;
  gboolean __cil_tmp72 ;
  gboolean __cil_tmp73 ;
  gboolean __cil_tmp74 ;
  gboolean __cil_tmp75 ;
  gboolean __cil_tmp76 ;
  gboolean __cil_tmp77 ;
  gboolean __cil_tmp78 ;
  unsigned short __cil_tmp79 ;
  gboolean __cil_tmp80 ;
  gboolean __cil_tmp81 ;
  gboolean __cil_tmp82 ;
  unsigned short __cil_tmp83 ;
  unsigned short __cil_tmp84 ;
  gboolean __cil_tmp85 ;
  gboolean __cil_tmp86 ;
  gboolean __cil_tmp87 ;
  gboolean __cil_tmp88 ;
  gboolean __cil_tmp89 ;
  gboolean __cil_tmp90 ;
  unsigned short __cil_tmp91 ;
  gboolean __cil_tmp92 ;
  gboolean __cil_tmp93 ;
  gboolean __cil_tmp94 ;
  unsigned short __cil_tmp95 ;
  unsigned short __cil_tmp96 ;
  gboolean __cil_tmp97 ;
  gboolean __cil_tmp98 ;
  gboolean __cil_tmp99 ;
  gboolean __cil_tmp100 ;
  gboolean __cil_tmp101 ;
  gboolean __cil_tmp102 ;
  unsigned short __cil_tmp103 ;
  gboolean __cil_tmp104 ;
  gboolean __cil_tmp105 ;
  gboolean __cil_tmp106 ;
  unsigned short __cil_tmp107 ;
  unsigned short __cil_tmp108 ;
  gboolean __cil_tmp109 ;
  gboolean __cil_tmp110 ;
  gboolean __cil_tmp111 ;
  gboolean __cil_tmp112 ;
  gboolean __cil_tmp113 ;
  gboolean __cil_tmp114 ;
  unsigned short __cil_tmp115 ;
  gboolean __cil_tmp116 ;
  gboolean __cil_tmp117 ;
  gboolean __cil_tmp118 ;
  unsigned short __cil_tmp119 ;
  unsigned short __cil_tmp120 ;
  gboolean __cil_tmp121 ;

  {
#line 610
  pos.x = (gushort )0;
#line 610
  pos.y = (gushort )0;
#line 612
  if (! clockwise) {
    {
#line 614
    if ((unsigned int )*edge == (unsigned int )1) {
#line 614
      goto case_1;
    }
#line 646
    if ((unsigned int )*edge == (unsigned int )0) {
#line 646
      goto case_0;
    }
#line 678
    if ((unsigned int )*edge == (unsigned int )3) {
#line 678
      goto case_3;
    }
#line 712
    if ((unsigned int )*edge == (unsigned int )2) {
#line 712
      goto case_2;
    }
#line 745
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 616
    __cil_tmp11 = is_outline_edge((edge_type )1, bitmap, *row, (unsigned short )((int )*col - 1),
                                  color, exp___0);
    }
    {
#line 616
    __cil_tmp10 = is_marked_edge((edge_type )1, *row, (unsigned short )((int )*col - 1),
                                 marked);
    }
#line 616
    if ((int )*col >= 1) {
#line 616
      if (! __cil_tmp10) {
#line 616
        if (__cil_tmp11) {
#line 619
          __cil_tmp12 = *col;
#line 619
          (*col) --;
#line 620
          pos.x = *col;
#line 621
          pos.y = (gushort )((int )bitmap->height - (int )*row);
#line 622
          goto switch_break;
        }
      }
    }
    {
#line 624
    __cil_tmp13 = at_exception_got_fatal(exp___0);
    }
#line 624
    if (__cil_tmp13) {
#line 624
      goto cleanup;
    }
    {
#line 626
    __cil_tmp19 = is_marked_edge((edge_type )0, *row, (unsigned short )((int )*col - 1),
                                 marked);
    }
    {
#line 626
    __cil_tmp18 = is_marked_edge((edge_type )3, (unsigned short )((int )*row - 1),
                                 *col, marked);
    }
    {
#line 626
    __cil_tmp17 = is_marked_edge((edge_type )1, *row, (unsigned short )((int )*col - 1),
                                 marked);
    }
    {
#line 626
    __cil_tmp16 = is_marked_edge((edge_type )2, (unsigned short )((int )*row - 1),
                                 *col, marked);
    }
    {
#line 626
    __cil_tmp15 = is_outline_edge((edge_type )0, bitmap, (unsigned short )((int )*row - 1),
                                  (unsigned short )((int )*col - 1), color, exp___0);
    }
    {
#line 626
    __cil_tmp14 = is_marked_edge((edge_type )0, (unsigned short )((int )*row - 1),
                                 (unsigned short )((int )*col - 1), marked);
    }
#line 626
    if ((int )*col >= 1) {
#line 626
      if ((int )*row >= 1) {
#line 626
        if (! __cil_tmp14) {
#line 626
          if (__cil_tmp15) {
#line 626
            if (! (__cil_tmp16 && __cil_tmp17)) {
#line 626
              if (! (__cil_tmp18 && __cil_tmp19)) {
#line 628
                *edge = (edge_type )0;
#line 629
                __cil_tmp20 = *col;
#line 629
                (*col) --;
#line 630
                __cil_tmp21 = *row;
#line 630
                (*row) --;
#line 631
                pos.x = (gushort )((int )*col + 1);
#line 632
                pos.y = (gushort )((int )bitmap->height - (int )*row);
#line 633
                goto switch_break;
              }
            }
          }
        }
      }
    }
    {
#line 635
    __cil_tmp22 = at_exception_got_fatal(exp___0);
    }
#line 635
    if (__cil_tmp22) {
#line 635
      goto cleanup;
    }
    {
#line 636
    __cil_tmp24 = is_outline_edge((edge_type )2, bitmap, *row, *col, color, exp___0);
    }
    {
#line 636
    __cil_tmp23 = is_marked_edge((edge_type )2, *row, *col, marked);
    }
#line 636
    if (! __cil_tmp23) {
#line 636
      if (__cil_tmp24) {
#line 638
        *edge = (edge_type )2;
#line 639
        pos.x = *col;
#line 640
        pos.y = (gushort )(((int )bitmap->height - (int )*row) - 1);
#line 641
        goto switch_break;
      }
    }
    {
#line 643
    __cil_tmp25 = at_exception_got_fatal(exp___0);
    }
#line 643
    if (__cil_tmp25) {
#line 643
      goto cleanup;
    }
#line 644
    *edge = (edge_type )4;
#line 645
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 648
    __cil_tmp27 = is_outline_edge((edge_type )0, bitmap, (unsigned short )((int )*row - 1),
                                  *col, color, exp___0);
    }
    {
#line 648
    __cil_tmp26 = is_marked_edge((edge_type )0, (unsigned short )((int )*row - 1),
                                 *col, marked);
    }
#line 648
    if ((int )*row >= 1) {
#line 648
      if (! __cil_tmp26) {
#line 648
        if (__cil_tmp27) {
#line 651
          __cil_tmp28 = *row;
#line 651
          (*row) --;
#line 652
          pos.x = (gushort )((int )*col + 1);
#line 653
          pos.y = (gushort )((int )bitmap->height - (int )*row);
#line 654
          goto switch_break;
        }
      }
    }
    {
#line 656
    __cil_tmp29 = at_exception_got_fatal(exp___0);
    }
#line 656
    if (__cil_tmp29) {
#line 656
      goto cleanup;
    }
    {
#line 658
    __cil_tmp35 = is_marked_edge((edge_type )0, (unsigned short )((int )*row - 1),
                                 *col, marked);
    }
    {
#line 658
    __cil_tmp34 = is_marked_edge((edge_type )1, *row, (unsigned short )((int )*col + 1),
                                 marked);
    }
    {
#line 658
    __cil_tmp33 = is_marked_edge((edge_type )3, (unsigned short )((int )*row - 1),
                                 *col, marked);
    }
    {
#line 658
    __cil_tmp32 = is_marked_edge((edge_type )2, *row, (unsigned short )((int )*col + 1),
                                 marked);
    }
    {
#line 658
    __cil_tmp31 = is_outline_edge((edge_type )3, bitmap, (unsigned short )((int )*row - 1),
                                  (unsigned short )((int )*col + 1), color, exp___0);
    }
    {
#line 658
    __cil_tmp30 = is_marked_edge((edge_type )3, (unsigned short )((int )*row - 1),
                                 (unsigned short )((int )*col + 1), marked);
    }
#line 658
    if ((int )*col + 1 < (int )marked->width) {
#line 658
      if ((int )*row >= 1) {
#line 658
        if (! __cil_tmp30) {
#line 658
          if (__cil_tmp31) {
#line 658
            if (! (__cil_tmp32 && __cil_tmp33)) {
#line 658
              if (! (__cil_tmp34 && __cil_tmp35)) {
#line 660
                *edge = (edge_type )3;
#line 661
                (*col) ++;
#line 662
                __cil_tmp37 = *row;
#line 662
                (*row) --;
#line 663
                pos.x = (gushort )((int )*col + 1);
#line 664
                pos.y = (gushort )(((int )bitmap->height - (int )*row) - 1);
#line 665
                goto switch_break;
              }
            }
          }
        }
      }
    }
    {
#line 667
    __cil_tmp38 = at_exception_got_fatal(exp___0);
    }
#line 667
    if (__cil_tmp38) {
#line 667
      goto cleanup;
    }
    {
#line 668
    __cil_tmp40 = is_outline_edge((edge_type )1, bitmap, *row, *col, color, exp___0);
    }
    {
#line 668
    __cil_tmp39 = is_marked_edge((edge_type )1, *row, *col, marked);
    }
#line 668
    if (! __cil_tmp39) {
#line 668
      if (__cil_tmp40) {
#line 670
        *edge = (edge_type )1;
#line 671
        pos.x = *col;
#line 672
        pos.y = (gushort )((int )bitmap->height - (int )*row);
#line 673
        goto switch_break;
      }
    }
    {
#line 675
    __cil_tmp41 = at_exception_got_fatal(exp___0);
    }
#line 675
    if (__cil_tmp41) {
#line 675
      goto cleanup;
    }
#line 676
    *edge = (edge_type )4;
#line 677
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 680
    __cil_tmp43 = is_outline_edge((edge_type )3, bitmap, *row, (unsigned short )((int )*col + 1),
                                  color, exp___0);
    }
    {
#line 680
    __cil_tmp42 = is_marked_edge((edge_type )3, *row, (unsigned short )((int )*col + 1),
                                 marked);
    }
#line 680
    if ((int )*col + 1 < (int )marked->width) {
#line 680
      if (! __cil_tmp42) {
#line 680
        if (__cil_tmp43) {
#line 684
          (*col) ++;
#line 685
          pos.x = (gushort )((int )*col + 1);
#line 686
          pos.y = (gushort )(((int )bitmap->height - (int )*row) - 1);
#line 687
          goto switch_break;
        }
      }
    }
    {
#line 689
    __cil_tmp45 = at_exception_got_fatal(exp___0);
    }
#line 689
    if (__cil_tmp45) {
#line 689
      goto cleanup;
    }
    {
#line 691
    __cil_tmp51 = is_marked_edge((edge_type )3, *row, (unsigned short )((int )*col + 1),
                                 marked);
    }
    {
#line 691
    __cil_tmp50 = is_marked_edge((edge_type )0, (unsigned short )((int )*row + 1),
                                 *col, marked);
    }
    {
#line 691
    __cil_tmp49 = is_marked_edge((edge_type )2, *row, (unsigned short )((int )*col + 1),
                                 marked);
    }
    {
#line 691
    __cil_tmp48 = is_marked_edge((edge_type )1, (unsigned short )((int )*row + 1),
                                 *col, marked);
    }
    {
#line 691
    __cil_tmp47 = is_outline_edge((edge_type )2, bitmap, (unsigned short )((int )*row + 1),
                                  (unsigned short )((int )*col + 1), color, exp___0);
    }
    {
#line 691
    __cil_tmp46 = is_marked_edge((edge_type )2, (unsigned short )((int )*row + 1),
                                 (unsigned short )((int )*col + 1), marked);
    }
#line 691
    if ((int )*col + 1 < (int )marked->width) {
#line 691
      if ((int )*row + 1 < (int )marked->height) {
#line 691
        if (! __cil_tmp46) {
#line 691
          if (__cil_tmp47) {
#line 691
            if (! (__cil_tmp48 && __cil_tmp49)) {
#line 691
              if (! (__cil_tmp50 && __cil_tmp51)) {
#line 694
                *edge = (edge_type )2;
#line 695
                (*col) ++;
#line 696
                (*row) ++;
#line 697
                pos.x = *col;
#line 698
                pos.y = (gushort )(((int )bitmap->height - (int )*row) - 1);
#line 699
                goto switch_break;
              }
            }
          }
        }
      }
    }
    {
#line 701
    __cil_tmp54 = at_exception_got_fatal(exp___0);
    }
#line 701
    if (__cil_tmp54) {
#line 701
      goto cleanup;
    }
    {
#line 702
    __cil_tmp56 = is_outline_edge((edge_type )0, bitmap, *row, *col, color, exp___0);
    }
    {
#line 702
    __cil_tmp55 = is_marked_edge((edge_type )0, *row, *col, marked);
    }
#line 702
    if (! __cil_tmp55) {
#line 702
      if (__cil_tmp56) {
#line 704
        *edge = (edge_type )0;
#line 705
        pos.x = (gushort )((int )*col + 1);
#line 706
        pos.y = (gushort )((int )bitmap->height - (int )*row);
#line 707
        goto switch_break;
      }
    }
    {
#line 709
    __cil_tmp57 = at_exception_got_fatal(exp___0);
    }
#line 709
    if (__cil_tmp57) {
#line 709
      goto cleanup;
    }
#line 710
    *edge = (edge_type )4;
#line 711
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 714
    __cil_tmp59 = is_outline_edge((edge_type )2, bitmap, (unsigned short )((int )*row + 1),
                                  *col, color, exp___0);
    }
    {
#line 714
    __cil_tmp58 = is_marked_edge((edge_type )2, (unsigned short )((int )*row + 1),
                                 *col, marked);
    }
#line 714
    if ((int )*row + 1 < (int )marked->height) {
#line 714
      if (! __cil_tmp58) {
#line 714
        if (__cil_tmp59) {
#line 718
          (*row) ++;
#line 719
          pos.x = *col;
#line 720
          pos.y = (gushort )(((int )bitmap->height - (int )*row) - 1);
#line 721
          goto switch_break;
        }
      }
    }
    {
#line 723
    __cil_tmp61 = at_exception_got_fatal(exp___0);
    }
#line 723
    if (__cil_tmp61) {
#line 723
      goto cleanup;
    }
    {
#line 725
    __cil_tmp67 = is_marked_edge((edge_type )2, (unsigned short )((int )*row + 1),
                                 *col, marked);
    }
    {
#line 725
    __cil_tmp66 = is_marked_edge((edge_type )3, *row, (unsigned short )((int )*col - 1),
                                 marked);
    }
    {
#line 725
    __cil_tmp65 = is_marked_edge((edge_type )1, (unsigned short )((int )*row + 1),
                                 *col, marked);
    }
    {
#line 725
    __cil_tmp64 = is_marked_edge((edge_type )0, *row, (unsigned short )((int )*col - 1),
                                 marked);
    }
    {
#line 725
    __cil_tmp63 = is_outline_edge((edge_type )1, bitmap, (unsigned short )((int )*row + 1),
                                  (unsigned short )((int )*col - 1), color, exp___0);
    }
    {
#line 725
    __cil_tmp62 = is_marked_edge((edge_type )1, (unsigned short )((int )*row + 1),
                                 (unsigned short )((int )*col - 1), marked);
    }
#line 725
    if ((int )*col >= 1) {
#line 725
      if ((int )*row + 1 < (int )marked->height) {
#line 725
        if (! __cil_tmp62) {
#line 725
          if (__cil_tmp63) {
#line 725
            if (! (__cil_tmp64 && __cil_tmp65)) {
#line 725
              if (! (__cil_tmp66 && __cil_tmp67)) {
#line 728
                *edge = (edge_type )1;
#line 729
                __cil_tmp68 = *col;
#line 729
                (*col) --;
#line 730
                (*row) ++;
#line 731
                pos.x = *col;
#line 732
                pos.y = (gushort )((int )bitmap->height - (int )*row);
#line 733
                goto switch_break;
              }
            }
          }
        }
      }
    }
    {
#line 735
    __cil_tmp70 = at_exception_got_fatal(exp___0);
    }
#line 735
    if (__cil_tmp70) {
#line 735
      goto cleanup;
    }
    {
#line 736
    __cil_tmp72 = is_outline_edge((edge_type )3, bitmap, *row, *col, color, exp___0);
    }
    {
#line 736
    __cil_tmp71 = is_marked_edge((edge_type )3, *row, *col, marked);
    }
#line 736
    if (! __cil_tmp71) {
#line 736
      if (__cil_tmp72) {
#line 738
        *edge = (edge_type )3;
#line 739
        pos.x = (gushort )((int )*col + 1);
#line 740
        pos.y = (gushort )(((int )bitmap->height - (int )*row) - 1);
#line 741
        goto switch_break;
      }
    }
    {
#line 743
    __cil_tmp73 = at_exception_got_fatal(exp___0);
    }
#line 743
    if (__cil_tmp73) {
#line 743
      goto cleanup;
    }

    switch_default: /* CIL Label */ 
    case_4: /* CIL Label */ 
#line 746
    *edge = (edge_type )4;
#line 747
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 750
    if ((unsigned int )*edge == (unsigned int )1) {
#line 750
      goto case_1___0;
    }
#line 782
    if ((unsigned int )*edge == (unsigned int )0) {
#line 782
      goto case_0___0;
    }
#line 814
    if ((unsigned int )*edge == (unsigned int )3) {
#line 814
      goto case_3___0;
    }
#line 848
    if ((unsigned int )*edge == (unsigned int )2) {
#line 848
      goto case_2___0;
    }
#line 881
    goto switch_default___0;
    case_1___0: /* CIL Label */ 
    {
#line 751
    __cil_tmp75 = is_outline_edge((edge_type )2, bitmap, *row, *col, color, exp___0);
    }
    {
#line 751
    __cil_tmp74 = is_marked_edge((edge_type )2, *row, *col, marked);
    }
#line 751
    if (! __cil_tmp74) {
#line 751
      if (__cil_tmp75) {
#line 753
        *edge = (edge_type )2;
#line 754
        pos.x = *col;
#line 755
        pos.y = (gushort )(((int )bitmap->height - (int )*row) - 1);
#line 756
        goto switch_break___0;
      }
    }
    {
#line 758
    __cil_tmp76 = at_exception_got_fatal(exp___0);
    }
#line 758
    if (__cil_tmp76) {
#line 758
      goto cleanup;
    }
    {
#line 760
    __cil_tmp78 = is_outline_edge((edge_type )1, bitmap, *row, (unsigned short )((int )*col - 1),
                                  color, exp___0);
    }
    {
#line 760
    __cil_tmp77 = is_marked_edge((edge_type )1, *row, (unsigned short )((int )*col - 1),
                                 marked);
    }
#line 760
    if ((int )*col >= 1) {
#line 760
      if (! __cil_tmp77) {
#line 760
        if (__cil_tmp78) {
#line 763
          __cil_tmp79 = *col;
#line 763
          (*col) --;
#line 764
          pos.x = *col;
#line 765
          pos.y = (gushort )((int )bitmap->height - (int )*row);
#line 766
          goto switch_break___0;
        }
      }
    }
    {
#line 768
    __cil_tmp80 = at_exception_got_fatal(exp___0);
    }
#line 768
    if (__cil_tmp80) {
#line 768
      goto cleanup;
    }
    {
#line 770
    __cil_tmp82 = is_outline_edge((edge_type )0, bitmap, (unsigned short )((int )*row - 1),
                                  (unsigned short )((int )*col - 1), color, exp___0);
    }
    {
#line 770
    __cil_tmp81 = is_marked_edge((edge_type )0, (unsigned short )((int )*row - 1),
                                 (unsigned short )((int )*col - 1), marked);
    }
#line 770
    if ((int )*col >= 1) {
#line 770
      if ((int )*row >= 1) {
#line 770
        if (! __cil_tmp81) {
#line 770
          if (__cil_tmp82) {
#line 772
            *edge = (edge_type )0;
#line 773
            __cil_tmp83 = *col;
#line 773
            (*col) --;
#line 774
            __cil_tmp84 = *row;
#line 774
            (*row) --;
#line 775
            pos.x = (gushort )((int )*col + 1);
#line 776
            pos.y = (gushort )((int )bitmap->height - (int )*row);
#line 777
            goto switch_break___0;
          }
        }
      }
    }
    {
#line 779
    __cil_tmp85 = at_exception_got_fatal(exp___0);
    }
#line 779
    if (__cil_tmp85) {
#line 779
      goto cleanup;
    }
#line 780
    *edge = (edge_type )4;
#line 781
    goto switch_break___0;
    case_0___0: /* CIL Label */ 
    {
#line 783
    __cil_tmp87 = is_outline_edge((edge_type )1, bitmap, *row, *col, color, exp___0);
    }
    {
#line 783
    __cil_tmp86 = is_marked_edge((edge_type )1, *row, *col, marked);
    }
#line 783
    if (! __cil_tmp86) {
#line 783
      if (__cil_tmp87) {
#line 785
        *edge = (edge_type )1;
#line 786
        pos.x = *col;
#line 787
        pos.y = (gushort )((int )bitmap->height - (int )*row);
#line 788
        goto switch_break___0;
      }
    }
    {
#line 790
    __cil_tmp88 = at_exception_got_fatal(exp___0);
    }
#line 790
    if (__cil_tmp88) {
#line 790
      goto cleanup;
    }
    {
#line 792
    __cil_tmp90 = is_outline_edge((edge_type )0, bitmap, (unsigned short )((int )*row - 1),
                                  *col, color, exp___0);
    }
    {
#line 792
    __cil_tmp89 = is_marked_edge((edge_type )0, (unsigned short )((int )*row - 1),
                                 *col, marked);
    }
#line 792
    if ((int )*row >= 1) {
#line 792
      if (! __cil_tmp89) {
#line 792
        if (__cil_tmp90) {
#line 795
          __cil_tmp91 = *row;
#line 795
          (*row) --;
#line 796
          pos.x = (gushort )((int )*col + 1);
#line 797
          pos.y = (gushort )((int )bitmap->height - (int )*row);
#line 798
          goto switch_break___0;
        }
      }
    }
    {
#line 800
    __cil_tmp92 = at_exception_got_fatal(exp___0);
    }
#line 800
    if (__cil_tmp92) {
#line 800
      goto cleanup;
    }
    {
#line 802
    __cil_tmp94 = is_outline_edge((edge_type )3, bitmap, (unsigned short )((int )*row - 1),
                                  (unsigned short )((int )*col + 1), color, exp___0);
    }
    {
#line 802
    __cil_tmp93 = is_marked_edge((edge_type )3, (unsigned short )((int )*row - 1),
                                 (unsigned short )((int )*col + 1), marked);
    }
#line 802
    if ((int )*col + 1 < (int )marked->width) {
#line 802
      if ((int )*row >= 1) {
#line 802
        if (! __cil_tmp93) {
#line 802
          if (__cil_tmp94) {
#line 804
            *edge = (edge_type )3;
#line 805
            (*col) ++;
#line 806
            __cil_tmp96 = *row;
#line 806
            (*row) --;
#line 807
            pos.x = (gushort )((int )*col + 1);
#line 808
            pos.y = (gushort )(((int )bitmap->height - (int )*row) - 1);
#line 809
            goto switch_break___0;
          }
        }
      }
    }
    {
#line 811
    __cil_tmp97 = at_exception_got_fatal(exp___0);
    }
#line 811
    if (__cil_tmp97) {
#line 811
      goto cleanup;
    }
#line 812
    *edge = (edge_type )4;
#line 813
    goto switch_break___0;
    case_3___0: /* CIL Label */ 
    {
#line 815
    __cil_tmp99 = is_outline_edge((edge_type )0, bitmap, *row, *col, color, exp___0);
    }
    {
#line 815
    __cil_tmp98 = is_marked_edge((edge_type )0, *row, *col, marked);
    }
#line 815
    if (! __cil_tmp98) {
#line 815
      if (__cil_tmp99) {
#line 817
        *edge = (edge_type )0;
#line 818
        pos.x = (gushort )((int )*col + 1);
#line 819
        pos.y = (gushort )((int )bitmap->height - (int )*row);
#line 820
        goto switch_break___0;
      }
    }
    {
#line 822
    __cil_tmp100 = at_exception_got_fatal(exp___0);
    }
#line 822
    if (__cil_tmp100) {
#line 822
      goto cleanup;
    }
    {
#line 824
    __cil_tmp102 = is_outline_edge((edge_type )3, bitmap, *row, (unsigned short )((int )*col + 1),
                                   color, exp___0);
    }
    {
#line 824
    __cil_tmp101 = is_marked_edge((edge_type )3, *row, (unsigned short )((int )*col + 1),
                                  marked);
    }
#line 824
    if ((int )*col + 1 < (int )marked->width) {
#line 824
      if (! __cil_tmp101) {
#line 824
        if (__cil_tmp102) {
#line 828
          (*col) ++;
#line 829
          pos.x = (gushort )((int )*col + 1);
#line 830
          pos.y = (gushort )(((int )bitmap->height - (int )*row) - 1);
#line 831
          goto switch_break___0;
        }
      }
    }
    {
#line 833
    __cil_tmp104 = at_exception_got_fatal(exp___0);
    }
#line 833
    if (__cil_tmp104) {
#line 833
      goto cleanup;
    }
    {
#line 835
    __cil_tmp106 = is_outline_edge((edge_type )2, bitmap, (unsigned short )((int )*row + 1),
                                   (unsigned short )((int )*col + 1), color, exp___0);
    }
    {
#line 835
    __cil_tmp105 = is_marked_edge((edge_type )2, (unsigned short )((int )*row + 1),
                                  (unsigned short )((int )*col + 1), marked);
    }
#line 835
    if ((int )*col + 1 < (int )marked->width) {
#line 835
      if ((int )*row + 1 < (int )marked->height) {
#line 835
        if (! __cil_tmp105) {
#line 835
          if (__cil_tmp106) {
#line 838
            *edge = (edge_type )2;
#line 839
            (*col) ++;
#line 840
            (*row) ++;
#line 841
            pos.x = *col;
#line 842
            pos.y = (gushort )(((int )bitmap->height - (int )*row) - 1);
#line 843
            goto switch_break___0;
          }
        }
      }
    }
    {
#line 845
    __cil_tmp109 = at_exception_got_fatal(exp___0);
    }
#line 845
    if (__cil_tmp109) {
#line 845
      goto cleanup;
    }
#line 846
    *edge = (edge_type )4;
#line 847
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
    {
#line 849
    __cil_tmp111 = is_outline_edge((edge_type )3, bitmap, *row, *col, color, exp___0);
    }
    {
#line 849
    __cil_tmp110 = is_marked_edge((edge_type )3, *row, *col, marked);
    }
#line 849
    if (! __cil_tmp110) {
#line 849
      if (__cil_tmp111) {
#line 851
        *edge = (edge_type )3;
#line 852
        pos.x = (gushort )((int )*col + 1);
#line 853
        pos.y = (gushort )(((int )bitmap->height - (int )*row) - 1);
#line 854
        goto switch_break___0;
      }
    }
    {
#line 856
    __cil_tmp112 = at_exception_got_fatal(exp___0);
    }
#line 856
    if (__cil_tmp112) {
#line 856
      goto cleanup;
    }
    {
#line 858
    __cil_tmp114 = is_outline_edge((edge_type )2, bitmap, (unsigned short )((int )*row + 1),
                                   *col, color, exp___0);
    }
    {
#line 858
    __cil_tmp113 = is_marked_edge((edge_type )2, (unsigned short )((int )*row + 1),
                                  *col, marked);
    }
#line 858
    if ((int )*row + 1 < (int )marked->height) {
#line 858
      if (! __cil_tmp113) {
#line 858
        if (__cil_tmp114) {
#line 862
          (*row) ++;
#line 863
          pos.x = *col;
#line 864
          pos.y = (gushort )(((int )bitmap->height - (int )*row) - 1);
#line 865
          goto switch_break___0;
        }
      }
    }
    {
#line 867
    __cil_tmp116 = at_exception_got_fatal(exp___0);
    }
#line 867
    if (__cil_tmp116) {
#line 867
      goto cleanup;
    }
    {
#line 869
    __cil_tmp118 = is_outline_edge((edge_type )1, bitmap, (unsigned short )((int )*row + 1),
                                   (unsigned short )((int )*col - 1), color, exp___0);
    }
    {
#line 869
    __cil_tmp117 = is_marked_edge((edge_type )1, (unsigned short )((int )*row + 1),
                                  (unsigned short )((int )*col - 1), marked);
    }
#line 869
    if ((int )*col >= 1) {
#line 869
      if ((int )*row + 1 < (int )marked->height) {
#line 869
        if (! __cil_tmp117) {
#line 869
          if (__cil_tmp118) {
#line 872
            *edge = (edge_type )1;
#line 873
            __cil_tmp119 = *col;
#line 873
            (*col) --;
#line 874
            (*row) ++;
#line 875
            pos.x = *col;
#line 876
            pos.y = (gushort )((int )bitmap->height - (int )*row);
#line 877
            goto switch_break___0;
          }
        }
      }
    }
    {
#line 879
    __cil_tmp121 = at_exception_got_fatal(exp___0);
    }
#line 879
    if (__cil_tmp121) {
#line 879
      goto cleanup;
    }

    switch_default___0: /* CIL Label */ 
    case_4___0: /* CIL Label */ 
#line 882
    *edge = (edge_type )4;
#line 883
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
  cleanup: 
#line 886
  return (pos);
}
}
#line 808 "/usr/include/glib-2.0/gobject/gobject.h"
__inline static void g_assert_finalize_object___6(GObject *object ) 
{ 
  gpointer weak_pointer ;
  long __cil_tmp3 ;
  long __cil_tmp4 ;

  {
#line 810
  weak_pointer = object;
  {
#line 812
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 812
    __cil_tmp3 = __builtin_expect((long )0, (long )1);
    }
#line 812
    if (__cil_tmp3) {

    } else {
      {
#line 812
      g_assertion_message((char const   *)((gchar *)0), "/usr/include/glib-2.0/gobject/gobject.h",
                          812, (char const   *)"g_assert_finalize_object\312\001@",
                          "\'G_IS_OBJECT (weak_pointer)\' should be TRUE");
      }
    }
#line 812
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 813
  g_object_add_weak_pointer(object, & weak_pointer);
#line 814
  g_object_unref(weak_pointer);
  }
  {
#line 815
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 815
    __cil_tmp4 = __builtin_expect((long )0, (long )1);
    }
#line 815
    if (__cil_tmp4) {

    } else {
      {
#line 815
      g_assertion_message((char const   *)((gchar *)0), "/usr/include/glib-2.0/gobject/gobject.h",
                          815, (char const   *)"g_assert_finalize_object\312\001\300\a\266\256\b",
                          "\'weak_pointer\' should be NULLV");
      }
    }
#line 815
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 40 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input.c"
static GHashTable *at_input_formats  =    (GHashTable *)((void *)0);
#line 41
static at_input_format_entry *at_input_format_new(gchar *descr , at_input_func reader ,
                                                  gpointer user_data , GDestroyNotify user_data_destroy_func ) ;
#line 42
static void at_input_format_free(at_input_format_entry *entry ) ;
#line 47
static void input_list_set(gpointer key , gpointer value , gpointer user_data ) ;
#line 48
static void input_list_strlen(gpointer key , gpointer value , gpointer user_data ) ;
#line 49
static void input_list_strcat(gpointer key , gpointer value , gpointer user_data ) ;
#line 57 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input.c"
int at_input_init(void) 
{ 
  GHashTable *__cil_tmp1 ;

  {
#line 59
  if (at_input_formats) {
#line 60
    return (1);
  }
  {
#line 62
  at_input_formats = g_hash_table_new_full(& g_str_hash, (GEqualFunc )(& g_str_equal),
                                           & g_free, (GDestroyNotify )(& at_input_format_free));
  }
#line 63
  if (! at_input_formats) {
#line 64
    return (0);
  }
#line 65
  return (1);
}
}
#line 68 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input.c"
static at_input_format_entry *at_input_format_new(gchar *descr , at_input_func reader ,
                                                  gpointer user_data , GDestroyNotify user_data_destroy_func ) 
{ 
  at_input_format_entry *entry ;
  gpointer __cil_tmp6 ;
  gchar *__cil_tmp7 ;

  {
  {
#line 71
  entry = (at_input_format_entry *)g_malloc(sizeof(at_input_format_entry ));
  }
#line 72
  if (entry) {
    {
#line 73
    entry->reader.func = reader;
#line 74
    entry->reader.data = user_data;
#line 75
    entry->descr = g_strdup(descr);
#line 76
    entry->user_data_destroy_func = user_data_destroy_func;
    }
  }
#line 78
  return (entry);
}
}
#line 81 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input.c"
static void at_input_format_free(at_input_format_entry *entry ) 
{ 


  {
  {
#line 83
  g_free((gpointer )entry->descr);
  }
#line 84
  if (entry->user_data_destroy_func) {
    {
#line 85
    (*(entry->user_data_destroy_func))(entry->reader.data);
    }
  }
  {
#line 86
  g_free(entry);
  }
  return;
}
}
#line 90 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input.c"
int at_input_add_handler(gchar *suffix , gchar *description , at_input_func reader ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 92
  __cil_tmp4 = at_input_add_handler_full(suffix, description, reader, 0, (void *)0,
                                         (GDestroyNotify )((void *)0));
  }
#line 92
  return (__cil_tmp4);
}
}
#line 95 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input.c"
int at_input_add_handler_full(gchar *suffix , gchar *description , at_input_func reader ,
                              gboolean override , gpointer user_data , GDestroyNotify user_data_destroy_func ) 
{ 
  gchar *gsuffix ;
  gchar *gdescription ;
  at_input_format_entry *old_entry ;
  at_input_format_entry *new_entry ;
  long __cil_tmp11 ;
  long __cil_tmp12 ;
  long __cil_tmp13 ;
  gchar *__cil_tmp14 ;
  long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  gchar *__cil_tmp17 ;
  gpointer __cil_tmp18 ;
  at_input_format_entry *__cil_tmp19 ;
  long __cil_tmp20 ;

  {
  {
#line 102
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 102
    __cil_tmp11 = __builtin_expect((long )0, (long )1);
    }
#line 102
    if (! __cil_tmp11) {
      {
#line 102
      g_return_if_fail_warning((char const   *)((gchar *)0), (char const   *)"at_input_add_handler_full",
                               "suffix");
      }
#line 102
      return (0);
    }
#line 102
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 103
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 103
    __cil_tmp12 = __builtin_expect((long )0, (long )1);
    }
#line 103
    if (! __cil_tmp12) {
      {
#line 103
      g_return_if_fail_warning((char const   *)((gchar *)0), (char const   *)"at_input_add_handler_full",
                               "description");
      }
#line 103
      return (0);
    }
#line 103
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 104
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 104
    __cil_tmp13 = __builtin_expect((long )0, (long )1);
    }
#line 104
    if (! __cil_tmp13) {
      {
#line 104
      g_return_if_fail_warning((char const   *)((gchar *)0), (char const   *)"at_input_add_handler_full",
                               "reader");
      }
#line 104
      return (0);
    }
#line 104
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 106
  gsuffix = g_strdup((gchar *)suffix);
  }
  {
#line 107
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 107
    __cil_tmp15 = __builtin_expect((long )0, (long )1);
    }
#line 107
    if (! __cil_tmp15) {
      {
#line 107
      g_return_if_fail_warning((char const   *)((gchar *)0), (char const   *)"at_input_add_handler_full",
                               "gsuffix");
      }
#line 107
      return (0);
    }
#line 107
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 108
  __cil_tmp16 = strlen((char const   *)gsuffix);
#line 108
  __cil_tmp17 = g_ascii_strdown(gsuffix, (gssize )__cil_tmp16);
#line 108
  gsuffix = __cil_tmp17;
#line 110
  gdescription = (gchar *)description;
#line 112
  old_entry = (at_input_format_entry *)g_hash_table_lookup(at_input_formats, gsuffix);
  }
#line 113
  if (old_entry) {
#line 113
    if (! override) {
      {
#line 114
      g_free(gsuffix);
      }
#line 115
      return (1);
    }
  }
  {
#line 118
  new_entry = at_input_format_new(gdescription, reader, user_data, user_data_destroy_func);
  }
  {
#line 119
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 119
    __cil_tmp20 = __builtin_expect((long )0, (long )1);
    }
#line 119
    if (! __cil_tmp20) {
      {
#line 119
      g_return_if_fail_warning((char const   *)((gchar *)0), (char const   *)"at_input_add_handler_full\370\336\a\027V",
                               "new_entry\372\336\a\027V");
      }
#line 119
      return (0);
    }
#line 119
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 121
  g_hash_table_replace(at_input_formats, gsuffix, new_entry);
  }
#line 122
  return (1);
}
}
#line 125 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input.c"
at_bitmap_reader *at_input_get_handler(gchar *filename ) 
{ 
  char *ext ;
  gchar *__cil_tmp3 ;
  at_bitmap_reader *__cil_tmp4 ;

  {
  {
#line 127
  __cil_tmp3 = find_suffix(filename);
#line 127
  ext = __cil_tmp3;
  }
#line 128
  if (ext == (void *)0) {
#line 129
    ext = "\220";
  }
  {
#line 131
  __cil_tmp4 = at_input_get_handler_by_suffix(ext);
  }
#line 131
  return (__cil_tmp4);
}
}
#line 134 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input.c"
at_bitmap_reader *at_input_get_handler_by_suffix(gchar *suffix ) 
{ 
  at_input_format_entry *format ;
  gchar *gsuffix ;
  gchar *__cil_tmp4 ;
  long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  gchar *__cil_tmp7 ;
  gpointer __cil_tmp8 ;

  {
#line 139
  if (! suffix) {
#line 140
    return ((at_bitmap_reader *)((void *)0));
  } else
#line 139
  if ((int )*(suffix + 0) == 0) {
#line 140
    return ((at_bitmap_reader *)((void *)0));
  }
  {
#line 142
  gsuffix = g_strdup(suffix);
  }
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 143
    __cil_tmp5 = __builtin_expect((long )0, (long )1);
    }
#line 143
    if (! __cil_tmp5) {
      {
#line 143
      g_return_if_fail_warning((char const   *)((gchar *)0), (char const   *)"at_input_get_handler_by_suffix",
                               "gsuffix");
      }
#line 143
      return ((at_bitmap_reader *)((void *)0));
    }
#line 143
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 144
  __cil_tmp6 = strlen((char const   *)gsuffix);
#line 144
  __cil_tmp7 = g_ascii_strdown(gsuffix, (gssize )__cil_tmp6);
#line 144
  gsuffix = __cil_tmp7;
#line 145
  format = (at_input_format_entry *)g_hash_table_lookup(at_input_formats, gsuffix);
#line 146
  g_free(gsuffix);
  }
#line 148
  if (format) {
#line 149
    return (& format->reader);
  } else {
#line 151
    return ((at_bitmap_reader *)((void *)0));
  }
}
}
#line 154 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input.c"
char const   **at_input_list_new(void) 
{ 
  char **list ;
  char **tmp ;
  gint format_count ;
  gint list_count ;
  guint __cil_tmp5 ;

  {
  {
#line 160
  __cil_tmp5 = g_hash_table_size(at_input_formats);
#line 160
  format_count = (gint )__cil_tmp5;
#line 161
  list_count = 2 * format_count;
#line 162
  list = (gchar **)0;
#line 163
  *(list + list_count) = (char *)((void *)0);
#line 165
  tmp = list;
#line 166
  g_hash_table_foreach(at_input_formats, & input_list_set, & tmp);
  }
#line 167
  return ((char const   **)list);
}
}
#line 170 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input.c"
void at_input_list_free(char const   **list ) 
{ 


  {
  {
#line 172
  free((char **)list);
  }
  return;
}
}
#line 175 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input.c"
char *at_input_shortlist(void) 
{ 
  gint length ;
  gint count ;
  char *list ;
  char *tmp ;
  guint __cil_tmp5 ;
  gpointer __cil_tmp6 ;
  long __cil_tmp7 ;

  {
  {
#line 177
  length = 0;
#line 179
  g_hash_table_foreach(at_input_formats, & input_list_strlen, & length);
#line 180
  __cil_tmp5 = g_hash_table_size(at_input_formats);
#line 180
  count = (gint )__cil_tmp5;
#line 183
  length += 2 * count;
#line 184
  list = (char *)g_malloc((gsize )(length + 1));
#line 185
  *(list + 0) = (char )'\000';
#line 187
  tmp = list;
#line 188
  g_hash_table_foreach(at_input_formats, & input_list_strcat, & tmp);
  }
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 191
    __cil_tmp7 = __builtin_expect((long )0, (long )1);
    }
#line 191
    if (! __cil_tmp7) {
      {
#line 191
      g_return_if_fail_warning((char const   *)((gchar *)0), (char const   *)"at_input_shortlist\337\a\027V",
                               "list[length - 2] == \',\'");
      }
#line 191
      return ((char *)((void *)0));
    }
#line 191
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 192
  *(list + (length - 2)) = (char )'\000';
#line 193
  return (list);
}
}
#line 196 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input.c"
static void input_list_set(gpointer key , gpointer value , gpointer user_data ) 
{ 
  at_input_format_entry *format ;
  char const   ***list_ptr ;
  char const   **list ;

  {
#line 198
  format = value;
#line 199
  list_ptr = user_data;
#line 200
  list = *list_ptr;
#line 201
  *(list + 0) = key;
#line 202
  *(list + 1) = format->descr;
#line 203
  *list_ptr = list + 2;
  return;
}
}
#line 206 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input.c"
static void input_list_strlen(gpointer key , gpointer value , gpointer user_data ) 
{ 
  gint *length ;
  long __cil_tmp5 ;
  long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;

  {
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 209
    __cil_tmp5 = __builtin_expect((long )0, (long )1);
    }
#line 209
    if (! __cil_tmp5) {
      {
#line 209
      g_return_if_fail_warning((char const   *)((gchar *)0), (char const   *)"input_list_strlent\337\a\027V",
                               "key");
      }
#line 209
      return;
    }
#line 209
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 210
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 210
    __cil_tmp6 = __builtin_expect((long )0, (long )1);
    }
#line 210
    if (! __cil_tmp6) {
      {
#line 210
      g_return_if_fail_warning((char const   *)((gchar *)0), (char const   *)"input_list_strlen",
                               "user_data");
      }
#line 210
      return;
    }
#line 210
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 212
  length = user_data;
#line 213
  __cil_tmp7 = strlen(key);
  }
#line 213
  *length += __cil_tmp7;
  return;
}
}
#line 216 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input.c"
static void input_list_strcat(gpointer key , gpointer value , gpointer user_data ) 
{ 
  gchar **list_ptr ;
  gchar *list ;
  unsigned long __cil_tmp6 ;

  {
  {
#line 220
  list_ptr = user_data;
#line 221
  list = *list_ptr;
#line 222
  strcat(list, key);
#line 223
  strcat(list, ", ");
#line 226
  __cil_tmp6 = strlen(key);
#line 226
  *list_ptr = (list + __cil_tmp6) + 2;
  }
  return;
}
}
#line 808 "/usr/include/glib-2.0/gobject/gobject.h"
__inline static void g_assert_finalize_object___7(GObject *object ) 
{ 
  gpointer weak_pointer ;
  long __cil_tmp3 ;
  long __cil_tmp4 ;

  {
#line 810
  weak_pointer = object;
  {
#line 812
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 812
    __cil_tmp3 = __builtin_expect((long )0, (long )1);
    }
#line 812
    if (__cil_tmp3) {

    } else {
      {
#line 812
      g_assertion_message((char const   *)((gchar *)0), "/usr/include/glib-2.0/gobject/gobject.h",
                          812, (char const   *)"g_assert_finalize_object\312\001@",
                          "\'G_IS_OBJECT (weak_pointer)\' should be TRUE");
      }
    }
#line 812
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 813
  g_object_add_weak_pointer(object, & weak_pointer);
#line 814
  g_object_unref(weak_pointer);
  }
  {
#line 815
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 815
    __cil_tmp4 = __builtin_expect((long )0, (long )1);
    }
#line 815
    if (__cil_tmp4) {

    } else {
      {
#line 815
      g_assertion_message((char const   *)((gchar *)0), "/usr/include/glib-2.0/gobject/gobject.h",
                          815, (char const   *)"g_assert_finalize_object\312\001@\b\272\256\b",
                          "\'weak_pointer\' should be NULLV");
      }
    }
#line 815
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 42 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output.c"
static GHashTable *at_output_formats  =    (GHashTable *)((void *)0);
#line 43
static at_output_format_entry *at_output_format_new(gchar *descr , at_output_func writer ,
                                                    gpointer user_data , GDestroyNotify user_data_destroy_func ) ;
#line 44
static void at_output_format_free(at_output_format_entry *entry ) ;
#line 49
static void output_list_set(gpointer key , gpointer value , gpointer user_data ) ;
#line 50
static void output_list_strlen(gpointer key , gpointer value , gpointer user_data ) ;
#line 51
static void output_list_strcat(gpointer key , gpointer value , gpointer user_data ) ;
#line 53 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output.c"
int at_output_init(void) 
{ 
  GHashTable *__cil_tmp1 ;

  {
#line 55
  if (at_output_formats) {
#line 56
    return (1);
  }
  {
#line 58
  at_output_formats = g_hash_table_new_full(& g_str_hash, (GEqualFunc )(& g_str_equal),
                                            & g_free, (GDestroyNotify )(& at_output_format_free));
  }
#line 59
  if (! at_output_formats) {
#line 60
    return (0);
  }
#line 61
  return (1);
}
}
#line 64 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output.c"
static at_output_format_entry *at_output_format_new(gchar *descr , at_output_func writer ,
                                                    gpointer user_data , GDestroyNotify user_data_destroy_func ) 
{ 
  at_output_format_entry *entry ;
  gpointer __cil_tmp6 ;
  gchar *__cil_tmp7 ;

  {
  {
#line 67
  entry = (at_output_format_entry *)g_malloc(sizeof(at_output_format_entry ));
  }
#line 68
  if (entry) {
    {
#line 69
    entry->writer.func = writer;
#line 70
    entry->writer.data = user_data;
#line 71
    __cil_tmp7 = g_strdup(descr);
#line 71
    entry->descr = (char const   *)__cil_tmp7;
#line 72
    entry->user_data_destroy_func = user_data_destroy_func;
    }
  }
#line 74
  return (entry);
}
}
#line 77 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output.c"
static void at_output_format_free(at_output_format_entry *entry ) 
{ 


  {
  {
#line 79
  g_free((gpointer )entry->descr);
  }
#line 80
  if (entry->user_data_destroy_func) {
    {
#line 81
    (*(entry->user_data_destroy_func))(entry->writer.data);
    }
  }
  {
#line 82
  g_free(entry);
  }
  return;
}
}
#line 86 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output.c"
int at_output_add_handler(gchar *suffix , gchar *description , at_output_func writer ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 88
  __cil_tmp4 = at_output_add_handler_full(suffix, description, writer, 0, (void *)0,
                                          (GDestroyNotify )((void *)0));
  }
#line 88
  return (__cil_tmp4);
}
}
#line 91 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output.c"
int at_output_add_handler_full(gchar *suffix , gchar *description , at_output_func writer ,
                               gboolean override , gpointer user_data , GDestroyNotify user_data_destroy_func ) 
{ 
  gchar *gsuffix ;
  gchar *gdescription ;
  at_output_format_entry *old_entry ;
  at_output_format_entry *new_entry ;
  long __cil_tmp11 ;
  long __cil_tmp12 ;
  long __cil_tmp13 ;
  gchar *__cil_tmp14 ;
  long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  gchar *__cil_tmp17 ;
  gpointer __cil_tmp18 ;
  at_output_format_entry *__cil_tmp19 ;
  long __cil_tmp20 ;

  {
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 98
    __cil_tmp11 = __builtin_expect((long )0, (long )1);
    }
#line 98
    if (! __cil_tmp11) {
      {
#line 98
      g_return_if_fail_warning((char const   *)((gchar *)0), (char const   *)"at_output_add_handler_full",
                               "suffix");
      }
#line 98
      return (0);
    }
#line 98
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 99
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 99
    __cil_tmp12 = __builtin_expect((long )0, (long )1);
    }
#line 99
    if (! __cil_tmp12) {
      {
#line 99
      g_return_if_fail_warning((char const   *)((gchar *)0), (char const   *)"at_output_add_handler_full",
                               "description");
      }
#line 99
      return (0);
    }
#line 99
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 100
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 100
    __cil_tmp13 = __builtin_expect((long )0, (long )1);
    }
#line 100
    if (! __cil_tmp13) {
      {
#line 100
      g_return_if_fail_warning((char const   *)((gchar *)0), (char const   *)"at_output_add_handler_full",
                               "writer");
      }
#line 100
      return (0);
    }
#line 100
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 102
  gsuffix = g_strdup((gchar *)suffix);
  }
  {
#line 103
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 103
    __cil_tmp15 = __builtin_expect((long )0, (long )1);
    }
#line 103
    if (! __cil_tmp15) {
      {
#line 103
      g_return_if_fail_warning((char const   *)((gchar *)0), (char const   *)"at_output_add_handler_full",
                               "gsuffix");
      }
#line 103
      return (0);
    }
#line 103
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 104
  __cil_tmp16 = strlen((char const   *)gsuffix);
#line 104
  __cil_tmp17 = g_ascii_strdown(gsuffix, (gssize )__cil_tmp16);
#line 104
  gsuffix = __cil_tmp17;
#line 106
  gdescription = (gchar *)description;
#line 108
  old_entry = (at_output_format_entry *)g_hash_table_lookup(at_output_formats, gsuffix);
  }
#line 109
  if (old_entry) {
#line 109
    if (! override) {
      {
#line 110
      g_free(gsuffix);
      }
#line 111
      return (1);
    }
  }
  {
#line 114
  new_entry = at_output_format_new(gdescription, writer, user_data, user_data_destroy_func);
  }
  {
#line 115
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 115
    __cil_tmp20 = __builtin_expect((long )0, (long )1);
    }
#line 115
    if (! __cil_tmp20) {
      {
#line 115
      g_return_if_fail_warning((char const   *)((gchar *)0), (char const   *)"at_output_add_handler_full",
                               "new_entry");
      }
#line 115
      return (0);
    }
#line 115
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 117
  g_hash_table_replace(at_output_formats, gsuffix, new_entry);
  }
#line 118
  return (1);
}
}
#line 121 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output.c"
at_spline_writer *at_output_get_handler(gchar *filename ) 
{ 
  char *ext ;
  gchar *__cil_tmp3 ;
  at_spline_writer *__cil_tmp4 ;

  {
  {
#line 123
  __cil_tmp3 = find_suffix(filename);
#line 123
  ext = __cil_tmp3;
  }
#line 124
  if (ext == (void *)0) {
#line 125
    ext = "\220";
  }
  {
#line 127
  __cil_tmp4 = at_output_get_handler_by_suffix(ext);
  }
#line 127
  return (__cil_tmp4);
}
}
#line 130 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output.c"
at_spline_writer *at_output_get_handler_by_suffix(gchar *suffix ) 
{ 
  at_output_format_entry *format ;
  gchar *gsuffix ;
  gchar *__cil_tmp4 ;
  long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  gchar *__cil_tmp7 ;
  gpointer __cil_tmp8 ;

  {
#line 135
  if (! suffix) {
#line 136
    return ((at_spline_writer *)((void *)0));
  } else
#line 135
  if ((int )*(suffix + 0) == 0) {
#line 136
    return ((at_spline_writer *)((void *)0));
  }
  {
#line 138
  gsuffix = g_strdup(suffix);
  }
  {
#line 139
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 139
    __cil_tmp5 = __builtin_expect((long )0, (long )1);
    }
#line 139
    if (! __cil_tmp5) {
      {
#line 139
      g_return_if_fail_warning((char const   *)((gchar *)0), (char const   *)"at_output_get_handler_by_suffix",
                               "gsuffix");
      }
#line 139
      return ((at_spline_writer *)((void *)0));
    }
#line 139
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 140
  __cil_tmp6 = strlen((char const   *)gsuffix);
#line 140
  __cil_tmp7 = g_ascii_strdown(gsuffix, (gssize )__cil_tmp6);
#line 140
  gsuffix = __cil_tmp7;
#line 141
  format = (at_output_format_entry *)g_hash_table_lookup(at_output_formats, gsuffix);
#line 142
  g_free(gsuffix);
  }
#line 144
  if (format) {
#line 145
    return (& format->writer);
  } else {
#line 147
    return ((at_spline_writer *)((void *)0));
  }
}
}
#line 150 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output.c"
char const   **at_output_list_new(void) 
{ 
  char **list ;
  char **tmp ;
  gint format_count ;
  gint list_count ;
  guint __cil_tmp5 ;

  {
  {
#line 156
  __cil_tmp5 = g_hash_table_size(at_output_formats);
#line 156
  format_count = (gint )__cil_tmp5;
#line 157
  list_count = 2 * format_count;
#line 158
  list = (gchar **)0;
#line 159
  *(list + list_count) = (char *)((void *)0);
#line 161
  tmp = list;
#line 162
  g_hash_table_foreach(at_output_formats, & output_list_set, & tmp);
  }
#line 163
  return ((char const   **)list);
}
}
#line 166 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output.c"
void at_output_list_free(char const   **list ) 
{ 


  {
  {
#line 168
  free((char **)list);
  }
  return;
}
}
#line 171 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output.c"
char *at_output_shortlist(void) 
{ 
  gint length ;
  gint count ;
  char *list ;
  char *tmp ;
  guint __cil_tmp5 ;
  gpointer __cil_tmp6 ;
  long __cil_tmp7 ;

  {
  {
#line 173
  length = 0;
#line 175
  g_hash_table_foreach(at_output_formats, & output_list_strlen, & length);
#line 176
  __cil_tmp5 = g_hash_table_size(at_output_formats);
#line 176
  count = (gint )__cil_tmp5;
#line 179
  length += 2 * count;
#line 180
  list = (char *)g_malloc((gsize )(length + 1));
#line 181
  *(list + 0) = (char )'\000';
#line 183
  tmp = list;
#line 184
  g_hash_table_foreach(at_output_formats, & output_list_strcat, & tmp);
  }
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 187
    __cil_tmp7 = __builtin_expect((long )0, (long )1);
    }
#line 187
    if (! __cil_tmp7) {
      {
#line 187
      g_return_if_fail_warning((char const   *)((gchar *)0), (char const   *)"at_output_shortlist\b\027V",
                               "list[length - 2] == \',\'");
      }
#line 187
      return ((char *)((void *)0));
    }
#line 187
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 188
  *(list + (length - 2)) = (char )'\000';
#line 189
  return (list);
}
}
#line 192 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output.c"
static void output_list_set(gpointer key , gpointer value , gpointer user_data ) 
{ 
  at_output_format_entry *format ;
  char const   ***list_ptr ;
  char const   **list ;

  {
#line 194
  format = value;
#line 195
  list_ptr = user_data;
#line 196
  list = *list_ptr;
#line 197
  *(list + 0) = key;
#line 198
  *(list + 1) = format->descr;
#line 199
  *list_ptr = list + 2;
  return;
}
}
#line 202 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output.c"
static void output_list_strlen(gpointer key , gpointer value , gpointer user_data ) 
{ 
  gint *length ;
  long __cil_tmp5 ;
  long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;

  {
  {
#line 205
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 205
    __cil_tmp5 = __builtin_expect((long )0, (long )1);
    }
#line 205
    if (! __cil_tmp5) {
      {
#line 205
      g_return_if_fail_warning((char const   *)((gchar *)0), (char const   *)"output_list_strlen(\b\027V",
                               "key\a\027V");
      }
#line 205
      return;
    }
#line 205
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 206
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 206
    __cil_tmp6 = __builtin_expect((long )0, (long )1);
    }
#line 206
    if (! __cil_tmp6) {
      {
#line 206
      g_return_if_fail_warning((char const   *)((gchar *)0), (char const   *)"output_list_strlen",
                               "user_data");
      }
#line 206
      return;
    }
#line 206
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 208
  length = user_data;
#line 209
  __cil_tmp7 = strlen(key);
  }
#line 209
  *length += __cil_tmp7;
  return;
}
}
#line 212 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output.c"
static void output_list_strcat(gpointer key , gpointer value , gpointer user_data ) 
{ 
  gchar **list_ptr ;
  gchar *list ;
  unsigned long __cil_tmp6 ;

  {
  {
#line 216
  list_ptr = user_data;
#line 217
  list = *list_ptr;
#line 218
  strcat(list, key);
#line 219
  strcat(list, ", ");
#line 222
  __cil_tmp6 = strlen(key);
#line 222
  *list_ptr = (list + __cil_tmp6) + 2;
  }
  return;
}
}
#line 225 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output.c"
void at_spline_list_foreach(at_spline_list_type *list , AtSplineListForeachFunc func ,
                            gpointer user_data ) 
{ 
  unsigned int i ;
  unsigned int __cil_tmp5 ;

  {
#line 228
  i = (unsigned int )0;
  {
#line 228
  while (1) {
    while_continue: /* CIL Label */ ;
#line 228
    if (! (i < list->length)) {
#line 228
      goto while_break;
    }
    {
#line 229
    (*func)(list, list->data + i, (int )i, user_data);
    }
#line 228
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 233 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output.c"
void at_spline_list_array_foreach(at_spline_list_array_type *list_array , AtSplineListArrayForeachFunc func ,
                                  gpointer user_data ) 
{ 
  unsigned int i ;
  unsigned int __cil_tmp5 ;

  {
#line 236
  i = (unsigned int )0;
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
#line 236
    if (! (i < list_array->length)) {
#line 236
      goto while_break;
    }
    {
#line 237
    (*func)(list_array, list_array->data + i, (int )i, user_data);
    }
#line 236
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 17 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/fit.h"
at_spline_list_array_type fitted_splines(pixel_outline_list_type pixel_outline_list ,
                                         fitting_opts_type *fitting_opts , at_distance_map *dist ,
                                         unsigned short width , unsigned short height ,
                                         at_exception_type *exception , at_progress_func notify_progress ,
                                         gpointer progress_data , at_testcancel_func test_cancel ,
                                         gpointer testcancel_data ) ;
#line 20
fitting_opts_type new_fitting_opts(void) ;
#line 51 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/autotrace.c"
at_fitting_opts_type *at_fitting_opts_new(void) 
{ 
  at_fitting_opts_type *opts ;
  void *__cil_tmp2 ;
  int tmp ;
  fitting_opts_type __cil_tmp4 ;

  {
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 54
    __cil_tmp2 = malloc(sizeof(at_fitting_opts_type ));
#line 54
    opts = (gpointer )__cil_tmp2;
    }
#line 54
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 55
  *opts = new_fitting_opts();
  }
#line 56
  return (opts);
}
}
#line 59 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/autotrace.c"
at_fitting_opts_type *at_fitting_opts_copy(at_fitting_opts_type *original ) 
{ 
  at_fitting_opts_type *new_opts ;
  at_fitting_opts_type *__cil_tmp3 ;
  at_color *__cil_tmp4 ;

  {
#line 62
  if (original == (void *)0) {
#line 63
    return ((at_fitting_opts_type *)((void *)0));
  }
  {
#line 65
  new_opts = at_fitting_opts_new();
#line 66
  *new_opts = *original;
  }
#line 67
  if (original->background_color) {
    {
#line 68
    new_opts->background_color = at_color_copy(original->background_color);
    }
  }
#line 69
  return (new_opts);
}
}
#line 72 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/autotrace.c"
void at_fitting_opts_free(at_fitting_opts_type *opts ) 
{ 


  {
  {
#line 74
  free(opts->background_color);
#line 75
  free(opts);
  }
  return;
}
}
#line 78 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/autotrace.c"
at_input_opts_type *at_input_opts_new(void) 
{ 
  at_input_opts_type *opts ;
  void *__cil_tmp2 ;
  int tmp ;

  {
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 81
    __cil_tmp2 = malloc(sizeof(at_input_opts_type ));
#line 81
    opts = (gpointer )__cil_tmp2;
    }
#line 81
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  opts->background_color = (at_color *)((void *)0);
#line 83
  opts->charcode = (unsigned int )0;
#line 84
  return (opts);
}
}
#line 87 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/autotrace.c"
at_input_opts_type *at_input_opts_copy(at_input_opts_type *original ) 
{ 
  at_input_opts_type *opts ;
  at_input_opts_type *__cil_tmp3 ;
  at_color *__cil_tmp4 ;

  {
  {
#line 90
  opts = at_input_opts_new();
#line 91
  *opts = *original;
  }
#line 92
  if (original->background_color) {
    {
#line 93
    opts->background_color = at_color_copy(original->background_color);
    }
  }
#line 94
  return (opts);
}
}
#line 97 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/autotrace.c"
void at_input_opts_free(at_input_opts_type *opts ) 
{ 


  {
  {
#line 99
  free(opts->background_color);
#line 100
  free(opts);
  }
  return;
}
}
#line 103 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/autotrace.c"
at_output_opts_type *at_output_opts_new(void) 
{ 
  at_output_opts_type *opts ;
  void *__cil_tmp2 ;
  int tmp ;

  {
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 106
    __cil_tmp2 = malloc(sizeof(at_output_opts_type ));
#line 106
    opts = (gpointer )__cil_tmp2;
    }
#line 106
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 107
  opts->dpi = 72;
#line 108
  return (opts);
}
}
#line 111 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/autotrace.c"
at_output_opts_type *at_output_opts_copy(at_output_opts_type *original ) 
{ 
  at_output_opts_type *opts ;
  at_output_opts_type *__cil_tmp3 ;

  {
  {
#line 113
  __cil_tmp3 = at_output_opts_new();
#line 113
  opts = __cil_tmp3;
#line 114
  *opts = *original;
  }
#line 115
  return (opts);
}
}
#line 118 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/autotrace.c"
void at_output_opts_free(at_output_opts_type *opts ) 
{ 


  {
  {
#line 120
  free(opts);
  }
  return;
}
}
#line 123 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/autotrace.c"
at_bitmap *at_bitmap_read(at_bitmap_reader *reader , gchar *filename , at_input_opts_type *opts ,
                          at_msg_func msg_func , gpointer msg_data ) 
{ 
  gboolean new_opts ;
  at_bitmap *bitmap ;
  void *__cil_tmp8 ;
  int tmp ;
  at_input_opts_type *__cil_tmp10 ;
  at_bitmap __cil_tmp11 ;

  {
#line 125
  new_opts = 0;
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 127
    __cil_tmp8 = malloc(sizeof(at_bitmap ));
#line 127
    bitmap = (gpointer )__cil_tmp8;
    }
#line 127
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 128
  if (opts == (void *)0) {
    {
#line 129
    opts = at_input_opts_new();
#line 130
    new_opts = ! 0;
    }
  }
  {
#line 132
  *bitmap = input_bmp_reader(filename, opts, msg_func, msg_data, reader->data);
  }
#line 133
  if (new_opts) {
    {
#line 134
    at_input_opts_free(opts);
    }
  }
#line 135
  return (bitmap);
}
}
#line 138 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/autotrace.c"
at_bitmap *at_bitmap_new(unsigned short width , unsigned short height , unsigned int planes ) 
{ 
  at_bitmap *bitmap ;
  void *__cil_tmp5 ;
  int tmp ;
  at_bitmap __cil_tmp7 ;

  {
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 141
    __cil_tmp5 = malloc(sizeof(at_bitmap ));
#line 141
    bitmap = (gpointer )__cil_tmp5;
    }
#line 141
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 142
  *bitmap = at_bitmap_init((unsigned char *)((void *)0), width, height, planes);
  }
#line 143
  return (bitmap);
}
}
#line 146 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/autotrace.c"
at_bitmap *at_bitmap_copy(at_bitmap *src ) 
{ 
  at_bitmap *dist ;
  unsigned short width ;
  unsigned short height ;
  unsigned short planes ;
  unsigned short __cil_tmp6 ;
  unsigned short __cil_tmp7 ;
  unsigned short __cil_tmp8 ;
  at_bitmap *__cil_tmp9 ;

  {
  {
#line 151
  width = at_bitmap_get_width(src);
#line 152
  height = at_bitmap_get_height(src);
#line 153
  planes = at_bitmap_get_planes(src);
#line 155
  dist = at_bitmap_new(width, height, (unsigned int )planes);
#line 156
  memcpy(dist->bitmap, src->bitmap, (unsigned long )(((int )width * (int )height) * (int )planes) * sizeof(unsigned char ));
  }
#line 157
  return (dist);
}
}
#line 160 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/autotrace.c"
at_bitmap at_bitmap_init(unsigned char *area , unsigned short width , unsigned short height ,
                         unsigned int planes ) 
{ 
  at_bitmap bitmap ;
  void *__cil_tmp6 ;
  int tmp ;

  {
#line 164
  if (area) {
#line 165
    bitmap.bitmap = area;
  } else
#line 167
  if (0 == (int )width * (int )height) {
#line 168
    bitmap.bitmap = (unsigned char *)((void *)0);
  } else {
    {
#line 170
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 170
      __cil_tmp6 = calloc((unsigned long )((unsigned int )((int )width * (int )height) * planes) * sizeof(unsigned char ),
                          (unsigned long )1);
#line 170
      bitmap.bitmap = (gpointer )__cil_tmp6;
      }
#line 170
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 173
  bitmap.width = width;
#line 174
  bitmap.height = height;
#line 175
  bitmap.np = planes;
#line 176
  return (bitmap);
}
}
#line 179 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/autotrace.c"
void at_bitmap_free(at_bitmap *bitmap ) 
{ 


  {
  {
#line 181
  free(bitmap->bitmap);
#line 182
  free(bitmap);
  }
  return;
}
}
#line 185 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/autotrace.c"
unsigned short at_bitmap_get_width(at_bitmap *bitmap ) 
{ 


  {
#line 187
  return (bitmap->width);
}
}
#line 190 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/autotrace.c"
unsigned short at_bitmap_get_height(at_bitmap *bitmap ) 
{ 


  {
#line 192
  return (bitmap->height);
}
}
#line 195 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/autotrace.c"
unsigned short at_bitmap_get_planes(at_bitmap *bitmap ) 
{ 


  {
#line 199
  return ((unsigned short )bitmap->np);
}
}
#line 202 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/autotrace.c"
void at_bitmap_get_color(at_bitmap *bitmap , unsigned int row , unsigned int col ,
                         at_color *color ) 
{ 
  unsigned char *p ;
  long __cil_tmp6 ;
  long __cil_tmp7 ;
  unsigned short __cil_tmp8 ;

  {
  {
#line 205
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 205
    __cil_tmp6 = __builtin_expect((long )0, (long )1);
    }
#line 205
    if (! __cil_tmp6) {
      {
#line 205
      g_return_if_fail_warning((char const   *)((gchar *)0), (char const   *)"at_bitmap_get_color",
                               "color");
      }
#line 205
      return;
    }
#line 205
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 206
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 206
    __cil_tmp7 = __builtin_expect((long )0, (long )1);
    }
#line 206
    if (! __cil_tmp7) {
      {
#line 206
      g_return_if_fail_warning((char const   *)((gchar *)0), (char const   *)"at_bitmap_get_color",
                               "bitmap");
      }
#line 206
      return;
    }
#line 206
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 208
  p = (bitmap->bitmap + (row * bitmap->np) * (unsigned int )bitmap->width) + col * bitmap->np;
#line 209
  __cil_tmp8 = at_bitmap_get_planes(bitmap);
  }
#line 209
  if ((int )__cil_tmp8 >= 3) {
    {
#line 210
    at_color_set(color, *(p + 0), *(p + 1), *(p + 2));
    }
  } else {
    {
#line 212
    at_color_set(color, *(p + 0), *(p + 0), *(p + 0));
    }
  }
  return;
}
}
#line 215 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/autotrace.c"
gboolean at_bitmap_equal_color(at_bitmap *bitmap , unsigned int row , unsigned int col ,
                               at_color *color ) 
{ 
  at_color c ;
  long __cil_tmp6 ;
  long __cil_tmp7 ;
  gboolean __cil_tmp8 ;

  {
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 219
    __cil_tmp6 = __builtin_expect((long )0, (long )1);
    }
#line 219
    if (! __cil_tmp6) {
      {
#line 219
      g_return_if_fail_warning((char const   *)((gchar *)0), (char const   *)"at_bitmap_equal_color",
                               "bitmap");
      }
#line 219
      return (0);
    }
#line 219
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 220
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 220
    __cil_tmp7 = __builtin_expect((long )0, (long )1);
    }
#line 220
    if (! __cil_tmp7) {
      {
#line 220
      g_return_if_fail_warning((char const   *)((gchar *)0), (char const   *)"at_bitmap_equal_color",
                               "color");
      }
#line 220
      return (0);
    }
#line 220
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 222
  at_bitmap_get_color(bitmap, row, col, & c);
#line 223
  __cil_tmp8 = at_color_equal(& c, color);
  }
#line 223
  return (__cil_tmp8);
}
}
#line 226 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/autotrace.c"
at_spline_list_array_type *at_splines_new(at_bitmap *bitmap , at_fitting_opts_type *opts ,
                                          at_msg_func msg_func , gpointer msg_data ) 
{ 
  at_spline_list_array_type *__cil_tmp5 ;

  {
  {
#line 228
  __cil_tmp5 = at_splines_new_full(bitmap, opts, msg_func, msg_data, (at_progress_func )((void *)0),
                                   (void *)0, (at_testcancel_func )((void *)0), (void *)0);
  }
#line 228
  return (__cil_tmp5);
}
}
#line 233 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/autotrace.c"
at_spline_list_array_type *at_splines_new_full(at_bitmap *bitmap , at_fitting_opts_type *opts ,
                                               at_msg_func msg_func , gpointer msg_data ,
                                               at_progress_func notify_progress ,
                                               gpointer progress_data , at_testcancel_func test_cancel ,
                                               gpointer testcancel_data ) 
{ 
  image_header_type image_header ;
  at_spline_list_array_type *splines ;
  pixel_outline_list_type pixels ;
  QuantizeObj *myQuant ;
  at_exception_type exp___0 ;
  at_exception_type __cil_tmp14 ;
  at_distance_map dist_map ;
  at_distance_map *dist ;
  gboolean __cil_tmp17 ;
  unsigned short __cil_tmp18 ;
  unsigned short __cil_tmp19 ;
  gboolean __cil_tmp20 ;
  at_distance_map __cil_tmp21 ;
  gboolean __cil_tmp22 ;
  gboolean __cil_tmp23 ;
  at_color background_color ;
  pixel_outline_list_type __cil_tmp25 ;
  pixel_outline_list_type __cil_tmp26 ;
  gboolean __cil_tmp27 ;
  gboolean __cil_tmp28 ;
  void *__cil_tmp29 ;
  int tmp ;
  at_spline_list_array_type __cil_tmp31 ;
  gboolean __cil_tmp32 ;
  gboolean __cil_tmp33 ;

  {
  {
#line 236
  splines = (at_spline_list_array_type *)((void *)0);
#line 238
  myQuant = (QuantizeObj *)((void *)0);
#line 239
  __cil_tmp14 = at_exception_new(msg_func, msg_data);
#line 239
  exp___0 = __cil_tmp14;
#line 240
  dist = (at_distance_map *)((void *)0);
  }
#line 253
  if (opts->despeckle_level > 0U) {
    {
#line 254
    despeckle(bitmap, (int )opts->despeckle_level, opts->despeckle_tightness, opts->noise_removal,
              & exp___0);
#line 255
    __cil_tmp17 = at_exception_got_fatal(& exp___0);
    }
#line 255
    if (__cil_tmp17) {
#line 255
      return (splines);
    }

  }
  {
#line 258
  image_header.width = at_bitmap_get_width(bitmap);
#line 259
  image_header.height = at_bitmap_get_height(bitmap);
  }
#line 261
  if (opts->color_count > 0U) {
    {
#line 262
    quantize(bitmap, (long )opts->color_count, opts->background_color, & myQuant,
             & exp___0);
    }
#line 263
    if (myQuant) {
      {
#line 264
      quantize_object_free(myQuant);
      }
    }
    {
#line 265
    __cil_tmp20 = at_exception_got_fatal(& exp___0);
    }
#line 265
    if (__cil_tmp20) {
#line 265
      return (splines);
    }

  }
#line 268
  if (opts->centerline) {
#line 269
    if (opts->preserve_width) {
      {
#line 271
      dist_map = new_distance_map(bitmap, (unsigned char )255, ! 0, & exp___0);
#line 272
      dist = & dist_map;
#line 273
      __cil_tmp22 = at_exception_got_fatal(& exp___0);
      }
#line 273
      if (__cil_tmp22) {
#line 273
        return (splines);
      }

    }
    {
#line 278
    thin_image(bitmap, opts->background_color, & exp___0);
#line 279
    __cil_tmp23 = at_exception_got_fatal(& exp___0);
    }
#line 279
    if (__cil_tmp23) {
#line 279
      goto cleanup_dist;
    }
  }
#line 284
  if (opts->centerline) {
#line 285
    background_color.r = (guint8 )255;
#line 285
    background_color.g = (guint8 )255;
#line 285
    background_color.b = (guint8 )255;
#line 286
    if (opts->background_color) {
#line 287
      background_color = *(opts->background_color);
    }
    {
#line 289
    pixels = find_centerline_pixels(bitmap, background_color, notify_progress, progress_data,
                                    test_cancel, testcancel_data, & exp___0);
    }
  } else {
    {
#line 291
    pixels = find_outline_pixels(bitmap, opts->background_color, notify_progress,
                                 progress_data, test_cancel, testcancel_data, & exp___0);
    }
  }
  {
#line 292
  __cil_tmp27 = at_exception_got_fatal(& exp___0);
  }
#line 292
  if (__cil_tmp27) {
#line 292
    goto cleanup_dist;
  }
  {
#line 293
  __cil_tmp28 = (*test_cancel)(testcancel_data);
  }
#line 293
  if (test_cancel) {
#line 293
    if (__cil_tmp28) {
#line 293
      goto cleanup_dist;
    }
  }

  {
#line 295
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 295
    __cil_tmp29 = malloc(sizeof(at_spline_list_array_type ));
#line 295
    splines = (gpointer )__cil_tmp29;
    }
#line 295
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 296
  *splines = fitted_splines(pixels, opts, dist, image_header.width, image_header.height,
                            & exp___0, notify_progress, progress_data, test_cancel,
                            testcancel_data);
#line 297
  __cil_tmp32 = at_exception_got_fatal(& exp___0);
  }
#line 297
  if (__cil_tmp32) {
    {
#line 297
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 297
      if (splines) {
        {
#line 297
        at_splines_free(splines);
#line 297
        splines = (at_spline_list_array_type *)((void *)0);
        }
      }
#line 297
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 297
    goto cleanup_pixels;
  }
  {
#line 298
  __cil_tmp33 = (*test_cancel)(testcancel_data);
  }
#line 298
  if (test_cancel) {
#line 298
    if (__cil_tmp33) {
      {
#line 298
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 298
        if (splines) {
          {
#line 298
          at_splines_free(splines);
#line 298
          splines = (at_spline_list_array_type *)((void *)0);
          }
        }
#line 298
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 298
      goto cleanup_pixels;
    }
  }

#line 300
  if (notify_progress) {
    {
#line 301
    (*notify_progress)((gfloat )1., progress_data);
    }
  }
  cleanup_pixels: 
  {
#line 304
  free_pixel_outline_list(& pixels);
  }
  cleanup_dist: 
#line 306
  if (dist) {
    {
#line 307
    free_distance_map(dist);
    }
  }
#line 308
  return (splines);
}
}
#line 321 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/autotrace.c"
void at_splines_write(at_spline_writer *writer , FILE *writeto , gchar *file_name ,
                      at_output_opts_type *opts , at_spline_list_array_type *splines ,
                      at_msg_func msg_func , gpointer msg_data ) 
{ 
  gboolean new_opts ;
  int llx ;
  int lly ;
  int urx ;
  int ury ;
  at_output_opts_type *__cil_tmp13 ;

  {
#line 323
  new_opts = 0;
#line 325
  llx = 0;
#line 326
  lly = 0;
#line 327
  urx = (int )splines->width;
#line 328
  ury = (int )splines->height;
#line 330
  if (! file_name) {
#line 331
    file_name = "\220";
  }
#line 333
  if (opts == (void *)0) {
    {
#line 334
    new_opts = ! 0;
#line 335
    opts = at_output_opts_new();
    }
  }
  {
#line 338
  setlocale(1, "C");
#line 339
  (*(writer->func))(writeto, file_name, llx, lly, urx, ury, opts, *splines, msg_func,
                    msg_data, writer->data);
  }
#line 340
  if (new_opts) {
    {
#line 341
    at_output_opts_free(opts);
    }
  }
  return;
}
}
#line 344 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/autotrace.c"
void at_splines_free(at_spline_list_array_type *splines ) 
{ 


  {
  {
#line 346
  free_spline_list_array(splines);
  }
#line 347
  if (splines->background_color) {
    {
#line 348
    at_color_free(splines->background_color);
    }
  }
  {
#line 349
  free(splines);
  }
  return;
}
}
#line 352 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/autotrace.c"
char const   *at_version(gboolean long_format ) 
{ 


  {
#line 354
  if (long_format) {
#line 355
    return ("AutoTrace version 0.40.0");
  }
#line 357
  return ("0.40.0");
}
}
#line 360 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/autotrace.c"
char const   *at_home_site(void) 
{ 


  {
#line 362
  return ("https://github.com/autotrace/autotrace");
}
}
#line 365 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/autotrace.c"
void autotrace_init(void) 
{ 
  static int initialized ;

  {
#line 367
  initialized = 0;
#line 368
  if (! initialized) {
    {
#line 370
    setlocale(6, "\220");
#line 371
    bindtextdomain("autotrace", "/usr/local/share/locale");
#line 375
    at_input_init();
#line 376
    at_output_init();
#line 377
    at_module_init();
#line 379
    initialized = 1;
    }
  }
  return;
}
}
#line 383 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/autotrace.c"
char const   *at_fitting_opts_doc_func(char *string ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 385
  __cil_tmp2 = dcgettext("autotrace", (char const   *)string, 5);
  }
#line 385
  return ((char const   *)__cil_tmp2);
}
}
#line 5 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/datetime.c"
char *at_time_string(void) 
{ 
  char *time_string ;
  void *__cil_tmp2 ;
  time_t t ;
  time_t __cil_tmp4 ;
  struct tm newtime ;

  {
  {
#line 7
  __cil_tmp2 = calloc(sizeof(char ), (unsigned long )25);
#line 7
  time_string = __cil_tmp2;
#line 8
  __cil_tmp4 = time((time_t *)((void *)0));
#line 8
  t = __cil_tmp4;
#line 12
  localtime_r(& t, & newtime);
#line 13
  strftime(time_string, (size_t )25, "%c", & newtime);
  }
#line 19
  return (time_string);
}
}
#line 32 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/color.c"
at_color *at_color_new(unsigned char r , unsigned char g , unsigned char b ) 
{ 
  at_color *color ;

  {
#line 35
  color = (at_color *)0;
#line 36
  color->r = r;
#line 37
  color->g = g;
#line 38
  color->b = b;
#line 39
  return (color);
}
}
#line 42 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/color.c"
at_color *at_color_parse(gchar *string , GError **err ) 
{ 
  GError *local_err ;
  unsigned char c[6] ;
  int i ;
  unsigned long __cil_tmp6 ;
  GQuark __cil_tmp7 ;
  char *__cil_tmp8 ;
  char ch ;
  GQuark __cil_tmp10 ;
  char *__cil_tmp11 ;
  int __cil_tmp12 ;
  at_color *__cil_tmp13 ;

  {
#line 44
  local_err = (GError *)((void *)0);
#line 48
  if (! string) {
#line 49
    return ((at_color *)((void *)0));
  } else
#line 50
  if ((int )*(string + 0) == 0) {
#line 51
    return ((at_color *)((void *)0));
  } else {
    {
#line 52
    __cil_tmp6 = strlen(string);
    }
#line 52
    if (__cil_tmp6 != 6UL) {
      {
#line 53
      __cil_tmp7 = at_error_quark();
      }
      {
#line 53
      __cil_tmp8 = dcgettext("autotrace\234\311\b\027V", "color string is too short: %sV",
                             5);
#line 53
      g_set_error(err, __cil_tmp7, 0, __cil_tmp8, string);
      }
#line 54
      return ((at_color *)((void *)0));
    }
  }
#line 57
  i = 0;
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    if (! (i < 6)) {
#line 57
      goto while_break;
    }
#line 58
    ch = *(string + i);
#line 59
    if ((int )ch >= 48) {
#line 59
      if ((int )ch <= 57) {
#line 60
        c[i] = (unsigned char )((int )ch - 48);
      } else {
#line 59
        goto _L___20;
      }
    } else
    _L___20: /* CIL Label */ 
#line 61
    if ((int )ch >= 65) {
#line 61
      if ((int )ch <= 70) {
#line 62
        c[i] = (unsigned char )(((int )ch - 65) + 10);
      } else {
#line 61
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 63
    if ((int )ch >= 97) {
#line 63
      if ((int )ch <= 102) {
#line 64
        c[i] = (unsigned char )(((int )ch - 97) + 10);
      } else {
        {
        {
#line 66
        __cil_tmp10 = at_error_quark();
        }
        }
        {
        {
#line 66
        __cil_tmp11 = dcgettext("autotrace", "wrong char in color string: %c", 5);
        }
        {
#line 66
        g_set_error(& local_err, __cil_tmp10, 0, __cil_tmp11, (int )*(string + i));
        }
        {
#line 67
        g_propagate_error(err, local_err);
        }
        }
#line 68
        return ((at_color *)((void *)0));
      }
    } else {
      {
      {
#line 66
      __cil_tmp10 = at_error_quark();
      }
      }
      {
      {
#line 66
      __cil_tmp11 = dcgettext("autotrace", "wrong char in color string: %c", 5);
      }
      {
#line 66
      g_set_error(& local_err, __cil_tmp10, 0, __cil_tmp11, (int )*(string + i));
      }
      {
#line 67
      g_propagate_error(err, local_err);
      }
      }
#line 68
      return ((at_color *)((void *)0));
    }
#line 57
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 71
  __cil_tmp13 = at_color_new((unsigned char )(16 * (int )c[0] + (int )c[1]), (unsigned char )(16 * (int )c[2] + (int )c[3]),
                             (unsigned char )(16 * (int )c[4] + (int )c[5]));
  }
#line 71
  return (__cil_tmp13);
}
}
#line 74 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/color.c"
at_color *at_color_copy(at_color *original ) 
{ 
  at_color *__cil_tmp2 ;

  {
#line 76
  if (original == (void *)0) {
#line 77
    return ((at_color *)((void *)0));
  }
  {
#line 79
  __cil_tmp2 = at_color_new(original->r, original->g, original->b);
  }
#line 79
  return (__cil_tmp2);
}
}
#line 82 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/color.c"
gboolean at_color_equal(at_color *c1 , at_color *c2 ) 
{ 


  {
#line 84
  if (c1 == c2) {
#line 85
    return (! 0);
  } else
#line 84
  if ((int )c1->r == (int )c2->r) {
#line 84
    if ((int )c1->g == (int )c2->g) {
#line 84
      if ((int )c1->b == (int )c2->b) {
#line 85
        return (! 0);
      }
    }
  }
#line 87
  return (0);
}
}
#line 90 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/color.c"
void at_color_set(at_color *c , unsigned char r , unsigned char g , unsigned char b ) 
{ 
  long __cil_tmp5 ;

  {
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 92
    __cil_tmp5 = __builtin_expect((long )0, (long )1);
    }
#line 92
    if (! __cil_tmp5) {
      {
#line 92
      g_return_if_fail_warning((char const   *)((gchar *)0), (char const   *)"at_color_set",
                               "c");
      }
#line 92
      return;
    }
#line 92
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  c->r = r;
#line 94
  c->g = g;
#line 95
  c->b = b;
  return;
}
}
#line 98 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/color.c"
unsigned char at_color_luminance(at_color *color ) 
{ 


  {
#line 100
  return ((unsigned char )((((double )((int )color->r) * 0.3 + (double )((int )color->g) * 0.59) + (double )((int )color->b) * 0.110000000001) + 0.5));
}
}
#line 103 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/color.c"
void at_color_free(at_color *color ) 
{ 


  {
  {
#line 105
  g_free(color);
  }
  return;
}
}
#line 108 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/color.c"
GType at_color_get_type(void) 
{ 
  static GType our_type ;
  GType __cil_tmp2 ;

  {
#line 110
  our_type = (GType )0;
#line 111
  if (our_type == 0UL) {
    {
#line 112
    our_type = g_boxed_type_register_static((gchar *)"AtColor", (GBoxedCopyFunc )(& at_color_copy),
                                            (GBoxedFreeFunc )(& at_color_free));
    }
  }
#line 113
  return (our_type);
}
}
#line 16 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/vector.h"
vector_type make_vector(at_real_coord c ) ;
#line 19
at_real_coord vector_to_point(vector_type v ) ;
#line 24
gfloat magnitude(vector_type v ) ;
#line 25
vector_type normalize(vector_type v ) ;
#line 27
vector_type Vadd(vector_type v1 , vector_type v2 ) ;
#line 28
gfloat Vdot(vector_type v1 , vector_type v2 ) ;
#line 29
vector_type Vmult_scalar(vector_type v , gfloat r ) ;
#line 30
gfloat Vangle(vector_type in_vector , vector_type out_vector , at_exception_type *exp___0 ) ;
#line 35
at_real_coord Vadd_point(at_real_coord c , vector_type v ) ;
#line 38
at_real_coord Vsubtract_point(at_real_coord c , vector_type v ) ;
#line 42
at_coord Vadd_int_point(at_coord c , vector_type v ) ;
#line 45
vector_type Vabs(vector_type v ) ;
#line 50
vector_type Psubtract(at_real_coord c1 , at_real_coord c2 ) ;
#line 53
at_real_coord Padd(at_real_coord coord1 , at_real_coord coord2 ) ;
#line 54
at_real_coord Pmult_scalar(at_real_coord coord , gfloat r ) ;
#line 58
vector_type IPsubtract(at_coord coord1 , at_coord coord2 ) ;
#line 59
at_coord IPsubtractP(at_coord c1 , at_coord c2 ) ;
#line 60
at_coord IPadd(at_coord c1 , at_coord c2 ) ;
#line 61
at_coord IPmult_scalar(at_coord c , int i ) ;
#line 62
at_real_coord IPmult_real(at_coord c , gfloat r ) ;
#line 63
gboolean IPequal(at_coord c1 , at_coord c2 ) ;
#line 14 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/epsilon-equal.h"
gboolean epsilon_equal(gfloat v1 , gfloat v2 ) ;
#line 15 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/vector.c"
static gfloat acos_d(gfloat v , at_exception_type *excep ) ;
#line 22 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/vector.c"
vector_type make_vector(at_real_coord c ) 
{ 
  vector_type v ;

  {
#line 26
  v.dx = c.x;
#line 27
  v.dy = c.y;
#line 28
  v.dz = c.z;
#line 30
  return (v);
}
}
#line 35 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/vector.c"
at_real_coord vector_to_point(vector_type v ) 
{ 
  at_real_coord coord ;

  {
#line 39
  coord.x = v.dx;
#line 40
  coord.y = v.dy;
#line 42
  return (coord);
}
}
#line 45 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/vector.c"
gfloat magnitude(vector_type v ) 
{ 
  double __cil_tmp2 ;

  {
  {
#line 47
  __cil_tmp2 = sqrt((double )((v.dx * v.dx + v.dy * v.dy) + v.dz * v.dz));
  }
#line 47
  return ((gfloat )__cil_tmp2);
}
}
#line 50 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/vector.c"
vector_type normalize(vector_type v ) 
{ 
  vector_type new_v ;
  gfloat m ;
  gfloat __cil_tmp4 ;

  {
  {
#line 53
  __cil_tmp4 = magnitude(v);
#line 53
  m = __cil_tmp4;
  }
#line 57
  if ((double )m > 0.) {
#line 58
    new_v.dx = v.dx / m;
#line 59
    new_v.dy = v.dy / m;
#line 60
    new_v.dz = v.dz / m;
  } else {
#line 62
    new_v.dx = v.dx;
#line 63
    new_v.dy = v.dy;
#line 64
    new_v.dz = v.dz;
  }
#line 67
  return (new_v);
}
}
#line 70 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/vector.c"
vector_type Vadd(vector_type v1 , vector_type v2 ) 
{ 
  vector_type new_v ;

  {
#line 74
  new_v.dx = v1.dx + v2.dx;
#line 75
  new_v.dy = v1.dy + v2.dy;
#line 76
  new_v.dz = v1.dz + v2.dz;
#line 78
  return (new_v);
}
}
#line 81 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/vector.c"
gfloat Vdot(vector_type v1 , vector_type v2 ) 
{ 


  {
#line 83
  return ((v1.dx * v2.dx + v1.dy * v2.dy) + v1.dz * v2.dz);
}
}
#line 86 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/vector.c"
vector_type Vmult_scalar(vector_type v , gfloat r ) 
{ 
  vector_type new_v ;

  {
#line 90
  new_v.dx = v.dx * r;
#line 91
  new_v.dy = v.dy * r;
#line 92
  new_v.dz = v.dz * r;
#line 94
  return (new_v);
}
}
#line 100 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/vector.c"
gfloat Vangle(vector_type in_vector , vector_type out_vector , at_exception_type *exp___0 ) 
{ 
  vector_type v1 ;
  vector_type __cil_tmp5 ;
  vector_type v2 ;
  vector_type __cil_tmp7 ;
  gfloat __cil_tmp8 ;
  gfloat __cil_tmp9 ;

  {
  {
#line 102
  __cil_tmp5 = normalize(in_vector);
#line 102
  v1 = __cil_tmp5;
#line 103
  __cil_tmp7 = normalize(out_vector);
#line 103
  v2 = __cil_tmp7;
#line 105
  __cil_tmp8 = Vdot(v2, v1);
#line 105
  __cil_tmp9 = acos_d(__cil_tmp8, exp___0);
  }
#line 105
  return (__cil_tmp9);
}
}
#line 108 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/vector.c"
at_real_coord Vadd_point(at_real_coord c , vector_type v ) 
{ 
  at_real_coord new_c ;

  {
#line 112
  new_c.x = c.x + v.dx;
#line 113
  new_c.y = c.y + v.dy;
#line 114
  new_c.z = c.z + v.dz;
#line 115
  return (new_c);
}
}
#line 118 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/vector.c"
at_real_coord Vsubtract_point(at_real_coord c , vector_type v ) 
{ 
  at_real_coord new_c ;

  {
#line 122
  new_c.x = c.x - v.dx;
#line 123
  new_c.y = c.y - v.dy;
#line 124
  new_c.z = c.z - v.dz;
#line 125
  return (new_c);
}
}
#line 128 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/vector.c"
at_coord Vadd_int_point(at_coord c , vector_type v ) 
{ 
  at_coord a ;
  long __cil_tmp4 ;
  long __cil_tmp5 ;

  {
  {
#line 132
  __cil_tmp4 = lround((double )((gfloat )c.x + v.dx));
#line 132
  a.x = (unsigned short )__cil_tmp4;
#line 133
  __cil_tmp5 = lround((double )((gfloat )c.y + v.dy));
#line 133
  a.y = (unsigned short )__cil_tmp5;
  }
#line 134
  return (a);
}
}
#line 137 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/vector.c"
vector_type Vabs(vector_type v ) 
{ 
  vector_type new_v ;
  double __cil_tmp3 ;
  double __cil_tmp4 ;
  double __cil_tmp5 ;

  {
  {
#line 141
  __cil_tmp3 = fabs((double )v.dx);
#line 141
  new_v.dx = (gfloat )__cil_tmp3;
#line 142
  __cil_tmp4 = fabs((double )v.dy);
#line 142
  new_v.dy = (gfloat )__cil_tmp4;
#line 143
  __cil_tmp5 = fabs((double )v.dz);
#line 143
  new_v.dz = (gfloat )__cil_tmp5;
  }
#line 144
  return (new_v);
}
}
#line 149 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/vector.c"
at_real_coord Padd(at_real_coord coord1 , at_real_coord coord2 ) 
{ 
  at_real_coord sum ;

  {
#line 153
  sum.x = coord1.x + coord2.x;
#line 154
  sum.y = coord1.y + coord2.y;
#line 155
  sum.z = coord1.z + coord2.z;
#line 157
  return (sum);
}
}
#line 160 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/vector.c"
at_real_coord Pmult_scalar(at_real_coord coord , gfloat r ) 
{ 
  at_real_coord answer ;

  {
#line 164
  answer.x = coord.x * r;
#line 165
  answer.y = coord.y * r;
#line 166
  answer.z = coord.z * r;
#line 168
  return (answer);
}
}
#line 171 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/vector.c"
vector_type Psubtract(at_real_coord c1 , at_real_coord c2 ) 
{ 
  vector_type v ;

  {
#line 175
  v.dx = c1.x - c2.x;
#line 176
  v.dy = c1.y - c2.y;
#line 177
  v.dz = c1.z - c2.z;
#line 179
  return (v);
}
}
#line 184 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/vector.c"
vector_type IPsubtract(at_coord coord1 , at_coord coord2 ) 
{ 
  vector_type v ;

  {
#line 188
  v.dx = (gfloat )((int )coord1.x - (int )coord2.x);
#line 189
  v.dy = (gfloat )((int )coord1.y - (int )coord2.y);
#line 190
  v.dz = (gfloat )0.;
#line 192
  return (v);
}
}
#line 195 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/vector.c"
at_coord IPsubtractP(at_coord c1 , at_coord c2 ) 
{ 
  at_coord c ;

  {
#line 199
  c.x = (gushort )((int )c1.x - (int )c2.x);
#line 200
  c.y = (gushort )((int )c1.y - (int )c2.y);
#line 202
  return (c);
}
}
#line 205 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/vector.c"
at_coord IPadd(at_coord c1 , at_coord c2 ) 
{ 
  at_coord c ;

  {
#line 209
  c.x = (gushort )((int )c1.x + (int )c2.x);
#line 210
  c.y = (gushort )((int )c1.y + (int )c2.y);
#line 212
  return (c);
}
}
#line 215 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/vector.c"
at_coord IPmult_scalar(at_coord c , int i ) 
{ 
  at_coord a ;

  {
#line 219
  a.x = (unsigned short )((int )c.x * i);
#line 220
  a.y = (unsigned short )((int )c.y * i);
#line 222
  return (a);
}
}
#line 225 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/vector.c"
at_real_coord IPmult_real(at_coord c , gfloat r ) 
{ 
  at_real_coord a ;

  {
#line 229
  a.x = (float )((int )c.x) * r;
#line 230
  a.y = (float )((int )c.y) * r;
#line 232
  return (a);
}
}
#line 235 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/vector.c"
gboolean IPequal(at_coord c1 , at_coord c2 ) 
{ 


  {
#line 237
  if ((int )c1.x == (int )c2.x) {
#line 237
    if ((int )c1.y == (int )c2.y) {
#line 238
      return (! 0);
    } else {
#line 240
      return (0);
    }
  } else {
#line 240
    return (0);
  }
}
}
#line 243 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/vector.c"
static gfloat acos_d(gfloat v , at_exception_type *excep ) 
{ 
  gfloat a ;
  gboolean __cil_tmp4 ;
  gboolean __cil_tmp5 ;
  int *__cil_tmp6 ;
  double __cil_tmp7 ;
  int *__cil_tmp8 ;
  int *__cil_tmp9 ;
  int *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 247
  __cil_tmp4 = epsilon_equal(v, (gfloat )1.);
  }
#line 247
  if (__cil_tmp4) {
#line 248
    v = (gfloat )1.;
  } else {
    {
#line 249
    __cil_tmp5 = epsilon_equal(v, (gfloat )(- 1.));
    }
#line 249
    if (__cil_tmp5) {
#line 250
      v = (gfloat )(- 1.);
    }
  }
  {
#line 252
  __cil_tmp6 = __errno_location();
#line 252
  *__cil_tmp6 = 0;
#line 253
  __cil_tmp7 = acos((double )v);
#line 253
  a = (gfloat )__cil_tmp7;
#line 254
  __cil_tmp9 = __errno_location();
  }
  {
#line 254
  __cil_tmp8 = __errno_location();
  }
#line 254
  if (*__cil_tmp8 == 34) {
    {
    {
#line 255
    __cil_tmp10 = __errno_location();
    }
    {
#line 255
    __cil_tmp11 = strerror(*__cil_tmp10);
    }
    {
#line 255
    at_exception_fatal(excep, __cil_tmp11);
    }
    }
#line 256
    return ((gfloat )0.);
  } else
#line 254
  if (*__cil_tmp9 == 33) {
    {
    {
#line 255
    __cil_tmp10 = __errno_location();
    }
    {
#line 255
    __cil_tmp11 = strerror(*__cil_tmp10);
    }
    {
#line 255
    at_exception_fatal(excep, __cil_tmp11);
    }
    }
#line 256
    return ((gfloat )0.);
  }
#line 259
  return ((a * (gfloat )180.) / (gfloat )3.14159265359);
}
}
#line 15 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/epsilon-equal.c"
gboolean epsilon_equal(gfloat v1 , gfloat v2 ) 
{ 
  double __cil_tmp3 ;

  {
  {
#line 17
  __cil_tmp3 = fabs((double )(v1 - v2));
  }
#line 17
  if (v1 == v2) {
#line 19
    return (! 0);
  } else
#line 17
  if (__cil_tmp3 <= 1.00000000001e-05) {
#line 19
    return (! 0);
  }
#line 21
  return (0);
}
}
#line 808 "/usr/include/glib-2.0/gobject/gobject.h"
__inline static void g_assert_finalize_object___11(GObject *object ) 
{ 
  gpointer weak_pointer ;
  long __cil_tmp3 ;
  long __cil_tmp4 ;

  {
#line 810
  weak_pointer = object;
  {
#line 812
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 812
    __cil_tmp3 = __builtin_expect((long )0, (long )1);
    }
#line 812
    if (__cil_tmp3) {

    } else {
      {
#line 812
      g_assertion_message((char const   *)((gchar *)0), "/usr/include/glib-2.0/gobject/gobject.h",
                          812, (char const   *)"g_assert_finalize_object\312\001@",
                          "\'G_IS_OBJECT (weak_pointer)\' should be TRUE");
      }
    }
#line 812
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 813
  g_object_add_weak_pointer(object, & weak_pointer);
#line 814
  g_object_unref(weak_pointer);
  }
  {
#line 815
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 815
    __cil_tmp4 = __builtin_expect((long )0, (long )1);
    }
#line 815
    if (__cil_tmp4) {

    } else {
      {
#line 815
      g_assertion_message((char const   *)((gchar *)0), "/usr/include/glib-2.0/gobject/gobject.h",
                          815, (char const   *)"g_assert_finalize_object\312\001\300\t\360\257\b",
                          "\'weak_pointer\' should be NULLV");
      }
    }
#line 815
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 68 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/curve.h"
curve_type new_curve(void) ;
#line 71
curve_type copy_most_of_curve(curve_type old_curve ) ;
#line 74
void free_curve(curve_type curve ) ;
#line 77
void append_pixel(curve_type curve , at_coord coord ) ;
#line 80
void append_point(curve_type curve , at_real_coord coord ) ;
#line 84
void log_curve(curve_type curve , gboolean print_t ) ;
#line 85
void log_entire_curve(curve_type curve ) ;
#line 88
extern void display_curve(curve_type  ) ;
#line 109
curve_list_type new_curve_list(void) ;
#line 110
void free_curve_list(curve_list_type *curve_list ) ;
#line 111
void append_curve(curve_list_type *curve_list , curve_type curve ) ;
#line 127
curve_list_array_type new_curve_list_array(void) ;
#line 128
void free_curve_list_array(curve_list_array_type *curve_list_array , at_progress_func notify_progress ,
                           gpointer client_data ) ;
#line 129
void append_curve_list(curve_list_array_type *curve_list_array , curve_list_type curve_list ) ;
#line 29 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/curve.c"
static at_real_coord int_to_real_coord(at_coord int_coord ) ;
#line 33 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/curve.c"
curve_type new_curve(void) 
{ 
  curve_type curve ;
  void *__cil_tmp2 ;
  int tmp ;

  {
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 36
    __cil_tmp2 = malloc(sizeof(struct curve ));
#line 36
    curve = (gpointer )__cil_tmp2;
    }
#line 36
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 37
  curve->point_list = (point_type *)((void *)0);
#line 38
  curve->length = (unsigned int )0;
#line 39
  curve->cyclic = 0;
#line 40
  curve->end_tangent = (vector_type *)((void *)0);
#line 40
  curve->start_tangent = curve->end_tangent;
#line 41
  curve->next = (struct curve *)((void *)0);
#line 41
  curve->previous = curve->next;
#line 43
  return (curve);
}
}
#line 48 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/curve.c"
curve_type copy_most_of_curve(curve_type old_curve ) 
{ 
  curve_type curve ;
  curve_type __cil_tmp3 ;

  {
  {
#line 50
  __cil_tmp3 = new_curve();
#line 50
  curve = __cil_tmp3;
#line 52
  curve->cyclic = old_curve->cyclic;
#line 53
  curve->previous = old_curve->previous;
#line 54
  curve->next = old_curve->next;
  }
#line 56
  return (curve);
}
}
#line 63 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/curve.c"
void free_curve(curve_type curve ) 
{ 


  {
#line 65
  if (curve->length > 0U) {
    {
#line 66
    free(curve->point_list);
    }
  }
#line 67
  if (curve->start_tangent) {
    {
#line 68
    free(curve->start_tangent);
    }
  }
#line 69
  if (curve->end_tangent) {
    {
#line 70
    free(curve->end_tangent);
    }
  }
  return;
}
}
#line 73 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/curve.c"
void append_pixel(curve_type curve , at_coord coord ) 
{ 
  at_real_coord __cil_tmp3 ;

  {
  {
#line 75
  __cil_tmp3 = int_to_real_coord(coord);
#line 75
  append_point(curve, __cil_tmp3);
  }
  return;
}
}
#line 78 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/curve.c"
void append_point(curve_type curve , at_real_coord coord ) 
{ 
  unsigned int __cil_tmp3 ;
  gpointer new_mem ;
  void *__cil_tmp5 ;
  int tmp ;
  void *__cil_tmp7 ;
  int tmp___0 ;

  {
#line 80
  (curve->length) ++;
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    if (curve->point_list == (void *)0) {
      {
#line 81
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 81
        __cil_tmp5 = malloc((unsigned long )curve->length * sizeof(point_type ));
#line 81
        new_mem = (gpointer )__cil_tmp5;
        }
#line 81
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 81
      __cil_tmp7 = realloc(curve->point_list, (unsigned long )curve->length * sizeof(point_type ));
#line 81
      new_mem = (gpointer )__cil_tmp7;
      }
    }
#line 81
    curve->point_list = new_mem;
#line 81
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  (curve->point_list + (curve->length - 1U))->coord = coord;
  return;
}
}
#line 102 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/curve.c"
void log_curve(curve_type curve , gboolean print_t ) 
{ 
  unsigned int this_point ;
  unsigned int __cil_tmp4 ;
  unsigned int __cil_tmp5 ;
  unsigned int __cil_tmp6 ;

  {
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 106
    if (logging) {
      {
#line 106
      fprintf(stdout, "curve id = %lx:\n\230\001", (unsigned long )curve);
      }
    }
#line 106
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 107
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 107
    if (logging) {
      {
#line 107
      fprintf(stdout, "  length = %u.\n", curve->length);
      }
    }
#line 107
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 108
  if (curve->cyclic) {
    {
#line 109
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 109
      if (logging) {
        {
#line 109
        fprintf(stdout, "  cyclic.\n");
        }
      }
#line 109
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 113
  if (curve->start_tangent != (void *)0) {
    {
#line 114
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 114
      if (logging) {
        {
#line 114
        fprintf(stdout, "  tangents = (%.3f,%.3f) & (%.3f,%.3f).\n\230\001", (double )(curve->start_tangent)->dx,
                (double )(curve->start_tangent)->dy, (double )(curve->end_tangent)->dx,
                (double )(curve->end_tangent)->dy);
        }
      }
#line 114
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 116
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 116
    if (logging) {
      {
#line 116
      fprintf(stdout, "  ");
      }
    }
#line 116
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 119
  if (curve->length <= 6U) {
#line 120
    this_point = (unsigned int )0;
    {
#line 120
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 120
      if (! (this_point < curve->length)) {
#line 120
        goto while_break___4;
      }
      {
#line 121
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 121
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 121
          if (logging) {
            {
#line 121
            fprintf(stdout, "(%.3f,%.3f)", (double )(curve->point_list + this_point)->coord.x,
                    (double )(curve->point_list + this_point)->coord.y);
            }
          }
#line 121
          goto while_break___6;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 121
        if (print_t) {
          {
#line 121
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 121
            if (logging) {
              {
#line 121
              fprintf(stdout, "/%.2f", (double )(curve->point_list + this_point)->t);
              }
            }
#line 121
            goto while_break___7;
          }
          while_break___7: /* CIL Label */ ;
          }
        }
#line 121
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 122
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 122
        if (logging) {
          {
#line 122
          fprintf(stdout, " ");
          }
        }
#line 122
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 124
      if (this_point != curve->length - 1U) {
#line 124
        if ((this_point + 1U) % 3U == 0U) {
          {
#line 125
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 125
            if (logging) {
              {
#line 125
              fprintf(stdout, "\n  ");
              }
            }
#line 125
            goto while_break___9;
          }
          while_break___9: /* CIL Label */ ;
          }
        }
      }
#line 120
      this_point ++;
    }
    while_break___4: /* CIL Label */ ;
    }
  } else {
#line 128
    this_point = (unsigned int )0;
    {
#line 128
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 128
      if (! (this_point < 3U && this_point < curve->length)) {
#line 128
        goto while_break___10;
      }
      {
#line 129
      while (1) {
        while_continue___11: /* CIL Label */ ;
        {
#line 129
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 129
          if (logging) {
            {
#line 129
            fprintf(stdout, "(%.3f,%.3f)", (double )(curve->point_list + this_point)->coord.x,
                    (double )(curve->point_list + this_point)->coord.y);
            }
          }
#line 129
          goto while_break___12;
        }
        while_break___12: /* CIL Label */ ;
        }
#line 129
        if (print_t) {
          {
#line 129
          while (1) {
            while_continue___13: /* CIL Label */ ;
#line 129
            if (logging) {
              {
#line 129
              fprintf(stdout, "/%.2f", (double )(curve->point_list + this_point)->t);
              }
            }
#line 129
            goto while_break___13;
          }
          while_break___13: /* CIL Label */ ;
          }
        }
#line 129
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
      {
#line 130
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 130
        if (logging) {
          {
#line 130
          fprintf(stdout, " ");
          }
        }
#line 130
        goto while_break___14;
      }
      while_break___14: /* CIL Label */ ;
      }
#line 128
      this_point ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    {
#line 133
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 133
      if (logging) {
        {
#line 133
        fprintf(stdout, "...\n   ...");
        }
      }
#line 133
      goto while_break___15;
    }
    while_break___15: /* CIL Label */ ;
    }
#line 135
    this_point = curve->length - 3U;
    {
#line 135
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 135
      if (! (this_point < curve->length)) {
#line 135
        goto while_break___16;
      }
      {
#line 136
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 136
        if (logging) {
          {
#line 136
          fprintf(stdout, " ");
          }
        }
#line 136
        goto while_break___17;
      }
      while_break___17: /* CIL Label */ ;
      }
      {
#line 137
      while (1) {
        while_continue___18: /* CIL Label */ ;
        {
#line 137
        while (1) {
          while_continue___19: /* CIL Label */ ;
#line 137
          if (logging) {
            {
#line 137
            fprintf(stdout, "(%.3f,%.3f)", (double )(curve->point_list + this_point)->coord.x,
                    (double )(curve->point_list + this_point)->coord.y);
            }
          }
#line 137
          goto while_break___19;
        }
        while_break___19: /* CIL Label */ ;
        }
#line 137
        if (print_t) {
          {
#line 137
          while (1) {
            while_continue___20: /* CIL Label */ ;
#line 137
            if (logging) {
              {
#line 137
              fprintf(stdout, "/%.2f", (double )(curve->point_list + this_point)->t);
              }
            }
#line 137
            goto while_break___20;
          }
          while_break___20: /* CIL Label */ ;
          }
        }
#line 137
        goto while_break___18;
      }
      while_break___18: /* CIL Label */ ;
      }
#line 135
      this_point ++;
    }
    while_break___16: /* CIL Label */ ;
    }
  }
  {
#line 141
  while (1) {
    while_continue___21: /* CIL Label */ ;
#line 141
    if (logging) {
      {
#line 141
      fprintf(stdout, ".\n");
      }
    }
#line 141
    goto while_break___21;
  }
  while_break___21: /* CIL Label */ ;
  }
  return;
}
}
#line 146 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/curve.c"
void log_entire_curve(curve_type curve ) 
{ 
  unsigned int this_point ;
  unsigned int __cil_tmp3 ;

  {
  {
#line 150
  while (1) {
    while_continue: /* CIL Label */ ;
#line 150
    if (logging) {
      {
#line 150
      fprintf(stdout, "curve id = %lx:\n\230\001", (unsigned long )curve);
      }
    }
#line 150
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 151
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 151
    if (logging) {
      {
#line 151
      fprintf(stdout, "  length = %u.\n", curve->length);
      }
    }
#line 151
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 152
  if (curve->cyclic) {
    {
#line 153
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 153
      if (logging) {
        {
#line 153
        fprintf(stdout, "  cyclic.\n");
        }
      }
#line 153
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 157
  if (curve->start_tangent != (void *)0) {
    {
#line 158
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 158
      if (logging) {
        {
#line 158
        fprintf(stdout, "  tangents = (%.3f,%.3f) & (%.3f,%.3f).\n\230\001", (double )(curve->start_tangent)->dx,
                (double )(curve->start_tangent)->dy, (double )(curve->end_tangent)->dx,
                (double )(curve->end_tangent)->dy);
        }
      }
#line 158
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 160
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 160
    if (logging) {
      {
#line 160
      fprintf(stdout, " ");
      }
    }
#line 160
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 162
  this_point = (unsigned int )0;
  {
#line 162
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 162
    if (! (this_point < curve->length)) {
#line 162
      goto while_break___4;
    }
    {
#line 163
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 163
      if (logging) {
        {
#line 163
        fprintf(stdout, " ");
        }
      }
#line 163
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 164
    while (1) {
      while_continue___6: /* CIL Label */ ;
      {
#line 164
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 164
        if (logging) {
          {
#line 164
          fprintf(stdout, "(%.3f,%.3f)", (double )(curve->point_list + this_point)->coord.x,
                  (double )(curve->point_list + this_point)->coord.y);
          }
        }
#line 164
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 164
      if (! 0) {
        {
#line 164
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 164
          if (logging) {
            {
#line 164
            fprintf(stdout, "/%.2f", (double )(curve->point_list + this_point)->t);
            }
          }
#line 164
          goto while_break___8;
        }
        while_break___8: /* CIL Label */ ;
        }
      }
#line 164
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 162
    this_point ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 168
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 168
    if (logging) {
      {
#line 168
      fprintf(stdout, ".\n");
      }
    }
#line 168
    goto while_break___9;
  }
  while_break___9: /* CIL Label */ ;
  }
  return;
}
}
#line 173 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/curve.c"
curve_list_type new_curve_list(void) 
{ 
  curve_list_type curve_list ;

  {
#line 177
  curve_list.length = (unsigned int )0;
#line 178
  curve_list.data = (curve_type *)((void *)0);
#line 180
  return (curve_list);
}
}
#line 185 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/curve.c"
void free_curve_list(curve_list_type *curve_list ) 
{ 
  unsigned int this_curve ;
  unsigned int __cil_tmp3 ;

  {
#line 189
  this_curve = (unsigned int )0;
  {
#line 189
  while (1) {
    while_continue: /* CIL Label */ ;
#line 189
    if (! (this_curve < curve_list->length)) {
#line 189
      goto while_break;
    }
    {
#line 190
    free_curve(*(curve_list->data + this_curve));
#line 191
    free(*(curve_list->data + this_curve));
    }
#line 189
    this_curve ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 195
  free(curve_list->data);
  }
  return;
}
}
#line 200 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/curve.c"
void append_curve(curve_list_type *curve_list , curve_type curve ) 
{ 
  unsigned int __cil_tmp3 ;
  gpointer new_mem ;
  void *__cil_tmp5 ;
  int tmp ;
  void *__cil_tmp7 ;
  int tmp___0 ;

  {
#line 202
  (curve_list->length) ++;
  {
#line 203
  while (1) {
    while_continue: /* CIL Label */ ;
#line 203
    if (curve_list->data == (void *)0) {
      {
#line 203
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 203
        __cil_tmp5 = malloc((unsigned long )curve_list->length * sizeof(curve_type ));
#line 203
        new_mem = (gpointer )__cil_tmp5;
        }
#line 203
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 203
      __cil_tmp7 = realloc(curve_list->data, (unsigned long )curve_list->length * sizeof(curve_type ));
#line 203
      new_mem = (gpointer )__cil_tmp7;
      }
    }
#line 203
    curve_list->data = new_mem;
#line 203
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 204
  *(curve_list->data + (curve_list->length - 1U)) = curve;
  return;
}
}
#line 209 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/curve.c"
curve_list_array_type new_curve_list_array(void) 
{ 
  curve_list_array_type curve_list_array ;

  {
#line 213
  curve_list_array.length = (unsigned int )0;
#line 214
  curve_list_array.data = (curve_list_type *)((void *)0);
#line 216
  return (curve_list_array);
}
}
#line 221 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/curve.c"
void free_curve_list_array(curve_list_array_type *curve_list_array , at_progress_func notify_progress ,
                           gpointer client_data ) 
{ 
  unsigned int this_list ;
  unsigned int __cil_tmp5 ;

  {
#line 225
  this_list = (unsigned int )0;
  {
#line 225
  while (1) {
    while_continue: /* CIL Label */ ;
#line 225
    if (! (this_list < curve_list_array->length)) {
#line 225
      goto while_break;
    }
#line 226
    if (notify_progress) {
      {
#line 227
      (*notify_progress)((gfloat )this_list / ((float )curve_list_array->length * (gfloat )3.) + (gfloat )0.666000000001,
                         client_data);
      }
    }
    {
#line 228
    free_curve_list(curve_list_array->data + this_list);
    }
#line 225
    this_list ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 232
  free(curve_list_array->data);
  }
  return;
}
}
#line 237 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/curve.c"
void append_curve_list(curve_list_array_type *curve_list_array , curve_list_type curve_list ) 
{ 
  unsigned int __cil_tmp3 ;
  gpointer new_mem ;
  void *__cil_tmp5 ;
  int tmp ;
  void *__cil_tmp7 ;
  int tmp___0 ;

  {
#line 239
  (curve_list_array->length) ++;
  {
#line 240
  while (1) {
    while_continue: /* CIL Label */ ;
#line 240
    if (curve_list_array->data == (void *)0) {
      {
#line 240
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 240
        __cil_tmp5 = malloc((unsigned long )curve_list_array->length * sizeof(curve_list_type ));
#line 240
        new_mem = (gpointer )__cil_tmp5;
        }
#line 240
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 240
      __cil_tmp7 = realloc(curve_list_array->data, (unsigned long )curve_list_array->length * sizeof(curve_list_type ));
#line 240
      new_mem = (gpointer )__cil_tmp7;
      }
    }
#line 240
    curve_list_array->data = new_mem;
#line 240
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 241
  *(curve_list_array->data + (curve_list_array->length - 1U)) = curve_list;
  return;
}
}
#line 246 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/curve.c"
static at_real_coord int_to_real_coord(at_coord int_coord ) 
{ 
  at_real_coord real_coord ;

  {
#line 250
  real_coord.x = (gfloat )int_coord.x;
#line 251
  real_coord.y = (gfloat )int_coord.y;
#line 252
  real_coord.z = (gfloat )0.;
#line 254
  return (real_coord);
}
}
#line 808 "/usr/include/glib-2.0/gobject/gobject.h"
__inline static void g_assert_finalize_object___12(GObject *object ) 
{ 
  gpointer weak_pointer ;
  long __cil_tmp3 ;
  long __cil_tmp4 ;

  {
#line 810
  weak_pointer = object;
  {
#line 812
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 812
    __cil_tmp3 = __builtin_expect((long )0, (long )1);
    }
#line 812
    if (__cil_tmp3) {

    } else {
      {
#line 812
      g_assertion_message((char const   *)((gchar *)0), "/usr/include/glib-2.0/gobject/gobject.h",
                          812, (char const   *)"g_assert_finalize_object\312\001@",
                          "\'G_IS_OBJECT (weak_pointer)\' should be TRUE");
      }
    }
#line 812
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 813
  g_object_add_weak_pointer(object, & weak_pointer);
#line 814
  g_object_unref(weak_pointer);
  }
  {
#line 815
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 815
    __cil_tmp4 = __builtin_expect((long )0, (long )1);
    }
#line 815
    if (__cil_tmp4) {

    } else {
      {
#line 815
      g_assertion_message((char const   *)((gchar *)0), "/usr/include/glib-2.0/gobject/gobject.h",
                          815, (char const   *)"g_assert_finalize_object\312\001\300\t\236\257\b",
                          "\'weak_pointer\' should be NULLV");
      }
    }
#line 815
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 16 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/spline.c"
void print_spline(spline_type s ) 
{ 
  int tmp ;

  {
#line 20
  if ((unsigned int )s.degree == 1U) {
    {
#line 21
    fprintf(stdout, "(%.3f,%.3f)--(%.3f,%.3f).\n", (double )s.v[0].x, (double )s.v[0].y,
            (double )s.v[3].x, (double )s.v[3].y);
    }
  } else
#line 23
  if ((unsigned int )s.degree == 3U) {
    {
#line 24
    fprintf(stdout, "(%.3f,%.3f)..ctrls(%.3f,%.3f)&(%.3f,%.3f)..(%.3f,%.3f).\n\230\001",
            (double )s.v[0].x, (double )s.v[0].y, (double )s.v[1].x, (double )s.v[1].y,
            (double )s.v[2].x, (double )s.v[2].y, (double )s.v[3].x, (double )s.v[3].y);
    }
  }
  return;
}
}
#line 31 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/spline.c"
at_real_coord evaluate_spline(spline_type s , gfloat t ) 
{ 
  spline_type V[4] ;
  int i ;
  int j ;
  gfloat one_minus_t ;
  polynomial_degree degree ;
  int __cil_tmp8 ;
  at_real_coord t1 ;
  at_real_coord __cil_tmp10 ;
  at_real_coord t2 ;
  at_real_coord __cil_tmp12 ;
  at_real_coord temp ;
  at_real_coord __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;

  {
#line 35
  one_minus_t = (gfloat )1. - t;
#line 36
  degree = s.degree;
#line 38
  i = 0;
  {
#line 38
  while (1) {
    while_continue: /* CIL Label */ ;
#line 38
    if (! ((unsigned int )i <= (unsigned int )degree)) {
#line 38
      goto while_break;
    }
#line 39
    V[0].v[i].x = s.v[i].x;
#line 40
    V[0].v[i].y = s.v[i].y;
#line 41
    V[0].v[i].z = s.v[i].z;
#line 38
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 44
  j = 1;
  {
#line 44
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 44
    if (! ((unsigned int )j <= (unsigned int )degree)) {
#line 44
      goto while_break___0;
    }
#line 45
    i = 0;
    {
#line 45
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 45
      if (! ((unsigned int )i <= (unsigned int )degree - (unsigned int )j)) {
#line 45
        goto while_break___1;
      }
      {
#line 46
      __cil_tmp10 = Pmult_scalar(V[j - 1].v[i], one_minus_t);
#line 46
      t1 = __cil_tmp10;
#line 47
      __cil_tmp12 = Pmult_scalar(V[j - 1].v[i + 1], t);
#line 47
      t2 = __cil_tmp12;
#line 48
      __cil_tmp14 = Padd(t1, t2);
#line 48
      temp = __cil_tmp14;
#line 49
      V[j].v[i].x = temp.x;
#line 50
      V[j].v[i].y = temp.y;
#line 51
      V[j].v[i].z = temp.z;
      }
#line 45
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 44
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 54
  return (V[degree].v[0]);
}
}
#line 59 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/spline.c"
spline_list_type *new_spline_list(void) 
{ 
  spline_list_type *answer ;
  void *__cil_tmp2 ;
  int tmp ;
  spline_list_type __cil_tmp4 ;

  {
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 63
    __cil_tmp2 = malloc(sizeof(spline_list_type ));
#line 63
    answer = (gpointer )__cil_tmp2;
    }
#line 63
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 64
  *answer = empty_spline_list();
  }
#line 65
  return (answer);
}
}
#line 68 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/spline.c"
spline_list_type empty_spline_list(void) 
{ 
  spline_list_type answer ;

  {
#line 71
  answer.data = (at_spline_type *)((void *)0);
#line 72
  answer.length = (unsigned int )0;
#line 73
  return (answer);
}
}
#line 78 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/spline.c"
spline_list_type *new_spline_list_with_spline(spline_type spline ) 
{ 
  spline_list_type *answer ;
  spline_list_type *__cil_tmp3 ;
  void *__cil_tmp4 ;
  int tmp ;

  {
  {
#line 82
  answer = new_spline_list();
  }
  {
#line 83
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 83
    __cil_tmp4 = malloc(sizeof(spline_type ));
#line 83
    answer->data = (gpointer )__cil_tmp4;
    }
#line 83
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 84
  *(answer->data + 0) = spline;
#line 85
  answer->length = (unsigned int )1;
#line 87
  return (answer);
}
}
#line 94 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/spline.c"
void free_spline_list(spline_list_type spline_list ) 
{ 


  {
  {
#line 96
  free(spline_list.data);
  }
  return;
}
}
#line 101 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/spline.c"
void append_spline(spline_list_type *l , spline_type s ) 
{ 
  int tmp ;
  unsigned int __cil_tmp4 ;
  gpointer new_mem ;
  void *__cil_tmp6 ;
  int tmp___0 ;
  void *__cil_tmp8 ;
  int tmp___1 ;

  {
#line 105
  (l->length) ++;
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 106
    if (l->data == (void *)0) {
      {
#line 106
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 106
        __cil_tmp6 = malloc((unsigned long )l->length * sizeof(spline_type ));
#line 106
        new_mem = (gpointer )__cil_tmp6;
        }
#line 106
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 106
      __cil_tmp8 = realloc(l->data, (unsigned long )l->length * sizeof(spline_type ));
#line 106
      new_mem = (gpointer )__cil_tmp8;
      }
    }
#line 106
    l->data = new_mem;
#line 106
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 107
  *(l->data + (l->length - 1U)) = s;
  return;
}
}
#line 113 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/spline.c"
void concat_spline_lists(spline_list_type *s1 , spline_list_type s2 ) 
{ 
  unsigned int this_spline ;
  unsigned int new_length ;
  int tmp ;
  gpointer new_mem ;
  void *__cil_tmp7 ;
  int tmp___0 ;
  void *__cil_tmp9 ;
  int tmp___1 ;
  unsigned int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;

  {
#line 120
  new_length = s1->length + s2.length;
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;
#line 122
    if (s1->data == (void *)0) {
      {
#line 122
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 122
        __cil_tmp7 = malloc((unsigned long )new_length * sizeof(spline_type ));
#line 122
        new_mem = (gpointer )__cil_tmp7;
        }
#line 122
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 122
      __cil_tmp9 = realloc(s1->data, (unsigned long )new_length * sizeof(spline_type ));
#line 122
      new_mem = (gpointer )__cil_tmp9;
      }
    }
#line 122
    s1->data = new_mem;
#line 122
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 124
  this_spline = (unsigned int )0;
  {
#line 124
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 124
    if (! (this_spline < s2.length)) {
#line 124
      goto while_break___1;
    }
#line 125
    __cil_tmp11 = s1->length;
#line 125
    (s1->length) ++;
#line 125
    *(s1->data + __cil_tmp11) = *(s2.data + this_spline);
#line 124
    this_spline ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  return;
}
}
#line 131 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/spline.c"
at_spline_list_array_type new_spline_list_array(void) 
{ 
  at_spline_list_array_type answer ;

  {
#line 135
  answer.data = (at_spline_list_type *)((void *)0);
#line 136
  answer.length = (unsigned int )0;
#line 138
  return (answer);
}
}
#line 143 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/spline.c"
void free_spline_list_array(at_spline_list_array_type *spline_list_array ) 
{ 
  unsigned int this_list ;
  unsigned int __cil_tmp3 ;

  {
#line 147
  this_list = (unsigned int )0;
  {
#line 147
  while (1) {
    while_continue: /* CIL Label */ ;
#line 147
    if (! (this_list < spline_list_array->length)) {
#line 147
      goto while_break;
    }
    {
#line 148
    free_spline_list(*(spline_list_array->data + this_list));
    }
#line 147
    this_list ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 150
  free(spline_list_array->data);
  }
  return;
}
}
#line 155 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/spline.c"
void append_spline_list(at_spline_list_array_type *l , spline_list_type s ) 
{ 
  unsigned int __cil_tmp3 ;
  gpointer new_mem ;
  void *__cil_tmp5 ;
  int tmp ;
  void *__cil_tmp7 ;
  int tmp___0 ;

  {
#line 157
  (l->length) ++;
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 158
    if (l->data == (void *)0) {
      {
#line 158
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 158
        __cil_tmp5 = malloc((unsigned long )l->length * sizeof(spline_list_type ));
#line 158
        new_mem = (gpointer )__cil_tmp5;
        }
#line 158
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 158
      __cil_tmp7 = realloc(l->data, (unsigned long )l->length * sizeof(spline_list_type ));
#line 158
      new_mem = (gpointer )__cil_tmp7;
      }
    }
#line 158
    l->data = new_mem;
#line 158
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 159
  *(l->data + (l->length - 1U)) = s;
  return;
}
}
#line 808 "/usr/include/glib-2.0/gobject/gobject.h"
__inline static void g_assert_finalize_object___13(GObject *object ) 
{ 
  gpointer weak_pointer ;
  long __cil_tmp3 ;
  long __cil_tmp4 ;

  {
#line 810
  weak_pointer = object;
  {
#line 812
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 812
    __cil_tmp3 = __builtin_expect((long )0, (long )1);
    }
#line 812
    if (__cil_tmp3) {

    } else {
      {
#line 812
      g_assertion_message((char const   *)((gchar *)0), "/usr/include/glib-2.0/gobject/gobject.h",
                          812, (char const   *)"g_assert_finalize_object\312\001@",
                          "\'G_IS_OBJECT (weak_pointer)\' should be TRUE");
      }
    }
#line 812
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 813
  g_object_add_weak_pointer(object, & weak_pointer);
#line 814
  g_object_unref(weak_pointer);
  }
  {
#line 815
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 815
    __cil_tmp4 = __builtin_expect((long )0, (long )1);
    }
#line 815
    if (__cil_tmp4) {

    } else {
      {
#line 815
      g_assertion_message((char const   *)((gchar *)0), "/usr/include/glib-2.0/gobject/gobject.h",
                          815, (char const   *)"g_assert_finalize_object\312\001@\n\030\257\b",
                          "\'weak_pointer\' should be NULLV");
      }
    }
#line 815
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 808 "/usr/include/glib-2.0/gobject/gobject.h"
__inline static void g_assert_finalize_object___14(GObject *object ) 
{ 
  gpointer weak_pointer ;
  long __cil_tmp3 ;
  long __cil_tmp4 ;

  {
#line 810
  weak_pointer = object;
  {
#line 812
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 812
    __cil_tmp3 = __builtin_expect((long )0, (long )1);
    }
#line 812
    if (__cil_tmp3) {

    } else {
      {
#line 812
      g_assertion_message((char const   *)((gchar *)0), "/usr/include/glib-2.0/gobject/gobject.h",
                          812, (char const   *)"g_assert_finalize_object\312\001@",
                          "\'G_IS_OBJECT (weak_pointer)\' should be TRUE");
      }
    }
#line 812
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 813
  g_object_add_weak_pointer(object, & weak_pointer);
#line 814
  g_object_unref(weak_pointer);
  }
  {
#line 815
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 815
    __cil_tmp4 = __builtin_expect((long )0, (long )1);
    }
#line 815
    if (__cil_tmp4) {

    } else {
      {
#line 815
      g_assertion_message((char const   *)((gchar *)0), "/usr/include/glib-2.0/gobject/gobject.h",
                          815, (char const   *)"g_assert_finalize_object\312\001@\n\256\256\b",
                          "\'weak_pointer\' should be NULLV");
      }
    }
#line 815
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 63 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/fit.c"
static void append_index(index_list_type *list , unsigned int new_index ) ;
#line 64
static void free_index_list(index_list_type *index_list ) ;
#line 65
static index_list_type new_index_list(void) ;
#line 66
static void remove_adjacent_corners(index_list_type *list , unsigned int last_index ,
                                    gboolean remove_adj_corners , at_exception_type *exception ) ;
#line 67
static void change_bad_lines(spline_list_type *spline_list , fitting_opts_type *fitting_opts ) ;
#line 68
static void filter(curve_type curve , fitting_opts_type *fitting_opts ) ;
#line 69
static void find_vectors(unsigned int test_index , pixel_outline_type outline , vector_type *in ,
                         vector_type *out , unsigned int corner_surround ) ;
#line 70
static index_list_type find_corners(pixel_outline_type pixel_outline , fitting_opts_type *fitting_opts ,
                                    at_exception_type *exception ) ;
#line 71
static gfloat find_error(curve_type curve , spline_type spline , unsigned int *worst_point ,
                         at_exception_type *exception ) ;
#line 72
static vector_type find_half_tangent(curve_type c , gboolean to_start_point , unsigned int *n_points ,
                                     unsigned int tangent_surround ) ;
#line 73
static void find_tangent(curve_type curve , gboolean to_start_point , gboolean cross_curve ,
                         unsigned int tangent_surround ) ;
#line 74
static spline_type fit_one_spline(curve_type curve , at_exception_type *exception ) ;
#line 75
static spline_list_type *fit_curve(curve_type curve , fitting_opts_type *fitting_opts ,
                                   at_exception_type *exception ) ;
#line 76
static spline_list_type fit_curve_list(curve_list_type curve_list , fitting_opts_type *fitting_opts ,
                                       at_distance_map *dist , at_exception_type *exception ) ;
#line 77
static spline_list_type *fit_with_least_squares(curve_type curve , fitting_opts_type *fitting_opts ,
                                                at_exception_type *exception ) ;
#line 78
static spline_list_type *fit_with_line(curve_type curve ) ;
#line 79
static void remove_knee_points(curve_type curve , gboolean clockwise ) ;
#line 80
static void set_initial_parameter_values(curve_type curve ) ;
#line 81
static gboolean spline_linear_enough(spline_type *spline , curve_type curve , fitting_opts_type *fitting_opts ) ;
#line 82
static curve_list_array_type split_at_corners(pixel_outline_list_type pixel_list ,
                                              fitting_opts_type *fitting_opts , at_exception_type *exception ) ;
#line 83
static at_coord real_to_int_coord(at_real_coord real_coord ) ;
#line 84
static gfloat distance(at_real_coord p1 , at_real_coord p2 ) ;
#line 87 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/fit.c"
fitting_opts_type new_fitting_opts(void) 
{ 
  fitting_opts_type fitting_opts ;

  {
#line 91
  fitting_opts.background_color = (at_color *)((void *)0);
#line 92
  fitting_opts.charcode = (unsigned int )0;
#line 93
  fitting_opts.color_count = (unsigned int )0;
#line 94
  fitting_opts.corner_always_threshold = (gfloat )60.;
#line 95
  fitting_opts.corner_surround = (unsigned int )4;
#line 96
  fitting_opts.corner_threshold = (gfloat )100.;
#line 97
  fitting_opts.error_threshold = (gfloat )2.;
#line 98
  fitting_opts.filter_iterations = (unsigned int )4;
#line 99
  fitting_opts.line_reversion_threshold = (gfloat )0.0100000000001;
#line 100
  fitting_opts.line_threshold = (gfloat )1.;
#line 101
  fitting_opts.remove_adjacent_corners = 0;
#line 102
  fitting_opts.tangent_surround = (unsigned int )3;
#line 103
  fitting_opts.despeckle_level = (unsigned int )0;
#line 104
  fitting_opts.despeckle_tightness = (gfloat )2.;
#line 105
  fitting_opts.noise_removal = (gfloat )0.99;
#line 106
  fitting_opts.centerline = 0;
#line 107
  fitting_opts.preserve_width = 0;
#line 108
  fitting_opts.width_weight_factor = (gfloat )6.;
#line 110
  return (fitting_opts);
}
}
#line 117 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/fit.c"
at_spline_list_array_type fitted_splines(pixel_outline_list_type pixel_outline_list ,
                                         fitting_opts_type *fitting_opts , at_distance_map *dist ,
                                         unsigned short width , unsigned short height ,
                                         at_exception_type *exception , at_progress_func notify_progress ,
                                         gpointer progress_data , at_testcancel_func test_cancel ,
                                         gpointer testcancel_data ) 
{ 
  unsigned int this_list ;
  at_spline_list_array_type char_splines ;
  at_spline_list_array_type __cil_tmp13 ;
  curve_list_array_type curve_array ;
  curve_list_array_type __cil_tmp15 ;
  at_color *__cil_tmp16 ;
  spline_list_type curve_list_splines ;
  curve_list_type curves ;
  gboolean __cil_tmp19 ;
  spline_list_type __cil_tmp20 ;
  gboolean __cil_tmp21 ;
  unsigned int __cil_tmp22 ;

  {
  {
#line 121
  __cil_tmp13 = new_spline_list_array();
#line 121
  char_splines = __cil_tmp13;
#line 122
  __cil_tmp15 = split_at_corners(pixel_outline_list, fitting_opts, exception);
#line 122
  curve_array = __cil_tmp15;
#line 126
  char_splines.centerline = fitting_opts->centerline;
#line 127
  char_splines.preserve_width = fitting_opts->preserve_width;
#line 128
  char_splines.width_weight_factor = fitting_opts->width_weight_factor;
  }
#line 130
  if (fitting_opts->background_color) {
    {
#line 131
    char_splines.background_color = at_color_copy(fitting_opts->background_color);
    }
  } else {
#line 133
    char_splines.background_color = (at_color *)((void *)0);
  }
#line 135
  char_splines.width = width;
#line 136
  char_splines.height = height;
#line 138
  this_list = (unsigned int )0;
  {
#line 138
  while (1) {
    while_continue: /* CIL Label */ ;
#line 138
    if (! (this_list < curve_array.length)) {
#line 138
      goto while_break;
    }
#line 140
    curves = *(curve_array.data + this_list);
#line 142
    if (notify_progress) {
      {
#line 143
      (*notify_progress)((gfloat )this_list / ((gfloat )curve_array.length * (gfloat )3.) + (gfloat )0.333000000001,
                         progress_data);
      }
    }
    {
#line 144
    __cil_tmp19 = (*test_cancel)(testcancel_data);
    }
#line 144
    if (test_cancel) {
#line 144
      if (__cil_tmp19) {
#line 145
        goto cleanup;
      }
    }
    {
#line 147
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 147
      if (logging) {
        {
#line 147
        fprintf(stdout, "\nFitting curve list #%u:\n", this_list);
        }
      }
#line 147
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 149
    curve_list_splines = fit_curve_list(curves, fitting_opts, dist, exception);
#line 150
    __cil_tmp21 = at_exception_got_fatal(exception);
    }
#line 150
    if (__cil_tmp21) {
#line 151
      if (char_splines.background_color) {
        {
#line 152
        at_color_free(char_splines.background_color);
        }
      }
#line 153
      goto cleanup;
    }
    {
#line 155
    curve_list_splines.clockwise = curves.clockwise;
#line 157
    memcpy(& curve_list_splines.color, & (pixel_outline_list.data + this_list)->color,
           sizeof(at_color ));
#line 158
    append_spline_list(& char_splines, curve_list_splines);
    }
#line 138
    this_list ++;
  }
  while_break: /* CIL Label */ ;
  }
  cleanup: 
  {
#line 161
  free_curve_list_array(& curve_array, notify_progress, progress_data);
  }
#line 163
  return (char_splines);
}
}
#line 170 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/fit.c"
static spline_list_type fit_curve_list(curve_list_type curve_list , fitting_opts_type *fitting_opts ,
                                       at_distance_map *dist , at_exception_type *exception ) 
{ 
  curve_type curve ;
  unsigned int this_curve ;
  unsigned int this_spline ;
  unsigned int curve_list_length ;
  spline_list_type curve_list_splines ;
  spline_list_type __cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  unsigned int this_point ;
  unsigned int height ;
  unsigned int x ;
  unsigned int y ;
  float width ;
  float w ;
  at_real_coord *coord ;
  unsigned int __cil_tmp19 ;
  unsigned int __cil_tmp20 ;
  unsigned int __cil_tmp21 ;
  spline_list_type *curve_splines ;
  curve_type current_curve ;
  spline_list_type *__cil_tmp24 ;
  gboolean __cil_tmp25 ;
  unsigned int __cil_tmp26 ;
  unsigned int __cil_tmp27 ;
  unsigned int __cil_tmp28 ;

  {
  {
#line 174
  curve_list_length = curve_list.length;
#line 175
  __cil_tmp10 = empty_spline_list();
#line 175
  curve_list_splines = __cil_tmp10;
#line 177
  curve_list_splines.open = curve_list.open;
  }
  {
#line 183
  while (1) {
    while_continue: /* CIL Label */ ;
#line 183
    if (logging) {
      {
#line 183
      fprintf(stdout, "\nRemoving knees:\n");
      }
    }
#line 183
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 184
  this_curve = (unsigned int )0;
  {
#line 184
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 184
    if (! (this_curve < curve_list_length)) {
#line 184
      goto while_break___0;
    }
    {
#line 185
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 185
      if (logging) {
        {
#line 185
        fprintf(stdout, "#%u:", this_curve);
        }
      }
#line 185
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 186
    remove_knee_points(*(curve_list.data + this_curve), curve_list.clockwise);
    }
#line 184
    this_curve ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 189
  if (dist != (void *)0) {
#line 191
    height = dist->height;
#line 192
    this_curve = (unsigned int )0;
    {
#line 192
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 192
      if (! (this_curve < curve_list_length)) {
#line 192
        goto while_break___2;
      }
#line 193
      curve = *(curve_list.data + this_curve);
#line 194
      this_point = (unsigned int )0;
      {
#line 194
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 194
        if (! (this_point < curve->length)) {
#line 194
          goto while_break___3;
        }
#line 197
        coord = & (curve->point_list + this_point)->coord;
#line 198
        x = (unsigned int )coord->x;
#line 199
        y = (height - (unsigned int )coord->y) - 1U;
#line 205
        width = *(*(dist->d + y) + x);
#line 206
        if (y >= 1U) {
#line 207
          w = *(*(dist->d + (y - 1U)) + x);
#line 207
          if (w > width) {
#line 208
            width = w;
          }
#line 209
          if (x >= 1U) {
#line 210
            w = *(*(dist->d + y) + (x - 1U));
#line 210
            if (w > width) {
#line 211
              width = w;
            }
#line 212
            w = *(*(dist->d + (y - 1U)) + (x - 1U));
#line 212
            if (w > width) {
#line 213
              width = w;
            }
          }
#line 215
          if (x + 1U < dist->width) {
#line 216
            w = *(*(dist->d + y) + (x + 1U));
#line 216
            if (w > width) {
#line 217
              width = w;
            }
#line 218
            w = *(*(dist->d + (y - 1U)) + (x + 1U));
#line 218
            if (w > width) {
#line 219
              width = w;
            }
          }
        }
#line 222
        if (y + 1U < height) {
#line 223
          w = *(*(dist->d + (y + 1U)) + x);
#line 223
          if (w > width) {
#line 224
            width = w;
          }
#line 225
          w = *(*(dist->d + (y + 1U)) + (x - 1U));
#line 225
          if (x >= 1U) {
#line 225
            if (w > width) {
#line 226
              width = w;
            }
          }
#line 227
          w = *(*(dist->d + (y + 1U)) + (x + 1U));
#line 227
          if (x + 1U < dist->width) {
#line 227
            if (w > width) {
#line 228
              width = w;
            }
          }
        }
#line 230
        coord->z = width * fitting_opts->width_weight_factor;
#line 194
        this_point ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 192
      this_curve ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 238
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 238
    if (logging) {
      {
#line 238
      fprintf(stdout, "\nFiltering curves:\n");
      }
    }
#line 238
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 239
  this_curve = (unsigned int )0;
  {
#line 239
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 239
    if (! (this_curve < curve_list.length)) {
#line 239
      goto while_break___5;
    }
    {
#line 240
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 240
      if (logging) {
        {
#line 240
        fprintf(stdout, "#%u: ", this_curve);
        }
      }
#line 240
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 241
    filter(*(curve_list.data + this_curve), fitting_opts);
    }
#line 239
    this_curve ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 255
  curve = *(curve_list.data + 0);
#line 256
  if (curve->cyclic == 1) {
    {
#line 257
    append_point(curve, (curve->point_list + 0)->coord);
    }
  }
#line 260
  this_curve = (unsigned int )0;
  {
#line 260
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 260
    if (! (this_curve < curve_list_length)) {
#line 260
      goto while_break___7;
    }
#line 262
    current_curve = *(curve_list.data + this_curve);
    {
#line 264
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 264
      if (logging) {
        {
#line 264
        fprintf(stdout, "\nFitting curve #%u:\n", this_curve);
        }
      }
#line 264
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 266
    curve_splines = fit_curve(current_curve, fitting_opts, exception);
#line 267
    __cil_tmp25 = at_exception_got_fatal(exception);
    }
#line 267
    if (__cil_tmp25) {
#line 268
      goto cleanup;
    } else
#line 269
    if (curve_splines == (void *)0) {
      {
#line 270
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 270
        if (logging) {
          {
#line 270
          fprintf(stdout, "Could not fit curve #%u", this_curve);
          }
        }
#line 270
        goto while_break___9;
      }
      while_break___9: /* CIL Label */ ;
      }
      {
#line 271
      at_exception_warning(exception, (gchar *)"Could not fit curve");
      }
    } else {
      {
#line 273
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 273
        if (logging) {
          {
#line 273
          fprintf(stdout, "Fitted splines for curve #%u:\n", this_curve);
          }
        }
#line 273
        goto while_break___10;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 274
      this_spline = (unsigned int )0;
      {
#line 274
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 274
        if (! (this_spline < curve_splines->length)) {
#line 274
          goto while_break___11;
        }
        {
#line 275
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 275
          if (logging) {
            {
#line 275
            fprintf(stdout, "  %u: ", this_spline);
            }
          }
#line 275
          goto while_break___12;
        }
        while_break___12: /* CIL Label */ ;
        }
#line 276
        if (logging) {
          {
#line 277
          print_spline(*(curve_splines->data + this_spline));
          }
        }
#line 274
        this_spline ++;
      }
      while_break___11: /* CIL Label */ ;
      }
      {
#line 283
      change_bad_lines(curve_splines, fitting_opts);
#line 285
      concat_spline_lists(& curve_list_splines, *curve_splines);
#line 286
      free_spline_list(*curve_splines);
#line 287
      free(curve_splines);
      }
    }
#line 260
    this_curve ++;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 291
  if (logging) {
    {
#line 292
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 292
      if (logging) {
        {
#line 292
        fprintf(stdout, "\nFitted splines are:\n");
        }
      }
#line 292
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
#line 293
    this_spline = (unsigned int )0;
    {
#line 293
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 293
      if (! (this_spline < curve_list_splines.length)) {
#line 293
        goto while_break___14;
      }
      {
#line 294
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 294
        if (logging) {
          {
#line 294
          fprintf(stdout, "  %u: ", this_spline);
          }
        }
#line 294
        goto while_break___15;
      }
      while_break___15: /* CIL Label */ ;
      }
      {
#line 295
      print_spline(*(curve_list_splines.data + this_spline));
      }
#line 293
      this_spline ++;
    }
    while_break___14: /* CIL Label */ ;
    }
  }
  cleanup: 
#line 299
  return (curve_list_splines);
}
}
#line 306 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/fit.c"
static spline_list_type *fit_curve(curve_type curve , fitting_opts_type *fitting_opts ,
                                   at_exception_type *exception ) 
{ 
  spline_list_type *fittedsplines ;
  spline_list_type *__cil_tmp5 ;
  spline_list_type *__cil_tmp6 ;
  spline_list_type *tmp ;

  {
#line 310
  if (curve->length < 2U) {
    {
#line 311
    while (1) {
      while_continue: /* CIL Label */ ;
#line 311
      if (logging) {
        {
#line 311
        fprintf(stdout, "Tried to fit curve with less than two points");
        }
      }
#line 311
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 312
    at_exception_warning(exception, (gchar *)"Tried to fit curve with less than two points");
    }
#line 313
    return ((spline_list_type *)((void *)0));
  }
#line 317
  if (curve->length < 4U) {
    {
#line 317
    __cil_tmp5 = fit_with_line(curve);
#line 317
    tmp = __cil_tmp5;
    }
  } else {
    {
#line 317
    __cil_tmp6 = fit_with_least_squares(curve, fitting_opts, exception);
#line 317
    tmp = __cil_tmp6;
    }
  }
#line 317
  fittedsplines = tmp;
#line 320
  return (fittedsplines);
}
}
#line 348 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/fit.c"
static curve_list_array_type split_at_corners(pixel_outline_list_type pixel_list ,
                                              fitting_opts_type *fitting_opts , at_exception_type *exception ) 
{ 
  unsigned int this_pixel_o ;
  curve_list_array_type curve_array ;
  curve_list_array_type __cil_tmp6 ;
  curve_type curve ;
  curve_type first_curve ;
  index_list_type corner_list ;
  unsigned int p ;
  unsigned int this_corner ;
  curve_list_type curve_list ;
  curve_list_type __cil_tmp13 ;
  pixel_outline_type pixel_o ;
  index_list_type __cil_tmp15 ;
  int surround ;
  unsigned int save_corner_surround ;
  index_list_type __cil_tmp18 ;
  curve_type __cil_tmp19 ;
  unsigned int __cil_tmp20 ;
  curve_type previous_curve ;
  unsigned int corner ;
  unsigned int next_corner ;
  unsigned int __cil_tmp24 ;
  curve_type __cil_tmp25 ;
  unsigned int __cil_tmp26 ;
  unsigned int __cil_tmp27 ;
  unsigned int __cil_tmp28 ;
  curve_type last_curve ;
  unsigned int __cil_tmp30 ;

  {
  {
#line 351
  __cil_tmp6 = new_curve_list_array();
#line 351
  curve_array = __cil_tmp6;
  }
  {
#line 353
  while (1) {
    while_continue: /* CIL Label */ ;
#line 353
    if (logging) {
      {
#line 353
      fprintf(stdout, "\nFinding corners:\n");
      }
    }
#line 353
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 355
  this_pixel_o = (unsigned int )0;
  {
#line 355
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 355
    if (! (this_pixel_o < pixel_list.length)) {
#line 355
      goto while_break___0;
    }
    {
#line 359
    __cil_tmp13 = new_curve_list();
#line 359
    curve_list = __cil_tmp13;
#line 360
    pixel_o = *(pixel_list.data + this_pixel_o);
#line 362
    curve_list.clockwise = pixel_o.clockwise;
#line 363
    curve_list.open = pixel_o.open;
    }
    {
#line 365
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 365
      if (logging) {
        {
#line 365
        fprintf(stdout, "#%u:", this_pixel_o);
        }
      }
#line 365
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 372
    if (pixel_o.length > fitting_opts->corner_surround * 2U + 2U) {
      {
#line 373
      corner_list = find_corners(pixel_o, fitting_opts, exception);
      }
    } else {
#line 377
      surround = (int )(pixel_o.length - 3U) / 2;
#line 377
      if (surround >= 2) {
        {
#line 378
        save_corner_surround = fitting_opts->corner_surround;
#line 379
        fitting_opts->corner_surround = (unsigned int )surround;
#line 380
        corner_list = find_corners(pixel_o, fitting_opts, exception);
#line 381
        fitting_opts->corner_surround = save_corner_surround;
        }
      } else {
#line 383
        corner_list.length = (unsigned int )0;
#line 384
        corner_list.data = (unsigned int *)((void *)0);
      }
    }
    {
#line 390
    first_curve = new_curve();
#line 392
    curve = first_curve;
    }
#line 394
    if (corner_list.length == 0U) {
#line 395
      p = (unsigned int )0;
      {
#line 395
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 395
        if (! (p < pixel_o.length)) {
#line 395
          goto while_break___2;
        }
        {
#line 396
        append_pixel(curve, *(pixel_o.data + p));
        }
#line 395
        p ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 398
      if (curve_list.open == 1) {
#line 399
        curve->cyclic = 0;
      } else {
#line 401
        curve->cyclic = ! 0;
      }
    } else {
#line 404
      this_corner = (unsigned int )0;
      {
#line 404
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 404
        if (! (this_corner < corner_list.length - 1U)) {
#line 404
          goto while_break___3;
        }
#line 405
        previous_curve = curve;
#line 406
        corner = *(corner_list.data + this_corner);
#line 407
        next_corner = *(corner_list.data + (this_corner + 1U));
#line 409
        p = corner;
        {
#line 409
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 409
          if (! (p <= next_corner)) {
#line 409
            goto while_break___4;
          }
          {
#line 410
          append_pixel(curve, *(pixel_o.data + p));
          }
#line 409
          p ++;
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 412
        append_curve(& curve_list, curve);
#line 413
        curve = new_curve();
#line 414
        previous_curve->next = curve;
#line 415
        curve->previous = previous_curve;
        }
#line 404
        this_corner ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 421
      p = *(corner_list.data + (corner_list.length - 1U));
      {
#line 421
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 421
        if (! (p < pixel_o.length)) {
#line 421
          goto while_break___5;
        }
        {
#line 422
        append_pixel(curve, *(pixel_o.data + p));
        }
#line 421
        p ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 424
      if (! pixel_o.open) {
#line 425
        p = (unsigned int )0;
        {
#line 425
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 425
          if (! (p <= *(corner_list.data + 0))) {
#line 425
            goto while_break___6;
          }
          {
#line 426
          append_pixel(curve, *(pixel_o.data + p));
          }
#line 425
          p ++;
        }
        while_break___6: /* CIL Label */ ;
        }
      } else {
#line 428
        last_curve = curve->previous;
#line 429
        first_curve->previous = (struct curve *)((void *)0);
#line 430
        if (last_curve) {
#line 431
          last_curve->next = (struct curve *)((void *)0);
        }
      }
    }
    {
#line 435
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 435
      if (logging) {
        {
#line 435
        fprintf(stdout, " [%u].\n", corner_list.length);
        }
      }
#line 435
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 436
    free_index_list(& corner_list);
#line 440
    append_curve(& curve_list, curve);
#line 441
    curve->next = first_curve;
#line 442
    first_curve->previous = curve;
#line 445
    append_curve_list(& curve_array, curve_list);
    }
#line 355
    this_pixel_o ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 448
  return (curve_array);
}
}
#line 473 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/fit.c"
static index_list_type find_corners(pixel_outline_type pixel_outline , fitting_opts_type *fitting_opts ,
                                    at_exception_type *exception ) 
{ 
  unsigned int p ;
  unsigned int start_p ;
  unsigned int end_p ;
  index_list_type corner_list ;
  index_list_type __cil_tmp8 ;
  gfloat corner_angle ;
  vector_type in_vector ;
  vector_type out_vector ;
  gfloat __cil_tmp12 ;
  gboolean __cil_tmp13 ;
  double __cil_tmp14 ;
  gfloat best_corner_angle ;
  unsigned int best_corner_index ;
  index_list_type equally_good_list ;
  index_list_type __cil_tmp18 ;
  unsigned int q ;
  unsigned int i ;
  gfloat __cil_tmp21 ;
  gboolean __cil_tmp22 ;
  gboolean __cil_tmp23 ;
  index_list_type __cil_tmp24 ;
  unsigned int __cil_tmp25 ;
  unsigned int j ;
  unsigned int __cil_tmp27 ;
  unsigned int tmp ;
  unsigned int __cil_tmp29 ;
  int tmp___0 ;

  {
  {
#line 476
  __cil_tmp8 = new_index_list();
#line 476
  corner_list = __cil_tmp8;
#line 478
  start_p = (unsigned int )0;
#line 479
  end_p = pixel_outline.length - 1U;
  }
#line 480
  if (pixel_outline.open) {
#line 481
    if (end_p <= fitting_opts->corner_surround * 2U) {
#line 482
      return (corner_list);
    }
    {
#line 483
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 483
      append_index(& corner_list, (unsigned int )0);
      }
      {
#line 483
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 483
        if (logging) {
          {
#line 483
          fprintf(stdout, " (%d,%d)%c%.3f", (int )(pixel_outline.data + 0)->x, (int )(pixel_outline.data + 0)->y,
                  '@', 0.);
          }
        }
#line 483
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 483
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 484
    start_p += fitting_opts->corner_surround;
#line 485
    end_p -= fitting_opts->corner_surround;
  }
#line 489
  p = start_p;
  {
#line 489
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 489
    if (! (p <= end_p)) {
#line 489
      goto while_break___1;
    }
    {
#line 494
    find_vectors(p, pixel_outline, & in_vector, & out_vector, fitting_opts->corner_surround);
#line 495
    corner_angle = Vangle(in_vector, out_vector, exception);
#line 496
    __cil_tmp13 = at_exception_got_fatal(exception);
    }
#line 496
    if (__cil_tmp13) {
#line 497
      goto cleanup;
    }
    {
#line 499
    __cil_tmp14 = fabs((double )corner_angle);
    }
#line 499
    if (__cil_tmp14 <= (double )fitting_opts->corner_threshold) {
      {
#line 504
      best_corner_angle = corner_angle;
#line 505
      best_corner_index = p;
#line 506
      __cil_tmp18 = new_index_list();
#line 506
      equally_good_list = __cil_tmp18;
#line 511
      q = p;
#line 512
      i = p + 1U;
      }
      {
#line 514
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 523
        if (corner_angle <= fitting_opts->corner_always_threshold) {
#line 523
          if (q >= p) {
            {
#line 524
            while (1) {
              while_continue___3: /* CIL Label */ ;
              {
#line 524
              append_index(& corner_list, q);
              }
              {
#line 524
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 524
                if (logging) {
                  {
#line 524
                  fprintf(stdout, " (%d,%d)%c%.3f", (int )(pixel_outline.data + q)->x,
                          (int )(pixel_outline.data + q)->y, '\\', (double )corner_angle);
                  }
                }
#line 524
                goto while_break___4;
              }
              while_break___4: /* CIL Label */ ;
              }
#line 524
              goto while_break___3;
            }
            while_break___3: /* CIL Label */ ;
            }
          }
        }
#line 529
        if (i >= best_corner_index + fitting_opts->corner_surround) {
#line 530
          goto while_break___2;
        } else
#line 529
        if (i >= pixel_outline.length) {
#line 530
          goto while_break___2;
        }
        {
#line 533
        q = i % pixel_outline.length;
#line 534
        find_vectors(q, pixel_outline, & in_vector, & out_vector, fitting_opts->corner_surround);
#line 535
        corner_angle = Vangle(in_vector, out_vector, exception);
#line 536
        __cil_tmp22 = at_exception_got_fatal(exception);
        }
#line 536
        if (__cil_tmp22) {
#line 537
          goto cleanup;
        }
        {
#line 543
        __cil_tmp23 = epsilon_equal(corner_angle, best_corner_angle);
        }
#line 543
        if (__cil_tmp23) {
          {
#line 544
          append_index(& equally_good_list, q);
          }
        } else
#line 546
        if (corner_angle < best_corner_angle) {
          {
#line 547
          best_corner_angle = corner_angle;
#line 550
          best_corner_index = q;
#line 550
          i = best_corner_index;
#line 551
          free_index_list(& equally_good_list);
#line 552
          equally_good_list = new_index_list();
          }
        }
#line 555
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 563
      if (best_corner_angle > fitting_opts->corner_always_threshold) {
#line 563
        if (best_corner_index >= p) {
          {
#line 566
          while (1) {
            while_continue___5: /* CIL Label */ ;
            {
#line 566
            append_index(& corner_list, best_corner_index);
            }
            {
#line 566
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 566
              if (logging) {
                {
#line 566
                fprintf(stdout, " (%d,%d)%c%.3f", (int )(pixel_outline.data + best_corner_index)->x,
                        (int )(pixel_outline.data + best_corner_index)->y, '/', (double )best_corner_angle);
                }
              }
#line 566
              goto while_break___6;
            }
            while_break___6: /* CIL Label */ ;
            }
#line 566
            goto while_break___5;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 568
          j = (unsigned int )0;
          {
#line 568
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 568
            if (! (j < equally_good_list.length)) {
#line 568
              goto while_break___7;
            }
            {
#line 569
            while (1) {
              while_continue___8: /* CIL Label */ ;
              {
#line 569
              append_index(& corner_list, *(equally_good_list.data + j));
              }
              {
#line 569
              while (1) {
                while_continue___9: /* CIL Label */ ;
#line 569
                if (logging) {
                  {
#line 569
                  fprintf(stdout, " (%d,%d)%c%.3f", (int )(pixel_outline.data + *(equally_good_list.data + j))->x,
                          (int )(pixel_outline.data + *(equally_good_list.data + j))->y,
                          '@', (double )best_corner_angle);
                  }
                }
#line 569
                goto while_break___9;
              }
              while_break___9: /* CIL Label */ ;
              }
#line 569
              goto while_break___8;
            }
            while_break___8: /* CIL Label */ ;
            }
#line 568
            j ++;
          }
          while_break___7: /* CIL Label */ ;
          }
        }
      }
      {
#line 571
      free_index_list(& equally_good_list);
      }
#line 576
      if (q < p) {
#line 576
        tmp = pixel_outline.length;
      } else {
#line 576
        tmp = q;
      }
#line 576
      p = tmp;
    }
#line 489
    p ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 580
  if (corner_list.length > 0U) {
#line 584
    if (pixel_outline.open) {
#line 584
      tmp___0 = 2;
    } else {
#line 584
      tmp___0 = 1;
    }
    {
#line 584
    remove_adjacent_corners(& corner_list, pixel_outline.length - (unsigned int )tmp___0,
                            fitting_opts->remove_adjacent_corners, exception);
    }
  }
  cleanup: 
#line 586
  return (corner_list);
}
}
#line 597 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/fit.c"
static void find_vectors(unsigned int test_index , pixel_outline_type outline , vector_type *in ,
                         vector_type *out , unsigned int corner_surround ) 
{ 
  int i ;
  unsigned int n_done ;
  at_coord candidate ;
  unsigned int tmp ;
  vector_type __cil_tmp10 ;
  vector_type __cil_tmp11 ;
  unsigned int tmp___0 ;
  unsigned int __cil_tmp13 ;
  vector_type __cil_tmp14 ;
  vector_type __cil_tmp15 ;
  unsigned int __cil_tmp16 ;

  {
#line 601
  candidate = *(outline.data + test_index);
#line 603
  in->dz = (gfloat )0.;
#line 603
  in->dy = in->dz;
#line 603
  in->dx = in->dy;
#line 604
  out->dz = (gfloat )0.;
#line 604
  out->dy = out->dz;
#line 604
  out->dx = out->dy;
#line 608
  n_done = (unsigned int )0;
#line 608
  if (test_index == 0U) {
#line 608
    tmp = outline.length - 1U;
  } else {
#line 608
    tmp = test_index - 1U;
  }
#line 608
  i = (int )tmp;
  {
#line 608
  while (1) {
    while_continue: /* CIL Label */ ;
#line 608
    if (! (n_done < corner_surround)) {
#line 608
      goto while_break;
    }
    {
#line 609
    __cil_tmp10 = IPsubtract(*(outline.data + i), candidate);
#line 609
    __cil_tmp11 = Vadd(*in, __cil_tmp10);
#line 609
    *in = __cil_tmp11;
    }
#line 608
    __cil_tmp13 = n_done;
#line 608
    n_done ++;
#line 608
    if (i == 0) {
#line 608
      tmp___0 = outline.length - 1U;
    } else {
#line 608
      tmp___0 = (unsigned int )(i - 1);
    }
#line 608
    i = (int )tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 612
  n_done = (unsigned int )0;
#line 612
  i = (int )((test_index + 1U) % outline.length);
  {
#line 612
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 612
    if (! (n_done < corner_surround)) {
#line 612
      goto while_break___0;
    }
    {
#line 613
    __cil_tmp14 = IPsubtract(*(outline.data + i), candidate);
#line 613
    __cil_tmp15 = Vadd(*out, __cil_tmp14);
#line 613
    *out = __cil_tmp15;
    }
#line 612
    __cil_tmp16 = n_done;
#line 612
    n_done ++;
#line 612
    i = (int )((unsigned int )(i + 1) % outline.length);
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 626 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/fit.c"
static void remove_adjacent_corners(index_list_type *list , unsigned int last_index ,
                                    gboolean remove_adj_corners , at_exception_type *exception ) 
{ 
  unsigned int j ;
  unsigned int last ;
  index_list_type new_list ;
  index_list_type __cil_tmp8 ;
  unsigned int search ;
  unsigned int temp ;
  unsigned int max_index ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  unsigned int current ;
  unsigned int next ;
  unsigned int __cil_tmp16 ;
  unsigned int __cil_tmp17 ;

  {
  {
#line 630
  __cil_tmp8 = new_index_list();
#line 630
  new_list = __cil_tmp8;
#line 632
  j = list->length - 1U;
  }
  {
#line 632
  while (1) {
    while_continue: /* CIL Label */ ;
#line 632
    if (! (j > 0U)) {
#line 632
      goto while_break;
    }
#line 636
    max_index = j;
#line 638
    search = (unsigned int )0;
    {
#line 638
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 638
      if (! (search < j)) {
#line 638
        goto while_break___0;
      }
#line 639
      if (*(list->data + search) > *(list->data + max_index)) {
#line 640
        max_index = search;
      }
#line 638
      search ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 642
    if (max_index != j) {
#line 643
      temp = *(list->data + j);
#line 644
      *(list->data + j) = *(list->data + max_index);
#line 645
      *(list->data + max_index) = temp;
      {
#line 648
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 648
        if (logging) {
          {
#line 648
          fprintf(stdout, "needed exchange");
          }
        }
#line 648
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 649
      at_exception_warning(exception, (gchar *)"needed exchange");
      }
    }
#line 632
    __cil_tmp13 = j;
#line 632
    j --;
  }
  while_break: /* CIL Label */ ;
  }
#line 656
  j = (unsigned int )0;
  {
#line 656
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 656
    if (! (j < list->length - 1U)) {
#line 656
      goto while_break___2;
    }
#line 657
    current = *(list->data + j);
#line 658
    next = *(list->data + (j + 1U));
#line 663
    if (remove_adj_corners) {
#line 663
      if (next == current + 1U) {
#line 664
        j ++;
      } else
#line 663
      if (next == current) {
#line 664
        j ++;
      }
    }
    {
#line 666
    append_index(& new_list, current);
    }
#line 656
    j ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 671
  last = *(list->data + (list->length - 1U));
#line 672
  if (new_list.length == 0U) {
    {
    {
#line 673
    append_index(& new_list, last);
    }
    }
  } else
#line 672
  if (! (last == *(new_list.data + (new_list.length - 1U)) + 1U || (last == last_index && *(list->data + 0) == 0U))) {
    {
    {
#line 673
    append_index(& new_list, last);
    }
    }
  }
  {
#line 675
  free_index_list(list);
#line 676
  *list = new_list;
  }
  return;
}
}
#line 715 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/fit.c"
static void remove_knee_points(curve_type curve , gboolean clockwise ) 
{ 
  unsigned int i ;
  unsigned int offset ;
  int tmp ;
  at_coord previous ;
  int tmp___0 ;
  int tmp___1 ;
  at_coord __cil_tmp9 ;
  curve_type trimmed_curve ;
  curve_type __cil_tmp11 ;
  at_coord __cil_tmp12 ;
  at_coord current ;
  at_coord __cil_tmp14 ;
  at_coord next ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  at_coord __cil_tmp18 ;
  vector_type prev_delta ;
  vector_type __cil_tmp20 ;
  vector_type next_delta ;
  vector_type __cil_tmp22 ;
  unsigned int __cil_tmp23 ;
  at_coord __cil_tmp24 ;

  {
#line 718
  if (curve->cyclic == 1) {
#line 718
    tmp = 0;
  } else {
#line 718
    tmp = 1;
  }
  {
#line 718
  offset = (unsigned int )tmp;
#line 719
  __cil_tmp9 = real_to_int_coord((curve->point_list + tmp___1)->coord);
#line 719
  previous = __cil_tmp9;
#line 720
  __cil_tmp11 = copy_most_of_curve(curve);
#line 720
  trimmed_curve = __cil_tmp11;
  }
#line 722
  if (curve->cyclic == 0) {
    {
#line 723
    __cil_tmp12 = real_to_int_coord((curve->point_list + 0)->coord);
#line 723
    append_pixel(trimmed_curve, __cil_tmp12);
    }
  }
#line 725
  i = offset;
  {
#line 725
  while (1) {
    while_continue: /* CIL Label */ ;
#line 725
    if (! (i < curve->length - offset)) {
#line 725
      goto while_break;
    }
    {
#line 726
    __cil_tmp14 = real_to_int_coord((curve->point_list + i)->coord);
#line 726
    current = __cil_tmp14;
#line 727
    __cil_tmp18 = real_to_int_coord((curve->point_list + tmp___3)->coord);
#line 727
    next = __cil_tmp18;
#line 728
    __cil_tmp20 = IPsubtract(previous, current);
#line 728
    prev_delta = __cil_tmp20;
#line 729
    __cil_tmp22 = IPsubtract(next, current);
#line 729
    next_delta = __cil_tmp22;
    }
#line 731
    if ((double )prev_delta.dx == 0.) {
#line 731
      if ((double )prev_delta.dy != 0.) {
        _L___33: /* CIL Label */ 
#line 731
        if ((double )next_delta.dx == 0.) {
#line 731
          if ((double )next_delta.dy != 0.) {
            _L___31: /* CIL Label */ 
#line 731
            if (clockwise) {
#line 731
              if ((double )prev_delta.dx == - 1.) {
#line 731
                if ((double )next_delta.dy == 1.) {
                  _L: /* CIL Label */ 
                  _L___25: /* CIL Label */ 
                  _L___26: /* CIL Label */ 
                  _L___28: /* CIL Label */ 
                  {
#line 734
                  while (1) {
                    while_continue___0: /* CIL Label */ ;
#line 734
                    if (logging) {
                      {
#line 734
                      fprintf(stdout, " (%d,%d)\230\001", (int )current.x, (int )current.y);
                      }
                    }
#line 734
                    goto while_break___0;
                  }
                  while_break___0: /* CIL Label */ ;
                  }
                } else {
#line 731
                  goto _L___30;
                }
              } else
              _L___30: /* CIL Label */ 
#line 731
              if ((double )prev_delta.dy == 1.) {
#line 731
                if ((double )next_delta.dx == 1.) {
#line 731
                  goto _L;
                } else {
#line 731
                  goto _L___29;
                }
              } else
              _L___29: /* CIL Label */ 
#line 731
              if ((double )prev_delta.dx == 1.) {
#line 731
                if ((double )next_delta.dy == - 1.) {
#line 731
                  goto _L;
                } else {
#line 731
                  goto _L___27;
                }
              } else
              _L___27: /* CIL Label */ 
#line 731
              if ((double )prev_delta.dy == - 1.) {
#line 731
                if ((double )next_delta.dx == - 1.) {
#line 731
                  goto _L;
                } else {
#line 731
                  goto _L___24;
                }
              } else {
#line 731
                goto _L___24;
              }
            } else
            _L___24: /* CIL Label */ 
#line 731
            if (! clockwise) {
#line 731
              if ((double )prev_delta.dy == 1.) {
#line 731
                if ((double )next_delta.dx == - 1.) {
#line 731
                  goto _L;
                } else {
#line 731
                  goto _L___23;
                }
              } else
              _L___23: /* CIL Label */ 
#line 731
              if ((double )prev_delta.dx == 1.) {
#line 731
                if ((double )next_delta.dy == 1.) {
#line 731
                  goto _L;
                } else {
#line 731
                  goto _L___22;
                }
              } else
              _L___22: /* CIL Label */ 
#line 731
              if ((double )prev_delta.dy == - 1.) {
#line 731
                if ((double )next_delta.dx == 1.) {
#line 731
                  goto _L;
                } else {
#line 731
                  goto _L___21;
                }
              } else
              _L___21: /* CIL Label */ 
#line 731
              if ((double )prev_delta.dx == - 1.) {
#line 731
                if ((double )next_delta.dy == - 1.) {
#line 731
                  goto _L;
                } else {
                  {
#line 736
                  previous = current;
                  {
                  {
                  {
                  {
                  {
                  {
#line 737
                  append_pixel(trimmed_curve, current);
                  }
                  }
                  }
                  }
                  }
                  }
                  }
                }
              } else {
                {
#line 736
                previous = current;
                {
                {
                {
                {
                {
                {
#line 737
                append_pixel(trimmed_curve, current);
                }
                }
                }
                }
                }
                }
                }
              }
            } else {
              {
#line 736
              previous = current;
              {
              {
              {
              {
              {
              {
#line 737
              append_pixel(trimmed_curve, current);
              }
              }
              }
              }
              }
              }
              }
            }
          } else {
#line 731
            goto _L___32;
          }
        } else
        _L___32: /* CIL Label */ 
#line 731
        if ((double )next_delta.dy == 0.) {
#line 731
          if ((double )next_delta.dx != 0.) {
#line 731
            goto _L___31;
          } else {
            {
#line 736
            previous = current;
            {
            {
            {
            {
            {
            {
#line 737
            append_pixel(trimmed_curve, current);
            }
            }
            }
            }
            }
            }
            }
          }
        } else {
          {
#line 736
          previous = current;
          {
          {
          {
          {
          {
          {
#line 737
          append_pixel(trimmed_curve, current);
          }
          }
          }
          }
          }
          }
          }
        }
      } else {
#line 731
        goto _L___34;
      }
    } else
    _L___34: /* CIL Label */ 
#line 731
    if ((double )prev_delta.dy == 0.) {
#line 731
      if ((double )prev_delta.dx != 0.) {
#line 731
        goto _L___33;
      } else {
        {
#line 736
        previous = current;
        {
        {
        {
        {
        {
        {
#line 737
        append_pixel(trimmed_curve, current);
        }
        }
        }
        }
        }
        }
        }
      }
    } else {
      {
#line 736
      previous = current;
      {
      {
      {
      {
      {
      {
#line 737
      append_pixel(trimmed_curve, current);
      }
      }
      }
      }
      }
      }
      }
    }
#line 725
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 741
  if (curve->cyclic == 0) {
    {
#line 742
    __cil_tmp24 = real_to_int_coord((curve->point_list + (curve->length - 1U))->coord);
#line 742
    append_pixel(trimmed_curve, __cil_tmp24);
    }
  }
#line 744
  if (trimmed_curve->length == curve->length) {
    {
#line 745
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 745
      if (logging) {
        {
#line 745
        fprintf(stdout, " (none)");
        }
      }
#line 745
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 747
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 747
    if (logging) {
      {
#line 747
      fprintf(stdout, ".\n");
      }
    }
#line 747
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 749
  free_curve(curve);
#line 750
  *curve = *trimmed_curve;
#line 751
  free(trimmed_curve);
  }
  return;
}
}
#line 757 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/fit.c"
static void filter(curve_type curve , fitting_opts_type *fitting_opts ) 
{ 
  unsigned int iteration ;
  unsigned int this_point ;
  unsigned int offset ;
  int tmp ;
  at_real_coord prev_new_point ;
  curve_type newcurve ;
  curve_type __cil_tmp9 ;
  gboolean collapsed ;
  vector_type in ;
  vector_type out ;
  vector_type sum ;
  at_real_coord new_point ;
  int prev ;
  int prevprev ;
  unsigned int next ;
  unsigned int nextnext ;
  at_real_coord candidate ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  vector_type __cil_tmp28 ;
  vector_type __cil_tmp29 ;
  vector_type __cil_tmp30 ;
  vector_type __cil_tmp31 ;
  vector_type __cil_tmp32 ;
  vector_type __cil_tmp33 ;
  vector_type __cil_tmp34 ;
  vector_type __cil_tmp35 ;
  vector_type __cil_tmp36 ;
  double __cil_tmp37 ;
  double __cil_tmp38 ;
  double __cil_tmp39 ;
  unsigned int __cil_tmp40 ;
  unsigned int __cil_tmp41 ;

  {
#line 760
  if (curve->cyclic == 1) {
#line 760
    tmp = 0;
  } else {
#line 760
    tmp = 1;
  }
#line 760
  offset = (unsigned int )tmp;
#line 767
  if (curve->length < 5U) {
    {
#line 768
    while (1) {
      while_continue: /* CIL Label */ ;
#line 768
      if (logging) {
        {
#line 768
        fprintf(stdout, "Length is %u, not enough to filter.\n", curve->length);
        }
      }
#line 768
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 769
    return;
  }
#line 772
  prev_new_point.x = 3.40282346639e+38f;
#line 773
  prev_new_point.y = 3.40282346639e+38f;
#line 774
  prev_new_point.z = 3.40282346639e+38f;
#line 776
  iteration = (unsigned int )0;
  {
#line 776
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 776
    if (! (iteration < fitting_opts->filter_iterations)) {
#line 776
      goto while_break___0;
    }
    {
#line 777
    __cil_tmp9 = copy_most_of_curve(curve);
#line 777
    newcurve = __cil_tmp9;
#line 778
    collapsed = 0;
    }
#line 781
    if (offset) {
      {
#line 782
      append_point(newcurve, (curve->point_list + 0)->coord);
      }
    }
#line 784
    this_point = offset;
    {
#line 784
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 784
      if (! (this_point < curve->length - offset)) {
#line 784
        goto while_break___1;
      }
#line 794
      candidate = (curve->point_list + this_point)->coord;
#line 796
      if ((int )this_point - 1 < 0) {
#line 796
        if (curve->cyclic) {
#line 796
          tmp___0 = ((int )curve->length + (int )this_point) - 1;
        } else {
#line 796
          tmp___0 = - 1;
        }
#line 796
        tmp___1 = tmp___0;
      } else {
#line 796
        tmp___1 = (int )this_point - 1;
      }
#line 796
      prev = tmp___1;
#line 797
      if ((int )prev - 1 < 0) {
#line 797
        if (curve->cyclic) {
#line 797
          tmp___2 = ((int )curve->length + (int )prev) - 1;
        } else {
#line 797
          tmp___2 = - 1;
        }
#line 797
        tmp___3 = tmp___2;
      } else {
#line 797
        tmp___3 = (int )prev - 1;
      }
#line 797
      prevprev = tmp___3;
#line 798
      if (this_point + 1U >= curve->length) {
#line 798
        if (curve->cyclic) {
#line 798
          tmp___4 = (this_point + 1U) % curve->length;
        } else {
#line 798
          tmp___4 = curve->length;
        }
#line 798
        tmp___5 = tmp___4;
      } else {
#line 798
        tmp___5 = this_point + 1U;
      }
#line 798
      next = tmp___5;
#line 799
      if (next + 1U >= curve->length) {
#line 799
        if (curve->cyclic) {
#line 799
          tmp___6 = (next + 1U) % curve->length;
        } else {
#line 799
          tmp___6 = curve->length;
        }
#line 799
        tmp___7 = tmp___6;
      } else {
#line 799
        tmp___7 = next + 1U;
      }
      {
#line 799
      nextnext = tmp___7;
#line 803
      in.dz = (gfloat )0.;
#line 803
      in.dy = in.dz;
#line 803
      in.dx = in.dy;
#line 805
      __cil_tmp28 = Psubtract((curve->point_list + prev)->coord, candidate);
#line 805
      __cil_tmp29 = Vadd(in, __cil_tmp28);
#line 805
      in = __cil_tmp29;
      }
#line 806
      if (prevprev >= 0) {
        {
#line 807
        __cil_tmp30 = Psubtract((curve->point_list + prevprev)->coord, candidate);
#line 807
        __cil_tmp31 = Vadd(in, __cil_tmp30);
#line 807
        in = __cil_tmp31;
        }
      }
      {
#line 811
      out.dz = (gfloat )0.;
#line 811
      out.dy = out.dz;
#line 811
      out.dx = out.dy;
#line 813
      __cil_tmp32 = Psubtract((curve->point_list + next)->coord, candidate);
#line 813
      __cil_tmp33 = Vadd(out, __cil_tmp32);
#line 813
      out = __cil_tmp33;
      }
#line 814
      if (nextnext < curve->length) {
        {
#line 815
        __cil_tmp34 = Psubtract((curve->point_list + nextnext)->coord, candidate);
#line 815
        __cil_tmp35 = Vadd(out, __cil_tmp34);
#line 815
        out = __cil_tmp35;
        }
      }
      {
#line 818
      new_point = candidate;
#line 819
      sum = Vadd(in, out);
#line 821
      new_point.x += sum.dx / (float )6;
#line 822
      new_point.y += sum.dy / (float )6;
#line 823
      new_point.z += sum.dz / (float )6;
#line 824
      __cil_tmp39 = fabs((double )(prev_new_point.z - new_point.z));
      }
      {
#line 824
      __cil_tmp38 = fabs((double )(prev_new_point.y - new_point.y));
      }
      {
#line 824
      __cil_tmp37 = fabs((double )(prev_new_point.x - new_point.x));
      }
#line 824
      if (__cil_tmp37 < 0.3) {
#line 824
        if (__cil_tmp38 < 0.3) {
#line 824
          if (__cil_tmp39 < 0.3) {
#line 825
            collapsed = ! 0;
#line 826
            goto while_break___1;
          }
        }
      }
      {
#line 831
      prev_new_point = new_point;
#line 831
      append_point(newcurve, prev_new_point);
      }
#line 784
      this_point ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 834
    if (collapsed) {
      {
#line 835
      free_curve(newcurve);
      }
    } else {
#line 838
      if (offset) {
        {
#line 839
        append_point(newcurve, (curve->point_list + (curve->length - 1U))->coord);
        }
      }
      {
#line 842
      free_curve(curve);
#line 843
      *curve = *newcurve;
      }
    }
    {
#line 845
    free(newcurve);
    }
#line 776
    iteration ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 848
  if (logging) {
    {
#line 849
    log_curve(curve, 0);
    }
  }
  return;
}
}
#line 857 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/fit.c"
static spline_list_type *fit_with_line(curve_type curve ) 
{ 
  spline_type line ;
  spline_list_type *__cil_tmp3 ;

  {
  {
#line 861
  while (1) {
    while_continue: /* CIL Label */ ;
#line 861
    if (logging) {
      {
#line 861
      fprintf(stdout, "Fitting with straight line:\n");
      }
    }
#line 861
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 863
  line.degree = (at_polynomial_degree )1;
#line 864
  line.v[1] = (curve->point_list + 0)->coord;
#line 864
  line.v[0] = line.v[1];
#line 865
  line.v[2] = (curve->point_list + (curve->length - 1U))->coord;
#line 865
  line.v[3] = line.v[2];
#line 868
  line.linearity = (gfloat )0;
#line 870
  if (logging) {
    {
#line 871
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 871
      if (logging) {
        {
#line 871
        fprintf(stdout, "  ");
        }
      }
#line 871
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 872
    print_spline(line);
    }
  }
  {
#line 875
  __cil_tmp3 = new_spline_list_with_spline(line);
  }
#line 875
  return (__cil_tmp3);
}
}
#line 882 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/fit.c"
static spline_list_type *fit_with_least_squares(curve_type curve , fitting_opts_type *fitting_opts ,
                                                at_exception_type *exception ) 
{ 
  gfloat error ;
  gfloat best_error ;
  spline_type spline ;
  spline_type best_spline ;
  spline_list_type *spline_list ;
  unsigned int worst_point ;
  gfloat previous_error ;
  spline_type __cil_tmp11 ;
  gboolean __cil_tmp12 ;
  gfloat __cil_tmp13 ;
  spline_list_type *__cil_tmp14 ;
  gboolean __cil_tmp15 ;
  spline_list_type *__cil_tmp16 ;
  unsigned int subdivision_index ;
  spline_list_type *left_spline_list ;
  spline_list_type *right_spline_list ;
  curve_type left_curve ;
  curve_type __cil_tmp21 ;
  curve_type right_curve ;
  curve_type __cil_tmp23 ;
  spline_list_type *__cil_tmp24 ;
  gboolean __cil_tmp25 ;
  spline_list_type *__cil_tmp26 ;
  gboolean __cil_tmp27 ;
  spline_list_type *__cil_tmp28 ;

  {
#line 884
  error = (gfloat )0;
#line 884
  best_error = 3.40282346639e+38f;
#line 886
  spline_list = (spline_list_type *)((void *)0);
#line 887
  worst_point = (unsigned int )0;
#line 888
  previous_error = 3.40282346639e+38f;
  {
#line 890
  while (1) {
    while_continue: /* CIL Label */ ;
#line 890
    if (logging) {
      {
#line 890
      fprintf(stdout, "\nFitting with least squares:\n");
      }
    }
#line 890
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 900
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 900
    if (logging) {
      {
#line 900
      fprintf(stdout, "Finding tangents:\n");
      }
    }
#line 900
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 901
  find_tangent(curve, ! 0, 0, fitting_opts->tangent_surround);
#line 903
  find_tangent(curve, 0, 0, fitting_opts->tangent_surround);
#line 906
  set_initial_parameter_values(curve);
  }
  {
#line 910
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 911
    spline = fit_one_spline(curve, exception);
#line 912
    __cil_tmp12 = at_exception_got_fatal(exception);
    }
#line 912
    if (__cil_tmp12) {
#line 913
      goto cleanup;
    }
#line 915
    if ((unsigned int )spline.degree == 1U) {
      {
#line 916
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 916
        if (logging) {
          {
#line 916
          fprintf(stdout, "  fitted to line:\n");
          }
        }
#line 916
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
      {
#line 918
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 918
        if (logging) {
          {
#line 918
          fprintf(stdout, "  fitted to spline:\n");
          }
        }
#line 918
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 920
    if (logging) {
      {
#line 921
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 921
        if (logging) {
          {
#line 921
          fprintf(stdout, "    ");
          }
        }
#line 921
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 922
      print_spline(spline);
      }
    }
#line 925
    if ((unsigned int )spline.degree == 1U) {
#line 926
      goto while_break___1;
    }
    {
#line 928
    error = find_error(curve, spline, & worst_point, exception);
    }
#line 929
    if (error <= previous_error) {
#line 930
      best_error = error;
#line 931
      best_spline = spline;
    }
#line 933
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 936
  if ((unsigned int )spline.degree == 1U) {
    {
#line 937
    spline_list = new_spline_list_with_spline(spline);
    }
    {
#line 938
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 938
      if (logging) {
        {
#line 938
        fprintf(stdout, "Accepted error of %.3f.\n\230\001", (double )error);
        }
      }
#line 938
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 939
    return (spline_list);
  }
#line 943
  spline = best_spline;
#line 944
  error = best_error;
#line 946
  if (error < fitting_opts->error_threshold) {
#line 946
    if (curve->cyclic == 0) {
      {
#line 951
      __cil_tmp15 = spline_linear_enough(& spline, curve, fitting_opts);
      }
#line 951
      if (__cil_tmp15) {
#line 952
        spline.degree = (at_polynomial_degree )1;
        {
#line 953
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 953
          if (logging) {
            {
#line 953
            fprintf(stdout, "Changed to line.\n");
            }
          }
#line 953
          goto while_break___6;
        }
        while_break___6: /* CIL Label */ ;
        }
      }
      {
#line 955
      spline_list = new_spline_list_with_spline(spline);
      }
      {
#line 956
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 956
        if (logging) {
          {
#line 956
          fprintf(stdout, "Accepted error of %.3f.\n\230\001", (double )error);
          }
        }
#line 956
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
    } else {
#line 946
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 962
    __cil_tmp21 = new_curve();
#line 962
    left_curve = __cil_tmp21;
#line 963
    __cil_tmp23 = new_curve();
#line 963
    right_curve = __cil_tmp23;
#line 966
    right_curve->next = curve->next;
#line 967
    right_curve->previous = left_curve;
#line 968
    left_curve->next = right_curve;
#line 969
    left_curve->previous = curve;
#line 970
    curve->next = left_curve;
    }
    {
#line 972
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 972
      if (logging) {
        {
#line 972
        fprintf(stdout, "\nSubdividing (error %.3f):\n", (double )error);
        }
      }
#line 972
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 973
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 973
      if (logging) {
        {
#line 973
        fprintf(stdout, "  Original point: (%.3f,%.3f), #%u.\n", (double )(curve->point_list + worst_point)->coord.x,
                (double )(curve->point_list + worst_point)->coord.y, worst_point);
        }
      }
#line 973
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 974
    subdivision_index = worst_point;
    {
#line 975
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 975
      if (logging) {
        {
#line 975
        fprintf(stdout, "  Final point: (%.3f,%.3f), #%u.\n", (double )(curve->point_list + subdivision_index)->coord.x,
                (double )(curve->point_list + subdivision_index)->coord.y, subdivision_index);
        }
      }
#line 975
      goto while_break___10;
    }
    while_break___10: /* CIL Label */ ;
    }
    {
#line 979
    left_curve->length = subdivision_index + 1U;
#line 980
    right_curve->length = curve->length - subdivision_index;
#line 981
    left_curve->point_list = curve->point_list;
#line 982
    right_curve->point_list = curve->point_list + subdivision_index;
#line 987
    left_curve->start_tangent = curve->start_tangent;
#line 988
    right_curve->end_tangent = curve->end_tangent;
#line 995
    find_tangent(left_curve, 0, ! 0, fitting_opts->tangent_surround);
#line 997
    right_curve->start_tangent = left_curve->end_tangent;
#line 1000
    left_spline_list = fit_curve(left_curve, fitting_opts, exception);
#line 1001
    __cil_tmp25 = at_exception_got_fatal(exception);
    }
#line 1001
    if (__cil_tmp25) {
#line 1004
      goto cleanup;
    }
    {
#line 1006
    right_spline_list = fit_curve(right_curve, fitting_opts, exception);
#line 1009
    __cil_tmp27 = at_exception_got_fatal(exception);
    }
#line 1009
    if (__cil_tmp27) {
#line 1010
      goto cleanup;
    }
#line 1013
    if (left_spline_list == (void *)0) {
#line 1013
      if (right_spline_list == (void *)0) {
#line 1014
        return ((spline_list_type *)((void *)0));
      }
    }
    {
#line 1017
    spline_list = new_spline_list();
    }
#line 1019
    if (left_spline_list == (void *)0) {
      {
#line 1020
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 1020
        if (logging) {
          {
#line 1020
          fprintf(stdout, "Could not fit spline to left curve (%lx).\n", (unsigned long )left_curve);
          }
        }
#line 1020
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
      {
#line 1021
      at_exception_warning(exception, (gchar *)"Could not fit left spline list");
      }
    } else {
      {
#line 1023
      concat_spline_lists(spline_list, *left_spline_list);
#line 1024
      free_spline_list(*left_spline_list);
#line 1025
      free(left_spline_list);
      }
    }
#line 1028
    if (right_spline_list == (void *)0) {
      {
#line 1029
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 1029
        if (logging) {
          {
#line 1029
          fprintf(stdout, "Could not fit spline to right curve (%lx).\n", (unsigned long )right_curve);
          }
        }
#line 1029
        goto while_break___12;
      }
      while_break___12: /* CIL Label */ ;
      }
      {
#line 1030
      at_exception_warning(exception, (gchar *)"Could not fit right spline list");
      }
    } else {
      {
#line 1032
      concat_spline_lists(spline_list, *right_spline_list);
#line 1033
      free_spline_list(*right_spline_list);
#line 1034
      free(right_spline_list);
      }
    }
#line 1036
    if (left_curve->end_tangent) {
      {
#line 1037
      free(left_curve->end_tangent);
      }
    }
    {
#line 1038
    free(left_curve);
#line 1039
    free(right_curve);
    }
  }
  cleanup: 
#line 1042
  return (spline_list);
}
}
#line 1065 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/fit.c"
static spline_type fit_one_spline(curve_type curve , at_exception_type *exception ) 
{ 
  gfloat X_C1_det ;
  gfloat C0_X_det ;
  gfloat C0_C1_det ;
  gfloat alpha1 ;
  gfloat alpha2 ;
  spline_type spline ;
  vector_type start_vector ;
  vector_type end_vector ;
  unsigned int i ;
  vector_type *A ;
  vector_type t1_hat ;
  vector_type t2_hat ;
  gfloat C[2][2] ;
  gfloat X[2] ;
  void *__cil_tmp17 ;
  int tmp ;
  vector_type __cil_tmp19 ;
  vector_type __cil_tmp20 ;
  vector_type __cil_tmp21 ;
  vector_type __cil_tmp22 ;
  unsigned int __cil_tmp23 ;
  vector_type temp ;
  vector_type temp0 ;
  vector_type temp1 ;
  vector_type temp2 ;
  vector_type temp3 ;
  vector_type *Ai ;
  gfloat __cil_tmp30 ;
  gfloat __cil_tmp31 ;
  gfloat __cil_tmp32 ;
  vector_type __cil_tmp33 ;
  vector_type __cil_tmp34 ;
  vector_type __cil_tmp35 ;
  vector_type __cil_tmp36 ;
  vector_type __cil_tmp37 ;
  vector_type __cil_tmp38 ;
  vector_type __cil_tmp39 ;
  at_real_coord __cil_tmp40 ;
  vector_type __cil_tmp41 ;
  gfloat __cil_tmp42 ;
  gfloat __cil_tmp43 ;
  unsigned int __cil_tmp44 ;
  vector_type __cil_tmp45 ;
  at_real_coord __cil_tmp46 ;
  vector_type __cil_tmp47 ;
  at_real_coord __cil_tmp48 ;

  {
#line 1075
  t1_hat = *(curve->start_tangent);
#line 1076
  t2_hat = *(curve->end_tangent);
#line 1077
  C[0][0] = (gfloat )0.;
#line 1077
  C[0][1] = (gfloat )0.;
#line 1077
  C[1][0] = (gfloat )0.;
#line 1077
  C[1][1] = (gfloat )0.;
#line 1078
  X[0] = (gfloat )0.;
#line 1078
  X[1] = (gfloat )0.;
  {
#line 1080
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1080
    __cil_tmp17 = malloc((unsigned long )(curve->length * 2U) * sizeof(vector_type ));
#line 1080
    A = (gpointer )__cil_tmp17;
    }
#line 1080
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1082
  spline.v[0] = (curve->point_list + 0)->coord;
#line 1083
  spline.v[3] = (curve->point_list + (curve->length - 1U))->coord;
#line 1084
  start_vector = make_vector(spline.v[0]);
#line 1085
  end_vector = make_vector(spline.v[3]);
#line 1087
  i = (unsigned int )0;
  }
  {
#line 1087
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1087
    if (! (i < curve->length)) {
#line 1087
      goto while_break___0;
    }
    {
#line 1088
    *(A + (i << 1)) = Vmult_scalar(t1_hat, ((gfloat )3. * (curve->point_list + i)->t) * (((gfloat )1. - (curve->point_list + i)->t) * ((gfloat )1. - (curve->point_list + i)->t)));
#line 1089
    *(A + ((i << 1) + 1U)) = Vmult_scalar(t2_hat, ((gfloat )3. * ((curve->point_list + i)->t * (curve->point_list + i)->t)) * ((gfloat )1. - (curve->point_list + i)->t));
    }
#line 1087
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1092
  i = (unsigned int )0;
  {
#line 1092
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1092
    if (! (i < curve->length)) {
#line 1092
      goto while_break___1;
    }
    {
#line 1094
    Ai = A + (i << 1);
#line 1096
    __cil_tmp30 = Vdot(*(Ai + 0), *(Ai + 0));
    }
    {
#line 1096
    C[0][0] += __cil_tmp30;
#line 1097
    __cil_tmp31 = Vdot(*(Ai + 0), *(Ai + 1));
    }
    {
#line 1097
    C[0][1] += __cil_tmp31;
#line 1099
    __cil_tmp32 = Vdot(*(Ai + 1), *(Ai + 1));
    }
    {
#line 1099
    C[1][1] += __cil_tmp32;
#line 1102
    temp0 = Vmult_scalar(start_vector, (((gfloat )1. - (curve->point_list + i)->t) * ((gfloat )1. - (curve->point_list + i)->t)) * ((gfloat )1. - (curve->point_list + i)->t));
#line 1103
    temp1 = Vmult_scalar(start_vector, ((gfloat )3. * (curve->point_list + i)->t) * (((gfloat )1. - (curve->point_list + i)->t) * ((gfloat )1. - (curve->point_list + i)->t)));
#line 1104
    temp2 = Vmult_scalar(end_vector, ((gfloat )3. * ((curve->point_list + i)->t * (curve->point_list + i)->t)) * ((gfloat )1. - (curve->point_list + i)->t));
#line 1105
    temp3 = Vmult_scalar(end_vector, ((curve->point_list + i)->t * (curve->point_list + i)->t) * (curve->point_list + i)->t);
#line 1107
    __cil_tmp37 = Vadd(temp2, temp3);
#line 1107
    __cil_tmp38 = Vadd(temp1, __cil_tmp37);
#line 1107
    __cil_tmp39 = Vadd(temp0, __cil_tmp38);
#line 1107
    __cil_tmp40 = Vsubtract_point((curve->point_list + i)->coord, __cil_tmp39);
#line 1107
    __cil_tmp41 = make_vector(__cil_tmp40);
#line 1107
    temp = __cil_tmp41;
#line 1109
    __cil_tmp42 = Vdot(temp, *(Ai + 0));
    }
    {
#line 1109
    X[0] += __cil_tmp42;
#line 1110
    __cil_tmp43 = Vdot(temp, *(Ai + 1));
    }
#line 1110
    X[1] += __cil_tmp43;
#line 1092
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1112
  free(A);
#line 1114
  C[1][0] = C[0][1];
#line 1116
  X_C1_det = X[0] * C[1][1] - X[1] * C[0][1];
#line 1117
  C0_X_det = C[0][0] * X[1] - C[0][1] * X[0];
#line 1118
  C0_C1_det = C[0][0] * C[1][1] - C[1][0] * C[0][1];
  }
#line 1119
  if ((double )C0_C1_det == 0.) {
#line 1121
    alpha1 = (gfloat )0;
#line 1122
    alpha2 = (gfloat )0;
  } else {
#line 1124
    alpha1 = X_C1_det / C0_C1_det;
#line 1125
    alpha2 = C0_X_det / C0_C1_det;
  }
  {
#line 1127
  __cil_tmp45 = Vmult_scalar(t1_hat, alpha1);
#line 1127
  __cil_tmp46 = Vadd_point(spline.v[0], __cil_tmp45);
#line 1127
  spline.v[1] = __cil_tmp46;
#line 1128
  __cil_tmp47 = Vmult_scalar(t2_hat, alpha2);
#line 1128
  __cil_tmp48 = Vadd_point(spline.v[3], __cil_tmp47);
#line 1128
  spline.v[2] = __cil_tmp48;
#line 1129
  spline.degree = (at_polynomial_degree )3;
  }
#line 1131
  return (spline);
}
}
#line 1140 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/fit.c"
static void set_initial_parameter_values(curve_type curve ) 
{ 
  unsigned int p ;
  at_real_coord point ;
  at_real_coord previous_p ;
  gfloat d ;
  gfloat __cil_tmp6 ;
  unsigned int __cil_tmp7 ;
  unsigned int __cil_tmp8 ;

  {
  {
#line 1144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1144
    if (logging) {
      {
#line 1144
      fprintf(stdout, "\nAssigning initial t values:\n  ");
      }
    }
#line 1144
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1146
  (curve->point_list + 0)->t = (gfloat )0.;
#line 1148
  p = (unsigned int )1;
  {
#line 1148
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1148
    if (! (p < curve->length)) {
#line 1148
      goto while_break___0;
    }
#line 1149
    point = (curve->point_list + p)->coord;
    {
#line 1149
    previous_p = (curve->point_list + (p - 1U))->coord;
#line 1150
    __cil_tmp6 = distance(point, previous_p);
#line 1150
    d = __cil_tmp6;
#line 1151
    (curve->point_list + p)->t = (curve->point_list + (p - 1U))->t + d;
    }
#line 1148
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1154
  if ((double )(curve->point_list + (curve->length - 1U))->t == 0.) {
#line 1155
    (curve->point_list + (curve->length - 1U))->t = (gfloat )1.;
  }
#line 1157
  p = (unsigned int )1;
  {
#line 1157
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1157
    if (! (p < curve->length)) {
#line 1157
      goto while_break___1;
    }
#line 1158
    (curve->point_list + p)->t /= (curve->point_list + (curve->length - 1U))->t;
#line 1157
    p ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1160
  if (logging) {
    {
#line 1161
    log_entire_curve(curve);
    }
  }
  return;
}
}
#line 1173 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/fit.c"
static void find_tangent(curve_type curve , gboolean to_start_point , gboolean cross_curve ,
                         unsigned int tangent_surround ) 
{ 
  vector_type tangent ;
  vector_type **curve_tangent ;
  vector_type **tmp ;
  unsigned int n_points ;
  char const   *tmp___0 ;
  void *__cil_tmp10 ;
  int tmp___1 ;
  vector_type __cil_tmp12 ;
  curve_type adjacent_curve ;
  struct curve *tmp___2 ;
  vector_type tangent2 ;
  vector_type __cil_tmp16 ;
  vector_type __cil_tmp17 ;
  vector_type tmp___3 ;
  vector_type __cil_tmp19 ;
  unsigned int __cil_tmp20 ;
  int tmp___4 ;
  vector_type __cil_tmp22 ;

  {
#line 1176
  if (to_start_point == 1) {
#line 1176
    tmp = & curve->start_tangent;
  } else {
#line 1176
    tmp = & curve->end_tangent;
  }
#line 1176
  curve_tangent = tmp;
#line 1178
  n_points = (unsigned int )0;
  {
#line 1180
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1180
    if (logging) {
#line 1180
      if (to_start_point == 1) {
#line 1180
        tmp___0 = "start";
      } else {
#line 1180
        tmp___0 = "end";
      }
      {
#line 1180
      fprintf(stdout, "  tangent to %s: ", tmp___0);
      }
    }
#line 1180
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1182
  if (*curve_tangent == (void *)0) {
    {
#line 1183
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1183
      __cil_tmp10 = malloc(sizeof(vector_type ));
#line 1183
      *curve_tangent = (gpointer )__cil_tmp10;
      }
#line 1183
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1184
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1185
      tangent = find_half_tangent(curve, to_start_point, & n_points, tangent_surround);
      }
#line 1187
      if (cross_curve == 1) {
        _L: /* CIL Label */ 
#line 1188
        if (to_start_point == 1) {
#line 1188
          tmp___2 = curve->previous;
        } else {
#line 1188
          tmp___2 = curve->next;
        }
#line 1188
        adjacent_curve = tmp___2;
#line 1189
        if (to_start_point == 0) {
          {
#line 1189
          __cil_tmp16 = find_half_tangent(adjacent_curve, ! 0, & n_points, tangent_surround);
#line 1189
          tmp___3 = __cil_tmp16;
          }
        } else {
          {
#line 1189
          __cil_tmp17 = find_half_tangent(adjacent_curve, ! 0, & n_points, tangent_surround);
#line 1189
          tmp___3 = __cil_tmp17;
          }
        }
#line 1189
        tangent2 = tmp___3;
        {
#line 1193
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1193
          if (logging) {
            {
#line 1193
            fprintf(stdout, "(adjacent curve half tangent (%.3f,%.3f,%.3f)) ", (double )tangent2.dx,
                    (double )tangent2.dy, (double )tangent2.dz);
            }
          }
#line 1193
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 1194
        tangent = Vadd(tangent, tangent2);
        }
      } else
#line 1187
      if (curve->cyclic == 1) {
#line 1187
        goto _L;
      }
#line 1196
      __cil_tmp20 = tangent_surround;
#line 1196
      tangent_surround --;
#line 1184
      if (! ((double )tangent.dx == 0. && (double )tangent.dy == 0.)) {
#line 1184
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1202
    *(*curve_tangent) = Vmult_scalar(tangent, (gfloat )(1. / (double )n_points));
    }
#line 1203
    if (curve->start_tangent) {
#line 1203
      if (curve->cyclic == 1) {
#line 1204
        *(curve->start_tangent) = *(*curve_tangent);
      }
    }
#line 1205
    if (curve->end_tangent) {
#line 1205
      if (curve->cyclic == 1) {
#line 1206
        *(curve->end_tangent) = *(*curve_tangent);
      }
    }
  } else {
    {
#line 1208
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1208
      if (logging) {
        {
#line 1208
        fprintf(stdout, "(already computed) ");
        }
      }
#line 1208
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  {
#line 1210
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1210
    if (logging) {
      {
#line 1210
      fprintf(stdout, "(%.3f,%.3f,%.3f).\n\202\n\027V", (double )(*curve_tangent)->dx,
              (double )(*curve_tangent)->dy, (double )(*curve_tangent)->dz);
      }
    }
#line 1210
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  return;
}
}
#line 1217 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/fit.c"
static vector_type find_half_tangent(curve_type c , gboolean to_start_point , unsigned int *n_points ,
                                     unsigned int tangent_surround ) 
{ 
  unsigned int p ;
  int factor ;
  int tmp ;
  unsigned int tangent_index ;
  unsigned int tmp___0 ;
  at_real_coord tangent_point ;
  vector_type tangent ;
  unsigned int surround ;
  int this_index ;
  at_real_coord this_point ;
  vector_type __cil_tmp15 ;
  vector_type __cil_tmp16 ;
  vector_type __cil_tmp17 ;
  unsigned int __cil_tmp18 ;
  unsigned int __cil_tmp19 ;

  {
#line 1220
  if (to_start_point) {
#line 1220
    tmp = 1;
  } else {
#line 1220
    tmp = - 1;
  }
#line 1220
  factor = tmp;
#line 1221
  if (to_start_point) {
#line 1221
    tmp___0 = (unsigned int )0;
  } else {
#line 1221
    tmp___0 = c->length - 1U;
  }
#line 1221
  tangent_index = tmp___0;
#line 1222
  tangent_point = (c->point_list + tangent_index)->coord;
#line 1223
  tangent.dx = (gfloat )0.;
#line 1223
  tangent.dy = (gfloat )0.;
#line 1223
  tangent.dz = 0.f;
#line 1226
  surround = c->length / 2U;
#line 1226
  if (surround > tangent_surround) {
#line 1227
    surround = tangent_surround;
  }
#line 1229
  p = (unsigned int )1;
  {
#line 1229
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1229
    if (! (p <= surround)) {
#line 1229
      goto while_break;
    }
#line 1230
    this_index = (int )(p * (unsigned int )factor + tangent_index);
#line 1233
    if (this_index < 0) {
#line 1234
      goto while_break;
    } else
#line 1233
    if (this_index >= (int )c->length) {
#line 1234
      goto while_break;
    }
    {
#line 1236
    this_point = (c->point_list + (p * (unsigned int )factor + tangent_index))->coord;
#line 1240
    __cil_tmp15 = Psubtract(this_point, tangent_point);
#line 1240
    __cil_tmp16 = Vmult_scalar(__cil_tmp15, (gfloat )factor);
#line 1240
    __cil_tmp17 = Vadd(tangent, __cil_tmp16);
#line 1240
    tangent = __cil_tmp17;
#line 1241
    (*n_points) ++;
    }
#line 1229
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1244
  return (tangent);
}
}
#line 1255 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/fit.c"
static gfloat find_error(curve_type curve , spline_type spline , unsigned int *worst_point ,
                         at_exception_type *exception ) 
{ 
  unsigned int this_point ;
  gfloat total_error ;
  gfloat worst_error ;
  at_real_coord curve_point ;
  gfloat t ;
  at_real_coord spline_point ;
  at_real_coord __cil_tmp11 ;
  gfloat this_error ;
  gfloat __cil_tmp13 ;
  unsigned int __cil_tmp14 ;
  gboolean __cil_tmp15 ;
  gboolean __cil_tmp16 ;

  {
#line 1258
  total_error = (gfloat )0.;
#line 1259
  worst_error = 1.17549435083e-38f;
#line 1261
  *worst_point = curve->length + 1U;
#line 1263
  this_point = (unsigned int )0;
  {
#line 1263
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1263
    if (! (this_point < curve->length)) {
#line 1263
      goto while_break;
    }
    {
#line 1264
    curve_point = (curve->point_list + this_point)->coord;
#line 1265
    t = (curve->point_list + this_point)->t;
#line 1266
    __cil_tmp11 = evaluate_spline(spline, t);
#line 1266
    spline_point = __cil_tmp11;
#line 1267
    __cil_tmp13 = distance(curve_point, spline_point);
#line 1267
    this_error = __cil_tmp13;
    }
#line 1268
    if (this_error >= worst_error) {
#line 1269
      *worst_point = this_point;
#line 1270
      worst_error = this_error;
    }
#line 1272
    total_error += this_error;
#line 1263
    this_point ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1275
  if (*worst_point == curve->length + 1U) {
    {
#line 1276
    __cil_tmp15 = epsilon_equal(total_error, (gfloat )0.);
    }
#line 1276
    if (__cil_tmp15) {
      {
#line 1277
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1277
        if (logging) {
          {
#line 1277
          fprintf(stdout, "  Every point fit perfectly.\n");
          }
        }
#line 1277
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 1279
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1279
        if (logging) {
          {
#line 1279
          fprintf(stdout, "No worst point found; something is wrong\220");
          }
        }
#line 1279
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 1280
      at_exception_warning(exception, (gchar *)"No worst point found; something is wrong\220");
      }
    }
  } else {
    {
#line 1283
    __cil_tmp16 = epsilon_equal(total_error, (gfloat )0.);
    }
#line 1283
    if (__cil_tmp16) {
      {
#line 1284
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1284
        if (logging) {
          {
#line 1284
          fprintf(stdout, "  Every point fit perfectly.\n");
          }
        }
#line 1284
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
      {
#line 1286
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1286
        if (logging) {
          {
#line 1286
          fprintf(stdout, "  Worst error (at (%.3f,%.3f,%.3f), point #%u) was %.3f.\n",
                  (double )(curve->point_list + *worst_point)->coord.x, (double )(curve->point_list + *worst_point)->coord.y,
                  (double )(curve->point_list + *worst_point)->coord.z, *worst_point,
                  (double )worst_error);
          }
        }
#line 1286
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 1287
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1287
        if (logging) {
          {
#line 1287
          fprintf(stdout, "  Total error was %.3f.\n\230\001", (double )total_error);
          }
        }
#line 1287
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 1288
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1288
        if (logging) {
          {
#line 1288
          fprintf(stdout, "  Average error (over %u points) was %.3f.\n", curve->length,
                  (double )(total_error / (float )curve->length));
          }
        }
#line 1288
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
  }
#line 1292
  return (worst_error);
}
}
#line 1298 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/fit.c"
static gboolean spline_linear_enough(spline_type *spline , curve_type curve , fitting_opts_type *fitting_opts ) 
{ 
  gfloat A ;
  gfloat B ;
  gfloat C ;
  unsigned int this_point ;
  gfloat dist ;
  gfloat start_end_dist ;
  gfloat threshold ;
  double __cil_tmp11 ;
  gfloat a ;
  gfloat b ;
  gfloat c ;
  gfloat w ;
  gfloat t ;
  at_real_coord spline_point ;
  at_real_coord __cil_tmp18 ;
  double __cil_tmp19 ;
  unsigned int __cil_tmp20 ;

  {
#line 1302
  dist = (gfloat )0.;
  {
#line 1304
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1304
    if (logging) {
      {
#line 1304
      fprintf(stdout, "Checking linearity:\n");
      }
    }
#line 1304
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1306
  A = spline->v[3].x - spline->v[0].x;
#line 1307
  B = spline->v[3].y - spline->v[0].y;
#line 1308
  C = spline->v[3].z - spline->v[0].z;
#line 1310
  start_end_dist = (gfloat )((A * A + B * B) + C * C);
  {
#line 1311
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1311
    if (logging) {
      {
#line 1311
      __cil_tmp11 = sqrt((double )start_end_dist);
#line 1311
      fprintf(stdout, "start_end_distance is %.3f.\n\323\210", __cil_tmp11);
      }
    }
#line 1311
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1313
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1313
    if (logging) {
      {
#line 1313
      fprintf(stdout, "  Line endpoints are (%.3f, %.3f, %.3f) and 1", (double )spline->v[0].x,
              (double )spline->v[0].y, (double )spline->v[0].z);
      }
    }
#line 1313
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1314
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1314
    if (logging) {
      {
#line 1314
      fprintf(stdout, "(%.3f, %.3f, %.3f)\n", (double )spline->v[3].x, (double )spline->v[3].y,
              (double )spline->v[3].z);
      }
    }
#line 1314
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1318
  this_point = (unsigned int )0;
  {
#line 1318
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1318
    if (! (this_point < curve->length)) {
#line 1318
      goto while_break___3;
    }
    {
#line 1320
    t = (curve->point_list + this_point)->t;
#line 1321
    __cil_tmp18 = evaluate_spline(*spline, t);
#line 1321
    spline_point = __cil_tmp18;
#line 1323
    a = spline_point.x - spline->v[0].x;
#line 1324
    b = spline_point.y - spline->v[0].y;
#line 1325
    c = spline_point.z - spline->v[0].z;
#line 1326
    w = ((A * a + B * b) + C * c) / start_end_dist;
#line 1328
    __cil_tmp19 = sqrt((double )(((a - A * w) * (a - A * w) + (b - B * w) * (b - B * w)) + (c - C * w) * (c - C * w)));
    }
#line 1328
    dist += (gfloat )__cil_tmp19;
#line 1318
    this_point ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 1330
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1330
    if (logging) {
      {
#line 1330
      fprintf(stdout, "  Total distance is %.3f, ", (double )dist);
      }
    }
#line 1330
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1332
  dist /= (float )(curve->length - 1U);
  {
#line 1333
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 1333
    if (logging) {
      {
#line 1333
      fprintf(stdout, "which is %.3f normalized.\n\002", (double )dist);
      }
    }
#line 1333
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 1338
  spline->linearity = dist;
  {
#line 1339
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 1339
    if (logging) {
      {
#line 1339
      fprintf(stdout, "  Final linearity: %.3f.\n:\003", (double )spline->linearity);
      }
    }
#line 1339
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 1340
  if (start_end_dist * (gfloat )0.5 > fitting_opts->line_threshold) {
#line 1341
    threshold = fitting_opts->line_threshold;
  } else {
#line 1343
    threshold = start_end_dist * (gfloat )0.5;
  }
  {
#line 1344
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 1344
    if (logging) {
      {
#line 1344
      fprintf(stdout, "threshold is %.3f .\n\204\031\004", (double )threshold);
      }
    }
#line 1344
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 1345
  if (dist < threshold) {
#line 1346
    return (! 0);
  } else {
#line 1348
    return (0);
  }
}
}
#line 1359 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/fit.c"
static void change_bad_lines(spline_list_type *spline_list , fitting_opts_type *fitting_opts ) 
{ 
  unsigned int this_spline ;
  gboolean found_cubic ;
  unsigned int length ;
  unsigned int __cil_tmp6 ;
  spline_type s ;
  unsigned int __cil_tmp8 ;

  {
#line 1362
  found_cubic = 0;
#line 1363
  length = spline_list->length;
  {
#line 1365
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1365
    if (logging) {
      {
#line 1365
      fprintf(stdout, "\nChecking for bad lines (length %u):\nf\005", length);
      }
    }
#line 1365
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1368
  this_spline = (unsigned int )0;
  {
#line 1368
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1368
    if (! (this_spline < length)) {
#line 1368
      goto while_break___0;
    }
#line 1369
    if ((unsigned int )(spline_list->data + this_spline)->degree == 3U) {
#line 1370
      found_cubic = ! 0;
#line 1371
      goto while_break___0;
    }
#line 1368
    this_spline ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1378
  if (found_cubic) {
#line 1379
    this_spline = (unsigned int )0;
    {
#line 1379
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1379
      if (! (this_spline < length)) {
#line 1379
        goto while_break___1;
      }
#line 1380
      s = *(spline_list->data + this_spline);
#line 1382
      if ((unsigned int )s.degree == 1U) {
        {
#line 1383
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1383
          if (logging) {
            {
#line 1383
            fprintf(stdout, "  #%u: ", this_spline);
            }
          }
#line 1383
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 1384
        if (s.linearity > fitting_opts->line_reversion_threshold) {
          {
#line 1385
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 1385
            if (logging) {
              {
#line 1385
              fprintf(stdout, "reverted, \006");
              }
            }
#line 1385
            goto while_break___3;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 1386
          (spline_list->data + this_spline)->degree = (at_polynomial_degree )3;
        }
        {
#line 1389
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 1389
          if (logging) {
            {
#line 1389
            fprintf(stdout, "linearity %.3f.\n\230\001", (double )s.linearity);
            }
          }
#line 1389
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
#line 1379
      this_spline ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
    {
#line 1392
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1392
      if (logging) {
        {
#line 1392
        fprintf(stdout, "  No lines.\n\320");
        }
      }
#line 1392
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
  return;
}
}
#line 1397 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/fit.c"
static index_list_type new_index_list(void) 
{ 
  index_list_type index_list ;

  {
#line 1401
  index_list.data = (unsigned int *)((void *)0);
#line 1402
  index_list.length = (unsigned int )0;
#line 1404
  return (index_list);
}
}
#line 1407 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/fit.c"
static void free_index_list(index_list_type *index_list ) 
{ 


  {
#line 1409
  if (index_list->length > 0U) {
    {
#line 1410
    free(index_list->data);
#line 1411
    index_list->data = (unsigned int *)((void *)0);
#line 1412
    index_list->length = (unsigned int )0;
    }
  }
  return;
}
}
#line 1416 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/fit.c"
static void append_index(index_list_type *list , unsigned int new_index ) 
{ 
  unsigned int __cil_tmp3 ;
  gpointer new_mem ;
  void *__cil_tmp5 ;
  int tmp ;
  void *__cil_tmp7 ;
  int tmp___0 ;

  {
#line 1418
  (list->length) ++;
  {
#line 1419
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1419
    if (list->data == (void *)0) {
      {
#line 1419
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 1419
        __cil_tmp5 = malloc((unsigned long )list->length * sizeof(unsigned int ));
#line 1419
        new_mem = (gpointer )__cil_tmp5;
        }
#line 1419
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 1419
      __cil_tmp7 = realloc(list->data, (unsigned long )list->length * sizeof(unsigned int ));
#line 1419
      new_mem = (gpointer )__cil_tmp7;
      }
    }
#line 1419
    list->data = new_mem;
#line 1419
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1420
  *(list->data + (list->length - 1U)) = new_index;
  return;
}
}
#line 1425 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/fit.c"
static at_coord real_to_int_coord(at_real_coord real_coord ) 
{ 
  at_coord int_coord ;
  long __cil_tmp3 ;
  long __cil_tmp4 ;

  {
  {
#line 1429
  __cil_tmp3 = lround((double )real_coord.x);
#line 1429
  int_coord.x = (gushort )__cil_tmp3;
#line 1430
  __cil_tmp4 = lround((double )real_coord.y);
#line 1430
  int_coord.y = (gushort )__cil_tmp4;
  }
#line 1432
  return (int_coord);
}
}
#line 1437 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/fit.c"
static gfloat distance(at_real_coord p1 , at_real_coord p2 ) 
{ 
  gfloat x ;
  gfloat y ;
  gfloat z ;
  double __cil_tmp6 ;

  {
#line 1439
  x = p1.x - p2.x;
#line 1439
  y = p1.y - p2.y;
  {
#line 1439
  z = p1.z - p2.z;
#line 1440
  __cil_tmp6 = sqrt((double )((x * x + y * y) + z * z));
  }
#line 1440
  return ((gfloat )__cil_tmp6);
}
}
#line 149 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 181
__inline extern int open(char const   *__path , int __oflag  , ...)  __attribute__((__gnu_inline__)) ;
#line 205
__inline extern int openat(int __fd , char const   *__path , int __oflag  , ...)  __attribute__((__gnu_inline__)) ;
#line 227
extern int creat(char const   *__file , mode_t __mode ) ;
#line 256
extern int lockf(int __fd , int __cmd , off_t __len ) ;
#line 273
extern  __attribute__((__nothrow__)) int posix_fadvise(int __fd , off_t __offset ,
                                                       off_t __len , int __advise ) ;
#line 295
extern int posix_fallocate(int __fd , off_t __offset , off_t __len ) ;
#line 26 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
extern int __open_2(char const   *__path , int __oflag ) ;
#line 27
extern int __open_alias(char const   *__path , int __oflag  , ...) ;
#line 35
extern void __open_too_many_args(void) ;
#line 37
extern void __open_missing_mode(void) ;
#line 41
__inline extern int open(char const   *__path , int __oflag  , ...)  __attribute__((__gnu_inline__)) ;
#line 41 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
__inline extern int open(char const   *__path , int __oflag  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;

  {
  {
#line 43
  __cil_tmp3 = __builtin_va_arg_pack_len();
  }
#line 43
  if (__cil_tmp3 > 1) {
    {
#line 44
    __open_too_many_args();
    }
  }
  {
#line 46
  __cil_tmp4 = __builtin_constant_p(__oflag);
  }
#line 46
  if (__cil_tmp4) {
    {
#line 48
    __cil_tmp5 = __builtin_va_arg_pack_len();
    }
#line 48
    if ((__oflag & 64) != 0) {
      _L: /* CIL Label */ 
#line 48
      if (__cil_tmp5 < 1) {
        {
#line 50
        __open_missing_mode();
#line 51
        __cil_tmp6 = __open_2(__path, __oflag);
        }
#line 51
        return (__cil_tmp6);
      }
    } else
#line 48
    if ((__oflag & 4259840) == 4259840) {
#line 48
      goto _L;
    }
    {
#line 53
    __cil_tmp7 = __builtin_va_arg_pack();
#line 53
    __cil_tmp8 = __open_alias(__path, __oflag, __cil_tmp7);
    }
#line 53
    return (__cil_tmp8);
  }
  {
#line 56
  __cil_tmp9 = __builtin_va_arg_pack_len();
  }
#line 56
  if (__cil_tmp9 < 1) {
    {
#line 57
    __cil_tmp10 = __open_2(__path, __oflag);
    }
#line 57
    return (__cil_tmp10);
  }
  {
#line 59
  __cil_tmp11 = __builtin_va_arg_pack();
#line 59
  __cil_tmp12 = __open_alias(__path, __oflag, __cil_tmp11);
  }
#line 59
  return (__cil_tmp12);
}
}
#line 98
extern int __openat_2(int __fd , char const   *__path , int __oflag ) ;
#line 100
extern int __openat_alias(int __fd , char const   *__path , int __oflag  , ...) ;
#line 111
extern void __openat_too_many_args(void) ;
#line 113
extern void __openat_missing_mode(void) ;
#line 117
__inline extern int openat(int __fd , char const   *__path , int __oflag  , ...)  __attribute__((__gnu_inline__)) ;
#line 117 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
__inline extern int openat(int __fd , char const   *__path , int __oflag  , ...) 
{ 
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;

  {
  {
#line 119
  __cil_tmp4 = __builtin_va_arg_pack_len();
  }
#line 119
  if (__cil_tmp4 > 1) {
    {
#line 120
    __openat_too_many_args();
    }
  }
  {
#line 122
  __cil_tmp5 = __builtin_constant_p(__oflag);
  }
#line 122
  if (__cil_tmp5) {
    {
#line 124
    __cil_tmp6 = __builtin_va_arg_pack_len();
    }
#line 124
    if ((__oflag & 64) != 0) {
      _L: /* CIL Label */ 
#line 124
      if (__cil_tmp6 < 1) {
        {
#line 126
        __openat_missing_mode();
#line 127
        __cil_tmp7 = __openat_2(__fd, __path, __oflag);
        }
#line 127
        return (__cil_tmp7);
      }
    } else
#line 124
    if ((__oflag & 4259840) == 4259840) {
#line 124
      goto _L;
    }
    {
#line 129
    __cil_tmp8 = __builtin_va_arg_pack();
#line 129
    __cil_tmp9 = __openat_alias(__fd, __path, __oflag, __cil_tmp8);
    }
#line 129
    return (__cil_tmp9);
  }
  {
#line 132
  __cil_tmp10 = __builtin_va_arg_pack_len();
  }
#line 132
  if (__cil_tmp10 < 1) {
    {
#line 133
    __cil_tmp11 = __openat_2(__fd, __path, __oflag);
    }
#line 133
    return (__cil_tmp11);
  }
  {
#line 135
  __cil_tmp12 = __builtin_va_arg_pack();
#line 135
  __cil_tmp13 = __openat_alias(__fd, __path, __oflag, __cil_tmp12);
  }
#line 135
  return (__cil_tmp13);
}
}
#line 205 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int stat(char const   *__file , struct stat *__buf ) ;
#line 210
extern  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__buf ) ;
#line 264
extern  __attribute__((__nothrow__)) int fstatat(int __fd , char const   *__file ,
                                                 struct stat *__buf , int __flag ) ;
#line 313
extern  __attribute__((__nothrow__)) int lstat(char const   *__file , struct stat *__buf ) ;
#line 352
extern  __attribute__((__nothrow__)) int chmod(char const   *__file , __mode_t __mode ) ;
#line 359
extern  __attribute__((__nothrow__)) int lchmod(char const   *__file , __mode_t __mode ) ;
#line 365
extern  __attribute__((__nothrow__)) int fchmod(int __fd , __mode_t __mode ) ;
#line 371
extern  __attribute__((__nothrow__)) int fchmodat(int __fd , char const   *__file ,
                                                  __mode_t __mode , int __flag ) ;
#line 380
extern  __attribute__((__nothrow__)) __mode_t umask(__mode_t __mask ) ;
#line 389
extern  __attribute__((__nothrow__)) int mkdir(char const   *__path , __mode_t __mode ) ;
#line 396
extern  __attribute__((__nothrow__)) int mkdirat(int __fd , char const   *__path ,
                                                 __mode_t __mode ) ;
#line 404
extern  __attribute__((__nothrow__)) int mknod(char const   *__path , __mode_t __mode ,
                                               __dev_t __dev ) ;
#line 411
extern  __attribute__((__nothrow__)) int mknodat(int __fd , char const   *__path ,
                                                 __mode_t __mode , __dev_t __dev ) ;
#line 418
extern  __attribute__((__nothrow__)) int mkfifo(char const   *__path , __mode_t __mode ) ;
#line 425
extern  __attribute__((__nothrow__)) int mkfifoat(int __fd , char const   *__path ,
                                                  __mode_t __mode ) ;
#line 433
extern  __attribute__((__nothrow__)) int utimensat(int __fd , char const   *__path ,
                                                   struct timespec __times[2] , int __flags ) ;
#line 452
extern  __attribute__((__nothrow__)) int futimens(int __fd , struct timespec __times[2] ) ;
#line 54 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-ild.c"
int write3DFrames  =    0;
#line 55 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-ild.c"
int trueColorWrite  =    1;
#line 56 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-ild.c"
int writeTable  =    0;
#line 57 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-ild.c"
int fromToZero  =    1;
#line 58 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-ild.c"
int insert_anchor_points  =    1;
#line 60 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-ild.c"
int lineDistance  =    800;
#line 61 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-ild.c"
int blankDistance  =    1200;
#line 62 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-ild.c"
int anchor_thresh  =    40;
#line 64 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-ild.c"
int inserted_anchor_points  =    0;
#line 98 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-ild.c"
pLaserFrame drawframe  =    (pLaserFrame )((void *)0);
#line 99 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-ild.c"
pLaserSequence drawsequence  =    (pLaserSequence )((void *)0);
#line 100 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-ild.c"
static unsigned char ilda[4]  = {      (unsigned char )'I',      (unsigned char )'L',      (unsigned char )'D',      (unsigned char )'A'};
#line 103 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-ild.c"
static unsigned char ilda_standard_color_palette[256][3]  = 
#line 103
  { {        (unsigned char )0,        (unsigned char )0,        (unsigned char )0}, 
   {        (unsigned char )255,        (unsigned char )255,        (unsigned char )255}, 
   {        (unsigned char )255,        (unsigned char )0,        (unsigned char )0}, 
   {        (unsigned char )255,        (unsigned char )255,        (unsigned char )0}, 
   {        (unsigned char )0,        (unsigned char )255,        (unsigned char )0}, 
   {        (unsigned char )0,        (unsigned char )255,        (unsigned char )255}, 
   {        (unsigned char )0,        (unsigned char )0,        (unsigned char )255}, 
   {        (unsigned char )255,        (unsigned char )0,        (unsigned char )255}, 
   {        (unsigned char )255,        (unsigned char )128,        (unsigned char )128}, 
   {        (unsigned char )255,        (unsigned char )140,        (unsigned char )128}, 
   {        (unsigned char )255,        (unsigned char )151,        (unsigned char )128}, 
   {        (unsigned char )255,        (unsigned char )163,        (unsigned char )128}, 
   {        (unsigned char )255,        (unsigned char )174,        (unsigned char )128}, 
   {        (unsigned char )255,        (unsigned char )186,        (unsigned char )128}, 
   {        (unsigned char )255,        (unsigned char )197,        (unsigned char )128}, 
   {        (unsigned char )255,        (unsigned char )209,        (unsigned char )128}, 
   {        (unsigned char )255,        (unsigned char )220,        (unsigned char )128}, 
   {        (unsigned char )255,        (unsigned char )232,        (unsigned char )128}, 
   {        (unsigned char )255,        (unsigned char )243,        (unsigned char )128}, 
   {        (unsigned char )255,        (unsigned char )255,        (unsigned char )128}, 
   {        (unsigned char )243,        (unsigned char )255,        (unsigned char )128}, 
   {        (unsigned char )232,        (unsigned char )255,        (unsigned char )128}, 
   {        (unsigned char )220,        (unsigned char )255,        (unsigned char )128}, 
   {        (unsigned char )209,        (unsigned char )255,        (unsigned char )128}, 
   {        (unsigned char )197,        (unsigned char )255,        (unsigned char )128}, 
   {        (unsigned char )186,        (unsigned char )255,        (unsigned char )128}, 
   {        (unsigned char )174,        (unsigned char )255,        (unsigned char )128}, 
   {        (unsigned char )163,        (unsigned char )255,        (unsigned char )128}, 
   {        (unsigned char )151,        (unsigned char )255,        (unsigned char )128}, 
   {        (unsigned char )140,        (unsigned char )255,        (unsigned char )128}, 
   {        (unsigned char )128,        (unsigned char )255,        (unsigned char )128}, 
   {        (unsigned char )128,        (unsigned char )255,        (unsigned char )140}, 
   {        (unsigned char )128,        (unsigned char )255,        (unsigned char )151}, 
   {        (unsigned char )128,        (unsigned char )255,        (unsigned char )163}, 
   {        (unsigned char )128,        (unsigned char )255,        (unsigned char )174}, 
   {        (unsigned char )128,        (unsigned char )255,        (unsigned char )186}, 
   {        (unsigned char )128,        (unsigned char )255,        (unsigned char )197}, 
   {        (unsigned char )128,        (unsigned char )255,        (unsigned char )209}, 
   {        (unsigned char )128,        (unsigned char )255,        (unsigned char )220}, 
   {        (unsigned char )128,        (unsigned char )255,        (unsigned char )232}, 
   {        (unsigned char )128,        (unsigned char )255,        (unsigned char )243}, 
   {        (unsigned char )128,        (unsigned char )255,        (unsigned char )255}, 
   {        (unsigned char )128,        (unsigned char )243,        (unsigned char )255}, 
   {        (unsigned char )128,        (unsigned char )232,        (unsigned char )255}, 
   {        (unsigned char )128,        (unsigned char )220,        (unsigned char )255}, 
   {        (unsigned char )128,        (unsigned char )209,        (unsigned char )255}, 
   {        (unsigned char )128,        (unsigned char )197,        (unsigned char )255}, 
   {        (unsigned char )128,        (unsigned char )186,        (unsigned char )255}, 
   {        (unsigned char )128,        (unsigned char )174,        (unsigned char )255}, 
   {        (unsigned char )128,        (unsigned char )163,        (unsigned char )255}, 
   {        (unsigned char )128,        (unsigned char )151,        (unsigned char )255}, 
   {        (unsigned char )128,        (unsigned char )140,        (unsigned char )255}, 
   {        (unsigned char )128,        (unsigned char )128,        (unsigned char )255}, 
   {        (unsigned char )140,        (unsigned char )128,        (unsigned char )255}, 
   {        (unsigned char )151,        (unsigned char )128,        (unsigned char )255}, 
   {        (unsigned char )163,        (unsigned char )128,        (unsigned char )255}, 
   {        (unsigned char )174,        (unsigned char )128,        (unsigned char )255}, 
   {        (unsigned char )186,        (unsigned char )128,        (unsigned char )255}, 
   {        (unsigned char )197,        (unsigned char )128,        (unsigned char )255}, 
   {        (unsigned char )209,        (unsigned char )128,        (unsigned char )255}, 
   {        (unsigned char )220,        (unsigned char )128,        (unsigned char )255}, 
   {        (unsigned char )232,        (unsigned char )128,        (unsigned char )255}, 
   {        (unsigned char )243,        (unsigned char )128,        (unsigned char )255}, 
   {        (unsigned char )255,        (unsigned char )128,        (unsigned char )255}, 
   {        (unsigned char )255,        (unsigned char )128,        (unsigned char )243}, 
   {        (unsigned char )255,        (unsigned char )128,        (unsigned char )232}, 
   {        (unsigned char )255,        (unsigned char )128,        (unsigned char )220}, 
   {        (unsigned char )255,        (unsigned char )128,        (unsigned char )209}, 
   {        (unsigned char )255,        (unsigned char )128,        (unsigned char )197}, 
   {        (unsigned char )255,        (unsigned char )128,        (unsigned char )186}, 
   {        (unsigned char )255,        (unsigned char )128,        (unsigned char )174}, 
   {        (unsigned char )255,        (unsigned char )128,        (unsigned char )163}, 
   {        (unsigned char )255,        (unsigned char )128,        (unsigned char )151}, 
   {        (unsigned char )255,        (unsigned char )128,        (unsigned char )140}, 
   {        (unsigned char )255,        (unsigned char )0,        (unsigned char )0}, 
   {        (unsigned char )255,        (unsigned char )23,        (unsigned char )0}, 
   {        (unsigned char )255,        (unsigned char )46,        (unsigned char )0}, 
   {        (unsigned char )255,        (unsigned char )70,        (unsigned char )0}, 
   {        (unsigned char )255,        (unsigned char )93,        (unsigned char )0}, 
   {        (unsigned char )255,        (unsigned char )116,        (unsigned char )0}, 
   {        (unsigned char )255,        (unsigned char )139,        (unsigned char )0}, 
   {        (unsigned char )255,        (unsigned char )162,        (unsigned char )0}, 
   {        (unsigned char )255,        (unsigned char )185,        (unsigned char )0}, 
   {        (unsigned char )255,        (unsigned char )209,        (unsigned char )0}, 
   {        (unsigned char )255,        (unsigned char )232,        (unsigned char )0}, 
   {        (unsigned char )255,        (unsigned char )255,        (unsigned char )0}, 
   {        (unsigned char )232,        (unsigned char )255,        (unsigned char )0}, 
   {        (unsigned char )209,        (unsigned char )255,        (unsigned char )0}, 
   {        (unsigned char )185,        (unsigned char )255,        (unsigned char )0}, 
   {        (unsigned char )162,        (unsigned char )255,        (unsigned char )0}, 
   {        (unsigned char )139,        (unsigned char )255,        (unsigned char )0}, 
   {        (unsigned char )116,        (unsigned char )255,        (unsigned char )0}, 
   {        (unsigned char )93,        (unsigned char )255,        (unsigned char )0}, 
   {        (unsigned char )70,        (unsigned char )255,        (unsigned char )0}, 
   {        (unsigned char )46,        (unsigned char )255,        (unsigned char )0}, 
   {        (unsigned char )23,        (unsigned char )255,        (unsigned char )0}, 
   {        (unsigned char )0,        (unsigned char )255,        (unsigned char )0}, 
   {        (unsigned char )0,        (unsigned char )255,        (unsigned char )23}, 
   {        (unsigned char )0,        (unsigned char )255,        (unsigned char )46}, 
   {        (unsigned char )0,        (unsigned char )255,        (unsigned char )70}, 
   {        (unsigned char )0,        (unsigned char )255,        (unsigned char )93}, 
   {        (unsigned char )0,        (unsigned char )255,        (unsigned char )116}, 
   {        (unsigned char )0,        (unsigned char )255,        (unsigned char )139}, 
   {        (unsigned char )0,        (unsigned char )255,        (unsigned char )162}, 
   {        (unsigned char )0,        (unsigned char )255,        (unsigned char )185}, 
   {        (unsigned char )0,        (unsigned char )255,        (unsigned char )209}, 
   {        (unsigned char )0,        (unsigned char )255,        (unsigned char )232}, 
   {        (unsigned char )0,        (unsigned char )255,        (unsigned char )255}, 
   {        (unsigned char )0,        (unsigned char )232,        (unsigned char )255}, 
   {        (unsigned char )0,        (unsigned char )209,        (unsigned char )255}, 
   {        (unsigned char )0,        (unsigned char )185,        (unsigned char )255}, 
   {        (unsigned char )0,        (unsigned char )162,        (unsigned char )255}, 
   {        (unsigned char )0,        (unsigned char )139,        (unsigned char )255}, 
   {        (unsigned char )0,        (unsigned char )116,        (unsigned char )255}, 
   {        (unsigned char )0,        (unsigned char )93,        (unsigned char )255}, 
   {        (unsigned char )0,        (unsigned char )70,        (unsigned char )255}, 
   {        (unsigned char )0,        (unsigned char )46,        (unsigned char )255}, 
   {        (unsigned char )0,        (unsigned char )23,        (unsigned char )255}, 
   {        (unsigned char )0,        (unsigned char )0,        (unsigned char )255}, 
   {        (unsigned char )23,        (unsigned char )0,        (unsigned char )255}, 
   {        (unsigned char )46,        (unsigned char )0,        (unsigned char )255}, 
   {        (unsigned char )70,        (unsigned char )0,        (unsigned char )255}, 
   {        (unsigned char )93,        (unsigned char )0,        (unsigned char )255}, 
   {        (unsigned char )116,        (unsigned char )0,        (unsigned char )255}, 
   {        (unsigned char )139,        (unsigned char )0,        (unsigned char )255}, 
   {        (unsigned char )162,        (unsigned char )0,        (unsigned char )255}, 
   {        (unsigned char )185,        (unsigned char )0,        (unsigned char )255}, 
   {        (unsigned char )209,        (unsigned char )0,        (unsigned char )255}, 
   {        (unsigned char )232,        (unsigned char )0,        (unsigned char )255}, 
   {        (unsigned char )255,        (unsigned char )0,        (unsigned char )255}, 
   {        (unsigned char )255,        (unsigned char )0,        (unsigned char )232}, 
   {        (unsigned char )255,        (unsigned char )0,        (unsigned char )209}, 
   {        (unsigned char )255,        (unsigned char )0,        (unsigned char )185}, 
   {        (unsigned char )255,        (unsigned char )0,        (unsigned char )162}, 
   {        (unsigned char )255,        (unsigned char )0,        (unsigned char )139}, 
   {        (unsigned char )255,        (unsigned char )0,        (unsigned char )116}, 
   {        (unsigned char )255,        (unsigned char )0,        (unsigned char )93}, 
   {        (unsigned char )255,        (unsigned char )0,        (unsigned char )70}, 
   {        (unsigned char )255,        (unsigned char )0,        (unsigned char )46}, 
   {        (unsigned char )255,        (unsigned char )0,        (unsigned char )23}, 
   {        (unsigned char )128,        (unsigned char )0,        (unsigned char )0}, 
   {        (unsigned char )128,        (unsigned char )12,        (unsigned char )0}, 
   {        (unsigned char )128,        (unsigned char )23,        (unsigned char )0}, 
   {        (unsigned char )128,        (unsigned char )35,        (unsigned char )0}, 
   {        (unsigned char )128,        (unsigned char )47,        (unsigned char )0}, 
   {        (unsigned char )128,        (unsigned char )58,        (unsigned char )0}, 
   {        (unsigned char )128,        (unsigned char )70,        (unsigned char )0}, 
   {        (unsigned char )128,        (unsigned char )81,        (unsigned char )0}, 
   {        (unsigned char )128,        (unsigned char )93,        (unsigned char )0}, 
   {        (unsigned char )128,        (unsigned char )105,        (unsigned char )0}, 
   {        (unsigned char )128,        (unsigned char )116,        (unsigned char )0}, 
   {        (unsigned char )128,        (unsigned char )128,        (unsigned char )0}, 
   {        (unsigned char )116,        (unsigned char )128,        (unsigned char )0}, 
   {        (unsigned char )105,        (unsigned char )128,        (unsigned char )0}, 
   {        (unsigned char )93,        (unsigned char )128,        (unsigned char )0}, 
   {        (unsigned char )81,        (unsigned char )128,        (unsigned char )0}, 
   {        (unsigned char )70,        (unsigned char )128,        (unsigned char )0}, 
   {        (unsigned char )58,        (unsigned char )128,        (unsigned char )0}, 
   {        (unsigned char )47,        (unsigned char )128,        (unsigned char )0}, 
   {        (unsigned char )35,        (unsigned char )128,        (unsigned char )0}, 
   {        (unsigned char )23,        (unsigned char )128,        (unsigned char )0}, 
   {        (unsigned char )12,        (unsigned char )128,        (unsigned char )0}, 
   {        (unsigned char )0,        (unsigned char )128,        (unsigned char )0}, 
   {        (unsigned char )0,        (unsigned char )128,        (unsigned char )12}, 
   {        (unsigned char )0,        (unsigned char )128,        (unsigned char )23}, 
   {        (unsigned char )0,        (unsigned char )128,        (unsigned char )35}, 
   {        (unsigned char )0,        (unsigned char )128,        (unsigned char )47}, 
   {        (unsigned char )0,        (unsigned char )128,        (unsigned char )58}, 
   {        (unsigned char )0,        (unsigned char )128,        (unsigned char )70}, 
   {        (unsigned char )0,        (unsigned char )128,        (unsigned char )81}, 
   {        (unsigned char )0,        (unsigned char )128,        (unsigned char )93}, 
   {        (unsigned char )0,        (unsigned char )128,        (unsigned char )105}, 
   {        (unsigned char )0,        (unsigned char )128,        (unsigned char )116}, 
   {        (unsigned char )0,        (unsigned char )128,        (unsigned char )128}, 
   {        (unsigned char )0,        (unsigned char )116,        (unsigned char )128}, 
   {        (unsigned char )0,        (unsigned char )105,        (unsigned char )128}, 
   {        (unsigned char )0,        (unsigned char )93,        (unsigned char )128}, 
   {        (unsigned char )0,        (unsigned char )81,        (unsigned char )128}, 
   {        (unsigned char )0,        (unsigned char )70,        (unsigned char )128}, 
   {        (unsigned char )0,        (unsigned char )58,        (unsigned char )128}, 
   {        (unsigned char )0,        (unsigned char )47,        (unsigned char )128}, 
   {        (unsigned char )0,        (unsigned char )35,        (unsigned char )128}, 
   {        (unsigned char )0,        (unsigned char )23,        (unsigned char )128}, 
   {        (unsigned char )0,        (unsigned char )12,        (unsigned char )128}, 
   {        (unsigned char )0,        (unsigned char )0,        (unsigned char )128}, 
   {        (unsigned char )12,        (unsigned char )0,        (unsigned char )128}, 
   {        (unsigned char )23,        (unsigned char )0,        (unsigned char )128}, 
   {        (unsigned char )35,        (unsigned char )0,        (unsigned char )128}, 
   {        (unsigned char )47,        (unsigned char )0,        (unsigned char )128}, 
   {        (unsigned char )58,        (unsigned char )0,        (unsigned char )128}, 
   {        (unsigned char )70,        (unsigned char )0,        (unsigned char )128}, 
   {        (unsigned char )81,        (unsigned char )0,        (unsigned char )128}, 
   {        (unsigned char )93,        (unsigned char )0,        (unsigned char )128}, 
   {        (unsigned char )105,        (unsigned char )0,        (unsigned char )128}, 
   {        (unsigned char )116,        (unsigned char )0,        (unsigned char )128}, 
   {        (unsigned char )128,        (unsigned char )0,        (unsigned char )128}, 
   {        (unsigned char )128,        (unsigned char )0,        (unsigned char )116}, 
   {        (unsigned char )128,        (unsigned char )0,        (unsigned char )105}, 
   {        (unsigned char )128,        (unsigned char )0,        (unsigned char )93}, 
   {        (unsigned char )128,        (unsigned char )0,        (unsigned char )81}, 
   {        (unsigned char )128,        (unsigned char )0,        (unsigned char )70}, 
   {        (unsigned char )128,        (unsigned char )0,        (unsigned char )58}, 
   {        (unsigned char )128,        (unsigned char )0,        (unsigned char )47}, 
   {        (unsigned char )128,        (unsigned char )0,        (unsigned char )35}, 
   {        (unsigned char )128,        (unsigned char )0,        (unsigned char )23}, 
   {        (unsigned char )128,        (unsigned char )0,        (unsigned char )12}, 
   {        (unsigned char )255,        (unsigned char )192,        (unsigned char )192}, 
   {        (unsigned char )255,        (unsigned char )64,        (unsigned char )64}, 
   {        (unsigned char )192,        (unsigned char )0,        (unsigned char )0}, 
   {        (unsigned char )64,        (unsigned char )0,        (unsigned char )0}, 
   {        (unsigned char )255,        (unsigned char )255,        (unsigned char )192}, 
   {        (unsigned char )255,        (unsigned char )255,        (unsigned char )64}, 
   {        (unsigned char )192,        (unsigned char )192,        (unsigned char )0}, 
   {        (unsigned char )64,        (unsigned char )64,        (unsigned char )0}, 
   {        (unsigned char )192,        (unsigned char )255,        (unsigned char )192}, 
   {        (unsigned char )64,        (unsigned char )255,        (unsigned char )64}, 
   {        (unsigned char )0,        (unsigned char )192,        (unsigned char )0}, 
   {        (unsigned char )0,        (unsigned char )64,        (unsigned char )0}, 
   {        (unsigned char )192,        (unsigned char )255,        (unsigned char )255}, 
   {        (unsigned char )64,        (unsigned char )255,        (unsigned char )255}, 
   {        (unsigned char )0,        (unsigned char )192,        (unsigned char )192}, 
   {        (unsigned char )0,        (unsigned char )64,        (unsigned char )64}, 
   {        (unsigned char )192,        (unsigned char )192,        (unsigned char )255}, 
   {        (unsigned char )64,        (unsigned char )64,        (unsigned char )255}, 
   {        (unsigned char )0,        (unsigned char )0,        (unsigned char )192}, 
   {        (unsigned char )0,        (unsigned char )0,        (unsigned char )64}, 
   {        (unsigned char )255,        (unsigned char )192,        (unsigned char )255}, 
   {        (unsigned char )255,        (unsigned char )64,        (unsigned char )255}, 
   {        (unsigned char )192,        (unsigned char )0,        (unsigned char )192}, 
   {        (unsigned char )64,        (unsigned char )0,        (unsigned char )64}, 
   {        (unsigned char )255,        (unsigned char )96,        (unsigned char )96}, 
   {        (unsigned char )255,        (unsigned char )255,        (unsigned char )255}, 
   {        (unsigned char )245,        (unsigned char )245,        (unsigned char )245}, 
   {        (unsigned char )235,        (unsigned char )235,        (unsigned char )235}, 
   {        (unsigned char )224,        (unsigned char )224,        (unsigned char )224}, 
   {        (unsigned char )213,        (unsigned char )213,        (unsigned char )213}, 
   {        (unsigned char )203,        (unsigned char )203,        (unsigned char )203}, 
   {        (unsigned char )192,        (unsigned char )192,        (unsigned char )192}, 
   {        (unsigned char )181,        (unsigned char )181,        (unsigned char )181}, 
   {        (unsigned char )171,        (unsigned char )171,        (unsigned char )171}, 
   {        (unsigned char )160,        (unsigned char )160,        (unsigned char )160}, 
   {        (unsigned char )149,        (unsigned char )149,        (unsigned char )149}, 
   {        (unsigned char )139,        (unsigned char )139,        (unsigned char )139}, 
   {        (unsigned char )128,        (unsigned char )128,        (unsigned char )128}, 
   {        (unsigned char )117,        (unsigned char )117,        (unsigned char )117}, 
   {        (unsigned char )107,        (unsigned char )107,        (unsigned char )107}, 
   {        (unsigned char )96,        (unsigned char )96,        (unsigned char )96}, 
   {        (unsigned char )85,        (unsigned char )85,        (unsigned char )85}, 
   {        (unsigned char )75,        (unsigned char )75,        (unsigned char )75}, 
   {        (unsigned char )64,        (unsigned char )64,        (unsigned char )64}, 
   {        (unsigned char )53,        (unsigned char )53,        (unsigned char )53}, 
   {        (unsigned char )43,        (unsigned char )43,        (unsigned char )43}, 
   {        (unsigned char )32,        (unsigned char )32,        (unsigned char )32}, 
   {        (unsigned char )21,        (unsigned char )21,        (unsigned char )21}, 
   {        (unsigned char )11,        (unsigned char )11,        (unsigned char )11}, 
   {        (unsigned char )0,        (unsigned char )0,        (unsigned char )0}};
#line 370 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-ild.c"
int find_best_match_color(unsigned char r , unsigned char g , unsigned char b ) 
{ 
  unsigned int i ;
  unsigned int dmin ;
  unsigned int d ;
  unsigned int ret ;
  int t ;
  unsigned int __cil_tmp9 ;

  {
#line 372
  dmin = (unsigned int )195076;
#line 376
  i = (unsigned int )0;
  {
#line 376
  while (1) {
    while_continue: /* CIL Label */ ;
#line 376
    if (! (i < 255U)) {
#line 376
      goto while_break;
    }
#line 377
    t = (int )r - (int )ilda_standard_color_palette[i][0];
#line 378
    d = (unsigned int )(t * t);
#line 379
    t = (int )g - (int )ilda_standard_color_palette[i][1];
#line 380
    d += (unsigned int )(t * t);
#line 381
    t = (int )b - (int )ilda_standard_color_palette[i][2];
#line 382
    d += (unsigned int )(t * t);
#line 383
    if (d < dmin) {
#line 384
      dmin = d;
#line 385
      ret = i;
#line 386
      if (dmin == 0U) {
#line 387
        return ((int )ret);
      }
    }
#line 376
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 390
  return ((int )ret);
}
}
#line 393 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-ild.c"
pLaserPoint newLaserPoint(void) 
{ 
  pLaserPoint p ;
  void *__cil_tmp2 ;

  {
  {
#line 395
  p = (pLaserPoint )((void *)0);
#line 397
  __cil_tmp2 = malloc(sizeof(LaserPoint ));
#line 397
  p = (pLaserPoint )__cil_tmp2;
  }
#line 397
  if (p == (void *)0) {
#line 398
    return ((pLaserPoint )((void *)0));
  }
#line 400
  p->z = (short )0;
#line 400
  p->y = p->z;
#line 400
  p->x = p->y;
#line 401
  p->b = (unsigned char )0;
#line 401
  p->g = p->b;
#line 401
  p->r = p->g;
#line 402
  p->attrib = (unsigned char )0;
#line 403
  p->next = (void *)0;
#line 405
  return (p);
}
}
#line 408 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-ild.c"
pLaserFrame newLaserFrame(void) 
{ 
  pLaserFrame p ;
  void *__cil_tmp2 ;

  {
  {
#line 410
  p = (pLaserFrame )((void *)0);
#line 412
  __cil_tmp2 = malloc(sizeof(LaserFrame ));
#line 412
  p = (pLaserFrame )__cil_tmp2;
  }
#line 412
  if (p == (void *)0) {
#line 413
    return ((pLaserFrame )((void *)0));
  }
#line 415
  p->next = (void *)0;
#line 416
  p->previous = (void *)0;
#line 417
  p->point_first = (LaserPoint *)((void *)0);
#line 418
  p->point_last = (LaserPoint *)((void *)0);
#line 419
  p->name = (char *)((void *)0);
#line 420
  p->count = 0;
#line 422
  return (p);
}
}
#line 425 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-ild.c"
pLaserPoint frame_point_add(pLaserFrame fra ) 
{ 
  pLaserPoint point ;
  pLaserPoint point2 ;
  pLaserPoint __cil_tmp4 ;
  pLaserPoint __cil_tmp5 ;

  {
#line 427
  point = fra->point_last;
#line 428
  point2 = (pLaserPoint )((void *)0);
#line 430
  (fra->count) ++;
#line 432
  if (point == (void *)0) {
    {
#line 433
    point = newLaserPoint();
#line 434
    point->next = (void *)0;
#line 435
    fra->point_first = point;
#line 436
    fra->point_last = point;
    }
#line 437
    return (point);
  }
  {
#line 440
  point2 = newLaserPoint();
#line 441
  point2->next = (void *)0;
#line 443
  point->next = point2;
#line 445
  fra->point_last = point->next;
  }
#line 447
  return (point2);
}
}
#line 450 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-ild.c"
int frame_point_count(LaserFrame *f ) 
{ 


  {
#line 452
  return (f->count);
}
}
#line 455 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-ild.c"
pLaserSequence newLaserSequence(void) 
{ 
  pLaserSequence p ;
  void *__cil_tmp2 ;

  {
  {
#line 457
  p = (pLaserSequence )((void *)0);
#line 459
  __cil_tmp2 = malloc(sizeof(LaserSequence ));
#line 459
  p = (pLaserSequence )__cil_tmp2;
  }
#line 459
  if (p == (void *)0) {
#line 460
    return ((pLaserSequence )((void *)0));
  }
#line 462
  p->frame_count = 0;
#line 463
  p->frame_first = (LaserFrame *)((void *)0);
#line 464
  p->frame_last = (LaserFrame *)((void *)0);
#line 466
  return (p);
}
}
#line 469 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-ild.c"
int sequence_frame_count(pLaserSequence seq ) 
{ 


  {
#line 471
  return (seq->frame_count);
}
}
#line 474 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-ild.c"
pLaserFrame sequence_frame_add(pLaserSequence seq ) 
{ 
  pLaserFrame frame1 ;
  pLaserFrame frame2 ;
  pLaserFrame __cil_tmp4 ;
  pLaserFrame __cil_tmp5 ;

  {
#line 477
  frame1 = seq->frame_last;
#line 478
  frame2 = (pLaserFrame )((void *)0);
#line 480
  (seq->frame_count) ++;
#line 482
  if (frame1 == (void *)0) {
    {
#line 483
    frame1 = newLaserFrame();
#line 484
    frame1->next = (void *)0;
#line 485
    frame1->previous = (void *)0;
#line 486
    seq->frame_first = frame1;
#line 487
    seq->frame_last = frame1;
    }
#line 488
    return (frame1);
  }
  {
#line 491
  frame2 = newLaserFrame();
#line 492
  frame2->previous = frame1;
#line 494
  frame1->next = frame2;
#line 496
  seq->frame_last = frame2;
  }
#line 498
  return (frame2);
}
}
#line 502 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-ild.c"
int writeILDAFrame(FILE *file , LaserFrame *f , int format ) 
{ 
  unsigned char lastr ;
  unsigned char lastg ;
  unsigned char lastb ;
  unsigned int lastc ;
  unsigned char cbuffer[8] ;
  int points ;
  int c ;
  int b ;
  int cpoints ;
  LaserPoint *point ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;

  {
#line 504
  lastr = (unsigned char )0;
#line 504
  lastg = (unsigned char )0;
  {
#line 504
  lastb = (unsigned char )0;
#line 505
  lastc = (unsigned int )0;
#line 511
  cpoints = frame_point_count(f);
#line 513
  point = f->point_first;
#line 514
  points = 0;
  }
  {
#line 516
  while (1) {
    while_continue: /* CIL Label */ ;
#line 516
    if (! point) {
#line 516
      goto while_break;
    }
#line 518
    if ((int )point->r == (int )lastr) {
#line 518
      if ((int )point->g == (int )lastg) {
#line 518
        if ((int )point->b == (int )lastb) {
#line 519
          c = (int )lastc;
        } else {
          {
          {
          {
#line 521
          c = find_best_match_color(point->r, point->g, point->b);
          }
          }
#line 522
          lastc = (unsigned int )c;
#line 523
          lastr = point->r;
#line 524
          lastg = point->g;
#line 525
          lastb = point->b;
          }
        }
      } else {
        {
        {
        {
#line 521
        c = find_best_match_color(point->r, point->g, point->b);
        }
        }
#line 522
        lastc = (unsigned int )c;
#line 523
        lastr = point->r;
#line 524
        lastg = point->g;
#line 525
        lastb = point->b;
        }
      }
    } else {
      {
      {
      {
#line 521
      c = find_best_match_color(point->r, point->g, point->b);
      }
      }
#line 522
      lastc = (unsigned int )c;
#line 523
      lastr = point->r;
#line 524
      lastg = point->g;
#line 525
      lastb = point->b;
      }
    }
#line 528
    if (! (((int )point->r || (int )point->g) || (int )point->b)) {
#line 529
      b = 64;
    } else
#line 528
    if ((int )point->attrib & 1) {
#line 529
      b = 64;
    } else {
#line 531
      b = 0;
    }
#line 534
    if (points + 1 == cpoints) {
#line 535
      b += 128;
    }
#line 537
    cbuffer[0] = (unsigned char )((int )point->x >> 8);
#line 538
    cbuffer[1] = (unsigned char )((int )point->x & 255);
#line 539
    cbuffer[2] = (unsigned char )((int )point->y >> 8);
#line 540
    cbuffer[3] = (unsigned char )((int )point->y & 255);
#line 542
    if (format == 0) {
      {
#line 543
      cbuffer[4] = (unsigned char )((int )point->z >> 8);
#line 544
      cbuffer[5] = (unsigned char )((int )point->z & 255);
#line 545
      cbuffer[6] = (unsigned char )b;
#line 546
      cbuffer[7] = (unsigned char )c;
#line 547
      fwrite((char *)((unsigned char *)cbuffer), sizeof(char ), (unsigned long )8,
             file);
      }
    } else {
      {
#line 549
      cbuffer[4] = (unsigned char )b;
#line 550
      cbuffer[5] = (unsigned char )c;
#line 551
      fwrite((char *)((unsigned char *)cbuffer), sizeof(char ), (unsigned long )6,
             file);
      }
    }
#line 553
    point = point->next;
#line 554
    points ++;
  }
  while_break: /* CIL Label */ ;
  }

#line 557
  return (0);
}
}
#line 561 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-ild.c"
int writeILDAHeader(FILE *file , unsigned int format , unsigned int datalength ) 
{ 
  unsigned char fhbuffer[12] ;
  int tmp ;
  unsigned long __cil_tmp6 ;

  {
  {
#line 566
  memcpy((unsigned char *)fhbuffer, (unsigned char *)ilda, (unsigned long )4);
#line 568
  fhbuffer[4] = (unsigned char )((format >> 24) & 255U);
#line 569
  fhbuffer[5] = (unsigned char )((format >> 16) & 255U);
#line 570
  fhbuffer[6] = (unsigned char )((format >> 8) & 255U);
#line 571
  fhbuffer[7] = (unsigned char )(format & 255U);
#line 573
  fhbuffer[8] = (unsigned char )((datalength >> 24) & 255U);
#line 574
  fhbuffer[9] = (unsigned char )((datalength >> 16) & 255U);
#line 575
  fhbuffer[10] = (unsigned char )((datalength >> 8) & 255U);
#line 576
  fhbuffer[11] = (unsigned char )(datalength & 255U);
  }
#line 578
  if (format > 2U) {
#line 578
    tmp = 12;
  } else {
#line 578
    tmp = 8;
  }
  {
#line 578
  __cil_tmp6 = fwrite((char *)((unsigned char *)fhbuffer), sizeof(char ), (unsigned long )tmp,
                      file);
  }
#line 578
  return ((int )__cil_tmp6);
}
}
#line 582 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-ild.c"
int writeILDAFrameHeader(FILE *file , LaserFrame *f , int format , unsigned int frames ,
                         unsigned int cframes ) 
{ 
  unsigned int cpoints ;
  unsigned char fhbuffer[24] ;
  unsigned char emptys[17] ;
  int __cil_tmp9 ;
  unsigned long __cil_tmp10 ;

  {
  {
#line 584
  cpoints = (unsigned int )0;
#line 586
  strcpy((char *)((unsigned char *)emptys), "                @\245\324\n\027V");
#line 588
  writeILDAHeader(file, (unsigned int )format, (unsigned int )0);
  }
#line 590
  if (f) {
    {
#line 595
    snprintf((char *)((unsigned char *)fhbuffer), (unsigned long )16, "Frame #%04d",
             frames);
    }
  } else {
    {
#line 598
    strncpy((char *)((unsigned char *)fhbuffer), (char const   *)((char *)((unsigned char *)emptys)),
            (unsigned long )16);
    }
  }
#line 601
  if (f) {
    {
#line 602
    __cil_tmp9 = frame_point_count(f);
#line 602
    cpoints = (unsigned int )__cil_tmp9;
    }
  }
  {
#line 604
  fhbuffer[16] = (unsigned char )((cpoints >> 8) & 255U);
#line 605
  fhbuffer[17] = (unsigned char )(cpoints & 255U);
#line 606
  fhbuffer[18] = (unsigned char )((frames >> 8) & 255U);
#line 607
  fhbuffer[19] = (unsigned char )(frames & 255U);
#line 608
  fhbuffer[20] = (unsigned char )((cframes >> 8) & 255U);
#line 609
  fhbuffer[21] = (unsigned char )(cframes & 255U);
#line 610
  fhbuffer[22] = (unsigned char )0;
#line 611
  fhbuffer[23] = (unsigned char )0;
#line 613
  __cil_tmp10 = fwrite((char *)((unsigned char *)fhbuffer), sizeof(char ), (unsigned long )24,
                       file);
  }
#line 613
  return ((int )__cil_tmp10);
}
}
#line 617 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-ild.c"
int writeILDATrueColor(FILE *file , LaserFrame *f ) 
{ 
  unsigned char cbuffer[4] ;
  int cpoints ;
  LaserPoint *point ;
  int __cil_tmp6 ;

  {
  {
#line 624
  cpoints = frame_point_count(f);
#line 626
  writeILDAHeader(file, (unsigned int )3, (unsigned int )(cpoints * 3 + 4));
#line 628
  cbuffer[0] = (unsigned char )((cpoints >> 24) & 255);
#line 629
  cbuffer[1] = (unsigned char )((cpoints >> 16) & 255);
#line 630
  cbuffer[2] = (unsigned char )((cpoints >> 8) & 255);
#line 631
  cbuffer[3] = (unsigned char )(cpoints & 255);
#line 633
  fwrite((char *)((unsigned char *)cbuffer), sizeof(char ), (unsigned long )4, file);
#line 635
  point = f->point_first;
  }
  {
#line 637
  while (1) {
    while_continue: /* CIL Label */ ;
#line 637
    if (! point) {
#line 637
      goto while_break;
    }
    {
#line 638
    cbuffer[0] = point->r;
#line 639
    cbuffer[1] = point->g;
#line 640
    cbuffer[2] = point->b;
#line 642
    fwrite((char *)((unsigned char *)cbuffer), sizeof(char ), (unsigned long )3, file);
#line 644
    point = point->next;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 647
  return (0);
}
}
#line 651 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-ild.c"
int writeILDAColorTable(FILE *file ) 
{ 
  unsigned int i ;
  unsigned int palette ;
  unsigned int colors ;
  unsigned char fhbuffer[24] ;
  unsigned char emptys[17] ;
  unsigned int __cil_tmp7 ;

  {
#line 653
  palette = (unsigned int )0;
  {
#line 653
  colors = (unsigned int )256;
#line 655
  strcpy((char *)((unsigned char *)emptys), "Color Table     \f");
#line 657
  writeILDAHeader(file, (unsigned int )2, (unsigned int )0);
#line 659
  strncpy((char *)((unsigned char *)fhbuffer), (char const   *)((char *)((unsigned char *)emptys)),
          (unsigned long )16);
#line 660
  fhbuffer[16] = (unsigned char )((colors >> 8) & 255U);
#line 661
  fhbuffer[17] = (unsigned char )(colors & 255U);
#line 662
  fhbuffer[18] = (unsigned char )((palette >> 8) & 255U);
#line 663
  fhbuffer[19] = (unsigned char )(palette & 255U);
#line 664
  fhbuffer[20] = (unsigned char )0;
#line 665
  fhbuffer[21] = (unsigned char )0;
#line 666
  fhbuffer[22] = (unsigned char )0;
#line 667
  fhbuffer[23] = (unsigned char )0;
#line 668
  fwrite((char *)((unsigned char *)fhbuffer), sizeof(char ), (unsigned long )24, file);
#line 670
  i = (unsigned int )0;
  }
  {
#line 670
  while (1) {
    while_continue: /* CIL Label */ ;
#line 670
    if (! (i < colors)) {
#line 670
      goto while_break;
    }
    {
#line 671
    fhbuffer[0] = ilda_standard_color_palette[i][0];
#line 672
    fhbuffer[1] = ilda_standard_color_palette[i][1];
#line 673
    fhbuffer[2] = ilda_standard_color_palette[i][2];
#line 674
    fwrite((char *)((unsigned char *)fhbuffer), sizeof(char ), (unsigned long )3,
           file);
    }
#line 670
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 677
  return (0);
}
}
#line 681 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-ild.c"
int writeILDA(FILE *file , LaserSequence *s ) 
{ 
  int format ;
  int tmp ;
  int frames ;
  int cframes ;
  int palettes ;
  LaserFrame *f ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
#line 683
  if (write3DFrames) {
#line 683
    tmp = 0;
  } else {
#line 683
    tmp = 1;
  }
#line 683
  format = tmp;
#line 684
  frames = 0;
#line 684
  palettes = 0;
#line 687
  if (writeTable) {
    {
#line 688
    writeILDAColorTable(file);
    }
  }
  {
#line 691
  cframes = sequence_frame_count(s);
#line 693
  f = s->frame_first;
  }
  {
#line 695
  while (1) {
    while_continue: /* CIL Label */ ;
#line 695
    if (! f) {
#line 695
      goto while_break;
    }
#line 697
    if (trueColorWrite) {
      {
#line 698
      writeILDATrueColor(file, f);
      }
    }
    {
#line 700
    writeILDAFrameHeader(file, f, format, (unsigned int )frames, (unsigned int )cframes);
#line 701
    writeILDAFrame(file, f, format);
#line 703
    f = f->next;
#line 704
    frames ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 708
  writeILDAFrameHeader(file, (LaserFrame *)((void *)0), format, (unsigned int )0,
                       (unsigned int )cframes);
  }
#line 710
  return (0);
}
}
#line 713 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-ild.c"
__inline static short clip(double x ) 
{ 
  double __cil_tmp2 ;

  {
#line 715
  if (x > 32767.) {
#line 716
    x = 32767.;
  }
#line 717
  if (x < - 32768.) {
#line 718
    x = - 32768.;
  }
  {
#line 719
  __cil_tmp2 = rint(x);
  }
#line 719
  return ((short )((unsigned short )__cil_tmp2));
}
}
#line 723 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-ild.c"
void blankingPath(int x1 , int y1___0 , int x2 , int y2 ) 
{ 
  int len ;
  int steps ;
  int i ;
  double lx ;
  double ly ;
  double t ;
  LaserPoint *p ;
  double __cil_tmp12 ;
  double __cil_tmp13 ;
  pLaserPoint __cil_tmp14 ;
  short __cil_tmp15 ;
  short __cil_tmp16 ;
  int __cil_tmp17 ;

  {
  {
#line 728
  lx = (double )(x2 - x1);
#line 729
  ly = (double )(y2 - y1___0);
#line 730
  __cil_tmp12 = sqrt(lx * lx + ly * ly);
#line 730
  __cil_tmp13 = rint(__cil_tmp12);
#line 730
  len = (int )__cil_tmp13;
  }
#line 732
  if (! len) {
#line 733
    return;
  }
#line 735
  if (len < blankDistance) {
#line 736
    steps = 1;
  } else {
#line 738
    steps = len / blankDistance;
  }
#line 741
  i = 0;
  {
#line 741
  while (1) {
    while_continue: /* CIL Label */ ;
#line 741
    if (! (i <= steps)) {
#line 741
      goto while_break;
    }
    {
#line 742
    t = (double )i / (double )steps;
#line 743
    p = frame_point_add(drawframe);
#line 744
    p->x = clip(((double )1 - t) * (double )x1 + (double )x2 * t);
#line 745
    p->y = clip(((double )1 - t) * (double )y1___0 + (double )y2 * t);
#line 746
    p->z = (short )0;
#line 747
    p->r = (unsigned char )0;
#line 748
    p->g = (unsigned char )0;
#line 749
    p->b = (unsigned char )0;
#line 750
    p->attrib = (unsigned char )1;
    }
#line 741
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 755 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-ild.c"
void blankingPathTo(int x , int y ) 
{ 


  {
#line 757
  if (! drawframe) {
#line 758
    return;
  } else
#line 757
  if (! drawframe->point_last) {
#line 758
    return;
  }
  {
#line 759
  blankingPath((int )(drawframe->point_last)->x, (int )(drawframe->point_last)->y,
               x, y);
  }
  return;
}
}
#line 763 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-ild.c"
void frameDrawInit(int x , int y , unsigned char r , unsigned char g , unsigned char b ) 
{ 
  pLaserFrame __cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 765
  if (! drawframe) {
    {
#line 766
    drawframe = sequence_frame_add(drawsequence);
    }
  }
  {
#line 767
  __cil_tmp7 = frame_point_count(drawframe);
  }
#line 767
  if (! __cil_tmp7) {
#line 768
    if (drawframe->previous) {
#line 768
      if (((LaserFrame *)drawframe->previous)->point_last) {
        {
#line 769
        blankingPath((int )(((LaserFrame *)drawframe->previous)->point_last)->x, (int )(((LaserFrame *)drawframe->previous)->point_last)->y,
                     x, y);
        }
      } else {
#line 768
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 771
    if (fromToZero) {
      {
#line 772
      blankingPath(0, 0, x, y);
      }
    }
  } else {
    {
#line 775
    blankingPathTo(x, y);
    }
  }
  return;
}
}
#line 779 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-ild.c"
double getAngle(double b1x , double b1y , double b2x , double b2y ) 
{ 
  double acosa ;
  double b1v ;
  double __cil_tmp7 ;
  double b2v ;
  double __cil_tmp9 ;
  double __cil_tmp10 ;

  {
  {
#line 782
  __cil_tmp7 = sqrt(b1x * b1x + b1y * b1y);
#line 782
  b1v = __cil_tmp7;
#line 783
  __cil_tmp9 = sqrt(b2x * b2x + b2y * b2y);
#line 783
  b2v = __cil_tmp9;
  }
#line 785
  if (b1v == (double )0) {
#line 786
    return (0.);
  } else
#line 785
  if (b2v == (double )0) {
#line 786
    return (0.);
  }
#line 787
  acosa = (b1x * b2x + b1y * b2y) / (b1v * b2v);
#line 788
  if (acosa > 1.) {
#line 789
    acosa = 1.;
  }
#line 790
  if (acosa < - 1.) {
#line 791
    acosa = - 1.;
  }
  {
#line 792
  __cil_tmp10 = acos(acosa);
  }
#line 792
  return ((__cil_tmp10 * 180.) / 3.14159265359);
}
}
#line 795 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-ild.c"
void insertAnchorPoints(void) 
{ 
  LaserPoint *p ;
  LaserPoint *pn ;
  double dx ;
  double dy ;
  double dx1 ;
  double dy1 ;
  double a ;
  double __cil_tmp8 ;
  pLaserPoint __cil_tmp9 ;
  int __cil_tmp10 ;

  {
#line 797
  p = drawframe->point_first;
#line 800
  if (! p) {
#line 801
    return;
  } else
#line 800
  if (! p->next) {
#line 801
    return;
  }
#line 803
  dx1 = (double )((int )((LaserPoint *)p->next)->x - (int )p->x);
#line 804
  dy1 = (double )((int )((LaserPoint *)p->next)->y - (int )p->y);
#line 805
  p = p->next;
  {
#line 807
  while (1) {
    while_continue: /* CIL Label */ ;
#line 807
    if (! (p && p->next)) {
#line 807
      goto while_break;
    }
#line 809
    dx = (double )((int )((LaserPoint *)p->next)->x - (int )p->x);
#line 810
    dy = (double )((int )((LaserPoint *)p->next)->y - (int )p->y);
#line 818
    if (dx) {
      _L: /* CIL Label */ 
      {
#line 819
      a = getAngle(dx1, dy1, dx, dy);
      }
      {
#line 820
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 820
        if (! (a > (double )anchor_thresh)) {
#line 820
          goto while_break___0;
        }
        {
#line 821
        pn = newLaserPoint();
#line 822
        pn->x = p->x;
#line 823
        pn->y = p->y;
#line 824
        pn->z = p->z;
#line 825
        pn->r = p->r;
#line 826
        pn->g = p->g;
#line 827
        pn->b = p->b;
#line 833
        pn->attrib = p->attrib;
#line 834
        pn->next = p->next;
#line 835
        p->next = pn;
#line 836
        (drawframe->count) ++;
#line 837
        inserted_anchor_points ++;
#line 838
        p = p->next;
#line 839
        a -= (double )anchor_thresh;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 841
      dx1 = dx;
#line 842
      dy1 = dy;
    } else
#line 818
    if (dy) {
#line 818
      goto _L;
    }
#line 845
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 849 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-ild.c"
void frameDrawFinish(void) 
{ 
  LaserPoint *p ;
  int __cil_tmp2 ;
  int __cil_tmp3 ;
  pLaserPoint __cil_tmp4 ;

  {
#line 853
  if (fromToZero) {
    {
#line 854
    blankingPathTo(0, 0);
    }
  }
  {
#line 856
  __cil_tmp2 = sequence_frame_count(drawsequence);
  }
#line 856
  if (__cil_tmp2 < 1) {
    {
#line 857
    frameDrawInit(0, 0, (unsigned char )0, (unsigned char )0, (unsigned char )0);
#line 859
    __cil_tmp3 = frame_point_count(drawframe);
    }
#line 859
    if (__cil_tmp3 < 1) {
      {
#line 860
      p = frame_point_add(drawframe);
#line 861
      p->x = (short )0;
#line 862
      p->y = (short )0;
#line 863
      p->z = (short )0;
#line 864
      p->r = (unsigned char )0;
#line 865
      p->g = (unsigned char )0;
#line 866
      p->b = (unsigned char )0;
#line 867
      p->attrib = (unsigned char )1;
      }
    }
  }
#line 871
  if (insert_anchor_points) {
    {
#line 872
    insertAnchorPoints();
    }
  }
  return;
}
}
#line 875 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-ild.c"
void drawLine(double x1 , double y1___0 , double x2 , double y2 , unsigned char r1 ,
              unsigned char g1 , unsigned char b1 ) 
{ 
  int i ;
  int len ;
  int steps ;
  double t ;
  double lx ;
  double ly ;
  LaserPoint *p ;
  double __cil_tmp15 ;
  double __cil_tmp16 ;
  double __cil_tmp17 ;
  double __cil_tmp18 ;
  pLaserPoint __cil_tmp19 ;
  short __cil_tmp20 ;
  short __cil_tmp21 ;
  int __cil_tmp22 ;

  {
  {
#line 885
  __cil_tmp15 = rint(x1);
  }
  {
#line 885
  __cil_tmp16 = rint(y1___0);
#line 885
  frameDrawInit((int )__cil_tmp15, (int )__cil_tmp16, r1, g1, b1);
#line 887
  lx = x2 - x1;
#line 888
  ly = y2 - y1___0;
#line 889
  __cil_tmp17 = sqrt(lx * lx + ly * ly);
#line 889
  __cil_tmp18 = rint(__cil_tmp17);
#line 889
  len = (int )__cil_tmp18;
  }
#line 891
  if (len < lineDistance) {
#line 892
    steps = 1;
  } else {
#line 894
    steps = len / lineDistance;
  }
#line 897
  i = 0;
  {
#line 897
  while (1) {
    while_continue: /* CIL Label */ ;
#line 897
    if (! (i <= steps)) {
#line 897
      goto while_break;
    }
    {
#line 898
    t = (double )i / (double )steps;
#line 899
    p = frame_point_add(drawframe);
#line 900
    p->x = clip(((double )1 - t) * x1 + x2 * t);
#line 901
    p->y = clip(((double )1 - t) * y1___0 + y2 * t);
#line 902
    p->z = (short )0;
#line 903
    p->r = r1;
#line 904
    p->g = g1;
#line 905
    p->b = b1;
#line 906
    p->attrib = (unsigned char )0;
    }
#line 897
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 911 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-ild.c"
void drawCubicBezier(double x1 , double y1___0 , double cx1 , double cy1 , double cx2 ,
                     double cy2 , double x2 , double y2 , unsigned char r1 , unsigned char g1 ,
                     unsigned char b1 ) 
{ 
  int len ;
  int steps ;
  int i ;
  double t ;
  double lx ;
  double ly ;
  LaserPoint *p ;
  double __cil_tmp19 ;
  double __cil_tmp20 ;
  double __cil_tmp21 ;
  double __cil_tmp22 ;
  double __cil_tmp23 ;
  double __cil_tmp24 ;
  double __cil_tmp25 ;
  double __cil_tmp26 ;
  pLaserPoint __cil_tmp27 ;
  short __cil_tmp28 ;
  short __cil_tmp29 ;
  int __cil_tmp30 ;

  {
  {
#line 921
  __cil_tmp19 = rint(x1);
  }
  {
#line 921
  __cil_tmp20 = rint(y1___0);
#line 921
  frameDrawInit((int )__cil_tmp19, (int )__cil_tmp20, r1, g1, b1);
#line 924
  lx = cx1 - x1;
#line 925
  ly = cy1 - y1___0;
#line 926
  __cil_tmp21 = sqrt(lx * lx + ly * ly);
#line 926
  __cil_tmp22 = rint(__cil_tmp21);
#line 926
  len = (int )__cil_tmp22;
#line 927
  lx = cx2 - cx1;
#line 928
  ly = cy2 - cy1;
#line 929
  __cil_tmp23 = sqrt(lx * lx + ly * ly);
#line 929
  __cil_tmp24 = rint(__cil_tmp23);
  }
  {
#line 929
  len += __cil_tmp24;
#line 930
  lx = x2 - cx2;
#line 931
  ly = y2 - cy2;
#line 932
  __cil_tmp25 = sqrt(lx * lx + ly * ly);
#line 932
  __cil_tmp26 = rint(__cil_tmp25);
  }
#line 932
  len += __cil_tmp26;
#line 934
  if (len < lineDistance) {
#line 935
    steps = 1;
  } else {
#line 937
    steps = len / lineDistance;
  }
#line 940
  i = 0;
  {
#line 940
  while (1) {
    while_continue: /* CIL Label */ ;
#line 940
    if (! (i <= steps)) {
#line 940
      goto while_break;
    }
    {
#line 941
    t = (double )i / (double )steps;
#line 942
    p = frame_point_add(drawframe);
#line 943
    p->x = clip(((((((double )1 - t) * ((double )1 - t)) * ((double )1 - t)) * x1 + (((cx1 * (double )3) * t) * ((double )1 - t)) * ((double )1 - t)) + (((cx2 * (double )3) * t) * t) * ((double )1 - t)) + ((x2 * t) * t) * t);
#line 944
    p->y = clip(((((((double )1 - t) * ((double )1 - t)) * ((double )1 - t)) * y1___0 + (((cy1 * (double )3) * t) * ((double )1 - t)) * ((double )1 - t)) + (((cy2 * (double )3) * t) * t) * ((double )1 - t)) + ((y2 * t) * t) * t);
#line 945
    p->z = (short )0;
#line 946
    p->r = r1;
#line 947
    p->g = g1;
#line 948
    p->b = b1;
#line 949
    p->attrib = (unsigned char )0;
    }
#line 940
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 955 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-ild.c"
static void OutputILDA(FILE *fdes , int llx , int lly , int urx , int ury , at_spline_list_array_type shape ) 
{ 
  unsigned int this_list ;
  unsigned int this_spline ;
  spline_list_type curr_list ;
  spline_type curr_spline ;
  int last_degree ;
  at_real_coord LastPoint ;
  double sx ;
  int tmp ;
  double sy ;
  int tmp___0 ;
  double ox ;
  double oy ;
  pLaserSequence __cil_tmp19 ;
  unsigned int __cil_tmp20 ;
  unsigned int __cil_tmp21 ;

  {
#line 963
  if (urx - llx > ury - lly) {
#line 963
    tmp = urx - llx;
  } else {
#line 963
    tmp = ury - lly;
  }
#line 963
  sx = 65535. / (double )tmp;
#line 964
  if (urx - llx > ury - lly) {
#line 964
    tmp___0 = urx - llx;
  } else {
#line 964
    tmp___0 = ury - lly;
  }
#line 964
  sy = 65535. / (double )tmp___0;
#line 966
  ox = (double )(llx + urx) / 2.;
#line 967
  oy = (double )(lly + ury) / 2.;
#line 969
  if (fdes == (void *)0) {
#line 970
    return;
  }
  {
#line 972
  drawsequence = newLaserSequence();
#line 974
  LastPoint.x = (gfloat )0;
#line 975
  LastPoint.y = (gfloat )0;
#line 978
  this_list = (unsigned int )0;
  }
  {
#line 978
  while (1) {
    while_continue: /* CIL Label */ ;
#line 978
    if (! (this_list < shape.length)) {
#line 978
      goto while_break;
    }
#line 979
    curr_list = *(shape.data + this_list);
#line 981
    curr_spline = *(curr_list.data + 0);
#line 982
    LastPoint = curr_spline.v[0];
#line 985
    this_spline = (unsigned int )0;
    {
#line 985
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 985
      if (! (this_spline < curr_list.length)) {
#line 985
        goto while_break___0;
      }
#line 986
      curr_spline = *(curr_list.data + this_spline);
#line 987
      last_degree = (int )curr_spline.degree;
      {
#line 990
      if ((unsigned int )((polynomial_degree )last_degree) == (unsigned int )1) {
#line 990
        goto case_1;
      }
#line 996
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 992
      drawLine(((double )LastPoint.x - ox) * sx, ((double )LastPoint.y - oy) * sy,
               ((double )curr_spline.v[3].x - ox) * sx, ((double )curr_spline.v[3].y - oy) * sy,
               curr_list.color.r, curr_list.color.g, curr_list.color.b);
      }
#line 993
      LastPoint = curr_spline.v[3];
#line 994
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 998
      drawCubicBezier(((double )LastPoint.x - ox) * sx, ((double )LastPoint.y - oy) * sy,
                      ((double )curr_spline.v[1].x - ox) * sx, ((double )curr_spline.v[1].y - oy) * sy,
                      ((double )curr_spline.v[2].x - ox) * sx, ((double )curr_spline.v[2].y - oy) * sy,
                      ((double )curr_spline.v[3].x - ox) * sx, ((double )curr_spline.v[3].y - oy) * sy,
                      curr_list.color.r, curr_list.color.g, curr_list.color.b);
      }
#line 999
      LastPoint = curr_spline.v[3];
#line 1000
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 985
      this_spline ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 978
    this_list ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1005
  frameDrawFinish();
#line 1006
  writeILDA(fdes, drawsequence);
  }
  return;
}
}
#line 1009 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-ild.c"
int output_ild_writer(FILE *file , gchar *name , int llx , int lly , int urx , int ury ,
                      at_output_opts_type *opts , at_spline_list_array_type shape ,
                      at_msg_func msg_func , gpointer msg_data , gpointer user_data ) 
{ 
  int __cil_tmp12 ;
  int __cil_tmp13 ;

  {
  {
#line 1020
  write3DFrames = 0;
#line 1021
  trueColorWrite = 1;
#line 1022
  writeTable = 0;
#line 1023
  fromToZero = 1;
#line 1024
  lineDistance = 800;
#line 1025
  blankDistance = 1200;
#line 1026
  insert_anchor_points = 1;
#line 1027
  anchor_thresh = 40;
#line 1030
  OutputILDA(file, llx, lly, urx, ury, shape);
  }
#line 1032
  if (file == stdout) {
#line 1033
    return (0);
  }
  {
#line 1035
  __cil_tmp12 = sequence_frame_count(drawsequence);
  }
  {
#line 1035
  __cil_tmp13 = frame_point_count(drawframe);
#line 1035
  printf("Wrote %d frame with %d points (%d anchors", __cil_tmp12, __cil_tmp13, inserted_anchor_points);
  }
#line 1036
  if (trueColorWrite) {
    {
#line 1037
    printf(", True Color Header");
    }
  }
#line 1038
  if (writeTable) {
    {
#line 1039
    printf(", Color Table");
    }
  }
  {
#line 1040
  printf(").\n");
  }
#line 1041
  return (0);
}
}
#line 808 "/usr/include/glib-2.0/gobject/gobject.h"
__inline static void g_assert_finalize_object___16(GObject *object ) 
{ 
  gpointer weak_pointer ;
  long __cil_tmp3 ;
  long __cil_tmp4 ;

  {
#line 810
  weak_pointer = object;
  {
#line 812
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 812
    __cil_tmp3 = __builtin_expect((long )0, (long )1);
    }
#line 812
    if (__cil_tmp3) {

    } else {
      {
#line 812
      g_assertion_message((char const   *)((gchar *)0), "/usr/include/glib-2.0/gobject/gobject.h",
                          812, (char const   *)"g_assert_finalize_object\312\001@",
                          "\'G_IS_OBJECT (weak_pointer)\' should be TRUE");
      }
    }
#line 812
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 813
  g_object_add_weak_pointer(object, & weak_pointer);
#line 814
  g_object_unref(weak_pointer);
  }
  {
#line 815
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 815
    __cil_tmp4 = __builtin_expect((long )0, (long )1);
    }
#line 815
    if (__cil_tmp4) {

    } else {
      {
#line 815
      g_assertion_message((char const   *)((gchar *)0), "/usr/include/glib-2.0/gobject/gobject.h",
                          815, (char const   *)"g_assert_finalize_object\312\001@\v\313\256\b",
                          "\'weak_pointer\' should be NULLV");
      }
    }
#line 815
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 52 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-plt.c"
static int GetIndexFromRGBValue(int red , int green , int blue ) 
{ 
  int i ;
  int index___35 ;
  int psav ;
  int pnew ;
  int px ;
  int py ;
  int pz ;
  int nred ;
  int ngreen ;
  int nblue ;
  at_color HPGL_COLORS[9] ;
  int __cil_tmp15 ;

  {
#line 54
  index___35 = 0;
#line 55
  psav = 195075;
#line 57
  HPGL_COLORS[0].r = (guint8 )0;
#line 57
  HPGL_COLORS[0].g = (guint8 )0;
#line 57
  HPGL_COLORS[0].b = (guint8 )0;
#line 57
  HPGL_COLORS[1].r = (guint8 )0;
#line 57
  HPGL_COLORS[1].g = (guint8 )0;
#line 57
  HPGL_COLORS[1].b = (guint8 )0;
#line 57
  HPGL_COLORS[2].r = (guint8 )255;
#line 57
  HPGL_COLORS[2].g = (guint8 )0;
#line 57
  HPGL_COLORS[2].b = (guint8 )0;
#line 57
  HPGL_COLORS[3].r = (guint8 )0;
#line 57
  HPGL_COLORS[3].g = (guint8 )255;
#line 57
  HPGL_COLORS[3].b = (guint8 )0;
#line 57
  HPGL_COLORS[4].r = (guint8 )255;
#line 57
  HPGL_COLORS[4].g = (guint8 )255;
#line 57
  HPGL_COLORS[4].b = (guint8 )0;
#line 57
  HPGL_COLORS[5].r = (guint8 )0;
#line 57
  HPGL_COLORS[5].g = (guint8 )0;
#line 57
  HPGL_COLORS[5].b = (guint8 )255;
#line 57
  HPGL_COLORS[6].r = (guint8 )184;
#line 57
  HPGL_COLORS[6].g = (guint8 )0;
#line 57
  HPGL_COLORS[6].b = (guint8 )128;
#line 57
  HPGL_COLORS[7].r = (guint8 )0;
#line 57
  HPGL_COLORS[7].g = (guint8 )255;
#line 57
  HPGL_COLORS[7].b = (guint8 )255;
#line 57
  HPGL_COLORS[8].r = (guint8 )255;
#line 57
  HPGL_COLORS[8].g = (guint8 )132;
#line 57
  HPGL_COLORS[8].b = (guint8 )0;
#line 61
  i = 1;
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
#line 61
    if (! ((unsigned long )i < sizeof(HPGL_COLORS) / sizeof(at_color ))) {
#line 61
      goto while_break;
    }
#line 62
    nred = (int )HPGL_COLORS[i].r;
#line 63
    ngreen = (int )HPGL_COLORS[i].g;
#line 64
    nblue = (int )HPGL_COLORS[i].b;
#line 67
    px = (red - nred) * (red - nred);
#line 68
    py = (green - ngreen) * (green - ngreen);
#line 69
    pz = (blue - nblue) * (blue - nblue);
#line 70
    pnew = (px + py) + pz;
#line 71
    if (pnew < psav) {
#line 72
      psav = pnew;
#line 73
      index___35 = i;
    }
#line 61
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 77
  return (index___35);
}
}
#line 80 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-plt.c"
static void GetSplinePts(at_real_coord *BezierPts , at_real_coord *Splines , int numsplines ) 
{ 
  gfloat t ;
  int count ;
  at_real_coord a ;
  at_real_coord b ;
  at_real_coord c ;
  at_real_coord d ;
  int __cil_tmp10 ;

  {
#line 98
  a.x = (BezierPts + 0)->x;
#line 99
  b.x = (float )3 * ((BezierPts + 1)->x - (BezierPts + 0)->x);
#line 100
  c.x = (float )3 * ((BezierPts + 2)->x - (BezierPts + 1)->x) - b.x;
#line 101
  d.x = ((BezierPts + 3)->x - (BezierPts + 0)->x) - (b.x + c.x);
#line 103
  a.y = (BezierPts + 0)->y;
#line 104
  b.y = (float )3 * ((BezierPts + 1)->y - (BezierPts + 0)->y);
#line 105
  c.y = (float )3 * ((BezierPts + 2)->y - (BezierPts + 1)->y) - b.y;
#line 106
  d.y = ((BezierPts + 3)->y - (BezierPts + 0)->y) - (b.y + c.y);
#line 109
  count = 0;
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 109
    if (! (count < numsplines)) {
#line 109
      goto while_break;
    }
#line 110
    t = (float )count / (float )(numsplines - 1);
#line 111
    if (count == 0) {
#line 112
      *(Splines + count) = *(BezierPts + 0);
    } else
#line 113
    if (count == numsplines - 1) {
#line 114
      *(Splines + count) = *(BezierPts + 3);
    } else {
#line 116
      (Splines + count)->x = a.x + t * (b.x + t * (c.x + t * d.x));
#line 117
      (Splines + count)->y = a.y + t * (b.y + t * (c.y + t * d.y));
    }
#line 109
    count ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 122 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-plt.c"
static void WriteBezier(FILE *fdes , spline_type sp1 , at_real_coord *BeginPt ) 
{ 
  at_real_coord Splines[8] ;
  at_real_coord BezierPts[4] ;
  at_real_coord LastPoint ;
  int i ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 128
  BezierPts[0] = *BeginPt;
#line 129
  BezierPts[1] = sp1.v[1];
#line 130
  BezierPts[2] = sp1.v[2];
#line 131
  BezierPts[3] = sp1.v[3];
#line 133
  GetSplinePts((at_real_coord *)BezierPts, (at_real_coord *)Splines, 8);
#line 135
  i = 1;
  }
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    if (! (i < 8)) {
#line 135
      goto while_break;
    }
    {
#line 136
    LastPoint = Splines[i];
#line 137
    __cil_tmp8 = fprintf(fdes, "PD%d %d;\020B\036\v\027V", (uint32_t )(LastPoint.x * (gfloat )1.),
                         (uint32_t )(LastPoint.y * (gfloat )1.));
    }
#line 135
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 140
  *BeginPt = LastPoint;
  return;
}
}
#line 143 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-plt.c"
static void OutputPlt(FILE *fdes , int llx , int lly , int urx , int ury , at_spline_list_array_type shape ) 
{ 
  int plu_inch ;
  int LOGXPIXELS ;
  unsigned int this_list ;
  unsigned int this_spline ;
  unsigned char red ;
  unsigned char green ;
  unsigned char blue ;
  uint32_t last_color ;
  uint32_t curr_color ;
  spline_list_type curr_list ;
  spline_type curr_spline ;
  int last_degree ;
  int index___36 ;
  float Scale ;
  at_real_coord StartPoint ;
  at_real_coord LastPoint ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  unsigned int __cil_tmp30 ;
  unsigned int __cil_tmp31 ;
  int __cil_tmp32 ;

  {
#line 148
  plu_inch = 1016;
#line 149
  LOGXPIXELS = 120;
#line 153
  last_color = 4294967295U;
#line 157
  Scale = (float )plu_inch / (float )LOGXPIXELS;
#line 161
  if (fdes == (void *)0) {
#line 162
    return;
  }
  {
#line 165
  __cil_tmp23 = fputs("IN;", fdes);
#line 168
  __cil_tmp24 = fprintf(fdes, "IP %d %d %d %d;", (uint32_t )(Scale * (float )llx),
                        (uint32_t )(Scale * (float )lly), (uint32_t )(Scale * (float )urx),
                        (uint32_t )(Scale * (float )ury));
#line 169
  __cil_tmp25 = fprintf(fdes, "SC %d %d %d %d;", llx, urx, lly, ury);
#line 171
  LastPoint.x = (gfloat )0;
#line 172
  LastPoint.y = (gfloat )0;
#line 173
  StartPoint = LastPoint;
#line 176
  this_list = (unsigned int )0;
  }
  {
#line 176
  while (1) {
    while_continue: /* CIL Label */ ;
#line 176
    if (! (this_list < shape.length)) {
#line 176
      goto while_break;
    }
#line 177
    curr_list = *(shape.data + this_list);
#line 180
    curr_color = (uint32_t )((((int )curr_list.color.r & 255) | (((int )curr_list.color.g & 255) << 8)) | (((int )curr_list.color.b & 255) << 16));
#line 181
    if (this_list == 0U) {
      _L: /* CIL Label */ 
#line 183
      blue = curr_list.color.b;
#line 183
      green = curr_list.color.g;
      {
#line 183
      red = curr_list.color.r;
#line 184
      index___36 = GetIndexFromRGBValue((int )red, (int )green, (int )blue);
#line 185
      __cil_tmp27 = fprintf(fdes, "SP%d;", index___36);
#line 186
      last_color = curr_color;
      }
    } else
#line 181
    if (curr_color != last_color) {
#line 181
      goto _L;
    }
    {
#line 189
    curr_spline = *(curr_list.data + 0);
#line 190
    LastPoint = curr_spline.v[0];
#line 191
    __cil_tmp28 = fprintf(fdes, "PU%d %d;\230\001", (uint32_t )(LastPoint.x * (gfloat )1.),
                          (uint32_t )(LastPoint.y * (gfloat )1.));
#line 192
    StartPoint = LastPoint;
#line 195
    this_spline = (unsigned int )0;
    }
    {
#line 195
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 195
      if (! (this_spline < curr_list.length)) {
#line 195
        goto while_break___0;
      }
#line 196
      curr_spline = *(curr_list.data + this_spline);
#line 197
      last_degree = (int )curr_spline.degree;
      {
#line 200
      if ((unsigned int )((polynomial_degree )last_degree) == (unsigned int )1) {
#line 200
        goto case_1;
      }
#line 205
      goto switch_default;
      case_1: /* CIL Label */ 
#line 202
      LastPoint = curr_spline.v[3];
      {
#line 203
      __cil_tmp29 = fprintf(fdes, "PD%d %d;\230\001", (uint32_t )(LastPoint.x * (gfloat )1.),
                            (uint32_t )(LastPoint.y * (gfloat )1.));
      }
#line 204
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 207
      WriteBezier(fdes, curr_spline, & LastPoint);
      }
#line 208
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 195
      this_spline ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 176
    this_list ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 213
  __cil_tmp32 = fprintf(fdes, "PU%d %d;\230\001", (uint32_t )(LastPoint.x * (gfloat )1.),
                        (uint32_t )(LastPoint.y * (gfloat )1.));
  }
  return;
}
}
#line 219 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-plt.c"
int output_plt_writer(FILE *file , gchar *name , int llx , int lly , int urx , int ury ,
                      at_output_opts_type *opts , at_spline_list_array_type shape ,
                      at_msg_func msg_func , gpointer msg_data , gpointer user_data ) 
{ 


  {
  {
#line 229
  OutputPlt(file, llx, lly, urx, ury, shape);
  }
#line 231
  return (0);
}
}
#line 50 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-pov.c"
static void out_splines(FILE *pov_file , at_spline_list_array_type shape ) 
{ 
  unsigned int this_list ;
  spline_list_type list ;
  at_color last_color ;
  unsigned int this_spline ;
  spline_type first ;
  unsigned int test_list ;
  unsigned int number ;
  spline_list_type testlist ;
  gboolean __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  gboolean __cil_tmp13 ;
  gboolean __cil_tmp14 ;
  spline_type s ;
  unsigned int __cil_tmp16 ;
  unsigned int __cil_tmp17 ;

  {
#line 55
  last_color.r = (guint8 )0;
#line 55
  last_color.g = (guint8 )0;
#line 55
  last_color.b = (guint8 )0;
#line 57
  this_list = (unsigned int )0;
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    if (! (this_list < shape.length)) {
#line 57
      goto while_break;
    }
#line 61
    number = (unsigned int )0;
#line 63
    list = *(shape.data + this_list);
#line 65
    test_list = this_list;
    {
#line 65
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 65
      if (! (test_list < shape.length)) {
#line 65
        goto while_break___0;
      }
      {
#line 66
      testlist = *(shape.data + test_list);
#line 67
      __cil_tmp11 = at_color_equal(& testlist.color, & list.color);
      }
#line 67
      if (! __cil_tmp11) {
#line 68
        goto while_break___0;
      }
#line 69
      number += testlist.length * 4U;
#line 65
      test_list ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 72
    first = *(list.data + 0);
#line 74
    if (this_list > 0U) {
      {
#line 75
      __cil_tmp13 = at_color_equal(& list.color, & last_color);
      }
#line 75
      if (! __cil_tmp13) {
        {
#line 76
        fprintf(pov_file, "\n  pigment {rgb<%.3f, %.3f, %.3f>}\n", (double )last_color.r / 255.,
                (double )last_color.g / 255., (double )last_color.b / 255.);
#line 77
        fprintf(pov_file, "%s\n", "  translate <0.0, 0.0, 0.0>");
#line 78
        fprintf(pov_file, "%s\n", "}");
        }
      } else {
        {
#line 80
        fprintf(pov_file, "%s\n", ",");
        }
      }
    }
    {
#line 83
    __cil_tmp14 = at_color_equal(& list.color, & last_color);
    }
#line 83
    if (this_list == 0U) {
      _L: /* CIL Label */ 
      {
#line 84
      fprintf(pov_file, "%s\n", "prism {");
#line 85
      fprintf(pov_file, "%s\n", "  bezier_spline");
#line 86
      fprintf(pov_file, "  %.1f\n", 0.);
#line 87
      fprintf(pov_file, "  %.4f\n", 0.000100000000001);
#line 88
      fprintf(pov_file, "  %d\n", number);
#line 89
      last_color = list.color;
      }
    } else
#line 83
    if (! __cil_tmp14) {
#line 83
      goto _L;
    }
#line 92
    this_spline = (unsigned int )0;
    {
#line 92
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 92
      if (! (this_spline < list.length)) {
#line 92
        goto while_break___1;
      }
#line 93
      s = *(list.data + this_spline);
#line 95
      if (this_spline > 0U) {
        {
#line 96
        fprintf(pov_file, "%s\n", ",");
        }
      }
#line 98
      if ((unsigned int )s.degree == 1U) {
        {
#line 99
        fprintf(pov_file, "  <%.3f, %.3f>, <%.3f, %.3f>, <%.3f, %.3f>, <%.3f, %.3f>\230\001",
                (double )s.v[0].x, (double )s.v[0].y, (double )s.v[0].x, (double )s.v[0].y,
                (double )s.v[3].x, (double )s.v[3].y, (double )s.v[3].x, (double )s.v[3].y);
        }
      } else {
        {
#line 101
        fprintf(pov_file, "  <%.3f, %.3f>, <%.3f, %.3f>, <%.3f, %.3f>, <%.3f, %.3f>\230\001",
                (double )s.v[0].x, (double )s.v[0].y, (double )s.v[1].x, (double )s.v[1].y,
                (double )s.v[2].x, (double )s.v[2].y, (double )s.v[3].x, (double )s.v[3].y);
        }
      }
#line 92
      this_spline ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 57
    this_list ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  if (shape.length > 0U) {
    {
#line 105
    fprintf(pov_file, "%s\n", "\220");
#line 106
    fprintf(pov_file, "  pigment {rgb<%.3f, %.3f, %.3f>}\n", (double )list.color.r / 255.,
            (double )list.color.g / 255., (double )list.color.b / 255.);
#line 107
    fprintf(pov_file, "%s\n", "  translate <0.0, 0.0, 0.0>");
#line 108
    fprintf(pov_file, "%s\n", "}");
    }
  }
  return;
}
}
#line 112 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-pov.c"
int output_pov_writer(FILE *pov_file , gchar *name , int llx , int lly , int urx ,
                      int ury , at_output_opts_type *opts , at_spline_list_array_type shape ,
                      at_msg_func msg_func , gpointer msg_data , gpointer user_data ) 
{ 


  {
#line 114
  if (shape.centerline == 1) {
    {
#line 115
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 115
      fputs("fatal: ", stderr);
      }
      {
#line 115
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 115
        if (logging) {
          {
#line 115
          fprintf(stdout, "fatal: ");
          }
        }
#line 115
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 115
      fprintf(stderr, "Povray output currently not supported for centerline method");
      }
      {
#line 115
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 115
        if (logging) {
          {
#line 115
          fprintf(stdout, "Povray output currently not supported for centerline method");
          }
        }
#line 115
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 115
      fputs(".\n", stderr);
#line 115
      exit(1);
      }
#line 115
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 117
  out_splines(pov_file, shape);
  }
#line 119
  return (0);
}
}
#line 32 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-dr2d.c"
float XFactor ;
#line 33
float YFactor ;
#line 34
float LineThickness ;
#line 59
static struct Chunk *BuildDRHD(int x1 , int y1___0 , int x2 , int y2 ) ;
#line 60
static struct Chunk *BuildPPRF(char *Units , int Portrait , char *PageType , float GridSize ) ;
#line 61
static struct Chunk *BuildCMAP(at_spline_list_array_type shape ) ;
#line 62
static struct Chunk *BuildLAYR(void) ;
#line 63
static struct Chunk *BuildDASH(void) ;
#line 64
static struct Chunk *BuildBBOX(spline_list_type list , int height ) ;
#line 65
static struct Chunk *BuildATTR(at_color colour , int StrokeOrFill , struct Chunk *CMAPChunk ) ;
#line 66
static int GetCMAPEntry(at_color colour , struct Chunk *CMAPChunk ) ;
#line 67
static int CountSplines(spline_list_type list ) ;
#line 68
static int SizeFloat(float f , char *Format ) ;
#line 69
static void ShortAsBytes(int value , unsigned char *bytes ) ;
#line 70
static void IntAsBytes(int value , unsigned char *bytes ) ;
#line 71
static void FloatAsIEEEBytes(float value , unsigned char *bytes ) ;
#line 73
static void flt2ieee(float *flt , unsigned char *bytes ) ;
#line 74
static void FreeChunk(struct Chunk *ThisChunk ) ;
#line 75
static void FreeChunks(struct Chunk **ChunkList , int NumChunks ) ;
#line 76
static int TotalSizeChunks(struct Chunk **ChunkList , int NumChunks ) ;
#line 77
static int SizeChunk(struct Chunk *ThisChunk ) ;
#line 78
static void PushPolyPoint(unsigned char *PolyData , int *PolyPoint , float x , float y ) ;
#line 79
static void PushPolyIndicator(unsigned char *PolyData , int *PolyPoint , unsigned int flags ) ;
#line 80
static struct Chunk **GeneratexPLY(struct Chunk *CMAP , at_spline_list_array_type shape ,
                                   int height ) ;
#line 82 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-dr2d.c"
static struct Chunk *BuildCMAP(at_spline_list_array_type shape ) 
{ 
  unsigned int this_list ;
  unsigned int this_list_length ;
  int ListSize ;
  int MaxListSize ;
  int WalkCol ;
  int FoundCol ;
  unsigned char Red ;
  unsigned char Green ;
  unsigned char Blue ;
  unsigned char *CMAP ;
  unsigned char *IndexCol ;
  struct Chunk *CMAPChunk ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  spline_list_type list ;
  at_color curr_color ;
  at_color tmp ;
  int __cil_tmp19 ;
  unsigned int __cil_tmp20 ;

  {
  {
#line 93
  MaxListSize = (int )shape.length;
#line 95
  __cil_tmp14 = malloc(sizeof(struct Chunk ));
#line 95
  CMAPChunk = (struct Chunk *)__cil_tmp14;
  }
#line 95
  if (CMAPChunk == (void *)0) {
    {
#line 96
    fprintf(stderr, "Insufficient memory to allocate CMAP chunk\n");
    }
#line 97
    return ((struct Chunk *)((void *)0));
  }
  {
#line 100
  __cil_tmp15 = malloc((unsigned long )(MaxListSize * 3));
#line 100
  CMAP = (unsigned char *)__cil_tmp15;
  }
#line 100
  if (CMAP == (void *)0) {
    {
#line 101
    fprintf(stderr, "Insufficient memory to allocate colour map (size %d)\n", MaxListSize);
#line 102
    free(CMAPChunk);
    }
#line 103
    return ((struct Chunk *)((void *)0));
  }
#line 106
  ListSize = 0;
#line 107
  this_list_length = shape.length;
#line 108
  this_list = (unsigned int )0;
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;
#line 108
    if (! (this_list < this_list_length)) {
#line 108
      goto while_break;
    }
#line 109
    list = *(shape.data + this_list);
#line 110
    if (shape.background_color != (void *)0 && list.clockwise) {
#line 110
      tmp = *(shape.background_color);
    } else {
#line 110
      tmp = list.color;
    }
#line 110
    curr_color = tmp;
#line 112
    Red = curr_color.r;
#line 113
    Green = curr_color.g;
#line 114
    Blue = curr_color.b;
#line 116
    FoundCol = 0;
#line 117
    WalkCol = 0;
    {
#line 117
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 117
      if (! (WalkCol < ListSize)) {
#line 117
        goto while_break___0;
      }
#line 118
      IndexCol = CMAP + WalkCol * 3;
#line 119
      if ((int )*IndexCol == (int )Red) {
#line 119
        if ((int )*(IndexCol + 1) == (int )Green) {
#line 119
          if ((int )*(IndexCol + 2) == (int )Blue) {
#line 120
            FoundCol = 1;
#line 121
            goto while_break___0;
          }
        }
      }
#line 117
      WalkCol ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 125
    if (FoundCol == 0) {
#line 126
      IndexCol = CMAP + ListSize * 3;
#line 127
      *IndexCol = Red;
#line 128
      *(IndexCol + 1) = Green;
#line 129
      *(IndexCol + 2) = Blue;
#line 130
      ListSize ++;
    }
#line 108
    this_list ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 134
  strncpy((char *)CMAPChunk->ID, "CMAP", (unsigned long )4);
#line 135
  CMAPChunk->Size = (unsigned int )(ListSize * 3);
#line 136
  CMAPChunk->Data = CMAP;
  }
#line 138
  return (CMAPChunk);
}
}
#line 141 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-dr2d.c"
static int GetCMAPEntry(at_color colour , struct Chunk *CMAPChunk ) 
{ 
  int WalkCol ;
  int ListSize ;
  unsigned char Red ;
  unsigned char Green ;
  unsigned char Blue ;
  unsigned char *IndexCol ;
  unsigned char *CMAPTable ;
  int __cil_tmp10 ;

  {
#line 148
  ListSize = (int )(CMAPChunk->Size / 3U);
#line 149
  CMAPTable = CMAPChunk->Data;
#line 151
  Red = colour.r;
#line 152
  Green = colour.g;
#line 153
  Blue = colour.b;
#line 155
  WalkCol = 0;
  {
#line 155
  while (1) {
    while_continue: /* CIL Label */ ;
#line 155
    if (! (WalkCol < ListSize)) {
#line 155
      goto while_break;
    }
#line 156
    IndexCol = CMAPTable + WalkCol * 3;
#line 157
    if ((int )*IndexCol == (int )Red) {
#line 157
      if ((int )*(IndexCol + 1) == (int )Green) {
#line 157
        if ((int )*(IndexCol + 2) == (int )Blue) {
#line 158
          return (WalkCol);
        }
      }
    }
#line 155
    WalkCol ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 162
  return (- 1);
}
}
#line 165 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-dr2d.c"
static struct Chunk *BuildBBOX(spline_list_type list , int height ) 
{ 
  unsigned int this_spline ;
  unsigned int this_spline_length ;
  float x1 ;
  float y1___0 ;
  float x2 ;
  float y2 ;
  float ex ;
  float ey ;
  struct Chunk *BBOXChunk ;
  unsigned char *BBOXData ;
  spline_type s ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  unsigned int __cil_tmp16 ;

  {
  {
#line 175
  __cil_tmp14 = malloc(sizeof(struct Chunk ));
#line 175
  BBOXChunk = (struct Chunk *)__cil_tmp14;
  }
#line 175
  if (BBOXChunk == (void *)0) {
    {
#line 176
    fprintf(stderr, "Insufficient memory to allocate BBOX chunk\n");
    }
#line 177
    return ((struct Chunk *)((void *)0));
  }
  {
#line 180
  __cil_tmp15 = malloc((unsigned long )16);
#line 180
  BBOXData = (unsigned char *)__cil_tmp15;
  }
#line 180
  if (BBOXData == (void *)0) {
    {
#line 181
    fprintf(stderr, "Insufficient memory to allocate BBOX data\n");
#line 182
    free(BBOXChunk);
    }
#line 183
    return ((struct Chunk *)((void *)0));
  }
#line 186
  s = *(list.data + 0);
#line 188
  x1 = s.v[0].x;
#line 189
  y1___0 = s.v[0].y;
#line 190
  x2 = s.v[0].x;
#line 191
  y2 = s.v[0].y;
#line 193
  this_spline_length = list.length;
#line 194
  this_spline = (unsigned int )0;
  {
#line 194
  while (1) {
    while_continue: /* CIL Label */ ;
#line 194
    if (! (this_spline < this_spline_length)) {
#line 194
      goto while_break;
    }
#line 195
    s = *(list.data + this_spline);
#line 196
    ex = s.v[3].x;
#line 197
    ey = (float )height - s.v[3].y;
#line 199
    if (x1 > ex) {
#line 200
      x1 = ex;
    }
#line 203
    if (y1___0 > ey) {
#line 204
      y1___0 = ey;
    }
#line 207
    if (x2 < ex) {
#line 208
      x2 = ex;
    }
#line 211
    if (y2 < ey) {
#line 212
      y2 = ey;
    }
#line 194
    this_spline ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 216
  FloatAsIEEEBytes(x1 * XFactor, BBOXData);
#line 217
  FloatAsIEEEBytes(y1___0 * YFactor, BBOXData + 4);
#line 218
  FloatAsIEEEBytes(x2 * XFactor, BBOXData + 8);
#line 219
  FloatAsIEEEBytes(y2 * YFactor, BBOXData + 12);
#line 221
  strncpy((char *)BBOXChunk->ID, "BBOX", (unsigned long )4);
#line 222
  BBOXChunk->Size = (unsigned int )16;
#line 223
  BBOXChunk->Data = BBOXData;
  }
#line 225
  return (BBOXChunk);
}
}
#line 228 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-dr2d.c"
static struct Chunk *BuildATTR(at_color colour , int StrokeOrFill , struct Chunk *CMAPChunk ) 
{ 
  struct Chunk *ATTRChunk ;
  unsigned char *ATTRData ;
  int ColourIndex ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;
  int __cil_tmp9 ;
  int tmp ;

  {
  {
#line 234
  __cil_tmp7 = malloc(sizeof(struct Chunk ));
#line 234
  ATTRChunk = (struct Chunk *)__cil_tmp7;
  }
#line 234
  if (ATTRChunk == (void *)0) {
    {
#line 235
    fprintf(stderr, "Insufficient memory to allocate ATTR chunk\n");
    }
#line 236
    return ((struct Chunk *)((void *)0));
  }
  {
#line 239
  __cil_tmp8 = malloc((unsigned long )14);
#line 239
  ATTRData = (unsigned char *)__cil_tmp8;
  }
#line 239
  if (ATTRData == (void *)0) {
    {
#line 240
    fprintf(stderr, "Insufficient memory to allocate ATTR data\n");
#line 241
    free(ATTRChunk);
    }
#line 242
    return ((struct Chunk *)((void *)0));
  }
  {
#line 245
  ColourIndex = GetCMAPEntry(colour, CMAPChunk);
  }
#line 247
  if (StrokeOrFill) {
#line 247
    tmp = 0;
  } else {
#line 247
    tmp = 1;
  }
  {
#line 247
  *(ATTRData + 0) = (unsigned char )tmp;
#line 248
  *(ATTRData + 1) = (unsigned char )3;
#line 249
  *(ATTRData + 2) = (unsigned char )1;
#line 250
  *(ATTRData + 3) = (unsigned char )0;
#line 251
  ShortAsBytes(ColourIndex, ATTRData + 4);
#line 252
  ShortAsBytes(ColourIndex, ATTRData + 6);
#line 253
  ShortAsBytes(0, ATTRData + 8);
#line 254
  FloatAsIEEEBytes(LineThickness, ATTRData + 10);
#line 256
  strncpy((char *)ATTRChunk->ID, "ATTR", (unsigned long )4);
#line 257
  ATTRChunk->Size = (unsigned int )14;
#line 258
  ATTRChunk->Data = ATTRData;
  }
#line 260
  return (ATTRChunk);
}
}
#line 263 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-dr2d.c"
static struct Chunk *BuildDRHD(int x1 , int y1___0 , int x2 , int y2 ) 
{ 
  struct Chunk *DRHDChunk ;
  unsigned char *DRHDData ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;

  {
  {
#line 268
  __cil_tmp7 = malloc(sizeof(struct Chunk ));
#line 268
  DRHDChunk = (struct Chunk *)__cil_tmp7;
  }
#line 268
  if (DRHDChunk == (void *)0) {
    {
#line 269
    fprintf(stderr, "Insufficient memory to allocate DRHD chunk\n");
    }
#line 270
    return ((struct Chunk *)((void *)0));
  }
  {
#line 273
  __cil_tmp8 = malloc((unsigned long )16);
#line 273
  DRHDData = (unsigned char *)__cil_tmp8;
  }
#line 273
  if (DRHDData == (void *)0) {
    {
#line 274
    fprintf(stderr, "Insufficient memory to allocate DRHD data\n");
#line 275
    free(DRHDChunk);
    }
#line 276
    return ((struct Chunk *)((void *)0));
  }
  {
#line 279
  FloatAsIEEEBytes((float )x1 * XFactor, DRHDData);
#line 280
  FloatAsIEEEBytes((float )y1___0 * YFactor, DRHDData + 4);
#line 281
  FloatAsIEEEBytes((float )x2 * XFactor, DRHDData + 8);
#line 282
  FloatAsIEEEBytes((float )y2 * YFactor, DRHDData + 12);
#line 284
  strncpy((char *)DRHDChunk->ID, "DRHD", (unsigned long )4);
#line 285
  DRHDChunk->Size = (unsigned int )16;
#line 286
  DRHDChunk->Data = DRHDData;
  }
#line 288
  return (DRHDChunk);
}
}
#line 291 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-dr2d.c"
static struct Chunk *BuildPPRF(char *Units , int Portrait , char *PageType , float GridSize ) 
{ 
  struct Chunk *PPRFChunk ;
  char *PPRFData ;
  char *PPRFPos ;
  int ChunkSize ;
  void *__cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  int tmp ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  int __cil_tmp17 ;
  void *__cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  char const   *tmp___0 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;

  {
  {
#line 298
  __cil_tmp9 = malloc(sizeof(struct Chunk ));
#line 298
  PPRFChunk = (struct Chunk *)__cil_tmp9;
  }
#line 298
  if (PPRFChunk == (void *)0) {
    {
#line 299
    fprintf(stderr, "Insufficient memory to allocate PPRF chunk\n");
    }
#line 300
    return ((struct Chunk *)((void *)0));
  }
  {
#line 303
  __cil_tmp11 = strlen((char const   *)Units);
  }
  {
#line 303
  __cil_tmp10 = strlen("Units=");
#line 303
  ChunkSize = (int )((__cil_tmp10 + __cil_tmp11) + 1UL);
  }
#line 304
  if (Portrait) {
#line 304
    tmp = 4;
  } else {
#line 304
    tmp = 5;
  }
  {
#line 304
  __cil_tmp12 = strlen("Portrait=");
  }
  {
#line 304
  ChunkSize += (__cil_tmp12 + (unsigned long )tmp) + 1UL;
#line 305
  __cil_tmp15 = strlen((char const   *)PageType);
  }
  {
#line 305
  __cil_tmp14 = strlen("PageType=");
  }
  {
#line 305
  ChunkSize += (__cil_tmp14 + __cil_tmp15) + 1UL;
#line 306
  __cil_tmp17 = SizeFloat(GridSize, "%f");
  }
  {
#line 306
  __cil_tmp16 = strlen("GridSize=");
  }
  {
#line 306
  ChunkSize += (__cil_tmp16 + (unsigned long )__cil_tmp17) + 1UL;
#line 308
  __cil_tmp18 = malloc((unsigned long )ChunkSize);
#line 308
  PPRFData = (char *)__cil_tmp18;
  }
#line 308
  if (PPRFData == (void *)0) {
    {
#line 309
    fprintf(stderr, "Insufficient memory to allocate PPRF data\n");
#line 310
    free(PPRFChunk);
    }
#line 311
    return ((struct Chunk *)((void *)0));
  }
  {
#line 314
  PPRFPos = PPRFData;
#line 315
  sprintf(PPRFPos, "Units=%s\230\001", Units);
#line 316
  __cil_tmp19 = strlen((char const   *)PPRFPos);
  }
#line 316
  PPRFPos += __cil_tmp19 + 1UL;
#line 317
  if (Portrait) {
#line 317
    tmp___0 = "True";
  } else {
#line 317
    tmp___0 = "False";
  }
  {
#line 317
  sprintf(PPRFPos, "Portrait=%s", tmp___0);
#line 318
  __cil_tmp21 = strlen((char const   *)PPRFPos);
  }
  {
#line 318
  PPRFPos += __cil_tmp21 + 1UL;
#line 319
  sprintf(PPRFPos, "PageType=%s", PageType);
#line 320
  __cil_tmp22 = strlen((char const   *)PPRFPos);
  }
  {
#line 320
  PPRFPos += __cil_tmp22 + 1UL;
#line 321
  sprintf(PPRFPos, "GridSize=%f", (double )GridSize);
#line 323
  strncpy((char *)PPRFChunk->ID, "PPRF", (unsigned long )4);
#line 324
  PPRFChunk->Size = (unsigned int )ChunkSize;
#line 325
  PPRFChunk->Data = (unsigned char *)PPRFData;
  }
#line 327
  return (PPRFChunk);
}
}
#line 330 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-dr2d.c"
static struct Chunk *BuildLAYR(void) 
{ 
  struct Chunk *LAYRChunk ;
  unsigned char *LAYRData ;
  void *__cil_tmp3 ;
  void *__cil_tmp4 ;

  {
  {
#line 335
  __cil_tmp3 = malloc(sizeof(struct Chunk ));
#line 335
  LAYRChunk = (struct Chunk *)__cil_tmp3;
  }
#line 335
  if (LAYRChunk == (void *)0) {
    {
#line 336
    fprintf(stderr, "Insufficient memory to allocate LAYR chunk\n");
    }
#line 337
    return ((struct Chunk *)((void *)0));
  }
  {
#line 340
  __cil_tmp4 = malloc((unsigned long )20);
#line 340
  LAYRData = (unsigned char *)__cil_tmp4;
  }
#line 340
  if (LAYRData == (void *)0) {
    {
#line 341
    fprintf(stderr, "Insufficient memory to allocate LAYR data\n");
#line 342
    free(LAYRChunk);
    }
#line 343
    return ((struct Chunk *)((void *)0));
  }
  {
#line 346
  ShortAsBytes(0, LAYRData);
#line 347
  memset(LAYRData + 2, 0, (unsigned long )16);
#line 348
  strcpy((char *)(LAYRData + 2), "Default layer");
#line 349
  *(LAYRData + 18) = (unsigned char )3;
#line 350
  *(LAYRData + 19) = (unsigned char )0;
#line 352
  strncpy((char *)LAYRChunk->ID, "LAYR", (unsigned long )4);
#line 353
  LAYRChunk->Size = (unsigned int )20;
#line 354
  LAYRChunk->Data = LAYRData;
  }
#line 356
  return (LAYRChunk);
}
}
#line 359 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-dr2d.c"
static struct Chunk *BuildDASH(void) 
{ 
  struct Chunk *DASHChunk ;
  unsigned char *DASHData ;
  void *__cil_tmp3 ;
  void *__cil_tmp4 ;

  {
  {
#line 364
  __cil_tmp3 = malloc(sizeof(struct Chunk ));
#line 364
  DASHChunk = (struct Chunk *)__cil_tmp3;
  }
#line 364
  if (DASHChunk == (void *)0) {
    {
#line 365
    fprintf(stderr, "Insufficient memory to allocate DASH chunk\n");
    }
#line 366
    return ((struct Chunk *)((void *)0));
  }
  {
#line 369
  __cil_tmp4 = malloc((unsigned long )4);
#line 369
  DASHData = (unsigned char *)__cil_tmp4;
  }
#line 369
  if (DASHData == (void *)0) {
    {
#line 370
    fprintf(stderr, "Insufficient memory to allocate DASH data\n");
#line 371
    free(DASHChunk);
    }
#line 372
    return ((struct Chunk *)((void *)0));
  }
  {
#line 375
  ShortAsBytes(1, DASHData);
#line 376
  ShortAsBytes(0, DASHData + 2);
#line 378
  strncpy((char *)DASHChunk->ID, "DASH", (unsigned long )4);
#line 379
  DASHChunk->Size = (unsigned int )4;
#line 380
  DASHChunk->Data = DASHData;
  }
#line 382
  return (DASHChunk);
}
}
#line 385 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-dr2d.c"
static struct Chunk **GeneratexPLY(struct Chunk *CMAP , at_spline_list_array_type shape ,
                                   int height ) 
{ 
  unsigned int this_list ;
  unsigned int this_list_length ;
  unsigned int this_spline ;
  unsigned int this_spline_length ;
  spline_type s ;
  struct Chunk **ChunkList ;
  struct Chunk *PolyChunk ;
  int ListPoint ;
  int PolySize ;
  int PolyPoint ;
  int NumPoints ;
  int StrokeOrFill ;
  unsigned char *PolyData ;
  void *__cil_tmp17 ;
  spline_list_type list ;
  spline_type first ;
  at_color curr_color ;
  at_color tmp ;
  int __cil_tmp22 ;
  struct Chunk *__cil_tmp23 ;
  int __cil_tmp24 ;
  struct Chunk *__cil_tmp25 ;
  void *__cil_tmp26 ;
  int __cil_tmp27 ;
  void *__cil_tmp28 ;
  int __cil_tmp29 ;
  char const   *tmp___0 ;
  unsigned int __cil_tmp31 ;
  unsigned int __cil_tmp32 ;

  {
  {
#line 398
  this_list_length = shape.length;
#line 401
  __cil_tmp17 = malloc(sizeof(struct Chunk ) * (unsigned long )(this_list_length * 3U));
#line 401
  ChunkList = (struct Chunk **)__cil_tmp17;
  }
#line 401
  if (ChunkList == (void *)0) {
    {
#line 402
    fprintf(stderr, "Insufficient memory to allocate chunk list\n");
    }
#line 403
    return ((struct Chunk **)((void *)0));
  }
#line 406
  ListPoint = 0;
#line 407
  this_list = (unsigned int )0;
  {
#line 407
  while (1) {
    while_continue: /* CIL Label */ ;
#line 407
    if (! (this_list < this_list_length)) {
#line 407
      goto while_break;
    }
#line 408
    list = *(shape.data + this_list);
#line 409
    first = *(list.data + 0);
#line 410
    if (shape.background_color != (void *)0 && list.clockwise) {
#line 410
      tmp = *(shape.background_color);
    } else {
#line 410
      tmp = list.color;
    }
    {
#line 410
    curr_color = tmp;
#line 412
    StrokeOrFill = shape.centerline || list.open;
#line 413
    this_spline_length = list.length;
#line 415
    __cil_tmp22 = ListPoint;
#line 415
    ListPoint ++;
#line 415
    *(ChunkList + __cil_tmp22) = BuildBBOX(list, height);
#line 416
    __cil_tmp24 = ListPoint;
#line 416
    ListPoint ++;
#line 416
    *(ChunkList + __cil_tmp24) = BuildATTR(curr_color, StrokeOrFill, CMAP);
#line 418
    __cil_tmp26 = malloc(sizeof(struct Chunk ));
#line 418
    PolyChunk = (struct Chunk *)__cil_tmp26;
    }
#line 418
    if (PolyChunk == (void *)0) {
      {
#line 419
      fprintf(stderr, "Insufficient memory to allocate xPLY chunk\n");
#line 420
      FreeChunks(ChunkList, ListPoint);
      }
#line 421
      return ((struct Chunk **)((void *)0));
    }
    {
#line 424
    NumPoints = CountSplines(list);
#line 427
    PolySize = (NumPoints << 3) + 2;
#line 428
    __cil_tmp28 = malloc((unsigned long )PolySize);
#line 428
    PolyData = (unsigned char *)__cil_tmp28;
    }
#line 428
    if (PolyData == (void *)0) {
      {
#line 429
      fprintf(stderr, "Insufficient memory to allocate xPLY data\n");
#line 430
      free(PolyChunk);
#line 431
      free(PolyData);
#line 432
      FreeChunks(ChunkList, ListPoint);
      }
#line 433
      return ((struct Chunk **)((void *)0));
    }
#line 436
    __cil_tmp29 = ListPoint;
#line 436
    ListPoint ++;
#line 436
    *(ChunkList + __cil_tmp29) = PolyChunk;
#line 437
    if (StrokeOrFill) {
#line 437
      tmp___0 = "OPLY";
    } else {
#line 437
      tmp___0 = "CPLY";
    }
    {
#line 437
    strncpy((char *)PolyChunk->ID, tmp___0, (unsigned long )4);
#line 438
    PolyChunk->Size = (unsigned int )PolySize;
#line 439
    PolyChunk->Data = PolyData;
#line 441
    ShortAsBytes(NumPoints, PolyData);
#line 442
    PolyPoint = 2;
    }
#line 444
    if ((unsigned int )first.degree == 1U) {
      {
#line 445
      PushPolyPoint(PolyData, & PolyPoint, first.v[0].x, (float )height - first.v[0].y);
      }
    }
#line 448
    this_spline = (unsigned int )0;
    {
#line 448
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 448
      if (! (this_spline < this_spline_length)) {
#line 448
        goto while_break___0;
      }
#line 449
      s = *(list.data + this_spline);
#line 451
      if ((unsigned int )s.degree == 1U) {
        {
#line 452
        PushPolyPoint(PolyData, & PolyPoint, s.v[3].x, (float )height - s.v[3].y);
        }
      } else {
        {
#line 454
        PushPolyIndicator(PolyData, & PolyPoint, (unsigned int )1);
#line 455
        PushPolyPoint(PolyData, & PolyPoint, s.v[0].x, (float )height - s.v[0].y);
#line 456
        PushPolyPoint(PolyData, & PolyPoint, s.v[1].x, (float )height - s.v[1].y);
#line 457
        PushPolyPoint(PolyData, & PolyPoint, s.v[2].x, (float )height - s.v[2].y);
#line 458
        PushPolyPoint(PolyData, & PolyPoint, s.v[3].x, (float )height - s.v[3].y);
        }
      }
#line 448
      this_spline ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 407
    this_list ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 463
  return (ChunkList);
}
}
#line 466 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-dr2d.c"
static int CountSplines(spline_list_type list ) 
{ 
  unsigned int this_spline ;
  unsigned int this_spline_length ;
  int Total ;
  unsigned int __cil_tmp5 ;

  {
#line 472
  Total = 0;
#line 474
  if ((unsigned int )(list.data + 0)->degree == 1U) {
#line 475
    Total ++;
  }
#line 478
  this_spline_length = list.length;
#line 479
  this_spline = (unsigned int )0;
  {
#line 479
  while (1) {
    while_continue: /* CIL Label */ ;
#line 479
    if (! (this_spline < this_spline_length)) {
#line 479
      goto while_break;
    }
#line 480
    if ((unsigned int )(list.data + this_spline)->degree == 1U) {
#line 481
      Total ++;
    } else {
#line 483
      Total += 5;
    }
#line 479
    this_spline ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 487
  return (Total);
}
}
#line 490 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-dr2d.c"
static void PushPolyPoint(unsigned char *PolyData , int *PolyPoint , float x , float y ) 
{ 
  int PolyLocal ;

  {
  {
#line 494
  PolyLocal = *PolyPoint;
#line 496
  FloatAsIEEEBytes(x * XFactor, PolyData + PolyLocal);
#line 497
  PolyLocal += 4;
#line 498
  FloatAsIEEEBytes(y * YFactor, PolyData + PolyLocal);
#line 500
  *PolyPoint = PolyLocal + 4;
  }
  return;
}
}
#line 503 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-dr2d.c"
static void PushPolyIndicator(unsigned char *PolyData , int *PolyPoint , unsigned int flags ) 
{ 
  int PolyLocal ;

  {
  {
#line 507
  PolyLocal = *PolyPoint;
#line 509
  IntAsBytes((int )4294967295U, PolyData + PolyLocal);
#line 510
  PolyLocal += 4;
#line 511
  IntAsBytes((int )flags, PolyData + PolyLocal);
#line 513
  *PolyPoint = PolyLocal + 4;
  }
  return;
}
}
#line 516 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-dr2d.c"
static void WriteChunk(FILE *file , struct Chunk *Chunk ) 
{ 
  unsigned char SizeBytes[4] ;
  int Size ;

  {
  {
#line 521
  Size = (int )Chunk->Size;
#line 522
  IntAsBytes(Size, (unsigned char *)SizeBytes);
#line 524
  fwrite((char *)Chunk->ID, (unsigned long )4, (unsigned long )1, file);
#line 525
  fwrite((unsigned char *)SizeBytes, (unsigned long )4, (unsigned long )1, file);
#line 526
  fwrite(Chunk->Data, (unsigned long )Size, (unsigned long )1, file);
  }
#line 527
  if (Size & 1) {
    {
#line 528
    fprintf(file, "%c", 0);
    }
  }
  return;
}
}
#line 532 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-dr2d.c"
static void WriteChunks(FILE *file , struct Chunk **ChunkList , int NumChunks ) 
{ 
  int WalkChunks ;
  int __cil_tmp5 ;

  {
#line 536
  WalkChunks = 0;
  {
#line 536
  while (1) {
    while_continue: /* CIL Label */ ;
#line 536
    if (! (WalkChunks < NumChunks)) {
#line 536
      goto while_break;
    }
    {
#line 537
    WriteChunk(file, *(ChunkList + WalkChunks));
    }
#line 536
    WalkChunks ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 541 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-dr2d.c"
static int TotalSizeChunks(struct Chunk **ChunkList , int NumChunks ) 
{ 
  int WalkChunks ;
  int Size ;
  int Total ;
  int __cil_tmp6 ;

  {
#line 547
  Total = 0;
#line 548
  WalkChunks = 0;
  {
#line 548
  while (1) {
    while_continue: /* CIL Label */ ;
#line 548
    if (! (WalkChunks < NumChunks)) {
#line 548
      goto while_break;
    }
#line 550
    Size = (int )(*(ChunkList + WalkChunks))->Size;
#line 551
    Size += Size & 1;
#line 552
    Total += Size + 8;
#line 548
    WalkChunks ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 555
  return (Total);
}
}
#line 558 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-dr2d.c"
static int SizeChunk(struct Chunk *ThisChunk ) 
{ 
  int Size ;

  {
#line 562
  Size = (int )ThisChunk->Size;
#line 563
  Size += Size & 1;
#line 565
  return (Size);
}
}
#line 568 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-dr2d.c"
static void FreeChunk(struct Chunk *ThisChunk ) 
{ 


  {
  {
#line 570
  free(ThisChunk->Data);
#line 571
  free(ThisChunk);
  }
  return;
}
}
#line 574 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-dr2d.c"
static void FreeChunks(struct Chunk **ChunkList , int NumChunks ) 
{ 
  int WalkChunks ;
  int __cil_tmp4 ;

  {
#line 578
  WalkChunks = 0;
  {
#line 578
  while (1) {
    while_continue: /* CIL Label */ ;
#line 578
    if (! (WalkChunks < NumChunks)) {
#line 578
      goto while_break;
    }
    {
#line 579
    FreeChunk(*(ChunkList + WalkChunks));
    }
#line 578
    WalkChunks ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 583 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-dr2d.c"
int output_dr2d_writer(FILE *file , gchar *name , int llx , int lly , int urx , int ury ,
                       at_output_opts_type *opts , at_spline_list_array_type shape ,
                       at_msg_func msg_func , gpointer msg_data , gpointer user_data ) 
{ 
  int width ;
  int height ;
  int NumSplines ;
  int FORMSize ;
  int Portrait ;
  struct Chunk *DRHDChunk ;
  struct Chunk *PPRFChunk ;
  struct Chunk *LAYRChunk ;
  struct Chunk *DASHChunk ;
  struct Chunk *CMAPChunk ;
  struct Chunk **ChunkList ;
  unsigned char SizeBytes[4] ;
  struct Chunk *__cil_tmp24 ;
  struct Chunk *__cil_tmp25 ;
  struct Chunk *__cil_tmp26 ;
  struct Chunk *__cil_tmp27 ;
  struct Chunk *__cil_tmp28 ;
  struct Chunk **__cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;

  {
#line 585
  width = urx - llx;
#line 586
  height = ury - lly;
#line 597
  Portrait = width < height;
#line 599
  if (Portrait) {
#line 600
    XFactor = ((float )11.693 / (float )width) * (float )(1 << 10);
#line 601
    YFactor = XFactor;
  } else {
#line 603
    YFactor = ((float )8.26810000001 / (float )height) * (float )(1 << 10);
#line 604
    XFactor = YFactor;
  }
  {
#line 607
  LineThickness = (float )1. / (float )opts->dpi;
#line 609
  DRHDChunk = BuildDRHD(llx, lly, urx, ury);
#line 610
  PPRFChunk = BuildPPRF("Inch", Portrait, "A4", (float )1.);
#line 611
  LAYRChunk = BuildLAYR();
#line 612
  DASHChunk = BuildDASH();
#line 613
  CMAPChunk = BuildCMAP(shape);
#line 615
  ChunkList = GeneratexPLY(CMAPChunk, shape, height);
#line 617
  NumSplines = (int )(shape.length * 3U);
#line 618
  __cil_tmp35 = TotalSizeChunks(ChunkList, NumSplines);
  }
  {
#line 618
  __cil_tmp34 = SizeChunk(CMAPChunk);
  }
  {
#line 618
  __cil_tmp33 = SizeChunk(DASHChunk);
  }
  {
#line 618
  __cil_tmp32 = SizeChunk(LAYRChunk);
  }
  {
#line 618
  __cil_tmp31 = SizeChunk(PPRFChunk);
  }
  {
#line 618
  __cil_tmp30 = SizeChunk(DRHDChunk);
#line 618
  FORMSize = (((((4 + (__cil_tmp30 + 8)) + (__cil_tmp31 + 8)) + (__cil_tmp32 + 8)) + (__cil_tmp33 + 8)) + (__cil_tmp34 + 8)) + __cil_tmp35;
#line 620
  IntAsBytes(FORMSize, (unsigned char *)SizeBytes);
#line 621
  fprintf(file, "FORM");
#line 622
  fwrite((unsigned char *)SizeBytes, (unsigned long )4, (unsigned long )1, file);
#line 623
  fprintf(file, "DR2D");
#line 625
  WriteChunk(file, DRHDChunk);
#line 626
  FreeChunk(DRHDChunk);
#line 627
  WriteChunk(file, PPRFChunk);
#line 628
  FreeChunk(PPRFChunk);
#line 629
  WriteChunk(file, LAYRChunk);
#line 630
  FreeChunk(LAYRChunk);
#line 631
  WriteChunk(file, DASHChunk);
#line 632
  FreeChunk(DASHChunk);
#line 633
  WriteChunk(file, CMAPChunk);
#line 634
  FreeChunk(CMAPChunk);
#line 635
  WriteChunks(file, ChunkList, NumSplines);
#line 636
  FreeChunks(ChunkList, NumSplines);
  }
#line 638
  return (0);
}
}
#line 641 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-dr2d.c"
static int SizeFloat(float f , char *Format ) 
{ 
  char FloatString[100] ;
  int __cil_tmp4 ;

  {
  {
#line 645
  __cil_tmp4 = sprintf((char *)FloatString, (char const   *)Format, (double )f);
  }
#line 645
  return (__cil_tmp4);
}
}
#line 648 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-dr2d.c"
static void IntAsBytes(int value , unsigned char *bytes ) 
{ 


  {
#line 650
  *bytes = (unsigned char )((value >> 24) & 255);
#line 651
  *(bytes + 1) = (unsigned char )((value >> 16) & 255);
#line 652
  *(bytes + 2) = (unsigned char )((value >> 8) & 255);
#line 653
  *(bytes + 3) = (unsigned char )(value & 255);
  return;
}
}
#line 656 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-dr2d.c"
static void ShortAsBytes(int value , unsigned char *bytes ) 
{ 


  {
#line 658
  *(bytes + 0) = (unsigned char )((value >> 8) & 255);
#line 659
  *(bytes + 1) = (unsigned char )(value & 255);
  return;
}
}
#line 662 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-dr2d.c"
static void FloatAsIEEEBytes(float value , unsigned char *bytes ) 
{ 


  {
  {
#line 664
  flt2ieee(& value, bytes);
  }
  return;
}
}
#line 667 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-dr2d.c"
static void flt2ieee(float *flt , unsigned char *bytes ) 
{ 
  long RealMant ;
  long RealMask ;
  long RealExp ;
  long MoveExp ;
  long __cil_tmp7 ;

  {
#line 672
  RealMant = (long )*flt;
#line 674
  *bytes = (unsigned char )0;
#line 675
  *(bytes + 1) = (unsigned char )0;
#line 676
  *(bytes + 2) = (unsigned char )0;
#line 677
  *(bytes + 3) = (unsigned char )0;
#line 679
  if (RealMant) {
#line 680
    if (RealMant < 0L) {
#line 681
      *bytes |= 128;
#line 682
      RealMant = - RealMant;
    }
#line 685
    RealExp = (long )31;
#line 685
    RealMask = (long )1073741824;
    {
#line 685
    while (1) {
      while_continue: /* CIL Label */ ;
#line 685
      if (! RealMask) {
#line 685
        goto while_break;
      }
#line 686
      if (RealMant & RealMask) {
#line 687
        goto while_break;
      }
#line 685
      __cil_tmp7 = RealExp;
#line 685
      RealExp --;
#line 685
      RealMask >>= 1;
    }
    while_break: /* CIL Label */ ;
    }
#line 691
    if (RealExp > 24L) {
#line 692
      RealMant >>= RealExp - 24L;
    } else {
#line 694
      RealMant <<= 24L - RealExp;
    }
#line 696
    RealExp -= (long )10;
#line 697
    RealExp += (long )126;
#line 699
    MoveExp = RealExp << 23;
#line 700
    *bytes |= (MoveExp >> 24) & 127L;
#line 701
    *(bytes + 1) |= ((MoveExp >> 16) & 128L) | ((RealMant >> 16) & 127L);
#line 702
    *(bytes + 2) |= (RealMant >> 8) & 255L;
#line 703
    *(bytes + 3) |= RealMant & 255L;
  }
  return;
}
}
#line 39 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-cgm.c"
static gboolean write16(FILE *fdes , uint16_t data ) 
{ 
  size_t count ;
  uint8_t outch ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int tmp ;

  {
  {
#line 41
  count = (size_t )0;
#line 44
  outch = (uint8_t )(((int )data >> 8) & 255);
#line 45
  __cil_tmp5 = fwrite(& outch, (unsigned long )1, (unsigned long )1, fdes);
  }
  {
#line 45
  count += __cil_tmp5;
#line 47
  outch = (uint8_t )((int )data & 255);
#line 48
  __cil_tmp6 = fwrite(& outch, (unsigned long )1, (unsigned long )1, fdes);
  }
#line 48
  count += __cil_tmp6;
#line 50
  if (count == sizeof(uint16_t )) {
#line 50
    tmp = ! 0;
  } else {
#line 50
    tmp = 0;
  }
#line 50
  return (tmp);
}
}
#line 53 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-cgm.c"
static gboolean write8(FILE *fdes , uint8_t data ) 
{ 
  size_t count ;
  unsigned long __cil_tmp4 ;
  int tmp ;

  {
  {
#line 55
  count = (size_t )0;
#line 57
  count = fwrite(& data, (unsigned long )1, (unsigned long )1, fdes);
  }
#line 59
  if (count == sizeof(uint8_t )) {
#line 59
    tmp = ! 0;
  } else {
#line 59
    tmp = 0;
  }
#line 59
  return (tmp);
}
}
#line 62 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-cgm.c"
static gboolean output_beginmetafilename(FILE *fdes , char const   *string ) 
{ 
  size_t len ;
  unsigned long __cil_tmp4 ;
  char const   *__cil_tmp5 ;

  {
  {
#line 64
  __cil_tmp4 = strlen(string);
#line 64
  len = __cil_tmp4;
  }
#line 66
  if (len + 1UL < 31UL) {
    {
#line 67
    write16(fdes, (uint16_t )((32UL + len) + 1UL));
    }
  } else {
    {
#line 69
    write16(fdes, (uint16_t )63);
#line 70
    write16(fdes, (uint16_t )(len + 1UL));
    }
  }
  {
#line 73
  write8(fdes, (uint8_t )len);
  }
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
#line 75
    if (! ((int )*string != 0)) {
#line 75
      goto while_break;
    }
    {
#line 76
    write8(fdes, (uint8_t )*string);
#line 77
    string ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 80
  if (len % 2UL == 0UL) {
    {
#line 81
    write8(fdes, (uint8_t )0);
    }
  }
#line 83
  return (! 0);
}
}
#line 86 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-cgm.c"
static gboolean output_beginpicture(FILE *fdes , char const   *string ) 
{ 
  int len ;
  unsigned long __cil_tmp4 ;
  char const   *__cil_tmp5 ;

  {
  {
#line 88
  __cil_tmp4 = strlen(string);
#line 88
  len = (int )__cil_tmp4;
  }
#line 90
  if (len + 1 < 31) {
    {
#line 91
    write16(fdes, (uint16_t )((96 + len) + 1));
    }
  } else {
    {
#line 93
    write16(fdes, (uint16_t )127);
#line 94
    write16(fdes, (uint16_t )(len + 1));
    }
  }
  {
#line 97
  write8(fdes, (uint8_t )len);
  }
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! ((int )*string != 0)) {
#line 99
      goto while_break;
    }
    {
#line 100
    write8(fdes, (uint8_t )*string);
#line 101
    string ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  if (len % 2 == 0) {
    {
#line 105
    write8(fdes, (uint8_t )0);
    }
  }
#line 107
  return (! 0);
}
}
#line 110 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-cgm.c"
static gboolean output_metafiledescription(FILE *fdes , char const   *string ) 
{ 
  int len ;
  unsigned long __cil_tmp4 ;
  char const   *__cil_tmp5 ;

  {
  {
#line 112
  __cil_tmp4 = strlen(string);
#line 112
  len = (int )__cil_tmp4;
  }
#line 114
  if (len + 1 < 31) {
    {
#line 115
    write16(fdes, (uint16_t )((4160 + len) + 1));
    }
  } else {
    {
#line 117
    write16(fdes, (uint16_t )4191);
#line 118
    write16(fdes, (uint16_t )(len + 1));
    }
  }
  {
#line 121
  write8(fdes, (uint8_t )len);
  }
  {
#line 123
  while (1) {
    while_continue: /* CIL Label */ ;
#line 123
    if (! ((int )*string != 0)) {
#line 123
      goto while_break;
    }
    {
#line 124
    write8(fdes, (uint8_t )*string);
#line 125
    string ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 128
  if (len % 2 == 0) {
    {
#line 129
    write8(fdes, (uint8_t )0);
    }
  }
#line 131
  return (! 0);
}
}
#line 134 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-cgm.c"
int output_cgm_writer(FILE *cgm_file , gchar *name , int llx , int lly , int urx ,
                      int ury , at_output_opts_type *opts , at_spline_list_array_type shape ,
                      at_msg_func msg_func , gpointer msg_data , gpointer user_data ) 
{ 
  unsigned int this_list ;
  char *des ;
  char const   *version_string ;
  char const   *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  void *__cil_tmp18 ;
  unsigned int this_spline ;
  spline_list_type list ;
  spline_type s ;
  unsigned int __cil_tmp22 ;
  unsigned int __cil_tmp23 ;

  {
  {
#line 138
  __cil_tmp15 = at_version(! 0);
#line 138
  version_string = __cil_tmp15;
#line 140
  output_beginmetafilename(cgm_file, (char const   *)name);
#line 142
  write16(cgm_file, (uint16_t )4130);
#line 143
  write16(cgm_file, (uint16_t )2);
#line 145
  __cil_tmp17 = strlen(version_string);
  }
  {
#line 145
  __cil_tmp16 = strlen("created by ");
#line 145
  __cil_tmp18 = malloc((__cil_tmp16 + __cil_tmp17) + 1UL);
#line 145
  des = (char *)__cil_tmp18;
#line 146
  strcpy(des, "created by \v\027V");
#line 147
  strcat(des, version_string);
#line 148
  output_metafiledescription(cgm_file, (char const   *)des);
#line 149
  free(des);
#line 151
  write16(cgm_file, (uint16_t )4454);
#line 152
  write16(cgm_file, (uint16_t )1);
#line 153
  write16(cgm_file, (uint16_t )65535);
#line 154
  write16(cgm_file, (uint16_t )1);
#line 156
  output_beginpicture(cgm_file, "pic1\027V");
#line 158
  write16(cgm_file, (uint16_t )8258);
#line 159
  write16(cgm_file, (uint16_t )1);
#line 161
  write16(cgm_file, (uint16_t )8392);
#line 162
  write16(cgm_file, (uint16_t )llx);
#line 163
  write16(cgm_file, (uint16_t )urx);
#line 164
  write16(cgm_file, (uint16_t )ury);
#line 165
  write16(cgm_file, (uint16_t )lly);
#line 167
  write16(cgm_file, (uint16_t )128);
#line 169
  this_list = (unsigned int )0;
  }
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
#line 169
    if (! (this_list < shape.length)) {
#line 169
      goto while_break;
    }
#line 172
    list = *(shape.data + this_list);
#line 174
    if (this_list > 0U) {
#line 175
      if (shape.centerline) {
        {
#line 176
        write16(cgm_file, (uint16_t )512);
        }
      } else {
        {
#line 178
        write16(cgm_file, (uint16_t )288);
        }
      }
    }
#line 181
    if (shape.centerline) {
      {
#line 182
      write16(cgm_file, (uint16_t )20611);
      }
    } else {
      {
#line 184
      write16(cgm_file, (uint16_t )21219);
      }
    }

#line 187
    if (shape.background_color != (void *)0) {
#line 187
      if (list.clockwise) {
        {
#line 188
        write8(cgm_file, (shape.background_color)->r);
#line 189
        write8(cgm_file, (shape.background_color)->g);
#line 190
        write8(cgm_file, (shape.background_color)->b);
        }
      } else {
        {
        {
#line 192
        write8(cgm_file, list.color.r);
        }
        {
#line 193
        write8(cgm_file, list.color.g);
        }
        {
#line 194
        write8(cgm_file, list.color.b);
        }
        }
      }
    } else {
      {
      {
#line 192
      write8(cgm_file, list.color.r);
      }
      {
#line 193
      write8(cgm_file, list.color.g);
      }
      {
#line 194
      write8(cgm_file, list.color.b);
      }
      }
    }
    {
#line 196
    write8(cgm_file, (uint8_t )0);
    }
#line 198
    if (shape.centerline) {
      {
#line 199
      write16(cgm_file, (uint16_t )21442);
#line 200
      write16(cgm_file, (uint16_t )1);
      }
    } else {
      {
#line 202
      write16(cgm_file, (uint16_t )21186);
#line 203
      write16(cgm_file, (uint16_t )1);
      }
    }
#line 206
    if (shape.centerline) {
      {
#line 207
      write16(cgm_file, (uint16_t )480);
      }
    } else {
      {
#line 209
      write16(cgm_file, (uint16_t )256);
      }
    }
#line 211
    this_spline = (unsigned int )0;
    {
#line 211
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 211
      if (! (this_spline < list.length)) {
#line 211
        goto while_break___0;
      }
#line 212
      s = *(list.data + this_spline);
#line 214
      if ((unsigned int )s.degree == 1U) {
        {
#line 215
        write16(cgm_file, (uint16_t )16424);
#line 216
        write16(cgm_file, (uint16_t )s.v[0].x);
#line 217
        write16(cgm_file, (uint16_t )((float )ury - s.v[0].y));
#line 218
        write16(cgm_file, (uint16_t )s.v[3].x);
#line 219
        write16(cgm_file, (uint16_t )((float )ury - s.v[3].y));
        }
      } else {
        {
#line 221
        write16(cgm_file, (uint16_t )17234);
#line 222
        write16(cgm_file, (uint16_t )2);
#line 223
        write16(cgm_file, (uint16_t )s.v[0].x);
#line 224
        write16(cgm_file, (uint16_t )((float )ury - s.v[0].y));
#line 225
        write16(cgm_file, (uint16_t )s.v[1].x);
#line 226
        write16(cgm_file, (uint16_t )((float )ury - s.v[1].y));
#line 227
        write16(cgm_file, (uint16_t )s.v[2].x);
#line 228
        write16(cgm_file, (uint16_t )((float )ury - s.v[2].y));
#line 229
        write16(cgm_file, (uint16_t )s.v[3].x);
#line 230
        write16(cgm_file, (uint16_t )((float )ury - s.v[3].y));
        }
      }
#line 211
      this_spline ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 169
    this_list ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 235
  if (shape.length > 0U) {
#line 236
    if (shape.centerline) {
      {
#line 237
      write16(cgm_file, (uint16_t )512);
      }
    } else {
      {
#line 239
      write16(cgm_file, (uint16_t )288);
      }
    }
  }
  {
#line 242
  write16(cgm_file, (uint16_t )160);
#line 244
  write16(cgm_file, (uint16_t )64);
  }
#line 246
  return (0);
}
}
#line 47 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-mif.c"
BboxT cbox ;
#line 52 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-mif.c"
static char const   *colorstring(int r , int g , int b ) 
{ 
  static char buffer[15] ;

  {
#line 55
  if (r == 0) {
#line 55
    if (g == 0) {
#line 55
      if (b == 0) {
#line 56
        return ("Black");
      } else {
#line 55
        goto _L___48;
      }
    } else {
#line 55
      goto _L___48;
    }
  } else
  _L___48: /* CIL Label */ 
  _L___49: /* CIL Label */ 
#line 57
  if (r == 255) {
#line 57
    if (g == 0) {
#line 57
      if (b == 0) {
#line 58
        return ("Red");
      } else {
#line 57
        goto _L___46;
      }
    } else {
#line 57
      goto _L___46;
    }
  } else
  _L___46: /* CIL Label */ 
  _L___47: /* CIL Label */ 
#line 59
  if (r == 0) {
#line 59
    if (g == 255) {
#line 59
      if (b == 0) {
#line 60
        return ("Green");
      } else {
#line 59
        goto _L___44;
      }
    } else {
#line 59
      goto _L___44;
    }
  } else
  _L___44: /* CIL Label */ 
  _L___45: /* CIL Label */ 
#line 61
  if (r == 0) {
#line 61
    if (g == 0) {
#line 61
      if (b == 255) {
#line 62
        return ("Blue");
      } else {
#line 61
        goto _L___42;
      }
    } else {
#line 61
      goto _L___42;
    }
  } else
  _L___42: /* CIL Label */ 
  _L___43: /* CIL Label */ 
#line 63
  if (r == 255) {
#line 63
    if (g == 255) {
#line 63
      if (b == 0) {
#line 64
        return ("Yellow");
      } else {
#line 63
        goto _L___40;
      }
    } else {
#line 63
      goto _L___40;
    }
  } else
  _L___40: /* CIL Label */ 
  _L___41: /* CIL Label */ 
#line 65
  if (r == 255) {
#line 65
    if (g == 0) {
#line 65
      if (b == 255) {
#line 66
        return ("Magenta");
      } else {
#line 65
        goto _L___38;
      }
    } else {
#line 65
      goto _L___38;
    }
  } else
  _L___38: /* CIL Label */ 
  _L___39: /* CIL Label */ 
#line 67
  if (r == 0) {
#line 67
    if (g == 255) {
#line 67
      if (b == 255) {
#line 68
        return ("Cyan");
      } else {
#line 67
        goto _L;
      }
    } else {
#line 67
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  _L___37: /* CIL Label */ 
#line 69
  if (r == 255) {
#line 69
    if (g == 255) {
#line 69
      if (b == 255) {
#line 70
        return ("White");
      } else {
        {
        {
        {
#line 72
        sprintf((char *)buffer, "R%.3dG%.3dB%.3d", r, g, b);
        }
        }
        }
      }
    } else {
      {
      {
      {
#line 72
      sprintf((char *)buffer, "R%.3dG%.3dB%.3d", r, g, b);
      }
      }
      }
    }
  } else {
    {
    {
    {
#line 72
    sprintf((char *)buffer, "R%.3dG%.3dB%.3d", r, g, b);
    }
    }
    }
  }
#line 74
  return ((char const   *)((char *)buffer));
}
}
#line 80 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-mif.c"
static gfloat bezpnt(gfloat t , gfloat z1 , gfloat z2 , gfloat z3 , gfloat z4 ) 
{ 
  gfloat temp ;
  gfloat t1 ;

  {
#line 84
  if (t < (gfloat )0.) {
#line 85
    t = (gfloat )0.;
  }
#line 87
  if (t > (gfloat )1.) {
#line 88
    t = (gfloat )1.;
  }
#line 90
  t1 = (gfloat )1. - t;
#line 91
  temp = ((((t1 * t1) * t1) * z1 + ((((gfloat )3. * t) * t1) * t1) * z2) + ((((gfloat )3. * t) * t) * t1) * z3) + ((t * t) * t) * z4;
#line 92
  return (temp);
}
}
#line 98 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-mif.c"
static void print_coord(FILE *f , gfloat x , gfloat y ) 
{ 


  {
  {
#line 100
  fprintf(f, "  <Point %.2f %.2f>\n", ((double )x * 72.) / (double )cbox.dpi, ((double )(((float )cbox.ury - y) + (float )1) * 72.) / (double )cbox.dpi);
  }
  return;
}
}
#line 106 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-mif.c"
int output_mif_writer(FILE *ps_file , gchar *name , int llx , int lly , int urx ,
                      int ury , at_output_opts_type *opts , at_spline_list_array_type shape ,
                      at_msg_func msg_func , gpointer msg_data , gpointer user_data ) 
{ 
  unsigned int this_list ;
  int i ;
  ColorT col_tbl[256] ;
  int n_ctbl ;
  at_color curr_color ;
  char const   *__cil_tmp17 ;
  spline_list_type list ;
  at_color tmp ;
  gboolean __cil_tmp20 ;
  int __cil_tmp21 ;
  char const   *__cil_tmp22 ;
  char *__cil_tmp23 ;
  int __cil_tmp24 ;
  unsigned int __cil_tmp25 ;
  int c ;
  int m ;
  int y ;
  int k ;
  int __cil_tmp30 ;
  unsigned int this_spline ;
  gboolean smooth ;
  spline_list_type list___0 ;
  spline_type first ;
  gboolean __cil_tmp35 ;
  int __cil_tmp36 ;
  char const   *tmp___0 ;
  spline_type s ;
  gfloat temp ;
  gfloat dt ;
  double __cil_tmp41 ;
  gfloat __cil_tmp42 ;
  gfloat __cil_tmp43 ;
  unsigned int __cil_tmp44 ;
  char const   *tmp___1 ;
  unsigned int __cil_tmp46 ;

  {
#line 111
  n_ctbl = 0;
#line 112
  curr_color.r = (guint8 )0;
#line 112
  curr_color.g = (guint8 )0;
  {
#line 112
  curr_color.b = (guint8 )0;
#line 114
  cbox.llx = llx;
#line 115
  cbox.lly = lly;
#line 116
  cbox.urx = urx;
#line 117
  cbox.ury = ury;
#line 118
  cbox.dpi = (gfloat )opts->dpi;
#line 120
  __cil_tmp17 = at_version(! 0);
#line 120
  fprintf(ps_file, "<MIFFile 4.00> #%s\n<Units Upt>\n<ColorCatalog\n", __cil_tmp17);
#line 122
  this_list = (unsigned int )0;
  }
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;
#line 122
    if (! (this_list < shape.length)) {
#line 122
      goto while_break;
    }
#line 123
    list = *(shape.data + this_list);
#line 124
    if (shape.background_color != (void *)0 && list.clockwise) {
#line 124
      tmp = *(shape.background_color);
    } else {
#line 124
      tmp = list.color;
    }
#line 124
    curr_color = tmp;
#line 126
    i = 0;
    {
#line 126
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 126
      if (! (i < n_ctbl)) {
#line 126
        goto while_break___0;
      }
      {
#line 127
      __cil_tmp20 = at_color_equal(& curr_color, & col_tbl[i].c);
      }
#line 127
      if (__cil_tmp20) {
#line 128
        goto while_break___0;
      }
#line 126
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 130
    if (i >= n_ctbl) {
      {
#line 131
      __cil_tmp22 = colorstring((int )curr_color.r, (int )curr_color.g, (int )curr_color.b);
#line 131
      __cil_tmp23 = strdup(__cil_tmp22);
#line 131
      col_tbl[n_ctbl].tag = __cil_tmp23;
#line 132
      col_tbl[n_ctbl].c = curr_color;
#line 133
      n_ctbl ++;
      }
    }
#line 122
    this_list ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 136
  i = 0;
  {
#line 136
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 136
    if (! (i < n_ctbl)) {
#line 136
      goto while_break___1;
    }
#line 138
    k = 255 - (int )col_tbl[i].c.r;
#line 138
    c = k;
#line 139
    m = 255 - (int )col_tbl[i].c.g;
#line 140
    if (m < k) {
#line 141
      k = m;
    }
#line 142
    y = 255 - (int )col_tbl[i].c.b;
#line 143
    if (y < k) {
#line 144
      k = y;
    }
    {
#line 145
    c -= k;
#line 146
    m -= k;
#line 147
    y -= k;
#line 148
    fprintf(ps_file, " <Color <ColorTag %s><ColorCyan %d><ColorMagenta %d><ColorYellow %d><ColorBlack %d>>\n\nL\f\027V",
            col_tbl[i].tag, (c * 100) / 255, (m * 100) / 255, (y * 100) / 255, (k * 100) / 255);
    }
#line 136
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 150
  fprintf(ps_file, ">\nL\f\027V");
#line 152
  fprintf(ps_file, "<Frame\n <Pen 15>\n <Fill 15>\n <PenWidth  0.2 pt>\n <Separation 0>\n <BRect  0.0 pt 0.0 pt %.1f pt %.1f pt>\n",
          ((double )(urx - llx) * 72.) / (double )cbox.dpi, ((double )(ury - lly) * 72.) / (double )cbox.dpi);
#line 154
  this_list = (unsigned int )0;
  }
  {
#line 154
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 154
    if (! (this_list < shape.length)) {
#line 154
      goto while_break___2;
    }
#line 158
    list___0 = *(shape.data + this_list);
#line 159
    first = *(list___0.data + 0);
#line 161
    i = 0;
    {
#line 161
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 161
      if (! (i < n_ctbl)) {
#line 161
        goto while_break___3;
      }
      {
#line 162
      __cil_tmp35 = at_color_equal(& curr_color, & col_tbl[i].c);
      }
#line 162
      if (__cil_tmp35) {
#line 163
        goto while_break___3;
      }
#line 161
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 165
    if (shape.centerline || list___0.open) {
#line 165
      tmp___0 = "<PolyLine <Fill 15><Pen 0>";
    } else {
#line 165
      tmp___0 = "<Polygon <Fill 0><Pen 15>";
    }
    {
#line 165
    fprintf(ps_file, " %s\n", tmp___0);
#line 166
    fprintf(ps_file, "  <ObColor `%s\'>\n", col_tbl[i].tag);
#line 168
    print_coord(ps_file, first.v[0].x, first.v[0].y);
#line 169
    smooth = 0;
#line 170
    this_spline = (unsigned int )0;
    }
    {
#line 170
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 170
      if (! (this_spline < list___0.length)) {
#line 170
        goto while_break___4;
      }
#line 171
      s = *(list___0.data + this_spline);
#line 173
      if ((unsigned int )s.degree == 1U) {
        {
#line 174
        print_coord(ps_file, s.v[3].x, s.v[3].y);
        }
      } else {
#line 177
        dt = (gfloat )(1. / 7.);
#line 179
        temp = dt;
        {
#line 179
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 179
          if (! (__cil_tmp41 > (double )dt)) {
#line 179
            goto while_break___5;
          }
          {
#line 180
          __cil_tmp42 = bezpnt(temp, s.v[0].x, s.v[1].x, s.v[2].x, s.v[3].x);
          }
          {
#line 180
          __cil_tmp43 = bezpnt(temp, s.v[0].y, s.v[1].y, s.v[2].y, s.v[3].y);
#line 180
          print_coord(ps_file, __cil_tmp42, __cil_tmp43);
          }
#line 179
          temp += dt;
        }
        while_break___5: /* CIL Label */ ;
        }
      }
#line 170
      this_spline ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 184
    if (smooth) {
#line 184
      tmp___1 = "Yes";
    } else {
#line 184
      tmp___1 = "No";
    }
    {
#line 184
    fprintf(ps_file, "  <Smoothed %s>\n\230\001", tmp___1);
#line 185
    fprintf(ps_file, " >\n");
    }
#line 154
    this_list ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 187
  fprintf(ps_file, ">\n");
  }
#line 188
  return (0);
}
}
#line 119 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-pdf.c"
static int output_pdf_header(FILE *pdf_file , gchar *name , int llx , int lly , int urx ,
                             int ury ) 
{ 


  {
  {
#line 121
  fprintf(pdf_file, "%s\n", "%PDF-1.2\220");
#line 122
  fprintf(pdf_file, "%s\n", "1 0 obj");
#line 123
  fprintf(pdf_file, "%s\n", "   << /Type /Catalog");
#line 124
  fprintf(pdf_file, "%s\n", "      /Outlines 2 0 R");
#line 125
  fprintf(pdf_file, "%s\n", "      /Pages 3 0 R");
#line 126
  fprintf(pdf_file, "%s\n", "   >>");
#line 127
  fprintf(pdf_file, "%s\n", "endobj");
#line 128
  fprintf(pdf_file, "%s\n", "2 0 obj");
#line 129
  fprintf(pdf_file, "%s\n", "   << /Type /Outlines");
#line 130
  fprintf(pdf_file, "%s\n", "      /Count 0");
#line 131
  fprintf(pdf_file, "%s\n", "   >>");
#line 132
  fprintf(pdf_file, "%s\n", "endobj");
#line 133
  fprintf(pdf_file, "%s\n", "3 0 obj");
#line 134
  fprintf(pdf_file, "%s\n", "   << /Type /Pages");
#line 135
  fprintf(pdf_file, "%s\n", "      /Kids [4 0 R]");
#line 136
  fprintf(pdf_file, "%s\n", "      /Count 1");
#line 137
  fprintf(pdf_file, "%s\n", "   >>");
#line 138
  fprintf(pdf_file, "%s\n", "endobj");
#line 139
  fprintf(pdf_file, "%s\n", "4 0 obj");
#line 140
  fprintf(pdf_file, "%s\n", "   << /Type /Page");
#line 141
  fprintf(pdf_file, "%s\n", "      /Parent 3 0 R");
#line 142
  fprintf(pdf_file, "      /MediaBox [%d %d %d %d]\n", llx, lly, urx, ury);
#line 143
  fprintf(pdf_file, "%s\n", "      /Contents 5 0 R");
#line 144
  fprintf(pdf_file, "%s\n", "      /Resources << /ProcSet 6 0 R >>");
#line 145
  fprintf(pdf_file, "%s\n", "   >>");
#line 146
  fprintf(pdf_file, "%s\n", "endobj");
  }
#line 148
  return (0);
}
}
#line 154 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-pdf.c"
static int output_pdf_tailor(FILE *pdf_file , size_t length , int llx , int lly ,
                             int urx , int ury ) 
{ 
  char temp[40] ;
  size_t tmp ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;

  {
  {
#line 159
  fprintf(pdf_file, "%s\n", "6 0 obj");
#line 160
  fprintf(pdf_file, "%s\n", "   [/PDF]");
#line 161
  fprintf(pdf_file, "%s\n", "endobj");
#line 162
  fprintf(pdf_file, "%s\n", "xref");
#line 163
  fprintf(pdf_file, "%s\n", "0 7");
#line 164
  fprintf(pdf_file, "%s\n", "0000000000 65535 f ");
#line 165
  fprintf(pdf_file, "%s\n", "0000000009 00000 n ");
#line 166
  fprintf(pdf_file, "%s\n", "0000000092 00000 n ");
#line 167
  fprintf(pdf_file, "%s\n", "0000000150 00000 n ");
#line 168
  fprintf(pdf_file, "%s\n", "0000000225 00000 n ");
#line 169
  sprintf((char *)temp, "%d", llx);
#line 170
  tmp = (size_t )366;
#line 171
  __cil_tmp9 = strlen((char const   *)((char *)temp));
  }
  {
#line 171
  tmp += __cil_tmp9;
#line 172
  sprintf((char *)temp, "%d", lly);
#line 173
  __cil_tmp10 = strlen((char const   *)((char *)temp));
  }
  {
#line 173
  tmp += __cil_tmp10;
#line 174
  sprintf((char *)temp, "%d", urx);
#line 175
  __cil_tmp11 = strlen((char const   *)((char *)temp));
  }
  {
#line 175
  tmp += __cil_tmp11;
#line 176
  sprintf((char *)temp, "%d", ury);
#line 177
  __cil_tmp12 = strlen((char const   *)((char *)temp));
  }
  {
#line 177
  tmp += __cil_tmp12;
#line 178
  fprintf(pdf_file, "%010zu 00000 n \n\230\001", tmp);
#line 179
  sprintf((char *)temp, "%zu", length);
#line 180
  __cil_tmp13 = strlen((char const   *)((char *)temp));
  }
  {
#line 180
  tmp += (50UL + length) + __cil_tmp13;
#line 181
  fprintf(pdf_file, "%010zu 00000 n \n\230\001", tmp);
#line 182
  fprintf(pdf_file, "%s\n", "trailer");
#line 183
  fprintf(pdf_file, "%s\n", "   << /Size 7V");
#line 184
  fprintf(pdf_file, "%s\n\f\027V", "      /Root 1 0 R\202\231\f\027V");
#line 185
  fprintf(pdf_file, "%s\n\f\027V", "   >>V");
#line 186
  fprintf(pdf_file, "%s\n\f\027V", "startxref");
#line 187
  fprintf(pdf_file, "%zu\n", tmp + 25UL);
#line 188
  fprintf(pdf_file, "%s\n", "%%EOF");
  }
#line 190
  return (0);
}
}
#line 196 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-pdf.c"
static void out_splines___0(FILE *pdf_file , at_spline_list_array_type shape , size_t *length ) 
{ 
  char temp[40] ;
  unsigned int this_list ;
  spline_list_type list ;
  at_color last_color ;
  unsigned int this_spline ;
  spline_type first ;
  gboolean __cil_tmp10 ;
  char const   *tmp ;
  int __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  char const   *tmp___0 ;
  int __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  long __cil_tmp17 ;
  long __cil_tmp18 ;
  char const   *tmp___1 ;
  int __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  long __cil_tmp22 ;
  long __cil_tmp23 ;
  char const   *tmp___2 ;
  int __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  int __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  spline_type s ;
  long __cil_tmp30 ;
  long __cil_tmp31 ;
  char const   *tmp___3 ;
  int __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  long __cil_tmp35 ;
  long __cil_tmp36 ;
  char const   *tmp___4 ;
  int __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  int __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  long __cil_tmp42 ;
  long __cil_tmp43 ;
  char const   *tmp___5 ;
  int __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  long __cil_tmp47 ;
  long __cil_tmp48 ;
  char const   *tmp___6 ;
  int __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  int __cil_tmp52 ;
  unsigned long __cil_tmp53 ;
  long __cil_tmp54 ;
  long __cil_tmp55 ;
  char const   *tmp___7 ;
  int __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  long __cil_tmp59 ;
  long __cil_tmp60 ;
  char const   *tmp___8 ;
  int __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  int __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  long __cil_tmp66 ;
  long __cil_tmp67 ;
  char const   *tmp___9 ;
  int __cil_tmp69 ;
  unsigned long __cil_tmp70 ;
  long __cil_tmp71 ;
  long __cil_tmp72 ;
  char const   *tmp___10 ;
  int __cil_tmp74 ;
  unsigned long __cil_tmp75 ;
  int __cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  unsigned int __cil_tmp78 ;
  unsigned int __cil_tmp79 ;
  char const   *tmp___11 ;
  int __cil_tmp81 ;
  unsigned long __cil_tmp82 ;
  unsigned int this_spline___0 ;
  spline_type first___0 ;
  gboolean __cil_tmp85 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  long __cil_tmp88 ;
  long __cil_tmp89 ;
  char const   *tmp___14 ;
  long __cil_tmp91 ;
  long __cil_tmp92 ;
  char const   *tmp___15 ;
  spline_type s___0 ;
  long __cil_tmp95 ;
  long __cil_tmp96 ;
  char const   *tmp___16 ;
  long __cil_tmp98 ;
  long __cil_tmp99 ;
  char const   *tmp___17 ;
  long __cil_tmp101 ;
  long __cil_tmp102 ;
  char const   *tmp___18 ;
  long __cil_tmp104 ;
  long __cil_tmp105 ;
  char const   *tmp___19 ;
  long __cil_tmp107 ;
  long __cil_tmp108 ;
  char const   *tmp___20 ;
  long __cil_tmp110 ;
  long __cil_tmp111 ;
  char const   *tmp___21 ;
  long __cil_tmp113 ;
  long __cil_tmp114 ;
  char const   *tmp___22 ;
  long __cil_tmp116 ;
  long __cil_tmp117 ;
  char const   *tmp___23 ;
  unsigned int __cil_tmp119 ;
  unsigned int __cil_tmp120 ;
  char const   *tmp___24 ;

  {
#line 202
  last_color.r = (guint8 )0;
#line 202
  last_color.g = (guint8 )0;
#line 202
  last_color.b = (guint8 )0;
#line 204
  this_list = (unsigned int )0;
  {
#line 204
  while (1) {
    while_continue: /* CIL Label */ ;
#line 204
    if (! (this_list < shape.length)) {
#line 204
      goto while_break;
    }
    {
#line 208
    list = *(shape.data + this_list);
#line 209
    first = *(list.data + 0);
#line 211
    __cil_tmp10 = at_color_equal(& list.color, & last_color);
    }
#line 211
    if (this_list == 0U) {
      _L: /* CIL Label */ 
#line 212
      if (this_list > 0U) {
        {
#line 213
        __cil_tmp13 = strlen((char const   *)((char *)temp));
        }
#line 213
        *length += __cil_tmp13;
#line 213
        if (shape.centerline || list.open) {
#line 213
          tmp = "S";
        } else {
#line 213
          tmp = "f";
        }
        {
#line 213
        __cil_tmp12 = sprintf((char *)temp, "%s\n", tmp);
        }
      }
      {
#line 217
      __cil_tmp16 = strlen((char const   *)((char *)temp));
      }
#line 217
      *length += __cil_tmp16;
#line 217
      if (shape.centerline || list.open) {
#line 217
        tmp___0 = "RG";
      } else {
#line 217
        tmp___0 = "rg";
      }
      {
#line 217
      __cil_tmp15 = sprintf((char *)temp, "%.3f %.3f %.3f %s\n\231\f\027V", (double )list.color.r / 255.,
                            (double )list.color.g / 255., (double )list.color.b / 255.,
                            tmp___0);
#line 218
      last_color = list.color;
      }
    } else
#line 211
    if (! __cil_tmp10) {
#line 211
      goto _L;
    }
    {
#line 220
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 220
      __cil_tmp21 = strlen((char const   *)((char *)temp));
      }
#line 220
      *length += __cil_tmp21;
      {
#line 220
      __cil_tmp17 = lround((double )((gfloat )6. * first.v[0].x));
#line 220
      first.v[0].x = (float )__cil_tmp17 / (gfloat )6.;
#line 220
      __cil_tmp18 = lround((double )first.v[0].x);
      }
#line 220
      if (first.v[0].x == (float )__cil_tmp18) {
#line 220
        tmp___1 = "%.0f ";
      } else {
#line 220
        tmp___1 = "%.3f ";
      }
      {
#line 220
      __cil_tmp20 = sprintf((char *)temp, tmp___1, (double )first.v[0].x);
#line 220
      __cil_tmp26 = strlen((char const   *)((char *)temp));
      }
#line 220
      *length += __cil_tmp26;
      {
#line 220
      __cil_tmp22 = lround((double )((gfloat )6. * first.v[0].y));
#line 220
      first.v[0].y = (float )__cil_tmp22 / (gfloat )6.;
#line 220
      __cil_tmp23 = lround((double )first.v[0].y);
      }
#line 220
      if (first.v[0].y == (float )__cil_tmp23) {
#line 220
        tmp___2 = "%.0f ";
      } else {
#line 220
        tmp___2 = "%.3f ";
      }
      {
#line 220
      __cil_tmp25 = sprintf((char *)temp, tmp___2, (double )first.v[0].y);
#line 220
      __cil_tmp28 = strlen((char const   *)((char *)temp));
      }
#line 220
      *length += __cil_tmp28;
      {
#line 220
      __cil_tmp27 = sprintf((char *)temp, "m\n");
      }
#line 220
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 222
    this_spline = (unsigned int )0;
    {
#line 222
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 222
      if (! (this_spline < list.length)) {
#line 222
        goto while_break___1;
      }
#line 223
      s = *(list.data + this_spline);
#line 225
      if ((unsigned int )s.degree == 1U) {
        {
#line 226
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 226
          __cil_tmp34 = strlen((char const   *)((char *)temp));
          }
#line 226
          *length += __cil_tmp34;
          {
#line 226
          __cil_tmp30 = lround((double )((gfloat )6. * s.v[3].x));
#line 226
          s.v[3].x = (float )__cil_tmp30 / (gfloat )6.;
#line 226
          __cil_tmp31 = lround((double )s.v[3].x);
          }
#line 226
          if (s.v[3].x == (float )__cil_tmp31) {
#line 226
            tmp___3 = "%.0f ";
          } else {
#line 226
            tmp___3 = "%.3f ";
          }
          {
#line 226
          __cil_tmp33 = sprintf((char *)temp, tmp___3, (double )s.v[3].x);
#line 226
          __cil_tmp39 = strlen((char const   *)((char *)temp));
          }
#line 226
          *length += __cil_tmp39;
          {
#line 226
          __cil_tmp35 = lround((double )((gfloat )6. * s.v[3].y));
#line 226
          s.v[3].y = (float )__cil_tmp35 / (gfloat )6.;
#line 226
          __cil_tmp36 = lround((double )s.v[3].y);
          }
#line 226
          if (s.v[3].y == (float )__cil_tmp36) {
#line 226
            tmp___4 = "%.0f ";
          } else {
#line 226
            tmp___4 = "%.3f V";
          }
          {
#line 226
          __cil_tmp38 = sprintf((char *)temp, tmp___4, (double )s.v[3].y);
#line 226
          __cil_tmp41 = strlen((char const   *)((char *)temp));
          }
#line 226
          *length += __cil_tmp41;
          {
#line 226
          __cil_tmp40 = sprintf((char *)temp, "l\n");
          }
#line 226
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
      } else {
        {
#line 228
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 228
          __cil_tmp46 = strlen((char const   *)((char *)temp));
          }
#line 228
          *length += __cil_tmp46;
          {
#line 228
          __cil_tmp42 = lround((double )((gfloat )6. * s.v[1].x));
#line 228
          s.v[1].x = (float )__cil_tmp42 / (gfloat )6.;
#line 228
          __cil_tmp43 = lround((double )s.v[1].x);
          }
#line 228
          if (s.v[1].x == (float )__cil_tmp43) {
#line 228
            tmp___5 = "%.0f V";
          } else {
#line 228
            tmp___5 = "%.3f V";
          }
          {
#line 228
          __cil_tmp45 = sprintf((char *)temp, tmp___5, (double )s.v[1].x);
#line 228
          __cil_tmp51 = strlen((char const   *)((char *)temp));
          }
#line 228
          *length += __cil_tmp51;
          {
#line 228
          __cil_tmp47 = lround((double )((gfloat )6. * s.v[1].y));
#line 228
          s.v[1].y = (float )__cil_tmp47 / (gfloat )6.;
#line 228
          __cil_tmp48 = lround((double )s.v[1].y);
          }
#line 228
          if (s.v[1].y == (float )__cil_tmp48) {
#line 228
            tmp___6 = "%.0f V";
          } else {
#line 228
            tmp___6 = "%.3f V";
          }
          {
#line 228
          __cil_tmp50 = sprintf((char *)temp, tmp___6, (double )s.v[1].y);
#line 228
          __cil_tmp53 = strlen((char const   *)((char *)temp));
          }
#line 228
          *length += __cil_tmp53;
          {
#line 228
          __cil_tmp52 = sprintf((char *)temp, " ");
#line 228
          __cil_tmp58 = strlen((char const   *)((char *)temp));
          }
#line 228
          *length += __cil_tmp58;
          {
#line 228
          __cil_tmp54 = lround((double )((gfloat )6. * s.v[2].x));
#line 228
          s.v[2].x = (float )__cil_tmp54 / (gfloat )6.;
#line 228
          __cil_tmp55 = lround((double )s.v[2].x);
          }
#line 228
          if (s.v[2].x == (float )__cil_tmp55) {
#line 228
            tmp___7 = "%.0f ";
          } else {
#line 228
            tmp___7 = "%.3f ";
          }
          {
#line 228
          __cil_tmp57 = sprintf((char *)temp, tmp___7, (double )s.v[2].x);
#line 228
          __cil_tmp63 = strlen((char const   *)((char *)temp));
          }
#line 228
          *length += __cil_tmp63;
          {
#line 228
          __cil_tmp59 = lround((double )((gfloat )6. * s.v[2].y));
#line 228
          s.v[2].y = (float )__cil_tmp59 / (gfloat )6.;
#line 228
          __cil_tmp60 = lround((double )s.v[2].y);
          }
#line 228
          if (s.v[2].y == (float )__cil_tmp60) {
#line 228
            tmp___8 = "%.0f ";
          } else {
#line 228
            tmp___8 = "%.3f ";
          }
          {
#line 228
          __cil_tmp62 = sprintf((char *)temp, tmp___8, (double )s.v[2].y);
#line 228
          __cil_tmp65 = strlen((char const   *)((char *)temp));
          }
#line 228
          *length += __cil_tmp65;
          {
#line 228
          __cil_tmp64 = sprintf((char *)temp, " ");
#line 228
          __cil_tmp70 = strlen((char const   *)((char *)temp));
          }
#line 228
          *length += __cil_tmp70;
          {
#line 228
          __cil_tmp66 = lround((double )((gfloat )6. * s.v[3].x));
#line 228
          s.v[3].x = (float )__cil_tmp66 / (gfloat )6.;
#line 228
          __cil_tmp67 = lround((double )s.v[3].x);
          }
#line 228
          if (s.v[3].x == (float )__cil_tmp67) {
#line 228
            tmp___9 = "%.0f ";
          } else {
#line 228
            tmp___9 = "%.3f ";
          }
          {
#line 228
          __cil_tmp69 = sprintf((char *)temp, tmp___9, (double )s.v[3].x);
#line 228
          __cil_tmp75 = strlen((char const   *)((char *)temp));
          }
#line 228
          *length += __cil_tmp75;
          {
#line 228
          __cil_tmp71 = lround((double )((gfloat )6. * s.v[3].y));
#line 228
          s.v[3].y = (float )__cil_tmp71 / (gfloat )6.;
#line 228
          __cil_tmp72 = lround((double )s.v[3].y);
          }
#line 228
          if (s.v[3].y == (float )__cil_tmp72) {
#line 228
            tmp___10 = "%.0f ";
          } else {
#line 228
            tmp___10 = "%.3f ";
          }
          {
#line 228
          __cil_tmp74 = sprintf((char *)temp, tmp___10, (double )s.v[3].y);
#line 228
          __cil_tmp77 = strlen((char const   *)((char *)temp));
          }
#line 228
          *length += __cil_tmp77;
          {
#line 228
          __cil_tmp76 = sprintf((char *)temp, " c \n");
          }
#line 228
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 222
      this_spline ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 204
    this_list ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 231
  if (shape.length > 0U) {
    {
#line 232
    __cil_tmp82 = strlen((char const   *)((char *)temp));
    }
#line 232
    *length += __cil_tmp82;
#line 232
    if (shape.centerline || list.open) {
#line 232
      tmp___11 = "S";
    } else {
#line 232
      tmp___11 = "f";
    }
    {
#line 232
    __cil_tmp81 = sprintf((char *)temp, "%s\n", tmp___11);
    }
  }
  {
#line 234
  fprintf(pdf_file, "%s\n", "5 0 obj");
#line 235
  fprintf(pdf_file, "   << /Length %zu >>\n", *length);
#line 236
  fprintf(pdf_file, "%s\n", "stream");
#line 238
  last_color.r = (guint8 )0;
#line 239
  last_color.g = (guint8 )0;
#line 240
  last_color.b = (guint8 )0;
#line 242
  this_list = (unsigned int )0;
  }
  {
#line 242
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 242
    if (! (this_list < shape.length)) {
#line 242
      goto while_break___4;
    }
    {
#line 246
    list = *(shape.data + this_list);
#line 247
    first___0 = *(list.data + 0);
#line 249
    __cil_tmp85 = at_color_equal(& list.color, & last_color);
    }
#line 249
    if (this_list == 0U) {
      _L___50: /* CIL Label */ 
#line 250
      if (this_list > 0U) {
#line 251
        if (shape.centerline || list.open) {
#line 251
          tmp___12 = "S";
        } else {
#line 251
          tmp___12 = "f";
        }
        {
#line 251
        fprintf(pdf_file, "%s\n", tmp___12);
        }
      }
#line 255
      if (shape.centerline || list.open) {
#line 255
        tmp___13 = "RG";
      } else {
#line 255
        tmp___13 = "rg";
      }
      {
#line 255
      fprintf(pdf_file, "%.3f %.3f %.3f %s\n", (double )list.color.r / 255., (double )list.color.g / 255.,
              (double )list.color.b / 255., tmp___13);
#line 256
      last_color = list.color;
      }
    } else
#line 249
    if (! __cil_tmp85) {
#line 249
      goto _L___50;
    }
    {
#line 258
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 258
      __cil_tmp88 = lround((double )((gfloat )6. * first___0.v[0].x));
#line 258
      first___0.v[0].x = (float )__cil_tmp88 / (gfloat )6.;
#line 258
      __cil_tmp89 = lround((double )first___0.v[0].x);
      }
#line 258
      if (first___0.v[0].x == (float )__cil_tmp89) {
#line 258
        tmp___14 = "%.0f ";
      } else {
#line 258
        tmp___14 = "%.3f ";
      }
      {
#line 258
      fprintf(pdf_file, tmp___14, (double )first___0.v[0].x);
#line 258
      __cil_tmp91 = lround((double )((gfloat )6. * first___0.v[0].y));
#line 258
      first___0.v[0].y = (float )__cil_tmp91 / (gfloat )6.;
#line 258
      __cil_tmp92 = lround((double )first___0.v[0].y);
      }
#line 258
      if (first___0.v[0].y == (float )__cil_tmp92) {
#line 258
        tmp___15 = "%.0f ";
      } else {
#line 258
        tmp___15 = "%.3f ";
      }
      {
#line 258
      fprintf(pdf_file, tmp___15, (double )first___0.v[0].y);
#line 258
      fprintf(pdf_file, "m\n");
      }
#line 258
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 260
    this_spline___0 = (unsigned int )0;
    {
#line 260
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 260
      if (! (this_spline___0 < list.length)) {
#line 260
        goto while_break___6;
      }
#line 261
      s___0 = *(list.data + this_spline___0);
#line 263
      if ((unsigned int )s___0.degree == 1U) {
        {
#line 264
        while (1) {
          while_continue___7: /* CIL Label */ ;
          {
#line 264
          __cil_tmp95 = lround((double )((gfloat )6. * s___0.v[3].x));
#line 264
          s___0.v[3].x = (float )__cil_tmp95 / (gfloat )6.;
#line 264
          __cil_tmp96 = lround((double )s___0.v[3].x);
          }
#line 264
          if (s___0.v[3].x == (float )__cil_tmp96) {
#line 264
            tmp___16 = "%.0f ";
          } else {
#line 264
            tmp___16 = "%.3f ";
          }
          {
#line 264
          fprintf(pdf_file, tmp___16, (double )s___0.v[3].x);
#line 264
          __cil_tmp98 = lround((double )((gfloat )6. * s___0.v[3].y));
#line 264
          s___0.v[3].y = (float )__cil_tmp98 / (gfloat )6.;
#line 264
          __cil_tmp99 = lround((double )s___0.v[3].y);
          }
#line 264
          if (s___0.v[3].y == (float )__cil_tmp99) {
#line 264
            tmp___17 = "%.0f ";
          } else {
#line 264
            tmp___17 = "%.3f ";
          }
          {
#line 264
          fprintf(pdf_file, tmp___17, (double )s___0.v[3].y);
#line 264
          fprintf(pdf_file, "l\n");
          }
#line 264
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
      } else {
        {
#line 266
        while (1) {
          while_continue___8: /* CIL Label */ ;
          {
#line 266
          __cil_tmp101 = lround((double )((gfloat )6. * s___0.v[1].x));
#line 266
          s___0.v[1].x = (float )__cil_tmp101 / (gfloat )6.;
#line 266
          __cil_tmp102 = lround((double )s___0.v[1].x);
          }
#line 266
          if (s___0.v[1].x == (float )__cil_tmp102) {
#line 266
            tmp___18 = "%.0f ";
          } else {
#line 266
            tmp___18 = "%.3f ";
          }
          {
#line 266
          fprintf(pdf_file, tmp___18, (double )s___0.v[1].x);
#line 266
          __cil_tmp104 = lround((double )((gfloat )6. * s___0.v[1].y));
#line 266
          s___0.v[1].y = (float )__cil_tmp104 / (gfloat )6.;
#line 266
          __cil_tmp105 = lround((double )s___0.v[1].y);
          }
#line 266
          if (s___0.v[1].y == (float )__cil_tmp105) {
#line 266
            tmp___19 = "%.0f ";
          } else {
#line 266
            tmp___19 = "%.3f ";
          }
          {
#line 266
          fprintf(pdf_file, tmp___19, (double )s___0.v[1].y);
#line 266
          fprintf(pdf_file, " ");
#line 266
          __cil_tmp107 = lround((double )((gfloat )6. * s___0.v[2].x));
#line 266
          s___0.v[2].x = (float )__cil_tmp107 / (gfloat )6.;
#line 266
          __cil_tmp108 = lround((double )s___0.v[2].x);
          }
#line 266
          if (s___0.v[2].x == (float )__cil_tmp108) {
#line 266
            tmp___20 = "%.0f ";
          } else {
#line 266
            tmp___20 = "%.3f ";
          }
          {
#line 266
          fprintf(pdf_file, tmp___20, (double )s___0.v[2].x);
#line 266
          __cil_tmp110 = lround((double )((gfloat )6. * s___0.v[2].y));
#line 266
          s___0.v[2].y = (float )__cil_tmp110 / (gfloat )6.;
#line 266
          __cil_tmp111 = lround((double )s___0.v[2].y);
          }
#line 266
          if (s___0.v[2].y == (float )__cil_tmp111) {
#line 266
            tmp___21 = "%.0f ";
          } else {
#line 266
            tmp___21 = "%.3f ";
          }
          {
#line 266
          fprintf(pdf_file, tmp___21, (double )s___0.v[2].y);
#line 266
          fprintf(pdf_file, " ");
#line 266
          __cil_tmp113 = lround((double )((gfloat )6. * s___0.v[3].x));
#line 266
          s___0.v[3].x = (float )__cil_tmp113 / (gfloat )6.;
#line 266
          __cil_tmp114 = lround((double )s___0.v[3].x);
          }
#line 266
          if (s___0.v[3].x == (float )__cil_tmp114) {
#line 266
            tmp___22 = "%.0f ";
          } else {
#line 266
            tmp___22 = "%.3f ";
          }
          {
#line 266
          fprintf(pdf_file, tmp___22, (double )s___0.v[3].x);
#line 266
          __cil_tmp116 = lround((double )((gfloat )6. * s___0.v[3].y));
#line 266
          s___0.v[3].y = (float )__cil_tmp116 / (gfloat )6.;
#line 266
          __cil_tmp117 = lround((double )s___0.v[3].y);
          }
#line 266
          if (s___0.v[3].y == (float )__cil_tmp117) {
#line 266
            tmp___23 = "%.0f ";
          } else {
#line 266
            tmp___23 = "%.3f ";
          }
          {
#line 266
          fprintf(pdf_file, tmp___23, (double )s___0.v[3].y);
#line 266
          fprintf(pdf_file, " c \n");
          }
#line 266
          goto while_break___8;
        }
        while_break___8: /* CIL Label */ ;
        }
      }
#line 260
      this_spline___0 ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 242
    this_list ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 269
  if (shape.length > 0U) {
#line 270
    if (shape.centerline || list.open) {
#line 270
      tmp___24 = "S";
    } else {
#line 270
      tmp___24 = "f";
    }
    {
#line 270
    fprintf(pdf_file, "%s\n", tmp___24);
    }
  }
  {
#line 271
  fprintf(pdf_file, "%s\n", "endstream");
#line 272
  fprintf(pdf_file, "%s\n", "endobj");
  }
  return;
}
}
#line 276 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-pdf.c"
int output_pdf_writer(FILE *pdf_file , gchar *name , int llx , int lly , int urx ,
                      int ury , at_output_opts_type *opts , at_spline_list_array_type shape ,
                      at_msg_func msg_func , gpointer msg_data , gpointer user_data ) 
{ 
  int result ;
  size_t length ;
  int __cil_tmp14 ;

  {
  {
#line 279
  length = (size_t )0;
#line 288
  result = output_pdf_header(pdf_file, name, llx, lly, urx, ury);
  }
#line 289
  if (result != 0) {
#line 290
    return (result);
  }
  {
#line 292
  out_splines___0(pdf_file, shape, & length);
#line 294
  output_pdf_tailor(pdf_file, length, llx, lly, urx, ury);
  }
#line 296
  return (0);
}
}
#line 81 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-epd.c"
static int output_epd_header(FILE *epd_file , gchar *name , int llx , int lly , int urx ,
                             int ury ) 
{ 
  gchar *time___51 ;
  char const   *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 85
  fprintf(epd_file, "%s\n", "%EPD-1.0\220");
#line 86
  __cil_tmp8 = at_version(! 0);
#line 86
  fprintf(epd_file, "%% Created by %s\n", __cil_tmp8);
#line 87
  fprintf(epd_file, "%% Title: %s\n", name);
#line 88
  time___51 = at_time_string();
#line 88
  fprintf(epd_file, "%% CreationDate: %s\n", time___51);
#line 89
  fprintf(epd_file, "%%BBox(%d,%d,%d,%d)\n", llx, lly, urx, ury);
#line 91
  g_free(time___51);
  }
#line 93
  return (0);
}
}
#line 99 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-epd.c"
static void out_splines___1(FILE *epd_file , at_spline_list_array_type shape ) 
{ 
  unsigned int this_list ;
  spline_list_type list ;
  at_color last_color ;
  unsigned int this_spline ;
  spline_type first ;
  gboolean __cil_tmp8 ;
  char const   *tmp ;
  char const   *tmp___0 ;
  long __cil_tmp11 ;
  long __cil_tmp12 ;
  char const   *tmp___1 ;
  long __cil_tmp14 ;
  long __cil_tmp15 ;
  char const   *tmp___2 ;
  spline_type s ;
  long __cil_tmp18 ;
  long __cil_tmp19 ;
  char const   *tmp___3 ;
  long __cil_tmp21 ;
  long __cil_tmp22 ;
  char const   *tmp___4 ;
  long __cil_tmp24 ;
  long __cil_tmp25 ;
  char const   *tmp___5 ;
  long __cil_tmp27 ;
  long __cil_tmp28 ;
  char const   *tmp___6 ;
  long __cil_tmp30 ;
  long __cil_tmp31 ;
  char const   *tmp___7 ;
  long __cil_tmp33 ;
  long __cil_tmp34 ;
  char const   *tmp___8 ;
  long __cil_tmp36 ;
  long __cil_tmp37 ;
  char const   *tmp___9 ;
  long __cil_tmp39 ;
  long __cil_tmp40 ;
  char const   *tmp___10 ;
  unsigned int __cil_tmp42 ;
  unsigned int __cil_tmp43 ;
  char const   *tmp___11 ;

  {
#line 103
  last_color.r = (guint8 )0;
#line 103
  last_color.g = (guint8 )0;
#line 103
  last_color.b = (guint8 )0;
#line 105
  this_list = (unsigned int )0;
  {
#line 105
  while (1) {
    while_continue: /* CIL Label */ ;
#line 105
    if (! (this_list < shape.length)) {
#line 105
      goto while_break;
    }
    {
#line 109
    list = *(shape.data + this_list);
#line 110
    first = *(list.data + 0);
#line 112
    __cil_tmp8 = at_color_equal(& list.color, & last_color);
    }
#line 112
    if (this_list == 0U) {
      _L: /* CIL Label */ 
#line 113
      if (this_list > 0U) {
#line 114
        if (shape.centerline || list.open) {
#line 114
          tmp = "S";
        } else {
#line 114
          tmp = "f";
        }
        {
#line 114
        fprintf(epd_file, "%s\n", tmp);
#line 115
        fprintf(epd_file, "%s\n", "h");
        }
      }
#line 117
      if (shape.centerline || list.open) {
#line 117
        tmp___0 = "RG";
      } else {
#line 117
        tmp___0 = "rg";
      }
      {
#line 117
      fprintf(epd_file, "%.3f %.3f %.3f %s\n", (double )list.color.r / 255., (double )list.color.g / 255.,
              (double )list.color.b / 255., tmp___0);
#line 118
      last_color = list.color;
      }
    } else
#line 112
    if (! __cil_tmp8) {
#line 112
      goto _L;
    }
    {
#line 120
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 120
      __cil_tmp11 = lround((double )((gfloat )6. * first.v[0].x));
#line 120
      first.v[0].x = (float )__cil_tmp11 / (gfloat )6.;
#line 120
      __cil_tmp12 = lround((double )first.v[0].x);
      }
#line 120
      if (first.v[0].x == (float )__cil_tmp12) {
#line 120
        tmp___1 = "%.0f ";
      } else {
#line 120
        tmp___1 = "%.3f ";
      }
      {
#line 120
      fprintf(epd_file, tmp___1, (double )first.v[0].x);
#line 120
      __cil_tmp14 = lround((double )((gfloat )6. * first.v[0].y));
#line 120
      first.v[0].y = (float )__cil_tmp14 / (gfloat )6.;
#line 120
      __cil_tmp15 = lround((double )first.v[0].y);
      }
#line 120
      if (first.v[0].y == (float )__cil_tmp15) {
#line 120
        tmp___2 = "%.0f ";
      } else {
#line 120
        tmp___2 = "%.3f ";
      }
      {
#line 120
      fprintf(epd_file, tmp___2, (double )first.v[0].y);
#line 120
      fprintf(epd_file, "m\n");
      }
#line 120
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 122
    this_spline = (unsigned int )0;
    {
#line 122
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 122
      if (! (this_spline < list.length)) {
#line 122
        goto while_break___1;
      }
#line 123
      s = *(list.data + this_spline);
#line 125
      if ((unsigned int )s.degree == 1U) {
        {
#line 126
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 126
          __cil_tmp18 = lround((double )((gfloat )6. * s.v[3].x));
#line 126
          s.v[3].x = (float )__cil_tmp18 / (gfloat )6.;
#line 126
          __cil_tmp19 = lround((double )s.v[3].x);
          }
#line 126
          if (s.v[3].x == (float )__cil_tmp19) {
#line 126
            tmp___3 = "%.0f ";
          } else {
#line 126
            tmp___3 = "%.3f ";
          }
          {
#line 126
          fprintf(epd_file, tmp___3, (double )s.v[3].x);
#line 126
          __cil_tmp21 = lround((double )((gfloat )6. * s.v[3].y));
#line 126
          s.v[3].y = (float )__cil_tmp21 / (gfloat )6.;
#line 126
          __cil_tmp22 = lround((double )s.v[3].y);
          }
#line 126
          if (s.v[3].y == (float )__cil_tmp22) {
#line 126
            tmp___4 = "%.0f ";
          } else {
#line 126
            tmp___4 = "%.3f ";
          }
          {
#line 126
          fprintf(epd_file, tmp___4, (double )s.v[3].y);
#line 126
          fprintf(epd_file, "l\n");
          }
#line 126
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
      } else {
        {
#line 128
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 128
          __cil_tmp24 = lround((double )((gfloat )6. * s.v[1].x));
#line 128
          s.v[1].x = (float )__cil_tmp24 / (gfloat )6.;
#line 128
          __cil_tmp25 = lround((double )s.v[1].x);
          }
#line 128
          if (s.v[1].x == (float )__cil_tmp25) {
#line 128
            tmp___5 = "%.0f ";
          } else {
#line 128
            tmp___5 = "%.3f ";
          }
          {
#line 128
          fprintf(epd_file, tmp___5, (double )s.v[1].x);
#line 128
          __cil_tmp27 = lround((double )((gfloat )6. * s.v[1].y));
#line 128
          s.v[1].y = (float )__cil_tmp27 / (gfloat )6.;
#line 128
          __cil_tmp28 = lround((double )s.v[1].y);
          }
#line 128
          if (s.v[1].y == (float )__cil_tmp28) {
#line 128
            tmp___6 = "%.0f ";
          } else {
#line 128
            tmp___6 = "%.3f ";
          }
          {
#line 128
          fprintf(epd_file, tmp___6, (double )s.v[1].y);
#line 128
          fprintf(epd_file, " ");
#line 128
          __cil_tmp30 = lround((double )((gfloat )6. * s.v[2].x));
#line 128
          s.v[2].x = (float )__cil_tmp30 / (gfloat )6.;
#line 128
          __cil_tmp31 = lround((double )s.v[2].x);
          }
#line 128
          if (s.v[2].x == (float )__cil_tmp31) {
#line 128
            tmp___7 = "%.0f ";
          } else {
#line 128
            tmp___7 = "%.3f ";
          }
          {
#line 128
          fprintf(epd_file, tmp___7, (double )s.v[2].x);
#line 128
          __cil_tmp33 = lround((double )((gfloat )6. * s.v[2].y));
#line 128
          s.v[2].y = (float )__cil_tmp33 / (gfloat )6.;
#line 128
          __cil_tmp34 = lround((double )s.v[2].y);
          }
#line 128
          if (s.v[2].y == (float )__cil_tmp34) {
#line 128
            tmp___8 = "%.0f ";
          } else {
#line 128
            tmp___8 = "%.3f ";
          }
          {
#line 128
          fprintf(epd_file, tmp___8, (double )s.v[2].y);
#line 128
          fprintf(epd_file, " ");
#line 128
          __cil_tmp36 = lround((double )((gfloat )6. * s.v[3].x));
#line 128
          s.v[3].x = (float )__cil_tmp36 / (gfloat )6.;
#line 128
          __cil_tmp37 = lround((double )s.v[3].x);
          }
#line 128
          if (s.v[3].x == (float )__cil_tmp37) {
#line 128
            tmp___9 = "%.0f ";
          } else {
#line 128
            tmp___9 = "%.3f ";
          }
          {
#line 128
          fprintf(epd_file, tmp___9, (double )s.v[3].x);
#line 128
          __cil_tmp39 = lround((double )((gfloat )6. * s.v[3].y));
#line 128
          s.v[3].y = (float )__cil_tmp39 / (gfloat )6.;
#line 128
          __cil_tmp40 = lround((double )s.v[3].y);
          }
#line 128
          if (s.v[3].y == (float )__cil_tmp40) {
#line 128
            tmp___10 = "%.0f ";
          } else {
#line 128
            tmp___10 = "%.3f ";
          }
          {
#line 128
          fprintf(epd_file, tmp___10, (double )s.v[3].y);
#line 128
          fprintf(epd_file, " c \n");
          }
#line 128
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 122
      this_spline ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 105
    this_list ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 131
  if (shape.length > 0U) {
#line 132
    if (shape.centerline || list.open) {
#line 132
      tmp___11 = "S";
    } else {
#line 132
      tmp___11 = "f";
    }
    {
#line 132
    fprintf(epd_file, "%s\n", tmp___11);
    }
  }
  return;
}
}
#line 135 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-epd.c"
int output_epd_writer(FILE *epd_file , gchar *name , int llx , int lly , int urx ,
                      int ury , at_output_opts_type *opts , at_spline_list_array_type shape ,
                      at_msg_func msg_func , gpointer msg_data , gpointer user_data ) 
{ 
  int result ;
  int __cil_tmp13 ;

  {
  {
#line 139
  result = output_epd_header(epd_file, name, llx, lly, urx, ury);
  }
#line 140
  if (result != 0) {
#line 141
    return (result);
  }
  {
#line 143
  out_splines___1(epd_file, shape);
  }
#line 145
  return (0);
}
}
#line 81 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-dxf.c"
struct Colors_t dxftable[255]  = 
#line 81 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-dxf.c"
  {      {255, 0, 0}, 
        {255, 255, 0}, 
        {0, 255, 0}, 
        {0, 255, 255}, 
        {0, 0, 255}, 
        {255, 0, 255}, 
        {255, 255, 255}, 
        {255, 255, 255}, 
        {255, 255, 255}, 
        {255, 9, 0}, 
        {255, 128, 128}, 
        {166, 0, 0}, 
        {166, 83, 83}, 
        {128, 0, 0}, 
        {128, 64, 64}, 
        {77, 0, 0}, 
        {77, 38, 38}, 
        {38, 0, 0}, 
        {38, 19, 19}, 
        {255, 64, 0}, 
        {255, 160, 128}, 
        {166, 42, 0}, 
        {166, 104, 83}, 
        {128, 32, 0}, 
        {128, 80, 64}, 
        {77, 19, 0}, 
        {77, 48, 38}, 
        {38, 10, 0}, 
        {38, 24, 19}, 
        {256, 128, 0}, 
        {256, 192, 0}, 
        {166, 83, 0}, 
        {166, 125, 83}, 
        {128, 64, 0}, 
        {128, 96, 64}, 
        {77, 38, 0}, 
        {77, 58, 38}, 
        {38, 19, 0}, 
        {38, 29, 19}, 
        {255, 192, 0}, 
        {255, 224, 128}, 
        {166, 125, 0}, 
        {166, 146, 83}, 
        {128, 96, 0}, 
        {128, 112, 64}, 
        {77, 58, 0}, 
        {77, 67, 38}, 
        {38, 29, 0}, 
        {38, 34, 19}, 
        {255, 255, 0}, 
        {255, 255, 128}, 
        {166, 166, 0}, 
        {166, 166, 83}, 
        {128, 128, 0}, 
        {128, 128, 64}, 
        {77, 77, 0}, 
        {77, 77, 38}, 
        {38, 38, 0}, 
        {38, 38, 19}, 
        {192, 255, 0}, 
        {224, 255, 128}, 
        {125, 166, 0}, 
        {146, 166, 83}, 
        {96, 128, 0}, 
        {112, 128, 64}, 
        {58, 77, 0}, 
        {67, 77, 38}, 
        {29, 38, 0}, 
        {34, 38, 19}, 
        {128, 255, 0}, 
        {192, 255, 128}, 
        {83, 166, 0}, 
        {125, 166, 83}, 
        {64, 128, 0}, 
        {96, 128, 64}, 
        {38, 77, 0}, 
        {58, 77, 38}, 
        {19, 38, 0}, 
        {29, 38, 19}, 
        {64, 255, 0}, 
        {160, 255, 128}, 
        {42, 160, 0}, 
        {104, 160, 80}, 
        {32, 128, 0}, 
        {80, 128, 64}, 
        {19, 77, 0}, 
        {48, 77, 38}, 
        {10, 38, 0}, 
        {24, 38, 19}, 
        {0, 255, 0}, 
        {128, 255, 128}, 
        {0, 166, 0}, 
        {83, 166, 83}, 
        {0, 128, 0}, 
        {64, 128, 64}, 
        {0, 77, 0}, 
        {38, 77, 38}, 
        {0, 38, 0}, 
        {19, 38, 19}, 
        {0, 255, 64}, 
        {128, 255, 160}, 
        {0, 166, 42}, 
        {83, 166, 118}, 
        {0, 128, 32}, 
        {64, 128, 80}, 
        {0, 77, 19}, 
        {38, 77, 48}, 
        {0, 38, 10}, 
        {19, 38, 24}, 
        {0, 255, 128}, 
        {128, 255, 192}, 
        {0, 166, 83}, 
        {83, 166, 125}, 
        {0, 128, 64}, 
        {64, 128, 96}, 
        {0, 77, 38}, 
        {38, 77, 58}, 
        {0, 38, 19}, 
        {19, 38, 29}, 
        {0, 255, 192}, 
        {128, 255, 224}, 
        {0, 166, 125}, 
        {83, 166, 146}, 
        {0, 128, 96}, 
        {64, 128, 112}, 
        {0, 77, 58}, 
        {38, 77, 67}, 
        {0, 38, 29}, 
        {19, 38, 34}, 
        {0, 255, 255}, 
        {128, 255, 255}, 
        {0, 166, 166}, 
        {83, 166, 166}, 
        {0, 128, 128}, 
        {64, 128, 128}, 
        {0, 77, 77}, 
        {38, 77, 77}, 
        {0, 38, 38}, 
        {19, 38, 38}, 
        {0, 192, 255}, 
        {128, 224, 255}, 
        {0, 125, 166}, 
        {83, 146, 166}, 
        {0, 96, 128}, 
        {64, 112, 128}, 
        {0, 58, 77}, 
        {38, 67, 77}, 
        {0, 29, 38}, 
        {19, 34, 38}, 
        {0, 128, 255}, 
        {128, 192, 255}, 
        {0, 83, 166}, 
        {83, 125, 166}, 
        {0, 64, 128}, 
        {64, 96, 128}, 
        {0, 38, 77}, 
        {38, 58, 77}, 
        {0, 19, 38}, 
        {19, 29, 38}, 
        {0, 64, 255}, 
        {128, 160, 255}, 
        {0, 42, 166}, 
        {83, 104, 166}, 
        {0, 32, 128}, 
        {64, 80, 128}, 
        {0, 19, 77}, 
        {38, 48, 77}, 
        {0, 10, 38}, 
        {19, 24, 38}, 
        {0, 0, 255}, 
        {128, 128, 255}, 
        {0, 0, 166}, 
        {83, 83, 166}, 
        {0, 0, 128}, 
        {64, 64, 128}, 
        {0, 0, 77}, 
        {38, 38, 77}, 
        {0, 0, 38}, 
        {19, 19, 38}, 
        {64, 0, 255}, 
        {160, 128, 255}, 
        {42, 0, 166}, 
        {104, 83, 166}, 
        {32, 0, 128}, 
        {80, 64, 128}, 
        {19, 0, 77}, 
        {48, 38, 77}, 
        {10, 0, 38}, 
        {24, 19, 38}, 
        {128, 0, 255}, 
        {192, 128, 255}, 
        {83, 0, 166}, 
        {125, 83, 166}, 
        {64, 0, 128}, 
        {96, 64, 128}, 
        {38, 0, 77}, 
        {58, 38, 77}, 
        {19, 0, 38}, 
        {29, 19, 38}, 
        {192, 0, 255}, 
        {224, 128, 255}, 
        {125, 0, 166}, 
        {146, 83, 166}, 
        {96, 0, 128}, 
        {112, 64, 128}, 
        {58, 0, 77}, 
        {67, 38, 77}, 
        {29, 0, 38}, 
        {34, 19, 38}, 
        {255, 0, 255}, 
        {255, 128, 255}, 
        {166, 0, 166}, 
        {166, 83, 166}, 
        {128, 0, 128}, 
        {128, 64, 128}, 
        {77, 0, 77}, 
        {77, 38, 77}, 
        {38, 0, 38}, 
        {38, 19, 38}, 
        {255, 0, 192}, 
        {255, 128, 224}, 
        {166, 0, 125}, 
        {166, 83, 146}, 
        {128, 0, 96}, 
        {128, 64, 112}, 
        {77, 0, 58}, 
        {77, 38, 67}, 
        {38, 0, 29}, 
        {38, 19, 34}, 
        {255, 0, 128}, 
        {255, 128, 192}, 
        {166, 0, 83}, 
        {166, 83, 125}, 
        {128, 0, 64}, 
        {128, 64, 96}, 
        {77, 0, 38}, 
        {77, 38, 58}, 
        {38, 0, 19}, 
        {38, 19, 29}, 
        {255, 0, 64}, 
        {255, 128, 160}, 
        {166, 0, 42}, 
        {166, 83, 104}, 
        {128, 0, 32}, 
        {128, 64, 80}, 
        {77, 0, 19}, 
        {77, 38, 48}, 
        {38, 0, 10}, 
        {38, 19, 24}, 
        {84, 84, 84}, 
        {119, 119, 119}, 
        {153, 153, 153}, 
        {187, 187, 187}, 
        {222, 222, 222}, 
        {255, 255, 255}};
#line 344 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-dxf.c"
void xypnt_next_pnt(xypnt_head_rec *head_xypnt , xypnt *coord_point , char *finished ) 
{ 


  {
#line 348
  if (head_xypnt) {
#line 348
    if (head_xypnt->current_point) {
#line 349
      head_xypnt->current_point = (head_xypnt->current_point)->next_point;
#line 350
      if (head_xypnt->current_point == (void *)0) {
#line 351
        *finished = (char )1;
      } else {
#line 353
        *coord_point = (head_xypnt->current_point)->point;
#line 354
        *finished = (char )0;
      }
    } else {
#line 357
      *finished = (char )1;
    }
  } else {
#line 357
    *finished = (char )1;
  }
  return;
}
}
#line 363 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-dxf.c"
void xypnt_first_pnt(xypnt_head_rec *head_xypnt , xypnt *coord_point , char *finished ) 
{ 


  {
#line 367
  if (head_xypnt) {
#line 368
    head_xypnt->current_point = head_xypnt->first_point;
#line 369
    if (head_xypnt->current_point == (void *)0) {
#line 370
      *finished = (char )1;
    } else {
#line 372
      *coord_point = (head_xypnt->current_point)->point;
#line 373
      *finished = (char )0;
    }
  } else {
#line 376
    *finished = (char )1;
  }
  return;
}
}
#line 383 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-dxf.c"
void xypnt_add_pnt(xypnt_head_rec *head_xypnt , xypnt coord_point ) 
{ 
  xypnt_point_rec *temp_point ;
  void *__cil_tmp4 ;

  {
#line 388
  if (! head_xypnt) {
#line 389
    return;
  }
  {
#line 390
  __cil_tmp4 = calloc((unsigned long )1, sizeof(struct xypnt_point_t ));
#line 390
  temp_point = (struct xypnt_point_t *)__cil_tmp4;
#line 391
  temp_point->point = coord_point;
#line 392
  temp_point->next_point = (struct xypnt_point_t *)((void *)0);
  }
#line 393
  if (head_xypnt->first_point == (void *)0) {
#line 394
    head_xypnt->first_point = temp_point;
  } else {
#line 396
    (head_xypnt->last_point)->next_point = temp_point;
  }
#line 397
  head_xypnt->last_point = temp_point;
  return;
}
}
#line 404 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-dxf.c"
void xypnt_dispose_list(xypnt_head_rec **head_xypnt ) 
{ 
  xypnt_point_rec *p ;
  xypnt_point_rec *old ;

  {
#line 407
  if (head_xypnt) {
#line 407
    if (*head_xypnt) {
#line 408
      if ((*head_xypnt)->last_point) {
#line 408
        if ((*head_xypnt)->first_point) {
#line 409
          p = (*head_xypnt)->first_point;
          {
#line 410
          while (1) {
            while_continue: /* CIL Label */ ;
#line 410
            if (! p) {
#line 410
              goto while_break;
            }
            {
#line 411
            old = p;
#line 412
            p = p->next_point;
#line 413
            free(old);
            }
          }
          while_break: /* CIL Label */ ;
          }
        }
      }
    }
  }
  return;
}
}
#line 424 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-dxf.c"
int GetIndexByRGBValue(int red , int green , int blue ) 
{ 
  int savdis ;
  int i ;
  double psav ;
  double pnew ;
  double px ;
  double py ;
  double pz ;
  int nred ;
  int ngreen ;
  int nblue ;
  double __cil_tmp14 ;
  int __cil_tmp15 ;

  {
#line 428
  savdis = 1;
#line 429
  psav = (double )10000000;
#line 432
  i = 0;
  {
#line 432
  while (1) {
    while_continue: /* CIL Label */ ;
#line 432
    if (! (i < 255)) {
#line 432
      goto while_break;
    }
    {
#line 433
    nred = dxftable[i].red;
#line 434
    ngreen = dxftable[i].green;
#line 435
    nblue = dxftable[i].blue;
#line 437
    px = (double )((red * red - (2 * nred) * red) + nred * nred);
#line 438
    py = (double )((green * green - (2 * ngreen) * green) + ngreen * ngreen);
#line 439
    pz = (double )((blue * blue - (2 * nblue) * blue) + nblue * nblue);
#line 440
    pnew = sqrt((px + py) + pz);
    }
#line 441
    if (pnew < psav) {
#line 442
      psav = pnew;
#line 443
      savdis = i;
    }
#line 432
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 446
  return (savdis + 1);
}
}
#line 452 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-dxf.c"
void xypnt_last_pnt(xypnt_head_rec *head_xypnt , xypnt *coord_point , char *finished ) 
{ 


  {
#line 456
  if (head_xypnt) {
#line 457
    head_xypnt->current_point = head_xypnt->last_point;
#line 458
    if (head_xypnt->current_point == (void *)0) {
#line 459
      *finished = (char )1;
    } else {
#line 461
      *coord_point = (head_xypnt->current_point)->point;
#line 462
      *finished = (char )0;
    }
  } else {
#line 465
    *finished = (char )1;
  }
  return;
}
}
#line 473 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-dxf.c"
double distpt2pt(xypnt p1 , xypnt p2 ) 
{ 
  double dx ;
  double dy ;
  double __cil_tmp5 ;
  double __cil_tmp6 ;
  double __cil_tmp7 ;

  {
#line 478
  dx = (double )(p2.xp - p1.xp);
#line 479
  dy = (double )(p2.yp - p1.yp);
#line 480
  if (p1.xp == p2.xp) {
    {
#line 481
    __cil_tmp5 = fabs(dy);
    }
#line 481
    return (__cil_tmp5);
  } else
#line 482
  if (p1.yp == p2.yp) {
    {
#line 483
    __cil_tmp6 = fabs(dx);
    }
#line 483
    return (__cil_tmp6);
  } else {
    {
#line 485
    __cil_tmp7 = sqrt(dx * dx + dy * dy);
    }
#line 485
    return (__cil_tmp7);
  }
}
}
#line 491 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-dxf.c"
static double get_total_length(xypnt_head_rec *vtx_list ) 
{ 
  double total_length ;
  xypnt curr_pnt ;
  xypnt next_pnt ;
  char end_of_list ;
  double __cil_tmp6 ;

  {
  {
#line 497
  total_length = 0.;
#line 498
  xypnt_first_pnt(vtx_list, & curr_pnt, & end_of_list);
  }
  {
#line 499
  while (1) {
    while_continue: /* CIL Label */ ;
#line 499
    if (! (! end_of_list)) {
#line 499
      goto while_break;
    }
    {
#line 500
    xypnt_next_pnt(vtx_list, & next_pnt, & end_of_list);
#line 501
    __cil_tmp6 = distpt2pt(curr_pnt, next_pnt);
    }
#line 501
    total_length += __cil_tmp6;
#line 502
    curr_pnt = next_pnt;
  }
  while_break: /* CIL Label */ ;
  }
#line 504
  return (total_length);
}
}
#line 510 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-dxf.c"
int bspline_to_lines(xypnt_head_rec *vtx_list , xypnt_head_rec **new_vtx_list , int vtx_count ,
                     int spline_order , int spline_resolution ) 
{ 
  int i ;
  int j ;
  int knot_index ;
  int number_of_segments ;
  int knot[10001] ;
  int n ;
  int m ;
  double spline_step ;
  double total_length ;
  double t ;
  double spline_pnt_x ;
  double spline_pnt_y ;
  double r ;
  double *weight ;
  xypnt curr_pnt ;
  xypnt spline_pnt ;
  char end_of_list ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int __cil_tmp28 ;
  double __cil_tmp29 ;
  double __cil_tmp30 ;
  double tmp___2 ;
  long __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  long __cil_tmp36 ;
  long __cil_tmp37 ;
  int __cil_tmp38 ;

  {
  {
#line 521
  __cil_tmp23 = calloc((unsigned long )1, sizeof(struct xypnt_head_t ));
#line 521
  *new_vtx_list = (struct xypnt_head_t *)__cil_tmp23;
  }
#line 522
  if (vtx_list) {
#line 523
    n = (vtx_count + spline_order) + 1;
#line 524
    m = spline_order + 1;
    {
#line 525
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 525
      __cil_tmp24 = malloc((unsigned long )(n * m) * sizeof(double ));
#line 525
      weight = (gpointer )__cil_tmp24;
      }
#line 525
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 527
    i = 0;
    {
#line 527
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 527
      if (! (i < vtx_count + spline_order)) {
#line 527
        goto while_break___0;
      }
#line 528
      if (i < spline_order) {
#line 528
        tmp___1 = 0;
      } else {
#line 528
        if (i > vtx_count) {
#line 528
          tmp___0 = knot[i - 1];
        } else {
#line 528
          tmp___0 = knot[i - 1] + 1;
        }
#line 528
        tmp___1 = tmp___0;
      }
#line 528
      knot[i] = tmp___1;
#line 527
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 529
    total_length = get_total_length(vtx_list);
    }
#line 530
    if (spline_resolution == 0) {
      {
#line 530
      __cil_tmp30 = sqrt(total_length);
#line 530
      tmp___2 = __cil_tmp30;
      }
    } else {
#line 530
      tmp___2 = total_length / (double )spline_resolution;
    }
    {
#line 530
    r = tmp___2;
#line 531
    __cil_tmp32 = lround(r);
#line 531
    number_of_segments = (int )__cil_tmp32;
#line 532
    spline_step = (double )knot[(vtx_count + spline_order) - 1] / (double )number_of_segments;
#line 533
    knot_index = spline_order - 1;
    }
    {
#line 533
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 533
      if (! (knot_index < vtx_count)) {
#line 533
        goto while_break___1;
      }
#line 534
      i = 0;
      {
#line 534
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 534
        if (! (i <= (vtx_count + spline_order) - 2)) {
#line 534
          goto while_break___2;
        }
#line 535
        *(weight + i) = (double )(i == knot_index && knot[i] != knot[i + 1]);
#line 534
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 536
      t = (double )knot[knot_index];
      {
#line 537
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 537
        if (! (t < (double )knot[knot_index + 1] - spline_step / 2.)) {
#line 537
          goto while_break___3;
        }
#line 538
        spline_pnt_x = 0.;
#line 539
        spline_pnt_y = 0.;
#line 540
        j = 2;
        {
#line 540
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 540
          if (! (j <= spline_order)) {
#line 540
            goto while_break___4;
          }
          {
#line 541
          i = 0;
#line 542
          xypnt_first_pnt(vtx_list, & curr_pnt, & end_of_list);
          }
          {
#line 543
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 543
            if (! (! end_of_list)) {
#line 543
              goto while_break___5;
            }
#line 544
            *(weight + ((j - 1) * n + i)) = (double )0;
#line 545
            if (*(weight + ((j - 2) * n + i))) {
#line 546
              *(weight + ((j - 1) * n + i)) += ((t - (double )knot[i]) * *(weight + ((j - 2) * n + i))) / (double )(knot[(i + j) - 1] - knot[i]);
            }
#line 547
            if (*(weight + (((j - 2) * n + i) + 1))) {
#line 548
              *(weight + ((j - 1) * n + i)) += (((double )knot[i + j] - t) * *(weight + (((j - 2) * n + i) + 1))) / (double )(knot[i + j] - knot[i + 1]);
            }
#line 549
            if (j == spline_order) {
#line 550
              spline_pnt_x += (double )curr_pnt.xp * *(weight + ((j - 1) * n + i));
#line 551
              spline_pnt_y += (double )curr_pnt.yp * *(weight + ((j - 1) * n + i));
            }
            {
#line 553
            i ++;
#line 554
            xypnt_next_pnt(vtx_list, & curr_pnt, & end_of_list);
            }
          }
          while_break___5: /* CIL Label */ ;
          }
#line 556
          *(weight + ((j - 1) * n + i)) = (double )0;
#line 540
          j ++;
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 558
        __cil_tmp36 = lround(spline_pnt_x);
#line 558
        spline_pnt.xp = (int )__cil_tmp36;
#line 559
        __cil_tmp37 = lround(spline_pnt_y);
#line 559
        spline_pnt.yp = (int )__cil_tmp37;
#line 560
        xypnt_add_pnt(*new_vtx_list, spline_pnt);
#line 561
        t += spline_step;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 533
      knot_index ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 564
    xypnt_last_pnt(vtx_list, & spline_pnt, & end_of_list);
#line 565
    xypnt_add_pnt(*new_vtx_list, spline_pnt);
#line 567
    free(weight);
    }
  }
#line 570
  return (0);
}
}
#line 576 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-dxf.c"
static void out_splines___2(FILE *dxf_file , at_spline_list_array_type shape ) 
{ 
  unsigned int this_list ;
  double startx ;
  double starty ;
  xypnt_head_rec *vec ;
  xypnt_head_rec *res ;
  xypnt pnt ;
  xypnt pnt_old ;
  char fin ;
  char new_layer ;
  char layerstr[10] ;
  int i ;
  int first_seg ;
  int idx ;
  unsigned int this_spline ;
  at_color last_color ;
  spline_list_type list ;
  spline_type first ;
  at_color curr_color ;
  at_color tmp ;
  gboolean __cil_tmp22 ;
  int __cil_tmp23 ;
  long __cil_tmp24 ;
  long __cil_tmp25 ;
  long __cil_tmp26 ;
  long __cil_tmp27 ;
  long __cil_tmp28 ;
  long __cil_tmp29 ;
  spline_type s ;
  long __cil_tmp31 ;
  long __cil_tmp32 ;
  long __cil_tmp33 ;
  long __cil_tmp34 ;
  void *__cil_tmp35 ;
  long __cil_tmp36 ;
  long __cil_tmp37 ;
  long __cil_tmp38 ;
  long __cil_tmp39 ;
  long __cil_tmp40 ;
  long __cil_tmp41 ;
  long __cil_tmp42 ;
  long __cil_tmp43 ;
  int __cil_tmp44 ;
  unsigned int __cil_tmp45 ;
  unsigned int __cil_tmp46 ;

  {
#line 581
  pnt_old.xp = 0;
  {
#line 581
  pnt_old.yp = 0;
#line 582
  new_layer = (char )0;
#line 583
  first_seg = 1;
#line 585
  strcpy((char *)layerstr, "C1");
#line 586
  this_list = (unsigned int )0;
  }
  {
#line 586
  while (1) {
    while_continue: /* CIL Label */ ;
#line 586
    if (! (this_list < shape.length)) {
#line 586
      goto while_break;
    }
#line 588
    last_color.r = (guint8 )0;
#line 588
    last_color.g = (guint8 )0;
#line 588
    last_color.b = (guint8 )0;
#line 590
    list = *(shape.data + this_list);
#line 591
    first = *(list.data + 0);
#line 592
    if (shape.background_color != (void *)0 && list.clockwise) {
#line 592
      tmp = *(shape.background_color);
    } else {
#line 592
      tmp = list.color;
    }
    {
#line 592
    curr_color = tmp;
#line 594
    __cil_tmp22 = at_color_equal(& curr_color, & last_color);
    }
#line 594
    if (this_list == 0U) {
      _L: /* CIL Label */ 
#line 595
      if (1) {
        {
#line 596
        idx = GetIndexByRGBValue((int )curr_color.r, (int )curr_color.g, (int )curr_color.b);
#line 597
        sprintf((char *)layerstr, "C%d", idx);
#line 598
        new_layer = (char )1;
#line 599
        last_color = curr_color;
        }
      }
    } else
#line 594
    if (! __cil_tmp22) {
#line 594
      goto _L;
    }
#line 602
    startx = (double )first.v[0].x;
#line 603
    starty = (double )first.v[0].y;
#line 604
    if (! first_seg) {
      {
#line 605
      __cil_tmp25 = lround(starty * (double )10000);
      }
      {
#line 605
      __cil_tmp24 = lround(startx * (double )10000);
      }
#line 605
      if (__cil_tmp24 != (long )pnt_old.xp) {
        _L___52: /* CIL Label */ 
        _L___53: /* CIL Label */ 
        {
#line 607
        new_layer = (char )0;
#line 608
        fprintf(dxf_file, "  0\nSEQEND\n  8\n%s\n", (char *)layerstr);
#line 609
        fprintf(dxf_file, "  0\nPOLYLINE\n  8\n%s\n  66\n1\n  10\n%f\n  20\n%f\n",
                (char *)layerstr, startx, starty);
#line 610
        fprintf(dxf_file, "  0\nVERTEX\n  8\n%s\n  10\n%f\n  20\n%f\n", (char *)layerstr,
                startx, starty);
#line 611
        __cil_tmp26 = lround(startx * (double )10000);
#line 611
        pnt_old.xp = (int )__cil_tmp26;
#line 612
        __cil_tmp27 = lround(starty * (double )10000);
#line 612
        pnt_old.yp = (int )__cil_tmp27;
        }
      } else
#line 605
      if (__cil_tmp25 != (long )pnt_old.yp) {
#line 605
        goto _L___52;
      } else
#line 605
      if ((int )new_layer) {
#line 605
        goto _L___52;
      }
    } else {
      {
#line 615
      fprintf(dxf_file, "  0\nPOLYLINE\n  8\n%s\n  66\n1\n  10\n%f\n  20\n%f\n", (char *)layerstr,
              startx, starty);
#line 616
      fprintf(dxf_file, "  0\nVERTEX\n  8\n%s\n  10\n%f\n  20\n%f\n", (char *)layerstr,
              startx, starty);
#line 617
      __cil_tmp28 = lround(startx * (double )10000);
#line 617
      pnt_old.xp = (int )__cil_tmp28;
#line 618
      __cil_tmp29 = lround(starty * (double )10000);
#line 618
      pnt_old.yp = (int )__cil_tmp29;
      }
    }
#line 620
    this_spline = (unsigned int )0;
    {
#line 620
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 620
      if (! (this_spline < list.length)) {
#line 620
        goto while_break___0;
      }
#line 621
      s = *(list.data + this_spline);
#line 623
      if ((unsigned int )s.degree == 1U) {
        {
#line 625
        __cil_tmp32 = lround(starty * (double )10000);
        }
        {
#line 625
        __cil_tmp31 = lround(startx * (double )10000);
        }
#line 625
        if (__cil_tmp31 != (long )pnt_old.xp) {
          {
#line 627
          new_layer = (char )0;
          {
          {
#line 628
          fprintf(dxf_file, "  0\nSEQEND\n  8\n%s\n7\r\027V", (char *)layerstr);
          }
          }
          {
          {
#line 629
          fprintf(dxf_file, "  0\nPOLYLINE\n  8\n%s\n  66\n1\n  10\n%f\n  20\n%f\n",
                  (char *)layerstr, startx, starty);
          }
          }
          {
          {
#line 630
          fprintf(dxf_file, "  0\nVERTEX\n  8\n%s\n  10\n%f\n  20\n%f\n7\r\027V",
                  (char *)layerstr, startx, starty);
          }
          }
          }
        } else
#line 625
        if (__cil_tmp32 != (long )pnt_old.yp) {
          {
#line 627
          new_layer = (char )0;
          {
          {
#line 628
          fprintf(dxf_file, "  0\nSEQEND\n  8\n%s\n7\r\027V", (char *)layerstr);
          }
          }
          {
          {
#line 629
          fprintf(dxf_file, "  0\nPOLYLINE\n  8\n%s\n  66\n1\n  10\n%f\n  20\n%f\n",
                  (char *)layerstr, startx, starty);
          }
          }
          {
          {
#line 630
          fprintf(dxf_file, "  0\nVERTEX\n  8\n%s\n  10\n%f\n  20\n%f\n7\r\027V",
                  (char *)layerstr, startx, starty);
          }
          }
          }
        } else
#line 625
        if ((int )new_layer) {
          {
#line 627
          new_layer = (char )0;
          {
          {
#line 628
          fprintf(dxf_file, "  0\nSEQEND\n  8\n%s\n7\r\027V", (char *)layerstr);
          }
          }
          {
          {
#line 629
          fprintf(dxf_file, "  0\nPOLYLINE\n  8\n%s\n  66\n1\n  10\n%f\n  20\n%f\n",
                  (char *)layerstr, startx, starty);
          }
          }
          {
          {
#line 630
          fprintf(dxf_file, "  0\nVERTEX\n  8\n%s\n  10\n%f\n  20\n%f\n7\r\027V",
                  (char *)layerstr, startx, starty);
          }
          }
          }
        }
        {
#line 632
        fprintf(dxf_file, "  0\nVERTEX\n  8\n%s\n  10\n%f\n  20\n%f\n", (char *)layerstr,
                (double )s.v[3].x, (double )s.v[3].y);
#line 634
        startx = (double )s.v[3].x;
#line 635
        starty = (double )s.v[3].y;
#line 636
        __cil_tmp33 = lround(startx * (double )10000);
#line 636
        pnt_old.xp = (int )__cil_tmp33;
#line 637
        __cil_tmp34 = lround(starty * (double )10000);
#line 637
        pnt_old.yp = (int )__cil_tmp34;
        }
      } else {
        {
#line 639
        __cil_tmp35 = calloc((unsigned long )1, sizeof(struct xypnt_head_t ));
#line 639
        vec = (struct xypnt_head_t *)__cil_tmp35;
#line 641
        __cil_tmp36 = lround(startx * (double )10000);
#line 641
        pnt.xp = (int )__cil_tmp36;
#line 642
        __cil_tmp37 = lround(starty * (double )10000);
#line 642
        pnt.yp = (int )__cil_tmp37;
#line 643
        xypnt_add_pnt(vec, pnt);
#line 644
        __cil_tmp38 = lround((double )(s.v[1].x * (float )10000));
#line 644
        pnt.xp = (int )__cil_tmp38;
#line 645
        __cil_tmp39 = lround((double )(s.v[1].y * (float )10000));
#line 645
        pnt.yp = (int )__cil_tmp39;
#line 646
        xypnt_add_pnt(vec, pnt);
#line 647
        __cil_tmp40 = lround((double )(s.v[2].x * (float )10000));
#line 647
        pnt.xp = (int )__cil_tmp40;
#line 648
        __cil_tmp41 = lround((double )(s.v[2].y * (float )10000));
#line 648
        pnt.yp = (int )__cil_tmp41;
#line 649
        xypnt_add_pnt(vec, pnt);
#line 650
        __cil_tmp42 = lround((double )(s.v[3].x * (float )10000));
#line 650
        pnt.xp = (int )__cil_tmp42;
#line 651
        __cil_tmp43 = lround((double )(s.v[3].y * (float )10000));
#line 651
        pnt.yp = (int )__cil_tmp43;
#line 652
        xypnt_add_pnt(vec, pnt);
#line 654
        res = (xypnt_head_rec *)((void *)0);
#line 657
        bspline_to_lines(vec, & res, 4, 4, 10000);
#line 659
        xypnt_first_pnt(res, & pnt, & fin);
        }
#line 661
        if (pnt.xp != pnt_old.xp) {
          {
#line 663
          new_layer = (char )0;
          {
          {
#line 664
          fprintf(dxf_file, "  0\nSEQEND\n  8\n%s\n", (char *)layerstr);
          }
          }
          {
          {
#line 665
          fprintf(dxf_file, "  0\nPOLYLINE\n  8\n%s\n  66\n1\n  10\n%f\n  20\n%f\n",
                  (char *)layerstr, (double )pnt.xp / (double )10000, (double )pnt.yp / (double )10000);
          }
          }
          {
          {
#line 666
          fprintf(dxf_file, "  0\nVERTEX\n  8\n%s\n  10\n%f\n  20\n%f\n7\r\027V",
                  (char *)layerstr, (double )pnt.xp / (double )10000, (double )pnt.yp / (double )10000);
          }
          }
          }
        } else
#line 661
        if (pnt.yp != pnt_old.yp) {
          {
#line 663
          new_layer = (char )0;
          {
          {
#line 664
          fprintf(dxf_file, "  0\nSEQEND\n  8\n%s\n", (char *)layerstr);
          }
          }
          {
          {
#line 665
          fprintf(dxf_file, "  0\nPOLYLINE\n  8\n%s\n  66\n1\n  10\n%f\n  20\n%f\n",
                  (char *)layerstr, (double )pnt.xp / (double )10000, (double )pnt.yp / (double )10000);
          }
          }
          {
          {
#line 666
          fprintf(dxf_file, "  0\nVERTEX\n  8\n%s\n  10\n%f\n  20\n%f\n7\r\027V",
                  (char *)layerstr, (double )pnt.xp / (double )10000, (double )pnt.yp / (double )10000);
          }
          }
          }
        } else
#line 661
        if ((int )new_layer) {
          {
#line 663
          new_layer = (char )0;
          {
          {
#line 664
          fprintf(dxf_file, "  0\nSEQEND\n  8\n%s\n", (char *)layerstr);
          }
          }
          {
          {
#line 665
          fprintf(dxf_file, "  0\nPOLYLINE\n  8\n%s\n  66\n1\n  10\n%f\n  20\n%f\n",
                  (char *)layerstr, (double )pnt.xp / (double )10000, (double )pnt.yp / (double )10000);
          }
          }
          {
          {
#line 666
          fprintf(dxf_file, "  0\nVERTEX\n  8\n%s\n  10\n%f\n  20\n%f\n7\r\027V",
                  (char *)layerstr, (double )pnt.xp / (double )10000, (double )pnt.yp / (double )10000);
          }
          }
          }
        }
#line 668
        i = 0;
        {
#line 669
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 669
          if (! (! fin)) {
#line 669
            goto while_break___1;
          }
#line 670
          if (i) {
            {
#line 671
            fprintf(dxf_file, "  0\nVERTEX\n  8\n%s\n  10\n%f\n  20\n%f\n7\r\027V",
                    (char *)layerstr, (double )pnt.xp / (double )10000, (double )pnt.yp / (double )10000);
            }
          }
          {
#line 673
          xypnt_next_pnt(res, & pnt, & fin);
#line 674
          i ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 677
        pnt_old = pnt;
#line 679
        xypnt_dispose_list(& vec);
#line 680
        xypnt_dispose_list(& res);
#line 682
        startx = (double )s.v[3].x;
#line 683
        starty = (double )s.v[3].y;
#line 685
        free(res);
#line 686
        free(vec);
        }
      }
#line 620
      this_spline ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 689
    first_seg = 0;
#line 690
    last_color = curr_color;
#line 586
    this_list ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 693
  fprintf(dxf_file, "  0\nSEQEND\n  8\n0\n\377\377\377");
  }
  return;
}
}
#line 700 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-dxf.c"
void output_layer(FILE *dxf_file , at_spline_list_array_type shape ) 
{ 
  int i ;
  int idx ;
  char layerlist[256] ;
  unsigned int this_list ;
  at_color last_color ;
  spline_list_type list ;
  at_color curr_color ;
  at_color tmp ;
  gboolean __cil_tmp11 ;
  int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  int __cil_tmp14 ;

  {
#line 705
  last_color.r = (guint8 )0;
#line 705
  last_color.g = (guint8 )0;
  {
#line 705
  last_color.b = (guint8 )0;
#line 707
  memset((char *)layerlist, 0, sizeof(layerlist));
#line 708
  this_list = (unsigned int )0;
  }
  {
#line 708
  while (1) {
    while_continue: /* CIL Label */ ;
#line 708
    if (! (this_list < shape.length)) {
#line 708
      goto while_break;
    }
#line 709
    list = *(shape.data + this_list);
#line 710
    if (shape.background_color != (void *)0 && list.clockwise) {
#line 710
      tmp = *(shape.background_color);
    } else {
#line 710
      tmp = list.color;
    }
    {
#line 710
    curr_color = tmp;
#line 712
    __cil_tmp11 = at_color_equal(& curr_color, & last_color);
    }
#line 712
    if (this_list == 0U) {
      _L: /* CIL Label */ 
#line 713
      if (1) {
        {
#line 714
        idx = GetIndexByRGBValue((int )curr_color.r, (int )curr_color.g, (int )curr_color.b);
#line 715
        layerlist[idx - 1] = (char )1;
#line 716
        last_color = curr_color;
        }
      }
    } else
#line 712
    if (! __cil_tmp11) {
#line 712
      goto _L;
    }
#line 708
    this_list ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 721
  fprintf(dxf_file, "%s\n", "  0");
#line 722
  fprintf(dxf_file, "%s\n", "SECTION");
#line 723
  fprintf(dxf_file, "%s\n", "  2");
#line 724
  fprintf(dxf_file, "%s\n", "TABLES");
#line 725
  fprintf(dxf_file, "%s\n", "  0");
#line 726
  fprintf(dxf_file, "%s\n", "TABLE");
#line 727
  fprintf(dxf_file, "%s\n", "  2");
#line 728
  fprintf(dxf_file, "%s\n", "LAYER");
#line 729
  fprintf(dxf_file, "%s\n", "  70");
#line 730
  fprintf(dxf_file, "%s\n", "     2048");
#line 732
  fprintf(dxf_file, "%s\n", "  0");
#line 733
  fprintf(dxf_file, "%s\n", "LAYER");
#line 734
  fprintf(dxf_file, "%s\n", "  2");
#line 735
  fprintf(dxf_file, "%s\n", "0");
#line 736
  fprintf(dxf_file, "%s\n", "  70");
#line 737
  fprintf(dxf_file, "%s\n", "    0");
#line 738
  fprintf(dxf_file, "%s\n", "  62");
#line 739
  fprintf(dxf_file, "%s\n", "     7");
#line 740
  fprintf(dxf_file, "%s\n", "  6");
#line 741
  fprintf(dxf_file, "%s\n", "CONTINUOUS");
#line 743
  i = 1;
  }
  {
#line 743
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 743
    if (! (i < 256)) {
#line 743
      goto while_break___0;
    }
#line 744
    if (layerlist[i - 1]) {
      {
#line 745
      fprintf(dxf_file, "%s\n\r\027V", "  0\r\027V");
#line 746
      fprintf(dxf_file, "%s\n\v\027V", "LAYER");
#line 747
      fprintf(dxf_file, "%s\n", "   2");
#line 748
      fprintf(dxf_file, "C%d\n", i);
#line 749
      fprintf(dxf_file, "%s\n", "  70");
#line 750
      fprintf(dxf_file, "%s\n", "     64");
#line 751
      fprintf(dxf_file, "%s\n", "  62");
#line 752
      fprintf(dxf_file, "%d\n\r\027V", i);
#line 753
      fprintf(dxf_file, "%s\n\r\027V", "  6\r\027V");
#line 754
      fprintf(dxf_file, "%s\n\r\027V", "CONTINUOUS");
      }
    }
#line 743
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 758
  fprintf(dxf_file, "%s\n", "  0");
#line 759
  fprintf(dxf_file, "%s\n", "ENDTAB");
#line 760
  fprintf(dxf_file, "%s\n", "  0");
#line 761
  fprintf(dxf_file, "%s\n", "ENDSEC");
  }
  return;
}
}
#line 768 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-dxf.c"
int output_dxf12_writer(FILE *dxf_file , gchar *name , int llx , int lly , int urx ,
                        int ury , at_output_opts_type *opts , at_spline_list_array_type shape ,
                        at_msg_func msg_func , gpointer msg_data , gpointer user_data ) 
{ 


  {
  {
#line 770
  fprintf(dxf_file, "%s\n", "  0");
#line 771
  fprintf(dxf_file, "%s\n", "SECTION");
#line 772
  fprintf(dxf_file, "%s\n", "  2");
#line 773
  fprintf(dxf_file, "%s\n", "HEADER");
#line 774
  fprintf(dxf_file, "%s\n", "  9");
#line 775
  fprintf(dxf_file, "%s\n", "$ACADVER\220");
#line 776
  fprintf(dxf_file, "%s\n", "  1");
#line 777
  fprintf(dxf_file, "%s\n\r\027V", "AC1009");
#line 778
  fprintf(dxf_file, "%s\n", "  9");
#line 779
  fprintf(dxf_file, "%s\n", "$EXTMIN");
#line 780
  fprintf(dxf_file, "%s\n\r\027V", "  10\027V");
#line 781
  fprintf(dxf_file, " %f\n\027V", (double )llx);
#line 782
  fprintf(dxf_file, "%s\n", "  20");
#line 783
  fprintf(dxf_file, " %f\n", (double )lly);
#line 784
  fprintf(dxf_file, "%s\n", "  30");
#line 785
  fprintf(dxf_file, "%s\n\r\027V", " 0.000000");
#line 786
  fprintf(dxf_file, "%s\n\r\027V", "  9\r\027V");
#line 787
  fprintf(dxf_file, "%s\n", "$EXTMAX");
#line 788
  fprintf(dxf_file, "%s\n", "  10");
#line 789
  fprintf(dxf_file, " %f\n", (double )urx);
#line 790
  fprintf(dxf_file, "%s\n", "  20");
#line 791
  fprintf(dxf_file, " %f\n\027V", (double )ury);
#line 792
  fprintf(dxf_file, "%s\n\r\027V", "  30\027V");
#line 793
  fprintf(dxf_file, "%s\n", " 0.000000");
#line 794
  fprintf(dxf_file, "%s\n\r\027V", "  0\r\027V");
#line 795
  fprintf(dxf_file, "%s\n\r\027V", "ENDSEC");
#line 797
  output_layer(dxf_file, shape);
#line 799
  fprintf(dxf_file, "%s\n\r\027V", "  0\r\027V");
#line 800
  fprintf(dxf_file, "%s\n\r\027V", "SECTION");
#line 801
  fprintf(dxf_file, "%s\n\r\027V", "  2");
#line 802
  fprintf(dxf_file, "%s\n", "ENTITIES\220");
#line 804
  out_splines___2(dxf_file, shape);
#line 806
  fprintf(dxf_file, "%s\n", "  0");
#line 807
  fprintf(dxf_file, "%s\n", "ENDSEC");
#line 808
  fprintf(dxf_file, "%s\n", "  0");
#line 809
  fprintf(dxf_file, "%s\n", "EOF");
  }
#line 810
  return (0);
}
}
#line 808 "/usr/include/glib-2.0/gobject/gobject.h"
__inline static void g_assert_finalize_object___24(GObject *object ) 
{ 
  gpointer weak_pointer ;
  long __cil_tmp3 ;
  long __cil_tmp4 ;

  {
#line 810
  weak_pointer = object;
  {
#line 812
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 812
    __cil_tmp3 = __builtin_expect((long )0, (long )1);
    }
#line 812
    if (__cil_tmp3) {

    } else {
      {
#line 812
      g_assertion_message((char const   *)((gchar *)0), "/usr/include/glib-2.0/gobject/gobject.h",
                          812, (char const   *)"g_assert_finalize_object\312\001@",
                          "\'G_IS_OBJECT (weak_pointer)\' should be TRUE");
      }
    }
#line 812
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 813
  g_object_add_weak_pointer(object, & weak_pointer);
#line 814
  g_object_unref(weak_pointer);
  }
  {
#line 815
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 815
    __cil_tmp4 = __builtin_expect((long )0, (long )1);
    }
#line 815
    if (__cil_tmp4) {

    } else {
      {
#line 815
      g_assertion_message((char const   *)((gchar *)0), "/usr/include/glib-2.0/gobject/gobject.h",
                          815, (char const   *)"g_assert_finalize_object\312\001@\r\313\256\b",
                          "\'weak_pointer\' should be NULLV");
      }
    }
#line 815
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 93 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-emf.c"
static EMFColorList *color_list  =    (EMFColorList *)((void *)0);
#line 94 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-emf.c"
static uint32_t *color_table  =    (uint32_t *)((void *)0);
#line 95
static float y_offset ;
#line 99 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-emf.c"
static int SearchColor(EMFColorList *head , uint32_t colref ) 
{ 


  {
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    if (! (head != (void *)0)) {
#line 101
      goto while_break;
    }
#line 102
    if (head->colref == colref) {
#line 103
      return (1);
    }
#line 104
    head = head->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 106
  return (0);
}
}
#line 109 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-emf.c"
static void AddColor(EMFColorList **head , uint32_t colref ) 
{ 
  EMFColorList *temp ;
  void *__cil_tmp4 ;
  int tmp ;

  {
  {
#line 113
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 113
    __cil_tmp4 = malloc(sizeof(EMFColorList ));
#line 113
    temp = (gpointer )__cil_tmp4;
    }
#line 113
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 115
  temp->colref = colref;
#line 116
  temp->next = *head;
#line 117
  *head = temp;
  return;
}
}
#line 120 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-emf.c"
static void ColorListToColorTable(EMFColorList **head , uint32_t **table , int len ) 
{ 
  EMFColorList *temp ;
  int i ;
  void *__cil_tmp6 ;
  int tmp ;
  int __cil_tmp8 ;

  {
#line 123
  i = 0;
  {
#line 125
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 125
    __cil_tmp6 = malloc(sizeof(uint32_t ) * (unsigned long )len);
#line 125
    *table = (gpointer )__cil_tmp6;
    }
#line 125
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 127
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 127
    if (! (*head != (void *)0)) {
#line 127
      goto while_break___0;
    }
    {
#line 128
    temp = *head;
#line 129
    *head = (*head)->next;
#line 130
    *(*table + i) = temp->colref;
#line 131
    i ++;
#line 132
    free(temp);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 136 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-emf.c"
static int ColorLookUp(uint32_t colref , uint32_t *table , int len ) 
{ 
  int i ;
  int __cil_tmp5 ;

  {
#line 140
  i = 0;
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 140
    if (! (i < len)) {
#line 140
      goto while_break;
    }
#line 141
    if (colref == *(table + i)) {
#line 142
      return (i);
    }
#line 140
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 144
  return (0);
}
}
#line 149 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-emf.c"
static gboolean write32(FILE *fdes , uint32_t data ) 
{ 
  size_t count ;
  uint8_t outch ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  int tmp ;

  {
  {
#line 151
  count = (size_t )0;
#line 154
  outch = (uint8_t )(data & 255U);
#line 155
  __cil_tmp5 = fwrite(& outch, (unsigned long )1, (unsigned long )1, fdes);
  }
  {
#line 155
  count += __cil_tmp5;
#line 157
  outch = (uint8_t )((data >> 8) & 255U);
#line 158
  __cil_tmp6 = fwrite(& outch, (unsigned long )1, (unsigned long )1, fdes);
  }
  {
#line 158
  count += __cil_tmp6;
#line 160
  outch = (uint8_t )((data >> 16) & 255U);
#line 161
  __cil_tmp7 = fwrite(& outch, (unsigned long )1, (unsigned long )1, fdes);
  }
  {
#line 161
  count += __cil_tmp7;
#line 163
  outch = (uint8_t )((data >> 24) & 255U);
#line 164
  __cil_tmp8 = fwrite(& outch, (unsigned long )1, (unsigned long )1, fdes);
  }
#line 164
  count += __cil_tmp8;
#line 166
  if (count == sizeof(uint32_t )) {
#line 166
    tmp = ! 0;
  } else {
#line 166
    tmp = 0;
  }
#line 166
  return (tmp);
}
}
#line 169 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-emf.c"
static gboolean write16___0(FILE *fdes , uint16_t data ) 
{ 
  size_t count ;
  uint8_t outch ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int tmp ;

  {
  {
#line 171
  count = (size_t )0;
#line 174
  outch = (uint8_t )((int )data & 255);
#line 175
  __cil_tmp5 = fwrite(& outch, (unsigned long )1, (unsigned long )1, fdes);
  }
  {
#line 175
  count += __cil_tmp5;
#line 177
  outch = (uint8_t )(((int )data >> 8) & 255);
#line 178
  __cil_tmp6 = fwrite(& outch, (unsigned long )1, (unsigned long )1, fdes);
  }
#line 178
  count += __cil_tmp6;
#line 180
  if (count == sizeof(uint16_t )) {
#line 180
    tmp = ! 0;
  } else {
#line 180
    tmp = 0;
  }
#line 180
  return (tmp);
}
}
#line 185 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-emf.c"
static int WriteMoveTo(FILE *fdes , at_real_coord *pt ) 
{ 
  int recsize ;

  {
#line 187
  recsize = (int )(sizeof(uint32_t ) * 4UL);
#line 189
  if (fdes != (void *)0) {
    {
#line 190
    write32(fdes, (uint32_t )27);
#line 191
    write32(fdes, (uint32_t )recsize);
#line 192
    write32(fdes, (uint32_t )((uint32_t )(pt->x * (gfloat )1.)));
#line 193
    write32(fdes, (uint32_t )((uint32_t )(y_offset - pt->y * (gfloat )1.)));
    }
  }
#line 195
  return (recsize);
}
}
#line 198 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-emf.c"
static int WriteLineTo(FILE *fdes , spline_type *spl ) 
{ 
  int recsize ;

  {
#line 200
  recsize = (int )(sizeof(uint32_t ) * 4UL);
#line 202
  if (fdes != (void *)0) {
    {
#line 203
    write32(fdes, (uint32_t )54);
#line 204
    write32(fdes, (uint32_t )recsize);
#line 205
    write32(fdes, (uint32_t )((uint32_t )(spl->v[3].x * (gfloat )1.)));
#line 206
    write32(fdes, (uint32_t )((uint32_t )(y_offset - spl->v[3].y * (gfloat )1.)));
    }
  }
#line 208
  return (recsize);
}
}
#line 237 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-emf.c"
static int MyWritePolyLineTo(FILE *fdes , spline_type *spl , int nlines ) 
{ 
  int i ;
  int recsize ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 240
  __cil_tmp6 = WriteLineTo((FILE *)((void *)0), (spline_type *)((void *)0));
#line 240
  recsize = nlines * __cil_tmp6;
  }
#line 242
  if (fdes != (void *)0) {
#line 243
    i = 0;
    {
#line 243
    while (1) {
      while_continue: /* CIL Label */ ;
#line 243
      if (! (i < nlines)) {
#line 243
        goto while_break;
      }
      {
#line 244
      WriteLineTo(fdes, spl + i);
      }
#line 243
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 247
  return (recsize);
}
}
#line 281 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-emf.c"
static int WritePolyBezierTo16(FILE *fdes , spline_type *spl , int ncurves ) 
{ 
  int i ;
  int recsize ;
  int __cil_tmp6 ;

  {
#line 284
  recsize = (int )(sizeof(uint32_t ) * 7UL + (sizeof(uint16_t ) * (unsigned long )ncurves) * 6UL);
#line 286
  if (fdes != (void *)0) {
    {
#line 287
    write32(fdes, (uint32_t )88);
#line 288
    write32(fdes, (uint32_t )recsize);
#line 289
    write32(fdes, (uint32_t )0);
#line 290
    write32(fdes, (uint32_t )0);
#line 291
    write32(fdes, (uint32_t )4294967295U);
#line 292
    write32(fdes, (uint32_t )4294967295U);
#line 293
    write32(fdes, (uint32_t )ncurves * 3U);
#line 295
    i = 0;
    }
    {
#line 295
    while (1) {
      while_continue: /* CIL Label */ ;
#line 295
      if (! (i < ncurves)) {
#line 295
        goto while_break;
      }
      {
#line 296
      write16___0(fdes, (uint16_t )((uint16_t )((spl + i)->v[1].x * (gfloat )1.)));
#line 297
      write16___0(fdes, (uint16_t )((uint16_t )(y_offset - (spl + i)->v[1].y * (gfloat )1.)));
#line 298
      write16___0(fdes, (uint16_t )((uint16_t )((spl + i)->v[2].x * (gfloat )1.)));
#line 299
      write16___0(fdes, (uint16_t )((uint16_t )(y_offset - (spl + i)->v[2].y * (gfloat )1.)));
#line 300
      write16___0(fdes, (uint16_t )((uint16_t )((spl + i)->v[3].x * (gfloat )1.)));
#line 301
      write16___0(fdes, (uint16_t )((uint16_t )(y_offset - (spl + i)->v[3].y * (gfloat )1.)));
      }
#line 295
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 304
  return (recsize);
}
}
#line 307 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-emf.c"
static int WriteSetPolyFillMode(FILE *fdes ) 
{ 
  int recsize ;

  {
#line 309
  recsize = (int )(sizeof(uint32_t ) * 3UL);
#line 311
  if (fdes != (void *)0) {
    {
#line 312
    write32(fdes, (uint32_t )19);
#line 313
    write32(fdes, (uint32_t )recsize);
#line 314
    write32(fdes, (uint32_t )1);
    }
  }
#line 316
  return (recsize);
}
}
#line 319 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-emf.c"
static int WriteBeginPath(FILE *fdes ) 
{ 
  int recsize ;

  {
#line 321
  recsize = (int )(sizeof(uint32_t ) * 2UL);
#line 323
  if (fdes != (void *)0) {
    {
#line 324
    write32(fdes, (uint32_t )59);
#line 325
    write32(fdes, (uint32_t )recsize);
    }
  }
#line 327
  return (recsize);
}
}
#line 330 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-emf.c"
static int WriteEndPath(FILE *fdes ) 
{ 
  int recsize ;

  {
#line 332
  recsize = (int )(sizeof(uint32_t ) * 2UL);
#line 334
  if (fdes != (void *)0) {
    {
#line 335
    write32(fdes, (uint32_t )60);
#line 336
    write32(fdes, (uint32_t )recsize);
    }
  }
#line 338
  return (recsize);
}
}
#line 341 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-emf.c"
static int WriteFillPath(FILE *fdes ) 
{ 
  int recsize ;

  {
#line 343
  recsize = (int )(sizeof(uint32_t ) * 6UL);
#line 345
  if (fdes != (void *)0) {
    {
#line 346
    write32(fdes, (uint32_t )62);
#line 347
    write32(fdes, (uint32_t )recsize);
#line 348
    write32(fdes, (uint32_t )0);
#line 349
    write32(fdes, (uint32_t )0);
#line 350
    write32(fdes, (uint32_t )4294967295U);
#line 351
    write32(fdes, (uint32_t )4294967295U);
    }
  }
#line 353
  return (recsize);
}
}
#line 356 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-emf.c"
static int WriteStrokePath(FILE *fdes ) 
{ 
  int recsize ;

  {
#line 358
  recsize = (int )(sizeof(uint32_t ) * 6UL);
#line 360
  if (fdes != (void *)0) {
    {
#line 361
    write32(fdes, (uint32_t )64);
#line 362
    write32(fdes, (uint32_t )recsize);
#line 363
    write32(fdes, (uint32_t )0);
#line 364
    write32(fdes, (uint32_t )0);
#line 365
    write32(fdes, (uint32_t )4294967295U);
#line 366
    write32(fdes, (uint32_t )4294967295U);
    }
  }
#line 368
  return (recsize);
}
}
#line 402 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-emf.c"
static int WriteCreateSolidPen(FILE *fdes , int hndNum , uint32_t colref ) 
{ 
  int recsize ;

  {
#line 404
  recsize = (int )(sizeof(uint32_t ) * 7UL);
#line 406
  if (fdes != (void *)0) {
    {
#line 407
    write32(fdes, (uint32_t )38);
#line 408
    write32(fdes, (uint32_t )recsize);
#line 409
    write32(fdes, (uint32_t )hndNum);
#line 410
    write32(fdes, (uint32_t )0);
#line 411
    write32(fdes, (uint32_t )0);
#line 412
    write32(fdes, (uint32_t )0);
#line 413
    write32(fdes, (uint32_t )colref);
    }
  }
#line 415
  return (recsize);
}
}
#line 418 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-emf.c"
static int WriteCreateSolidBrush(FILE *fdes , int hndNum , uint32_t colref ) 
{ 
  int recsize ;

  {
#line 420
  recsize = (int )(sizeof(uint32_t ) * 6UL);
#line 422
  if (fdes != (void *)0) {
    {
#line 423
    write32(fdes, (uint32_t )39);
#line 424
    write32(fdes, (uint32_t )recsize);
#line 425
    write32(fdes, (uint32_t )hndNum);
#line 426
    write32(fdes, (uint32_t )0);
#line 427
    write32(fdes, (uint32_t )colref);
#line 428
    write32(fdes, (uint32_t )0);
    }
  }
#line 430
  return (recsize);
}
}
#line 433 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-emf.c"
static int WriteSelectObject(FILE *fdes , int hndNum ) 
{ 
  int recsize ;

  {
#line 435
  recsize = (int )(sizeof(uint32_t ) * 3UL);
#line 437
  if (fdes != (void *)0) {
    {
#line 438
    write32(fdes, (uint32_t )37);
#line 439
    write32(fdes, (uint32_t )recsize);
#line 440
    write32(fdes, (uint32_t )hndNum);
    }
  }
#line 442
  return (recsize);
}
}
#line 446 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-emf.c"
static int WriteDeleteObject(FILE *fdes , int hndNum ) 
{ 
  int recsize ;

  {
#line 448
  recsize = (int )(sizeof(uint32_t ) * 3UL);
#line 450
  if (fdes != (void *)0) {
    {
#line 451
    write32(fdes, (uint32_t )40);
#line 452
    write32(fdes, (uint32_t )recsize);
#line 453
    write32(fdes, (uint32_t )hndNum);
    }
  }
#line 455
  return (recsize);
}
}
#line 458 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-emf.c"
static int WriteEndOfMetafile(FILE *fdes ) 
{ 
  int recsize ;

  {
#line 460
  recsize = (int )(sizeof(uint32_t ) * 5UL);
#line 462
  if (fdes != (void *)0) {
    {
#line 463
    write32(fdes, (uint32_t )14);
#line 464
    write32(fdes, (uint32_t )recsize);
#line 465
    write32(fdes, (uint32_t )0);
#line 466
    write32(fdes, (uint32_t )((unsigned long )((uint32_t )recsize) - sizeof(uint32_t )));
#line 467
    write32(fdes, (uint32_t )recsize);
    }
  }
#line 470
  return (recsize);
}
}
#line 473 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-emf.c"
static int WriteHeader(FILE *fdes , gchar *name , int width , int height , int fsize ,
                       int nrec , int nhand ) 
{ 
  int i ;
  int recsize ;
  size_t desclen ;
  char const   *editor ;
  char const   *__cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;

  {
  {
#line 477
  __cil_tmp12 = at_version(! 0);
#line 477
  editor = __cil_tmp12;
#line 479
  __cil_tmp14 = strlen((char const   *)name);
  }
  {
#line 479
  __cil_tmp13 = strlen(editor);
#line 479
  desclen = (__cil_tmp13 + __cil_tmp14) + 3UL;
#line 480
  recsize = (int )((sizeof(uint32_t ) * 25UL + desclen * 2UL) + (desclen * 2UL) % 4UL);
  }
#line 482
  if (fdes != (void *)0) {
    {
#line 483
    write32(fdes, (uint32_t )1);
#line 484
    write32(fdes, (uint32_t )recsize);
#line 486
    write32(fdes, (uint32_t )0);
#line 487
    write32(fdes, (uint32_t )0);
#line 488
    write32(fdes, (uint32_t )width);
#line 489
    write32(fdes, (uint32_t )height);
#line 491
    write32(fdes, (uint32_t )0);
#line 492
    write32(fdes, (uint32_t )0);
#line 493
    write32(fdes, (((uint32_t )width * 320U) * 100U) / 1280U);
#line 494
    write32(fdes, (((uint32_t )height * 240U) * 100U) / 1024U);
#line 496
    write32(fdes, (uint32_t )1179469088);
#line 498
    write32(fdes, (uint32_t )65536);
#line 500
    write32(fdes, (uint32_t )fsize);
#line 502
    write32(fdes, (uint32_t )nrec);
#line 504
    write16___0(fdes, (uint16_t )nhand);
#line 506
    write16___0(fdes, (uint16_t )0);
#line 508
    write32(fdes, (uint32_t )desclen);
#line 510
    write32(fdes, (uint32_t )100);
#line 512
    write32(fdes, (uint32_t )0);
#line 514
    write32(fdes, (uint32_t )1280);
#line 515
    write32(fdes, (uint32_t )1024);
#line 516
    write32(fdes, (uint32_t )320);
#line 517
    write32(fdes, (uint32_t )240);
#line 519
    write32(fdes, (uint32_t )0);
#line 520
    write32(fdes, (uint32_t )0);
#line 521
    write32(fdes, (uint32_t )0);
#line 523
    i = 0;
    }
    {
#line 523
    while (1) {
      while_continue: /* CIL Label */ ;
#line 523
      if (! *(editor + i)) {
#line 523
        goto while_break;
      }
      {
#line 524
      write16___0(fdes, (uint16_t )((int )*(editor + i) & 127));
      }
#line 523
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 526
    write16___0(fdes, (uint16_t )0);
#line 527
    i = 0;
    }
    {
#line 527
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 527
      if (! *(name + i)) {
#line 527
        goto while_break___0;
      }
      {
#line 528
      write16___0(fdes, (uint16_t )((int )*(name + i) & 127));
      }
#line 527
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 530
    write32(fdes, (uint32_t )0);
    }
#line 531
    if ((desclen * 2UL) % 4UL) {
      {
#line 532
      write16___0(fdes, (uint16_t )0);
      }
    }
  }
#line 534
  return (recsize);
}
}
#line 755 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-emf.c"
static void GetEmfStats(EMFStats *stats , gchar *name , at_spline_list_array_type shape ) 
{ 
  unsigned int this_list ;
  unsigned int this_spline ;
  int ncolors ;
  int ncolorchng ;
  int nrecords ;
  int filesize ;
  uint32_t last_color ;
  uint32_t curr_color ;
  spline_list_type curr_list ;
  spline_type curr_spline ;
  int last_degree ;
  int nlines ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  unsigned int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  unsigned int __cil_tmp39 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;

  {
#line 758
  ncolors = 0;
#line 759
  ncolorchng = 0;
#line 760
  nrecords = 0;
#line 761
  filesize = 0;
#line 762
  last_color = 4294967295U;
#line 769
  this_list = (unsigned int )0;
  {
#line 769
  while (1) {
    while_continue: /* CIL Label */ ;
#line 769
    if (! (this_list < shape.length)) {
#line 769
      goto while_break;
    }
#line 770
    curr_list = *(shape.data + this_list);
#line 771
    curr_color = (uint32_t )((((int )curr_list.color.r & 255) | (((int )curr_list.color.g & 255) << 8)) | (((int )curr_list.color.b & 255) << 16));
#line 772
    if (this_list == 0U) {
      _L: /* CIL Label */ 
      {
#line 773
      ncolorchng ++;
#line 774
      __cil_tmp17 = SearchColor(color_list, curr_color);
      }
#line 774
      if (! __cil_tmp17) {
        {
#line 775
        ncolors ++;
#line 776
        AddColor(& color_list, curr_color);
        }
      }
#line 778
      if (shape.centerline) {
        {
#line 779
        nrecords += 2;
#line 780
        __cil_tmp20 = WriteSelectObject((FILE *)((void *)0), 0);
        }
        {
#line 780
        __cil_tmp19 = WriteCreateSolidPen((FILE *)((void *)0), 0, (uint32_t )0);
        }
#line 780
        filesize += __cil_tmp19 + __cil_tmp20;
#line 781
        if (this_list != 0U) {
          {
#line 782
          nrecords ++;
#line 783
          __cil_tmp22 = WriteDeleteObject((FILE *)((void *)0), 0);
          }
#line 783
          filesize += __cil_tmp22;
        }
      } else {
        {
#line 786
        nrecords ++;
#line 787
        __cil_tmp24 = WriteSelectObject((FILE *)((void *)0), 0);
        }
#line 787
        filesize += __cil_tmp24;
      }
      {
#line 790
      nrecords += 2;
#line 791
      __cil_tmp26 = WriteSelectObject((FILE *)((void *)0), 0);
      }
      {
#line 791
      __cil_tmp25 = WriteCreateSolidBrush((FILE *)((void *)0), 0, (uint32_t )0);
      }
#line 791
      filesize += __cil_tmp25 + __cil_tmp26;
#line 792
      if (this_list != 0U) {
        {
#line 793
        nrecords ++;
#line 794
        __cil_tmp28 = WriteDeleteObject((FILE *)((void *)0), 0);
        }
#line 794
        filesize += __cil_tmp28;
      }
#line 797
      last_color = curr_color;
    } else
#line 772
    if (curr_color != last_color) {
#line 772
      goto _L;
    }
    {
#line 801
    nrecords ++;
#line 802
    __cil_tmp29 = WriteBeginPath((FILE *)((void *)0));
    }
    {
#line 802
    filesize += __cil_tmp29;
#line 804
    nrecords ++;
#line 805
    __cil_tmp31 = WriteMoveTo((FILE *)((void *)0), (at_real_coord *)((void *)0));
    }
#line 805
    filesize += __cil_tmp31;
#line 807
    this_spline = (unsigned int )0;
#line 808
    last_degree = - 1;
    {
#line 811
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 811
      if (! (this_spline < curr_list.length)) {
#line 811
        goto while_break___0;
      }
#line 812
      nlines = 0;
#line 813
      curr_spline = *(curr_list.data + this_spline);
#line 814
      last_degree = (int )curr_spline.degree;
      {
#line 818
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 818
        if (! (last_degree == (int )curr_spline.degree)) {
#line 818
          goto while_break___1;
        }
#line 819
        nlines ++;
#line 820
        this_spline ++;
#line 821
        if (this_spline >= curr_list.length) {
#line 822
          goto while_break___1;
        }
#line 823
        curr_spline = *(curr_list.data + this_spline);
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 826
      if ((unsigned int )((polynomial_degree )last_degree) == (unsigned int )1) {
#line 826
        goto case_1;
      }
#line 831
      goto switch_default;
      case_1: /* CIL Label */ 
#line 828
      nrecords += nlines;
      {
#line 829
      __cil_tmp34 = MyWritePolyLineTo((FILE *)((void *)0), (spline_type *)((void *)0),
                                      nlines);
      }
#line 829
      filesize += __cil_tmp34;
#line 830
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 833
      nrecords ++;
      {
#line 834
      __cil_tmp36 = WritePolyBezierTo16((FILE *)((void *)0), (spline_type *)((void *)0),
                                        nlines);
      }
#line 834
      filesize += __cil_tmp36;
#line 835
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 840
    nrecords += 2;
#line 841
    __cil_tmp38 = WriteFillPath((FILE *)((void *)0));
    }
    {
#line 841
    __cil_tmp37 = WriteEndPath((FILE *)((void *)0));
    }
#line 841
    filesize += __cil_tmp37 + __cil_tmp38;
#line 769
    this_list ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 846
  if (shape.centerline) {
    {
#line 847
    nrecords ++;
#line 848
    __cil_tmp41 = WriteDeleteObject((FILE *)((void *)0), 0);
    }
#line 848
    filesize += __cil_tmp41;
  }
  {
#line 851
  nrecords ++;
#line 852
  __cil_tmp43 = WriteDeleteObject((FILE *)((void *)0), 0);
  }
  {
#line 852
  filesize += __cil_tmp43;
#line 855
  nrecords += 2;
#line 856
  __cil_tmp45 = WriteHeader((FILE *)((void *)0), name, 0, 0, 0, 0, 0);
  }
  {
#line 856
  __cil_tmp44 = WriteEndOfMetafile((FILE *)((void *)0));
  }
  {
#line 856
  filesize += __cil_tmp44 + __cil_tmp45;
#line 859
  nrecords ++;
#line 860
  __cil_tmp47 = WriteSetPolyFillMode((FILE *)((void *)0));
  }
  {
#line 860
  filesize += __cil_tmp47;
#line 862
  stats->ncolors = ncolors;
#line 863
  stats->nrecords = nrecords;
#line 864
  stats->filesize = filesize;
#line 867
  ColorListToColorTable(& color_list, & color_table, ncolors);
  }
  return;
}
}
#line 872 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-emf.c"
static void OutputEmf(FILE *fdes , EMFStats *stats , gchar *name , int width , int height ,
                      at_spline_list_array_type shape ) 
{ 
  unsigned int this_list ;
  unsigned int this_spline ;
  int color_index ;
  int last_index ;
  uint32_t last_color ;
  uint32_t curr_color ;
  spline_list_type curr_list ;
  spline_type curr_spline ;
  int last_degree ;
  int nlines ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  unsigned int __cil_tmp19 ;
  unsigned int __cil_tmp20 ;

  {
  {
#line 876
  last_color = 4294967295U;
#line 883
  WriteHeader(fdes, name, width, height, stats->filesize, stats->nrecords, stats->ncolors * 2 + 1);
#line 885
  y_offset = (gfloat )1. * (float )height;
#line 888
  WriteSetPolyFillMode(fdes);
#line 891
  this_list = (unsigned int )0;
  }
  {
#line 891
  while (1) {
    while_continue: /* CIL Label */ ;
#line 891
    if (! (this_list < shape.length)) {
#line 891
      goto while_break;
    }
#line 892
    curr_list = *(shape.data + this_list);
#line 895
    curr_color = (uint32_t )((((int )curr_list.color.r & 255) | (((int )curr_list.color.g & 255) << 8)) | (((int )curr_list.color.b & 255) << 16));
#line 896
    if (this_list == 0U) {
      _L: /* CIL Label */ 
      {
#line 898
      color_index = ColorLookUp(curr_color, color_table, stats->ncolors);
      }
#line 899
      if (shape.centerline) {
        {
#line 900
        WriteCreateSolidPen(fdes, color_index * 2 + 1, *(color_table + color_index));
#line 901
        WriteSelectObject(fdes, color_index * 2 + 1);
        }
#line 902
        if (this_list != 0U) {
          {
#line 903
          WriteDeleteObject(fdes, last_index * 2 + 1);
          }
        }
      } else {
        {
#line 905
        WriteSelectObject(fdes, (int )2147483656U);
        }
      }
      {
#line 907
      WriteCreateSolidBrush(fdes, color_index * 2 + 2, *(color_table + color_index));
#line 908
      WriteSelectObject(fdes, color_index * 2 + 2);
      }
#line 909
      if (this_list != 0U) {
        {
#line 910
        WriteDeleteObject(fdes, last_index * 2 + 2);
        }
      }
#line 912
      last_color = curr_color;
#line 913
      last_index = color_index;
    } else
#line 896
    if (curr_color != last_color) {
#line 896
      goto _L;
    }
    {
#line 916
    WriteBeginPath(fdes);
#line 919
    curr_spline = *(curr_list.data + 0);
#line 920
    WriteMoveTo(fdes, & curr_spline.v[0]);
#line 923
    this_spline = (unsigned int )0;
    }
    {
#line 926
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 926
      if (! (this_spline < curr_list.length)) {
#line 926
        goto while_break___0;
      }
#line 927
      nlines = 0;
#line 928
      curr_spline = *(curr_list.data + this_spline);
#line 929
      last_degree = (int )curr_spline.degree;
      {
#line 933
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 933
        if (! (last_degree == (int )curr_spline.degree)) {
#line 933
          goto while_break___1;
        }
#line 934
        nlines ++;
#line 935
        this_spline ++;
#line 936
        if (this_spline >= curr_list.length) {
#line 937
          goto while_break___1;
        }
#line 938
        curr_spline = *(curr_list.data + this_spline);
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 941
      if ((unsigned int )((polynomial_degree )last_degree) == (unsigned int )1) {
#line 941
        goto case_1;
      }
#line 945
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 943
      MyWritePolyLineTo(fdes, curr_list.data + (this_spline - (unsigned int )nlines),
                        nlines);
      }
#line 944
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 947
      WritePolyBezierTo16(fdes, curr_list.data + (this_spline - (unsigned int )nlines),
                          nlines);
      }
#line 948
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 953
    WriteEndPath(fdes);
    }
#line 955
    if (shape.centerline) {
      {
      {
#line 957
      WriteStrokePath(fdes);
      }
      }
    } else
#line 955
    if (curr_list.open) {
      {
      {
#line 957
      WriteStrokePath(fdes);
      }
      }
    } else {
      {
#line 960
      WriteFillPath(fdes);
      }
    }
#line 891
    this_list ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 965
  if (shape.centerline) {
    {
#line 966
    WriteDeleteObject(fdes, last_index * 2 + 1);
    }
  }
  {
#line 967
  WriteDeleteObject(fdes, last_index * 2 + 2);
#line 970
  WriteEndOfMetafile(fdes);
#line 973
  free((void *)color_table);
  }
  return;
}
}
#line 976 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-emf.c"
int output_emf_writer(FILE *file , gchar *name , int llx , int lly , int urx , int ury ,
                      at_output_opts_type *opts , at_spline_list_array_type shape ,
                      at_msg_func msg_func , gpointer msg_data , gpointer user_data ) 
{ 
  EMFStats stats ;

  {
  {
#line 988
  GetEmfStats(& stats, name, shape);
#line 991
  OutputEmf(file, & stats, name, urx, ury, shape);
  }
#line 993
  return (0);
}
}
#line 81 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-p2e.c"
static int output_p2e_header(FILE *ps_file , gchar *name , int llx , int lly , int urx ,
                             int ury , at_spline_list_array_type shape ) 
{ 
  unsigned int this_list ;
  unsigned int with_curves ;
  unsigned int this_spline ;
  spline_list_type list ;
  spline_type s ;
  unsigned int __cil_tmp13 ;
  unsigned int __cil_tmp14 ;

  {
#line 83
  with_curves = (unsigned int )1;
#line 85
  this_list = (unsigned int )0;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! (this_list < shape.length)) {
#line 85
      goto while_break;
    }
#line 88
    list = *(shape.data + this_list);
#line 90
    this_spline = (unsigned int )0;
    {
#line 90
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 90
      if (! (this_spline < list.length)) {
#line 90
        goto while_break___0;
      }
#line 91
      s = *(list.data + this_spline);
#line 93
      if ((unsigned int )s.degree != 1U) {
#line 94
        with_curves = (unsigned int )0;
#line 95
        this_list = shape.length;
#line 96
        goto while_break___0;
      }
#line 90
      this_spline ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 85
    this_list ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 102
  fprintf(ps_file, "%s\n", "%!PS-Adobe-3.0");
#line 103
  fprintf(ps_file, "%%%%Title: flattened PostScript generated by autotrace: %s\n",
          name);
#line 104
  fprintf(ps_file, "%s\n", "%%Creator: pstoedit");
#line 105
  fprintf(ps_file, "%s\n", "%%BoundingBox: (atend)");
#line 106
  fprintf(ps_file, "%s\n", "%%Pages: (atend)\220");
#line 107
  fprintf(ps_file, "%s\n", "%%EndComments");
#line 108
  fprintf(ps_file, "%s\n", "%%BeginProlog");
#line 109
  fprintf(ps_file, "%s\n", "/setPageSize { pop pop } def");
#line 110
  fprintf(ps_file, "%s\n", "/ntranslate { neg exch neg exch translate } def");
#line 111
  fprintf(ps_file, "%s\n", "/setshowparams { pop pop pop} def");
#line 112
  fprintf(ps_file, "%s\n", "/awidthshowhex { dup /ASCIIHexDecode filter exch length 2 div cvi string readstring pop awidthshow } def\220");
#line 113
  fprintf(ps_file, "%s\n", "/backendconstraints { pop pop } def");
#line 114
  fprintf(ps_file, "%s\n", "/pstoedit.newfont { 80 string cvs  findfont  dup length dict begin {1 index /FID ne {def} {pop pop} ifelse} forall  /Encoding ISOLatin1Encoding def   dup 80 string cvs /FontName exch def  currentdict end  definefont pop } def");
#line 115
  fprintf(ps_file, "%s\n", "/imagestring 1 string def");
#line 116
  fprintf(ps_file, "%s\n", "%%EndProlog");
#line 117
  fprintf(ps_file, "%s\n", "%%BeginSetup");
#line 118
  fprintf(ps_file, "%s\n", "% textastext doflatten backendconstraints  ");
#line 119
  fprintf(ps_file, "%d 0 backendconstraints\n\230\001", with_curves);
#line 120
  fprintf(ps_file, "%s\n", "%%EndSetup");
  }
#line 122
  return (0);
}
}
#line 128 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-p2e.c"
static void out_splines___3(FILE *ps_file , at_spline_list_array_type shape ) 
{ 
  unsigned int this_list ;
  unsigned int pathnr ;
  spline_list_type list ;
  at_color last_color ;
  unsigned int this_spline ;
  spline_type first ;
  gboolean __cil_tmp9 ;
  int c ;
  int m ;
  int y ;
  int k ;
  char const   *tmp ;
  char const   *tmp___0 ;
  unsigned int __cil_tmp16 ;
  long __cil_tmp17 ;
  char const   *tmp___1 ;
  long __cil_tmp19 ;
  char const   *tmp___2 ;
  spline_type s ;
  long __cil_tmp22 ;
  char const   *tmp___3 ;
  long __cil_tmp24 ;
  char const   *tmp___4 ;
  long __cil_tmp26 ;
  char const   *tmp___5 ;
  long __cil_tmp28 ;
  char const   *tmp___6 ;
  long __cil_tmp30 ;
  char const   *tmp___7 ;
  long __cil_tmp32 ;
  char const   *tmp___8 ;
  long __cil_tmp34 ;
  char const   *tmp___9 ;
  long __cil_tmp36 ;
  char const   *tmp___10 ;
  unsigned int __cil_tmp38 ;
  unsigned int __cil_tmp39 ;
  char const   *tmp___11 ;

  {
#line 131
  pathnr = (unsigned int )1;
#line 133
  last_color.r = (guint8 )0;
#line 133
  last_color.g = (guint8 )0;
  {
#line 133
  last_color.b = (guint8 )0;
#line 135
  fprintf(ps_file, "%s\n", " 612 792 setPageSize");
#line 136
  fprintf(ps_file, "%s\n", " 0 setlinecap");
#line 137
  fprintf(ps_file, "%s\n", " 10.0 setmiterlimit");
#line 138
  fprintf(ps_file, "%s\n", " 0 setlinejoin");
#line 139
  fprintf(ps_file, "%s\n", " [ ] 0.0 setdash\220");
#line 140
  fprintf(ps_file, "%s\n", " 1.0 setlinewidth");
#line 142
  this_list = (unsigned int )0;
  }
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 142
    if (! (this_list < shape.length)) {
#line 142
      goto while_break;
    }
    {
#line 146
    list = *(shape.data + this_list);
#line 147
    first = *(list.data + 0);
#line 149
    __cil_tmp9 = at_color_equal(& list.color, & last_color);
    }
#line 149
    if (this_list == 0U) {
      _L: /* CIL Label */ 
#line 152
      if (shape.centerline || list.open) {
#line 152
        tmp = "stroke";
      } else {
#line 152
        tmp = "fill";
      }
      {
#line 152
      fprintf(ps_file, "%s\n", tmp);
#line 153
      fprintf(ps_file, "\n\n%% %d pathnumber\n", pathnr);
      }
#line 154
      if (shape.centerline || list.open) {
#line 154
        tmp___0 = "% strokedpath";
      } else {
#line 154
        tmp___0 = "% filledpath";
      }
      {
#line 154
      fprintf(ps_file, "%s\n", tmp___0);
#line 155
      pathnr ++;
#line 160
      k = 255 - (int )list.color.r;
#line 160
      c = k;
#line 161
      m = 255 - (int )list.color.g;
      }
#line 162
      if (m < k) {
#line 163
        k = m;
      }
#line 164
      y = 255 - (int )list.color.b;
#line 165
      if (y < k) {
#line 166
        k = y;
      }
      {
#line 167
      c -= k;
#line 168
      m -= k;
#line 169
      y -= k;
#line 170
      fprintf(ps_file, "%.3f %.3f %.3f %.3f %s\n", (double )c / 255., (double )m / 255.,
              (double )y / 255., (double )k / 255., "setcmykcolor\027V");
#line 172
      last_color = list.color;
      }
    } else
#line 149
    if (! __cil_tmp9) {
#line 149
      goto _L;
    }
    {
#line 175
    fprintf(ps_file, "%s\n\r\027V", "newpath");
    }
    {
#line 176
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 176
      fprintf(ps_file, " E\317\r\027V");
#line 176
      __cil_tmp17 = lround((double )first.v[0].x);
      }
#line 176
      if (first.v[0].x == (float )__cil_tmp17) {
#line 176
        tmp___1 = "%.0f ";
      } else {
#line 176
        tmp___1 = "%.3f ";
      }
      {
#line 176
      fprintf(ps_file, tmp___1, (double )first.v[0].x);
#line 176
      __cil_tmp19 = lround((double )first.v[0].y);
      }
#line 176
      if (first.v[0].y == (float )__cil_tmp19) {
#line 176
        tmp___2 = "%.0f V";
      } else {
#line 176
        tmp___2 = "%.3f ";
      }
      {
#line 176
      fprintf(ps_file, tmp___2, (double )first.v[0].y);
#line 176
      fprintf(ps_file, "moveto\n\r\027V");
      }
#line 176
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 178
    this_spline = (unsigned int )0;
    {
#line 178
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 178
      if (! (this_spline < list.length)) {
#line 178
        goto while_break___1;
      }
#line 179
      s = *(list.data + this_spline);
#line 181
      if ((unsigned int )s.degree == 1U) {
        {
#line 182
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 182
          fprintf(ps_file, " ");
#line 182
          __cil_tmp22 = lround((double )s.v[3].x);
          }
#line 182
          if (s.v[3].x == (float )__cil_tmp22) {
#line 182
            tmp___3 = "%.0f ";
          } else {
#line 182
            tmp___3 = "%.3f ";
          }
          {
#line 182
          fprintf(ps_file, tmp___3, (double )s.v[3].x);
#line 182
          __cil_tmp24 = lround((double )s.v[3].y);
          }
#line 182
          if (s.v[3].y == (float )__cil_tmp24) {
#line 182
            tmp___4 = "%.0f ";
          } else {
#line 182
            tmp___4 = "%.3f ";
          }
          {
#line 182
          fprintf(ps_file, tmp___4, (double )s.v[3].y);
#line 182
          fprintf(ps_file, "lineto\n");
          }
#line 182
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
      } else {
        {
#line 184
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 184
          fprintf(ps_file, " ");
#line 184
          __cil_tmp26 = lround((double )s.v[1].x);
          }
#line 184
          if (s.v[1].x == (float )__cil_tmp26) {
#line 184
            tmp___5 = "%.0f ";
          } else {
#line 184
            tmp___5 = "%.3f ";
          }
          {
#line 184
          fprintf(ps_file, tmp___5, (double )s.v[1].x);
#line 184
          __cil_tmp28 = lround((double )s.v[1].y);
          }
#line 184
          if (s.v[1].y == (float )__cil_tmp28) {
#line 184
            tmp___6 = "%.0f ";
          } else {
#line 184
            tmp___6 = "%.3f ";
          }
          {
#line 184
          fprintf(ps_file, tmp___6, (double )s.v[1].y);
#line 184
          fprintf(ps_file, " ");
#line 184
          __cil_tmp30 = lround((double )s.v[2].x);
          }
#line 184
          if (s.v[2].x == (float )__cil_tmp30) {
#line 184
            tmp___7 = "%.0f ";
          } else {
#line 184
            tmp___7 = "%.3f ";
          }
          {
#line 184
          fprintf(ps_file, tmp___7, (double )s.v[2].x);
#line 184
          __cil_tmp32 = lround((double )s.v[2].y);
          }
#line 184
          if (s.v[2].y == (float )__cil_tmp32) {
#line 184
            tmp___8 = "%.0f ";
          } else {
#line 184
            tmp___8 = "%.3f ";
          }
          {
#line 184
          fprintf(ps_file, tmp___8, (double )s.v[2].y);
#line 184
          fprintf(ps_file, " ");
#line 184
          __cil_tmp34 = lround((double )s.v[3].x);
          }
#line 184
          if (s.v[3].x == (float )__cil_tmp34) {
#line 184
            tmp___9 = "%.0f ";
          } else {
#line 184
            tmp___9 = "%.3f ";
          }
          {
#line 184
          fprintf(ps_file, tmp___9, (double )s.v[3].x);
#line 184
          __cil_tmp36 = lround((double )s.v[3].y);
          }
#line 184
          if (s.v[3].y == (float )__cil_tmp36) {
#line 184
            tmp___10 = "%.0f ";
          } else {
#line 184
            tmp___10 = "%.3f ";
          }
          {
#line 184
          fprintf(ps_file, tmp___10, (double )s.v[3].y);
#line 184
          fprintf(ps_file, " curveto\n");
          }
#line 184
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 178
      this_spline ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 186
    if (! list.open) {
      {
#line 187
      fprintf(ps_file, "%s\n", "closepath");
      }
    }
#line 142
    this_list ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 189
  if (shape.length > 0U) {
#line 190
    if (shape.centerline || list.open) {
#line 190
      tmp___11 = "stroke";
    } else {
#line 190
      tmp___11 = "fill";
    }
    {
#line 190
    fprintf(ps_file, "%s\n", tmp___11);
    }
  }
  return;
}
}
#line 193 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-p2e.c"
int output_p2e_writer(FILE *ps_file , gchar *name , int llx , int lly , int urx ,
                      int ury , at_output_opts_type *opts , at_spline_list_array_type shape ,
                      at_msg_func msg_func , gpointer msg_data , gpointer user_data ) 
{ 
  int result ;
  int __cil_tmp13 ;

  {
  {
#line 197
  result = output_p2e_header(ps_file, name, llx, lly, urx, ury, shape);
  }
#line 198
  if (result != 0) {
#line 199
    return (result);
  }
  {
#line 201
  out_splines___3(ps_file, shape);
#line 203
  fprintf(ps_file, "%s\n", "showpage\220");
#line 204
  fprintf(ps_file, "%%%%BoundingBox: %d %d %d %d\n", llx, lly, urx, ury);
#line 205
  fprintf(ps_file, "%s\n", "%%Page: 1 1");
#line 206
  fprintf(ps_file, "%s\n", "% normal end reached by pstoedit.pro");
#line 207
  fprintf(ps_file, "%s\n", "%%Trailer");
#line 208
  fprintf(ps_file, "%s\n", "%%Pages: 1");
#line 209
  fprintf(ps_file, "%s\n", "%%EOF");
  }
#line 211
  return (0);
}
}
#line 808 "/usr/include/glib-2.0/gobject/gobject.h"
__inline static void g_assert_finalize_object___26(GObject *object ) 
{ 
  gpointer weak_pointer ;
  long __cil_tmp3 ;
  long __cil_tmp4 ;

  {
#line 810
  weak_pointer = object;
  {
#line 812
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 812
    __cil_tmp3 = __builtin_expect((long )0, (long )1);
    }
#line 812
    if (__cil_tmp3) {

    } else {
      {
#line 812
      g_assertion_message((char const   *)((gchar *)0), "/usr/include/glib-2.0/gobject/gobject.h",
                          812, (char const   *)"g_assert_finalize_object\312\001@",
                          "\'G_IS_OBJECT (weak_pointer)\' should be TRUE");
      }
    }
#line 812
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 813
  g_object_add_weak_pointer(object, & weak_pointer);
#line 814
  g_object_unref(weak_pointer);
  }
  {
#line 815
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 815
    __cil_tmp4 = __builtin_expect((long )0, (long )1);
    }
#line 815
    if (__cil_tmp4) {

    } else {
      {
#line 815
      g_assertion_message((char const   *)((gchar *)0), "/usr/include/glib-2.0/gobject/gobject.h",
                          815, (char const   *)"g_assert_finalize_object\312\001@\016\312\256\b",
                          "\'weak_pointer\' should be NULLV");
      }
    }
#line 815
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 37 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-ugs.c"
static long lowerx ;
#line 37
static long upperx ;
#line 37
static long lowery ;
#line 37
static long uppery ;
#line 39 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-ugs.c"
static int compute_determinant(double *det , double a , double b , double c , double d ) 
{ 
  double lensq ;

  {
#line 43
  *det = a * d - b * c;
#line 44
  lensq = (a * a + b * b) * (c * c + d * d);
#line 45
  if (lensq < (double )1) {
#line 46
    return (0);
  } else
#line 45
  if ((*det * *det) * (double )4000000 < lensq) {
#line 46
    return (0);
  }
#line 47
  return (1);
}
}
#line 50 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-ugs.c"
static void cubic_to_quadratic(double ax , double ay , double bx , double by , double cx ,
                               double cy , double dx , double dy , double *fx , double *fy ,
                               double *ex , double *ey , double *gx , double *gy ) 
{ 
  double t ;
  double t1 ;
  double det ;
  double tanx ;
  double tany ;
  double s ;
  double tw1 ;
  double tw2 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;

  {
#line 55
  tw1 = (- ax + (double )2 * bx) - cx;
#line 56
  tw2 = ((- ax + (double )3 * bx) - (double )3 * cx) + dx;
#line 57
  if (tw2 < (double )0) {
#line 58
    tw1 = - tw1;
#line 59
    tw2 = - tw2;
  }
#line 61
  if (tw1 > 0.00100000000001) {
#line 61
    if (tw1 < tw2) {
#line 62
      t = tw1 / tw2;
    } else {
#line 61
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 64
    tw1 = (- ay + (double )2 * by) - cy;
#line 65
    tw2 = ((- ay + (double )3 * by) - (double )3 * cy) + dy;
#line 66
    if (tw2 < (double )0) {
#line 67
      tw1 = - tw1;
#line 68
      tw2 = - tw2;
    }
#line 70
    if (tw1 > 0.00100000000001) {
#line 70
      if (tw1 < tw2) {
#line 71
        t = tw1 / tw2;
      } else {
#line 73
        t = 0.5;
      }
    } else {
#line 73
      t = 0.5;
    }
  }
  {
#line 75
  t1 = (double )1 - t;
#line 78
  *ex = ((((ax * t1) * t1) * t1 + ((((double )3 * bx) * t) * t1) * t1) + ((((double )3 * cx) * t) * t) * t1) + ((dx * t) * t) * t;
#line 79
  *ey = ((((ay * t1) * t1) * t1 + ((((double )3 * by) * t) * t1) * t1) + ((((double )3 * cy) * t) * t) * t1) + ((dy * t) * t) * t;
#line 82
  tanx = (double )3 * ((((- ax * t1) * t1 + (bx * t1) * ((double )1 - (double )3 * t)) + (cx * t) * ((double )2 - (double )3 * t)) + (dx * t) * t);
#line 83
  tany = (double )3 * ((((- ay * t1) * t1 + (by * t1) * ((double )1 - (double )3 * t)) + (cy * t) * ((double )2 - (double )3 * t)) + (dy * t) * t);
#line 88
  __cil_tmp23 = compute_determinant(& det, bx - ax, by - ay, tanx, tany);
  }
#line 88
  if (__cil_tmp23) {
    {
#line 89
    compute_determinant(& s, *ex - ax, *ey - ay, tanx, tany);
#line 90
    s /= det;
    }
#line 91
    if (s < (double )0) {
#line 92
      s = (double )0;
    }
#line 94
    *fx = bx * s + ax * ((double )1 - s);
#line 95
    *fy = by * s + ay * ((double )1 - s);
  } else {
#line 98
    *fx = *ex;
#line 99
    *fy = *ey;
  }
  {
#line 105
  __cil_tmp24 = compute_determinant(& det, cx - dx, cy - dy, - tanx, - tany);
  }
#line 105
  if (__cil_tmp24) {
    {
#line 106
    compute_determinant(& s, *ex - dx, *ey - dy, - tanx, - tany);
#line 107
    s /= det;
    }
#line 108
    if (s < (double )0) {
#line 109
      s = (double )0;
    }
#line 111
    *gx = cx * s + dx * ((double )1 - s);
#line 112
    *gy = cy * s + dy * ((double )1 - s);
  } else {
#line 115
    *gx = *ex;
#line 116
    *gy = *ey;
  }
  return;
}
}
#line 161 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-ugs.c"
static void output_splines(FILE *file , at_spline_list_array_type shape , int height ) 
{ 
  unsigned int l ;
  unsigned int s ;
  spline_list_type list ;
  spline_type first ;
  spline_type t ;
  double x1 ;
  double y1___54 ;
  double x1a ;
  double y1a ;
  double x2 ;
  double y2 ;
  double x3a ;
  double y3a ;
  double x3 ;
  double y3 ;
  int ix1 ;
  int iy1 ;
  int ix1a ;
  int iy1a ;
  int ix2 ;
  int iy2 ;
  int ix3a ;
  int iy3a ;
  int ix3 ;
  int iy3 ;
  long __cil_tmp29 ;
  long __cil_tmp30 ;
  long __cil_tmp31 ;
  long __cil_tmp32 ;
  long __cil_tmp33 ;
  long __cil_tmp34 ;
  long __cil_tmp35 ;
  long __cil_tmp36 ;
  long __cil_tmp37 ;
  long __cil_tmp38 ;
  long __cil_tmp39 ;
  long __cil_tmp40 ;
  long __cil_tmp41 ;
  long __cil_tmp42 ;
  long __cil_tmp43 ;
  long __cil_tmp44 ;
  unsigned int __cil_tmp45 ;
  unsigned int __cil_tmp46 ;

  {
  {
#line 169
  fprintf(file, "\tcontour\n");
#line 170
  l = (unsigned int )0;
  }
  {
#line 170
  while (1) {
    while_continue: /* CIL Label */ ;
#line 170
    if (! (l < shape.length)) {
#line 170
      goto while_break;
    }
    {
#line 171
    list = *(shape.data + l);
#line 172
    first = *(list.data + 0);
#line 174
    x1 = (double )(first.v[0].x + (float )ugs_left_bearing);
#line 175
    y1___54 = (double )(first.v[0].y + (float )ugs_descend);
#line 176
    __cil_tmp29 = lround(x1);
#line 176
    ix1 = (int )__cil_tmp29;
#line 177
    __cil_tmp30 = lround(y1___54);
#line 177
    iy1 = (int )__cil_tmp30;
#line 179
    fprintf(file, "\t\tpath\n");
#line 180
    fprintf(file, "\t\t\tdot-on %d %d\n\230\001", ix1, iy1);
    }
#line 182
    if (lowerx > (long )ix1) {
#line 183
      lowerx = (long )ix1;
    }
#line 184
    if (lowery > (long )iy1) {
#line 185
      lowery = (long )iy1;
    }
#line 186
    if (upperx < (long )ix1) {
#line 187
      upperx = (long )ix1;
    }
#line 188
    if (uppery < (long )iy1) {
#line 189
      uppery = (long )iy1;
    }
#line 191
    s = (unsigned int )0;
    {
#line 191
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 191
      if (! (s < list.length)) {
#line 191
        goto while_break___0;
      }
#line 192
      t = *(list.data + s);
#line 194
      if ((unsigned int )t.degree == 1U) {
        {
#line 195
        x3 = (double )(t.v[3].x + (float )ugs_left_bearing);
#line 196
        y3 = (double )(t.v[3].y + (float )ugs_descend);
#line 197
        __cil_tmp31 = lround(x3);
#line 197
        ix3 = (int )__cil_tmp31;
#line 198
        __cil_tmp32 = lround(y3);
#line 198
        iy3 = (int )__cil_tmp32;
#line 200
        __cil_tmp34 = lround(y1___54);
        }
        {
#line 200
        __cil_tmp33 = lround(x1);
        }
#line 200
        if (! ((long )ix3 == __cil_tmp33 && (long )iy3 == __cil_tmp34)) {
          {
#line 201
          fprintf(file, "\t\t\tdot-on %d %d\n\230\001", ix3, iy3);
          }
        }
#line 203
        if (lowerx > (long )ix3) {
#line 204
          lowerx = (long )ix3;
        }
#line 205
        if (lowery > (long )iy3) {
#line 206
          lowery = (long )iy3;
        }
#line 207
        if (upperx < (long )ix3) {
#line 208
          upperx = (long )ix3;
        }
#line 209
        if (uppery < (long )iy3) {
#line 210
          uppery = (long )iy3;
        }
      } else {
        {
#line 212
        x1a = (double )(t.v[1].x + (float )ugs_left_bearing);
#line 213
        y1a = (double )(t.v[1].y + (float )ugs_descend);
#line 214
        x3a = (double )(t.v[2].x + (float )ugs_left_bearing);
#line 215
        y3a = (double )(t.v[2].y + (float )ugs_descend);
#line 216
        x3 = (double )(t.v[3].x + (float )ugs_left_bearing);
#line 217
        y3 = (double )(t.v[3].y + (float )ugs_descend);
#line 218
        __cil_tmp35 = lround(x3);
#line 218
        ix3 = (int )__cil_tmp35;
#line 219
        __cil_tmp36 = lround(y3);
#line 219
        iy3 = (int )__cil_tmp36;
#line 221
        cubic_to_quadratic(x1, y1___54, x1a, y1a, x3a, y3a, x3, y3, & x1a, & y1a,
                           & x2, & y2, & x3a, & y3a);
#line 222
        __cil_tmp37 = lround(x1a);
#line 222
        ix1a = (int )__cil_tmp37;
#line 223
        __cil_tmp38 = lround(y1a);
#line 223
        iy1a = (int )__cil_tmp38;
#line 224
        __cil_tmp39 = lround(x2);
#line 224
        ix2 = (int )__cil_tmp39;
#line 225
        __cil_tmp40 = lround(y2);
#line 225
        iy2 = (int )__cil_tmp40;
#line 226
        __cil_tmp41 = lround(x3a);
#line 226
        ix3a = (int )__cil_tmp41;
#line 227
        __cil_tmp42 = lround(y3a);
#line 227
        iy3a = (int )__cil_tmp42;
#line 229
        __cil_tmp44 = lround(y1___54);
        }
        {
#line 229
        __cil_tmp43 = lround(x1);
        }
#line 229
        if (! ((long )ix1a == __cil_tmp43 && (long )iy1a == __cil_tmp44)) {
#line 229
          if (! (ix1a == ix2 && iy1a == iy2)) {
            {
#line 230
            fprintf(file, "\t\t\tdot-off %d %d\n", ix1a, iy1a);
            }
          }
        }
        {
#line 232
        fprintf(file, "\t\t\tdot-on %d %d\n\230\001", ix2, iy2);
        }
#line 234
        if (! (ix3a == ix2 && iy3a == iy2)) {
#line 234
          if (! (ix3a == ix3 && iy3a == iy3)) {
            {
#line 235
            fprintf(file, "\t\t\tdot-off %d %d\n", ix3a, iy3a);
            }
          }
        }
        {
#line 237
        fprintf(file, "\t\t\tdot-on %d %d\n\230\001", ix3, iy3);
        }
#line 239
        if (lowerx > (long )ix1a) {
#line 240
          lowerx = (long )ix1a;
        }
#line 241
        if (lowery > (long )iy1a) {
#line 242
          lowery = (long )iy1a;
        }
#line 243
        if (upperx < (long )ix1a) {
#line 244
          upperx = (long )ix1a;
        }
#line 245
        if (uppery < (long )iy1a) {
#line 246
          uppery = (long )iy1a;
        }
#line 248
        if (lowerx > (long )ix2) {
#line 249
          lowerx = (long )ix2;
        }
#line 250
        if (lowery > (long )iy2) {
#line 251
          lowery = (long )iy2;
        }
#line 252
        if (upperx < (long )ix2) {
#line 253
          upperx = (long )ix2;
        }
#line 254
        if (uppery < (long )iy2) {
#line 255
          uppery = (long )iy2;
        }
#line 257
        if (lowerx > (long )ix3a) {
#line 258
          lowerx = (long )ix3a;
        }
#line 259
        if (lowery > (long )iy3a) {
#line 260
          lowery = (long )iy3a;
        }
#line 261
        if (upperx < (long )ix3a) {
#line 262
          upperx = (long )ix3a;
        }
#line 263
        if (uppery < (long )iy3a) {
#line 264
          uppery = (long )iy3a;
        }
#line 266
        if (lowerx > (long )ix3) {
#line 267
          lowerx = (long )ix3;
        }
#line 268
        if (lowery > (long )iy3) {
#line 269
          lowery = (long )iy3;
        }
#line 270
        if (upperx < (long )ix3) {
#line 271
          upperx = (long )ix3;
        }
#line 272
        if (uppery < (long )iy3) {
#line 273
          uppery = (long )iy3;
        }
      }
#line 275
      x1 = x3;
#line 276
      y1___54 = y3;
#line 191
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 278
    fprintf(file, "\t\tend path\n");
    }
#line 170
    l ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 280
  fprintf(file, "\tend contour\n");
  }
  return;
}
}
#line 283 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-ugs.c"
int output_ugs_writer(FILE *file , gchar *name , int llx , int lly , int urx , int ury ,
                      at_output_opts_type *opts , at_spline_list_array_type shape ,
                      at_msg_func msg_func , gpointer msg_data , gpointer usar_data ) 
{ 


  {
  {
#line 286
  fprintf(file, "symbol %#lx design-size %ld\n", ugs_charcode, ugs_design_pixels);
#line 287
  fprintf(file, "\tadvance-width %ld\n", ugs_advance_width);
#line 289
  upperx = (ugs_advance_width - ugs_max_col) - 1L;
#line 290
  uppery = ugs_max_row;
#line 292
  lowerx = ugs_left_bearing;
#line 293
  lowery = ugs_descend;
#line 295
  output_splines(file, shape, ury - lly);
#line 297
  fprintf(file, "\tleft-bearing %ld\n", lowerx);
#line 298
  fprintf(file, "\tright-bearing %ld\n", (ugs_advance_width - upperx) - 1L);
#line 299
  fprintf(file, "\tascend %ld\n", uppery + 1L);
#line 300
  fprintf(file, "\tdescend %ld\n", lowery);
#line 303
  fputs("end symbol\n\n", file);
  }
#line 304
  return (0);
}
}
#line 28 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-svg.c"
static void out_splines___4(FILE *file , at_spline_list_array_type shape , int height ) 
{ 
  unsigned int this_list ;
  spline_list_type list ;
  at_color last_color ;
  unsigned int this_spline ;
  spline_type first ;
  gboolean __cil_tmp9 ;
  char const   *tmp ;
  char const   *tmp___0 ;
  spline_type s ;
  unsigned int __cil_tmp13 ;
  unsigned int __cil_tmp14 ;

  {
#line 32
  last_color.r = (guint8 )0;
#line 32
  last_color.g = (guint8 )0;
#line 32
  last_color.b = (guint8 )0;
#line 34
  this_list = (unsigned int )0;
  {
#line 34
  while (1) {
    while_continue: /* CIL Label */ ;
#line 34
    if (! (this_list < shape.length)) {
#line 34
      goto while_break;
    }
    {
#line 38
    list = *(shape.data + this_list);
#line 39
    first = *(list.data + 0);
#line 41
    __cil_tmp9 = at_color_equal(& list.color, & last_color);
    }
#line 41
    if (this_list == 0U) {
      _L: /* CIL Label */ 
#line 42
      if (this_list > 0U) {
#line 43
        if (! (shape.centerline || list.open)) {
          {
#line 44
          fputs("z", file);
          }
        }
        {
#line 45
        fputs("\"/>\n", file);
        }
      }
#line 47
      if (shape.centerline || list.open) {
#line 47
        tmp = "stroke";
      } else {
#line 47
        tmp = "fill";
      }
#line 47
      if (shape.centerline || list.open) {
#line 47
        tmp___0 = "fill";
      } else {
#line 47
        tmp___0 = "stroke";
      }
      {
#line 47
      fprintf(file, "<path style=\"%s:#%02x%02x%02x; %s:none;\" d=\"", tmp, (int )list.color.r,
              (int )list.color.g, (int )list.color.b, tmp___0);
      }
    } else
#line 41
    if (! __cil_tmp9) {
#line 41
      goto _L;
    }
    {
#line 49
    fprintf(file, "M%g %g", (double )first.v[0].x, (double )((float )height - first.v[0].y));
#line 50
    this_spline = (unsigned int )0;
    }
    {
#line 50
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 50
      if (! (this_spline < list.length)) {
#line 50
        goto while_break___0;
      }
#line 51
      s = *(list.data + this_spline);
#line 53
      if ((unsigned int )s.degree == 1U) {
        {
#line 54
        fprintf(file, "L%g %g", (double )s.v[3].x, (double )((float )height - s.v[3].y));
        }
      } else {
        {
#line 56
        fprintf(file, "C%g %g %g %g %g %g", (double )s.v[1].x, (double )((float )height - s.v[1].y),
                (double )s.v[2].x, (double )((float )height - s.v[2].y), (double )s.v[3].x,
                (double )((float )height - s.v[3].y));
        }
      }
#line 58
      last_color = list.color;
#line 50
      this_spline ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 34
    this_list ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 61
  if (! (shape.centerline || list.open)) {
    {
#line 62
    fputs("z", file);
    }
  }
#line 63
  if (shape.length > 0U) {
    {
#line 64
    fputs("\"/>\n", file);
    }
  }
  return;
}
}
#line 67 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-svg.c"
int output_svg_writer(FILE *file , gchar *name , int llx , int lly , int urx , int ury ,
                      at_output_opts_type *opts , at_spline_list_array_type shape ,
                      at_msg_func msg_func , gpointer msg_data , gpointer user_data ) 
{ 
  int width ;
  int height ;

  {
  {
#line 69
  width = urx - llx;
#line 70
  height = ury - lly;
#line 71
  fputs("<?xml version=\"1.0\" standalone=\"yes\"?>\n", file);
#line 72
  fprintf(file, "<svg width=\"%d\" height=\"%d\">\n", width, height);
#line 74
  out_splines___4(file, shape, height);
#line 75
  fputs("</svg>\n", file);
  }
#line 77
  return (0);
}
}
#line 808 "/usr/include/glib-2.0/gobject/gobject.h"
__inline static void g_assert_finalize_object___28(GObject *object ) 
{ 
  gpointer weak_pointer ;
  long __cil_tmp3 ;
  long __cil_tmp4 ;

  {
#line 810
  weak_pointer = object;
  {
#line 812
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 812
    __cil_tmp3 = __builtin_expect((long )0, (long )1);
    }
#line 812
    if (__cil_tmp3) {

    } else {
      {
#line 812
      g_assertion_message((char const   *)((gchar *)0), "/usr/include/glib-2.0/gobject/gobject.h",
                          812, (char const   *)"g_assert_finalize_object\312\001@",
                          "\'G_IS_OBJECT (weak_pointer)\' should be TRUE");
      }
    }
#line 812
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 813
  g_object_add_weak_pointer(object, & weak_pointer);
#line 814
  g_object_unref(weak_pointer);
  }
  {
#line 815
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 815
    __cil_tmp4 = __builtin_expect((long )0, (long )1);
    }
#line 815
    if (__cil_tmp4) {

    } else {
      {
#line 815
      g_assertion_message((char const   *)((gchar *)0), "/usr/include/glib-2.0/gobject/gobject.h",
                          815, (char const   *)"g_assert_finalize_object\312\001\300\016\306\256\b",
                          "\'weak_pointer\' should be NULLV");
      }
    }
#line 815
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 27 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-sk.c"
static void out_splines___5(FILE *file , at_spline_list_array_type shape ) 
{ 
  unsigned int this_list ;
  spline_list_type list ;
  unsigned int this_spline ;
  spline_type first ;
  gboolean stroke ;
  char const   *tmp ;
  char const   *tmp___0 ;
  spline_type s ;
  unsigned int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;

  {
#line 32
  this_list = (unsigned int )0;
  {
#line 32
  while (1) {
    while_continue: /* CIL Label */ ;
#line 32
    if (! (this_list < shape.length)) {
#line 32
      goto while_break;
    }
#line 38
    list = *(shape.data + this_list);
#line 39
    first = *(list.data + 0);
#line 41
    stroke = shape.centerline || list.open;
#line 45
    if (stroke) {
#line 45
      tmp = "lp";
    } else {
#line 45
      tmp = "fp";
    }
    {
#line 45
    fprintf(file, "%s((%g,%g,%g))\n", tmp, (double )((int )list.color.r) / 255., (double )((int )list.color.g) / 255.,
            (double )((int )list.color.b) / 255.);
    }
#line 46
    if (stroke) {
#line 46
      tmp___0 = "fe()\n";
    } else {
#line 46
      tmp___0 = "le()\n";
    }
    {
#line 46
    fputs(tmp___0, file);
#line 49
    fputs("b()\n", file);
#line 52
    fprintf(file, "bs(%g,%g,0)\n", (double )first.v[0].x, (double )first.v[0].y);
#line 55
    this_spline = (unsigned int )0;
    }
    {
#line 55
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 55
      if (! (this_spline < list.length)) {
#line 55
        goto while_break___0;
      }
#line 56
      s = *(list.data + this_spline);
#line 57
      if ((unsigned int )s.degree == 1U) {
        {
#line 58
        fprintf(file, "bs(%g,%g,0)\n", (double )s.v[3].x, (double )s.v[3].y);
        }
      } else {
        {
#line 60
        fprintf(file, "bc(%g,%g,%g,%g,%g,%g,0)\n\230\001", (double )s.v[1].x, (double )s.v[1].y,
                (double )s.v[2].x, (double )s.v[2].y, (double )s.v[3].x, (double )s.v[3].y);
        }
      }
#line 55
      this_spline ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 65
    if (! stroke) {
      {
#line 66
      fputs("bC()\n", file);
      }
    }
#line 32
    this_list ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 70 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-sk.c"
int output_sk_writer(FILE *file , gchar *name , int llx , int lly , int urx , int ury ,
                     at_output_opts_type *opts , at_spline_list_array_type shape ,
                     at_msg_func msg_func , gpointer msg_data , gpointer user_data ) 
{ 


  {
  {
#line 72
  fputs("##Sketch 1 0\n", file);
#line 73
  fputs("document()\n", file);
#line 74
  fputs("layer(\'Layer 1\',1,1,0,0)\n", file);
#line 75
  fputs("guess_cont()\n", file);
#line 77
  out_splines___5(file, shape);
  }
#line 78
  return (0);
}
}
#line 808 "/usr/include/glib-2.0/gobject/gobject.h"
__inline static void g_assert_finalize_object___29(GObject *object ) 
{ 
  gpointer weak_pointer ;
  long __cil_tmp3 ;
  long __cil_tmp4 ;

  {
#line 810
  weak_pointer = object;
  {
#line 812
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 812
    __cil_tmp3 = __builtin_expect((long )0, (long )1);
    }
#line 812
    if (__cil_tmp3) {

    } else {
      {
#line 812
      g_assertion_message((char const   *)((gchar *)0), "/usr/include/glib-2.0/gobject/gobject.h",
                          812, (char const   *)"g_assert_finalize_object\312\001@",
                          "\'G_IS_OBJECT (weak_pointer)\' should be TRUE");
      }
    }
#line 812
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 813
  g_object_add_weak_pointer(object, & weak_pointer);
#line 814
  g_object_unref(weak_pointer);
  }
  {
#line 815
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 815
    __cil_tmp4 = __builtin_expect((long )0, (long )1);
    }
#line 815
    if (__cil_tmp4) {

    } else {
      {
#line 815
      g_assertion_message((char const   *)((gchar *)0), "/usr/include/glib-2.0/gobject/gobject.h",
                          815, (char const   *)"g_assert_finalize_object\312\001\300\016\342\257\b",
                          "\'weak_pointer\' should be NULLV");
      }
    }
#line 815
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 47 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-fig.c"
static gfloat bezpnt___0(gfloat t , gfloat z1 , gfloat z2 , gfloat z3 , gfloat z4 ) ;
#line 48
static void out_fig_splines(FILE *file , at_spline_list_array_type shape , int llx ,
                            int lly , int urx , int ury , at_exception_type *exp___0 ) ;
#line 49
static int get_fig_colour(at_color this_colour , at_exception_type *exp___0 ) ;
#line 50
static void fig_col_init(void) ;
#line 58
static struct __anonstruct_1283 fig_hash[544] ;
#line 63
static struct __anonstruct_1284 fig_colour_map[544] ;
#line 65 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-fig.c"
static int LAST_FIG_COLOUR  =    32;
#line 69
static float glob_min_x ;
#line 69
static float glob_max_x ;
#line 69
static float glob_min_y ;
#line 69
static float glob_max_y ;
#line 70
static float loc_min_x ;
#line 70
static float loc_max_x ;
#line 70
static float loc_min_y ;
#line 70
static float loc_max_y ;
#line 71 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-fig.c"
static int glo_bbox_flag  =    0;
#line 71 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-fig.c"
static int loc_bbox_flag  =    0;
#line 71
static int fig_depth ;
#line 73 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-fig.c"
static void fig_new_depth(void) 
{ 
  int __cil_tmp1 ;

  {
#line 75
  if (glo_bbox_flag == 0) {
#line 76
    glob_max_y = loc_max_y;
#line 77
    glob_min_y = loc_min_y;
#line 78
    glob_max_x = loc_max_x;
#line 79
    glob_min_x = loc_min_x;
#line 80
    glo_bbox_flag = 1;
  } else
#line 82
  if (loc_max_y <= glob_min_y) {
    _L: /* CIL Label */ 
    _L___55: /* CIL Label */ 
    _L___56: /* CIL Label */ 
#line 84
    if (loc_max_y > glob_max_y) {
#line 85
      glob_max_y = loc_max_y;
    }
#line 86
    if (loc_min_y < glob_min_y) {
#line 87
      glob_min_y = loc_min_y;
    }
#line 88
    if (loc_max_x > glob_max_x) {
#line 89
      glob_max_x = loc_max_x;
    }
#line 90
    if (loc_min_x < glob_min_x) {
#line 91
      glob_min_x = loc_min_x;
    }
  } else
#line 82
  if (loc_min_y >= glob_max_y) {
#line 82
    goto _L;
  } else
#line 82
  if (loc_max_x <= glob_min_x) {
#line 82
    goto _L;
  } else
#line 82
  if (loc_min_x >= glob_max_x) {
#line 82
    goto _L;
  } else {
#line 94
    glob_max_y = loc_max_y;
#line 95
    glob_min_y = loc_min_y;
#line 96
    glob_max_x = loc_max_x;
#line 97
    glob_min_x = loc_min_x;
#line 98
    if (fig_depth) {
#line 99
      __cil_tmp1 = fig_depth;
#line 99
      fig_depth --;
    }
  }
#line 102
  loc_bbox_flag = 0;
  return;
}
}
#line 105 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-fig.c"
static void fig_addtobbox(float x , float y ) 
{ 


  {
#line 107
  if (loc_bbox_flag == 0) {
#line 108
    loc_max_y = y;
#line 109
    loc_min_y = y;
#line 110
    loc_max_x = x;
#line 111
    loc_min_x = x;
#line 112
    loc_bbox_flag = 1;
  } else {
#line 114
    if (loc_max_y < y) {
#line 115
      loc_max_y = y;
    }
#line 116
    if (loc_min_y > y) {
#line 117
      loc_min_y = y;
    }
#line 118
    if (loc_max_x < x) {
#line 119
      loc_max_x = x;
    }
#line 120
    if (loc_min_x > x) {
#line 121
      loc_min_x = x;
    }
  }
  return;
}
}
#line 127 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-fig.c"
static gfloat bezpnt___0(gfloat t , gfloat z1 , gfloat z2 , gfloat z3 , gfloat z4 ) 
{ 
  gfloat temp ;
  gfloat t1 ;

  {
#line 131
  if (t < (gfloat )0.) {
#line 132
    t = (gfloat )0.;
  }
#line 134
  if (t > (gfloat )1.) {
#line 135
    t = (gfloat )1.;
  }
#line 137
  t1 = (gfloat )1. - t;
#line 138
  temp = ((((t1 * t1) * t1) * z1 + ((((gfloat )3. * t) * t1) * t1) * z2) + ((((gfloat )3. * t) * t) * t1) * z3) + ((t * t) * t) * z4;
#line 139
  return (temp);
}
}
#line 142 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-fig.c"
static void out_fig_splines(FILE *file , at_spline_list_array_type shape , int llx ,
                            int lly , int urx , int ury , at_exception_type *exp___0 ) 
{ 
  unsigned int this_list ;
  int fig_colour ;
  int fig_fill ;
  int fig_width ;
  int fig_subt ;
  int fig_spline_close ;
  int i ;
  int *spline_colours ;
  void *__cil_tmp16 ;
  int tmp ;
  spline_list_type list ;
  at_color curr_color ;
  at_color tmp___0 ;
  int __cil_tmp21 ;
  unsigned int __cil_tmp22 ;
  int __cil_tmp23 ;
  unsigned int this_spline ;
  spline_list_type list___0 ;
  int *pointx ;
  int *pointy ;
  gfloat *contrl ;
  int pointcount ;
  int is_spline ;
  int j ;
  int maxlength ;
  void *__cil_tmp33 ;
  int tmp___1 ;
  void *__cil_tmp35 ;
  int tmp___2 ;
  void *__cil_tmp37 ;
  int tmp___3 ;
  spline_type s ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  gfloat temp ;
  gfloat __cil_tmp43 ;
  gfloat __cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  unsigned int __cil_tmp47 ;
  int __cil_tmp48 ;
  int __cil_tmp49 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;
  int __cil_tmp53 ;
  int __cil_tmp54 ;
  unsigned int __cil_tmp55 ;

  {
  {
#line 155
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 155
    __cil_tmp16 = malloc(sizeof(int ) * (unsigned long )shape.length);
#line 155
    spline_colours = (gpointer )__cil_tmp16;
    }
#line 155
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 158
  fig_col_init();
#line 161
  this_list = (unsigned int )0;
  }
  {
#line 161
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 161
    if (! (this_list < shape.length)) {
#line 161
      goto while_break___0;
    }
#line 162
    list = *(shape.data + this_list);
#line 163
    if (shape.background_color != (void *)0 && list.clockwise) {
#line 163
      tmp___0 = *(shape.background_color);
    } else {
#line 163
      tmp___0 = list.color;
    }
    {
#line 163
    curr_color = tmp___0;
#line 164
    *(spline_colours + this_list) = get_fig_colour(curr_color, exp___0);
    }
#line 161
    this_list ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 167
  if (LAST_FIG_COLOUR > 32) {
#line 168
    i = 32;
    {
#line 168
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 168
      if (! (i < LAST_FIG_COLOUR)) {
#line 168
        goto while_break___1;
      }
      {
#line 169
      fprintf(file, "0 %d #%.2x%.2x%.2x\n", i, (int )fig_colour_map[i].c.r, (int )fig_colour_map[i].c.g,
              (int )fig_colour_map[i].c.b);
      }
#line 168
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 173
  fig_depth = (int )(shape.length + 20U);
#line 174
  if (fig_depth > 999) {
#line 175
    fig_depth = 999;
  }
#line 178
  this_list = (unsigned int )0;
  {
#line 178
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 178
    if (! (this_list < shape.length)) {
#line 178
      goto while_break___2;
    }
#line 180
    list___0 = *(shape.data + this_list);
#line 185
    pointcount = 0;
#line 185
    is_spline = 0;
#line 186
    maxlength = (int )(list___0.length * 5U + 1U);
    {
#line 188
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 188
      __cil_tmp33 = malloc((unsigned long )maxlength * sizeof(int ));
#line 188
      pointx = (gpointer )__cil_tmp33;
      }
#line 188
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 189
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 189
      __cil_tmp35 = malloc((unsigned long )maxlength * sizeof(int ));
#line 189
      pointy = (gpointer )__cil_tmp35;
      }
#line 189
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 190
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 190
      __cil_tmp37 = malloc((unsigned long )maxlength * sizeof(gfloat ));
#line 190
      contrl = (gpointer )__cil_tmp37;
      }
#line 190
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 192
    if (list___0.clockwise) {
#line 193
      fig_colour = 7;
    } else {
#line 195
      fig_colour = *(spline_colours + this_list);
    }
#line 198
    fig_spline_close = 5;
#line 200
    this_spline = (unsigned int )0;
    {
#line 200
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 200
      if (! (this_spline < list___0.length)) {
#line 200
        goto while_break___6;
      }
#line 201
      s = *(list___0.data + this_spline);
#line 203
      if (pointcount == 0) {
        {
#line 204
        *(pointx + pointcount) = (int )((double )s.v[0].x * 15. + 300.);
#line 205
        *(pointy + pointcount) = (int )((double )((float )ury - s.v[0].y) * 15. + 300.);
#line 206
        *(contrl + pointcount) = (gfloat )0.;
#line 207
        fig_addtobbox(s.v[0].x, s.v[0].y);
#line 208
        pointcount ++;
        }
      }
#line 212
      if ((unsigned int )s.degree == 1U) {
        {
#line 213
        *(pointx + pointcount) = (int )((double )s.v[3].x * 15. + 300.);
#line 214
        *(pointy + pointcount) = (int )((double )((float )ury - s.v[3].y) * 15. + 300.);
#line 215
        *(contrl + pointcount) = (gfloat )0.;
#line 216
        fig_addtobbox(s.v[0].x, s.v[0].y);
#line 217
        pointcount ++;
        }
      } else {
#line 222
        temp = (gfloat )0.200000000001;
        {
#line 222
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 222
          if (! (temp < (gfloat )0.900000000001)) {
#line 222
            goto while_break___7;
          }
          {
#line 223
          __cil_tmp43 = bezpnt___0(temp, s.v[0].x, s.v[1].x, s.v[2].x, s.v[3].x);
#line 223
          *(pointx + pointcount) = (int )((double )__cil_tmp43 * 15. + 300.);
#line 224
          __cil_tmp44 = bezpnt___0(temp, s.v[0].y, s.v[1].y, s.v[2].y, s.v[3].y);
#line 224
          *(pointy + pointcount) = (int )((double )((float )ury - __cil_tmp44) * 15. + 300.);
#line 225
          *(contrl + pointcount) = (gfloat )(- 1.);
#line 226
          pointcount ++;
          }
#line 222
          temp += (gfloat )0.200000000001;
        }
        while_break___7: /* CIL Label */ ;
        }
        {
#line 228
        *(pointx + pointcount) = (int )((double )s.v[3].x * 15. + 300.);
#line 229
        *(pointy + pointcount) = (int )((double )((float )ury - s.v[3].y) * 15. + 300.);
#line 230
        *(contrl + pointcount) = (gfloat )0.;
#line 231
        fig_addtobbox(s.v[0].x, s.v[0].y);
#line 232
        fig_addtobbox(s.v[1].x, s.v[1].y);
#line 233
        fig_addtobbox(s.v[2].x, s.v[2].y);
#line 234
        fig_addtobbox(s.v[3].x, s.v[3].y);
#line 235
        pointcount ++;
#line 236
        is_spline = 1;
        }
      }
#line 200
      this_spline ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 239
    if (shape.centerline) {
#line 240
      fig_fill = - 1;
#line 241
      fig_width = 1;
#line 242
      fig_spline_close = 4;
    } else {
#line 245
      fig_fill = 20;
#line 246
      fig_width = 0;
#line 247
      fig_spline_close = 5;
    }
#line 249
    if (is_spline != 0) {
      {
#line 250
      fig_new_depth();
#line 251
      fprintf(file, "3 %d 0 %d %d %d %d 0 %d 0.00 0 0 0 %d\n", fig_spline_close, fig_width,
              fig_colour, fig_colour, fig_depth, fig_fill, pointcount);
#line 253
      j = 0;
#line 254
      i = 0;
      }
      {
#line 254
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 254
        if (! (i < pointcount)) {
#line 254
          goto while_break___8;
        }
#line 255
        j ++;
#line 256
        if (j == 1) {
          {
#line 257
          fprintf(file, "\t");
          }
        }
        {
#line 259
        fprintf(file, "%d %d ", *(pointx + i), *(pointy + i));
        }
#line 260
        if (j == 8) {
          {
#line 261
          fprintf(file, "\n");
#line 262
          j = 0;
          }
        }
#line 254
        i ++;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 265
      if (j != 0) {
        {
#line 266
        fprintf(file, "\n");
        }
      }
#line 268
      j = 0;
#line 270
      i = 0;
      {
#line 270
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 270
        if (! (i < pointcount)) {
#line 270
          goto while_break___9;
        }
#line 271
        j ++;
#line 272
        if (j == 1) {
          {
#line 273
          fprintf(file, "\t");
          }
        }
        {
#line 275
        fprintf(file, "%f ", (double )*(contrl + i));
        }
#line 276
        if (j == 8) {
          {
#line 277
          fprintf(file, "\n");
#line 278
          j = 0;
          }
        }
#line 270
        i ++;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 281
      if (j != 0) {
        {
#line 282
        fprintf(file, "\n");
        }
      }
    } else {
#line 286
      fig_subt = 3;
#line 287
      if (pointcount == 2) {
#line 288
        if (*(pointx + 0) == *(pointx + 1)) {
#line 288
          if (*(pointy + 0) == *(pointy + 1)) {
            {
#line 290
            fig_new_depth();
#line 291
            fprintf(file, "2 1 0 1 %d %d %d 0 -1 0.000 0 0 -1 0 0 1\n", fig_colour,
                    fig_colour, fig_depth);
#line 292
            fprintf(file, "\t%d %d\n", *(pointx + 0), *(pointy + 0));
            }
          } else {
            {
            {
#line 295
            fig_new_depth();
            }
            {
#line 296
            fprintf(file, "2 1 0 1 %d %d %d 0 -1 0.000 0 0 -1 0 0 2\n", fig_colour,
                    fig_colour, fig_depth);
            }
            {
#line 297
            fprintf(file, "\t%d %d %d %d\n", *(pointx + 0), *(pointy + 0), *(pointx + 1),
                    *(pointy + 1));
            }
            }
          }
        } else {
          {
          {
#line 295
          fig_new_depth();
          }
          {
#line 296
          fprintf(file, "2 1 0 1 %d %d %d 0 -1 0.000 0 0 -1 0 0 2\n", fig_colour,
                  fig_colour, fig_depth);
          }
          {
#line 297
          fprintf(file, "\t%d %d %d %d\n", *(pointx + 0), *(pointy + 0), *(pointx + 1),
                  *(pointy + 1));
          }
          }
        }
      } else
#line 300
      if (pointcount == 3) {
#line 300
        if (*(pointx + 0) == *(pointx + 2)) {
#line 300
          if (*(pointy + 0) == *(pointy + 2)) {
            {
#line 303
            fig_new_depth();
#line 304
            fprintf(file, "2 1 0 1 %d %d %d 0 -1 0.000 0 0 -1 0 0 2\n", fig_colour,
                    fig_colour, fig_depth);
#line 305
            fprintf(file, "\t%d %d %d %d\n", *(pointx + 0), *(pointy + 0), *(pointx + 1),
                    *(pointy + 1));
            }
          } else {
#line 300
            goto _L___57;
          }
        } else {
#line 300
          goto _L___57;
        }
      } else {
        _L___57: /* CIL Label */ 
        _L___58: /* CIL Label */ 
#line 307
        if (*(pointx + 0) != *(pointx + (pointcount - 1))) {
          _L: /* CIL Label */ 
#line 308
          if (shape.centerline) {
#line 309
            fig_subt = 1;
          } else {
#line 312
            *(pointx + pointcount) = *(pointx + 0);
#line 313
            *(pointy + pointcount) = *(pointy + 0);
#line 314
            pointcount ++;
          }
        } else
#line 307
        if (*(pointy + 0) != *(pointy + (pointcount - 1))) {
#line 307
          goto _L;
        }
        {
#line 317
        fig_new_depth();
#line 318
        fprintf(file, "2 %d 0 %d %d %d %d 0 %d 0.00 0 0 0 0 0 %d\n", fig_subt, fig_width,
                fig_colour, fig_colour, fig_depth, fig_fill, pointcount);
#line 320
        j = 0;
#line 321
        i = 0;
        }
        {
#line 321
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 321
          if (! (i < pointcount)) {
#line 321
            goto while_break___10;
          }
#line 322
          j ++;
#line 323
          if (j == 1) {
            {
#line 324
            fprintf(file, "\t");
            }
          }
          {
#line 326
          fprintf(file, "%d %d ", *(pointx + i), *(pointy + i));
          }
#line 327
          if (j == 8) {
            {
#line 328
            fprintf(file, "\n");
#line 329
            j = 0;
            }
          }
#line 321
          i ++;
        }
        while_break___10: /* CIL Label */ ;
        }
#line 332
        if (j != 0) {
          {
#line 333
          fprintf(file, "\n");
          }
        }
      }
    }
#line 339
    if (fig_depth < 0) {
#line 340
      fig_depth = 0;
    }
    {
#line 342
    free(pointx);
#line 343
    free(pointy);
#line 344
    free(contrl);
    }
#line 178
    this_list ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 346
  free(spline_colours);
  }
#line 347
  return;
}
}
#line 350 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-fig.c"
int output_fig_writer(FILE *file , gchar *name , int llx , int lly , int urx , int ury ,
                      at_output_opts_type *opts , at_spline_list_array_type shape ,
                      at_msg_func msg_func , gpointer msg_data , gpointer user_data ) 
{ 
  at_exception_type exp___0 ;
  at_exception_type __cil_tmp13 ;

  {
  {
#line 352
  __cil_tmp13 = at_exception_new(msg_func, msg_data);
#line 352
  exp___0 = __cil_tmp13;
#line 354
  fprintf(file, "#FIG 3.2\nLandscape\nCenter\nInches\nLetter\n100.00\nSingle\n-2\n1200 2\n\220");
#line 357
  out_fig_splines(file, shape, llx, lly, urx, ury, & exp___0);
  }
#line 358
  return (0);
}
}
#line 368 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-fig.c"
static void fig_col_init(void) 
{ 
  int i ;
  int __cil_tmp2 ;

  {
#line 372
  i = 0;
  {
#line 372
  while (1) {
    while_continue: /* CIL Label */ ;
#line 372
    if (! (i < 544)) {
#line 372
      goto while_break;
    }
#line 373
    fig_hash[i].colour = (unsigned int )0;
#line 374
    fig_colour_map[i].alternate = 0;
#line 372
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 379
  fig_hash[0].colour = (unsigned int )0;
#line 380
  fig_colour_map[0].c.r = (guint8 )0;
#line 381
  fig_colour_map[0].c.g = (guint8 )0;
#line 382
  fig_colour_map[0].c.b = (guint8 )0;
#line 384
  fig_hash[543].colour = (unsigned int )7;
#line 385
  fig_colour_map[7].c.r = (guint8 )255;
#line 386
  fig_colour_map[7].c.g = (guint8 )255;
#line 387
  fig_colour_map[7].c.b = (guint8 )255;
#line 389
  fig_hash[255].colour = (unsigned int )4;
#line 390
  fig_colour_map[4].c.r = (guint8 )255;
#line 391
  fig_colour_map[4].c.g = (guint8 )0;
#line 392
  fig_colour_map[4].c.b = (guint8 )0;
#line 394
  fig_hash[161].colour = (unsigned int )2;
#line 395
  fig_colour_map[2].c.r = (guint8 )0;
#line 396
  fig_colour_map[2].c.g = (guint8 )255;
#line 397
  fig_colour_map[2].c.b = (guint8 )0;
#line 399
  fig_hash[127].colour = (unsigned int )1;
#line 400
  fig_colour_map[1].c.r = (guint8 )0;
#line 401
  fig_colour_map[1].c.g = (guint8 )0;
#line 402
  fig_colour_map[1].c.b = (guint8 )255;
#line 404
  fig_hash[198].colour = (unsigned int )3;
#line 405
  fig_colour_map[3].c.r = (guint8 )0;
#line 406
  fig_colour_map[3].c.g = (guint8 )255;
#line 407
  fig_colour_map[3].c.b = (guint8 )255;
#line 409
  fig_hash[382].colour = (unsigned int )5;
#line 410
  fig_colour_map[5].c.r = (guint8 )255;
#line 411
  fig_colour_map[5].c.g = (guint8 )0;
#line 412
  fig_colour_map[5].c.b = (guint8 )255;
#line 414
  fig_hash[416].colour = (unsigned int )6;
#line 415
  fig_colour_map[6].c.r = (guint8 )255;
#line 416
  fig_colour_map[6].c.g = (guint8 )255;
#line 417
  fig_colour_map[6].c.b = (guint8 )0;
  return;
}
}
#line 425 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-fig.c"
static int get_fig_colour(at_color this_colour , at_exception_type *exp___0 ) 
{ 
  int hash ;
  int i ;
  int this_ind ;
  gboolean __cil_tmp6 ;
  int __cil_tmp7 ;
  gboolean __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 429
  hash = (((int )this_colour.r & 255) + ((int )this_colour.g & 161)) + ((int )this_colour.b & 127);
#line 432
  __cil_tmp6 = at_color_equal(& fig_colour_map[0].c, & this_colour);
  }
#line 432
  if (hash == 0) {
#line 432
    if (__cil_tmp6) {
#line 433
      return (0);
    }
  }
#line 436
  if (fig_hash[hash].colour == 0U) {
#line 437
    fig_hash[hash].colour = (unsigned int )LAST_FIG_COLOUR;
#line 438
    fig_colour_map[LAST_FIG_COLOUR].c.r = this_colour.r;
#line 439
    fig_colour_map[LAST_FIG_COLOUR].c.g = this_colour.g;
#line 440
    fig_colour_map[LAST_FIG_COLOUR].c.b = this_colour.b;
#line 441
    LAST_FIG_COLOUR ++;
#line 442
    if (LAST_FIG_COLOUR >= 543) {
      {
#line 443
      while (1) {
        while_continue: /* CIL Label */ ;
#line 443
        if (logging) {
          {
#line 443
          fprintf(stdout, "Output-Fig: too many colours: %d\230\001", LAST_FIG_COLOUR);
          }
        }
#line 443
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 444
      at_exception_fatal(exp___0, (gchar *)"Output-Fig: too many colours");
      }
#line 445
      return (0);
    }
#line 447
    return ((int )fig_hash[hash].colour);
  } else {
#line 449
    i = 0;
#line 450
    this_ind = (int )fig_hash[hash].colour;
    figcolloop: 
    {
#line 453
    __cil_tmp8 = at_color_equal(& fig_colour_map[this_ind].c, & this_colour);
    }
#line 453
    if (__cil_tmp8) {
#line 454
      return (this_ind);
    }
#line 457
    if (fig_colour_map[this_ind].alternate == 0) {
#line 458
      fig_colour_map[this_ind].alternate = LAST_FIG_COLOUR;
#line 459
      fig_colour_map[LAST_FIG_COLOUR].c.r = this_colour.r;
#line 460
      fig_colour_map[LAST_FIG_COLOUR].c.g = this_colour.g;
#line 461
      fig_colour_map[LAST_FIG_COLOUR].c.b = this_colour.b;
#line 462
      LAST_FIG_COLOUR ++;
#line 463
      if (LAST_FIG_COLOUR >= 543) {
        {
#line 464
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 464
          if (logging) {
            {
#line 464
            fprintf(stdout, "Output-Fig: too many colours: %d\230\001", LAST_FIG_COLOUR);
            }
          }
#line 464
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 465
        at_exception_fatal(exp___0, (gchar *)"Output-Fig: too many colours");
        }
#line 466
        return (0);
      }
#line 468
      return (fig_colour_map[this_ind].alternate);
    }
#line 471
    this_ind = fig_colour_map[this_ind].alternate;
#line 473
    __cil_tmp10 = i;
#line 473
    i ++;
#line 473
    if (__cil_tmp10 > 543) {
      {
#line 474
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 474
        if (logging) {
          {
#line 474
          fprintf(stdout, "Output-Fig: too many colours (loop): %d", i);
          }
        }
#line 474
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 475
      at_exception_fatal(exp___0, (gchar *)"Output-Fig: too many colours (loop)");
      }
#line 476
      return (0);
    }
#line 479
    goto figcolloop;
  }
}
}
#line 37 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-er.c"
static int output_er_header(FILE *er_file , gchar *name , int llx , int lly , int urx ,
                            int ury ) 
{ 
  gchar *time___59 ;
  char *__cil_tmp8 ;

  {
  {
#line 41
  time___59 = at_time_string();
#line 41
  fprintf(er_file, "#Elastic Reality Shape File\n\n#Date: %s\n\n\230\001", time___59);
#line 43
  g_free(time___59);
#line 45
  fprintf(er_file, "ImageSize = {\n\tWidth = %d\n\tHeight = %d\n}\n\n", urx - llx,
          ury - lly);
  }
#line 47
  return (0);
}
}
#line 52 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-er.c"
static void out_splines___6(FILE *er_file , at_spline_list_array_type shape , unsigned int width ,
                            unsigned int height , at_output_opts_type *opts ) 
{ 
  unsigned int this_list ;
  unsigned int corresp_pt ;
  double x0 ;
  double y0___0 ;
  double x1 ;
  double y1___0 ;
  double x2 ;
  double y2 ;
  double corresp_length ;
  unsigned int this_spline ;
  spline_type prev ;
  spline_list_type list ;
  unsigned int length ;
  unsigned int out_length ;
  unsigned int tmp ;
  char const   *tmp___0 ;
  unsigned int tmp___1 ;
  spline_type s ;
  unsigned int __cil_tmp24 ;
  gfloat w ;
  unsigned int tmp___2 ;
  spline_type s___0 ;
  unsigned int __cil_tmp28 ;
  double tmp___3 ;
  double tmp___4 ;
  unsigned int __cil_tmp31 ;
  unsigned int __cil_tmp32 ;

  {
#line 57
  this_list = (unsigned int )0;
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    if (! (this_list < shape.length)) {
#line 57
      goto while_break;
    }
#line 61
    list = *(shape.data + this_list);
#line 62
    length = list.length;
#line 63
    if (list.open || length == 1U) {
#line 63
      tmp = length + 1U;
    } else {
#line 63
      tmp = length;
    }
    {
#line 63
    out_length = tmp;
#line 65
    fprintf(er_file, "Shape = {\n");
#line 66
    fprintf(er_file, "\t#Shape Number %d\n", this_list + 1U);
#line 67
    fprintf(er_file, "\tGroup = Default\n");
#line 68
    fprintf(er_file, "\tType = Source\n");
#line 69
    fprintf(er_file, "\tRoll = A\n");
#line 70
    fprintf(er_file, "\tOpaque = True\n");
#line 71
    fprintf(er_file, "\tLocked = False\n\220");
#line 72
    fprintf(er_file, "\tWarp = True\n");
#line 73
    fprintf(er_file, "\tCookieCut = True\n");
#line 74
    fprintf(er_file, "\tColorCorrect = True\n");
#line 75
    fprintf(er_file, "\tPrecision = 10\n\220");
    }
#line 76
    if (list.open) {
#line 76
      tmp___0 = "False";
    } else {
#line 76
      tmp___0 = "True";
    }
    {
#line 76
    fprintf(er_file, "\tClosed = %s\n", tmp___0);
#line 77
    fprintf(er_file, "\tTween = Linear\n\220");
#line 78
    fprintf(er_file, "\tBPoints = %d\n", out_length);
#line 79
    fprintf(er_file, "\tCPoints = %d\n", 4);
#line 80
    fprintf(er_file, "\tFormKey = {\n");
#line 81
    fprintf(er_file, "\t\tFrame = 1\n");
#line 82
    fprintf(er_file, "\t\tPointList = {\n\220");
#line 84
    tmp___1 = list.length - 1U;
#line 84
    prev = *(list.data + tmp___1);
    }
#line 85
    if (list.open) {
#line 86
      prev.degree = (polynomial_degree )(- 1);
    } else
#line 85
    if (length == 1U) {
#line 86
      prev.degree = (polynomial_degree )(- 1);
    }
#line 88
    this_spline = (unsigned int )0;
    {
#line 88
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 88
      if (! (this_spline < length)) {
#line 88
        goto while_break___0;
      }
#line 89
      s = *(list.data + this_spline);
#line 91
      if ((unsigned int )prev.degree == 4294967295U) {
#line 92
        x0 = (double )s.v[0].x;
#line 93
        y0___0 = (double )s.v[0].y;
      } else
#line 94
      if ((unsigned int )prev.degree == 3U) {
#line 95
        x0 = (double )prev.v[2].x;
#line 96
        y0___0 = (double )prev.v[2].y;
      } else {
#line 98
        x0 = (double )s.v[0].x;
#line 99
        y0___0 = (double )s.v[0].y;
      }
#line 102
      x1 = (double )s.v[0].x;
#line 103
      y1___0 = (double )s.v[0].y;
#line 105
      if ((unsigned int )s.degree == 3U) {
#line 106
        x2 = (double )s.v[1].x;
#line 107
        y2 = (double )s.v[1].y;
      } else {
#line 109
        x2 = (double )s.v[0].x;
#line 110
        y2 = (double )s.v[0].y;
      }
      {
#line 113
      fprintf(er_file, "\t\t\t(%f, %f), (%f, %f), (%f, %f),\n", x0 / (double )width,
              y0___0 / (double )height, x1 / (double )width, y1___0 / (double )height,
              x2 / (double )width, y2 / (double )height);
#line 115
      prev = s;
      }
#line 88
      this_spline ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 118
    if (list.open) {
      _L: /* CIL Label */ 
      {
#line 119
      x0 = (double )prev.v[2].x;
#line 120
      y0___0 = (double )prev.v[2].y;
#line 121
      x1 = (double )prev.v[3].x;
#line 121
      x2 = x1;
#line 122
      y1___0 = (double )prev.v[3].y;
#line 122
      y2 = y1___0;
#line 124
      fprintf(er_file, "\t\t\t(%f, %f), (%f, %f), (%f, %f),\n", x0 / (double )width,
              y0___0 / (double )height, x1 / (double )width, y1___0 / (double )height,
              x2 / (double )width, y2 / (double )height);
      }
    } else
#line 118
    if (length == 1U) {
#line 118
      goto _L;
    }
    {
#line 128
    fprintf(er_file, "\t\t}\n\n\t}\n\n");
    }
#line 130
    if (shape.centerline) {
#line 130
      if (shape.preserve_width) {
        {
#line 131
        w = (gfloat )1. / shape.width_weight_factor;
#line 133
        fprintf(er_file, "\tWeightKey = {\n");
#line 134
        fprintf(er_file, "\t\tFrame = 1\n");
#line 135
        fprintf(er_file, "\t\tPointList = {\n\220");
#line 136
        tmp___2 = list.length - 1U;
#line 136
        prev = *(list.data + tmp___2);
        }
#line 137
        if (list.open) {
#line 138
          prev.degree = (polynomial_degree )(- 1);
        } else
#line 137
        if (length == 1U) {
#line 138
          prev.degree = (polynomial_degree )(- 1);
        }
#line 139
        this_spline = (unsigned int )0;
        {
#line 139
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 139
          if (! (this_spline < length)) {
#line 139
            goto while_break___1;
          }
#line 140
          s___0 = *(list.data + this_spline);
#line 142
          if ((unsigned int )prev.degree == 4294967295U) {
#line 143
            x0 = (double )s___0.v[0].z;
          } else
#line 144
          if ((unsigned int )prev.degree == 3U) {
#line 145
            x0 = (double )prev.v[2].z;
          } else {
#line 147
            x0 = (double )s___0.v[0].z;
          }
#line 149
          x1 = (double )s___0.v[0].z;
#line 151
          if ((unsigned int )s___0.degree == 3U) {
#line 152
            x2 = (double )s___0.v[1].z;
          } else {
#line 154
            x2 = (double )s___0.v[0].z;
          }
          {
#line 156
          fprintf(er_file, "\t\t\t%g, %g, %g,\n", x0 * (double )w, x1 * (double )w,
                  x2 * (double )w);
#line 158
          prev = s___0;
          }
#line 139
          this_spline ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 160
        if (list.open) {
          {
#line 161
          x0 = (double )prev.v[2].z;
#line 162
          x1 = (double )prev.v[3].z;
#line 162
          x2 = x1;
          {
#line 163
          fprintf(er_file, "\t\t\t%g, %g, %g,\n", x0 * (double )w, x1 * (double )w,
                  x2 * (double )w);
          }
          }
        } else
#line 160
        if (length == 1U) {
          {
#line 161
          x0 = (double )prev.v[2].z;
#line 162
          x1 = (double )prev.v[3].z;
#line 162
          x2 = x1;
          {
#line 163
          fprintf(er_file, "\t\t\t%g, %g, %g,\n", x0 * (double )w, x1 * (double )w,
                  x2 * (double )w);
          }
          }
        }
        {
#line 166
        fprintf(er_file, "\t\t}\n\n\t}\n\n");
        }
      }
    }
    {
#line 169
    fprintf(er_file, "\tCorrKey = {\n");
#line 170
    fprintf(er_file, "\t\tFrame = 1\n");
#line 171
    fprintf(er_file, "\t\tPointList = {\n\220");
#line 172
    fprintf(er_file, "\t\t\t0");
    }
#line 173
    if (list.open) {
#line 173
      tmp___3 = 1.;
    } else {
#line 173
      tmp___3 = 2.;
    }
#line 173
    corresp_length = (double )out_length - tmp___3;
#line 174
    corresp_pt = (unsigned int )1;
    {
#line 174
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 174
      if (! (corresp_pt < 4U)) {
#line 174
        goto while_break___2;
      }
#line 175
      if (list.open) {
#line 175
        tmp___4 = 1.;
      } else {
#line 175
        tmp___4 = 0.;
      }
      {
#line 175
      fprintf(er_file, ", %g", (corresp_length * (double )corresp_pt) / ((double )4 - tmp___4));
      }
#line 174
      corresp_pt ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 178
    fprintf(er_file, "\n\t\t}\n\n\t}\n\n");
#line 181
    fprintf(er_file, "}\n\n");
    }
#line 57
    this_list ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 185 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-er.c"
int output_er_writer(FILE *file , gchar *name , int llx , int lly , int urx , int ury ,
                     at_output_opts_type *opts , at_spline_list_array_type shape ,
                     at_msg_func msg_func , gpointer msg_data , gpointer user_data ) 
{ 
  int result ;
  unsigned int width ;
  unsigned int height ;
  int __cil_tmp15 ;

  {
  {
#line 190
  result = output_er_header(file, name, llx, lly, urx, ury);
  }
#line 191
  if (result != 0) {
#line 192
    return (result);
  }
  {
#line 194
  width = (unsigned int )(urx - llx);
#line 195
  height = (unsigned int )(ury - lly);
#line 196
  out_splines___6(file, shape, width, height, opts);
  }
#line 198
  return (0);
}
}
#line 80 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-eps.c"
static int output_eps_header(FILE *ps_file , gchar *name , int llx , int lly , int urx ,
                             int ury ) 
{ 
  gchar *time___60 ;
  char const   *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 84
  fprintf(ps_file, "%s\n", "%!PS-Adobe-3.0 EPSF-3.0");
#line 85
  __cil_tmp8 = at_version(! 0);
#line 85
  fprintf(ps_file, "%%%%Creator: Adobe Illustrator by %s\n", __cil_tmp8);
#line 86
  fprintf(ps_file, "%%%%Title: %s\n", name);
#line 87
  time___60 = at_time_string();
#line 87
  fprintf(ps_file, "%%%%CreationDate: %s\n", time___60);
#line 88
  fprintf(ps_file, "%%%%BoundingBox: %d %d %d %d\n", llx, lly, urx, ury);
#line 89
  fprintf(ps_file, "%s\n", "%%DocumentData: Clean7Bit");
#line 90
  fprintf(ps_file, "%s\n", "%%EndComments");
#line 92
  g_free(time___60);
#line 102
  fprintf(ps_file, "%s\n", "%%BeginProlog");
#line 103
  fprintf(ps_file, "%s\n", "/bd { bind def } bind def");
#line 104
  fprintf(ps_file, "%s\n", "/incompound false def");
#line 105
  fprintf(ps_file, "%s\n", "/m { moveto } bd\220");
#line 106
  fprintf(ps_file, "%s\n", "/l { lineto } bd\220");
#line 107
  fprintf(ps_file, "%s\n", "/c { curveto } bd");
#line 108
  fprintf(ps_file, "%s\n", "/F { incompound not {fill} if } bd");
#line 109
  fprintf(ps_file, "%s\n", "/f { closepath F } bd");
#line 110
  fprintf(ps_file, "%s\n", "/S { stroke } bd\220");
#line 111
  fprintf(ps_file, "%s\n", "/*u { /incompound true def } bd");
#line 112
  fprintf(ps_file, "%s\n", "/*U { /incompound false def f} bd");
#line 113
  fprintf(ps_file, "%s\n", "/k { setcmykcolor } bd");
#line 114
  fprintf(ps_file, "%s\n", "/K { k } bd");
#line 115
  fprintf(ps_file, "%s\n", "%%EndProlog");
#line 116
  fprintf(ps_file, "%s\n", "%%BeginSetup");
#line 117
  fprintf(ps_file, "%s\n", "%%EndSetup");
  }
#line 119
  return (0);
}
}
#line 125 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-eps.c"
static void out_splines___7(FILE *ps_file , at_spline_list_array_type shape ) 
{ 
  unsigned int this_list ;
  spline_list_type list ;
  at_color last_color ;
  unsigned int this_spline ;
  int c ;
  int m ;
  int y ;
  int k ;
  spline_type first ;
  gboolean __cil_tmp12 ;
  char const   *tmp ;
  long __cil_tmp14 ;
  long __cil_tmp15 ;
  char const   *tmp___0 ;
  long __cil_tmp17 ;
  long __cil_tmp18 ;
  char const   *tmp___1 ;
  spline_type s ;
  long __cil_tmp21 ;
  long __cil_tmp22 ;
  char const   *tmp___2 ;
  long __cil_tmp24 ;
  long __cil_tmp25 ;
  char const   *tmp___3 ;
  long __cil_tmp27 ;
  long __cil_tmp28 ;
  char const   *tmp___4 ;
  long __cil_tmp30 ;
  long __cil_tmp31 ;
  char const   *tmp___5 ;
  long __cil_tmp33 ;
  long __cil_tmp34 ;
  char const   *tmp___6 ;
  long __cil_tmp36 ;
  long __cil_tmp37 ;
  char const   *tmp___7 ;
  long __cil_tmp39 ;
  long __cil_tmp40 ;
  char const   *tmp___8 ;
  long __cil_tmp42 ;
  long __cil_tmp43 ;
  char const   *tmp___9 ;
  unsigned int __cil_tmp45 ;
  char const   *tmp___10 ;
  unsigned int __cil_tmp47 ;

  {
#line 130
  last_color.r = (guint8 )0;
#line 130
  last_color.g = (guint8 )0;
#line 130
  last_color.b = (guint8 )0;
#line 132
  this_list = (unsigned int )0;
  {
#line 132
  while (1) {
    while_continue: /* CIL Label */ ;
#line 132
    if (! (this_list < shape.length)) {
#line 132
      goto while_break;
    }
    {
#line 137
    list = *(shape.data + this_list);
#line 138
    first = *(list.data + 0);
#line 140
    __cil_tmp12 = at_color_equal(& list.color, & last_color);
    }
#line 140
    if (this_list == 0U) {
      _L: /* CIL Label */ 
#line 141
      if (this_list > 0U) {
        {
#line 142
        fprintf(ps_file, "%s\n", "*U");
        }
      }
#line 143
      k = 255 - (int )list.color.r;
#line 143
      c = k;
#line 144
      m = 255 - (int )list.color.g;
#line 145
      if (m < k) {
#line 146
        k = m;
      }
#line 147
      y = 255 - (int )list.color.b;
#line 148
      if (y < k) {
#line 149
        k = y;
      }
#line 150
      c -= k;
#line 151
      m -= k;
#line 152
      y -= k;
#line 154
      if (shape.centerline || list.open) {
#line 154
        tmp = "K";
      } else {
#line 154
        tmp = "k";
      }
      {
#line 154
      fprintf(ps_file, "%.3f %.3f %.3f %.3f %s\n", (double )c / 255., (double )m / 255.,
              (double )y / 255., (double )k / 255., tmp);
#line 155
      fprintf(ps_file, "%s\n", "*u");
#line 156
      last_color = list.color;
      }
    } else
#line 140
    if (! __cil_tmp12) {
#line 140
      goto _L;
    }
    {
#line 158
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 158
      __cil_tmp14 = lround((double )((gfloat )6. * first.v[0].x));
#line 158
      first.v[0].x = (float )__cil_tmp14 / (gfloat )6.;
#line 158
      __cil_tmp15 = lround((double )first.v[0].x);
      }
#line 158
      if (first.v[0].x == (float )__cil_tmp15) {
#line 158
        tmp___0 = "%.0f ";
      } else {
#line 158
        tmp___0 = "%.3f ";
      }
      {
#line 158
      fprintf(ps_file, tmp___0, (double )first.v[0].x);
#line 158
      __cil_tmp17 = lround((double )((gfloat )6. * first.v[0].y));
#line 158
      first.v[0].y = (float )__cil_tmp17 / (gfloat )6.;
#line 158
      __cil_tmp18 = lround((double )first.v[0].y);
      }
#line 158
      if (first.v[0].y == (float )__cil_tmp18) {
#line 158
        tmp___1 = "%.0f ";
      } else {
#line 158
        tmp___1 = "%.3f ";
      }
      {
#line 158
      fprintf(ps_file, tmp___1, (double )first.v[0].y);
#line 158
      fprintf(ps_file, "m\n");
      }
#line 158
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 160
    this_spline = (unsigned int )0;
    {
#line 160
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 160
      if (! (this_spline < list.length)) {
#line 160
        goto while_break___1;
      }
#line 161
      s = *(list.data + this_spline);
#line 163
      if ((unsigned int )s.degree == 1U) {
        {
#line 164
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 164
          __cil_tmp21 = lround((double )((gfloat )6. * s.v[3].x));
#line 164
          s.v[3].x = (float )__cil_tmp21 / (gfloat )6.;
#line 164
          __cil_tmp22 = lround((double )s.v[3].x);
          }
#line 164
          if (s.v[3].x == (float )__cil_tmp22) {
#line 164
            tmp___2 = "%.0f ";
          } else {
#line 164
            tmp___2 = "%.3f ";
          }
          {
#line 164
          fprintf(ps_file, tmp___2, (double )s.v[3].x);
#line 164
          __cil_tmp24 = lround((double )((gfloat )6. * s.v[3].y));
#line 164
          s.v[3].y = (float )__cil_tmp24 / (gfloat )6.;
#line 164
          __cil_tmp25 = lround((double )s.v[3].y);
          }
#line 164
          if (s.v[3].y == (float )__cil_tmp25) {
#line 164
            tmp___3 = "%.0f V";
          } else {
#line 164
            tmp___3 = "%.3f V";
          }
          {
#line 164
          fprintf(ps_file, tmp___3, (double )s.v[3].y);
#line 164
          fprintf(ps_file, "l\n");
          }
#line 164
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
      } else {
        {
#line 166
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 166
          __cil_tmp27 = lround((double )((gfloat )6. * s.v[1].x));
#line 166
          s.v[1].x = (float )__cil_tmp27 / (gfloat )6.;
#line 166
          __cil_tmp28 = lround((double )s.v[1].x);
          }
#line 166
          if (s.v[1].x == (float )__cil_tmp28) {
#line 166
            tmp___4 = "%.0f ";
          } else {
#line 166
            tmp___4 = "%.3f ";
          }
          {
#line 166
          fprintf(ps_file, tmp___4, (double )s.v[1].x);
#line 166
          __cil_tmp30 = lround((double )((gfloat )6. * s.v[1].y));
#line 166
          s.v[1].y = (float )__cil_tmp30 / (gfloat )6.;
#line 166
          __cil_tmp31 = lround((double )s.v[1].y);
          }
#line 166
          if (s.v[1].y == (float )__cil_tmp31) {
#line 166
            tmp___5 = "%.0f ";
          } else {
#line 166
            tmp___5 = "%.3f ";
          }
          {
#line 166
          fprintf(ps_file, tmp___5, (double )s.v[1].y);
#line 166
          fprintf(ps_file, " ");
#line 166
          __cil_tmp33 = lround((double )((gfloat )6. * s.v[2].x));
#line 166
          s.v[2].x = (float )__cil_tmp33 / (gfloat )6.;
#line 166
          __cil_tmp34 = lround((double )s.v[2].x);
          }
#line 166
          if (s.v[2].x == (float )__cil_tmp34) {
#line 166
            tmp___6 = "%.0f ";
          } else {
#line 166
            tmp___6 = "%.3f ";
          }
          {
#line 166
          fprintf(ps_file, tmp___6, (double )s.v[2].x);
#line 166
          __cil_tmp36 = lround((double )((gfloat )6. * s.v[2].y));
#line 166
          s.v[2].y = (float )__cil_tmp36 / (gfloat )6.;
#line 166
          __cil_tmp37 = lround((double )s.v[2].y);
          }
#line 166
          if (s.v[2].y == (float )__cil_tmp37) {
#line 166
            tmp___7 = "%.0f ";
          } else {
#line 166
            tmp___7 = "%.3f ";
          }
          {
#line 166
          fprintf(ps_file, tmp___7, (double )s.v[2].y);
#line 166
          fprintf(ps_file, " ");
#line 166
          __cil_tmp39 = lround((double )((gfloat )6. * s.v[3].x));
#line 166
          s.v[3].x = (float )__cil_tmp39 / (gfloat )6.;
#line 166
          __cil_tmp40 = lround((double )s.v[3].x);
          }
#line 166
          if (s.v[3].x == (float )__cil_tmp40) {
#line 166
            tmp___8 = "%.0f ";
          } else {
#line 166
            tmp___8 = "%.3f ";
          }
          {
#line 166
          fprintf(ps_file, tmp___8, (double )s.v[3].x);
#line 166
          __cil_tmp42 = lround((double )((gfloat )6. * s.v[3].y));
#line 166
          s.v[3].y = (float )__cil_tmp42 / (gfloat )6.;
#line 166
          __cil_tmp43 = lround((double )s.v[3].y);
          }
#line 166
          if (s.v[3].y == (float )__cil_tmp43) {
#line 166
            tmp___9 = "%.0f ";
          } else {
#line 166
            tmp___9 = "%.3f ";
          }
          {
#line 166
          fprintf(ps_file, tmp___9, (double )s.v[3].y);
#line 166
          fprintf(ps_file, " c \n");
          }
#line 166
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 160
      this_spline ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 168
    if (shape.length > 0U) {
#line 169
      if (shape.centerline || list.open) {
#line 169
        tmp___10 = "S";
      } else {
#line 169
        tmp___10 = "f";
      }
      {
#line 169
      fprintf(ps_file, "%s\n", tmp___10);
      }
    }
#line 132
    this_list ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 171
  if (shape.length > 0U) {
    {
#line 172
    fprintf(ps_file, "%s\n", "*U");
    }
  }
  return;
}
}
#line 175 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/output-eps.c"
int output_eps_writer(FILE *ps_file , gchar *name , int llx , int lly , int urx ,
                      int ury , at_output_opts_type *opts , at_spline_list_array_type shape ,
                      at_msg_func msg_func , gpointer msg_data , gpointer user_data ) 
{ 
  int result ;
  int __cil_tmp13 ;

  {
  {
#line 179
  result = output_eps_header(ps_file, name, llx, lly, urx, ury);
  }
#line 180
  if (result != 0) {
#line 181
    return (result);
  }
  {
#line 183
  out_splines___7(ps_file, shape);
#line 185
  fprintf(ps_file, "%s\n", "%%Trailer");
#line 186
  fprintf(ps_file, "%s\n", "%%EOF");
  }
#line 187
  return (0);
}
}
#line 36 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__)) int setjmp(jmp_buf __env ) ;
#line 41
extern  __attribute__((__nothrow__)) int __sigsetjmp(struct __jmp_buf_tag __env[1] ,
                                                     int __savemask ) ;
#line 45
extern  __attribute__((__nothrow__)) int _setjmp(struct __jmp_buf_tag __env[1] ) ;
#line 54
extern  __attribute__((__nothrow__)) void longjmp(struct __jmp_buf_tag __env[1] ,
                                                  int __val ) ;
#line 61
extern  __attribute__((__nothrow__)) void _longjmp(struct __jmp_buf_tag __env[1] ,
                                                   int __val ) ;
#line 80
extern  __attribute__((__nothrow__)) void siglongjmp(struct __jmp_buf_tag __env[1] ,
                                                     int __val ) ;
#line 924 "/usr/include/png.h"
extern png_uint_32 png_access_version_number(void) ;
#line 929
extern void png_set_sig_bytes(png_structrp png_ptr , int num_bytes ) ;
#line 936
extern int png_sig_cmp(png_const_bytep sig , size_t start , size_t num_to_check ) ;
#line 945
extern png_structp png_create_read_struct(png_const_charp user_png_ver , png_voidp error_ptr ,
                                          png_error_ptr error_fn , png_error_ptr warn_fn ) ;
#line 951
extern png_structp png_create_write_struct(png_const_charp user_png_ver , png_voidp error_ptr ,
                                           png_error_ptr error_fn , png_error_ptr warn_fn ) ;
#line 956
extern size_t png_get_compression_buffer_size(png_const_structrp png_ptr ) ;
#line 959
extern void png_set_compression_buffer_size(png_structrp png_ptr , size_t size ) ;
#line 973
extern jmp_buf *png_set_longjmp_fn(png_structrp png_ptr , png_longjmp_ptr longjmp_fn ,
                                   size_t jmp_buf_size ) ;
#line 986
extern void png_longjmp(png_const_structrp png_ptr , int val ) ;
#line 991
extern int png_reset_zstream(png_structrp png_ptr ) ;
#line 996
extern png_structp png_create_read_struct_2(png_const_charp user_png_ver , png_voidp error_ptr ,
                                            png_error_ptr error_fn , png_error_ptr warn_fn ,
                                            png_voidp mem_ptr , png_malloc_ptr malloc_fn ,
                                            png_free_ptr free_fn ) ;
#line 1001
extern png_structp png_create_write_struct_2(png_const_charp user_png_ver , png_voidp error_ptr ,
                                             png_error_ptr error_fn , png_error_ptr warn_fn ,
                                             png_voidp mem_ptr , png_malloc_ptr malloc_fn ,
                                             png_free_ptr free_fn ) ;
#line 1009
extern void png_write_sig(png_structrp png_ptr ) ;
#line 1012
extern void png_write_chunk(png_structrp png_ptr , png_const_bytep chunk_name , png_const_bytep data ,
                            size_t length ) ;
#line 1016
extern void png_write_chunk_start(png_structrp png_ptr , png_const_bytep chunk_name ,
                                  png_uint_32 length ) ;
#line 1020
extern void png_write_chunk_data(png_structrp png_ptr , png_const_bytep data , size_t length ) ;
#line 1024
extern void png_write_chunk_end(png_structrp png_ptr ) ;
#line 1027
extern png_infop png_create_info_struct(png_const_structrp png_ptr ) ;
#line 1034
extern void png_info_init_3(png_infopp info_ptr , size_t png_info_struct_size ) ;
#line 1038
extern void png_write_info_before_PLTE(png_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1040
extern void png_write_info(png_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1045
extern void png_read_info(png_structrp png_ptr , png_inforp info_ptr ) ;
#line 1056
extern png_const_charp png_convert_to_rfc1123(png_structrp png_ptr , png_const_timep ptime ) ;
#line 1059
extern int png_convert_to_rfc1123_buffer(char out[29] , png_const_timep ptime ) ;
#line 1065
extern void png_convert_from_struct_tm(png_timep ptime , struct tm *ttime ) ;
#line 1069
extern void png_convert_from_time_t(png_timep ptime , time_t ttime ) ;
#line 1074
extern void png_set_expand(png_structrp png_ptr ) ;
#line 1075
extern void png_set_expand_gray_1_2_4_to_8(png_structrp png_ptr ) ;
#line 1076
extern void png_set_palette_to_rgb(png_structrp png_ptr ) ;
#line 1077
extern void png_set_tRNS_to_alpha(png_structrp png_ptr ) ;
#line 1084
extern void png_set_expand_16(png_structrp png_ptr ) ;
#line 1089
extern void png_set_bgr(png_structrp png_ptr ) ;
#line 1094
extern void png_set_gray_to_rgb(png_structrp png_ptr ) ;
#line 1104
extern void png_set_rgb_to_gray(png_structrp png_ptr , int error_action , double red ,
                                double green ) ;
#line 1106
extern void png_set_rgb_to_gray_fixed(png_structrp png_ptr , int error_action , png_fixed_point red ,
                                      png_fixed_point green ) ;
#line 1109
extern png_byte png_get_rgb_to_gray_status(png_const_structrp png_ptr ) ;
#line 1114
extern void png_build_grayscale_palette(int bit_depth , png_colorp palette ) ;
#line 1160
extern void png_set_alpha_mode(png_structrp png_ptr , int mode , double output_gamma ) ;
#line 1162
extern void png_set_alpha_mode_fixed(png_structrp png_ptr , int mode , png_fixed_point output_gamma ) ;
#line 1253
extern void png_set_strip_alpha(png_structrp png_ptr ) ;
#line 1258
extern void png_set_swap_alpha(png_structrp png_ptr ) ;
#line 1263
extern void png_set_invert_alpha(png_structrp png_ptr ) ;
#line 1268
extern void png_set_filler(png_structrp png_ptr , png_uint_32 filler , int flags ) ;
#line 1274
extern void png_set_add_alpha(png_structrp png_ptr , png_uint_32 filler , int flags ) ;
#line 1280
extern void png_set_swap(png_structrp png_ptr ) ;
#line 1285
extern void png_set_packing(png_structrp png_ptr ) ;
#line 1291
extern void png_set_packswap(png_structrp png_ptr ) ;
#line 1296
extern void png_set_shift(png_structrp png_ptr , png_const_color_8p true_bits ) ;
#line 1308
extern int png_set_interlace_handling(png_structrp png_ptr ) ;
#line 1313
extern void png_set_invert_mono(png_structrp png_ptr ) ;
#line 1322
extern void png_set_background(png_structrp png_ptr , png_const_color_16p background_color ,
                               int background_gamma_code , int need_expand , double background_gamma ) ;
#line 1325
extern void png_set_background_fixed(png_structrp png_ptr , png_const_color_16p background_color ,
                                     int background_gamma_code , int need_expand ,
                                     png_fixed_point background_gamma ) ;
#line 1338
extern void png_set_scale_16(png_structrp png_ptr ) ;
#line 1344
extern void png_set_strip_16(png_structrp png_ptr ) ;
#line 1351
extern void png_set_quantize(png_structrp png_ptr , png_colorp palette , int num_palette ,
                             int maximum_colors , png_const_uint_16p histogram , int full_quantize ) ;
#line 1373
extern void png_set_gamma(png_structrp png_ptr , double screen_gamma , double override_file_gamma ) ;
#line 1375
extern void png_set_gamma_fixed(png_structrp png_ptr , png_fixed_point screen_gamma ,
                                png_fixed_point override_file_gamma ) ;
#line 1381
extern void png_set_flush(png_structrp png_ptr , int nrows ) ;
#line 1383
extern void png_write_flush(png_structrp png_ptr ) ;
#line 1387
extern void png_start_read_image(png_structrp png_ptr ) ;
#line 1390
extern void png_read_update_info(png_structrp png_ptr , png_inforp info_ptr ) ;
#line 1395
extern void png_read_rows(png_structrp png_ptr , png_bytepp row , png_bytepp display_row ,
                          png_uint_32 num_rows ) ;
#line 1401
extern void png_read_row(png_structrp png_ptr , png_bytep row , png_bytep display_row ) ;
#line 1407
extern void png_read_image(png_structrp png_ptr , png_bytepp image ) ;
#line 1411
extern void png_write_row(png_structrp png_ptr , png_const_bytep row ) ;
#line 1419
extern void png_write_rows(png_structrp png_ptr , png_bytepp row , png_uint_32 num_rows ) ;
#line 1423
extern void png_write_image(png_structrp png_ptr , png_bytepp image ) ;
#line 1426
extern void png_write_end(png_structrp png_ptr , png_inforp info_ptr ) ;
#line 1431
extern void png_read_end(png_structrp png_ptr , png_inforp info_ptr ) ;
#line 1435
extern void png_destroy_info_struct(png_const_structrp png_ptr , png_infopp info_ptr_ptr ) ;
#line 1439
extern void png_destroy_read_struct(png_structpp png_ptr_ptr , png_infopp info_ptr_ptr ,
                                    png_infopp end_info_ptr_ptr ) ;
#line 1443
extern void png_destroy_write_struct(png_structpp png_ptr_ptr , png_infopp info_ptr_ptr ) ;
#line 1447
extern void png_set_crc_action(png_structrp png_ptr , int crit_action , int ancil_action ) ;
#line 1478
extern void png_set_filter(png_structrp png_ptr , int method , int filters ) ;
#line 1508
extern void png_set_filter_heuristics(png_structrp png_ptr , int heuristic_method ,
                                      int num_weights , png_const_doublep filter_weights ,
                                      png_const_doublep filter_costs ) ;
#line 1511
extern void png_set_filter_heuristics_fixed(png_structrp png_ptr , int heuristic_method ,
                                            int num_weights , png_const_fixed_point_p filter_weights ,
                                            png_const_fixed_point_p filter_costs ) ;
#line 1531
extern void png_set_compression_level(png_structrp png_ptr , int level ) ;
#line 1534
extern void png_set_compression_mem_level(png_structrp png_ptr , int mem_level ) ;
#line 1537
extern void png_set_compression_strategy(png_structrp png_ptr , int strategy ) ;
#line 1543
extern void png_set_compression_window_bits(png_structrp png_ptr , int window_bits ) ;
#line 1546
extern void png_set_compression_method(png_structrp png_ptr , int method ) ;
#line 1552
extern void png_set_text_compression_level(png_structrp png_ptr , int level ) ;
#line 1555
extern void png_set_text_compression_mem_level(png_structrp png_ptr , int mem_level ) ;
#line 1558
extern void png_set_text_compression_strategy(png_structrp png_ptr , int strategy ) ;
#line 1564
extern void png_set_text_compression_window_bits(png_structrp png_ptr , int window_bits ) ;
#line 1567
extern void png_set_text_compression_method(png_structrp png_ptr , int method ) ;
#line 1583
extern void png_init_io(png_structrp png_ptr , png_FILE_p fp ) ;
#line 1594
extern void png_set_error_fn(png_structrp png_ptr , png_voidp error_ptr , png_error_ptr error_fn ,
                             png_error_ptr warning_fn ) ;
#line 1598
extern png_voidp png_get_error_ptr(png_const_structrp png_ptr ) ;
#line 1610
extern void png_set_write_fn(png_structrp png_ptr , png_voidp io_ptr , png_rw_ptr write_data_fn ,
                             png_flush_ptr output_flush_fn ) ;
#line 1614
extern void png_set_read_fn(png_structrp png_ptr , png_voidp io_ptr , png_rw_ptr read_data_fn ) ;
#line 1618
extern png_voidp png_get_io_ptr(png_const_structrp png_ptr ) ;
#line 1620
extern void png_set_read_status_fn(png_structrp png_ptr , png_read_status_ptr read_row_fn ) ;
#line 1623
extern void png_set_write_status_fn(png_structrp png_ptr , png_write_status_ptr write_row_fn ) ;
#line 1628
extern void png_set_mem_fn(png_structrp png_ptr , png_voidp mem_ptr , png_malloc_ptr malloc_fn ,
                           png_free_ptr free_fn ) ;
#line 1631
extern png_voidp png_get_mem_ptr(png_const_structrp png_ptr ) ;
#line 1635
extern void png_set_read_user_transform_fn(png_structrp png_ptr , png_user_transform_ptr read_user_transform_fn ) ;
#line 1640
extern void png_set_write_user_transform_fn(png_structrp png_ptr , png_user_transform_ptr write_user_transform_fn ) ;
#line 1645
extern void png_set_user_transform_info(png_structrp png_ptr , png_voidp user_transform_ptr ,
                                        int user_transform_depth , int user_transform_channels ) ;
#line 1649
extern png_voidp png_get_user_transform_ptr(png_const_structrp png_ptr ) ;
#line 1665
extern png_uint_32 png_get_current_row_number(png_const_structrp  ) ;
#line 1666
extern png_byte png_get_current_pass_number(png_const_structrp  ) ;
#line 1689
extern void png_set_read_user_chunk_fn(png_structrp png_ptr , png_voidp user_chunk_ptr ,
                                       png_user_chunk_ptr read_user_chunk_fn ) ;
#line 1694
extern png_voidp png_get_user_chunk_ptr(png_const_structrp png_ptr ) ;
#line 1701
extern void png_set_progressive_read_fn(png_structrp png_ptr , png_voidp progressive_ptr ,
                                        png_progressive_info_ptr info_fn , png_progressive_row_ptr row_fn ,
                                        png_progressive_end_ptr end_fn ) ;
#line 1706
extern png_voidp png_get_progressive_ptr(png_const_structrp png_ptr ) ;
#line 1710
extern void png_process_data(png_structrp png_ptr , png_inforp info_ptr , png_bytep buffer ,
                             size_t buffer_size ) ;
#line 1720
extern size_t png_process_data_pause(png_structrp  , int save ) ;
#line 1728
extern png_uint_32 png_process_data_skip(png_structrp  ) ;
#line 1735
extern void png_progressive_combine_row(png_const_structrp png_ptr , png_bytep old_row ,
                                        png_const_bytep new_row ) ;
#line 1739
extern png_voidp png_malloc(png_const_structrp png_ptr , png_alloc_size_t size ) ;
#line 1742
extern png_voidp png_calloc(png_const_structrp png_ptr , png_alloc_size_t size ) ;
#line 1746
extern png_voidp png_malloc_warn(png_const_structrp png_ptr , png_alloc_size_t size ) ;
#line 1750
extern void png_free(png_const_structrp png_ptr , png_voidp ptr ) ;
#line 1753
extern void png_free_data(png_const_structrp png_ptr , png_inforp info_ptr , png_uint_32 free_me ,
                          int num ) ;
#line 1763
extern void png_data_freer(png_const_structrp png_ptr , png_inforp info_ptr , int freer ,
                           png_uint_32 mask ) ;
#line 1789
extern png_voidp png_malloc_default(png_const_structrp png_ptr , png_alloc_size_t size ) ;
#line 1791
extern void png_free_default(png_const_structrp png_ptr , png_voidp ptr ) ;
#line 1797
extern void png_error(png_const_structrp png_ptr , png_const_charp error_message ) ;
#line 1801
extern void png_chunk_error(png_const_structrp png_ptr , png_const_charp error_message ) ;
#line 1813
extern void png_warning(png_const_structrp png_ptr , png_const_charp warning_message ) ;
#line 1817
extern void png_chunk_warning(png_const_structrp png_ptr , png_const_charp warning_message ) ;
#line 1827
extern void png_benign_error(png_const_structrp png_ptr , png_const_charp warning_message ) ;
#line 1832
extern void png_chunk_benign_error(png_const_structrp png_ptr , png_const_charp warning_message ) ;
#line 1836
extern void png_set_benign_errors(png_structrp png_ptr , int allowed ) ;
#line 1861
extern png_uint_32 png_get_valid(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                 png_uint_32 flag ) ;
#line 1865
extern size_t png_get_rowbytes(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1872
extern png_bytepp png_get_rows(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1878
extern void png_set_rows(png_const_structrp png_ptr , png_inforp info_ptr , png_bytepp row_pointers ) ;
#line 1883
extern png_byte png_get_channels(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1888
extern png_uint_32 png_get_image_width(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1892
extern png_uint_32 png_get_image_height(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1896
extern png_byte png_get_bit_depth(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1900
extern png_byte png_get_color_type(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1904
extern png_byte png_get_filter_type(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1908
extern png_byte png_get_interlace_type(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1912
extern png_byte png_get_compression_type(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1916
extern png_uint_32 png_get_pixels_per_meter(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1918
extern png_uint_32 png_get_x_pixels_per_meter(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1920
extern png_uint_32 png_get_y_pixels_per_meter(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1924
extern float png_get_pixel_aspect_ratio(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1926
extern png_fixed_point png_get_pixel_aspect_ratio_fixed(png_const_structrp png_ptr ,
                                                        png_const_inforp info_ptr ) ;
#line 1930
extern png_int_32 png_get_x_offset_pixels(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1932
extern png_int_32 png_get_y_offset_pixels(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1934
extern png_int_32 png_get_x_offset_microns(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1936
extern png_int_32 png_get_y_offset_microns(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1943
extern png_const_bytep png_get_signature(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1948
extern png_uint_32 png_get_bKGD(png_const_structrp png_ptr , png_inforp info_ptr ,
                                png_color_16p *background ) ;
#line 1953
extern void png_set_bKGD(png_const_structrp png_ptr , png_inforp info_ptr , png_const_color_16p background ) ;
#line 1958
extern png_uint_32 png_get_cHRM(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                double *white_x , double *white_y , double *red_x ,
                                double *red_y , double *green_x , double *green_y ,
                                double *blue_x , double *blue_y ) ;
#line 1962
extern png_uint_32 png_get_cHRM_XYZ(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                    double *red_X , double *red_Y , double *red_Z ,
                                    double *green_X , double *green_Y , double *green_Z ,
                                    double *blue_X , double *blue_Y , double *blue_Z ) ;
#line 1966
extern png_uint_32 png_get_cHRM_fixed(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                      png_fixed_point *int_white_x , png_fixed_point *int_white_y ,
                                      png_fixed_point *int_red_x , png_fixed_point *int_red_y ,
                                      png_fixed_point *int_green_x , png_fixed_point *int_green_y ,
                                      png_fixed_point *int_blue_x , png_fixed_point *int_blue_y ) ;
#line 1972
extern png_uint_32 png_get_cHRM_XYZ_fixed(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                          png_fixed_point *int_red_X , png_fixed_point *int_red_Y ,
                                          png_fixed_point *int_red_Z , png_fixed_point *int_green_X ,
                                          png_fixed_point *int_green_Y , png_fixed_point *int_green_Z ,
                                          png_fixed_point *int_blue_X , png_fixed_point *int_blue_Y ,
                                          png_fixed_point *int_blue_Z ) ;
#line 1982
extern void png_set_cHRM(png_const_structrp png_ptr , png_inforp info_ptr , double white_x ,
                         double white_y , double red_x , double red_y , double green_x ,
                         double green_y , double blue_x , double blue_y ) ;
#line 1986
extern void png_set_cHRM_XYZ(png_const_structrp png_ptr , png_inforp info_ptr , double red_X ,
                             double red_Y , double red_Z , double green_X , double green_Y ,
                             double green_Z , double blue_X , double blue_Y , double blue_Z ) ;
#line 1990
extern void png_set_cHRM_fixed(png_const_structrp png_ptr , png_inforp info_ptr ,
                               png_fixed_point int_white_x , png_fixed_point int_white_y ,
                               png_fixed_point int_red_x , png_fixed_point int_red_y ,
                               png_fixed_point int_green_x , png_fixed_point int_green_y ,
                               png_fixed_point int_blue_x , png_fixed_point int_blue_y ) ;
#line 1996
extern void png_set_cHRM_XYZ_fixed(png_const_structrp png_ptr , png_inforp info_ptr ,
                                   png_fixed_point int_red_X , png_fixed_point int_red_Y ,
                                   png_fixed_point int_red_Z , png_fixed_point int_green_X ,
                                   png_fixed_point int_green_Y , png_fixed_point int_green_Z ,
                                   png_fixed_point int_blue_X , png_fixed_point int_blue_Y ,
                                   png_fixed_point int_blue_Z ) ;
#line 2005
extern png_uint_32 png_get_eXIf(png_const_structrp png_ptr , png_inforp info_ptr ,
                                png_bytep *exif ) ;
#line 2007
extern void png_set_eXIf(png_const_structrp png_ptr , png_inforp info_ptr , png_bytep exif ) ;
#line 2010
extern png_uint_32 png_get_eXIf_1(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                  png_uint_32 *num_exif , png_bytep *exif ) ;
#line 2012
extern void png_set_eXIf_1(png_const_structrp png_ptr , png_inforp info_ptr , png_uint_32 num_exif ,
                           png_bytep exif ) ;
#line 2017
extern png_uint_32 png_get_gAMA(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                double *file_gamma ) ;
#line 2019
extern png_uint_32 png_get_gAMA_fixed(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                      png_fixed_point *int_file_gamma ) ;
#line 2025
extern void png_set_gAMA(png_const_structrp png_ptr , png_inforp info_ptr , double file_gamma ) ;
#line 2027
extern void png_set_gAMA_fixed(png_const_structrp png_ptr , png_inforp info_ptr ,
                               png_fixed_point int_file_gamma ) ;
#line 2032
extern png_uint_32 png_get_hIST(png_const_structrp png_ptr , png_inforp info_ptr ,
                                png_uint_16p *hist ) ;
#line 2034
extern void png_set_hIST(png_const_structrp png_ptr , png_inforp info_ptr , png_const_uint_16p hist ) ;
#line 2038
extern png_uint_32 png_get_IHDR(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                png_uint_32 *width , png_uint_32 *height , int *bit_depth ,
                                int *color_type , int *interlace_method , int *compression_method ,
                                int *filter_method ) ;
#line 2043
extern void png_set_IHDR(png_const_structrp png_ptr , png_inforp info_ptr , png_uint_32 width ,
                         png_uint_32 height , int bit_depth , int color_type , int interlace_method ,
                         int compression_method , int filter_method ) ;
#line 2049
extern png_uint_32 png_get_oFFs(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                png_int_32 *offset_x , png_int_32 *offset_y , int *unit_type ) ;
#line 2055
extern void png_set_oFFs(png_const_structrp png_ptr , png_inforp info_ptr , png_int_32 offset_x ,
                         png_int_32 offset_y , int unit_type ) ;
#line 2061
extern png_uint_32 png_get_pCAL(png_const_structrp png_ptr , png_inforp info_ptr ,
                                png_charp *purpose , png_int_32 *X0 , png_int_32 *X1 ,
                                int *type , int *nparams , png_charp *units , png_charpp *params ) ;
#line 2068
extern void png_set_pCAL(png_const_structrp png_ptr , png_inforp info_ptr , png_const_charp purpose ,
                         png_int_32 X0 , png_int_32 X1 , int type , int nparams ,
                         png_const_charp units , png_charpp params ) ;
#line 2074
extern png_uint_32 png_get_pHYs(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                png_uint_32 *res_x , png_uint_32 *res_y , int *unit_type ) ;
#line 2080
extern void png_set_pHYs(png_const_structrp png_ptr , png_inforp info_ptr , png_uint_32 res_x ,
                         png_uint_32 res_y , int unit_type ) ;
#line 2084
extern png_uint_32 png_get_PLTE(png_const_structrp png_ptr , png_inforp info_ptr ,
                                png_colorp *palette , int *num_palette ) ;
#line 2087
extern void png_set_PLTE(png_structrp png_ptr , png_inforp info_ptr , png_const_colorp palette ,
                         int num_palette ) ;
#line 2091
extern png_uint_32 png_get_sBIT(png_const_structrp png_ptr , png_inforp info_ptr ,
                                png_color_8p *sig_bit ) ;
#line 2096
extern void png_set_sBIT(png_const_structrp png_ptr , png_inforp info_ptr , png_const_color_8p sig_bit ) ;
#line 2101
extern png_uint_32 png_get_sRGB(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                int *file_srgb_intent ) ;
#line 2106
extern void png_set_sRGB(png_const_structrp png_ptr , png_inforp info_ptr , int srgb_intent ) ;
#line 2108
extern void png_set_sRGB_gAMA_and_cHRM(png_const_structrp png_ptr , png_inforp info_ptr ,
                                       int srgb_intent ) ;
#line 2113
extern png_uint_32 png_get_iCCP(png_const_structrp png_ptr , png_inforp info_ptr ,
                                png_charpp name , int *compression_type , png_bytepp profile ,
                                png_uint_32 *proflen ) ;
#line 2119
extern void png_set_iCCP(png_const_structrp png_ptr , png_inforp info_ptr , png_const_charp name ,
                         int compression_type , png_const_bytep profile , png_uint_32 proflen ) ;
#line 2125
extern int png_get_sPLT(png_const_structrp png_ptr , png_inforp info_ptr , png_sPLT_tpp entries ) ;
#line 2130
extern void png_set_sPLT(png_const_structrp png_ptr , png_inforp info_ptr , png_const_sPLT_tp entries ,
                         int nentries ) ;
#line 2136
extern int png_get_text(png_const_structrp png_ptr , png_inforp info_ptr , png_textp *text_ptr ,
                        int *num_text ) ;
#line 2148
extern void png_set_text(png_const_structrp png_ptr , png_inforp info_ptr , png_const_textp text_ptr ,
                         int num_text ) ;
#line 2153
extern png_uint_32 png_get_tIME(png_const_structrp png_ptr , png_inforp info_ptr ,
                                png_timep *mod_time ) ;
#line 2158
extern void png_set_tIME(png_const_structrp png_ptr , png_inforp info_ptr , png_const_timep mod_time ) ;
#line 2163
extern png_uint_32 png_get_tRNS(png_const_structrp png_ptr , png_inforp info_ptr ,
                                png_bytep *trans_alpha , int *num_trans , png_color_16p *trans_color ) ;
#line 2169
extern void png_set_tRNS(png_structrp png_ptr , png_inforp info_ptr , png_const_bytep trans_alpha ,
                         int num_trans , png_const_color_16p trans_color ) ;
#line 2175
extern png_uint_32 png_get_sCAL(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                int *unit , double *width , double *height ) ;
#line 2184
extern png_uint_32 png_get_sCAL_fixed(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                      int *unit , png_fixed_point *width , png_fixed_point *height ) ;
#line 2188
extern png_uint_32 png_get_sCAL_s(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                  int *unit , png_charpp swidth , png_charpp sheight ) ;
#line 2192
extern void png_set_sCAL(png_const_structrp png_ptr , png_inforp info_ptr , int unit ,
                         double width , double height ) ;
#line 2194
extern void png_set_sCAL_fixed(png_const_structrp png_ptr , png_inforp info_ptr ,
                               int unit , png_fixed_point width , png_fixed_point height ) ;
#line 2197
extern void png_set_sCAL_s(png_const_structrp png_ptr , png_inforp info_ptr , int unit ,
                           png_const_charp swidth , png_const_charp sheight ) ;
#line 2302
extern void png_set_keep_unknown_chunks(png_structrp png_ptr , int keep , png_const_bytep chunk_list ,
                                        int num_chunks ) ;
#line 2310
extern int png_handle_as_unknown(png_const_structrp png_ptr , png_const_bytep chunk_name ) ;
#line 2315
extern void png_set_unknown_chunks(png_const_structrp png_ptr , png_inforp info_ptr ,
                                   png_const_unknown_chunkp unknowns , int num_unknowns ) ;
#line 2327
extern void png_set_unknown_chunk_location(png_const_structrp png_ptr , png_inforp info_ptr ,
                                           int chunk , int location ) ;
#line 2330
extern int png_get_unknown_chunks(png_const_structrp png_ptr , png_inforp info_ptr ,
                                  png_unknown_chunkpp entries ) ;
#line 2338
extern void png_set_invalid(png_const_structrp png_ptr , png_inforp info_ptr , int mask ) ;
#line 2344
extern void png_read_png(png_structrp png_ptr , png_inforp info_ptr , int transforms ,
                         png_voidp params ) ;
#line 2348
extern void png_write_png(png_structrp png_ptr , png_inforp info_ptr , int transforms ,
                          png_voidp params ) ;
#line 2353
extern png_const_charp png_get_copyright(png_const_structrp png_ptr ) ;
#line 2355
extern png_const_charp png_get_header_ver(png_const_structrp png_ptr ) ;
#line 2357
extern png_const_charp png_get_header_version(png_const_structrp png_ptr ) ;
#line 2359
extern png_const_charp png_get_libpng_ver(png_const_structrp png_ptr ) ;
#line 2363
extern png_uint_32 png_permit_mng_features(png_structrp png_ptr , png_uint_32 mng_features_permitted ) ;
#line 2384
extern void png_set_user_limits(png_structrp png_ptr , png_uint_32 user_width_max ,
                                png_uint_32 user_height_max ) ;
#line 2386
extern png_uint_32 png_get_user_width_max(png_const_structrp png_ptr ) ;
#line 2388
extern png_uint_32 png_get_user_height_max(png_const_structrp png_ptr ) ;
#line 2391
extern void png_set_chunk_cache_max(png_structrp png_ptr , png_uint_32 user_chunk_cache_max ) ;
#line 2393
extern png_uint_32 png_get_chunk_cache_max(png_const_structrp png_ptr ) ;
#line 2396
extern void png_set_chunk_malloc_max(png_structrp png_ptr , png_alloc_size_t user_chunk_cache_max ) ;
#line 2398
extern png_alloc_size_t png_get_chunk_malloc_max(png_const_structrp png_ptr ) ;
#line 2403
extern png_uint_32 png_get_pixels_per_inch(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 2406
extern png_uint_32 png_get_x_pixels_per_inch(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 2409
extern png_uint_32 png_get_y_pixels_per_inch(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 2412
extern float png_get_x_offset_inches(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 2415
extern png_fixed_point png_get_x_offset_inches_fixed(png_const_structrp png_ptr ,
                                                     png_const_inforp info_ptr ) ;
#line 2419
extern float png_get_y_offset_inches(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 2422
extern png_fixed_point png_get_y_offset_inches_fixed(png_const_structrp png_ptr ,
                                                     png_const_inforp info_ptr ) ;
#line 2427
extern png_uint_32 png_get_pHYs_dpi(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                    png_uint_32 *res_x , png_uint_32 *res_y , int *unit_type ) ;
#line 2435
extern png_uint_32 png_get_io_state(png_const_structrp png_ptr ) ;
#line 2441
extern png_uint_32 png_get_io_chunk_type(png_const_structrp png_ptr ) ;
#line 2567
extern png_uint_32 png_get_uint_32(png_const_bytep buf ) ;
#line 2568
extern png_uint_16 png_get_uint_16(png_const_bytep buf ) ;
#line 2569
extern png_int_32 png_get_int_32(png_const_bytep buf ) ;
#line 2572
extern png_uint_32 png_get_uint_31(png_const_structrp png_ptr , png_const_bytep buf ) ;
#line 2578
extern void png_save_uint_32(png_bytep buf , png_uint_32 i ) ;
#line 2581
extern void png_save_int_32(png_bytep buf , png_int_32 i ) ;
#line 2589
extern void png_save_uint_16(png_bytep buf , unsigned int i ) ;
#line 2635
extern void png_set_check_for_invalid_index(png_structrp png_ptr , int allowed ) ;
#line 2638
extern int png_get_palette_max(png_const_structp png_ptr , png_const_infop info_ptr ) ;
#line 3003
extern int png_image_begin_read_from_file(png_imagep image , char const   *file_name ) ;
#line 3009
extern int png_image_begin_read_from_stdio(png_imagep image , FILE *file ) ;
#line 3014
extern int png_image_begin_read_from_memory(png_imagep image , png_const_voidp memory ,
                                            size_t size ) ;
#line 3018
extern int png_image_finish_read(png_imagep image , png_const_colorp background ,
                                 void *buffer , png_int_32 row_stride , void *colormap ) ;
#line 3053
extern void png_image_free(png_imagep image ) ;
#line 3077
extern int png_image_write_to_file(png_imagep image , char const   *file , int convert_to_8bit ,
                                   void const   *buffer , png_int_32 row_stride ,
                                   void const   *colormap ) ;
#line 3082
extern int png_image_write_to_stdio(png_imagep image , FILE *file , int convert_to_8_bit ,
                                    void const   *buffer , png_int_32 row_stride ,
                                    void const   *colormap ) ;
#line 3109
extern int png_image_write_to_memory(png_imagep image , void *memory , png_alloc_size_t *memory_bytes ,
                                     int convert_to_8_bit , void const   *buffer ,
                                     png_int_32 row_stride , void const   *colormap ) ;
#line 3245
extern int png_set_option(png_structrp png_ptr , int option , int onoff ) ;
#line 3253
extern png_uint_32 png_get_acTL(png_structp png_ptr , png_infop info_ptr , png_uint_32 *num_frames ,
                                png_uint_32 *num_plays ) ;
#line 3256
extern png_uint_32 png_set_acTL(png_structp png_ptr , png_infop info_ptr , png_uint_32 num_frames ,
                                png_uint_32 num_plays ) ;
#line 3259
extern png_uint_32 png_get_num_frames(png_structp png_ptr , png_infop info_ptr ) ;
#line 3262
extern png_uint_32 png_get_num_plays(png_structp png_ptr , png_infop info_ptr ) ;
#line 3265
extern png_uint_32 png_get_next_frame_fcTL(png_structp png_ptr , png_infop info_ptr ,
                                           png_uint_32 *width , png_uint_32 *height ,
                                           png_uint_32 *x_offset , png_uint_32 *y_offset ,
                                           png_uint_16 *delay_num , png_uint_16 *delay_den ,
                                           png_byte *dispose_op , png_byte *blend_op ) ;
#line 3271
extern png_uint_32 png_set_next_frame_fcTL(png_structp png_ptr , png_infop info_ptr ,
                                           png_uint_32 width , png_uint_32 height ,
                                           png_uint_32 x_offset , png_uint_32 y_offset ,
                                           png_uint_16 delay_num , png_uint_16 delay_den ,
                                           png_byte dispose_op , png_byte blend_op ) ;
#line 3277
extern png_uint_32 png_get_next_frame_width(png_structp png_ptr , png_infop info_ptr ) ;
#line 3279
extern png_uint_32 png_get_next_frame_height(png_structp png_ptr , png_infop info_ptr ) ;
#line 3281
extern png_uint_32 png_get_next_frame_x_offset(png_structp png_ptr , png_infop info_ptr ) ;
#line 3283
extern png_uint_32 png_get_next_frame_y_offset(png_structp png_ptr , png_infop info_ptr ) ;
#line 3285
extern png_uint_16 png_get_next_frame_delay_num(png_structp png_ptr , png_infop info_ptr ) ;
#line 3287
extern png_uint_16 png_get_next_frame_delay_den(png_structp png_ptr , png_infop info_ptr ) ;
#line 3289
extern png_byte png_get_next_frame_dispose_op(png_structp png_ptr , png_infop info_ptr ) ;
#line 3291
extern png_byte png_get_next_frame_blend_op(png_structp png_ptr , png_infop info_ptr ) ;
#line 3293
extern png_byte png_get_first_frame_is_hidden(png_structp png_ptr , png_infop info_ptr ) ;
#line 3295
extern png_uint_32 png_set_first_frame_is_hidden(png_structp png_ptr , png_infop info_ptr ,
                                                 png_byte is_hidden ) ;
#line 3299
extern void png_read_frame_head(png_structp png_ptr , png_infop info_ptr ) ;
#line 3302
extern void png_set_progressive_frame_fn(png_structp png_ptr , png_progressive_frame_ptr frame_info_fn ,
                                         png_progressive_frame_ptr frame_end_fn ) ;
#line 3309
extern void png_write_frame_head(png_structp png_ptr , png_infop info_ptr , png_bytepp row_pointers ,
                                 png_uint_32 width , png_uint_32 height , png_uint_32 x_offset ,
                                 png_uint_32 y_offset , png_uint_16 delay_num , png_uint_16 delay_den ,
                                 png_byte dispose_op , png_byte blend_op ) ;
#line 3316
extern void png_write_frame_tail(png_structp png_ptr , png_infop info_ptr ) ;
#line 35 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-png.c"
static png_bytep *read_png(png_structp png_ptr , png_infop info_ptr , at_input_opts_type *opts ) ;
#line 42 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-png.c"
static void handle_warning(png_structp png , gchar *message ) 
{ 
  png_voidp __cil_tmp3 ;

  {
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if (logging) {
      {
#line 44
      fprintf(stdout, "PNG warning: %s", message);
      }
    }
#line 44
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 45
  __cil_tmp3 = png_get_error_ptr(png);
#line 45
  at_exception_warning((at_exception_type *)__cil_tmp3, message);
  }
  return;
}
}
#line 50 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-png.c"
static void handle_error(png_structp png , gchar *message ) 
{ 
  png_voidp __cil_tmp3 ;

  {
  {
#line 52
  while (1) {
    while_continue: /* CIL Label */ ;
#line 52
    if (logging) {
      {
#line 52
      fprintf(stdout, "PNG error: %s", message);
      }
    }
#line 52
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 53
  __cil_tmp3 = png_get_error_ptr(png);
#line 53
  at_exception_fatal((at_exception_type *)__cil_tmp3, message);
  }
  return;
}
}
#line 59 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-png.c"
static void finalize_structs(png_structp png , png_infop info , png_infop end_info ) 
{ 
  png_structp *tmp ;
  png_infop *tmp___0 ;
  png_infop *tmp___1 ;

  {
#line 61
  if (png) {
#line 61
    tmp = & png;
  } else {
#line 61
    tmp = (png_structp *)((void *)0);
  }
#line 61
  if (info) {
#line 61
    tmp___0 = & info;
  } else {
#line 61
    tmp___0 = (png_infop *)((void *)0);
  }
#line 61
  if (end_info) {
#line 61
    tmp___1 = & end_info;
  } else {
#line 61
    tmp___1 = (png_infop *)((void *)0);
  }
  {
#line 61
  png_destroy_read_struct(tmp, tmp___0, tmp___1);
  }
  return;
}
}
#line 64 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-png.c"
static int init_structs(png_structp *png , png_infop *info , png_infop *end_info ,
                        at_exception_type *exp___0 ) 
{ 
  png_structp __cil_tmp5 ;
  png_infop __cil_tmp6 ;
  png_infop __cil_tmp7 ;

  {
  {
#line 66
  *png = (png_structp )((void *)0);
#line 67
  *end_info = (png_infop )((void *)0);
#line 67
  *info = *end_info;
#line 69
  *png = png_create_read_struct("1.6.37", exp___0, (png_error_ptr )(& handle_error),
                                (png_error_ptr )(& handle_warning));
  }
#line 71
  if (*png) {
    {
#line 72
    *info = png_create_info_struct(*png);
    }
#line 73
    if (*info) {
      {
#line 74
      *end_info = png_create_info_struct(*png);
      }
#line 75
      if (*end_info) {
#line 76
        return (1);
      }
    }
    {
#line 78
    finalize_structs(*png, *info, *end_info);
    }
  }
#line 80
  return (0);
}
}
#line 89 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-png.c"
static int load_image(at_bitmap *image , FILE *stream , at_input_opts_type *opts ,
                      at_exception_type *exp___0 ) 
{ 
  png_structp png ;
  png_infop info ;
  png_infop end_info ;
  png_bytep *rows ;
  unsigned short width ;
  unsigned short height ;
  unsigned short row ;
  int pixel_size ;
  int result ;
  int __cil_tmp14 ;
  gboolean __cil_tmp15 ;
  png_bytep *__cil_tmp16 ;
  png_uint_32 __cil_tmp17 ;
  png_uint_32 __cil_tmp18 ;
  png_byte __cil_tmp19 ;
  at_bitmap __cil_tmp20 ;
  unsigned short __cil_tmp21 ;
  png_bytep *__cil_tmp22 ;

  {
  {
#line 96
  result = 1;
#line 98
  __cil_tmp14 = init_structs(& png, & info, & end_info, exp___0);
  }
#line 98
  if (! __cil_tmp14) {
#line 99
    return (0);
  }
  {
#line 101
  png_init_io(png, stream);
  }
  {
#line 102
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 102
    __cil_tmp15 = at_exception_got_fatal(exp___0);
    }
#line 102
    if (__cil_tmp15) {
#line 102
      result = 0;
#line 102
      goto cleanup;
    }
#line 102
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 104
  rows = read_png(png, info, opts);
#line 106
  __cil_tmp17 = png_get_image_width(png, info);
#line 106
  width = (unsigned short )__cil_tmp17;
#line 107
  __cil_tmp18 = png_get_image_height(png, info);
#line 107
  height = (unsigned short )__cil_tmp18;
#line 108
  __cil_tmp19 = png_get_color_type(png, info);
  }
#line 108
  if ((int )__cil_tmp19 == 0) {
#line 109
    pixel_size = 1;
  } else {
#line 111
    pixel_size = 3;
  }
  {
#line 114
  *image = at_bitmap_init((unsigned char *)((void *)0), width, height, (unsigned int )pixel_size);
#line 115
  row = (unsigned short )0;
  }
  {
#line 115
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 115
    if (! ((int )row < (int )height)) {
#line 115
      goto while_break___0;
    }
    {
#line 116
    memcpy((image->bitmap + ((unsigned int )row * image->np) * (unsigned int )image->width) + 0U,
           *rows, (unsigned long )((int )width * pixel_size) * sizeof(unsigned char ));
    }
#line 115
    __cil_tmp22 = rows;
#line 115
    rows ++;
#line 115
    __cil_tmp21 = row;
#line 115
    row ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  cleanup: 
  {
#line 119
  finalize_structs(png, info, end_info);
  }
#line 120
  return (result);
}
}
#line 123 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-png.c"
at_bitmap input_png_reader(gchar *filename , at_input_opts_type *opts , at_msg_func msg_func ,
                           gpointer msg_data , gpointer user_data ) 
{ 
  FILE *stream ;
  at_bitmap image ;
  at_bitmap __cil_tmp8 ;
  at_exception_type exp___0 ;
  at_exception_type __cil_tmp10 ;
  FILE *__cil_tmp11 ;

  {
  {
#line 126
  __cil_tmp8 = at_bitmap_init((unsigned char *)0, (unsigned short )0, (unsigned short )0,
                              (unsigned int )1);
#line 126
  image = __cil_tmp8;
#line 127
  __cil_tmp10 = at_exception_new(msg_func, msg_data);
#line 127
  exp___0 = __cil_tmp10;
#line 129
  stream = fopen((char const   *)filename, "rb");
  }
#line 130
  if (! stream) {
    {
#line 131
    while (1) {
      while_continue: /* CIL Label */ ;
#line 131
      if (logging) {
        {
#line 131
        fprintf(stdout, "Can\'t open \"%s\"\n\230\001", filename);
        }
      }
#line 131
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 132
    at_exception_fatal(& exp___0, (gchar *)"Cannot open input png file");
    }
#line 133
    return (image);
  }
  {
#line 136
  load_image(& image, stream, opts, & exp___0);
#line 137
  fclose(stream);
  }
#line 139
  return (image);
}
}
#line 142 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-png.c"
static png_bytep *read_png(png_structp png_ptr , png_infop info_ptr , at_input_opts_type *opts ) 
{ 
  png_color_16p original_bg ;
  png_color_16 my_bg ;
  png_byte __cil_tmp6 ;
  png_byte __cil_tmp7 ;
  png_uint_32 __cil_tmp8 ;
  png_uint_32 __cil_tmp9 ;
  png_bytepp __cil_tmp10 ;

  {
  {
#line 147
  png_read_info(png_ptr, info_ptr);
#line 149
  png_set_strip_16(png_ptr);
#line 150
  png_set_packing(png_ptr);
#line 151
  __cil_tmp8 = png_get_valid(png_ptr, info_ptr, 16U);
  }
  {
#line 151
  __cil_tmp7 = png_get_color_type(png_ptr, info_ptr);
  }
  {
#line 151
  __cil_tmp6 = png_get_bit_depth(png_ptr, info_ptr);
  }
#line 151
  if ((int )__cil_tmp6 < 8) {
    {
    {
    {
#line 152
    png_set_expand(png_ptr);
    }
    }
    }
  } else
#line 151
  if ((int )__cil_tmp7 == 3) {
    {
    {
    {
#line 152
    png_set_expand(png_ptr);
    }
    }
    }
  } else
#line 151
  if (__cil_tmp8) {
    {
    {
    {
#line 152
    png_set_expand(png_ptr);
    }
    }
    }
  }
  {
#line 154
  __cil_tmp9 = png_get_bKGD(png_ptr, info_ptr, & original_bg);
  }
#line 154
  if (__cil_tmp9) {
#line 156
    my_bg.index = (png_byte )0;
#line 158
    if (opts) {
#line 158
      if (opts->background_color) {
#line 159
        my_bg.red = (png_uint_16 )(256 * (int )(opts->background_color)->r);
#line 160
        my_bg.green = (png_uint_16 )(256 * (int )(opts->background_color)->g);
#line 161
        my_bg.blue = (png_uint_16 )(256 * (int )(opts->background_color)->b);
#line 162
        my_bg.gray = (png_uint_16 )(256 * ((((int )(opts->background_color)->r + (int )(opts->background_color)->g) + (int )(opts->background_color)->b) / 3));
      } else {
#line 165
        my_bg.gray = (png_uint_16 )65535;
#line 165
        my_bg.blue = my_bg.gray;
#line 165
        my_bg.green = my_bg.blue;
#line 165
        my_bg.red = my_bg.green;
      }
    } else {
#line 165
      my_bg.gray = (png_uint_16 )65535;
#line 165
      my_bg.blue = my_bg.gray;
#line 165
      my_bg.green = my_bg.blue;
#line 165
      my_bg.red = my_bg.green;
    }
    {
#line 167
    png_set_background(png_ptr, & my_bg, 2, 1, 1.);
    }
  } else {
    {
#line 169
    png_set_strip_alpha(png_ptr);
    }
  }
  {
#line 170
  png_set_interlace_handling(png_ptr);
#line 171
  png_read_update_info(png_ptr, info_ptr);
#line 173
  png_read_png(png_ptr, info_ptr, 0, (void *)0);
#line 174
  png_read_end(png_ptr, info_ptr);
#line 175
  __cil_tmp10 = png_get_rows(png_ptr, info_ptr);
  }
#line 175
  return (__cil_tmp10);
}
}
#line 112 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-gf.c"
static unsigned char get_byte(gf_font_t *font ) 
{ 
  unsigned char b ;
  unsigned long __cil_tmp3 ;

  {
  {
#line 116
  __cil_tmp3 = fread(& b, (unsigned long )1, (unsigned long )1, font->input_file);
  }
#line 116
  if (__cil_tmp3 != 1UL) {
    {
#line 117
    fprintf(stderr, "%s: read error\n", font->input_filename);
#line 118
    exit(- 1);
    }
  }
#line 120
  return (b);
}
}
#line 123 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-gf.c"
static unsigned short get_two(gf_font_t *font ) 
{ 
  unsigned short b ;
  unsigned char __cil_tmp3 ;
  unsigned char __cil_tmp4 ;

  {
  {
#line 127
  __cil_tmp3 = get_byte(font);
#line 127
  b = (unsigned short )((int )((unsigned short )__cil_tmp3) << 8);
#line 128
  __cil_tmp4 = get_byte(font);
  }
#line 128
  b |= (int )__cil_tmp4;
#line 129
  return (b);
}
}
#line 136 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-gf.c"
static unsigned long get_three(gf_font_t *font ) 
{ 
  unsigned long b ;
  unsigned char __cil_tmp3 ;
  unsigned char __cil_tmp4 ;
  unsigned char __cil_tmp5 ;

  {
  {
#line 140
  __cil_tmp3 = get_byte(font);
#line 140
  b = (unsigned long )__cil_tmp3 << 16;
#line 141
  __cil_tmp4 = get_byte(font);
  }
  {
#line 141
  b |= (unsigned long )__cil_tmp4 << 8;
#line 142
  __cil_tmp5 = get_byte(font);
  }
#line 142
  b |= (unsigned long )__cil_tmp5;
#line 143
  return (b);
}
}
#line 146 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-gf.c"
static unsigned long get_four(gf_font_t *font ) 
{ 
  unsigned long b ;
  unsigned char __cil_tmp3 ;
  unsigned char __cil_tmp4 ;
  unsigned char __cil_tmp5 ;
  unsigned char __cil_tmp6 ;

  {
  {
#line 150
  __cil_tmp3 = get_byte(font);
#line 150
  b = (unsigned long )__cil_tmp3 << 24;
#line 151
  __cil_tmp4 = get_byte(font);
  }
  {
#line 151
  b |= (unsigned long )__cil_tmp4 << 16;
#line 152
  __cil_tmp5 = get_byte(font);
  }
  {
#line 152
  b |= (unsigned long )__cil_tmp5 << 8;
#line 153
  __cil_tmp6 = get_byte(font);
  }
#line 153
  b |= (unsigned long )__cil_tmp6;
#line 154
  return (b);
}
}
#line 157 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-gf.c"
static void move_relative(gf_font_t *font , long count ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 159
  __cil_tmp3 = fseek(font->input_file, count, 1);
  }
#line 159
  if (__cil_tmp3 < 0) {
    {
#line 160
    fprintf(stderr, "%s: seek error\n", font->input_filename);
#line 161
    exit(- 1);
    }
  }
  return;
}
}
#line 165 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-gf.c"
static unsigned char get_previous_byte(gf_font_t *font ) 
{ 
  unsigned char b ;
  unsigned char __cil_tmp3 ;

  {
  {
#line 169
  move_relative(font, (long )(- 1));
#line 170
  b = get_byte(font);
#line 171
  move_relative(font, (long )(- 1));
  }
#line 172
  return (b);
}
}
#line 175 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-gf.c"
static unsigned long get_previous_four(gf_font_t *font ) 
{ 
  unsigned long b ;
  unsigned long __cil_tmp3 ;

  {
  {
#line 179
  move_relative(font, (long )(- 4));
#line 180
  b = get_four(font);
#line 181
  move_relative(font, (long )(- 4));
  }
#line 182
  return (b);
}
}
#line 189 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-gf.c"
static void skip_specials(gf_font_t *font ) 
{ 
  unsigned char __cil_tmp2 ;
  unsigned char __cil_tmp3 ;
  unsigned short __cil_tmp4 ;
  unsigned long __cil_tmp5 ;

  {
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 191
    if (! 1) {
#line 191
      goto while_break;
    }
    {
#line 192
    __cil_tmp2 = get_byte(font);
    }
    {
#line 193
    if ((int )__cil_tmp2 == 239) {
#line 193
      goto case_239;
    }
#line 196
    if ((int )__cil_tmp2 == 240) {
#line 196
      goto case_240;
    }
#line 199
    if ((int )__cil_tmp2 == 241) {
#line 199
      goto case_241;
    }
#line 202
    if ((int )__cil_tmp2 == 243) {
#line 202
      goto case_243;
    }
#line 205
    goto switch_default;
    case_239: /* CIL Label */ 
    {
#line 194
    __cil_tmp3 = get_byte(font);
#line 194
    move_relative(font, (long )__cil_tmp3);
    }
#line 195
    goto while_continue;
    case_240: /* CIL Label */ 
    {
#line 197
    __cil_tmp4 = get_two(font);
#line 197
    move_relative(font, (long )__cil_tmp4);
    }
#line 198
    goto while_continue;
    case_241: /* CIL Label */ 
    {
#line 200
    __cil_tmp5 = get_three(font);
#line 200
    move_relative(font, (long )__cil_tmp5);
    }
#line 201
    goto while_continue;
    case_243: /* CIL Label */ 
    {
#line 203
    get_four(font);
    }
#line 204
    goto while_continue;
    switch_default: /* CIL Label */ 
    {
#line 206
    move_relative(font, (long )(- 1));
    }
#line 207
    return;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 231 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-gf.c"
static void get_character_bitmap(gf_char_t *sym ) 
{ 
  unsigned char c ;
  int height ;
  int width ;
  int painting_black ;
  int cur_x ;
  int cur_y ;
  unsigned char __cil_tmp8 ;
  void *__cil_tmp9 ;
  unsigned char __cil_tmp10 ;
  unsigned int length ;
  unsigned char __cil_tmp12 ;
  unsigned short __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned int matrix_x ;
  unsigned int matrix_y ;
  int __cil_tmp17 ;
  unsigned int __cil_tmp18 ;
  unsigned int rows_to_skip ;
  unsigned char __cil_tmp20 ;
  unsigned short __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  int __cil_tmp23 ;

  {
#line 238
  painting_black = 0;
#line 241
  cur_x = (int )sym->bbox_min_col;
#line 242
  cur_y = (int )sym->bbox_max_row;
#line 244
  width = (int )(sym->bbox_max_col - sym->bbox_min_col);
#line 245
  height = (int )((sym->bbox_max_row - sym->bbox_min_row) + 1L);
#line 253
  if (width <= 0) {
    _L: /* CIL Label */ 
#line 254
    sym->height = (unsigned short )0;
#line 255
    sym->width = (unsigned short )0;
#line 256
    sym->bitmap = (char *)0;
    {
#line 259
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 259
      c = get_byte(sym->font);
      }
#line 259
      if (! ((int )c == 244)) {
#line 259
        goto while_break;
      }
#line 260
      goto while_continue;
    }
    while_break: /* CIL Label */ ;
    }
#line 261
    if ((int )c != 69) {
      {
#line 262
      fprintf(stderr, "%s: expected eoc (for a blank character), found %u\n", (sym->font)->input_filename,
              (int )c);
#line 263
      exit(- 1);
      }
    }
#line 265
    return;
  } else
#line 253
  if (height <= 0) {
#line 253
    goto _L;
  }
  {
#line 268
  sym->height = (unsigned short )height;
#line 269
  sym->width = (unsigned short )width;
#line 270
  sym->bitmap = (char *)calloc((unsigned long )width, (unsigned long )height);
  }
#line 271
  if (! sym->bitmap) {
    {
#line 272
    fprintf(stderr, "%s: out of memory\n", (sym->font)->input_filename);
#line 273
    exit(- 1);
    }
  }
  {
#line 276
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 276
    if (! 1) {
#line 276
      goto while_break___0;
    }
    {
#line 277
    c = get_byte(sym->font);
    }
#line 278
    if ((int )c == 69) {
#line 279
      goto while_break___0;
    }
#line 281
    if ((int )c <= 66) {
#line 290
      if ((int )c <= 63) {
#line 291
        length = (unsigned int )((int )c);
      } else {
        {
#line 294
        if ((int )c == 64) {
#line 294
          goto case_64;
        }
#line 297
        if ((int )c == 65) {
#line 297
          goto case_65;
        }
#line 300
        if ((int )c == 66) {
#line 300
          goto case_66;
        }
#line 303
        goto switch_default;
        case_64: /* CIL Label */ 
        {
#line 295
        __cil_tmp12 = get_byte(sym->font);
#line 295
        length = (unsigned int )__cil_tmp12;
        }
#line 296
        goto switch_break;
        case_65: /* CIL Label */ 
        {
#line 298
        __cil_tmp13 = get_two(sym->font);
#line 298
        length = (unsigned int )__cil_tmp13;
        }
#line 299
        goto switch_break;
        case_66: /* CIL Label */ 
        {
#line 301
        __cil_tmp14 = get_three(sym->font);
#line 301
        length = (unsigned int )__cil_tmp14;
        }
#line 302
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 304
        fprintf(stderr, "%s: invalid painting command %u\n\230\001", (sym->font)->input_filename,
                (int )c);
        }
        {
#line 305
        exit(- 1);
        }
        switch_break: /* CIL Label */ ;
        }
      }
#line 312
      if (painting_black) {
#line 315
        matrix_y = (unsigned int )(sym->bbox_max_row - (long )cur_y);
        {
#line 316
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 316
          if (! (length != 0U)) {
#line 316
            goto while_break___1;
          }
#line 317
          matrix_x = (unsigned int )((long )cur_x - sym->bbox_min_col);
#line 319
          *(sym->bitmap + (matrix_y * (unsigned int )sym->width + matrix_x)) = (char )255;
#line 320
          cur_x ++;
#line 316
          __cil_tmp18 = length;
#line 316
          length --;
        }
        while_break___1: /* CIL Label */ ;
        }
      } else {
#line 323
        cur_x += length;
      }
#line 325
      painting_black = ! painting_black;
    } else
#line 327
    if (70 <= (int )c) {
#line 327
      if ((int )c <= 73) {
        {
#line 333
        if ((int )c == 70) {
#line 333
          goto case_70;
        }
#line 336
        if ((int )c == 71) {
#line 336
          goto case_71;
        }
#line 339
        if ((int )c == 72) {
#line 339
          goto case_72;
        }
#line 342
        if ((int )c == 73) {
#line 342
          goto case_73;
        }
#line 345
        goto switch_default___0;
        case_70: /* CIL Label */ 
#line 334
        rows_to_skip = (unsigned int )0;
#line 335
        goto switch_break___0;
        case_71: /* CIL Label */ 
        {
#line 337
        __cil_tmp20 = get_byte(sym->font);
#line 337
        rows_to_skip = (unsigned int )__cil_tmp20;
        }
#line 338
        goto switch_break___0;
        case_72: /* CIL Label */ 
        {
#line 340
        __cil_tmp21 = get_two(sym->font);
#line 340
        rows_to_skip = (unsigned int )__cil_tmp21;
        }
#line 341
        goto switch_break___0;
        case_73: /* CIL Label */ 
        {
#line 343
        __cil_tmp22 = get_three(sym->font);
#line 343
        rows_to_skip = (unsigned int )__cil_tmp22;
        }
#line 344
        goto switch_break___0;
        switch_default___0: /* CIL Label */ 
        {
#line 346
        fprintf(stderr, "%s: invalid skip command %u\n", (sym->font)->input_filename,
                (int )c);
        }
        {
#line 347
        exit(- 1);
        }
        switch_break___0: /* CIL Label */ ;
        }
#line 349
        cur_y -= rows_to_skip + 1U;
#line 350
        cur_x = (int )sym->bbox_min_col;
#line 351
        painting_black = 0;
      } else {
#line 327
        goto _L___63;
      }
    } else
    _L___63: /* CIL Label */ 
#line 353
    if (74 <= (int )c) {
#line 353
      if ((int )c <= 238) {
#line 356
        __cil_tmp23 = cur_y;
#line 356
        cur_y --;
#line 357
        cur_x = (int )((sym->bbox_min_col + (long )c) - 74L);
#line 358
        painting_black = 1;
      } else {
#line 353
        goto _L___62;
      }
    } else
    _L___62: /* CIL Label */ 
#line 360
    if (! ((int )c == 244)) {
#line 363
      if (239 <= (int )c) {
#line 363
        if ((int )c <= 242) {
          {
          {
#line 364
          skip_specials(sym->font);
          }
          }
        } else {
#line 363
          goto _L___61;
        }
      } else
      _L___61: /* CIL Label */ 
#line 363
      if ((int )c == 243) {
        {
        {
#line 364
        skip_specials(sym->font);
        }
        }
      } else {
        {
#line 367
        fprintf(stderr, "%s: expected paint or skip or new_row, found %u\n\230\001",
                (sym->font)->input_filename, (int )c);
#line 368
        exit(- 1);
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 378 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-gf.c"
static void deblank(gf_char_t *sym ) 
{ 
  unsigned int all_white ;
  unsigned int white_on_left ;
  unsigned int white_on_right ;
  unsigned int white_on_top ;
  unsigned int white_on_bottom ;
  int c ;
  int r ;
  int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  unsigned int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  unsigned int __cil_tmp19 ;
  int __cil_tmp20 ;
  gf_char_t condensed ;
  void *__cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;

  {
#line 380
  white_on_left = (unsigned int )0;
#line 380
  white_on_right = (unsigned int )0;
#line 380
  white_on_top = (unsigned int )0;
#line 380
  white_on_bottom = (unsigned int )0;
#line 384
  all_white = (unsigned int )1;
#line 385
  c = 0;
  {
#line 385
  while (1) {
    while_continue: /* CIL Label */ ;
#line 385
    if (! (c < (int )sym->width && all_white)) {
#line 385
      goto while_break;
    }
#line 386
    r = 0;
    {
#line 386
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 386
      if (! (r < (int )sym->height && all_white)) {
#line 386
        goto while_break___0;
      }
#line 387
      if ((int )*(sym->bitmap + (r * (int )sym->width + c)) != 0) {
#line 388
        all_white = (unsigned int )0;
      }
#line 386
      r ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 390
    if (all_white) {
#line 391
      white_on_left ++;
    }
#line 385
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 395
  all_white = (unsigned int )1;
#line 396
  c = (int )sym->width - 1;
  {
#line 396
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 396
    if (! (c >= 0 && all_white)) {
#line 396
      goto while_break___1;
    }
#line 397
    r = 0;
    {
#line 397
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 397
      if (! (r < (int )sym->height && all_white)) {
#line 397
        goto while_break___2;
      }
#line 398
      if ((int )*(sym->bitmap + (r * (int )sym->width + c)) != 0) {
#line 399
        all_white = (unsigned int )0;
      }
#line 397
      r ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 401
    if (all_white) {
#line 402
      white_on_right ++;
    }
#line 396
    __cil_tmp14 = c;
#line 396
    c --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 406
  all_white = (unsigned int )1;
#line 407
  r = 0;
  {
#line 407
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 407
    if (! (r < (int )sym->height && all_white)) {
#line 407
      goto while_break___3;
    }
#line 408
    c = 0;
    {
#line 408
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 408
      if (! (c < (int )sym->width && all_white)) {
#line 408
        goto while_break___4;
      }
#line 409
      if ((int )*(sym->bitmap + (r * (int )sym->width + c)) != 0) {
#line 410
        all_white = (unsigned int )0;
      }
#line 408
      c ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 412
    if (all_white) {
#line 413
      white_on_top ++;
    }
#line 407
    r ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 417
  all_white = (unsigned int )1;
#line 418
  r = (int )sym->height - 1;
  {
#line 418
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 418
    if (! (r >= 0 && all_white)) {
#line 418
      goto while_break___5;
    }
#line 419
    c = 0;
    {
#line 419
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 419
      if (! (c < (int )sym->width && all_white)) {
#line 419
        goto while_break___6;
      }
#line 420
      if ((int )*(sym->bitmap + (r * (int )sym->width + c)) != 0) {
#line 421
        all_white = (unsigned int )0;
      }
#line 419
      c ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 423
    if (all_white) {
#line 424
      white_on_bottom ++;
    }
#line 418
    __cil_tmp20 = r;
#line 418
    r --;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 433
  if (white_on_left > 0U) {
    _L: /* CIL Label */ 
    _L___64: /* CIL Label */ 
    _L___65: /* CIL Label */ 
#line 436
    if (white_on_left + white_on_right > (unsigned int )sym->width) {
#line 438
      sym->width = (unsigned short )0;
#line 439
      sym->height = (unsigned short )0;
#line 440
      sym->bbox_min_col = (long )0;
#line 441
      sym->bbox_max_col = (long )0;
#line 442
      sym->bbox_min_row = (long )0;
#line 443
      sym->bbox_max_row = (long )0;
#line 444
      condensed.bitmap = (char *)0;
    } else {
      {
#line 446
      condensed.width = (unsigned short )(((unsigned int )sym->width - white_on_left) - white_on_right);
#line 447
      condensed.height = (unsigned short )(((unsigned int )sym->height - white_on_top) - white_on_bottom);
#line 448
      condensed.bitmap = (char *)calloc((unsigned long )condensed.width, (unsigned long )condensed.height);
      }
#line 449
      if (! condensed.bitmap) {
        {
#line 450
        fprintf(stderr, "%s: out of memory\n", (sym->font)->input_filename);
#line 451
        exit(- 1);
        }
      }
#line 453
      r = 0;
      {
#line 453
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 453
        if (! (r < (int )condensed.height)) {
#line 453
          goto while_break___7;
        }
#line 454
        c = 0;
        {
#line 454
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 454
          if (! (c < (int )condensed.width)) {
#line 454
            goto while_break___8;
          }
#line 455
          *(condensed.bitmap + (r * (int )condensed.width + c)) = *(sym->bitmap + (((unsigned int )r + white_on_top) * (unsigned int )sym->width + ((unsigned int )c + white_on_left)));
#line 454
          c ++;
        }
        while_break___8: /* CIL Label */ ;
        }
#line 453
        r ++;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 457
      sym->bbox_min_row += (long )white_on_bottom;
#line 458
      sym->bbox_max_row -= (long )white_on_top;
#line 459
      sym->bbox_min_col += (long )white_on_left;
#line 460
      sym->bbox_max_col -= (long )white_on_right;
    }
    {
#line 462
    free(sym->bitmap);
#line 463
    sym->bitmap = condensed.bitmap;
    }
  } else
#line 433
  if (white_on_right > 0U) {
#line 433
    goto _L;
  } else
#line 433
  if (white_on_top > 0U) {
#line 433
    goto _L;
  } else
#line 433
  if (white_on_bottom > 0U) {
#line 433
    goto _L;
  }
  return;
}
}
#line 467 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-gf.c"
static int gf_open(gf_font_t *font , char *filename ) 
{ 
  unsigned char b ;
  unsigned char c ;
  unsigned long post_ptr ;
  FILE *__cil_tmp6 ;
  int __cil_tmp7 ;
  long __cil_tmp8 ;
  unsigned char __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned char __cil_tmp11 ;
  unsigned char __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned char __cil_tmp21 ;
  unsigned char __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned char __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;

  {
  {
#line 472
  font->input_filename = filename;
#line 473
  font->input_file = fopen((char const   *)filename, "r");
  }
#line 474
  if (! font->input_file) {
    {
#line 475
    perror((char const   *)filename);
    }
#line 476
    return (0);
  }
  {
#line 479
  __cil_tmp7 = fseek(font->input_file, (long )0, 2);
  }
#line 479
  if (__cil_tmp7 < 0) {
    {
#line 480
    perror((char const   *)filename);
    }
#line 481
    return (0);
  }
  {
#line 485
  __cil_tmp8 = ftell(font->input_file);
  }
#line 485
  if (__cil_tmp8 <= 0L) {
    {
#line 486
    fprintf(stderr, "%s: empty file\n", font->input_filename);
    }
#line 487
    return (0);
  }
  {
#line 490
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 491
    b = get_previous_byte(font);
    }
#line 490
    if (! ((int )b == 223)) {
#line 490
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 493
  if ((int )b != 131) {
    {
#line 494
    fprintf(stderr, "%s: invalid signature (expected %u, found %u)\n", font->input_filename,
            131, (int )b);
    }
#line 495
    return (0);
  }
  {
#line 498
  post_ptr = get_previous_four(font);
#line 499
  c = (unsigned char )0;
  }
  {
#line 499
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 499
    if (! 1) {
#line 499
      goto while_break___0;
    }
#line 500
    font->char_loc[c].charcode = c;
#line 501
    font->char_loc[c].tfm_width = (long )0;
#line 502
    font->char_loc[c].char_pointer = (long )(- 1);
#line 503
    if ((int )c == 255) {
#line 504
      goto while_break___0;
    }
#line 499
    c ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 507
  fseek(font->input_file, (long )post_ptr, 0);
#line 508
  b = get_byte(font);
  }
#line 509
  if ((int )b != 248) {
    {
#line 510
    fprintf(stderr, "%s: invalid font structure (expected %u, found %u)\n", font->input_filename,
            248, (int )b);
    }
#line 511
    return (0);
  }
  {
#line 513
  get_four(font);
#line 515
  __cil_tmp13 = get_four(font);
#line 515
  font->design_size = (double )__cil_tmp13 / (double )(1L << 20);
#line 516
  font->checksum = get_four(font);
#line 520
  __cil_tmp15 = get_four(font);
#line 520
  font->h_pixels_per_point = (double )__cil_tmp15 / (double )(1L << 16);
#line 521
  __cil_tmp16 = get_four(font);
#line 521
  font->v_pixels_per_point = (double )__cil_tmp16 / (double )(1L << 16);
#line 523
  __cil_tmp17 = get_four(font);
#line 523
  font->bbox_min_col = (long )__cil_tmp17;
#line 524
  __cil_tmp18 = get_four(font);
#line 524
  font->bbox_max_col = (long )__cil_tmp18;
#line 525
  __cil_tmp19 = get_four(font);
#line 525
  font->bbox_min_row = (long )__cil_tmp19;
#line 526
  __cil_tmp20 = get_four(font);
#line 526
  font->bbox_max_row = (long )__cil_tmp20;
  }
  {
#line 531
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 531
    if (! 1) {
#line 531
      goto while_break___1;
    }
    {
#line 532
    b = get_byte(font);
    }
#line 533
    if ((int )b == 249) {
#line 534
      goto while_break___1;
    }
    {
#line 536
    c = get_byte(font);
    }
#line 538
    if ((int )b == 245) {
      {
#line 539
      __cil_tmp23 = get_four(font);
#line 539
      font->char_loc[c].h_escapement = (long )((double )__cil_tmp23 / (double )(1 << 16) + 0.5);
#line 541
      get_four(font);
      }
    } else
#line 543
    if ((int )b == 246) {
      {
#line 544
      __cil_tmp24 = get_byte(font);
#line 544
      font->char_loc[c].h_escapement = (long )__cil_tmp24;
      }
    } else {
      {
#line 547
      fprintf(stderr, "%s: invalid char_loc command (found %u)\n\230\001", font->input_filename,
              (int )b);
      }
#line 548
      return (0);
    }
    {
#line 551
    __cil_tmp25 = get_four(font);
#line 551
    font->char_loc[c].tfm_width = (long )__cil_tmp25;
#line 552
    __cil_tmp26 = get_four(font);
#line 552
    font->char_loc[c].char_pointer = (long )__cil_tmp26;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 554
  return (1);
}
}
#line 560 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-gf.c"
static int gf_get_char(gf_font_t *font , gf_char_t *sym , unsigned char charcode ) 
{ 
  gf_locator_t *loc ;
  unsigned char c ;
  unsigned char col_delta ;
  unsigned char row_delta ;
  long lcode ;
  long back_pointer ;
  int __cil_tmp10 ;
  unsigned char __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned char __cil_tmp18 ;
  unsigned char __cil_tmp19 ;
  unsigned char __cil_tmp20 ;
  unsigned char __cil_tmp21 ;
  unsigned char __cil_tmp22 ;

  {
#line 566
  loc = & font->char_loc[charcode];
#line 567
  if (loc->char_pointer == -1L) {
#line 568
    return (0);
  }
  {
#line 570
  sym->font = font;
#line 571
  sym->h_escapement = loc->h_escapement;
#line 572
  sym->tfm_width = loc->tfm_width;
#line 574
  __cil_tmp10 = fseek(font->input_file, loc->char_pointer, 0);
  }
#line 574
  if (__cil_tmp10 < 0) {
    {
#line 575
    fprintf(stderr, "%s: seek error\n", font->input_filename);
    }
#line 576
    return (0);
  }
  {
#line 582
  skip_specials(font);
#line 584
  c = get_byte(font);
  }
  {
#line 586
  if ((int )c == 67) {
#line 586
    goto case_67;
  }
#line 610
  if ((int )c == 68) {
#line 610
    goto case_68;
  }
#line 622
  if ((int )c == 248) {
#line 622
    goto case_248;
  }
#line 625
  goto switch_default;
  case_67: /* CIL Label */ 
  {
#line 591
  __cil_tmp12 = get_four(font);
#line 591
  lcode = (long )__cil_tmp12;
  }
#line 592
  if (lcode < 0L) {
    {
    {
#line 595
    fprintf(stderr, "%s: invalid character code %ld (expected %d)\n", font->input_filename,
            lcode, (int )charcode);
    }
    }
#line 596
    return (0);
  } else
#line 592
  if (lcode > 255L) {
    {
    {
#line 595
    fprintf(stderr, "%s: invalid character code %ld (expected %d)\n", font->input_filename,
            lcode, (int )charcode);
    }
    }
#line 596
    return (0);
  }
  {
#line 598
  sym->charcode = (unsigned char )lcode;
#line 600
  __cil_tmp13 = get_four(font);
#line 600
  back_pointer = (long )__cil_tmp13;
  }
#line 601
  if (back_pointer != -1L) {
    {
#line 602
    fprintf(stderr, "%s: warning: character %u has a non-null back pointer (to %#lx)\n\230\001",
            font->input_filename, (int )sym->charcode, back_pointer);
    }
  }
  {
#line 604
  __cil_tmp14 = get_four(font);
#line 604
  sym->bbox_min_col = (long )__cil_tmp14;
#line 605
  __cil_tmp15 = get_four(font);
#line 605
  sym->bbox_max_col = (long )__cil_tmp15;
#line 606
  __cil_tmp16 = get_four(font);
#line 606
  sym->bbox_min_row = (long )__cil_tmp16;
#line 607
  __cil_tmp17 = get_four(font);
#line 607
  sym->bbox_max_row = (long )__cil_tmp17;
  }
#line 608
  goto switch_break;
  case_68: /* CIL Label */ 
  {
#line 611
  sym->charcode = get_byte(font);
  }
  {
#line 613
  col_delta = get_byte(font);
#line 614
  __cil_tmp20 = get_byte(font);
#line 614
  sym->bbox_max_col = (long )__cil_tmp20;
#line 615
  sym->bbox_min_col = sym->bbox_max_col - (long )col_delta;
#line 617
  row_delta = get_byte(font);
#line 618
  __cil_tmp22 = get_byte(font);
#line 618
  sym->bbox_max_row = (long )__cil_tmp22;
#line 619
  sym->bbox_min_row = sym->bbox_max_row - (long )row_delta;
  }
#line 620
  goto switch_break;
  case_248: /* CIL Label */ 
#line 623
  return (0);
  switch_default: /* CIL Label */ 
  {
#line 626
  fprintf(stderr, "%s: error reading character (found %u)\n", font->input_filename,
          (int )c);
  }
#line 627
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 629
  if ((int )sym->charcode != (int )charcode) {
    {
#line 630
    fprintf(stderr, "%s: warning: character code mismatch, %d != %d\n", font->input_filename,
            (int )sym->charcode, (int )charcode);
    }
  }
  {
#line 633
  get_character_bitmap(sym);
#line 635
  deblank(sym);
  }
#line 636
  return (1);
}
}
#line 639 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-gf.c"
at_bitmap input_gf_reader(gchar *filename , at_input_opts_type *opts , at_msg_func msg_func ,
                          gpointer msg_data , gpointer user_data ) 
{ 
  at_exception_type exp___0 ;
  at_exception_type __cil_tmp7 ;
  at_bitmap bitmap ;
  at_bitmap __cil_tmp9 ;
  gf_font_t fontdata ;
  gf_font_t *font ;
  gf_char_t chardata ;
  gf_char_t *sym ;
  unsigned int i ;
  unsigned int j ;
  unsigned int ptr ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  at_bitmap __cil_tmp19 ;
  unsigned int __cil_tmp20 ;
  unsigned int __cil_tmp21 ;
  unsigned int __cil_tmp22 ;

  {
  {
#line 641
  __cil_tmp7 = at_exception_new(msg_func, msg_data);
#line 641
  exp___0 = __cil_tmp7;
#line 642
  __cil_tmp9 = at_bitmap_init((unsigned char *)((void *)0), (unsigned short )0, (unsigned short )0,
                              (unsigned int )0);
#line 642
  bitmap = __cil_tmp9;
#line 643
  font = & fontdata;
#line 644
  sym = & chardata;
#line 647
  __cil_tmp17 = gf_open(font, filename);
  }
#line 647
  if (! __cil_tmp17) {
    {
#line 648
    at_exception_fatal(& exp___0, (gchar *)"Cannot open input GF file");
    }
#line 649
    return (bitmap);
  }
#line 651
  if (opts->charcode == 0U) {
#line 653
    i = (unsigned int )0;
    {
#line 653
    while (1) {
      while_continue: /* CIL Label */ ;
#line 653
      if (! (i < 256U)) {
#line 653
        goto while_break;
      }
#line 654
      if (font->char_loc[i].char_pointer != -1L) {
#line 655
        goto while_break;
      }
#line 653
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 656
    if (i >= 256U) {
      {
#line 657
      at_exception_fatal(& exp___0, (gchar *)"No characters in input GF file");
      }
#line 658
      return (bitmap);
    }
#line 660
    opts->charcode = i;
  }
  {
#line 662
  __cil_tmp18 = gf_get_char(font, sym, (unsigned char )opts->charcode);
  }
#line 662
  if (! __cil_tmp18) {
    {
#line 663
    fclose(font->input_file);
#line 664
    at_exception_fatal(& exp___0, (gchar *)"Error reading character from GF file");
    }
#line 665
    return (bitmap);
  }
  {
#line 668
  ugs_design_pixels = (long )(font->design_size * font->v_pixels_per_point + 0.5);
#line 669
  ugs_charcode = (long )opts->charcode;
#line 670
  ugs_advance_width = sym->h_escapement;
#line 671
  ugs_left_bearing = sym->bbox_min_col;
#line 672
  ugs_descend = sym->bbox_min_row;
#line 673
  ugs_max_col = sym->bbox_max_col;
#line 674
  ugs_max_row = sym->bbox_max_row;
#line 676
  bitmap = at_bitmap_init((unsigned char *)((void *)0), sym->width, sym->height, (unsigned int )1);
#line 677
  ptr = (unsigned int )0;
  }
#line 677
  j = (unsigned int )0;
  {
#line 677
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 677
    if (! (j < (unsigned int )sym->height)) {
#line 677
      goto while_break___0;
    }
#line 678
    i = (unsigned int )0;
    {
#line 678
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 678
      if (! (i < (unsigned int )sym->width)) {
#line 678
        goto while_break___1;
      }
#line 679
      __cil_tmp20 = ptr;
#line 679
      ptr ++;
#line 679
      *(bitmap.bitmap + __cil_tmp20) = (unsigned char )*(sym->bitmap + (j * (unsigned int )sym->width + i));
#line 678
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 677
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 682
  free(sym->bitmap);
#line 683
  fclose(font->input_file);
  }
#line 684
  return (bitmap);
}
}
#line 102 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-tga.c"
static struct __anonstruct_1287 tga_footer ;
#line 104
static at_bitmap ReadImage(FILE *fp , struct tga_header *hdr , at_exception_type *exp___0 ) ;
#line 105 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-tga.c"
at_bitmap input_tga_reader(gchar *filename , at_input_opts_type *opts , at_msg_func msg_func ,
                           gpointer msg_data , gpointer user_data ) 
{ 
  FILE *fp ;
  struct tga_header hdr ;
  at_bitmap image ;
  at_bitmap __cil_tmp9 ;
  at_exception_type exp___0 ;
  at_exception_type __cil_tmp11 ;
  FILE *__cil_tmp12 ;
  int __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  int __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  int __cil_tmp17 ;
  at_bitmap __cil_tmp18 ;

  {
  {
#line 110
  __cil_tmp9 = at_bitmap_init((unsigned char *)0, (unsigned short )0, (unsigned short )0,
                              (unsigned int )1);
#line 110
  image = __cil_tmp9;
#line 111
  __cil_tmp11 = at_exception_new(msg_func, msg_data);
#line 111
  exp___0 = __cil_tmp11;
#line 113
  fp = fopen((char const   *)filename, "rb");
  }
#line 114
  if (! fp) {
    {
#line 115
    while (1) {
      while_continue: /* CIL Label */ ;
#line 115
      if (logging) {
        {
#line 115
        fprintf(stdout, "TGA: can\'t open \"%s\"\n", filename);
        }
      }
#line 115
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 116
    at_exception_fatal(& exp___0, (gchar *)"Cannot open input tga file");
    }
  }
  {
#line 120
  __cil_tmp14 = fread(& tga_footer, sizeof(tga_footer), (unsigned long )1, fp);
  }
  {
#line 120
  __cil_tmp13 = fseek(fp, (long )(0UL - sizeof(tga_footer)), 2);
  }
#line 120
  if (__cil_tmp13) {
    _L: /* CIL Label */ 
    {
#line 122
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 122
      if (logging) {
        {
#line 122
        fprintf(stdout, "TGA: Cannot read footer from \"%s\"\n", filename);
        }
      }
#line 122
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 123
    at_exception_fatal(& exp___0, (gchar *)"TGA: Cannot read footer");
    }
#line 124
    goto cleanup;
  } else
#line 120
  if (__cil_tmp14 != 1UL) {
#line 120
    goto _L;
  }
  {
#line 129
  __cil_tmp16 = fread(& hdr, sizeof(hdr), (unsigned long )1, fp);
  }
  {
#line 129
  __cil_tmp15 = fseek(fp, (long )0, 0);
  }
#line 129
  if (__cil_tmp15) {
    _L___66: /* CIL Label */ 
    {
#line 130
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 130
      if (logging) {
        {
#line 130
        fprintf(stdout, "TGA: Cannot read header from \"%s\"\n", filename);
        }
      }
#line 130
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 131
    at_exception_fatal(& exp___0, (gchar *)"TGA: Cannot read header");
    }
#line 132
    goto cleanup;
  } else
#line 129
  if (__cil_tmp16 != 1UL) {
#line 129
    goto _L___66;
  }
  {
#line 136
  __cil_tmp17 = fseek(fp, (long )hdr.idLength, 1);
  }
#line 136
  if ((int )hdr.idLength) {
#line 136
    if (__cil_tmp17) {
      {
#line 137
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 137
        if (logging) {
          {
#line 137
          fprintf(stdout, "TGA: Cannot skip ID field in \"%s\"\n", filename);
          }
        }
#line 137
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 138
      at_exception_fatal(& exp___0, (gchar *)"TGA: Cannot skip ID field");
      }
#line 139
      goto cleanup;
    }
  }
  {
#line 142
  image = ReadImage(fp, & hdr, & exp___0);
  }
  cleanup: 
  {
#line 144
  fclose(fp);
  }
#line 145
  return (image);
}
}
#line 148 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-tga.c"
static int std_fread(unsigned char *buf , int datasize , int nelems , FILE *fp ) 
{ 
  unsigned long __cil_tmp5 ;

  {
  {
#line 151
  __cil_tmp5 = fread(buf, (unsigned long )datasize, (unsigned long )nelems, fp);
  }
#line 151
  return ((int )__cil_tmp5);
}
}
#line 157 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-tga.c"
static int rle_fread(unsigned char *buf , int datasize , int nelems , FILE *fp ) 
{ 
  static unsigned char *statebuf ;
  static int statelen ;
  static int laststate ;
  int j ;
  int k ;
  int buflen ;
  int count ;
  int bytes ;
  unsigned char *p ;
  int tmp ;
  int __cil_tmp15 ;
  void *__cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;

  {
#line 159
  statebuf = (unsigned char *)0;
#line 160
  statelen = 0;
#line 161
  laststate = 0;
#line 168
  buflen = nelems * datasize;
#line 170
  j = 0;
  {
#line 171
  while (1) {
    while_continue: /* CIL Label */ ;
#line 171
    if (! (j < buflen)) {
#line 171
      goto while_break;
    }
#line 172
    if (laststate < statelen) {
#line 174
      if (buflen - j < statelen - laststate) {
#line 174
        tmp = buflen - j;
      } else {
#line 174
        tmp = statelen - laststate;
      }
      {
#line 174
      bytes = tmp;
#line 175
      memcpy(buf + j, statebuf + laststate, (unsigned long )bytes);
#line 176
      j += bytes;
#line 177
      laststate += bytes;
      }
#line 180
      if (laststate >= statelen) {
#line 181
        laststate = 0;
#line 182
        statelen = 0;
      }
#line 186
      if (j >= buflen) {
#line 187
        goto while_break;
      }
    }
    {
#line 191
    count = fgetc(fp);
    }
#line 192
    if (count == -1) {
#line 193
      return (j / datasize);
    }
#line 197
    bytes = ((count & -129) + 1) * datasize;
#line 199
    if (j + bytes <= buflen) {
#line 201
      p = buf + j;
    } else {
#line 204
      if (! statebuf) {
        {
#line 205
        __cil_tmp16 = malloc((unsigned long )(128 * datasize));
#line 205
        statebuf = (unsigned char *)__cil_tmp16;
        }
      }
#line 206
      p = statebuf;
    }
#line 209
    if (count & 128) {
      {
#line 211
      __cil_tmp17 = fread(p, (unsigned long )datasize, (unsigned long )1, fp);
      }
#line 211
      if (__cil_tmp17 != 1UL) {
#line 212
        return (j / datasize);
      }
#line 216
      if (datasize == 1) {
        {
#line 217
        memset(p + 1, (int )*p, (unsigned long )(bytes - 1));
        }
      } else {
#line 219
        k = datasize;
        {
#line 219
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 219
          if (! (k < bytes)) {
#line 219
            goto while_break___0;
          }
          {
#line 220
          memcpy(p + k, p, (unsigned long )datasize);
          }
#line 219
          k += datasize;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    } else {
      {
#line 223
      __cil_tmp18 = fread(p, (unsigned long )bytes, (unsigned long )1, fp);
      }
#line 223
      if (__cil_tmp18 != 1UL) {
#line 224
        return (j / datasize);
      }
    }
#line 229
    if (p == statebuf) {
#line 230
      statelen = bytes;
    } else {
#line 232
      j += bytes;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 235
  return (nelems);
}
}
#line 238 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-tga.c"
static at_bitmap ReadImage(FILE *fp , struct tga_header *hdr , at_exception_type *exp___0 ) 
{ 
  at_bitmap image ;
  at_bitmap __cil_tmp5 ;
  unsigned char *buffer ;
  unsigned char *alphas ;
  unsigned short width ;
  unsigned short height ;
  unsigned short bpp ;
  unsigned short abpp ;
  unsigned short pbpp ;
  unsigned short nalphas ;
  int j ;
  int k ;
  int pelbytes ;
  int wbytes ;
  int bsize ;
  int npels ;
  int pels ;
  int rle ;
  int badread ;
  int itype ;
  int dtype ;
  unsigned char *cmap ;
  int (*myfread)(unsigned char * , int  , int  , FILE * ) ;
  char horzrev ;
  char vertrev ;
  int tmp ;
  int tmp___0 ;
  int index___72 ;
  int colors ;
  unsigned int length ;
  void *__cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  long __cil_tmp36 ;
  void *__cil_tmp37 ;
  unsigned char tmp___1 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  unsigned short __cil_tmp42 ;
  int __cil_tmp43 ;
  at_bitmap __cil_tmp44 ;
  void *__cil_tmp45 ;
  int __cil_tmp46 ;
  long __cil_tmp47 ;
  int __cil_tmp48 ;
  unsigned char tmp___2 ;
  unsigned char *tmp___3 ;
  int __cil_tmp51 ;
  unsigned char *temp ;
  unsigned char *temp2 ;
  unsigned char *temp3 ;
  unsigned char index___74 ;
  int xpos ;
  int ypos ;
  void *__cil_tmp58 ;
  unsigned char *__cil_tmp59 ;
  unsigned char *__cil_tmp60 ;
  unsigned char *__cil_tmp61 ;
  unsigned char *__cil_tmp62 ;
  int __cil_tmp63 ;
  int __cil_tmp64 ;

  {
  {
#line 240
  __cil_tmp5 = at_bitmap_init((unsigned char *)0, (unsigned short )0, (unsigned short )0,
                              (unsigned int )1);
#line 240
  image = __cil_tmp5;
#line 241
  buffer = (unsigned char *)((void *)0);
#line 242
  alphas = (unsigned char *)((void *)0);
#line 249
  cmap = (unsigned char *)((void *)0);
#line 253
  horzrev = (char )((int )hdr->descriptor & 16);
#line 254
  vertrev = (char )(! ((int )hdr->descriptor & 32));
#line 256
  image.bitmap = (unsigned char *)((void *)0);
#line 260
  width = (unsigned short )(((int )hdr->widthHi << 8) | (int )hdr->widthLo);
#line 261
  height = (unsigned short )(((int )hdr->heightHi << 8) | (int )hdr->heightLo);
#line 263
  bpp = (unsigned short )hdr->bpp;
#line 264
  abpp = (unsigned short )((int )hdr->descriptor & 15);
  }
#line 266
  if ((int )hdr->imageType == 2) {
    _L: /* CIL Label */ 
#line 267
    if ((int )bpp / 3 < 8) {
#line 267
      tmp = (int )bpp / 3;
    } else {
#line 267
      tmp = 8;
    }
#line 267
    pbpp = (unsigned short )(tmp * 3);
  } else
#line 266
  if ((int )hdr->imageType == 10) {
#line 266
    goto _L;
  } else
#line 268
  if ((int )abpp < (int )bpp) {
#line 269
    pbpp = (unsigned short )((int )bpp - (int )abpp);
  } else {
#line 271
    pbpp = bpp;
  }
#line 273
  if ((int )abpp + (int )pbpp > (int )bpp) {
    {
#line 274
    while (1) {
      while_continue: /* CIL Label */ ;
#line 274
      if (logging) {
        {
#line 274
        fprintf(stdout, "TGA: %d bit image, %d bit alpha is greater than %d total bits per pixel\n\230\001",
                (int )pbpp, (int )abpp, (int )bpp);
        }
      }
#line 274
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 275
    at_exception_warning(exp___0, (gchar *)"TGA: alpha bit is too great");
#line 278
    abpp = (unsigned short )((int )bpp - (int )pbpp);
    }
    {
#line 279
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 279
      if (logging) {
        {
#line 279
        fprintf(stdout, "TGA: reducing to %d bit alpha\n", (int )abpp);
        }
      }
#line 279
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 280
    at_exception_warning(exp___0, (gchar *)"TGA: alpha bit is reducedUm\020\027V");
    }
  } else
#line 281
  if ((int )abpp + (int )pbpp < (int )bpp) {
    {
#line 282
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 282
      if (logging) {
        {
#line 282
        fprintf(stdout, "TGA: %d bit image, %d bit alpha is less than %d total bits per pixel\n",
                (int )pbpp, (int )abpp, (int )bpp);
        }
      }
#line 282
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 283
    at_exception_warning(exp___0, (gchar *)"TGA: alpha bit is too little");
#line 286
    abpp = (unsigned short )((int )bpp - (int )pbpp);
    }
    {
#line 287
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 287
      if (logging) {
        {
#line 287
        fprintf(stdout, "TGA: increasing to %d bit alpha\n\230\001", (int )abpp);
        }
      }
#line 287
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 288
    at_exception_warning(exp___0, (gchar *)"TGA: alpha bit is increased");
    }
  }
#line 291
  rle = 0;
  {
#line 293
  if ((int )hdr->imageType == 9) {
#line 293
    goto case_9;
  }
#line 295
  if ((int )hdr->imageType == 1) {
#line 295
    goto case_1;
  }
#line 317
  if ((int )hdr->imageType == 11) {
#line 317
    goto case_11;
  }
#line 319
  if ((int )hdr->imageType == 3) {
#line 319
    goto case_3;
  }
#line 328
  if ((int )hdr->imageType == 10) {
#line 328
    goto case_10;
  }
#line 330
  if ((int )hdr->imageType == 2) {
#line 330
    goto case_2;
  }
#line 339
  goto switch_default;
  case_9: /* CIL Label */ 
#line 294
  rle = 1;
  case_1: /* CIL Label */ 
#line 296
  itype = 1;
#line 299
  if ((int )hdr->colorMapSize / 3 < 8) {
#line 299
    tmp___0 = (int )hdr->colorMapSize / 3;
  } else {
#line 299
    tmp___0 = 8;
  }
#line 299
  pbpp = (unsigned short )(tmp___0 * 3);
#line 300
  if ((int )pbpp < (int )hdr->colorMapSize) {
#line 301
    abpp = (unsigned short )((int )hdr->colorMapSize - (int )pbpp);
  } else {
#line 303
    abpp = (unsigned short )0;
  }
#line 305
  if ((int )bpp != 8) {
    {
#line 306
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 306
      if (logging) {
        {
#line 306
        fprintf(stdout, "TGA: index sizes other than 8 bits are unimplemented\n");
        }
      }
#line 306
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 307
    at_exception_fatal(exp___0, (gchar *)"TGA: index sizes other than 8 bits are unimplemented\027V");
    }
#line 308
    return (image);
  }
#line 311
  if (abpp) {
#line 312
    dtype = 2;
  } else {
#line 314
    dtype = 1;
  }
#line 315
  goto switch_break;
  case_11: /* CIL Label */ 
#line 318
  rle = 1;
  case_3: /* CIL Label */ 
#line 320
  itype = 3;
#line 322
  if (abpp) {
#line 323
    dtype = 4;
  } else {
#line 325
    dtype = 3;
  }
#line 326
  goto switch_break;
  case_10: /* CIL Label */ 
#line 329
  rle = 1;
  case_2: /* CIL Label */ 
#line 331
  itype = 5;
#line 333
  if (abpp) {
#line 334
    dtype = 6;
  } else {
#line 336
    dtype = 5;
  }
#line 337
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 341
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 341
    if (logging) {
      {
#line 341
      fprintf(stdout, "TGA: unrecognized image type %d\n\230\001", (int )hdr->imageType);
      }
    }
#line 341
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 342
  at_exception_fatal(exp___0, (gchar *)"TGA: unrecognized image type");
  }
#line 343
  return (image);
  switch_break: /* CIL Label */ ;
  }
#line 347
  if ((int )abpp) {
#line 347
    if ((int )abpp != 8) {
      _L___67: /* CIL Label */ 
      _L___68: /* CIL Label */ 
      {
#line 349
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 349
        if (logging) {
          {
#line 349
          fprintf(stdout, "TGA: channel sizes other than 8 bits are unimplemented\n");
          }
        }
#line 349
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 350
      at_exception_fatal(exp___0, (gchar *)"TGA: channel sizes other than 8 bits are unimplemented");
      }
#line 351
      return (image);
    } else {
#line 347
      goto _L___71;
    }
  } else
  _L___71: /* CIL Label */ 
#line 347
  if (itype == 5) {
    _L___70: /* CIL Label */ 
#line 347
    if ((int )pbpp != 24) {
#line 347
      goto _L___67;
    } else {
#line 347
      goto _L___69;
    }
  } else
#line 347
  if (itype == 1) {
#line 347
    goto _L___70;
  } else
  _L___69: /* CIL Label */ 
#line 347
  if (itype == 3) {
#line 347
    if ((int )pbpp != 8) {
#line 347
      goto _L___67;
    }
  }
#line 355
  if (itype == 1) {
#line 356
    if ((int )hdr->colorMapType != 1) {
      {
#line 357
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 357
        if (logging) {
          {
#line 357
          fprintf(stdout, "TGA: indexed image has invalid color map type %d\n", (int )hdr->colorMapType);
          }
        }
#line 357
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 358
      at_exception_fatal(exp___0, (gchar *)"TGA: indexed image has invalid color map type");
      }
#line 359
      return (image);
    }
  } else
#line 361
  if ((int )hdr->colorMapType != 0) {
    {
#line 362
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 362
      if (logging) {
        {
#line 362
        fprintf(stdout, "TGA: non-indexed image has invalid color map type %d\n",
                (int )hdr->colorMapType);
        }
      }
#line 362
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 363
    at_exception_fatal(exp___0, (gchar *)"TGA: non-indexed image has invalid color map type");
    }
#line 364
    return (image);
  }
#line 367
  nalphas = (unsigned short )0;
#line 368
  if ((int )hdr->colorMapType == 1) {
#line 373
    index___72 = ((int )hdr->colorMapIndexHi << 8) | (int )hdr->colorMapIndexLo;
#line 374
    length = (unsigned int )(((int )hdr->colorMapLengthHi << 8) | (int )hdr->colorMapLengthLo);
#line 376
    if (length == 0U) {
      {
#line 377
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 377
        if (logging) {
          {
#line 377
          fprintf(stdout, "TGA: invalid color map length %d\n", length);
          }
        }
#line 377
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
      {
#line 378
      at_exception_fatal(exp___0, (gchar *)"TGA: invalid color map length");
      }
#line 379
      return (image);
    }
    {
#line 382
    pelbytes = ((int )hdr->colorMapSize + 7) / 8;
#line 383
    colors = (int )(length + (unsigned int )index___72);
#line 384
    __cil_tmp34 = malloc((unsigned long )(colors * pelbytes));
#line 384
    cmap = (unsigned char *)__cil_tmp34;
#line 387
    memset(cmap, 0, (unsigned long )(index___72 * pelbytes));
#line 390
    __cil_tmp35 = fread(cmap + index___72 * pelbytes, (unsigned long )pelbytes, (unsigned long )length,
                        fp);
    }
#line 390
    if (__cil_tmp35 != (unsigned long )length) {
      {
#line 391
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 391
        if (logging) {
          {
#line 391
          __cil_tmp36 = ftell(fp);
#line 391
          fprintf(stdout, "TGA: error reading colormap (ftell == %ld)\n", __cil_tmp36);
          }
        }
#line 391
        goto while_break___9;
      }
      while_break___9: /* CIL Label */ ;
      }
      {
#line 392
      at_exception_fatal(exp___0, (gchar *)"TGA: error reading colormap");
      }
#line 393
      return (image);
    }
#line 398
    if (pelbytes > 3) {
      {
#line 399
      __cil_tmp37 = malloc((unsigned long )colors);
#line 399
      alphas = (unsigned char *)__cil_tmp37;
      }
    }
#line 401
    k = 0;
#line 402
    j = 0;
    {
#line 402
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 402
      if (! (j < colors * pelbytes)) {
#line 402
        goto while_break___10;
      }
#line 404
      tmp___1 = *(cmap + j);
#line 405
      __cil_tmp39 = k;
#line 405
      k ++;
#line 405
      *(cmap + __cil_tmp39) = *(cmap + (j + 2));
#line 406
      __cil_tmp40 = k;
#line 406
      k ++;
#line 406
      *(cmap + __cil_tmp40) = *(cmap + (j + 1));
#line 407
      __cil_tmp41 = k;
#line 407
      k ++;
#line 407
      *(cmap + __cil_tmp41) = tmp___1;
#line 410
      if (alphas) {
#line 411
        __cil_tmp42 = nalphas;
#line 411
        nalphas ++;
#line 411
        *(alphas + __cil_tmp42) = *(cmap + (j + 3));
      }
#line 402
      j += pelbytes;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 416
    if ((int )nalphas) {
#line 416
      if ((int )*(alphas + ((int )nalphas - 1)) == 0) {
#line 417
        __cil_tmp43 = colors;
#line 417
        colors --;
      }
    }
#line 420
    abpp = (unsigned short )0;
#line 421
    pbpp = (unsigned short )8;
#line 422
    pelbytes = 1;
  } else {
#line 424
    pelbytes = 3;
  }
  {
#line 426
  image = at_bitmap_init((unsigned char *)((void *)0), width, height, (unsigned int )3);
#line 429
  bpp = (unsigned short )((((int )pbpp + (int )abpp) + 7) / 8);
  }
#line 432
  if ((int )horzrev) {
    {
    {
#line 433
    __cil_tmp45 = malloc((unsigned long )(((int )width * (int )height) * pelbytes) * sizeof(unsigned char ));
    }
#line 433
    buffer = (unsigned char *)__cil_tmp45;
    }
  } else
#line 432
  if ((int )vertrev) {
    {
    {
#line 433
    __cil_tmp45 = malloc((unsigned long )(((int )width * (int )height) * pelbytes) * sizeof(unsigned char ));
    }
#line 433
    buffer = (unsigned char *)__cil_tmp45;
    }
  }
#line 434
  if (rle) {
#line 435
    myfread = & rle_fread;
  } else {
#line 437
    myfread = & std_fread;
  }
#line 439
  wbytes = (int )width * pelbytes;
#line 440
  badread = 0;
#line 442
  npels = (int )width * (int )height;
#line 443
  bsize = wbytes * (int )height;
#line 446
  if (badread) {
#line 447
    pels = 0;
  } else {
    {
#line 449
    pels = (*myfread)(image.bitmap, (int )bpp, npels, fp);
    }
  }
#line 451
  if (pels != npels) {
#line 452
    if (! badread) {
      {
#line 454
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 454
        if (logging) {
          {
#line 454
          __cil_tmp47 = ftell(fp);
#line 454
          fprintf(stdout, "TGA: error reading (ftell == %ld)\n", __cil_tmp47);
          }
        }
#line 454
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
      {
#line 455
      at_exception_warning(exp___0, (gchar *)"TGA: eroor reading file");
#line 456
      badread = 1;
      }
    }
    {
#line 460
    memset(image.bitmap + pels * (int )bpp, 0, (unsigned long )((npels - pels) * (int )bpp));
    }
  }
#line 463
  if (nalphas) {
#line 465
    k = (npels - 1) * (int )bpp;
#line 466
    j = bsize - pelbytes;
    {
#line 466
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 466
      if (! (j >= 0)) {
#line 466
        goto while_break___12;
      }
#line 468
      *(image.bitmap + (j + 1)) = *(alphas + *(image.bitmap + k));
#line 469
      __cil_tmp48 = k;
#line 469
      k --;
#line 469
      *(image.bitmap + j) = *(image.bitmap + __cil_tmp48);
#line 466
      j -= pelbytes;
    }
    while_break___12: /* CIL Label */ ;
    }
  }
#line 473
  if (itype == 3) {
#line 474
    j = bsize / 3 - 1;
    {
#line 474
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 474
      if (! (j >= 0)) {
#line 474
        goto while_break___13;
      }
#line 476
      *(image.bitmap + 3 * j) = *(image.bitmap + j);
#line 477
      *(image.bitmap + (3 * j + 1)) = *(image.bitmap + j);
#line 478
      *(image.bitmap + (3 * j + 2)) = *(image.bitmap + j);
#line 474
      j --;
    }
    while_break___13: /* CIL Label */ ;
    }
  }
#line 481
  if (pelbytes >= 3) {
#line 483
    j = 0;
    {
#line 483
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 483
      if (! (j < bsize)) {
#line 483
        goto while_break___14;
      }
#line 484
      tmp___2 = *(image.bitmap + j);
#line 485
      *(image.bitmap + j) = *(image.bitmap + (j + 2));
#line 486
      *(image.bitmap + (j + 2)) = tmp___2;
#line 483
      j += pelbytes;
    }
    while_break___14: /* CIL Label */ ;
    }
  }
#line 490
  if ((int )horzrev) {
    _L___73: /* CIL Label */ 
#line 492
    if (vertrev) {
#line 494
      j = 0;
      {
#line 494
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 494
        if (! (j < bsize)) {
#line 494
          goto while_break___15;
        }
        {
#line 495
        memcpy(buffer + j, (image.bitmap + bsize) - (j + wbytes), (unsigned long )wbytes);
        }
#line 494
        j += wbytes;
      }
      while_break___15: /* CIL Label */ ;
      }
    } else
#line 496
    if (horzrev) {
#line 498
      j = 0;
      {
#line 498
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 498
        if (! (j < bsize)) {
#line 498
          goto while_break___16;
        }
#line 499
        k = 0;
        {
#line 499
        while (1) {
          while_continue___17: /* CIL Label */ ;
#line 499
          if (! (k < wbytes)) {
#line 499
            goto while_break___17;
          }
          {
#line 500
          memcpy((buffer + k) + j, (image.bitmap + (j + wbytes)) - (k + pelbytes),
                 (unsigned long )pelbytes);
          }
#line 499
          k += pelbytes;
        }
        while_break___17: /* CIL Label */ ;
        }
#line 498
        j += wbytes;
      }
      while_break___16: /* CIL Label */ ;
      }
    } else {
#line 503
      j = 0;
      {
#line 503
      while (1) {
        while_continue___18: /* CIL Label */ ;
#line 503
        if (! (j < bsize)) {
#line 503
          goto while_break___18;
        }
        {
#line 504
        memcpy(buffer + j, (image.bitmap + bsize) - (j + pelbytes), (unsigned long )pelbytes);
        }
#line 503
        j += pelbytes;
      }
      while_break___18: /* CIL Label */ ;
      }
    }
#line 508
    tmp___3 = buffer;
#line 509
    buffer = image.bitmap;
#line 510
    image.bitmap = tmp___3;
  } else
#line 490
  if ((int )vertrev) {
#line 490
    goto _L___73;
  }
  {
#line 513
  __cil_tmp51 = fgetc(fp);
  }
#line 513
  if (__cil_tmp51 != -1) {
    {
#line 514
    while (1) {
      while_continue___19: /* CIL Label */ ;
#line 514
      if (logging) {
        {
#line 514
        fprintf(stdout, "TGA: too much input data, ignoring extra...\n");
        }
      }
#line 514
      goto while_break___19;
    }
    while_break___19: /* CIL Label */ ;
    }
    {
#line 515
    at_exception_warning(exp___0, (gchar *)"TGA: too much input data, ignoring extra datum");
    }
  }
  {
#line 518
  free(buffer);
  }
#line 520
  if ((int )hdr->colorMapType == 1) {
    {
#line 525
    temp = image.bitmap;
#line 525
    temp2 = temp;
#line 526
    __cil_tmp58 = malloc((unsigned long )(((int )width * (int )height) * 3) * sizeof(unsigned char ));
#line 526
    temp3 = (unsigned char *)__cil_tmp58;
#line 526
    image.bitmap = temp3;
#line 528
    ypos = 0;
    }
    {
#line 528
    while (1) {
      while_continue___20: /* CIL Label */ ;
#line 528
      if (! (ypos < (int )height)) {
#line 528
        goto while_break___20;
      }
#line 529
      xpos = 0;
      {
#line 529
      while (1) {
        while_continue___21: /* CIL Label */ ;
#line 529
        if (! (xpos < (int )width)) {
#line 529
          goto while_break___21;
        }
#line 530
        __cil_tmp59 = temp2;
#line 530
        temp2 ++;
#line 530
        index___74 = *__cil_tmp59;
#line 531
        __cil_tmp60 = temp3;
#line 531
        temp3 ++;
#line 531
        *__cil_tmp60 = *(cmap + 3 * (int )index___74);
#line 532
        __cil_tmp61 = temp3;
#line 532
        temp3 ++;
#line 532
        *__cil_tmp61 = *(cmap + (3 * (int )index___74 + 1));
#line 533
        __cil_tmp62 = temp3;
#line 533
        temp3 ++;
#line 533
        *__cil_tmp62 = *(cmap + (3 * (int )index___74 + 2));
#line 529
        xpos ++;
      }
      while_break___21: /* CIL Label */ ;
      }
#line 528
      ypos ++;
    }
    while_break___20: /* CIL Label */ ;
    }
    {
#line 536
    free(temp);
#line 537
    free(cmap);
    }
  }
  {
#line 540
  free(alphas);
  }
#line 542
  return (image);
}
}
#line 45 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-bmp.c"
struct Bitmap_File_Head_Struct Bitmap_File_Head ;
#line 59
struct Bitmap_Head_Struct Bitmap_Head ;
#line 61
static long ToL(unsigned char *puffer ) ;
#line 62
static short ToS(unsigned char *puffer ) ;
#line 63
static int ReadColorMap(FILE *fd , unsigned char buffer[256][3] , int number , int size ,
                        int *grey , at_exception_type *exp___0 ) ;
#line 64
static unsigned char *ReadImage___0(FILE *fd , int width , int height , unsigned char cmap[256][3] ,
                                    int bpp , int compression , int rowbytes , int grey ) ;
#line 66 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-bmp.c"
at_bitmap input_bmp_reader(gchar *filename , at_input_opts_type *opts , at_msg_func msg_func ,
                           gpointer msg_data , gpointer user_data ) 
{ 
  FILE *fd ;
  unsigned char buffer[64] ;
  int ColormapSize ;
  int rowbytes ;
  int Maps ;
  int Grey ;
  unsigned char ColorMap[256][3] ;
  at_bitmap image ;
  at_bitmap __cil_tmp14 ;
  unsigned char *image_storage ;
  at_exception_type exp___0 ;
  at_exception_type __cil_tmp17 ;
  FILE *__cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  int __cil_tmp20 ;
  long __cil_tmp21 ;
  short __cil_tmp22 ;
  short __cil_tmp23 ;
  long __cil_tmp24 ;
  long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  short __cil_tmp27 ;
  short __cil_tmp28 ;
  short __cil_tmp29 ;
  short __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  long __cil_tmp32 ;
  long __cil_tmp33 ;
  short __cil_tmp34 ;
  short __cil_tmp35 ;
  long __cil_tmp36 ;
  long __cil_tmp37 ;
  long __cil_tmp38 ;
  long __cil_tmp39 ;
  long __cil_tmp40 ;
  long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  long __cil_tmp43 ;
  long __cil_tmp44 ;
  short __cil_tmp45 ;
  short __cil_tmp46 ;
  long __cil_tmp47 ;
  long __cil_tmp48 ;
  long __cil_tmp49 ;
  long __cil_tmp50 ;
  long __cil_tmp51 ;
  long __cil_tmp52 ;
  gboolean __cil_tmp53 ;
  unsigned char *__cil_tmp54 ;
  int tmp ;
  at_bitmap __cil_tmp56 ;

  {
  {
#line 72
  __cil_tmp14 = at_bitmap_init((unsigned char *)0, (unsigned short )0, (unsigned short )0,
                               (unsigned int )1);
#line 72
  image = __cil_tmp14;
#line 74
  __cil_tmp17 = at_exception_new(msg_func, msg_data);
#line 74
  exp___0 = __cil_tmp17;
#line 76
  fd = fopen((char const   *)filename, "rb");
  }
#line 78
  if (! fd) {
    {
#line 79
    while (1) {
      while_continue: /* CIL Label */ ;
#line 79
      if (logging) {
        {
#line 79
        fprintf(stdout, "Can\'t open \"%s\"\n\230\001", filename);
        }
      }
#line 79
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 80
    at_exception_fatal(& exp___0, (gchar *)"bmp: cannot open input file");
    }
#line 81
    return (image);
  }
  {
#line 86
  __cil_tmp20 = strncmp((char const   *)((unsigned char *)buffer), "BM", (unsigned long )2);
  }
  {
#line 86
  __cil_tmp19 = fread((unsigned char *)buffer, (unsigned long )18, (unsigned long )1,
                      fd);
  }
#line 86
  if (! (__cil_tmp19 != 0UL)) {
    _L: /* CIL Label */ 
    {
#line 87
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 87
      if (logging) {
        {
#line 87
        fprintf(stdout, "Not a valid BMP file %s\n\230\001", filename);
        }
      }
#line 87
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 88
    at_exception_fatal(& exp___0, (gchar *)"bmp: invalid input file");
    }
#line 89
    goto cleanup;
  } else
#line 86
  if (__cil_tmp20) {
#line 86
    goto _L;
  }
  {
#line 94
  __cil_tmp21 = ToL(& buffer[2]);
#line 94
  Bitmap_File_Head.bfSize = (unsigned long )__cil_tmp21;
#line 95
  __cil_tmp22 = ToS(& buffer[6]);
#line 95
  Bitmap_File_Head.zzHotX = (unsigned short )__cil_tmp22;
#line 96
  __cil_tmp23 = ToS(& buffer[8]);
#line 96
  Bitmap_File_Head.zzHotY = (unsigned short )__cil_tmp23;
#line 97
  __cil_tmp24 = ToL(& buffer[10]);
#line 97
  Bitmap_File_Head.bfOffs = (unsigned long )__cil_tmp24;
#line 98
  __cil_tmp25 = ToL(& buffer[14]);
#line 98
  Bitmap_File_Head.biSize = (unsigned long )__cil_tmp25;
  }
#line 102
  if (Bitmap_File_Head.biSize == 12UL) {
    {
#line 103
    __cil_tmp26 = fread((unsigned char *)buffer, (unsigned long )8, (unsigned long )1,
                        fd);
    }
#line 103
    if (! (__cil_tmp26 != 0UL)) {
      {
#line 104
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 104
        if (logging) {
          {
#line 104
          fprintf(stdout, "Error reading BMP file header\n");
          }
        }
#line 104
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 105
      at_exception_fatal(& exp___0, (gchar *)"Error reading BMP file header");
      }
#line 106
      goto cleanup;
    }
    {
#line 109
    __cil_tmp27 = ToS(& buffer[0]);
#line 109
    Bitmap_Head.biWidth = (unsigned long )__cil_tmp27;
#line 110
    __cil_tmp28 = ToS(& buffer[2]);
#line 110
    Bitmap_Head.biHeight = (unsigned long )__cil_tmp28;
#line 111
    __cil_tmp29 = ToS(& buffer[4]);
#line 111
    Bitmap_Head.biPlanes = (unsigned short )__cil_tmp29;
#line 112
    __cil_tmp30 = ToS(& buffer[6]);
#line 112
    Bitmap_Head.biBitCnt = (unsigned short )__cil_tmp30;
#line 113
    Bitmap_Head.biCompr = (unsigned long )0;
#line 114
    Bitmap_Head.biSizeIm = (unsigned long )0;
#line 115
    Bitmap_Head.biYPels = (unsigned long )0;
#line 115
    Bitmap_Head.biXPels = Bitmap_Head.biYPels;
#line 116
    Bitmap_Head.biClrUsed = (unsigned long )0;
#line 117
    Maps = 3;
    }
  } else
#line 118
  if (Bitmap_File_Head.biSize == 40UL) {
    {
#line 119
    __cil_tmp31 = fread((unsigned char *)buffer, Bitmap_File_Head.biSize - 4UL, (unsigned long )1,
                        fd);
    }
#line 119
    if (! (__cil_tmp31 != 0UL)) {
      {
#line 120
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 120
        if (logging) {
          {
#line 120
          fprintf(stdout, "Error reading BMP file header\n");
          }
        }
#line 120
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 121
      at_exception_fatal(& exp___0, (gchar *)"Error reading BMP file header");
      }
#line 122
      goto cleanup;
    }
    {
#line 125
    __cil_tmp32 = ToL(& buffer[0]);
#line 125
    Bitmap_Head.biWidth = (unsigned long )__cil_tmp32;
#line 126
    __cil_tmp33 = ToL(& buffer[4]);
#line 126
    Bitmap_Head.biHeight = (unsigned long )__cil_tmp33;
#line 127
    __cil_tmp34 = ToS(& buffer[8]);
#line 127
    Bitmap_Head.biPlanes = (unsigned short )__cil_tmp34;
#line 128
    __cil_tmp35 = ToS(& buffer[10]);
#line 128
    Bitmap_Head.biBitCnt = (unsigned short )__cil_tmp35;
#line 129
    __cil_tmp36 = ToL(& buffer[12]);
#line 129
    Bitmap_Head.biCompr = (unsigned long )__cil_tmp36;
#line 130
    __cil_tmp37 = ToL(& buffer[16]);
#line 130
    Bitmap_Head.biSizeIm = (unsigned long )__cil_tmp37;
#line 131
    __cil_tmp38 = ToL(& buffer[20]);
#line 131
    Bitmap_Head.biXPels = (unsigned long )__cil_tmp38;
#line 132
    __cil_tmp39 = ToL(& buffer[24]);
#line 132
    Bitmap_Head.biYPels = (unsigned long )__cil_tmp39;
#line 133
    __cil_tmp40 = ToL(& buffer[28]);
#line 133
    Bitmap_Head.biClrUsed = (unsigned long )__cil_tmp40;
#line 134
    __cil_tmp41 = ToL(& buffer[32]);
#line 134
    Bitmap_Head.biClrImp = (unsigned long )__cil_tmp41;
#line 136
    Maps = 4;
    }
  } else
#line 137
  if (Bitmap_File_Head.biSize >= 40UL) {
#line 137
    if (Bitmap_File_Head.biSize <= 64UL) {
      {
#line 138
      __cil_tmp42 = fread((unsigned char *)buffer, Bitmap_File_Head.biSize - 4UL,
                          (unsigned long )1, fd);
      }
#line 138
      if (! (__cil_tmp42 != 0UL)) {
        {
#line 139
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 139
          if (logging) {
            {
#line 139
            fprintf(stdout, "Error reading BMP file header\n");
            }
          }
#line 139
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 140
        at_exception_fatal(& exp___0, (gchar *)"Error reading BMP file header");
        }
#line 141
        goto cleanup;
      }
      {
#line 144
      __cil_tmp43 = ToL(& buffer[0]);
#line 144
      Bitmap_Head.biWidth = (unsigned long )__cil_tmp43;
#line 145
      __cil_tmp44 = ToL(& buffer[4]);
#line 145
      Bitmap_Head.biHeight = (unsigned long )__cil_tmp44;
#line 146
      __cil_tmp45 = ToS(& buffer[8]);
#line 146
      Bitmap_Head.biPlanes = (unsigned short )__cil_tmp45;
#line 147
      __cil_tmp46 = ToS(& buffer[10]);
#line 147
      Bitmap_Head.biBitCnt = (unsigned short )__cil_tmp46;
#line 148
      __cil_tmp47 = ToL(& buffer[12]);
#line 148
      Bitmap_Head.biCompr = (unsigned long )__cil_tmp47;
#line 149
      __cil_tmp48 = ToL(& buffer[16]);
#line 149
      Bitmap_Head.biSizeIm = (unsigned long )__cil_tmp48;
#line 150
      __cil_tmp49 = ToL(& buffer[20]);
#line 150
      Bitmap_Head.biXPels = (unsigned long )__cil_tmp49;
#line 151
      __cil_tmp50 = ToL(& buffer[24]);
#line 151
      Bitmap_Head.biYPels = (unsigned long )__cil_tmp50;
#line 152
      __cil_tmp51 = ToL(& buffer[28]);
#line 152
      Bitmap_Head.biClrUsed = (unsigned long )__cil_tmp51;
#line 153
      __cil_tmp52 = ToL(& buffer[32]);
#line 153
      Bitmap_Head.biClrImp = (unsigned long )__cil_tmp52;
#line 155
      Maps = 3;
      }
    } else {
#line 137
      goto _L___75;
    }
  } else {
    _L___75: /* CIL Label */ 
    {
#line 157
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 157
      if (logging) {
        {
#line 157
        fprintf(stdout, "Error reading BMP file header\n");
        }
      }
#line 157
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 158
    at_exception_fatal(& exp___0, (gchar *)"Error reading BMP file header");
    }
#line 159
    goto cleanup;
  }
#line 167
  ColormapSize = (int )(((Bitmap_File_Head.bfOffs - Bitmap_File_Head.biSize) - 14UL) / (unsigned long )Maps);
#line 169
  if (Bitmap_Head.biClrUsed == 0UL) {
#line 169
    if ((int )Bitmap_Head.biBitCnt <= 8) {
#line 170
      Bitmap_Head.biClrUsed = (unsigned long )ColormapSize;
    }
  }
#line 174
  if (Bitmap_Head.biHeight == 0UL) {
    _L___76: /* CIL Label */ 
    _L___77: /* CIL Label */ 
    _L___78: /* CIL Label */ 
    {
#line 177
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 177
      if (logging) {
        {
#line 177
        fprintf(stdout, "Error reading BMP file header\n");
        }
      }
#line 177
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 178
    at_exception_fatal(& exp___0, (gchar *)"Error reading BMP file header");
    }
#line 179
    goto cleanup;
  } else
#line 174
  if (Bitmap_Head.biWidth == 0UL) {
#line 174
    goto _L___76;
  } else
#line 174
  if ((int )Bitmap_Head.biPlanes != 1) {
#line 174
    goto _L___76;
  } else
#line 174
  if (ColormapSize > 256) {
#line 174
    goto _L___76;
  } else
#line 174
  if (Bitmap_Head.biClrUsed > 256UL) {
#line 174
    goto _L___76;
  }
  {
#line 190
  rowbytes = (int )(((Bitmap_Head.biWidth * (unsigned long )Bitmap_Head.biBitCnt - 1UL) / 32UL) * 4UL + 4UL);
#line 197
  ReadColorMap(fd, (unsigned char (*)[3])ColorMap, ColormapSize, Maps, & Grey, & exp___0);
#line 198
  __cil_tmp53 = at_exception_got_fatal(& exp___0);
  }
#line 198
  if (__cil_tmp53) {
#line 199
    goto cleanup;
  }
  {
#line 206
  image_storage = ReadImage___0(fd, (int )Bitmap_Head.biWidth, (int )Bitmap_Head.biHeight,
                                (unsigned char (*)[3])ColorMap, (int )Bitmap_Head.biBitCnt,
                                (int )Bitmap_Head.biCompr, rowbytes, Grey);
  }
#line 207
  if (Grey) {
#line 207
    tmp = 1;
  } else {
#line 207
    tmp = 3;
  }
  {
#line 207
  __cil_tmp56 = at_bitmap_init(image_storage, (unsigned short )Bitmap_Head.biWidth,
                               (unsigned short )Bitmap_Head.biHeight, (unsigned int )tmp);
#line 207
  image = __cil_tmp56;
  }
  cleanup: 
  {
#line 209
  fclose(fd);
  }
#line 210
  return (image);
}
}
#line 213 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-bmp.c"
static int ReadColorMap(FILE *fd , unsigned char buffer[256][3] , int number , int size ,
                        int *grey , at_exception_type *exp___0 ) 
{ 
  int i ;
  unsigned char rgb[4] ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;

  {
#line 218
  *grey = number > 2;
#line 219
  i = 0;
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
#line 219
    if (! (i < number)) {
#line 219
      goto while_break;
    }
    {
#line 220
    __cil_tmp9 = fread((unsigned char *)rgb, (unsigned long )size, (unsigned long )1,
                       fd);
    }
#line 220
    if (! (__cil_tmp9 != 0UL)) {
      {
#line 221
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 221
        if (logging) {
          {
#line 221
          fprintf(stdout, "Bad colormap\n");
          }
        }
#line 221
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 222
      at_exception_fatal(exp___0, (gchar *)"Bad colormap");
      }
#line 223
      goto cleanup;
    }
#line 228
    buffer[i][0] = rgb[2];
#line 229
    buffer[i][1] = rgb[1];
#line 230
    buffer[i][2] = rgb[0];
#line 231
    *grey = (*grey && (int )rgb[0] == (int )rgb[1]) && (int )rgb[1] == (int )rgb[2];
#line 219
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  cleanup: 
#line 234
  return (0);
}
}
#line 237 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-bmp.c"
static unsigned char *ReadImage___0(FILE *fd , int width , int height , unsigned char cmap[256][3] ,
                                    int bpp , int compression , int rowbytes , int grey ) 
{ 
  unsigned char v ;
  unsigned char howmuch ;
  int xpos ;
  int ypos ;
  unsigned char *image ;
  unsigned char *temp ;
  unsigned char *buffer ;
  long rowstride ;
  long channels ;
  unsigned short rgb ;
  int i ;
  int j ;
  int notused ;
  void *__cil_tmp22 ;
  int tmp ;
  void *__cil_tmp24 ;
  int tmp___0 ;
  void *__cil_tmp26 ;
  int tmp___1 ;
  void *__cil_tmp28 ;
  int tmp___2 ;
  unsigned long __cil_tmp30 ;
  unsigned char *__cil_tmp31 ;
  unsigned char *__cil_tmp32 ;
  unsigned char *__cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  unsigned char *__cil_tmp35 ;
  unsigned char *__cil_tmp36 ;
  unsigned char *__cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  short __cil_tmp39 ;
  unsigned char *__cil_tmp40 ;
  unsigned char *__cil_tmp41 ;
  unsigned char *__cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  int __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  int __cil_tmp49 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  int __cil_tmp53 ;
  int __cil_tmp54 ;
  unsigned char __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  int __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  unsigned char *temp2 ;
  unsigned char *temp3 ;
  unsigned char index___79 ;
  void *__cil_tmp62 ;
  int tmp___3 ;
  unsigned char *__cil_tmp64 ;
  unsigned char *__cil_tmp65 ;
  unsigned char *__cil_tmp66 ;
  unsigned char *__cil_tmp67 ;
  int __cil_tmp68 ;
  int __cil_tmp69 ;

  {
#line 240
  xpos = 0;
#line 240
  ypos = 0;
#line 247
  if (bpp >= 16) {
    {
#line 248
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 248
      __cil_tmp22 = malloc((unsigned long )((width * height) * 3) * sizeof(unsigned char ));
#line 248
      image = (gpointer )__cil_tmp22;
      }
#line 248
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 249
    channels = (long )3;
  } else
#line 250
  if (grey) {
    {
#line 251
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 251
      __cil_tmp24 = malloc((unsigned long )(width * height) * sizeof(unsigned char ));
#line 251
      image = (gpointer )__cil_tmp24;
      }
#line 251
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 252
    channels = (long )1;
  } else {
    {
#line 255
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 255
      __cil_tmp26 = malloc((unsigned long )(width * height) * sizeof(unsigned char ));
#line 255
      image = (gpointer )__cil_tmp26;
      }
#line 255
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 256
    channels = (long )1;
  }
  {
#line 259
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 259
    __cil_tmp28 = malloc((unsigned long )rowbytes);
#line 259
    buffer = (gpointer )__cil_tmp28;
    }
#line 259
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 260
  rowstride = (long )width * channels;
#line 262
  ypos = height - 1;
  {
#line 266
  if (bpp == 32) {
#line 266
    goto case_32;
  }
#line 280
  if (bpp == 24) {
#line 280
    goto case_24;
  }
#line 294
  if (bpp == 16) {
#line 294
    goto case_16;
  }
#line 311
  if (bpp == 1) {
#line 311
    goto case_1;
  }
#line 311
  if (bpp == 4) {
#line 311
    goto case_1;
  }
#line 311
  if (bpp == 8) {
#line 311
    goto case_1;
  }
#line 390
  goto switch_default;
  case_32: /* CIL Label */ 
  {
#line 268
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 268
    __cil_tmp30 = fread(buffer, (unsigned long )rowbytes, (unsigned long )1, fd);
    }
#line 268
    if (! (__cil_tmp30 != 0UL)) {
#line 268
      goto while_break___3;
    }
#line 269
    temp = image + (long )ypos * rowstride;
#line 270
    xpos = 0;
    {
#line 270
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 270
      if (! (xpos < width)) {
#line 270
        goto while_break___4;
      }
#line 271
      __cil_tmp31 = temp;
#line 271
      temp ++;
#line 271
      *__cil_tmp31 = *(buffer + (xpos * 4 + 2));
#line 272
      __cil_tmp32 = temp;
#line 272
      temp ++;
#line 272
      *__cil_tmp32 = *(buffer + (xpos * 4 + 1));
#line 273
      __cil_tmp33 = temp;
#line 273
      temp ++;
#line 273
      *__cil_tmp33 = *(buffer + xpos * 4);
#line 270
      xpos ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 275
    ypos --;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 278
  goto switch_break;
  case_24: /* CIL Label */ 
  {
#line 282
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 282
    __cil_tmp34 = fread(buffer, (unsigned long )rowbytes, (unsigned long )1, fd);
    }
#line 282
    if (! (__cil_tmp34 != 0UL)) {
#line 282
      goto while_break___5;
    }
#line 283
    temp = image + (long )ypos * rowstride;
#line 284
    xpos = 0;
    {
#line 284
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 284
      if (! (xpos < width)) {
#line 284
        goto while_break___6;
      }
#line 285
      __cil_tmp35 = temp;
#line 285
      temp ++;
#line 285
      *__cil_tmp35 = *(buffer + (xpos * 3 + 2));
#line 286
      __cil_tmp36 = temp;
#line 286
      temp ++;
#line 286
      *__cil_tmp36 = *(buffer + (xpos * 3 + 1));
#line 287
      __cil_tmp37 = temp;
#line 287
      temp ++;
#line 287
      *__cil_tmp37 = *(buffer + xpos * 3);
#line 284
      xpos ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 289
    ypos --;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 292
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 296
  while (1) {
    while_continue___7: /* CIL Label */ ;
    {
#line 296
    __cil_tmp38 = fread(buffer, (unsigned long )rowbytes, (unsigned long )1, fd);
    }
#line 296
    if (! (__cil_tmp38 != 0UL)) {
#line 296
      goto while_break___7;
    }
#line 297
    temp = image + (long )ypos * rowstride;
#line 298
    xpos = 0;
    {
#line 298
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 298
      if (! (xpos < width)) {
#line 298
        goto while_break___8;
      }
      {
#line 299
      __cil_tmp39 = ToS(buffer + xpos * 2);
#line 299
      rgb = (unsigned short )__cil_tmp39;
#line 300
      __cil_tmp40 = temp;
#line 300
      temp ++;
#line 300
      *__cil_tmp40 = (unsigned char )((((int )rgb >> 10) & 31) * 8);
#line 301
      __cil_tmp41 = temp;
#line 301
      temp ++;
#line 301
      *__cil_tmp41 = (unsigned char )((((int )rgb >> 5) & 31) * 8);
#line 302
      __cil_tmp42 = temp;
#line 302
      temp ++;
#line 302
      *__cil_tmp42 = (unsigned char )(((int )rgb & 31) * 8);
      }
#line 298
      xpos ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 304
    ypos --;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 307
  goto switch_break;
  case_1: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_8: /* CIL Label */ 
#line 313
  if (compression == 0) {
    {
#line 314
    while (1) {
      while_continue___9: /* CIL Label */ ;
      {
#line 314
      __cil_tmp43 = fread(& v, (unsigned long )1, (unsigned long )1, fd);
      }
#line 314
      if (! (__cil_tmp43 != 0UL)) {
#line 314
        goto while_break___9;
      }
#line 315
      i = 1;
      {
#line 315
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 315
        if (! (i <= 8 / bpp && xpos < width)) {
#line 315
          goto while_break___10;
        }
#line 316
        temp = (unsigned char *)((image + (long )ypos * rowstride) + (long )xpos * channels);
#line 317
        *temp = (unsigned char )(((int )v & (((1 << bpp) - 1) << (8 - i * bpp))) >> (8 - i * bpp));
#line 315
        __cil_tmp45 = xpos;
#line 315
        xpos ++;
#line 315
        __cil_tmp44 = i;
#line 315
        i ++;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 319
      if (xpos == width) {
        {
#line 320
        __cil_tmp46 = fread(buffer, (unsigned long )((rowbytes - 1) - (width * bpp - 1) / 8),
                            (unsigned long )1, fd);
#line 320
        notused = __cil_tmp46 != 0UL;
#line 321
        __cil_tmp47 = ypos;
#line 321
        ypos --;
#line 322
        xpos = 0;
        }
      }
#line 325
      if (ypos < 0) {
#line 326
        goto while_break___9;
      }
    }
    while_break___9: /* CIL Label */ ;
    }
#line 328
    goto switch_break;
  } else {
    {
#line 330
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 330
      if (! (ypos >= 0 && xpos <= width)) {
#line 330
        goto while_break___11;
      }
      {
#line 331
      __cil_tmp48 = fread(buffer, (unsigned long )2, (unsigned long )1, fd);
#line 331
      notused = __cil_tmp48 != 0UL;
      }
#line 332
      if ((int )((unsigned char )*(buffer + 0)) != 0) {
#line 335
        j = 0;
        {
#line 335
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 335
          if (! ((int )((unsigned char )j) < (int )((unsigned char )*(buffer + 0)) && xpos < width)) {
#line 335
            goto while_break___12;
          }
#line 339
          i = 1;
          {
#line 339
          while (1) {
            while_continue___13: /* CIL Label */ ;
#line 339
            if (! ((i <= 8 / bpp && xpos < width) && (int )((unsigned char )j) < (int )((unsigned char )*(buffer + 0)))) {
#line 339
              goto while_break___13;
            }
#line 340
            temp = (image + (long )ypos * rowstride) + (long )xpos * channels;
#line 341
            *temp = (unsigned char )(((int )*(buffer + 1) & (((1 << bpp) - 1) << (8 - i * bpp))) >> (8 - i * bpp));
#line 339
            __cil_tmp51 = j;
#line 339
            j ++;
#line 339
            __cil_tmp50 = xpos;
#line 339
            xpos ++;
#line 339
            __cil_tmp49 = i;
#line 339
            i ++;
          }
          while_break___13: /* CIL Label */ ;
          }
        }
        while_break___12: /* CIL Label */ ;
        }
      }
#line 345
      if ((int )((unsigned char )*(buffer + 0)) == 0) {
#line 345
        if ((int )((unsigned char )*(buffer + 1)) > 2) {
#line 348
          howmuch = *(buffer + 1);
#line 349
          j = 0;
          {
#line 349
          while (1) {
            while_continue___14: /* CIL Label */ ;
#line 349
            if (! (j < (int )howmuch)) {
#line 349
              goto while_break___14;
            }
            {
#line 350
            __cil_tmp52 = fread(& v, (unsigned long )1, (unsigned long )1, fd);
#line 350
            notused = __cil_tmp52 != 0UL;
#line 351
            i = 1;
            }
            {
#line 352
            while (1) {
              while_continue___15: /* CIL Label */ ;
#line 352
              if (! (i <= 8 / bpp && xpos < width)) {
#line 352
                goto while_break___15;
              }
#line 353
              temp = (image + (long )ypos * rowstride) + (long )xpos * channels;
#line 354
              *temp = (unsigned char )(((int )v & (((1 << bpp) - 1) << (8 - i * bpp))) >> (8 - i * bpp));
#line 355
              i ++;
#line 356
              xpos ++;
            }
            while_break___15: /* CIL Label */ ;
            }
#line 349
            j += 8 / bpp;
          }
          while_break___14: /* CIL Label */ ;
          }
#line 360
          if ((int )howmuch % 2) {
#line 360
            if (bpp == 4) {
#line 361
              howmuch ++;
            }
          }
#line 363
          if (((int )howmuch / (8 / bpp)) % 2) {
            {
#line 364
            __cil_tmp56 = fread(& v, (unsigned long )1, (unsigned long )1, fd);
#line 364
            notused = __cil_tmp56 != 0UL;
            }
          }
        }
      }
#line 367
      if ((int )((unsigned char )*(buffer + 0)) == 0) {
#line 367
        if ((int )((unsigned char )*(buffer + 1)) == 0) {
#line 370
          __cil_tmp57 = ypos;
#line 370
          ypos --;
#line 371
          xpos = 0;
        }
      }
#line 373
      if ((int )((unsigned char )*(buffer + 0)) == 0) {
#line 373
        if ((int )((unsigned char )*(buffer + 1)) == 1) {
#line 376
          goto while_break___11;
        }
      }
#line 378
      if ((int )((unsigned char )*(buffer + 0)) == 0) {
#line 378
        if ((int )((unsigned char )*(buffer + 1)) == 2) {
          {
#line 381
          __cil_tmp58 = fread(buffer, (unsigned long )2, (unsigned long )1, fd);
#line 381
          notused = __cil_tmp58 != 0UL;
#line 382
          xpos += (int )((unsigned char )*(buffer + 0));
#line 383
          ypos -= (int )((unsigned char )*(buffer + 1));
          }
        }
      }
    }
    while_break___11: /* CIL Label */ ;
    }
#line 386
    goto switch_break;
  }
#line 389
  goto switch_break;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 395
  if (bpp <= 8) {
#line 398
    temp = image;
#line 398
    temp2 = temp;
    {
#line 399
    while (1) {
      while_continue___16: /* CIL Label */ ;
      {
#line 399
      __cil_tmp62 = malloc((unsigned long )((width * height) * 3) * sizeof(unsigned char ));
#line 399
      image = (gpointer )__cil_tmp62;
      }
#line 399
      goto while_break___16;
    }
    while_break___16: /* CIL Label */ ;
    }
#line 400
    temp3 = image;
#line 401
    ypos = 0;
    {
#line 401
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 401
      if (! (ypos < height)) {
#line 401
        goto while_break___17;
      }
#line 402
      xpos = 0;
      {
#line 402
      while (1) {
        while_continue___18: /* CIL Label */ ;
#line 402
        if (! (xpos < width)) {
#line 402
          goto while_break___18;
        }
#line 403
        __cil_tmp64 = temp2;
#line 403
        temp2 ++;
#line 403
        index___79 = *__cil_tmp64;
#line 404
        __cil_tmp65 = temp3;
#line 404
        temp3 ++;
#line 404
        *__cil_tmp65 = cmap[index___79][0];
#line 405
        if (! grey) {
#line 406
          __cil_tmp66 = temp3;
#line 406
          temp3 ++;
#line 406
          *__cil_tmp66 = cmap[index___79][1];
#line 407
          __cil_tmp67 = temp3;
#line 407
          temp3 ++;
#line 407
          *__cil_tmp67 = cmap[index___79][2];
        }
#line 402
        xpos ++;
      }
      while_break___18: /* CIL Label */ ;
      }
#line 401
      ypos ++;
    }
    while_break___17: /* CIL Label */ ;
    }
    {
#line 411
    free(temp);
    }
  }
  {
#line 414
  free(buffer);
  }
#line 415
  return (image);
}
}
#line 418 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-bmp.c"
static long ToL(unsigned char *puffer ) 
{ 


  {
#line 420
  return ((long )((((int )*(puffer + 0) | ((int )*(puffer + 1) << 8)) | ((int )*(puffer + 2) << 16)) | ((int )*(puffer + 3) << 24)));
}
}
#line 423 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-bmp.c"
static short ToS(unsigned char *puffer ) 
{ 


  {
#line 425
  return ((short )((int )*(puffer + 0) | ((int )*(puffer + 1) << 8)));
}
}
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void) ;
#line 81
extern  __attribute__((__nothrow__)) __int32_t **__ctype_tolower_loc(void) ;
#line 83
extern  __attribute__((__nothrow__)) __int32_t **__ctype_toupper_loc(void) ;
#line 108
extern  __attribute__((__nothrow__)) int isalnum(int  ) ;
#line 109
extern  __attribute__((__nothrow__)) int isalpha(int  ) ;
#line 110
extern  __attribute__((__nothrow__)) int iscntrl(int  ) ;
#line 111
extern  __attribute__((__nothrow__)) int isdigit(int  ) ;
#line 112
extern  __attribute__((__nothrow__)) int islower(int  ) ;
#line 113
extern  __attribute__((__nothrow__)) int isgraph(int  ) ;
#line 114
extern  __attribute__((__nothrow__)) int isprint(int  ) ;
#line 115
extern  __attribute__((__nothrow__)) int ispunct(int  ) ;
#line 116
extern  __attribute__((__nothrow__)) int isspace(int  ) ;
#line 117
extern  __attribute__((__nothrow__)) int isupper(int  ) ;
#line 118
extern  __attribute__((__nothrow__)) int isxdigit(int  ) ;
#line 122
__inline extern  __attribute__((__nothrow__)) int tolower(int __c )  __attribute__((__gnu_inline__)) ;
#line 125
__inline extern  __attribute__((__nothrow__)) int toupper(int __c )  __attribute__((__gnu_inline__)) ;
#line 130
extern  __attribute__((__nothrow__)) int isblank(int  ) ;
#line 142
extern  __attribute__((__nothrow__)) int isascii(int __c ) ;
#line 146
extern  __attribute__((__nothrow__)) int toascii(int __c ) ;
#line 150
extern  __attribute__((__nothrow__)) int _toupper(int  ) ;
#line 151
extern  __attribute__((__nothrow__)) int _tolower(int  ) ;
#line 207
__inline extern  __attribute__((__nothrow__)) int tolower(int __c )  __attribute__((__gnu_inline__)) ;
#line 207 "/usr/include/ctype.h"
__inline extern int tolower(int __c ) 
{ 
  __int32_t **__cil_tmp2 ;
  __int32_t tmp ;

  {
#line 209
  if (__c >= -128 && __c < 256) {
    {
#line 209
    __cil_tmp2 = __ctype_tolower_loc();
#line 209
    tmp = *(*__cil_tmp2 + __c);
    }
  } else {
#line 209
    tmp = __c;
  }
#line 209
  return (tmp);
}
}
#line 213
__inline extern  __attribute__((__nothrow__)) int toupper(int __c )  __attribute__((__gnu_inline__)) ;
#line 213 "/usr/include/ctype.h"
__inline extern int toupper(int __c ) 
{ 
  __int32_t **__cil_tmp2 ;
  __int32_t tmp ;

  {
#line 215
  if (__c >= -128 && __c < 256) {
    {
#line 215
    __cil_tmp2 = __ctype_toupper_loc();
#line 215
    tmp = *(*__cil_tmp2 + __c);
    }
  } else {
#line 215
    tmp = __c;
  }
#line 215
  return (tmp);
}
}
#line 251
extern  __attribute__((__nothrow__)) int isalnum_l(int  , locale_t  ) ;
#line 252
extern  __attribute__((__nothrow__)) int isalpha_l(int  , locale_t  ) ;
#line 253
extern  __attribute__((__nothrow__)) int iscntrl_l(int  , locale_t  ) ;
#line 254
extern  __attribute__((__nothrow__)) int isdigit_l(int  , locale_t  ) ;
#line 255
extern  __attribute__((__nothrow__)) int islower_l(int  , locale_t  ) ;
#line 256
extern  __attribute__((__nothrow__)) int isgraph_l(int  , locale_t  ) ;
#line 257
extern  __attribute__((__nothrow__)) int isprint_l(int  , locale_t  ) ;
#line 258
extern  __attribute__((__nothrow__)) int ispunct_l(int  , locale_t  ) ;
#line 259
extern  __attribute__((__nothrow__)) int isspace_l(int  , locale_t  ) ;
#line 260
extern  __attribute__((__nothrow__)) int isupper_l(int  , locale_t  ) ;
#line 261
extern  __attribute__((__nothrow__)) int isxdigit_l(int  , locale_t  ) ;
#line 263
extern  __attribute__((__nothrow__)) int isblank_l(int  , locale_t  ) ;
#line 267
extern  __attribute__((__nothrow__)) int __tolower_l(int __c , locale_t __l ) ;
#line 268
extern  __attribute__((__nothrow__)) int tolower_l(int __c , locale_t __l ) ;
#line 271
extern  __attribute__((__nothrow__)) int __toupper_l(int __c , locale_t __l ) ;
#line 272
extern  __attribute__((__nothrow__)) int toupper_l(int __c , locale_t __l ) ;
#line 71 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-pnm.c"
static void pnm_load_ascii(PNMScanner *scan , PNMInfo *info , unsigned char *data ,
                           at_exception_type *excep ) ;
#line 72
static void pnm_load_raw(PNMScanner *scan , PNMInfo *info , unsigned char *data ,
                         at_exception_type *excep ) ;
#line 73
static void pnm_load_rawpbm(PNMScanner *scan , PNMInfo *info , unsigned char *data ,
                            at_exception_type *excep ) ;
#line 75
static void pnmscanner_destroy(PNMScanner *s ) ;
#line 76
static void pnmscanner_createbuffer(PNMScanner *s , unsigned int bufsize ) ;
#line 77
static void pnmscanner_getchar(PNMScanner *s ) ;
#line 78
static void pnmscanner_eatwhitespace(PNMScanner *s ) ;
#line 79
static void pnmscanner_gettoken(PNMScanner *s , unsigned char *buf , unsigned int bufsize ) ;
#line 80
static void pnmscanner_getsmalltoken(PNMScanner *s , unsigned char *buf ) ;
#line 82
static PNMScanner *pnmscanner_create(FILE *fd ) ;
#line 93 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-pnm.c"
static struct struct_pnm_types pnm_types[7]  = {      {(char )'1', 0, 1, 1, & pnm_load_ascii}, 
        {(char )'2', 1, 1, 255, & pnm_load_ascii}, 
        {(char )'3', 3, 1, 255, & pnm_load_ascii}, 
        {(char )'4', 0, 0, 1, & pnm_load_rawpbm}, 
        {(char )'5', 1, 0, 255, & pnm_load_raw}, 
        {(char )'6', 3, 0, 255, & pnm_load_raw}, 
        {(char )0, 0, 0, 0, (void (*)(PNMScanner * , struct _PNMInfo * , unsigned char * ,
                                   at_exception_type * ))((void *)0)}};
#line 110 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-pnm.c"
at_bitmap input_pnm_reader(gchar *filename , at_input_opts_type *opts , at_msg_func msg_func ,
                           gpointer msg_data , gpointer user_data ) 
{ 
  char buf[512] ;
  PNMInfo *pnminfo ;
  PNMScanner *scan ;
  int ctr ;
  FILE *fd ;
  at_bitmap bitmap ;
  at_bitmap __cil_tmp12 ;
  at_exception_type excep ;
  at_exception_type __cil_tmp14 ;
  FILE *__cil_tmp15 ;
  void *__cil_tmp16 ;
  PNMScanner *__cil_tmp17 ;
  int __cil_tmp18 ;
  unsigned short const   **__cil_tmp19 ;
  int __cil_tmp20 ;
  int tmp ;
  unsigned short const   **__cil_tmp22 ;
  int __cil_tmp23 ;
  int tmp___0 ;
  unsigned short const   **__cil_tmp25 ;
  int __cil_tmp26 ;
  int tmp___1 ;
  int tmp___2 ;
  at_bitmap __cil_tmp29 ;

  {
  {
#line 117
  __cil_tmp12 = at_bitmap_init((unsigned char *)((void *)0), (unsigned short )0, (unsigned short )0,
                               (unsigned int )0);
#line 117
  bitmap = __cil_tmp12;
#line 118
  __cil_tmp14 = at_exception_new(msg_func, msg_data);
#line 118
  excep = __cil_tmp14;
#line 121
  fd = fopen((char const   *)filename, "rb");
  }
#line 123
  if (fd == (void *)0) {
    {
#line 124
    while (1) {
      while_continue: /* CIL Label */ ;
#line 124
      if (logging) {
        {
#line 124
        fprintf(stdout, "pnm filter: can\'t open file\n");
        }
      }
#line 124
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 125
    at_exception_fatal(& excep, (gchar *)"pnm filter: can\'t open file");
    }
#line 126
    return (bitmap);
  }
  {
#line 130
  __cil_tmp16 = malloc(sizeof(PNMInfo ));
#line 130
  pnminfo = (PNMInfo *)__cil_tmp16;
#line 132
  scan = (PNMScanner *)((void *)0);
#line 135
  scan = pnmscanner_create(fd);
#line 138
  pnmscanner_gettoken(scan, (unsigned char *)((char *)buf), (unsigned int )512);
  }
#line 139
  if (scan->eof) {
    {
#line 140
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 140
      if (logging) {
        {
#line 140
        fprintf(stdout, "pnm filter: premature end of file\n");
        }
      }
#line 140
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 141
    at_exception_fatal(& excep, (gchar *)"pnm filter: premature end of file");
    }
#line 142
    goto cleanup;
  }
#line 144
  if ((int )buf[0] != 80) {
    _L: /* CIL Label */ 
    {
#line 145
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 145
      if (logging) {
        {
#line 145
        fprintf(stdout, "pnm filter: %s is not a valid file\n", filename);
        }
      }
#line 145
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 146
    at_exception_fatal(& excep, (gchar *)"pnm filter: invalid file\220");
    }
#line 147
    goto cleanup;
  } else
#line 144
  if ((int )buf[2]) {
#line 144
    goto _L;
  }
#line 151
  ctr = 0;
  {
#line 151
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 151
    if (! pnm_types[ctr].name) {
#line 151
      goto while_break___2;
    }
#line 152
    if ((int )buf[1] == (int )pnm_types[ctr].name) {
#line 153
      pnminfo->np = pnm_types[ctr].np;
#line 154
      pnminfo->asciibody = pnm_types[ctr].asciibody;
#line 155
      pnminfo->maxval = pnm_types[ctr].maxval;
#line 156
      pnminfo->loader = pnm_types[ctr].loader;
    }
#line 151
    ctr ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 158
  if (! pnminfo->loader) {
    {
#line 159
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 159
      if (logging) {
        {
#line 159
        fprintf(stdout, "pnm filter: file not in a supported format\n");
        }
      }
#line 159
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 160
    at_exception_fatal(& excep, (gchar *)"pnm filter: file not in a supported format");
    }
#line 161
    goto cleanup;
  }
  {
#line 164
  pnmscanner_gettoken(scan, (unsigned char *)((char *)buf), (unsigned int )512);
  }
#line 165
  if (scan->eof) {
    {
#line 166
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 166
      if (logging) {
        {
#line 166
        fprintf(stdout, "pnm filter: premature end of file\n");
        }
      }
#line 166
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 167
    at_exception_fatal(& excep, (gchar *)"pnm filter: premature end of file");
    }
#line 168
    goto cleanup;
  }
  {
#line 170
  __cil_tmp19 = __ctype_b_loc();
  }
#line 170
  if ((int )*(*__cil_tmp19 + (int )*((char *)buf)) & 2048) {
    {
#line 170
    __cil_tmp20 = atoi((char const   *)((char *)buf));
#line 170
    tmp = __cil_tmp20;
    }
  } else {
#line 170
    tmp = 0;
  }
#line 170
  pnminfo->xres = (unsigned int )tmp;
#line 171
  if (pnminfo->xres <= 0U) {
    {
#line 172
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 172
      if (logging) {
        {
#line 172
        fprintf(stdout, "pnm filter: invalid xres while loading\n");
        }
      }
#line 172
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 173
    at_exception_fatal(& excep, (gchar *)"pnm filter: premature end of file");
    }
#line 174
    goto cleanup;
  }
  {
#line 177
  pnmscanner_gettoken(scan, (unsigned char *)((char *)buf), (unsigned int )512);
  }
#line 178
  if (scan->eof) {
    {
#line 179
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 179
      if (logging) {
        {
#line 179
        fprintf(stdout, "pnm filter: premature end of file\n");
        }
      }
#line 179
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 180
    at_exception_fatal(& excep, (gchar *)"pnm filter: premature end of file");
    }
#line 181
    goto cleanup;
  }
  {
#line 183
  __cil_tmp22 = __ctype_b_loc();
  }
#line 183
  if ((int )*(*__cil_tmp22 + (int )*((char *)buf)) & 2048) {
    {
#line 183
    __cil_tmp23 = atoi((char const   *)((char *)buf));
#line 183
    tmp___0 = __cil_tmp23;
    }
  } else {
#line 183
    tmp___0 = 0;
  }
#line 183
  pnminfo->yres = (unsigned int )tmp___0;
#line 184
  if (pnminfo->yres <= 0U) {
    {
#line 185
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 185
      if (logging) {
        {
#line 185
        fprintf(stdout, "pnm filter: invalid yres while loading\n");
        }
      }
#line 185
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 186
    at_exception_fatal(& excep, (gchar *)"pnm filter: invalid yres while loading");
    }
#line 187
    goto cleanup;
  }
#line 190
  if (pnminfo->np != 0) {
    {
#line 191
    pnmscanner_gettoken(scan, (unsigned char *)((char *)buf), (unsigned int )512);
    }
#line 192
    if (scan->eof) {
      {
#line 193
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 193
        if (logging) {
          {
#line 193
          fprintf(stdout, "pnm filter: premature end of file\n");
          }
        }
#line 193
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
      {
#line 194
      at_exception_fatal(& excep, (gchar *)"pnm filter: invalid yres while loading");
      }
#line 195
      goto cleanup;
    }
    {
#line 198
    __cil_tmp25 = __ctype_b_loc();
    }
#line 198
    if ((int )*(*__cil_tmp25 + (int )*((char *)buf)) & 2048) {
      {
#line 198
      __cil_tmp26 = atoi((char const   *)((char *)buf));
#line 198
      tmp___1 = __cil_tmp26;
      }
    } else {
#line 198
      tmp___1 = 0;
    }
#line 198
    pnminfo->maxval = tmp___1;
#line 199
    if (pnminfo->maxval <= 0) {
      _L___80: /* CIL Label */ 
      {
#line 201
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 201
        if (logging) {
          {
#line 201
          fprintf(stdout, "pnm filter: invalid maxval while loading\n");
          }
        }
#line 201
        goto while_break___9;
      }
      while_break___9: /* CIL Label */ ;
      }
      {
#line 202
      at_exception_fatal(& excep, (gchar *)"pnm filter: invalid maxval while loading\220");
      }
#line 203
      goto cleanup;
    } else
#line 199
    if (pnminfo->maxval > 255) {
#line 199
      if (! pnminfo->asciibody) {
#line 199
        goto _L___80;
      }
    }
  }
#line 207
  if (pnminfo->np) {
#line 207
    tmp___2 = pnminfo->np;
  } else {
#line 207
    tmp___2 = 1;
  }
  {
#line 207
  __cil_tmp29 = at_bitmap_init((unsigned char *)((void *)0), (unsigned short )pnminfo->xres,
                               (unsigned short )pnminfo->yres, (unsigned int )tmp___2);
#line 207
  bitmap = __cil_tmp29;
#line 208
  (*(pnminfo->loader))(scan, pnminfo, bitmap.bitmap, & excep);
  }
  cleanup: 
  {
#line 212
  pnmscanner_destroy(scan);
  }
  {
#line 215
  free(pnminfo);
#line 218
  fclose(fd);
  }
#line 220
  return (bitmap);
}
}
#line 223 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-pnm.c"
static void pnm_load_ascii(PNMScanner *scan , PNMInfo *info , unsigned char *data ,
                           at_exception_type *excep ) 
{ 
  unsigned char *d ;
  unsigned int x ;
  int i ;
  int b ;
  int start ;
  int end ;
  int scanlines ;
  int np ;
  char buf[512] ;
  int tmp ;
  unsigned short const   **__cil_tmp15 ;
  int __cil_tmp16 ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned short const   **__cil_tmp19 ;
  int __cil_tmp20 ;
  int tmp___2 ;
  int __cil_tmp22 ;
  unsigned int __cil_tmp23 ;
  int __cil_tmp24 ;

  {
#line 232
  if (info->np) {
#line 232
    tmp = info->np;
  } else {
#line 232
    tmp = 1;
  }
  {
#line 232
  np = tmp;
#line 235
  pnmscanner_createbuffer(scan, (unsigned int )4096);
#line 237
  start = 0;
#line 238
  end = (int )info->yres;
#line 239
  scanlines = end - start;
#line 240
  d = data;
#line 242
  i = 0;
  }
  {
#line 242
  while (1) {
    while_continue: /* CIL Label */ ;
#line 242
    if (! (i < scanlines)) {
#line 242
      goto while_break;
    }
#line 243
    x = (unsigned int )0;
    {
#line 243
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 243
      if (! (x < info->xres)) {
#line 243
        goto while_break___0;
      }
#line 244
      b = 0;
      {
#line 244
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 244
        if (! (b < np)) {
#line 244
          goto while_break___1;
        }
#line 246
        if (scan->eof) {
          {
#line 247
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 247
            if (logging) {
              {
#line 247
              fprintf(stdout, "pnm filter: premature end of file\n");
              }
            }
#line 247
            goto while_break___2;
          }
          while_break___2: /* CIL Label */ ;
          }
          {
#line 248
          at_exception_fatal(excep, (gchar *)"pnm filter: premature end of file");
          }
#line 249
          return;
        }
#line 251
        if (info->np) {
          {
#line 252
          pnmscanner_gettoken(scan, (unsigned char *)((char *)buf), (unsigned int )512);
          }
        } else {
          {
#line 254
          pnmscanner_getsmalltoken(scan, (unsigned char *)((char *)buf));
          }
        }
        {
#line 256
        if (info->maxval == 255) {
#line 256
          goto case_255;
        }
#line 259
        if (info->maxval == 1) {
#line 259
          goto case_1;
        }
#line 262
        goto switch_default;
        case_255: /* CIL Label */ 
        {
#line 257
        __cil_tmp15 = __ctype_b_loc();
        }
#line 257
        if ((int )*(*__cil_tmp15 + (int )*((char *)buf)) & 2048) {
          {
#line 257
          __cil_tmp16 = atoi((char const   *)((char *)buf));
#line 257
          tmp___0 = __cil_tmp16;
          }
        } else {
#line 257
          tmp___0 = 0;
        }
#line 257
        *(d + b) = (unsigned char )tmp___0;
#line 258
        goto switch_break;
        case_1: /* CIL Label */ 
#line 260
        if ((int )*((char *)buf) == 48) {
#line 260
          tmp___1 = 255;
        } else {
#line 260
          tmp___1 = 0;
        }
#line 260
        *(d + b) = (unsigned char )tmp___1;
#line 261
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 263
        __cil_tmp19 = __ctype_b_loc();
        }
#line 263
        if ((int )*(*__cil_tmp19 + (int )*((char *)buf)) & 2048) {
          {
#line 263
          __cil_tmp20 = atoi((char const   *)((char *)buf));
#line 263
          tmp___2 = __cil_tmp20;
          }
        } else {
#line 263
          tmp___2 = 0;
        }
#line 263
        *(d + b) = (unsigned char )(255. * ((double )tmp___2 / (double )info->maxval));
        switch_break: /* CIL Label */ ;
        }
#line 244
        b ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 268
      d += np;
#line 243
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 242
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 272 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-pnm.c"
static void pnm_load_raw(PNMScanner *scan , PNMInfo *info , unsigned char *data ,
                         at_exception_type *excep ) 
{ 
  unsigned char *d ;
  unsigned int x ;
  unsigned int i ;
  unsigned int start ;
  unsigned int end ;
  unsigned int scanlines ;
  FILE *fd ;
  unsigned long __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  unsigned int __cil_tmp14 ;

  {
#line 279
  fd = scan->fd;
#line 281
  start = (unsigned int )0;
#line 282
  end = info->yres;
#line 283
  scanlines = end - start;
#line 284
  d = data;
#line 286
  i = (unsigned int )0;
  {
#line 286
  while (1) {
    while_continue: /* CIL Label */ ;
#line 286
    if (! (i < scanlines)) {
#line 286
      goto while_break;
    }
    {
#line 287
    __cil_tmp12 = fread(d, (unsigned long )1, (unsigned long )(info->xres * (unsigned int )info->np),
                        fd);
    }
#line 287
    if ((unsigned long )(info->xres * (unsigned int )info->np) != __cil_tmp12) {
      {
#line 288
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 288
        if (logging) {
          {
#line 288
          fprintf(stdout, "pnm filter: premature end of file\n\006\021\027V");
          }
        }
#line 288
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 289
      at_exception_fatal(excep, (gchar *)"pnm filter: premature end of file\n\006\021\027V");
      }
#line 290
      return;
    }
#line 293
    if (info->maxval != 255) {
#line 294
      x = (unsigned int )0;
      {
#line 294
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 294
        if (! (x < info->xres * (unsigned int )info->np)) {
#line 294
          goto while_break___1;
        }
#line 295
        *(d + x) = (unsigned char )((255. * (double )*(d + x)) / (double )info->maxval);
#line 294
        x ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 298
    d += info->xres * (unsigned int )info->np;
#line 286
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 302 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-pnm.c"
static void pnm_load_rawpbm(PNMScanner *scan , PNMInfo *info , unsigned char *data ,
                            at_exception_type *excep ) 
{ 
  unsigned char *buf ;
  unsigned char curbyte ;
  unsigned char *d ;
  unsigned int x ;
  unsigned int i ;
  unsigned int start ;
  unsigned int end ;
  unsigned int scanlines ;
  FILE *fd ;
  unsigned int rowlen ;
  unsigned int bufpos ;
  double __cil_tmp16 ;
  void *__cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned int __cil_tmp19 ;
  int tmp ;
  unsigned int __cil_tmp21 ;
  unsigned int __cil_tmp22 ;

  {
  {
#line 312
  fd = scan->fd;
#line 313
  __cil_tmp16 = ceil((double )info->xres / 8.);
#line 313
  rowlen = (unsigned int )__cil_tmp16;
#line 314
  __cil_tmp17 = malloc((unsigned long )rowlen * sizeof(unsigned char ));
#line 314
  buf = (unsigned char *)__cil_tmp17;
#line 316
  start = (unsigned int )0;
#line 317
  end = info->yres;
#line 318
  scanlines = end - start;
#line 319
  d = data;
#line 321
  i = (unsigned int )0;
  }
  {
#line 321
  while (1) {
    while_continue: /* CIL Label */ ;
#line 321
    if (! (i < scanlines)) {
#line 321
      goto while_break;
    }
    {
#line 322
    __cil_tmp18 = fread(buf, (unsigned long )1, (unsigned long )rowlen, fd);
    }
#line 322
    if ((unsigned long )rowlen != __cil_tmp18) {
      {
#line 323
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 323
        if (logging) {
          {
#line 323
          fprintf(stdout, "pnm filter: error reading file\n");
          }
        }
#line 323
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 324
      at_exception_fatal(excep, (gchar *)"pnm filter: error reading file");
      }
#line 325
      goto cleanup;
    }
#line 327
    bufpos = (unsigned int )0;
#line 328
    curbyte = *(buf + 0);
#line 330
    x = (unsigned int )0;
    {
#line 330
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 330
      if (! (x < info->xres)) {
#line 330
        goto while_break___1;
      }
#line 331
      if (x % 8U == 0U) {
#line 332
        __cil_tmp19 = bufpos;
#line 332
        bufpos ++;
#line 332
        curbyte = *(buf + __cil_tmp19);
      }
#line 333
      if ((int )curbyte & 128) {
#line 333
        tmp = 0;
      } else {
#line 333
        tmp = 255;
      }
#line 333
      *(d + x) = (unsigned char )tmp;
#line 334
      curbyte <<= 1;
#line 330
      x ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 337
    d += info->xres;
#line 321
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  cleanup: 
  {
#line 340
  free(buf);
  }
  return;
}
}
#line 349 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-pnm.c"
static PNMScanner *pnmscanner_create(FILE *fd ) 
{ 
  PNMScanner *s ;
  void *__cil_tmp3 ;
  int tmp ;
  unsigned long __cil_tmp5 ;

  {
  {
#line 353
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 353
    __cil_tmp3 = malloc(sizeof(PNMScanner ));
#line 353
    s = (gpointer )__cil_tmp3;
    }
#line 353
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 354
  s->fd = fd;
#line 355
  s->inbuf = (char *)0;
#line 356
  __cil_tmp5 = fread(& s->cur, (unsigned long )1, (unsigned long )1, s->fd);
#line 356
  s->eof = ! __cil_tmp5;
  }
#line 357
  return (s);
}
}
#line 363 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-pnm.c"
static void pnmscanner_destroy(PNMScanner *s ) 
{ 


  {
  {
#line 365
  free(s->inbuf);
#line 366
  free(s);
  }
  return;
}
}
#line 372 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-pnm.c"
static void pnmscanner_createbuffer(PNMScanner *s , unsigned int bufsize ) 
{ 
  void *__cil_tmp3 ;
  unsigned long __cil_tmp4 ;

  {
  {
#line 374
  __cil_tmp3 = malloc(sizeof(char ) * (unsigned long )bufsize);
#line 374
  s->inbuf = (char *)__cil_tmp3;
#line 375
  s->inbufsize = (int )bufsize;
#line 376
  s->inbufpos = 0;
#line 377
  __cil_tmp4 = fread(s->inbuf, (unsigned long )1, (unsigned long )bufsize, s->fd);
#line 377
  s->inbufvalidsize = (int )__cil_tmp4;
  }
  return;
}
}
#line 383 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-pnm.c"
static void pnmscanner_gettoken(PNMScanner *s , unsigned char *buf , unsigned int bufsize ) 
{ 
  unsigned int ctr ;
  unsigned short const   **__cil_tmp5 ;
  unsigned int __cil_tmp6 ;

  {
  {
#line 385
  ctr = (unsigned int )0;
#line 387
  pnmscanner_eatwhitespace(s);
  }
  {
#line 388
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 388
    __cil_tmp5 = __ctype_b_loc();
    }
#line 388
    if (! (((! s->eof && ! ((int )*(*__cil_tmp5 + (int )s->cur) & 8192)) && (int )s->cur != 35) && ctr < bufsize)) {
#line 388
      goto while_break;
    }
    {
#line 389
    __cil_tmp6 = ctr;
#line 389
    ctr ++;
#line 389
    *(buf + __cil_tmp6) = (unsigned char )s->cur;
#line 390
    pnmscanner_getchar(s);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 392
  *(buf + ctr) = (unsigned char )'\000';
  return;
}
}
#line 398 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-pnm.c"
static void pnmscanner_getsmalltoken(PNMScanner *s , unsigned char *buf ) 
{ 
  unsigned short const   **__cil_tmp3 ;

  {
  {
#line 400
  pnmscanner_eatwhitespace(s);
#line 401
  __cil_tmp3 = __ctype_b_loc();
  }
#line 401
  if (! s->eof) {
#line 401
    if (! ((int )*(*__cil_tmp3 + (int )s->cur) & 8192)) {
#line 401
      if ((int )s->cur != 35) {
        {
#line 402
        *buf = (unsigned char )s->cur;
#line 403
        pnmscanner_getchar(s);
        }
      }
    }
  }
  return;
}
}
#line 410 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-pnm.c"
static void pnmscanner_getchar(PNMScanner *s ) 
{ 
  int __cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;

  {
#line 412
  if (s->inbuf) {
#line 413
    __cil_tmp2 = s->inbufpos;
#line 413
    (s->inbufpos) ++;
#line 413
    s->cur = *(s->inbuf + __cil_tmp2);
#line 414
    if (s->inbufpos >= s->inbufvalidsize) {
#line 415
      if (s->inbufsize > s->inbufvalidsize) {
#line 416
        s->eof = 1;
      } else {
        {
#line 418
        __cil_tmp3 = fread(s->inbuf, (unsigned long )1, (unsigned long )s->inbufsize,
                           s->fd);
#line 418
        s->inbufvalidsize = (int )__cil_tmp3;
        }
      }
#line 419
      s->inbufpos = 0;
    }
  } else {
    {
#line 422
    __cil_tmp4 = fread(& s->cur, (unsigned long )1, (unsigned long )1, s->fd);
#line 422
    s->eof = ! __cil_tmp4;
    }
  }
  return;
}
}
#line 429 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/input-pnm.c"
static void pnmscanner_eatwhitespace(PNMScanner *s ) 
{ 
  int state ;
  unsigned short const   **__cil_tmp3 ;

  {
#line 431
  state = 0;
  {
#line 433
  while (1) {
    while_continue: /* CIL Label */ ;
#line 433
    if (! (! s->eof && state != -1)) {
#line 433
      goto while_break;
    }
    {
#line 435
    if (state == 0) {
#line 435
      goto case_0;
    }
#line 445
    if (state == 1) {
#line 445
      goto case_1;
    }
#line 434
    goto switch_break;
    case_0: /* CIL Label */ 
#line 436
    if ((int )s->cur == 35) {
      {
#line 437
      state = 1;
#line 438
      pnmscanner_getchar(s);
      }
    } else {
      {
#line 439
      __cil_tmp3 = __ctype_b_loc();
      }
#line 439
      if (! ((int )*(*__cil_tmp3 + (int )s->cur) & 8192)) {
#line 440
        state = - 1;
      } else {
        {
#line 442
        pnmscanner_getchar(s);
        }
      }
    }
#line 443
    goto switch_break;
    case_1: /* CIL Label */ 
#line 446
    if ((int )s->cur == 10) {
#line 447
      state = 0;
    }
    {
#line 448
    pnmscanner_getchar(s);
    }
#line 449
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 808 "/usr/include/glib-2.0/gobject/gobject.h"
__inline static void g_assert_finalize_object___37(GObject *object ) 
{ 
  gpointer weak_pointer ;
  long __cil_tmp3 ;
  long __cil_tmp4 ;

  {
#line 810
  weak_pointer = object;
  {
#line 812
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 812
    __cil_tmp3 = __builtin_expect((long )0, (long )1);
    }
#line 812
    if (__cil_tmp3) {

    } else {
      {
#line 812
      g_assertion_message((char const   *)((gchar *)0), "/usr/include/glib-2.0/gobject/gobject.h",
                          812, (char const   *)"g_assert_finalize_object\312\001@",
                          "\'G_IS_OBJECT (weak_pointer)\' should be TRUE");
      }
    }
#line 812
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 813
  g_object_add_weak_pointer(object, & weak_pointer);
#line 814
  g_object_unref(weak_pointer);
  }
  {
#line 815
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 815
    __cil_tmp4 = __builtin_expect((long )0, (long )1);
    }
#line 815
    if (__cil_tmp4) {

    } else {
      {
#line 815
      g_assertion_message((char const   *)((gchar *)0), "/usr/include/glib-2.0/gobject/gobject.h",
                          815, (char const   *)"g_assert_finalize_object\312\001@\021Z\256\b",
                          "\'weak_pointer\' should be NULLV");
      }
    }
#line 815
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 36 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h"
extern char *optarg ;
#line 50
extern int optind ;
#line 55
extern int opterr ;
#line 59
extern int optopt ;
#line 91
extern  __attribute__((__nothrow__)) int getopt(int ___argc , char * const  *___argv ,
                                                char const   *__shortopts ) ;
#line 66 "/usr/include/x86_64-linux-gnu/bits/getopt_ext.h"
extern  __attribute__((__nothrow__)) int getopt_long(int ___argc , char * const  *___argv ,
                                                     char const   *__shortopts , struct option *__longopts ,
                                                     int *__longind ) ;
#line 70
extern  __attribute__((__nothrow__)) int getopt_long_only(int ___argc , char * const  *___argv ,
                                                          char const   *__shortopts ,
                                                          struct option *__longopts ,
                                                          int *__longind ) ;
#line 7 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/atou.h"
unsigned int atou(gchar *s ) ;
#line 29 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/main.c"
static at_bitmap_reader *input_reader  =    (at_bitmap_reader *)((void *)0);
#line 34
static char *get_basename(char *name ) ;
#line 38 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/main.c"
static char *output_name  =    (char *)"P;\r\021\027V";
#line 41 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/main.c"
static at_spline_writer *output_writer  =    (at_spline_writer *)((void *)0);
#line 44
static gboolean printed_version ;
#line 47 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/main.c"
static gboolean dumping_bitmap  =    0;
#line 50 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/main.c"
static gboolean report_progress  =    0;
#line 53
static void dot_printer(gfloat percentage , gpointer client_data ) ;
#line 55
static char *read_command_line(int argc , char *argv[] , at_fitting_opts_type *fitting_opts ,
                               at_input_opts_type *input_opts , at_output_opts_type *output_opts ) ;
#line 57
static void dump(at_bitmap *bitmap , FILE *fp ) ;
#line 59
static void input_list_formats(FILE *file ) ;
#line 60
static void output_list_formats(FILE *file ) ;
#line 62
static void exception_handler(gchar *msg , at_msg_type type , gpointer data ) ;
#line 66 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/main.c"
int main(int argc , char *argv[] ) 
{ 
  at_fitting_opts_type *fitting_opts ;
  at_input_opts_type *input_opts ;
  at_output_opts_type *output_opts ;
  char *input_name ;
  char *input_rootname ;
  char *dumpfile_name ;
  at_spline_list_array_type *splines ;
  at_bitmap *bitmap ;
  FILE *output_file ;
  FILE *dump_file ;
  at_progress_func progress_reporter ;
  int progress_stat ;
  at_fitting_opts_type *__cil_tmp15 ;
  at_input_opts_type *__cil_tmp16 ;
  at_output_opts_type *__cil_tmp17 ;
  char *__cil_tmp18 ;
  int __cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  gchar *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  at_bitmap_reader *__cil_tmp26 ;
  at_spline_writer *__cil_tmp27 ;
  at_spline_writer *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  int __cil_tmp31 ;
  FILE *__cil_tmp32 ;
  int *__cil_tmp33 ;
  at_bitmap *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  at_spline_list_array_type *__cil_tmp37 ;
  unsigned short __cil_tmp38 ;
  gchar *__cil_tmp39 ;
  gchar *__cil_tmp40 ;
  FILE *__cil_tmp41 ;
  int *__cil_tmp42 ;
  unsigned short __cil_tmp43 ;
  unsigned short __cil_tmp44 ;
  unsigned short __cil_tmp45 ;

  {
  {
#line 72
  dumpfile_name = (char *)((void *)0);
#line 78
  progress_reporter = (at_progress_func )((void *)0);
#line 79
  progress_stat = 0;
#line 81
  autotrace_init();
#line 84
  setlocale(6, "\300\316T\021\027V");
#line 85
  bindtextdomain("autotrace", "/usr/local/share/locale");
#line 86
  textdomain("autotrace");
#line 89
  fitting_opts = at_fitting_opts_new();
#line 90
  input_opts = at_input_opts_new();
#line 91
  output_opts = at_output_opts_new();
#line 93
  input_name = read_command_line(argc, argv, fitting_opts, input_opts, output_opts);
#line 95
  __cil_tmp19 = strcasecmp((char const   *)output_name, (char const   *)input_name);
  }
#line 95
  if (output_name != (void *)0) {
#line 95
    if (input_name != (void *)0) {
#line 95
      if (0 == __cil_tmp19) {
        {
#line 96
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 96
          fputs("fatal: ", stderr);
          }
          {
#line 96
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 96
            if (logging) {
              {
#line 96
              fprintf(stdout, "fatal: ");
              }
            }
#line 96
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
          {
#line 96
          __cil_tmp20 = dcgettext("autotrace", "Input and output file may not be the same\n",
                                  5);
#line 96
          fprintf(stderr, (char const   *)__cil_tmp20);
          }
          {
#line 96
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 96
            if (logging) {
              {
#line 96
              __cil_tmp21 = dcgettext("autotrace", "Input and output file may not be the same\n",
                                      5);
#line 96
              fprintf(stdout, (char const   *)__cil_tmp21);
              }
            }
#line 96
            goto while_break___1;
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 96
          fputs(".\n", stderr);
#line 96
          exit(1);
          }
#line 96
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
  }
  {
#line 98
  __cil_tmp22 = get_basename(input_name);
#line 98
  __cil_tmp23 = remove_suffix(__cil_tmp22);
#line 98
  input_rootname = __cil_tmp23;
  }
#line 98
  if (input_rootname == (void *)0) {
    {
#line 99
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 99
      fputs("fatal: ", stderr);
      }
      {
#line 99
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 99
        if (logging) {
          {
#line 99
          fprintf(stdout, "fatal: ");
          }
        }
#line 99
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 99
      __cil_tmp24 = dcgettext("autotrace", "Not a valid input file name %s", 5);
#line 99
      fprintf(stderr, (char const   *)__cil_tmp24, input_name);
      }
      {
#line 99
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 99
        if (logging) {
          {
#line 99
          __cil_tmp25 = dcgettext("autotrace", "Not a valid input file name %s", 5);
#line 99
          fprintf(stdout, (char const   *)__cil_tmp25, input_name);
          }
        }
#line 99
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 99
      fputs(".\n", stderr);
#line 99
      exit(1);
      }
#line 99
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 109
  if (! input_reader) {
    {
#line 110
    input_reader = at_input_get_handler(input_name);
    }
  }
#line 115
  if (! output_writer) {
    {
#line 116
    output_writer = at_output_get_handler(output_name);
    }
  }
#line 117
  if (! output_writer) {
    {
#line 118
    output_writer = at_output_get_handler_by_suffix("eps");
    }
#line 119
    if (output_writer == (void *)0) {
      {
#line 120
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 120
        fputs("fatal: ", stderr);
        }
        {
#line 120
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 120
          if (logging) {
            {
#line 120
            fprintf(stdout, "fatal: ");
            }
          }
#line 120
          goto while_break___6;
        }
        while_break___6: /* CIL Label */ ;
        }
        {
#line 120
        __cil_tmp29 = dcgettext("autotrace", "Default format %s is not supported",
                                5);
#line 120
        fprintf(stderr, (char const   *)__cil_tmp29, "eps");
        }
        {
#line 120
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 120
          if (logging) {
            {
#line 120
            __cil_tmp30 = dcgettext("autotrace", "Default format %s is not supported",
                                    5);
#line 120
            fprintf(stdout, (char const   *)__cil_tmp30, "eps");
            }
          }
#line 120
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
        {
#line 120
        fputs(".\n", stderr);
#line 120
        exit(1);
        }
#line 120
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
  }
  {
#line 124
  __cil_tmp31 = strcmp((char const   *)output_name, "\220");
  }
#line 124
  if (! __cil_tmp31) {
#line 125
    output_file = stdout;
  } else {
    {
#line 127
    output_file = fopen((char const   *)output_name, "wb");
    }
#line 128
    if (output_file == (void *)0) {
      {
#line 129
      perror((char const   *)output_name);
#line 130
      __cil_tmp33 = __errno_location();
#line 130
      exit(*__cil_tmp33);
      }
    }
  }
#line 135
  if (input_reader != (void *)0) {
    {
#line 136
    bitmap = at_bitmap_read(input_reader, input_name, input_opts, & exception_handler,
                            (void *)0);
#line 138
    at_input_opts_free(input_opts);
    }
  } else {
    {
#line 140
    while (1) {
      while_continue___8: /* CIL Label */ ;
      {
#line 140
      fputs("fatal: ", stderr);
      }
      {
#line 140
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 140
        if (logging) {
          {
#line 140
          fprintf(stdout, "fatal: ");
          }
        }
#line 140
        goto while_break___9;
      }
      while_break___9: /* CIL Label */ ;
      }
      {
#line 140
      __cil_tmp35 = dcgettext("autotrace", "Unsupported input format\251", 5);
#line 140
      fprintf(stderr, (char const   *)__cil_tmp35);
      }
      {
#line 140
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 140
        if (logging) {
          {
#line 140
          __cil_tmp36 = dcgettext("autotrace", "Unsupported input format\251", 5);
#line 140
          fprintf(stdout, (char const   *)__cil_tmp36);
          }
        }
#line 140
        goto while_break___10;
      }
      while_break___10: /* CIL Label */ ;
      }
      {
#line 140
      fputs(".\n", stderr);
#line 140
      exit(1);
      }
#line 140
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
  }
#line 142
  if (report_progress) {
    {
#line 143
    progress_reporter = & dot_printer;
#line 144
    fprintf(stderr, "%-15s", input_name);
    }
  }
  {
#line 147
  splines = at_splines_new_full(bitmap, fitting_opts, & exception_handler, (void *)0,
                                progress_reporter, & progress_stat, (at_testcancel_func )((void *)0),
                                (void *)0);
  }
#line 150
  if (dumping_bitmap) {
    {
#line 151
    __cil_tmp38 = at_bitmap_get_planes(bitmap);
    }
#line 151
    if ((int )__cil_tmp38 == 1) {
      {
#line 152
      dumpfile_name = extend_filename(input_rootname, "dump.pgm\260\"U\021\027V");
      }
    } else {
      {
#line 154
      dumpfile_name = extend_filename(input_rootname, "dump.ppm\220");
      }
    }
    {
#line 155
    dump_file = fopen((char const   *)dumpfile_name, "wb");
    }
#line 156
    if (dump_file == (void *)0) {
      {
#line 157
      perror((char const   *)dumpfile_name);
#line 158
      __cil_tmp42 = __errno_location();
#line 158
      exit(*__cil_tmp42);
      }
    }
    {
#line 160
    __cil_tmp43 = at_bitmap_get_planes(bitmap);
    }
#line 160
    if ((int )__cil_tmp43 == 1) {
      {
#line 161
      fprintf(dump_file, "%s\n", "P5");
      }
    } else {
      {
#line 163
      fprintf(dump_file, "%s\n", "P6");
      }
    }
    {
#line 164
    fprintf(dump_file, "%s\n", "# Created by AutoTrace");
#line 165
    __cil_tmp44 = at_bitmap_get_width(bitmap);
    }
    {
#line 165
    __cil_tmp45 = at_bitmap_get_height(bitmap);
#line 165
    fprintf(dump_file, "%d %d\n", (int )__cil_tmp44, (int )__cil_tmp45);
#line 166
    fprintf(dump_file, "%d\n", 255);
#line 167
    dump(bitmap, dump_file);
#line 168
    fclose(dump_file);
    }
  }
  {
#line 171
  at_splines_write(output_writer, output_file, output_name, output_opts, splines,
                   & exception_handler, (void *)0);
#line 172
  at_output_opts_free(output_opts);
  }
#line 174
  if (output_file != stdout) {
    {
#line 175
    fclose(output_file);
    }
  }
  {
#line 177
  at_splines_free(splines);
#line 178
  at_bitmap_free(bitmap);
#line 179
  at_fitting_opts_free(fitting_opts);
  }
#line 181
  if (report_progress) {
    {
#line 182
    fputs("\n", stderr);
    }
  }
#line 184
  return (0);
}
}
#line 245 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/main.c"
static char *read_command_line(int argc , char *argv[] , at_fitting_opts_type *fitting_opts ,
                               at_input_opts_type *input_opts , at_output_opts_type *output_opts ) 
{ 
  int g ;
  int option_index ;
  struct option long_options[33] ;
  int __cil_tmp9 ;
  int tmp ;
  int __cil_tmp11 ;
  at_color *__cil_tmp12 ;
  at_color *__cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  int __cil_tmp17 ;
  unsigned int __cil_tmp18 ;
  int __cil_tmp19 ;
  double __cil_tmp20 ;
  int __cil_tmp21 ;
  unsigned int __cil_tmp22 ;
  int __cil_tmp23 ;
  double __cil_tmp24 ;
  int __cil_tmp25 ;
  int endian ;
  char *str ;
  int __cil_tmp28 ;
  unsigned int __cil_tmp29 ;
  int __cil_tmp30 ;
  double __cil_tmp31 ;
  int __cil_tmp32 ;
  double __cil_tmp33 ;
  int __cil_tmp34 ;
  unsigned int __cil_tmp35 ;
  int __cil_tmp36 ;
  double __cil_tmp37 ;
  int __cil_tmp38 ;
  unsigned int __cil_tmp39 ;
  int __cil_tmp40 ;
  char *ishortlist ;
  char *oshortlist ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char const   *__cil_tmp47 ;
  int __cil_tmp48 ;
  at_bitmap_reader *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  int __cil_tmp52 ;
  double __cil_tmp53 ;
  int __cil_tmp54 ;
  double __cil_tmp55 ;
  int __cil_tmp56 ;
  char *__cil_tmp57 ;
  int __cil_tmp58 ;
  char *__cil_tmp59 ;
  int __cil_tmp60 ;
  int __cil_tmp61 ;
  at_spline_writer *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  int __cil_tmp65 ;
  int __cil_tmp66 ;
  int __cil_tmp67 ;
  unsigned int __cil_tmp68 ;
  int __cil_tmp69 ;
  char *__cil_tmp70 ;
  char const   *__cil_tmp71 ;
  int __cil_tmp72 ;
  double __cil_tmp73 ;
  char const   *tmp___0 ;

  {
#line 249
  long_options[0].name = "align-threshold";
#line 249
  long_options[0].has_arg = 1;
#line 249
  long_options[0].flag = (int *)0;
#line 249
  long_options[0].val = 0;
#line 249
  long_options[1].name = "background-color\251";
#line 249
  long_options[1].has_arg = 1;
#line 249
  long_options[1].flag = (int *)0;
#line 249
  long_options[1].val = 0;
#line 249
  long_options[2].name = "debug-arch";
#line 249
  long_options[2].has_arg = 0;
#line 249
  long_options[2].flag = (int *)0;
#line 249
  long_options[2].val = 0;
#line 249
  long_options[3].name = "debug-bitmap";
#line 249
  long_options[3].has_arg = 0;
#line 249
  long_options[3].flag = (int *)(& dumping_bitmap);
#line 249
  long_options[3].val = 1;
#line 249
  long_options[4].name = "centerline";
#line 249
  long_options[4].has_arg = 0;
#line 249
  long_options[4].flag = (int *)0;
#line 249
  long_options[4].val = 0;
#line 249
  long_options[5].name = "charcode\251";
#line 249
  long_options[5].has_arg = 1;
#line 249
  long_options[5].flag = (int *)0;
#line 249
  long_options[5].val = 0;
#line 249
  long_options[6].name = "color-count";
#line 249
  long_options[6].has_arg = 1;
#line 249
  long_options[6].flag = (int *)0;
#line 249
  long_options[6].val = 0;
#line 249
  long_options[7].name = "corner-always-threshold";
#line 249
  long_options[7].has_arg = 1;
#line 249
  long_options[7].flag = (int *)0;
#line 249
  long_options[7].val = 0;
#line 249
  long_options[8].name = "corner-surround";
#line 249
  long_options[8].has_arg = 1;
#line 249
  long_options[8].flag = (int *)0;
#line 249
  long_options[8].val = 0;
#line 249
  long_options[9].name = "corner-threshold\251";
#line 249
  long_options[9].has_arg = 1;
#line 249
  long_options[9].flag = (int *)0;
#line 249
  long_options[9].val = 0;
#line 249
  long_options[10].name = "despeckle-level";
#line 249
  long_options[10].has_arg = 1;
#line 249
  long_options[10].flag = (int *)0;
#line 249
  long_options[10].val = 0;
#line 249
  long_options[11].name = "despeckle-tightness";
#line 249
  long_options[11].has_arg = 1;
#line 249
  long_options[11].flag = (int *)0;
#line 249
  long_options[11].val = 0;
#line 249
  long_options[12].name = "dpi";
#line 249
  long_options[12].has_arg = 1;
#line 249
  long_options[12].flag = (int *)0;
#line 249
  long_options[12].val = 0;
#line 249
  long_options[13].name = "error-threshold";
#line 249
  long_options[13].has_arg = 1;
#line 249
  long_options[13].flag = (int *)0;
#line 249
  long_options[13].val = 0;
#line 249
  long_options[14].name = "filter-iterations";
#line 249
  long_options[14].has_arg = 1;
#line 249
  long_options[14].flag = (int *)0;
#line 249
  long_options[14].val = 0;
#line 249
  long_options[15].name = "help";
#line 249
  long_options[15].has_arg = 0;
#line 249
  long_options[15].flag = (int *)0;
#line 249
  long_options[15].val = 0;
#line 249
  long_options[16].name = "input-format";
#line 249
  long_options[16].has_arg = 1;
#line 249
  long_options[16].flag = (int *)0;
#line 249
  long_options[16].val = 0;
#line 249
  long_options[17].name = "line-reversion-threshold\251";
#line 249
  long_options[17].has_arg = 1;
#line 249
  long_options[17].flag = (int *)0;
#line 249
  long_options[17].val = 0;
#line 249
  long_options[18].name = "line-threshold";
#line 249
  long_options[18].has_arg = 1;
#line 249
  long_options[18].flag = (int *)0;
#line 249
  long_options[18].val = 0;
#line 249
  long_options[19].name = "list-output-formats";
#line 249
  long_options[19].has_arg = 0;
#line 249
  long_options[19].flag = (int *)0;
#line 249
  long_options[19].val = 0;
#line 249
  long_options[20].name = "list-input-formats";
#line 249
  long_options[20].has_arg = 0;
#line 249
  long_options[20].flag = (int *)0;
#line 249
  long_options[20].val = 0;
#line 249
  long_options[21].name = "log";
#line 249
  long_options[21].has_arg = 0;
#line 249
  long_options[21].flag = (int *)(& logging);
#line 249
  long_options[21].val = 1;
#line 249
  long_options[22].name = "noise-removal";
#line 249
  long_options[22].has_arg = 1;
#line 249
  long_options[22].flag = (int *)0;
#line 249
  long_options[22].val = 0;
#line 249
  long_options[23].name = "output-file";
#line 249
  long_options[23].has_arg = 1;
#line 249
  long_options[23].flag = (int *)0;
#line 249
  long_options[23].val = 0;
#line 249
  long_options[24].name = "output-format";
#line 249
  long_options[24].has_arg = 1;
#line 249
  long_options[24].flag = (int *)0;
#line 249
  long_options[24].val = 0;
#line 249
  long_options[25].name = "preserve-width";
#line 249
  long_options[25].has_arg = 0;
#line 249
  long_options[25].flag = (int *)0;
#line 249
  long_options[25].val = 0;
#line 249
  long_options[26].name = "range";
#line 249
  long_options[26].has_arg = 1;
#line 249
  long_options[26].flag = (int *)0;
#line 249
  long_options[26].val = 0;
#line 249
  long_options[27].name = "remove-adjacent-corners";
#line 249
  long_options[27].has_arg = 0;
#line 249
  long_options[27].flag = (int *)0;
#line 249
  long_options[27].val = 0;
#line 249
  long_options[28].name = "tangent-surround\251";
#line 249
  long_options[28].has_arg = 1;
#line 249
  long_options[28].flag = (int *)0;
#line 249
  long_options[28].val = 0;
#line 249
  long_options[29].name = "report-progress";
#line 249
  long_options[29].has_arg = 0;
#line 249
  long_options[29].flag = (int *)(& report_progress);
#line 249
  long_options[29].val = 1;
#line 249
  long_options[30].name = "version";
#line 249
  long_options[30].has_arg = 0;
#line 249
  long_options[30].flag = (int *)(& printed_version);
#line 249
  long_options[30].val = 1;
#line 249
  long_options[31].name = "width-weight-factor";
#line 249
  long_options[31].has_arg = 1;
#line 249
  long_options[31].flag = (int *)0;
#line 249
  long_options[31].val = 0;
#line 249
  long_options[32].name = (char const   *)0;
#line 249
  long_options[32].has_arg = 0;
#line 249
  long_options[32].flag = (int *)0;
#line 249
  long_options[32].val = 0;
  {
#line 285
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 287
    g = getopt_long_only(argc, (char * const  *)argv, "\230\001", (struct option *)long_options,
                         & option_index);
    }
#line 289
    if (g == -1) {
#line 290
      goto while_break;
    }
#line 292
    if (g == 63) {
      {
#line 293
      exit(1);
      }
    }
    {
#line 297
    __cil_tmp11 = strcasecmp(long_options[option_index].name, "background-color\220");
    }
#line 297
    if (long_options[option_index].name != (void *)0) {
#line 297
      if ("background-color\251" != (void *)0) {
#line 297
        if (0 == __cil_tmp11) {
          {
#line 298
          fitting_opts->background_color = at_color_parse(optarg, (GError **)((void *)0));
#line 299
          input_opts->background_color = at_color_copy(fitting_opts->background_color);
          }
        } else {
#line 297
          goto _L___130;
        }
      } else {
#line 297
        goto _L___130;
      }
    } else {
      _L___130: /* CIL Label */ 
      _L___131: /* CIL Label */ 
      {
#line 300
      __cil_tmp14 = strcasecmp(long_options[option_index].name, "centerline");
      }
#line 300
      if (long_options[option_index].name != (void *)0) {
#line 300
        if ("centerline" != (void *)0) {
#line 300
          if (0 == __cil_tmp14) {
#line 301
            fitting_opts->centerline = ! 0;
          } else {
#line 300
            goto _L___128;
          }
        } else {
#line 300
          goto _L___128;
        }
      } else {
        _L___128: /* CIL Label */ 
        _L___129: /* CIL Label */ 
        {
#line 303
        __cil_tmp15 = strcasecmp(long_options[option_index].name, "charcode\220");
        }
#line 303
        if (long_options[option_index].name != (void *)0) {
#line 303
          if ("charcode\251" != (void *)0) {
#line 303
            if (0 == __cil_tmp15) {
              {
#line 304
              __cil_tmp16 = strtoul((char const   *)optarg, (char **)0, 0);
#line 304
              fitting_opts->charcode = (unsigned int )__cil_tmp16;
#line 305
              input_opts->charcode = fitting_opts->charcode;
              }
            } else {
#line 303
              goto _L___126;
            }
          } else {
#line 303
            goto _L___126;
          }
        } else {
          _L___126: /* CIL Label */ 
          _L___127: /* CIL Label */ 
          {
#line 308
          __cil_tmp17 = strcasecmp(long_options[option_index].name, "color-count");
          }
#line 308
          if (long_options[option_index].name != (void *)0) {
#line 308
            if ("color-count" != (void *)0) {
#line 308
              if (0 == __cil_tmp17) {
                {
#line 309
                fitting_opts->color_count = atou(optarg);
                }
              } else {
#line 308
                goto _L___124;
              }
            } else {
#line 308
              goto _L___124;
            }
          } else {
            _L___124: /* CIL Label */ 
            _L___125: /* CIL Label */ 
            {
#line 311
            __cil_tmp19 = strcasecmp(long_options[option_index].name, "corner-always-threshold");
            }
#line 311
            if (long_options[option_index].name != (void *)0) {
#line 311
              if ("corner-always-threshold" != (void *)0) {
#line 311
                if (0 == __cil_tmp19) {
                  {
#line 312
                  __cil_tmp20 = atof((char const   *)optarg);
#line 312
                  fitting_opts->corner_always_threshold = (gfloat )__cil_tmp20;
                  }
                } else {
#line 311
                  goto _L___122;
                }
              } else {
#line 311
                goto _L___122;
              }
            } else {
              _L___122: /* CIL Label */ 
              _L___123: /* CIL Label */ 
              {
#line 314
              __cil_tmp21 = strcasecmp(long_options[option_index].name, "corner-surround");
              }
#line 314
              if (long_options[option_index].name != (void *)0) {
#line 314
                if ("corner-surround" != (void *)0) {
#line 314
                  if (0 == __cil_tmp21) {
                    {
#line 315
                    fitting_opts->corner_surround = atou(optarg);
                    }
                  } else {
#line 314
                    goto _L___120;
                  }
                } else {
#line 314
                  goto _L___120;
                }
              } else {
                _L___120: /* CIL Label */ 
                _L___121: /* CIL Label */ 
                {
#line 317
                __cil_tmp23 = strcasecmp(long_options[option_index].name, "corner-threshold\220");
                }
#line 317
                if (long_options[option_index].name != (void *)0) {
#line 317
                  if ("corner-threshold\251" != (void *)0) {
#line 317
                    if (0 == __cil_tmp23) {
                      {
#line 318
                      __cil_tmp24 = atof((char const   *)optarg);
#line 318
                      fitting_opts->corner_threshold = (gfloat )__cil_tmp24;
                      }
                    } else {
#line 317
                      goto _L___118;
                    }
                  } else {
#line 317
                    goto _L___118;
                  }
                } else {
                  _L___118: /* CIL Label */ 
                  _L___119: /* CIL Label */ 
                  {
#line 320
                  __cil_tmp25 = strcasecmp(long_options[option_index].name, "debug-arch");
                  }
#line 320
                  if (long_options[option_index].name != (void *)0) {
#line 320
                    if ("debug-arch" != (void *)0) {
#line 320
                      if (0 == __cil_tmp25) {
#line 321
                        endian = 1;
#line 323
                        if (*((char *)(& endian))) {
#line 324
                          str = "little";
                        } else {
#line 326
                          str = "big";
                        }
                        {
#line 328
                        printf("%lu bit, %s endian\n", sizeof(void *) * 8UL, str);
#line 329
                        exit(0);
                        }
                      } else {
#line 320
                        goto _L___116;
                      }
                    } else {
#line 320
                      goto _L___116;
                    }
                  } else {
                    _L___116: /* CIL Label */ 
                    _L___117: /* CIL Label */ 
                    {
#line 332
                    __cil_tmp28 = strcasecmp(long_options[option_index].name, "despeckle-level");
                    }
#line 332
                    if (long_options[option_index].name != (void *)0) {
#line 332
                      if ("despeckle-level" != (void *)0) {
#line 332
                        if (0 == __cil_tmp28) {
                          {
#line 333
                          fitting_opts->despeckle_level = atou(optarg);
                          }
                        } else {
#line 332
                          goto _L___114;
                        }
                      } else {
#line 332
                        goto _L___114;
                      }
                    } else {
                      _L___114: /* CIL Label */ 
                      _L___115: /* CIL Label */ 
                      {
#line 335
                      __cil_tmp30 = strcasecmp(long_options[option_index].name, "despeckle-tightness");
                      }
#line 335
                      if (long_options[option_index].name != (void *)0) {
#line 335
                        if ("despeckle-tightness" != (void *)0) {
#line 335
                          if (0 == __cil_tmp30) {
                            {
#line 336
                            __cil_tmp31 = atof((char const   *)optarg);
#line 336
                            fitting_opts->despeckle_tightness = (gfloat )__cil_tmp31;
                            }
                          } else {
#line 335
                            goto _L___112;
                          }
                        } else {
#line 335
                          goto _L___112;
                        }
                      } else {
                        _L___112: /* CIL Label */ 
                        _L___113: /* CIL Label */ 
                        {
#line 338
                        __cil_tmp32 = strcasecmp(long_options[option_index].name,
                                                 "noise-removal\002");
                        }
#line 338
                        if (long_options[option_index].name != (void *)0) {
#line 338
                          if ("noise-removal\f" != (void *)0) {
#line 338
                            if (0 == __cil_tmp32) {
                              {
#line 339
                              __cil_tmp33 = atof((char const   *)optarg);
#line 339
                              fitting_opts->noise_removal = (gfloat )__cil_tmp33;
                              }
                            } else {
#line 338
                              goto _L___110;
                            }
                          } else {
#line 338
                            goto _L___110;
                          }
                        } else {
                          _L___110: /* CIL Label */ 
                          _L___111: /* CIL Label */ 
                          {
#line 341
                          __cil_tmp34 = strcasecmp(long_options[option_index].name,
                                                   "dpi");
                          }
#line 341
                          if (long_options[option_index].name != (void *)0) {
#line 341
                            if ("dpi" != (void *)0) {
#line 341
                              if (0 == __cil_tmp34) {
                                {
#line 342
                                __cil_tmp35 = atou(optarg);
#line 342
                                output_opts->dpi = (int )__cil_tmp35;
                                }
                              } else {
#line 341
                                goto _L___108;
                              }
                            } else {
#line 341
                              goto _L___108;
                            }
                          } else {
                            _L___108: /* CIL Label */ 
                            _L___109: /* CIL Label */ 
                            {
#line 344
                            __cil_tmp36 = strcasecmp(long_options[option_index].name,
                                                     "error-threshold");
                            }
#line 344
                            if (long_options[option_index].name != (void *)0) {
#line 344
                              if ("error-threshold" != (void *)0) {
#line 344
                                if (0 == __cil_tmp36) {
                                  {
#line 345
                                  __cil_tmp37 = atof((char const   *)optarg);
#line 345
                                  fitting_opts->error_threshold = (gfloat )__cil_tmp37;
                                  }
                                } else {
#line 344
                                  goto _L___106;
                                }
                              } else {
#line 344
                                goto _L___106;
                              }
                            } else {
                              _L___106: /* CIL Label */ 
                              _L___107: /* CIL Label */ 
                              {
#line 347
                              __cil_tmp38 = strcasecmp(long_options[option_index].name,
                                                       "filter-iterations");
                              }
#line 347
                              if (long_options[option_index].name != (void *)0) {
#line 347
                                if ("filter-iterations" != (void *)0) {
#line 347
                                  if (0 == __cil_tmp38) {
                                    {
#line 348
                                    fitting_opts->filter_iterations = atou(optarg);
                                    }
                                  } else {
#line 347
                                    goto _L___104;
                                  }
                                } else {
#line 347
                                  goto _L___104;
                                }
                              } else {
                                _L___104: /* CIL Label */ 
                                _L___105: /* CIL Label */ 
                                {
#line 350
                                __cil_tmp40 = strcasecmp(long_options[option_index].name,
                                                         "help\002");
                                }
#line 350
                                if (long_options[option_index].name != (void *)0) {
#line 350
                                  if ("helpr" != (void *)0) {
#line 350
                                    if (0 == __cil_tmp40) {
                                      {
#line 352
                                      __cil_tmp43 = dcgettext("autotrace\204\001",
                                                              "Usage: %s [options] <input_file_name>.\n",
                                                              5);
#line 352
                                      fprintf(stderr, (char const   *)__cil_tmp43,
                                              argv[0]);
#line 353
                                      fprintf(stderr, "Options:<input_name> should be a supported image.\n  You can use `--\' or `-\' to start an option.\n  You can use any unambiguous abbreviation for an option name.\n  You can separate option names and values with `=\' or ` \'.\nbackground-color <hexadezimal>: the color of the background that\n  should be ignored, for example FFFFFF;\n  default is no background color.\ncenterline: trace a character\'s centerline, rather than its outline.\ncharcode <unsigned>: code of character to load from GF font file.\ncolor-count <unsigned>: number of colors a color bitmap is reduced to,\n  it does not work on grayscale, allowed are 1..256;\n  default is 0, that means not color reduction is done.\ncorner-always-threshold <angle-in-degrees>: if the angle at a pixel is\n  less than this, it is considered a corner, even if it is within\n  `corner-surround\' pixels of another corner; default is 60.\ncorner-surround <unsigned>: number of pixels on either side of a\n  point to consider when determining if that point is a corner;\n  default is 4.\ncorner-threshold <angle-in-degrees>: if a pixel, its predecessor(s),\n  and its successor(s) meet at an angle smaller than this, it\'s a\n  corner; default is 100.\ndespeckle-level <unsigned>: 0..20; default is no despeckling.\ndespeckle-tightness <real>: 0.0..8.0; default is 2.0.\ndpi <unsigned>: The dots per inch value in the input image, affects scaling\n  of mif output image\n\220");
#line 354
                                      ishortlist = at_input_shortlist();
                                      }
                                      {
#line 354
                                      oshortlist = at_output_shortlist();
#line 354
                                      fprintf(stderr, "error-threshold <real>: subdivide fitted curves that are off by\n  more pixels than this; default is 2.0.\nfilter-iterations <unsigned>: smooth the curve this many times\n  before fitting; default is 4.\ninput-format:  %s. \nhelp: print this message.\nline-reversion-threshold <real>: if a spline is closer to a straight\n  line than this, weighted by the square of the curve length, keep it a\n  straight line even if it is a list with curves; default is .01.\nline-threshold <real>: if the spline is not more than this far away\n  from the straight line defined by its endpoints,\n  then output a straight line; default is 1.\nlist-output-formats: print a list of support output formats to stderr.\nlist-input-formats:  print a list of support input formats to stderr.\nlog: write detailed progress reports to <input_name>.log.\nnoise-removal <real>:: 0.0..1.0; default is 0.99.\noutput-file <filename>: write to <filename>\noutput-format <format>: use format <format> for the output file\n  %s can be used.\npreserve-width: whether to preserve line width prior to thinning.\nremove-adjacent-corners: remove corners that are adjacent.\ntangent-surround <unsigned>: number of points on either side of a\n  point to consider when computing the tangent at that point; default is 3.\nreport-progress: report tracing status in real time.\ndebug-arch: print the type of cpu.\ndebug-bitmap: dump loaded bitmap to <input_name>.bitmap.ppm or pgm.\nversion: print the version number of this program.\nwidth-weight-factor <real>: weight factor for fitting the linewidth.\n",
                                              ishortlist, oshortlist);
#line 355
                                      free(ishortlist);
#line 356
                                      free(oshortlist);
#line 357
                                      __cil_tmp46 = dcgettext("autotrace", "\nYou can get the source code of autotrace from \n%s\n",
                                                              5);
                                      }
                                      {
#line 357
                                      __cil_tmp47 = at_home_site();
#line 357
                                      fprintf(stderr, (char const   *)__cil_tmp46,
                                              __cil_tmp47);
#line 358
                                      exit(0);
                                      }
                                    } else {
#line 350
                                      goto _L___102;
                                    }
                                  } else {
#line 350
                                    goto _L___102;
                                  }
                                } else {
                                  _L___102: /* CIL Label */ 
                                  _L___103: /* CIL Label */ 
                                  {
#line 361
                                  __cil_tmp48 = strcasecmp(long_options[option_index].name,
                                                           "input-formatZ^\003");
                                  }
#line 361
                                  if (long_options[option_index].name != (void *)0) {
#line 361
                                    if ("input-format\001" != (void *)0) {
#line 361
                                      if (0 == __cil_tmp48) {
                                        {
#line 362
                                        input_reader = at_input_get_handler_by_suffix(optarg);
                                        }
#line 363
                                        if (! input_reader) {
                                          {
#line 364
                                          while (1) {
                                            while_continue___0: /* CIL Label */ ;
                                            {
#line 364
                                            fputs("fatal: ", stderr);
                                            }
                                            {
#line 364
                                            while (1) {
                                              while_continue___1: /* CIL Label */ ;
#line 364
                                              if (logging) {
                                                {
#line 364
                                                fprintf(stdout, "fatal: ");
                                                }
                                              }
#line 364
                                              goto while_break___1;
                                            }
                                            while_break___1: /* CIL Label */ ;
                                            }
                                            {
#line 364
                                            __cil_tmp50 = dcgettext("autotrace", "Input format %s is not supported\n\314#\310\262\177",
                                                                    5);
#line 364
                                            fprintf(stderr, (char const   *)__cil_tmp50,
                                                    optarg);
                                            }
                                            {
#line 364
                                            while (1) {
                                              while_continue___2: /* CIL Label */ ;
#line 364
                                              if (logging) {
                                                {
#line 364
                                                __cil_tmp51 = dcgettext("autotrace\376\004",
                                                                        "Input format %s is not supported\n",
                                                                        5);
#line 364
                                                fprintf(stdout, (char const   *)__cil_tmp51,
                                                        optarg);
                                                }
                                              }
#line 364
                                              goto while_break___2;
                                            }
                                            while_break___2: /* CIL Label */ ;
                                            }
                                            {
#line 364
                                            fputs(".\n", stderr);
#line 364
                                            exit(1);
                                            }
#line 364
                                            goto while_break___0;
                                          }
                                          while_break___0: /* CIL Label */ ;
                                          }
                                        }
                                      } else {
#line 361
                                        goto _L___100;
                                      }
                                    } else {
#line 361
                                      goto _L___100;
                                    }
                                  } else {
                                    _L___100: /* CIL Label */ 
                                    _L___101: /* CIL Label */ 
                                    {
#line 367
                                    __cil_tmp52 = strcasecmp(long_options[option_index].name,
                                                             "line-threshold\005");
                                    }
#line 367
                                    if (long_options[option_index].name != (void *)0) {
#line 367
                                      if ("line-threshold" != (void *)0) {
#line 367
                                        if (0 == __cil_tmp52) {
                                          {
#line 368
                                          __cil_tmp53 = atof((char const   *)optarg);
#line 368
                                          fitting_opts->line_threshold = (gfloat )__cil_tmp53;
                                          }
                                        } else {
#line 367
                                          goto _L___98;
                                        }
                                      } else {
#line 367
                                        goto _L___98;
                                      }
                                    } else {
                                      _L___98: /* CIL Label */ 
                                      _L___99: /* CIL Label */ 
                                      {
#line 370
                                      __cil_tmp54 = strcasecmp(long_options[option_index].name,
                                                               "line-reversion-threshold\220");
                                      }
#line 370
                                      if (long_options[option_index].name != (void *)0) {
#line 370
                                        if ("line-reversion-threshold\251" != (void *)0) {
#line 370
                                          if (0 == __cil_tmp54) {
                                            {
#line 371
                                            __cil_tmp55 = atof((char const   *)optarg);
#line 371
                                            fitting_opts->line_reversion_threshold = (gfloat )__cil_tmp55;
                                            }
                                          } else {
#line 370
                                            goto _L___96;
                                          }
                                        } else {
#line 370
                                          goto _L___96;
                                        }
                                      } else {
                                        _L___96: /* CIL Label */ 
                                        _L___97: /* CIL Label */ 
                                        {
#line 373
                                        __cil_tmp56 = strcasecmp(long_options[option_index].name,
                                                                 "list-output-formats");
                                        }
#line 373
                                        if (long_options[option_index].name != (void *)0) {
#line 373
                                          if ("list-output-formats" != (void *)0) {
#line 373
                                            if (0 == __cil_tmp56) {
                                              {
#line 374
                                              __cil_tmp57 = dcgettext("autotrace{\006",
                                                                      "Supported output formats:\n",
                                                                      5);
#line 374
                                              fprintf(stderr, (char const   *)__cil_tmp57);
#line 375
                                              output_list_formats(stderr);
#line 376
                                              exit(0);
                                              }
                                            } else {
#line 373
                                              goto _L___94;
                                            }
                                          } else {
#line 373
                                            goto _L___94;
                                          }
                                        } else {
                                          _L___94: /* CIL Label */ 
                                          _L___95: /* CIL Label */ 
                                          {
#line 377
                                          __cil_tmp58 = strcasecmp(long_options[option_index].name,
                                                                   "list-input-formats");
                                          }
#line 377
                                          if (long_options[option_index].name != (void *)0) {
#line 377
                                            if ("list-input-formats" != (void *)0) {
#line 377
                                              if (0 == __cil_tmp58) {
                                                {
#line 378
                                                __cil_tmp59 = dcgettext("autotrace{\006",
                                                                        "Supported input formats:\n",
                                                                        5);
#line 378
                                                fprintf(stderr, (char const   *)__cil_tmp59);
#line 379
                                                input_list_formats(stderr);
#line 380
                                                exit(0);
                                                }
                                              } else {
#line 377
                                                goto _L___92;
                                              }
                                            } else {
#line 377
                                              goto _L___92;
                                            }
                                          } else {
                                            _L___92: /* CIL Label */ 
                                            _L___93: /* CIL Label */ 
                                            {
#line 383
                                            __cil_tmp60 = strcasecmp(long_options[option_index].name,
                                                                     "output-file");
                                            }
#line 383
                                            if (long_options[option_index].name != (void *)0) {
#line 383
                                              if ("output-file" != (void *)0) {
#line 383
                                                if (0 == __cil_tmp60) {
#line 384
                                                  output_name = optarg;
                                                } else {
#line 383
                                                  goto _L___90;
                                                }
                                              } else {
#line 383
                                                goto _L___90;
                                              }
                                            } else {
                                              _L___90: /* CIL Label */ 
                                              _L___91: /* CIL Label */ 
                                              {
#line 386
                                              __cil_tmp61 = strcasecmp(long_options[option_index].name,
                                                                       "output-format");
                                              }
#line 386
                                              if (long_options[option_index].name != (void *)0) {
#line 386
                                                if ("output-format" != (void *)0) {
#line 386
                                                  if (0 == __cil_tmp61) {
                                                    {
#line 387
                                                    output_writer = at_output_get_handler_by_suffix(optarg);
                                                    }
#line 388
                                                    if (output_writer == (void *)0) {
                                                      {
#line 389
                                                      while (1) {
                                                        while_continue___3: /* CIL Label */ ;
                                                        {
#line 389
                                                        fputs("fatal: ", stderr);
                                                        }
                                                        {
#line 389
                                                        while (1) {
                                                          while_continue___4: /* CIL Label */ ;
#line 389
                                                          if (logging) {
                                                            {
#line 389
                                                            fprintf(stdout, "fatal: ");
                                                            }
                                                          }
#line 389
                                                          goto while_break___4;
                                                        }
                                                        while_break___4: /* CIL Label */ ;
                                                        }
                                                        {
#line 389
                                                        __cil_tmp63 = dcgettext("autotrace\001",
                                                                                "Output format %s is not supported",
                                                                                5);
#line 389
                                                        fprintf(stderr, (char const   *)__cil_tmp63,
                                                                optarg);
                                                        }
                                                        {
#line 389
                                                        while (1) {
                                                          while_continue___5: /* CIL Label */ ;
#line 389
                                                          if (logging) {
                                                            {
#line 389
                                                            __cil_tmp64 = dcgettext("autotrace\256\a",
                                                                                    "Output format %s is not supported\255\b",
                                                                                    5);
#line 389
                                                            fprintf(stdout, (char const   *)__cil_tmp64,
                                                                    optarg);
                                                            }
                                                          }
#line 389
                                                          goto while_break___5;
                                                        }
                                                        while_break___5: /* CIL Label */ ;
                                                        }
                                                        {
#line 389
                                                        fputs(".\n\b", stderr);
#line 389
                                                        exit(1);
                                                        }
#line 389
                                                        goto while_break___3;
                                                      }
                                                      while_break___3: /* CIL Label */ ;
                                                      }
                                                    }
                                                  } else {
#line 386
                                                    goto _L___88;
                                                  }
                                                } else {
#line 386
                                                  goto _L___88;
                                                }
                                              } else {
                                                _L___88: /* CIL Label */ 
                                                _L___89: /* CIL Label */ 
                                                {
#line 390
                                                __cil_tmp65 = strcasecmp(long_options[option_index].name,
                                                                         "preserve_width");
                                                }
#line 390
                                                if (long_options[option_index].name != (void *)0) {
#line 390
                                                  if ("preserve_width" != (void *)0) {
#line 390
                                                    if (0 == __cil_tmp65) {
#line 391
                                                      fitting_opts->preserve_width = ! 0;
                                                    } else {
#line 390
                                                      goto _L___86;
                                                    }
                                                  } else {
#line 390
                                                    goto _L___86;
                                                  }
                                                } else {
                                                  _L___86: /* CIL Label */ 
                                                  _L___87: /* CIL Label */ 
                                                  {
#line 393
                                                  __cil_tmp66 = strcasecmp(long_options[option_index].name,
                                                                           "remove-adjacent-corners");
                                                  }
#line 393
                                                  if (long_options[option_index].name != (void *)0) {
#line 393
                                                    if ("remove-adjacent-corners" != (void *)0) {
#line 393
                                                      if (0 == __cil_tmp66) {
#line 394
                                                        fitting_opts->remove_adjacent_corners = ! 0;
                                                      } else {
#line 393
                                                        goto _L___84;
                                                      }
                                                    } else {
#line 393
                                                      goto _L___84;
                                                    }
                                                  } else {
                                                    _L___84: /* CIL Label */ 
                                                    _L___85: /* CIL Label */ 
                                                    {
#line 396
                                                    __cil_tmp67 = strcasecmp(long_options[option_index].name,
                                                                             "tangent-surround\220");
                                                    }
#line 396
                                                    if (long_options[option_index].name != (void *)0) {
#line 396
                                                      if ("tangent-surround\251" != (void *)0) {
#line 396
                                                        if (0 == __cil_tmp67) {
                                                          {
#line 397
                                                          fitting_opts->tangent_surround = atou(optarg);
                                                          }
                                                        } else {
#line 396
                                                          goto _L___82;
                                                        }
                                                      } else {
#line 396
                                                        goto _L___82;
                                                      }
                                                    } else {
                                                      _L___82: /* CIL Label */ 
                                                      _L___83: /* CIL Label */ 
                                                      {
#line 399
                                                      __cil_tmp69 = strcasecmp(long_options[option_index].name,
                                                                               "version");
                                                      }
#line 399
                                                      if (long_options[option_index].name != (void *)0) {
#line 399
                                                        if ("version" != (void *)0) {
#line 399
                                                          if (0 == __cil_tmp69) {
                                                            {
#line 400
                                                            __cil_tmp70 = dcgettext("autotrace",
                                                                                    "AutoTrace version %s.\n",
                                                                                    5);
                                                            }
                                                            {
#line 400
                                                            __cil_tmp71 = at_version(0);
#line 400
                                                            printf((char const   *)__cil_tmp70,
                                                                   __cil_tmp71);
                                                            }
                                                          } else {
#line 399
                                                            goto _L;
                                                          }
                                                        } else {
#line 399
                                                          goto _L;
                                                        }
                                                      } else {
                                                        _L: /* CIL Label */ 
                                                        _L___81: /* CIL Label */ 
                                                        {
#line 402
                                                        __cil_tmp72 = strcasecmp(long_options[option_index].name,
                                                                                 "width-weight-factor");
                                                        }
#line 402
                                                        if (long_options[option_index].name != (void *)0) {
#line 402
                                                          if ("width-weight-factor" != (void *)0) {
#line 402
                                                            if (0 == __cil_tmp72) {
                                                              {
#line 403
                                                              __cil_tmp73 = atof((char const   *)optarg);
#line 403
                                                              fitting_opts->width_weight_factor = (gfloat )__cil_tmp73;
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 407
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 407
    if (printed_version) {
#line 407
      if (optind == argc) {
        {
#line 407
        exit(0);
        }
      }
    }
#line 407
    if (optind + 1 == argc) {
#line 407
      if ((int )*(argv[optind]) != 0) {
#line 407
        return (argv[optind]);
      } else {
#line 407
        goto _L___132;
      }
    } else {
      _L___132: /* CIL Label */ 
      {
#line 407
      fprintf(stderr, "Usage: %s [options] <image_name>.\n", argv[0]);
      }
#line 407
      if (optind == argc) {
#line 407
        tmp___0 = "Missing <image_name>";
      } else {
#line 407
        tmp___0 = "Too many <image_name>s";
      }
      {
#line 407
      fprintf(stderr, "(%s.)\n", tmp___0);
#line 407
      fputs("For more information, use ``-help\'\'.\n", stderr);
#line 407
      exit(1);
      }
    }
#line 407
    return ((char *)((void *)0));
#line 407
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
  return ((char *)0);
}
}
#line 414 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/main.c"
static char *get_basename(char *name ) 
{ 
  char *base ;
  char *__cil_tmp3 ;
  char *tmp ;

  {
  {
#line 419
  __cil_tmp3 = strrchr((char const   *)name, '/');
#line 419
  base = __cil_tmp3;
  }
#line 421
  if (base) {
#line 421
    tmp = base + 1;
  } else {
#line 421
    tmp = name;
  }
#line 421
  return (tmp);
}
}
#line 425 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/main.c"
static void input_list_formats(FILE *file ) 
{ 
  char const   **list ;
  char const   **__cil_tmp3 ;
  char const   **tmp ;
  char const   *suffix ;
  char const   *descr ;
  char const   **__cil_tmp7 ;
  char const   **__cil_tmp8 ;

  {
  {
#line 427
  __cil_tmp3 = at_input_list_new();
#line 427
  list = __cil_tmp3;
#line 432
  tmp = list;
  }
  {
#line 433
  while (1) {
    while_continue: /* CIL Label */ ;
#line 433
    if (! *list) {
#line 433
      goto while_break;
    }
    {
#line 434
    __cil_tmp7 = list;
#line 434
    list ++;
#line 434
    suffix = *__cil_tmp7;
#line 435
    __cil_tmp8 = list;
#line 435
    list ++;
#line 435
    descr = *__cil_tmp8;
#line 436
    fprintf(file, "%5s %s\n", suffix, descr);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 439
  at_input_list_free(tmp);
  }
  return;
}
}
#line 442 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/main.c"
static void output_list_formats(FILE *file ) 
{ 
  char const   **list ;
  char const   **__cil_tmp3 ;
  char const   **tmp ;
  char const   *suffix ;
  char const   *descr ;
  char const   **__cil_tmp7 ;
  char const   **__cil_tmp8 ;

  {
  {
#line 444
  __cil_tmp3 = at_output_list_new();
#line 444
  list = __cil_tmp3;
#line 449
  tmp = list;
  }
  {
#line 450
  while (1) {
    while_continue: /* CIL Label */ ;
#line 450
    if (! *list) {
#line 450
      goto while_break;
    }
    {
#line 451
    __cil_tmp7 = list;
#line 451
    list ++;
#line 451
    suffix = *__cil_tmp7;
#line 452
    __cil_tmp8 = list;
#line 452
    list ++;
#line 452
    descr = *__cil_tmp8;
#line 453
    fprintf(file, "%10s %s\n\230\001", suffix, descr);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 456
  at_output_list_free(tmp);
  }
  return;
}
}
#line 459 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/main.c"
static void dot_printer(gfloat percentage , gpointer client_data ) 
{ 
  int *current ;
  float unit ;
  int maximum ;
  int __cil_tmp6 ;

  {
#line 461
  current = (int *)client_data;
#line 462
  unit = (float )1. / (float )50;
#line 463
  maximum = (int )(percentage / unit);
  {
#line 465
  while (1) {
    while_continue: /* CIL Label */ ;
#line 465
    if (! (*current < maximum)) {
#line 465
      goto while_break;
    }
    {
#line 466
    fputc('|', stderr);
#line 467
    (*current) ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 471 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/main.c"
static void dump(at_bitmap *bitmap , FILE *fp ) 
{ 
  unsigned short width ;
  unsigned short height ;
  unsigned int np ;
  unsigned short __cil_tmp6 ;
  unsigned short __cil_tmp7 ;
  unsigned short __cil_tmp8 ;

  {
  {
#line 476
  width = at_bitmap_get_width(bitmap);
#line 477
  height = at_bitmap_get_height(bitmap);
#line 478
  __cil_tmp8 = at_bitmap_get_planes(bitmap);
#line 478
  np = (unsigned int )__cil_tmp8;
#line 480
  fwrite(bitmap->bitmap, sizeof(unsigned char ), (unsigned long )((unsigned int )((int )width * (int )height) * np),
         fp);
  }
  return;
}
}
#line 483 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/main.c"
static void exception_handler(gchar *msg , at_msg_type type , gpointer data ) 
{ 
  char *__cil_tmp4 ;

  {
#line 485
  if ((unsigned int )type == 1U) {
    {
#line 486
    fprintf(stderr, "%s\n\021\027V", msg);
#line 487
    exit(1);
    }
  } else
#line 488
  if ((unsigned int )type == 2U) {
    {
#line 489
    fprintf(stderr, "%s\n", msg);
    }
  } else {
    {
#line 491
    __cil_tmp4 = dcgettext("autotrace2W\021\027V", "Wrong type of msg1W\021\027V",
                           5);
#line 491
    exception_handler(__cil_tmp4, (at_msg_type )1, (void *)0);
    }
  }
  return;
}
}
#line 10 "/root/patron-artifact/OSS_donor/CVE-2017-9181/bug/autotrace-20200219.65/src/atou.c"
unsigned int atou(gchar *s ) 
{ 
  int i ;
  int __cil_tmp3 ;

  {
  {
#line 12
  __cil_tmp3 = atoi((char const   *)s);
#line 12
  i = __cil_tmp3;
  }
#line 14
  if (i < 0) {
    {
#line 15
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 15
      fputs("fatal: ", stderr);
      }
      {
#line 15
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 15
        if (logging) {
          {
#line 15
          fprintf(stdout, "fatal: ");
          }
        }
#line 15
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 15
      fprintf(stderr, "I expected a positive number, not %d", i);
      }
      {
#line 15
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 15
        if (logging) {
          {
#line 15
          fprintf(stdout, "I expected a positive number, not %d", i);
          }
        }
#line 15
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 15
      fputs(".\n", stderr);
#line 15
      exit(1);
      }
#line 15
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 17
  return ((unsigned int )i);
}
}
