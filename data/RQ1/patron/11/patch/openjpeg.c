/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stddef.h"
typedef unsigned long size_t;
#line 39 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef short __int16_t;
#line 40 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __uint16_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __int32_t;
#line 42 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uint32_t;
#line 44 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __int64_t;
#line 45 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uint64_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 152 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 196 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int16_t int16_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int32_t int32_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int64_t int64_t;
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
struct __anonstruct_5 {
   unsigned long __val[16] ;
};
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
typedef struct __anonstruct_5 __sigset_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE ;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_marker ;
#line 37
struct _IO_codecvt ;
#line 38
struct _IO_wide_data ;
#line 43 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
typedef void _IO_lock_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[20] ;
};
#line 52 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 83 "/root/patron/new_22/src/lib/openjp2/openjpeg.h"
typedef int OPJ_BOOL;
#line 87 "/root/patron/new_22/src/lib/openjp2/openjpeg.h"
typedef char OPJ_CHAR;
#line 88 "/root/patron/new_22/src/lib/openjp2/openjpeg.h"
typedef float OPJ_FLOAT32;
#line 89 "/root/patron/new_22/src/lib/openjp2/openjpeg.h"
typedef double OPJ_FLOAT64;
#line 90 "/root/patron/new_22/src/lib/openjp2/openjpeg.h"
typedef unsigned char OPJ_BYTE;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint16_t uint16_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint32_t uint32_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint64_t uint64_t;
#line 96 "/root/patron/new_22/src/lib/openjp2/openjpeg.h"
typedef int16_t OPJ_INT16;
#line 97 "/root/patron/new_22/src/lib/openjp2/openjpeg.h"
typedef uint16_t OPJ_UINT16;
#line 98 "/root/patron/new_22/src/lib/openjp2/openjpeg.h"
typedef int32_t OPJ_INT32;
#line 99 "/root/patron/new_22/src/lib/openjp2/openjpeg.h"
typedef uint32_t OPJ_UINT32;
#line 100 "/root/patron/new_22/src/lib/openjp2/openjpeg.h"
typedef int64_t OPJ_INT64;
#line 101 "/root/patron/new_22/src/lib/openjp2/openjpeg.h"
typedef uint64_t OPJ_UINT64;
#line 103 "/root/patron/new_22/src/lib/openjp2/openjpeg.h"
typedef int64_t OPJ_OFF_T;
#line 106 "/root/patron/new_22/src/lib/openjp2/openjpeg.h"
typedef size_t OPJ_SIZE_T;
#line 162
enum RSIZ_CAPABILITIES {
    OPJ_STD_RSIZ = 0,
    OPJ_CINEMA2K = 3,
    OPJ_CINEMA4K = 4,
    OPJ_MCT = 33024
} ;
#line 167 "/root/patron/new_22/src/lib/openjp2/openjpeg.h"
typedef enum RSIZ_CAPABILITIES OPJ_RSIZ_CAPABILITIES;
#line 172
enum CINEMA_MODE {
    OPJ_OFF = 0,
    OPJ_CINEMA2K_24 = 1,
    OPJ_CINEMA2K_48 = 2,
    OPJ_CINEMA4K_24 = 3
} ;
#line 177 "/root/patron/new_22/src/lib/openjp2/openjpeg.h"
typedef enum CINEMA_MODE OPJ_CINEMA_MODE;
#line 182
enum PROG_ORDER {
    OPJ_PROG_UNKNOWN = -1,
    OPJ_LRCP = 0,
    OPJ_RLCP = 1,
    OPJ_RPCL = 2,
    OPJ_PCRL = 3,
    OPJ_CPRL = 4
} ;
#line 189 "/root/patron/new_22/src/lib/openjp2/openjpeg.h"
typedef enum PROG_ORDER OPJ_PROG_ORDER;
#line 194
enum COLOR_SPACE {
    OPJ_CLRSPC_UNKNOWN = -1,
    OPJ_CLRSPC_UNSPECIFIED = 0,
    OPJ_CLRSPC_SRGB = 1,
    OPJ_CLRSPC_GRAY = 2,
    OPJ_CLRSPC_SYCC = 3
} ;
#line 200 "/root/patron/new_22/src/lib/openjp2/openjpeg.h"
typedef enum COLOR_SPACE OPJ_COLOR_SPACE;
#line 205
enum CODEC_FORMAT {
    OPJ_CODEC_UNKNOWN = -1,
    OPJ_CODEC_J2K = 0,
    OPJ_CODEC_JPT = 1,
    OPJ_CODEC_JP2 = 2
} ;
#line 210 "/root/patron/new_22/src/lib/openjp2/openjpeg.h"
typedef enum CODEC_FORMAT OPJ_CODEC_FORMAT;
#line 236 "/root/patron/new_22/src/lib/openjp2/openjpeg.h"
struct opj_poc {
   OPJ_UINT32 resno0 ;
   OPJ_UINT32 compno0 ;
   OPJ_UINT32 layno1 ;
   OPJ_UINT32 resno1 ;
   OPJ_UINT32 compno1 ;
   OPJ_UINT32 layno0 ;
   OPJ_UINT32 precno0 ;
   OPJ_UINT32 precno1 ;
   OPJ_PROG_ORDER prg1 ;
   OPJ_PROG_ORDER prg ;
   OPJ_CHAR progorder[5] ;
   OPJ_UINT32 tile ;
   OPJ_INT32 tx0 ;
   OPJ_INT32 tx1 ;
   OPJ_INT32 ty0 ;
   OPJ_INT32 ty1 ;
   OPJ_UINT32 layS ;
   OPJ_UINT32 resS ;
   OPJ_UINT32 compS ;
   OPJ_UINT32 prcS ;
   OPJ_UINT32 layE ;
   OPJ_UINT32 resE ;
   OPJ_UINT32 compE ;
   OPJ_UINT32 prcE ;
   OPJ_UINT32 txS ;
   OPJ_UINT32 txE ;
   OPJ_UINT32 tyS ;
   OPJ_UINT32 tyE ;
   OPJ_UINT32 dx ;
   OPJ_UINT32 dy ;
   OPJ_UINT32 lay_t ;
   OPJ_UINT32 res_t ;
   OPJ_UINT32 comp_t ;
   OPJ_UINT32 prc_t ;
   OPJ_UINT32 tx0_t ;
   OPJ_UINT32 ty0_t ;
};
#line 259 "/root/patron/new_22/src/lib/openjp2/openjpeg.h"
typedef struct opj_poc opj_poc_t;
#line 264 "/root/patron/new_22/src/lib/openjp2/openjpeg.h"
struct opj_cparameters {
   OPJ_BOOL tile_size_on ;
   int cp_tx0 ;
   int cp_ty0 ;
   int cp_tdx ;
   int cp_tdy ;
   int cp_disto_alloc ;
   int cp_fixed_alloc ;
   int cp_fixed_quality ;
   int *cp_matrice ;
   char *cp_comment ;
   int csty ;
   OPJ_PROG_ORDER prog_order ;
   opj_poc_t POC[32] ;
   OPJ_UINT32 numpocs ;
   int tcp_numlayers ;
   float tcp_rates[100] ;
   float tcp_distoratio[100] ;
   int numresolution ;
   int cblockw_init ;
   int cblockh_init ;
   int mode ;
   int irreversible ;
   int roi_compno ;
   int roi_shift ;
   int res_spec ;
   int prcw_init[33] ;
   int prch_init[33] ;
   char infile[4096] ;
   char outfile[4096] ;
   int index_on ;
   char index[4096] ;
   int image_offset_x0 ;
   int image_offset_y0 ;
   int subsampling_dx ;
   int subsampling_dy ;
   int decod_format ;
   int cod_format ;
   OPJ_BOOL jpwl_epc_on ;
   int jpwl_hprot_MH ;
   int jpwl_hprot_TPH_tileno[16] ;
   int jpwl_hprot_TPH[16] ;
   int jpwl_pprot_tileno[16] ;
   int jpwl_pprot_packno[16] ;
   int jpwl_pprot[16] ;
   int jpwl_sens_size ;
   int jpwl_sens_addr ;
   int jpwl_sens_range ;
   int jpwl_sens_MH ;
   int jpwl_sens_TPH_tileno[16] ;
   int jpwl_sens_TPH[16] ;
   OPJ_CINEMA_MODE cp_cinema ;
   int max_comp_size ;
   OPJ_RSIZ_CAPABILITIES cp_rsiz ;
   char tp_on ;
   char tp_flag ;
   char tcp_mct ;
   OPJ_BOOL jpip_on ;
   void *mct_data ;
};
#line 393 "/root/patron/new_22/src/lib/openjp2/openjpeg.h"
typedef struct opj_cparameters opj_cparameters_t;
#line 400 "/root/patron/new_22/src/lib/openjp2/openjpeg.h"
struct opj_dparameters {
   OPJ_UINT32 cp_reduce ;
   OPJ_UINT32 cp_layer ;
   char infile[4096] ;
   char outfile[4096] ;
   int decod_format ;
   int cod_format ;
   OPJ_UINT32 DA_x0 ;
   OPJ_UINT32 DA_x1 ;
   OPJ_UINT32 DA_y0 ;
   OPJ_UINT32 DA_y1 ;
   OPJ_BOOL m_verbose ;
   OPJ_UINT32 tile_index ;
   OPJ_UINT32 nb_tile_to_decode ;
   OPJ_BOOL jpwl_correct ;
   int jpwl_exp_comps ;
   int jpwl_max_tiles ;
   unsigned int flags ;
};
#line 460 "/root/patron/new_22/src/lib/openjp2/openjpeg.h"
typedef struct opj_dparameters opj_dparameters_t;
#line 466 "/root/patron/new_22/src/lib/openjp2/openjpeg.h"
typedef void *opj_codec_t;
#line 505 "/root/patron/new_22/src/lib/openjp2/openjpeg.h"
typedef void *opj_stream_t;
#line 516 "/root/patron/new_22/src/lib/openjp2/openjpeg.h"
struct opj_image_comp {
   OPJ_UINT32 dx ;
   OPJ_UINT32 dy ;
   OPJ_UINT32 w ;
   OPJ_UINT32 h ;
   OPJ_UINT32 x0 ;
   OPJ_UINT32 y0 ;
   OPJ_UINT32 prec ;
   OPJ_UINT32 bpp ;
   OPJ_UINT32 sgnd ;
   OPJ_UINT32 resno_decoded ;
   OPJ_UINT32 factor ;
   OPJ_INT32 *data ;
};
#line 541 "/root/patron/new_22/src/lib/openjp2/openjpeg.h"
typedef struct opj_image_comp opj_image_comp_t;
#line 546 "/root/patron/new_22/src/lib/openjp2/openjpeg.h"
struct opj_image {
   OPJ_UINT32 x0 ;
   OPJ_UINT32 y0 ;
   OPJ_UINT32 x1 ;
   OPJ_UINT32 y1 ;
   OPJ_UINT32 numcomps ;
   OPJ_COLOR_SPACE color_space ;
   opj_image_comp_t *comps ;
   OPJ_BYTE *icc_profile_buf ;
   OPJ_UINT32 icc_profile_len ;
};
#line 565 "/root/patron/new_22/src/lib/openjp2/openjpeg.h"
typedef struct opj_image opj_image_t;
#line 571 "/root/patron/new_22/src/lib/openjp2/openjpeg.h"
struct opj_image_comptparm {
   OPJ_UINT32 dx ;
   OPJ_UINT32 dy ;
   OPJ_UINT32 w ;
   OPJ_UINT32 h ;
   OPJ_UINT32 x0 ;
   OPJ_UINT32 y0 ;
   OPJ_UINT32 prec ;
   OPJ_UINT32 bpp ;
   OPJ_UINT32 sgnd ;
};
#line 590 "/root/patron/new_22/src/lib/openjp2/openjpeg.h"
typedef struct opj_image_comptparm opj_image_cmptparm_t;
#line 603 "/root/patron/new_22/src/lib/openjp2/openjpeg.h"
struct opj_packet_info {
   OPJ_OFF_T start_pos ;
   OPJ_OFF_T end_ph_pos ;
   OPJ_OFF_T end_pos ;
   double disto ;
};
#line 612 "/root/patron/new_22/src/lib/openjp2/openjpeg.h"
typedef struct opj_packet_info opj_packet_info_t;
#line 619 "/root/patron/new_22/src/lib/openjp2/openjpeg.h"
struct opj_marker_info {
   unsigned short type ;
   OPJ_OFF_T pos ;
   int len ;
};
#line 626 "/root/patron/new_22/src/lib/openjp2/openjpeg.h"
typedef struct opj_marker_info opj_marker_info_t;
#line 632 "/root/patron/new_22/src/lib/openjp2/openjpeg.h"
struct opj_tp_info {
   int tp_start_pos ;
   int tp_end_header ;
   int tp_end_pos ;
   int tp_start_pack ;
   int tp_numpacks ;
};
#line 643 "/root/patron/new_22/src/lib/openjp2/openjpeg.h"
typedef struct opj_tp_info opj_tp_info_t;
#line 648 "/root/patron/new_22/src/lib/openjp2/openjpeg.h"
struct opj_tile_info {
   double *thresh ;
   int tileno ;
   int start_pos ;
   int end_header ;
   int end_pos ;
   int pw[33] ;
   int ph[33] ;
   int pdx[33] ;
   int pdy[33] ;
   opj_packet_info_t *packet ;
   int numpix ;
   double distotile ;
   int marknum ;
   opj_marker_info_t *marker ;
   int maxmarknum ;
   int num_tps ;
   opj_tp_info_t *tp ;
};
#line 683 "/root/patron/new_22/src/lib/openjp2/openjpeg.h"
typedef struct opj_tile_info opj_tile_info_t;
#line 688 "/root/patron/new_22/src/lib/openjp2/openjpeg.h"
struct opj_codestream_info {
   double D_max ;
   int packno ;
   int index_write ;
   int image_w ;
   int image_h ;
   OPJ_PROG_ORDER prog ;
   int tile_x ;
   int tile_y ;
   int tile_Ox ;
   int tile_Oy ;
   int tw ;
   int th ;
   int numcomps ;
   int numlayers ;
   int *numdecompos ;
   int marknum ;
   opj_marker_info_t *marker ;
   int maxmarknum ;
   int main_head_start ;
   int main_head_end ;
   int codestream_size ;
   opj_tile_info_t *tile ;
};
#line 735 "/root/patron/new_22/src/lib/openjp2/openjpeg.h"
typedef struct opj_codestream_info opj_codestream_info_t;
#line 743 "/root/patron/new_22/src/lib/openjp2/openjpeg.h"
struct opj_tccp_info {
   OPJ_UINT32 compno ;
   OPJ_UINT32 csty ;
   OPJ_UINT32 numresolutions ;
   OPJ_UINT32 cblkw ;
   OPJ_UINT32 cblkh ;
   OPJ_UINT32 cblksty ;
   OPJ_UINT32 qmfbid ;
   OPJ_UINT32 qntsty ;
   OPJ_UINT32 stepsizes_mant[97] ;
   OPJ_UINT32 stepsizes_expn[97] ;
   OPJ_UINT32 numgbits ;
   OPJ_INT32 roishift ;
   OPJ_UINT32 prcw[33] ;
   OPJ_UINT32 prch[33] ;
};
#line 774 "/root/patron/new_22/src/lib/openjp2/openjpeg.h"
typedef struct opj_tccp_info opj_tccp_info_t;
#line 779 "/root/patron/new_22/src/lib/openjp2/openjpeg.h"
struct opj_tile_v2_info {
   int tileno ;
   OPJ_UINT32 csty ;
   OPJ_PROG_ORDER prg ;
   OPJ_UINT32 numlayers ;
   OPJ_UINT32 mct ;
   opj_tccp_info_t *tccp_info ;
};
#line 795 "/root/patron/new_22/src/lib/openjp2/openjpeg.h"
typedef struct opj_tile_v2_info opj_tile_info_v2_t;
#line 800 "/root/patron/new_22/src/lib/openjp2/openjpeg.h"
struct opj_codestream_info_v2 {
   OPJ_UINT32 tx0 ;
   OPJ_UINT32 ty0 ;
   OPJ_UINT32 tdx ;
   OPJ_UINT32 tdy ;
   OPJ_UINT32 tw ;
   OPJ_UINT32 th ;
   OPJ_UINT32 nbcomps ;
   opj_tile_info_v2_t m_default_tile_info ;
   opj_tile_info_v2_t *tile_info ;
};
#line 824 "/root/patron/new_22/src/lib/openjp2/openjpeg.h"
typedef struct opj_codestream_info_v2 opj_codestream_info_v2_t;
#line 830 "/root/patron/new_22/src/lib/openjp2/openjpeg.h"
struct opj_tp_index {
   OPJ_OFF_T start_pos ;
   OPJ_OFF_T end_header ;
   OPJ_OFF_T end_pos ;
};
#line 838 "/root/patron/new_22/src/lib/openjp2/openjpeg.h"
typedef struct opj_tp_index opj_tp_index_t;
#line 843 "/root/patron/new_22/src/lib/openjp2/openjpeg.h"
struct opj_tile_index {
   OPJ_UINT32 tileno ;
   OPJ_UINT32 nb_tps ;
   OPJ_UINT32 current_nb_tps ;
   OPJ_UINT32 current_tpsno ;
   opj_tp_index_t *tp_index ;
   OPJ_UINT32 marknum ;
   opj_marker_info_t *marker ;
   OPJ_UINT32 maxmarknum ;
   OPJ_UINT32 nb_packet ;
   opj_packet_info_t *packet_index ;
};
#line 870 "/root/patron/new_22/src/lib/openjp2/openjpeg.h"
typedef struct opj_tile_index opj_tile_index_t;
#line 875 "/root/patron/new_22/src/lib/openjp2/openjpeg.h"
struct opj_codestream_index {
   OPJ_OFF_T main_head_start ;
   OPJ_OFF_T main_head_end ;
   OPJ_UINT64 codestream_size ;
   OPJ_UINT32 marknum ;
   opj_marker_info_t *marker ;
   OPJ_UINT32 maxmarknum ;
   OPJ_UINT32 nb_of_tiles ;
   opj_tile_index_t *tile_index ;
};
#line 898 "/root/patron/new_22/src/lib/openjp2/openjpeg.h"
typedef struct opj_codestream_index opj_codestream_index_t;
#line 47 "/root/patron/new_22/src/lib/openjp2/function_list.h"
typedef void (*opj_procedure)(void);
#line 52 "/root/patron/new_22/src/lib/openjp2/function_list.h"
struct opj_procedure_list {
   OPJ_UINT32 m_nb_procedures ;
   OPJ_UINT32 m_nb_max_procedures ;
   opj_procedure *m_procedures ;
};
#line 67 "/root/patron/new_22/src/lib/openjp2/function_list.h"
typedef struct opj_procedure_list opj_procedure_list_t;
#line 45 "/root/patron/new_22/src/lib/openjp2/event.h"
struct opj_event_mgr {
   void *m_error_data ;
   void *m_warning_data ;
   void *m_info_data ;
   void (*error_handler)(char const   * , void * ) ;
   void (*warning_handler)(char const   * , void * ) ;
   void (*info_handler)(char const   * , void * ) ;
};
#line 59 "/root/patron/new_22/src/lib/openjp2/event.h"
typedef struct opj_event_mgr opj_event_mgr_t;
#line 149 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stddef.h"
typedef long ptrdiff_t;
#line 50 "/root/patron/new_22/src/lib/openjp2/bio.h"
struct opj_bio {
   OPJ_BYTE *start ;
   OPJ_BYTE *end ;
   OPJ_BYTE *bp ;
   OPJ_UINT32 buf ;
   OPJ_UINT32 ct ;
};
#line 61 "/root/patron/new_22/src/lib/openjp2/bio.h"
typedef struct opj_bio opj_bio_t;
#line 68 "/root/patron/new_22/src/lib/openjp2/cio.h"
enum __anonenum__25 {
    opj_signed_sentinel = -1,
    opj_stream_e_output = 1,
    opj_stream_e_input = 2,
    opj_stream_e_end = 4,
    opj_stream_e_error = 8
} ;
#line 76 "/root/patron/new_22/src/lib/openjp2/cio.h"
typedef enum __anonenum__25 opj_stream_flag;
#line 81 "/root/patron/new_22/src/lib/openjp2/cio.h"
struct opj_stream_private {
   void *m_user_data ;
   OPJ_UINT64 m_user_data_length ;
   OPJ_SIZE_T (*m_read_fn)(void * , OPJ_SIZE_T  , void * ) ;
   OPJ_SIZE_T (*m_write_fn)(void * , OPJ_SIZE_T  , void * ) ;
   OPJ_OFF_T (*m_skip_fn)(OPJ_OFF_T  , void * ) ;
   OPJ_BOOL (*m_seek_fn)(OPJ_OFF_T  , void * ) ;
   OPJ_BYTE *m_stored_data ;
   OPJ_BYTE *m_current_data ;
   OPJ_OFF_T (*m_opj_skip)(struct opj_stream_private * , OPJ_OFF_T  , struct opj_event_mgr * ) ;
   OPJ_BOOL (*m_opj_seek)(struct opj_stream_private * , OPJ_OFF_T  , struct opj_event_mgr * ) ;
   OPJ_SIZE_T m_bytes_in_buffer ;
   OPJ_OFF_T m_byte_offset ;
   OPJ_SIZE_T m_buffer_size ;
   opj_stream_flag m_status ;
};
#line 156 "/root/patron/new_22/src/lib/openjp2/cio.h"
typedef struct opj_stream_private opj_stream_private_t;
#line 36 "/root/patron/new_22/src/lib/openjp2/image.h"
struct opj_cp ;
#line 129 "/root/patron/new_22/src/lib/openjp2/j2k.h"
enum MCT_ELEMENT_TYPE {
    MCT_TYPE_INT16 = 0,
    MCT_TYPE_INT32 = 1,
    MCT_TYPE_FLOAT = 2,
    MCT_TYPE_DOUBLE = 3
} ;
#line 135 "/root/patron/new_22/src/lib/openjp2/j2k.h"
typedef enum MCT_ELEMENT_TYPE J2K_MCT_ELEMENT_TYPE;
#line 140
enum MCT_ARRAY_TYPE {
    MCT_TYPE_DEPENDENCY = 0,
    MCT_TYPE_DECORRELATION = 1,
    MCT_TYPE_OFFSET = 2
} ;
#line 145 "/root/patron/new_22/src/lib/openjp2/j2k.h"
typedef enum MCT_ARRAY_TYPE J2K_MCT_ARRAY_TYPE;
#line 152
enum T2_MODE {
    THRESH_CALC = 0,
    FINAL_PASS = 1
} ;
#line 155 "/root/patron/new_22/src/lib/openjp2/j2k.h"
typedef enum T2_MODE J2K_T2_MODE;
#line 160 "/root/patron/new_22/src/lib/openjp2/j2k.h"
struct opj_stepsize {
   OPJ_INT32 expn ;
   OPJ_INT32 mant ;
};
#line 165 "/root/patron/new_22/src/lib/openjp2/j2k.h"
typedef struct opj_stepsize opj_stepsize_t;
#line 170 "/root/patron/new_22/src/lib/openjp2/j2k.h"
struct opj_tccp {
   OPJ_UINT32 csty ;
   OPJ_UINT32 numresolutions ;
   OPJ_UINT32 cblkw ;
   OPJ_UINT32 cblkh ;
   OPJ_UINT32 cblksty ;
   OPJ_UINT32 qmfbid ;
   OPJ_UINT32 qntsty ;
   opj_stepsize_t stepsizes[97] ;
   OPJ_UINT32 numgbits ;
   OPJ_INT32 roishift ;
   OPJ_UINT32 prcw[33] ;
   OPJ_UINT32 prch[33] ;
   OPJ_INT32 m_dc_level_shift ;
};
#line 199 "/root/patron/new_22/src/lib/openjp2/j2k.h"
typedef struct opj_tccp opj_tccp_t;
#line 206 "/root/patron/new_22/src/lib/openjp2/j2k.h"
struct opj_mct_data {
   J2K_MCT_ELEMENT_TYPE m_element_type ;
   J2K_MCT_ARRAY_TYPE m_array_type ;
   OPJ_UINT32 m_index ;
   OPJ_BYTE *m_data ;
   OPJ_UINT32 m_data_size ;
};
#line 214 "/root/patron/new_22/src/lib/openjp2/j2k.h"
typedef struct opj_mct_data opj_mct_data_t;
#line 219 "/root/patron/new_22/src/lib/openjp2/j2k.h"
struct opj_simple_mcc_decorrelation_data {
   OPJ_UINT32 m_index ;
   OPJ_UINT32 m_nb_comps ;
   opj_mct_data_t *m_decorrelation_array ;
   opj_mct_data_t *m_offset_array ;
   OPJ_UINT32 m_is_irreversible ;
};
#line 227 "/root/patron/new_22/src/lib/openjp2/j2k.h"
typedef struct opj_simple_mcc_decorrelation_data opj_simple_mcc_decorrelation_data_t;
#line 234 "/root/patron/new_22/src/lib/openjp2/j2k.h"
struct opj_tcp {
   OPJ_UINT32 csty ;
   OPJ_PROG_ORDER prg ;
   OPJ_UINT32 numlayers ;
   OPJ_UINT32 num_layers_to_decode ;
   OPJ_UINT32 mct ;
   OPJ_FLOAT32 rates[100] ;
   OPJ_UINT32 numpocs ;
   opj_poc_t pocs[32] ;
   OPJ_BYTE *ppt_data ;
   OPJ_BYTE *ppt_buffer ;
   OPJ_UINT32 ppt_data_size ;
   OPJ_UINT32 ppt_len ;
   OPJ_FLOAT32 distoratio[100] ;
   opj_tccp_t *tccps ;
   OPJ_UINT32 m_nb_tile_parts ;
   OPJ_BYTE *m_data ;
   OPJ_UINT32 m_data_size ;
   OPJ_FLOAT64 *mct_norms ;
   OPJ_FLOAT32 *m_mct_decoding_matrix ;
   OPJ_FLOAT32 *m_mct_coding_matrix ;
   opj_mct_data_t *m_mct_records ;
   OPJ_UINT32 m_nb_mct_records ;
   OPJ_UINT32 m_nb_max_mct_records ;
   opj_simple_mcc_decorrelation_data_t *m_mcc_records ;
   OPJ_UINT32 m_nb_mcc_records ;
   OPJ_UINT32 m_nb_max_mcc_records ;
   OPJ_UINT32 ppt ;
   OPJ_UINT32 POC ;
};
#line 294 "/root/patron/new_22/src/lib/openjp2/j2k.h"
typedef struct opj_tcp opj_tcp_t;
#line 299 "/root/patron/new_22/src/lib/openjp2/j2k.h"
struct opj_encoding_param {
   OPJ_CINEMA_MODE m_cinema ;
   OPJ_UINT32 m_max_comp_size ;
   OPJ_INT32 m_tp_pos ;
   OPJ_INT32 *m_matrice ;
   OPJ_BYTE m_tp_flag ;
   OPJ_UINT32 m_disto_alloc ;
   OPJ_UINT32 m_fixed_alloc ;
   OPJ_UINT32 m_fixed_quality ;
   OPJ_UINT32 m_tp_on ;
};
#line 320 "/root/patron/new_22/src/lib/openjp2/j2k.h"
typedef struct opj_encoding_param opj_encoding_param_t;
#line 322 "/root/patron/new_22/src/lib/openjp2/j2k.h"
struct opj_decoding_param {
   OPJ_UINT32 m_reduce ;
   OPJ_UINT32 m_layer ;
};
#line 329 "/root/patron/new_22/src/lib/openjp2/j2k.h"
typedef struct opj_decoding_param opj_decoding_param_t;
#line 379 "/root/patron/new_22/src/lib/openjp2/j2k.h"
union __anonunion_26 {
   opj_decoding_param_t m_dec ;
   opj_encoding_param_t m_enc ;
};
#line 335 "/root/patron/new_22/src/lib/openjp2/j2k.h"
struct opj_cp {
   OPJ_RSIZ_CAPABILITIES rsiz ;
   OPJ_UINT32 tx0 ;
   OPJ_UINT32 ty0 ;
   OPJ_UINT32 tdx ;
   OPJ_UINT32 tdy ;
   OPJ_CHAR *comment ;
   OPJ_UINT32 tw ;
   OPJ_UINT32 th ;
   OPJ_BYTE *ppm_data ;
   OPJ_UINT32 ppm_len ;
   OPJ_UINT32 ppm_data_read ;
   OPJ_BYTE *ppm_data_current ;
   OPJ_BYTE *ppm_buffer ;
   OPJ_BYTE *ppm_data_first ;
   OPJ_UINT32 ppm_data_size ;
   OPJ_INT32 ppm_store ;
   OPJ_INT32 ppm_previous ;
   opj_tcp_t *tcps ;
   union __anonunion_26 m_specific_param ;
   OPJ_UINT32 ppm ;
   OPJ_UINT32 m_is_decoder ;
};
#line 437 "/root/patron/new_22/src/lib/openjp2/j2k.h"
typedef struct opj_cp opj_cp_t;
#line 440 "/root/patron/new_22/src/lib/openjp2/j2k.h"
struct opj_j2k_dec {
   OPJ_UINT32 m_state ;
   opj_tcp_t *m_default_tcp ;
   OPJ_BYTE *m_header_data ;
   OPJ_UINT32 m_header_data_size ;
   OPJ_UINT32 m_sot_length ;
   OPJ_UINT32 m_start_tile_x ;
   OPJ_UINT32 m_start_tile_y ;
   OPJ_UINT32 m_end_tile_x ;
   OPJ_UINT32 m_end_tile_y ;
   OPJ_UINT32 m_DA_x0 ;
   OPJ_UINT32 m_DA_y0 ;
   OPJ_UINT32 m_DA_x1 ;
   OPJ_UINT32 m_DA_y1 ;
   OPJ_INT32 m_tile_ind_to_dec ;
   OPJ_OFF_T m_last_sot_read_pos ;
   OPJ_BOOL m_last_tile_part ;
   OPJ_UINT32 m_can_decode ;
   OPJ_UINT32 m_discard_tiles ;
   OPJ_UINT32 m_skip_data ;
};
#line 481 "/root/patron/new_22/src/lib/openjp2/j2k.h"
typedef struct opj_j2k_dec opj_j2k_dec_t;
#line 483 "/root/patron/new_22/src/lib/openjp2/j2k.h"
struct opj_j2k_enc {
   OPJ_UINT32 m_current_poc_tile_part_number ;
   OPJ_UINT32 m_current_tile_part_number ;
   OPJ_OFF_T m_tlm_start ;
   OPJ_BYTE *m_tlm_sot_offsets_buffer ;
   OPJ_BYTE *m_tlm_sot_offsets_current ;
   OPJ_UINT32 m_total_tile_parts ;
   OPJ_BYTE *m_encoded_tile_data ;
   OPJ_UINT32 m_encoded_tile_size ;
   OPJ_BYTE *m_header_tile_data ;
   OPJ_UINT32 m_header_tile_data_size ;
};
#line 522 "/root/patron/new_22/src/lib/openjp2/j2k.h"
typedef struct opj_j2k_enc opj_j2k_enc_t;
#line 526
struct opj_tcd ;
#line 536 "/root/patron/new_22/src/lib/openjp2/j2k.h"
union __anonunion_27 {
   opj_j2k_dec_t m_decoder ;
   opj_j2k_enc_t m_encoder ;
};
#line 530 "/root/patron/new_22/src/lib/openjp2/j2k.h"
struct opj_j2k {
   OPJ_BOOL m_is_decoder ;
   union __anonunion_27 m_specific_param ;
   opj_image_t *m_private_image ;
   opj_image_t *m_output_image ;
   opj_cp_t m_cp ;
   opj_procedure_list_t *m_procedure_list ;
   opj_procedure_list_t *m_validation_list ;
   opj_codestream_index_t *cstr_index ;
   OPJ_UINT32 m_current_tile_number ;
   struct opj_tcd *m_tcd ;
};
#line 568 "/root/patron/new_22/src/lib/openjp2/j2k.h"
typedef struct opj_j2k opj_j2k_t;
#line 90 "/root/patron/new_22/src/lib/openjp2/jp2.h"
struct opj_jp2_cdef_info {
   OPJ_UINT16 cn ;
   OPJ_UINT16 typ ;
   OPJ_UINT16 asoc ;
};
#line 93 "/root/patron/new_22/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_cdef_info opj_jp2_cdef_info_t;
#line 98 "/root/patron/new_22/src/lib/openjp2/jp2.h"
struct opj_jp2_cdef {
   opj_jp2_cdef_info_t *info ;
   OPJ_UINT16 n ;
};
#line 102 "/root/patron/new_22/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_cdef opj_jp2_cdef_t;
#line 107 "/root/patron/new_22/src/lib/openjp2/jp2.h"
struct opj_jp2_cmap_comp {
   OPJ_UINT16 cmp ;
   OPJ_BYTE mtyp ;
   OPJ_BYTE pcol ;
};
#line 111 "/root/patron/new_22/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_cmap_comp opj_jp2_cmap_comp_t;
#line 116 "/root/patron/new_22/src/lib/openjp2/jp2.h"
struct opj_jp2_pclr {
   OPJ_UINT32 *entries ;
   OPJ_BYTE *channel_sign ;
   OPJ_BYTE *channel_size ;
   opj_jp2_cmap_comp_t *cmap ;
   OPJ_UINT16 nr_entries ;
   OPJ_BYTE nr_channels ;
};
#line 124 "/root/patron/new_22/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_pclr opj_jp2_pclr_t;
#line 129 "/root/patron/new_22/src/lib/openjp2/jp2.h"
struct opj_jp2_color {
   OPJ_BYTE *icc_profile_buf ;
   OPJ_UINT32 icc_profile_len ;
   opj_jp2_cdef_t *jp2_cdef ;
   opj_jp2_pclr_t *jp2_pclr ;
   OPJ_BYTE jp2_has_colr ;
};
#line 137 "/root/patron/new_22/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_color opj_jp2_color_t;
#line 142 "/root/patron/new_22/src/lib/openjp2/jp2.h"
struct opj_jp2_comps {
   OPJ_UINT32 depth ;
   OPJ_UINT32 sgnd ;
   OPJ_UINT32 bpcc ;
};
#line 146 "/root/patron/new_22/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_comps opj_jp2_comps_t;
#line 151 "/root/patron/new_22/src/lib/openjp2/jp2.h"
struct opj_jp2 {
   opj_j2k_t *j2k ;
   struct opj_procedure_list *m_validation_list ;
   struct opj_procedure_list *m_procedure_list ;
   OPJ_UINT32 w ;
   OPJ_UINT32 h ;
   OPJ_UINT32 numcomps ;
   OPJ_UINT32 bpc ;
   OPJ_UINT32 C ;
   OPJ_UINT32 UnkC ;
   OPJ_UINT32 IPR ;
   OPJ_UINT32 meth ;
   OPJ_UINT32 approx ;
   OPJ_UINT32 enumcs ;
   OPJ_UINT32 precedence ;
   OPJ_UINT32 brand ;
   OPJ_UINT32 minversion ;
   OPJ_UINT32 numcl ;
   OPJ_UINT32 *cl ;
   opj_jp2_comps_t *comps ;
   OPJ_OFF_T j2k_codestream_offset ;
   OPJ_OFF_T jpip_iptr_offset ;
   OPJ_BOOL jpip_on ;
   OPJ_UINT32 jp2_state ;
   OPJ_UINT32 jp2_img_state ;
   opj_jp2_color_t color ;
   OPJ_BOOL ignore_pclr_cmap_cdef ;
};
#line 194 "/root/patron/new_22/src/lib/openjp2/jp2.h"
typedef struct opj_jp2 opj_jp2_t;
#line 199 "/root/patron/new_22/src/lib/openjp2/jp2.h"
struct opj_jp2_box {
   OPJ_UINT32 length ;
   OPJ_UINT32 type ;
   OPJ_INT32 init_pos ;
};
#line 203 "/root/patron/new_22/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_box opj_jp2_box_t;
#line 205 "/root/patron/new_22/src/lib/openjp2/jp2.h"
struct opj_jp2_header_handler {
   OPJ_UINT32 id ;
   OPJ_BOOL (*handler)(opj_jp2_t * , OPJ_BYTE * , OPJ_UINT32  , opj_event_mgr_t * ) ;
};
#line 215 "/root/patron/new_22/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_header_handler opj_jp2_header_handler_t;
#line 218 "/root/patron/new_22/src/lib/openjp2/jp2.h"
struct opj_jp2_img_header_writer_handler {
   OPJ_BYTE *(*handler)(opj_jp2_t * , OPJ_UINT32 * ) ;
   OPJ_BYTE *m_data ;
   OPJ_UINT32 m_size ;
};
#line 227 "/root/patron/new_22/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_img_header_writer_handler opj_jp2_img_header_writer_handler_t;
#line 49 "/root/patron/new_22/src/lib/openjp2/mqc.h"
struct opj_mqc_state {
   OPJ_UINT32 qeval ;
   OPJ_UINT32 mps ;
   struct opj_mqc_state *nmps ;
   struct opj_mqc_state *nlps ;
};
#line 58 "/root/patron/new_22/src/lib/openjp2/mqc.h"
typedef struct opj_mqc_state opj_mqc_state_t;
#line 65 "/root/patron/new_22/src/lib/openjp2/mqc.h"
struct opj_mqc {
   OPJ_UINT32 c ;
   OPJ_UINT32 a ;
   OPJ_UINT32 ct ;
   OPJ_BYTE *bp ;
   OPJ_BYTE *start ;
   OPJ_BYTE *end ;
   opj_mqc_state_t *ctxs[19] ;
   opj_mqc_state_t **curctx ;
};
#line 77 "/root/patron/new_22/src/lib/openjp2/mqc.h"
typedef struct opj_mqc opj_mqc_t;
#line 46 "/root/patron/new_22/src/lib/openjp2/raw.h"
struct opj_raw {
   OPJ_BYTE c ;
   OPJ_UINT32 ct ;
   OPJ_UINT32 lenmax ;
   OPJ_UINT32 len ;
   OPJ_BYTE *bp ;
   OPJ_BYTE *start ;
   OPJ_BYTE *end ;
};
#line 61 "/root/patron/new_22/src/lib/openjp2/raw.h"
typedef struct opj_raw opj_raw_t;
#line 49 "/root/patron/new_22/src/lib/openjp2/pi.h"
struct opj_pi_resolution {
   OPJ_UINT32 pdx ;
   OPJ_UINT32 pdy ;
   OPJ_UINT32 pw ;
   OPJ_UINT32 ph ;
};
#line 52 "/root/patron/new_22/src/lib/openjp2/pi.h"
typedef struct opj_pi_resolution opj_pi_resolution_t;
#line 57 "/root/patron/new_22/src/lib/openjp2/pi.h"
struct opj_pi_comp {
   OPJ_UINT32 dx ;
   OPJ_UINT32 dy ;
   OPJ_UINT32 numresolutions ;
   opj_pi_resolution_t *resolutions ;
};
#line 62 "/root/patron/new_22/src/lib/openjp2/pi.h"
typedef struct opj_pi_comp opj_pi_comp_t;
#line 67 "/root/patron/new_22/src/lib/openjp2/pi.h"
struct opj_pi_iterator {
   OPJ_BYTE tp_on ;
   OPJ_INT16 *include ;
   OPJ_UINT32 step_l ;
   OPJ_UINT32 step_r ;
   OPJ_UINT32 step_c ;
   OPJ_UINT32 step_p ;
   OPJ_UINT32 compno ;
   OPJ_UINT32 resno ;
   OPJ_UINT32 precno ;
   OPJ_UINT32 layno ;
   OPJ_BOOL first ;
   opj_poc_t poc ;
   OPJ_UINT32 numcomps ;
   opj_pi_comp_t *comps ;
   OPJ_INT32 tx0 ;
   OPJ_INT32 ty0 ;
   OPJ_INT32 tx1 ;
   OPJ_INT32 ty1 ;
   OPJ_INT32 x ;
   OPJ_INT32 y ;
   OPJ_UINT32 dx ;
   OPJ_UINT32 dy ;
};
#line 102 "/root/patron/new_22/src/lib/openjp2/pi.h"
typedef struct opj_pi_iterator opj_pi_iterator_t;
#line 51 "/root/patron/new_22/src/lib/openjp2/tgt.h"
struct opj_tgt_node {
   struct opj_tgt_node *parent ;
   OPJ_INT32 value ;
   OPJ_INT32 low ;
   OPJ_UINT32 known ;
};
#line 56 "/root/patron/new_22/src/lib/openjp2/tgt.h"
typedef struct opj_tgt_node opj_tgt_node_t;
#line 61 "/root/patron/new_22/src/lib/openjp2/tgt.h"
struct opj_tgt_tree {
   OPJ_UINT32 numleafsh ;
   OPJ_UINT32 numleafsv ;
   OPJ_UINT32 numnodes ;
   opj_tgt_node_t *nodes ;
   OPJ_UINT32 nodes_size ;
};
#line 68 "/root/patron/new_22/src/lib/openjp2/tgt.h"
typedef struct opj_tgt_tree opj_tgt_tree_t;
#line 49 "/root/patron/new_22/src/lib/openjp2/tcd.h"
struct opj_tcd_seg {
   OPJ_BYTE **data ;
   OPJ_UINT32 dataindex ;
   OPJ_UINT32 numpasses ;
   OPJ_UINT32 real_num_passes ;
   OPJ_UINT32 len ;
   OPJ_UINT32 maxpasses ;
   OPJ_UINT32 numnewpasses ;
   OPJ_UINT32 newlen ;
};
#line 58 "/root/patron/new_22/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_seg opj_tcd_seg_t;
#line 63 "/root/patron/new_22/src/lib/openjp2/tcd.h"
struct opj_tcd_pass {
   OPJ_UINT32 rate ;
   OPJ_FLOAT64 distortiondec ;
   OPJ_UINT32 len ;
   OPJ_UINT32 term ;
};
#line 68 "/root/patron/new_22/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_pass opj_tcd_pass_t;
#line 73 "/root/patron/new_22/src/lib/openjp2/tcd.h"
struct opj_tcd_layer {
   OPJ_UINT32 numpasses ;
   OPJ_UINT32 len ;
   OPJ_FLOAT64 disto ;
   OPJ_BYTE *data ;
};
#line 78 "/root/patron/new_22/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_layer opj_tcd_layer_t;
#line 83 "/root/patron/new_22/src/lib/openjp2/tcd.h"
struct opj_tcd_cblk_enc {
   OPJ_BYTE *data ;
   opj_tcd_layer_t *layers ;
   opj_tcd_pass_t *passes ;
   OPJ_INT32 x0 ;
   OPJ_INT32 y0 ;
   OPJ_INT32 x1 ;
   OPJ_INT32 y1 ;
   OPJ_UINT32 numbps ;
   OPJ_UINT32 numlenbits ;
   OPJ_UINT32 numpasses ;
   OPJ_UINT32 numpassesinlayers ;
   OPJ_UINT32 totalpasses ;
};
#line 93 "/root/patron/new_22/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_cblk_enc opj_tcd_cblk_enc_t;
#line 96 "/root/patron/new_22/src/lib/openjp2/tcd.h"
struct opj_tcd_cblk_dec {
   OPJ_BYTE *data ;
   opj_tcd_seg_t *segs ;
   OPJ_INT32 x0 ;
   OPJ_INT32 y0 ;
   OPJ_INT32 x1 ;
   OPJ_INT32 y1 ;
   OPJ_UINT32 numbps ;
   OPJ_UINT32 numlenbits ;
   OPJ_UINT32 data_max_size ;
   OPJ_UINT32 data_current_size ;
   OPJ_UINT32 numnewpasses ;
   OPJ_UINT32 numsegs ;
   OPJ_UINT32 real_num_segs ;
   OPJ_UINT32 m_current_max_segs ;
};
#line 108 "/root/patron/new_22/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_cblk_dec opj_tcd_cblk_dec_t;
#line 116 "/root/patron/new_22/src/lib/openjp2/tcd.h"
union __anonunion_30 {
   opj_tcd_cblk_enc_t *enc ;
   opj_tcd_cblk_dec_t *dec ;
};
#line 113 "/root/patron/new_22/src/lib/openjp2/tcd.h"
struct opj_tcd_precinct {
   OPJ_INT32 x0 ;
   OPJ_INT32 y0 ;
   OPJ_INT32 x1 ;
   OPJ_INT32 y1 ;
   OPJ_UINT32 cw ;
   OPJ_UINT32 ch ;
   union __anonunion_30 cblks ;
   OPJ_UINT32 block_size ;
   opj_tgt_tree_t *incltree ;
   opj_tgt_tree_t *imsbtree ;
};
#line 123 "/root/patron/new_22/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_precinct opj_tcd_precinct_t;
#line 128 "/root/patron/new_22/src/lib/openjp2/tcd.h"
struct opj_tcd_band {
   OPJ_INT32 x0 ;
   OPJ_INT32 y0 ;
   OPJ_INT32 x1 ;
   OPJ_INT32 y1 ;
   OPJ_UINT32 bandno ;
   opj_tcd_precinct_t *precincts ;
   OPJ_UINT32 precincts_data_size ;
   OPJ_INT32 numbps ;
   OPJ_FLOAT32 stepsize ;
};
#line 135 "/root/patron/new_22/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_band opj_tcd_band_t;
#line 140 "/root/patron/new_22/src/lib/openjp2/tcd.h"
struct opj_tcd_resolution {
   OPJ_INT32 x0 ;
   OPJ_INT32 y0 ;
   OPJ_INT32 x1 ;
   OPJ_INT32 y1 ;
   OPJ_UINT32 pw ;
   OPJ_UINT32 ph ;
   OPJ_UINT32 numbands ;
   opj_tcd_band_t bands[3] ;
};
#line 145 "/root/patron/new_22/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_resolution opj_tcd_resolution_t;
#line 150 "/root/patron/new_22/src/lib/openjp2/tcd.h"
struct opj_tcd_tilecomp {
   OPJ_INT32 x0 ;
   OPJ_INT32 y0 ;
   OPJ_INT32 x1 ;
   OPJ_INT32 y1 ;
   OPJ_UINT32 numresolutions ;
   OPJ_UINT32 minimum_num_resolutions ;
   opj_tcd_resolution_t *resolutions ;
   OPJ_UINT32 resolutions_size ;
   OPJ_INT32 *data ;
   OPJ_UINT32 data_size ;
   OPJ_INT32 numpix ;
};
#line 160 "/root/patron/new_22/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_tilecomp opj_tcd_tilecomp_t;
#line 166 "/root/patron/new_22/src/lib/openjp2/tcd.h"
struct opj_tcd_tile {
   OPJ_INT32 x0 ;
   OPJ_INT32 y0 ;
   OPJ_INT32 x1 ;
   OPJ_INT32 y1 ;
   OPJ_UINT32 numcomps ;
   opj_tcd_tilecomp_t *comps ;
   OPJ_INT32 numpix ;
   OPJ_FLOAT64 distotile ;
   OPJ_FLOAT64 distolayer[100] ;
   OPJ_UINT32 packno ;
};
#line 174 "/root/patron/new_22/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_tile opj_tcd_tile_t;
#line 179 "/root/patron/new_22/src/lib/openjp2/tcd.h"
struct opj_tcd_image {
   opj_tcd_tile_t *tiles ;
};
#line 183 "/root/patron/new_22/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_image opj_tcd_image_t;
#line 189 "/root/patron/new_22/src/lib/openjp2/tcd.h"
struct opj_tcd {
   OPJ_INT32 tp_pos ;
   OPJ_UINT32 tp_num ;
   OPJ_UINT32 cur_tp_num ;
   OPJ_UINT32 cur_totnum_tp ;
   OPJ_UINT32 cur_pino ;
   opj_tcd_image_t *tcd_image ;
   opj_image_t *image ;
   opj_cp_t *cp ;
   opj_tcp_t *tcp ;
   OPJ_UINT32 tcd_tileno ;
   OPJ_UINT32 m_is_decoder ;
};
#line 213 "/root/patron/new_22/src/lib/openjp2/tcd.h"
typedef struct opj_tcd opj_tcd_t;
#line 88 "/root/patron/new_22/src/lib/openjp2/t1.h"
typedef OPJ_INT16 opj_flag_t;
#line 93 "/root/patron/new_22/src/lib/openjp2/t1.h"
struct opj_t1 {
   opj_mqc_t *mqc ;
   opj_raw_t *raw ;
   OPJ_INT32 *data ;
   opj_flag_t *flags ;
   OPJ_UINT32 w ;
   OPJ_UINT32 h ;
   OPJ_UINT32 datasize ;
   OPJ_UINT32 flagssize ;
   OPJ_UINT32 flags_stride ;
};
#line 107 "/root/patron/new_22/src/lib/openjp2/t1.h"
typedef struct opj_t1 opj_t1_t;
#line 47 "/root/patron/new_22/src/lib/openjp2/t2.h"
struct opj_t2 {
   opj_image_t *image ;
   opj_cp_t *cp ;
};
#line 53 "/root/patron/new_22/src/lib/openjp2/t2.h"
typedef struct opj_t2 opj_t2_t;
#line 40 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_34 {
   long ru_maxrss ;
   __syscall_slong_t __ru_maxrss_word ;
};
#line 47 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_35 {
   long ru_ixrss ;
   __syscall_slong_t __ru_ixrss_word ;
};
#line 53 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_36 {
   long ru_idrss ;
   __syscall_slong_t __ru_idrss_word ;
};
#line 59 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_37 {
   long ru_isrss ;
   __syscall_slong_t __ru_isrss_word ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_38 {
   long ru_minflt ;
   __syscall_slong_t __ru_minflt_word ;
};
#line 72 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_39 {
   long ru_majflt ;
   __syscall_slong_t __ru_majflt_word ;
};
#line 78 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_40 {
   long ru_nswap ;
   __syscall_slong_t __ru_nswap_word ;
};
#line 85 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_41 {
   long ru_inblock ;
   __syscall_slong_t __ru_inblock_word ;
};
#line 91 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_42 {
   long ru_oublock ;
   __syscall_slong_t __ru_oublock_word ;
};
#line 97 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_43 {
   long ru_msgsnd ;
   __syscall_slong_t __ru_msgsnd_word ;
};
#line 103 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_44 {
   long ru_msgrcv ;
   __syscall_slong_t __ru_msgrcv_word ;
};
#line 109 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_45 {
   long ru_nsignals ;
   __syscall_slong_t __ru_nsignals_word ;
};
#line 117 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_46 {
   long ru_nvcsw ;
   __syscall_slong_t __ru_nvcsw_word ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_47 {
   long ru_nivcsw ;
   __syscall_slong_t __ru_nivcsw_word ;
};
#line 33 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
struct rusage {
   struct timeval ru_utime ;
   struct timeval ru_stime ;
   union __anonunion_34 __annonCompField3 ;
   long ru_maxrss ;
   __syscall_slong_t __ru_maxrss_word ;
   union __anonunion_35 __annonCompField4 ;
   long ru_ixrss ;
   __syscall_slong_t __ru_ixrss_word ;
   union __anonunion_36 __annonCompField5 ;
   long ru_idrss ;
   __syscall_slong_t __ru_idrss_word ;
   union __anonunion_37 __annonCompField6 ;
   long ru_isrss ;
   __syscall_slong_t __ru_isrss_word ;
   union __anonunion_38 __annonCompField7 ;
   long ru_minflt ;
   __syscall_slong_t __ru_minflt_word ;
   union __anonunion_39 __annonCompField8 ;
   long ru_majflt ;
   __syscall_slong_t __ru_majflt_word ;
   union __anonunion_40 __annonCompField9 ;
   long ru_nswap ;
   __syscall_slong_t __ru_nswap_word ;
   union __anonunion_41 __annonCompField10 ;
   long ru_inblock ;
   __syscall_slong_t __ru_inblock_word ;
   union __anonunion_42 __annonCompField11 ;
   long ru_oublock ;
   __syscall_slong_t __ru_oublock_word ;
   union __anonunion_43 __annonCompField12 ;
   long ru_msgsnd ;
   __syscall_slong_t __ru_msgsnd_word ;
   union __anonunion_44 __annonCompField13 ;
   long ru_msgrcv ;
   __syscall_slong_t __ru_msgrcv_word ;
   union __anonunion_45 __annonCompField14 ;
   long ru_nsignals ;
   __syscall_slong_t __ru_nsignals_word ;
   union __anonunion_46 __annonCompField15 ;
   long ru_nvcsw ;
   __syscall_slong_t __ru_nvcsw_word ;
   union __anonunion_47 __annonCompField16 ;
   long ru_nivcsw ;
   __syscall_slong_t __ru_nivcsw_word ;
};
#line 43 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef int __rusage_who_t;
#line 38 "/root/patron/new_22/src/lib/openjp2/openjpeg.c"
struct opj_decompression {
   OPJ_BOOL (*opj_read_header)(struct opj_stream_private * , void * , opj_image_t ** ,
                               struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_decode)(void * , struct opj_stream_private * , opj_image_t * , struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_read_tile_header)(void * , OPJ_UINT32 * , OPJ_UINT32 * , OPJ_INT32 * ,
                                    OPJ_INT32 * , OPJ_INT32 * , OPJ_INT32 * , OPJ_UINT32 * ,
                                    OPJ_BOOL * , struct opj_stream_private * , struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_decode_tile_data)(void * , OPJ_UINT32  , OPJ_BYTE * , OPJ_UINT32  ,
                                    struct opj_stream_private * , struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_end_decompress)(void * , struct opj_stream_private * , struct opj_event_mgr * ) ;
   void (*opj_destroy)(void * ) ;
   void (*opj_setup_decoder)(void * , opj_dparameters_t * ) ;
   OPJ_BOOL (*opj_set_decode_area)(void * , opj_image_t * , OPJ_INT32  , OPJ_INT32  ,
                                   OPJ_INT32  , OPJ_INT32  , struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_get_decoded_tile)(void * , opj_stream_private_t * , opj_image_t * ,
                                    struct opj_event_mgr * , OPJ_UINT32  ) ;
   OPJ_BOOL (*opj_set_decoded_resolution_factor)(void * , OPJ_UINT32  , opj_event_mgr_t * ) ;
};
#line 94 "/root/patron/new_22/src/lib/openjp2/openjpeg.c"
typedef struct opj_decompression opj_decompression_t;
#line 99 "/root/patron/new_22/src/lib/openjp2/openjpeg.c"
struct opj_compression {
   OPJ_BOOL (*opj_start_compress)(void * , struct opj_stream_private * , struct opj_image * ,
                                  struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_encode)(void * , struct opj_stream_private * , struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_write_tile)(void * , OPJ_UINT32  , OPJ_BYTE * , OPJ_UINT32  , struct opj_stream_private * ,
                              struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_end_compress)(void * , struct opj_stream_private * , struct opj_event_mgr * ) ;
   void (*opj_destroy)(void * ) ;
   void (*opj_setup_encoder)(void * , opj_cparameters_t * , struct opj_image * , struct opj_event_mgr * ) ;
};
#line 128 "/root/patron/new_22/src/lib/openjp2/openjpeg.c"
typedef struct opj_compression opj_compression_t;
#line 136 "/root/patron/new_22/src/lib/openjp2/openjpeg.c"
union __anonunion_76 {
   opj_decompression_t m_decompression ;
   opj_compression_t m_compression ;
};
#line 133 "/root/patron/new_22/src/lib/openjp2/openjpeg.c"
struct opj_codec_private {
   union __anonunion_76 m_codec_data ;
   void *m_codec ;
   opj_event_mgr_t m_event_mgr ;
   OPJ_BOOL is_decompressor ;
   void (*opj_dump_codec)(void * , OPJ_INT32  , FILE * ) ;
   opj_codestream_info_v2_t *(*opj_get_codec_info)(void * ) ;
   opj_codestream_index_t *(*opj_get_codec_index)(void * ) ;
};
#line 151 "/root/patron/new_22/src/lib/openjp2/openjpeg.c"
typedef struct opj_codec_private opj_codec_private_t;
#line 191 "/root/patron/new_22/src/lib/openjp2/j2k.c"
struct opj_dec_memory_marker_handler ;
#line 1161 "/root/patron/new_22/src/lib/openjp2/j2k.c"
struct j2k_prog_order {
   OPJ_PROG_ORDER enum_prog ;
   char str_prog[5] ;
};
#line 1164 "/root/patron/new_22/src/lib/openjp2/j2k.c"
typedef struct j2k_prog_order j2k_prog_order_t;
#line 1186 "/root/patron/new_22/src/lib/openjp2/j2k.c"
typedef void (*opj_j2k_mct_function)(void const   * , void * , OPJ_UINT32  );
#line 1212 "/root/patron/new_22/src/lib/openjp2/j2k.c"
struct opj_dec_memory_marker_handler {
   OPJ_UINT32 id ;
   OPJ_UINT32 states ;
   OPJ_BOOL (*handler)(opj_j2k_t * , OPJ_BYTE * , OPJ_UINT32  , opj_event_mgr_t * ) ;
};
#line 1224 "/root/patron/new_22/src/lib/openjp2/j2k.c"
typedef struct opj_dec_memory_marker_handler opj_dec_memory_marker_handler_t;
#line 70 "/usr/include/x86_64-linux-gnu/tiff.h"
typedef unsigned short uint16;
#line 73 "/usr/include/x86_64-linux-gnu/tiff.h"
typedef unsigned int uint32;
#line 38 "/usr/include/x86_64-linux-gnu/tiffio.h"
struct tiff ;
#line 38 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef struct tiff TIFF;
#line 65 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef long tmsize_t;
#line 72 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef uint32 tstrile_t;
#line 73 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef tstrile_t tstrip_t;
#line 75 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef tmsize_t tsize_t;
#line 76 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef void *tdata_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 33 "/usr/include/setjmp.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 45 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag jmp_buf[1];
#line 481 "/usr/include/pngconf.h"
typedef unsigned char png_byte;
#line 511 "/usr/include/pngconf.h"
typedef unsigned int png_uint_32;
#line 577 "/usr/include/pngconf.h"
typedef void *png_voidp;
#line 580 "/usr/include/pngconf.h"
typedef png_byte *png_const_bytep;
#line 590 "/usr/include/pngconf.h"
typedef char const   *png_const_charp;
#line 597 "/usr/include/pngconf.h"
typedef FILE *png_FILE_p;
#line 606 "/usr/include/pngconf.h"
typedef png_byte **png_bytepp;
#line 454 "/usr/include/png.h"
struct png_struct_def ;
#line 454 "/usr/include/png.h"
typedef struct png_struct_def png_struct;
#line 456 "/usr/include/png.h"
typedef png_struct *png_structp;
#line 457 "/usr/include/png.h"
typedef png_struct **png_structpp;
#line 468
struct png_info_def ;
#line 468 "/usr/include/png.h"
typedef struct png_info_def png_info;
#line 469 "/usr/include/png.h"
typedef png_info *png_infop;
#line 471 "/usr/include/png.h"
typedef png_info **png_infopp;
#line 484 "/usr/include/png.h"
typedef png_struct *png_structrp;
#line 485 "/usr/include/png.h"
typedef png_struct *png_const_structrp;
#line 486 "/usr/include/png.h"
typedef png_info *png_inforp;
#line 487 "/usr/include/png.h"
typedef png_info *png_const_inforp;
#line 515 "/usr/include/png.h"
struct png_color_8_struct {
   png_byte red ;
   png_byte green ;
   png_byte blue ;
   png_byte gray ;
   png_byte alpha ;
};
#line 522 "/usr/include/png.h"
typedef struct png_color_8_struct png_color_8;
#line 524 "/usr/include/png.h"
typedef png_color_8 *png_const_color_8p;
#line 36 "/root/patron/new_22/src/bin/jp2/convert.h"
struct raw_cparameters {
   int rawWidth ;
   int rawHeight ;
   int rawComp ;
   int rawBitDepth ;
   OPJ_BOOL rawSigned ;
};
#line 48 "/root/patron/new_22/src/bin/jp2/convert.h"
typedef struct raw_cparameters raw_cparameters_t;
#line 510 "/root/patron/new_22/src/bin/jp2/convert.c"
typedef unsigned short WORD;
#line 513 "/root/patron/new_22/src/bin/jp2/convert.c"
typedef unsigned int DWORD;
#line 515 "/root/patron/new_22/src/bin/jp2/convert.c"
struct __anonstruct_117 {
   WORD bfType ;
   DWORD bfSize ;
   WORD bfReserved1 ;
   WORD bfReserved2 ;
   DWORD bfOffBits ;
};
#line 521 "/root/patron/new_22/src/bin/jp2/convert.c"
typedef struct __anonstruct_117 BITMAPFILEHEADER_t;
#line 523 "/root/patron/new_22/src/bin/jp2/convert.c"
struct __anonstruct_118 {
   DWORD biSize ;
   DWORD biWidth ;
   DWORD biHeight ;
   WORD biPlanes ;
   WORD biBitCount ;
   DWORD biCompression ;
   DWORD biSizeImage ;
   DWORD biXpelsPerMeter ;
   DWORD biYpelsPerMeter ;
   DWORD biClrUsed ;
   DWORD biClrImportant ;
};
#line 535 "/root/patron/new_22/src/bin/jp2/convert.c"
typedef struct __anonstruct_118 BITMAPINFOHEADER_t;
#line 1472 "/root/patron/new_22/src/bin/jp2/convert.c"
struct pnm_header {
   int width ;
   int height ;
   int maxval ;
   int depth ;
   int format ;
   char rgb ;
   char rgba ;
   char gray ;
   char graya ;
   char bw ;
   char ok ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream ;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 6 "/root/patron/new_22/src/bin/common/opj_getopt.h"
struct opj_option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 12 "/root/patron/new_22/src/bin/common/opj_getopt.h"
typedef struct opj_option opj_option_t;
#line 70 "/root/patron/new_22/src/bin/jp2/opj_decompress.c"
struct dircnt {
   char *filename_buf ;
   char **filename ;
};
#line 75 "/root/patron/new_22/src/bin/jp2/opj_decompress.c"
typedef struct dircnt dircnt_t;
#line 78 "/root/patron/new_22/src/bin/jp2/opj_decompress.c"
struct img_folder {
   char *imgdirpath ;
   char const   *out_format ;
   char set_imgdir ;
   char set_out_format ;
};
#line 88 "/root/patron/new_22/src/bin/jp2/opj_decompress.c"
typedef struct img_folder img_fol_t;
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 43 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memcpy(void *__dest , void const   *__src ,
                                                  size_t __n ) ;
#line 61
extern  __attribute__((__nothrow__)) void *memset(void *__s , int __c , size_t __n ) ;
#line 64
extern  __attribute__((__nothrow__)) int memcmp(void const   *__s1 , void const   *__s2 ,
                                                size_t __n ) ;
#line 122
extern  __attribute__((__nothrow__)) char *strcpy(char *__dest , char const   *__src ) ;
#line 125
extern  __attribute__((__nothrow__)) char *strncpy(char *__dest , char const   *__src ,
                                                   size_t __n ) ;
#line 130
extern  __attribute__((__nothrow__)) char *strcat(char *__dest , char const   *__src ) ;
#line 137
extern  __attribute__((__nothrow__)) int strcmp(char const   *__s1 , char const   *__s2 ) ;
#line 226
extern  __attribute__((__nothrow__)) char *strchr(char const   *__s , int __c ) ;
#line 253
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c ) ;
#line 336
extern  __attribute__((__nothrow__)) char *strtok(char *__s , char const   *__delim ) ;
#line 385
extern  __attribute__((__nothrow__)) unsigned long strlen(char const   *__s ) ;
#line 116 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) int strcasecmp(char const   *__s1 , char const   *__s2 ) ;
#line 104 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int atoi(char const   *__nptr ) ;
#line 539
extern  __attribute__((__nothrow__)) void *malloc(size_t __size ) ;
#line 542
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size ) ;
#line 550
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size ) ;
#line 565
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 840
extern  __attribute__((__nothrow__)) int abs(int __x ) ;
#line 140 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double pow(double __x , double __y ) ;
#line 159
extern  __attribute__((__nothrow__)) double ceil(double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) double floor(double __x ) ;
#line 314
extern  __attribute__((__nothrow__)) long lrintf(float __x ) ;
#line 138 "/usr/include/stdio.h"
extern FILE *stdout ;
#line 139
extern FILE *stderr ;
#line 146
extern  __attribute__((__nothrow__)) int remove(char const   *__filename ) ;
#line 213
extern int fclose(FILE *__stream ) ;
#line 246
extern FILE *fopen(char const   *__filename , char const   *__modes ) ;
#line 326
extern int fprintf(FILE *__stream , char const   *__format  , ...) ;
#line 332
extern int printf(char const   *__format  , ...) ;
#line 334
extern  __attribute__((__nothrow__)) int sprintf(char *__s , char const   *__format 
                                                 , ...) ;
#line 358
extern  __attribute__((__nothrow__)) int vsnprintf(char *__s , size_t __maxlen , char const   *__format ,
                                                   __gnuc_va_list __arg ) ;
#line 391
extern int fscanf(FILE *__stream , char const   *__format  , ...) ;
#line 399
extern  __attribute__((__nothrow__)) int sscanf(char const   *__s , char const   *__format 
                                                , ...) ;
#line 485
extern int fgetc(FILE *__stream ) ;
#line 486
extern int getc(FILE *__stream ) ;
#line 564
extern char *fgets(char *__s , int __n , FILE *__stream ) ;
#line 626
extern int fputs(char const   *__s , FILE *__stream ) ;
#line 646
extern unsigned long fread(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 652
extern unsigned long fwrite(void const   *__ptr , size_t __size , size_t __n , FILE *__s ) ;
#line 684
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 707
extern int fseeko(FILE *__stream , __off_t __off , int __whence ) ;
#line 712
extern __off_t ftello(FILE *__stream ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void) ;
#line 940 "/root/patron/new_22/src/lib/openjp2/openjpeg.h"
char const   *opj_version(void) ;
#line 956
opj_image_t *opj_image_create(OPJ_UINT32 numcmpts , opj_image_cmptparm_t *cmptparms ,
                              OPJ_COLOR_SPACE clrspc ) ;
#line 963
void opj_image_destroy(opj_image_t *image ) ;
#line 974
opj_image_t *opj_image_tile_create(OPJ_UINT32 numcmpts , opj_image_cmptparm_t *cmptparms ,
                                   OPJ_COLOR_SPACE clrspc ) ;
#line 989
opj_stream_t *opj_stream_default_create(OPJ_BOOL l_is_input ) ;
#line 999
opj_stream_t *opj_stream_create(OPJ_SIZE_T p_buffer_size , OPJ_BOOL l_is_input ) ;
#line 1007
void opj_stream_destroy(opj_stream_t *p_stream ) ;
#line 1015
void opj_stream_destroy_v3(opj_stream_t *p_stream ) ;
#line 1022
void opj_stream_set_read_function(opj_stream_t *p_stream , OPJ_SIZE_T (*p_function)(void * ,
                                                                                    OPJ_SIZE_T  ,
                                                                                    void * ) ) ;
#line 1029
void opj_stream_set_write_function(opj_stream_t *p_stream , OPJ_SIZE_T (*p_function)(void * ,
                                                                                     OPJ_SIZE_T  ,
                                                                                     void * ) ) ;
#line 1036
void opj_stream_set_skip_function(opj_stream_t *p_stream , OPJ_OFF_T (*p_function)(OPJ_OFF_T  ,
                                                                                   void * ) ) ;
#line 1043
void opj_stream_set_seek_function(opj_stream_t *p_stream , OPJ_BOOL (*p_function)(OPJ_OFF_T  ,
                                                                                  void * ) ) ;
#line 1050
void opj_stream_set_user_data(opj_stream_t *p_stream , void *p_data ) ;
#line 1058
void opj_stream_set_user_data_length(opj_stream_t *p_stream , OPJ_UINT64 data_length ) ;
#line 1066
opj_stream_t *opj_stream_create_default_file_stream(FILE *p_file , OPJ_BOOL p_is_read_stream ) ;
#line 1073
opj_stream_t *opj_stream_create_default_file_stream_v3(char const   *fname , OPJ_BOOL p_is_read_stream ) ;
#line 1081
opj_stream_t *opj_stream_create_file_stream(FILE *p_file , OPJ_SIZE_T p_size , OPJ_BOOL p_is_read_stream ) ;
#line 1090
opj_stream_t *opj_stream_create_file_stream_v3(char const   *fname , OPJ_SIZE_T p_size ,
                                               OPJ_BOOL p_is_read_stream ) ;
#line 1105
OPJ_BOOL opj_set_info_handler(opj_codec_t *p_codec , void (*p_callback)(char const   * ,
                                                                        void * ) ,
                              void *p_user_data ) ;
#line 1114
OPJ_BOOL opj_set_warning_handler(opj_codec_t *p_codec , void (*p_callback)(char const   * ,
                                                                           void * ) ,
                                 void *p_user_data ) ;
#line 1123
OPJ_BOOL opj_set_error_handler(opj_codec_t *p_codec , void (*p_callback)(char const   * ,
                                                                         void * ) ,
                               void *p_user_data ) ;
#line 1139
opj_codec_t *opj_create_decompress(OPJ_CODEC_FORMAT p_format ) ;
#line 1146
void opj_destroy_codec(opj_codec_t *p_codec ) ;
#line 1153
OPJ_BOOL opj_end_decompress(opj_codec_t *p_codec , opj_stream_t *p_stream ) ;
#line 1161
void opj_set_default_decoder_parameters(opj_dparameters_t *parameters ) ;
#line 1172
OPJ_BOOL opj_setup_decoder(opj_codec_t *p_codec , opj_dparameters_t *parameters ) ;
#line 1184
OPJ_BOOL opj_read_header(opj_stream_t *p_stream , opj_codec_t *p_codec , opj_image_t **p_image ) ;
#line 1200
OPJ_BOOL opj_set_decode_area(opj_codec_t *p_codec , opj_image_t *p_image , OPJ_INT32 p_start_x ,
                             OPJ_INT32 p_start_y , OPJ_INT32 p_end_x , OPJ_INT32 p_end_y ) ;
#line 1213
OPJ_BOOL opj_decode(opj_codec_t *p_codec , opj_stream_t *p_stream , opj_image_t *p_image ) ;
#line 1227
OPJ_BOOL opj_get_decoded_tile(opj_codec_t *p_codec , opj_stream_t *p_stream , opj_image_t *p_image ,
                              OPJ_UINT32 tile_index ) ;
#line 1239
OPJ_BOOL opj_set_decoded_resolution_factor(opj_codec_t *p_codec , OPJ_UINT32 res_factor ) ;
#line 1253
OPJ_BOOL opj_write_tile(opj_codec_t *p_codec , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                        OPJ_UINT32 p_data_size , opj_stream_t *p_stream ) ;
#line 1280
OPJ_BOOL opj_read_tile_header(opj_codec_t *p_codec , opj_stream_t *p_stream , OPJ_UINT32 *p_tile_index ,
                              OPJ_UINT32 *p_data_size , OPJ_INT32 *p_tile_x0 , OPJ_INT32 *p_tile_y0 ,
                              OPJ_INT32 *p_tile_x1 , OPJ_INT32 *p_tile_y1 , OPJ_UINT32 *p_nb_comps ,
                              OPJ_BOOL *p_should_go_on ) ;
#line 1301
OPJ_BOOL opj_decode_tile_data(opj_codec_t *p_codec , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                              OPJ_UINT32 p_data_size , opj_stream_t *p_stream ) ;
#line 1314
opj_codec_t *opj_create_compress(OPJ_CODEC_FORMAT p_format ) ;
#line 1337
void opj_set_default_encoder_parameters(opj_cparameters_t *parameters ) ;
#line 1345
OPJ_BOOL opj_setup_encoder(opj_codec_t *p_codec , opj_cparameters_t *parameters ,
                           opj_image_t *p_image ) ;
#line 1355
OPJ_BOOL opj_start_compress(opj_codec_t *p_codec , opj_image_t *p_image , opj_stream_t *p_stream ) ;
#line 1364
OPJ_BOOL opj_end_compress(opj_codec_t *p_codec , opj_stream_t *p_stream ) ;
#line 1374
OPJ_BOOL opj_encode(opj_codec_t *p_info , opj_stream_t *p_stream ) ;
#line 1387
void opj_destroy_cstr_info(opj_codestream_info_v2_t **cstr_info ) ;
#line 1398
void opj_dump_codec(opj_codec_t *p_codec , OPJ_INT32 info_flag , FILE *output_stream ) ;
#line 1410
opj_codestream_info_v2_t *opj_get_cstr_info(opj_codec_t *p_codec ) ;
#line 1420
opj_codestream_index_t *opj_get_cstr_index(opj_codec_t *p_codec ) ;
#line 1422
void opj_destroy_cstr_index(opj_codestream_index_t **p_cstr_index ) ;
#line 1462
OPJ_BOOL opj_set_MCT(opj_cparameters_t *parameters , OPJ_FLOAT32 *pEncodingMatrix ,
                     OPJ_INT32 *p_dc_shift , OPJ_UINT32 pNbComp ) ;
#line 46 "/root/patron/new_22/src/lib/openjp2/opj_clock.h"
OPJ_FLOAT64 opj_clock(void) ;
#line 76 "/root/patron/new_22/src/lib/openjp2/function_list.h"
opj_procedure_list_t *opj_procedure_list_create(void) ;
#line 83
void opj_procedure_list_destroy(opj_procedure_list_t *p_list ) ;
#line 93
OPJ_BOOL opj_procedure_list_add_procedure(opj_procedure_list_t *p_validation_list ,
                                          void (*p_procedure)(void) ) ;
#line 102
OPJ_UINT32 opj_procedure_list_get_nb_procedures(opj_procedure_list_t *p_validation_list ) ;
#line 113
opj_procedure *opj_procedure_list_get_first_procedure(opj_procedure_list_t *p_validation_list ) ;
#line 122
void opj_procedure_list_clear(opj_procedure_list_t *p_validation_list ) ;
#line 85 "/root/patron/new_22/src/lib/openjp2/event.h"
OPJ_BOOL opj_event_msg(opj_event_mgr_t *p_event_mgr , OPJ_INT32 event_type , char const   *fmt 
                       , ...) ;
#line 91
void opj_set_default_event_handler(opj_event_mgr_t *p_manager ) ;
#line 70 "/root/patron/new_22/src/lib/openjp2/bio.h"
opj_bio_t *opj_bio_create(void) ;
#line 75
void opj_bio_destroy(opj_bio_t *bio ) ;
#line 81
ptrdiff_t opj_bio_numbytes(opj_bio_t *bio ) ;
#line 88
void opj_bio_init_enc(opj_bio_t *bio , OPJ_BYTE *bp , OPJ_UINT32 len ) ;
#line 95
void opj_bio_init_dec(opj_bio_t *bio , OPJ_BYTE *bp , OPJ_UINT32 len ) ;
#line 102
void opj_bio_write(opj_bio_t *bio , OPJ_UINT32 v , OPJ_UINT32 n ) ;
#line 109
OPJ_UINT32 opj_bio_read(opj_bio_t *bio , OPJ_UINT32 n ) ;
#line 115
OPJ_BOOL opj_bio_flush(opj_bio_t *bio ) ;
#line 121
OPJ_BOOL opj_bio_inalign(opj_bio_t *bio ) ;
#line 167 "/root/patron/new_22/src/lib/openjp2/cio.h"
void opj_write_bytes_BE(OPJ_BYTE *p_buffer , OPJ_UINT32 p_value , OPJ_UINT32 p_nb_bytes ) ;
#line 176
void opj_read_bytes_BE(OPJ_BYTE *p_buffer , OPJ_UINT32 *p_value , OPJ_UINT32 p_nb_bytes ) ;
#line 185
void opj_write_bytes_LE(OPJ_BYTE *p_buffer , OPJ_UINT32 p_value , OPJ_UINT32 p_nb_bytes ) ;
#line 194
void opj_read_bytes_LE(OPJ_BYTE *p_buffer , OPJ_UINT32 *p_value , OPJ_UINT32 p_nb_bytes ) ;
#line 202
void opj_write_double_LE(OPJ_BYTE *p_buffer , OPJ_FLOAT64 p_value ) ;
#line 209
void opj_write_double_BE(OPJ_BYTE *p_buffer , OPJ_FLOAT64 p_value ) ;
#line 216
void opj_read_double_LE(OPJ_BYTE *p_buffer , OPJ_FLOAT64 *p_value ) ;
#line 223
void opj_read_double_BE(OPJ_BYTE *p_buffer , OPJ_FLOAT64 *p_value ) ;
#line 230
void opj_read_float_LE(OPJ_BYTE *p_buffer , OPJ_FLOAT32 *p_value ) ;
#line 237
void opj_read_float_BE(OPJ_BYTE *p_buffer , OPJ_FLOAT32 *p_value ) ;
#line 244
void opj_write_float_LE(OPJ_BYTE *p_buffer , OPJ_FLOAT32 p_value ) ;
#line 251
void opj_write_float_BE(OPJ_BYTE *p_buffer , OPJ_FLOAT32 p_value ) ;
#line 261
OPJ_SIZE_T opj_stream_read_data(opj_stream_private_t *p_stream , OPJ_BYTE *p_buffer ,
                                OPJ_SIZE_T p_size , opj_event_mgr_t *p_event_mgr ) ;
#line 271
OPJ_SIZE_T opj_stream_write_data(opj_stream_private_t *p_stream , OPJ_BYTE *p_buffer ,
                                 OPJ_SIZE_T p_size , opj_event_mgr_t *p_event_mgr ) ;
#line 279
OPJ_BOOL opj_stream_flush(opj_stream_private_t *p_stream , opj_event_mgr_t *p_event_mgr ) ;
#line 288
OPJ_OFF_T opj_stream_skip(opj_stream_private_t *p_stream , OPJ_OFF_T p_size , opj_event_mgr_t *p_event_mgr ) ;
#line 297
OPJ_OFF_T opj_stream_tell(opj_stream_private_t *p_stream ) ;
#line 307
OPJ_OFF_T opj_stream_get_number_byte_left(opj_stream_private_t *p_stream ) ;
#line 316
OPJ_OFF_T opj_stream_write_skip(opj_stream_private_t *p_stream , OPJ_OFF_T p_size ,
                                opj_event_mgr_t *p_event_mgr ) ;
#line 325
OPJ_OFF_T opj_stream_read_skip(opj_stream_private_t *p_stream , OPJ_OFF_T p_size ,
                               opj_event_mgr_t *p_event_mgr ) ;
#line 334
OPJ_BOOL opj_stream_read_seek(opj_stream_private_t *p_stream , OPJ_OFF_T p_size ,
                              opj_event_mgr_t *p_event_mgr ) ;
#line 343
OPJ_BOOL opj_stream_write_seek(opj_stream_private_t *p_stream , OPJ_OFF_T p_size ,
                               opj_event_mgr_t *p_event_mgr ) ;
#line 352
OPJ_BOOL opj_stream_seek(opj_stream_private_t *p_stream , OPJ_OFF_T p_size , struct opj_event_mgr *p_event_mgr ) ;
#line 357
OPJ_BOOL opj_stream_has_seek(opj_stream_private_t *p_stream ) ;
#line 362
OPJ_SIZE_T opj_stream_default_read(void *p_buffer , OPJ_SIZE_T p_nb_bytes , void *p_user_data ) ;
#line 367
OPJ_SIZE_T opj_stream_default_write(void *p_buffer , OPJ_SIZE_T p_nb_bytes , void *p_user_data ) ;
#line 372
OPJ_OFF_T opj_stream_default_skip(OPJ_OFF_T p_nb_bytes , void *p_user_data ) ;
#line 377
OPJ_BOOL opj_stream_default_seek(OPJ_OFF_T p_nb_bytes , void *p_user_data ) ;
#line 46 "/root/patron/new_22/src/lib/openjp2/image.h"
opj_image_t *opj_image_create0(void) ;
#line 56
void opj_image_comp_header_update(opj_image_t *p_image_header , struct opj_cp *p_cp ) ;
#line 58
void opj_copy_image_header(opj_image_t *p_image_src , opj_image_t *p_image_dest ) ;
#line 51 "/root/patron/new_22/src/lib/openjp2/invert.h"
OPJ_BOOL opj_matrix_inversion_f(OPJ_FLOAT32 *pSrcMatrix , OPJ_FLOAT32 *pDestMatrix ,
                                OPJ_UINT32 nb_compo ) ;
#line 583 "/root/patron/new_22/src/lib/openjp2/j2k.h"
void opj_j2k_setup_decoder(opj_j2k_t *j2k , opj_dparameters_t *parameters ) ;
#line 590
opj_j2k_t *opj_j2k_create_compress(void) ;
#line 593
void opj_j2k_setup_encoder(opj_j2k_t *p_j2k , opj_cparameters_t *parameters , opj_image_t *image ,
                           opj_event_mgr_t *p_manager ) ;
#line 601
char *opj_j2k_convert_progression_order(OPJ_PROG_ORDER prg_order ) ;
#line 612
OPJ_BOOL opj_j2k_end_decompress(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                opj_event_mgr_t *p_manager ) ;
#line 626
OPJ_BOOL opj_j2k_read_header(opj_stream_private_t *p_stream , opj_j2k_t *p_j2k , opj_image_t **p_image ,
                             opj_event_mgr_t *p_manager ) ;
#line 637
void opj_j2k_destroy(opj_j2k_t *p_j2k ) ;
#line 644
void j2k_destroy_cstr_index(opj_codestream_index_t *p_cstr_ind ) ;
#line 655
OPJ_BOOL opj_j2k_decode_tile(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                             OPJ_UINT32 p_data_size , opj_stream_private_t *p_stream ,
                             opj_event_mgr_t *p_manager ) ;
#line 676
OPJ_BOOL opj_j2k_read_tile_header(opj_j2k_t *p_j2k , OPJ_UINT32 *p_tile_index , OPJ_UINT32 *p_data_size ,
                                  OPJ_INT32 *p_tile_x0 , OPJ_INT32 *p_tile_y0 , OPJ_INT32 *p_tile_x1 ,
                                  OPJ_INT32 *p_tile_y1 , OPJ_UINT32 *p_nb_comps ,
                                  OPJ_BOOL *p_go_on , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) ;
#line 702
OPJ_BOOL opj_j2k_set_decode_area(opj_j2k_t *p_j2k , opj_image_t *p_image , OPJ_INT32 p_start_x ,
                                 OPJ_INT32 p_start_y , OPJ_INT32 p_end_x , OPJ_INT32 p_end_y ,
                                 opj_event_mgr_t *p_manager ) ;
#line 713
opj_j2k_t *opj_j2k_create_decompress(void) ;
#line 724
void j2k_dump(opj_j2k_t *p_j2k , OPJ_INT32 flag , FILE *out_stream ) ;
#line 735
void j2k_dump_image_header(opj_image_t *img_header , OPJ_BOOL dev_dump_flag , FILE *out_stream ) ;
#line 744
void j2k_dump_image_comp_header(opj_image_comp_t *comp_header , OPJ_BOOL dev_dump_flag ,
                                FILE *out_stream ) ;
#line 753
opj_codestream_info_v2_t *j2k_get_cstr_info(opj_j2k_t *p_j2k ) ;
#line 762
opj_codestream_index_t *j2k_get_cstr_index(opj_j2k_t *p_j2k ) ;
#line 772
OPJ_BOOL opj_j2k_decode(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_image_t *p_image ,
                        opj_event_mgr_t *p_manager ) ;
#line 778
OPJ_BOOL opj_j2k_get_tile(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_image_t *p_image ,
                          opj_event_mgr_t *p_manager , OPJ_UINT32 tile_index ) ;
#line 784
OPJ_BOOL opj_j2k_set_decoded_resolution_factor(opj_j2k_t *p_j2k , OPJ_UINT32 res_factor ,
                                               opj_event_mgr_t *p_manager ) ;
#line 798
OPJ_BOOL opj_j2k_write_tile(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                            OPJ_UINT32 p_data_size , opj_stream_private_t *p_stream ,
                            opj_event_mgr_t *p_manager ) ;
#line 808
OPJ_BOOL opj_j2k_encode(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) ;
#line 822
OPJ_BOOL opj_j2k_start_compress(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                opj_image_t *p_image , opj_event_mgr_t *p_manager ) ;
#line 831
OPJ_BOOL opj_j2k_end_compress(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                              opj_event_mgr_t *p_manager ) ;
#line 835
OPJ_BOOL opj_j2k_setup_mct_encoding(opj_tcp_t *p_tcp , opj_image_t *p_image ) ;
#line 242 "/root/patron/new_22/src/lib/openjp2/jp2.h"
OPJ_BOOL opj_jp2_write_jp2h(opj_jp2_t *jp2 , opj_stream_private_t *stream , opj_event_mgr_t *p_manager ) ;
#line 252
void opj_jp2_setup_decoder(opj_jp2_t *jp2 , opj_dparameters_t *parameters ) ;
#line 263
OPJ_BOOL opj_jp2_decode(opj_jp2_t *jp2 , opj_stream_private_t *p_stream , opj_image_t *p_image ,
                        opj_event_mgr_t *p_manager ) ;
#line 277
void opj_jp2_setup_encoder(opj_jp2_t *jp2 , opj_cparameters_t *parameters , opj_image_t *image ,
                           opj_event_mgr_t *p_manager ) ;
#line 289
OPJ_BOOL opj_jp2_encode(opj_jp2_t *jp2 , opj_stream_private_t *stream , opj_event_mgr_t *p_manager ) ;
#line 304
OPJ_BOOL opj_jp2_start_compress(opj_jp2_t *jp2 , opj_stream_private_t *stream , opj_image_t *p_image ,
                                opj_event_mgr_t *p_manager ) ;
#line 314
OPJ_BOOL opj_jp2_end_compress(opj_jp2_t *jp2 , opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) ;
#line 324
OPJ_BOOL opj_jp2_end_decompress(opj_jp2_t *jp2 , opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) ;
#line 338
OPJ_BOOL opj_jp2_read_header(opj_stream_private_t *p_stream , opj_jp2_t *jp2 , opj_image_t **p_image ,
                             opj_event_mgr_t *p_manager ) ;
#line 357
OPJ_BOOL opj_jp2_read_tile_header(opj_jp2_t *p_jp2 , OPJ_UINT32 *p_tile_index , OPJ_UINT32 *p_data_size ,
                                  OPJ_INT32 *p_tile_x0 , OPJ_INT32 *p_tile_y0 , OPJ_INT32 *p_tile_x1 ,
                                  OPJ_INT32 *p_tile_y1 , OPJ_UINT32 *p_nb_comps ,
                                  OPJ_BOOL *p_go_on , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) ;
#line 379
OPJ_BOOL opj_jp2_write_tile(opj_jp2_t *p_jp2 , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                            OPJ_UINT32 p_data_size , opj_stream_private_t *p_stream ,
                            opj_event_mgr_t *p_manager ) ;
#line 397
OPJ_BOOL opj_jp2_decode_tile(opj_jp2_t *p_jp2 , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                             OPJ_UINT32 p_data_size , opj_stream_private_t *p_stream ,
                             opj_event_mgr_t *p_manager ) ;
#line 409
opj_jp2_t *opj_jp2_create(OPJ_BOOL p_is_decoder ) ;
#line 415
void opj_jp2_destroy(opj_jp2_t *jp2 ) ;
#line 431
OPJ_BOOL opj_jp2_set_decode_area(opj_jp2_t *p_jp2 , opj_image_t *p_image , OPJ_INT32 p_start_x ,
                                 OPJ_INT32 p_start_y , OPJ_INT32 p_end_x , OPJ_INT32 p_end_y ,
                                 opj_event_mgr_t *p_manager ) ;
#line 440
OPJ_BOOL opj_jp2_get_tile(opj_jp2_t *p_jp2 , opj_stream_private_t *p_stream , opj_image_t *p_image ,
                          opj_event_mgr_t *p_manager , OPJ_UINT32 tile_index ) ;
#line 450
OPJ_BOOL opj_jp2_set_decoded_resolution_factor(opj_jp2_t *p_jp2 , OPJ_UINT32 res_factor ,
                                               opj_event_mgr_t *p_manager ) ;
#line 464
void jp2_dump(opj_jp2_t *p_jp2 , OPJ_INT32 flag , FILE *out_stream ) ;
#line 473
opj_codestream_info_v2_t *jp2_get_cstr_info(opj_jp2_t *p_jp2 ) ;
#line 482
opj_codestream_index_t *jp2_get_cstr_index(opj_jp2_t *p_jp2 ) ;
#line 86 "/root/patron/new_22/src/lib/openjp2/mqc.h"
opj_mqc_t *opj_mqc_create(void) ;
#line 91
void opj_mqc_destroy(opj_mqc_t *mqc ) ;
#line 97
OPJ_UINT32 opj_mqc_numbytes(opj_mqc_t *mqc ) ;
#line 103
void opj_mqc_resetstates(opj_mqc_t *mqc ) ;
#line 111
void opj_mqc_setstate(opj_mqc_t *mqc , OPJ_UINT32 ctxno , OPJ_UINT32 msb , OPJ_INT32 prob ) ;
#line 117
void opj_mqc_init_enc(opj_mqc_t *mqc , OPJ_BYTE *bp ) ;
#line 129
void opj_mqc_encode(opj_mqc_t *mqc , OPJ_UINT32 d ) ;
#line 134
void opj_mqc_flush(opj_mqc_t *mqc ) ;
#line 141
void opj_mqc_bypass_init_enc(opj_mqc_t *mqc ) ;
#line 149
void opj_mqc_bypass_enc(opj_mqc_t *mqc , OPJ_UINT32 d ) ;
#line 156
OPJ_UINT32 opj_mqc_bypass_flush_enc(opj_mqc_t *mqc ) ;
#line 161
void opj_mqc_reset_enc(opj_mqc_t *mqc ) ;
#line 167
OPJ_UINT32 opj_mqc_restart_enc(opj_mqc_t *mqc ) ;
#line 172
void opj_mqc_restart_init_enc(opj_mqc_t *mqc ) ;
#line 177
void opj_mqc_erterm_enc(opj_mqc_t *mqc ) ;
#line 182
void opj_mqc_segmark_enc(opj_mqc_t *mqc ) ;
#line 189
OPJ_BOOL opj_mqc_init_dec(opj_mqc_t *mqc , OPJ_BYTE *bp , OPJ_UINT32 len ) ;
#line 195
OPJ_INT32 opj_mqc_decode(opj_mqc_t *mqc ) ;
#line 70 "/root/patron/new_22/src/lib/openjp2/raw.h"
opj_raw_t *opj_raw_create(void) ;
#line 75
void opj_raw_destroy(opj_raw_t *raw ) ;
#line 81
OPJ_UINT32 opj_raw_numbytes(opj_raw_t *raw ) ;
#line 88
void opj_raw_init_dec(opj_raw_t *raw , OPJ_BYTE *bp , OPJ_UINT32 len ) ;
#line 94
OPJ_UINT32 opj_raw_decode(opj_raw_t *raw ) ;
#line 117 "/root/patron/new_22/src/lib/openjp2/pi.h"
opj_pi_iterator_t *opj_pi_initialise_encode(opj_image_t *p_image , opj_cp_t *p_cp ,
                                            OPJ_UINT32 p_tile_no , J2K_T2_MODE p_t2_mode ) ;
#line 129
void opj_pi_update_encoding_parameters(opj_image_t *p_image , opj_cp_t *p_cp , OPJ_UINT32 p_tile_no ) ;
#line 143
void opj_pi_create_encode(opj_pi_iterator_t *pi , opj_cp_t *cp , OPJ_UINT32 tileno ,
                          OPJ_UINT32 pino , OPJ_UINT32 tpnum , OPJ_INT32 tppos , J2K_T2_MODE t2_mode ) ;
#line 159
opj_pi_iterator_t *opj_pi_create_decode(opj_image_t *p_image , opj_cp_t *p_cp , OPJ_UINT32 p_tile_no ) ;
#line 168
void opj_pi_destroy(opj_pi_iterator_t *p_pi , OPJ_UINT32 p_nb_elements ) ;
#line 176
OPJ_BOOL opj_pi_next(opj_pi_iterator_t *pi ) ;
#line 80 "/root/patron/new_22/src/lib/openjp2/tgt.h"
opj_tgt_tree_t *opj_tgt_create(OPJ_UINT32 numleafsh , OPJ_UINT32 numleafsv ) ;
#line 90
opj_tgt_tree_t *opj_tgt_init(opj_tgt_tree_t *p_tree , OPJ_UINT32 p_num_leafs_h , OPJ_UINT32 p_num_leafs_v ) ;
#line 97
void opj_tgt_destroy(opj_tgt_tree_t *p_tree ) ;
#line 102
void opj_tgt_reset(opj_tgt_tree_t *p_tree ) ;
#line 109
void opj_tgt_setvalue(opj_tgt_tree_t *tree , OPJ_UINT32 leafno , OPJ_INT32 value ) ;
#line 119
void opj_tgt_encode(opj_bio_t *bio , opj_tgt_tree_t *tree , OPJ_UINT32 leafno , OPJ_INT32 threshold ) ;
#line 131
OPJ_UINT32 opj_tgt_decode(opj_bio_t *bio , opj_tgt_tree_t *tree , OPJ_UINT32 leafno ,
                          OPJ_INT32 threshold ) ;
#line 229 "/root/patron/new_22/src/lib/openjp2/tcd.h"
opj_tcd_t *opj_tcd_create(OPJ_BOOL p_is_decoder ) ;
#line 235
void opj_tcd_destroy(opj_tcd_t *tcd ) ;
#line 245
OPJ_BOOL opj_tcd_init(opj_tcd_t *p_tcd , opj_image_t *p_image , opj_cp_t *p_cp ) ;
#line 258
OPJ_BOOL opj_tcd_init_decode_tile(opj_tcd_t *p_tcd , OPJ_UINT32 p_tile_no ) ;
#line 260
void opj_tcd_makelayer_fixed(opj_tcd_t *tcd , OPJ_UINT32 layno , OPJ_UINT32 final ) ;
#line 262
void opj_tcd_rateallocate_fixed(opj_tcd_t *tcd ) ;
#line 264
void opj_tcd_makelayer(opj_tcd_t *tcd , OPJ_UINT32 layno , OPJ_FLOAT64 thresh , OPJ_UINT32 final ) ;
#line 269
OPJ_BOOL opj_tcd_rateallocate(opj_tcd_t *tcd , OPJ_BYTE *dest , OPJ_UINT32 *p_data_written ,
                              OPJ_UINT32 len , opj_codestream_info_t *cstr_info ) ;
#line 278
OPJ_UINT32 opj_tcd_get_decoded_tile_size(opj_tcd_t *p_tcd ) ;
#line 290
OPJ_BOOL opj_tcd_encode_tile(opj_tcd_t *p_tcd , OPJ_UINT32 p_tile_no , OPJ_BYTE *p_dest ,
                             OPJ_UINT32 *p_data_written , OPJ_UINT32 p_max_length ,
                             opj_codestream_info_t *p_cstr_info ) ;
#line 306
OPJ_BOOL opj_tcd_decode_tile(opj_tcd_t *p_tcd , OPJ_BYTE *p_src , OPJ_UINT32 p_max_length ,
                             OPJ_UINT32 p_tile_no , opj_codestream_index_t *p_cstr_index ) ;
#line 316
OPJ_BOOL opj_tcd_update_tile_data(opj_tcd_t *p_tcd , OPJ_BYTE *p_dest , OPJ_UINT32 p_dest_length ) ;
#line 323
OPJ_UINT32 opj_tcd_get_encoded_tile_size(opj_tcd_t *p_tcd ) ;
#line 333
OPJ_BOOL opj_tcd_init_encode_tile(opj_tcd_t *p_tcd , OPJ_UINT32 p_tile_no ) ;
#line 339
OPJ_BOOL opj_tcd_copy_tile_data(opj_tcd_t *p_tcd , OPJ_BYTE *p_src , OPJ_UINT32 p_src_length ) ;
#line 122 "/root/patron/new_22/src/lib/openjp2/t1.h"
OPJ_BOOL opj_t1_encode_cblks(opj_t1_t *t1 , opj_tcd_tile_t *tile , opj_tcp_t *tcp ,
                             OPJ_FLOAT64 *mct_norms ) ;
#line 133
OPJ_BOOL opj_t1_decode_cblks(opj_t1_t *t1 , opj_tcd_tilecomp_t *tilec , opj_tccp_t *tccp ) ;
#line 144
opj_t1_t *opj_t1_create(void) ;
#line 151
void opj_t1_destroy(opj_t1_t *p_t1 ) ;
#line 55 "/root/patron/new_22/src/lib/openjp2/dwt.h"
extern OPJ_BOOL opj_dwt_encode(opj_tcd_tilecomp_t *tilec ) ;
#line 63
extern OPJ_BOOL opj_dwt_decode(opj_tcd_tilecomp_t *tilec , OPJ_UINT32 numres ) ;
#line 70
extern OPJ_UINT32 opj_dwt_getgain(OPJ_UINT32 orient ) ;
#line 77
extern OPJ_FLOAT64 opj_dwt_getnorm(OPJ_UINT32 level , OPJ_UINT32 orient ) ;
#line 83
extern OPJ_BOOL opj_dwt_encode_real(opj_tcd_tilecomp_t *tilec ) ;
#line 90
extern OPJ_BOOL opj_dwt_decode_real(opj_tcd_tilecomp_t *tilec , OPJ_UINT32 numres ) ;
#line 97
extern OPJ_UINT32 opj_dwt_getgain_real(OPJ_UINT32 orient ) ;
#line 104
extern OPJ_FLOAT64 opj_dwt_getnorm_real(OPJ_UINT32 level , OPJ_UINT32 orient ) ;
#line 110
extern void opj_dwt_calc_explicit_stepsizes(opj_tccp_t *tccp , OPJ_UINT32 prec ) ;
#line 74 "/root/patron/new_22/src/lib/openjp2/t2.h"
OPJ_BOOL opj_t2_encode_packets(opj_t2_t *p_t2 , OPJ_UINT32 p_tile_no , opj_tcd_tile_t *p_tile ,
                               OPJ_UINT32 p_maxlayers , OPJ_BYTE *p_dest , OPJ_UINT32 *p_data_written ,
                               OPJ_UINT32 p_max_len , opj_codestream_info_t *cstr_info ,
                               OPJ_UINT32 p_tp_num , OPJ_INT32 p_tp_pos , OPJ_UINT32 p_pino ,
                               J2K_T2_MODE p_t2_mode ) ;
#line 99
OPJ_BOOL opj_t2_decode_packets(opj_t2_t *p_t2 , OPJ_UINT32 p_tile_no , opj_tcd_tile_t *p_tile ,
                               OPJ_BYTE *p_src , OPJ_UINT32 *p_data_read , OPJ_UINT32 p_max_len ,
                               opj_codestream_index_t *p_cstr_index ) ;
#line 114
opj_t2_t *opj_t2_create(opj_image_t *p_image , opj_cp_t *p_cp ) ;
#line 120
void opj_t2_destroy(opj_t2_t *t2 ) ;
#line 57 "/root/patron/new_22/src/lib/openjp2/mct.h"
extern void opj_mct_encode(OPJ_INT32 *c0 , OPJ_INT32 *c1 , OPJ_INT32 *c2 , OPJ_UINT32 n ) ;
#line 65
extern void opj_mct_decode(OPJ_INT32 *c0 , OPJ_INT32 *c1 , OPJ_INT32 *c2 , OPJ_UINT32 n ) ;
#line 80
extern void opj_mct_encode_real(OPJ_INT32 *c0 , OPJ_INT32 *c1 , OPJ_INT32 *c2 , OPJ_UINT32 n ) ;
#line 88
extern void opj_mct_decode_real(OPJ_FLOAT32 *c0 , OPJ_FLOAT32 *c1 , OPJ_FLOAT32 *c2 ,
                                OPJ_UINT32 n ) ;
#line 105
extern OPJ_BOOL opj_mct_encode_custom(OPJ_BYTE *p_coding_data , OPJ_UINT32 n , OPJ_BYTE **p_data ,
                                      OPJ_UINT32 p_nb_comp , OPJ_UINT32 is_signed ) ;
#line 120
extern OPJ_BOOL opj_mct_decode_custom(OPJ_BYTE *pDecodingData , OPJ_UINT32 n , OPJ_BYTE **pData ,
                                      OPJ_UINT32 pNbComp , OPJ_UINT32 isSigned ) ;
#line 133
extern void opj_calculate_norms(OPJ_FLOAT64 *pNorms , OPJ_UINT32 p_nb_comps , OPJ_FLOAT32 *pMatrix ) ;
#line 139
extern OPJ_FLOAT64 *opj_mct_get_mct_norms(void) ;
#line 143
extern OPJ_FLOAT64 *opj_mct_get_mct_norms_real(void) ;
#line 50 "/root/patron/new_22/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_min(OPJ_INT32 a , OPJ_INT32 b ) 
{ 
  OPJ_INT32 tmp ;

  {
#line 51
  if (a < b) {
#line 51
    tmp = a;
  } else {
#line 51
    tmp = b;
  }
#line 51
  return (tmp);
}
}
#line 58 "/root/patron/new_22/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_UINT32 opj_uint_min(OPJ_UINT32 a , OPJ_UINT32 b ) 
{ 
  OPJ_UINT32 tmp ;

  {
#line 59
  if (a < b) {
#line 59
    tmp = a;
  } else {
#line 59
    tmp = b;
  }
#line 59
  return (tmp);
}
}
#line 66 "/root/patron/new_22/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_max(OPJ_INT32 a , OPJ_INT32 b ) 
{ 
  OPJ_INT32 tmp ;

  {
#line 67
  if (a > b) {
#line 67
    tmp = a;
  } else {
#line 67
    tmp = b;
  }
#line 67
  return (tmp);
}
}
#line 74 "/root/patron/new_22/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_UINT32 opj_uint_max(OPJ_UINT32 a , OPJ_UINT32 b ) 
{ 
  OPJ_UINT32 tmp ;

  {
#line 75
  if (a > b) {
#line 75
    tmp = a;
  } else {
#line 75
    tmp = b;
  }
#line 75
  return (tmp);
}
}
#line 87 "/root/patron/new_22/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_clamp(OPJ_INT32 a , OPJ_INT32 min , OPJ_INT32 max ) 
{ 


  {
#line 88
  if (a < min) {
#line 89
    return (min);
  }
#line 90
  if (a > max) {
#line 91
    return (max);
  }
#line 92
  return (a);
}
}
#line 97 "/root/patron/new_22/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_abs(OPJ_INT32 a ) 
{ 
  OPJ_INT32 tmp ;

  {
#line 98
  if (a < 0) {
#line 98
    tmp = - a;
  } else {
#line 98
    tmp = a;
  }
#line 98
  return (tmp);
}
}
#line 104 "/root/patron/new_22/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_ceildiv(OPJ_INT32 a , OPJ_INT32 b ) 
{ 


  {
#line 105
  return (((a + b) - 1) / b);
}
}
#line 112 "/root/patron/new_22/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_UINT32 opj_uint_ceildiv(OPJ_UINT32 a , OPJ_UINT32 b ) 
{ 


  {
#line 113
  return (((a + b) - 1U) / b);
}
}
#line 120 "/root/patron/new_22/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_ceildivpow2(OPJ_INT32 a , OPJ_INT32 b ) 
{ 


  {
#line 121
  return (((a + (1 << b)) - 1) >> b);
}
}
#line 127 "/root/patron/new_22/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_floordivpow2(OPJ_INT32 a , OPJ_INT32 b ) 
{ 


  {
#line 128
  return (a >> b);
}
}
#line 134 "/root/patron/new_22/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_floorlog2(OPJ_INT32 a ) 
{ 
  OPJ_INT32 l ;

  {
#line 136
  l = 0;
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;

#line 136
    if (! (a > 1)) {
#line 136
      goto while_break;
    }
#line 137
    a >>= 1;
#line 136
    l ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 139
  return (l);
}
}
#line 145 "/root/patron/new_22/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_UINT32 opj_uint_floorlog2(OPJ_UINT32 a ) 
{ 
  OPJ_UINT32 l ;

  {
#line 147
  l = (OPJ_UINT32 )0;
  {
#line 147
  while (1) {
    while_continue: /* CIL Label */ ;

#line 147
    if (! (a > 1U)) {
#line 147
      goto while_break;
    }
#line 149
    a >>= 1;
#line 147
    l ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 151
  return (l);
}
}
#line 160 "/root/patron/new_22/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_fix_mul(OPJ_INT32 a , OPJ_INT32 b ) 
{ 
  OPJ_INT64 temp ;

  {
#line 161
  temp = (OPJ_INT64 )a * (OPJ_INT64 )b;
#line 162
  temp += temp & 4096L;
#line 163
  return ((OPJ_INT32 )(temp >> 13));
}
}
#line 42 "/root/patron/new_22/src/lib/openjp2/tgt.c"
opj_tgt_tree_t *opj_tgt_create(OPJ_UINT32 numleafsh , OPJ_UINT32 numleafsv ) 
{ 
  OPJ_INT32 nplh[32] ;
  OPJ_INT32 nplv[32] ;
  opj_tgt_node_t *node ;
  opj_tgt_node_t *l_parent_node ;
  opj_tgt_node_t *l_parent_node0 ;
  opj_tgt_tree_t *tree ;
  OPJ_UINT32 i ;
  OPJ_INT32 j ;
  OPJ_INT32 k ;
  OPJ_UINT32 numlvls ;
  OPJ_UINT32 n ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;

  {
  {
#line 45
  node = (opj_tgt_node_t *)0;
#line 46
  l_parent_node = (opj_tgt_node_t *)0;
#line 47
  l_parent_node0 = (opj_tgt_node_t *)0;
#line 48
  tree = (opj_tgt_tree_t *)0;
#line 54
  __cil_tmp14 = malloc(sizeof(opj_tgt_tree_t ));
#line 54
  tree = (opj_tgt_tree_t *)__cil_tmp14;
  }
#line 55
  if (! tree) {
    {
#line 56
    fprintf(stderr, "ERROR in tgt_create while allocating tree\n");
    }
#line 57
    return ((opj_tgt_tree_t *)0);
  }
  {
#line 59
  memset((void *)tree, 0, sizeof(opj_tgt_tree_t ));
#line 61
  tree->numleafsh = numleafsh;
#line 62
  tree->numleafsv = numleafsv;
#line 64
  numlvls = (OPJ_UINT32 )0;
#line 65
  nplh[0] = (OPJ_INT32 )numleafsh;
#line 66
  nplv[0] = (OPJ_INT32 )numleafsv;
#line 67
  tree->numnodes = (OPJ_UINT32 )0;
  }
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    n = (OPJ_UINT32 )(nplh[numlvls] * nplv[numlvls]);
#line 70
    nplh[numlvls + 1U] = (nplh[numlvls] + 1) / 2;
#line 71
    nplv[numlvls + 1U] = (nplv[numlvls] + 1) / 2;
#line 72
    tree->numnodes += n;
#line 73
    numlvls ++;
#line 68
    if (! (n > 1U)) {
#line 68
      goto while_break;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: ;
#line 77
  if (tree->numnodes == 0U) {
    {
#line 78
    free((void *)tree);
#line 79
    fprintf(stderr, "WARNING in tgt_create tree->numnodes == 0, no tree created.\n");
    }
#line 80
    return ((opj_tgt_tree_t *)0);
  }
  {
#line 83
  __cil_tmp15 = calloc((unsigned long )tree->numnodes, sizeof(opj_tgt_node_t ));
#line 83
  tree->nodes = (opj_tgt_node_t *)__cil_tmp15;
  }
#line 84
  if (! tree->nodes) {
    {
#line 85
    fprintf(stderr, "ERROR in tgt_create while allocating node of the tree\n");
#line 86
    free((void *)tree);
    }
#line 87
    return ((opj_tgt_tree_t *)0);
  }
  {
#line 89
  memset((void *)tree->nodes, 0, (unsigned long )tree->numnodes * sizeof(opj_tgt_node_t ));
#line 90
  tree->nodes_size = (OPJ_UINT32 )((unsigned long )tree->numnodes * sizeof(opj_tgt_node_t ));
#line 92
  node = tree->nodes;
#line 93
  l_parent_node = tree->nodes + tree->numleafsh * tree->numleafsv;
#line 94
  l_parent_node0 = l_parent_node;
#line 96
  i = (OPJ_UINT32 )0;
  }
  {
#line 96
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 96
    if (! (i < numlvls - 1U)) {
#line 96
      goto while_break___0;
    }
#line 97
    j = 0;
    {
#line 97
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 97
      if (! (j < nplv[i])) {
#line 97
        goto while_break___1;
      }
#line 98
      k = nplh[i];
      {
#line 99
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 99
        k --;
#line 99
        if (! (k >= 0)) {
#line 99
          goto while_break___2;
        }
#line 100
        node->parent = l_parent_node;
#line 101
        node ++;
#line 102
        k --;
#line 102
        if (k >= 0) {
#line 103
          node->parent = l_parent_node;
#line 104
          node ++;
        }
#line 106
        l_parent_node ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___2: ;
#line 108
      if (j & 1) {
#line 109
        l_parent_node0 = l_parent_node;
      } else
#line 108
      if (j == nplv[i] - 1) {
#line 109
        l_parent_node0 = l_parent_node;
      } else {
#line 111
        l_parent_node = l_parent_node0;
#line 112
        l_parent_node0 += nplh[i];
      }
#line 97
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: 
#line 96
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 116
  node->parent = (struct opj_tgt_node *)0;
#line 117
  opj_tgt_reset(tree);
  }
#line 118
  return (tree);
}
}
#line 129 "/root/patron/new_22/src/lib/openjp2/tgt.c"
opj_tgt_tree_t *opj_tgt_init(opj_tgt_tree_t *p_tree , OPJ_UINT32 p_num_leafs_h , OPJ_UINT32 p_num_leafs_v ) 
{ 
  OPJ_INT32 l_nplh[32] ;
  OPJ_INT32 l_nplv[32] ;
  opj_tgt_node_t *l_node ;
  opj_tgt_node_t *l_parent_node ;
  opj_tgt_node_t *l_parent_node0 ;
  OPJ_UINT32 i ;
  OPJ_INT32 j ;
  OPJ_INT32 k ;
  OPJ_UINT32 l_num_levels ;
  OPJ_UINT32 n ;
  OPJ_UINT32 l_node_size ;
  opj_tgt_node_t *new_nodes ;
  void *__cil_tmp16 ;

  {
#line 133
  l_node = (opj_tgt_node_t *)0;
#line 134
  l_parent_node = (opj_tgt_node_t *)0;
#line 135
  l_parent_node0 = (opj_tgt_node_t *)0;
#line 142
  if (! p_tree) {
#line 143
    return ((opj_tgt_tree_t *)0);
  }
#line 146
  if (p_tree->numleafsh != p_num_leafs_h) {
    _L: 
#line 147
    p_tree->numleafsh = p_num_leafs_h;
#line 148
    p_tree->numleafsv = p_num_leafs_v;
#line 150
    l_num_levels = (OPJ_UINT32 )0;
#line 151
    l_nplh[0] = (OPJ_INT32 )p_num_leafs_h;
#line 152
    l_nplv[0] = (OPJ_INT32 )p_num_leafs_v;
#line 153
    p_tree->numnodes = (OPJ_UINT32 )0;
    {
#line 154
    while (1) {
      while_continue: /* CIL Label */ ;
#line 156
      n = (OPJ_UINT32 )(l_nplh[l_num_levels] * l_nplv[l_num_levels]);
#line 157
      l_nplh[l_num_levels + 1U] = (l_nplh[l_num_levels] + 1) / 2;
#line 158
      l_nplv[l_num_levels + 1U] = (l_nplv[l_num_levels] + 1) / 2;
#line 159
      p_tree->numnodes += n;
#line 160
      l_num_levels ++;
#line 154
      if (! (n > 1U)) {
#line 154
        goto while_break;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break: ;
#line 165
    if (p_tree->numnodes == 0U) {
      {
#line 166
      opj_tgt_destroy(p_tree);
      }
#line 167
      return ((opj_tgt_tree_t *)0);
    }
#line 169
    l_node_size = (OPJ_UINT32 )((unsigned long )p_tree->numnodes * sizeof(opj_tgt_node_t ));
#line 171
    if (l_node_size > p_tree->nodes_size) {
      {
#line 172
      __cil_tmp16 = realloc((void *)p_tree->nodes, (unsigned long )l_node_size);
#line 172
      new_nodes = (opj_tgt_node_t *)__cil_tmp16;
      }
#line 173
      if (! new_nodes) {
        {
#line 174
        fprintf(stderr, "ERROR Not enough memory to reinitialize the tag tree\nU");
#line 175
        opj_tgt_destroy(p_tree);
        }
#line 176
        return ((opj_tgt_tree_t *)0);
      }
      {
#line 178
      p_tree->nodes = new_nodes;
#line 179
      memset((void *)((char *)p_tree->nodes + p_tree->nodes_size), 0, (unsigned long )(l_node_size - p_tree->nodes_size));
#line 180
      p_tree->nodes_size = l_node_size;
      }
    }
#line 182
    l_node = p_tree->nodes;
#line 183
    l_parent_node = p_tree->nodes + p_tree->numleafsh * p_tree->numleafsv;
#line 184
    l_parent_node0 = l_parent_node;
#line 186
    i = (OPJ_UINT32 )0;
    {
#line 186
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 186
      if (! (i < l_num_levels - 1U)) {
#line 186
        goto while_break___0;
      }
#line 187
      j = 0;
      {
#line 187
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 187
        if (! (j < l_nplv[i])) {
#line 187
          goto while_break___1;
        }
#line 188
        k = l_nplh[i];
        {
#line 189
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 189
          k --;
#line 189
          if (! (k >= 0)) {
#line 189
            goto while_break___2;
          }
#line 190
          l_node->parent = l_parent_node;
#line 191
          l_node ++;
#line 192
          k --;
#line 192
          if (k >= 0) {
#line 193
            l_node->parent = l_parent_node;
#line 194
            l_node ++;
          }
#line 196
          l_parent_node ++;
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___2: ;
#line 198
        if (j & 1) {
#line 200
          l_parent_node0 = l_parent_node;
        } else
#line 198
        if (j == l_nplv[i] - 1) {
#line 200
          l_parent_node0 = l_parent_node;
        } else {
#line 204
          l_parent_node = l_parent_node0;
#line 205
          l_parent_node0 += l_nplh[i];
        }
#line 187
        j ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: 
#line 186
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
#line 209
    l_node->parent = (struct opj_tgt_node *)0;
  } else
#line 146
  if (p_tree->numleafsv != p_num_leafs_v) {
#line 146
    goto _L;
  }
  {
#line 211
  opj_tgt_reset(p_tree);
  }
#line 213
  return (p_tree);
}
}
#line 216 "/root/patron/new_22/src/lib/openjp2/tgt.c"
void opj_tgt_destroy(opj_tgt_tree_t *p_tree ) 
{ 


  {
#line 218
  if (! p_tree) {
#line 219
    return;
  }
#line 222
  if (p_tree->nodes) {
    {
#line 223
    free((void *)p_tree->nodes);
#line 224
    p_tree->nodes = (opj_tgt_node_t *)0;
    }
  }
  {
#line 226
  free((void *)p_tree);
  }
#line 228
  return;
}
}
#line 229 "/root/patron/new_22/src/lib/openjp2/tgt.c"
void opj_tgt_reset(opj_tgt_tree_t *p_tree ) 
{ 
  OPJ_UINT32 i ;
  opj_tgt_node_t *l_current_node ;

  {
#line 231
  l_current_node = (opj_tgt_node_t *)0;
#line 233
  if (! p_tree) {
#line 234
    return;
  }
#line 237
  l_current_node = p_tree->nodes;
#line 238
  i = (OPJ_UINT32 )0;
  {
#line 238
  while (1) {
    while_continue: /* CIL Label */ ;

#line 238
    if (! (i < p_tree->numnodes)) {
#line 238
      goto while_break;
    }
#line 240
    l_current_node->value = 999;
#line 241
    l_current_node->low = 0;
#line 242
    l_current_node->known = (OPJ_UINT32 )0;
#line 243
    l_current_node ++;
#line 238
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 242
  return;
}
}
#line 247 "/root/patron/new_22/src/lib/openjp2/tgt.c"
void opj_tgt_setvalue(opj_tgt_tree_t *tree , OPJ_UINT32 leafno , OPJ_INT32 value ) 
{ 
  opj_tgt_node_t *node ;

  {
#line 249
  node = tree->nodes + leafno;
  {
#line 250
  while (1) {
    while_continue: /* CIL Label */ ;

#line 250
    if (node) {
#line 250
      if (! (node->value > value)) {
#line 250
        goto while_break;
      }
    } else {
#line 250
      goto while_break;
    }
#line 251
    node->value = value;
#line 252
    node = node->parent;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 256
  return;
}
}
#line 256 "/root/patron/new_22/src/lib/openjp2/tgt.c"
void opj_tgt_encode(opj_bio_t *bio , opj_tgt_tree_t *tree , OPJ_UINT32 leafno , OPJ_INT32 threshold ) 
{ 
  opj_tgt_node_t *stk[31] ;
  opj_tgt_node_t **stkptr ;
  opj_tgt_node_t *node ;
  OPJ_INT32 low ;
  opj_tgt_node_t **__cil_tmp9 ;

  {
#line 262
  stkptr = stk;
#line 263
  node = tree->nodes + leafno;
  {
#line 264
  while (1) {
    while_continue: /* CIL Label */ ;

#line 264
    if (! node->parent) {
#line 264
      goto while_break;
    }
#line 265
    __cil_tmp9 = stkptr;
#line 265
    stkptr ++;
#line 265
    *__cil_tmp9 = node;
#line 266
    node = node->parent;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
#line 269
  low = 0;
  {
#line 270
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 271
    if (low > node->low) {
#line 272
      node->low = low;
    } else {
#line 274
      low = node->low;
    }
    {
#line 277
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 277
      if (! (low < threshold)) {
#line 277
        goto while_break___1;
      }
#line 278
      if (low >= node->value) {
#line 279
        if (! node->known) {
          {
#line 280
          opj_bio_write(bio, (OPJ_UINT32 )1, (OPJ_UINT32 )1);
#line 281
          node->known = (OPJ_UINT32 )1;
          }
        }
#line 283
        goto while_break___1;
      }
      {
#line 285
      opj_bio_write(bio, (OPJ_UINT32 )0, (OPJ_UINT32 )1);
#line 286
      low ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: 
#line 289
    node->low = low;
#line 290
    if ((unsigned long )stkptr == (unsigned long )(stk)) {
#line 291
      goto while_break___0;
    }
#line 292
    stkptr --;
#line 292
    node = *stkptr;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: ;
#line 296
  return;
}
}
#line 296 "/root/patron/new_22/src/lib/openjp2/tgt.c"
OPJ_UINT32 opj_tgt_decode(opj_bio_t *bio , opj_tgt_tree_t *tree , OPJ_UINT32 leafno ,
                          OPJ_INT32 threshold ) 
{ 
  opj_tgt_node_t *stk[31] ;
  opj_tgt_node_t **stkptr ;
  opj_tgt_node_t *node ;
  OPJ_INT32 low ;
  opj_tgt_node_t **__cil_tmp9 ;
  OPJ_UINT32 __cil_tmp10 ;
  int tmp ;

  {
#line 302
  stkptr = stk;
#line 303
  node = tree->nodes + leafno;
  {
#line 304
  while (1) {
    while_continue: /* CIL Label */ ;

#line 304
    if (! node->parent) {
#line 304
      goto while_break;
    }
#line 305
    __cil_tmp9 = stkptr;
#line 305
    stkptr ++;
#line 305
    *__cil_tmp9 = node;
#line 306
    node = node->parent;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
#line 309
  low = 0;
  {
#line 310
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 311
    if (low > node->low) {
#line 312
      node->low = low;
    } else {
#line 314
      low = node->low;
    }
    {
#line 316
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 316
      if (low < threshold) {
#line 316
        if (! (low < node->value)) {
#line 316
          goto while_break___1;
        }
      } else {
#line 316
        goto while_break___1;
      }
      {
#line 317
      __cil_tmp10 = opj_bio_read(bio, (OPJ_UINT32 )1);
      }
#line 317
      if (__cil_tmp10) {
#line 318
        node->value = low;
      } else {
#line 320
        low ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: 
#line 323
    node->low = low;
#line 324
    if ((unsigned long )stkptr == (unsigned long )(stk)) {
#line 325
      goto while_break___0;
    }
#line 327
    stkptr --;
#line 327
    node = *stkptr;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: ;
#line 330
  if (node->value < threshold) {
#line 330
    tmp = 1;
  } else {
#line 330
    tmp = 0;
  }
#line 330
  return ((OPJ_UINT32 )tmp);
}
}
#line 103 "/root/patron/new_22/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_code_block_dec_allocate(opj_tcd_cblk_dec_t *p_code_block ) ;
#line 108
void opj_tcd_code_block_dec_deallocate(opj_tcd_precinct_t *p_precinct ) ;
#line 113
OPJ_BOOL opj_tcd_code_block_enc_allocate(opj_tcd_cblk_enc_t *p_code_block ) ;
#line 118
void opj_tcd_code_block_enc_deallocate(opj_tcd_precinct_t *p_precinct ) ;
#line 125
void opj_tcd_free_tile(opj_tcd_t *p_tcd ) ;
#line 128
OPJ_BOOL opj_tcd_t2_decode(opj_tcd_t *p_tcd , OPJ_BYTE *p_src_data , OPJ_UINT32 *p_data_read ,
                           OPJ_UINT32 p_max_src_size , opj_codestream_index_t *p_cstr_index ) ;
#line 134
OPJ_BOOL opj_tcd_t1_decode(opj_tcd_t *p_tcd ) ;
#line 136
OPJ_BOOL opj_tcd_dwt_decode(opj_tcd_t *p_tcd ) ;
#line 138
OPJ_BOOL opj_tcd_mct_decode(opj_tcd_t *p_tcd ) ;
#line 140
OPJ_BOOL opj_tcd_dc_level_shift_decode(opj_tcd_t *p_tcd ) ;
#line 143
OPJ_BOOL opj_tcd_dc_level_shift_encode(opj_tcd_t *p_tcd ) ;
#line 145
OPJ_BOOL opj_tcd_mct_encode(opj_tcd_t *p_tcd ) ;
#line 147
OPJ_BOOL opj_tcd_dwt_encode(opj_tcd_t *p_tcd ) ;
#line 149
OPJ_BOOL opj_tcd_t1_encode(opj_tcd_t *p_tcd ) ;
#line 151
OPJ_BOOL opj_tcd_t2_encode(opj_tcd_t *p_tcd , OPJ_BYTE *p_dest_data , OPJ_UINT32 *p_data_written ,
                           OPJ_UINT32 p_max_dest_size , opj_codestream_info_t *p_cstr_info ) ;
#line 157
OPJ_BOOL opj_tcd_rate_allocate_encode(opj_tcd_t *p_tcd , OPJ_BYTE *p_dest_data , OPJ_UINT32 p_max_dest_size ,
                                      opj_codestream_info_t *p_cstr_info ) ;
#line 167 "/root/patron/new_22/src/lib/openjp2/tcd.c"
opj_tcd_t *opj_tcd_create(OPJ_BOOL p_is_decoder ) 
{ 
  opj_tcd_t *l_tcd ;
  void *__cil_tmp3 ;
  int tmp ;
  void *__cil_tmp5 ;

  {
  {
#line 169
  l_tcd = (opj_tcd_t *)0;
#line 172
  __cil_tmp3 = malloc(sizeof(opj_tcd_t ));
#line 172
  l_tcd = (opj_tcd_t *)__cil_tmp3;
  }
#line 173
  if (! l_tcd) {
#line 174
    return ((opj_tcd_t *)0);
  }
  {
#line 176
  memset((void *)l_tcd, 0, sizeof(opj_tcd_t ));
  }
#line 178
  if (p_is_decoder) {
#line 178
    tmp = 1;
  } else {
#line 178
    tmp = 0;
  }
  {
#line 178
  l_tcd->m_is_decoder = (OPJ_UINT32 )tmp;
#line 180
  __cil_tmp5 = malloc(sizeof(opj_tcd_image_t ));
#line 180
  l_tcd->tcd_image = (opj_tcd_image_t *)__cil_tmp5;
  }
#line 181
  if (! l_tcd->tcd_image) {
    {
#line 182
    free((void *)l_tcd);
    }
#line 183
    return ((opj_tcd_t *)0);
  }
  {
#line 185
  memset((void *)l_tcd->tcd_image, 0, sizeof(opj_tcd_image_t ));
  }
#line 187
  return (l_tcd);
}
}
#line 193 "/root/patron/new_22/src/lib/openjp2/tcd.c"
void opj_tcd_rateallocate_fixed(opj_tcd_t *tcd ) 
{ 
  OPJ_UINT32 layno ;

  {
#line 196
  layno = (OPJ_UINT32 )0;
  {
#line 196
  while (1) {
    while_continue: /* CIL Label */ ;

#line 196
    if (! (layno < (tcd->tcp)->numlayers)) {
#line 196
      goto while_break;
    }
    {
#line 197
    opj_tcd_makelayer_fixed(tcd, layno, (OPJ_UINT32 )1);
#line 196
    layno ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 200
  return;
}
}
#line 202 "/root/patron/new_22/src/lib/openjp2/tcd.c"
void opj_tcd_makelayer(opj_tcd_t *tcd , OPJ_UINT32 layno , OPJ_FLOAT64 thresh , OPJ_UINT32 final ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 bandno ;
  OPJ_UINT32 precno ;
  OPJ_UINT32 cblkno ;
  OPJ_UINT32 passno ;
  opj_tcd_tile_t *tcd_tile ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *prc ;
  opj_tcd_cblk_enc_t *cblk ;
  opj_tcd_layer_t *layer ;
  OPJ_UINT32 n ;
  OPJ_UINT32 dr ;
  OPJ_FLOAT64 dd ;
  opj_tcd_pass_t *pass ;

  {
#line 210
  tcd_tile = (tcd->tcd_image)->tiles;
#line 212
  tcd_tile->distolayer[layno] = (OPJ_FLOAT64 )0;
#line 214
  compno = (OPJ_UINT32 )0;
  {
#line 214
  while (1) {
    while_continue: /* CIL Label */ ;

#line 214
    if (! (compno < tcd_tile->numcomps)) {
#line 214
      goto while_break;
    }
#line 215
    tilec = tcd_tile->comps + compno;
#line 217
    resno = (OPJ_UINT32 )0;
    {
#line 217
    while (1) {
      while_continue___5: /* CIL Label */ ;

#line 217
      if (! (resno < tilec->numresolutions)) {
#line 217
        goto while_break___0;
      }
#line 218
      res = tilec->resolutions + resno;
#line 220
      bandno = (OPJ_UINT32 )0;
      {
#line 220
      while (1) {
        while_continue___6: /* CIL Label */ ;

#line 220
        if (! (bandno < res->numbands)) {
#line 220
          goto while_break___1;
        }
#line 221
        band = & res->bands[bandno];
#line 223
        precno = (OPJ_UINT32 )0;
        {
#line 223
        while (1) {
          while_continue___7: /* CIL Label */ ;

#line 223
          if (! (precno < res->pw * res->ph)) {
#line 223
            goto while_break___2;
          }
#line 224
          prc = band->precincts + precno;
#line 226
          cblkno = (OPJ_UINT32 )0;
          {
#line 226
          while (1) {
            while_continue___8: /* CIL Label */ ;
            while_continue___3: ;
#line 226
            if (! (cblkno < prc->cw * prc->ch)) {
#line 226
              goto while_break___3;
            }
#line 227
            cblk = prc->cblks.enc + cblkno;
#line 228
            layer = cblk->layers + layno;
#line 231
            if (layno == 0U) {
#line 232
              cblk->numpassesinlayers = (OPJ_UINT32 )0;
            }
#line 235
            n = cblk->numpassesinlayers;
#line 237
            passno = cblk->numpassesinlayers;
            {
#line 237
            while (1) {
              while_continue___9: /* CIL Label */ ;
              while_continue___4: ;
#line 237
              if (! (passno < cblk->totalpasses)) {
#line 237
                goto while_break___4;
              }
#line 240
              pass = cblk->passes + passno;
#line 242
              if (n == 0U) {
#line 243
                dr = pass->rate;
#line 244
                dd = pass->distortiondec;
              } else {
#line 246
                dr = pass->rate - (cblk->passes + (n - 1U))->rate;
#line 247
                dd = pass->distortiondec - (cblk->passes + (n - 1U))->distortiondec;
              }
#line 250
              if (! dr) {
#line 251
                if (dd != (double )0) {
#line 252
                  n = passno + 1U;
                }
#line 253
                goto while_continue___4;
              }
#line 255
              if (dd / (double )dr >= thresh) {
#line 256
                n = passno + 1U;
              }
#line 237
              passno ++;
            }
            while_break___10: /* CIL Label */ ;
            }
            while_break___4: 
#line 259
            layer->numpasses = n - cblk->numpassesinlayers;
#line 261
            if (! layer->numpasses) {
#line 262
              layer->disto = (OPJ_FLOAT64 )0;
#line 263
              goto while_continue___3;
            }
#line 266
            if (cblk->numpassesinlayers == 0U) {
#line 267
              layer->len = (cblk->passes + (n - 1U))->rate;
#line 268
              layer->data = cblk->data;
#line 269
              layer->disto = (cblk->passes + (n - 1U))->distortiondec;
            } else {
#line 271
              layer->len = (cblk->passes + (n - 1U))->rate - (cblk->passes + (cblk->numpassesinlayers - 1U))->rate;
#line 272
              layer->data = cblk->data + (cblk->passes + (cblk->numpassesinlayers - 1U))->rate;
#line 273
              layer->disto = (cblk->passes + (n - 1U))->distortiondec - (cblk->passes + (cblk->numpassesinlayers - 1U))->distortiondec;
            }
#line 276
            tcd_tile->distolayer[layno] += layer->disto;
#line 278
            if (final) {
#line 279
              cblk->numpassesinlayers = n;
            }
#line 226
            cblkno ++;
          }
          while_break___9: /* CIL Label */ ;
          }
          while_break___3: 
#line 223
          precno ++;
        }
        while_break___8: /* CIL Label */ ;
        }
        while_break___2: 
#line 220
        bandno ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___1: 
#line 217
      resno ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___0: 
#line 214
    compno ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: ;
#line 218
  return;
}
}
#line 287 "/root/patron/new_22/src/lib/openjp2/tcd.c"
void opj_tcd_makelayer_fixed(opj_tcd_t *tcd , OPJ_UINT32 layno , OPJ_UINT32 final ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 bandno ;
  OPJ_UINT32 precno ;
  OPJ_UINT32 cblkno ;
  OPJ_INT32 value ;
  OPJ_INT32 matrice[10][10][3] ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  opj_cp_t *cp ;
  opj_tcd_tile_t *tcd_tile ;
  opj_tcp_t *tcd_tcp ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *prc ;
  opj_tcd_cblk_enc_t *cblk ;
  opj_tcd_layer_t *layer ;
  OPJ_UINT32 n ;
  OPJ_INT32 imsb ;

  {
#line 293
  cp = tcd->cp;
#line 294
  tcd_tile = (tcd->tcd_image)->tiles;
#line 295
  tcd_tcp = tcd->tcp;
#line 297
  compno = (OPJ_UINT32 )0;
  {
#line 297
  while (1) {
    while_continue: /* CIL Label */ ;

#line 297
    if (! (compno < tcd_tile->numcomps)) {
#line 297
      goto while_break;
    }
#line 298
    tilec = tcd_tile->comps + compno;
#line 300
    i = (OPJ_UINT32 )0;
    {
#line 300
    while (1) {
      while_continue___7: /* CIL Label */ ;

#line 300
      if (! (i < tcd_tcp->numlayers)) {
#line 300
        goto while_break___0;
      }
#line 301
      j = (OPJ_UINT32 )0;
      {
#line 301
      while (1) {
        while_continue___8: /* CIL Label */ ;

#line 301
        if (! (j < tilec->numresolutions)) {
#line 301
          goto while_break___1;
        }
#line 302
        k = (OPJ_UINT32 )0;
        {
#line 302
        while (1) {
          while_continue___9: /* CIL Label */ ;

#line 302
          if (! (k < 3U)) {
#line 302
            goto while_break___2;
          }
#line 303
          matrice[i][j][k] = (OPJ_INT32 )((float )*(cp->m_specific_param.m_enc.m_matrice + (((i * tilec->numresolutions) * 3U + j * 3U) + k)) * (OPJ_FLOAT32 )((double )((tcd->image)->comps + compno)->prec / 16.));
#line 302
          k ++;
        }
        while_break___10: /* CIL Label */ ;
        }
        while_break___2: 
#line 301
        j ++;
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___1: 
#line 300
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___0: 
#line 310
    resno = (OPJ_UINT32 )0;
    {
#line 310
    while (1) {
      while_continue___10: /* CIL Label */ ;

#line 310
      if (! (resno < tilec->numresolutions)) {
#line 310
        goto while_break___3;
      }
#line 311
      res = tilec->resolutions + resno;
#line 313
      bandno = (OPJ_UINT32 )0;
      {
#line 313
      while (1) {
        while_continue___11: /* CIL Label */ ;

#line 313
        if (! (bandno < res->numbands)) {
#line 313
          goto while_break___4;
        }
#line 314
        band = & res->bands[bandno];
#line 316
        precno = (OPJ_UINT32 )0;
        {
#line 316
        while (1) {
          while_continue___12: /* CIL Label */ ;

#line 316
          if (! (precno < res->pw * res->ph)) {
#line 316
            goto while_break___5;
          }
#line 317
          prc = band->precincts + precno;
#line 319
          cblkno = (OPJ_UINT32 )0;
          {
#line 319
          while (1) {
            while_continue___13: /* CIL Label */ ;
            while_continue___6: ;
#line 319
            if (! (cblkno < prc->cw * prc->ch)) {
#line 319
              goto while_break___6;
            }
#line 320
            cblk = prc->cblks.enc + cblkno;
#line 321
            layer = cblk->layers + layno;
#line 323
            imsb = (OPJ_INT32 )(((tcd->image)->comps + compno)->prec - cblk->numbps);
#line 326
            if (layno == 0U) {
#line 327
              value = matrice[layno][resno][bandno];
#line 328
              if (imsb >= value) {
#line 329
                value = 0;
              } else {
#line 331
                value -= imsb;
              }
            } else {
#line 334
              value = matrice[layno][resno][bandno] - matrice[layno - 1U][resno][bandno];
#line 335
              if (imsb >= matrice[layno - 1U][resno][bandno]) {
#line 336
                value -= imsb - matrice[layno - 1U][resno][bandno];
#line 337
                if (value < 0) {
#line 338
                  value = 0;
                }
              }
            }
#line 343
            if (layno == 0U) {
#line 344
              cblk->numpassesinlayers = (OPJ_UINT32 )0;
            }
#line 347
            n = cblk->numpassesinlayers;
#line 348
            if (cblk->numpassesinlayers == 0U) {
#line 349
              if (value != 0) {
#line 350
                n = (unsigned int )(3 * value - 2) + cblk->numpassesinlayers;
              } else {
#line 352
                n = cblk->numpassesinlayers;
              }
            } else {
#line 355
              n = (unsigned int )(3 * value) + cblk->numpassesinlayers;
            }
#line 358
            layer->numpasses = n - cblk->numpassesinlayers;
#line 360
            if (! layer->numpasses) {
#line 361
              goto while_continue___6;
            }
#line 363
            if (cblk->numpassesinlayers == 0U) {
#line 364
              layer->len = (cblk->passes + (n - 1U))->rate;
#line 365
              layer->data = cblk->data;
            } else {
#line 367
              layer->len = (cblk->passes + (n - 1U))->rate - (cblk->passes + (cblk->numpassesinlayers - 1U))->rate;
#line 368
              layer->data = cblk->data + (cblk->passes + (cblk->numpassesinlayers - 1U))->rate;
            }
#line 371
            if (final) {
#line 372
              cblk->numpassesinlayers = n;
            }
#line 319
            cblkno ++;
          }
          while_break___14: /* CIL Label */ ;
          }
          while_break___6: 
#line 316
          precno ++;
        }
        while_break___13: /* CIL Label */ ;
        }
        while_break___5: 
#line 313
        bandno ++;
      }
      while_break___12: /* CIL Label */ ;
      }
      while_break___4: 
#line 310
      resno ++;
    }
    while_break___11: /* CIL Label */ ;
    }
    while_break___3: 
#line 297
    compno ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break: ;
#line 301
  return;
}
}
#line 380 "/root/patron/new_22/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_rateallocate(opj_tcd_t *tcd , OPJ_BYTE *dest , OPJ_UINT32 *p_data_written ,
                              OPJ_UINT32 len , opj_codestream_info_t *cstr_info ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 bandno ;
  OPJ_UINT32 precno ;
  OPJ_UINT32 cblkno ;
  OPJ_UINT32 layno ;
  OPJ_UINT32 passno ;
  OPJ_FLOAT64 min ;
  OPJ_FLOAT64 max ;
  OPJ_FLOAT64 cumdisto[100] ;
  OPJ_FLOAT64 K ;
  OPJ_FLOAT64 maxSE ;
  opj_cp_t *cp ;
  opj_tcd_tile_t *tcd_tile ;
  opj_tcp_t *tcd_tcp ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *prc ;
  opj_tcd_cblk_enc_t *cblk ;
  opj_tcd_pass_t *pass ;
  OPJ_INT32 dr ;
  OPJ_FLOAT64 dd ;
  OPJ_FLOAT64 rdslope ;
  opj_tile_info_t *tile_info ;
  void *__cil_tmp37 ;
  OPJ_FLOAT64 lo ;
  OPJ_FLOAT64 hi ;
  OPJ_BOOL success ;
  OPJ_UINT32 maxlen ;
  double __cil_tmp42 ;
  OPJ_UINT32 __cil_tmp43 ;
  OPJ_UINT32 tmp ;
  OPJ_FLOAT64 goodthresh ;
  OPJ_FLOAT64 stable_thresh ;
  OPJ_UINT32 i ;
  OPJ_FLOAT64 distotarget ;
  double __cil_tmp49 ;
  opj_t2_t *t2 ;
  opj_t2_t *__cil_tmp51 ;
  OPJ_FLOAT64 thresh ;
  OPJ_FLOAT64 distoachieved ;
  OPJ_BOOL __cil_tmp54 ;
  OPJ_FLOAT64 tmp___0 ;
  OPJ_FLOAT64 tmp___1 ;
  OPJ_BOOL __cil_tmp57 ;
  OPJ_FLOAT64 tmp___2 ;
  OPJ_FLOAT64 tmp___3 ;

  {
#line 390
  K = (OPJ_FLOAT64 )1;
#line 391
  maxSE = (OPJ_FLOAT64 )0;
#line 393
  cp = tcd->cp;
#line 394
  tcd_tile = (tcd->tcd_image)->tiles;
#line 395
  tcd_tcp = tcd->tcp;
#line 397
  min = (double )1.79769313487e+308L;
#line 398
  max = (OPJ_FLOAT64 )0;
#line 400
  tcd_tile->numpix = 0;
#line 402
  compno = (OPJ_UINT32 )0;
  {
#line 402
  while (1) {
    while_continue: /* CIL Label */ ;

#line 402
    if (! (compno < tcd_tile->numcomps)) {
#line 402
      goto while_break;
    }
#line 403
    tilec = tcd_tile->comps + compno;
#line 404
    tilec->numpix = 0;
#line 406
    resno = (OPJ_UINT32 )0;
    {
#line 406
    while (1) {
      while_continue___7: /* CIL Label */ ;

#line 406
      if (! (resno < tilec->numresolutions)) {
#line 406
        goto while_break___0;
      }
#line 407
      res = tilec->resolutions + resno;
#line 409
      bandno = (OPJ_UINT32 )0;
      {
#line 409
      while (1) {
        while_continue___8: /* CIL Label */ ;

#line 409
        if (! (bandno < res->numbands)) {
#line 409
          goto while_break___1;
        }
#line 410
        band = & res->bands[bandno];
#line 412
        precno = (OPJ_UINT32 )0;
        {
#line 412
        while (1) {
          while_continue___9: /* CIL Label */ ;

#line 412
          if (! (precno < res->pw * res->ph)) {
#line 412
            goto while_break___2;
          }
#line 413
          prc = band->precincts + precno;
#line 415
          cblkno = (OPJ_UINT32 )0;
          {
#line 415
          while (1) {
            while_continue___10: /* CIL Label */ ;

#line 415
            if (! (cblkno < prc->cw * prc->ch)) {
#line 415
              goto while_break___3;
            }
#line 416
            cblk = prc->cblks.enc + cblkno;
#line 418
            passno = (OPJ_UINT32 )0;
            {
#line 418
            while (1) {
              while_continue___11: /* CIL Label */ ;
              while_continue___4: ;
#line 418
              if (! (passno < cblk->totalpasses)) {
#line 418
                goto while_break___4;
              }
#line 419
              pass = cblk->passes + passno;
#line 423
              if (passno == 0U) {
#line 424
                dr = (OPJ_INT32 )pass->rate;
#line 425
                dd = pass->distortiondec;
              } else {
#line 427
                dr = (OPJ_INT32 )(pass->rate - (cblk->passes + (passno - 1U))->rate);
#line 428
                dd = pass->distortiondec - (cblk->passes + (passno - 1U))->distortiondec;
              }
#line 431
              if (dr == 0) {
#line 432
                goto while_continue___4;
              }
#line 435
              rdslope = dd / (double )dr;
#line 436
              if (rdslope < min) {
#line 437
                min = rdslope;
              }
#line 440
              if (rdslope > max) {
#line 441
                max = rdslope;
              }
#line 418
              passno ++;
            }
            while_break___12: /* CIL Label */ ;
            }
            while_break___4: 
#line 446
            tcd_tile->numpix += (cblk->x1 - cblk->x0) * (cblk->y1 - cblk->y0);
#line 447
            tilec->numpix += (cblk->x1 - cblk->x0) * (cblk->y1 - cblk->y0);
#line 415
            cblkno ++;
          }
          while_break___11: /* CIL Label */ ;
          }
          while_break___3: 
#line 412
          precno ++;
        }
        while_break___10: /* CIL Label */ ;
        }
        while_break___2: 
#line 409
        bandno ++;
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___1: 
#line 406
      resno ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___0: 
#line 453
    maxSE += (((OPJ_FLOAT64 )(1 << ((tcd->image)->comps + compno)->prec) - 1.) * ((OPJ_FLOAT64 )(1 << ((tcd->image)->comps + compno)->prec) - 1.)) * (OPJ_FLOAT64 )tilec->numpix;
#line 402
    compno ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break: ;
#line 459
  if (cstr_info) {
    {
#line 460
    tile_info = cstr_info->tile + tcd->tcd_tileno;
#line 461
    tile_info->numpix = tcd_tile->numpix;
#line 462
    tile_info->distotile = tcd_tile->distotile;
#line 463
    __cil_tmp37 = malloc((unsigned long )tcd_tcp->numlayers * sizeof(OPJ_FLOAT64 ));
#line 463
    tile_info->thresh = (OPJ_FLOAT64 *)__cil_tmp37;
    }
  }
#line 466
  layno = (OPJ_UINT32 )0;
  {
#line 466
  while (1) {
    while_continue___12: /* CIL Label */ ;

#line 466
    if (! (layno < tcd_tcp->numlayers)) {
#line 466
      goto while_break___5;
    }
#line 467
    lo = min;
#line 468
    hi = max;
#line 469
    success = 0;
#line 470
    if (tcd_tcp->rates[layno]) {
      {
#line 470
      __cil_tmp42 = ceil((double )tcd_tcp->rates[layno]);
#line 470
      __cil_tmp43 = opj_uint_min((OPJ_UINT32 )__cil_tmp42, len);
#line 470
      tmp = __cil_tmp43;
      }
    } else {
#line 470
      tmp = len;
    }
    {
#line 470
    maxlen = tmp;
#line 471
    goodthresh = (OPJ_FLOAT64 )0;
#line 472
    stable_thresh = (OPJ_FLOAT64 )0;
#line 477
    __cil_tmp49 = pow((double )((OPJ_FLOAT32 )10), (double )(tcd_tcp->distoratio[layno] / (float )10));
#line 477
    distotarget = tcd_tile->distotile - (K * maxSE) / __cil_tmp49;
    }
#line 483
    if ((int )cp->m_specific_param.m_enc.m_disto_alloc == 1) {
#line 483
      if (tcd_tcp->rates[layno] > (float )0) {
        _L: 
        {
#line 484
        __cil_tmp51 = opj_t2_create(tcd->image, cp);
#line 484
        t2 = __cil_tmp51;
#line 485
        thresh = (OPJ_FLOAT64 )0;
        }
#line 487
        if ((unsigned long )t2 == (unsigned long )((opj_t2_t *)0)) {
#line 488
          return (0);
        }
#line 491
        i = (OPJ_UINT32 )0;
        {
#line 491
        while (1) {
          while_continue___13: /* CIL Label */ ;
          while_continue___6: ;
#line 491
          if (! (i < 128U)) {
#line 491
            goto while_break___6;
          }
          {
#line 492
          distoachieved = (OPJ_FLOAT64 )0;
#line 494
          thresh = (lo + hi) / (double )2;
#line 496
          opj_tcd_makelayer(tcd, layno, thresh, (OPJ_UINT32 )0);
          }
#line 498
          if (cp->m_specific_param.m_enc.m_fixed_quality) {
#line 499
            if (cp->m_specific_param.m_enc.m_cinema) {
              {
#line 500
              __cil_tmp54 = opj_t2_encode_packets(t2, tcd->tcd_tileno, tcd_tile, layno + 1U,
                                                  dest, p_data_written, maxlen, cstr_info,
                                                  tcd->cur_tp_num, tcd->tp_pos, tcd->cur_pino,
                                                  (J2K_T2_MODE )0);
              }
#line 500
              if (! __cil_tmp54) {
#line 502
                lo = thresh;
#line 503
                goto while_continue___6;
              } else {
#line 506
                if (layno == 0U) {
#line 506
                  tmp___0 = tcd_tile->distolayer[0];
                } else {
#line 506
                  tmp___0 = cumdisto[layno - 1U] + tcd_tile->distolayer[layno];
                }
#line 506
                distoachieved = tmp___0;
#line 509
                if (distoachieved < distotarget) {
#line 510
                  hi = thresh;
#line 511
                  stable_thresh = thresh;
#line 512
                  goto while_continue___6;
                } else {
#line 514
                  lo = thresh;
                }
              }
            } else {
#line 518
              if (layno == 0U) {
#line 518
                tmp___1 = tcd_tile->distolayer[0];
              } else {
#line 518
                tmp___1 = cumdisto[layno - 1U] + tcd_tile->distolayer[layno];
              }
#line 518
              distoachieved = tmp___1;
#line 521
              if (distoachieved < distotarget) {
#line 522
                hi = thresh;
#line 523
                stable_thresh = thresh;
#line 524
                goto while_continue___6;
              }
#line 526
              lo = thresh;
            }
          } else {
            {
#line 529
            __cil_tmp57 = opj_t2_encode_packets(t2, tcd->tcd_tileno, tcd_tile, layno + 1U,
                                                dest, p_data_written, maxlen, cstr_info,
                                                tcd->cur_tp_num, tcd->tp_pos, tcd->cur_pino,
                                                (J2K_T2_MODE )0);
            }
#line 529
            if (! __cil_tmp57) {
#line 533
              lo = thresh;
#line 534
              goto while_continue___6;
            }
#line 537
            hi = thresh;
#line 538
            stable_thresh = thresh;
          }
#line 491
          i ++;
        }
        while_break___14: /* CIL Label */ ;
        }
        while_break___6: 
#line 542
        success = 1;
#line 543
        if (stable_thresh == (double )0) {
#line 543
          tmp___2 = thresh;
        } else {
#line 543
          tmp___2 = stable_thresh;
        }
        {
#line 543
        goodthresh = tmp___2;
#line 545
        opj_t2_destroy(t2);
        }
      } else {
#line 483
        goto _L___0;
      }
    } else
    _L___0: 
#line 483
    if ((int )cp->m_specific_param.m_enc.m_fixed_quality == 1) {
#line 483
      if (tcd_tcp->distoratio[layno] > (float )0) {
#line 483
        goto _L;
      } else {
#line 547
        success = 1;
#line 548
        goodthresh = min;
      }
    } else {
#line 547
      success = 1;
#line 548
      goodthresh = min;
    }
#line 551
    if (! success) {
#line 552
      return (0);
    }
#line 555
    if (cstr_info) {
#line 556
      *((cstr_info->tile + tcd->tcd_tileno)->thresh + layno) = goodthresh;
    }
    {
#line 559
    opj_tcd_makelayer(tcd, layno, goodthresh, (OPJ_UINT32 )1);
    }
#line 562
    if (layno == 0U) {
#line 562
      tmp___3 = tcd_tile->distolayer[0];
    } else {
#line 562
      tmp___3 = cumdisto[layno - 1U] + tcd_tile->distolayer[layno];
    }
#line 562
    cumdisto[layno] = tmp___3;
#line 466
    layno ++;
  }
  while_break___13: /* CIL Label */ ;
  }
  while_break___5: ;
#line 565
  return (1);
}
}
#line 568 "/root/patron/new_22/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_init(opj_tcd_t *p_tcd , opj_image_t *p_image , opj_cp_t *p_cp ) 
{ 
  OPJ_UINT32 l_tile_comp_size ;
  void *__cil_tmp5 ;
  void *__cil_tmp6 ;

  {
  {
#line 574
  p_tcd->image = p_image;
#line 575
  p_tcd->cp = p_cp;
#line 577
  __cil_tmp5 = malloc(sizeof(opj_tcd_tile_t ));
#line 577
  (p_tcd->tcd_image)->tiles = (opj_tcd_tile_t *)__cil_tmp5;
  }
#line 578
  if (! (p_tcd->tcd_image)->tiles) {
#line 579
    return (0);
  }
  {
#line 581
  memset((void *)(p_tcd->tcd_image)->tiles, 0, sizeof(opj_tcd_tile_t ));
#line 583
  l_tile_comp_size = (OPJ_UINT32 )((unsigned long )p_image->numcomps * sizeof(opj_tcd_tilecomp_t ));
#line 584
  __cil_tmp6 = malloc((unsigned long )l_tile_comp_size);
#line 584
  ((p_tcd->tcd_image)->tiles)->comps = (opj_tcd_tilecomp_t *)__cil_tmp6;
  }
#line 585
  if (! ((p_tcd->tcd_image)->tiles)->comps) {
#line 586
    return (0);
  }
  {
#line 588
  memset((void *)((p_tcd->tcd_image)->tiles)->comps, 0, (unsigned long )l_tile_comp_size);
#line 590
  ((p_tcd->tcd_image)->tiles)->numcomps = p_image->numcomps;
#line 591
  p_tcd->tp_pos = p_cp->m_specific_param.m_enc.m_tp_pos;
  }
#line 593
  return (1);
}
}
#line 599 "/root/patron/new_22/src/lib/openjp2/tcd.c"
void opj_tcd_destroy(opj_tcd_t *tcd ) 
{ 


  {
#line 600
  if (tcd) {
    {
#line 601
    opj_tcd_free_tile(tcd);
    }
#line 603
    if (tcd->tcd_image) {
      {
#line 604
      free((void *)tcd->tcd_image);
#line 605
      tcd->tcd_image = (opj_tcd_image_t *)0;
      }
    }
    {
#line 607
    free((void *)tcd);
    }
  }
#line 610
  return;
}
}
#line 992 "/root/patron/new_22/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_init_encode_tile(opj_tcd_t *p_tcd , OPJ_UINT32 p_tile_no ) 
{ 
  OPJ_UINT32 (*l_gain_ptr)(OPJ_UINT32  ) ;
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 bandno ;
  OPJ_UINT32 precno ;
  OPJ_UINT32 cblkno ;
  opj_tcp_t *l_tcp ;
  opj_cp_t *l_cp ;
  opj_tcd_tile_t *l_tile ;
  opj_tccp_t *l_tccp ;
  opj_tcd_tilecomp_t *l_tilec ;
  opj_image_comp_t *l_image_comp ;
  opj_tcd_resolution_t *l_res ;
  opj_tcd_band_t *l_band ;
  opj_stepsize_t *l_step_size ;
  opj_tcd_precinct_t *l_current_precinct ;
  opj_tcd_cblk_enc_t *l_code_block ;
  opj_image_t *l_image ;
  OPJ_UINT32 p ;
  OPJ_UINT32 q ;
  OPJ_UINT32 l_level_no ;
  OPJ_UINT32 l_pdx ;
  OPJ_UINT32 l_pdy ;
  OPJ_UINT32 l_gain ;
  OPJ_INT32 l_x0b ;
  OPJ_INT32 l_y0b ;
  OPJ_INT32 l_tl_prc_x_start ;
  OPJ_INT32 l_tl_prc_y_start ;
  OPJ_INT32 l_br_prc_x_end ;
  OPJ_INT32 l_br_prc_y_end ;
  OPJ_UINT32 l_nb_precincts ;
  OPJ_UINT32 l_nb_precinct_size ;
  OPJ_UINT32 l_nb_code_blocks ;
  OPJ_UINT32 l_nb_code_blocks_size ;
  OPJ_UINT32 l_data_size ;
  void *__cil_tmp46 ;
  OPJ_INT32 *new_data ;
  void *__cil_tmp48 ;
  void *__cil_tmp49 ;
  opj_tcd_resolution_t *new_resolutions ;
  void *__cil_tmp51 ;
  OPJ_INT32 tlcbgxstart ;
  OPJ_INT32 tlcbgystart ;
  OPJ_UINT32 cbgwidthexpn ;
  OPJ_UINT32 cbgheightexpn ;
  OPJ_UINT32 cblkwidthexpn ;
  OPJ_UINT32 cblkheightexpn ;
  OPJ_INT32 __cil_tmp62 ;
  OPJ_INT32 __cil_tmp63 ;
  OPJ_INT32 __cil_tmp64 ;
  OPJ_INT32 __cil_tmp65 ;
  int tmp ;
  int tmp___0 ;
  OPJ_INT32 numbps ;
  double __cil_tmp82 ;
  void *__cil_tmp83 ;
  opj_tcd_precinct_t *new_precincts ;
  void *__cil_tmp85 ;
  OPJ_INT32 tlcblkxstart ;
  OPJ_INT32 tlcblkystart ;
  OPJ_INT32 brcblkxend ;
  OPJ_INT32 brcblkyend ;
  OPJ_INT32 cbgxstart ;
  OPJ_INT32 cbgystart ;
  OPJ_INT32 cbgxend ;
  OPJ_INT32 cbgyend ;
  OPJ_INT32 __cil_tmp98 ;
  OPJ_INT32 __cil_tmp99 ;
  OPJ_INT32 __cil_tmp100 ;
  OPJ_INT32 __cil_tmp101 ;
  void *__cil_tmp102 ;
  opj_tcd_cblk_enc_t *new_ELEMENT ;
  void *__cil_tmp104 ;
  OPJ_INT32 cblkxstart ;
  OPJ_INT32 cblkystart ;
  OPJ_INT32 cblkxend ;
  OPJ_INT32 cblkyend ;
  OPJ_BOOL __cil_tmp117 ;

  {
  {
#line 992
  l_gain_ptr = (OPJ_UINT32 (*)(OPJ_UINT32  ))0;
#line 992
  l_tcp = (opj_tcp_t *)0;
#line 992
  l_cp = (opj_cp_t *)0;
#line 992
  l_tile = (opj_tcd_tile_t *)0;
#line 992
  l_tccp = (opj_tccp_t *)0;
#line 992
  l_tilec = (opj_tcd_tilecomp_t *)0;
#line 992
  l_image_comp = (opj_image_comp_t *)0;
#line 992
  l_res = (opj_tcd_resolution_t *)0;
#line 992
  l_band = (opj_tcd_band_t *)0;
#line 992
  l_step_size = (opj_stepsize_t *)0;
#line 992
  l_current_precinct = (opj_tcd_precinct_t *)0;
#line 992
  l_code_block = (opj_tcd_cblk_enc_t *)0;
#line 992
  l_image = (opj_image_t *)0;
#line 992
  l_cp = p_tcd->cp;
#line 992
  l_tcp = l_cp->tcps + p_tile_no;
#line 992
  l_tile = (p_tcd->tcd_image)->tiles;
#line 992
  l_tccp = l_tcp->tccps;
#line 992
  l_tilec = l_tile->comps;
#line 992
  l_image = p_tcd->image;
#line 992
  l_image_comp = (p_tcd->image)->comps;
#line 992
  p = p_tile_no % l_cp->tw;
#line 992
  q = p_tile_no / l_cp->tw;
#line 992
  l_tile->x0 = opj_int_max((OPJ_INT32 )(l_cp->tx0 + p * l_cp->tdx), (OPJ_INT32 )l_image->x0);
#line 992
  l_tile->y0 = opj_int_max((OPJ_INT32 )(l_cp->ty0 + q * l_cp->tdy), (OPJ_INT32 )l_image->y0);
#line 992
  l_tile->x1 = opj_int_min((OPJ_INT32 )(l_cp->tx0 + (p + 1U) * l_cp->tdx), (OPJ_INT32 )l_image->x1);
#line 992
  l_tile->y1 = opj_int_min((OPJ_INT32 )(l_cp->ty0 + (q + 1U) * l_cp->tdy), (OPJ_INT32 )l_image->y1);
#line 992
  compno = (OPJ_UINT32 )0;
  }
  {
#line 992
  while (1) {
    while_continue: /* CIL Label */ ;

#line 992
    if (! (compno < l_tile->numcomps)) {
#line 992
      goto while_break;
    }
    {
#line 992
    l_tilec->x0 = opj_int_ceildiv(l_tile->x0, (OPJ_INT32 )l_image_comp->dx);
#line 992
    l_tilec->y0 = opj_int_ceildiv(l_tile->y0, (OPJ_INT32 )l_image_comp->dy);
#line 992
    l_tilec->x1 = opj_int_ceildiv(l_tile->x1, (OPJ_INT32 )l_image_comp->dx);
#line 992
    l_tilec->y1 = opj_int_ceildiv(l_tile->y1, (OPJ_INT32 )l_image_comp->dy);
#line 992
    l_data_size = (OPJ_UINT32 )((unsigned long )((l_tilec->x1 - l_tilec->x0) * (l_tilec->y1 - l_tilec->y0)) * sizeof(OPJ_UINT32 ));
#line 992
    l_tilec->numresolutions = l_tccp->numresolutions;
    }
#line 992
    if (l_tccp->numresolutions < l_cp->m_specific_param.m_dec.m_reduce) {
#line 992
      l_tilec->minimum_num_resolutions = (OPJ_UINT32 )1;
    } else {
#line 992
      l_tilec->minimum_num_resolutions = l_tccp->numresolutions - l_cp->m_specific_param.m_dec.m_reduce;
    }
#line 992
    if ((unsigned long )l_tilec->data == (unsigned long )((OPJ_INT32 *)0)) {
      {
#line 992
      __cil_tmp46 = malloc((unsigned long )l_data_size);
#line 992
      l_tilec->data = (OPJ_INT32 *)__cil_tmp46;
      }
#line 992
      if (! l_tilec->data) {
#line 992
        return (0);
      }
#line 992
      l_tilec->data_size = l_data_size;
    } else
#line 992
    if (l_data_size > l_tilec->data_size) {
      {
#line 992
      __cil_tmp48 = realloc((void *)l_tilec->data, (unsigned long )l_data_size);
#line 992
      new_data = (OPJ_INT32 *)__cil_tmp48;
#line 992
      fprintf(stderr, "Not enough memory to handle tile data\n");
      }
#line 992
      if (! new_data) {
        {
#line 992
        free((void *)l_tilec->data);
#line 992
        l_tilec->data = (OPJ_INT32 *)((void *)0);
#line 992
        l_tilec->data_size = (OPJ_UINT32 )0;
        }
#line 992
        return (0);
      }
#line 992
      l_tilec->data = new_data;
#line 992
      l_tilec->data_size = l_data_size;
    }
#line 992
    l_data_size = (OPJ_UINT32 )((unsigned long )l_tilec->numresolutions * sizeof(opj_tcd_resolution_t ));
#line 992
    if ((unsigned long )l_tilec->resolutions == (unsigned long )((opj_tcd_resolution_t *)0)) {
      {
#line 992
      __cil_tmp49 = malloc((unsigned long )l_data_size);
#line 992
      l_tilec->resolutions = (opj_tcd_resolution_t *)__cil_tmp49;
      }
#line 992
      if (! l_tilec->resolutions) {
#line 992
        return (0);
      }
      {
#line 992
      l_tilec->resolutions_size = l_data_size;
#line 992
      memset((void *)l_tilec->resolutions, 0, (unsigned long )l_data_size);
      }
    } else
#line 992
    if (l_data_size > l_tilec->resolutions_size) {
      {
#line 992
      __cil_tmp51 = realloc((void *)l_tilec->resolutions, (unsigned long )l_data_size);
#line 992
      new_resolutions = (opj_tcd_resolution_t *)__cil_tmp51;
      }
#line 992
      if (! new_resolutions) {
        {
#line 992
        fprintf(stderr, "Not enough memory to tile resolutions\n");
#line 992
        free((void *)l_tilec->resolutions);
#line 992
        l_tilec->resolutions = (opj_tcd_resolution_t *)((void *)0);
#line 992
        l_tilec->resolutions_size = (OPJ_UINT32 )0;
        }
#line 992
        return (0);
      }
      {
#line 992
      l_tilec->resolutions = new_resolutions;
#line 992
      memset((void *)((OPJ_BYTE *)l_tilec->resolutions + l_tilec->resolutions_size),
             0, (unsigned long )(l_data_size - l_tilec->resolutions_size));
#line 992
      l_tilec->resolutions_size = l_data_size;
      }
    }
#line 992
    l_level_no = l_tilec->numresolutions - 1U;
#line 992
    l_res = l_tilec->resolutions;
#line 992
    l_step_size = l_tccp->stepsizes;
#line 992
    if (l_tccp->qmfbid == 0U) {
#line 992
      l_gain_ptr = & opj_dwt_getgain_real;
    } else {
#line 992
      l_gain_ptr = & opj_dwt_getgain;
    }
#line 992
    resno = (OPJ_UINT32 )0;
    {
#line 992
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 992
      if (! (resno < l_tilec->numresolutions)) {
#line 992
        goto while_break___0;
      }
      {
#line 992
      l_res->x0 = opj_int_ceildivpow2(l_tilec->x0, (OPJ_INT32 )l_level_no);
#line 992
      l_res->y0 = opj_int_ceildivpow2(l_tilec->y0, (OPJ_INT32 )l_level_no);
#line 992
      l_res->x1 = opj_int_ceildivpow2(l_tilec->x1, (OPJ_INT32 )l_level_no);
#line 992
      l_res->y1 = opj_int_ceildivpow2(l_tilec->y1, (OPJ_INT32 )l_level_no);
#line 992
      l_pdx = l_tccp->prcw[resno];
#line 992
      l_pdy = l_tccp->prch[resno];
#line 992
      __cil_tmp62 = opj_int_floordivpow2(l_res->x0, (OPJ_INT32 )l_pdx);
#line 992
      l_tl_prc_x_start = __cil_tmp62 << l_pdx;
#line 992
      __cil_tmp63 = opj_int_floordivpow2(l_res->y0, (OPJ_INT32 )l_pdy);
#line 992
      l_tl_prc_y_start = __cil_tmp63 << l_pdy;
#line 992
      __cil_tmp64 = opj_int_ceildivpow2(l_res->x1, (OPJ_INT32 )l_pdx);
#line 992
      l_br_prc_x_end = __cil_tmp64 << l_pdx;
#line 992
      __cil_tmp65 = opj_int_ceildivpow2(l_res->y1, (OPJ_INT32 )l_pdy);
#line 992
      l_br_prc_y_end = __cil_tmp65 << l_pdy;
      }
#line 992
      if (l_res->x0 == l_res->x1) {
#line 992
        tmp = 0;
      } else {
#line 992
        tmp = (l_br_prc_x_end - l_tl_prc_x_start) >> l_pdx;
      }
#line 992
      l_res->pw = (OPJ_UINT32 )tmp;
#line 992
      if (l_res->y0 == l_res->y1) {
#line 992
        tmp___0 = 0;
      } else {
#line 992
        tmp___0 = (l_br_prc_y_end - l_tl_prc_y_start) >> l_pdy;
      }
#line 992
      l_res->ph = (OPJ_UINT32 )tmp___0;
#line 992
      l_nb_precincts = l_res->pw * l_res->ph;
#line 992
      l_nb_precinct_size = (OPJ_UINT32 )((unsigned long )l_nb_precincts * sizeof(opj_tcd_precinct_t ));
#line 992
      if (resno == 0U) {
#line 992
        tlcbgxstart = l_tl_prc_x_start;
#line 992
        tlcbgystart = l_tl_prc_y_start;
#line 992
        cbgwidthexpn = l_pdx;
#line 992
        cbgheightexpn = l_pdy;
#line 992
        l_res->numbands = (OPJ_UINT32 )1;
      } else {
        {
#line 992
        tlcbgxstart = opj_int_ceildivpow2(l_tl_prc_x_start, 1);
#line 992
        tlcbgystart = opj_int_ceildivpow2(l_tl_prc_y_start, 1);
#line 992
        cbgwidthexpn = l_pdx - 1U;
#line 992
        cbgheightexpn = l_pdy - 1U;
#line 992
        l_res->numbands = (OPJ_UINT32 )3;
        }
      }
      {
#line 992
      cblkwidthexpn = opj_uint_min(l_tccp->cblkw, cbgwidthexpn);
#line 992
      cblkheightexpn = opj_uint_min(l_tccp->cblkh, cbgheightexpn);
#line 992
      l_band = l_res->bands;
#line 992
      bandno = (OPJ_UINT32 )0;
      }
      {
#line 992
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 992
        if (! (bandno < l_res->numbands)) {
#line 992
          goto while_break___1;
        }
#line 992
        if (resno == 0U) {
          {
#line 992
          l_band->bandno = (OPJ_UINT32 )0;
#line 992
          l_band->x0 = opj_int_ceildivpow2(l_tilec->x0, (OPJ_INT32 )l_level_no);
#line 992
          l_band->y0 = opj_int_ceildivpow2(l_tilec->y0, (OPJ_INT32 )l_level_no);
#line 992
          l_band->x1 = opj_int_ceildivpow2(l_tilec->x1, (OPJ_INT32 )l_level_no);
#line 992
          l_band->y1 = opj_int_ceildivpow2(l_tilec->y1, (OPJ_INT32 )l_level_no);
          }
        } else {
          {
#line 992
          l_band->bandno = bandno + 1U;
#line 992
          l_x0b = (OPJ_INT32 )(l_band->bandno & 1U);
#line 992
          l_y0b = (OPJ_INT32 )(l_band->bandno >> 1);
#line 992
          l_band->x0 = opj_int_ceildivpow2(l_tilec->x0 - (1 << l_level_no) * l_x0b,
                                           (OPJ_INT32 )(l_level_no + 1U));
#line 992
          l_band->y0 = opj_int_ceildivpow2(l_tilec->y0 - (1 << l_level_no) * l_y0b,
                                           (OPJ_INT32 )(l_level_no + 1U));
#line 992
          l_band->x1 = opj_int_ceildivpow2(l_tilec->x1 - (1 << l_level_no) * l_x0b,
                                           (OPJ_INT32 )(l_level_no + 1U));
#line 992
          l_band->y1 = opj_int_ceildivpow2(l_tilec->y1 - (1 << l_level_no) * l_y0b,
                                           (OPJ_INT32 )(l_level_no + 1U));
          }
        }
        {
#line 992
        l_gain = (*l_gain_ptr)(l_band->bandno);
#line 992
        numbps = (OPJ_INT32 )(l_image_comp->prec + l_gain);
#line 992
        __cil_tmp82 = pow(2., (double )(numbps - l_step_size->expn));
#line 992
        l_band->stepsize = (OPJ_FLOAT32 )((1. + (double )l_step_size->mant / 2048.) * __cil_tmp82) * 1.f;
#line 992
        l_band->numbps = (OPJ_INT32 )(((unsigned int )l_step_size->expn + l_tccp->numgbits) - 1U);
        }
#line 992
        if (! l_band->precincts) {
          {
#line 992
          __cil_tmp83 = malloc((unsigned long )l_nb_precinct_size);
#line 992
          l_band->precincts = (opj_tcd_precinct_t *)__cil_tmp83;
          }
#line 992
          if (! l_band->precincts) {
#line 992
            return (0);
          }
          {
#line 992
          memset((void *)l_band->precincts, 0, (unsigned long )l_nb_precinct_size);
#line 992
          l_band->precincts_data_size = l_nb_precinct_size;
          }
        } else
#line 992
        if (l_band->precincts_data_size < l_nb_precinct_size) {
          {
#line 992
          __cil_tmp85 = realloc((void *)l_band->precincts, (unsigned long )l_nb_precinct_size);
#line 992
          new_precincts = (opj_tcd_precinct_t *)__cil_tmp85;
          }
#line 992
          if (! new_precincts) {
            {
#line 992
            fprintf(stderr, "Not enough memory to handle band precints\n");
#line 992
            free((void *)l_band->precincts);
#line 992
            l_band->precincts = (opj_tcd_precinct_t *)((void *)0);
#line 992
            l_band->precincts_data_size = (OPJ_UINT32 )0;
            }
#line 992
            return (0);
          }
          {
#line 992
          l_band->precincts = new_precincts;
#line 992
          memset((void *)((OPJ_BYTE *)l_band->precincts + l_band->precincts_data_size),
                 0, (unsigned long )(l_nb_precinct_size - l_band->precincts_data_size));
#line 992
          l_band->precincts_data_size = l_nb_precinct_size;
          }
        }
#line 992
        l_current_precinct = l_band->precincts;
#line 992
        precno = (OPJ_UINT32 )0;
        {
#line 992
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 992
          if (! (precno < l_nb_precincts)) {
#line 992
            goto while_break___2;
          }
          {
#line 992
          cbgxstart = (OPJ_INT32 )((unsigned int )tlcbgxstart + (precno % l_res->pw) * (unsigned int )(1 << cbgwidthexpn));
#line 992
          cbgystart = (OPJ_INT32 )((unsigned int )tlcbgystart + (precno / l_res->pw) * (unsigned int )(1 << cbgheightexpn));
#line 992
          cbgxend = cbgxstart + (1 << cbgwidthexpn);
#line 992
          cbgyend = cbgystart + (1 << cbgheightexpn);
#line 992
          l_current_precinct->x0 = opj_int_max(cbgxstart, l_band->x0);
#line 992
          l_current_precinct->y0 = opj_int_max(cbgystart, l_band->y0);
#line 992
          l_current_precinct->x1 = opj_int_min(cbgxend, l_band->x1);
#line 992
          l_current_precinct->y1 = opj_int_min(cbgyend, l_band->y1);
#line 992
          __cil_tmp98 = opj_int_floordivpow2(l_current_precinct->x0, (OPJ_INT32 )cblkwidthexpn);
#line 992
          tlcblkxstart = __cil_tmp98 << cblkwidthexpn;
#line 992
          __cil_tmp99 = opj_int_floordivpow2(l_current_precinct->y0, (OPJ_INT32 )cblkheightexpn);
#line 992
          tlcblkystart = __cil_tmp99 << cblkheightexpn;
#line 992
          __cil_tmp100 = opj_int_ceildivpow2(l_current_precinct->x1, (OPJ_INT32 )cblkwidthexpn);
#line 992
          brcblkxend = __cil_tmp100 << cblkwidthexpn;
#line 992
          __cil_tmp101 = opj_int_ceildivpow2(l_current_precinct->y1, (OPJ_INT32 )cblkheightexpn);
#line 992
          brcblkyend = __cil_tmp101 << cblkheightexpn;
#line 992
          l_current_precinct->cw = (OPJ_UINT32 )((brcblkxend - tlcblkxstart) >> cblkwidthexpn);
#line 992
          l_current_precinct->ch = (OPJ_UINT32 )((brcblkyend - tlcblkystart) >> cblkheightexpn);
#line 992
          l_nb_code_blocks = l_current_precinct->cw * l_current_precinct->ch;
#line 992
          l_nb_code_blocks_size = (OPJ_UINT32 )((unsigned long )l_nb_code_blocks * sizeof(opj_tcd_cblk_enc_t ));
          }
#line 992
          if (! l_current_precinct->cblks.enc) {
            {
#line 992
            __cil_tmp102 = malloc((unsigned long )l_nb_code_blocks_size);
#line 992
            l_current_precinct->cblks.enc = (opj_tcd_cblk_enc_t *)__cil_tmp102;
            }
#line 992
            if (! l_current_precinct->cblks.enc) {
#line 992
              return (0);
            }
            {
#line 992
            memset((void *)l_current_precinct->cblks.enc, 0, (unsigned long )l_nb_code_blocks_size);
#line 992
            l_current_precinct->block_size = l_nb_code_blocks_size;
            }
          } else
#line 992
          if (l_nb_code_blocks_size > l_current_precinct->block_size) {
            {
#line 992
            __cil_tmp104 = realloc((void *)l_current_precinct->cblks.enc, (unsigned long )l_nb_code_blocks_size);
#line 992
            new_ELEMENT = (opj_tcd_cblk_enc_t *)__cil_tmp104;
            }
#line 992
            if (! new_ELEMENT) {
              {
#line 992
              free((void *)l_current_precinct->cblks.enc);
#line 992
              l_current_precinct->cblks.enc = (opj_tcd_cblk_enc_t *)((void *)0);
#line 992
              l_current_precinct->block_size = (OPJ_UINT32 )0;
#line 992
              fprintf(stderr, "Not enough memory for current precinct codeblock element\n");
              }
#line 992
              return (0);
            }
            {
#line 992
            l_current_precinct->cblks.enc = new_ELEMENT;
#line 992
            memset((void *)((OPJ_BYTE *)l_current_precinct->cblks.enc + l_current_precinct->block_size),
                   0, (unsigned long )(l_nb_code_blocks_size - l_current_precinct->block_size));
#line 992
            l_current_precinct->block_size = l_nb_code_blocks_size;
            }
          }
#line 992
          if (! l_current_precinct->incltree) {
            {
#line 992
            l_current_precinct->incltree = opj_tgt_create(l_current_precinct->cw,
                                                          l_current_precinct->ch);
            }
          } else {
            {
#line 992
            l_current_precinct->incltree = opj_tgt_init(l_current_precinct->incltree,
                                                        l_current_precinct->cw, l_current_precinct->ch);
            }
          }
#line 992
          if (! l_current_precinct->incltree) {
            {
#line 992
            fprintf(stderr, "WARNING: No incltree created.\n");
            }
          }
#line 992
          if (! l_current_precinct->imsbtree) {
            {
#line 992
            l_current_precinct->imsbtree = opj_tgt_create(l_current_precinct->cw,
                                                          l_current_precinct->ch);
            }
          } else {
            {
#line 992
            l_current_precinct->imsbtree = opj_tgt_init(l_current_precinct->imsbtree,
                                                        l_current_precinct->cw, l_current_precinct->ch);
            }
          }
#line 992
          if (! l_current_precinct->imsbtree) {
            {
#line 992
            fprintf(stderr, "WARNING: No imsbtree created.\n");
            }
          }
#line 992
          l_code_block = l_current_precinct->cblks.enc;
#line 992
          cblkno = (OPJ_UINT32 )0;
          {
#line 992
          while (1) {
            while_continue___3: /* CIL Label */ ;

#line 992
            if (! (cblkno < l_nb_code_blocks)) {
#line 992
              goto while_break___3;
            }
            {
#line 992
            cblkxstart = (OPJ_INT32 )((unsigned int )tlcblkxstart + (cblkno % l_current_precinct->cw) * (unsigned int )(1 << cblkwidthexpn));
#line 992
            cblkystart = (OPJ_INT32 )((unsigned int )tlcblkystart + (cblkno / l_current_precinct->cw) * (unsigned int )(1 << cblkheightexpn));
#line 992
            cblkxend = cblkxstart + (1 << cblkwidthexpn);
#line 992
            cblkyend = cblkystart + (1 << cblkheightexpn);
#line 992
            l_code_block->x0 = opj_int_max(cblkxstart, l_current_precinct->x0);
#line 992
            l_code_block->y0 = opj_int_max(cblkystart, l_current_precinct->y0);
#line 992
            l_code_block->x1 = opj_int_min(cblkxend, l_current_precinct->x1);
#line 992
            l_code_block->y1 = opj_int_min(cblkyend, l_current_precinct->y1);
#line 992
            __cil_tmp117 = opj_tcd_code_block_enc_allocate(l_code_block);
            }
#line 992
            if (! __cil_tmp117) {
#line 992
              return (0);
            }
#line 992
            l_code_block ++;
#line 992
            cblkno ++;
          }
          while_break___8: /* CIL Label */ ;
          }
          while_break___3: 
#line 992
          l_current_precinct ++;
#line 992
          precno ++;
        }
        while_break___7: /* CIL Label */ ;
        }
        while_break___2: 
#line 992
        l_band ++;
#line 992
        l_step_size ++;
#line 992
        bandno ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___1: 
#line 992
      l_res ++;
#line 992
      l_level_no --;
#line 992
      resno ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: 
#line 992
    l_tccp ++;
#line 992
    l_tilec ++;
#line 992
    l_image_comp ++;
#line 992
    compno ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: ;
#line 992
  return (1);
}
}
#line 993 "/root/patron/new_22/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_init_decode_tile(opj_tcd_t *p_tcd , OPJ_UINT32 p_tile_no ) 
{ 
  OPJ_UINT32 (*l_gain_ptr)(OPJ_UINT32  ) ;
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 bandno ;
  OPJ_UINT32 precno ;
  OPJ_UINT32 cblkno ;
  opj_tcp_t *l_tcp ;
  opj_cp_t *l_cp ;
  opj_tcd_tile_t *l_tile ;
  opj_tccp_t *l_tccp ;
  opj_tcd_tilecomp_t *l_tilec ;
  opj_image_comp_t *l_image_comp ;
  opj_tcd_resolution_t *l_res ;
  opj_tcd_band_t *l_band ;
  opj_stepsize_t *l_step_size ;
  opj_tcd_precinct_t *l_current_precinct ;
  opj_tcd_cblk_dec_t *l_code_block ;
  opj_image_t *l_image ;
  OPJ_UINT32 p ;
  OPJ_UINT32 q ;
  OPJ_UINT32 l_level_no ;
  OPJ_UINT32 l_pdx ;
  OPJ_UINT32 l_pdy ;
  OPJ_UINT32 l_gain ;
  OPJ_INT32 l_x0b ;
  OPJ_INT32 l_y0b ;
  OPJ_INT32 l_tl_prc_x_start ;
  OPJ_INT32 l_tl_prc_y_start ;
  OPJ_INT32 l_br_prc_x_end ;
  OPJ_INT32 l_br_prc_y_end ;
  OPJ_UINT32 l_nb_precincts ;
  OPJ_UINT32 l_nb_precinct_size ;
  OPJ_UINT32 l_nb_code_blocks ;
  OPJ_UINT32 l_nb_code_blocks_size ;
  OPJ_UINT32 l_data_size ;
  void *__cil_tmp46 ;
  OPJ_INT32 *new_data ;
  void *__cil_tmp48 ;
  void *__cil_tmp49 ;
  opj_tcd_resolution_t *new_resolutions ;
  void *__cil_tmp51 ;
  OPJ_INT32 tlcbgxstart ;
  OPJ_INT32 tlcbgystart ;
  OPJ_UINT32 cbgwidthexpn ;
  OPJ_UINT32 cbgheightexpn ;
  OPJ_UINT32 cblkwidthexpn ;
  OPJ_UINT32 cblkheightexpn ;
  OPJ_INT32 __cil_tmp62 ;
  OPJ_INT32 __cil_tmp63 ;
  OPJ_INT32 __cil_tmp64 ;
  OPJ_INT32 __cil_tmp65 ;
  int tmp ;
  int tmp___0 ;
  OPJ_INT32 numbps ;
  double __cil_tmp82 ;
  void *__cil_tmp83 ;
  opj_tcd_precinct_t *new_precincts ;
  void *__cil_tmp85 ;
  OPJ_INT32 tlcblkxstart ;
  OPJ_INT32 tlcblkystart ;
  OPJ_INT32 brcblkxend ;
  OPJ_INT32 brcblkyend ;
  OPJ_INT32 cbgxstart ;
  OPJ_INT32 cbgystart ;
  OPJ_INT32 cbgxend ;
  OPJ_INT32 cbgyend ;
  OPJ_INT32 __cil_tmp98 ;
  OPJ_INT32 __cil_tmp99 ;
  OPJ_INT32 __cil_tmp100 ;
  OPJ_INT32 __cil_tmp101 ;
  void *__cil_tmp102 ;
  opj_tcd_cblk_dec_t *new_ELEMENT ;
  void *__cil_tmp104 ;
  OPJ_INT32 cblkxstart ;
  OPJ_INT32 cblkystart ;
  OPJ_INT32 cblkxend ;
  OPJ_INT32 cblkyend ;
  OPJ_BOOL __cil_tmp117 ;

  {
  {
#line 993
  l_gain_ptr = (OPJ_UINT32 (*)(OPJ_UINT32  ))0;
#line 993
  l_tcp = (opj_tcp_t *)0;
#line 993
  l_cp = (opj_cp_t *)0;
#line 993
  l_tile = (opj_tcd_tile_t *)0;
#line 993
  l_tccp = (opj_tccp_t *)0;
#line 993
  l_tilec = (opj_tcd_tilecomp_t *)0;
#line 993
  l_image_comp = (opj_image_comp_t *)0;
#line 993
  l_res = (opj_tcd_resolution_t *)0;
#line 993
  l_band = (opj_tcd_band_t *)0;
#line 993
  l_step_size = (opj_stepsize_t *)0;
#line 993
  l_current_precinct = (opj_tcd_precinct_t *)0;
#line 993
  l_code_block = (opj_tcd_cblk_dec_t *)0;
#line 993
  l_image = (opj_image_t *)0;
#line 993
  l_cp = p_tcd->cp;
#line 993
  l_tcp = l_cp->tcps + p_tile_no;
#line 993
  l_tile = (p_tcd->tcd_image)->tiles;
#line 993
  l_tccp = l_tcp->tccps;
#line 993
  l_tilec = l_tile->comps;
#line 993
  l_image = p_tcd->image;
#line 993
  l_image_comp = (p_tcd->image)->comps;
#line 993
  p = p_tile_no % l_cp->tw;
#line 993
  q = p_tile_no / l_cp->tw;
#line 993
  l_tile->x0 = opj_int_max((OPJ_INT32 )(l_cp->tx0 + p * l_cp->tdx), (OPJ_INT32 )l_image->x0);
#line 993
  l_tile->y0 = opj_int_max((OPJ_INT32 )(l_cp->ty0 + q * l_cp->tdy), (OPJ_INT32 )l_image->y0);
#line 993
  l_tile->x1 = opj_int_min((OPJ_INT32 )(l_cp->tx0 + (p + 1U) * l_cp->tdx), (OPJ_INT32 )l_image->x1);
#line 993
  l_tile->y1 = opj_int_min((OPJ_INT32 )(l_cp->ty0 + (q + 1U) * l_cp->tdy), (OPJ_INT32 )l_image->y1);
#line 993
  compno = (OPJ_UINT32 )0;
  }
  {
#line 993
  while (1) {
    while_continue: /* CIL Label */ ;

#line 993
    if (! (compno < l_tile->numcomps)) {
#line 993
      goto while_break;
    }
    {
#line 993
    l_tilec->x0 = opj_int_ceildiv(l_tile->x0, (OPJ_INT32 )l_image_comp->dx);
#line 993
    l_tilec->y0 = opj_int_ceildiv(l_tile->y0, (OPJ_INT32 )l_image_comp->dy);
#line 993
    l_tilec->x1 = opj_int_ceildiv(l_tile->x1, (OPJ_INT32 )l_image_comp->dx);
#line 993
    l_tilec->y1 = opj_int_ceildiv(l_tile->y1, (OPJ_INT32 )l_image_comp->dy);
#line 993
    l_data_size = (OPJ_UINT32 )((unsigned long )((l_tilec->x1 - l_tilec->x0) * (l_tilec->y1 - l_tilec->y0)) * sizeof(OPJ_UINT32 ));
#line 993
    l_tilec->numresolutions = l_tccp->numresolutions;
    }
#line 993
    if (l_tccp->numresolutions < l_cp->m_specific_param.m_dec.m_reduce) {
#line 993
      l_tilec->minimum_num_resolutions = (OPJ_UINT32 )1;
    } else {
#line 993
      l_tilec->minimum_num_resolutions = l_tccp->numresolutions - l_cp->m_specific_param.m_dec.m_reduce;
    }
#line 993
    if ((unsigned long )l_tilec->data == (unsigned long )((OPJ_INT32 *)0)) {
      {
#line 993
      __cil_tmp46 = malloc((unsigned long )l_data_size);
#line 993
      l_tilec->data = (OPJ_INT32 *)__cil_tmp46;
      }
#line 993
      if (! l_tilec->data) {
#line 993
        return (0);
      }
#line 993
      l_tilec->data_size = l_data_size;
    } else
#line 993
    if (l_data_size > l_tilec->data_size) {
      {
#line 993
      __cil_tmp48 = realloc((void *)l_tilec->data, (unsigned long )l_data_size);
#line 993
      new_data = (OPJ_INT32 *)__cil_tmp48;
#line 993
      fprintf(stderr, "Not enough memory to handle tile data\n");
      }
#line 993
      if (! new_data) {
        {
#line 993
        free((void *)l_tilec->data);
#line 993
        l_tilec->data = (OPJ_INT32 *)((void *)0);
#line 993
        l_tilec->data_size = (OPJ_UINT32 )0;
        }
#line 993
        return (0);
      }
#line 993
      l_tilec->data = new_data;
#line 993
      l_tilec->data_size = l_data_size;
    }
#line 993
    l_data_size = (OPJ_UINT32 )((unsigned long )l_tilec->numresolutions * sizeof(opj_tcd_resolution_t ));
#line 993
    if ((unsigned long )l_tilec->resolutions == (unsigned long )((opj_tcd_resolution_t *)0)) {
      {
#line 993
      __cil_tmp49 = malloc((unsigned long )l_data_size);
#line 993
      l_tilec->resolutions = (opj_tcd_resolution_t *)__cil_tmp49;
      }
#line 993
      if (! l_tilec->resolutions) {
#line 993
        return (0);
      }
      {
#line 993
      l_tilec->resolutions_size = l_data_size;
#line 993
      memset((void *)l_tilec->resolutions, 0, (unsigned long )l_data_size);
      }
    } else
#line 993
    if (l_data_size > l_tilec->resolutions_size) {
      {
#line 993
      __cil_tmp51 = realloc((void *)l_tilec->resolutions, (unsigned long )l_data_size);
#line 993
      new_resolutions = (opj_tcd_resolution_t *)__cil_tmp51;
      }
#line 993
      if (! new_resolutions) {
        {
#line 993
        fprintf(stderr, "Not enough memory to tile resolutions\n");
#line 993
        free((void *)l_tilec->resolutions);
#line 993
        l_tilec->resolutions = (opj_tcd_resolution_t *)((void *)0);
#line 993
        l_tilec->resolutions_size = (OPJ_UINT32 )0;
        }
#line 993
        return (0);
      }
      {
#line 993
      l_tilec->resolutions = new_resolutions;
#line 993
      memset((void *)((OPJ_BYTE *)l_tilec->resolutions + l_tilec->resolutions_size),
             0, (unsigned long )(l_data_size - l_tilec->resolutions_size));
#line 993
      l_tilec->resolutions_size = l_data_size;
      }
    }
#line 993
    l_level_no = l_tilec->numresolutions - 1U;
#line 993
    l_res = l_tilec->resolutions;
#line 993
    l_step_size = l_tccp->stepsizes;
#line 993
    if (l_tccp->qmfbid == 0U) {
#line 993
      l_gain_ptr = & opj_dwt_getgain_real;
    } else {
#line 993
      l_gain_ptr = & opj_dwt_getgain;
    }
#line 993
    resno = (OPJ_UINT32 )0;
    {
#line 993
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 993
      if (! (resno < l_tilec->numresolutions)) {
#line 993
        goto while_break___0;
      }
      {
#line 993
      l_res->x0 = opj_int_ceildivpow2(l_tilec->x0, (OPJ_INT32 )l_level_no);
#line 993
      l_res->y0 = opj_int_ceildivpow2(l_tilec->y0, (OPJ_INT32 )l_level_no);
#line 993
      l_res->x1 = opj_int_ceildivpow2(l_tilec->x1, (OPJ_INT32 )l_level_no);
#line 993
      l_res->y1 = opj_int_ceildivpow2(l_tilec->y1, (OPJ_INT32 )l_level_no);
#line 993
      l_pdx = l_tccp->prcw[resno];
#line 993
      l_pdy = l_tccp->prch[resno];
#line 993
      __cil_tmp62 = opj_int_floordivpow2(l_res->x0, (OPJ_INT32 )l_pdx);
#line 993
      l_tl_prc_x_start = __cil_tmp62 << l_pdx;
#line 993
      __cil_tmp63 = opj_int_floordivpow2(l_res->y0, (OPJ_INT32 )l_pdy);
#line 993
      l_tl_prc_y_start = __cil_tmp63 << l_pdy;
#line 993
      __cil_tmp64 = opj_int_ceildivpow2(l_res->x1, (OPJ_INT32 )l_pdx);
#line 993
      l_br_prc_x_end = __cil_tmp64 << l_pdx;
#line 993
      __cil_tmp65 = opj_int_ceildivpow2(l_res->y1, (OPJ_INT32 )l_pdy);
#line 993
      l_br_prc_y_end = __cil_tmp65 << l_pdy;
      }
#line 993
      if (l_res->x0 == l_res->x1) {
#line 993
        tmp = 0;
      } else {
#line 993
        tmp = (l_br_prc_x_end - l_tl_prc_x_start) >> l_pdx;
      }
#line 993
      l_res->pw = (OPJ_UINT32 )tmp;
#line 993
      if (l_res->y0 == l_res->y1) {
#line 993
        tmp___0 = 0;
      } else {
#line 993
        tmp___0 = (l_br_prc_y_end - l_tl_prc_y_start) >> l_pdy;
      }
#line 993
      l_res->ph = (OPJ_UINT32 )tmp___0;
#line 993
      l_nb_precincts = l_res->pw * l_res->ph;
#line 993
      l_nb_precinct_size = (OPJ_UINT32 )((unsigned long )l_nb_precincts * sizeof(opj_tcd_precinct_t ));
#line 993
      if (resno == 0U) {
#line 993
        tlcbgxstart = l_tl_prc_x_start;
#line 993
        tlcbgystart = l_tl_prc_y_start;
#line 993
        cbgwidthexpn = l_pdx;
#line 993
        cbgheightexpn = l_pdy;
#line 993
        l_res->numbands = (OPJ_UINT32 )1;
      } else {
        {
#line 993
        tlcbgxstart = opj_int_ceildivpow2(l_tl_prc_x_start, 1);
#line 993
        tlcbgystart = opj_int_ceildivpow2(l_tl_prc_y_start, 1);
#line 993
        cbgwidthexpn = l_pdx - 1U;
#line 993
        cbgheightexpn = l_pdy - 1U;
#line 993
        l_res->numbands = (OPJ_UINT32 )3;
        }
      }
      {
#line 993
      cblkwidthexpn = opj_uint_min(l_tccp->cblkw, cbgwidthexpn);
#line 993
      cblkheightexpn = opj_uint_min(l_tccp->cblkh, cbgheightexpn);
#line 993
      l_band = l_res->bands;
#line 993
      bandno = (OPJ_UINT32 )0;
      }
      {
#line 993
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 993
        if (! (bandno < l_res->numbands)) {
#line 993
          goto while_break___1;
        }
#line 993
        if (resno == 0U) {
          {
#line 993
          l_band->bandno = (OPJ_UINT32 )0;
#line 993
          l_band->x0 = opj_int_ceildivpow2(l_tilec->x0, (OPJ_INT32 )l_level_no);
#line 993
          l_band->y0 = opj_int_ceildivpow2(l_tilec->y0, (OPJ_INT32 )l_level_no);
#line 993
          l_band->x1 = opj_int_ceildivpow2(l_tilec->x1, (OPJ_INT32 )l_level_no);
#line 993
          l_band->y1 = opj_int_ceildivpow2(l_tilec->y1, (OPJ_INT32 )l_level_no);
          }
        } else {
          {
#line 993
          l_band->bandno = bandno + 1U;
#line 993
          l_x0b = (OPJ_INT32 )(l_band->bandno & 1U);
#line 993
          l_y0b = (OPJ_INT32 )(l_band->bandno >> 1);
#line 993
          l_band->x0 = opj_int_ceildivpow2(l_tilec->x0 - (1 << l_level_no) * l_x0b,
                                           (OPJ_INT32 )(l_level_no + 1U));
#line 993
          l_band->y0 = opj_int_ceildivpow2(l_tilec->y0 - (1 << l_level_no) * l_y0b,
                                           (OPJ_INT32 )(l_level_no + 1U));
#line 993
          l_band->x1 = opj_int_ceildivpow2(l_tilec->x1 - (1 << l_level_no) * l_x0b,
                                           (OPJ_INT32 )(l_level_no + 1U));
#line 993
          l_band->y1 = opj_int_ceildivpow2(l_tilec->y1 - (1 << l_level_no) * l_y0b,
                                           (OPJ_INT32 )(l_level_no + 1U));
          }
        }
        {
#line 993
        l_gain = (*l_gain_ptr)(l_band->bandno);
#line 993
        numbps = (OPJ_INT32 )(l_image_comp->prec + l_gain);
#line 993
        __cil_tmp82 = pow(2., (double )(numbps - l_step_size->expn));
#line 993
        l_band->stepsize = (OPJ_FLOAT32 )((1. + (double )l_step_size->mant / 2048.) * __cil_tmp82) * 0.5f;
#line 993
        l_band->numbps = (OPJ_INT32 )(((unsigned int )l_step_size->expn + l_tccp->numgbits) - 1U);
        }
#line 993
        if (! l_band->precincts) {
          {
#line 993
          __cil_tmp83 = malloc((unsigned long )l_nb_precinct_size);
#line 993
          l_band->precincts = (opj_tcd_precinct_t *)__cil_tmp83;
          }
#line 993
          if (! l_band->precincts) {
#line 993
            return (0);
          }
          {
#line 993
          memset((void *)l_band->precincts, 0, (unsigned long )l_nb_precinct_size);
#line 993
          l_band->precincts_data_size = l_nb_precinct_size;
          }
        } else
#line 993
        if (l_band->precincts_data_size < l_nb_precinct_size) {
          {
#line 993
          __cil_tmp85 = realloc((void *)l_band->precincts, (unsigned long )l_nb_precinct_size);
#line 993
          new_precincts = (opj_tcd_precinct_t *)__cil_tmp85;
          }
#line 993
          if (! new_precincts) {
            {
#line 993
            fprintf(stderr, "Not enough memory to handle band precints\n\241\210\202U");
#line 993
            free((void *)l_band->precincts);
#line 993
            l_band->precincts = (opj_tcd_precinct_t *)((void *)0);
#line 993
            l_band->precincts_data_size = (OPJ_UINT32 )0;
            }
#line 993
            return (0);
          }
          {
#line 993
          l_band->precincts = new_precincts;
#line 993
          memset((void *)((OPJ_BYTE *)l_band->precincts + l_band->precincts_data_size),
                 0, (unsigned long )(l_nb_precinct_size - l_band->precincts_data_size));
#line 993
          l_band->precincts_data_size = l_nb_precinct_size;
          }
        }
#line 993
        l_current_precinct = l_band->precincts;
#line 993
        precno = (OPJ_UINT32 )0;
        {
#line 993
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 993
          if (! (precno < l_nb_precincts)) {
#line 993
            goto while_break___2;
          }
          {
#line 993
          cbgxstart = (OPJ_INT32 )((unsigned int )tlcbgxstart + (precno % l_res->pw) * (unsigned int )(1 << cbgwidthexpn));
#line 993
          cbgystart = (OPJ_INT32 )((unsigned int )tlcbgystart + (precno / l_res->pw) * (unsigned int )(1 << cbgheightexpn));
#line 993
          cbgxend = cbgxstart + (1 << cbgwidthexpn);
#line 993
          cbgyend = cbgystart + (1 << cbgheightexpn);
#line 993
          l_current_precinct->x0 = opj_int_max(cbgxstart, l_band->x0);
#line 993
          l_current_precinct->y0 = opj_int_max(cbgystart, l_band->y0);
#line 993
          l_current_precinct->x1 = opj_int_min(cbgxend, l_band->x1);
#line 993
          l_current_precinct->y1 = opj_int_min(cbgyend, l_band->y1);
#line 993
          __cil_tmp98 = opj_int_floordivpow2(l_current_precinct->x0, (OPJ_INT32 )cblkwidthexpn);
#line 993
          tlcblkxstart = __cil_tmp98 << cblkwidthexpn;
#line 993
          __cil_tmp99 = opj_int_floordivpow2(l_current_precinct->y0, (OPJ_INT32 )cblkheightexpn);
#line 993
          tlcblkystart = __cil_tmp99 << cblkheightexpn;
#line 993
          __cil_tmp100 = opj_int_ceildivpow2(l_current_precinct->x1, (OPJ_INT32 )cblkwidthexpn);
#line 993
          brcblkxend = __cil_tmp100 << cblkwidthexpn;
#line 993
          __cil_tmp101 = opj_int_ceildivpow2(l_current_precinct->y1, (OPJ_INT32 )cblkheightexpn);
#line 993
          brcblkyend = __cil_tmp101 << cblkheightexpn;
#line 993
          l_current_precinct->cw = (OPJ_UINT32 )((brcblkxend - tlcblkxstart) >> cblkwidthexpn);
#line 993
          l_current_precinct->ch = (OPJ_UINT32 )((brcblkyend - tlcblkystart) >> cblkheightexpn);
#line 993
          l_nb_code_blocks = l_current_precinct->cw * l_current_precinct->ch;
#line 993
          l_nb_code_blocks_size = (OPJ_UINT32 )((unsigned long )l_nb_code_blocks * sizeof(opj_tcd_cblk_dec_t ));
          }
#line 993
          if (! l_current_precinct->cblks.dec) {
            {
#line 993
            __cil_tmp102 = malloc((unsigned long )l_nb_code_blocks_size);
#line 993
            l_current_precinct->cblks.dec = (opj_tcd_cblk_dec_t *)__cil_tmp102;
            }
#line 993
            if (! l_current_precinct->cblks.dec) {
#line 993
              return (0);
            }
            {
#line 993
            memset((void *)l_current_precinct->cblks.dec, 0, (unsigned long )l_nb_code_blocks_size);
#line 993
            l_current_precinct->block_size = l_nb_code_blocks_size;
            }
          } else
#line 993
          if (l_nb_code_blocks_size > l_current_precinct->block_size) {
            {
#line 993
            __cil_tmp104 = realloc((void *)l_current_precinct->cblks.dec, (unsigned long )l_nb_code_blocks_size);
#line 993
            new_ELEMENT = (opj_tcd_cblk_dec_t *)__cil_tmp104;
            }
#line 993
            if (! new_ELEMENT) {
              {
#line 993
              free((void *)l_current_precinct->cblks.dec);
#line 993
              l_current_precinct->cblks.dec = (opj_tcd_cblk_dec_t *)((void *)0);
#line 993
              l_current_precinct->block_size = (OPJ_UINT32 )0;
#line 993
              fprintf(stderr, "Not enough memory for current precinct codeblock element\n&\241\210\202U");
              }
#line 993
              return (0);
            }
            {
#line 993
            l_current_precinct->cblks.dec = new_ELEMENT;
#line 993
            memset((void *)((OPJ_BYTE *)l_current_precinct->cblks.dec + l_current_precinct->block_size),
                   0, (unsigned long )(l_nb_code_blocks_size - l_current_precinct->block_size));
#line 993
            l_current_precinct->block_size = l_nb_code_blocks_size;
            }
          }
#line 993
          if (! l_current_precinct->incltree) {
            {
#line 993
            l_current_precinct->incltree = opj_tgt_create(l_current_precinct->cw,
                                                          l_current_precinct->ch);
            }
          } else {
            {
#line 993
            l_current_precinct->incltree = opj_tgt_init(l_current_precinct->incltree,
                                                        l_current_precinct->cw, l_current_precinct->ch);
            }
          }
#line 993
          if (! l_current_precinct->incltree) {
            {
#line 993
            fprintf(stderr, "WARNING: No incltree created.\n");
            }
          }
#line 993
          if (! l_current_precinct->imsbtree) {
            {
#line 993
            l_current_precinct->imsbtree = opj_tgt_create(l_current_precinct->cw,
                                                          l_current_precinct->ch);
            }
          } else {
            {
#line 993
            l_current_precinct->imsbtree = opj_tgt_init(l_current_precinct->imsbtree,
                                                        l_current_precinct->cw, l_current_precinct->ch);
            }
          }
#line 993
          if (! l_current_precinct->imsbtree) {
            {
#line 993
            fprintf(stderr, "WARNING: No imsbtree created.\n");
            }
          }
#line 993
          l_code_block = l_current_precinct->cblks.dec;
#line 993
          cblkno = (OPJ_UINT32 )0;
          {
#line 993
          while (1) {
            while_continue___3: /* CIL Label */ ;

#line 993
            if (! (cblkno < l_nb_code_blocks)) {
#line 993
              goto while_break___3;
            }
            {
#line 993
            cblkxstart = (OPJ_INT32 )((unsigned int )tlcblkxstart + (cblkno % l_current_precinct->cw) * (unsigned int )(1 << cblkwidthexpn));
#line 993
            cblkystart = (OPJ_INT32 )((unsigned int )tlcblkystart + (cblkno / l_current_precinct->cw) * (unsigned int )(1 << cblkheightexpn));
#line 993
            cblkxend = cblkxstart + (1 << cblkwidthexpn);
#line 993
            cblkyend = cblkystart + (1 << cblkheightexpn);
#line 993
            l_code_block->x0 = opj_int_max(cblkxstart, l_current_precinct->x0);
#line 993
            l_code_block->y0 = opj_int_max(cblkystart, l_current_precinct->y0);
#line 993
            l_code_block->x1 = opj_int_min(cblkxend, l_current_precinct->x1);
#line 993
            l_code_block->y1 = opj_int_min(cblkyend, l_current_precinct->y1);
#line 993
            __cil_tmp117 = opj_tcd_code_block_dec_allocate(l_code_block);
            }
#line 993
            if (! __cil_tmp117) {
#line 993
              return (0);
            }
#line 993
            l_code_block ++;
#line 993
            cblkno ++;
          }
          while_break___8: /* CIL Label */ ;
          }
          while_break___3: 
#line 993
          l_current_precinct ++;
#line 993
          precno ++;
        }
        while_break___7: /* CIL Label */ ;
        }
        while_break___2: 
#line 993
        l_band ++;
#line 993
        l_step_size ++;
#line 993
        bandno ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___1: 
#line 993
      l_res ++;
#line 993
      l_level_no --;
#line 993
      resno ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: 
#line 993
    l_tccp ++;
#line 993
    l_tilec ++;
#line 993
    l_image_comp ++;
#line 993
    compno ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: ;
#line 993
  return (1);
}
}
#line 1000 "/root/patron/new_22/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_code_block_enc_allocate(opj_tcd_cblk_enc_t *p_code_block ) 
{ 
  void *__cil_tmp2 ;
  void *__cil_tmp3 ;
  void *__cil_tmp4 ;

  {
#line 1002
  if (! p_code_block->data) {
    {
#line 1004
    __cil_tmp2 = malloc(8192UL);
#line 1004
    p_code_block->data = (OPJ_BYTE *)__cil_tmp2;
    }
#line 1005
    if (! p_code_block->data) {
#line 1006
      return (0);
    }
    {
#line 1009
    *(p_code_block->data + 0) = (OPJ_BYTE )0;
#line 1010
    (p_code_block->data) ++;
#line 1013
    __cil_tmp3 = malloc(100UL * sizeof(opj_tcd_layer_t ));
#line 1013
    p_code_block->layers = (opj_tcd_layer_t *)__cil_tmp3;
    }
#line 1014
    if (! p_code_block->layers) {
#line 1015
      return (0);
    }
    {
#line 1018
    __cil_tmp4 = malloc(100UL * sizeof(opj_tcd_pass_t ));
#line 1018
    p_code_block->passes = (opj_tcd_pass_t *)__cil_tmp4;
    }
#line 1019
    if (! p_code_block->passes) {
#line 1020
      return (0);
    }
  }
  {
#line 1024
  memset((void *)p_code_block->layers, 0, 100UL * sizeof(opj_tcd_layer_t ));
#line 1025
  memset((void *)p_code_block->passes, 0, 100UL * sizeof(opj_tcd_pass_t ));
  }
#line 1027
  return (1);
}
}
#line 1033 "/root/patron/new_22/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_code_block_dec_allocate(opj_tcd_cblk_dec_t *p_code_block ) 
{ 
  OPJ_UINT32 l_seg_size ;
  void *__cil_tmp3 ;
  void *__cil_tmp4 ;

  {
#line 1037
  if (! p_code_block->data) {
    {
#line 1039
    __cil_tmp3 = malloc(8192UL);
#line 1039
    p_code_block->data = (OPJ_BYTE *)__cil_tmp3;
    }
#line 1040
    if (! p_code_block->data) {
#line 1041
      return (0);
    }
    {
#line 1043
    p_code_block->data_max_size = (OPJ_UINT32 )8192;
#line 1046
    l_seg_size = (OPJ_UINT32 )(10UL * sizeof(opj_tcd_seg_t ));
#line 1047
    __cil_tmp4 = malloc((unsigned long )l_seg_size);
#line 1047
    p_code_block->segs = (opj_tcd_seg_t *)__cil_tmp4;
    }
#line 1048
    if (! p_code_block->segs) {
#line 1049
      return (0);
    }
    {
#line 1051
    memset((void *)p_code_block->segs, 0, (unsigned long )l_seg_size);
#line 1054
    p_code_block->m_current_max_segs = (OPJ_UINT32 )10;
    }
  }
#line 1060
  return (1);
}
}
#line 1063 "/root/patron/new_22/src/lib/openjp2/tcd.c"
OPJ_UINT32 opj_tcd_get_decoded_tile_size(opj_tcd_t *p_tcd ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_data_size ;
  opj_image_comp_t *l_img_comp ;
  opj_tcd_tilecomp_t *l_tile_comp ;
  opj_tcd_resolution_t *l_res ;
  OPJ_UINT32 l_size_comp ;
  OPJ_UINT32 l_remaining ;

  {
#line 1066
  l_data_size = (OPJ_UINT32 )0;
#line 1067
  l_img_comp = (opj_image_comp_t *)0;
#line 1068
  l_tile_comp = (opj_tcd_tilecomp_t *)0;
#line 1069
  l_res = (opj_tcd_resolution_t *)0;
#line 1072
  l_tile_comp = ((p_tcd->tcd_image)->tiles)->comps;
#line 1073
  l_img_comp = (p_tcd->image)->comps;
#line 1075
  i = (OPJ_UINT32 )0;
  {
#line 1075
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1075
    if (! (i < (p_tcd->image)->numcomps)) {
#line 1075
      goto while_break;
    }
#line 1076
    l_size_comp = l_img_comp->prec >> 3;
#line 1077
    l_remaining = l_img_comp->prec & 7U;
#line 1079
    if (l_remaining) {
#line 1080
      l_size_comp ++;
    }
#line 1083
    if (l_size_comp == 3U) {
#line 1084
      l_size_comp = (OPJ_UINT32 )4;
    }
#line 1087
    l_res = (l_tile_comp->resolutions + l_tile_comp->minimum_num_resolutions) - 1;
#line 1088
    l_data_size += (l_size_comp * (unsigned int )(l_res->x1 - l_res->x0)) * (unsigned int )(l_res->y1 - l_res->y0);
#line 1089
    l_img_comp ++;
#line 1090
    l_tile_comp ++;
#line 1075
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1093
  return (l_data_size);
}
}
#line 1096 "/root/patron/new_22/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_encode_tile(opj_tcd_t *p_tcd , OPJ_UINT32 p_tile_no , OPJ_BYTE *p_dest ,
                             OPJ_UINT32 *p_data_written , OPJ_UINT32 p_max_length ,
                             opj_codestream_info_t *p_cstr_info ) 
{ 
  OPJ_UINT32 l_num_packs ;
  OPJ_UINT32 i ;
  opj_tcd_tilecomp_t *l_tilec_idx ;
  opj_tccp_t *l_tccp ;
  opj_tcd_resolution_t *l_res_idx ;
  void *__cil_tmp13 ;
  OPJ_BOOL __cil_tmp14 ;
  OPJ_BOOL __cil_tmp15 ;
  OPJ_BOOL __cil_tmp16 ;
  OPJ_BOOL __cil_tmp17 ;
  OPJ_BOOL __cil_tmp18 ;
  OPJ_BOOL __cil_tmp19 ;

  {
#line 1104
  if (p_tcd->cur_tp_num == 0U) {
#line 1106
    p_tcd->tcd_tileno = p_tile_no;
#line 1107
    p_tcd->tcp = (p_tcd->cp)->tcps + p_tile_no;
#line 1110
    if (p_cstr_info) {
#line 1111
      l_num_packs = (OPJ_UINT32 )0;
#line 1113
      l_tilec_idx = ((p_tcd->tcd_image)->tiles)->comps + 0;
#line 1114
      l_tccp = (p_tcd->tcp)->tccps;
#line 1116
      i = (OPJ_UINT32 )0;
      {
#line 1116
      while (1) {
        while_continue: /* CIL Label */ ;

#line 1116
        if (! (i < l_tilec_idx->numresolutions)) {
#line 1116
          goto while_break;
        }
#line 1117
        l_res_idx = l_tilec_idx->resolutions + i;
#line 1119
        (p_cstr_info->tile + p_tile_no)->pw[i] = (int )l_res_idx->pw;
#line 1120
        (p_cstr_info->tile + p_tile_no)->ph[i] = (int )l_res_idx->ph;
#line 1122
        l_num_packs += l_res_idx->pw * l_res_idx->ph;
#line 1123
        (p_cstr_info->tile + p_tile_no)->pdx[i] = (int )l_tccp->prcw[i];
#line 1124
        (p_cstr_info->tile + p_tile_no)->pdy[i] = (int )l_tccp->prch[i];
#line 1116
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: 
      {
#line 1126
      __cil_tmp13 = calloc((unsigned long )((unsigned int )(p_cstr_info->numcomps * p_cstr_info->numlayers) * l_num_packs),
                           sizeof(opj_packet_info_t ));
#line 1126
      (p_cstr_info->tile + p_tile_no)->packet = (opj_packet_info_t *)__cil_tmp13;
      }
    }
    {
#line 1132
    __cil_tmp14 = opj_tcd_dc_level_shift_encode(p_tcd);
    }
#line 1132
    if (! __cil_tmp14) {
#line 1133
      return (0);
    }
    {
#line 1138
    __cil_tmp15 = opj_tcd_mct_encode(p_tcd);
    }
#line 1138
    if (! __cil_tmp15) {
#line 1139
      return (0);
    }
    {
#line 1144
    __cil_tmp16 = opj_tcd_dwt_encode(p_tcd);
    }
#line 1144
    if (! __cil_tmp16) {
#line 1145
      return (0);
    }
    {
#line 1150
    __cil_tmp17 = opj_tcd_t1_encode(p_tcd);
    }
#line 1150
    if (! __cil_tmp17) {
#line 1151
      return (0);
    }
    {
#line 1156
    __cil_tmp18 = opj_tcd_rate_allocate_encode(p_tcd, p_dest, p_max_length, p_cstr_info);
    }
#line 1156
    if (! __cil_tmp18) {
#line 1157
      return (0);
    }
  }
#line 1165
  if (p_cstr_info) {
#line 1166
    p_cstr_info->index_write = 1;
  }
  {
#line 1170
  __cil_tmp19 = opj_tcd_t2_encode(p_tcd, p_dest, p_data_written, p_max_length, p_cstr_info);
  }
#line 1170
  if (! __cil_tmp19) {
#line 1171
    return (0);
  }
#line 1177
  return (1);
}
}
#line 1180 "/root/patron/new_22/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_decode_tile(opj_tcd_t *p_tcd , OPJ_BYTE *p_src , OPJ_UINT32 p_max_length ,
                             OPJ_UINT32 p_tile_no , opj_codestream_index_t *p_cstr_index ) 
{ 
  OPJ_UINT32 l_data_read ;
  OPJ_BOOL __cil_tmp7 ;
  OPJ_BOOL __cil_tmp8 ;
  OPJ_BOOL __cil_tmp9 ;
  OPJ_BOOL __cil_tmp10 ;
  OPJ_BOOL __cil_tmp11 ;

  {
  {
#line 1188
  p_tcd->tcd_tileno = p_tile_no;
#line 1189
  p_tcd->tcp = (p_tcd->cp)->tcps + p_tile_no;
#line 1216
  l_data_read = (OPJ_UINT32 )0;
#line 1217
  __cil_tmp7 = opj_tcd_t2_decode(p_tcd, p_src, & l_data_read, p_max_length, p_cstr_index);
  }
#line 1217
  if (! __cil_tmp7) {
#line 1219
    return (0);
  }
  {
#line 1226
  __cil_tmp8 = opj_tcd_t1_decode(p_tcd);
  }
#line 1226
  if (! __cil_tmp8) {
#line 1229
    return (0);
  }
  {
#line 1236
  __cil_tmp9 = opj_tcd_dwt_decode(p_tcd);
  }
#line 1236
  if (! __cil_tmp9) {
#line 1239
    return (0);
  }
  {
#line 1245
  __cil_tmp10 = opj_tcd_mct_decode(p_tcd);
  }
#line 1245
  if (! __cil_tmp10) {
#line 1248
    return (0);
  }
  {
#line 1253
  __cil_tmp11 = opj_tcd_dc_level_shift_decode(p_tcd);
  }
#line 1253
  if (! __cil_tmp11) {
#line 1256
    return (0);
  }
#line 1262
  return (1);
}
}
#line 1265 "/root/patron/new_22/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_update_tile_data(opj_tcd_t *p_tcd , OPJ_BYTE *p_dest , OPJ_UINT32 p_dest_length ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  OPJ_UINT32 l_data_size ;
  opj_image_comp_t *l_img_comp ;
  opj_tcd_tilecomp_t *l_tilec ;
  opj_tcd_resolution_t *l_res ;
  OPJ_UINT32 l_size_comp ;
  OPJ_UINT32 l_remaining ;
  OPJ_UINT32 l_stride ;
  OPJ_UINT32 l_width ;
  OPJ_UINT32 l_height ;
  OPJ_CHAR *l_dest_ptr ;
  OPJ_INT32 *l_src_ptr ;
  OPJ_CHAR *__cil_tmp19 ;
  OPJ_INT32 *__cil_tmp20 ;
  OPJ_CHAR *__cil_tmp21 ;
  OPJ_INT32 *__cil_tmp22 ;
  OPJ_INT32 *l_src_ptr___0 ;
  OPJ_INT16 *l_dest_ptr___0 ;
  OPJ_INT16 *__cil_tmp25 ;
  OPJ_INT32 *__cil_tmp26 ;
  OPJ_INT16 *__cil_tmp27 ;
  OPJ_INT32 *__cil_tmp28 ;
  OPJ_INT32 *l_dest_ptr___1 ;
  OPJ_INT32 *l_src_ptr___1 ;
  OPJ_INT32 *__cil_tmp31 ;
  OPJ_INT32 *__cil_tmp32 ;

  {
  {
#line 1270
  l_data_size = (OPJ_UINT32 )0;
#line 1271
  l_img_comp = (opj_image_comp_t *)0;
#line 1272
  l_tilec = (opj_tcd_tilecomp_t *)0;
#line 1277
  l_data_size = opj_tcd_get_decoded_tile_size(p_tcd);
  }
#line 1278
  if (l_data_size > p_dest_length) {
#line 1279
    return (0);
  }
#line 1282
  l_tilec = ((p_tcd->tcd_image)->tiles)->comps;
#line 1283
  l_img_comp = (p_tcd->image)->comps;
#line 1285
  i = (OPJ_UINT32 )0;
  {
#line 1285
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1285
    if (! (i < (p_tcd->image)->numcomps)) {
#line 1285
      goto while_break;
    }
#line 1286
    l_size_comp = l_img_comp->prec >> 3;
#line 1287
    l_remaining = l_img_comp->prec & 7U;
#line 1288
    l_res = l_tilec->resolutions + l_img_comp->resno_decoded;
#line 1289
    l_width = (OPJ_UINT32 )(l_res->x1 - l_res->x0);
#line 1290
    l_height = (OPJ_UINT32 )(l_res->y1 - l_res->y0);
#line 1291
    l_stride = (unsigned int )(l_tilec->x1 - l_tilec->x0) - l_width;
#line 1293
    if (l_remaining) {
#line 1294
      l_size_comp ++;
    }
#line 1297
    if (l_size_comp == 3U) {
#line 1298
      l_size_comp = (OPJ_UINT32 )4;
    }
#line 1303
    if (l_size_comp == 1U) {
#line 1303
      goto case_1;
    }
#line 1328
    if (l_size_comp == 2U) {
#line 1328
      goto case_2;
    }
#line 1353
    if (l_size_comp == 4U) {
#line 1353
      goto case_4;
    }
#line 1301
    goto switch_break;
    case_1: 
#line 1305
    l_dest_ptr = (OPJ_CHAR *)p_dest;
#line 1306
    l_src_ptr = l_tilec->data;
#line 1308
    if (l_img_comp->sgnd) {
#line 1309
      j = (OPJ_UINT32 )0;
      {
#line 1309
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 1309
        if (! (j < l_height)) {
#line 1309
          goto while_break___0;
        }
#line 1310
        k = (OPJ_UINT32 )0;
        {
#line 1310
        while (1) {
          while_continue___1: /* CIL Label */ ;

#line 1310
          if (! (k < l_width)) {
#line 1310
            goto while_break___1;
          }
#line 1311
          __cil_tmp20 = l_src_ptr;
#line 1311
          l_src_ptr ++;
#line 1311
          __cil_tmp19 = l_dest_ptr;
#line 1311
          l_dest_ptr ++;
#line 1311
          *__cil_tmp19 = (OPJ_CHAR )*__cil_tmp20;
#line 1310
          k ++;
        }
        while_break___12: /* CIL Label */ ;
        }
        while_break___1: 
#line 1313
        l_src_ptr += l_stride;
#line 1309
        j ++;
      }
      while_break___11: /* CIL Label */ ;
      }
      while_break___0: ;
    } else {
#line 1317
      j = (OPJ_UINT32 )0;
      {
#line 1317
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 1317
        if (! (j < l_height)) {
#line 1317
          goto while_break___2;
        }
#line 1318
        k = (OPJ_UINT32 )0;
        {
#line 1318
        while (1) {
          while_continue___3: /* CIL Label */ ;

#line 1318
          if (! (k < l_width)) {
#line 1318
            goto while_break___3;
          }
#line 1319
          __cil_tmp22 = l_src_ptr;
#line 1319
          l_src_ptr ++;
#line 1319
          __cil_tmp21 = l_dest_ptr;
#line 1319
          l_dest_ptr ++;
#line 1319
          *__cil_tmp21 = (OPJ_CHAR )((OPJ_BYTE )(*__cil_tmp22 & 255));
#line 1318
          k ++;
        }
        while_break___14: /* CIL Label */ ;
        }
        while_break___3: 
#line 1321
        l_src_ptr += l_stride;
#line 1317
        j ++;
      }
      while_break___13: /* CIL Label */ ;
      }
      while_break___2: ;
    }
#line 1325
    p_dest = (OPJ_BYTE *)l_dest_ptr;
#line 1327
    goto switch_break;
    case_2: 
#line 1330
    l_src_ptr___0 = l_tilec->data;
#line 1331
    l_dest_ptr___0 = (OPJ_INT16 *)p_dest;
#line 1333
    if (l_img_comp->sgnd) {
#line 1334
      j = (OPJ_UINT32 )0;
      {
#line 1334
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 1334
        if (! (j < l_height)) {
#line 1334
          goto while_break___4;
        }
#line 1335
        k = (OPJ_UINT32 )0;
        {
#line 1335
        while (1) {
          while_continue___5: /* CIL Label */ ;

#line 1335
          if (! (k < l_width)) {
#line 1335
            goto while_break___5;
          }
#line 1336
          __cil_tmp26 = l_src_ptr___0;
#line 1336
          l_src_ptr___0 ++;
#line 1336
          __cil_tmp25 = l_dest_ptr___0;
#line 1336
          l_dest_ptr___0 ++;
#line 1336
          *__cil_tmp25 = (OPJ_INT16 )*__cil_tmp26;
#line 1335
          k ++;
        }
        while_break___16: /* CIL Label */ ;
        }
        while_break___5: 
#line 1338
        l_src_ptr___0 += l_stride;
#line 1334
        j ++;
      }
      while_break___15: /* CIL Label */ ;
      }
      while_break___4: ;
    } else {
#line 1342
      j = (OPJ_UINT32 )0;
      {
#line 1342
      while (1) {
        while_continue___6: /* CIL Label */ ;

#line 1342
        if (! (j < l_height)) {
#line 1342
          goto while_break___6;
        }
#line 1343
        k = (OPJ_UINT32 )0;
        {
#line 1343
        while (1) {
          while_continue___7: /* CIL Label */ ;

#line 1343
          if (! (k < l_width)) {
#line 1343
            goto while_break___7;
          }
#line 1344
          __cil_tmp28 = l_src_ptr___0;
#line 1344
          l_src_ptr___0 ++;
#line 1344
          __cil_tmp27 = l_dest_ptr___0;
#line 1344
          l_dest_ptr___0 ++;
#line 1344
          *__cil_tmp27 = (OPJ_INT16 )((OPJ_UINT16 )(*__cil_tmp28 & 65535));
#line 1343
          k ++;
        }
        while_break___18: /* CIL Label */ ;
        }
        while_break___7: 
#line 1346
        l_src_ptr___0 += l_stride;
#line 1342
        j ++;
      }
      while_break___17: /* CIL Label */ ;
      }
      while_break___6: ;
    }
#line 1350
    p_dest = (OPJ_BYTE *)l_dest_ptr___0;
#line 1352
    goto switch_break;
    case_4: 
#line 1355
    l_dest_ptr___1 = (OPJ_INT32 *)p_dest;
#line 1356
    l_src_ptr___1 = l_tilec->data;
#line 1358
    j = (OPJ_UINT32 )0;
    {
#line 1358
    while (1) {
      while_continue___8: /* CIL Label */ ;

#line 1358
      if (! (j < l_height)) {
#line 1358
        goto while_break___8;
      }
#line 1359
      k = (OPJ_UINT32 )0;
      {
#line 1359
      while (1) {
        while_continue___9: /* CIL Label */ ;

#line 1359
        if (! (k < l_width)) {
#line 1359
          goto while_break___9;
        }
#line 1360
        __cil_tmp32 = l_src_ptr___1;
#line 1360
        l_src_ptr___1 ++;
#line 1360
        __cil_tmp31 = l_dest_ptr___1;
#line 1360
        l_dest_ptr___1 ++;
#line 1360
        *__cil_tmp31 = *__cil_tmp32;
#line 1359
        k ++;
      }
      while_break___20: /* CIL Label */ ;
      }
      while_break___9: 
#line 1362
      l_src_ptr___1 += l_stride;
#line 1358
      j ++;
    }
    while_break___19: /* CIL Label */ ;
    }
    while_break___8: 
#line 1365
    p_dest = (OPJ_BYTE *)l_dest_ptr___1;
#line 1367
    goto switch_break;
    switch_break: 
#line 1370
    l_img_comp ++;
#line 1371
    l_tilec ++;
#line 1285
    i ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break: ;
#line 1374
  return (1);
}
}
#line 1380 "/root/patron/new_22/src/lib/openjp2/tcd.c"
void opj_tcd_free_tile(opj_tcd_t *p_tcd ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 bandno ;
  OPJ_UINT32 precno ;
  opj_tcd_tile_t *l_tile ;
  opj_tcd_tilecomp_t *l_tile_comp ;
  opj_tcd_resolution_t *l_res ;
  opj_tcd_band_t *l_band ;
  opj_tcd_precinct_t *l_precinct ;
  OPJ_UINT32 l_nb_resolutions ;
  OPJ_UINT32 l_nb_precincts ;
  void (*l_tcd_code_block_deallocate)(opj_tcd_precinct_t * ) ;

  {
#line 1383
  l_tile = (opj_tcd_tile_t *)0;
#line 1384
  l_tile_comp = (opj_tcd_tilecomp_t *)0;
#line 1385
  l_res = (opj_tcd_resolution_t *)0;
#line 1386
  l_band = (opj_tcd_band_t *)0;
#line 1387
  l_precinct = (opj_tcd_precinct_t *)0;
#line 1389
  l_tcd_code_block_deallocate = (void (*)(opj_tcd_precinct_t * ))0;
#line 1391
  if (! p_tcd) {
#line 1392
    return;
  }
#line 1395
  if (! p_tcd->tcd_image) {
#line 1396
    return;
  }
#line 1399
  if (p_tcd->m_is_decoder) {
#line 1400
    l_tcd_code_block_deallocate = & opj_tcd_code_block_dec_deallocate;
  } else {
#line 1403
    l_tcd_code_block_deallocate = & opj_tcd_code_block_enc_deallocate;
  }
#line 1406
  l_tile = (p_tcd->tcd_image)->tiles;
#line 1407
  if (! l_tile) {
#line 1408
    return;
  }
#line 1411
  l_tile_comp = l_tile->comps;
#line 1413
  compno = (OPJ_UINT32 )0;
  {
#line 1413
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1413
    if (! (compno < l_tile->numcomps)) {
#line 1413
      goto while_break;
    }
#line 1414
    l_res = l_tile_comp->resolutions;
#line 1415
    if (l_res) {
#line 1417
      l_nb_resolutions = (OPJ_UINT32 )((unsigned long )l_tile_comp->resolutions_size / sizeof(opj_tcd_resolution_t ));
#line 1418
      resno = (OPJ_UINT32 )0;
      {
#line 1418
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 1418
        if (! (resno < l_nb_resolutions)) {
#line 1418
          goto while_break___0;
        }
#line 1419
        l_band = l_res->bands;
#line 1420
        bandno = (OPJ_UINT32 )0;
        {
#line 1420
        while (1) {
          while_continue___1: /* CIL Label */ ;

#line 1420
          if (! (bandno < 3U)) {
#line 1420
            goto while_break___1;
          }
#line 1421
          l_precinct = l_band->precincts;
#line 1422
          if (l_precinct) {
#line 1424
            l_nb_precincts = (OPJ_UINT32 )((unsigned long )l_band->precincts_data_size / sizeof(opj_tcd_precinct_t ));
#line 1425
            precno = (OPJ_UINT32 )0;
            {
#line 1425
            while (1) {
              while_continue___2: /* CIL Label */ ;

#line 1425
              if (! (precno < l_nb_precincts)) {
#line 1425
                goto while_break___2;
              }
              {
#line 1426
              opj_tgt_destroy(l_precinct->incltree);
#line 1427
              l_precinct->incltree = (opj_tgt_tree_t *)0;
#line 1428
              opj_tgt_destroy(l_precinct->imsbtree);
#line 1429
              l_precinct->imsbtree = (opj_tgt_tree_t *)0;
#line 1430
              (*l_tcd_code_block_deallocate)(l_precinct);
#line 1431
              l_precinct ++;
#line 1425
              precno ++;
              }
            }
            while_break___6: /* CIL Label */ ;
            }
            while_break___2: 
            {
#line 1434
            free((void *)l_band->precincts);
#line 1435
            l_band->precincts = (opj_tcd_precinct_t *)0;
            }
          }
#line 1437
          l_band ++;
#line 1420
          bandno ++;
        }
        while_break___5: /* CIL Label */ ;
        }
        while_break___1: 
#line 1439
        l_res ++;
#line 1418
        resno ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___0: 
      {
#line 1442
      free((void *)l_tile_comp->resolutions);
#line 1443
      l_tile_comp->resolutions = (opj_tcd_resolution_t *)0;
      }
    }
#line 1446
    if (l_tile_comp->data) {
      {
#line 1447
      free((void *)l_tile_comp->data);
#line 1448
      l_tile_comp->data = (OPJ_INT32 *)0;
      }
    }
#line 1450
    l_tile_comp ++;
#line 1413
    compno ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1453
  free((void *)l_tile->comps);
#line 1454
  l_tile->comps = (opj_tcd_tilecomp_t *)0;
#line 1455
  free((void *)(p_tcd->tcd_image)->tiles);
#line 1456
  (p_tcd->tcd_image)->tiles = (opj_tcd_tile_t *)0;
  }
#line 1458
  return;
}
}
#line 1460 "/root/patron/new_22/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_t2_decode(opj_tcd_t *p_tcd , OPJ_BYTE *p_src_data , OPJ_UINT32 *p_data_read ,
                           OPJ_UINT32 p_max_src_size , opj_codestream_index_t *p_cstr_index ) 
{ 
  opj_t2_t *l_t2 ;
  OPJ_BOOL __cil_tmp8 ;

  {
  {
#line 1469
  l_t2 = opj_t2_create(p_tcd->image, p_tcd->cp);
  }
#line 1470
  if ((unsigned long )l_t2 == (unsigned long )((opj_t2_t *)0)) {
#line 1471
    return (0);
  }
  {
#line 1474
  __cil_tmp8 = opj_t2_decode_packets(l_t2, p_tcd->tcd_tileno, (p_tcd->tcd_image)->tiles,
                                     p_src_data, p_data_read, p_max_src_size, p_cstr_index);
  }
#line 1474
  if (! __cil_tmp8) {
    {
#line 1482
    opj_t2_destroy(l_t2);
    }
#line 1483
    return (0);
  }
  {
#line 1486
  opj_t2_destroy(l_t2);
  }
#line 1489
  return (1);
}
}
#line 1492 "/root/patron/new_22/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_t1_decode(opj_tcd_t *p_tcd ) 
{ 
  OPJ_UINT32 compno ;
  opj_t1_t *l_t1 ;
  opj_tcd_tile_t *l_tile ;
  opj_tcd_tilecomp_t *l_tile_comp ;
  opj_tccp_t *l_tccp ;
  OPJ_BOOL __cil_tmp8 ;

  {
  {
#line 1496
  l_tile = (p_tcd->tcd_image)->tiles;
#line 1497
  l_tile_comp = l_tile->comps;
#line 1498
  l_tccp = (p_tcd->tcp)->tccps;
#line 1501
  l_t1 = opj_t1_create();
  }
#line 1502
  if ((unsigned long )l_t1 == (unsigned long )((opj_t1_t *)0)) {
#line 1503
    return (0);
  }
#line 1506
  compno = (OPJ_UINT32 )0;
  {
#line 1506
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1506
    if (! (compno < l_tile->numcomps)) {
#line 1506
      goto while_break;
    }
    {
#line 1508
    __cil_tmp8 = opj_t1_decode_cblks(l_t1, l_tile_comp, l_tccp);
    }
#line 1508
    if (0 == __cil_tmp8) {
      {
#line 1509
      opj_t1_destroy(l_t1);
      }
#line 1510
      return (0);
    }
#line 1512
    l_tile_comp ++;
#line 1513
    l_tccp ++;
#line 1506
    compno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1516
  opj_t1_destroy(l_t1);
  }
#line 1518
  return (1);
}
}
#line 1522 "/root/patron/new_22/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_dwt_decode(opj_tcd_t *p_tcd ) 
{ 
  OPJ_UINT32 compno ;
  opj_tcd_tile_t *l_tile ;
  opj_tcd_tilecomp_t *l_tile_comp ;
  opj_tccp_t *l_tccp ;
  opj_image_comp_t *l_img_comp ;
  OPJ_BOOL __cil_tmp7 ;
  OPJ_BOOL __cil_tmp8 ;

  {
#line 1525
  l_tile = (p_tcd->tcd_image)->tiles;
#line 1526
  l_tile_comp = l_tile->comps;
#line 1527
  l_tccp = (p_tcd->tcp)->tccps;
#line 1528
  l_img_comp = (p_tcd->image)->comps;
#line 1530
  compno = (OPJ_UINT32 )0;
  {
#line 1530
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1530
    if (! (compno < l_tile->numcomps)) {
#line 1530
      goto while_break;
    }
#line 1544
    if (l_tccp->qmfbid == 1U) {
      {
#line 1545
      __cil_tmp7 = opj_dwt_decode(l_tile_comp, l_img_comp->resno_decoded + 1U);
      }
#line 1545
      if (! __cil_tmp7) {
#line 1546
        return (0);
      }
    } else {
      {
#line 1550
      __cil_tmp8 = opj_dwt_decode_real(l_tile_comp, l_img_comp->resno_decoded + 1U);
      }
#line 1550
      if (! __cil_tmp8) {
#line 1551
        return (0);
      }
    }
#line 1555
    l_tile_comp ++;
#line 1556
    l_img_comp ++;
#line 1557
    l_tccp ++;
#line 1530
    compno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1560
  return (1);
}
}
#line 1562 "/root/patron/new_22/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_mct_decode(opj_tcd_t *p_tcd ) 
{ 
  opj_tcd_tile_t *l_tile ;
  opj_tcp_t *l_tcp ;
  opj_tcd_tilecomp_t *l_tile_comp ;
  OPJ_UINT32 l_samples ;
  OPJ_UINT32 i ;
  OPJ_BYTE **l_data ;
  void *__cil_tmp8 ;
  OPJ_BOOL __cil_tmp9 ;

  {
#line 1564
  l_tile = (p_tcd->tcd_image)->tiles;
#line 1565
  l_tcp = p_tcd->tcp;
#line 1566
  l_tile_comp = l_tile->comps;
#line 1569
  if (! l_tcp->mct) {
#line 1570
    return (1);
  }
#line 1573
  l_samples = (OPJ_UINT32 )((l_tile_comp->x1 - l_tile_comp->x0) * (l_tile_comp->y1 - l_tile_comp->y0));
#line 1575
  if (l_tile->numcomps >= 3U) {
#line 1576
    if (l_tcp->mct == 2U) {
#line 1579
      if (! l_tcp->m_mct_decoding_matrix) {
#line 1580
        return (1);
      }
      {
#line 1583
      __cil_tmp8 = malloc((unsigned long )l_tile->numcomps * sizeof(OPJ_BYTE *));
#line 1583
      l_data = (OPJ_BYTE **)__cil_tmp8;
      }
#line 1584
      if (! l_data) {
#line 1585
        return (0);
      }
#line 1588
      i = (OPJ_UINT32 )0;
      {
#line 1588
      while (1) {
        while_continue: /* CIL Label */ ;

#line 1588
        if (! (i < l_tile->numcomps)) {
#line 1588
          goto while_break;
        }
#line 1589
        *(l_data + i) = (OPJ_BYTE *)l_tile_comp->data;
#line 1590
        l_tile_comp ++;
#line 1588
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: 
      {
#line 1593
      __cil_tmp9 = opj_mct_decode_custom((OPJ_BYTE *)l_tcp->m_mct_decoding_matrix,
                                         l_samples, l_data, l_tile->numcomps, ((p_tcd->image)->comps)->sgnd);
      }
#line 1593
      if (! __cil_tmp9) {
        {
#line 1603
        free((void *)l_data);
        }
#line 1604
        return (0);
      }
      {
#line 1607
      free((void *)l_data);
      }
    } else
#line 1610
    if ((l_tcp->tccps)->qmfbid == 1U) {
      {
#line 1611
      opj_mct_decode((l_tile->comps + 0)->data, (l_tile->comps + 1)->data, (l_tile->comps + 2)->data,
                     l_samples);
      }
    } else {
      {
#line 1617
      opj_mct_decode_real((OPJ_FLOAT32 *)(l_tile->comps + 0)->data, (OPJ_FLOAT32 *)(l_tile->comps + 1)->data,
                          (OPJ_FLOAT32 *)(l_tile->comps + 2)->data, l_samples);
      }
    }
  } else {
    {
#line 1626
    fprintf(stderr, "Number of components (%d) is inconsistent with a MCT. Skip the MCT step.\n",
            l_tile->numcomps);
    }
  }
#line 1629
  return (1);
}
}
#line 1633 "/root/patron/new_22/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_dc_level_shift_decode(opj_tcd_t *p_tcd ) 
{ 
  OPJ_UINT32 compno ;
  opj_tcd_tilecomp_t *l_tile_comp ;
  opj_tccp_t *l_tccp ;
  opj_image_comp_t *l_img_comp ;
  opj_tcd_resolution_t *l_res ;
  opj_tcd_tile_t *l_tile ;
  OPJ_UINT32 l_width ;
  OPJ_UINT32 l_height ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_INT32 *l_current_ptr ;
  OPJ_INT32 l_min ;
  OPJ_INT32 l_max ;
  OPJ_UINT32 l_stride ;
  OPJ_FLOAT32 l_value ;
  long __cil_tmp18 ;
  OPJ_INT32 __cil_tmp19 ;

  {
#line 1636
  l_tile_comp = (opj_tcd_tilecomp_t *)0;
#line 1637
  l_tccp = (opj_tccp_t *)0;
#line 1638
  l_img_comp = (opj_image_comp_t *)0;
#line 1639
  l_res = (opj_tcd_resolution_t *)0;
#line 1646
  l_tile = (p_tcd->tcd_image)->tiles;
#line 1647
  l_tile_comp = l_tile->comps;
#line 1648
  l_tccp = (p_tcd->tcp)->tccps;
#line 1649
  l_img_comp = (p_tcd->image)->comps;
#line 1651
  compno = (OPJ_UINT32 )0;
  {
#line 1651
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1651
    if (! (compno < l_tile->numcomps)) {
#line 1651
      goto while_break;
    }
#line 1652
    l_res = l_tile_comp->resolutions + l_img_comp->resno_decoded;
#line 1653
    l_width = (OPJ_UINT32 )(l_res->x1 - l_res->x0);
#line 1654
    l_height = (OPJ_UINT32 )(l_res->y1 - l_res->y0);
#line 1655
    l_stride = (unsigned int )(l_tile_comp->x1 - l_tile_comp->x0) - l_width;
#line 1657
    if (l_img_comp->sgnd) {
#line 1658
      l_min = - (1 << (l_img_comp->prec - 1U));
#line 1659
      l_max = (1 << (l_img_comp->prec - 1U)) - 1;
    } else {
#line 1662
      l_min = 0;
#line 1663
      l_max = (1 << l_img_comp->prec) - 1;
    }
#line 1666
    l_current_ptr = l_tile_comp->data;
#line 1668
    if (l_tccp->qmfbid == 1U) {
#line 1669
      j = (OPJ_UINT32 )0;
      {
#line 1669
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 1669
        if (! (j < l_height)) {
#line 1669
          goto while_break___0;
        }
#line 1670
        i = (OPJ_UINT32 )0;
        {
#line 1670
        while (1) {
          while_continue___1: /* CIL Label */ ;

#line 1670
          if (! (i < l_width)) {
#line 1670
            goto while_break___1;
          }
          {
#line 1671
          *l_current_ptr = opj_int_clamp(*l_current_ptr + l_tccp->m_dc_level_shift,
                                         l_min, l_max);
#line 1672
          l_current_ptr ++;
#line 1670
          i ++;
          }
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___1: 
#line 1674
        l_current_ptr += l_stride;
#line 1669
        j ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___0: ;
    } else {
#line 1678
      j = (OPJ_UINT32 )0;
      {
#line 1678
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 1678
        if (! (j < l_height)) {
#line 1678
          goto while_break___2;
        }
#line 1679
        i = (OPJ_UINT32 )0;
        {
#line 1679
        while (1) {
          while_continue___3: /* CIL Label */ ;

#line 1679
          if (! (i < l_width)) {
#line 1679
            goto while_break___3;
          }
          {
#line 1680
          l_value = *((OPJ_FLOAT32 *)l_current_ptr);
#line 1681
          __cil_tmp18 = lrintf(l_value);
#line 1681
          __cil_tmp19 = opj_int_clamp((OPJ_INT32 )(__cil_tmp18 + (long )l_tccp->m_dc_level_shift),
                                      l_min, l_max);
#line 1681
          *l_current_ptr = __cil_tmp19;
#line 1682
          l_current_ptr ++;
#line 1679
          i ++;
          }
        }
        while_break___8: /* CIL Label */ ;
        }
        while_break___3: 
#line 1684
        l_current_ptr += l_stride;
#line 1678
        j ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___2: ;
    }
#line 1688
    l_img_comp ++;
#line 1689
    l_tccp ++;
#line 1690
    l_tile_comp ++;
#line 1651
    compno ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: ;
#line 1693
  return (1);
}
}
#line 1701 "/root/patron/new_22/src/lib/openjp2/tcd.c"
void opj_tcd_code_block_dec_deallocate(opj_tcd_precinct_t *p_precinct ) 
{ 
  OPJ_UINT32 cblkno ;
  OPJ_UINT32 l_nb_code_blocks ;
  opj_tcd_cblk_dec_t *l_code_block ;

  {
#line 1705
  l_code_block = p_precinct->cblks.dec;
#line 1706
  if (l_code_block) {
#line 1713
    l_nb_code_blocks = (OPJ_UINT32 )((unsigned long )p_precinct->block_size / sizeof(opj_tcd_cblk_dec_t ));
#line 1716
    cblkno = (OPJ_UINT32 )0;
    {
#line 1716
    while (1) {
      while_continue: /* CIL Label */ ;

#line 1716
      if (! (cblkno < l_nb_code_blocks)) {
#line 1716
        goto while_break;
      }
#line 1718
      if (l_code_block->data) {
        {
#line 1719
        free((void *)l_code_block->data);
#line 1720
        l_code_block->data = (OPJ_BYTE *)0;
        }
      }
#line 1723
      if (l_code_block->segs) {
        {
#line 1724
        free((void *)l_code_block->segs);
#line 1725
        l_code_block->segs = (opj_tcd_seg_t *)0;
        }
      }
#line 1728
      l_code_block ++;
#line 1716
      cblkno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: 
    {
#line 1731
    free((void *)p_precinct->cblks.dec);
#line 1732
    p_precinct->cblks.dec = (opj_tcd_cblk_dec_t *)0;
    }
  }
#line 1735
  return;
}
}
#line 1739 "/root/patron/new_22/src/lib/openjp2/tcd.c"
void opj_tcd_code_block_enc_deallocate(opj_tcd_precinct_t *p_precinct ) 
{ 
  OPJ_UINT32 cblkno ;
  OPJ_UINT32 l_nb_code_blocks ;
  opj_tcd_cblk_enc_t *l_code_block ;

  {
#line 1743
  l_code_block = p_precinct->cblks.enc;
#line 1744
  if (l_code_block) {
#line 1745
    l_nb_code_blocks = (OPJ_UINT32 )((unsigned long )p_precinct->block_size / sizeof(opj_tcd_cblk_enc_t ));
#line 1747
    cblkno = (OPJ_UINT32 )0;
    {
#line 1747
    while (1) {
      while_continue: /* CIL Label */ ;

#line 1747
      if (! (cblkno < l_nb_code_blocks)) {
#line 1747
        goto while_break;
      }
#line 1748
      if (l_code_block->data) {
        {
#line 1749
        free((void *)(l_code_block->data - 1));
#line 1750
        l_code_block->data = (OPJ_BYTE *)0;
        }
      }
#line 1753
      if (l_code_block->layers) {
        {
#line 1754
        free((void *)l_code_block->layers);
#line 1755
        l_code_block->layers = (opj_tcd_layer_t *)0;
        }
      }
#line 1758
      if (l_code_block->passes) {
        {
#line 1759
        free((void *)l_code_block->passes);
#line 1760
        l_code_block->passes = (opj_tcd_pass_t *)0;
        }
      }
#line 1762
      l_code_block ++;
#line 1747
      cblkno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: 
    {
#line 1765
    free((void *)p_precinct->cblks.enc);
#line 1767
    p_precinct->cblks.enc = (opj_tcd_cblk_enc_t *)0;
    }
  }
#line 1770
  return;
}
}
#line 1771 "/root/patron/new_22/src/lib/openjp2/tcd.c"
OPJ_UINT32 opj_tcd_get_encoded_tile_size(opj_tcd_t *p_tcd ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_data_size ;
  opj_image_comp_t *l_img_comp ;
  opj_tcd_tilecomp_t *l_tilec ;
  OPJ_UINT32 l_size_comp ;
  OPJ_UINT32 l_remaining ;

  {
#line 1773
  l_data_size = (OPJ_UINT32 )0;
#line 1774
  l_img_comp = (opj_image_comp_t *)0;
#line 1775
  l_tilec = (opj_tcd_tilecomp_t *)0;
#line 1778
  l_tilec = ((p_tcd->tcd_image)->tiles)->comps;
#line 1779
  l_img_comp = (p_tcd->image)->comps;
#line 1780
  i = (OPJ_UINT32 )0;
  {
#line 1780
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1780
    if (! (i < (p_tcd->image)->numcomps)) {
#line 1780
      goto while_break;
    }
#line 1781
    l_size_comp = l_img_comp->prec >> 3;
#line 1782
    l_remaining = l_img_comp->prec & 7U;
#line 1784
    if (l_remaining) {
#line 1785
      l_size_comp ++;
    }
#line 1788
    if (l_size_comp == 3U) {
#line 1789
      l_size_comp = (OPJ_UINT32 )4;
    }
#line 1792
    l_data_size += (l_size_comp * (unsigned int )(l_tilec->x1 - l_tilec->x0)) * (unsigned int )(l_tilec->y1 - l_tilec->y0);
#line 1793
    l_img_comp ++;
#line 1794
    l_tilec ++;
#line 1780
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1797
  return (l_data_size);
}
}
#line 1800 "/root/patron/new_22/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_dc_level_shift_encode(opj_tcd_t *p_tcd ) 
{ 
  OPJ_UINT32 compno ;
  opj_tcd_tilecomp_t *l_tile_comp ;
  opj_tccp_t *l_tccp ;
  opj_image_comp_t *l_img_comp ;
  opj_tcd_tile_t *l_tile ;
  OPJ_UINT32 l_nb_elem ;
  OPJ_UINT32 i ;
  OPJ_INT32 *l_current_ptr ;

  {
#line 1803
  l_tile_comp = (opj_tcd_tilecomp_t *)0;
#line 1804
  l_tccp = (opj_tccp_t *)0;
#line 1805
  l_img_comp = (opj_image_comp_t *)0;
#line 1810
  l_tile = (p_tcd->tcd_image)->tiles;
#line 1811
  l_tile_comp = l_tile->comps;
#line 1812
  l_tccp = (p_tcd->tcp)->tccps;
#line 1813
  l_img_comp = (p_tcd->image)->comps;
#line 1815
  compno = (OPJ_UINT32 )0;
  {
#line 1815
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1815
    if (! (compno < l_tile->numcomps)) {
#line 1815
      goto while_break;
    }
#line 1816
    l_current_ptr = l_tile_comp->data;
#line 1817
    l_nb_elem = (OPJ_UINT32 )((l_tile_comp->x1 - l_tile_comp->x0) * (l_tile_comp->y1 - l_tile_comp->y0));
#line 1819
    if (l_tccp->qmfbid == 1U) {
#line 1820
      i = (OPJ_UINT32 )0;
      {
#line 1820
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 1820
        if (! (i < l_nb_elem)) {
#line 1820
          goto while_break___0;
        }
#line 1821
        *l_current_ptr -= l_tccp->m_dc_level_shift;
#line 1822
        l_current_ptr ++;
#line 1820
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break___0: ;
    } else {
#line 1826
      i = (OPJ_UINT32 )0;
      {
#line 1826
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 1826
        if (! (i < l_nb_elem)) {
#line 1826
          goto while_break___1;
        }
#line 1827
        *l_current_ptr = (*l_current_ptr - l_tccp->m_dc_level_shift) << 11;
#line 1828
        l_current_ptr ++;
#line 1826
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: ;
    }
#line 1832
    l_img_comp ++;
#line 1833
    l_tccp ++;
#line 1834
    l_tile_comp ++;
#line 1815
    compno ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 1837
  return (1);
}
}
#line 1840 "/root/patron/new_22/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_mct_encode(opj_tcd_t *p_tcd ) 
{ 
  opj_tcd_tile_t *l_tile ;
  opj_tcd_tilecomp_t *l_tile_comp ;
  OPJ_UINT32 samples ;
  OPJ_UINT32 i ;
  OPJ_BYTE **l_data ;
  opj_tcp_t *l_tcp ;
  void *__cil_tmp8 ;
  OPJ_BOOL __cil_tmp9 ;

  {
#line 1842
  l_tile = (p_tcd->tcd_image)->tiles;
#line 1843
  l_tile_comp = ((p_tcd->tcd_image)->tiles)->comps;
#line 1844
  samples = (OPJ_UINT32 )((l_tile_comp->x1 - l_tile_comp->x0) * (l_tile_comp->y1 - l_tile_comp->y0));
#line 1846
  l_data = (OPJ_BYTE **)0;
#line 1847
  l_tcp = p_tcd->tcp;
#line 1849
  if (! (p_tcd->tcp)->mct) {
#line 1850
    return (1);
  }
#line 1853
  if ((p_tcd->tcp)->mct == 2U) {
#line 1854
    if (! (p_tcd->tcp)->m_mct_coding_matrix) {
#line 1855
      return (1);
    }
    {
#line 1858
    __cil_tmp8 = malloc((unsigned long )l_tile->numcomps * sizeof(OPJ_BYTE *));
#line 1858
    l_data = (OPJ_BYTE **)__cil_tmp8;
    }
#line 1859
    if (! l_data) {
#line 1860
      return (0);
    }
#line 1863
    i = (OPJ_UINT32 )0;
    {
#line 1863
    while (1) {
      while_continue: /* CIL Label */ ;

#line 1863
      if (! (i < l_tile->numcomps)) {
#line 1863
        goto while_break;
      }
#line 1864
      *(l_data + i) = (OPJ_BYTE *)l_tile_comp->data;
#line 1865
      l_tile_comp ++;
#line 1863
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: 
    {
#line 1868
    __cil_tmp9 = opj_mct_encode_custom((OPJ_BYTE *)(p_tcd->tcp)->m_mct_coding_matrix,
                                       samples, l_data, l_tile->numcomps, ((p_tcd->image)->comps)->sgnd);
    }
#line 1868
    if (! __cil_tmp9) {
      {
#line 1879
      free((void *)l_data);
      }
#line 1880
      return (0);
    }
    {
#line 1883
    free((void *)l_data);
    }
  } else
#line 1885
  if ((l_tcp->tccps)->qmfbid == 0U) {
    {
#line 1886
    opj_mct_encode_real((l_tile->comps + 0)->data, (l_tile->comps + 1)->data, (l_tile->comps + 2)->data,
                        samples);
    }
  } else {
    {
#line 1889
    opj_mct_encode((l_tile->comps + 0)->data, (l_tile->comps + 1)->data, (l_tile->comps + 2)->data,
                   samples);
    }
  }
#line 1892
  return (1);
}
}
#line 1895 "/root/patron/new_22/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_dwt_encode(opj_tcd_t *p_tcd ) 
{ 
  opj_tcd_tile_t *l_tile ;
  opj_tcd_tilecomp_t *l_tile_comp ;
  opj_tccp_t *l_tccp ;
  OPJ_UINT32 compno ;
  OPJ_BOOL __cil_tmp6 ;
  OPJ_BOOL __cil_tmp7 ;

  {
#line 1897
  l_tile = (p_tcd->tcd_image)->tiles;
#line 1898
  l_tile_comp = ((p_tcd->tcd_image)->tiles)->comps;
#line 1899
  l_tccp = (p_tcd->tcp)->tccps;
#line 1902
  compno = (OPJ_UINT32 )0;
  {
#line 1902
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1902
    if (! (compno < l_tile->numcomps)) {
#line 1902
      goto while_break;
    }
#line 1903
    if (l_tccp->qmfbid == 1U) {
      {
#line 1904
      __cil_tmp6 = opj_dwt_encode(l_tile_comp);
      }
#line 1904
      if (! __cil_tmp6) {
#line 1905
        return (0);
      }
    } else
#line 1908
    if (l_tccp->qmfbid == 0U) {
      {
#line 1909
      __cil_tmp7 = opj_dwt_encode_real(l_tile_comp);
      }
#line 1909
      if (! __cil_tmp7) {
#line 1910
        return (0);
      }
    }
#line 1914
    l_tile_comp ++;
#line 1915
    l_tccp ++;
#line 1902
    compno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1918
  return (1);
}
}
#line 1921 "/root/patron/new_22/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_t1_encode(opj_tcd_t *p_tcd ) 
{ 
  opj_t1_t *l_t1 ;
  OPJ_FLOAT64 *l_mct_norms ;
  opj_tcp_t *l_tcp ;
  OPJ_BOOL __cil_tmp8 ;

  {
  {
#line 1925
  l_tcp = p_tcd->tcp;
#line 1927
  l_t1 = opj_t1_create();
  }
#line 1928
  if ((unsigned long )l_t1 == (unsigned long )((opj_t1_t *)0)) {
#line 1929
    return (0);
  }
#line 1932
  if (l_tcp->mct == 1U) {
#line 1934
    if ((l_tcp->tccps)->qmfbid == 0U) {
      {
#line 1935
      l_mct_norms = opj_mct_get_mct_norms_real();
      }
    } else {
      {
#line 1938
      l_mct_norms = opj_mct_get_mct_norms();
      }
    }
  } else {
#line 1942
    l_mct_norms = l_tcp->mct_norms;
  }
  {
#line 1945
  __cil_tmp8 = opj_t1_encode_cblks(l_t1, (p_tcd->tcd_image)->tiles, l_tcp, l_mct_norms);
  }
#line 1945
  if (! __cil_tmp8) {
    {
#line 1946
    opj_t1_destroy(l_t1);
    }
#line 1947
    return (0);
  }
  {
#line 1950
  opj_t1_destroy(l_t1);
  }
#line 1952
  return (1);
}
}
#line 1955 "/root/patron/new_22/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_t2_encode(opj_tcd_t *p_tcd , OPJ_BYTE *p_dest_data , OPJ_UINT32 *p_data_written ,
                           OPJ_UINT32 p_max_dest_size , opj_codestream_info_t *p_cstr_info ) 
{ 
  opj_t2_t *l_t2 ;
  OPJ_BOOL __cil_tmp8 ;

  {
  {
#line 1963
  l_t2 = opj_t2_create(p_tcd->image, p_tcd->cp);
  }
#line 1964
  if ((unsigned long )l_t2 == (unsigned long )((opj_t2_t *)0)) {
#line 1965
    return (0);
  }
  {
#line 1968
  __cil_tmp8 = opj_t2_encode_packets(l_t2, p_tcd->tcd_tileno, (p_tcd->tcd_image)->tiles,
                                     (p_tcd->tcp)->numlayers, p_dest_data, p_data_written,
                                     p_max_dest_size, p_cstr_info, p_tcd->tp_num,
                                     p_tcd->tp_pos, p_tcd->cur_pino, (J2K_T2_MODE )1);
  }
#line 1968
  if (! __cil_tmp8) {
    {
#line 1982
    opj_t2_destroy(l_t2);
    }
#line 1983
    return (0);
  }
  {
#line 1986
  opj_t2_destroy(l_t2);
  }
#line 1989
  return (1);
}
}
#line 1993 "/root/patron/new_22/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_rate_allocate_encode(opj_tcd_t *p_tcd , OPJ_BYTE *p_dest_data , OPJ_UINT32 p_max_dest_size ,
                                      opj_codestream_info_t *p_cstr_info ) 
{ 
  opj_cp_t *l_cp ;
  OPJ_UINT32 l_nb_written ;
  OPJ_BOOL __cil_tmp7 ;

  {
#line 1998
  l_cp = p_tcd->cp;
#line 1999
  l_nb_written = (OPJ_UINT32 )0;
#line 2001
  if (p_cstr_info) {
#line 2002
    p_cstr_info->index_write = 0;
  }
#line 2005
  if ((int )l_cp->m_specific_param.m_enc.m_disto_alloc) {
    _L: 
    {
#line 2008
    __cil_tmp7 = opj_tcd_rateallocate(p_tcd, p_dest_data, & l_nb_written, p_max_dest_size,
                                      p_cstr_info);
    }
#line 2008
    if (! __cil_tmp7) {
#line 2009
      return (0);
    }
  } else
#line 2005
  if ((int )l_cp->m_specific_param.m_enc.m_fixed_quality) {
#line 2005
    goto _L;
  } else {
    {
#line 2014
    opj_tcd_rateallocate_fixed(p_tcd);
    }
  }
#line 2017
  return (1);
}
}
#line 2021 "/root/patron/new_22/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_copy_tile_data(opj_tcd_t *p_tcd , OPJ_BYTE *p_src , OPJ_UINT32 p_src_length ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 l_data_size ;
  opj_image_comp_t *l_img_comp ;
  opj_tcd_tilecomp_t *l_tilec ;
  OPJ_UINT32 l_size_comp ;
  OPJ_UINT32 l_remaining ;
  OPJ_UINT32 l_nb_elem ;
  OPJ_CHAR *l_src_ptr ;
  OPJ_INT32 *l_dest_ptr ;
  OPJ_INT32 *__cil_tmp15 ;
  OPJ_CHAR *__cil_tmp16 ;
  OPJ_INT32 *__cil_tmp17 ;
  OPJ_CHAR *__cil_tmp18 ;
  OPJ_INT32 *l_dest_ptr___0 ;
  OPJ_INT16 *l_src_ptr___0 ;
  OPJ_INT32 *__cil_tmp21 ;
  OPJ_INT16 *__cil_tmp22 ;
  OPJ_INT32 *__cil_tmp23 ;
  OPJ_INT16 *__cil_tmp24 ;
  OPJ_INT32 *l_src_ptr___1 ;
  OPJ_INT32 *l_dest_ptr___1 ;
  OPJ_INT32 *__cil_tmp27 ;
  OPJ_INT32 *__cil_tmp28 ;

  {
  {
#line 2025
  l_data_size = (OPJ_UINT32 )0;
#line 2026
  l_img_comp = (opj_image_comp_t *)0;
#line 2027
  l_tilec = (opj_tcd_tilecomp_t *)0;
#line 2031
  l_data_size = opj_tcd_get_encoded_tile_size(p_tcd);
  }
#line 2032
  if (l_data_size != p_src_length) {
#line 2033
    return (0);
  }
#line 2036
  l_tilec = ((p_tcd->tcd_image)->tiles)->comps;
#line 2037
  l_img_comp = (p_tcd->image)->comps;
#line 2038
  i = (OPJ_UINT32 )0;
  {
#line 2038
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2038
    if (! (i < (p_tcd->image)->numcomps)) {
#line 2038
      goto while_break;
    }
#line 2039
    l_size_comp = l_img_comp->prec >> 3;
#line 2040
    l_remaining = l_img_comp->prec & 7U;
#line 2041
    l_nb_elem = (OPJ_UINT32 )((l_tilec->x1 - l_tilec->x0) * (l_tilec->y1 - l_tilec->y0));
#line 2043
    if (l_remaining) {
#line 2044
      l_size_comp ++;
    }
#line 2047
    if (l_size_comp == 3U) {
#line 2048
      l_size_comp = (OPJ_UINT32 )4;
    }
#line 2052
    if (l_size_comp == 1U) {
#line 2052
      goto case_1;
    }
#line 2071
    if (l_size_comp == 2U) {
#line 2071
      goto case_2;
    }
#line 2090
    if (l_size_comp == 4U) {
#line 2090
      goto case_4;
    }
#line 2051
    goto switch_break;
    case_1: 
#line 2054
    l_src_ptr = (OPJ_CHAR *)p_src;
#line 2055
    l_dest_ptr = l_tilec->data;
#line 2057
    if (l_img_comp->sgnd) {
#line 2058
      j = (OPJ_UINT32 )0;
      {
#line 2058
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 2058
        if (! (j < l_nb_elem)) {
#line 2058
          goto while_break___0;
        }
#line 2059
        __cil_tmp16 = l_src_ptr;
#line 2059
        l_src_ptr ++;
#line 2059
        __cil_tmp15 = l_dest_ptr;
#line 2059
        l_dest_ptr ++;
#line 2059
        *__cil_tmp15 = (OPJ_INT32 )*__cil_tmp16;
#line 2058
        j ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___0: ;
    } else {
#line 2063
      j = (OPJ_UINT32 )0;
      {
#line 2063
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 2063
        if (! (j < l_nb_elem)) {
#line 2063
          goto while_break___1;
        }
#line 2064
        __cil_tmp18 = l_src_ptr;
#line 2064
        l_src_ptr ++;
#line 2064
        __cil_tmp17 = l_dest_ptr;
#line 2064
        l_dest_ptr ++;
#line 2064
        *__cil_tmp17 = (int )*__cil_tmp18 & 255;
#line 2063
        j ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___1: ;
    }
#line 2068
    p_src = (OPJ_BYTE *)l_src_ptr;
#line 2070
    goto switch_break;
    case_2: 
#line 2073
    l_dest_ptr___0 = l_tilec->data;
#line 2074
    l_src_ptr___0 = (OPJ_INT16 *)p_src;
#line 2076
    if (l_img_comp->sgnd) {
#line 2077
      j = (OPJ_UINT32 )0;
      {
#line 2077
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 2077
        if (! (j < l_nb_elem)) {
#line 2077
          goto while_break___2;
        }
#line 2078
        __cil_tmp22 = l_src_ptr___0;
#line 2078
        l_src_ptr___0 ++;
#line 2078
        __cil_tmp21 = l_dest_ptr___0;
#line 2078
        l_dest_ptr___0 ++;
#line 2078
        *__cil_tmp21 = (OPJ_INT32 )*__cil_tmp22;
#line 2077
        j ++;
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___2: ;
    } else {
#line 2082
      j = (OPJ_UINT32 )0;
      {
#line 2082
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 2082
        if (! (j < l_nb_elem)) {
#line 2082
          goto while_break___3;
        }
#line 2083
        __cil_tmp24 = l_src_ptr___0;
#line 2083
        l_src_ptr___0 ++;
#line 2083
        __cil_tmp23 = l_dest_ptr___0;
#line 2083
        l_dest_ptr___0 ++;
#line 2083
        *__cil_tmp23 = (int )*__cil_tmp24 & 65535;
#line 2082
        j ++;
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___3: ;
    }
#line 2087
    p_src = (OPJ_BYTE *)l_src_ptr___0;
#line 2089
    goto switch_break;
    case_4: 
#line 2092
    l_src_ptr___1 = (OPJ_INT32 *)p_src;
#line 2093
    l_dest_ptr___1 = l_tilec->data;
#line 2095
    j = (OPJ_UINT32 )0;
    {
#line 2095
    while (1) {
      while_continue___4: /* CIL Label */ ;

#line 2095
      if (! (j < l_nb_elem)) {
#line 2095
        goto while_break___4;
      }
#line 2096
      __cil_tmp28 = l_src_ptr___1;
#line 2096
      l_src_ptr___1 ++;
#line 2096
      __cil_tmp27 = l_dest_ptr___1;
#line 2096
      l_dest_ptr___1 ++;
#line 2096
      *__cil_tmp27 = *__cil_tmp28;
#line 2095
      j ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___4: 
#line 2099
    p_src = (OPJ_BYTE *)l_src_ptr___1;
#line 2101
    goto switch_break;
    switch_break: 
#line 2104
    l_img_comp ++;
#line 2105
    l_tilec ++;
#line 2038
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: ;
#line 2108
  return (1);
}
}
#line 3 "/root/patron/new_22/src/lib/openjp2/t1_luts.h"
static OPJ_BYTE lut_ctxno_zc[1024]  = 
#line 3 "/root/patron/new_22/src/lib/openjp2/t1_luts.h"
  {      (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )2, 
        (OPJ_BYTE )1,      (OPJ_BYTE )2,      (OPJ_BYTE )2,      (OPJ_BYTE )2, 
        (OPJ_BYTE )1,      (OPJ_BYTE )2,      (OPJ_BYTE )2,      (OPJ_BYTE )2, 
        (OPJ_BYTE )2,      (OPJ_BYTE )2,      (OPJ_BYTE )2,      (OPJ_BYTE )2, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )5,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )5,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )2, 
        (OPJ_BYTE )1,      (OPJ_BYTE )2,      (OPJ_BYTE )2,      (OPJ_BYTE )2, 
        (OPJ_BYTE )1,      (OPJ_BYTE )2,      (OPJ_BYTE )2,      (OPJ_BYTE )2, 
        (OPJ_BYTE )2,      (OPJ_BYTE )2,      (OPJ_BYTE )2,      (OPJ_BYTE )2, 
        (OPJ_BYTE )5,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )5,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )2, 
        (OPJ_BYTE )1,      (OPJ_BYTE )2,      (OPJ_BYTE )2,      (OPJ_BYTE )2, 
        (OPJ_BYTE )1,      (OPJ_BYTE )2,      (OPJ_BYTE )2,      (OPJ_BYTE )2, 
        (OPJ_BYTE )2,      (OPJ_BYTE )2,      (OPJ_BYTE )2,      (OPJ_BYTE )2, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )5,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )3, 
        (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )4, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )5,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )6, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )7, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )0,      (OPJ_BYTE )3,      (OPJ_BYTE )3,      (OPJ_BYTE )6, 
        (OPJ_BYTE )3,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )8, 
        (OPJ_BYTE )3,      (OPJ_BYTE )6,      (OPJ_BYTE )6,      (OPJ_BYTE )8, 
        (OPJ_BYTE )6,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )1,      (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )7, 
        (OPJ_BYTE )4,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )4,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )1,      (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )7, 
        (OPJ_BYTE )4,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )4,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )2,      (OPJ_BYTE )5,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )1,      (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )7, 
        (OPJ_BYTE )4,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )4,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )2,      (OPJ_BYTE )5,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )2,      (OPJ_BYTE )5,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )2,      (OPJ_BYTE )5,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )1,      (OPJ_BYTE )4,      (OPJ_BYTE )4,      (OPJ_BYTE )7, 
        (OPJ_BYTE )4,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )4,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )2,      (OPJ_BYTE )5,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )2,      (OPJ_BYTE )5,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )2,      (OPJ_BYTE )5,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )2,      (OPJ_BYTE )5,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )2,      (OPJ_BYTE )5,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )2,      (OPJ_BYTE )5,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8, 
        (OPJ_BYTE )2,      (OPJ_BYTE )5,      (OPJ_BYTE )5,      (OPJ_BYTE )7, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )5,      (OPJ_BYTE )7,      (OPJ_BYTE )7,      (OPJ_BYTE )8, 
        (OPJ_BYTE )7,      (OPJ_BYTE )8,      (OPJ_BYTE )8,      (OPJ_BYTE )8};
#line 38 "/root/patron/new_22/src/lib/openjp2/t1_luts.h"
static OPJ_BYTE lut_ctxno_sc[256]  = 
#line 38
  {      (OPJ_BYTE )9,      (OPJ_BYTE )10,      (OPJ_BYTE )12,      (OPJ_BYTE )13, 
        (OPJ_BYTE )10,      (OPJ_BYTE )10,      (OPJ_BYTE )13,      (OPJ_BYTE )13, 
        (OPJ_BYTE )12,      (OPJ_BYTE )13,      (OPJ_BYTE )12,      (OPJ_BYTE )13, 
        (OPJ_BYTE )13,      (OPJ_BYTE )13,      (OPJ_BYTE )13,      (OPJ_BYTE )13, 
        (OPJ_BYTE )9,      (OPJ_BYTE )10,      (OPJ_BYTE )12,      (OPJ_BYTE )11, 
        (OPJ_BYTE )10,      (OPJ_BYTE )9,      (OPJ_BYTE )13,      (OPJ_BYTE )12, 
        (OPJ_BYTE )12,      (OPJ_BYTE )11,      (OPJ_BYTE )12,      (OPJ_BYTE )11, 
        (OPJ_BYTE )13,      (OPJ_BYTE )12,      (OPJ_BYTE )13,      (OPJ_BYTE )12, 
        (OPJ_BYTE )9,      (OPJ_BYTE )10,      (OPJ_BYTE )12,      (OPJ_BYTE )11, 
        (OPJ_BYTE )10,      (OPJ_BYTE )10,      (OPJ_BYTE )11,      (OPJ_BYTE )11, 
        (OPJ_BYTE )12,      (OPJ_BYTE )13,      (OPJ_BYTE )9,      (OPJ_BYTE )10, 
        (OPJ_BYTE )13,      (OPJ_BYTE )13,      (OPJ_BYTE )10,      (OPJ_BYTE )10, 
        (OPJ_BYTE )9,      (OPJ_BYTE )10,      (OPJ_BYTE )12,      (OPJ_BYTE )13, 
        (OPJ_BYTE )10,      (OPJ_BYTE )9,      (OPJ_BYTE )11,      (OPJ_BYTE )12, 
        (OPJ_BYTE )12,      (OPJ_BYTE )11,      (OPJ_BYTE )9,      (OPJ_BYTE )10, 
        (OPJ_BYTE )13,      (OPJ_BYTE )12,      (OPJ_BYTE )10,      (OPJ_BYTE )9, 
        (OPJ_BYTE )9,      (OPJ_BYTE )10,      (OPJ_BYTE )12,      (OPJ_BYTE )13, 
        (OPJ_BYTE )10,      (OPJ_BYTE )9,      (OPJ_BYTE )11,      (OPJ_BYTE )12, 
        (OPJ_BYTE )12,      (OPJ_BYTE )13,      (OPJ_BYTE )12,      (OPJ_BYTE )13, 
        (OPJ_BYTE )11,      (OPJ_BYTE )12,      (OPJ_BYTE )11,      (OPJ_BYTE )12, 
        (OPJ_BYTE )9,      (OPJ_BYTE )10,      (OPJ_BYTE )12,      (OPJ_BYTE )11, 
        (OPJ_BYTE )10,      (OPJ_BYTE )10,      (OPJ_BYTE )11,      (OPJ_BYTE )11, 
        (OPJ_BYTE )12,      (OPJ_BYTE )11,      (OPJ_BYTE )12,      (OPJ_BYTE )11, 
        (OPJ_BYTE )11,      (OPJ_BYTE )11,      (OPJ_BYTE )11,      (OPJ_BYTE )11, 
        (OPJ_BYTE )9,      (OPJ_BYTE )10,      (OPJ_BYTE )12,      (OPJ_BYTE )11, 
        (OPJ_BYTE )10,      (OPJ_BYTE )9,      (OPJ_BYTE )13,      (OPJ_BYTE )12, 
        (OPJ_BYTE )12,      (OPJ_BYTE )13,      (OPJ_BYTE )9,      (OPJ_BYTE )10, 
        (OPJ_BYTE )11,      (OPJ_BYTE )12,      (OPJ_BYTE )10,      (OPJ_BYTE )9, 
        (OPJ_BYTE )9,      (OPJ_BYTE )10,      (OPJ_BYTE )12,      (OPJ_BYTE )13, 
        (OPJ_BYTE )10,      (OPJ_BYTE )10,      (OPJ_BYTE )13,      (OPJ_BYTE )13, 
        (OPJ_BYTE )12,      (OPJ_BYTE )11,      (OPJ_BYTE )9,      (OPJ_BYTE )10, 
        (OPJ_BYTE )11,      (OPJ_BYTE )11,      (OPJ_BYTE )10,      (OPJ_BYTE )10, 
        (OPJ_BYTE )9,      (OPJ_BYTE )10,      (OPJ_BYTE )12,      (OPJ_BYTE )13, 
        (OPJ_BYTE )10,      (OPJ_BYTE )10,      (OPJ_BYTE )13,      (OPJ_BYTE )13, 
        (OPJ_BYTE )12,      (OPJ_BYTE )11,      (OPJ_BYTE )9,      (OPJ_BYTE )10, 
        (OPJ_BYTE )11,      (OPJ_BYTE )11,      (OPJ_BYTE )10,      (OPJ_BYTE )10, 
        (OPJ_BYTE )9,      (OPJ_BYTE )10,      (OPJ_BYTE )12,      (OPJ_BYTE )11, 
        (OPJ_BYTE )10,      (OPJ_BYTE )9,      (OPJ_BYTE )13,      (OPJ_BYTE )12, 
        (OPJ_BYTE )12,      (OPJ_BYTE )13,      (OPJ_BYTE )9,      (OPJ_BYTE )10, 
        (OPJ_BYTE )11,      (OPJ_BYTE )12,      (OPJ_BYTE )10,      (OPJ_BYTE )9, 
        (OPJ_BYTE )9,      (OPJ_BYTE )10,      (OPJ_BYTE )12,      (OPJ_BYTE )11, 
        (OPJ_BYTE )10,      (OPJ_BYTE )10,      (OPJ_BYTE )11,      (OPJ_BYTE )11, 
        (OPJ_BYTE )12,      (OPJ_BYTE )11,      (OPJ_BYTE )12,      (OPJ_BYTE )11, 
        (OPJ_BYTE )11,      (OPJ_BYTE )11,      (OPJ_BYTE )11,      (OPJ_BYTE )11, 
        (OPJ_BYTE )9,      (OPJ_BYTE )10,      (OPJ_BYTE )12,      (OPJ_BYTE )13, 
        (OPJ_BYTE )10,      (OPJ_BYTE )9,      (OPJ_BYTE )11,      (OPJ_BYTE )12, 
        (OPJ_BYTE )12,      (OPJ_BYTE )13,      (OPJ_BYTE )12,      (OPJ_BYTE )13, 
        (OPJ_BYTE )11,      (OPJ_BYTE )12,      (OPJ_BYTE )11,      (OPJ_BYTE )12, 
        (OPJ_BYTE )9,      (OPJ_BYTE )10,      (OPJ_BYTE )12,      (OPJ_BYTE )13, 
        (OPJ_BYTE )10,      (OPJ_BYTE )9,      (OPJ_BYTE )11,      (OPJ_BYTE )12, 
        (OPJ_BYTE )12,      (OPJ_BYTE )11,      (OPJ_BYTE )9,      (OPJ_BYTE )10, 
        (OPJ_BYTE )13,      (OPJ_BYTE )12,      (OPJ_BYTE )10,      (OPJ_BYTE )9, 
        (OPJ_BYTE )9,      (OPJ_BYTE )10,      (OPJ_BYTE )12,      (OPJ_BYTE )11, 
        (OPJ_BYTE )10,      (OPJ_BYTE )10,      (OPJ_BYTE )11,      (OPJ_BYTE )11, 
        (OPJ_BYTE )12,      (OPJ_BYTE )13,      (OPJ_BYTE )9,      (OPJ_BYTE )10, 
        (OPJ_BYTE )13,      (OPJ_BYTE )13,      (OPJ_BYTE )10,      (OPJ_BYTE )10, 
        (OPJ_BYTE )9,      (OPJ_BYTE )10,      (OPJ_BYTE )12,      (OPJ_BYTE )11, 
        (OPJ_BYTE )10,      (OPJ_BYTE )9,      (OPJ_BYTE )13,      (OPJ_BYTE )12, 
        (OPJ_BYTE )12,      (OPJ_BYTE )11,      (OPJ_BYTE )12,      (OPJ_BYTE )11, 
        (OPJ_BYTE )13,      (OPJ_BYTE )12,      (OPJ_BYTE )13,      (OPJ_BYTE )12, 
        (OPJ_BYTE )9,      (OPJ_BYTE )10,      (OPJ_BYTE )12,      (OPJ_BYTE )13, 
        (OPJ_BYTE )10,      (OPJ_BYTE )10,      (OPJ_BYTE )13,      (OPJ_BYTE )13, 
        (OPJ_BYTE )12,      (OPJ_BYTE )13,      (OPJ_BYTE )12,      (OPJ_BYTE )13, 
        (OPJ_BYTE )13,      (OPJ_BYTE )13,      (OPJ_BYTE )13,      (OPJ_BYTE )13};
#line 57 "/root/patron/new_22/src/lib/openjp2/t1_luts.h"
static OPJ_BYTE lut_spb[256]  = 
#line 57
  {      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )1, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )0, 
        (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )0, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )1, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )1,      (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )0,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1, 
        (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1,      (OPJ_BYTE )1};
#line 68 "/root/patron/new_22/src/lib/openjp2/t1_luts.h"
static OPJ_INT16 lut_nmsedec_sig[128]  = 
#line 68
  {      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )384,      (OPJ_INT16 )768,      (OPJ_INT16 )1152, 
        (OPJ_INT16 )1536,      (OPJ_INT16 )1920,      (OPJ_INT16 )2304,      (OPJ_INT16 )2688, 
        (OPJ_INT16 )3072,      (OPJ_INT16 )3456,      (OPJ_INT16 )3840,      (OPJ_INT16 )4224, 
        (OPJ_INT16 )4608,      (OPJ_INT16 )4992,      (OPJ_INT16 )5376,      (OPJ_INT16 )5760, 
        (OPJ_INT16 )6144,      (OPJ_INT16 )6528,      (OPJ_INT16 )6912,      (OPJ_INT16 )7296, 
        (OPJ_INT16 )7680,      (OPJ_INT16 )8064,      (OPJ_INT16 )8448,      (OPJ_INT16 )8832, 
        (OPJ_INT16 )9216,      (OPJ_INT16 )9600,      (OPJ_INT16 )9984,      (OPJ_INT16 )10368, 
        (OPJ_INT16 )10752,      (OPJ_INT16 )11136,      (OPJ_INT16 )11520,      (OPJ_INT16 )11904, 
        (OPJ_INT16 )12288,      (OPJ_INT16 )12672,      (OPJ_INT16 )13056,      (OPJ_INT16 )13440, 
        (OPJ_INT16 )13824,      (OPJ_INT16 )14208,      (OPJ_INT16 )14592,      (OPJ_INT16 )14976, 
        (OPJ_INT16 )15360,      (OPJ_INT16 )15744,      (OPJ_INT16 )16128,      (OPJ_INT16 )16512, 
        (OPJ_INT16 )16896,      (OPJ_INT16 )17280,      (OPJ_INT16 )17664,      (OPJ_INT16 )18048, 
        (OPJ_INT16 )18432,      (OPJ_INT16 )18816,      (OPJ_INT16 )19200,      (OPJ_INT16 )19584, 
        (OPJ_INT16 )19968,      (OPJ_INT16 )20352,      (OPJ_INT16 )20736,      (OPJ_INT16 )21120, 
        (OPJ_INT16 )21504,      (OPJ_INT16 )21888,      (OPJ_INT16 )22272,      (OPJ_INT16 )22656, 
        (OPJ_INT16 )23040,      (OPJ_INT16 )23424,      (OPJ_INT16 )23808,      (OPJ_INT16 )24192, 
        (OPJ_INT16 )24576,      (OPJ_INT16 )24960,      (OPJ_INT16 )25344,      (OPJ_INT16 )25728, 
        (OPJ_INT16 )26112,      (OPJ_INT16 )26496,      (OPJ_INT16 )26880,      (OPJ_INT16 )27264, 
        (OPJ_INT16 )27648,      (OPJ_INT16 )28032,      (OPJ_INT16 )28416,      (OPJ_INT16 )28800, 
        (OPJ_INT16 )29184,      (OPJ_INT16 )29568,      (OPJ_INT16 )29952,      (OPJ_INT16 )30336};
#line 87 "/root/patron/new_22/src/lib/openjp2/t1_luts.h"
static OPJ_INT16 lut_nmsedec_sig0[128]  = 
#line 87
  {      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )128,      (OPJ_INT16 )128, 
        (OPJ_INT16 )128,      (OPJ_INT16 )128,      (OPJ_INT16 )256,      (OPJ_INT16 )256, 
        (OPJ_INT16 )256,      (OPJ_INT16 )384,      (OPJ_INT16 )384,      (OPJ_INT16 )512, 
        (OPJ_INT16 )512,      (OPJ_INT16 )640,      (OPJ_INT16 )640,      (OPJ_INT16 )768, 
        (OPJ_INT16 )768,      (OPJ_INT16 )896,      (OPJ_INT16 )1024,      (OPJ_INT16 )1024, 
        (OPJ_INT16 )1152,      (OPJ_INT16 )1280,      (OPJ_INT16 )1408,      (OPJ_INT16 )1408, 
        (OPJ_INT16 )1536,      (OPJ_INT16 )1664,      (OPJ_INT16 )1792,      (OPJ_INT16 )1920, 
        (OPJ_INT16 )2048,      (OPJ_INT16 )2176,      (OPJ_INT16 )2304,      (OPJ_INT16 )2432, 
        (OPJ_INT16 )2560,      (OPJ_INT16 )2688,      (OPJ_INT16 )2944,      (OPJ_INT16 )3072, 
        (OPJ_INT16 )3200,      (OPJ_INT16 )3328,      (OPJ_INT16 )3584,      (OPJ_INT16 )3712, 
        (OPJ_INT16 )3840,      (OPJ_INT16 )4096,      (OPJ_INT16 )4224,      (OPJ_INT16 )4480, 
        (OPJ_INT16 )4608,      (OPJ_INT16 )4864,      (OPJ_INT16 )4992,      (OPJ_INT16 )5248, 
        (OPJ_INT16 )5376,      (OPJ_INT16 )5632,      (OPJ_INT16 )5888,      (OPJ_INT16 )6016, 
        (OPJ_INT16 )6272,      (OPJ_INT16 )6528,      (OPJ_INT16 )6784,      (OPJ_INT16 )6912, 
        (OPJ_INT16 )7168,      (OPJ_INT16 )7424,      (OPJ_INT16 )7680,      (OPJ_INT16 )7936, 
        (OPJ_INT16 )8192,      (OPJ_INT16 )8448,      (OPJ_INT16 )8704,      (OPJ_INT16 )8960, 
        (OPJ_INT16 )9216,      (OPJ_INT16 )9472,      (OPJ_INT16 )9856,      (OPJ_INT16 )10112, 
        (OPJ_INT16 )10368,      (OPJ_INT16 )10624,      (OPJ_INT16 )11008,      (OPJ_INT16 )11264, 
        (OPJ_INT16 )11520,      (OPJ_INT16 )11904,      (OPJ_INT16 )12160,      (OPJ_INT16 )12544, 
        (OPJ_INT16 )12800,      (OPJ_INT16 )13184,      (OPJ_INT16 )13440,      (OPJ_INT16 )13824, 
        (OPJ_INT16 )14080,      (OPJ_INT16 )14464,      (OPJ_INT16 )14848,      (OPJ_INT16 )15104, 
        (OPJ_INT16 )15488,      (OPJ_INT16 )15872,      (OPJ_INT16 )16256,      (OPJ_INT16 )16512, 
        (OPJ_INT16 )16896,      (OPJ_INT16 )17280,      (OPJ_INT16 )17664,      (OPJ_INT16 )18048, 
        (OPJ_INT16 )18432,      (OPJ_INT16 )18816,      (OPJ_INT16 )19200,      (OPJ_INT16 )19584, 
        (OPJ_INT16 )19968,      (OPJ_INT16 )20352,      (OPJ_INT16 )20864,      (OPJ_INT16 )21248, 
        (OPJ_INT16 )21632,      (OPJ_INT16 )22016,      (OPJ_INT16 )22528,      (OPJ_INT16 )22912, 
        (OPJ_INT16 )23296,      (OPJ_INT16 )23808,      (OPJ_INT16 )24192,      (OPJ_INT16 )24704, 
        (OPJ_INT16 )25088,      (OPJ_INT16 )25600,      (OPJ_INT16 )25984,      (OPJ_INT16 )26496, 
        (OPJ_INT16 )26880,      (OPJ_INT16 )27392,      (OPJ_INT16 )27904,      (OPJ_INT16 )28288, 
        (OPJ_INT16 )28800,      (OPJ_INT16 )29312,      (OPJ_INT16 )29824,      (OPJ_INT16 )30208, 
        (OPJ_INT16 )30720,      (OPJ_INT16 )31232,      (OPJ_INT16 )31744,      (OPJ_INT16 )32256};
#line 106 "/root/patron/new_22/src/lib/openjp2/t1_luts.h"
static OPJ_INT16 lut_nmsedec_ref[128]  = 
#line 106
  {      (OPJ_INT16 )6144,      (OPJ_INT16 )6016,      (OPJ_INT16 )5888,      (OPJ_INT16 )5760, 
        (OPJ_INT16 )5632,      (OPJ_INT16 )5504,      (OPJ_INT16 )5376,      (OPJ_INT16 )5248, 
        (OPJ_INT16 )5120,      (OPJ_INT16 )4992,      (OPJ_INT16 )4864,      (OPJ_INT16 )4736, 
        (OPJ_INT16 )4608,      (OPJ_INT16 )4480,      (OPJ_INT16 )4352,      (OPJ_INT16 )4224, 
        (OPJ_INT16 )4096,      (OPJ_INT16 )3968,      (OPJ_INT16 )3840,      (OPJ_INT16 )3712, 
        (OPJ_INT16 )3584,      (OPJ_INT16 )3456,      (OPJ_INT16 )3328,      (OPJ_INT16 )3200, 
        (OPJ_INT16 )3072,      (OPJ_INT16 )2944,      (OPJ_INT16 )2816,      (OPJ_INT16 )2688, 
        (OPJ_INT16 )2560,      (OPJ_INT16 )2432,      (OPJ_INT16 )2304,      (OPJ_INT16 )2176, 
        (OPJ_INT16 )2048,      (OPJ_INT16 )1920,      (OPJ_INT16 )1792,      (OPJ_INT16 )1664, 
        (OPJ_INT16 )1536,      (OPJ_INT16 )1408,      (OPJ_INT16 )1280,      (OPJ_INT16 )1152, 
        (OPJ_INT16 )1024,      (OPJ_INT16 )896,      (OPJ_INT16 )768,      (OPJ_INT16 )640, 
        (OPJ_INT16 )512,      (OPJ_INT16 )384,      (OPJ_INT16 )256,      (OPJ_INT16 )128, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )128,      (OPJ_INT16 )256,      (OPJ_INT16 )384, 
        (OPJ_INT16 )512,      (OPJ_INT16 )640,      (OPJ_INT16 )768,      (OPJ_INT16 )896, 
        (OPJ_INT16 )1024,      (OPJ_INT16 )1152,      (OPJ_INT16 )1280,      (OPJ_INT16 )1408, 
        (OPJ_INT16 )1536,      (OPJ_INT16 )1664,      (OPJ_INT16 )1792,      (OPJ_INT16 )1920, 
        (OPJ_INT16 )2048,      (OPJ_INT16 )2176,      (OPJ_INT16 )2304,      (OPJ_INT16 )2432, 
        (OPJ_INT16 )2560,      (OPJ_INT16 )2688,      (OPJ_INT16 )2816,      (OPJ_INT16 )2944, 
        (OPJ_INT16 )3072,      (OPJ_INT16 )3200,      (OPJ_INT16 )3328,      (OPJ_INT16 )3456, 
        (OPJ_INT16 )3584,      (OPJ_INT16 )3712,      (OPJ_INT16 )3840,      (OPJ_INT16 )3968, 
        (OPJ_INT16 )4096,      (OPJ_INT16 )4224,      (OPJ_INT16 )4352,      (OPJ_INT16 )4480, 
        (OPJ_INT16 )4608,      (OPJ_INT16 )4736,      (OPJ_INT16 )4864,      (OPJ_INT16 )4992, 
        (OPJ_INT16 )5120,      (OPJ_INT16 )5248,      (OPJ_INT16 )5376,      (OPJ_INT16 )5504, 
        (OPJ_INT16 )5632,      (OPJ_INT16 )5760,      (OPJ_INT16 )5888,      (OPJ_INT16 )6016};
#line 125 "/root/patron/new_22/src/lib/openjp2/t1_luts.h"
static OPJ_INT16 lut_nmsedec_ref0[128]  = 
#line 125
  {      (OPJ_INT16 )8192,      (OPJ_INT16 )7936,      (OPJ_INT16 )7680,      (OPJ_INT16 )7424, 
        (OPJ_INT16 )7168,      (OPJ_INT16 )6912,      (OPJ_INT16 )6784,      (OPJ_INT16 )6528, 
        (OPJ_INT16 )6272,      (OPJ_INT16 )6016,      (OPJ_INT16 )5888,      (OPJ_INT16 )5632, 
        (OPJ_INT16 )5376,      (OPJ_INT16 )5248,      (OPJ_INT16 )4992,      (OPJ_INT16 )4864, 
        (OPJ_INT16 )4608,      (OPJ_INT16 )4480,      (OPJ_INT16 )4224,      (OPJ_INT16 )4096, 
        (OPJ_INT16 )3840,      (OPJ_INT16 )3712,      (OPJ_INT16 )3584,      (OPJ_INT16 )3328, 
        (OPJ_INT16 )3200,      (OPJ_INT16 )3072,      (OPJ_INT16 )2944,      (OPJ_INT16 )2688, 
        (OPJ_INT16 )2560,      (OPJ_INT16 )2432,      (OPJ_INT16 )2304,      (OPJ_INT16 )2176, 
        (OPJ_INT16 )2048,      (OPJ_INT16 )1920,      (OPJ_INT16 )1792,      (OPJ_INT16 )1664, 
        (OPJ_INT16 )1536,      (OPJ_INT16 )1408,      (OPJ_INT16 )1408,      (OPJ_INT16 )1280, 
        (OPJ_INT16 )1152,      (OPJ_INT16 )1024,      (OPJ_INT16 )1024,      (OPJ_INT16 )896, 
        (OPJ_INT16 )768,      (OPJ_INT16 )768,      (OPJ_INT16 )640,      (OPJ_INT16 )640, 
        (OPJ_INT16 )512,      (OPJ_INT16 )512,      (OPJ_INT16 )384,      (OPJ_INT16 )384, 
        (OPJ_INT16 )256,      (OPJ_INT16 )256,      (OPJ_INT16 )256,      (OPJ_INT16 )128, 
        (OPJ_INT16 )128,      (OPJ_INT16 )128,      (OPJ_INT16 )128,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )0, 
        (OPJ_INT16 )0,      (OPJ_INT16 )0,      (OPJ_INT16 )128,      (OPJ_INT16 )128, 
        (OPJ_INT16 )128,      (OPJ_INT16 )128,      (OPJ_INT16 )256,      (OPJ_INT16 )256, 
        (OPJ_INT16 )256,      (OPJ_INT16 )384,      (OPJ_INT16 )384,      (OPJ_INT16 )512, 
        (OPJ_INT16 )512,      (OPJ_INT16 )640,      (OPJ_INT16 )640,      (OPJ_INT16 )768, 
        (OPJ_INT16 )768,      (OPJ_INT16 )896,      (OPJ_INT16 )1024,      (OPJ_INT16 )1024, 
        (OPJ_INT16 )1152,      (OPJ_INT16 )1280,      (OPJ_INT16 )1408,      (OPJ_INT16 )1408, 
        (OPJ_INT16 )1536,      (OPJ_INT16 )1664,      (OPJ_INT16 )1792,      (OPJ_INT16 )1920, 
        (OPJ_INT16 )2048,      (OPJ_INT16 )2176,      (OPJ_INT16 )2304,      (OPJ_INT16 )2432, 
        (OPJ_INT16 )2560,      (OPJ_INT16 )2688,      (OPJ_INT16 )2944,      (OPJ_INT16 )3072, 
        (OPJ_INT16 )3200,      (OPJ_INT16 )3328,      (OPJ_INT16 )3584,      (OPJ_INT16 )3712, 
        (OPJ_INT16 )3840,      (OPJ_INT16 )4096,      (OPJ_INT16 )4224,      (OPJ_INT16 )4480, 
        (OPJ_INT16 )4608,      (OPJ_INT16 )4864,      (OPJ_INT16 )4992,      (OPJ_INT16 )5248, 
        (OPJ_INT16 )5376,      (OPJ_INT16 )5632,      (OPJ_INT16 )5888,      (OPJ_INT16 )6016, 
        (OPJ_INT16 )6272,      (OPJ_INT16 )6528,      (OPJ_INT16 )6784,      (OPJ_INT16 )6912, 
        (OPJ_INT16 )7168,      (OPJ_INT16 )7424,      (OPJ_INT16 )7680,      (OPJ_INT16 )7936};
#line 42 "/root/patron/new_22/src/lib/openjp2/t1.c"
OPJ_BYTE opj_t1_getctxno_zc(OPJ_UINT32 f , OPJ_UINT32 orient ) ;
#line 43
OPJ_BYTE opj_t1_getctxno_sc(OPJ_UINT32 f ) ;
#line 44
OPJ_UINT32 opj_t1_getctxno_mag(OPJ_UINT32 f ) ;
#line 45
OPJ_BYTE opj_t1_getspb(OPJ_UINT32 f ) ;
#line 46
OPJ_INT16 opj_t1_getnmsedec_sig(OPJ_UINT32 x , OPJ_UINT32 bitpos ) ;
#line 47
OPJ_INT16 opj_t1_getnmsedec_ref(OPJ_UINT32 x , OPJ_UINT32 bitpos ) ;
#line 48
void opj_t1_updateflags(opj_flag_t *flagsp , OPJ_UINT32 s , OPJ_UINT32 stride ) ;
#line 52
void opj_t1_enc_sigpass_step(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                             OPJ_UINT32 orient , OPJ_INT32 bpno , OPJ_INT32 one ,
                             OPJ_INT32 *nmsedec , OPJ_BYTE type , OPJ_UINT32 vsc ) ;
#line 65
void opj_t1_dec_sigpass_step(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                             OPJ_UINT32 orient , OPJ_INT32 oneplushalf , OPJ_BYTE type ,
                             OPJ_UINT32 vsc ) ;
#line 73
__inline static void opj_t1_dec_sigpass_step_raw(opj_t1_t *t1 , opj_flag_t *flagsp ,
                                                 OPJ_INT32 *datap , OPJ_INT32 orient ,
                                                 OPJ_INT32 oneplushalf , OPJ_INT32 vsc ) ;
#line 80
__inline void opj_t1_dec_sigpass_step_mqc(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                                          OPJ_INT32 orient , OPJ_INT32 oneplushalf ) ;
#line 86
__inline void opj_t1_dec_sigpass_step_mqc_vsc(opj_t1_t *t1 , opj_flag_t *flagsp ,
                                              OPJ_INT32 *datap , OPJ_INT32 orient ,
                                              OPJ_INT32 oneplushalf , OPJ_INT32 vsc ) ;
#line 98
void opj_t1_enc_sigpass(opj_t1_t *t1 , OPJ_INT32 bpno , OPJ_UINT32 orient , OPJ_INT32 *nmsedec ,
                        OPJ_BYTE type , OPJ_UINT32 cblksty ) ;
#line 108
void opj_t1_dec_sigpass_raw(opj_t1_t *t1 , OPJ_INT32 bpno , OPJ_INT32 orient , OPJ_INT32 cblksty ) ;
#line 113
void opj_t1_dec_sigpass_mqc(opj_t1_t *t1 , OPJ_INT32 bpno , OPJ_INT32 orient ) ;
#line 117
void opj_t1_dec_sigpass_mqc_vsc(opj_t1_t *t1 , OPJ_INT32 bpno , OPJ_INT32 orient ) ;
#line 127
void opj_t1_enc_refpass_step(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                             OPJ_INT32 bpno , OPJ_INT32 one , OPJ_INT32 *nmsedec ,
                             OPJ_BYTE type , OPJ_UINT32 vsc ) ;
#line 140
void opj_t1_enc_refpass(opj_t1_t *t1 , OPJ_INT32 bpno , OPJ_INT32 *nmsedec , OPJ_BYTE type ,
                        OPJ_UINT32 cblksty ) ;
#line 149
void opj_t1_dec_refpass_raw(opj_t1_t *t1 , OPJ_INT32 bpno , OPJ_INT32 cblksty ) ;
#line 153
void opj_t1_dec_refpass_mqc(opj_t1_t *t1 , OPJ_INT32 bpno ) ;
#line 156
void opj_t1_dec_refpass_mqc_vsc(opj_t1_t *t1 , OPJ_INT32 bpno ) ;
#line 164
void opj_t1_dec_refpass_step(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                             OPJ_INT32 poshalf , OPJ_INT32 neghalf , OPJ_BYTE type ,
                             OPJ_UINT32 vsc ) ;
#line 172
__inline void opj_t1_dec_refpass_step_raw(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                                          OPJ_INT32 poshalf , OPJ_INT32 neghalf ,
                                          OPJ_INT32 vsc ) ;
#line 179
__inline void opj_t1_dec_refpass_step_mqc(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                                          OPJ_INT32 poshalf , OPJ_INT32 neghalf ) ;
#line 185
__inline void opj_t1_dec_refpass_step_mqc_vsc(opj_t1_t *t1 , opj_flag_t *flagsp ,
                                              OPJ_INT32 *datap , OPJ_INT32 poshalf ,
                                              OPJ_INT32 neghalf , OPJ_INT32 vsc ) ;
#line 198
void opj_t1_enc_clnpass_step(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                             OPJ_UINT32 orient , OPJ_INT32 bpno , OPJ_INT32 one ,
                             OPJ_INT32 *nmsedec , OPJ_UINT32 partial , OPJ_UINT32 vsc ) ;
#line 211
static void opj_t1_dec_clnpass_step_partial(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                                            OPJ_INT32 orient , OPJ_INT32 oneplushalf ) ;
#line 217
static void opj_t1_dec_clnpass_step(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                                    OPJ_INT32 orient , OPJ_INT32 oneplushalf ) ;
#line 223
static void opj_t1_dec_clnpass_step_vsc(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                                        OPJ_INT32 orient , OPJ_INT32 oneplushalf ,
                                        OPJ_INT32 partial , OPJ_INT32 vsc ) ;
#line 234
void opj_t1_enc_clnpass(opj_t1_t *t1 , OPJ_INT32 bpno , OPJ_UINT32 orient , OPJ_INT32 *nmsedec ,
                        OPJ_UINT32 cblksty ) ;
#line 243
static void opj_t1_dec_clnpass(opj_t1_t *t1 , OPJ_INT32 bpno , OPJ_INT32 orient ,
                               OPJ_INT32 cblksty ) ;
#line 249
static OPJ_FLOAT64 opj_t1_getwmsedec(OPJ_INT32 nmsedec , OPJ_UINT32 compno , OPJ_UINT32 level ,
                                     OPJ_UINT32 orient , OPJ_INT32 bpno , OPJ_UINT32 qmfbid ,
                                     OPJ_FLOAT64 stepsize , OPJ_UINT32 numcomps ,
                                     OPJ_FLOAT64 *mct_norms ) ;
#line 260
void opj_t1_encode_cblk(opj_t1_t *t1 , opj_tcd_cblk_enc_t *cblk , OPJ_UINT32 orient ,
                        OPJ_UINT32 compno , OPJ_UINT32 level , OPJ_UINT32 qmfbid ,
                        OPJ_FLOAT64 stepsize , OPJ_UINT32 cblksty , OPJ_UINT32 numcomps ,
                        opj_tcd_tile_t *tile , OPJ_FLOAT64 *mct_norms ) ;
#line 280
OPJ_BOOL opj_t1_decode_cblk(opj_t1_t *t1 , opj_tcd_cblk_dec_t *cblk , OPJ_UINT32 orient ,
                            OPJ_UINT32 roishift , OPJ_UINT32 cblksty ) ;
#line 286
OPJ_BOOL opj_t1_allocate_buffers(opj_t1_t *t1 , OPJ_UINT32 w , OPJ_UINT32 h ) ;
#line 296 "/root/patron/new_22/src/lib/openjp2/t1.c"
OPJ_BYTE opj_t1_getctxno_zc(OPJ_UINT32 f , OPJ_UINT32 orient ) 
{ 


  {
#line 297
  return (lut_ctxno_zc[(orient << 8) | (f & 255U)]);
}
}
#line 300 "/root/patron/new_22/src/lib/openjp2/t1.c"
OPJ_BYTE opj_t1_getctxno_sc(OPJ_UINT32 f ) 
{ 


  {
#line 301
  return (lut_ctxno_sc[(f & 4080U) >> 4]);
}
}
#line 304 "/root/patron/new_22/src/lib/openjp2/t1.c"
OPJ_UINT32 opj_t1_getctxno_mag(OPJ_UINT32 f ) 
{ 
  OPJ_UINT32 tmp1 ;
  int tmp ;
  OPJ_UINT32 tmp2 ;
  unsigned int tmp___0 ;

  {
#line 305
  if (f & 255U) {
#line 305
    tmp = 15;
  } else {
#line 305
    tmp = 14;
  }
#line 305
  tmp1 = (OPJ_UINT32 )tmp;
#line 306
  if (f & 8192U) {
#line 306
    tmp___0 = 16U;
  } else {
#line 306
    tmp___0 = tmp1;
  }
#line 306
  tmp2 = tmp___0;
#line 307
  return (tmp2);
}
}
#line 310 "/root/patron/new_22/src/lib/openjp2/t1.c"
OPJ_BYTE opj_t1_getspb(OPJ_UINT32 f ) 
{ 


  {
#line 311
  return (lut_spb[(f & 4080U) >> 4]);
}
}
#line 314 "/root/patron/new_22/src/lib/openjp2/t1.c"
OPJ_INT16 opj_t1_getnmsedec_sig(OPJ_UINT32 x , OPJ_UINT32 bitpos ) 
{ 


  {
#line 315
  if (bitpos > 6U) {
#line 316
    return (lut_nmsedec_sig[(x >> (bitpos - 6U)) & (unsigned int )((1 << 7) - 1)]);
  }
#line 319
  return (lut_nmsedec_sig0[x & (unsigned int )((1 << 7) - 1)]);
}
}
#line 322 "/root/patron/new_22/src/lib/openjp2/t1.c"
OPJ_INT16 opj_t1_getnmsedec_ref(OPJ_UINT32 x , OPJ_UINT32 bitpos ) 
{ 


  {
#line 323
  if (bitpos > 6U) {
#line 324
    return (lut_nmsedec_ref[(x >> (bitpos - 6U)) & (unsigned int )((1 << 7) - 1)]);
  }
#line 327
  return (lut_nmsedec_ref0[x & (unsigned int )((1 << 7) - 1)]);
}
}
#line 334 "/root/patron/new_22/src/lib/openjp2/t1.c"
static opj_flag_t mod[8]  ;
#line 330 "/root/patron/new_22/src/lib/openjp2/t1.c"
void opj_t1_updateflags(opj_flag_t *flagsp , OPJ_UINT32 s , OPJ_UINT32 stride ) 
{ 
  opj_flag_t *np ;
  opj_flag_t *sp ;

  {
#line 331
  np = flagsp - stride;
#line 332
  sp = flagsp + stride;
#line 334
  mod[0] = (opj_flag_t )64;
#line 334
  mod[1] = (opj_flag_t )1088;
#line 334
  mod[2] = (opj_flag_t )32;
#line 334
  mod[3] = (opj_flag_t )544;
#line 334
  mod[4] = (opj_flag_t )128;
#line 334
  mod[5] = (opj_flag_t )2176;
#line 334
  mod[6] = (opj_flag_t )16;
#line 334
  mod[7] = (opj_flag_t )272;
#line 341
  *(np + -1) = (opj_flag_t )((int )*(np + -1) | 2);
#line 342
  *(np + 0) = (opj_flag_t )((int )*(np + 0) | (int )mod[s]);
#line 343
  *(np + 1) = (opj_flag_t )((int )*(np + 1) | 4);
#line 345
  *(flagsp + -1) = (opj_flag_t )((int )*(flagsp + -1) | (int )mod[s + 2U]);
#line 346
  *(flagsp + 0) = (opj_flag_t )((int )*(flagsp + 0) | 4096);
#line 347
  *(flagsp + 1) = (opj_flag_t )((int )*(flagsp + 1) | (int )mod[s + 4U]);
#line 349
  *(sp + -1) = (opj_flag_t )((int )*(sp + -1) | 1);
#line 350
  *(sp + 0) = (opj_flag_t )((int )*(sp + 0) | (int )mod[s + 6U]);
#line 351
  *(sp + 1) = (opj_flag_t )((int )*(sp + 1) | 8);
#line 352
  return;
}
}
#line 354 "/root/patron/new_22/src/lib/openjp2/t1.c"
void opj_t1_enc_sigpass_step(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                             OPJ_UINT32 orient , OPJ_INT32 bpno , OPJ_INT32 one ,
                             OPJ_INT32 *nmsedec , OPJ_BYTE type , OPJ_UINT32 vsc ) 
{ 
  OPJ_INT32 v ;
  OPJ_UINT32 flag ;
  opj_mqc_t *mqc ;
  int tmp ;
  OPJ_INT32 __cil_tmp14 ;
  int tmp___0 ;
  OPJ_BYTE __cil_tmp16 ;
  int tmp___1 ;
  OPJ_INT32 __cil_tmp18 ;
  OPJ_INT16 __cil_tmp19 ;
  OPJ_BYTE __cil_tmp20 ;
  OPJ_BYTE __cil_tmp21 ;

  {
#line 368
  mqc = t1->mqc;
#line 370
  if (vsc) {
#line 370
    tmp = (int )*flagsp & -1095;
  } else {
#line 370
    tmp = (int )*flagsp;
  }
#line 370
  flag = (OPJ_UINT32 )tmp;
#line 371
  if (flag & 255U) {
#line 371
    if (! (flag & 20480U)) {
      {
#line 372
      __cil_tmp14 = opj_int_abs(*datap);
      }
#line 372
      if (__cil_tmp14 & one) {
#line 372
        tmp___0 = 1;
      } else {
#line 372
        tmp___0 = 0;
      }
      {
#line 372
      v = tmp___0;
#line 373
      __cil_tmp16 = opj_t1_getctxno_zc(flag, orient);
#line 373
      mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp16];
      }
#line 374
      if ((int )type == 1) {
        {
#line 375
        opj_mqc_bypass_enc(mqc, (OPJ_UINT32 )v);
        }
      } else {
        {
#line 377
        opj_mqc_encode(mqc, (OPJ_UINT32 )v);
        }
      }
#line 379
      if (v) {
#line 380
        if (*datap < 0) {
#line 380
          tmp___1 = 1;
        } else {
#line 380
          tmp___1 = 0;
        }
        {
#line 380
        v = tmp___1;
#line 381
        __cil_tmp18 = opj_int_abs(*datap);
#line 381
        __cil_tmp19 = opj_t1_getnmsedec_sig((OPJ_UINT32 )__cil_tmp18, (OPJ_UINT32 )(bpno + 6));
#line 381
        *nmsedec += (int )__cil_tmp19;
#line 382
        __cil_tmp20 = opj_t1_getctxno_sc(flag);
#line 382
        mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp20];
        }
#line 383
        if ((int )type == 1) {
          {
#line 384
          opj_mqc_bypass_enc(mqc, (OPJ_UINT32 )v);
          }
        } else {
          {
#line 386
          __cil_tmp21 = opj_t1_getspb(flag);
#line 386
          opj_mqc_encode(mqc, (OPJ_UINT32 )(v ^ (int )__cil_tmp21));
          }
        }
        {
#line 388
        opj_t1_updateflags(flagsp, (OPJ_UINT32 )v, t1->flags_stride);
        }
      }
#line 390
      *flagsp = (opj_flag_t )((int )*flagsp | 16384);
    }
  }
#line 393
  return;
}
}
#line 395 "/root/patron/new_22/src/lib/openjp2/t1.c"
__inline static void opj_t1_dec_sigpass_step_raw(opj_t1_t *t1 , opj_flag_t *flagsp ,
                                                 OPJ_INT32 *datap , OPJ_INT32 orient ,
                                                 OPJ_INT32 oneplushalf , OPJ_INT32 vsc ) 
{ 
  OPJ_INT32 v ;
  OPJ_INT32 flag ;
  opj_raw_t *raw ;
  int tmp ;
  OPJ_UINT32 __cil_tmp11 ;
  OPJ_UINT32 __cil_tmp12 ;
  OPJ_INT32 tmp___0 ;

  {
#line 404
  raw = t1->raw;
#line 407
  if (vsc) {
#line 407
    tmp = (int )*flagsp & -1095;
  } else {
#line 407
    tmp = (int )*flagsp;
  }
#line 407
  flag = tmp;
#line 408
  if (flag & 255) {
#line 408
    if (! (flag & 20480)) {
      {
#line 409
      __cil_tmp11 = opj_raw_decode(raw);
      }
#line 409
      if (__cil_tmp11) {
        {
#line 410
        __cil_tmp12 = opj_raw_decode(raw);
#line 410
        v = (OPJ_INT32 )__cil_tmp12;
        }
#line 411
        if (v) {
#line 411
          tmp___0 = - oneplushalf;
        } else {
#line 411
          tmp___0 = oneplushalf;
        }
        {
#line 411
        *datap = tmp___0;
#line 412
        opj_t1_updateflags(flagsp, (OPJ_UINT32 )v, t1->flags_stride);
        }
      }
#line 414
      *flagsp = (opj_flag_t )((int )*flagsp | 16384);
    }
  }
#line 417
  return;
}
}
#line 418 "/root/patron/new_22/src/lib/openjp2/t1.c"
__inline void opj_t1_dec_sigpass_step_mqc(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                                          OPJ_INT32 orient , OPJ_INT32 oneplushalf ) 
{ 
  OPJ_INT32 v ;
  OPJ_INT32 flag ;
  opj_mqc_t *mqc ;
  OPJ_BYTE __cil_tmp9 ;
  OPJ_INT32 __cil_tmp10 ;
  OPJ_BYTE __cil_tmp11 ;
  OPJ_INT32 __cil_tmp12 ;
  OPJ_BYTE __cil_tmp13 ;
  OPJ_INT32 tmp ;

  {
#line 427
  mqc = t1->mqc;
#line 429
  flag = (OPJ_INT32 )*flagsp;
#line 430
  if (flag & 255) {
#line 430
    if (! (flag & 20480)) {
      {
#line 431
      __cil_tmp9 = opj_t1_getctxno_zc((OPJ_UINT32 )flag, (OPJ_UINT32 )orient);
#line 431
      mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp9];
#line 432
      __cil_tmp10 = opj_mqc_decode(mqc);
      }
#line 432
      if (__cil_tmp10) {
        {
#line 433
        __cil_tmp11 = opj_t1_getctxno_sc((OPJ_UINT32 )flag);
#line 433
        mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp11];
#line 434
        __cil_tmp13 = opj_t1_getspb((OPJ_UINT32 )flag);
#line 434
        __cil_tmp12 = opj_mqc_decode(mqc);
#line 434
        v = __cil_tmp12 ^ (int )__cil_tmp13;
        }
#line 435
        if (v) {
#line 435
          tmp = - oneplushalf;
        } else {
#line 435
          tmp = oneplushalf;
        }
        {
#line 435
        *datap = tmp;
#line 436
        opj_t1_updateflags(flagsp, (OPJ_UINT32 )v, t1->flags_stride);
        }
      }
#line 438
      *flagsp = (opj_flag_t )((int )*flagsp | 16384);
    }
  }
#line 441
  return;
}
}
#line 442 "/root/patron/new_22/src/lib/openjp2/t1.c"
__inline void opj_t1_dec_sigpass_step_mqc_vsc(opj_t1_t *t1 , opj_flag_t *flagsp ,
                                              OPJ_INT32 *datap , OPJ_INT32 orient ,
                                              OPJ_INT32 oneplushalf , OPJ_INT32 vsc ) 
{ 
  OPJ_INT32 v ;
  OPJ_INT32 flag ;
  opj_mqc_t *mqc ;
  int tmp ;
  OPJ_BYTE __cil_tmp11 ;
  OPJ_INT32 __cil_tmp12 ;
  OPJ_BYTE __cil_tmp13 ;
  OPJ_INT32 __cil_tmp14 ;
  OPJ_BYTE __cil_tmp15 ;
  OPJ_INT32 tmp___0 ;

  {
#line 452
  mqc = t1->mqc;
#line 454
  if (vsc) {
#line 454
    tmp = (int )*flagsp & -1095;
  } else {
#line 454
    tmp = (int )*flagsp;
  }
#line 454
  flag = tmp;
#line 455
  if (flag & 255) {
#line 455
    if (! (flag & 20480)) {
      {
#line 456
      __cil_tmp11 = opj_t1_getctxno_zc((OPJ_UINT32 )flag, (OPJ_UINT32 )orient);
#line 456
      mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp11];
#line 457
      __cil_tmp12 = opj_mqc_decode(mqc);
      }
#line 457
      if (__cil_tmp12) {
        {
#line 458
        __cil_tmp13 = opj_t1_getctxno_sc((OPJ_UINT32 )flag);
#line 458
        mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp13];
#line 459
        __cil_tmp15 = opj_t1_getspb((OPJ_UINT32 )flag);
#line 459
        __cil_tmp14 = opj_mqc_decode(mqc);
#line 459
        v = __cil_tmp14 ^ (int )__cil_tmp15;
        }
#line 460
        if (v) {
#line 460
          tmp___0 = - oneplushalf;
        } else {
#line 460
          tmp___0 = oneplushalf;
        }
        {
#line 460
        *datap = tmp___0;
#line 461
        opj_t1_updateflags(flagsp, (OPJ_UINT32 )v, t1->flags_stride);
        }
      }
#line 463
      *flagsp = (opj_flag_t )((int )*flagsp | 16384);
    }
  }
#line 466
  return;
}
}
#line 469 "/root/patron/new_22/src/lib/openjp2/t1.c"
void opj_t1_enc_sigpass(opj_t1_t *t1 , OPJ_INT32 bpno , OPJ_UINT32 orient , OPJ_INT32 *nmsedec ,
                        OPJ_BYTE type , OPJ_UINT32 cblksty ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  OPJ_UINT32 vsc ;
  OPJ_INT32 one ;
  int tmp ;

  {
#line 480
  *nmsedec = 0;
#line 481
  one = 1 << (bpno + 6);
#line 482
  k = (OPJ_UINT32 )0;
  {
#line 482
  while (1) {
    while_continue: /* CIL Label */ ;

#line 482
    if (! (k < t1->h)) {
#line 482
      goto while_break;
    }
#line 483
    i = (OPJ_UINT32 )0;
    {
#line 483
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 483
      if (! (i < t1->w)) {
#line 483
        goto while_break___0;
      }
#line 484
      j = k;
      {
#line 484
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 484
        if (j < k + 4U) {
#line 484
          if (! (j < t1->h)) {
#line 484
            goto while_break___1;
          }
        } else {
#line 484
          goto while_break___1;
        }
#line 485
        if (cblksty & 8U) {
#line 485
          if (j == k + 3U) {
#line 485
            tmp = 1;
          } else
#line 485
          if (j == t1->h - 1U) {
#line 485
            tmp = 1;
          } else {
#line 485
            tmp = 0;
          }
        } else {
#line 485
          tmp = 0;
        }
        {
#line 485
        vsc = (OPJ_UINT32 )tmp;
#line 486
        opj_t1_enc_sigpass_step(t1, t1->flags + (((j + 1U) * t1->flags_stride + i) + 1U),
                                t1->data + (j * t1->w + i), orient, bpno, one, nmsedec,
                                type, vsc);
#line 484
        j ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: 
#line 483
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
#line 482
    k += 4U;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 486
  return;
}
}
#line 501 "/root/patron/new_22/src/lib/openjp2/t1.c"
void opj_t1_dec_sigpass_raw(opj_t1_t *t1 , OPJ_INT32 bpno , OPJ_INT32 orient , OPJ_INT32 cblksty ) 
{ 
  OPJ_INT32 one ;
  OPJ_INT32 half ;
  OPJ_INT32 oneplushalf ;
  OPJ_INT32 vsc ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  int tmp ;

  {
#line 509
  one = 1 << bpno;
#line 510
  half = one >> 1;
#line 511
  oneplushalf = one | half;
#line 512
  k = (OPJ_UINT32 )0;
  {
#line 512
  while (1) {
    while_continue: /* CIL Label */ ;

#line 512
    if (! (k < t1->h)) {
#line 512
      goto while_break;
    }
#line 513
    i = (OPJ_UINT32 )0;
    {
#line 513
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 513
      if (! (i < t1->w)) {
#line 513
        goto while_break___0;
      }
#line 514
      j = k;
      {
#line 514
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 514
        if (j < k + 4U) {
#line 514
          if (! (j < t1->h)) {
#line 514
            goto while_break___1;
          }
        } else {
#line 514
          goto while_break___1;
        }
#line 515
        if (cblksty & 8) {
#line 515
          if (j == k + 3U) {
#line 515
            tmp = 1;
          } else
#line 515
          if (j == t1->h - 1U) {
#line 515
            tmp = 1;
          } else {
#line 515
            tmp = 0;
          }
        } else {
#line 515
          tmp = 0;
        }
        {
#line 515
        vsc = tmp;
#line 516
        opj_t1_dec_sigpass_step_raw(t1, t1->flags + (((j + 1U) * t1->flags_stride + i) + 1U),
                                    t1->data + (j * t1->w + i), orient, oneplushalf,
                                    vsc);
#line 514
        j ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: 
#line 513
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
#line 512
    k += 4U;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 516
  return;
}
}
#line 528 "/root/patron/new_22/src/lib/openjp2/t1.c"
void opj_t1_dec_sigpass_mqc(opj_t1_t *t1 , OPJ_INT32 bpno , OPJ_INT32 orient ) 
{ 
  OPJ_INT32 one ;
  OPJ_INT32 half ;
  OPJ_INT32 oneplushalf ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  OPJ_INT32 *data1 ;
  opj_flag_t *flags1 ;
  OPJ_INT32 *data2 ;
  opj_flag_t *flags2 ;
  OPJ_INT32 *data2___0 ;
  opj_flag_t *flags2___0 ;

  {
#line 535
  data1 = t1->data;
#line 536
  flags1 = t1->flags + 1;
#line 537
  one = 1 << bpno;
#line 538
  half = one >> 1;
#line 539
  oneplushalf = one | half;
#line 540
  k = (OPJ_UINT32 )0;
  {
#line 540
  while (1) {
    while_continue: /* CIL Label */ ;

#line 540
    if (! (k < (t1->h & 4294967292U))) {
#line 540
      goto while_break;
    }
#line 541
    i = (OPJ_UINT32 )0;
    {
#line 541
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 541
      if (! (i < t1->w)) {
#line 541
        goto while_break___0;
      }
      {
#line 542
      data2 = data1 + i;
#line 543
      flags2 = flags1 + i;
#line 544
      flags2 += t1->flags_stride;
#line 545
      opj_t1_dec_sigpass_step_mqc(t1, flags2, data2, orient, oneplushalf);
#line 546
      data2 += t1->w;
#line 547
      flags2 += t1->flags_stride;
#line 548
      opj_t1_dec_sigpass_step_mqc(t1, flags2, data2, orient, oneplushalf);
#line 549
      data2 += t1->w;
#line 550
      flags2 += t1->flags_stride;
#line 551
      opj_t1_dec_sigpass_step_mqc(t1, flags2, data2, orient, oneplushalf);
#line 552
      data2 += t1->w;
#line 553
      flags2 += t1->flags_stride;
#line 554
      opj_t1_dec_sigpass_step_mqc(t1, flags2, data2, orient, oneplushalf);
#line 555
      data2 += t1->w;
#line 541
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
#line 557
    data1 += t1->w << 2;
#line 558
    flags1 += t1->flags_stride << 2;
#line 540
    k += 4U;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: 
#line 560
  i = (OPJ_UINT32 )0;
  {
#line 560
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 560
    if (! (i < t1->w)) {
#line 560
      goto while_break___1;
    }
#line 561
    data2___0 = data1 + i;
#line 562
    flags2___0 = flags1 + i;
#line 563
    j = k;
    {
#line 563
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 563
      if (! (j < t1->h)) {
#line 563
        goto while_break___2;
      }
      {
#line 564
      flags2___0 += t1->flags_stride;
#line 565
      opj_t1_dec_sigpass_step_mqc(t1, flags2___0, data2___0, orient, oneplushalf);
#line 566
      data2___0 += t1->w;
#line 563
      j ++;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: 
#line 560
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___1: ;
#line 564
  return;
}
}
#line 571 "/root/patron/new_22/src/lib/openjp2/t1.c"
void opj_t1_dec_sigpass_mqc_vsc(opj_t1_t *t1 , OPJ_INT32 bpno , OPJ_INT32 orient ) 
{ 
  OPJ_INT32 one ;
  OPJ_INT32 half ;
  OPJ_INT32 oneplushalf ;
  OPJ_INT32 vsc ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  int tmp ;

  {
#line 578
  one = 1 << bpno;
#line 579
  half = one >> 1;
#line 580
  oneplushalf = one | half;
#line 581
  k = (OPJ_UINT32 )0;
  {
#line 581
  while (1) {
    while_continue: /* CIL Label */ ;

#line 581
    if (! (k < t1->h)) {
#line 581
      goto while_break;
    }
#line 582
    i = (OPJ_UINT32 )0;
    {
#line 582
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 582
      if (! (i < t1->w)) {
#line 582
        goto while_break___0;
      }
#line 583
      j = k;
      {
#line 583
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 583
        if (j < k + 4U) {
#line 583
          if (! (j < t1->h)) {
#line 583
            goto while_break___1;
          }
        } else {
#line 583
          goto while_break___1;
        }
#line 584
        if (j == k + 3U) {
#line 584
          tmp = 1;
        } else
#line 584
        if (j == t1->h - 1U) {
#line 584
          tmp = 1;
        } else {
#line 584
          tmp = 0;
        }
        {
#line 584
        vsc = tmp;
#line 585
        opj_t1_dec_sigpass_step_mqc_vsc(t1, t1->flags + (((j + 1U) * t1->flags_stride + i) + 1U),
                                        t1->data + (j * t1->w + i), orient, oneplushalf,
                                        vsc);
#line 583
        j ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: 
#line 582
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
#line 581
    k += 4U;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 585
  return;
}
}
#line 599 "/root/patron/new_22/src/lib/openjp2/t1.c"
void opj_t1_enc_refpass_step(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                             OPJ_INT32 bpno , OPJ_INT32 one , OPJ_INT32 *nmsedec ,
                             OPJ_BYTE type , OPJ_UINT32 vsc ) 
{ 
  OPJ_INT32 v ;
  OPJ_UINT32 flag ;
  opj_mqc_t *mqc ;
  int tmp ;
  OPJ_INT32 __cil_tmp13 ;
  OPJ_INT16 __cil_tmp14 ;
  OPJ_INT32 __cil_tmp15 ;
  int tmp___0 ;
  OPJ_UINT32 __cil_tmp17 ;

  {
#line 611
  mqc = t1->mqc;
#line 613
  if (vsc) {
#line 613
    tmp = (int )*flagsp & -1095;
  } else {
#line 613
    tmp = (int )*flagsp;
  }
#line 613
  flag = (OPJ_UINT32 )tmp;
#line 614
  if ((flag & 20480U) == 4096U) {
    {
#line 615
    __cil_tmp13 = opj_int_abs(*datap);
#line 615
    __cil_tmp14 = opj_t1_getnmsedec_ref((OPJ_UINT32 )__cil_tmp13, (OPJ_UINT32 )(bpno + 6));
#line 615
    *nmsedec += (int )__cil_tmp14;
#line 616
    __cil_tmp15 = opj_int_abs(*datap);
    }
#line 616
    if (__cil_tmp15 & one) {
#line 616
      tmp___0 = 1;
    } else {
#line 616
      tmp___0 = 0;
    }
    {
#line 616
    v = tmp___0;
#line 617
    __cil_tmp17 = opj_t1_getctxno_mag(flag);
#line 617
    mqc->curctx = & mqc->ctxs[__cil_tmp17];
    }
#line 618
    if ((int )type == 1) {
      {
#line 619
      opj_mqc_bypass_enc(mqc, (OPJ_UINT32 )v);
      }
    } else {
      {
#line 621
      opj_mqc_encode(mqc, (OPJ_UINT32 )v);
      }
    }
#line 623
    *flagsp = (opj_flag_t )((int )*flagsp | 8192);
  }
#line 625
  return;
}
}
#line 627 "/root/patron/new_22/src/lib/openjp2/t1.c"
__inline void opj_t1_dec_refpass_step_raw(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                                          OPJ_INT32 poshalf , OPJ_INT32 neghalf ,
                                          OPJ_INT32 vsc ) 
{ 
  OPJ_INT32 v ;
  OPJ_INT32 t ;
  OPJ_INT32 flag ;
  opj_raw_t *raw ;
  int tmp ;
  OPJ_UINT32 __cil_tmp12 ;
  OPJ_INT32 tmp___0 ;
  OPJ_INT32 tmp___1 ;

  {
#line 637
  raw = t1->raw;
#line 639
  if (vsc) {
#line 639
    tmp = (int )*flagsp & -1095;
  } else {
#line 639
    tmp = (int )*flagsp;
  }
#line 639
  flag = tmp;
#line 640
  if ((flag & 20480) == 4096) {
    {
#line 641
    __cil_tmp12 = opj_raw_decode(raw);
#line 641
    v = (OPJ_INT32 )__cil_tmp12;
    }
#line 642
    if (v) {
#line 642
      tmp___0 = poshalf;
    } else {
#line 642
      tmp___0 = neghalf;
    }
#line 642
    t = tmp___0;
#line 643
    if (*datap < 0) {
#line 643
      tmp___1 = - t;
    } else {
#line 643
      tmp___1 = t;
    }
#line 643
    *datap += tmp___1;
#line 644
    *flagsp = (opj_flag_t )((int )*flagsp | 8192);
  }
#line 646
  return;
}
}
#line 648 "/root/patron/new_22/src/lib/openjp2/t1.c"
__inline void opj_t1_dec_refpass_step_mqc(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                                          OPJ_INT32 poshalf , OPJ_INT32 neghalf ) 
{ 
  OPJ_INT32 v ;
  OPJ_INT32 t ;
  OPJ_INT32 flag ;
  opj_mqc_t *mqc ;
  OPJ_UINT32 __cil_tmp10 ;
  OPJ_INT32 tmp ;
  OPJ_INT32 tmp___0 ;

  {
#line 657
  mqc = t1->mqc;
#line 659
  flag = (OPJ_INT32 )*flagsp;
#line 660
  if ((flag & 20480) == 4096) {
    {
#line 661
    __cil_tmp10 = opj_t1_getctxno_mag((OPJ_UINT32 )flag);
#line 661
    mqc->curctx = & mqc->ctxs[__cil_tmp10];
#line 662
    v = opj_mqc_decode(mqc);
    }
#line 663
    if (v) {
#line 663
      tmp = poshalf;
    } else {
#line 663
      tmp = neghalf;
    }
#line 663
    t = tmp;
#line 664
    if (*datap < 0) {
#line 664
      tmp___0 = - t;
    } else {
#line 664
      tmp___0 = t;
    }
#line 664
    *datap += tmp___0;
#line 665
    *flagsp = (opj_flag_t )((int )*flagsp | 8192);
  }
#line 667
  return;
}
}
#line 669 "/root/patron/new_22/src/lib/openjp2/t1.c"
__inline void opj_t1_dec_refpass_step_mqc_vsc(opj_t1_t *t1 , opj_flag_t *flagsp ,
                                              OPJ_INT32 *datap , OPJ_INT32 poshalf ,
                                              OPJ_INT32 neghalf , OPJ_INT32 vsc ) 
{ 
  OPJ_INT32 v ;
  OPJ_INT32 t ;
  OPJ_INT32 flag ;
  opj_mqc_t *mqc ;
  int tmp ;
  OPJ_UINT32 __cil_tmp12 ;
  OPJ_INT32 tmp___0 ;
  OPJ_INT32 tmp___1 ;

  {
#line 679
  mqc = t1->mqc;
#line 681
  if (vsc) {
#line 681
    tmp = (int )*flagsp & -1095;
  } else {
#line 681
    tmp = (int )*flagsp;
  }
#line 681
  flag = tmp;
#line 682
  if ((flag & 20480) == 4096) {
    {
#line 683
    __cil_tmp12 = opj_t1_getctxno_mag((OPJ_UINT32 )flag);
#line 683
    mqc->curctx = & mqc->ctxs[__cil_tmp12];
#line 684
    v = opj_mqc_decode(mqc);
    }
#line 685
    if (v) {
#line 685
      tmp___0 = poshalf;
    } else {
#line 685
      tmp___0 = neghalf;
    }
#line 685
    t = tmp___0;
#line 686
    if (*datap < 0) {
#line 686
      tmp___1 = - t;
    } else {
#line 686
      tmp___1 = t;
    }
#line 686
    *datap += tmp___1;
#line 687
    *flagsp = (opj_flag_t )((int )*flagsp | 8192);
  }
#line 689
  return;
}
}
#line 692 "/root/patron/new_22/src/lib/openjp2/t1.c"
void opj_t1_enc_refpass(opj_t1_t *t1 , OPJ_INT32 bpno , OPJ_INT32 *nmsedec , OPJ_BYTE type ,
                        OPJ_UINT32 cblksty ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  OPJ_UINT32 vsc ;
  OPJ_INT32 one ;
  int tmp ;

  {
#line 702
  *nmsedec = 0;
#line 703
  one = 1 << (bpno + 6);
#line 704
  k = (OPJ_UINT32 )0;
  {
#line 704
  while (1) {
    while_continue: /* CIL Label */ ;

#line 704
    if (! (k < t1->h)) {
#line 704
      goto while_break;
    }
#line 705
    i = (OPJ_UINT32 )0;
    {
#line 705
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 705
      if (! (i < t1->w)) {
#line 705
        goto while_break___0;
      }
#line 706
      j = k;
      {
#line 706
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 706
        if (j < k + 4U) {
#line 706
          if (! (j < t1->h)) {
#line 706
            goto while_break___1;
          }
        } else {
#line 706
          goto while_break___1;
        }
#line 707
        if (cblksty & 8U) {
#line 707
          if (j == k + 3U) {
#line 707
            tmp = 1;
          } else
#line 707
          if (j == t1->h - 1U) {
#line 707
            tmp = 1;
          } else {
#line 707
            tmp = 0;
          }
        } else {
#line 707
          tmp = 0;
        }
        {
#line 707
        vsc = (OPJ_UINT32 )tmp;
#line 708
        opj_t1_enc_refpass_step(t1, t1->flags + (((j + 1U) * t1->flags_stride + i) + 1U),
                                t1->data + (j * t1->w + i), bpno, one, nmsedec, type,
                                vsc);
#line 706
        j ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: 
#line 705
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
#line 704
    k += 4U;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 708
  return;
}
}
#line 722 "/root/patron/new_22/src/lib/openjp2/t1.c"
void opj_t1_dec_refpass_raw(opj_t1_t *t1 , OPJ_INT32 bpno , OPJ_INT32 cblksty ) 
{ 
  OPJ_INT32 one ;
  OPJ_INT32 poshalf ;
  OPJ_INT32 neghalf ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  OPJ_INT32 vsc ;
  OPJ_INT32 tmp ;
  int tmp___0 ;

  {
#line 730
  one = 1 << bpno;
#line 731
  poshalf = one >> 1;
#line 732
  if (bpno > 0) {
#line 732
    tmp = - poshalf;
  } else {
#line 732
    tmp = -1;
  }
#line 732
  neghalf = tmp;
#line 733
  k = (OPJ_UINT32 )0;
  {
#line 733
  while (1) {
    while_continue: /* CIL Label */ ;

#line 733
    if (! (k < t1->h)) {
#line 733
      goto while_break;
    }
#line 734
    i = (OPJ_UINT32 )0;
    {
#line 734
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 734
      if (! (i < t1->w)) {
#line 734
        goto while_break___0;
      }
#line 735
      j = k;
      {
#line 735
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 735
        if (j < k + 4U) {
#line 735
          if (! (j < t1->h)) {
#line 735
            goto while_break___1;
          }
        } else {
#line 735
          goto while_break___1;
        }
#line 736
        if (cblksty & 8) {
#line 736
          if (j == k + 3U) {
#line 736
            tmp___0 = 1;
          } else
#line 736
          if (j == t1->h - 1U) {
#line 736
            tmp___0 = 1;
          } else {
#line 736
            tmp___0 = 0;
          }
        } else {
#line 736
          tmp___0 = 0;
        }
        {
#line 736
        vsc = tmp___0;
#line 737
        opj_t1_dec_refpass_step_raw(t1, t1->flags + (((j + 1U) * t1->flags_stride + i) + 1U),
                                    t1->data + (j * t1->w + i), poshalf, neghalf,
                                    vsc);
#line 735
        j ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: 
#line 734
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
#line 733
    k += 4U;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 737
  return;
}
}
#line 749 "/root/patron/new_22/src/lib/openjp2/t1.c"
void opj_t1_dec_refpass_mqc(opj_t1_t *t1 , OPJ_INT32 bpno ) 
{ 
  OPJ_INT32 one ;
  OPJ_INT32 poshalf ;
  OPJ_INT32 neghalf ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  OPJ_INT32 *data1 ;
  opj_flag_t *flags1 ;
  OPJ_INT32 tmp ;
  OPJ_INT32 *data2 ;
  opj_flag_t *flags2 ;
  OPJ_INT32 *data2___0 ;
  opj_flag_t *flags2___0 ;

  {
#line 755
  data1 = t1->data;
#line 756
  flags1 = t1->flags + 1;
#line 757
  one = 1 << bpno;
#line 758
  poshalf = one >> 1;
#line 759
  if (bpno > 0) {
#line 759
    tmp = - poshalf;
  } else {
#line 759
    tmp = -1;
  }
#line 759
  neghalf = tmp;
#line 760
  k = (OPJ_UINT32 )0;
  {
#line 760
  while (1) {
    while_continue: /* CIL Label */ ;

#line 760
    if (! (k < (t1->h & 4294967292U))) {
#line 760
      goto while_break;
    }
#line 761
    i = (OPJ_UINT32 )0;
    {
#line 761
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 761
      if (! (i < t1->w)) {
#line 761
        goto while_break___0;
      }
      {
#line 762
      data2 = data1 + i;
#line 763
      flags2 = flags1 + i;
#line 764
      flags2 += t1->flags_stride;
#line 765
      opj_t1_dec_refpass_step_mqc(t1, flags2, data2, poshalf, neghalf);
#line 766
      data2 += t1->w;
#line 767
      flags2 += t1->flags_stride;
#line 768
      opj_t1_dec_refpass_step_mqc(t1, flags2, data2, poshalf, neghalf);
#line 769
      data2 += t1->w;
#line 770
      flags2 += t1->flags_stride;
#line 771
      opj_t1_dec_refpass_step_mqc(t1, flags2, data2, poshalf, neghalf);
#line 772
      data2 += t1->w;
#line 773
      flags2 += t1->flags_stride;
#line 774
      opj_t1_dec_refpass_step_mqc(t1, flags2, data2, poshalf, neghalf);
#line 775
      data2 += t1->w;
#line 761
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
#line 777
    data1 += t1->w << 2;
#line 778
    flags1 += t1->flags_stride << 2;
#line 760
    k += 4U;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: 
#line 780
  i = (OPJ_UINT32 )0;
  {
#line 780
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 780
    if (! (i < t1->w)) {
#line 780
      goto while_break___1;
    }
#line 781
    data2___0 = data1 + i;
#line 782
    flags2___0 = flags1 + i;
#line 783
    j = k;
    {
#line 783
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 783
      if (! (j < t1->h)) {
#line 783
        goto while_break___2;
      }
      {
#line 784
      flags2___0 += t1->flags_stride;
#line 785
      opj_t1_dec_refpass_step_mqc(t1, flags2___0, data2___0, poshalf, neghalf);
#line 786
      data2___0 += t1->w;
#line 783
      j ++;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: 
#line 780
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___1: ;
#line 784
  return;
}
}
#line 791 "/root/patron/new_22/src/lib/openjp2/t1.c"
void opj_t1_dec_refpass_mqc_vsc(opj_t1_t *t1 , OPJ_INT32 bpno ) 
{ 
  OPJ_INT32 one ;
  OPJ_INT32 poshalf ;
  OPJ_INT32 neghalf ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  OPJ_INT32 vsc ;
  OPJ_INT32 tmp ;
  int tmp___0 ;

  {
#line 798
  one = 1 << bpno;
#line 799
  poshalf = one >> 1;
#line 800
  if (bpno > 0) {
#line 800
    tmp = - poshalf;
  } else {
#line 800
    tmp = -1;
  }
#line 800
  neghalf = tmp;
#line 801
  k = (OPJ_UINT32 )0;
  {
#line 801
  while (1) {
    while_continue: /* CIL Label */ ;

#line 801
    if (! (k < t1->h)) {
#line 801
      goto while_break;
    }
#line 802
    i = (OPJ_UINT32 )0;
    {
#line 802
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 802
      if (! (i < t1->w)) {
#line 802
        goto while_break___0;
      }
#line 803
      j = k;
      {
#line 803
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 803
        if (j < k + 4U) {
#line 803
          if (! (j < t1->h)) {
#line 803
            goto while_break___1;
          }
        } else {
#line 803
          goto while_break___1;
        }
#line 804
        if (j == k + 3U) {
#line 804
          tmp___0 = 1;
        } else
#line 804
        if (j == t1->h - 1U) {
#line 804
          tmp___0 = 1;
        } else {
#line 804
          tmp___0 = 0;
        }
        {
#line 804
        vsc = tmp___0;
#line 805
        opj_t1_dec_refpass_step_mqc_vsc(t1, t1->flags + (((j + 1U) * t1->flags_stride + i) + 1U),
                                        t1->data + (j * t1->w + i), poshalf, neghalf,
                                        vsc);
#line 803
        j ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: 
#line 802
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
#line 801
    k += 4U;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 805
  return;
}
}
#line 818 "/root/patron/new_22/src/lib/openjp2/t1.c"
void opj_t1_enc_clnpass_step(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                             OPJ_UINT32 orient , OPJ_INT32 bpno , OPJ_INT32 one ,
                             OPJ_INT32 *nmsedec , OPJ_UINT32 partial , OPJ_UINT32 vsc ) 
{ 
  OPJ_INT32 v ;
  OPJ_UINT32 flag ;
  opj_mqc_t *mqc ;
  int tmp ;
  OPJ_BYTE __cil_tmp14 ;
  OPJ_INT32 __cil_tmp15 ;
  int tmp___0 ;
  OPJ_INT32 __cil_tmp17 ;
  OPJ_INT16 __cil_tmp18 ;
  OPJ_BYTE __cil_tmp19 ;
  int tmp___1 ;
  OPJ_BYTE __cil_tmp21 ;

  {
#line 832
  mqc = t1->mqc;
#line 834
  if (vsc) {
#line 834
    tmp = (int )*flagsp & -1095;
  } else {
#line 834
    tmp = (int )*flagsp;
  }
#line 834
  flag = (OPJ_UINT32 )tmp;
#line 835
  if (partial) {
#line 836
    goto LABEL_PARTIAL;
  }
#line 838
  if (! ((int )*flagsp & 20480)) {
    {
#line 839
    __cil_tmp14 = opj_t1_getctxno_zc(flag, orient);
#line 839
    mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp14];
#line 840
    __cil_tmp15 = opj_int_abs(*datap);
    }
#line 840
    if (__cil_tmp15 & one) {
#line 840
      tmp___0 = 1;
    } else {
#line 840
      tmp___0 = 0;
    }
    {
#line 840
    v = tmp___0;
#line 841
    opj_mqc_encode(mqc, (OPJ_UINT32 )v);
    }
#line 842
    if (v) {
      LABEL_PARTIAL: 
      {
#line 844
      __cil_tmp17 = opj_int_abs(*datap);
#line 844
      __cil_tmp18 = opj_t1_getnmsedec_sig((OPJ_UINT32 )__cil_tmp17, (OPJ_UINT32 )(bpno + 6));
#line 844
      *nmsedec += (int )__cil_tmp18;
#line 845
      __cil_tmp19 = opj_t1_getctxno_sc(flag);
#line 845
      mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp19];
      }
#line 846
      if (*datap < 0) {
#line 846
        tmp___1 = 1;
      } else {
#line 846
        tmp___1 = 0;
      }
      {
#line 846
      v = tmp___1;
#line 847
      __cil_tmp21 = opj_t1_getspb(flag);
#line 847
      opj_mqc_encode(mqc, (OPJ_UINT32 )(v ^ (int )__cil_tmp21));
#line 848
      opj_t1_updateflags(flagsp, (OPJ_UINT32 )v, t1->flags_stride);
      }
    }
  }
#line 851
  *flagsp = (opj_flag_t )((int )*flagsp & -16385);
#line 852
  return;
}
}
#line 854 "/root/patron/new_22/src/lib/openjp2/t1.c"
static void opj_t1_dec_clnpass_step_partial(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                                            OPJ_INT32 orient , OPJ_INT32 oneplushalf ) 
{ 
  OPJ_INT32 v ;
  OPJ_INT32 flag ;
  opj_mqc_t *mqc ;
  OPJ_BYTE __cil_tmp9 ;
  OPJ_INT32 __cil_tmp10 ;
  OPJ_BYTE __cil_tmp11 ;
  OPJ_INT32 tmp ;

  {
  {
#line 862
  mqc = t1->mqc;
#line 866
  flag = (OPJ_INT32 )*flagsp;
#line 867
  __cil_tmp9 = opj_t1_getctxno_sc((OPJ_UINT32 )flag);
#line 867
  mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp9];
#line 868
  __cil_tmp11 = opj_t1_getspb((OPJ_UINT32 )flag);
#line 868
  __cil_tmp10 = opj_mqc_decode(mqc);
#line 868
  v = __cil_tmp10 ^ (int )__cil_tmp11;
  }
#line 869
  if (v) {
#line 869
    tmp = - oneplushalf;
  } else {
#line 869
    tmp = oneplushalf;
  }
  {
#line 869
  *datap = tmp;
#line 870
  opj_t1_updateflags(flagsp, (OPJ_UINT32 )v, t1->flags_stride);
#line 871
  *flagsp = (opj_flag_t )((int )*flagsp & -16385);
  }
#line 873
  return;
}
}
#line 874 "/root/patron/new_22/src/lib/openjp2/t1.c"
static void opj_t1_dec_clnpass_step(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                                    OPJ_INT32 orient , OPJ_INT32 oneplushalf ) 
{ 
  OPJ_INT32 v ;
  OPJ_INT32 flag ;
  opj_mqc_t *mqc ;
  OPJ_BYTE __cil_tmp9 ;
  OPJ_INT32 __cil_tmp10 ;
  OPJ_BYTE __cil_tmp11 ;
  OPJ_INT32 __cil_tmp12 ;
  OPJ_BYTE __cil_tmp13 ;
  OPJ_INT32 tmp ;

  {
#line 883
  mqc = t1->mqc;
#line 885
  flag = (OPJ_INT32 )*flagsp;
#line 886
  if (! (flag & 20480)) {
    {
#line 887
    __cil_tmp9 = opj_t1_getctxno_zc((OPJ_UINT32 )flag, (OPJ_UINT32 )orient);
#line 887
    mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp9];
#line 888
    __cil_tmp10 = opj_mqc_decode(mqc);
    }
#line 888
    if (__cil_tmp10) {
      {
#line 889
      __cil_tmp11 = opj_t1_getctxno_sc((OPJ_UINT32 )flag);
#line 889
      mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp11];
#line 890
      __cil_tmp13 = opj_t1_getspb((OPJ_UINT32 )flag);
#line 890
      __cil_tmp12 = opj_mqc_decode(mqc);
#line 890
      v = __cil_tmp12 ^ (int )__cil_tmp13;
      }
#line 891
      if (v) {
#line 891
        tmp = - oneplushalf;
      } else {
#line 891
        tmp = oneplushalf;
      }
      {
#line 891
      *datap = tmp;
#line 892
      opj_t1_updateflags(flagsp, (OPJ_UINT32 )v, t1->flags_stride);
      }
    }
  }
#line 895
  *flagsp = (opj_flag_t )((int )*flagsp & -16385);
#line 896
  return;
}
}
#line 898 "/root/patron/new_22/src/lib/openjp2/t1.c"
static void opj_t1_dec_clnpass_step_vsc(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                                        OPJ_INT32 orient , OPJ_INT32 oneplushalf ,
                                        OPJ_INT32 partial , OPJ_INT32 vsc ) 
{ 
  OPJ_INT32 v ;
  OPJ_INT32 flag ;
  opj_mqc_t *mqc ;
  int tmp ;
  OPJ_BYTE __cil_tmp12 ;
  OPJ_INT32 __cil_tmp13 ;
  OPJ_BYTE __cil_tmp14 ;
  OPJ_INT32 __cil_tmp15 ;
  OPJ_BYTE __cil_tmp16 ;
  OPJ_INT32 tmp___0 ;

  {
#line 909
  mqc = t1->mqc;
#line 911
  if (vsc) {
#line 911
    tmp = (int )*flagsp & -1095;
  } else {
#line 911
    tmp = (int )*flagsp;
  }
#line 911
  flag = tmp;
#line 912
  if (partial) {
#line 913
    goto LABEL_PARTIAL;
  }
#line 915
  if (! (flag & 20480)) {
    {
#line 916
    __cil_tmp12 = opj_t1_getctxno_zc((OPJ_UINT32 )flag, (OPJ_UINT32 )orient);
#line 916
    mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp12];
#line 917
    __cil_tmp13 = opj_mqc_decode(mqc);
    }
#line 917
    if (__cil_tmp13) {
      LABEL_PARTIAL: 
      {
#line 919
      __cil_tmp14 = opj_t1_getctxno_sc((OPJ_UINT32 )flag);
#line 919
      mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp14];
#line 920
      __cil_tmp16 = opj_t1_getspb((OPJ_UINT32 )flag);
#line 920
      __cil_tmp15 = opj_mqc_decode(mqc);
#line 920
      v = __cil_tmp15 ^ (int )__cil_tmp16;
      }
#line 921
      if (v) {
#line 921
        tmp___0 = - oneplushalf;
      } else {
#line 921
        tmp___0 = oneplushalf;
      }
      {
#line 921
      *datap = tmp___0;
#line 922
      opj_t1_updateflags(flagsp, (OPJ_UINT32 )v, t1->flags_stride);
      }
    }
  }
#line 925
  *flagsp = (opj_flag_t )((int )*flagsp & -16385);
#line 926
  return;
}
}
#line 928 "/root/patron/new_22/src/lib/openjp2/t1.c"
void opj_t1_enc_clnpass(opj_t1_t *t1 , OPJ_INT32 bpno , OPJ_UINT32 orient , OPJ_INT32 *nmsedec ,
                        OPJ_UINT32 cblksty ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  OPJ_INT32 one ;
  OPJ_UINT32 agg ;
  OPJ_UINT32 runlen ;
  OPJ_UINT32 vsc ;
  opj_mqc_t *mqc ;
  OPJ_INT32 __cil_tmp14 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 939
  mqc = t1->mqc;
#line 941
  *nmsedec = 0;
#line 942
  one = 1 << (bpno + 6);
#line 943
  k = (OPJ_UINT32 )0;
  {
#line 943
  while (1) {
    while_continue: /* CIL Label */ ;

#line 943
    if (! (k < t1->h)) {
#line 943
      goto while_break;
    }
#line 944
    i = (OPJ_UINT32 )0;
    {
#line 944
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue___0: ;
#line 944
      if (! (i < t1->w)) {
#line 944
        goto while_break___0;
      }
#line 945
      if (k + 3U < t1->h) {
#line 946
        if (cblksty & 8U) {
#line 947
          if ((int )*(t1->flags + ((1U + k) * t1->flags_stride + (1U + i))) & 20735) {
#line 947
            tmp___0 = 0;
          } else
#line 947
          if ((int )*(t1->flags + (((1U + k) + 1U) * t1->flags_stride + (1U + i))) & 20735) {
#line 947
            tmp___0 = 0;
          } else
#line 947
          if ((int )*(t1->flags + (((1U + k) + 2U) * t1->flags_stride + (1U + i))) & 20735) {
#line 947
            tmp___0 = 0;
          } else
#line 947
          if (((int )*(t1->flags + (((1U + k) + 3U) * t1->flags_stride + (1U + i))) & -1095) & 20735) {
#line 947
            tmp___0 = 0;
          } else {
#line 947
            tmp___0 = 1;
          }
#line 947
          agg = (OPJ_UINT32 )tmp___0;
        } else {
#line 953
          if ((int )*(t1->flags + ((1U + k) * t1->flags_stride + (1U + i))) & 20735) {
#line 953
            tmp___1 = 0;
          } else
#line 953
          if ((int )*(t1->flags + (((1U + k) + 1U) * t1->flags_stride + (1U + i))) & 20735) {
#line 953
            tmp___1 = 0;
          } else
#line 953
          if ((int )*(t1->flags + (((1U + k) + 2U) * t1->flags_stride + (1U + i))) & 20735) {
#line 953
            tmp___1 = 0;
          } else
#line 953
          if ((int )*(t1->flags + (((1U + k) + 3U) * t1->flags_stride + (1U + i))) & 20735) {
#line 953
            tmp___1 = 0;
          } else {
#line 953
            tmp___1 = 1;
          }
#line 953
          agg = (OPJ_UINT32 )tmp___1;
        }
      } else {
#line 959
        agg = (OPJ_UINT32 )0;
      }
#line 961
      if (agg) {
#line 962
        runlen = (OPJ_UINT32 )0;
        {
#line 962
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 962
          if (! (runlen < 4U)) {
#line 962
            goto while_break___1;
          }
          {
#line 963
          __cil_tmp14 = opj_int_abs(*(t1->data + ((k + runlen) * t1->w + i)));
          }
#line 963
          if (__cil_tmp14 & one) {
#line 964
            goto while_break___1;
          }
#line 962
          runlen ++;
        }
        while_break___5: /* CIL Label */ ;
        }
        while_break___1: 
        {
#line 966
        mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )17];
#line 967
        opj_mqc_encode(mqc, (OPJ_UINT32 )(runlen != 4U));
        }
#line 968
        if (runlen == 4U) {
#line 969
          goto while_continue___0;
        }
        {
#line 971
        mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )18];
#line 972
        opj_mqc_encode(mqc, runlen >> 1);
#line 973
        opj_mqc_encode(mqc, runlen & 1U);
        }
      } else {
#line 975
        runlen = (OPJ_UINT32 )0;
      }
#line 977
      j = k + runlen;
      {
#line 977
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 977
        if (j < k + 4U) {
#line 977
          if (! (j < t1->h)) {
#line 977
            goto while_break___2;
          }
        } else {
#line 977
          goto while_break___2;
        }
#line 978
        if (cblksty & 8U) {
#line 978
          if (j == k + 3U) {
#line 978
            tmp = 1;
          } else
#line 978
          if (j == t1->h - 1U) {
#line 978
            tmp = 1;
          } else {
#line 978
            tmp = 0;
          }
        } else {
#line 978
          tmp = 0;
        }
#line 978
        vsc = (OPJ_UINT32 )tmp;
#line 979
        if (agg) {
#line 979
          if (j == k + runlen) {
#line 979
            tmp___2 = 1;
          } else {
#line 979
            tmp___2 = 0;
          }
        } else {
#line 979
          tmp___2 = 0;
        }
        {
#line 979
        opj_t1_enc_clnpass_step(t1, t1->flags + (((j + 1U) * t1->flags_stride + i) + 1U),
                                t1->data + (j * t1->w + i), orient, bpno, one, nmsedec,
                                (OPJ_UINT32 )tmp___2, vsc);
#line 977
        j ++;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___2: 
#line 944
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
#line 943
    k += 4U;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: ;
#line 947
  return;
}
}
#line 994 "/root/patron/new_22/src/lib/openjp2/t1.c"
static void opj_t1_dec_clnpass(opj_t1_t *t1 , OPJ_INT32 bpno , OPJ_INT32 orient ,
                               OPJ_INT32 cblksty ) 
{ 
  OPJ_INT32 one ;
  OPJ_INT32 half ;
  OPJ_INT32 oneplushalf ;
  OPJ_INT32 agg ;
  OPJ_INT32 runlen ;
  OPJ_INT32 vsc ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  OPJ_INT32 segsym ;
  opj_mqc_t *mqc ;
  OPJ_INT32 __cil_tmp16 ;
  OPJ_INT32 __cil_tmp18 ;
  int tmp ;
  OPJ_INT32 *data1 ;
  opj_flag_t *flags1 ;
  OPJ_INT32 *data2 ;
  opj_flag_t *flags2 ;
  OPJ_INT32 __cil_tmp24 ;
  OPJ_INT32 __cil_tmp26 ;
  OPJ_INT32 *data2___0 ;
  opj_flag_t *flags2___0 ;
  OPJ_INT32 v ;
  OPJ_INT32 __cil_tmp31 ;
  OPJ_INT32 __cil_tmp32 ;
  OPJ_INT32 __cil_tmp33 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1002
  segsym = cblksty & 32;
#line 1004
  mqc = t1->mqc;
#line 1006
  one = 1 << bpno;
#line 1007
  half = one >> 1;
#line 1008
  oneplushalf = one | half;
#line 1009
  if (cblksty & 8) {
#line 1010
    k = (OPJ_UINT32 )0;
    {
#line 1010
    while (1) {
      while_continue: /* CIL Label */ ;

#line 1010
      if (! (k < t1->h)) {
#line 1010
        goto while_break;
      }
#line 1011
      i = (OPJ_UINT32 )0;
      {
#line 1011
      while (1) {
        while_continue___4: /* CIL Label */ ;
        while_continue___0: ;
#line 1011
        if (! (i < t1->w)) {
#line 1011
          goto while_break___0;
        }
#line 1012
        if (k + 3U < t1->h) {
#line 1013
          if ((int )*(t1->flags + ((1U + k) * t1->flags_stride + (1U + i))) & 20735) {
#line 1013
            tmp___0 = 0;
          } else
#line 1013
          if ((int )*(t1->flags + (((1U + k) + 1U) * t1->flags_stride + (1U + i))) & 20735) {
#line 1013
            tmp___0 = 0;
          } else
#line 1013
          if ((int )*(t1->flags + (((1U + k) + 2U) * t1->flags_stride + (1U + i))) & 20735) {
#line 1013
            tmp___0 = 0;
          } else
#line 1013
          if (((int )*(t1->flags + (((1U + k) + 3U) * t1->flags_stride + (1U + i))) & -1095) & 20735) {
#line 1013
            tmp___0 = 0;
          } else {
#line 1013
            tmp___0 = 1;
          }
#line 1013
          agg = tmp___0;
        } else {
#line 1019
          agg = 0;
        }
#line 1021
        if (agg) {
          {
#line 1022
          mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )17];
#line 1023
          __cil_tmp16 = opj_mqc_decode(mqc);
          }
#line 1023
          if (! __cil_tmp16) {
#line 1024
            goto while_continue___0;
          }
          {
#line 1026
          mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )18];
#line 1027
          runlen = opj_mqc_decode(mqc);
#line 1028
          __cil_tmp18 = opj_mqc_decode(mqc);
#line 1028
          runlen = (runlen << 1) | __cil_tmp18;
          }
        } else {
#line 1030
          runlen = 0;
        }
#line 1032
        j = k + (unsigned int )runlen;
        {
#line 1032
        while (1) {
          while_continue___5: /* CIL Label */ ;

#line 1032
          if (j < k + 4U) {
#line 1032
            if (! (j < t1->h)) {
#line 1032
              goto while_break___1;
            }
          } else {
#line 1032
            goto while_break___1;
          }
#line 1033
          if (j == k + 3U) {
#line 1033
            tmp = 1;
          } else
#line 1033
          if (j == t1->h - 1U) {
#line 1033
            tmp = 1;
          } else {
#line 1033
            tmp = 0;
          }
#line 1033
          vsc = tmp;
#line 1034
          if (agg) {
#line 1034
            if (j == k + (unsigned int )runlen) {
#line 1034
              tmp___1 = 1;
            } else {
#line 1034
              tmp___1 = 0;
            }
          } else {
#line 1034
            tmp___1 = 0;
          }
          {
#line 1034
          opj_t1_dec_clnpass_step_vsc(t1, t1->flags + (((j + 1U) * t1->flags_stride + i) + 1U),
                                      t1->data + (j * t1->w + i), orient, oneplushalf,
                                      tmp___1, vsc);
#line 1032
          j ++;
          }
        }
        while_break___9: /* CIL Label */ ;
        }
        while_break___1: 
#line 1011
        i ++;
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___0: 
#line 1010
      k += 4U;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break: ;
  } else {
#line 1046
    data1 = t1->data;
#line 1047
    flags1 = t1->flags + 1;
#line 1048
    k = (OPJ_UINT32 )0;
    {
#line 1048
    while (1) {
      while_continue___6: /* CIL Label */ ;

#line 1048
      if (! (k < (t1->h & 4294967292U))) {
#line 1048
        goto while_break___2;
      }
#line 1049
      i = (OPJ_UINT32 )0;
      {
#line 1049
      while (1) {
        while_continue___7: /* CIL Label */ ;
        while_continue___3: ;
#line 1049
        if (! (i < t1->w)) {
#line 1049
          goto while_break___3;
        }
#line 1050
        data2 = data1 + i;
#line 1051
        flags2 = flags1 + i;
#line 1052
        if ((int )*(t1->flags + ((1U + k) * t1->flags_stride + (1U + i))) & 20735) {
#line 1052
          tmp___2 = 0;
        } else
#line 1052
        if ((int )*(t1->flags + (((1U + k) + 1U) * t1->flags_stride + (1U + i))) & 20735) {
#line 1052
          tmp___2 = 0;
        } else
#line 1052
        if ((int )*(t1->flags + (((1U + k) + 2U) * t1->flags_stride + (1U + i))) & 20735) {
#line 1052
          tmp___2 = 0;
        } else
#line 1052
        if ((int )*(t1->flags + (((1U + k) + 3U) * t1->flags_stride + (1U + i))) & 20735) {
#line 1052
          tmp___2 = 0;
        } else {
#line 1052
          tmp___2 = 1;
        }
#line 1052
        agg = tmp___2;
#line 1056
        if (agg) {
          {
#line 1057
          mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )17];
#line 1058
          __cil_tmp24 = opj_mqc_decode(mqc);
          }
#line 1058
          if (! __cil_tmp24) {
#line 1059
            goto while_continue___3;
          }
          {
#line 1061
          mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )18];
#line 1062
          runlen = opj_mqc_decode(mqc);
#line 1063
          __cil_tmp26 = opj_mqc_decode(mqc);
#line 1063
          runlen = (runlen << 1) | __cil_tmp26;
#line 1064
          flags2 += (unsigned int )runlen * t1->flags_stride;
#line 1065
          data2 += (unsigned int )runlen * t1->w;
#line 1066
          j = k + (unsigned int )runlen;
          }
          {
#line 1066
          while (1) {
            while_continue___8: /* CIL Label */ ;

#line 1066
            if (j < k + 4U) {
#line 1066
              if (! (j < t1->h)) {
#line 1066
                goto while_break___4;
              }
            } else {
#line 1066
              goto while_break___4;
            }
#line 1067
            flags2 += t1->flags_stride;
#line 1068
            if (agg) {
#line 1068
              if (j == k + (unsigned int )runlen) {
                {
#line 1069
                opj_t1_dec_clnpass_step_partial(t1, flags2, data2, orient, oneplushalf);
                }
              } else {
                {
#line 1071
                opj_t1_dec_clnpass_step(t1, flags2, data2, orient, oneplushalf);
                }
              }
            } else {
              {
#line 1071
              opj_t1_dec_clnpass_step(t1, flags2, data2, orient, oneplushalf);
              }
            }
#line 1073
            data2 += t1->w;
#line 1066
            j ++;
          }
          while_break___12: /* CIL Label */ ;
          }
          while_break___4: ;
        } else {
          {
#line 1076
          flags2 += t1->flags_stride;
#line 1077
          opj_t1_dec_clnpass_step(t1, flags2, data2, orient, oneplushalf);
#line 1078
          data2 += t1->w;
#line 1079
          flags2 += t1->flags_stride;
#line 1080
          opj_t1_dec_clnpass_step(t1, flags2, data2, orient, oneplushalf);
#line 1081
          data2 += t1->w;
#line 1082
          flags2 += t1->flags_stride;
#line 1083
          opj_t1_dec_clnpass_step(t1, flags2, data2, orient, oneplushalf);
#line 1084
          data2 += t1->w;
#line 1085
          flags2 += t1->flags_stride;
#line 1086
          opj_t1_dec_clnpass_step(t1, flags2, data2, orient, oneplushalf);
#line 1087
          data2 += t1->w;
          }
        }
#line 1049
        i ++;
      }
      while_break___11: /* CIL Label */ ;
      }
      while_break___3: 
#line 1090
      data1 += t1->w << 2;
#line 1091
      flags1 += t1->flags_stride << 2;
#line 1048
      k += 4U;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___2: 
#line 1093
    i = (OPJ_UINT32 )0;
    {
#line 1093
    while (1) {
      while_continue___9: /* CIL Label */ ;

#line 1093
      if (! (i < t1->w)) {
#line 1093
        goto while_break___5;
      }
#line 1094
      data2___0 = data1 + i;
#line 1095
      flags2___0 = flags1 + i;
#line 1096
      j = k;
      {
#line 1096
      while (1) {
        while_continue___10: /* CIL Label */ ;

#line 1096
        if (! (j < t1->h)) {
#line 1096
          goto while_break___6;
        }
        {
#line 1097
        flags2___0 += t1->flags_stride;
#line 1098
        opj_t1_dec_clnpass_step(t1, flags2___0, data2___0, orient, oneplushalf);
#line 1099
        data2___0 += t1->w;
#line 1096
        j ++;
        }
      }
      while_break___14: /* CIL Label */ ;
      }
      while_break___6: 
#line 1093
      i ++;
    }
    while_break___13: /* CIL Label */ ;
    }
    while_break___5: ;
  }
#line 1104
  if (segsym) {
    {
#line 1105
    v = 0;
#line 1106
    mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )18];
#line 1107
    v = opj_mqc_decode(mqc);
#line 1108
    __cil_tmp31 = opj_mqc_decode(mqc);
#line 1108
    v = (v << 1) | __cil_tmp31;
#line 1109
    __cil_tmp32 = opj_mqc_decode(mqc);
#line 1109
    v = (v << 1) | __cil_tmp32;
#line 1110
    __cil_tmp33 = opj_mqc_decode(mqc);
#line 1110
    v = (v << 1) | __cil_tmp33;
    }
  }
#line 1113
  return;
}
}
#line 1121 "/root/patron/new_22/src/lib/openjp2/t1.c"
static OPJ_FLOAT64 opj_t1_getwmsedec(OPJ_INT32 nmsedec , OPJ_UINT32 compno , OPJ_UINT32 level ,
                                     OPJ_UINT32 orient , OPJ_INT32 bpno , OPJ_UINT32 qmfbid ,
                                     OPJ_FLOAT64 stepsize , OPJ_UINT32 numcomps ,
                                     OPJ_FLOAT64 *mct_norms ) 
{ 
  OPJ_FLOAT64 w1 ;
  OPJ_FLOAT64 w2 ;
  OPJ_FLOAT64 wmsedec ;

  {
#line 1132
  w1 = (OPJ_FLOAT64 )1;
#line 1135
  if (mct_norms) {
#line 1136
    w1 = *(mct_norms + compno);
  }
#line 1139
  if (qmfbid == 1U) {
    {
#line 1140
    w2 = opj_dwt_getnorm(level, orient);
    }
  } else {
    {
#line 1142
    w2 = opj_dwt_getnorm_real(level, orient);
    }
  }
#line 1145
  wmsedec = ((w1 * w2) * stepsize) * (double )(1 << bpno);
#line 1146
  wmsedec *= (wmsedec * (double )nmsedec) / 8192.;
#line 1148
  return (wmsedec);
}
}
#line 1151 "/root/patron/new_22/src/lib/openjp2/t1.c"
OPJ_BOOL opj_t1_allocate_buffers(opj_t1_t *t1 , OPJ_UINT32 w , OPJ_UINT32 h ) 
{ 
  OPJ_UINT32 datasize ;
  OPJ_UINT32 flagssize ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;

  {
#line 1156
  datasize = w * h;
#line 1159
  if (datasize > t1->datasize) {
    {
#line 1160
    free((void *)t1->data);
#line 1161
    __cil_tmp6 = malloc((unsigned long )datasize * sizeof(OPJ_INT32 ));
#line 1161
    t1->data = (OPJ_INT32 *)__cil_tmp6;
    }
#line 1162
    if (! t1->data) {
#line 1163
      return (0);
    }
#line 1165
    t1->datasize = datasize;
  }
  {
#line 1167
  memset((void *)t1->data, 0, (unsigned long )datasize * sizeof(OPJ_INT32 ));
#line 1169
  t1->flags_stride = w + 2U;
#line 1170
  flagssize = t1->flags_stride * (h + 2U);
  }
#line 1172
  if (flagssize > t1->flagssize) {
    {
#line 1173
    free((void *)t1->flags);
#line 1174
    __cil_tmp7 = malloc((unsigned long )flagssize * sizeof(opj_flag_t ));
#line 1174
    t1->flags = (opj_flag_t *)__cil_tmp7;
    }
#line 1175
    if (! t1->flags) {
#line 1176
      return (0);
    }
#line 1178
    t1->flagssize = flagssize;
  }
  {
#line 1180
  memset((void *)t1->flags, 0, (unsigned long )flagssize * sizeof(opj_flag_t ));
#line 1182
  t1->w = w;
#line 1183
  t1->h = h;
  }
#line 1185
  return (1);
}
}
#line 1196 "/root/patron/new_22/src/lib/openjp2/t1.c"
opj_t1_t *opj_t1_create(void) 
{ 
  opj_t1_t *l_t1 ;
  void *__cil_tmp2 ;

  {
  {
#line 1198
  l_t1 = (opj_t1_t *)0;
#line 1200
  __cil_tmp2 = malloc(sizeof(opj_t1_t ));
#line 1200
  l_t1 = (opj_t1_t *)__cil_tmp2;
  }
#line 1201
  if (! l_t1) {
#line 1202
    return ((opj_t1_t *)0);
  }
  {
#line 1204
  memset((void *)l_t1, 0, sizeof(opj_t1_t ));
#line 1207
  l_t1->mqc = opj_mqc_create();
  }
#line 1208
  if (! l_t1->mqc) {
    {
#line 1209
    opj_t1_destroy(l_t1);
    }
#line 1210
    return ((opj_t1_t *)0);
  }
  {
#line 1213
  l_t1->raw = opj_raw_create();
  }
#line 1214
  if (! l_t1->raw) {
    {
#line 1215
    opj_t1_destroy(l_t1);
    }
#line 1216
    return ((opj_t1_t *)0);
  }
#line 1219
  return (l_t1);
}
}
#line 1228 "/root/patron/new_22/src/lib/openjp2/t1.c"
void opj_t1_destroy(opj_t1_t *p_t1 ) 
{ 


  {
#line 1230
  if (! p_t1) {
#line 1231
    return;
  }
  {
#line 1235
  opj_mqc_destroy(p_t1->mqc);
#line 1236
  p_t1->mqc = (opj_mqc_t *)0;
#line 1237
  opj_raw_destroy(p_t1->raw);
#line 1238
  p_t1->raw = (opj_raw_t *)0;
  }
#line 1240
  if (p_t1->data) {
    {
#line 1241
    free((void *)p_t1->data);
#line 1242
    p_t1->data = (OPJ_INT32 *)0;
    }
  }
#line 1245
  if (p_t1->flags) {
    {
#line 1246
    free((void *)p_t1->flags);
#line 1247
    p_t1->flags = (opj_flag_t *)0;
    }
  }
  {
#line 1250
  free((void *)p_t1);
  }
#line 1252
  return;
}
}
#line 1253 "/root/patron/new_22/src/lib/openjp2/t1.c"
OPJ_BOOL opj_t1_decode_cblks(opj_t1_t *t1 , opj_tcd_tilecomp_t *tilec , opj_tccp_t *tccp ) 
{ 
  OPJ_UINT32 resno ;
  OPJ_UINT32 bandno ;
  OPJ_UINT32 precno ;
  OPJ_UINT32 cblkno ;
  OPJ_UINT32 tile_w ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *precinct ;
  opj_tcd_cblk_dec_t *cblk ;
  OPJ_INT32 *datap ;
  OPJ_UINT32 cblk_w ;
  OPJ_UINT32 cblk_h ;
  OPJ_INT32 x ;
  OPJ_INT32 y ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_BOOL __cil_tmp20 ;
  opj_tcd_resolution_t *pres ;
  opj_tcd_resolution_t *pres___0 ;
  OPJ_INT32 thresh ;
  OPJ_INT32 val ;
  OPJ_INT32 mag ;
  int __cil_tmp26 ;
  OPJ_INT32 tmp ;
  OPJ_INT32 *tiledp ;
  OPJ_INT32 tmp___0 ;
  OPJ_FLOAT32 *tiledp___0 ;
  OPJ_FLOAT32 *tiledp2 ;
  OPJ_FLOAT32 tmp___1 ;

  {
#line 1259
  tile_w = (OPJ_UINT32 )(tilec->x1 - tilec->x0);
#line 1261
  resno = (OPJ_UINT32 )0;
  {
#line 1261
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1261
    if (! (resno < tilec->minimum_num_resolutions)) {
#line 1261
      goto while_break;
    }
#line 1262
    res = tilec->resolutions + resno;
#line 1264
    bandno = (OPJ_UINT32 )0;
    {
#line 1264
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1264
      if (! (bandno < res->numbands)) {
#line 1264
        goto while_break___0;
      }
#line 1265
      band = & res->bands[bandno];
#line 1267
      precno = (OPJ_UINT32 )0;
      {
#line 1267
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 1267
        if (! (precno < res->pw * res->ph)) {
#line 1267
          goto while_break___1;
        }
#line 1268
        precinct = band->precincts + precno;
#line 1270
        cblkno = (OPJ_UINT32 )0;
        {
#line 1270
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 1270
          if (! (cblkno < precinct->cw * precinct->ch)) {
#line 1270
            goto while_break___2;
          }
          {
#line 1271
          cblk = precinct->cblks.dec + cblkno;
#line 1278
          __cil_tmp20 = opj_t1_decode_cblk(t1, cblk, band->bandno, (OPJ_UINT32 )tccp->roishift,
                                           tccp->cblksty);
          }
#line 1278
          if (0 == __cil_tmp20) {
#line 1284
            return (0);
          }
#line 1287
          x = cblk->x0 - band->x0;
#line 1288
          y = cblk->y0 - band->y0;
#line 1289
          if (band->bandno & 1U) {
#line 1290
            pres = tilec->resolutions + (resno - 1U);
#line 1291
            x += pres->x1 - pres->x0;
          }
#line 1293
          if (band->bandno & 2U) {
#line 1294
            pres___0 = tilec->resolutions + (resno - 1U);
#line 1295
            y += pres___0->y1 - pres___0->y0;
          }
#line 1298
          datap = t1->data;
#line 1299
          cblk_w = t1->w;
#line 1300
          cblk_h = t1->h;
#line 1302
          if (tccp->roishift) {
#line 1303
            thresh = 1 << tccp->roishift;
#line 1304
            j = (OPJ_UINT32 )0;
            {
#line 1304
            while (1) {
              while_continue___3: /* CIL Label */ ;

#line 1304
              if (! (j < cblk_h)) {
#line 1304
                goto while_break___3;
              }
#line 1305
              i = (OPJ_UINT32 )0;
              {
#line 1305
              while (1) {
                while_continue___4: /* CIL Label */ ;

#line 1305
                if (! (i < cblk_w)) {
#line 1305
                  goto while_break___4;
                }
                {
#line 1306
                val = *(datap + (j * cblk_w + i));
#line 1307
                __cil_tmp26 = abs(val);
#line 1307
                mag = __cil_tmp26;
                }
#line 1308
                if (mag >= thresh) {
#line 1309
                  mag >>= tccp->roishift;
#line 1310
                  if (val < 0) {
#line 1310
                    tmp = - mag;
                  } else {
#line 1310
                    tmp = mag;
                  }
#line 1310
                  *(datap + (j * cblk_w + i)) = tmp;
                }
#line 1305
                i ++;
              }
              while_break___14: /* CIL Label */ ;
              }
              while_break___4: 
#line 1304
              j ++;
            }
            while_break___13: /* CIL Label */ ;
            }
            while_break___3: ;
          }
#line 1317
          if (tccp->qmfbid == 1U) {
#line 1318
            tiledp = tilec->data + ((unsigned int )y * tile_w + (unsigned int )x);
#line 1319
            j = (OPJ_UINT32 )0;
            {
#line 1319
            while (1) {
              while_continue___5: /* CIL Label */ ;

#line 1319
              if (! (j < cblk_h)) {
#line 1319
                goto while_break___5;
              }
#line 1320
              i = (OPJ_UINT32 )0;
              {
#line 1320
              while (1) {
                while_continue___6: /* CIL Label */ ;

#line 1320
                if (! (i < cblk_w)) {
#line 1320
                  goto while_break___6;
                }
#line 1321
                tmp___0 = *(datap + (j * cblk_w + i));
#line 1322
                *(tiledp + (j * tile_w + i)) = tmp___0 / 2;
#line 1320
                i ++;
              }
              while_break___16: /* CIL Label */ ;
              }
              while_break___6: 
#line 1319
              j ++;
            }
            while_break___15: /* CIL Label */ ;
            }
            while_break___5: ;
          } else {
#line 1326
            tiledp___0 = (OPJ_FLOAT32 *)(tilec->data + ((unsigned int )y * tile_w + (unsigned int )x));
#line 1327
            j = (OPJ_UINT32 )0;
            {
#line 1327
            while (1) {
              while_continue___7: /* CIL Label */ ;

#line 1327
              if (! (j < cblk_h)) {
#line 1327
                goto while_break___7;
              }
#line 1328
              tiledp2 = tiledp___0;
#line 1329
              i = (OPJ_UINT32 )0;
              {
#line 1329
              while (1) {
                while_continue___8: /* CIL Label */ ;

#line 1329
                if (! (i < cblk_w)) {
#line 1329
                  goto while_break___8;
                }
#line 1330
                tmp___1 = (float )*datap * band->stepsize;
#line 1331
                *tiledp2 = tmp___1;
#line 1332
                datap ++;
#line 1333
                tiledp2 ++;
#line 1329
                i ++;
              }
              while_break___18: /* CIL Label */ ;
              }
              while_break___8: 
#line 1338
              tiledp___0 += tile_w;
#line 1327
              j ++;
            }
            while_break___17: /* CIL Label */ ;
            }
            while_break___7: ;
          }
#line 1270
          cblkno ++;
        }
        while_break___12: /* CIL Label */ ;
        }
        while_break___2: 
#line 1267
        precno ++;
      }
      while_break___11: /* CIL Label */ ;
      }
      while_break___1: 
#line 1264
      bandno ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___0: 
#line 1261
    resno ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break: ;
#line 1349
  return (1);
}
}
#line 1353 "/root/patron/new_22/src/lib/openjp2/t1.c"
OPJ_BOOL opj_t1_decode_cblk(opj_t1_t *t1 , opj_tcd_cblk_dec_t *cblk , OPJ_UINT32 orient ,
                            OPJ_UINT32 roishift , OPJ_UINT32 cblksty ) 
{ 
  opj_raw_t *raw ;
  opj_mqc_t *mqc ;
  OPJ_INT32 bpno ;
  OPJ_UINT32 passtype ;
  OPJ_UINT32 segno ;
  OPJ_UINT32 passno ;
  OPJ_BYTE type ;
  OPJ_BOOL __cil_tmp13 ;
  opj_tcd_seg_t *seg ;
  int tmp ;
  OPJ_BOOL __cil_tmp16 ;
  OPJ_INT32 __cil_tmp17 ;

  {
  {
#line 1359
  raw = t1->raw;
#line 1360
  mqc = t1->mqc;
#line 1365
  type = (OPJ_BYTE )0;
#line 1367
  __cil_tmp13 = opj_t1_allocate_buffers(t1, (OPJ_UINT32 )(cblk->x1 - cblk->x0), (OPJ_UINT32 )(cblk->y1 - cblk->y0));
  }
#line 1367
  if (! __cil_tmp13) {
#line 1372
    return (0);
  }
  {
#line 1375
  bpno = (OPJ_INT32 )((roishift + cblk->numbps) - 1U);
#line 1376
  passtype = (OPJ_UINT32 )2;
#line 1378
  opj_mqc_resetstates(mqc);
#line 1379
  opj_mqc_setstate(mqc, (OPJ_UINT32 )18, (OPJ_UINT32 )0, 46);
#line 1380
  opj_mqc_setstate(mqc, (OPJ_UINT32 )17, (OPJ_UINT32 )0, 3);
#line 1381
  opj_mqc_setstate(mqc, (OPJ_UINT32 )0, (OPJ_UINT32 )0, 4);
#line 1383
  segno = (OPJ_UINT32 )0;
  }
  {
#line 1383
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 1383
    if (! (segno < cblk->real_num_segs)) {
#line 1383
      goto while_break;
    }
#line 1384
    seg = cblk->segs + segno;
#line 1387
    if (bpno <= ((OPJ_INT32 )cblk->numbps - 1) - 4) {
#line 1387
      if (passtype < 2U) {
#line 1387
        if (cblksty & 1U) {
#line 1387
          tmp = 1;
        } else {
#line 1387
          tmp = 0;
        }
      } else {
#line 1387
        tmp = 0;
      }
    } else {
#line 1387
      tmp = 0;
    }
#line 1387
    type = (OPJ_BYTE )tmp;
#line 1389
    if ((unsigned long )seg->data == (unsigned long )((OPJ_BYTE **)0)) {
#line 1390
      goto while_continue;
    }
#line 1392
    if ((int )type == 1) {
      {
#line 1393
      opj_raw_init_dec(raw, *(seg->data) + seg->dataindex, seg->len);
      }
    } else {
      {
#line 1395
      __cil_tmp16 = opj_mqc_init_dec(mqc, *(seg->data) + seg->dataindex, seg->len);
      }
#line 1395
      if (0 == __cil_tmp16) {
#line 1396
        return (0);
      }
    }
#line 1400
    passno = (OPJ_UINT32 )0;
    {
#line 1400
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 1400
      if (! (passno < seg->real_num_passes)) {
#line 1400
        goto while_break___0;
      }
#line 1402
      if (passtype == 0U) {
#line 1402
        goto case_0;
      }
#line 1413
      if (passtype == 1U) {
#line 1413
        goto case_1;
      }
#line 1424
      if (passtype == 2U) {
#line 1424
        goto case_2;
      }
#line 1401
      goto switch_break;
      case_0: 
#line 1403
      if ((int )type == 1) {
        {
#line 1404
        opj_t1_dec_sigpass_raw(t1, bpno + 1, (OPJ_INT32 )orient, (OPJ_INT32 )cblksty);
        }
      } else
#line 1406
      if (cblksty & 8U) {
        {
#line 1407
        opj_t1_dec_sigpass_mqc_vsc(t1, bpno + 1, (OPJ_INT32 )orient);
        }
      } else {
        {
#line 1409
        opj_t1_dec_sigpass_mqc(t1, bpno + 1, (OPJ_INT32 )orient);
        }
      }
#line 1412
      goto switch_break;
      case_1: 
#line 1414
      if ((int )type == 1) {
        {
#line 1415
        opj_t1_dec_refpass_raw(t1, bpno + 1, (OPJ_INT32 )cblksty);
        }
      } else
#line 1417
      if (cblksty & 8U) {
        {
#line 1418
        opj_t1_dec_refpass_mqc_vsc(t1, bpno + 1);
        }
      } else {
        {
#line 1420
        opj_t1_dec_refpass_mqc(t1, bpno + 1);
        }
      }
#line 1423
      goto switch_break;
      case_2: 
      {
#line 1425
      opj_t1_dec_clnpass(t1, bpno + 1, (OPJ_INT32 )orient, (OPJ_INT32 )cblksty);
      }
#line 1426
      goto switch_break;
      switch_break: ;
#line 1429
      if (cblksty & 2U) {
#line 1429
        if ((int )type == 0) {
          {
#line 1430
          opj_mqc_resetstates(mqc);
#line 1431
          opj_mqc_setstate(mqc, (OPJ_UINT32 )18, (OPJ_UINT32 )0, 46);
#line 1432
          opj_mqc_setstate(mqc, (OPJ_UINT32 )17, (OPJ_UINT32 )0, 3);
#line 1433
          opj_mqc_setstate(mqc, (OPJ_UINT32 )0, (OPJ_UINT32 )0, 4);
          }
        }
      }
#line 1435
      passtype ++;
#line 1435
      if (passtype == 3U) {
#line 1436
        passtype = (OPJ_UINT32 )0;
#line 1437
        __cil_tmp17 = bpno;
#line 1437
        bpno --;
      }
#line 1400
      passno ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 1383
    segno ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 1441
  return (1);
}
}
#line 1447 "/root/patron/new_22/src/lib/openjp2/t1.c"
OPJ_BOOL opj_t1_encode_cblks(opj_t1_t *t1 , opj_tcd_tile_t *tile , opj_tcp_t *tcp ,
                             OPJ_FLOAT64 *mct_norms ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 bandno ;
  OPJ_UINT32 precno ;
  OPJ_UINT32 cblkno ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tccp_t *tccp ;
  OPJ_UINT32 tile_w ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  OPJ_INT32 bandconst ;
  double __cil_tmp16 ;
  opj_tcd_precinct_t *prc ;
  opj_tcd_cblk_enc_t *cblk ;
  OPJ_INT32 *datap ;
  OPJ_INT32 *tiledp ;
  OPJ_UINT32 cblk_w ;
  OPJ_UINT32 cblk_h ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_INT32 x ;
  OPJ_INT32 y ;
  opj_tcd_resolution_t *pres ;
  opj_tcd_resolution_t *pres___0 ;
  OPJ_BOOL __cil_tmp29 ;
  OPJ_INT32 tmp ;
  OPJ_INT32 tmp___0 ;
  OPJ_INT32 __cil_tmp32 ;

  {
#line 1455
  tile->distotile = (OPJ_FLOAT64 )0;
#line 1457
  compno = (OPJ_UINT32 )0;
  {
#line 1457
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1457
    if (! (compno < tile->numcomps)) {
#line 1457
      goto while_break;
    }
#line 1458
    tilec = tile->comps + compno;
#line 1459
    tccp = tcp->tccps + compno;
#line 1460
    tile_w = (OPJ_UINT32 )(tilec->x1 - tilec->x0);
#line 1462
    resno = (OPJ_UINT32 )0;
    {
#line 1462
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1462
      if (! (resno < tilec->numresolutions)) {
#line 1462
        goto while_break___0;
      }
#line 1463
      res = tilec->resolutions + resno;
#line 1465
      bandno = (OPJ_UINT32 )0;
      {
#line 1465
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 1465
        if (! (bandno < res->numbands)) {
#line 1465
          goto while_break___1;
        }
        {
#line 1466
        band = & res->bands[bandno];
#line 1467
        __cil_tmp16 = floor((double )(band->stepsize * (float )8192));
#line 1467
        bandconst = 67108864 / (OPJ_INT32 )__cil_tmp16;
#line 1469
        precno = (OPJ_UINT32 )0;
        }
        {
#line 1469
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 1469
          if (! (precno < res->pw * res->ph)) {
#line 1469
            goto while_break___2;
          }
#line 1470
          prc = band->precincts + precno;
#line 1472
          cblkno = (OPJ_UINT32 )0;
          {
#line 1472
          while (1) {
            while_continue___3: /* CIL Label */ ;

#line 1472
            if (! (cblkno < prc->cw * prc->ch)) {
#line 1472
              goto while_break___3;
            }
#line 1473
            cblk = prc->cblks.enc + cblkno;
#line 1480
            x = cblk->x0 - band->x0;
#line 1481
            y = cblk->y0 - band->y0;
#line 1482
            if (band->bandno & 1U) {
#line 1483
              pres = tilec->resolutions + (resno - 1U);
#line 1484
              x += pres->x1 - pres->x0;
            }
#line 1486
            if (band->bandno & 2U) {
#line 1487
              pres___0 = tilec->resolutions + (resno - 1U);
#line 1488
              y += pres___0->y1 - pres___0->y0;
            }
            {
#line 1491
            __cil_tmp29 = opj_t1_allocate_buffers(t1, (OPJ_UINT32 )(cblk->x1 - cblk->x0),
                                                  (OPJ_UINT32 )(cblk->y1 - cblk->y0));
            }
#line 1491
            if (! __cil_tmp29) {
#line 1496
              return (0);
            }
#line 1499
            datap = t1->data;
#line 1500
            cblk_w = t1->w;
#line 1501
            cblk_h = t1->h;
#line 1503
            tiledp = tilec->data + ((unsigned int )y * tile_w + (unsigned int )x);
#line 1504
            if (tccp->qmfbid == 1U) {
#line 1505
              j = (OPJ_UINT32 )0;
              {
#line 1505
              while (1) {
                while_continue___4: /* CIL Label */ ;

#line 1505
                if (! (j < cblk_h)) {
#line 1505
                  goto while_break___4;
                }
#line 1506
                i = (OPJ_UINT32 )0;
                {
#line 1506
                while (1) {
                  while_continue___5: /* CIL Label */ ;

#line 1506
                  if (! (i < cblk_w)) {
#line 1506
                    goto while_break___5;
                  }
#line 1507
                  tmp = *(tiledp + (j * tile_w + i));
#line 1508
                  *(datap + (j * cblk_w + i)) = tmp << 6;
#line 1506
                  i ++;
                }
                while_break___14: /* CIL Label */ ;
                }
                while_break___5: 
#line 1505
                j ++;
              }
              while_break___13: /* CIL Label */ ;
              }
              while_break___4: ;
            } else {
#line 1512
              j = (OPJ_UINT32 )0;
              {
#line 1512
              while (1) {
                while_continue___6: /* CIL Label */ ;

#line 1512
                if (! (j < cblk_h)) {
#line 1512
                  goto while_break___6;
                }
#line 1513
                i = (OPJ_UINT32 )0;
                {
#line 1513
                while (1) {
                  while_continue___7: /* CIL Label */ ;

#line 1513
                  if (! (i < cblk_w)) {
#line 1513
                    goto while_break___7;
                  }
                  {
#line 1514
                  tmp___0 = *(tiledp + (j * tile_w + i));
#line 1515
                  __cil_tmp32 = opj_int_fix_mul(tmp___0, bandconst);
#line 1515
                  *(datap + (j * cblk_w + i)) = __cil_tmp32 >> 5;
#line 1513
                  i ++;
                  }
                }
                while_break___16: /* CIL Label */ ;
                }
                while_break___7: 
#line 1512
                j ++;
              }
              while_break___15: /* CIL Label */ ;
              }
              while_break___6: ;
            }
            {
#line 1523
            opj_t1_encode_cblk(t1, cblk, band->bandno, compno, (tilec->numresolutions - 1U) - resno,
                               tccp->qmfbid, (OPJ_FLOAT64 )band->stepsize, tccp->cblksty,
                               tile->numcomps, tile, mct_norms);
#line 1472
            cblkno ++;
            }
          }
          while_break___12: /* CIL Label */ ;
          }
          while_break___3: 
#line 1469
          precno ++;
        }
        while_break___11: /* CIL Label */ ;
        }
        while_break___2: 
#line 1465
        bandno ++;
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___1: 
#line 1462
      resno ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___0: 
#line 1457
    compno ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break: ;
#line 1541
  return (1);
}
}
#line 1545 "/root/patron/new_22/src/lib/openjp2/t1.c"
void opj_t1_encode_cblk(opj_t1_t *t1 , opj_tcd_cblk_enc_t *cblk , OPJ_UINT32 orient ,
                        OPJ_UINT32 compno , OPJ_UINT32 level , OPJ_UINT32 qmfbid ,
                        OPJ_FLOAT64 stepsize , OPJ_UINT32 cblksty , OPJ_UINT32 numcomps ,
                        opj_tcd_tile_t *tile , OPJ_FLOAT64 *mct_norms ) 
{ 
  OPJ_FLOAT64 cumwmsedec ;
  opj_mqc_t *mqc ;
  OPJ_UINT32 passno ;
  OPJ_INT32 bpno ;
  OPJ_UINT32 passtype ;
  OPJ_INT32 nmsedec ;
  OPJ_INT32 max ;
  OPJ_UINT32 i ;
  OPJ_BYTE type ;
  OPJ_FLOAT64 tempwmsedec ;
  OPJ_INT32 tmp ;
  int __cil_tmp23 ;
  OPJ_INT32 __cil_tmp25 ;
  OPJ_INT32 tmp___0 ;
  opj_tcd_pass_t *pass ;
  OPJ_UINT32 correction ;
  int tmp___1 ;
  OPJ_INT32 __cil_tmp31 ;
  int tmp___2 ;
  OPJ_UINT32 __cil_tmp33 ;
  opj_tcd_pass_t *pass___0 ;
  OPJ_UINT32 __cil_tmp35 ;
  OPJ_UINT32 __cil_tmp37 ;
  unsigned int tmp___3 ;

  {
#line 1557
  cumwmsedec = 0.;
#line 1559
  mqc = t1->mqc;
#line 1564
  nmsedec = 0;
#line 1567
  type = (OPJ_BYTE )0;
#line 1570
  max = 0;
#line 1571
  i = (OPJ_UINT32 )0;
  {
#line 1571
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1571
    if (! (i < t1->w * t1->h)) {
#line 1571
      goto while_break;
    }
    {
#line 1572
    __cil_tmp23 = abs(*(t1->data + i));
#line 1572
    tmp = __cil_tmp23;
#line 1573
    max = opj_int_max(max, tmp);
#line 1571
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 1576
  if (max) {
    {
#line 1576
    __cil_tmp25 = opj_int_floorlog2(max);
#line 1576
    tmp___0 = (__cil_tmp25 + 1) - 6;
    }
  } else {
#line 1576
    tmp___0 = 0;
  }
  {
#line 1576
  cblk->numbps = (OPJ_UINT32 )tmp___0;
#line 1578
  bpno = (OPJ_INT32 )(cblk->numbps - 1U);
#line 1579
  passtype = (OPJ_UINT32 )2;
#line 1581
  opj_mqc_resetstates(mqc);
#line 1582
  opj_mqc_setstate(mqc, (OPJ_UINT32 )18, (OPJ_UINT32 )0, 46);
#line 1583
  opj_mqc_setstate(mqc, (OPJ_UINT32 )17, (OPJ_UINT32 )0, 3);
#line 1584
  opj_mqc_setstate(mqc, (OPJ_UINT32 )0, (OPJ_UINT32 )0, 4);
#line 1585
  opj_mqc_init_enc(mqc, cblk->data);
#line 1587
  passno = (OPJ_UINT32 )0;
  }
  {
#line 1587
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 1587
    if (! (bpno >= 0)) {
#line 1587
      goto while_break___0;
    }
#line 1588
    pass = cblk->passes + passno;
#line 1589
    correction = (OPJ_UINT32 )3;
#line 1590
    if (bpno < (OPJ_INT32 )cblk->numbps - 4) {
#line 1590
      if (passtype < 2U) {
#line 1590
        if (cblksty & 1U) {
#line 1590
          tmp___1 = 1;
        } else {
#line 1590
          tmp___1 = 0;
        }
      } else {
#line 1590
        tmp___1 = 0;
      }
    } else {
#line 1590
      tmp___1 = 0;
    }
#line 1590
    type = (OPJ_BYTE )tmp___1;
#line 1593
    if (passtype == 0U) {
#line 1593
      goto case_0;
    }
#line 1596
    if (passtype == 1U) {
#line 1596
      goto case_1;
    }
#line 1599
    if (passtype == 2U) {
#line 1599
      goto case_2;
    }
#line 1592
    goto switch_break;
    case_0: 
    {
#line 1594
    opj_t1_enc_sigpass(t1, bpno, orient, & nmsedec, type, cblksty);
    }
#line 1595
    goto switch_break;
    case_1: 
    {
#line 1597
    opj_t1_enc_refpass(t1, bpno, & nmsedec, type, cblksty);
    }
#line 1598
    goto switch_break;
    case_2: 
    {
#line 1600
    opj_t1_enc_clnpass(t1, bpno, orient, & nmsedec, cblksty);
    }
#line 1602
    if (cblksty & 32U) {
      {
#line 1603
      opj_mqc_segmark_enc(mqc);
      }
    }
#line 1604
    goto switch_break;
    switch_break: 
    {
#line 1608
    tempwmsedec = opj_t1_getwmsedec(nmsedec, compno, level, orient, bpno, qmfbid,
                                    stepsize, numcomps, mct_norms);
#line 1609
    cumwmsedec += tempwmsedec;
#line 1610
    tile->distotile += tempwmsedec;
    }
#line 1613
    if (cblksty & 4U) {
#line 1613
      if (passtype == 2U) {
#line 1613
        if (bpno - 1 < 0) {
#line 1613
          goto _L___2;
        } else {
#line 1613
          goto _L___3;
        }
      } else {
        _L___3: /* CIL Label */ 
#line 1614
        if ((int )type == 1) {
          {
#line 1615
          opj_mqc_flush(mqc);
#line 1616
          correction = (OPJ_UINT32 )1;
          }
        } else {
          {
#line 1619
          opj_mqc_flush(mqc);
#line 1620
          correction = (OPJ_UINT32 )1;
          }
        }
#line 1622
        pass->term = (OPJ_UINT32 )1;
      }
    } else
    _L___2: 
#line 1624
    if (bpno < (OPJ_INT32 )cblk->numbps - 4) {
#line 1624
      if (passtype > 0U) {
        _L: 
#line 1624
        if (cblksty & 1U) {
#line 1626
          if ((int )type == 1) {
            {
#line 1627
            opj_mqc_flush(mqc);
#line 1628
            correction = (OPJ_UINT32 )1;
            }
          } else {
            {
#line 1631
            opj_mqc_flush(mqc);
#line 1632
            correction = (OPJ_UINT32 )1;
            }
          }
#line 1634
          pass->term = (OPJ_UINT32 )1;
        } else {
#line 1636
          pass->term = (OPJ_UINT32 )0;
        }
      } else {
#line 1624
        goto _L___1;
      }
    } else
    _L___1: 
#line 1624
    if (bpno == (OPJ_INT32 )cblk->numbps - 4) {
#line 1624
      if (passtype == 2U) {
#line 1624
        goto _L;
      } else {
#line 1636
        pass->term = (OPJ_UINT32 )0;
      }
    } else {
#line 1636
      pass->term = (OPJ_UINT32 )0;
    }
#line 1640
    passtype ++;
#line 1640
    if (passtype == 3U) {
#line 1641
      passtype = (OPJ_UINT32 )0;
#line 1642
      __cil_tmp31 = bpno;
#line 1642
      bpno --;
    }
#line 1645
    if ((int )pass->term) {
#line 1645
      if (bpno > 0) {
#line 1646
        if (bpno < (OPJ_INT32 )cblk->numbps - 4) {
#line 1646
          if (passtype < 2U) {
#line 1646
            if (cblksty & 1U) {
#line 1646
              tmp___2 = 1;
            } else {
#line 1646
              tmp___2 = 0;
            }
          } else {
#line 1646
            tmp___2 = 0;
          }
        } else {
#line 1646
          tmp___2 = 0;
        }
#line 1646
        type = (OPJ_BYTE )tmp___2;
#line 1647
        if ((int )type == 1) {
          {
#line 1648
          opj_mqc_bypass_init_enc(mqc);
          }
        } else {
          {
#line 1650
          opj_mqc_restart_init_enc(mqc);
          }
        }
      }
    }
    {
#line 1653
    pass->distortiondec = cumwmsedec;
#line 1654
    __cil_tmp33 = opj_mqc_numbytes(mqc);
#line 1654
    pass->rate = __cil_tmp33 + correction;
    }
#line 1657
    if (cblksty & 2U) {
      {
#line 1658
      opj_mqc_reset_enc(mqc);
      }
    }
#line 1587
    passno ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: ;
#line 1662
  if (cblksty & 16U) {
    {
#line 1663
    opj_mqc_erterm_enc(mqc);
    }
  } else
#line 1664
  if (! (cblksty & 1U)) {
    {
#line 1665
    opj_mqc_flush(mqc);
    }
  }
#line 1667
  cblk->totalpasses = passno;
#line 1669
  passno = (OPJ_UINT32 )0;
  {
#line 1669
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 1669
    if (! (passno < cblk->totalpasses)) {
#line 1669
      goto while_break___1;
    }
    {
#line 1670
    pass___0 = cblk->passes + passno;
#line 1671
    __cil_tmp35 = opj_mqc_numbytes(mqc);
    }
#line 1671
    if (pass___0->rate > __cil_tmp35) {
      {
#line 1672
      pass___0->rate = opj_mqc_numbytes(mqc);
      }
    }
#line 1674
    if (pass___0->rate > 1U) {
#line 1674
      if ((int )*(cblk->data + (pass___0->rate - 1U)) == 255) {
#line 1675
        __cil_tmp37 = pass___0->rate;
#line 1675
        (pass___0->rate) --;
      }
    }
#line 1677
    if (passno == 0U) {
#line 1677
      tmp___3 = 0U;
    } else {
#line 1677
      tmp___3 = (cblk->passes + (passno - 1U))->rate;
    }
#line 1677
    pass___0->len = pass___0->rate - tmp___3;
#line 1669
    passno ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: ;
#line 1673
  return;
}
}
#line 1681 "/root/patron/new_22/src/lib/openjp2/t1.c"
void opj_t1_dec_refpass_step(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                             OPJ_INT32 poshalf , OPJ_INT32 neghalf , OPJ_BYTE type ,
                             OPJ_UINT32 vsc ) 
{ 
  OPJ_INT32 t ;
  OPJ_UINT32 v ;
  OPJ_UINT32 flag ;
  opj_mqc_t *mqc ;
  opj_raw_t *raw ;
  int tmp ;
  OPJ_UINT32 __cil_tmp14 ;
  OPJ_INT32 __cil_tmp16 ;
  OPJ_INT32 tmp___0 ;
  OPJ_INT32 tmp___1 ;

  {
#line 1692
  mqc = t1->mqc;
#line 1693
  raw = t1->raw;
#line 1695
  if (vsc) {
#line 1695
    tmp = (int )*flagsp & -1095;
  } else {
#line 1695
    tmp = (int )*flagsp;
  }
#line 1695
  flag = (OPJ_UINT32 )tmp;
#line 1696
  if ((flag & 20480U) == 4096U) {
    {
#line 1697
    __cil_tmp14 = opj_t1_getctxno_mag(flag);
#line 1697
    mqc->curctx = & mqc->ctxs[__cil_tmp14];
    }
#line 1698
    if ((int )type == 1) {
      {
#line 1699
      v = opj_raw_decode(raw);
      }
    } else {
      {
#line 1701
      __cil_tmp16 = opj_mqc_decode(mqc);
#line 1701
      v = (OPJ_UINT32 )__cil_tmp16;
      }
    }
#line 1703
    if (v) {
#line 1703
      tmp___0 = poshalf;
    } else {
#line 1703
      tmp___0 = neghalf;
    }
#line 1703
    t = tmp___0;
#line 1704
    if (*datap < 0) {
#line 1704
      tmp___1 = - t;
    } else {
#line 1704
      tmp___1 = t;
    }
#line 1704
    *datap += tmp___1;
#line 1705
    *flagsp = (opj_flag_t )((int )*flagsp | 8192);
  }
#line 1707
  return;
}
}
#line 1711 "/root/patron/new_22/src/lib/openjp2/t1.c"
void opj_t1_dec_sigpass_step(opj_t1_t *t1 , opj_flag_t *flagsp , OPJ_INT32 *datap ,
                             OPJ_UINT32 orient , OPJ_INT32 oneplushalf , OPJ_BYTE type ,
                             OPJ_UINT32 vsc ) 
{ 
  OPJ_UINT32 v ;
  OPJ_UINT32 flag ;
  opj_raw_t *raw ;
  opj_mqc_t *mqc ;
  int tmp ;
  OPJ_UINT32 __cil_tmp13 ;
  OPJ_INT32 tmp___0 ;
  OPJ_BYTE __cil_tmp16 ;
  OPJ_INT32 __cil_tmp17 ;
  OPJ_BYTE __cil_tmp18 ;
  OPJ_INT32 __cil_tmp19 ;
  OPJ_BYTE __cil_tmp20 ;
  OPJ_INT32 tmp___1 ;

  {
#line 1721
  raw = t1->raw;
#line 1722
  mqc = t1->mqc;
#line 1724
  if (vsc) {
#line 1724
    tmp = (int )*flagsp & -1095;
  } else {
#line 1724
    tmp = (int )*flagsp;
  }
#line 1724
  flag = (OPJ_UINT32 )tmp;
#line 1725
  if (flag & 255U) {
#line 1725
    if (! (flag & 20480U)) {
#line 1726
      if ((int )type == 1) {
        {
#line 1727
        __cil_tmp13 = opj_raw_decode(raw);
        }
#line 1727
        if (__cil_tmp13) {
          {
#line 1728
          v = opj_raw_decode(raw);
          }
#line 1729
          if (v) {
#line 1729
            tmp___0 = - oneplushalf;
          } else {
#line 1729
            tmp___0 = oneplushalf;
          }
          {
#line 1729
          *datap = tmp___0;
#line 1730
          opj_t1_updateflags(flagsp, v, t1->flags_stride);
          }
        }
      } else {
        {
#line 1733
        __cil_tmp16 = opj_t1_getctxno_zc(flag, orient);
#line 1733
        mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp16];
#line 1734
        __cil_tmp17 = opj_mqc_decode(mqc);
        }
#line 1734
        if (__cil_tmp17) {
          {
#line 1735
          __cil_tmp18 = opj_t1_getctxno_sc(flag);
#line 1735
          mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )__cil_tmp18];
#line 1736
          __cil_tmp20 = opj_t1_getspb(flag);
#line 1736
          __cil_tmp19 = opj_mqc_decode(mqc);
#line 1736
          v = (OPJ_UINT32 )(__cil_tmp19 ^ (int )__cil_tmp20);
          }
#line 1737
          if (v) {
#line 1737
            tmp___1 = - oneplushalf;
          } else {
#line 1737
            tmp___1 = oneplushalf;
          }
          {
#line 1737
          *datap = tmp___1;
#line 1738
          opj_t1_updateflags(flagsp, v, t1->flags_stride);
          }
        }
      }
#line 1741
      *flagsp = (opj_flag_t )((int )*flagsp | 16384);
    }
  }
#line 1744
  return;
}
}
#line 45 "/root/patron/new_22/src/lib/openjp2/raw.c"
opj_raw_t *opj_raw_create(void) 
{ 
  opj_raw_t *raw ;
  void *__cil_tmp2 ;

  {
  {
#line 46
  __cil_tmp2 = malloc(sizeof(opj_raw_t ));
#line 46
  raw = (opj_raw_t *)__cil_tmp2;
  }
#line 47
  return (raw);
}
}
#line 50 "/root/patron/new_22/src/lib/openjp2/raw.c"
void opj_raw_destroy(opj_raw_t *raw ) 
{ 


  {
#line 51
  if (raw) {
    {
#line 52
    free((void *)raw);
    }
  }
#line 55
  return;
}
}
#line 56 "/root/patron/new_22/src/lib/openjp2/raw.c"
OPJ_UINT32 opj_raw_numbytes(opj_raw_t *raw ) 
{ 


  {
#line 57
  return ((OPJ_UINT32 )(raw->bp - raw->start));
}
}
#line 60 "/root/patron/new_22/src/lib/openjp2/raw.c"
void opj_raw_init_dec(opj_raw_t *raw , OPJ_BYTE *bp , OPJ_UINT32 len ) 
{ 


  {
#line 61
  raw->start = bp;
#line 62
  raw->lenmax = len;
#line 63
  raw->len = (OPJ_UINT32 )0;
#line 64
  raw->c = (OPJ_BYTE )0;
#line 65
  raw->ct = (OPJ_UINT32 )0;
#line 66
  return;
}
}
#line 68 "/root/patron/new_22/src/lib/openjp2/raw.c"
OPJ_UINT32 opj_raw_decode(opj_raw_t *raw ) 
{ 
  OPJ_UINT32 d ;
  OPJ_UINT32 __cil_tmp4 ;

  {
#line 70
  if (raw->ct == 0U) {
#line 71
    raw->ct = (OPJ_UINT32 )8;
#line 72
    if (raw->len == raw->lenmax) {
#line 73
      raw->c = (OPJ_BYTE )255;
    } else {
#line 75
      if ((int )raw->c == 255) {
#line 76
        raw->ct = (OPJ_UINT32 )7;
      }
#line 78
      raw->c = *(raw->start + raw->len);
#line 79
      (raw->len) ++;
    }
  }
#line 82
  __cil_tmp4 = raw->ct;
#line 82
  (raw->ct) --;
#line 83
  d = (OPJ_UINT32 )(((int )raw->c >> raw->ct) & 1);
#line 85
  return (d);
}
}
#line 42 "/root/patron/new_22/src/lib/openjp2/t2.c"
static void opj_t2_putcommacode(opj_bio_t *bio , OPJ_INT32 n ) ;
#line 44
OPJ_UINT32 opj_t2_getcommacode(opj_bio_t *bio ) ;
#line 50
void opj_t2_putnumpasses(opj_bio_t *bio , OPJ_UINT32 n ) ;
#line 51
OPJ_UINT32 opj_t2_getnumpasses(opj_bio_t *bio ) ;
#line 65
OPJ_BOOL opj_t2_encode_packet(OPJ_UINT32 tileno , opj_tcd_tile_t *tile , opj_tcp_t *tcp ,
                              opj_pi_iterator_t *pi , OPJ_BYTE *dest , OPJ_UINT32 *p_data_written ,
                              OPJ_UINT32 length , opj_codestream_info_t *cstr_info ) ;
#line 87
OPJ_BOOL opj_t2_decode_packet(opj_t2_t *p_t2 , opj_tcd_tile_t *p_tile , opj_tcp_t *p_tcp ,
                              opj_pi_iterator_t *p_pi , OPJ_BYTE *p_src , OPJ_UINT32 *p_data_read ,
                              OPJ_UINT32 p_max_length , opj_packet_info_t *p_pack_info ) ;
#line 96
static OPJ_BOOL opj_t2_skip_packet(opj_t2_t *p_t2 , opj_tcd_tile_t *p_tile , opj_tcp_t *p_tcp ,
                                   opj_pi_iterator_t *p_pi , OPJ_BYTE *p_src , OPJ_UINT32 *p_data_read ,
                                   OPJ_UINT32 p_max_length , opj_packet_info_t *p_pack_info ) ;
#line 105
OPJ_BOOL opj_t2_read_packet_header(opj_t2_t *p_t2 , opj_tcd_tile_t *p_tile , opj_tcp_t *p_tcp ,
                                   opj_pi_iterator_t *p_pi , OPJ_BOOL *p_is_data_present ,
                                   OPJ_BYTE *p_src_data , OPJ_UINT32 *p_data_read ,
                                   OPJ_UINT32 p_max_length , opj_packet_info_t *p_pack_info ) ;
#line 115
OPJ_BOOL opj_t2_read_packet_data(opj_t2_t *p_t2 , opj_tcd_tile_t *p_tile , opj_pi_iterator_t *p_pi ,
                                 OPJ_BYTE *p_src_data , OPJ_UINT32 *p_data_read ,
                                 OPJ_UINT32 p_max_length , opj_packet_info_t *pack_info ) ;
#line 123
OPJ_BOOL opj_t2_skip_packet_data(opj_t2_t *p_t2 , opj_tcd_tile_t *p_tile , opj_pi_iterator_t *p_pi ,
                                 OPJ_UINT32 *p_data_read , OPJ_UINT32 p_max_length ,
                                 opj_packet_info_t *pack_info ) ;
#line 136
OPJ_BOOL opj_t2_init_seg(opj_tcd_cblk_dec_t *cblk , OPJ_UINT32 index___0 , OPJ_UINT32 cblksty ,
                         OPJ_UINT32 first ) ;
#line 148 "/root/patron/new_22/src/lib/openjp2/t2.c"
static void opj_t2_putcommacode(opj_bio_t *bio , OPJ_INT32 n ) 
{ 


  {
  {
#line 149
  while (1) {
    while_continue: /* CIL Label */ ;
#line 149
    n --;
#line 149
    if (! (n >= 0)) {
#line 149
      goto while_break;
    }
    {
#line 150
    opj_bio_write(bio, (OPJ_UINT32 )1, (OPJ_UINT32 )1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 152
  opj_bio_write(bio, (OPJ_UINT32 )0, (OPJ_UINT32 )1);
  }
#line 154
  return;
}
}
#line 155 "/root/patron/new_22/src/lib/openjp2/t2.c"
OPJ_UINT32 opj_t2_getcommacode(opj_bio_t *bio ) 
{ 
  OPJ_UINT32 n ;
  OPJ_UINT32 __cil_tmp3 ;

  {
#line 157
  n = (OPJ_UINT32 )0;
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 158
    __cil_tmp3 = opj_bio_read(bio, (OPJ_UINT32 )1);
    }
#line 158
    if (! __cil_tmp3) {
#line 158
      goto while_break;
    }
#line 159
    n ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 161
  return (n);
}
}
#line 164 "/root/patron/new_22/src/lib/openjp2/t2.c"
void opj_t2_putnumpasses(opj_bio_t *bio , OPJ_UINT32 n ) 
{ 


  {
#line 165
  if (n == 1U) {
    {
#line 166
    opj_bio_write(bio, (OPJ_UINT32 )0, (OPJ_UINT32 )1);
    }
  } else
#line 167
  if (n == 2U) {
    {
#line 168
    opj_bio_write(bio, (OPJ_UINT32 )2, (OPJ_UINT32 )2);
    }
  } else
#line 169
  if (n <= 5U) {
    {
#line 170
    opj_bio_write(bio, 12U | (n - 3U), (OPJ_UINT32 )4);
    }
  } else
#line 171
  if (n <= 36U) {
    {
#line 172
    opj_bio_write(bio, 480U | (n - 6U), (OPJ_UINT32 )9);
    }
  } else
#line 173
  if (n <= 164U) {
    {
#line 174
    opj_bio_write(bio, 65408U | (n - 37U), (OPJ_UINT32 )16);
    }
  }
#line 177
  return;
}
}
#line 178 "/root/patron/new_22/src/lib/openjp2/t2.c"
OPJ_UINT32 opj_t2_getnumpasses(opj_bio_t *bio ) 
{ 
  OPJ_UINT32 n ;
  OPJ_UINT32 __cil_tmp3 ;
  OPJ_UINT32 __cil_tmp4 ;
  OPJ_UINT32 __cil_tmp7 ;

  {
  {
#line 180
  __cil_tmp3 = opj_bio_read(bio, (OPJ_UINT32 )1);
  }
#line 180
  if (! __cil_tmp3) {
#line 181
    return ((OPJ_UINT32 )1);
  }
  {
#line 182
  __cil_tmp4 = opj_bio_read(bio, (OPJ_UINT32 )1);
  }
#line 182
  if (! __cil_tmp4) {
#line 183
    return ((OPJ_UINT32 )2);
  }
  {
#line 184
  n = opj_bio_read(bio, (OPJ_UINT32 )2);
  }
#line 184
  if (n != 3U) {
#line 185
    return (3U + n);
  }
  {
#line 186
  n = opj_bio_read(bio, (OPJ_UINT32 )5);
  }
#line 186
  if (n != 31U) {
#line 187
    return (6U + n);
  }
  {
#line 188
  __cil_tmp7 = opj_bio_read(bio, (OPJ_UINT32 )7);
  }
#line 188
  return (37U + __cil_tmp7);
}
}
#line 193 "/root/patron/new_22/src/lib/openjp2/t2.c"
OPJ_BOOL opj_t2_encode_packets(opj_t2_t *p_t2 , OPJ_UINT32 p_tile_no , opj_tcd_tile_t *p_tile ,
                               OPJ_UINT32 p_maxlayers , OPJ_BYTE *p_dest , OPJ_UINT32 *p_data_written ,
                               OPJ_UINT32 p_max_len , opj_codestream_info_t *cstr_info ,
                               OPJ_UINT32 p_tp_num , OPJ_INT32 p_tp_pos , OPJ_UINT32 p_pino ,
                               J2K_T2_MODE p_t2_mode ) 
{ 
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 l_nb_bytes ;
  OPJ_UINT32 compno ;
  OPJ_UINT32 poc ;
  opj_pi_iterator_t *l_pi ;
  opj_pi_iterator_t *l_current_pi ;
  opj_image_t *l_image ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 pocno ;
  int tmp ;
  OPJ_UINT32 l_max_comp ;
  OPJ_UINT32 tmp___0 ;
  OPJ_UINT32 l_nb_pocs ;
  OPJ_UINT32 l_comp_len ;
  OPJ_UINT32 l_tp_num ;
  OPJ_BOOL __cil_tmp30 ;
  OPJ_BOOL __cil_tmp31 ;
  OPJ_BOOL __cil_tmp32 ;
  OPJ_BOOL __cil_tmp33 ;
  opj_tile_info_t *info_TL ;
  opj_packet_info_t *info_PK ;
  OPJ_OFF_T tmp___1 ;

  {
#line 206
  l_current_data = p_dest;
#line 207
  l_nb_bytes = (OPJ_UINT32 )0;
#line 210
  l_pi = (opj_pi_iterator_t *)0;
#line 211
  l_current_pi = (opj_pi_iterator_t *)0;
#line 212
  l_image = p_t2->image;
#line 213
  l_cp = p_t2->cp;
#line 214
  l_tcp = l_cp->tcps + p_tile_no;
#line 215
  if ((unsigned int )l_cp->m_specific_param.m_enc.m_cinema == 3U) {
#line 215
    tmp = 2;
  } else {
#line 215
    tmp = 1;
  }
#line 215
  pocno = (OPJ_UINT32 )tmp;
#line 216
  if (l_cp->m_specific_param.m_enc.m_max_comp_size > 0U) {
#line 216
    tmp___0 = l_image->numcomps;
  } else {
#line 216
    tmp___0 = 1U;
  }
  {
#line 216
  l_max_comp = tmp___0;
#line 217
  l_nb_pocs = l_tcp->numpocs + 1U;
#line 219
  l_pi = opj_pi_initialise_encode(l_image, l_cp, p_tile_no, p_t2_mode);
  }
#line 220
  if (! l_pi) {
#line 221
    return (0);
  }
#line 224
  *p_data_written = (OPJ_UINT32 )0;
#line 226
  if ((unsigned int )p_t2_mode == 0U) {
#line 227
    l_current_pi = l_pi;
#line 229
    compno = (OPJ_UINT32 )0;
    {
#line 229
    while (1) {
      while_continue: /* CIL Label */ ;

#line 229
      if (! (compno < l_max_comp)) {
#line 229
        goto while_break;
      }
#line 230
      l_comp_len = (OPJ_UINT32 )0;
#line 231
      l_current_pi = l_pi;
#line 233
      poc = (OPJ_UINT32 )0;
      {
#line 233
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 233
        if (! (poc < pocno)) {
#line 233
          goto while_break___0;
        }
        {
#line 234
        l_tp_num = compno;
#line 237
        opj_pi_create_encode(l_pi, l_cp, p_tile_no, poc, l_tp_num, p_tp_pos, p_t2_mode);
        }
        {
#line 239
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 239
          __cil_tmp30 = opj_pi_next(l_current_pi);
          }
#line 239
          if (! __cil_tmp30) {
#line 239
            goto while_break___1;
          }
#line 240
          if (l_current_pi->layno < p_maxlayers) {
            {
#line 241
            l_nb_bytes = (OPJ_UINT32 )0;
#line 243
            __cil_tmp31 = opj_t2_encode_packet(p_tile_no, p_tile, l_tcp, l_current_pi,
                                               l_current_data, & l_nb_bytes, p_max_len,
                                               cstr_info);
            }
#line 243
            if (! __cil_tmp31) {
              {
#line 244
              opj_pi_destroy(l_pi, l_nb_pocs);
              }
#line 245
              return (0);
            }
#line 248
            l_comp_len += l_nb_bytes;
#line 249
            l_current_data += l_nb_bytes;
#line 250
            p_max_len -= l_nb_bytes;
#line 252
            *p_data_written += l_nb_bytes;
          }
        }
        while_break___5: /* CIL Label */ ;
        }
        while_break___1: ;
#line 256
        if (l_cp->m_specific_param.m_enc.m_max_comp_size) {
#line 257
          if (l_comp_len > l_cp->m_specific_param.m_enc.m_max_comp_size) {
            {
#line 258
            opj_pi_destroy(l_pi, l_nb_pocs);
            }
#line 259
            return (0);
          }
        }
#line 263
        l_current_pi ++;
#line 233
        poc ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___0: 
#line 229
      compno ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break: ;
  } else {
    {
#line 268
    opj_pi_create_encode(l_pi, l_cp, p_tile_no, p_pino, p_tp_num, p_tp_pos, p_t2_mode);
#line 270
    l_current_pi = l_pi + p_pino;
    }
    {
#line 272
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 272
      __cil_tmp32 = opj_pi_next(l_current_pi);
      }
#line 272
      if (! __cil_tmp32) {
#line 272
        goto while_break___2;
      }
#line 273
      if (l_current_pi->layno < p_maxlayers) {
        {
#line 274
        l_nb_bytes = (OPJ_UINT32 )0;
#line 276
        __cil_tmp33 = opj_t2_encode_packet(p_tile_no, p_tile, l_tcp, l_current_pi,
                                           l_current_data, & l_nb_bytes, p_max_len,
                                           cstr_info);
        }
#line 276
        if (! __cil_tmp33) {
          {
#line 277
          opj_pi_destroy(l_pi, l_nb_pocs);
          }
#line 278
          return (0);
        }
#line 281
        l_current_data += l_nb_bytes;
#line 282
        p_max_len -= l_nb_bytes;
#line 284
        *p_data_written += l_nb_bytes;
#line 287
        if (cstr_info) {
#line 288
          if (cstr_info->index_write) {
#line 289
            info_TL = cstr_info->tile + p_tile_no;
#line 290
            info_PK = info_TL->packet + cstr_info->packno;
#line 291
            if (! cstr_info->packno) {
#line 292
              info_PK->start_pos = (OPJ_OFF_T )(info_TL->end_header + 1);
            } else {
#line 294
              if ((int )l_cp->m_specific_param.m_enc.m_tp_on | (int )l_tcp->POC) {
#line 294
                if (info_PK->start_pos) {
#line 294
                  tmp___1 = info_PK->start_pos;
                } else {
#line 294
                  tmp___1 = (info_TL->packet + (cstr_info->packno - 1))->end_pos + 1L;
                }
              } else {
#line 294
                tmp___1 = (info_TL->packet + (cstr_info->packno - 1))->end_pos + 1L;
              }
#line 294
              info_PK->start_pos = tmp___1;
            }
#line 296
            info_PK->end_pos = (info_PK->start_pos + (long )l_nb_bytes) - 1L;
#line 297
            info_PK->end_ph_pos += info_PK->start_pos - 1L;
          }
#line 301
          (cstr_info->packno) ++;
        }
#line 304
        (p_tile->packno) ++;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: ;
  }
  {
#line 309
  opj_pi_destroy(l_pi, l_nb_pocs);
  }
#line 311
  return (1);
}
}
#line 314 "/root/patron/new_22/src/lib/openjp2/t2.c"
OPJ_BOOL opj_t2_decode_packets(opj_t2_t *p_t2 , OPJ_UINT32 p_tile_no , opj_tcd_tile_t *p_tile ,
                               OPJ_BYTE *p_src , OPJ_UINT32 *p_data_read , OPJ_UINT32 p_max_len ,
                               opj_codestream_index_t *p_cstr_index ) 
{ 
  OPJ_BYTE *l_current_data ;
  opj_pi_iterator_t *l_pi ;
  OPJ_UINT32 pino ;
  opj_image_t *l_image ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 l_nb_bytes_read ;
  OPJ_UINT32 l_nb_pocs ;
  opj_pi_iterator_t *l_current_pi ;
  opj_packet_info_t *l_pack_info ;
  opj_image_comp_t *l_img_comp ;
  OPJ_BOOL *first_pass_failed ;
  void *__cil_tmp21 ;
  OPJ_BOOL __cil_tmp22 ;
  OPJ_BOOL __cil_tmp23 ;
  OPJ_BOOL __cil_tmp25 ;

  {
  {
#line 322
  l_current_data = p_src;
#line 323
  l_pi = (opj_pi_iterator_t *)0;
#line 325
  l_image = p_t2->image;
#line 326
  l_cp = p_t2->cp;
#line 327
  l_tcp = (p_t2->cp)->tcps + p_tile_no;
#line 329
  l_nb_pocs = l_tcp->numpocs + 1U;
#line 330
  l_current_pi = (opj_pi_iterator_t *)0;
#line 335
  l_pack_info = (opj_packet_info_t *)0;
#line 336
  l_img_comp = (opj_image_comp_t *)0;
#line 347
  l_pi = opj_pi_create_decode(l_image, l_cp, p_tile_no);
  }
#line 348
  if (! l_pi) {
#line 349
    return (0);
  }
#line 353
  l_current_pi = l_pi;
#line 355
  pino = (OPJ_UINT32 )0;
  {
#line 355
  while (1) {
    while_continue: /* CIL Label */ ;

#line 355
    if (! (pino <= l_tcp->numpocs)) {
#line 355
      goto while_break;
    }
    {
#line 362
    __cil_tmp21 = malloc((unsigned long )l_image->numcomps * sizeof(OPJ_BOOL ));
#line 362
    first_pass_failed = (OPJ_BOOL *)__cil_tmp21;
    }
#line 363
    if (! first_pass_failed) {
      {
#line 365
      opj_pi_destroy(l_pi, l_nb_pocs);
      }
#line 366
      return (0);
    }
    {
#line 368
    memset((void *)first_pass_failed, 1, (unsigned long )l_image->numcomps * sizeof(OPJ_BOOL ));
    }
    {
#line 370
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 370
      __cil_tmp22 = opj_pi_next(l_current_pi);
      }
#line 370
      if (! __cil_tmp22) {
#line 370
        goto while_break___0;
      }
#line 373
      if (l_tcp->num_layers_to_decode > l_current_pi->layno) {
#line 373
        if (l_current_pi->resno < (p_tile->comps + l_current_pi->compno)->minimum_num_resolutions) {
          {
#line 375
          l_nb_bytes_read = (OPJ_UINT32 )0;
#line 377
          *(first_pass_failed + l_current_pi->compno) = 0;
#line 379
          __cil_tmp23 = opj_t2_decode_packet(p_t2, p_tile, l_tcp, l_current_pi, l_current_data,
                                             & l_nb_bytes_read, p_max_len, l_pack_info);
          }
#line 379
          if (! __cil_tmp23) {
            {
#line 380
            opj_pi_destroy(l_pi, l_nb_pocs);
#line 381
            free((void *)first_pass_failed);
            }
#line 382
            return (0);
          }
          {
#line 385
          l_img_comp = l_image->comps + l_current_pi->compno;
#line 386
          l_img_comp->resno_decoded = opj_uint_max(l_current_pi->resno, l_img_comp->resno_decoded);
          }
        } else {
#line 373
          goto _L;
        }
      } else {
        _L: 
        {
#line 389
        l_nb_bytes_read = (OPJ_UINT32 )0;
#line 390
        __cil_tmp25 = opj_t2_skip_packet(p_t2, p_tile, l_tcp, l_current_pi, l_current_data,
                                         & l_nb_bytes_read, p_max_len, l_pack_info);
        }
#line 390
        if (! __cil_tmp25) {
          {
#line 391
          opj_pi_destroy(l_pi, l_nb_pocs);
#line 392
          free((void *)first_pass_failed);
          }
#line 393
          return (0);
        }
      }
#line 397
      if (*(first_pass_failed + l_current_pi->compno)) {
#line 398
        l_img_comp = l_image->comps + l_current_pi->compno;
#line 399
        if (l_img_comp->resno_decoded == 0U) {
#line 400
          l_img_comp->resno_decoded = (p_tile->comps + l_current_pi->compno)->minimum_num_resolutions - 1U;
        }
      }
#line 403
      l_current_data += l_nb_bytes_read;
#line 404
      p_max_len -= l_nb_bytes_read;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 429
    l_current_pi ++;
#line 431
    free((void *)first_pass_failed);
#line 355
    pino ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 443
  opj_pi_destroy(l_pi, l_nb_pocs);
#line 444
  *p_data_read = (OPJ_UINT32 )(l_current_data - p_src);
  }
#line 445
  return (1);
}
}
#line 457 "/root/patron/new_22/src/lib/openjp2/t2.c"
opj_t2_t *opj_t2_create(opj_image_t *p_image , opj_cp_t *p_cp ) 
{ 
  opj_t2_t *l_t2 ;
  void *__cil_tmp4 ;

  {
  {
#line 460
  __cil_tmp4 = malloc(sizeof(opj_t2_t ));
#line 460
  l_t2 = (opj_t2_t *)__cil_tmp4;
  }
#line 461
  if (! l_t2) {
#line 462
    return ((opj_t2_t *)((void *)0));
  }
  {
#line 464
  memset((void *)l_t2, 0, sizeof(opj_t2_t ));
#line 466
  l_t2->image = p_image;
#line 467
  l_t2->cp = p_cp;
  }
#line 469
  return (l_t2);
}
}
#line 472 "/root/patron/new_22/src/lib/openjp2/t2.c"
void opj_t2_destroy(opj_t2_t *t2 ) 
{ 


  {
#line 473
  if (t2) {
    {
#line 474
    free((void *)t2);
    }
  }
#line 477
  return;
}
}
#line 478 "/root/patron/new_22/src/lib/openjp2/t2.c"
OPJ_BOOL opj_t2_decode_packet(opj_t2_t *p_t2 , opj_tcd_tile_t *p_tile , opj_tcp_t *p_tcp ,
                              opj_pi_iterator_t *p_pi , OPJ_BYTE *p_src , OPJ_UINT32 *p_data_read ,
                              OPJ_UINT32 p_max_length , opj_packet_info_t *p_pack_info ) 
{ 
  OPJ_BOOL l_read_data ;
  OPJ_UINT32 l_nb_bytes_read ;
  OPJ_UINT32 l_nb_total_bytes_read ;
  OPJ_BOOL __cil_tmp12 ;
  OPJ_BOOL __cil_tmp13 ;

  {
  {
#line 488
  l_nb_bytes_read = (OPJ_UINT32 )0;
#line 489
  l_nb_total_bytes_read = (OPJ_UINT32 )0;
#line 491
  *p_data_read = (OPJ_UINT32 )0;
#line 493
  __cil_tmp12 = opj_t2_read_packet_header(p_t2, p_tile, p_tcp, p_pi, & l_read_data,
                                          p_src, & l_nb_bytes_read, p_max_length,
                                          p_pack_info);
  }
#line 493
  if (! __cil_tmp12) {
#line 494
    return (0);
  }
#line 497
  p_src += l_nb_bytes_read;
#line 498
  l_nb_total_bytes_read += l_nb_bytes_read;
#line 499
  p_max_length -= l_nb_bytes_read;
#line 502
  if (l_read_data) {
    {
#line 503
    l_nb_bytes_read = (OPJ_UINT32 )0;
#line 505
    __cil_tmp13 = opj_t2_read_packet_data(p_t2, p_tile, p_pi, p_src, & l_nb_bytes_read,
                                          p_max_length, p_pack_info);
    }
#line 505
    if (! __cil_tmp13) {
#line 506
      return (0);
    }
#line 509
    l_nb_total_bytes_read += l_nb_bytes_read;
  }
#line 512
  *p_data_read = l_nb_total_bytes_read;
#line 514
  return (1);
}
}
#line 517 "/root/patron/new_22/src/lib/openjp2/t2.c"
OPJ_BOOL opj_t2_encode_packet(OPJ_UINT32 tileno , opj_tcd_tile_t *tile , opj_tcp_t *tcp ,
                              opj_pi_iterator_t *pi , OPJ_BYTE *dest , OPJ_UINT32 *p_data_written ,
                              OPJ_UINT32 length , opj_codestream_info_t *cstr_info ) 
{ 
  OPJ_UINT32 bandno ;
  OPJ_UINT32 cblkno ;
  OPJ_BYTE *c ;
  OPJ_UINT32 l_nb_bytes ;
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 precno ;
  OPJ_UINT32 layno ;
  OPJ_UINT32 l_nb_blocks ;
  opj_tcd_band_t *band ;
  opj_tcd_cblk_enc_t *cblk ;
  opj_tcd_pass_t *pass ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *res ;
  opj_bio_t *bio ;
  opj_tcd_precinct_t *prc ;
  opj_tcd_precinct_t *prc___0 ;
  opj_tcd_layer_t *layer ;
  opj_tcd_layer_t *layer___0 ;
  OPJ_UINT32 increment ;
  OPJ_UINT32 nump ;
  OPJ_UINT32 len ;
  OPJ_UINT32 passno ;
  OPJ_UINT32 l_nb_passes ;
  OPJ_INT32 __cil_tmp34 ;
  OPJ_INT32 __cil_tmp35 ;
  OPJ_INT32 __cil_tmp36 ;
  OPJ_INT32 __cil_tmp38 ;
  OPJ_BOOL __cil_tmp40 ;
  ptrdiff_t __cil_tmp41 ;
  opj_packet_info_t *info_PK ;
  opj_tcd_precinct_t *prc___1 ;
  opj_tcd_layer_t *layer___1 ;
  opj_packet_info_t *info_PK___0 ;

  {
#line 527
  c = dest;
#line 529
  compno = pi->compno;
#line 530
  resno = pi->resno;
#line 531
  precno = pi->precno;
#line 532
  layno = pi->layno;
#line 534
  band = (opj_tcd_band_t *)0;
#line 535
  cblk = (opj_tcd_cblk_enc_t *)0;
#line 536
  pass = (opj_tcd_pass_t *)0;
#line 538
  tilec = tile->comps + compno;
#line 539
  res = tilec->resolutions + resno;
#line 541
  bio = (opj_bio_t *)0;
#line 544
  if (tcp->csty & 2U) {
#line 545
    *(c + 0) = (OPJ_BYTE )255;
#line 546
    *(c + 1) = (OPJ_BYTE )145;
#line 547
    *(c + 2) = (OPJ_BYTE )0;
#line 548
    *(c + 3) = (OPJ_BYTE )4;
#line 549
    *(c + 4) = (OPJ_BYTE )((tile->packno % 65536U) / 256U);
#line 550
    *(c + 5) = (OPJ_BYTE )((tile->packno % 65536U) % 256U);
#line 551
    c += 6;
#line 552
    length -= 6U;
  }
#line 556
  if (! layno) {
#line 557
    band = res->bands;
#line 559
    bandno = (OPJ_UINT32 )0;
    {
#line 559
    while (1) {
      while_continue: /* CIL Label */ ;

#line 559
      if (! (bandno < res->numbands)) {
#line 559
        goto while_break;
      }
      {
#line 560
      prc = band->precincts + precno;
#line 562
      opj_tgt_reset(prc->incltree);
#line 563
      opj_tgt_reset(prc->imsbtree);
#line 565
      l_nb_blocks = prc->cw * prc->ch;
#line 566
      cblkno = (OPJ_UINT32 )0;
      }
      {
#line 566
      while (1) {
        while_continue___8: /* CIL Label */ ;

#line 566
        if (! (cblkno < l_nb_blocks)) {
#line 566
          goto while_break___0;
        }
        {
#line 567
        cblk = prc->cblks.enc + cblkno;
#line 569
        cblk->numpasses = (OPJ_UINT32 )0;
#line 570
        opj_tgt_setvalue(prc->imsbtree, cblkno, (OPJ_INT32 )((unsigned int )band->numbps - cblk->numbps));
#line 566
        cblkno ++;
        }
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___0: 
#line 572
      band ++;
#line 559
      bandno ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break: ;
  }
  {
#line 576
  bio = opj_bio_create();
#line 577
  opj_bio_init_enc(bio, c, length);
#line 578
  opj_bio_write(bio, (OPJ_UINT32 )1, (OPJ_UINT32 )1);
#line 581
  band = res->bands;
#line 582
  bandno = (OPJ_UINT32 )0;
  }
  {
#line 582
  while (1) {
    while_continue___9: /* CIL Label */ ;

#line 582
    if (! (bandno < res->numbands)) {
#line 582
      goto while_break___1;
    }
#line 583
    prc___0 = band->precincts + precno;
#line 585
    l_nb_blocks = prc___0->cw * prc___0->ch;
#line 586
    cblk = prc___0->cblks.enc;
#line 588
    cblkno = (OPJ_UINT32 )0;
    {
#line 588
    while (1) {
      while_continue___10: /* CIL Label */ ;

#line 588
      if (! (cblkno < l_nb_blocks)) {
#line 588
        goto while_break___2;
      }
#line 589
      layer = cblk->layers + layno;
#line 591
      if (! cblk->numpasses) {
#line 591
        if (layer->numpasses) {
          {
#line 592
          opj_tgt_setvalue(prc___0->incltree, cblkno, (OPJ_INT32 )layno);
          }
        }
      }
#line 595
      cblk ++;
#line 588
      cblkno ++;
    }
    while_break___11: /* CIL Label */ ;
    }
    while_break___2: 
#line 598
    cblk = prc___0->cblks.enc;
#line 599
    cblkno = (OPJ_UINT32 )0;
    {
#line 599
    while (1) {
      while_continue___11: /* CIL Label */ ;
      while_continue___3: ;
#line 599
      if (! (cblkno < l_nb_blocks)) {
#line 599
        goto while_break___3;
      }
#line 600
      layer___0 = cblk->layers + layno;
#line 601
      increment = (OPJ_UINT32 )0;
#line 602
      nump = (OPJ_UINT32 )0;
#line 603
      len = (OPJ_UINT32 )0;
#line 607
      if (! cblk->numpasses) {
        {
#line 608
        opj_tgt_encode(bio, prc___0->incltree, cblkno, (OPJ_INT32 )(layno + 1U));
        }
      } else {
        {
#line 610
        opj_bio_write(bio, (OPJ_UINT32 )(layer___0->numpasses != 0U), (OPJ_UINT32 )1);
        }
      }
#line 614
      if (! layer___0->numpasses) {
#line 615
        cblk ++;
#line 616
        goto while_continue___3;
      }
#line 620
      if (! cblk->numpasses) {
        {
#line 621
        cblk->numlenbits = (OPJ_UINT32 )3;
#line 622
        opj_tgt_encode(bio, prc___0->imsbtree, cblkno, 999);
        }
      }
      {
#line 626
      opj_t2_putnumpasses(bio, layer___0->numpasses);
#line 627
      l_nb_passes = cblk->numpasses + layer___0->numpasses;
#line 628
      pass = cblk->passes + cblk->numpasses;
#line 631
      passno = cblk->numpasses;
      }
      {
#line 631
      while (1) {
        while_continue___12: /* CIL Label */ ;

#line 631
        if (! (passno < l_nb_passes)) {
#line 631
          goto while_break___4;
        }
#line 632
        nump ++;
#line 633
        len += pass->len;
#line 635
        if ((int )pass->term) {
          _L: 
          {
#line 636
          __cil_tmp35 = opj_int_floorlog2((OPJ_INT32 )nump);
#line 636
          __cil_tmp34 = opj_int_floorlog2((OPJ_INT32 )len);
#line 636
          __cil_tmp36 = opj_int_max((OPJ_INT32 )increment, (OPJ_INT32 )((unsigned int )(__cil_tmp34 + 1) - (cblk->numlenbits + (unsigned int )__cil_tmp35)));
#line 636
          increment = (OPJ_UINT32 )__cil_tmp36;
#line 637
          len = (OPJ_UINT32 )0;
#line 638
          nump = (OPJ_UINT32 )0;
          }
        } else
#line 635
        if (passno == (cblk->numpasses + layer___0->numpasses) - 1U) {
#line 635
          goto _L;
        }
#line 641
        pass ++;
#line 631
        passno ++;
      }
      while_break___13: /* CIL Label */ ;
      }
      while_break___4: 
      {
#line 643
      opj_t2_putcommacode(bio, (OPJ_INT32 )increment);
#line 646
      cblk->numlenbits += increment;
#line 648
      pass = cblk->passes + cblk->numpasses;
#line 650
      passno = cblk->numpasses;
      }
      {
#line 650
      while (1) {
        while_continue___13: /* CIL Label */ ;

#line 650
        if (! (passno < l_nb_passes)) {
#line 650
          goto while_break___5;
        }
#line 651
        nump ++;
#line 652
        len += pass->len;
#line 654
        if ((int )pass->term) {
          {
#line 655
          __cil_tmp38 = opj_int_floorlog2((OPJ_INT32 )nump);
#line 655
          opj_bio_write(bio, len, cblk->numlenbits + (unsigned int )__cil_tmp38);
#line 656
          len = (OPJ_UINT32 )0;
#line 657
          nump = (OPJ_UINT32 )0;
          }
        } else
#line 654
        if (passno == (cblk->numpasses + layer___0->numpasses) - 1U) {
          {
#line 655
          __cil_tmp38 = opj_int_floorlog2((OPJ_INT32 )nump);
#line 655
          opj_bio_write(bio, len, cblk->numlenbits + (unsigned int )__cil_tmp38);
#line 656
          len = (OPJ_UINT32 )0;
#line 657
          nump = (OPJ_UINT32 )0;
          }
        }
#line 659
        pass ++;
#line 650
        passno ++;
      }
      while_break___14: /* CIL Label */ ;
      }
      while_break___5: 
#line 662
      cblk ++;
#line 599
      cblkno ++;
    }
    while_break___12: /* CIL Label */ ;
    }
    while_break___3: 
#line 665
    band ++;
#line 582
    bandno ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break___1: 
  {
#line 668
  __cil_tmp40 = opj_bio_flush(bio);
  }
#line 668
  if (! __cil_tmp40) {
    {
#line 669
    opj_bio_destroy(bio);
    }
#line 670
    return (0);
  }
  {
#line 673
  __cil_tmp41 = opj_bio_numbytes(bio);
#line 673
  l_nb_bytes = (OPJ_UINT32 )__cil_tmp41;
#line 674
  c += l_nb_bytes;
#line 675
  length -= l_nb_bytes;
#line 677
  opj_bio_destroy(bio);
  }
#line 680
  if (tcp->csty & 4U) {
#line 681
    *(c + 0) = (OPJ_BYTE )255;
#line 682
    *(c + 1) = (OPJ_BYTE )146;
#line 683
    c += 2;
#line 684
    length -= 2U;
  }
#line 691
  if (cstr_info) {
#line 691
    if (cstr_info->index_write) {
#line 692
      info_PK = (cstr_info->tile + tileno)->packet + cstr_info->packno;
#line 693
      info_PK->end_ph_pos = (OPJ_OFF_T )((OPJ_INT32 )(c - dest));
    }
  }
#line 698
  band = res->bands;
#line 699
  bandno = (OPJ_UINT32 )0;
  {
#line 699
  while (1) {
    while_continue___14: /* CIL Label */ ;

#line 699
    if (! (bandno < res->numbands)) {
#line 699
      goto while_break___6;
    }
#line 700
    prc___1 = band->precincts + precno;
#line 702
    l_nb_blocks = prc___1->cw * prc___1->ch;
#line 703
    cblk = prc___1->cblks.enc;
#line 705
    cblkno = (OPJ_UINT32 )0;
    {
#line 705
    while (1) {
      while_continue___15: /* CIL Label */ ;
      while_continue___7: ;
#line 705
      if (! (cblkno < l_nb_blocks)) {
#line 705
        goto while_break___7;
      }
#line 706
      layer___1 = cblk->layers + layno;
#line 708
      if (! layer___1->numpasses) {
#line 709
        cblk ++;
#line 710
        goto while_continue___7;
      }
#line 713
      if (layer___1->len > length) {
#line 714
        return (0);
      }
      {
#line 717
      memcpy((void *)c, (void const   *)layer___1->data, (unsigned long )layer___1->len);
#line 718
      cblk->numpasses += layer___1->numpasses;
#line 719
      c += layer___1->len;
#line 720
      length -= layer___1->len;
      }
#line 723
      if (cstr_info) {
#line 723
        if (cstr_info->index_write) {
#line 724
          info_PK___0 = (cstr_info->tile + tileno)->packet + cstr_info->packno;
#line 725
          info_PK___0->disto += layer___1->disto;
#line 726
          if (cstr_info->D_max < info_PK___0->disto) {
#line 727
            cstr_info->D_max = info_PK___0->disto;
          }
        }
      }
#line 731
      cblk ++;
#line 705
      cblkno ++;
    }
    while_break___16: /* CIL Label */ ;
    }
    while_break___7: 
#line 734
    band ++;
#line 699
    bandno ++;
  }
  while_break___15: /* CIL Label */ ;
  }
  while_break___6: 
#line 737
  *p_data_written = (OPJ_UINT32 )((long )*p_data_written + (c - dest));
#line 739
  return (1);
}
}
#line 742 "/root/patron/new_22/src/lib/openjp2/t2.c"
static OPJ_BOOL opj_t2_skip_packet(opj_t2_t *p_t2 , opj_tcd_tile_t *p_tile , opj_tcp_t *p_tcp ,
                                   opj_pi_iterator_t *p_pi , OPJ_BYTE *p_src , OPJ_UINT32 *p_data_read ,
                                   OPJ_UINT32 p_max_length , opj_packet_info_t *p_pack_info ) 
{ 
  OPJ_BOOL l_read_data ;
  OPJ_UINT32 l_nb_bytes_read ;
  OPJ_UINT32 l_nb_total_bytes_read ;
  OPJ_BOOL __cil_tmp12 ;
  OPJ_BOOL __cil_tmp13 ;

  {
  {
#line 752
  l_nb_bytes_read = (OPJ_UINT32 )0;
#line 753
  l_nb_total_bytes_read = (OPJ_UINT32 )0;
#line 755
  *p_data_read = (OPJ_UINT32 )0;
#line 757
  __cil_tmp12 = opj_t2_read_packet_header(p_t2, p_tile, p_tcp, p_pi, & l_read_data,
                                          p_src, & l_nb_bytes_read, p_max_length,
                                          p_pack_info);
  }
#line 757
  if (! __cil_tmp12) {
#line 758
    return (0);
  }
#line 761
  p_src += l_nb_bytes_read;
#line 762
  l_nb_total_bytes_read += l_nb_bytes_read;
#line 763
  p_max_length -= l_nb_bytes_read;
#line 766
  if (l_read_data) {
    {
#line 767
    l_nb_bytes_read = (OPJ_UINT32 )0;
#line 769
    __cil_tmp13 = opj_t2_skip_packet_data(p_t2, p_tile, p_pi, & l_nb_bytes_read, p_max_length,
                                          p_pack_info);
    }
#line 769
    if (! __cil_tmp13) {
#line 770
      return (0);
    }
#line 773
    l_nb_total_bytes_read += l_nb_bytes_read;
  }
#line 775
  *p_data_read = l_nb_total_bytes_read;
#line 777
  return (1);
}
}
#line 782 "/root/patron/new_22/src/lib/openjp2/t2.c"
OPJ_BOOL opj_t2_read_packet_header(opj_t2_t *p_t2 , opj_tcd_tile_t *p_tile , opj_tcp_t *p_tcp ,
                                   opj_pi_iterator_t *p_pi , OPJ_BOOL *p_is_data_present ,
                                   OPJ_BYTE *p_src_data , OPJ_UINT32 *p_data_read ,
                                   OPJ_UINT32 p_max_length , opj_packet_info_t *p_pack_info ) 
{ 
  OPJ_UINT32 bandno ;
  OPJ_UINT32 cblkno ;
  OPJ_UINT32 l_nb_code_blocks ;
  OPJ_UINT32 l_remaining_length ;
  OPJ_UINT32 l_header_length ;
  OPJ_UINT32 *l_modified_length_ptr ;
  OPJ_BYTE *l_current_data ;
  opj_cp_t *l_cp ;
  opj_bio_t *l_bio ;
  opj_tcd_band_t *l_band ;
  opj_tcd_cblk_dec_t *l_cblk ;
  opj_tcd_resolution_t *l_res ;
  OPJ_BYTE *l_header_data ;
  OPJ_BYTE **l_header_data_start ;
  OPJ_UINT32 l_present ;
  opj_tcd_precinct_t *l_prc ;
  ptrdiff_t __cil_tmp28 ;
  opj_tcd_precinct_t *l_prc___0 ;
  OPJ_UINT32 l_included ;
  OPJ_UINT32 l_increment ;
  OPJ_UINT32 l_segno ;
  OPJ_INT32 n ;
  OPJ_UINT32 i ;
  OPJ_UINT32 __cil_tmp37 ;
  OPJ_BOOL __cil_tmp40 ;
  OPJ_BOOL __cil_tmp41 ;
  OPJ_INT32 __cil_tmp42 ;
  OPJ_UINT32 __cil_tmp43 ;
  OPJ_UINT32 __cil_tmp44 ;
  OPJ_BOOL __cil_tmp45 ;
  OPJ_BOOL __cil_tmp47 ;
  ptrdiff_t __cil_tmp48 ;

  {
#line 798
  l_modified_length_ptr = (OPJ_UINT32 *)0;
#line 799
  l_current_data = p_src_data;
#line 800
  l_cp = p_t2->cp;
#line 801
  l_bio = (opj_bio_t *)0;
#line 802
  l_band = (opj_tcd_band_t *)0;
#line 803
  l_cblk = (opj_tcd_cblk_dec_t *)0;
#line 804
  l_res = (p_tile->comps + p_pi->compno)->resolutions + p_pi->resno;
#line 806
  l_header_data = (OPJ_BYTE *)0;
#line 807
  l_header_data_start = (OPJ_BYTE **)0;
#line 811
  if (p_pi->layno == 0U) {
#line 812
    l_band = l_res->bands;
#line 815
    bandno = (OPJ_UINT32 )0;
    {
#line 815
    while (1) {
      while_continue: /* CIL Label */ ;

#line 815
      if (! (bandno < l_res->numbands)) {
#line 815
        goto while_break;
      }
#line 816
      l_prc = l_band->precincts + p_pi->precno;
#line 818
      if (! (l_band->x1 - l_band->x0 == 0)) {
#line 818
        if (! (l_band->y1 - l_band->y0 == 0)) {
          {
#line 819
          opj_tgt_reset(l_prc->incltree);
#line 820
          opj_tgt_reset(l_prc->imsbtree);
#line 821
          l_cblk = l_prc->cblks.dec;
#line 823
          l_nb_code_blocks = l_prc->cw * l_prc->ch;
#line 824
          cblkno = (OPJ_UINT32 )0;
          }
          {
#line 824
          while (1) {
            while_continue___3: /* CIL Label */ ;

#line 824
            if (! (cblkno < l_nb_code_blocks)) {
#line 824
              goto while_break___0;
            }
#line 825
            l_cblk->numsegs = (OPJ_UINT32 )0;
#line 826
            l_cblk->real_num_segs = (OPJ_UINT32 )0;
#line 827
            l_cblk ++;
#line 824
            cblkno ++;
          }
          while_break___6: /* CIL Label */ ;
          }
          while_break___0: ;
        }
      }
#line 831
      l_band ++;
#line 815
      bandno ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 837
  if (p_tcp->csty & 2U) {
#line 838
    if (! ((int )*l_current_data != 255)) {
#line 838
      if (! ((int )*(l_current_data + 1) != 145)) {
#line 841
        l_current_data += 6;
      }
    }
  }
  {
#line 854
  l_bio = opj_bio_create();
  }
#line 855
  if (! l_bio) {
#line 856
    return (0);
  }
#line 859
  if ((int )l_cp->ppm == 1) {
#line 860
    l_header_data_start = & l_cp->ppm_data;
#line 861
    l_header_data = *l_header_data_start;
#line 862
    l_modified_length_ptr = & l_cp->ppm_len;
  } else
#line 865
  if ((int )p_tcp->ppt == 1) {
#line 866
    l_header_data_start = & p_tcp->ppt_data;
#line 867
    l_header_data = *l_header_data_start;
#line 868
    l_modified_length_ptr = & p_tcp->ppt_len;
  } else {
#line 871
    l_header_data_start = & l_current_data;
#line 872
    l_header_data = *l_header_data_start;
#line 873
    l_remaining_length = (OPJ_UINT32 )((p_src_data + p_max_length) - l_header_data);
#line 874
    l_modified_length_ptr = & l_remaining_length;
  }
  {
#line 877
  opj_bio_init_dec(l_bio, l_header_data, *l_modified_length_ptr);
#line 879
  l_present = opj_bio_read(l_bio, (OPJ_UINT32 )1);
  }
#line 880
  if (! l_present) {
    {
#line 882
    opj_bio_inalign(l_bio);
#line 883
    __cil_tmp28 = opj_bio_numbytes(l_bio);
#line 883
    l_header_data += __cil_tmp28;
#line 884
    opj_bio_destroy(l_bio);
    }
#line 887
    if (p_tcp->csty & 4U) {
#line 888
      if (p_max_length < 2U) {
        {
#line 889
        fprintf(stderr, "Not enough space for expected EPH marker\n");
        }
      } else
#line 890
      if ((int )*l_header_data != 255) {
        {
#line 891
        printf("Error : expected EPH marker\n");
        }
      } else
#line 890
      if ((int )*(l_header_data + 1) != 146) {
        {
#line 891
        printf("Error : expected EPH marker\n");
        }
      } else {
#line 893
        l_header_data += 2;
      }
    }
#line 897
    l_header_length = (OPJ_UINT32 )(l_header_data - *l_header_data_start);
#line 898
    *l_modified_length_ptr -= l_header_length;
#line 899
    *l_header_data_start += l_header_length;
#line 904
    if (p_pack_info) {
#line 905
      p_pack_info->end_ph_pos = (OPJ_OFF_T )((OPJ_INT32 )(l_current_data - p_src_data));
    }
#line 909
    *p_is_data_present = 0;
#line 910
    *p_data_read = (OPJ_UINT32 )(l_current_data - p_src_data);
#line 911
    return (1);
  }
#line 914
  l_band = l_res->bands;
#line 915
  bandno = (OPJ_UINT32 )0;
  {
#line 915
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___1: ;
#line 915
    if (! (bandno < l_res->numbands)) {
#line 915
      goto while_break___1;
    }
#line 916
    l_prc___0 = l_band->precincts + p_pi->precno;
#line 918
    if (l_band->x1 - l_band->x0 == 0) {
#line 919
      l_band ++;
#line 920
      goto while_continue___1;
    } else
#line 918
    if (l_band->y1 - l_band->y0 == 0) {
#line 919
      l_band ++;
#line 920
      goto while_continue___1;
    }
#line 923
    l_nb_code_blocks = l_prc___0->cw * l_prc___0->ch;
#line 924
    l_cblk = l_prc___0->cblks.dec;
#line 925
    cblkno = (OPJ_UINT32 )0;
    {
#line 925
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___2: ;
#line 925
      if (! (cblkno < l_nb_code_blocks)) {
#line 925
        goto while_break___2;
      }
#line 930
      if (! l_cblk->numsegs) {
        {
#line 931
        l_included = opj_tgt_decode(l_bio, l_prc___0->incltree, cblkno, (OPJ_INT32 )(p_pi->layno + 1U));
        }
      } else {
        {
#line 935
        l_included = opj_bio_read(l_bio, (OPJ_UINT32 )1);
        }
      }
#line 939
      if (! l_included) {
#line 940
        l_cblk->numnewpasses = (OPJ_UINT32 )0;
#line 941
        l_cblk ++;
#line 942
        goto while_continue___2;
      }
#line 946
      if (! l_cblk->numsegs) {
#line 947
        i = (OPJ_UINT32 )0;
        {
#line 949
        while (1) {
          while_continue___6: /* CIL Label */ ;
          {
#line 949
          __cil_tmp37 = opj_tgt_decode(l_bio, l_prc___0->imsbtree, cblkno, (OPJ_INT32 )i);
          }
#line 949
          if (! (! __cil_tmp37)) {
#line 949
            goto while_break___3;
          }
#line 950
          i ++;
        }
        while_break___9: /* CIL Label */ ;
        }
        while_break___3: 
#line 953
        l_cblk->numbps = (unsigned int )(l_band->numbps + 1) - i;
#line 954
        l_cblk->numlenbits = (OPJ_UINT32 )3;
      }
      {
#line 958
      l_cblk->numnewpasses = opj_t2_getnumpasses(l_bio);
#line 959
      l_increment = opj_t2_getcommacode(l_bio);
#line 962
      l_cblk->numlenbits += l_increment;
#line 963
      l_segno = (OPJ_UINT32 )0;
      }
#line 965
      if (! l_cblk->numsegs) {
        {
#line 966
        __cil_tmp40 = opj_t2_init_seg(l_cblk, l_segno, (p_tcp->tccps + p_pi->compno)->cblksty,
                                      (OPJ_UINT32 )1);
        }
#line 966
        if (! __cil_tmp40) {
          {
#line 967
          opj_bio_destroy(l_bio);
          }
#line 968
          return (0);
        }
      } else {
#line 972
        l_segno = l_cblk->numsegs - 1U;
#line 973
        if ((l_cblk->segs + l_segno)->numpasses == (l_cblk->segs + l_segno)->maxpasses) {
          {
#line 974
          l_segno ++;
#line 975
          __cil_tmp41 = opj_t2_init_seg(l_cblk, l_segno, (p_tcp->tccps + p_pi->compno)->cblksty,
                                        (OPJ_UINT32 )0);
          }
#line 975
          if (! __cil_tmp41) {
            {
#line 976
            opj_bio_destroy(l_bio);
            }
#line 977
            return (0);
          }
        }
      }
#line 981
      n = (OPJ_INT32 )l_cblk->numnewpasses;
      {
#line 983
      while (1) {
        while_continue___7: /* CIL Label */ ;
        {
#line 984
        __cil_tmp42 = opj_int_min((OPJ_INT32 )((l_cblk->segs + l_segno)->maxpasses - (l_cblk->segs + l_segno)->numpasses),
                                  n);
#line 984
        (l_cblk->segs + l_segno)->numnewpasses = (OPJ_UINT32 )__cil_tmp42;
#line 985
        __cil_tmp43 = opj_uint_floorlog2((l_cblk->segs + l_segno)->numnewpasses);
#line 985
        __cil_tmp44 = opj_bio_read(l_bio, l_cblk->numlenbits + __cil_tmp43);
#line 985
        (l_cblk->segs + l_segno)->newlen = __cil_tmp44;
        }
#line 987
        if ((l_cblk->segs + l_segno)->newlen > *l_modified_length_ptr) {
          {
#line 988
          opj_bio_destroy(l_bio);
          }
#line 989
          return (0);
        }
#line 992
        n = (OPJ_INT32 )((OPJ_UINT32 )n - (l_cblk->segs + l_segno)->numnewpasses);
#line 993
        if (n > 0) {
          {
#line 994
          l_segno ++;
#line 996
          __cil_tmp45 = opj_t2_init_seg(l_cblk, l_segno, (p_tcp->tccps + p_pi->compno)->cblksty,
                                        (OPJ_UINT32 )0);
          }
#line 996
          if (! __cil_tmp45) {
            {
#line 997
            opj_bio_destroy(l_bio);
            }
#line 998
            return (0);
          }
        }
#line 983
        if (! (n > 0)) {
#line 983
          goto while_break___4;
        }
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___4: 
#line 1003
      l_cblk ++;
#line 925
      cblkno ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___2: 
#line 1006
    l_band ++;
#line 915
    bandno ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___1: 
  {
#line 1009
  __cil_tmp47 = opj_bio_inalign(l_bio);
  }
#line 1009
  if (! __cil_tmp47) {
    {
#line 1010
    opj_bio_destroy(l_bio);
    }
#line 1011
    return (0);
  }
  {
#line 1014
  __cil_tmp48 = opj_bio_numbytes(l_bio);
#line 1014
  l_header_data += __cil_tmp48;
#line 1015
  opj_bio_destroy(l_bio);
  }
#line 1018
  if (p_tcp->csty & 4U) {
#line 1021
    if (! ((int )*l_header_data != 255)) {
#line 1021
      if (! ((int )*(l_header_data + 1) != 146)) {
#line 1024
        l_header_data += 2;
      }
    }
  }
#line 1028
  l_header_length = (OPJ_UINT32 )(l_header_data - *l_header_data_start);
#line 1029
  *l_modified_length_ptr -= l_header_length;
#line 1030
  *l_header_data_start += l_header_length;
#line 1035
  if (p_pack_info) {
#line 1036
    p_pack_info->end_ph_pos = (OPJ_OFF_T )((OPJ_INT32 )(l_current_data - p_src_data));
  }
#line 1040
  *p_is_data_present = 1;
#line 1041
  *p_data_read = (OPJ_UINT32 )(l_current_data - p_src_data);
#line 1043
  return (1);
}
}
#line 1046 "/root/patron/new_22/src/lib/openjp2/t2.c"
OPJ_BOOL opj_t2_read_packet_data(opj_t2_t *p_t2 , opj_tcd_tile_t *p_tile , opj_pi_iterator_t *p_pi ,
                                 OPJ_BYTE *p_src_data , OPJ_UINT32 *p_data_read ,
                                 OPJ_UINT32 p_max_length , opj_packet_info_t *pack_info ) 
{ 
  OPJ_UINT32 bandno ;
  OPJ_UINT32 cblkno ;
  OPJ_UINT32 l_nb_code_blocks ;
  OPJ_BYTE *l_current_data ;
  opj_tcd_band_t *l_band ;
  opj_tcd_cblk_dec_t *l_cblk ;
  opj_tcd_resolution_t *l_res ;
  opj_tcd_precinct_t *l_prc ;
  opj_tcd_seg_t *l_seg ;
  OPJ_BYTE *new_cblk_data ;
  void *__cil_tmp18 ;

  {
#line 1056
  l_current_data = p_src_data;
#line 1057
  l_band = (opj_tcd_band_t *)0;
#line 1058
  l_cblk = (opj_tcd_cblk_dec_t *)0;
#line 1059
  l_res = (p_tile->comps + p_pi->compno)->resolutions + p_pi->resno;
#line 1064
  l_band = l_res->bands;
#line 1065
  bandno = (OPJ_UINT32 )0;
  {
#line 1065
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: ;
#line 1065
    if (! (bandno < l_res->numbands)) {
#line 1065
      goto while_break;
    }
#line 1066
    l_prc = l_band->precincts + p_pi->precno;
#line 1068
    if (l_band->x1 - l_band->x0 == 0) {
#line 1069
      l_band ++;
#line 1070
      goto while_continue;
    } else
#line 1068
    if (l_band->y1 - l_band->y0 == 0) {
#line 1069
      l_band ++;
#line 1070
      goto while_continue;
    }
#line 1073
    l_nb_code_blocks = l_prc->cw * l_prc->ch;
#line 1074
    l_cblk = l_prc->cblks.dec;
#line 1076
    cblkno = (OPJ_UINT32 )0;
    {
#line 1076
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: ;
#line 1076
      if (! (cblkno < l_nb_code_blocks)) {
#line 1076
        goto while_break___0;
      }
#line 1077
      l_seg = (opj_tcd_seg_t *)0;
#line 1079
      if (! l_cblk->numnewpasses) {
#line 1081
        l_cblk ++;
#line 1082
        goto while_continue___0;
      }
#line 1085
      if (! l_cblk->numsegs) {
#line 1086
        l_seg = l_cblk->segs;
#line 1087
        (l_cblk->numsegs) ++;
#line 1088
        l_cblk->data_current_size = (OPJ_UINT32 )0;
      } else {
#line 1091
        l_seg = l_cblk->segs + (l_cblk->numsegs - 1U);
#line 1093
        if (l_seg->numpasses == l_seg->maxpasses) {
#line 1094
          l_seg ++;
#line 1095
          (l_cblk->numsegs) ++;
        }
      }
      {
#line 1099
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 1100
        if ((unsigned long )(l_current_data + l_seg->newlen) > (unsigned long )(p_src_data + p_max_length)) {
#line 1101
          return (0);
        }
#line 1124
        if (l_cblk->data_current_size + l_seg->newlen > l_cblk->data_max_size) {
          {
#line 1125
          __cil_tmp18 = realloc((void *)l_cblk->data, (unsigned long )(l_cblk->data_current_size + l_seg->newlen));
#line 1125
          new_cblk_data = (OPJ_BYTE *)__cil_tmp18;
          }
#line 1126
          if (! new_cblk_data) {
            {
#line 1127
            free((void *)l_cblk->data);
#line 1128
            l_cblk->data = (OPJ_BYTE *)((void *)0);
#line 1129
            l_cblk->data_max_size = (OPJ_UINT32 )0;
            }
#line 1131
            return (0);
          }
#line 1133
          l_cblk->data_max_size = l_cblk->data_current_size + l_seg->newlen;
#line 1134
          l_cblk->data = new_cblk_data;
        }
        {
#line 1137
        memcpy((void *)(l_cblk->data + l_cblk->data_current_size), (void const   *)l_current_data,
               (unsigned long )l_seg->newlen);
        }
#line 1139
        if (l_seg->numpasses == 0U) {
#line 1140
          l_seg->data = & l_cblk->data;
#line 1141
          l_seg->dataindex = l_cblk->data_current_size;
        }
#line 1144
        l_current_data += l_seg->newlen;
#line 1145
        l_seg->numpasses += l_seg->numnewpasses;
#line 1146
        l_cblk->numnewpasses -= l_seg->numnewpasses;
#line 1148
        l_seg->real_num_passes = l_seg->numpasses;
#line 1149
        l_cblk->data_current_size += l_seg->newlen;
#line 1150
        l_seg->len += l_seg->newlen;
#line 1152
        if (l_cblk->numnewpasses > 0U) {
#line 1153
          l_seg ++;
#line 1154
          (l_cblk->numsegs) ++;
        }
#line 1099
        if (! (l_cblk->numnewpasses > 0U)) {
#line 1099
          goto while_break___1;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: 
#line 1158
      l_cblk->real_num_segs = l_cblk->numsegs;
#line 1159
      l_cblk ++;
#line 1076
      cblkno ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
#line 1162
    l_band ++;
#line 1065
    bandno ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
#line 1165
  *p_data_read = (OPJ_UINT32 )(l_current_data - p_src_data);
#line 1167
  return (1);
}
}
#line 1170 "/root/patron/new_22/src/lib/openjp2/t2.c"
OPJ_BOOL opj_t2_skip_packet_data(opj_t2_t *p_t2 , opj_tcd_tile_t *p_tile , opj_pi_iterator_t *p_pi ,
                                 OPJ_UINT32 *p_data_read , OPJ_UINT32 p_max_length ,
                                 opj_packet_info_t *pack_info ) 
{ 
  OPJ_UINT32 bandno ;
  OPJ_UINT32 cblkno ;
  OPJ_UINT32 l_nb_code_blocks ;
  opj_tcd_band_t *l_band ;
  opj_tcd_cblk_dec_t *l_cblk ;
  opj_tcd_resolution_t *l_res ;
  opj_tcd_precinct_t *l_prc ;
  opj_tcd_seg_t *l_seg ;

  {
#line 1179
  l_band = (opj_tcd_band_t *)0;
#line 1180
  l_cblk = (opj_tcd_cblk_dec_t *)0;
#line 1181
  l_res = (p_tile->comps + p_pi->compno)->resolutions + p_pi->resno;
#line 1186
  *p_data_read = (OPJ_UINT32 )0;
#line 1187
  l_band = l_res->bands;
#line 1189
  bandno = (OPJ_UINT32 )0;
  {
#line 1189
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: ;
#line 1189
    if (! (bandno < l_res->numbands)) {
#line 1189
      goto while_break;
    }
#line 1190
    l_prc = l_band->precincts + p_pi->precno;
#line 1192
    if (l_band->x1 - l_band->x0 == 0) {
#line 1193
      l_band ++;
#line 1194
      goto while_continue;
    } else
#line 1192
    if (l_band->y1 - l_band->y0 == 0) {
#line 1193
      l_band ++;
#line 1194
      goto while_continue;
    }
#line 1197
    l_nb_code_blocks = l_prc->cw * l_prc->ch;
#line 1198
    l_cblk = l_prc->cblks.dec;
#line 1200
    cblkno = (OPJ_UINT32 )0;
    {
#line 1200
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: ;
#line 1200
      if (! (cblkno < l_nb_code_blocks)) {
#line 1200
        goto while_break___0;
      }
#line 1201
      l_seg = (opj_tcd_seg_t *)0;
#line 1203
      if (! l_cblk->numnewpasses) {
#line 1205
        l_cblk ++;
#line 1206
        goto while_continue___0;
      }
#line 1209
      if (! l_cblk->numsegs) {
#line 1210
        l_seg = l_cblk->segs;
#line 1211
        (l_cblk->numsegs) ++;
#line 1212
        l_cblk->data_current_size = (OPJ_UINT32 )0;
      } else {
#line 1215
        l_seg = l_cblk->segs + (l_cblk->numsegs - 1U);
#line 1217
        if (l_seg->numpasses == l_seg->maxpasses) {
#line 1218
          l_seg ++;
#line 1219
          (l_cblk->numsegs) ++;
        }
      }
      {
#line 1223
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 1224
        if (*p_data_read + l_seg->newlen > p_max_length) {
#line 1225
          return (0);
        }
#line 1247
        *p_data_read += l_seg->newlen;
#line 1249
        l_seg->numpasses += l_seg->numnewpasses;
#line 1250
        l_cblk->numnewpasses -= l_seg->numnewpasses;
#line 1251
        if (l_cblk->numnewpasses > 0U) {
#line 1253
          l_seg ++;
#line 1254
          (l_cblk->numsegs) ++;
        }
#line 1223
        if (! (l_cblk->numnewpasses > 0U)) {
#line 1223
          goto while_break___1;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: 
#line 1258
      l_cblk ++;
#line 1200
      cblkno ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
#line 1261
    l_band ++;
#line 1189
    bandno ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 1264
  return (1);
}
}
#line 1268 "/root/patron/new_22/src/lib/openjp2/t2.c"
OPJ_BOOL opj_t2_init_seg(opj_tcd_cblk_dec_t *cblk , OPJ_UINT32 index___0 , OPJ_UINT32 cblksty ,
                         OPJ_UINT32 first ) 
{ 
  opj_tcd_seg_t *seg ;
  OPJ_UINT32 l_nb_segs ;
  opj_tcd_seg_t *new_segs ;
  void *__cil_tmp8 ;
  int tmp ;

  {
#line 1273
  seg = (opj_tcd_seg_t *)0;
#line 1274
  l_nb_segs = index___0 + 1U;
#line 1276
  if (l_nb_segs > cblk->m_current_max_segs) {
    {
#line 1278
    cblk->m_current_max_segs += 10U;
#line 1280
    __cil_tmp8 = realloc((void *)cblk->segs, (unsigned long )cblk->m_current_max_segs * sizeof(opj_tcd_seg_t ));
#line 1280
    new_segs = (opj_tcd_seg_t *)__cil_tmp8;
    }
#line 1281
    if (! new_segs) {
      {
#line 1282
      free((void *)cblk->segs);
#line 1283
      cblk->segs = (opj_tcd_seg_t *)((void *)0);
#line 1284
      cblk->m_current_max_segs = (OPJ_UINT32 )0;
      }
#line 1286
      return (0);
    }
#line 1288
    cblk->segs = new_segs;
  }
  {
#line 1291
  seg = cblk->segs + index___0;
#line 1292
  memset((void *)seg, 0, sizeof(opj_tcd_seg_t ));
  }
#line 1294
  if (cblksty & 4U) {
#line 1295
    seg->maxpasses = (OPJ_UINT32 )1;
  } else
#line 1297
  if (cblksty & 1U) {
#line 1298
    if (first) {
#line 1299
      seg->maxpasses = (OPJ_UINT32 )10;
    } else {
#line 1301
      if ((seg - 1)->maxpasses == 1U) {
#line 1301
        tmp = 2;
      } else
#line 1301
      if ((seg - 1)->maxpasses == 10U) {
#line 1301
        tmp = 2;
      } else {
#line 1301
        tmp = 1;
      }
#line 1301
      seg->maxpasses = (OPJ_UINT32 )tmp;
    }
  } else {
#line 1304
    seg->maxpasses = (OPJ_UINT32 )109;
  }
#line 1307
  return (1);
}
}
#line 46 "/root/patron/new_22/src/lib/openjp2/pi.c"
OPJ_BOOL opj_pi_next_lrcp(opj_pi_iterator_t *pi ) ;
#line 52
OPJ_BOOL opj_pi_next_rlcp(opj_pi_iterator_t *pi ) ;
#line 58
OPJ_BOOL opj_pi_next_rpcl(opj_pi_iterator_t *pi ) ;
#line 64
OPJ_BOOL opj_pi_next_pcrl(opj_pi_iterator_t *pi ) ;
#line 70
OPJ_BOOL opj_pi_next_cprl(opj_pi_iterator_t *pi ) ;
#line 86
void opj_pi_update_encode_poc_and_final(opj_cp_t *p_cp , OPJ_UINT32 p_tileno , OPJ_INT32 p_tx0 ,
                                        OPJ_INT32 p_tx1 , OPJ_INT32 p_ty0 , OPJ_INT32 p_ty1 ,
                                        OPJ_UINT32 p_max_prec , OPJ_UINT32 p_max_res ,
                                        OPJ_UINT32 p_dx_min , OPJ_UINT32 p_dy_min ) ;
#line 112
void opj_pi_update_encode_not_poc(opj_cp_t *p_cp , OPJ_UINT32 p_num_comps , OPJ_UINT32 p_tileno ,
                                  OPJ_INT32 p_tx0 , OPJ_INT32 p_tx1 , OPJ_INT32 p_ty0 ,
                                  OPJ_INT32 p_ty1 , OPJ_UINT32 p_max_prec , OPJ_UINT32 p_max_res ,
                                  OPJ_UINT32 p_dx_min , OPJ_UINT32 p_dy_min ) ;
#line 138
void opj_get_encoding_parameters(opj_image_t *p_image , opj_cp_t *p_cp , OPJ_UINT32 p_tileno ,
                                 OPJ_INT32 *p_tx0 , OPJ_INT32 *p_tx1 , OPJ_INT32 *p_ty0 ,
                                 OPJ_INT32 *p_ty1 , OPJ_UINT32 *p_dx_min , OPJ_UINT32 *p_dy_min ,
                                 OPJ_UINT32 *p_max_prec , OPJ_UINT32 *p_max_res ) ;
#line 170
void opj_get_all_encoding_parameters(opj_image_t *p_image , opj_cp_t *p_cp , OPJ_UINT32 tileno ,
                                     OPJ_INT32 *p_tx0 , OPJ_INT32 *p_tx1 , OPJ_INT32 *p_ty0 ,
                                     OPJ_INT32 *p_ty1 , OPJ_UINT32 *p_dx_min , OPJ_UINT32 *p_dy_min ,
                                     OPJ_UINT32 *p_max_prec , OPJ_UINT32 *p_max_res ,
                                     OPJ_UINT32 **p_resolutions ) ;
#line 190
opj_pi_iterator_t *opj_pi_create(opj_image_t *image , opj_cp_t *cp , OPJ_UINT32 tileno ) ;
#line 196
void opj_pi_update_decode_not_poc(opj_pi_iterator_t *p_pi , opj_tcp_t *p_tcp , OPJ_UINT32 p_max_precision ,
                                  OPJ_UINT32 p_max_res ) ;
#line 203
void opj_pi_update_decode_poc(opj_pi_iterator_t *p_pi , opj_tcp_t *p_tcp , OPJ_UINT32 p_max_precision ,
                              OPJ_UINT32 p_max_res ) ;
#line 211
OPJ_BOOL opj_pi_check_next_level(OPJ_INT32 pos , opj_cp_t *cp , OPJ_UINT32 tileno ,
                                 OPJ_UINT32 pino , OPJ_CHAR *prog ) ;
#line 227 "/root/patron/new_22/src/lib/openjp2/pi.c"
OPJ_BOOL opj_pi_next_lrcp(opj_pi_iterator_t *pi ) 
{ 
  opj_pi_comp_t *comp ;
  opj_pi_resolution_t *res ;
  OPJ_UINT32 index___3 ;

  {
#line 228
  comp = (opj_pi_comp_t *)((void *)0);
#line 229
  res = (opj_pi_resolution_t *)((void *)0);
#line 230
  index___3 = (OPJ_UINT32 )0;
#line 232
  if (! pi->first) {
#line 233
    comp = pi->comps + pi->compno;
#line 234
    res = comp->resolutions + pi->resno;
#line 235
    goto LABEL_SKIP;
  } else {
#line 237
    pi->first = 0;
  }
#line 240
  pi->layno = pi->poc.layno0;
  {
#line 240
  while (1) {
    while_continue: /* CIL Label */ ;

#line 240
    if (! (pi->layno < pi->poc.layno1)) {
#line 240
      goto while_break;
    }
#line 241
    pi->resno = pi->poc.resno0;
    {
#line 241
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 241
      if (! (pi->resno < pi->poc.resno1)) {
#line 241
        goto while_break___0;
      }
#line 243
      pi->compno = pi->poc.compno0;
      {
#line 243
      while (1) {
        while_continue___3: /* CIL Label */ ;
        while_continue___1: ;
#line 243
        if (! (pi->compno < pi->poc.compno1)) {
#line 243
          goto while_break___1;
        }
#line 244
        comp = pi->comps + pi->compno;
#line 245
        if (pi->resno >= comp->numresolutions) {
#line 246
          goto while_continue___1;
        }
#line 248
        res = comp->resolutions + pi->resno;
#line 249
        if (! pi->tp_on) {
#line 250
          pi->poc.precno1 = res->pw * res->ph;
        }
#line 252
        pi->precno = pi->poc.precno0;
        {
#line 252
        while (1) {
          while_continue___4: /* CIL Label */ ;

#line 252
          if (! (pi->precno < pi->poc.precno1)) {
#line 252
            goto while_break___2;
          }
#line 253
          index___3 = ((pi->layno * pi->step_l + pi->resno * pi->step_r) + pi->compno * pi->step_c) + pi->precno * pi->step_p;
#line 254
          if (! *(pi->include + index___3)) {
#line 255
            *(pi->include + index___3) = (OPJ_INT16 )1;
#line 256
            return (1);
          }
          LABEL_SKIP: 
#line 252
          (pi->precno) ++;
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___2: 
#line 243
        (pi->compno) ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: 
#line 242
      (pi->resno) ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
#line 240
    (pi->layno) ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: ;
#line 264
  return (0);
}
}
#line 267 "/root/patron/new_22/src/lib/openjp2/pi.c"
OPJ_BOOL opj_pi_next_rlcp(opj_pi_iterator_t *pi ) 
{ 
  opj_pi_comp_t *comp ;
  opj_pi_resolution_t *res ;
  OPJ_UINT32 index___4 ;

  {
#line 268
  comp = (opj_pi_comp_t *)((void *)0);
#line 269
  res = (opj_pi_resolution_t *)((void *)0);
#line 270
  index___4 = (OPJ_UINT32 )0;
#line 272
  if (! pi->first) {
#line 273
    comp = pi->comps + pi->compno;
#line 274
    res = comp->resolutions + pi->resno;
#line 275
    goto LABEL_SKIP;
  } else {
#line 277
    pi->first = 0;
  }
#line 280
  pi->resno = pi->poc.resno0;
  {
#line 280
  while (1) {
    while_continue: /* CIL Label */ ;

#line 280
    if (! (pi->resno < pi->poc.resno1)) {
#line 280
      goto while_break;
    }
#line 281
    pi->layno = pi->poc.layno0;
    {
#line 281
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 281
      if (! (pi->layno < pi->poc.layno1)) {
#line 281
        goto while_break___0;
      }
#line 282
      pi->compno = pi->poc.compno0;
      {
#line 282
      while (1) {
        while_continue___3: /* CIL Label */ ;
        while_continue___1: ;
#line 282
        if (! (pi->compno < pi->poc.compno1)) {
#line 282
          goto while_break___1;
        }
#line 283
        comp = pi->comps + pi->compno;
#line 284
        if (pi->resno >= comp->numresolutions) {
#line 285
          goto while_continue___1;
        }
#line 287
        res = comp->resolutions + pi->resno;
#line 288
        if (! pi->tp_on) {
#line 289
          pi->poc.precno1 = res->pw * res->ph;
        }
#line 291
        pi->precno = pi->poc.precno0;
        {
#line 291
        while (1) {
          while_continue___4: /* CIL Label */ ;

#line 291
          if (! (pi->precno < pi->poc.precno1)) {
#line 291
            goto while_break___2;
          }
#line 292
          index___4 = ((pi->layno * pi->step_l + pi->resno * pi->step_r) + pi->compno * pi->step_c) + pi->precno * pi->step_p;
#line 293
          if (! *(pi->include + index___4)) {
#line 294
            *(pi->include + index___4) = (OPJ_INT16 )1;
#line 295
            return (1);
          }
          LABEL_SKIP: 
#line 291
          (pi->precno) ++;
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___2: 
#line 282
        (pi->compno) ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: 
#line 281
      (pi->layno) ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
#line 280
    (pi->resno) ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: ;
#line 303
  return (0);
}
}
#line 306 "/root/patron/new_22/src/lib/openjp2/pi.c"
OPJ_BOOL opj_pi_next_rpcl(opj_pi_iterator_t *pi ) 
{ 
  opj_pi_comp_t *comp ;
  opj_pi_resolution_t *res ;
  OPJ_UINT32 index___5 ;
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 dx ;
  OPJ_UINT32 dy ;
  OPJ_UINT32 __cil_tmp9 ;
  OPJ_UINT32 tmp ;
  OPJ_UINT32 __cil_tmp11 ;
  OPJ_UINT32 tmp___0 ;
  OPJ_UINT32 levelno ;
  OPJ_INT32 trx0 ;
  OPJ_INT32 try0 ;
  OPJ_INT32 trx1 ;
  OPJ_INT32 try1 ;
  OPJ_UINT32 rpx ;
  OPJ_UINT32 rpy ;
  OPJ_INT32 prci ;
  OPJ_INT32 prcj ;
  OPJ_INT32 __cil_tmp28 ;
  OPJ_INT32 __cil_tmp29 ;
  OPJ_INT32 __cil_tmp30 ;
  OPJ_INT32 __cil_tmp31 ;
  OPJ_INT32 __cil_tmp32 ;
  OPJ_INT32 __cil_tmp33 ;

  {
#line 307
  comp = (opj_pi_comp_t *)((void *)0);
#line 308
  res = (opj_pi_resolution_t *)((void *)0);
#line 309
  index___5 = (OPJ_UINT32 )0;
#line 311
  if (! pi->first) {
#line 312
    goto LABEL_SKIP;
  } else {
#line 315
    pi->first = 0;
#line 316
    pi->dx = (OPJ_UINT32 )0;
#line 317
    pi->dy = (OPJ_UINT32 )0;
#line 318
    compno = (OPJ_UINT32 )0;
    {
#line 318
    while (1) {
      while_continue: /* CIL Label */ ;

#line 318
      if (! (compno < pi->numcomps)) {
#line 318
        goto while_break;
      }
#line 319
      comp = pi->comps + compno;
#line 320
      resno = (OPJ_UINT32 )0;
      {
#line 320
      while (1) {
        while_continue___5: /* CIL Label */ ;

#line 320
        if (! (resno < comp->numresolutions)) {
#line 320
          goto while_break___0;
        }
#line 322
        res = comp->resolutions + resno;
#line 323
        dx = comp->dx * (unsigned int )(1 << (((res->pdx + comp->numresolutions) - 1U) - resno));
#line 324
        dy = comp->dy * (unsigned int )(1 << (((res->pdy + comp->numresolutions) - 1U) - resno));
#line 325
        if (! pi->dx) {
#line 325
          tmp = dx;
        } else {
          {
#line 325
          __cil_tmp9 = opj_uint_min(pi->dx, dx);
#line 325
          tmp = __cil_tmp9;
          }
        }
#line 325
        pi->dx = tmp;
#line 326
        if (! pi->dy) {
#line 326
          tmp___0 = dy;
        } else {
          {
#line 326
          __cil_tmp11 = opj_uint_min(pi->dy, dy);
#line 326
          tmp___0 = __cil_tmp11;
          }
        }
#line 326
        pi->dy = tmp___0;
#line 320
        resno ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___0: 
#line 318
      compno ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 330
  if (! pi->tp_on) {
#line 331
    pi->poc.ty0 = pi->ty0;
#line 332
    pi->poc.tx0 = pi->tx0;
#line 333
    pi->poc.ty1 = pi->ty1;
#line 334
    pi->poc.tx1 = pi->tx1;
  }
#line 336
  pi->resno = pi->poc.resno0;
  {
#line 336
  while (1) {
    while_continue___6: /* CIL Label */ ;

#line 336
    if (! (pi->resno < pi->poc.resno1)) {
#line 336
      goto while_break___1;
    }
#line 337
    pi->y = pi->poc.ty0;
    {
#line 337
    while (1) {
      while_continue___7: /* CIL Label */ ;

#line 337
      if (! (pi->y < pi->poc.ty1)) {
#line 337
        goto while_break___2;
      }
#line 338
      pi->x = pi->poc.tx0;
      {
#line 338
      while (1) {
        while_continue___8: /* CIL Label */ ;

#line 338
        if (! (pi->x < pi->poc.tx1)) {
#line 338
          goto while_break___3;
        }
#line 339
        pi->compno = pi->poc.compno0;
        {
#line 339
        while (1) {
          while_continue___9: /* CIL Label */ ;
          while_continue___4: ;
#line 339
          if (! (pi->compno < pi->poc.compno1)) {
#line 339
            goto while_break___4;
          }
#line 345
          comp = pi->comps + pi->compno;
#line 346
          if (pi->resno >= comp->numresolutions) {
#line 347
            goto while_continue___4;
          }
          {
#line 349
          res = comp->resolutions + pi->resno;
#line 350
          levelno = (comp->numresolutions - 1U) - pi->resno;
#line 351
          trx0 = opj_int_ceildiv(pi->tx0, (OPJ_INT32 )(comp->dx << levelno));
#line 352
          try0 = opj_int_ceildiv(pi->ty0, (OPJ_INT32 )(comp->dy << levelno));
#line 353
          trx1 = opj_int_ceildiv(pi->tx1, (OPJ_INT32 )(comp->dx << levelno));
#line 354
          try1 = opj_int_ceildiv(pi->ty1, (OPJ_INT32 )(comp->dy << levelno));
#line 355
          rpx = res->pdx + levelno;
#line 356
          rpy = res->pdy + levelno;
          }
#line 357
          if (! ((unsigned int )pi->y % (comp->dy << rpy) == 0U)) {
#line 357
            if (pi->y == pi->ty0) {
#line 357
              if (! ((try0 << levelno) % (1 << rpy))) {
#line 358
                goto while_continue___4;
              }
            } else {
#line 358
              goto while_continue___4;
            }
          }
#line 360
          if (! ((unsigned int )pi->x % (comp->dx << rpx) == 0U)) {
#line 360
            if (pi->x == pi->tx0) {
#line 360
              if (! ((trx0 << levelno) % (1 << rpx))) {
#line 361
                goto while_continue___4;
              }
            } else {
#line 361
              goto while_continue___4;
            }
          }
#line 364
          if (res->pw == 0U) {
#line 364
            goto while_continue___4;
          } else
#line 364
          if (res->ph == 0U) {
#line 364
            goto while_continue___4;
          }
#line 366
          if (trx0 == trx1) {
#line 366
            goto while_continue___4;
          } else
#line 366
          if (try0 == try1) {
#line 366
            goto while_continue___4;
          }
          {
#line 368
          __cil_tmp30 = opj_int_floordivpow2(trx0, (OPJ_INT32 )res->pdx);
#line 368
          __cil_tmp28 = opj_int_ceildiv(pi->x, (OPJ_INT32 )(comp->dx << levelno));
#line 368
          __cil_tmp29 = opj_int_floordivpow2(__cil_tmp28, (OPJ_INT32 )res->pdx);
#line 368
          prci = __cil_tmp29 - __cil_tmp30;
#line 370
          __cil_tmp33 = opj_int_floordivpow2(try0, (OPJ_INT32 )res->pdy);
#line 370
          __cil_tmp31 = opj_int_ceildiv(pi->y, (OPJ_INT32 )(comp->dy << levelno));
#line 370
          __cil_tmp32 = opj_int_floordivpow2(__cil_tmp31, (OPJ_INT32 )res->pdy);
#line 370
          prcj = __cil_tmp32 - __cil_tmp33;
#line 372
          pi->precno = (unsigned int )prci + (unsigned int )prcj * res->pw;
#line 373
          pi->layno = pi->poc.layno0;
          }
          {
#line 373
          while (1) {
            while_continue___10: /* CIL Label */ ;

#line 373
            if (! (pi->layno < pi->poc.layno1)) {
#line 373
              goto while_break___5;
            }
#line 374
            index___5 = ((pi->layno * pi->step_l + pi->resno * pi->step_r) + pi->compno * pi->step_c) + pi->precno * pi->step_p;
#line 375
            if (! *(pi->include + index___5)) {
#line 376
              *(pi->include + index___5) = (OPJ_INT16 )1;
#line 377
              return (1);
            }
            LABEL_SKIP: 
#line 373
            (pi->layno) ++;
          }
          while_break___12: /* CIL Label */ ;
          }
          while_break___5: 
#line 339
          (pi->compno) ++;
        }
        while_break___11: /* CIL Label */ ;
        }
        while_break___4: 
#line 338
        pi->x = (OPJ_INT32 )((OPJ_UINT32 )pi->x + (pi->dx - (unsigned int )pi->x % pi->dx));
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___3: 
#line 337
      pi->y = (OPJ_INT32 )((OPJ_UINT32 )pi->y + (pi->dy - (unsigned int )pi->y % pi->dy));
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___2: 
#line 336
    (pi->resno) ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___1: ;
#line 386
  return (0);
}
}
#line 389 "/root/patron/new_22/src/lib/openjp2/pi.c"
OPJ_BOOL opj_pi_next_pcrl(opj_pi_iterator_t *pi ) 
{ 
  opj_pi_comp_t *comp ;
  opj_pi_resolution_t *res ;
  OPJ_UINT32 index___6 ;
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 dx ;
  OPJ_UINT32 dy ;
  OPJ_UINT32 __cil_tmp9 ;
  OPJ_UINT32 tmp ;
  OPJ_UINT32 __cil_tmp11 ;
  OPJ_UINT32 tmp___0 ;
  OPJ_UINT32 __cil_tmp15 ;
  OPJ_UINT32 levelno ;
  OPJ_INT32 trx0 ;
  OPJ_INT32 try0 ;
  OPJ_INT32 trx1 ;
  OPJ_INT32 try1 ;
  OPJ_UINT32 rpx ;
  OPJ_UINT32 rpy ;
  OPJ_INT32 prci ;
  OPJ_INT32 prcj ;
  OPJ_INT32 __cil_tmp29 ;
  OPJ_INT32 __cil_tmp30 ;
  OPJ_INT32 __cil_tmp31 ;
  OPJ_INT32 __cil_tmp32 ;
  OPJ_INT32 __cil_tmp33 ;
  OPJ_INT32 __cil_tmp34 ;

  {
#line 390
  comp = (opj_pi_comp_t *)((void *)0);
#line 391
  res = (opj_pi_resolution_t *)((void *)0);
#line 392
  index___6 = (OPJ_UINT32 )0;
#line 394
  if (! pi->first) {
#line 395
    comp = pi->comps + pi->compno;
#line 396
    goto LABEL_SKIP;
  } else {
#line 399
    pi->first = 0;
#line 400
    pi->dx = (OPJ_UINT32 )0;
#line 401
    pi->dy = (OPJ_UINT32 )0;
#line 402
    compno = (OPJ_UINT32 )0;
    {
#line 402
    while (1) {
      while_continue: /* CIL Label */ ;

#line 402
      if (! (compno < pi->numcomps)) {
#line 402
        goto while_break;
      }
#line 403
      comp = pi->comps + compno;
#line 404
      resno = (OPJ_UINT32 )0;
      {
#line 404
      while (1) {
        while_continue___5: /* CIL Label */ ;

#line 404
        if (! (resno < comp->numresolutions)) {
#line 404
          goto while_break___0;
        }
#line 406
        res = comp->resolutions + resno;
#line 407
        dx = comp->dx * (unsigned int )(1 << (((res->pdx + comp->numresolutions) - 1U) - resno));
#line 408
        dy = comp->dy * (unsigned int )(1 << (((res->pdy + comp->numresolutions) - 1U) - resno));
#line 409
        if (! pi->dx) {
#line 409
          tmp = dx;
        } else {
          {
#line 409
          __cil_tmp9 = opj_uint_min(pi->dx, dx);
#line 409
          tmp = __cil_tmp9;
          }
        }
#line 409
        pi->dx = tmp;
#line 410
        if (! pi->dy) {
#line 410
          tmp___0 = dy;
        } else {
          {
#line 410
          __cil_tmp11 = opj_uint_min(pi->dy, dy);
#line 410
          tmp___0 = __cil_tmp11;
          }
        }
#line 410
        pi->dy = tmp___0;
#line 404
        resno ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___0: 
#line 402
      compno ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 414
  if (! pi->tp_on) {
#line 415
    pi->poc.ty0 = pi->ty0;
#line 416
    pi->poc.tx0 = pi->tx0;
#line 417
    pi->poc.ty1 = pi->ty1;
#line 418
    pi->poc.tx1 = pi->tx1;
  }
#line 420
  pi->y = pi->poc.ty0;
  {
#line 420
  while (1) {
    while_continue___6: /* CIL Label */ ;

#line 420
    if (! (pi->y < pi->poc.ty1)) {
#line 420
      goto while_break___1;
    }
#line 421
    pi->x = pi->poc.tx0;
    {
#line 421
    while (1) {
      while_continue___7: /* CIL Label */ ;

#line 421
      if (! (pi->x < pi->poc.tx1)) {
#line 421
        goto while_break___2;
      }
#line 422
      pi->compno = pi->poc.compno0;
      {
#line 422
      while (1) {
        while_continue___8: /* CIL Label */ ;

#line 422
        if (! (pi->compno < pi->poc.compno1)) {
#line 422
          goto while_break___3;
        }
#line 423
        comp = pi->comps + pi->compno;
#line 424
        pi->resno = pi->poc.resno0;
        {
#line 424
        while (1) {
          while_continue___9: /* CIL Label */ ;
          while_continue___4: ;
#line 424
          if (! (pi->resno < __cil_tmp15)) {
#line 424
            goto while_break___4;
          }
          {
#line 430
          res = comp->resolutions + pi->resno;
#line 431
          levelno = (comp->numresolutions - 1U) - pi->resno;
#line 432
          trx0 = opj_int_ceildiv(pi->tx0, (OPJ_INT32 )(comp->dx << levelno));
#line 433
          try0 = opj_int_ceildiv(pi->ty0, (OPJ_INT32 )(comp->dy << levelno));
#line 434
          trx1 = opj_int_ceildiv(pi->tx1, (OPJ_INT32 )(comp->dx << levelno));
#line 435
          try1 = opj_int_ceildiv(pi->ty1, (OPJ_INT32 )(comp->dy << levelno));
#line 436
          rpx = res->pdx + levelno;
#line 437
          rpy = res->pdy + levelno;
          }
#line 438
          if (! ((unsigned int )pi->y % (comp->dy << rpy) == 0U)) {
#line 438
            if (pi->y == pi->ty0) {
#line 438
              if (! ((try0 << levelno) % (1 << rpy))) {
#line 439
                goto while_continue___4;
              }
            } else {
#line 439
              goto while_continue___4;
            }
          }
#line 441
          if (! ((unsigned int )pi->x % (comp->dx << rpx) == 0U)) {
#line 441
            if (pi->x == pi->tx0) {
#line 441
              if (! ((trx0 << levelno) % (1 << rpx))) {
#line 442
                goto while_continue___4;
              }
            } else {
#line 442
              goto while_continue___4;
            }
          }
#line 445
          if (res->pw == 0U) {
#line 445
            goto while_continue___4;
          } else
#line 445
          if (res->ph == 0U) {
#line 445
            goto while_continue___4;
          }
#line 447
          if (trx0 == trx1) {
#line 447
            goto while_continue___4;
          } else
#line 447
          if (try0 == try1) {
#line 447
            goto while_continue___4;
          }
          {
#line 449
          __cil_tmp31 = opj_int_floordivpow2(trx0, (OPJ_INT32 )res->pdx);
#line 449
          __cil_tmp29 = opj_int_ceildiv(pi->x, (OPJ_INT32 )(comp->dx << levelno));
#line 449
          __cil_tmp30 = opj_int_floordivpow2(__cil_tmp29, (OPJ_INT32 )res->pdx);
#line 449
          prci = __cil_tmp30 - __cil_tmp31;
#line 451
          __cil_tmp34 = opj_int_floordivpow2(try0, (OPJ_INT32 )res->pdy);
#line 451
          __cil_tmp32 = opj_int_ceildiv(pi->y, (OPJ_INT32 )(comp->dy << levelno));
#line 451
          __cil_tmp33 = opj_int_floordivpow2(__cil_tmp32, (OPJ_INT32 )res->pdy);
#line 451
          prcj = __cil_tmp33 - __cil_tmp34;
#line 453
          pi->precno = (unsigned int )prci + (unsigned int )prcj * res->pw;
#line 454
          pi->layno = pi->poc.layno0;
          }
          {
#line 454
          while (1) {
            while_continue___10: /* CIL Label */ ;

#line 454
            if (! (pi->layno < pi->poc.layno1)) {
#line 454
              goto while_break___5;
            }
#line 455
            index___6 = ((pi->layno * pi->step_l + pi->resno * pi->step_r) + pi->compno * pi->step_c) + pi->precno * pi->step_p;
#line 456
            if (! *(pi->include + index___6)) {
#line 457
              *(pi->include + index___6) = (OPJ_INT16 )1;
#line 458
              return (1);
            }
            LABEL_SKIP: 
#line 454
            (pi->layno) ++;
          }
          while_break___12: /* CIL Label */ ;
          }
          while_break___5: 
#line 424
          (pi->resno) ++;
        }
        while_break___11: /* CIL Label */ ;
        }
        while_break___4: 
#line 422
        (pi->compno) ++;
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___3: 
#line 421
      pi->x = (OPJ_INT32 )((OPJ_UINT32 )pi->x + (pi->dx - (unsigned int )pi->x % pi->dx));
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___2: 
#line 420
    pi->y = (OPJ_INT32 )((OPJ_UINT32 )pi->y + (pi->dy - (unsigned int )pi->y % pi->dy));
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___1: ;
#line 467
  return (0);
}
}
#line 470 "/root/patron/new_22/src/lib/openjp2/pi.c"
OPJ_BOOL opj_pi_next_cprl(opj_pi_iterator_t *pi ) 
{ 
  opj_pi_comp_t *comp ;
  opj_pi_resolution_t *res ;
  OPJ_UINT32 index___7 ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 dx ;
  OPJ_UINT32 dy ;
  OPJ_UINT32 __cil_tmp8 ;
  OPJ_UINT32 tmp ;
  OPJ_UINT32 __cil_tmp10 ;
  OPJ_UINT32 tmp___0 ;
  OPJ_UINT32 __cil_tmp13 ;
  OPJ_UINT32 levelno ;
  OPJ_INT32 trx0 ;
  OPJ_INT32 try0 ;
  OPJ_INT32 trx1 ;
  OPJ_INT32 try1 ;
  OPJ_UINT32 rpx ;
  OPJ_UINT32 rpy ;
  OPJ_INT32 prci ;
  OPJ_INT32 prcj ;
  OPJ_INT32 __cil_tmp27 ;
  OPJ_INT32 __cil_tmp28 ;
  OPJ_INT32 __cil_tmp29 ;
  OPJ_INT32 __cil_tmp30 ;
  OPJ_INT32 __cil_tmp31 ;
  OPJ_INT32 __cil_tmp32 ;

  {
#line 471
  comp = (opj_pi_comp_t *)((void *)0);
#line 472
  res = (opj_pi_resolution_t *)((void *)0);
#line 473
  index___7 = (OPJ_UINT32 )0;
#line 475
  if (! pi->first) {
#line 476
    comp = pi->comps + pi->compno;
#line 477
    goto LABEL_SKIP;
  } else {
#line 479
    pi->first = 0;
  }
#line 482
  pi->compno = pi->poc.compno0;
  {
#line 482
  while (1) {
    while_continue: /* CIL Label */ ;

#line 482
    if (! (pi->compno < pi->poc.compno1)) {
#line 482
      goto while_break;
    }
#line 484
    comp = pi->comps + pi->compno;
#line 485
    pi->dx = (OPJ_UINT32 )0;
#line 486
    pi->dy = (OPJ_UINT32 )0;
#line 487
    resno = (OPJ_UINT32 )0;
    {
#line 487
    while (1) {
      while_continue___4: /* CIL Label */ ;

#line 487
      if (! (resno < comp->numresolutions)) {
#line 487
        goto while_break___0;
      }
#line 489
      res = comp->resolutions + resno;
#line 490
      dx = comp->dx * (unsigned int )(1 << (((res->pdx + comp->numresolutions) - 1U) - resno));
#line 491
      dy = comp->dy * (unsigned int )(1 << (((res->pdy + comp->numresolutions) - 1U) - resno));
#line 492
      if (! pi->dx) {
#line 492
        tmp = dx;
      } else {
        {
#line 492
        __cil_tmp8 = opj_uint_min(pi->dx, dx);
#line 492
        tmp = __cil_tmp8;
        }
      }
#line 492
      pi->dx = tmp;
#line 493
      if (! pi->dy) {
#line 493
        tmp___0 = dy;
      } else {
        {
#line 493
        __cil_tmp10 = opj_uint_min(pi->dy, dy);
#line 493
        tmp___0 = __cil_tmp10;
        }
      }
#line 493
      pi->dy = tmp___0;
#line 487
      resno ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___0: ;
#line 495
    if (! pi->tp_on) {
#line 496
      pi->poc.ty0 = pi->ty0;
#line 497
      pi->poc.tx0 = pi->tx0;
#line 498
      pi->poc.ty1 = pi->ty1;
#line 499
      pi->poc.tx1 = pi->tx1;
    }
#line 501
    pi->y = pi->poc.ty0;
    {
#line 501
    while (1) {
      while_continue___5: /* CIL Label */ ;

#line 501
      if (! (pi->y < pi->poc.ty1)) {
#line 501
        goto while_break___1;
      }
#line 502
      pi->x = pi->poc.tx0;
      {
#line 502
      while (1) {
        while_continue___6: /* CIL Label */ ;

#line 502
        if (! (pi->x < pi->poc.tx1)) {
#line 502
          goto while_break___2;
        }
#line 503
        pi->resno = pi->poc.resno0;
        {
#line 503
        while (1) {
          while_continue___7: /* CIL Label */ ;
          while_continue___3: ;
#line 503
          if (! (pi->resno < __cil_tmp13)) {
#line 503
            goto while_break___3;
          }
          {
#line 509
          res = comp->resolutions + pi->resno;
#line 510
          levelno = (comp->numresolutions - 1U) - pi->resno;
#line 511
          trx0 = opj_int_ceildiv(pi->tx0, (OPJ_INT32 )(comp->dx << levelno));
#line 512
          try0 = opj_int_ceildiv(pi->ty0, (OPJ_INT32 )(comp->dy << levelno));
#line 513
          trx1 = opj_int_ceildiv(pi->tx1, (OPJ_INT32 )(comp->dx << levelno));
#line 514
          try1 = opj_int_ceildiv(pi->ty1, (OPJ_INT32 )(comp->dy << levelno));
#line 515
          rpx = res->pdx + levelno;
#line 516
          rpy = res->pdy + levelno;
          }
#line 517
          if (! ((unsigned int )pi->y % (comp->dy << rpy) == 0U)) {
#line 517
            if (pi->y == pi->ty0) {
#line 517
              if (! ((try0 << levelno) % (1 << rpy))) {
#line 518
                goto while_continue___3;
              }
            } else {
#line 518
              goto while_continue___3;
            }
          }
#line 520
          if (! ((unsigned int )pi->x % (comp->dx << rpx) == 0U)) {
#line 520
            if (pi->x == pi->tx0) {
#line 520
              if (! ((trx0 << levelno) % (1 << rpx))) {
#line 521
                goto while_continue___3;
              }
            } else {
#line 521
              goto while_continue___3;
            }
          }
#line 524
          if (res->pw == 0U) {
#line 524
            goto while_continue___3;
          } else
#line 524
          if (res->ph == 0U) {
#line 524
            goto while_continue___3;
          }
#line 526
          if (trx0 == trx1) {
#line 526
            goto while_continue___3;
          } else
#line 526
          if (try0 == try1) {
#line 526
            goto while_continue___3;
          }
          {
#line 528
          __cil_tmp29 = opj_int_floordivpow2(trx0, (OPJ_INT32 )res->pdx);
#line 528
          __cil_tmp27 = opj_int_ceildiv(pi->x, (OPJ_INT32 )(comp->dx << levelno));
#line 528
          __cil_tmp28 = opj_int_floordivpow2(__cil_tmp27, (OPJ_INT32 )res->pdx);
#line 528
          prci = __cil_tmp28 - __cil_tmp29;
#line 530
          __cil_tmp32 = opj_int_floordivpow2(try0, (OPJ_INT32 )res->pdy);
#line 530
          __cil_tmp30 = opj_int_ceildiv(pi->y, (OPJ_INT32 )(comp->dy << levelno));
#line 530
          __cil_tmp31 = opj_int_floordivpow2(__cil_tmp30, (OPJ_INT32 )res->pdy);
#line 530
          prcj = __cil_tmp31 - __cil_tmp32;
#line 532
          pi->precno = (unsigned int )prci + (unsigned int )prcj * res->pw;
#line 533
          pi->layno = pi->poc.layno0;
          }
          {
#line 533
          while (1) {
            while_continue___8: /* CIL Label */ ;

#line 533
            if (! (pi->layno < pi->poc.layno1)) {
#line 533
              goto while_break___4;
            }
#line 534
            index___7 = ((pi->layno * pi->step_l + pi->resno * pi->step_r) + pi->compno * pi->step_c) + pi->precno * pi->step_p;
#line 535
            if (! *(pi->include + index___7)) {
#line 536
              *(pi->include + index___7) = (OPJ_INT16 )1;
#line 537
              return (1);
            }
            LABEL_SKIP: 
#line 533
            (pi->layno) ++;
          }
          while_break___10: /* CIL Label */ ;
          }
          while_break___4: 
#line 503
          (pi->resno) ++;
        }
        while_break___9: /* CIL Label */ ;
        }
        while_break___3: 
#line 502
        pi->x = (OPJ_INT32 )((OPJ_UINT32 )pi->x + (pi->dx - (unsigned int )pi->x % pi->dx));
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___2: 
#line 501
      pi->y = (OPJ_INT32 )((OPJ_UINT32 )pi->y + (pi->dy - (unsigned int )pi->y % pi->dy));
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: 
#line 482
    (pi->compno) ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: ;
#line 546
  return (0);
}
}
#line 549 "/root/patron/new_22/src/lib/openjp2/pi.c"
void opj_get_encoding_parameters(opj_image_t *p_image , opj_cp_t *p_cp , OPJ_UINT32 p_tileno ,
                                 OPJ_INT32 *p_tx0 , OPJ_INT32 *p_tx1 , OPJ_INT32 *p_ty0 ,
                                 OPJ_INT32 *p_ty1 , OPJ_UINT32 *p_dx_min , OPJ_UINT32 *p_dy_min ,
                                 OPJ_UINT32 *p_max_prec , OPJ_UINT32 *p_max_res ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;
  opj_image_comp_t *l_img_comp ;
  OPJ_UINT32 p ;
  OPJ_UINT32 q ;
  OPJ_UINT32 l_level_no ;
  OPJ_INT32 l_rx0 ;
  OPJ_INT32 l_ry0 ;
  OPJ_INT32 l_rx1 ;
  OPJ_INT32 l_ry1 ;
  OPJ_INT32 l_px0 ;
  OPJ_INT32 l_py0 ;
  OPJ_INT32 l_px1 ;
  OPJ_INT32 py1 ;
  OPJ_UINT32 l_pdx ;
  OPJ_UINT32 l_pdy ;
  OPJ_UINT32 l_pw ;
  OPJ_UINT32 l_ph ;
  OPJ_UINT32 l_product ;
  OPJ_INT32 l_tcx0 ;
  OPJ_INT32 l_tcy0 ;
  OPJ_INT32 l_tcx1 ;
  OPJ_INT32 l_tcy1 ;
  OPJ_UINT32 l_dx ;
  OPJ_UINT32 l_dy ;
  OPJ_INT32 __cil_tmp56 ;
  OPJ_INT32 __cil_tmp57 ;
  OPJ_INT32 __cil_tmp58 ;
  OPJ_INT32 __cil_tmp59 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 564
  l_tcp = (opj_tcp_t *)0;
#line 565
  l_tccp = (opj_tccp_t *)0;
#line 566
  l_img_comp = (opj_image_comp_t *)0;
#line 577
  l_tcp = p_cp->tcps + p_tileno;
#line 578
  l_img_comp = p_image->comps;
#line 579
  l_tccp = l_tcp->tccps;
#line 582
  p = p_tileno % p_cp->tw;
#line 583
  q = p_tileno / p_cp->tw;
#line 586
  *p_tx0 = opj_int_max((OPJ_INT32 )(p_cp->tx0 + p * p_cp->tdx), (OPJ_INT32 )p_image->x0);
#line 587
  *p_tx1 = opj_int_min((OPJ_INT32 )(p_cp->tx0 + (p + 1U) * p_cp->tdx), (OPJ_INT32 )p_image->x1);
#line 588
  *p_ty0 = opj_int_max((OPJ_INT32 )(p_cp->ty0 + q * p_cp->tdy), (OPJ_INT32 )p_image->y0);
#line 589
  *p_ty1 = opj_int_min((OPJ_INT32 )(p_cp->ty0 + (q + 1U) * p_cp->tdy), (OPJ_INT32 )p_image->y1);
#line 592
  *p_max_prec = (OPJ_UINT32 )0;
#line 593
  *p_max_res = (OPJ_UINT32 )0;
#line 596
  *p_dx_min = (OPJ_UINT32 )2147483647;
#line 597
  *p_dy_min = (OPJ_UINT32 )2147483647;
#line 599
  compno = (OPJ_UINT32 )0;
  }
  {
#line 599
  while (1) {
    while_continue: /* CIL Label */ ;

#line 599
    if (! (compno < p_image->numcomps)) {
#line 599
      goto while_break;
    }
    {
#line 609
    l_tcx0 = opj_int_ceildiv(*p_tx0, (OPJ_INT32 )l_img_comp->dx);
#line 610
    l_tcy0 = opj_int_ceildiv(*p_ty0, (OPJ_INT32 )l_img_comp->dy);
#line 611
    l_tcx1 = opj_int_ceildiv(*p_tx1, (OPJ_INT32 )l_img_comp->dx);
#line 612
    l_tcy1 = opj_int_ceildiv(*p_ty1, (OPJ_INT32 )l_img_comp->dy);
    }
#line 614
    if (l_tccp->numresolutions > *p_max_res) {
#line 615
      *p_max_res = l_tccp->numresolutions;
    }
#line 619
    resno = (OPJ_UINT32 )0;
    {
#line 619
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 619
      if (! (resno < l_tccp->numresolutions)) {
#line 619
        goto while_break___0;
      }
      {
#line 623
      l_pdx = l_tccp->prcw[resno];
#line 624
      l_pdy = l_tccp->prch[resno];
#line 626
      l_dx = l_img_comp->dx * (unsigned int )(1 << (((l_pdx + l_tccp->numresolutions) - 1U) - resno));
#line 627
      l_dy = l_img_comp->dy * (unsigned int )(1 << (((l_pdy + l_tccp->numresolutions) - 1U) - resno));
#line 630
      *p_dx_min = opj_uint_min(*p_dx_min, l_dx);
#line 631
      *p_dy_min = opj_uint_min(*p_dy_min, l_dy);
#line 634
      l_level_no = (l_tccp->numresolutions - 1U) - resno;
#line 636
      l_rx0 = opj_int_ceildivpow2(l_tcx0, (OPJ_INT32 )l_level_no);
#line 637
      l_ry0 = opj_int_ceildivpow2(l_tcy0, (OPJ_INT32 )l_level_no);
#line 638
      l_rx1 = opj_int_ceildivpow2(l_tcx1, (OPJ_INT32 )l_level_no);
#line 639
      l_ry1 = opj_int_ceildivpow2(l_tcy1, (OPJ_INT32 )l_level_no);
#line 641
      __cil_tmp56 = opj_int_floordivpow2(l_rx0, (OPJ_INT32 )l_pdx);
#line 641
      l_px0 = __cil_tmp56 << l_pdx;
#line 642
      __cil_tmp57 = opj_int_floordivpow2(l_ry0, (OPJ_INT32 )l_pdy);
#line 642
      l_py0 = __cil_tmp57 << l_pdy;
#line 643
      __cil_tmp58 = opj_int_ceildivpow2(l_rx1, (OPJ_INT32 )l_pdx);
#line 643
      l_px1 = __cil_tmp58 << l_pdx;
#line 645
      __cil_tmp59 = opj_int_ceildivpow2(l_ry1, (OPJ_INT32 )l_pdy);
#line 645
      py1 = __cil_tmp59 << l_pdy;
      }
#line 647
      if (l_rx0 == l_rx1) {
#line 647
        tmp___2 = 0;
      } else {
#line 647
        tmp___2 = (l_px1 - l_px0) >> l_pdx;
      }
#line 647
      l_pw = (OPJ_UINT32 )tmp___2;
#line 648
      if (l_ry0 == l_ry1) {
#line 648
        tmp___3 = 0;
      } else {
#line 648
        tmp___3 = (py1 - l_py0) >> l_pdy;
      }
#line 648
      l_ph = (OPJ_UINT32 )tmp___3;
#line 650
      l_product = l_pw * l_ph;
#line 653
      if (l_product > *p_max_prec) {
#line 654
        *p_max_prec = l_product;
      }
#line 619
      resno ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 657
    l_img_comp ++;
#line 658
    l_tccp ++;
#line 599
    compno ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 603
  return;
}
}
#line 663 "/root/patron/new_22/src/lib/openjp2/pi.c"
void opj_get_all_encoding_parameters(opj_image_t *p_image , opj_cp_t *p_cp , OPJ_UINT32 tileno ,
                                     OPJ_INT32 *p_tx0 , OPJ_INT32 *p_tx1 , OPJ_INT32 *p_ty0 ,
                                     OPJ_INT32 *p_ty1 , OPJ_UINT32 *p_dx_min , OPJ_UINT32 *p_dy_min ,
                                     OPJ_UINT32 *p_max_prec , OPJ_UINT32 *p_max_res ,
                                     OPJ_UINT32 **p_resolutions ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  opj_tcp_t *tcp ;
  opj_tccp_t *l_tccp ;
  opj_image_comp_t *l_img_comp ;
  OPJ_UINT32 *lResolutionPtr ;
  OPJ_UINT32 p ;
  OPJ_UINT32 q ;
  OPJ_UINT32 l_level_no ;
  OPJ_INT32 l_rx0 ;
  OPJ_INT32 l_ry0 ;
  OPJ_INT32 l_rx1 ;
  OPJ_INT32 l_ry1 ;
  OPJ_INT32 l_px0 ;
  OPJ_INT32 l_py0 ;
  OPJ_INT32 l_px1 ;
  OPJ_INT32 py1 ;
  OPJ_UINT32 l_product ;
  OPJ_INT32 l_tcx0 ;
  OPJ_INT32 l_tcy0 ;
  OPJ_INT32 l_tcx1 ;
  OPJ_INT32 l_tcy1 ;
  OPJ_UINT32 l_pdx ;
  OPJ_UINT32 l_pdy ;
  OPJ_UINT32 l_pw ;
  OPJ_UINT32 l_ph ;
  OPJ_UINT32 l_dx ;
  OPJ_UINT32 l_dy ;
  OPJ_UINT32 *__cil_tmp52 ;
  OPJ_UINT32 *__cil_tmp53 ;
  OPJ_INT32 __cil_tmp54 ;
  OPJ_INT32 __cil_tmp55 ;
  OPJ_INT32 __cil_tmp60 ;
  OPJ_INT32 __cil_tmp61 ;
  OPJ_INT32 __cil_tmp62 ;
  OPJ_INT32 __cil_tmp63 ;
  int tmp___2 ;
  int tmp___3 ;
  OPJ_UINT32 *__cil_tmp66 ;
  OPJ_UINT32 *__cil_tmp67 ;

  {
  {
#line 680
  tcp = (opj_tcp_t *)0;
#line 681
  l_tccp = (opj_tccp_t *)0;
#line 682
  l_img_comp = (opj_image_comp_t *)0;
#line 696
  tcp = p_cp->tcps + tileno;
#line 697
  l_tccp = tcp->tccps;
#line 698
  l_img_comp = p_image->comps;
#line 701
  p = tileno % p_cp->tw;
#line 702
  q = tileno / p_cp->tw;
#line 705
  *p_tx0 = opj_int_max((OPJ_INT32 )(p_cp->tx0 + p * p_cp->tdx), (OPJ_INT32 )p_image->x0);
#line 706
  *p_tx1 = opj_int_min((OPJ_INT32 )(p_cp->tx0 + (p + 1U) * p_cp->tdx), (OPJ_INT32 )p_image->x1);
#line 707
  *p_ty0 = opj_int_max((OPJ_INT32 )(p_cp->ty0 + q * p_cp->tdy), (OPJ_INT32 )p_image->y0);
#line 708
  *p_ty1 = opj_int_min((OPJ_INT32 )(p_cp->ty0 + (q + 1U) * p_cp->tdy), (OPJ_INT32 )p_image->y1);
#line 711
  *p_max_prec = (OPJ_UINT32 )0;
#line 712
  *p_max_res = (OPJ_UINT32 )0;
#line 715
  *p_dx_min = (OPJ_UINT32 )2147483647;
#line 716
  *p_dy_min = (OPJ_UINT32 )2147483647;
#line 718
  compno = (OPJ_UINT32 )0;
  }
  {
#line 718
  while (1) {
    while_continue: /* CIL Label */ ;

#line 718
    if (! (compno < p_image->numcomps)) {
#line 718
      goto while_break;
    }
    {
#line 727
    lResolutionPtr = *(p_resolutions + compno);
#line 729
    l_tcx0 = opj_int_ceildiv(*p_tx0, (OPJ_INT32 )l_img_comp->dx);
#line 730
    l_tcy0 = opj_int_ceildiv(*p_ty0, (OPJ_INT32 )l_img_comp->dy);
#line 731
    l_tcx1 = opj_int_ceildiv(*p_tx1, (OPJ_INT32 )l_img_comp->dx);
#line 732
    l_tcy1 = opj_int_ceildiv(*p_ty1, (OPJ_INT32 )l_img_comp->dy);
    }
#line 734
    if (l_tccp->numresolutions > *p_max_res) {
#line 735
      *p_max_res = l_tccp->numresolutions;
    }
#line 739
    l_level_no = l_tccp->numresolutions - 1U;
#line 740
    resno = (OPJ_UINT32 )0;
    {
#line 740
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 740
      if (! (resno < l_tccp->numresolutions)) {
#line 740
        goto while_break___0;
      }
      {
#line 744
      l_pdx = l_tccp->prcw[resno];
#line 745
      l_pdy = l_tccp->prch[resno];
#line 746
      __cil_tmp52 = lResolutionPtr;
#line 746
      lResolutionPtr ++;
#line 746
      *__cil_tmp52 = l_pdx;
#line 747
      __cil_tmp53 = lResolutionPtr;
#line 747
      lResolutionPtr ++;
#line 747
      *__cil_tmp53 = l_pdy;
#line 748
      l_dx = l_img_comp->dx * (unsigned int )(1 << (l_pdx + l_level_no));
#line 749
      l_dy = l_img_comp->dy * (unsigned int )(1 << (l_pdy + l_level_no));
#line 751
      __cil_tmp54 = opj_int_min((OPJ_INT32 )*p_dx_min, (OPJ_INT32 )l_dx);
#line 751
      *p_dx_min = (OPJ_UINT32 )__cil_tmp54;
#line 752
      __cil_tmp55 = opj_int_min((OPJ_INT32 )*p_dy_min, (OPJ_INT32 )l_dy);
#line 752
      *p_dy_min = (OPJ_UINT32 )__cil_tmp55;
#line 755
      l_rx0 = opj_int_ceildivpow2(l_tcx0, (OPJ_INT32 )l_level_no);
#line 756
      l_ry0 = opj_int_ceildivpow2(l_tcy0, (OPJ_INT32 )l_level_no);
#line 757
      l_rx1 = opj_int_ceildivpow2(l_tcx1, (OPJ_INT32 )l_level_no);
#line 758
      l_ry1 = opj_int_ceildivpow2(l_tcy1, (OPJ_INT32 )l_level_no);
#line 759
      __cil_tmp60 = opj_int_floordivpow2(l_rx0, (OPJ_INT32 )l_pdx);
#line 759
      l_px0 = __cil_tmp60 << l_pdx;
#line 760
      __cil_tmp61 = opj_int_floordivpow2(l_ry0, (OPJ_INT32 )l_pdy);
#line 760
      l_py0 = __cil_tmp61 << l_pdy;
#line 761
      __cil_tmp62 = opj_int_ceildivpow2(l_rx1, (OPJ_INT32 )l_pdx);
#line 761
      l_px1 = __cil_tmp62 << l_pdx;
#line 762
      __cil_tmp63 = opj_int_ceildivpow2(l_ry1, (OPJ_INT32 )l_pdy);
#line 762
      py1 = __cil_tmp63 << l_pdy;
      }
#line 763
      if (l_rx0 == l_rx1) {
#line 763
        tmp___2 = 0;
      } else {
#line 763
        tmp___2 = (l_px1 - l_px0) >> l_pdx;
      }
#line 763
      l_pw = (OPJ_UINT32 )tmp___2;
#line 764
      if (l_ry0 == l_ry1) {
#line 764
        tmp___3 = 0;
      } else {
#line 764
        tmp___3 = (py1 - l_py0) >> l_pdy;
      }
#line 764
      l_ph = (OPJ_UINT32 )tmp___3;
#line 765
      __cil_tmp66 = lResolutionPtr;
#line 765
      lResolutionPtr ++;
#line 765
      *__cil_tmp66 = l_pw;
#line 766
      __cil_tmp67 = lResolutionPtr;
#line 766
      lResolutionPtr ++;
#line 766
      *__cil_tmp67 = l_ph;
#line 767
      l_product = l_pw * l_ph;
#line 770
      if (l_product > *p_max_prec) {
#line 771
        *p_max_prec = l_product;
      }
#line 774
      l_level_no --;
#line 740
      resno ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 776
    l_tccp ++;
#line 777
    l_img_comp ++;
#line 718
    compno ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 722
  return;
}
}
#line 781 "/root/patron/new_22/src/lib/openjp2/pi.c"
opj_pi_iterator_t *opj_pi_create(opj_image_t *image , opj_cp_t *cp , OPJ_UINT32 tileno ) 
{ 
  OPJ_UINT32 pino ;
  OPJ_UINT32 compno ;
  OPJ_UINT32 l_poc_bound ;
  opj_pi_iterator_t *l_pi ;
  opj_tcp_t *tcp ;
  opj_tccp_t *tccp ;
  opj_pi_iterator_t *l_current_pi ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  opj_pi_comp_t *comp ;
  void *__cil_tmp17 ;

  {
  {
#line 791
  l_pi = (opj_pi_iterator_t *)0;
#line 792
  tcp = (opj_tcp_t *)0;
#line 793
  tccp = (opj_tccp_t *)0;
#line 796
  l_current_pi = (opj_pi_iterator_t *)0;
#line 804
  tcp = cp->tcps + tileno;
#line 805
  l_poc_bound = tcp->numpocs + 1U;
#line 808
  __cil_tmp14 = calloc((unsigned long )l_poc_bound, sizeof(opj_pi_iterator_t ));
#line 808
  l_pi = (opj_pi_iterator_t *)__cil_tmp14;
  }
#line 809
  if (! l_pi) {
#line 810
    return ((opj_pi_iterator_t *)((void *)0));
  }
  {
#line 812
  memset((void *)l_pi, 0, (unsigned long )l_poc_bound * sizeof(opj_pi_iterator_t ));
#line 814
  l_current_pi = l_pi;
#line 815
  pino = (OPJ_UINT32 )0;
  }
  {
#line 815
  while (1) {
    while_continue: /* CIL Label */ ;

#line 815
    if (! (pino < l_poc_bound)) {
#line 815
      goto while_break;
    }
    {
#line 817
    __cil_tmp15 = calloc((unsigned long )image->numcomps, sizeof(opj_pi_comp_t ));
#line 817
    l_current_pi->comps = (opj_pi_comp_t *)__cil_tmp15;
    }
#line 818
    if (! l_current_pi->comps) {
      {
#line 819
      opj_pi_destroy(l_pi, l_poc_bound);
      }
#line 820
      return ((opj_pi_iterator_t *)((void *)0));
    }
    {
#line 823
    l_current_pi->numcomps = image->numcomps;
#line 824
    memset((void *)l_current_pi->comps, 0, (unsigned long )image->numcomps * sizeof(opj_pi_comp_t ));
#line 826
    compno = (OPJ_UINT32 )0;
    }
    {
#line 826
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 826
      if (! (compno < image->numcomps)) {
#line 826
        goto while_break___0;
      }
      {
#line 827
      comp = l_current_pi->comps + compno;
#line 829
      tccp = tcp->tccps + compno;
#line 831
      __cil_tmp17 = malloc((unsigned long )tccp->numresolutions * sizeof(opj_pi_resolution_t ));
#line 831
      comp->resolutions = (opj_pi_resolution_t *)__cil_tmp17;
      }
#line 832
      if (! comp->resolutions) {
        {
#line 833
        opj_pi_destroy(l_pi, l_poc_bound);
        }
#line 834
        return ((opj_pi_iterator_t *)0);
      }
      {
#line 837
      comp->numresolutions = tccp->numresolutions;
#line 838
      memset((void *)comp->resolutions, 0, (unsigned long )tccp->numresolutions * sizeof(opj_pi_resolution_t ));
#line 826
      compno ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 840
    l_current_pi ++;
#line 815
    pino ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 842
  return (l_pi);
}
}
#line 845 "/root/patron/new_22/src/lib/openjp2/pi.c"
void opj_pi_update_encode_poc_and_final(opj_cp_t *p_cp , OPJ_UINT32 p_tileno , OPJ_INT32 p_tx0 ,
                                        OPJ_INT32 p_tx1 , OPJ_INT32 p_ty0 , OPJ_INT32 p_ty1 ,
                                        OPJ_UINT32 p_max_prec , OPJ_UINT32 p_max_res ,
                                        OPJ_UINT32 p_dx_min , OPJ_UINT32 p_dy_min ) 
{ 
  OPJ_UINT32 pino ;
  opj_tcp_t *l_tcp ;
  opj_poc_t *l_current_poc ;
  OPJ_UINT32 l_poc_bound ;
  OPJ_UINT32 tmp___1 ;

  {
#line 859
  l_tcp = (opj_tcp_t *)0;
#line 861
  l_current_poc = (opj_poc_t *)0;
#line 873
  l_tcp = p_cp->tcps + p_tileno;
#line 875
  l_poc_bound = l_tcp->numpocs + 1U;
#line 879
  l_current_poc = l_tcp->pocs;
#line 881
  l_current_poc->compS = l_current_poc->compno0;
#line 882
  l_current_poc->compE = l_current_poc->compno1;
#line 883
  l_current_poc->resS = l_current_poc->resno0;
#line 884
  l_current_poc->resE = l_current_poc->resno1;
#line 885
  l_current_poc->layE = l_current_poc->layno1;
#line 888
  l_current_poc->layS = (OPJ_UINT32 )0;
#line 889
  l_current_poc->prg = l_current_poc->prg1;
#line 890
  l_current_poc->prcS = (OPJ_UINT32 )0;
#line 892
  l_current_poc->prcE = p_max_prec;
#line 893
  l_current_poc->txS = (OPJ_UINT32 )p_tx0;
#line 894
  l_current_poc->txE = (OPJ_UINT32 )p_tx1;
#line 895
  l_current_poc->tyS = (OPJ_UINT32 )p_ty0;
#line 896
  l_current_poc->tyE = (OPJ_UINT32 )p_ty1;
#line 897
  l_current_poc->dx = p_dx_min;
#line 898
  l_current_poc->dy = p_dy_min;
#line 900
  l_current_poc ++;
#line 901
  pino = (OPJ_UINT32 )1;
  {
#line 901
  while (1) {
    while_continue: /* CIL Label */ ;

#line 901
    if (! (pino < l_poc_bound)) {
#line 901
      goto while_break;
    }
#line 902
    l_current_poc->compS = l_current_poc->compno0;
#line 903
    l_current_poc->compE = l_current_poc->compno1;
#line 904
    l_current_poc->resS = l_current_poc->resno0;
#line 905
    l_current_poc->resE = l_current_poc->resno1;
#line 906
    l_current_poc->layE = l_current_poc->layno1;
#line 907
    l_current_poc->prg = l_current_poc->prg1;
#line 908
    l_current_poc->prcS = (OPJ_UINT32 )0;
#line 910
    if (l_current_poc->layE > (l_current_poc - 1)->layE) {
#line 910
      tmp___1 = l_current_poc->layE;
    } else {
#line 910
      tmp___1 = 0U;
    }
#line 910
    l_current_poc->layS = tmp___1;
#line 912
    l_current_poc->prcE = p_max_prec;
#line 913
    l_current_poc->txS = (OPJ_UINT32 )p_tx0;
#line 914
    l_current_poc->txE = (OPJ_UINT32 )p_tx1;
#line 915
    l_current_poc->tyS = (OPJ_UINT32 )p_ty0;
#line 916
    l_current_poc->tyE = (OPJ_UINT32 )p_ty1;
#line 917
    l_current_poc->dx = p_dx_min;
#line 918
    l_current_poc->dy = p_dy_min;
#line 919
    l_current_poc ++;
#line 901
    pino ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 905
  return;
}
}
#line 923 "/root/patron/new_22/src/lib/openjp2/pi.c"
void opj_pi_update_encode_not_poc(opj_cp_t *p_cp , OPJ_UINT32 p_num_comps , OPJ_UINT32 p_tileno ,
                                  OPJ_INT32 p_tx0 , OPJ_INT32 p_tx1 , OPJ_INT32 p_ty0 ,
                                  OPJ_INT32 p_ty1 , OPJ_UINT32 p_max_prec , OPJ_UINT32 p_max_res ,
                                  OPJ_UINT32 p_dx_min , OPJ_UINT32 p_dy_min ) 
{ 
  OPJ_UINT32 pino ;
  opj_tcp_t *l_tcp ;
  opj_poc_t *l_current_poc ;
  OPJ_UINT32 l_poc_bound ;

  {
#line 938
  l_tcp = (opj_tcp_t *)0;
#line 940
  l_current_poc = (opj_poc_t *)0;
#line 949
  l_tcp = p_cp->tcps + p_tileno;
#line 952
  l_poc_bound = l_tcp->numpocs + 1U;
#line 956
  l_current_poc = l_tcp->pocs;
#line 958
  pino = (OPJ_UINT32 )0;
  {
#line 958
  while (1) {
    while_continue: /* CIL Label */ ;

#line 958
    if (! (pino < l_poc_bound)) {
#line 958
      goto while_break;
    }
#line 959
    l_current_poc->compS = (OPJ_UINT32 )0;
#line 960
    l_current_poc->compE = p_num_comps;
#line 961
    l_current_poc->resS = (OPJ_UINT32 )0;
#line 962
    l_current_poc->resE = p_max_res;
#line 963
    l_current_poc->layS = (OPJ_UINT32 )0;
#line 964
    l_current_poc->layE = l_tcp->numlayers;
#line 965
    l_current_poc->prg = l_tcp->prg;
#line 966
    l_current_poc->prcS = (OPJ_UINT32 )0;
#line 967
    l_current_poc->prcE = p_max_prec;
#line 968
    l_current_poc->txS = (OPJ_UINT32 )p_tx0;
#line 969
    l_current_poc->txE = (OPJ_UINT32 )p_tx1;
#line 970
    l_current_poc->tyS = (OPJ_UINT32 )p_ty0;
#line 971
    l_current_poc->tyE = (OPJ_UINT32 )p_ty1;
#line 972
    l_current_poc->dx = p_dx_min;
#line 973
    l_current_poc->dy = p_dy_min;
#line 974
    l_current_poc ++;
#line 958
    pino ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 962
  return;
}
}
#line 978 "/root/patron/new_22/src/lib/openjp2/pi.c"
void opj_pi_update_decode_poc(opj_pi_iterator_t *p_pi , opj_tcp_t *p_tcp , OPJ_UINT32 p_max_precision ,
                              OPJ_UINT32 p_max_res ) 
{ 
  OPJ_UINT32 pino ;
  OPJ_UINT32 l_bound ;
  opj_pi_iterator_t *l_current_pi ;
  opj_poc_t *l_current_poc ;

  {
#line 989
  l_current_pi = (opj_pi_iterator_t *)0;
#line 990
  l_current_poc = (opj_poc_t *)0;
#line 999
  l_bound = p_tcp->numpocs + 1U;
#line 1000
  l_current_pi = p_pi;
#line 1001
  l_current_poc = p_tcp->pocs;
#line 1003
  pino = (OPJ_UINT32 )0;
  {
#line 1003
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1003
    if (! (pino < l_bound)) {
#line 1003
      goto while_break;
    }
#line 1004
    l_current_pi->poc.prg = l_current_poc->prg;
#line 1005
    l_current_pi->first = 1;
#line 1007
    l_current_pi->poc.resno0 = l_current_poc->resno0;
#line 1008
    l_current_pi->poc.compno0 = l_current_poc->compno0;
#line 1009
    l_current_pi->poc.layno0 = (OPJ_UINT32 )0;
#line 1010
    l_current_pi->poc.precno0 = (OPJ_UINT32 )0;
#line 1011
    l_current_pi->poc.resno1 = l_current_poc->resno1;
#line 1012
    l_current_pi->poc.compno1 = l_current_poc->compno1;
#line 1013
    l_current_pi->poc.layno1 = l_current_poc->layno1;
#line 1014
    l_current_pi->poc.precno1 = p_max_precision;
#line 1015
    l_current_pi ++;
#line 1016
    l_current_poc ++;
#line 1003
    pino ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1007
  return;
}
}
#line 1020 "/root/patron/new_22/src/lib/openjp2/pi.c"
void opj_pi_update_decode_not_poc(opj_pi_iterator_t *p_pi , opj_tcp_t *p_tcp , OPJ_UINT32 p_max_precision ,
                                  OPJ_UINT32 p_max_res ) 
{ 
  OPJ_UINT32 pino ;
  OPJ_UINT32 l_bound ;
  opj_pi_iterator_t *l_current_pi ;

  {
#line 1031
  l_current_pi = (opj_pi_iterator_t *)0;
#line 1037
  l_bound = p_tcp->numpocs + 1U;
#line 1038
  l_current_pi = p_pi;
#line 1040
  pino = (OPJ_UINT32 )0;
  {
#line 1040
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1040
    if (! (pino < l_bound)) {
#line 1040
      goto while_break;
    }
#line 1041
    l_current_pi->poc.prg = p_tcp->prg;
#line 1042
    l_current_pi->first = 1;
#line 1043
    l_current_pi->poc.resno0 = (OPJ_UINT32 )0;
#line 1044
    l_current_pi->poc.compno0 = (OPJ_UINT32 )0;
#line 1045
    l_current_pi->poc.layno0 = (OPJ_UINT32 )0;
#line 1046
    l_current_pi->poc.precno0 = (OPJ_UINT32 )0;
#line 1047
    l_current_pi->poc.resno1 = p_max_res;
#line 1048
    l_current_pi->poc.compno1 = l_current_pi->numcomps;
#line 1049
    l_current_pi->poc.layno1 = p_tcp->numlayers;
#line 1050
    l_current_pi->poc.precno1 = p_max_precision;
#line 1051
    l_current_pi ++;
#line 1040
    pino ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1044
  return;
}
}
#line 1057 "/root/patron/new_22/src/lib/openjp2/pi.c"
OPJ_BOOL opj_pi_check_next_level(OPJ_INT32 pos , opj_cp_t *cp , OPJ_UINT32 tileno ,
                                 OPJ_UINT32 pino , OPJ_CHAR *prog ) 
{ 
  OPJ_INT32 i ;
  opj_tcp_t *tcps ;
  opj_poc_t *tcp ;
  OPJ_BOOL __cil_tmp9 ;
  OPJ_BOOL __cil_tmp10 ;
  OPJ_BOOL __cil_tmp11 ;
  OPJ_BOOL __cil_tmp12 ;
  OPJ_BOOL __cil_tmp13 ;
  OPJ_INT32 __cil_tmp14 ;

  {
#line 1064
  tcps = cp->tcps + tileno;
#line 1065
  tcp = & tcps->pocs[pino];
#line 1067
  if (pos >= 0) {
#line 1068
    i = pos;
    {
#line 1068
    while (1) {
      while_continue: /* CIL Label */ ;

#line 1068
      if (! (pos >= 0)) {
#line 1068
        goto while_break;
      }
#line 1070
      if ((int )*(prog + i) == 82) {
#line 1070
        goto case_82;
      }
#line 1081
      if ((int )*(prog + i) == 67) {
#line 1081
        goto case_67;
      }
#line 1092
      if ((int )*(prog + i) == 76) {
#line 1092
        goto case_76;
      }
#line 1103
      if ((int )*(prog + i) == 80) {
#line 1103
        goto case_80;
      }
#line 1105
      if ((int )*(prog + i) == 1) {
#line 1105
        goto case_1;
      }
#line 1116
      goto switch_default;
      case_82: 
#line 1071
      if (tcp->res_t == tcp->resE) {
        {
#line 1072
        __cil_tmp9 = opj_pi_check_next_level(pos - 1, cp, tileno, pino, prog);
        }
#line 1072
        if (__cil_tmp9) {
#line 1073
          return (1);
        } else {
#line 1075
          return (0);
        }
      } else {
#line 1078
        return (1);
      }
#line 1080
      goto switch_break;
      case_67: 
#line 1082
      if (tcp->comp_t == tcp->compE) {
        {
#line 1083
        __cil_tmp10 = opj_pi_check_next_level(pos - 1, cp, tileno, pino, prog);
        }
#line 1083
        if (__cil_tmp10) {
#line 1084
          return (1);
        } else {
#line 1086
          return (0);
        }
      } else {
#line 1089
        return (1);
      }
#line 1091
      goto switch_break;
      case_76: 
#line 1093
      if (tcp->lay_t == tcp->layE) {
        {
#line 1094
        __cil_tmp11 = opj_pi_check_next_level(pos - 1, cp, tileno, pino, prog);
        }
#line 1094
        if (__cil_tmp11) {
#line 1095
          return (1);
        } else {
#line 1097
          return (0);
        }
      } else {
#line 1100
        return (1);
      }
#line 1102
      goto switch_break;
      case_80: 
#line 1105
      if ((int )tcp->prg == 1) {
#line 1105
        goto case_1;
      }
#line 1116
      goto switch_default;
      case_1: 
#line 1106
      if (tcp->prc_t == tcp->prcE) {
        {
#line 1107
        __cil_tmp12 = opj_pi_check_next_level(i - 1, cp, tileno, pino, prog);
        }
#line 1107
        if (__cil_tmp12) {
#line 1108
          return (1);
        } else {
#line 1110
          return (0);
        }
      } else {
#line 1113
        return (1);
      }
#line 1115
      goto switch_break___0;
      switch_default: 
#line 1117
      if (tcp->tx0_t == tcp->txE) {
#line 1119
        if (tcp->ty0_t == tcp->tyE) {
          {
#line 1120
          __cil_tmp13 = opj_pi_check_next_level(i - 1, cp, tileno, pino, prog);
          }
#line 1120
          if (__cil_tmp13) {
#line 1121
            return (1);
          } else {
#line 1123
            return (0);
          }
        } else {
#line 1126
          return (1);
        }
      } else {
#line 1129
        return (1);
      }
#line 1131
      goto switch_break___0;
      switch_break___0: ;
      switch_break: 
#line 1068
      __cil_tmp14 = i;
#line 1068
      i --;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 1136
  return (0);
}
}
#line 1145 "/root/patron/new_22/src/lib/openjp2/pi.c"
opj_pi_iterator_t *opj_pi_create_decode(opj_image_t *p_image , opj_cp_t *p_cp , OPJ_UINT32 p_tile_no ) 
{ 
  OPJ_UINT32 pino ;
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 *l_tmp_data ;
  OPJ_UINT32 **l_tmp_ptr ;
  OPJ_UINT32 l_max_res ;
  OPJ_UINT32 l_max_prec ;
  OPJ_INT32 l_tx0 ;
  OPJ_INT32 l_tx1 ;
  OPJ_INT32 l_ty0 ;
  OPJ_INT32 l_ty1 ;
  OPJ_UINT32 l_dx_min ;
  OPJ_UINT32 l_dy_min ;
  OPJ_UINT32 l_bound ;
  OPJ_UINT32 l_step_p ;
  OPJ_UINT32 l_step_c ;
  OPJ_UINT32 l_step_r ;
  OPJ_UINT32 l_step_l ;
  OPJ_UINT32 l_data_stride ;
  opj_pi_iterator_t *l_pi ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;
  opj_pi_comp_t *l_current_comp ;
  opj_image_comp_t *l_img_comp ;
  opj_pi_iterator_t *l_current_pi ;
  OPJ_UINT32 *l_encoding_value_ptr ;
  void *__cil_tmp33 ;
  void *__cil_tmp34 ;
  void *__cil_tmp36 ;
  opj_pi_resolution_t *l_res ;
  OPJ_UINT32 *__cil_tmp38 ;
  OPJ_UINT32 *__cil_tmp39 ;
  OPJ_UINT32 *__cil_tmp40 ;
  OPJ_UINT32 *__cil_tmp41 ;
  opj_pi_resolution_t *l_res___0 ;
  OPJ_UINT32 *__cil_tmp44 ;
  OPJ_UINT32 *__cil_tmp45 ;
  OPJ_UINT32 *__cil_tmp46 ;
  OPJ_UINT32 *__cil_tmp47 ;

  {
  {
#line 1167
  l_pi = (opj_pi_iterator_t *)0;
#line 1168
  l_tcp = (opj_tcp_t *)0;
#line 1169
  l_tccp = (opj_tccp_t *)0;
#line 1170
  l_current_comp = (opj_pi_comp_t *)0;
#line 1171
  l_img_comp = (opj_image_comp_t *)0;
#line 1172
  l_current_pi = (opj_pi_iterator_t *)0;
#line 1173
  l_encoding_value_ptr = (OPJ_UINT32 *)0;
#line 1181
  l_tcp = p_cp->tcps + p_tile_no;
#line 1182
  l_bound = l_tcp->numpocs + 1U;
#line 1184
  l_data_stride = (OPJ_UINT32 )132;
#line 1185
  __cil_tmp33 = malloc((unsigned long )(l_data_stride * p_image->numcomps) * sizeof(OPJ_UINT32 ));
#line 1185
  l_tmp_data = (OPJ_UINT32 *)__cil_tmp33;
  }
#line 1187
  if (! l_tmp_data) {
#line 1190
    return ((opj_pi_iterator_t *)0);
  }
  {
#line 1192
  __cil_tmp34 = malloc((unsigned long )p_image->numcomps * sizeof(OPJ_UINT32 *));
#line 1192
  l_tmp_ptr = (OPJ_UINT32 **)__cil_tmp34;
  }
#line 1194
  if (! l_tmp_ptr) {
    {
#line 1197
    free((void *)l_tmp_data);
    }
#line 1198
    return ((opj_pi_iterator_t *)0);
  }
  {
#line 1202
  l_pi = opj_pi_create(p_image, p_cp, p_tile_no);
  }
#line 1203
  if (! l_pi) {
    {
#line 1204
    free((void *)l_tmp_data);
#line 1205
    free((void *)l_tmp_ptr);
    }
#line 1206
    return ((opj_pi_iterator_t *)0);
  }
#line 1209
  l_encoding_value_ptr = l_tmp_data;
#line 1212
  compno = (OPJ_UINT32 )0;
  {
#line 1211
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1211
    if (! (compno < p_image->numcomps)) {
#line 1211
      goto while_break;
    }
#line 1214
    *(l_tmp_ptr + compno) = l_encoding_value_ptr;
#line 1215
    l_encoding_value_ptr += l_data_stride;
#line 1212
    compno ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1218
  opj_get_all_encoding_parameters(p_image, p_cp, p_tile_no, & l_tx0, & l_tx1, & l_ty0,
                                  & l_ty1, & l_dx_min, & l_dy_min, & l_max_prec, & l_max_res,
                                  l_tmp_ptr);
#line 1221
  l_step_p = (OPJ_UINT32 )1;
#line 1222
  l_step_c = l_max_prec * l_step_p;
#line 1223
  l_step_r = p_image->numcomps * l_step_c;
#line 1224
  l_step_l = l_max_res * l_step_r;
#line 1227
  l_current_pi = l_pi;
#line 1230
  __cil_tmp36 = calloc((unsigned long )((l_tcp->numlayers + 1U) * l_step_l), sizeof(OPJ_INT16 ));
#line 1230
  l_current_pi->include = (OPJ_INT16 *)__cil_tmp36;
  }
#line 1231
  if (! l_current_pi->include) {
    {
#line 1234
    free((void *)l_tmp_data);
#line 1235
    free((void *)l_tmp_ptr);
#line 1236
    opj_pi_destroy(l_pi, l_bound);
    }
#line 1237
    return ((opj_pi_iterator_t *)0);
  }
  {
#line 1239
  memset((void *)l_current_pi->include, 0, (unsigned long )((l_tcp->numlayers + 1U) * l_step_l) * sizeof(OPJ_INT16 ));
#line 1242
  l_current_comp = l_current_pi->comps;
#line 1243
  l_img_comp = p_image->comps;
#line 1244
  l_tccp = l_tcp->tccps;
#line 1246
  l_current_pi->tx0 = l_tx0;
#line 1247
  l_current_pi->ty0 = l_ty0;
#line 1248
  l_current_pi->tx1 = l_tx1;
#line 1249
  l_current_pi->ty1 = l_ty1;
#line 1254
  l_current_pi->step_p = l_step_p;
#line 1255
  l_current_pi->step_c = l_step_c;
#line 1256
  l_current_pi->step_r = l_step_r;
#line 1257
  l_current_pi->step_l = l_step_l;
#line 1261
  compno = (OPJ_UINT32 )0;
  }
  {
#line 1260
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 1260
    if (! (compno < l_current_pi->numcomps)) {
#line 1260
      goto while_break___0;
    }
#line 1263
    l_res = l_current_comp->resolutions;
#line 1264
    l_encoding_value_ptr = *(l_tmp_ptr + compno);
#line 1266
    l_current_comp->dx = l_img_comp->dx;
#line 1267
    l_current_comp->dy = l_img_comp->dy;
#line 1270
    resno = (OPJ_UINT32 )0;
    {
#line 1269
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 1269
      if (! (resno < l_current_comp->numresolutions)) {
#line 1269
        goto while_break___1;
      }
#line 1272
      __cil_tmp38 = l_encoding_value_ptr;
#line 1272
      l_encoding_value_ptr ++;
#line 1272
      l_res->pdx = *__cil_tmp38;
#line 1273
      __cil_tmp39 = l_encoding_value_ptr;
#line 1273
      l_encoding_value_ptr ++;
#line 1273
      l_res->pdy = *__cil_tmp39;
#line 1274
      __cil_tmp40 = l_encoding_value_ptr;
#line 1274
      l_encoding_value_ptr ++;
#line 1274
      l_res->pw = *__cil_tmp40;
#line 1275
      __cil_tmp41 = l_encoding_value_ptr;
#line 1275
      l_encoding_value_ptr ++;
#line 1275
      l_res->ph = *__cil_tmp41;
#line 1276
      l_res ++;
#line 1270
      resno ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: 
#line 1278
    l_current_comp ++;
#line 1279
    l_img_comp ++;
#line 1280
    l_tccp ++;
#line 1261
    compno ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___0: 
#line 1282
  l_current_pi ++;
#line 1284
  pino = (OPJ_UINT32 )1;
  {
#line 1284
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 1284
    if (! (pino < l_bound)) {
#line 1284
      goto while_break___2;
    }
#line 1286
    l_current_comp = l_current_pi->comps;
#line 1287
    l_img_comp = p_image->comps;
#line 1288
    l_tccp = l_tcp->tccps;
#line 1290
    l_current_pi->tx0 = l_tx0;
#line 1291
    l_current_pi->ty0 = l_ty0;
#line 1292
    l_current_pi->tx1 = l_tx1;
#line 1293
    l_current_pi->ty1 = l_ty1;
#line 1296
    l_current_pi->step_p = l_step_p;
#line 1297
    l_current_pi->step_c = l_step_c;
#line 1298
    l_current_pi->step_r = l_step_r;
#line 1299
    l_current_pi->step_l = l_step_l;
#line 1303
    compno = (OPJ_UINT32 )0;
    {
#line 1302
    while (1) {
      while_continue___3: /* CIL Label */ ;

#line 1302
      if (! (compno < l_current_pi->numcomps)) {
#line 1302
        goto while_break___3;
      }
#line 1305
      l_res___0 = l_current_comp->resolutions;
#line 1306
      l_encoding_value_ptr = *(l_tmp_ptr + compno);
#line 1308
      l_current_comp->dx = l_img_comp->dx;
#line 1309
      l_current_comp->dy = l_img_comp->dy;
#line 1312
      resno = (OPJ_UINT32 )0;
      {
#line 1311
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 1311
        if (! (resno < l_current_comp->numresolutions)) {
#line 1311
          goto while_break___4;
        }
#line 1314
        __cil_tmp44 = l_encoding_value_ptr;
#line 1314
        l_encoding_value_ptr ++;
#line 1314
        l_res___0->pdx = *__cil_tmp44;
#line 1315
        __cil_tmp45 = l_encoding_value_ptr;
#line 1315
        l_encoding_value_ptr ++;
#line 1315
        l_res___0->pdy = *__cil_tmp45;
#line 1316
        __cil_tmp46 = l_encoding_value_ptr;
#line 1316
        l_encoding_value_ptr ++;
#line 1316
        l_res___0->pw = *__cil_tmp46;
#line 1317
        __cil_tmp47 = l_encoding_value_ptr;
#line 1317
        l_encoding_value_ptr ++;
#line 1317
        l_res___0->ph = *__cil_tmp47;
#line 1318
        l_res___0 ++;
#line 1312
        resno ++;
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___4: 
#line 1320
      l_current_comp ++;
#line 1321
      l_img_comp ++;
#line 1322
      l_tccp ++;
#line 1303
      compno ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___3: 
#line 1325
    l_current_pi->include = (l_current_pi - 1)->include;
#line 1326
    l_current_pi ++;
#line 1284
    pino ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___2: 
  {
#line 1328
  free((void *)l_tmp_data);
#line 1329
  l_tmp_data = (OPJ_UINT32 *)0;
#line 1330
  free((void *)l_tmp_ptr);
#line 1331
  l_tmp_ptr = (OPJ_UINT32 **)0;
  }
#line 1332
  if (l_tcp->POC) {
    {
#line 1335
    opj_pi_update_decode_poc(l_pi, l_tcp, l_max_prec, l_max_res);
    }
  } else {
    {
#line 1339
    opj_pi_update_decode_not_poc(l_pi, l_tcp, l_max_prec, l_max_res);
    }
  }
#line 1341
  return (l_pi);
}
}
#line 1346 "/root/patron/new_22/src/lib/openjp2/pi.c"
opj_pi_iterator_t *opj_pi_initialise_encode(opj_image_t *p_image , opj_cp_t *p_cp ,
                                            OPJ_UINT32 p_tile_no , J2K_T2_MODE p_t2_mode ) 
{ 
  OPJ_UINT32 pino ;
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 *l_tmp_data ;
  OPJ_UINT32 **l_tmp_ptr ;
  OPJ_UINT32 l_max_res ;
  OPJ_UINT32 l_max_prec ;
  OPJ_INT32 l_tx0 ;
  OPJ_INT32 l_tx1 ;
  OPJ_INT32 l_ty0 ;
  OPJ_INT32 l_ty1 ;
  OPJ_UINT32 l_dx_min ;
  OPJ_UINT32 l_dy_min ;
  OPJ_UINT32 l_bound ;
  OPJ_UINT32 l_step_p ;
  OPJ_UINT32 l_step_c ;
  OPJ_UINT32 l_step_r ;
  OPJ_UINT32 l_step_l ;
  OPJ_UINT32 l_data_stride ;
  opj_pi_iterator_t *l_pi ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;
  opj_pi_comp_t *l_current_comp ;
  opj_image_comp_t *l_img_comp ;
  opj_pi_iterator_t *l_current_pi ;
  OPJ_UINT32 *l_encoding_value_ptr ;
  void *__cil_tmp34 ;
  void *__cil_tmp35 ;
  void *__cil_tmp37 ;
  opj_pi_resolution_t *l_res ;
  OPJ_UINT32 *__cil_tmp39 ;
  OPJ_UINT32 *__cil_tmp40 ;
  OPJ_UINT32 *__cil_tmp41 ;
  OPJ_UINT32 *__cil_tmp42 ;
  opj_pi_resolution_t *l_res___0 ;
  OPJ_UINT32 *__cil_tmp45 ;
  OPJ_UINT32 *__cil_tmp46 ;
  OPJ_UINT32 *__cil_tmp47 ;
  OPJ_UINT32 *__cil_tmp48 ;

  {
  {
#line 1369
  l_pi = (opj_pi_iterator_t *)0;
#line 1370
  l_tcp = (opj_tcp_t *)0;
#line 1371
  l_tccp = (opj_tccp_t *)0;
#line 1372
  l_current_comp = (opj_pi_comp_t *)0;
#line 1373
  l_img_comp = (opj_image_comp_t *)0;
#line 1374
  l_current_pi = (opj_pi_iterator_t *)0;
#line 1375
  l_encoding_value_ptr = (OPJ_UINT32 *)0;
#line 1383
  l_tcp = p_cp->tcps + p_tile_no;
#line 1384
  l_bound = l_tcp->numpocs + 1U;
#line 1386
  l_data_stride = (OPJ_UINT32 )132;
#line 1387
  __cil_tmp34 = malloc((unsigned long )(l_data_stride * p_image->numcomps) * sizeof(OPJ_UINT32 ));
#line 1387
  l_tmp_data = (OPJ_UINT32 *)__cil_tmp34;
  }
#line 1389
  if (! l_tmp_data) {
#line 1390
    return ((opj_pi_iterator_t *)0);
  }
  {
#line 1393
  __cil_tmp35 = malloc((unsigned long )p_image->numcomps * sizeof(OPJ_UINT32 *));
#line 1393
  l_tmp_ptr = (OPJ_UINT32 **)__cil_tmp35;
  }
#line 1395
  if (! l_tmp_ptr) {
    {
#line 1396
    free((void *)l_tmp_data);
    }
#line 1397
    return ((opj_pi_iterator_t *)0);
  }
  {
#line 1401
  l_pi = opj_pi_create(p_image, p_cp, p_tile_no);
  }
#line 1402
  if (! l_pi) {
    {
#line 1403
    free((void *)l_tmp_data);
#line 1404
    free((void *)l_tmp_ptr);
    }
#line 1405
    return ((opj_pi_iterator_t *)0);
  }
#line 1408
  l_encoding_value_ptr = l_tmp_data;
#line 1410
  compno = (OPJ_UINT32 )0;
  {
#line 1410
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1410
    if (! (compno < p_image->numcomps)) {
#line 1410
      goto while_break;
    }
#line 1411
    *(l_tmp_ptr + compno) = l_encoding_value_ptr;
#line 1412
    l_encoding_value_ptr += l_data_stride;
#line 1410
    compno ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1416
  opj_get_all_encoding_parameters(p_image, p_cp, p_tile_no, & l_tx0, & l_tx1, & l_ty0,
                                  & l_ty1, & l_dx_min, & l_dy_min, & l_max_prec, & l_max_res,
                                  l_tmp_ptr);
#line 1419
  l_step_p = (OPJ_UINT32 )1;
#line 1420
  l_step_c = l_max_prec * l_step_p;
#line 1421
  l_step_r = p_image->numcomps * l_step_c;
#line 1422
  l_step_l = l_max_res * l_step_r;
#line 1425
  l_pi->tp_on = (OPJ_BYTE )p_cp->m_specific_param.m_enc.m_tp_on;
#line 1426
  l_current_pi = l_pi;
#line 1429
  __cil_tmp37 = calloc((unsigned long )(l_tcp->numlayers * l_step_l), sizeof(OPJ_INT16 ));
#line 1429
  l_current_pi->include = (OPJ_INT16 *)__cil_tmp37;
  }
#line 1430
  if (! l_current_pi->include) {
    {
#line 1431
    free((void *)l_tmp_data);
#line 1432
    free((void *)l_tmp_ptr);
#line 1433
    opj_pi_destroy(l_pi, l_bound);
    }
#line 1434
    return ((opj_pi_iterator_t *)0);
  }
  {
#line 1436
  memset((void *)l_current_pi->include, 0, (unsigned long )(l_tcp->numlayers * l_step_l) * sizeof(OPJ_INT16 ));
#line 1439
  l_current_comp = l_current_pi->comps;
#line 1440
  l_img_comp = p_image->comps;
#line 1441
  l_tccp = l_tcp->tccps;
#line 1442
  l_current_pi->tx0 = l_tx0;
#line 1443
  l_current_pi->ty0 = l_ty0;
#line 1444
  l_current_pi->tx1 = l_tx1;
#line 1445
  l_current_pi->ty1 = l_ty1;
#line 1446
  l_current_pi->dx = l_dx_min;
#line 1447
  l_current_pi->dy = l_dy_min;
#line 1448
  l_current_pi->step_p = l_step_p;
#line 1449
  l_current_pi->step_c = l_step_c;
#line 1450
  l_current_pi->step_r = l_step_r;
#line 1451
  l_current_pi->step_l = l_step_l;
#line 1454
  compno = (OPJ_UINT32 )0;
  }
  {
#line 1454
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 1454
    if (! (compno < l_current_pi->numcomps)) {
#line 1454
      goto while_break___0;
    }
#line 1455
    l_res = l_current_comp->resolutions;
#line 1456
    l_encoding_value_ptr = *(l_tmp_ptr + compno);
#line 1458
    l_current_comp->dx = l_img_comp->dx;
#line 1459
    l_current_comp->dy = l_img_comp->dy;
#line 1462
    resno = (OPJ_UINT32 )0;
    {
#line 1462
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 1462
      if (! (resno < l_current_comp->numresolutions)) {
#line 1462
        goto while_break___1;
      }
#line 1463
      __cil_tmp39 = l_encoding_value_ptr;
#line 1463
      l_encoding_value_ptr ++;
#line 1463
      l_res->pdx = *__cil_tmp39;
#line 1464
      __cil_tmp40 = l_encoding_value_ptr;
#line 1464
      l_encoding_value_ptr ++;
#line 1464
      l_res->pdy = *__cil_tmp40;
#line 1465
      __cil_tmp41 = l_encoding_value_ptr;
#line 1465
      l_encoding_value_ptr ++;
#line 1465
      l_res->pw = *__cil_tmp41;
#line 1466
      __cil_tmp42 = l_encoding_value_ptr;
#line 1466
      l_encoding_value_ptr ++;
#line 1466
      l_res->ph = *__cil_tmp42;
#line 1467
      l_res ++;
#line 1462
      resno ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: 
#line 1470
    l_current_comp ++;
#line 1471
    l_img_comp ++;
#line 1472
    l_tccp ++;
#line 1454
    compno ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___0: 
#line 1474
  l_current_pi ++;
#line 1476
  pino = (OPJ_UINT32 )1;
  {
#line 1476
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 1476
    if (! (pino < l_bound)) {
#line 1476
      goto while_break___2;
    }
#line 1477
    l_current_comp = l_current_pi->comps;
#line 1478
    l_img_comp = p_image->comps;
#line 1479
    l_tccp = l_tcp->tccps;
#line 1481
    l_current_pi->tx0 = l_tx0;
#line 1482
    l_current_pi->ty0 = l_ty0;
#line 1483
    l_current_pi->tx1 = l_tx1;
#line 1484
    l_current_pi->ty1 = l_ty1;
#line 1485
    l_current_pi->dx = l_dx_min;
#line 1486
    l_current_pi->dy = l_dy_min;
#line 1487
    l_current_pi->step_p = l_step_p;
#line 1488
    l_current_pi->step_c = l_step_c;
#line 1489
    l_current_pi->step_r = l_step_r;
#line 1490
    l_current_pi->step_l = l_step_l;
#line 1493
    compno = (OPJ_UINT32 )0;
    {
#line 1493
    while (1) {
      while_continue___3: /* CIL Label */ ;

#line 1493
      if (! (compno < l_current_pi->numcomps)) {
#line 1493
        goto while_break___3;
      }
#line 1494
      l_res___0 = l_current_comp->resolutions;
#line 1495
      l_encoding_value_ptr = *(l_tmp_ptr + compno);
#line 1497
      l_current_comp->dx = l_img_comp->dx;
#line 1498
      l_current_comp->dy = l_img_comp->dy;
#line 1500
      resno = (OPJ_UINT32 )0;
      {
#line 1500
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 1500
        if (! (resno < l_current_comp->numresolutions)) {
#line 1500
          goto while_break___4;
        }
#line 1501
        __cil_tmp45 = l_encoding_value_ptr;
#line 1501
        l_encoding_value_ptr ++;
#line 1501
        l_res___0->pdx = *__cil_tmp45;
#line 1502
        __cil_tmp46 = l_encoding_value_ptr;
#line 1502
        l_encoding_value_ptr ++;
#line 1502
        l_res___0->pdy = *__cil_tmp46;
#line 1503
        __cil_tmp47 = l_encoding_value_ptr;
#line 1503
        l_encoding_value_ptr ++;
#line 1503
        l_res___0->pw = *__cil_tmp47;
#line 1504
        __cil_tmp48 = l_encoding_value_ptr;
#line 1504
        l_encoding_value_ptr ++;
#line 1504
        l_res___0->ph = *__cil_tmp48;
#line 1505
        l_res___0 ++;
#line 1500
        resno ++;
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___4: 
#line 1507
      l_current_comp ++;
#line 1508
      l_img_comp ++;
#line 1509
      l_tccp ++;
#line 1493
      compno ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___3: 
#line 1513
    l_current_pi->include = (l_current_pi - 1)->include;
#line 1514
    l_current_pi ++;
#line 1476
    pino ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___2: 
  {
#line 1517
  free((void *)l_tmp_data);
#line 1518
  l_tmp_data = (OPJ_UINT32 *)0;
#line 1519
  free((void *)l_tmp_ptr);
#line 1520
  l_tmp_ptr = (OPJ_UINT32 **)0;
  }
#line 1522
  if ((int )l_tcp->POC) {
#line 1522
    if ((unsigned int )p_cp->m_specific_param.m_enc.m_cinema) {
      {
#line 1523
      opj_pi_update_encode_poc_and_final(p_cp, p_tile_no, l_tx0, l_tx1, l_ty0, l_ty1,
                                         l_max_prec, l_max_res, l_dx_min, l_dy_min);
      }
    } else
#line 1522
    if ((unsigned int )p_t2_mode == 1U) {
      {
#line 1523
      opj_pi_update_encode_poc_and_final(p_cp, p_tile_no, l_tx0, l_tx1, l_ty0, l_ty1,
                                         l_max_prec, l_max_res, l_dx_min, l_dy_min);
      }
    } else {
      {
#line 1526
      opj_pi_update_encode_not_poc(p_cp, p_image->numcomps, p_tile_no, l_tx0, l_tx1,
                                   l_ty0, l_ty1, l_max_prec, l_max_res, l_dx_min,
                                   l_dy_min);
      }
    }
  } else {
    {
#line 1526
    opj_pi_update_encode_not_poc(p_cp, p_image->numcomps, p_tile_no, l_tx0, l_tx1,
                                 l_ty0, l_ty1, l_max_prec, l_max_res, l_dx_min, l_dy_min);
    }
  }
#line 1529
  return (l_pi);
}
}
#line 1532 "/root/patron/new_22/src/lib/openjp2/pi.c"
void opj_pi_create_encode(opj_pi_iterator_t *pi , opj_cp_t *cp , OPJ_UINT32 tileno ,
                          OPJ_UINT32 pino , OPJ_UINT32 tpnum , OPJ_INT32 tppos , J2K_T2_MODE t2_mode ) 
{ 
  OPJ_CHAR *prog ;
  OPJ_INT32 i ;
  OPJ_UINT32 incr_top ;
  OPJ_UINT32 resetX ;
  opj_tcp_t *tcps ;
  opj_poc_t *tcp ;
  OPJ_INT32 __cil_tmp16 ;
  OPJ_BOOL __cil_tmp17 ;
  OPJ_BOOL __cil_tmp18 ;
  OPJ_BOOL __cil_tmp19 ;
  OPJ_BOOL __cil_tmp20 ;
  OPJ_BOOL __cil_tmp21 ;
  OPJ_INT32 __cil_tmp22 ;

  {
  {
#line 1542
  incr_top = (OPJ_UINT32 )1;
#line 1542
  resetX = (OPJ_UINT32 )0;
#line 1543
  tcps = cp->tcps + tileno;
#line 1544
  tcp = & tcps->pocs[pino];
#line 1546
  prog = opj_j2k_convert_progression_order(tcp->prg);
#line 1548
  (pi + pino)->first = 1;
#line 1549
  (pi + pino)->poc.prg = tcp->prg;
  }
#line 1551
  if ((int )cp->m_specific_param.m_enc.m_tp_on) {
#line 1551
    if (! cp->m_specific_param.m_enc.m_cinema) {
#line 1551
      if ((unsigned int )t2_mode == 1U) {
#line 1551
        goto _L___4;
      } else {
#line 1551
        goto _L___5;
      }
    } else
    _L___5: /* CIL Label */ 
#line 1551
    if ((unsigned int )cp->m_specific_param.m_enc.m_cinema) {
      _L___4: /* CIL Label */ 
#line 1565
      i = tppos + 1;
      {
#line 1565
      while (1) {
        while_continue: /* CIL Label */ ;

#line 1565
        if (! (i < 4)) {
#line 1565
          goto while_break;
        }
#line 1567
        if ((int )*(prog + i) == 82) {
#line 1567
          goto case_82;
        }
#line 1571
        if ((int )*(prog + i) == 67) {
#line 1571
          goto case_67;
        }
#line 1575
        if ((int )*(prog + i) == 76) {
#line 1575
          goto case_76;
        }
#line 1579
        if ((int )*(prog + i) == 80) {
#line 1579
          goto case_80;
        }
#line 1582
        if ((int )*(prog + i) == 1) {
#line 1582
          goto case_1;
        }
#line 1582
        if ((int )*(prog + i) == 0) {
#line 1582
          goto case_1;
        }
#line 1586
        goto switch_default;
        case_82: 
#line 1568
        (pi + pino)->poc.resno0 = tcp->resS;
#line 1569
        (pi + pino)->poc.resno1 = tcp->resE;
#line 1570
        goto switch_break;
        case_67: 
#line 1572
        (pi + pino)->poc.compno0 = tcp->compS;
#line 1573
        (pi + pino)->poc.compno1 = tcp->compE;
#line 1574
        goto switch_break;
        case_76: 
#line 1576
        (pi + pino)->poc.layno0 = tcp->layS;
#line 1577
        (pi + pino)->poc.layno1 = tcp->layE;
#line 1578
        goto switch_break;
        case_80: 
#line 1582
        if ((int )tcp->prg == 1) {
#line 1582
          goto case_1;
        }
#line 1582
        if ((int )tcp->prg == 0) {
#line 1582
          goto case_1;
        }
#line 1586
        goto switch_default;
        case_1: 
#line 1583
        (pi + pino)->poc.precno0 = tcp->prcS;
#line 1584
        (pi + pino)->poc.precno1 = tcp->prcE;
#line 1585
        goto switch_break___0;
        switch_default: 
#line 1587
        (pi + pino)->poc.tx0 = (OPJ_INT32 )tcp->txS;
#line 1588
        (pi + pino)->poc.ty0 = (OPJ_INT32 )tcp->tyS;
#line 1589
        (pi + pino)->poc.tx1 = (OPJ_INT32 )tcp->txE;
#line 1590
        (pi + pino)->poc.ty1 = (OPJ_INT32 )tcp->tyE;
#line 1591
        goto switch_break___0;
        switch_break___0: ;
#line 1593
        goto switch_break;
        switch_break: 
#line 1565
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break: ;
#line 1597
      if (tpnum == 0U) {
#line 1598
        i = tppos;
        {
#line 1598
        while (1) {
          while_continue___0: /* CIL Label */ ;

#line 1598
          if (! (i >= 0)) {
#line 1598
            goto while_break___0;
          }
#line 1600
          if ((int )*(prog + i) == 67) {
#line 1600
            goto case_67___0;
          }
#line 1606
          if ((int )*(prog + i) == 82) {
#line 1606
            goto case_82___0;
          }
#line 1612
          if ((int )*(prog + i) == 76) {
#line 1612
            goto case_76___0;
          }
#line 1618
          if ((int )*(prog + i) == 80) {
#line 1618
            goto case_80___0;
          }
#line 1621
          if ((int )*(prog + i) == 1) {
#line 1621
            goto case_1___0;
          }
#line 1621
          if ((int )*(prog + i) == 0) {
#line 1621
            goto case_1___0;
          }
#line 1627
          goto switch_default___0;
          case_67___0: 
#line 1601
          tcp->comp_t = tcp->compS;
#line 1602
          (pi + pino)->poc.compno0 = tcp->comp_t;
#line 1603
          (pi + pino)->poc.compno1 = tcp->comp_t + 1U;
#line 1604
          (tcp->comp_t) ++;
#line 1605
          goto switch_break___1;
          case_82___0: 
#line 1607
          tcp->res_t = tcp->resS;
#line 1608
          (pi + pino)->poc.resno0 = tcp->res_t;
#line 1609
          (pi + pino)->poc.resno1 = tcp->res_t + 1U;
#line 1610
          (tcp->res_t) ++;
#line 1611
          goto switch_break___1;
          case_76___0: 
#line 1613
          tcp->lay_t = tcp->layS;
#line 1614
          (pi + pino)->poc.layno0 = tcp->lay_t;
#line 1615
          (pi + pino)->poc.layno1 = tcp->lay_t + 1U;
#line 1616
          (tcp->lay_t) ++;
#line 1617
          goto switch_break___1;
          case_80___0: 
#line 1621
          if ((int )tcp->prg == 1) {
#line 1621
            goto case_1___0;
          }
#line 1621
          if ((int )tcp->prg == 0) {
#line 1621
            goto case_1___0;
          }
#line 1627
          goto switch_default___0;
          case_1___0: 
#line 1622
          tcp->prc_t = tcp->prcS;
#line 1623
          (pi + pino)->poc.precno0 = tcp->prc_t;
#line 1624
          (pi + pino)->poc.precno1 = tcp->prc_t + 1U;
#line 1625
          (tcp->prc_t) ++;
#line 1626
          goto switch_break___2;
          switch_default___0: 
#line 1628
          tcp->tx0_t = tcp->txS;
#line 1629
          tcp->ty0_t = tcp->tyS;
#line 1630
          (pi + pino)->poc.tx0 = (OPJ_INT32 )tcp->tx0_t;
#line 1631
          (pi + pino)->poc.tx1 = (OPJ_INT32 )((tcp->tx0_t + tcp->dx) - tcp->tx0_t % tcp->dx);
#line 1632
          (pi + pino)->poc.ty0 = (OPJ_INT32 )tcp->ty0_t;
#line 1633
          (pi + pino)->poc.ty1 = (OPJ_INT32 )((tcp->ty0_t + tcp->dy) - tcp->ty0_t % tcp->dy);
#line 1634
          tcp->tx0_t = (OPJ_UINT32 )(pi + pino)->poc.tx1;
#line 1635
          tcp->ty0_t = (OPJ_UINT32 )(pi + pino)->poc.ty1;
#line 1636
          goto switch_break___2;
          switch_break___2: ;
#line 1638
          goto switch_break___1;
          switch_break___1: 
#line 1598
          __cil_tmp16 = i;
#line 1598
          i --;
        }
        while_break___3: /* CIL Label */ ;
        }
        while_break___0: 
#line 1641
        incr_top = (OPJ_UINT32 )1;
      } else {
#line 1643
        i = tppos;
        {
#line 1643
        while (1) {
          while_continue___1: /* CIL Label */ ;

#line 1643
          if (! (i >= 0)) {
#line 1643
            goto while_break___1;
          }
#line 1645
          if ((int )*(prog + i) == 67) {
#line 1645
            goto case_67___1;
          }
#line 1649
          if ((int )*(prog + i) == 82) {
#line 1649
            goto case_82___1;
          }
#line 1653
          if ((int )*(prog + i) == 76) {
#line 1653
            goto case_76___1;
          }
#line 1657
          if ((int )*(prog + i) == 80) {
#line 1657
            goto case_80___1;
          }
#line 1660
          if ((int )*(prog + i) == 1) {
#line 1660
            goto case_1___1;
          }
#line 1660
          if ((int )*(prog + i) == 0) {
#line 1660
            goto case_1___1;
          }
#line 1664
          goto switch_default___1;
          case_67___1: 
#line 1646
          (pi + pino)->poc.compno0 = tcp->comp_t - 1U;
#line 1647
          (pi + pino)->poc.compno1 = tcp->comp_t;
#line 1648
          goto switch_break___3;
          case_82___1: 
#line 1650
          (pi + pino)->poc.resno0 = tcp->res_t - 1U;
#line 1651
          (pi + pino)->poc.resno1 = tcp->res_t;
#line 1652
          goto switch_break___3;
          case_76___1: 
#line 1654
          (pi + pino)->poc.layno0 = tcp->lay_t - 1U;
#line 1655
          (pi + pino)->poc.layno1 = tcp->lay_t;
#line 1656
          goto switch_break___3;
          case_80___1: 
#line 1660
          if ((int )tcp->prg == 1) {
#line 1660
            goto case_1___1;
          }
#line 1660
          if ((int )tcp->prg == 0) {
#line 1660
            goto case_1___1;
          }
#line 1664
          goto switch_default___1;
          case_1___1: 
#line 1661
          (pi + pino)->poc.precno0 = tcp->prc_t - 1U;
#line 1662
          (pi + pino)->poc.precno1 = tcp->prc_t;
#line 1663
          goto switch_break___4;
          switch_default___1: 
#line 1665
          (pi + pino)->poc.tx0 = (OPJ_INT32 )((tcp->tx0_t - tcp->dx) - tcp->tx0_t % tcp->dx);
#line 1666
          (pi + pino)->poc.tx1 = (OPJ_INT32 )tcp->tx0_t;
#line 1667
          (pi + pino)->poc.ty0 = (OPJ_INT32 )((tcp->ty0_t - tcp->dy) - tcp->ty0_t % tcp->dy);
#line 1668
          (pi + pino)->poc.ty1 = (OPJ_INT32 )tcp->ty0_t;
#line 1669
          goto switch_break___4;
          switch_break___4: ;
#line 1671
          goto switch_break___3;
          switch_break___3: ;
#line 1673
          if (incr_top == 1U) {
#line 1675
            if ((int )*(prog + i) == 82) {
#line 1675
              goto case_82___2;
            }
#line 1693
            if ((int )*(prog + i) == 67) {
#line 1693
              goto case_67___2;
            }
#line 1711
            if ((int )*(prog + i) == 76) {
#line 1711
              goto case_76___2;
            }
#line 1729
            if ((int )*(prog + i) == 80) {
#line 1729
              goto case_80___2;
            }
#line 1732
            if ((int )*(prog + i) == 1) {
#line 1732
              goto case_1___2;
            }
#line 1732
            if ((int )*(prog + i) == 0) {
#line 1732
              goto case_1___2;
            }
#line 1750
            goto switch_default___2;
            case_82___2: 
#line 1676
            if (tcp->res_t == tcp->resE) {
              {
#line 1677
              __cil_tmp17 = opj_pi_check_next_level(i - 1, cp, tileno, pino, prog);
              }
#line 1677
              if (__cil_tmp17) {
#line 1678
                tcp->res_t = tcp->resS;
#line 1679
                (pi + pino)->poc.resno0 = tcp->res_t;
#line 1680
                (pi + pino)->poc.resno1 = tcp->res_t + 1U;
#line 1681
                (tcp->res_t) ++;
#line 1682
                incr_top = (OPJ_UINT32 )1;
              } else {
#line 1684
                incr_top = (OPJ_UINT32 )0;
              }
            } else {
#line 1687
              (pi + pino)->poc.resno0 = tcp->res_t;
#line 1688
              (pi + pino)->poc.resno1 = tcp->res_t + 1U;
#line 1689
              (tcp->res_t) ++;
#line 1690
              incr_top = (OPJ_UINT32 )0;
            }
#line 1692
            goto switch_break___5;
            case_67___2: 
#line 1694
            if (tcp->comp_t == tcp->compE) {
              {
#line 1695
              __cil_tmp18 = opj_pi_check_next_level(i - 1, cp, tileno, pino, prog);
              }
#line 1695
              if (__cil_tmp18) {
#line 1696
                tcp->comp_t = tcp->compS;
#line 1697
                (pi + pino)->poc.compno0 = tcp->comp_t;
#line 1698
                (pi + pino)->poc.compno1 = tcp->comp_t + 1U;
#line 1699
                (tcp->comp_t) ++;
#line 1700
                incr_top = (OPJ_UINT32 )1;
              } else {
#line 1702
                incr_top = (OPJ_UINT32 )0;
              }
            } else {
#line 1705
              (pi + pino)->poc.compno0 = tcp->comp_t;
#line 1706
              (pi + pino)->poc.compno1 = tcp->comp_t + 1U;
#line 1707
              (tcp->comp_t) ++;
#line 1708
              incr_top = (OPJ_UINT32 )0;
            }
#line 1710
            goto switch_break___5;
            case_76___2: 
#line 1712
            if (tcp->lay_t == tcp->layE) {
              {
#line 1713
              __cil_tmp19 = opj_pi_check_next_level(i - 1, cp, tileno, pino, prog);
              }
#line 1713
              if (__cil_tmp19) {
#line 1714
                tcp->lay_t = tcp->layS;
#line 1715
                (pi + pino)->poc.layno0 = tcp->lay_t;
#line 1716
                (pi + pino)->poc.layno1 = tcp->lay_t + 1U;
#line 1717
                (tcp->lay_t) ++;
#line 1718
                incr_top = (OPJ_UINT32 )1;
              } else {
#line 1720
                incr_top = (OPJ_UINT32 )0;
              }
            } else {
#line 1723
              (pi + pino)->poc.layno0 = tcp->lay_t;
#line 1724
              (pi + pino)->poc.layno1 = tcp->lay_t + 1U;
#line 1725
              (tcp->lay_t) ++;
#line 1726
              incr_top = (OPJ_UINT32 )0;
            }
#line 1728
            goto switch_break___5;
            case_80___2: 
#line 1732
            if ((int )tcp->prg == 1) {
#line 1732
              goto case_1___2;
            }
#line 1732
            if ((int )tcp->prg == 0) {
#line 1732
              goto case_1___2;
            }
#line 1750
            goto switch_default___2;
            case_1___2: 
#line 1733
            if (tcp->prc_t == tcp->prcE) {
              {
#line 1734
              __cil_tmp20 = opj_pi_check_next_level(i - 1, cp, tileno, pino, prog);
              }
#line 1734
              if (__cil_tmp20) {
#line 1735
                tcp->prc_t = tcp->prcS;
#line 1736
                (pi + pino)->poc.precno0 = tcp->prc_t;
#line 1737
                (pi + pino)->poc.precno1 = tcp->prc_t + 1U;
#line 1738
                (tcp->prc_t) ++;
#line 1739
                incr_top = (OPJ_UINT32 )1;
              } else {
#line 1741
                incr_top = (OPJ_UINT32 )0;
              }
            } else {
#line 1744
              (pi + pino)->poc.precno0 = tcp->prc_t;
#line 1745
              (pi + pino)->poc.precno1 = tcp->prc_t + 1U;
#line 1746
              (tcp->prc_t) ++;
#line 1747
              incr_top = (OPJ_UINT32 )0;
            }
#line 1749
            goto switch_break___6;
            switch_default___2: 
#line 1751
            if (tcp->tx0_t >= tcp->txE) {
#line 1752
              if (tcp->ty0_t >= tcp->tyE) {
                {
#line 1753
                __cil_tmp21 = opj_pi_check_next_level(i - 1, cp, tileno, pino, prog);
                }
#line 1753
                if (__cil_tmp21) {
#line 1754
                  tcp->ty0_t = tcp->tyS;
#line 1755
                  (pi + pino)->poc.ty0 = (OPJ_INT32 )tcp->ty0_t;
#line 1756
                  (pi + pino)->poc.ty1 = (OPJ_INT32 )((tcp->ty0_t + tcp->dy) - tcp->ty0_t % tcp->dy);
#line 1757
                  tcp->ty0_t = (OPJ_UINT32 )(pi + pino)->poc.ty1;
#line 1758
                  incr_top = (OPJ_UINT32 )1;
#line 1758
                  resetX = (OPJ_UINT32 )1;
                } else {
#line 1760
                  incr_top = (OPJ_UINT32 )0;
#line 1760
                  resetX = (OPJ_UINT32 )0;
                }
              } else {
#line 1763
                (pi + pino)->poc.ty0 = (OPJ_INT32 )tcp->ty0_t;
#line 1764
                (pi + pino)->poc.ty1 = (OPJ_INT32 )((tcp->ty0_t + tcp->dy) - tcp->ty0_t % tcp->dy);
#line 1765
                tcp->ty0_t = (OPJ_UINT32 )(pi + pino)->poc.ty1;
#line 1766
                incr_top = (OPJ_UINT32 )0;
#line 1766
                resetX = (OPJ_UINT32 )1;
              }
#line 1768
              if (resetX == 1U) {
#line 1769
                tcp->tx0_t = tcp->txS;
#line 1770
                (pi + pino)->poc.tx0 = (OPJ_INT32 )tcp->tx0_t;
#line 1771
                (pi + pino)->poc.tx1 = (OPJ_INT32 )((tcp->tx0_t + tcp->dx) - tcp->tx0_t % tcp->dx);
#line 1772
                tcp->tx0_t = (OPJ_UINT32 )(pi + pino)->poc.tx1;
              }
            } else {
#line 1775
              (pi + pino)->poc.tx0 = (OPJ_INT32 )tcp->tx0_t;
#line 1776
              (pi + pino)->poc.tx1 = (OPJ_INT32 )((tcp->tx0_t + tcp->dx) - tcp->tx0_t % tcp->dx);
#line 1777
              tcp->tx0_t = (OPJ_UINT32 )(pi + pino)->poc.tx1;
#line 1778
              incr_top = (OPJ_UINT32 )0;
            }
#line 1780
            goto switch_break___6;
            switch_break___6: ;
#line 1782
            goto switch_break___5;
            switch_break___5: ;
          }
#line 1643
          __cil_tmp22 = i;
#line 1643
          i --;
        }
        while_break___4: /* CIL Label */ ;
        }
        while_break___1: ;
      }
    } else {
#line 1551
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
#line 1552
    (pi + pino)->poc.resno0 = tcp->resS;
#line 1553
    (pi + pino)->poc.resno1 = tcp->resE;
#line 1554
    (pi + pino)->poc.compno0 = tcp->compS;
#line 1555
    (pi + pino)->poc.compno1 = tcp->compE;
#line 1556
    (pi + pino)->poc.layno0 = tcp->layS;
#line 1557
    (pi + pino)->poc.layno1 = tcp->layE;
#line 1558
    (pi + pino)->poc.precno0 = tcp->prcS;
#line 1559
    (pi + pino)->poc.precno1 = tcp->prcE;
#line 1560
    (pi + pino)->poc.tx0 = (OPJ_INT32 )tcp->txS;
#line 1561
    (pi + pino)->poc.ty0 = (OPJ_INT32 )tcp->tyS;
#line 1562
    (pi + pino)->poc.tx1 = (OPJ_INT32 )tcp->txE;
#line 1563
    (pi + pino)->poc.ty1 = (OPJ_INT32 )tcp->tyE;
  }
#line 1649
  return;
}
}
#line 1790 "/root/patron/new_22/src/lib/openjp2/pi.c"
void opj_pi_destroy(opj_pi_iterator_t *p_pi , OPJ_UINT32 p_nb_elements ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_UINT32 pino ;
  opj_pi_iterator_t *l_current_pi ;
  opj_pi_comp_t *l_current_component ;

  {
#line 1794
  l_current_pi = p_pi;
#line 1795
  if (p_pi) {
#line 1796
    if (p_pi->include) {
      {
#line 1797
      free((void *)p_pi->include);
#line 1798
      p_pi->include = (OPJ_INT16 *)0;
      }
    }
#line 1800
    pino = (OPJ_UINT32 )0;
    {
#line 1800
    while (1) {
      while_continue: /* CIL Label */ ;

#line 1800
      if (! (pino < p_nb_elements)) {
#line 1800
        goto while_break;
      }
#line 1801
      if (l_current_pi->comps) {
#line 1802
        l_current_component = l_current_pi->comps;
#line 1803
        compno = (OPJ_UINT32 )0;
        {
#line 1803
        while (1) {
          while_continue___0: /* CIL Label */ ;

#line 1803
          if (! (compno < l_current_pi->numcomps)) {
#line 1803
            goto while_break___0;
          }
#line 1804
          if (l_current_component->resolutions) {
            {
#line 1805
            free((void *)l_current_component->resolutions);
#line 1806
            l_current_component->resolutions = (opj_pi_resolution_t *)0;
            }
          }
#line 1809
          l_current_component ++;
#line 1803
          compno ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        while_break___0: 
        {
#line 1811
        free((void *)l_current_pi->comps);
#line 1812
        l_current_pi->comps = (opj_pi_comp_t *)0;
        }
      }
#line 1814
      l_current_pi ++;
#line 1800
      pino ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: 
    {
#line 1816
    free((void *)p_pi);
    }
  }
#line 1819
  return;
}
}
#line 1822 "/root/patron/new_22/src/lib/openjp2/pi.c"
void opj_pi_update_encoding_parameters(opj_image_t *p_image , opj_cp_t *p_cp , OPJ_UINT32 p_tile_no ) 
{ 
  OPJ_UINT32 l_max_res ;
  OPJ_UINT32 l_max_prec ;
  OPJ_INT32 l_tx0 ;
  OPJ_INT32 l_tx1 ;
  OPJ_INT32 l_ty0 ;
  OPJ_INT32 l_ty1 ;
  OPJ_UINT32 l_dx_min ;
  OPJ_UINT32 l_dy_min ;
  opj_tcp_t *l_tcp ;

  {
  {
#line 1833
  l_tcp = (opj_tcp_t *)0;
#line 1840
  l_tcp = p_cp->tcps + p_tile_no;
#line 1843
  opj_get_encoding_parameters(p_image, p_cp, p_tile_no, & l_tx0, & l_tx1, & l_ty0,
                              & l_ty1, & l_dx_min, & l_dy_min, & l_max_prec, & l_max_res);
  }
#line 1845
  if (l_tcp->POC) {
    {
#line 1846
    opj_pi_update_encode_poc_and_final(p_cp, p_tile_no, l_tx0, l_tx1, l_ty0, l_ty1,
                                       l_max_prec, l_max_res, l_dx_min, l_dy_min);
    }
  } else {
    {
#line 1849
    opj_pi_update_encode_not_poc(p_cp, p_image->numcomps, p_tile_no, l_tx0, l_tx1,
                                 l_ty0, l_ty1, l_max_prec, l_max_res, l_dx_min, l_dy_min);
    }
  }
#line 1853
  return;
}
}
#line 1853 "/root/patron/new_22/src/lib/openjp2/pi.c"
OPJ_BOOL opj_pi_next(opj_pi_iterator_t *pi ) 
{ 
  OPJ_BOOL __cil_tmp2 ;
  OPJ_BOOL __cil_tmp3 ;
  OPJ_BOOL __cil_tmp4 ;
  OPJ_BOOL __cil_tmp5 ;
  OPJ_BOOL __cil_tmp6 ;

  {
#line 1855
  if ((int )pi->poc.prg == 0) {
#line 1855
    goto case_0;
  }
#line 1857
  if ((int )pi->poc.prg == 1) {
#line 1857
    goto case_1;
  }
#line 1859
  if ((int )pi->poc.prg == 2) {
#line 1859
    goto case_2;
  }
#line 1861
  if ((int )pi->poc.prg == 3) {
#line 1861
    goto case_3;
  }
#line 1863
  if ((int )pi->poc.prg == 4) {
#line 1863
    goto case_4;
  }
#line 1865
  if ((int )pi->poc.prg == -1) {
#line 1865
    goto case_neg_1;
  }
#line 1854
  goto switch_break;
  case_0: 
  {
#line 1856
  __cil_tmp2 = opj_pi_next_lrcp(pi);
  }
#line 1856
  return (__cil_tmp2);
  case_1: 
  {
#line 1858
  __cil_tmp3 = opj_pi_next_rlcp(pi);
  }
#line 1858
  return (__cil_tmp3);
  case_2: 
  {
#line 1860
  __cil_tmp4 = opj_pi_next_rpcl(pi);
  }
#line 1860
  return (__cil_tmp4);
  case_3: 
  {
#line 1862
  __cil_tmp5 = opj_pi_next_pcrl(pi);
  }
#line 1862
  return (__cil_tmp5);
  case_4: 
  {
#line 1864
  __cil_tmp6 = opj_pi_next_cprl(pi);
  }
#line 1864
  return (__cil_tmp6);
  case_neg_1: 
#line 1866
  return (0);
  switch_break: ;
#line 1869
  return (0);
}
}
#line 87 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int getrusage(__rusage_who_t __who , struct rusage *__usage ) ;
#line 36 "/root/patron/new_22/src/lib/openjp2/opj_clock.c"
OPJ_FLOAT64 opj_clock(void) 
{ 
  struct rusage t ;
  OPJ_FLOAT64 procTime ;

  {
  {
#line 51
  getrusage(0, & t);
#line 54
  procTime = (OPJ_FLOAT64 )(t.ru_utime.tv_sec + t.ru_stime.tv_sec);
  }
#line 56
  return (procTime + (double )(t.ru_utime.tv_usec + t.ru_stime.tv_usec) * 1e-06);
}
}
#line 156 "/root/patron/new_22/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_set_info_handler(opj_codec_t *p_codec , void (*p_callback)(char const   * ,
                                                                        void * ) ,
                              void *p_user_data ) 
{ 
  opj_codec_private_t *l_codec ;

  {
#line 160
  l_codec = (opj_codec_private_t *)p_codec;
#line 161
  if (! l_codec) {
#line 162
    return (0);
  }
#line 165
  l_codec->m_event_mgr.info_handler = p_callback;
#line 166
  l_codec->m_event_mgr.m_info_data = p_user_data;
#line 168
  return (1);
}
}
#line 171 "/root/patron/new_22/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_set_warning_handler(opj_codec_t *p_codec , void (*p_callback)(char const   * ,
                                                                           void * ) ,
                                 void *p_user_data ) 
{ 
  opj_codec_private_t *l_codec ;

  {
#line 175
  l_codec = (opj_codec_private_t *)p_codec;
#line 176
  if (! l_codec) {
#line 177
    return (0);
  }
#line 180
  l_codec->m_event_mgr.warning_handler = p_callback;
#line 181
  l_codec->m_event_mgr.m_warning_data = p_user_data;
#line 183
  return (1);
}
}
#line 186 "/root/patron/new_22/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_set_error_handler(opj_codec_t *p_codec , void (*p_callback)(char const   * ,
                                                                         void * ) ,
                               void *p_user_data ) 
{ 
  opj_codec_private_t *l_codec ;

  {
#line 190
  l_codec = (opj_codec_private_t *)p_codec;
#line 191
  if (! l_codec) {
#line 192
    return (0);
  }
#line 195
  l_codec->m_event_mgr.error_handler = p_callback;
#line 196
  l_codec->m_event_mgr.m_error_data = p_user_data;
#line 198
  return (1);
}
}
#line 203 "/root/patron/new_22/src/lib/openjp2/openjpeg.c"
static OPJ_SIZE_T opj_read_from_file(void *p_buffer , OPJ_SIZE_T p_nb_bytes , FILE *p_file ) 
{ 
  OPJ_SIZE_T l_nb_read ;
  unsigned long __cil_tmp5 ;
  OPJ_SIZE_T tmp ;

  {
  {
#line 205
  __cil_tmp5 = fread(p_buffer, 1UL, p_nb_bytes, p_file);
#line 205
  l_nb_read = __cil_tmp5;
  }
#line 206
  if (l_nb_read) {
#line 206
    tmp = l_nb_read;
  } else {
#line 206
    tmp = (OPJ_SIZE_T )-1;
  }
#line 206
  return (tmp);
}
}
#line 209 "/root/patron/new_22/src/lib/openjp2/openjpeg.c"
static OPJ_UINT64 opj_get_data_length_from_file(FILE *p_file ) 
{ 
  OPJ_OFF_T file_length ;
  __off_t __cil_tmp3 ;

  {
  {
#line 211
  file_length = (OPJ_OFF_T )0;
#line 213
  fseeko(p_file, (__off_t )0, 2);
#line 214
  __cil_tmp3 = ftello(p_file);
#line 214
  file_length = (OPJ_OFF_T )((OPJ_UINT64 )__cil_tmp3);
#line 215
  fseeko(p_file, (__off_t )0, 0);
  }
#line 217
  return ((OPJ_UINT64 )file_length);
}
}
#line 220 "/root/patron/new_22/src/lib/openjp2/openjpeg.c"
static OPJ_SIZE_T opj_write_from_file(void *p_buffer , OPJ_SIZE_T p_nb_bytes , FILE *p_file ) 
{ 
  unsigned long __cil_tmp4 ;

  {
  {
#line 222
  __cil_tmp4 = fwrite((void const   *)p_buffer, 1UL, p_nb_bytes, p_file);
  }
#line 222
  return (__cil_tmp4);
}
}
#line 225 "/root/patron/new_22/src/lib/openjp2/openjpeg.c"
static OPJ_OFF_T opj_skip_from_file(OPJ_OFF_T p_nb_bytes , FILE *p_user_data ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 227
  __cil_tmp3 = fseeko(p_user_data, p_nb_bytes, 1);
  }
#line 227
  if (__cil_tmp3) {
#line 228
    return ((OPJ_OFF_T )-1);
  }
#line 231
  return (p_nb_bytes);
}
}
#line 234 "/root/patron/new_22/src/lib/openjp2/openjpeg.c"
static OPJ_BOOL opj_seek_from_file(OPJ_OFF_T p_nb_bytes , FILE *p_user_data ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 236
  __cil_tmp3 = fseeko(p_user_data, p_nb_bytes, 0);
  }
#line 236
  if (__cil_tmp3) {
#line 237
    return (0);
  }
#line 240
  return (1);
}
}
#line 269 "/root/patron/new_22/src/lib/openjp2/openjpeg.c"
char const   *opj_version(void) 
{ 


  {
#line 270
  return ("2.0.0");
}
}
#line 276 "/root/patron/new_22/src/lib/openjp2/openjpeg.c"
opj_codec_t *opj_create_decompress(OPJ_CODEC_FORMAT p_format ) 
{ 
  opj_codec_private_t *l_codec ;
  void *__cil_tmp3 ;
  opj_j2k_t *tmp ;
  opj_jp2_t *tmp___0 ;

  {
  {
#line 278
  l_codec = (opj_codec_private_t *)0;
#line 280
  __cil_tmp3 = calloc(1UL, sizeof(opj_codec_private_t ));
#line 280
  l_codec = (opj_codec_private_t *)__cil_tmp3;
  }
#line 281
  if (! l_codec) {
#line 282
    return ((opj_codec_t *)0);
  }
  {
#line 284
  memset((void *)l_codec, 0, sizeof(opj_codec_private_t ));
#line 286
  l_codec->is_decompressor = 1;
  }
#line 289
  if ((int )p_format == 0) {
#line 289
    goto case_0;
  }
#line 364
  if ((int )p_format == 2) {
#line 364
    goto case_2;
  }
#line 441
  goto switch_default;
  case_0: 
  {
#line 290
  l_codec->opj_dump_codec = (void (*)(void * , OPJ_INT32  , FILE * ))(& j2k_dump);
#line 292
  l_codec->opj_get_codec_info = (opj_codestream_info_v2_t *(*)(void * ))(& j2k_get_cstr_info);
#line 294
  l_codec->opj_get_codec_index = (opj_codestream_index_t *(*)(void * ))(& j2k_get_cstr_index);
#line 296
  l_codec->m_codec_data.m_decompression.opj_decode = (OPJ_BOOL (*)(void * , struct opj_stream_private * ,
                                                                   opj_image_t * ,
                                                                   struct opj_event_mgr * ))(& opj_j2k_decode);
#line 301
  l_codec->m_codec_data.m_decompression.opj_end_decompress = (OPJ_BOOL (*)(void * ,
                                                                           struct opj_stream_private * ,
                                                                           struct opj_event_mgr * ))(& opj_j2k_end_decompress);
#line 306
  l_codec->m_codec_data.m_decompression.opj_read_header = (OPJ_BOOL (*)(struct opj_stream_private * ,
                                                                        void * , opj_image_t ** ,
                                                                        struct opj_event_mgr * ))(& opj_j2k_read_header);
#line 312
  l_codec->m_codec_data.m_decompression.opj_destroy = (void (*)(void * ))(& opj_j2k_destroy);
#line 315
  l_codec->m_codec_data.m_decompression.opj_setup_decoder = (void (*)(void * , opj_dparameters_t * ))(& opj_j2k_setup_decoder);
#line 318
  l_codec->m_codec_data.m_decompression.opj_read_tile_header = (OPJ_BOOL (*)(void * ,
                                                                             OPJ_UINT32 * ,
                                                                             OPJ_UINT32 * ,
                                                                             OPJ_INT32 * ,
                                                                             OPJ_INT32 * ,
                                                                             OPJ_INT32 * ,
                                                                             OPJ_INT32 * ,
                                                                             OPJ_UINT32 * ,
                                                                             OPJ_BOOL * ,
                                                                             struct opj_stream_private * ,
                                                                             struct opj_event_mgr * ))(& opj_j2k_read_tile_header);
#line 329
  l_codec->m_codec_data.m_decompression.opj_decode_tile_data = (OPJ_BOOL (*)(void * ,
                                                                             OPJ_UINT32  ,
                                                                             OPJ_BYTE * ,
                                                                             OPJ_UINT32  ,
                                                                             struct opj_stream_private * ,
                                                                             struct opj_event_mgr * ))(& opj_j2k_decode_tile);
#line 337
  l_codec->m_codec_data.m_decompression.opj_set_decode_area = (OPJ_BOOL (*)(void * ,
                                                                            opj_image_t * ,
                                                                            OPJ_INT32  ,
                                                                            OPJ_INT32  ,
                                                                            OPJ_INT32  ,
                                                                            OPJ_INT32  ,
                                                                            struct opj_event_mgr * ))(& opj_j2k_set_decode_area);
#line 343
  l_codec->m_codec_data.m_decompression.opj_get_decoded_tile = (OPJ_BOOL (*)(void * ,
                                                                             opj_stream_private_t * ,
                                                                             opj_image_t * ,
                                                                             struct opj_event_mgr * ,
                                                                             OPJ_UINT32  ))(& opj_j2k_get_tile);
#line 350
  l_codec->m_codec_data.m_decompression.opj_set_decoded_resolution_factor = (OPJ_BOOL (*)(void * ,
                                                                                          OPJ_UINT32  ,
                                                                                          struct opj_event_mgr * ))(& opj_j2k_set_decoded_resolution_factor);
#line 355
  tmp = opj_j2k_create_decompress();
#line 355
  l_codec->m_codec = (void *)tmp;
  }
#line 357
  if (! l_codec->m_codec) {
    {
#line 358
    free((void *)l_codec);
    }
#line 359
    return ((opj_codec_t *)((void *)0));
  }
#line 362
  goto switch_break;
  case_2: 
  {
#line 366
  l_codec->opj_dump_codec = (void (*)(void * , OPJ_INT32  , FILE * ))(& jp2_dump);
#line 368
  l_codec->opj_get_codec_info = (opj_codestream_info_v2_t *(*)(void * ))(& jp2_get_cstr_info);
#line 370
  l_codec->opj_get_codec_index = (opj_codestream_index_t *(*)(void * ))(& jp2_get_cstr_index);
#line 372
  l_codec->m_codec_data.m_decompression.opj_decode = (OPJ_BOOL (*)(void * , struct opj_stream_private * ,
                                                                   opj_image_t * ,
                                                                   struct opj_event_mgr * ))(& opj_jp2_decode);
#line 378
  l_codec->m_codec_data.m_decompression.opj_end_decompress = (OPJ_BOOL (*)(void * ,
                                                                           struct opj_stream_private * ,
                                                                           struct opj_event_mgr * ))(& opj_jp2_end_decompress);
#line 383
  l_codec->m_codec_data.m_decompression.opj_read_header = (OPJ_BOOL (*)(struct opj_stream_private * ,
                                                                        void * , opj_image_t ** ,
                                                                        struct opj_event_mgr * ))(& opj_jp2_read_header);
#line 389
  l_codec->m_codec_data.m_decompression.opj_read_tile_header = (OPJ_BOOL (*)(void * ,
                                                                             OPJ_UINT32 * ,
                                                                             OPJ_UINT32 * ,
                                                                             OPJ_INT32 * ,
                                                                             OPJ_INT32 * ,
                                                                             OPJ_INT32 * ,
                                                                             OPJ_INT32 * ,
                                                                             OPJ_UINT32 * ,
                                                                             OPJ_BOOL * ,
                                                                             struct opj_stream_private * ,
                                                                             struct opj_event_mgr * ))(& opj_jp2_read_tile_header);
#line 402
  l_codec->m_codec_data.m_decompression.opj_decode_tile_data = (OPJ_BOOL (*)(void * ,
                                                                             OPJ_UINT32  ,
                                                                             OPJ_BYTE * ,
                                                                             OPJ_UINT32  ,
                                                                             struct opj_stream_private * ,
                                                                             struct opj_event_mgr * ))(& opj_jp2_decode_tile);
#line 408
  l_codec->m_codec_data.m_decompression.opj_destroy = (void (*)(void * ))(& opj_jp2_destroy);
#line 410
  l_codec->m_codec_data.m_decompression.opj_setup_decoder = (void (*)(void * , opj_dparameters_t * ))(& opj_jp2_setup_decoder);
#line 413
  l_codec->m_codec_data.m_decompression.opj_set_decode_area = (OPJ_BOOL (*)(void * ,
                                                                            opj_image_t * ,
                                                                            OPJ_INT32  ,
                                                                            OPJ_INT32  ,
                                                                            OPJ_INT32  ,
                                                                            OPJ_INT32  ,
                                                                            struct opj_event_mgr * ))(& opj_jp2_set_decode_area);
#line 419
  l_codec->m_codec_data.m_decompression.opj_get_decoded_tile = (OPJ_BOOL (*)(void * ,
                                                                             opj_stream_private_t * ,
                                                                             opj_image_t * ,
                                                                             struct opj_event_mgr * ,
                                                                             OPJ_UINT32  ))(& opj_jp2_get_tile);
#line 426
  l_codec->m_codec_data.m_decompression.opj_set_decoded_resolution_factor = (OPJ_BOOL (*)(void * ,
                                                                                          OPJ_UINT32  ,
                                                                                          opj_event_mgr_t * ))(& opj_jp2_set_decoded_resolution_factor);
#line 431
  tmp___0 = opj_jp2_create(1);
#line 431
  l_codec->m_codec = (void *)tmp___0;
  }
#line 433
  if (! l_codec->m_codec) {
    {
#line 434
    free((void *)l_codec);
    }
#line 435
    return ((opj_codec_t *)0);
  }
#line 438
  goto switch_break;
  switch_default: 
  {
#line 442
  free((void *)l_codec);
  }
#line 443
  return ((opj_codec_t *)0);
  switch_break: 
  {
#line 446
  opj_set_default_event_handler(& l_codec->m_event_mgr);
  }
#line 447
  return ((opj_codec_t *)l_codec);
}
}
#line 450 "/root/patron/new_22/src/lib/openjp2/openjpeg.c"
void opj_set_default_decoder_parameters(opj_dparameters_t *parameters ) 
{ 


  {
#line 451
  if (parameters) {
    {
#line 452
    memset((void *)parameters, 0, sizeof(opj_dparameters_t ));
#line 454
    parameters->cp_layer = (OPJ_UINT32 )0;
#line 455
    parameters->cp_reduce = (OPJ_UINT32 )0;
#line 457
    parameters->decod_format = -1;
#line 458
    parameters->cod_format = -1;
#line 459
    parameters->flags = 0U;
    }
  }
#line 462
  return;
}
}
#line 470 "/root/patron/new_22/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_setup_decoder(opj_codec_t *p_codec , opj_dparameters_t *parameters ) 
{ 
  opj_codec_private_t *l_codec ;

  {
#line 474
  if (p_codec) {
#line 474
    if (parameters) {
#line 475
      l_codec = (opj_codec_private_t *)p_codec;
#line 477
      if (! l_codec->is_decompressor) {
        {
#line 478
        opj_event_msg(& l_codec->m_event_mgr, 1, "Codec provided to the opj_setup_decoder function is not a decompressor handler.\n\300/a\211\202U");
        }
#line 480
        return (0);
      }
      {
#line 483
      (*(l_codec->m_codec_data.m_decompression.opj_setup_decoder))(l_codec->m_codec,
                                                                   parameters);
      }
#line 485
      return (1);
    }
  }
#line 487
  return (0);
}
}
#line 490 "/root/patron/new_22/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_read_header(opj_stream_t *p_stream , opj_codec_t *p_codec , opj_image_t **p_image ) 
{ 
  opj_codec_private_t *l_codec ;
  opj_stream_private_t *l_stream ;
  OPJ_BOOL __cil_tmp6 ;

  {
#line 494
  if (p_codec) {
#line 494
    if (p_stream) {
#line 495
      l_codec = (opj_codec_private_t *)p_codec;
#line 496
      l_stream = (opj_stream_private_t *)p_stream;
#line 498
      if (! l_codec->is_decompressor) {
        {
#line 499
        opj_event_msg(& l_codec->m_event_mgr, 1, "Codec provided to the opj_read_header function is not a decompressor handler.\n");
        }
#line 501
        return (0);
      }
      {
#line 504
      __cil_tmp6 = (*(l_codec->m_codec_data.m_decompression.opj_read_header))(l_stream,
                                                                              l_codec->m_codec,
                                                                              p_image,
                                                                              & l_codec->m_event_mgr);
      }
#line 504
      return (__cil_tmp6);
    }
  }
#line 510
  return (0);
}
}
#line 513 "/root/patron/new_22/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_decode(opj_codec_t *p_codec , opj_stream_t *p_stream , opj_image_t *p_image ) 
{ 
  opj_codec_private_t *l_codec ;
  opj_stream_private_t *l_stream ;
  OPJ_BOOL __cil_tmp6 ;

  {
#line 517
  if (p_codec) {
#line 517
    if (p_stream) {
#line 518
      l_codec = (opj_codec_private_t *)p_codec;
#line 519
      l_stream = (opj_stream_private_t *)p_stream;
#line 521
      if (! l_codec->is_decompressor) {
#line 522
        return (0);
      }
      {
#line 525
      __cil_tmp6 = (*(l_codec->m_codec_data.m_decompression.opj_decode))(l_codec->m_codec,
                                                                         l_stream,
                                                                         p_image,
                                                                         & l_codec->m_event_mgr);
      }
#line 525
      return (__cil_tmp6);
    }
  }
#line 531
  return (0);
}
}
#line 534 "/root/patron/new_22/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_set_decode_area(opj_codec_t *p_codec , opj_image_t *p_image , OPJ_INT32 p_start_x ,
                             OPJ_INT32 p_start_y , OPJ_INT32 p_end_x , OPJ_INT32 p_end_y ) 
{ 
  opj_codec_private_t *l_codec ;
  OPJ_BOOL __cil_tmp8 ;

  {
#line 540
  if (p_codec) {
#line 541
    l_codec = (opj_codec_private_t *)p_codec;
#line 543
    if (! l_codec->is_decompressor) {
#line 544
      return (0);
    }
    {
#line 547
    __cil_tmp8 = (*(l_codec->m_codec_data.m_decompression.opj_set_decode_area))(l_codec->m_codec,
                                                                                p_image,
                                                                                p_start_x,
                                                                                p_start_y,
                                                                                p_end_x,
                                                                                p_end_y,
                                                                                & l_codec->m_event_mgr);
    }
#line 547
    return (__cil_tmp8);
  }
#line 553
  return (0);
}
}
#line 556 "/root/patron/new_22/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_read_tile_header(opj_codec_t *p_codec , opj_stream_t *p_stream , OPJ_UINT32 *p_tile_index ,
                              OPJ_UINT32 *p_data_size , OPJ_INT32 *p_tile_x0 , OPJ_INT32 *p_tile_y0 ,
                              OPJ_INT32 *p_tile_x1 , OPJ_INT32 *p_tile_y1 , OPJ_UINT32 *p_nb_comps ,
                              OPJ_BOOL *p_should_go_on ) 
{ 
  opj_codec_private_t *l_codec ;
  opj_stream_private_t *l_stream ;
  OPJ_BOOL __cil_tmp13 ;

  {
#line 565
  if (p_codec) {
#line 565
    if (p_stream) {
#line 565
      if (p_data_size) {
#line 565
        if (p_tile_index) {
#line 566
          l_codec = (opj_codec_private_t *)p_codec;
#line 567
          l_stream = (opj_stream_private_t *)p_stream;
#line 569
          if (! l_codec->is_decompressor) {
#line 570
            return (0);
          }
          {
#line 573
          __cil_tmp13 = (*(l_codec->m_codec_data.m_decompression.opj_read_tile_header))(l_codec->m_codec,
                                                                                        p_tile_index,
                                                                                        p_data_size,
                                                                                        p_tile_x0,
                                                                                        p_tile_y0,
                                                                                        p_tile_x1,
                                                                                        p_tile_y1,
                                                                                        p_nb_comps,
                                                                                        p_should_go_on,
                                                                                        l_stream,
                                                                                        & l_codec->m_event_mgr);
          }
#line 573
          return (__cil_tmp13);
        }
      }
    }
  }
#line 583
  return (0);
}
}
#line 586 "/root/patron/new_22/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_decode_tile_data(opj_codec_t *p_codec , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                              OPJ_UINT32 p_data_size , opj_stream_t *p_stream ) 
{ 
  opj_codec_private_t *l_codec ;
  opj_stream_private_t *l_stream ;
  OPJ_BOOL __cil_tmp8 ;

  {
#line 593
  if (p_codec) {
#line 593
    if (p_data) {
#line 593
      if (p_stream) {
#line 594
        l_codec = (opj_codec_private_t *)p_codec;
#line 595
        l_stream = (opj_stream_private_t *)p_stream;
#line 597
        if (! l_codec->is_decompressor) {
#line 598
          return (0);
        }
        {
#line 601
        __cil_tmp8 = (*(l_codec->m_codec_data.m_decompression.opj_decode_tile_data))(l_codec->m_codec,
                                                                                     p_tile_index,
                                                                                     p_data,
                                                                                     p_data_size,
                                                                                     l_stream,
                                                                                     & l_codec->m_event_mgr);
        }
#line 601
        return (__cil_tmp8);
      }
    }
  }
#line 608
  return (0);
}
}
#line 611 "/root/patron/new_22/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_get_decoded_tile(opj_codec_t *p_codec , opj_stream_t *p_stream , opj_image_t *p_image ,
                              OPJ_UINT32 tile_index ) 
{ 
  opj_codec_private_t *l_codec ;
  opj_stream_private_t *l_stream ;
  OPJ_BOOL __cil_tmp7 ;

  {
#line 616
  if (p_codec) {
#line 616
    if (p_stream) {
#line 617
      l_codec = (opj_codec_private_t *)p_codec;
#line 618
      l_stream = (opj_stream_private_t *)p_stream;
#line 620
      if (! l_codec->is_decompressor) {
#line 621
        return (0);
      }
      {
#line 624
      __cil_tmp7 = (*(l_codec->m_codec_data.m_decompression.opj_get_decoded_tile))(l_codec->m_codec,
                                                                                   l_stream,
                                                                                   p_image,
                                                                                   & l_codec->m_event_mgr,
                                                                                   tile_index);
      }
#line 624
      return (__cil_tmp7);
    }
  }
#line 631
  return (0);
}
}
#line 634 "/root/patron/new_22/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_set_decoded_resolution_factor(opj_codec_t *p_codec , OPJ_UINT32 res_factor ) 
{ 
  opj_codec_private_t *l_codec ;

  {
#line 637
  l_codec = (opj_codec_private_t *)p_codec;
#line 639
  if (! l_codec) {
    {
#line 640
    fprintf(stderr, "[ERROR] Input parameters of the setup_decoder function are incorrect.\n");
    }
#line 641
    return (0);
  }
  {
#line 644
  (*(l_codec->m_codec_data.m_decompression.opj_set_decoded_resolution_factor))(l_codec->m_codec,
                                                                               res_factor,
                                                                               & l_codec->m_event_mgr);
  }
#line 647
  return (1);
}
}
#line 653 "/root/patron/new_22/src/lib/openjp2/openjpeg.c"
opj_codec_t *opj_create_compress(OPJ_CODEC_FORMAT p_format ) 
{ 
  opj_codec_private_t *l_codec ;
  void *__cil_tmp3 ;
  opj_j2k_t *tmp ;
  opj_jp2_t *tmp___0 ;

  {
  {
#line 655
  l_codec = (opj_codec_private_t *)0;
#line 657
  __cil_tmp3 = calloc(1UL, sizeof(opj_codec_private_t ));
#line 657
  l_codec = (opj_codec_private_t *)__cil_tmp3;
  }
#line 658
  if (! l_codec) {
#line 659
    return ((opj_codec_t *)0);
  }
  {
#line 661
  memset((void *)l_codec, 0, sizeof(opj_codec_private_t ));
#line 663
  l_codec->is_decompressor = 0;
  }
#line 666
  if ((int )p_format == 0) {
#line 666
    goto case_0;
  }
#line 702
  if ((int )p_format == 2) {
#line 702
    goto case_2;
  }
#line 741
  goto switch_default;
  case_0: 
  {
#line 667
  l_codec->m_codec_data.m_compression.opj_encode = (OPJ_BOOL (*)(void * , struct opj_stream_private * ,
                                                                 struct opj_event_mgr * ))(& opj_j2k_encode);
#line 671
  l_codec->m_codec_data.m_compression.opj_end_compress = (OPJ_BOOL (*)(void * , struct opj_stream_private * ,
                                                                       struct opj_event_mgr * ))(& opj_j2k_end_compress);
#line 675
  l_codec->m_codec_data.m_compression.opj_start_compress = (OPJ_BOOL (*)(void * ,
                                                                         struct opj_stream_private * ,
                                                                         struct opj_image * ,
                                                                         struct opj_event_mgr * ))(& opj_j2k_start_compress);
#line 680
  l_codec->m_codec_data.m_compression.opj_write_tile = (OPJ_BOOL (*)(void * , OPJ_UINT32  ,
                                                                     OPJ_BYTE * ,
                                                                     OPJ_UINT32  ,
                                                                     struct opj_stream_private * ,
                                                                     struct opj_event_mgr * ))(& opj_j2k_write_tile);
#line 687
  l_codec->m_codec_data.m_compression.opj_destroy = (void (*)(void * ))(& opj_j2k_destroy);
#line 689
  l_codec->m_codec_data.m_compression.opj_setup_encoder = (void (*)(void * , opj_cparameters_t * ,
                                                                    struct opj_image * ,
                                                                    struct opj_event_mgr * ))(& opj_j2k_setup_encoder);
#line 694
  tmp = opj_j2k_create_compress();
#line 694
  l_codec->m_codec = (void *)tmp;
  }
#line 695
  if (! l_codec->m_codec) {
    {
#line 696
    free((void *)l_codec);
    }
#line 697
    return ((opj_codec_t *)0);
  }
#line 700
  goto switch_break;
  case_2: 
  {
#line 704
  l_codec->m_codec_data.m_compression.opj_encode = (OPJ_BOOL (*)(void * , struct opj_stream_private * ,
                                                                 struct opj_event_mgr * ))(& opj_jp2_encode);
#line 708
  l_codec->m_codec_data.m_compression.opj_end_compress = (OPJ_BOOL (*)(void * , struct opj_stream_private * ,
                                                                       struct opj_event_mgr * ))(& opj_jp2_end_compress);
#line 712
  l_codec->m_codec_data.m_compression.opj_start_compress = (OPJ_BOOL (*)(void * ,
                                                                         struct opj_stream_private * ,
                                                                         struct opj_image * ,
                                                                         struct opj_event_mgr * ))(& opj_jp2_start_compress);
#line 717
  l_codec->m_codec_data.m_compression.opj_write_tile = (OPJ_BOOL (*)(void * , OPJ_UINT32  ,
                                                                     OPJ_BYTE * ,
                                                                     OPJ_UINT32  ,
                                                                     struct opj_stream_private * ,
                                                                     struct opj_event_mgr * ))(& opj_jp2_write_tile);
#line 724
  l_codec->m_codec_data.m_compression.opj_destroy = (void (*)(void * ))(& opj_jp2_destroy);
#line 726
  l_codec->m_codec_data.m_compression.opj_setup_encoder = (void (*)(void * , opj_cparameters_t * ,
                                                                    struct opj_image * ,
                                                                    struct opj_event_mgr * ))(& opj_jp2_setup_encoder);
#line 731
  tmp___0 = opj_jp2_create(0);
#line 731
  l_codec->m_codec = (void *)tmp___0;
  }
#line 732
  if (! l_codec->m_codec) {
    {
#line 733
    free((void *)l_codec);
    }
#line 734
    return ((opj_codec_t *)0);
  }
#line 737
  goto switch_break;
  switch_default: 
  {
#line 742
  free((void *)l_codec);
  }
#line 743
  return ((opj_codec_t *)0);
  switch_break: 
  {
#line 746
  opj_set_default_event_handler(& l_codec->m_event_mgr);
  }
#line 747
  return ((opj_codec_t *)l_codec);
}
}
#line 750 "/root/patron/new_22/src/lib/openjp2/openjpeg.c"
void opj_set_default_encoder_parameters(opj_cparameters_t *parameters ) 
{ 


  {
#line 751
  if (parameters) {
    {
#line 752
    memset((void *)parameters, 0, sizeof(opj_cparameters_t ));
#line 754
    parameters->cp_cinema = (OPJ_CINEMA_MODE )0;
#line 755
    parameters->max_comp_size = 0;
#line 756
    parameters->numresolution = 6;
#line 757
    parameters->cp_rsiz = (OPJ_RSIZ_CAPABILITIES )0;
#line 758
    parameters->cblockw_init = 64;
#line 759
    parameters->cblockh_init = 64;
#line 760
    parameters->prog_order = (OPJ_PROG_ORDER )0;
#line 761
    parameters->roi_compno = -1;
#line 762
    parameters->subsampling_dx = 1;
#line 763
    parameters->subsampling_dy = 1;
#line 764
    parameters->tp_on = (char)0;
#line 765
    parameters->decod_format = -1;
#line 766
    parameters->cod_format = -1;
#line 767
    parameters->tcp_rates[0] = (float )0;
#line 768
    parameters->tcp_numlayers = 0;
#line 769
    parameters->cp_disto_alloc = 0;
#line 770
    parameters->cp_fixed_alloc = 0;
#line 771
    parameters->cp_fixed_quality = 0;
#line 772
    parameters->jpip_on = 0;
    }
  }
#line 775
  return;
}
}
#line 808 "/root/patron/new_22/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_setup_encoder(opj_codec_t *p_codec , opj_cparameters_t *parameters ,
                           opj_image_t *p_image ) 
{ 
  opj_codec_private_t *l_codec ;

  {
#line 812
  if (p_codec) {
#line 812
    if (parameters) {
#line 812
      if (p_image) {
#line 813
        l_codec = (opj_codec_private_t *)p_codec;
#line 815
        if (! l_codec->is_decompressor) {
          {
#line 816
          (*(l_codec->m_codec_data.m_compression.opj_setup_encoder))(l_codec->m_codec,
                                                                     parameters, p_image,
                                                                     & l_codec->m_event_mgr);
          }
#line 820
          return (1);
        }
      }
    }
  }
#line 824
  return (0);
}
}
#line 827 "/root/patron/new_22/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_start_compress(opj_codec_t *p_codec , opj_image_t *p_image , opj_stream_t *p_stream ) 
{ 
  opj_codec_private_t *l_codec ;
  opj_stream_private_t *l_stream ;
  OPJ_BOOL __cil_tmp6 ;

  {
#line 831
  if (p_codec) {
#line 831
    if (p_stream) {
#line 832
      l_codec = (opj_codec_private_t *)p_codec;
#line 833
      l_stream = (opj_stream_private_t *)p_stream;
#line 835
      if (! l_codec->is_decompressor) {
        {
#line 836
        __cil_tmp6 = (*(l_codec->m_codec_data.m_compression.opj_start_compress))(l_codec->m_codec,
                                                                                 l_stream,
                                                                                 p_image,
                                                                                 & l_codec->m_event_mgr);
        }
#line 836
        return (__cil_tmp6);
      }
    }
  }
#line 843
  return (0);
}
}
#line 846 "/root/patron/new_22/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_encode(opj_codec_t *p_info , opj_stream_t *p_stream ) 
{ 
  opj_codec_private_t *l_codec ;
  opj_stream_private_t *l_stream ;
  OPJ_BOOL __cil_tmp5 ;

  {
#line 848
  if (p_info) {
#line 848
    if (p_stream) {
#line 849
      l_codec = (opj_codec_private_t *)p_info;
#line 850
      l_stream = (opj_stream_private_t *)p_stream;
#line 852
      if (! l_codec->is_decompressor) {
        {
#line 853
        __cil_tmp5 = (*(l_codec->m_codec_data.m_compression.opj_encode))(l_codec->m_codec,
                                                                         l_stream,
                                                                         & l_codec->m_event_mgr);
        }
#line 853
        return (__cil_tmp5);
      }
    }
  }
#line 859
  return (0);
}
}
#line 863 "/root/patron/new_22/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_end_compress(opj_codec_t *p_codec , opj_stream_t *p_stream ) 
{ 
  opj_codec_private_t *l_codec ;
  opj_stream_private_t *l_stream ;
  OPJ_BOOL __cil_tmp5 ;

  {
#line 866
  if (p_codec) {
#line 866
    if (p_stream) {
#line 867
      l_codec = (opj_codec_private_t *)p_codec;
#line 868
      l_stream = (opj_stream_private_t *)p_stream;
#line 870
      if (! l_codec->is_decompressor) {
        {
#line 871
        __cil_tmp5 = (*(l_codec->m_codec_data.m_compression.opj_end_compress))(l_codec->m_codec,
                                                                               l_stream,
                                                                               & l_codec->m_event_mgr);
        }
#line 871
        return (__cil_tmp5);
      }
    }
  }
#line 876
  return (0);
}
}
#line 880 "/root/patron/new_22/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_end_decompress(opj_codec_t *p_codec , opj_stream_t *p_stream ) 
{ 
  opj_codec_private_t *l_codec ;
  opj_stream_private_t *l_stream ;
  OPJ_BOOL __cil_tmp5 ;

  {
#line 883
  if (p_codec) {
#line 883
    if (p_stream) {
#line 884
      l_codec = (opj_codec_private_t *)p_codec;
#line 885
      l_stream = (opj_stream_private_t *)p_stream;
#line 887
      if (! l_codec->is_decompressor) {
#line 888
        return (0);
      }
      {
#line 891
      __cil_tmp5 = (*(l_codec->m_codec_data.m_decompression.opj_end_decompress))(l_codec->m_codec,
                                                                                 l_stream,
                                                                                 & l_codec->m_event_mgr);
      }
#line 891
      return (__cil_tmp5);
    }
  }
#line 896
  return (0);
}
}
#line 899 "/root/patron/new_22/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_set_MCT(opj_cparameters_t *parameters , OPJ_FLOAT32 *pEncodingMatrix ,
                     OPJ_INT32 *p_dc_shift , OPJ_UINT32 pNbComp ) 
{ 
  OPJ_UINT32 l_matrix_size ;
  OPJ_UINT32 l_dc_shift_size ;
  OPJ_UINT32 l_mct_total_size ;
  OPJ_INT32 rsiz ;

  {
  {
#line 903
  l_matrix_size = (OPJ_UINT32 )((unsigned long )(pNbComp * pNbComp) * sizeof(OPJ_FLOAT32 ));
#line 904
  l_dc_shift_size = (OPJ_UINT32 )((unsigned long )pNbComp * sizeof(OPJ_INT32 ));
#line 905
  l_mct_total_size = l_matrix_size + l_dc_shift_size;
#line 908
  rsiz = (OPJ_INT32 )parameters->cp_rsiz | 33024;
#line 909
  parameters->cp_rsiz = (OPJ_RSIZ_CAPABILITIES )rsiz;
#line 910
  parameters->irreversible = 1;
#line 913
  parameters->tcp_mct = (char)2;
#line 914
  parameters->mct_data = malloc((unsigned long )l_mct_total_size);
  }
#line 915
  if (! parameters->mct_data) {
#line 916
    return (0);
  }
  {
#line 919
  memcpy(parameters->mct_data, (void const   *)pEncodingMatrix, (unsigned long )l_matrix_size);
#line 920
  memcpy((void *)((OPJ_BYTE *)parameters->mct_data + l_matrix_size), (void const   *)p_dc_shift,
         (unsigned long )l_dc_shift_size);
  }
#line 922
  return (1);
}
}
#line 925 "/root/patron/new_22/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_write_tile(opj_codec_t *p_codec , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                        OPJ_UINT32 p_data_size , opj_stream_t *p_stream ) 
{ 
  opj_codec_private_t *l_codec ;
  opj_stream_private_t *l_stream ;
  OPJ_BOOL __cil_tmp8 ;

  {
#line 931
  if (p_codec) {
#line 931
    if (p_stream) {
#line 931
      if (p_data) {
#line 932
        l_codec = (opj_codec_private_t *)p_codec;
#line 933
        l_stream = (opj_stream_private_t *)p_stream;
#line 935
        if (l_codec->is_decompressor) {
#line 936
          return (0);
        }
        {
#line 939
        __cil_tmp8 = (*(l_codec->m_codec_data.m_compression.opj_write_tile))(l_codec->m_codec,
                                                                             p_tile_index,
                                                                             p_data,
                                                                             p_data_size,
                                                                             l_stream,
                                                                             & l_codec->m_event_mgr);
        }
#line 939
        return (__cil_tmp8);
      }
    }
  }
#line 947
  return (0);
}
}
#line 952 "/root/patron/new_22/src/lib/openjp2/openjpeg.c"
void opj_destroy_codec(opj_codec_t *p_codec ) 
{ 
  opj_codec_private_t *l_codec ;

  {
#line 954
  if (p_codec) {
#line 955
    l_codec = (opj_codec_private_t *)p_codec;
#line 957
    if (l_codec->is_decompressor) {
      {
#line 958
      (*(l_codec->m_codec_data.m_decompression.opj_destroy))(l_codec->m_codec);
      }
    } else {
      {
#line 961
      (*(l_codec->m_codec_data.m_compression.opj_destroy))(l_codec->m_codec);
      }
    }
    {
#line 964
    l_codec->m_codec = (void *)0;
#line 965
    free((void *)l_codec);
    }
  }
#line 968
  return;
}
}
#line 971 "/root/patron/new_22/src/lib/openjp2/openjpeg.c"
void opj_dump_codec(opj_codec_t *p_codec , OPJ_INT32 info_flag , FILE *output_stream ) 
{ 
  opj_codec_private_t *l_codec ;

  {
#line 975
  if (p_codec) {
    {
#line 976
    l_codec = (opj_codec_private_t *)p_codec;
#line 978
    (*(l_codec->opj_dump_codec))(l_codec->m_codec, info_flag, output_stream);
    }
#line 979
    return;
  }
  {
#line 982
  fprintf(stderr, "[ERROR] Input parameter of the dump_codec function are incorrect.\nb\211\202U");
  }
#line 983
  return;
}
}
#line 986 "/root/patron/new_22/src/lib/openjp2/openjpeg.c"
opj_codestream_info_v2_t *opj_get_cstr_info(opj_codec_t *p_codec ) 
{ 
  opj_codec_private_t *l_codec ;
  opj_codestream_info_v2_t *__cil_tmp3 ;

  {
#line 988
  if (p_codec) {
    {
#line 989
    l_codec = (opj_codec_private_t *)p_codec;
#line 991
    __cil_tmp3 = (*(l_codec->opj_get_codec_info))(l_codec->m_codec);
    }
#line 991
    return (__cil_tmp3);
  }
#line 994
  return ((opj_codestream_info_v2_t *)((void *)0));
}
}
#line 997 "/root/patron/new_22/src/lib/openjp2/openjpeg.c"
void opj_destroy_cstr_info(opj_codestream_info_v2_t **cstr_info ) 
{ 


  {
#line 998
  if (cstr_info) {
#line 1000
    if ((*cstr_info)->m_default_tile_info.tccp_info) {
      {
#line 1001
      free((void *)(*cstr_info)->m_default_tile_info.tccp_info);
      }
    }
    {
#line 1008
    free((void *)*cstr_info);
#line 1009
    *cstr_info = (opj_codestream_info_v2_t *)((void *)0);
    }
  }
#line 1012
  return;
}
}
#line 1013 "/root/patron/new_22/src/lib/openjp2/openjpeg.c"
opj_codestream_index_t *opj_get_cstr_index(opj_codec_t *p_codec ) 
{ 
  opj_codec_private_t *l_codec ;
  opj_codestream_index_t *__cil_tmp3 ;

  {
#line 1015
  if (p_codec) {
    {
#line 1016
    l_codec = (opj_codec_private_t *)p_codec;
#line 1018
    __cil_tmp3 = (*(l_codec->opj_get_codec_index))(l_codec->m_codec);
    }
#line 1018
    return (__cil_tmp3);
  }
#line 1021
  return ((opj_codestream_index_t *)((void *)0));
}
}
#line 1024 "/root/patron/new_22/src/lib/openjp2/openjpeg.c"
void opj_destroy_cstr_index(opj_codestream_index_t **p_cstr_index ) 
{ 


  {
#line 1026
  if (*p_cstr_index) {
    {
#line 1027
    j2k_destroy_cstr_index(*p_cstr_index);
#line 1028
    *p_cstr_index = (opj_codestream_index_t *)((void *)0);
    }
  }
#line 1031
  return;
}
}
#line 1033 "/root/patron/new_22/src/lib/openjp2/openjpeg.c"
opj_stream_t *opj_stream_create_default_file_stream(FILE *p_file , OPJ_BOOL p_is_read_stream ) 
{ 
  opj_stream_t *__cil_tmp3 ;

  {
  {
#line 1035
  __cil_tmp3 = opj_stream_create_file_stream(p_file, (OPJ_SIZE_T )1048576, p_is_read_stream);
  }
#line 1035
  return (__cil_tmp3);
}
}
#line 1038 "/root/patron/new_22/src/lib/openjp2/openjpeg.c"
opj_stream_t *opj_stream_create_default_file_stream_v3(char const   *fname , OPJ_BOOL p_is_read_stream ) 
{ 
  opj_stream_t *__cil_tmp3 ;

  {
  {
#line 1040
  __cil_tmp3 = opj_stream_create_file_stream_v3(fname, (OPJ_SIZE_T )1048576, p_is_read_stream);
  }
#line 1040
  return (__cil_tmp3);
}
}
#line 1043 "/root/patron/new_22/src/lib/openjp2/openjpeg.c"
opj_stream_t *opj_stream_create_file_stream(FILE *p_file , OPJ_SIZE_T p_size , OPJ_BOOL p_is_read_stream ) 
{ 
  opj_stream_t *l_stream ;
  OPJ_UINT64 __cil_tmp6 ;

  {
#line 1047
  l_stream = (opj_stream_t *)0;
#line 1049
  if (! p_file) {
#line 1050
    return ((opj_stream_t *)((void *)0));
  }
  {
#line 1053
  l_stream = opj_stream_create(p_size, p_is_read_stream);
  }
#line 1054
  if (! l_stream) {
#line 1055
    return ((opj_stream_t *)((void *)0));
  }
  {
#line 1058
  opj_stream_set_user_data(l_stream, (void *)p_file);
#line 1059
  __cil_tmp6 = opj_get_data_length_from_file(p_file);
#line 1059
  opj_stream_set_user_data_length(l_stream, __cil_tmp6);
#line 1060
  opj_stream_set_read_function(l_stream, (OPJ_SIZE_T (*)(void * , OPJ_SIZE_T  , void * ))(& opj_read_from_file));
#line 1061
  opj_stream_set_write_function(l_stream, (OPJ_SIZE_T (*)(void * , OPJ_SIZE_T  , void * ))(& opj_write_from_file));
#line 1062
  opj_stream_set_skip_function(l_stream, (OPJ_OFF_T (*)(OPJ_OFF_T  , void * ))(& opj_skip_from_file));
#line 1063
  opj_stream_set_seek_function(l_stream, (OPJ_BOOL (*)(OPJ_OFF_T  , void * ))(& opj_seek_from_file));
  }
#line 1065
  return (l_stream);
}
}
#line 1068 "/root/patron/new_22/src/lib/openjp2/openjpeg.c"
opj_stream_t *opj_stream_create_file_stream_v3(char const   *fname , OPJ_SIZE_T p_size ,
                                               OPJ_BOOL p_is_read_stream ) 
{ 
  opj_stream_t *l_stream ;
  FILE *p_file ;
  char const   *mode ;
  OPJ_UINT64 __cil_tmp9 ;

  {
#line 1073
  l_stream = (opj_stream_t *)0;
#line 1077
  if (! fname) {
#line 1078
    return ((opj_stream_t *)((void *)0));
  }
#line 1081
  if (p_is_read_stream) {
    {
#line 1081
    strcpy((char *)mode, "rb");
    }
  } else {
    {
#line 1081
    strcpy((char *)mode, "wb");
    }
  }
  {
#line 1083
  p_file = fopen(fname, mode);
  }
#line 1085
  if (! p_file) {
#line 1086
    return ((opj_stream_t *)((void *)0));
  }
  {
#line 1089
  l_stream = opj_stream_create(p_size, p_is_read_stream);
  }
#line 1090
  if (! l_stream) {
    {
#line 1091
    fclose(p_file);
    }
#line 1092
    return ((opj_stream_t *)((void *)0));
  }
  {
#line 1095
  opj_stream_set_user_data(l_stream, (void *)p_file);
#line 1096
  __cil_tmp9 = opj_get_data_length_from_file(p_file);
#line 1096
  opj_stream_set_user_data_length(l_stream, __cil_tmp9);
#line 1097
  opj_stream_set_read_function(l_stream, (OPJ_SIZE_T (*)(void * , OPJ_SIZE_T  , void * ))(& opj_read_from_file));
#line 1098
  opj_stream_set_write_function(l_stream, (OPJ_SIZE_T (*)(void * , OPJ_SIZE_T  , void * ))(& opj_write_from_file));
#line 1099
  opj_stream_set_skip_function(l_stream, (OPJ_OFF_T (*)(OPJ_OFF_T  , void * ))(& opj_skip_from_file));
#line 1100
  opj_stream_set_seek_function(l_stream, (OPJ_BOOL (*)(OPJ_OFF_T  , void * ))(& opj_seek_from_file));
  }
#line 1102
  return (l_stream);
}
}
#line 46 "/root/patron/new_22/src/lib/openjp2/mqc.c"
void opj_mqc_byteout(opj_mqc_t *mqc ) ;
#line 51
void opj_mqc_renorme(opj_mqc_t *mqc ) ;
#line 56
void opj_mqc_codemps(opj_mqc_t *mqc ) ;
#line 61
void opj_mqc_codelps(opj_mqc_t *mqc ) ;
#line 66
void opj_mqc_setbits(opj_mqc_t *mqc ) ;
#line 72
__inline static OPJ_INT32 opj_mqc_mpsexchange(opj_mqc_t *mqc ) ;
#line 78
__inline static OPJ_INT32 opj_mqc_lpsexchange(opj_mqc_t *mqc ) ;
#line 83
static void opj_mqc_bytein(opj_mqc_t *mqc ) ;
#line 88
__inline static void opj_mqc_renormd(opj_mqc_t *mqc ) ;
#line 96 "/root/patron/new_22/src/lib/openjp2/mqc.c"
static opj_mqc_state_t mqc_states[94]  = 
#line 96
  {      {(OPJ_UINT32 )22017, (OPJ_UINT32 )0, & mqc_states[2], & mqc_states[3]}, 
        {(OPJ_UINT32 )22017, (OPJ_UINT32 )1, & mqc_states[3], & mqc_states[2]}, 
        {(OPJ_UINT32 )13313, (OPJ_UINT32 )0, & mqc_states[4], & mqc_states[12]}, 
        {(OPJ_UINT32 )13313, (OPJ_UINT32 )1, & mqc_states[5], & mqc_states[13]}, 
        {(OPJ_UINT32 )6145, (OPJ_UINT32 )0, & mqc_states[6], & mqc_states[18]}, 
        {(OPJ_UINT32 )6145, (OPJ_UINT32 )1, & mqc_states[7], & mqc_states[19]}, 
        {(OPJ_UINT32 )2753, (OPJ_UINT32 )0, & mqc_states[8], & mqc_states[24]}, 
        {(OPJ_UINT32 )2753, (OPJ_UINT32 )1, & mqc_states[9], & mqc_states[25]}, 
        {(OPJ_UINT32 )1313, (OPJ_UINT32 )0, & mqc_states[10], & mqc_states[58]}, 
        {(OPJ_UINT32 )1313, (OPJ_UINT32 )1, & mqc_states[11], & mqc_states[59]}, 
        {(OPJ_UINT32 )545, (OPJ_UINT32 )0, & mqc_states[76], & mqc_states[66]}, 
        {(OPJ_UINT32 )545, (OPJ_UINT32 )1, & mqc_states[77], & mqc_states[67]}, 
        {(OPJ_UINT32 )22017, (OPJ_UINT32 )0, & mqc_states[14], & mqc_states[13]}, 
        {(OPJ_UINT32 )22017, (OPJ_UINT32 )1, & mqc_states[15], & mqc_states[12]}, 
        {(OPJ_UINT32 )21505, (OPJ_UINT32 )0, & mqc_states[16], & mqc_states[28]}, 
        {(OPJ_UINT32 )21505, (OPJ_UINT32 )1, & mqc_states[17], & mqc_states[29]}, 
        {(OPJ_UINT32 )18433, (OPJ_UINT32 )0, & mqc_states[18], & mqc_states[28]}, 
        {(OPJ_UINT32 )18433, (OPJ_UINT32 )1, & mqc_states[19], & mqc_states[29]}, 
        {(OPJ_UINT32 )14337, (OPJ_UINT32 )0, & mqc_states[20], & mqc_states[28]}, 
        {(OPJ_UINT32 )14337, (OPJ_UINT32 )1, & mqc_states[21], & mqc_states[29]}, 
        {(OPJ_UINT32 )12289, (OPJ_UINT32 )0, & mqc_states[22], & mqc_states[34]}, 
        {(OPJ_UINT32 )12289, (OPJ_UINT32 )1, & mqc_states[23], & mqc_states[35]}, 
        {(OPJ_UINT32 )9217, (OPJ_UINT32 )0, & mqc_states[24], & mqc_states[36]}, 
        {(OPJ_UINT32 )9217, (OPJ_UINT32 )1, & mqc_states[25], & mqc_states[37]}, 
        {(OPJ_UINT32 )7169, (OPJ_UINT32 )0, & mqc_states[26], & mqc_states[40]}, 
        {(OPJ_UINT32 )7169, (OPJ_UINT32 )1, & mqc_states[27], & mqc_states[41]}, 
        {(OPJ_UINT32 )5633, (OPJ_UINT32 )0, & mqc_states[58], & mqc_states[42]}, 
        {(OPJ_UINT32 )5633, (OPJ_UINT32 )1, & mqc_states[59], & mqc_states[43]}, 
        {(OPJ_UINT32 )22017, (OPJ_UINT32 )0, & mqc_states[30], & mqc_states[29]}, 
        {(OPJ_UINT32 )22017, (OPJ_UINT32 )1, & mqc_states[31], & mqc_states[28]}, 
        {(OPJ_UINT32 )21505, (OPJ_UINT32 )0, & mqc_states[32], & mqc_states[28]}, 
        {(OPJ_UINT32 )21505, (OPJ_UINT32 )1, & mqc_states[33], & mqc_states[29]}, 
        {(OPJ_UINT32 )20737, (OPJ_UINT32 )0, & mqc_states[34], & mqc_states[30]}, 
        {(OPJ_UINT32 )20737, (OPJ_UINT32 )1, & mqc_states[35], & mqc_states[31]}, 
        {(OPJ_UINT32 )18433, (OPJ_UINT32 )0, & mqc_states[36], & mqc_states[32]}, 
        {(OPJ_UINT32 )18433, (OPJ_UINT32 )1, & mqc_states[37], & mqc_states[33]}, 
        {(OPJ_UINT32 )14337, (OPJ_UINT32 )0, & mqc_states[38], & mqc_states[34]}, 
        {(OPJ_UINT32 )14337, (OPJ_UINT32 )1, & mqc_states[39], & mqc_states[35]}, 
        {(OPJ_UINT32 )13313, (OPJ_UINT32 )0, & mqc_states[40], & mqc_states[36]}, 
        {(OPJ_UINT32 )13313, (OPJ_UINT32 )1, & mqc_states[41], & mqc_states[37]}, 
        {(OPJ_UINT32 )12289, (OPJ_UINT32 )0, & mqc_states[42], & mqc_states[38]}, 
        {(OPJ_UINT32 )12289, (OPJ_UINT32 )1, & mqc_states[43], & mqc_states[39]}, 
        {(OPJ_UINT32 )10241, (OPJ_UINT32 )0, & mqc_states[44], & mqc_states[38]}, 
        {(OPJ_UINT32 )10241, (OPJ_UINT32 )1, & mqc_states[45], & mqc_states[39]}, 
        {(OPJ_UINT32 )9217, (OPJ_UINT32 )0, & mqc_states[46], & mqc_states[40]}, 
        {(OPJ_UINT32 )9217, (OPJ_UINT32 )1, & mqc_states[47], & mqc_states[41]}, 
        {(OPJ_UINT32 )8705, (OPJ_UINT32 )0, & mqc_states[48], & mqc_states[42]}, 
        {(OPJ_UINT32 )8705, (OPJ_UINT32 )1, & mqc_states[49], & mqc_states[43]}, 
        {(OPJ_UINT32 )7169, (OPJ_UINT32 )0, & mqc_states[50], & mqc_states[44]}, 
        {(OPJ_UINT32 )7169, (OPJ_UINT32 )1, & mqc_states[51], & mqc_states[45]}, 
        {(OPJ_UINT32 )6145, (OPJ_UINT32 )0, & mqc_states[52], & mqc_states[46]}, 
        {(OPJ_UINT32 )6145, (OPJ_UINT32 )1, & mqc_states[53], & mqc_states[47]}, 
        {(OPJ_UINT32 )5633, (OPJ_UINT32 )0, & mqc_states[54], & mqc_states[48]}, 
        {(OPJ_UINT32 )5633, (OPJ_UINT32 )1, & mqc_states[55], & mqc_states[49]}, 
        {(OPJ_UINT32 )5121, (OPJ_UINT32 )0, & mqc_states[56], & mqc_states[50]}, 
        {(OPJ_UINT32 )5121, (OPJ_UINT32 )1, & mqc_states[57], & mqc_states[51]}, 
        {(OPJ_UINT32 )4609, (OPJ_UINT32 )0, & mqc_states[58], & mqc_states[52]}, 
        {(OPJ_UINT32 )4609, (OPJ_UINT32 )1, & mqc_states[59], & mqc_states[53]}, 
        {(OPJ_UINT32 )4353, (OPJ_UINT32 )0, & mqc_states[60], & mqc_states[54]}, 
        {(OPJ_UINT32 )4353, (OPJ_UINT32 )1, & mqc_states[61], & mqc_states[55]}, 
        {(OPJ_UINT32 )2753, (OPJ_UINT32 )0, & mqc_states[62], & mqc_states[56]}, 
        {(OPJ_UINT32 )2753, (OPJ_UINT32 )1, & mqc_states[63], & mqc_states[57]}, 
        {(OPJ_UINT32 )2497, (OPJ_UINT32 )0, & mqc_states[64], & mqc_states[58]}, 
        {(OPJ_UINT32 )2497, (OPJ_UINT32 )1, & mqc_states[65], & mqc_states[59]}, 
        {(OPJ_UINT32 )2209, (OPJ_UINT32 )0, & mqc_states[66], & mqc_states[60]}, 
        {(OPJ_UINT32 )2209, (OPJ_UINT32 )1, & mqc_states[67], & mqc_states[61]}, 
        {(OPJ_UINT32 )1313, (OPJ_UINT32 )0, & mqc_states[68], & mqc_states[62]}, 
        {(OPJ_UINT32 )1313, (OPJ_UINT32 )1, & mqc_states[69], & mqc_states[63]}, 
        {(OPJ_UINT32 )1089, (OPJ_UINT32 )0, & mqc_states[70], & mqc_states[64]}, 
        {(OPJ_UINT32 )1089, (OPJ_UINT32 )1, & mqc_states[71], & mqc_states[65]}, 
        {(OPJ_UINT32 )673, (OPJ_UINT32 )0, & mqc_states[72], & mqc_states[66]}, 
        {(OPJ_UINT32 )673, (OPJ_UINT32 )1, & mqc_states[73], & mqc_states[67]}, 
        {(OPJ_UINT32 )545, (OPJ_UINT32 )0, & mqc_states[74], & mqc_states[68]}, 
        {(OPJ_UINT32 )545, (OPJ_UINT32 )1, & mqc_states[75], & mqc_states[69]}, 
        {(OPJ_UINT32 )321, (OPJ_UINT32 )0, & mqc_states[76], & mqc_states[70]}, 
        {(OPJ_UINT32 )321, (OPJ_UINT32 )1, & mqc_states[77], & mqc_states[71]}, 
        {(OPJ_UINT32 )273, (OPJ_UINT32 )0, & mqc_states[78], & mqc_states[72]}, 
        {(OPJ_UINT32 )273, (OPJ_UINT32 )1, & mqc_states[79], & mqc_states[73]}, 
        {(OPJ_UINT32 )133, (OPJ_UINT32 )0, & mqc_states[80], & mqc_states[74]}, 
        {(OPJ_UINT32 )133, (OPJ_UINT32 )1, & mqc_states[81], & mqc_states[75]}, 
        {(OPJ_UINT32 )73, (OPJ_UINT32 )0, & mqc_states[82], & mqc_states[76]}, 
        {(OPJ_UINT32 )73, (OPJ_UINT32 )1, & mqc_states[83], & mqc_states[77]}, 
        {(OPJ_UINT32 )37, (OPJ_UINT32 )0, & mqc_states[84], & mqc_states[78]}, 
        {(OPJ_UINT32 )37, (OPJ_UINT32 )1, & mqc_states[85], & mqc_states[79]}, 
        {(OPJ_UINT32 )21, (OPJ_UINT32 )0, & mqc_states[86], & mqc_states[80]}, 
        {(OPJ_UINT32 )21, (OPJ_UINT32 )1, & mqc_states[87], & mqc_states[81]}, 
        {(OPJ_UINT32 )9, (OPJ_UINT32 )0, & mqc_states[88], & mqc_states[82]}, 
        {(OPJ_UINT32 )9, (OPJ_UINT32 )1, & mqc_states[89], & mqc_states[83]}, 
        {(OPJ_UINT32 )5, (OPJ_UINT32 )0, & mqc_states[90], & mqc_states[84]}, 
        {(OPJ_UINT32 )5, (OPJ_UINT32 )1, & mqc_states[91], & mqc_states[85]}, 
        {(OPJ_UINT32 )1, (OPJ_UINT32 )0, & mqc_states[90], & mqc_states[86]}, 
        {(OPJ_UINT32 )1, (OPJ_UINT32 )1, & mqc_states[91], & mqc_states[87]}, 
        {(OPJ_UINT32 )22017, (OPJ_UINT32 )0, & mqc_states[92], & mqc_states[92]}, 
        {(OPJ_UINT32 )22017, (OPJ_UINT32 )1, & mqc_states[93], & mqc_states[93]}};
#line 199 "/root/patron/new_22/src/lib/openjp2/mqc.c"
void opj_mqc_byteout(opj_mqc_t *mqc ) 
{ 


  {
#line 200
  if ((int )*(mqc->bp) == 255) {
#line 201
    (mqc->bp) ++;
#line 202
    *(mqc->bp) = (OPJ_BYTE )(mqc->c >> 20);
#line 203
    mqc->c &= 1048575U;
#line 204
    mqc->ct = (OPJ_UINT32 )7;
  } else
#line 206
  if ((mqc->c & 134217728U) == 0U) {
#line 207
    (mqc->bp) ++;
#line 208
    *(mqc->bp) = (OPJ_BYTE )(mqc->c >> 19);
#line 209
    mqc->c &= 524287U;
#line 210
    mqc->ct = (OPJ_UINT32 )8;
  } else {
#line 212
    *(mqc->bp) = (OPJ_BYTE )((int )*(mqc->bp) + 1);
#line 213
    if ((int )*(mqc->bp) == 255) {
#line 214
      mqc->c &= 134217727U;
#line 215
      (mqc->bp) ++;
#line 216
      *(mqc->bp) = (OPJ_BYTE )(mqc->c >> 20);
#line 217
      mqc->c &= 1048575U;
#line 218
      mqc->ct = (OPJ_UINT32 )7;
    } else {
#line 220
      (mqc->bp) ++;
#line 221
      *(mqc->bp) = (OPJ_BYTE )(mqc->c >> 19);
#line 222
      mqc->c &= 524287U;
#line 223
      mqc->ct = (OPJ_UINT32 )8;
    }
  }
#line 226
  return;
}
}
#line 229 "/root/patron/new_22/src/lib/openjp2/mqc.c"
void opj_mqc_renorme(opj_mqc_t *mqc ) 
{ 
  OPJ_UINT32 __cil_tmp2 ;

  {
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 231
    mqc->a <<= 1;
#line 232
    mqc->c <<= 1;
#line 233
    __cil_tmp2 = mqc->ct;
#line 233
    (mqc->ct) --;
#line 234
    if (mqc->ct == 0U) {
      {
#line 235
      opj_mqc_byteout(mqc);
      }
    }
#line 230
    if (! ((mqc->a & 32768U) == 0U)) {
#line 230
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 235
  return;
}
}
#line 240 "/root/patron/new_22/src/lib/openjp2/mqc.c"
void opj_mqc_codemps(opj_mqc_t *mqc ) 
{ 


  {
#line 241
  mqc->a -= (*(mqc->curctx))->qeval;
#line 242
  if ((mqc->a & 32768U) == 0U) {
#line 243
    if (mqc->a < (*(mqc->curctx))->qeval) {
#line 244
      mqc->a = (*(mqc->curctx))->qeval;
    } else {
#line 246
      mqc->c += (*(mqc->curctx))->qeval;
    }
    {
#line 248
    *(mqc->curctx) = (*(mqc->curctx))->nmps;
#line 249
    opj_mqc_renorme(mqc);
    }
  } else {
#line 251
    mqc->c += (*(mqc->curctx))->qeval;
  }
#line 253
  return;
}
}
#line 255 "/root/patron/new_22/src/lib/openjp2/mqc.c"
void opj_mqc_codelps(opj_mqc_t *mqc ) 
{ 


  {
#line 256
  mqc->a -= (*(mqc->curctx))->qeval;
#line 257
  if (mqc->a < (*(mqc->curctx))->qeval) {
#line 258
    mqc->c += (*(mqc->curctx))->qeval;
  } else {
#line 260
    mqc->a = (*(mqc->curctx))->qeval;
  }
  {
#line 262
  *(mqc->curctx) = (*(mqc->curctx))->nlps;
#line 263
  opj_mqc_renorme(mqc);
  }
#line 265
  return;
}
}
#line 266 "/root/patron/new_22/src/lib/openjp2/mqc.c"
void opj_mqc_setbits(opj_mqc_t *mqc ) 
{ 
  OPJ_UINT32 tempc ;

  {
#line 267
  tempc = mqc->c + mqc->a;
#line 268
  mqc->c |= 65535U;
#line 269
  if (mqc->c >= tempc) {
#line 270
    mqc->c -= 32768U;
  }
#line 272
  return;
}
}
#line 274 "/root/patron/new_22/src/lib/openjp2/mqc.c"
__inline static OPJ_INT32 opj_mqc_mpsexchange(opj_mqc_t *mqc ) 
{ 
  OPJ_INT32 d ;

  {
#line 276
  if (mqc->a < (*(mqc->curctx))->qeval) {
#line 277
    d = (OPJ_INT32 )(1U - (*(mqc->curctx))->mps);
#line 278
    *(mqc->curctx) = (*(mqc->curctx))->nlps;
  } else {
#line 280
    d = (OPJ_INT32 )(*(mqc->curctx))->mps;
#line 281
    *(mqc->curctx) = (*(mqc->curctx))->nmps;
  }
#line 284
  return (d);
}
}
#line 287 "/root/patron/new_22/src/lib/openjp2/mqc.c"
__inline static OPJ_INT32 opj_mqc_lpsexchange(opj_mqc_t *mqc ) 
{ 
  OPJ_INT32 d ;

  {
#line 289
  if (mqc->a < (*(mqc->curctx))->qeval) {
#line 290
    mqc->a = (*(mqc->curctx))->qeval;
#line 291
    d = (OPJ_INT32 )(*(mqc->curctx))->mps;
#line 292
    *(mqc->curctx) = (*(mqc->curctx))->nmps;
  } else {
#line 294
    mqc->a = (*(mqc->curctx))->qeval;
#line 295
    d = (OPJ_INT32 )(1U - (*(mqc->curctx))->mps);
#line 296
    *(mqc->curctx) = (*(mqc->curctx))->nlps;
  }
#line 299
  return (d);
}
}
#line 310 "/root/patron/new_22/src/lib/openjp2/mqc.c"
static void opj_mqc_bytein(opj_mqc_t *mqc ) 
{ 
  OPJ_UINT32 c ;

  {
#line 311
  if ((unsigned long )mqc->bp != (unsigned long )mqc->end) {
#line 313
    if ((unsigned long )(mqc->bp + 1) != (unsigned long )mqc->end) {
#line 314
      c = (OPJ_UINT32 )*(mqc->bp + 1);
    } else {
#line 316
      c = (OPJ_UINT32 )255;
    }
#line 318
    if ((int )*(mqc->bp) == 255) {
#line 319
      if (c > 143U) {
#line 320
        mqc->c += 65280U;
#line 321
        mqc->ct = (OPJ_UINT32 )8;
      } else {
#line 323
        (mqc->bp) ++;
#line 324
        mqc->c += c << 9;
#line 325
        mqc->ct = (OPJ_UINT32 )7;
      }
    } else {
#line 328
      (mqc->bp) ++;
#line 329
      mqc->c += c << 8;
#line 330
      mqc->ct = (OPJ_UINT32 )8;
    }
  } else {
#line 333
    mqc->c += 65280U;
#line 334
    mqc->ct = (OPJ_UINT32 )8;
  }
#line 336
  return;
}
}
#line 339 "/root/patron/new_22/src/lib/openjp2/mqc.c"
__inline static void opj_mqc_renormd(opj_mqc_t *mqc ) 
{ 
  OPJ_UINT32 __cil_tmp2 ;

  {
  {
#line 340
  while (1) {
    while_continue: /* CIL Label */ ;

#line 341
    if (mqc->ct == 0U) {
      {
#line 342
      opj_mqc_bytein(mqc);
      }
    }
#line 344
    mqc->a <<= 1;
#line 345
    mqc->c <<= 1;
#line 346
    __cil_tmp2 = mqc->ct;
#line 346
    (mqc->ct) --;
#line 340
    if (! (mqc->a < 32768U)) {
#line 340
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 345
  return;
}
}
#line 356 "/root/patron/new_22/src/lib/openjp2/mqc.c"
opj_mqc_t *opj_mqc_create(void) 
{ 
  opj_mqc_t *mqc ;
  void *__cil_tmp2 ;

  {
  {
#line 357
  __cil_tmp2 = malloc(sizeof(opj_mqc_t ));
#line 357
  mqc = (opj_mqc_t *)__cil_tmp2;
  }
#line 361
  return (mqc);
}
}
#line 364 "/root/patron/new_22/src/lib/openjp2/mqc.c"
void opj_mqc_destroy(opj_mqc_t *mqc ) 
{ 


  {
#line 365
  if (mqc) {
    {
#line 369
    free((void *)mqc);
    }
  }
#line 372
  return;
}
}
#line 373 "/root/patron/new_22/src/lib/openjp2/mqc.c"
OPJ_UINT32 opj_mqc_numbytes(opj_mqc_t *mqc ) 
{ 


  {
#line 374
  return ((OPJ_UINT32 )(mqc->bp - mqc->start));
}
}
#line 377 "/root/patron/new_22/src/lib/openjp2/mqc.c"
void opj_mqc_init_enc(opj_mqc_t *mqc , OPJ_BYTE *bp ) 
{ 


  {
#line 379
  mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )0];
#line 380
  mqc->a = (OPJ_UINT32 )32768;
#line 381
  mqc->c = (OPJ_UINT32 )0;
#line 382
  mqc->bp = bp - 1;
#line 383
  mqc->ct = (OPJ_UINT32 )12;
#line 384
  if ((int )*(mqc->bp) == 255) {
#line 385
    mqc->ct = (OPJ_UINT32 )13;
  }
#line 387
  mqc->start = bp;
#line 388
  return;
}
}
#line 390 "/root/patron/new_22/src/lib/openjp2/mqc.c"
void opj_mqc_encode(opj_mqc_t *mqc , OPJ_UINT32 d ) 
{ 


  {
#line 391
  if ((*(mqc->curctx))->mps == d) {
    {
#line 392
    opj_mqc_codemps(mqc);
    }
  } else {
    {
#line 394
    opj_mqc_codelps(mqc);
    }
  }
#line 397
  return;
}
}
#line 398 "/root/patron/new_22/src/lib/openjp2/mqc.c"
void opj_mqc_flush(opj_mqc_t *mqc ) 
{ 


  {
  {
#line 399
  opj_mqc_setbits(mqc);
#line 400
  mqc->c <<= mqc->ct;
#line 401
  opj_mqc_byteout(mqc);
#line 402
  mqc->c <<= mqc->ct;
#line 403
  opj_mqc_byteout(mqc);
  }
#line 405
  if ((int )*(mqc->bp) != 255) {
#line 406
    (mqc->bp) ++;
  }
#line 408
  return;
}
}
#line 410 "/root/patron/new_22/src/lib/openjp2/mqc.c"
void opj_mqc_bypass_init_enc(opj_mqc_t *mqc ) 
{ 


  {
#line 411
  mqc->c = (OPJ_UINT32 )0;
#line 412
  mqc->ct = (OPJ_UINT32 )8;
#line 413
  return;
}
}
#line 418 "/root/patron/new_22/src/lib/openjp2/mqc.c"
void opj_mqc_bypass_enc(opj_mqc_t *mqc , OPJ_UINT32 d ) 
{ 
  OPJ_UINT32 __cil_tmp3 ;

  {
#line 419
  __cil_tmp3 = mqc->ct;
#line 419
  (mqc->ct) --;
#line 420
  mqc->c += d << mqc->ct;
#line 421
  if (mqc->ct == 0U) {
#line 422
    (mqc->bp) ++;
#line 423
    *(mqc->bp) = (OPJ_BYTE )mqc->c;
#line 424
    mqc->ct = (OPJ_UINT32 )8;
#line 425
    if ((int )*(mqc->bp) == 255) {
#line 426
      mqc->ct = (OPJ_UINT32 )7;
    }
#line 428
    mqc->c = (OPJ_UINT32 )0;
  }
#line 430
  return;
}
}
#line 432 "/root/patron/new_22/src/lib/openjp2/mqc.c"
OPJ_UINT32 opj_mqc_bypass_flush_enc(opj_mqc_t *mqc ) 
{ 
  OPJ_BYTE bit_padding ;
  OPJ_UINT32 __cil_tmp3 ;

  {
#line 435
  bit_padding = (OPJ_BYTE )0;
#line 437
  if (mqc->ct != 0U) {
    {
#line 438
    while (1) {
      while_continue: /* CIL Label */ ;

#line 438
      if (! (mqc->ct > 0U)) {
#line 438
        goto while_break;
      }
#line 439
      __cil_tmp3 = mqc->ct;
#line 439
      (mqc->ct) --;
#line 440
      mqc->c += (unsigned int )((int )bit_padding << mqc->ct);
#line 441
      bit_padding = (OPJ_BYTE )(((int )bit_padding + 1) & 1);
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: 
#line 443
    (mqc->bp) ++;
#line 444
    *(mqc->bp) = (OPJ_BYTE )mqc->c;
#line 445
    mqc->ct = (OPJ_UINT32 )8;
#line 446
    mqc->c = (OPJ_UINT32 )0;
  }
#line 449
  return ((OPJ_UINT32 )1);
}
}
#line 452 "/root/patron/new_22/src/lib/openjp2/mqc.c"
void opj_mqc_reset_enc(opj_mqc_t *mqc ) 
{ 


  {
  {
#line 453
  opj_mqc_resetstates(mqc);
#line 454
  opj_mqc_setstate(mqc, (OPJ_UINT32 )18, (OPJ_UINT32 )0, 46);
#line 455
  opj_mqc_setstate(mqc, (OPJ_UINT32 )17, (OPJ_UINT32 )0, 3);
#line 456
  opj_mqc_setstate(mqc, (OPJ_UINT32 )0, (OPJ_UINT32 )0, 4);
  }
#line 458
  return;
}
}
#line 459 "/root/patron/new_22/src/lib/openjp2/mqc.c"
OPJ_UINT32 opj_mqc_restart_enc(opj_mqc_t *mqc ) 
{ 
  OPJ_UINT32 correction ;
  OPJ_INT32 n ;

  {
#line 460
  correction = (OPJ_UINT32 )1;
#line 463
  n = (OPJ_INT32 )(12U - mqc->ct);
#line 464
  mqc->c <<= mqc->ct;
  {
#line 465
  while (1) {
    while_continue: /* CIL Label */ ;

#line 465
    if (! (n > 0)) {
#line 465
      goto while_break;
    }
    {
#line 466
    opj_mqc_byteout(mqc);
#line 467
    n = (OPJ_INT32 )((OPJ_UINT32 )n - mqc->ct);
#line 468
    mqc->c <<= mqc->ct;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 470
  opj_mqc_byteout(mqc);
  }
#line 472
  return (correction);
}
}
#line 475 "/root/patron/new_22/src/lib/openjp2/mqc.c"
void opj_mqc_restart_init_enc(opj_mqc_t *mqc ) 
{ 
  OPJ_BYTE *__cil_tmp2 ;

  {
#line 477
  mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )0];
#line 478
  mqc->a = (OPJ_UINT32 )32768;
#line 479
  mqc->c = (OPJ_UINT32 )0;
#line 480
  mqc->ct = (OPJ_UINT32 )12;
#line 481
  __cil_tmp2 = mqc->bp;
#line 481
  (mqc->bp) --;
#line 482
  if ((int )*(mqc->bp) == 255) {
#line 483
    mqc->ct = (OPJ_UINT32 )13;
  }
#line 485
  return;
}
}
#line 487 "/root/patron/new_22/src/lib/openjp2/mqc.c"
void opj_mqc_erterm_enc(opj_mqc_t *mqc ) 
{ 
  OPJ_INT32 k ;

  {
#line 488
  k = (OPJ_INT32 )((11U - mqc->ct) + 1U);
  {
#line 490
  while (1) {
    while_continue: /* CIL Label */ ;

#line 490
    if (! (k > 0)) {
#line 490
      goto while_break;
    }
    {
#line 491
    mqc->c <<= mqc->ct;
#line 492
    mqc->ct = (OPJ_UINT32 )0;
#line 493
    opj_mqc_byteout(mqc);
#line 494
    k = (OPJ_INT32 )((OPJ_UINT32 )k - mqc->ct);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 497
  if ((int )*(mqc->bp) != 255) {
    {
#line 498
    opj_mqc_byteout(mqc);
    }
  }
#line 501
  return;
}
}
#line 502 "/root/patron/new_22/src/lib/openjp2/mqc.c"
void opj_mqc_segmark_enc(opj_mqc_t *mqc ) 
{ 
  OPJ_UINT32 i ;

  {
#line 504
  mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )18];
#line 506
  i = (OPJ_UINT32 )1;
  {
#line 506
  while (1) {
    while_continue: /* CIL Label */ ;

#line 506
    if (! (i < 5U)) {
#line 506
      goto while_break;
    }
    {
#line 507
    opj_mqc_encode(mqc, i % 2U);
#line 506
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 510
  return;
}
}
#line 511 "/root/patron/new_22/src/lib/openjp2/mqc.c"
OPJ_BOOL opj_mqc_init_dec(opj_mqc_t *mqc , OPJ_BYTE *bp , OPJ_UINT32 len ) 
{ 


  {
#line 512
  mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )0];
#line 513
  mqc->start = bp;
#line 514
  mqc->end = bp + len;
#line 515
  mqc->bp = bp;
#line 516
  if (len == 0U) {
#line 516
    mqc->c = (OPJ_UINT32 )(255 << 16);
  } else {
#line 517
    mqc->c = (OPJ_UINT32 )((int )*(mqc->bp) << 16);
  }
  {
#line 563
  opj_mqc_bytein(mqc);
#line 564
  mqc->c <<= 7;
#line 565
  mqc->ct -= 7U;
#line 566
  mqc->a = (OPJ_UINT32 )32768;
  }
#line 567
  return (1);
}
}
#line 570 "/root/patron/new_22/src/lib/openjp2/mqc.c"
OPJ_INT32 opj_mqc_decode(opj_mqc_t *mqc ) 
{ 
  OPJ_INT32 d ;

  {
#line 572
  mqc->a -= (*(mqc->curctx))->qeval;
#line 573
  if (mqc->c >> 16 < (*(mqc->curctx))->qeval) {
    {
#line 574
    d = opj_mqc_lpsexchange(mqc);
#line 575
    opj_mqc_renormd(mqc);
    }
  } else {
#line 577
    mqc->c -= (*(mqc->curctx))->qeval << 16;
#line 578
    if ((mqc->a & 32768U) == 0U) {
      {
#line 579
      d = opj_mqc_mpsexchange(mqc);
#line 580
      opj_mqc_renormd(mqc);
      }
    } else {
#line 582
      d = (OPJ_INT32 )(*(mqc->curctx))->mps;
    }
  }
#line 586
  return (d);
}
}
#line 589 "/root/patron/new_22/src/lib/openjp2/mqc.c"
void opj_mqc_resetstates(opj_mqc_t *mqc ) 
{ 
  OPJ_UINT32 i ;

  {
#line 591
  i = (OPJ_UINT32 )0;
  {
#line 591
  while (1) {
    while_continue: /* CIL Label */ ;

#line 591
    if (! (i < 19U)) {
#line 591
      goto while_break;
    }
#line 592
    mqc->ctxs[i] = mqc_states;
#line 591
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 595
  return;
}
}
#line 596 "/root/patron/new_22/src/lib/openjp2/mqc.c"
void opj_mqc_setstate(opj_mqc_t *mqc , OPJ_UINT32 ctxno , OPJ_UINT32 msb , OPJ_INT32 prob ) 
{ 


  {
#line 597
  mqc->ctxs[ctxno] = & mqc_states[msb + (unsigned int )(prob << 1)];
#line 598
  return;
}
}
#line 56 "/root/patron/new_22/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_read_ihdr(opj_jp2_t *jp2 , OPJ_BYTE *p_image_header_data , OPJ_UINT32 p_image_header_size ,
                           opj_event_mgr_t *p_manager ) ;
#line 69
OPJ_BYTE *opj_jp2_write_ihdr(opj_jp2_t *jp2 , OPJ_UINT32 *p_nb_bytes_written ) ;
#line 80
OPJ_BYTE *opj_jp2_write_bpcc(opj_jp2_t *jp2 , OPJ_UINT32 *p_nb_bytes_written ) ;
#line 93
OPJ_BOOL opj_jp2_read_bpcc(opj_jp2_t *jp2 , OPJ_BYTE *p_bpc_header_data , OPJ_UINT32 p_bpc_header_size ,
                           opj_event_mgr_t *p_manager ) ;
#line 98
OPJ_BOOL opj_jp2_read_cdef(opj_jp2_t *jp2 , OPJ_BYTE *p_cdef_header_data , OPJ_UINT32 p_cdef_header_size ,
                           opj_event_mgr_t *p_manager ) ;
#line 103
void opj_jp2_apply_cdef(opj_image_t *image , opj_jp2_color_t *color ) ;
#line 113
OPJ_BYTE *opj_jp2_write_colr(opj_jp2_t *jp2 , OPJ_UINT32 *p_nb_bytes_written ) ;
#line 125
OPJ_BOOL opj_jp2_write_ftyp(opj_jp2_t *jp2 , opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) ;
#line 139
static OPJ_BOOL opj_jp2_read_ftyp(opj_jp2_t *jp2 , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                  opj_event_mgr_t *p_manager ) ;
#line 144
OPJ_BOOL opj_jp2_skip_jp2c(opj_jp2_t *jp2 , opj_stream_private_t *stream , opj_event_mgr_t *p_manager ) ;
#line 158
static OPJ_BOOL opj_jp2_read_jp2h(opj_jp2_t *jp2 , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                  opj_event_mgr_t *p_manager ) ;
#line 172
OPJ_BOOL opj_jp2_write_jp2c(opj_jp2_t *jp2 , opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) ;
#line 218
static OPJ_BOOL opj_jp2_read_jp(opj_jp2_t *jp2 , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                opj_event_mgr_t *p_manager ) ;
#line 232
OPJ_BOOL opj_jp2_write_jp(opj_jp2_t *jp2 , opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) ;
#line 241
void opj_jp2_apply_pclr(opj_image_t *image , opj_jp2_color_t *color ) ;
#line 243
void opj_jp2_free_pclr(opj_jp2_color_t *color ) ;
#line 255
OPJ_BOOL opj_jp2_read_pclr(opj_jp2_t *jp2 , OPJ_BYTE *p_pclr_header_data , OPJ_UINT32 p_pclr_header_size ,
                           opj_event_mgr_t *p_manager ) ;
#line 271
OPJ_BOOL opj_jp2_read_cmap(opj_jp2_t *jp2 , OPJ_BYTE *p_cmap_header_data , OPJ_UINT32 p_cmap_header_size ,
                           opj_event_mgr_t *p_manager ) ;
#line 286
OPJ_BOOL opj_jp2_read_colr(opj_jp2_t *jp2 , OPJ_BYTE *p_colr_header_data , OPJ_UINT32 p_colr_header_size ,
                           opj_event_mgr_t *p_manager ) ;
#line 299
void opj_jp2_setup_end_header_writing(opj_jp2_t *jp2 ) ;
#line 305
void opj_jp2_setup_end_header_reading(opj_jp2_t *jp2 ) ;
#line 316
OPJ_BOOL opj_jp2_read_header_procedure(opj_jp2_t *jp2 , opj_stream_private_t *stream ,
                                       opj_event_mgr_t *p_manager ) ;
#line 330
static OPJ_BOOL opj_jp2_exec(opj_jp2_t *jp2 , opj_procedure_list_t *p_procedure_list ,
                             opj_stream_private_t *stream , opj_event_mgr_t *p_manager ) ;
#line 345
OPJ_BOOL opj_jp2_read_boxhdr(opj_jp2_box_t *box , OPJ_UINT32 *p_number_bytes_read ,
                             opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) ;
#line 354
void opj_jp2_setup_encoding_validation(opj_jp2_t *jp2 ) ;
#line 359
void opj_jp2_setup_header_writing(opj_jp2_t *jp2 ) ;
#line 361
OPJ_BOOL opj_jp2_default_validation(opj_jp2_t *jp2 , opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) ;
#line 372
static opj_jp2_header_handler_t *opj_jp2_img_find_handler(OPJ_UINT32 p_id ) ;
#line 381
opj_jp2_header_handler_t *opj_jp2_find_handler(OPJ_UINT32 p_id ) ;
#line 383 "/root/patron/new_22/src/lib/openjp2/jp2.c"
opj_jp2_header_handler_t jp2_header[3]  = {      {(OPJ_UINT32 )1783636000, & opj_jp2_read_jp}, 
        {(OPJ_UINT32 )1718909296, & opj_jp2_read_ftyp}, 
        {(OPJ_UINT32 )1785737832, & opj_jp2_read_jp2h}};
#line 390 "/root/patron/new_22/src/lib/openjp2/jp2.c"
opj_jp2_header_handler_t jp2_img_header[6]  = {      {(OPJ_UINT32 )1768449138, & opj_jp2_read_ihdr}, 
        {(OPJ_UINT32 )1668246642, & opj_jp2_read_colr}, 
        {(OPJ_UINT32 )1651532643, & opj_jp2_read_bpcc}, 
        {(OPJ_UINT32 )1885564018, & opj_jp2_read_pclr}, 
        {(OPJ_UINT32 )1668112752, & opj_jp2_read_cmap}, 
        {(OPJ_UINT32 )1667523942, & opj_jp2_read_cdef}};
#line 412
OPJ_BOOL opj_jp2_read_boxhdr_char(opj_jp2_box_t *box , OPJ_BYTE *p_data , OPJ_UINT32 *p_number_bytes_read ,
                                  OPJ_UINT32 p_box_max_size , opj_event_mgr_t *p_manager ) ;
#line 422
void opj_jp2_setup_decoding_validation(opj_jp2_t *jp2 ) ;
#line 428
void opj_jp2_setup_header_reading(opj_jp2_t *jp2 ) ;
#line 431 "/root/patron/new_22/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_read_boxhdr(opj_jp2_box_t *box , OPJ_UINT32 *p_number_bytes_read ,
                             opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BYTE l_data_header[8] ;
  OPJ_SIZE_T __cil_tmp10 ;
  OPJ_OFF_T __cil_tmp11 ;
  OPJ_UINT32 l_xl_part_size ;
  OPJ_UINT32 l_nb_bytes_read ;
  OPJ_SIZE_T __cil_tmp14 ;

  {
  {
#line 445
  __cil_tmp10 = opj_stream_read_data(cio, l_data_header, (OPJ_SIZE_T )8, p_manager);
#line 445
  *p_number_bytes_read = (OPJ_UINT32 )__cil_tmp10;
  }
#line 446
  if (*p_number_bytes_read != 8U) {
#line 447
    return (0);
  }
  {
#line 451
  opj_read_bytes_LE(l_data_header, & box->length, (OPJ_UINT32 )4);
#line 452
  opj_read_bytes_LE(l_data_header + 4, & box->type, (OPJ_UINT32 )4);
  }
#line 454
  if (box->length == 0U) {
    {
#line 456
    __cil_tmp11 = opj_stream_get_number_byte_left(cio);
#line 456
    box->length = (OPJ_UINT32 )__cil_tmp11;
    }
#line 457
    return (1);
  }
#line 462
  if (box->length == 1U) {
    {
#line 465
    __cil_tmp14 = opj_stream_read_data(cio, l_data_header, (OPJ_SIZE_T )8, p_manager);
#line 465
    l_nb_bytes_read = (OPJ_UINT32 )__cil_tmp14;
    }
#line 466
    if (l_nb_bytes_read != 8U) {
#line 467
      if (l_nb_bytes_read > 0U) {
#line 468
        *p_number_bytes_read += l_nb_bytes_read;
      }
#line 471
      return (0);
    }
    {
#line 474
    *p_number_bytes_read = (OPJ_UINT32 )16;
#line 475
    opj_read_bytes_LE(l_data_header, & l_xl_part_size, (OPJ_UINT32 )4);
    }
#line 476
    if (l_xl_part_size != 0U) {
      {
#line 477
      opj_event_msg(p_manager, 1, "Cannot handle box sizes higher than 2^32\n");
      }
#line 478
      return (0);
    }
    {
#line 480
    opj_read_bytes_LE(l_data_header + 4, & box->length, (OPJ_UINT32 )4);
    }
  }
#line 482
  return (1);
}
}
#line 509 "/root/patron/new_22/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_read_ihdr(opj_jp2_t *jp2 , OPJ_BYTE *p_image_header_data , OPJ_UINT32 p_image_header_size ,
                           opj_event_mgr_t *p_manager ) 
{ 
  void *__cil_tmp8 ;

  {
#line 519
  if (p_image_header_size != 14U) {
    {
#line 520
    opj_event_msg(p_manager, 1, "Bad image header box (bad size)\n\220");
    }
#line 521
    return (0);
  }
  {
#line 524
  opj_read_bytes_LE(p_image_header_data, & jp2->h, (OPJ_UINT32 )4);
#line 525
  p_image_header_data += 4;
#line 526
  opj_read_bytes_LE(p_image_header_data, & jp2->w, (OPJ_UINT32 )4);
#line 527
  p_image_header_data += 4;
#line 528
  opj_read_bytes_LE(p_image_header_data, & jp2->numcomps, (OPJ_UINT32 )2);
#line 529
  p_image_header_data += 2;
#line 532
  __cil_tmp8 = malloc((unsigned long )jp2->numcomps * sizeof(opj_jp2_comps_t ));
#line 532
  jp2->comps = (opj_jp2_comps_t *)__cil_tmp8;
  }
#line 533
  if ((unsigned long )jp2->comps == (unsigned long )((opj_jp2_comps_t *)0)) {
    {
#line 534
    opj_event_msg(p_manager, 1, "Not enough memory to handle image header (ihdr)\n\220");
    }
#line 535
    return (0);
  }
  {
#line 537
  memset((void *)jp2->comps, 0, (unsigned long )jp2->numcomps * sizeof(opj_jp2_comps_t ));
#line 539
  opj_read_bytes_LE(p_image_header_data, & jp2->bpc, (OPJ_UINT32 )1);
#line 540
  p_image_header_data ++;
#line 542
  opj_read_bytes_LE(p_image_header_data, & jp2->C, (OPJ_UINT32 )1);
#line 543
  p_image_header_data ++;
  }
#line 546
  if (jp2->C != 7U) {
    {
#line 547
    opj_event_msg(p_manager, 4, "JP2 IHDR box: compression type indicate that the file is not a conforming JP2 file (%d) \n",
                  jp2->C);
    }
  }
  {
#line 550
  opj_read_bytes_LE(p_image_header_data, & jp2->UnkC, (OPJ_UINT32 )1);
#line 551
  p_image_header_data ++;
#line 552
  opj_read_bytes_LE(p_image_header_data, & jp2->IPR, (OPJ_UINT32 )1);
#line 553
  p_image_header_data ++;
  }
#line 555
  return (1);
}
}
#line 558 "/root/patron/new_22/src/lib/openjp2/jp2.c"
OPJ_BYTE *opj_jp2_write_ihdr(opj_jp2_t *jp2 , OPJ_UINT32 *p_nb_bytes_written ) 
{ 
  OPJ_BYTE *l_ihdr_data ;
  OPJ_BYTE *l_current_ihdr_ptr ;
  void *__cil_tmp7 ;

  {
  {
#line 569
  __cil_tmp7 = malloc(22UL);
#line 569
  l_ihdr_data = (OPJ_BYTE *)__cil_tmp7;
  }
#line 570
  if ((unsigned long )l_ihdr_data == (unsigned long )((OPJ_BYTE *)0)) {
#line 571
    return ((OPJ_BYTE *)0);
  }
  {
#line 573
  memset((void *)l_ihdr_data, 0, 22UL);
#line 575
  l_current_ihdr_ptr = l_ihdr_data;
#line 577
  opj_write_bytes_LE(l_current_ihdr_ptr, (OPJ_UINT32 )22, (OPJ_UINT32 )4);
#line 578
  l_current_ihdr_ptr += 4;
#line 580
  opj_write_bytes_LE(l_current_ihdr_ptr, (OPJ_UINT32 )1768449138, (OPJ_UINT32 )4);
#line 581
  l_current_ihdr_ptr += 4;
#line 583
  opj_write_bytes_LE(l_current_ihdr_ptr, jp2->h, (OPJ_UINT32 )4);
#line 584
  l_current_ihdr_ptr += 4;
#line 586
  opj_write_bytes_LE(l_current_ihdr_ptr, jp2->w, (OPJ_UINT32 )4);
#line 587
  l_current_ihdr_ptr += 4;
#line 589
  opj_write_bytes_LE(l_current_ihdr_ptr, jp2->numcomps, (OPJ_UINT32 )2);
#line 590
  l_current_ihdr_ptr += 2;
#line 592
  opj_write_bytes_LE(l_current_ihdr_ptr, jp2->bpc, (OPJ_UINT32 )1);
#line 593
  l_current_ihdr_ptr ++;
#line 595
  opj_write_bytes_LE(l_current_ihdr_ptr, jp2->C, (OPJ_UINT32 )1);
#line 596
  l_current_ihdr_ptr ++;
#line 598
  opj_write_bytes_LE(l_current_ihdr_ptr, jp2->UnkC, (OPJ_UINT32 )1);
#line 599
  l_current_ihdr_ptr ++;
#line 601
  opj_write_bytes_LE(l_current_ihdr_ptr, jp2->IPR, (OPJ_UINT32 )1);
#line 602
  l_current_ihdr_ptr ++;
#line 604
  *p_nb_bytes_written = (OPJ_UINT32 )22;
  }
#line 606
  return (l_ihdr_data);
}
}
#line 609 "/root/patron/new_22/src/lib/openjp2/jp2.c"
OPJ_BYTE *opj_jp2_write_bpcc(opj_jp2_t *jp2 , OPJ_UINT32 *p_nb_bytes_written ) 
{ 
  OPJ_UINT32 i ;
  OPJ_INT32 l_bpcc_size ;
  OPJ_BYTE *l_bpcc_data ;
  OPJ_BYTE *l_current_bpcc_ptr ;
  void *__cil_tmp9 ;

  {
  {
#line 615
  l_bpcc_size = (OPJ_INT32 )(8U + jp2->numcomps);
#line 622
  __cil_tmp9 = malloc((unsigned long )l_bpcc_size);
#line 622
  l_bpcc_data = (OPJ_BYTE *)__cil_tmp9;
  }
#line 623
  if ((unsigned long )l_bpcc_data == (unsigned long )((OPJ_BYTE *)0)) {
#line 624
    return ((OPJ_BYTE *)0);
  }
  {
#line 626
  memset((void *)l_bpcc_data, 0, (unsigned long )l_bpcc_size);
#line 628
  l_current_bpcc_ptr = l_bpcc_data;
#line 630
  opj_write_bytes_LE(l_current_bpcc_ptr, (OPJ_UINT32 )l_bpcc_size, (OPJ_UINT32 )4);
#line 631
  l_current_bpcc_ptr += 4;
#line 633
  opj_write_bytes_LE(l_current_bpcc_ptr, (OPJ_UINT32 )1651532643, (OPJ_UINT32 )4);
#line 634
  l_current_bpcc_ptr += 4;
#line 636
  i = (OPJ_UINT32 )0;
  }
  {
#line 636
  while (1) {
    while_continue: /* CIL Label */ ;

#line 636
    if (! (i < jp2->numcomps)) {
#line 636
      goto while_break;
    }
    {
#line 637
    opj_write_bytes_LE(l_current_bpcc_ptr, (jp2->comps + i)->bpcc, (OPJ_UINT32 )1);
#line 638
    l_current_bpcc_ptr ++;
#line 636
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 641
  *p_nb_bytes_written = (OPJ_UINT32 )l_bpcc_size;
#line 643
  return (l_bpcc_data);
}
}
#line 646 "/root/patron/new_22/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_read_bpcc(opj_jp2_t *jp2 , OPJ_BYTE *p_bpc_header_data , OPJ_UINT32 p_bpc_header_size ,
                           opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;

  {
#line 660
  if (jp2->bpc != 255U) {
    {
#line 661
    opj_event_msg(p_manager, 2, "A BPCC header box is available although BPC given by the IHDR box (%d) indicate components bit depth is constant\n\305\235\211\202U",
                  jp2->bpc);
    }
  }
#line 665
  if (p_bpc_header_size != jp2->numcomps) {
    {
#line 666
    opj_event_msg(p_manager, 1, "Bad BPCC header box (bad size)\n");
    }
#line 667
    return (0);
  }
#line 671
  i = (OPJ_UINT32 )0;
  {
#line 671
  while (1) {
    while_continue: /* CIL Label */ ;

#line 671
    if (! (i < jp2->numcomps)) {
#line 671
      goto while_break;
    }
    {
#line 672
    opj_read_bytes_LE(p_bpc_header_data, & (jp2->comps + i)->bpcc, (OPJ_UINT32 )1);
#line 673
    p_bpc_header_data ++;
#line 671
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 676
  return (1);
}
}
#line 679 "/root/patron/new_22/src/lib/openjp2/jp2.c"
OPJ_BYTE *opj_jp2_write_colr(opj_jp2_t *jp2 , OPJ_UINT32 *p_nb_bytes_written ) 
{ 
  OPJ_UINT32 l_colr_size ;
  OPJ_BYTE *l_colr_data ;
  OPJ_BYTE *l_current_colr_ptr ;
  void *__cil_tmp10 ;
  OPJ_UINT32 i ;

  {
#line 684
  l_colr_size = (OPJ_UINT32 )11;
#line 693
  if (jp2->meth == 1U) {
#line 693
    goto case_1;
  }
#line 700
  goto switch_default;
  case_1: 
#line 694
  l_colr_size += 4U;
#line 695
  goto switch_break;
#line 698
  l_colr_size += jp2->color.icc_profile_len;
#line 699
  goto switch_break;
  switch_default: 
#line 701
  return ((OPJ_BYTE *)0);
  switch_break: 
  {
#line 704
  __cil_tmp10 = malloc((unsigned long )l_colr_size);
#line 704
  l_colr_data = (OPJ_BYTE *)__cil_tmp10;
  }
#line 705
  if ((unsigned long )l_colr_data == (unsigned long )((OPJ_BYTE *)0)) {
#line 706
    return ((OPJ_BYTE *)0);
  }
  {
#line 708
  memset((void *)l_colr_data, 0, (unsigned long )l_colr_size);
#line 710
  l_current_colr_ptr = l_colr_data;
#line 712
  opj_write_bytes_LE(l_current_colr_ptr, l_colr_size, (OPJ_UINT32 )4);
#line 713
  l_current_colr_ptr += 4;
#line 715
  opj_write_bytes_LE(l_current_colr_ptr, (OPJ_UINT32 )1668246642, (OPJ_UINT32 )4);
#line 716
  l_current_colr_ptr += 4;
#line 718
  opj_write_bytes_LE(l_current_colr_ptr, jp2->meth, (OPJ_UINT32 )1);
#line 719
  l_current_colr_ptr ++;
#line 721
  opj_write_bytes_LE(l_current_colr_ptr, jp2->precedence, (OPJ_UINT32 )1);
#line 722
  l_current_colr_ptr ++;
#line 724
  opj_write_bytes_LE(l_current_colr_ptr, jp2->approx, (OPJ_UINT32 )1);
#line 725
  l_current_colr_ptr ++;
  }
#line 727
  if (jp2->meth == 1U) {
    {
#line 728
    opj_write_bytes_LE(l_current_colr_ptr, jp2->enumcs, (OPJ_UINT32 )4);
    }
  } else
#line 730
  if (jp2->meth == 2U) {
#line 732
    i = (OPJ_UINT32 )0;
    {
#line 732
    while (1) {
      while_continue: /* CIL Label */ ;

#line 732
      if (! (i < jp2->color.icc_profile_len)) {
#line 732
        goto while_break;
      }
      {
#line 733
      opj_write_bytes_LE(l_current_colr_ptr, (OPJ_UINT32 )*(jp2->color.icc_profile_buf + i),
                         (OPJ_UINT32 )1);
#line 734
      l_current_colr_ptr ++;
#line 732
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 739
  *p_nb_bytes_written = l_colr_size;
#line 741
  return (l_colr_data);
}
}
#line 744 "/root/patron/new_22/src/lib/openjp2/jp2.c"
void opj_jp2_free_pclr(opj_jp2_color_t *color ) 
{ 


  {
  {
#line 746
  free((void *)(color->jp2_pclr)->channel_sign);
#line 747
  free((void *)(color->jp2_pclr)->channel_size);
#line 748
  free((void *)(color->jp2_pclr)->entries);
  }
#line 750
  if ((color->jp2_pclr)->cmap) {
    {
#line 750
    free((void *)(color->jp2_pclr)->cmap);
    }
  }
  {
#line 752
  free((void *)color->jp2_pclr);
#line 752
  color->jp2_pclr = (opj_jp2_pclr_t *)((void *)0);
  }
#line 754
  return;
}
}
#line 755 "/root/patron/new_22/src/lib/openjp2/jp2.c"
void opj_jp2_apply_pclr(opj_image_t *image , opj_jp2_color_t *color ) 
{ 
  opj_image_comp_t *old_comps ;
  opj_image_comp_t *new_comps ;
  OPJ_BYTE *channel_size ;
  OPJ_BYTE *channel_sign ;
  OPJ_UINT32 *entries ;
  opj_jp2_cmap_comp_t *cmap ;
  OPJ_INT32 *src ;
  OPJ_INT32 *dst ;
  OPJ_UINT32 j ;
  OPJ_UINT32 max ;
  OPJ_UINT16 i ;
  OPJ_UINT16 nr_channels ;
  OPJ_UINT16 cmp ;
  OPJ_UINT16 pcol ;
  OPJ_INT32 k ;
  OPJ_INT32 top_k ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;

  {
  {
#line 766
  channel_size = (color->jp2_pclr)->channel_size;
#line 767
  channel_sign = (color->jp2_pclr)->channel_sign;
#line 768
  entries = (color->jp2_pclr)->entries;
#line 769
  cmap = (color->jp2_pclr)->cmap;
#line 770
  nr_channels = (OPJ_UINT16 )(color->jp2_pclr)->nr_channels;
#line 772
  old_comps = image->comps;
#line 773
  __cil_tmp19 = malloc((unsigned long )nr_channels * sizeof(opj_image_comp_t ));
#line 773
  new_comps = (opj_image_comp_t *)__cil_tmp19;
#line 776
  i = (OPJ_UINT16 )0;
  }
  {
#line 776
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: ;
#line 776
    if (! ((int )i < (int )nr_channels)) {
#line 776
      goto while_break;
    }
#line 777
    pcol = (OPJ_UINT16 )(cmap + (int )i)->pcol;
#line 777
    cmp = (cmap + (int )i)->cmp;
#line 779
    *(new_comps + (int )pcol) = *(old_comps + (int )cmp);
#line 782
    if ((int )(cmap + (int )i)->mtyp == 0) {
#line 783
      (old_comps + (int )cmp)->data = (OPJ_INT32 *)((void *)0);
#line 783
      goto while_continue;
    }
    {
#line 787
    __cil_tmp20 = malloc((unsigned long )((old_comps + (int )cmp)->w * (old_comps + (int )cmp)->h) * sizeof(OPJ_INT32 ));
#line 787
    (new_comps + (int )pcol)->data = (OPJ_INT32 *)__cil_tmp20;
#line 789
    (new_comps + (int )pcol)->prec = (OPJ_UINT32 )*(channel_size + (int )i);
#line 790
    (new_comps + (int )pcol)->sgnd = (OPJ_UINT32 )*(channel_sign + (int )i);
#line 776
    i = (OPJ_UINT16 )((int )i + 1);
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: 
#line 793
  top_k = (int )(color->jp2_pclr)->nr_entries - 1;
#line 795
  i = (OPJ_UINT16 )0;
  {
#line 795
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: ;
#line 795
    if (! ((int )i < (int )nr_channels)) {
#line 795
      goto while_break___0;
    }
#line 797
    if ((int )(cmap + (int )i)->mtyp == 0) {
#line 797
      goto while_continue___0;
    }
#line 800
    cmp = (cmap + (int )i)->cmp;
#line 800
    pcol = (OPJ_UINT16 )(cmap + (int )i)->pcol;
#line 801
    src = (old_comps + (int )cmp)->data;
#line 802
    dst = (new_comps + (int )pcol)->data;
#line 803
    max = (new_comps + (int )pcol)->w * (new_comps + (int )pcol)->h;
#line 805
    j = (OPJ_UINT32 )0;
    {
#line 805
    while (1) {
      while_continue___3: /* CIL Label */ ;

#line 805
      if (! (j < max)) {
#line 805
        goto while_break___1;
      }
#line 808
      k = *(src + j);
#line 808
      if (k < 0) {
#line 808
        k = 0;
      } else
#line 808
      if (k > top_k) {
#line 808
        k = top_k;
      }
#line 811
      *(dst + j) = (OPJ_INT32 )*(entries + (k * (int )nr_channels + (int )pcol));
#line 805
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: 
#line 795
    i = (OPJ_UINT16 )((int )i + 1);
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: 
#line 815
  max = image->numcomps;
#line 816
  i = (OPJ_UINT16 )0;
  {
#line 816
  while (1) {
    while_continue___4: /* CIL Label */ ;

#line 816
    if (! ((unsigned int )i < max)) {
#line 816
      goto while_break___2;
    }
#line 817
    if ((old_comps + (int )i)->data) {
      {
#line 817
      free((void *)(old_comps + (int )i)->data);
      }
    }
#line 816
    i = (OPJ_UINT16 )((int )i + 1);
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: 
  {
#line 820
  free((void *)old_comps);
#line 821
  image->comps = new_comps;
#line 822
  image->numcomps = (OPJ_UINT32 )nr_channels;
#line 824
  opj_jp2_free_pclr(color);
  }
#line 826
  return;
}
}
#line 828 "/root/patron/new_22/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_read_pclr(opj_jp2_t *jp2 , OPJ_BYTE *p_pclr_header_data , OPJ_UINT32 p_pclr_header_size ,
                           opj_event_mgr_t *p_manager ) 
{ 
  opj_jp2_pclr_t *jp2_pclr ;
  OPJ_BYTE *channel_size ;
  OPJ_BYTE *channel_sign ;
  OPJ_UINT32 *entries ;
  OPJ_UINT16 nr_entries ;
  OPJ_UINT16 nr_channels ;
  OPJ_UINT16 i ;
  OPJ_UINT16 j ;
  OPJ_UINT32 l_value ;
  OPJ_BYTE *orig_header_data ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  int tmp___2 ;
  OPJ_INT32 bytes_to_read ;

  {
#line 840
  orig_header_data = p_pclr_header_data;
#line 848
  if (jp2->color.jp2_pclr) {
#line 849
    return (0);
  }
#line 851
  if (p_pclr_header_size < 3U) {
#line 852
    return (0);
  }
  {
#line 854
  opj_read_bytes_LE(p_pclr_header_data, & l_value, (OPJ_UINT32 )2);
#line 855
  p_pclr_header_data += 2;
#line 856
  nr_entries = (OPJ_UINT16 )l_value;
#line 858
  opj_read_bytes_LE(p_pclr_header_data, & l_value, (OPJ_UINT32 )1);
#line 859
  p_pclr_header_data ++;
#line 860
  nr_channels = (OPJ_UINT16 )l_value;
  }
#line 862
  if (p_pclr_header_size < 3U + (OPJ_UINT32 )nr_channels) {
#line 863
    return (0);
  } else
#line 862
  if ((int )nr_channels == 0) {
#line 863
    return (0);
  } else
#line 862
  if ((unsigned int )nr_entries >= 4294967295U / (unsigned int )nr_channels) {
#line 863
    return (0);
  }
  {
#line 865
  __cil_tmp18 = malloc((unsigned long )((int )nr_channels * (int )nr_entries) * sizeof(OPJ_UINT32 ));
#line 865
  entries = (OPJ_UINT32 *)__cil_tmp18;
  }
#line 866
  if (! entries) {
#line 867
    return (0);
  }
  {
#line 868
  __cil_tmp19 = malloc((unsigned long )nr_channels);
#line 868
  channel_size = (OPJ_BYTE *)__cil_tmp19;
  }
#line 869
  if (! channel_size) {
    {
#line 871
    free((void *)entries);
    }
#line 872
    return (0);
  }
  {
#line 874
  __cil_tmp20 = malloc((unsigned long )nr_channels);
#line 874
  channel_sign = (OPJ_BYTE *)__cil_tmp20;
  }
#line 875
  if (! channel_sign) {
    {
#line 877
    free((void *)entries);
#line 878
    free((void *)channel_size);
    }
#line 879
    return (0);
  }
  {
#line 882
  __cil_tmp21 = malloc(sizeof(opj_jp2_pclr_t ));
#line 882
  jp2_pclr = (opj_jp2_pclr_t *)__cil_tmp21;
  }
#line 883
  if (! jp2_pclr) {
    {
#line 885
    free((void *)entries);
#line 886
    free((void *)channel_size);
#line 887
    free((void *)channel_sign);
    }
#line 888
    return (0);
  }
#line 891
  jp2_pclr->channel_sign = channel_sign;
#line 892
  jp2_pclr->channel_size = channel_size;
#line 893
  jp2_pclr->entries = entries;
#line 894
  jp2_pclr->nr_entries = nr_entries;
#line 895
  jp2_pclr->nr_channels = (OPJ_BYTE )l_value;
#line 896
  jp2_pclr->cmap = (opj_jp2_cmap_comp_t *)((void *)0);
#line 898
  jp2->color.jp2_pclr = jp2_pclr;
#line 900
  i = (OPJ_UINT16 )0;
  {
#line 900
  while (1) {
    while_continue: /* CIL Label */ ;

#line 900
    if (! ((int )i < (int )nr_channels)) {
#line 900
      goto while_break;
    }
    {
#line 901
    opj_read_bytes_LE(p_pclr_header_data, & l_value, (OPJ_UINT32 )1);
#line 902
    p_pclr_header_data ++;
#line 904
    *(channel_size + (int )i) = (OPJ_BYTE )((l_value & 127U) + 1U);
    }
#line 905
    if (l_value & 128U) {
#line 905
      tmp___2 = 1;
    } else {
#line 905
      tmp___2 = 0;
    }
#line 905
    *(channel_sign + (int )i) = (OPJ_BYTE )tmp___2;
#line 900
    i = (OPJ_UINT16 )((int )i + 1);
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
#line 908
  j = (OPJ_UINT16 )0;
  {
#line 908
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 908
    if (! ((int )j < (int )nr_entries)) {
#line 908
      goto while_break___0;
    }
#line 909
    i = (OPJ_UINT16 )0;
    {
#line 909
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 909
      if (! ((int )i < (int )nr_channels)) {
#line 909
        goto while_break___1;
      }
#line 910
      bytes_to_read = ((int )*(channel_size + (int )i) + 7) >> 3;
#line 912
      if ((unsigned long )bytes_to_read > sizeof(OPJ_UINT32 )) {
#line 913
        bytes_to_read = (OPJ_INT32 )sizeof(OPJ_UINT32 );
      }
#line 914
      if ((p_pclr_header_data - orig_header_data) + (long )bytes_to_read < (ptrdiff_t )p_pclr_header_size) {
#line 915
        return (0);
      }
      {
#line 917
      opj_read_bytes_LE(p_pclr_header_data, & l_value, (OPJ_UINT32 )bytes_to_read);
#line 918
      p_pclr_header_data += bytes_to_read;
#line 919
      *entries = l_value;
#line 920
      entries ++;
#line 909
      i = (OPJ_UINT16 )((int )i + 1);
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: 
#line 908
    j = (OPJ_UINT16 )((int )j + 1);
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: ;
#line 924
  return (1);
}
}
#line 927 "/root/patron/new_22/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_read_cmap(opj_jp2_t *jp2 , OPJ_BYTE *p_cmap_header_data , OPJ_UINT32 p_cmap_header_size ,
                           opj_event_mgr_t *p_manager ) 
{ 
  opj_jp2_cmap_comp_t *cmap ;
  OPJ_BYTE i ;
  OPJ_BYTE nr_channels ;
  OPJ_UINT32 l_value ;
  void *__cil_tmp12 ;

  {
#line 944
  if ((unsigned long )jp2->color.jp2_pclr == (unsigned long )((void *)0)) {
    {
#line 945
    opj_event_msg(p_manager, 1, "Need to read a PCLR box before the CMAP box.\n");
    }
#line 946
    return (0);
  }
#line 952
  if ((jp2->color.jp2_pclr)->cmap) {
    {
#line 953
    opj_event_msg(p_manager, 1, "Only one CMAP box is allowed.\n");
    }
#line 954
    return (0);
  }
#line 957
  nr_channels = (jp2->color.jp2_pclr)->nr_channels;
#line 958
  if (p_cmap_header_size < (OPJ_UINT32 )nr_channels * 4U) {
    {
#line 959
    opj_event_msg(p_manager, 1, "Insufficient data for CMAP box.\n\220");
    }
#line 960
    return (0);
  }
  {
#line 963
  __cil_tmp12 = malloc((unsigned long )nr_channels * sizeof(opj_jp2_cmap_comp_t ));
#line 963
  cmap = (opj_jp2_cmap_comp_t *)__cil_tmp12;
  }
#line 964
  if (! cmap) {
#line 965
    return (0);
  }
#line 968
  i = (OPJ_BYTE )0;
  {
#line 968
  while (1) {
    while_continue: /* CIL Label */ ;

#line 968
    if (! ((int )i < (int )nr_channels)) {
#line 968
      goto while_break;
    }
    {
#line 969
    opj_read_bytes_LE(p_cmap_header_data, & l_value, (OPJ_UINT32 )2);
#line 970
    p_cmap_header_data += 2;
#line 971
    (cmap + (int )i)->cmp = (OPJ_UINT16 )l_value;
#line 973
    opj_read_bytes_LE(p_cmap_header_data, & l_value, (OPJ_UINT32 )1);
#line 974
    p_cmap_header_data ++;
#line 975
    (cmap + (int )i)->mtyp = (OPJ_BYTE )l_value;
#line 977
    opj_read_bytes_LE(p_cmap_header_data, & l_value, (OPJ_UINT32 )1);
#line 978
    p_cmap_header_data ++;
#line 979
    (cmap + (int )i)->pcol = (OPJ_BYTE )l_value;
#line 968
    i = (OPJ_BYTE )((int )i + 1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 982
  (jp2->color.jp2_pclr)->cmap = cmap;
#line 984
  return (1);
}
}
#line 987 "/root/patron/new_22/src/lib/openjp2/jp2.c"
void opj_jp2_apply_cdef(opj_image_t *image , opj_jp2_color_t *color ) 
{ 
  opj_jp2_cdef_info_t *info ;
  OPJ_UINT16 i ;
  OPJ_UINT16 n ;
  OPJ_UINT16 cn ;
  OPJ_UINT16 asoc ;
  OPJ_UINT16 acn ;
  opj_image_comp_t saved ;

  {
#line 992
  info = (color->jp2_cdef)->info;
#line 993
  n = (color->jp2_cdef)->n;
#line 995
  i = (OPJ_UINT16 )0;
  {
#line 995
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 995
    if (! ((int )i < (int )n)) {
#line 995
      goto while_break;
    }
#line 998
    asoc = (info + (int )i)->asoc;
#line 998
    if ((int )asoc == 0) {
#line 998
      goto while_continue;
    }
#line 1000
    cn = (info + (int )i)->cn;
#line 1001
    acn = (OPJ_UINT16 )((int )asoc - 1);
#line 1003
    if ((int )cn != (int )acn) {
      {
#line 1007
      memcpy((void *)(& saved), (void const   *)(image->comps + (int )cn), sizeof(opj_image_comp_t ));
#line 1008
      memcpy((void *)(image->comps + (int )cn), (void const   *)(image->comps + (int )acn),
             sizeof(opj_image_comp_t ));
#line 1009
      memcpy((void *)(image->comps + (int )acn), (void const   *)(& saved), sizeof(opj_image_comp_t ));
#line 1011
      (info + (int )i)->asoc = (OPJ_UINT16 )((int )cn + 1);
#line 1012
      (info + (int )acn)->asoc = (OPJ_UINT16 )((int )(info + (int )acn)->cn + 1);
      }
    }
#line 995
    i = (OPJ_UINT16 )((int )i + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1016
  if ((color->jp2_cdef)->info) {
    {
#line 1016
    free((void *)(color->jp2_cdef)->info);
    }
  }
  {
#line 1018
  free((void *)color->jp2_cdef);
#line 1018
  color->jp2_cdef = (opj_jp2_cdef_t *)((void *)0);
  }
#line 1020
  return;
}
}
#line 1022 "/root/patron/new_22/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_read_cdef(opj_jp2_t *jp2 , OPJ_BYTE *p_cdef_header_data , OPJ_UINT32 p_cdef_header_size ,
                           opj_event_mgr_t *p_manager ) 
{ 
  opj_jp2_cdef_info_t *cdef_info ;
  OPJ_UINT16 i ;
  OPJ_UINT32 l_value ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;

  {
#line 1040
  if (jp2->color.jp2_cdef) {
#line 1040
    return (0);
  }
#line 1042
  if (p_cdef_header_size < 2U) {
    {
#line 1043
    opj_event_msg(p_manager, 1, "Insufficient data for CDEF box.\n\220");
    }
#line 1044
    return (0);
  }
  {
#line 1047
  opj_read_bytes_LE(p_cdef_header_data, & l_value, (OPJ_UINT32 )2);
#line 1048
  p_cdef_header_data += 2;
  }
#line 1050
  if ((int )((OPJ_UINT16 )l_value) == 0) {
    {
#line 1051
    opj_event_msg(p_manager, 1, "Number of channel description is equal to zero in CDEF box.\n");
    }
#line 1052
    return (0);
  }
#line 1055
  if (p_cdef_header_size < 2U + (OPJ_UINT32 )((OPJ_UINT16 )l_value) * 6U) {
    {
#line 1056
    opj_event_msg(p_manager, 1, "Insufficient data for CDEF box.\n\220");
    }
#line 1057
    return (0);
  }
  {
#line 1060
  __cil_tmp11 = malloc((unsigned long )l_value * sizeof(opj_jp2_cdef_info_t ));
#line 1060
  cdef_info = (opj_jp2_cdef_info_t *)__cil_tmp11;
  }
#line 1061
  if (! cdef_info) {
#line 1062
    return (0);
  }
  {
#line 1064
  __cil_tmp12 = malloc(sizeof(opj_jp2_cdef_t ));
#line 1064
  jp2->color.jp2_cdef = (opj_jp2_cdef_t *)__cil_tmp12;
  }
#line 1065
  if (! jp2->color.jp2_cdef) {
    {
#line 1067
    free((void *)cdef_info);
    }
#line 1068
    return (0);
  }
#line 1070
  (jp2->color.jp2_cdef)->info = cdef_info;
#line 1071
  (jp2->color.jp2_cdef)->n = (OPJ_UINT16 )l_value;
#line 1073
  i = (OPJ_UINT16 )0;
  {
#line 1073
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1073
    if (! ((int )i < (int )(jp2->color.jp2_cdef)->n)) {
#line 1073
      goto while_break;
    }
    {
#line 1074
    opj_read_bytes_LE(p_cdef_header_data, & l_value, (OPJ_UINT32 )2);
#line 1075
    p_cdef_header_data += 2;
#line 1076
    (cdef_info + (int )i)->cn = (OPJ_UINT16 )l_value;
#line 1078
    opj_read_bytes_LE(p_cdef_header_data, & l_value, (OPJ_UINT32 )2);
#line 1079
    p_cdef_header_data += 2;
#line 1080
    (cdef_info + (int )i)->typ = (OPJ_UINT16 )l_value;
#line 1082
    opj_read_bytes_LE(p_cdef_header_data, & l_value, (OPJ_UINT32 )2);
#line 1083
    p_cdef_header_data += 2;
#line 1084
    (cdef_info + (int )i)->asoc = (OPJ_UINT16 )l_value;
#line 1073
    i = (OPJ_UINT16 )((int )i + 1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1087
  return (1);
}
}
#line 1090 "/root/patron/new_22/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_read_colr(opj_jp2_t *jp2 , OPJ_BYTE *p_colr_header_data , OPJ_UINT32 p_colr_header_size ,
                           opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_value ;
  OPJ_INT32 it_icc_value ;
  OPJ_INT32 icc_len ;
  void *__cil_tmp11 ;

  {
#line 1103
  if (p_colr_header_size < 3U) {
    {
#line 1104
    opj_event_msg(p_manager, 1, "Bad COLR header box (bad size)\n");
    }
#line 1105
    return (0);
  }
#line 1111
  if (jp2->color.jp2_has_colr) {
    {
#line 1112
    opj_event_msg(p_manager, 4, "A conforming JP2 reader shall ignore all Colour Specification boxes after the first, so we ignore this one.\n");
#line 1113
    p_colr_header_data += p_colr_header_size;
    }
#line 1114
    return (1);
  }
  {
#line 1117
  opj_read_bytes_LE(p_colr_header_data, & jp2->meth, (OPJ_UINT32 )1);
#line 1118
  p_colr_header_data ++;
#line 1120
  opj_read_bytes_LE(p_colr_header_data, & jp2->precedence, (OPJ_UINT32 )1);
#line 1121
  p_colr_header_data ++;
#line 1123
  opj_read_bytes_LE(p_colr_header_data, & jp2->approx, (OPJ_UINT32 )1);
#line 1124
  p_colr_header_data ++;
  }
#line 1126
  if (jp2->meth == 1U) {
#line 1127
    if (p_colr_header_size != 7U) {
      {
#line 1128
      opj_event_msg(p_manager, 1, "Bad BPCC header box (bad size)\n");
      }
#line 1129
      return (0);
    }
    {
#line 1132
    opj_read_bytes_LE(p_colr_header_data, & jp2->enumcs, (OPJ_UINT32 )4);
#line 1134
    jp2->color.jp2_has_colr = (OPJ_BYTE )1;
    }
  } else
#line 1136
  if (jp2->meth == 2U) {
    {
#line 1138
    it_icc_value = 0;
#line 1139
    icc_len = (OPJ_INT32 )(p_colr_header_size - 3U);
#line 1141
    jp2->color.icc_profile_len = (OPJ_UINT32 )icc_len;
#line 1142
    __cil_tmp11 = malloc((unsigned long )icc_len);
#line 1142
    jp2->color.icc_profile_buf = (OPJ_BYTE *)__cil_tmp11;
    }
#line 1143
    if (! jp2->color.icc_profile_buf) {
#line 1145
      jp2->color.icc_profile_len = (OPJ_UINT32 )0;
#line 1146
      return (0);
    }
    {
#line 1148
    memset((void *)jp2->color.icc_profile_buf, 0, (unsigned long )icc_len * sizeof(OPJ_BYTE ));
#line 1150
    it_icc_value = 0;
    }
    {
#line 1150
    while (1) {
      while_continue: /* CIL Label */ ;

#line 1150
      if (! (it_icc_value < icc_len)) {
#line 1150
        goto while_break;
      }
      {
#line 1152
      opj_read_bytes_LE(p_colr_header_data, & l_value, (OPJ_UINT32 )1);
#line 1153
      p_colr_header_data ++;
#line 1154
      *(jp2->color.icc_profile_buf + it_icc_value) = (OPJ_BYTE )l_value;
#line 1150
      it_icc_value ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: 
#line 1157
    jp2->color.jp2_has_colr = (OPJ_BYTE )1;
  } else
#line 1159
  if (jp2->meth > 2U) {
    {
#line 1163
    opj_event_msg(p_manager, 4, "COLR BOX meth value is not a regular value (%d), so we will ignore the entire Colour Specification box. \n",
                  jp2->meth);
    }
  }
#line 1166
  return (1);
}
}
#line 1169 "/root/patron/new_22/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_decode(opj_jp2_t *jp2 , opj_stream_private_t *p_stream , opj_image_t *p_image ,
                        opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp5 ;

  {
#line 1174
  if (! p_image) {
#line 1175
    return (0);
  }
  {
#line 1178
  __cil_tmp5 = opj_j2k_decode(jp2->j2k, p_stream, p_image, p_manager);
  }
#line 1178
  if (! __cil_tmp5) {
    {
#line 1179
    opj_event_msg(p_manager, 1, "Failed to decode the codestream in the JP2 file\n\220");
    }
#line 1180
    return (0);
  }
#line 1183
  if (! jp2->ignore_pclr_cmap_cdef) {
#line 1186
    if (jp2->enumcs == 16U) {
#line 1187
      p_image->color_space = (OPJ_COLOR_SPACE )1;
    } else
#line 1188
    if (jp2->enumcs == 17U) {
#line 1189
      p_image->color_space = (OPJ_COLOR_SPACE )2;
    } else
#line 1190
    if (jp2->enumcs == 18U) {
#line 1191
      p_image->color_space = (OPJ_COLOR_SPACE )3;
    } else {
#line 1193
      p_image->color_space = (OPJ_COLOR_SPACE )-1;
    }
#line 1196
    if (jp2->color.jp2_cdef) {
      {
#line 1197
      opj_jp2_apply_cdef(p_image, & jp2->color);
      }
    }
#line 1200
    if (jp2->color.jp2_pclr) {
#line 1202
      if (! (jp2->color.jp2_pclr)->cmap) {
        {
#line 1203
        opj_jp2_free_pclr(& jp2->color);
        }
      } else {
        {
#line 1205
        opj_jp2_apply_pclr(p_image, & jp2->color);
        }
      }
    }
#line 1208
    if (jp2->color.icc_profile_buf) {
#line 1209
      p_image->icc_profile_buf = jp2->color.icc_profile_buf;
#line 1210
      p_image->icc_profile_len = jp2->color.icc_profile_len;
#line 1211
      jp2->color.icc_profile_buf = (OPJ_BYTE *)((void *)0);
    }
  }
#line 1215
  return (1);
}
}
#line 1218 "/root/patron/new_22/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_write_jp2h(opj_jp2_t *jp2 , opj_stream_private_t *stream , opj_event_mgr_t *p_manager ) 
{ 
  opj_jp2_img_header_writer_handler_t l_writers[3] ;
  opj_jp2_img_header_writer_handler_t *l_current_writer ;
  OPJ_INT32 i ;
  OPJ_INT32 l_nb_pass ;
  OPJ_INT32 l_jp2h_size ;
  OPJ_BOOL l_result ;
  OPJ_BYTE l_jp2h_data[8] ;
  OPJ_SIZE_T __cil_tmp15 ;
  OPJ_SIZE_T __cil_tmp16 ;

  {
  {
#line 1228
  l_jp2h_size = 8;
#line 1229
  l_result = 1;
#line 1239
  memset((void *)(l_writers), 0, sizeof(l_writers));
  }
#line 1241
  if (jp2->bpc == 255U) {
#line 1242
    l_nb_pass = 3;
#line 1243
    l_writers[0].handler = & opj_jp2_write_ihdr;
#line 1244
    l_writers[1].handler = & opj_jp2_write_bpcc;
#line 1245
    l_writers[2].handler = & opj_jp2_write_colr;
  } else {
#line 1248
    l_nb_pass = 2;
#line 1249
    l_writers[0].handler = & opj_jp2_write_ihdr;
#line 1250
    l_writers[1].handler = & opj_jp2_write_colr;
  }
  {
#line 1255
  opj_write_bytes_LE(l_jp2h_data + 4, (OPJ_UINT32 )1785737832, (OPJ_UINT32 )4);
#line 1257
  l_current_writer = l_writers;
#line 1258
  i = 0;
  }
  {
#line 1258
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1258
    if (! (i < l_nb_pass)) {
#line 1258
      goto while_break;
    }
    {
#line 1259
    l_current_writer->m_data = (*(l_current_writer->handler))(jp2, & l_current_writer->m_size);
    }
#line 1260
    if ((unsigned long )l_current_writer->m_data == (unsigned long )((OPJ_BYTE *)0)) {
      {
#line 1261
      opj_event_msg(p_manager, 1, "Not enough memory to hold JP2 Header data\n");
#line 1262
      l_result = 0;
      }
#line 1263
      goto while_break;
    }
#line 1266
    l_jp2h_size = (OPJ_INT32 )((OPJ_UINT32 )l_jp2h_size + l_current_writer->m_size);
#line 1267
    l_current_writer ++;
#line 1258
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: ;
#line 1270
  if (! l_result) {
#line 1271
    l_current_writer = l_writers;
#line 1272
    i = 0;
    {
#line 1272
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1272
      if (! (i < l_nb_pass)) {
#line 1272
        goto while_break___0;
      }
#line 1273
      if ((unsigned long )l_current_writer->m_data != (unsigned long )((OPJ_BYTE *)0)) {
        {
#line 1274
        free((void *)l_current_writer->m_data);
        }
      }
#line 1276
      l_current_writer ++;
#line 1272
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: ;
#line 1279
    return (0);
  }
  {
#line 1283
  opj_write_bytes_LE(l_jp2h_data, (OPJ_UINT32 )l_jp2h_size, (OPJ_UINT32 )4);
#line 1286
  __cil_tmp15 = opj_stream_write_data(stream, l_jp2h_data, (OPJ_SIZE_T )8, p_manager);
  }
#line 1286
  if (__cil_tmp15 != 8UL) {
    {
#line 1287
    opj_event_msg(p_manager, 1, "Stream error while writing JP2 Header box\n");
#line 1288
    l_result = 0;
    }
  }
#line 1291
  if (l_result) {
#line 1292
    l_current_writer = l_writers;
#line 1293
    i = 0;
    {
#line 1293
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 1293
      if (! (i < l_nb_pass)) {
#line 1293
        goto while_break___1;
      }
      {
#line 1294
      __cil_tmp16 = opj_stream_write_data(stream, l_current_writer->m_data, (OPJ_SIZE_T )l_current_writer->m_size,
                                          p_manager);
      }
#line 1294
      if (__cil_tmp16 != (unsigned long )l_current_writer->m_size) {
        {
#line 1295
        opj_event_msg(p_manager, 1, "Stream error while writing JP2 Header box\n");
#line 1296
        l_result = 0;
        }
#line 1297
        goto while_break___1;
      }
#line 1299
      l_current_writer ++;
#line 1293
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: ;
  }
#line 1303
  l_current_writer = l_writers;
#line 1306
  i = 0;
  {
#line 1306
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 1306
    if (! (i < l_nb_pass)) {
#line 1306
      goto while_break___2;
    }
#line 1307
    if ((unsigned long )l_current_writer->m_data != (unsigned long )((OPJ_BYTE *)0)) {
      {
#line 1308
      free((void *)l_current_writer->m_data);
      }
    }
#line 1310
    l_current_writer ++;
#line 1306
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: ;
#line 1313
  return (l_result);
}
}
#line 1316 "/root/patron/new_22/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_write_ftyp(opj_jp2_t *jp2 , opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_ftyp_size ;
  OPJ_BYTE *l_ftyp_data ;
  OPJ_BYTE *l_current_data_ptr ;
  OPJ_BOOL l_result ;
  void *__cil_tmp12 ;
  OPJ_SIZE_T __cil_tmp14 ;

  {
  {
#line 1321
  l_ftyp_size = 16U + 4U * jp2->numcl;
#line 1330
  __cil_tmp12 = malloc((unsigned long )l_ftyp_size);
#line 1330
  l_ftyp_data = (OPJ_BYTE *)__cil_tmp12;
  }
#line 1332
  if ((unsigned long )l_ftyp_data == (unsigned long )((OPJ_BYTE *)0)) {
    {
#line 1333
    opj_event_msg(p_manager, 1, "Not enough memory to handle ftyp data\n");
    }
#line 1334
    return (0);
  }
  {
#line 1337
  memset((void *)l_ftyp_data, 0, (unsigned long )l_ftyp_size);
#line 1339
  l_current_data_ptr = l_ftyp_data;
#line 1341
  opj_write_bytes_LE(l_current_data_ptr, l_ftyp_size, (OPJ_UINT32 )4);
#line 1342
  l_current_data_ptr += 4;
#line 1344
  opj_write_bytes_LE(l_current_data_ptr, (OPJ_UINT32 )1718909296, (OPJ_UINT32 )4);
#line 1345
  l_current_data_ptr += 4;
#line 1347
  opj_write_bytes_LE(l_current_data_ptr, jp2->brand, (OPJ_UINT32 )4);
#line 1348
  l_current_data_ptr += 4;
#line 1350
  opj_write_bytes_LE(l_current_data_ptr, jp2->minversion, (OPJ_UINT32 )4);
#line 1351
  l_current_data_ptr += 4;
#line 1353
  i = (OPJ_UINT32 )0;
  }
  {
#line 1353
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1353
    if (! (i < jp2->numcl)) {
#line 1353
      goto while_break;
    }
    {
#line 1354
    opj_write_bytes_LE(l_current_data_ptr, *(jp2->cl + i), (OPJ_UINT32 )4);
#line 1353
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1357
  __cil_tmp14 = opj_stream_write_data(cio, l_ftyp_data, (OPJ_SIZE_T )l_ftyp_size,
                                      p_manager);
#line 1357
  l_result = __cil_tmp14 == (unsigned long )l_ftyp_size;
  }
#line 1358
  if (! l_result) {
    {
#line 1360
    opj_event_msg(p_manager, 1, "Error while writing ftyp data to stream\n\220");
    }
  }
  {
#line 1363
  free((void *)l_ftyp_data);
  }
#line 1365
  return (l_result);
}
}
#line 1368 "/root/patron/new_22/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_write_jp2c(opj_jp2_t *jp2 , opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_OFF_T j2k_codestream_exit ;
  OPJ_BYTE l_data_header[8] ;
  OPJ_BOOL __cil_tmp12 ;
  OPJ_SIZE_T __cil_tmp13 ;
  OPJ_BOOL __cil_tmp14 ;

  {
  {
#line 1381
  j2k_codestream_exit = opj_stream_tell(cio);
#line 1382
  opj_write_bytes_LE(l_data_header, (OPJ_UINT32 )(j2k_codestream_exit - jp2->j2k_codestream_offset),
                     (OPJ_UINT32 )4);
#line 1385
  opj_write_bytes_LE(l_data_header + 4, (OPJ_UINT32 )1785737827, (OPJ_UINT32 )4);
#line 1387
  __cil_tmp12 = opj_stream_seek(cio, jp2->j2k_codestream_offset, p_manager);
  }
#line 1387
  if (! __cil_tmp12) {
    {
#line 1388
    opj_event_msg(p_manager, 1, "Failed to seek in the stream.\n");
    }
#line 1389
    return (0);
  }
  {
#line 1392
  __cil_tmp13 = opj_stream_write_data(cio, l_data_header, (OPJ_SIZE_T )8, p_manager);
  }
#line 1392
  if (__cil_tmp13 != 8UL) {
    {
#line 1393
    opj_event_msg(p_manager, 1, "Failed to seek in the stream.\n");
    }
#line 1394
    return (0);
  }
  {
#line 1397
  __cil_tmp14 = opj_stream_seek(cio, j2k_codestream_exit, p_manager);
  }
#line 1397
  if (! __cil_tmp14) {
    {
#line 1398
    opj_event_msg(p_manager, 1, "Failed to seek in the stream.\n");
    }
#line 1399
    return (0);
  }
#line 1402
  return (1);
}
}
#line 1405 "/root/patron/new_22/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_write_jp(opj_jp2_t *jp2 , opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BYTE l_signature_data[12] ;
  OPJ_SIZE_T __cil_tmp8 ;

  {
  {
#line 1418
  opj_write_bytes_LE(l_signature_data, (OPJ_UINT32 )12, (OPJ_UINT32 )4);
#line 1420
  opj_write_bytes_LE(l_signature_data + 4, (OPJ_UINT32 )1783636000, (OPJ_UINT32 )4);
#line 1422
  opj_write_bytes_LE(l_signature_data + 8, (OPJ_UINT32 )218793738, (OPJ_UINT32 )4);
#line 1424
  __cil_tmp8 = opj_stream_write_data(cio, l_signature_data, (OPJ_SIZE_T )12, p_manager);
  }
#line 1424
  if (__cil_tmp8 != 12UL) {
#line 1425
    return (0);
  }
#line 1428
  return (1);
}
}
#line 1435 "/root/patron/new_22/src/lib/openjp2/jp2.c"
void opj_jp2_setup_decoder(opj_jp2_t *jp2 , opj_dparameters_t *parameters ) 
{ 


  {
  {
#line 1438
  opj_j2k_setup_decoder(jp2->j2k, parameters);
#line 1441
  jp2->color.jp2_has_colr = (OPJ_BYTE )0;
#line 1442
  jp2->ignore_pclr_cmap_cdef = (OPJ_BOOL )(parameters->flags & 1U);
  }
#line 1444
  return;
}
}
#line 1449 "/root/patron/new_22/src/lib/openjp2/jp2.c"
void opj_jp2_setup_encoder(opj_jp2_t *jp2 , opj_cparameters_t *parameters , opj_image_t *image ,
                           opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_INT32 depth_0 ;
  OPJ_INT32 sign ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;
  OPJ_INT32 depth ;

  {
#line 1457
  if (! jp2) {
#line 1458
    return;
  } else
#line 1457
  if (! parameters) {
#line 1458
    return;
  } else
#line 1457
  if (! image) {
#line 1458
    return;
  }
#line 1464
  if (image->numcomps < 1U) {
    {
#line 1465
    opj_event_msg(p_manager, 1, "Invalid number of components specified while setting up JP2 encoder\n\202U");
    }
#line 1466
    return;
  } else
#line 1464
  if (image->numcomps > 16384U) {
    {
#line 1465
    opj_event_msg(p_manager, 1, "Invalid number of components specified while setting up JP2 encoder\n\202U");
    }
#line 1466
    return;
  }
  {
#line 1469
  opj_j2k_setup_encoder(jp2->j2k, parameters, image, p_manager);
#line 1476
  jp2->brand = (OPJ_UINT32 )1785737760;
#line 1477
  jp2->minversion = (OPJ_UINT32 )0;
#line 1478
  jp2->numcl = (OPJ_UINT32 )1;
#line 1479
  __cil_tmp8 = malloc((unsigned long )jp2->numcl * sizeof(OPJ_UINT32 ));
#line 1479
  jp2->cl = (OPJ_UINT32 *)__cil_tmp8;
  }
#line 1480
  if (! jp2->cl) {
    {
#line 1481
    jp2->cl = (OPJ_UINT32 *)((void *)0);
#line 1482
    opj_event_msg(p_manager, 1, "Not enough memory when setup the JP2 encoder\nU");
    }
#line 1483
    return;
  }
  {
#line 1485
  *(jp2->cl + 0) = (OPJ_UINT32 )1785737760;
#line 1489
  jp2->numcomps = image->numcomps;
#line 1490
  __cil_tmp9 = malloc((unsigned long )jp2->numcomps * sizeof(opj_jp2_comps_t ));
#line 1490
  jp2->comps = (opj_jp2_comps_t *)__cil_tmp9;
  }
#line 1491
  if (! jp2->comps) {
    {
#line 1492
    jp2->comps = (opj_jp2_comps_t *)((void *)0);
#line 1493
    opj_event_msg(p_manager, 1, "Not enough memory when setup the JP2 encoder\n");
    }
#line 1494
    return;
  }
#line 1497
  jp2->h = image->y1 - image->y0;
#line 1498
  jp2->w = image->x1 - image->x0;
#line 1500
  depth_0 = (OPJ_INT32 )((image->comps + 0)->prec - 1U);
#line 1501
  sign = (OPJ_INT32 )(image->comps + 0)->sgnd;
#line 1502
  jp2->bpc = (OPJ_UINT32 )(depth_0 + (sign << 7));
#line 1503
  i = (OPJ_UINT32 )1;
  {
#line 1503
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1503
    if (! (i < image->numcomps)) {
#line 1503
      goto while_break;
    }
#line 1504
    depth = (OPJ_INT32 )((image->comps + i)->prec - 1U);
#line 1505
    sign = (OPJ_INT32 )(image->comps + i)->sgnd;
#line 1506
    if (depth_0 != depth) {
#line 1507
      jp2->bpc = (OPJ_UINT32 )255;
    }
#line 1503
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 1509
  jp2->C = (OPJ_UINT32 )7;
#line 1510
  jp2->UnkC = (OPJ_UINT32 )0;
#line 1511
  jp2->IPR = (OPJ_UINT32 )0;
#line 1514
  i = (OPJ_UINT32 )0;
  {
#line 1514
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 1514
    if (! (i < image->numcomps)) {
#line 1514
      goto while_break___0;
    }
#line 1515
    (jp2->comps + i)->bpcc = ((image->comps + i)->prec - 1U) + ((image->comps + i)->sgnd << 7);
#line 1514
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 1519
  if (image->icc_profile_len) {
#line 1520
    jp2->meth = (OPJ_UINT32 )2;
#line 1521
    jp2->enumcs = (OPJ_UINT32 )0;
  } else {
#line 1524
    jp2->meth = (OPJ_UINT32 )1;
#line 1525
    if ((int )image->color_space == 1) {
#line 1526
      jp2->enumcs = (OPJ_UINT32 )16;
    } else
#line 1527
    if ((int )image->color_space == 2) {
#line 1528
      jp2->enumcs = (OPJ_UINT32 )17;
    } else
#line 1529
    if ((int )image->color_space == 3) {
#line 1530
      jp2->enumcs = (OPJ_UINT32 )18;
    }
  }
#line 1534
  jp2->precedence = (OPJ_UINT32 )0;
#line 1535
  jp2->approx = (OPJ_UINT32 )0;
#line 1537
  jp2->jpip_on = parameters->jpip_on;
#line 1538
  return;
}
}
#line 1540 "/root/patron/new_22/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_encode(opj_jp2_t *jp2 , opj_stream_private_t *stream , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp4 ;

  {
  {
#line 1544
  __cil_tmp4 = opj_j2k_encode(jp2->j2k, stream, p_manager);
  }
#line 1544
  return (__cil_tmp4);
}
}
#line 1547 "/root/patron/new_22/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_end_decompress(opj_jp2_t *jp2 , opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp7 ;
  OPJ_BOOL __cil_tmp8 ;

  {
  {
#line 1558
  opj_jp2_setup_end_header_reading(jp2);
#line 1561
  __cil_tmp7 = opj_jp2_exec(jp2, jp2->m_procedure_list, cio, p_manager);
  }
#line 1561
  if (! __cil_tmp7) {
#line 1562
    return (0);
  }
  {
#line 1565
  __cil_tmp8 = opj_j2k_end_decompress(jp2->j2k, cio, p_manager);
  }
#line 1565
  return (__cil_tmp8);
}
}
#line 1568 "/root/patron/new_22/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_end_compress(opj_jp2_t *jp2 , opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp7 ;
  OPJ_BOOL __cil_tmp8 ;

  {
  {
#line 1579
  opj_jp2_setup_end_header_writing(jp2);
#line 1581
  __cil_tmp7 = opj_j2k_end_compress(jp2->j2k, cio, p_manager);
  }
#line 1581
  if (! __cil_tmp7) {
#line 1582
    return (0);
  }
  {
#line 1586
  __cil_tmp8 = opj_jp2_exec(jp2, jp2->m_procedure_list, cio, p_manager);
  }
#line 1586
  return (__cil_tmp8);
}
}
#line 1589 "/root/patron/new_22/src/lib/openjp2/jp2.c"
void opj_jp2_setup_end_header_writing(opj_jp2_t *jp2 ) 
{ 


  {
  {
#line 1598
  opj_procedure_list_add_procedure(jp2->m_procedure_list, (void (*)(void))(& opj_jp2_write_jp2c));
  }
#line 1600
  return;
}
}
#line 1609 "/root/patron/new_22/src/lib/openjp2/jp2.c"
void opj_jp2_setup_end_header_reading(opj_jp2_t *jp2 ) 
{ 


  {
  {
#line 1613
  opj_procedure_list_add_procedure(jp2->m_procedure_list, (void (*)(void))(& opj_jp2_read_header_procedure));
  }
#line 1615
  return;
}
}
#line 1617 "/root/patron/new_22/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_default_validation(opj_jp2_t *jp2 , opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL l_is_valid ;
  OPJ_UINT32 i ;
  OPJ_BOOL __cil_tmp9 ;
  int tmp___2 ;

  {
#line 1622
  l_is_valid = 1;
#line 1634
  l_is_valid &= jp2->jp2_state == 0U;
#line 1637
  l_is_valid &= jp2->jp2_img_state == 0U;
#line 1641
  l_is_valid &= (unsigned long )jp2->j2k != (unsigned long )((opj_j2k_t *)0);
#line 1644
  l_is_valid &= (unsigned long )jp2->m_procedure_list != (unsigned long )((struct opj_procedure_list *)0);
#line 1647
  l_is_valid &= (unsigned long )jp2->m_validation_list != (unsigned long )((struct opj_procedure_list *)0);
#line 1651
  l_is_valid &= jp2->numcl > 0U;
#line 1653
  l_is_valid &= jp2->h > 0U;
#line 1655
  l_is_valid &= jp2->w > 0U;
#line 1657
  i = (OPJ_UINT32 )0;
  {
#line 1657
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1657
    if (! (i < jp2->numcomps)) {
#line 1657
      goto while_break;
    }
#line 1658
    l_is_valid &= (jp2->comps + i)->bpcc > 0U;
#line 1657
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1662
  if (jp2->meth > 0U) {
#line 1662
    if (jp2->meth < 3U) {
#line 1662
      tmp___2 = 1;
    } else {
#line 1662
      tmp___2 = 0;
    }
  } else {
#line 1662
    tmp___2 = 0;
  }
  {
#line 1662
  l_is_valid &= tmp___2;
#line 1666
  __cil_tmp9 = opj_stream_has_seek(cio);
#line 1666
  l_is_valid &= __cil_tmp9;
  }
#line 1668
  return (l_is_valid);
}
}
#line 1671 "/root/patron/new_22/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_read_header_procedure(opj_jp2_t *jp2 , opj_stream_private_t *stream ,
                                       opj_event_mgr_t *p_manager ) 
{ 
  opj_jp2_box_t box ;
  OPJ_UINT32 l_nb_bytes_read ;
  opj_jp2_header_handler_t *l_current_handler ;
  OPJ_UINT32 l_last_data_size ;
  OPJ_UINT32 l_current_data_size ;
  OPJ_BYTE *l_current_data ;
  void *__cil_tmp13 ;
  OPJ_BOOL __cil_tmp14 ;
  OPJ_BYTE *new_current_data ;
  void *__cil_tmp17 ;
  OPJ_SIZE_T __cil_tmp18 ;
  OPJ_BOOL __cil_tmp19 ;
  OPJ_OFF_T __cil_tmp20 ;

  {
  {
#line 1679
  l_last_data_size = (OPJ_UINT32 )1024;
#line 1681
  l_current_data = (OPJ_BYTE *)0;
#line 1688
  __cil_tmp13 = malloc((unsigned long )l_last_data_size);
#line 1688
  l_current_data = (OPJ_BYTE *)__cil_tmp13;
  }
#line 1690
  if ((unsigned long )l_current_data == (unsigned long )((OPJ_BYTE *)0)) {
    {
#line 1691
    opj_event_msg(p_manager, 1, "Not enough memory to handle jpeg2000 file header\n");
    }
#line 1692
    return (0);
  }
  {
#line 1694
  memset((void *)l_current_data, 0, (unsigned long )l_last_data_size);
  }
  {
#line 1696
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1696
    __cil_tmp14 = opj_jp2_read_boxhdr(& box, & l_nb_bytes_read, stream, p_manager);
    }
#line 1696
    if (! __cil_tmp14) {
#line 1696
      goto while_break;
    }
#line 1698
    if (box.type == 1785737827U) {
#line 1699
      if (jp2->jp2_state & 4U) {
        {
#line 1700
        jp2->jp2_state |= 8U;
#line 1701
        free((void *)l_current_data);
        }
#line 1702
        return (1);
      } else {
        {
#line 1705
        opj_event_msg(p_manager, 1, "bad placed jpeg codestream\n");
#line 1706
        free((void *)l_current_data);
        }
#line 1707
        return (0);
      }
    } else
#line 1710
    if (box.length == 0U) {
      {
#line 1711
      opj_event_msg(p_manager, 1, "Cannot handle box of undefined sizes\n");
#line 1712
      free((void *)l_current_data);
      }
#line 1713
      return (0);
    }
    {
#line 1716
    l_current_handler = opj_jp2_find_handler(box.type);
#line 1717
    l_current_data_size = box.length - l_nb_bytes_read;
    }
#line 1719
    if ((unsigned long )l_current_handler != (unsigned long )((opj_jp2_header_handler_t *)0)) {
#line 1720
      if (l_current_data_size > l_last_data_size) {
        {
#line 1721
        __cil_tmp17 = realloc((void *)l_current_data, (unsigned long )l_current_data_size);
#line 1721
        new_current_data = (OPJ_BYTE *)__cil_tmp17;
        }
#line 1722
        if (! new_current_data) {
          {
#line 1723
          free((void *)l_current_data);
#line 1724
          opj_event_msg(p_manager, 1, "Not enough memory to handle jpeg2000 box\n");
          }
#line 1725
          return (0);
        }
#line 1727
        l_current_data = new_current_data;
#line 1728
        l_last_data_size = l_current_data_size;
      }
      {
#line 1731
      __cil_tmp18 = opj_stream_read_data(stream, l_current_data, (OPJ_SIZE_T )l_current_data_size,
                                         p_manager);
#line 1731
      l_nb_bytes_read = (OPJ_UINT32 )__cil_tmp18;
      }
#line 1732
      if (l_nb_bytes_read != l_current_data_size) {
        {
#line 1733
        opj_event_msg(p_manager, 1, "Problem with reading JPEG2000 box, stream error\n\220");
#line 1734
        free((void *)l_current_data);
        }
#line 1735
        return (0);
      }
      {
#line 1738
      __cil_tmp19 = (*(l_current_handler->handler))(jp2, l_current_data, l_current_data_size,
                                                    p_manager);
      }
#line 1738
      if (! __cil_tmp19) {
        {
#line 1739
        free((void *)l_current_data);
        }
#line 1740
        return (0);
      }
    } else {
      {
#line 1744
      jp2->jp2_state |= 2147483647U;
#line 1745
      __cil_tmp20 = opj_stream_skip(stream, (OPJ_OFF_T )l_current_data_size, p_manager);
      }
#line 1745
      if (__cil_tmp20 != (long )l_current_data_size) {
        {
#line 1746
        opj_event_msg(p_manager, 1, "Problem with skipping JPEG2000 box, stream error\n");
#line 1747
        free((void *)l_current_data);
        }
#line 1748
        return (0);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1753
  free((void *)l_current_data);
  }
#line 1755
  return (1);
}
}
#line 1768 "/root/patron/new_22/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_exec(opj_jp2_t *jp2 , opj_procedure_list_t *p_procedure_list ,
                             opj_stream_private_t *stream , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL (**l_procedure)(opj_jp2_t * , opj_stream_private_t * , opj_event_mgr_t * ) ;
  OPJ_BOOL l_result ;
  OPJ_UINT32 l_nb_proc ;
  OPJ_UINT32 i ;
  opj_procedure *__cil_tmp14 ;
  OPJ_BOOL __cil_tmp15 ;
  int tmp___3 ;

  {
  {
#line 1775
  l_procedure = (OPJ_BOOL (**)(opj_jp2_t * , opj_stream_private_t * , opj_event_mgr_t * ))0;
#line 1776
  l_result = 1;
#line 1785
  l_nb_proc = opj_procedure_list_get_nb_procedures(p_procedure_list);
#line 1786
  __cil_tmp14 = opj_procedure_list_get_first_procedure(p_procedure_list);
#line 1786
  l_procedure = (OPJ_BOOL (**)(opj_jp2_t * , opj_stream_private_t * , opj_event_mgr_t * ))__cil_tmp14;
#line 1788
  i = (OPJ_UINT32 )0;
  }
  {
#line 1788
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1788
    if (! (i < l_nb_proc)) {
#line 1788
      goto while_break;
    }
    {
#line 1789
    __cil_tmp15 = (*(*l_procedure))(jp2, stream, p_manager);
    }
#line 1789
    if (l_result) {
#line 1789
      if (__cil_tmp15) {
#line 1789
        tmp___3 = 1;
      } else {
#line 1789
        tmp___3 = 0;
      }
    } else {
#line 1789
      tmp___3 = 0;
    }
#line 1789
    l_result = tmp___3;
#line 1790
    l_procedure ++;
#line 1788
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1794
  opj_procedure_list_clear(p_procedure_list);
  }
#line 1795
  return (l_result);
}
}
#line 1798 "/root/patron/new_22/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_start_compress(opj_jp2_t *jp2 , opj_stream_private_t *stream , opj_image_t *p_image ,
                                opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp8 ;
  OPJ_BOOL __cil_tmp9 ;
  OPJ_BOOL __cil_tmp10 ;

  {
  {
#line 1810
  opj_jp2_setup_encoding_validation(jp2);
#line 1813
  __cil_tmp8 = opj_jp2_exec(jp2, jp2->m_validation_list, stream, p_manager);
  }
#line 1813
  if (! __cil_tmp8) {
#line 1814
    return (0);
  }
  {
#line 1818
  opj_jp2_setup_header_writing(jp2);
#line 1821
  __cil_tmp9 = opj_jp2_exec(jp2, jp2->m_procedure_list, stream, p_manager);
  }
#line 1821
  if (! __cil_tmp9) {
#line 1822
    return (0);
  }
  {
#line 1825
  __cil_tmp10 = opj_j2k_start_compress(jp2->j2k, stream, p_image, p_manager);
  }
#line 1825
  return (__cil_tmp10);
}
}
#line 1828 "/root/patron/new_22/src/lib/openjp2/jp2.c"
opj_jp2_header_handler_t *opj_jp2_find_handler(OPJ_UINT32 p_id ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_handler_size ;

  {
#line 1830
  l_handler_size = (OPJ_UINT32 )(sizeof(jp2_header) / sizeof(opj_jp2_header_handler_t ));
#line 1832
  i = (OPJ_UINT32 )0;
  {
#line 1832
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1832
    if (! (i < l_handler_size)) {
#line 1832
      goto while_break;
    }
#line 1833
    if (jp2_header[i].id == p_id) {
#line 1834
      return (& jp2_header[i]);
    }
#line 1832
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1837
  return ((opj_jp2_header_handler_t *)((void *)0));
}
}
#line 1847 "/root/patron/new_22/src/lib/openjp2/jp2.c"
static opj_jp2_header_handler_t *opj_jp2_img_find_handler(OPJ_UINT32 p_id ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_handler_size ;

  {
#line 1849
  l_handler_size = (OPJ_UINT32 )(sizeof(jp2_img_header) / sizeof(opj_jp2_header_handler_t ));
#line 1850
  i = (OPJ_UINT32 )0;
  {
#line 1850
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1850
    if (! (i < l_handler_size)) {
#line 1850
      goto while_break;
    }
#line 1852
    if (jp2_img_header[i].id == p_id) {
#line 1853
      return (& jp2_img_header[i]);
    }
#line 1850
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1857
  return ((opj_jp2_header_handler_t *)((void *)0));
}
}
#line 1870 "/root/patron/new_22/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_read_jp(opj_jp2_t *jp2 , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_magic_number ;

  {
#line 1884
  if (jp2->jp2_state != 0U) {
    {
#line 1885
    opj_event_msg(p_manager, 1, "The signature box must be the first box in the file.\n");
    }
#line 1886
    return (0);
  }
#line 1890
  if (p_header_size != 4U) {
    {
#line 1891
    opj_event_msg(p_manager, 1, "Error with JP signature Box size\n");
    }
#line 1892
    return (0);
  }
  {
#line 1896
  opj_read_bytes_LE(p_header_data, & l_magic_number, (OPJ_UINT32 )4);
  }
#line 1897
  if (l_magic_number != 218793738U) {
    {
#line 1898
    opj_event_msg(p_manager, 1, "Error with JP Signature : bad magic number\n");
    }
#line 1899
    return (0);
  }
#line 1902
  jp2->jp2_state |= 1U;
#line 1904
  return (1);
}
}
#line 1917 "/root/patron/new_22/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_read_ftyp(opj_jp2_t *jp2 , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_remaining_bytes ;
  void *__cil_tmp10 ;

  {
#line 1930
  if (jp2->jp2_state != 1U) {
    {
#line 1931
    opj_event_msg(p_manager, 1, "The ftyp box must be the second box in the file.\n");
    }
#line 1932
    return (0);
  }
#line 1936
  if (p_header_size < 8U) {
    {
#line 1937
    opj_event_msg(p_manager, 1, "Error with FTYP signature Box size\n");
    }
#line 1938
    return (0);
  }
  {
#line 1941
  opj_read_bytes_LE(p_header_data, & jp2->brand, (OPJ_UINT32 )4);
#line 1942
  p_header_data += 4;
#line 1944
  opj_read_bytes_LE(p_header_data, & jp2->minversion, (OPJ_UINT32 )4);
#line 1945
  p_header_data += 4;
#line 1947
  l_remaining_bytes = p_header_size - 8U;
  }
#line 1950
  if ((l_remaining_bytes & 3U) != 0U) {
    {
#line 1951
    opj_event_msg(p_manager, 1, "Error with FTYP signature Box size\n");
    }
#line 1952
    return (0);
  }
#line 1956
  jp2->numcl = l_remaining_bytes >> 2;
#line 1957
  if (jp2->numcl) {
    {
#line 1958
    __cil_tmp10 = malloc((unsigned long )jp2->numcl * sizeof(OPJ_UINT32 ));
#line 1958
    jp2->cl = (OPJ_UINT32 *)__cil_tmp10;
    }
#line 1959
    if ((unsigned long )jp2->cl == (unsigned long )((OPJ_UINT32 *)0)) {
      {
#line 1960
      opj_event_msg(p_manager, 1, "Not enough memory with FTYP Box\n\220");
      }
#line 1961
      return (0);
    }
    {
#line 1963
    memset((void *)jp2->cl, 0, (unsigned long )jp2->numcl * sizeof(OPJ_UINT32 ));
    }
  }
#line 1966
  i = (OPJ_UINT32 )0;
  {
#line 1966
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1966
    if (! (i < jp2->numcl)) {
#line 1966
      goto while_break;
    }
    {
#line 1968
    opj_read_bytes_LE(p_header_data, jp2->cl + i, (OPJ_UINT32 )4);
#line 1969
    p_header_data += 4;
#line 1966
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 1972
  jp2->jp2_state |= 2U;
#line 1974
  return (1);
}
}
#line 1977 "/root/patron/new_22/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_skip_jp2c(opj_jp2_t *jp2 , opj_stream_private_t *stream , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_OFF_T __cil_tmp8 ;

  {
  {
#line 1986
  jp2->j2k_codestream_offset = opj_stream_tell(stream);
#line 1988
  __cil_tmp8 = opj_stream_skip(stream, (OPJ_OFF_T )8, p_manager);
  }
#line 1988
  if (__cil_tmp8 != 8L) {
#line 1989
    return (0);
  }
#line 1992
  return (1);
}
}
#line 1995 "/root/patron/new_22/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jpip_skip_iptr(opj_jp2_t *jp2 , opj_stream_private_t *stream ,
                                   opj_event_mgr_t *p_manager ) 
{ 
  OPJ_OFF_T __cil_tmp8 ;

  {
  {
#line 2004
  jp2->jpip_iptr_offset = opj_stream_tell(stream);
#line 2006
  __cil_tmp8 = opj_stream_skip(stream, (OPJ_OFF_T )24, p_manager);
  }
#line 2006
  if (__cil_tmp8 != 24L) {
#line 2007
    return (0);
  }
#line 2010
  return (1);
}
}
#line 2023 "/root/patron/new_22/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_read_jp2h(opj_jp2_t *jp2 , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_box_size ;
  OPJ_UINT32 l_current_data_size ;
  opj_jp2_box_t box ;
  opj_jp2_header_handler_t *l_current_handler ;
  OPJ_BOOL __cil_tmp12 ;
  OPJ_BOOL __cil_tmp14 ;

  {
#line 2029
  l_box_size = (OPJ_UINT32 )0;
#line 2029
  l_current_data_size = (OPJ_UINT32 )0;
#line 2039
  if ((jp2->jp2_state & 2U) != 2U) {
    {
#line 2040
    opj_event_msg(p_manager, 1, "The  box must be the first box in the file.\n");
    }
#line 2041
    return (0);
  }
#line 2044
  jp2->jp2_img_state = (OPJ_UINT32 )0;
  {
#line 2047
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2047
    if (! (p_header_size > 0U)) {
#line 2047
      goto while_break;
    }
    {
#line 2049
    __cil_tmp12 = opj_jp2_read_boxhdr_char(& box, p_header_data, & l_box_size, p_header_size,
                                           p_manager);
    }
#line 2049
    if (! __cil_tmp12) {
      {
#line 2050
      opj_event_msg(p_manager, 1, "Stream error while reading JP2 Header box\n");
      }
#line 2051
      return (0);
    }
#line 2054
    if (box.length > p_header_size) {
      {
#line 2055
      opj_event_msg(p_manager, 1, "Stream error while reading JP2 Header box: box length is inconsistent.\n");
      }
#line 2056
      return (0);
    }
    {
#line 2059
    l_current_handler = opj_jp2_img_find_handler(box.type);
#line 2060
    l_current_data_size = box.length - l_box_size;
#line 2061
    p_header_data += l_box_size;
    }
#line 2063
    if ((unsigned long )l_current_handler != (unsigned long )((opj_jp2_header_handler_t *)0)) {
      {
#line 2064
      __cil_tmp14 = (*(l_current_handler->handler))(jp2, p_header_data, l_current_data_size,
                                                    p_manager);
      }
#line 2064
      if (! __cil_tmp14) {
#line 2065
        return (0);
      }
    } else {
#line 2069
      jp2->jp2_img_state |= 2147483647U;
    }
#line 2072
    p_header_data += l_current_data_size;
#line 2073
    p_header_size -= box.length;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 2076
  jp2->jp2_state |= 4U;
#line 2078
  return (1);
}
}
#line 2081 "/root/patron/new_22/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_read_boxhdr_char(opj_jp2_box_t *box , OPJ_BYTE *p_data , OPJ_UINT32 *p_number_bytes_read ,
                                  OPJ_UINT32 p_box_max_size , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_value ;
  OPJ_UINT32 l_xl_part_size ;

  {
#line 2096
  if (p_box_max_size < 8U) {
    {
#line 2097
    opj_event_msg(p_manager, 1, "Cannot handle box of less than 8 bytes\n");
    }
#line 2098
    return (0);
  }
  {
#line 2102
  opj_read_bytes_LE(p_data, & l_value, (OPJ_UINT32 )4);
#line 2103
  p_data += 4;
#line 2104
  box->length = (OPJ_UINT32 )((OPJ_INT32 )l_value);
#line 2106
  opj_read_bytes_LE(p_data, & l_value, (OPJ_UINT32 )4);
#line 2107
  p_data += 4;
#line 2108
  box->type = (OPJ_UINT32 )((OPJ_INT32 )l_value);
#line 2110
  *p_number_bytes_read = (OPJ_UINT32 )8;
  }
#line 2114
  if (box->length == 1U) {
#line 2117
    if (p_box_max_size < 16U) {
      {
#line 2118
      opj_event_msg(p_manager, 1, "Cannot handle XL box of less than 16 bytes\n");
      }
#line 2119
      return (0);
    }
    {
#line 2122
    opj_read_bytes_LE(p_data, & l_xl_part_size, (OPJ_UINT32 )4);
#line 2123
    p_data += 4;
#line 2124
    *p_number_bytes_read += 4U;
    }
#line 2126
    if (l_xl_part_size != 0U) {
      {
#line 2127
      opj_event_msg(p_manager, 1, "Cannot handle box sizes higher than 2^32\n");
      }
#line 2128
      return (0);
    }
    {
#line 2131
    opj_read_bytes_LE(p_data, & l_value, (OPJ_UINT32 )4);
#line 2132
    *p_number_bytes_read += 4U;
#line 2133
    box->length = (OPJ_UINT32 )((OPJ_INT32 )l_value);
    }
#line 2135
    if (box->length == 0U) {
      {
#line 2136
      opj_event_msg(p_manager, 1, "Cannot handle box of undefined sizes\n");
      }
#line 2137
      return (0);
    }
  } else
#line 2140
  if (box->length == 0U) {
    {
#line 2141
    opj_event_msg(p_manager, 1, "Cannot handle box of undefined sizes\n");
    }
#line 2142
    return (0);
  }
#line 2145
  return (1);
}
}
#line 2148 "/root/patron/new_22/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_read_header(opj_stream_private_t *p_stream , opj_jp2_t *jp2 , opj_image_t **p_image ,
                             opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp8 ;
  OPJ_BOOL __cil_tmp9 ;
  OPJ_BOOL __cil_tmp10 ;

  {
  {
#line 2160
  opj_jp2_setup_decoding_validation(jp2);
#line 2163
  opj_jp2_setup_header_reading(jp2);
#line 2166
  __cil_tmp8 = opj_jp2_exec(jp2, jp2->m_validation_list, p_stream, p_manager);
  }
#line 2166
  if (! __cil_tmp8) {
#line 2167
    return (0);
  }
  {
#line 2171
  __cil_tmp9 = opj_jp2_exec(jp2, jp2->m_procedure_list, p_stream, p_manager);
  }
#line 2171
  if (! __cil_tmp9) {
#line 2172
    return (0);
  }
  {
#line 2175
  __cil_tmp10 = opj_j2k_read_header(p_stream, jp2->j2k, p_image, p_manager);
  }
#line 2175
  return (__cil_tmp10);
}
}
#line 2181 "/root/patron/new_22/src/lib/openjp2/jp2.c"
void opj_jp2_setup_encoding_validation(opj_jp2_t *jp2 ) 
{ 


  {
  {
#line 2186
  opj_procedure_list_add_procedure(jp2->m_validation_list, (void (*)(void))(& opj_jp2_default_validation));
  }
#line 2188
  return;
}
}
#line 2190 "/root/patron/new_22/src/lib/openjp2/jp2.c"
void opj_jp2_setup_decoding_validation(opj_jp2_t *jp2 ) 
{ 


  {
#line 2195
  return;
}
}
#line 2197 "/root/patron/new_22/src/lib/openjp2/jp2.c"
void opj_jp2_setup_header_writing(opj_jp2_t *jp2 ) 
{ 


  {
  {
#line 2202
  opj_procedure_list_add_procedure(jp2->m_procedure_list, (void (*)(void))(& opj_jp2_write_jp));
#line 2203
  opj_procedure_list_add_procedure(jp2->m_procedure_list, (void (*)(void))(& opj_jp2_write_ftyp));
#line 2204
  opj_procedure_list_add_procedure(jp2->m_procedure_list, (void (*)(void))(& opj_jp2_write_jp2h));
  }
#line 2205
  if (jp2->jpip_on) {
    {
#line 2206
    opj_procedure_list_add_procedure(jp2->m_procedure_list, (void (*)(void))(& opj_jpip_skip_iptr));
    }
  }
  {
#line 2207
  opj_procedure_list_add_procedure(jp2->m_procedure_list, (void (*)(void))(& opj_jp2_skip_jp2c));
  }
#line 2209
  return;
}
}
#line 2213 "/root/patron/new_22/src/lib/openjp2/jp2.c"
void opj_jp2_setup_header_reading(opj_jp2_t *jp2 ) 
{ 


  {
  {
#line 2218
  opj_procedure_list_add_procedure(jp2->m_procedure_list, (void (*)(void))(& opj_jp2_read_header_procedure));
  }
#line 2220
  return;
}
}
#line 2222 "/root/patron/new_22/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_read_tile_header(opj_jp2_t *p_jp2 , OPJ_UINT32 *p_tile_index , OPJ_UINT32 *p_data_size ,
                                  OPJ_INT32 *p_tile_x0 , OPJ_INT32 *p_tile_y0 , OPJ_INT32 *p_tile_x1 ,
                                  OPJ_INT32 *p_tile_y1 , OPJ_UINT32 *p_nb_comps ,
                                  OPJ_BOOL *p_go_on , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp12 ;

  {
  {
#line 2235
  __cil_tmp12 = opj_j2k_read_tile_header(p_jp2->j2k, p_tile_index, p_data_size, p_tile_x0,
                                         p_tile_y0, p_tile_x1, p_tile_y1, p_nb_comps,
                                         p_go_on, p_stream, p_manager);
  }
#line 2235
  return (__cil_tmp12);
}
}
#line 2246 "/root/patron/new_22/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_write_tile(opj_jp2_t *p_jp2 , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                            OPJ_UINT32 p_data_size , opj_stream_private_t *p_stream ,
                            opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp7 ;

  {
  {
#line 2255
  __cil_tmp7 = opj_j2k_write_tile(p_jp2->j2k, p_tile_index, p_data, p_data_size, p_stream,
                                  p_manager);
  }
#line 2255
  return (__cil_tmp7);
}
}
#line 2258 "/root/patron/new_22/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_decode_tile(opj_jp2_t *p_jp2 , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                             OPJ_UINT32 p_data_size , opj_stream_private_t *p_stream ,
                             opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp7 ;

  {
  {
#line 2266
  __cil_tmp7 = opj_j2k_decode_tile(p_jp2->j2k, p_tile_index, p_data, p_data_size,
                                   p_stream, p_manager);
  }
#line 2266
  return (__cil_tmp7);
}
}
#line 2269 "/root/patron/new_22/src/lib/openjp2/jp2.c"
void opj_jp2_destroy(opj_jp2_t *jp2 ) 
{ 


  {
#line 2271
  if (jp2) {
    {
#line 2273
    opj_j2k_destroy(jp2->j2k);
#line 2274
    jp2->j2k = (opj_j2k_t *)0;
    }
#line 2276
    if (jp2->comps) {
      {
#line 2277
      free((void *)jp2->comps);
#line 2278
      jp2->comps = (opj_jp2_comps_t *)0;
      }
    }
#line 2281
    if (jp2->cl) {
      {
#line 2282
      free((void *)jp2->cl);
#line 2283
      jp2->cl = (OPJ_UINT32 *)0;
      }
    }
#line 2286
    if (jp2->color.icc_profile_buf) {
      {
#line 2287
      free((void *)jp2->color.icc_profile_buf);
#line 2288
      jp2->color.icc_profile_buf = (OPJ_BYTE *)0;
      }
    }
#line 2291
    if (jp2->color.jp2_cdef) {
#line 2292
      if ((jp2->color.jp2_cdef)->info) {
        {
#line 2293
        free((void *)(jp2->color.jp2_cdef)->info);
#line 2294
        (jp2->color.jp2_cdef)->info = (opj_jp2_cdef_info_t *)((void *)0);
        }
      }
      {
#line 2297
      free((void *)jp2->color.jp2_cdef);
#line 2298
      jp2->color.jp2_cdef = (opj_jp2_cdef_t *)0;
      }
    }
#line 2301
    if (jp2->color.jp2_pclr) {
#line 2302
      if ((jp2->color.jp2_pclr)->cmap) {
        {
#line 2303
        free((void *)(jp2->color.jp2_pclr)->cmap);
#line 2304
        (jp2->color.jp2_pclr)->cmap = (opj_jp2_cmap_comp_t *)((void *)0);
        }
      }
#line 2306
      if ((jp2->color.jp2_pclr)->channel_sign) {
        {
#line 2307
        free((void *)(jp2->color.jp2_pclr)->channel_sign);
#line 2308
        (jp2->color.jp2_pclr)->channel_sign = (OPJ_BYTE *)((void *)0);
        }
      }
#line 2310
      if ((jp2->color.jp2_pclr)->channel_size) {
        {
#line 2311
        free((void *)(jp2->color.jp2_pclr)->channel_size);
#line 2312
        (jp2->color.jp2_pclr)->channel_size = (OPJ_BYTE *)((void *)0);
        }
      }
#line 2314
      if ((jp2->color.jp2_pclr)->entries) {
        {
#line 2315
        free((void *)(jp2->color.jp2_pclr)->entries);
#line 2316
        (jp2->color.jp2_pclr)->entries = (OPJ_UINT32 *)((void *)0);
        }
      }
      {
#line 2319
      free((void *)jp2->color.jp2_pclr);
#line 2320
      jp2->color.jp2_pclr = (opj_jp2_pclr_t *)0;
      }
    }
#line 2323
    if (jp2->m_validation_list) {
      {
#line 2324
      opj_procedure_list_destroy(jp2->m_validation_list);
#line 2325
      jp2->m_validation_list = (struct opj_procedure_list *)0;
      }
    }
#line 2328
    if (jp2->m_procedure_list) {
      {
#line 2329
      opj_procedure_list_destroy(jp2->m_procedure_list);
#line 2330
      jp2->m_procedure_list = (struct opj_procedure_list *)0;
      }
    }
    {
#line 2333
    free((void *)jp2);
    }
  }
#line 2336
  return;
}
}
#line 2337 "/root/patron/new_22/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_set_decode_area(opj_jp2_t *p_jp2 , opj_image_t *p_image , OPJ_INT32 p_start_x ,
                                 OPJ_INT32 p_start_y , OPJ_INT32 p_end_x , OPJ_INT32 p_end_y ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp8 ;

  {
  {
#line 2344
  __cil_tmp8 = opj_j2k_set_decode_area(p_jp2->j2k, p_image, p_start_x, p_start_y,
                                       p_end_x, p_end_y, p_manager);
  }
#line 2344
  return (__cil_tmp8);
}
}
#line 2347 "/root/patron/new_22/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_get_tile(opj_jp2_t *p_jp2 , opj_stream_private_t *p_stream , opj_image_t *p_image ,
                          opj_event_mgr_t *p_manager , OPJ_UINT32 tile_index ) 
{ 
  OPJ_BOOL __cil_tmp6 ;

  {
#line 2354
  if (! p_image) {
#line 2355
    return (0);
  }
  {
#line 2357
  opj_event_msg(p_manager, 2, "JP2 box which are after the codestream will not be read by this function.\n");
#line 2359
  __cil_tmp6 = opj_j2k_get_tile(p_jp2->j2k, p_stream, p_image, p_manager, tile_index);
  }
#line 2359
  if (! __cil_tmp6) {
    {
#line 2360
    opj_event_msg(p_manager, 1, "Failed to decode the codestream in the JP2 file\n\220");
    }
#line 2361
    return (0);
  }
#line 2365
  if (p_jp2->enumcs == 16U) {
#line 2366
    p_image->color_space = (OPJ_COLOR_SPACE )1;
  } else
#line 2367
  if (p_jp2->enumcs == 17U) {
#line 2368
    p_image->color_space = (OPJ_COLOR_SPACE )2;
  } else
#line 2369
  if (p_jp2->enumcs == 18U) {
#line 2370
    p_image->color_space = (OPJ_COLOR_SPACE )3;
  } else {
#line 2372
    p_image->color_space = (OPJ_COLOR_SPACE )-1;
  }
#line 2375
  if (p_jp2->color.jp2_cdef) {
    {
#line 2376
    opj_jp2_apply_cdef(p_image, & p_jp2->color);
    }
  }
#line 2379
  if (p_jp2->color.jp2_pclr) {
#line 2381
    if (! (p_jp2->color.jp2_pclr)->cmap) {
      {
#line 2382
      opj_jp2_free_pclr(& p_jp2->color);
      }
    } else {
      {
#line 2384
      opj_jp2_apply_pclr(p_image, & p_jp2->color);
      }
    }
  }
#line 2387
  if (p_jp2->color.icc_profile_buf) {
#line 2388
    p_image->icc_profile_buf = p_jp2->color.icc_profile_buf;
#line 2389
    p_image->icc_profile_len = p_jp2->color.icc_profile_len;
#line 2390
    p_jp2->color.icc_profile_buf = (OPJ_BYTE *)((void *)0);
  }
#line 2393
  return (1);
}
}
#line 2400 "/root/patron/new_22/src/lib/openjp2/jp2.c"
opj_jp2_t *opj_jp2_create(OPJ_BOOL p_is_decoder ) 
{ 
  opj_jp2_t *jp2 ;
  void *__cil_tmp3 ;

  {
  {
#line 2402
  __cil_tmp3 = malloc(sizeof(opj_jp2_t ));
#line 2402
  jp2 = (opj_jp2_t *)__cil_tmp3;
  }
#line 2403
  if (jp2) {
    {
#line 2404
    memset((void *)jp2, 0, sizeof(opj_jp2_t ));
    }
#line 2407
    if (! p_is_decoder) {
      {
#line 2408
      jp2->j2k = opj_j2k_create_compress();
      }
    } else {
      {
#line 2411
      jp2->j2k = opj_j2k_create_decompress();
      }
    }
#line 2414
    if ((unsigned long )jp2->j2k == (unsigned long )((opj_j2k_t *)0)) {
      {
#line 2415
      opj_jp2_destroy(jp2);
      }
#line 2416
      return ((opj_jp2_t *)0);
    }
    {
#line 2420
    jp2->color.icc_profile_buf = (OPJ_BYTE *)((void *)0);
#line 2421
    jp2->color.icc_profile_len = (OPJ_UINT32 )0;
#line 2422
    jp2->color.jp2_cdef = (opj_jp2_cdef_t *)((void *)0);
#line 2423
    jp2->color.jp2_pclr = (opj_jp2_pclr_t *)((void *)0);
#line 2424
    jp2->color.jp2_has_colr = (OPJ_BYTE )0;
#line 2427
    jp2->m_validation_list = opj_procedure_list_create();
    }
#line 2428
    if (! jp2->m_validation_list) {
      {
#line 2429
      opj_jp2_destroy(jp2);
      }
#line 2430
      return ((opj_jp2_t *)0);
    }
    {
#line 2434
    jp2->m_procedure_list = opj_procedure_list_create();
    }
#line 2435
    if (! jp2->m_procedure_list) {
      {
#line 2436
      opj_jp2_destroy(jp2);
      }
#line 2437
      return ((opj_jp2_t *)0);
    }
  }
#line 2441
  return (jp2);
}
}
#line 2444 "/root/patron/new_22/src/lib/openjp2/jp2.c"
void jp2_dump(opj_jp2_t *p_jp2 , OPJ_INT32 flag , FILE *out_stream ) 
{ 


  {
  {
#line 2449
  j2k_dump(p_jp2->j2k, flag, out_stream);
  }
#line 2451
  return;
}
}
#line 2454 "/root/patron/new_22/src/lib/openjp2/jp2.c"
opj_codestream_index_t *jp2_get_cstr_index(opj_jp2_t *p_jp2 ) 
{ 
  opj_codestream_index_t *__cil_tmp2 ;

  {
  {
#line 2456
  __cil_tmp2 = j2k_get_cstr_index(p_jp2->j2k);
  }
#line 2456
  return (__cil_tmp2);
}
}
#line 2459 "/root/patron/new_22/src/lib/openjp2/jp2.c"
opj_codestream_info_v2_t *jp2_get_cstr_info(opj_jp2_t *p_jp2 ) 
{ 
  opj_codestream_info_v2_t *__cil_tmp2 ;

  {
  {
#line 2461
  __cil_tmp2 = j2k_get_cstr_info(p_jp2->j2k);
  }
#line 2461
  return (__cil_tmp2);
}
}
#line 2464 "/root/patron/new_22/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_set_decoded_resolution_factor(opj_jp2_t *p_jp2 , OPJ_UINT32 res_factor ,
                                               opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp4 ;

  {
  {
#line 2468
  __cil_tmp4 = opj_j2k_set_decoded_resolution_factor(p_jp2->j2k, res_factor, p_manager);
  }
#line 2468
  return (__cil_tmp4);
}
}
#line 53 "/root/patron/new_22/src/lib/openjp2/j2k.c"
void opj_j2k_setup_header_reading(opj_j2k_t *p_j2k ) ;
#line 58
OPJ_BOOL opj_j2k_read_header_procedure(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                       opj_event_mgr_t *p_manager ) ;
#line 71
OPJ_BOOL opj_j2k_encoding_validation(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                     opj_event_mgr_t *p_manager ) ;
#line 84
OPJ_BOOL opj_j2k_decoding_validation(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                     opj_event_mgr_t *p_manager ) ;
#line 92
void opj_j2k_setup_encoding_validation(opj_j2k_t *p_j2k ) ;
#line 98
void opj_j2k_setup_decoding_validation(opj_j2k_t *p_j2k ) ;
#line 104
void opj_j2k_setup_end_compress(opj_j2k_t *p_j2k ) ;
#line 115
OPJ_BOOL opj_j2k_mct_validation(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                opj_event_mgr_t *p_manager ) ;
#line 122
OPJ_BOOL opj_j2k_build_decoder(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                               opj_event_mgr_t *p_manager ) ;
#line 128
OPJ_BOOL opj_j2k_build_encoder(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                               opj_event_mgr_t *p_manager ) ;
#line 139
static OPJ_BOOL opj_j2k_create_tcd(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                   opj_event_mgr_t *p_manager ) ;
#line 153
OPJ_BOOL opj_j2k_exec(opj_j2k_t *p_j2k , opj_procedure_list_t *p_procedure_list ,
                      opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) ;
#line 165
OPJ_BOOL opj_j2k_update_rates(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                              opj_event_mgr_t *p_manager ) ;
#line 173
static OPJ_BOOL opj_j2k_copy_default_tcp_and_create_tcd(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                                        opj_event_mgr_t *p_manager ) ;
#line 180
static OPJ_BOOL opj_j2k_destroy_header_memory(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                              opj_event_mgr_t *p_manager ) ;
#line 191
struct opj_dec_memory_marker_handler *opj_j2k_get_marker_handler(OPJ_UINT32 p_id ) ;
#line 198
void opj_j2k_tcp_destroy(opj_tcp_t *p_tcp ) ;
#line 205
void opj_j2k_tcp_data_destroy(opj_tcp_t *p_tcp ) ;
#line 212
void opj_j2k_cp_destroy(opj_cp_t *p_cp ) ;
#line 226
OPJ_BOOL opj_j2k_write_SPCod_SPCoc(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no , OPJ_UINT32 p_comp_no ,
                                   OPJ_BYTE *p_data , OPJ_UINT32 *p_header_size ,
                                   struct opj_event_mgr *p_manager ) ;
#line 242
OPJ_UINT32 opj_j2k_get_SPCod_SPCoc_size(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no ,
                                        OPJ_UINT32 p_comp_no ) ;
#line 254
OPJ_BOOL opj_j2k_read_SPCod_SPCoc(opj_j2k_t *p_j2k , OPJ_UINT32 compno , OPJ_BYTE *p_header_data ,
                                  OPJ_UINT32 *p_header_size , opj_event_mgr_t *p_manager ) ;
#line 269
OPJ_UINT32 opj_j2k_get_SQcd_SQcc_size(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no , OPJ_UINT32 p_comp_no ) ;
#line 284
OPJ_BOOL opj_j2k_write_SQcd_SQcc(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no , OPJ_UINT32 p_comp_no ,
                                 OPJ_BYTE *p_data , OPJ_UINT32 *p_header_size , struct opj_event_mgr *p_manager ) ;
#line 294
void opj_j2k_update_tlm(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_part_size ) ;
#line 306
OPJ_BOOL opj_j2k_read_SQcd_SQcc(opj_j2k_t *p_j2k , OPJ_UINT32 p_comp_no , OPJ_BYTE *p_header_data ,
                                OPJ_UINT32 *p_header_size , opj_event_mgr_t *p_manager ) ;
#line 317
void opj_j2k_copy_tile_component_parameters(opj_j2k_t *p_j2k ) ;
#line 324
void opj_j2k_copy_tile_quantization_parameters(opj_j2k_t *p_j2k ) ;
#line 329
OPJ_BOOL opj_j2k_decode_tiles(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                              opj_event_mgr_t *p_manager ) ;
#line 333
OPJ_BOOL opj_j2k_pre_write_tile(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_index , opj_stream_private_t *p_stream ,
                                opj_event_mgr_t *p_manager ) ;
#line 338
OPJ_BOOL opj_j2k_update_image_data(opj_tcd_t *p_tcd , OPJ_BYTE *p_data , opj_image_t *p_output_image ) ;
#line 340
void opj_j2k_get_tile_data(opj_tcd_t *p_tcd , OPJ_BYTE *p_data ) ;
#line 342
OPJ_BOOL opj_j2k_post_write_tile(opj_j2k_t *p_j2k , OPJ_BYTE *p_data , OPJ_UINT32 p_data_size ,
                                 opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) ;
#line 352
void opj_j2k_setup_header_writing(opj_j2k_t *p_j2k ) ;
#line 354
OPJ_BOOL opj_j2k_write_first_tile_part(opj_j2k_t *p_j2k , OPJ_BYTE *p_data , OPJ_UINT32 *p_data_written ,
                                       OPJ_UINT32 p_total_data_size , opj_stream_private_t *p_stream ,
                                       struct opj_event_mgr *p_manager ) ;
#line 361
OPJ_BOOL opj_j2k_write_all_tile_parts(opj_j2k_t *p_j2k , OPJ_BYTE *p_data , OPJ_UINT32 *p_data_written ,
                                      OPJ_UINT32 p_total_data_size , opj_stream_private_t *p_stream ,
                                      struct opj_event_mgr *p_manager ) ;
#line 375
OPJ_BOOL opj_j2k_get_end_header(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                struct opj_event_mgr *p_manager ) ;
#line 379
OPJ_BOOL opj_j2k_allocate_tile_element_cstr_index(opj_j2k_t *p_j2k ) ;
#line 394
OPJ_BOOL opj_j2k_write_soc(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) ;
#line 404
static OPJ_BOOL opj_j2k_read_soc(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                 opj_event_mgr_t *p_manager ) ;
#line 415
OPJ_BOOL opj_j2k_write_siz(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) ;
#line 426
static OPJ_BOOL opj_j2k_read_siz(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 438
OPJ_BOOL opj_j2k_write_com(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) ;
#line 449
static OPJ_BOOL opj_j2k_read_com(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 460
OPJ_BOOL opj_j2k_write_cod(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) ;
#line 471
static OPJ_BOOL opj_j2k_read_cod(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 484
OPJ_BOOL opj_j2k_write_coc(opj_j2k_t *p_j2k , OPJ_UINT32 p_comp_no , opj_stream_private_t *p_stream ,
                           opj_event_mgr_t *p_manager ) ;
#line 497
void opj_j2k_write_coc_in_memory(opj_j2k_t *p_j2k , OPJ_UINT32 p_comp_no , OPJ_BYTE *p_data ,
                                 OPJ_UINT32 *p_data_written , opj_event_mgr_t *p_manager ) ;
#line 508
OPJ_UINT32 opj_j2k_get_max_coc_size(opj_j2k_t *p_j2k ) ;
#line 517
static OPJ_BOOL opj_j2k_read_coc(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 529
OPJ_BOOL opj_j2k_write_qcd(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) ;
#line 540
static OPJ_BOOL opj_j2k_read_qcd(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 552
OPJ_BOOL opj_j2k_write_qcc(opj_j2k_t *p_j2k , OPJ_UINT32 p_comp_no , opj_stream_private_t *p_stream ,
                           opj_event_mgr_t *p_manager ) ;
#line 566
void opj_j2k_write_qcc_in_memory(opj_j2k_t *p_j2k , OPJ_UINT32 p_comp_no , OPJ_BYTE *p_data ,
                                 OPJ_UINT32 *p_data_written , opj_event_mgr_t *p_manager ) ;
#line 575
OPJ_UINT32 opj_j2k_get_max_qcc_size(opj_j2k_t *p_j2k ) ;
#line 584
static OPJ_BOOL opj_j2k_read_qcc(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 595
OPJ_BOOL opj_j2k_write_poc(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) ;
#line 606
void opj_j2k_write_poc_in_memory(opj_j2k_t *p_j2k , OPJ_BYTE *p_data , OPJ_UINT32 *p_data_written ,
                                 opj_event_mgr_t *p_manager ) ;
#line 613
OPJ_UINT32 opj_j2k_get_max_poc_size(opj_j2k_t *p_j2k ) ;
#line 623
static OPJ_BOOL opj_j2k_read_poc(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 631
OPJ_UINT32 opj_j2k_get_max_toc_size(opj_j2k_t *p_j2k ) ;
#line 638
OPJ_UINT32 opj_j2k_get_specific_header_sizes(opj_j2k_t *p_j2k ) ;
#line 648
static OPJ_BOOL opj_j2k_read_crg(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 660
static OPJ_BOOL opj_j2k_read_tlm(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 672
OPJ_BOOL opj_j2k_write_updated_tlm(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                   struct opj_event_mgr *p_manager ) ;
#line 684
static OPJ_BOOL opj_j2k_read_plm(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 696
static OPJ_BOOL opj_j2k_read_plt(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 718
OPJ_BOOL j2k_read_ppm_v3(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                         struct opj_event_mgr *p_manager ) ;
#line 732
static OPJ_BOOL opj_j2k_read_ppt(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 743
OPJ_BOOL opj_j2k_write_tlm(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) ;
#line 756
OPJ_BOOL opj_j2k_write_sot(opj_j2k_t *p_j2k , OPJ_BYTE *p_data , OPJ_UINT32 *p_data_written ,
                           opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) ;
#line 770
OPJ_BOOL opj_j2k_read_sot(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                          opj_event_mgr_t *p_manager ) ;
#line 785
OPJ_BOOL opj_j2k_write_sod(opj_j2k_t *p_j2k , opj_tcd_t *p_tile_coder , OPJ_BYTE *p_data ,
                           OPJ_UINT32 *p_data_written , OPJ_UINT32 p_total_data_size ,
                           opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) ;
#line 800
OPJ_BOOL opj_j2k_read_sod(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) ;
#line 804 "/root/patron/new_22/src/lib/openjp2/j2k.c"
void opj_j2k_update_tlm(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_part_size ) 
{ 


  {
  {
#line 806
  opj_write_bytes_LE(p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current,
                     p_j2k->m_current_tile_number, (OPJ_UINT32 )1);
#line 807
  (p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current) ++;
#line 809
  opj_write_bytes_LE(p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current,
                     p_tile_part_size, (OPJ_UINT32 )4);
#line 810
  p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current += 4;
  }
#line 812
  return;
}
}
#line 823
OPJ_BOOL opj_j2k_write_rgn(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no , OPJ_UINT32 p_comp_no ,
                           OPJ_UINT32 nb_comps , opj_stream_private_t *p_stream ,
                           opj_event_mgr_t *p_manager ) ;
#line 838
static OPJ_BOOL opj_j2k_read_rgn(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 850
OPJ_BOOL opj_j2k_write_eoc(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) ;
#line 861
OPJ_BOOL opj_j2k_read_eoc(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) ;
#line 872
OPJ_BOOL opj_j2k_write_mct_data_group(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                      struct opj_event_mgr *p_manager ) ;
#line 883
OPJ_BOOL opj_j2k_init_info(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                           struct opj_event_mgr *p_manager ) ;
#line 894
static OPJ_BOOL opj_j2k_add_mhmarker(opj_codestream_index_t *cstr_index , OPJ_UINT32 type ,
                                     OPJ_OFF_T pos , OPJ_UINT32 len ) ;
#line 903
static OPJ_BOOL opj_j2k_add_tlmarker(OPJ_UINT32 tileno , opj_codestream_index_t *cstr_index ,
                                     OPJ_UINT32 type , OPJ_OFF_T pos , OPJ_UINT32 len ) ;
#line 915
OPJ_BOOL opj_j2k_read_unk(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , OPJ_UINT32 *output_marker ,
                          opj_event_mgr_t *p_manager ) ;
#line 928
OPJ_BOOL opj_j2k_write_mct_record(opj_j2k_t *p_j2k , opj_mct_data_t *p_mct_record ,
                                  struct opj_stream_private *p_stream , struct opj_event_mgr *p_manager ) ;
#line 941
static OPJ_BOOL opj_j2k_read_mct(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 954
OPJ_BOOL opj_j2k_write_mcc_record(opj_j2k_t *p_j2k , struct opj_simple_mcc_decorrelation_data *p_mcc_record ,
                                  struct opj_stream_private *p_stream , struct opj_event_mgr *p_manager ) ;
#line 967
OPJ_BOOL opj_j2k_read_mcc(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                          opj_event_mgr_t *p_manager ) ;
#line 979
OPJ_BOOL opj_j2k_write_mco(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                           struct opj_event_mgr *p_manager ) ;
#line 991
static OPJ_BOOL opj_j2k_read_mco(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 996
OPJ_BOOL opj_j2k_add_mct(opj_tcp_t *p_tcp , opj_image_t *p_image , OPJ_UINT32 p_index ) ;
#line 998
void opj_j2k_read_int16_to_float(void const   *p_src_data , void *p_dest_data , OPJ_UINT32 p_nb_elem ) ;
#line 999
void opj_j2k_read_int32_to_float(void const   *p_src_data , void *p_dest_data , OPJ_UINT32 p_nb_elem ) ;
#line 1000
void opj_j2k_read_float32_to_float(void const   *p_src_data , void *p_dest_data ,
                                   OPJ_UINT32 p_nb_elem ) ;
#line 1001
void opj_j2k_read_float64_to_float(void const   *p_src_data , void *p_dest_data ,
                                   OPJ_UINT32 p_nb_elem ) ;
#line 1003
void opj_j2k_read_int16_to_int32(void const   *p_src_data , void *p_dest_data , OPJ_UINT32 p_nb_elem ) ;
#line 1004
void opj_j2k_read_int32_to_int32(void const   *p_src_data , void *p_dest_data , OPJ_UINT32 p_nb_elem ) ;
#line 1005
void opj_j2k_read_float32_to_int32(void const   *p_src_data , void *p_dest_data ,
                                   OPJ_UINT32 p_nb_elem ) ;
#line 1006
void opj_j2k_read_float64_to_int32(void const   *p_src_data , void *p_dest_data ,
                                   OPJ_UINT32 p_nb_elem ) ;
#line 1008
void opj_j2k_write_float_to_int16(void const   *p_src_data , void *p_dest_data , OPJ_UINT32 p_nb_elem ) ;
#line 1009
void opj_j2k_write_float_to_int32(void const   *p_src_data , void *p_dest_data , OPJ_UINT32 p_nb_elem ) ;
#line 1010
void opj_j2k_write_float_to_float(void const   *p_src_data , void *p_dest_data , OPJ_UINT32 p_nb_elem ) ;
#line 1011
void opj_j2k_write_float_to_float64(void const   *p_src_data , void *p_dest_data ,
                                    OPJ_UINT32 p_nb_elem ) ;
#line 1020
OPJ_BOOL opj_j2k_end_encoding(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                              struct opj_event_mgr *p_manager ) ;
#line 1031
OPJ_BOOL opj_j2k_write_cbd(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                           struct opj_event_mgr *p_manager ) ;
#line 1042
static OPJ_BOOL opj_j2k_read_cbd(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 1054
OPJ_BOOL opj_j2k_write_all_coc(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                               struct opj_event_mgr *p_manager ) ;
#line 1065
OPJ_BOOL opj_j2k_write_all_qcc(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                               struct opj_event_mgr *p_manager ) ;
#line 1076
OPJ_BOOL opj_j2k_write_regions(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                               struct opj_event_mgr *p_manager ) ;
#line 1087
OPJ_BOOL opj_j2k_write_epc(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                           struct opj_event_mgr *p_manager ) ;
#line 1104
OPJ_BOOL opj_j2k_check_poc_val(opj_poc_t *p_pocs , OPJ_UINT32 p_nb_pocs , OPJ_UINT32 p_nb_resolutions ,
                               OPJ_UINT32 p_num_comps , OPJ_UINT32 p_num_layers ,
                               opj_event_mgr_t *p_manager ) ;
#line 1120
OPJ_UINT32 opj_j2k_get_num_tp(opj_cp_t *cp , OPJ_UINT32 pino , OPJ_UINT32 tileno ) ;
#line 1134
OPJ_BOOL opj_j2k_calculate_tp(opj_j2k_t *p_j2k , opj_cp_t *cp , OPJ_UINT32 *p_nb_tiles ,
                              opj_image_t *image , opj_event_mgr_t *p_manager ) ;
#line 1140
void opj_j2k_dump_MH_info(opj_j2k_t *p_j2k , FILE *out_stream ) ;
#line 1142
void opj_j2k_dump_MH_index(opj_j2k_t *p_j2k , FILE *out_stream ) ;
#line 1144
opj_codestream_index_t *opj_j2k_create_cstr_index(void) ;
#line 1146
OPJ_FLOAT32 opj_j2k_get_tp_stride(opj_tcp_t *p_tcp ) ;
#line 1148
OPJ_FLOAT32 opj_j2k_get_default_stride(opj_tcp_t *p_tcp ) ;
#line 1150
int opj_j2k_initialise_4K_poc(opj_poc_t *POC , int numres ) ;
#line 1152
void opj_j2k_set_cinema_parameters(opj_cparameters_t *parameters , opj_image_t *image ,
                                   opj_event_mgr_t *p_manager ) ;
#line 1154
OPJ_BOOL opj_j2k_is_cinema_compliant(opj_image_t *image , OPJ_CINEMA_MODE cinema_mode ,
                                     opj_event_mgr_t *p_manager ) ;
#line 1166 "/root/patron/new_22/src/lib/openjp2/j2k.c"
j2k_prog_order_t j2k_prog_order_list[6]  = {      {(OPJ_PROG_ORDER )4, {(char )"CPRL", (char)0, (char)0, (char)0, (char)0}}, 
        {(OPJ_PROG_ORDER )0, {(char )"LRCP", (char)0, (char)0, (char)0, (char)0}}, 
        {(OPJ_PROG_ORDER )3, {(char )"PCRL", (char)0, (char)0, (char)0, (char)0}}, 
        {(OPJ_PROG_ORDER )1, {(char )"RLCP", (char)0, (char)0, (char)0, (char)0}}, 
        {(OPJ_PROG_ORDER )2, {(char )"RPCL", (char)0, (char)0, (char)0, (char)0}}, 
        {(OPJ_PROG_ORDER )-1, {(char )"\250", (char)0, (char)0, (char)0, (char)0}}};
#line 1178 "/root/patron/new_22/src/lib/openjp2/j2k.c"
static OPJ_UINT32 MCT_ELEMENT_SIZE[4]  = {      (OPJ_UINT32 )2,      (OPJ_UINT32 )4,      (OPJ_UINT32 )4,      (OPJ_UINT32 )8};
#line 1188 "/root/patron/new_22/src/lib/openjp2/j2k.c"
opj_j2k_mct_function j2k_mct_read_functions_to_float[4]  = {      & opj_j2k_read_int16_to_float,      & opj_j2k_read_int32_to_float,      & opj_j2k_read_float32_to_float,      & opj_j2k_read_float64_to_float};
#line 1196 "/root/patron/new_22/src/lib/openjp2/j2k.c"
opj_j2k_mct_function j2k_mct_read_functions_to_int32[4]  = {      & opj_j2k_read_int16_to_int32,      & opj_j2k_read_int32_to_int32,      & opj_j2k_read_float32_to_int32,      & opj_j2k_read_float64_to_int32};
#line 1204 "/root/patron/new_22/src/lib/openjp2/j2k.c"
opj_j2k_mct_function j2k_mct_write_functions_from_float[4]  = {      & opj_j2k_write_float_to_int16,      & opj_j2k_write_float_to_int32,      & opj_j2k_write_float_to_float,      & opj_j2k_write_float_to_float64};
#line 1226 "/root/patron/new_22/src/lib/openjp2/j2k.c"
opj_dec_memory_marker_handler_t j2k_memory_marker_handler_tab[21]  = 
#line 1226
  {      {(OPJ_UINT32 )65424, (OPJ_UINT32 )12, & opj_j2k_read_sot}, 
        {(OPJ_UINT32 )65362, (OPJ_UINT32 )20, & opj_j2k_read_cod}, 
        {(OPJ_UINT32 )65363, (OPJ_UINT32 )20, & opj_j2k_read_coc}, 
        {(OPJ_UINT32 )65374, (OPJ_UINT32 )20, & opj_j2k_read_rgn}, 
        {(OPJ_UINT32 )65372, (OPJ_UINT32 )20, & opj_j2k_read_qcd}, 
        {(OPJ_UINT32 )65373, (OPJ_UINT32 )20, & opj_j2k_read_qcc}, 
        {(OPJ_UINT32 )65375, (OPJ_UINT32 )20, & opj_j2k_read_poc}, 
        {(OPJ_UINT32 )65361, (OPJ_UINT32 )2, & opj_j2k_read_siz}, 
        {(OPJ_UINT32 )65365, (OPJ_UINT32 )4, & opj_j2k_read_tlm}, 
        {(OPJ_UINT32 )65367, (OPJ_UINT32 )4, & opj_j2k_read_plm}, 
        {(OPJ_UINT32 )65368, (OPJ_UINT32 )16, & opj_j2k_read_plt}, 
        {(OPJ_UINT32 )65376, (OPJ_UINT32 )4, & j2k_read_ppm_v3}, 
        {(OPJ_UINT32 )65377, (OPJ_UINT32 )16, & opj_j2k_read_ppt}, 
        {(OPJ_UINT32 )65425, (OPJ_UINT32 )0, (OPJ_BOOL (*)(opj_j2k_t * , OPJ_BYTE * ,
                                                        OPJ_UINT32  , opj_event_mgr_t * ))0}, 
        {(OPJ_UINT32 )65379,
      (OPJ_UINT32 )4, & opj_j2k_read_crg}, 
        {(OPJ_UINT32 )65380, (OPJ_UINT32 )20, & opj_j2k_read_com}, 
        {(OPJ_UINT32 )65396, (OPJ_UINT32 )20, & opj_j2k_read_mct}, 
        {(OPJ_UINT32 )65400, (OPJ_UINT32 )4, & opj_j2k_read_cbd}, 
        {(OPJ_UINT32 )65397, (OPJ_UINT32 )20, & opj_j2k_read_mcc}, 
        {(OPJ_UINT32 )65399, (OPJ_UINT32 )20, & opj_j2k_read_mco}, 
        {(OPJ_UINT32 )0, (OPJ_UINT32 )20, (OPJ_BOOL (*)(opj_j2k_t * , OPJ_BYTE * , OPJ_UINT32  ,
                                                     opj_event_mgr_t * ))0}};
#line 1263 "/root/patron/new_22/src/lib/openjp2/j2k.c"
void opj_j2k_read_int16_to_float(void const   *p_src_data , void *p_dest_data , OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_src_data ;
  OPJ_FLOAT32 *l_dest_data ;
  OPJ_UINT32 i ;
  OPJ_UINT32 l_temp ;
  OPJ_FLOAT32 *__cil_tmp8 ;

  {
#line 1265
  l_src_data = (OPJ_BYTE *)p_src_data;
#line 1266
  l_dest_data = (OPJ_FLOAT32 *)p_dest_data;
#line 1270
  i = (OPJ_UINT32 )0;
  {
#line 1270
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1270
    if (! (i < p_nb_elem)) {
#line 1270
      goto while_break;
    }
    {
#line 1271
    opj_read_bytes_LE(l_src_data, & l_temp, (OPJ_UINT32 )2);
#line 1273
    l_src_data += sizeof(OPJ_INT16 );
#line 1275
    __cil_tmp8 = l_dest_data;
#line 1275
    l_dest_data ++;
#line 1275
    *__cil_tmp8 = (OPJ_FLOAT32 )l_temp;
#line 1270
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1274
  return;
}
}
#line 1279 "/root/patron/new_22/src/lib/openjp2/j2k.c"
void opj_j2k_read_int32_to_float(void const   *p_src_data , void *p_dest_data , OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_src_data ;
  OPJ_FLOAT32 *l_dest_data ;
  OPJ_UINT32 i ;
  OPJ_UINT32 l_temp ;
  OPJ_FLOAT32 *__cil_tmp8 ;

  {
#line 1281
  l_src_data = (OPJ_BYTE *)p_src_data;
#line 1282
  l_dest_data = (OPJ_FLOAT32 *)p_dest_data;
#line 1286
  i = (OPJ_UINT32 )0;
  {
#line 1286
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1286
    if (! (i < p_nb_elem)) {
#line 1286
      goto while_break;
    }
    {
#line 1287
    opj_read_bytes_LE(l_src_data, & l_temp, (OPJ_UINT32 )4);
#line 1289
    l_src_data += sizeof(OPJ_INT32 );
#line 1291
    __cil_tmp8 = l_dest_data;
#line 1291
    l_dest_data ++;
#line 1291
    *__cil_tmp8 = (OPJ_FLOAT32 )l_temp;
#line 1286
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1290
  return;
}
}
#line 1295 "/root/patron/new_22/src/lib/openjp2/j2k.c"
void opj_j2k_read_float32_to_float(void const   *p_src_data , void *p_dest_data ,
                                   OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_src_data ;
  OPJ_FLOAT32 *l_dest_data ;
  OPJ_UINT32 i ;
  OPJ_FLOAT32 l_temp ;
  OPJ_FLOAT32 *__cil_tmp8 ;

  {
#line 1297
  l_src_data = (OPJ_BYTE *)p_src_data;
#line 1298
  l_dest_data = (OPJ_FLOAT32 *)p_dest_data;
#line 1302
  i = (OPJ_UINT32 )0;
  {
#line 1302
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1302
    if (! (i < p_nb_elem)) {
#line 1302
      goto while_break;
    }
    {
#line 1303
    opj_read_float_LE(l_src_data, & l_temp);
#line 1305
    l_src_data += sizeof(OPJ_FLOAT32 );
#line 1307
    __cil_tmp8 = l_dest_data;
#line 1307
    l_dest_data ++;
#line 1307
    *__cil_tmp8 = l_temp;
#line 1302
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1306
  return;
}
}
#line 1311 "/root/patron/new_22/src/lib/openjp2/j2k.c"
void opj_j2k_read_float64_to_float(void const   *p_src_data , void *p_dest_data ,
                                   OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_src_data ;
  OPJ_FLOAT32 *l_dest_data ;
  OPJ_UINT32 i ;
  OPJ_FLOAT64 l_temp ;
  OPJ_FLOAT32 *__cil_tmp8 ;

  {
#line 1313
  l_src_data = (OPJ_BYTE *)p_src_data;
#line 1314
  l_dest_data = (OPJ_FLOAT32 *)p_dest_data;
#line 1318
  i = (OPJ_UINT32 )0;
  {
#line 1318
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1318
    if (! (i < p_nb_elem)) {
#line 1318
      goto while_break;
    }
    {
#line 1319
    opj_read_double_LE(l_src_data, & l_temp);
#line 1321
    l_src_data += sizeof(OPJ_FLOAT64 );
#line 1323
    __cil_tmp8 = l_dest_data;
#line 1323
    l_dest_data ++;
#line 1323
    *__cil_tmp8 = (OPJ_FLOAT32 )l_temp;
#line 1318
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1322
  return;
}
}
#line 1327 "/root/patron/new_22/src/lib/openjp2/j2k.c"
void opj_j2k_read_int16_to_int32(void const   *p_src_data , void *p_dest_data , OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_src_data ;
  OPJ_INT32 *l_dest_data ;
  OPJ_UINT32 i ;
  OPJ_UINT32 l_temp ;
  OPJ_INT32 *__cil_tmp8 ;

  {
#line 1329
  l_src_data = (OPJ_BYTE *)p_src_data;
#line 1330
  l_dest_data = (OPJ_INT32 *)p_dest_data;
#line 1334
  i = (OPJ_UINT32 )0;
  {
#line 1334
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1334
    if (! (i < p_nb_elem)) {
#line 1334
      goto while_break;
    }
    {
#line 1335
    opj_read_bytes_LE(l_src_data, & l_temp, (OPJ_UINT32 )2);
#line 1337
    l_src_data += sizeof(OPJ_INT16 );
#line 1339
    __cil_tmp8 = l_dest_data;
#line 1339
    l_dest_data ++;
#line 1339
    *__cil_tmp8 = (OPJ_INT32 )l_temp;
#line 1334
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1338
  return;
}
}
#line 1343 "/root/patron/new_22/src/lib/openjp2/j2k.c"
void opj_j2k_read_int32_to_int32(void const   *p_src_data , void *p_dest_data , OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_src_data ;
  OPJ_INT32 *l_dest_data ;
  OPJ_UINT32 i ;
  OPJ_UINT32 l_temp ;
  OPJ_INT32 *__cil_tmp8 ;

  {
#line 1345
  l_src_data = (OPJ_BYTE *)p_src_data;
#line 1346
  l_dest_data = (OPJ_INT32 *)p_dest_data;
#line 1350
  i = (OPJ_UINT32 )0;
  {
#line 1350
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1350
    if (! (i < p_nb_elem)) {
#line 1350
      goto while_break;
    }
    {
#line 1351
    opj_read_bytes_LE(l_src_data, & l_temp, (OPJ_UINT32 )4);
#line 1353
    l_src_data += sizeof(OPJ_INT32 );
#line 1355
    __cil_tmp8 = l_dest_data;
#line 1355
    l_dest_data ++;
#line 1355
    *__cil_tmp8 = (OPJ_INT32 )l_temp;
#line 1350
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1354
  return;
}
}
#line 1359 "/root/patron/new_22/src/lib/openjp2/j2k.c"
void opj_j2k_read_float32_to_int32(void const   *p_src_data , void *p_dest_data ,
                                   OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_src_data ;
  OPJ_INT32 *l_dest_data ;
  OPJ_UINT32 i ;
  OPJ_FLOAT32 l_temp ;
  OPJ_INT32 *__cil_tmp8 ;

  {
#line 1361
  l_src_data = (OPJ_BYTE *)p_src_data;
#line 1362
  l_dest_data = (OPJ_INT32 *)p_dest_data;
#line 1366
  i = (OPJ_UINT32 )0;
  {
#line 1366
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1366
    if (! (i < p_nb_elem)) {
#line 1366
      goto while_break;
    }
    {
#line 1367
    opj_read_float_LE(l_src_data, & l_temp);
#line 1369
    l_src_data += sizeof(OPJ_FLOAT32 );
#line 1371
    __cil_tmp8 = l_dest_data;
#line 1371
    l_dest_data ++;
#line 1371
    *__cil_tmp8 = (OPJ_INT32 )l_temp;
#line 1366
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1370
  return;
}
}
#line 1375 "/root/patron/new_22/src/lib/openjp2/j2k.c"
void opj_j2k_read_float64_to_int32(void const   *p_src_data , void *p_dest_data ,
                                   OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_src_data ;
  OPJ_INT32 *l_dest_data ;
  OPJ_UINT32 i ;
  OPJ_FLOAT64 l_temp ;
  OPJ_INT32 *__cil_tmp8 ;

  {
#line 1377
  l_src_data = (OPJ_BYTE *)p_src_data;
#line 1378
  l_dest_data = (OPJ_INT32 *)p_dest_data;
#line 1382
  i = (OPJ_UINT32 )0;
  {
#line 1382
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1382
    if (! (i < p_nb_elem)) {
#line 1382
      goto while_break;
    }
    {
#line 1383
    opj_read_double_LE(l_src_data, & l_temp);
#line 1385
    l_src_data += sizeof(OPJ_FLOAT64 );
#line 1387
    __cil_tmp8 = l_dest_data;
#line 1387
    l_dest_data ++;
#line 1387
    *__cil_tmp8 = (OPJ_INT32 )l_temp;
#line 1382
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1386
  return;
}
}
#line 1391 "/root/patron/new_22/src/lib/openjp2/j2k.c"
void opj_j2k_write_float_to_int16(void const   *p_src_data , void *p_dest_data , OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_dest_data ;
  OPJ_FLOAT32 *l_src_data ;
  OPJ_UINT32 i ;
  OPJ_UINT32 l_temp ;
  OPJ_FLOAT32 *__cil_tmp8 ;

  {
#line 1393
  l_dest_data = (OPJ_BYTE *)p_dest_data;
#line 1394
  l_src_data = (OPJ_FLOAT32 *)p_src_data;
#line 1398
  i = (OPJ_UINT32 )0;
  {
#line 1398
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1398
    if (! (i < p_nb_elem)) {
#line 1398
      goto while_break;
    }
    {
#line 1399
    __cil_tmp8 = l_src_data;
#line 1399
    l_src_data ++;
#line 1399
    l_temp = (OPJ_UINT32 )*__cil_tmp8;
#line 1401
    opj_write_bytes_LE(l_dest_data, l_temp, (OPJ_UINT32 )sizeof(OPJ_INT16 ));
#line 1403
    l_dest_data += sizeof(OPJ_INT16 );
#line 1398
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1402
  return;
}
}
#line 1407 "/root/patron/new_22/src/lib/openjp2/j2k.c"
void opj_j2k_write_float_to_int32(void const   *p_src_data , void *p_dest_data , OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_dest_data ;
  OPJ_FLOAT32 *l_src_data ;
  OPJ_UINT32 i ;
  OPJ_UINT32 l_temp ;
  OPJ_FLOAT32 *__cil_tmp8 ;

  {
#line 1409
  l_dest_data = (OPJ_BYTE *)p_dest_data;
#line 1410
  l_src_data = (OPJ_FLOAT32 *)p_src_data;
#line 1414
  i = (OPJ_UINT32 )0;
  {
#line 1414
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1414
    if (! (i < p_nb_elem)) {
#line 1414
      goto while_break;
    }
    {
#line 1415
    __cil_tmp8 = l_src_data;
#line 1415
    l_src_data ++;
#line 1415
    l_temp = (OPJ_UINT32 )*__cil_tmp8;
#line 1417
    opj_write_bytes_LE(l_dest_data, l_temp, (OPJ_UINT32 )sizeof(OPJ_INT32 ));
#line 1419
    l_dest_data += sizeof(OPJ_INT32 );
#line 1414
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1418
  return;
}
}
#line 1423 "/root/patron/new_22/src/lib/openjp2/j2k.c"
void opj_j2k_write_float_to_float(void const   *p_src_data , void *p_dest_data , OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_dest_data ;
  OPJ_FLOAT32 *l_src_data ;
  OPJ_UINT32 i ;
  OPJ_FLOAT32 l_temp ;
  OPJ_FLOAT32 *__cil_tmp8 ;

  {
#line 1425
  l_dest_data = (OPJ_BYTE *)p_dest_data;
#line 1426
  l_src_data = (OPJ_FLOAT32 *)p_src_data;
#line 1430
  i = (OPJ_UINT32 )0;
  {
#line 1430
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1430
    if (! (i < p_nb_elem)) {
#line 1430
      goto while_break;
    }
    {
#line 1431
    __cil_tmp8 = l_src_data;
#line 1431
    l_src_data ++;
#line 1431
    l_temp = *__cil_tmp8;
#line 1433
    opj_write_float_LE(l_dest_data, l_temp);
#line 1435
    l_dest_data += sizeof(OPJ_FLOAT32 );
#line 1430
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1434
  return;
}
}
#line 1439 "/root/patron/new_22/src/lib/openjp2/j2k.c"
void opj_j2k_write_float_to_float64(void const   *p_src_data , void *p_dest_data ,
                                    OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_dest_data ;
  OPJ_FLOAT32 *l_src_data ;
  OPJ_UINT32 i ;
  OPJ_FLOAT64 l_temp ;
  OPJ_FLOAT32 *__cil_tmp8 ;

  {
#line 1441
  l_dest_data = (OPJ_BYTE *)p_dest_data;
#line 1442
  l_src_data = (OPJ_FLOAT32 *)p_src_data;
#line 1446
  i = (OPJ_UINT32 )0;
  {
#line 1446
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1446
    if (! (i < p_nb_elem)) {
#line 1446
      goto while_break;
    }
    {
#line 1447
    __cil_tmp8 = l_src_data;
#line 1447
    l_src_data ++;
#line 1447
    l_temp = (OPJ_FLOAT64 )*__cil_tmp8;
#line 1449
    opj_write_double_LE(l_dest_data, l_temp);
#line 1451
    l_dest_data += sizeof(OPJ_FLOAT64 );
#line 1446
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1450
  return;
}
}
#line 1455 "/root/patron/new_22/src/lib/openjp2/j2k.c"
char *opj_j2k_convert_progression_order(OPJ_PROG_ORDER prg_order ) 
{ 
  j2k_prog_order_t *po ;

  {
#line 1457
  po = j2k_prog_order_list;
  {
#line 1457
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1457
    if (! ((int )po->enum_prog != -1)) {
#line 1457
      goto while_break;
    }
#line 1458
    if ((int )po->enum_prog == (int )prg_order) {
#line 1459
      return (po->str_prog);
    }
#line 1457
    po ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1462
  return (po->str_prog);
}
}
#line 1465 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_check_poc_val(opj_poc_t *p_pocs , OPJ_UINT32 p_nb_pocs , OPJ_UINT32 p_nb_resolutions ,
                               OPJ_UINT32 p_num_comps , OPJ_UINT32 p_num_layers ,
                               opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 *packet_array ;
  OPJ_UINT32 index___8 ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 compno ;
  OPJ_UINT32 layno ;
  OPJ_UINT32 i ;
  OPJ_UINT32 step_c ;
  OPJ_UINT32 step_r ;
  OPJ_UINT32 step_l ;
  OPJ_BOOL loss ;
  OPJ_UINT32 layno0 ;
  void *__cil_tmp18 ;
  OPJ_UINT32 res_index ;
  OPJ_UINT32 comp_index ;
  OPJ_UINT32 l_last_layno1 ;
  OPJ_UINT32 tmp ;
  OPJ_UINT32 res_index___0 ;
  OPJ_UINT32 comp_index___0 ;

  {
  {
#line 1475
  step_c = (OPJ_UINT32 )1;
#line 1476
  step_r = p_num_comps * step_c;
#line 1477
  step_l = p_nb_resolutions * step_r;
#line 1478
  loss = 0;
#line 1479
  layno0 = (OPJ_UINT32 )0;
#line 1481
  __cil_tmp18 = calloc((unsigned long )(step_l * p_num_layers), sizeof(OPJ_UINT32 ));
#line 1481
  packet_array = (OPJ_UINT32 *)__cil_tmp18;
  }
#line 1482
  if ((unsigned long )packet_array == (unsigned long )((OPJ_UINT32 *)0)) {
    {
#line 1483
    opj_event_msg(p_manager, 1, "Not enough memory for checking the poc values.\n");
    }
#line 1484
    return (0);
  }
  {
#line 1486
  memset((void *)packet_array, 0, (unsigned long )(step_l * p_num_layers) * sizeof(OPJ_UINT32 ));
  }
#line 1488
  if (p_nb_pocs == 0U) {
#line 1489
    return (1);
  }
#line 1492
  index___8 = step_r * p_pocs->resno0;
#line 1494
  resno = p_pocs->resno0;
  {
#line 1494
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1494
    if (! (resno < p_pocs->resno1)) {
#line 1494
      goto while_break;
    }
#line 1496
    res_index = index___8 + p_pocs->compno0 * step_c;
#line 1499
    compno = p_pocs->compno0;
    {
#line 1499
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1499
      if (! (compno < p_pocs->compno1)) {
#line 1499
        goto while_break___0;
      }
#line 1500
      comp_index = res_index + layno0 * step_l;
#line 1503
      layno = layno0;
      {
#line 1503
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 1503
        if (! (layno < p_pocs->layno1)) {
#line 1503
          goto while_break___1;
        }
#line 1505
        *(packet_array + comp_index) = (OPJ_UINT32 )1;
#line 1506
        comp_index += step_l;
#line 1503
        layno ++;
      }
      while_break___11: /* CIL Label */ ;
      }
      while_break___1: 
#line 1509
      res_index += step_c;
#line 1499
      compno ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___0: 
#line 1512
    index___8 += step_r;
#line 1494
    resno ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break: 
#line 1514
  p_pocs ++;
#line 1517
  i = (OPJ_UINT32 )1;
  {
#line 1517
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 1517
    if (! (i < p_nb_pocs)) {
#line 1517
      goto while_break___2;
    }
#line 1518
    l_last_layno1 = (p_pocs - 1)->layno1;
#line 1520
    if (p_pocs->layno1 > l_last_layno1) {
#line 1520
      tmp = l_last_layno1;
    } else {
#line 1520
      tmp = 0U;
    }
#line 1520
    layno0 = tmp;
#line 1521
    index___8 = step_r * p_pocs->resno0;
#line 1524
    resno = p_pocs->resno0;
    {
#line 1524
    while (1) {
      while_continue___3: /* CIL Label */ ;

#line 1524
      if (! (resno < p_pocs->resno1)) {
#line 1524
        goto while_break___3;
      }
#line 1525
      res_index___0 = index___8 + p_pocs->compno0 * step_c;
#line 1528
      compno = p_pocs->compno0;
      {
#line 1528
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 1528
        if (! (compno < p_pocs->compno1)) {
#line 1528
          goto while_break___4;
        }
#line 1529
        comp_index___0 = res_index___0 + layno0 * step_l;
#line 1532
        layno = layno0;
        {
#line 1532
        while (1) {
          while_continue___5: /* CIL Label */ ;

#line 1532
          if (! (layno < p_pocs->layno1)) {
#line 1532
            goto while_break___5;
          }
#line 1534
          *(packet_array + comp_index___0) = (OPJ_UINT32 )1;
#line 1535
          comp_index___0 += step_l;
#line 1532
          layno ++;
        }
        while_break___15: /* CIL Label */ ;
        }
        while_break___5: 
#line 1538
        res_index___0 += step_c;
#line 1528
        compno ++;
      }
      while_break___14: /* CIL Label */ ;
      }
      while_break___4: 
#line 1541
      index___8 += step_r;
#line 1524
      resno ++;
    }
    while_break___13: /* CIL Label */ ;
    }
    while_break___3: 
#line 1544
    p_pocs ++;
#line 1517
    i ++;
  }
  while_break___12: /* CIL Label */ ;
  }
  while_break___2: 
#line 1547
  index___8 = (OPJ_UINT32 )0;
#line 1548
  layno = (OPJ_UINT32 )0;
  {
#line 1548
  while (1) {
    while_continue___6: /* CIL Label */ ;

#line 1548
    if (! (layno < p_num_layers)) {
#line 1548
      goto while_break___6;
    }
#line 1549
    resno = (OPJ_UINT32 )0;
    {
#line 1549
    while (1) {
      while_continue___7: /* CIL Label */ ;

#line 1549
      if (! (resno < p_nb_resolutions)) {
#line 1549
        goto while_break___7;
      }
#line 1550
      compno = (OPJ_UINT32 )0;
      {
#line 1550
      while (1) {
        while_continue___8: /* CIL Label */ ;

#line 1550
        if (! (compno < p_num_comps)) {
#line 1550
          goto while_break___8;
        }
#line 1551
        loss |= *(packet_array + index___8) != 1U;
#line 1553
        index___8 += step_c;
#line 1550
        compno ++;
      }
      while_break___18: /* CIL Label */ ;
      }
      while_break___8: 
#line 1549
      resno ++;
    }
    while_break___17: /* CIL Label */ ;
    }
    while_break___7: 
#line 1548
    layno ++;
  }
  while_break___16: /* CIL Label */ ;
  }
  while_break___6: ;
#line 1558
  if (loss) {
    {
#line 1559
    opj_event_msg(p_manager, 1, "Missing packets possible loss of data\n");
    }
  }
  {
#line 1562
  free((void *)packet_array);
  }
#line 1564
  return (! loss);
}
}
#line 1569 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_UINT32 opj_j2k_get_num_tp(opj_cp_t *cp , OPJ_UINT32 pino , OPJ_UINT32 tileno ) 
{ 
  OPJ_CHAR *prog ;
  OPJ_UINT32 i ;
  OPJ_UINT32 tpnum ;
  opj_tcp_t *tcp ;
  opj_poc_t *l_current_poc ;

  {
  {
#line 1571
  prog = (OPJ_CHAR *)0;
#line 1573
  tpnum = (OPJ_UINT32 )1;
#line 1574
  tcp = (opj_tcp_t *)0;
#line 1575
  l_current_poc = (opj_poc_t *)0;
#line 1582
  tcp = cp->tcps + tileno;
#line 1585
  l_current_poc = & tcp->pocs[pino];
#line 1589
  prog = opj_j2k_convert_progression_order(tcp->prg);
  }
#line 1592
  if ((int )cp->m_specific_param.m_enc.m_tp_on == 1) {
#line 1593
    i = (OPJ_UINT32 )0;
    {
#line 1593
    while (1) {
      while_continue: /* CIL Label */ ;

#line 1593
      if (! (i < 4U)) {
#line 1593
        goto while_break;
      }
#line 1597
      if ((int )*(prog + i) == 67) {
#line 1597
        goto case_67;
      }
#line 1601
      if ((int )*(prog + i) == 82) {
#line 1601
        goto case_82;
      }
#line 1605
      if ((int )*(prog + i) == 80) {
#line 1605
        goto case_80;
      }
#line 1609
      if ((int )*(prog + i) == 76) {
#line 1609
        goto case_76;
      }
#line 1594
      goto switch_break;
      case_67: 
#line 1598
      tpnum *= l_current_poc->compE;
#line 1599
      goto switch_break;
      case_82: 
#line 1602
      tpnum *= l_current_poc->resE;
#line 1603
      goto switch_break;
      case_80: 
#line 1606
      tpnum *= l_current_poc->prcE;
#line 1607
      goto switch_break;
      case_76: 
#line 1610
      tpnum *= l_current_poc->layE;
#line 1611
      goto switch_break;
      switch_break: ;
#line 1614
      if ((int )cp->m_specific_param.m_enc.m_tp_flag == (int )*(prog + i)) {
#line 1615
        cp->m_specific_param.m_enc.m_tp_pos = (OPJ_INT32 )i;
#line 1616
        goto while_break;
      }
#line 1593
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  } else {
#line 1621
    tpnum = (OPJ_UINT32 )1;
  }
#line 1624
  return (tpnum);
}
}
#line 1627 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_calculate_tp(opj_j2k_t *p_j2k , opj_cp_t *cp , OPJ_UINT32 *p_nb_tiles ,
                              opj_image_t *image , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 pino ;
  OPJ_UINT32 tileno ;
  OPJ_UINT32 l_nb_tiles ;
  opj_tcp_t *tcp ;
  OPJ_UINT32 cur_totnum_tp ;
  OPJ_UINT32 tp_num ;
  OPJ_UINT32 __cil_tmp17 ;

  {
#line 1645
  l_nb_tiles = cp->tw * cp->th;
#line 1646
  *p_nb_tiles = (OPJ_UINT32 )0;
#line 1647
  tcp = cp->tcps;
#line 1684
  tileno = (OPJ_UINT32 )0;
  {
#line 1684
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1684
    if (! (tileno < l_nb_tiles)) {
#line 1684
      goto while_break;
    }
    {
#line 1685
    cur_totnum_tp = (OPJ_UINT32 )0;
#line 1687
    opj_pi_update_encoding_parameters(image, cp, tileno);
#line 1689
    pino = (OPJ_UINT32 )0;
    }
    {
#line 1689
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1689
      if (! (pino <= tcp->numpocs)) {
#line 1689
        goto while_break___0;
      }
      {
#line 1690
      __cil_tmp17 = opj_j2k_get_num_tp(cp, pino, tileno);
#line 1690
      tp_num = __cil_tmp17;
#line 1692
      *p_nb_tiles += tp_num;
#line 1694
      cur_totnum_tp += tp_num;
#line 1689
      pino ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 1696
    tcp->m_nb_tile_parts = cur_totnum_tp;
#line 1698
    tcp ++;
#line 1684
    tileno ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 1702
  return (1);
}
}
#line 1705 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_soc(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BYTE *l_start_stream ;
  OPJ_SIZE_T __cil_tmp8 ;

  {
  {
#line 1710
  l_start_stream = (OPJ_BYTE *)0;
#line 1717
  l_start_stream = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 1720
  opj_write_bytes_LE(l_start_stream, (OPJ_UINT32 )65359, (OPJ_UINT32 )2);
#line 1722
  __cil_tmp8 = opj_stream_write_data(p_stream, l_start_stream, (OPJ_SIZE_T )2, p_manager);
  }
#line 1722
  if (__cil_tmp8 != 2UL) {
#line 1723
    return (0);
  }
#line 1736
  return (1);
}
}
#line 1745 "/root/patron/new_22/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_soc(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BYTE l_data[2] ;
  OPJ_UINT32 l_marker ;
  OPJ_SIZE_T __cil_tmp9 ;
  OPJ_OFF_T __cil_tmp10 ;
  OPJ_BOOL __cil_tmp11 ;

  {
  {
#line 1758
  __cil_tmp9 = opj_stream_read_data(p_stream, l_data, (OPJ_SIZE_T )2, p_manager);
  }
#line 1758
  if (__cil_tmp9 != 2UL) {
#line 1759
    return (0);
  }
  {
#line 1762
  opj_read_bytes_LE(l_data, & l_marker, (OPJ_UINT32 )2);
  }
#line 1763
  if (l_marker != 65359U) {
#line 1764
    return (0);
  }
  {
#line 1768
  p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )2;
#line 1771
  __cil_tmp10 = opj_stream_tell(p_stream);
#line 1771
  (p_j2k->cstr_index)->main_head_start = __cil_tmp10 - 2L;
#line 1773
  opj_event_msg(p_manager, 4, "Start to read j2k main header (%d).\n", (p_j2k->cstr_index)->main_head_start);
#line 1776
  __cil_tmp11 = opj_j2k_add_mhmarker(p_j2k->cstr_index, (OPJ_UINT32 )65359, (p_j2k->cstr_index)->main_head_start,
                                     (OPJ_UINT32 )2);
  }
#line 1776
  if (0 == __cil_tmp11) {
    {
#line 1777
    opj_event_msg(p_manager, 1, "Not enough memory to add mh marker\n\211\202U");
    }
#line 1778
    return (0);
  }
#line 1780
  return (1);
}
}
#line 1783 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_siz(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_size_len ;
  OPJ_BYTE *l_current_ptr ;
  opj_image_t *l_image ;
  opj_cp_t *cp ;
  opj_image_comp_t *l_img_comp ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp14 ;
  OPJ_SIZE_T __cil_tmp15 ;

  {
#line 1790
  l_image = (opj_image_t *)0;
#line 1791
  cp = (opj_cp_t *)0;
#line 1792
  l_img_comp = (opj_image_comp_t *)0;
#line 1799
  l_image = p_j2k->m_private_image;
#line 1800
  cp = & p_j2k->m_cp;
#line 1801
  l_size_len = 40U + 3U * l_image->numcomps;
#line 1802
  l_img_comp = l_image->comps;
#line 1804
  if (l_size_len > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 1806
    __cil_tmp14 = realloc((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                          (unsigned long )l_size_len);
#line 1806
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp14;
    }
#line 1807
    if (! new_header_tile_data) {
      {
#line 1808
      free((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 1809
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 1810
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 1811
      opj_event_msg(p_manager, 1, "Not enough memory for the SIZ marker\n");
      }
#line 1812
      return (0);
    }
#line 1814
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 1815
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_size_len;
  }
  {
#line 1818
  l_current_ptr = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 1821
  opj_write_bytes_LE(l_current_ptr, (OPJ_UINT32 )65361, (OPJ_UINT32 )2);
#line 1822
  l_current_ptr += 2;
#line 1824
  opj_write_bytes_LE(l_current_ptr, l_size_len - 2U, (OPJ_UINT32 )2);
#line 1825
  l_current_ptr += 2;
#line 1827
  opj_write_bytes_LE(l_current_ptr, (OPJ_UINT32 )cp->rsiz, (OPJ_UINT32 )2);
#line 1828
  l_current_ptr += 2;
#line 1830
  opj_write_bytes_LE(l_current_ptr, l_image->x1, (OPJ_UINT32 )4);
#line 1831
  l_current_ptr += 4;
#line 1833
  opj_write_bytes_LE(l_current_ptr, l_image->y1, (OPJ_UINT32 )4);
#line 1834
  l_current_ptr += 4;
#line 1836
  opj_write_bytes_LE(l_current_ptr, l_image->x0, (OPJ_UINT32 )4);
#line 1837
  l_current_ptr += 4;
#line 1839
  opj_write_bytes_LE(l_current_ptr, l_image->y0, (OPJ_UINT32 )4);
#line 1840
  l_current_ptr += 4;
#line 1842
  opj_write_bytes_LE(l_current_ptr, cp->tdx, (OPJ_UINT32 )4);
#line 1843
  l_current_ptr += 4;
#line 1845
  opj_write_bytes_LE(l_current_ptr, cp->tdy, (OPJ_UINT32 )4);
#line 1846
  l_current_ptr += 4;
#line 1848
  opj_write_bytes_LE(l_current_ptr, cp->tx0, (OPJ_UINT32 )4);
#line 1849
  l_current_ptr += 4;
#line 1851
  opj_write_bytes_LE(l_current_ptr, cp->ty0, (OPJ_UINT32 )4);
#line 1852
  l_current_ptr += 4;
#line 1854
  opj_write_bytes_LE(l_current_ptr, l_image->numcomps, (OPJ_UINT32 )2);
#line 1855
  l_current_ptr += 2;
#line 1857
  i = (OPJ_UINT32 )0;
  }
  {
#line 1857
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1857
    if (! (i < l_image->numcomps)) {
#line 1857
      goto while_break;
    }
    {
#line 1859
    opj_write_bytes_LE(l_current_ptr, (l_img_comp->prec - 1U) + (l_img_comp->sgnd << 7),
                       (OPJ_UINT32 )1);
#line 1860
    l_current_ptr ++;
#line 1862
    opj_write_bytes_LE(l_current_ptr, l_img_comp->dx, (OPJ_UINT32 )1);
#line 1863
    l_current_ptr ++;
#line 1865
    opj_write_bytes_LE(l_current_ptr, l_img_comp->dy, (OPJ_UINT32 )1);
#line 1866
    l_current_ptr ++;
#line 1868
    l_img_comp ++;
#line 1857
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1871
  __cil_tmp15 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_size_len, p_manager);
  }
#line 1871
  if (__cil_tmp15 != (unsigned long )l_size_len) {
#line 1872
    return (0);
  }
#line 1875
  return (1);
}
}
#line 1885 "/root/patron/new_22/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_siz(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_nb_comp ;
  OPJ_UINT32 l_nb_comp_remain ;
  OPJ_UINT32 l_remaining_size ;
  OPJ_UINT32 l_nb_tiles ;
  OPJ_UINT32 l_tmp ;
  opj_image_t *l_image ;
  opj_cp_t *l_cp ;
  opj_image_comp_t *l_img_comp ;
  opj_tcp_t *l_current_tile_param ;
  void *__cil_tmp18 ;
  OPJ_UINT32 tmp___2 ;
  OPJ_INT32 __cil_tmp20 ;
  OPJ_INT32 __cil_tmp21 ;
  OPJ_INT32 __cil_tmp22 ;
  OPJ_INT32 __cil_tmp23 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;

  {
#line 1897
  l_image = (opj_image_t *)0;
#line 1898
  l_cp = (opj_cp_t *)0;
#line 1899
  l_img_comp = (opj_image_comp_t *)0;
#line 1900
  l_current_tile_param = (opj_tcp_t *)0;
#line 1907
  l_image = p_j2k->m_private_image;
#line 1908
  l_cp = & p_j2k->m_cp;
#line 1911
  if (p_header_size < 36U) {
    {
#line 1912
    opj_event_msg(p_manager, 1, "Error with SIZ marker size\n");
    }
#line 1913
    return (0);
  }
#line 1916
  l_remaining_size = p_header_size - 36U;
#line 1917
  l_nb_comp = l_remaining_size / 3U;
#line 1918
  l_nb_comp_remain = l_remaining_size % 3U;
#line 1919
  if (l_nb_comp_remain != 0U) {
    {
#line 1920
    opj_event_msg(p_manager, 1, "Error with SIZ marker size\n\211\202U");
    }
#line 1921
    return (0);
  }
  {
#line 1924
  opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )2);
#line 1925
  p_header_data += 2;
#line 1926
  l_cp->rsiz = (OPJ_RSIZ_CAPABILITIES )l_tmp;
#line 1927
  opj_read_bytes_LE(p_header_data, & l_image->x1, (OPJ_UINT32 )4);
#line 1928
  p_header_data += 4;
#line 1929
  opj_read_bytes_LE(p_header_data, & l_image->y1, (OPJ_UINT32 )4);
#line 1930
  p_header_data += 4;
#line 1931
  opj_read_bytes_LE(p_header_data, & l_image->x0, (OPJ_UINT32 )4);
#line 1932
  p_header_data += 4;
#line 1933
  opj_read_bytes_LE(p_header_data, & l_image->y0, (OPJ_UINT32 )4);
#line 1934
  p_header_data += 4;
#line 1935
  opj_read_bytes_LE(p_header_data, & l_cp->tdx, (OPJ_UINT32 )4);
#line 1936
  p_header_data += 4;
#line 1937
  opj_read_bytes_LE(p_header_data, & l_cp->tdy, (OPJ_UINT32 )4);
#line 1938
  p_header_data += 4;
#line 1939
  opj_read_bytes_LE(p_header_data, & l_cp->tx0, (OPJ_UINT32 )4);
#line 1940
  p_header_data += 4;
#line 1941
  opj_read_bytes_LE(p_header_data, & l_cp->ty0, (OPJ_UINT32 )4);
#line 1942
  p_header_data += 4;
#line 1943
  opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )2);
#line 1944
  p_header_data += 2;
  }
#line 1945
  if (l_tmp < 16385U) {
#line 1946
    l_image->numcomps = (OPJ_UINT32 )((OPJ_UINT16 )l_tmp);
  } else {
    {
#line 1948
    opj_event_msg(p_manager, 1, "Error with SIZ marker: number of component is illegal -> %d\n",
                  l_tmp);
    }
#line 1949
    return (0);
  }
#line 1952
  if (l_image->numcomps != l_nb_comp) {
    {
#line 1953
    opj_event_msg(p_manager, 1, "Error with SIZ marker: number of component is not compatible with the remaining number of parameters ( %d vs %d)\n",
                  l_image->numcomps, l_nb_comp);
    }
#line 1954
    return (0);
  }
  {
#line 2000
  __cil_tmp18 = calloc((unsigned long )l_image->numcomps, sizeof(opj_image_comp_t ));
#line 2000
  l_image->comps = (opj_image_comp_t *)__cil_tmp18;
  }
#line 2001
  if ((unsigned long )l_image->comps == (unsigned long )((opj_image_comp_t *)0)) {
    {
#line 2002
    l_image->numcomps = (OPJ_UINT32 )0;
#line 2003
    opj_event_msg(p_manager, 1, "Not enough memory to take in charge SIZ marker\n");
    }
#line 2004
    return (0);
  }
  {
#line 2007
  memset((void *)l_image->comps, 0, (unsigned long )l_image->numcomps * sizeof(opj_image_comp_t ));
#line 2008
  l_img_comp = l_image->comps;
#line 2011
  i = (OPJ_UINT32 )0;
  }
  {
#line 2011
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2011
    if (! (i < l_image->numcomps)) {
#line 2011
      goto while_break;
    }
    {
#line 2013
    opj_read_bytes_LE(p_header_data, & tmp___2, (OPJ_UINT32 )1);
#line 2014
    p_header_data ++;
#line 2015
    l_img_comp->prec = (tmp___2 & 127U) + 1U;
#line 2016
    l_img_comp->sgnd = tmp___2 >> 7;
#line 2017
    opj_read_bytes_LE(p_header_data, & tmp___2, (OPJ_UINT32 )1);
#line 2018
    p_header_data ++;
#line 2019
    l_img_comp->dx = (OPJ_UINT32 )((OPJ_INT32 )tmp___2);
#line 2020
    opj_read_bytes_LE(p_header_data, & tmp___2, (OPJ_UINT32 )1);
#line 2021
    p_header_data ++;
#line 2022
    l_img_comp->dy = (OPJ_UINT32 )((OPJ_INT32 )tmp___2);
    }
#line 2023
    if (l_img_comp->dx < 1U) {
      {
#line 2025
      opj_event_msg(p_manager, 1, "Invalid values for comp = %d : dx=%u dy=%u\n (should be between 1 and 255 according the JPEG2000 norm)",
                    i, l_img_comp->dx, l_img_comp->dy);
      }
#line 2028
      return (0);
    } else
#line 2023
    if (l_img_comp->dx > 255U) {
      {
#line 2025
      opj_event_msg(p_manager, 1, "Invalid values for comp = %d : dx=%u dy=%u\n (should be between 1 and 255 according the JPEG2000 norm)",
                    i, l_img_comp->dx, l_img_comp->dy);
      }
#line 2028
      return (0);
    } else
#line 2023
    if (l_img_comp->dy < 1U) {
      {
#line 2025
      opj_event_msg(p_manager, 1, "Invalid values for comp = %d : dx=%u dy=%u\n (should be between 1 and 255 according the JPEG2000 norm)",
                    i, l_img_comp->dx, l_img_comp->dy);
      }
#line 2028
      return (0);
    } else
#line 2023
    if (l_img_comp->dy > 255U) {
      {
#line 2025
      opj_event_msg(p_manager, 1, "Invalid values for comp = %d : dx=%u dy=%u\n (should be between 1 and 255 according the JPEG2000 norm)",
                    i, l_img_comp->dx, l_img_comp->dy);
      }
#line 2028
      return (0);
    }
#line 2058
    l_img_comp->resno_decoded = (OPJ_UINT32 )0;
#line 2059
    l_img_comp->factor = l_cp->m_specific_param.m_dec.m_reduce;
#line 2060
    l_img_comp ++;
#line 2011
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
  {
#line 2064
  __cil_tmp20 = opj_int_ceildiv((OPJ_INT32 )(l_image->x1 - l_cp->tx0), (OPJ_INT32 )l_cp->tdx);
#line 2064
  l_cp->tw = (OPJ_UINT32 )__cil_tmp20;
#line 2065
  __cil_tmp21 = opj_int_ceildiv((OPJ_INT32 )(l_image->y1 - l_cp->ty0), (OPJ_INT32 )l_cp->tdy);
#line 2065
  l_cp->th = (OPJ_UINT32 )__cil_tmp21;
  }
#line 2068
  if (l_cp->tw == 0U) {
    {
#line 2069
    opj_event_msg(p_manager, 1, "Invalid number of tiles : %u x %u (maximum fixed by jpeg2000 norm is 65535 tiles)\n\304\211\202U",
                  l_cp->tw, l_cp->th);
    }
#line 2072
    return (0);
  } else
#line 2068
  if (l_cp->th == 0U) {
    {
#line 2069
    opj_event_msg(p_manager, 1, "Invalid number of tiles : %u x %u (maximum fixed by jpeg2000 norm is 65535 tiles)\n\304\211\202U",
                  l_cp->tw, l_cp->th);
    }
#line 2072
    return (0);
  } else
#line 2068
  if (l_cp->tw > 65535U / l_cp->th) {
    {
#line 2069
    opj_event_msg(p_manager, 1, "Invalid number of tiles : %u x %u (maximum fixed by jpeg2000 norm is 65535 tiles)\n\304\211\202U",
                  l_cp->tw, l_cp->th);
    }
#line 2072
    return (0);
  }
#line 2074
  l_nb_tiles = l_cp->tw * l_cp->th;
#line 2077
  if (p_j2k->m_specific_param.m_decoder.m_discard_tiles) {
    {
#line 2078
    p_j2k->m_specific_param.m_decoder.m_start_tile_x = (p_j2k->m_specific_param.m_decoder.m_start_tile_x - l_cp->tx0) / l_cp->tdx;
#line 2079
    p_j2k->m_specific_param.m_decoder.m_start_tile_y = (p_j2k->m_specific_param.m_decoder.m_start_tile_y - l_cp->ty0) / l_cp->tdy;
#line 2080
    __cil_tmp22 = opj_int_ceildiv((OPJ_INT32 )(p_j2k->m_specific_param.m_decoder.m_end_tile_x - l_cp->tx0),
                                  (OPJ_INT32 )l_cp->tdx);
#line 2080
    p_j2k->m_specific_param.m_decoder.m_end_tile_x = (OPJ_UINT32 )__cil_tmp22;
#line 2081
    __cil_tmp23 = opj_int_ceildiv((OPJ_INT32 )(p_j2k->m_specific_param.m_decoder.m_end_tile_y - l_cp->ty0),
                                  (OPJ_INT32 )l_cp->tdy);
#line 2081
    p_j2k->m_specific_param.m_decoder.m_end_tile_y = (OPJ_UINT32 )__cil_tmp23;
    }
  } else {
#line 2084
    p_j2k->m_specific_param.m_decoder.m_start_tile_x = (OPJ_UINT32 )0;
#line 2085
    p_j2k->m_specific_param.m_decoder.m_start_tile_y = (OPJ_UINT32 )0;
#line 2086
    p_j2k->m_specific_param.m_decoder.m_end_tile_x = l_cp->tw;
#line 2087
    p_j2k->m_specific_param.m_decoder.m_end_tile_y = l_cp->th;
  }
  {
#line 2131
  __cil_tmp24 = calloc((unsigned long )l_nb_tiles, sizeof(opj_tcp_t ));
#line 2131
  l_cp->tcps = (opj_tcp_t *)__cil_tmp24;
  }
#line 2132
  if ((unsigned long )l_cp->tcps == (unsigned long )((opj_tcp_t *)0)) {
    {
#line 2133
    opj_event_msg(p_manager, 1, "Not enough memory to take in charge SIZ marker\n");
    }
#line 2134
    return (0);
  }
  {
#line 2136
  memset((void *)l_cp->tcps, 0, (unsigned long )l_nb_tiles * sizeof(opj_tcp_t ));
#line 2151
  __cil_tmp25 = calloc((unsigned long )l_image->numcomps, sizeof(opj_tccp_t ));
#line 2151
  (p_j2k->m_specific_param.m_decoder.m_default_tcp)->tccps = (opj_tccp_t *)__cil_tmp25;
  }
#line 2153
  if ((unsigned long )(p_j2k->m_specific_param.m_decoder.m_default_tcp)->tccps == (unsigned long )((opj_tccp_t *)0)) {
    {
#line 2154
    opj_event_msg(p_manager, 1, "Not enough memory to take in charge SIZ marker\n");
    }
#line 2155
    return (0);
  }
  {
#line 2157
  memset((void *)(p_j2k->m_specific_param.m_decoder.m_default_tcp)->tccps, 0, (unsigned long )l_image->numcomps * sizeof(opj_tccp_t ));
#line 2159
  __cil_tmp26 = malloc(10UL * sizeof(opj_mct_data_t ));
#line 2159
  (p_j2k->m_specific_param.m_decoder.m_default_tcp)->m_mct_records = (opj_mct_data_t *)__cil_tmp26;
  }
#line 2162
  if (! (p_j2k->m_specific_param.m_decoder.m_default_tcp)->m_mct_records) {
    {
#line 2163
    opj_event_msg(p_manager, 1, "Not enough memory to take in charge SIZ marker\n");
    }
#line 2164
    return (0);
  }
  {
#line 2166
  memset((void *)(p_j2k->m_specific_param.m_decoder.m_default_tcp)->m_mct_records,
         0, 10UL * sizeof(opj_mct_data_t ));
#line 2167
  (p_j2k->m_specific_param.m_decoder.m_default_tcp)->m_nb_max_mct_records = (OPJ_UINT32 )10;
#line 2169
  __cil_tmp27 = malloc(10UL * sizeof(opj_simple_mcc_decorrelation_data_t ));
#line 2169
  (p_j2k->m_specific_param.m_decoder.m_default_tcp)->m_mcc_records = (opj_simple_mcc_decorrelation_data_t *)__cil_tmp27;
  }
#line 2173
  if (! (p_j2k->m_specific_param.m_decoder.m_default_tcp)->m_mcc_records) {
    {
#line 2174
    opj_event_msg(p_manager, 1, "Not enough memory to take in charge SIZ marker\n");
    }
#line 2175
    return (0);
  }
  {
#line 2177
  memset((void *)(p_j2k->m_specific_param.m_decoder.m_default_tcp)->m_mcc_records,
         0, 10UL * sizeof(opj_simple_mcc_decorrelation_data_t ));
#line 2178
  (p_j2k->m_specific_param.m_decoder.m_default_tcp)->m_nb_max_mcc_records = (OPJ_UINT32 )10;
#line 2181
  i = (OPJ_UINT32 )0;
  }
  {
#line 2181
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 2181
    if (! (i < l_image->numcomps)) {
#line 2181
      goto while_break___0;
    }
#line 2182
    if (! (l_image->comps + i)->sgnd) {
#line 2183
      ((p_j2k->m_specific_param.m_decoder.m_default_tcp)->tccps + i)->m_dc_level_shift = 1 << ((l_image->comps + i)->prec - 1U);
    }
#line 2181
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: 
#line 2187
  l_current_tile_param = l_cp->tcps;
#line 2188
  i = (OPJ_UINT32 )0;
  {
#line 2188
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 2188
    if (! (i < l_nb_tiles)) {
#line 2188
      goto while_break___1;
    }
    {
#line 2189
    __cil_tmp28 = malloc((unsigned long )l_image->numcomps * sizeof(opj_tccp_t ));
#line 2189
    l_current_tile_param->tccps = (opj_tccp_t *)__cil_tmp28;
    }
#line 2190
    if ((unsigned long )l_current_tile_param->tccps == (unsigned long )((opj_tccp_t *)0)) {
      {
#line 2191
      opj_event_msg(p_manager, 1, "Not enough memory to take in charge SIZ marker\n");
      }
#line 2192
      return (0);
    }
    {
#line 2194
    memset((void *)l_current_tile_param->tccps, 0, (unsigned long )l_image->numcomps * sizeof(opj_tccp_t ));
#line 2196
    l_current_tile_param ++;
#line 2188
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: 
  {
#line 2199
  p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )4;
#line 2200
  opj_image_comp_header_update(l_image, l_cp);
  }
#line 2202
  return (1);
}
}
#line 2205 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_com(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_comment_size ;
  OPJ_UINT32 l_total_com_size ;
  OPJ_CHAR *l_comment ;
  OPJ_BYTE *l_current_ptr ;
  unsigned long __cil_tmp11 ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp13 ;
  OPJ_SIZE_T __cil_tmp14 ;

  {
  {
#line 2213
  l_current_ptr = (OPJ_BYTE *)0;
#line 2220
  l_comment = p_j2k->m_cp.comment;
#line 2221
  __cil_tmp11 = strlen((char const   *)l_comment);
#line 2221
  l_comment_size = (OPJ_UINT32 )__cil_tmp11;
#line 2222
  l_total_com_size = l_comment_size + 6U;
  }
#line 2224
  if (l_total_com_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 2225
    __cil_tmp13 = realloc((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                          (unsigned long )l_total_com_size);
#line 2225
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp13;
    }
#line 2226
    if (! new_header_tile_data) {
      {
#line 2227
      free((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 2228
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 2229
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 2230
      opj_event_msg(p_manager, 1, "Not enough memory to write the COM marker\n\305\211\202U");
      }
#line 2231
      return (0);
    }
#line 2233
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 2234
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_total_com_size;
  }
  {
#line 2237
  l_current_ptr = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 2239
  opj_write_bytes_LE(l_current_ptr, (OPJ_UINT32 )65380, (OPJ_UINT32 )2);
#line 2240
  l_current_ptr += 2;
#line 2242
  opj_write_bytes_LE(l_current_ptr, l_total_com_size - 2U, (OPJ_UINT32 )2);
#line 2243
  l_current_ptr += 2;
#line 2245
  opj_write_bytes_LE(l_current_ptr, (OPJ_UINT32 )1, (OPJ_UINT32 )2);
#line 2246
  l_current_ptr += 2;
#line 2248
  memcpy((void *)l_current_ptr, (void const   *)l_comment, (unsigned long )l_comment_size);
#line 2250
  __cil_tmp14 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_total_com_size, p_manager);
  }
#line 2250
  if (__cil_tmp14 != (unsigned long )l_total_com_size) {
#line 2251
    return (0);
  }
#line 2254
  return (1);
}
}
#line 2264 "/root/patron/new_22/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_com(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 


  {
#line 2276
  return (1);
}
}
#line 2279 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_cod(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) 
{ 
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 l_code_size ;
  OPJ_UINT32 l_remaining_size ;
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 __cil_tmp12 ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp14 ;
  OPJ_BOOL __cil_tmp15 ;
  OPJ_SIZE_T __cil_tmp16 ;

  {
  {
#line 2283
  l_cp = (opj_cp_t *)0;
#line 2284
  l_tcp = (opj_tcp_t *)0;
#line 2286
  l_current_data = (OPJ_BYTE *)0;
#line 2293
  l_cp = & p_j2k->m_cp;
#line 2294
  l_tcp = l_cp->tcps + p_j2k->m_current_tile_number;
#line 2295
  __cil_tmp12 = opj_j2k_get_SPCod_SPCoc_size(p_j2k, p_j2k->m_current_tile_number,
                                             (OPJ_UINT32 )0);
#line 2295
  l_code_size = 9U + __cil_tmp12;
#line 2296
  l_remaining_size = l_code_size;
  }
#line 2298
  if (l_code_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 2299
    __cil_tmp14 = realloc((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                          (unsigned long )l_code_size);
#line 2299
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp14;
    }
#line 2300
    if (! new_header_tile_data) {
      {
#line 2301
      free((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 2302
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 2303
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 2304
      opj_event_msg(p_manager, 1, "Not enough memory to write COD marker\n");
      }
#line 2305
      return (0);
    }
#line 2307
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 2308
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_code_size;
  }
  {
#line 2311
  l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 2313
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65362, (OPJ_UINT32 )2);
#line 2314
  l_current_data += 2;
#line 2316
  opj_write_bytes_LE(l_current_data, l_code_size - 2U, (OPJ_UINT32 )2);
#line 2317
  l_current_data += 2;
#line 2319
  opj_write_bytes_LE(l_current_data, l_tcp->csty, (OPJ_UINT32 )1);
#line 2320
  l_current_data ++;
#line 2322
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )l_tcp->prg, (OPJ_UINT32 )1);
#line 2323
  l_current_data ++;
#line 2325
  opj_write_bytes_LE(l_current_data, l_tcp->numlayers, (OPJ_UINT32 )2);
#line 2326
  l_current_data += 2;
#line 2328
  opj_write_bytes_LE(l_current_data, l_tcp->mct, (OPJ_UINT32 )1);
#line 2329
  l_current_data ++;
#line 2331
  l_remaining_size -= 9U;
#line 2333
  __cil_tmp15 = opj_j2k_write_SPCod_SPCoc(p_j2k, p_j2k->m_current_tile_number, (OPJ_UINT32 )0,
                                          l_current_data, & l_remaining_size, p_manager);
  }
#line 2333
  if (! __cil_tmp15) {
    {
#line 2334
    opj_event_msg(p_manager, 1, "Error writing COD marker\n");
    }
#line 2335
    return (0);
  }
#line 2338
  if (l_remaining_size != 0U) {
    {
#line 2339
    opj_event_msg(p_manager, 1, "Error writing COD marker\n\231\304\211\202U");
    }
#line 2340
    return (0);
  }
  {
#line 2343
  __cil_tmp16 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_code_size, p_manager);
  }
#line 2343
  if (__cil_tmp16 != (unsigned long )l_code_size) {
#line 2344
    return (0);
  }
#line 2347
  return (1);
}
}
#line 2357 "/root/patron/new_22/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_cod(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_tmp ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_image_t *l_image ;
  opj_tcp_t *tmp___2 ;
  OPJ_BOOL __cil_tmp14 ;

  {
#line 2366
  l_cp = (opj_cp_t *)0;
#line 2367
  l_tcp = (opj_tcp_t *)0;
#line 2368
  l_image = (opj_image_t *)0;
#line 2375
  l_image = p_j2k->m_private_image;
#line 2376
  l_cp = & p_j2k->m_cp;
#line 2379
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 2379
    tmp___2 = l_cp->tcps + p_j2k->m_current_tile_number;
  } else {
#line 2379
    tmp___2 = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
#line 2379
  l_tcp = tmp___2;
#line 2384
  if (p_header_size < 5U) {
    {
#line 2385
    opj_event_msg(p_manager, 1, "Error reading COD marker\n\222\305\211\202U");
    }
#line 2386
    return (0);
  }
  {
#line 2389
  opj_read_bytes_LE(p_header_data, & l_tcp->csty, (OPJ_UINT32 )1);
#line 2390
  p_header_data ++;
#line 2391
  opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )1);
#line 2392
  p_header_data ++;
#line 2393
  l_tcp->prg = (OPJ_PROG_ORDER )l_tmp;
#line 2394
  opj_read_bytes_LE(p_header_data, & l_tcp->numlayers, (OPJ_UINT32 )2);
#line 2395
  p_header_data += 2;
  }
#line 2398
  if (l_cp->m_specific_param.m_dec.m_layer) {
#line 2399
    l_tcp->num_layers_to_decode = l_cp->m_specific_param.m_dec.m_layer;
  } else {
#line 2402
    l_tcp->num_layers_to_decode = l_tcp->numlayers;
  }
  {
#line 2405
  opj_read_bytes_LE(p_header_data, & l_tcp->mct, (OPJ_UINT32 )1);
#line 2406
  p_header_data ++;
#line 2408
  p_header_size -= 5U;
#line 2409
  i = (OPJ_UINT32 )0;
  }
  {
#line 2409
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2409
    if (! (i < l_image->numcomps)) {
#line 2409
      goto while_break;
    }
#line 2410
    (l_tcp->tccps + i)->csty = l_tcp->csty & 1U;
#line 2409
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 2413
  __cil_tmp14 = opj_j2k_read_SPCod_SPCoc(p_j2k, (OPJ_UINT32 )0, p_header_data, & p_header_size,
                                         p_manager);
  }
#line 2413
  if (! __cil_tmp14) {
    {
#line 2414
    opj_event_msg(p_manager, 1, "Error reading COD marker\n");
    }
#line 2415
    return (0);
  }
#line 2418
  if (p_header_size != 0U) {
    {
#line 2419
    opj_event_msg(p_manager, 1, "Error reading COD marker\n\200\305\211\202U");
    }
#line 2420
    return (0);
  }
  {
#line 2424
  opj_j2k_copy_tile_component_parameters(p_j2k);
  }
#line 2439
  return (1);
}
}
#line 2442 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_coc(opj_j2k_t *p_j2k , OPJ_UINT32 p_comp_no , opj_stream_private_t *p_stream ,
                           opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_coc_size ;
  OPJ_UINT32 l_remaining_size ;
  OPJ_UINT32 l_comp_room ;
  int tmp___2 ;
  OPJ_UINT32 __cil_tmp12 ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp14 ;
  OPJ_SIZE_T __cil_tmp15 ;

  {
#line 2455
  if ((p_j2k->m_private_image)->numcomps <= 256U) {
#line 2455
    tmp___2 = 1;
  } else {
#line 2455
    tmp___2 = 2;
  }
  {
#line 2455
  l_comp_room = (OPJ_UINT32 )tmp___2;
#line 2457
  __cil_tmp12 = opj_j2k_get_SPCod_SPCoc_size(p_j2k, p_j2k->m_current_tile_number,
                                             p_comp_no);
#line 2457
  l_coc_size = (5U + l_comp_room) + __cil_tmp12;
  }
#line 2459
  if (l_coc_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 2466
    __cil_tmp14 = realloc((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                          (unsigned long )l_coc_size);
#line 2466
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp14;
    }
#line 2467
    if (! new_header_tile_data) {
      {
#line 2468
      free((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 2469
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 2470
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 2471
      opj_event_msg(p_manager, 1, "Not enough memory to write COC marker\n");
      }
#line 2472
      return (0);
    }
#line 2474
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 2475
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_coc_size;
  }
  {
#line 2478
  opj_j2k_write_coc_in_memory(p_j2k, p_comp_no, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                              & l_remaining_size, p_manager);
#line 2480
  __cil_tmp15 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_coc_size, p_manager);
  }
#line 2480
  if (__cil_tmp15 != (unsigned long )l_coc_size) {
#line 2481
    return (0);
  }
#line 2484
  return (1);
}
}
#line 2487 "/root/patron/new_22/src/lib/openjp2/j2k.c"
void opj_j2k_write_coc_in_memory(opj_j2k_t *p_j2k , OPJ_UINT32 p_comp_no , OPJ_BYTE *p_data ,
                                 OPJ_UINT32 *p_data_written , opj_event_mgr_t *p_manager ) 
{ 
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 l_coc_size ;
  OPJ_UINT32 l_remaining_size ;
  OPJ_BYTE *l_current_data ;
  opj_image_t *l_image ;
  OPJ_UINT32 l_comp_room ;
  int tmp___1 ;
  OPJ_UINT32 __cil_tmp16 ;

  {
#line 2494
  l_cp = (opj_cp_t *)0;
#line 2495
  l_tcp = (opj_tcp_t *)0;
#line 2497
  l_current_data = (OPJ_BYTE *)0;
#line 2498
  l_image = (opj_image_t *)0;
#line 2505
  l_cp = & p_j2k->m_cp;
#line 2506
  l_tcp = l_cp->tcps + p_j2k->m_current_tile_number;
#line 2507
  l_image = p_j2k->m_private_image;
#line 2508
  if (l_image->numcomps <= 256U) {
#line 2508
    tmp___1 = 1;
  } else {
#line 2508
    tmp___1 = 2;
  }
  {
#line 2508
  l_comp_room = (OPJ_UINT32 )tmp___1;
#line 2510
  __cil_tmp16 = opj_j2k_get_SPCod_SPCoc_size(p_j2k, p_j2k->m_current_tile_number,
                                             p_comp_no);
#line 2510
  l_coc_size = (5U + l_comp_room) + __cil_tmp16;
#line 2511
  l_remaining_size = l_coc_size;
#line 2513
  l_current_data = p_data;
#line 2515
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65363, (OPJ_UINT32 )2);
#line 2516
  l_current_data += 2;
#line 2518
  opj_write_bytes_LE(l_current_data, l_coc_size - 2U, (OPJ_UINT32 )2);
#line 2519
  l_current_data += 2;
#line 2521
  opj_write_bytes_LE(l_current_data, p_comp_no, l_comp_room);
#line 2522
  l_current_data += l_comp_room;
#line 2524
  opj_write_bytes_LE(l_current_data, (l_tcp->tccps + p_comp_no)->csty, (OPJ_UINT32 )1);
#line 2525
  l_current_data ++;
#line 2527
  l_remaining_size -= 5U + l_comp_room;
#line 2528
  opj_j2k_write_SPCod_SPCoc(p_j2k, p_j2k->m_current_tile_number, (OPJ_UINT32 )0, l_current_data,
                            & l_remaining_size, p_manager);
#line 2529
  *p_data_written = l_coc_size;
  }
#line 2531
  return;
}
}
#line 2532 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_UINT32 opj_j2k_get_max_coc_size(opj_j2k_t *p_j2k ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 l_nb_comp ;
  OPJ_UINT32 l_nb_tiles ;
  OPJ_UINT32 l_max ;
  OPJ_UINT32 __cil_tmp7 ;
  OPJ_UINT32 __cil_tmp8 ;

  {
#line 2537
  l_max = (OPJ_UINT32 )0;
#line 2541
  l_nb_tiles = p_j2k->m_cp.tw * p_j2k->m_cp.th;
#line 2542
  l_nb_comp = (p_j2k->m_private_image)->numcomps;
#line 2544
  i = (OPJ_UINT32 )0;
  {
#line 2544
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2544
    if (! (i < l_nb_tiles)) {
#line 2544
      goto while_break;
    }
#line 2545
    j = (OPJ_UINT32 )0;
    {
#line 2545
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 2545
      if (! (j < l_nb_comp)) {
#line 2545
        goto while_break___0;
      }
      {
#line 2546
      __cil_tmp7 = opj_j2k_get_SPCod_SPCoc_size(p_j2k, i, j);
#line 2546
      __cil_tmp8 = opj_uint_max(l_max, __cil_tmp7);
#line 2546
      l_max = __cil_tmp8;
#line 2545
      j ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 2544
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 2550
  return (6U + l_max);
}
}
#line 2560 "/root/patron/new_22/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_coc(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_image_t *l_image ;
  OPJ_UINT32 l_comp_room ;
  OPJ_UINT32 l_comp_no ;
  opj_tcp_t *tmp___2 ;
  int tmp___3 ;
  OPJ_BOOL __cil_tmp15 ;

  {
#line 2566
  l_cp = (opj_cp_t *)((void *)0);
#line 2567
  l_tcp = (opj_tcp_t *)((void *)0);
#line 2568
  l_image = (opj_image_t *)((void *)0);
#line 2577
  l_cp = & p_j2k->m_cp;
#line 2578
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 2578
    tmp___2 = l_cp->tcps + p_j2k->m_current_tile_number;
  } else {
#line 2578
    tmp___2 = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
#line 2578
  l_tcp = tmp___2;
#line 2581
  l_image = p_j2k->m_private_image;
#line 2583
  if (l_image->numcomps <= 256U) {
#line 2583
    tmp___3 = 1;
  } else {
#line 2583
    tmp___3 = 2;
  }
#line 2583
  l_comp_room = (OPJ_UINT32 )tmp___3;
#line 2586
  if (p_header_size < l_comp_room + 1U) {
    {
#line 2587
    opj_event_msg(p_manager, 1, "Error reading COC marker\n");
    }
#line 2588
    return (0);
  }
  {
#line 2590
  p_header_size -= l_comp_room + 1U;
#line 2592
  opj_read_bytes_LE(p_header_data, & l_comp_no, l_comp_room);
#line 2593
  p_header_data += l_comp_room;
  }
#line 2594
  if (l_comp_no >= l_image->numcomps) {
    {
#line 2595
    opj_event_msg(p_manager, 1, "Error reading COC marker (bad number of components)\n");
    }
#line 2596
    return (0);
  }
  {
#line 2599
  opj_read_bytes_LE(p_header_data, & (l_tcp->tccps + l_comp_no)->csty, (OPJ_UINT32 )1);
#line 2600
  p_header_data ++;
#line 2602
  __cil_tmp15 = opj_j2k_read_SPCod_SPCoc(p_j2k, l_comp_no, p_header_data, & p_header_size,
                                         p_manager);
  }
#line 2602
  if (! __cil_tmp15) {
    {
#line 2603
    opj_event_msg(p_manager, 1, "Error reading COC marker\n");
    }
#line 2604
    return (0);
  }
#line 2607
  if (p_header_size != 0U) {
    {
#line 2608
    opj_event_msg(p_manager, 1, "Error reading COC marker\n");
    }
#line 2609
    return (0);
  }
#line 2611
  return (1);
}
}
#line 2614 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_qcd(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_qcd_size ;
  OPJ_UINT32 l_remaining_size ;
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 __cil_tmp10 ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp12 ;
  OPJ_BOOL __cil_tmp13 ;
  OPJ_SIZE_T __cil_tmp14 ;

  {
  {
#line 2620
  l_current_data = (OPJ_BYTE *)0;
#line 2627
  __cil_tmp10 = opj_j2k_get_SQcd_SQcc_size(p_j2k, p_j2k->m_current_tile_number, (OPJ_UINT32 )0);
#line 2627
  l_qcd_size = 4U + __cil_tmp10;
#line 2628
  l_remaining_size = l_qcd_size;
  }
#line 2630
  if (l_qcd_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 2631
    __cil_tmp12 = realloc((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                          (unsigned long )l_qcd_size);
#line 2631
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp12;
    }
#line 2632
    if (! new_header_tile_data) {
      {
#line 2633
      free((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 2634
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 2635
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 2636
      opj_event_msg(p_manager, 1, "Not enough memory to write QCD marker\n");
      }
#line 2637
      return (0);
    }
#line 2639
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 2640
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_qcd_size;
  }
  {
#line 2643
  l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 2645
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65372, (OPJ_UINT32 )2);
#line 2646
  l_current_data += 2;
#line 2648
  opj_write_bytes_LE(l_current_data, l_qcd_size - 2U, (OPJ_UINT32 )2);
#line 2649
  l_current_data += 2;
#line 2651
  l_remaining_size -= 4U;
#line 2653
  __cil_tmp13 = opj_j2k_write_SQcd_SQcc(p_j2k, p_j2k->m_current_tile_number, (OPJ_UINT32 )0,
                                        l_current_data, & l_remaining_size, p_manager);
  }
#line 2653
  if (! __cil_tmp13) {
    {
#line 2654
    opj_event_msg(p_manager, 1, "Error writing QCD marker\n");
    }
#line 2655
    return (0);
  }
#line 2658
  if (l_remaining_size != 0U) {
    {
#line 2659
    opj_event_msg(p_manager, 1, "Error writing QCD marker\n");
    }
#line 2660
    return (0);
  }
  {
#line 2663
  __cil_tmp14 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_qcd_size, p_manager);
  }
#line 2663
  if (__cil_tmp14 != (unsigned long )l_qcd_size) {
#line 2664
    return (0);
  }
#line 2667
  return (1);
}
}
#line 2677 "/root/patron/new_22/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_qcd(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp8 ;

  {
  {
#line 2688
  __cil_tmp8 = opj_j2k_read_SQcd_SQcc(p_j2k, (OPJ_UINT32 )0, p_header_data, & p_header_size,
                                      p_manager);
  }
#line 2688
  if (! __cil_tmp8) {
    {
#line 2689
    opj_event_msg(p_manager, 1, "Error reading QCD marker\n");
    }
#line 2690
    return (0);
  }
#line 2693
  if (p_header_size != 0U) {
    {
#line 2694
    opj_event_msg(p_manager, 1, "Error reading QCD marker\n&\276\211\202U");
    }
#line 2695
    return (0);
  }
  {
#line 2699
  opj_j2k_copy_tile_quantization_parameters(p_j2k);
  }
#line 2701
  return (1);
}
}
#line 2704 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_qcc(opj_j2k_t *p_j2k , OPJ_UINT32 p_comp_no , opj_stream_private_t *p_stream ,
                           opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_qcc_size ;
  OPJ_UINT32 l_remaining_size ;
  OPJ_UINT32 __cil_tmp10 ;
  int tmp___2 ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp13 ;
  OPJ_SIZE_T __cil_tmp14 ;

  {
  {
#line 2717
  __cil_tmp10 = opj_j2k_get_SQcd_SQcc_size(p_j2k, p_j2k->m_current_tile_number, p_comp_no);
#line 2717
  l_qcc_size = 5U + __cil_tmp10;
  }
#line 2718
  if ((p_j2k->m_private_image)->numcomps <= 256U) {
#line 2718
    tmp___2 = 0;
  } else {
#line 2718
    tmp___2 = 1;
  }
#line 2718
  l_qcc_size += (unsigned int )tmp___2;
#line 2719
  l_remaining_size = l_qcc_size;
#line 2721
  if (l_qcc_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 2722
    __cil_tmp13 = realloc((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                          (unsigned long )l_qcc_size);
#line 2722
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp13;
    }
#line 2723
    if (! new_header_tile_data) {
      {
#line 2724
      free((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 2725
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 2726
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 2727
      opj_event_msg(p_manager, 1, "Not enough memory to write QCC marker\n");
      }
#line 2728
      return (0);
    }
#line 2730
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 2731
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_qcc_size;
  }
  {
#line 2734
  opj_j2k_write_qcc_in_memory(p_j2k, p_comp_no, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                              & l_remaining_size, p_manager);
#line 2736
  __cil_tmp14 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_qcc_size, p_manager);
  }
#line 2736
  if (__cil_tmp14 != (unsigned long )l_qcc_size) {
#line 2737
    return (0);
  }
#line 2740
  return (1);
}
}
#line 2743 "/root/patron/new_22/src/lib/openjp2/j2k.c"
void opj_j2k_write_qcc_in_memory(opj_j2k_t *p_j2k , OPJ_UINT32 p_comp_no , OPJ_BYTE *p_data ,
                                 OPJ_UINT32 *p_data_written , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_qcc_size ;
  OPJ_UINT32 l_remaining_size ;
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 __cil_tmp11 ;

  {
  {
#line 2751
  l_current_data = (OPJ_BYTE *)0;
#line 2757
  __cil_tmp11 = opj_j2k_get_SQcd_SQcc_size(p_j2k, p_j2k->m_current_tile_number, p_comp_no);
#line 2757
  l_qcc_size = 6U + __cil_tmp11;
#line 2758
  l_remaining_size = l_qcc_size;
#line 2760
  l_current_data = p_data;
#line 2762
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65373, (OPJ_UINT32 )2);
#line 2763
  l_current_data += 2;
  }
#line 2765
  if ((p_j2k->m_private_image)->numcomps <= 256U) {
    {
#line 2766
    l_qcc_size --;
#line 2768
    opj_write_bytes_LE(l_current_data, l_qcc_size - 2U, (OPJ_UINT32 )2);
#line 2769
    l_current_data += 2;
#line 2771
    opj_write_bytes_LE(l_current_data, p_comp_no, (OPJ_UINT32 )1);
#line 2772
    l_current_data ++;
#line 2775
    l_remaining_size -= 6U;
    }
  } else {
    {
#line 2778
    opj_write_bytes_LE(l_current_data, l_qcc_size - 2U, (OPJ_UINT32 )2);
#line 2779
    l_current_data += 2;
#line 2781
    opj_write_bytes_LE(l_current_data, p_comp_no, (OPJ_UINT32 )2);
#line 2782
    l_current_data += 2;
#line 2784
    l_remaining_size -= 6U;
    }
  }
  {
#line 2787
  opj_j2k_write_SQcd_SQcc(p_j2k, p_j2k->m_current_tile_number, p_comp_no, l_current_data,
                          & l_remaining_size, p_manager);
#line 2789
  *p_data_written = l_qcc_size;
  }
#line 2791
  return;
}
}
#line 2792 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_UINT32 opj_j2k_get_max_qcc_size(opj_j2k_t *p_j2k ) 
{ 
  OPJ_UINT32 __cil_tmp2 ;

  {
  {
#line 2794
  __cil_tmp2 = opj_j2k_get_max_coc_size(p_j2k);
  }
#line 2794
  return (__cil_tmp2);
}
}
#line 2804 "/root/patron/new_22/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_qcc(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_num_comp ;
  OPJ_UINT32 l_comp_no ;
  OPJ_BOOL __cil_tmp10 ;

  {
#line 2817
  l_num_comp = (p_j2k->m_private_image)->numcomps;
#line 2819
  if (l_num_comp <= 256U) {
#line 2820
    if (p_header_size < 1U) {
      {
#line 2821
      opj_event_msg(p_manager, 1, "Error reading QCC marker\n");
      }
#line 2822
      return (0);
    }
    {
#line 2824
    opj_read_bytes_LE(p_header_data, & l_comp_no, (OPJ_UINT32 )1);
#line 2825
    p_header_data ++;
#line 2826
    p_header_size --;
    }
  } else {
#line 2829
    if (p_header_size < 2U) {
      {
#line 2830
      opj_event_msg(p_manager, 1, "Error reading QCC marker\n");
      }
#line 2831
      return (0);
    }
    {
#line 2833
    opj_read_bytes_LE(p_header_data, & l_comp_no, (OPJ_UINT32 )2);
#line 2834
    p_header_data += 2;
#line 2835
    p_header_size -= 2U;
    }
  }
#line 2864
  if (l_comp_no >= (p_j2k->m_private_image)->numcomps) {
    {
#line 2865
    opj_event_msg(p_manager, 1, "Invalid component number: %d, regarding the number of components %d\n",
                  l_comp_no, (p_j2k->m_private_image)->numcomps);
    }
#line 2868
    return (0);
  }
  {
#line 2871
  __cil_tmp10 = opj_j2k_read_SQcd_SQcc(p_j2k, l_comp_no, p_header_data, & p_header_size,
                                       p_manager);
  }
#line 2871
  if (! __cil_tmp10) {
    {
#line 2872
    opj_event_msg(p_manager, 1, "Error reading QCC marker\n");
    }
#line 2873
    return (0);
  }
#line 2876
  if (p_header_size != 0U) {
    {
#line 2877
    opj_event_msg(p_manager, 1, "Error reading QCC marker\n");
    }
#line 2878
    return (0);
  }
#line 2881
  return (1);
}
}
#line 2884 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_poc(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_nb_comp ;
  OPJ_UINT32 l_nb_poc ;
  OPJ_UINT32 l_poc_size ;
  OPJ_UINT32 l_written_size ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 l_poc_room ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp14 ;
  OPJ_SIZE_T __cil_tmp15 ;

  {
#line 2892
  l_written_size = (OPJ_UINT32 )0;
#line 2893
  l_tcp = (opj_tcp_t *)0;
#line 2901
  l_tcp = p_j2k->m_cp.tcps + p_j2k->m_current_tile_number;
#line 2902
  l_nb_comp = (p_j2k->m_private_image)->numcomps;
#line 2903
  l_nb_poc = 1U + l_tcp->numpocs;
#line 2905
  if (l_nb_comp <= 256U) {
#line 2906
    l_poc_room = (OPJ_UINT32 )1;
  } else {
#line 2909
    l_poc_room = (OPJ_UINT32 )2;
  }
#line 2911
  l_poc_size = 4U + (5U + 2U * l_poc_room) * l_nb_poc;
#line 2913
  if (l_poc_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 2914
    __cil_tmp14 = realloc((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                          (unsigned long )l_poc_size);
#line 2914
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp14;
    }
#line 2915
    if (! new_header_tile_data) {
      {
#line 2916
      free((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 2917
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 2918
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 2919
      opj_event_msg(p_manager, 1, "Not enough memory to write POC marker\n");
      }
#line 2920
      return (0);
    }
#line 2922
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 2923
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_poc_size;
  }
  {
#line 2926
  opj_j2k_write_poc_in_memory(p_j2k, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                              & l_written_size, p_manager);
#line 2928
  __cil_tmp15 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_poc_size, p_manager);
  }
#line 2928
  if (__cil_tmp15 != (unsigned long )l_poc_size) {
#line 2929
    return (0);
  }
#line 2932
  return (1);
}
}
#line 2935 "/root/patron/new_22/src/lib/openjp2/j2k.c"
void opj_j2k_write_poc_in_memory(opj_j2k_t *p_j2k , OPJ_BYTE *p_data , OPJ_UINT32 *p_data_written ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 l_nb_comp ;
  OPJ_UINT32 l_nb_poc ;
  OPJ_UINT32 l_poc_size ;
  opj_image_t *l_image ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;
  opj_poc_t *l_current_poc ;
  OPJ_UINT32 l_poc_room ;
  OPJ_INT32 __cil_tmp17 ;
  OPJ_INT32 __cil_tmp18 ;
  OPJ_INT32 __cil_tmp19 ;

  {
#line 2942
  l_current_data = (OPJ_BYTE *)0;
#line 2946
  l_image = (opj_image_t *)0;
#line 2947
  l_tcp = (opj_tcp_t *)0;
#line 2948
  l_tccp = (opj_tccp_t *)0;
#line 2949
  l_current_poc = (opj_poc_t *)0;
#line 2956
  l_tcp = p_j2k->m_cp.tcps + p_j2k->m_current_tile_number;
#line 2957
  l_tccp = l_tcp->tccps + 0;
#line 2958
  l_image = p_j2k->m_private_image;
#line 2959
  l_nb_comp = l_image->numcomps;
#line 2960
  l_nb_poc = 1U + l_tcp->numpocs;
#line 2962
  if (l_nb_comp <= 256U) {
#line 2963
    l_poc_room = (OPJ_UINT32 )1;
  } else {
#line 2966
    l_poc_room = (OPJ_UINT32 )2;
  }
  {
#line 2969
  l_poc_size = 4U + (5U + 2U * l_poc_room) * l_nb_poc;
#line 2971
  l_current_data = p_data;
#line 2973
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65375, (OPJ_UINT32 )2);
#line 2974
  l_current_data += 2;
#line 2976
  opj_write_bytes_LE(l_current_data, l_poc_size - 2U, (OPJ_UINT32 )2);
#line 2977
  l_current_data += 2;
#line 2979
  l_current_poc = l_tcp->pocs;
#line 2980
  i = (OPJ_UINT32 )0;
  }
  {
#line 2980
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2980
    if (! (i < l_nb_poc)) {
#line 2980
      goto while_break;
    }
    {
#line 2981
    opj_write_bytes_LE(l_current_data, l_current_poc->resno0, (OPJ_UINT32 )1);
#line 2982
    l_current_data ++;
#line 2984
    opj_write_bytes_LE(l_current_data, l_current_poc->compno0, l_poc_room);
#line 2985
    l_current_data += l_poc_room;
#line 2987
    opj_write_bytes_LE(l_current_data, l_current_poc->layno1, (OPJ_UINT32 )2);
#line 2988
    l_current_data += 2;
#line 2990
    opj_write_bytes_LE(l_current_data, l_current_poc->resno1, (OPJ_UINT32 )1);
#line 2991
    l_current_data ++;
#line 2993
    opj_write_bytes_LE(l_current_data, l_current_poc->compno1, l_poc_room);
#line 2994
    l_current_data += l_poc_room;
#line 2996
    opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )l_current_poc->prg, (OPJ_UINT32 )1);
#line 2997
    l_current_data ++;
#line 3000
    __cil_tmp17 = opj_int_min((OPJ_INT32 )l_current_poc->layno1, (OPJ_INT32 )l_tcp->numlayers);
#line 3000
    l_current_poc->layno1 = (OPJ_UINT32 )__cil_tmp17;
#line 3001
    __cil_tmp18 = opj_int_min((OPJ_INT32 )l_current_poc->resno1, (OPJ_INT32 )l_tccp->numresolutions);
#line 3001
    l_current_poc->resno1 = (OPJ_UINT32 )__cil_tmp18;
#line 3002
    __cil_tmp19 = opj_int_min((OPJ_INT32 )l_current_poc->compno1, (OPJ_INT32 )l_nb_comp);
#line 3002
    l_current_poc->compno1 = (OPJ_UINT32 )__cil_tmp19;
#line 3004
    l_current_poc ++;
#line 2980
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 3007
  *p_data_written = l_poc_size;
#line 3008
  return;
}
}
#line 3010 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_UINT32 opj_j2k_get_max_poc_size(opj_j2k_t *p_j2k ) 
{ 
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 l_nb_tiles ;
  OPJ_UINT32 l_max_poc ;
  OPJ_UINT32 i ;

  {
#line 3012
  l_tcp = (opj_tcp_t *)0;
#line 3013
  l_nb_tiles = (OPJ_UINT32 )0;
#line 3014
  l_max_poc = (OPJ_UINT32 )0;
#line 3017
  l_tcp = p_j2k->m_cp.tcps;
#line 3018
  l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;
#line 3020
  i = (OPJ_UINT32 )0;
  {
#line 3020
  while (1) {
    while_continue: /* CIL Label */ ;

#line 3020
    if (! (i < l_nb_tiles)) {
#line 3020
      goto while_break;
    }
    {
#line 3021
    l_max_poc = opj_uint_max(l_max_poc, l_tcp->numpocs);
#line 3022
    l_tcp ++;
#line 3020
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 3025
  l_max_poc ++;
#line 3027
  return (4U + 9U * l_max_poc);
}
}
#line 3030 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_UINT32 opj_j2k_get_max_toc_size(opj_j2k_t *p_j2k ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_nb_tiles ;
  OPJ_UINT32 l_max ;
  opj_tcp_t *l_tcp ;

  {
#line 3034
  l_max = (OPJ_UINT32 )0;
#line 3035
  l_tcp = (opj_tcp_t *)0;
#line 3037
  l_tcp = p_j2k->m_cp.tcps;
#line 3038
  l_nb_tiles = p_j2k->m_cp.tw * p_j2k->m_cp.th;
#line 3040
  i = (OPJ_UINT32 )0;
  {
#line 3040
  while (1) {
    while_continue: /* CIL Label */ ;

#line 3040
    if (! (i < l_nb_tiles)) {
#line 3040
      goto while_break;
    }
    {
#line 3041
    l_max = opj_uint_max(l_max, l_tcp->m_nb_tile_parts);
#line 3043
    l_tcp ++;
#line 3040
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 3046
  return (12U * l_max);
}
}
#line 3049 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_UINT32 opj_j2k_get_specific_header_sizes(opj_j2k_t *p_j2k ) 
{ 
  OPJ_UINT32 l_nb_bytes ;
  OPJ_UINT32 l_nb_comps ;
  OPJ_UINT32 l_coc_bytes ;
  OPJ_UINT32 l_qcc_bytes ;
  OPJ_UINT32 __cil_tmp6 ;
  OPJ_UINT32 __cil_tmp9 ;

  {
  {
#line 3051
  l_nb_bytes = (OPJ_UINT32 )0;
#line 3055
  l_nb_comps = (p_j2k->m_private_image)->numcomps - 1U;
#line 3056
  __cil_tmp6 = opj_j2k_get_max_toc_size(p_j2k);
#line 3056
  l_nb_bytes += __cil_tmp6;
  }
#line 3058
  if ((unsigned int )p_j2k->m_cp.m_specific_param.m_enc.m_cinema == 0U) {
    {
#line 3059
    l_coc_bytes = opj_j2k_get_max_coc_size(p_j2k);
#line 3060
    l_nb_bytes += l_nb_comps * l_coc_bytes;
#line 3062
    l_qcc_bytes = opj_j2k_get_max_qcc_size(p_j2k);
#line 3063
    l_nb_bytes += l_nb_comps * l_qcc_bytes;
    }
  }
  {
#line 3066
  __cil_tmp9 = opj_j2k_get_max_poc_size(p_j2k);
#line 3066
  l_nb_bytes += __cil_tmp9;
  }
#line 3070
  return (l_nb_bytes);
}
}
#line 3081 "/root/patron/new_22/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_poc(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_nb_comp ;
  OPJ_UINT32 l_tmp ;
  opj_image_t *l_image ;
  OPJ_UINT32 l_old_poc_nb ;
  OPJ_UINT32 l_current_poc_nb ;
  OPJ_UINT32 l_current_poc_remaining ;
  OPJ_UINT32 l_chunk_size ;
  OPJ_UINT32 l_comp_room ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_poc_t *l_current_poc ;
  opj_tcp_t *tmp___2 ;
  OPJ_UINT32 tmp___3 ;

  {
#line 3088
  l_image = (opj_image_t *)0;
#line 3092
  l_cp = (opj_cp_t *)0;
#line 3093
  l_tcp = (opj_tcp_t *)0;
#line 3094
  l_current_poc = (opj_poc_t *)0;
#line 3101
  l_image = p_j2k->m_private_image;
#line 3102
  l_nb_comp = l_image->numcomps;
#line 3103
  if (l_nb_comp <= 256U) {
#line 3104
    l_comp_room = (OPJ_UINT32 )1;
  } else {
#line 3107
    l_comp_room = (OPJ_UINT32 )2;
  }
#line 3109
  l_chunk_size = 5U + 2U * l_comp_room;
#line 3110
  l_current_poc_nb = p_header_size / l_chunk_size;
#line 3111
  l_current_poc_remaining = p_header_size % l_chunk_size;
#line 3113
  if (l_current_poc_nb <= 0U) {
    {
#line 3114
    opj_event_msg(p_manager, 1, "Error reading POC marker\n");
    }
#line 3115
    return (0);
  } else
#line 3113
  if (l_current_poc_remaining != 0U) {
    {
#line 3114
    opj_event_msg(p_manager, 1, "Error reading POC marker\n");
    }
#line 3115
    return (0);
  }
#line 3118
  l_cp = & p_j2k->m_cp;
#line 3119
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 3119
    tmp___2 = l_cp->tcps + p_j2k->m_current_tile_number;
  } else {
#line 3119
    tmp___2 = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
#line 3119
  l_tcp = tmp___2;
#line 3122
  if ((int )l_tcp->POC) {
#line 3122
    tmp___3 = l_tcp->numpocs + 1U;
  } else {
#line 3122
    tmp___3 = 0U;
  }
#line 3122
  l_old_poc_nb = tmp___3;
#line 3123
  l_current_poc_nb += l_old_poc_nb;
#line 3128
  l_tcp->POC = (OPJ_UINT32 )1;
#line 3130
  l_current_poc = & l_tcp->pocs[l_old_poc_nb];
#line 3131
  i = l_old_poc_nb;
  {
#line 3131
  while (1) {
    while_continue: /* CIL Label */ ;

#line 3131
    if (! (i < l_current_poc_nb)) {
#line 3131
      goto while_break;
    }
    {
#line 3132
    opj_read_bytes_LE(p_header_data, & l_current_poc->resno0, (OPJ_UINT32 )1);
#line 3133
    p_header_data ++;
#line 3134
    opj_read_bytes_LE(p_header_data, & l_current_poc->compno0, l_comp_room);
#line 3135
    p_header_data += l_comp_room;
#line 3136
    opj_read_bytes_LE(p_header_data, & l_current_poc->layno1, (OPJ_UINT32 )2);
#line 3137
    p_header_data += 2;
#line 3138
    opj_read_bytes_LE(p_header_data, & l_current_poc->resno1, (OPJ_UINT32 )1);
#line 3139
    p_header_data ++;
#line 3140
    opj_read_bytes_LE(p_header_data, & l_current_poc->compno1, l_comp_room);
#line 3141
    p_header_data += l_comp_room;
#line 3142
    opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )1);
#line 3143
    p_header_data ++;
#line 3144
    l_current_poc->prg = (OPJ_PROG_ORDER )l_tmp;
#line 3146
    l_current_poc->compno1 = opj_uint_min(l_current_poc->compno1, l_nb_comp);
#line 3147
    l_current_poc ++;
#line 3131
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 3150
  l_tcp->numpocs = l_current_poc_nb - 1U;
#line 3151
  return (1);
}
}
#line 3162 "/root/patron/new_22/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_crg(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_nb_comp ;

  {
#line 3174
  l_nb_comp = (p_j2k->m_private_image)->numcomps;
#line 3176
  if (p_header_size != l_nb_comp * 4U) {
    {
#line 3177
    opj_event_msg(p_manager, 1, "Error reading CRG marker\nj\310\211\202U");
    }
#line 3178
    return (0);
  }
#line 3191
  return (1);
}
}
#line 3202 "/root/patron/new_22/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_tlm(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_Ztlm ;
  OPJ_UINT32 l_Stlm ;
  OPJ_UINT32 l_ST ;
  OPJ_UINT32 l_SP ;
  OPJ_UINT32 l_tot_num_tp_remaining ;
  OPJ_UINT32 l_quotient ;
  OPJ_UINT32 l_Ptlm_size ;

  {
#line 3214
  if (p_header_size < 2U) {
    {
#line 3215
    opj_event_msg(p_manager, 1, "Error reading TLM marker\n\207\310\211\202U");
    }
#line 3216
    return (0);
  }
  {
#line 3218
  p_header_size -= 2U;
#line 3220
  opj_read_bytes_LE(p_header_data, & l_Ztlm, (OPJ_UINT32 )1);
#line 3221
  p_header_data ++;
#line 3222
  opj_read_bytes_LE(p_header_data, & l_Stlm, (OPJ_UINT32 )1);
#line 3223
  p_header_data ++;
#line 3225
  l_ST = (l_Stlm >> 4) & 3U;
#line 3226
  l_SP = (l_Stlm >> 6) & 1U;
#line 3228
  l_Ptlm_size = (l_SP + 1U) * 2U;
#line 3229
  l_quotient = l_Ptlm_size + l_ST;
#line 3231
  l_tot_num_tp_remaining = p_header_size % l_quotient;
  }
#line 3233
  if (l_tot_num_tp_remaining != 0U) {
    {
#line 3234
    opj_event_msg(p_manager, 1, "Error reading TLM marker\nO\310\211\202U");
    }
#line 3235
    return (0);
  }
#line 3247
  return (1);
}
}
#line 3258 "/root/patron/new_22/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_plm(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 


  {
#line 3269
  if (p_header_size < 1U) {
    {
#line 3270
    opj_event_msg(p_manager, 1, "Error reading PLM marker\n\301\310\211\202U");
    }
#line 3271
    return (0);
  }
#line 3317
  return (1);
}
}
#line 3328 "/root/patron/new_22/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_plt(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_Zplt ;
  OPJ_UINT32 l_tmp ;
  OPJ_UINT32 l_packet_len ;
  OPJ_UINT32 i ;

  {
#line 3334
  l_packet_len = (OPJ_UINT32 )0;
#line 3341
  if (p_header_size < 1U) {
    {
#line 3342
    opj_event_msg(p_manager, 1, "Error reading PLT marker\n\301\310\211\202U");
    }
#line 3343
    return (0);
  }
  {
#line 3346
  opj_read_bytes_LE(p_header_data, & l_Zplt, (OPJ_UINT32 )1);
#line 3347
  p_header_data ++;
#line 3348
  p_header_size --;
#line 3350
  i = (OPJ_UINT32 )0;
  }
  {
#line 3350
  while (1) {
    while_continue: /* CIL Label */ ;

#line 3350
    if (! (i < p_header_size)) {
#line 3350
      goto while_break;
    }
    {
#line 3351
    opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )1);
#line 3352
    p_header_data ++;
#line 3354
    l_packet_len |= l_tmp & 127U;
    }
#line 3355
    if (l_tmp & 128U) {
#line 3356
      l_packet_len <<= 7;
    } else {
#line 3360
      l_packet_len = (OPJ_UINT32 )0;
    }
#line 3350
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 3364
  if (l_packet_len != 0U) {
    {
#line 3365
    opj_event_msg(p_manager, 1, "Error reading PLT marker\n\337\310\211\202U");
    }
#line 3366
    return (0);
  }
#line 3369
  return (1);
}
}
#line 3475 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL j2k_read_ppm_v3(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                         struct opj_event_mgr *p_manager ) 
{ 
  opj_cp_t *l_cp ;
  OPJ_UINT32 l_remaining_data ;
  OPJ_UINT32 l_Z_ppm ;
  OPJ_UINT32 l_N_ppm ;
  void *__cil_tmp12 ;
  OPJ_BYTE *new_ppm_data ;
  void *__cil_tmp15 ;
  OPJ_BYTE *new_ppm_data___0 ;
  void *__cil_tmp18 ;
  OPJ_BYTE *new_ppm_data___1 ;
  void *__cil_tmp21 ;

  {
#line 3482
  l_cp = (opj_cp_t *)0;
#line 3491
  if (p_header_size < 1U) {
    {
#line 3492
    opj_event_msg(p_manager, 1, "Error reading PPM marker\n");
    }
#line 3493
    return (0);
  }
  {
#line 3496
  l_cp = & p_j2k->m_cp;
#line 3497
  l_cp->ppm = (OPJ_UINT32 )1;
#line 3499
  opj_read_bytes_LE(p_header_data, & l_Z_ppm, (OPJ_UINT32 )1);
#line 3500
  p_header_data ++;
#line 3501
  p_header_size --;
  }
#line 3504
  if (l_Z_ppm == 0U) {
#line 3506
    if (p_header_size < 4U) {
      {
#line 3507
      opj_event_msg(p_manager, 1, "Error reading PPM marker\n");
      }
#line 3508
      return (0);
    }
    {
#line 3511
    opj_read_bytes_LE(p_header_data, & l_N_ppm, (OPJ_UINT32 )4);
#line 3512
    p_header_data += 4;
#line 3513
    p_header_size -= 4U;
#line 3516
    l_cp->ppm_len = l_N_ppm;
#line 3517
    l_cp->ppm_data_read = (OPJ_UINT32 )0;
#line 3519
    __cil_tmp12 = malloc((unsigned long )l_cp->ppm_len);
#line 3519
    l_cp->ppm_data = (OPJ_BYTE *)__cil_tmp12;
#line 3520
    l_cp->ppm_buffer = l_cp->ppm_data;
    }
#line 3521
    if ((unsigned long )l_cp->ppm_data == (unsigned long )((OPJ_BYTE *)0)) {
      {
#line 3522
      opj_event_msg(p_manager, 1, "Not enough memory to read ppm marker\nU");
      }
#line 3523
      return (0);
    }
    {
#line 3525
    memset((void *)l_cp->ppm_data, 0, (unsigned long )l_cp->ppm_len);
#line 3527
    l_cp->ppm_data_current = l_cp->ppm_data;
    }
  } else
#line 3532
  if (p_header_size < 4U) {
    {
#line 3533
    opj_event_msg(p_manager, 2, "Empty PPM marker\n\330\310\211\202U");
    }
#line 3534
    return (1);
  } else
#line 3538
  if (l_cp->ppm_data_read < l_cp->ppm_len) {
#line 3540
    l_cp->ppm_data_current = l_cp->ppm_data + l_cp->ppm_data_read;
#line 3541
    l_N_ppm = l_cp->ppm_len - l_cp->ppm_data_read;
  } else {
    {
#line 3545
    opj_read_bytes_LE(p_header_data, & l_N_ppm, (OPJ_UINT32 )4);
#line 3546
    p_header_data += 4;
#line 3547
    p_header_size -= 4U;
#line 3551
    __cil_tmp15 = realloc((void *)l_cp->ppm_data, (unsigned long )(l_cp->ppm_len + l_N_ppm));
#line 3551
    new_ppm_data = (OPJ_BYTE *)__cil_tmp15;
    }
#line 3552
    if (! new_ppm_data) {
      {
#line 3553
      free((void *)l_cp->ppm_data);
#line 3554
      l_cp->ppm_data = (OPJ_BYTE *)((void *)0);
#line 3555
      l_cp->ppm_buffer = (OPJ_BYTE *)((void *)0);
#line 3556
      l_cp->ppm_len = (OPJ_UINT32 )0;
#line 3557
      opj_event_msg(p_manager, 1, "Not enough memory to increase the size of ppm_data to add the new Ippm series\n");
      }
#line 3558
      return (0);
    }
#line 3560
    l_cp->ppm_data = new_ppm_data;
#line 3561
    l_cp->ppm_buffer = l_cp->ppm_data;
#line 3564
    l_cp->ppm_data_current = l_cp->ppm_data + l_cp->ppm_len;
#line 3565
    l_cp->ppm_len += l_N_ppm;
  }
#line 3570
  l_remaining_data = p_header_size;
  {
#line 3572
  while (1) {
    while_continue: /* CIL Label */ ;

#line 3572
    if (! (l_remaining_data >= l_N_ppm)) {
#line 3572
      goto while_break;
    }
    {
#line 3574
    memcpy((void *)l_cp->ppm_data_current, (void const   *)p_header_data, (unsigned long )l_N_ppm);
#line 3575
    p_header_size -= l_N_ppm;
#line 3576
    p_header_data += l_N_ppm;
#line 3578
    l_cp->ppm_data_read += l_N_ppm;
    }
#line 3580
    if (p_header_size) {
      {
#line 3582
      opj_read_bytes_LE(p_header_data, & l_N_ppm, (OPJ_UINT32 )4);
#line 3583
      p_header_data += 4;
#line 3584
      p_header_size -= 4U;
      }
    } else {
#line 3587
      l_remaining_data = p_header_size;
#line 3588
      goto while_break;
    }
#line 3591
    l_remaining_data = p_header_size;
#line 3594
    if (l_remaining_data > l_N_ppm) {
      {
#line 3598
      __cil_tmp18 = realloc((void *)l_cp->ppm_data, (unsigned long )(l_cp->ppm_len + l_N_ppm));
#line 3598
      new_ppm_data___0 = (OPJ_BYTE *)__cil_tmp18;
      }
#line 3599
      if (! new_ppm_data___0) {
        {
#line 3600
        free((void *)l_cp->ppm_data);
#line 3601
        l_cp->ppm_data = (OPJ_BYTE *)((void *)0);
#line 3602
        l_cp->ppm_buffer = (OPJ_BYTE *)((void *)0);
#line 3603
        l_cp->ppm_len = (OPJ_UINT32 )0;
#line 3604
        opj_event_msg(p_manager, 1, "Not enough memory to increase the size of ppm_data to add the new (complete) Ippm series\n");
        }
#line 3605
        return (0);
      }
#line 3607
      l_cp->ppm_data = new_ppm_data___0;
#line 3608
      l_cp->ppm_buffer = l_cp->ppm_data;
#line 3611
      l_cp->ppm_data_current = l_cp->ppm_data + l_cp->ppm_len;
#line 3612
      l_cp->ppm_len += l_N_ppm;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 3618
  if (l_remaining_data) {
    {
#line 3621
    __cil_tmp21 = realloc((void *)l_cp->ppm_data, (unsigned long )(l_cp->ppm_len + l_N_ppm));
#line 3621
    new_ppm_data___1 = (OPJ_BYTE *)__cil_tmp21;
    }
#line 3622
    if (! new_ppm_data___1) {
      {
#line 3623
      free((void *)l_cp->ppm_data);
#line 3624
      l_cp->ppm_data = (OPJ_BYTE *)((void *)0);
#line 3625
      l_cp->ppm_buffer = (OPJ_BYTE *)((void *)0);
#line 3626
      l_cp->ppm_len = (OPJ_UINT32 )0;
#line 3627
      opj_event_msg(p_manager, 1, "Not enough memory to increase the size of ppm_data to add the new (incomplete) Ippm series\n");
      }
#line 3628
      return (0);
    }
    {
#line 3630
    l_cp->ppm_data = new_ppm_data___1;
#line 3631
    l_cp->ppm_buffer = l_cp->ppm_data;
#line 3634
    l_cp->ppm_data_current = l_cp->ppm_data + l_cp->ppm_len;
#line 3635
    l_cp->ppm_len += l_N_ppm;
#line 3638
    memcpy((void *)l_cp->ppm_data_current, (void const   *)p_header_data, (unsigned long )l_remaining_data);
#line 3639
    p_header_size -= l_remaining_data;
#line 3640
    p_header_data += l_remaining_data;
#line 3642
    l_cp->ppm_data_read += l_remaining_data;
    }
  }
#line 3691
  return (1);
}
}
#line 3702 "/root/patron/new_22/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_ppt(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 l_Z_ppt ;
  void *__cil_tmp11 ;
  OPJ_BYTE *new_ppt_buffer ;
  void *__cil_tmp13 ;

  {
#line 3708
  l_cp = (opj_cp_t *)0;
#line 3709
  l_tcp = (opj_tcp_t *)0;
#line 3718
  if (p_header_size < 1U) {
    {
#line 3719
    opj_event_msg(p_manager, 1, "Error reading PPT marker\n");
    }
#line 3720
    return (0);
  }
#line 3723
  l_cp = & p_j2k->m_cp;
#line 3724
  if (l_cp->ppm) {
    {
#line 3725
    opj_event_msg(p_manager, 1, "Error reading PPT marker: packet header have been previously found in the main header (PPM marker).\n\202U");
    }
#line 3726
    return (0);
  }
  {
#line 3729
  l_tcp = l_cp->tcps + p_j2k->m_current_tile_number;
#line 3730
  l_tcp->ppt = (OPJ_UINT32 )1;
#line 3732
  opj_read_bytes_LE(p_header_data, & l_Z_ppt, (OPJ_UINT32 )1);
#line 3733
  p_header_data ++;
#line 3734
  p_header_size --;
  }
#line 3737
  if (l_Z_ppt == 0U) {
    {
#line 3739
    l_tcp->ppt_data_size = (OPJ_UINT32 )0;
#line 3740
    l_tcp->ppt_len = p_header_size;
#line 3742
    __cil_tmp11 = calloc((unsigned long )l_tcp->ppt_len, sizeof(OPJ_BYTE ));
#line 3742
    l_tcp->ppt_buffer = (OPJ_BYTE *)__cil_tmp11;
    }
#line 3743
    if ((unsigned long )l_tcp->ppt_buffer == (unsigned long )((OPJ_BYTE *)0)) {
      {
#line 3744
      opj_event_msg(p_manager, 1, "Not enough memory to read PPT marker\nU");
      }
#line 3745
      return (0);
    }
#line 3747
    l_tcp->ppt_data = l_tcp->ppt_buffer;
  } else {
    {
#line 3753
    l_tcp->ppt_len += p_header_size;
#line 3755
    __cil_tmp13 = realloc((void *)l_tcp->ppt_buffer, (unsigned long )l_tcp->ppt_len);
#line 3755
    new_ppt_buffer = (OPJ_BYTE *)__cil_tmp13;
    }
#line 3756
    if (! new_ppt_buffer) {
      {
#line 3757
      free((void *)l_tcp->ppt_buffer);
#line 3758
      l_tcp->ppt_buffer = (OPJ_BYTE *)((void *)0);
#line 3759
      l_tcp->ppt_len = (OPJ_UINT32 )0;
#line 3760
      opj_event_msg(p_manager, 1, "Not enough memory to read PPT marker\n");
      }
#line 3761
      return (0);
    }
    {
#line 3763
    l_tcp->ppt_buffer = new_ppt_buffer;
#line 3764
    l_tcp->ppt_data = l_tcp->ppt_buffer;
#line 3766
    memset((void *)(l_tcp->ppt_buffer + l_tcp->ppt_data_size), 0, (unsigned long )p_header_size);
    }
  }
  {
#line 3770
  memcpy((void *)(l_tcp->ppt_buffer + l_tcp->ppt_data_size), (void const   *)p_header_data,
         (unsigned long )p_header_size);
#line 3772
  l_tcp->ppt_data_size += p_header_size;
  }
#line 3774
  return (1);
}
}
#line 3777 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_tlm(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 l_tlm_size ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp10 ;
  OPJ_SIZE_T __cil_tmp12 ;

  {
#line 3782
  l_current_data = (OPJ_BYTE *)0;
#line 3790
  l_tlm_size = 6U + 5U * p_j2k->m_specific_param.m_encoder.m_total_tile_parts;
#line 3792
  if (l_tlm_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 3793
    __cil_tmp10 = realloc((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                          (unsigned long )l_tlm_size);
#line 3793
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp10;
    }
#line 3794
    if (! new_header_tile_data) {
      {
#line 3795
      free((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 3796
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 3797
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 3798
      opj_event_msg(p_manager, 1, "Not enough memory to write TLM marker\n");
      }
#line 3799
      return (0);
    }
#line 3801
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 3802
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_tlm_size;
  }
  {
#line 3805
  l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 3809
  p_j2k->m_specific_param.m_encoder.m_tlm_start = opj_stream_tell(p_stream);
#line 3811
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65365, (OPJ_UINT32 )2);
#line 3812
  l_current_data += 2;
#line 3814
  opj_write_bytes_LE(l_current_data, l_tlm_size - 2U, (OPJ_UINT32 )2);
#line 3815
  l_current_data += 2;
#line 3817
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )0, (OPJ_UINT32 )1);
#line 3818
  l_current_data ++;
#line 3820
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )80, (OPJ_UINT32 )1);
#line 3821
  l_current_data ++;
#line 3824
  __cil_tmp12 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_tlm_size, p_manager);
  }
#line 3824
  if (__cil_tmp12 != (unsigned long )l_tlm_size) {
#line 3825
    return (0);
  }
#line 3828
  return (1);
}
}
#line 3831 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_sot(opj_j2k_t *p_j2k , OPJ_BYTE *p_data , OPJ_UINT32 *p_data_written ,
                           opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) 
{ 


  {
  {
#line 3843
  opj_write_bytes_LE(p_data, (OPJ_UINT32 )65424, (OPJ_UINT32 )2);
#line 3844
  p_data += 2;
#line 3846
  opj_write_bytes_LE(p_data, (OPJ_UINT32 )10, (OPJ_UINT32 )2);
#line 3847
  p_data += 2;
#line 3849
  opj_write_bytes_LE(p_data, p_j2k->m_current_tile_number, (OPJ_UINT32 )2);
#line 3850
  p_data += 2;
#line 3853
  p_data += 4;
#line 3855
  opj_write_bytes_LE(p_data, p_j2k->m_specific_param.m_encoder.m_current_tile_part_number,
                     (OPJ_UINT32 )1);
#line 3856
  p_data ++;
#line 3858
  opj_write_bytes_LE(p_data, (p_j2k->m_cp.tcps + p_j2k->m_current_tile_number)->m_nb_tile_parts,
                     (OPJ_UINT32 )1);
#line 3859
  p_data ++;
#line 3870
  *p_data_written = (OPJ_UINT32 )12;
  }
#line 3872
  return (1);
}
}
#line 3875 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_read_sot(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                          opj_event_mgr_t *p_manager ) 
{ 
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 l_tot_len ;
  OPJ_UINT32 l_num_parts ;
  OPJ_UINT32 l_current_part ;
  OPJ_UINT32 l_tile_x ;
  OPJ_UINT32 l_tile_y ;
  void *__cil_tmp17 ;
  opj_tp_index_t *new_tp_index ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  opj_tp_index_t *new_tp_index___0 ;
  void *__cil_tmp22 ;
  int tmp___4 ;

  {
#line 3880
  l_cp = (opj_cp_t *)0;
#line 3881
  l_tcp = (opj_tcp_t *)0;
#line 3882
  l_num_parts = (OPJ_UINT32 )0;
#line 3892
  if (p_header_size != 8U) {
    {
#line 3893
    opj_event_msg(p_manager, 1, "Error reading SOT marker\n");
    }
#line 3894
    return (0);
  }
  {
#line 3897
  l_cp = & p_j2k->m_cp;
#line 3898
  opj_read_bytes_LE(p_header_data, & p_j2k->m_current_tile_number, (OPJ_UINT32 )2);
#line 3899
  p_header_data += 2;
#line 3901
  l_tcp = l_cp->tcps + p_j2k->m_current_tile_number;
#line 3902
  l_tile_x = p_j2k->m_current_tile_number % l_cp->tw;
#line 3903
  l_tile_y = p_j2k->m_current_tile_number / l_cp->tw;
#line 3936
  opj_read_bytes_LE(p_header_data, & l_tot_len, (OPJ_UINT32 )4);
#line 3937
  p_header_data += 4;
  }
#line 3940
  if (l_tot_len != 0U) {
#line 3940
    if (l_tot_len < 14U) {
#line 3942
      if (l_tot_len == 12U) {
        {
#line 3944
        opj_event_msg(p_manager, 2, "Empty SOT marker detected: Psot=%d.\n", l_tot_len);
        }
      } else {
        {
#line 3948
        opj_event_msg(p_manager, 1, "Psot value is not correct regards to the JPEG2000 norm: %d.\n",
                      l_tot_len);
        }
#line 3949
        return (0);
      }
    }
  }
#line 3975
  if (! l_tot_len) {
    {
#line 3976
    opj_event_msg(p_manager, 4, "Psot value of the current tile-part is equal to zero, we assuming it is the last tile-part of the codestream.\n");
#line 3978
    p_j2k->m_specific_param.m_decoder.m_last_tile_part = 1;
    }
  }
  {
#line 3981
  opj_read_bytes_LE(p_header_data, & l_current_part, (OPJ_UINT32 )1);
#line 3982
  p_header_data ++;
#line 3984
  opj_read_bytes_LE(p_header_data, & l_num_parts, (OPJ_UINT32 )1);
#line 3985
  p_header_data ++;
  }
#line 3987
  if (l_num_parts != 0U) {
#line 3990
    if (l_tcp->m_nb_tile_parts) {
#line 3991
      if (l_current_part >= l_tcp->m_nb_tile_parts) {
        {
#line 3992
        opj_event_msg(p_manager, 1, "In SOT marker, TPSot (%d) is not valid regards to the current number of tile-part (%d), giving up\n",
                      l_current_part, l_tcp->m_nb_tile_parts);
#line 3994
        p_j2k->m_specific_param.m_decoder.m_last_tile_part = 1;
        }
#line 3995
        return (0);
      }
    }
#line 3998
    l_tcp->m_nb_tile_parts = l_num_parts;
  }
#line 4002
  if (l_tcp->m_nb_tile_parts) {
#line 4003
    if (l_tcp->m_nb_tile_parts == l_current_part + 1U) {
#line 4004
      p_j2k->m_specific_param.m_decoder.m_can_decode = (OPJ_UINT32 )1;
    }
  }
#line 4008
  if (! p_j2k->m_specific_param.m_decoder.m_last_tile_part) {
#line 4010
    p_j2k->m_specific_param.m_decoder.m_sot_length = l_tot_len - 12U;
  } else {
#line 4014
    p_j2k->m_specific_param.m_decoder.m_sot_length = (OPJ_UINT32 )0;
  }
#line 4017
  p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )16;
#line 4020
  if (p_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec == -1) {
#line 4021
    if (l_tile_x < p_j2k->m_specific_param.m_decoder.m_start_tile_x) {
#line 4021
      tmp___4 = 1;
    } else
#line 4021
    if (l_tile_x >= p_j2k->m_specific_param.m_decoder.m_end_tile_x) {
#line 4021
      tmp___4 = 1;
    } else
#line 4021
    if (l_tile_y < p_j2k->m_specific_param.m_decoder.m_start_tile_y) {
#line 4021
      tmp___4 = 1;
    } else
#line 4021
    if (l_tile_y >= p_j2k->m_specific_param.m_decoder.m_end_tile_y) {
#line 4021
      tmp___4 = 1;
    } else {
#line 4021
      tmp___4 = 0;
    }
#line 4021
    p_j2k->m_specific_param.m_decoder.m_skip_data = (OPJ_UINT32 )tmp___4;
  } else {
#line 4029
    p_j2k->m_specific_param.m_decoder.m_skip_data = (OPJ_UINT32 )(p_j2k->m_current_tile_number != (OPJ_UINT32 )p_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec);
  }
#line 4034
  if (p_j2k->cstr_index) {
#line 4037
    ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tileno = p_j2k->m_current_tile_number;
#line 4038
    ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->current_tpsno = l_current_part;
#line 4040
    if (l_num_parts != 0U) {
#line 4041
      ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->nb_tps = l_num_parts;
#line 4042
      ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->current_nb_tps = l_num_parts;
#line 4044
      if (! ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index) {
        {
#line 4045
        __cil_tmp17 = calloc((unsigned long )l_num_parts, sizeof(opj_tp_index_t ));
#line 4045
        ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index = (opj_tp_index_t *)__cil_tmp17;
        }
      } else {
        {
#line 4049
        __cil_tmp19 = realloc((void *)((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index,
                              (unsigned long )l_num_parts * sizeof(opj_tp_index_t ));
#line 4049
        new_tp_index = (opj_tp_index_t *)__cil_tmp19;
        }
#line 4051
        if (! new_tp_index) {
          {
#line 4052
          free((void *)((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index);
#line 4053
          ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index = (opj_tp_index_t *)((void *)0);
#line 4054
          opj_event_msg(p_manager, 1, "Not enough memory to read PPT marker\n");
          }
#line 4055
          return (0);
        }
#line 4057
        ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index = new_tp_index;
      }
    } else {
#line 4063
      if (! ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index) {
        {
#line 4064
        ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->current_nb_tps = (OPJ_UINT32 )10;
#line 4065
        __cil_tmp20 = calloc((unsigned long )((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->current_nb_tps,
                             sizeof(opj_tp_index_t ));
#line 4065
        ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index = (opj_tp_index_t *)__cil_tmp20;
        }
      }
#line 4070
      if (l_current_part >= ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->current_nb_tps) {
        {
#line 4072
        ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->current_nb_tps += 10U;
#line 4073
        __cil_tmp22 = realloc((void *)((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index,
                              (unsigned long )((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->current_nb_tps * sizeof(opj_tp_index_t ));
#line 4073
        new_tp_index___0 = (opj_tp_index_t *)__cil_tmp22;
        }
#line 4076
        if (! new_tp_index___0) {
          {
#line 4077
          free((void *)((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index);
#line 4078
          ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index = (opj_tp_index_t *)((void *)0);
#line 4079
          ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->current_nb_tps = (OPJ_UINT32 )0;
#line 4080
          opj_event_msg(p_manager, 1, "Not enough memory to read PPT marker\n");
          }
#line 4081
          return (0);
        }
#line 4083
        ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index = new_tp_index___0;
      }
    }
  }
#line 4118
  return (1);
}
}
#line 4121 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_sod(opj_j2k_t *p_j2k , opj_tcd_t *p_tile_coder , OPJ_BYTE *p_data ,
                           OPJ_UINT32 *p_data_written , OPJ_UINT32 p_total_data_size ,
                           opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) 
{ 
  opj_codestream_info_t *l_cstr_info ;
  OPJ_UINT32 l_remaining_data ;
  OPJ_BOOL __cil_tmp13 ;

  {
  {
#line 4130
  l_cstr_info = (opj_codestream_info_t *)0;
#line 4138
  opj_write_bytes_LE(p_data, (OPJ_UINT32 )65427, (OPJ_UINT32 )2);
#line 4139
  p_data += 2;
#line 4142
  l_remaining_data = p_total_data_size - 4U;
#line 4145
  p_tile_coder->tp_num = p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number;
#line 4146
  p_tile_coder->cur_tp_num = p_j2k->m_specific_param.m_encoder.m_current_tile_part_number;
  }
#line 4176
  if (p_j2k->m_specific_param.m_encoder.m_current_tile_part_number == 0U) {
#line 4177
    ((p_tile_coder->tcd_image)->tiles)->packno = (OPJ_UINT32 )0;
#line 4178
    if (l_cstr_info) {
#line 4179
      l_cstr_info->packno = 0;
    }
  }
  {
#line 4183
  *p_data_written = (OPJ_UINT32 )0;
#line 4185
  __cil_tmp13 = opj_tcd_encode_tile(p_tile_coder, p_j2k->m_current_tile_number, p_data,
                                    p_data_written, l_remaining_data, l_cstr_info);
  }
#line 4185
  if (! __cil_tmp13) {
    {
#line 4186
    opj_event_msg(p_manager, 1, "Cannot encode tile\n");
    }
#line 4187
    return (0);
  }
#line 4190
  *p_data_written += 2U;
#line 4192
  return (1);
}
}
#line 4195 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_read_sod(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_current_read_size ;
  opj_codestream_index_t *l_cstr_index ;
  OPJ_BYTE **l_current_data ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 *l_tile_len ;
  OPJ_BOOL l_sot_length_pb_detected ;
  OPJ_OFF_T __cil_tmp13 ;
  void *__cil_tmp14 ;
  OPJ_BYTE *l_new_current_data ;
  void *__cil_tmp16 ;
  OPJ_OFF_T l_current_pos ;
  OPJ_OFF_T __cil_tmp18 ;
  OPJ_UINT32 l_current_tile_part ;
  OPJ_BOOL __cil_tmp20 ;
  OPJ_SIZE_T __cil_tmp21 ;

  {
#line 4201
  l_cstr_index = (opj_codestream_index_t *)0;
#line 4202
  l_current_data = (OPJ_BYTE **)0;
#line 4203
  l_tcp = (opj_tcp_t *)0;
#line 4204
  l_tile_len = (OPJ_UINT32 *)0;
#line 4205
  l_sot_length_pb_detected = 0;
#line 4212
  l_tcp = p_j2k->m_cp.tcps + p_j2k->m_current_tile_number;
#line 4214
  if (p_j2k->m_specific_param.m_decoder.m_last_tile_part) {
    {
#line 4219
    __cil_tmp13 = opj_stream_get_number_byte_left(p_stream);
#line 4219
    p_j2k->m_specific_param.m_decoder.m_sot_length = (OPJ_UINT32 )(__cil_tmp13 - 2L);
    }
  } else
#line 4223
  if (p_j2k->m_specific_param.m_decoder.m_sot_length >= 2U) {
#line 4224
    p_j2k->m_specific_param.m_decoder.m_sot_length -= 2U;
  }
#line 4230
  l_current_data = & l_tcp->m_data;
#line 4231
  l_tile_len = & l_tcp->m_data_size;
#line 4234
  if (p_j2k->m_specific_param.m_decoder.m_sot_length) {
#line 4235
    if (! *l_current_data) {
      {
#line 4239
      __cil_tmp14 = malloc((unsigned long )p_j2k->m_specific_param.m_decoder.m_sot_length);
#line 4239
      *l_current_data = (OPJ_BYTE *)__cil_tmp14;
      }
    } else {
      {
#line 4242
      __cil_tmp16 = realloc((void *)*l_current_data, (unsigned long )(*l_tile_len + p_j2k->m_specific_param.m_decoder.m_sot_length));
#line 4242
      l_new_current_data = (OPJ_BYTE *)__cil_tmp16;
      }
#line 4243
      if (! l_new_current_data) {
        {
#line 4244
        free((void *)*l_current_data);
        }
      }
#line 4250
      *l_current_data = l_new_current_data;
    }
#line 4253
    if ((unsigned long )*l_current_data == (unsigned long )((OPJ_BYTE *)0)) {
      {
#line 4254
      opj_event_msg(p_manager, 1, "Not enough memory to decode tile\n");
      }
#line 4255
      return (0);
    }
  } else {
#line 4259
    l_sot_length_pb_detected = 1;
  }
#line 4263
  l_cstr_index = p_j2k->cstr_index;
#line 4264
  if (l_cstr_index) {
    {
#line 4265
    __cil_tmp18 = opj_stream_tell(p_stream);
#line 4265
    l_current_pos = __cil_tmp18 - 2L;
#line 4267
    l_current_tile_part = (l_cstr_index->tile_index + p_j2k->m_current_tile_number)->current_tpsno;
#line 4268
    ((l_cstr_index->tile_index + p_j2k->m_current_tile_number)->tp_index + l_current_tile_part)->end_header = l_current_pos;
#line 4270
    ((l_cstr_index->tile_index + p_j2k->m_current_tile_number)->tp_index + l_current_tile_part)->end_pos = (l_current_pos + (long )p_j2k->m_specific_param.m_decoder.m_sot_length) + 2L;
#line 4273
    __cil_tmp20 = opj_j2k_add_tlmarker(p_j2k->m_current_tile_number, l_cstr_index,
                                       (OPJ_UINT32 )65427, l_current_pos, p_j2k->m_specific_param.m_decoder.m_sot_length + 2U);
    }
#line 4273
    if (0 == __cil_tmp20) {
      {
#line 4278
      opj_event_msg(p_manager, 1, "Not enough memory to add tl marker\n\211\202U");
      }
#line 4279
      return (0);
    }
  }
#line 4286
  if (! l_sot_length_pb_detected) {
    {
#line 4287
    __cil_tmp21 = opj_stream_read_data(p_stream, *l_current_data + *l_tile_len, (OPJ_SIZE_T )p_j2k->m_specific_param.m_decoder.m_sot_length,
                                       p_manager);
#line 4287
    l_current_read_size = (OPJ_UINT32 )__cil_tmp21;
    }
  } else {
#line 4295
    l_current_read_size = (OPJ_UINT32 )0;
  }
#line 4298
  if (l_current_read_size != p_j2k->m_specific_param.m_decoder.m_sot_length) {
#line 4299
    p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )64;
  } else {
#line 4302
    p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )8;
  }
#line 4305
  *l_tile_len += l_current_read_size;
#line 4307
  return (1);
}
}
#line 4310 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_rgn(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no , OPJ_UINT32 p_comp_no ,
                           OPJ_UINT32 nb_comps , opj_stream_private_t *p_stream ,
                           opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 l_rgn_size ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;
  OPJ_UINT32 l_comp_room ;
  OPJ_SIZE_T __cil_tmp16 ;

  {
#line 4318
  l_current_data = (OPJ_BYTE *)0;
#line 4320
  l_cp = (opj_cp_t *)0;
#line 4321
  l_tcp = (opj_tcp_t *)0;
#line 4322
  l_tccp = (opj_tccp_t *)0;
#line 4330
  l_cp = & p_j2k->m_cp;
#line 4331
  l_tcp = l_cp->tcps + p_tile_no;
#line 4332
  l_tccp = l_tcp->tccps + p_comp_no;
#line 4334
  if (nb_comps <= 256U) {
#line 4335
    l_comp_room = (OPJ_UINT32 )1;
  } else {
#line 4338
    l_comp_room = (OPJ_UINT32 )2;
  }
  {
#line 4341
  l_rgn_size = 6U + l_comp_room;
#line 4343
  l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 4345
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65374, (OPJ_UINT32 )2);
#line 4346
  l_current_data += 2;
#line 4348
  opj_write_bytes_LE(l_current_data, l_rgn_size - 2U, (OPJ_UINT32 )2);
#line 4349
  l_current_data += 2;
#line 4351
  opj_write_bytes_LE(l_current_data, p_comp_no, l_comp_room);
#line 4352
  l_current_data += l_comp_room;
#line 4354
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )0, (OPJ_UINT32 )1);
#line 4355
  l_current_data ++;
#line 4357
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )l_tccp->roishift, (OPJ_UINT32 )1);
#line 4358
  l_current_data ++;
#line 4360
  __cil_tmp16 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_rgn_size, p_manager);
  }
#line 4360
  if (__cil_tmp16 != (unsigned long )l_rgn_size) {
#line 4361
    return (0);
  }
#line 4364
  return (1);
}
}
#line 4367 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_eoc(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_SIZE_T __cil_tmp7 ;
  OPJ_BOOL __cil_tmp8 ;

  {
  {
#line 4377
  opj_write_bytes_LE(p_j2k->m_specific_param.m_encoder.m_header_tile_data, (OPJ_UINT32 )65497,
                     (OPJ_UINT32 )2);
#line 4387
  __cil_tmp7 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                     (OPJ_SIZE_T )2, p_manager);
  }
#line 4387
  if (__cil_tmp7 != 2UL) {
#line 4388
    return (0);
  }
  {
#line 4391
  __cil_tmp8 = opj_stream_flush(p_stream, p_manager);
  }
#line 4391
  if (! __cil_tmp8) {
#line 4392
    return (0);
  }
#line 4395
  return (1);
}
}
#line 4406 "/root/patron/new_22/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_rgn(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_nb_comp ;
  opj_image_t *l_image ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 l_comp_room ;
  OPJ_UINT32 l_comp_no ;
  OPJ_UINT32 l_roi_sty ;
  opj_tcp_t *tmp___2 ;

  {
#line 4413
  l_image = (opj_image_t *)0;
#line 4415
  l_cp = (opj_cp_t *)0;
#line 4416
  l_tcp = (opj_tcp_t *)0;
#line 4424
  l_image = p_j2k->m_private_image;
#line 4425
  l_nb_comp = l_image->numcomps;
#line 4427
  if (l_nb_comp <= 256U) {
#line 4428
    l_comp_room = (OPJ_UINT32 )1;
  } else {
#line 4430
    l_comp_room = (OPJ_UINT32 )2;
  }
#line 4432
  if (p_header_size != 2U + l_comp_room) {
    {
#line 4433
    opj_event_msg(p_manager, 1, "Error reading RGN marker\n");
    }
#line 4434
    return (0);
  }
#line 4437
  l_cp = & p_j2k->m_cp;
#line 4438
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 4438
    tmp___2 = l_cp->tcps + p_j2k->m_current_tile_number;
  } else {
#line 4438
    tmp___2 = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
  {
#line 4438
  l_tcp = tmp___2;
#line 4442
  opj_read_bytes_LE(p_header_data, & l_comp_no, l_comp_room);
#line 4443
  p_header_data += l_comp_room;
#line 4444
  opj_read_bytes_LE(p_header_data, & l_roi_sty, (OPJ_UINT32 )1);
#line 4445
  p_header_data ++;
#line 4462
  opj_read_bytes_LE(p_header_data, (OPJ_UINT32 *)(& (l_tcp->tccps + l_comp_no)->roishift),
                    (OPJ_UINT32 )1);
#line 4463
  p_header_data ++;
  }
#line 4465
  return (1);
}
}
#line 4469 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_FLOAT32 opj_j2k_get_tp_stride(opj_tcp_t *p_tcp ) 
{ 


  {
#line 4471
  return ((OPJ_FLOAT32 )((p_tcp->m_nb_tile_parts - 1U) * 14U));
}
}
#line 4474 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_FLOAT32 opj_j2k_get_default_stride(opj_tcp_t *p_tcp ) 
{ 


  {
#line 4477
  return ((OPJ_FLOAT32 )0);
}
}
#line 4480 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_update_rates(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                              opj_event_mgr_t *p_manager ) 
{ 
  opj_cp_t *l_cp ;
  opj_image_t *l_image ;
  opj_tcp_t *l_tcp ;
  opj_image_comp_t *l_img_comp ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  OPJ_INT32 l_x0 ;
  OPJ_INT32 l_y0 ;
  OPJ_INT32 l_x1 ;
  OPJ_INT32 l_y1 ;
  OPJ_FLOAT32 *l_rates ;
  OPJ_FLOAT32 l_sot_remove ;
  OPJ_UINT32 l_bits_empty ;
  OPJ_UINT32 l_size_pixel ;
  OPJ_UINT32 l_tile_size ;
  OPJ_UINT32 l_last_res ;
  OPJ_FLOAT32 (*l_tp_stride_func)(opj_tcp_t * ) ;
  OPJ_OFF_T __cil_tmp25 ;
  OPJ_FLOAT32 l_offset ;
  OPJ_FLOAT32 __cil_tmp27 ;
  OPJ_UINT32 __cil_tmp32 ;
  OPJ_UINT32 __cil_tmp33 ;
  OPJ_UINT32 __cil_tmp34 ;
  void *__cil_tmp35 ;
  void *__cil_tmp36 ;

  {
  {
#line 4484
  l_cp = (opj_cp_t *)0;
#line 4485
  l_image = (opj_image_t *)0;
#line 4486
  l_tcp = (opj_tcp_t *)0;
#line 4487
  l_img_comp = (opj_image_comp_t *)0;
#line 4491
  l_rates = (OPJ_FLOAT32 *)0;
#line 4494
  l_tile_size = (OPJ_UINT32 )0;
#line 4496
  l_tp_stride_func = (OPJ_FLOAT32 (*)(opj_tcp_t * ))0;
#line 4503
  l_cp = & p_j2k->m_cp;
#line 4504
  l_image = p_j2k->m_private_image;
#line 4505
  l_tcp = l_cp->tcps;
#line 4507
  l_bits_empty = (8U * (l_image->comps)->dx) * (l_image->comps)->dy;
#line 4508
  l_size_pixel = l_image->numcomps * (l_image->comps)->prec;
#line 4509
  __cil_tmp25 = opj_stream_tell(p_stream);
#line 4509
  l_sot_remove = (OPJ_FLOAT32 )__cil_tmp25 / (float )(l_cp->th * l_cp->tw);
  }
#line 4511
  if (l_cp->m_specific_param.m_enc.m_tp_on) {
#line 4512
    l_tp_stride_func = & opj_j2k_get_tp_stride;
  } else {
#line 4515
    l_tp_stride_func = & opj_j2k_get_default_stride;
  }
#line 4518
  i = (OPJ_UINT32 )0;
  {
#line 4518
  while (1) {
    while_continue: /* CIL Label */ ;

#line 4518
    if (! (i < l_cp->th)) {
#line 4518
      goto while_break;
    }
#line 4519
    j = (OPJ_UINT32 )0;
    {
#line 4519
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 4519
      if (! (j < l_cp->tw)) {
#line 4519
        goto while_break___0;
      }
      {
#line 4520
      __cil_tmp27 = (*l_tp_stride_func)(l_tcp);
#line 4520
      l_offset = __cil_tmp27 / (float )l_tcp->numlayers;
#line 4523
      l_x0 = opj_int_max((OPJ_INT32 )(l_cp->tx0 + j * l_cp->tdx), (OPJ_INT32 )l_image->x0);
#line 4524
      l_y0 = opj_int_max((OPJ_INT32 )(l_cp->ty0 + i * l_cp->tdy), (OPJ_INT32 )l_image->y0);
#line 4525
      l_x1 = opj_int_min((OPJ_INT32 )(l_cp->tx0 + (j + 1U) * l_cp->tdx), (OPJ_INT32 )l_image->x1);
#line 4526
      l_y1 = opj_int_min((OPJ_INT32 )(l_cp->ty0 + (i + 1U) * l_cp->tdy), (OPJ_INT32 )l_image->y1);
#line 4528
      l_rates = l_tcp->rates;
      }
#line 4531
      if (*l_rates) {
#line 4532
        *l_rates = (OPJ_FLOAT32 )((l_size_pixel * (unsigned int )(l_x1 - l_x0)) * (unsigned int )(l_y1 - l_y0)) / (*l_rates * (float )l_bits_empty) - l_offset;
      }
#line 4540
      l_rates ++;
#line 4542
      k = (OPJ_UINT32 )1;
      {
#line 4542
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 4542
        if (! (k < l_tcp->numlayers)) {
#line 4542
          goto while_break___1;
        }
#line 4543
        if (*l_rates) {
#line 4544
          *l_rates = (OPJ_FLOAT32 )((l_size_pixel * (unsigned int )(l_x1 - l_x0)) * (unsigned int )(l_y1 - l_y0)) / (*l_rates * (float )l_bits_empty) - l_offset;
        }
#line 4552
        l_rates ++;
#line 4542
        k ++;
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___1: 
#line 4555
      l_tcp ++;
#line 4519
      j ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___0: 
#line 4518
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break: 
#line 4560
  l_tcp = l_cp->tcps;
#line 4562
  i = (OPJ_UINT32 )0;
  {
#line 4562
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 4562
    if (! (i < l_cp->th)) {
#line 4562
      goto while_break___2;
    }
#line 4563
    j = (OPJ_UINT32 )0;
    {
#line 4563
    while (1) {
      while_continue___3: /* CIL Label */ ;

#line 4563
      if (! (j < l_cp->tw)) {
#line 4563
        goto while_break___3;
      }
#line 4564
      l_rates = l_tcp->rates;
#line 4566
      if (*l_rates) {
#line 4567
        *l_rates -= l_sot_remove;
#line 4569
        if (*l_rates < (float )30) {
#line 4570
          *l_rates = (OPJ_FLOAT32 )30;
        }
      }
#line 4574
      l_rates ++;
#line 4576
      l_last_res = l_tcp->numlayers - 1U;
#line 4578
      k = (OPJ_UINT32 )1;
      {
#line 4578
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 4578
        if (! (k < l_last_res)) {
#line 4578
          goto while_break___4;
        }
#line 4580
        if (*l_rates) {
#line 4581
          *l_rates -= l_sot_remove;
#line 4583
          if (*l_rates < *(l_rates - 1) + (float )10) {
#line 4584
            *l_rates = *(l_rates - 1) + (float )20;
          }
        }
#line 4588
        l_rates ++;
#line 4578
        k ++;
      }
      while_break___11: /* CIL Label */ ;
      }
      while_break___4: ;
#line 4591
      if (*l_rates) {
#line 4592
        *l_rates -= l_sot_remove + 2.f;
#line 4594
        if (*l_rates < *(l_rates - 1) + (float )10) {
#line 4595
          *l_rates = *(l_rates - 1) + (float )20;
        }
      }
#line 4599
      l_tcp ++;
#line 4563
      j ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___3: 
#line 4562
    i ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break___2: 
#line 4603
  l_img_comp = l_image->comps;
#line 4604
  l_tile_size = (OPJ_UINT32 )0;
#line 4606
  i = (OPJ_UINT32 )0;
  {
#line 4606
  while (1) {
    while_continue___5: /* CIL Label */ ;

#line 4606
    if (! (i < l_image->numcomps)) {
#line 4606
      goto while_break___5;
    }
    {
#line 4607
    __cil_tmp33 = opj_uint_ceildiv(l_cp->tdy, l_img_comp->dy);
#line 4607
    __cil_tmp32 = opj_uint_ceildiv(l_cp->tdx, l_img_comp->dx);
#line 4607
    l_tile_size += (__cil_tmp32 * __cil_tmp33) * l_img_comp->prec;
#line 4614
    l_img_comp ++;
#line 4606
    i ++;
    }
  }
  while_break___12: /* CIL Label */ ;
  }
  while_break___5: 
  {
#line 4617
  l_tile_size = (OPJ_UINT32 )((double )l_tile_size * 0.162500000001);
#line 4619
  __cil_tmp34 = opj_j2k_get_specific_header_sizes(p_j2k);
#line 4619
  l_tile_size += __cil_tmp34;
#line 4621
  p_j2k->m_specific_param.m_encoder.m_encoded_tile_size = l_tile_size;
#line 4622
  __cil_tmp35 = malloc((unsigned long )p_j2k->m_specific_param.m_encoder.m_encoded_tile_size);
#line 4622
  p_j2k->m_specific_param.m_encoder.m_encoded_tile_data = (OPJ_BYTE *)__cil_tmp35;
  }
#line 4624
  if ((unsigned long )p_j2k->m_specific_param.m_encoder.m_encoded_tile_data == (unsigned long )((OPJ_BYTE *)0)) {
#line 4625
    return (0);
  }
#line 4628
  if (l_cp->m_specific_param.m_enc.m_cinema) {
    {
#line 4629
    __cil_tmp36 = malloc((unsigned long )(5U * p_j2k->m_specific_param.m_encoder.m_total_tile_parts));
#line 4629
    p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer = (OPJ_BYTE *)__cil_tmp36;
    }
#line 4631
    if (! p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer) {
#line 4632
      return (0);
    }
#line 4635
    p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current = p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer;
  }
#line 4639
  return (1);
}
}
#line 4642 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_read_eoc(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  opj_tcd_t *l_tcd ;
  OPJ_UINT32 l_nb_tiles ;
  opj_tcp_t *l_tcp ;
  OPJ_BOOL l_success ;
  OPJ_BOOL __cil_tmp13 ;

  {
  {
#line 4647
  l_tcd = (opj_tcd_t *)0;
#line 4649
  l_tcp = (opj_tcp_t *)0;
#line 4657
  l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;
#line 4658
  l_tcp = p_j2k->m_cp.tcps;
#line 4660
  l_tcd = opj_tcd_create(1);
  }
#line 4661
  if ((unsigned long )l_tcd == (unsigned long )((opj_tcd_t *)0)) {
    {
#line 4662
    opj_event_msg(p_manager, 1, "Cannot decode tile, memory error\n\374\313\211\202U");
    }
#line 4663
    return (0);
  }
#line 4666
  i = (OPJ_UINT32 )0;
  {
#line 4666
  while (1) {
    while_continue: /* CIL Label */ ;

#line 4666
    if (! (i < l_nb_tiles)) {
#line 4666
      goto while_break;
    }
#line 4667
    if (l_tcp->m_data) {
      {
#line 4668
      __cil_tmp13 = opj_tcd_init_decode_tile(l_tcd, i);
      }
#line 4668
      if (! __cil_tmp13) {
        {
#line 4669
        opj_tcd_destroy(l_tcd);
#line 4670
        opj_event_msg(p_manager, 1, "Cannot decode tile, memory error\n");
        }
#line 4671
        return (0);
      }
      {
#line 4674
      l_success = opj_tcd_decode_tile(l_tcd, l_tcp->m_data, l_tcp->m_data_size, i,
                                      p_j2k->cstr_index);
      }
#line 4677
      if (! l_success) {
#line 4678
        p_j2k->m_specific_param.m_decoder.m_state |= 32768U;
#line 4679
        goto while_break;
      }
    }
    {
#line 4683
    opj_j2k_tcp_destroy(l_tcp);
#line 4684
    l_tcp ++;
#line 4666
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 4687
  opj_tcd_destroy(l_tcd);
  }
#line 4688
  return (1);
}
}
#line 4691 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_get_end_header(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                struct opj_event_mgr *p_manager ) 
{ 


  {
  {
#line 4700
  (p_j2k->cstr_index)->main_head_end = opj_stream_tell(p_stream);
  }
#line 4702
  return (1);
}
}
#line 4705 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_mct_data_group(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                      struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 i ;
  opj_simple_mcc_decorrelation_data_t *l_mcc_record ;
  opj_mct_data_t *l_mct_record ;
  opj_tcp_t *l_tcp ;
  OPJ_BOOL __cil_tmp11 ;
  OPJ_BOOL __cil_tmp12 ;
  OPJ_BOOL __cil_tmp13 ;
  OPJ_BOOL __cil_tmp14 ;

  {
  {
#line 4719
  __cil_tmp11 = opj_j2k_write_cbd(p_j2k, p_stream, p_manager);
  }
#line 4719
  if (! __cil_tmp11) {
#line 4720
    return (0);
  }
#line 4723
  l_tcp = p_j2k->m_cp.tcps + p_j2k->m_current_tile_number;
#line 4724
  l_mct_record = l_tcp->m_mct_records;
#line 4726
  i = (OPJ_UINT32 )0;
  {
#line 4726
  while (1) {
    while_continue: /* CIL Label */ ;

#line 4726
    if (! (i < l_tcp->m_nb_mct_records)) {
#line 4726
      goto while_break;
    }
    {
#line 4728
    __cil_tmp12 = opj_j2k_write_mct_record(p_j2k, l_mct_record, p_stream, p_manager);
    }
#line 4728
    if (! __cil_tmp12) {
#line 4729
      return (0);
    }
#line 4732
    l_mct_record ++;
#line 4726
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
#line 4735
  l_mcc_record = l_tcp->m_mcc_records;
#line 4737
  i = (OPJ_UINT32 )0;
  {
#line 4737
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 4737
    if (! (i < l_tcp->m_nb_mcc_records)) {
#line 4737
      goto while_break___0;
    }
    {
#line 4739
    __cil_tmp13 = opj_j2k_write_mcc_record(p_j2k, l_mcc_record, p_stream, p_manager);
    }
#line 4739
    if (! __cil_tmp13) {
#line 4740
      return (0);
    }
#line 4743
    l_mcc_record ++;
#line 4737
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 4746
  __cil_tmp14 = opj_j2k_write_mco(p_j2k, p_stream, p_manager);
  }
#line 4746
  if (! __cil_tmp14) {
#line 4747
    return (0);
  }
#line 4750
  return (1);
}
}
#line 4753 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_all_coc(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                               struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_BOOL __cil_tmp8 ;

  {
#line 4764
  compno = (OPJ_UINT32 )0;
  {
#line 4764
  while (1) {
    while_continue: /* CIL Label */ ;

#line 4764
    if (! (compno < (p_j2k->m_private_image)->numcomps)) {
#line 4764
      goto while_break;
    }
    {
#line 4766
    __cil_tmp8 = opj_j2k_write_coc(p_j2k, compno, p_stream, p_manager);
    }
#line 4766
    if (! __cil_tmp8) {
#line 4767
      return (0);
    }
#line 4764
    compno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 4771
  return (1);
}
}
#line 4774 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_all_qcc(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                               struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_BOOL __cil_tmp8 ;

  {
#line 4785
  compno = (OPJ_UINT32 )0;
  {
#line 4785
  while (1) {
    while_continue: /* CIL Label */ ;

#line 4785
    if (! (compno < (p_j2k->m_private_image)->numcomps)) {
#line 4785
      goto while_break;
    }
    {
#line 4787
    __cil_tmp8 = opj_j2k_write_qcc(p_j2k, compno, p_stream, p_manager);
    }
#line 4787
    if (! __cil_tmp8) {
#line 4788
      return (0);
    }
#line 4785
    compno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 4792
  return (1);
}
}
#line 4796 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_regions(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                               struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 compno ;
  opj_tccp_t *l_tccp ;
  OPJ_BOOL __cil_tmp9 ;

  {
#line 4801
  l_tccp = (opj_tccp_t *)0;
#line 4808
  l_tccp = (p_j2k->m_cp.tcps)->tccps;
#line 4810
  compno = (OPJ_UINT32 )0;
  {
#line 4810
  while (1) {
    while_continue: /* CIL Label */ ;

#line 4810
    if (! (compno < (p_j2k->m_private_image)->numcomps)) {
#line 4810
      goto while_break;
    }
#line 4811
    if (l_tccp->roishift) {
      {
#line 4813
      __cil_tmp9 = opj_j2k_write_rgn(p_j2k, (OPJ_UINT32 )0, compno, (p_j2k->m_private_image)->numcomps,
                                     p_stream, p_manager);
      }
#line 4813
      if (! __cil_tmp9) {
#line 4814
        return (0);
      }
    }
#line 4818
    l_tccp ++;
#line 4810
    compno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 4821
  return (1);
}
}
#line 4824 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_epc(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                           struct opj_event_mgr *p_manager ) 
{ 
  opj_codestream_index_t *l_cstr_index ;
  OPJ_OFF_T __cil_tmp8 ;

  {
#line 4828
  l_cstr_index = (opj_codestream_index_t *)0;
#line 4835
  l_cstr_index = p_j2k->cstr_index;
#line 4836
  if (l_cstr_index) {
    {
#line 4837
    __cil_tmp8 = opj_stream_tell(p_stream);
#line 4837
    l_cstr_index->codestream_size = (OPJ_UINT64 )__cil_tmp8;
#line 4842
    l_cstr_index->codestream_size -= (unsigned long )l_cstr_index->main_head_start;
    }
  }
#line 4859
  return (1);
}
}
#line 4862 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_read_unk(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , OPJ_UINT32 *output_marker ,
                          opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_unknown_marker ;
  opj_dec_memory_marker_handler_t *l_marker_handler ;
  OPJ_UINT32 l_size_unk ;
  OPJ_SIZE_T __cil_tmp11 ;
  OPJ_BOOL res ;
  OPJ_OFF_T __cil_tmp14 ;
  OPJ_BOOL __cil_tmp15 ;

  {
  {
#line 4870
  l_size_unk = (OPJ_UINT32 )2;
#line 4877
  opj_event_msg(p_manager, 2, "Unknown marker\n");
  }
  {
#line 4879
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 4881
    __cil_tmp11 = opj_stream_read_data(p_stream, p_j2k->m_specific_param.m_decoder.m_header_data,
                                       (OPJ_SIZE_T )2, p_manager);
    }
#line 4881
    if (__cil_tmp11 != 2UL) {
      {
#line 4882
      opj_event_msg(p_manager, 1, "Stream too short\n");
      }
#line 4883
      return (0);
    }
    {
#line 4887
    opj_read_bytes_LE(p_j2k->m_specific_param.m_decoder.m_header_data, & l_unknown_marker,
                      (OPJ_UINT32 )2);
    }
#line 4889
    if (! (l_unknown_marker < 65280U)) {
      {
#line 4892
      l_marker_handler = opj_j2k_get_marker_handler(l_unknown_marker);
      }
#line 4894
      if (! (p_j2k->m_specific_param.m_decoder.m_state & l_marker_handler->states)) {
        {
#line 4895
        opj_event_msg(p_manager, 1, "Marker is not compliant with its position\n");
        }
#line 4896
        return (0);
      } else
#line 4899
      if (l_marker_handler->id != 0U) {
#line 4901
        if (l_marker_handler->id != 65424U) {
          {
#line 4903
          __cil_tmp14 = opj_stream_tell(p_stream);
#line 4903
          __cil_tmp15 = opj_j2k_add_mhmarker(p_j2k->cstr_index, (OPJ_UINT32 )0, (OPJ_OFF_T )((OPJ_UINT32 )__cil_tmp14 - l_size_unk),
                                             l_size_unk);
#line 4903
          res = __cil_tmp15;
          }
#line 4906
          if (res == 0) {
            {
#line 4907
            opj_event_msg(p_manager, 1, "Not enough memory to add mh marker\n");
            }
#line 4908
            return (0);
          }
        }
#line 4911
        goto while_break;
      } else {
#line 4914
        l_size_unk += 2U;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 4919
  *output_marker = l_marker_handler->id;
#line 4921
  return (1);
}
}
#line 4924 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_mct_record(opj_j2k_t *p_j2k , opj_mct_data_t *p_mct_record ,
                                  struct opj_stream_private *p_stream , struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 l_mct_size ;
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 l_tmp ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp12 ;
  OPJ_SIZE_T __cil_tmp13 ;

  {
#line 4930
  l_current_data = (OPJ_BYTE *)0;
#line 4938
  l_mct_size = 10U + p_mct_record->m_data_size;
#line 4940
  if (l_mct_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 4941
    __cil_tmp12 = realloc((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                          (unsigned long )l_mct_size);
#line 4941
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp12;
    }
#line 4942
    if (! new_header_tile_data) {
      {
#line 4943
      free((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 4944
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 4945
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 4946
      opj_event_msg(p_manager, 1, "Not enough memory to write MCT marker\n");
      }
#line 4947
      return (0);
    }
#line 4949
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 4950
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_mct_size;
  }
  {
#line 4953
  l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 4955
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65396, (OPJ_UINT32 )2);
#line 4956
  l_current_data += 2;
#line 4958
  opj_write_bytes_LE(l_current_data, l_mct_size - 2U, (OPJ_UINT32 )2);
#line 4959
  l_current_data += 2;
#line 4961
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )0, (OPJ_UINT32 )2);
#line 4962
  l_current_data += 2;
#line 4965
  l_tmp = ((p_mct_record->m_index & 255U) | ((unsigned int )p_mct_record->m_array_type << 8)) | ((unsigned int )p_mct_record->m_element_type << 10);
#line 4967
  opj_write_bytes_LE(l_current_data, l_tmp, (OPJ_UINT32 )2);
#line 4968
  l_current_data += 2;
#line 4970
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )0, (OPJ_UINT32 )2);
#line 4971
  l_current_data += 2;
#line 4973
  memcpy((void *)l_current_data, (void const   *)p_mct_record->m_data, (unsigned long )p_mct_record->m_data_size);
#line 4975
  __cil_tmp13 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_mct_size, p_manager);
  }
#line 4975
  if (__cil_tmp13 != (unsigned long )l_mct_size) {
#line 4976
    return (0);
  }
#line 4979
  return (1);
}
}
#line 4990 "/root/patron/new_22/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_mct(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 l_tmp ;
  OPJ_UINT32 l_indix ;
  opj_mct_data_t *l_mct_data ;
  opj_tcp_t *tmp___1 ;
  opj_mct_data_t *new_mct_records ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;

  {
#line 4997
  l_tcp = (opj_tcp_t *)0;
#line 5006
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 5006
    tmp___1 = p_j2k->m_cp.tcps + p_j2k->m_current_tile_number;
  } else {
#line 5006
    tmp___1 = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
#line 5006
  l_tcp = tmp___1;
#line 5010
  if (p_header_size < 2U) {
    {
#line 5011
    opj_event_msg(p_manager, 1, "Error reading MCT marker\n");
    }
#line 5012
    return (0);
  }
  {
#line 5016
  opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )2);
#line 5017
  p_header_data += 2;
  }
#line 5018
  if (l_tmp != 0U) {
    {
#line 5019
    opj_event_msg(p_manager, 2, "Cannot take in charge mct data within multiple MCT records\n");
    }
#line 5020
    return (1);
  }
#line 5023
  if (p_header_size <= 6U) {
    {
#line 5024
    opj_event_msg(p_manager, 1, "Error reading MCT marker\n");
    }
#line 5025
    return (0);
  }
  {
#line 5029
  opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )2);
#line 5030
  p_header_data += 2;
#line 5032
  l_indix = l_tmp & 255U;
#line 5033
  l_mct_data = l_tcp->m_mct_records;
#line 5035
  i = (OPJ_UINT32 )0;
  }
  {
#line 5035
  while (1) {
    while_continue: /* CIL Label */ ;

#line 5035
    if (! (i < l_tcp->m_nb_mct_records)) {
#line 5035
      goto while_break;
    }
#line 5036
    if (l_mct_data->m_index == l_indix) {
#line 5037
      goto while_break;
    }
#line 5039
    l_mct_data ++;
#line 5035
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 5043
  if (i == l_tcp->m_nb_mct_records) {
#line 5044
    if (l_tcp->m_nb_mct_records == l_tcp->m_nb_max_mct_records) {
      {
#line 5046
      l_tcp->m_nb_max_mct_records += 10U;
#line 5048
      __cil_tmp14 = realloc((void *)l_tcp->m_mct_records, (unsigned long )l_tcp->m_nb_max_mct_records * sizeof(opj_mct_data_t ));
#line 5048
      new_mct_records = (opj_mct_data_t *)__cil_tmp14;
      }
#line 5049
      if (! new_mct_records) {
        {
#line 5050
        free((void *)l_tcp->m_mct_records);
#line 5051
        l_tcp->m_mct_records = (opj_mct_data_t *)((void *)0);
#line 5052
        l_tcp->m_nb_max_mct_records = (OPJ_UINT32 )0;
#line 5053
        l_tcp->m_nb_mct_records = (OPJ_UINT32 )0;
#line 5054
        opj_event_msg(p_manager, 1, "Not enough memory to read MCT marker\n");
        }
#line 5055
        return (0);
      }
      {
#line 5057
      l_tcp->m_mct_records = new_mct_records;
#line 5058
      l_mct_data = l_tcp->m_mct_records + l_tcp->m_nb_mct_records;
#line 5059
      memset((void *)l_mct_data, 0, (unsigned long )(l_tcp->m_nb_max_mct_records - l_tcp->m_nb_mct_records) * sizeof(opj_mct_data_t ));
      }
    }
#line 5062
    l_mct_data = l_tcp->m_mct_records + l_tcp->m_nb_mct_records;
  }
#line 5065
  if (l_mct_data->m_data) {
    {
#line 5066
    free((void *)l_mct_data->m_data);
#line 5067
    l_mct_data->m_data = (OPJ_BYTE *)0;
    }
  }
  {
#line 5070
  l_mct_data->m_index = l_indix;
#line 5071
  l_mct_data->m_array_type = (J2K_MCT_ARRAY_TYPE )((l_tmp >> 8) & 3U);
#line 5072
  l_mct_data->m_element_type = (J2K_MCT_ELEMENT_TYPE )((l_tmp >> 10) & 3U);
#line 5074
  opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )2);
#line 5075
  p_header_data += 2;
  }
#line 5076
  if (l_tmp != 0U) {
    {
#line 5077
    opj_event_msg(p_manager, 2, "Cannot take in charge multiple MCT markers\n");
    }
#line 5078
    return (1);
  }
  {
#line 5081
  p_header_size -= 6U;
#line 5083
  __cil_tmp15 = malloc((unsigned long )p_header_size);
#line 5083
  l_mct_data->m_data = (OPJ_BYTE *)__cil_tmp15;
  }
#line 5084
  if (! l_mct_data->m_data) {
    {
#line 5085
    opj_event_msg(p_manager, 1, "Error reading MCT marker\n");
    }
#line 5086
    return (0);
  }
  {
#line 5088
  memcpy((void *)l_mct_data->m_data, (void const   *)p_header_data, (unsigned long )p_header_size);
#line 5090
  l_mct_data->m_data_size = p_header_size;
#line 5091
  (l_tcp->m_nb_mct_records) ++;
  }
#line 5093
  return (1);
}
}
#line 5096 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_mcc_record(opj_j2k_t *p_j2k , struct opj_simple_mcc_decorrelation_data *p_mcc_record ,
                                  struct opj_stream_private *p_stream , struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_mcc_size ;
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 l_nb_bytes_for_comp ;
  OPJ_UINT32 l_mask ;
  OPJ_UINT32 l_tmcc ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp15 ;
  OPJ_SIZE_T __cil_tmp16 ;

  {
#line 5103
  l_current_data = (OPJ_BYTE *)0;
#line 5113
  if (p_mcc_record->m_nb_comps > 255U) {
#line 5114
    l_nb_bytes_for_comp = (OPJ_UINT32 )2;
#line 5115
    l_mask = (OPJ_UINT32 )32768;
  } else {
#line 5118
    l_nb_bytes_for_comp = (OPJ_UINT32 )1;
#line 5119
    l_mask = (OPJ_UINT32 )0;
  }
#line 5122
  l_mcc_size = (p_mcc_record->m_nb_comps * 2U) * l_nb_bytes_for_comp + 19U;
#line 5123
  if (l_mcc_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 5125
    __cil_tmp15 = realloc((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                          (unsigned long )l_mcc_size);
#line 5125
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp15;
    }
#line 5126
    if (! new_header_tile_data) {
      {
#line 5127
      free((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 5128
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 5129
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 5130
      opj_event_msg(p_manager, 1, "Not enough memory to write MCC marker\n");
      }
#line 5131
      return (0);
    }
#line 5133
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 5134
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_mcc_size;
  }
  {
#line 5137
  l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 5139
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65397, (OPJ_UINT32 )2);
#line 5140
  l_current_data += 2;
#line 5142
  opj_write_bytes_LE(l_current_data, l_mcc_size - 2U, (OPJ_UINT32 )2);
#line 5143
  l_current_data += 2;
#line 5146
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )0, (OPJ_UINT32 )2);
#line 5147
  l_current_data += 2;
#line 5149
  opj_write_bytes_LE(l_current_data, p_mcc_record->m_index, (OPJ_UINT32 )1);
#line 5150
  l_current_data ++;
#line 5153
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )0, (OPJ_UINT32 )2);
#line 5154
  l_current_data += 2;
#line 5156
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )1, (OPJ_UINT32 )2);
#line 5157
  l_current_data += 2;
#line 5159
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )1, (OPJ_UINT32 )1);
#line 5160
  l_current_data ++;
#line 5162
  opj_write_bytes_LE(l_current_data, p_mcc_record->m_nb_comps | l_mask, (OPJ_UINT32 )2);
#line 5163
  l_current_data += 2;
#line 5165
  i = (OPJ_UINT32 )0;
  }
  {
#line 5165
  while (1) {
    while_continue: /* CIL Label */ ;

#line 5165
    if (! (i < p_mcc_record->m_nb_comps)) {
#line 5165
      goto while_break;
    }
    {
#line 5166
    opj_write_bytes_LE(l_current_data, i, l_nb_bytes_for_comp);
#line 5167
    l_current_data += l_nb_bytes_for_comp;
#line 5165
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 5170
  opj_write_bytes_LE(l_current_data, p_mcc_record->m_nb_comps | l_mask, (OPJ_UINT32 )2);
#line 5171
  l_current_data += 2;
#line 5173
  i = (OPJ_UINT32 )0;
  }
  {
#line 5173
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 5173
    if (! (i < p_mcc_record->m_nb_comps)) {
#line 5173
      goto while_break___0;
    }
    {
#line 5175
    opj_write_bytes_LE(l_current_data, i, l_nb_bytes_for_comp);
#line 5176
    l_current_data += l_nb_bytes_for_comp;
#line 5173
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: 
#line 5179
  l_tmcc = (OPJ_UINT32 )((! p_mcc_record->m_is_irreversible & 1) << 16);
#line 5181
  if (p_mcc_record->m_decorrelation_array) {
#line 5182
    l_tmcc |= (p_mcc_record->m_decorrelation_array)->m_index;
  }
#line 5185
  if (p_mcc_record->m_offset_array) {
#line 5186
    l_tmcc |= (p_mcc_record->m_offset_array)->m_index << 8;
  }
  {
#line 5189
  opj_write_bytes_LE(l_current_data, l_tmcc, (OPJ_UINT32 )3);
#line 5190
  l_current_data += 3;
#line 5192
  __cil_tmp16 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_mcc_size, p_manager);
  }
#line 5192
  if (__cil_tmp16 != (unsigned long )l_mcc_size) {
#line 5193
    return (0);
  }
#line 5196
  return (1);
}
}
#line 5199 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_read_mcc(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                          opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 l_tmp ;
  OPJ_UINT32 l_indix ;
  opj_tcp_t *l_tcp ;
  opj_simple_mcc_decorrelation_data_t *l_mcc_record ;
  opj_mct_data_t *l_mct_data ;
  OPJ_UINT32 l_nb_collections ;
  OPJ_UINT32 l_nb_comps ;
  OPJ_UINT32 l_nb_bytes_by_comp ;
  opj_tcp_t *tmp___2 ;
  opj_simple_mcc_decorrelation_data_t *new_mcc_records ;
  void *__cil_tmp20 ;

  {
#line 5219
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 5219
    tmp___2 = p_j2k->m_cp.tcps + p_j2k->m_current_tile_number;
  } else {
#line 5219
    tmp___2 = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
#line 5219
  l_tcp = tmp___2;
#line 5223
  if (p_header_size < 2U) {
    {
#line 5224
    opj_event_msg(p_manager, 1, "Error reading MCC marker\n\275\315\211\202U");
    }
#line 5225
    return (0);
  }
  {
#line 5229
  opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )2);
#line 5230
  p_header_data += 2;
  }
#line 5231
  if (l_tmp != 0U) {
    {
#line 5232
    opj_event_msg(p_manager, 2, "Cannot take in charge multiple data spanning\n");
    }
#line 5233
    return (1);
  }
#line 5236
  if (p_header_size < 7U) {
    {
#line 5237
    opj_event_msg(p_manager, 1, "Error reading MCC marker\n");
    }
#line 5238
    return (0);
  }
  {
#line 5241
  opj_read_bytes_LE(p_header_data, & l_indix, (OPJ_UINT32 )1);
#line 5242
  p_header_data ++;
#line 5244
  l_mcc_record = l_tcp->m_mcc_records;
#line 5246
  i = (OPJ_UINT32 )0;
  }
  {
#line 5246
  while (1) {
    while_continue: /* CIL Label */ ;

#line 5246
    if (! (i < l_tcp->m_nb_mcc_records)) {
#line 5246
      goto while_break;
    }
#line 5247
    if (l_mcc_record->m_index == l_indix) {
#line 5248
      goto while_break;
    }
#line 5250
    l_mcc_record ++;
#line 5246
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: ;
#line 5254
  if (i == l_tcp->m_nb_mcc_records) {
#line 5255
    if (l_tcp->m_nb_mcc_records == l_tcp->m_nb_max_mcc_records) {
      {
#line 5257
      l_tcp->m_nb_max_mcc_records += 10U;
#line 5259
      __cil_tmp20 = realloc((void *)l_tcp->m_mcc_records, (unsigned long )l_tcp->m_nb_max_mcc_records * sizeof(opj_simple_mcc_decorrelation_data_t ));
#line 5259
      new_mcc_records = (opj_simple_mcc_decorrelation_data_t *)__cil_tmp20;
      }
#line 5261
      if (! new_mcc_records) {
        {
#line 5262
        free((void *)l_tcp->m_mcc_records);
#line 5263
        l_tcp->m_mcc_records = (opj_simple_mcc_decorrelation_data_t *)((void *)0);
#line 5264
        l_tcp->m_nb_max_mcc_records = (OPJ_UINT32 )0;
#line 5265
        l_tcp->m_nb_mcc_records = (OPJ_UINT32 )0;
#line 5266
        opj_event_msg(p_manager, 1, "Not enough memory to read MCC marker\nU");
        }
#line 5267
        return (0);
      }
      {
#line 5269
      l_tcp->m_mcc_records = new_mcc_records;
#line 5270
      l_mcc_record = l_tcp->m_mcc_records + l_tcp->m_nb_mcc_records;
#line 5271
      memset((void *)l_mcc_record, 0, (unsigned long )(l_tcp->m_nb_max_mcc_records - l_tcp->m_nb_mcc_records) * sizeof(opj_simple_mcc_decorrelation_data_t ));
      }
    }
#line 5273
    l_mcc_record = l_tcp->m_mcc_records + l_tcp->m_nb_mcc_records;
  }
  {
#line 5275
  l_mcc_record->m_index = l_indix;
#line 5278
  opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )2);
#line 5279
  p_header_data += 2;
  }
#line 5280
  if (l_tmp != 0U) {
    {
#line 5281
    opj_event_msg(p_manager, 2, "Cannot take in charge multiple data spanning\n");
    }
#line 5282
    return (1);
  }
  {
#line 5285
  opj_read_bytes_LE(p_header_data, & l_nb_collections, (OPJ_UINT32 )2);
#line 5286
  p_header_data += 2;
  }
#line 5288
  if (l_nb_collections > 1U) {
    {
#line 5289
    opj_event_msg(p_manager, 2, "Cannot take in charge multiple collections\n\211\202U");
    }
#line 5290
    return (1);
  }
#line 5293
  p_header_size -= 7U;
#line 5295
  i = (OPJ_UINT32 )0;
  {
#line 5295
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 5295
    if (! (i < l_nb_collections)) {
#line 5295
      goto while_break___0;
    }
#line 5296
    if (p_header_size < 3U) {
      {
#line 5297
      opj_event_msg(p_manager, 1, "Error reading MCC marker\n\220\315\211\202U");
      }
#line 5298
      return (0);
    }
    {
#line 5301
    opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )1);
#line 5302
    p_header_data ++;
    }
#line 5304
    if (l_tmp != 1U) {
      {
#line 5305
      opj_event_msg(p_manager, 2, "Cannot take in charge collections other than array decorrelation\n");
      }
#line 5306
      return (1);
    }
    {
#line 5309
    opj_read_bytes_LE(p_header_data, & l_nb_comps, (OPJ_UINT32 )2);
#line 5311
    p_header_data += 2;
#line 5312
    p_header_size -= 3U;
#line 5314
    l_nb_bytes_by_comp = 1U + (l_nb_comps >> 15);
#line 5315
    l_mcc_record->m_nb_comps = l_nb_comps & 32767U;
    }
#line 5317
    if (p_header_size < l_nb_bytes_by_comp * l_mcc_record->m_nb_comps + 2U) {
      {
#line 5318
      opj_event_msg(p_manager, 1, "Error reading MCC marker\n");
      }
#line 5319
      return (0);
    }
#line 5322
    p_header_size -= l_nb_bytes_by_comp * l_mcc_record->m_nb_comps + 2U;
#line 5324
    j = (OPJ_UINT32 )0;
    {
#line 5324
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 5324
      if (! (j < l_mcc_record->m_nb_comps)) {
#line 5324
        goto while_break___1;
      }
      {
#line 5325
      opj_read_bytes_LE(p_header_data, & l_tmp, l_nb_bytes_by_comp);
#line 5326
      p_header_data += l_nb_bytes_by_comp;
      }
#line 5328
      if (l_tmp != j) {
        {
#line 5329
        opj_event_msg(p_manager, 2, "Cannot take in charge collections with indix shuffle\n");
        }
#line 5330
        return (1);
      }
#line 5324
      j ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: 
    {
#line 5334
    opj_read_bytes_LE(p_header_data, & l_nb_comps, (OPJ_UINT32 )2);
#line 5335
    p_header_data += 2;
#line 5337
    l_nb_bytes_by_comp = 1U + (l_nb_comps >> 15);
#line 5338
    l_nb_comps &= 32767U;
    }
#line 5340
    if (l_nb_comps != l_mcc_record->m_nb_comps) {
      {
#line 5341
      opj_event_msg(p_manager, 2, "Cannot take in charge collections without same number of indixes\n");
      }
#line 5342
      return (1);
    }
#line 5345
    if (p_header_size < l_nb_bytes_by_comp * l_mcc_record->m_nb_comps + 3U) {
      {
#line 5346
      opj_event_msg(p_manager, 1, "Error reading MCC marker\n");
      }
#line 5347
      return (0);
    }
#line 5350
    p_header_size -= l_nb_bytes_by_comp * l_mcc_record->m_nb_comps + 3U;
#line 5352
    j = (OPJ_UINT32 )0;
    {
#line 5352
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 5352
      if (! (j < l_mcc_record->m_nb_comps)) {
#line 5352
        goto while_break___2;
      }
      {
#line 5353
      opj_read_bytes_LE(p_header_data, & l_tmp, l_nb_bytes_by_comp);
#line 5354
      p_header_data += l_nb_bytes_by_comp;
      }
#line 5356
      if (l_tmp != j) {
        {
#line 5357
        opj_event_msg(p_manager, 2, "Cannot take in charge collections with indix shuffle\n");
        }
#line 5358
        return (1);
      }
#line 5352
      j ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___2: 
    {
#line 5362
    opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )3);
#line 5363
    p_header_data += 3;
#line 5365
    l_mcc_record->m_is_irreversible = (OPJ_UINT32 )(! ((l_tmp >> 16) & 1U));
#line 5366
    l_mcc_record->m_decorrelation_array = (opj_mct_data_t *)0;
#line 5367
    l_mcc_record->m_offset_array = (opj_mct_data_t *)0;
#line 5369
    l_indix = l_tmp & 255U;
    }
#line 5370
    if (l_indix != 0U) {
#line 5371
      l_mct_data = l_tcp->m_mct_records;
#line 5372
      j = (OPJ_UINT32 )0;
      {
#line 5372
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 5372
        if (! (j < l_tcp->m_nb_mct_records)) {
#line 5372
          goto while_break___3;
        }
#line 5373
        if (l_mct_data->m_index == l_indix) {
#line 5374
          l_mcc_record->m_decorrelation_array = l_mct_data;
#line 5375
          goto while_break___3;
        }
#line 5377
        l_mct_data ++;
#line 5372
        j ++;
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___3: ;
#line 5380
      if ((unsigned long )l_mcc_record->m_decorrelation_array == (unsigned long )((opj_mct_data_t *)0)) {
        {
#line 5381
        opj_event_msg(p_manager, 1, "Error reading MCC marker\n");
        }
#line 5382
        return (0);
      }
    }
#line 5386
    l_indix = (l_tmp >> 8) & 255U;
#line 5387
    if (l_indix != 0U) {
#line 5388
      l_mct_data = l_tcp->m_mct_records;
#line 5389
      j = (OPJ_UINT32 )0;
      {
#line 5389
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 5389
        if (! (j < l_tcp->m_nb_mct_records)) {
#line 5389
          goto while_break___4;
        }
#line 5390
        if (l_mct_data->m_index == l_indix) {
#line 5391
          l_mcc_record->m_offset_array = l_mct_data;
#line 5392
          goto while_break___4;
        }
#line 5394
        l_mct_data ++;
#line 5389
        j ++;
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___4: ;
#line 5397
      if ((unsigned long )l_mcc_record->m_offset_array == (unsigned long )((opj_mct_data_t *)0)) {
        {
#line 5398
        opj_event_msg(p_manager, 1, "Error reading MCC marker\n");
        }
#line 5399
        return (0);
      }
    }
#line 5295
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___0: ;
#line 5404
  if (p_header_size != 0U) {
    {
#line 5405
    opj_event_msg(p_manager, 1, "Error reading MCC marker\n");
    }
#line 5406
    return (0);
  }
#line 5409
  (l_tcp->m_nb_mcc_records) ++;
#line 5411
  return (1);
}
}
#line 5414 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_mco(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                           struct opj_event_mgr *p_manager ) 
{ 
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 l_mco_size ;
  opj_tcp_t *l_tcp ;
  opj_simple_mcc_decorrelation_data_t *l_mcc_record ;
  OPJ_UINT32 i ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp13 ;
  OPJ_SIZE_T __cil_tmp14 ;

  {
#line 5419
  l_current_data = (OPJ_BYTE *)0;
#line 5421
  l_tcp = (opj_tcp_t *)0;
#line 5430
  l_tcp = p_j2k->m_cp.tcps + p_j2k->m_current_tile_number;
#line 5431
  l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 5433
  l_mco_size = 5U + l_tcp->m_nb_mcc_records;
#line 5434
  if (l_mco_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 5436
    __cil_tmp13 = realloc((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                          (unsigned long )l_mco_size);
#line 5436
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp13;
    }
#line 5437
    if (! new_header_tile_data) {
      {
#line 5438
      free((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 5439
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 5440
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 5441
      opj_event_msg(p_manager, 1, "Not enough memory to write MCO marker\n");
      }
#line 5442
      return (0);
    }
#line 5444
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 5445
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_mco_size;
  }
  {
#line 5448
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65399, (OPJ_UINT32 )2);
#line 5449
  l_current_data += 2;
#line 5451
  opj_write_bytes_LE(l_current_data, l_mco_size - 2U, (OPJ_UINT32 )2);
#line 5452
  l_current_data += 2;
#line 5454
  opj_write_bytes_LE(l_current_data, l_tcp->m_nb_mcc_records, (OPJ_UINT32 )1);
#line 5455
  l_current_data ++;
#line 5457
  l_mcc_record = l_tcp->m_mcc_records;
#line 5458
  i = (OPJ_UINT32 )0;
  }
  {
#line 5458
  while (1) {
    while_continue: /* CIL Label */ ;

#line 5458
    if (! (i < l_tcp->m_nb_mcc_records)) {
#line 5458
      goto while_break;
    }
    {
#line 5459
    opj_write_bytes_LE(l_current_data, l_mcc_record->m_index, (OPJ_UINT32 )1);
#line 5460
    l_current_data ++;
#line 5462
    l_mcc_record ++;
#line 5458
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 5465
  __cil_tmp14 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_mco_size, p_manager);
  }
#line 5465
  if (__cil_tmp14 != (unsigned long )l_mco_size) {
#line 5466
    return (0);
  }
#line 5469
  return (1);
}
}
#line 5480 "/root/patron/new_22/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_mco(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_tmp ;
  OPJ_UINT32 i ;
  OPJ_UINT32 l_nb_stages ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;
  opj_image_t *l_image ;
  opj_tcp_t *tmp___2 ;
  OPJ_BOOL __cil_tmp15 ;

  {
#line 5497
  l_image = p_j2k->m_private_image;
#line 5498
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 5498
    tmp___2 = p_j2k->m_cp.tcps + p_j2k->m_current_tile_number;
  } else {
#line 5498
    tmp___2 = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
#line 5498
  l_tcp = tmp___2;
#line 5502
  if (p_header_size < 1U) {
    {
#line 5503
    opj_event_msg(p_manager, 1, "Error reading MCO marker\n");
    }
#line 5504
    return (0);
  }
  {
#line 5507
  opj_read_bytes_LE(p_header_data, & l_nb_stages, (OPJ_UINT32 )1);
#line 5508
  p_header_data ++;
  }
#line 5510
  if (l_nb_stages > 1U) {
    {
#line 5511
    opj_event_msg(p_manager, 2, "Cannot take in charge multiple transformation stages.\n");
    }
#line 5512
    return (1);
  }
#line 5515
  if (p_header_size != l_nb_stages + 1U) {
    {
#line 5516
    opj_event_msg(p_manager, 2, "Error reading MCO marker\n");
    }
#line 5517
    return (0);
  }
#line 5520
  l_tccp = l_tcp->tccps;
#line 5522
  i = (OPJ_UINT32 )0;
  {
#line 5522
  while (1) {
    while_continue: /* CIL Label */ ;

#line 5522
    if (! (i < l_image->numcomps)) {
#line 5522
      goto while_break;
    }
#line 5523
    l_tccp->m_dc_level_shift = 0;
#line 5524
    l_tccp ++;
#line 5522
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 5527
  if (l_tcp->m_mct_decoding_matrix) {
    {
#line 5528
    free((void *)l_tcp->m_mct_decoding_matrix);
#line 5529
    l_tcp->m_mct_decoding_matrix = (OPJ_FLOAT32 *)0;
    }
  }
#line 5532
  i = (OPJ_UINT32 )0;
  {
#line 5532
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 5532
    if (! (i < l_nb_stages)) {
#line 5532
      goto while_break___0;
    }
    {
#line 5533
    opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )1);
#line 5534
    p_header_data ++;
#line 5536
    __cil_tmp15 = opj_j2k_add_mct(l_tcp, p_j2k->m_private_image, l_tmp);
    }
#line 5536
    if (! __cil_tmp15) {
#line 5537
      return (0);
    }
#line 5532
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 5541
  return (1);
}
}
#line 5544 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_add_mct(opj_tcp_t *p_tcp , opj_image_t *p_image , OPJ_UINT32 p_index ) 
{ 
  OPJ_UINT32 i ;
  opj_simple_mcc_decorrelation_data_t *l_mcc_record ;
  opj_mct_data_t *l_deco_array ;
  opj_mct_data_t *l_offset_array ;
  OPJ_UINT32 l_data_size ;
  OPJ_UINT32 l_mct_size ;
  OPJ_UINT32 l_offset_size ;
  OPJ_UINT32 l_nb_elem ;
  OPJ_UINT32 *l_offset_data ;
  OPJ_UINT32 *l_current_offset_data ;
  opj_tccp_t *l_tccp ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  OPJ_UINT32 *__cil_tmp18 ;

  {
#line 5557
  l_mcc_record = p_tcp->m_mcc_records;
#line 5559
  i = (OPJ_UINT32 )0;
  {
#line 5559
  while (1) {
    while_continue: /* CIL Label */ ;

#line 5559
    if (! (i < p_tcp->m_nb_mcc_records)) {
#line 5559
      goto while_break;
    }
#line 5560
    if (l_mcc_record->m_index == p_index) {
#line 5561
      goto while_break;
    }
#line 5559
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 5565
  if (i == p_tcp->m_nb_mcc_records) {
#line 5567
    return (1);
  }
#line 5570
  if (l_mcc_record->m_nb_comps != p_image->numcomps) {
#line 5572
    return (1);
  }
#line 5575
  l_deco_array = l_mcc_record->m_decorrelation_array;
#line 5577
  if (l_deco_array) {
#line 5578
    l_data_size = (MCT_ELEMENT_SIZE[l_deco_array->m_element_type] * p_image->numcomps) * p_image->numcomps;
#line 5579
    if (l_deco_array->m_data_size != l_data_size) {
#line 5580
      return (0);
    }
    {
#line 5583
    l_nb_elem = p_image->numcomps * p_image->numcomps;
#line 5584
    l_mct_size = (OPJ_UINT32 )((unsigned long )l_nb_elem * sizeof(OPJ_FLOAT32 ));
#line 5585
    __cil_tmp16 = malloc((unsigned long )l_mct_size);
#line 5585
    p_tcp->m_mct_decoding_matrix = (OPJ_FLOAT32 *)__cil_tmp16;
    }
#line 5587
    if (! p_tcp->m_mct_decoding_matrix) {
#line 5588
      return (0);
    }
    {
#line 5591
    (*(j2k_mct_read_functions_to_float[l_deco_array->m_element_type]))((void const   *)l_deco_array->m_data,
                                                                       (void *)p_tcp->m_mct_decoding_matrix,
                                                                       l_nb_elem);
    }
  }
#line 5594
  l_offset_array = l_mcc_record->m_offset_array;
#line 5596
  if (l_offset_array) {
#line 5597
    l_data_size = MCT_ELEMENT_SIZE[l_offset_array->m_element_type] * p_image->numcomps;
#line 5598
    if (l_offset_array->m_data_size != l_data_size) {
#line 5599
      return (0);
    }
    {
#line 5602
    l_nb_elem = p_image->numcomps;
#line 5603
    l_offset_size = (OPJ_UINT32 )((unsigned long )l_nb_elem * sizeof(OPJ_UINT32 ));
#line 5604
    __cil_tmp17 = malloc((unsigned long )l_offset_size);
#line 5604
    l_offset_data = (OPJ_UINT32 *)__cil_tmp17;
    }
#line 5606
    if (! l_offset_data) {
#line 5607
      return (0);
    }
    {
#line 5610
    (*(j2k_mct_read_functions_to_int32[l_offset_array->m_element_type]))((void const   *)l_offset_array->m_data,
                                                                         (void *)l_offset_data,
                                                                         l_nb_elem);
#line 5612
    l_tccp = p_tcp->tccps;
#line 5613
    l_current_offset_data = l_offset_data;
#line 5615
    i = (OPJ_UINT32 )0;
    }
    {
#line 5615
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 5615
      if (! (i < p_image->numcomps)) {
#line 5615
        goto while_break___0;
      }
#line 5616
      __cil_tmp18 = l_current_offset_data;
#line 5616
      l_current_offset_data ++;
#line 5616
      l_tccp->m_dc_level_shift = (OPJ_INT32 )*__cil_tmp18;
#line 5617
      l_tccp ++;
#line 5615
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 5620
    free((void *)l_offset_data);
    }
  }
#line 5623
  return (1);
}
}
#line 5626 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_cbd(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                           struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_cbd_size ;
  OPJ_BYTE *l_current_data ;
  opj_image_t *l_image ;
  opj_image_comp_t *l_comp ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp13 ;
  OPJ_SIZE_T __cil_tmp14 ;

  {
#line 5632
  l_current_data = (OPJ_BYTE *)0;
#line 5633
  l_image = (opj_image_t *)0;
#line 5634
  l_comp = (opj_image_comp_t *)0;
#line 5641
  l_image = p_j2k->m_private_image;
#line 5642
  l_cbd_size = 6U + (p_j2k->m_private_image)->numcomps;
#line 5644
  if (l_cbd_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 5645
    __cil_tmp13 = realloc((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                          (unsigned long )l_cbd_size);
#line 5645
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp13;
    }
#line 5646
    if (! new_header_tile_data) {
      {
#line 5647
      free((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 5648
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 5649
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 5650
      opj_event_msg(p_manager, 1, "Not enough memory to write CBD marker\n");
      }
#line 5651
      return (0);
    }
#line 5653
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 5654
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_cbd_size;
  }
  {
#line 5657
  l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 5659
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65400, (OPJ_UINT32 )2);
#line 5660
  l_current_data += 2;
#line 5662
  opj_write_bytes_LE(l_current_data, l_cbd_size - 2U, (OPJ_UINT32 )2);
#line 5663
  l_current_data += 2;
#line 5665
  opj_write_bytes_LE(l_current_data, l_image->numcomps, (OPJ_UINT32 )2);
#line 5666
  l_current_data += 2;
#line 5668
  l_comp = l_image->comps;
#line 5670
  i = (OPJ_UINT32 )0;
  }
  {
#line 5670
  while (1) {
    while_continue: /* CIL Label */ ;

#line 5670
    if (! (i < l_image->numcomps)) {
#line 5670
      goto while_break;
    }
    {
#line 5671
    opj_write_bytes_LE(l_current_data, (l_comp->sgnd << 7) | (l_comp->prec - 1U),
                       (OPJ_UINT32 )1);
#line 5672
    l_current_data ++;
#line 5674
    l_comp ++;
#line 5670
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 5677
  __cil_tmp14 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_cbd_size, p_manager);
  }
#line 5677
  if (__cil_tmp14 != (unsigned long )l_cbd_size) {
#line 5678
    return (0);
  }
#line 5681
  return (1);
}
}
#line 5691 "/root/patron/new_22/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_cbd(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_nb_comp ;
  OPJ_UINT32 l_num_comp ;
  OPJ_UINT32 l_comp_def ;
  OPJ_UINT32 i ;
  opj_image_comp_t *l_comp ;

  {
#line 5700
  l_comp = (opj_image_comp_t *)0;
#line 5707
  l_num_comp = (p_j2k->m_private_image)->numcomps;
#line 5709
  if (p_header_size != (p_j2k->m_private_image)->numcomps + 2U) {
    {
#line 5710
    opj_event_msg(p_manager, 1, "Crror reading CBD marker\n");
    }
#line 5711
    return (0);
  }
  {
#line 5714
  opj_read_bytes_LE(p_header_data, & l_nb_comp, (OPJ_UINT32 )2);
#line 5715
  p_header_data += 2;
  }
#line 5717
  if (l_nb_comp != l_num_comp) {
    {
#line 5718
    opj_event_msg(p_manager, 1, "Crror reading CBD marker\n");
    }
#line 5719
    return (0);
  }
#line 5722
  l_comp = (p_j2k->m_private_image)->comps;
#line 5723
  i = (OPJ_UINT32 )0;
  {
#line 5723
  while (1) {
    while_continue: /* CIL Label */ ;

#line 5723
    if (! (i < l_num_comp)) {
#line 5723
      goto while_break;
    }
    {
#line 5724
    opj_read_bytes_LE(p_header_data, & l_comp_def, (OPJ_UINT32 )1);
#line 5725
    p_header_data ++;
#line 5726
    l_comp->sgnd = (l_comp_def >> 7) & 1U;
#line 5727
    l_comp->prec = (l_comp_def & 127U) + 1U;
#line 5728
    l_comp ++;
#line 5723
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 5731
  return (1);
}
}
#line 5738 "/root/patron/new_22/src/lib/openjp2/j2k.c"
void opj_j2k_setup_decoder(opj_j2k_t *j2k , opj_dparameters_t *parameters ) 
{ 


  {
#line 5740
  if (j2k) {
#line 5740
    if (parameters) {
#line 5741
      j2k->m_cp.m_specific_param.m_dec.m_layer = parameters->cp_layer;
#line 5742
      j2k->m_cp.m_specific_param.m_dec.m_reduce = parameters->cp_reduce;
    }
  }
#line 5745
  return;
}
}
#line 5756 "/root/patron/new_22/src/lib/openjp2/j2k.c"
opj_j2k_t *opj_j2k_create_compress(void) 
{ 
  opj_j2k_t *l_j2k ;
  void *__cil_tmp2 ;
  void *__cil_tmp3 ;

  {
  {
#line 5758
  __cil_tmp2 = malloc(sizeof(opj_j2k_t ));
#line 5758
  l_j2k = (opj_j2k_t *)__cil_tmp2;
  }
#line 5759
  if (! l_j2k) {
#line 5760
    return ((opj_j2k_t *)((void *)0));
  }
  {
#line 5763
  memset((void *)l_j2k, 0, sizeof(opj_j2k_t ));
#line 5765
  l_j2k->m_is_decoder = 0;
#line 5766
  l_j2k->m_cp.m_is_decoder = (OPJ_UINT32 )0;
#line 5768
  __cil_tmp3 = malloc(1000UL);
#line 5768
  l_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)__cil_tmp3;
  }
#line 5769
  if (! l_j2k->m_specific_param.m_encoder.m_header_tile_data) {
    {
#line 5770
    opj_j2k_destroy(l_j2k);
    }
#line 5771
    return ((opj_j2k_t *)((void *)0));
  }
  {
#line 5774
  l_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )1000;
#line 5777
  l_j2k->m_validation_list = opj_procedure_list_create();
  }
#line 5778
  if (! l_j2k->m_validation_list) {
    {
#line 5779
    opj_j2k_destroy(l_j2k);
    }
#line 5780
    return ((opj_j2k_t *)((void *)0));
  }
  {
#line 5784
  l_j2k->m_procedure_list = opj_procedure_list_create();
  }
#line 5785
  if (! l_j2k->m_procedure_list) {
    {
#line 5786
    opj_j2k_destroy(l_j2k);
    }
#line 5787
    return ((opj_j2k_t *)((void *)0));
  }
#line 5790
  return (l_j2k);
}
}
#line 5793 "/root/patron/new_22/src/lib/openjp2/j2k.c"
int opj_j2k_initialise_4K_poc(opj_poc_t *POC , int numres ) 
{ 


  {
#line 5794
  (POC + 0)->tile = (OPJ_UINT32 )1;
#line 5795
  (POC + 0)->resno0 = (OPJ_UINT32 )0;
#line 5796
  (POC + 0)->compno0 = (OPJ_UINT32 )0;
#line 5797
  (POC + 0)->layno1 = (OPJ_UINT32 )1;
#line 5798
  (POC + 0)->resno1 = (OPJ_UINT32 )(numres - 1);
#line 5799
  (POC + 0)->compno1 = (OPJ_UINT32 )3;
#line 5800
  (POC + 0)->prg1 = (OPJ_PROG_ORDER )4;
#line 5801
  (POC + 1)->tile = (OPJ_UINT32 )1;
#line 5802
  (POC + 1)->resno0 = (OPJ_UINT32 )(numres - 1);
#line 5803
  (POC + 1)->compno0 = (OPJ_UINT32 )0;
#line 5804
  (POC + 1)->layno1 = (OPJ_UINT32 )1;
#line 5805
  (POC + 1)->resno1 = (OPJ_UINT32 )numres;
#line 5806
  (POC + 1)->compno1 = (OPJ_UINT32 )3;
#line 5807
  (POC + 1)->prg1 = (OPJ_PROG_ORDER )4;
#line 5808
  return (2);
}
}
#line 5811 "/root/patron/new_22/src/lib/openjp2/j2k.c"
void opj_j2k_set_cinema_parameters(opj_cparameters_t *parameters , opj_image_t *image ,
                                   opj_event_mgr_t *p_manager ) 
{ 
  float max_rate ;
  float temp_rate ;
  int i ;
  int __cil_tmp8 ;

  {
#line 5814
  max_rate = (float )0;
#line 5815
  temp_rate = (float )0;
#line 5821
  if ((unsigned int )parameters->cp_cinema == 2U) {
#line 5821
    goto case_2;
  }
#line 5821
  if ((unsigned int )parameters->cp_cinema == 1U) {
#line 5821
    goto case_2;
  }
#line 5824
  if ((unsigned int )parameters->cp_cinema == 3U) {
#line 5824
    goto case_3;
  }
#line 5819
  goto switch_break;
  case_2: 
#line 5822
  parameters->cp_rsiz = (OPJ_RSIZ_CAPABILITIES )3;
#line 5823
  goto switch_break;
  case_3: 
#line 5825
  parameters->cp_rsiz = (OPJ_RSIZ_CAPABILITIES )4;
#line 5826
  goto switch_break;
  switch_break: 
#line 5830
  parameters->tile_size_on = 0;
#line 5831
  parameters->cp_tdx = 1;
#line 5832
  parameters->cp_tdy = 1;
#line 5835
  parameters->tp_flag = (char )'C';
#line 5836
  parameters->tp_on = (char)1;
#line 5839
  parameters->cp_tx0 = 0;
#line 5840
  parameters->cp_ty0 = 0;
#line 5841
  parameters->image_offset_x0 = 0;
#line 5842
  parameters->image_offset_y0 = 0;
#line 5845
  parameters->cblockw_init = 32;
#line 5846
  parameters->cblockh_init = 32;
#line 5849
  parameters->mode = 0;
#line 5852
  parameters->roi_compno = -1;
#line 5855
  parameters->subsampling_dx = 1;
#line 5856
  parameters->subsampling_dy = 1;
#line 5859
  parameters->irreversible = 1;
#line 5862
  if (parameters->tcp_numlayers > 1) {
    {
#line 5863
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\n1 single quality layer-> Number of layers forced to 1 (rather than %d)\n",
                  parameters->tcp_numlayers);
#line 5868
    parameters->tcp_numlayers = 1;
    }
  }
#line 5874
  if ((unsigned int )parameters->cp_cinema == 2U) {
#line 5874
    goto case_2___0;
  }
#line 5874
  if ((unsigned int )parameters->cp_cinema == 1U) {
#line 5874
    goto case_2___0;
  }
#line 5884
  if ((unsigned int )parameters->cp_cinema == 3U) {
#line 5884
    goto case_3___0;
  }
#line 5901
  goto switch_default;
  case_2___0: 
#line 5875
  if (parameters->numresolution > 6) {
    {
#line 5876
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-3 (2k dc profile) requires:\nNumber of decomposition levels <= 5\n-> Number of decomposition levels forced to 5 (rather than %d)\n`\003",
                  parameters->numresolution + 1);
#line 5881
    parameters->numresolution = 6;
    }
  }
#line 5883
  goto switch_break___0;
  case_3___0: 
#line 5885
  if (parameters->numresolution < 2) {
    {
#line 5886
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-4 (4k dc profile) requires:\nNumber of decomposition levels >= 1 && <= 6\n-> Number of decomposition levels forced to 1 (rather than %d)\n",
                  parameters->numresolution + 1);
#line 5891
    parameters->numresolution = 1;
    }
  } else
#line 5892
  if (parameters->numresolution > 7) {
    {
#line 5893
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-4 (4k dc profile) requires:\nNumber of decomposition levels >= 1 && <= 6\n-> Number of decomposition levels forced to 6 (rather than %d)\n\a",
                  parameters->numresolution + 1);
#line 5898
    parameters->numresolution = 7;
    }
  }
#line 5900
  goto switch_break___0;
  switch_default: 
#line 5902
  goto switch_break___0;
  switch_break___0: 
#line 5906
  parameters->csty |= 1;
#line 5907
  parameters->res_spec = parameters->numresolution - 1;
#line 5908
  i = 0;
  {
#line 5908
  while (1) {
    while_continue: /* CIL Label */ ;

#line 5908
    if (! (i < parameters->res_spec)) {
#line 5908
      goto while_break;
    }
#line 5909
    parameters->prcw_init[i] = 256;
#line 5910
    parameters->prch_init[i] = 256;
#line 5908
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 5914
  parameters->prog_order = (OPJ_PROG_ORDER )4;
#line 5917
  if ((unsigned int )parameters->cp_cinema == 3U) {
    {
#line 5918
    __cil_tmp8 = opj_j2k_initialise_4K_poc(parameters->POC, parameters->numresolution);
#line 5918
    parameters->numpocs = (OPJ_UINT32 )__cil_tmp8;
    }
  } else {
#line 5920
    parameters->numpocs = (OPJ_UINT32 )0;
  }
#line 5924
  parameters->cp_disto_alloc = 1;
#line 5927
  if ((unsigned int )parameters->cp_cinema == 3U) {
#line 5927
    goto case_3___1;
  }
#line 5927
  if ((unsigned int )parameters->cp_cinema == 1U) {
#line 5927
    goto case_3___1;
  }
#line 5951
  if ((unsigned int )parameters->cp_cinema == 2U) {
#line 5951
    goto case_2___1;
  }
#line 5975
  goto switch_default___0;
  case_3___1: 
#line 5928
  max_rate = (float )(((image->numcomps * (image->comps + 0)->w) * (image->comps + 0)->h) * (image->comps + 0)->prec) / (float )((10416664U * (image->comps + 0)->dx) * (image->comps + 0)->dy);
#line 5930
  if (parameters->tcp_rates[0] == (float )0) {
#line 5931
    parameters->tcp_rates[0] = max_rate;
  } else {
#line 5933
    temp_rate = (float )(((image->numcomps * (image->comps + 0)->w) * (image->comps + 0)->h) * (image->comps + 0)->prec) / (((parameters->tcp_rates[0] * (float )8) * (float )(image->comps + 0)->dx) * (float )(image->comps + 0)->dy);
#line 5935
    if (temp_rate > (float )1302083) {
      {
#line 5936
      opj_event_msg(p_manager, 2, "JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\nMaximum 1302083 compressed bytes @ 24fps\n-> Specified rate (%3.1f) exceeds this limit. Rate will be forced to %3.1f.\n\336\347\004",
                    (double )parameters->tcp_rates[0], (double )max_rate);
#line 5941
      parameters->tcp_rates[0] = max_rate;
      }
    } else {
      {
#line 5943
      opj_event_msg(p_manager, 2, "JPEG 2000 Profile-3 and 4 (2k/4k dc profile):\nINFO : Specified rate (%3.1f) is below the 2k/4k limit @ 24fps.\n",
                    (double )parameters->tcp_rates[0]);
      }
    }
  }
#line 5949
  parameters->max_comp_size = 1041666;
#line 5950
  goto switch_break___1;
  case_2___1: 
#line 5952
  max_rate = (float )(((image->numcomps * (image->comps + 0)->w) * (image->comps + 0)->h) * (image->comps + 0)->prec) / (float )((5208328U * (image->comps + 0)->dx) * (image->comps + 0)->dy);
#line 5954
  if (parameters->tcp_rates[0] == (float )0) {
#line 5955
    parameters->tcp_rates[0] = max_rate;
  } else {
#line 5957
    temp_rate = (float )(((image->numcomps * (image->comps + 0)->w) * (image->comps + 0)->h) * (image->comps + 0)->prec) / (((parameters->tcp_rates[0] * (float )8) * (float )(image->comps + 0)->dx) * (float )(image->comps + 0)->dy);
#line 5959
    if (temp_rate > (float )651041) {
      {
#line 5960
      opj_event_msg(p_manager, 2, "JPEG 2000 Profile-3 (2k dc profile) requires:\nMaximum 651041 compressed bytes @ 48fps\n-> Specified rate (%3.1f) exceeds this limit. Rate will be forced to %3.1f.\n",
                    (double )parameters->tcp_rates[0], (double )max_rate);
#line 5965
      parameters->tcp_rates[0] = max_rate;
      }
    } else {
      {
#line 5967
      opj_event_msg(p_manager, 2, "JPEG 2000 Profile-3 (2k dc profile):\nINFO : Specified rate (%3.1f) is below the 2k limit @ 48 fps.\n",
                    (double )parameters->tcp_rates[0]);
      }
    }
  }
#line 5973
  parameters->max_comp_size = 520833;
#line 5974
  goto switch_break___1;
  switch_default___0: 
#line 5976
  goto switch_break___1;
  switch_break___1: ;
#line 5979
  return;
}
}
#line 5980 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_is_cinema_compliant(opj_image_t *image , OPJ_CINEMA_MODE cinema_mode ,
                                     opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  char signed_str[7] ;
  char unsigned_str[9] ;
  char *tmp_str ;
  char *tmp ;

  {
#line 5985
  if (image->numcomps != 3U) {
    {
#line 5986
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-3 (2k dc profile) requires:\n3 components-> Number of components of input image (%d) is not compliant\n-> Non-profile-3 codestream will be generated\n",
                  image->numcomps);
    }
#line 5992
    return (0);
  }
#line 5996
  i = (OPJ_UINT32 )0;
  {
#line 5996
  while (1) {
    while_continue: /* CIL Label */ ;

#line 5996
    if (! (i < image->numcomps)) {
#line 5996
      goto while_break;
    }
#line 5997
    if ((unsigned int )((image->comps + i)->bpp != 12U) | (image->comps + i)->sgnd) {
      {
#line 5998
      strcpy(signed_str, "signed");
#line 5999
      strcpy(unsigned_str, "unsigned\f");
      }
#line 6000
      if ((image->comps + i)->sgnd) {
#line 6000
        tmp = signed_str;
      } else {
#line 6000
        tmp = unsigned_str;
      }
      {
#line 6000
      tmp_str = tmp;
#line 6001
      opj_event_msg(p_manager, 2, "JPEG 2000 Profile-3 (2k dc profile) requires:\nPrecision of each component shall be 12 bits unsigned-> At least component %d of input image (%d bits, %s) is not compliant\n-> Non-profile-3 codestream will be generated\n",
                    i, (image->comps + i)->bpp, tmp_str);
      }
#line 6007
      return (0);
    }
#line 5996
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 6014
  if ((unsigned int )cinema_mode == 2U) {
#line 6014
    goto case_2;
  }
#line 6014
  if ((unsigned int )cinema_mode == 1U) {
#line 6014
    goto case_2;
  }
#line 6025
  if ((unsigned int )cinema_mode == 3U) {
#line 6025
    goto case_3;
  }
#line 6036
  goto switch_default;
  case_2: 
#line 6015
  if (((image->comps + 0)->w > 2048U) | ((image->comps + 0)->h > 1080U)) {
    {
#line 6016
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-3 (2k dc profile) requires:\nwidth <= 2048 and height <= 1080\n-> Input image size %d x %d is not compliant\n-> Non-profile-3 codestream will be generated\n",
                  (image->comps + 0)->w, (image->comps + 0)->h);
    }
#line 6022
    return (0);
  }
#line 6024
  goto switch_break;
  case_3: 
#line 6026
  if (((image->comps + 0)->w > 4096U) | ((image->comps + 0)->h > 2160U)) {
    {
#line 6027
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-4 (4k dc profile) requires:\nwidth <= 4096 and height <= 2160\n-> Image size %d x %d is not compliant\n-> Non-profile-4 codestream will be generated\n\230\001",
                  (image->comps + 0)->w, (image->comps + 0)->h);
    }
#line 6033
    return (0);
  }
#line 6035
  goto switch_break;
  switch_default: 
#line 6037
  goto switch_break;
  switch_break: ;
#line 6040
  return (1);
}
}
#line 6043 "/root/patron/new_22/src/lib/openjp2/j2k.c"
void opj_j2k_setup_encoder(opj_j2k_t *p_j2k , opj_cparameters_t *parameters , opj_image_t *image ,
                           opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 tileno ;
  OPJ_UINT32 numpocs_tile ;
  opj_cp_t *cp ;
  OPJ_BOOL __cil_tmp10 ;
  size_t array_size ;
  void *__cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  void *__cil_tmp14 ;
  OPJ_INT32 __cil_tmp15 ;
  OPJ_INT32 __cil_tmp16 ;
  void *__cil_tmp17 ;
  opj_tcp_t *tcp ;
  opj_poc_t *tcp_poc ;
  void *__cil_tmp23 ;
  OPJ_UINT32 lMctSize ;
  OPJ_FLOAT32 *lTmpBuf ;
  void *__cil_tmp26 ;
  OPJ_INT32 *l_dc_shift ;
  void *__cil_tmp28 ;
  void *__cil_tmp29 ;
  void *__cil_tmp32 ;
  opj_tccp_t *tccp ;
  opj_tccp_t *tccp___0 ;
  opj_image_comp_t *l_comp ;
  opj_tccp_t *tccp___1 ;
  OPJ_INT32 __cil_tmp39 ;
  OPJ_INT32 __cil_tmp40 ;
  int tmp___0 ;
  int tmp___1 ;
  OPJ_INT32 p ;
  OPJ_INT32 it_res ;
  OPJ_INT32 __cil_tmp45 ;
  OPJ_INT32 __cil_tmp46 ;
  OPJ_INT32 res_spec ;
  OPJ_INT32 size_prcw ;
  OPJ_INT32 size_prch ;
  OPJ_INT32 __cil_tmp51 ;
  OPJ_INT32 __cil_tmp52 ;
  OPJ_INT32 __cil_tmp54 ;

  {
#line 6049
  cp = (opj_cp_t *)0;
#line 6051
  if (! p_j2k) {
#line 6052
    return;
  } else
#line 6051
  if (! parameters) {
#line 6052
    return;
  } else
#line 6051
  if (! image) {
#line 6052
    return;
  }
#line 6056
  cp = & p_j2k->m_cp;
#line 6059
  cp->tw = (OPJ_UINT32 )1;
#line 6060
  cp->th = (OPJ_UINT32 )1;
#line 6063
  if (parameters->cp_cinema) {
    {
#line 6064
    opj_j2k_set_cinema_parameters(parameters, image, p_manager);
#line 6065
    __cil_tmp10 = opj_j2k_is_cinema_compliant(image, parameters->cp_cinema, p_manager);
    }
#line 6065
    if (! __cil_tmp10) {
#line 6066
      parameters->cp_rsiz = (OPJ_RSIZ_CAPABILITIES )0;
    }
  }
#line 6073
  cp->m_specific_param.m_enc.m_cinema = parameters->cp_cinema;
#line 6074
  cp->m_specific_param.m_enc.m_max_comp_size = (OPJ_UINT32 )parameters->max_comp_size;
#line 6075
  cp->rsiz = parameters->cp_rsiz;
#line 6076
  cp->m_specific_param.m_enc.m_disto_alloc = (OPJ_UINT32 )parameters->cp_disto_alloc;
#line 6077
  cp->m_specific_param.m_enc.m_fixed_alloc = (OPJ_UINT32 )parameters->cp_fixed_alloc;
#line 6078
  cp->m_specific_param.m_enc.m_fixed_quality = (OPJ_UINT32 )parameters->cp_fixed_quality;
#line 6081
  if (parameters->cp_matrice) {
#line 6081
    if (parameters->cp_fixed_alloc) {
      {
#line 6082
      array_size = (unsigned long )((parameters->tcp_numlayers * parameters->numresolution) * 3) * sizeof(OPJ_INT32 );
#line 6083
      __cil_tmp12 = malloc(array_size);
#line 6083
      cp->m_specific_param.m_enc.m_matrice = (OPJ_INT32 *)__cil_tmp12;
#line 6084
      memcpy((void *)cp->m_specific_param.m_enc.m_matrice, (void const   *)parameters->cp_matrice,
             array_size);
      }
    }
  }
#line 6088
  cp->tdx = (OPJ_UINT32 )parameters->cp_tdx;
#line 6089
  cp->tdy = (OPJ_UINT32 )parameters->cp_tdy;
#line 6092
  cp->tx0 = (OPJ_UINT32 )parameters->cp_tx0;
#line 6093
  cp->ty0 = (OPJ_UINT32 )parameters->cp_ty0;
#line 6096
  if (parameters->cp_comment) {
    {
#line 6097
    __cil_tmp13 = strlen((char const   *)parameters->cp_comment);
#line 6097
    __cil_tmp14 = malloc(__cil_tmp13 + 1UL);
#line 6097
    cp->comment = (char *)__cil_tmp14;
    }
#line 6098
    if (cp->comment) {
      {
#line 6099
      strcpy(cp->comment, (char const   *)parameters->cp_comment);
      }
    }
  }
#line 6107
  if (parameters->tile_size_on) {
    {
#line 6108
    __cil_tmp15 = opj_int_ceildiv((OPJ_INT32 )(image->x1 - cp->tx0), (OPJ_INT32 )cp->tdx);
#line 6108
    cp->tw = (OPJ_UINT32 )__cil_tmp15;
#line 6109
    __cil_tmp16 = opj_int_ceildiv((OPJ_INT32 )(image->y1 - cp->ty0), (OPJ_INT32 )cp->tdy);
#line 6109
    cp->th = (OPJ_UINT32 )__cil_tmp16;
    }
  } else {
#line 6111
    cp->tdx = image->x1 - cp->tx0;
#line 6112
    cp->tdy = image->y1 - cp->ty0;
  }
#line 6115
  if (parameters->tp_on) {
#line 6116
    cp->m_specific_param.m_enc.m_tp_flag = (OPJ_BYTE )parameters->tp_flag;
#line 6117
    cp->m_specific_param.m_enc.m_tp_on = (OPJ_UINT32 )1;
  }
  {
#line 6178
  __cil_tmp17 = calloc((unsigned long )(cp->tw * cp->th), sizeof(opj_tcp_t ));
#line 6178
  cp->tcps = (opj_tcp_t *)__cil_tmp17;
  }
#line 6179
  if (parameters->numpocs) {
    {
#line 6181
    opj_j2k_check_poc_val(parameters->POC, parameters->numpocs, (OPJ_UINT32 )parameters->numresolution,
                          image->numcomps, (OPJ_UINT32 )parameters->tcp_numlayers,
                          p_manager);
    }
  }
#line 6185
  tileno = (OPJ_UINT32 )0;
  {
#line 6185
  while (1) {
    while_continue: /* CIL Label */ ;

#line 6185
    if (! (tileno < cp->tw * cp->th)) {
#line 6185
      goto while_break;
    }
#line 6186
    tcp = cp->tcps + tileno;
#line 6187
    tcp->numlayers = (OPJ_UINT32 )parameters->tcp_numlayers;
#line 6189
    j = (OPJ_UINT32 )0;
    {
#line 6189
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 6189
      if (! (j < tcp->numlayers)) {
#line 6189
        goto while_break___0;
      }
#line 6190
      if (cp->m_specific_param.m_enc.m_cinema) {
#line 6191
        if (cp->m_specific_param.m_enc.m_fixed_quality) {
#line 6192
          tcp->distoratio[j] = parameters->tcp_distoratio[j];
        }
#line 6194
        tcp->rates[j] = parameters->tcp_rates[j];
      } else
#line 6196
      if (cp->m_specific_param.m_enc.m_fixed_quality) {
#line 6197
        tcp->distoratio[j] = parameters->tcp_distoratio[j];
      } else {
#line 6199
        tcp->rates[j] = parameters->tcp_rates[j];
      }
#line 6189
      j ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___0: 
#line 6204
    tcp->csty = (OPJ_UINT32 )parameters->csty;
#line 6205
    tcp->prg = parameters->prog_order;
#line 6206
    tcp->mct = (OPJ_UINT32 )parameters->tcp_mct;
#line 6208
    numpocs_tile = (OPJ_UINT32 )0;
#line 6209
    tcp->POC = (OPJ_UINT32 )0;
#line 6211
    if (parameters->numpocs) {
#line 6213
      tcp->POC = (OPJ_UINT32 )1;
#line 6214
      i = (OPJ_UINT32 )0;
      {
#line 6214
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 6214
        if (! (i < parameters->numpocs)) {
#line 6214
          goto while_break___1;
        }
#line 6215
        if (tileno + 1U == parameters->POC[i].tile) {
#line 6216
          tcp_poc = & tcp->pocs[numpocs_tile];
#line 6218
          tcp_poc->resno0 = parameters->POC[numpocs_tile].resno0;
#line 6219
          tcp_poc->compno0 = parameters->POC[numpocs_tile].compno0;
#line 6220
          tcp_poc->layno1 = parameters->POC[numpocs_tile].layno1;
#line 6221
          tcp_poc->resno1 = parameters->POC[numpocs_tile].resno1;
#line 6222
          tcp_poc->compno1 = parameters->POC[numpocs_tile].compno1;
#line 6223
          tcp_poc->prg1 = parameters->POC[numpocs_tile].prg1;
#line 6224
          tcp_poc->tile = parameters->POC[numpocs_tile].tile;
#line 6226
          numpocs_tile ++;
        }
#line 6214
        i ++;
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___1: 
#line 6230
      tcp->numpocs = numpocs_tile - 1U;
    } else {
#line 6232
      tcp->numpocs = (OPJ_UINT32 )0;
    }
    {
#line 6235
    __cil_tmp23 = calloc((unsigned long )image->numcomps, sizeof(opj_tccp_t ));
#line 6235
    tcp->tccps = (opj_tccp_t *)__cil_tmp23;
    }
#line 6237
    if (parameters->mct_data) {
      {
#line 6239
      lMctSize = (OPJ_UINT32 )((unsigned long )(image->numcomps * image->numcomps) * sizeof(OPJ_FLOAT32 ));
#line 6240
      __cil_tmp26 = malloc((unsigned long )lMctSize);
#line 6240
      lTmpBuf = (OPJ_FLOAT32 *)__cil_tmp26;
#line 6241
      l_dc_shift = (OPJ_INT32 *)((OPJ_BYTE *)parameters->mct_data + lMctSize);
#line 6243
      tcp->mct = (OPJ_UINT32 )2;
#line 6244
      __cil_tmp28 = malloc((unsigned long )lMctSize);
#line 6244
      tcp->m_mct_coding_matrix = (OPJ_FLOAT32 *)__cil_tmp28;
#line 6245
      memcpy((void *)tcp->m_mct_coding_matrix, (void const   *)parameters->mct_data,
             (unsigned long )lMctSize);
#line 6246
      memcpy((void *)lTmpBuf, (void const   *)parameters->mct_data, (unsigned long )lMctSize);
#line 6248
      __cil_tmp29 = malloc((unsigned long )lMctSize);
#line 6248
      tcp->m_mct_decoding_matrix = (OPJ_FLOAT32 *)__cil_tmp29;
#line 6251
      __cil_tmp32 = malloc((unsigned long )image->numcomps * sizeof(OPJ_FLOAT64 ));
#line 6251
      tcp->mct_norms = (OPJ_FLOAT64 *)__cil_tmp32;
#line 6254
      opj_calculate_norms(tcp->mct_norms, image->numcomps, tcp->m_mct_decoding_matrix);
#line 6255
      free((void *)lTmpBuf);
#line 6257
      i = (OPJ_UINT32 )0;
      }
      {
#line 6257
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 6257
        if (! (i < image->numcomps)) {
#line 6257
          goto while_break___2;
        }
#line 6258
        tccp = tcp->tccps + i;
#line 6259
        tccp->m_dc_level_shift = *(l_dc_shift + i);
#line 6257
        i ++;
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___2: 
      {
#line 6262
      opj_j2k_setup_mct_encoding(tcp, image);
      }
    } else {
#line 6265
      i = (OPJ_UINT32 )0;
      {
#line 6265
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 6265
        if (! (i < image->numcomps)) {
#line 6265
          goto while_break___3;
        }
#line 6266
        tccp___0 = tcp->tccps + i;
#line 6267
        l_comp = image->comps + i;
#line 6269
        if (! l_comp->sgnd) {
#line 6270
          tccp___0->m_dc_level_shift = 1 << (l_comp->prec - 1U);
        }
#line 6265
        i ++;
      }
      while_break___11: /* CIL Label */ ;
      }
      while_break___3: ;
    }
#line 6275
    i = (OPJ_UINT32 )0;
    {
#line 6275
    while (1) {
      while_continue___4: /* CIL Label */ ;

#line 6275
      if (! (i < image->numcomps)) {
#line 6275
        goto while_break___4;
      }
      {
#line 6276
      tccp___1 = tcp->tccps + i;
#line 6278
      tccp___1->csty = (OPJ_UINT32 )(parameters->csty & 1);
#line 6279
      tccp___1->numresolutions = (OPJ_UINT32 )parameters->numresolution;
#line 6280
      __cil_tmp39 = opj_int_floorlog2(parameters->cblockw_init);
#line 6280
      tccp___1->cblkw = (OPJ_UINT32 )__cil_tmp39;
#line 6281
      __cil_tmp40 = opj_int_floorlog2(parameters->cblockh_init);
#line 6281
      tccp___1->cblkh = (OPJ_UINT32 )__cil_tmp40;
#line 6282
      tccp___1->cblksty = (OPJ_UINT32 )parameters->mode;
      }
#line 6283
      if (parameters->irreversible) {
#line 6283
        tmp___0 = 0;
      } else {
#line 6283
        tmp___0 = 1;
      }
#line 6283
      tccp___1->qmfbid = (OPJ_UINT32 )tmp___0;
#line 6284
      if (parameters->irreversible) {
#line 6284
        tmp___1 = 2;
      } else {
#line 6284
        tmp___1 = 0;
      }
#line 6284
      tccp___1->qntsty = (OPJ_UINT32 )tmp___1;
#line 6285
      tccp___1->numgbits = (OPJ_UINT32 )2;
#line 6287
      if ((OPJ_INT32 )i == parameters->roi_compno) {
#line 6288
        tccp___1->roishift = parameters->roi_shift;
      } else {
#line 6290
        tccp___1->roishift = 0;
      }
#line 6293
      if (parameters->csty & 1) {
#line 6294
        p = 0;
#line 6295
        it_res = (OPJ_INT32 )(tccp___1->numresolutions - 1U);
        {
#line 6295
        while (1) {
          while_continue___5: /* CIL Label */ ;

#line 6295
          if (! (it_res >= 0)) {
#line 6295
            goto while_break___5;
          }
#line 6296
          if (p < parameters->res_spec) {
#line 6298
            if (parameters->prcw_init[p] < 1) {
#line 6299
              tccp___1->prcw[it_res] = (OPJ_UINT32 )1;
            } else {
              {
#line 6301
              __cil_tmp45 = opj_int_floorlog2(parameters->prcw_init[p]);
#line 6301
              tccp___1->prcw[it_res] = (OPJ_UINT32 )__cil_tmp45;
              }
            }
#line 6304
            if (parameters->prch_init[p] < 1) {
#line 6305
              tccp___1->prch[it_res] = (OPJ_UINT32 )1;
            } else {
              {
#line 6307
              __cil_tmp46 = opj_int_floorlog2(parameters->prch_init[p]);
#line 6307
              tccp___1->prch[it_res] = (OPJ_UINT32 )__cil_tmp46;
              }
            }
          } else {
#line 6311
            res_spec = parameters->res_spec;
#line 6312
            size_prcw = 0;
#line 6313
            size_prch = 0;
#line 6316
            size_prcw = parameters->prcw_init[res_spec - 1] >> (p - (res_spec - 1));
#line 6317
            size_prch = parameters->prch_init[res_spec - 1] >> (p - (res_spec - 1));
#line 6320
            if (size_prcw < 1) {
#line 6321
              tccp___1->prcw[it_res] = (OPJ_UINT32 )1;
            } else {
              {
#line 6323
              __cil_tmp51 = opj_int_floorlog2(size_prcw);
#line 6323
              tccp___1->prcw[it_res] = (OPJ_UINT32 )__cil_tmp51;
              }
            }
#line 6326
            if (size_prch < 1) {
#line 6327
              tccp___1->prch[it_res] = (OPJ_UINT32 )1;
            } else {
              {
#line 6329
              __cil_tmp52 = opj_int_floorlog2(size_prch);
#line 6329
              tccp___1->prch[it_res] = (OPJ_UINT32 )__cil_tmp52;
              }
            }
          }
#line 6332
          p ++;
#line 6295
          __cil_tmp54 = it_res;
#line 6295
          it_res --;
        }
        while_break___13: /* CIL Label */ ;
        }
        while_break___5: ;
      } else {
#line 6336
        j = (OPJ_UINT32 )0;
        {
#line 6336
        while (1) {
          while_continue___6: /* CIL Label */ ;

#line 6336
          if (! (j < tccp___1->numresolutions)) {
#line 6336
            goto while_break___6;
          }
#line 6337
          tccp___1->prcw[j] = (OPJ_UINT32 )15;
#line 6338
          tccp___1->prch[j] = (OPJ_UINT32 )15;
#line 6336
          j ++;
        }
        while_break___14: /* CIL Label */ ;
        }
        while_break___6: ;
      }
      {
#line 6342
      opj_dwt_calc_explicit_stepsizes(tccp___1, (image->comps + i)->prec);
#line 6275
      i ++;
      }
    }
    while_break___12: /* CIL Label */ ;
    }
    while_break___4: 
#line 6185
    tileno ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break: ;
#line 6346
  if (parameters->mct_data) {
    {
#line 6347
    free(parameters->mct_data);
#line 6348
    parameters->mct_data = (void *)0;
    }
  }
#line 6351
  return;
}
}
#line 6352 "/root/patron/new_22/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_add_mhmarker(opj_codestream_index_t *cstr_index , OPJ_UINT32 type ,
                                     OPJ_OFF_T pos , OPJ_UINT32 len ) 
{ 
  opj_marker_info_t *new_marker ;
  void *__cil_tmp7 ;

  {
#line 6357
  if (cstr_index->marknum + 1U > cstr_index->maxmarknum) {
    {
#line 6359
    cstr_index->maxmarknum = (OPJ_UINT32 )(100 + (OPJ_INT32 )((OPJ_FLOAT32 )cstr_index->maxmarknum * 1.f));
#line 6360
    __cil_tmp7 = realloc((void *)cstr_index->marker, (unsigned long )cstr_index->maxmarknum * sizeof(opj_marker_info_t ));
#line 6360
    new_marker = (opj_marker_info_t *)__cil_tmp7;
    }
#line 6361
    if (! new_marker) {
      {
#line 6362
      free((void *)cstr_index->marker);
#line 6363
      cstr_index->marker = (opj_marker_info_t *)((void *)0);
#line 6364
      cstr_index->maxmarknum = (OPJ_UINT32 )0;
#line 6365
      cstr_index->marknum = (OPJ_UINT32 )0;
      }
#line 6367
      return (0);
    }
#line 6369
    cstr_index->marker = new_marker;
  }
#line 6373
  (cstr_index->marker + cstr_index->marknum)->type = (OPJ_UINT16 )type;
#line 6374
  (cstr_index->marker + cstr_index->marknum)->pos = (OPJ_OFF_T )((OPJ_INT32 )pos);
#line 6375
  (cstr_index->marker + cstr_index->marknum)->len = (OPJ_INT32 )len;
#line 6376
  (cstr_index->marknum) ++;
#line 6377
  return (1);
}
}
#line 6380 "/root/patron/new_22/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_add_tlmarker(OPJ_UINT32 tileno , opj_codestream_index_t *cstr_index ,
                                     OPJ_UINT32 type , OPJ_OFF_T pos , OPJ_UINT32 len ) 
{ 
  opj_marker_info_t *new_marker ;
  void *__cil_tmp9 ;
  OPJ_UINT32 l_current_tile_part ;

  {
#line 6386
  if ((cstr_index->tile_index + tileno)->marknum + 1U > (cstr_index->tile_index + tileno)->maxmarknum) {
    {
#line 6388
    (cstr_index->tile_index + tileno)->maxmarknum = (OPJ_UINT32 )(100 + (OPJ_INT32 )((OPJ_FLOAT32 )(cstr_index->tile_index + tileno)->maxmarknum * 1.f));
#line 6389
    __cil_tmp9 = realloc((void *)(cstr_index->tile_index + tileno)->marker, (unsigned long )(cstr_index->tile_index + tileno)->maxmarknum * sizeof(opj_marker_info_t ));
#line 6389
    new_marker = (opj_marker_info_t *)__cil_tmp9;
    }
#line 6392
    if (! new_marker) {
      {
#line 6393
      free((void *)(cstr_index->tile_index + tileno)->marker);
#line 6394
      (cstr_index->tile_index + tileno)->marker = (opj_marker_info_t *)((void *)0);
#line 6395
      (cstr_index->tile_index + tileno)->maxmarknum = (OPJ_UINT32 )0;
#line 6396
      (cstr_index->tile_index + tileno)->marknum = (OPJ_UINT32 )0;
      }
#line 6398
      return (0);
    }
#line 6400
    (cstr_index->tile_index + tileno)->marker = new_marker;
  }
#line 6404
  ((cstr_index->tile_index + tileno)->marker + (cstr_index->tile_index + tileno)->marknum)->type = (OPJ_UINT16 )type;
#line 6405
  ((cstr_index->tile_index + tileno)->marker + (cstr_index->tile_index + tileno)->marknum)->pos = (OPJ_OFF_T )((OPJ_INT32 )pos);
#line 6406
  ((cstr_index->tile_index + tileno)->marker + (cstr_index->tile_index + tileno)->marknum)->len = (OPJ_INT32 )len;
#line 6407
  ((cstr_index->tile_index + tileno)->marknum) ++;
#line 6409
  if (type == 65424U) {
#line 6410
    l_current_tile_part = (cstr_index->tile_index + tileno)->current_tpsno;
#line 6412
    if ((cstr_index->tile_index + tileno)->tp_index) {
#line 6413
      ((cstr_index->tile_index + tileno)->tp_index + l_current_tile_part)->start_pos = pos;
    }
  }
#line 6416
  return (1);
}
}
#line 6425 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_end_decompress(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                opj_event_mgr_t *p_manager ) 
{ 


  {
#line 6433
  return (1);
}
}
#line 6436 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_read_header(opj_stream_private_t *p_stream , opj_j2k_t *p_j2k , opj_image_t **p_image ,
                             opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp9 ;
  OPJ_BOOL __cil_tmp10 ;
  OPJ_BOOL __cil_tmp12 ;

  {
  {
#line 6447
  p_j2k->m_private_image = opj_image_create0();
  }
#line 6448
  if (! p_j2k->m_private_image) {
#line 6449
    return (0);
  }
  {
#line 6453
  opj_j2k_setup_decoding_validation(p_j2k);
#line 6456
  __cil_tmp9 = opj_j2k_exec(p_j2k, p_j2k->m_validation_list, p_stream, p_manager);
  }
#line 6456
  if (! __cil_tmp9) {
    {
#line 6457
    opj_image_destroy(p_j2k->m_private_image);
#line 6458
    p_j2k->m_private_image = (opj_image_t *)((void *)0);
    }
#line 6459
    return (0);
  }
  {
#line 6463
  opj_j2k_setup_header_reading(p_j2k);
#line 6466
  __cil_tmp10 = opj_j2k_exec(p_j2k, p_j2k->m_procedure_list, p_stream, p_manager);
  }
#line 6466
  if (! __cil_tmp10) {
    {
#line 6467
    opj_image_destroy(p_j2k->m_private_image);
#line 6468
    p_j2k->m_private_image = (opj_image_t *)((void *)0);
    }
#line 6469
    return (0);
  }
  {
#line 6472
  *p_image = opj_image_create0();
  }
#line 6473
  if (! *p_image) {
#line 6474
    return (0);
  }
  {
#line 6478
  opj_copy_image_header(p_j2k->m_private_image, *p_image);
#line 6481
  __cil_tmp12 = opj_j2k_allocate_tile_element_cstr_index(p_j2k);
  }
#line 6481
  if (! __cil_tmp12) {
#line 6482
    return (0);
  }
#line 6485
  return (1);
}
}
#line 6488 "/root/patron/new_22/src/lib/openjp2/j2k.c"
void opj_j2k_setup_header_reading(opj_j2k_t *p_j2k ) 
{ 


  {
  {
#line 6493
  opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_read_header_procedure));
#line 6496
  opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_copy_default_tcp_and_create_tcd));
  }
#line 6498
  return;
}
}
#line 6500 "/root/patron/new_22/src/lib/openjp2/j2k.c"
void opj_j2k_setup_decoding_validation(opj_j2k_t *p_j2k ) 
{ 


  {
  {
#line 6505
  opj_procedure_list_add_procedure(p_j2k->m_validation_list, (void (*)(void))(& opj_j2k_build_decoder));
#line 6506
  opj_procedure_list_add_procedure(p_j2k->m_validation_list, (void (*)(void))(& opj_j2k_decoding_validation));
  }
#line 6508
  return;
}
}
#line 6511 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_mct_validation(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL l_is_valid ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 l_nb_tiles ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;

  {
#line 6515
  l_is_valid = 1;
#line 6523
  if (((unsigned int )p_j2k->m_cp.rsiz & 33280U) == 33280U) {
#line 6524
    l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;
#line 6525
    l_tcp = p_j2k->m_cp.tcps;
#line 6527
    i = (OPJ_UINT32 )0;
    {
#line 6527
    while (1) {
      while_continue: /* CIL Label */ ;

#line 6527
      if (! (i < l_nb_tiles)) {
#line 6527
        goto while_break;
      }
#line 6528
      if (l_tcp->mct == 2U) {
#line 6529
        l_tccp = l_tcp->tccps;
#line 6530
        l_is_valid &= (unsigned long )l_tcp->m_mct_coding_matrix != (unsigned long )((OPJ_FLOAT32 *)0);
#line 6532
        j = (OPJ_UINT32 )0;
        {
#line 6532
        while (1) {
          while_continue___0: /* CIL Label */ ;

#line 6532
          if (! (j < (p_j2k->m_private_image)->numcomps)) {
#line 6532
            goto while_break___0;
          }
#line 6533
          l_is_valid &= ! (l_tccp->qmfbid & 1U);
#line 6534
          l_tccp ++;
#line 6532
          j ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        while_break___0: ;
      }
#line 6537
      l_tcp ++;
#line 6527
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 6541
  return (l_is_valid);
}
}
#line 6544 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_setup_mct_encoding(opj_tcp_t *p_tcp , opj_image_t *p_image ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_indix ;
  opj_mct_data_t *l_mct_deco_data ;
  opj_mct_data_t *l_mct_offset_data ;
  opj_simple_mcc_decorrelation_data_t *l_mcc_data ;
  OPJ_UINT32 l_mct_size ;
  OPJ_UINT32 l_nb_elem ;
  OPJ_FLOAT32 *l_data ;
  OPJ_FLOAT32 *l_current_data ;
  opj_tccp_t *l_tccp ;
  opj_mct_data_t *new_mct_records ;
  void *__cil_tmp15 ;
  OPJ_UINT32 __cil_tmp16 ;
  void *__cil_tmp17 ;
  opj_mct_data_t *new_mct_records___0 ;
  void *__cil_tmp19 ;
  OPJ_UINT32 __cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  OPJ_FLOAT32 *__cil_tmp23 ;
  opj_simple_mcc_decorrelation_data_t *new_mcc_records ;
  void *__cil_tmp25 ;
  OPJ_UINT32 __cil_tmp26 ;

  {
#line 6547
  l_indix = (OPJ_UINT32 )1;
#line 6548
  l_mct_deco_data = (opj_mct_data_t *)0;
#line 6548
  l_mct_offset_data = (opj_mct_data_t *)0;
#line 6557
  if (p_tcp->mct != 2U) {
#line 6558
    return (1);
  }
#line 6561
  if (p_tcp->m_mct_decoding_matrix) {
#line 6562
    if (p_tcp->m_nb_mct_records == p_tcp->m_nb_max_mct_records) {
      {
#line 6564
      p_tcp->m_nb_max_mct_records += 10U;
#line 6566
      __cil_tmp15 = realloc((void *)p_tcp->m_mct_records, (unsigned long )p_tcp->m_nb_max_mct_records * sizeof(opj_mct_data_t ));
#line 6566
      new_mct_records = (opj_mct_data_t *)__cil_tmp15;
      }
#line 6567
      if (! new_mct_records) {
        {
#line 6568
        free((void *)p_tcp->m_mct_records);
#line 6569
        p_tcp->m_mct_records = (opj_mct_data_t *)((void *)0);
#line 6570
        p_tcp->m_nb_max_mct_records = (OPJ_UINT32 )0;
#line 6571
        p_tcp->m_nb_mct_records = (OPJ_UINT32 )0;
        }
#line 6573
        return (0);
      }
      {
#line 6575
      p_tcp->m_mct_records = new_mct_records;
#line 6576
      l_mct_deco_data = p_tcp->m_mct_records + p_tcp->m_nb_mct_records;
#line 6578
      memset((void *)l_mct_deco_data, 0, (unsigned long )(p_tcp->m_nb_max_mct_records - p_tcp->m_nb_mct_records) * sizeof(opj_mct_data_t ));
      }
    }
#line 6580
    l_mct_deco_data = p_tcp->m_mct_records + p_tcp->m_nb_mct_records;
#line 6582
    if (l_mct_deco_data->m_data) {
      {
#line 6583
      free((void *)l_mct_deco_data->m_data);
#line 6584
      l_mct_deco_data->m_data = (OPJ_BYTE *)0;
      }
    }
    {
#line 6587
    __cil_tmp16 = l_indix;
#line 6587
    l_indix ++;
#line 6587
    l_mct_deco_data->m_index = __cil_tmp16;
#line 6588
    l_mct_deco_data->m_array_type = (J2K_MCT_ARRAY_TYPE )1;
#line 6589
    l_mct_deco_data->m_element_type = (J2K_MCT_ELEMENT_TYPE )2;
#line 6590
    l_nb_elem = p_image->numcomps * p_image->numcomps;
#line 6591
    l_mct_size = l_nb_elem * MCT_ELEMENT_SIZE[l_mct_deco_data->m_element_type];
#line 6592
    __cil_tmp17 = malloc((unsigned long )l_mct_size);
#line 6592
    l_mct_deco_data->m_data = (OPJ_BYTE *)__cil_tmp17;
    }
#line 6594
    if (! l_mct_deco_data->m_data) {
#line 6595
      return (0);
    }
    {
#line 6598
    (*(j2k_mct_write_functions_from_float[l_mct_deco_data->m_element_type]))((void const   *)p_tcp->m_mct_decoding_matrix,
                                                                             (void *)l_mct_deco_data->m_data,
                                                                             l_nb_elem);
#line 6600
    l_mct_deco_data->m_data_size = l_mct_size;
#line 6601
    (p_tcp->m_nb_mct_records) ++;
    }
  }
#line 6604
  if (p_tcp->m_nb_mct_records == p_tcp->m_nb_max_mct_records) {
    {
#line 6606
    p_tcp->m_nb_max_mct_records += 10U;
#line 6607
    __cil_tmp19 = realloc((void *)p_tcp->m_mct_records, (unsigned long )p_tcp->m_nb_max_mct_records * sizeof(opj_mct_data_t ));
#line 6607
    new_mct_records___0 = (opj_mct_data_t *)__cil_tmp19;
    }
#line 6608
    if (! new_mct_records___0) {
      {
#line 6609
      free((void *)p_tcp->m_mct_records);
#line 6610
      p_tcp->m_mct_records = (opj_mct_data_t *)((void *)0);
#line 6611
      p_tcp->m_nb_max_mct_records = (OPJ_UINT32 )0;
#line 6612
      p_tcp->m_nb_mct_records = (OPJ_UINT32 )0;
      }
#line 6614
      return (0);
    }
    {
#line 6616
    p_tcp->m_mct_records = new_mct_records___0;
#line 6617
    l_mct_offset_data = p_tcp->m_mct_records + p_tcp->m_nb_mct_records;
#line 6619
    memset((void *)l_mct_offset_data, 0, (unsigned long )(p_tcp->m_nb_max_mct_records - p_tcp->m_nb_mct_records) * sizeof(opj_mct_data_t ));
    }
#line 6621
    if (l_mct_deco_data) {
#line 6622
      l_mct_deco_data = l_mct_offset_data - 1;
    }
  }
#line 6626
  l_mct_offset_data = p_tcp->m_mct_records + p_tcp->m_nb_mct_records;
#line 6628
  if (l_mct_offset_data->m_data) {
    {
#line 6629
    free((void *)l_mct_offset_data->m_data);
#line 6630
    l_mct_offset_data->m_data = (OPJ_BYTE *)0;
    }
  }
  {
#line 6633
  __cil_tmp20 = l_indix;
#line 6633
  l_indix ++;
#line 6633
  l_mct_offset_data->m_index = __cil_tmp20;
#line 6634
  l_mct_offset_data->m_array_type = (J2K_MCT_ARRAY_TYPE )2;
#line 6635
  l_mct_offset_data->m_element_type = (J2K_MCT_ELEMENT_TYPE )2;
#line 6636
  l_nb_elem = p_image->numcomps;
#line 6637
  l_mct_size = l_nb_elem * MCT_ELEMENT_SIZE[l_mct_offset_data->m_element_type];
#line 6638
  __cil_tmp21 = malloc((unsigned long )l_mct_size);
#line 6638
  l_mct_offset_data->m_data = (OPJ_BYTE *)__cil_tmp21;
  }
#line 6640
  if (! l_mct_offset_data->m_data) {
#line 6641
    return (0);
  }
  {
#line 6644
  __cil_tmp22 = malloc((unsigned long )l_nb_elem * sizeof(OPJ_FLOAT32 ));
#line 6644
  l_data = (OPJ_FLOAT32 *)__cil_tmp22;
  }
#line 6645
  if (! l_data) {
    {
#line 6646
    free((void *)l_mct_offset_data->m_data);
#line 6647
    l_mct_offset_data->m_data = (OPJ_BYTE *)0;
    }
#line 6648
    return (0);
  }
#line 6651
  l_tccp = p_tcp->tccps;
#line 6652
  l_current_data = l_data;
#line 6654
  i = (OPJ_UINT32 )0;
  {
#line 6654
  while (1) {
    while_continue: /* CIL Label */ ;

#line 6654
    if (! (i < l_nb_elem)) {
#line 6654
      goto while_break;
    }
#line 6655
    __cil_tmp23 = l_current_data;
#line 6655
    l_current_data ++;
#line 6655
    *__cil_tmp23 = (OPJ_FLOAT32 )l_tccp->m_dc_level_shift;
#line 6656
    l_tccp ++;
#line 6654
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 6659
  (*(j2k_mct_write_functions_from_float[l_mct_offset_data->m_element_type]))((void const   *)l_data,
                                                                             (void *)l_mct_offset_data->m_data,
                                                                             l_nb_elem);
#line 6661
  free((void *)l_data);
#line 6663
  l_mct_offset_data->m_data_size = l_mct_size;
#line 6665
  (p_tcp->m_nb_mct_records) ++;
  }
#line 6667
  if (p_tcp->m_nb_mcc_records == p_tcp->m_nb_max_mcc_records) {
    {
#line 6669
    p_tcp->m_nb_max_mcc_records += 10U;
#line 6670
    __cil_tmp25 = realloc((void *)p_tcp->m_mcc_records, (unsigned long )p_tcp->m_nb_max_mcc_records * sizeof(opj_simple_mcc_decorrelation_data_t ));
#line 6670
    new_mcc_records = (opj_simple_mcc_decorrelation_data_t *)__cil_tmp25;
    }
#line 6672
    if (! new_mcc_records) {
      {
#line 6673
      free((void *)p_tcp->m_mcc_records);
#line 6674
      p_tcp->m_mcc_records = (opj_simple_mcc_decorrelation_data_t *)((void *)0);
#line 6675
      p_tcp->m_nb_max_mcc_records = (OPJ_UINT32 )0;
#line 6676
      p_tcp->m_nb_mcc_records = (OPJ_UINT32 )0;
      }
#line 6678
      return (0);
    }
    {
#line 6680
    p_tcp->m_mcc_records = new_mcc_records;
#line 6681
    l_mcc_data = p_tcp->m_mcc_records + p_tcp->m_nb_mcc_records;
#line 6682
    memset((void *)l_mcc_data, 0, (unsigned long )(p_tcp->m_nb_max_mcc_records - p_tcp->m_nb_mcc_records) * sizeof(opj_simple_mcc_decorrelation_data_t ));
    }
  }
#line 6686
  l_mcc_data = p_tcp->m_mcc_records + p_tcp->m_nb_mcc_records;
#line 6687
  l_mcc_data->m_decorrelation_array = l_mct_deco_data;
#line 6688
  l_mcc_data->m_is_irreversible = (OPJ_UINT32 )1;
#line 6689
  l_mcc_data->m_nb_comps = p_image->numcomps;
#line 6690
  __cil_tmp26 = l_indix;
#line 6690
  l_indix ++;
#line 6690
  l_mcc_data->m_index = __cil_tmp26;
#line 6691
  l_mcc_data->m_offset_array = l_mct_offset_data;
#line 6692
  (p_tcp->m_nb_mcc_records) ++;
#line 6694
  return (1);
}
}
#line 6697 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_build_decoder(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                               opj_event_mgr_t *p_manager ) 
{ 


  {
#line 6706
  return (1);
}
}
#line 6709 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_build_encoder(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                               opj_event_mgr_t *p_manager ) 
{ 


  {
#line 6718
  return (1);
}
}
#line 6721 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_encoding_validation(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                     opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL l_is_valid ;

  {
#line 6725
  l_is_valid = 1;
#line 6734
  l_is_valid &= p_j2k->m_specific_param.m_decoder.m_state == 0U;
#line 6738
  l_is_valid &= (unsigned long )p_j2k->m_procedure_list != (unsigned long )((opj_procedure_list_t *)0);
#line 6740
  l_is_valid &= (unsigned long )p_j2k->m_validation_list != (unsigned long )((opj_procedure_list_t *)0);
#line 6742
  if (p_j2k->m_cp.tdx < (OPJ_UINT32 )(1 << ((p_j2k->m_cp.tcps)->tccps)->numresolutions)) {
    {
#line 6743
    opj_event_msg(p_manager, 1, "Number of resolutions is too high in comparison to the size of tiles\n");
    }
#line 6744
    return (0);
  }
#line 6747
  if (p_j2k->m_cp.tdy < (OPJ_UINT32 )(1 << ((p_j2k->m_cp.tcps)->tccps)->numresolutions)) {
    {
#line 6748
    opj_event_msg(p_manager, 1, "Number of resolutions is too high in comparison to the size of tiles\nU");
    }
#line 6749
    return (0);
  }
#line 6753
  return (l_is_valid);
}
}
#line 6756 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_decoding_validation(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                     opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL l_is_valid ;

  {
#line 6761
  l_is_valid = 1;
#line 6773
  l_is_valid &= p_j2k->m_specific_param.m_decoder.m_state == 0U;
#line 6778
  l_is_valid &= (unsigned long )p_j2k->m_procedure_list != (unsigned long )((opj_procedure_list_t *)0);
#line 6780
  l_is_valid &= (unsigned long )p_j2k->m_validation_list != (unsigned long )((opj_procedure_list_t *)0);
#line 6783
  return (l_is_valid);
}
}
#line 6786 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_read_header_procedure(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                       opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_current_marker ;
  OPJ_UINT32 l_marker_size ;
  opj_dec_memory_marker_handler_t *l_marker_handler ;
  OPJ_BOOL __cil_tmp10 ;
  OPJ_SIZE_T __cil_tmp11 ;
  OPJ_BOOL __cil_tmp13 ;
  OPJ_SIZE_T __cil_tmp15 ;
  OPJ_BYTE *new_header_data ;
  void *__cil_tmp17 ;
  OPJ_SIZE_T __cil_tmp18 ;
  OPJ_BOOL __cil_tmp19 ;
  OPJ_OFF_T __cil_tmp20 ;
  OPJ_BOOL __cil_tmp21 ;
  OPJ_SIZE_T __cil_tmp22 ;
  OPJ_OFF_T __cil_tmp23 ;

  {
  {
#line 6792
  l_marker_handler = (opj_dec_memory_marker_handler_t *)0;
#line 6800
  p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )1;
#line 6803
  __cil_tmp10 = opj_j2k_read_soc(p_j2k, p_stream, p_manager);
  }
#line 6803
  if (! __cil_tmp10) {
    {
#line 6804
    opj_event_msg(p_manager, 1, "Expected a SOC marker \n");
    }
#line 6805
    return (0);
  }
  {
#line 6809
  __cil_tmp11 = opj_stream_read_data(p_stream, p_j2k->m_specific_param.m_decoder.m_header_data,
                                     (OPJ_SIZE_T )2, p_manager);
  }
#line 6809
  if (__cil_tmp11 != 2UL) {
    {
#line 6810
    opj_event_msg(p_manager, 1, "Stream too short\nf\323\211\202U");
    }
#line 6811
    return (0);
  }
  {
#line 6815
  opj_read_bytes_LE(p_j2k->m_specific_param.m_decoder.m_header_data, & l_current_marker,
                    (OPJ_UINT32 )2);
  }
  {
#line 6818
  while (1) {
    while_continue: /* CIL Label */ ;

#line 6818
    if (! (l_current_marker != 65424U)) {
#line 6818
      goto while_break;
    }
#line 6821
    if (l_current_marker < 65280U) {
      {
#line 6822
      opj_event_msg(p_manager, 1, "We expected read a marker ID (0xff--) instead of %.8x\n",
                    l_current_marker);
      }
#line 6823
      return (0);
    }
    {
#line 6827
    l_marker_handler = opj_j2k_get_marker_handler(l_current_marker);
    }
#line 6830
    if (l_marker_handler->id == 0U) {
      {
#line 6831
      __cil_tmp13 = opj_j2k_read_unk(p_j2k, p_stream, & l_current_marker, p_manager);
      }
#line 6831
      if (! __cil_tmp13) {
        {
#line 6832
        opj_event_msg(p_manager, 1, "Unknow marker have been detected and generated error.\n");
        }
#line 6833
        return (0);
      }
#line 6836
      if (l_current_marker == 65424U) {
#line 6837
        goto while_break;
      } else {
        {
#line 6839
        l_marker_handler = opj_j2k_get_marker_handler(l_current_marker);
        }
      }
    }
#line 6843
    if (! (p_j2k->m_specific_param.m_decoder.m_state & l_marker_handler->states)) {
      {
#line 6844
      opj_event_msg(p_manager, 1, "Marker is not compliant with its position\n\322\211\202U");
      }
#line 6845
      return (0);
    }
    {
#line 6849
    __cil_tmp15 = opj_stream_read_data(p_stream, p_j2k->m_specific_param.m_decoder.m_header_data,
                                       (OPJ_SIZE_T )2, p_manager);
    }
#line 6849
    if (__cil_tmp15 != 2UL) {
      {
#line 6850
      opj_event_msg(p_manager, 1, "Stream too short\n");
      }
#line 6851
      return (0);
    }
    {
#line 6855
    opj_read_bytes_LE(p_j2k->m_specific_param.m_decoder.m_header_data, & l_marker_size,
                      (OPJ_UINT32 )2);
#line 6856
    l_marker_size -= 2U;
    }
#line 6859
    if (l_marker_size > p_j2k->m_specific_param.m_decoder.m_header_data_size) {
      {
#line 6860
      __cil_tmp17 = realloc((void *)p_j2k->m_specific_param.m_decoder.m_header_data,
                            (unsigned long )l_marker_size);
#line 6860
      new_header_data = (OPJ_BYTE *)__cil_tmp17;
      }
#line 6861
      if (! new_header_data) {
        {
#line 6862
        free((void *)p_j2k->m_specific_param.m_decoder.m_header_data);
#line 6863
        p_j2k->m_specific_param.m_decoder.m_header_data = (OPJ_BYTE *)((void *)0);
#line 6864
        p_j2k->m_specific_param.m_decoder.m_header_data_size = (OPJ_UINT32 )0;
#line 6865
        opj_event_msg(p_manager, 1, "Not enough memory to read header\n");
        }
#line 6866
        return (0);
      }
#line 6868
      p_j2k->m_specific_param.m_decoder.m_header_data = new_header_data;
#line 6869
      p_j2k->m_specific_param.m_decoder.m_header_data_size = l_marker_size;
    }
    {
#line 6873
    __cil_tmp18 = opj_stream_read_data(p_stream, p_j2k->m_specific_param.m_decoder.m_header_data,
                                       (OPJ_SIZE_T )l_marker_size, p_manager);
    }
#line 6873
    if (__cil_tmp18 != (unsigned long )l_marker_size) {
      {
#line 6874
      opj_event_msg(p_manager, 1, "Stream too short\n");
      }
#line 6875
      return (0);
    }
    {
#line 6879
    __cil_tmp19 = (*(l_marker_handler->handler))(p_j2k, p_j2k->m_specific_param.m_decoder.m_header_data,
                                                 l_marker_size, p_manager);
    }
#line 6879
    if (! __cil_tmp19) {
      {
#line 6880
      opj_event_msg(p_manager, 1, "Marker handler function failed to read the marker segment\n");
      }
#line 6881
      return (0);
    }
    {
#line 6885
    __cil_tmp20 = opj_stream_tell(p_stream);
#line 6885
    __cil_tmp21 = opj_j2k_add_mhmarker(p_j2k->cstr_index, l_marker_handler->id, (OPJ_OFF_T )(((OPJ_UINT32 )__cil_tmp20 - l_marker_size) - 4U),
                                       l_marker_size + 4U);
    }
#line 6885
    if (0 == __cil_tmp21) {
      {
#line 6890
      opj_event_msg(p_manager, 1, "Not enough memory to add mh marker\n");
      }
#line 6891
      return (0);
    }
    {
#line 6895
    __cil_tmp22 = opj_stream_read_data(p_stream, p_j2k->m_specific_param.m_decoder.m_header_data,
                                       (OPJ_SIZE_T )2, p_manager);
    }
#line 6895
    if (__cil_tmp22 != 2UL) {
      {
#line 6896
      opj_event_msg(p_manager, 1, "Stream too short\n");
      }
#line 6897
      return (0);
    }
    {
#line 6901
    opj_read_bytes_LE(p_j2k->m_specific_param.m_decoder.m_header_data, & l_current_marker,
                      (OPJ_UINT32 )2);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 6904
  opj_event_msg(p_manager, 4, "Main header has been correctly decoded.\n\220");
#line 6907
  __cil_tmp23 = opj_stream_tell(p_stream);
#line 6907
  (p_j2k->cstr_index)->main_head_end = (OPJ_OFF_T )((OPJ_UINT32 )__cil_tmp23 - 2U);
#line 6910
  p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )8;
  }
#line 6912
  return (1);
}
}
#line 6915 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_exec(opj_j2k_t *p_j2k , opj_procedure_list_t *p_procedure_list ,
                      opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL (**l_procedure)(opj_j2k_t * , opj_stream_private_t * , opj_event_mgr_t * ) ;
  OPJ_BOOL l_result ;
  OPJ_UINT32 l_nb_proc ;
  OPJ_UINT32 i ;
  opj_procedure *__cil_tmp14 ;
  OPJ_BOOL __cil_tmp15 ;
  int tmp___3 ;

  {
  {
#line 6920
  l_procedure = (OPJ_BOOL (**)(opj_j2k_t * , opj_stream_private_t * , opj_event_mgr_t * ))0;
#line 6921
  l_result = 1;
#line 6930
  l_nb_proc = opj_procedure_list_get_nb_procedures(p_procedure_list);
#line 6931
  __cil_tmp14 = opj_procedure_list_get_first_procedure(p_procedure_list);
#line 6931
  l_procedure = (OPJ_BOOL (**)(opj_j2k_t * , opj_stream_private_t * , opj_event_mgr_t * ))__cil_tmp14;
#line 6933
  i = (OPJ_UINT32 )0;
  }
  {
#line 6933
  while (1) {
    while_continue: /* CIL Label */ ;

#line 6933
    if (! (i < l_nb_proc)) {
#line 6933
      goto while_break;
    }
    {
#line 6934
    __cil_tmp15 = (*(*l_procedure))(p_j2k, p_stream, p_manager);
    }
#line 6934
    if (l_result) {
#line 6934
      if (__cil_tmp15) {
#line 6934
        tmp___3 = 1;
      } else {
#line 6934
        tmp___3 = 0;
      }
    } else {
#line 6934
      tmp___3 = 0;
    }
#line 6934
    l_result = tmp___3;
#line 6935
    l_procedure ++;
#line 6933
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 6939
  opj_procedure_list_clear(p_procedure_list);
  }
#line 6940
  return (l_result);
}
}
#line 6944 "/root/patron/new_22/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_copy_default_tcp_and_create_tcd(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                                        opj_event_mgr_t *p_manager ) 
{ 
  opj_tcp_t *l_tcp ;
  opj_tcp_t *l_default_tcp ;
  OPJ_UINT32 l_nb_tiles ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  opj_tccp_t *l_current_tccp ;
  OPJ_UINT32 l_tccp_size ;
  OPJ_UINT32 l_mct_size ;
  opj_image_t *l_image ;
  OPJ_UINT32 l_mcc_records_size ;
  OPJ_UINT32 l_mct_records_size ;
  opj_mct_data_t *l_src_mct_rec ;
  opj_mct_data_t *l_dest_mct_rec ;
  opj_simple_mcc_decorrelation_data_t *l_src_mcc_rec ;
  opj_simple_mcc_decorrelation_data_t *l_dest_mcc_rec ;
  OPJ_UINT32 l_offset ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  opj_tcd_t *__cil_tmp27 ;
  OPJ_BOOL __cil_tmp28 ;

  {
#line 6949
  l_tcp = (opj_tcp_t *)0;
#line 6950
  l_default_tcp = (opj_tcp_t *)0;
#line 6953
  l_current_tccp = (opj_tccp_t *)0;
#line 6967
  l_image = p_j2k->m_private_image;
#line 6968
  l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;
#line 6969
  l_tcp = p_j2k->m_cp.tcps;
#line 6970
  l_tccp_size = (OPJ_UINT32 )((unsigned long )l_image->numcomps * sizeof(opj_tccp_t ));
#line 6971
  l_default_tcp = p_j2k->m_specific_param.m_decoder.m_default_tcp;
#line 6972
  l_mct_size = (OPJ_UINT32 )((unsigned long )(l_image->numcomps * l_image->numcomps) * sizeof(OPJ_FLOAT32 ));
#line 6975
  i = (OPJ_UINT32 )0;
  {
#line 6975
  while (1) {
    while_continue: /* CIL Label */ ;

#line 6975
    if (! (i < l_nb_tiles)) {
#line 6975
      goto while_break;
    }
    {
#line 6977
    l_current_tccp = l_tcp->tccps;
#line 6979
    memcpy((void *)l_tcp, (void const   *)l_default_tcp, sizeof(opj_tcp_t ));
#line 6981
    l_tcp->ppt = (OPJ_UINT32 )0;
#line 6982
    l_tcp->ppt_data = (OPJ_BYTE *)0;
#line 6984
    l_tcp->tccps = l_current_tccp;
    }
#line 6987
    if (l_default_tcp->m_mct_decoding_matrix) {
      {
#line 6988
      __cil_tmp23 = malloc((unsigned long )l_mct_size);
#line 6988
      l_tcp->m_mct_decoding_matrix = (OPJ_FLOAT32 *)__cil_tmp23;
      }
#line 6989
      if (! l_tcp->m_mct_decoding_matrix) {
#line 6990
        return (0);
      }
      {
#line 6992
      memcpy((void *)l_tcp->m_mct_decoding_matrix, (void const   *)l_default_tcp->m_mct_decoding_matrix,
             (unsigned long )l_mct_size);
      }
    }
    {
#line 6996
    l_mct_records_size = (OPJ_UINT32 )((unsigned long )l_default_tcp->m_nb_max_mct_records * sizeof(opj_mct_data_t ));
#line 6997
    __cil_tmp24 = malloc((unsigned long )l_mct_records_size);
#line 6997
    l_tcp->m_mct_records = (opj_mct_data_t *)__cil_tmp24;
    }
#line 6998
    if (! l_tcp->m_mct_records) {
#line 6999
      return (0);
    }
    {
#line 7001
    memcpy((void *)l_tcp->m_mct_records, (void const   *)l_default_tcp->m_mct_records,
           (unsigned long )l_mct_records_size);
#line 7004
    l_src_mct_rec = l_default_tcp->m_mct_records;
#line 7005
    l_dest_mct_rec = l_tcp->m_mct_records;
#line 7007
    j = (OPJ_UINT32 )0;
    }
    {
#line 7007
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 7007
      if (! (j < l_default_tcp->m_nb_mct_records)) {
#line 7007
        goto while_break___0;
      }
#line 7009
      if (l_src_mct_rec->m_data) {
        {
#line 7011
        __cil_tmp25 = malloc((unsigned long )l_src_mct_rec->m_data_size);
#line 7011
        l_dest_mct_rec->m_data = (OPJ_BYTE *)__cil_tmp25;
        }
#line 7012
        if (! l_dest_mct_rec->m_data) {
#line 7013
          return (0);
        }
        {
#line 7015
        memcpy((void *)l_dest_mct_rec->m_data, (void const   *)l_src_mct_rec->m_data,
               (unsigned long )l_src_mct_rec->m_data_size);
        }
      }
#line 7018
      l_src_mct_rec ++;
#line 7019
      l_dest_mct_rec ++;
#line 7007
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 7023
    l_mcc_records_size = (OPJ_UINT32 )((unsigned long )l_default_tcp->m_nb_max_mcc_records * sizeof(opj_simple_mcc_decorrelation_data_t ));
#line 7024
    __cil_tmp26 = malloc((unsigned long )l_mcc_records_size);
#line 7024
    l_tcp->m_mcc_records = (opj_simple_mcc_decorrelation_data_t *)__cil_tmp26;
    }
#line 7025
    if (! l_tcp->m_mcc_records) {
#line 7026
      return (0);
    }
    {
#line 7028
    memcpy((void *)l_tcp->m_mcc_records, (void const   *)l_default_tcp->m_mcc_records,
           (unsigned long )l_mcc_records_size);
#line 7031
    l_src_mcc_rec = l_default_tcp->m_mcc_records;
#line 7032
    l_dest_mcc_rec = l_tcp->m_mcc_records;
#line 7034
    j = (OPJ_UINT32 )0;
    }
    {
#line 7034
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 7034
      if (! (j < l_default_tcp->m_nb_max_mcc_records)) {
#line 7034
        goto while_break___1;
      }
#line 7036
      if (l_src_mcc_rec->m_decorrelation_array) {
#line 7037
        l_offset = (OPJ_UINT32 )(l_src_mcc_rec->m_decorrelation_array - l_default_tcp->m_mct_records);
#line 7038
        l_dest_mcc_rec->m_decorrelation_array = l_tcp->m_mct_records + l_offset;
      }
#line 7041
      if (l_src_mcc_rec->m_offset_array) {
#line 7042
        l_offset = (OPJ_UINT32 )(l_src_mcc_rec->m_offset_array - l_default_tcp->m_mct_records);
#line 7043
        l_dest_mcc_rec->m_offset_array = l_tcp->m_mct_records + l_offset;
      }
#line 7046
      l_src_mcc_rec ++;
#line 7047
      l_dest_mcc_rec ++;
#line 7034
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: 
    {
#line 7051
    memcpy((void *)l_current_tccp, (void const   *)l_default_tcp->tccps, (unsigned long )l_tccp_size);
#line 7054
    l_tcp ++;
#line 6975
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
  {
#line 7058
  __cil_tmp27 = opj_tcd_create(1);
#line 7058
  p_j2k->m_tcd = __cil_tmp27;
  }
#line 7059
  if (! p_j2k->m_tcd) {
#line 7060
    return (0);
  }
  {
#line 7063
  __cil_tmp28 = opj_tcd_init(p_j2k->m_tcd, l_image, & p_j2k->m_cp);
  }
#line 7063
  if (! __cil_tmp28) {
    {
#line 7064
    opj_tcd_destroy(p_j2k->m_tcd);
#line 7065
    p_j2k->m_tcd = (struct opj_tcd *)0;
#line 7066
    opj_event_msg(p_manager, 1, "Cannot decode tile, memory error\n");
    }
#line 7067
    return (0);
  }
#line 7070
  return (1);
}
}
#line 7073 "/root/patron/new_22/src/lib/openjp2/j2k.c"
struct opj_dec_memory_marker_handler *opj_j2k_get_marker_handler(OPJ_UINT32 p_id ) 
{ 
  opj_dec_memory_marker_handler_t *e ;

  {
#line 7076
  e = j2k_memory_marker_handler_tab;
  {
#line 7076
  while (1) {
    while_continue: /* CIL Label */ ;

#line 7076
    if (! (e->id != 0U)) {
#line 7076
      goto while_break;
    }
#line 7077
    if (e->id == p_id) {
#line 7078
      goto while_break;
    }
#line 7076
    e ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 7081
  return (e);
}
}
#line 7084 "/root/patron/new_22/src/lib/openjp2/j2k.c"
void opj_j2k_destroy(opj_j2k_t *p_j2k ) 
{ 


  {
#line 7086
  if ((unsigned long )p_j2k == (unsigned long )((opj_j2k_t *)0)) {
#line 7087
    return;
  }
#line 7090
  if (p_j2k->m_is_decoder) {
#line 7092
    if ((unsigned long )p_j2k->m_specific_param.m_decoder.m_default_tcp != (unsigned long )((opj_tcp_t *)0)) {
      {
#line 7093
      opj_j2k_tcp_destroy(p_j2k->m_specific_param.m_decoder.m_default_tcp);
#line 7094
      free((void *)p_j2k->m_specific_param.m_decoder.m_default_tcp);
#line 7095
      p_j2k->m_specific_param.m_decoder.m_default_tcp = (opj_tcp_t *)0;
      }
    }
#line 7098
    if ((unsigned long )p_j2k->m_specific_param.m_decoder.m_header_data != (unsigned long )((OPJ_BYTE *)0)) {
      {
#line 7099
      free((void *)p_j2k->m_specific_param.m_decoder.m_header_data);
#line 7100
      p_j2k->m_specific_param.m_decoder.m_header_data = (OPJ_BYTE *)0;
#line 7101
      p_j2k->m_specific_param.m_decoder.m_header_data_size = (OPJ_UINT32 )0;
      }
    }
  } else {
#line 7106
    if (p_j2k->m_specific_param.m_encoder.m_encoded_tile_data) {
      {
#line 7107
      free((void *)p_j2k->m_specific_param.m_encoder.m_encoded_tile_data);
#line 7108
      p_j2k->m_specific_param.m_encoder.m_encoded_tile_data = (OPJ_BYTE *)0;
      }
    }
#line 7111
    if (p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer) {
      {
#line 7112
      free((void *)p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer);
#line 7113
      p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer = (OPJ_BYTE *)0;
#line 7114
      p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current = (OPJ_BYTE *)0;
      }
    }
#line 7117
    if (p_j2k->m_specific_param.m_encoder.m_header_tile_data) {
      {
#line 7118
      free((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 7119
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)0;
#line 7120
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
      }
    }
  }
  {
#line 7124
  opj_tcd_destroy(p_j2k->m_tcd);
#line 7126
  opj_j2k_cp_destroy(& p_j2k->m_cp);
#line 7127
  memset((void *)(& p_j2k->m_cp), 0, sizeof(opj_cp_t ));
#line 7129
  opj_procedure_list_destroy(p_j2k->m_procedure_list);
#line 7130
  p_j2k->m_procedure_list = (opj_procedure_list_t *)0;
#line 7132
  opj_procedure_list_destroy(p_j2k->m_validation_list);
#line 7133
  p_j2k->m_procedure_list = (opj_procedure_list_t *)0;
#line 7135
  j2k_destroy_cstr_index(p_j2k->cstr_index);
#line 7136
  p_j2k->cstr_index = (opj_codestream_index_t *)((void *)0);
#line 7138
  opj_image_destroy(p_j2k->m_private_image);
#line 7139
  p_j2k->m_private_image = (opj_image_t *)((void *)0);
#line 7141
  opj_image_destroy(p_j2k->m_output_image);
#line 7142
  p_j2k->m_output_image = (opj_image_t *)((void *)0);
#line 7144
  free((void *)p_j2k);
  }
#line 7146
  return;
}
}
#line 7147 "/root/patron/new_22/src/lib/openjp2/j2k.c"
void j2k_destroy_cstr_index(opj_codestream_index_t *p_cstr_ind ) 
{ 
  OPJ_UINT32 it_tile ;

  {
#line 7149
  if (p_cstr_ind) {
#line 7151
    if (p_cstr_ind->marker) {
      {
#line 7152
      free((void *)p_cstr_ind->marker);
#line 7153
      p_cstr_ind->marker = (opj_marker_info_t *)((void *)0);
      }
    }
#line 7156
    if (p_cstr_ind->tile_index) {
#line 7157
      it_tile = (OPJ_UINT32 )0;
#line 7159
      it_tile = (OPJ_UINT32 )0;
      {
#line 7159
      while (1) {
        while_continue: /* CIL Label */ ;

#line 7159
        if (! (it_tile < p_cstr_ind->nb_of_tiles)) {
#line 7159
          goto while_break;
        }
#line 7161
        if ((p_cstr_ind->tile_index + it_tile)->packet_index) {
          {
#line 7162
          free((void *)(p_cstr_ind->tile_index + it_tile)->packet_index);
#line 7163
          (p_cstr_ind->tile_index + it_tile)->packet_index = (opj_packet_info_t *)((void *)0);
          }
        }
#line 7166
        if ((p_cstr_ind->tile_index + it_tile)->tp_index) {
          {
#line 7167
          free((void *)(p_cstr_ind->tile_index + it_tile)->tp_index);
#line 7168
          (p_cstr_ind->tile_index + it_tile)->tp_index = (opj_tp_index_t *)((void *)0);
          }
        }
#line 7171
        if ((p_cstr_ind->tile_index + it_tile)->marker) {
          {
#line 7172
          free((void *)(p_cstr_ind->tile_index + it_tile)->marker);
#line 7173
          (p_cstr_ind->tile_index + it_tile)->marker = (opj_marker_info_t *)((void *)0);
          }
        }
#line 7159
        it_tile ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: 
      {
#line 7178
      free((void *)p_cstr_ind->tile_index);
#line 7179
      p_cstr_ind->tile_index = (opj_tile_index_t *)((void *)0);
      }
    }
    {
#line 7182
    free((void *)p_cstr_ind);
    }
  }
#line 7185
  return;
}
}
#line 7186 "/root/patron/new_22/src/lib/openjp2/j2k.c"
void opj_j2k_tcp_destroy(opj_tcp_t *p_tcp ) 
{ 
  opj_mct_data_t *l_mct_data ;
  OPJ_UINT32 i ;

  {
#line 7188
  if ((unsigned long )p_tcp == (unsigned long )((opj_tcp_t *)0)) {
#line 7189
    return;
  }
#line 7192
  if ((unsigned long )p_tcp->ppt_buffer != (unsigned long )((OPJ_BYTE *)0)) {
    {
#line 7193
    free((void *)p_tcp->ppt_buffer);
#line 7194
    p_tcp->ppt_buffer = (OPJ_BYTE *)0;
    }
  }
#line 7197
  if ((unsigned long )p_tcp->tccps != (unsigned long )((opj_tccp_t *)0)) {
    {
#line 7198
    free((void *)p_tcp->tccps);
#line 7199
    p_tcp->tccps = (opj_tccp_t *)0;
    }
  }
#line 7202
  if ((unsigned long )p_tcp->m_mct_coding_matrix != (unsigned long )((OPJ_FLOAT32 *)0)) {
    {
#line 7203
    free((void *)p_tcp->m_mct_coding_matrix);
#line 7204
    p_tcp->m_mct_coding_matrix = (OPJ_FLOAT32 *)0;
    }
  }
#line 7207
  if ((unsigned long )p_tcp->m_mct_decoding_matrix != (unsigned long )((OPJ_FLOAT32 *)0)) {
    {
#line 7208
    free((void *)p_tcp->m_mct_decoding_matrix);
#line 7209
    p_tcp->m_mct_decoding_matrix = (OPJ_FLOAT32 *)0;
    }
  }
#line 7212
  if (p_tcp->m_mcc_records) {
    {
#line 7213
    free((void *)p_tcp->m_mcc_records);
#line 7214
    p_tcp->m_mcc_records = (opj_simple_mcc_decorrelation_data_t *)0;
#line 7215
    p_tcp->m_nb_max_mcc_records = (OPJ_UINT32 )0;
#line 7216
    p_tcp->m_nb_mcc_records = (OPJ_UINT32 )0;
    }
  }
#line 7219
  if (p_tcp->m_mct_records) {
#line 7220
    l_mct_data = p_tcp->m_mct_records;
#line 7223
    i = (OPJ_UINT32 )0;
    {
#line 7223
    while (1) {
      while_continue: /* CIL Label */ ;

#line 7223
      if (! (i < p_tcp->m_nb_mct_records)) {
#line 7223
        goto while_break;
      }
#line 7224
      if (l_mct_data->m_data) {
        {
#line 7225
        free((void *)l_mct_data->m_data);
#line 7226
        l_mct_data->m_data = (OPJ_BYTE *)0;
        }
      }
#line 7229
      l_mct_data ++;
#line 7223
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: 
    {
#line 7232
    free((void *)p_tcp->m_mct_records);
#line 7233
    p_tcp->m_mct_records = (opj_mct_data_t *)0;
    }
  }
#line 7236
  if ((unsigned long )p_tcp->mct_norms != (unsigned long )((OPJ_FLOAT64 *)0)) {
    {
#line 7237
    free((void *)p_tcp->mct_norms);
#line 7238
    p_tcp->mct_norms = (OPJ_FLOAT64 *)0;
    }
  }
  {
#line 7241
  opj_j2k_tcp_data_destroy(p_tcp);
  }
#line 7243
  return;
}
}
#line 7245 "/root/patron/new_22/src/lib/openjp2/j2k.c"
void opj_j2k_tcp_data_destroy(opj_tcp_t *p_tcp ) 
{ 


  {
#line 7247
  if (p_tcp->m_data) {
    {
#line 7248
    free((void *)p_tcp->m_data);
#line 7249
    p_tcp->m_data = (OPJ_BYTE *)((void *)0);
#line 7250
    p_tcp->m_data_size = (OPJ_UINT32 )0;
    }
  }
#line 7253
  return;
}
}
#line 7254 "/root/patron/new_22/src/lib/openjp2/j2k.c"
void opj_j2k_cp_destroy(opj_cp_t *p_cp ) 
{ 
  OPJ_UINT32 l_nb_tiles ;
  opj_tcp_t *l_current_tile ;
  OPJ_UINT32 i ;

  {
#line 7257
  l_current_tile = (opj_tcp_t *)0;
#line 7260
  if ((unsigned long )p_cp == (unsigned long )((opj_cp_t *)0)) {
#line 7262
    return;
  }
#line 7264
  if ((unsigned long )p_cp->tcps != (unsigned long )((opj_tcp_t *)0)) {
#line 7266
    l_current_tile = p_cp->tcps;
#line 7267
    l_nb_tiles = p_cp->th * p_cp->tw;
#line 7269
    i = (OPJ_UINT32 )0;
    {
#line 7269
    while (1) {
      while_continue: /* CIL Label */ ;

#line 7269
      if (! (i < l_nb_tiles)) {
#line 7269
        goto while_break;
      }
      {
#line 7271
      opj_j2k_tcp_destroy(l_current_tile);
#line 7272
      l_current_tile ++;
#line 7269
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: 
    {
#line 7274
    free((void *)p_cp->tcps);
#line 7275
    p_cp->tcps = (opj_tcp_t *)0;
    }
  }
  {
#line 7277
  free((void *)p_cp->ppm_buffer);
#line 7278
  p_cp->ppm_buffer = (OPJ_BYTE *)0;
#line 7279
  p_cp->ppm_data = (OPJ_BYTE *)((void *)0);
#line 7280
  free((void *)p_cp->comment);
#line 7281
  p_cp->comment = (OPJ_CHAR *)0;
  }
#line 7282
  if (! p_cp->m_is_decoder) {
    {
#line 7284
    free((void *)p_cp->m_specific_param.m_enc.m_matrice);
#line 7285
    p_cp->m_specific_param.m_enc.m_matrice = (OPJ_INT32 *)0;
    }
  }
#line 7288
  return;
}
}
#line 7289 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_read_tile_header(opj_j2k_t *p_j2k , OPJ_UINT32 *p_tile_index , OPJ_UINT32 *p_data_size ,
                                  OPJ_INT32 *p_tile_x0 , OPJ_INT32 *p_tile_y0 , OPJ_INT32 *p_tile_x1 ,
                                  OPJ_INT32 *p_tile_y1 , OPJ_UINT32 *p_nb_comps ,
                                  OPJ_BOOL *p_go_on , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_current_marker ;
  OPJ_UINT32 l_marker_size ;
  opj_dec_memory_marker_handler_t *l_marker_handler ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 l_nb_tiles ;
  OPJ_OFF_T __cil_tmp20 ;
  OPJ_SIZE_T __cil_tmp21 ;
  OPJ_BYTE *new_header_data ;
  void *__cil_tmp24 ;
  OPJ_SIZE_T __cil_tmp25 ;
  OPJ_BOOL __cil_tmp26 ;
  OPJ_OFF_T __cil_tmp27 ;
  OPJ_BOOL __cil_tmp28 ;
  OPJ_UINT32 sot_pos ;
  OPJ_OFF_T __cil_tmp30 ;
  OPJ_OFF_T __cil_tmp31 ;
  OPJ_SIZE_T __cil_tmp32 ;
  OPJ_OFF_T __cil_tmp33 ;
  OPJ_BOOL __cil_tmp34 ;
  OPJ_SIZE_T __cil_tmp35 ;
  OPJ_SIZE_T __cil_tmp36 ;
  OPJ_BOOL __cil_tmp37 ;

  {
#line 7299
  l_current_marker = (OPJ_UINT32 )65424;
#line 7301
  l_marker_handler = (opj_dec_memory_marker_handler_t *)0;
#line 7302
  l_tcp = (opj_tcp_t *)((void *)0);
#line 7311
  if (p_j2k->m_specific_param.m_decoder.m_state == 256U) {
#line 7312
    l_current_marker = (OPJ_UINT32 )65497;
  } else
#line 7315
  if (p_j2k->m_specific_param.m_decoder.m_state != 8U) {
#line 7316
    return (0);
  }
  {
#line 7320
  while (1) {
    while_continue: /* CIL Label */ ;

#line 7320
    if (! p_j2k->m_specific_param.m_decoder.m_can_decode) {
#line 7320
      if (! (l_current_marker != 65497U)) {
#line 7320
        goto while_break;
      }
    } else {
#line 7320
      goto while_break;
    }
    {
#line 7323
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 7323
      if (! (l_current_marker != 65427U)) {
#line 7323
        goto while_break___0;
      }
      {
#line 7325
      __cil_tmp20 = opj_stream_get_number_byte_left(p_stream);
      }
#line 7325
      if (__cil_tmp20 == 0L) {
#line 7327
        p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )64;
#line 7328
        goto while_break___0;
      }
      {
#line 7332
      __cil_tmp21 = opj_stream_read_data(p_stream, p_j2k->m_specific_param.m_decoder.m_header_data,
                                         (OPJ_SIZE_T )2, p_manager);
      }
#line 7332
      if (__cil_tmp21 != 2UL) {
        {
#line 7333
        opj_event_msg(p_manager, 1, "Stream too short\n");
        }
#line 7334
        return (0);
      }
      {
#line 7338
      opj_read_bytes_LE(p_j2k->m_specific_param.m_decoder.m_header_data, & l_marker_size,
                        (OPJ_UINT32 )2);
      }
#line 7341
      if (p_j2k->m_specific_param.m_decoder.m_state & 16U) {
#line 7342
        p_j2k->m_specific_param.m_decoder.m_sot_length -= l_marker_size + 2U;
      }
      {
#line 7344
      l_marker_size -= 2U;
#line 7347
      l_marker_handler = opj_j2k_get_marker_handler(l_current_marker);
      }
#line 7350
      if (! (p_j2k->m_specific_param.m_decoder.m_state & l_marker_handler->states)) {
        {
#line 7351
        opj_event_msg(p_manager, 1, "Marker is not compliant with its position\n");
        }
#line 7352
        return (0);
      }
#line 7357
      if (l_marker_size > p_j2k->m_specific_param.m_decoder.m_header_data_size) {
        {
#line 7358
        __cil_tmp24 = realloc((void *)p_j2k->m_specific_param.m_decoder.m_header_data,
                              (unsigned long )l_marker_size);
#line 7358
        new_header_data = (OPJ_BYTE *)__cil_tmp24;
        }
#line 7359
        if (! new_header_data) {
          {
#line 7360
          free((void *)p_j2k->m_specific_param.m_decoder.m_header_data);
#line 7361
          p_j2k->m_specific_param.m_decoder.m_header_data = (OPJ_BYTE *)((void *)0);
#line 7362
          p_j2k->m_specific_param.m_decoder.m_header_data_size = (OPJ_UINT32 )0;
#line 7363
          opj_event_msg(p_manager, 1, "Not enough memory to read header\n");
          }
#line 7364
          return (0);
        }
#line 7366
        p_j2k->m_specific_param.m_decoder.m_header_data = new_header_data;
#line 7367
        p_j2k->m_specific_param.m_decoder.m_header_data_size = l_marker_size;
      }
      {
#line 7371
      __cil_tmp25 = opj_stream_read_data(p_stream, p_j2k->m_specific_param.m_decoder.m_header_data,
                                         (OPJ_SIZE_T )l_marker_size, p_manager);
      }
#line 7371
      if (__cil_tmp25 != (unsigned long )l_marker_size) {
        {
#line 7372
        opj_event_msg(p_manager, 1, "Stream too short\n");
        }
#line 7373
        return (0);
      }
#line 7376
      if (! l_marker_handler->handler) {
        {
#line 7378
        opj_event_msg(p_manager, 1, "Not sure how that happened.\n");
        }
#line 7379
        return (0);
      }
      {
#line 7382
      __cil_tmp26 = (*(l_marker_handler->handler))(p_j2k, p_j2k->m_specific_param.m_decoder.m_header_data,
                                                   l_marker_size, p_manager);
      }
#line 7382
      if (! __cil_tmp26) {
        {
#line 7383
        opj_event_msg(p_manager, 1, "Fail to read the current marker segment (%#x)\n",
                      l_current_marker);
        }
#line 7384
        return (0);
      }
      {
#line 7388
      __cil_tmp27 = opj_stream_tell(p_stream);
#line 7388
      __cil_tmp28 = opj_j2k_add_tlmarker(p_j2k->m_current_tile_number, p_j2k->cstr_index,
                                         l_marker_handler->id, (OPJ_OFF_T )(((OPJ_UINT32 )__cil_tmp27 - l_marker_size) - 4U),
                                         l_marker_size + 4U);
      }
#line 7388
      if (0 == __cil_tmp28) {
        {
#line 7393
        opj_event_msg(p_manager, 1, "Not enough memory to add tl marker\n");
        }
#line 7394
        return (0);
      }
#line 7398
      if (l_marker_handler->id == 65424U) {
        {
#line 7399
        __cil_tmp30 = opj_stream_tell(p_stream);
#line 7399
        sot_pos = ((OPJ_UINT32 )__cil_tmp30 - l_marker_size) - 4U;
        }
#line 7400
        if ((long )sot_pos > p_j2k->m_specific_param.m_decoder.m_last_sot_read_pos) {
#line 7402
          p_j2k->m_specific_param.m_decoder.m_last_sot_read_pos = (OPJ_OFF_T )sot_pos;
        }
      }
#line 7406
      if (p_j2k->m_specific_param.m_decoder.m_skip_data) {
        {
#line 7408
        __cil_tmp31 = opj_stream_skip(p_stream, (OPJ_OFF_T )p_j2k->m_specific_param.m_decoder.m_sot_length,
                                      p_manager);
        }
#line 7408
        if (__cil_tmp31 != (long )p_j2k->m_specific_param.m_decoder.m_sot_length) {
          {
#line 7409
          opj_event_msg(p_manager, 1, "Stream too short\n");
          }
#line 7410
          return (0);
        }
#line 7412
        l_current_marker = (OPJ_UINT32 )65427;
      } else {
        {
#line 7416
        __cil_tmp32 = opj_stream_read_data(p_stream, p_j2k->m_specific_param.m_decoder.m_header_data,
                                           (OPJ_SIZE_T )2, p_manager);
        }
#line 7416
        if (__cil_tmp32 != 2UL) {
          {
#line 7417
          opj_event_msg(p_manager, 1, "Stream too short\n");
          }
#line 7418
          return (0);
        }
        {
#line 7421
        opj_read_bytes_LE(p_j2k->m_specific_param.m_decoder.m_header_data, & l_current_marker,
                          (OPJ_UINT32 )2);
        }
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 7424
    __cil_tmp33 = opj_stream_get_number_byte_left(p_stream);
    }
#line 7424
    if (__cil_tmp33 == 0L) {
#line 7424
      if (p_j2k->m_specific_param.m_decoder.m_state == 64U) {
#line 7426
        goto while_break;
      }
    }
#line 7429
    if (! p_j2k->m_specific_param.m_decoder.m_skip_data) {
      {
#line 7431
      __cil_tmp34 = opj_j2k_read_sod(p_j2k, p_stream, p_manager);
      }
#line 7431
      if (! __cil_tmp34) {
#line 7432
        return (0);
      }
#line 7435
      if (! p_j2k->m_specific_param.m_decoder.m_can_decode) {
        {
#line 7437
        __cil_tmp35 = opj_stream_read_data(p_stream, p_j2k->m_specific_param.m_decoder.m_header_data,
                                           (OPJ_SIZE_T )2, p_manager);
        }
#line 7437
        if (__cil_tmp35 != 2UL) {
          {
#line 7438
          opj_event_msg(p_manager, 1, "Stream too short\n");
          }
#line 7439
          return (0);
        }
        {
#line 7443
        opj_read_bytes_LE(p_j2k->m_specific_param.m_decoder.m_header_data, & l_current_marker,
                          (OPJ_UINT32 )2);
        }
      }
    } else {
      {
#line 7448
      p_j2k->m_specific_param.m_decoder.m_skip_data = (OPJ_UINT32 )0;
#line 7449
      p_j2k->m_specific_param.m_decoder.m_can_decode = (OPJ_UINT32 )0;
#line 7450
      p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )8;
#line 7453
      __cil_tmp36 = opj_stream_read_data(p_stream, p_j2k->m_specific_param.m_decoder.m_header_data,
                                         (OPJ_SIZE_T )2, p_manager);
      }
#line 7453
      if (__cil_tmp36 != 2UL) {
        {
#line 7454
        opj_event_msg(p_manager, 1, "Stream too short\n");
        }
#line 7455
        return (0);
      }
      {
#line 7459
      opj_read_bytes_LE(p_j2k->m_specific_param.m_decoder.m_header_data, & l_current_marker,
                        (OPJ_UINT32 )2);
      }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 7464
  if (l_current_marker == 65497U) {
#line 7465
    if (p_j2k->m_specific_param.m_decoder.m_state != 256U) {
#line 7466
      p_j2k->m_current_tile_number = (OPJ_UINT32 )0;
#line 7467
      p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )256;
    }
  }
#line 7472
  if (! p_j2k->m_specific_param.m_decoder.m_can_decode) {
#line 7473
    l_tcp = p_j2k->m_cp.tcps + p_j2k->m_current_tile_number;
#line 7474
    l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;
    {
#line 7476
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 7476
      if ((unsigned long )l_tcp->m_data == (unsigned long )((OPJ_BYTE *)0)) {
#line 7476
        if (! (p_j2k->m_current_tile_number < l_nb_tiles)) {
#line 7476
          goto while_break___1;
        }
      } else {
#line 7476
        goto while_break___1;
      }
#line 7477
      (p_j2k->m_current_tile_number) ++;
#line 7478
      l_tcp ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: ;
#line 7481
    if (p_j2k->m_current_tile_number == l_nb_tiles) {
#line 7482
      *p_go_on = 0;
#line 7483
      return (1);
    }
  }
  {
#line 7488
  __cil_tmp37 = opj_tcd_init_decode_tile(p_j2k->m_tcd, p_j2k->m_current_tile_number);
  }
#line 7488
  if (! __cil_tmp37) {
    {
#line 7489
    opj_event_msg(p_manager, 1, "Cannot decode tile, memory error\n");
    }
#line 7490
    return (0);
  }
  {
#line 7493
  opj_event_msg(p_manager, 4, "Header of tile %d / %d has been read.\n", p_j2k->m_current_tile_number,
                p_j2k->m_cp.th * p_j2k->m_cp.tw - 1U);
#line 7496
  *p_tile_index = p_j2k->m_current_tile_number;
#line 7497
  *p_go_on = 1;
#line 7498
  *p_data_size = opj_tcd_get_decoded_tile_size(p_j2k->m_tcd);
#line 7499
  *p_tile_x0 = (((p_j2k->m_tcd)->tcd_image)->tiles)->x0;
#line 7500
  *p_tile_y0 = (((p_j2k->m_tcd)->tcd_image)->tiles)->y0;
#line 7501
  *p_tile_x1 = (((p_j2k->m_tcd)->tcd_image)->tiles)->x1;
#line 7502
  *p_tile_y1 = (((p_j2k->m_tcd)->tcd_image)->tiles)->y1;
#line 7503
  *p_nb_comps = (((p_j2k->m_tcd)->tcd_image)->tiles)->numcomps;
#line 7505
  p_j2k->m_specific_param.m_decoder.m_state |= 128U;
  }
#line 7507
  return (1);
}
}
#line 7510 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_decode_tile(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                             OPJ_UINT32 p_data_size , opj_stream_private_t *p_stream ,
                             opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_current_marker ;
  OPJ_BYTE l_data[2] ;
  opj_tcp_t *l_tcp ;
  OPJ_BOOL __cil_tmp13 ;
  OPJ_BOOL __cil_tmp14 ;
  OPJ_OFF_T __cil_tmp15 ;
  OPJ_SIZE_T __cil_tmp16 ;
  OPJ_OFF_T __cil_tmp17 ;

  {
#line 7526
  if (! (p_j2k->m_specific_param.m_decoder.m_state & 128U)) {
#line 7528
    return (0);
  } else
#line 7526
  if (p_tile_index != p_j2k->m_current_tile_number) {
#line 7528
    return (0);
  }
#line 7531
  l_tcp = p_j2k->m_cp.tcps + p_tile_index;
#line 7532
  if (! l_tcp->m_data) {
    {
#line 7533
    opj_j2k_tcp_destroy(l_tcp);
    }
#line 7534
    return (0);
  }
  {
#line 7537
  __cil_tmp13 = opj_tcd_decode_tile(p_j2k->m_tcd, l_tcp->m_data, l_tcp->m_data_size,
                                    p_tile_index, p_j2k->cstr_index);
  }
#line 7537
  if (! __cil_tmp13) {
    {
#line 7542
    opj_j2k_tcp_destroy(l_tcp);
#line 7543
    p_j2k->m_specific_param.m_decoder.m_state |= 32768U;
    }
#line 7544
    return (0);
  }
  {
#line 7547
  __cil_tmp14 = opj_tcd_update_tile_data(p_j2k->m_tcd, p_data, p_data_size);
  }
#line 7547
  if (! __cil_tmp14) {
#line 7548
    return (0);
  }
  {
#line 7555
  opj_j2k_tcp_data_destroy(l_tcp);
#line 7557
  p_j2k->m_specific_param.m_decoder.m_can_decode = (OPJ_UINT32 )0;
#line 7558
  p_j2k->m_specific_param.m_decoder.m_state &= 4294967167U;
#line 7560
  __cil_tmp15 = opj_stream_get_number_byte_left(p_stream);
  }
#line 7560
  if (__cil_tmp15 == 0L) {
#line 7560
    if (p_j2k->m_specific_param.m_decoder.m_state == 64U) {
#line 7562
      return (1);
    }
  }
#line 7565
  if (p_j2k->m_specific_param.m_decoder.m_state != 256U) {
    {
#line 7566
    __cil_tmp16 = opj_stream_read_data(p_stream, l_data, (OPJ_SIZE_T )2, p_manager);
    }
#line 7566
    if (__cil_tmp16 != 2UL) {
      {
#line 7567
      opj_event_msg(p_manager, 1, "Stream too short\n%\325\211\202U");
      }
#line 7568
      return (0);
    }
    {
#line 7571
    opj_read_bytes_LE(l_data, & l_current_marker, (OPJ_UINT32 )2);
    }
#line 7573
    if (l_current_marker == 65497U) {
#line 7574
      p_j2k->m_current_tile_number = (OPJ_UINT32 )0;
#line 7575
      p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )256;
    } else
#line 7577
    if (l_current_marker != 65424U) {
      {
#line 7579
      opj_event_msg(p_manager, 1, "Stream too short, expected SOT\n");
#line 7581
      __cil_tmp17 = opj_stream_get_number_byte_left(p_stream);
      }
#line 7581
      if (__cil_tmp17 == 0L) {
#line 7582
        p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )64;
#line 7583
        return (1);
      }
#line 7585
      return (0);
    }
  }
#line 7589
  return (1);
}
}
#line 7592 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_update_image_data(opj_tcd_t *p_tcd , OPJ_BYTE *p_data , opj_image_t *p_output_image ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  OPJ_UINT32 l_width_src ;
  OPJ_UINT32 l_height_src ;
  OPJ_UINT32 l_width_dest ;
  OPJ_UINT32 l_height_dest ;
  OPJ_INT32 l_offset_x0_src ;
  OPJ_INT32 l_offset_y0_src ;
  OPJ_INT32 l_offset_x1_src ;
  OPJ_INT32 l_offset_y1_src ;
  OPJ_INT32 l_start_offset_src ;
  OPJ_INT32 l_line_offset_src ;
  OPJ_INT32 l_end_offset_src ;
  OPJ_UINT32 l_start_x_dest ;
  OPJ_UINT32 l_start_y_dest ;
  OPJ_UINT32 l_x0_dest ;
  OPJ_UINT32 l_y0_dest ;
  OPJ_UINT32 l_x1_dest ;
  OPJ_UINT32 l_y1_dest ;
  OPJ_INT32 l_start_offset_dest ;
  OPJ_INT32 l_line_offset_dest ;
  opj_image_comp_t *l_img_comp_src ;
  opj_image_comp_t *l_img_comp_dest ;
  opj_tcd_tilecomp_t *l_tilec ;
  opj_image_t *l_image_src ;
  OPJ_UINT32 l_size_comp ;
  OPJ_UINT32 l_remaining ;
  OPJ_INT32 *l_dest_ptr ;
  opj_tcd_resolution_t *l_res ;
  void *__cil_tmp34 ;
  OPJ_INT32 __cil_tmp35 ;
  OPJ_INT32 __cil_tmp36 ;
  OPJ_CHAR *l_src_ptr ;
  OPJ_INT32 *__cil_tmp40 ;
  OPJ_CHAR *__cil_tmp41 ;
  OPJ_INT32 *__cil_tmp42 ;
  OPJ_CHAR *__cil_tmp43 ;
  OPJ_INT16 *l_src_ptr___0 ;
  OPJ_INT32 *__cil_tmp45 ;
  OPJ_INT16 *__cil_tmp46 ;
  OPJ_INT32 *__cil_tmp47 ;
  OPJ_INT16 *__cil_tmp48 ;
  OPJ_INT32 *l_src_ptr___1 ;
  OPJ_INT32 *__cil_tmp50 ;
  OPJ_INT32 *__cil_tmp51 ;

  {
#line 7594
  k = (OPJ_UINT32 )0;
#line 7603
  l_img_comp_src = (opj_image_comp_t *)0;
#line 7604
  l_img_comp_dest = (opj_image_comp_t *)0;
#line 7606
  l_tilec = (opj_tcd_tilecomp_t *)0;
#line 7607
  l_image_src = (opj_image_t *)0;
#line 7610
  l_res = (opj_tcd_resolution_t *)0;
#line 7612
  l_tilec = ((p_tcd->tcd_image)->tiles)->comps;
#line 7613
  l_image_src = p_tcd->image;
#line 7614
  l_img_comp_src = l_image_src->comps;
#line 7616
  l_img_comp_dest = p_output_image->comps;
#line 7618
  i = (OPJ_UINT32 )0;
  {
#line 7618
  while (1) {
    while_continue: /* CIL Label */ ;

#line 7618
    if (! (i < l_image_src->numcomps)) {
#line 7618
      goto while_break;
    }
#line 7621
    if (! l_img_comp_dest->data) {
      {
#line 7623
      __cil_tmp34 = calloc((unsigned long )(l_img_comp_dest->w * l_img_comp_dest->h),
                           sizeof(OPJ_INT32 ));
#line 7623
      l_img_comp_dest->data = (OPJ_INT32 *)__cil_tmp34;
      }
#line 7624
      if (! l_img_comp_dest->data) {
#line 7625
        return (0);
      }
    }
#line 7630
    l_img_comp_dest->resno_decoded = l_img_comp_src->resno_decoded;
#line 7634
    l_size_comp = l_img_comp_src->prec >> 3;
#line 7635
    l_remaining = l_img_comp_src->prec & 7U;
#line 7636
    l_res = l_tilec->resolutions + l_img_comp_src->resno_decoded;
#line 7638
    if (l_remaining) {
#line 7639
      l_size_comp ++;
    }
#line 7642
    if (l_size_comp == 3U) {
#line 7643
      l_size_comp = (OPJ_UINT32 )4;
    }
    {
#line 7653
    l_width_src = (OPJ_UINT32 )(l_res->x1 - l_res->x0);
#line 7654
    l_height_src = (OPJ_UINT32 )(l_res->y1 - l_res->y0);
#line 7657
    __cil_tmp35 = opj_int_ceildivpow2((OPJ_INT32 )l_img_comp_dest->x0, (OPJ_INT32 )l_img_comp_dest->factor);
#line 7657
    l_x0_dest = (OPJ_UINT32 )__cil_tmp35;
#line 7658
    __cil_tmp36 = opj_int_ceildivpow2((OPJ_INT32 )l_img_comp_dest->y0, (OPJ_INT32 )l_img_comp_dest->factor);
#line 7658
    l_y0_dest = (OPJ_UINT32 )__cil_tmp36;
#line 7659
    l_x1_dest = l_x0_dest + l_img_comp_dest->w;
#line 7660
    l_y1_dest = l_y0_dest + l_img_comp_dest->h;
    }
#line 7676
    if (l_x0_dest < (OPJ_UINT32 )l_res->x0) {
#line 7677
      l_start_x_dest = (unsigned int )l_res->x0 - l_x0_dest;
#line 7678
      l_offset_x0_src = 0;
#line 7680
      if (l_x1_dest >= (OPJ_UINT32 )l_res->x1) {
#line 7681
        l_width_dest = l_width_src;
#line 7682
        l_offset_x1_src = 0;
      } else {
#line 7685
        l_width_dest = l_x1_dest - (unsigned int )l_res->x0;
#line 7686
        l_offset_x1_src = (OPJ_INT32 )(l_width_src - l_width_dest);
      }
    } else {
#line 7690
      l_start_x_dest = (OPJ_UINT32 )0;
#line 7691
      l_offset_x0_src = (OPJ_INT32 )(l_x0_dest - (unsigned int )l_res->x0);
#line 7693
      if (l_x1_dest >= (OPJ_UINT32 )l_res->x1) {
#line 7694
        l_width_dest = l_width_src - (unsigned int )l_offset_x0_src;
#line 7695
        l_offset_x1_src = 0;
      } else {
#line 7698
        l_width_dest = l_img_comp_dest->w;
#line 7699
        l_offset_x1_src = (OPJ_INT32 )((unsigned int )l_res->x1 - l_x1_dest);
      }
    }
#line 7703
    if (l_y0_dest < (OPJ_UINT32 )l_res->y0) {
#line 7704
      l_start_y_dest = (unsigned int )l_res->y0 - l_y0_dest;
#line 7705
      l_offset_y0_src = 0;
#line 7707
      if (l_y1_dest >= (OPJ_UINT32 )l_res->y1) {
#line 7708
        l_height_dest = l_height_src;
#line 7709
        l_offset_y1_src = 0;
      } else {
#line 7712
        l_height_dest = l_y1_dest - (unsigned int )l_res->y0;
#line 7713
        l_offset_y1_src = (OPJ_INT32 )(l_height_src - l_height_dest);
      }
    } else {
#line 7717
      l_start_y_dest = (OPJ_UINT32 )0;
#line 7718
      l_offset_y0_src = (OPJ_INT32 )(l_y0_dest - (unsigned int )l_res->y0);
#line 7720
      if (l_y1_dest >= (OPJ_UINT32 )l_res->y1) {
#line 7721
        l_height_dest = l_height_src - (unsigned int )l_offset_y0_src;
#line 7722
        l_offset_y1_src = 0;
      } else {
#line 7725
        l_height_dest = l_img_comp_dest->h;
#line 7726
        l_offset_y1_src = (OPJ_INT32 )((unsigned int )l_res->y1 - l_y1_dest);
      }
    }
#line 7730
    if (l_offset_x0_src < 0) {
#line 7731
      return (0);
    } else
#line 7730
    if (l_offset_y0_src < 0) {
#line 7731
      return (0);
    } else
#line 7730
    if (l_offset_x1_src < 0) {
#line 7731
      return (0);
    } else
#line 7730
    if (l_offset_y1_src < 0) {
#line 7731
      return (0);
    }
#line 7736
    l_start_offset_src = (OPJ_INT32 )((unsigned int )l_offset_x0_src + (unsigned int )l_offset_y0_src * l_width_src);
#line 7737
    l_line_offset_src = l_offset_x1_src + l_offset_x0_src;
#line 7738
    l_end_offset_src = (OPJ_INT32 )((unsigned int )l_offset_y1_src * l_width_src - (unsigned int )l_offset_x0_src);
#line 7741
    l_start_offset_dest = (OPJ_INT32 )(l_start_x_dest + l_start_y_dest * l_img_comp_dest->w);
#line 7742
    l_line_offset_dest = (OPJ_INT32 )(l_img_comp_dest->w - l_width_dest);
#line 7745
    l_dest_ptr = l_img_comp_dest->data + l_start_offset_dest;
#line 7762
    if (l_size_comp == 1U) {
#line 7762
      goto case_1;
    }
#line 7792
    if (l_size_comp == 2U) {
#line 7792
      goto case_2;
    }
#line 7822
    if (l_size_comp == 4U) {
#line 7822
      goto case_4;
    }
#line 7761
    goto switch_break;
    case_1: 
#line 7764
    l_src_ptr = (OPJ_CHAR *)p_data;
#line 7765
    l_src_ptr += l_start_offset_src;
#line 7767
    if (l_img_comp_src->sgnd) {
#line 7768
      j = (OPJ_UINT32 )0;
      {
#line 7768
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 7768
        if (! (j < l_height_dest)) {
#line 7768
          goto while_break___0;
        }
#line 7769
        k = (OPJ_UINT32 )0;
        {
#line 7769
        while (1) {
          while_continue___1: /* CIL Label */ ;

#line 7769
          if (! (k < l_width_dest)) {
#line 7769
            goto while_break___1;
          }
#line 7770
          __cil_tmp41 = l_src_ptr;
#line 7770
          l_src_ptr ++;
#line 7770
          __cil_tmp40 = l_dest_ptr;
#line 7770
          l_dest_ptr ++;
#line 7770
          *__cil_tmp40 = (OPJ_INT32 )*__cil_tmp41;
#line 7769
          k ++;
        }
        while_break___12: /* CIL Label */ ;
        }
        while_break___1: 
#line 7773
        l_dest_ptr += l_line_offset_dest;
#line 7774
        l_src_ptr += l_line_offset_src;
#line 7768
        j ++;
      }
      while_break___11: /* CIL Label */ ;
      }
      while_break___0: ;
    } else {
#line 7778
      j = (OPJ_UINT32 )0;
      {
#line 7778
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 7778
        if (! (j < l_height_dest)) {
#line 7778
          goto while_break___2;
        }
#line 7779
        k = (OPJ_UINT32 )0;
        {
#line 7779
        while (1) {
          while_continue___3: /* CIL Label */ ;

#line 7779
          if (! (k < l_width_dest)) {
#line 7779
            goto while_break___3;
          }
#line 7780
          __cil_tmp43 = l_src_ptr;
#line 7780
          l_src_ptr ++;
#line 7780
          __cil_tmp42 = l_dest_ptr;
#line 7780
          l_dest_ptr ++;
#line 7780
          *__cil_tmp42 = (int )*__cil_tmp43 & 255;
#line 7779
          k ++;
        }
        while_break___14: /* CIL Label */ ;
        }
        while_break___3: 
#line 7783
        l_dest_ptr += l_line_offset_dest;
#line 7784
        l_src_ptr += l_line_offset_src;
#line 7778
        j ++;
      }
      while_break___13: /* CIL Label */ ;
      }
      while_break___2: ;
    }
#line 7788
    l_src_ptr += l_end_offset_src;
#line 7789
    p_data = (OPJ_BYTE *)l_src_ptr;
#line 7791
    goto switch_break;
    case_2: 
#line 7794
    l_src_ptr___0 = (OPJ_INT16 *)p_data;
#line 7795
    l_src_ptr___0 += l_start_offset_src;
#line 7797
    if (l_img_comp_src->sgnd) {
#line 7798
      j = (OPJ_UINT32 )0;
      {
#line 7798
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 7798
        if (! (j < l_height_dest)) {
#line 7798
          goto while_break___4;
        }
#line 7799
        k = (OPJ_UINT32 )0;
        {
#line 7799
        while (1) {
          while_continue___5: /* CIL Label */ ;

#line 7799
          if (! (k < l_width_dest)) {
#line 7799
            goto while_break___5;
          }
#line 7800
          __cil_tmp46 = l_src_ptr___0;
#line 7800
          l_src_ptr___0 ++;
#line 7800
          __cil_tmp45 = l_dest_ptr;
#line 7800
          l_dest_ptr ++;
#line 7800
          *__cil_tmp45 = (OPJ_INT32 )*__cil_tmp46;
#line 7799
          k ++;
        }
        while_break___16: /* CIL Label */ ;
        }
        while_break___5: 
#line 7803
        l_dest_ptr += l_line_offset_dest;
#line 7804
        l_src_ptr___0 += l_line_offset_src;
#line 7798
        j ++;
      }
      while_break___15: /* CIL Label */ ;
      }
      while_break___4: ;
    } else {
#line 7808
      j = (OPJ_UINT32 )0;
      {
#line 7808
      while (1) {
        while_continue___6: /* CIL Label */ ;

#line 7808
        if (! (j < l_height_dest)) {
#line 7808
          goto while_break___6;
        }
#line 7809
        k = (OPJ_UINT32 )0;
        {
#line 7809
        while (1) {
          while_continue___7: /* CIL Label */ ;

#line 7809
          if (! (k < l_width_dest)) {
#line 7809
            goto while_break___7;
          }
#line 7810
          __cil_tmp48 = l_src_ptr___0;
#line 7810
          l_src_ptr___0 ++;
#line 7810
          __cil_tmp47 = l_dest_ptr;
#line 7810
          l_dest_ptr ++;
#line 7810
          *__cil_tmp47 = (int )*__cil_tmp48 & 65535;
#line 7809
          k ++;
        }
        while_break___18: /* CIL Label */ ;
        }
        while_break___7: 
#line 7813
        l_dest_ptr += l_line_offset_dest;
#line 7814
        l_src_ptr___0 += l_line_offset_src;
#line 7808
        j ++;
      }
      while_break___17: /* CIL Label */ ;
      }
      while_break___6: ;
    }
#line 7818
    l_src_ptr___0 += l_end_offset_src;
#line 7819
    p_data = (OPJ_BYTE *)l_src_ptr___0;
#line 7821
    goto switch_break;
    case_4: 
#line 7824
    l_src_ptr___1 = (OPJ_INT32 *)p_data;
#line 7825
    l_src_ptr___1 += l_start_offset_src;
#line 7827
    j = (OPJ_UINT32 )0;
    {
#line 7827
    while (1) {
      while_continue___8: /* CIL Label */ ;

#line 7827
      if (! (j < l_height_dest)) {
#line 7827
        goto while_break___8;
      }
#line 7828
      k = (OPJ_UINT32 )0;
      {
#line 7828
      while (1) {
        while_continue___9: /* CIL Label */ ;

#line 7828
        if (! (k < l_width_dest)) {
#line 7828
          goto while_break___9;
        }
#line 7829
        __cil_tmp51 = l_src_ptr___1;
#line 7829
        l_src_ptr___1 ++;
#line 7829
        __cil_tmp50 = l_dest_ptr;
#line 7829
        l_dest_ptr ++;
#line 7829
        *__cil_tmp50 = *__cil_tmp51;
#line 7828
        k ++;
      }
      while_break___20: /* CIL Label */ ;
      }
      while_break___9: 
#line 7832
      l_dest_ptr += l_line_offset_dest;
#line 7833
      l_src_ptr___1 += l_line_offset_src;
#line 7827
      j ++;
    }
    while_break___19: /* CIL Label */ ;
    }
    while_break___8: 
#line 7836
    l_src_ptr___1 += l_end_offset_src;
#line 7837
    p_data = (OPJ_BYTE *)l_src_ptr___1;
#line 7839
    goto switch_break;
    switch_break: 
#line 7842
    l_img_comp_dest ++;
#line 7843
    l_img_comp_src ++;
#line 7844
    l_tilec ++;
#line 7618
    i ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break: ;
#line 7847
  return (1);
}
}
#line 7850 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_set_decode_area(opj_j2k_t *p_j2k , opj_image_t *p_image , OPJ_INT32 p_start_x ,
                                 OPJ_INT32 p_start_y , OPJ_INT32 p_end_x , OPJ_INT32 p_end_y ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  opj_cp_t *l_cp ;
  opj_image_t *l_image ;
  OPJ_UINT32 it_comp ;
  OPJ_INT32 l_comp_x1 ;
  OPJ_INT32 l_comp_y1 ;
  opj_image_comp_t *l_img_comp ;
  OPJ_INT32 __cil_tmp18 ;
  OPJ_INT32 __cil_tmp19 ;
  OPJ_INT32 l_h ;
  OPJ_INT32 l_w ;
  OPJ_INT32 __cil_tmp22 ;
  OPJ_INT32 __cil_tmp23 ;
  OPJ_INT32 __cil_tmp26 ;
  OPJ_INT32 __cil_tmp27 ;
  OPJ_INT32 __cil_tmp28 ;
  OPJ_INT32 __cil_tmp29 ;

  {
#line 7856
  l_cp = & p_j2k->m_cp;
#line 7857
  l_image = p_j2k->m_private_image;
#line 7861
  l_img_comp = (opj_image_comp_t *)((void *)0);
#line 7864
  if (p_j2k->m_specific_param.m_decoder.m_state != 8U) {
    {
#line 7865
    opj_event_msg(p_manager, 1, "Need to decode the main header before begin to decode the remaining codestream");
    }
#line 7866
    return (0);
  }
#line 7869
  if (! p_start_x) {
#line 7869
    if (! p_start_y) {
#line 7869
      if (! p_end_x) {
#line 7869
        if (! p_end_y) {
          {
#line 7870
          opj_event_msg(p_manager, 4, "No decoded area parameters, set the decoded area to the whole image\n");
#line 7872
          p_j2k->m_specific_param.m_decoder.m_start_tile_x = (OPJ_UINT32 )0;
#line 7873
          p_j2k->m_specific_param.m_decoder.m_start_tile_y = (OPJ_UINT32 )0;
#line 7874
          p_j2k->m_specific_param.m_decoder.m_end_tile_x = l_cp->tw;
#line 7875
          p_j2k->m_specific_param.m_decoder.m_end_tile_y = l_cp->th;
          }
#line 7877
          return (1);
        }
      }
    }
  }
#line 7887
  if ((OPJ_UINT32 )p_start_x > l_image->x1) {
    {
#line 7888
    opj_event_msg(p_manager, 1, "Left position of the decoded area (region_x0=%d) is outside the image area (Xsiz=%d).\n",
                  p_start_x, l_image->x1);
    }
#line 7891
    return (0);
  } else
#line 7893
  if ((OPJ_UINT32 )p_start_x < l_image->x0) {
    {
#line 7894
    opj_event_msg(p_manager, 2, "Left position of the decoded area (region_x0=%d) is outside the image area (XOsiz=%d).\n",
                  p_start_x, l_image->x0);
#line 7897
    p_j2k->m_specific_param.m_decoder.m_start_tile_x = (OPJ_UINT32 )0;
#line 7898
    p_image->x0 = l_image->x0;
    }
  } else {
#line 7901
    p_j2k->m_specific_param.m_decoder.m_start_tile_x = ((unsigned int )p_start_x - l_cp->tx0) / l_cp->tdx;
#line 7902
    p_image->x0 = (OPJ_UINT32 )p_start_x;
  }
#line 7906
  if ((OPJ_UINT32 )p_start_y > l_image->y1) {
    {
#line 7907
    opj_event_msg(p_manager, 1, "Up position of the decoded area (region_y0=%d) is outside the image area (Ysiz=%d).\n",
                  p_start_y, l_image->y1);
    }
#line 7910
    return (0);
  } else
#line 7912
  if ((OPJ_UINT32 )p_start_y < l_image->y0) {
    {
#line 7913
    opj_event_msg(p_manager, 2, "Up position of the decoded area (region_y0=%d) is outside the image area (YOsiz=%d).\n",
                  p_start_y, l_image->y0);
#line 7916
    p_j2k->m_specific_param.m_decoder.m_start_tile_y = (OPJ_UINT32 )0;
#line 7917
    p_image->y0 = l_image->y0;
    }
  } else {
#line 7920
    p_j2k->m_specific_param.m_decoder.m_start_tile_y = ((unsigned int )p_start_y - l_cp->ty0) / l_cp->tdy;
#line 7921
    p_image->y0 = (OPJ_UINT32 )p_start_y;
  }
#line 7927
  if ((OPJ_UINT32 )p_end_x < l_image->x0) {
    {
#line 7928
    opj_event_msg(p_manager, 1, "Right position of the decoded area (region_x1=%d) is outside the image area (XOsiz=%d).\n\230\001",
                  p_end_x, l_image->x0);
    }
#line 7931
    return (0);
  } else
#line 7933
  if ((OPJ_UINT32 )p_end_x > l_image->x1) {
    {
#line 7934
    opj_event_msg(p_manager, 2, "Right position of the decoded area (region_x1=%d) is outside the image area (Xsiz=%d).\n",
                  p_end_x, l_image->x1);
#line 7937
    p_j2k->m_specific_param.m_decoder.m_end_tile_x = l_cp->tw;
#line 7938
    p_image->x1 = l_image->x1;
    }
  } else {
    {
#line 7941
    __cil_tmp18 = opj_int_ceildiv((OPJ_INT32 )((unsigned int )p_end_x - l_cp->tx0),
                                  (OPJ_INT32 )l_cp->tdx);
#line 7941
    p_j2k->m_specific_param.m_decoder.m_end_tile_x = (OPJ_UINT32 )__cil_tmp18;
#line 7942
    p_image->x1 = (OPJ_UINT32 )p_end_x;
    }
  }
#line 7946
  if ((OPJ_UINT32 )p_end_y < l_image->y0) {
    {
#line 7947
    opj_event_msg(p_manager, 1, "Bottom position of the decoded area (region_y1=%d) is outside the image area (YOsiz=%d).\n\333\325\211\202U",
                  p_end_y, l_image->y0);
    }
#line 7950
    return (0);
  }
#line 7952
  if ((OPJ_UINT32 )p_end_y > l_image->y1) {
    {
#line 7953
    opj_event_msg(p_manager, 2, "Bottom position of the decoded area (region_y1=%d) is outside the image area (Ysiz=%d).\n\230\001",
                  p_end_y, l_image->y1);
#line 7956
    p_j2k->m_specific_param.m_decoder.m_end_tile_y = l_cp->th;
#line 7957
    p_image->y1 = l_image->y1;
    }
  } else {
    {
#line 7960
    __cil_tmp19 = opj_int_ceildiv((OPJ_INT32 )((unsigned int )p_end_y - l_cp->ty0),
                                  (OPJ_INT32 )l_cp->tdy);
#line 7960
    p_j2k->m_specific_param.m_decoder.m_end_tile_y = (OPJ_UINT32 )__cil_tmp19;
#line 7961
    p_image->y1 = (OPJ_UINT32 )p_end_y;
    }
  }
#line 7965
  p_j2k->m_specific_param.m_decoder.m_discard_tiles = (OPJ_UINT32 )1;
#line 7967
  l_img_comp = p_image->comps;
#line 7968
  it_comp = (OPJ_UINT32 )0;
  {
#line 7968
  while (1) {
    while_continue: /* CIL Label */ ;

#line 7968
    if (! (it_comp < p_image->numcomps)) {
#line 7968
      goto while_break;
    }
    {
#line 7972
    __cil_tmp22 = opj_int_ceildiv((OPJ_INT32 )p_image->x0, (OPJ_INT32 )l_img_comp->dx);
#line 7972
    l_img_comp->x0 = (OPJ_UINT32 )__cil_tmp22;
#line 7973
    __cil_tmp23 = opj_int_ceildiv((OPJ_INT32 )p_image->y0, (OPJ_INT32 )l_img_comp->dy);
#line 7973
    l_img_comp->y0 = (OPJ_UINT32 )__cil_tmp23;
#line 7974
    l_comp_x1 = opj_int_ceildiv((OPJ_INT32 )p_image->x1, (OPJ_INT32 )l_img_comp->dx);
#line 7975
    l_comp_y1 = opj_int_ceildiv((OPJ_INT32 )p_image->y1, (OPJ_INT32 )l_img_comp->dy);
#line 7977
    __cil_tmp27 = opj_int_ceildivpow2((OPJ_INT32 )l_img_comp->x0, (OPJ_INT32 )l_img_comp->factor);
#line 7977
    __cil_tmp26 = opj_int_ceildivpow2(l_comp_x1, (OPJ_INT32 )l_img_comp->factor);
#line 7977
    l_w = __cil_tmp26 - __cil_tmp27;
    }
#line 7979
    if (l_w < 0) {
      {
#line 7980
      opj_event_msg(p_manager, 1, "Size x of the decoded component image is incorrect (comp[%d].w=%d).\n",
                    it_comp, l_w);
      }
#line 7983
      return (0);
    }
    {
#line 7985
    l_img_comp->w = (OPJ_UINT32 )l_w;
#line 7987
    __cil_tmp29 = opj_int_ceildivpow2((OPJ_INT32 )l_img_comp->y0, (OPJ_INT32 )l_img_comp->factor);
#line 7987
    __cil_tmp28 = opj_int_ceildivpow2(l_comp_y1, (OPJ_INT32 )l_img_comp->factor);
#line 7987
    l_h = __cil_tmp28 - __cil_tmp29;
    }
#line 7989
    if (l_h < 0) {
      {
#line 7990
      opj_event_msg(p_manager, 1, "Size y of the decoded component image is incorrect (comp[%d].h=%d).\n",
                    it_comp, l_h);
      }
#line 7993
      return (0);
    }
#line 7995
    l_img_comp->h = (OPJ_UINT32 )l_h;
#line 7997
    l_img_comp ++;
#line 7968
    it_comp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 8000
  opj_event_msg(p_manager, 4, "Setting decoding area to %d,%d,%d,%d\nU", p_image->x0,
                p_image->y0, p_image->x1, p_image->y1);
  }
#line 8003
  return (1);
}
}
#line 8006 "/root/patron/new_22/src/lib/openjp2/j2k.c"
opj_j2k_t *opj_j2k_create_decompress(void) 
{ 
  opj_j2k_t *l_j2k ;
  void *__cil_tmp2 ;
  void *__cil_tmp3 ;
  void *__cil_tmp4 ;

  {
  {
#line 8008
  __cil_tmp2 = malloc(sizeof(opj_j2k_t ));
#line 8008
  l_j2k = (opj_j2k_t *)__cil_tmp2;
  }
#line 8009
  if (! l_j2k) {
#line 8010
    return ((opj_j2k_t *)0);
  }
  {
#line 8012
  memset((void *)l_j2k, 0, sizeof(opj_j2k_t ));
#line 8014
  l_j2k->m_is_decoder = 1;
#line 8015
  l_j2k->m_cp.m_is_decoder = (OPJ_UINT32 )1;
#line 8017
  __cil_tmp3 = malloc(sizeof(opj_tcp_t ));
#line 8017
  l_j2k->m_specific_param.m_decoder.m_default_tcp = (opj_tcp_t *)__cil_tmp3;
  }
#line 8018
  if (! l_j2k->m_specific_param.m_decoder.m_default_tcp) {
    {
#line 8019
    opj_j2k_destroy(l_j2k);
    }
#line 8020
    return ((opj_j2k_t *)0);
  }
  {
#line 8022
  memset((void *)l_j2k->m_specific_param.m_decoder.m_default_tcp, 0, sizeof(opj_tcp_t ));
#line 8024
  __cil_tmp4 = malloc(1000UL);
#line 8024
  l_j2k->m_specific_param.m_decoder.m_header_data = (OPJ_BYTE *)__cil_tmp4;
  }
#line 8025
  if (! l_j2k->m_specific_param.m_decoder.m_header_data) {
    {
#line 8026
    opj_j2k_destroy(l_j2k);
    }
#line 8027
    return ((opj_j2k_t *)0);
  }
  {
#line 8030
  l_j2k->m_specific_param.m_decoder.m_header_data_size = (OPJ_UINT32 )1000;
#line 8032
  l_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec = -1;
#line 8034
  l_j2k->m_specific_param.m_decoder.m_last_sot_read_pos = (OPJ_OFF_T )0;
#line 8037
  l_j2k->cstr_index = opj_j2k_create_cstr_index();
#line 8049
  l_j2k->m_validation_list = opj_procedure_list_create();
  }
#line 8050
  if (! l_j2k->m_validation_list) {
    {
#line 8051
    opj_j2k_destroy(l_j2k);
    }
#line 8052
    return ((opj_j2k_t *)0);
  }
  {
#line 8056
  l_j2k->m_procedure_list = opj_procedure_list_create();
  }
#line 8057
  if (! l_j2k->m_procedure_list) {
    {
#line 8058
    opj_j2k_destroy(l_j2k);
    }
#line 8059
    return ((opj_j2k_t *)0);
  }
#line 8062
  return (l_j2k);
}
}
#line 8065 "/root/patron/new_22/src/lib/openjp2/j2k.c"
opj_codestream_index_t *opj_j2k_create_cstr_index(void) 
{ 
  opj_codestream_index_t *cstr_index ;
  void *__cil_tmp2 ;
  void *__cil_tmp3 ;

  {
  {
#line 8067
  __cil_tmp2 = calloc(1UL, sizeof(opj_codestream_index_t ));
#line 8067
  cstr_index = (opj_codestream_index_t *)__cil_tmp2;
  }
#line 8069
  if (! cstr_index) {
#line 8070
    return ((opj_codestream_index_t *)((void *)0));
  }
  {
#line 8072
  cstr_index->maxmarknum = (OPJ_UINT32 )100;
#line 8073
  cstr_index->marknum = (OPJ_UINT32 )0;
#line 8074
  __cil_tmp3 = calloc((unsigned long )cstr_index->maxmarknum, sizeof(opj_marker_info_t ));
#line 8074
  cstr_index->marker = (opj_marker_info_t *)__cil_tmp3;
  }
#line 8076
  if (! cstr_index->marker) {
#line 8077
    return ((opj_codestream_index_t *)((void *)0));
  }
#line 8079
  cstr_index->tile_index = (opj_tile_index_t *)((void *)0);
#line 8081
  return (cstr_index);
}
}
#line 8084 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_UINT32 opj_j2k_get_SPCod_SPCoc_size(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no ,
                                        OPJ_UINT32 p_comp_no ) 
{ 
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;

  {
#line 8088
  l_cp = (opj_cp_t *)0;
#line 8089
  l_tcp = (opj_tcp_t *)0;
#line 8090
  l_tccp = (opj_tccp_t *)0;
#line 8095
  l_cp = & p_j2k->m_cp;
#line 8096
  l_tcp = l_cp->tcps + p_tile_no;
#line 8097
  l_tccp = l_tcp->tccps + p_comp_no;
#line 8103
  if (l_tccp->csty & 1U) {
#line 8104
    return (5U + l_tccp->numresolutions);
  } else {
#line 8107
    return ((OPJ_UINT32 )5);
  }
}
}
#line 8111 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_SPCod_SPCoc(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no , OPJ_UINT32 p_comp_no ,
                                   OPJ_BYTE *p_data , OPJ_UINT32 *p_header_size ,
                                   struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 i ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;

  {
#line 8119
  l_cp = (opj_cp_t *)0;
#line 8120
  l_tcp = (opj_tcp_t *)0;
#line 8121
  l_tccp = (opj_tccp_t *)0;
#line 8129
  l_cp = & p_j2k->m_cp;
#line 8130
  l_tcp = l_cp->tcps + p_tile_no;
#line 8131
  l_tccp = l_tcp->tccps + p_comp_no;
#line 8137
  if (*p_header_size < 5U) {
    {
#line 8138
    opj_event_msg(p_manager, 1, "Error writing SPCod SPCoc element\n\326\211\202U");
    }
#line 8139
    return (0);
  }
  {
#line 8142
  opj_write_bytes_LE(p_data, l_tccp->numresolutions - 1U, (OPJ_UINT32 )1);
#line 8143
  p_data ++;
#line 8145
  opj_write_bytes_LE(p_data, l_tccp->cblkw - 2U, (OPJ_UINT32 )1);
#line 8146
  p_data ++;
#line 8148
  opj_write_bytes_LE(p_data, l_tccp->cblkh - 2U, (OPJ_UINT32 )1);
#line 8149
  p_data ++;
#line 8151
  opj_write_bytes_LE(p_data, l_tccp->cblksty, (OPJ_UINT32 )1);
#line 8152
  p_data ++;
#line 8154
  opj_write_bytes_LE(p_data, l_tccp->qmfbid, (OPJ_UINT32 )1);
#line 8155
  p_data ++;
#line 8157
  *p_header_size -= 5U;
  }
#line 8159
  if (l_tccp->csty & 1U) {
#line 8161
    if (*p_header_size < l_tccp->numresolutions) {
      {
#line 8162
      opj_event_msg(p_manager, 1, "Error writing SPCod SPCoc element\n");
      }
#line 8163
      return (0);
    }
#line 8166
    i = (OPJ_UINT32 )0;
    {
#line 8166
    while (1) {
      while_continue: /* CIL Label */ ;

#line 8166
      if (! (i < l_tccp->numresolutions)) {
#line 8166
        goto while_break;
      }
      {
#line 8167
      opj_write_bytes_LE(p_data, l_tccp->prcw[i] + (l_tccp->prch[i] << 4), (OPJ_UINT32 )1);
#line 8168
      p_data ++;
#line 8166
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: 
#line 8171
    *p_header_size -= l_tccp->numresolutions;
  }
#line 8174
  return (1);
}
}
#line 8177 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_read_SPCod_SPCoc(opj_j2k_t *p_j2k , OPJ_UINT32 compno , OPJ_BYTE *p_header_data ,
                                  OPJ_UINT32 *p_header_size , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_tmp ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;
  OPJ_BYTE *l_current_ptr ;
  opj_tcp_t *tmp___2 ;

  {
#line 8184
  l_cp = (opj_cp_t *)((void *)0);
#line 8185
  l_tcp = (opj_tcp_t *)((void *)0);
#line 8186
  l_tccp = (opj_tccp_t *)((void *)0);
#line 8187
  l_current_ptr = (OPJ_BYTE *)((void *)0);
#line 8194
  l_cp = & p_j2k->m_cp;
#line 8195
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 8195
    tmp___2 = l_cp->tcps + p_j2k->m_current_tile_number;
  } else {
#line 8195
    tmp___2 = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
#line 8195
  l_tcp = tmp___2;
#line 8202
  l_tccp = l_tcp->tccps + compno;
#line 8203
  l_current_ptr = p_header_data;
#line 8206
  if (*p_header_size < 5U) {
    {
#line 8207
    opj_event_msg(p_manager, 1, "Error reading SPCod SPCoc element\n\327\211\202U");
    }
#line 8208
    return (0);
  }
  {
#line 8211
  opj_read_bytes_LE(l_current_ptr, & l_tccp->numresolutions, (OPJ_UINT32 )1);
#line 8212
  (l_tccp->numresolutions) ++;
  }
#line 8213
  if (l_tccp->numresolutions > 33U) {
    {
#line 8214
    opj_event_msg(p_manager, 1, "Invalid value for numresolutions : %d, max value is set in openjpeg.h at %d\n",
                  l_tccp->numresolutions, 33);
    }
#line 8217
    return (0);
  }
#line 8219
  l_current_ptr ++;
#line 8222
  if (l_cp->m_specific_param.m_dec.m_reduce >= l_tccp->numresolutions) {
    {
#line 8223
    opj_event_msg(p_manager, 1, "Error decoding component %d.\nThe number of resolutions to remove is higher than the number of resolutions of this component\nModify the cp_reduce parameter.\n\n",
                  compno);
#line 8225
    p_j2k->m_specific_param.m_decoder.m_state |= 32768U;
    }
#line 8226
    return (0);
  }
  {
#line 8229
  opj_read_bytes_LE(l_current_ptr, & l_tccp->cblkw, (OPJ_UINT32 )1);
#line 8230
  l_current_ptr ++;
#line 8231
  l_tccp->cblkw += 2U;
#line 8233
  opj_read_bytes_LE(l_current_ptr, & l_tccp->cblkh, (OPJ_UINT32 )1);
#line 8234
  l_current_ptr ++;
#line 8235
  l_tccp->cblkh += 2U;
#line 8237
  opj_read_bytes_LE(l_current_ptr, & l_tccp->cblksty, (OPJ_UINT32 )1);
#line 8238
  l_current_ptr ++;
#line 8240
  opj_read_bytes_LE(l_current_ptr, & l_tccp->qmfbid, (OPJ_UINT32 )1);
#line 8241
  l_current_ptr ++;
#line 8243
  *p_header_size -= 5U;
  }
#line 8246
  if (l_tccp->csty & 1U) {
#line 8247
    if (*p_header_size < l_tccp->numresolutions) {
      {
#line 8248
      opj_event_msg(p_manager, 1, "Error reading SPCod SPCoc element\n");
      }
#line 8249
      return (0);
    }
#line 8252
    i = (OPJ_UINT32 )0;
    {
#line 8252
    while (1) {
      while_continue: /* CIL Label */ ;

#line 8252
      if (! (i < l_tccp->numresolutions)) {
#line 8252
        goto while_break;
      }
      {
#line 8253
      opj_read_bytes_LE(l_current_ptr, & l_tmp, (OPJ_UINT32 )1);
#line 8254
      l_current_ptr ++;
#line 8255
      l_tccp->prcw[i] = l_tmp & 15U;
#line 8256
      l_tccp->prch[i] = l_tmp >> 4;
#line 8252
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: 
#line 8259
    *p_header_size -= l_tccp->numresolutions;
  } else {
#line 8263
    i = (OPJ_UINT32 )0;
    {
#line 8263
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 8263
      if (! (i < l_tccp->numresolutions)) {
#line 8263
        goto while_break___0;
      }
#line 8264
      l_tccp->prcw[i] = (OPJ_UINT32 )15;
#line 8265
      l_tccp->prch[i] = (OPJ_UINT32 )15;
#line 8263
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
  }
#line 8286
  return (1);
}
}
#line 8289 "/root/patron/new_22/src/lib/openjp2/j2k.c"
void opj_j2k_copy_tile_component_parameters(opj_j2k_t *p_j2k ) 
{ 
  OPJ_UINT32 i ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_ref_tccp ;
  opj_tccp_t *l_copied_tccp ;
  OPJ_UINT32 l_prc_size ;
  opj_tcp_t *tmp___0 ;

  {
#line 8293
  l_cp = (opj_cp_t *)((void *)0);
#line 8294
  l_tcp = (opj_tcp_t *)((void *)0);
#line 8295
  l_ref_tccp = (opj_tccp_t *)((void *)0);
#line 8295
  l_copied_tccp = (opj_tccp_t *)((void *)0);
#line 8301
  l_cp = & p_j2k->m_cp;
#line 8302
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 8302
    tmp___0 = l_cp->tcps + p_j2k->m_current_tile_number;
  } else {
#line 8302
    tmp___0 = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
#line 8302
  l_tcp = tmp___0;
#line 8306
  l_ref_tccp = l_tcp->tccps + 0;
#line 8307
  l_copied_tccp = l_ref_tccp + 1;
#line 8308
  l_prc_size = (OPJ_UINT32 )((unsigned long )l_ref_tccp->numresolutions * sizeof(OPJ_UINT32 ));
#line 8310
  i = (OPJ_UINT32 )1;
  {
#line 8310
  while (1) {
    while_continue: /* CIL Label */ ;

#line 8310
    if (! (i < (p_j2k->m_private_image)->numcomps)) {
#line 8310
      goto while_break;
    }
    {
#line 8311
    l_copied_tccp->numresolutions = l_ref_tccp->numresolutions;
#line 8312
    l_copied_tccp->cblkw = l_ref_tccp->cblkw;
#line 8313
    l_copied_tccp->cblkh = l_ref_tccp->cblkh;
#line 8314
    l_copied_tccp->cblksty = l_ref_tccp->cblksty;
#line 8315
    l_copied_tccp->qmfbid = l_ref_tccp->qmfbid;
#line 8316
    memcpy((void *)(l_copied_tccp->prcw), (void const   *)(l_ref_tccp->prcw), (unsigned long )l_prc_size);
#line 8317
    memcpy((void *)(l_copied_tccp->prch), (void const   *)(l_ref_tccp->prch), (unsigned long )l_prc_size);
#line 8318
    l_copied_tccp ++;
#line 8310
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 8314
  return;
}
}
#line 8322 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_UINT32 opj_j2k_get_SQcd_SQcc_size(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no , OPJ_UINT32 p_comp_no ) 
{ 
  OPJ_UINT32 l_num_bands ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;
  unsigned int tmp___2 ;

  {
#line 8328
  l_cp = (opj_cp_t *)0;
#line 8329
  l_tcp = (opj_tcp_t *)0;
#line 8330
  l_tccp = (opj_tccp_t *)0;
#line 8335
  l_cp = & p_j2k->m_cp;
#line 8336
  l_tcp = l_cp->tcps + p_tile_no;
#line 8337
  l_tccp = l_tcp->tccps + p_comp_no;
#line 8343
  if (l_tccp->qntsty == 1U) {
#line 8343
    tmp___2 = 1U;
  } else {
#line 8343
    tmp___2 = l_tccp->numresolutions * 3U - 2U;
  }
#line 8343
  l_num_bands = tmp___2;
#line 8345
  if (l_tccp->qntsty == 0U) {
#line 8346
    return (1U + l_num_bands);
  } else {
#line 8349
    return (1U + 2U * l_num_bands);
  }
}
}
#line 8353 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_SQcd_SQcc(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no , OPJ_UINT32 p_comp_no ,
                                 OPJ_BYTE *p_data , OPJ_UINT32 *p_header_size , struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 l_header_size ;
  OPJ_UINT32 l_band_no ;
  OPJ_UINT32 l_num_bands ;
  OPJ_UINT32 l_expn ;
  OPJ_UINT32 l_mant ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;
  unsigned int tmp___5 ;

  {
#line 8364
  l_cp = (opj_cp_t *)0;
#line 8365
  l_tcp = (opj_tcp_t *)0;
#line 8366
  l_tccp = (opj_tccp_t *)0;
#line 8374
  l_cp = & p_j2k->m_cp;
#line 8375
  l_tcp = l_cp->tcps + p_tile_no;
#line 8376
  l_tccp = l_tcp->tccps + p_comp_no;
#line 8382
  if (l_tccp->qntsty == 1U) {
#line 8382
    tmp___5 = 1U;
  } else {
#line 8382
    tmp___5 = l_tccp->numresolutions * 3U - 2U;
  }
#line 8382
  l_num_bands = tmp___5;
#line 8384
  if (l_tccp->qntsty == 0U) {
#line 8385
    l_header_size = 1U + l_num_bands;
#line 8387
    if (*p_header_size < l_header_size) {
      {
#line 8388
      opj_event_msg(p_manager, 1, "Error writing SQcd SQcc element\n\220");
      }
#line 8389
      return (0);
    }
    {
#line 8392
    opj_write_bytes_LE(p_data, l_tccp->qntsty + (l_tccp->numgbits << 5), (OPJ_UINT32 )1);
#line 8393
    p_data ++;
#line 8395
    l_band_no = (OPJ_UINT32 )0;
    }
    {
#line 8395
    while (1) {
      while_continue: /* CIL Label */ ;

#line 8395
      if (! (l_band_no < l_num_bands)) {
#line 8395
        goto while_break;
      }
      {
#line 8396
      l_expn = (OPJ_UINT32 )l_tccp->stepsizes[l_band_no].expn;
#line 8397
      opj_write_bytes_LE(p_data, l_expn << 3, (OPJ_UINT32 )1);
#line 8398
      p_data ++;
#line 8395
      l_band_no ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: ;
  } else {
#line 8402
    l_header_size = 1U + 2U * l_num_bands;
#line 8404
    if (*p_header_size < l_header_size) {
      {
#line 8405
      opj_event_msg(p_manager, 1, "Error writing SQcd SQcc element\n\220");
      }
#line 8406
      return (0);
    }
    {
#line 8409
    opj_write_bytes_LE(p_data, l_tccp->qntsty + (l_tccp->numgbits << 5), (OPJ_UINT32 )1);
#line 8410
    p_data ++;
#line 8412
    l_band_no = (OPJ_UINT32 )0;
    }
    {
#line 8412
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 8412
      if (! (l_band_no < l_num_bands)) {
#line 8412
        goto while_break___0;
      }
      {
#line 8413
      l_expn = (OPJ_UINT32 )l_tccp->stepsizes[l_band_no].expn;
#line 8414
      l_mant = (OPJ_UINT32 )l_tccp->stepsizes[l_band_no].mant;
#line 8416
      opj_write_bytes_LE(p_data, (l_expn << 11) + l_mant, (OPJ_UINT32 )2);
#line 8417
      p_data += 2;
#line 8412
      l_band_no ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
  }
#line 8421
  *p_header_size -= l_header_size;
#line 8423
  return (1);
}
}
#line 8426 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_read_SQcd_SQcc(opj_j2k_t *p_j2k , OPJ_UINT32 p_comp_no , OPJ_BYTE *p_header_data ,
                                OPJ_UINT32 *p_header_size , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_band_no ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;
  OPJ_BYTE *l_current_ptr ;
  OPJ_UINT32 l_tmp ;
  OPJ_UINT32 l_num_band ;
  opj_tcp_t *tmp___2 ;
  OPJ_UINT32 tmp___4 ;
  unsigned int tmp___5 ;

  {
#line 8435
  l_cp = (opj_cp_t *)0;
#line 8436
  l_tcp = (opj_tcp_t *)0;
#line 8437
  l_tccp = (opj_tccp_t *)0;
#line 8438
  l_current_ptr = (OPJ_BYTE *)0;
#line 8446
  l_cp = & p_j2k->m_cp;
#line 8448
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 8448
    tmp___2 = l_cp->tcps + p_j2k->m_current_tile_number;
  } else {
#line 8448
    tmp___2 = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
#line 8448
  l_tcp = tmp___2;
#line 8455
  l_tccp = l_tcp->tccps + p_comp_no;
#line 8456
  l_current_ptr = p_header_data;
#line 8458
  if (*p_header_size < 1U) {
    {
#line 8459
    opj_event_msg(p_manager, 1, "Error reading SQcd or SQcc element\n");
    }
#line 8460
    return (0);
  }
  {
#line 8462
  (*p_header_size) --;
#line 8464
  opj_read_bytes_LE(l_current_ptr, & l_tmp, (OPJ_UINT32 )1);
#line 8465
  l_current_ptr ++;
#line 8467
  l_tccp->qntsty = l_tmp & 31U;
#line 8468
  l_tccp->numgbits = l_tmp >> 5;
  }
#line 8469
  if (l_tccp->qntsty == 1U) {
#line 8470
    l_num_band = (OPJ_UINT32 )1;
  } else {
#line 8473
    if (l_tccp->qntsty == 0U) {
#line 8473
      tmp___4 = *p_header_size;
    } else {
#line 8473
      tmp___4 = *p_header_size / 2U;
    }
#line 8473
    l_num_band = tmp___4;
#line 8477
    if (l_num_band > 97U) {
      {
#line 8478
      opj_event_msg(p_manager, 2, "While reading CCP_QNTSTY element inside QCD or QCC marker segment, number of subbands (%d) is greater to OPJ_J2K_MAXBANDS (%d). So we limit the number of elements stored to OPJ_J2K_MAXBANDS (%d) and skip the rest. \n",
                    l_num_band, 97, 97);
      }
    }
  }
#line 8507
  if (l_tccp->qntsty == 0U) {
#line 8508
    l_band_no = (OPJ_UINT32 )0;
    {
#line 8508
    while (1) {
      while_continue: /* CIL Label */ ;

#line 8508
      if (! (l_band_no < l_num_band)) {
#line 8508
        goto while_break;
      }
      {
#line 8509
      opj_read_bytes_LE(l_current_ptr, & l_tmp, (OPJ_UINT32 )1);
#line 8510
      l_current_ptr ++;
      }
#line 8511
      if (l_band_no < 97U) {
#line 8512
        l_tccp->stepsizes[l_band_no].expn = (OPJ_INT32 )(l_tmp >> 3);
#line 8513
        l_tccp->stepsizes[l_band_no].mant = 0;
      }
#line 8508
      l_band_no ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break: 
#line 8516
    *p_header_size -= l_num_band;
  } else {
#line 8519
    l_band_no = (OPJ_UINT32 )0;
    {
#line 8519
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 8519
      if (! (l_band_no < l_num_band)) {
#line 8519
        goto while_break___0;
      }
      {
#line 8520
      opj_read_bytes_LE(l_current_ptr, & l_tmp, (OPJ_UINT32 )2);
#line 8521
      l_current_ptr += 2;
      }
#line 8522
      if (l_band_no < 97U) {
#line 8523
        l_tccp->stepsizes[l_band_no].expn = (OPJ_INT32 )(l_tmp >> 11);
#line 8524
        l_tccp->stepsizes[l_band_no].mant = (OPJ_INT32 )(l_tmp & 2047U);
      }
#line 8519
      l_band_no ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
#line 8527
    *p_header_size -= 2U * l_num_band;
  }
#line 8531
  if (l_tccp->qntsty == 1U) {
#line 8532
    l_band_no = (OPJ_UINT32 )1;
    {
#line 8532
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 8532
      if (! (l_band_no < 97U)) {
#line 8532
        goto while_break___1;
      }
#line 8533
      if ((unsigned int )l_tccp->stepsizes[0].expn - (l_band_no - 1U) / 3U > 0U) {
#line 8533
        tmp___5 = (unsigned int )l_tccp->stepsizes[0].expn - (l_band_no - 1U) / 3U;
      } else {
#line 8533
        tmp___5 = 0U;
      }
#line 8533
      l_tccp->stepsizes[l_band_no].expn = (OPJ_INT32 )tmp___5;
#line 8536
      l_tccp->stepsizes[l_band_no].mant = l_tccp->stepsizes[0].mant;
#line 8532
      l_band_no ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: ;
  }
#line 8540
  return (1);
}
}
#line 8543 "/root/patron/new_22/src/lib/openjp2/j2k.c"
void opj_j2k_copy_tile_quantization_parameters(opj_j2k_t *p_j2k ) 
{ 
  OPJ_UINT32 i ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_ref_tccp ;
  opj_tccp_t *l_copied_tccp ;
  OPJ_UINT32 l_size ;
  opj_tcp_t *tmp___0 ;

  {
#line 8546
  l_cp = (opj_cp_t *)((void *)0);
#line 8547
  l_tcp = (opj_tcp_t *)((void *)0);
#line 8548
  l_ref_tccp = (opj_tccp_t *)((void *)0);
#line 8549
  l_copied_tccp = (opj_tccp_t *)((void *)0);
#line 8555
  l_cp = & p_j2k->m_cp;
#line 8556
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 8556
    tmp___0 = l_cp->tcps + p_j2k->m_current_tile_number;
  } else {
#line 8556
    tmp___0 = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
#line 8556
  l_tcp = tmp___0;
#line 8560
  l_ref_tccp = l_tcp->tccps + 0;
#line 8561
  l_copied_tccp = l_ref_tccp + 1;
#line 8562
  l_size = (OPJ_UINT32 )(97UL * sizeof(opj_stepsize_t ));
#line 8564
  i = (OPJ_UINT32 )1;
  {
#line 8564
  while (1) {
    while_continue: /* CIL Label */ ;

#line 8564
    if (! (i < (p_j2k->m_private_image)->numcomps)) {
#line 8564
      goto while_break;
    }
    {
#line 8565
    l_copied_tccp->qntsty = l_ref_tccp->qntsty;
#line 8566
    l_copied_tccp->numgbits = l_ref_tccp->numgbits;
#line 8567
    memcpy((void *)(l_copied_tccp->stepsizes), (void const   *)(l_ref_tccp->stepsizes),
           (unsigned long )l_size);
#line 8568
    l_copied_tccp ++;
#line 8564
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 8568
  return;
}
}
#line 8572 "/root/patron/new_22/src/lib/openjp2/j2k.c"
void j2k_dump(opj_j2k_t *p_j2k , OPJ_INT32 flag , FILE *out_stream ) 
{ 


  {
#line 8575
  if (flag & 128) {
    {
#line 8576
    fprintf(out_stream, "Wrong flag\n");
    }
#line 8577
    return;
  } else
#line 8575
  if (flag & 256) {
    {
#line 8576
    fprintf(out_stream, "Wrong flag\n");
    }
#line 8577
    return;
  }
#line 8581
  if (flag & 1) {
#line 8582
    if (p_j2k->m_private_image) {
      {
#line 8583
      j2k_dump_image_header(p_j2k->m_private_image, 0, out_stream);
      }
    }
  }
#line 8587
  if (flag & 2) {
    {
#line 8588
    opj_j2k_dump_MH_info(p_j2k, out_stream);
    }
  }
#line 8597
  if (flag & 16) {
    {
#line 8598
    opj_j2k_dump_MH_index(p_j2k, out_stream);
    }
  }
#line 8605
  return;
}
}
#line 8608 "/root/patron/new_22/src/lib/openjp2/j2k.c"
void opj_j2k_dump_MH_index(opj_j2k_t *p_j2k , FILE *out_stream ) 
{ 
  opj_codestream_index_t *cstr_index ;
  OPJ_UINT32 it_marker ;
  OPJ_UINT32 it_tile ;
  OPJ_UINT32 it_tile_part ;
  OPJ_UINT32 l_acc_nb_of_tile_part ;
  OPJ_UINT32 nb_of_tile_part ;

  {
  {
#line 8610
  cstr_index = p_j2k->cstr_index;
#line 8613
  fprintf(out_stream, "Codestream index from main header: {\nU");
#line 8615
  fprintf(out_stream, "\t Main header start position=%li\n\t Main header end position=%li\n",
          cstr_index->main_head_start, cstr_index->main_head_end);
#line 8619
  fprintf(out_stream, "\t Marker list: {\nR\330\211\202U");
  }
#line 8621
  if (cstr_index->marker) {
#line 8622
    it_marker = (OPJ_UINT32 )0;
    {
#line 8622
    while (1) {
      while_continue: /* CIL Label */ ;

#line 8622
      if (! (it_marker < cstr_index->marknum)) {
#line 8622
        goto while_break;
      }
      {
#line 8623
      fprintf(out_stream, "\t\t type=%#x, pos=%li, len=%d\n", (int )(cstr_index->marker + it_marker)->type,
              (cstr_index->marker + it_marker)->pos, (cstr_index->marker + it_marker)->len);
#line 8622
      it_marker ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break: ;
  }
  {
#line 8630
  fprintf(out_stream, "\t }\n");
  }
#line 8632
  if (cstr_index->tile_index) {
#line 8635
    l_acc_nb_of_tile_part = (OPJ_UINT32 )0;
#line 8636
    it_tile = (OPJ_UINT32 )0;
    {
#line 8636
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 8636
      if (! (it_tile < cstr_index->nb_of_tiles)) {
#line 8636
        goto while_break___0;
      }
#line 8637
      l_acc_nb_of_tile_part += (cstr_index->tile_index + it_tile)->nb_tps;
#line 8636
      it_tile ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: ;
#line 8640
    if (l_acc_nb_of_tile_part) {
      {
#line 8642
      fprintf(out_stream, "\t Tile index: {\n\220");
#line 8644
      it_tile = (OPJ_UINT32 )0;
      }
      {
#line 8644
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 8644
        if (! (it_tile < cstr_index->nb_of_tiles)) {
#line 8644
          goto while_break___1;
        }
        {
#line 8645
        nb_of_tile_part = (cstr_index->tile_index + it_tile)->nb_tps;
#line 8647
        fprintf(out_stream, "\t\t nb of tile-part in tile [%d]=%d\n\211\202U", it_tile,
                nb_of_tile_part);
        }
#line 8649
        if ((cstr_index->tile_index + it_tile)->tp_index) {
#line 8650
          it_tile_part = (OPJ_UINT32 )0;
          {
#line 8650
          while (1) {
            while_continue___2: /* CIL Label */ ;

#line 8650
            if (! (it_tile_part < nb_of_tile_part)) {
#line 8650
              goto while_break___2;
            }
            {
#line 8651
            fprintf(out_stream, "\t\t\t tile-part[%d]: star_pos=%li, end_header=%li, end_pos=%li.\n\330\211\202U",
                    it_tile_part, ((cstr_index->tile_index + it_tile)->tp_index + it_tile_part)->start_pos,
                    ((cstr_index->tile_index + it_tile)->tp_index + it_tile_part)->end_header,
                    ((cstr_index->tile_index + it_tile)->tp_index + it_tile_part)->end_pos);
#line 8650
            it_tile_part ++;
            }
          }
          while_break___7: /* CIL Label */ ;
          }
          while_break___2: ;
        }
#line 8659
        if ((cstr_index->tile_index + it_tile)->marker) {
#line 8660
          it_marker = (OPJ_UINT32 )0;
          {
#line 8660
          while (1) {
            while_continue___3: /* CIL Label */ ;

#line 8660
            if (! (it_marker < (cstr_index->tile_index + it_tile)->marknum)) {
#line 8660
              goto while_break___3;
            }
            {
#line 8661
            fprintf(out_stream, "\t\t type=%#x, pos=%li, len=%d\n", (int )((cstr_index->tile_index + it_tile)->marker + it_marker)->type,
                    ((cstr_index->tile_index + it_tile)->marker + it_marker)->pos,
                    ((cstr_index->tile_index + it_tile)->marker + it_marker)->len);
#line 8660
            it_marker ++;
            }
          }
          while_break___8: /* CIL Label */ ;
          }
          while_break___3: ;
        }
#line 8644
        it_tile ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___1: 
      {
#line 8668
      fprintf(out_stream, "\t }\n");
      }
    }
  }
  {
#line 8672
  fprintf(out_stream, "}\n");
  }
#line 8674
  return;
}
}
#line 8676 "/root/patron/new_22/src/lib/openjp2/j2k.c"
void opj_j2k_dump_MH_info(opj_j2k_t *p_j2k , FILE *out_stream ) 
{ 
  opj_tcp_t *l_default_tile ;
  OPJ_INT32 compno ;
  OPJ_INT32 numcomps ;
  opj_tccp_t *l_tccp ;
  OPJ_UINT32 resno ;
  OPJ_INT32 bandno ;
  OPJ_INT32 numbands ;
  unsigned int tmp ;

  {
  {
#line 8678
  l_default_tile = (opj_tcp_t *)((void *)0);
#line 8680
  fprintf(out_stream, "Codestream info from main header: {\n");
#line 8682
  fprintf(out_stream, "\t tx0=%d, ty0=%d\n", p_j2k->m_cp.tx0, p_j2k->m_cp.ty0);
#line 8683
  fprintf(out_stream, "\t tdx=%d, tdy=%d\n", p_j2k->m_cp.tdx, p_j2k->m_cp.tdy);
#line 8684
  fprintf(out_stream, "\t tw=%d, th=%d\n", p_j2k->m_cp.tw, p_j2k->m_cp.th);
#line 8686
  l_default_tile = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
#line 8687
  if (l_default_tile) {
    {
#line 8690
    numcomps = (OPJ_INT32 )(p_j2k->m_private_image)->numcomps;
#line 8692
    fprintf(out_stream, "\t default tile {\n");
#line 8693
    fprintf(out_stream, "\t\t csty=%#x\n", l_default_tile->csty);
#line 8694
    fprintf(out_stream, "\t\t prg=%#x\n", (int )l_default_tile->prg);
#line 8695
    fprintf(out_stream, "\t\t numlayers=%d\n\230\001", l_default_tile->numlayers);
#line 8696
    fprintf(out_stream, "\t\t mct=%x\n", l_default_tile->mct);
#line 8698
    compno = 0;
    }
    {
#line 8698
    while (1) {
      while_continue: /* CIL Label */ ;

#line 8698
      if (! (compno < numcomps)) {
#line 8698
        goto while_break;
      }
      {
#line 8699
      l_tccp = l_default_tile->tccps + compno;
#line 8704
      fprintf(out_stream, "\t\t comp %d {\n", compno);
#line 8705
      fprintf(out_stream, "\t\t\t csty=%#x\n", l_tccp->csty);
#line 8706
      fprintf(out_stream, "\t\t\t numresolutions=%d\n", l_tccp->numresolutions);
#line 8707
      fprintf(out_stream, "\t\t\t cblkw=2^%d\n", l_tccp->cblkw);
#line 8708
      fprintf(out_stream, "\t\t\t cblkh=2^%d\n", l_tccp->cblkh);
#line 8709
      fprintf(out_stream, "\t\t\t cblksty=%#x\n\230\001", l_tccp->cblksty);
#line 8710
      fprintf(out_stream, "\t\t\t qmfbid=%d\n", l_tccp->qmfbid);
#line 8712
      fprintf(out_stream, "\t\t\t preccintsize (w,h)=");
#line 8713
      resno = (OPJ_UINT32 )0;
      }
      {
#line 8713
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 8713
        if (! (resno < l_tccp->numresolutions)) {
#line 8713
          goto while_break___0;
        }
        {
#line 8714
        fprintf(out_stream, "(%d,%d) \230\001", l_tccp->prcw[resno], l_tccp->prch[resno]);
#line 8713
        resno ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break___0: 
      {
#line 8716
      fprintf(out_stream, "\n");
#line 8719
      fprintf(out_stream, "\t\t\t qntsty=%d\n", l_tccp->qntsty);
#line 8720
      fprintf(out_stream, "\t\t\t numgbits=%d\n\230\001", l_tccp->numgbits);
#line 8721
      fprintf(out_stream, "\t\t\t stepsizes (m,e)=");
      }
#line 8722
      if (l_tccp->qntsty == 1U) {
#line 8722
        tmp = 1U;
      } else {
#line 8722
        tmp = l_tccp->numresolutions * 3U - 2U;
      }
#line 8722
      numbands = (OPJ_INT32 )tmp;
#line 8723
      bandno = 0;
      {
#line 8723
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 8723
        if (! (bandno < numbands)) {
#line 8723
          goto while_break___1;
        }
        {
#line 8724
        fprintf(out_stream, "(%d,%d) \230\001", l_tccp->stepsizes[bandno].mant, l_tccp->stepsizes[bandno].expn);
#line 8723
        bandno ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: 
      {
#line 8727
      fprintf(out_stream, "\n");
#line 8730
      fprintf(out_stream, "\t\t\t roishift=%d\n\230\001", l_tccp->roishift);
#line 8732
      fprintf(out_stream, "\t\t }\n");
#line 8698
      compno ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break: 
    {
#line 8734
    fprintf(out_stream, "\t }\n");
    }
  }
  {
#line 8738
  fprintf(out_stream, "}\n");
  }
#line 8740
  return;
}
}
#line 8742 "/root/patron/new_22/src/lib/openjp2/j2k.c"
void j2k_dump_image_header(opj_image_t *img_header , OPJ_BOOL dev_dump_flag , FILE *out_stream ) 
{ 
  char tab[2] ;
  OPJ_UINT32 compno ;

  {
#line 8746
  if (dev_dump_flag) {
    {
#line 8747
    fprintf(stdout, "[DEV] Dump an image_header struct {\n");
#line 8748
    tab[0] = (char )'\000';
    }
  } else {
    {
#line 8751
    fprintf(out_stream, "Image info {\n");
#line 8752
    tab[0] = (char )'\t';
#line 8752
    tab[1] = (char )'\000';
    }
  }
  {
#line 8755
  fprintf(out_stream, "%s x0=%d, y0=%d\n\230\001", tab, img_header->x0, img_header->y0);
#line 8756
  fprintf(out_stream, "%s x1=%d, y1=%d\n\230\001", tab, img_header->x1, img_header->y1);
#line 8757
  fprintf(out_stream, "%s numcomps=%d\n", tab, img_header->numcomps);
  }
#line 8759
  if (img_header->comps) {
#line 8761
    compno = (OPJ_UINT32 )0;
    {
#line 8761
    while (1) {
      while_continue: /* CIL Label */ ;

#line 8761
      if (! (compno < img_header->numcomps)) {
#line 8761
        goto while_break;
      }
      {
#line 8762
      fprintf(out_stream, "%s\t component %d {\n", tab, compno);
#line 8763
      j2k_dump_image_comp_header(img_header->comps + compno, dev_dump_flag, out_stream);
#line 8764
      fprintf(out_stream, "%s}\n", tab);
#line 8761
      compno ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
  {
#line 8768
  fprintf(out_stream, "}\n");
  }
#line 8770
  return;
}
}
#line 8771 "/root/patron/new_22/src/lib/openjp2/j2k.c"
void j2k_dump_image_comp_header(opj_image_comp_t *comp_header , OPJ_BOOL dev_dump_flag ,
                                FILE *out_stream ) 
{ 
  char tab[3] ;

  {
#line 8775
  if (dev_dump_flag) {
    {
#line 8776
    fprintf(stdout, "[DEV] Dump an image_comp_header struct {\n");
#line 8777
    tab[0] = (char )'\000';
    }
  } else {
#line 8779
    tab[0] = (char )'\t';
#line 8779
    tab[1] = (char )'\t';
#line 8779
    tab[2] = (char )'\000';
  }
  {
#line 8782
  fprintf(out_stream, "%s dx=%d, dy=%d\n\230\001", tab, comp_header->dx, comp_header->dy);
#line 8783
  fprintf(out_stream, "%s prec=%d\n", tab, comp_header->prec);
#line 8784
  fprintf(out_stream, "%s sgnd=%d\n", tab, comp_header->sgnd);
  }
#line 8786
  if (dev_dump_flag) {
    {
#line 8787
    fprintf(out_stream, "}\n");
    }
  }
#line 8790
  return;
}
}
#line 8790 "/root/patron/new_22/src/lib/openjp2/j2k.c"
opj_codestream_info_v2_t *j2k_get_cstr_info(opj_j2k_t *p_j2k ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_UINT32 numcomps ;
  opj_tcp_t *l_default_tile ;
  opj_codestream_info_v2_t *cstr_info ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;
  opj_tccp_t *l_tccp ;
  opj_tccp_info_t *l_tccp_info ;
  OPJ_INT32 bandno ;
  OPJ_INT32 numbands ;
  unsigned int tmp ;

  {
  {
#line 8793
  numcomps = (p_j2k->m_private_image)->numcomps;
#line 8795
  __cil_tmp6 = calloc(1UL, sizeof(opj_codestream_info_v2_t ));
#line 8795
  cstr_info = (opj_codestream_info_v2_t *)__cil_tmp6;
  }
#line 8796
  if (! cstr_info) {
#line 8797
    return ((opj_codestream_info_v2_t *)((void *)0));
  }
  {
#line 8799
  cstr_info->nbcomps = (p_j2k->m_private_image)->numcomps;
#line 8801
  cstr_info->tx0 = p_j2k->m_cp.tx0;
#line 8802
  cstr_info->ty0 = p_j2k->m_cp.ty0;
#line 8803
  cstr_info->tdx = p_j2k->m_cp.tdx;
#line 8804
  cstr_info->tdy = p_j2k->m_cp.tdy;
#line 8805
  cstr_info->tw = p_j2k->m_cp.tw;
#line 8806
  cstr_info->th = p_j2k->m_cp.th;
#line 8808
  cstr_info->tile_info = (opj_tile_info_v2_t *)((void *)0);
#line 8810
  l_default_tile = p_j2k->m_specific_param.m_decoder.m_default_tcp;
#line 8812
  cstr_info->m_default_tile_info.csty = l_default_tile->csty;
#line 8813
  cstr_info->m_default_tile_info.prg = l_default_tile->prg;
#line 8814
  cstr_info->m_default_tile_info.numlayers = l_default_tile->numlayers;
#line 8815
  cstr_info->m_default_tile_info.mct = l_default_tile->mct;
#line 8817
  __cil_tmp7 = calloc((unsigned long )cstr_info->nbcomps, sizeof(opj_tccp_info_t ));
#line 8817
  cstr_info->m_default_tile_info.tccp_info = (opj_tccp_info_t *)__cil_tmp7;
  }
#line 8818
  if (! cstr_info->m_default_tile_info.tccp_info) {
    {
#line 8820
    opj_destroy_cstr_info(& cstr_info);
    }
#line 8821
    return ((opj_codestream_info_v2_t *)((void *)0));
  }
#line 8824
  compno = (OPJ_UINT32 )0;
  {
#line 8824
  while (1) {
    while_continue: /* CIL Label */ ;

#line 8824
    if (! (compno < numcomps)) {
#line 8824
      goto while_break;
    }
#line 8825
    l_tccp = l_default_tile->tccps + compno;
#line 8826
    l_tccp_info = cstr_info->m_default_tile_info.tccp_info + compno;
#line 8830
    l_tccp_info->csty = l_tccp->csty;
#line 8831
    l_tccp_info->numresolutions = l_tccp->numresolutions;
#line 8832
    l_tccp_info->cblkw = l_tccp->cblkw;
#line 8833
    l_tccp_info->cblkh = l_tccp->cblkh;
#line 8834
    l_tccp_info->cblksty = l_tccp->cblksty;
#line 8835
    l_tccp_info->qmfbid = l_tccp->qmfbid;
#line 8836
    if (l_tccp->numresolutions < 33U) {
      {
#line 8838
      memcpy((void *)(l_tccp_info->prch), (void const   *)(l_tccp->prch), (unsigned long )l_tccp->numresolutions);
#line 8839
      memcpy((void *)(l_tccp_info->prcw), (void const   *)(l_tccp->prcw), (unsigned long )l_tccp->numresolutions);
      }
    }
#line 8843
    l_tccp_info->qntsty = l_tccp->qntsty;
#line 8844
    l_tccp_info->numgbits = l_tccp->numgbits;
#line 8846
    if (l_tccp->qntsty == 1U) {
#line 8846
      tmp = 1U;
    } else {
#line 8846
      tmp = l_tccp->numresolutions * 3U - 2U;
    }
#line 8846
    numbands = (OPJ_INT32 )tmp;
#line 8847
    if (numbands < 97) {
#line 8848
      bandno = 0;
      {
#line 8848
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 8848
        if (! (bandno < numbands)) {
#line 8848
          goto while_break___0;
        }
#line 8849
        l_tccp_info->stepsizes_mant[bandno] = (OPJ_UINT32 )l_tccp->stepsizes[bandno].mant;
#line 8850
        l_tccp_info->stepsizes_expn[bandno] = (OPJ_UINT32 )l_tccp->stepsizes[bandno].expn;
#line 8848
        bandno ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: ;
    }
#line 8855
    l_tccp_info->roishift = l_tccp->roishift;
#line 8824
    compno ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 8858
  return (cstr_info);
}
}
#line 8861 "/root/patron/new_22/src/lib/openjp2/j2k.c"
opj_codestream_index_t *j2k_get_cstr_index(opj_j2k_t *p_j2k ) 
{ 
  opj_codestream_index_t *l_cstr_index ;
  void *__cil_tmp3 ;
  void *__cil_tmp4 ;
  void *__cil_tmp5 ;
  OPJ_UINT32 it_tile ;
  void *__cil_tmp7 ;
  OPJ_UINT32 it_tile_free ;
  void *__cil_tmp10 ;
  OPJ_UINT32 it_tile_free___0 ;

  {
  {
#line 8863
  __cil_tmp3 = calloc(1UL, sizeof(opj_codestream_index_t ));
#line 8863
  l_cstr_index = (opj_codestream_index_t *)__cil_tmp3;
  }
#line 8865
  if (! l_cstr_index) {
#line 8866
    return ((opj_codestream_index_t *)((void *)0));
  }
  {
#line 8868
  l_cstr_index->main_head_start = (p_j2k->cstr_index)->main_head_start;
#line 8869
  l_cstr_index->main_head_end = (p_j2k->cstr_index)->main_head_end;
#line 8870
  l_cstr_index->codestream_size = (p_j2k->cstr_index)->codestream_size;
#line 8872
  l_cstr_index->marknum = (p_j2k->cstr_index)->marknum;
#line 8873
  __cil_tmp4 = malloc((unsigned long )l_cstr_index->marknum * sizeof(opj_marker_info_t ));
#line 8873
  l_cstr_index->marker = (opj_marker_info_t *)__cil_tmp4;
  }
#line 8874
  if (! l_cstr_index->marker) {
    {
#line 8875
    free((void *)l_cstr_index);
    }
#line 8876
    return ((opj_codestream_index_t *)((void *)0));
  }
#line 8879
  if ((p_j2k->cstr_index)->marker) {
    {
#line 8880
    memcpy((void *)l_cstr_index->marker, (void const   *)(p_j2k->cstr_index)->marker,
           (unsigned long )l_cstr_index->marknum * sizeof(opj_marker_info_t ));
    }
  } else {
    {
#line 8882
    free((void *)l_cstr_index->marker);
#line 8883
    l_cstr_index->marker = (opj_marker_info_t *)((void *)0);
    }
  }
  {
#line 8886
  l_cstr_index->nb_of_tiles = (p_j2k->cstr_index)->nb_of_tiles;
#line 8887
  __cil_tmp5 = calloc((unsigned long )l_cstr_index->nb_of_tiles, sizeof(opj_tile_index_t ));
#line 8887
  l_cstr_index->tile_index = (opj_tile_index_t *)__cil_tmp5;
  }
#line 8888
  if (! l_cstr_index->tile_index) {
    {
#line 8889
    free((void *)l_cstr_index->marker);
#line 8890
    free((void *)l_cstr_index);
    }
#line 8891
    return ((opj_codestream_index_t *)((void *)0));
  }
#line 8894
  if (! (p_j2k->cstr_index)->tile_index) {
    {
#line 8895
    free((void *)l_cstr_index->tile_index);
#line 8896
    l_cstr_index->tile_index = (opj_tile_index_t *)((void *)0);
    }
  } else {
#line 8899
    it_tile = (OPJ_UINT32 )0;
#line 8900
    it_tile = (OPJ_UINT32 )0;
    {
#line 8900
    while (1) {
      while_continue: /* CIL Label */ ;

#line 8900
      if (! (it_tile < l_cstr_index->nb_of_tiles)) {
#line 8900
        goto while_break;
      }
      {
#line 8903
      (l_cstr_index->tile_index + it_tile)->marknum = ((p_j2k->cstr_index)->tile_index + it_tile)->marknum;
#line 8905
      __cil_tmp7 = malloc((unsigned long )(l_cstr_index->tile_index + it_tile)->marknum * sizeof(opj_marker_info_t ));
#line 8905
      (l_cstr_index->tile_index + it_tile)->marker = (opj_marker_info_t *)__cil_tmp7;
      }
#line 8908
      if (! (l_cstr_index->tile_index + it_tile)->marker) {
#line 8911
        it_tile_free = (OPJ_UINT32 )0;
        {
#line 8911
        while (1) {
          while_continue___0: /* CIL Label */ ;

#line 8911
          if (! (it_tile_free < it_tile)) {
#line 8911
            goto while_break___0;
          }
          {
#line 8912
          free((void *)(l_cstr_index->tile_index + it_tile_free)->marker);
#line 8911
          it_tile_free ++;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
        while_break___0: 
        {
#line 8915
        free((void *)l_cstr_index->tile_index);
#line 8916
        free((void *)l_cstr_index->marker);
#line 8917
        free((void *)l_cstr_index);
        }
#line 8918
        return ((opj_codestream_index_t *)((void *)0));
      }
#line 8921
      if (((p_j2k->cstr_index)->tile_index + it_tile)->marker) {
        {
#line 8922
        memcpy((void *)(l_cstr_index->tile_index + it_tile)->marker, (void const   *)((p_j2k->cstr_index)->tile_index + it_tile)->marker,
               (unsigned long )(l_cstr_index->tile_index + it_tile)->marknum * sizeof(opj_marker_info_t ));
        }
      } else {
        {
#line 8926
        free((void *)(l_cstr_index->tile_index + it_tile)->marker);
#line 8927
        (l_cstr_index->tile_index + it_tile)->marker = (opj_marker_info_t *)((void *)0);
        }
      }
      {
#line 8931
      (l_cstr_index->tile_index + it_tile)->nb_tps = ((p_j2k->cstr_index)->tile_index + it_tile)->nb_tps;
#line 8933
      __cil_tmp10 = malloc((unsigned long )(l_cstr_index->tile_index + it_tile)->nb_tps * sizeof(opj_tp_index_t ));
#line 8933
      (l_cstr_index->tile_index + it_tile)->tp_index = (opj_tp_index_t *)__cil_tmp10;
      }
#line 8936
      if (! (l_cstr_index->tile_index + it_tile)->tp_index) {
#line 8939
        it_tile_free___0 = (OPJ_UINT32 )0;
        {
#line 8939
        while (1) {
          while_continue___1: /* CIL Label */ ;

#line 8939
          if (! (it_tile_free___0 < it_tile)) {
#line 8939
            goto while_break___1;
          }
          {
#line 8940
          free((void *)(l_cstr_index->tile_index + it_tile_free___0)->marker);
#line 8941
          free((void *)(l_cstr_index->tile_index + it_tile_free___0)->tp_index);
#line 8939
          it_tile_free___0 ++;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
        while_break___1: 
        {
#line 8944
        free((void *)l_cstr_index->tile_index);
#line 8945
        free((void *)l_cstr_index->marker);
#line 8946
        free((void *)l_cstr_index);
        }
#line 8947
        return ((opj_codestream_index_t *)((void *)0));
      }
#line 8950
      if (((p_j2k->cstr_index)->tile_index + it_tile)->tp_index) {
        {
#line 8951
        memcpy((void *)(l_cstr_index->tile_index + it_tile)->tp_index, (void const   *)((p_j2k->cstr_index)->tile_index + it_tile)->tp_index,
               (unsigned long )(l_cstr_index->tile_index + it_tile)->nb_tps * sizeof(opj_tp_index_t ));
        }
      } else {
        {
#line 8956
        free((void *)(l_cstr_index->tile_index + it_tile)->tp_index);
#line 8957
        (l_cstr_index->tile_index + it_tile)->tp_index = (opj_tp_index_t *)((void *)0);
        }
      }
#line 8961
      (l_cstr_index->tile_index + it_tile)->nb_packet = (OPJ_UINT32 )0;
#line 8962
      (l_cstr_index->tile_index + it_tile)->packet_index = (opj_packet_info_t *)((void *)0);
#line 8900
      it_tile ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 8967
  return (l_cstr_index);
}
}
#line 8970 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_allocate_tile_element_cstr_index(opj_j2k_t *p_j2k ) 
{ 
  OPJ_UINT32 it_tile ;
  void *__cil_tmp3 ;
  void *__cil_tmp4 ;

  {
  {
#line 8972
  it_tile = (OPJ_UINT32 )0;
#line 8974
  (p_j2k->cstr_index)->nb_of_tiles = p_j2k->m_cp.tw * p_j2k->m_cp.th;
#line 8975
  __cil_tmp3 = calloc((unsigned long )(p_j2k->cstr_index)->nb_of_tiles, sizeof(opj_tile_index_t ));
#line 8975
  (p_j2k->cstr_index)->tile_index = (opj_tile_index_t *)__cil_tmp3;
  }
#line 8976
  if (! (p_j2k->cstr_index)->tile_index) {
#line 8977
    return (0);
  }
#line 8979
  it_tile = (OPJ_UINT32 )0;
  {
#line 8979
  while (1) {
    while_continue: /* CIL Label */ ;

#line 8979
    if (! (it_tile < (p_j2k->cstr_index)->nb_of_tiles)) {
#line 8979
      goto while_break;
    }
    {
#line 8980
    ((p_j2k->cstr_index)->tile_index + it_tile)->maxmarknum = (OPJ_UINT32 )100;
#line 8981
    ((p_j2k->cstr_index)->tile_index + it_tile)->marknum = (OPJ_UINT32 )0;
#line 8982
    __cil_tmp4 = calloc((unsigned long )((p_j2k->cstr_index)->tile_index + it_tile)->maxmarknum,
                        sizeof(opj_marker_info_t ));
#line 8982
    ((p_j2k->cstr_index)->tile_index + it_tile)->marker = (opj_marker_info_t *)__cil_tmp4;
    }
#line 8984
    if (! ((p_j2k->cstr_index)->tile_index + it_tile)->marker) {
#line 8985
      return (0);
    }
#line 8979
    it_tile ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 8988
  return (1);
}
}
#line 8991 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_decode_tiles(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                              opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL l_go_on ;
  OPJ_UINT32 l_current_tile_no ;
  OPJ_UINT32 l_data_size ;
  OPJ_UINT32 l_max_data_size ;
  OPJ_INT32 l_tile_x0 ;
  OPJ_INT32 l_tile_y0 ;
  OPJ_INT32 l_tile_x1 ;
  OPJ_INT32 l_tile_y1 ;
  OPJ_UINT32 l_nb_comps ;
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 nr_tiles ;
  void *__cil_tmp15 ;
  OPJ_BOOL __cil_tmp16 ;
  OPJ_BYTE *l_new_current_data ;
  void *__cil_tmp18 ;
  OPJ_BOOL __cil_tmp19 ;
  OPJ_BOOL __cil_tmp20 ;
  OPJ_OFF_T __cil_tmp21 ;

  {
  {
#line 8995
  l_go_on = 1;
#line 9001
  nr_tiles = (OPJ_UINT32 )0;
#line 9003
  __cil_tmp15 = malloc(1000UL);
#line 9003
  l_current_data = (OPJ_BYTE *)__cil_tmp15;
  }
#line 9004
  if (! l_current_data) {
    {
#line 9005
    opj_event_msg(p_manager, 1, "Not enough memory to decode tiles\n");
    }
#line 9006
    return (0);
  }
#line 9008
  l_max_data_size = (OPJ_UINT32 )1000;
  {
#line 9010
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 9011
    __cil_tmp16 = opj_j2k_read_tile_header(p_j2k, & l_current_tile_no, & l_data_size,
                                           & l_tile_x0, & l_tile_y0, & l_tile_x1,
                                           & l_tile_y1, & l_nb_comps, & l_go_on, p_stream,
                                           p_manager);
    }
#line 9011
    if (! __cil_tmp16) {
      {
#line 9020
      free((void *)l_current_data);
      }
#line 9021
      return (0);
    }
#line 9024
    if (! l_go_on) {
#line 9025
      goto while_break;
    }
#line 9028
    if (l_data_size > l_max_data_size) {
      {
#line 9029
      __cil_tmp18 = realloc((void *)l_current_data, (unsigned long )l_data_size);
#line 9029
      l_new_current_data = (OPJ_BYTE *)__cil_tmp18;
      }
#line 9030
      if (! l_new_current_data) {
        {
#line 9031
        free((void *)l_current_data);
#line 9032
        opj_event_msg(p_manager, 1, "Not enough memory to decode tile %d/%d\n", l_current_tile_no + 1U,
                      p_j2k->m_cp.th * p_j2k->m_cp.tw);
        }
#line 9033
        return (0);
      }
#line 9035
      l_current_data = l_new_current_data;
#line 9036
      l_max_data_size = l_data_size;
    }
    {
#line 9039
    __cil_tmp19 = opj_j2k_decode_tile(p_j2k, l_current_tile_no, l_current_data, l_data_size,
                                      p_stream, p_manager);
    }
#line 9039
    if (! __cil_tmp19) {
      {
#line 9040
      free((void *)l_current_data);
      }
#line 9041
      return (0);
    }
    {
#line 9043
    opj_event_msg(p_manager, 4, "Tile %d/%d has been decoded.\n", l_current_tile_no + 1U,
                  p_j2k->m_cp.th * p_j2k->m_cp.tw);
#line 9045
    __cil_tmp20 = opj_j2k_update_image_data(p_j2k->m_tcd, l_current_data, p_j2k->m_output_image);
    }
#line 9045
    if (! __cil_tmp20) {
      {
#line 9046
      free((void *)l_current_data);
      }
#line 9047
      return (0);
    }
    {
#line 9049
    opj_event_msg(p_manager, 4, "Image data has been updated with tile %d.\n\n", l_current_tile_no + 1U);
#line 9051
    __cil_tmp21 = opj_stream_get_number_byte_left(p_stream);
    }
#line 9051
    if (__cil_tmp21 == 0L) {
#line 9051
      if (p_j2k->m_specific_param.m_decoder.m_state == 64U) {
#line 9053
        goto while_break;
      }
    }
#line 9054
    nr_tiles ++;
#line 9054
    if (nr_tiles == p_j2k->m_cp.th * p_j2k->m_cp.tw) {
#line 9055
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 9058
  free((void *)l_current_data);
  }
#line 9060
  return (1);
}
}
#line 9066 "/root/patron/new_22/src/lib/openjp2/j2k.c"
static void opj_j2k_setup_decoding(opj_j2k_t *p_j2k ) 
{ 


  {
  {
#line 9071
  opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_decode_tiles));
  }
#line 9073
  return;
}
}
#line 9079 "/root/patron/new_22/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_decode_one_tile(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                        opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL l_go_on ;
  OPJ_UINT32 l_current_tile_no ;
  OPJ_UINT32 l_tile_no_to_dec ;
  OPJ_UINT32 l_data_size ;
  OPJ_UINT32 l_max_data_size ;
  OPJ_INT32 l_tile_x0 ;
  OPJ_INT32 l_tile_y0 ;
  OPJ_INT32 l_tile_x1 ;
  OPJ_INT32 l_tile_y1 ;
  OPJ_UINT32 l_nb_comps ;
  OPJ_BYTE *l_current_data ;
  void *__cil_tmp15 ;
  OPJ_BOOL __cil_tmp16 ;
  OPJ_BOOL __cil_tmp17 ;
  OPJ_BOOL __cil_tmp18 ;
  OPJ_BOOL __cil_tmp19 ;
  OPJ_BYTE *l_new_current_data ;
  void *__cil_tmp21 ;
  OPJ_BOOL __cil_tmp22 ;
  OPJ_BOOL __cil_tmp23 ;
  OPJ_BOOL __cil_tmp24 ;

  {
  {
#line 9083
  l_go_on = 1;
#line 9091
  __cil_tmp15 = malloc(1000UL);
#line 9091
  l_current_data = (OPJ_BYTE *)__cil_tmp15;
  }
#line 9092
  if (! l_current_data) {
    {
#line 9093
    opj_event_msg(p_manager, 1, "Not enough memory to decode one tile\n");
    }
#line 9094
    return (0);
  }
#line 9096
  l_max_data_size = (OPJ_UINT32 )1000;
#line 9099
  if (! (p_j2k->cstr_index)->tile_index) {
    {
#line 9101
    __cil_tmp16 = opj_j2k_allocate_tile_element_cstr_index(p_j2k);
    }
#line 9101
    if (! __cil_tmp16) {
      {
#line 9102
      free((void *)l_current_data);
      }
#line 9103
      return (0);
    }
  }
#line 9107
  l_tile_no_to_dec = (OPJ_UINT32 )p_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec;
#line 9108
  if ((p_j2k->cstr_index)->tile_index) {
#line 9109
    if (((p_j2k->cstr_index)->tile_index)->tp_index) {
#line 9111
      if (! ((p_j2k->cstr_index)->tile_index + l_tile_no_to_dec)->nb_tps) {
        {
#line 9114
        __cil_tmp17 = opj_stream_read_seek(p_stream, p_j2k->m_specific_param.m_decoder.m_last_sot_read_pos + 2L,
                                           p_manager);
        }
#line 9114
        if (! __cil_tmp17) {
          {
#line 9115
          opj_event_msg(p_manager, 1, "Problem with seek function\n\211\202U");
          }
#line 9116
          return (0);
        }
      } else {
        {
#line 9120
        __cil_tmp18 = opj_stream_read_seek(p_stream, (((p_j2k->cstr_index)->tile_index + l_tile_no_to_dec)->tp_index + 0)->start_pos + 2L,
                                           p_manager);
        }
#line 9120
        if (! __cil_tmp18) {
          {
#line 9121
          opj_event_msg(p_manager, 1, "Problem with seek function\n");
          }
#line 9122
          return (0);
        }
      }
#line 9126
      if (p_j2k->m_specific_param.m_decoder.m_state == 256U) {
#line 9127
        p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )8;
      }
    }
  }
  {
#line 9130
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 9131
    __cil_tmp19 = opj_j2k_read_tile_header(p_j2k, & l_current_tile_no, & l_data_size,
                                           & l_tile_x0, & l_tile_y0, & l_tile_x1,
                                           & l_tile_y1, & l_nb_comps, & l_go_on, p_stream,
                                           p_manager);
    }
#line 9131
    if (! __cil_tmp19) {
      {
#line 9140
      free((void *)l_current_data);
      }
#line 9141
      return (0);
    }
#line 9144
    if (! l_go_on) {
#line 9145
      goto while_break;
    }
#line 9148
    if (l_data_size > l_max_data_size) {
      {
#line 9149
      __cil_tmp21 = realloc((void *)l_current_data, (unsigned long )l_data_size);
#line 9149
      l_new_current_data = (OPJ_BYTE *)__cil_tmp21;
      }
#line 9150
      if (! l_new_current_data) {
        {
#line 9151
        free((void *)l_current_data);
#line 9152
        l_current_data = (OPJ_BYTE *)((void *)0);
#line 9155
        opj_event_msg(p_manager, 1, "Not enough memory to decode tile %d/%d\n", l_current_tile_no,
                      p_j2k->m_cp.th * p_j2k->m_cp.tw - 1U);
        }
#line 9156
        return (0);
      }
#line 9158
      l_current_data = l_new_current_data;
#line 9159
      l_max_data_size = l_data_size;
    }
    {
#line 9162
    __cil_tmp22 = opj_j2k_decode_tile(p_j2k, l_current_tile_no, l_current_data, l_data_size,
                                      p_stream, p_manager);
    }
#line 9162
    if (! __cil_tmp22) {
      {
#line 9163
      free((void *)l_current_data);
      }
#line 9164
      return (0);
    }
    {
#line 9166
    opj_event_msg(p_manager, 4, "Tile %d/%d has been decoded.\n", l_current_tile_no,
                  p_j2k->m_cp.th * p_j2k->m_cp.tw - 1U);
#line 9168
    __cil_tmp23 = opj_j2k_update_image_data(p_j2k->m_tcd, l_current_data, p_j2k->m_output_image);
    }
#line 9168
    if (! __cil_tmp23) {
      {
#line 9169
      free((void *)l_current_data);
      }
#line 9170
      return (0);
    }
    {
#line 9172
    opj_event_msg(p_manager, 4, "Image data has been updated with tile %d.\n\n\211\202U",
                  l_current_tile_no);
    }
#line 9174
    if (l_current_tile_no == l_tile_no_to_dec) {
      {
#line 9177
      __cil_tmp24 = opj_stream_read_seek(p_stream, (p_j2k->cstr_index)->main_head_end + 2L,
                                         p_manager);
      }
#line 9177
      if (! __cil_tmp24) {
        {
#line 9178
        opj_event_msg(p_manager, 1, "Problem with seek function\n\211\202U");
        }
#line 9179
        return (0);
      }
#line 9181
      goto while_break;
    } else {
      {
#line 9184
      opj_event_msg(p_manager, 2, "Tile read, decode and updated is not the desired (%d vs %d).\n",
                    l_current_tile_no, l_tile_no_to_dec);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 9189
  free((void *)l_current_data);
  }
#line 9191
  return (1);
}
}
#line 9197 "/root/patron/new_22/src/lib/openjp2/j2k.c"
static void opj_j2k_setup_decoding_tile(opj_j2k_t *p_j2k ) 
{ 


  {
  {
#line 9202
  opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_decode_one_tile));
  }
#line 9204
  return;
}
}
#line 9207 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_decode(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_image_t *p_image ,
                        opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_BOOL __cil_tmp7 ;

  {
#line 9214
  if (! p_image) {
#line 9215
    return (0);
  }
  {
#line 9217
  p_j2k->m_output_image = opj_image_create0();
  }
#line 9218
  if (! p_j2k->m_output_image) {
#line 9219
    return (0);
  }
  {
#line 9221
  opj_copy_image_header(p_image, p_j2k->m_output_image);
#line 9224
  opj_j2k_setup_decoding(p_j2k);
#line 9227
  __cil_tmp7 = opj_j2k_exec(p_j2k, p_j2k->m_procedure_list, p_stream, p_manager);
  }
#line 9227
  if (! __cil_tmp7) {
    {
#line 9228
    opj_image_destroy(p_j2k->m_private_image);
#line 9229
    p_j2k->m_private_image = (opj_image_t *)((void *)0);
    }
#line 9230
    return (0);
  }
#line 9234
  compno = (OPJ_UINT32 )0;
  {
#line 9234
  while (1) {
    while_continue: /* CIL Label */ ;

#line 9234
    if (! (compno < p_image->numcomps)) {
#line 9234
      goto while_break;
    }
#line 9235
    (p_image->comps + compno)->resno_decoded = ((p_j2k->m_output_image)->comps + compno)->resno_decoded;
#line 9236
    (p_image->comps + compno)->data = ((p_j2k->m_output_image)->comps + compno)->data;
#line 9237
    ((p_j2k->m_output_image)->comps + compno)->data = (OPJ_INT32 *)((void *)0);
#line 9234
    compno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 9240
  return (1);
}
}
#line 9243 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_get_tile(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_image_t *p_image ,
                          opj_event_mgr_t *p_manager , OPJ_UINT32 tile_index ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_UINT32 l_tile_x ;
  OPJ_UINT32 l_tile_y ;
  opj_image_comp_t *l_img_comp ;
  OPJ_INT32 l_comp_x1 ;
  OPJ_INT32 l_comp_y1 ;
  OPJ_INT32 __cil_tmp12 ;
  OPJ_INT32 __cil_tmp13 ;
  OPJ_INT32 __cil_tmp16 ;
  OPJ_INT32 __cil_tmp17 ;
  OPJ_INT32 __cil_tmp18 ;
  OPJ_INT32 __cil_tmp19 ;
  OPJ_BOOL __cil_tmp22 ;

  {
#line 9253
  if (! p_image) {
    {
#line 9254
    opj_event_msg(p_manager, 1, "We need an image previously created.\n");
    }
#line 9255
    return (0);
  }
#line 9258
  if (tile_index >= p_j2k->m_cp.tw * p_j2k->m_cp.th) {
    {
#line 9259
    opj_event_msg(p_manager, 1, "Tile index provided by the user is incorrect %d (max = %d) \n",
                  tile_index, p_j2k->m_cp.tw * p_j2k->m_cp.th - 1U);
    }
#line 9260
    return (0);
  }
#line 9264
  l_tile_x = tile_index % p_j2k->m_cp.tw;
#line 9265
  l_tile_y = tile_index / p_j2k->m_cp.tw;
#line 9267
  p_image->x0 = l_tile_x * p_j2k->m_cp.tdx + p_j2k->m_cp.tx0;
#line 9268
  if (p_image->x0 < (p_j2k->m_private_image)->x0) {
#line 9269
    p_image->x0 = (p_j2k->m_private_image)->x0;
  }
#line 9270
  p_image->x1 = (l_tile_x + 1U) * p_j2k->m_cp.tdx + p_j2k->m_cp.tx0;
#line 9271
  if (p_image->x1 > (p_j2k->m_private_image)->x1) {
#line 9272
    p_image->x1 = (p_j2k->m_private_image)->x1;
  }
#line 9274
  p_image->y0 = l_tile_y * p_j2k->m_cp.tdy + p_j2k->m_cp.ty0;
#line 9275
  if (p_image->y0 < (p_j2k->m_private_image)->y0) {
#line 9276
    p_image->y0 = (p_j2k->m_private_image)->y0;
  }
#line 9277
  p_image->y1 = (l_tile_y + 1U) * p_j2k->m_cp.tdy + p_j2k->m_cp.ty0;
#line 9278
  if (p_image->y1 > (p_j2k->m_private_image)->y1) {
#line 9279
    p_image->y1 = (p_j2k->m_private_image)->y1;
  }
#line 9281
  l_img_comp = p_image->comps;
#line 9282
  compno = (OPJ_UINT32 )0;
  {
#line 9282
  while (1) {
    while_continue: /* CIL Label */ ;

#line 9282
    if (! (compno < p_image->numcomps)) {
#line 9282
      goto while_break;
    }
    {
#line 9286
    l_img_comp->factor = ((p_j2k->m_private_image)->comps + compno)->factor;
#line 9288
    __cil_tmp12 = opj_int_ceildiv((OPJ_INT32 )p_image->x0, (OPJ_INT32 )l_img_comp->dx);
#line 9288
    l_img_comp->x0 = (OPJ_UINT32 )__cil_tmp12;
#line 9289
    __cil_tmp13 = opj_int_ceildiv((OPJ_INT32 )p_image->y0, (OPJ_INT32 )l_img_comp->dy);
#line 9289
    l_img_comp->y0 = (OPJ_UINT32 )__cil_tmp13;
#line 9290
    l_comp_x1 = opj_int_ceildiv((OPJ_INT32 )p_image->x1, (OPJ_INT32 )l_img_comp->dx);
#line 9291
    l_comp_y1 = opj_int_ceildiv((OPJ_INT32 )p_image->y1, (OPJ_INT32 )l_img_comp->dy);
#line 9293
    __cil_tmp17 = opj_int_ceildivpow2((OPJ_INT32 )l_img_comp->x0, (OPJ_INT32 )l_img_comp->factor);
#line 9293
    __cil_tmp16 = opj_int_ceildivpow2(l_comp_x1, (OPJ_INT32 )l_img_comp->factor);
#line 9293
    l_img_comp->w = (OPJ_UINT32 )(__cil_tmp16 - __cil_tmp17);
#line 9294
    __cil_tmp19 = opj_int_ceildivpow2((OPJ_INT32 )l_img_comp->y0, (OPJ_INT32 )l_img_comp->factor);
#line 9294
    __cil_tmp18 = opj_int_ceildivpow2(l_comp_y1, (OPJ_INT32 )l_img_comp->factor);
#line 9294
    l_img_comp->h = (OPJ_UINT32 )(__cil_tmp18 - __cil_tmp19);
#line 9296
    l_img_comp ++;
#line 9282
    compno ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 9300
  if (p_j2k->m_output_image) {
    {
#line 9301
    opj_image_destroy(p_j2k->m_output_image);
    }
  }
  {
#line 9304
  p_j2k->m_output_image = opj_image_create0();
  }
#line 9305
  if (! p_j2k->m_output_image) {
#line 9306
    return (0);
  }
  {
#line 9308
  opj_copy_image_header(p_image, p_j2k->m_output_image);
#line 9310
  p_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec = (OPJ_INT32 )tile_index;
#line 9313
  opj_j2k_setup_decoding_tile(p_j2k);
#line 9316
  __cil_tmp22 = opj_j2k_exec(p_j2k, p_j2k->m_procedure_list, p_stream, p_manager);
  }
#line 9316
  if (! __cil_tmp22) {
    {
#line 9317
    opj_image_destroy(p_j2k->m_private_image);
#line 9318
    p_j2k->m_private_image = (opj_image_t *)((void *)0);
    }
#line 9319
    return (0);
  }
#line 9323
  compno = (OPJ_UINT32 )0;
  {
#line 9323
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 9323
    if (! (compno < p_image->numcomps)) {
#line 9323
      goto while_break___0;
    }
#line 9324
    (p_image->comps + compno)->resno_decoded = ((p_j2k->m_output_image)->comps + compno)->resno_decoded;
#line 9326
    if ((p_image->comps + compno)->data) {
      {
#line 9327
      free((void *)(p_image->comps + compno)->data);
      }
    }
#line 9329
    (p_image->comps + compno)->data = ((p_j2k->m_output_image)->comps + compno)->data;
#line 9331
    ((p_j2k->m_output_image)->comps + compno)->data = (OPJ_INT32 *)((void *)0);
#line 9323
    compno ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 9334
  return (1);
}
}
#line 9337 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_set_decoded_resolution_factor(opj_j2k_t *p_j2k , OPJ_UINT32 res_factor ,
                                               opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 it_comp ;
  OPJ_UINT32 max_res ;

  {
#line 9343
  p_j2k->m_cp.m_specific_param.m_dec.m_reduce = res_factor;
#line 9345
  if (p_j2k->m_private_image) {
#line 9346
    if ((p_j2k->m_private_image)->comps) {
#line 9347
      if (p_j2k->m_specific_param.m_decoder.m_default_tcp) {
#line 9348
        if ((p_j2k->m_specific_param.m_decoder.m_default_tcp)->tccps) {
#line 9349
          it_comp = (OPJ_UINT32 )0;
          {
#line 9349
          while (1) {
            while_continue: /* CIL Label */ ;

#line 9349
            if (! (it_comp < (p_j2k->m_private_image)->numcomps)) {
#line 9349
              goto while_break;
            }
#line 9350
            max_res = ((p_j2k->m_specific_param.m_decoder.m_default_tcp)->tccps + it_comp)->numresolutions;
#line 9351
            if (res_factor >= max_res) {
              {
#line 9352
              opj_event_msg(p_manager, 1, "Resolution factor is greater than the maximum resolution in the component.\n");
              }
#line 9353
              return (0);
            }
#line 9355
            ((p_j2k->m_private_image)->comps + it_comp)->factor = res_factor;
#line 9349
            it_comp ++;
          }
          while_break___0: /* CIL Label */ ;
          }
          while_break: ;
#line 9357
          return (1);
        }
      }
    }
  }
#line 9363
  return (0);
}
}
#line 9366 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_encode(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_nb_tiles ;
  OPJ_UINT32 l_max_tile_size ;
  OPJ_UINT32 l_current_tile_size ;
  OPJ_BYTE *l_current_data ;
  void *__cil_tmp12 ;
  OPJ_BOOL __cil_tmp13 ;
  OPJ_BYTE *l_new_current_data ;
  void *__cil_tmp16 ;
  OPJ_BOOL __cil_tmp17 ;

  {
  {
#line 9380
  __cil_tmp12 = malloc(1000UL);
#line 9380
  l_current_data = (OPJ_BYTE *)__cil_tmp12;
  }
#line 9381
  if (! l_current_data) {
    {
#line 9382
    opj_event_msg(p_manager, 1, "Not enough memory to encode all tiles\n");
    }
#line 9383
    return (0);
  }
#line 9385
  l_max_tile_size = (OPJ_UINT32 )1000;
#line 9387
  l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;
#line 9388
  i = (OPJ_UINT32 )0;
  {
#line 9388
  while (1) {
    while_continue: /* CIL Label */ ;

#line 9388
    if (! (i < l_nb_tiles)) {
#line 9388
      goto while_break;
    }
    {
#line 9389
    __cil_tmp13 = opj_j2k_pre_write_tile(p_j2k, i, p_stream, p_manager);
    }
#line 9389
    if (! __cil_tmp13) {
      {
#line 9390
      free((void *)l_current_data);
      }
#line 9391
      return (0);
    }
    {
#line 9394
    l_current_tile_size = opj_tcd_get_encoded_tile_size(p_j2k->m_tcd);
    }
#line 9395
    if (l_current_tile_size > l_max_tile_size) {
      {
#line 9396
      __cil_tmp16 = realloc((void *)l_current_data, (unsigned long )l_current_tile_size);
#line 9396
      l_new_current_data = (OPJ_BYTE *)__cil_tmp16;
      }
#line 9397
      if (! l_new_current_data) {
        {
#line 9398
        free((void *)l_current_data);
#line 9399
        opj_event_msg(p_manager, 1, "Not enough memory to encode all tiles\n");
        }
#line 9400
        return (0);
      }
#line 9402
      l_current_data = l_new_current_data;
#line 9403
      l_max_tile_size = l_current_tile_size;
    }
    {
#line 9406
    opj_j2k_get_tile_data(p_j2k->m_tcd, l_current_data);
#line 9408
    __cil_tmp17 = opj_j2k_post_write_tile(p_j2k, l_current_data, l_current_tile_size,
                                          p_stream, p_manager);
    }
#line 9408
    if (! __cil_tmp17) {
#line 9409
      return (0);
    }
#line 9388
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 9413
  free((void *)l_current_data);
  }
#line 9414
  return (1);
}
}
#line 9417 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_end_compress(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                              opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp4 ;

  {
  {
#line 9422
  opj_j2k_setup_end_compress(p_j2k);
#line 9424
  __cil_tmp4 = opj_j2k_exec(p_j2k, p_j2k->m_procedure_list, p_stream, p_manager);
  }
#line 9424
  if (! __cil_tmp4) {
#line 9426
    return (0);
  }
#line 9429
  return (1);
}
}
#line 9432 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_start_compress(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                opj_image_t *p_image , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 it_comp ;
  OPJ_BOOL __cil_tmp11 ;
  OPJ_BOOL __cil_tmp12 ;

  {
  {
#line 9442
  p_j2k->m_private_image = opj_image_create0();
#line 9443
  opj_copy_image_header(p_image, p_j2k->m_private_image);
  }
#line 9446
  if (p_image->comps) {
#line 9448
    it_comp = (OPJ_UINT32 )0;
    {
#line 9448
    while (1) {
      while_continue: /* CIL Label */ ;

#line 9448
      if (! (it_comp < p_image->numcomps)) {
#line 9448
        goto while_break;
      }
#line 9449
      if ((p_image->comps + it_comp)->data) {
#line 9450
        ((p_j2k->m_private_image)->comps + it_comp)->data = (p_image->comps + it_comp)->data;
#line 9451
        (p_image->comps + it_comp)->data = (OPJ_INT32 *)((void *)0);
      }
#line 9448
      it_comp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
  {
#line 9458
  opj_j2k_setup_encoding_validation(p_j2k);
#line 9461
  __cil_tmp11 = opj_j2k_exec(p_j2k, p_j2k->m_validation_list, p_stream, p_manager);
  }
#line 9461
  if (! __cil_tmp11) {
#line 9462
    return (0);
  }
  {
#line 9466
  opj_j2k_setup_header_writing(p_j2k);
#line 9469
  __cil_tmp12 = opj_j2k_exec(p_j2k, p_j2k->m_procedure_list, p_stream, p_manager);
  }
#line 9469
  if (! __cil_tmp12) {
#line 9470
    return (0);
  }
#line 9473
  return (1);
}
}
#line 9476 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_pre_write_tile(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_index , opj_stream_private_t *p_stream ,
                                opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp5 ;

  {
#line 9482
  if (p_tile_index != p_j2k->m_current_tile_number) {
    {
#line 9483
    opj_event_msg(p_manager, 1, "The given tile index does not match.");
    }
#line 9484
    return (0);
  }
  {
#line 9487
  opj_event_msg(p_manager, 4, "tile number %d / %d\n\202U", p_j2k->m_current_tile_number + 1U,
                p_j2k->m_cp.tw * p_j2k->m_cp.th);
#line 9489
  p_j2k->m_specific_param.m_encoder.m_current_tile_part_number = (OPJ_UINT32 )0;
#line 9490
  (p_j2k->m_tcd)->cur_totnum_tp = (p_j2k->m_cp.tcps + p_tile_index)->m_nb_tile_parts;
#line 9491
  p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number = (OPJ_UINT32 )0;
#line 9494
  __cil_tmp5 = opj_tcd_init_encode_tile(p_j2k->m_tcd, p_j2k->m_current_tile_number);
  }
#line 9494
  if (! __cil_tmp5) {
#line 9495
    return (0);
  }
#line 9498
  return (1);
}
}
#line 9501 "/root/patron/new_22/src/lib/openjp2/j2k.c"
void opj_j2k_get_tile_data(opj_tcd_t *p_tcd , OPJ_BYTE *p_data ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  OPJ_UINT32 l_width ;
  OPJ_UINT32 l_height ;
  OPJ_UINT32 l_stride ;
  OPJ_UINT32 l_offset_x ;
  OPJ_UINT32 l_offset_y ;
  OPJ_UINT32 l_image_width ;
  opj_image_comp_t *l_img_comp ;
  opj_tcd_tilecomp_t *l_tilec ;
  opj_image_t *l_image ;
  OPJ_UINT32 l_size_comp ;
  OPJ_UINT32 l_remaining ;
  OPJ_INT32 *l_src_ptr ;
  OPJ_INT32 __cil_tmp18 ;
  OPJ_INT32 __cil_tmp19 ;
  OPJ_INT32 __cil_tmp20 ;
  OPJ_CHAR *l_dest_ptr ;
  OPJ_INT16 *l_dest_ptr___0 ;
  OPJ_INT16 *__cil_tmp23 ;
  OPJ_INT32 *__cil_tmp24 ;
  OPJ_INT16 *__cil_tmp25 ;
  OPJ_INT32 *__cil_tmp26 ;
  OPJ_INT32 *l_dest_ptr___1 ;
  OPJ_INT32 *__cil_tmp28 ;
  OPJ_INT32 *__cil_tmp29 ;

  {
#line 9503
  k = (OPJ_UINT32 )0;
#line 9505
  l_img_comp = (opj_image_comp_t *)0;
#line 9506
  l_tilec = (opj_tcd_tilecomp_t *)0;
#line 9507
  l_image = (opj_image_t *)0;
#line 9510
  l_tilec = ((p_tcd->tcd_image)->tiles)->comps;
#line 9511
  l_image = p_tcd->image;
#line 9512
  l_img_comp = l_image->comps;
#line 9514
  i = (OPJ_UINT32 )0;
  {
#line 9514
  while (1) {
    while_continue: /* CIL Label */ ;

#line 9514
    if (! (i < (p_tcd->image)->numcomps)) {
#line 9514
      goto while_break;
    }
#line 9515
    l_size_comp = l_img_comp->prec >> 3;
#line 9516
    l_remaining = l_img_comp->prec & 7U;
#line 9517
    if (l_remaining) {
#line 9518
      l_size_comp ++;
    }
#line 9521
    if (l_size_comp == 3U) {
#line 9522
      l_size_comp = (OPJ_UINT32 )4;
    }
    {
#line 9525
    l_width = (OPJ_UINT32 )(l_tilec->x1 - l_tilec->x0);
#line 9526
    l_height = (OPJ_UINT32 )(l_tilec->y1 - l_tilec->y0);
#line 9527
    __cil_tmp18 = opj_int_ceildiv((OPJ_INT32 )l_image->x0, (OPJ_INT32 )l_img_comp->dx);
#line 9527
    l_offset_x = (OPJ_UINT32 )__cil_tmp18;
#line 9528
    __cil_tmp19 = opj_int_ceildiv((OPJ_INT32 )l_image->y0, (OPJ_INT32 )l_img_comp->dy);
#line 9528
    l_offset_y = (OPJ_UINT32 )__cil_tmp19;
#line 9529
    __cil_tmp20 = opj_int_ceildiv((OPJ_INT32 )(l_image->x1 - l_image->x0), (OPJ_INT32 )l_img_comp->dx);
#line 9529
    l_image_width = (OPJ_UINT32 )__cil_tmp20;
#line 9530
    l_stride = l_image_width - l_width;
#line 9531
    l_src_ptr = (l_img_comp->data + ((unsigned int )l_tilec->x0 - l_offset_x)) + ((unsigned int )l_tilec->y0 - l_offset_y) * l_image_width;
    }
#line 9534
    if (l_size_comp == 1U) {
#line 9534
      goto case_1;
    }
#line 9561
    if (l_size_comp == 2U) {
#line 9561
      goto case_2;
    }
#line 9584
    if (l_size_comp == 4U) {
#line 9584
      goto case_4;
    }
#line 9533
    goto switch_break;
    case_1: 
#line 9536
    l_dest_ptr = (OPJ_CHAR *)p_data;
#line 9537
    if (l_img_comp->sgnd) {
#line 9538
      j = (OPJ_UINT32 )0;
      {
#line 9538
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 9538
        if (! (j < l_height)) {
#line 9538
          goto while_break___0;
        }
#line 9539
        k = (OPJ_UINT32 )0;
        {
#line 9539
        while (1) {
          while_continue___1: /* CIL Label */ ;

#line 9539
          if (! (k < l_width)) {
#line 9539
            goto while_break___1;
          }
#line 9540
          *l_dest_ptr = (OPJ_CHAR )*l_src_ptr;
#line 9541
          l_dest_ptr ++;
#line 9542
          l_src_ptr ++;
#line 9539
          k ++;
        }
        while_break___12: /* CIL Label */ ;
        }
        while_break___1: 
#line 9544
        l_src_ptr += l_stride;
#line 9538
        j ++;
      }
      while_break___11: /* CIL Label */ ;
      }
      while_break___0: ;
    } else {
#line 9548
      j = (OPJ_UINT32 )0;
      {
#line 9548
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 9548
        if (! (j < l_height)) {
#line 9548
          goto while_break___2;
        }
#line 9549
        k = (OPJ_UINT32 )0;
        {
#line 9549
        while (1) {
          while_continue___3: /* CIL Label */ ;

#line 9549
          if (! (k < l_width)) {
#line 9549
            goto while_break___3;
          }
#line 9550
          *l_dest_ptr = (OPJ_CHAR )(*l_src_ptr & 255);
#line 9551
          l_dest_ptr ++;
#line 9552
          l_src_ptr ++;
#line 9549
          k ++;
        }
        while_break___14: /* CIL Label */ ;
        }
        while_break___3: 
#line 9554
        l_src_ptr += l_stride;
#line 9548
        j ++;
      }
      while_break___13: /* CIL Label */ ;
      }
      while_break___2: ;
    }
#line 9558
    p_data = (OPJ_BYTE *)l_dest_ptr;
#line 9560
    goto switch_break;
    case_2: 
#line 9563
    l_dest_ptr___0 = (OPJ_INT16 *)p_data;
#line 9564
    if (l_img_comp->sgnd) {
#line 9565
      j = (OPJ_UINT32 )0;
      {
#line 9565
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 9565
        if (! (j < l_height)) {
#line 9565
          goto while_break___4;
        }
#line 9566
        k = (OPJ_UINT32 )0;
        {
#line 9566
        while (1) {
          while_continue___5: /* CIL Label */ ;

#line 9566
          if (! (k < l_width)) {
#line 9566
            goto while_break___5;
          }
#line 9567
          __cil_tmp24 = l_src_ptr;
#line 9567
          l_src_ptr ++;
#line 9567
          __cil_tmp23 = l_dest_ptr___0;
#line 9567
          l_dest_ptr___0 ++;
#line 9567
          *__cil_tmp23 = (OPJ_INT16 )*__cil_tmp24;
#line 9566
          k ++;
        }
        while_break___16: /* CIL Label */ ;
        }
        while_break___5: 
#line 9569
        l_src_ptr += l_stride;
#line 9565
        j ++;
      }
      while_break___15: /* CIL Label */ ;
      }
      while_break___4: ;
    } else {
#line 9573
      j = (OPJ_UINT32 )0;
      {
#line 9573
      while (1) {
        while_continue___6: /* CIL Label */ ;

#line 9573
        if (! (j < l_height)) {
#line 9573
          goto while_break___6;
        }
#line 9574
        k = (OPJ_UINT32 )0;
        {
#line 9574
        while (1) {
          while_continue___7: /* CIL Label */ ;

#line 9574
          if (! (k < l_width)) {
#line 9574
            goto while_break___7;
          }
#line 9575
          __cil_tmp26 = l_src_ptr;
#line 9575
          l_src_ptr ++;
#line 9575
          __cil_tmp25 = l_dest_ptr___0;
#line 9575
          l_dest_ptr___0 ++;
#line 9575
          *__cil_tmp25 = (OPJ_INT16 )(*__cil_tmp26 & 65535);
#line 9574
          k ++;
        }
        while_break___18: /* CIL Label */ ;
        }
        while_break___7: 
#line 9577
        l_src_ptr += l_stride;
#line 9573
        j ++;
      }
      while_break___17: /* CIL Label */ ;
      }
      while_break___6: ;
    }
#line 9581
    p_data = (OPJ_BYTE *)l_dest_ptr___0;
#line 9583
    goto switch_break;
    case_4: 
#line 9586
    l_dest_ptr___1 = (OPJ_INT32 *)p_data;
#line 9587
    j = (OPJ_UINT32 )0;
    {
#line 9587
    while (1) {
      while_continue___8: /* CIL Label */ ;

#line 9587
      if (! (j < l_height)) {
#line 9587
        goto while_break___8;
      }
#line 9588
      k = (OPJ_UINT32 )0;
      {
#line 9588
      while (1) {
        while_continue___9: /* CIL Label */ ;

#line 9588
        if (! (k < l_width)) {
#line 9588
          goto while_break___9;
        }
#line 9589
        __cil_tmp29 = l_src_ptr;
#line 9589
        l_src_ptr ++;
#line 9589
        __cil_tmp28 = l_dest_ptr___1;
#line 9589
        l_dest_ptr___1 ++;
#line 9589
        *__cil_tmp28 = *__cil_tmp29;
#line 9588
        k ++;
      }
      while_break___20: /* CIL Label */ ;
      }
      while_break___9: 
#line 9591
      l_src_ptr += l_stride;
#line 9587
      j ++;
    }
    while_break___19: /* CIL Label */ ;
    }
    while_break___8: 
#line 9594
    p_data = (OPJ_BYTE *)l_dest_ptr___1;
#line 9596
    goto switch_break;
    switch_break: 
#line 9599
    l_img_comp ++;
#line 9600
    l_tilec ++;
#line 9514
    i ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break: ;
#line 9518
  return;
}
}
#line 9604 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_post_write_tile(opj_j2k_t *p_j2k , OPJ_BYTE *p_data , OPJ_UINT32 p_data_size ,
                                 opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) 
{ 
  opj_tcd_t *l_tcd ;
  OPJ_UINT32 l_nb_bytes_written ;
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 l_tile_size ;
  OPJ_UINT32 l_available_data ;
  OPJ_BOOL __cil_tmp12 ;
  OPJ_BOOL __cil_tmp13 ;
  OPJ_BOOL __cil_tmp14 ;
  OPJ_SIZE_T __cil_tmp15 ;

  {
  {
#line 9610
  l_tcd = (opj_tcd_t *)0;
#line 9612
  l_current_data = (OPJ_BYTE *)0;
#line 9613
  l_tile_size = (OPJ_UINT32 )0;
#line 9619
  l_tcd = p_j2k->m_tcd;
#line 9621
  l_tile_size = p_j2k->m_specific_param.m_encoder.m_encoded_tile_size;
#line 9622
  l_available_data = l_tile_size;
#line 9623
  l_current_data = p_j2k->m_specific_param.m_encoder.m_encoded_tile_data;
#line 9625
  __cil_tmp12 = opj_tcd_copy_tile_data(l_tcd, p_data, p_data_size);
  }
#line 9625
  if (! __cil_tmp12) {
    {
#line 9626
    opj_event_msg(p_manager, 1, "Size mismatch between tile data and sent data.");
    }
#line 9627
    return (0);
  }
  {
#line 9630
  l_nb_bytes_written = (OPJ_UINT32 )0;
#line 9631
  __cil_tmp13 = opj_j2k_write_first_tile_part(p_j2k, l_current_data, & l_nb_bytes_written,
                                              l_available_data, p_stream, p_manager);
  }
#line 9631
  if (! __cil_tmp13) {
#line 9632
    return (0);
  }
  {
#line 9634
  l_current_data += l_nb_bytes_written;
#line 9635
  l_available_data -= l_nb_bytes_written;
#line 9637
  l_nb_bytes_written = (OPJ_UINT32 )0;
#line 9638
  __cil_tmp14 = opj_j2k_write_all_tile_parts(p_j2k, l_current_data, & l_nb_bytes_written,
                                             l_available_data, p_stream, p_manager);
  }
#line 9638
  if (! __cil_tmp14) {
#line 9639
    return (0);
  }
  {
#line 9642
  l_available_data -= l_nb_bytes_written;
#line 9643
  l_nb_bytes_written = l_tile_size - l_available_data;
#line 9645
  __cil_tmp15 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_encoded_tile_data,
                                      (OPJ_SIZE_T )l_nb_bytes_written, p_manager);
  }
#line 9645
  if (__cil_tmp15 != (unsigned long )l_nb_bytes_written) {
#line 9648
    return (0);
  }
#line 9651
  (p_j2k->m_current_tile_number) ++;
#line 9653
  return (1);
}
}
#line 9656 "/root/patron/new_22/src/lib/openjp2/j2k.c"
void opj_j2k_setup_end_compress(opj_j2k_t *p_j2k ) 
{ 


  {
  {
#line 9662
  opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_write_eoc));
  }
#line 9664
  if (p_j2k->m_cp.m_specific_param.m_enc.m_cinema) {
    {
#line 9665
    opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_write_updated_tlm));
    }
  }
  {
#line 9668
  opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_write_epc));
#line 9669
  opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_end_encoding));
#line 9670
  opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_destroy_header_memory));
  }
#line 9672
  return;
}
}
#line 9673 "/root/patron/new_22/src/lib/openjp2/j2k.c"
void opj_j2k_setup_encoding_validation(opj_j2k_t *p_j2k ) 
{ 


  {
  {
#line 9678
  opj_procedure_list_add_procedure(p_j2k->m_validation_list, (void (*)(void))(& opj_j2k_build_encoder));
#line 9679
  opj_procedure_list_add_procedure(p_j2k->m_validation_list, (void (*)(void))(& opj_j2k_encoding_validation));
#line 9682
  opj_procedure_list_add_procedure(p_j2k->m_validation_list, (void (*)(void))(& opj_j2k_mct_validation));
  }
#line 9684
  return;
}
}
#line 9685 "/root/patron/new_22/src/lib/openjp2/j2k.c"
void opj_j2k_setup_header_writing(opj_j2k_t *p_j2k ) 
{ 


  {
  {
#line 9690
  opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_init_info));
#line 9691
  opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_write_soc));
#line 9692
  opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_write_siz));
#line 9693
  opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_write_cod));
#line 9694
  opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_write_qcd));
  }
#line 9696
  if (p_j2k->m_cp.m_specific_param.m_enc.m_cinema) {
    {
#line 9701
    opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_write_tlm));
    }
#line 9703
    if ((unsigned int )p_j2k->m_cp.m_specific_param.m_enc.m_cinema == 3U) {
      {
#line 9704
      opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_write_poc));
      }
    }
  }
  {
#line 9708
  opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_write_regions));
  }
#line 9710
  if ((unsigned long )p_j2k->m_cp.comment != (unsigned long )((OPJ_CHAR *)0)) {
    {
#line 9711
    opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_write_com));
    }
  }
#line 9715
  if ((unsigned int )p_j2k->m_cp.rsiz & 33024U) {
    {
#line 9716
    opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_write_mct_data_group));
    }
  }
#line 9720
  if (p_j2k->cstr_index) {
    {
#line 9721
    opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_get_end_header));
    }
  }
  {
#line 9724
  opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_create_tcd));
#line 9725
  opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (void (*)(void))(& opj_j2k_update_rates));
  }
#line 9727
  return;
}
}
#line 9728 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_first_tile_part(opj_j2k_t *p_j2k , OPJ_BYTE *p_data , OPJ_UINT32 *p_data_written ,
                                       OPJ_UINT32 p_total_data_size , opj_stream_private_t *p_stream ,
                                       struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 l_nb_bytes_written ;
  OPJ_UINT32 l_current_nb_bytes_written ;
  OPJ_BYTE *l_begin_data ;
  opj_tcd_t *l_tcd ;
  opj_cp_t *l_cp ;
  OPJ_BOOL __cil_tmp12 ;
  OPJ_BOOL __cil_tmp13 ;

  {
  {
#line 9736
  l_nb_bytes_written = (OPJ_UINT32 )0;
#line 9738
  l_begin_data = (OPJ_BYTE *)0;
#line 9740
  l_tcd = (opj_tcd_t *)0;
#line 9741
  l_cp = (opj_cp_t *)0;
#line 9743
  l_tcd = p_j2k->m_tcd;
#line 9744
  l_cp = & p_j2k->m_cp;
#line 9746
  l_tcd->cur_pino = (OPJ_UINT32 )0;
#line 9749
  p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number = (OPJ_UINT32 )0;
#line 9754
  l_current_nb_bytes_written = (OPJ_UINT32 )0;
#line 9755
  l_begin_data = p_data;
#line 9756
  __cil_tmp12 = opj_j2k_write_sot(p_j2k, p_data, & l_current_nb_bytes_written, p_stream,
                                  p_manager);
  }
#line 9756
  if (! __cil_tmp12) {
#line 9758
    return (0);
  }
#line 9761
  l_nb_bytes_written += l_current_nb_bytes_written;
#line 9762
  p_data += l_current_nb_bytes_written;
#line 9763
  p_total_data_size -= l_current_nb_bytes_written;
#line 9765
  if ((unsigned int )l_cp->m_specific_param.m_enc.m_cinema == 0U) {
#line 9780
    if ((l_cp->tcps + p_j2k->m_current_tile_number)->numpocs) {
      {
#line 9781
      l_current_nb_bytes_written = (OPJ_UINT32 )0;
#line 9782
      opj_j2k_write_poc_in_memory(p_j2k, p_data, & l_current_nb_bytes_written, p_manager);
#line 9783
      l_nb_bytes_written += l_current_nb_bytes_written;
#line 9784
      p_data += l_current_nb_bytes_written;
#line 9785
      p_total_data_size -= l_current_nb_bytes_written;
      }
    }
  }
  {
#line 9789
  l_current_nb_bytes_written = (OPJ_UINT32 )0;
#line 9790
  __cil_tmp13 = opj_j2k_write_sod(p_j2k, l_tcd, p_data, & l_current_nb_bytes_written,
                                  p_total_data_size, p_stream, p_manager);
  }
#line 9790
  if (! __cil_tmp13) {
#line 9791
    return (0);
  }
  {
#line 9794
  l_nb_bytes_written += l_current_nb_bytes_written;
#line 9795
  *p_data_written = l_nb_bytes_written;
#line 9798
  opj_write_bytes_LE(l_begin_data + 6, l_nb_bytes_written, (OPJ_UINT32 )4);
  }
#line 9800
  if (l_cp->m_specific_param.m_enc.m_cinema) {
    {
#line 9801
    opj_j2k_update_tlm(p_j2k, l_nb_bytes_written);
    }
  }
#line 9804
  return (1);
}
}
#line 9807 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_all_tile_parts(opj_j2k_t *p_j2k , OPJ_BYTE *p_data , OPJ_UINT32 *p_data_written ,
                                      OPJ_UINT32 p_total_data_size , opj_stream_private_t *p_stream ,
                                      struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 tilepartno ;
  OPJ_UINT32 l_nb_bytes_written ;
  OPJ_UINT32 l_current_nb_bytes_written ;
  OPJ_UINT32 l_part_tile_size ;
  OPJ_UINT32 tot_num_tp ;
  OPJ_UINT32 pino ;
  OPJ_BYTE *l_begin_data ;
  opj_tcp_t *l_tcp ;
  opj_tcd_t *l_tcd ;
  opj_cp_t *l_cp ;
  OPJ_BOOL __cil_tmp18 ;
  OPJ_BOOL __cil_tmp19 ;
  OPJ_BOOL __cil_tmp21 ;
  OPJ_BOOL __cil_tmp22 ;

  {
  {
#line 9815
  tilepartno = (OPJ_UINT32 )0;
#line 9816
  l_nb_bytes_written = (OPJ_UINT32 )0;
#line 9823
  l_tcp = (opj_tcp_t *)0;
#line 9824
  l_tcd = (opj_tcd_t *)0;
#line 9825
  l_cp = (opj_cp_t *)0;
#line 9827
  l_tcd = p_j2k->m_tcd;
#line 9828
  l_cp = & p_j2k->m_cp;
#line 9829
  l_tcp = l_cp->tcps + p_j2k->m_current_tile_number;
#line 9832
  tot_num_tp = opj_j2k_get_num_tp(l_cp, (OPJ_UINT32 )0, p_j2k->m_current_tile_number);
#line 9835
  (p_j2k->m_specific_param.m_encoder.m_current_tile_part_number) ++;
#line 9836
  tilepartno = (OPJ_UINT32 )1;
  }
  {
#line 9836
  while (1) {
    while_continue: /* CIL Label */ ;

#line 9836
    if (! (tilepartno < tot_num_tp)) {
#line 9836
      goto while_break;
    }
    {
#line 9837
    p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number = tilepartno;
#line 9838
    l_current_nb_bytes_written = (OPJ_UINT32 )0;
#line 9839
    l_part_tile_size = (OPJ_UINT32 )0;
#line 9840
    l_begin_data = p_data;
#line 9842
    __cil_tmp18 = opj_j2k_write_sot(p_j2k, p_data, & l_current_nb_bytes_written, p_stream,
                                    p_manager);
    }
#line 9842
    if (! __cil_tmp18) {
#line 9843
      return (0);
    }
    {
#line 9846
    l_nb_bytes_written += l_current_nb_bytes_written;
#line 9847
    p_data += l_current_nb_bytes_written;
#line 9848
    p_total_data_size -= l_current_nb_bytes_written;
#line 9849
    l_part_tile_size += l_current_nb_bytes_written;
#line 9851
    l_current_nb_bytes_written = (OPJ_UINT32 )0;
#line 9852
    __cil_tmp19 = opj_j2k_write_sod(p_j2k, l_tcd, p_data, & l_current_nb_bytes_written,
                                    p_total_data_size, p_stream, p_manager);
    }
#line 9852
    if (! __cil_tmp19) {
#line 9853
      return (0);
    }
    {
#line 9856
    p_data += l_current_nb_bytes_written;
#line 9857
    l_nb_bytes_written += l_current_nb_bytes_written;
#line 9858
    p_total_data_size -= l_current_nb_bytes_written;
#line 9859
    l_part_tile_size += l_current_nb_bytes_written;
#line 9862
    opj_write_bytes_LE(l_begin_data + 6, l_part_tile_size, (OPJ_UINT32 )4);
    }
#line 9864
    if (l_cp->m_specific_param.m_enc.m_cinema) {
      {
#line 9865
      opj_j2k_update_tlm(p_j2k, l_part_tile_size);
      }
    }
#line 9868
    (p_j2k->m_specific_param.m_encoder.m_current_tile_part_number) ++;
#line 9836
    tilepartno ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
#line 9871
  pino = (OPJ_UINT32 )1;
  {
#line 9871
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 9871
    if (! (pino <= l_tcp->numpocs)) {
#line 9871
      goto while_break___0;
    }
    {
#line 9872
    l_tcd->cur_pino = pino;
#line 9875
    tot_num_tp = opj_j2k_get_num_tp(l_cp, pino, p_j2k->m_current_tile_number);
#line 9876
    tilepartno = (OPJ_UINT32 )0;
    }
    {
#line 9876
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 9876
      if (! (tilepartno < tot_num_tp)) {
#line 9876
        goto while_break___1;
      }
      {
#line 9877
      p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number = tilepartno;
#line 9878
      l_current_nb_bytes_written = (OPJ_UINT32 )0;
#line 9879
      l_part_tile_size = (OPJ_UINT32 )0;
#line 9880
      l_begin_data = p_data;
#line 9882
      __cil_tmp21 = opj_j2k_write_sot(p_j2k, p_data, & l_current_nb_bytes_written,
                                      p_stream, p_manager);
      }
#line 9882
      if (! __cil_tmp21) {
#line 9883
        return (0);
      }
      {
#line 9886
      l_nb_bytes_written += l_current_nb_bytes_written;
#line 9887
      p_data += l_current_nb_bytes_written;
#line 9888
      p_total_data_size -= l_current_nb_bytes_written;
#line 9889
      l_part_tile_size += l_current_nb_bytes_written;
#line 9891
      l_current_nb_bytes_written = (OPJ_UINT32 )0;
#line 9893
      __cil_tmp22 = opj_j2k_write_sod(p_j2k, l_tcd, p_data, & l_current_nb_bytes_written,
                                      p_total_data_size, p_stream, p_manager);
      }
#line 9893
      if (! __cil_tmp22) {
#line 9894
        return (0);
      }
      {
#line 9897
      l_nb_bytes_written += l_current_nb_bytes_written;
#line 9898
      p_data += l_current_nb_bytes_written;
#line 9899
      p_total_data_size -= l_current_nb_bytes_written;
#line 9900
      l_part_tile_size += l_current_nb_bytes_written;
#line 9903
      opj_write_bytes_LE(l_begin_data + 6, l_part_tile_size, (OPJ_UINT32 )4);
      }
#line 9905
      if (l_cp->m_specific_param.m_enc.m_cinema) {
        {
#line 9906
        opj_j2k_update_tlm(p_j2k, l_part_tile_size);
        }
      }
#line 9909
      (p_j2k->m_specific_param.m_encoder.m_current_tile_part_number) ++;
#line 9876
      tilepartno ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: 
#line 9871
    pino ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: 
#line 9913
  *p_data_written = l_nb_bytes_written;
#line 9915
  return (1);
}
}
#line 9918 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_updated_tlm(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                   struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 l_tlm_size ;
  OPJ_OFF_T l_tlm_position ;
  OPJ_OFF_T l_current_position ;
  OPJ_BOOL __cil_tmp11 ;
  OPJ_SIZE_T __cil_tmp12 ;
  OPJ_BOOL __cil_tmp13 ;

  {
  {
#line 9930
  l_tlm_size = 5U * p_j2k->m_specific_param.m_encoder.m_total_tile_parts;
#line 9931
  l_tlm_position = 6L + p_j2k->m_specific_param.m_encoder.m_tlm_start;
#line 9932
  l_current_position = opj_stream_tell(p_stream);
#line 9934
  __cil_tmp11 = opj_stream_seek(p_stream, l_tlm_position, p_manager);
  }
#line 9934
  if (! __cil_tmp11) {
#line 9935
    return (0);
  }
  {
#line 9938
  __cil_tmp12 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer,
                                      (OPJ_SIZE_T )l_tlm_size, p_manager);
  }
#line 9938
  if (__cil_tmp12 != (unsigned long )l_tlm_size) {
#line 9939
    return (0);
  }
  {
#line 9942
  __cil_tmp13 = opj_stream_seek(p_stream, l_current_position, p_manager);
  }
#line 9942
  if (! __cil_tmp13) {
#line 9943
    return (0);
  }
#line 9946
  return (1);
}
}
#line 9949 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_end_encoding(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                              struct opj_event_mgr *p_manager ) 
{ 


  {
  {
#line 9958
  opj_tcd_destroy(p_j2k->m_tcd);
#line 9959
  p_j2k->m_tcd = (struct opj_tcd *)0;
  }
#line 9961
  if (p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer) {
    {
#line 9962
    free((void *)p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer);
#line 9963
    p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer = (OPJ_BYTE *)0;
#line 9964
    p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current = (OPJ_BYTE *)0;
    }
  }
#line 9967
  if (p_j2k->m_specific_param.m_encoder.m_encoded_tile_data) {
    {
#line 9968
    free((void *)p_j2k->m_specific_param.m_encoder.m_encoded_tile_data);
#line 9969
    p_j2k->m_specific_param.m_encoder.m_encoded_tile_data = (OPJ_BYTE *)0;
    }
  }
#line 9972
  p_j2k->m_specific_param.m_encoder.m_encoded_tile_size = (OPJ_UINT32 )0;
#line 9974
  return (1);
}
}
#line 9980 "/root/patron/new_22/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_destroy_header_memory(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                              opj_event_mgr_t *p_manager ) 
{ 


  {
#line 9990
  if (p_j2k->m_specific_param.m_encoder.m_header_tile_data) {
    {
#line 9991
    free((void *)p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 9992
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)0;
    }
  }
#line 9995
  p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 9997
  return (1);
}
}
#line 10000 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_init_info(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                           struct opj_event_mgr *p_manager ) 
{ 
  opj_codestream_info_t *l_cstr_info ;
  OPJ_BOOL __cil_tmp8 ;

  {
  {
#line 10004
  l_cstr_info = (opj_codestream_info_t *)0;
#line 10051
  __cil_tmp8 = opj_j2k_calculate_tp(p_j2k, & p_j2k->m_cp, & p_j2k->m_specific_param.m_encoder.m_total_tile_parts,
                                    p_j2k->m_private_image, p_manager);
  }
#line 10051
  return (__cil_tmp8);
}
}
#line 10061 "/root/patron/new_22/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_create_tcd(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                   opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp8 ;

  {
  {
#line 10071
  p_j2k->m_tcd = opj_tcd_create(0);
  }
#line 10073
  if (! p_j2k->m_tcd) {
    {
#line 10074
    opj_event_msg(p_manager, 1, "Not enough memory to create Tile Coder\n");
    }
#line 10075
    return (0);
  }
  {
#line 10078
  __cil_tmp8 = opj_tcd_init(p_j2k->m_tcd, p_j2k->m_private_image, & p_j2k->m_cp);
  }
#line 10078
  if (! __cil_tmp8) {
    {
#line 10079
    opj_tcd_destroy(p_j2k->m_tcd);
#line 10080
    p_j2k->m_tcd = (struct opj_tcd *)0;
    }
#line 10081
    return (0);
  }
#line 10084
  return (1);
}
}
#line 10087 "/root/patron/new_22/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_tile(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                            OPJ_UINT32 p_data_size , opj_stream_private_t *p_stream ,
                            opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp7 ;
  OPJ_BOOL __cil_tmp8 ;

  {
  {
#line 10094
  __cil_tmp7 = opj_j2k_pre_write_tile(p_j2k, p_tile_index, p_stream, p_manager);
  }
#line 10094
  if (! __cil_tmp7) {
    {
#line 10095
    opj_event_msg(p_manager, 1, "Error while opj_j2k_pre_write_tile with tile index = %d\n\230\001",
                  p_tile_index);
    }
#line 10096
    return (0);
  } else {
    {
#line 10099
    __cil_tmp8 = opj_j2k_post_write_tile(p_j2k, p_data, p_data_size, p_stream, p_manager);
    }
#line 10099
    if (! __cil_tmp8) {
      {
#line 10100
      opj_event_msg(p_manager, 1, "Error while opj_j2k_post_write_tile with tile index = %d\n",
                    p_tile_index);
      }
#line 10101
      return (0);
    }
  }
#line 10105
  return (1);
}
}
#line 32 "/root/patron/new_22/src/lib/openjp2/invert.c"
OPJ_BOOL opj_lupDecompose(OPJ_FLOAT32 *matrix , OPJ_UINT32 *permutations , OPJ_FLOAT32 *p_swap_area ,
                          OPJ_UINT32 nb_compo ) ;
#line 39
void opj_lupSolve(OPJ_FLOAT32 *pResult , OPJ_FLOAT32 *pMatrix , OPJ_FLOAT32 *pVector ,
                  OPJ_UINT32 *pPermutations , OPJ_UINT32 nb_compo , OPJ_FLOAT32 *p_intermediate_data ) ;
#line 49
void opj_lupInvert(OPJ_FLOAT32 *pSrcMatrix , OPJ_FLOAT32 *pDestMatrix , OPJ_UINT32 nb_compo ,
                   OPJ_UINT32 *pPermutations , OPJ_FLOAT32 *p_src_temp , OPJ_FLOAT32 *p_dest_temp ,
                   OPJ_FLOAT32 *p_swap_area ) ;
#line 65 "/root/patron/new_22/src/lib/openjp2/invert.c"
OPJ_BOOL opj_matrix_inversion_f(OPJ_FLOAT32 *pSrcMatrix , OPJ_FLOAT32 *pDestMatrix ,
                                OPJ_UINT32 nb_compo ) 
{ 
  OPJ_BYTE *l_data ;
  OPJ_UINT32 l_permutation_size ;
  OPJ_UINT32 l_swap_size ;
  OPJ_UINT32 l_total_size ;
  OPJ_UINT32 *lPermutations ;
  OPJ_FLOAT32 *l_double_data ;
  void *__cil_tmp10 ;
  OPJ_BOOL __cil_tmp11 ;

  {
  {
#line 69
  l_data = (OPJ_BYTE *)0;
#line 70
  l_permutation_size = (OPJ_UINT32 )((unsigned long )nb_compo * sizeof(OPJ_UINT32 ));
#line 71
  l_swap_size = (OPJ_UINT32 )((unsigned long )nb_compo * sizeof(OPJ_FLOAT32 ));
#line 72
  l_total_size = l_permutation_size + 3U * l_swap_size;
#line 73
  lPermutations = (OPJ_UINT32 *)0;
#line 74
  l_double_data = (OPJ_FLOAT32 *)0;
#line 76
  __cil_tmp10 = malloc((unsigned long )l_total_size);
#line 76
  l_data = (OPJ_BYTE *)__cil_tmp10;
  }
#line 77
  if ((unsigned long )l_data == (unsigned long )((OPJ_BYTE *)0)) {
#line 78
    return (0);
  }
  {
#line 80
  lPermutations = (OPJ_UINT32 *)l_data;
#line 81
  l_double_data = (OPJ_FLOAT32 *)(l_data + l_permutation_size);
#line 82
  memset((void *)lPermutations, 0, (unsigned long )l_permutation_size);
#line 84
  __cil_tmp11 = opj_lupDecompose(pSrcMatrix, lPermutations, l_double_data, nb_compo);
  }
#line 84
  if (! __cil_tmp11) {
    {
#line 85
    free((void *)l_data);
    }
#line 86
    return (0);
  }
  {
#line 89
  opj_lupInvert(pSrcMatrix, pDestMatrix, nb_compo, lPermutations, l_double_data, l_double_data + nb_compo,
                l_double_data + 2U * nb_compo);
#line 90
  free((void *)l_data);
  }
#line 92
  return (1);
}
}
#line 101 "/root/patron/new_22/src/lib/openjp2/invert.c"
OPJ_BOOL opj_lupDecompose(OPJ_FLOAT32 *matrix , OPJ_UINT32 *permutations , OPJ_FLOAT32 *p_swap_area ,
                          OPJ_UINT32 nb_compo ) 
{ 
  OPJ_UINT32 *tmpPermutations ;
  OPJ_UINT32 *dstPermutations ;
  OPJ_UINT32 k2 ;
  OPJ_UINT32 t ;
  OPJ_FLOAT32 temp ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  OPJ_FLOAT32 p ;
  OPJ_UINT32 lLastColum ;
  OPJ_UINT32 lSwapSize ;
  OPJ_FLOAT32 *lTmpMatrix ;
  OPJ_FLOAT32 *lColumnMatrix ;
  OPJ_FLOAT32 *lDestMatrix ;
  OPJ_UINT32 offset ;
  OPJ_UINT32 lStride ;
  OPJ_UINT32 *__cil_tmp21 ;
  OPJ_FLOAT32 tmp ;
  OPJ_FLOAT32 *__cil_tmp23 ;
  OPJ_FLOAT32 *__cil_tmp24 ;
  OPJ_FLOAT32 *__cil_tmp25 ;
  OPJ_FLOAT32 *__cil_tmp26 ;

  {
#line 105
  tmpPermutations = permutations;
#line 107
  k2 = (OPJ_UINT32 )0;
#line 111
  lLastColum = nb_compo - 1U;
#line 112
  lSwapSize = (OPJ_UINT32 )((unsigned long )nb_compo * sizeof(OPJ_FLOAT32 ));
#line 113
  lTmpMatrix = matrix;
#line 115
  offset = (OPJ_UINT32 )1;
#line 116
  lStride = nb_compo - 1U;
#line 119
  i = (OPJ_UINT32 )0;
  {
#line 119
  while (1) {
    while_continue: /* CIL Label */ ;

#line 119
    if (! (i < nb_compo)) {
#line 119
      goto while_break;
    }
#line 121
    __cil_tmp21 = tmpPermutations;
#line 121
    tmpPermutations ++;
#line 121
    *__cil_tmp21 = i;
#line 119
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: 
#line 124
  tmpPermutations = permutations;
#line 125
  k = (OPJ_UINT32 )0;
  {
#line 125
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 125
    if (! (k < lLastColum)) {
#line 125
      goto while_break___0;
    }
#line 126
    p = (OPJ_FLOAT32 )0.;
#line 129
    lColumnMatrix = lTmpMatrix + k;
#line 132
    i = k;
    {
#line 132
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 132
      if (! (i < nb_compo)) {
#line 132
        goto while_break___1;
      }
#line 133
      if (*lColumnMatrix > (float )0) {
#line 133
        tmp = *lColumnMatrix;
      } else {
#line 133
        tmp = - *lColumnMatrix;
      }
#line 133
      temp = tmp;
#line 134
      if (temp > p) {
#line 135
        p = temp;
#line 136
        k2 = i;
      }
#line 139
      lColumnMatrix += nb_compo;
#line 132
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___1: ;
#line 143
    if ((double )p == 0.) {
#line 144
      return (0);
    }
#line 148
    if (k2 != k) {
      {
#line 151
      dstPermutations = (tmpPermutations + k2) - k;
#line 153
      t = *tmpPermutations;
#line 154
      *tmpPermutations = *dstPermutations;
#line 155
      *dstPermutations = t;
#line 158
      lColumnMatrix = lTmpMatrix + (k2 - k) * nb_compo;
#line 159
      memcpy((void *)p_swap_area, (void const   *)lColumnMatrix, (unsigned long )lSwapSize);
#line 160
      memcpy((void *)lColumnMatrix, (void const   *)lTmpMatrix, (unsigned long )lSwapSize);
#line 161
      memcpy((void *)lTmpMatrix, (void const   *)p_swap_area, (unsigned long )lSwapSize);
      }
    }
#line 165
    lDestMatrix = lTmpMatrix + k;
#line 166
    lColumnMatrix = lDestMatrix + nb_compo;
#line 168
    __cil_tmp23 = lDestMatrix;
#line 168
    lDestMatrix ++;
#line 168
    temp = *__cil_tmp23;
#line 171
    i = offset;
    {
#line 171
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 171
      if (! (i < nb_compo)) {
#line 171
        goto while_break___2;
      }
#line 177
      p = *lColumnMatrix / temp;
#line 178
      __cil_tmp24 = lColumnMatrix;
#line 178
      lColumnMatrix ++;
#line 178
      *__cil_tmp24 = p;
#line 180
      j = offset;
      {
#line 180
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 180
        if (! (j < nb_compo)) {
#line 180
          goto while_break___3;
        }
#line 182
        __cil_tmp26 = lDestMatrix;
#line 182
        lDestMatrix ++;
#line 182
        __cil_tmp25 = lColumnMatrix;
#line 182
        lColumnMatrix ++;
#line 182
        *__cil_tmp25 -= p * *__cil_tmp26;
#line 180
        j ++;
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___3: 
#line 185
      lDestMatrix -= lStride;
#line 187
      lColumnMatrix += k;
#line 171
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: 
#line 191
    offset ++;
#line 193
    lStride --;
#line 195
    lTmpMatrix += nb_compo;
#line 197
    tmpPermutations ++;
#line 125
    k ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___0: ;
#line 199
  return (1);
}
}
#line 202 "/root/patron/new_22/src/lib/openjp2/invert.c"
void opj_lupSolve(OPJ_FLOAT32 *pResult , OPJ_FLOAT32 *pMatrix , OPJ_FLOAT32 *pVector ,
                  OPJ_UINT32 *pPermutations , OPJ_UINT32 nb_compo , OPJ_FLOAT32 *p_intermediate_data ) 
{ 
  OPJ_INT32 k ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_FLOAT32 sum ;
  OPJ_FLOAT32 u ;
  OPJ_UINT32 lStride ;
  OPJ_FLOAT32 *lCurrentPtr ;
  OPJ_FLOAT32 *lIntermediatePtr ;
  OPJ_FLOAT32 *lDestPtr ;
  OPJ_FLOAT32 *lTmpMatrix ;
  OPJ_FLOAT32 *lLineMatrix ;
  OPJ_FLOAT32 *lBeginPtr ;
  OPJ_FLOAT32 *lGeneratedData ;
  OPJ_UINT32 *lCurrentPermutationPtr ;
  OPJ_FLOAT32 *__cil_tmp21 ;
  OPJ_FLOAT32 *__cil_tmp22 ;
  OPJ_FLOAT32 *__cil_tmp23 ;
  OPJ_UINT32 *__cil_tmp24 ;
  OPJ_FLOAT32 *__cil_tmp26 ;
  OPJ_FLOAT32 *__cil_tmp27 ;
  OPJ_FLOAT32 *__cil_tmp28 ;
  OPJ_FLOAT32 *__cil_tmp29 ;
  OPJ_FLOAT32 *__cil_tmp30 ;
  OPJ_FLOAT32 *__cil_tmp31 ;

  {
#line 212
  lStride = nb_compo + 1U;
#line 217
  lLineMatrix = pMatrix;
#line 218
  lBeginPtr = (pResult + nb_compo) - 1;
#line 220
  lCurrentPermutationPtr = pPermutations;
#line 223
  lIntermediatePtr = p_intermediate_data;
#line 224
  lGeneratedData = (p_intermediate_data + nb_compo) - 1;
#line 226
  i = (OPJ_UINT32 )0;
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;

#line 226
    if (! (i < nb_compo)) {
#line 226
      goto while_break;
    }
#line 227
    sum = (OPJ_FLOAT32 )0.;
#line 228
    lCurrentPtr = p_intermediate_data;
#line 229
    lTmpMatrix = lLineMatrix;
#line 230
    j = (OPJ_UINT32 )1;
    {
#line 230
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 230
      if (! (j <= i)) {
#line 230
        goto while_break___0;
      }
#line 233
      __cil_tmp22 = lCurrentPtr;
#line 233
      lCurrentPtr ++;
#line 233
      __cil_tmp21 = lTmpMatrix;
#line 233
      lTmpMatrix ++;
#line 233
      sum += *__cil_tmp21 * *__cil_tmp22;
#line 230
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
#line 236
    __cil_tmp24 = lCurrentPermutationPtr;
#line 236
    lCurrentPermutationPtr ++;
#line 236
    __cil_tmp23 = lIntermediatePtr;
#line 236
    lIntermediatePtr ++;
#line 236
    *__cil_tmp23 = *(pVector + *__cil_tmp24) - sum;
#line 237
    lLineMatrix += nb_compo;
#line 226
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: 
#line 241
  lLineMatrix = (pMatrix + nb_compo * nb_compo) - 1;
#line 244
  lDestPtr = pResult + nb_compo;
#line 248
  k = (OPJ_INT32 )nb_compo - 1;
  {
#line 248
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 248
    if (! (k != -1)) {
#line 248
      goto while_break___1;
    }
#line 249
    sum = (OPJ_FLOAT32 )0.;
#line 250
    lTmpMatrix = lLineMatrix;
#line 251
    __cil_tmp26 = lTmpMatrix;
#line 251
    lTmpMatrix ++;
#line 251
    u = *__cil_tmp26;
#line 252
    __cil_tmp27 = lDestPtr;
#line 252
    lDestPtr --;
#line 252
    lCurrentPtr = __cil_tmp27;
#line 253
    j = (OPJ_UINT32 )(k + 1);
    {
#line 253
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 253
      if (! (j < nb_compo)) {
#line 253
        goto while_break___2;
      }
#line 255
      __cil_tmp29 = lCurrentPtr;
#line 255
      lCurrentPtr ++;
#line 255
      __cil_tmp28 = lTmpMatrix;
#line 255
      lTmpMatrix ++;
#line 255
      sum += *__cil_tmp28 * *__cil_tmp29;
#line 253
      j ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: 
#line 258
    __cil_tmp31 = lGeneratedData;
#line 258
    lGeneratedData --;
#line 258
    __cil_tmp30 = lBeginPtr;
#line 258
    lBeginPtr --;
#line 258
    *__cil_tmp30 = (*__cil_tmp31 - sum) / u;
#line 259
    lLineMatrix -= lStride;
#line 248
    k --;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___1: ;
#line 252
  return;
}
}
#line 264 "/root/patron/new_22/src/lib/openjp2/invert.c"
void opj_lupInvert(OPJ_FLOAT32 *pSrcMatrix , OPJ_FLOAT32 *pDestMatrix , OPJ_UINT32 nb_compo ,
                   OPJ_UINT32 *pPermutations , OPJ_FLOAT32 *p_src_temp , OPJ_FLOAT32 *p_dest_temp ,
                   OPJ_FLOAT32 *p_swap_area ) 
{ 
  OPJ_UINT32 j ;
  OPJ_UINT32 i ;
  OPJ_FLOAT32 *lCurrentPtr ;
  OPJ_FLOAT32 *lLineMatrix ;
  OPJ_UINT32 lSwapSize ;
  OPJ_FLOAT32 *__cil_tmp13 ;

  {
#line 274
  lLineMatrix = pDestMatrix;
#line 275
  lSwapSize = (OPJ_UINT32 )((unsigned long )nb_compo * sizeof(OPJ_FLOAT32 ));
#line 277
  j = (OPJ_UINT32 )0;
  {
#line 277
  while (1) {
    while_continue: /* CIL Label */ ;

#line 277
    if (! (j < nb_compo)) {
#line 277
      goto while_break;
    }
    {
#line 278
    __cil_tmp13 = lLineMatrix;
#line 278
    lLineMatrix ++;
#line 278
    lCurrentPtr = __cil_tmp13;
#line 279
    memset((void *)p_src_temp, 0, (unsigned long )lSwapSize);
#line 280
    *(p_src_temp + j) = (OPJ_FLOAT32 )1.;
#line 281
    opj_lupSolve(p_dest_temp, pSrcMatrix, p_src_temp, pPermutations, nb_compo, p_swap_area);
#line 283
    i = (OPJ_UINT32 )0;
    }
    {
#line 283
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 283
      if (! (i < nb_compo)) {
#line 283
        goto while_break___0;
      }
#line 284
      *lCurrentPtr = *(p_dest_temp + i);
#line 285
      lCurrentPtr += nb_compo;
#line 283
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 277
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 281
  return;
}
}
#line 29 "/root/patron/new_22/src/lib/openjp2/image.c"
opj_image_t *opj_image_create0(void) 
{ 
  opj_image_t *image ;
  void *__cil_tmp2 ;

  {
  {
#line 30
  __cil_tmp2 = calloc(1UL, sizeof(opj_image_t ));
#line 30
  image = (opj_image_t *)__cil_tmp2;
  }
#line 31
  return (image);
}
}
#line 34 "/root/patron/new_22/src/lib/openjp2/image.c"
opj_image_t *opj_image_create(OPJ_UINT32 numcmpts , opj_image_cmptparm_t *cmptparms ,
                              OPJ_COLOR_SPACE clrspc ) 
{ 
  OPJ_UINT32 compno ;
  opj_image_t *image ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;
  opj_image_comp_t *comp ;
  void *__cil_tmp9 ;

  {
  {
#line 36
  image = (opj_image_t *)((void *)0);
#line 38
  __cil_tmp6 = calloc(1UL, sizeof(opj_image_t ));
#line 38
  image = (opj_image_t *)__cil_tmp6;
  }
#line 39
  if (image) {
    {
#line 40
    image->color_space = clrspc;
#line 41
    image->numcomps = numcmpts;
#line 43
    __cil_tmp7 = calloc(1UL, (unsigned long )image->numcomps * sizeof(opj_image_comp_t ));
#line 43
    image->comps = (opj_image_comp_t *)__cil_tmp7;
    }
#line 44
    if (! image->comps) {
      {
#line 45
      fprintf(stderr, "Unable to allocate memory for image.\n");
#line 46
      opj_image_destroy(image);
      }
#line 47
      return ((opj_image_t *)((void *)0));
    }
#line 50
    compno = (OPJ_UINT32 )0;
    {
#line 50
    while (1) {
      while_continue: /* CIL Label */ ;

#line 50
      if (! (compno < numcmpts)) {
#line 50
        goto while_break;
      }
      {
#line 51
      comp = image->comps + compno;
#line 52
      comp->dx = (cmptparms + compno)->dx;
#line 53
      comp->dy = (cmptparms + compno)->dy;
#line 54
      comp->w = (cmptparms + compno)->w;
#line 55
      comp->h = (cmptparms + compno)->h;
#line 56
      comp->x0 = (cmptparms + compno)->x0;
#line 57
      comp->y0 = (cmptparms + compno)->y0;
#line 58
      comp->prec = (cmptparms + compno)->prec;
#line 59
      comp->bpp = (cmptparms + compno)->bpp;
#line 60
      comp->sgnd = (cmptparms + compno)->sgnd;
#line 61
      __cil_tmp9 = calloc((unsigned long )(comp->w * comp->h), sizeof(OPJ_INT32 ));
#line 61
      comp->data = (OPJ_INT32 *)__cil_tmp9;
      }
#line 62
      if (! comp->data) {
        {
#line 63
        fprintf(stderr, "Unable to allocate memory for image.\n");
#line 64
        opj_image_destroy(image);
        }
#line 65
        return ((opj_image_t *)((void *)0));
      }
#line 50
      compno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 70
  return (image);
}
}
#line 73 "/root/patron/new_22/src/lib/openjp2/image.c"
void opj_image_destroy(opj_image_t *image ) 
{ 
  OPJ_UINT32 compno ;
  opj_image_comp_t *image_comp ;

  {
#line 74
  if (image) {
#line 75
    if (image->comps) {
#line 79
      compno = (OPJ_UINT32 )0;
      {
#line 79
      while (1) {
        while_continue: /* CIL Label */ ;

#line 79
        if (! (compno < image->numcomps)) {
#line 79
          goto while_break;
        }
#line 80
        image_comp = image->comps + compno;
#line 81
        if (image_comp->data) {
          {
#line 82
          free((void *)image_comp->data);
          }
        }
#line 79
        compno ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: 
      {
#line 85
      free((void *)image->comps);
      }
    }
#line 88
    if (image->icc_profile_buf) {
      {
#line 89
      free((void *)image->icc_profile_buf);
      }
    }
    {
#line 92
    free((void *)image);
    }
  }
#line 95
  return;
}
}
#line 102 "/root/patron/new_22/src/lib/openjp2/image.c"
void opj_image_comp_header_update(opj_image_t *p_image_header , struct opj_cp *p_cp ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_width ;
  OPJ_UINT32 l_height ;
  OPJ_INT32 l_x0 ;
  OPJ_INT32 l_y0 ;
  OPJ_INT32 l_x1 ;
  OPJ_INT32 l_y1 ;
  OPJ_INT32 l_comp_x0 ;
  OPJ_INT32 l_comp_y0 ;
  OPJ_INT32 l_comp_x1 ;
  OPJ_INT32 l_comp_y1 ;
  opj_image_comp_t *l_img_comp ;
  OPJ_INT32 __cil_tmp23 ;
  OPJ_INT32 __cil_tmp24 ;

  {
  {
#line 107
  l_img_comp = (opj_image_comp_t *)((void *)0);
#line 109
  l_x0 = opj_int_max((OPJ_INT32 )p_cp->tx0, (OPJ_INT32 )p_image_header->x0);
#line 110
  l_y0 = opj_int_max((OPJ_INT32 )p_cp->ty0, (OPJ_INT32 )p_image_header->y0);
#line 111
  l_x1 = opj_int_min((OPJ_INT32 )(p_cp->tx0 + p_cp->tw * p_cp->tdx), (OPJ_INT32 )p_image_header->x1);
#line 112
  l_y1 = opj_int_min((OPJ_INT32 )(p_cp->ty0 + p_cp->th * p_cp->tdy), (OPJ_INT32 )p_image_header->y1);
#line 114
  l_img_comp = p_image_header->comps;
#line 115
  i = (OPJ_UINT32 )0;
  }
  {
#line 115
  while (1) {
    while_continue: /* CIL Label */ ;

#line 115
    if (! (i < p_image_header->numcomps)) {
#line 115
      goto while_break;
    }
    {
#line 116
    l_comp_x0 = opj_int_ceildiv(l_x0, (OPJ_INT32 )l_img_comp->dx);
#line 117
    l_comp_y0 = opj_int_ceildiv(l_y0, (OPJ_INT32 )l_img_comp->dy);
#line 118
    l_comp_x1 = opj_int_ceildiv(l_x1, (OPJ_INT32 )l_img_comp->dx);
#line 119
    l_comp_y1 = opj_int_ceildiv(l_y1, (OPJ_INT32 )l_img_comp->dy);
#line 120
    __cil_tmp23 = opj_int_ceildivpow2(l_comp_x1 - l_comp_x0, (OPJ_INT32 )l_img_comp->factor);
#line 120
    l_width = (OPJ_UINT32 )__cil_tmp23;
#line 121
    __cil_tmp24 = opj_int_ceildivpow2(l_comp_y1 - l_comp_y0, (OPJ_INT32 )l_img_comp->factor);
#line 121
    l_height = (OPJ_UINT32 )__cil_tmp24;
#line 122
    l_img_comp->w = l_width;
#line 123
    l_img_comp->h = l_height;
#line 124
    l_img_comp->x0 = (OPJ_UINT32 )l_comp_x0;
#line 125
    l_img_comp->y0 = (OPJ_UINT32 )l_comp_y0;
#line 126
    l_img_comp ++;
#line 115
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 119
  return;
}
}
#line 139 "/root/patron/new_22/src/lib/openjp2/image.c"
void opj_copy_image_header(opj_image_t *p_image_src , opj_image_t *p_image_dest ) 
{ 
  OPJ_UINT32 compno ;
  opj_image_comp_t *image_comp ;
  void *__cil_tmp8 ;
  void *__cil_tmp10 ;

  {
#line 147
  p_image_dest->x0 = p_image_src->x0;
#line 148
  p_image_dest->y0 = p_image_src->y0;
#line 149
  p_image_dest->x1 = p_image_src->x1;
#line 150
  p_image_dest->y1 = p_image_src->y1;
#line 152
  if (p_image_dest->comps) {
#line 153
    compno = (OPJ_UINT32 )0;
    {
#line 153
    while (1) {
      while_continue: /* CIL Label */ ;

#line 153
      if (! (compno < p_image_dest->numcomps)) {
#line 153
        goto while_break;
      }
#line 154
      image_comp = p_image_dest->comps + compno;
#line 155
      if (image_comp->data) {
        {
#line 156
        free((void *)image_comp->data);
        }
      }
#line 153
      compno ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: 
    {
#line 159
    free((void *)p_image_dest->comps);
#line 160
    p_image_dest->comps = (opj_image_comp_t *)((void *)0);
    }
  }
  {
#line 163
  p_image_dest->numcomps = p_image_src->numcomps;
#line 165
  __cil_tmp8 = malloc((unsigned long )p_image_dest->numcomps * sizeof(opj_image_comp_t ));
#line 165
  p_image_dest->comps = (opj_image_comp_t *)__cil_tmp8;
  }
#line 166
  if (! p_image_dest->comps) {
#line 167
    p_image_dest->comps = (opj_image_comp_t *)((void *)0);
#line 168
    p_image_dest->numcomps = (OPJ_UINT32 )0;
#line 169
    return;
  }
#line 172
  compno = (OPJ_UINT32 )0;
  {
#line 172
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 172
    if (! (compno < p_image_dest->numcomps)) {
#line 172
      goto while_break___0;
    }
    {
#line 173
    memcpy((void *)(p_image_dest->comps + compno), (void const   *)(p_image_src->comps + compno),
           sizeof(opj_image_comp_t ));
#line 176
    (p_image_dest->comps + compno)->data = (OPJ_INT32 *)((void *)0);
#line 172
    compno ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: 
#line 179
  p_image_dest->color_space = p_image_src->color_space;
#line 180
  p_image_dest->icc_profile_len = p_image_src->icc_profile_len;
#line 182
  if (p_image_dest->icc_profile_len) {
    {
#line 183
    __cil_tmp10 = malloc((unsigned long )p_image_dest->icc_profile_len);
#line 183
    p_image_dest->icc_profile_buf = (OPJ_BYTE *)__cil_tmp10;
    }
#line 184
    if (! p_image_dest->icc_profile_buf) {
#line 185
      p_image_dest->icc_profile_buf = (OPJ_BYTE *)((void *)0);
#line 186
      p_image_dest->icc_profile_len = (OPJ_UINT32 )0;
#line 187
      return;
    }
    {
#line 189
    memcpy((void *)p_image_dest->icc_profile_buf, (void const   *)p_image_src->icc_profile_buf,
           (unsigned long )p_image_src->icc_profile_len);
    }
  } else {
#line 194
    p_image_dest->icc_profile_buf = (OPJ_BYTE *)((void *)0);
  }
#line 196
  return;
}
}
#line 199 "/root/patron/new_22/src/lib/openjp2/image.c"
opj_image_t *opj_image_tile_create(OPJ_UINT32 numcmpts , opj_image_cmptparm_t *cmptparms ,
                                   OPJ_COLOR_SPACE clrspc ) 
{ 
  OPJ_UINT32 compno ;
  opj_image_t *image ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;
  opj_image_comp_t *comp ;

  {
  {
#line 201
  image = (opj_image_t *)0;
#line 203
  __cil_tmp6 = malloc(sizeof(opj_image_t ));
#line 203
  image = (opj_image_t *)__cil_tmp6;
  }
#line 204
  if (image) {
    {
#line 206
    memset((void *)image, 0, sizeof(opj_image_t ));
#line 208
    image->color_space = clrspc;
#line 209
    image->numcomps = numcmpts;
#line 212
    __cil_tmp7 = malloc((unsigned long )image->numcomps * sizeof(opj_image_comp_t ));
#line 212
    image->comps = (opj_image_comp_t *)__cil_tmp7;
    }
#line 213
    if (! image->comps) {
      {
#line 214
      opj_image_destroy(image);
      }
#line 215
      return ((opj_image_t *)0);
    }
    {
#line 217
    memset((void *)image->comps, 0, (unsigned long )image->numcomps * sizeof(opj_image_comp_t ));
#line 220
    compno = (OPJ_UINT32 )0;
    }
    {
#line 220
    while (1) {
      while_continue: /* CIL Label */ ;

#line 220
      if (! (compno < numcmpts)) {
#line 220
        goto while_break;
      }
#line 221
      comp = image->comps + compno;
#line 222
      comp->dx = (cmptparms + compno)->dx;
#line 223
      comp->dy = (cmptparms + compno)->dy;
#line 224
      comp->w = (cmptparms + compno)->w;
#line 225
      comp->h = (cmptparms + compno)->h;
#line 226
      comp->x0 = (cmptparms + compno)->x0;
#line 227
      comp->y0 = (cmptparms + compno)->y0;
#line 228
      comp->prec = (cmptparms + compno)->prec;
#line 229
      comp->sgnd = (cmptparms + compno)->sgnd;
#line 230
      comp->data = (OPJ_INT32 *)0;
#line 220
      compno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 234
  return (image);
}
}
#line 34 "/root/patron/new_22/src/lib/openjp2/function_list.c"
opj_procedure_list_t *opj_procedure_list_create(void) 
{ 
  opj_procedure_list_t *l_validation ;
  void *__cil_tmp2 ;
  void *__cil_tmp3 ;

  {
  {
#line 37
  __cil_tmp2 = malloc(sizeof(opj_procedure_list_t ));
#line 37
  l_validation = (opj_procedure_list_t *)__cil_tmp2;
  }
#line 38
  if (! l_validation) {
#line 40
    return ((opj_procedure_list_t *)0);
  }
  {
#line 43
  memset((void *)l_validation, 0, sizeof(opj_procedure_list_t ));
#line 44
  l_validation->m_nb_max_procedures = (OPJ_UINT32 )10;
#line 45
  __cil_tmp3 = malloc(10UL * sizeof(void (*)(void)));
#line 45
  l_validation->m_procedures = (opj_procedure *)__cil_tmp3;
  }
#line 47
  if (! l_validation->m_procedures) {
    {
#line 49
    free((void *)l_validation);
    }
#line 50
    return ((opj_procedure_list_t *)0);
  }
  {
#line 52
  memset((void *)l_validation->m_procedures, 0, 10UL * sizeof(void (*)(void)));
  }
#line 53
  return (l_validation);
}
}
#line 56 "/root/patron/new_22/src/lib/openjp2/function_list.c"
void opj_procedure_list_destroy(opj_procedure_list_t *p_list ) 
{ 


  {
#line 58
  if (! p_list) {
#line 60
    return;
  }
#line 63
  if (p_list->m_procedures) {
    {
#line 65
    free((void *)p_list->m_procedures);
    }
  }
  {
#line 67
  free((void *)p_list);
  }
#line 69
  return;
}
}
#line 70 "/root/patron/new_22/src/lib/openjp2/function_list.c"
OPJ_BOOL opj_procedure_list_add_procedure(opj_procedure_list_t *p_validation_list ,
                                          void (*p_procedure)(void) ) 
{ 
  opj_procedure *new_procedures ;
  void *__cil_tmp4 ;

  {
#line 72
  if (p_validation_list->m_nb_max_procedures == p_validation_list->m_nb_procedures) {
    {
#line 76
    p_validation_list->m_nb_max_procedures += 10U;
#line 77
    __cil_tmp4 = realloc((void *)p_validation_list->m_procedures, (unsigned long )p_validation_list->m_nb_max_procedures * sizeof(void (*)(void)));
#line 77
    new_procedures = (opj_procedure *)__cil_tmp4;
    }
#line 80
    if (! new_procedures) {
      {
#line 82
      free((void *)p_validation_list->m_procedures);
#line 83
      p_validation_list->m_nb_max_procedures = (OPJ_UINT32 )0;
#line 84
      p_validation_list->m_nb_procedures = (OPJ_UINT32 )0;
#line 86
      fprintf(stderr, "Not enough memory to add a new validation procedure\n");
      }
#line 88
      return (0);
    } else {
#line 92
      p_validation_list->m_procedures = new_procedures;
    }
  }
#line 95
  *(p_validation_list->m_procedures + p_validation_list->m_nb_procedures) = p_procedure;
#line 96
  (p_validation_list->m_nb_procedures) ++;
#line 98
  return (1);
}
}
#line 101 "/root/patron/new_22/src/lib/openjp2/function_list.c"
OPJ_UINT32 opj_procedure_list_get_nb_procedures(opj_procedure_list_t *p_validation_list ) 
{ 


  {
#line 103
  return (p_validation_list->m_nb_procedures);
}
}
#line 106 "/root/patron/new_22/src/lib/openjp2/function_list.c"
opj_procedure *opj_procedure_list_get_first_procedure(opj_procedure_list_t *p_validation_list ) 
{ 


  {
#line 108
  return (p_validation_list->m_procedures);
}
}
#line 111 "/root/patron/new_22/src/lib/openjp2/function_list.c"
void opj_procedure_list_clear(opj_procedure_list_t *p_validation_list ) 
{ 


  {
#line 113
  p_validation_list->m_nb_procedures = (OPJ_UINT32 )0;
#line 114
  return;
}
}
#line 71 "/root/patron/new_22/src/lib/openjp2/event.c"
static void opj_default_callback(char const   *msg , void *client_data ) 
{ 


  {
#line 76
  return;
}
}
#line 81 "/root/patron/new_22/src/lib/openjp2/event.c"
OPJ_BOOL opj_event_msg(opj_event_mgr_t *p_event_mgr , OPJ_INT32 event_type , char const   *fmt 
                       , ...) 
{ 
  void (*msg_handler)(char const   * , void * ) ;
  void *l_data ;
  va_list arg ;
  size_t str_length ;
  char message[512] ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long tmp ;

  {
#line 83
  msg_handler = (void (*)(char const   * , void * ))0;
#line 84
  l_data = (void *)0;
#line 86
  if ((unsigned long )p_event_mgr != (unsigned long )((opj_event_mgr_t *)0)) {
#line 88
    if (event_type == 1) {
#line 88
      goto case_1;
    }
#line 92
    if (event_type == 2) {
#line 92
      goto case_2;
    }
#line 96
    if (event_type == 4) {
#line 96
      goto case_4;
    }
#line 100
    goto switch_default;
    case_1: 
#line 89
    msg_handler = p_event_mgr->error_handler;
#line 90
    l_data = p_event_mgr->m_error_data;
#line 91
    goto switch_break;
    case_2: 
#line 93
    msg_handler = p_event_mgr->warning_handler;
#line 94
    l_data = p_event_mgr->m_warning_data;
#line 95
    goto switch_break;
    case_4: 
#line 97
    msg_handler = p_event_mgr->info_handler;
#line 98
    l_data = p_event_mgr->m_info_data;
#line 99
    goto switch_break;
    switch_default: 
#line 101
    goto switch_break;
    switch_break: ;
#line 103
    if ((unsigned long )msg_handler == (unsigned long )((void (*)(char const   * ,
                                                                  void * ))0)) {
#line 104
      return (0);
    }
  } else {
#line 107
    return (0);
  }
#line 110
  if ((unsigned long )fmt != (unsigned long )((char const   *)0)) {
#line 110
    if ((unsigned long )p_event_mgr != (unsigned long )((opj_event_mgr_t *)0)) {
      {
#line 114
      memset((void *)(message), 0, 512UL);
#line 116
      __builtin_va_start((__builtin_va_list )((void *)arg), fmt);
#line 118
      __cil_tmp9 = strlen(fmt);
      }
#line 118
      if (__cil_tmp9 > 512UL) {
#line 118
        tmp = 512UL;
      } else {
        {
#line 118
        __cil_tmp10 = strlen(fmt);
#line 118
        tmp = __cil_tmp10;
        }
      }
      {
#line 118
      str_length = tmp;
#line 121
      vsnprintf(message, 512UL, fmt, (__gnuc_va_list )((void *)arg));
#line 123
      __builtin_va_end((__builtin_va_list )((void *)arg));
#line 126
      (*msg_handler)((char const   *)(message), l_data);
      }
    }
  }
#line 129
  return (1);
}
}
#line 132 "/root/patron/new_22/src/lib/openjp2/event.c"
void opj_set_default_event_handler(opj_event_mgr_t *p_manager ) 
{ 


  {
#line 134
  p_manager->m_error_data = (void *)0;
#line 135
  p_manager->m_warning_data = (void *)0;
#line 136
  p_manager->m_info_data = (void *)0;
#line 137
  p_manager->error_handler = & opj_default_callback;
#line 138
  p_manager->info_handler = & opj_default_callback;
#line 139
  p_manager->warning_handler = & opj_default_callback;
#line 140
  return;
}
}
#line 41 "/root/patron/new_22/src/lib/openjp2/cio.c"
void opj_write_bytes_BE(OPJ_BYTE *p_buffer , OPJ_UINT32 p_value , OPJ_UINT32 p_nb_bytes ) 
{ 
  OPJ_BYTE *l_data_ptr ;

  {
  {
#line 43
  l_data_ptr = (OPJ_BYTE *)(& p_value) + p_nb_bytes;
#line 47
  memcpy((void *)p_buffer, (void const   *)l_data_ptr, (unsigned long )p_nb_bytes);
  }
#line 49
  return;
}
}
#line 50 "/root/patron/new_22/src/lib/openjp2/cio.c"
void opj_write_bytes_LE(OPJ_BYTE *p_buffer , OPJ_UINT32 p_value , OPJ_UINT32 p_nb_bytes ) 
{ 
  OPJ_BYTE *l_data_ptr ;
  OPJ_UINT32 i ;
  OPJ_BYTE *__cil_tmp7 ;
  OPJ_BYTE *__cil_tmp8 ;

  {
#line 52
  l_data_ptr = ((OPJ_BYTE *)(& p_value) + p_nb_bytes) - 1;
#line 57
  i = (OPJ_UINT32 )0;
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;

#line 57
    if (! (i < p_nb_bytes)) {
#line 57
      goto while_break;
    }
#line 58
    __cil_tmp8 = l_data_ptr;
#line 58
    l_data_ptr --;
#line 58
    __cil_tmp7 = p_buffer;
#line 58
    p_buffer ++;
#line 58
    *__cil_tmp7 = *__cil_tmp8;
#line 57
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 61
  return;
}
}
#line 62 "/root/patron/new_22/src/lib/openjp2/cio.c"
void opj_read_bytes_BE(OPJ_BYTE *p_buffer , OPJ_UINT32 *p_value , OPJ_UINT32 p_nb_bytes ) 
{ 
  OPJ_BYTE *l_data_ptr ;

  {
  {
#line 64
  l_data_ptr = (OPJ_BYTE *)p_value;
#line 68
  *p_value = (OPJ_UINT32 )0;
#line 69
  memcpy((void *)((l_data_ptr + 4) - p_nb_bytes), (void const   *)p_buffer, (unsigned long )p_nb_bytes);
  }
#line 71
  return;
}
}
#line 72 "/root/patron/new_22/src/lib/openjp2/cio.c"
void opj_read_bytes_LE(OPJ_BYTE *p_buffer , OPJ_UINT32 *p_value , OPJ_UINT32 p_nb_bytes ) 
{ 
  OPJ_BYTE *l_data_ptr ;
  OPJ_UINT32 i ;
  OPJ_BYTE *__cil_tmp7 ;
  OPJ_BYTE *__cil_tmp8 ;

  {
#line 74
  l_data_ptr = ((OPJ_BYTE *)p_value + p_nb_bytes) - 1;
#line 79
  *p_value = (OPJ_UINT32 )0;
#line 80
  i = (OPJ_UINT32 )0;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;

#line 80
    if (! (i < p_nb_bytes)) {
#line 80
      goto while_break;
    }
#line 81
    __cil_tmp8 = p_buffer;
#line 81
    p_buffer ++;
#line 81
    __cil_tmp7 = l_data_ptr;
#line 81
    l_data_ptr --;
#line 81
    *__cil_tmp7 = *__cil_tmp8;
#line 80
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 84
  return;
}
}
#line 85 "/root/patron/new_22/src/lib/openjp2/cio.c"
void opj_write_double_BE(OPJ_BYTE *p_buffer , OPJ_FLOAT64 p_value ) 
{ 
  OPJ_BYTE *l_data_ptr ;

  {
  {
#line 87
  l_data_ptr = (OPJ_BYTE *)(& p_value);
#line 88
  memcpy((void *)p_buffer, (void const   *)l_data_ptr, sizeof(OPJ_FLOAT64 ));
  }
#line 90
  return;
}
}
#line 91 "/root/patron/new_22/src/lib/openjp2/cio.c"
void opj_write_double_LE(OPJ_BYTE *p_buffer , OPJ_FLOAT64 p_value ) 
{ 
  OPJ_BYTE *l_data_ptr ;
  OPJ_UINT32 i ;
  OPJ_BYTE *__cil_tmp5 ;
  OPJ_BYTE *__cil_tmp6 ;

  {
#line 93
  l_data_ptr = ((OPJ_BYTE *)(& p_value) + sizeof(OPJ_FLOAT64 )) - 1;
#line 95
  i = (OPJ_UINT32 )0;
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;

#line 95
    if (! ((unsigned long )i < sizeof(OPJ_FLOAT64 ))) {
#line 95
      goto while_break;
    }
#line 96
    __cil_tmp6 = l_data_ptr;
#line 96
    l_data_ptr --;
#line 96
    __cil_tmp5 = p_buffer;
#line 96
    p_buffer ++;
#line 96
    *__cil_tmp5 = *__cil_tmp6;
#line 95
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 99
  return;
}
}
#line 100 "/root/patron/new_22/src/lib/openjp2/cio.c"
void opj_read_double_BE(OPJ_BYTE *p_buffer , OPJ_FLOAT64 *p_value ) 
{ 
  OPJ_BYTE *l_data_ptr ;

  {
  {
#line 102
  l_data_ptr = (OPJ_BYTE *)p_value;
#line 103
  memcpy((void *)l_data_ptr, (void const   *)p_buffer, sizeof(OPJ_FLOAT64 ));
  }
#line 105
  return;
}
}
#line 106 "/root/patron/new_22/src/lib/openjp2/cio.c"
void opj_read_double_LE(OPJ_BYTE *p_buffer , OPJ_FLOAT64 *p_value ) 
{ 
  OPJ_BYTE *l_data_ptr ;
  OPJ_UINT32 i ;
  OPJ_BYTE *__cil_tmp5 ;
  OPJ_BYTE *__cil_tmp6 ;

  {
#line 108
  l_data_ptr = ((OPJ_BYTE *)p_value + sizeof(OPJ_FLOAT64 )) - 1;
#line 110
  i = (OPJ_UINT32 )0;
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;

#line 110
    if (! ((unsigned long )i < sizeof(OPJ_FLOAT64 ))) {
#line 110
      goto while_break;
    }
#line 111
    __cil_tmp6 = p_buffer;
#line 111
    p_buffer ++;
#line 111
    __cil_tmp5 = l_data_ptr;
#line 111
    l_data_ptr --;
#line 111
    *__cil_tmp5 = *__cil_tmp6;
#line 110
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 114
  return;
}
}
#line 115 "/root/patron/new_22/src/lib/openjp2/cio.c"
void opj_write_float_BE(OPJ_BYTE *p_buffer , OPJ_FLOAT32 p_value ) 
{ 
  OPJ_BYTE *l_data_ptr ;

  {
  {
#line 117
  l_data_ptr = (OPJ_BYTE *)(& p_value);
#line 118
  memcpy((void *)p_buffer, (void const   *)l_data_ptr, sizeof(OPJ_FLOAT32 ));
  }
#line 120
  return;
}
}
#line 121 "/root/patron/new_22/src/lib/openjp2/cio.c"
void opj_write_float_LE(OPJ_BYTE *p_buffer , OPJ_FLOAT32 p_value ) 
{ 
  OPJ_BYTE *l_data_ptr ;
  OPJ_UINT32 i ;
  OPJ_BYTE *__cil_tmp5 ;
  OPJ_BYTE *__cil_tmp6 ;

  {
#line 123
  l_data_ptr = ((OPJ_BYTE *)(& p_value) + sizeof(OPJ_FLOAT32 )) - 1;
#line 125
  i = (OPJ_UINT32 )0;
  {
#line 125
  while (1) {
    while_continue: /* CIL Label */ ;

#line 125
    if (! ((unsigned long )i < sizeof(OPJ_FLOAT32 ))) {
#line 125
      goto while_break;
    }
#line 126
    __cil_tmp6 = l_data_ptr;
#line 126
    l_data_ptr --;
#line 126
    __cil_tmp5 = p_buffer;
#line 126
    p_buffer ++;
#line 126
    *__cil_tmp5 = *__cil_tmp6;
#line 125
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 129
  return;
}
}
#line 130 "/root/patron/new_22/src/lib/openjp2/cio.c"
void opj_read_float_BE(OPJ_BYTE *p_buffer , OPJ_FLOAT32 *p_value ) 
{ 
  OPJ_BYTE *l_data_ptr ;

  {
  {
#line 132
  l_data_ptr = (OPJ_BYTE *)p_value;
#line 133
  memcpy((void *)l_data_ptr, (void const   *)p_buffer, sizeof(OPJ_FLOAT32 ));
  }
#line 135
  return;
}
}
#line 136 "/root/patron/new_22/src/lib/openjp2/cio.c"
void opj_read_float_LE(OPJ_BYTE *p_buffer , OPJ_FLOAT32 *p_value ) 
{ 
  OPJ_BYTE *l_data_ptr ;
  OPJ_UINT32 i ;
  OPJ_BYTE *__cil_tmp5 ;
  OPJ_BYTE *__cil_tmp6 ;

  {
#line 138
  l_data_ptr = ((OPJ_BYTE *)p_value + sizeof(OPJ_FLOAT32 )) - 1;
#line 140
  i = (OPJ_UINT32 )0;
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;

#line 140
    if (! ((unsigned long )i < sizeof(OPJ_FLOAT32 ))) {
#line 140
      goto while_break;
    }
#line 141
    __cil_tmp6 = p_buffer;
#line 141
    p_buffer ++;
#line 141
    __cil_tmp5 = l_data_ptr;
#line 141
    l_data_ptr --;
#line 141
    *__cil_tmp5 = *__cil_tmp6;
#line 140
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 144
  return;
}
}
#line 145 "/root/patron/new_22/src/lib/openjp2/cio.c"
opj_stream_t *opj_stream_create(OPJ_SIZE_T p_buffer_size , OPJ_BOOL l_is_input ) 
{ 
  opj_stream_private_t *l_stream ;
  void *__cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 147
  l_stream = (opj_stream_private_t *)0;
#line 148
  __cil_tmp4 = malloc(sizeof(opj_stream_private_t ));
#line 148
  l_stream = (opj_stream_private_t *)__cil_tmp4;
  }
#line 149
  if (! l_stream) {
#line 150
    return ((opj_stream_t *)0);
  }
  {
#line 153
  memset((void *)l_stream, 0, sizeof(opj_stream_private_t ));
#line 154
  l_stream->m_buffer_size = p_buffer_size;
#line 155
  __cil_tmp5 = malloc(p_buffer_size);
#line 155
  l_stream->m_stored_data = (OPJ_BYTE *)__cil_tmp5;
  }
#line 156
  if (! l_stream->m_stored_data) {
    {
#line 157
    free((void *)l_stream);
    }
#line 158
    return ((opj_stream_t *)0);
  }
#line 161
  l_stream->m_current_data = l_stream->m_stored_data;
#line 163
  if (l_is_input) {
#line 164
    l_stream->m_status = (opj_stream_flag )((int )l_stream->m_status | 2);
#line 165
    l_stream->m_opj_skip = & opj_stream_read_skip;
#line 166
    l_stream->m_opj_seek = & opj_stream_read_seek;
  } else {
#line 169
    l_stream->m_status = (opj_stream_flag )((int )l_stream->m_status | 1);
#line 170
    l_stream->m_opj_skip = & opj_stream_write_skip;
#line 171
    l_stream->m_opj_seek = & opj_stream_write_seek;
  }
#line 174
  l_stream->m_read_fn = & opj_stream_default_read;
#line 175
  l_stream->m_write_fn = & opj_stream_default_write;
#line 176
  l_stream->m_skip_fn = & opj_stream_default_skip;
#line 177
  l_stream->m_seek_fn = & opj_stream_default_seek;
#line 179
  return ((opj_stream_t *)l_stream);
}
}
#line 182 "/root/patron/new_22/src/lib/openjp2/cio.c"
opj_stream_t *opj_stream_default_create(OPJ_BOOL l_is_input ) 
{ 
  opj_stream_t *__cil_tmp2 ;

  {
  {
#line 184
  __cil_tmp2 = opj_stream_create((OPJ_SIZE_T )1048576, l_is_input);
  }
#line 184
  return (__cil_tmp2);
}
}
#line 187 "/root/patron/new_22/src/lib/openjp2/cio.c"
void opj_stream_destroy(opj_stream_t *p_stream ) 
{ 
  opj_stream_private_t *l_stream ;

  {
#line 189
  l_stream = (opj_stream_private_t *)p_stream;
#line 191
  if (l_stream) {
    {
#line 192
    free((void *)l_stream->m_stored_data);
#line 193
    l_stream->m_stored_data = (OPJ_BYTE *)0;
#line 194
    free((void *)l_stream);
    }
  }
#line 197
  return;
}
}
#line 198 "/root/patron/new_22/src/lib/openjp2/cio.c"
void opj_stream_destroy_v3(opj_stream_t *p_stream ) 
{ 
  opj_stream_private_t *l_stream ;
  FILE *fp ;

  {
#line 200
  l_stream = (opj_stream_private_t *)p_stream;
#line 202
  if (l_stream) {
#line 203
    fp = (FILE *)l_stream->m_user_data;
#line 204
    if (fp) {
      {
#line 205
      fclose(fp);
      }
    }
    {
#line 207
    free((void *)l_stream->m_stored_data);
#line 208
    l_stream->m_stored_data = (OPJ_BYTE *)0;
#line 209
    free((void *)l_stream);
    }
  }
#line 212
  return;
}
}
#line 213 "/root/patron/new_22/src/lib/openjp2/cio.c"
void opj_stream_set_read_function(opj_stream_t *p_stream , OPJ_SIZE_T (*p_function)(void * ,
                                                                                    OPJ_SIZE_T  ,
                                                                                    void * ) ) 
{ 
  opj_stream_private_t *l_stream ;

  {
#line 215
  l_stream = (opj_stream_private_t *)p_stream;
#line 217
  if (! l_stream) {
#line 218
    return;
  } else
#line 217
  if (! ((int )l_stream->m_status & 2)) {
#line 218
    return;
  }
#line 221
  l_stream->m_read_fn = p_function;
#line 222
  return;
}
}
#line 224 "/root/patron/new_22/src/lib/openjp2/cio.c"
void opj_stream_set_seek_function(opj_stream_t *p_stream , OPJ_BOOL (*p_function)(OPJ_OFF_T  ,
                                                                                  void * ) ) 
{ 
  opj_stream_private_t *l_stream ;

  {
#line 226
  l_stream = (opj_stream_private_t *)p_stream;
#line 228
  if (! l_stream) {
#line 229
    return;
  }
#line 231
  l_stream->m_seek_fn = p_function;
#line 232
  return;
}
}
#line 234 "/root/patron/new_22/src/lib/openjp2/cio.c"
void opj_stream_set_write_function(opj_stream_t *p_stream , OPJ_SIZE_T (*p_function)(void * ,
                                                                                     OPJ_SIZE_T  ,
                                                                                     void * ) ) 
{ 
  opj_stream_private_t *l_stream ;

  {
#line 236
  l_stream = (opj_stream_private_t *)p_stream;
#line 238
  if (! l_stream) {
#line 239
    return;
  } else
#line 238
  if (! ((int )l_stream->m_status & 1)) {
#line 239
    return;
  }
#line 242
  l_stream->m_write_fn = p_function;
#line 243
  return;
}
}
#line 245 "/root/patron/new_22/src/lib/openjp2/cio.c"
void opj_stream_set_skip_function(opj_stream_t *p_stream , OPJ_OFF_T (*p_function)(OPJ_OFF_T  ,
                                                                                   void * ) ) 
{ 
  opj_stream_private_t *l_stream ;

  {
#line 247
  l_stream = (opj_stream_private_t *)p_stream;
#line 249
  if (! l_stream) {
#line 250
    return;
  }
#line 253
  l_stream->m_skip_fn = p_function;
#line 254
  return;
}
}
#line 256 "/root/patron/new_22/src/lib/openjp2/cio.c"
void opj_stream_set_user_data(opj_stream_t *p_stream , void *p_data ) 
{ 
  opj_stream_private_t *l_stream ;

  {
#line 258
  l_stream = (opj_stream_private_t *)p_stream;
#line 259
  if (! l_stream) {
#line 260
    return;
  }
#line 261
  l_stream->m_user_data = p_data;
#line 262
  return;
}
}
#line 264 "/root/patron/new_22/src/lib/openjp2/cio.c"
void opj_stream_set_user_data_length(opj_stream_t *p_stream , OPJ_UINT64 data_length ) 
{ 
  opj_stream_private_t *l_stream ;

  {
#line 266
  l_stream = (opj_stream_private_t *)p_stream;
#line 267
  if (! l_stream) {
#line 268
    return;
  }
#line 269
  l_stream->m_user_data_length = data_length;
#line 270
  return;
}
}
#line 272 "/root/patron/new_22/src/lib/openjp2/cio.c"
OPJ_SIZE_T opj_stream_read_data(opj_stream_private_t *p_stream , OPJ_BYTE *p_buffer ,
                                OPJ_SIZE_T p_size , opj_event_mgr_t *p_event_mgr ) 
{ 
  OPJ_SIZE_T l_read_nb_bytes ;
  OPJ_SIZE_T tmp ;
  OPJ_SIZE_T tmp___0 ;
  OPJ_SIZE_T tmp___1 ;

  {
#line 274
  l_read_nb_bytes = (OPJ_SIZE_T )0;
#line 275
  if (p_stream->m_bytes_in_buffer >= p_size) {
    {
#line 276
    memcpy((void *)p_buffer, (void const   *)p_stream->m_current_data, p_size);
#line 277
    p_stream->m_current_data += p_size;
#line 278
    p_stream->m_bytes_in_buffer -= p_size;
#line 279
    l_read_nb_bytes += p_size;
#line 280
    p_stream->m_byte_offset += (OPJ_OFF_T )p_size;
    }
#line 281
    return (l_read_nb_bytes);
  }
#line 285
  if ((int )p_stream->m_status & 4) {
    {
#line 286
    l_read_nb_bytes += p_stream->m_bytes_in_buffer;
#line 287
    memcpy((void *)p_buffer, (void const   *)p_stream->m_current_data, p_stream->m_bytes_in_buffer);
#line 288
    p_stream->m_current_data += p_stream->m_bytes_in_buffer;
#line 289
    p_stream->m_byte_offset += (OPJ_OFF_T )p_stream->m_bytes_in_buffer;
#line 290
    p_stream->m_bytes_in_buffer = (OPJ_SIZE_T )0;
    }
#line 291
    if (l_read_nb_bytes) {
#line 291
      tmp = l_read_nb_bytes;
    } else {
#line 291
      tmp = (OPJ_SIZE_T )-1;
    }
#line 291
    return (tmp);
  }
#line 295
  if (p_stream->m_bytes_in_buffer) {
    {
#line 296
    l_read_nb_bytes += p_stream->m_bytes_in_buffer;
#line 297
    memcpy((void *)p_buffer, (void const   *)p_stream->m_current_data, p_stream->m_bytes_in_buffer);
#line 298
    p_stream->m_current_data = p_stream->m_stored_data;
#line 299
    p_buffer += p_stream->m_bytes_in_buffer;
#line 300
    p_size -= p_stream->m_bytes_in_buffer;
#line 301
    p_stream->m_byte_offset += (OPJ_OFF_T )p_stream->m_bytes_in_buffer;
#line 302
    p_stream->m_bytes_in_buffer = (OPJ_SIZE_T )0;
    }
  } else {
#line 308
    p_stream->m_current_data = p_stream->m_stored_data;
  }
  {
#line 311
  while (1) {
    while_continue: /* CIL Label */ ;

#line 313
    if (p_size < p_stream->m_buffer_size) {
      {
#line 315
      p_stream->m_bytes_in_buffer = (*(p_stream->m_read_fn))((void *)p_stream->m_stored_data,
                                                             p_stream->m_buffer_size,
                                                             p_stream->m_user_data);
      }
#line 317
      if (p_stream->m_bytes_in_buffer == 0xffffffffffffffffUL) {
        {
#line 319
        opj_event_msg(p_event_mgr, 4, "Stream reached its end !\n");
#line 321
        p_stream->m_bytes_in_buffer = (OPJ_SIZE_T )0;
#line 322
        p_stream->m_status = (opj_stream_flag )((int )p_stream->m_status | 4);
        }
#line 324
        if (l_read_nb_bytes) {
#line 324
          tmp___0 = l_read_nb_bytes;
        } else {
#line 324
          tmp___0 = (OPJ_SIZE_T )-1;
        }
#line 324
        return (tmp___0);
      } else
#line 326
      if (p_stream->m_bytes_in_buffer < p_size) {
        {
#line 328
        l_read_nb_bytes += p_stream->m_bytes_in_buffer;
#line 329
        memcpy((void *)p_buffer, (void const   *)p_stream->m_current_data, p_stream->m_bytes_in_buffer);
#line 330
        p_stream->m_current_data = p_stream->m_stored_data;
#line 331
        p_buffer += p_stream->m_bytes_in_buffer;
#line 332
        p_size -= p_stream->m_bytes_in_buffer;
#line 333
        p_stream->m_byte_offset += (OPJ_OFF_T )p_stream->m_bytes_in_buffer;
#line 334
        p_stream->m_bytes_in_buffer = (OPJ_SIZE_T )0;
        }
      } else {
        {
#line 337
        l_read_nb_bytes += p_size;
#line 338
        memcpy((void *)p_buffer, (void const   *)p_stream->m_current_data, p_size);
#line 339
        p_stream->m_current_data += p_size;
#line 340
        p_stream->m_bytes_in_buffer -= p_size;
#line 341
        p_stream->m_byte_offset += (OPJ_OFF_T )p_size;
        }
#line 342
        return (l_read_nb_bytes);
      }
    } else {
      {
#line 347
      p_stream->m_bytes_in_buffer = (*(p_stream->m_read_fn))((void *)p_buffer, p_size,
                                                             p_stream->m_user_data);
      }
#line 349
      if (p_stream->m_bytes_in_buffer == 0xffffffffffffffffUL) {
        {
#line 351
        opj_event_msg(p_event_mgr, 4, "Stream reached its end !\n");
#line 353
        p_stream->m_bytes_in_buffer = (OPJ_SIZE_T )0;
#line 354
        p_stream->m_status = (opj_stream_flag )((int )p_stream->m_status | 4);
        }
#line 356
        if (l_read_nb_bytes) {
#line 356
          tmp___1 = l_read_nb_bytes;
        } else {
#line 356
          tmp___1 = (OPJ_SIZE_T )-1;
        }
#line 356
        return (tmp___1);
      } else
#line 358
      if (p_stream->m_bytes_in_buffer < p_size) {
#line 360
        l_read_nb_bytes += p_stream->m_bytes_in_buffer;
#line 361
        p_stream->m_current_data = p_stream->m_stored_data;
#line 362
        p_buffer += p_stream->m_bytes_in_buffer;
#line 363
        p_size -= p_stream->m_bytes_in_buffer;
#line 364
        p_stream->m_byte_offset += (OPJ_OFF_T )p_stream->m_bytes_in_buffer;
#line 365
        p_stream->m_bytes_in_buffer = (OPJ_SIZE_T )0;
      } else {
#line 369
        l_read_nb_bytes += p_stream->m_bytes_in_buffer;
#line 370
        p_stream->m_byte_offset += (OPJ_OFF_T )p_stream->m_bytes_in_buffer;
#line 371
        p_stream->m_current_data = p_stream->m_stored_data;
#line 372
        p_stream->m_bytes_in_buffer = (OPJ_SIZE_T )0;
#line 373
        return (l_read_nb_bytes);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 380
  return (0UL);
}
}
#line 379 "/root/patron/new_22/src/lib/openjp2/cio.c"
OPJ_SIZE_T opj_stream_write_data(opj_stream_private_t *p_stream , OPJ_BYTE *p_buffer ,
                                 OPJ_SIZE_T p_size , opj_event_mgr_t *p_event_mgr ) 
{ 
  OPJ_SIZE_T l_remaining_bytes ;
  OPJ_SIZE_T l_write_nb_bytes ;
  OPJ_BOOL __cil_tmp7 ;

  {
#line 384
  l_remaining_bytes = (OPJ_SIZE_T )0;
#line 385
  l_write_nb_bytes = (OPJ_SIZE_T )0;
#line 387
  if ((int )p_stream->m_status & 8) {
#line 388
    return ((OPJ_SIZE_T )-1);
  }
  {
#line 391
  while (1) {
    while_continue: /* CIL Label */ ;
#line 392
    l_remaining_bytes = p_stream->m_buffer_size - p_stream->m_bytes_in_buffer;
#line 395
    if (l_remaining_bytes >= p_size) {
      {
#line 396
      memcpy((void *)p_stream->m_current_data, (void const   *)p_buffer, p_size);
#line 398
      p_stream->m_current_data += p_size;
#line 399
      p_stream->m_bytes_in_buffer += p_size;
#line 400
      l_write_nb_bytes += p_size;
#line 401
      p_stream->m_byte_offset += (OPJ_OFF_T )p_size;
      }
#line 403
      return (l_write_nb_bytes);
    }
#line 407
    if (l_remaining_bytes) {
      {
#line 408
      l_write_nb_bytes += l_remaining_bytes;
#line 410
      memcpy((void *)p_stream->m_current_data, (void const   *)p_buffer, l_remaining_bytes);
#line 412
      p_stream->m_current_data = p_stream->m_stored_data;
#line 414
      p_buffer += l_remaining_bytes;
#line 415
      p_size -= l_remaining_bytes;
#line 416
      p_stream->m_bytes_in_buffer += l_remaining_bytes;
#line 417
      p_stream->m_byte_offset += (OPJ_OFF_T )l_remaining_bytes;
      }
    }
    {
#line 420
    __cil_tmp7 = opj_stream_flush(p_stream, p_event_mgr);
    }
#line 420
    if (! __cil_tmp7) {
#line 421
      return ((OPJ_SIZE_T )-1);
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 427
  return (0UL);
}
}
#line 427 "/root/patron/new_22/src/lib/openjp2/cio.c"
OPJ_BOOL opj_stream_flush(opj_stream_private_t *p_stream , opj_event_mgr_t *p_event_mgr ) 
{ 
  OPJ_SIZE_T l_current_write_nb_bytes ;

  {
#line 430
  l_current_write_nb_bytes = (OPJ_SIZE_T )0;
#line 432
  p_stream->m_current_data = p_stream->m_stored_data;
  {
#line 434
  while (1) {
    while_continue: /* CIL Label */ ;

#line 434
    if (! p_stream->m_bytes_in_buffer) {
#line 434
      goto while_break;
    }
    {
#line 436
    l_current_write_nb_bytes = (*(p_stream->m_write_fn))((void *)p_stream->m_current_data,
                                                         p_stream->m_bytes_in_buffer,
                                                         p_stream->m_user_data);
    }
#line 440
    if (l_current_write_nb_bytes == 0xffffffffffffffffUL) {
      {
#line 441
      p_stream->m_status = (opj_stream_flag )((int )p_stream->m_status | 8);
#line 442
      opj_event_msg(p_event_mgr, 4, "Error on writing stream!\nDk\212\202U");
      }
#line 444
      return (0);
    }
#line 447
    p_stream->m_current_data += l_current_write_nb_bytes;
#line 448
    p_stream->m_bytes_in_buffer -= l_current_write_nb_bytes;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 451
  p_stream->m_current_data = p_stream->m_stored_data;
#line 453
  return (1);
}
}
#line 456 "/root/patron/new_22/src/lib/openjp2/cio.c"
OPJ_OFF_T opj_stream_read_skip(opj_stream_private_t *p_stream , OPJ_OFF_T p_size ,
                               opj_event_mgr_t *p_event_mgr ) 
{ 
  OPJ_OFF_T l_skip_nb_bytes ;
  OPJ_OFF_T l_current_skip_nb_bytes ;
  OPJ_OFF_T tmp___0 ;
  OPJ_OFF_T tmp___1 ;

  {
#line 458
  l_skip_nb_bytes = (OPJ_OFF_T )0;
#line 459
  l_current_skip_nb_bytes = (OPJ_OFF_T )0;
#line 463
  if (p_stream->m_bytes_in_buffer >= (OPJ_SIZE_T )p_size) {
#line 464
    p_stream->m_current_data += p_size;
#line 467
    p_stream->m_bytes_in_buffer -= (OPJ_SIZE_T )p_size;
#line 468
    l_skip_nb_bytes += p_size;
#line 469
    p_stream->m_byte_offset += l_skip_nb_bytes;
#line 470
    return (l_skip_nb_bytes);
  }
#line 474
  if ((int )p_stream->m_status & 4) {
#line 475
    l_skip_nb_bytes += (OPJ_OFF_T )p_stream->m_bytes_in_buffer;
#line 476
    p_stream->m_current_data += p_stream->m_bytes_in_buffer;
#line 477
    p_stream->m_bytes_in_buffer = (OPJ_SIZE_T )0;
#line 478
    p_stream->m_byte_offset += l_skip_nb_bytes;
#line 479
    if (l_skip_nb_bytes) {
#line 479
      tmp___0 = l_skip_nb_bytes;
    } else {
#line 479
      tmp___0 = (OPJ_OFF_T )-1;
    }
#line 479
    return (tmp___0);
  }
#line 483
  if (p_stream->m_bytes_in_buffer) {
#line 484
    l_skip_nb_bytes += (OPJ_OFF_T )p_stream->m_bytes_in_buffer;
#line 485
    p_stream->m_current_data = p_stream->m_stored_data;
#line 486
    p_size -= (OPJ_OFF_T )p_stream->m_bytes_in_buffer;
#line 487
    p_stream->m_bytes_in_buffer = (OPJ_SIZE_T )0;
  }
  {
#line 490
  while (1) {
    while_continue: /* CIL Label */ ;

#line 490
    if (! (p_size > 0L)) {
#line 490
      goto while_break;
    }
    {
#line 492
    l_current_skip_nb_bytes = (*(p_stream->m_skip_fn))(p_size, p_stream->m_user_data);
    }
#line 493
    if (l_current_skip_nb_bytes == -1L) {
      {
#line 494
      opj_event_msg(p_event_mgr, 4, "Stream reached its end !\n");
#line 496
      p_stream->m_status = (opj_stream_flag )((int )p_stream->m_status | 4);
#line 497
      p_stream->m_byte_offset += l_skip_nb_bytes;
      }
#line 499
      if (l_skip_nb_bytes) {
#line 499
        tmp___1 = l_skip_nb_bytes;
      } else {
#line 499
        tmp___1 = (OPJ_OFF_T )-1;
      }
#line 499
      return (tmp___1);
    }
#line 501
    p_size -= l_current_skip_nb_bytes;
#line 502
    l_skip_nb_bytes += l_current_skip_nb_bytes;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 505
  p_stream->m_byte_offset += l_skip_nb_bytes;
#line 507
  return (l_skip_nb_bytes);
}
}
#line 510 "/root/patron/new_22/src/lib/openjp2/cio.c"
OPJ_OFF_T opj_stream_write_skip(opj_stream_private_t *p_stream , OPJ_OFF_T p_size ,
                                opj_event_mgr_t *p_event_mgr ) 
{ 
  OPJ_BOOL l_is_written ;
  OPJ_OFF_T l_current_skip_nb_bytes ;
  OPJ_OFF_T l_skip_nb_bytes ;
  OPJ_OFF_T tmp ;

  {
#line 512
  l_is_written = 0;
#line 513
  l_current_skip_nb_bytes = (OPJ_OFF_T )0;
#line 514
  l_skip_nb_bytes = (OPJ_OFF_T )0;
#line 516
  if ((int )p_stream->m_status & 8) {
#line 517
    return ((OPJ_OFF_T )-1);
  }
  {
#line 521
  l_is_written = opj_stream_flush(p_stream, p_event_mgr);
  }
#line 522
  if (! l_is_written) {
#line 523
    p_stream->m_status = (opj_stream_flag )((int )p_stream->m_status | 8);
#line 524
    p_stream->m_bytes_in_buffer = (OPJ_SIZE_T )0;
#line 525
    p_stream->m_current_data = p_stream->m_current_data;
#line 526
    return ((OPJ_OFF_T )-1);
  }
  {
#line 530
  while (1) {
    while_continue: /* CIL Label */ ;

#line 530
    if (! (p_size > 0L)) {
#line 530
      goto while_break;
    }
    {
#line 532
    l_current_skip_nb_bytes = (*(p_stream->m_skip_fn))(p_size, p_stream->m_user_data);
    }
#line 534
    if (l_current_skip_nb_bytes == -1L) {
      {
#line 535
      opj_event_msg(p_event_mgr, 4, "Stream error!\n");
#line 537
      p_stream->m_status = (opj_stream_flag )((int )p_stream->m_status | 8);
#line 538
      p_stream->m_byte_offset += l_skip_nb_bytes;
      }
#line 540
      if (l_skip_nb_bytes) {
#line 540
        tmp = l_skip_nb_bytes;
      } else {
#line 540
        tmp = (OPJ_OFF_T )-1;
      }
#line 540
      return (tmp);
    }
#line 542
    p_size -= l_current_skip_nb_bytes;
#line 543
    l_skip_nb_bytes += l_current_skip_nb_bytes;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 546
  p_stream->m_byte_offset += l_skip_nb_bytes;
#line 548
  return (l_skip_nb_bytes);
}
}
#line 551 "/root/patron/new_22/src/lib/openjp2/cio.c"
OPJ_OFF_T opj_stream_tell(opj_stream_private_t *p_stream ) 
{ 


  {
#line 553
  return (p_stream->m_byte_offset);
}
}
#line 556 "/root/patron/new_22/src/lib/openjp2/cio.c"
OPJ_OFF_T opj_stream_get_number_byte_left(opj_stream_private_t *p_stream ) 
{ 
  OPJ_OFF_T tmp___1 ;

  {
#line 560
  if (p_stream->m_user_data_length) {
#line 560
    tmp___1 = (OPJ_OFF_T )p_stream->m_user_data_length - p_stream->m_byte_offset;
  } else {
#line 560
    tmp___1 = 0L;
  }
#line 560
  return (tmp___1);
}
}
#line 565 "/root/patron/new_22/src/lib/openjp2/cio.c"
OPJ_OFF_T opj_stream_skip(opj_stream_private_t *p_stream , OPJ_OFF_T p_size , opj_event_mgr_t *p_event_mgr ) 
{ 
  OPJ_OFF_T __cil_tmp5 ;

  {
  {
#line 568
  __cil_tmp5 = (*(p_stream->m_opj_skip))(p_stream, p_size, p_event_mgr);
  }
#line 568
  return (__cil_tmp5);
}
}
#line 571 "/root/patron/new_22/src/lib/openjp2/cio.c"
OPJ_BOOL opj_stream_read_seek(opj_stream_private_t *p_stream , OPJ_OFF_T p_size ,
                              opj_event_mgr_t *p_event_mgr ) 
{ 
  OPJ_BOOL __cil_tmp4 ;

  {
  {
#line 574
  p_stream->m_current_data = p_stream->m_stored_data;
#line 575
  p_stream->m_bytes_in_buffer = (OPJ_SIZE_T )0;
#line 577
  __cil_tmp4 = (*(p_stream->m_seek_fn))(p_size, p_stream->m_user_data);
  }
#line 577
  if (! __cil_tmp4) {
#line 578
    p_stream->m_status = (opj_stream_flag )((int )p_stream->m_status | 4);
#line 579
    return (0);
  } else {
#line 583
    p_stream->m_status = (opj_stream_flag )((int )p_stream->m_status & -5);
#line 584
    p_stream->m_byte_offset = p_size;
  }
#line 588
  return (1);
}
}
#line 591 "/root/patron/new_22/src/lib/openjp2/cio.c"
OPJ_BOOL opj_stream_write_seek(opj_stream_private_t *p_stream , OPJ_OFF_T p_size ,
                               opj_event_mgr_t *p_event_mgr ) 
{ 
  OPJ_BOOL __cil_tmp4 ;
  OPJ_BOOL __cil_tmp5 ;

  {
  {
#line 593
  __cil_tmp4 = opj_stream_flush(p_stream, p_event_mgr);
  }
#line 593
  if (! __cil_tmp4) {
#line 594
    p_stream->m_status = (opj_stream_flag )((int )p_stream->m_status | 8);
#line 595
    return (0);
  }
  {
#line 598
  p_stream->m_current_data = p_stream->m_stored_data;
#line 599
  p_stream->m_bytes_in_buffer = (OPJ_SIZE_T )0;
#line 601
  __cil_tmp5 = (*(p_stream->m_seek_fn))(p_size, p_stream->m_user_data);
  }
#line 601
  if (! __cil_tmp5) {
#line 602
    p_stream->m_status = (opj_stream_flag )((int )p_stream->m_status | 8);
#line 603
    return (0);
  } else {
#line 606
    p_stream->m_byte_offset = p_size;
  }
#line 609
  return (1);
}
}
#line 612 "/root/patron/new_22/src/lib/openjp2/cio.c"
OPJ_BOOL opj_stream_seek(opj_stream_private_t *p_stream , OPJ_OFF_T p_size , struct opj_event_mgr *p_event_mgr ) 
{ 
  OPJ_BOOL __cil_tmp5 ;

  {
  {
#line 615
  __cil_tmp5 = (*(p_stream->m_opj_seek))(p_stream, p_size, p_event_mgr);
  }
#line 615
  return (__cil_tmp5);
}
}
#line 618 "/root/patron/new_22/src/lib/openjp2/cio.c"
OPJ_BOOL opj_stream_has_seek(opj_stream_private_t *p_stream ) 
{ 


  {
#line 620
  return ((unsigned long )p_stream->m_seek_fn != (unsigned long )(& opj_stream_default_seek));
}
}
#line 623 "/root/patron/new_22/src/lib/openjp2/cio.c"
OPJ_SIZE_T opj_stream_default_read(void *p_buffer , OPJ_SIZE_T p_nb_bytes , void *p_user_data ) 
{ 


  {
#line 628
  return ((OPJ_SIZE_T )-1);
}
}
#line 631 "/root/patron/new_22/src/lib/openjp2/cio.c"
OPJ_SIZE_T opj_stream_default_write(void *p_buffer , OPJ_SIZE_T p_nb_bytes , void *p_user_data ) 
{ 


  {
#line 636
  return ((OPJ_SIZE_T )-1);
}
}
#line 639 "/root/patron/new_22/src/lib/openjp2/cio.c"
OPJ_OFF_T opj_stream_default_skip(OPJ_OFF_T p_nb_bytes , void *p_user_data ) 
{ 


  {
#line 643
  return ((OPJ_OFF_T )-1);
}
}
#line 646 "/root/patron/new_22/src/lib/openjp2/cio.c"
OPJ_BOOL opj_stream_default_seek(OPJ_OFF_T p_nb_bytes , void *p_user_data ) 
{ 


  {
#line 650
  return (0);
}
}
#line 45 "/root/patron/new_22/src/lib/openjp2/bio.c"
void opj_bio_putbit(opj_bio_t *bio , OPJ_UINT32 b ) ;
#line 51
OPJ_UINT32 opj_bio_getbit(opj_bio_t *bio ) ;
#line 57
OPJ_BOOL opj_bio_byteout(opj_bio_t *bio ) ;
#line 63
OPJ_BOOL opj_bio_bytein(opj_bio_t *bio ) ;
#line 75 "/root/patron/new_22/src/lib/openjp2/bio.c"
OPJ_BOOL opj_bio_byteout(opj_bio_t *bio ) 
{ 
  int tmp ;
  OPJ_BYTE *__cil_tmp3 ;

  {
#line 76
  bio->buf = (bio->buf << 8) & 65535U;
#line 77
  if (bio->buf == 65280U) {
#line 77
    tmp = 7;
  } else {
#line 77
    tmp = 8;
  }
#line 77
  bio->ct = (OPJ_UINT32 )tmp;
#line 78
  if ((unsigned long )bio->bp >= (unsigned long )bio->end) {
#line 79
    return (0);
  }
#line 81
  __cil_tmp3 = bio->bp;
#line 81
  (bio->bp) ++;
#line 81
  *__cil_tmp3 = (OPJ_BYTE )(bio->buf >> 8);
#line 82
  return (1);
}
}
#line 85 "/root/patron/new_22/src/lib/openjp2/bio.c"
OPJ_BOOL opj_bio_bytein(opj_bio_t *bio ) 
{ 
  int tmp ;
  OPJ_BYTE *__cil_tmp3 ;

  {
#line 86
  bio->buf = (bio->buf << 8) & 65535U;
#line 87
  if (bio->buf == 65280U) {
#line 87
    tmp = 7;
  } else {
#line 87
    tmp = 8;
  }
#line 87
  bio->ct = (OPJ_UINT32 )tmp;
#line 88
  if ((unsigned long )bio->bp >= (unsigned long )bio->end) {
#line 89
    return (0);
  }
#line 91
  __cil_tmp3 = bio->bp;
#line 91
  (bio->bp) ++;
#line 91
  bio->buf |= (unsigned int )*__cil_tmp3;
#line 92
  return (1);
}
}
#line 95 "/root/patron/new_22/src/lib/openjp2/bio.c"
void opj_bio_putbit(opj_bio_t *bio , OPJ_UINT32 b ) 
{ 
  OPJ_UINT32 __cil_tmp3 ;

  {
#line 96
  if (bio->ct == 0U) {
    {
#line 97
    opj_bio_byteout(bio);
    }
  }
#line 99
  __cil_tmp3 = bio->ct;
#line 99
  (bio->ct) --;
#line 100
  bio->buf |= b << bio->ct;
#line 101
  return;
}
}
#line 103 "/root/patron/new_22/src/lib/openjp2/bio.c"
OPJ_UINT32 opj_bio_getbit(opj_bio_t *bio ) 
{ 
  OPJ_UINT32 __cil_tmp2 ;

  {
#line 104
  if (bio->ct == 0U) {
    {
#line 105
    opj_bio_bytein(bio);
    }
  }
#line 107
  __cil_tmp2 = bio->ct;
#line 107
  (bio->ct) --;
#line 108
  return ((bio->buf >> bio->ct) & 1U);
}
}
#line 117 "/root/patron/new_22/src/lib/openjp2/bio.c"
opj_bio_t *opj_bio_create(void) 
{ 
  opj_bio_t *bio ;
  void *__cil_tmp2 ;

  {
  {
#line 118
  __cil_tmp2 = malloc(sizeof(opj_bio_t ));
#line 118
  bio = (opj_bio_t *)__cil_tmp2;
  }
#line 119
  return (bio);
}
}
#line 122 "/root/patron/new_22/src/lib/openjp2/bio.c"
void opj_bio_destroy(opj_bio_t *bio ) 
{ 


  {
#line 123
  if (bio) {
    {
#line 124
    free((void *)bio);
    }
  }
#line 127
  return;
}
}
#line 128 "/root/patron/new_22/src/lib/openjp2/bio.c"
ptrdiff_t opj_bio_numbytes(opj_bio_t *bio ) 
{ 


  {
#line 129
  return (bio->bp - bio->start);
}
}
#line 132 "/root/patron/new_22/src/lib/openjp2/bio.c"
void opj_bio_init_enc(opj_bio_t *bio , OPJ_BYTE *bp , OPJ_UINT32 len ) 
{ 


  {
#line 133
  bio->start = bp;
#line 134
  bio->end = bp + len;
#line 135
  bio->bp = bp;
#line 136
  bio->buf = (OPJ_UINT32 )0;
#line 137
  bio->ct = (OPJ_UINT32 )8;
#line 138
  return;
}
}
#line 140 "/root/patron/new_22/src/lib/openjp2/bio.c"
void opj_bio_init_dec(opj_bio_t *bio , OPJ_BYTE *bp , OPJ_UINT32 len ) 
{ 


  {
#line 141
  bio->start = bp;
#line 142
  bio->end = bp + len;
#line 143
  bio->bp = bp;
#line 144
  bio->buf = (OPJ_UINT32 )0;
#line 145
  bio->ct = (OPJ_UINT32 )0;
#line 146
  return;
}
}
#line 148 "/root/patron/new_22/src/lib/openjp2/bio.c"
void opj_bio_write(opj_bio_t *bio , OPJ_UINT32 v , OPJ_UINT32 n ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 __cil_tmp5 ;

  {
#line 150
  i = n - 1U;
  {
#line 150
  while (1) {
    while_continue: /* CIL Label */ ;

#line 150
    if (! (i < n)) {
#line 150
      goto while_break;
    }
    {
#line 151
    opj_bio_putbit(bio, (v >> i) & 1U);
#line 150
    __cil_tmp5 = i;
#line 150
    i --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 154
  return;
}
}
#line 155 "/root/patron/new_22/src/lib/openjp2/bio.c"
OPJ_UINT32 opj_bio_read(opj_bio_t *bio , OPJ_UINT32 n ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 v ;
  OPJ_UINT32 __cil_tmp5 ;
  OPJ_UINT32 __cil_tmp6 ;

  {
#line 158
  v = (OPJ_UINT32 )0;
#line 159
  i = n - 1U;
  {
#line 159
  while (1) {
    while_continue: /* CIL Label */ ;

#line 159
    if (! (i < n)) {
#line 159
      goto while_break;
    }
    {
#line 160
    __cil_tmp5 = opj_bio_getbit(bio);
#line 160
    v += __cil_tmp5 << i;
#line 159
    __cil_tmp6 = i;
#line 159
    i --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 162
  return (v);
}
}
#line 165 "/root/patron/new_22/src/lib/openjp2/bio.c"
OPJ_BOOL opj_bio_flush(opj_bio_t *bio ) 
{ 
  OPJ_BOOL __cil_tmp2 ;
  OPJ_BOOL __cil_tmp3 ;

  {
  {
#line 166
  bio->ct = (OPJ_UINT32 )0;
#line 167
  __cil_tmp2 = opj_bio_byteout(bio);
  }
#line 167
  if (! __cil_tmp2) {
#line 168
    return (0);
  }
#line 170
  if (bio->ct == 7U) {
    {
#line 171
    bio->ct = (OPJ_UINT32 )0;
#line 172
    __cil_tmp3 = opj_bio_byteout(bio);
    }
#line 172
    if (! __cil_tmp3) {
#line 173
      return (0);
    }
  }
#line 176
  return (1);
}
}
#line 179 "/root/patron/new_22/src/lib/openjp2/bio.c"
OPJ_BOOL opj_bio_inalign(opj_bio_t *bio ) 
{ 
  OPJ_BOOL __cil_tmp2 ;

  {
#line 180
  bio->ct = (OPJ_UINT32 )0;
#line 181
  if ((bio->buf & 255U) == 255U) {
    {
#line 182
    __cil_tmp2 = opj_bio_bytein(bio);
    }
#line 182
    if (! __cil_tmp2) {
#line 183
      return (0);
    }
#line 185
    bio->ct = (OPJ_UINT32 )0;
  }
#line 187
  return (1);
}
}
#line 42 "/root/patron/new_22/src/bin/jp2/index.h"
int write_index_file(opj_codestream_info_t *cstr_info , char *index___0 ) ;
#line 44 "/root/patron/new_22/src/bin/jp2/index.c"
int write_index_file(opj_codestream_info_t *cstr_info , char *index___0 ) 
{ 
  int tileno ;
  int compno ;
  int layno ;
  int resno ;
  int precno ;
  int pack_nb ;
  int x ;
  int y ;
  FILE *stream ;
  double total_disto ;
  int tilepartno ;
  char disto_on ;
  char numpix_on ;
  int __cil_tmp17 ;
  OPJ_OFF_T start_pos ;
  OPJ_OFF_T end_ph_pos ;
  OPJ_OFF_T end_pos ;
  double disto ;
  int max_numdecompos ;
  int prec_max ;
  int prec_max___0 ;
  int numprec ;
  int x0 ;
  double __cil_tmp40 ;
  int y0___10 ;
  double __cil_tmp42 ;
  int x1 ;
  int y1___11 ;
  int pcnx ;
  int pcx ;
  double __cil_tmp47 ;
  int pcy ;
  double __cil_tmp49 ;
  int precno_x ;
  double __cil_tmp51 ;
  int precno_y ;
  double __cil_tmp53 ;
  int x0___0 ;
  double __cil_tmp62 ;
  int y0___12 ;
  double __cil_tmp64 ;
  int x1___0 ;
  int y1___13 ;
  int max_numprec ;
  int numprec___0 ;
  int numprec___1 ;
  int pcnx___0 ;
  int pcx___0 ;
  double __cil_tmp73 ;
  int pcy___0 ;
  double __cil_tmp75 ;
  int precno_x___0 ;
  double __cil_tmp77 ;
  int precno_y___0 ;
  double __cil_tmp79 ;
  int max_numprec___0 ;
  int numprec___2 ;
  int x0___1 ;
  double __cil_tmp91 ;
  int y0___14 ;
  double __cil_tmp93 ;
  int x1___1 ;
  int y1___15 ;
  int numprec___3 ;
  int pcnx___1 ;
  int pcx___1 ;
  double __cil_tmp99 ;
  int pcy___1 ;
  double __cil_tmp101 ;
  int precno_x___1 ;
  double __cil_tmp103 ;
  int precno_y___1 ;
  double __cil_tmp105 ;

  {
#line 46
  stream = (FILE *)((void *)0);
#line 47
  total_disto = (double )0;
#line 58
  if (! cstr_info) {
#line 59
    return (1);
  }
  {
#line 61
  stream = fopen((char const   *)index___0, "w");
  }
#line 62
  if (! stream) {
    {
#line 63
    fprintf(stderr, "failed to open index file [%s] for writing\n", index___0);
    }
#line 64
    return (1);
  }
#line 67
  if ((cstr_info->tile + 0)->distotile) {
#line 68
    disto_on = (char)1;
  } else {
#line 70
    disto_on = (char)0;
  }
#line 72
  if ((cstr_info->tile + 0)->numpix) {
#line 73
    numpix_on = (char)1;
  } else {
#line 75
    numpix_on = (char)0;
  }
  {
#line 77
  fprintf(stream, "%d %d\n", cstr_info->image_w, cstr_info->image_h);
#line 78
  fprintf(stream, "%d\n", (int )cstr_info->prog);
#line 79
  fprintf(stream, "%d %d\n", cstr_info->tile_x, cstr_info->tile_y);
#line 80
  fprintf(stream, "%d %d\n", cstr_info->tw, cstr_info->th);
#line 81
  fprintf(stream, "%d\n", cstr_info->numcomps);
#line 82
  fprintf(stream, "%d\n", cstr_info->numlayers);
#line 83
  fprintf(stream, "%d\n", *(cstr_info->numdecompos + 0));
#line 85
  resno = *(cstr_info->numdecompos + 0);
  }
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;

#line 85
    if (! (resno >= 0)) {
#line 85
      goto while_break;
    }
    {
#line 86
    fprintf(stream, "[%d,%d] \251", 1 << (cstr_info->tile + 0)->pdx[resno], 1 << (cstr_info->tile + 0)->pdx[resno]);
#line 85
    __cil_tmp17 = resno;
#line 85
    resno --;
    }
  }
  while_break___33: /* CIL Label */ ;
  }
  while_break: 
  {
#line 90
  fprintf(stream, "\n");
#line 92
  fprintf(stream, "%d\n", cstr_info->main_head_start);
#line 94
  fprintf(stream, "%d\n", cstr_info->main_head_end);
#line 95
  fprintf(stream, "%d\n", cstr_info->codestream_size);
#line 97
  fprintf(stream, "\nINFO ON TILES\n");
#line 98
  fprintf(stream, "tileno start_pos  end_hd  end_tile   nbparts");
  }
#line 99
  if (disto_on) {
    {
#line 100
    fprintf(stream, "         disto");
    }
  }
#line 101
  if (numpix_on) {
    {
#line 102
    fprintf(stream, "     nbpix");
    }
  }
#line 103
  if ((int )disto_on) {
#line 103
    if ((int )numpix_on) {
      {
#line 104
      fprintf(stream, "  disto/nbpix");
      }
    }
  }
  {
#line 105
  fprintf(stream, "\n");
#line 107
  tileno = 0;
  }
  {
#line 107
  while (1) {
    while_continue___29: /* CIL Label */ ;

#line 107
    if (! (tileno < cstr_info->tw * cstr_info->th)) {
#line 107
      goto while_break___0;
    }
    {
#line 108
    fprintf(stream, "%4d %9d %9d %9d %9d", (cstr_info->tile + tileno)->tileno, (cstr_info->tile + tileno)->start_pos,
            (cstr_info->tile + tileno)->end_header, (cstr_info->tile + tileno)->end_pos,
            (cstr_info->tile + tileno)->num_tps);
    }
#line 114
    if (disto_on) {
      {
#line 115
      fprintf(stream, " %9e", (cstr_info->tile + tileno)->distotile);
      }
    }
#line 116
    if (numpix_on) {
      {
#line 117
      fprintf(stream, " %9d", (cstr_info->tile + tileno)->numpix);
      }
    }
#line 118
    if ((int )disto_on) {
#line 118
      if ((int )numpix_on) {
        {
#line 119
        fprintf(stream, " %9e", (cstr_info->tile + tileno)->distotile / (double )(cstr_info->tile + tileno)->numpix);
        }
      }
    }
    {
#line 120
    fprintf(stream, "\n");
#line 107
    tileno ++;
    }
  }
  while_break___34: /* CIL Label */ ;
  }
  while_break___0: 
#line 123
  tileno = 0;
  {
#line 123
  while (1) {
    while_continue___30: /* CIL Label */ ;

#line 123
    if (! (tileno < cstr_info->tw * cstr_info->th)) {
#line 123
      goto while_break___1;
    }
#line 125
    disto = (double )0;
#line 126
    max_numdecompos = 0;
#line 127
    pack_nb = 0;
#line 129
    compno = 0;
    {
#line 129
    while (1) {
      while_continue___31: /* CIL Label */ ;

#line 129
      if (! (compno < cstr_info->numcomps)) {
#line 129
        goto while_break___2;
      }
#line 130
      if (max_numdecompos < *(cstr_info->numdecompos + compno)) {
#line 131
        max_numdecompos = *(cstr_info->numdecompos + compno);
      }
#line 129
      compno ++;
    }
    while_break___36: /* CIL Label */ ;
    }
    while_break___2: 
    {
#line 134
    fprintf(stream, "\nTILE %d DETAILS\n", tileno);
#line 135
    fprintf(stream, "part_nb tileno  start_pack num_packs  start_pos end_tph_pos   end_pos\n");
#line 136
    tilepartno = 0;
    }
    {
#line 136
    while (1) {
      while_continue___32: /* CIL Label */ ;

#line 136
      if (! (tilepartno < (cstr_info->tile + tileno)->num_tps)) {
#line 136
        goto while_break___3;
      }
      {
#line 137
      fprintf(stream, "%4d %9d   %9d %9d  %9d %11d %9d\n\230\001", tilepartno, tileno,
              ((cstr_info->tile + tileno)->tp + tilepartno)->tp_start_pack, ((cstr_info->tile + tileno)->tp + tilepartno)->tp_numpacks,
              ((cstr_info->tile + tileno)->tp + tilepartno)->tp_start_pos, ((cstr_info->tile + tileno)->tp + tilepartno)->tp_end_header,
              ((cstr_info->tile + tileno)->tp + tilepartno)->tp_end_pos);
#line 136
      tilepartno ++;
      }
    }
    while_break___37: /* CIL Label */ ;
    }
    while_break___3: ;
#line 146
    if ((int )cstr_info->prog == 0) {
      {
#line 147
      fprintf(stream, "LRCP\npack_nb tileno layno resno compno precno start_pos end_ph_pos end_pos");
      }
#line 148
      if (disto_on) {
        {
#line 149
        fprintf(stream, " disto");
        }
      }
      {
#line 150
      fprintf(stream, "\n");
#line 152
      layno = 0;
      }
      {
#line 152
      while (1) {
        while_continue___33: /* CIL Label */ ;

#line 152
        if (! (layno < cstr_info->numlayers)) {
#line 152
          goto while_break___4;
        }
#line 153
        resno = 0;
        {
#line 153
        while (1) {
          while_continue___34: /* CIL Label */ ;

#line 153
          if (! (resno < max_numdecompos + 1)) {
#line 153
            goto while_break___5;
          }
#line 154
          compno = 0;
          {
#line 154
          while (1) {
            while_continue___35: /* CIL Label */ ;

#line 154
            if (! (compno < cstr_info->numcomps)) {
#line 154
              goto while_break___6;
            }
#line 156
            if (resno > *(cstr_info->numdecompos + compno)) {
#line 157
              goto while_break___6;
            }
#line 158
            prec_max = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 159
            precno = 0;
            {
#line 159
            while (1) {
              while_continue___36: /* CIL Label */ ;

#line 159
              if (! (precno < prec_max)) {
#line 159
                goto while_break___7;
              }
              {
#line 160
              start_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->start_pos;
#line 161
              end_ph_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_ph_pos;
#line 162
              end_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_pos;
#line 163
              disto = ((cstr_info->tile + tileno)->packet + pack_nb)->disto;
#line 164
              fprintf(stream, "%4d %6d %7d %5d %6d  %6d    %6ld     %6ld %7ld", pack_nb,
                      tileno, layno, resno, compno, precno, start_pos, end_ph_pos,
                      end_pos);
              }
#line 166
              if (disto_on) {
                {
#line 167
                fprintf(stream, " %8e", disto);
                }
              }
              {
#line 168
              fprintf(stream, "\n");
#line 169
              total_disto += disto;
#line 170
              pack_nb ++;
#line 159
              precno ++;
              }
            }
            while_break___41: /* CIL Label */ ;
            }
            while_break___7: 
#line 154
            compno ++;
          }
          while_break___40: /* CIL Label */ ;
          }
          while_break___6: 
#line 153
          resno ++;
        }
        while_break___39: /* CIL Label */ ;
        }
        while_break___5: 
#line 152
        layno ++;
      }
      while_break___38: /* CIL Label */ ;
      }
      while_break___4: ;
    } else
#line 177
    if ((int )cstr_info->prog == 1) {
      {
#line 178
      fprintf(stream, "RLCP\npack_nb tileno resno layno compno precno start_pos end_ph_pos end_pos\n");
      }
#line 179
      if (disto_on) {
        {
#line 180
        fprintf(stream, " disto");
        }
      }
      {
#line 181
      fprintf(stream, "\n");
#line 183
      resno = 0;
      }
      {
#line 183
      while (1) {
        while_continue___37: /* CIL Label */ ;

#line 183
        if (! (resno < max_numdecompos + 1)) {
#line 183
          goto while_break___8;
        }
#line 184
        layno = 0;
        {
#line 184
        while (1) {
          while_continue___38: /* CIL Label */ ;

#line 184
          if (! (layno < cstr_info->numlayers)) {
#line 184
            goto while_break___9;
          }
#line 185
          compno = 0;
          {
#line 185
          while (1) {
            while_continue___39: /* CIL Label */ ;

#line 185
            if (! (compno < cstr_info->numcomps)) {
#line 185
              goto while_break___10;
            }
#line 187
            if (resno > *(cstr_info->numdecompos + compno)) {
#line 188
              goto while_break___10;
            }
#line 189
            prec_max___0 = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 190
            precno = 0;
            {
#line 190
            while (1) {
              while_continue___40: /* CIL Label */ ;

#line 190
              if (! (precno < prec_max___0)) {
#line 190
                goto while_break___11;
              }
              {
#line 191
              start_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->start_pos;
#line 192
              end_ph_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_ph_pos;
#line 193
              end_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_pos;
#line 194
              disto = ((cstr_info->tile + tileno)->packet + pack_nb)->disto;
#line 195
              fprintf(stream, "%4d %6d %5d %7d %6d %6d %9ld   %9ld %7ld\230\001",
                      pack_nb, tileno, resno, layno, compno, precno, start_pos, end_ph_pos,
                      end_pos);
              }
#line 197
              if (disto_on) {
                {
#line 198
                fprintf(stream, " %8e", disto);
                }
              }
              {
#line 199
              fprintf(stream, "\n");
#line 200
              total_disto += disto;
#line 201
              pack_nb ++;
#line 190
              precno ++;
              }
            }
            while_break___45: /* CIL Label */ ;
            }
            while_break___11: 
#line 185
            compno ++;
          }
          while_break___44: /* CIL Label */ ;
          }
          while_break___10: 
#line 184
          layno ++;
        }
        while_break___43: /* CIL Label */ ;
        }
        while_break___9: 
#line 183
        resno ++;
      }
      while_break___42: /* CIL Label */ ;
      }
      while_break___8: ;
    } else
#line 208
    if ((int )cstr_info->prog == 2) {
      {
#line 210
      fprintf(stream, "RPCL\npack_nb tileno resno precno compno layno start_pos end_ph_pos end_pos");
      }
#line 211
      if (disto_on) {
        {
#line 212
        fprintf(stream, " disto");
        }
      }
      {
#line 213
      fprintf(stream, "\n");
#line 215
      resno = 0;
      }
      {
#line 215
      while (1) {
        while_continue___41: /* CIL Label */ ;

#line 215
        if (! (resno < max_numdecompos + 1)) {
#line 215
          goto while_break___12;
        }
#line 216
        numprec = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 217
        precno = 0;
        {
#line 217
        while (1) {
          while_continue___42: /* CIL Label */ ;

#line 217
          if (! (precno < numprec)) {
#line 217
            goto while_break___13;
          }
          {
#line 219
          __cil_tmp40 = floor((double )((float )tileno / (float )cstr_info->tw));
#line 219
          x0 = (cstr_info->tile_Ox + tileno) - ((int )__cil_tmp40 * cstr_info->tw) * cstr_info->tile_x;
#line 220
          __cil_tmp42 = floor((double )((float )tileno / (float )cstr_info->tw));
#line 220
          y0___10 = cstr_info->tile_Ox + (int )__cil_tmp42 * cstr_info->tile_y;
#line 221
          x1 = x0 + cstr_info->tile_x;
#line 222
          y1___11 = y0___10 + cstr_info->tile_y;
#line 223
          compno = 0;
          }
          {
#line 223
          while (1) {
            while_continue___43: /* CIL Label */ ;

#line 223
            if (! (compno < cstr_info->numcomps)) {
#line 223
              goto while_break___14;
            }
            {
#line 224
            pcnx = (cstr_info->tile + tileno)->pw[resno];
#line 225
            __cil_tmp47 = pow((double )2, (double )(((cstr_info->tile + tileno)->pdx[resno] + *(cstr_info->numdecompos + compno)) - resno));
#line 225
            pcx = (int )__cil_tmp47;
#line 226
            __cil_tmp49 = pow((double )2, (double )(((cstr_info->tile + tileno)->pdy[resno] + *(cstr_info->numdecompos + compno)) - resno));
#line 226
            pcy = (int )__cil_tmp49;
#line 227
            __cil_tmp51 = floor((double )((float )precno / (float )pcnx));
#line 227
            precno_x = precno - (int )__cil_tmp51 * pcnx;
#line 228
            __cil_tmp53 = floor((double )((float )precno / (float )pcnx));
#line 228
            precno_y = (int )__cil_tmp53;
            }
#line 229
            if (resno > *(cstr_info->numdecompos + compno)) {
#line 230
              goto while_break___14;
            }
#line 231
            y = y0___10;
            {
#line 231
            while (1) {
              while_continue___44: /* CIL Label */ ;

#line 231
              if (! (y < y1___11)) {
#line 231
                goto while_break___15;
              }
#line 232
              if (precno_y * pcy == y) {
#line 233
                x = x0;
                {
#line 233
                while (1) {
                  while_continue___45: /* CIL Label */ ;

#line 233
                  if (! (x < x1)) {
#line 233
                    goto while_break___16;
                  }
#line 234
                  if (precno_x * pcx == x) {
#line 235
                    layno = 0;
                    {
#line 235
                    while (1) {
                      while_continue___46: /* CIL Label */ ;

#line 235
                      if (! (layno < cstr_info->numlayers)) {
#line 235
                        goto while_break___17;
                      }
                      {
#line 236
                      start_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->start_pos;
#line 237
                      end_ph_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_ph_pos;
#line 238
                      end_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_pos;
#line 239
                      disto = ((cstr_info->tile + tileno)->packet + pack_nb)->disto;
#line 240
                      fprintf(stream, "%4d %6d %5d %6d %6d %7d %9ld   %9ld %7ld\230\001",
                              pack_nb, tileno, resno, precno, compno, layno, start_pos,
                              end_ph_pos, end_pos);
                      }
#line 242
                      if (disto_on) {
                        {
#line 243
                        fprintf(stream, " %8e", disto);
                        }
                      }
                      {
#line 244
                      fprintf(stream, "\n");
#line 245
                      total_disto += disto;
#line 246
                      pack_nb ++;
#line 235
                      layno ++;
                      }
                    }
                    while_break___51: /* CIL Label */ ;
                    }
                    while_break___17: ;
                  }
#line 233
                  x ++;
                }
                while_break___50: /* CIL Label */ ;
                }
                while_break___16: ;
              }
#line 231
              y ++;
            }
            while_break___49: /* CIL Label */ ;
            }
            while_break___15: 
#line 223
            compno ++;
          }
          while_break___48: /* CIL Label */ ;
          }
          while_break___14: 
#line 217
          precno ++;
        }
        while_break___47: /* CIL Label */ ;
        }
        while_break___13: 
#line 215
        resno ++;
      }
      while_break___46: /* CIL Label */ ;
      }
      while_break___12: ;
    } else
#line 257
    if ((int )cstr_info->prog == 3) {
      {
#line 259
      __cil_tmp62 = floor((double )((float )tileno / (float )cstr_info->tw));
#line 259
      x0___0 = (cstr_info->tile_Ox + tileno) - ((int )__cil_tmp62 * cstr_info->tw) * cstr_info->tile_x;
#line 260
      __cil_tmp64 = floor((double )((float )tileno / (float )cstr_info->tw));
#line 260
      y0___12 = cstr_info->tile_Ox + (int )__cil_tmp64 * cstr_info->tile_y;
#line 261
      x1___0 = x0___0 + cstr_info->tile_x;
#line 262
      y1___13 = y0___12 + cstr_info->tile_y;
#line 265
      max_numprec = 0;
#line 266
      resno = 0;
      }
      {
#line 266
      while (1) {
        while_continue___47: /* CIL Label */ ;

#line 266
        if (! (resno < max_numdecompos + 1)) {
#line 266
          goto while_break___18;
        }
#line 267
        numprec___0 = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 268
        if (numprec___0 > max_numprec) {
#line 269
          max_numprec = numprec___0;
        }
#line 266
        resno ++;
      }
      while_break___52: /* CIL Label */ ;
      }
      while_break___18: 
      {
#line 272
      fprintf(stream, "PCRL\npack_nb tileno precno compno resno layno start_pos end_ph_pos end_pos");
      }
#line 273
      if (disto_on) {
        {
#line 274
        fprintf(stream, " disto");
        }
      }
      {
#line 275
      fprintf(stream, "\n");
#line 277
      precno = 0;
      }
      {
#line 277
      while (1) {
        while_continue___48: /* CIL Label */ ;

#line 277
        if (! (precno < max_numprec)) {
#line 277
          goto while_break___19;
        }
#line 278
        compno = 0;
        {
#line 278
        while (1) {
          while_continue___49: /* CIL Label */ ;

#line 278
          if (! (compno < cstr_info->numcomps)) {
#line 278
            goto while_break___20;
          }
#line 279
          resno = 0;
          {
#line 279
          while (1) {
            while_continue___50: /* CIL Label */ ;
            while_continue___21: ;
#line 279
            if (! (resno < *(cstr_info->numdecompos + compno) + 1)) {
#line 279
              goto while_break___21;
            }
            {
#line 280
            numprec___1 = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 281
            pcnx___0 = (cstr_info->tile + tileno)->pw[resno];
#line 282
            __cil_tmp73 = pow((double )2, (double )(((cstr_info->tile + tileno)->pdx[resno] + *(cstr_info->numdecompos + compno)) - resno));
#line 282
            pcx___0 = (int )__cil_tmp73;
#line 283
            __cil_tmp75 = pow((double )2, (double )(((cstr_info->tile + tileno)->pdy[resno] + *(cstr_info->numdecompos + compno)) - resno));
#line 283
            pcy___0 = (int )__cil_tmp75;
#line 284
            __cil_tmp77 = floor((double )((float )precno / (float )pcnx___0));
#line 284
            precno_x___0 = precno - (int )__cil_tmp77 * pcnx___0;
#line 285
            __cil_tmp79 = floor((double )((float )precno / (float )pcnx___0));
#line 285
            precno_y___0 = (int )__cil_tmp79;
            }
#line 286
            if (precno >= numprec___1) {
#line 287
              goto while_continue___21;
            }
#line 288
            y = y0___12;
            {
#line 288
            while (1) {
              while_continue___51: /* CIL Label */ ;

#line 288
              if (! (y < y1___13)) {
#line 288
                goto while_break___22;
              }
#line 289
              if (precno_y___0 * pcy___0 == y) {
#line 290
                x = x0___0;
                {
#line 290
                while (1) {
                  while_continue___52: /* CIL Label */ ;

#line 290
                  if (! (x < x1___0)) {
#line 290
                    goto while_break___23;
                  }
#line 291
                  if (precno_x___0 * pcx___0 == x) {
#line 292
                    layno = 0;
                    {
#line 292
                    while (1) {
                      while_continue___53: /* CIL Label */ ;

#line 292
                      if (! (layno < cstr_info->numlayers)) {
#line 292
                        goto while_break___24;
                      }
                      {
#line 293
                      start_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->start_pos;
#line 294
                      end_ph_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_ph_pos;
#line 295
                      end_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_pos;
#line 296
                      disto = ((cstr_info->tile + tileno)->packet + pack_nb)->disto;
#line 297
                      fprintf(stream, "%4d %6d %6d %6d %5d %7d %9ld   %9ld %7ld\230\001",
                              pack_nb, tileno, precno, compno, resno, layno, start_pos,
                              end_ph_pos, end_pos);
                      }
#line 299
                      if (disto_on) {
                        {
#line 300
                        fprintf(stream, " %8e", disto);
                        }
                      }
                      {
#line 301
                      fprintf(stream, "\n");
#line 302
                      total_disto += disto;
#line 303
                      pack_nb ++;
#line 292
                      layno ++;
                      }
                    }
                    while_break___58: /* CIL Label */ ;
                    }
                    while_break___24: ;
                  }
#line 290
                  x ++;
                }
                while_break___57: /* CIL Label */ ;
                }
                while_break___23: ;
              }
#line 288
              y ++;
            }
            while_break___56: /* CIL Label */ ;
            }
            while_break___22: 
#line 279
            resno ++;
          }
          while_break___55: /* CIL Label */ ;
          }
          while_break___21: 
#line 278
          compno ++;
        }
        while_break___54: /* CIL Label */ ;
        }
        while_break___20: 
#line 277
        precno ++;
      }
      while_break___53: /* CIL Label */ ;
      }
      while_break___19: ;
    } else {
#line 316
      max_numprec___0 = 0;
#line 317
      resno = 0;
      {
#line 317
      while (1) {
        while_continue___54: /* CIL Label */ ;

#line 317
        if (! (resno < max_numdecompos + 1)) {
#line 317
          goto while_break___25;
        }
#line 318
        numprec___2 = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 319
        if (numprec___2 > max_numprec___0) {
#line 320
          max_numprec___0 = numprec___2;
        }
#line 317
        resno ++;
      }
      while_break___59: /* CIL Label */ ;
      }
      while_break___25: 
      {
#line 323
      fprintf(stream, "CPRL\npack_nb tileno compno precno resno layno start_pos end_ph_pos end_pos");
      }
#line 324
      if (disto_on) {
        {
#line 325
        fprintf(stream, " disto");
        }
      }
      {
#line 326
      fprintf(stream, "\n");
#line 328
      compno = 0;
      }
      {
#line 328
      while (1) {
        while_continue___55: /* CIL Label */ ;

#line 328
        if (! (compno < cstr_info->numcomps)) {
#line 328
          goto while_break___26;
        }
        {
#line 330
        __cil_tmp91 = floor((double )((float )tileno / (float )cstr_info->tw));
#line 330
        x0___1 = (cstr_info->tile_Ox + tileno) - ((int )__cil_tmp91 * cstr_info->tw) * cstr_info->tile_x;
#line 331
        __cil_tmp93 = floor((double )((float )tileno / (float )cstr_info->tw));
#line 331
        y0___14 = cstr_info->tile_Ox + (int )__cil_tmp93 * cstr_info->tile_y;
#line 332
        x1___1 = x0___1 + cstr_info->tile_x;
#line 333
        y1___15 = y0___14 + cstr_info->tile_y;
#line 335
        precno = 0;
        }
        {
#line 335
        while (1) {
          while_continue___56: /* CIL Label */ ;

#line 335
          if (! (precno < max_numprec___0)) {
#line 335
            goto while_break___27;
          }
#line 336
          resno = 0;
          {
#line 336
          while (1) {
            while_continue___57: /* CIL Label */ ;
            while_continue___28: ;
#line 336
            if (! (resno < *(cstr_info->numdecompos + compno) + 1)) {
#line 336
              goto while_break___28;
            }
            {
#line 337
            numprec___3 = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 338
            pcnx___1 = (cstr_info->tile + tileno)->pw[resno];
#line 339
            __cil_tmp99 = pow((double )2, (double )(((cstr_info->tile + tileno)->pdx[resno] + *(cstr_info->numdecompos + compno)) - resno));
#line 339
            pcx___1 = (int )__cil_tmp99;
#line 340
            __cil_tmp101 = pow((double )2, (double )(((cstr_info->tile + tileno)->pdy[resno] + *(cstr_info->numdecompos + compno)) - resno));
#line 340
            pcy___1 = (int )__cil_tmp101;
#line 341
            __cil_tmp103 = floor((double )((float )precno / (float )pcnx___1));
#line 341
            precno_x___1 = precno - (int )__cil_tmp103 * pcnx___1;
#line 342
            __cil_tmp105 = floor((double )((float )precno / (float )pcnx___1));
#line 342
            precno_y___1 = (int )__cil_tmp105;
            }
#line 343
            if (precno >= numprec___3) {
#line 344
              goto while_continue___28;
            }
#line 346
            y = y0___14;
            {
#line 346
            while (1) {
              while_continue___58: /* CIL Label */ ;

#line 346
              if (! (y < y1___15)) {
#line 346
                goto while_break___29;
              }
#line 347
              if (precno_y___1 * pcy___1 == y) {
#line 348
                x = x0___1;
                {
#line 348
                while (1) {
                  while_continue___59: /* CIL Label */ ;

#line 348
                  if (! (x < x1___1)) {
#line 348
                    goto while_break___30;
                  }
#line 349
                  if (precno_x___1 * pcx___1 == x) {
#line 350
                    layno = 0;
                    {
#line 350
                    while (1) {
                      while_continue___60: /* CIL Label */ ;

#line 350
                      if (! (layno < cstr_info->numlayers)) {
#line 350
                        goto while_break___31;
                      }
                      {
#line 351
                      start_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->start_pos;
#line 352
                      end_ph_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_ph_pos;
#line 353
                      end_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_pos;
#line 354
                      disto = ((cstr_info->tile + tileno)->packet + pack_nb)->disto;
#line 355
                      fprintf(stream, "%4d %6d %6d %6d %5d %7d %9ld   %9ld %7ld\230\001",
                              pack_nb, tileno, compno, precno, resno, layno, start_pos,
                              end_ph_pos, end_pos);
                      }
#line 357
                      if (disto_on) {
                        {
#line 358
                        fprintf(stream, " %8e", disto);
                        }
                      }
                      {
#line 359
                      fprintf(stream, "\n");
#line 360
                      total_disto += disto;
#line 361
                      pack_nb ++;
#line 350
                      layno ++;
                      }
                    }
                    while_break___65: /* CIL Label */ ;
                    }
                    while_break___31: ;
                  }
#line 348
                  x ++;
                }
                while_break___64: /* CIL Label */ ;
                }
                while_break___30: ;
              }
#line 346
              y ++;
            }
            while_break___63: /* CIL Label */ ;
            }
            while_break___29: 
#line 336
            resno ++;
          }
          while_break___62: /* CIL Label */ ;
          }
          while_break___28: 
#line 335
          precno ++;
        }
        while_break___61: /* CIL Label */ ;
        }
        while_break___27: 
#line 328
        compno ++;
      }
      while_break___60: /* CIL Label */ ;
      }
      while_break___26: ;
    }
#line 123
    tileno ++;
  }
  while_break___35: /* CIL Label */ ;
  }
  while_break___1: ;
#line 373
  if (disto_on) {
    {
#line 374
    fprintf(stream, "%8e\n", cstr_info->D_max);
#line 375
    fprintf(stream, "%.8e\n", total_disto);
    }
  }
#line 379
  if (cstr_info->marknum) {
    {
#line 380
    fprintf(stream, "\nMARKER LIST\n");
#line 381
    fprintf(stream, "%d\n", cstr_info->marknum);
#line 382
    fprintf(stream, "type\tstart_pos    length\n");
#line 383
    x = 0;
    }
    {
#line 383
    while (1) {
      while_continue___61: /* CIL Label */ ;

#line 383
      if (! (x < cstr_info->marknum)) {
#line 383
        goto while_break___32;
      }
      {
#line 384
      fprintf(stream, "%X\t%9ld %9d\n\230\001", (int )(cstr_info->marker + x)->type,
              (cstr_info->marker + x)->pos, (cstr_info->marker + x)->len);
#line 383
      x ++;
      }
    }
    while_break___66: /* CIL Label */ ;
    }
    while_break___32: ;
  }
  {
#line 387
  fclose(stream);
#line 389
  fprintf(stderr, "Generated index file %s\n\230\001", index___0);
  }
#line 391
  return (0);
}
}
#line 293 "/usr/include/x86_64-linux-gnu/tiffio.h"
extern void *_TIFFmalloc(tmsize_t s ) ;
#line 299
extern void _TIFFfree(void *p ) ;
#line 343
extern void TIFFClose(TIFF *tif ) ;
#line 346
extern int TIFFGetField(TIFF *tif , uint32 tag  , ...) ;
#line 348
extern int TIFFGetFieldDefaulted(TIFF *tif , uint32 tag  , ...) ;
#line 358
extern tmsize_t TIFFStripSize(TIFF *tif ) ;
#line 407
extern int TIFFSetField(TIFF * , uint32   , ...) ;
#line 440
extern TIFF *TIFFOpen(char const   * , char const   * ) ;
#line 469
extern tmsize_t TIFFReadEncodedStrip(TIFF *tif , uint32 strip , void *buf , tmsize_t size ) ;
#line 476
extern tmsize_t TIFFWriteEncodedStrip(TIFF *tif , uint32 strip , void *data , tmsize_t cc ) ;
#line 58 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__)) int _setjmp(struct __jmp_buf_tag *__env ) ;
#line 67
extern  __attribute__((__nothrow__)) void longjmp(struct __jmp_buf_tag *__env , int __val ) ;
#line 929 "/usr/include/png.h"
extern void png_set_sig_bytes(png_structrp png_ptr , int num_bytes ) ;
#line 945
extern png_structp png_create_read_struct(png_const_charp user_png_ver , png_voidp error_ptr ,
                                          void (*error_fn)(png_structp  , png_const_charp  ) ,
                                          void (*warn_fn)(png_structp  , png_const_charp  ) ) ;
#line 951
extern png_structp png_create_write_struct(png_const_charp user_png_ver , png_voidp error_ptr ,
                                           void (*error_fn)(png_structp  , png_const_charp  ) ,
                                           void (*warn_fn)(png_structp  , png_const_charp  ) ) ;
#line 973
extern jmp_buf *png_set_longjmp_fn(png_structrp png_ptr , void (*longjmp_fn)(struct __jmp_buf_tag * ,
                                                                             int  ) ,
                                   size_t jmp_buf_size ) ;
#line 1027
extern png_infop png_create_info_struct(png_const_structrp png_ptr ) ;
#line 1040
extern void png_write_info(png_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1045
extern void png_read_info(png_structrp png_ptr , png_inforp info_ptr ) ;
#line 1074
extern void png_set_expand(png_structrp png_ptr ) ;
#line 1094
extern void png_set_gray_to_rgb(png_structrp png_ptr ) ;
#line 1285
extern void png_set_packing(png_structrp png_ptr ) ;
#line 1373
extern void png_set_gamma(png_structrp png_ptr , double screen_gamma , double override_file_gamma ) ;
#line 1390
extern void png_read_update_info(png_structrp png_ptr , png_inforp info_ptr ) ;
#line 1407
extern void png_read_image(png_structrp png_ptr , png_bytepp image ) ;
#line 1411
extern void png_write_row(png_structrp png_ptr , png_const_bytep row ) ;
#line 1426
extern void png_write_end(png_structrp png_ptr , png_inforp info_ptr ) ;
#line 1439
extern void png_destroy_read_struct(png_structpp png_ptr_ptr , png_infopp info_ptr_ptr ,
                                    png_infopp end_info_ptr_ptr ) ;
#line 1443
extern void png_destroy_write_struct(png_structpp png_ptr_ptr , png_infopp info_ptr_ptr ) ;
#line 1531
extern void png_set_compression_level(png_structrp png_ptr , int level ) ;
#line 1583
extern void png_init_io(png_structrp png_ptr , png_FILE_p fp ) ;
#line 1861
extern png_uint_32 png_get_valid(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                 png_uint_32 flag ) ;
#line 1865
extern size_t png_get_rowbytes(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1896
extern png_byte png_get_bit_depth(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1900
extern png_byte png_get_color_type(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 2017
extern png_uint_32 png_get_gAMA(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                double *file_gamma ) ;
#line 2038
extern png_uint_32 png_get_IHDR(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                png_uint_32 *width , png_uint_32 *height , int *bit_depth ,
                                int *color_type , int *interlace_method , int *compression_method ,
                                int *filter_method ) ;
#line 2043
extern void png_set_IHDR(png_const_structrp png_ptr , png_inforp info_ptr , png_uint_32 width ,
                         png_uint_32 height , int bit_depth , int color_type , int interlace_method ,
                         int compression_method , int filter_method ) ;
#line 2074
extern png_uint_32 png_get_pHYs(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                png_uint_32 *res_x , png_uint_32 *res_y , int *unit_type ) ;
#line 2096
extern void png_set_sBIT(png_const_structrp png_ptr , png_inforp info_ptr , png_const_color_8p sig_bit ) ;
#line 2106
extern void png_set_sRGB(png_const_structrp png_ptr , png_inforp info_ptr , int srgb_intent ) ;
#line 51 "/root/patron/new_22/src/bin/jp2/convert.h"
opj_image_t *tgatoimage(char const   *filename , opj_cparameters_t *parameters ) ;
#line 52
int imagetotga(opj_image_t *image , char const   *outfile ) ;
#line 55
opj_image_t *bmptoimage(char const   *filename , opj_cparameters_t *parameters ) ;
#line 56
int imagetobmp(opj_image_t *image , char const   *outfile ) ;
#line 59
opj_image_t *tiftoimage(char const   *filename , opj_cparameters_t *parameters ) ;
#line 60
int imagetotif(opj_image_t *image , char const   *outfile ) ;
#line 67
opj_image_t *pgxtoimage(char const   *filename , opj_cparameters_t *parameters ) ;
#line 68
int imagetopgx(opj_image_t *image , char const   *outfile ) ;
#line 70
opj_image_t *pnmtoimage(char const   *filename , opj_cparameters_t *parameters ) ;
#line 71
int imagetopnm(opj_image_t *image , char const   *outfile ) ;
#line 74
int imagetoraw(opj_image_t *image , char const   *outfile ) ;
#line 75
int imagetorawl(opj_image_t *image , char const   *outfile ) ;
#line 76
opj_image_t *rawtoimage(char const   *filename , opj_cparameters_t *parameters , raw_cparameters_t *raw_cp ) ;
#line 77
opj_image_t *rawltoimage(char const   *filename , opj_cparameters_t *parameters ,
                         raw_cparameters_t *raw_cp ) ;
#line 80
int imagetopng(opj_image_t *image , char const   *write_idf ) ;
#line 81
opj_image_t *pngtoimage(char const   *read_idf , opj_cparameters_t *params ) ;
#line 56 "/root/patron/new_22/src/bin/jp2/convert.c"
static int int_floorlog2(int a ) 
{ 
  int l ;

  {
#line 58
  l = 0;
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;

#line 58
    if (! (a > 1)) {
#line 58
      goto while_break;
    }
#line 59
    a >>= 1;
#line 58
    l ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 61
  return (l);
}
}
#line 95 "/root/patron/new_22/src/bin/jp2/convert.c"
static unsigned short get_ushort(unsigned short val ) 
{ 


  {
#line 100
  return (val);
}
}
#line 107 "/root/patron/new_22/src/bin/jp2/convert.c"
static int tga_readheader(FILE *fp , unsigned int *bits_per_pixel , unsigned int *width ,
                          unsigned int *height , int *flip_image ) 
{ 
  int palette_size ;
  unsigned char *tga ;
  unsigned char id_len ;
  unsigned char cmap_type ;
  unsigned char image_type ;
  unsigned char pixel_depth ;
  unsigned char image_desc ;
  unsigned short cmap_index ;
  unsigned short cmap_len ;
  unsigned short cmap_entry_size ;
  unsigned short x_origin ;
  unsigned short y_origin ;
  unsigned short image_w ;
  unsigned short image_h ;
  void *__cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned char *id ;
  void *__cil_tmp29 ;
  unsigned long __cil_tmp30 ;

  {
#line 117
  if (! bits_per_pixel) {
#line 118
    return (0);
  } else
#line 117
  if (! width) {
#line 118
    return (0);
  } else
#line 117
  if (! height) {
#line 118
    return (0);
  } else
#line 117
  if (! flip_image) {
#line 118
    return (0);
  }
  {
#line 119
  __cil_tmp20 = malloc(18UL);
#line 119
  tga = (unsigned char *)__cil_tmp20;
#line 121
  __cil_tmp21 = fread((void *)tga, 18UL, 1UL, fp);
  }
#line 121
  if (__cil_tmp21 != 1UL) {
    {
#line 123
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 124
    return (0);
  }
  {
#line 126
  id_len = *(tga + 0);
#line 127
  cmap_type = *(tga + 1);
#line 128
  image_type = *(tga + 2);
#line 129
  cmap_index = get_ushort(*((unsigned short *)(tga + 3)));
#line 130
  cmap_len = get_ushort(*((unsigned short *)(tga + 5)));
#line 131
  cmap_entry_size = (unsigned short )*(tga + 7);
#line 134
  x_origin = get_ushort(*((unsigned short *)(tga + 8)));
#line 135
  y_origin = get_ushort(*((unsigned short *)(tga + 10)));
#line 136
  image_w = get_ushort(*((unsigned short *)(tga + 12)));
#line 137
  image_h = get_ushort(*((unsigned short *)(tga + 14)));
#line 138
  pixel_depth = *(tga + 16);
#line 139
  image_desc = *(tga + 17);
#line 141
  free((void *)tga);
#line 143
  *bits_per_pixel = (unsigned int )pixel_depth;
#line 144
  *width = (unsigned int )image_w;
#line 145
  *height = (unsigned int )image_h;
  }
#line 148
  if (id_len) {
    {
#line 150
    __cil_tmp29 = malloc((unsigned long )id_len);
#line 150
    id = (unsigned char *)__cil_tmp29;
#line 151
    __cil_tmp30 = fread((void *)id, (unsigned long )id_len, 1UL, fp);
    }
#line 151
    if (! __cil_tmp30) {
      {
#line 153
      fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 154
      free((void *)id);
      }
#line 155
      return (0);
    }
    {
#line 157
    free((void *)id);
    }
  }
#line 163
  if ((int )image_type > 8) {
    {
#line 165
    fprintf(stderr, "Sorry, compressed tga files are not currently supported.\n");
    }
#line 166
    return (0);
  }
#line 169
  *flip_image = ! ((int )image_desc & 32);
#line 172
  palette_size = (int )cmap_len * ((int )cmap_entry_size / 8);
#line 174
  if (palette_size > 0) {
    {
#line 176
    fprintf(stderr, "File contains a palette - not yet supported.");
#line 177
    fseek(fp, (long )palette_size, 1);
    }
  }
#line 179
  return (1);
}
}
#line 192 "/root/patron/new_22/src/bin/jp2/convert.c"
static int tga_writeheader(FILE *fp , int bits_per_pixel , int width , int height ,
                           OPJ_BOOL flip_image ) 
{ 
  unsigned short image_w ;
  unsigned short image_h ;
  unsigned short us0 ;
  unsigned char uc0 ;
  unsigned char image_type ;
  unsigned char pixel_depth ;
  unsigned char image_desc ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;

  {
#line 199
  if (! bits_per_pixel) {
#line 200
    return (0);
  } else
#line 199
  if (! width) {
#line 200
    return (0);
  } else
#line 199
  if (! height) {
#line 200
    return (0);
  }
#line 202
  pixel_depth = (unsigned char)0;
#line 204
  if (bits_per_pixel < 256) {
#line 205
    pixel_depth = (unsigned char )bits_per_pixel;
  } else {
    {
#line 207
    fprintf(stderr, "ERROR: Wrong bits per pixel inside tga_headerU");
    }
#line 208
    return (0);
  }
  {
#line 210
  uc0 = (unsigned char)0;
#line 212
  __cil_tmp13 = fwrite((void const   *)(& uc0), 1UL, 1UL, fp);
  }
#line 212
  if (__cil_tmp13 != 1UL) {
#line 212
    goto fails;
  }
  {
#line 213
  __cil_tmp14 = fwrite((void const   *)(& uc0), 1UL, 1UL, fp);
  }
#line 213
  if (__cil_tmp14 != 1UL) {
#line 213
    goto fails;
  }
  {
#line 215
  image_type = (unsigned char)2;
#line 216
  __cil_tmp15 = fwrite((void const   *)(& image_type), 1UL, 1UL, fp);
  }
#line 216
  if (__cil_tmp15 != 1UL) {
#line 216
    goto fails;
  }
  {
#line 218
  us0 = (unsigned short)0;
#line 219
  __cil_tmp16 = fwrite((void const   *)(& us0), 2UL, 1UL, fp);
  }
#line 219
  if (__cil_tmp16 != 1UL) {
#line 219
    goto fails;
  }
  {
#line 220
  __cil_tmp17 = fwrite((void const   *)(& us0), 2UL, 1UL, fp);
  }
#line 220
  if (__cil_tmp17 != 1UL) {
#line 220
    goto fails;
  }
  {
#line 221
  __cil_tmp18 = fwrite((void const   *)(& uc0), 1UL, 1UL, fp);
  }
#line 221
  if (__cil_tmp18 != 1UL) {
#line 221
    goto fails;
  }
  {
#line 223
  __cil_tmp19 = fwrite((void const   *)(& us0), 2UL, 1UL, fp);
  }
#line 223
  if (__cil_tmp19 != 1UL) {
#line 223
    goto fails;
  }
  {
#line 224
  __cil_tmp20 = fwrite((void const   *)(& us0), 2UL, 1UL, fp);
  }
#line 224
  if (__cil_tmp20 != 1UL) {
#line 224
    goto fails;
  }
  {
#line 226
  image_w = (unsigned short )width;
#line 227
  image_h = (unsigned short )height;
#line 230
  __cil_tmp21 = fwrite((void const   *)(& image_w), 2UL, 1UL, fp);
  }
#line 230
  if (__cil_tmp21 != 1UL) {
#line 230
    goto fails;
  }
  {
#line 231
  __cil_tmp22 = fwrite((void const   *)(& image_h), 2UL, 1UL, fp);
  }
#line 231
  if (__cil_tmp22 != 1UL) {
#line 231
    goto fails;
  }
  {
#line 239
  __cil_tmp23 = fwrite((void const   *)(& pixel_depth), 1UL, 1UL, fp);
  }
#line 239
  if (__cil_tmp23 != 1UL) {
#line 239
    goto fails;
  }
#line 241
  image_desc = (unsigned char)8;
#line 243
  if (flip_image) {
#line 244
    image_desc = (unsigned char )((int )image_desc | 32);
  }
  {
#line 245
  __cil_tmp24 = fwrite((void const   *)(& image_desc), 1UL, 1UL, fp);
  }
#line 245
  if (__cil_tmp24 != 1UL) {
#line 245
    goto fails;
  }
#line 247
  return (1);
  fails: 
  {
#line 250
  fputs("\nwrite_tgaheader: write ERROR\n", stderr);
  }
#line 251
  return (0);
}
}
#line 254 "/root/patron/new_22/src/bin/jp2/convert.c"
opj_image_t *tgatoimage(char const   *filename , opj_cparameters_t *parameters ) 
{ 
  FILE *f ;
  opj_image_t *image ;
  unsigned int image_width ;
  unsigned int image_height ;
  unsigned int pixel_bit_depth ;
  unsigned int x ;
  unsigned int y ;
  int flip_image ;
  opj_image_cmptparm_t cmptparm[4] ;
  int numcomps ;
  OPJ_COLOR_SPACE color_space ;
  OPJ_BOOL mono ;
  OPJ_BOOL save_alpha ;
  int subsampling_dx ;
  int subsampling_dy ;
  int i ;
  int __cil_tmp20 ;
  int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  int index___16 ;
  unsigned char r ;
  unsigned char g ;
  unsigned char b ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned char r___0 ;
  unsigned char g___0 ;
  unsigned char b___0 ;
  unsigned char a ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 259
  flip_image = 0;
#line 268
  f = fopen(filename, "rb\340\212\202U");
  }
#line 269
  if (! f) {
    {
#line 270
    fprintf(stderr, "Failed to open %s for reading !!\n", filename);
    }
#line 271
    return ((opj_image_t *)0);
  }
  {
#line 274
  __cil_tmp20 = tga_readheader(f, & pixel_bit_depth, & image_width, & image_height,
                               & flip_image);
  }
#line 274
  if (! __cil_tmp20) {
#line 275
    return ((opj_image_t *)((void *)0));
  }
#line 278
  if (! (pixel_bit_depth == 24U)) {
#line 278
    if (! (pixel_bit_depth == 32U)) {
#line 279
      return ((opj_image_t *)((void *)0));
    }
  }
  {
#line 282
  memset((void *)(& cmptparm[0]), 0, 4UL * sizeof(opj_image_cmptparm_t ));
  }
#line 284
  if (pixel_bit_depth == 8U) {
#line 284
    tmp___3 = 1;
  } else
#line 284
  if (pixel_bit_depth == 16U) {
#line 284
    tmp___3 = 1;
  } else {
#line 284
    tmp___3 = 0;
  }
#line 284
  mono = tmp___3;
#line 285
  if (pixel_bit_depth == 16U) {
#line 285
    tmp___4 = 1;
  } else
#line 285
  if (pixel_bit_depth == 32U) {
#line 285
    tmp___4 = 1;
  } else {
#line 285
    tmp___4 = 0;
  }
#line 285
  save_alpha = tmp___4;
#line 287
  if (mono) {
#line 288
    color_space = (OPJ_COLOR_SPACE )2;
#line 289
    if (save_alpha) {
#line 289
      tmp = 2;
    } else {
#line 289
      tmp = 1;
    }
#line 289
    numcomps = tmp;
  } else {
#line 292
    if (save_alpha) {
#line 292
      tmp___0 = 4;
    } else {
#line 292
      tmp___0 = 3;
    }
#line 292
    numcomps = tmp___0;
#line 293
    color_space = (OPJ_COLOR_SPACE )1;
  }
#line 296
  subsampling_dx = parameters->subsampling_dx;
#line 297
  subsampling_dy = parameters->subsampling_dy;
#line 299
  i = 0;
  {
#line 299
  while (1) {
    while_continue: /* CIL Label */ ;

#line 299
    if (! (i < numcomps)) {
#line 299
      goto while_break;
    }
#line 300
    cmptparm[i].prec = (OPJ_UINT32 )8;
#line 301
    cmptparm[i].bpp = (OPJ_UINT32 )8;
#line 302
    cmptparm[i].sgnd = (OPJ_UINT32 )0;
#line 303
    cmptparm[i].dx = (OPJ_UINT32 )subsampling_dx;
#line 304
    cmptparm[i].dy = (OPJ_UINT32 )subsampling_dy;
#line 305
    cmptparm[i].w = image_width;
#line 306
    cmptparm[i].h = image_height;
#line 299
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: 
  {
#line 310
  image = opj_image_create((OPJ_UINT32 )numcomps, & cmptparm[0], color_space);
  }
#line 312
  if (! image) {
#line 313
    return ((opj_image_t *)((void *)0));
  }
#line 316
  image->x0 = (OPJ_UINT32 )parameters->image_offset_x0;
#line 317
  image->y0 = (OPJ_UINT32 )parameters->image_offset_y0;
#line 318
  if (! image->x0) {
#line 318
    tmp___1 = (image_width - 1U) * (unsigned int )subsampling_dx + 1U;
  } else {
#line 318
    tmp___1 = (image->x0 + (image_width - 1U) * (unsigned int )subsampling_dx) + 1U;
  }
#line 318
  image->x1 = tmp___1;
#line 319
  if (! image->y0) {
#line 319
    tmp___2 = (image_height - 1U) * (unsigned int )subsampling_dy + 1U;
  } else {
#line 319
    tmp___2 = (image->y0 + (image_height - 1U) * (unsigned int )subsampling_dy) + 1U;
  }
#line 319
  image->y1 = tmp___2;
#line 322
  y = 0U;
  {
#line 322
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 322
    if (! (y < image_height)) {
#line 322
      goto while_break___0;
    }
#line 326
    if (flip_image) {
#line 327
      index___16 = (int )(((image_height - y) - 1U) * image_width);
    } else {
#line 329
      index___16 = (int )(y * image_width);
    }
#line 331
    if (numcomps == 3) {
#line 333
      x = 0U;
      {
#line 333
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 333
        if (! (x < image_width)) {
#line 333
          goto while_break___1;
        }
        {
#line 337
        __cil_tmp31 = fread((void *)(& b), 1UL, 1UL, f);
        }
#line 337
        if (! __cil_tmp31) {
          {
#line 339
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 340
          opj_image_destroy(image);
          }
#line 341
          return ((opj_image_t *)((void *)0));
        }
        {
#line 343
        __cil_tmp32 = fread((void *)(& g), 1UL, 1UL, f);
        }
#line 343
        if (! __cil_tmp32) {
          {
#line 345
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 346
          opj_image_destroy(image);
          }
#line 347
          return ((opj_image_t *)((void *)0));
        }
        {
#line 349
        __cil_tmp33 = fread((void *)(& r), 1UL, 1UL, f);
        }
#line 349
        if (! __cil_tmp33) {
          {
#line 351
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 352
          opj_image_destroy(image);
          }
#line 353
          return ((opj_image_t *)((void *)0));
        }
#line 356
        *((image->comps + 0)->data + index___16) = (OPJ_INT32 )r;
#line 357
        *((image->comps + 1)->data + index___16) = (OPJ_INT32 )g;
#line 358
        *((image->comps + 2)->data + index___16) = (OPJ_INT32 )b;
#line 359
        index___16 ++;
#line 333
        x ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: ;
    } else
#line 362
    if (numcomps == 4) {
#line 364
      x = 0U;
      {
#line 364
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 364
        if (! (x < image_width)) {
#line 364
          goto while_break___2;
        }
        {
#line 367
        __cil_tmp40 = fread((void *)(& b___0), 1UL, 1UL, f);
        }
#line 367
        if (! __cil_tmp40) {
          {
#line 369
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 370
          opj_image_destroy(image);
          }
#line 371
          return ((opj_image_t *)((void *)0));
        }
        {
#line 373
        __cil_tmp41 = fread((void *)(& g___0), 1UL, 1UL, f);
        }
#line 373
        if (! __cil_tmp41) {
          {
#line 375
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 376
          opj_image_destroy(image);
          }
#line 377
          return ((opj_image_t *)((void *)0));
        }
        {
#line 379
        __cil_tmp42 = fread((void *)(& r___0), 1UL, 1UL, f);
        }
#line 379
        if (! __cil_tmp42) {
          {
#line 381
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 382
          opj_image_destroy(image);
          }
#line 383
          return ((opj_image_t *)((void *)0));
        }
        {
#line 385
        __cil_tmp43 = fread((void *)(& a), 1UL, 1UL, f);
        }
#line 385
        if (! __cil_tmp43) {
          {
#line 387
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 388
          opj_image_destroy(image);
          }
#line 389
          return ((opj_image_t *)((void *)0));
        }
#line 392
        *((image->comps + 0)->data + index___16) = (OPJ_INT32 )r___0;
#line 393
        *((image->comps + 1)->data + index___16) = (OPJ_INT32 )g___0;
#line 394
        *((image->comps + 2)->data + index___16) = (OPJ_INT32 )b___0;
#line 395
        *((image->comps + 3)->data + index___16) = (OPJ_INT32 )a;
#line 396
        index___16 ++;
#line 364
        x ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___2: ;
    } else {
      {
#line 400
      fprintf(stderr, "Currently unsupported bit depth : %s\n", filename);
      }
    }
#line 322
    y ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: ;
#line 403
  return (image);
}
}
#line 406 "/root/patron/new_22/src/bin/jp2/convert.c"
int imagetotga(opj_image_t *image , char const   *outfile ) 
{ 
  int width ;
  int height ;
  int bpp ;
  int x ;
  int y ;
  OPJ_BOOL write_alpha ;
  int i ;
  int adjustR ;
  int adjustG ;
  int adjustB ;
  unsigned int alpha_channel ;
  float r ;
  float g ;
  float b ;
  float a ;
  unsigned char value ;
  float scale ;
  FILE *fdest ;
  size_t res ;
  int tmp ;
  int __cil_tmp25 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned int index___17 ;
  int __cil_tmp34 ;
  unsigned int __cil_tmp35 ;
  int tmp___3 ;

  {
  {
#line 417
  fdest = fopen(outfile, "wb");
  }
#line 418
  if (! fdest) {
    {
#line 419
    fprintf(stderr, "ERROR -> failed to open %s for writing\n", outfile);
    }
#line 420
    return (1);
  }
#line 423
  i = 0;
  {
#line 423
  while (1) {
    while_continue: /* CIL Label */ ;

#line 423
    if (! ((unsigned int )i < image->numcomps - 1U)) {
#line 423
      goto while_break;
    }
#line 424
    if ((image->comps + 0)->dx != (image->comps + (i + 1))->dx) {
      {
#line 427
      fprintf(stderr, "Unable to create a tga file with such J2K image charateristics.");
      }
#line 428
      return (1);
    } else
#line 424
    if ((image->comps + 0)->dy != (image->comps + (i + 1))->dy) {
      {
#line 427
      fprintf(stderr, "Unable to create a tga file with such J2K image charateristics.");
      }
#line 428
      return (1);
    } else
#line 424
    if ((image->comps + 0)->prec != (image->comps + (i + 1))->prec) {
      {
#line 427
      fprintf(stderr, "Unable to create a tga file with such J2K image charateristics.");
      }
#line 428
      return (1);
    }
#line 423
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: 
#line 432
  width = (int )(image->comps + 0)->w;
#line 433
  height = (int )(image->comps + 0)->h;
#line 436
  if (image->numcomps == 2U) {
#line 436
    tmp___3 = 1;
  } else
#line 436
  if (image->numcomps == 4U) {
#line 436
    tmp___3 = 1;
  } else {
#line 436
    tmp___3 = 0;
  }
#line 436
  write_alpha = tmp___3;
#line 439
  if (write_alpha) {
#line 439
    tmp = 32;
  } else {
#line 439
    tmp = 24;
  }
  {
#line 439
  bpp = tmp;
#line 440
  __cil_tmp25 = tga_writeheader(fdest, bpp, width, height, 1);
  }
#line 440
  if (! __cil_tmp25) {
#line 441
    return (1);
  }
#line 443
  alpha_channel = image->numcomps - 1U;
#line 445
  scale = 255.f / (float )((1 << (image->comps + 0)->prec) - 1);
#line 447
  if ((image->comps + 0)->sgnd) {
#line 447
    tmp___0 = 1 << ((image->comps + 0)->prec - 1U);
  } else {
#line 447
    tmp___0 = 0;
  }
#line 447
  adjustR = tmp___0;
#line 448
  if ((image->comps + 1)->sgnd) {
#line 448
    tmp___1 = 1 << ((image->comps + 1)->prec - 1U);
  } else {
#line 448
    tmp___1 = 0;
  }
#line 448
  adjustG = tmp___1;
#line 449
  if ((image->comps + 2)->sgnd) {
#line 449
    tmp___2 = 1 << ((image->comps + 2)->prec - 1U);
  } else {
#line 449
    tmp___2 = 0;
  }
#line 449
  adjustB = tmp___2;
#line 451
  y = 0;
  {
#line 451
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 451
    if (! (y < height)) {
#line 451
      goto while_break___0;
    }
#line 452
    index___17 = (unsigned int )(y * width);
#line 454
    x = 0;
    {
#line 454
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 454
      if (! (x < width)) {
#line 454
        goto while_break___1;
      }
#line 455
      r = (float )(*((image->comps + 0)->data + index___17) + adjustR);
#line 457
      if (image->numcomps > 2U) {
#line 458
        g = (float )(*((image->comps + 1)->data + index___17) + adjustG);
#line 459
        b = (float )(*((image->comps + 2)->data + index___17) + adjustB);
      } else {
#line 462
        g = r;
#line 463
        b = r;
      }
      {
#line 467
      value = (unsigned char )(b * scale);
#line 468
      res = fwrite((void const   *)(& value), 1UL, 1UL, fdest);
      }
#line 469
      if (res < 1UL) {
        {
#line 470
        fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
        }
#line 471
        return (1);
      }
      {
#line 474
      value = (unsigned char )(g * scale);
#line 475
      res = fwrite((void const   *)(& value), 1UL, 1UL, fdest);
      }
#line 476
      if (res < 1UL) {
        {
#line 477
        fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
        }
#line 478
        return (1);
      }
      {
#line 481
      value = (unsigned char )(r * scale);
#line 482
      res = fwrite((void const   *)(& value), 1UL, 1UL, fdest);
      }
#line 483
      if (res < 1UL) {
        {
#line 484
        fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
        }
#line 485
        return (1);
      }
#line 488
      if (write_alpha) {
        {
#line 489
        a = (float )*((image->comps + alpha_channel)->data + index___17);
#line 490
        value = (unsigned char )(a * scale);
#line 491
        res = fwrite((void const   *)(& value), 1UL, 1UL, fdest);
        }
#line 492
        if (res < 1UL) {
          {
#line 493
          fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
          }
#line 494
          return (1);
        }
      }
#line 454
      __cil_tmp35 = index___17;
#line 454
      index___17 ++;
#line 454
      __cil_tmp34 = x;
#line 454
      x ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: 
#line 451
    y ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: ;
#line 500
  return (0);
}
}
#line 537 "/root/patron/new_22/src/bin/jp2/convert.c"
opj_image_t *bmptoimage(char const   *filename , opj_cparameters_t *parameters ) 
{ 
  int subsampling_dx ;
  int subsampling_dy ;
  int i ;
  int numcomps ;
  int w ;
  int h ;
  OPJ_COLOR_SPACE color_space ;
  opj_image_cmptparm_t cmptparm[3] ;
  opj_image_t *image ;
  FILE *IN ;
  BITMAPFILEHEADER_t File_h ;
  BITMAPINFOHEADER_t Info_h ;
  unsigned char *RGB ;
  unsigned char *table_R ;
  unsigned char *table_G ;
  unsigned char *table_B ;
  unsigned int j ;
  unsigned int PAD ;
  int x ;
  int y ;
  int index___18 ;
  int gray_scale ;
  int has_color ;
  DWORD W ;
  DWORD H ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  int __cil_tmp48 ;
  int __cil_tmp49 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;
  int __cil_tmp53 ;
  int __cil_tmp54 ;
  int __cil_tmp55 ;
  int __cil_tmp56 ;
  int __cil_tmp57 ;
  int __cil_tmp58 ;
  int __cil_tmp59 ;
  int __cil_tmp60 ;
  int __cil_tmp61 ;
  int __cil_tmp62 ;
  int __cil_tmp63 ;
  int __cil_tmp64 ;
  int __cil_tmp65 ;
  int __cil_tmp66 ;
  int __cil_tmp67 ;
  int __cil_tmp68 ;
  int __cil_tmp69 ;
  int __cil_tmp70 ;
  int __cil_tmp71 ;
  int __cil_tmp72 ;
  int __cil_tmp73 ;
  int __cil_tmp74 ;
  int __cil_tmp75 ;
  int __cil_tmp76 ;
  int __cil_tmp77 ;
  int __cil_tmp78 ;
  int __cil_tmp79 ;
  int __cil_tmp80 ;
  int __cil_tmp81 ;
  int __cil_tmp82 ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  void *__cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  unsigned char *scanline ;
  unsigned char *pixel ;
  void *__cil_tmp95 ;
  void *__cil_tmp96 ;
  void *__cil_tmp97 ;
  int __cil_tmp98 ;
  int __cil_tmp99 ;
  int __cil_tmp100 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  void *__cil_tmp109 ;
  unsigned long __cil_tmp110 ;
  unsigned char pixel_index ;
  unsigned char *pix ;
  unsigned char *beyond ;
  int *gray ;
  int *red ;
  int *green ;
  int *blue ;
  unsigned int x___20 ;
  unsigned int y___21 ;
  unsigned int max ;
  int i___22 ;
  int c ;
  int c1 ;
  unsigned char uc ;
  void *__cil_tmp129 ;
  void *__cil_tmp130 ;
  void *__cil_tmp131 ;
  int __cil_tmp132 ;
  int __cil_tmp133 ;
  int __cil_tmp134 ;
  int tmp___6 ;
  int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  void *__cil_tmp142 ;
  int __cil_tmp145 ;
  unsigned int __cil_tmp146 ;
  unsigned char *__cil_tmp147 ;
  int __cil_tmp152 ;
  unsigned int __cil_tmp153 ;
  unsigned char *__cil_tmp154 ;
  unsigned int __cil_tmp155 ;
  unsigned char *__cil_tmp156 ;
  int *__cil_tmp157 ;
  unsigned int __cil_tmp158 ;
  unsigned char *__cil_tmp159 ;
  int *__cil_tmp160 ;
  int *__cil_tmp161 ;
  int *__cil_tmp162 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  {
#line 539
  subsampling_dx = parameters->subsampling_dx;
#line 540
  subsampling_dy = parameters->subsampling_dy;
#line 545
  image = (opj_image_t *)((void *)0);
#line 552
  PAD = 0U;
#line 555
  gray_scale = 1;
#line 559
  IN = fopen(filename, "rb");
  }
#line 560
  if (! IN) {
    {
#line 562
    fprintf(stderr, "Failed to open %s for reading !!\n9\342\212\202U", filename);
    }
#line 563
    return ((opj_image_t *)((void *)0));
  }
  {
#line 566
  __cil_tmp29 = getc(IN);
#line 566
  File_h.bfType = (WORD )__cil_tmp29;
#line 567
  __cil_tmp30 = getc(IN);
#line 567
  File_h.bfType = (WORD )((__cil_tmp30 << 8) + (int )File_h.bfType);
  }
#line 569
  if ((int )File_h.bfType != 19778) {
    {
#line 571
    fprintf(stderr, "Error, not a BMP file!\n");
#line 572
    fclose(IN);
    }
#line 573
    return ((opj_image_t *)((void *)0));
  }
  {
#line 577
  __cil_tmp31 = getc(IN);
#line 577
  File_h.bfSize = (DWORD )__cil_tmp31;
#line 578
  __cil_tmp32 = getc(IN);
#line 578
  File_h.bfSize = (unsigned int )(__cil_tmp32 << 8) + File_h.bfSize;
#line 579
  __cil_tmp33 = getc(IN);
#line 579
  File_h.bfSize = (unsigned int )(__cil_tmp33 << 16) + File_h.bfSize;
#line 580
  __cil_tmp34 = getc(IN);
#line 580
  File_h.bfSize = (unsigned int )(__cil_tmp34 << 24) + File_h.bfSize;
#line 582
  __cil_tmp35 = getc(IN);
#line 582
  File_h.bfReserved1 = (WORD )__cil_tmp35;
#line 583
  __cil_tmp36 = getc(IN);
#line 583
  File_h.bfReserved1 = (WORD )((__cil_tmp36 << 8) + (int )File_h.bfReserved1);
#line 585
  __cil_tmp37 = getc(IN);
#line 585
  File_h.bfReserved2 = (WORD )__cil_tmp37;
#line 586
  __cil_tmp38 = getc(IN);
#line 586
  File_h.bfReserved2 = (WORD )((__cil_tmp38 << 8) + (int )File_h.bfReserved2);
#line 588
  __cil_tmp39 = getc(IN);
#line 588
  File_h.bfOffBits = (DWORD )__cil_tmp39;
#line 589
  __cil_tmp40 = getc(IN);
#line 589
  File_h.bfOffBits = (unsigned int )(__cil_tmp40 << 8) + File_h.bfOffBits;
#line 590
  __cil_tmp41 = getc(IN);
#line 590
  File_h.bfOffBits = (unsigned int )(__cil_tmp41 << 16) + File_h.bfOffBits;
#line 591
  __cil_tmp42 = getc(IN);
#line 591
  File_h.bfOffBits = (unsigned int )(__cil_tmp42 << 24) + File_h.bfOffBits;
#line 596
  __cil_tmp43 = getc(IN);
#line 596
  Info_h.biSize = (DWORD )__cil_tmp43;
#line 597
  __cil_tmp44 = getc(IN);
#line 597
  Info_h.biSize = (unsigned int )(__cil_tmp44 << 8) + Info_h.biSize;
#line 598
  __cil_tmp45 = getc(IN);
#line 598
  Info_h.biSize = (unsigned int )(__cil_tmp45 << 16) + Info_h.biSize;
#line 599
  __cil_tmp46 = getc(IN);
#line 599
  Info_h.biSize = (unsigned int )(__cil_tmp46 << 24) + Info_h.biSize;
  }
#line 601
  if (Info_h.biSize != 40U) {
    {
#line 603
    fprintf(stderr, "Error, unknown BMP header size %d\n\341\212\202U", Info_h.biSize);
#line 604
    fclose(IN);
    }
#line 605
    return ((opj_image_t *)((void *)0));
  }
  {
#line 607
  __cil_tmp47 = getc(IN);
#line 607
  Info_h.biWidth = (DWORD )__cil_tmp47;
#line 608
  __cil_tmp48 = getc(IN);
#line 608
  Info_h.biWidth = (unsigned int )(__cil_tmp48 << 8) + Info_h.biWidth;
#line 609
  __cil_tmp49 = getc(IN);
#line 609
  Info_h.biWidth = (unsigned int )(__cil_tmp49 << 16) + Info_h.biWidth;
#line 610
  __cil_tmp50 = getc(IN);
#line 610
  Info_h.biWidth = (unsigned int )(__cil_tmp50 << 24) + Info_h.biWidth;
#line 611
  w = (int )Info_h.biWidth;
#line 613
  __cil_tmp51 = getc(IN);
#line 613
  Info_h.biHeight = (DWORD )__cil_tmp51;
#line 614
  __cil_tmp52 = getc(IN);
#line 614
  Info_h.biHeight = (unsigned int )(__cil_tmp52 << 8) + Info_h.biHeight;
#line 615
  __cil_tmp53 = getc(IN);
#line 615
  Info_h.biHeight = (unsigned int )(__cil_tmp53 << 16) + Info_h.biHeight;
#line 616
  __cil_tmp54 = getc(IN);
#line 616
  Info_h.biHeight = (unsigned int )(__cil_tmp54 << 24) + Info_h.biHeight;
#line 617
  h = (int )Info_h.biHeight;
#line 619
  __cil_tmp55 = getc(IN);
#line 619
  Info_h.biPlanes = (WORD )__cil_tmp55;
#line 620
  __cil_tmp56 = getc(IN);
#line 620
  Info_h.biPlanes = (WORD )((__cil_tmp56 << 8) + (int )Info_h.biPlanes);
#line 622
  __cil_tmp57 = getc(IN);
#line 622
  Info_h.biBitCount = (WORD )__cil_tmp57;
#line 623
  __cil_tmp58 = getc(IN);
#line 623
  Info_h.biBitCount = (WORD )((__cil_tmp58 << 8) + (int )Info_h.biBitCount);
#line 625
  __cil_tmp59 = getc(IN);
#line 625
  Info_h.biCompression = (DWORD )__cil_tmp59;
#line 626
  __cil_tmp60 = getc(IN);
#line 626
  Info_h.biCompression = (unsigned int )(__cil_tmp60 << 8) + Info_h.biCompression;
#line 627
  __cil_tmp61 = getc(IN);
#line 627
  Info_h.biCompression = (unsigned int )(__cil_tmp61 << 16) + Info_h.biCompression;
#line 628
  __cil_tmp62 = getc(IN);
#line 628
  Info_h.biCompression = (unsigned int )(__cil_tmp62 << 24) + Info_h.biCompression;
#line 630
  __cil_tmp63 = getc(IN);
#line 630
  Info_h.biSizeImage = (DWORD )__cil_tmp63;
#line 631
  __cil_tmp64 = getc(IN);
#line 631
  Info_h.biSizeImage = (unsigned int )(__cil_tmp64 << 8) + Info_h.biSizeImage;
#line 632
  __cil_tmp65 = getc(IN);
#line 632
  Info_h.biSizeImage = (unsigned int )(__cil_tmp65 << 16) + Info_h.biSizeImage;
#line 633
  __cil_tmp66 = getc(IN);
#line 633
  Info_h.biSizeImage = (unsigned int )(__cil_tmp66 << 24) + Info_h.biSizeImage;
#line 635
  __cil_tmp67 = getc(IN);
#line 635
  Info_h.biXpelsPerMeter = (DWORD )__cil_tmp67;
#line 636
  __cil_tmp68 = getc(IN);
#line 636
  Info_h.biXpelsPerMeter = (unsigned int )(__cil_tmp68 << 8) + Info_h.biXpelsPerMeter;
#line 637
  __cil_tmp69 = getc(IN);
#line 637
  Info_h.biXpelsPerMeter = (unsigned int )(__cil_tmp69 << 16) + Info_h.biXpelsPerMeter;
#line 638
  __cil_tmp70 = getc(IN);
#line 638
  Info_h.biXpelsPerMeter = (unsigned int )(__cil_tmp70 << 24) + Info_h.biXpelsPerMeter;
#line 640
  __cil_tmp71 = getc(IN);
#line 640
  Info_h.biYpelsPerMeter = (DWORD )__cil_tmp71;
#line 641
  __cil_tmp72 = getc(IN);
#line 641
  Info_h.biYpelsPerMeter = (unsigned int )(__cil_tmp72 << 8) + Info_h.biYpelsPerMeter;
#line 642
  __cil_tmp73 = getc(IN);
#line 642
  Info_h.biYpelsPerMeter = (unsigned int )(__cil_tmp73 << 16) + Info_h.biYpelsPerMeter;
#line 643
  __cil_tmp74 = getc(IN);
#line 643
  Info_h.biYpelsPerMeter = (unsigned int )(__cil_tmp74 << 24) + Info_h.biYpelsPerMeter;
#line 645
  __cil_tmp75 = getc(IN);
#line 645
  Info_h.biClrUsed = (DWORD )__cil_tmp75;
#line 646
  __cil_tmp76 = getc(IN);
#line 646
  Info_h.biClrUsed = (unsigned int )(__cil_tmp76 << 8) + Info_h.biClrUsed;
#line 647
  __cil_tmp77 = getc(IN);
#line 647
  Info_h.biClrUsed = (unsigned int )(__cil_tmp77 << 16) + Info_h.biClrUsed;
#line 648
  __cil_tmp78 = getc(IN);
#line 648
  Info_h.biClrUsed = (unsigned int )(__cil_tmp78 << 24) + Info_h.biClrUsed;
#line 650
  __cil_tmp79 = getc(IN);
#line 650
  Info_h.biClrImportant = (DWORD )__cil_tmp79;
#line 651
  __cil_tmp80 = getc(IN);
#line 651
  Info_h.biClrImportant = (unsigned int )(__cil_tmp80 << 8) + Info_h.biClrImportant;
#line 652
  __cil_tmp81 = getc(IN);
#line 652
  Info_h.biClrImportant = (unsigned int )(__cil_tmp81 << 16) + Info_h.biClrImportant;
#line 653
  __cil_tmp82 = getc(IN);
#line 653
  Info_h.biClrImportant = (unsigned int )(__cil_tmp82 << 24) + Info_h.biClrImportant;
  }
#line 657
  if ((int )Info_h.biBitCount == 24) {
    {
#line 659
    numcomps = 3;
#line 660
    color_space = (OPJ_COLOR_SPACE )1;
#line 662
    memset((void *)(& cmptparm[0]), 0, 3UL * sizeof(opj_image_cmptparm_t ));
#line 663
    i = 0;
    }
    {
#line 663
    while (1) {
      while_continue: /* CIL Label */ ;

#line 663
      if (! (i < numcomps)) {
#line 663
        goto while_break;
      }
#line 665
      cmptparm[i].prec = (OPJ_UINT32 )8;
#line 666
      cmptparm[i].bpp = (OPJ_UINT32 )8;
#line 667
      cmptparm[i].sgnd = (OPJ_UINT32 )0;
#line 668
      cmptparm[i].dx = (OPJ_UINT32 )subsampling_dx;
#line 669
      cmptparm[i].dy = (OPJ_UINT32 )subsampling_dy;
#line 670
      cmptparm[i].w = (OPJ_UINT32 )w;
#line 671
      cmptparm[i].h = (OPJ_UINT32 )h;
#line 663
      i ++;
    }
    while_break___13: /* CIL Label */ ;
    }
    while_break: 
    {
#line 674
    image = opj_image_create((OPJ_UINT32 )numcomps, & cmptparm[0], color_space);
    }
#line 675
    if (! image) {
      {
#line 677
      fclose(IN);
      }
#line 678
      return ((opj_image_t *)((void *)0));
    }
#line 682
    image->x0 = (OPJ_UINT32 )parameters->image_offset_x0;
#line 683
    image->y0 = (OPJ_UINT32 )parameters->image_offset_y0;
#line 684
    if (! image->x0) {
#line 684
      tmp = (unsigned int )((w - 1) * subsampling_dx + 1);
    } else {
#line 684
      tmp = (image->x0 + (unsigned int )((w - 1) * subsampling_dx)) + 1U;
    }
#line 684
    image->x1 = tmp;
#line 685
    if (! image->y0) {
#line 685
      tmp___0 = (unsigned int )((h - 1) * subsampling_dy + 1);
    } else {
#line 685
      tmp___0 = (image->y0 + (unsigned int )((h - 1) * subsampling_dy)) + 1U;
    }
    {
#line 685
    image->y1 = tmp___0;
#line 690
    fseek(IN, 0L, 0);
#line 691
    fseek(IN, (long )File_h.bfOffBits, 0);
#line 693
    W = Info_h.biWidth;
#line 694
    H = Info_h.biHeight;
    }
#line 698
    if ((3U * W) % 4U) {
#line 698
      tmp___1 = 4U - (3U * W) % 4U;
    } else {
#line 698
      tmp___1 = 0U;
    }
    {
#line 698
    PAD = tmp___1;
#line 700
    __cil_tmp88 = malloc((unsigned long )((3U * W + PAD) * H) * sizeof(unsigned char ));
#line 700
    RGB = (unsigned char *)__cil_tmp88;
#line 703
    __cil_tmp89 = fread((void *)RGB, sizeof(unsigned char ), (unsigned long )((3U * W + PAD) * H),
                        IN);
    }
#line 703
    if (__cil_tmp89 != (unsigned long )((3U * W + PAD) * H)) {
      {
#line 705
      free((void *)RGB);
#line 706
      opj_image_destroy(image);
#line 707
      fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
      }
#line 708
      return ((opj_image_t *)((void *)0));
    }
#line 711
    index___18 = 0;
#line 713
    y = 0;
    {
#line 713
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 713
      if (! (y < (int )H)) {
#line 713
        goto while_break___0;
      }
#line 715
      scanline = RGB + (3U * W + PAD) * ((H - 1U) - (unsigned int )y);
#line 716
      x = 0;
      {
#line 716
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 716
        if (! (x < (int )W)) {
#line 716
          goto while_break___1;
        }
#line 718
        pixel = scanline + 3 * x;
#line 719
        *((image->comps + 0)->data + index___18) = (OPJ_INT32 )*(pixel + 2);
#line 720
        *((image->comps + 1)->data + index___18) = (OPJ_INT32 )*(pixel + 1);
#line 721
        *((image->comps + 2)->data + index___18) = (OPJ_INT32 )*(pixel + 0);
#line 722
        index___18 ++;
#line 716
        x ++;
      }
      while_break___15: /* CIL Label */ ;
      }
      while_break___1: 
#line 713
      y ++;
    }
    while_break___14: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 725
    free((void *)RGB);
    }
  } else
#line 728
  if ((int )Info_h.biBitCount == 8) {
#line 728
    if (Info_h.biCompression == 0U) {
#line 730
      if (Info_h.biClrUsed == 0U) {
#line 730
        Info_h.biClrUsed = (DWORD )256;
      } else
#line 732
      if (Info_h.biClrUsed > 256U) {
#line 732
        Info_h.biClrUsed = (DWORD )256;
      }
      {
#line 734
      __cil_tmp95 = malloc(256UL * sizeof(unsigned char ));
#line 734
      table_R = (unsigned char *)__cil_tmp95;
#line 735
      __cil_tmp96 = malloc(256UL * sizeof(unsigned char ));
#line 735
      table_G = (unsigned char *)__cil_tmp96;
#line 736
      __cil_tmp97 = malloc(256UL * sizeof(unsigned char ));
#line 736
      table_B = (unsigned char *)__cil_tmp97;
#line 738
      has_color = 0;
#line 739
      j = 0U;
      }
      {
#line 739
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 739
        if (! (j < Info_h.biClrUsed)) {
#line 739
          goto while_break___2;
        }
        {
#line 741
        __cil_tmp98 = getc(IN);
#line 741
        *(table_B + j) = (unsigned char )__cil_tmp98;
#line 742
        __cil_tmp99 = getc(IN);
#line 742
        *(table_G + j) = (unsigned char )__cil_tmp99;
#line 743
        __cil_tmp100 = getc(IN);
#line 743
        *(table_R + j) = (unsigned char )__cil_tmp100;
#line 744
        getc(IN);
        }
#line 745
        if ((int )*(table_R + j) == (int )*(table_G + j)) {
#line 745
          if ((int )*(table_R + j) == (int )*(table_B + j)) {
#line 745
            tmp___10 = 0;
          } else {
#line 745
            tmp___10 = 1;
          }
        } else {
#line 745
          tmp___10 = 1;
        }
#line 745
        has_color += tmp___10;
#line 739
        j ++;
      }
      while_break___16: /* CIL Label */ ;
      }
      while_break___2: ;
#line 748
      if (has_color) {
#line 748
        gray_scale = 0;
      }
      {
#line 751
      fseek(IN, 0L, 0);
#line 752
      fseek(IN, (long )File_h.bfOffBits, 0);
#line 754
      W = Info_h.biWidth;
#line 755
      H = Info_h.biHeight;
      }
#line 756
      if (Info_h.biWidth % 2U) {
#line 757
        W ++;
      }
#line 759
      if (gray_scale) {
#line 759
        tmp___2 = 1;
      } else {
#line 759
        tmp___2 = 3;
      }
#line 759
      numcomps = tmp___2;
#line 760
      if (gray_scale) {
#line 760
        tmp___3 = 2;
      } else {
#line 760
        tmp___3 = 1;
      }
      {
#line 760
      color_space = (OPJ_COLOR_SPACE )tmp___3;
#line 762
      memset((void *)(& cmptparm[0]), 0, 3UL * sizeof(opj_image_cmptparm_t ));
#line 763
      i = 0;
      }
      {
#line 763
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 763
        if (! (i < numcomps)) {
#line 763
          goto while_break___3;
        }
#line 765
        cmptparm[i].prec = (OPJ_UINT32 )8;
#line 766
        cmptparm[i].bpp = (OPJ_UINT32 )8;
#line 767
        cmptparm[i].sgnd = (OPJ_UINT32 )0;
#line 768
        cmptparm[i].dx = (OPJ_UINT32 )subsampling_dx;
#line 769
        cmptparm[i].dy = (OPJ_UINT32 )subsampling_dy;
#line 770
        cmptparm[i].w = (OPJ_UINT32 )w;
#line 771
        cmptparm[i].h = (OPJ_UINT32 )h;
#line 763
        i ++;
      }
      while_break___17: /* CIL Label */ ;
      }
      while_break___3: 
      {
#line 774
      image = opj_image_create((OPJ_UINT32 )numcomps, & cmptparm[0], color_space);
      }
#line 775
      if (! image) {
        {
#line 777
        fclose(IN);
#line 778
        free((void *)table_R);
#line 778
        free((void *)table_G);
#line 778
        free((void *)table_B);
        }
#line 779
        return ((opj_image_t *)((void *)0));
      }
#line 783
      image->x0 = (OPJ_UINT32 )parameters->image_offset_x0;
#line 784
      image->y0 = (OPJ_UINT32 )parameters->image_offset_y0;
#line 785
      if (! image->x0) {
#line 785
        tmp___4 = (unsigned int )((w - 1) * subsampling_dx + 1);
      } else {
#line 785
        tmp___4 = (image->x0 + (unsigned int )((w - 1) * subsampling_dx)) + 1U;
      }
#line 785
      image->x1 = tmp___4;
#line 786
      if (! image->y0) {
#line 786
        tmp___5 = (unsigned int )((h - 1) * subsampling_dy + 1);
      } else {
#line 786
        tmp___5 = (image->y0 + (unsigned int )((h - 1) * subsampling_dy)) + 1U;
      }
      {
#line 786
      image->y1 = tmp___5;
#line 790
      __cil_tmp109 = malloc((unsigned long )(W * H) * sizeof(unsigned char ));
#line 790
      RGB = (unsigned char *)__cil_tmp109;
#line 792
      __cil_tmp110 = fread((void *)RGB, sizeof(unsigned char ), (unsigned long )(W * H),
                           IN);
      }
#line 792
      if (__cil_tmp110 != (unsigned long )(W * H)) {
        {
#line 794
        free((void *)table_R);
#line 795
        free((void *)table_G);
#line 796
        free((void *)table_B);
#line 797
        free((void *)RGB);
#line 798
        opj_image_destroy(image);
#line 799
        fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
        }
#line 800
        return ((opj_image_t *)((void *)0));
      }
#line 802
      if (gray_scale) {
#line 804
        index___18 = 0;
#line 805
        j = 0U;
        {
#line 805
        while (1) {
          while_continue___4: /* CIL Label */ ;

#line 805
          if (! (j < W * H)) {
#line 805
            goto while_break___4;
          }
#line 807
          if (j % W < W - 1U) {
#line 807
            if (Info_h.biWidth % 2U) {
#line 809
              *((image->comps + 0)->data + index___18) = (OPJ_INT32 )*(table_R + (int )*(RGB + ((W * H - (j / W + 1U) * W) + j % W)));
#line 811
              index___18 ++;
            } else {
#line 807
              goto _L;
            }
          } else
          _L: 
#line 807
          if (! (Info_h.biWidth % 2U)) {
#line 809
            *((image->comps + 0)->data + index___18) = (OPJ_INT32 )*(table_R + (int )*(RGB + ((W * H - (j / W + 1U) * W) + j % W)));
#line 811
            index___18 ++;
          }
#line 805
          j ++;
        }
        while_break___18: /* CIL Label */ ;
        }
        while_break___4: ;
      } else {
#line 818
        index___18 = 0;
#line 819
        j = 0U;
        {
#line 819
        while (1) {
          while_continue___5: /* CIL Label */ ;

#line 819
          if (! (j < W * H)) {
#line 819
            goto while_break___5;
          }
#line 821
          if (j % W < W - 1U) {
#line 821
            if (Info_h.biWidth % 2U) {
#line 824
              pixel_index = *(RGB + ((W * H - (j / W + 1U) * W) + j % W));
#line 826
              *((image->comps + 0)->data + index___18) = (OPJ_INT32 )*(table_R + (int )pixel_index);
#line 827
              *((image->comps + 1)->data + index___18) = (OPJ_INT32 )*(table_G + (int )pixel_index);
#line 828
              *((image->comps + 2)->data + index___18) = (OPJ_INT32 )*(table_B + (int )pixel_index);
#line 829
              index___18 ++;
            } else {
#line 821
              goto _L___19;
            }
          } else
          _L___19: 
#line 821
          if (! (Info_h.biWidth % 2U)) {
#line 824
            pixel_index = *(RGB + ((W * H - (j / W + 1U) * W) + j % W));
#line 826
            *((image->comps + 0)->data + index___18) = (OPJ_INT32 )*(table_R + (int )pixel_index);
#line 827
            *((image->comps + 1)->data + index___18) = (OPJ_INT32 )*(table_G + (int )pixel_index);
#line 828
            *((image->comps + 2)->data + index___18) = (OPJ_INT32 )*(table_B + (int )pixel_index);
#line 829
            index___18 ++;
          }
#line 819
          j ++;
        }
        while_break___19: /* CIL Label */ ;
        }
        while_break___5: ;
      }
      {
#line 833
      free((void *)RGB);
#line 834
      free((void *)table_R);
#line 835
      free((void *)table_G);
#line 836
      free((void *)table_B);
      }
    } else {
#line 728
      goto _L___23;
    }
  } else
  _L___23: 
#line 839
  if ((int )Info_h.biBitCount == 8) {
#line 839
    if (Info_h.biCompression == 1U) {
#line 847
      if (Info_h.biClrUsed == 0U) {
#line 848
        Info_h.biClrUsed = (DWORD )256;
      } else
#line 849
      if (Info_h.biClrUsed > 256U) {
#line 850
        Info_h.biClrUsed = (DWORD )256;
      }
      {
#line 852
      __cil_tmp129 = malloc(256UL * sizeof(unsigned char ));
#line 852
      table_R = (unsigned char *)__cil_tmp129;
#line 853
      __cil_tmp130 = malloc(256UL * sizeof(unsigned char ));
#line 853
      table_G = (unsigned char *)__cil_tmp130;
#line 854
      __cil_tmp131 = malloc(256UL * sizeof(unsigned char ));
#line 854
      table_B = (unsigned char *)__cil_tmp131;
#line 856
      has_color = 0;
#line 857
      j = 0U;
      }
      {
#line 857
      while (1) {
        while_continue___6: /* CIL Label */ ;

#line 857
        if (! (j < Info_h.biClrUsed)) {
#line 857
          goto while_break___6;
        }
        {
#line 859
        __cil_tmp132 = getc(IN);
#line 859
        *(table_B + j) = (unsigned char )__cil_tmp132;
#line 860
        __cil_tmp133 = getc(IN);
#line 860
        *(table_G + j) = (unsigned char )__cil_tmp133;
#line 861
        __cil_tmp134 = getc(IN);
#line 861
        *(table_R + j) = (unsigned char )__cil_tmp134;
#line 862
        getc(IN);
        }
#line 863
        if ((int )*(table_R + j) == (int )*(table_G + j)) {
#line 863
          if ((int )*(table_R + j) == (int )*(table_B + j)) {
#line 863
            tmp___11 = 0;
          } else {
#line 863
            tmp___11 = 1;
          }
        } else {
#line 863
          tmp___11 = 1;
        }
#line 863
        has_color += tmp___11;
#line 857
        j ++;
      }
      while_break___20: /* CIL Label */ ;
      }
      while_break___6: ;
#line 866
      if (has_color) {
#line 867
        gray_scale = 0;
      }
#line 869
      if (gray_scale) {
#line 869
        tmp___6 = 1;
      } else {
#line 869
        tmp___6 = 3;
      }
#line 869
      numcomps = tmp___6;
#line 870
      if (gray_scale) {
#line 870
        tmp___7 = 2;
      } else {
#line 870
        tmp___7 = 1;
      }
      {
#line 870
      color_space = (OPJ_COLOR_SPACE )tmp___7;
#line 872
      memset((void *)(& cmptparm[0]), 0, 3UL * sizeof(opj_image_cmptparm_t ));
#line 873
      i___22 = 0;
      }
      {
#line 873
      while (1) {
        while_continue___7: /* CIL Label */ ;

#line 873
        if (! (i___22 < numcomps)) {
#line 873
          goto while_break___7;
        }
#line 875
        cmptparm[i___22].prec = (OPJ_UINT32 )8;
#line 876
        cmptparm[i___22].bpp = (OPJ_UINT32 )8;
#line 877
        cmptparm[i___22].sgnd = (OPJ_UINT32 )0;
#line 878
        cmptparm[i___22].dx = (OPJ_UINT32 )subsampling_dx;
#line 879
        cmptparm[i___22].dy = (OPJ_UINT32 )subsampling_dy;
#line 880
        cmptparm[i___22].w = (OPJ_UINT32 )w;
#line 881
        cmptparm[i___22].h = (OPJ_UINT32 )h;
#line 873
        i___22 ++;
      }
      while_break___21: /* CIL Label */ ;
      }
      while_break___7: 
      {
#line 884
      image = opj_image_create((OPJ_UINT32 )numcomps, & cmptparm[0], color_space);
      }
#line 885
      if (! image) {
        {
#line 887
        fclose(IN);
#line 888
        free((void *)table_R);
#line 889
        free((void *)table_G);
#line 890
        free((void *)table_B);
        }
#line 891
        return ((opj_image_t *)((void *)0));
      }
#line 895
      image->x0 = (OPJ_UINT32 )parameters->image_offset_x0;
#line 896
      image->y0 = (OPJ_UINT32 )parameters->image_offset_y0;
#line 897
      if (! image->x0) {
#line 897
        tmp___8 = (unsigned int )((w - 1) * subsampling_dx + 1);
      } else {
#line 897
        tmp___8 = (image->x0 + (unsigned int )((w - 1) * subsampling_dx)) + 1U;
      }
#line 897
      image->x1 = tmp___8;
#line 899
      if (! image->y0) {
#line 899
        tmp___9 = (unsigned int )((h - 1) * subsampling_dy + 1);
      } else {
#line 899
        tmp___9 = (image->y0 + (unsigned int )((h - 1) * subsampling_dy)) + 1U;
      }
      {
#line 899
      image->y1 = tmp___9;
#line 905
      fseek(IN, 0L, 0);
#line 906
      fseek(IN, (long )File_h.bfOffBits, 0);
#line 908
      W = Info_h.biWidth;
#line 909
      H = Info_h.biHeight;
#line 910
      __cil_tmp142 = calloc(1UL, (unsigned long )(W * H) * sizeof(unsigned char ));
#line 910
      RGB = (unsigned char *)__cil_tmp142;
#line 911
      beyond = RGB + W * H;
#line 912
      pix = beyond - W;
#line 913
      y___21 = 0U;
#line 913
      x___20 = y___21;
      }
      {
#line 915
      while (1) {
        while_continue___8: /* CIL Label */ ;

#line 915
        if (! (y___21 < H)) {
#line 915
          goto while_break___8;
        }
        {
#line 917
        c = getc(IN);
        }
#line 919
        if (c) {
          {
#line 921
          c1 = getc(IN);
#line 923
          i___22 = 0;
          }
          {
#line 923
          while (1) {
            while_continue___9: /* CIL Label */ ;

#line 923
            if ((unsigned long )pix < (unsigned long )beyond) {
#line 923
              if (i___22 < c) {
#line 923
                if (! (x___20 < W)) {
#line 923
                  goto while_break___9;
                }
              } else {
#line 923
                goto while_break___9;
              }
            } else {
#line 923
              goto while_break___9;
            }
#line 924
            *pix = (unsigned char )c1;
#line 923
            __cil_tmp147 = pix;
#line 923
            pix ++;
#line 923
            __cil_tmp146 = x___20;
#line 923
            x___20 ++;
#line 923
            __cil_tmp145 = i___22;
#line 923
            i___22 ++;
          }
          while_break___23: /* CIL Label */ ;
          }
          while_break___9: ;
        } else {
          {
#line 928
          c = getc(IN);
          }
#line 930
          if (c == 0) {
#line 932
            x___20 = 0U;
#line 933
            y___21 ++;
#line 934
            pix = (RGB + x___20) + ((H - y___21) - 1U) * W;
          } else
#line 936
          if (c == 1) {
#line 937
            goto while_break___8;
          } else
#line 938
          if (c == 2) {
            {
#line 940
            c = getc(IN);
#line 941
            x___20 += (unsigned int )c;
#line 942
            c = getc(IN);
#line 943
            y___21 += (unsigned int )c;
#line 944
            pix = (RGB + ((H - y___21) - 1U) * W) + x___20;
            }
          } else {
#line 948
            i___22 = 0;
            {
#line 949
            while (1) {
              while_continue___10: /* CIL Label */ ;

#line 949
              if ((unsigned long )pix < (unsigned long )beyond) {
#line 949
                if (i___22 < c) {
#line 949
                  if (! (x___20 < W)) {
#line 949
                    goto while_break___10;
                  }
                } else {
#line 949
                  goto while_break___10;
                }
              } else {
#line 949
                goto while_break___10;
              }
              {
#line 951
              c1 = getc(IN);
#line 952
              *pix = (unsigned char )c1;
#line 949
              __cil_tmp154 = pix;
#line 949
              pix ++;
#line 949
              __cil_tmp153 = x___20;
#line 949
              x___20 ++;
#line 949
              __cil_tmp152 = i___22;
#line 949
              i___22 ++;
              }
            }
            while_break___24: /* CIL Label */ ;
            }
            while_break___10: ;
#line 954
            if (c & 1) {
              {
#line 955
              getc(IN);
              }
            }
          }
        }
      }
      while_break___22: /* CIL Label */ ;
      }
      while_break___8: ;
#line 960
      if (gray_scale) {
#line 962
        gray = (image->comps + 0)->data;
#line 963
        pix = RGB;
#line 964
        max = W * H;
        {
#line 966
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 966
          __cil_tmp155 = max;
#line 966
          max --;
#line 966
          if (! __cil_tmp155) {
#line 966
            goto while_break___11;
          }
#line 968
          __cil_tmp156 = pix;
#line 968
          pix ++;
#line 968
          uc = *__cil_tmp156;
#line 970
          __cil_tmp157 = gray;
#line 970
          gray ++;
#line 970
          *__cil_tmp157 = (int )*(table_R + (int )uc);
        }
        while_break___25: /* CIL Label */ ;
        }
        while_break___11: ;
      } else {
#line 977
        red = (image->comps + 0)->data;
#line 978
        green = (image->comps + 1)->data;
#line 979
        blue = (image->comps + 2)->data;
#line 980
        pix = RGB;
#line 981
        max = W * H;
        {
#line 983
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 983
          __cil_tmp158 = max;
#line 983
          max --;
#line 983
          if (! __cil_tmp158) {
#line 983
            goto while_break___12;
          }
#line 985
          __cil_tmp159 = pix;
#line 985
          pix ++;
#line 985
          uc = *__cil_tmp159;
#line 987
          __cil_tmp160 = red;
#line 987
          red ++;
#line 987
          *__cil_tmp160 = (int )*(table_R + (int )uc);
#line 988
          __cil_tmp161 = green;
#line 988
          green ++;
#line 988
          *__cil_tmp161 = (int )*(table_G + (int )uc);
#line 989
          __cil_tmp162 = blue;
#line 989
          blue ++;
#line 989
          *__cil_tmp162 = (int )*(table_B + (int )uc);
        }
        while_break___26: /* CIL Label */ ;
        }
        while_break___12: ;
      }
      {
#line 992
      free((void *)RGB);
#line 993
      free((void *)table_R);
#line 994
      free((void *)table_G);
#line 995
      free((void *)table_B);
      }
    } else {
      {
#line 999
      fprintf(stderr, "Other system than 24 bits/pixels or 8 bits (no RLE coding) is not yet implemented [%d]\n",
              (int )Info_h.biBitCount);
      }
    }
  } else {
    {
#line 999
    fprintf(stderr, "Other system than 24 bits/pixels or 8 bits (no RLE coding) is not yet implemented [%d]\n",
            (int )Info_h.biBitCount);
    }
  }
  {
#line 1003
  fclose(IN);
  }
#line 1004
  return (image);
}
}
#line 1007 "/root/patron/new_22/src/bin/jp2/convert.c"
int imagetobmp(opj_image_t *image , char const   *outfile ) 
{ 
  int w ;
  int h ;
  int i ;
  int pad ;
  FILE *fdest ;
  int adjustR ;
  int adjustG ;
  int adjustB ;
  unsigned char rc ;
  unsigned char gc ;
  unsigned char bc ;
  int r ;
  int g ;
  int b ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int __cil_tmp22 ;
  int r___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int __cil_tmp29 ;

  {
#line 1010
  fdest = (FILE *)((void *)0);
#line 1013
  if ((image->comps + 0)->prec < 8U) {
    {
#line 1014
    fprintf(stderr, "Unsupported number of components: %d\n", (image->comps + 0)->prec);
    }
#line 1015
    return (1);
  }
#line 1017
  if (image->numcomps >= 3U) {
#line 1017
    if ((image->comps + 0)->dx == (image->comps + 1)->dx) {
#line 1017
      if ((image->comps + 1)->dx == (image->comps + 2)->dx) {
#line 1017
        if ((image->comps + 0)->dy == (image->comps + 1)->dy) {
#line 1017
          if ((image->comps + 1)->dy == (image->comps + 2)->dy) {
#line 1017
            if ((image->comps + 0)->prec == (image->comps + 1)->prec) {
#line 1017
              if ((image->comps + 1)->prec == (image->comps + 2)->prec) {
                {
#line 1028
                fdest = fopen(outfile, "wb");
                }
#line 1029
                if (! fdest) {
                  {
#line 1030
                  fprintf(stderr, "ERROR -> failed to open %s for writing\n", outfile);
                  }
#line 1031
                  return (1);
                }
                {
#line 1034
                w = (int )(image->comps + 0)->w;
#line 1035
                h = (int )(image->comps + 0)->h;
#line 1037
                fprintf(fdest, "BM");
#line 1041
                fprintf(fdest, "%c%c%c%c\230\001", (int )((unsigned char )(((h * w) * 3 + (3 * h) * (w % 2)) + 54)) & 255,
                        (int )((unsigned char )((((h * w) * 3 + (3 * h) * (w % 2)) + 54) >> 8)) & 255,
                        (int )((unsigned char )((((h * w) * 3 + (3 * h) * (w % 2)) + 54) >> 16)) & 255,
                        (int )((unsigned char )((((h * w) * 3 + (3 * h) * (w % 2)) + 54) >> 24)) & 255);
#line 1046
                fprintf(fdest, "%c%c%c%c\251", 0, 0, 0, 0);
#line 1047
                fprintf(fdest, "%c%c%c%c\251", 54, (54 >> 8) & 255, (54 >> 16) & 255,
                        (54 >> 24) & 255);
#line 1051
                fprintf(fdest, "%c%c%c%c\251", 40, (40 >> 8) & 255, (40 >> 16) & 255,
                        (40 >> 24) & 255);
#line 1052
                fprintf(fdest, "%c%c%c%c\230\001", (int )((unsigned char )(w & 255)),
                        (int )((unsigned char )(w >> 8)) & 255, (int )((unsigned char )(w >> 16)) & 255,
                        (int )((unsigned char )(w >> 24)) & 255);
#line 1056
                fprintf(fdest, "%c%c%c%c\230\001", (int )((unsigned char )(h & 255)),
                        (int )((unsigned char )(h >> 8)) & 255, (int )((unsigned char )(h >> 16)) & 255,
                        (int )((unsigned char )(h >> 24)) & 255);
#line 1060
                fprintf(fdest, "%c%c", 1, (1 >> 8) & 255);
#line 1061
                fprintf(fdest, "%c%c\202U", 24, (24 >> 8) & 255);
#line 1062
                fprintf(fdest, "%c%c%c%c\251", 0, 0, 0, 0);
#line 1063
                fprintf(fdest, "%c%c%c%c\251", (int )((unsigned char )((3 * h) * w + (3 * h) * (w % 2))) & 255,
                        (int )((unsigned char )(((h * w) * 3 + (3 * h) * (w % 2)) >> 8)) & 255,
                        (int )((unsigned char )(((h * w) * 3 + (3 * h) * (w % 2)) >> 16)) & 255,
                        (int )((unsigned char )(((h * w) * 3 + (3 * h) * (w % 2)) >> 24)) & 255);
#line 1067
                fprintf(fdest, "%c%c%c%c\251", 154, (7834 >> 8) & 255, (7834 >> 16) & 255,
                        (7834 >> 24) & 255);
#line 1068
                fprintf(fdest, "%c%c%c%c\251", 154, (7834 >> 8) & 255, (7834 >> 16) & 255,
                        (7834 >> 24) & 255);
#line 1069
                fprintf(fdest, "%c%c%c%c\251", 0, 0, 0, 0);
#line 1070
                fprintf(fdest, "%c%c%c%c\251", 0, 0, 0, 0);
                }
#line 1072
                if ((image->comps + 0)->prec > 8U) {
                  {
#line 1073
                  adjustR = (int )((image->comps + 0)->prec - 8U);
#line 1074
                  printf("BMP CONVERSION: Truncating component 0 from %d bits to 8 bits\n",
                         (image->comps + 0)->prec);
                  }
                } else {
#line 1077
                  adjustR = 0;
                }
#line 1078
                if ((image->comps + 1)->prec > 8U) {
                  {
#line 1079
                  adjustG = (int )((image->comps + 1)->prec - 8U);
#line 1080
                  printf("BMP CONVERSION: Truncating component 1 from %d bits to 8 bits\n",
                         (image->comps + 1)->prec);
                  }
                } else {
#line 1083
                  adjustG = 0;
                }
#line 1084
                if ((image->comps + 2)->prec > 8U) {
                  {
#line 1085
                  adjustB = (int )((image->comps + 2)->prec - 8U);
#line 1086
                  printf("BMP CONVERSION: Truncating component 2 from %d bits to 8 bits\n",
                         (image->comps + 2)->prec);
                  }
                } else {
#line 1089
                  adjustB = 0;
                }
#line 1091
                i = 0;
                {
#line 1091
                while (1) {
                  while_continue: /* CIL Label */ ;

#line 1091
                  if (! (i < w * h)) {
#line 1091
                    goto while_break;
                  }
#line 1095
                  r = *((image->comps + 0)->data + ((w * h - (i / w + 1) * w) + i % w));
#line 1096
                  if ((image->comps + 0)->sgnd) {
#line 1096
                    tmp = 1 << ((image->comps + 0)->prec - 1U);
                  } else {
#line 1096
                    tmp = 0;
                  }
#line 1096
                  r += tmp;
#line 1097
                  r = (r >> adjustR) + (r >> (adjustR - 1)) % 2;
#line 1098
                  if (r > 255) {
#line 1098
                    r = 255;
                  } else
#line 1098
                  if (r < 0) {
#line 1098
                    r = 0;
                  }
#line 1099
                  rc = (unsigned char )r;
#line 1101
                  g = *((image->comps + 1)->data + ((w * h - (i / w + 1) * w) + i % w));
#line 1102
                  if ((image->comps + 1)->sgnd) {
#line 1102
                    tmp___0 = 1 << ((image->comps + 1)->prec - 1U);
                  } else {
#line 1102
                    tmp___0 = 0;
                  }
#line 1102
                  g += tmp___0;
#line 1103
                  g = (g >> adjustG) + (g >> (adjustG - 1)) % 2;
#line 1104
                  if (g > 255) {
#line 1104
                    g = 255;
                  } else
#line 1104
                  if (g < 0) {
#line 1104
                    g = 0;
                  }
#line 1105
                  gc = (unsigned char )g;
#line 1107
                  b = *((image->comps + 2)->data + ((w * h - (i / w + 1) * w) + i % w));
#line 1108
                  if ((image->comps + 2)->sgnd) {
#line 1108
                    tmp___1 = 1 << ((image->comps + 2)->prec - 1U);
                  } else {
#line 1108
                    tmp___1 = 0;
                  }
#line 1108
                  b += tmp___1;
#line 1109
                  b = (b >> adjustB) + (b >> (adjustB - 1)) % 2;
#line 1110
                  if (b > 255) {
#line 1110
                    b = 255;
                  } else
#line 1110
                  if (b < 0) {
#line 1110
                    b = 0;
                  }
                  {
#line 1111
                  bc = (unsigned char )b;
#line 1113
                  fprintf(fdest, "%c%c%c", (int )bc, (int )gc, (int )rc);
                  }
#line 1115
                  if ((i + 1) % w == 0) {
#line 1116
                    if ((3 * w) % 4) {
#line 1116
                      tmp___2 = 4 - (3 * w) % 4;
                    } else {
#line 1116
                      tmp___2 = 0;
                    }
#line 1116
                    pad = tmp___2;
                    {
#line 1116
                    while (1) {
                      while_continue___0: /* CIL Label */ ;

#line 1116
                      if (! (pad > 0)) {
#line 1116
                        goto while_break___0;
                      }
                      {
#line 1117
                      fprintf(fdest, "%c", 0);
#line 1116
                      __cil_tmp22 = pad;
#line 1116
                      pad --;
                      }
                    }
                    while_break___5: /* CIL Label */ ;
                    }
                    while_break___0: ;
                  }
#line 1091
                  i ++;
                }
                while_break___4: /* CIL Label */ ;
                }
                while_break: 
                {
#line 1120
                fclose(fdest);
                }
              } else {
#line 1017
                goto _L;
              }
            } else {
#line 1017
              goto _L;
            }
          } else {
#line 1017
            goto _L;
          }
        } else {
#line 1017
          goto _L;
        }
      } else {
#line 1017
        goto _L;
      }
    } else {
#line 1017
      goto _L;
    }
  } else {
    _L: 
    {
#line 1127
    fdest = fopen(outfile, "wb");
#line 1128
    w = (int )(image->comps + 0)->w;
#line 1129
    h = (int )(image->comps + 0)->h;
#line 1131
    fprintf(fdest, "BM");
#line 1135
    fprintf(fdest, "%c%c%c%c\230\001", (int )((unsigned char )(((h * w + 54) + 1024) + h * (w % 2))) & 255,
            (int )((unsigned char )((((h * w + 54) + 1024) + h * (w % 2)) >> 8)) & 255,
            (int )((unsigned char )((((h * w + 54) + 1024) + h * (w % 2)) >> 16)) & 255,
            (int )((unsigned char )((((h * w + 54) + 1024) + w * (w % 2)) >> 24)) & 255);
#line 1139
    fprintf(fdest, "%c%c%c%c\251", 0, 0, 0, 0);
#line 1140
    fprintf(fdest, "%c%c%c%c\251", 54, (1078 >> 8) & 255, (1078 >> 16) & 255, (1078 >> 24) & 255);
#line 1146
    fprintf(fdest, "%c%c%c%c\251", 40, (40 >> 8) & 255, (40 >> 16) & 255, (40 >> 24) & 255);
#line 1147
    fprintf(fdest, "%c%c%c%c\230\001", (int )((unsigned char )(w & 255)), (int )((unsigned char )(w >> 8)) & 255,
            (int )((unsigned char )(w >> 16)) & 255, (int )((unsigned char )(w >> 24)) & 255);
#line 1151
    fprintf(fdest, "%c%c%c%c\230\001", (int )((unsigned char )(h & 255)), (int )((unsigned char )(h >> 8)) & 255,
            (int )((unsigned char )(h >> 16)) & 255, (int )((unsigned char )(h >> 24)) & 255);
#line 1155
    fprintf(fdest, "%c%c\202U", 1, (1 >> 8) & 255);
#line 1156
    fprintf(fdest, "%c%c\202U", 8, (8 >> 8) & 255);
#line 1157
    fprintf(fdest, "%c%c%c%c\251", 0, 0, 0, 0);
#line 1158
    fprintf(fdest, "%c%c%c%c\230\001", (int )((unsigned char )(h * w + h * (w % 2))) & 255,
            (int )((unsigned char )((h * w + h * (w % 2)) >> 8)) & 255, (int )((unsigned char )((h * w + h * (w % 2)) >> 16)) & 255,
            (int )((unsigned char )((h * w + h * (w % 2)) >> 24)) & 255);
#line 1162
    fprintf(fdest, "%c%c%c%c\251", 154, (7834 >> 8) & 255, (7834 >> 16) & 255, (7834 >> 24) & 255);
#line 1163
    fprintf(fdest, "%c%c%c%c\251", 154, (7834 >> 8) & 255, (7834 >> 16) & 255, (7834 >> 24) & 255);
#line 1164
    fprintf(fdest, "%c%c%c%c\251", 0, (256 >> 8) & 255, (256 >> 16) & 255, (256 >> 24) & 255);
#line 1165
    fprintf(fdest, "%c%c%c%c\251", 0, (256 >> 8) & 255, (256 >> 16) & 255, (256 >> 24) & 255);
    }
#line 1167
    if ((image->comps + 0)->prec > 8U) {
      {
#line 1168
      adjustR = (int )((image->comps + 0)->prec - 8U);
#line 1169
      printf("BMP CONVERSION: Truncating component 0 from %d bits to 8 bits\n", (image->comps + 0)->prec);
      }
    } else {
#line 1171
      adjustR = 0;
    }
#line 1173
    i = 0;
    {
#line 1173
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 1173
      if (! (i < 256)) {
#line 1173
        goto while_break___1;
      }
      {
#line 1174
      fprintf(fdest, "%c%c%c%c\230\001", i, i, i, 0);
#line 1173
      i ++;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___1: 
#line 1177
    i = 0;
    {
#line 1177
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 1177
      if (! (i < w * h)) {
#line 1177
        goto while_break___2;
      }
#line 1180
      r___0 = *((image->comps + 0)->data + ((w * h - (i / w + 1) * w) + i % w));
#line 1181
      if ((image->comps + 0)->sgnd) {
#line 1181
        tmp___3 = 1 << ((image->comps + 0)->prec - 1U);
      } else {
#line 1181
        tmp___3 = 0;
      }
#line 1181
      r___0 += tmp___3;
#line 1182
      r___0 = (r___0 >> adjustR) + (r___0 >> (adjustR - 1)) % 2;
#line 1183
      if (r___0 > 255) {
#line 1183
        r___0 = 255;
      } else
#line 1183
      if (r___0 < 0) {
#line 1183
        r___0 = 0;
      }
      {
#line 1185
      fprintf(fdest, "%c\342\212\202U", (int )((unsigned char )r___0));
      }
#line 1187
      if ((i + 1) % w == 0) {
#line 1188
        if (w % 4) {
#line 1188
          tmp___4 = 4 - w % 4;
        } else {
#line 1188
          tmp___4 = 0;
        }
#line 1188
        pad = tmp___4;
        {
#line 1188
        while (1) {
          while_continue___3: /* CIL Label */ ;

#line 1188
          if (! (pad > 0)) {
#line 1188
            goto while_break___3;
          }
          {
#line 1189
          fprintf(fdest, "%c\344\212\202U", 0);
#line 1188
          __cil_tmp29 = pad;
#line 1188
          pad --;
          }
        }
        while_break___8: /* CIL Label */ ;
        }
        while_break___3: ;
      }
#line 1177
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: 
    {
#line 1192
    fclose(fdest);
    }
  }
#line 1195
  return (0);
}
}
#line 1205 "/root/patron/new_22/src/bin/jp2/convert.c"
static unsigned char readuchar(FILE *f ) 
{ 
  unsigned char c1 ;
  unsigned long __cil_tmp3 ;

  {
  {
#line 1208
  __cil_tmp3 = fread((void *)(& c1), 1UL, 1UL, f);
  }
#line 1208
  if (! __cil_tmp3) {
    {
#line 1210
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1211
    return ((unsigned char)0);
  }
#line 1213
  return (c1);
}
}
#line 1216 "/root/patron/new_22/src/bin/jp2/convert.c"
static unsigned short readushort(FILE *f , int bigendian ) 
{ 
  unsigned char c1 ;
  unsigned char c2 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;

  {
  {
#line 1219
  __cil_tmp5 = fread((void *)(& c1), 1UL, 1UL, f);
  }
#line 1219
  if (! __cil_tmp5) {
    {
#line 1221
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1222
    return ((unsigned short)0);
  }
  {
#line 1224
  __cil_tmp6 = fread((void *)(& c2), 1UL, 1UL, f);
  }
#line 1224
  if (! __cil_tmp6) {
    {
#line 1226
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1227
    return ((unsigned short)0);
  }
#line 1229
  if (bigendian) {
#line 1230
    return ((unsigned short )(((int )c1 << 8) + (int )c2));
  } else {
#line 1232
    return ((unsigned short )(((int )c2 << 8) + (int )c1));
  }
}
}
#line 1235 "/root/patron/new_22/src/bin/jp2/convert.c"
static unsigned int readuint(FILE *f , int bigendian ) 
{ 
  unsigned char c1 ;
  unsigned char c2 ;
  unsigned char c3 ;
  unsigned char c4 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;

  {
  {
#line 1238
  __cil_tmp7 = fread((void *)(& c1), 1UL, 1UL, f);
  }
#line 1238
  if (! __cil_tmp7) {
    {
#line 1240
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1241
    return (0U);
  }
  {
#line 1243
  __cil_tmp8 = fread((void *)(& c2), 1UL, 1UL, f);
  }
#line 1243
  if (! __cil_tmp8) {
    {
#line 1245
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1246
    return (0U);
  }
  {
#line 1248
  __cil_tmp9 = fread((void *)(& c3), 1UL, 1UL, f);
  }
#line 1248
  if (! __cil_tmp9) {
    {
#line 1250
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1251
    return (0U);
  }
  {
#line 1253
  __cil_tmp10 = fread((void *)(& c4), 1UL, 1UL, f);
  }
#line 1253
  if (! __cil_tmp10) {
    {
#line 1255
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1256
    return (0U);
  }
#line 1258
  if (bigendian) {
#line 1259
    return ((unsigned int )(((((int )c1 << 24) + ((int )c2 << 16)) + ((int )c3 << 8)) + (int )c4));
  } else {
#line 1261
    return ((unsigned int )(((((int )c4 << 24) + ((int )c3 << 16)) + ((int )c2 << 8)) + (int )c1));
  }
}
}
#line 1264 "/root/patron/new_22/src/bin/jp2/convert.c"
opj_image_t *pgxtoimage(char const   *filename , opj_cparameters_t *parameters ) 
{ 
  FILE *f ;
  int w ;
  int h ;
  int prec ;
  int i ;
  int numcomps ;
  int max ;
  OPJ_COLOR_SPACE color_space ;
  opj_image_cmptparm_t cmptparm ;
  opj_image_t *image ;
  int adjustS ;
  int ushift ;
  int dshift ;
  int force8 ;
  char endian1 ;
  char endian2 ;
  char sign ;
  char signtmp[32] ;
  char temp[32] ;
  int bigendian ;
  opj_image_comp_t *comp ;
  int __cil_tmp25 ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int v ;
  unsigned char __cil_tmp31 ;
  unsigned char __cil_tmp32 ;
  unsigned char __cil_tmp33 ;
  unsigned short __cil_tmp34 ;
  unsigned short __cil_tmp35 ;
  unsigned int __cil_tmp36 ;
  unsigned int __cil_tmp37 ;
  int __cil_tmp39 ;

  {
  {
#line 1265
  f = (FILE *)((void *)0);
#line 1270
  image = (opj_image_t *)((void *)0);
#line 1278
  comp = (opj_image_comp_t *)((void *)0);
#line 1280
  numcomps = 1;
#line 1281
  color_space = (OPJ_COLOR_SPACE )2;
#line 1283
  memset((void *)(& cmptparm), 0, sizeof(opj_image_cmptparm_t ));
#line 1285
  max = 0;
#line 1287
  f = fopen(filename, "rb\345\212\202U");
  }
#line 1288
  if (! f) {
    {
#line 1289
    fprintf(stderr, "Failed to open %s for reading !\n\230\001", filename);
    }
#line 1290
    return ((opj_image_t *)((void *)0));
  }
  {
#line 1293
  fseek(f, 0L, 0);
#line 1294
  __cil_tmp25 = fscanf(f, "PG%[ \t]%c%c%[ \t+-]%d%[ \t]%d%[ \t]%d\344\212\202U", temp,
                       & endian1, & endian2, signtmp, & prec, temp, & w, temp, & h);
  }
#line 1294
  if (__cil_tmp25 != 9) {
    {
#line 1295
    fprintf(stderr, "ERROR: Failed to read the right number of element from the fscanf() function!\n");
    }
#line 1296
    return ((opj_image_t *)((void *)0));
  }
#line 1299
  i = 0;
#line 1300
  sign = (char )'+';
  {
#line 1301
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1301
    if (! ((int )signtmp[i] != 0)) {
#line 1301
      goto while_break;
    }
#line 1302
    if ((int )signtmp[i] == 45) {
#line 1302
      sign = (char )'-';
    }
#line 1303
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1306
  fgetc(f);
  }
#line 1307
  if ((int )endian1 == 77) {
#line 1307
    if ((int )endian2 == 76) {
#line 1308
      bigendian = 1;
    } else {
#line 1307
      goto _L;
    }
  } else
  _L: 
#line 1309
  if ((int )endian2 == 77) {
#line 1309
    if ((int )endian1 == 76) {
#line 1310
      bigendian = 0;
    } else {
      {
#line 1312
      fprintf(stderr, "Bad pgx header, please check input file\n\220");
      }
#line 1313
      return ((opj_image_t *)((void *)0));
    }
  } else {
    {
#line 1312
    fprintf(stderr, "Bad pgx header, please check input file\n\220");
    }
#line 1313
    return ((opj_image_t *)((void *)0));
  }
#line 1318
  cmptparm.x0 = (OPJ_UINT32 )parameters->image_offset_x0;
#line 1319
  cmptparm.y0 = (OPJ_UINT32 )parameters->image_offset_y0;
#line 1320
  if (! cmptparm.x0) {
#line 1320
    tmp = (unsigned int )((w - 1) * parameters->subsampling_dx + 1);
  } else {
#line 1320
    tmp = (cmptparm.x0 + (unsigned int )((w - 1) * parameters->subsampling_dx)) + 1U;
  }
#line 1320
  cmptparm.w = tmp;
#line 1321
  if (! cmptparm.y0) {
#line 1321
    tmp___0 = (unsigned int )((h - 1) * parameters->subsampling_dy + 1);
  } else {
#line 1321
    tmp___0 = (cmptparm.y0 + (unsigned int )((h - 1) * parameters->subsampling_dy)) + 1U;
  }
#line 1321
  cmptparm.h = tmp___0;
#line 1323
  if ((int )sign == 45) {
#line 1324
    cmptparm.sgnd = (OPJ_UINT32 )1;
  } else {
#line 1326
    cmptparm.sgnd = (OPJ_UINT32 )0;
  }
#line 1328
  if (prec < 8) {
#line 1330
    force8 = 1;
#line 1331
    ushift = 8 - prec;
#line 1331
    dshift = prec - ushift;
#line 1332
    if (cmptparm.sgnd) {
#line 1332
      adjustS = 1 << (prec - 1);
    } else {
#line 1332
      adjustS = 0;
    }
#line 1333
    cmptparm.sgnd = (OPJ_UINT32 )0;
#line 1334
    prec = 8;
  } else {
#line 1336
    adjustS = 0;
#line 1336
    force8 = adjustS;
#line 1336
    dshift = force8;
#line 1336
    ushift = dshift;
  }
  {
#line 1338
  cmptparm.prec = (OPJ_UINT32 )prec;
#line 1339
  cmptparm.bpp = (OPJ_UINT32 )prec;
#line 1340
  cmptparm.dx = (OPJ_UINT32 )parameters->subsampling_dx;
#line 1341
  cmptparm.dy = (OPJ_UINT32 )parameters->subsampling_dy;
#line 1344
  image = opj_image_create((OPJ_UINT32 )numcomps, & cmptparm, color_space);
  }
#line 1345
  if (! image) {
    {
#line 1346
    fclose(f);
    }
#line 1347
    return ((opj_image_t *)((void *)0));
  }
#line 1350
  image->x0 = cmptparm.x0;
#line 1351
  image->y0 = cmptparm.x0;
#line 1352
  image->x1 = cmptparm.w;
#line 1353
  image->y1 = cmptparm.h;
#line 1357
  comp = image->comps + 0;
#line 1359
  i = 0;
  {
#line 1359
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue___0: ;
#line 1359
    if (! (i < w * h)) {
#line 1359
      goto while_break___0;
    }
#line 1361
    if (force8) {
      {
#line 1363
      __cil_tmp31 = readuchar(f);
#line 1363
      v = (int )__cil_tmp31 + adjustS;
#line 1364
      v = (v << ushift) + (v >> dshift);
#line 1365
      *(comp->data + i) = (OPJ_INT32 )((unsigned char )v);
      }
#line 1367
      if (v > max) {
#line 1367
        max = v;
      }
#line 1369
      goto while_continue___0;
    }
#line 1371
    if (comp->prec == 8U) {
#line 1372
      if (! comp->sgnd) {
        {
#line 1373
        __cil_tmp32 = readuchar(f);
#line 1373
        v = (int )__cil_tmp32;
        }
      } else {
        {
#line 1375
        __cil_tmp33 = readuchar(f);
#line 1375
        v = (int )((char )__cil_tmp33);
        }
      }
    } else
#line 1377
    if (comp->prec <= 16U) {
#line 1378
      if (! comp->sgnd) {
        {
#line 1379
        __cil_tmp34 = readushort(f, bigendian);
#line 1379
        v = (int )__cil_tmp34;
        }
      } else {
        {
#line 1381
        __cil_tmp35 = readushort(f, bigendian);
#line 1381
        v = (int )((short )__cil_tmp35);
        }
      }
    } else
#line 1384
    if (! comp->sgnd) {
      {
#line 1385
      __cil_tmp36 = readuint(f, bigendian);
#line 1385
      v = (int )__cil_tmp36;
      }
    } else {
      {
#line 1387
      __cil_tmp37 = readuint(f, bigendian);
#line 1387
      v = (int )__cil_tmp37;
      }
    }
#line 1390
    if (v > max) {
#line 1391
      max = v;
    }
#line 1392
    *(comp->data + i) = v;
#line 1359
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 1394
  fclose(f);
#line 1395
  __cil_tmp39 = int_floorlog2(max);
#line 1395
  comp->bpp = (OPJ_UINT32 )(__cil_tmp39 + 1);
  }
#line 1397
  return (image);
}
}
#line 1400 "/root/patron/new_22/src/bin/jp2/convert.c"
int imagetopgx(opj_image_t *image , char const   *outfile ) 
{ 
  int w ;
  int h ;
  int i ;
  int j ;
  int compno ;
  FILE *fdest ;
  opj_image_comp_t *comp ;
  char bname[256] ;
  char *name ;
  int nbytes ;
  size_t res ;
  size_t olen ;
  unsigned long __cil_tmp15 ;
  size_t dotpos ;
  size_t total ;
  void *__cil_tmp18 ;
  int tmp ;
  int v ;
  char byte ;
  int __cil_tmp24 ;

  {
#line 1403
  fdest = (FILE *)((void *)0);
#line 1405
  compno = 0;
  {
#line 1405
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1405
    if (! ((unsigned int )compno < image->numcomps)) {
#line 1405
      goto while_break;
    }
    {
#line 1406
    comp = image->comps + compno;
#line 1408
    name = bname;
#line 1409
    nbytes = 0;
#line 1411
    __cil_tmp15 = strlen(outfile);
#line 1411
    olen = __cil_tmp15;
#line 1412
    dotpos = olen - 4UL;
#line 1413
    total = ((dotpos + 1UL) + 1UL) + 4UL;
    }
#line 1414
    if ((int )*(outfile + dotpos) != 46) {
      {
#line 1416
      fprintf(stderr, "ERROR -> Impossible happen.\212\202U");
      }
#line 1417
      return (1);
    }
#line 1419
    if (total > 256UL) {
      {
#line 1420
      __cil_tmp18 = malloc(total + 1UL);
#line 1420
      name = (char *)__cil_tmp18;
      }
    }
    {
#line 1422
    strncpy(name, outfile, dotpos);
#line 1424
    sprintf(name + dotpos, "_%d.pgx", compno);
#line 1428
    fdest = fopen((char const   *)name, "wb\345\212\202U");
    }
#line 1429
    if (! fdest) {
      {
#line 1430
      fprintf(stderr, "ERROR -> failed to open %s for writing\n", name);
      }
#line 1431
      return (1);
    }
#line 1434
    if (total > 256UL) {
      {
#line 1435
      free((void *)name);
      }
    }
#line 1438
    w = (int )(image->comps + compno)->w;
#line 1439
    h = (int )(image->comps + compno)->h;
#line 1441
    if (comp->sgnd) {
#line 1441
      tmp = '-';
    } else {
#line 1441
      tmp = '+';
    }
    {
#line 1441
    fprintf(fdest, "PG ML %c %d %d %d\n\345\212\202U", tmp, comp->prec, w, h);
    }
#line 1442
    if (comp->prec <= 8U) {
#line 1443
      nbytes = 1;
    } else
#line 1444
    if (comp->prec <= 16U) {
#line 1445
      nbytes = 2;
    } else {
#line 1447
      nbytes = 4;
    }
#line 1449
    i = 0;
    {
#line 1449
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1449
      if (! (i < w * h)) {
#line 1449
        goto while_break___0;
      }
#line 1450
      v = *((image->comps + compno)->data + i);
#line 1451
      j = nbytes - 1;
      {
#line 1451
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 1451
        if (! (j >= 0)) {
#line 1451
          goto while_break___1;
        }
        {
#line 1452
        byte = (char )(v >> j * 8);
#line 1453
        res = fwrite((void const   *)(& byte), 1UL, 1UL, fdest);
        }
#line 1454
        if (res < 1UL) {
          {
#line 1455
          fprintf(stderr, "failed to write 1 byte for %s\n", name);
          }
#line 1456
          return (1);
        }
#line 1451
        __cil_tmp24 = j;
#line 1451
        j --;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: 
#line 1449
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 1460
    fclose(fdest);
#line 1405
    compno ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: ;
#line 1463
  return (0);
}
}
#line 1479 "/root/patron/new_22/src/bin/jp2/convert.c"
static char *skip_white(char *s ) 
{ 
  unsigned short const   **__cil_tmp2 ;

  {
  {
#line 1481
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 1481
    if (! *s) {
#line 1481
      goto while_break;
    }
#line 1483
    if ((int )*s == 10) {
#line 1483
      return ((char *)((void *)0));
    } else
#line 1483
    if ((int )*s == 13) {
#line 1483
      return ((char *)((void *)0));
    }
    {
#line 1484
    __cil_tmp2 = __ctype_b_loc();
    }
#line 1484
    if ((int )*(*__cil_tmp2 + (int )*s) & 8192) {
#line 1484
      s ++;
#line 1484
      goto while_continue;
    }
#line 1485
    return (s);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1487
  return ((char *)((void *)0));
}
}
#line 1490 "/root/patron/new_22/src/bin/jp2/convert.c"
static char *skip_int(char *start , int *out_n ) 
{ 
  char *s ;
  char c ;
  unsigned short const   **__cil_tmp6 ;

  {
  {
#line 1495
  *out_n = 0;
#line 1495
  s = start;
#line 1497
  s = skip_white(start);
  }
#line 1498
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1498
    return ((char *)((void *)0));
  }
#line 1499
  start = s;
  {
#line 1501
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1501
    if (! *s) {
#line 1501
      goto while_break;
    }
    {
#line 1503
    __cil_tmp6 = __ctype_b_loc();
    }
#line 1503
    if (! ((int )*(*__cil_tmp6 + (int )*s) & 2048)) {
#line 1503
      goto while_break;
    }
#line 1504
    s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1506
  c = *s;
#line 1506
  *s = (char)0;
#line 1506
  *out_n = atoi((char const   *)start);
#line 1506
  *s = c;
  }
#line 1507
  return (s);
}
}
#line 1510 "/root/patron/new_22/src/bin/jp2/convert.c"
static char *skip_idf(char *start , char *out_idf ) 
{ 
  char *s ;
  char c ;
  unsigned short const   **__cil_tmp6 ;

  {
  {
#line 1515
  s = skip_white(start);
  }
#line 1516
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1516
    return ((char *)((void *)0));
  }
#line 1517
  start = s;
  {
#line 1519
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 1519
    if (! *s) {
#line 1519
      goto while_break;
    }
    {
#line 1521
    __cil_tmp6 = __ctype_b_loc();
    }
#line 1521
    if ((int )*(*__cil_tmp6 + (int )*s) & 1024) {
#line 1521
      s ++;
#line 1521
      goto while_continue;
    } else
#line 1521
    if ((int )*s == 95) {
#line 1521
      s ++;
#line 1521
      goto while_continue;
    }
#line 1522
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1524
  c = *s;
#line 1524
  *s = (char)0;
#line 1524
  strncpy((char *)out_idf, (char const   *)start, 255UL);
#line 1524
  *s = c;
  }
#line 1525
  return (s);
}
}
#line 1528 "/root/patron/new_22/src/bin/jp2/convert.c"
static void read_pnm_header(FILE *reader , struct pnm_header *ph ) 
{ 
  char *s ;
  int format ;
  int have_wh ;
  int end ;
  int ttype ;
  char idf[256] ;
  char type[256] ;
  char line[256] ;
  char *__cil_tmp11 ;
  char *__cil_tmp13 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp18 ;
  int __cil_tmp20 ;
  int __cil_tmp22 ;
  int __cil_tmp24 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;

  {
  {
#line 1535
  __cil_tmp11 = fgets(line, 250, reader);
  }
#line 1535
  if ((unsigned long )__cil_tmp11 == (unsigned long )((void *)0)) {
    {
#line 1537
    fprintf(stderr, "\nWARNING: fgets return a NULL value");
    }
#line 1538
    return;
  }
#line 1541
  if ((int )line[0] != 80) {
    {
#line 1543
    fprintf(stderr, "read_pnm_header:PNM:magic P missing\n");
    }
#line 1543
    return;
  }
  {
#line 1545
  format = atoi((char const   *)(line + 1));
  }
#line 1546
  if (format < 1) {
    {
#line 1548
    fprintf(stderr, "read_pnm_header:magic format %d invalid\n\230\001", format);
    }
#line 1549
    return;
  } else
#line 1546
  if (format > 7) {
    {
#line 1548
    fprintf(stderr, "read_pnm_header:magic format %d invalid\n\230\001", format);
    }
#line 1549
    return;
  }
#line 1551
  ph->format = format;
#line 1552
  have_wh = 0;
#line 1552
  end = have_wh;
#line 1552
  ttype = end;
  {
#line 1554
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
    {
#line 1554
    __cil_tmp13 = fgets(line, 250, reader);
    }
#line 1554
    if (! __cil_tmp13) {
#line 1554
      goto while_break;
    }
#line 1556
    if ((int )line[0] == 35) {
#line 1556
      goto while_continue;
    }
#line 1558
    s = line;
#line 1560
    if (format == 7) {
      {
#line 1562
      s = skip_idf(s, (char *)(idf));
      }
#line 1564
      if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1564
        return;
      } else
#line 1564
      if ((int )*s == 0) {
#line 1564
        return;
      }
      {
#line 1566
      __cil_tmp15 = strcmp((char const   *)(idf), "ENDHDR");
      }
#line 1566
      if (__cil_tmp15 == 0) {
#line 1568
        end = 1;
#line 1568
        goto while_break;
      }
      {
#line 1570
      __cil_tmp16 = strcmp((char const   *)(idf), "WIDTH");
      }
#line 1570
      if (__cil_tmp16 == 0) {
        {
#line 1572
        s = skip_int(s, & ph->width);
        }
#line 1573
        if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1573
          return;
        } else
#line 1573
        if ((int )*s == 0) {
#line 1573
          return;
        }
#line 1575
        goto while_continue;
      }
      {
#line 1577
      __cil_tmp18 = strcmp((char const   *)(idf), "HEIGHT");
      }
#line 1577
      if (__cil_tmp18 == 0) {
        {
#line 1579
        s = skip_int(s, & ph->height);
        }
#line 1580
        if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1580
          return;
        } else
#line 1580
        if ((int )*s == 0) {
#line 1580
          return;
        }
#line 1582
        goto while_continue;
      }
      {
#line 1584
      __cil_tmp20 = strcmp((char const   *)(idf), "DEPTHU");
      }
#line 1584
      if (__cil_tmp20 == 0) {
        {
#line 1586
        s = skip_int(s, & ph->depth);
        }
#line 1587
        if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1587
          return;
        } else
#line 1587
        if ((int )*s == 0) {
#line 1587
          return;
        }
#line 1589
        goto while_continue;
      }
      {
#line 1591
      __cil_tmp22 = strcmp((char const   *)(idf), "MAXVAL");
      }
#line 1591
      if (__cil_tmp22 == 0) {
        {
#line 1593
        s = skip_int(s, & ph->maxval);
        }
#line 1594
        if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1594
          return;
        } else
#line 1594
        if ((int )*s == 0) {
#line 1594
          return;
        }
#line 1596
        goto while_continue;
      }
      {
#line 1598
      __cil_tmp24 = strcmp((char const   *)(idf), "TUPLTYPE\220");
      }
#line 1598
      if (__cil_tmp24 == 0) {
        {
#line 1600
        s = skip_idf(s, (char *)(type));
        }
#line 1601
        if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1601
          return;
        } else
#line 1601
        if ((int )*s == 0) {
#line 1601
          return;
        }
        {
#line 1603
        __cil_tmp26 = strcmp((char const   *)(type), "BLACKANDWHITEU");
        }
#line 1603
        if (__cil_tmp26 == 0) {
#line 1605
          ph->bw = (char)1;
#line 1605
          ttype = 1;
#line 1605
          goto while_continue;
        }
        {
#line 1607
        __cil_tmp27 = strcmp((char const   *)(type), "GRAYSCALE");
        }
#line 1607
        if (__cil_tmp27 == 0) {
#line 1609
          ph->gray = (char)1;
#line 1609
          ttype = 1;
#line 1609
          goto while_continue;
        }
        {
#line 1611
        __cil_tmp28 = strcmp((char const   *)(type), "GRAYSCALE_ALPHA");
        }
#line 1611
        if (__cil_tmp28 == 0) {
#line 1613
          ph->graya = (char)1;
#line 1613
          ttype = 1;
#line 1613
          goto while_continue;
        }
        {
#line 1615
        __cil_tmp29 = strcmp((char const   *)(type), "RGB");
        }
#line 1615
        if (__cil_tmp29 == 0) {
#line 1617
          ph->rgb = (char)1;
#line 1617
          ttype = 1;
#line 1617
          goto while_continue;
        }
        {
#line 1619
        __cil_tmp30 = strcmp((char const   *)(type), "RGB_ALPHA");
        }
#line 1619
        if (__cil_tmp30 == 0) {
#line 1621
          ph->rgba = (char)1;
#line 1621
          ttype = 1;
#line 1621
          goto while_continue;
        }
        {
#line 1623
        fprintf(stderr, "read_pnm_header:unknown P7 TUPLTYPE %s\n", type);
        }
#line 1624
        return;
      }
      {
#line 1626
      fprintf(stderr, "read_pnm_header:unknown P7 idf %s\n", idf);
      }
#line 1627
      return;
    }
#line 1630
    if (! have_wh) {
      {
#line 1632
      s = skip_int(s, & ph->width);
#line 1634
      s = skip_int(s, & ph->height);
#line 1636
      have_wh = 1;
      }
#line 1638
      if (format == 1) {
#line 1638
        goto while_break;
      } else
#line 1638
      if (format == 4) {
#line 1638
        goto while_break;
      }
#line 1640
      goto while_continue;
    }
#line 1642
    if (format == 2) {
      _L: 
      {
#line 1645
      s = skip_int(s, & ph->maxval);
      }
#line 1647
      if (ph->maxval > 65535) {
#line 1647
        return;
      }
    } else
#line 1642
    if (format == 3) {
#line 1642
      goto _L;
    } else
#line 1642
    if (format == 5) {
#line 1642
      goto _L;
    } else
#line 1642
    if (format == 6) {
#line 1642
      goto _L;
    }
#line 1649
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 1651
  if (format == 2) {
    _L___31: 
#line 1653
    if (ph->maxval < 1) {
#line 1653
      return;
    } else
#line 1653
    if (ph->maxval > 65535) {
#line 1653
      return;
    }
  } else
#line 1651
  if (format == 3) {
#line 1651
    goto _L___31;
  } else
#line 1651
  if (format > 4) {
#line 1651
    goto _L___31;
  }
#line 1655
  if (ph->width < 1) {
#line 1655
    return;
  } else
#line 1655
  if (ph->height < 1) {
#line 1655
    return;
  }
#line 1657
  if (format == 7) {
#line 1659
    if (! end) {
      {
#line 1661
      fprintf(stderr, "read_pnm_header:P7 without ENDHDR\n");
      }
#line 1661
      return;
    }
#line 1663
    if (ph->depth < 1) {
#line 1663
      return;
    } else
#line 1663
    if (ph->depth > 4) {
#line 1663
      return;
    }
#line 1665
    if (ph->width) {
#line 1665
      if (ph->height) {
#line 1665
        if (ph->depth & ph->maxval) {
#line 1665
          if (ttype) {
#line 1666
            ph->ok = (char)1;
          }
        }
      }
    }
  } else
#line 1670
  if (format != 1) {
#line 1670
    if (format != 4) {
#line 1672
      if (ph->width) {
#line 1672
        if (ph->height) {
#line 1672
          if (ph->maxval) {
#line 1672
            ph->ok = (char)1;
          }
        }
      }
    } else {
#line 1670
      goto _L___33;
    }
  } else {
    _L___33: 
#line 1676
    if (ph->width) {
#line 1676
      if (ph->height) {
#line 1676
        ph->ok = (char)1;
      }
    }
#line 1677
    ph->maxval = 255;
  }
#line 1679
  return;
}
}
#line 1682 "/root/patron/new_22/src/bin/jp2/convert.c"
static int has_prec(int val ) 
{ 


  {
#line 1684
  if (val < 2) {
#line 1684
    return (1);
  }
#line 1685
  if (val < 4) {
#line 1685
    return (2);
  }
#line 1686
  if (val < 8) {
#line 1686
    return (3);
  }
#line 1687
  if (val < 16) {
#line 1687
    return (4);
  }
#line 1688
  if (val < 32) {
#line 1688
    return (5);
  }
#line 1689
  if (val < 64) {
#line 1689
    return (6);
  }
#line 1690
  if (val < 128) {
#line 1690
    return (7);
  }
#line 1691
  if (val < 256) {
#line 1691
    return (8);
  }
#line 1692
  if (val < 512) {
#line 1692
    return (9);
  }
#line 1693
  if (val < 1024) {
#line 1693
    return (10);
  }
#line 1694
  if (val < 2048) {
#line 1694
    return (11);
  }
#line 1695
  if (val < 4096) {
#line 1695
    return (12);
  }
#line 1696
  if (val < 8192) {
#line 1696
    return (13);
  }
#line 1697
  if (val < 16384) {
#line 1697
    return (14);
  }
#line 1698
  if (val < 32768) {
#line 1698
    return (15);
  }
#line 1699
  return (16);
}
}
#line 1702 "/root/patron/new_22/src/bin/jp2/convert.c"
opj_image_t *pnmtoimage(char const   *filename , opj_cparameters_t *parameters ) 
{ 
  int subsampling_dx ;
  int subsampling_dy ;
  FILE *fp ;
  int i ;
  int compno ;
  int numcomps ;
  int w ;
  int h ;
  int prec ;
  int format ;
  OPJ_COLOR_SPACE color_space ;
  opj_image_cmptparm_t cmptparm[4] ;
  opj_image_t *image ;
  struct pnm_header header_info ;
  unsigned int index___34 ;
  int __cil_tmp22 ;
  unsigned char c0 ;
  unsigned char c1 ;
  unsigned char one ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned int index___35 ;
  int __cil_tmp33 ;
  int tmp ;
  int x ;
  int y ;
  int bit ;
  unsigned char uc ;
  int __cil_tmp40 ;
  int tmp___0 ;
  unsigned char uc___0 ;
  unsigned long __cil_tmp43 ;
  int tmp___1 ;

  {
  {
#line 1703
  subsampling_dx = parameters->subsampling_dx;
#line 1704
  subsampling_dy = parameters->subsampling_dy;
#line 1706
  fp = (FILE *)((void *)0);
#line 1710
  image = (opj_image_t *)((void *)0);
#line 1713
  fp = fopen(filename, "rb");
  }
#line 1713
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 1715
    fprintf(stderr, "pnmtoimage:Failed to open %s for reading!\n", filename);
    }
#line 1716
    return ((opj_image_t *)((void *)0));
  }
  {
#line 1718
  memset((void *)(& header_info), 0, sizeof(struct pnm_header ));
#line 1720
  read_pnm_header(fp, & header_info);
  }
#line 1722
  if (! header_info.ok) {
    {
#line 1722
    fclose(fp);
    }
#line 1722
    return ((opj_image_t *)((void *)0));
  }
#line 1724
  format = header_info.format;
#line 1729
  if (format == 4) {
#line 1729
    goto case_4;
  }
#line 1729
  if (format == 1) {
#line 1729
    goto case_4;
  }
#line 1734
  if (format == 5) {
#line 1734
    goto case_5;
  }
#line 1734
  if (format == 2) {
#line 1734
    goto case_5;
  }
#line 1739
  if (format == 6) {
#line 1739
    goto case_6;
  }
#line 1739
  if (format == 3) {
#line 1739
    goto case_6;
  }
#line 1743
  if (format == 7) {
#line 1743
    goto case_7;
  }
#line 1747
  goto switch_default;
  case_4: 
#line 1730
  numcomps = 1;
#line 1731
  goto switch_break;
  case_5: 
#line 1735
  numcomps = 1;
#line 1736
  goto switch_break;
  case_6: 
#line 1740
  numcomps = 3;
#line 1741
  goto switch_break;
  case_7: 
#line 1744
  numcomps = header_info.depth;
#line 1745
  goto switch_break;
  switch_default: 
  {
#line 1747
  fclose(fp);
  }
#line 1747
  return ((opj_image_t *)((void *)0));
  switch_break: ;
#line 1749
  if (numcomps < 3) {
#line 1750
    color_space = (OPJ_COLOR_SPACE )2;
  } else {
#line 1752
    color_space = (OPJ_COLOR_SPACE )1;
  }
  {
#line 1754
  prec = has_prec(header_info.maxval);
  }
#line 1756
  if (prec < 8) {
#line 1756
    prec = 8;
  }
  {
#line 1758
  w = header_info.width;
#line 1759
  h = header_info.height;
#line 1760
  subsampling_dx = parameters->subsampling_dx;
#line 1761
  subsampling_dy = parameters->subsampling_dy;
#line 1763
  memset((void *)(& cmptparm[0]), 0, (unsigned long )numcomps * sizeof(opj_image_cmptparm_t ));
#line 1765
  i = 0;
  }
  {
#line 1765
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1765
    if (! (i < numcomps)) {
#line 1765
      goto while_break;
    }
#line 1767
    cmptparm[i].prec = (OPJ_UINT32 )prec;
#line 1768
    cmptparm[i].bpp = (OPJ_UINT32 )prec;
#line 1769
    cmptparm[i].sgnd = (OPJ_UINT32 )0;
#line 1770
    cmptparm[i].dx = (OPJ_UINT32 )subsampling_dx;
#line 1771
    cmptparm[i].dy = (OPJ_UINT32 )subsampling_dy;
#line 1772
    cmptparm[i].w = (OPJ_UINT32 )w;
#line 1773
    cmptparm[i].h = (OPJ_UINT32 )h;
#line 1765
    i ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break: 
  {
#line 1775
  image = opj_image_create((OPJ_UINT32 )numcomps, & cmptparm[0], color_space);
  }
#line 1777
  if (! image) {
    {
#line 1777
    fclose(fp);
    }
#line 1777
    return ((opj_image_t *)((void *)0));
  }
#line 1780
  image->x0 = (OPJ_UINT32 )parameters->image_offset_x0;
#line 1781
  image->y0 = (OPJ_UINT32 )parameters->image_offset_y0;
#line 1782
  image->x1 = (OPJ_UINT32 )((parameters->image_offset_x0 + (w - 1) * subsampling_dx) + 1);
#line 1783
  image->y1 = (OPJ_UINT32 )((parameters->image_offset_y0 + (h - 1) * subsampling_dy) + 1);
#line 1785
  if (format == 2) {
    _L___38: 
#line 1789
    i = 0;
    {
#line 1789
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1789
      if (! (i < w * h)) {
#line 1789
        goto while_break___0;
      }
#line 1791
      compno = 0;
      {
#line 1791
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 1791
        if (! (compno < numcomps)) {
#line 1791
          goto while_break___1;
        }
        {
#line 1793
        index___34 = 0U;
#line 1794
        __cil_tmp22 = fscanf(fp, "%u", & index___34);
        }
#line 1794
        if (__cil_tmp22 != 1) {
          {
#line 1795
          fprintf(stderr, "\nWARNING: fscanf return a number of element different from the expected.\n");
          }
        }
#line 1797
        *((image->comps + compno)->data + i) = (OPJ_INT32 )((index___34 * 255U) / (unsigned int )header_info.maxval);
#line 1791
        compno ++;
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___1: 
#line 1789
      i ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___0: ;
  } else
#line 1785
  if (format == 3) {
#line 1785
    goto _L___38;
  } else
#line 1802
  if (format == 5) {
    _L: 
#line 1810
    one = (unsigned char )(prec < 9);
#line 1812
    i = 0;
    {
#line 1812
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 1812
      if (! (i < w * h)) {
#line 1812
        goto while_break___2;
      }
#line 1814
      compno = 0;
      {
#line 1814
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 1814
        if (! (compno < numcomps)) {
#line 1814
          goto while_break___3;
        }
        {
#line 1816
        __cil_tmp28 = fread((void *)(& c0), 1UL, 1UL, fp);
        }
#line 1816
        if (! __cil_tmp28) {
          {
#line 1817
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
          }
        }
#line 1818
        if (one) {
#line 1820
          *((image->comps + compno)->data + i) = (OPJ_INT32 )c0;
        } else {
          {
#line 1824
          __cil_tmp29 = fread((void *)(& c1), 1UL, 1UL, fp);
          }
#line 1824
          if (! __cil_tmp29) {
            {
#line 1825
            fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
            }
          }
#line 1827
          *((image->comps + compno)->data + i) = ((int )c0 << 8) | (int )c1;
        }
#line 1814
        compno ++;
      }
      while_break___12: /* CIL Label */ ;
      }
      while_break___3: 
#line 1812
      i ++;
    }
    while_break___11: /* CIL Label */ ;
    }
    while_break___2: ;
  } else
#line 1802
  if (format == 6) {
#line 1802
    goto _L;
  } else
#line 1802
  if (format == 7) {
#line 1802
    if ((int )header_info.gray) {
#line 1802
      goto _L;
    } else
#line 1802
    if ((int )header_info.graya) {
#line 1802
      goto _L;
    } else
#line 1802
    if ((int )header_info.rgb) {
#line 1802
      goto _L;
    } else
#line 1802
    if ((int )header_info.rgba) {
#line 1802
      goto _L;
    } else {
#line 1802
      goto _L___36;
    }
  } else
  _L___36: 
#line 1833
  if (format == 1) {
#line 1835
    i = 0;
    {
#line 1835
    while (1) {
      while_continue___4: /* CIL Label */ ;

#line 1835
      if (! (i < w * h)) {
#line 1835
        goto while_break___4;
      }
      {
#line 1839
      __cil_tmp33 = fscanf(fp, "%u", & index___35);
      }
#line 1839
      if (__cil_tmp33 != 1) {
        {
#line 1840
        fprintf(stderr, "\nWARNING: fscanf return a number of element different from the expected.\n");
        }
      }
#line 1842
      if (index___35) {
#line 1842
        tmp = 0;
      } else {
#line 1842
        tmp = 255;
      }
#line 1842
      *((image->comps + 0)->data + i) = tmp;
#line 1835
      i ++;
    }
    while_break___13: /* CIL Label */ ;
    }
    while_break___4: ;
  } else
#line 1846
  if (format == 4) {
#line 1851
    i = 0;
#line 1852
    y = 0;
    {
#line 1852
    while (1) {
      while_continue___5: /* CIL Label */ ;

#line 1852
      if (! (y < h)) {
#line 1852
        goto while_break___5;
      }
#line 1854
      bit = -1;
#line 1854
      uc = (unsigned char)0;
#line 1856
      x = 0;
      {
#line 1856
      while (1) {
        while_continue___6: /* CIL Label */ ;

#line 1856
        if (! (x < w)) {
#line 1856
          goto while_break___6;
        }
#line 1858
        if (bit == -1) {
          {
#line 1860
          bit = 7;
#line 1861
          __cil_tmp40 = getc(fp);
#line 1861
          uc = (unsigned char )__cil_tmp40;
          }
        }
#line 1863
        if (((int )uc >> bit) & 1) {
#line 1863
          tmp___0 = 0;
        } else {
#line 1863
          tmp___0 = 255;
        }
#line 1863
        *((image->comps + 0)->data + i) = tmp___0;
#line 1864
        bit --;
#line 1864
        i ++;
#line 1856
        x ++;
      }
      while_break___15: /* CIL Label */ ;
      }
      while_break___6: 
#line 1852
      y ++;
    }
    while_break___14: /* CIL Label */ ;
    }
    while_break___5: ;
  } else
#line 1869
  if (format == 7) {
#line 1869
    if ((int )header_info.bw) {
#line 1873
      i = 0;
      {
#line 1873
      while (1) {
        while_continue___7: /* CIL Label */ ;

#line 1873
        if (! (i < w * h)) {
#line 1873
          goto while_break___7;
        }
        {
#line 1875
        __cil_tmp43 = fread((void *)(& uc___0), 1UL, 1UL, fp);
        }
#line 1875
        if (! __cil_tmp43) {
          {
#line 1876
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
          }
        }
#line 1877
        if ((int )uc___0 & 1) {
#line 1877
          tmp___1 = 0;
        } else {
#line 1877
          tmp___1 = 255;
        }
#line 1877
        *((image->comps + 0)->data + i) = tmp___1;
#line 1873
        i ++;
      }
      while_break___16: /* CIL Label */ ;
      }
      while_break___7: ;
    }
  }
  {
#line 1880
  fclose(fp);
  }
#line 1882
  return (image);
}
}
#line 1885 "/root/patron/new_22/src/bin/jp2/convert.c"
int imagetopnm(opj_image_t *image , char const   *outfile ) 
{ 
  int *red ;
  int *green ;
  int *blue ;
  int *alpha ;
  int wr ;
  int hr ;
  int max ;
  int i ;
  int compno ;
  int ncomp ;
  int adjustR ;
  int adjustG ;
  int adjustB ;
  int adjustA ;
  int fails ;
  int two ;
  int want_gray ;
  int has_alpha ;
  int triple ;
  int prec ;
  int v ;
  FILE *fdest ;
  char const   *tmp ;
  char *destname ;
  char const   *tt ;
  char const   *tmp___39 ;
  char const   *__cil_tmp30 ;
  int tmp___40 ;
  char const   *__cil_tmp32 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int *__cil_tmp36 ;
  int *__cil_tmp37 ;
  int *__cil_tmp38 ;
  int *__cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  void *__cil_tmp41 ;
  char const   *__cil_tmp43 ;
  int tmp___44 ;
  int *__cil_tmp45 ;
  int tmp___45 ;
  int tmp___46 ;

  {
#line 1893
  fdest = (FILE *)((void *)0);
#line 1894
  tmp = outfile;
#line 1896
  alpha = (int *)((void *)0);
#line 1897
  prec = (int )(image->comps + 0)->prec;
#line 1897
  if (prec > 16) {
    {
#line 1899
    fprintf(stderr, "%s:%d:imagetopnm\n\tprecision %d is larger than 16\n\t: refused.\n",
            "/root/patron/new_22/src/bin/jp2/convert.c\037\347\212\202U", 1900, prec);
    }
#line 1901
    return (1);
  }
#line 1903
  has_alpha = 0;
#line 1903
  two = has_alpha;
#line 1903
  fails = 1;
#line 1904
  ncomp = (int )image->numcomps;
  {
#line 1906
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1906
    if (! *tmp) {
#line 1906
      goto while_break;
    }
#line 1906
    tmp ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: 
#line 1906
  tmp -= 2;
#line 1907
  if ((int )*tmp == 103) {
#line 1907
    tmp___45 = 1;
  } else
#line 1907
  if ((int )*tmp == 71) {
#line 1907
    tmp___45 = 1;
  } else {
#line 1907
    tmp___45 = 0;
  }
#line 1907
  want_gray = tmp___45;
#line 1908
  ncomp = (int )image->numcomps;
#line 1910
  if (want_gray) {
#line 1910
    ncomp = 1;
  }
#line 1912
  if (ncomp == 2) {
    _L: 
    {
#line 1922
    fdest = fopen(outfile, "wb");
    }
#line 1924
    if (! fdest) {
      {
#line 1926
      fprintf(stderr, "ERROR -> failed to open %s for writing\n", outfile);
      }
#line 1927
      return (fails);
    }
#line 1929
    two = prec > 8;
#line 1930
    triple = ncomp > 2;
#line 1931
    wr = (int )(image->comps + 0)->w;
#line 1931
    hr = (int )(image->comps + 0)->h;
#line 1932
    max = (1 << prec) - 1;
#line 1932
    if (ncomp == 4) {
#line 1932
      tmp___46 = 1;
    } else
#line 1932
    if (ncomp == 2) {
#line 1932
      tmp___46 = 1;
    } else {
#line 1932
      tmp___46 = 0;
    }
#line 1932
    has_alpha = tmp___46;
#line 1934
    red = (image->comps + 0)->data;
#line 1936
    if (triple) {
#line 1938
      green = (image->comps + 1)->data;
#line 1939
      blue = (image->comps + 2)->data;
    } else {
#line 1941
      blue = (int *)((void *)0);
#line 1941
      green = blue;
    }
#line 1943
    if (has_alpha) {
#line 1945
      if (triple) {
        {
#line 1945
        strcpy((char *)tmp___39, "RGB_ALPHA\343\346\212\202U");
        }
      } else {
        {
#line 1945
        strcpy((char *)tmp___39, "GRAYSCALE_ALPHA");
        }
      }
      {
#line 1945
      tt = tmp___39;
#line 1947
      __cil_tmp30 = opj_version();
#line 1947
      fprintf(fdest, "P7\n# OpenJPEG-%s\nWIDTH %d\nHEIGHT %d\nDEPTH %d\nMAXVAL %d\nTUPLTYPE %s\nENDHDR\n",
              __cil_tmp30, wr, hr, ncomp, max, tt);
#line 1950
      alpha = (image->comps + (ncomp - 1))->data;
      }
#line 1951
      if ((image->comps + (ncomp - 1))->sgnd) {
#line 1951
        tmp___40 = 1 << ((image->comps + (ncomp - 1))->prec - 1U);
      } else {
#line 1951
        tmp___40 = 0;
      }
#line 1951
      adjustA = tmp___40;
    } else {
      {
#line 1956
      __cil_tmp32 = opj_version();
#line 1956
      fprintf(fdest, "P6\n# OpenJPEG-%s\n%d %d\n%d\n", __cil_tmp32, wr, hr, max);
#line 1958
      adjustA = 0;
      }
    }
#line 1960
    if ((image->comps + 0)->sgnd) {
#line 1960
      tmp___41 = 1 << ((image->comps + 0)->prec - 1U);
    } else {
#line 1960
      tmp___41 = 0;
    }
#line 1960
    adjustR = tmp___41;
#line 1962
    if (triple) {
#line 1964
      if ((image->comps + 1)->sgnd) {
#line 1964
        tmp___42 = 1 << ((image->comps + 1)->prec - 1U);
      } else {
#line 1964
        tmp___42 = 0;
      }
#line 1964
      adjustG = tmp___42;
#line 1965
      if ((image->comps + 2)->sgnd) {
#line 1965
        tmp___43 = 1 << ((image->comps + 2)->prec - 1U);
      } else {
#line 1965
        tmp___43 = 0;
      }
#line 1965
      adjustB = tmp___43;
    } else {
#line 1967
      adjustB = 0;
#line 1967
      adjustG = adjustB;
    }
#line 1969
    i = 0;
    {
#line 1969
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue___0: ;
#line 1969
      if (! (i < wr * hr)) {
#line 1969
        goto while_break___0;
      }
#line 1971
      if (two) {
        {
#line 1973
        v = *red + adjustR;
#line 1973
        red ++;
#line 1975
        fprintf(fdest, "%c%c\202U", (int )((unsigned char )(v >> 8)), (int )((unsigned char )v));
        }
#line 1977
        if (triple) {
          {
#line 1979
          v = *green + adjustG;
#line 1979
          green ++;
#line 1981
          fprintf(fdest, "%c%c\202U", (int )((unsigned char )(v >> 8)), (int )((unsigned char )v));
#line 1983
          v = *blue + adjustB;
#line 1983
          blue ++;
#line 1985
          fprintf(fdest, "%c%c\202U", (int )((unsigned char )(v >> 8)), (int )((unsigned char )v));
          }
        }
#line 1989
        if (has_alpha) {
          {
#line 1991
          v = *alpha + adjustA;
#line 1991
          alpha ++;
#line 1993
          fprintf(fdest, "%c%c\202U", (int )((unsigned char )(v >> 8)), (int )((unsigned char )v));
          }
        }
#line 1995
        goto while_continue___0;
      }
      {
#line 2001
      __cil_tmp36 = red;
#line 2001
      red ++;
#line 2001
      fprintf(fdest, "%c", (int )((unsigned char )*__cil_tmp36));
      }
#line 2002
      if (triple) {
        {
#line 2003
        __cil_tmp37 = green;
#line 2003
        green ++;
#line 2003
        __cil_tmp38 = blue;
#line 2003
        blue ++;
#line 2003
        fprintf(fdest, "%c%c\202U", (int )((unsigned char )*__cil_tmp37), (int )((unsigned char )*__cil_tmp38));
        }
      }
#line 2005
      if (has_alpha) {
        {
#line 2006
        __cil_tmp39 = alpha;
#line 2006
        alpha ++;
#line 2006
        fprintf(fdest, "%c", (int )((unsigned char )*__cil_tmp39));
        }
      }
#line 1969
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 2010
    fclose(fdest);
    }
#line 2010
    return (0);
  } else
#line 1912
  if (ncomp > 2) {
#line 1912
    if ((image->comps + 0)->dx == (image->comps + 1)->dx) {
#line 1912
      if ((image->comps + 1)->dx == (image->comps + 2)->dx) {
#line 1912
        if ((image->comps + 0)->dy == (image->comps + 1)->dy) {
#line 1912
          if ((image->comps + 1)->dy == (image->comps + 2)->dy) {
#line 1912
            if ((image->comps + 0)->prec == (image->comps + 1)->prec) {
#line 1912
              if ((image->comps + 1)->prec == (image->comps + 2)->prec) {
#line 1912
                goto _L;
              }
            }
          }
        }
      }
    }
  }
#line 2015
  if (image->numcomps > (unsigned int )ncomp) {
    {
#line 2017
    fprintf(stderr, "WARNING -> [PGM file] Only the first component\n");
#line 2018
    fprintf(stderr, "           is written to the file\n");
    }
  }
  {
#line 2020
  __cil_tmp40 = strlen(outfile);
#line 2020
  __cil_tmp41 = malloc(__cil_tmp40 + 8UL);
#line 2020
  destname = (char *)__cil_tmp41;
#line 2022
  compno = 0;
  }
  {
#line 2022
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 2022
    if (! (compno < ncomp)) {
#line 2022
      goto while_break___1;
    }
#line 2024
    if (ncomp > 1) {
      {
#line 2025
      sprintf(destname, "%d.%sU", compno, outfile);
      }
    } else {
      {
#line 2027
      sprintf(destname, "%s\346\212\202U", outfile);
      }
    }
    {
#line 2029
    fdest = fopen((char const   *)destname, "wb\346\212\202U");
    }
#line 2030
    if (! fdest) {
      {
#line 2032
      fprintf(stderr, "ERROR -> failed to open %s for writing\n", destname);
#line 2033
      free((void *)destname);
      }
#line 2034
      return (1);
    }
    {
#line 2036
    wr = (int )(image->comps + compno)->w;
#line 2036
    hr = (int )(image->comps + compno)->h;
#line 2037
    prec = (int )(image->comps + compno)->prec;
#line 2038
    max = (1 << prec) - 1;
#line 2040
    __cil_tmp43 = opj_version();
#line 2040
    fprintf(fdest, "P5\n#OpenJPEG-%s\n%d %d\n%d\n", __cil_tmp43, wr, hr, max);
#line 2043
    red = (image->comps + compno)->data;
    }
#line 2044
    if ((image->comps + compno)->sgnd) {
#line 2044
      tmp___44 = 1 << ((image->comps + compno)->prec - 1U);
    } else {
#line 2044
      tmp___44 = 0;
    }
#line 2044
    adjustR = tmp___44;
#line 2047
    if (prec > 8) {
#line 2049
      i = 0;
      {
#line 2049
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 2049
        if (! (i < wr * hr)) {
#line 2049
          goto while_break___2;
        }
        {
#line 2051
        v = *red + adjustR;
#line 2051
        red ++;
#line 2053
        fprintf(fdest, "%c%c", (int )((unsigned char )(v >> 8)), (int )((unsigned char )v));
        }
#line 2055
        if (has_alpha) {
          {
#line 2057
          __cil_tmp45 = alpha;
#line 2057
          alpha ++;
#line 2057
          v = *__cil_tmp45;
#line 2059
          fprintf(fdest, "%c%c", (int )((unsigned char )(v >> 8)), (int )((unsigned char )v));
          }
        }
#line 2049
        i ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___2: ;
    } else {
#line 2065
      i = 0;
      {
#line 2065
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 2065
        if (! (i < wr * hr)) {
#line 2065
          goto while_break___3;
        }
        {
#line 2067
        fprintf(fdest, "%c", (int )((unsigned char )(*red + adjustR)));
#line 2067
        red ++;
#line 2065
        i ++;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___3: ;
    }
    {
#line 2070
    fclose(fdest);
#line 2022
    compno ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___1: 
  {
#line 2072
  free((void *)destname);
  }
#line 2074
  return (0);
}
}
#line 2084 "/root/patron/new_22/src/bin/jp2/convert.c"
int imagetotif(opj_image_t *image , char const   *outfile ) 
{ 
  int width ;
  int height ;
  int imgsize ;
  int bps ;
  int index___45 ;
  int adjust ;
  int sgnd ;
  int ushift ;
  int dshift ;
  int has_alpha ;
  int force16 ;
  TIFF *tif ;
  tdata_t buf ;
  tstrip_t strip ;
  tsize_t strip_size ;
  int tmp ;
  uint32 __cil_tmp22 ;
  unsigned char *dat8 ;
  tsize_t i ;
  tsize_t ssize ;
  tsize_t last_i ;
  int step ;
  int restx ;
  int r ;
  int g ;
  int b ;
  int a ;
  int r___0 ;
  int g___0 ;
  int b___0 ;
  int a___0 ;
  int r___1 ;
  int g___1 ;
  int b___1 ;
  int a___1 ;
  int r___2 ;
  int g___2 ;
  int b___2 ;
  int a___2 ;
  int step___0 ;
  uint32 __cil_tmp54 ;
  unsigned char *dat8___0 ;
  tsize_t i___0 ;
  tsize_t ssize___0 ;
  tmsize_t __cil_tmp58 ;
  int r___3 ;
  int a___3 ;
  int r___4 ;
  int a___4 ;

  {
#line 2094
  has_alpha = 0;
#line 2094
  force16 = has_alpha;
#line 2094
  dshift = force16;
#line 2094
  ushift = dshift;
#line 2095
  bps = (int )(image->comps + 0)->prec;
#line 2097
  if (bps > 8) {
#line 2097
    if (bps < 16) {
#line 2099
      ushift = 16 - bps;
#line 2099
      dshift = bps - ushift;
#line 2100
      bps = 16;
#line 2100
      force16 = 1;
    }
  }
#line 2103
  if (bps != 8) {
#line 2103
    if (bps != 16) {
      {
#line 2105
      fprintf(stderr, "imagetotif: Bits=%d, Only 8 and 16 bits implemented\n", bps);
#line 2107
      fprintf(stderr, "\tAborting\n");
      }
#line 2108
      return (1);
    }
  }
  {
#line 2110
  tif = TIFFOpen(outfile, "wb\347\212\202U");
  }
#line 2112
  if (! tif) {
    {
#line 2114
    fprintf(stderr, "imagetotif:failed to open %s for writing\n\240\347\212\202U",
            outfile);
    }
#line 2115
    return (1);
  }
#line 2117
  sgnd = (int )(image->comps + 0)->sgnd;
#line 2118
  if (sgnd) {
#line 2118
    tmp = 1 << ((image->comps + 0)->prec - 1U);
  } else {
#line 2118
    tmp = 0;
  }
#line 2118
  adjust = tmp;
#line 2120
  if (image->numcomps >= 3U) {
#line 2120
    if ((image->comps + 0)->dx == (image->comps + 1)->dx) {
#line 2120
      if ((image->comps + 1)->dx == (image->comps + 2)->dx) {
#line 2120
        if ((image->comps + 0)->dy == (image->comps + 1)->dy) {
#line 2120
          if ((image->comps + 1)->dy == (image->comps + 2)->dy) {
#line 2120
            if ((image->comps + 0)->prec == (image->comps + 1)->prec) {
#line 2120
              if ((image->comps + 1)->prec == (image->comps + 2)->prec) {
                {
#line 2128
                has_alpha = image->numcomps == 4U;
#line 2130
                width = (int )(image->comps + 0)->w;
#line 2131
                height = (int )(image->comps + 0)->h;
#line 2132
                imgsize = width * height;
#line 2134
                TIFFSetField(tif, (uint32 )256, width);
#line 2135
                TIFFSetField(tif, (uint32 )257, height);
#line 2136
                TIFFSetField(tif, (uint32 )277, 3 + has_alpha);
#line 2137
                TIFFSetField(tif, (uint32 )258, bps);
#line 2138
                TIFFSetField(tif, (uint32 )274, 1);
#line 2139
                TIFFSetField(tif, (uint32 )284, 1);
#line 2140
                TIFFSetField(tif, (uint32 )262, 2);
#line 2141
                TIFFSetField(tif, (uint32 )278, 1);
#line 2142
                strip_size = TIFFStripSize(tif);
#line 2143
                buf = _TIFFmalloc(strip_size);
#line 2144
                index___45 = 0;
#line 2146
                strip = (tstrip_t )0;
                }
                {
#line 2146
                while (1) {
                  while_continue: /* CIL Label */ ;

#line 2146
                  if (! (strip < __cil_tmp22)) {
#line 2146
                    goto while_break;
                  }
                  {
#line 2149
                  last_i = (tsize_t )0;
#line 2151
                  ssize = TIFFStripSize(tif);
#line 2152
                  dat8 = (unsigned char *)buf;
                  }
#line 2154
                  if (bps == 8) {
#line 2156
                    step = 3 + has_alpha;
#line 2157
                    restx = step - 1;
#line 2159
                    i = (tsize_t )0;
                    {
#line 2159
                    while (1) {
                      while_continue___0: /* CIL Label */ ;

#line 2159
                      if (! (i < ssize - (long )restx)) {
#line 2159
                        goto while_break___0;
                      }
#line 2161
                      a = 0;
#line 2163
                      if (index___45 < imgsize) {
#line 2165
                        r = *((image->comps + 0)->data + index___45);
#line 2166
                        g = *((image->comps + 1)->data + index___45);
#line 2167
                        b = *((image->comps + 2)->data + index___45);
#line 2168
                        if (has_alpha) {
#line 2168
                          a = *((image->comps + 3)->data + index___45);
                        }
#line 2170
                        if (sgnd) {
#line 2172
                          r += adjust;
#line 2173
                          g += adjust;
#line 2174
                          b += adjust;
#line 2175
                          if (has_alpha) {
#line 2175
                            a += adjust;
                          }
                        }
#line 2177
                        *(dat8 + i) = (unsigned char )r;
#line 2178
                        *(dat8 + (i + 1L)) = (unsigned char )g;
#line 2179
                        *(dat8 + (i + 2L)) = (unsigned char )b;
#line 2180
                        if (has_alpha) {
#line 2180
                          *(dat8 + (i + 3L)) = (unsigned char )a;
                        }
#line 2182
                        index___45 ++;
#line 2183
                        last_i = i + (long )step;
                      } else {
#line 2186
                        goto while_break___0;
                      }
#line 2159
                      i += (long )step;
                    }
                    while_break___8: /* CIL Label */ ;
                    }
                    while_break___0: ;
#line 2189
                    if (last_i < ssize) {
#line 2191
                      i = last_i;
                      {
#line 2191
                      while (1) {
                        while_continue___1: /* CIL Label */ ;

#line 2191
                        if (! (i < ssize)) {
#line 2191
                          goto while_break___1;
                        }
#line 2193
                        a___0 = 0;
#line 2195
                        if (index___45 < imgsize) {
#line 2197
                          r___0 = *((image->comps + 0)->data + index___45);
#line 2198
                          g___0 = *((image->comps + 1)->data + index___45);
#line 2199
                          b___0 = *((image->comps + 2)->data + index___45);
#line 2200
                          if (has_alpha) {
#line 2200
                            a___0 = *((image->comps + 3)->data + index___45);
                          }
#line 2202
                          if (sgnd) {
#line 2204
                            r___0 += adjust;
#line 2205
                            g___0 += adjust;
#line 2206
                            b___0 += adjust;
#line 2207
                            if (has_alpha) {
#line 2207
                              a___0 += adjust;
                            }
                          }
#line 2209
                          *(dat8 + i) = (unsigned char )r___0;
#line 2210
                          if (i + 1L < ssize) {
#line 2210
                            *(dat8 + (i + 1L)) = (unsigned char )g___0;
                          } else {
#line 2210
                            goto while_break___1;
                          }
#line 2211
                          if (i + 2L < ssize) {
#line 2211
                            *(dat8 + (i + 2L)) = (unsigned char )b___0;
                          } else {
#line 2211
                            goto while_break___1;
                          }
#line 2212
                          if (has_alpha) {
#line 2214
                            if (i + 3L < ssize) {
#line 2214
                              *(dat8 + (i + 3L)) = (unsigned char )a___0;
                            } else {
#line 2214
                              goto while_break___1;
                            }
                          }
#line 2216
                          index___45 ++;
                        } else {
#line 2219
                          goto while_break___1;
                        }
#line 2191
                        i += (long )step;
                      }
                      while_break___9: /* CIL Label */ ;
                      }
                      while_break___1: ;
                    }
                  } else
#line 2225
                  if (bps == 16) {
#line 2227
                    step = (6 + has_alpha) + has_alpha;
#line 2228
                    restx = step - 1;
#line 2230
                    i = (tsize_t )0;
                    {
#line 2230
                    while (1) {
                      while_continue___2: /* CIL Label */ ;

#line 2230
                      if (! (i < ssize - (long )restx)) {
#line 2230
                        goto while_break___2;
                      }
#line 2232
                      a___1 = 0;
#line 2234
                      if (index___45 < imgsize) {
#line 2236
                        r___1 = *((image->comps + 0)->data + index___45);
#line 2237
                        g___1 = *((image->comps + 1)->data + index___45);
#line 2238
                        b___1 = *((image->comps + 2)->data + index___45);
#line 2239
                        if (has_alpha) {
#line 2239
                          a___1 = *((image->comps + 3)->data + index___45);
                        }
#line 2241
                        if (sgnd) {
#line 2243
                          r___1 += adjust;
#line 2244
                          g___1 += adjust;
#line 2245
                          b___1 += adjust;
#line 2246
                          if (has_alpha) {
#line 2246
                            a___1 += adjust;
                          }
                        }
#line 2248
                        if (force16) {
#line 2250
                          r___1 = (r___1 << ushift) + (r___1 >> dshift);
#line 2251
                          g___1 = (g___1 << ushift) + (g___1 >> dshift);
#line 2252
                          b___1 = (b___1 << ushift) + (b___1 >> dshift);
#line 2253
                          if (has_alpha) {
#line 2253
                            a___1 = (a___1 << ushift) + (a___1 >> dshift);
                          }
                        }
#line 2255
                        *(dat8 + i) = (unsigned char )r___1;
#line 2256
                        *(dat8 + (i + 1L)) = (unsigned char )(r___1 >> 8);
#line 2257
                        *(dat8 + (i + 2L)) = (unsigned char )g___1;
#line 2258
                        *(dat8 + (i + 3L)) = (unsigned char )(g___1 >> 8);
#line 2259
                        *(dat8 + (i + 4L)) = (unsigned char )b___1;
#line 2260
                        *(dat8 + (i + 5L)) = (unsigned char )(b___1 >> 8);
#line 2261
                        if (has_alpha) {
#line 2263
                          *(dat8 + (i + 6L)) = (unsigned char )a___1;
#line 2264
                          *(dat8 + (i + 7L)) = (unsigned char )(a___1 >> 8);
                        }
#line 2266
                        index___45 ++;
#line 2267
                        last_i = i + (long )step;
                      } else {
#line 2270
                        goto while_break___2;
                      }
#line 2230
                      i += (long )step;
                    }
                    while_break___10: /* CIL Label */ ;
                    }
                    while_break___2: ;
#line 2273
                    if (last_i < ssize) {
#line 2275
                      i = last_i;
                      {
#line 2275
                      while (1) {
                        while_continue___3: /* CIL Label */ ;

#line 2275
                        if (! (i < ssize)) {
#line 2275
                          goto while_break___3;
                        }
#line 2277
                        a___2 = 0;
#line 2279
                        if (index___45 < imgsize) {
#line 2281
                          r___2 = *((image->comps + 0)->data + index___45);
#line 2282
                          g___2 = *((image->comps + 1)->data + index___45);
#line 2283
                          b___2 = *((image->comps + 2)->data + index___45);
#line 2284
                          if (has_alpha) {
#line 2284
                            a___2 = *((image->comps + 3)->data + index___45);
                          }
#line 2286
                          if (sgnd) {
#line 2288
                            r___2 += adjust;
#line 2289
                            g___2 += adjust;
#line 2290
                            b___2 += adjust;
#line 2291
                            if (has_alpha) {
#line 2291
                              a___2 += adjust;
                            }
                          }
#line 2293
                          if (force16) {
#line 2295
                            r___2 = (r___2 << ushift) + (r___2 >> dshift);
#line 2296
                            g___2 = (g___2 << ushift) + (g___2 >> dshift);
#line 2297
                            b___2 = (b___2 << ushift) + (b___2 >> dshift);
#line 2298
                            if (has_alpha) {
#line 2298
                              a___2 = (a___2 << ushift) + (a___2 >> dshift);
                            }
                          }
#line 2300
                          *(dat8 + i) = (unsigned char )r___2;
#line 2301
                          if (i + 1L < ssize) {
#line 2301
                            *(dat8 + (i + 1L)) = (unsigned char )(r___2 >> 8);
                          } else {
#line 2301
                            goto while_break___3;
                          }
#line 2302
                          if (i + 2L < ssize) {
#line 2302
                            *(dat8 + (i + 2L)) = (unsigned char )g___2;
                          } else {
#line 2302
                            goto while_break___3;
                          }
#line 2303
                          if (i + 3L < ssize) {
#line 2303
                            *(dat8 + (i + 3L)) = (unsigned char )(g___2 >> 8);
                          } else {
#line 2303
                            goto while_break___3;
                          }
#line 2304
                          if (i + 4L < ssize) {
#line 2304
                            *(dat8 + (i + 4L)) = (unsigned char )b___2;
                          } else {
#line 2304
                            goto while_break___3;
                          }
#line 2305
                          if (i + 5L < ssize) {
#line 2305
                            *(dat8 + (i + 5L)) = (unsigned char )(b___2 >> 8);
                          } else {
#line 2305
                            goto while_break___3;
                          }
#line 2307
                          if (has_alpha) {
#line 2309
                            if (i + 6L < ssize) {
#line 2309
                              *(dat8 + (i + 6L)) = (unsigned char )a___2;
                            } else {
#line 2309
                              goto while_break___3;
                            }
#line 2310
                            if (i + 7L < ssize) {
#line 2310
                              *(dat8 + (i + 7L)) = (unsigned char )(a___2 >> 8);
                            } else {
#line 2310
                              goto while_break___3;
                            }
                          }
#line 2312
                          index___45 ++;
                        } else {
#line 2315
                          goto while_break___3;
                        }
#line 2275
                        i += (long )step;
                      }
                      while_break___11: /* CIL Label */ ;
                      }
                      while_break___3: ;
                    }
                  }
                  {
#line 2320
                  TIFFWriteEncodedStrip(tif, strip, buf, strip_size);
#line 2146
                  strip ++;
                  }
                }
                while_break___7: /* CIL Label */ ;
                }
                while_break: 
                {
#line 2323
                _TIFFfree(buf);
#line 2324
                TIFFClose(tif);
                }
#line 2326
                return (0);
              }
            }
          }
        }
      }
    }
  }
#line 2329
  if (image->numcomps == 1U) {
    _L: 
    {
#line 2337
    has_alpha = image->numcomps == 2U;
#line 2339
    width = (int )(image->comps + 0)->w;
#line 2340
    height = (int )(image->comps + 0)->h;
#line 2341
    imgsize = width * height;
#line 2344
    TIFFSetField(tif, (uint32 )256, width);
#line 2345
    TIFFSetField(tif, (uint32 )257, height);
#line 2346
    TIFFSetField(tif, (uint32 )277, 1 + has_alpha);
#line 2347
    TIFFSetField(tif, (uint32 )258, bps);
#line 2348
    TIFFSetField(tif, (uint32 )274, 1);
#line 2349
    TIFFSetField(tif, (uint32 )284, 1);
#line 2350
    TIFFSetField(tif, (uint32 )262, 1);
#line 2351
    TIFFSetField(tif, (uint32 )278, 1);
#line 2354
    strip_size = TIFFStripSize(tif);
#line 2355
    buf = _TIFFmalloc(strip_size);
#line 2356
    index___45 = 0;
#line 2358
    strip = (tstrip_t )0;
    }
    {
#line 2358
    while (1) {
      while_continue___4: /* CIL Label */ ;

#line 2358
      if (! (strip < __cil_tmp54)) {
#line 2358
        goto while_break___4;
      }
      {
#line 2361
      __cil_tmp58 = TIFFStripSize(tif);
#line 2361
      ssize___0 = __cil_tmp58;
#line 2362
      dat8___0 = (unsigned char *)buf;
      }
#line 2364
      if (bps == 8) {
#line 2366
        step___0 = 1 + has_alpha;
#line 2368
        i___0 = (tsize_t )0;
        {
#line 2368
        while (1) {
          while_continue___5: /* CIL Label */ ;

#line 2368
          if (! (i___0 < ssize___0)) {
#line 2368
            goto while_break___5;
          }
#line 2370
          if (index___45 < imgsize) {
#line 2372
            a___3 = 0;
#line 2374
            r___3 = *((image->comps + 0)->data + index___45);
#line 2375
            if (has_alpha) {
#line 2375
              a___3 = *((image->comps + 1)->data + index___45);
            }
#line 2377
            if (sgnd) {
#line 2379
              r___3 += adjust;
#line 2380
              if (has_alpha) {
#line 2380
                a___3 += adjust;
              }
            }
#line 2382
            *(dat8___0 + i___0) = (unsigned char )r___3;
#line 2383
            if (has_alpha) {
#line 2383
              *(dat8___0 + (i___0 + 1L)) = (unsigned char )a___3;
            }
#line 2384
            index___45 ++;
          } else {
#line 2387
            goto while_break___5;
          }
#line 2368
          i___0 += (long )step___0;
        }
        while_break___13: /* CIL Label */ ;
        }
        while_break___5: ;
      } else
#line 2391
      if (bps == 16) {
#line 2393
        step___0 = (2 + has_alpha) + has_alpha;
#line 2395
        i___0 = (tsize_t )0;
        {
#line 2395
        while (1) {
          while_continue___6: /* CIL Label */ ;

#line 2395
          if (! (i___0 < ssize___0)) {
#line 2395
            goto while_break___6;
          }
#line 2397
          if (index___45 < imgsize) {
#line 2399
            a___4 = 0;
#line 2401
            r___4 = *((image->comps + 0)->data + index___45);
#line 2402
            if (has_alpha) {
#line 2402
              a___4 = *((image->comps + 1)->data + index___45);
            }
#line 2404
            if (sgnd) {
#line 2406
              r___4 += adjust;
#line 2407
              if (has_alpha) {
#line 2407
                a___4 += adjust;
              }
            }
#line 2409
            if (force16) {
#line 2411
              r___4 = (r___4 << ushift) + (r___4 >> dshift);
#line 2412
              if (has_alpha) {
#line 2412
                a___4 = (a___4 << ushift) + (a___4 >> dshift);
              }
            }
#line 2414
            *(dat8___0 + i___0) = (unsigned char )r___4;
#line 2415
            *(dat8___0 + (i___0 + 1L)) = (unsigned char )(r___4 >> 8);
#line 2416
            if (has_alpha) {
#line 2418
              *(dat8___0 + (i___0 + 2L)) = (unsigned char )a___4;
#line 2419
              *(dat8___0 + (i___0 + 3L)) = (unsigned char )(a___4 >> 8);
            }
#line 2421
            index___45 ++;
          } else {
#line 2424
            goto while_break___6;
          }
#line 2395
          i___0 += (long )step___0;
        }
        while_break___14: /* CIL Label */ ;
        }
        while_break___6: ;
      }
      {
#line 2427
      TIFFWriteEncodedStrip(tif, strip, buf, strip_size);
#line 2358
      strip ++;
      }
    }
    while_break___12: /* CIL Label */ ;
    }
    while_break___4: 
    {
#line 2430
    _TIFFfree(buf);
#line 2431
    TIFFClose(tif);
    }
#line 2433
    return (0);
  } else
#line 2329
  if (image->numcomps == 2U) {
#line 2329
    if ((image->comps + 0)->dx == (image->comps + 1)->dx) {
#line 2329
      if ((image->comps + 0)->dy == (image->comps + 1)->dy) {
#line 2329
        if ((image->comps + 0)->prec == (image->comps + 1)->prec) {
#line 2329
          goto _L;
        }
      }
    }
  }
  {
#line 2436
  TIFFClose(tif);
#line 2438
  fprintf(stderr, "imagetotif: Bad color format.\n\tOnly RGB(A) and GRAY(A) has been implemented\n\220");
#line 2440
  fprintf(stderr, "\tFOUND: numcomps(%d)\n\tAborting\n", image->numcomps);
  }
#line 2443
  return (1);
}
}
#line 2450 "/root/patron/new_22/src/bin/jp2/convert.c"
opj_image_t *tiftoimage(char const   *filename , opj_cparameters_t *parameters ) 
{ 
  int subsampling_dx ;
  int subsampling_dy ;
  TIFF *tif ;
  tdata_t buf ;
  tstrip_t strip ;
  tsize_t strip_size ;
  int j ;
  int numcomps ;
  int w ;
  int h ;
  int index___46 ;
  OPJ_COLOR_SPACE color_space ;
  opj_image_cmptparm_t cmptparm[4] ;
  opj_image_t *image ;
  int imgsize ;
  int has_alpha ;
  unsigned short tiBps ;
  unsigned short tiPhoto ;
  unsigned short tiSf ;
  unsigned short tiSpp ;
  unsigned short tiPC ;
  unsigned int tiWidth ;
  unsigned int tiHeight ;
  uint16 *sampleinfo ;
  uint16 extrasamples ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  tmsize_t __cil_tmp33 ;
  void *__cil_tmp34 ;
  uint32 __cil_tmp36 ;
  unsigned char *dat8 ;
  int step ;
  tsize_t i ;
  tsize_t ssize ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  tmsize_t __cil_tmp48 ;
  void *__cil_tmp49 ;
  uint32 __cil_tmp51 ;
  unsigned char *dat8___0 ;
  tsize_t i___0 ;
  tsize_t ssize___0 ;
  int step___0 ;

  {
  {
#line 2452
  subsampling_dx = parameters->subsampling_dx;
#line 2453
  subsampling_dy = parameters->subsampling_dy;
#line 2461
  image = (opj_image_t *)((void *)0);
#line 2462
  imgsize = 0;
#line 2463
  has_alpha = 0;
#line 2467
  tif = TIFFOpen(filename, "r\300\350\212\202U");
  }
#line 2469
  if (! tif) {
    {
#line 2471
    fprintf(stderr, "tiftoimage:Failed to open %s for reading\n", filename);
    }
#line 2472
    return ((opj_image_t *)0);
  }
  {
#line 2474
  tiPC = (unsigned short)0;
#line 2474
  tiSpp = tiPC;
#line 2474
  tiSf = tiSpp;
#line 2474
  tiPhoto = tiSf;
#line 2474
  tiBps = tiPhoto;
#line 2475
  tiHeight = 0U;
#line 2475
  tiWidth = tiHeight;
#line 2477
  TIFFGetField(tif, (uint32 )256, & tiWidth);
#line 2478
  TIFFGetField(tif, (uint32 )257, & tiHeight);
#line 2479
  TIFFGetField(tif, (uint32 )258, & tiBps);
#line 2480
  TIFFGetField(tif, (uint32 )339, & tiSf);
#line 2481
  TIFFGetField(tif, (uint32 )277, & tiSpp);
#line 2482
  TIFFGetField(tif, (uint32 )262, & tiPhoto);
#line 2483
  TIFFGetField(tif, (uint32 )284, & tiPC);
#line 2484
  w = (int )tiWidth;
#line 2485
  h = (int )tiHeight;
  }
#line 2487
  if ((int )tiBps != 8) {
#line 2487
    if ((int )tiBps != 16) {
#line 2487
      if ((int )tiBps != 12) {
#line 2487
        tiBps = (unsigned short)0;
      }
    }
  }
#line 2488
  if ((int )tiPhoto != 1) {
#line 2488
    if ((int )tiPhoto != 2) {
#line 2488
      tiPhoto = (unsigned short)0;
    }
  }
#line 2490
  if (! tiBps) {
    _L: 
#line 2492
    if (! tiBps) {
      {
#line 2493
      fprintf(stderr, "imagetotif: Bits=%d, Only 8 and 16 bits implemented\n\230\001",
              (int )tiBps);
      }
    } else
#line 2496
    if (! tiPhoto) {
      {
#line 2497
      fprintf(stderr, "tiftoimage: Bad color format %d.\n\tOnly RGB(A) and GRAY(A) has been implemented\n",
              (int )tiPhoto);
      }
    }
    {
#line 2500
    fprintf(stderr, "\tAborting\n\350\212\202U");
#line 2501
    TIFFClose(tif);
    }
#line 2503
    return ((opj_image_t *)((void *)0));
  } else
#line 2490
  if (! tiPhoto) {
#line 2490
    goto _L;
  }
  {
#line 2510
  TIFFGetFieldDefaulted(tif, (uint32 )338, & extrasamples, & sampleinfo);
  }
#line 2513
  if ((int )extrasamples >= 1) {
#line 2517
    if ((int )*(sampleinfo + 0) == 0) {
#line 2517
      goto case_0;
    }
#line 2525
    if ((int )*(sampleinfo + 0) == 2) {
#line 2525
      goto case_2;
    }
#line 2525
    if ((int )*(sampleinfo + 0) == 1) {
#line 2525
      goto case_2;
    }
#line 2515
    goto switch_break;
    case_0: 
#line 2520
    if ((int )tiSpp > 3) {
#line 2521
      has_alpha = 1;
    }
#line 2522
    goto switch_break;
    case_2: 
#line 2526
    has_alpha = 1;
#line 2527
    goto switch_break;
    switch_break: ;
  } else
#line 2531
  if ((int )tiSpp == 4) {
#line 2531
    has_alpha = 1;
  } else
#line 2531
  if ((int )tiSpp == 2) {
#line 2531
    has_alpha = 1;
  }
  {
#line 2536
  memset((void *)(& cmptparm[0]), 0, 4UL * sizeof(opj_image_cmptparm_t ));
  }
#line 2538
  if ((int )tiPhoto == 2) {
#line 2538
    if ((unsigned int )parameters->cp_cinema) {
      {
#line 2539
      fprintf(stdout, "WARNING:\nInput image bitdepth is %d bits\nTIF conversion has automatically rescaled to 12-bits\nto comply with cinema profiles.\n",
              (int )tiBps);
      }
    }
  }
#line 2546
  if ((int )tiPhoto == 2) {
#line 2548
    numcomps = 3 + has_alpha;
#line 2549
    color_space = (OPJ_COLOR_SPACE )1;
#line 2552
    j = 0;
    {
#line 2552
    while (1) {
      while_continue: /* CIL Label */ ;

#line 2552
      if (! (j < numcomps)) {
#line 2552
        goto while_break;
      }
#line 2554
      if (parameters->cp_cinema) {
#line 2556
        cmptparm[j].prec = (OPJ_UINT32 )12;
#line 2557
        cmptparm[j].bpp = (OPJ_UINT32 )12;
      } else {
#line 2561
        cmptparm[j].prec = (OPJ_UINT32 )tiBps;
#line 2562
        cmptparm[j].bpp = (OPJ_UINT32 )tiBps;
      }
#line 2564
      cmptparm[j].dx = (OPJ_UINT32 )subsampling_dx;
#line 2565
      cmptparm[j].dy = (OPJ_UINT32 )subsampling_dy;
#line 2566
      cmptparm[j].w = (OPJ_UINT32 )w;
#line 2567
      cmptparm[j].h = (OPJ_UINT32 )h;
#line 2552
      j ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break: 
    {
#line 2577
    image = opj_image_create((OPJ_UINT32 )numcomps, & cmptparm[0], color_space);
    }
#line 2580
    if (! image) {
      {
#line 2582
      TIFFClose(tif);
      }
#line 2583
      return ((opj_image_t *)((void *)0));
    }
#line 2587
    image->x0 = (OPJ_UINT32 )parameters->image_offset_x0;
#line 2588
    image->y0 = (OPJ_UINT32 )parameters->image_offset_y0;
#line 2589
    if (! image->x0) {
#line 2589
      tmp = (unsigned int )((w - 1) * subsampling_dx + 1);
    } else {
#line 2589
      tmp = (image->x0 + (unsigned int )((w - 1) * subsampling_dx)) + 1U;
    }
#line 2589
    image->x1 = tmp;
#line 2591
    if (! image->y0) {
#line 2591
      tmp___0 = (unsigned int )((h - 1) * subsampling_dy + 1);
    } else {
#line 2591
      tmp___0 = (image->y0 + (unsigned int )((h - 1) * subsampling_dy)) + 1U;
    }
    {
#line 2591
    image->y1 = tmp___0;
#line 2594
    __cil_tmp33 = TIFFStripSize(tif);
#line 2594
    __cil_tmp34 = _TIFFmalloc(__cil_tmp33);
#line 2594
    buf = __cil_tmp34;
#line 2596
    strip_size = TIFFStripSize(tif);
#line 2597
    index___46 = 0;
#line 2598
    imgsize = (int )((image->comps + 0)->w * (image->comps + 0)->h);
#line 2601
    strip = (tstrip_t )0;
    }
    {
#line 2601
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 2601
      if (! (strip < __cil_tmp36)) {
#line 2601
        goto while_break___0;
      }
      {
#line 2606
      ssize = TIFFReadEncodedStrip(tif, strip, buf, strip_size);
#line 2607
      dat8 = (unsigned char *)buf;
      }
#line 2609
      if ((int )tiBps == 16) {
#line 2611
        step = (6 + has_alpha) + has_alpha;
#line 2613
        i = (tsize_t )0;
        {
#line 2613
        while (1) {
          while_continue___1: /* CIL Label */ ;

#line 2613
          if (! (i < ssize)) {
#line 2613
            goto while_break___1;
          }
#line 2615
          if (index___46 < imgsize) {
#line 2617
            *((image->comps + 0)->data + index___46) = ((int )*(dat8 + (i + 1L)) << 8) | (int )*(dat8 + i);
#line 2618
            *((image->comps + 1)->data + index___46) = ((int )*(dat8 + (i + 3L)) << 8) | (int )*(dat8 + (i + 2L));
#line 2619
            *((image->comps + 2)->data + index___46) = ((int )*(dat8 + (i + 5L)) << 8) | (int )*(dat8 + (i + 4L));
#line 2620
            if (has_alpha) {
#line 2621
              *((image->comps + 3)->data + index___46) = ((int )*(dat8 + (i + 7L)) << 8) | (int )*(dat8 + (i + 6L));
            }
#line 2623
            if (parameters->cp_cinema) {
#line 2627
              *((image->comps + 0)->data + index___46) = (*((image->comps + 0)->data + index___46) + 8) >> 4;
#line 2629
              *((image->comps + 1)->data + index___46) = (*((image->comps + 1)->data + index___46) + 8) >> 4;
#line 2631
              *((image->comps + 2)->data + index___46) = (*((image->comps + 2)->data + index___46) + 8) >> 4;
#line 2633
              if (has_alpha) {
#line 2634
                *((image->comps + 3)->data + index___46) = (*((image->comps + 3)->data + index___46) + 8) >> 4;
              }
            }
#line 2637
            index___46 ++;
          } else {
#line 2640
            goto while_break___1;
          }
#line 2613
          i += (long )step;
        }
        while_break___10: /* CIL Label */ ;
        }
        while_break___1: ;
      } else
#line 2644
      if ((int )tiBps == 8) {
#line 2646
        step = 3 + has_alpha;
#line 2648
        i = (tsize_t )0;
        {
#line 2648
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 2648
          if (! (i < ssize)) {
#line 2648
            goto while_break___2;
          }
#line 2650
          if (index___46 < imgsize) {
#line 2653
            *((image->comps + 0)->data + index___46) = (OPJ_INT32 )*(dat8 + i);
#line 2654
            *((image->comps + 1)->data + index___46) = (OPJ_INT32 )*(dat8 + (i + 1L));
#line 2655
            *((image->comps + 2)->data + index___46) = (OPJ_INT32 )*(dat8 + (i + 2L));
#line 2656
            if (has_alpha) {
#line 2657
              *((image->comps + 3)->data + index___46) = (OPJ_INT32 )*(dat8 + (i + 3L));
            }
#line 2660
            if (parameters->cp_cinema) {
#line 2665
              *((image->comps + 0)->data + index___46) <<= 4;
#line 2666
              *((image->comps + 1)->data + index___46) <<= 4;
#line 2667
              *((image->comps + 2)->data + index___46) <<= 4;
#line 2668
              if (has_alpha) {
#line 2669
                *((image->comps + 3)->data + index___46) <<= 4;
              }
            }
#line 2672
            index___46 ++;
          } else {
#line 2675
            goto while_break___2;
          }
#line 2648
          i += (long )step;
        }
        while_break___11: /* CIL Label */ ;
        }
        while_break___2: ;
      } else
#line 2679
      if ((int )tiBps == 12) {
#line 2681
        step = 9;
#line 2683
        i = (tsize_t )0;
        {
#line 2683
        while (1) {
          while_continue___3: /* CIL Label */ ;

#line 2683
          if (! (i < ssize)) {
#line 2683
            goto while_break___3;
          }
#line 2685
          if ((index___46 < imgsize) & (index___46 + 1 < imgsize)) {
#line 2687
            *((image->comps + 0)->data + index___46) = ((int )*(dat8 + i) << 4) | ((int )*(dat8 + (i + 1L)) >> 4);
#line 2688
            *((image->comps + 1)->data + index___46) = (((int )*(dat8 + (i + 1L)) & 15) << 8) | (int )*(dat8 + (i + 2L));
#line 2690
            *((image->comps + 2)->data + index___46) = ((int )*(dat8 + (i + 3L)) << 4) | ((int )*(dat8 + (i + 4L)) >> 4);
#line 2691
            *((image->comps + 0)->data + (index___46 + 1)) = (((int )*(dat8 + (i + 4L)) & 15) << 8) | (int )*(dat8 + (i + 5L));
#line 2693
            *((image->comps + 1)->data + (index___46 + 1)) = ((int )*(dat8 + (i + 6L)) << 4) | ((int )*(dat8 + (i + 7L)) >> 4);
#line 2694
            *((image->comps + 2)->data + (index___46 + 1)) = (((int )*(dat8 + (i + 7L)) & 15) << 8) | (int )*(dat8 + (i + 8L));
#line 2696
            index___46 += 2;
          } else {
#line 2699
            goto while_break___3;
          }
#line 2683
          i += (long )step;
        }
        while_break___12: /* CIL Label */ ;
        }
        while_break___3: ;
      }
#line 2601
      strip ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___0: 
    {
#line 2704
    _TIFFfree(buf);
#line 2705
    TIFFClose(tif);
    }
#line 2707
    return (image);
  }
#line 2710
  if ((int )tiPhoto == 1) {
#line 2712
    numcomps = 1 + has_alpha;
#line 2713
    color_space = (OPJ_COLOR_SPACE )2;
#line 2715
    j = 0;
    {
#line 2715
    while (1) {
      while_continue___4: /* CIL Label */ ;

#line 2715
      if (! (j < numcomps)) {
#line 2715
        goto while_break___4;
      }
#line 2717
      cmptparm[j].prec = (OPJ_UINT32 )tiBps;
#line 2718
      cmptparm[j].bpp = (OPJ_UINT32 )tiBps;
#line 2719
      cmptparm[j].dx = (OPJ_UINT32 )subsampling_dx;
#line 2720
      cmptparm[j].dy = (OPJ_UINT32 )subsampling_dy;
#line 2721
      cmptparm[j].w = (OPJ_UINT32 )w;
#line 2722
      cmptparm[j].h = (OPJ_UINT32 )h;
#line 2715
      j ++;
    }
    while_break___13: /* CIL Label */ ;
    }
    while_break___4: 
    {
#line 2727
    image = opj_image_create((OPJ_UINT32 )numcomps, & cmptparm[0], color_space);
    }
#line 2730
    if (! image) {
      {
#line 2732
      TIFFClose(tif);
      }
#line 2733
      return ((opj_image_t *)((void *)0));
    }
#line 2737
    image->x0 = (OPJ_UINT32 )parameters->image_offset_x0;
#line 2738
    image->y0 = (OPJ_UINT32 )parameters->image_offset_y0;
#line 2739
    if (! image->x0) {
#line 2739
      tmp___1 = (unsigned int )((w - 1) * subsampling_dx + 1);
    } else {
#line 2739
      tmp___1 = (image->x0 + (unsigned int )((w - 1) * subsampling_dx)) + 1U;
    }
#line 2739
    image->x1 = tmp___1;
#line 2741
    if (! image->y0) {
#line 2741
      tmp___2 = (unsigned int )((h - 1) * subsampling_dy + 1);
    } else {
#line 2741
      tmp___2 = (image->y0 + (unsigned int )((h - 1) * subsampling_dy)) + 1U;
    }
    {
#line 2741
    image->y1 = tmp___2;
#line 2744
    __cil_tmp48 = TIFFStripSize(tif);
#line 2744
    __cil_tmp49 = _TIFFmalloc(__cil_tmp48);
#line 2744
    buf = __cil_tmp49;
#line 2746
    strip_size = TIFFStripSize(tif);
#line 2747
    index___46 = 0;
#line 2748
    imgsize = (int )((image->comps + 0)->w * (image->comps + 0)->h);
#line 2751
    strip = (tstrip_t )0;
    }
    {
#line 2751
    while (1) {
      while_continue___5: /* CIL Label */ ;

#line 2751
      if (! (strip < __cil_tmp51)) {
#line 2751
        goto while_break___5;
      }
      {
#line 2757
      ssize___0 = TIFFReadEncodedStrip(tif, strip, buf, strip_size);
#line 2758
      dat8___0 = (unsigned char *)buf;
      }
#line 2760
      if ((int )tiBps == 16) {
#line 2762
        step___0 = (2 + has_alpha) + has_alpha;
#line 2764
        i___0 = (tsize_t )0;
        {
#line 2764
        while (1) {
          while_continue___6: /* CIL Label */ ;

#line 2764
          if (! (i___0 < ssize___0)) {
#line 2764
            goto while_break___6;
          }
#line 2766
          if (index___46 < imgsize) {
#line 2768
            *((image->comps + 0)->data + index___46) = ((int )*(dat8___0 + (i___0 + 1L)) << 8) | (int )*(dat8___0 + i___0);
#line 2769
            if (has_alpha) {
#line 2770
              *((image->comps + 1)->data + index___46) = ((int )*(dat8___0 + (i___0 + 3L)) << 8) | (int )*(dat8___0 + (i___0 + 2L));
            }
#line 2771
            index___46 ++;
          } else {
#line 2774
            goto while_break___6;
          }
#line 2764
          i___0 += (long )step___0;
        }
        while_break___15: /* CIL Label */ ;
        }
        while_break___6: ;
      } else
#line 2778
      if ((int )tiBps == 8) {
#line 2780
        step___0 = 1 + has_alpha;
#line 2782
        i___0 = (tsize_t )0;
        {
#line 2782
        while (1) {
          while_continue___7: /* CIL Label */ ;

#line 2782
          if (! (i___0 < ssize___0)) {
#line 2782
            goto while_break___7;
          }
#line 2784
          if (index___46 < imgsize) {
#line 2786
            *((image->comps + 0)->data + index___46) = (OPJ_INT32 )*(dat8___0 + i___0);
#line 2787
            if (has_alpha) {
#line 2788
              *((image->comps + 1)->data + index___46) = (OPJ_INT32 )*(dat8___0 + (i___0 + 1L));
            }
#line 2789
            index___46 ++;
          } else {
#line 2792
            goto while_break___7;
          }
#line 2782
          i___0 += (long )step___0;
        }
        while_break___16: /* CIL Label */ ;
        }
        while_break___7: ;
      }
#line 2751
      strip ++;
    }
    while_break___14: /* CIL Label */ ;
    }
    while_break___5: 
    {
#line 2797
    _TIFFfree(buf);
#line 2798
    TIFFClose(tif);
    }
  }
#line 2802
  return (image);
}
}
#line 2813 "/root/patron/new_22/src/bin/jp2/convert.c"
static opj_image_t *rawtoimage_common(char const   *filename , opj_cparameters_t *parameters ,
                                      raw_cparameters_t *raw_cp , OPJ_BOOL big_endian ) 
{ 
  int subsampling_dx ;
  int subsampling_dy ;
  FILE *f ;
  int i ;
  int compno ;
  int numcomps ;
  int w ;
  int h ;
  OPJ_COLOR_SPACE color_space ;
  opj_image_cmptparm_t *cmptparm ;
  opj_image_t *image ;
  unsigned short ch ;
  void *__cil_tmp18 ;
  unsigned char value ;
  unsigned long __cil_tmp22 ;
  int tmp ;
  unsigned short value___0 ;
  unsigned char temp1 ;
  unsigned char temp2 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  int tmp___0 ;
  unsigned long __cil_tmp34 ;

  {
#line 2814
  subsampling_dx = parameters->subsampling_dx;
#line 2815
  subsampling_dy = parameters->subsampling_dy;
#line 2817
  f = (FILE *)((void *)0);
#line 2821
  image = (opj_image_t *)((void *)0);
#line 2824
  if (! (((raw_cp->rawWidth & raw_cp->rawHeight) & raw_cp->rawComp) & raw_cp->rawBitDepth) == 0) {
    {
#line 2826
    fprintf(stderr, "\nError: invalid raw image parameters\nU");
#line 2827
    fprintf(stderr, "Please use the Format option -F:\n\024\350\212\202U");
#line 2828
    fprintf(stderr, "-F rawWidth,rawHeight,rawComp,rawBitDepth,s/u (Signed/Unsigned)\n\220");
#line 2829
    fprintf(stderr, "Example: -i lena.raw -o lena.j2k -F 512,512,3,8,u\n\350\212\202U");
#line 2830
    fprintf(stderr, "Aborting\n\335\351\212\202U");
    }
#line 2831
    return ((opj_image_t *)((void *)0));
  }
  {
#line 2834
  f = fopen(filename, "rb");
  }
#line 2835
  if (! f) {
    {
#line 2836
    fprintf(stderr, "Failed to open %s for reading !!\n\372\351\212\202U", filename);
#line 2837
    fprintf(stderr, "Aborting\n\367\351\212\202U");
    }
#line 2838
    return ((opj_image_t *)((void *)0));
  }
  {
#line 2840
  numcomps = raw_cp->rawComp;
#line 2841
  color_space = (OPJ_COLOR_SPACE )1;
#line 2842
  w = raw_cp->rawWidth;
#line 2843
  h = raw_cp->rawHeight;
#line 2844
  __cil_tmp18 = malloc((unsigned long )numcomps * sizeof(opj_image_cmptparm_t ));
#line 2844
  cmptparm = (opj_image_cmptparm_t *)__cil_tmp18;
#line 2847
  memset((void *)(cmptparm + 0), 0, (unsigned long )numcomps * sizeof(opj_image_cmptparm_t ));
#line 2848
  i = 0;
  }
  {
#line 2848
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2848
    if (! (i < numcomps)) {
#line 2848
      goto while_break;
    }
#line 2849
    (cmptparm + i)->prec = (OPJ_UINT32 )raw_cp->rawBitDepth;
#line 2850
    (cmptparm + i)->bpp = (OPJ_UINT32 )raw_cp->rawBitDepth;
#line 2851
    (cmptparm + i)->sgnd = (OPJ_UINT32 )raw_cp->rawSigned;
#line 2852
    (cmptparm + i)->dx = (OPJ_UINT32 )subsampling_dx;
#line 2853
    (cmptparm + i)->dy = (OPJ_UINT32 )subsampling_dy;
#line 2854
    (cmptparm + i)->w = (OPJ_UINT32 )w;
#line 2855
    (cmptparm + i)->h = (OPJ_UINT32 )h;
#line 2848
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: 
  {
#line 2858
  image = opj_image_create((OPJ_UINT32 )numcomps, cmptparm + 0, color_space);
#line 2859
  free((void *)cmptparm);
  }
#line 2860
  if (! image) {
    {
#line 2861
    fclose(f);
    }
#line 2862
    return ((opj_image_t *)((void *)0));
  }
#line 2865
  image->x0 = (OPJ_UINT32 )parameters->image_offset_x0;
#line 2866
  image->y0 = (OPJ_UINT32 )parameters->image_offset_y0;
#line 2867
  image->x1 = (OPJ_UINT32 )((parameters->image_offset_x0 + (w - 1) * subsampling_dx) + 1);
#line 2868
  image->y1 = (OPJ_UINT32 )((parameters->image_offset_y0 + (h - 1) * subsampling_dy) + 1);
#line 2870
  if (raw_cp->rawBitDepth <= 8) {
#line 2872
    value = (unsigned char)0;
#line 2873
    compno = 0;
    {
#line 2873
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 2873
      if (! (compno < numcomps)) {
#line 2873
        goto while_break___0;
      }
#line 2874
      i = 0;
      {
#line 2874
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 2874
        if (! (i < w * h)) {
#line 2874
          goto while_break___1;
        }
        {
#line 2875
        __cil_tmp22 = fread((void *)(& value), 1UL, 1UL, f);
        }
#line 2875
        if (! __cil_tmp22) {
          {
#line 2876
          fprintf(stderr, "Error reading raw file. End of file probably reached.\n");
          }
#line 2877
          return ((opj_image_t *)((void *)0));
        }
#line 2879
        if (raw_cp->rawSigned) {
#line 2879
          tmp = (int )((char )value);
        } else {
#line 2879
          tmp = (int )value;
        }
#line 2879
        *((image->comps + compno)->data + i) = tmp;
#line 2874
        i ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___1: 
#line 2873
      compno ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: ;
  } else
#line 2883
  if (raw_cp->rawBitDepth <= 16) {
#line 2886
    compno = 0;
    {
#line 2886
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 2886
      if (! (compno < numcomps)) {
#line 2886
        goto while_break___2;
      }
#line 2887
      i = 0;
      {
#line 2887
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 2887
        if (! (i < w * h)) {
#line 2887
          goto while_break___3;
        }
        {
#line 2890
        __cil_tmp29 = fread((void *)(& temp1), 1UL, 1UL, f);
        }
#line 2890
        if (! __cil_tmp29) {
          {
#line 2891
          fprintf(stderr, "Error reading raw file. End of file probably reached.\n");
          }
#line 2892
          return ((opj_image_t *)((void *)0));
        }
        {
#line 2894
        __cil_tmp30 = fread((void *)(& temp2), 1UL, 1UL, f);
        }
#line 2894
        if (! __cil_tmp30) {
          {
#line 2895
          fprintf(stderr, "Error reading raw file. End of file probably reached.\n");
          }
#line 2896
          return ((opj_image_t *)((void *)0));
        }
#line 2898
        if (big_endian) {
#line 2900
          value___0 = (unsigned short )((int )temp1 << 8);
#line 2901
          value___0 = (unsigned short )((int )value___0 + (int )temp2);
        } else {
#line 2905
          value___0 = (unsigned short )((int )temp2 << 8);
#line 2906
          value___0 = (unsigned short )((int )value___0 + (int )temp1);
        }
#line 2908
        if (raw_cp->rawSigned) {
#line 2908
          tmp___0 = (int )((short )value___0);
        } else {
#line 2908
          tmp___0 = (int )value___0;
        }
#line 2908
        *((image->comps + compno)->data + i) = tmp___0;
#line 2887
        i ++;
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___3: 
#line 2886
      compno ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: ;
  } else {
    {
#line 2913
    fprintf(stderr, "OpenJPEG cannot encode raw components with bit depth higher than 16 bits.\n\351\212\202U");
    }
#line 2914
    return ((opj_image_t *)((void *)0));
  }
  {
#line 2917
  __cil_tmp34 = fread((void *)(& ch), 1UL, 1UL, f);
  }
#line 2917
  if (__cil_tmp34) {
    {
#line 2918
    fprintf(stderr, "Warning. End of raw file not reached... processing anyway\n");
    }
  }
  {
#line 2920
  fclose(f);
  }
#line 2922
  return (image);
}
}
#line 2925 "/root/patron/new_22/src/bin/jp2/convert.c"
opj_image_t *rawltoimage(char const   *filename , opj_cparameters_t *parameters ,
                         raw_cparameters_t *raw_cp ) 
{ 
  opj_image_t *__cil_tmp4 ;

  {
  {
#line 2926
  __cil_tmp4 = rawtoimage_common(filename, parameters, raw_cp, 0);
  }
#line 2926
  return (__cil_tmp4);
}
}
#line 2929 "/root/patron/new_22/src/bin/jp2/convert.c"
opj_image_t *rawtoimage(char const   *filename , opj_cparameters_t *parameters , raw_cparameters_t *raw_cp ) 
{ 
  opj_image_t *__cil_tmp4 ;

  {
  {
#line 2930
  __cil_tmp4 = rawtoimage_common(filename, parameters, raw_cp, 1);
  }
#line 2930
  return (__cil_tmp4);
}
}
#line 2933 "/root/patron/new_22/src/bin/jp2/convert.c"
static int imagetoraw_common(opj_image_t *image , char const   *outfile , OPJ_BOOL big_endian ) 
{ 
  FILE *rawFile ;
  size_t res ;
  int compno ;
  int w ;
  int h ;
  int line ;
  int row ;
  int *ptr ;
  char const   *tmp ;
  signed char curr ;
  int mask ;
  unsigned char curr___0 ;
  int mask___0 ;
  short curr___1 ;
  int mask___1 ;
  unsigned char temp1 ;
  unsigned char temp2 ;
  unsigned short curr___2 ;
  int mask___2 ;
  unsigned char temp1___0 ;
  unsigned char temp2___0 ;

  {
#line 2935
  rawFile = (FILE *)((void *)0);
#line 2942
  if ((image->numcomps * image->x1) * image->y1 == 0U) {
    {
#line 2944
    fprintf(stderr, "\nError: invalid raw image parameters\nU");
    }
#line 2945
    return (1);
  }
  {
#line 2948
  rawFile = fopen(outfile, "wb\352\212\202U");
  }
#line 2949
  if (! rawFile) {
    {
#line 2950
    fprintf(stderr, "Failed to open %s for writing !!\n", outfile);
    }
#line 2951
    return (1);
  }
  {
#line 2954
  fprintf(stdout, "Raw image characteristics: %d components\n]\352\212\202U", image->numcomps);
#line 2956
  compno = 0;
  }
  {
#line 2956
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2956
    if (! ((unsigned int )compno < image->numcomps)) {
#line 2956
      goto while_break;
    }
#line 2958
    if ((image->comps + compno)->sgnd == 1U) {
      {
#line 2958
      strcpy((char *)tmp, "signed");
      }
    } else {
      {
#line 2958
      strcpy((char *)tmp, "unsigned\220");
      }
    }
    {
#line 2958
    fprintf(stdout, "Component %d characteristics: %dx%dx%d %s\n", compno, (image->comps + compno)->w,
            (image->comps + compno)->h, (image->comps + compno)->prec, tmp);
#line 2961
    w = (int )(image->comps + compno)->w;
#line 2962
    h = (int )(image->comps + compno)->h;
    }
#line 2964
    if ((image->comps + compno)->prec <= 8U) {
#line 2966
      if ((image->comps + compno)->sgnd == 1U) {
#line 2969
        mask = (1 << (image->comps + compno)->prec) - 1;
#line 2970
        ptr = (image->comps + compno)->data;
#line 2971
        line = 0;
        {
#line 2971
        while (1) {
          while_continue___0: /* CIL Label */ ;

#line 2971
          if (! (line < h)) {
#line 2971
            goto while_break___0;
          }
#line 2972
          row = 0;
          {
#line 2972
          while (1) {
            while_continue___1: /* CIL Label */ ;

#line 2972
            if (! (row < w)) {
#line 2972
              goto while_break___1;
            }
            {
#line 2973
            curr = (signed char )(*ptr & mask);
#line 2974
            res = fwrite((void const   *)(& curr), sizeof(signed char ), 1UL, rawFile);
            }
#line 2975
            if (res < 1UL) {
              {
#line 2976
              fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
              }
#line 2977
              return (1);
            }
#line 2979
            ptr ++;
#line 2972
            row ++;
          }
          while_break___10: /* CIL Label */ ;
          }
          while_break___1: 
#line 2971
          line ++;
        }
        while_break___9: /* CIL Label */ ;
        }
        while_break___0: ;
      } else
#line 2983
      if ((image->comps + compno)->sgnd == 0U) {
#line 2986
        mask___0 = (1 << (image->comps + compno)->prec) - 1;
#line 2987
        ptr = (image->comps + compno)->data;
#line 2988
        line = 0;
        {
#line 2988
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 2988
          if (! (line < h)) {
#line 2988
            goto while_break___2;
          }
#line 2989
          row = 0;
          {
#line 2989
          while (1) {
            while_continue___3: /* CIL Label */ ;

#line 2989
            if (! (row < w)) {
#line 2989
              goto while_break___3;
            }
            {
#line 2990
            curr___0 = (unsigned char )(*ptr & mask___0);
#line 2991
            res = fwrite((void const   *)(& curr___0), sizeof(unsigned char ), 1UL,
                         rawFile);
            }
#line 2992
            if (res < 1UL) {
              {
#line 2993
              fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
              }
#line 2994
              return (1);
            }
#line 2996
            ptr ++;
#line 2989
            row ++;
          }
          while_break___12: /* CIL Label */ ;
          }
          while_break___3: 
#line 2988
          line ++;
        }
        while_break___11: /* CIL Label */ ;
        }
        while_break___2: ;
      }
    } else
#line 3001
    if ((image->comps + compno)->prec <= 16U) {
#line 3003
      if ((image->comps + compno)->sgnd == 1U) {
#line 3006
        mask___1 = (1 << (image->comps + compno)->prec) - 1;
#line 3007
        ptr = (image->comps + compno)->data;
#line 3008
        line = 0;
        {
#line 3008
        while (1) {
          while_continue___4: /* CIL Label */ ;

#line 3008
          if (! (line < h)) {
#line 3008
            goto while_break___4;
          }
#line 3009
          row = 0;
          {
#line 3009
          while (1) {
            while_continue___5: /* CIL Label */ ;

#line 3009
            if (! (row < w)) {
#line 3009
              goto while_break___5;
            }
#line 3012
            curr___1 = (short )(*ptr & mask___1);
#line 3013
            if (big_endian) {
#line 3015
              temp1 = (unsigned char )((int )curr___1 >> 8);
#line 3016
              temp2 = (unsigned char )curr___1;
            } else {
#line 3020
              temp2 = (unsigned char )((int )curr___1 >> 8);
#line 3021
              temp1 = (unsigned char )curr___1;
            }
            {
#line 3023
            res = fwrite((void const   *)(& temp1), 1UL, 1UL, rawFile);
            }
#line 3024
            if (res < 1UL) {
              {
#line 3025
              fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
              }
#line 3026
              return (1);
            }
            {
#line 3028
            res = fwrite((void const   *)(& temp2), 1UL, 1UL, rawFile);
            }
#line 3029
            if (res < 1UL) {
              {
#line 3030
              fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
              }
#line 3031
              return (1);
            }
#line 3033
            ptr ++;
#line 3009
            row ++;
          }
          while_break___14: /* CIL Label */ ;
          }
          while_break___5: 
#line 3008
          line ++;
        }
        while_break___13: /* CIL Label */ ;
        }
        while_break___4: ;
      } else
#line 3037
      if ((image->comps + compno)->sgnd == 0U) {
#line 3040
        mask___2 = (1 << (image->comps + compno)->prec) - 1;
#line 3041
        ptr = (image->comps + compno)->data;
#line 3042
        line = 0;
        {
#line 3042
        while (1) {
          while_continue___6: /* CIL Label */ ;

#line 3042
          if (! (line < h)) {
#line 3042
            goto while_break___6;
          }
#line 3043
          row = 0;
          {
#line 3043
          while (1) {
            while_continue___7: /* CIL Label */ ;

#line 3043
            if (! (row < w)) {
#line 3043
              goto while_break___7;
            }
#line 3046
            curr___2 = (unsigned short )(*ptr & mask___2);
#line 3047
            if (big_endian) {
#line 3049
              temp1___0 = (unsigned char )((int )curr___2 >> 8);
#line 3050
              temp2___0 = (unsigned char )curr___2;
            } else {
#line 3054
              temp2___0 = (unsigned char )((int )curr___2 >> 8);
#line 3055
              temp1___0 = (unsigned char )curr___2;
            }
            {
#line 3057
            res = fwrite((void const   *)(& temp1___0), 1UL, 1UL, rawFile);
            }
#line 3058
            if (res < 1UL) {
              {
#line 3059
              fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
              }
#line 3060
              return (1);
            }
            {
#line 3062
            res = fwrite((void const   *)(& temp2___0), 1UL, 1UL, rawFile);
            }
#line 3063
            if (res < 1UL) {
              {
#line 3064
              fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
              }
#line 3065
              return (1);
            }
#line 3067
            ptr ++;
#line 3043
            row ++;
          }
          while_break___16: /* CIL Label */ ;
          }
          while_break___7: 
#line 3042
          line ++;
        }
        while_break___15: /* CIL Label */ ;
        }
        while_break___6: ;
      }
    } else
#line 3072
    if ((image->comps + compno)->prec <= 32U) {
      {
#line 3074
      fprintf(stderr, "More than 16 bits per component no handled yet\n");
      }
#line 3075
      return (1);
    } else {
      {
#line 3079
      fprintf(stderr, "Error: invalid precision: %d\nU", (image->comps + compno)->prec);
      }
#line 3080
      return (1);
    }
#line 2956
    compno ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break: 
  {
#line 3083
  fclose(rawFile);
  }
#line 3084
  return (0);
}
}
#line 3087 "/root/patron/new_22/src/bin/jp2/convert.c"
int imagetoraw(opj_image_t *image , char const   *outfile ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 3089
  __cil_tmp3 = imagetoraw_common(image, outfile, 1);
  }
#line 3089
  return (__cil_tmp3);
}
}
#line 3092 "/root/patron/new_22/src/bin/jp2/convert.c"
int imagetorawl(opj_image_t *image , char const   *outfile ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 3094
  __cil_tmp3 = imagetoraw_common(image, outfile, 0);
  }
#line 3094
  return (__cil_tmp3);
}
}
#line 3103 "/root/patron/new_22/src/bin/jp2/convert.c"
opj_image_t *pngtoimage(char const   *read_idf , opj_cparameters_t *params ) 
{ 
  png_structp png ;
  png_infop info ;
  double gamma___0 ;
  double display_exponent ;
  int bit_depth ;
  int interlace_type ;
  int compression_type ;
  int filter_type ;
  int unit ;
  png_uint_32 resx ;
  png_uint_32 resy ;
  unsigned int i ;
  unsigned int j ;
  png_uint_32 width ;
  png_uint_32 height ;
  int color_type ;
  int has_alpha ;
  int is16 ;
  unsigned char *s ;
  FILE *reader ;
  unsigned char **rows ;
  opj_image_t *image ;
  opj_image_cmptparm_t cmptparm[4] ;
  int sub_dx ;
  int sub_dy ;
  unsigned int nr_comp ;
  int *r ;
  int *g ;
  int *b ;
  int *a ;
  unsigned char sigbuf[8] ;
  unsigned long __cil_tmp35 ;
  int __cil_tmp36 ;
  jmp_buf *__cil_tmp39 ;
  int __cil_tmp40 ;
  png_uint_32 __cil_tmp41 ;
  png_uint_32 __cil_tmp42 ;
  int tmp ;
  png_uint_32 __cil_tmp44 ;
  png_byte __cil_tmp45 ;
  png_byte __cil_tmp46 ;
  void *__cil_tmp47 ;
  size_t __cil_tmp48 ;
  void *__cil_tmp49 ;
  int *__cil_tmp51 ;
  int *__cil_tmp52 ;
  int *__cil_tmp53 ;
  int *__cil_tmp54 ;
  int *__cil_tmp55 ;
  unsigned char *__cil_tmp56 ;
  int *__cil_tmp57 ;
  unsigned char *__cil_tmp58 ;
  int *__cil_tmp59 ;
  unsigned char *__cil_tmp60 ;
  int *__cil_tmp61 ;
  unsigned char *__cil_tmp62 ;

  {
  {
#line 3125
  reader = fopen(read_idf, "rb");
  }
#line 3125
  if ((unsigned long )reader == (unsigned long )((void *)0)) {
    {
#line 3127
    fprintf(stderr, "pngtoimage: can not open %s\n", read_idf);
    }
#line 3128
    return ((opj_image_t *)((void *)0));
  }
  {
#line 3130
  image = (opj_image_t *)((void *)0);
#line 3130
  png = (png_structp )((void *)0);
#line 3130
  rows = (unsigned char **)((void *)0);
#line 3132
  __cil_tmp36 = memcmp((void const   *)(sigbuf), (void const   *)"\211PNG\r\n\032\n\251",
                       8UL);
#line 3132
  __cil_tmp35 = fread((void *)(sigbuf), 1UL, 8UL, reader);
  }
#line 3132
  if (__cil_tmp35 != 8UL) {
    {
#line 3135
    fprintf(stderr, "pngtoimage: %s is no valid PNG file\n\002", read_idf);
    }
#line 3136
    goto fin;
  } else
#line 3132
  if (__cil_tmp36 != 0) {
    {
#line 3135
    fprintf(stderr, "pngtoimage: %s is no valid PNG file\n\002", read_idf);
    }
#line 3136
    goto fin;
  }
  {
#line 3142
  display_exponent = 2.20000000001;
#line 3144
  png = png_create_read_struct("1.6.37", (void *)0, (void (*)(png_structp  , png_const_charp  ))((void *)0),
                               (void (*)(png_structp  , png_const_charp  ))((void *)0));
  }
#line 3144
  if ((unsigned long )png == (unsigned long )((void *)0)) {
#line 3146
    goto fin;
  }
  {
#line 3147
  info = png_create_info_struct(png);
  }
#line 3147
  if ((unsigned long )info == (unsigned long )((void *)0)) {
#line 3148
    goto fin;
  }
  {
#line 3150
  __cil_tmp39 = png_set_longjmp_fn(png, & longjmp, sizeof(jmp_buf ));
#line 3150
  __cil_tmp40 = _setjmp((struct __jmp_buf_tag *)(*__cil_tmp39));
  }
#line 3150
  if (__cil_tmp40) {
#line 3151
    goto fin;
  }
  {
#line 3153
  png_init_io(png, reader);
#line 3154
  png_set_sig_bytes(png, 8);
#line 3156
  png_read_info(png, info);
#line 3158
  __cil_tmp41 = png_get_IHDR(png, info, & width, & height, & bit_depth, & color_type,
                             & interlace_type, & compression_type, & filter_type);
  }
#line 3158
  if (__cil_tmp41 == 0U) {
#line 3161
    goto fin;
  }
#line 3168
  if (color_type == 3) {
    {
#line 3169
    png_set_expand(png);
    }
  } else
#line 3171
  if (color_type == 0) {
#line 3171
    if (bit_depth < 8) {
      {
#line 3172
      png_set_expand(png);
      }
    }
  }
  {
#line 3174
  __cil_tmp42 = png_get_valid(png, info, 16U);
  }
#line 3174
  if (__cil_tmp42) {
    {
#line 3175
    png_set_expand(png);
    }
  }
#line 3177
  is16 = bit_depth == 16;
#line 3181
  if (color_type == 0) {
    _L: 
    {
#line 3184
    png_set_gray_to_rgb(png);
    }
#line 3185
    if (color_type == 0) {
#line 3185
      tmp = 2;
    } else {
#line 3185
      tmp = 6;
    }
#line 3185
    color_type = tmp;
  } else
#line 3181
  if (color_type == 4) {
#line 3181
    goto _L;
  }
  {
#line 3189
  __cil_tmp44 = png_get_gAMA(png, info, & gamma___0);
  }
#line 3189
  if (! __cil_tmp44) {
#line 3190
    gamma___0 = 0.454550000001;
  }
  {
#line 3192
  png_set_gamma(png, display_exponent, gamma___0);
#line 3194
  png_read_update_info(png, info);
#line 3196
  png_get_pHYs(png, info, & resx, & resy, & unit);
#line 3198
  __cil_tmp45 = png_get_color_type(png, info);
#line 3198
  color_type = (int )__cil_tmp45;
#line 3200
  has_alpha = color_type == 6;
#line 3202
  nr_comp = (unsigned int )(3 + has_alpha);
#line 3204
  __cil_tmp46 = png_get_bit_depth(png, info);
#line 3204
  bit_depth = (int )__cil_tmp46;
#line 3206
  __cil_tmp47 = calloc((unsigned long )(height + 1U), sizeof(unsigned char *));
#line 3206
  rows = (unsigned char **)__cil_tmp47;
#line 3207
  i = 0U;
  }
  {
#line 3207
  while (1) {
    while_continue: /* CIL Label */ ;

#line 3207
    if (! (i < height)) {
#line 3207
      goto while_break;
    }
    {
#line 3208
    __cil_tmp48 = png_get_rowbytes(png, info);
#line 3208
    __cil_tmp49 = malloc(__cil_tmp48);
#line 3208
    *(rows + i) = (unsigned char *)__cil_tmp49;
#line 3207
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: 
  {
#line 3210
  png_read_image(png, rows);
#line 3212
  memset((void *)(& cmptparm), 0, 4UL * sizeof(opj_image_cmptparm_t ));
#line 3214
  sub_dx = params->subsampling_dx;
#line 3214
  sub_dy = params->subsampling_dy;
#line 3216
  i = 0U;
  }
  {
#line 3216
  while (1) {
    while_continue___3: /* CIL Label */ ;

#line 3216
    if (! (i < nr_comp)) {
#line 3216
      goto while_break___0;
    }
#line 3218
    cmptparm[i].prec = (OPJ_UINT32 )bit_depth;
#line 3220
    cmptparm[i].bpp = (OPJ_UINT32 )bit_depth;
#line 3221
    cmptparm[i].sgnd = (OPJ_UINT32 )0;
#line 3222
    cmptparm[i].dx = (OPJ_UINT32 )sub_dx;
#line 3223
    cmptparm[i].dy = (OPJ_UINT32 )sub_dy;
#line 3224
    cmptparm[i].w = width;
#line 3225
    cmptparm[i].h = height;
#line 3216
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___0: 
  {
#line 3228
  image = opj_image_create(nr_comp, & cmptparm[0], (OPJ_COLOR_SPACE )1);
  }
#line 3230
  if ((unsigned long )image == (unsigned long )((void *)0)) {
#line 3230
    goto fin;
  }
#line 3232
  image->x0 = (OPJ_UINT32 )params->image_offset_x0;
#line 3233
  image->y0 = (OPJ_UINT32 )params->image_offset_y0;
#line 3234
  image->x1 = ((image->x0 + (width - 1U) * (unsigned int )sub_dx) + 1U) + image->x0;
#line 3235
  image->y1 = ((image->y0 + (height - 1U) * (unsigned int )sub_dy) + 1U) + image->y0;
#line 3237
  r = (image->comps + 0)->data;
#line 3238
  g = (image->comps + 1)->data;
#line 3239
  b = (image->comps + 2)->data;
#line 3240
  a = (image->comps + 3)->data;
#line 3242
  i = 0U;
  {
#line 3242
  while (1) {
    while_continue___4: /* CIL Label */ ;

#line 3242
    if (! (i < height)) {
#line 3242
      goto while_break___1;
    }
#line 3244
    s = *(rows + i);
#line 3246
    j = 0U;
    {
#line 3246
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___2: ;
#line 3246
      if (! (j < width)) {
#line 3246
        goto while_break___2;
      }
#line 3248
      if (is16) {
#line 3250
        __cil_tmp51 = r;
#line 3250
        r ++;
#line 3250
        *__cil_tmp51 = ((int )*(s + 0) << 8) | (int )*(s + 1);
#line 3250
        s += 2;
#line 3252
        __cil_tmp52 = g;
#line 3252
        g ++;
#line 3252
        *__cil_tmp52 = ((int )*(s + 0) << 8) | (int )*(s + 1);
#line 3252
        s += 2;
#line 3254
        __cil_tmp53 = b;
#line 3254
        b ++;
#line 3254
        *__cil_tmp53 = ((int )*(s + 0) << 8) | (int )*(s + 1);
#line 3254
        s += 2;
#line 3256
        if (has_alpha) {
#line 3256
          __cil_tmp54 = a;
#line 3256
          a ++;
#line 3256
          *__cil_tmp54 = ((int )*(s + 0) << 8) | (int )*(s + 1);
#line 3256
          s += 2;
        }
#line 3258
        goto while_continue___2;
      }
#line 3260
      __cil_tmp56 = s;
#line 3260
      s ++;
#line 3260
      __cil_tmp55 = r;
#line 3260
      r ++;
#line 3260
      *__cil_tmp55 = (int )*__cil_tmp56;
#line 3260
      __cil_tmp58 = s;
#line 3260
      s ++;
#line 3260
      __cil_tmp57 = g;
#line 3260
      g ++;
#line 3260
      *__cil_tmp57 = (int )*__cil_tmp58;
#line 3260
      __cil_tmp60 = s;
#line 3260
      s ++;
#line 3260
      __cil_tmp59 = b;
#line 3260
      b ++;
#line 3260
      *__cil_tmp59 = (int )*__cil_tmp60;
#line 3262
      if (has_alpha) {
#line 3262
        __cil_tmp62 = s;
#line 3262
        s ++;
#line 3262
        __cil_tmp61 = a;
#line 3262
        a ++;
#line 3262
        *__cil_tmp61 = (int )*__cil_tmp62;
      }
#line 3246
      j ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: 
#line 3242
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___1: ;
  fin: 
#line 3266
  if (rows) {
#line 3268
    i = 0U;
    {
#line 3268
    while (1) {
      while_continue___6: /* CIL Label */ ;

#line 3268
      if (! (i < height)) {
#line 3268
        goto while_break___3;
      }
      {
#line 3269
      free((void *)*(rows + i));
#line 3268
      i ++;
      }
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___3: 
    {
#line 3270
    free((void *)rows);
    }
  }
#line 3272
  if (png) {
    {
#line 3273
    png_destroy_read_struct(& png, & info, (png_infopp )((void *)0));
    }
  }
  {
#line 3275
  fclose(reader);
  }
#line 3277
  return (image);
}
}
#line 3281 "/root/patron/new_22/src/bin/jp2/convert.c"
int imagetopng(opj_image_t *image , char const   *write_idf ) 
{ 
  FILE *writer ;
  png_structp png ;
  png_infop info ;
  int *red ;
  int *green ;
  int *blue ;
  int *alpha ;
  unsigned char *row_buf ;
  unsigned char *d ;
  int has_alpha ;
  int width ;
  int height ;
  int nr_comp ;
  int color_type ;
  int adjustR ;
  int adjustG ;
  int adjustB ;
  int adjustA ;
  int x ;
  int y ;
  int fails ;
  int prec ;
  int ushift ;
  int dshift ;
  int is16 ;
  int force16 ;
  int force8 ;
  unsigned short mask ;
  png_color_8 sig_bit ;
  jmp_buf *__cil_tmp35 ;
  int __cil_tmp36 ;
  int v ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *__cil_tmp42 ;
  unsigned char *__cil_tmp43 ;
  unsigned char *__cil_tmp44 ;
  unsigned char *__cil_tmp45 ;
  unsigned char *__cil_tmp46 ;
  unsigned char *__cil_tmp47 ;
  unsigned char *__cil_tmp48 ;
  unsigned char *__cil_tmp49 ;
  unsigned char *__cil_tmp50 ;
  unsigned char *__cil_tmp51 ;
  unsigned char *__cil_tmp52 ;
  unsigned char *__cil_tmp53 ;
  unsigned char *__cil_tmp54 ;
  int v___0 ;
  int tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp58 ;
  unsigned char *__cil_tmp59 ;
  unsigned char *__cil_tmp60 ;
  int *__cil_tmp61 ;
  unsigned char *__cil_tmp62 ;
  unsigned char *__cil_tmp63 ;
  void *__cil_tmp64 ;
  unsigned char *__cil_tmp65 ;
  unsigned char *__cil_tmp66 ;

  {
#line 3291
  mask = (unsigned short)65535;
#line 3294
  dshift = 0;
#line 3294
  ushift = dshift;
#line 3294
  force8 = ushift;
#line 3294
  force16 = force8;
#line 3294
  is16 = force16;
#line 3294
  fails = 1;
#line 3295
  prec = (int )(image->comps + 0)->prec;
#line 3296
  nr_comp = (int )image->numcomps;
#line 3298
  if (prec > 8) {
#line 3298
    if (prec < 16) {
#line 3300
      ushift = 16 - prec;
#line 3300
      dshift = prec - ushift;
#line 3301
      prec = 16;
#line 3301
      force16 = 1;
    } else {
#line 3298
      goto _L;
    }
  } else
  _L: 
#line 3304
  if (prec < 8) {
#line 3304
    if (nr_comp > 1) {
#line 3306
      ushift = 8 - prec;
#line 3306
      dshift = 8 - ushift;
#line 3307
      prec = 8;
#line 3307
      force8 = 1;
    }
  }
#line 3310
  if (prec != 1) {
#line 3310
    if (prec != 2) {
#line 3310
      if (prec != 4) {
#line 3310
        if (prec != 8) {
#line 3310
          if (prec != 16) {
            {
#line 3312
            fprintf(stderr, "imagetopng: can not create %s\n\twrong bit_depth %d\n",
                    write_idf, prec);
            }
#line 3314
            return (fails);
          }
        }
      }
    }
  }
  {
#line 3316
  writer = fopen(write_idf, "wb");
  }
#line 3318
  if ((unsigned long )writer == (unsigned long )((void *)0)) {
#line 3318
    return (fails);
  }
  {
#line 3320
  info = (png_infop )((void *)0);
#line 3320
  has_alpha = 0;
#line 3328
  png = png_create_write_struct("1.6.37", (void *)0, (void (*)(png_structp  , png_const_charp  ))((void *)0),
                                (void (*)(png_structp  , png_const_charp  ))((void *)0));
  }
#line 3332
  if ((unsigned long )png == (unsigned long )((void *)0)) {
#line 3332
    goto fin;
  }
  {
#line 3336
  info = png_create_info_struct(png);
  }
#line 3338
  if ((unsigned long )info == (unsigned long )((void *)0)) {
#line 3338
    goto fin;
  }
  {
#line 3343
  __cil_tmp35 = png_set_longjmp_fn(png, & longjmp, sizeof(jmp_buf ));
#line 3343
  __cil_tmp36 = _setjmp((struct __jmp_buf_tag *)(*__cil_tmp35));
  }
#line 3343
  if (__cil_tmp36) {
#line 3343
    goto fin;
  }
  {
#line 3347
  png_init_io(png, writer);
#line 3366
  png_set_compression_level(png, 9);
  }
#line 3368
  if (prec == 16) {
#line 3368
    mask = (unsigned short)65535;
  } else
#line 3370
  if (prec == 8) {
#line 3370
    mask = (unsigned short)255;
  } else
#line 3372
  if (prec == 4) {
#line 3372
    mask = (unsigned short)15;
  } else
#line 3374
  if (prec == 2) {
#line 3374
    mask = (unsigned short)3;
  } else
#line 3376
  if (prec == 1) {
#line 3376
    mask = (unsigned short)1;
  }
#line 3378
  if (nr_comp >= 3) {
#line 3378
    if ((image->comps + 0)->dx == (image->comps + 1)->dx) {
#line 3378
      if ((image->comps + 1)->dx == (image->comps + 2)->dx) {
#line 3378
        if ((image->comps + 0)->dy == (image->comps + 1)->dy) {
#line 3378
          if ((image->comps + 1)->dy == (image->comps + 2)->dy) {
#line 3378
            if ((image->comps + 0)->prec == (image->comps + 1)->prec) {
#line 3378
              if ((image->comps + 1)->prec == (image->comps + 2)->prec) {
#line 3388
                has_alpha = nr_comp > 3;
#line 3390
                is16 = prec == 16;
#line 3392
                width = (int )(image->comps + 0)->w;
#line 3393
                height = (int )(image->comps + 0)->h;
#line 3395
                red = (image->comps + 0)->data;
#line 3396
                green = (image->comps + 1)->data;
#line 3397
                blue = (image->comps + 2)->data;
#line 3399
                sig_bit.blue = (png_byte )prec;
#line 3399
                sig_bit.green = sig_bit.blue;
#line 3399
                sig_bit.red = sig_bit.green;
#line 3401
                if (has_alpha) {
#line 3403
                  sig_bit.alpha = (png_byte )prec;
#line 3404
                  alpha = (image->comps + 3)->data;
#line 3405
                  color_type = 6;
#line 3406
                  if ((image->comps + 3)->sgnd) {
#line 3406
                    tmp = 1 << ((image->comps + 3)->prec - 1U);
                  } else {
#line 3406
                    tmp = 0;
                  }
#line 3406
                  adjustA = tmp;
                } else {
#line 3410
                  sig_bit.alpha = (png_byte )0;
#line 3410
                  alpha = (int *)((void *)0);
#line 3411
                  color_type = 2;
#line 3412
                  adjustA = 0;
                }
                {
#line 3414
                png_set_sBIT(png, info, & sig_bit);
#line 3416
                png_set_IHDR(png, info, (png_uint_32 )width, (png_uint_32 )height,
                             prec, color_type, 0, 0, 0);
#line 3421
                png_set_gamma(png, 2.20000000001, 1. / 2.20000000001);
#line 3422
                png_set_sRGB(png, info, 0);
#line 3424
                png_write_info(png, info);
                }
#line 3426
                if (prec < 8) {
                  {
#line 3428
                  png_set_packing(png);
                  }
                }
#line 3430
                if ((image->comps + 0)->sgnd) {
#line 3430
                  tmp___0 = 1 << ((image->comps + 0)->prec - 1U);
                } else {
#line 3430
                  tmp___0 = 0;
                }
#line 3430
                adjustR = tmp___0;
#line 3431
                if ((image->comps + 1)->sgnd) {
#line 3431
                  tmp___1 = 1 << ((image->comps + 1)->prec - 1U);
                } else {
#line 3431
                  tmp___1 = 0;
                }
#line 3431
                adjustG = tmp___1;
#line 3432
                if ((image->comps + 2)->sgnd) {
#line 3432
                  tmp___2 = 1 << ((image->comps + 2)->prec - 1U);
                } else {
#line 3432
                  tmp___2 = 0;
                }
                {
#line 3432
                adjustB = tmp___2;
#line 3434
                __cil_tmp42 = malloc((unsigned long )((width * nr_comp) * 2));
#line 3434
                row_buf = (unsigned char *)__cil_tmp42;
#line 3436
                y = 0;
                }
                {
#line 3436
                while (1) {
                  while_continue: /* CIL Label */ ;

#line 3436
                  if (! (y < height)) {
#line 3436
                    goto while_break;
                  }
#line 3438
                  d = row_buf;
#line 3440
                  x = 0;
                  {
#line 3440
                  while (1) {
                    while_continue___1: /* CIL Label */ ;
                    while_continue___0: ;
#line 3440
                    if (! (x < width)) {
#line 3440
                      goto while_break___0;
                    }
#line 3442
                    if (is16) {
#line 3444
                      v = *red + adjustR;
#line 3444
                      red ++;
#line 3446
                      if (force16) {
#line 3446
                        v = (v << ushift) + (v >> dshift);
                      }
#line 3448
                      __cil_tmp43 = d;
#line 3448
                      d ++;
#line 3448
                      *__cil_tmp43 = (unsigned char )(v >> 8);
#line 3448
                      __cil_tmp44 = d;
#line 3448
                      d ++;
#line 3448
                      *__cil_tmp44 = (unsigned char )v;
#line 3450
                      v = *green + adjustG;
#line 3450
                      green ++;
#line 3452
                      if (force16) {
#line 3452
                        v = (v << ushift) + (v >> dshift);
                      }
#line 3454
                      __cil_tmp45 = d;
#line 3454
                      d ++;
#line 3454
                      *__cil_tmp45 = (unsigned char )(v >> 8);
#line 3454
                      __cil_tmp46 = d;
#line 3454
                      d ++;
#line 3454
                      *__cil_tmp46 = (unsigned char )v;
#line 3456
                      v = *blue + adjustB;
#line 3456
                      blue ++;
#line 3458
                      if (force16) {
#line 3458
                        v = (v << ushift) + (v >> dshift);
                      }
#line 3460
                      __cil_tmp47 = d;
#line 3460
                      d ++;
#line 3460
                      *__cil_tmp47 = (unsigned char )(v >> 8);
#line 3460
                      __cil_tmp48 = d;
#line 3460
                      d ++;
#line 3460
                      *__cil_tmp48 = (unsigned char )v;
#line 3462
                      if (has_alpha) {
#line 3464
                        v = *alpha + adjustA;
#line 3464
                        alpha ++;
#line 3466
                        if (force16) {
#line 3466
                          v = (v << ushift) + (v >> dshift);
                        }
#line 3468
                        __cil_tmp49 = d;
#line 3468
                        d ++;
#line 3468
                        *__cil_tmp49 = (unsigned char )(v >> 8);
#line 3468
                        __cil_tmp50 = d;
#line 3468
                        d ++;
#line 3468
                        *__cil_tmp50 = (unsigned char )v;
                      }
#line 3470
                      goto while_continue___0;
                    }
#line 3473
                    v = *red + adjustR;
#line 3473
                    red ++;
#line 3475
                    if (force8) {
#line 3475
                      v = (v << ushift) + (v >> dshift);
                    }
#line 3477
                    __cil_tmp51 = d;
#line 3477
                    d ++;
#line 3477
                    *__cil_tmp51 = (unsigned char )(v & (int )mask);
#line 3479
                    v = *green + adjustG;
#line 3479
                    green ++;
#line 3481
                    if (force8) {
#line 3481
                      v = (v << ushift) + (v >> dshift);
                    }
#line 3483
                    __cil_tmp52 = d;
#line 3483
                    d ++;
#line 3483
                    *__cil_tmp52 = (unsigned char )(v & (int )mask);
#line 3485
                    v = *blue + adjustB;
#line 3485
                    blue ++;
#line 3487
                    if (force8) {
#line 3487
                      v = (v << ushift) + (v >> dshift);
                    }
#line 3489
                    __cil_tmp53 = d;
#line 3489
                    d ++;
#line 3489
                    *__cil_tmp53 = (unsigned char )(v & (int )mask);
#line 3491
                    if (has_alpha) {
#line 3493
                      v = *alpha + adjustA;
#line 3493
                      alpha ++;
#line 3495
                      if (force8) {
#line 3495
                        v = (v << ushift) + (v >> dshift);
                      }
#line 3497
                      __cil_tmp54 = d;
#line 3497
                      d ++;
#line 3497
                      *__cil_tmp54 = (unsigned char )(v & (int )mask);
                    }
#line 3440
                    x ++;
                  }
                  while_break___6: /* CIL Label */ ;
                  }
                  while_break___0: 
                  {
#line 3501
                  png_write_row(png, row_buf);
#line 3436
                  y ++;
                  }
                }
                while_break___5: /* CIL Label */ ;
                }
                while_break: 
                {
#line 3504
                free((void *)row_buf);
                }
              } else {
#line 3378
                goto _L___48;
              }
            } else {
#line 3378
              goto _L___48;
            }
          } else {
#line 3378
            goto _L___48;
          }
        } else {
#line 3378
          goto _L___48;
        }
      } else {
#line 3378
        goto _L___48;
      }
    } else {
#line 3378
      goto _L___48;
    }
  } else
  _L___48: 
#line 3508
  if (nr_comp == 1) {
    _L___47: 
#line 3516
    red = (image->comps + 0)->data;
#line 3518
    sig_bit.gray = (png_byte )prec;
#line 3519
    sig_bit.alpha = (png_byte )0;
#line 3519
    sig_bit.blue = sig_bit.alpha;
#line 3519
    sig_bit.green = sig_bit.blue;
#line 3519
    sig_bit.red = sig_bit.green;
#line 3520
    alpha = (int *)((void *)0);
#line 3520
    adjustA = 0;
#line 3521
    color_type = 0;
#line 3523
    if (nr_comp == 2) {
#line 3525
      has_alpha = 1;
#line 3525
      sig_bit.alpha = (png_byte )prec;
#line 3526
      alpha = (image->comps + 1)->data;
#line 3527
      color_type = 4;
#line 3528
      if ((image->comps + 1)->sgnd) {
#line 3528
        tmp___3 = 1 << ((image->comps + 1)->prec - 1U);
      } else {
#line 3528
        tmp___3 = 0;
      }
#line 3528
      adjustA = tmp___3;
    }
    {
#line 3530
    width = (int )(image->comps + 0)->w;
#line 3531
    height = (int )(image->comps + 0)->h;
#line 3533
    png_set_IHDR(png, info, (png_uint_32 )width, (png_uint_32 )height, (int )sig_bit.gray,
                 color_type, 0, 0, 0);
#line 3538
    png_set_sBIT(png, info, & sig_bit);
#line 3540
    png_set_gamma(png, 2.20000000001, 1. / 2.20000000001);
#line 3541
    png_set_sRGB(png, info, 0);
#line 3543
    png_write_info(png, info);
    }
#line 3545
    if ((image->comps + 0)->sgnd) {
#line 3545
      tmp___4 = 1 << ((image->comps + 0)->prec - 1U);
    } else {
#line 3545
      tmp___4 = 0;
    }
#line 3545
    adjustR = tmp___4;
#line 3547
    if (prec < 8) {
      {
#line 3549
      png_set_packing(png);
      }
    }
#line 3552
    if (prec > 8) {
      {
#line 3554
      __cil_tmp58 = malloc((unsigned long )(width * nr_comp) * sizeof(unsigned short ));
#line 3554
      row_buf = (unsigned char *)__cil_tmp58;
#line 3557
      y = 0;
      }
      {
#line 3557
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 3557
        if (! (y < height)) {
#line 3557
          goto while_break___1;
        }
#line 3559
        d = row_buf;
#line 3561
        x = 0;
        {
#line 3561
        while (1) {
          while_continue___3: /* CIL Label */ ;

#line 3561
          if (! (x < width)) {
#line 3561
            goto while_break___2;
          }
#line 3563
          v___0 = *red + adjustR;
#line 3563
          red ++;
#line 3565
          if (force16) {
#line 3565
            v___0 = (v___0 << ushift) + (v___0 >> dshift);
          }
#line 3567
          __cil_tmp59 = d;
#line 3567
          d ++;
#line 3567
          *__cil_tmp59 = (unsigned char )(v___0 >> 8);
#line 3567
          __cil_tmp60 = d;
#line 3567
          d ++;
#line 3567
          *__cil_tmp60 = (unsigned char )v___0;
#line 3569
          if (has_alpha) {
#line 3571
            __cil_tmp61 = alpha;
#line 3571
            alpha ++;
#line 3571
            v___0 = *__cil_tmp61;
#line 3573
            if (force16) {
#line 3573
              v___0 = (v___0 << ushift) + (v___0 >> dshift);
            }
#line 3575
            __cil_tmp62 = d;
#line 3575
            d ++;
#line 3575
            *__cil_tmp62 = (unsigned char )(v___0 >> 8);
#line 3575
            __cil_tmp63 = d;
#line 3575
            d ++;
#line 3575
            *__cil_tmp63 = (unsigned char )v___0;
          }
#line 3561
          x ++;
        }
        while_break___8: /* CIL Label */ ;
        }
        while_break___2: 
        {
#line 3578
        png_write_row(png, row_buf);
#line 3557
        y ++;
        }
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___1: 
      {
#line 3581
      free((void *)row_buf);
      }
    } else {
      {
#line 3585
      __cil_tmp64 = calloc((unsigned long )width, (unsigned long )(nr_comp * 2));
#line 3585
      row_buf = (unsigned char *)__cil_tmp64;
#line 3587
      y = 0;
      }
      {
#line 3587
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 3587
        if (! (y < height)) {
#line 3587
          goto while_break___3;
        }
#line 3589
        d = row_buf;
#line 3591
        x = 0;
        {
#line 3591
        while (1) {
          while_continue___5: /* CIL Label */ ;

#line 3591
          if (! (x < width)) {
#line 3591
            goto while_break___4;
          }
#line 3593
          v___0 = *red + adjustR;
#line 3593
          red ++;
#line 3595
          if (force8) {
#line 3595
            v___0 = (v___0 << ushift) + (v___0 >> dshift);
          }
#line 3597
          __cil_tmp65 = d;
#line 3597
          d ++;
#line 3597
          *__cil_tmp65 = (unsigned char )(v___0 & (int )mask);
#line 3599
          if (has_alpha) {
#line 3601
            v___0 = *alpha + adjustA;
#line 3601
            alpha ++;
#line 3603
            if (force8) {
#line 3603
              v___0 = (v___0 << ushift) + (v___0 >> dshift);
            }
#line 3605
            __cil_tmp66 = d;
#line 3605
            d ++;
#line 3605
            *__cil_tmp66 = (unsigned char )(v___0 & (int )mask);
          }
#line 3591
          x ++;
        }
        while_break___10: /* CIL Label */ ;
        }
        while_break___4: 
        {
#line 3609
        png_write_row(png, row_buf);
#line 3587
        y ++;
        }
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___3: 
      {
#line 3612
      free((void *)row_buf);
      }
    }
  } else
#line 3508
  if (nr_comp == 2) {
#line 3508
    if ((image->comps + 0)->dx == (image->comps + 1)->dx) {
#line 3508
      if ((image->comps + 0)->dy == (image->comps + 1)->dy) {
#line 3508
        if ((image->comps + 0)->prec == (image->comps + 1)->prec) {
#line 3508
          goto _L___47;
        } else {
          {
#line 3617
          fprintf(stderr, "imagetopng: can not create %s\n", write_idf);
          }
#line 3618
          goto fin;
        }
      } else {
        {
#line 3617
        fprintf(stderr, "imagetopng: can not create %s\n", write_idf);
        }
#line 3618
        goto fin;
      }
    } else {
      {
#line 3617
      fprintf(stderr, "imagetopng: can not create %s\n", write_idf);
      }
#line 3618
      goto fin;
    }
  } else {
    {
#line 3617
    fprintf(stderr, "imagetopng: can not create %s\n", write_idf);
    }
#line 3618
    goto fin;
  }
  {
#line 3620
  png_write_end(png, info);
#line 3622
  fails = 0;
  }
  fin: 
#line 3626
  if (png) {
    {
#line 3628
    png_destroy_write_struct(& png, & info);
    }
  }
  {
#line 3630
  fclose(writer);
  }
#line 3632
  if (fails) {
    {
#line 3632
    remove(write_idf);
    }
  }
#line 3634
  return (fails);
}
}
#line 134 "/usr/include/dirent.h"
extern DIR *opendir(char const   *__name ) ;
#line 162
extern struct dirent *readdir(DIR *__dirp ) ;
#line 18 "/root/patron/new_22/src/bin/common/opj_getopt.h"
int opj_opterr ;
#line 19
int opj_optind ;
#line 20 "/root/patron/new_22/src/bin/common/opj_getopt.h"
int opj_optopt  ;
#line 21 "/root/patron/new_22/src/bin/common/opj_getopt.h"
int opj_optreset  ;
#line 22 "/root/patron/new_22/src/bin/common/opj_getopt.h"
char *opj_optarg  ;
#line 24
int opj_getopt(int nargc , char * const  *nargv , char const   *ostr ) ;
#line 25
int opj_getopt_long(int argc , char * const  *argv , char const   *optstring , opj_option_t *longopts ,
                    int totlen ) ;
#line 27
void reset_options_reading(void) ;
#line 35 "/root/patron/new_22/src/bin/common/color.h"
void color_sycc_to_rgb(opj_image_t *img ) ;
#line 92 "/root/patron/new_22/src/bin/jp2/opj_decompress.c"
int get_num_images(char *imgdirpath ) ;
#line 93
int load_images(dircnt_t *dirptr , char *imgdirpath ) ;
#line 94
int get_file_format(char const   *filename ) ;
#line 95
char get_next_file(int imageno , dircnt_t *dirptr , img_fol_t *img_fol , opj_dparameters_t *parameters ) ;
#line 96
static int infile_format(char const   *fname ) ;
#line 98
int parse_cmdline_decoder(int argc , char **argv , opj_dparameters_t *parameters ,
                          img_fol_t *img_fol , char *indexfilename ) ;
#line 99
int parse_DA_values(char *inArg , unsigned int *DA_x0 , unsigned int *DA_y0 , unsigned int *DA_x1 ,
                    unsigned int *DA_y1 ) ;
#line 102 "/root/patron/new_22/src/bin/jp2/opj_decompress.c"
static void decode_help_display(void) 
{ 


  {
  {
#line 103
  fprintf(stdout, "HELP for opj_decompress\n----\n\n");
#line 104
  fprintf(stdout, "- the -h option displays this help information on screen\n\n");
#line 107
  fprintf(stdout, "List of parameters for the JPEG 2000 decoder:\n");
#line 113
  fprintf(stdout, "\n");
#line 114
  fprintf(stdout, "\n");
#line 115
  fprintf(stdout, "  -ImgDir \n");
#line 116
  fprintf(stdout, "\tImage file Directory path \n");
#line 117
  fprintf(stdout, "  -OutFor \n");
#line 118
  fprintf(stdout, "    REQUIRED only if -ImgDir is used\n");
#line 119
  fprintf(stdout, "\t  Need to specify only format without filename <BMP>  \n\220");
#line 120
  fprintf(stdout, "    Currently accepts PGM, PPM, PNM, PGX, PNG, BMP, TIF, RAW and TGA formats\n");
#line 121
  fprintf(stdout, "  -i <compressed file>\n");
#line 122
  fprintf(stdout, "    REQUIRED only if an Input image directory not specified\n");
#line 123
  fprintf(stdout, "    Currently accepts J2K-files, JP2-files and JPT-files. The file type\n\220");
#line 124
  fprintf(stdout, "    is identified based on its suffix.\n");
#line 125
  fprintf(stdout, "  -o <decompressed file>\n");
#line 126
  fprintf(stdout, "    REQUIRED\n");
#line 127
  fprintf(stdout, "    Currently accepts PGM, PPM, PNM, PGX, PNG, BMP, TIF, RAW and TGA files\n");
#line 128
  fprintf(stdout, "    Binary data is written to the file (not ascii). If a PGX\n");
#line 129
  fprintf(stdout, "    filename is given, there will be as many output files as there are\n");
#line 130
  fprintf(stdout, "    components: an indice starting from 0 will then be appended to the\n");
#line 131
  fprintf(stdout, "    output filename, just before the \"pgx\" extension. If a PGM filename\n\220");
#line 132
  fprintf(stdout, "    is given and there are more than one component, only the first component\n");
#line 133
  fprintf(stdout, "    will be written to the file.\n");
#line 134
  fprintf(stdout, "  -r <reduce factor>\n");
#line 135
  fprintf(stdout, "    Set the number of highest resolution levels to be discarded. The\n");
#line 136
  fprintf(stdout, "    image resolution is effectively divided by 2 to the power of the\n");
#line 137
  fprintf(stdout, "    number of discarded levels. The reduce factor is limited by the\n");
#line 138
  fprintf(stdout, "    smallest total number of decomposition levels among tiles.\n");
#line 139
  fprintf(stdout, "  -l <number of quality layers to decode>\n");
#line 140
  fprintf(stdout, "    Set the maximum number of quality layers to decode. If there are\n");
#line 141
  fprintf(stdout, "    less quality layers than the specified number, all the quality layers\n");
#line 142
  fprintf(stdout, "    are decoded.\n");
#line 143
  fprintf(stdout, "  -x  \n");
#line 144
  fprintf(stdout, "    Create an index file *.Idx (-x index_name.Idx) \n");
#line 145
  fprintf(stdout, "  -d <x0,y0,x1,y1>\n");
#line 146
  fprintf(stdout, "    OPTIONAL\n");
#line 147
  fprintf(stdout, "    Decoding area\n");
#line 148
  fprintf(stdout, "    By default all the image is decoded.\n");
#line 149
  fprintf(stdout, "  -t <tile_number>\n");
#line 150
  fprintf(stdout, "    OPTIONAL\n");
#line 151
  fprintf(stdout, "    Set the tile number of the decoded tile. Follow the JPEG2000 convention from left-up to bottom-up\n");
#line 152
  fprintf(stdout, "    By default all tiles are decoded.\n");
#line 153
  fprintf(stdout, "\n");
#line 164
  fprintf(stdout, "\n\035");
  }
#line 166
  return;
}
}
#line 169 "/root/patron/new_22/src/bin/jp2/opj_decompress.c"
int get_num_images(char *imgdirpath ) 
{ 
  DIR *dir ;
  struct dirent *content ;
  int num_images ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
  {
#line 172
  num_images = 0;
#line 176
  dir = opendir((char const   *)imgdirpath);
  }
#line 177
  if (! dir) {
    {
#line 178
    fprintf(stderr, "Could not open Folder %s\n", imgdirpath);
    }
#line 179
    return (0);
  }
  {
#line 182
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
    {
#line 182
    content = readdir(dir);
    }
#line 182
    if (! ((unsigned long )content != (unsigned long )((void *)0))) {
#line 182
      goto while_break;
    }
    {
#line 183
    __cil_tmp8 = strcmp("..", (char const   *)(content->d_name));
#line 183
    __cil_tmp7 = strcmp(".\217", (char const   *)(content->d_name));
    }
#line 183
    if (__cil_tmp7 == 0) {
#line 184
      goto while_continue;
    } else
#line 183
    if (__cil_tmp8 == 0) {
#line 184
      goto while_continue;
    }
#line 185
    num_images ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 187
  return (num_images);
}
}
#line 191 "/root/patron/new_22/src/bin/jp2/opj_decompress.c"
int load_images(dircnt_t *dirptr , char *imgdirpath ) 
{ 
  DIR *dir ;
  struct dirent *content ;
  int i ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 194
  i = 0;
#line 198
  dir = opendir((char const   *)imgdirpath);
  }
#line 199
  if (! dir) {
    {
#line 200
    fprintf(stderr, "Could not open Folder %s\n\205\001", imgdirpath);
    }
#line 201
    return (1);
  } else {
    {
#line 203
    fprintf(stderr, "Folder opened successfully\n");
    }
  }
  {
#line 206
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
    {
#line 206
    content = readdir(dir);
    }
#line 206
    if (! ((unsigned long )content != (unsigned long )((void *)0))) {
#line 206
      goto while_break;
    }
    {
#line 207
    __cil_tmp9 = strcmp("..", (char const   *)(content->d_name));
#line 207
    __cil_tmp8 = strcmp(".", (char const   *)(content->d_name));
    }
#line 207
    if (__cil_tmp8 == 0) {
#line 208
      goto while_continue;
    } else
#line 207
    if (__cil_tmp9 == 0) {
#line 208
      goto while_continue;
    }
    {
#line 210
    strcpy(*(dirptr->filename + i), (char const   *)(content->d_name));
#line 211
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 213
  return (0);
}
}
#line 220 "/root/patron/new_22/src/bin/jp2/opj_decompress.c"
static char const   *extension[15]  ;
#line 221 "/root/patron/new_22/src/bin/jp2/opj_decompress.c"
static int const   format[15]  ;
#line 217 "/root/patron/new_22/src/bin/jp2/opj_decompress.c"
int get_file_format(char const   *filename ) 
{ 
  unsigned int i ;
  char *ext ;
  char *__cil_tmp6 ;
  int __cil_tmp8 ;

  {
  {
#line 219
  strcpy((char *)extension[0], "pgx\213\202U");
#line 219
  strcpy((char *)extension[1], "pnm");
#line 219
  strcpy((char *)extension[2], "pgm\213\202U");
#line 219
  strcpy((char *)extension[3], "ppm");
#line 219
  strcpy((char *)extension[4], "bmp\212\202U");
#line 219
  strcpy((char *)extension[5], "tif\212\202U");
#line 219
  strcpy((char *)extension[6], "raw\213\202U");
#line 219
  strcpy((char *)extension[7], "rawl\202U");
#line 219
  strcpy((char *)extension[8], "tga\212\202U");
#line 219
  strcpy((char *)extension[9], "png\212\202U");
#line 219
  strcpy((char *)extension[10], "j2k\212\202U");
#line 219
  strcpy((char *)extension[11], "jp2\212\202U");
#line 219
  strcpy((char *)extension[12], "jpt\212\202U");
#line 219
  strcpy((char *)extension[13], "j2c\212\202U");
#line 219
  strcpy((char *)extension[14], "jpc\212\202U");
#line 220
  format[0] = (int const   )11;
#line 220
  format[1] = (int const   )10;
#line 220
  format[2] = (int const   )10;
#line 220
  format[3] = (int const   )10;
#line 220
  format[4] = (int const   )12;
#line 220
  format[5] = (int const   )14;
#line 220
  format[6] = (int const   )15;
#line 220
  format[7] = (int const   )18;
#line 220
  format[8] = (int const   )16;
#line 220
  format[9] = (int const   )17;
#line 220
  format[10] = (int const   )0;
#line 220
  format[11] = (int const   )1;
#line 220
  format[12] = (int const   )2;
#line 220
  format[13] = (int const   )0;
#line 220
  format[14] = (int const   )0;
#line 221
  __cil_tmp6 = strrchr(filename, '.');
#line 221
  ext = __cil_tmp6;
  }
#line 222
  if ((unsigned long )ext == (unsigned long )((void *)0)) {
#line 223
    return (-1);
  }
#line 224
  ext ++;
#line 225
  if (ext) {
#line 226
    i = 0U;
    {
#line 226
    while (1) {
      while_continue: /* CIL Label */ ;

#line 226
      if (! ((unsigned long )i < sizeof(format) / sizeof(format[0]))) {
#line 226
        goto while_break;
      }
      {
#line 227
      __cil_tmp8 = strcasecmp((char const   *)ext, extension[i]);
      }
#line 227
      if (__cil_tmp8 == 0) {
#line 228
        return ((int )format[i]);
      }
#line 226
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 233
  return (-1);
}
}
#line 237 "/root/patron/new_22/src/bin/jp2/opj_decompress.c"
char get_next_file(int imageno , dircnt_t *dirptr , img_fol_t *img_fol , opj_dparameters_t *parameters ) 
{ 
  char image_filename[4096] ;
  char infilename[4096] ;
  char outfilename[4096] ;
  char temp_ofname[4096] ;
  char *temp_p ;
  char temp1[4096] ;
  char *__cil_tmp12 ;

  {
  {
#line 239
  strcpy(temp1, "\002");
#line 241
  strcpy(image_filename, (char const   *)*(dirptr->filename + imageno));
#line 242
  fprintf(stderr, "File Number %d \"%s\"\n\202U", imageno, image_filename);
#line 243
  parameters->decod_format = infile_format((char const   *)(image_filename));
  }
#line 244
  if (parameters->decod_format == -1) {
#line 245
    return ((char)1);
  }
  {
#line 246
  sprintf(infilename, "%s/%sU", img_fol->imgdirpath, image_filename);
#line 247
  strncpy(parameters->infile, (char const   *)(infilename), sizeof(infilename));
#line 250
  __cil_tmp12 = strtok(image_filename, ".");
#line 250
  strcpy(temp_ofname, (char const   *)__cil_tmp12);
  }
  {
#line 251
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 251
    temp_p = strtok((char *)((void *)0), ".\024\373\212\202U");
    }
#line 251
    if (! ((unsigned long )temp_p != (unsigned long )((void *)0))) {
#line 251
      goto while_break;
    }
    {
#line 252
    strcat(temp_ofname, (char const   *)(temp1));
#line 253
    sprintf(temp1, ".%s", temp_p);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 255
  if ((int )img_fol->set_out_format == 1) {
    {
#line 256
    sprintf(outfilename, "%s/%s.%s\230\001", img_fol->imgdirpath, temp_ofname, img_fol->out_format);
#line 257
    strncpy(parameters->outfile, (char const   *)(outfilename), sizeof(outfilename));
    }
  }
#line 259
  return ((char)0);
}
}
#line 268 "/root/patron/new_22/src/bin/jp2/opj_decompress.c"
static int infile_format(char const   *fname ) 
{ 
  FILE *reader ;
  char const   *s ;
  char const   *magic_s ;
  int ext_format ;
  int magic_format ;
  unsigned char buf[12] ;
  unsigned int l_nb_read ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  unsigned long __cil_tmp15 ;

  {
  {
#line 276
  reader = fopen(fname, "rb");
  }
#line 278
  if ((unsigned long )reader == (unsigned long )((void *)0)) {
#line 279
    return (-2);
  }
  {
#line 281
  memset((void *)(buf), 0, 12UL);
#line 282
  __cil_tmp10 = fread((void *)(buf), 1UL, 12UL, reader);
#line 282
  l_nb_read = (unsigned int )__cil_tmp10;
#line 283
  fclose(reader);
  }
#line 284
  if (l_nb_read != 12U) {
#line 285
    return (-1);
  }
  {
#line 289
  ext_format = get_file_format(fname);
  }
#line 291
  if (ext_format == 2) {
#line 292
    return (2);
  }
  {
#line 294
  __cil_tmp13 = memcmp((void const   *)(buf), (void const   *)"\r\n\207\n", 4UL);
#line 294
  __cil_tmp12 = memcmp((void const   *)(buf), (void const   *)"", 12UL);
  }
#line 294
  if (__cil_tmp12 == 0) {
    {
#line 295
    magic_format = 1;
#line 296
    strcpy((char *)magic_s, ".jp2");
    }
  } else
#line 294
  if (__cil_tmp13 == 0) {
    {
#line 295
    magic_format = 1;
#line 296
    strcpy((char *)magic_s, ".jp2");
    }
  } else {
    {
#line 298
    __cil_tmp14 = memcmp((void const   *)(buf), (void const   *)"\377O\377Q", 4UL);
    }
#line 298
    if (__cil_tmp14 == 0) {
      {
#line 299
      magic_format = 0;
#line 300
      strcpy((char *)magic_s, ".j2k or .jpc or .j2c");
      }
    } else {
#line 303
      return (-1);
    }
  }
#line 305
  if (magic_format == ext_format) {
#line 306
    return (ext_format);
  }
  {
#line 308
  __cil_tmp15 = strlen(fname);
#line 308
  s = (fname + __cil_tmp15) - 4;
#line 310
  fputs("\n===========================================\n", stderr);
#line 311
  fprintf(stderr, "The extension of this file is incorrect.\nFOUND %s. SHOULD BE %s\n",
          s, magic_s);
#line 313
  fputs("===========================================\n\202U", stderr);
  }
#line 315
  return (magic_format);
}
}
#line 323 "/root/patron/new_22/src/bin/jp2/opj_decompress.c"
int parse_cmdline_decoder(int argc , char **argv , opj_dparameters_t *parameters ,
                          img_fol_t *img_fol , char *indexfilename ) 
{ 
  int totlen ;
  int c ;
  opj_option_t long_option[2] ;
  char optlist[16] ;
  char *infile ;
  char *outfile ;
  char outformat[50] ;
  char *of ;
  unsigned long __cil_tmp18 ;
  void *__cil_tmp19 ;
  int size_optarg ;
  unsigned long __cil_tmp21 ;
  char *ROI_values ;
  void *__cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  char *index___54 ;

  {
  {
#line 326
  strcpy((char *)long_option[0].name, "ImgDir");
#line 326
  long_option[0].has_arg = 1;
#line 326
  long_option[0].flag = (int *)((void *)0);
#line 326
  long_option[0].val = 'y';
#line 326
  strcpy((char *)long_option[1].name, "OutFor");
#line 326
  long_option[1].has_arg = 1;
#line 326
  long_option[1].flag = (int *)((void *)0);
#line 326
  long_option[1].val = 'O';
#line 331
  strcpy(optlist, "i:o:r:l:x:d:t:h");
#line 339
  totlen = (int )sizeof(long_option);
#line 340
  img_fol->set_out_format = (char)0;
  }
  {
#line 341
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 342
    c = opj_getopt_long(argc, argv, (char const   *)(optlist), long_option, totlen);
    }
#line 343
    if (c == -1) {
#line 344
      goto while_break;
    }
#line 346
    if (c == 105) {
#line 346
      goto case_105;
    }
#line 351
    if (c == 0) {
#line 351
      goto case_0;
    }
#line 353
    if (c == 1) {
#line 353
      goto case_1;
    }
#line 355
    if (c == 2) {
#line 355
      goto case_2;
    }
#line 357
    if (c == -2) {
#line 357
      goto case_exp;
    }
#line 374
    if (c == 111) {
#line 374
      goto case_111;
    }
#line 379
    if (c == 11) {
#line 379
      goto case_11;
    }
#line 381
    if (c == 10) {
#line 381
      goto case_10;
    }
#line 383
    if (c == 12) {
#line 383
      goto case_12;
    }
#line 385
    if (c == 14) {
#line 385
      goto case_14;
    }
#line 387
    if (c == 15) {
#line 387
      goto case_15;
    }
#line 389
    if (c == 18) {
#line 389
      goto case_18;
    }
#line 391
    if (c == 16) {
#line 391
      goto case_16;
    }
#line 393
    if (c == 17) {
#line 393
      goto case_17;
    }
#line 405
    if (c == 79) {
#line 405
      goto case_79;
    }
#line 413
    if (c == 11) {
#line 413
      goto case_11___0;
    }
#line 416
    if (c == 10) {
#line 416
      goto case_10___0;
    }
#line 419
    if (c == 12) {
#line 419
      goto case_12___0;
    }
#line 422
    if (c == 14) {
#line 422
      goto case_14___0;
    }
#line 425
    if (c == 15) {
#line 425
      goto case_15___0;
    }
#line 428
    if (c == 18) {
#line 428
      goto case_18___0;
    }
#line 431
    if (c == 16) {
#line 431
      goto case_16___0;
    }
#line 434
    if (c == 17) {
#line 434
      goto case_17___0;
    }
#line 448
    if (c == 114) {
#line 448
      goto case_114;
    }
#line 457
    if (c == 108) {
#line 457
      goto case_108;
    }
#line 465
    if (c == 104) {
#line 465
      goto case_104;
    }
#line 471
    if (c == 121) {
#line 471
      goto case_121;
    }
#line 481
    if (c == 100) {
#line 481
      goto case_100;
    }
#line 497
    if (c == 116) {
#line 497
      goto case_116;
    }
#line 506
    if (c == 120) {
#line 506
      goto case_120;
    }
#line 586
    goto switch_default___2;
    case_105: 
    {
#line 348
    infile = opj_optarg;
#line 349
    parameters->decod_format = infile_format((char const   *)infile);
    }
#line 351
    if (parameters->decod_format == 0) {
#line 351
      goto case_0;
    }
#line 353
    if (parameters->decod_format == 1) {
#line 353
      goto case_1;
    }
#line 355
    if (parameters->decod_format == 2) {
#line 355
      goto case_2;
    }
#line 357
    if (parameters->decod_format == -2) {
#line 357
      goto case_exp;
    }
#line 362
    goto switch_default;
    case_0: 
#line 352
    goto switch_break___0;
    case_1: 
#line 354
    goto switch_break___0;
    case_2: 
#line 356
    goto switch_break___0;
    case_exp: 
    {
#line 358
    fprintf(stderr, "!! infile cannot be read: %s !!\n\n\356\224\212\202U", infile);
    }
#line 361
    return (1);
    switch_default: 
    {
#line 363
    fprintf(stderr, "!! Unrecognized format for infile: %s [accept only *.j2k, *.jp2, *.jpc or *.jpt] !!\n\nU",
            infile);
    }
#line 366
    return (1);
    switch_break___0: 
    {
#line 368
    strncpy(parameters->infile, (char const   *)infile, sizeof(parameters->infile) - 1UL);
    }
#line 370
    goto switch_break;
    case_111: 
    {
#line 376
    outfile = opj_optarg;
#line 377
    parameters->cod_format = get_file_format((char const   *)outfile);
    }
#line 379
    if (parameters->cod_format == 11) {
#line 379
      goto case_11;
    }
#line 381
    if (parameters->cod_format == 10) {
#line 381
      goto case_10;
    }
#line 383
    if (parameters->cod_format == 12) {
#line 383
      goto case_12;
    }
#line 385
    if (parameters->cod_format == 14) {
#line 385
      goto case_14;
    }
#line 387
    if (parameters->cod_format == 15) {
#line 387
      goto case_15;
    }
#line 389
    if (parameters->cod_format == 18) {
#line 389
      goto case_18;
    }
#line 391
    if (parameters->cod_format == 16) {
#line 391
      goto case_16;
    }
#line 393
    if (parameters->cod_format == 17) {
#line 393
      goto case_17;
    }
#line 395
    goto switch_default___0;
    case_11: 
#line 380
    goto switch_break___1;
    case_10: 
#line 382
    goto switch_break___1;
    case_12: 
#line 384
    goto switch_break___1;
    case_14: 
#line 386
    goto switch_break___1;
    case_15: 
#line 388
    goto switch_break___1;
    case_18: 
#line 390
    goto switch_break___1;
    case_16: 
#line 392
    goto switch_break___1;
    case_17: 
#line 394
    goto switch_break___1;
    switch_default___0: 
    {
#line 396
    fprintf(stderr, "Unknown output format image %s [only *.pnm, *.pgm, *.ppm, *.pgx, *.bmp, *.tif, *.raw or *.tga]!! \n\004\213\202U",
            outfile);
    }
#line 397
    return (1);
    switch_break___1: 
    {
#line 399
    strncpy(parameters->outfile, (char const   *)outfile, sizeof(parameters->outfile) - 1UL);
    }
#line 401
    goto switch_break;
    case_79: 
    {
#line 408
    of = opj_optarg;
#line 409
    sprintf(outformat, ".%s", of);
#line 410
    img_fol->set_out_format = (char)1;
#line 411
    parameters->cod_format = get_file_format((char const   *)(outformat));
    }
#line 413
    if (parameters->cod_format == 11) {
#line 413
      goto case_11___0;
    }
#line 416
    if (parameters->cod_format == 10) {
#line 416
      goto case_10___0;
    }
#line 419
    if (parameters->cod_format == 12) {
#line 419
      goto case_12___0;
    }
#line 422
    if (parameters->cod_format == 14) {
#line 422
      goto case_14___0;
    }
#line 425
    if (parameters->cod_format == 15) {
#line 425
      goto case_15___0;
    }
#line 428
    if (parameters->cod_format == 18) {
#line 428
      goto case_18___0;
    }
#line 431
    if (parameters->cod_format == 16) {
#line 431
      goto case_16___0;
    }
#line 434
    if (parameters->cod_format == 17) {
#line 434
      goto case_17___0;
    }
#line 437
    goto switch_default___1;
    case_11___0: 
    {
#line 414
    strcpy((char *)img_fol->out_format, "pgx");
    }
#line 415
    goto switch_break___2;
    case_10___0: 
    {
#line 417
    strcpy((char *)img_fol->out_format, "ppm");
    }
#line 418
    goto switch_break___2;
    case_12___0: 
    {
#line 420
    strcpy((char *)img_fol->out_format, "bmp");
    }
#line 421
    goto switch_break___2;
    case_14___0: 
    {
#line 423
    strcpy((char *)img_fol->out_format, "tif");
    }
#line 424
    goto switch_break___2;
    case_15___0: 
    {
#line 426
    strcpy((char *)img_fol->out_format, "raw");
    }
#line 427
    goto switch_break___2;
    case_18___0: 
    {
#line 429
    strcpy((char *)img_fol->out_format, "rawl");
    }
#line 430
    goto switch_break___2;
    case_16___0: 
    {
#line 432
    strcpy((char *)img_fol->out_format, "raw");
    }
#line 433
    goto switch_break___2;
    case_17___0: 
    {
#line 435
    strcpy((char *)img_fol->out_format, "png");
    }
#line 436
    goto switch_break___2;
    switch_default___1: 
    {
#line 438
    fprintf(stderr, "Unknown output format image %s [only *.pnm, *.pgm, *.ppm, *.pgx, *.bmp, *.tif, *.raw or *.tga]!! \n",
            outformat);
    }
#line 439
    return (1);
#line 440
    goto switch_break___2;
    switch_break___2: ;
#line 443
    goto switch_break;
    case_114: 
    {
#line 450
    sscanf((char const   *)opj_optarg, "%d", & parameters->cp_reduce);
    }
#line 452
    goto switch_break;
    case_108: 
    {
#line 459
    sscanf((char const   *)opj_optarg, "%d", & parameters->cp_layer);
    }
#line 461
    goto switch_break;
    case_104: 
    {
#line 466
    decode_help_display();
    }
#line 467
    return (1);
    case_121: 
    {
#line 473
    __cil_tmp18 = strlen((char const   *)opj_optarg);
#line 473
    __cil_tmp19 = malloc(__cil_tmp18 + 1UL);
#line 473
    img_fol->imgdirpath = (char *)__cil_tmp19;
#line 474
    strcpy(img_fol->imgdirpath, (char const   *)opj_optarg);
#line 475
    img_fol->set_imgdir = (char)1;
    }
#line 477
    goto switch_break;
    case_100: 
    {
#line 483
    __cil_tmp21 = strlen((char const   *)opj_optarg);
#line 483
    size_optarg = (int )__cil_tmp21 + 1;
#line 484
    __cil_tmp23 = malloc((unsigned long )size_optarg);
#line 484
    ROI_values = (char *)__cil_tmp23;
#line 485
    *(ROI_values + 0) = (char )'\000';
#line 486
    __cil_tmp24 = strlen((char const   *)opj_optarg);
#line 486
    strncpy(ROI_values, (char const   *)opj_optarg, __cil_tmp24);
#line 487
    __cil_tmp25 = strlen((char const   *)opj_optarg);
#line 487
    *(ROI_values + __cil_tmp25) = (char )'\000';
#line 489
    parse_DA_values(ROI_values, & parameters->DA_x0, & parameters->DA_y0, & parameters->DA_x1,
                    & parameters->DA_y1);
#line 491
    free((void *)ROI_values);
    }
#line 493
    goto switch_break;
    case_116: 
    {
#line 499
    sscanf((char const   *)opj_optarg, "%d", & parameters->tile_index);
#line 500
    parameters->nb_tile_to_decode = (OPJ_UINT32 )1;
    }
#line 502
    goto switch_break;
    case_120: 
    {
#line 508
    index___54 = opj_optarg;
#line 509
    strncpy(indexfilename, (char const   *)index___54, 4096UL);
    }
#line 511
    goto switch_break;
    switch_default___2: 
    {
#line 587
    fprintf(stderr, "WARNING -> this option is not valid \"-%c %s\"\n", c, opj_optarg);
    }
#line 588
    goto switch_break;
    switch_break: ;
#line 341
    if (! (c != -1)) {
#line 341
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 593
  if ((int )img_fol->set_imgdir == 1) {
#line 594
    if (! ((int )parameters->infile[0] == 0)) {
      {
#line 595
      fprintf(stderr, "Error: options -ImgDir and -i cannot be used together !!\n");
      }
#line 596
      return (1);
    }
#line 598
    if ((int )img_fol->set_out_format == 0) {
      {
#line 599
      fprintf(stderr, "Error: When -ImgDir is used, -OutFor <FORMAT> must be used !!\n");
#line 600
      fprintf(stderr, "Only one format allowed! Valid format PGM, PPM, PNM, PGX, BMP, TIF, RAW and TGA!!\n");
      }
#line 601
      return (1);
    }
#line 603
    if (! ((int )parameters->outfile[0] == 0)) {
      {
#line 604
      fprintf(stderr, "Error: options -ImgDir and -o cannot be used together !!\n");
      }
#line 605
      return (1);
    }
  } else
#line 608
  if ((int )parameters->infile[0] == 0) {
    {
#line 609
    fprintf(stderr, "Example: %s -i image.j2k -o image.pgm\n", *(argv + 0));
#line 610
    fprintf(stderr, "    Try: %s -h\n", *(argv + 0));
    }
#line 611
    return (1);
  } else
#line 608
  if ((int )parameters->outfile[0] == 0) {
    {
#line 609
    fprintf(stderr, "Example: %s -i image.j2k -o image.pgm\n", *(argv + 0));
#line 610
    fprintf(stderr, "    Try: %s -h\n", *(argv + 0));
    }
#line 611
    return (1);
  }
#line 615
  return (0);
}
}
#line 624 "/root/patron/new_22/src/bin/jp2/opj_decompress.c"
int parse_DA_values(char *inArg , unsigned int *DA_x0 , unsigned int *DA_y0 , unsigned int *DA_x1 ,
                    unsigned int *DA_y1 ) 
{ 
  int it ;
  int values[4] ;
  char delims[2] ;
  char *result ;

  {
  {
#line 626
  it = 0;
#line 628
  strcpy(delims, ",");
#line 629
  result = (char *)((void *)0);
#line 630
  result = strtok(inArg, (char const   *)(delims));
  }
  {
#line 632
  while (1) {
    while_continue: /* CIL Label */ ;

#line 632
    if ((unsigned long )result != (unsigned long )((void *)0)) {
#line 632
      if (! (it < 4)) {
#line 632
        goto while_break;
      }
    } else {
#line 632
      goto while_break;
    }
    {
#line 633
    values[it] = atoi((char const   *)result);
#line 634
    result = strtok((char *)((void *)0), (char const   *)(delims));
#line 635
    it ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 638
  if (it != 4) {
#line 639
    return (1);
  } else {
#line 642
    *DA_x0 = (unsigned int )values[0];
#line 642
    *DA_y0 = (unsigned int )values[1];
#line 643
    *DA_x1 = (unsigned int )values[2];
#line 643
    *DA_y1 = (unsigned int )values[3];
#line 644
    return (0);
  }
}
}
#line 653 "/root/patron/new_22/src/bin/jp2/opj_decompress.c"
static void error_callback(char const   *msg , void *client_data ) 
{ 


  {
  {
#line 655
  fprintf(stdout, "[ERROR] %s", msg);
  }
#line 657
  return;
}
}
#line 660 "/root/patron/new_22/src/bin/jp2/opj_decompress.c"
static void warning_callback(char const   *msg , void *client_data ) 
{ 


  {
  {
#line 662
  fprintf(stdout, "[WARNING] %s", msg);
  }
#line 664
  return;
}
}
#line 667 "/root/patron/new_22/src/bin/jp2/opj_decompress.c"
static void info_callback(char const   *msg , void *client_data ) 
{ 


  {
  {
#line 669
  fprintf(stdout, "[INFO] %s", msg);
  }
#line 671
  return;
}
}
#line 677 "/root/patron/new_22/src/bin/jp2/opj_decompress.c"
int main(int argc , char **argv ) 
{ 
  opj_dparameters_t parameters ;
  opj_image_t *image ;
  opj_stream_t *l_stream ;
  opj_codec_t *l_codec ;
  opj_codestream_index_t *cstr_index ;
  char indexfilename[4096] ;
  OPJ_INT32 num_images ;
  OPJ_INT32 imageno ;
  img_fol_t img_fol ;
  dircnt_t *dirptr ;
  int __cil_tmp13 ;
  int it_image ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  int __cil_tmp20 ;
  char __cil_tmp21 ;
  OPJ_BOOL __cil_tmp26 ;
  OPJ_BOOL __cil_tmp27 ;
  OPJ_BOOL __cil_tmp28 ;
  OPJ_BOOL __cil_tmp29 ;
  OPJ_BOOL __cil_tmp30 ;
  OPJ_BOOL __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;

  {
  {
#line 681
  image = (opj_image_t *)((void *)0);
#line 682
  l_stream = (opj_stream_t *)((void *)0);
#line 683
  l_codec = (opj_codec_t *)((void *)0);
#line 684
  cstr_index = (opj_codestream_index_t *)((void *)0);
#line 690
  dirptr = (dircnt_t *)((void *)0);
#line 693
  opj_set_default_decoder_parameters(& parameters);
#line 696
  indexfilename[0] = (char)0;
#line 699
  memset((void *)(& img_fol), 0, sizeof(img_fol_t ));
#line 702
  __cil_tmp13 = parse_cmdline_decoder(argc, argv, & parameters, & img_fol, indexfilename);
  }
#line 702
  if (__cil_tmp13 == 1) {
#line 703
    return (1);
  }
#line 707
  if ((int )img_fol.set_imgdir == 1) {
    {
#line 709
    num_images = get_num_images(img_fol.imgdirpath);
#line 711
    __cil_tmp16 = malloc(sizeof(dircnt_t ));
#line 711
    dirptr = (dircnt_t *)__cil_tmp16;
    }
#line 712
    if (dirptr) {
      {
#line 713
      __cil_tmp17 = malloc((unsigned long )(num_images * 4096) * sizeof(char ));
#line 713
      dirptr->filename_buf = (char *)__cil_tmp17;
#line 714
      __cil_tmp18 = malloc((unsigned long )num_images * sizeof(char *));
#line 714
      dirptr->filename = (char **)__cil_tmp18;
      }
#line 716
      if (! dirptr->filename_buf) {
#line 717
        return (1);
      }
#line 719
      it_image = 0;
      {
#line 719
      while (1) {
        while_continue: /* CIL Label */ ;

#line 719
        if (! (it_image < num_images)) {
#line 719
          goto while_break;
        }
#line 720
        *(dirptr->filename + it_image) = dirptr->filename_buf + it_image * 4096;
#line 719
        it_image ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      while_break: ;
    }
    {
#line 723
    __cil_tmp20 = load_images(dirptr, img_fol.imgdirpath);
    }
#line 723
    if (__cil_tmp20 == 1) {
#line 724
      return (1);
    }
#line 726
    if (num_images == 0) {
      {
#line 727
      fprintf(stdout, "Folder is empty\n\220");
      }
#line 728
      return (1);
    }
  } else {
#line 731
    num_images = 1;
  }
#line 735
  imageno = 0;
  {
#line 735
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue___0: ;
#line 735
    if (! (imageno < num_images)) {
#line 735
      goto while_break___0;
    }
    {
#line 737
    fprintf(stderr, "\n");
    }
#line 739
    if ((int )img_fol.set_imgdir == 1) {
      {
#line 740
      __cil_tmp21 = get_next_file(imageno, dirptr, & img_fol, & parameters);
      }
#line 740
      if (__cil_tmp21) {
        {
#line 741
        fprintf(stderr, "skipping file...\n");
        }
#line 742
        goto while_continue___0;
      }
    }
    {
#line 749
    l_stream = opj_stream_create_default_file_stream_v3((char const   *)(parameters.infile),
                                                        1);
    }
#line 750
    if (! l_stream) {
      {
#line 751
      fprintf(stderr, "ERROR -> failed to create the stream from the file %s\n", parameters.infile);
      }
#line 752
      return (1);
    }
#line 759
    if (parameters.decod_format == 0) {
#line 759
      goto case_0;
    }
#line 765
    if (parameters.decod_format == 1) {
#line 765
      goto case_1;
    }
#line 771
    if (parameters.decod_format == 2) {
#line 771
      goto case_2;
    }
#line 777
    goto switch_default;
    case_0: 
    {
#line 762
    l_codec = opj_create_decompress((OPJ_CODEC_FORMAT )0);
    }
#line 763
    goto switch_break;
    case_1: 
    {
#line 768
    l_codec = opj_create_decompress((OPJ_CODEC_FORMAT )2);
    }
#line 769
    goto switch_break;
    case_2: 
    {
#line 774
    l_codec = opj_create_decompress((OPJ_CODEC_FORMAT )1);
    }
#line 775
    goto switch_break;
    switch_default: 
    {
#line 778
    fprintf(stderr, "skipping file..\n\220");
#line 779
    opj_stream_destroy_v3(l_stream);
    }
#line 780
    goto while_continue___0;
    switch_break: 
    {
#line 784
    opj_set_info_handler(l_codec, & info_callback, (void *)0);
#line 785
    opj_set_warning_handler(l_codec, & warning_callback, (void *)0);
#line 786
    opj_set_error_handler(l_codec, & error_callback, (void *)0);
#line 789
    __cil_tmp26 = opj_setup_decoder(l_codec, & parameters);
    }
#line 789
    if (! __cil_tmp26) {
      {
#line 790
      fprintf(stderr, "ERROR -> j2k_dump: failed to setup the decoder\n");
#line 791
      opj_stream_destroy_v3(l_stream);
#line 792
      opj_destroy_codec(l_codec);
      }
#line 793
      return (1);
    }
    {
#line 798
    __cil_tmp27 = opj_read_header(l_stream, l_codec, & image);
    }
#line 798
    if (! __cil_tmp27) {
      {
#line 799
      fprintf(stderr, "ERROR -> opj_decompress: failed to read the header\n\213\202U");
#line 800
      opj_stream_destroy_v3(l_stream);
#line 801
      opj_destroy_codec(l_codec);
#line 802
      opj_image_destroy(image);
      }
#line 803
      return (1);
    }
#line 806
    if (! parameters.nb_tile_to_decode) {
      {
#line 808
      __cil_tmp28 = opj_set_decode_area(l_codec, image, (OPJ_INT32 )parameters.DA_x0,
                                        (OPJ_INT32 )parameters.DA_y0, (OPJ_INT32 )parameters.DA_x1,
                                        (OPJ_INT32 )parameters.DA_y1);
      }
#line 808
      if (! __cil_tmp28) {
        {
#line 810
        fprintf(stderr, "ERROR -> opj_decompress: failed to set the decoded area\n\220");
#line 811
        opj_stream_destroy_v3(l_stream);
#line 812
        opj_destroy_codec(l_codec);
#line 813
        opj_image_destroy(image);
        }
#line 814
        return (1);
      }
      {
#line 818
      __cil_tmp30 = opj_end_decompress(l_codec, l_stream);
#line 818
      __cil_tmp29 = opj_decode(l_codec, l_stream, image);
      }
#line 818
      if (__cil_tmp29) {
#line 818
        if (! __cil_tmp30) {
          {
#line 819
          fprintf(stderr, "ERROR -> opj_decompress: failed to decode image!\n");
#line 820
          opj_destroy_codec(l_codec);
#line 821
          opj_stream_destroy_v3(l_stream);
#line 822
          opj_image_destroy(image);
          }
#line 823
          return (1);
        }
      } else {
        {
#line 819
        fprintf(stderr, "ERROR -> opj_decompress: failed to decode image!\n");
#line 820
        opj_destroy_codec(l_codec);
#line 821
        opj_stream_destroy_v3(l_stream);
#line 822
        opj_image_destroy(image);
        }
#line 823
        return (1);
      }
    } else {
      {
#line 837
      __cil_tmp31 = opj_get_decoded_tile(l_codec, l_stream, image, parameters.tile_index);
      }
#line 837
      if (! __cil_tmp31) {
        {
#line 838
        fprintf(stderr, "ERROR -> opj_decompress: failed to decode tile!\n\220");
#line 839
        opj_destroy_codec(l_codec);
#line 840
        opj_stream_destroy_v3(l_stream);
#line 841
        opj_image_destroy(image);
        }
#line 842
        return (1);
      }
      {
#line 844
      fprintf(stdout, "tile %d is decoded!\n\nU", parameters.tile_index);
      }
    }
    {
#line 848
    opj_stream_destroy_v3(l_stream);
    }
#line 850
    if ((int )image->color_space == 3) {
      {
#line 851
      color_sycc_to_rgb(image);
      }
    }
#line 854
    if ((int )image->color_space != 3) {
#line 854
      if (image->numcomps == 3U) {
#line 854
        if ((image->comps + 0)->dx == (image->comps + 0)->dy) {
#line 854
          if ((image->comps + 1)->dx != 1U) {
#line 857
            image->color_space = (OPJ_COLOR_SPACE )3;
          } else {
#line 854
            goto _L;
          }
        } else {
#line 854
          goto _L;
        }
      } else {
#line 854
        goto _L;
      }
    } else
    _L: 
#line 858
    if (image->numcomps <= 2U) {
#line 859
      image->color_space = (OPJ_COLOR_SPACE )2;
    }
#line 861
    if (image->icc_profile_buf) {
      {
#line 865
      free((void *)image->icc_profile_buf);
#line 866
      image->icc_profile_buf = (OPJ_BYTE *)((void *)0);
#line 866
      image->icc_profile_len = (OPJ_UINT32 )0;
      }
    }
#line 872
    if (parameters.cod_format == 10) {
#line 872
      goto case_10;
    }
#line 881
    if (parameters.cod_format == 11) {
#line 881
      goto case_11;
    }
#line 890
    if (parameters.cod_format == 12) {
#line 890
      goto case_12;
    }
#line 899
    if (parameters.cod_format == 14) {
#line 899
      goto case_14;
    }
#line 908
    if (parameters.cod_format == 15) {
#line 908
      goto case_15;
    }
#line 917
    if (parameters.cod_format == 18) {
#line 917
      goto case_18;
    }
#line 926
    if (parameters.cod_format == 16) {
#line 926
      goto case_16;
    }
#line 935
    if (parameters.cod_format == 17) {
#line 935
      goto case_17;
    }
#line 947
    goto switch_default___0;
    case_10: 
    {
#line 873
    __cil_tmp32 = imagetopnm(image, (char const   *)(parameters.outfile));
    }
#line 873
    if (__cil_tmp32) {
      {
#line 874
      fprintf(stdout, "Outfile %s not generated\n", parameters.outfile);
      }
    } else {
      {
#line 877
      fprintf(stdout, "Generated Outfile %s\n", parameters.outfile);
      }
    }
#line 879
    goto switch_break___0;
    case_11: 
    {
#line 882
    __cil_tmp33 = imagetopgx(image, (char const   *)(parameters.outfile));
    }
#line 882
    if (__cil_tmp33) {
      {
#line 883
      fprintf(stdout, "Outfile %s not generated\n", parameters.outfile);
      }
    } else {
      {
#line 886
      fprintf(stdout, "Generated Outfile %s\n", parameters.outfile);
      }
    }
#line 888
    goto switch_break___0;
    case_12: 
    {
#line 891
    __cil_tmp34 = imagetobmp(image, (char const   *)(parameters.outfile));
    }
#line 891
    if (__cil_tmp34) {
      {
#line 892
      fprintf(stdout, "Outfile %s not generated\n", parameters.outfile);
      }
    } else {
      {
#line 895
      fprintf(stdout, "Generated Outfile %s\n", parameters.outfile);
      }
    }
#line 897
    goto switch_break___0;
    case_14: 
    {
#line 900
    __cil_tmp35 = imagetotif(image, (char const   *)(parameters.outfile));
    }
#line 900
    if (__cil_tmp35) {
      {
#line 901
      fprintf(stdout, "Outfile %s not generated\n", parameters.outfile);
      }
    } else {
      {
#line 904
      fprintf(stdout, "Generated Outfile %s\n", parameters.outfile);
      }
    }
#line 906
    goto switch_break___0;
    case_15: 
    {
#line 909
    __cil_tmp36 = imagetoraw(image, (char const   *)(parameters.outfile));
    }
#line 909
    if (__cil_tmp36) {
      {
#line 910
      fprintf(stdout, "Error generating raw file. Outfile %s not generated\n", parameters.outfile);
      }
    } else {
      {
#line 913
      fprintf(stdout, "Successfully generated Outfile %s\n", parameters.outfile);
      }
    }
#line 915
    goto switch_break___0;
    case_18: 
    {
#line 918
    __cil_tmp37 = imagetorawl(image, (char const   *)(parameters.outfile));
    }
#line 918
    if (__cil_tmp37) {
      {
#line 919
      fprintf(stdout, "Error generating rawl file. Outfile %s not generated\n", parameters.outfile);
      }
    } else {
      {
#line 922
      fprintf(stdout, "Successfully generated Outfile %s\n", parameters.outfile);
      }
    }
#line 924
    goto switch_break___0;
    case_16: 
    {
#line 927
    __cil_tmp38 = imagetotga(image, (char const   *)(parameters.outfile));
    }
#line 927
    if (__cil_tmp38) {
      {
#line 928
      fprintf(stdout, "Error generating tga file. Outfile %s not generated\n", parameters.outfile);
      }
    } else {
      {
#line 931
      fprintf(stdout, "Successfully generated Outfile %s\n", parameters.outfile);
      }
    }
#line 933
    goto switch_break___0;
    case_17: 
    {
#line 936
    __cil_tmp39 = imagetopng(image, (char const   *)(parameters.outfile));
    }
#line 936
    if (__cil_tmp39) {
      {
#line 937
      fprintf(stdout, "Error generating png file. Outfile %s not generated\n", parameters.outfile);
      }
    } else {
      {
#line 940
      fprintf(stdout, "Successfully generated Outfile %s\n", parameters.outfile);
      }
    }
#line 942
    goto switch_break___0;
    switch_default___0: 
    {
#line 948
    fprintf(stderr, "Outfile %s not generated\n", parameters.outfile);
    }
    switch_break___0: ;
#line 952
    if (l_codec) {
      {
#line 953
      opj_destroy_codec(l_codec);
      }
    }
    {
#line 958
    opj_image_destroy(image);
#line 961
    opj_destroy_cstr_index(& cstr_index);
#line 735
    imageno ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 964
  return (0);
}
}
#line 45 "/root/patron/new_22/src/bin/common/opj_getopt.c"
int opj_opterr  =    1;
#line 46 "/root/patron/new_22/src/bin/common/opj_getopt.c"
int opj_optind  =    1;
#line 53 "/root/patron/new_22/src/bin/common/opj_getopt.c"
static char EMSG[1]  = {      (char )'\250'};
#line 56 "/root/patron/new_22/src/bin/common/opj_getopt.c"
void reset_options_reading(void) 
{ 


  {
#line 57
  opj_opterr = 1;
#line 58
  opj_optind = 1;
#line 59
  return;
}
}
#line 67 "/root/patron/new_22/src/bin/common/opj_getopt.c"
static char *place  ;
#line 65 "/root/patron/new_22/src/bin/common/opj_getopt.c"
int opj_getopt(int nargc , char * const  *nargv , char const   *ostr ) 
{ 
  char *oli ;
  char *__cil_tmp6 ;

  {
#line 67
  place = EMSG;
#line 68
  oli = (char *)((void *)0);
#line 70
  if (opj_optreset) {
    _L: 
#line 71
    opj_optreset = 0;
#line 72
    place = (char *)*(nargv + opj_optind);
#line 72
    if (opj_optind >= nargc) {
#line 73
      place = EMSG;
#line 74
      return (-1);
    } else
#line 72
    if ((int )*place != 45) {
#line 73
      place = EMSG;
#line 74
      return (-1);
    }
#line 76
    place ++;
#line 76
    if ((int )*(place + 1)) {
#line 76
      if ((int )*place == 45) {
#line 77
        opj_optind ++;
#line 78
        place = EMSG;
#line 79
        return (-1);
      }
    }
  } else
#line 70
  if (! *place) {
#line 70
    goto _L;
  }
  {
#line 82
  oli = strchr(ostr, opj_optopt);
#line 82
  __cil_tmp6 = place;
#line 82
  place ++;
#line 82
  opj_optopt = (int )*__cil_tmp6;
  }
#line 82
  if (! oli) {
    _L___57: 
#line 88
    if (opj_optopt == 45) {
#line 89
      return (-1);
    }
#line 90
    if (! *place) {
#line 91
      opj_optind ++;
    }
#line 92
    if (opj_opterr) {
#line 92
      if ((int )*ostr != 58) {
        {
#line 93
        fprintf(stderr, "%s: illegal option -- %c\n", *(nargv + 0), opj_optopt);
        }
#line 95
        return ('?');
      }
    }
  } else
#line 82
  if (opj_optopt == 58) {
#line 82
    goto _L___57;
  }
#line 98
  oli ++;
#line 98
  if ((int )*oli != 58) {
#line 99
    opj_optarg = (char *)((void *)0);
#line 100
    if (! *place) {
#line 101
      opj_optind ++;
    }
  } else {
#line 103
    if (*place) {
#line 104
      opj_optarg = place;
    } else {
#line 105
      opj_optind ++;
#line 105
      if (nargc <= opj_optind) {
#line 106
        place = EMSG;
#line 107
        if ((int )*ostr == 58) {
#line 108
          return (':');
        }
#line 109
        if (opj_opterr) {
          {
#line 110
          fprintf(stderr, "%s: option requires an argument -- %c\n", *(nargv + 0),
                  opj_optopt);
          }
#line 113
          return ('?');
        }
      } else {
#line 116
        opj_optarg = (char *)*(nargv + opj_optind);
      }
    }
#line 117
    place = EMSG;
#line 118
    opj_optind ++;
  }
#line 120
  return (opj_optopt);
}
}
#line 127 "/root/patron/new_22/src/bin/common/opj_getopt.c"
static int lastidx  ;
#line 128 "/root/patron/new_22/src/bin/common/opj_getopt.c"
static int lastofs  ;
#line 124 "/root/patron/new_22/src/bin/common/opj_getopt.c"
int opj_getopt_long(int argc , char * const  *argv , char const   *optstring , opj_option_t *longopts ,
                    int totlen ) 
{ 
  char *tmp ;
  int i ;
  int len ;
  char param ;
  char *arg ;
  opj_option_t *o ;
  unsigned long __cil_tmp15 ;
  int __cil_tmp16 ;
  opj_option_t *__cil_tmp17 ;

  {
#line 129
  param = (char)1;
  again: 
#line 132
  if (! *(argv + opj_optind)) {
#line 133
    return (-1);
  } else
#line 132
  if (opj_optind >= argc) {
#line 133
    return (-1);
  } else
#line 132
  if ((int )*(*(argv + opj_optind)) != 45) {
#line 133
    return (-1);
  }
#line 135
  if ((int )*(*(argv + opj_optind) + 0) == 45) {
#line 135
    if ((int )*(*(argv + opj_optind) + 1) == 0) {
#line 136
      if (opj_optind >= argc - 1) {
#line 137
        param = (char)0;
      } else
#line 140
      if ((int )*(*(argv + (opj_optind + 1)) + 0) == 45) {
#line 141
        param = (char)0;
      } else {
#line 144
        param = (char)2;
      }
    }
  }
#line 149
  if ((int )param == 0) {
#line 150
    opj_optind ++;
#line 151
    return ('?');
  }
#line 154
  if ((int )*(*(argv + opj_optind) + 0) == 45) {
#line 155
    arg = (char *)(*(argv + opj_optind) + 1);
#line 157
    o = longopts;
#line 158
    len = (int )sizeof(*(longopts + 0));
#line 160
    if ((int )param > 1) {
#line 161
      arg = (char *)*(argv + (opj_optind + 1));
#line 162
      opj_optind ++;
    } else {
#line 165
      arg = (char *)(*(argv + opj_optind) + 1);
    }
    {
#line 167
    __cil_tmp15 = strlen((char const   *)arg);
    }
#line 167
    if (__cil_tmp15 > 1UL) {
#line 168
      i = 0;
      {
#line 168
      while (1) {
        while_continue: /* CIL Label */ ;

#line 168
        if (! (i < totlen)) {
#line 168
          goto while_break;
        }
        {
#line 169
        __cil_tmp16 = strcmp(o->name, (char const   *)arg);
        }
#line 169
        if (! __cil_tmp16) {
#line 170
          if (o->has_arg == 0) {
#line 171
            if (*(argv + (opj_optind + 1))) {
#line 171
              if (! ((int )*(*(argv + (opj_optind + 1)) + 0) == 45)) {
                {
#line 172
                fprintf(stderr, "%s: option does not require an argument. Ignoring %s\n",
                        arg, *(argv + (opj_optind + 1)));
#line 173
                opj_optind ++;
                }
              }
            }
          } else {
#line 176
            opj_optarg = (char *)*(argv + (opj_optind + 1));
#line 177
            if (opj_optarg) {
#line 178
              if ((int )*(opj_optarg + 0) == 45) {
#line 179
                if (opj_opterr) {
                  {
#line 180
                  fprintf(stderr, "%s: option requires an argument\n\230\001", arg);
                  }
#line 181
                  return ('?');
                }
              }
            }
#line 185
            if (! opj_optarg) {
#line 185
              if (o->has_arg == 1) {
#line 186
                if (opj_opterr) {
                  {
#line 187
                  fprintf(stderr, "%s: option requires an argument \no\024\213\202U",
                          arg);
                  }
#line 188
                  return ('?');
                }
              }
            }
#line 191
            opj_optind ++;
          }
#line 193
          opj_optind ++;
#line 194
          if (o->flag) {
#line 195
            *(o->flag) = o->val;
          } else {
#line 197
            return (o->val);
          }
#line 198
          return (0);
        }
#line 168
        __cil_tmp17 = o;
#line 168
        o ++;
#line 168
        i += len;
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: 
      {
#line 201
      fprintf(stderr, "Invalid option %s\n\024\213\202U", arg);
#line 202
      opj_optind ++;
      }
#line 203
      return ('?');
    } else {
#line 205
      if ((int )*optstring == 58) {
#line 205
        return (':');
      }
#line 206
      if (lastidx != opj_optind) {
#line 207
        lastidx = opj_optind;
#line 207
        lastofs = 0;
      }
      {
#line 209
      opj_optopt = (int )*(*(argv + opj_optind) + (lastofs + 1));
#line 210
      tmp = strchr(optstring, opj_optopt);
      }
#line 210
      if (tmp) {
#line 211
        if ((int )*tmp == 0) {
#line 212
          opj_optind ++;
#line 213
          goto again;
        }
#line 215
        if ((int )*(tmp + 1) == 58) {
#line 216
          if ((int )*(tmp + 2) == 58) {
            _L: 
#line 217
            opj_optarg = (char *)((*(argv + opj_optind) + lastofs) + 2);
#line 217
            if (! *opj_optarg) {
#line 217
              opj_optarg = (char *)0;
            }
#line 218
            goto found;
          } else
#line 216
          if ((int )*(*(argv + opj_optind) + (lastofs + 2))) {
#line 216
            goto _L;
          }
#line 220
          opj_optarg = (char *)*(argv + (opj_optind + 1));
#line 221
          if (opj_optarg) {
#line 222
            if ((int )*(opj_optarg + 0) == 45) {
#line 223
              if (opj_opterr) {
                {
#line 224
                fprintf(stderr, "%s: option requires an argument\n\230\001", arg);
                }
#line 225
                return ('?');
              }
            }
          }
#line 229
          if (! opj_optarg) {
#line 230
            if (opj_opterr) {
              {
#line 231
              fprintf(stderr, "%s: option requires an argument\n\230\001", arg);
              }
#line 232
              return ('?');
            }
          }
#line 235
          opj_optind ++;
        } else {
#line 237
          lastofs ++;
#line 238
          return (opj_optopt);
        }
        found: 
#line 241
        opj_optind ++;
#line 242
        return (opj_optopt);
      } else {
        {
#line 244
        fprintf(stderr, "Invalid option %s\n", arg);
#line 245
        opj_optind ++;
        }
#line 246
        return ('?');
      }
    }
  }
  {
#line 251
  fprintf(stderr, "Invalid option\n");
#line 252
  opj_optind ++;
  }
#line 253
  return ('?');
}
}
#line 67 "/root/patron/new_22/src/bin/common/color.c"
static void sycc_to_rgb(int offset , int upb , int y , int cb , int cr , int *out_r ,
                        int *out_g , int *out_b ) 
{ 
  int r ;
  int g ;
  int b ;

  {
#line 72
  cb -= offset;
#line 72
  cr -= offset;
#line 73
  r = y + (int )(1.402 * (double )((float )cr));
#line 74
  if (r < 0) {
#line 74
    r = 0;
  } else
#line 74
  if (r > upb) {
#line 74
    r = upb;
  }
#line 74
  *out_r = r;
#line 76
  g = y - (int )(0.344 * (double )((float )cb) + 0.714 * (double )((float )cr));
#line 77
  if (g < 0) {
#line 77
    g = 0;
  } else
#line 77
  if (g > upb) {
#line 77
    g = upb;
  }
#line 77
  *out_g = g;
#line 79
  b = y + (int )(1.77200000001 * (double )((float )cb));
#line 80
  if (b < 0) {
#line 80
    b = 0;
  } else
#line 80
  if (b > upb) {
#line 80
    b = upb;
  }
#line 80
  *out_b = b;
#line 81
  return;
}
}
#line 83 "/root/patron/new_22/src/bin/common/color.c"
static void sycc444_to_rgb(opj_image_t *img ) 
{ 
  int *d0 ;
  int *d1 ;
  int *d2 ;
  int *r ;
  int *g ;
  int *b ;
  int const   *y ;
  int const   *cb ;
  int const   *cr ;
  int maxw ;
  int maxh ;
  int max ;
  int i ;
  int offset ;
  int upb ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;

  {
  {
#line 89
  i = (int )(img->comps + 0)->prec;
#line 90
  offset = 1 << (i - 1);
#line 90
  upb = (1 << i) - 1;
#line 92
  maxw = (int )(img->comps + 0)->w;
#line 92
  maxh = (int )(img->comps + 0)->h;
#line 93
  max = maxw * maxh;
#line 95
  y = (int const   *)(img->comps + 0)->data;
#line 96
  cb = (int const   *)(img->comps + 1)->data;
#line 97
  cr = (int const   *)(img->comps + 2)->data;
#line 99
  __cil_tmp17 = malloc(sizeof(int ) * (unsigned long )max);
#line 99
  r = (int *)__cil_tmp17;
#line 99
  d0 = r;
#line 100
  __cil_tmp18 = malloc(sizeof(int ) * (unsigned long )max);
#line 100
  g = (int *)__cil_tmp18;
#line 100
  d1 = g;
#line 101
  __cil_tmp19 = malloc(sizeof(int ) * (unsigned long )max);
#line 101
  b = (int *)__cil_tmp19;
#line 101
  d2 = b;
#line 103
  i = 0;
  }
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;

#line 103
    if (! (i < max)) {
#line 103
      goto while_break;
    }
    {
#line 105
    sycc_to_rgb(offset, upb, (int )*y, (int )*cb, (int )*cr, r, g, b);
#line 107
    y ++;
#line 107
    cb ++;
#line 107
    cr ++;
#line 107
    r ++;
#line 107
    g ++;
#line 107
    b ++;
#line 103
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 109
  free((void *)(img->comps + 0)->data);
#line 109
  (img->comps + 0)->data = d0;
#line 110
  free((void *)(img->comps + 1)->data);
#line 110
  (img->comps + 1)->data = d1;
#line 111
  free((void *)(img->comps + 2)->data);
#line 111
  (img->comps + 2)->data = d2;
  }
#line 113
  return;
}
}
#line 115 "/root/patron/new_22/src/bin/common/color.c"
static void sycc422_to_rgb(opj_image_t *img ) 
{ 
  int *d0 ;
  int *d1 ;
  int *d2 ;
  int *r ;
  int *g ;
  int *b ;
  int const   *y ;
  int const   *cb ;
  int const   *cr ;
  int maxw ;
  int maxh ;
  int max ;
  int offset ;
  int upb ;
  int i ;
  int j ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;

  {
  {
#line 122
  i = (int )(img->comps + 0)->prec;
#line 123
  offset = 1 << (i - 1);
#line 123
  upb = (1 << i) - 1;
#line 125
  maxw = (int )(img->comps + 0)->w;
#line 125
  maxh = (int )(img->comps + 0)->h;
#line 126
  max = maxw * maxh;
#line 128
  y = (int const   *)(img->comps + 0)->data;
#line 129
  cb = (int const   *)(img->comps + 1)->data;
#line 130
  cr = (int const   *)(img->comps + 2)->data;
#line 132
  __cil_tmp18 = malloc(sizeof(int ) * (unsigned long )max);
#line 132
  r = (int *)__cil_tmp18;
#line 132
  d0 = r;
#line 133
  __cil_tmp19 = malloc(sizeof(int ) * (unsigned long )max);
#line 133
  g = (int *)__cil_tmp19;
#line 133
  d1 = g;
#line 134
  __cil_tmp20 = malloc(sizeof(int ) * (unsigned long )max);
#line 134
  b = (int *)__cil_tmp20;
#line 134
  d2 = b;
#line 136
  i = 0;
  }
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;

#line 136
    if (! (i < maxh)) {
#line 136
      goto while_break;
    }
#line 138
    j = 0;
    {
#line 138
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 138
      if (! (j < maxw)) {
#line 138
        goto while_break___0;
      }
      {
#line 140
      sycc_to_rgb(offset, upb, (int )*y, (int )*cb, (int )*cr, r, g, b);
#line 142
      y ++;
#line 142
      r ++;
#line 142
      g ++;
#line 142
      b ++;
#line 144
      sycc_to_rgb(offset, upb, (int )*y, (int )*cb, (int )*cr, r, g, b);
#line 146
      y ++;
#line 146
      r ++;
#line 146
      g ++;
#line 146
      b ++;
#line 146
      cb ++;
#line 146
      cr ++;
#line 138
      j += 2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 136
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 149
  free((void *)(img->comps + 0)->data);
#line 149
  (img->comps + 0)->data = d0;
#line 150
  free((void *)(img->comps + 1)->data);
#line 150
  (img->comps + 1)->data = d1;
#line 151
  free((void *)(img->comps + 2)->data);
#line 151
  (img->comps + 2)->data = d2;
#line 153
  (img->comps + 1)->w = (OPJ_UINT32 )maxw;
#line 153
  (img->comps + 1)->h = (OPJ_UINT32 )maxh;
#line 154
  (img->comps + 2)->w = (OPJ_UINT32 )maxw;
#line 154
  (img->comps + 2)->h = (OPJ_UINT32 )maxh;
#line 155
  (img->comps + 1)->dx = (img->comps + 0)->dx;
#line 156
  (img->comps + 2)->dx = (img->comps + 0)->dx;
#line 157
  (img->comps + 1)->dy = (img->comps + 0)->dy;
#line 158
  (img->comps + 2)->dy = (img->comps + 0)->dy;
  }
#line 160
  return;
}
}
#line 162 "/root/patron/new_22/src/bin/common/color.c"
static void sycc420_to_rgb(opj_image_t *img ) 
{ 
  int *d0 ;
  int *d1 ;
  int *d2 ;
  int *r ;
  int *g ;
  int *b ;
  int *nr ;
  int *ng ;
  int *nb ;
  int const   *y ;
  int const   *cb ;
  int const   *cr ;
  int const   *ny ;
  int maxw ;
  int maxh ;
  int max ;
  int offset ;
  int upb ;
  int i ;
  int j ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;

  {
  {
#line 169
  i = (int )(img->comps + 0)->prec;
#line 170
  offset = 1 << (i - 1);
#line 170
  upb = (1 << i) - 1;
#line 172
  maxw = (int )(img->comps + 0)->w;
#line 172
  maxh = (int )(img->comps + 0)->h;
#line 173
  max = maxw * maxh;
#line 175
  y = (int const   *)(img->comps + 0)->data;
#line 176
  cb = (int const   *)(img->comps + 1)->data;
#line 177
  cr = (int const   *)(img->comps + 2)->data;
#line 179
  __cil_tmp22 = malloc(sizeof(int ) * (unsigned long )max);
#line 179
  r = (int *)__cil_tmp22;
#line 179
  d0 = r;
#line 180
  __cil_tmp23 = malloc(sizeof(int ) * (unsigned long )max);
#line 180
  g = (int *)__cil_tmp23;
#line 180
  d1 = g;
#line 181
  __cil_tmp24 = malloc(sizeof(int ) * (unsigned long )max);
#line 181
  b = (int *)__cil_tmp24;
#line 181
  d2 = b;
#line 183
  i = 0;
  }
  {
#line 183
  while (1) {
    while_continue: /* CIL Label */ ;

#line 183
    if (! (i < maxh)) {
#line 183
      goto while_break;
    }
#line 185
    ny = y + maxw;
#line 186
    nr = r + maxw;
#line 186
    ng = g + maxw;
#line 186
    nb = b + maxw;
#line 188
    j = 0;
    {
#line 188
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 188
      if (! (j < maxw)) {
#line 188
        goto while_break___0;
      }
      {
#line 190
      sycc_to_rgb(offset, upb, (int )*y, (int )*cb, (int )*cr, r, g, b);
#line 192
      y ++;
#line 192
      r ++;
#line 192
      g ++;
#line 192
      b ++;
#line 194
      sycc_to_rgb(offset, upb, (int )*y, (int )*cb, (int )*cr, r, g, b);
#line 196
      y ++;
#line 196
      r ++;
#line 196
      g ++;
#line 196
      b ++;
#line 198
      sycc_to_rgb(offset, upb, (int )*ny, (int )*cb, (int )*cr, nr, ng, nb);
#line 200
      ny ++;
#line 200
      nr ++;
#line 200
      ng ++;
#line 200
      nb ++;
#line 202
      sycc_to_rgb(offset, upb, (int )*ny, (int )*cb, (int )*cr, nr, ng, nb);
#line 204
      ny ++;
#line 204
      nr ++;
#line 204
      ng ++;
#line 204
      nb ++;
#line 204
      cb ++;
#line 204
      cr ++;
#line 188
      j += 2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: 
#line 206
    y += maxw;
#line 206
    r += maxw;
#line 206
    g += maxw;
#line 206
    b += maxw;
#line 183
    i += 2;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 208
  free((void *)(img->comps + 0)->data);
#line 208
  (img->comps + 0)->data = d0;
#line 209
  free((void *)(img->comps + 1)->data);
#line 209
  (img->comps + 1)->data = d1;
#line 210
  free((void *)(img->comps + 2)->data);
#line 210
  (img->comps + 2)->data = d2;
#line 212
  (img->comps + 1)->w = (OPJ_UINT32 )maxw;
#line 212
  (img->comps + 1)->h = (OPJ_UINT32 )maxh;
#line 213
  (img->comps + 2)->w = (OPJ_UINT32 )maxw;
#line 213
  (img->comps + 2)->h = (OPJ_UINT32 )maxh;
#line 214
  (img->comps + 1)->dx = (img->comps + 0)->dx;
#line 215
  (img->comps + 2)->dx = (img->comps + 0)->dx;
#line 216
  (img->comps + 1)->dy = (img->comps + 0)->dy;
#line 217
  (img->comps + 2)->dy = (img->comps + 0)->dy;
  }
#line 219
  return;
}
}
#line 221 "/root/patron/new_22/src/bin/common/color.c"
void color_sycc_to_rgb(opj_image_t *img ) 
{ 


  {
#line 223
  if (img->numcomps < 3U) {
#line 225
    img->color_space = (OPJ_COLOR_SPACE )2;
#line 226
    return;
  }
#line 229
  if ((img->comps + 0)->dx == 1U) {
#line 229
    if ((img->comps + 1)->dx == 2U) {
#line 229
      if ((img->comps + 2)->dx == 2U) {
#line 229
        if ((img->comps + 0)->dy == 1U) {
#line 229
          if ((img->comps + 1)->dy == 2U) {
#line 229
            if ((img->comps + 2)->dy == 2U) {
              {
#line 236
              sycc420_to_rgb(img);
              }
            } else {
#line 229
              goto _L___62;
            }
          } else {
#line 229
            goto _L___62;
          }
        } else {
#line 229
          goto _L___62;
        }
      } else {
#line 229
        goto _L___62;
      }
    } else {
#line 229
      goto _L___62;
    }
  } else
  _L___62: 
#line 239
  if ((img->comps + 0)->dx == 1U) {
#line 239
    if ((img->comps + 1)->dx == 2U) {
#line 239
      if ((img->comps + 2)->dx == 2U) {
#line 239
        if ((img->comps + 0)->dy == 1U) {
#line 239
          if ((img->comps + 1)->dy == 1U) {
#line 239
            if ((img->comps + 2)->dy == 1U) {
              {
#line 246
              sycc422_to_rgb(img);
              }
            } else {
#line 239
              goto _L;
            }
          } else {
#line 239
            goto _L;
          }
        } else {
#line 239
          goto _L;
        }
      } else {
#line 239
        goto _L;
      }
    } else {
#line 239
      goto _L;
    }
  } else
  _L: 
#line 249
  if ((img->comps + 0)->dx == 1U) {
#line 249
    if ((img->comps + 1)->dx == 1U) {
#line 249
      if ((img->comps + 2)->dx == 1U) {
#line 249
        if ((img->comps + 0)->dy == 1U) {
#line 249
          if ((img->comps + 1)->dy == 1U) {
#line 249
            if ((img->comps + 2)->dy == 1U) {
              {
#line 256
              sycc444_to_rgb(img);
              }
            } else {
              {
#line 260
              fprintf(stderr, "%s:%d:color_sycc_to_rgb\n\tCAN NOT CONVERT\n", "/root/patron/new_22/src/bin/common/color.c",
                      261);
              }
#line 262
              return;
            }
          } else {
            {
#line 260
            fprintf(stderr, "%s:%d:color_sycc_to_rgb\n\tCAN NOT CONVERT\n", "/root/patron/new_22/src/bin/common/color.c",
                    261);
            }
#line 262
            return;
          }
        } else {
          {
#line 260
          fprintf(stderr, "%s:%d:color_sycc_to_rgb\n\tCAN NOT CONVERT\n", "/root/patron/new_22/src/bin/common/color.c",
                  261);
          }
#line 262
          return;
        }
      } else {
        {
#line 260
        fprintf(stderr, "%s:%d:color_sycc_to_rgb\n\tCAN NOT CONVERT\n", "/root/patron/new_22/src/bin/common/color.c",
                261);
        }
#line 262
        return;
      }
    } else {
      {
#line 260
      fprintf(stderr, "%s:%d:color_sycc_to_rgb\n\tCAN NOT CONVERT\n", "/root/patron/new_22/src/bin/common/color.c",
              261);
      }
#line 262
      return;
    }
  } else {
    {
#line 260
    fprintf(stderr, "%s:%d:color_sycc_to_rgb\n\tCAN NOT CONVERT\n", "/root/patron/new_22/src/bin/common/color.c",
            261);
    }
#line 262
    return;
  }
#line 264
  img->color_space = (OPJ_COLOR_SPACE )1;
#line 265
  return;
}
}
