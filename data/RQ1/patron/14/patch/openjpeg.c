/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 38 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __uint8_t;
#line 39 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef short __int16_t;
#line 40 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __uint16_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __int32_t;
#line 42 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uint32_t;
#line 44 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __int64_t;
#line 45 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uint64_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 152 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 196 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 216 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stddef.h"
typedef unsigned long size_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 53 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
#line 97 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __anonstruct_3 {
   unsigned int __low ;
   unsigned int __high ;
};
#line 94 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
union __anonunion_2 {
   unsigned long long __wseq ;
   struct __anonstruct_3 __wseq32 ;
};
#line 106 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __anonstruct_5 {
   unsigned int __low ;
   unsigned int __high ;
};
#line 103 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
union __anonunion_4 {
   unsigned long long __g1_start ;
   struct __anonstruct_5 __g1_start32 ;
};
#line 92 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_cond_s {
   union __anonunion_2 __annonCompField1 ;
   unsigned long long __wseq ;
   struct __anonstruct_3 __wseq32 ;
   union __anonunion_4 __annonCompField2 ;
   unsigned long long __g1_start ;
   struct __anonstruct_5 __g1_start32 ;
   unsigned int __g_refs[2] ;
   unsigned int __g_size[2] ;
   unsigned int __g1_orig_size ;
   unsigned int __wrefs ;
   unsigned int __g_signals[2] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_6 {
   char __size[4] ;
   int __align ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_6 pthread_mutexattr_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_7 {
   char __size[4] ;
   int __align ;
};
#line 45 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_7 pthread_condattr_t;
#line 56 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union pthread_attr_t pthread_attr_t;
#line 67 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_8 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 72 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_8 pthread_mutex_t;
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_9 {
   struct __pthread_cond_s __data ;
   char __size[48] ;
   long long __align ;
};
#line 80 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_9 pthread_cond_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 718 "/usr/include/pthread.h"
struct __jmp_buf_tag ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int16_t int16_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int32_t int32_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int64_t int64_t;
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
struct __anonstruct_30 {
   unsigned long __val[16] ;
};
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
typedef struct __anonstruct_30 __sigset_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE ;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_marker ;
#line 37
struct _IO_codecvt ;
#line 38
struct _IO_wide_data ;
#line 43 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
typedef void _IO_lock_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[20] ;
};
#line 52 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 110 "/root/patron-new/39/src/lib/openjp2/openjpeg.h"
typedef int OPJ_BOOL;
#line 114 "/root/patron-new/39/src/lib/openjp2/openjpeg.h"
typedef char OPJ_CHAR;
#line 115 "/root/patron-new/39/src/lib/openjp2/openjpeg.h"
typedef float OPJ_FLOAT32;
#line 116 "/root/patron-new/39/src/lib/openjp2/openjpeg.h"
typedef double OPJ_FLOAT64;
#line 117 "/root/patron-new/39/src/lib/openjp2/openjpeg.h"
typedef unsigned char OPJ_BYTE;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint8_t uint8_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint16_t uint16_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint32_t uint32_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint64_t uint64_t;
#line 122 "/root/patron-new/39/src/lib/openjp2/openjpeg.h"
typedef uint8_t OPJ_UINT8;
#line 123 "/root/patron-new/39/src/lib/openjp2/openjpeg.h"
typedef int16_t OPJ_INT16;
#line 124 "/root/patron-new/39/src/lib/openjp2/openjpeg.h"
typedef uint16_t OPJ_UINT16;
#line 125 "/root/patron-new/39/src/lib/openjp2/openjpeg.h"
typedef int32_t OPJ_INT32;
#line 126 "/root/patron-new/39/src/lib/openjp2/openjpeg.h"
typedef uint32_t OPJ_UINT32;
#line 127 "/root/patron-new/39/src/lib/openjp2/openjpeg.h"
typedef int64_t OPJ_INT64;
#line 128 "/root/patron-new/39/src/lib/openjp2/openjpeg.h"
typedef uint64_t OPJ_UINT64;
#line 130 "/root/patron-new/39/src/lib/openjp2/openjpeg.h"
typedef int64_t OPJ_OFF_T;
#line 133 "/root/patron-new/39/src/lib/openjp2/openjpeg.h"
typedef size_t OPJ_SIZE_T;
#line 276
enum RSIZ_CAPABILITIES {
    OPJ_STD_RSIZ = 0,
    OPJ_CINEMA2K = 3,
    OPJ_CINEMA4K = 4,
    OPJ_MCT = 33024
} ;
#line 281 "/root/patron-new/39/src/lib/openjp2/openjpeg.h"
typedef enum RSIZ_CAPABILITIES OPJ_RSIZ_CAPABILITIES;
#line 287
enum CINEMA_MODE {
    OPJ_OFF = 0,
    OPJ_CINEMA2K_24 = 1,
    OPJ_CINEMA2K_48 = 2,
    OPJ_CINEMA4K_24 = 3
} ;
#line 292 "/root/patron-new/39/src/lib/openjp2/openjpeg.h"
typedef enum CINEMA_MODE OPJ_CINEMA_MODE;
#line 297
enum PROG_ORDER {
    OPJ_PROG_UNKNOWN = -1,
    OPJ_LRCP = 0,
    OPJ_RLCP = 1,
    OPJ_RPCL = 2,
    OPJ_PCRL = 3,
    OPJ_CPRL = 4
} ;
#line 304 "/root/patron-new/39/src/lib/openjp2/openjpeg.h"
typedef enum PROG_ORDER OPJ_PROG_ORDER;
#line 309
enum COLOR_SPACE {
    OPJ_CLRSPC_UNKNOWN = -1,
    OPJ_CLRSPC_UNSPECIFIED = 0,
    OPJ_CLRSPC_SRGB = 1,
    OPJ_CLRSPC_GRAY = 2,
    OPJ_CLRSPC_SYCC = 3,
    OPJ_CLRSPC_EYCC = 4,
    OPJ_CLRSPC_CMYK = 5
} ;
#line 317 "/root/patron-new/39/src/lib/openjp2/openjpeg.h"
typedef enum COLOR_SPACE OPJ_COLOR_SPACE;
#line 322
enum CODEC_FORMAT {
    OPJ_CODEC_UNKNOWN = -1,
    OPJ_CODEC_J2K = 0,
    OPJ_CODEC_JPT = 1,
    OPJ_CODEC_JP2 = 2,
    OPJ_CODEC_JPP = 3,
    OPJ_CODEC_JPX = 4
} ;
#line 329 "/root/patron-new/39/src/lib/openjp2/openjpeg.h"
typedef enum CODEC_FORMAT OPJ_CODEC_FORMAT;
#line 359 "/root/patron-new/39/src/lib/openjp2/openjpeg.h"
struct opj_poc {
   OPJ_UINT32 resno0 ;
   OPJ_UINT32 compno0 ;
   OPJ_UINT32 layno1 ;
   OPJ_UINT32 resno1 ;
   OPJ_UINT32 compno1 ;
   OPJ_UINT32 layno0 ;
   OPJ_UINT32 precno0 ;
   OPJ_UINT32 precno1 ;
   OPJ_PROG_ORDER prg1 ;
   OPJ_PROG_ORDER prg ;
   OPJ_CHAR progorder[5] ;
   OPJ_UINT32 tile ;
   OPJ_INT32 tx0 ;
   OPJ_INT32 tx1 ;
   OPJ_INT32 ty0 ;
   OPJ_INT32 ty1 ;
   OPJ_UINT32 layS ;
   OPJ_UINT32 resS ;
   OPJ_UINT32 compS ;
   OPJ_UINT32 prcS ;
   OPJ_UINT32 layE ;
   OPJ_UINT32 resE ;
   OPJ_UINT32 compE ;
   OPJ_UINT32 prcE ;
   OPJ_UINT32 txS ;
   OPJ_UINT32 txE ;
   OPJ_UINT32 tyS ;
   OPJ_UINT32 tyE ;
   OPJ_UINT32 dx ;
   OPJ_UINT32 dy ;
   OPJ_UINT32 lay_t ;
   OPJ_UINT32 res_t ;
   OPJ_UINT32 comp_t ;
   OPJ_UINT32 prc_t ;
   OPJ_UINT32 tx0_t ;
   OPJ_UINT32 ty0_t ;
};
#line 382 "/root/patron-new/39/src/lib/openjp2/openjpeg.h"
typedef struct opj_poc opj_poc_t;
#line 387 "/root/patron-new/39/src/lib/openjp2/openjpeg.h"
struct opj_cparameters {
   OPJ_BOOL tile_size_on ;
   int cp_tx0 ;
   int cp_ty0 ;
   int cp_tdx ;
   int cp_tdy ;
   int cp_disto_alloc ;
   int cp_fixed_alloc ;
   int cp_fixed_quality ;
   int *cp_matrice ;
   char *cp_comment ;
   int csty ;
   OPJ_PROG_ORDER prog_order ;
   opj_poc_t POC[32] ;
   OPJ_UINT32 numpocs ;
   int tcp_numlayers ;
   float tcp_rates[100] ;
   float tcp_distoratio[100] ;
   int numresolution ;
   int cblockw_init ;
   int cblockh_init ;
   int mode ;
   int irreversible ;
   int roi_compno ;
   int roi_shift ;
   int res_spec ;
   int prcw_init[33] ;
   int prch_init[33] ;
   char infile[4096] ;
   char outfile[4096] ;
   int index_on ;
   char index[4096] ;
   int image_offset_x0 ;
   int image_offset_y0 ;
   int subsampling_dx ;
   int subsampling_dy ;
   int decod_format ;
   int cod_format ;
   OPJ_BOOL jpwl_epc_on ;
   int jpwl_hprot_MH ;
   int jpwl_hprot_TPH_tileno[16] ;
   int jpwl_hprot_TPH[16] ;
   int jpwl_pprot_tileno[16] ;
   int jpwl_pprot_packno[16] ;
   int jpwl_pprot[16] ;
   int jpwl_sens_size ;
   int jpwl_sens_addr ;
   int jpwl_sens_range ;
   int jpwl_sens_MH ;
   int jpwl_sens_TPH_tileno[16] ;
   int jpwl_sens_TPH[16] ;
   OPJ_CINEMA_MODE cp_cinema ;
   int max_comp_size ;
   OPJ_RSIZ_CAPABILITIES cp_rsiz ;
   char tp_on ;
   char tp_flag ;
   char tcp_mct ;
   OPJ_BOOL jpip_on ;
   void *mct_data ;
   int max_cs_size ;
   OPJ_UINT16 rsiz ;
};
#line 538 "/root/patron-new/39/src/lib/openjp2/openjpeg.h"
typedef struct opj_cparameters opj_cparameters_t;
#line 546 "/root/patron-new/39/src/lib/openjp2/openjpeg.h"
struct opj_dparameters {
   OPJ_UINT32 cp_reduce ;
   OPJ_UINT32 cp_layer ;
   char infile[4096] ;
   char outfile[4096] ;
   int decod_format ;
   int cod_format ;
   OPJ_UINT32 DA_x0 ;
   OPJ_UINT32 DA_x1 ;
   OPJ_UINT32 DA_y0 ;
   OPJ_UINT32 DA_y1 ;
   OPJ_BOOL m_verbose ;
   OPJ_UINT32 tile_index ;
   OPJ_UINT32 nb_tile_to_decode ;
   OPJ_BOOL jpwl_correct ;
   int jpwl_exp_comps ;
   int jpwl_max_tiles ;
   unsigned int flags ;
};
#line 606 "/root/patron-new/39/src/lib/openjp2/openjpeg.h"
typedef struct opj_dparameters opj_dparameters_t;
#line 612 "/root/patron-new/39/src/lib/openjp2/openjpeg.h"
typedef void *opj_codec_t;
#line 660 "/root/patron-new/39/src/lib/openjp2/openjpeg.h"
typedef void *opj_stream_t;
#line 671 "/root/patron-new/39/src/lib/openjp2/openjpeg.h"
struct opj_image_comp {
   OPJ_UINT32 dx ;
   OPJ_UINT32 dy ;
   OPJ_UINT32 w ;
   OPJ_UINT32 h ;
   OPJ_UINT32 x0 ;
   OPJ_UINT32 y0 ;
   OPJ_UINT32 prec ;
   OPJ_UINT32 bpp ;
   OPJ_UINT32 sgnd ;
   OPJ_UINT32 resno_decoded ;
   OPJ_UINT32 factor ;
   OPJ_INT32 *data ;
   OPJ_UINT16 alpha ;
};
#line 698 "/root/patron-new/39/src/lib/openjp2/openjpeg.h"
typedef struct opj_image_comp opj_image_comp_t;
#line 703 "/root/patron-new/39/src/lib/openjp2/openjpeg.h"
struct opj_image {
   OPJ_UINT32 x0 ;
   OPJ_UINT32 y0 ;
   OPJ_UINT32 x1 ;
   OPJ_UINT32 y1 ;
   OPJ_UINT32 numcomps ;
   OPJ_COLOR_SPACE color_space ;
   opj_image_comp_t *comps ;
   OPJ_BYTE *icc_profile_buf ;
   OPJ_UINT32 icc_profile_len ;
};
#line 722 "/root/patron-new/39/src/lib/openjp2/openjpeg.h"
typedef struct opj_image opj_image_t;
#line 728 "/root/patron-new/39/src/lib/openjp2/openjpeg.h"
struct opj_image_comptparm {
   OPJ_UINT32 dx ;
   OPJ_UINT32 dy ;
   OPJ_UINT32 w ;
   OPJ_UINT32 h ;
   OPJ_UINT32 x0 ;
   OPJ_UINT32 y0 ;
   OPJ_UINT32 prec ;
   OPJ_UINT32 bpp ;
   OPJ_UINT32 sgnd ;
};
#line 747 "/root/patron-new/39/src/lib/openjp2/openjpeg.h"
typedef struct opj_image_comptparm opj_image_cmptparm_t;
#line 760 "/root/patron-new/39/src/lib/openjp2/openjpeg.h"
struct opj_packet_info {
   OPJ_OFF_T start_pos ;
   OPJ_OFF_T end_ph_pos ;
   OPJ_OFF_T end_pos ;
   double disto ;
};
#line 769 "/root/patron-new/39/src/lib/openjp2/openjpeg.h"
typedef struct opj_packet_info opj_packet_info_t;
#line 776 "/root/patron-new/39/src/lib/openjp2/openjpeg.h"
struct opj_marker_info {
   unsigned short type ;
   OPJ_OFF_T pos ;
   int len ;
};
#line 783 "/root/patron-new/39/src/lib/openjp2/openjpeg.h"
typedef struct opj_marker_info opj_marker_info_t;
#line 789 "/root/patron-new/39/src/lib/openjp2/openjpeg.h"
struct opj_tp_info {
   int tp_start_pos ;
   int tp_end_header ;
   int tp_end_pos ;
   int tp_start_pack ;
   int tp_numpacks ;
};
#line 800 "/root/patron-new/39/src/lib/openjp2/openjpeg.h"
typedef struct opj_tp_info opj_tp_info_t;
#line 805 "/root/patron-new/39/src/lib/openjp2/openjpeg.h"
struct opj_tile_info {
   double *thresh ;
   int tileno ;
   int start_pos ;
   int end_header ;
   int end_pos ;
   int pw[33] ;
   int ph[33] ;
   int pdx[33] ;
   int pdy[33] ;
   opj_packet_info_t *packet ;
   int numpix ;
   double distotile ;
   int marknum ;
   opj_marker_info_t *marker ;
   int maxmarknum ;
   int num_tps ;
   opj_tp_info_t *tp ;
};
#line 840 "/root/patron-new/39/src/lib/openjp2/openjpeg.h"
typedef struct opj_tile_info opj_tile_info_t;
#line 845 "/root/patron-new/39/src/lib/openjp2/openjpeg.h"
struct opj_codestream_info {
   double D_max ;
   int packno ;
   int index_write ;
   int image_w ;
   int image_h ;
   OPJ_PROG_ORDER prog ;
   int tile_x ;
   int tile_y ;
   int tile_Ox ;
   int tile_Oy ;
   int tw ;
   int th ;
   int numcomps ;
   int numlayers ;
   int *numdecompos ;
   int marknum ;
   opj_marker_info_t *marker ;
   int maxmarknum ;
   int main_head_start ;
   int main_head_end ;
   int codestream_size ;
   opj_tile_info_t *tile ;
};
#line 892 "/root/patron-new/39/src/lib/openjp2/openjpeg.h"
typedef struct opj_codestream_info opj_codestream_info_t;
#line 900 "/root/patron-new/39/src/lib/openjp2/openjpeg.h"
struct opj_tccp_info {
   OPJ_UINT32 compno ;
   OPJ_UINT32 csty ;
   OPJ_UINT32 numresolutions ;
   OPJ_UINT32 cblkw ;
   OPJ_UINT32 cblkh ;
   OPJ_UINT32 cblksty ;
   OPJ_UINT32 qmfbid ;
   OPJ_UINT32 qntsty ;
   OPJ_UINT32 stepsizes_mant[97] ;
   OPJ_UINT32 stepsizes_expn[97] ;
   OPJ_UINT32 numgbits ;
   OPJ_INT32 roishift ;
   OPJ_UINT32 prcw[33] ;
   OPJ_UINT32 prch[33] ;
};
#line 930 "/root/patron-new/39/src/lib/openjp2/openjpeg.h"
typedef struct opj_tccp_info opj_tccp_info_t;
#line 935 "/root/patron-new/39/src/lib/openjp2/openjpeg.h"
struct opj_tile_v2_info {
   int tileno ;
   OPJ_UINT32 csty ;
   OPJ_PROG_ORDER prg ;
   OPJ_UINT32 numlayers ;
   OPJ_UINT32 mct ;
   opj_tccp_info_t *tccp_info ;
};
#line 951 "/root/patron-new/39/src/lib/openjp2/openjpeg.h"
typedef struct opj_tile_v2_info opj_tile_info_v2_t;
#line 956 "/root/patron-new/39/src/lib/openjp2/openjpeg.h"
struct opj_codestream_info_v2 {
   OPJ_UINT32 tx0 ;
   OPJ_UINT32 ty0 ;
   OPJ_UINT32 tdx ;
   OPJ_UINT32 tdy ;
   OPJ_UINT32 tw ;
   OPJ_UINT32 th ;
   OPJ_UINT32 nbcomps ;
   opj_tile_info_v2_t m_default_tile_info ;
   opj_tile_info_v2_t *tile_info ;
};
#line 980 "/root/patron-new/39/src/lib/openjp2/openjpeg.h"
typedef struct opj_codestream_info_v2 opj_codestream_info_v2_t;
#line 986 "/root/patron-new/39/src/lib/openjp2/openjpeg.h"
struct opj_tp_index {
   OPJ_OFF_T start_pos ;
   OPJ_OFF_T end_header ;
   OPJ_OFF_T end_pos ;
};
#line 994 "/root/patron-new/39/src/lib/openjp2/openjpeg.h"
typedef struct opj_tp_index opj_tp_index_t;
#line 999 "/root/patron-new/39/src/lib/openjp2/openjpeg.h"
struct opj_tile_index {
   OPJ_UINT32 tileno ;
   OPJ_UINT32 nb_tps ;
   OPJ_UINT32 current_nb_tps ;
   OPJ_UINT32 current_tpsno ;
   opj_tp_index_t *tp_index ;
   OPJ_UINT32 marknum ;
   opj_marker_info_t *marker ;
   OPJ_UINT32 maxmarknum ;
   OPJ_UINT32 nb_packet ;
   opj_packet_info_t *packet_index ;
};
#line 1026 "/root/patron-new/39/src/lib/openjp2/openjpeg.h"
typedef struct opj_tile_index opj_tile_index_t;
#line 1031 "/root/patron-new/39/src/lib/openjp2/openjpeg.h"
struct opj_codestream_index {
   OPJ_OFF_T main_head_start ;
   OPJ_OFF_T main_head_end ;
   OPJ_UINT64 codestream_size ;
   OPJ_UINT32 marknum ;
   opj_marker_info_t *marker ;
   OPJ_UINT32 maxmarknum ;
   OPJ_UINT32 nb_of_tiles ;
   opj_tile_index_t *tile_index ;
};
#line 1054 "/root/patron-new/39/src/lib/openjp2/openjpeg.h"
typedef struct opj_codestream_index opj_codestream_index_t;
#line 217 "/root/patron-new/39/src/lib/openjp2/opj_includes.h"
typedef unsigned int OPJ_BITFIELD;
#line 149 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stddef.h"
typedef long ptrdiff_t;
#line 50 "/root/patron-new/39/src/lib/openjp2/event.h"
struct opj_event_mgr {
   void *m_error_data ;
   void *m_warning_data ;
   void *m_info_data ;
   void (*error_handler)(char const   * , void * ) ;
   void (*warning_handler)(char const   * , void * ) ;
   void (*info_handler)(char const   * , void * ) ;
};
#line 63 "/root/patron-new/39/src/lib/openjp2/event.h"
typedef struct opj_event_mgr opj_event_mgr_t;
#line 52 "/root/patron-new/39/src/lib/openjp2/function_list.h"
typedef void (*opj_procedure)(void);
#line 57 "/root/patron-new/39/src/lib/openjp2/function_list.h"
struct opj_procedure_list {
   OPJ_UINT32 m_nb_procedures ;
   OPJ_UINT32 m_nb_max_procedures ;
   opj_procedure *m_procedures ;
};
#line 71 "/root/patron-new/39/src/lib/openjp2/function_list.h"
typedef struct opj_procedure_list opj_procedure_list_t;
#line 56 "/root/patron-new/39/src/lib/openjp2/bio.h"
struct opj_bio {
   OPJ_BYTE *start ;
   OPJ_BYTE *end ;
   OPJ_BYTE *bp ;
   OPJ_UINT32 buf ;
   OPJ_UINT32 ct ;
};
#line 67 "/root/patron-new/39/src/lib/openjp2/bio.h"
typedef struct opj_bio opj_bio_t;
#line 81 "/root/patron-new/39/src/lib/openjp2/cio.h"
struct opj_stream_private {
   void *m_user_data ;
   void (*m_free_user_data_fn)(void * ) ;
   OPJ_UINT64 m_user_data_length ;
   OPJ_SIZE_T (*m_read_fn)(void * , OPJ_SIZE_T  , void * ) ;
   OPJ_SIZE_T (*m_write_fn)(void * , OPJ_SIZE_T  , void * ) ;
   OPJ_OFF_T (*m_skip_fn)(OPJ_OFF_T  , void * ) ;
   OPJ_BOOL (*m_seek_fn)(OPJ_OFF_T  , void * ) ;
   OPJ_BYTE *m_stored_data ;
   OPJ_BYTE *m_current_data ;
   OPJ_OFF_T (*m_opj_skip)(struct opj_stream_private * , OPJ_OFF_T  , struct opj_event_mgr * ) ;
   OPJ_BOOL (*m_opj_seek)(struct opj_stream_private * , OPJ_OFF_T  , struct opj_event_mgr * ) ;
   OPJ_SIZE_T m_bytes_in_buffer ;
   OPJ_OFF_T m_byte_offset ;
   OPJ_SIZE_T m_buffer_size ;
   OPJ_UINT32 m_status ;
};
#line 165 "/root/patron-new/39/src/lib/openjp2/cio.h"
typedef struct opj_stream_private opj_stream_private_t;
#line 52 "/root/patron-new/39/src/lib/openjp2/thread.h"
struct opj_mutex_t ;
#line 52 "/root/patron-new/39/src/lib/openjp2/thread.h"
typedef struct opj_mutex_t opj_mutex_t;
#line 81
struct opj_cond_t ;
#line 81 "/root/patron-new/39/src/lib/openjp2/thread.h"
typedef struct opj_cond_t opj_cond_t;
#line 141
struct opj_thread_t ;
#line 141 "/root/patron-new/39/src/lib/openjp2/thread.h"
typedef struct opj_thread_t opj_thread_t;
#line 167
struct opj_tls_t ;
#line 167 "/root/patron-new/39/src/lib/openjp2/thread.h"
typedef struct opj_tls_t opj_tls_t;
#line 195
struct opj_thread_pool_t ;
#line 195 "/root/patron-new/39/src/lib/openjp2/thread.h"
typedef struct opj_thread_pool_t opj_thread_pool_t;
#line 41 "/root/patron-new/39/src/lib/openjp2/image.h"
struct opj_cp ;
#line 136 "/root/patron-new/39/src/lib/openjp2/j2k.h"
enum MCT_ELEMENT_TYPE {
    MCT_TYPE_INT16 = 0,
    MCT_TYPE_INT32 = 1,
    MCT_TYPE_FLOAT = 2,
    MCT_TYPE_DOUBLE = 3
} ;
#line 141 "/root/patron-new/39/src/lib/openjp2/j2k.h"
typedef enum MCT_ELEMENT_TYPE J2K_MCT_ELEMENT_TYPE;
#line 146
enum MCT_ARRAY_TYPE {
    MCT_TYPE_DEPENDENCY = 0,
    MCT_TYPE_DECORRELATION = 1,
    MCT_TYPE_OFFSET = 2
} ;
#line 150 "/root/patron-new/39/src/lib/openjp2/j2k.h"
typedef enum MCT_ARRAY_TYPE J2K_MCT_ARRAY_TYPE;
#line 157
enum T2_MODE {
    THRESH_CALC = 0,
    FINAL_PASS = 1
} ;
#line 160 "/root/patron-new/39/src/lib/openjp2/j2k.h"
typedef enum T2_MODE J2K_T2_MODE;
#line 165 "/root/patron-new/39/src/lib/openjp2/j2k.h"
struct opj_stepsize {
   OPJ_INT32 expn ;
   OPJ_INT32 mant ;
};
#line 170 "/root/patron-new/39/src/lib/openjp2/j2k.h"
typedef struct opj_stepsize opj_stepsize_t;
#line 175 "/root/patron-new/39/src/lib/openjp2/j2k.h"
struct opj_tccp {
   OPJ_UINT32 csty ;
   OPJ_UINT32 numresolutions ;
   OPJ_UINT32 cblkw ;
   OPJ_UINT32 cblkh ;
   OPJ_UINT32 cblksty ;
   OPJ_UINT32 qmfbid ;
   OPJ_UINT32 qntsty ;
   opj_stepsize_t stepsizes[97] ;
   OPJ_UINT32 numgbits ;
   OPJ_INT32 roishift ;
   OPJ_UINT32 prcw[33] ;
   OPJ_UINT32 prch[33] ;
   OPJ_INT32 m_dc_level_shift ;
};
#line 203 "/root/patron-new/39/src/lib/openjp2/j2k.h"
typedef struct opj_tccp opj_tccp_t;
#line 210 "/root/patron-new/39/src/lib/openjp2/j2k.h"
struct opj_mct_data {
   J2K_MCT_ELEMENT_TYPE m_element_type ;
   J2K_MCT_ARRAY_TYPE m_array_type ;
   OPJ_UINT32 m_index ;
   OPJ_BYTE *m_data ;
   OPJ_UINT32 m_data_size ;
};
#line 217 "/root/patron-new/39/src/lib/openjp2/j2k.h"
typedef struct opj_mct_data opj_mct_data_t;
#line 222 "/root/patron-new/39/src/lib/openjp2/j2k.h"
struct opj_simple_mcc_decorrelation_data {
   OPJ_UINT32 m_index ;
   OPJ_UINT32 m_nb_comps ;
   opj_mct_data_t *m_decorrelation_array ;
   opj_mct_data_t *m_offset_array ;
   OPJ_BITFIELD m_is_irreversible ;
};
#line 229 "/root/patron-new/39/src/lib/openjp2/j2k.h"
typedef struct opj_simple_mcc_decorrelation_data opj_simple_mcc_decorrelation_data_t;
#line 231 "/root/patron-new/39/src/lib/openjp2/j2k.h"
struct opj_ppx_struct {
   OPJ_BYTE *m_data ;
   OPJ_UINT32 m_data_size ;
};
#line 234 "/root/patron-new/39/src/lib/openjp2/j2k.h"
typedef struct opj_ppx_struct opj_ppx;
#line 241 "/root/patron-new/39/src/lib/openjp2/j2k.h"
struct opj_tcp {
   OPJ_UINT32 csty ;
   OPJ_PROG_ORDER prg ;
   OPJ_UINT32 numlayers ;
   OPJ_UINT32 num_layers_to_decode ;
   OPJ_UINT32 mct ;
   OPJ_FLOAT32 rates[100] ;
   OPJ_UINT32 numpocs ;
   opj_poc_t pocs[32] ;
   OPJ_UINT32 ppt_markers_count ;
   opj_ppx *ppt_markers ;
   OPJ_BYTE *ppt_data ;
   OPJ_BYTE *ppt_buffer ;
   OPJ_UINT32 ppt_data_size ;
   OPJ_UINT32 ppt_len ;
   OPJ_FLOAT32 distoratio[100] ;
   opj_tccp_t *tccps ;
   OPJ_INT32 m_current_tile_part_number ;
   OPJ_UINT32 m_nb_tile_parts ;
   OPJ_BYTE *m_data ;
   OPJ_UINT32 m_data_size ;
   OPJ_FLOAT64 *mct_norms ;
   OPJ_FLOAT32 *m_mct_decoding_matrix ;
   OPJ_FLOAT32 *m_mct_coding_matrix ;
   opj_mct_data_t *m_mct_records ;
   OPJ_UINT32 m_nb_mct_records ;
   OPJ_UINT32 m_nb_max_mct_records ;
   opj_simple_mcc_decorrelation_data_t *m_mcc_records ;
   OPJ_UINT32 m_nb_mcc_records ;
   OPJ_UINT32 m_nb_max_mcc_records ;
   OPJ_BITFIELD cod ;
   OPJ_BITFIELD ppt ;
   OPJ_BITFIELD POC ;
};
#line 310 "/root/patron-new/39/src/lib/openjp2/j2k.h"
typedef struct opj_tcp opj_tcp_t;
#line 315 "/root/patron-new/39/src/lib/openjp2/j2k.h"
struct opj_encoding_param {
   OPJ_UINT32 m_max_comp_size ;
   OPJ_INT32 m_tp_pos ;
   OPJ_INT32 *m_matrice ;
   OPJ_BYTE m_tp_flag ;
   OPJ_BITFIELD m_disto_alloc ;
   OPJ_BITFIELD m_fixed_alloc ;
   OPJ_BITFIELD m_fixed_quality ;
   OPJ_BITFIELD m_tp_on ;
};
#line 333 "/root/patron-new/39/src/lib/openjp2/j2k.h"
typedef struct opj_encoding_param opj_encoding_param_t;
#line 335 "/root/patron-new/39/src/lib/openjp2/j2k.h"
struct opj_decoding_param {
   OPJ_UINT32 m_reduce ;
   OPJ_UINT32 m_layer ;
};
#line 341 "/root/patron-new/39/src/lib/openjp2/j2k.h"
typedef struct opj_decoding_param opj_decoding_param_t;
#line 395 "/root/patron-new/39/src/lib/openjp2/j2k.h"
union __anonunion_41 {
   opj_decoding_param_t m_dec ;
   opj_encoding_param_t m_enc ;
};
#line 347 "/root/patron-new/39/src/lib/openjp2/j2k.h"
struct opj_cp {
   OPJ_UINT16 rsiz ;
   OPJ_UINT32 tx0 ;
   OPJ_UINT32 ty0 ;
   OPJ_UINT32 tdx ;
   OPJ_UINT32 tdy ;
   OPJ_CHAR *comment ;
   OPJ_UINT32 tw ;
   OPJ_UINT32 th ;
   OPJ_UINT32 ppm_markers_count ;
   opj_ppx *ppm_markers ;
   OPJ_BYTE *ppm_data ;
   OPJ_UINT32 ppm_len ;
   OPJ_UINT32 ppm_data_read ;
   OPJ_BYTE *ppm_data_current ;
   OPJ_BYTE *ppm_buffer ;
   OPJ_BYTE *ppm_data_first ;
   OPJ_UINT32 ppm_data_size ;
   OPJ_INT32 ppm_store ;
   OPJ_INT32 ppm_previous ;
   opj_tcp_t *tcps ;
   union __anonunion_41 m_specific_param ;
   OPJ_BITFIELD ppm ;
   OPJ_BITFIELD m_is_decoder ;
   OPJ_BITFIELD allow_different_bit_depth_sign ;
};
#line 454 "/root/patron-new/39/src/lib/openjp2/j2k.h"
typedef struct opj_cp opj_cp_t;
#line 457 "/root/patron-new/39/src/lib/openjp2/j2k.h"
struct opj_j2k_dec {
   OPJ_UINT32 m_state ;
   opj_tcp_t *m_default_tcp ;
   OPJ_BYTE *m_header_data ;
   OPJ_UINT32 m_header_data_size ;
   OPJ_UINT32 m_sot_length ;
   OPJ_UINT32 m_start_tile_x ;
   OPJ_UINT32 m_start_tile_y ;
   OPJ_UINT32 m_end_tile_x ;
   OPJ_UINT32 m_end_tile_y ;
   OPJ_INT32 m_tile_ind_to_dec ;
   OPJ_OFF_T m_last_sot_read_pos ;
   OPJ_BOOL m_last_tile_part ;
   OPJ_UINT32 m_numcomps_to_decode ;
   OPJ_UINT32 *m_comps_indices_to_decode ;
   OPJ_BITFIELD m_can_decode ;
   OPJ_BITFIELD m_discard_tiles ;
   OPJ_BITFIELD m_skip_data ;
   OPJ_BITFIELD m_nb_tile_parts_correction_checked ;
   OPJ_BITFIELD m_nb_tile_parts_correction ;
};
#line 497 "/root/patron-new/39/src/lib/openjp2/j2k.h"
typedef struct opj_j2k_dec opj_j2k_dec_t;
#line 499 "/root/patron-new/39/src/lib/openjp2/j2k.h"
struct opj_j2k_enc {
   OPJ_UINT32 m_current_poc_tile_part_number ;
   OPJ_UINT32 m_current_tile_part_number ;
   OPJ_OFF_T m_tlm_start ;
   OPJ_BYTE *m_tlm_sot_offsets_buffer ;
   OPJ_BYTE *m_tlm_sot_offsets_current ;
   OPJ_UINT32 m_total_tile_parts ;
   OPJ_BYTE *m_encoded_tile_data ;
   OPJ_UINT32 m_encoded_tile_size ;
   OPJ_BYTE *m_header_tile_data ;
   OPJ_UINT32 m_header_tile_data_size ;
   OPJ_BOOL m_PLT ;
   OPJ_UINT32 m_reserved_bytes_for_PLT ;
};
#line 543 "/root/patron-new/39/src/lib/openjp2/j2k.h"
typedef struct opj_j2k_enc opj_j2k_enc_t;
#line 547
struct opj_tcd ;
#line 556 "/root/patron-new/39/src/lib/openjp2/j2k.h"
union __anonunion_42 {
   opj_j2k_dec_t m_decoder ;
   opj_j2k_enc_t m_encoder ;
};
#line 551 "/root/patron-new/39/src/lib/openjp2/j2k.h"
struct opj_j2k {
   OPJ_BOOL m_is_decoder ;
   union __anonunion_42 m_specific_param ;
   opj_image_t *m_private_image ;
   opj_image_t *m_output_image ;
   opj_cp_t m_cp ;
   opj_procedure_list_t *m_procedure_list ;
   opj_procedure_list_t *m_validation_list ;
   opj_codestream_index_t *cstr_index ;
   OPJ_UINT32 m_current_tile_number ;
   struct opj_tcd *m_tcd ;
   opj_thread_pool_t *m_tp ;
   OPJ_UINT32 ihdr_w ;
   OPJ_UINT32 ihdr_h ;
   unsigned int dump_state ;
};
#line 598 "/root/patron-new/39/src/lib/openjp2/j2k.h"
typedef struct opj_j2k opj_j2k_t;
#line 93 "/root/patron-new/39/src/lib/openjp2/jp2.h"
struct opj_jp2_cdef_info {
   OPJ_UINT16 cn ;
   OPJ_UINT16 typ ;
   OPJ_UINT16 asoc ;
};
#line 95 "/root/patron-new/39/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_cdef_info opj_jp2_cdef_info_t;
#line 100 "/root/patron-new/39/src/lib/openjp2/jp2.h"
struct opj_jp2_cdef {
   opj_jp2_cdef_info_t *info ;
   OPJ_UINT16 n ;
};
#line 103 "/root/patron-new/39/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_cdef opj_jp2_cdef_t;
#line 108 "/root/patron-new/39/src/lib/openjp2/jp2.h"
struct opj_jp2_cmap_comp {
   OPJ_UINT16 cmp ;
   OPJ_BYTE mtyp ;
   OPJ_BYTE pcol ;
};
#line 111 "/root/patron-new/39/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_cmap_comp opj_jp2_cmap_comp_t;
#line 116 "/root/patron-new/39/src/lib/openjp2/jp2.h"
struct opj_jp2_pclr {
   OPJ_UINT32 *entries ;
   OPJ_BYTE *channel_sign ;
   OPJ_BYTE *channel_size ;
   opj_jp2_cmap_comp_t *cmap ;
   OPJ_UINT16 nr_entries ;
   OPJ_BYTE nr_channels ;
};
#line 123 "/root/patron-new/39/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_pclr opj_jp2_pclr_t;
#line 128 "/root/patron-new/39/src/lib/openjp2/jp2.h"
struct opj_jp2_color {
   OPJ_BYTE *icc_profile_buf ;
   OPJ_UINT32 icc_profile_len ;
   opj_jp2_cdef_t *jp2_cdef ;
   opj_jp2_pclr_t *jp2_pclr ;
   OPJ_BYTE jp2_has_colr ;
};
#line 135 "/root/patron-new/39/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_color opj_jp2_color_t;
#line 140 "/root/patron-new/39/src/lib/openjp2/jp2.h"
struct opj_jp2_comps {
   OPJ_UINT32 depth ;
   OPJ_UINT32 sgnd ;
   OPJ_UINT32 bpcc ;
};
#line 144 "/root/patron-new/39/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_comps opj_jp2_comps_t;
#line 149 "/root/patron-new/39/src/lib/openjp2/jp2.h"
struct opj_jp2 {
   opj_j2k_t *j2k ;
   struct opj_procedure_list *m_validation_list ;
   struct opj_procedure_list *m_procedure_list ;
   OPJ_UINT32 w ;
   OPJ_UINT32 h ;
   OPJ_UINT32 numcomps ;
   OPJ_UINT32 bpc ;
   OPJ_UINT32 C ;
   OPJ_UINT32 UnkC ;
   OPJ_UINT32 IPR ;
   OPJ_UINT32 meth ;
   OPJ_UINT32 approx ;
   OPJ_UINT32 enumcs ;
   OPJ_UINT32 precedence ;
   OPJ_UINT32 brand ;
   OPJ_UINT32 minversion ;
   OPJ_UINT32 numcl ;
   OPJ_UINT32 *cl ;
   opj_jp2_comps_t *comps ;
   OPJ_OFF_T j2k_codestream_offset ;
   OPJ_OFF_T jpip_iptr_offset ;
   OPJ_BOOL jpip_on ;
   OPJ_UINT32 jp2_state ;
   OPJ_UINT32 jp2_img_state ;
   opj_jp2_color_t color ;
   OPJ_BOOL ignore_pclr_cmap_cdef ;
   OPJ_BYTE has_jp2h ;
   OPJ_BYTE has_ihdr ;
};
#line 193 "/root/patron-new/39/src/lib/openjp2/jp2.h"
typedef struct opj_jp2 opj_jp2_t;
#line 198 "/root/patron-new/39/src/lib/openjp2/jp2.h"
struct opj_jp2_box {
   OPJ_UINT32 length ;
   OPJ_UINT32 type ;
   OPJ_INT32 init_pos ;
};
#line 202 "/root/patron-new/39/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_box opj_jp2_box_t;
#line 204 "/root/patron-new/39/src/lib/openjp2/jp2.h"
struct opj_jp2_header_handler {
   OPJ_UINT32 id ;
   OPJ_BOOL (*handler)(opj_jp2_t * , OPJ_BYTE * , OPJ_UINT32  , opj_event_mgr_t * ) ;
};
#line 213 "/root/patron-new/39/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_header_handler opj_jp2_header_handler_t;
#line 216 "/root/patron-new/39/src/lib/openjp2/jp2.h"
struct opj_jp2_img_header_writer_handler {
   OPJ_BYTE *(*handler)(opj_jp2_t * , OPJ_UINT32 * ) ;
   OPJ_BYTE *m_data ;
   OPJ_UINT32 m_size ;
};
#line 224 "/root/patron-new/39/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_img_header_writer_handler opj_jp2_img_header_writer_handler_t;
#line 58 "/root/patron-new/39/src/lib/openjp2/mqc.h"
struct opj_mqc_state {
   OPJ_UINT32 qeval ;
   OPJ_UINT32 mps ;
   struct opj_mqc_state *nmps ;
   struct opj_mqc_state *nlps ;
};
#line 67 "/root/patron-new/39/src/lib/openjp2/mqc.h"
typedef struct opj_mqc_state opj_mqc_state_t;
#line 74 "/root/patron-new/39/src/lib/openjp2/mqc.h"
struct opj_mqc {
   OPJ_UINT32 c ;
   OPJ_UINT32 a ;
   OPJ_UINT32 ct ;
   OPJ_UINT32 end_of_byte_stream_counter ;
   OPJ_BYTE *bp ;
   OPJ_BYTE *start ;
   OPJ_BYTE *end ;
   opj_mqc_state_t *ctxs[19] ;
   opj_mqc_state_t **curctx ;
   OPJ_BYTE *lut_ctxno_zc_orient ;
   OPJ_BYTE backup[2] ;
};
#line 97 "/root/patron-new/39/src/lib/openjp2/mqc.h"
typedef struct opj_mqc opj_mqc_t;
#line 55 "/root/patron-new/39/src/lib/openjp2/pi.h"
struct opj_pi_resolution {
   OPJ_UINT32 pdx ;
   OPJ_UINT32 pdy ;
   OPJ_UINT32 pw ;
   OPJ_UINT32 ph ;
};
#line 58 "/root/patron-new/39/src/lib/openjp2/pi.h"
typedef struct opj_pi_resolution opj_pi_resolution_t;
#line 63 "/root/patron-new/39/src/lib/openjp2/pi.h"
struct opj_pi_comp {
   OPJ_UINT32 dx ;
   OPJ_UINT32 dy ;
   OPJ_UINT32 numresolutions ;
   opj_pi_resolution_t *resolutions ;
};
#line 68 "/root/patron-new/39/src/lib/openjp2/pi.h"
typedef struct opj_pi_comp opj_pi_comp_t;
#line 73 "/root/patron-new/39/src/lib/openjp2/pi.h"
struct opj_pi_iterator {
   OPJ_BYTE tp_on ;
   OPJ_INT16 *include ;
   OPJ_UINT32 include_size ;
   OPJ_UINT32 step_l ;
   OPJ_UINT32 step_r ;
   OPJ_UINT32 step_c ;
   OPJ_UINT32 step_p ;
   OPJ_UINT32 compno ;
   OPJ_UINT32 resno ;
   OPJ_UINT32 precno ;
   OPJ_UINT32 layno ;
   OPJ_BOOL first ;
   opj_poc_t poc ;
   OPJ_UINT32 numcomps ;
   opj_pi_comp_t *comps ;
   OPJ_UINT32 tx0 ;
   OPJ_UINT32 ty0 ;
   OPJ_UINT32 tx1 ;
   OPJ_UINT32 ty1 ;
   OPJ_UINT32 x ;
   OPJ_UINT32 y ;
   OPJ_UINT32 dx ;
   OPJ_UINT32 dy ;
};
#line 110 "/root/patron-new/39/src/lib/openjp2/pi.h"
typedef struct opj_pi_iterator opj_pi_iterator_t;
#line 57 "/root/patron-new/39/src/lib/openjp2/tgt.h"
struct opj_tgt_node {
   struct opj_tgt_node *parent ;
   OPJ_INT32 value ;
   OPJ_INT32 low ;
   OPJ_UINT32 known ;
};
#line 62 "/root/patron-new/39/src/lib/openjp2/tgt.h"
typedef struct opj_tgt_node opj_tgt_node_t;
#line 67 "/root/patron-new/39/src/lib/openjp2/tgt.h"
struct opj_tgt_tree {
   OPJ_UINT32 numleafsh ;
   OPJ_UINT32 numleafsv ;
   OPJ_UINT32 numnodes ;
   opj_tgt_node_t *nodes ;
   OPJ_UINT32 nodes_size ;
};
#line 73 "/root/patron-new/39/src/lib/openjp2/tgt.h"
typedef struct opj_tgt_tree opj_tgt_tree_t;
#line 57 "/root/patron-new/39/src/lib/openjp2/tcd.h"
struct opj_tcd_pass {
   OPJ_UINT32 rate ;
   OPJ_FLOAT64 distortiondec ;
   OPJ_UINT32 len ;
   OPJ_BITFIELD term ;
};
#line 62 "/root/patron-new/39/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_pass opj_tcd_pass_t;
#line 67 "/root/patron-new/39/src/lib/openjp2/tcd.h"
struct opj_tcd_layer {
   OPJ_UINT32 numpasses ;
   OPJ_UINT32 len ;
   OPJ_FLOAT64 disto ;
   OPJ_BYTE *data ;
};
#line 72 "/root/patron-new/39/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_layer opj_tcd_layer_t;
#line 77 "/root/patron-new/39/src/lib/openjp2/tcd.h"
struct opj_tcd_cblk_enc {
   OPJ_BYTE *data ;
   opj_tcd_layer_t *layers ;
   opj_tcd_pass_t *passes ;
   OPJ_INT32 x0 ;
   OPJ_INT32 y0 ;
   OPJ_INT32 x1 ;
   OPJ_INT32 y1 ;
   OPJ_UINT32 numbps ;
   OPJ_UINT32 numlenbits ;
   OPJ_UINT32 data_size ;
   OPJ_UINT32 numpasses ;
   OPJ_UINT32 numpassesinlayers ;
   OPJ_UINT32 totalpasses ;
};
#line 90 "/root/patron-new/39/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_cblk_enc opj_tcd_cblk_enc_t;
#line 94 "/root/patron-new/39/src/lib/openjp2/tcd.h"
struct opj_tcd_seg_data_chunk {
   OPJ_BYTE *data ;
   OPJ_UINT32 len ;
};
#line 100 "/root/patron-new/39/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_seg_data_chunk opj_tcd_seg_data_chunk_t;
#line 105 "/root/patron-new/39/src/lib/openjp2/tcd.h"
struct opj_tcd_seg {
   OPJ_UINT32 len ;
   OPJ_UINT32 numpasses ;
   OPJ_UINT32 real_num_passes ;
   OPJ_UINT32 maxpasses ;
   OPJ_UINT32 numnewpasses ;
   OPJ_UINT32 newlen ;
};
#line 117 "/root/patron-new/39/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_seg opj_tcd_seg_t;
#line 120 "/root/patron-new/39/src/lib/openjp2/tcd.h"
struct opj_tcd_cblk_dec {
   opj_tcd_seg_t *segs ;
   opj_tcd_seg_data_chunk_t *chunks ;
   OPJ_INT32 x0 ;
   OPJ_INT32 y0 ;
   OPJ_INT32 x1 ;
   OPJ_INT32 y1 ;
   OPJ_UINT32 numbps ;
   OPJ_UINT32 numlenbits ;
   OPJ_UINT32 numnewpasses ;
   OPJ_UINT32 numsegs ;
   OPJ_UINT32 real_num_segs ;
   OPJ_UINT32 m_current_max_segs ;
   OPJ_UINT32 numchunks ;
   OPJ_UINT32 numchunksalloc ;
   OPJ_INT32 *decoded_data ;
};
#line 139 "/root/patron-new/39/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_cblk_dec opj_tcd_cblk_dec_t;
#line 146 "/root/patron-new/39/src/lib/openjp2/tcd.h"
union __anonunion_45 {
   opj_tcd_cblk_enc_t *enc ;
   opj_tcd_cblk_dec_t *dec ;
   void *blocks ;
};
#line 142 "/root/patron-new/39/src/lib/openjp2/tcd.h"
struct opj_tcd_precinct {
   OPJ_INT32 x0 ;
   OPJ_INT32 y0 ;
   OPJ_INT32 x1 ;
   OPJ_INT32 y1 ;
   OPJ_UINT32 cw ;
   OPJ_UINT32 ch ;
   union __anonunion_45 cblks ;
   OPJ_UINT32 block_size ;
   opj_tgt_tree_t *incltree ;
   opj_tgt_tree_t *imsbtree ;
};
#line 154 "/root/patron-new/39/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_precinct opj_tcd_precinct_t;
#line 157 "/root/patron-new/39/src/lib/openjp2/tcd.h"
struct opj_tcd_band {
   OPJ_INT32 x0 ;
   OPJ_INT32 y0 ;
   OPJ_INT32 x1 ;
   OPJ_INT32 y1 ;
   OPJ_UINT32 bandno ;
   opj_tcd_precinct_t *precincts ;
   OPJ_UINT32 precincts_data_size ;
   OPJ_INT32 numbps ;
   OPJ_FLOAT32 stepsize ;
};
#line 168 "/root/patron-new/39/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_band opj_tcd_band_t;
#line 171 "/root/patron-new/39/src/lib/openjp2/tcd.h"
struct opj_tcd_resolution {
   OPJ_INT32 x0 ;
   OPJ_INT32 y0 ;
   OPJ_INT32 x1 ;
   OPJ_INT32 y1 ;
   OPJ_UINT32 pw ;
   OPJ_UINT32 ph ;
   OPJ_UINT32 numbands ;
   opj_tcd_band_t bands[3] ;
   OPJ_UINT32 win_x0 ;
   OPJ_UINT32 win_y0 ;
   OPJ_UINT32 win_x1 ;
   OPJ_UINT32 win_y1 ;
};
#line 186 "/root/patron-new/39/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_resolution opj_tcd_resolution_t;
#line 189 "/root/patron-new/39/src/lib/openjp2/tcd.h"
struct opj_tcd_tilecomp {
   OPJ_INT32 x0 ;
   OPJ_INT32 y0 ;
   OPJ_INT32 x1 ;
   OPJ_INT32 y1 ;
   OPJ_UINT32 compno ;
   OPJ_UINT32 numresolutions ;
   OPJ_UINT32 minimum_num_resolutions ;
   opj_tcd_resolution_t *resolutions ;
   OPJ_UINT32 resolutions_size ;
   OPJ_INT32 *data ;
   OPJ_BOOL ownsData ;
   size_t data_size_needed ;
   size_t data_size ;
   OPJ_INT32 *data_win ;
   OPJ_UINT32 win_x0 ;
   OPJ_UINT32 win_y0 ;
   OPJ_UINT32 win_x1 ;
   OPJ_UINT32 win_y1 ;
   OPJ_INT32 numpix ;
};
#line 222 "/root/patron-new/39/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_tilecomp opj_tcd_tilecomp_t;
#line 228 "/root/patron-new/39/src/lib/openjp2/tcd.h"
struct opj_tcd_tile {
   OPJ_INT32 x0 ;
   OPJ_INT32 y0 ;
   OPJ_INT32 x1 ;
   OPJ_INT32 y1 ;
   OPJ_UINT32 numcomps ;
   opj_tcd_tilecomp_t *comps ;
   OPJ_INT32 numpix ;
   OPJ_FLOAT64 distotile ;
   OPJ_FLOAT64 distolayer[100] ;
   OPJ_UINT32 packno ;
};
#line 237 "/root/patron-new/39/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_tile opj_tcd_tile_t;
#line 242 "/root/patron-new/39/src/lib/openjp2/tcd.h"
struct opj_tcd_image {
   opj_tcd_tile_t *tiles ;
};
#line 245 "/root/patron-new/39/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_image opj_tcd_image_t;
#line 251 "/root/patron-new/39/src/lib/openjp2/tcd.h"
struct opj_tcd {
   OPJ_INT32 tp_pos ;
   OPJ_UINT32 tp_num ;
   OPJ_UINT32 cur_tp_num ;
   OPJ_UINT32 cur_totnum_tp ;
   OPJ_UINT32 cur_pino ;
   opj_tcd_image_t *tcd_image ;
   opj_image_t *image ;
   opj_cp_t *cp ;
   opj_tcp_t *tcp ;
   OPJ_UINT32 tcd_tileno ;
   OPJ_BITFIELD m_is_decoder ;
   opj_thread_pool_t *thread_pool ;
   OPJ_UINT32 win_x0 ;
   OPJ_UINT32 win_y0 ;
   OPJ_UINT32 win_x1 ;
   OPJ_UINT32 win_y1 ;
   OPJ_BOOL whole_tile_decoding ;
   OPJ_BOOL *used_component ;
};
#line 285 "/root/patron-new/39/src/lib/openjp2/tcd.h"
typedef struct opj_tcd opj_tcd_t;
#line 291 "/root/patron-new/39/src/lib/openjp2/tcd.h"
struct opj_tcd_marker_info {
   OPJ_BOOL need_PLT ;
   OPJ_UINT32 packet_count ;
   OPJ_UINT32 *p_packet_size ;
};
#line 301 "/root/patron-new/39/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_marker_info opj_tcd_marker_info_t;
#line 54 "/root/patron-new/39/src/lib/openjp2/t2.h"
struct opj_t2 {
   opj_image_t *image ;
   opj_cp_t *cp ;
};
#line 60 "/root/patron-new/39/src/lib/openjp2/t2.h"
typedef struct opj_t2 opj_t2_t;
#line 53 "/root/patron-new/39/src/lib/openjp2/sparse_array.h"
struct opj_sparse_array_int32 ;
#line 53 "/root/patron-new/39/src/lib/openjp2/sparse_array.h"
typedef struct opj_sparse_array_int32 opj_sparse_array_int32_t;
#line 48 "/root/patron-new/39/src/lib/openjp2/opj_codec.h"
struct opj_decompression {
   OPJ_BOOL (*opj_read_header)(struct opj_stream_private * , void * , opj_image_t ** ,
                               struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_decode)(void * , struct opj_stream_private * , opj_image_t * , struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_read_tile_header)(void * , OPJ_UINT32 * , OPJ_UINT32 * , OPJ_INT32 * ,
                                    OPJ_INT32 * , OPJ_INT32 * , OPJ_INT32 * , OPJ_UINT32 * ,
                                    OPJ_BOOL * , struct opj_stream_private * , struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_decode_tile_data)(void * , OPJ_UINT32  , OPJ_BYTE * , OPJ_UINT32  ,
                                    struct opj_stream_private * , struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_end_decompress)(void * , struct opj_stream_private * , struct opj_event_mgr * ) ;
   void (*opj_destroy)(void * ) ;
   void (*opj_setup_decoder)(void * , opj_dparameters_t * ) ;
   OPJ_BOOL (*opj_set_decode_area)(void * , opj_image_t * , OPJ_INT32  , OPJ_INT32  ,
                                   OPJ_INT32  , OPJ_INT32  , struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_get_decoded_tile)(void * , opj_stream_private_t * , opj_image_t * ,
                                    struct opj_event_mgr * , OPJ_UINT32  ) ;
   OPJ_BOOL (*opj_set_decoded_resolution_factor)(void * , OPJ_UINT32  , opj_event_mgr_t * ) ;
   OPJ_BOOL (*opj_set_decoded_components)(void * , OPJ_UINT32  , OPJ_UINT32 * , opj_event_mgr_t * ) ;
};
#line 124 "/root/patron-new/39/src/lib/openjp2/opj_codec.h"
struct opj_compression {
   OPJ_BOOL (*opj_start_compress)(void * , struct opj_stream_private * , struct opj_image * ,
                                  struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_encode)(void * , struct opj_stream_private * , struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_write_tile)(void * , OPJ_UINT32  , OPJ_BYTE * , OPJ_UINT32  , struct opj_stream_private * ,
                              struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_end_compress)(void * , struct opj_stream_private * , struct opj_event_mgr * ) ;
   void (*opj_destroy)(void * ) ;
   OPJ_BOOL (*opj_setup_encoder)(void * , opj_cparameters_t * , struct opj_image * ,
                                 struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_encoder_set_extra_options)(void * , char const   * const  * , struct opj_event_mgr * ) ;
};
#line 44 "/root/patron-new/39/src/lib/openjp2/opj_codec.h"
union __anonunion_46 {
   struct opj_decompression m_decompression ;
   struct opj_compression m_compression ;
};
#line 42 "/root/patron-new/39/src/lib/openjp2/opj_codec.h"
struct opj_codec_private {
   union __anonunion_46 m_codec_data ;
   void *m_codec ;
   opj_event_mgr_t m_event_mgr ;
   OPJ_BOOL is_decompressor ;
   void (*opj_dump_codec)(void * , OPJ_INT32  , FILE * ) ;
   opj_codestream_info_v2_t *(*opj_get_codec_info)(void * ) ;
   opj_codestream_index_t *(*opj_get_codec_index)(void * ) ;
   OPJ_BOOL (*opj_set_threads)(void * , OPJ_UINT32  ) ;
};
#line 172 "/root/patron-new/39/src/lib/openjp2/opj_codec.h"
typedef struct opj_codec_private opj_codec_private_t;
#line 309 "/root/patron-new/39/src/lib/openjp2/thread.c"
struct opj_mutex_t {
   pthread_mutex_t mutex ;
};
#line 344 "/root/patron-new/39/src/lib/openjp2/thread.c"
struct opj_cond_t {
   pthread_cond_t cond ;
};
#line 383 "/root/patron-new/39/src/lib/openjp2/thread.c"
struct opj_thread_t {
   void (*thread_fn)(void * ) ;
   void *user_data ;
   pthread_t thread ;
};
#line 498 "/root/patron-new/39/src/lib/openjp2/thread.c"
struct __anonstruct_47 {
   int key ;
   void *value ;
   void (*opj_free_func)(void * ) ;
};
#line 502 "/root/patron-new/39/src/lib/openjp2/thread.c"
typedef struct __anonstruct_47 opj_tls_key_val_t;
#line 504 "/root/patron-new/39/src/lib/openjp2/thread.c"
struct opj_tls_t {
   opj_tls_key_val_t *key_val ;
   int key_val_count ;
};
#line 573 "/root/patron-new/39/src/lib/openjp2/thread.c"
struct __anonstruct_48 {
   void (*job_fn)(void * , opj_tls_t * ) ;
   void *user_data ;
};
#line 576 "/root/patron-new/39/src/lib/openjp2/thread.c"
typedef struct __anonstruct_48 opj_worker_thread_job_t;
#line 578 "/root/patron-new/39/src/lib/openjp2/thread.c"
struct __anonstruct_49 {
   opj_thread_pool_t *tp ;
   opj_thread_t *thread ;
   int marked_as_waiting ;
   opj_mutex_t *mutex ;
   opj_cond_t *cond ;
};
#line 585 "/root/patron-new/39/src/lib/openjp2/thread.c"
typedef struct __anonstruct_49 opj_worker_thread_t;
#line 587
enum __anonenum__50 {
    OPJWTS_OK = 0,
    OPJWTS_STOP = 1,
    OPJWTS_ERROR = 2
} ;
#line 591 "/root/patron-new/39/src/lib/openjp2/thread.c"
typedef enum __anonenum__50 opj_worker_thread_state;
#line 593 "/root/patron-new/39/src/lib/openjp2/thread.c"
struct opj_job_list_t {
   opj_worker_thread_job_t *job ;
   struct opj_job_list_t *next ;
};
#line 597 "/root/patron-new/39/src/lib/openjp2/thread.c"
typedef struct opj_job_list_t opj_job_list_t;
#line 599 "/root/patron-new/39/src/lib/openjp2/thread.c"
struct opj_worker_thread_list_t {
   opj_worker_thread_t *worker_thread ;
   struct opj_worker_thread_list_t *next ;
};
#line 603 "/root/patron-new/39/src/lib/openjp2/thread.c"
typedef struct opj_worker_thread_list_t opj_worker_thread_list_t;
#line 605 "/root/patron-new/39/src/lib/openjp2/thread.c"
struct opj_thread_pool_t {
   opj_worker_thread_t *worker_threads ;
   int worker_threads_count ;
   opj_cond_t *cond ;
   opj_mutex_t *mutex ;
   opj_worker_thread_state state ;
   opj_job_list_t *job_queue ;
   int pending_jobs_count ;
   opj_worker_thread_list_t *waiting_worker_thread_list ;
   int waiting_worker_thread_count ;
   opj_tls_t *tls ;
   int signaling_threshold ;
};
#line 35 "/root/patron-new/39/src/lib/openjp2/sparse_array.c"
struct opj_sparse_array_int32 {
   OPJ_UINT32 width ;
   OPJ_UINT32 height ;
   OPJ_UINT32 block_width ;
   OPJ_UINT32 block_height ;
   OPJ_UINT32 block_count_hor ;
   OPJ_UINT32 block_count_ver ;
   OPJ_INT32 **data_blocks ;
};
#line 40 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_69 {
   long ru_maxrss ;
   __syscall_slong_t __ru_maxrss_word ;
};
#line 47 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_70 {
   long ru_ixrss ;
   __syscall_slong_t __ru_ixrss_word ;
};
#line 53 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_71 {
   long ru_idrss ;
   __syscall_slong_t __ru_idrss_word ;
};
#line 59 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_72 {
   long ru_isrss ;
   __syscall_slong_t __ru_isrss_word ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_73 {
   long ru_minflt ;
   __syscall_slong_t __ru_minflt_word ;
};
#line 72 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_74 {
   long ru_majflt ;
   __syscall_slong_t __ru_majflt_word ;
};
#line 78 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_75 {
   long ru_nswap ;
   __syscall_slong_t __ru_nswap_word ;
};
#line 85 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_76 {
   long ru_inblock ;
   __syscall_slong_t __ru_inblock_word ;
};
#line 91 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_77 {
   long ru_oublock ;
   __syscall_slong_t __ru_oublock_word ;
};
#line 97 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_78 {
   long ru_msgsnd ;
   __syscall_slong_t __ru_msgsnd_word ;
};
#line 103 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_79 {
   long ru_msgrcv ;
   __syscall_slong_t __ru_msgrcv_word ;
};
#line 109 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_80 {
   long ru_nsignals ;
   __syscall_slong_t __ru_nsignals_word ;
};
#line 117 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_81 {
   long ru_nvcsw ;
   __syscall_slong_t __ru_nvcsw_word ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_82 {
   long ru_nivcsw ;
   __syscall_slong_t __ru_nivcsw_word ;
};
#line 33 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
struct rusage {
   struct timeval ru_utime ;
   struct timeval ru_stime ;
   union __anonunion_69 __annonCompField3 ;
   long ru_maxrss ;
   __syscall_slong_t __ru_maxrss_word ;
   union __anonunion_70 __annonCompField4 ;
   long ru_ixrss ;
   __syscall_slong_t __ru_ixrss_word ;
   union __anonunion_71 __annonCompField5 ;
   long ru_idrss ;
   __syscall_slong_t __ru_idrss_word ;
   union __anonunion_72 __annonCompField6 ;
   long ru_isrss ;
   __syscall_slong_t __ru_isrss_word ;
   union __anonunion_73 __annonCompField7 ;
   long ru_minflt ;
   __syscall_slong_t __ru_minflt_word ;
   union __anonunion_74 __annonCompField8 ;
   long ru_majflt ;
   __syscall_slong_t __ru_majflt_word ;
   union __anonunion_75 __annonCompField9 ;
   long ru_nswap ;
   __syscall_slong_t __ru_nswap_word ;
   union __anonunion_76 __annonCompField10 ;
   long ru_inblock ;
   __syscall_slong_t __ru_inblock_word ;
   union __anonunion_77 __annonCompField11 ;
   long ru_oublock ;
   __syscall_slong_t __ru_oublock_word ;
   union __anonunion_78 __annonCompField12 ;
   long ru_msgsnd ;
   __syscall_slong_t __ru_msgsnd_word ;
   union __anonunion_79 __annonCompField13 ;
   long ru_msgrcv ;
   __syscall_slong_t __ru_msgrcv_word ;
   union __anonunion_80 __annonCompField14 ;
   long ru_nsignals ;
   __syscall_slong_t __ru_nsignals_word ;
   union __anonunion_81 __annonCompField15 ;
   long ru_nvcsw ;
   __syscall_slong_t __ru_nvcsw_word ;
   union __anonunion_82 __annonCompField16 ;
   long ru_nivcsw ;
   __syscall_slong_t __ru_nivcsw_word ;
};
#line 43 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef int __rusage_who_t;
#line 197 "/root/patron-new/39/src/lib/openjp2/j2k.c"
struct opj_dec_memory_marker_handler ;
#line 1315 "/root/patron-new/39/src/lib/openjp2/j2k.c"
struct j2k_prog_order {
   OPJ_PROG_ORDER enum_prog ;
   char str_prog[5] ;
};
#line 1318 "/root/patron-new/39/src/lib/openjp2/j2k.c"
typedef struct j2k_prog_order j2k_prog_order_t;
#line 1339 "/root/patron-new/39/src/lib/openjp2/j2k.c"
typedef void (*opj_j2k_mct_function)(void const   * , void * , OPJ_UINT32  );
#line 1363 "/root/patron-new/39/src/lib/openjp2/j2k.c"
struct opj_dec_memory_marker_handler {
   OPJ_UINT32 id ;
   OPJ_UINT32 states ;
   OPJ_BOOL (*handler)(opj_j2k_t * , OPJ_BYTE * , OPJ_UINT32  , opj_event_mgr_t * ) ;
};
#line 1374 "/root/patron-new/39/src/lib/openjp2/j2k.c"
typedef struct opj_dec_memory_marker_handler opj_dec_memory_marker_handler_t;
#line 70 "/usr/include/x86_64-linux-gnu/tiff.h"
typedef unsigned short uint16;
#line 73 "/usr/include/x86_64-linux-gnu/tiff.h"
typedef unsigned int uint32;
#line 38 "/usr/include/x86_64-linux-gnu/tiffio.h"
struct tiff ;
#line 38 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef struct tiff TIFF;
#line 65 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef long tmsize_t;
#line 72 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef uint32 tstrile_t;
#line 73 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef tstrile_t tstrip_t;
#line 75 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef tmsize_t tsize_t;
#line 76 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef void *tdata_t;
#line 42 "/root/patron-new/39/src/bin/jp2/convert.h"
struct raw_comp_cparameters {
   int dx ;
   int dy ;
};
#line 48 "/root/patron-new/39/src/bin/jp2/convert.h"
typedef struct raw_comp_cparameters raw_comp_cparameters_t;
#line 52 "/root/patron-new/39/src/bin/jp2/convert.h"
struct raw_cparameters {
   int rawWidth ;
   int rawHeight ;
   int rawComp ;
   int rawBitDepth ;
   OPJ_BOOL rawSigned ;
   raw_comp_cparameters_t *rawComps ;
};
#line 66 "/root/patron-new/39/src/bin/jp2/convert.h"
typedef struct raw_cparameters raw_cparameters_t;
#line 74 "/root/patron-new/39/src/bin/jp2/convert.h"
typedef void (*convert_32s_CXPX)(OPJ_INT32 * , OPJ_INT32 * const  * , OPJ_SIZE_T  );
#line 77 "/root/patron-new/39/src/bin/jp2/convert.h"
typedef void (*convert_32s_PXCX)(OPJ_INT32 * const  * , OPJ_INT32 * , OPJ_SIZE_T  ,
                                 OPJ_INT32  );
#line 81 "/root/patron-new/39/src/bin/jp2/convert.h"
typedef void (*convert_XXx32s_C1R)(OPJ_BYTE * , OPJ_INT32 * , OPJ_SIZE_T  );
#line 84 "/root/patron-new/39/src/bin/jp2/convert.h"
typedef void (*convert_32sXXx_C1R)(OPJ_INT32 * , OPJ_BYTE * , OPJ_SIZE_T  );
#line 33 "/usr/include/setjmp.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 45 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag jmp_buf[1];
#line 481 "/usr/include/pngconf.h"
typedef unsigned char png_byte;
#line 511 "/usr/include/pngconf.h"
typedef unsigned int png_uint_32;
#line 523 "/usr/include/pngconf.h"
typedef size_t png_size_t;
#line 577 "/usr/include/pngconf.h"
typedef void *png_voidp;
#line 579 "/usr/include/pngconf.h"
typedef png_byte *png_bytep;
#line 580 "/usr/include/pngconf.h"
typedef png_byte *png_const_bytep;
#line 590 "/usr/include/pngconf.h"
typedef char const   *png_const_charp;
#line 597 "/usr/include/pngconf.h"
typedef FILE *png_FILE_p;
#line 606 "/usr/include/pngconf.h"
typedef png_byte **png_bytepp;
#line 454 "/usr/include/png.h"
struct png_struct_def ;
#line 454 "/usr/include/png.h"
typedef struct png_struct_def png_struct;
#line 456 "/usr/include/png.h"
typedef png_struct *png_structp;
#line 457 "/usr/include/png.h"
typedef png_struct **png_structpp;
#line 468
struct png_info_def ;
#line 468 "/usr/include/png.h"
typedef struct png_info_def png_info;
#line 469 "/usr/include/png.h"
typedef png_info *png_infop;
#line 471 "/usr/include/png.h"
typedef png_info **png_infopp;
#line 484 "/usr/include/png.h"
typedef png_struct *png_structrp;
#line 485 "/usr/include/png.h"
typedef png_struct *png_const_structrp;
#line 486 "/usr/include/png.h"
typedef png_info *png_inforp;
#line 487 "/usr/include/png.h"
typedef png_info *png_const_inforp;
#line 515 "/usr/include/png.h"
struct png_color_8_struct {
   png_byte red ;
   png_byte green ;
   png_byte blue ;
   png_byte gray ;
   png_byte alpha ;
};
#line 522 "/usr/include/png.h"
typedef struct png_color_8_struct png_color_8;
#line 524 "/usr/include/png.h"
typedef png_color_8 *png_const_color_8p;
#line 48 "/root/patron-new/39/src/bin/jp2/convertbmp.c"
struct __anonstruct_120 {
   OPJ_UINT16 bfType ;
   OPJ_UINT32 bfSize ;
   OPJ_UINT16 bfReserved1 ;
   OPJ_UINT16 bfReserved2 ;
   OPJ_UINT32 bfOffBits ;
};
#line 54 "/root/patron-new/39/src/bin/jp2/convertbmp.c"
typedef struct __anonstruct_120 OPJ_BITMAPFILEHEADER;
#line 56 "/root/patron-new/39/src/bin/jp2/convertbmp.c"
struct __anonstruct_121 {
   OPJ_UINT32 biSize ;
   OPJ_UINT32 biWidth ;
   OPJ_UINT32 biHeight ;
   OPJ_UINT16 biPlanes ;
   OPJ_UINT16 biBitCount ;
   OPJ_UINT32 biCompression ;
   OPJ_UINT32 biSizeImage ;
   OPJ_UINT32 biXpelsPerMeter ;
   OPJ_UINT32 biYpelsPerMeter ;
   OPJ_UINT32 biClrUsed ;
   OPJ_UINT32 biClrImportant ;
   OPJ_UINT32 biRedMask ;
   OPJ_UINT32 biGreenMask ;
   OPJ_UINT32 biBlueMask ;
   OPJ_UINT32 biAlphaMask ;
   OPJ_UINT32 biColorSpaceType ;
   OPJ_UINT8 biColorSpaceEP[36] ;
   OPJ_UINT32 biRedGamma ;
   OPJ_UINT32 biGreenGamma ;
   OPJ_UINT32 biBlueGamma ;
   OPJ_UINT32 biIntent ;
   OPJ_UINT32 biIccProfileData ;
   OPJ_UINT32 biIccProfileSize ;
   OPJ_UINT32 biReserved ;
};
#line 81 "/root/patron-new/39/src/bin/jp2/convertbmp.c"
typedef struct __anonstruct_121 OPJ_BITMAPINFOHEADER;
#line 1492 "/root/patron-new/39/src/bin/jp2/convert.c"
struct pnm_header {
   int width ;
   int height ;
   int maxval ;
   int depth ;
   int format ;
   char rgb ;
   char rgba ;
   char gray ;
   char graya ;
   char bw ;
   char ok ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream ;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 6 "/root/patron-new/39/src/bin/common/opj_getopt.h"
struct opj_option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 11 "/root/patron-new/39/src/bin/common/opj_getopt.h"
typedef struct opj_option opj_option_t;
#line 74 "/root/patron-new/39/src/bin/jp2/opj_compress.c"
struct dircnt {
   char *filename_buf ;
   char **filename ;
};
#line 79 "/root/patron-new/39/src/bin/jp2/opj_compress.c"
typedef struct dircnt dircnt_t;
#line 81 "/root/patron-new/39/src/bin/jp2/opj_compress.c"
struct img_folder {
   char *imgdirpath ;
   char *out_format ;
   char set_imgdir ;
   char set_out_format ;
};
#line 90 "/root/patron-new/39/src/bin/jp2/opj_compress.c"
typedef struct img_folder img_fol_t;
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 198 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int pthread_create(pthread_t *__newthread , pthread_attr_t *__attr ,
                                                        void *(*__start_routine)(void * ) ,
                                                        void *__arg ) ;
#line 215
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
#line 263
extern  __attribute__((__nothrow__)) int pthread_attr_init(pthread_attr_t *__attr ) ;
#line 275
extern  __attribute__((__nothrow__)) int pthread_attr_setdetachstate(pthread_attr_t *__attr ,
                                                                     int __detachstate ) ;
#line 725
extern  __attribute__((__nothrow__)) int pthread_mutex_init(pthread_mutex_t *__mutex ,
                                                            pthread_mutexattr_t *__mutexattr ) ;
#line 730
extern  __attribute__((__nothrow__)) int pthread_mutex_destroy(pthread_mutex_t *__mutex ) ;
#line 738
extern  __attribute__((__nothrow__)) int pthread_mutex_lock(pthread_mutex_t *__mutex ) ;
#line 756
extern  __attribute__((__nothrow__)) int pthread_mutex_unlock(pthread_mutex_t *__mutex ) ;
#line 965
extern  __attribute__((__nothrow__)) int pthread_cond_init(pthread_cond_t *__cond ,
                                                           pthread_condattr_t *__cond_attr ) ;
#line 970
extern  __attribute__((__nothrow__)) int pthread_cond_destroy(pthread_cond_t *__cond ) ;
#line 974
extern  __attribute__((__nothrow__)) int pthread_cond_signal(pthread_cond_t *__cond ) ;
#line 986
extern int pthread_cond_wait(pthread_cond_t *__cond , pthread_mutex_t *__mutex ) ;
#line 101 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double atof(char const   *__nptr ) ;
#line 104
extern  __attribute__((__nothrow__)) int atoi(char const   *__nptr ) ;
#line 539
extern  __attribute__((__nothrow__)) void *malloc(size_t __size ) ;
#line 542
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size ) ;
#line 550
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size ) ;
#line 565
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 580
extern  __attribute__((__nothrow__)) int posix_memalign(void **__memptr , size_t __alignment ,
                                                        size_t __size ) ;
#line 634
extern  __attribute__((__nothrow__)) char *getenv(char const   *__name ) ;
#line 619 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) long sysconf(int __name ) ;
#line 43 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memcpy(void *__dest , void const   *__src ,
                                                  size_t __n ) ;
#line 47
extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                   size_t __n ) ;
#line 61
extern  __attribute__((__nothrow__)) void *memset(void *__s , int __c , size_t __n ) ;
#line 64
extern  __attribute__((__nothrow__)) int memcmp(void const   *__s1 , void const   *__s2 ,
                                                size_t __n ) ;
#line 122
extern  __attribute__((__nothrow__)) char *strcpy(char *__dest , char const   *__src ) ;
#line 125
extern  __attribute__((__nothrow__)) char *strncpy(char *__dest , char const   *__src ,
                                                   size_t __n ) ;
#line 130
extern  __attribute__((__nothrow__)) char *strcat(char *__dest , char const   *__src ) ;
#line 137
extern  __attribute__((__nothrow__)) int strcmp(char const   *__s1 , char const   *__s2 ) ;
#line 140
extern  __attribute__((__nothrow__)) int strncmp(char const   *__s1 , char const   *__s2 ,
                                                 size_t __n ) ;
#line 226
extern  __attribute__((__nothrow__)) char *strchr(char const   *__s , int __c ) ;
#line 253
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c ) ;
#line 303
extern  __attribute__((__nothrow__)) char *strpbrk(char const   *__s , char const   *__accept ) ;
#line 330
extern  __attribute__((__nothrow__)) char *strstr(char const   *__haystack , char const   *__needle ) ;
#line 336
extern  __attribute__((__nothrow__)) char *strtok(char *__s , char const   *__delim ) ;
#line 385
extern  __attribute__((__nothrow__)) unsigned long strlen(char const   *__s ) ;
#line 116 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) int strcasecmp(char const   *__s1 , char const   *__s2 ) ;
#line 140 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double pow(double __x , double __y ) ;
#line 143
extern  __attribute__((__nothrow__)) double sqrt(double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) double ceil(double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) double floor(double __x ) ;
#line 314
extern  __attribute__((__nothrow__)) long lrintf(float __x ) ;
#line 138 "/usr/include/stdio.h"
extern FILE *stdout ;
#line 139
extern FILE *stderr ;
#line 146
extern  __attribute__((__nothrow__)) int remove(char const   *__filename ) ;
#line 213
extern int fclose(FILE *__stream ) ;
#line 246
extern FILE *fopen(char const   *__filename , char const   *__modes ) ;
#line 326
extern int fprintf(FILE *__stream , char const   *__format  , ...) ;
#line 332
extern int printf(char const   *__format  , ...) ;
#line 334
extern  __attribute__((__nothrow__)) int sprintf(char *__s , char const   *__format 
                                                 , ...) ;
#line 358
extern  __attribute__((__nothrow__)) int vsnprintf(char *__s , size_t __maxlen , char const   *__format ,
                                                   __gnuc_va_list __arg ) ;
#line 391
extern int fscanf(FILE *__stream , char const   *__format  , ...) ;
#line 399
extern  __attribute__((__nothrow__)) int sscanf(char const   *__s , char const   *__format 
                                                , ...) ;
#line 485
extern int fgetc(FILE *__stream ) ;
#line 486
extern int getc(FILE *__stream ) ;
#line 564
extern char *fgets(char *__s , int __n , FILE *__stream ) ;
#line 626
extern int fputs(char const   *__s , FILE *__stream ) ;
#line 646
extern unsigned long fread(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 652
extern unsigned long fwrite(void const   *__ptr , size_t __size , size_t __n , FILE *__s ) ;
#line 684
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 689
extern long ftell(FILE *__stream ) ;
#line 707
extern int fseeko(FILE *__stream , __off_t __off , int __whence ) ;
#line 712
extern __off_t ftello(FILE *__stream ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void) ;
#line 1096 "/root/patron-new/39/src/lib/openjp2/openjpeg.h"
char const   *opj_version(void) ;
#line 1112
opj_image_t *opj_image_create(OPJ_UINT32 numcmpts , opj_image_cmptparm_t *cmptparms ,
                              OPJ_COLOR_SPACE clrspc ) ;
#line 1120
void opj_image_destroy(opj_image_t *image___12 ) ;
#line 1131
opj_image_t *opj_image_tile_create(OPJ_UINT32 numcmpts___0 , opj_image_cmptparm_t *cmptparms___0 ,
                                   OPJ_COLOR_SPACE clrspc___0 ) ;
#line 1143
void *opj_image_data_alloc(OPJ_SIZE_T size___6 ) ;
#line 1153
void opj_image_data_free(void *ptr___6 ) ;
#line 1168
opj_stream_t *opj_stream_default_create(OPJ_BOOL l_is_input___0 ) ;
#line 1179
opj_stream_t *opj_stream_create(OPJ_SIZE_T p_buffer_size , OPJ_BOOL l_is_input ) ;
#line 1188
void opj_stream_destroy(opj_stream_t *p_stream___72 ) ;
#line 1195
void opj_stream_set_read_function(opj_stream_t *p_stream___73 , OPJ_SIZE_T (*p_function)(void * ,
                                                                                         OPJ_SIZE_T  ,
                                                                                         void * ) ) ;
#line 1203
void opj_stream_set_write_function(opj_stream_t *p_stream___75 , OPJ_SIZE_T (*p_function___1)(void * ,
                                                                                              OPJ_SIZE_T  ,
                                                                                              void * ) ) ;
#line 1211
void opj_stream_set_skip_function(opj_stream_t *p_stream___76 , OPJ_OFF_T (*p_function___2)(OPJ_OFF_T  ,
                                                                                            void * ) ) ;
#line 1220
void opj_stream_set_seek_function(opj_stream_t *p_stream___74 , OPJ_BOOL (*p_function___0)(OPJ_OFF_T  ,
                                                                                           void * ) ) ;
#line 1229
void opj_stream_set_user_data(opj_stream_t *p_stream___77 , void *p_data___17 , void (*p_function___3)(void * ) ) ;
#line 1238
void opj_stream_set_user_data_length(opj_stream_t *p_stream___78 , OPJ_UINT64 data_length ) ;
#line 1246
opj_stream_t *opj_stream_create_default_file_stream(char const   *fname , OPJ_BOOL p_is_read_stream ) ;
#line 1254
opj_stream_t *opj_stream_create_file_stream(char const   *fname___0 , OPJ_SIZE_T p_size ,
                                            OPJ_BOOL p_is_read_stream___0 ) ;
#line 1270
OPJ_BOOL opj_set_info_handler(opj_codec_t *p_codec , void (*p_callback)(char const   * ,
                                                                        void * ) ,
                              void *p_user_data ) ;
#line 1279
OPJ_BOOL opj_set_warning_handler(opj_codec_t *p_codec___0 , void (*p_callback___0)(char const   * ,
                                                                                   void * ) ,
                                 void *p_user_data___0 ) ;
#line 1288
OPJ_BOOL opj_set_error_handler(opj_codec_t *p_codec___1 , void (*p_callback___1)(char const   * ,
                                                                                 void * ) ,
                               void *p_user_data___1 ) ;
#line 1304
opj_codec_t *opj_create_decompress(OPJ_CODEC_FORMAT p_format ) ;
#line 1312
void opj_destroy_codec(opj_codec_t *p_codec___18 ) ;
#line 1319
OPJ_BOOL opj_end_decompress(opj_codec_t *p_codec___16 , opj_stream_t *p_stream___7 ) ;
#line 1327
void opj_set_default_decoder_parameters(opj_dparameters_t *parameters ) ;
#line 1339
OPJ_BOOL opj_setup_decoder(opj_codec_t *p_codec___3 , opj_dparameters_t *parameters___0 ) ;
#line 1360
OPJ_BOOL opj_codec_set_threads(opj_codec_t *p_codec___2 , int num_threads ) ;
#line 1372
OPJ_BOOL opj_read_header(opj_stream_t *p_stream , opj_codec_t *p_codec___4 , opj_image_t **p_image ) ;
#line 1402
OPJ_BOOL opj_set_decoded_components(opj_codec_t *p_codec___5 , OPJ_UINT32 numcomps ,
                                    OPJ_UINT32 *comps_indices , OPJ_BOOL apply_color_transforms ) ;
#line 1429
OPJ_BOOL opj_set_decode_area(opj_codec_t *p_codec___7 , opj_image_t *p_image___1 ,
                             OPJ_INT32 p_start_x , OPJ_INT32 p_start_y , OPJ_INT32 p_end_x ,
                             OPJ_INT32 p_end_y ) ;
#line 1442
OPJ_BOOL opj_decode(opj_codec_t *p_codec___6 , opj_stream_t *p_stream___0 , opj_image_t *p_image___0 ) ;
#line 1456
OPJ_BOOL opj_get_decoded_tile(opj_codec_t *p_codec___10 , opj_stream_t *p_stream___3 ,
                              opj_image_t *p_image___2 , OPJ_UINT32 tile_index ) ;
#line 1468
OPJ_BOOL opj_set_decoded_resolution_factor(opj_codec_t *p_codec___11 , OPJ_UINT32 res_factor ) ;
#line 1483
OPJ_BOOL opj_write_tile(opj_codec_t *p_codec___17 , OPJ_UINT32 p_tile_index___1 ,
                        OPJ_BYTE *p_data___0 , OPJ_UINT32 p_data_size___1 , opj_stream_t *p_stream___8 ) ;
#line 1510
OPJ_BOOL opj_read_tile_header(opj_codec_t *p_codec___8 , opj_stream_t *p_stream___1 ,
                              OPJ_UINT32 *p_tile_index , OPJ_UINT32 *p_data_size ,
                              OPJ_INT32 *p_tile_x0 , OPJ_INT32 *p_tile_y0 , OPJ_INT32 *p_tile_x1 ,
                              OPJ_INT32 *p_tile_y1 , OPJ_UINT32 *p_nb_comps , OPJ_BOOL *p_should_go_on ) ;
#line 1533
OPJ_BOOL opj_decode_tile_data(opj_codec_t *p_codec___9 , OPJ_UINT32 p_tile_index___0 ,
                              OPJ_BYTE *p_data , OPJ_UINT32 p_data_size___0 , opj_stream_t *p_stream___2 ) ;
#line 1546
opj_codec_t *opj_create_compress(OPJ_CODEC_FORMAT p_format___0 ) ;
#line 1569
void opj_set_default_encoder_parameters(opj_cparameters_t *parameters___1 ) ;
#line 1578
OPJ_BOOL opj_setup_encoder(opj_codec_t *p_codec___12 , opj_cparameters_t *parameters___2 ,
                           opj_image_t *p_image___3 ) ;
#line 1605
OPJ_BOOL opj_encoder_set_extra_options(opj_codec_t *p_codec___13 , char const   * const  *options ) ;
#line 1615
OPJ_BOOL opj_start_compress(opj_codec_t *p_codec___14 , opj_image_t *p_image___4 ,
                            opj_stream_t *p_stream___4 ) ;
#line 1624
OPJ_BOOL opj_end_compress(opj_codec_t *p_codec___15 , opj_stream_t *p_stream___6 ) ;
#line 1634
OPJ_BOOL opj_encode(opj_codec_t *p_info , opj_stream_t *p_stream___5 ) ;
#line 1647
void opj_destroy_cstr_info(opj_codestream_info_v2_t **cstr_info ) ;
#line 1659
void opj_dump_codec(opj_codec_t *p_codec___19 , OPJ_INT32 info_flag , FILE *output_stream ) ;
#line 1671
opj_codestream_info_v2_t *opj_get_cstr_info(opj_codec_t *p_codec___20 ) ;
#line 1682
opj_codestream_index_t *opj_get_cstr_index(opj_codec_t *p_codec___21 ) ;
#line 1685
void opj_destroy_cstr_index(opj_codestream_index_t **p_cstr_index ) ;
#line 1727
OPJ_BOOL opj_set_MCT(opj_cparameters_t *parameters___3 , OPJ_FLOAT32 *pEncodingMatrix ,
                     OPJ_INT32 *p_dc_shift , OPJ_UINT32 pNbComp ) ;
#line 1741
OPJ_BOOL opj_has_thread_support(void) ;
#line 1744
int opj_get_num_cpus(void) ;
#line 174 "/root/patron-new/39/src/lib/openjp2/opj_includes.h"
__inline static long opj_lrintf(float f ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 176
  __cil_tmp2 = lrintf(f);
  }
#line 176
  return (__cil_tmp2);
}
}
#line 51 "/root/patron-new/39/src/lib/openjp2/opj_clock.h"
OPJ_FLOAT64 opj_clock(void) ;
#line 55 "/root/patron-new/39/src/lib/openjp2/opj_malloc.h"
void *opj_malloc(size_t size___0 ) ;
#line 63
void *opj_calloc(size_t num , size_t size___1 ) ;
#line 70
void *opj_aligned_malloc(size_t size___2 ) ;
#line 71
void *opj_aligned_realloc(void *ptr___1 , size_t size___3 ) ;
#line 72
void opj_aligned_free(void *ptr___3 ) ;
#line 79
void *opj_aligned_32_malloc(size_t size___4 ) ;
#line 80
void *opj_aligned_32_realloc(void *ptr___2 , size_t size___5 ) ;
#line 88
void *opj_realloc(void *ptr___4 , size_t new_size___0 ) ;
#line 94
void opj_free(void *ptr___5 ) ;
#line 89 "/root/patron-new/39/src/lib/openjp2/event.h"
OPJ_BOOL opj_event_msg(opj_event_mgr_t *p_event_mgr , OPJ_INT32 event_type , char const   *fmt 
                       , ...) ;
#line 96
void opj_set_default_event_handler(opj_event_mgr_t *p_manager___150 ) ;
#line 80 "/root/patron-new/39/src/lib/openjp2/function_list.h"
opj_procedure_list_t *opj_procedure_list_create(void) ;
#line 87
void opj_procedure_list_destroy(opj_procedure_list_t *p_list ) ;
#line 98
OPJ_BOOL opj_procedure_list_add_procedure(opj_procedure_list_t *p_validation_list ,
                                          void (*p_procedure)(void) , opj_event_mgr_t *p_manager___149 ) ;
#line 108
OPJ_UINT32 opj_procedure_list_get_nb_procedures(opj_procedure_list_t *p_validation_list___0 ) ;
#line 120
opj_procedure *opj_procedure_list_get_first_procedure(opj_procedure_list_t *p_validation_list___1 ) ;
#line 130
void opj_procedure_list_clear(opj_procedure_list_t *p_validation_list___2 ) ;
#line 76 "/root/patron-new/39/src/lib/openjp2/bio.h"
opj_bio_t *opj_bio_create(void) ;
#line 81
void opj_bio_destroy(opj_bio_t *bio___4 ) ;
#line 87
ptrdiff_t opj_bio_numbytes(opj_bio_t *bio___5 ) ;
#line 94
void opj_bio_init_enc(opj_bio_t *bio___6 , OPJ_BYTE *bp___3 , OPJ_UINT32 len___4 ) ;
#line 101
void opj_bio_init_dec(opj_bio_t *bio___7 , OPJ_BYTE *bp___4 , OPJ_UINT32 len___5 ) ;
#line 108
void opj_bio_write(opj_bio_t *bio___8 , OPJ_UINT32 v , OPJ_UINT32 n___1 ) ;
#line 115
OPJ_UINT32 opj_bio_read(opj_bio_t *bio___9 , OPJ_UINT32 n___2 ) ;
#line 121
OPJ_BOOL opj_bio_flush(opj_bio_t *bio___10 ) ;
#line 127
OPJ_BOOL opj_bio_inalign(opj_bio_t *bio___11 ) ;
#line 176 "/root/patron-new/39/src/lib/openjp2/cio.h"
void opj_write_bytes_BE(OPJ_BYTE *p_buffer___1 , OPJ_UINT32 p_value , OPJ_UINT32 p_nb_bytes___3 ) ;
#line 186
void opj_read_bytes_BE(OPJ_BYTE *p_buffer___3 , OPJ_UINT32 *p_value___1 , OPJ_UINT32 p_nb_bytes___5 ) ;
#line 196
void opj_write_bytes_LE(OPJ_BYTE *p_buffer___2 , OPJ_UINT32 p_value___0 , OPJ_UINT32 p_nb_bytes___4 ) ;
#line 206
void opj_read_bytes_LE(OPJ_BYTE *p_buffer___4 , OPJ_UINT32 *p_value___2 , OPJ_UINT32 p_nb_bytes___6 ) ;
#line 215
void opj_write_double_LE(OPJ_BYTE *p_buffer___6 , OPJ_FLOAT64 p_value___4 ) ;
#line 222
void opj_write_double_BE(OPJ_BYTE *p_buffer___5 , OPJ_FLOAT64 p_value___3 ) ;
#line 229
void opj_read_double_LE(OPJ_BYTE *p_buffer___8 , OPJ_FLOAT64 *p_value___6 ) ;
#line 236
void opj_read_double_BE(OPJ_BYTE *p_buffer___7 , OPJ_FLOAT64 *p_value___5 ) ;
#line 243
void opj_read_float_LE(OPJ_BYTE *p_buffer___12 , OPJ_FLOAT32 *p_value___10 ) ;
#line 250
void opj_read_float_BE(OPJ_BYTE *p_buffer___11 , OPJ_FLOAT32 *p_value___9 ) ;
#line 257
void opj_write_float_LE(OPJ_BYTE *p_buffer___10 , OPJ_FLOAT32 p_value___8 ) ;
#line 264
void opj_write_float_BE(OPJ_BYTE *p_buffer___9 , OPJ_FLOAT32 p_value___7 ) ;
#line 274
OPJ_SIZE_T opj_stream_read_data(opj_stream_private_t *p_stream___79 , OPJ_BYTE *p_buffer___13 ,
                                OPJ_SIZE_T p_size___0 , opj_event_mgr_t *p_event_mgr___0 ) ;
#line 285
OPJ_SIZE_T opj_stream_write_data(opj_stream_private_t *p_stream___80 , OPJ_BYTE *p_buffer___14 ,
                                 OPJ_SIZE_T p_size___1 , opj_event_mgr_t *p_event_mgr___1 ) ;
#line 295
OPJ_BOOL opj_stream_flush(opj_stream_private_t *p_stream___81 , opj_event_mgr_t *p_event_mgr___2 ) ;
#line 305
OPJ_OFF_T opj_stream_skip(opj_stream_private_t *p_stream___86 , OPJ_OFF_T p_size___4 ,
                          opj_event_mgr_t *p_event_mgr___5 ) ;
#line 315
OPJ_OFF_T opj_stream_tell(opj_stream_private_t *p_stream___84 ) ;
#line 325
OPJ_OFF_T opj_stream_get_number_byte_left(opj_stream_private_t *p_stream___85 ) ;
#line 335
OPJ_OFF_T opj_stream_write_skip(opj_stream_private_t *p_stream___83 , OPJ_OFF_T p_size___3 ,
                                opj_event_mgr_t *p_event_mgr___4 ) ;
#line 345
OPJ_OFF_T opj_stream_read_skip(opj_stream_private_t *p_stream___82 , OPJ_OFF_T p_size___2 ,
                               opj_event_mgr_t *p_event_mgr___3 ) ;
#line 355
OPJ_BOOL opj_stream_read_seek(opj_stream_private_t *p_stream___87 , OPJ_OFF_T p_size___5 ,
                              opj_event_mgr_t *p_event_mgr___6 ) ;
#line 365
OPJ_BOOL opj_stream_write_seek(opj_stream_private_t *p_stream___88 , OPJ_OFF_T p_size___6 ,
                               opj_event_mgr_t *p_event_mgr___7 ) ;
#line 375
OPJ_BOOL opj_stream_seek(opj_stream_private_t *p_stream___89 , OPJ_OFF_T p_size___7 ,
                         struct opj_event_mgr *p_event_mgr___8 ) ;
#line 381
OPJ_BOOL opj_stream_has_seek(opj_stream_private_t *p_stream___90 ) ;
#line 386
OPJ_SIZE_T opj_stream_default_read(void *p_buffer___15 , OPJ_SIZE_T p_nb_bytes___7 ,
                                   void *p_user_data___4 ) ;
#line 392
OPJ_SIZE_T opj_stream_default_write(void *p_buffer___16 , OPJ_SIZE_T p_nb_bytes___8 ,
                                    void *p_user_data___5 ) ;
#line 398
OPJ_OFF_T opj_stream_default_skip(OPJ_OFF_T p_nb_bytes___9 , void *p_user_data___6 ) ;
#line 403
OPJ_BOOL opj_stream_default_seek(OPJ_OFF_T p_nb_bytes___10 , void *p_user_data___7 ) ;
#line 58 "/root/patron-new/39/src/lib/openjp2/thread.h"
opj_mutex_t *opj_mutex_create(void) ;
#line 63
void opj_mutex_lock(opj_mutex_t *mutex ) ;
#line 68
void opj_mutex_unlock(opj_mutex_t *mutex ) ;
#line 73
void opj_mutex_destroy(opj_mutex_t *mutex ) ;
#line 87
opj_cond_t *opj_cond_create(void) ;
#line 120
void opj_cond_wait(opj_cond_t *cond , opj_mutex_t *mutex ) ;
#line 128
void opj_cond_signal(opj_cond_t *cond ) ;
#line 133
void opj_cond_destroy(opj_cond_t *cond ) ;
#line 154
opj_thread_t *opj_thread_create(void (*thread_fn)(void * ) , void *user_data ) ;
#line 160
void opj_thread_join(opj_thread_t *thread ) ;
#line 174
void *opj_tls_get(opj_tls_t *tls , int key ) ;
#line 186
OPJ_BOOL opj_tls_set(opj_tls_t *tls , int key , void *value , void (*opj_free_func)(void * ) ) ;
#line 207
opj_thread_pool_t *opj_thread_pool_create(int num_threads ) ;
#line 225
OPJ_BOOL opj_thread_pool_submit_job(opj_thread_pool_t *tp , void (*job_fn)(void * ,
                                                                           opj_tls_t * ) ,
                                    void *user_data ) ;
#line 237
void opj_thread_pool_wait_completion(opj_thread_pool_t *tp , int max_remaining_jobs ) ;
#line 245
int opj_thread_pool_get_thread_count(opj_thread_pool_t *tp ) ;
#line 250
void opj_thread_pool_destroy(opj_thread_pool_t *tp ) ;
#line 51 "/root/patron-new/39/src/lib/openjp2/image.h"
opj_image_t *opj_image_create0(void) ;
#line 61
void opj_image_comp_header_update(opj_image_t *p_image_header , struct opj_cp *p_cp___1 ) ;
#line 64
void opj_copy_image_header(opj_image_t *p_image_src , opj_image_t *p_image_dest ) ;
#line 56 "/root/patron-new/39/src/lib/openjp2/invert.h"
OPJ_BOOL opj_matrix_inversion_f(OPJ_FLOAT32 *pSrcMatrix , OPJ_FLOAT32 *pDestMatrix ,
                                OPJ_UINT32 nb_compo ) ;
#line 613 "/root/patron-new/39/src/lib/openjp2/j2k.h"
void opj_j2k_setup_decoder(opj_j2k_t *j2k , opj_dparameters_t *parameters___6 ) ;
#line 615
OPJ_BOOL opj_j2k_set_threads(opj_j2k_t *j2k___0 , OPJ_UINT32 num_threads___1 ) ;
#line 622
opj_j2k_t *opj_j2k_create_compress(void) ;
#line 625
OPJ_BOOL opj_j2k_setup_encoder(opj_j2k_t *p_j2k___58 , opj_cparameters_t *parameters___11 ,
                               opj_image_t *image___9 , opj_event_mgr_t *p_manager___101 ) ;
#line 633
char const   *opj_j2k_convert_progression_order(OPJ_PROG_ORDER prg_order ) ;
#line 644
OPJ_BOOL opj_j2k_end_decompress(opj_j2k_t *p_j2k___59 , opj_stream_private_t *p_stream___42 ,
                                opj_event_mgr_t *p_manager___102 ) ;
#line 658
OPJ_BOOL opj_j2k_read_header(opj_stream_private_t *p_stream___43 , opj_j2k_t *p_j2k___60 ,
                             opj_image_t **p_image___11 , opj_event_mgr_t *p_manager___103 ) ;
#line 669
void opj_j2k_destroy(opj_j2k_t *p_j2k___71 ) ;
#line 676
void j2k_destroy_cstr_index(opj_codestream_index_t *p_cstr_ind ) ;
#line 687
OPJ_BOOL opj_j2k_decode_tile(opj_j2k_t *p_j2k___73 , OPJ_UINT32 p_tile_index___6 ,
                             OPJ_BYTE *p_data___10 , OPJ_UINT32 p_data_size___6 ,
                             opj_stream_private_t *p_stream___54 , opj_event_mgr_t *p_manager___116 ) ;
#line 708
OPJ_BOOL opj_j2k_read_tile_header(opj_j2k_t *p_j2k___72 , OPJ_UINT32 *p_tile_index___5 ,
                                  OPJ_UINT32 *p_data_size___5 , OPJ_INT32 *p_tile_x0___1 ,
                                  OPJ_INT32 *p_tile_y0___1 , OPJ_INT32 *p_tile_x1___1 ,
                                  OPJ_INT32 *p_tile_y1___1 , OPJ_UINT32 *p_nb_comps___1 ,
                                  OPJ_BOOL *p_go_on___0 , opj_stream_private_t *p_stream___53 ,
                                  opj_event_mgr_t *p_manager___115 ) ;
#line 731
OPJ_BOOL opj_j2k_set_decoded_components(opj_j2k_t *p_j2k___74 , OPJ_UINT32 numcomps___1 ,
                                        OPJ_UINT32 *comps_indices___1 , opj_event_mgr_t *p_manager___118 ) ;
#line 749
OPJ_BOOL opj_j2k_set_decode_area(opj_j2k_t *p_j2k___75 , opj_image_t *p_image___14 ,
                                 OPJ_INT32 p_start_x___1 , OPJ_INT32 p_start_y___1 ,
                                 OPJ_INT32 p_end_x___1 , OPJ_INT32 p_end_y___1 , opj_event_mgr_t *p_manager___119 ) ;
#line 760
opj_j2k_t *opj_j2k_create_decompress(void) ;
#line 771
void j2k_dump(opj_j2k_t *p_j2k___86 , OPJ_INT32 flag___0 , FILE *out_stream___1 ) ;
#line 782
void j2k_dump_image_header(opj_image_t *img_header , OPJ_BOOL dev_dump_flag , FILE *out_stream___4 ) ;
#line 792
void j2k_dump_image_comp_header(opj_image_comp_t *comp_header , OPJ_BOOL dev_dump_flag___0 ,
                                FILE *out_stream___5 ) ;
#line 802
opj_codestream_info_v2_t *j2k_get_cstr_info(opj_j2k_t *p_j2k___89 ) ;
#line 811
opj_codestream_index_t *j2k_get_cstr_index(opj_j2k_t *p_j2k___90 ) ;
#line 821
OPJ_BOOL opj_j2k_decode(opj_j2k_t *p_j2k___98 , opj_stream_private_t *p_stream___57 ,
                        opj_image_t *p_image___16 , opj_event_mgr_t *p_manager___129 ) ;
#line 827
OPJ_BOOL opj_j2k_get_tile(opj_j2k_t *p_j2k___99 , opj_stream_private_t *p_stream___58 ,
                          opj_image_t *p_image___17 , opj_event_mgr_t *p_manager___130 ,
                          OPJ_UINT32 tile_index___1 ) ;
#line 833
OPJ_BOOL opj_j2k_set_decoded_resolution_factor(opj_j2k_t *p_j2k___100 , OPJ_UINT32 res_factor___1 ,
                                               opj_event_mgr_t *p_manager___131 ) ;
#line 846
OPJ_BOOL opj_j2k_encoder_set_extra_options(opj_j2k_t *p_j2k___101 , char const   * const  *p_options___0 ,
                                           opj_event_mgr_t *p_manager___132 ) ;
#line 860
OPJ_BOOL opj_j2k_write_tile(opj_j2k_t *p_j2k___117 , OPJ_UINT32 p_tile_index___8 ,
                            OPJ_BYTE *p_data___16 , OPJ_UINT32 p_data_size___7 , opj_stream_private_t *p_stream___71 ,
                            opj_event_mgr_t *p_manager___148 ) ;
#line 870
OPJ_BOOL opj_j2k_encode(opj_j2k_t *p_j2k___102 , opj_stream_private_t *p_stream___59 ,
                        opj_event_mgr_t *p_manager___133 ) ;
#line 884
OPJ_BOOL opj_j2k_start_compress(opj_j2k_t *p_j2k___104 , opj_stream_private_t *p_stream___61 ,
                                opj_image_t *p_image___18 , opj_event_mgr_t *p_manager___135 ) ;
#line 893
OPJ_BOOL opj_j2k_end_compress(opj_j2k_t *p_j2k___103 , opj_stream_private_t *p_stream___60 ,
                              opj_event_mgr_t *p_manager___134 ) ;
#line 897
OPJ_BOOL opj_j2k_setup_mct_encoding(opj_tcp_t *p_tcp___3 , opj_image_t *p_image___12 ) ;
#line 236 "/root/patron-new/39/src/lib/openjp2/jp2.h"
void opj_jp2_setup_decoder(opj_jp2_t *jp2___14 , opj_dparameters_t *parameters___4 ) ;
#line 244
OPJ_BOOL opj_jp2_set_threads(opj_jp2_t *jp2___15 , OPJ_UINT32 num_threads___0 ) ;
#line 255
OPJ_BOOL opj_jp2_decode(opj_jp2_t *jp2___9 , opj_stream_private_t *p_stream___9 ,
                        opj_image_t *p_image___5 , opj_event_mgr_t *p_manager___8 ) ;
#line 270
OPJ_BOOL opj_jp2_setup_encoder(opj_jp2_t *jp2___16 , opj_cparameters_t *parameters___5 ,
                               opj_image_t *image___2 , opj_event_mgr_t *p_manager___13 ) ;
#line 282
OPJ_BOOL opj_jp2_encode(opj_jp2_t *jp2___17 , opj_stream_private_t *stream___0 , opj_event_mgr_t *p_manager___14 ) ;
#line 297
OPJ_BOOL opj_jp2_start_compress(opj_jp2_t *jp2___25 , opj_stream_private_t *stream___3 ,
                                opj_image_t *p_image___6 , opj_event_mgr_t *p_manager___22 ) ;
#line 307
OPJ_BOOL opj_jp2_end_compress(opj_jp2_t *jp2___19 , opj_stream_private_t *cio___4 ,
                              opj_event_mgr_t *p_manager___16 ) ;
#line 317
OPJ_BOOL opj_jp2_end_decompress(opj_jp2_t *jp2___18 , opj_stream_private_t *cio___3 ,
                                opj_event_mgr_t *p_manager___15 ) ;
#line 331
OPJ_BOOL opj_jp2_read_header(opj_stream_private_t *p_stream___10 , opj_jp2_t *jp2___31 ,
                             opj_image_t **p_image___7 , opj_event_mgr_t *p_manager___29 ) ;
#line 346
OPJ_BOOL opj_jp2_set_decoded_components(opj_jp2_t *p_jp2___2 , OPJ_UINT32 numcomps___0 ,
                                        OPJ_UINT32 *comps_indices___0 , opj_event_mgr_t *p_manager___37 ) ;
#line 365
OPJ_BOOL opj_jp2_read_tile_header(opj_jp2_t *p_jp2 , OPJ_UINT32 *p_tile_index___2 ,
                                  OPJ_UINT32 *p_data_size___2 , OPJ_INT32 *p_tile_x0___0 ,
                                  OPJ_INT32 *p_tile_y0___0 , OPJ_INT32 *p_tile_x1___0 ,
                                  OPJ_INT32 *p_tile_y1___0 , OPJ_UINT32 *p_nb_comps___0 ,
                                  OPJ_BOOL *p_go_on , opj_stream_private_t *p_stream___11 ,
                                  opj_event_mgr_t *p_manager___34 ) ;
#line 387
OPJ_BOOL opj_jp2_write_tile(opj_jp2_t *p_jp2___0 , OPJ_UINT32 p_tile_index___3 , OPJ_BYTE *p_data___2 ,
                            OPJ_UINT32 p_data_size___3 , opj_stream_private_t *p_stream___12 ,
                            opj_event_mgr_t *p_manager___35 ) ;
#line 405
OPJ_BOOL opj_jp2_decode_tile(opj_jp2_t *p_jp2___1 , OPJ_UINT32 p_tile_index___4 ,
                             OPJ_BYTE *p_data___3 , OPJ_UINT32 p_data_size___4 , opj_stream_private_t *p_stream___13 ,
                             opj_event_mgr_t *p_manager___36 ) ;
#line 417
opj_jp2_t *opj_jp2_create(OPJ_BOOL p_is_decoder ) ;
#line 423
void opj_jp2_destroy(opj_jp2_t *jp2___36 ) ;
#line 439
OPJ_BOOL opj_jp2_set_decode_area(opj_jp2_t *p_jp2___3 , opj_image_t *p_image___8 ,
                                 OPJ_INT32 p_start_x___0 , OPJ_INT32 p_start_y___0 ,
                                 OPJ_INT32 p_end_x___0 , OPJ_INT32 p_end_y___0 , opj_event_mgr_t *p_manager___38 ) ;
#line 448
OPJ_BOOL opj_jp2_get_tile(opj_jp2_t *p_jp2___4 , opj_stream_private_t *p_stream___14 ,
                          opj_image_t *p_image___9 , opj_event_mgr_t *p_manager___39 ,
                          OPJ_UINT32 tile_index___0 ) ;
#line 458
OPJ_BOOL opj_jp2_set_decoded_resolution_factor(opj_jp2_t *p_jp2___8 , OPJ_UINT32 res_factor___0 ,
                                               opj_event_mgr_t *p_manager___40 ) ;
#line 471
OPJ_BOOL opj_jp2_encoder_set_extra_options(opj_jp2_t *p_jp2___9 , char const   * const  *p_options ,
                                           opj_event_mgr_t *p_manager___41 ) ;
#line 486
void jp2_dump(opj_jp2_t *p_jp2___5 , OPJ_INT32 flag , FILE *out_stream ) ;
#line 495
opj_codestream_info_v2_t *jp2_get_cstr_info(opj_jp2_t *p_jp2___7 ) ;
#line 504
opj_codestream_index_t *jp2_get_cstr_index(opj_jp2_t *p_jp2___6 ) ;
#line 175 "/root/patron-new/39/src/lib/openjp2/mqc_inl.h"
__inline static void opj_mqc_bytein(opj_mqc_t *mqc ) 
{ 
  OPJ_UINT32 l_c ;

  {
#line 177
  l_c = (OPJ_UINT32 )*(mqc->bp + 1);
#line 177
  if ((int )*(mqc->bp) == 255) {
#line 177
    if (l_c > 143U) {
#line 177
      mqc->c += 65280U;
#line 177
      mqc->ct = (OPJ_UINT32 )8;
#line 177
      (mqc->end_of_byte_stream_counter) ++;
    } else {
#line 177
      (mqc->bp) ++;
#line 177
      mqc->c += l_c << 9;
#line 177
      mqc->ct = (OPJ_UINT32 )7;
    }
  } else {
#line 177
    (mqc->bp) ++;
#line 177
    mqc->c += l_c << 8;
#line 177
    mqc->ct = (OPJ_UINT32 )8;
  }
#line 180
  return;
}
}
#line 110 "/root/patron-new/39/src/lib/openjp2/mqc.h"
OPJ_UINT32 opj_mqc_numbytes(opj_mqc_t *mqc___4 ) ;
#line 116
void opj_mqc_resetstates(opj_mqc_t *mqc___20 ) ;
#line 124
void opj_mqc_setstate(opj_mqc_t *mqc___21 , OPJ_UINT32 ctxno , OPJ_UINT32 msb , OPJ_INT32 prob ) ;
#line 131
void opj_mqc_init_enc(opj_mqc_t *mqc___5 , OPJ_BYTE *bp ) ;
#line 143
void opj_mqc_encode(opj_mqc_t *mqc___6 , OPJ_UINT32 d ) ;
#line 148
void opj_mqc_flush(opj_mqc_t *mqc___7 ) ;
#line 154
void opj_mqc_bypass_init_enc(opj_mqc_t *mqc___8 ) ;
#line 161
OPJ_UINT32 opj_mqc_bypass_get_extra_bytes(opj_mqc_t *mqc___10 , OPJ_BOOL erterm ) ;
#line 169
void opj_mqc_bypass_enc(opj_mqc_t *mqc___9 , OPJ_UINT32 d___0 ) ;
#line 175
void opj_mqc_bypass_flush_enc(opj_mqc_t *mqc___11 , OPJ_BOOL erterm___0 ) ;
#line 180
void opj_mqc_reset_enc(opj_mqc_t *mqc___12 ) ;
#line 195
void opj_mqc_restart_init_enc(opj_mqc_t *mqc___13 ) ;
#line 200
void opj_mqc_erterm_enc(opj_mqc_t *mqc___14 ) ;
#line 205
void opj_mqc_segmark_enc(opj_mqc_t *mqc___15 ) ;
#line 225
void opj_mqc_init_dec(opj_mqc_t *mqc___17 , OPJ_BYTE *bp___1 , OPJ_UINT32 len___0 ,
                      OPJ_UINT32 extra_writable_bytes___0 ) ;
#line 246
void opj_mqc_raw_init_dec(opj_mqc_t *mqc___18 , OPJ_BYTE *bp___2 , OPJ_UINT32 len___1 ,
                          OPJ_UINT32 extra_writable_bytes___1 ) ;
#line 258
void opq_mqc_finish_dec(opj_mqc_t *mqc___19 ) ;
#line 125 "/root/patron-new/39/src/lib/openjp2/pi.h"
extern opj_pi_iterator_t *opj_pi_initialise_encode(opj_image_t *image , opj_cp_t *cp ,
                                                   OPJ_UINT32 tileno , J2K_T2_MODE t2_mode ) ;
#line 137
extern void opj_pi_update_encoding_parameters(opj_image_t *p_image , opj_cp_t *p_cp ,
                                              OPJ_UINT32 p_tile_no ) ;
#line 151
extern void opj_pi_create_encode(opj_pi_iterator_t *pi , opj_cp_t *cp , OPJ_UINT32 tileno ,
                                 OPJ_UINT32 pino , OPJ_UINT32 tpnum , OPJ_INT32 tppos ,
                                 J2K_T2_MODE t2_mode ) ;
#line 167
extern opj_pi_iterator_t *opj_pi_create_decode(opj_image_t *image , opj_cp_t *cp ,
                                               OPJ_UINT32 tileno ) ;
#line 176
extern void opj_pi_destroy(opj_pi_iterator_t *p_pi , OPJ_UINT32 p_nb_elements ) ;
#line 184
extern OPJ_BOOL opj_pi_next(opj_pi_iterator_t *pi ) ;
#line 192
extern OPJ_UINT32 opj_get_encoding_packet_count(opj_image_t *p_image , opj_cp_t *p_cp ,
                                                OPJ_UINT32 p_tile_no ) ;
#line 86 "/root/patron-new/39/src/lib/openjp2/tgt.h"
opj_tgt_tree_t *opj_tgt_create(OPJ_UINT32 numleafsh , OPJ_UINT32 numleafsv , opj_event_mgr_t *p_manager ) ;
#line 98
opj_tgt_tree_t *opj_tgt_init(opj_tgt_tree_t *p_tree , OPJ_UINT32 p_num_leafs_h , OPJ_UINT32 p_num_leafs_v ,
                             opj_event_mgr_t *p_manager ) ;
#line 105
void opj_tgt_destroy(opj_tgt_tree_t *p_tree ) ;
#line 110
void opj_tgt_reset(opj_tgt_tree_t *p_tree ) ;
#line 117
void opj_tgt_setvalue(opj_tgt_tree_t *tree , OPJ_UINT32 leafno , OPJ_INT32 value ) ;
#line 127
void opj_tgt_encode(opj_bio_t *bio , opj_tgt_tree_t *tree , OPJ_UINT32 leafno , OPJ_INT32 threshold ) ;
#line 139
OPJ_UINT32 opj_tgt_decode(opj_bio_t *bio , opj_tgt_tree_t *tree , OPJ_UINT32 leafno ,
                          OPJ_INT32 threshold ) ;
#line 317 "/root/patron-new/39/src/lib/openjp2/tcd.h"
opj_tcd_t *opj_tcd_create(OPJ_BOOL p_is_decoder ) ;
#line 323
void opj_tcd_destroy(opj_tcd_t *tcd ) ;
#line 330
opj_tcd_marker_info_t *opj_tcd_marker_info_create(OPJ_BOOL need_PLT ) ;
#line 337
void opj_tcd_marker_info_destroy(opj_tcd_marker_info_t *p_tcd_marker_info ) ;
#line 349
OPJ_BOOL opj_tcd_init(opj_tcd_t *p_tcd , opj_image_t *p_image , opj_cp_t *p_cp , opj_thread_pool_t *p_tp ) ;
#line 364
OPJ_BOOL opj_tcd_init_decode_tile(opj_tcd_t *p_tcd , OPJ_UINT32 p_tile_no , opj_event_mgr_t *p_manager ) ;
#line 367
void opj_tcd_makelayer_fixed(opj_tcd_t *tcd , OPJ_UINT32 layno , OPJ_UINT32 final ) ;
#line 370
void opj_tcd_rateallocate_fixed(opj_tcd_t *tcd ) ;
#line 372
void opj_tcd_makelayer(opj_tcd_t *tcd , OPJ_UINT32 layno , OPJ_FLOAT64 thresh , OPJ_UINT32 final ) ;
#line 377
OPJ_BOOL opj_tcd_rateallocate(opj_tcd_t *tcd , OPJ_BYTE *dest , OPJ_UINT32 *p_data_written ,
                              OPJ_UINT32 len , opj_codestream_info_t *cstr_info ,
                              opj_event_mgr_t *p_manager ) ;
#line 387
OPJ_UINT32 opj_tcd_get_decoded_tile_size(opj_tcd_t *p_tcd , OPJ_BOOL take_into_account_partial_decoding ) ;
#line 402
OPJ_BOOL opj_tcd_encode_tile(opj_tcd_t *p_tcd , OPJ_UINT32 p_tile_no , OPJ_BYTE *p_dest ,
                             OPJ_UINT32 *p_data_written , OPJ_UINT32 p_max_length ,
                             opj_codestream_info_t *p_cstr_info , opj_tcd_marker_info_t *p_marker_info ,
                             opj_event_mgr_t *p_manager ) ;
#line 429
OPJ_BOOL opj_tcd_decode_tile(opj_tcd_t *p_tcd , OPJ_UINT32 win_x0 , OPJ_UINT32 win_y0 ,
                             OPJ_UINT32 win_x1 , OPJ_UINT32 win_y1 , OPJ_UINT32 numcomps_to_decode ,
                             OPJ_UINT32 *comps_indices , OPJ_BYTE *p_src , OPJ_UINT32 p_max_length ,
                             OPJ_UINT32 p_tile_no , opj_codestream_index_t *p_cstr_index ,
                             opj_event_mgr_t *p_manager ) ;
#line 446
OPJ_BOOL opj_tcd_update_tile_data(opj_tcd_t *p_tcd , OPJ_BYTE *p_dest , OPJ_UINT32 p_dest_length ) ;
#line 455
OPJ_SIZE_T opj_tcd_get_encoder_input_buffer_size(opj_tcd_t *p_tcd ) ;
#line 466
OPJ_BOOL opj_tcd_init_encode_tile(opj_tcd_t *p_tcd , OPJ_UINT32 p_tile_no , opj_event_mgr_t *p_manager ) ;
#line 474
OPJ_BOOL opj_tcd_copy_tile_data(opj_tcd_t *p_tcd , OPJ_BYTE *p_src , OPJ_SIZE_T p_src_length ) ;
#line 483
OPJ_BOOL opj_alloc_tile_component_data(opj_tcd_tilecomp_t *l_tilec ) ;
#line 489
OPJ_BOOL opj_tcd_is_band_empty(opj_tcd_band_t *band ) ;
#line 492
void opj_tcd_reinit_segment(opj_tcd_seg_t *seg ) ;
#line 509
OPJ_BOOL opj_tcd_is_subband_area_of_interest(opj_tcd_t *tcd , OPJ_UINT32 compno ,
                                             OPJ_UINT32 resno , OPJ_UINT32 bandno ,
                                             OPJ_UINT32 band_x0 , OPJ_UINT32 band_y0 ,
                                             OPJ_UINT32 band_x1 , OPJ_UINT32 band_y1 ) ;
#line 225 "/root/patron-new/39/src/lib/openjp2/t1.h"
extern OPJ_BOOL opj_t1_encode_cblks(opj_tcd_t *tcd , opj_tcd_tile_t *tile , opj_tcp_t *tcp ,
                                    OPJ_FLOAT64 *mct_norms , OPJ_UINT32 mct_numcomps ) ;
#line 241
extern void opj_t1_decode_cblks(opj_tcd_t *tcd , OPJ_BOOL *pret , opj_tcd_tilecomp_t *tilec ,
                                opj_tccp_t *tccp , opj_event_mgr_t *p_manager , opj_mutex_t *p_manager_mutex ,
                                OPJ_BOOL check_pterm ) ;
#line 62 "/root/patron-new/39/src/lib/openjp2/dwt.h"
extern OPJ_BOOL opj_dwt_encode(opj_tcd_t *p_tcd , opj_tcd_tilecomp_t *tilec ) ;
#line 72
extern OPJ_BOOL opj_dwt_decode(opj_tcd_t *p_tcd , opj_tcd_tilecomp_t *tilec , OPJ_UINT32 numres ) ;
#line 81
extern OPJ_UINT32 opj_dwt_getgain(OPJ_UINT32 orient ) ;
#line 95
extern OPJ_BOOL opj_dwt_encode_real(opj_tcd_t *p_tcd , opj_tcd_tilecomp_t *tilec ) ;
#line 104
extern OPJ_BOOL opj_dwt_decode_real(opj_tcd_t *p_tcd , opj_tcd_tilecomp_t *tilec ,
                                    OPJ_UINT32 numres ) ;
#line 113
extern OPJ_UINT32 opj_dwt_getgain_real(OPJ_UINT32 orient ) ;
#line 126
extern void opj_dwt_calc_explicit_stepsizes(opj_tccp_t *tccp , OPJ_UINT32 prec ) ;
#line 83 "/root/patron-new/39/src/lib/openjp2/t2.h"
OPJ_BOOL opj_t2_encode_packets(opj_t2_t *p_t2 , OPJ_UINT32 p_tile_no , opj_tcd_tile_t *p_tile ,
                               OPJ_UINT32 p_maxlayers , OPJ_BYTE *p_dest , OPJ_UINT32 *p_data_written ,
                               OPJ_UINT32 p_max_len , opj_codestream_info_t *cstr_info ,
                               opj_tcd_marker_info_t *p_marker_info , OPJ_UINT32 p_tp_num ,
                               OPJ_INT32 p_tp_pos , OPJ_UINT32 p_pino , J2K_T2_MODE p_t2_mode ,
                               opj_event_mgr_t *p_manager ) ;
#line 112
OPJ_BOOL opj_t2_decode_packets(opj_tcd_t *tcd , opj_t2_t *p_t2 , OPJ_UINT32 p_tile_no ,
                               opj_tcd_tile_t *p_tile , OPJ_BYTE *p_src , OPJ_UINT32 *p_data_read ,
                               OPJ_UINT32 p_max_len , opj_codestream_index_t *p_cstr_index ,
                               opj_event_mgr_t *p_manager ) ;
#line 129
opj_t2_t *opj_t2_create(opj_image_t *p_image , opj_cp_t *p_cp ) ;
#line 135
void opj_t2_destroy(opj_t2_t *t2 ) ;
#line 63 "/root/patron-new/39/src/lib/openjp2/mct.h"
extern void opj_mct_encode(OPJ_INT32 *c0 , OPJ_INT32 *c1 , OPJ_INT32 *c2 , OPJ_SIZE_T n ) ;
#line 72
extern void opj_mct_decode(OPJ_INT32 *c0 , OPJ_INT32 *c1 , OPJ_INT32 *c2 , OPJ_SIZE_T n ) ;
#line 88
extern void opj_mct_encode_real(OPJ_FLOAT32 *c0 , OPJ_FLOAT32 *c1 , OPJ_FLOAT32 *c2 ,
                                OPJ_SIZE_T n ) ;
#line 98
extern void opj_mct_decode_real(OPJ_FLOAT32 *c0 , OPJ_FLOAT32 *c1 , OPJ_FLOAT32 *c2 ,
                                OPJ_SIZE_T n ) ;
#line 116
extern OPJ_BOOL opj_mct_encode_custom(OPJ_BYTE *p_coding_data , OPJ_SIZE_T n , OPJ_BYTE **p_data ,
                                      OPJ_UINT32 p_nb_comp , OPJ_UINT32 is_signed ) ;
#line 131
extern OPJ_BOOL opj_mct_decode_custom(OPJ_BYTE *pDecodingData , OPJ_SIZE_T n , OPJ_BYTE **pData ,
                                      OPJ_UINT32 pNbComp , OPJ_UINT32 isSigned ) ;
#line 144
extern void opj_calculate_norms(OPJ_FLOAT64 *pNorms , OPJ_UINT32 p_nb_comps , OPJ_FLOAT32 *pMatrix ) ;
#line 150
extern OPJ_FLOAT64 *opj_mct_get_mct_norms(void) ;
#line 154
extern OPJ_FLOAT64 *opj_mct_get_mct_norms_real(void) ;
#line 56 "/root/patron-new/39/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_min(OPJ_INT32 a , OPJ_INT32 b ) 
{ 
  OPJ_INT32 tmp ;

  {
#line 58
  if (a < b) {
#line 58
    tmp = a;
  } else {
#line 58
    tmp = b;
  }
#line 58
  return (tmp);
}
}
#line 65 "/root/patron-new/39/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_UINT32 opj_uint_min(OPJ_UINT32 a , OPJ_UINT32 b ) 
{ 
  OPJ_UINT32 tmp ;

  {
#line 67
  if (a < b) {
#line 67
    tmp = a;
  } else {
#line 67
    tmp = b;
  }
#line 67
  return (tmp);
}
}
#line 74 "/root/patron-new/39/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_max(OPJ_INT32 a , OPJ_INT32 b ) 
{ 
  OPJ_INT32 tmp ;

  {
#line 76
  if (a > b) {
#line 76
    tmp = a;
  } else {
#line 76
    tmp = b;
  }
#line 76
  return (tmp);
}
}
#line 83 "/root/patron-new/39/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_UINT32 opj_uint_max(OPJ_UINT32 a , OPJ_UINT32 b ) 
{ 
  OPJ_UINT32 tmp ;

  {
#line 85
  if (a > b) {
#line 85
    tmp = a;
  } else {
#line 85
    tmp = b;
  }
#line 85
  return (tmp);
}
}
#line 92 "/root/patron-new/39/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_UINT32 opj_uint_adds(OPJ_UINT32 a , OPJ_UINT32 b ) 
{ 
  OPJ_UINT64 sum ;

  {
#line 94
  sum = (OPJ_UINT64 )a + (OPJ_UINT64 )b;
#line 95
  return ((OPJ_UINT32 )(- ((OPJ_INT32 )(sum >> 32))) | (OPJ_UINT32 )sum);
}
}
#line 116 "/root/patron-new/39/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_clamp(OPJ_INT32 a , OPJ_INT32 min , OPJ_INT32 max ) 
{ 


  {
#line 119
  if (a < min) {
#line 120
    return (min);
  }
#line 122
  if (a > max) {
#line 123
    return (max);
  }
#line 125
  return (a);
}
}
#line 137 "/root/patron-new/39/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT64 opj_int64_clamp(OPJ_INT64 a , OPJ_INT64 min , OPJ_INT64 max ) 
{ 


  {
#line 140
  if (a < min) {
#line 141
    return (min);
  }
#line 143
  if (a > max) {
#line 144
    return (max);
  }
#line 146
  return (a);
}
}
#line 160 "/root/patron-new/39/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_ceildiv(OPJ_INT32 a , OPJ_INT32 b ) 
{ 


  {
#line 163
  return ((OPJ_INT32 )((((OPJ_INT64 )a + (long )b) - 1L) / (long )b));
}
}
#line 170 "/root/patron-new/39/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_UINT32 opj_uint_ceildiv(OPJ_UINT32 a , OPJ_UINT32 b ) 
{ 


  {
#line 173
  return ((OPJ_UINT32 )((((OPJ_UINT64 )a + (unsigned long )b) - 1UL) / (unsigned long )b));
}
}
#line 180 "/root/patron-new/39/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_ceildivpow2(OPJ_INT32 a , OPJ_INT32 b ) 
{ 


  {
#line 182
  return ((OPJ_INT32 )((((long )a + (1L << b)) - 1L) >> b));
}
}
#line 189 "/root/patron-new/39/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int64_ceildivpow2(OPJ_INT64 a , OPJ_INT32 b ) 
{ 


  {
#line 191
  return ((OPJ_INT32 )(((a + (1L << b)) - 1L) >> b));
}
}
#line 198 "/root/patron-new/39/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_UINT32 opj_uint_ceildivpow2(OPJ_UINT32 a , OPJ_UINT32 b ) 
{ 


  {
#line 200
  return ((OPJ_UINT32 )((((unsigned long )a + (1UL << b)) - 1UL) >> b));
}
}
#line 207 "/root/patron-new/39/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_floordivpow2(OPJ_INT32 a , OPJ_INT32 b ) 
{ 


  {
#line 209
  return (a >> b);
}
}
#line 225 "/root/patron-new/39/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_floorlog2(OPJ_INT32 a ) 
{ 
  OPJ_INT32 l ;

  {
#line 228
  l = 0;
  {
#line 228
  while (1) {
    while_continue: /* CIL Label */ ;

#line 228
    if (! (a > 1)) {
#line 228
      goto while_break;
    }
#line 229
    a >>= 1;
#line 228
    l ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 231
  return (l);
}
}
#line 237 "/root/patron-new/39/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_UINT32 opj_uint_floorlog2(OPJ_UINT32 a ) 
{ 
  OPJ_UINT32 l ;

  {
#line 240
  l = (OPJ_UINT32 )0;
  {
#line 240
  while (1) {
    while_continue: /* CIL Label */ ;

#line 240
    if (! (a > 1U)) {
#line 240
      goto while_break;
    }
#line 241
    a >>= 1;
#line 240
    l ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 243
  return (l);
}
}
#line 62 "/root/patron-new/39/src/lib/openjp2/sparse_array.h"
opj_sparse_array_int32_t *opj_sparse_array_int32_create(OPJ_UINT32 width , OPJ_UINT32 height ,
                                                        OPJ_UINT32 block_width , OPJ_UINT32 block_height ) ;
#line 70
void opj_sparse_array_int32_free(opj_sparse_array_int32_t *sa ) ;
#line 80
OPJ_BOOL opj_sparse_array_is_region_valid(opj_sparse_array_int32_t *sa , OPJ_UINT32 x0 ,
                                          OPJ_UINT32 y0___0 , OPJ_UINT32 x1 , OPJ_UINT32 y1___0 ) ;
#line 102
OPJ_BOOL opj_sparse_array_int32_read(opj_sparse_array_int32_t *sa , OPJ_UINT32 x0 ,
                                     OPJ_UINT32 y0___0 , OPJ_UINT32 x1 , OPJ_UINT32 y1___0 ,
                                     OPJ_INT32 *dest , OPJ_UINT32 dest_col_stride ,
                                     OPJ_UINT32 dest_line_stride , OPJ_BOOL forgiving ) ;
#line 129
OPJ_BOOL opj_sparse_array_int32_write(opj_sparse_array_int32_t *sa , OPJ_UINT32 x0 ,
                                      OPJ_UINT32 y0___0 , OPJ_UINT32 x1 , OPJ_UINT32 y1___0 ,
                                      OPJ_INT32 *src , OPJ_UINT32 src_col_stride ,
                                      OPJ_UINT32 src_line_stride , OPJ_BOOL forgiving ) ;
#line 295 "/root/patron-new/39/src/lib/openjp2/thread.c"
OPJ_BOOL opj_has_thread_support(void) 
{ 


  {
#line 297
  return (1);
}
}
#line 300 "/root/patron-new/39/src/lib/openjp2/thread.c"
int opj_get_num_cpus(void) 
{ 
  long __cil_tmp1 ;

  {
  {
#line 303
  __cil_tmp1 = sysconf(84);
  }
#line 303
  return ((int )__cil_tmp1);
}
}
#line 313 "/root/patron-new/39/src/lib/openjp2/thread.c"
opj_mutex_t *opj_mutex_create(void) 
{ 
  opj_mutex_t *mutex ;
  void *__cil_tmp2 ;
  int __cil_tmp3 ;

  {
  {
#line 315
  __cil_tmp2 = opj_calloc((size_t )1U, sizeof(opj_mutex_t ));
#line 315
  mutex = (opj_mutex_t *)__cil_tmp2;
  }
#line 316
  if ((unsigned long )mutex != (unsigned long )((void *)0)) {
    {
#line 317
    __cil_tmp3 = pthread_mutex_init(& mutex->mutex, (pthread_mutexattr_t *)((void *)0));
    }
#line 317
    if (__cil_tmp3 != 0) {
      {
#line 318
      opj_free((void *)mutex);
#line 319
      mutex = (opj_mutex_t *)((void *)0);
      }
    }
  }
#line 322
  return (mutex);
}
}
#line 325 "/root/patron-new/39/src/lib/openjp2/thread.c"
void opj_mutex_lock(opj_mutex_t *mutex ) 
{ 


  {
  {
#line 327
  pthread_mutex_lock(& mutex->mutex);
  }
#line 329
  return;
}
}
#line 330 "/root/patron-new/39/src/lib/openjp2/thread.c"
void opj_mutex_unlock(opj_mutex_t *mutex ) 
{ 


  {
  {
#line 332
  pthread_mutex_unlock(& mutex->mutex);
  }
#line 334
  return;
}
}
#line 335 "/root/patron-new/39/src/lib/openjp2/thread.c"
void opj_mutex_destroy(opj_mutex_t *mutex ) 
{ 


  {
#line 337
  if (! mutex) {
#line 338
    return;
  }
  {
#line 340
  pthread_mutex_destroy(& mutex->mutex);
#line 341
  opj_free((void *)mutex);
  }
#line 343
  return;
}
}
#line 348 "/root/patron-new/39/src/lib/openjp2/thread.c"
opj_cond_t *opj_cond_create(void) 
{ 
  opj_cond_t *cond ;
  void *__cil_tmp2 ;
  int __cil_tmp3 ;

  {
  {
#line 350
  __cil_tmp2 = opj_malloc(sizeof(opj_cond_t ));
#line 350
  cond = (opj_cond_t *)__cil_tmp2;
  }
#line 351
  if (! cond) {
#line 352
    return ((opj_cond_t *)((void *)0));
  }
  {
#line 354
  __cil_tmp3 = pthread_cond_init(& cond->cond, (pthread_condattr_t *)((void *)0));
  }
#line 354
  if (__cil_tmp3 != 0) {
    {
#line 355
    opj_free((void *)cond);
    }
#line 356
    return ((opj_cond_t *)((void *)0));
  }
#line 358
  return (cond);
}
}
#line 361 "/root/patron-new/39/src/lib/openjp2/thread.c"
void opj_cond_wait(opj_cond_t *cond , opj_mutex_t *mutex ) 
{ 


  {
  {
#line 363
  pthread_cond_wait(& cond->cond, & mutex->mutex);
  }
#line 365
  return;
}
}
#line 366 "/root/patron-new/39/src/lib/openjp2/thread.c"
void opj_cond_signal(opj_cond_t *cond ) 
{ 
  int ret ;
  int __cil_tmp3 ;

  {
  {
#line 368
  __cil_tmp3 = pthread_cond_signal(& cond->cond);
#line 368
  ret = __cil_tmp3;
  }
#line 370
  return;
}
}
#line 373 "/root/patron-new/39/src/lib/openjp2/thread.c"
void opj_cond_destroy(opj_cond_t *cond ) 
{ 


  {
#line 375
  if (! cond) {
#line 376
    return;
  }
  {
#line 378
  pthread_cond_destroy(& cond->cond);
#line 379
  opj_free((void *)cond);
  }
#line 381
  return;
}
}
#line 389 "/root/patron-new/39/src/lib/openjp2/thread.c"
static void *opj_thread_callback_adapter(void *info ) 
{ 
  opj_thread_t *thread ;

  {
  {
#line 391
  thread = (opj_thread_t *)info;
#line 392
  (*(thread->thread_fn))(thread->user_data);
  }
#line 393
  return ((void *)0);
}
}
#line 396 "/root/patron-new/39/src/lib/openjp2/thread.c"
opj_thread_t *opj_thread_create(void (*thread_fn)(void * ) , void *user_data ) 
{ 
  pthread_attr_t attr ;
  opj_thread_t *thread ;
  void *__cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 403
  __cil_tmp6 = opj_malloc(sizeof(opj_thread_t ));
#line 403
  thread = (opj_thread_t *)__cil_tmp6;
  }
#line 404
  if (! thread) {
#line 405
    return ((opj_thread_t *)((void *)0));
  }
  {
#line 407
  thread->thread_fn = thread_fn;
#line 408
  thread->user_data = user_data;
#line 410
  pthread_attr_init(& attr);
#line 411
  pthread_attr_setdetachstate(& attr, 0);
#line 412
  __cil_tmp7 = pthread_create(& thread->thread, & attr, & opj_thread_callback_adapter,
                              (void *)thread);
  }
#line 412
  if (__cil_tmp7 != 0) {
    {
#line 414
    opj_free((void *)thread);
    }
#line 415
    return ((opj_thread_t *)((void *)0));
  }
#line 417
  return (thread);
}
}
#line 420 "/root/patron-new/39/src/lib/openjp2/thread.c"
void opj_thread_join(opj_thread_t *thread ) 
{ 
  void *status ;

  {
  {
#line 423
  pthread_join(thread->thread, & status);
#line 425
  opj_free((void *)thread);
  }
#line 427
  return;
}
}
#line 509 "/root/patron-new/39/src/lib/openjp2/thread.c"
static opj_tls_t *opj_tls_new(void) 
{ 
  void *__cil_tmp1 ;

  {
  {
#line 511
  __cil_tmp1 = opj_calloc((size_t )1, sizeof(opj_tls_t ));
  }
#line 511
  return ((opj_tls_t *)__cil_tmp1);
}
}
#line 514 "/root/patron-new/39/src/lib/openjp2/thread.c"
static void opj_tls_destroy(opj_tls_t *tls ) 
{ 
  int i ;

  {
#line 517
  if (! tls) {
#line 518
    return;
  }
#line 520
  i = 0;
  {
#line 520
  while (1) {
    while_continue: /* CIL Label */ ;

#line 520
    if (! (i < tls->key_val_count)) {
#line 520
      goto while_break;
    }
#line 521
    if ((tls->key_val + i)->opj_free_func) {
      {
#line 522
      (*((tls->key_val + i)->opj_free_func))((tls->key_val + i)->value);
      }
    }
#line 520
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: 
  {
#line 525
  opj_free((void *)tls->key_val);
#line 526
  opj_free((void *)tls);
  }
#line 528
  return;
}
}
#line 529 "/root/patron-new/39/src/lib/openjp2/thread.c"
void *opj_tls_get(opj_tls_t *tls , int key ) 
{ 
  int i ;

  {
#line 532
  i = 0;
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;

#line 532
    if (! (i < tls->key_val_count)) {
#line 532
      goto while_break;
    }
#line 533
    if ((tls->key_val + i)->key == key) {
#line 534
      return ((tls->key_val + i)->value);
    }
#line 532
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 537
  return ((void *)0);
}
}
#line 540 "/root/patron-new/39/src/lib/openjp2/thread.c"
OPJ_BOOL opj_tls_set(opj_tls_t *tls , int key , void *value , void (*opj_free_func)(void * ) ) 
{ 
  opj_tls_key_val_t *new_key_val ;
  int i ;
  void *__cil_tmp8 ;

  {
#line 546
  if (tls->key_val_count == 2147483647) {
#line 547
    return (0);
  }
#line 549
  i = 0;
  {
#line 549
  while (1) {
    while_continue: /* CIL Label */ ;

#line 549
    if (! (i < tls->key_val_count)) {
#line 549
      goto while_break;
    }
#line 550
    if ((tls->key_val + i)->key == key) {
#line 551
      if ((tls->key_val + i)->opj_free_func) {
        {
#line 552
        (*((tls->key_val + i)->opj_free_func))((tls->key_val + i)->value);
        }
      }
#line 554
      (tls->key_val + i)->value = value;
#line 555
      (tls->key_val + i)->opj_free_func = opj_free_func;
#line 556
      return (1);
    }
#line 549
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: 
  {
#line 559
  __cil_tmp8 = opj_realloc((void *)tls->key_val, ((size_t )tls->key_val_count + 1UL) * sizeof(opj_tls_key_val_t ));
#line 559
  new_key_val = (opj_tls_key_val_t *)__cil_tmp8;
  }
#line 561
  if (! new_key_val) {
#line 562
    return (0);
  }
#line 564
  tls->key_val = new_key_val;
#line 565
  (new_key_val + tls->key_val_count)->key = key;
#line 566
  (new_key_val + tls->key_val_count)->value = value;
#line 567
  (new_key_val + tls->key_val_count)->opj_free_func = opj_free_func;
#line 568
  (tls->key_val_count) ++;
#line 569
  return (1);
}
}
#line 619
static OPJ_BOOL opj_thread_pool_setup(opj_thread_pool_t *tp , int num_threads ) ;
#line 620
static opj_worker_thread_job_t *opj_thread_pool_get_next_job(opj_thread_pool_t *tp ,
                                                             opj_worker_thread_t *worker_thread ,
                                                             OPJ_BOOL signal_job_finished ) ;
#line 625 "/root/patron-new/39/src/lib/openjp2/thread.c"
opj_thread_pool_t *opj_thread_pool_create(int num_threads ) 
{ 
  opj_thread_pool_t *tp ;
  void *__cil_tmp3 ;
  OPJ_BOOL __cil_tmp6 ;

  {
  {
#line 629
  __cil_tmp3 = opj_calloc((size_t )1, sizeof(opj_thread_pool_t ));
#line 629
  tp = (opj_thread_pool_t *)__cil_tmp3;
  }
#line 630
  if (! tp) {
#line 631
    return ((opj_thread_pool_t *)((void *)0));
  }
#line 633
  tp->state = (opj_worker_thread_state )0;
#line 635
  if (num_threads <= 0) {
    {
#line 636
    tp->tls = opj_tls_new();
    }
#line 637
    if (! tp->tls) {
      {
#line 638
      opj_free((void *)tp);
#line 639
      tp = (opj_thread_pool_t *)((void *)0);
      }
    }
#line 641
    return (tp);
  }
  {
#line 644
  tp->mutex = opj_mutex_create();
  }
#line 645
  if (! tp->mutex) {
    {
#line 646
    opj_free((void *)tp);
    }
#line 647
    return ((opj_thread_pool_t *)((void *)0));
  }
  {
#line 649
  __cil_tmp6 = opj_thread_pool_setup(tp, num_threads);
  }
#line 649
  if (! __cil_tmp6) {
    {
#line 650
    opj_thread_pool_destroy(tp);
    }
#line 651
    return ((opj_thread_pool_t *)((void *)0));
  }
#line 653
  return (tp);
}
}
#line 656 "/root/patron-new/39/src/lib/openjp2/thread.c"
static void opj_worker_thread_function(void *user_data ) 
{ 
  opj_worker_thread_t *worker_thread ;
  opj_thread_pool_t *tp ;
  opj_tls_t *tls ;
  OPJ_BOOL job_finished ;
  opj_worker_thread_job_t *job ;
  opj_worker_thread_job_t *__cil_tmp8 ;

  {
  {
#line 661
  job_finished = 0;
#line 663
  worker_thread = (opj_worker_thread_t *)user_data;
#line 664
  tp = worker_thread->tp;
#line 665
  tls = opj_tls_new();
  }
  {
#line 667
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 668
    __cil_tmp8 = opj_thread_pool_get_next_job(tp, worker_thread, job_finished);
#line 668
    job = __cil_tmp8;
    }
#line 670
    if ((unsigned long )job == (unsigned long )((void *)0)) {
#line 671
      goto while_break;
    }
#line 674
    if (job->job_fn) {
      {
#line 675
      (*(job->job_fn))(job->user_data, tls);
      }
    }
    {
#line 677
    opj_free((void *)job);
#line 678
    job_finished = 1;
    }
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: 
  {
#line 681
  opj_tls_destroy(tls);
  }
#line 683
  return;
}
}
#line 684 "/root/patron-new/39/src/lib/openjp2/thread.c"
static OPJ_BOOL opj_thread_pool_setup(opj_thread_pool_t *tp , int num_threads ) 
{ 
  int i ;
  OPJ_BOOL bRet ;
  void *__cil_tmp7 ;

  {
  {
#line 687
  bRet = 1;
#line 691
  tp->cond = opj_cond_create();
  }
#line 692
  if ((unsigned long )tp->cond == (unsigned long )((void *)0)) {
#line 693
    return (0);
  }
  {
#line 696
  __cil_tmp7 = opj_calloc((size_t )num_threads, sizeof(opj_worker_thread_t ));
#line 696
  tp->worker_threads = (opj_worker_thread_t *)__cil_tmp7;
  }
#line 698
  if ((unsigned long )tp->worker_threads == (unsigned long )((void *)0)) {
#line 699
    return (0);
  }
#line 701
  tp->worker_threads_count = num_threads;
#line 703
  i = 0;
  {
#line 703
  while (1) {
    while_continue: /* CIL Label */ ;

#line 703
    if (! (i < num_threads)) {
#line 703
      goto while_break;
    }
    {
#line 704
    (tp->worker_threads + i)->tp = tp;
#line 706
    (tp->worker_threads + i)->mutex = opj_mutex_create();
    }
#line 707
    if ((unsigned long )(tp->worker_threads + i)->mutex == (unsigned long )((void *)0)) {
#line 708
      tp->worker_threads_count = i;
#line 709
      bRet = 0;
#line 710
      goto while_break;
    }
    {
#line 713
    (tp->worker_threads + i)->cond = opj_cond_create();
    }
#line 714
    if ((unsigned long )(tp->worker_threads + i)->cond == (unsigned long )((void *)0)) {
      {
#line 715
      opj_mutex_destroy((tp->worker_threads + i)->mutex);
#line 716
      tp->worker_threads_count = i;
#line 717
      bRet = 0;
      }
#line 718
      goto while_break;
    }
    {
#line 721
    (tp->worker_threads + i)->marked_as_waiting = 0;
#line 723
    (tp->worker_threads + i)->thread = opj_thread_create(& opj_worker_thread_function,
                                                         (void *)(tp->worker_threads + i));
    }
#line 725
    if ((unsigned long )(tp->worker_threads + i)->thread == (unsigned long )((void *)0)) {
      {
#line 726
      opj_mutex_destroy((tp->worker_threads + i)->mutex);
#line 727
      opj_cond_destroy((tp->worker_threads + i)->cond);
#line 728
      tp->worker_threads_count = i;
#line 729
      bRet = 0;
      }
#line 730
      goto while_break;
    }
#line 703
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }

  while_break: 
  {
#line 736
  opj_mutex_lock(tp->mutex);
  }
  {
#line 737
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 737
    if (! (tp->waiting_worker_thread_count < tp->worker_threads_count)) {
#line 737
      goto while_break___0;
    }
    {
#line 738
    opj_cond_wait(tp->cond, tp->mutex);
    }
  }
  while_break___2: /* CIL Label */ ;
  }

  while_break___0: 
  {
#line 740
  opj_mutex_unlock(tp->mutex);
  }
#line 743
  if ((unsigned int )tp->state == 2U) {
#line 744
    bRet = 0;
  }
#line 747
  return (bRet);
}
}
#line 757 "/root/patron-new/39/src/lib/openjp2/thread.c"
static opj_worker_thread_job_t *opj_thread_pool_get_next_job(opj_thread_pool_t *tp ,
                                                             opj_worker_thread_t *worker_thread ,
                                                             OPJ_BOOL signal_job_finished ) 
{ 
  opj_job_list_t *top_job_iter ;
  int __cil_tmp5 ;
  opj_worker_thread_job_t *job ;
  opj_worker_thread_list_t *item ;
  void *__cil_tmp10 ;

  {
  {
#line 762
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 765
    opj_mutex_lock(tp->mutex);
    }
#line 767
    if (signal_job_finished) {
#line 768
      signal_job_finished = 0;
#line 769
      __cil_tmp5 = tp->pending_jobs_count;
#line 769
      (tp->pending_jobs_count) --;
#line 771
      if (tp->pending_jobs_count <= tp->signaling_threshold) {
        {
#line 772
        opj_cond_signal(tp->cond);
        }
      }
    }
#line 776
    if ((unsigned int )tp->state == 1U) {
      {
#line 777
      opj_mutex_unlock(tp->mutex);
      }
#line 778
      return ((opj_worker_thread_job_t *)((void *)0));
    }
#line 780
    top_job_iter = tp->job_queue;
#line 781
    if (top_job_iter) {
      {
#line 783
      tp->job_queue = top_job_iter->next;
#line 785
      job = top_job_iter->job;
#line 786
      opj_mutex_unlock(tp->mutex);
#line 787
      opj_free((void *)top_job_iter);
      }
#line 788
      return (job);
    }
#line 792
    if (! worker_thread->marked_as_waiting) {
      {
#line 795
      worker_thread->marked_as_waiting = 1;
#line 796
      (tp->waiting_worker_thread_count) ++;
#line 799
      __cil_tmp10 = opj_malloc(sizeof(opj_worker_thread_list_t ));
#line 799
      item = (opj_worker_thread_list_t *)__cil_tmp10;
      }
#line 800
      if ((unsigned long )item == (unsigned long )((void *)0)) {
        {
#line 801
        tp->state = (opj_worker_thread_state )2;
#line 802
        opj_cond_signal(tp->cond);
#line 804
        opj_mutex_unlock(tp->mutex);
        }
#line 805
        return ((opj_worker_thread_job_t *)((void *)0));
      }
#line 808
      item->worker_thread = worker_thread;
#line 809
      item->next = tp->waiting_worker_thread_list;
#line 810
      tp->waiting_worker_thread_list = item;
    }
    {
#line 814
    opj_cond_signal(tp->cond);
#line 816
    opj_mutex_lock(worker_thread->mutex);
#line 817
    opj_mutex_unlock(tp->mutex);
#line 820
    opj_cond_wait(worker_thread->cond, worker_thread->mutex);
#line 822
    opj_mutex_unlock(worker_thread->mutex);
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 828
  return ((opj_worker_thread_job_t *)0);
}
}
#line 827 "/root/patron-new/39/src/lib/openjp2/thread.c"
OPJ_BOOL opj_thread_pool_submit_job(opj_thread_pool_t *tp , void (*job_fn)(void * ,
                                                                           opj_tls_t * ) ,
                                    void *user_data ) 
{ 
  opj_worker_thread_job_t *job ;
  opj_job_list_t *item ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;
  opj_worker_thread_t *worker_thread ;
  opj_worker_thread_list_t *next ;
  opj_worker_thread_list_t *to_opj_free ;
  int __cil_tmp13 ;

  {
#line 834
  if ((unsigned long )tp->mutex == (unsigned long )((void *)0)) {
    {
#line 835
    (*job_fn)(user_data, tp->tls);
    }
#line 836
    return (1);
  }
  {
#line 839
  __cil_tmp6 = opj_malloc(sizeof(opj_worker_thread_job_t ));
#line 839
  job = (opj_worker_thread_job_t *)__cil_tmp6;
  }
#line 840
  if ((unsigned long )job == (unsigned long )((void *)0)) {
#line 841
    return (0);
  }
  {
#line 843
  job->job_fn = job_fn;
#line 844
  job->user_data = user_data;
#line 846
  __cil_tmp7 = opj_malloc(sizeof(opj_job_list_t ));
#line 846
  item = (opj_job_list_t *)__cil_tmp7;
  }
#line 847
  if ((unsigned long )item == (unsigned long )((void *)0)) {
    {
#line 848
    opj_free((void *)job);
    }
#line 849
    return (0);
  }
  {
#line 851
  item->job = job;
#line 853
  opj_mutex_lock(tp->mutex);
#line 855
  tp->signaling_threshold = 100 * tp->worker_threads_count;
  }
  {
#line 856
  while (1) {
    while_continue: /* CIL Label */ ;

#line 856
    if (! (tp->pending_jobs_count > tp->signaling_threshold)) {
#line 856
      goto while_break;
    }
    {
#line 858
    opj_cond_wait(tp->cond, tp->mutex);
    }
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: 
#line 862
  item->next = tp->job_queue;
#line 863
  tp->job_queue = item;
#line 864
  (tp->pending_jobs_count) ++;
#line 866
  if (tp->waiting_worker_thread_list) {
    {
#line 871
    worker_thread = (tp->waiting_worker_thread_list)->worker_thread;
#line 874
    worker_thread->marked_as_waiting = 0;
#line 876
    next = (tp->waiting_worker_thread_list)->next;
#line 877
    to_opj_free = tp->waiting_worker_thread_list;
#line 878
    tp->waiting_worker_thread_list = next;
#line 879
    __cil_tmp13 = tp->waiting_worker_thread_count;
#line 879
    (tp->waiting_worker_thread_count) --;
#line 881
    opj_mutex_lock(worker_thread->mutex);
#line 882
    opj_mutex_unlock(tp->mutex);
#line 883
    opj_cond_signal(worker_thread->cond);
#line 884
    opj_mutex_unlock(worker_thread->mutex);
#line 886
    opj_free((void *)to_opj_free);
    }
  } else {
    {
#line 888
    opj_mutex_unlock(tp->mutex);
    }
  }
#line 891
  return (1);
}
}
#line 894 "/root/patron-new/39/src/lib/openjp2/thread.c"
void opj_thread_pool_wait_completion(opj_thread_pool_t *tp , int max_remaining_jobs ) 
{ 


  {
#line 897
  if ((unsigned long )tp->mutex == (unsigned long )((void *)0)) {
#line 898
    return;
  }
#line 901
  if (max_remaining_jobs < 0) {
#line 902
    max_remaining_jobs = 0;
  }
  {
#line 904
  opj_mutex_lock(tp->mutex);
#line 905
  tp->signaling_threshold = max_remaining_jobs;
  }
  {
#line 906
  while (1) {
    while_continue: /* CIL Label */ ;

#line 906
    if (! (tp->pending_jobs_count > max_remaining_jobs)) {
#line 906
      goto while_break;
    }
    {
#line 908
    opj_cond_wait(tp->cond, tp->mutex);
    }
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: 
  {
#line 911
  opj_mutex_unlock(tp->mutex);
  }
#line 913
  return;
}
}
#line 914 "/root/patron-new/39/src/lib/openjp2/thread.c"
int opj_thread_pool_get_thread_count(opj_thread_pool_t *tp ) 
{ 


  {
#line 916
  return (tp->worker_threads_count);
}
}
#line 919 "/root/patron-new/39/src/lib/openjp2/thread.c"
void opj_thread_pool_destroy(opj_thread_pool_t *tp ) 
{ 
  int i ;
  opj_worker_thread_list_t *next ;

  {
#line 921
  if (! tp) {
#line 922
    return;
  }
#line 924
  if (tp->cond) {
    {
#line 926
    opj_thread_pool_wait_completion(tp, 0);
#line 928
    opj_mutex_lock(tp->mutex);
#line 929
    tp->state = (opj_worker_thread_state )1;
#line 930
    opj_mutex_unlock(tp->mutex);
#line 932
    i = 0;
    }
    {
#line 932
    while (1) {
      while_continue: /* CIL Label */ ;

#line 932
      if (! (i < tp->worker_threads_count)) {
#line 932
        goto while_break;
      }
      {
#line 933
      opj_mutex_lock((tp->worker_threads + i)->mutex);
#line 934
      opj_cond_signal((tp->worker_threads + i)->cond);
#line 935
      opj_mutex_unlock((tp->worker_threads + i)->mutex);
#line 936
      opj_thread_join((tp->worker_threads + i)->thread);
#line 937
      opj_cond_destroy((tp->worker_threads + i)->cond);
#line 938
      opj_mutex_destroy((tp->worker_threads + i)->mutex);
#line 932
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }

    while_break: 
    {
#line 941
    opj_free((void *)tp->worker_threads);
    }
    {
#line 943
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 943
      if (! ((unsigned long )tp->waiting_worker_thread_list != (unsigned long )((void *)0))) {
#line 943
        goto while_break___0;
      }
      {
#line 944
      next = (tp->waiting_worker_thread_list)->next;
#line 945
      opj_free((void *)tp->waiting_worker_thread_list);
#line 946
      tp->waiting_worker_thread_list = next;
      }
    }
    while_break___2: /* CIL Label */ ;
    }

    while_break___0: 
    {
#line 949
    opj_cond_destroy(tp->cond);
    }
  }
  {
#line 951
  opj_mutex_destroy(tp->mutex);
#line 952
  opj_tls_destroy(tp->tls);
#line 953
  opj_free((void *)tp);
  }
#line 955
  return;
}
}
#line 48 "/root/patron-new/39/src/lib/openjp2/tgt.c"
opj_tgt_tree_t *opj_tgt_create(OPJ_UINT32 numleafsh , OPJ_UINT32 numleafsv , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_INT32 nplh[32] ;
  OPJ_INT32 nplv[32] ;
  opj_tgt_node_t *node ;
  opj_tgt_node_t *l_parent_node ;
  opj_tgt_node_t *l_parent_node0 ;
  opj_tgt_tree_t *tree ;
  OPJ_UINT32 i ;
  OPJ_INT32 j ;
  OPJ_INT32 k ;
  OPJ_UINT32 numlvls ;
  OPJ_UINT32 n ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;

  {
  {
#line 53
  node = (opj_tgt_node_t *)0;
#line 54
  l_parent_node = (opj_tgt_node_t *)0;
#line 55
  l_parent_node0 = (opj_tgt_node_t *)0;
#line 56
  tree = (opj_tgt_tree_t *)0;
#line 62
  __cil_tmp15 = opj_calloc((size_t )1, sizeof(opj_tgt_tree_t ));
#line 62
  tree = (opj_tgt_tree_t *)__cil_tmp15;
  }
#line 63
  if (! tree) {
    {
#line 64
    opj_event_msg(p_manager, 1, "Not enough memory to create Tag-tree\n");
    }
#line 65
    return ((opj_tgt_tree_t *)0);
  }
#line 68
  tree->numleafsh = numleafsh;
#line 69
  tree->numleafsv = numleafsv;
#line 71
  numlvls = (OPJ_UINT32 )0;
#line 72
  nplh[0] = (OPJ_INT32 )numleafsh;
#line 73
  nplv[0] = (OPJ_INT32 )numleafsv;
#line 74
  tree->numnodes = (OPJ_UINT32 )0;
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    n = (OPJ_UINT32 )(nplh[numlvls] * nplv[numlvls]);
#line 77
    nplh[numlvls + 1U] = (nplh[numlvls] + 1) / 2;
#line 78
    nplv[numlvls + 1U] = (nplv[numlvls] + 1) / 2;
#line 79
    tree->numnodes += n;
#line 80
    numlvls ++;
#line 75
    if (! (n > 1U)) {
#line 75
      goto while_break;
    }
  }
  while_break___3: /* CIL Label */ ;
  }

  while_break: ;
#line 84
  if (tree->numnodes == 0U) {
    {
#line 85
    opj_free((void *)tree);
    }
#line 86
    return ((opj_tgt_tree_t *)0);
  }
  {
#line 89
  __cil_tmp16 = opj_calloc((size_t )tree->numnodes, sizeof(opj_tgt_node_t ));
#line 89
  tree->nodes = (opj_tgt_node_t *)__cil_tmp16;
  }
#line 91
  if (! tree->nodes) {
    {
#line 92
    opj_event_msg(p_manager, 1, "Not enough memory to create Tag-tree nodes\n");
#line 94
    opj_free((void *)tree);
    }
#line 95
    return ((opj_tgt_tree_t *)0);
  }
#line 97
  tree->nodes_size = tree->numnodes * (OPJ_UINT32 )sizeof(opj_tgt_node_t );
#line 99
  node = tree->nodes;
#line 100
  l_parent_node = tree->nodes + tree->numleafsh * tree->numleafsv;
#line 101
  l_parent_node0 = l_parent_node;
#line 103
  i = (OPJ_UINT32 )0;
  {
#line 103
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 103
    if (! (i < numlvls - 1U)) {
#line 103
      goto while_break___0;
    }
#line 104
    j = 0;
    {
#line 104
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 104
      if (! (j < nplv[i])) {
#line 104
        goto while_break___1;
      }
#line 105
      k = nplh[i];
      {
#line 106
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 106
        k --;
#line 106
        if (! (k >= 0)) {
#line 106
          goto while_break___2;
        }
#line 107
        node->parent = l_parent_node;
#line 108
        node ++;
#line 109
        k --;
#line 109
        if (k >= 0) {
#line 110
          node->parent = l_parent_node;
#line 111
          node ++;
        }
#line 113
        l_parent_node ++;
      }
      while_break___6: /* CIL Label */ ;
      }

      while_break___2: ;
#line 115
      if (j & 1) {
#line 116
        l_parent_node0 = l_parent_node;
      } else
#line 115
      if (j == nplv[i] - 1) {
#line 116
        l_parent_node0 = l_parent_node;
      } else {
#line 118
        l_parent_node = l_parent_node0;
#line 119
        l_parent_node0 += nplh[i];
      }
#line 104
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }

    while_break___1: 
#line 103
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }

  while_break___0: 
  {
#line 123
  node->parent = (struct opj_tgt_node *)0;
#line 124
  opj_tgt_reset(tree);
  }
#line 125
  return (tree);
}
}
#line 136 "/root/patron-new/39/src/lib/openjp2/tgt.c"
opj_tgt_tree_t *opj_tgt_init(opj_tgt_tree_t *p_tree , OPJ_UINT32 p_num_leafs_h , OPJ_UINT32 p_num_leafs_v ,
                             opj_event_mgr_t *p_manager ) 
{ 
  OPJ_INT32 l_nplh[32] ;
  OPJ_INT32 l_nplv[32] ;
  opj_tgt_node_t *l_node ;
  opj_tgt_node_t *l_parent_node ;
  opj_tgt_node_t *l_parent_node0 ;
  OPJ_UINT32 i ;
  OPJ_INT32 j ;
  OPJ_INT32 k ;
  OPJ_UINT32 l_num_levels ;
  OPJ_UINT32 n ;
  OPJ_UINT32 l_node_size ;
  opj_tgt_node_t *new_nodes ;
  void *__cil_tmp17 ;

  {
#line 141
  l_node = (opj_tgt_node_t *)0;
#line 142
  l_parent_node = (opj_tgt_node_t *)0;
#line 143
  l_parent_node0 = (opj_tgt_node_t *)0;
#line 150
  if (! p_tree) {
#line 151
    return ((opj_tgt_tree_t *)0);
  }
#line 154
  if (p_tree->numleafsh != p_num_leafs_h) {
    _L: 
#line 156
    p_tree->numleafsh = p_num_leafs_h;
#line 157
    p_tree->numleafsv = p_num_leafs_v;
#line 159
    l_num_levels = (OPJ_UINT32 )0;
#line 160
    l_nplh[0] = (OPJ_INT32 )p_num_leafs_h;
#line 161
    l_nplv[0] = (OPJ_INT32 )p_num_leafs_v;
#line 162
    p_tree->numnodes = (OPJ_UINT32 )0;
    {
#line 163
    while (1) {
      while_continue: /* CIL Label */ ;
#line 164
      n = (OPJ_UINT32 )(l_nplh[l_num_levels] * l_nplv[l_num_levels]);
#line 165
      l_nplh[l_num_levels + 1U] = (l_nplh[l_num_levels] + 1) / 2;
#line 166
      l_nplv[l_num_levels + 1U] = (l_nplv[l_num_levels] + 1) / 2;
#line 167
      p_tree->numnodes += n;
#line 168
      l_num_levels ++;
#line 163
      if (! (n > 1U)) {
#line 163
        goto while_break;
      }
    }
    while_break___3: /* CIL Label */ ;
    }

    while_break: ;
#line 172
    if (p_tree->numnodes == 0U) {
      {
#line 173
      opj_tgt_destroy(p_tree);
      }
#line 174
      return ((opj_tgt_tree_t *)0);
    }
#line 176
    l_node_size = p_tree->numnodes * (OPJ_UINT32 )sizeof(opj_tgt_node_t );
#line 178
    if (l_node_size > p_tree->nodes_size) {
      {
#line 179
      __cil_tmp17 = opj_realloc((void *)p_tree->nodes, (size_t )l_node_size);
#line 179
      new_nodes = (opj_tgt_node_t *)__cil_tmp17;
      }
#line 181
      if (! new_nodes) {
        {
#line 182
        opj_event_msg(p_manager, 1, "Not enough memory to reinitialize the tag tree\n");
#line 184
        opj_tgt_destroy(p_tree);
        }
#line 185
        return ((opj_tgt_tree_t *)0);
      }
      {
#line 187
      p_tree->nodes = new_nodes;
#line 188
      memset((void *)((char *)p_tree->nodes + p_tree->nodes_size), 0, (unsigned long )(l_node_size - p_tree->nodes_size));
#line 190
      p_tree->nodes_size = l_node_size;
      }
    }
#line 192
    l_node = p_tree->nodes;
#line 193
    l_parent_node = p_tree->nodes + p_tree->numleafsh * p_tree->numleafsv;
#line 194
    l_parent_node0 = l_parent_node;
#line 196
    i = (OPJ_UINT32 )0;
    {
#line 196
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 196
      if (! (i < l_num_levels - 1U)) {
#line 196
        goto while_break___0;
      }
#line 197
      j = 0;
      {
#line 197
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 197
        if (! (j < l_nplv[i])) {
#line 197
          goto while_break___1;
        }
#line 198
        k = l_nplh[i];
        {
#line 199
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 199
          k --;
#line 199
          if (! (k >= 0)) {
#line 199
            goto while_break___2;
          }
#line 200
          l_node->parent = l_parent_node;
#line 201
          l_node ++;
#line 202
          k --;
#line 202
          if (k >= 0) {
#line 203
            l_node->parent = l_parent_node;
#line 204
            l_node ++;
          }
#line 206
          l_parent_node ++;
        }
        while_break___6: /* CIL Label */ ;
        }

        while_break___2: ;
#line 208
        if (j & 1) {
#line 209
          l_parent_node0 = l_parent_node;
        } else
#line 208
        if (j == l_nplv[i] - 1) {
#line 209
          l_parent_node0 = l_parent_node;
        } else {
#line 211
          l_parent_node = l_parent_node0;
#line 212
          l_parent_node0 += l_nplh[i];
        }
#line 197
        j ++;
      }
      while_break___5: /* CIL Label */ ;
      }

      while_break___1: 
#line 196
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }

    while_break___0: 
#line 216
    l_node->parent = (struct opj_tgt_node *)0;
  } else
#line 154
  if (p_tree->numleafsv != p_num_leafs_v) {
#line 154
    goto _L;
  }
  {
#line 218
  opj_tgt_reset(p_tree);
  }
#line 220
  return (p_tree);
}
}
#line 223 "/root/patron-new/39/src/lib/openjp2/tgt.c"
void opj_tgt_destroy(opj_tgt_tree_t *p_tree ) 
{ 


  {
#line 225
  if (! p_tree) {
#line 226
    return;
  }
#line 229
  if (p_tree->nodes) {
    {
#line 230
    opj_free((void *)p_tree->nodes);
#line 231
    p_tree->nodes = (opj_tgt_node_t *)0;
    }
  }
  {
#line 233
  opj_free((void *)p_tree);
  }
#line 235
  return;
}
}
#line 236 "/root/patron-new/39/src/lib/openjp2/tgt.c"
void opj_tgt_reset(opj_tgt_tree_t *p_tree ) 
{ 
  OPJ_UINT32 i ;
  opj_tgt_node_t *l_current_node ;

  {
#line 239
  l_current_node = (opj_tgt_node_t *)0;
#line 241
  if (! p_tree) {
#line 242
    return;
  }
#line 245
  l_current_node = p_tree->nodes;
#line 246
  i = (OPJ_UINT32 )0;
  {
#line 246
  while (1) {
    while_continue: /* CIL Label */ ;

#line 246
    if (! (i < p_tree->numnodes)) {
#line 246
      goto while_break;
    }
#line 247
    l_current_node->value = 999;
#line 248
    l_current_node->low = 0;
#line 249
    l_current_node->known = (OPJ_UINT32 )0;
#line 250
    l_current_node ++;
#line 246
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 250
  return;
}
}
#line 254 "/root/patron-new/39/src/lib/openjp2/tgt.c"
void opj_tgt_setvalue(opj_tgt_tree_t *tree , OPJ_UINT32 leafno , OPJ_INT32 value ) 
{ 
  opj_tgt_node_t *node ;

  {
#line 257
  node = tree->nodes + leafno;
  {
#line 258
  while (1) {
    while_continue: /* CIL Label */ ;

#line 258
    if (node) {
#line 258
      if (! (node->value > value)) {
#line 258
        goto while_break;
      }
    } else {
#line 258
      goto while_break;
    }
#line 259
    node->value = value;
#line 260
    node = node->parent;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 264
  return;
}
}
#line 264 "/root/patron-new/39/src/lib/openjp2/tgt.c"
void opj_tgt_encode(opj_bio_t *bio , opj_tgt_tree_t *tree , OPJ_UINT32 leafno , OPJ_INT32 threshold ) 
{ 
  opj_tgt_node_t *stk[31] ;
  opj_tgt_node_t **stkptr ;
  opj_tgt_node_t *node ;
  OPJ_INT32 low ;
  opj_tgt_node_t **__cil_tmp9 ;

  {
#line 272
  stkptr = stk;
#line 273
  node = tree->nodes + leafno;
  {
#line 274
  while (1) {
    while_continue: /* CIL Label */ ;

#line 274
    if (! node->parent) {
#line 274
      goto while_break;
    }
#line 275
    __cil_tmp9 = stkptr;
#line 275
    stkptr ++;
#line 275
    *__cil_tmp9 = node;
#line 276
    node = node->parent;
  }
  while_break___2: /* CIL Label */ ;
  }

  while_break: 
#line 279
  low = 0;
  {
#line 280
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 281
    if (low > node->low) {
#line 282
      node->low = low;
    } else {
#line 284
      low = node->low;
    }
    {
#line 287
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 287
      if (! (low < threshold)) {
#line 287
        goto while_break___1;
      }
#line 288
      if (low >= node->value) {
#line 289
        if (! node->known) {
          {
#line 290
          opj_bio_write(bio, (OPJ_UINT32 )1, (OPJ_UINT32 )1);
#line 291
          node->known = (OPJ_UINT32 )1;
          }
        }
#line 293
        goto while_break___1;
      }
      {
#line 295
      opj_bio_write(bio, (OPJ_UINT32 )0, (OPJ_UINT32 )1);
#line 296
      low ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }

    while_break___1: 
#line 299
    node->low = low;
#line 300
    if ((unsigned long )stkptr == (unsigned long )(stk)) {
#line 301
      goto while_break___0;
    }
#line 303
    stkptr --;
#line 303
    node = *stkptr;
  }
  while_break___3: /* CIL Label */ ;
  }

  while_break___0: ;
#line 307
  return;
}
}
#line 307 "/root/patron-new/39/src/lib/openjp2/tgt.c"
OPJ_UINT32 opj_tgt_decode(opj_bio_t *bio , opj_tgt_tree_t *tree , OPJ_UINT32 leafno ,
                          OPJ_INT32 threshold ) 
{ 
  opj_tgt_node_t *stk[31] ;
  opj_tgt_node_t **stkptr ;
  opj_tgt_node_t *node ;
  OPJ_INT32 low ;
  opj_tgt_node_t **__cil_tmp9 ;
  OPJ_UINT32 __cil_tmp10 ;
  int tmp ;

  {
#line 315
  stkptr = stk;
#line 316
  node = tree->nodes + leafno;
  {
#line 317
  while (1) {
    while_continue: /* CIL Label */ ;

#line 317
    if (! node->parent) {
#line 317
      goto while_break;
    }
#line 318
    __cil_tmp9 = stkptr;
#line 318
    stkptr ++;
#line 318
    *__cil_tmp9 = node;
#line 319
    node = node->parent;
  }
  while_break___2: /* CIL Label */ ;
  }

  while_break: 
#line 322
  low = 0;
  {
#line 323
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 324
    if (low > node->low) {
#line 325
      node->low = low;
    } else {
#line 327
      low = node->low;
    }
    {
#line 329
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 329
      if (low < threshold) {
#line 329
        if (! (low < node->value)) {
#line 329
          goto while_break___1;
        }
      } else {
#line 329
        goto while_break___1;
      }
      {
#line 330
      __cil_tmp10 = opj_bio_read(bio, (OPJ_UINT32 )1);
      }
#line 330
      if (__cil_tmp10) {
#line 331
        node->value = low;
      } else {
#line 333
        low ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }

    while_break___1: 
#line 336
    node->low = low;
#line 337
    if ((unsigned long )stkptr == (unsigned long )(stk)) {
#line 338
      goto while_break___0;
    }
#line 340
    stkptr --;
#line 340
    node = *stkptr;
  }
  while_break___3: /* CIL Label */ ;
  }

  while_break___0: ;
#line 343
  if (node->value < threshold) {
#line 343
    tmp = 1;
  } else {
#line 343
    tmp = 0;
  }
#line 343
  return ((OPJ_UINT32 )tmp);
}
}
#line 114 "/root/patron-new/39/src/lib/openjp2/tcd.c"
__inline static OPJ_BOOL opj_tcd_init_tile(opj_tcd_t *p_tcd , OPJ_UINT32 p_tile_no ,
                                           OPJ_BOOL isEncoder , OPJ_FLOAT32 fraction ,
                                           OPJ_SIZE_T sizeof_block , opj_event_mgr_t *manager ) ;
#line 121
static OPJ_BOOL opj_tcd_code_block_dec_allocate(opj_tcd_cblk_dec_t *p_code_block ) ;
#line 127
static void opj_tcd_code_block_dec_deallocate(opj_tcd_precinct_t *p_precinct ) ;
#line 132
static OPJ_BOOL opj_tcd_code_block_enc_allocate(opj_tcd_cblk_enc_t *p_code_block ) ;
#line 138
static OPJ_BOOL opj_tcd_code_block_enc_allocate_data(opj_tcd_cblk_enc_t *p_code_block ) ;
#line 144
static void opj_tcd_code_block_enc_deallocate(opj_tcd_precinct_t *p_precinct ) ;
#line 151
static void opj_tcd_free_tile(opj_tcd_t *p_tcd ) ;
#line 154
static OPJ_BOOL opj_tcd_t2_decode(opj_tcd_t *p_tcd , OPJ_BYTE *p_src_data , OPJ_UINT32 *p_data_read ,
                                  OPJ_UINT32 p_max_src_size , opj_codestream_index_t *p_cstr_index ,
                                  opj_event_mgr_t *p_manager ) ;
#line 161
static OPJ_BOOL opj_tcd_t1_decode(opj_tcd_t *p_tcd , opj_event_mgr_t *p_manager ) ;
#line 164
static OPJ_BOOL opj_tcd_dwt_decode(opj_tcd_t *p_tcd ) ;
#line 166
static OPJ_BOOL opj_tcd_mct_decode(opj_tcd_t *p_tcd , opj_event_mgr_t *p_manager ) ;
#line 169
static OPJ_BOOL opj_tcd_dc_level_shift_decode(opj_tcd_t *p_tcd ) ;
#line 172
static OPJ_BOOL opj_tcd_dc_level_shift_encode(opj_tcd_t *p_tcd ) ;
#line 174
static OPJ_BOOL opj_tcd_mct_encode(opj_tcd_t *p_tcd ) ;
#line 176
static OPJ_BOOL opj_tcd_dwt_encode(opj_tcd_t *p_tcd ) ;
#line 178
static OPJ_BOOL opj_tcd_t1_encode(opj_tcd_t *p_tcd ) ;
#line 180
static OPJ_BOOL opj_tcd_t2_encode(opj_tcd_t *p_tcd , OPJ_BYTE *p_dest_data , OPJ_UINT32 *p_data_written ,
                                  OPJ_UINT32 p_max_dest_size , opj_codestream_info_t *p_cstr_info ,
                                  opj_tcd_marker_info_t *p_marker_info , opj_event_mgr_t *p_manager ) ;
#line 188
static OPJ_BOOL opj_tcd_rate_allocate_encode(opj_tcd_t *p_tcd , OPJ_BYTE *p_dest_data ,
                                             OPJ_UINT32 p_max_dest_size , opj_codestream_info_t *p_cstr_info ,
                                             opj_event_mgr_t *p_manager ) ;
#line 195
static OPJ_BOOL opj_tcd_is_whole_tilecomp_decoding(opj_tcd_t *p_tcd , OPJ_UINT32 compno ) ;
#line 203 "/root/patron-new/39/src/lib/openjp2/tcd.c"
opj_tcd_t *opj_tcd_create(OPJ_BOOL p_is_decoder ) 
{ 
  opj_tcd_t *l_tcd ;
  void *__cil_tmp3 ;
  int tmp ;
  void *__cil_tmp5 ;

  {
  {
#line 205
  l_tcd = (opj_tcd_t *)0;
#line 208
  __cil_tmp3 = opj_calloc((size_t )1, sizeof(opj_tcd_t ));
#line 208
  l_tcd = (opj_tcd_t *)__cil_tmp3;
  }
#line 209
  if (! l_tcd) {
#line 210
    return ((opj_tcd_t *)0);
  }
#line 213
  if (p_is_decoder) {
#line 213
    tmp = 1;
  } else {
#line 213
    tmp = 0;
  }
  {
#line 213
  l_tcd->m_is_decoder = (OPJ_BITFIELD )tmp;
#line 215
  __cil_tmp5 = opj_calloc((size_t )1, sizeof(opj_tcd_image_t ));
#line 215
  l_tcd->tcd_image = (opj_tcd_image_t *)__cil_tmp5;
  }
#line 216
  if (! l_tcd->tcd_image) {
    {
#line 217
    opj_free((void *)l_tcd);
    }
#line 218
    return ((opj_tcd_t *)0);
  }
#line 221
  return (l_tcd);
}
}
#line 227 "/root/patron-new/39/src/lib/openjp2/tcd.c"
void opj_tcd_rateallocate_fixed(opj_tcd_t *tcd ) 
{ 
  OPJ_UINT32 layno ;

  {
#line 231
  layno = (OPJ_UINT32 )0;
  {
#line 231
  while (1) {
    while_continue: /* CIL Label */ ;

#line 231
    if (! (layno < (tcd->tcp)->numlayers)) {
#line 231
      goto while_break;
    }
    {
#line 232
    opj_tcd_makelayer_fixed(tcd, layno, (OPJ_UINT32 )1);
#line 231
    layno ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 235
  return;
}
}
#line 237 "/root/patron-new/39/src/lib/openjp2/tcd.c"
void opj_tcd_makelayer(opj_tcd_t *tcd , OPJ_UINT32 layno , OPJ_FLOAT64 thresh , OPJ_UINT32 final ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 bandno ;
  OPJ_UINT32 precno ;
  OPJ_UINT32 cblkno ;
  OPJ_UINT32 passno ;
  opj_tcd_tile_t *tcd_tile ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  OPJ_BOOL __cil_tmp15 ;
  opj_tcd_precinct_t *prc ;
  opj_tcd_cblk_enc_t *cblk ;
  opj_tcd_layer_t *layer ;
  OPJ_UINT32 n ;
  OPJ_UINT32 dr ;
  OPJ_FLOAT64 dd ;
  opj_tcd_pass_t *pass ;

  {
#line 245
  tcd_tile = (tcd->tcd_image)->tiles;
#line 247
  tcd_tile->distolayer[layno] = (OPJ_FLOAT64 )0;
#line 249
  compno = (OPJ_UINT32 )0;
  {
#line 249
  while (1) {
    while_continue: /* CIL Label */ ;

#line 249
    if (! (compno < tcd_tile->numcomps)) {
#line 249
      goto while_break;
    }
#line 250
    tilec = tcd_tile->comps + compno;
#line 252
    resno = (OPJ_UINT32 )0;
    {
#line 252
    while (1) {
      while_continue___5: /* CIL Label */ ;

#line 252
      if (! (resno < tilec->numresolutions)) {
#line 252
        goto while_break___0;
      }
#line 253
      res = tilec->resolutions + resno;
#line 255
      bandno = (OPJ_UINT32 )0;
      {
#line 255
      while (1) {
        while_continue___6: /* CIL Label */ ;

        while_continue___1: ;
#line 255
        if (! (bandno < res->numbands)) {
#line 255
          goto while_break___1;
        }
        {
#line 256
        band = & res->bands[bandno];
#line 259
        __cil_tmp15 = opj_tcd_is_band_empty(band);
        }
#line 259
        if (__cil_tmp15) {
#line 260
          goto while_continue___1;
        }
#line 263
        precno = (OPJ_UINT32 )0;
        {
#line 263
        while (1) {
          while_continue___7: /* CIL Label */ ;

#line 263
          if (! (precno < res->pw * res->ph)) {
#line 263
            goto while_break___2;
          }
#line 264
          prc = band->precincts + precno;
#line 266
          cblkno = (OPJ_UINT32 )0;
          {
#line 266
          while (1) {
            while_continue___8: /* CIL Label */ ;

            while_continue___3: ;
#line 266
            if (! (cblkno < prc->cw * prc->ch)) {
#line 266
              goto while_break___3;
            }
#line 267
            cblk = prc->cblks.enc + cblkno;
#line 268
            layer = cblk->layers + layno;
#line 271
            if (layno == 0U) {
#line 272
              cblk->numpassesinlayers = (OPJ_UINT32 )0;
            }
#line 275
            n = cblk->numpassesinlayers;
#line 277
            if (thresh < (double )0) {
#line 279
              n = cblk->totalpasses;
            } else {
#line 281
              passno = cblk->numpassesinlayers;
              {
#line 281
              while (1) {
                while_continue___9: /* CIL Label */ ;

                while_continue___4: ;
#line 281
                if (! (passno < cblk->totalpasses)) {
#line 281
                  goto while_break___4;
                }
#line 284
                pass = cblk->passes + passno;
#line 286
                if (n == 0U) {
#line 287
                  dr = pass->rate;
#line 288
                  dd = pass->distortiondec;
                } else {
#line 290
                  dr = pass->rate - (cblk->passes + (n - 1U))->rate;
#line 291
                  dd = pass->distortiondec - (cblk->passes + (n - 1U))->distortiondec;
                }
#line 294
                if (! dr) {
#line 295
                  if (dd != (double )0) {
#line 296
                    n = passno + 1U;
                  }
#line 298
                  goto while_continue___4;
                }
#line 300
                if (thresh - dd / (double )dr < (double )2.22044604926e-16L) {
#line 302
                  n = passno + 1U;
                }
#line 281
                passno ++;
              }
              while_break___10: /* CIL Label */ ;
              }

              while_break___4: ;
            }
#line 307
            layer->numpasses = n - cblk->numpassesinlayers;
#line 309
            if (! layer->numpasses) {
#line 310
              layer->disto = (OPJ_FLOAT64 )0;
#line 311
              goto while_continue___3;
            }
#line 314
            if (cblk->numpassesinlayers == 0U) {
#line 315
              layer->len = (cblk->passes + (n - 1U))->rate;
#line 316
              layer->data = cblk->data;
#line 317
              layer->disto = (cblk->passes + (n - 1U))->distortiondec;
            } else {
#line 319
              layer->len = (cblk->passes + (n - 1U))->rate - (cblk->passes + (cblk->numpassesinlayers - 1U))->rate;
#line 321
              layer->data = cblk->data + (cblk->passes + (cblk->numpassesinlayers - 1U))->rate;
#line 322
              layer->disto = (cblk->passes + (n - 1U))->distortiondec - (cblk->passes + (cblk->numpassesinlayers - 1U))->distortiondec;
            }
#line 326
            tcd_tile->distolayer[layno] += layer->disto;
#line 328
            if (final) {
#line 329
              cblk->numpassesinlayers = n;
            }
#line 266
            cblkno ++;
          }
          while_break___9: /* CIL Label */ ;
          }

          while_break___3: 
#line 263
          precno ++;
        }
        while_break___8: /* CIL Label */ ;
        }

        while_break___2: 
#line 255
        bandno ++;
      }
      while_break___7: /* CIL Label */ ;
      }

      while_break___1: 
#line 252
      resno ++;
    }
    while_break___6: /* CIL Label */ ;
    }

    while_break___0: 
#line 249
    compno ++;
  }
  while_break___5: /* CIL Label */ ;
  }

  while_break: ;
#line 253
  return;
}
}
#line 338 "/root/patron-new/39/src/lib/openjp2/tcd.c"
void opj_tcd_makelayer_fixed(opj_tcd_t *tcd , OPJ_UINT32 layno , OPJ_UINT32 final ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 bandno ;
  OPJ_UINT32 precno ;
  OPJ_UINT32 cblkno ;
  OPJ_INT32 value ;
  OPJ_INT32 matrice[10][10][3] ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  opj_cp_t *cp ;
  opj_tcd_tile_t *tcd_tile ;
  opj_tcp_t *tcd_tcp ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  OPJ_BOOL __cil_tmp23 ;
  opj_tcd_precinct_t *prc ;
  opj_tcd_cblk_enc_t *cblk ;
  opj_tcd_layer_t *layer ;
  OPJ_UINT32 n ;
  OPJ_INT32 imsb ;

  {
#line 346
  cp = tcd->cp;
#line 347
  tcd_tile = (tcd->tcd_image)->tiles;
#line 348
  tcd_tcp = tcd->tcp;
#line 350
  compno = (OPJ_UINT32 )0;
  {
#line 350
  while (1) {
    while_continue: /* CIL Label */ ;

#line 350
    if (! (compno < tcd_tile->numcomps)) {
#line 350
      goto while_break;
    }
#line 351
    tilec = tcd_tile->comps + compno;
#line 353
    i = (OPJ_UINT32 )0;
    {
#line 353
    while (1) {
      while_continue___7: /* CIL Label */ ;

#line 353
      if (! (i < tcd_tcp->numlayers)) {
#line 353
        goto while_break___0;
      }
#line 354
      j = (OPJ_UINT32 )0;
      {
#line 354
      while (1) {
        while_continue___8: /* CIL Label */ ;

#line 354
        if (! (j < tilec->numresolutions)) {
#line 354
          goto while_break___1;
        }
#line 355
        k = (OPJ_UINT32 )0;
        {
#line 355
        while (1) {
          while_continue___9: /* CIL Label */ ;

#line 355
          if (! (k < 3U)) {
#line 355
            goto while_break___2;
          }
#line 356
          matrice[i][j][k] = (OPJ_INT32 )((OPJ_FLOAT32 )*(cp->m_specific_param.m_enc.m_matrice + (((i * tilec->numresolutions) * 3U + j * 3U) + k)) * (OPJ_FLOAT32 )((double )((tcd->image)->comps + compno)->prec / 16.));
#line 355
          k ++;
        }
        while_break___10: /* CIL Label */ ;
        }

        while_break___2: 
#line 354
        j ++;
      }
      while_break___9: /* CIL Label */ ;
      }

      while_break___1: 
#line 353
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }

    while_break___0: 
#line 364
    resno = (OPJ_UINT32 )0;
    {
#line 364
    while (1) {
      while_continue___10: /* CIL Label */ ;

#line 364
      if (! (resno < tilec->numresolutions)) {
#line 364
        goto while_break___3;
      }
#line 365
      res = tilec->resolutions + resno;
#line 367
      bandno = (OPJ_UINT32 )0;
      {
#line 367
      while (1) {
        while_continue___11: /* CIL Label */ ;

        while_continue___4: ;
#line 367
        if (! (bandno < res->numbands)) {
#line 367
          goto while_break___4;
        }
        {
#line 368
        band = & res->bands[bandno];
#line 371
        __cil_tmp23 = opj_tcd_is_band_empty(band);
        }
#line 371
        if (__cil_tmp23) {
#line 372
          goto while_continue___4;
        }
#line 375
        precno = (OPJ_UINT32 )0;
        {
#line 375
        while (1) {
          while_continue___12: /* CIL Label */ ;

#line 375
          if (! (precno < res->pw * res->ph)) {
#line 375
            goto while_break___5;
          }
#line 376
          prc = band->precincts + precno;
#line 378
          cblkno = (OPJ_UINT32 )0;
          {
#line 378
          while (1) {
            while_continue___13: /* CIL Label */ ;

            while_continue___6: ;
#line 378
            if (! (cblkno < prc->cw * prc->ch)) {
#line 378
              goto while_break___6;
            }
#line 379
            cblk = prc->cblks.enc + cblkno;
#line 380
            layer = cblk->layers + layno;
#line 382
            imsb = (OPJ_INT32 )(((tcd->image)->comps + compno)->prec - cblk->numbps);
#line 386
            if (layno == 0U) {
#line 387
              value = matrice[layno][resno][bandno];
#line 388
              if (imsb >= value) {
#line 389
                value = 0;
              } else {
#line 391
                value -= imsb;
              }
            } else {
#line 394
              value = matrice[layno][resno][bandno] - matrice[layno - 1U][resno][bandno];
#line 395
              if (imsb >= matrice[layno - 1U][resno][bandno]) {
#line 396
                value -= imsb - matrice[layno - 1U][resno][bandno];
#line 397
                if (value < 0) {
#line 398
                  value = 0;
                }
              }
            }
#line 403
            if (layno == 0U) {
#line 404
              cblk->numpassesinlayers = (OPJ_UINT32 )0;
            }
#line 407
            n = cblk->numpassesinlayers;
#line 408
            if (cblk->numpassesinlayers == 0U) {
#line 409
              if (value != 0) {
#line 410
                n = (3U * (OPJ_UINT32 )value - 2U) + cblk->numpassesinlayers;
              } else {
#line 412
                n = cblk->numpassesinlayers;
              }
            } else {
#line 415
              n = 3U * (OPJ_UINT32 )value + cblk->numpassesinlayers;
            }
#line 418
            layer->numpasses = n - cblk->numpassesinlayers;
#line 420
            if (! layer->numpasses) {
#line 421
              goto while_continue___6;
            }
#line 424
            if (cblk->numpassesinlayers == 0U) {
#line 425
              layer->len = (cblk->passes + (n - 1U))->rate;
#line 426
              layer->data = cblk->data;
            } else {
#line 428
              layer->len = (cblk->passes + (n - 1U))->rate - (cblk->passes + (cblk->numpassesinlayers - 1U))->rate;
#line 430
              layer->data = cblk->data + (cblk->passes + (cblk->numpassesinlayers - 1U))->rate;
            }
#line 433
            if (final) {
#line 434
              cblk->numpassesinlayers = n;
            }
#line 378
            cblkno ++;
          }
          while_break___14: /* CIL Label */ ;
          }

          while_break___6: 
#line 375
          precno ++;
        }
        while_break___13: /* CIL Label */ ;
        }

        while_break___5: 
#line 367
        bandno ++;
      }
      while_break___12: /* CIL Label */ ;
      }

      while_break___4: 
#line 364
      resno ++;
    }
    while_break___11: /* CIL Label */ ;
    }

    while_break___3: 
#line 350
    compno ++;
  }
  while_break___7: /* CIL Label */ ;
  }

  while_break: ;
#line 354
  return;
}
}
#line 443 "/root/patron-new/39/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_rateallocate(opj_tcd_t *tcd , OPJ_BYTE *dest , OPJ_UINT32 *p_data_written ,
                              OPJ_UINT32 len , opj_codestream_info_t *cstr_info ,
                              opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 bandno ;
  OPJ_UINT32 precno ;
  OPJ_UINT32 cblkno ;
  OPJ_UINT32 layno ;
  OPJ_UINT32 passno ;
  OPJ_FLOAT64 min ;
  OPJ_FLOAT64 max ;
  OPJ_FLOAT64 cumdisto[100] ;
  OPJ_FLOAT64 K ;
  OPJ_FLOAT64 maxSE ;
  opj_cp_t *cp ;
  opj_tcd_tile_t *tcd_tile ;
  opj_tcp_t *tcd_tcp ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  OPJ_BOOL __cil_tmp25 ;
  opj_tcd_precinct_t *prc ;
  opj_tcd_cblk_enc_t *cblk ;
  opj_tcd_pass_t *pass ;
  OPJ_INT32 dr ;
  OPJ_FLOAT64 dd ;
  OPJ_FLOAT64 rdslope ;
  opj_tile_info_t *tile_info ;
  void *__cil_tmp39 ;
  OPJ_FLOAT64 lo ;
  OPJ_FLOAT64 hi ;
  OPJ_UINT32 maxlen ;
  double __cil_tmp43 ;
  OPJ_UINT32 __cil_tmp44 ;
  OPJ_UINT32 tmp ;
  OPJ_FLOAT64 goodthresh ;
  OPJ_FLOAT64 stable_thresh ;
  OPJ_UINT32 i ;
  OPJ_FLOAT64 distotarget ;
  double __cil_tmp50 ;
  opj_t2_t *t2 ;
  opj_t2_t *__cil_tmp52 ;
  OPJ_FLOAT64 thresh ;
  OPJ_FLOAT64 distoachieved ;
  OPJ_BOOL __cil_tmp55 ;
  OPJ_FLOAT64 tmp___0 ;
  OPJ_FLOAT64 tmp___1 ;
  OPJ_BOOL __cil_tmp58 ;
  OPJ_FLOAT64 tmp___2 ;
  OPJ_FLOAT64 tmp___3 ;

  {
#line 454
  K = (OPJ_FLOAT64 )1;
#line 455
  maxSE = (OPJ_FLOAT64 )0;
#line 457
  cp = tcd->cp;
#line 458
  tcd_tile = (tcd->tcd_image)->tiles;
#line 459
  tcd_tcp = tcd->tcp;
#line 461
  min = (double )1.79769313487e+308L;
#line 462
  max = (OPJ_FLOAT64 )0;
#line 464
  tcd_tile->numpix = 0;
#line 466
  compno = (OPJ_UINT32 )0;
  {
#line 466
  while (1) {
    while_continue: /* CIL Label */ ;

#line 466
    if (! (compno < tcd_tile->numcomps)) {
#line 466
      goto while_break;
    }
#line 467
    tilec = tcd_tile->comps + compno;
#line 468
    tilec->numpix = 0;
#line 470
    resno = (OPJ_UINT32 )0;
    {
#line 470
    while (1) {
      while_continue___7: /* CIL Label */ ;

#line 470
      if (! (resno < tilec->numresolutions)) {
#line 470
        goto while_break___0;
      }
#line 471
      res = tilec->resolutions + resno;
#line 473
      bandno = (OPJ_UINT32 )0;
      {
#line 473
      while (1) {
        while_continue___8: /* CIL Label */ ;

        while_continue___1: ;
#line 473
        if (! (bandno < res->numbands)) {
#line 473
          goto while_break___1;
        }
        {
#line 474
        band = & res->bands[bandno];
#line 477
        __cil_tmp25 = opj_tcd_is_band_empty(band);
        }
#line 477
        if (__cil_tmp25) {
#line 478
          goto while_continue___1;
        }
#line 481
        precno = (OPJ_UINT32 )0;
        {
#line 481
        while (1) {
          while_continue___9: /* CIL Label */ ;

#line 481
          if (! (precno < res->pw * res->ph)) {
#line 481
            goto while_break___2;
          }
#line 482
          prc = band->precincts + precno;
#line 484
          cblkno = (OPJ_UINT32 )0;
          {
#line 484
          while (1) {
            while_continue___10: /* CIL Label */ ;

#line 484
            if (! (cblkno < prc->cw * prc->ch)) {
#line 484
              goto while_break___3;
            }
#line 485
            cblk = prc->cblks.enc + cblkno;
#line 487
            passno = (OPJ_UINT32 )0;
            {
#line 487
            while (1) {
              while_continue___11: /* CIL Label */ ;

              while_continue___4: ;
#line 487
              if (! (passno < cblk->totalpasses)) {
#line 487
                goto while_break___4;
              }
#line 488
              pass = cblk->passes + passno;
#line 492
              if (passno == 0U) {
#line 493
                dr = (OPJ_INT32 )pass->rate;
#line 494
                dd = pass->distortiondec;
              } else {
#line 496
                dr = (OPJ_INT32 )(pass->rate - (cblk->passes + (passno - 1U))->rate);
#line 497
                dd = pass->distortiondec - (cblk->passes + (passno - 1U))->distortiondec;
              }
#line 500
              if (dr == 0) {
#line 501
                goto while_continue___4;
              }
#line 504
              rdslope = dd / (double )dr;
#line 505
              if (rdslope < min) {
#line 506
                min = rdslope;
              }
#line 509
              if (rdslope > max) {
#line 510
                max = rdslope;
              }
#line 487
              passno ++;
            }
            while_break___12: /* CIL Label */ ;
            }

            while_break___4: 
#line 515
            tcd_tile->numpix += (cblk->x1 - cblk->x0) * (cblk->y1 - cblk->y0);
#line 516
            tilec->numpix += (cblk->x1 - cblk->x0) * (cblk->y1 - cblk->y0);
#line 484
            cblkno ++;
          }
          while_break___11: /* CIL Label */ ;
          }

          while_break___3: 
#line 481
          precno ++;
        }
        while_break___10: /* CIL Label */ ;
        }

        while_break___2: 
#line 473
        bandno ++;
      }
      while_break___9: /* CIL Label */ ;
      }

      while_break___1: 
#line 470
      resno ++;
    }
    while_break___8: /* CIL Label */ ;
    }

    while_break___0: 
#line 522
    maxSE += (((OPJ_FLOAT64 )(1 << ((tcd->image)->comps + compno)->prec) - 1.) * ((OPJ_FLOAT64 )(1 << ((tcd->image)->comps + compno)->prec) - 1.)) * (OPJ_FLOAT64 )tilec->numpix;
#line 466
    compno ++;
  }
  while_break___7: /* CIL Label */ ;
  }

  while_break: ;
#line 528
  if (cstr_info) {
    {
#line 529
    tile_info = cstr_info->tile + tcd->tcd_tileno;
#line 530
    tile_info->numpix = tcd_tile->numpix;
#line 531
    tile_info->distotile = tcd_tile->distotile;
#line 532
    __cil_tmp39 = opj_malloc((unsigned long )tcd_tcp->numlayers * sizeof(OPJ_FLOAT64 ));
#line 532
    tile_info->thresh = (OPJ_FLOAT64 *)__cil_tmp39;
    }
#line 534
    if (! tile_info->thresh) {
#line 536
      return (0);
    }
  }
#line 540
  layno = (OPJ_UINT32 )0;
  {
#line 540
  while (1) {
    while_continue___12: /* CIL Label */ ;

#line 540
    if (! (layno < tcd_tcp->numlayers)) {
#line 540
      goto while_break___5;
    }
#line 541
    lo = min;
#line 542
    hi = max;
#line 543
    if (tcd_tcp->rates[layno] > 0.f) {
      {
#line 543
      __cil_tmp43 = ceil((double )tcd_tcp->rates[layno]);
#line 543
      __cil_tmp44 = opj_uint_min((OPJ_UINT32 )__cil_tmp43, len);
#line 543
      tmp = __cil_tmp44;
      }
    } else {
#line 543
      tmp = len;
    }
    {
#line 543
    maxlen = tmp;
#line 545
    goodthresh = (OPJ_FLOAT64 )0;
#line 546
    stable_thresh = (OPJ_FLOAT64 )0;
#line 551
    __cil_tmp50 = pow((double )((OPJ_FLOAT32 )10), (double )(tcd_tcp->distoratio[layno] / (float )10));
#line 551
    distotarget = tcd_tile->distotile - (K * maxSE) / __cil_tmp50;
    }
#line 558
    if ((int )cp->m_specific_param.m_enc.m_disto_alloc == 1) {
#line 558
      if (tcd_tcp->rates[layno] > 0.f) {
        _L___2: 
        {
#line 562
        __cil_tmp52 = opj_t2_create(tcd->image, cp);
#line 562
        t2 = __cil_tmp52;
#line 563
        thresh = (OPJ_FLOAT64 )0;
        }
#line 565
        if ((unsigned long )t2 == (unsigned long )((opj_t2_t *)0)) {
#line 566
          return (0);
        }
#line 569
        i = (OPJ_UINT32 )0;
        {
#line 569
        while (1) {
          while_continue___13: /* CIL Label */ ;

          while_continue___6: ;
#line 569
          if (! (i < 128U)) {
#line 569
            goto while_break___6;
          }
          {
#line 570
          distoachieved = (OPJ_FLOAT64 )0;
#line 572
          thresh = (lo + hi) / (double )2;
#line 574
          opj_tcd_makelayer(tcd, layno, thresh, (OPJ_UINT32 )0);
          }
#line 576
          if (cp->m_specific_param.m_enc.m_fixed_quality) {
#line 577
            if ((int )cp->rsiz >= 3) {
#line 577
              if ((int )cp->rsiz <= 6) {
                _L: 
                {
#line 578
                __cil_tmp55 = opj_t2_encode_packets(t2, tcd->tcd_tileno, tcd_tile,
                                                    layno + 1U, dest, p_data_written,
                                                    maxlen, cstr_info, (opj_tcd_marker_info_t *)((void *)0),
                                                    tcd->cur_tp_num, tcd->tp_pos,
                                                    tcd->cur_pino, (J2K_T2_MODE )0,
                                                    p_manager);
                }
#line 578
                if (! __cil_tmp55) {
#line 583
                  lo = thresh;
#line 584
                  goto while_continue___6;
                } else {
#line 586
                  if (layno == 0U) {
#line 586
                    tmp___0 = tcd_tile->distolayer[0];
                  } else {
#line 586
                    tmp___0 = cumdisto[layno - 1U] + tcd_tile->distolayer[layno];
                  }
#line 586
                  distoachieved = tmp___0;
#line 589
                  if (distoachieved < distotarget) {
#line 590
                    hi = thresh;
#line 591
                    stable_thresh = thresh;
#line 592
                    goto while_continue___6;
                  } else {
#line 594
                    lo = thresh;
                  }
                }
              } else {
#line 577
                goto _L___1;
              }
            } else
            _L___1: 
#line 577
            if ((int )cp->rsiz >= 1024) {
#line 577
              if ((int )cp->rsiz <= 2459) {
#line 577
                goto _L;
              } else {
#line 577
                goto _L___0;
              }
            } else {
              _L___0: 
#line 598
              if (layno == 0U) {
#line 598
                tmp___1 = tcd_tile->distolayer[0];
              } else {
#line 598
                tmp___1 = cumdisto[layno - 1U] + tcd_tile->distolayer[layno];
              }
#line 598
              distoachieved = tmp___1;
#line 601
              if (distoachieved < distotarget) {
#line 602
                hi = thresh;
#line 603
                stable_thresh = thresh;
#line 604
                goto while_continue___6;
              }
#line 606
              lo = thresh;
            }
          } else {
            {
#line 609
            __cil_tmp58 = opj_t2_encode_packets(t2, tcd->tcd_tileno, tcd_tile, layno + 1U,
                                                dest, p_data_written, maxlen, cstr_info,
                                                (opj_tcd_marker_info_t *)((void *)0),
                                                tcd->cur_tp_num, tcd->tp_pos, tcd->cur_pino,
                                                (J2K_T2_MODE )0, p_manager);
            }
#line 609
            if (! __cil_tmp58) {
#line 615
              lo = thresh;
#line 616
              goto while_continue___6;
            }
#line 619
            hi = thresh;
#line 620
            stable_thresh = thresh;
          }
#line 569
          i ++;
        }
        while_break___14: /* CIL Label */ ;
        }

        while_break___6: ;
#line 624
        if (stable_thresh == (double )0) {
#line 624
          tmp___2 = thresh;
        } else {
#line 624
          tmp___2 = stable_thresh;
        }
        {
#line 624
        goodthresh = tmp___2;
#line 626
        opj_t2_destroy(t2);
        }
      } else {
#line 558
        goto _L___3;
      }
    } else
    _L___3: 
#line 558
    if ((int )cp->m_specific_param.m_enc.m_fixed_quality == 1) {
#line 558
      if ((double )tcd_tcp->distoratio[layno] > 0.) {
#line 558
        goto _L___2;
      } else {
#line 629
        goodthresh = (OPJ_FLOAT64 )-1;
      }
    } else {
#line 629
      goodthresh = (OPJ_FLOAT64 )-1;
    }
#line 632
    if (cstr_info) {
#line 633
      *((cstr_info->tile + tcd->tcd_tileno)->thresh + layno) = goodthresh;
    }
    {
#line 636
    opj_tcd_makelayer(tcd, layno, goodthresh, (OPJ_UINT32 )1);
    }
#line 639
    if (layno == 0U) {
#line 639
      tmp___3 = tcd_tile->distolayer[0];
    } else {
#line 639
      tmp___3 = cumdisto[layno - 1U] + tcd_tile->distolayer[layno];
    }
#line 639
    cumdisto[layno] = tmp___3;
#line 540
    layno ++;
  }
  while_break___13: /* CIL Label */ ;
  }

  while_break___5: ;
#line 643
  return (1);
}
}
#line 646 "/root/patron-new/39/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_init(opj_tcd_t *p_tcd , opj_image_t *p_image , opj_cp_t *p_cp , opj_thread_pool_t *p_tp ) 
{ 
  void *__cil_tmp5 ;
  void *__cil_tmp6 ;

  {
  {
#line 651
  p_tcd->image = p_image;
#line 652
  p_tcd->cp = p_cp;
#line 654
  __cil_tmp5 = opj_calloc((size_t )1, sizeof(opj_tcd_tile_t ));
#line 654
  (p_tcd->tcd_image)->tiles = (opj_tcd_tile_t *)__cil_tmp5;
  }
#line 656
  if (! (p_tcd->tcd_image)->tiles) {
#line 657
    return (0);
  }
  {
#line 660
  __cil_tmp6 = opj_calloc((size_t )p_image->numcomps, sizeof(opj_tcd_tilecomp_t ));
#line 660
  ((p_tcd->tcd_image)->tiles)->comps = (opj_tcd_tilecomp_t *)__cil_tmp6;
  }
#line 662
  if (! ((p_tcd->tcd_image)->tiles)->comps) {
#line 663
    return (0);
  }
#line 666
  ((p_tcd->tcd_image)->tiles)->numcomps = p_image->numcomps;
#line 667
  p_tcd->tp_pos = p_cp->m_specific_param.m_enc.m_tp_pos;
#line 668
  p_tcd->thread_pool = p_tp;
#line 670
  return (1);
}
}
#line 676 "/root/patron-new/39/src/lib/openjp2/tcd.c"
void opj_tcd_destroy(opj_tcd_t *tcd ) 
{ 


  {
#line 678
  if (tcd) {
    {
#line 679
    opj_tcd_free_tile(tcd);
    }
#line 681
    if (tcd->tcd_image) {
      {
#line 682
      opj_free((void *)tcd->tcd_image);
#line 683
      tcd->tcd_image = (opj_tcd_image_t *)0;
      }
    }
    {
#line 686
    opj_free((void *)tcd->used_component);
#line 688
    opj_free((void *)tcd);
    }
  }
#line 691
  return;
}
}
#line 692 "/root/patron-new/39/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_alloc_tile_component_data(opj_tcd_tilecomp_t *l_tilec ) 
{ 
  void *__cil_tmp2 ;
  void *__cil_tmp3 ;

  {
#line 694
  if ((unsigned long )l_tilec->data == (unsigned long )((OPJ_INT32 *)0)) {
    _L: 
    {
#line 697
    __cil_tmp2 = opj_image_data_alloc(l_tilec->data_size_needed);
#line 697
    l_tilec->data = (OPJ_INT32 *)__cil_tmp2;
    }
#line 698
    if (! l_tilec->data) {
#line 698
      if (l_tilec->data_size_needed != 0UL) {
#line 699
        return (0);
      }
    }
#line 702
    l_tilec->data_size = l_tilec->data_size_needed;
#line 703
    l_tilec->ownsData = 1;
  } else
#line 694
  if (l_tilec->data_size_needed > l_tilec->data_size) {
#line 694
    if (l_tilec->ownsData == 0) {
#line 694
      goto _L;
    } else {
#line 694
      goto _L___4;
    }
  } else
  _L___4: 
#line 704
  if (l_tilec->data_size_needed > l_tilec->data_size) {
    {
#line 706
    opj_image_data_free((void *)l_tilec->data);
#line 707
    __cil_tmp3 = opj_image_data_alloc(l_tilec->data_size_needed);
#line 707
    l_tilec->data = (OPJ_INT32 *)__cil_tmp3;
    }
#line 708
    if (! l_tilec->data) {
#line 709
      l_tilec->data_size = (size_t )0;
#line 710
      l_tilec->data_size_needed = (size_t )0;
#line 711
      l_tilec->ownsData = 0;
#line 712
      return (0);
    }
#line 715
    l_tilec->data_size = l_tilec->data_size_needed;
#line 716
    l_tilec->ownsData = 1;
  }
#line 718
  return (1);
}
}
#line 723 "/root/patron-new/39/src/lib/openjp2/tcd.c"
__inline static OPJ_BOOL opj_tcd_init_tile(opj_tcd_t *p_tcd , OPJ_UINT32 p_tile_no ,
                                           OPJ_BOOL isEncoder , OPJ_FLOAT32 fraction ,
                                           OPJ_SIZE_T sizeof_block , opj_event_mgr_t *manager ) 
{ 
  OPJ_UINT32 (*l_gain_ptr)(OPJ_UINT32  ) ;
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 bandno ;
  OPJ_UINT32 precno ;
  OPJ_UINT32 cblkno ;
  opj_tcp_t *l_tcp ;
  opj_cp_t *l_cp ;
  opj_tcd_tile_t *l_tile ;
  opj_tccp_t *l_tccp ;
  opj_tcd_tilecomp_t *l_tilec ;
  opj_image_comp_t *l_image_comp ;
  opj_tcd_resolution_t *l_res ;
  opj_tcd_band_t *l_band ;
  opj_stepsize_t *l_step_size ;
  opj_tcd_precinct_t *l_current_precinct ;
  opj_image_t *l_image ;
  OPJ_UINT32 p ;
  OPJ_UINT32 q ;
  OPJ_UINT32 l_level_no ;
  OPJ_UINT32 l_pdx ;
  OPJ_UINT32 l_pdy ;
  OPJ_UINT32 l_gain ;
  OPJ_INT32 l_x0b ;
  OPJ_INT32 l_y0b ;
  OPJ_UINT32 l_tx0 ;
  OPJ_UINT32 l_ty0 ;
  OPJ_INT32 l_tl_prc_x_start ;
  OPJ_INT32 l_tl_prc_y_start ;
  OPJ_INT32 l_br_prc_x_end ;
  OPJ_INT32 l_br_prc_y_end ;
  OPJ_UINT32 l_nb_precincts ;
  OPJ_UINT32 l_nb_precinct_size ;
  OPJ_UINT32 l_nb_code_blocks ;
  OPJ_UINT32 l_nb_code_blocks_size ;
  OPJ_UINT32 l_data_size ;
  OPJ_UINT32 __cil_tmp43 ;
  OPJ_UINT32 __cil_tmp44 ;
  OPJ_UINT32 __cil_tmp45 ;
  OPJ_UINT32 __cil_tmp46 ;
  OPJ_UINT32 __cil_tmp47 ;
  OPJ_UINT32 __cil_tmp48 ;
  OPJ_SIZE_T l_tile_data_size ;
  OPJ_SIZE_T w ;
  OPJ_SIZE_T h ;
  void *__cil_tmp56 ;
  opj_tcd_resolution_t *new_resolutions ;
  void *__cil_tmp58 ;
  OPJ_INT32 tlcbgxstart ;
  OPJ_INT32 tlcbgystart ;
  OPJ_UINT32 cbgwidthexpn ;
  OPJ_UINT32 cbgheightexpn ;
  OPJ_UINT32 cblkwidthexpn ;
  OPJ_UINT32 cblkheightexpn ;
  OPJ_INT32 __cil_tmp69 ;
  OPJ_INT32 __cil_tmp70 ;
  OPJ_UINT32 tmp ;
  OPJ_INT32 __cil_tmp72 ;
  OPJ_UINT32 tmp___0 ;
  OPJ_INT32 __cil_tmp74 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  OPJ_INT32 numbps ;
  OPJ_BOOL __cil_tmp90 ;
  double __cil_tmp92 ;
  void *__cil_tmp93 ;
  opj_tcd_precinct_t *new_precincts ;
  void *__cil_tmp95 ;
  OPJ_INT32 tlcblkxstart ;
  OPJ_INT32 tlcblkystart ;
  OPJ_INT32 brcblkxend ;
  OPJ_INT32 brcblkyend ;
  OPJ_INT32 cbgxstart ;
  OPJ_INT32 cbgystart ;
  OPJ_INT32 cbgxend ;
  OPJ_INT32 cbgyend ;
  OPJ_INT32 __cil_tmp108 ;
  OPJ_INT32 __cil_tmp109 ;
  OPJ_INT32 __cil_tmp110 ;
  OPJ_INT32 __cil_tmp111 ;
  void *new_blocks ;
  void *__cil_tmp114 ;
  OPJ_INT32 cblkxstart ;
  OPJ_INT32 cblkystart ;
  OPJ_INT32 cblkxend ;
  OPJ_INT32 cblkyend ;
  opj_tcd_cblk_enc_t *l_code_block ;
  OPJ_BOOL __cil_tmp124 ;
  OPJ_BOOL __cil_tmp129 ;
  opj_tcd_cblk_dec_t *l_code_block___0 ;
  OPJ_BOOL __cil_tmp131 ;

  {
  {
#line 727
  l_gain_ptr = (OPJ_UINT32 (*)(OPJ_UINT32  ))0;
#line 729
  l_tcp = (opj_tcp_t *)0;
#line 730
  l_cp = (opj_cp_t *)0;
#line 731
  l_tile = (opj_tcd_tile_t *)0;
#line 732
  l_tccp = (opj_tccp_t *)0;
#line 733
  l_tilec = (opj_tcd_tilecomp_t *)0;
#line 734
  l_image_comp = (opj_image_comp_t *)0;
#line 735
  l_res = (opj_tcd_resolution_t *)0;
#line 736
  l_band = (opj_tcd_band_t *)0;
#line 737
  l_step_size = (opj_stepsize_t *)0;
#line 738
  l_current_precinct = (opj_tcd_precinct_t *)0;
#line 739
  l_image = (opj_image_t *)0;
#line 759
  l_cp = p_tcd->cp;
#line 760
  l_tcp = l_cp->tcps + p_tile_no;
#line 761
  l_tile = (p_tcd->tcd_image)->tiles;
#line 762
  l_tccp = l_tcp->tccps;
#line 763
  l_tilec = l_tile->comps;
#line 764
  l_image = p_tcd->image;
#line 765
  l_image_comp = (p_tcd->image)->comps;
#line 767
  p = p_tile_no % l_cp->tw;
#line 768
  q = p_tile_no / l_cp->tw;
#line 772
  l_tx0 = l_cp->tx0 + p * l_cp->tdx;
#line 774
  __cil_tmp43 = opj_uint_max(l_tx0, l_image->x0);
#line 774
  l_tile->x0 = (OPJ_INT32 )__cil_tmp43;
#line 775
  __cil_tmp44 = opj_uint_adds(l_tx0, l_cp->tdx);
#line 775
  __cil_tmp45 = opj_uint_min(__cil_tmp44, l_image->x1);
#line 775
  l_tile->x1 = (OPJ_INT32 )__cil_tmp45;
  }
#line 778
  if (l_tile->x0 < 0) {
    {
#line 779
    opj_event_msg(manager, 1, "Tile X coordinates are not supported\nU");
    }
#line 780
    return (0);
  } else
#line 778
  if (l_tile->x1 <= l_tile->x0) {
    {
#line 779
    opj_event_msg(manager, 1, "Tile X coordinates are not supported\nU");
    }
#line 780
    return (0);
  }
  {
#line 782
  l_ty0 = l_cp->ty0 + q * l_cp->tdy;
#line 784
  __cil_tmp46 = opj_uint_max(l_ty0, l_image->y0);
#line 784
  l_tile->y0 = (OPJ_INT32 )__cil_tmp46;
#line 785
  __cil_tmp47 = opj_uint_adds(l_ty0, l_cp->tdy);
#line 785
  __cil_tmp48 = opj_uint_min(__cil_tmp47, l_image->y1);
#line 785
  l_tile->y1 = (OPJ_INT32 )__cil_tmp48;
  }
#line 788
  if (l_tile->y0 < 0) {
    {
#line 789
    opj_event_msg(manager, 1, "Tile Y coordinates are not supported\nU");
    }
#line 790
    return (0);
  } else
#line 788
  if (l_tile->y1 <= l_tile->y0) {
    {
#line 789
    opj_event_msg(manager, 1, "Tile Y coordinates are not supported\nU");
    }
#line 790
    return (0);
  }
#line 795
  if (l_tccp->numresolutions == 0U) {
    {
#line 796
    opj_event_msg(manager, 1, "tiles require at least one resolution\n");
    }
#line 797
    return (0);
  }
#line 802
  compno = (OPJ_UINT32 )0;
  {
#line 802
  while (1) {
    while_continue: /* CIL Label */ ;

#line 802
    if (! (compno < l_tile->numcomps)) {
#line 802
      goto while_break;
    }
    {
#line 804
    l_image_comp->resno_decoded = (OPJ_UINT32 )0;
#line 806
    l_tilec->x0 = opj_int_ceildiv(l_tile->x0, (OPJ_INT32 )l_image_comp->dx);
#line 807
    l_tilec->y0 = opj_int_ceildiv(l_tile->y0, (OPJ_INT32 )l_image_comp->dy);
#line 808
    l_tilec->x1 = opj_int_ceildiv(l_tile->x1, (OPJ_INT32 )l_image_comp->dx);
#line 809
    l_tilec->y1 = opj_int_ceildiv(l_tile->y1, (OPJ_INT32 )l_image_comp->dy);
#line 810
    l_tilec->compno = compno;
#line 813
    l_tilec->numresolutions = l_tccp->numresolutions;
    }
#line 814
    if (l_tccp->numresolutions < l_cp->m_specific_param.m_dec.m_reduce) {
#line 815
      l_tilec->minimum_num_resolutions = (OPJ_UINT32 )1;
    } else {
#line 817
      l_tilec->minimum_num_resolutions = l_tccp->numresolutions - l_cp->m_specific_param.m_dec.m_reduce;
    }
#line 821
    if (isEncoder) {
#line 825
      w = (OPJ_SIZE_T )(l_tilec->x1 - l_tilec->x0);
#line 826
      h = (OPJ_SIZE_T )(l_tilec->y1 - l_tilec->y0);
#line 829
      if (h > 0UL) {
#line 829
        if (w > 0xffffffffffffffffUL / h) {
          {
#line 830
          opj_event_msg(manager, 1, "Size of tile data exceeds system limits\n\220");
          }
#line 831
          return (0);
        }
      }
#line 833
      l_tile_data_size = w * h;
#line 835
      if (0xffffffffffffffffUL / sizeof(OPJ_UINT32 ) < l_tile_data_size) {
        {
#line 836
        opj_event_msg(manager, 1, "Size of tile data exceeds system limits\n\220");
        }
#line 837
        return (0);
      }
#line 839
      l_tile_data_size *= sizeof(OPJ_UINT32 );
#line 841
      l_tilec->data_size_needed = l_tile_data_size;
    }
    {
#line 844
    l_data_size = l_tilec->numresolutions * (OPJ_UINT32 )sizeof(opj_tcd_resolution_t );
#line 847
    opj_image_data_free((void *)l_tilec->data_win);
#line 848
    l_tilec->data_win = (OPJ_INT32 *)((void *)0);
#line 849
    l_tilec->win_x0 = (OPJ_UINT32 )0;
#line 850
    l_tilec->win_y0 = (OPJ_UINT32 )0;
#line 851
    l_tilec->win_x1 = (OPJ_UINT32 )0;
#line 852
    l_tilec->win_y1 = (OPJ_UINT32 )0;
    }
#line 854
    if ((unsigned long )l_tilec->resolutions == (unsigned long )((opj_tcd_resolution_t *)0)) {
      {
#line 855
      __cil_tmp56 = opj_malloc((size_t )l_data_size);
#line 855
      l_tilec->resolutions = (opj_tcd_resolution_t *)__cil_tmp56;
      }
#line 856
      if (! l_tilec->resolutions) {
#line 857
        return (0);
      }
      {
#line 860
      l_tilec->resolutions_size = l_data_size;
#line 861
      memset((void *)l_tilec->resolutions, 0, (unsigned long )l_data_size);
      }
    } else
#line 862
    if (l_data_size > l_tilec->resolutions_size) {
      {
#line 863
      __cil_tmp58 = opj_realloc((void *)l_tilec->resolutions, (size_t )l_data_size);
#line 863
      new_resolutions = (opj_tcd_resolution_t *)__cil_tmp58;
      }
#line 865
      if (! new_resolutions) {
        {
#line 866
        opj_event_msg(manager, 1, "Not enough memory for tile resolutions\n");
#line 867
        opj_free((void *)l_tilec->resolutions);
#line 868
        l_tilec->resolutions = (opj_tcd_resolution_t *)((void *)0);
#line 869
        l_tilec->resolutions_size = (OPJ_UINT32 )0;
        }
#line 870
        return (0);
      }
      {
#line 872
      l_tilec->resolutions = new_resolutions;
#line 874
      memset((void *)((OPJ_BYTE *)l_tilec->resolutions + l_tilec->resolutions_size),
             0, (unsigned long )(l_data_size - l_tilec->resolutions_size));
#line 876
      l_tilec->resolutions_size = l_data_size;
      }
    }
#line 879
    l_level_no = l_tilec->numresolutions;
#line 880
    l_res = l_tilec->resolutions;
#line 881
    l_step_size = l_tccp->stepsizes;
#line 882
    if (l_tccp->qmfbid == 0U) {
#line 883
      l_gain_ptr = & opj_dwt_getgain_real;
    } else {
#line 885
      l_gain_ptr = & opj_dwt_getgain;
    }
#line 889
    resno = (OPJ_UINT32 )0;
    {
#line 889
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 889
      if (! (resno < l_tilec->numresolutions)) {
#line 889
        goto while_break___0;
      }
      {
#line 895
      l_level_no --;
#line 898
      l_res->x0 = opj_int_ceildivpow2(l_tilec->x0, (OPJ_INT32 )l_level_no);
#line 899
      l_res->y0 = opj_int_ceildivpow2(l_tilec->y0, (OPJ_INT32 )l_level_no);
#line 900
      l_res->x1 = opj_int_ceildivpow2(l_tilec->x1, (OPJ_INT32 )l_level_no);
#line 901
      l_res->y1 = opj_int_ceildivpow2(l_tilec->y1, (OPJ_INT32 )l_level_no);
#line 905
      l_pdx = l_tccp->prcw[resno];
#line 906
      l_pdy = l_tccp->prch[resno];
#line 909
      __cil_tmp69 = opj_int_floordivpow2(l_res->x0, (OPJ_INT32 )l_pdx);
#line 909
      l_tl_prc_x_start = __cil_tmp69 << l_pdx;
#line 910
      __cil_tmp70 = opj_int_floordivpow2(l_res->y0, (OPJ_INT32 )l_pdy);
#line 910
      l_tl_prc_y_start = __cil_tmp70 << l_pdy;
#line 912
      __cil_tmp72 = opj_int_ceildivpow2(l_res->x1, (OPJ_INT32 )l_pdx);
#line 912
      tmp = (OPJ_UINT32 )__cil_tmp72 << l_pdx;
      }
#line 914
      if (tmp > 2147483647U) {
        {
#line 915
        opj_event_msg(manager, 1, "Integer overflow\n");
        }
#line 916
        return (0);
      }
      {
#line 918
      l_br_prc_x_end = (OPJ_INT32 )tmp;
#line 921
      __cil_tmp74 = opj_int_ceildivpow2(l_res->y1, (OPJ_INT32 )l_pdy);
#line 921
      tmp___0 = (OPJ_UINT32 )__cil_tmp74 << l_pdy;
      }
#line 923
      if (tmp___0 > 2147483647U) {
        {
#line 924
        opj_event_msg(manager, 1, "Integer overflow\n");
        }
#line 925
        return (0);
      }
#line 927
      l_br_prc_y_end = (OPJ_INT32 )tmp___0;
#line 931
      if (l_res->x0 == l_res->x1) {
#line 931
        tmp___1 = 0U;
      } else {
#line 931
        tmp___1 = (OPJ_UINT32 )((l_br_prc_x_end - l_tl_prc_x_start) >> l_pdx);
      }
#line 931
      l_res->pw = tmp___1;
#line 933
      if (l_res->y0 == l_res->y1) {
#line 933
        tmp___2 = 0U;
      } else {
#line 933
        tmp___2 = (OPJ_UINT32 )((l_br_prc_y_end - l_tl_prc_y_start) >> l_pdy);
      }
#line 933
      l_res->ph = tmp___2;
#line 937
      if (l_res->pw != 0U) {
#line 937
        if (4294967295U / l_res->pw < l_res->ph) {
          {
#line 938
          opj_event_msg(manager, 1, "Size of tile data exceeds system limits\n\220");
          }
#line 939
          return (0);
        }
      }
#line 941
      l_nb_precincts = l_res->pw * l_res->ph;
#line 943
      if (4294967295U / (OPJ_UINT32 )sizeof(opj_tcd_precinct_t ) < l_nb_precincts) {
        {
#line 945
        opj_event_msg(manager, 1, "Size of tile data exceeds system limits\n\220");
        }
#line 946
        return (0);
      }
#line 948
      l_nb_precinct_size = l_nb_precincts * (OPJ_UINT32 )sizeof(opj_tcd_precinct_t );
#line 950
      if (resno == 0U) {
#line 951
        tlcbgxstart = l_tl_prc_x_start;
#line 952
        tlcbgystart = l_tl_prc_y_start;
#line 955
        cbgwidthexpn = l_pdx;
#line 956
        cbgheightexpn = l_pdy;
#line 957
        l_res->numbands = (OPJ_UINT32 )1;
      } else {
        {
#line 959
        tlcbgxstart = opj_int_ceildivpow2(l_tl_prc_x_start, 1);
#line 960
        tlcbgystart = opj_int_ceildivpow2(l_tl_prc_y_start, 1);
#line 963
        cbgwidthexpn = l_pdx - 1U;
#line 964
        cbgheightexpn = l_pdy - 1U;
#line 965
        l_res->numbands = (OPJ_UINT32 )3;
        }
      }
      {
#line 968
      cblkwidthexpn = opj_uint_min(l_tccp->cblkw, cbgwidthexpn);
#line 969
      cblkheightexpn = opj_uint_min(l_tccp->cblkh, cbgheightexpn);
#line 970
      l_band = l_res->bands;
#line 972
      bandno = (OPJ_UINT32 )0;
      }
      {
#line 972
      while (1) {
        while_continue___3: /* CIL Label */ ;

        while_continue___1: ;
#line 972
        if (! (bandno < l_res->numbands)) {
#line 972
          goto while_break___1;
        }
#line 976
        if (resno == 0U) {
          {
#line 977
          l_band->bandno = (OPJ_UINT32 )0;
#line 978
          l_band->x0 = opj_int_ceildivpow2(l_tilec->x0, (OPJ_INT32 )l_level_no);
#line 979
          l_band->y0 = opj_int_ceildivpow2(l_tilec->y0, (OPJ_INT32 )l_level_no);
#line 980
          l_band->x1 = opj_int_ceildivpow2(l_tilec->x1, (OPJ_INT32 )l_level_no);
#line 981
          l_band->y1 = opj_int_ceildivpow2(l_tilec->y1, (OPJ_INT32 )l_level_no);
          }
        } else {
          {
#line 983
          l_band->bandno = bandno + 1U;
#line 985
          l_x0b = (OPJ_INT32 )(l_band->bandno & 1U);
#line 987
          l_y0b = (OPJ_INT32 )(l_band->bandno >> 1);
#line 989
          l_band->x0 = opj_int64_ceildivpow2((long )l_tilec->x0 - ((OPJ_INT64 )l_x0b << l_level_no),
                                             (OPJ_INT32 )(l_level_no + 1U));
#line 991
          l_band->y0 = opj_int64_ceildivpow2((long )l_tilec->y0 - ((OPJ_INT64 )l_y0b << l_level_no),
                                             (OPJ_INT32 )(l_level_no + 1U));
#line 993
          l_band->x1 = opj_int64_ceildivpow2((long )l_tilec->x1 - ((OPJ_INT64 )l_x0b << l_level_no),
                                             (OPJ_INT32 )(l_level_no + 1U));
#line 995
          l_band->y1 = opj_int64_ceildivpow2((long )l_tilec->y1 - ((OPJ_INT64 )l_y0b << l_level_no),
                                             (OPJ_INT32 )(l_level_no + 1U));
          }
        }
#line 999
        if (isEncoder) {
          {
#line 1001
          __cil_tmp90 = opj_tcd_is_band_empty(l_band);
          }
#line 1001
          if (__cil_tmp90) {
#line 1005
            goto while_continue___1;
          }
        }
        {
#line 1010
        l_gain = (*l_gain_ptr)(l_band->bandno);
#line 1011
        numbps = (OPJ_INT32 )(l_image_comp->prec + l_gain);
#line 1015
        __cil_tmp92 = pow(2., (double )(numbps - l_step_size->expn));
#line 1015
        l_band->stepsize = (OPJ_FLOAT32 )((1. + (double )l_step_size->mant / 2048.) * __cil_tmp92) * fraction;
#line 1019
        l_band->numbps = (l_step_size->expn + (OPJ_INT32 )l_tccp->numgbits) - 1;
        }
#line 1022
        if (! l_band->precincts) {
#line 1022
          if (l_nb_precincts > 0U) {
            {
#line 1023
            __cil_tmp93 = opj_malloc((size_t )l_nb_precinct_size);
#line 1023
            l_band->precincts = (opj_tcd_precinct_t *)__cil_tmp93;
            }
#line 1025
            if (! l_band->precincts) {
              {
#line 1026
              opj_event_msg(manager, 1, "Not enough memory to handle band precints\n");
              }
#line 1028
              return (0);
            }
            {
#line 1031
            memset((void *)l_band->precincts, 0, (unsigned long )l_nb_precinct_size);
#line 1032
            l_band->precincts_data_size = l_nb_precinct_size;
            }
          } else {
#line 1022
            goto _L;
          }
        } else
        _L: 
#line 1033
        if (l_band->precincts_data_size < l_nb_precinct_size) {
          {
#line 1035
          __cil_tmp95 = opj_realloc((void *)l_band->precincts, (size_t )l_nb_precinct_size);
#line 1035
          new_precincts = (opj_tcd_precinct_t *)__cil_tmp95;
          }
#line 1037
          if (! new_precincts) {
            {
#line 1038
            opj_event_msg(manager, 1, "Not enough memory to handle band precints\n");
#line 1040
            opj_free((void *)l_band->precincts);
#line 1041
            l_band->precincts = (opj_tcd_precinct_t *)((void *)0);
#line 1042
            l_band->precincts_data_size = (OPJ_UINT32 )0;
            }
#line 1043
            return (0);
          }
          {
#line 1045
          l_band->precincts = new_precincts;
#line 1047
          memset((void *)((OPJ_BYTE *)l_band->precincts + l_band->precincts_data_size),
                 0, (unsigned long )(l_nb_precinct_size - l_band->precincts_data_size));
#line 1049
          l_band->precincts_data_size = l_nb_precinct_size;
          }
        }
#line 1052
        l_current_precinct = l_band->precincts;
#line 1053
        precno = (OPJ_UINT32 )0;
        {
#line 1053
        while (1) {
          while_continue___4: /* CIL Label */ ;

#line 1053
          if (! (precno < l_nb_precincts)) {
#line 1053
            goto while_break___2;
          }
          {
#line 1055
          cbgxstart = tlcbgxstart + (OPJ_INT32 )(precno % l_res->pw) * (1 << cbgwidthexpn);
#line 1057
          cbgystart = tlcbgystart + (OPJ_INT32 )(precno / l_res->pw) * (1 << cbgheightexpn);
#line 1059
          cbgxend = cbgxstart + (1 << cbgwidthexpn);
#line 1060
          cbgyend = cbgystart + (1 << cbgheightexpn);
#line 1067
          l_current_precinct->x0 = opj_int_max(cbgxstart, l_band->x0);
#line 1068
          l_current_precinct->y0 = opj_int_max(cbgystart, l_band->y0);
#line 1069
          l_current_precinct->x1 = opj_int_min(cbgxend, l_band->x1);
#line 1070
          l_current_precinct->y1 = opj_int_min(cbgyend, l_band->y1);
#line 1073
          __cil_tmp108 = opj_int_floordivpow2(l_current_precinct->x0, (OPJ_INT32 )cblkwidthexpn);
#line 1073
          tlcblkxstart = __cil_tmp108 << cblkwidthexpn;
#line 1076
          __cil_tmp109 = opj_int_floordivpow2(l_current_precinct->y0, (OPJ_INT32 )cblkheightexpn);
#line 1076
          tlcblkystart = __cil_tmp109 << cblkheightexpn;
#line 1079
          __cil_tmp110 = opj_int_ceildivpow2(l_current_precinct->x1, (OPJ_INT32 )cblkwidthexpn);
#line 1079
          brcblkxend = __cil_tmp110 << cblkwidthexpn;
#line 1082
          __cil_tmp111 = opj_int_ceildivpow2(l_current_precinct->y1, (OPJ_INT32 )cblkheightexpn);
#line 1082
          brcblkyend = __cil_tmp111 << cblkheightexpn;
#line 1085
          l_current_precinct->cw = (OPJ_UINT32 )((brcblkxend - tlcblkxstart) >> cblkwidthexpn);
#line 1087
          l_current_precinct->ch = (OPJ_UINT32 )((brcblkyend - tlcblkystart) >> cblkheightexpn);
#line 1090
          l_nb_code_blocks = l_current_precinct->cw * l_current_precinct->ch;
          }
#line 1092
          if (4294967295U / (OPJ_UINT32 )sizeof_block < l_nb_code_blocks) {
            {
#line 1094
            opj_event_msg(manager, 1, "Size of code block data exceeds system limits\n");
            }
#line 1096
            return (0);
          }
#line 1098
          l_nb_code_blocks_size = l_nb_code_blocks * (OPJ_UINT32 )sizeof_block;
#line 1100
          if (! l_current_precinct->cblks.blocks) {
#line 1100
            if (l_nb_code_blocks > 0U) {
              {
#line 1101
              l_current_precinct->cblks.blocks = opj_malloc((size_t )l_nb_code_blocks_size);
              }
#line 1102
              if (! l_current_precinct->cblks.blocks) {
#line 1103
                return (0);
              }
              {
#line 1107
              memset(l_current_precinct->cblks.blocks, 0, (unsigned long )l_nb_code_blocks_size);
#line 1109
              l_current_precinct->block_size = l_nb_code_blocks_size;
              }
            } else {
#line 1100
              goto _L___5;
            }
          } else
          _L___5: 
#line 1110
          if (l_nb_code_blocks_size > l_current_precinct->block_size) {
            {
#line 1111
            __cil_tmp114 = opj_realloc(l_current_precinct->cblks.blocks, (size_t )l_nb_code_blocks_size);
#line 1111
            new_blocks = __cil_tmp114;
            }
#line 1113
            if (! new_blocks) {
              {
#line 1114
              opj_free(l_current_precinct->cblks.blocks);
#line 1115
              l_current_precinct->cblks.blocks = (void *)0;
#line 1116
              l_current_precinct->block_size = (OPJ_UINT32 )0;
#line 1117
              opj_event_msg(manager, 1, "Not enough memory for current precinct codeblock element\n");
              }
#line 1119
              return (0);
            }
            {
#line 1121
            l_current_precinct->cblks.blocks = new_blocks;
#line 1124
            memset((void *)((OPJ_BYTE *)l_current_precinct->cblks.blocks + l_current_precinct->block_size),
                   0, (unsigned long )(l_nb_code_blocks_size - l_current_precinct->block_size));
#line 1129
            l_current_precinct->block_size = l_nb_code_blocks_size;
            }
          }
#line 1132
          if (! l_current_precinct->incltree) {
            {
#line 1133
            l_current_precinct->incltree = opj_tgt_create(l_current_precinct->cw,
                                                          l_current_precinct->ch,
                                                          manager);
            }
          } else {
            {
#line 1136
            l_current_precinct->incltree = opj_tgt_init(l_current_precinct->incltree,
                                                        l_current_precinct->cw, l_current_precinct->ch,
                                                        manager);
            }
          }
#line 1140
          if (! l_current_precinct->imsbtree) {
            {
#line 1141
            l_current_precinct->imsbtree = opj_tgt_create(l_current_precinct->cw,
                                                          l_current_precinct->ch,
                                                          manager);
            }
          } else {
            {
#line 1144
            l_current_precinct->imsbtree = opj_tgt_init(l_current_precinct->imsbtree,
                                                        l_current_precinct->cw, l_current_precinct->ch,
                                                        manager);
            }
          }
#line 1148
          cblkno = (OPJ_UINT32 )0;
          {
#line 1148
          while (1) {
            while_continue___5: /* CIL Label */ ;

#line 1148
            if (! (cblkno < l_nb_code_blocks)) {
#line 1148
              goto while_break___3;
            }
#line 1149
            cblkxstart = tlcblkxstart + (OPJ_INT32 )(cblkno % l_current_precinct->cw) * (1 << cblkwidthexpn);
#line 1151
            cblkystart = tlcblkystart + (OPJ_INT32 )(cblkno / l_current_precinct->cw) * (1 << cblkheightexpn);
#line 1153
            cblkxend = cblkxstart + (1 << cblkwidthexpn);
#line 1154
            cblkyend = cblkystart + (1 << cblkheightexpn);
#line 1156
            if (isEncoder) {
              {
#line 1157
              l_code_block = l_current_precinct->cblks.enc + cblkno;
#line 1159
              __cil_tmp124 = opj_tcd_code_block_enc_allocate(l_code_block);
              }
#line 1159
              if (! __cil_tmp124) {
#line 1160
                return (0);
              }
              {
#line 1163
              l_code_block->x0 = opj_int_max(cblkxstart, l_current_precinct->x0);
#line 1164
              l_code_block->y0 = opj_int_max(cblkystart, l_current_precinct->y0);
#line 1165
              l_code_block->x1 = opj_int_min(cblkxend, l_current_precinct->x1);
#line 1166
              l_code_block->y1 = opj_int_min(cblkyend, l_current_precinct->y1);
#line 1168
              __cil_tmp129 = opj_tcd_code_block_enc_allocate_data(l_code_block);
              }
#line 1168
              if (! __cil_tmp129) {
#line 1169
                return (0);
              }
            } else {
              {
#line 1172
              l_code_block___0 = l_current_precinct->cblks.dec + cblkno;
#line 1174
              __cil_tmp131 = opj_tcd_code_block_dec_allocate(l_code_block___0);
              }
#line 1174
              if (! __cil_tmp131) {
#line 1175
                return (0);
              }
              {
#line 1178
              l_code_block___0->x0 = opj_int_max(cblkxstart, l_current_precinct->x0);
#line 1179
              l_code_block___0->y0 = opj_int_max(cblkystart, l_current_precinct->y0);
#line 1180
              l_code_block___0->x1 = opj_int_min(cblkxend, l_current_precinct->x1);
#line 1181
              l_code_block___0->y1 = opj_int_min(cblkyend, l_current_precinct->y1);
              }
            }
#line 1148
            cblkno ++;
          }
          while_break___8: /* CIL Label */ ;
          }

          while_break___3: 
#line 1184
          l_current_precinct ++;
#line 1053
          precno ++;
        }
        while_break___7: /* CIL Label */ ;
        }

        while_break___2: 
#line 972
        l_step_size ++;
#line 972
        l_band ++;
#line 972
        bandno ++;
      }
      while_break___6: /* CIL Label */ ;
      }

      while_break___1: 
#line 1187
      l_res ++;
#line 889
      resno ++;
    }
    while_break___5: /* CIL Label */ ;
    }

    while_break___0: 
#line 1189
    l_tccp ++;
#line 1190
    l_tilec ++;
#line 1191
    l_image_comp ++;
#line 802
    compno ++;
  }
  while_break___4: /* CIL Label */ ;
  }

  while_break: ;
#line 1193
  return (1);
}
}
#line 1196 "/root/patron-new/39/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_init_encode_tile(opj_tcd_t *p_tcd , OPJ_UINT32 p_tile_no , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp4 ;

  {
  {
#line 1199
  __cil_tmp4 = opj_tcd_init_tile(p_tcd, p_tile_no, 1, 1.f, sizeof(opj_tcd_cblk_enc_t ),
                                 p_manager);
  }
#line 1199
  return (__cil_tmp4);
}
}
#line 1203 "/root/patron-new/39/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_init_decode_tile(opj_tcd_t *p_tcd , OPJ_UINT32 p_tile_no , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp4 ;

  {
  {
#line 1206
  __cil_tmp4 = opj_tcd_init_tile(p_tcd, p_tile_no, 0, 0.5f, sizeof(opj_tcd_cblk_dec_t ),
                                 p_manager);
  }
#line 1206
  return (__cil_tmp4);
}
}
#line 1213 "/root/patron-new/39/src/lib/openjp2/tcd.c"
static OPJ_BOOL opj_tcd_code_block_enc_allocate(opj_tcd_cblk_enc_t *p_code_block ) 
{ 
  void *__cil_tmp2 ;
  void *__cil_tmp3 ;

  {
#line 1216
  if (! p_code_block->layers) {
    {
#line 1218
    __cil_tmp2 = opj_calloc((size_t )100, sizeof(opj_tcd_layer_t ));
#line 1218
    p_code_block->layers = (opj_tcd_layer_t *)__cil_tmp2;
    }
#line 1220
    if (! p_code_block->layers) {
#line 1221
      return (0);
    }
  }
#line 1224
  if (! p_code_block->passes) {
    {
#line 1225
    __cil_tmp3 = opj_calloc((size_t )100, sizeof(opj_tcd_pass_t ));
#line 1225
    p_code_block->passes = (opj_tcd_pass_t *)__cil_tmp3;
    }
#line 1227
    if (! p_code_block->passes) {
#line 1228
      return (0);
    }
  }
#line 1231
  return (1);
}
}
#line 1237 "/root/patron-new/39/src/lib/openjp2/tcd.c"
static OPJ_BOOL opj_tcd_code_block_enc_allocate_data(opj_tcd_cblk_enc_t *p_code_block ) 
{ 
  OPJ_UINT32 l_data_size ;
  void *__cil_tmp3 ;

  {
#line 1246
  l_data_size = 2U + (OPJ_UINT32 )(((p_code_block->x1 - p_code_block->x0) * (p_code_block->y1 - p_code_block->y0)) * (OPJ_INT32 )sizeof(OPJ_UINT32 ));
#line 1249
  if (l_data_size > p_code_block->data_size) {
#line 1250
    if (p_code_block->data) {
      {
#line 1252
      opj_free((void *)(p_code_block->data - 1));
      }
    }
    {
#line 1254
    __cil_tmp3 = opj_malloc((size_t )(l_data_size + 1U));
#line 1254
    p_code_block->data = (OPJ_BYTE *)__cil_tmp3;
    }
#line 1255
    if (! p_code_block->data) {
#line 1256
      p_code_block->data_size = 0U;
#line 1257
      return (0);
    }
#line 1259
    p_code_block->data_size = l_data_size;
#line 1265
    *(p_code_block->data + 0) = (OPJ_BYTE )0;
#line 1266
    (p_code_block->data) ++;
  }
#line 1268
  return (1);
}
}
#line 1272 "/root/patron-new/39/src/lib/openjp2/tcd.c"
void opj_tcd_reinit_segment(opj_tcd_seg_t *seg ) 
{ 


  {
  {
#line 1274
  memset((void *)seg, 0, sizeof(opj_tcd_seg_t ));
  }
#line 1276
  return;
}
}
#line 1280 "/root/patron-new/39/src/lib/openjp2/tcd.c"
static OPJ_BOOL opj_tcd_code_block_dec_allocate(opj_tcd_cblk_dec_t *p_code_block ) 
{ 
  void *__cil_tmp2 ;
  opj_tcd_seg_t *l_segs ;
  OPJ_UINT32 l_current_max_segs ;
  opj_tcd_seg_data_chunk_t *l_chunks ;
  OPJ_UINT32 l_numchunksalloc ;
  OPJ_UINT32 i ;

  {
#line 1283
  if (! p_code_block->segs) {
    {
#line 1285
    __cil_tmp2 = opj_calloc((size_t )10, sizeof(opj_tcd_seg_t ));
#line 1285
    p_code_block->segs = (opj_tcd_seg_t *)__cil_tmp2;
    }
#line 1287
    if (! p_code_block->segs) {
#line 1288
      return (0);
    }
#line 1292
    p_code_block->m_current_max_segs = (OPJ_UINT32 )10;
  } else {
    {
#line 1296
    l_segs = p_code_block->segs;
#line 1297
    l_current_max_segs = p_code_block->m_current_max_segs;
#line 1298
    l_chunks = p_code_block->chunks;
#line 1299
    l_numchunksalloc = p_code_block->numchunksalloc;
#line 1302
    opj_aligned_free((void *)p_code_block->decoded_data);
#line 1303
    p_code_block->decoded_data = (OPJ_INT32 *)0;
#line 1305
    memset((void *)p_code_block, 0, sizeof(opj_tcd_cblk_dec_t ));
#line 1306
    p_code_block->segs = l_segs;
#line 1307
    p_code_block->m_current_max_segs = l_current_max_segs;
#line 1308
    i = (OPJ_UINT32 )0;
    }
    {
#line 1308
    while (1) {
      while_continue: /* CIL Label */ ;

#line 1308
      if (! (i < l_current_max_segs)) {
#line 1308
        goto while_break;
      }
      {
#line 1309
      opj_tcd_reinit_segment(l_segs + i);
#line 1308
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }

    while_break: 
#line 1311
    p_code_block->chunks = l_chunks;
#line 1312
    p_code_block->numchunksalloc = l_numchunksalloc;
  }
#line 1315
  return (1);
}
}
#line 1318 "/root/patron-new/39/src/lib/openjp2/tcd.c"
OPJ_UINT32 opj_tcd_get_decoded_tile_size(opj_tcd_t *p_tcd , OPJ_BOOL take_into_account_partial_decoding ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_data_size ;
  opj_image_comp_t *l_img_comp ;
  opj_tcd_tilecomp_t *l_tile_comp ;
  opj_tcd_resolution_t *l_res ;
  OPJ_UINT32 l_size_comp ;
  OPJ_UINT32 l_remaining ;
  OPJ_UINT32 l_temp ;
  OPJ_UINT32 w ;
  OPJ_UINT32 h ;

  {
#line 1322
  l_data_size = (OPJ_UINT32 )0;
#line 1323
  l_img_comp = (opj_image_comp_t *)0;
#line 1324
  l_tile_comp = (opj_tcd_tilecomp_t *)0;
#line 1325
  l_res = (opj_tcd_resolution_t *)0;
#line 1329
  l_tile_comp = ((p_tcd->tcd_image)->tiles)->comps;
#line 1330
  l_img_comp = (p_tcd->image)->comps;
#line 1332
  i = (OPJ_UINT32 )0;
  {
#line 1332
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1332
    if (! (i < (p_tcd->image)->numcomps)) {
#line 1332
      goto while_break;
    }
#line 1334
    l_size_comp = l_img_comp->prec >> 3;
#line 1335
    l_remaining = l_img_comp->prec & 7U;
#line 1337
    if (l_remaining) {
#line 1338
      l_size_comp ++;
    }
#line 1341
    if (l_size_comp == 3U) {
#line 1342
      l_size_comp = (OPJ_UINT32 )4;
    }
#line 1345
    l_res = (l_tile_comp->resolutions + l_tile_comp->minimum_num_resolutions) - 1;
#line 1346
    if (take_into_account_partial_decoding) {
#line 1346
      if (! p_tcd->whole_tile_decoding) {
#line 1347
        w = l_res->win_x1 - l_res->win_x0;
#line 1348
        h = l_res->win_y1 - l_res->win_y0;
      } else {
#line 1350
        w = (OPJ_UINT32 )(l_res->x1 - l_res->x0);
#line 1351
        h = (OPJ_UINT32 )(l_res->y1 - l_res->y0);
      }
    } else {
#line 1350
      w = (OPJ_UINT32 )(l_res->x1 - l_res->x0);
#line 1351
      h = (OPJ_UINT32 )(l_res->y1 - l_res->y0);
    }
#line 1353
    if (h > 0U) {
#line 1353
      if (4294967295U / w < h) {
#line 1354
        return (4294967295U);
      }
    }
#line 1356
    l_temp = w * h;
#line 1357
    if (l_size_comp) {
#line 1357
      if (4294967295U / l_size_comp < l_temp) {
#line 1358
        return (4294967295U);
      }
    }
#line 1360
    l_temp *= l_size_comp;
#line 1362
    if (l_temp > 4294967295U - l_data_size) {
#line 1363
      return (4294967295U);
    }
#line 1365
    l_data_size += l_temp;
#line 1366
    l_img_comp ++;
#line 1367
    l_tile_comp ++;
#line 1332
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 1370
  return (l_data_size);
}
}
#line 1373 "/root/patron-new/39/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_encode_tile(opj_tcd_t *p_tcd , OPJ_UINT32 p_tile_no , OPJ_BYTE *p_dest ,
                             OPJ_UINT32 *p_data_written , OPJ_UINT32 p_max_length ,
                             opj_codestream_info_t *p_cstr_info , opj_tcd_marker_info_t *p_marker_info ,
                             opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_num_packs ;
  OPJ_UINT32 i ;
  opj_tcd_tilecomp_t *l_tilec_idx ;
  opj_tccp_t *l_tccp ;
  opj_tcd_resolution_t *l_res_idx ;
  void *__cil_tmp15 ;
  OPJ_BOOL __cil_tmp16 ;
  OPJ_BOOL __cil_tmp17 ;
  OPJ_BOOL __cil_tmp18 ;
  OPJ_BOOL __cil_tmp19 ;
  OPJ_BOOL __cil_tmp20 ;
  OPJ_BOOL __cil_tmp21 ;

  {
#line 1383
  if (p_tcd->cur_tp_num == 0U) {
#line 1385
    p_tcd->tcd_tileno = p_tile_no;
#line 1386
    p_tcd->tcp = (p_tcd->cp)->tcps + p_tile_no;
#line 1389
    if (p_cstr_info) {
#line 1390
      l_num_packs = (OPJ_UINT32 )0;
#line 1392
      l_tilec_idx = ((p_tcd->tcd_image)->tiles)->comps + 0;
#line 1394
      l_tccp = (p_tcd->tcp)->tccps;
#line 1396
      i = (OPJ_UINT32 )0;
      {
#line 1396
      while (1) {
        while_continue: /* CIL Label */ ;

#line 1396
        if (! (i < l_tilec_idx->numresolutions)) {
#line 1396
          goto while_break;
        }
#line 1397
        l_res_idx = l_tilec_idx->resolutions + i;
#line 1399
        (p_cstr_info->tile + p_tile_no)->pw[i] = (int )l_res_idx->pw;
#line 1400
        (p_cstr_info->tile + p_tile_no)->ph[i] = (int )l_res_idx->ph;
#line 1402
        l_num_packs += l_res_idx->pw * l_res_idx->ph;
#line 1403
        (p_cstr_info->tile + p_tile_no)->pdx[i] = (int )l_tccp->prcw[i];
#line 1404
        (p_cstr_info->tile + p_tile_no)->pdy[i] = (int )l_tccp->prch[i];
#line 1396
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }

      while_break: 
      {
#line 1406
      __cil_tmp15 = opj_calloc(((OPJ_SIZE_T )p_cstr_info->numcomps * (OPJ_SIZE_T )p_cstr_info->numlayers) * (unsigned long )l_num_packs,
                               sizeof(opj_packet_info_t ));
#line 1406
      (p_cstr_info->tile + p_tile_no)->packet = (opj_packet_info_t *)__cil_tmp15;
      }
#line 1410
      if (! (p_cstr_info->tile + p_tile_no)->packet) {
#line 1412
        return (0);
      }
    }
    {
#line 1419
    __cil_tmp16 = opj_tcd_dc_level_shift_encode(p_tcd);
    }
#line 1419
    if (! __cil_tmp16) {
#line 1420
      return (0);
    }
    {
#line 1425
    __cil_tmp17 = opj_tcd_mct_encode(p_tcd);
    }
#line 1425
    if (! __cil_tmp17) {
#line 1426
      return (0);
    }
    {
#line 1431
    __cil_tmp18 = opj_tcd_dwt_encode(p_tcd);
    }
#line 1431
    if (! __cil_tmp18) {
#line 1432
      return (0);
    }
    {
#line 1437
    __cil_tmp19 = opj_tcd_t1_encode(p_tcd);
    }
#line 1437
    if (! __cil_tmp19) {
#line 1438
      return (0);
    }
    {
#line 1443
    __cil_tmp20 = opj_tcd_rate_allocate_encode(p_tcd, p_dest, p_max_length, p_cstr_info,
                                               p_manager);
    }
#line 1443
    if (! __cil_tmp20) {
#line 1445
      return (0);
    }
  }
#line 1453
  if (p_cstr_info) {
#line 1454
    p_cstr_info->index_write = 1;
  }
  {
#line 1458
  __cil_tmp21 = opj_tcd_t2_encode(p_tcd, p_dest, p_data_written, p_max_length, p_cstr_info,
                                  p_marker_info, p_manager);
  }
#line 1458
  if (! __cil_tmp21) {
#line 1460
    return (0);
  }
#line 1466
  return (1);
}
}
#line 1469 "/root/patron-new/39/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_decode_tile(opj_tcd_t *p_tcd , OPJ_UINT32 win_x0 , OPJ_UINT32 win_y0 ,
                             OPJ_UINT32 win_x1 , OPJ_UINT32 win_y1 , OPJ_UINT32 numcomps_to_decode ,
                             OPJ_UINT32 *comps_indices , OPJ_BYTE *p_src , OPJ_UINT32 p_max_length ,
                             OPJ_UINT32 p_tile_no , opj_codestream_index_t *p_cstr_index ,
                             opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_data_read ;
  OPJ_UINT32 compno ;
  OPJ_BOOL *used_component ;
  void *__cil_tmp16 ;
  OPJ_BOOL __cil_tmp18 ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *l_res ;
  OPJ_SIZE_T l_data_size ;
  OPJ_SIZE_T res_w ;
  OPJ_SIZE_T res_h ;
  OPJ_BOOL __cil_tmp25 ;
  OPJ_UINT32 resno ;
  opj_tcd_tilecomp_t *tilec___0 ;
  opj_image_comp_t *image_comp ;
  OPJ_UINT32 __cil_tmp30 ;
  OPJ_UINT32 __cil_tmp31 ;
  OPJ_UINT32 __cil_tmp32 ;
  OPJ_UINT32 __cil_tmp33 ;
  OPJ_UINT32 __cil_tmp34 ;
  OPJ_UINT32 __cil_tmp35 ;
  OPJ_UINT32 __cil_tmp36 ;
  OPJ_UINT32 __cil_tmp37 ;
  opj_tcd_resolution_t *res ;
  OPJ_BOOL __cil_tmp44 ;
  OPJ_BOOL __cil_tmp45 ;
  opj_tcd_tilecomp_t *tilec___1 ;
  opj_image_comp_t *image_comp___0 ;
  opj_tcd_resolution_t *res___0 ;
  OPJ_SIZE_T w ;
  OPJ_SIZE_T h ;
  OPJ_SIZE_T l_data_size___0 ;
  void *__cil_tmp52 ;
  OPJ_BOOL __cil_tmp54 ;
  OPJ_BOOL __cil_tmp55 ;
  OPJ_BOOL __cil_tmp56 ;

  {
  {
#line 1486
  p_tcd->tcd_tileno = p_tile_no;
#line 1487
  p_tcd->tcp = (p_tcd->cp)->tcps + p_tile_no;
#line 1488
  p_tcd->win_x0 = win_x0;
#line 1489
  p_tcd->win_y0 = win_y0;
#line 1490
  p_tcd->win_x1 = win_x1;
#line 1491
  p_tcd->win_y1 = win_y1;
#line 1492
  p_tcd->whole_tile_decoding = 1;
#line 1494
  opj_free((void *)p_tcd->used_component);
#line 1495
  p_tcd->used_component = (OPJ_BOOL *)((void *)0);
  }
#line 1497
  if (numcomps_to_decode) {
    {
#line 1498
    __cil_tmp16 = opj_calloc(sizeof(OPJ_BOOL ), (size_t )(p_tcd->image)->numcomps);
#line 1498
    used_component = (OPJ_BOOL *)__cil_tmp16;
    }
#line 1500
    if ((unsigned long )used_component == (unsigned long )((void *)0)) {
#line 1501
      return (0);
    }
#line 1503
    compno = (OPJ_UINT32 )0;
    {
#line 1503
    while (1) {
      while_continue: /* CIL Label */ ;

#line 1503
      if (! (compno < numcomps_to_decode)) {
#line 1503
        goto while_break;
      }
#line 1504
      *(used_component + *(comps_indices + compno)) = 1;
#line 1503
      compno ++;
    }
    while_break___5: /* CIL Label */ ;
    }

    while_break: 
#line 1507
    p_tcd->used_component = used_component;
  }
#line 1510
  compno = (OPJ_UINT32 )0;
  {
#line 1510
  while (1) {
    while_continue___5: /* CIL Label */ ;

    while_continue___0: ;
#line 1510
    if (! (compno < (p_tcd->image)->numcomps)) {
#line 1510
      goto while_break___0;
    }
#line 1511
    if ((unsigned long )p_tcd->used_component != (unsigned long )((void *)0)) {
#line 1511
      if (! *(p_tcd->used_component + compno)) {
#line 1512
        goto while_continue___0;
      }
    }
    {
#line 1515
    __cil_tmp18 = opj_tcd_is_whole_tilecomp_decoding(p_tcd, compno);
    }
#line 1515
    if (! __cil_tmp18) {
#line 1516
      p_tcd->whole_tile_decoding = 0;
#line 1517
      goto while_break___0;
    }
#line 1510
    compno ++;
  }
  while_break___6: /* CIL Label */ ;
  }

  while_break___0: ;
#line 1521
  if (p_tcd->whole_tile_decoding) {
#line 1522
    compno = (OPJ_UINT32 )0;
    {
#line 1522
    while (1) {
      while_continue___6: /* CIL Label */ ;

      while_continue___1: ;
#line 1522
      if (! (compno < (p_tcd->image)->numcomps)) {
#line 1522
        goto while_break___1;
      }
#line 1523
      tilec = ((p_tcd->tcd_image)->tiles)->comps + compno;
#line 1524
      l_res = tilec->resolutions + (tilec->minimum_num_resolutions - 1U);
#line 1529
      res_w = (OPJ_SIZE_T )(l_res->x1 - l_res->x0);
#line 1530
      res_h = (OPJ_SIZE_T )(l_res->y1 - l_res->y0);
#line 1532
      if ((unsigned long )p_tcd->used_component != (unsigned long )((void *)0)) {
#line 1532
        if (! *(p_tcd->used_component + compno)) {
#line 1533
          goto while_continue___1;
        }
      }
#line 1537
      if (res_h > 0UL) {
#line 1537
        if (res_w > 0xffffffffffffffffUL / res_h) {
          {
#line 1538
          opj_event_msg(p_manager, 1, "Size of tile data exceeds system limits\n\220");
          }
#line 1540
          return (0);
        }
      }
#line 1542
      l_data_size = res_w * res_h;
#line 1544
      if (0xffffffffffffffffUL / sizeof(OPJ_UINT32 ) < l_data_size) {
        {
#line 1545
        opj_event_msg(p_manager, 1, "Size of tile data exceeds system limits\n\220");
        }
#line 1547
        return (0);
      }
      {
#line 1549
      l_data_size *= sizeof(OPJ_UINT32 );
#line 1551
      tilec->data_size_needed = l_data_size;
#line 1553
      __cil_tmp25 = opj_alloc_tile_component_data(tilec);
      }
#line 1553
      if (! __cil_tmp25) {
        {
#line 1554
        opj_event_msg(p_manager, 1, "Size of tile data exceeds system limits\n\220");
        }
#line 1556
        return (0);
      }
#line 1522
      compno ++;
    }
    while_break___7: /* CIL Label */ ;
    }

    while_break___1: ;
  } else {
#line 1563
    compno = (OPJ_UINT32 )0;
    {
#line 1563
    while (1) {
      while_continue___7: /* CIL Label */ ;

      while_continue___2: ;
#line 1563
      if (! (compno < (p_tcd->image)->numcomps)) {
#line 1563
        goto while_break___2;
      }
#line 1565
      tilec___0 = ((p_tcd->tcd_image)->tiles)->comps + compno;
#line 1566
      image_comp = (p_tcd->image)->comps + compno;
#line 1568
      if ((unsigned long )p_tcd->used_component != (unsigned long )((void *)0)) {
#line 1568
        if (! *(p_tcd->used_component + compno)) {
#line 1569
          goto while_continue___2;
        }
      }
      {
#line 1574
      __cil_tmp30 = opj_uint_ceildiv(p_tcd->win_x0, image_comp->dx);
#line 1574
      __cil_tmp31 = opj_uint_max((OPJ_UINT32 )tilec___0->x0, __cil_tmp30);
#line 1574
      tilec___0->win_x0 = __cil_tmp31;
#line 1577
      __cil_tmp32 = opj_uint_ceildiv(p_tcd->win_y0, image_comp->dy);
#line 1577
      __cil_tmp33 = opj_uint_max((OPJ_UINT32 )tilec___0->y0, __cil_tmp32);
#line 1577
      tilec___0->win_y0 = __cil_tmp33;
#line 1580
      __cil_tmp34 = opj_uint_ceildiv(p_tcd->win_x1, image_comp->dx);
#line 1580
      __cil_tmp35 = opj_uint_min((OPJ_UINT32 )tilec___0->x1, __cil_tmp34);
#line 1580
      tilec___0->win_x1 = __cil_tmp35;
#line 1583
      __cil_tmp36 = opj_uint_ceildiv(p_tcd->win_y1, image_comp->dy);
#line 1583
      __cil_tmp37 = opj_uint_min((OPJ_UINT32 )tilec___0->y1, __cil_tmp36);
#line 1583
      tilec___0->win_y1 = __cil_tmp37;
      }
#line 1586
      if (tilec___0->win_x1 < tilec___0->win_x0) {
        {
#line 1591
        opj_event_msg(p_manager, 1, "Invalid tilec->win_xxx values\n");
        }
#line 1593
        return (0);
      } else
#line 1586
      if (tilec___0->win_y1 < tilec___0->win_y0) {
        {
#line 1591
        opj_event_msg(p_manager, 1, "Invalid tilec->win_xxx values\n");
        }
#line 1593
        return (0);
      }
#line 1596
      resno = (OPJ_UINT32 )0;
      {
#line 1596
      while (1) {
        while_continue___8: /* CIL Label */ ;

#line 1596
        if (! (resno < tilec___0->numresolutions)) {
#line 1596
          goto while_break___3;
        }
        {
#line 1597
        res = tilec___0->resolutions + resno;
#line 1598
        res->win_x0 = opj_uint_ceildivpow2(tilec___0->win_x0, (tilec___0->numresolutions - 1U) - resno);
#line 1600
        res->win_y0 = opj_uint_ceildivpow2(tilec___0->win_y0, (tilec___0->numresolutions - 1U) - resno);
#line 1602
        res->win_x1 = opj_uint_ceildivpow2(tilec___0->win_x1, (tilec___0->numresolutions - 1U) - resno);
#line 1604
        res->win_y1 = opj_uint_ceildivpow2(tilec___0->win_y1, (tilec___0->numresolutions - 1U) - resno);
#line 1596
        resno ++;
        }
      }
      while_break___9: /* CIL Label */ ;
      }

      while_break___3: 
#line 1563
      compno ++;
    }
    while_break___8: /* CIL Label */ ;
    }

    while_break___2: ;
  }
  {
#line 1636
  l_data_read = (OPJ_UINT32 )0;
#line 1637
  __cil_tmp44 = opj_tcd_t2_decode(p_tcd, p_src, & l_data_read, p_max_length, p_cstr_index,
                                  p_manager);
  }
#line 1637
  if (! __cil_tmp44) {
#line 1639
    return (0);
  }
  {
#line 1646
  __cil_tmp45 = opj_tcd_t1_decode(p_tcd, p_manager);
  }
#line 1646
  if (! __cil_tmp45) {
#line 1647
    return (0);
  }
#line 1654
  if (! p_tcd->whole_tile_decoding) {
#line 1655
    compno = (OPJ_UINT32 )0;
    {
#line 1655
    while (1) {
      while_continue___9: /* CIL Label */ ;

      while_continue___4: ;
#line 1655
      if (! (compno < (p_tcd->image)->numcomps)) {
#line 1655
        goto while_break___4;
      }
      {
#line 1656
      tilec___1 = ((p_tcd->tcd_image)->tiles)->comps + compno;
#line 1657
      image_comp___0 = (p_tcd->image)->comps + compno;
#line 1658
      res___0 = tilec___1->resolutions + image_comp___0->resno_decoded;
#line 1659
      w = (OPJ_SIZE_T )(res___0->win_x1 - res___0->win_x0);
#line 1660
      h = (OPJ_SIZE_T )(res___0->win_y1 - res___0->win_y0);
#line 1663
      opj_image_data_free((void *)tilec___1->data_win);
#line 1664
      tilec___1->data_win = (OPJ_INT32 *)((void *)0);
      }
#line 1666
      if ((unsigned long )p_tcd->used_component != (unsigned long )((void *)0)) {
#line 1666
        if (! *(p_tcd->used_component + compno)) {
#line 1667
          goto while_continue___4;
        }
      }
#line 1670
      if (w > 0UL) {
#line 1670
        if (h > 0UL) {
#line 1671
          if (w > 0xffffffffffffffffUL / h) {
            {
#line 1672
            opj_event_msg(p_manager, 1, "Size of tile data exceeds system limits\n\220");
            }
#line 1674
            return (0);
          }
#line 1676
          l_data_size___0 = w * h;
#line 1677
          if (l_data_size___0 > 0xffffffffffffffffUL / sizeof(OPJ_INT32 )) {
            {
#line 1678
            opj_event_msg(p_manager, 1, "Size of tile data exceeds system limits\n\220");
            }
#line 1680
            return (0);
          }
          {
#line 1682
          l_data_size___0 *= sizeof(OPJ_INT32 );
#line 1684
          __cil_tmp52 = opj_image_data_alloc(l_data_size___0);
#line 1684
          tilec___1->data_win = (OPJ_INT32 *)__cil_tmp52;
          }
#line 1685
          if ((unsigned long )tilec___1->data_win == (unsigned long )((void *)0)) {
            {
#line 1686
            opj_event_msg(p_manager, 1, "Size of tile data exceeds system limits\n\220");
            }
#line 1688
            return (0);
          }
        }
      }
#line 1655
      compno ++;
    }
    while_break___10: /* CIL Label */ ;
    }

    while_break___4: ;
  }
  {
#line 1697
  __cil_tmp54 = opj_tcd_dwt_decode(p_tcd);
  }
#line 1697
  if (! __cil_tmp54) {
#line 1699
    return (0);
  }
  {
#line 1705
  __cil_tmp55 = opj_tcd_mct_decode(p_tcd, p_manager);
  }
#line 1705
  if (! __cil_tmp55) {
#line 1707
    return (0);
  }
  {
#line 1712
  __cil_tmp56 = opj_tcd_dc_level_shift_decode(p_tcd);
  }
#line 1712
  if (! __cil_tmp56) {
#line 1714
    return (0);
  }
#line 1720
  return (1);
}
}
#line 1723 "/root/patron-new/39/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_update_tile_data(opj_tcd_t *p_tcd , OPJ_BYTE *p_dest , OPJ_UINT32 p_dest_length ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  OPJ_UINT32 l_data_size ;
  opj_image_comp_t *l_img_comp ;
  opj_tcd_tilecomp_t *l_tilec ;
  opj_tcd_resolution_t *l_res ;
  OPJ_UINT32 l_size_comp ;
  OPJ_UINT32 l_remaining ;
  OPJ_UINT32 l_stride ;
  OPJ_UINT32 l_width ;
  OPJ_UINT32 l_height ;
  OPJ_INT32 *l_src_data ;
  OPJ_CHAR *l_dest_ptr ;
  OPJ_INT32 *l_src_ptr ;
  OPJ_CHAR *__cil_tmp20 ;
  OPJ_INT32 *__cil_tmp21 ;
  OPJ_CHAR *__cil_tmp22 ;
  OPJ_INT32 *__cil_tmp23 ;
  OPJ_INT32 *l_src_ptr___0 ;
  OPJ_INT16 *l_dest_ptr___0 ;
  OPJ_INT16 val ;
  OPJ_INT32 *__cil_tmp27 ;
  OPJ_INT16 val___0 ;
  OPJ_INT32 *__cil_tmp30 ;
  OPJ_INT32 *l_dest_ptr___1 ;
  OPJ_INT32 *l_src_ptr___1 ;

  {
  {
#line 1728
  l_data_size = (OPJ_UINT32 )0;
#line 1729
  l_img_comp = (opj_image_comp_t *)0;
#line 1730
  l_tilec = (opj_tcd_tilecomp_t *)0;
#line 1735
  l_data_size = opj_tcd_get_decoded_tile_size(p_tcd, 1);
  }
#line 1736
  if (l_data_size == 4294967295U) {
#line 1737
    return (0);
  } else
#line 1736
  if (l_data_size > p_dest_length) {
#line 1737
    return (0);
  }
#line 1740
  l_tilec = ((p_tcd->tcd_image)->tiles)->comps;
#line 1741
  l_img_comp = (p_tcd->image)->comps;
#line 1743
  i = (OPJ_UINT32 )0;
  {
#line 1743
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1743
    if (! (i < (p_tcd->image)->numcomps)) {
#line 1743
      goto while_break;
    }
#line 1745
    l_size_comp = l_img_comp->prec >> 3;
#line 1746
    l_remaining = l_img_comp->prec & 7U;
#line 1747
    l_res = l_tilec->resolutions + l_img_comp->resno_decoded;
#line 1748
    if (p_tcd->whole_tile_decoding) {
#line 1749
      l_width = (OPJ_UINT32 )(l_res->x1 - l_res->x0);
#line 1750
      l_height = (OPJ_UINT32 )(l_res->y1 - l_res->y0);
#line 1751
      l_stride = (OPJ_UINT32 )((l_tilec->resolutions + (l_tilec->minimum_num_resolutions - 1U))->x1 - (l_tilec->resolutions + (l_tilec->minimum_num_resolutions - 1U))->x0) - l_width;
#line 1754
      l_src_data = l_tilec->data;
    } else {
#line 1756
      l_width = l_res->win_x1 - l_res->win_x0;
#line 1757
      l_height = l_res->win_y1 - l_res->win_y0;
#line 1758
      l_stride = (OPJ_UINT32 )0;
#line 1759
      l_src_data = l_tilec->data_win;
    }
#line 1762
    if (l_remaining) {
#line 1763
      l_size_comp ++;
    }
#line 1766
    if (l_size_comp == 3U) {
#line 1767
      l_size_comp = (OPJ_UINT32 )4;
    }
#line 1771
    if (l_size_comp == 1U) {
#line 1771
      goto case_1;
    }
#line 1794
    if (l_size_comp == 2U) {
#line 1794
      goto case_2;
    }
#line 1821
    if (l_size_comp == 4U) {
#line 1821
      goto case_4;
    }
#line 1770
    goto switch_break;
    case_1: 
#line 1772
    l_dest_ptr = (OPJ_CHAR *)p_dest;
#line 1773
    l_src_ptr = l_src_data;
#line 1775
    if (l_img_comp->sgnd) {
#line 1776
      j = (OPJ_UINT32 )0;
      {
#line 1776
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 1776
        if (! (j < l_height)) {
#line 1776
          goto while_break___0;
        }
#line 1777
        k = (OPJ_UINT32 )0;
        {
#line 1777
        while (1) {
          while_continue___1: /* CIL Label */ ;

#line 1777
          if (! (k < l_width)) {
#line 1777
            goto while_break___1;
          }
#line 1778
          __cil_tmp21 = l_src_ptr;
#line 1778
          l_src_ptr ++;
#line 1778
          __cil_tmp20 = l_dest_ptr;
#line 1778
          l_dest_ptr ++;
#line 1778
          *__cil_tmp20 = (OPJ_CHAR )*__cil_tmp21;
#line 1777
          k ++;
        }
        while_break___11: /* CIL Label */ ;
        }

        while_break___1: 
#line 1780
        l_src_ptr += l_stride;
#line 1776
        j ++;
      }
      while_break___10: /* CIL Label */ ;
      }

      while_break___0: ;
    } else {
#line 1783
      j = (OPJ_UINT32 )0;
      {
#line 1783
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 1783
        if (! (j < l_height)) {
#line 1783
          goto while_break___2;
        }
#line 1784
        k = (OPJ_UINT32 )0;
        {
#line 1784
        while (1) {
          while_continue___3: /* CIL Label */ ;

#line 1784
          if (! (k < l_width)) {
#line 1784
            goto while_break___3;
          }
#line 1785
          __cil_tmp23 = l_src_ptr;
#line 1785
          l_src_ptr ++;
#line 1785
          __cil_tmp22 = l_dest_ptr;
#line 1785
          l_dest_ptr ++;
#line 1785
          *__cil_tmp22 = (OPJ_CHAR )(*__cil_tmp23 & 255);
#line 1784
          k ++;
        }
        while_break___13: /* CIL Label */ ;
        }

        while_break___3: 
#line 1787
        l_src_ptr += l_stride;
#line 1783
        j ++;
      }
      while_break___12: /* CIL Label */ ;
      }

      while_break___2: ;
    }
#line 1791
    p_dest = (OPJ_BYTE *)l_dest_ptr;
#line 1793
    goto switch_break;
    case_2: 
#line 1795
    l_src_ptr___0 = l_src_data;
#line 1796
    l_dest_ptr___0 = (OPJ_INT16 *)p_dest;
#line 1798
    if (l_img_comp->sgnd) {
#line 1799
      j = (OPJ_UINT32 )0;
      {
#line 1799
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 1799
        if (! (j < l_height)) {
#line 1799
          goto while_break___4;
        }
#line 1800
        k = (OPJ_UINT32 )0;
        {
#line 1800
        while (1) {
          while_continue___5: /* CIL Label */ ;

#line 1800
          if (! (k < l_width)) {
#line 1800
            goto while_break___5;
          }
          {
#line 1801
          __cil_tmp27 = l_src_ptr___0;
#line 1801
          l_src_ptr___0 ++;
#line 1801
          val = (OPJ_INT16 )*__cil_tmp27;
#line 1802
          memcpy((void *)l_dest_ptr___0, (void const   *)(& val), sizeof(val));
#line 1803
          l_dest_ptr___0 ++;
#line 1800
          k ++;
          }
        }
        while_break___15: /* CIL Label */ ;
        }

        while_break___5: 
#line 1805
        l_src_ptr___0 += l_stride;
#line 1799
        j ++;
      }
      while_break___14: /* CIL Label */ ;
      }

      while_break___4: ;
    } else {
#line 1808
      j = (OPJ_UINT32 )0;
      {
#line 1808
      while (1) {
        while_continue___6: /* CIL Label */ ;

#line 1808
        if (! (j < l_height)) {
#line 1808
          goto while_break___6;
        }
#line 1809
        k = (OPJ_UINT32 )0;
        {
#line 1809
        while (1) {
          while_continue___7: /* CIL Label */ ;

#line 1809
          if (! (k < l_width)) {
#line 1809
            goto while_break___7;
          }
          {
#line 1810
          __cil_tmp30 = l_src_ptr___0;
#line 1810
          l_src_ptr___0 ++;
#line 1810
          val___0 = (OPJ_INT16 )(*__cil_tmp30 & 65535);
#line 1811
          memcpy((void *)l_dest_ptr___0, (void const   *)(& val___0), sizeof(val___0));
#line 1812
          l_dest_ptr___0 ++;
#line 1809
          k ++;
          }
        }
        while_break___17: /* CIL Label */ ;
        }

        while_break___7: 
#line 1814
        l_src_ptr___0 += l_stride;
#line 1808
        j ++;
      }
      while_break___16: /* CIL Label */ ;
      }

      while_break___6: ;
    }
#line 1818
    p_dest = (OPJ_BYTE *)l_dest_ptr___0;
#line 1820
    goto switch_break;
    case_4: 
#line 1822
    l_dest_ptr___1 = (OPJ_INT32 *)p_dest;
#line 1823
    l_src_ptr___1 = l_src_data;
#line 1825
    j = (OPJ_UINT32 )0;
    {
#line 1825
    while (1) {
      while_continue___8: /* CIL Label */ ;

#line 1825
      if (! (j < l_height)) {
#line 1825
        goto while_break___8;
      }
      {
#line 1826
      memcpy((void *)l_dest_ptr___1, (void const   *)l_src_ptr___1, (unsigned long )l_width * sizeof(OPJ_INT32 ));
#line 1827
      l_dest_ptr___1 += l_width;
#line 1828
      l_src_ptr___1 += l_width + l_stride;
#line 1825
      j ++;
      }
    }
    while_break___18: /* CIL Label */ ;
    }

    while_break___8: 
#line 1831
    p_dest = (OPJ_BYTE *)l_dest_ptr___1;
#line 1833
    goto switch_break;
    switch_break: 
#line 1836
    l_img_comp ++;
#line 1837
    l_tilec ++;
#line 1743
    i ++;
  }
  while_break___9: /* CIL Label */ ;
  }

  while_break: ;
#line 1840
  return (1);
}
}
#line 1846 "/root/patron-new/39/src/lib/openjp2/tcd.c"
static void opj_tcd_free_tile(opj_tcd_t *p_tcd ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 bandno ;
  OPJ_UINT32 precno ;
  opj_tcd_tile_t *l_tile ;
  opj_tcd_tilecomp_t *l_tile_comp ;
  opj_tcd_resolution_t *l_res ;
  opj_tcd_band_t *l_band ;
  opj_tcd_precinct_t *l_precinct ;
  OPJ_UINT32 l_nb_resolutions ;
  OPJ_UINT32 l_nb_precincts ;
  void (*l_tcd_code_block_deallocate)(opj_tcd_precinct_t * ) ;

  {
#line 1849
  l_tile = (opj_tcd_tile_t *)0;
#line 1850
  l_tile_comp = (opj_tcd_tilecomp_t *)0;
#line 1851
  l_res = (opj_tcd_resolution_t *)0;
#line 1852
  l_band = (opj_tcd_band_t *)0;
#line 1853
  l_precinct = (opj_tcd_precinct_t *)0;
#line 1855
  l_tcd_code_block_deallocate = (void (*)(opj_tcd_precinct_t * ))0;
#line 1857
  if (! p_tcd) {
#line 1858
    return;
  }
#line 1861
  if (! p_tcd->tcd_image) {
#line 1862
    return;
  }
#line 1865
  if (p_tcd->m_is_decoder) {
#line 1866
    l_tcd_code_block_deallocate = & opj_tcd_code_block_dec_deallocate;
  } else {
#line 1868
    l_tcd_code_block_deallocate = & opj_tcd_code_block_enc_deallocate;
  }
#line 1871
  l_tile = (p_tcd->tcd_image)->tiles;
#line 1872
  if (! l_tile) {
#line 1873
    return;
  }
#line 1876
  l_tile_comp = l_tile->comps;
#line 1878
  compno = (OPJ_UINT32 )0;
  {
#line 1878
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1878
    if (! (compno < l_tile->numcomps)) {
#line 1878
      goto while_break;
    }
#line 1879
    l_res = l_tile_comp->resolutions;
#line 1880
    if (l_res) {
#line 1882
      l_nb_resolutions = l_tile_comp->resolutions_size / (OPJ_UINT32 )sizeof(opj_tcd_resolution_t );
#line 1884
      resno = (OPJ_UINT32 )0;
      {
#line 1884
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 1884
        if (! (resno < l_nb_resolutions)) {
#line 1884
          goto while_break___0;
        }
#line 1885
        l_band = l_res->bands;
#line 1886
        bandno = (OPJ_UINT32 )0;
        {
#line 1886
        while (1) {
          while_continue___1: /* CIL Label */ ;

#line 1886
          if (! (bandno < 3U)) {
#line 1886
            goto while_break___1;
          }
#line 1887
          l_precinct = l_band->precincts;
#line 1888
          if (l_precinct) {
#line 1890
            l_nb_precincts = l_band->precincts_data_size / (OPJ_UINT32 )sizeof(opj_tcd_precinct_t );
#line 1892
            precno = (OPJ_UINT32 )0;
            {
#line 1892
            while (1) {
              while_continue___2: /* CIL Label */ ;

#line 1892
              if (! (precno < l_nb_precincts)) {
#line 1892
                goto while_break___2;
              }
              {
#line 1893
              opj_tgt_destroy(l_precinct->incltree);
#line 1894
              l_precinct->incltree = (opj_tgt_tree_t *)0;
#line 1895
              opj_tgt_destroy(l_precinct->imsbtree);
#line 1896
              l_precinct->imsbtree = (opj_tgt_tree_t *)0;
#line 1897
              (*l_tcd_code_block_deallocate)(l_precinct);
#line 1898
              l_precinct ++;
#line 1892
              precno ++;
              }
            }
            while_break___6: /* CIL Label */ ;
            }

            while_break___2: 
            {
#line 1901
            opj_free((void *)l_band->precincts);
#line 1902
            l_band->precincts = (opj_tcd_precinct_t *)0;
            }
          }
#line 1904
          l_band ++;
#line 1886
          bandno ++;
        }
        while_break___5: /* CIL Label */ ;
        }

        while_break___1: 
#line 1906
        l_res ++;
#line 1884
        resno ++;
      }
      while_break___4: /* CIL Label */ ;
      }

      while_break___0: 
      {
#line 1909
      opj_free((void *)l_tile_comp->resolutions);
#line 1910
      l_tile_comp->resolutions = (opj_tcd_resolution_t *)0;
      }
    }
#line 1913
    if (l_tile_comp->data) {
#line 1913
      if (l_tile_comp->ownsData) {
        {
#line 1914
        opj_image_data_free((void *)l_tile_comp->data);
#line 1915
        l_tile_comp->data = (OPJ_INT32 *)0;
#line 1916
        l_tile_comp->ownsData = 0;
#line 1917
        l_tile_comp->data_size = (size_t )0;
#line 1918
        l_tile_comp->data_size_needed = (size_t )0;
        }
      }
    }
    {
#line 1921
    opj_image_data_free((void *)l_tile_comp->data_win);
#line 1923
    l_tile_comp ++;
#line 1878
    compno ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }

  while_break: 
  {
#line 1926
  opj_free((void *)l_tile->comps);
#line 1927
  l_tile->comps = (opj_tcd_tilecomp_t *)0;
#line 1928
  opj_free((void *)(p_tcd->tcd_image)->tiles);
#line 1929
  (p_tcd->tcd_image)->tiles = (opj_tcd_tile_t *)0;
  }
#line 1931
  return;
}
}
#line 1933 "/root/patron-new/39/src/lib/openjp2/tcd.c"
static OPJ_BOOL opj_tcd_t2_decode(opj_tcd_t *p_tcd , OPJ_BYTE *p_src_data , OPJ_UINT32 *p_data_read ,
                                  OPJ_UINT32 p_max_src_size , opj_codestream_index_t *p_cstr_index ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  opj_t2_t *l_t2 ;
  OPJ_BOOL __cil_tmp9 ;

  {
  {
#line 1943
  l_t2 = opj_t2_create(p_tcd->image, p_tcd->cp);
  }
#line 1944
  if ((unsigned long )l_t2 == (unsigned long )((opj_t2_t *)0)) {
#line 1945
    return (0);
  }
  {
#line 1948
  __cil_tmp9 = opj_t2_decode_packets(p_tcd, l_t2, p_tcd->tcd_tileno, (p_tcd->tcd_image)->tiles,
                                     p_src_data, p_data_read, p_max_src_size, p_cstr_index,
                                     p_manager);
  }
#line 1948
  if (! __cil_tmp9) {
    {
#line 1958
    opj_t2_destroy(l_t2);
    }
#line 1959
    return (0);
  }
  {
#line 1962
  opj_t2_destroy(l_t2);
  }
#line 1965
  return (1);
}
}
#line 1968 "/root/patron-new/39/src/lib/openjp2/tcd.c"
static OPJ_BOOL opj_tcd_t1_decode(opj_tcd_t *p_tcd , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 compno ;
  opj_tcd_tile_t *l_tile ;
  opj_tcd_tilecomp_t *l_tile_comp ;
  opj_tccp_t *l_tccp ;
  OPJ_BOOL ret ;
  OPJ_BOOL check_pterm ;
  opj_mutex_t *p_manager_mutex ;

  {
  {
#line 1971
  l_tile = (p_tcd->tcd_image)->tiles;
#line 1972
  l_tile_comp = l_tile->comps;
#line 1973
  l_tccp = (p_tcd->tcp)->tccps;
#line 1974
  ret = 1;
#line 1975
  check_pterm = 0;
#line 1976
  p_manager_mutex = (opj_mutex_t *)((void *)0);
#line 1978
  p_manager_mutex = opj_mutex_create();
  }
#line 1981
  if ((p_tcd->tcp)->num_layers_to_decode == (p_tcd->tcp)->numlayers) {
#line 1981
    if ((l_tccp->cblksty & 16U) != 0U) {
#line 1983
      check_pterm = 1;
    }
  }
#line 1986
  compno = (OPJ_UINT32 )0;
  {
#line 1986
  while (1) {
    while_continue___0: /* CIL Label */ ;

    while_continue: ;
#line 1986
    if (! (compno < l_tile->numcomps)) {
#line 1986
      goto while_break;
    }
#line 1988
    if ((unsigned long )p_tcd->used_component != (unsigned long )((void *)0)) {
#line 1988
      if (! *(p_tcd->used_component + compno)) {
#line 1989
        goto while_continue;
      }
    }
    {
#line 1992
    opj_t1_decode_cblks(p_tcd, & ret, l_tile_comp, l_tccp, p_manager, p_manager_mutex,
                        check_pterm);
    }
#line 1994
    if (! ret) {
#line 1995
      goto while_break;
    }
#line 1987
    l_tccp ++;
#line 1987
    l_tile_comp ++;
#line 1987
    compno ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: 
  {
#line 1999
  opj_thread_pool_wait_completion(p_tcd->thread_pool, 0);
  }
#line 2000
  if (p_manager_mutex) {
    {
#line 2001
    opj_mutex_destroy(p_manager_mutex);
    }
  }
#line 2003
  return (ret);
}
}
#line 2007 "/root/patron-new/39/src/lib/openjp2/tcd.c"
static OPJ_BOOL opj_tcd_dwt_decode(opj_tcd_t *p_tcd ) 
{ 
  OPJ_UINT32 compno ;
  opj_tcd_tile_t *l_tile ;
  opj_tcd_tilecomp_t *l_tile_comp ;
  opj_tccp_t *l_tccp ;
  opj_image_comp_t *l_img_comp ;
  OPJ_BOOL __cil_tmp7 ;
  OPJ_BOOL __cil_tmp8 ;
  OPJ_UINT32 __cil_tmp9 ;

  {
#line 2010
  l_tile = (p_tcd->tcd_image)->tiles;
#line 2011
  l_tile_comp = l_tile->comps;
#line 2012
  l_tccp = (p_tcd->tcp)->tccps;
#line 2013
  l_img_comp = (p_tcd->image)->comps;
#line 2015
  compno = (OPJ_UINT32 )0;
  {
#line 2015
  while (1) {
    while_continue___0: /* CIL Label */ ;

    while_continue: ;
#line 2015
    if (! (compno < l_tile->numcomps)) {
#line 2015
      goto while_break;
    }
#line 2017
    if ((unsigned long )p_tcd->used_component != (unsigned long )((void *)0)) {
#line 2017
      if (! *(p_tcd->used_component + compno)) {
#line 2018
        goto while_continue;
      }
    }
#line 2021
    if (l_tccp->qmfbid == 1U) {
      {
#line 2022
      __cil_tmp7 = opj_dwt_decode(p_tcd, l_tile_comp, l_img_comp->resno_decoded + 1U);
      }
#line 2022
      if (! __cil_tmp7) {
#line 2024
        return (0);
      }
    } else {
      {
#line 2027
      __cil_tmp8 = opj_dwt_decode_real(p_tcd, l_tile_comp, l_img_comp->resno_decoded + 1U);
      }
#line 2027
      if (! __cil_tmp8) {
#line 2029
        return (0);
      }
    }
#line 2016
    l_tccp ++;
#line 2016
    l_img_comp ++;
#line 2016
    l_tile_comp ++;
#line 2016
    __cil_tmp9 = compno;
#line 2016
    compno ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 2035
  return (1);
}
}
#line 2038 "/root/patron-new/39/src/lib/openjp2/tcd.c"
static OPJ_BOOL opj_tcd_mct_decode(opj_tcd_t *p_tcd , opj_event_mgr_t *p_manager ) 
{ 
  opj_tcd_tile_t *l_tile ;
  opj_tcp_t *l_tcp ;
  opj_tcd_tilecomp_t *l_tile_comp ;
  OPJ_SIZE_T l_samples ;
  OPJ_UINT32 i ;
  opj_tcd_resolution_t *res_comp0 ;
  opj_tcd_resolution_t *res_comp1 ;
  opj_tcd_resolution_t *res_comp2 ;
  opj_tcd_resolution_t *res_comp0___0 ;
  opj_tcd_resolution_t *res_comp1___0 ;
  opj_tcd_resolution_t *res_comp2___0 ;
  OPJ_BYTE **l_data ;
  void *__cil_tmp15 ;
  OPJ_BOOL __cil_tmp16 ;

  {
#line 2040
  l_tile = (p_tcd->tcd_image)->tiles;
#line 2041
  l_tcp = p_tcd->tcp;
#line 2042
  l_tile_comp = l_tile->comps;
#line 2046
  if ((unsigned long )p_tcd->used_component != (unsigned long )((void *)0)) {
#line 2047
    return (1);
  } else
#line 2046
  if (l_tcp->mct == 0U) {
#line 2047
    return (1);
  }
#line 2050
  if (p_tcd->whole_tile_decoding) {
#line 2051
    res_comp0 = ((l_tile->comps + 0)->resolutions + l_tile_comp->minimum_num_resolutions) - 1;
#line 2057
    l_samples = (OPJ_SIZE_T )(res_comp0->x1 - res_comp0->x0) * (OPJ_SIZE_T )(res_comp0->y1 - res_comp0->y0);
#line 2059
    if (l_tile->numcomps >= 3U) {
#line 2060
      if (l_tile_comp->minimum_num_resolutions != (l_tile->comps + 1)->minimum_num_resolutions) {
        {
#line 2064
        opj_event_msg(p_manager, 1, "Tiles don\'t all have the same dimension. Skip the MCT step.\n]U");
        }
#line 2066
        return (0);
      } else
#line 2060
      if (l_tile_comp->minimum_num_resolutions != (l_tile->comps + 2)->minimum_num_resolutions) {
        {
#line 2064
        opj_event_msg(p_manager, 1, "Tiles don\'t all have the same dimension. Skip the MCT step.\n]U");
        }
#line 2066
        return (0);
      }
    }
#line 2069
    if (l_tile->numcomps >= 3U) {
#line 2070
      res_comp1 = ((l_tile->comps + 1)->resolutions + l_tile_comp->minimum_num_resolutions) - 1;
#line 2072
      res_comp2 = ((l_tile->comps + 2)->resolutions + l_tile_comp->minimum_num_resolutions) - 1;
#line 2075
      if (((p_tcd->image)->comps + 0)->resno_decoded != ((p_tcd->image)->comps + 1)->resno_decoded) {
        {
#line 2083
        opj_event_msg(p_manager, 1, "Tiles don\'t all have the same dimension. Skip the MCT step.\n");
        }
#line 2085
        return (0);
      } else
#line 2075
      if (((p_tcd->image)->comps + 0)->resno_decoded != ((p_tcd->image)->comps + 2)->resno_decoded) {
        {
#line 2083
        opj_event_msg(p_manager, 1, "Tiles don\'t all have the same dimension. Skip the MCT step.\n");
        }
#line 2085
        return (0);
      } else
#line 2075
      if ((OPJ_SIZE_T )(res_comp1->x1 - res_comp1->x0) * (OPJ_SIZE_T )(res_comp1->y1 - res_comp1->y0) != l_samples) {
        {
#line 2083
        opj_event_msg(p_manager, 1, "Tiles don\'t all have the same dimension. Skip the MCT step.\n");
        }
#line 2085
        return (0);
      } else
#line 2075
      if ((OPJ_SIZE_T )(res_comp2->x1 - res_comp2->x0) * (OPJ_SIZE_T )(res_comp2->y1 - res_comp2->y0) != l_samples) {
        {
#line 2083
        opj_event_msg(p_manager, 1, "Tiles don\'t all have the same dimension. Skip the MCT step.\n");
        }
#line 2085
        return (0);
      }
    }
  } else {
#line 2089
    res_comp0___0 = (l_tile->comps + 0)->resolutions + ((p_tcd->image)->comps + 0)->resno_decoded;
#line 2092
    l_samples = (OPJ_SIZE_T )(res_comp0___0->win_x1 - res_comp0___0->win_x0) * (OPJ_SIZE_T )(res_comp0___0->win_y1 - res_comp0___0->win_y0);
#line 2094
    if (l_tile->numcomps >= 3U) {
#line 2095
      res_comp1___0 = (l_tile->comps + 1)->resolutions + ((p_tcd->image)->comps + 1)->resno_decoded;
#line 2097
      res_comp2___0 = (l_tile->comps + 2)->resolutions + ((p_tcd->image)->comps + 2)->resno_decoded;
#line 2100
      if (((p_tcd->image)->comps + 0)->resno_decoded != ((p_tcd->image)->comps + 1)->resno_decoded) {
        {
#line 2108
        opj_event_msg(p_manager, 1, "Tiles don\'t all have the same dimension. Skip the MCT step.\n");
        }
#line 2110
        return (0);
      } else
#line 2100
      if (((p_tcd->image)->comps + 0)->resno_decoded != ((p_tcd->image)->comps + 2)->resno_decoded) {
        {
#line 2108
        opj_event_msg(p_manager, 1, "Tiles don\'t all have the same dimension. Skip the MCT step.\n");
        }
#line 2110
        return (0);
      } else
#line 2100
      if ((OPJ_SIZE_T )(res_comp1___0->win_x1 - res_comp1___0->win_x0) * (OPJ_SIZE_T )(res_comp1___0->win_y1 - res_comp1___0->win_y0) != l_samples) {
        {
#line 2108
        opj_event_msg(p_manager, 1, "Tiles don\'t all have the same dimension. Skip the MCT step.\n");
        }
#line 2110
        return (0);
      } else
#line 2100
      if ((OPJ_SIZE_T )(res_comp2___0->win_x1 - res_comp2___0->win_x0) * (OPJ_SIZE_T )(res_comp2___0->win_y1 - res_comp2___0->win_y0) != l_samples) {
        {
#line 2108
        opj_event_msg(p_manager, 1, "Tiles don\'t all have the same dimension. Skip the MCT step.\n");
        }
#line 2110
        return (0);
      }
    }
  }
#line 2115
  if (l_tile->numcomps >= 3U) {
#line 2116
    if (l_tcp->mct == 2U) {
#line 2119
      if (! l_tcp->m_mct_decoding_matrix) {
#line 2120
        return (1);
      }
      {
#line 2123
      __cil_tmp15 = opj_malloc((unsigned long )l_tile->numcomps * sizeof(OPJ_BYTE *));
#line 2123
      l_data = (OPJ_BYTE **)__cil_tmp15;
      }
#line 2124
      if (! l_data) {
#line 2125
        return (0);
      }
#line 2128
      i = (OPJ_UINT32 )0;
      {
#line 2128
      while (1) {
        while_continue: /* CIL Label */ ;

#line 2128
        if (! (i < l_tile->numcomps)) {
#line 2128
          goto while_break;
        }
#line 2129
        if (p_tcd->whole_tile_decoding) {
#line 2130
          *(l_data + i) = (OPJ_BYTE *)l_tile_comp->data;
        } else {
#line 2132
          *(l_data + i) = (OPJ_BYTE *)l_tile_comp->data_win;
        }
#line 2134
        l_tile_comp ++;
#line 2128
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }

      while_break: 
      {
#line 2137
      __cil_tmp16 = opj_mct_decode_custom((OPJ_BYTE *)l_tcp->m_mct_decoding_matrix,
                                          l_samples, l_data, l_tile->numcomps, ((p_tcd->image)->comps)->sgnd);
      }
#line 2137
      if (! __cil_tmp16) {
        {
#line 2147
        opj_free((void *)l_data);
        }
#line 2148
        return (0);
      }
      {
#line 2151
      opj_free((void *)l_data);
      }
    } else
#line 2153
    if ((l_tcp->tccps)->qmfbid == 1U) {
#line 2154
      if (p_tcd->whole_tile_decoding) {
        {
#line 2155
        opj_mct_decode((l_tile->comps + 0)->data, (l_tile->comps + 1)->data, (l_tile->comps + 2)->data,
                       l_samples);
        }
      } else {
        {
#line 2160
        opj_mct_decode((l_tile->comps + 0)->data_win, (l_tile->comps + 1)->data_win,
                       (l_tile->comps + 2)->data_win, l_samples);
        }
      }
    } else
#line 2166
    if (p_tcd->whole_tile_decoding) {
      {
#line 2167
      opj_mct_decode_real((OPJ_FLOAT32 *)(l_tile->comps + 0)->data, (OPJ_FLOAT32 *)(l_tile->comps + 1)->data,
                          (OPJ_FLOAT32 *)(l_tile->comps + 2)->data, l_samples);
      }
    } else {
      {
#line 2172
      opj_mct_decode_real((OPJ_FLOAT32 *)(l_tile->comps + 0)->data_win, (OPJ_FLOAT32 *)(l_tile->comps + 1)->data_win,
                          (OPJ_FLOAT32 *)(l_tile->comps + 2)->data_win, l_samples);
      }
    }
  } else {
    {
#line 2180
    opj_event_msg(p_manager, 1, "Number of components (%d) is inconsistent with a MCT. Skip the MCT step.\n",
                  l_tile->numcomps);
    }
  }
#line 2185
  return (1);
}
}
#line 2189 "/root/patron-new/39/src/lib/openjp2/tcd.c"
static OPJ_BOOL opj_tcd_dc_level_shift_decode(opj_tcd_t *p_tcd ) 
{ 
  OPJ_UINT32 compno ;
  opj_tcd_tilecomp_t *l_tile_comp ;
  opj_tccp_t *l_tccp ;
  opj_image_comp_t *l_img_comp ;
  opj_tcd_resolution_t *l_res ;
  opj_tcd_tile_t *l_tile ;
  OPJ_UINT32 l_width ;
  OPJ_UINT32 l_height ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_INT32 *l_current_ptr ;
  OPJ_INT32 l_min ;
  OPJ_INT32 l_max ;
  OPJ_UINT32 l_stride ;
  OPJ_FLOAT32 l_value ;
  OPJ_INT64 l_value_int ;
  long __cil_tmp20 ;
  OPJ_INT64 __cil_tmp21 ;
  OPJ_UINT32 __cil_tmp22 ;

  {
#line 2192
  l_tile_comp = (opj_tcd_tilecomp_t *)0;
#line 2193
  l_tccp = (opj_tccp_t *)0;
#line 2194
  l_img_comp = (opj_image_comp_t *)0;
#line 2195
  l_res = (opj_tcd_resolution_t *)0;
#line 2202
  l_tile = (p_tcd->tcd_image)->tiles;
#line 2203
  l_tile_comp = l_tile->comps;
#line 2204
  l_tccp = (p_tcd->tcp)->tccps;
#line 2205
  l_img_comp = (p_tcd->image)->comps;
#line 2207
  compno = (OPJ_UINT32 )0;
  {
#line 2207
  while (1) {
    while_continue___0: /* CIL Label */ ;

    while_continue: ;
#line 2207
    if (! (compno < l_tile->numcomps)) {
#line 2207
      goto while_break;
    }
#line 2210
    if ((unsigned long )p_tcd->used_component != (unsigned long )((void *)0)) {
#line 2210
      if (! *(p_tcd->used_component + compno)) {
#line 2211
        goto while_continue;
      }
    }
#line 2214
    l_res = l_tile_comp->resolutions + l_img_comp->resno_decoded;
#line 2216
    if (! p_tcd->whole_tile_decoding) {
#line 2217
      l_width = l_res->win_x1 - l_res->win_x0;
#line 2218
      l_height = l_res->win_y1 - l_res->win_y0;
#line 2219
      l_stride = (OPJ_UINT32 )0;
#line 2220
      l_current_ptr = l_tile_comp->data_win;
    } else {
#line 2222
      l_width = (OPJ_UINT32 )(l_res->x1 - l_res->x0);
#line 2223
      l_height = (OPJ_UINT32 )(l_res->y1 - l_res->y0);
#line 2224
      l_stride = (OPJ_UINT32 )((l_tile_comp->resolutions + (l_tile_comp->minimum_num_resolutions - 1U))->x1 - (l_tile_comp->resolutions + (l_tile_comp->minimum_num_resolutions - 1U))->x0) - l_width;
#line 2228
      l_current_ptr = l_tile_comp->data;
    }
#line 2234
    if (l_img_comp->sgnd) {
#line 2235
      l_min = - (1 << (l_img_comp->prec - 1U));
#line 2236
      l_max = (1 << (l_img_comp->prec - 1U)) - 1;
    } else {
#line 2238
      l_min = 0;
#line 2239
      l_max = (OPJ_INT32 )((1U << l_img_comp->prec) - 1U);
    }
#line 2243
    if (l_tccp->qmfbid == 1U) {
#line 2244
      j = (OPJ_UINT32 )0;
      {
#line 2244
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 2244
        if (! (j < l_height)) {
#line 2244
          goto while_break___0;
        }
#line 2245
        i = (OPJ_UINT32 )0;
        {
#line 2245
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 2245
          if (! (i < l_width)) {
#line 2245
            goto while_break___1;
          }
          {
#line 2247
          *l_current_ptr = opj_int_clamp(*l_current_ptr + l_tccp->m_dc_level_shift,
                                         l_min, l_max);
#line 2249
          l_current_ptr ++;
#line 2245
          i ++;
          }
        }
        while_break___6: /* CIL Label */ ;
        }

        while_break___1: 
#line 2251
        l_current_ptr += l_stride;
#line 2244
        j ++;
      }
      while_break___5: /* CIL Label */ ;
      }

      while_break___0: ;
    } else {
#line 2254
      j = (OPJ_UINT32 )0;
      {
#line 2254
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 2254
        if (! (j < l_height)) {
#line 2254
          goto while_break___2;
        }
#line 2255
        i = (OPJ_UINT32 )0;
        {
#line 2255
        while (1) {
          while_continue___4: /* CIL Label */ ;

#line 2255
          if (! (i < l_width)) {
#line 2255
            goto while_break___3;
          }
#line 2256
          l_value = *((OPJ_FLOAT32 *)l_current_ptr);
#line 2257
          if (l_value > (float )2147483647) {
#line 2258
            *l_current_ptr = l_max;
          } else
#line 2259
          if (l_value < (float )(-0x7FFFFFFF-1)) {
#line 2260
            *l_current_ptr = l_min;
          } else {
            {
#line 2263
            __cil_tmp20 = opj_lrintf(l_value);
#line 2263
            l_value_int = __cil_tmp20;
#line 2264
            __cil_tmp21 = opj_int64_clamp(l_value_int + (long )l_tccp->m_dc_level_shift,
                                          (OPJ_INT64 )l_min, (OPJ_INT64 )l_max);
#line 2264
            *l_current_ptr = (OPJ_INT32 )__cil_tmp21;
            }
          }
#line 2267
          l_current_ptr ++;
#line 2255
          i ++;
        }
        while_break___8: /* CIL Label */ ;
        }

        while_break___3: 
#line 2269
        l_current_ptr += l_stride;
#line 2254
        j ++;
      }
      while_break___7: /* CIL Label */ ;
      }

      while_break___2: ;
    }
#line 2208
    l_tile_comp ++;
#line 2208
    l_tccp ++;
#line 2208
    l_img_comp ++;
#line 2208
    __cil_tmp22 = compno;
#line 2208
    compno ++;
  }
  while_break___4: /* CIL Label */ ;
  }

  while_break: ;
#line 2274
  return (1);
}
}
#line 2282 "/root/patron-new/39/src/lib/openjp2/tcd.c"
static void opj_tcd_code_block_dec_deallocate(opj_tcd_precinct_t *p_precinct ) 
{ 
  OPJ_UINT32 cblkno ;
  OPJ_UINT32 l_nb_code_blocks ;
  opj_tcd_cblk_dec_t *l_code_block ;

  {
#line 2286
  l_code_block = p_precinct->cblks.dec;
#line 2287
  if (l_code_block) {
#line 2294
    l_nb_code_blocks = p_precinct->block_size / (OPJ_UINT32 )sizeof(opj_tcd_cblk_dec_t );
#line 2298
    cblkno = (OPJ_UINT32 )0;
    {
#line 2298
    while (1) {
      while_continue: /* CIL Label */ ;

#line 2298
      if (! (cblkno < l_nb_code_blocks)) {
#line 2298
        goto while_break;
      }
#line 2300
      if (l_code_block->segs) {
        {
#line 2301
        opj_free((void *)l_code_block->segs);
#line 2302
        l_code_block->segs = (opj_tcd_seg_t *)0;
        }
      }
#line 2305
      if (l_code_block->chunks) {
        {
#line 2306
        opj_free((void *)l_code_block->chunks);
#line 2307
        l_code_block->chunks = (opj_tcd_seg_data_chunk_t *)0;
        }
      }
      {
#line 2310
      opj_aligned_free((void *)l_code_block->decoded_data);
#line 2311
      l_code_block->decoded_data = (OPJ_INT32 *)((void *)0);
#line 2313
      l_code_block ++;
#line 2298
      cblkno ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }

    while_break: 
    {
#line 2316
    opj_free((void *)p_precinct->cblks.dec);
#line 2317
    p_precinct->cblks.dec = (opj_tcd_cblk_dec_t *)0;
    }
  }
#line 2320
  return;
}
}
#line 2324 "/root/patron-new/39/src/lib/openjp2/tcd.c"
static void opj_tcd_code_block_enc_deallocate(opj_tcd_precinct_t *p_precinct ) 
{ 
  OPJ_UINT32 cblkno ;
  OPJ_UINT32 l_nb_code_blocks ;
  opj_tcd_cblk_enc_t *l_code_block ;

  {
#line 2328
  l_code_block = p_precinct->cblks.enc;
#line 2329
  if (l_code_block) {
#line 2330
    l_nb_code_blocks = p_precinct->block_size / (OPJ_UINT32 )sizeof(opj_tcd_cblk_enc_t );
#line 2333
    cblkno = (OPJ_UINT32 )0;
    {
#line 2333
    while (1) {
      while_continue: /* CIL Label */ ;

#line 2333
      if (! (cblkno < l_nb_code_blocks)) {
#line 2333
        goto while_break;
      }
#line 2334
      if (l_code_block->data) {
        {
#line 2337
        opj_free((void *)(l_code_block->data - 1));
#line 2338
        l_code_block->data = (OPJ_BYTE *)0;
        }
      }
#line 2341
      if (l_code_block->layers) {
        {
#line 2342
        opj_free((void *)l_code_block->layers);
#line 2343
        l_code_block->layers = (opj_tcd_layer_t *)0;
        }
      }
#line 2346
      if (l_code_block->passes) {
        {
#line 2347
        opj_free((void *)l_code_block->passes);
#line 2348
        l_code_block->passes = (opj_tcd_pass_t *)0;
        }
      }
#line 2350
      l_code_block ++;
#line 2333
      cblkno ++;
    }
    while_break___0: /* CIL Label */ ;
    }

    while_break: 
    {
#line 2353
    opj_free((void *)p_precinct->cblks.enc);
#line 2355
    p_precinct->cblks.enc = (opj_tcd_cblk_enc_t *)0;
    }
  }
#line 2358
  return;
}
}
#line 2359 "/root/patron-new/39/src/lib/openjp2/tcd.c"
OPJ_SIZE_T opj_tcd_get_encoder_input_buffer_size(opj_tcd_t *p_tcd ) 
{ 
  OPJ_UINT32 i ;
  OPJ_SIZE_T l_data_size ;
  opj_image_comp_t *l_img_comp ;
  opj_tcd_tilecomp_t *l_tilec ;
  OPJ_UINT32 l_size_comp ;
  OPJ_UINT32 l_remaining ;

  {
#line 2362
  l_data_size = (OPJ_SIZE_T )0;
#line 2363
  l_img_comp = (opj_image_comp_t *)0;
#line 2364
  l_tilec = (opj_tcd_tilecomp_t *)0;
#line 2367
  l_tilec = ((p_tcd->tcd_image)->tiles)->comps;
#line 2368
  l_img_comp = (p_tcd->image)->comps;
#line 2369
  i = (OPJ_UINT32 )0;
  {
#line 2369
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2369
    if (! (i < (p_tcd->image)->numcomps)) {
#line 2369
      goto while_break;
    }
#line 2370
    l_size_comp = l_img_comp->prec >> 3;
#line 2371
    l_remaining = l_img_comp->prec & 7U;
#line 2373
    if (l_remaining) {
#line 2374
      l_size_comp ++;
    }
#line 2377
    if (l_size_comp == 3U) {
#line 2378
      l_size_comp = (OPJ_UINT32 )4;
    }
#line 2381
    l_data_size += (unsigned long )l_size_comp * ((OPJ_SIZE_T )(l_tilec->x1 - l_tilec->x0) * (OPJ_SIZE_T )(l_tilec->y1 - l_tilec->y0));
#line 2383
    l_img_comp ++;
#line 2384
    l_tilec ++;
#line 2369
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 2387
  return (l_data_size);
}
}
#line 2390 "/root/patron-new/39/src/lib/openjp2/tcd.c"
static OPJ_BOOL opj_tcd_dc_level_shift_encode(opj_tcd_t *p_tcd ) 
{ 
  OPJ_UINT32 compno ;
  opj_tcd_tilecomp_t *l_tile_comp ;
  opj_tccp_t *l_tccp ;
  opj_image_comp_t *l_img_comp ;
  opj_tcd_tile_t *l_tile ;
  OPJ_SIZE_T l_nb_elem ;
  OPJ_SIZE_T i ;
  OPJ_INT32 *l_current_ptr ;

  {
#line 2393
  l_tile_comp = (opj_tcd_tilecomp_t *)0;
#line 2394
  l_tccp = (opj_tccp_t *)0;
#line 2395
  l_img_comp = (opj_image_comp_t *)0;
#line 2400
  l_tile = (p_tcd->tcd_image)->tiles;
#line 2401
  l_tile_comp = l_tile->comps;
#line 2402
  l_tccp = (p_tcd->tcp)->tccps;
#line 2403
  l_img_comp = (p_tcd->image)->comps;
#line 2405
  compno = (OPJ_UINT32 )0;
  {
#line 2405
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2405
    if (! (compno < l_tile->numcomps)) {
#line 2405
      goto while_break;
    }
#line 2406
    l_current_ptr = l_tile_comp->data;
#line 2407
    l_nb_elem = (OPJ_SIZE_T )(l_tile_comp->x1 - l_tile_comp->x0) * (OPJ_SIZE_T )(l_tile_comp->y1 - l_tile_comp->y0);
#line 2410
    if (l_tccp->qmfbid == 1U) {
#line 2411
      i = (OPJ_SIZE_T )0;
      {
#line 2411
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 2411
        if (! (i < l_nb_elem)) {
#line 2411
          goto while_break___0;
        }
#line 2412
        *l_current_ptr -= l_tccp->m_dc_level_shift;
#line 2413
        l_current_ptr ++;
#line 2411
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }

      while_break___0: ;
    } else {
#line 2416
      i = (OPJ_SIZE_T )0;
      {
#line 2416
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 2416
        if (! (i < l_nb_elem)) {
#line 2416
          goto while_break___1;
        }
#line 2417
        *((OPJ_FLOAT32 *)l_current_ptr) = (OPJ_FLOAT32 )(*l_current_ptr - l_tccp->m_dc_level_shift);
#line 2419
        l_current_ptr ++;
#line 2416
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }

      while_break___1: ;
    }
#line 2423
    l_img_comp ++;
#line 2424
    l_tccp ++;
#line 2425
    l_tile_comp ++;
#line 2405
    compno ++;
  }
  while_break___2: /* CIL Label */ ;
  }

  while_break: ;
#line 2428
  return (1);
}
}
#line 2431 "/root/patron-new/39/src/lib/openjp2/tcd.c"
static OPJ_BOOL opj_tcd_mct_encode(opj_tcd_t *p_tcd ) 
{ 
  opj_tcd_tile_t *l_tile ;
  opj_tcd_tilecomp_t *l_tile_comp ;
  OPJ_SIZE_T samples ;
  OPJ_UINT32 i ;
  OPJ_BYTE **l_data ;
  opj_tcp_t *l_tcp ;
  void *__cil_tmp8 ;
  OPJ_BOOL __cil_tmp9 ;

  {
#line 2433
  l_tile = (p_tcd->tcd_image)->tiles;
#line 2434
  l_tile_comp = ((p_tcd->tcd_image)->tiles)->comps;
#line 2435
  samples = (OPJ_SIZE_T )(l_tile_comp->x1 - l_tile_comp->x0) * (OPJ_SIZE_T )(l_tile_comp->y1 - l_tile_comp->y0);
#line 2438
  l_data = (OPJ_BYTE **)0;
#line 2439
  l_tcp = p_tcd->tcp;
#line 2441
  if (! (p_tcd->tcp)->mct) {
#line 2442
    return (1);
  }
#line 2445
  if ((p_tcd->tcp)->mct == 2U) {
#line 2446
    if (! (p_tcd->tcp)->m_mct_coding_matrix) {
#line 2447
      return (1);
    }
    {
#line 2450
    __cil_tmp8 = opj_malloc((unsigned long )l_tile->numcomps * sizeof(OPJ_BYTE *));
#line 2450
    l_data = (OPJ_BYTE **)__cil_tmp8;
    }
#line 2451
    if (! l_data) {
#line 2452
      return (0);
    }
#line 2455
    i = (OPJ_UINT32 )0;
    {
#line 2455
    while (1) {
      while_continue: /* CIL Label */ ;

#line 2455
      if (! (i < l_tile->numcomps)) {
#line 2455
        goto while_break;
      }
#line 2456
      *(l_data + i) = (OPJ_BYTE *)l_tile_comp->data;
#line 2457
      l_tile_comp ++;
#line 2455
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }

    while_break: 
    {
#line 2460
    __cil_tmp9 = opj_mct_encode_custom((OPJ_BYTE *)(p_tcd->tcp)->m_mct_coding_matrix,
                                       samples, l_data, l_tile->numcomps, ((p_tcd->image)->comps)->sgnd);
    }
#line 2460
    if (! __cil_tmp9) {
      {
#line 2470
      opj_free((void *)l_data);
      }
#line 2471
      return (0);
    }
    {
#line 2474
    opj_free((void *)l_data);
    }
  } else
#line 2475
  if ((l_tcp->tccps)->qmfbid == 0U) {
    {
#line 2476
    opj_mct_encode_real((OPJ_FLOAT32 *)(l_tile->comps + 0)->data, (OPJ_FLOAT32 *)(l_tile->comps + 1)->data,
                        (OPJ_FLOAT32 *)(l_tile->comps + 2)->data, samples);
    }
  } else {
    {
#line 2482
    opj_mct_encode((l_tile->comps + 0)->data, (l_tile->comps + 1)->data, (l_tile->comps + 2)->data,
                   samples);
    }
  }
#line 2486
  return (1);
}
}
#line 2489 "/root/patron-new/39/src/lib/openjp2/tcd.c"
static OPJ_BOOL opj_tcd_dwt_encode(opj_tcd_t *p_tcd ) 
{ 
  opj_tcd_tile_t *l_tile ;
  opj_tcd_tilecomp_t *l_tile_comp ;
  opj_tccp_t *l_tccp ;
  OPJ_UINT32 compno ;
  OPJ_BOOL __cil_tmp6 ;
  OPJ_BOOL __cil_tmp7 ;

  {
#line 2491
  l_tile = (p_tcd->tcd_image)->tiles;
#line 2492
  l_tile_comp = ((p_tcd->tcd_image)->tiles)->comps;
#line 2493
  l_tccp = (p_tcd->tcp)->tccps;
#line 2496
  compno = (OPJ_UINT32 )0;
  {
#line 2496
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2496
    if (! (compno < l_tile->numcomps)) {
#line 2496
      goto while_break;
    }
#line 2497
    if (l_tccp->qmfbid == 1U) {
      {
#line 2498
      __cil_tmp6 = opj_dwt_encode(p_tcd, l_tile_comp);
      }
#line 2498
      if (! __cil_tmp6) {
#line 2499
        return (0);
      }
    } else
#line 2501
    if (l_tccp->qmfbid == 0U) {
      {
#line 2502
      __cil_tmp7 = opj_dwt_encode_real(p_tcd, l_tile_comp);
      }
#line 2502
      if (! __cil_tmp7) {
#line 2503
        return (0);
      }
    }
#line 2507
    l_tile_comp ++;
#line 2508
    l_tccp ++;
#line 2496
    compno ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 2511
  return (1);
}
}
#line 2514 "/root/patron-new/39/src/lib/openjp2/tcd.c"
static OPJ_BOOL opj_tcd_t1_encode(opj_tcd_t *p_tcd ) 
{ 
  OPJ_FLOAT64 *l_mct_norms ;
  OPJ_UINT32 l_mct_numcomps ;
  opj_tcp_t *l_tcp ;
  OPJ_BOOL __cil_tmp7 ;

  {
#line 2517
  l_mct_numcomps = 0U;
#line 2518
  l_tcp = p_tcd->tcp;
#line 2520
  if (l_tcp->mct == 1U) {
#line 2521
    l_mct_numcomps = 3U;
#line 2523
    if ((l_tcp->tccps)->qmfbid == 0U) {
      {
#line 2524
      l_mct_norms = opj_mct_get_mct_norms_real();
      }
    } else {
      {
#line 2526
      l_mct_norms = opj_mct_get_mct_norms();
      }
    }
  } else {
#line 2529
    l_mct_numcomps = (p_tcd->image)->numcomps;
#line 2530
    l_mct_norms = l_tcp->mct_norms;
  }
  {
#line 2533
  __cil_tmp7 = opj_t1_encode_cblks(p_tcd, (p_tcd->tcd_image)->tiles, l_tcp, l_mct_norms,
                                   l_mct_numcomps);
  }
#line 2533
  return (__cil_tmp7);
#line 2537
  return (1);
}
}
#line 2540 "/root/patron-new/39/src/lib/openjp2/tcd.c"
static OPJ_BOOL opj_tcd_t2_encode(opj_tcd_t *p_tcd , OPJ_BYTE *p_dest_data , OPJ_UINT32 *p_data_written ,
                                  OPJ_UINT32 p_max_dest_size , opj_codestream_info_t *p_cstr_info ,
                                  opj_tcd_marker_info_t *p_marker_info , opj_event_mgr_t *p_manager ) 
{ 
  opj_t2_t *l_t2 ;
  OPJ_BOOL __cil_tmp10 ;

  {
  {
#line 2550
  l_t2 = opj_t2_create(p_tcd->image, p_tcd->cp);
  }
#line 2551
  if ((unsigned long )l_t2 == (unsigned long )((opj_t2_t *)0)) {
#line 2552
    return (0);
  }
  {
#line 2555
  __cil_tmp10 = opj_t2_encode_packets(l_t2, p_tcd->tcd_tileno, (p_tcd->tcd_image)->tiles,
                                      (p_tcd->tcp)->numlayers, p_dest_data, p_data_written,
                                      p_max_dest_size, p_cstr_info, p_marker_info,
                                      p_tcd->tp_num, p_tcd->tp_pos, p_tcd->cur_pino,
                                      (J2K_T2_MODE )1, p_manager);
  }
#line 2555
  if (! __cil_tmp10) {
    {
#line 2570
    opj_t2_destroy(l_t2);
    }
#line 2571
    return (0);
  }
  {
#line 2574
  opj_t2_destroy(l_t2);
  }
#line 2577
  return (1);
}
}
#line 2581 "/root/patron-new/39/src/lib/openjp2/tcd.c"
static OPJ_BOOL opj_tcd_rate_allocate_encode(opj_tcd_t *p_tcd , OPJ_BYTE *p_dest_data ,
                                             OPJ_UINT32 p_max_dest_size , opj_codestream_info_t *p_cstr_info ,
                                             opj_event_mgr_t *p_manager ) 
{ 
  opj_cp_t *l_cp ;
  OPJ_UINT32 l_nb_written ;
  OPJ_BOOL __cil_tmp8 ;

  {
#line 2587
  l_cp = p_tcd->cp;
#line 2588
  l_nb_written = (OPJ_UINT32 )0;
#line 2590
  if (p_cstr_info) {
#line 2591
    p_cstr_info->index_write = 0;
  }
#line 2594
  if ((int )l_cp->m_specific_param.m_enc.m_disto_alloc) {
    _L: 
    {
#line 2598
    __cil_tmp8 = opj_tcd_rateallocate(p_tcd, p_dest_data, & l_nb_written, p_max_dest_size,
                                      p_cstr_info, p_manager);
    }
#line 2598
    if (! __cil_tmp8) {
#line 2600
      return (0);
    }
  } else
#line 2594
  if ((int )l_cp->m_specific_param.m_enc.m_fixed_quality) {
#line 2594
    goto _L;
  } else {
    {
#line 2604
    opj_tcd_rateallocate_fixed(p_tcd);
    }
  }
#line 2607
  return (1);
}
}
#line 2611 "/root/patron-new/39/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_copy_tile_data(opj_tcd_t *p_tcd , OPJ_BYTE *p_src , OPJ_SIZE_T p_src_length ) 
{ 
  OPJ_UINT32 i ;
  OPJ_SIZE_T j ;
  OPJ_SIZE_T l_data_size ;
  opj_image_comp_t *l_img_comp ;
  opj_tcd_tilecomp_t *l_tilec ;
  OPJ_UINT32 l_size_comp ;
  OPJ_UINT32 l_remaining ;
  OPJ_SIZE_T l_nb_elem ;
  OPJ_CHAR *l_src_ptr ;
  OPJ_INT32 *l_dest_ptr ;
  OPJ_INT32 *__cil_tmp15 ;
  OPJ_CHAR *__cil_tmp16 ;
  OPJ_INT32 *__cil_tmp17 ;
  OPJ_CHAR *__cil_tmp18 ;
  OPJ_INT32 *l_dest_ptr___0 ;
  OPJ_INT16 *l_src_ptr___0 ;
  OPJ_INT32 *__cil_tmp21 ;
  OPJ_INT16 *__cil_tmp22 ;
  OPJ_INT32 *__cil_tmp23 ;
  OPJ_INT16 *__cil_tmp24 ;
  OPJ_INT32 *l_src_ptr___1 ;
  OPJ_INT32 *l_dest_ptr___1 ;
  OPJ_INT32 *__cil_tmp27 ;
  OPJ_INT32 *__cil_tmp28 ;

  {
  {
#line 2617
  l_data_size = (OPJ_SIZE_T )0;
#line 2618
  l_img_comp = (opj_image_comp_t *)0;
#line 2619
  l_tilec = (opj_tcd_tilecomp_t *)0;
#line 2623
  l_data_size = opj_tcd_get_encoder_input_buffer_size(p_tcd);
  }
#line 2624
  if (l_data_size != p_src_length) {
#line 2625
    return (0);
  }
#line 2628
  l_tilec = ((p_tcd->tcd_image)->tiles)->comps;
#line 2629
  l_img_comp = (p_tcd->image)->comps;
#line 2630
  i = (OPJ_UINT32 )0;
  {
#line 2630
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2630
    if (! (i < (p_tcd->image)->numcomps)) {
#line 2630
      goto while_break;
    }
#line 2631
    l_size_comp = l_img_comp->prec >> 3;
#line 2632
    l_remaining = l_img_comp->prec & 7U;
#line 2633
    l_nb_elem = (OPJ_SIZE_T )(l_tilec->x1 - l_tilec->x0) * (OPJ_SIZE_T )(l_tilec->y1 - l_tilec->y0);
#line 2636
    if (l_remaining) {
#line 2637
      l_size_comp ++;
    }
#line 2640
    if (l_size_comp == 3U) {
#line 2641
      l_size_comp = (OPJ_UINT32 )4;
    }
#line 2645
    if (l_size_comp == 1U) {
#line 2645
      goto case_1;
    }
#line 2662
    if (l_size_comp == 2U) {
#line 2662
      goto case_2;
    }
#line 2679
    if (l_size_comp == 4U) {
#line 2679
      goto case_4;
    }
#line 2644
    goto switch_break;
    case_1: 
#line 2646
    l_src_ptr = (OPJ_CHAR *)p_src;
#line 2647
    l_dest_ptr = l_tilec->data;
#line 2649
    if (l_img_comp->sgnd) {
#line 2650
      j = (OPJ_SIZE_T )0;
      {
#line 2650
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 2650
        if (! (j < l_nb_elem)) {
#line 2650
          goto while_break___0;
        }
#line 2651
        __cil_tmp16 = l_src_ptr;
#line 2651
        l_src_ptr ++;
#line 2651
        __cil_tmp15 = l_dest_ptr;
#line 2651
        l_dest_ptr ++;
#line 2651
        *__cil_tmp15 = (OPJ_INT32 )*__cil_tmp16;
#line 2650
        j ++;
      }
      while_break___6: /* CIL Label */ ;
      }

      while_break___0: ;
    } else {
#line 2654
      j = (OPJ_SIZE_T )0;
      {
#line 2654
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 2654
        if (! (j < l_nb_elem)) {
#line 2654
          goto while_break___1;
        }
#line 2655
        __cil_tmp18 = l_src_ptr;
#line 2655
        l_src_ptr ++;
#line 2655
        __cil_tmp17 = l_dest_ptr;
#line 2655
        l_dest_ptr ++;
#line 2655
        *__cil_tmp17 = (int )*__cil_tmp18 & 255;
#line 2654
        j ++;
      }
      while_break___7: /* CIL Label */ ;
      }

      while_break___1: ;
    }
#line 2659
    p_src = (OPJ_BYTE *)l_src_ptr;
#line 2661
    goto switch_break;
    case_2: 
#line 2663
    l_dest_ptr___0 = l_tilec->data;
#line 2664
    l_src_ptr___0 = (OPJ_INT16 *)p_src;
#line 2666
    if (l_img_comp->sgnd) {
#line 2667
      j = (OPJ_SIZE_T )0;
      {
#line 2667
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 2667
        if (! (j < l_nb_elem)) {
#line 2667
          goto while_break___2;
        }
#line 2668
        __cil_tmp22 = l_src_ptr___0;
#line 2668
        l_src_ptr___0 ++;
#line 2668
        __cil_tmp21 = l_dest_ptr___0;
#line 2668
        l_dest_ptr___0 ++;
#line 2668
        *__cil_tmp21 = (OPJ_INT32 )*__cil_tmp22;
#line 2667
        j ++;
      }
      while_break___8: /* CIL Label */ ;
      }

      while_break___2: ;
    } else {
#line 2671
      j = (OPJ_SIZE_T )0;
      {
#line 2671
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 2671
        if (! (j < l_nb_elem)) {
#line 2671
          goto while_break___3;
        }
#line 2672
        __cil_tmp24 = l_src_ptr___0;
#line 2672
        l_src_ptr___0 ++;
#line 2672
        __cil_tmp23 = l_dest_ptr___0;
#line 2672
        l_dest_ptr___0 ++;
#line 2672
        *__cil_tmp23 = (int )*__cil_tmp24 & 65535;
#line 2671
        j ++;
      }
      while_break___9: /* CIL Label */ ;
      }

      while_break___3: ;
    }
#line 2676
    p_src = (OPJ_BYTE *)l_src_ptr___0;
#line 2678
    goto switch_break;
    case_4: 
#line 2680
    l_src_ptr___1 = (OPJ_INT32 *)p_src;
#line 2681
    l_dest_ptr___1 = l_tilec->data;
#line 2683
    j = (OPJ_SIZE_T )0;
    {
#line 2683
    while (1) {
      while_continue___4: /* CIL Label */ ;

#line 2683
      if (! (j < l_nb_elem)) {
#line 2683
        goto while_break___4;
      }
#line 2684
      __cil_tmp28 = l_src_ptr___1;
#line 2684
      l_src_ptr___1 ++;
#line 2684
      __cil_tmp27 = l_dest_ptr___1;
#line 2684
      l_dest_ptr___1 ++;
#line 2684
      *__cil_tmp27 = *__cil_tmp28;
#line 2683
      j ++;
    }
    while_break___10: /* CIL Label */ ;
    }

    while_break___4: 
#line 2687
    p_src = (OPJ_BYTE *)l_src_ptr___1;
#line 2689
    goto switch_break;
    switch_break: 
#line 2692
    l_img_comp ++;
#line 2693
    l_tilec ++;
#line 2630
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }

  while_break: ;
#line 2696
  return (1);
}
}
#line 2699 "/root/patron-new/39/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_is_band_empty(opj_tcd_band_t *band ) 
{ 
  int tmp ;

  {
#line 2701
  if (band->x1 - band->x0 == 0) {
#line 2701
    tmp = 1;
  } else
#line 2701
  if (band->y1 - band->y0 == 0) {
#line 2701
    tmp = 1;
  } else {
#line 2701
    tmp = 0;
  }
#line 2701
  return (tmp);
}
}
#line 2704 "/root/patron-new/39/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_is_subband_area_of_interest(opj_tcd_t *tcd , OPJ_UINT32 compno ,
                                             OPJ_UINT32 resno , OPJ_UINT32 bandno ,
                                             OPJ_UINT32 band_x0 , OPJ_UINT32 band_y0 ,
                                             OPJ_UINT32 band_x1 , OPJ_UINT32 band_y1 ) 
{ 
  OPJ_UINT32 filter_margin ;
  int tmp ;
  opj_tcd_tilecomp_t *tilec ;
  opj_image_comp_t *image_comp ;
  OPJ_UINT32 tcx0 ;
  OPJ_UINT32 __cil_tmp14 ;
  OPJ_UINT32 __cil_tmp15 ;
  OPJ_UINT32 tcy0 ;
  OPJ_UINT32 __cil_tmp17 ;
  OPJ_UINT32 __cil_tmp18 ;
  OPJ_UINT32 tcx1 ;
  OPJ_UINT32 __cil_tmp20 ;
  OPJ_UINT32 __cil_tmp21 ;
  OPJ_UINT32 tcy1 ;
  OPJ_UINT32 __cil_tmp23 ;
  OPJ_UINT32 __cil_tmp24 ;
  OPJ_UINT32 nb ;
  OPJ_UINT32 tmp___0 ;
  OPJ_UINT32 x0b ;
  OPJ_UINT32 y0b ;
  OPJ_UINT32 tbx0 ;
  OPJ_UINT32 __cil_tmp30 ;
  unsigned int tmp___1 ;
  OPJ_UINT32 tmp___2 ;
  OPJ_UINT32 tby0 ;
  OPJ_UINT32 __cil_tmp34 ;
  unsigned int tmp___3 ;
  OPJ_UINT32 tmp___4 ;
  OPJ_UINT32 tbx1 ;
  OPJ_UINT32 __cil_tmp38 ;
  unsigned int tmp___5 ;
  OPJ_UINT32 tmp___6 ;
  OPJ_UINT32 tby1 ;
  OPJ_UINT32 __cil_tmp42 ;
  unsigned int tmp___7 ;
  OPJ_UINT32 tmp___8 ;
  OPJ_BOOL intersects ;
  int tmp___9 ;

  {
#line 2721
  if (((tcd->tcp)->tccps + compno)->qmfbid == 1U) {
#line 2721
    tmp = 2;
  } else {
#line 2721
    tmp = 3;
  }
  {
#line 2721
  filter_margin = (OPJ_UINT32 )tmp;
#line 2722
  tilec = ((tcd->tcd_image)->tiles)->comps + compno;
#line 2723
  image_comp = (tcd->image)->comps + compno;
#line 2726
  __cil_tmp14 = opj_uint_ceildiv(tcd->win_x0, image_comp->dx);
#line 2726
  __cil_tmp15 = opj_uint_max((OPJ_UINT32 )tilec->x0, __cil_tmp14);
#line 2726
  tcx0 = __cil_tmp15;
#line 2729
  __cil_tmp17 = opj_uint_ceildiv(tcd->win_y0, image_comp->dy);
#line 2729
  __cil_tmp18 = opj_uint_max((OPJ_UINT32 )tilec->y0, __cil_tmp17);
#line 2729
  tcy0 = __cil_tmp18;
#line 2732
  __cil_tmp20 = opj_uint_ceildiv(tcd->win_x1, image_comp->dx);
#line 2732
  __cil_tmp21 = opj_uint_min((OPJ_UINT32 )tilec->x1, __cil_tmp20);
#line 2732
  tcx1 = __cil_tmp21;
#line 2735
  __cil_tmp23 = opj_uint_ceildiv(tcd->win_y1, image_comp->dy);
#line 2735
  __cil_tmp24 = opj_uint_min((OPJ_UINT32 )tilec->y1, __cil_tmp23);
#line 2735
  tcy1 = __cil_tmp24;
  }
#line 2739
  if (resno == 0U) {
#line 2739
    tmp___0 = tilec->numresolutions - 1U;
  } else {
#line 2739
    tmp___0 = tilec->numresolutions - resno;
  }
#line 2739
  nb = tmp___0;
#line 2744
  x0b = bandno & 1U;
#line 2745
  y0b = bandno >> 1;
#line 2746
  if (nb == 0U) {
#line 2746
    tmp___2 = tcx0;
  } else {
#line 2746
    if (tcx0 <= (1U << (nb - 1U)) * x0b) {
#line 2746
      tmp___1 = 0U;
    } else {
      {
#line 2746
      __cil_tmp30 = opj_uint_ceildivpow2(tcx0 - (1U << (nb - 1U)) * x0b, nb);
#line 2746
      tmp___1 = __cil_tmp30;
      }
    }
#line 2746
    tmp___2 = tmp___1;
  }
#line 2746
  tbx0 = tmp___2;
#line 2749
  if (nb == 0U) {
#line 2749
    tmp___4 = tcy0;
  } else {
#line 2749
    if (tcy0 <= (1U << (nb - 1U)) * y0b) {
#line 2749
      tmp___3 = 0U;
    } else {
      {
#line 2749
      __cil_tmp34 = opj_uint_ceildivpow2(tcy0 - (1U << (nb - 1U)) * y0b, nb);
#line 2749
      tmp___3 = __cil_tmp34;
      }
    }
#line 2749
    tmp___4 = tmp___3;
  }
#line 2749
  tby0 = tmp___4;
#line 2752
  if (nb == 0U) {
#line 2752
    tmp___6 = tcx1;
  } else {
#line 2752
    if (tcx1 <= (1U << (nb - 1U)) * x0b) {
#line 2752
      tmp___5 = 0U;
    } else {
      {
#line 2752
      __cil_tmp38 = opj_uint_ceildivpow2(tcx1 - (1U << (nb - 1U)) * x0b, nb);
#line 2752
      tmp___5 = __cil_tmp38;
      }
    }
#line 2752
    tmp___6 = tmp___5;
  }
#line 2752
  tbx1 = tmp___6;
#line 2755
  if (nb == 0U) {
#line 2755
    tmp___8 = tcy1;
  } else {
#line 2755
    if (tcy1 <= (1U << (nb - 1U)) * y0b) {
#line 2755
      tmp___7 = 0U;
    } else {
      {
#line 2755
      __cil_tmp42 = opj_uint_ceildivpow2(tcy1 - (1U << (nb - 1U)) * y0b, nb);
#line 2755
      tmp___7 = __cil_tmp42;
      }
    }
#line 2755
    tmp___8 = tmp___7;
  }
#line 2755
  tby1 = tmp___8;
#line 2760
  if (tbx0 < filter_margin) {
#line 2761
    tbx0 = (OPJ_UINT32 )0;
  } else {
#line 2763
    tbx0 -= filter_margin;
  }
#line 2765
  if (tby0 < filter_margin) {
#line 2766
    tby0 = (OPJ_UINT32 )0;
  } else {
#line 2768
    tby0 -= filter_margin;
  }
  {
#line 2770
  tbx1 = opj_uint_adds(tbx1, filter_margin);
#line 2771
  tby1 = opj_uint_adds(tby1, filter_margin);
  }
#line 2773
  if (band_x0 < tbx1) {
#line 2773
    if (band_y0 < tby1) {
#line 2773
      if (band_x1 > tbx0) {
#line 2773
        if (band_y1 > tby0) {
#line 2773
          tmp___9 = 1;
        } else {
#line 2773
          tmp___9 = 0;
        }
      } else {
#line 2773
        tmp___9 = 0;
      }
    } else {
#line 2773
      tmp___9 = 0;
    }
  } else {
#line 2773
    tmp___9 = 0;
  }
#line 2773
  intersects = tmp___9;
#line 2782
  return (intersects);
}
}
#line 2792 "/root/patron-new/39/src/lib/openjp2/tcd.c"
static OPJ_BOOL opj_tcd_is_whole_tilecomp_decoding(opj_tcd_t *p_tcd , OPJ_UINT32 compno ) 
{ 
  opj_tcd_tilecomp_t *tilec ;
  opj_image_comp_t *image_comp ;
  OPJ_UINT32 tcx0 ;
  OPJ_UINT32 __cil_tmp6 ;
  OPJ_UINT32 __cil_tmp7 ;
  OPJ_UINT32 tcy0 ;
  OPJ_UINT32 __cil_tmp9 ;
  OPJ_UINT32 __cil_tmp10 ;
  OPJ_UINT32 tcx1 ;
  OPJ_UINT32 __cil_tmp12 ;
  OPJ_UINT32 __cil_tmp13 ;
  OPJ_UINT32 tcy1 ;
  OPJ_UINT32 __cil_tmp15 ;
  OPJ_UINT32 __cil_tmp16 ;
  OPJ_UINT32 shift ;
  int tmp ;

  {
  {
#line 2795
  tilec = ((p_tcd->tcd_image)->tiles)->comps + compno;
#line 2796
  image_comp = (p_tcd->image)->comps + compno;
#line 2799
  __cil_tmp6 = opj_uint_ceildiv(p_tcd->win_x0, image_comp->dx);
#line 2799
  __cil_tmp7 = opj_uint_max((OPJ_UINT32 )tilec->x0, __cil_tmp6);
#line 2799
  tcx0 = __cil_tmp7;
#line 2802
  __cil_tmp9 = opj_uint_ceildiv(p_tcd->win_y0, image_comp->dy);
#line 2802
  __cil_tmp10 = opj_uint_max((OPJ_UINT32 )tilec->y0, __cil_tmp9);
#line 2802
  tcy0 = __cil_tmp10;
#line 2805
  __cil_tmp12 = opj_uint_ceildiv(p_tcd->win_x1, image_comp->dx);
#line 2805
  __cil_tmp13 = opj_uint_min((OPJ_UINT32 )tilec->x1, __cil_tmp12);
#line 2805
  tcx1 = __cil_tmp13;
#line 2808
  __cil_tmp15 = opj_uint_ceildiv(p_tcd->win_y1, image_comp->dy);
#line 2808
  __cil_tmp16 = opj_uint_min((OPJ_UINT32 )tilec->y1, __cil_tmp15);
#line 2808
  tcy1 = __cil_tmp16;
#line 2812
  shift = tilec->numresolutions - tilec->minimum_num_resolutions;
  }
#line 2815
  if (tcx0 >= (OPJ_UINT32 )tilec->x0) {
#line 2815
    if (tcy0 >= (OPJ_UINT32 )tilec->y0) {
#line 2815
      if (tcx1 <= (OPJ_UINT32 )tilec->x1) {
#line 2815
        if (tcy1 <= (OPJ_UINT32 )tilec->y1) {
#line 2815
          if (shift >= 32U) {
#line 2815
            tmp = 1;
          } else
#line 2815
          if ((tcx0 - (OPJ_UINT32 )tilec->x0) >> shift == 0U) {
#line 2815
            if ((tcy0 - (OPJ_UINT32 )tilec->y0) >> shift == 0U) {
#line 2815
              if (((OPJ_UINT32 )tilec->x1 - tcx1) >> shift == 0U) {
#line 2815
                if (((OPJ_UINT32 )tilec->y1 - tcy1) >> shift == 0U) {
#line 2815
                  tmp = 1;
                } else {
#line 2815
                  tmp = 0;
                }
              } else {
#line 2815
                tmp = 0;
              }
            } else {
#line 2815
              tmp = 0;
            }
          } else {
#line 2815
            tmp = 0;
          }
        } else {
#line 2815
          tmp = 0;
        }
      } else {
#line 2815
        tmp = 0;
      }
    } else {
#line 2815
      tmp = 0;
    }
  } else {
#line 2815
    tmp = 0;
  }
#line 2815
  return (tmp);
}
}
#line 2828 "/root/patron-new/39/src/lib/openjp2/tcd.c"
opj_tcd_marker_info_t *opj_tcd_marker_info_create(OPJ_BOOL need_PLT ) 
{ 
  opj_tcd_marker_info_t *l_tcd_marker_info ;
  void *__cil_tmp3 ;

  {
  {
#line 2830
  __cil_tmp3 = opj_calloc((size_t )1, sizeof(opj_tcd_marker_info_t ));
#line 2830
  l_tcd_marker_info = (opj_tcd_marker_info_t *)__cil_tmp3;
  }
#line 2832
  if (! l_tcd_marker_info) {
#line 2833
    return ((opj_tcd_marker_info_t *)((void *)0));
  }
#line 2836
  l_tcd_marker_info->need_PLT = need_PLT;
#line 2838
  return (l_tcd_marker_info);
}
}
#line 2843 "/root/patron-new/39/src/lib/openjp2/tcd.c"
void opj_tcd_marker_info_destroy(opj_tcd_marker_info_t *p_tcd_marker_info ) 
{ 


  {
#line 2845
  if (p_tcd_marker_info) {
    {
#line 2846
    opj_free((void *)p_tcd_marker_info->p_packet_size);
    }
  }
#line 2849
  return;
}
}
#line 51 "/root/patron-new/39/src/lib/openjp2/t2.c"
static void opj_t2_putcommacode(opj_bio_t *bio , OPJ_INT32 n ) ;
#line 53
static OPJ_UINT32 opj_t2_getcommacode(opj_bio_t *bio ) ;
#line 59
static void opj_t2_putnumpasses(opj_bio_t *bio , OPJ_UINT32 n ) ;
#line 60
static OPJ_UINT32 opj_t2_getnumpasses(opj_bio_t *bio ) ;
#line 76
static OPJ_BOOL opj_t2_encode_packet(OPJ_UINT32 tileno , opj_tcd_tile_t *tile , opj_tcp_t *tcp ,
                                     opj_pi_iterator_t *pi , OPJ_BYTE *dest , OPJ_UINT32 *p_data_written ,
                                     OPJ_UINT32 length , opj_codestream_info_t *cstr_info ,
                                     J2K_T2_MODE p_t2_mode , opj_event_mgr_t *p_manager ) ;
#line 101
static OPJ_BOOL opj_t2_decode_packet(opj_t2_t *p_t2 , opj_tcd_tile_t *p_tile , opj_tcp_t *p_tcp ,
                                     opj_pi_iterator_t *p_pi , OPJ_BYTE *p_src , OPJ_UINT32 *p_data_read ,
                                     OPJ_UINT32 p_max_length , opj_packet_info_t *p_pack_info ,
                                     opj_event_mgr_t *p_manager ) ;
#line 111
static OPJ_BOOL opj_t2_skip_packet(opj_t2_t *p_t2 , opj_tcd_tile_t *p_tile , opj_tcp_t *p_tcp ,
                                   opj_pi_iterator_t *p_pi , OPJ_BYTE *p_src , OPJ_UINT32 *p_data_read ,
                                   OPJ_UINT32 p_max_length , opj_packet_info_t *p_pack_info ,
                                   opj_event_mgr_t *p_manager ) ;
#line 121
static OPJ_BOOL opj_t2_read_packet_header(opj_t2_t *p_t2 , opj_tcd_tile_t *p_tile ,
                                          opj_tcp_t *p_tcp , opj_pi_iterator_t *p_pi ,
                                          OPJ_BOOL *p_is_data_present , OPJ_BYTE *p_src_data ,
                                          OPJ_UINT32 *p_data_read , OPJ_UINT32 p_max_length ,
                                          opj_packet_info_t *p_pack_info , opj_event_mgr_t *p_manager ) ;
#line 132
static OPJ_BOOL opj_t2_read_packet_data(opj_t2_t *p_t2 , opj_tcd_tile_t *p_tile ,
                                        opj_pi_iterator_t *p_pi , OPJ_BYTE *p_src_data ,
                                        OPJ_UINT32 *p_data_read , OPJ_UINT32 p_max_length ,
                                        opj_packet_info_t *pack_info , opj_event_mgr_t *p_manager ) ;
#line 141
static OPJ_BOOL opj_t2_skip_packet_data(opj_t2_t *p_t2 , opj_tcd_tile_t *p_tile ,
                                        opj_pi_iterator_t *p_pi , OPJ_UINT32 *p_data_read ,
                                        OPJ_UINT32 p_max_length , opj_packet_info_t *pack_info ,
                                        opj_event_mgr_t *p_manager ) ;
#line 155
static OPJ_BOOL opj_t2_init_seg(opj_tcd_cblk_dec_t *cblk , OPJ_UINT32 index___0 ,
                                OPJ_UINT32 cblksty , OPJ_UINT32 first ) ;
#line 167 "/root/patron-new/39/src/lib/openjp2/t2.c"
static void opj_t2_putcommacode(opj_bio_t *bio , OPJ_INT32 n ) 
{ 


  {
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
#line 169
    n --;
#line 169
    if (! (n >= 0)) {
#line 169
      goto while_break;
    }
    {
#line 170
    opj_bio_write(bio, (OPJ_UINT32 )1, (OPJ_UINT32 )1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: 
  {
#line 172
  opj_bio_write(bio, (OPJ_UINT32 )0, (OPJ_UINT32 )1);
  }
#line 174
  return;
}
}
#line 175 "/root/patron-new/39/src/lib/openjp2/t2.c"
static OPJ_UINT32 opj_t2_getcommacode(opj_bio_t *bio ) 
{ 
  OPJ_UINT32 n ;
  OPJ_UINT32 __cil_tmp3 ;

  {
#line 177
  n = (OPJ_UINT32 )0;
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 178
    __cil_tmp3 = opj_bio_read(bio, (OPJ_UINT32 )1);
    }
#line 178
    if (! __cil_tmp3) {
#line 178
      goto while_break;
    }
#line 179
    n ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 181
  return (n);
}
}
#line 184 "/root/patron-new/39/src/lib/openjp2/t2.c"
static void opj_t2_putnumpasses(opj_bio_t *bio , OPJ_UINT32 n ) 
{ 


  {
#line 186
  if (n == 1U) {
    {
#line 187
    opj_bio_write(bio, (OPJ_UINT32 )0, (OPJ_UINT32 )1);
    }
  } else
#line 188
  if (n == 2U) {
    {
#line 189
    opj_bio_write(bio, (OPJ_UINT32 )2, (OPJ_UINT32 )2);
    }
  } else
#line 190
  if (n <= 5U) {
    {
#line 191
    opj_bio_write(bio, 12U | (n - 3U), (OPJ_UINT32 )4);
    }
  } else
#line 192
  if (n <= 36U) {
    {
#line 193
    opj_bio_write(bio, 480U | (n - 6U), (OPJ_UINT32 )9);
    }
  } else
#line 194
  if (n <= 164U) {
    {
#line 195
    opj_bio_write(bio, 65408U | (n - 37U), (OPJ_UINT32 )16);
    }
  }
#line 198
  return;
}
}
#line 199 "/root/patron-new/39/src/lib/openjp2/t2.c"
static OPJ_UINT32 opj_t2_getnumpasses(opj_bio_t *bio ) 
{ 
  OPJ_UINT32 n ;
  OPJ_UINT32 __cil_tmp3 ;
  OPJ_UINT32 __cil_tmp4 ;
  OPJ_UINT32 __cil_tmp7 ;

  {
  {
#line 202
  __cil_tmp3 = opj_bio_read(bio, (OPJ_UINT32 )1);
  }
#line 202
  if (! __cil_tmp3) {
#line 203
    return ((OPJ_UINT32 )1);
  }
  {
#line 205
  __cil_tmp4 = opj_bio_read(bio, (OPJ_UINT32 )1);
  }
#line 205
  if (! __cil_tmp4) {
#line 206
    return ((OPJ_UINT32 )2);
  }
  {
#line 208
  n = opj_bio_read(bio, (OPJ_UINT32 )2);
  }
#line 208
  if (n != 3U) {
#line 209
    return (3U + n);
  }
  {
#line 211
  n = opj_bio_read(bio, (OPJ_UINT32 )5);
  }
#line 211
  if (n != 31U) {
#line 212
    return (6U + n);
  }
  {
#line 214
  __cil_tmp7 = opj_bio_read(bio, (OPJ_UINT32 )7);
  }
#line 214
  return (37U + __cil_tmp7);
}
}
#line 219 "/root/patron-new/39/src/lib/openjp2/t2.c"
OPJ_BOOL opj_t2_encode_packets(opj_t2_t *p_t2 , OPJ_UINT32 p_tile_no , opj_tcd_tile_t *p_tile ,
                               OPJ_UINT32 p_maxlayers , OPJ_BYTE *p_dest , OPJ_UINT32 *p_data_written ,
                               OPJ_UINT32 p_max_len , opj_codestream_info_t *cstr_info ,
                               opj_tcd_marker_info_t *p_marker_info , OPJ_UINT32 p_tp_num ,
                               OPJ_INT32 p_tp_pos , OPJ_UINT32 p_pino , J2K_T2_MODE p_t2_mode ,
                               opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 l_nb_bytes ;
  OPJ_UINT32 compno ;
  OPJ_UINT32 poc ;
  opj_pi_iterator_t *l_pi ;
  opj_pi_iterator_t *l_current_pi ;
  opj_image_t *l_image ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 pocno ;
  int tmp ;
  OPJ_UINT32 l_max_comp ;
  OPJ_UINT32 tmp___0 ;
  OPJ_UINT32 l_nb_pocs ;
  OPJ_UINT32 l_comp_len ;
  OPJ_UINT32 l_tp_num ;
  OPJ_BOOL __cil_tmp32 ;
  OPJ_BOOL __cil_tmp33 ;
  OPJ_UINT32 __cil_tmp36 ;
  void *__cil_tmp37 ;
  OPJ_BOOL __cil_tmp38 ;
  OPJ_BOOL __cil_tmp39 ;
  opj_tile_info_t *info_TL ;
  opj_packet_info_t *info_PK ;
  OPJ_OFF_T tmp___3 ;

  {
#line 234
  l_current_data = p_dest;
#line 235
  l_nb_bytes = (OPJ_UINT32 )0;
#line 238
  l_pi = (opj_pi_iterator_t *)0;
#line 239
  l_current_pi = (opj_pi_iterator_t *)0;
#line 240
  l_image = p_t2->image;
#line 241
  l_cp = p_t2->cp;
#line 242
  l_tcp = l_cp->tcps + p_tile_no;
#line 243
  if ((int )l_cp->rsiz == 4) {
#line 243
    tmp = 2;
  } else {
#line 243
    tmp = 1;
  }
#line 243
  pocno = (OPJ_UINT32 )tmp;
#line 244
  if (l_cp->m_specific_param.m_enc.m_max_comp_size > 0U) {
#line 244
    tmp___0 = l_image->numcomps;
  } else {
#line 244
    tmp___0 = 1U;
  }
  {
#line 244
  l_max_comp = tmp___0;
#line 246
  l_nb_pocs = l_tcp->numpocs + 1U;
#line 248
  l_pi = opj_pi_initialise_encode(l_image, l_cp, p_tile_no, p_t2_mode);
  }
#line 249
  if (! l_pi) {
#line 250
    return (0);
  }
#line 253
  *p_data_written = (OPJ_UINT32 )0;
#line 255
  if ((unsigned int )p_t2_mode == 0U) {
#line 256
    l_current_pi = l_pi;
#line 258
    compno = (OPJ_UINT32 )0;
    {
#line 258
    while (1) {
      while_continue: /* CIL Label */ ;

#line 258
      if (! (compno < l_max_comp)) {
#line 258
        goto while_break;
      }
#line 259
      l_comp_len = (OPJ_UINT32 )0;
#line 260
      l_current_pi = l_pi;
#line 262
      poc = (OPJ_UINT32 )0;
      {
#line 262
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 262
        if (! (poc < pocno)) {
#line 262
          goto while_break___0;
        }
        {
#line 263
        l_tp_num = compno;
#line 266
        opj_pi_create_encode(l_pi, l_cp, p_tile_no, poc, l_tp_num, p_tp_pos, p_t2_mode);
        }
#line 268
        if ((int )l_current_pi->poc.prg == -1) {
          {
#line 270
          opj_pi_destroy(l_pi, l_nb_pocs);
          }
#line 271
          return (0);
        }
        {
#line 273
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 273
          __cil_tmp32 = opj_pi_next(l_current_pi);
          }
#line 273
          if (! __cil_tmp32) {
#line 273
            goto while_break___1;
          }
#line 274
          if (l_current_pi->layno < p_maxlayers) {
            {
#line 275
            l_nb_bytes = (OPJ_UINT32 )0;
#line 277
            __cil_tmp33 = opj_t2_encode_packet(p_tile_no, p_tile, l_tcp, l_current_pi,
                                               l_current_data, & l_nb_bytes, p_max_len,
                                               cstr_info, p_t2_mode, p_manager);
            }
#line 277
            if (! __cil_tmp33) {
              {
#line 282
              opj_pi_destroy(l_pi, l_nb_pocs);
              }
#line 283
              return (0);
            }
#line 286
            l_comp_len += l_nb_bytes;
#line 287
            l_current_data += l_nb_bytes;
#line 288
            p_max_len -= l_nb_bytes;
#line 290
            *p_data_written += l_nb_bytes;
          }
        }
        while_break___5: /* CIL Label */ ;
        }

        while_break___1: ;
#line 294
        if (l_cp->m_specific_param.m_enc.m_max_comp_size) {
#line 295
          if (l_comp_len > l_cp->m_specific_param.m_enc.m_max_comp_size) {
            {
#line 296
            opj_pi_destroy(l_pi, l_nb_pocs);
            }
#line 297
            return (0);
          }
        }
#line 301
        l_current_pi ++;
#line 262
        poc ++;
      }
      while_break___4: /* CIL Label */ ;
      }

      while_break___0: 
#line 258
      compno ++;
    }
    while_break___3: /* CIL Label */ ;
    }

    while_break: ;
  } else {
    {
#line 305
    opj_pi_create_encode(l_pi, l_cp, p_tile_no, p_pino, p_tp_num, p_tp_pos, p_t2_mode);
#line 308
    l_current_pi = l_pi + p_pino;
    }
#line 309
    if ((int )l_current_pi->poc.prg == -1) {
      {
#line 311
      opj_pi_destroy(l_pi, l_nb_pocs);
      }
#line 312
      return (0);
    }
#line 315
    if (p_marker_info) {
#line 315
      if (p_marker_info->need_PLT) {
        {
#line 320
        __cil_tmp36 = opj_get_encoding_packet_count(l_image, l_cp, p_tile_no);
#line 320
        __cil_tmp37 = opj_malloc((unsigned long )__cil_tmp36 * sizeof(OPJ_UINT32 ));
#line 320
        p_marker_info->p_packet_size = (OPJ_UINT32 *)__cil_tmp37;
        }
#line 322
        if ((unsigned long )p_marker_info->p_packet_size == (unsigned long )((void *)0)) {
          {
#line 323
          opj_pi_destroy(l_pi, l_nb_pocs);
          }
#line 324
          return (0);
        }
      }
    }
    {
#line 328
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 328
      __cil_tmp38 = opj_pi_next(l_current_pi);
      }
#line 328
      if (! __cil_tmp38) {
#line 328
        goto while_break___2;
      }
#line 329
      if (l_current_pi->layno < p_maxlayers) {
        {
#line 330
        l_nb_bytes = (OPJ_UINT32 )0;
#line 332
        __cil_tmp39 = opj_t2_encode_packet(p_tile_no, p_tile, l_tcp, l_current_pi,
                                           l_current_data, & l_nb_bytes, p_max_len,
                                           cstr_info, p_t2_mode, p_manager);
        }
#line 332
        if (! __cil_tmp39) {
          {
#line 335
          opj_pi_destroy(l_pi, l_nb_pocs);
          }
#line 336
          return (0);
        }
#line 339
        l_current_data += l_nb_bytes;
#line 340
        p_max_len -= l_nb_bytes;
#line 342
        *p_data_written += l_nb_bytes;
#line 344
        if (p_marker_info) {
#line 344
          if (p_marker_info->need_PLT) {
#line 345
            *(p_marker_info->p_packet_size + p_marker_info->packet_count) = l_nb_bytes;
#line 346
            (p_marker_info->packet_count) ++;
          }
        }
#line 350
        if (cstr_info) {
#line 351
          if (cstr_info->index_write) {
#line 352
            info_TL = cstr_info->tile + p_tile_no;
#line 353
            info_PK = info_TL->packet + cstr_info->packno;
#line 354
            if (! cstr_info->packno) {
#line 355
              info_PK->start_pos = (OPJ_OFF_T )(info_TL->end_header + 1);
            } else {
#line 357
              if ((int )l_cp->m_specific_param.m_enc.m_tp_on | (int )l_tcp->POC) {
#line 357
                if (info_PK->start_pos) {
#line 357
                  tmp___3 = info_PK->start_pos;
                } else {
#line 357
                  tmp___3 = (info_TL->packet + (cstr_info->packno - 1))->end_pos + 1L;
                }
              } else {
#line 357
                tmp___3 = (info_TL->packet + (cstr_info->packno - 1))->end_pos + 1L;
              }
#line 357
              info_PK->start_pos = tmp___3;
            }
#line 361
            info_PK->end_pos = (info_PK->start_pos + (long )l_nb_bytes) - 1L;
#line 362
            info_PK->end_ph_pos += info_PK->start_pos - 1L;
          }
#line 367
          (cstr_info->packno) ++;
        }
#line 370
        (p_tile->packno) ++;
      }
    }
    while_break___6: /* CIL Label */ ;
    }

    while_break___2: ;
  }
  {
#line 375
  opj_pi_destroy(l_pi, l_nb_pocs);
  }
#line 377
  return (1);
}
}
#line 385 "/root/patron-new/39/src/lib/openjp2/t2.c"
static void opj_null_jas_fprintf(FILE *file , char const   *format  , ...) 
{ 


  {
#line 390
  return;
}
}
#line 393 "/root/patron-new/39/src/lib/openjp2/t2.c"
OPJ_BOOL opj_t2_decode_packets(opj_tcd_t *tcd , opj_t2_t *p_t2 , OPJ_UINT32 p_tile_no ,
                               opj_tcd_tile_t *p_tile , OPJ_BYTE *p_src , OPJ_UINT32 *p_data_read ,
                               OPJ_UINT32 p_max_len , opj_codestream_index_t *p_cstr_index ,
                               opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BYTE *l_current_data ;
  opj_pi_iterator_t *l_pi ;
  OPJ_UINT32 pino ;
  opj_image_t *l_image ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 l_nb_bytes_read ;
  OPJ_UINT32 l_nb_pocs ;
  opj_pi_iterator_t *l_current_pi ;
  opj_packet_info_t *l_pack_info ;
  opj_image_comp_t *l_img_comp ;
  OPJ_BOOL *first_pass_failed ;
  void *__cil_tmp23 ;
  OPJ_BOOL __cil_tmp24 ;
  OPJ_BOOL skip_packet ;
  OPJ_UINT32 bandno ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *prec ;
  OPJ_BOOL __cil_tmp31 ;
  OPJ_BOOL __cil_tmp32 ;
  OPJ_BOOL __cil_tmp34 ;

  {
  {
#line 403
  l_current_data = p_src;
#line 404
  l_pi = (opj_pi_iterator_t *)0;
#line 406
  l_image = p_t2->image;
#line 407
  l_cp = p_t2->cp;
#line 408
  l_tcp = (p_t2->cp)->tcps + p_tile_no;
#line 410
  l_nb_pocs = l_tcp->numpocs + 1U;
#line 411
  l_current_pi = (opj_pi_iterator_t *)0;
#line 416
  l_pack_info = (opj_packet_info_t *)0;
#line 417
  l_img_comp = (opj_image_comp_t *)0;
#line 428
  l_pi = opj_pi_create_decode(l_image, l_cp, p_tile_no);
  }
#line 429
  if (! l_pi) {
#line 430
    return (0);
  }
#line 434
  l_current_pi = l_pi;
#line 436
  pino = (OPJ_UINT32 )0;
  {
#line 436
  while (1) {
    while_continue: /* CIL Label */ ;

#line 436
    if (! (pino <= l_tcp->numpocs)) {
#line 436
      goto while_break;
    }
#line 443
    first_pass_failed = (OPJ_BOOL *)((void *)0);
#line 445
    if ((int )l_current_pi->poc.prg == -1) {
      {
#line 447
      opj_pi_destroy(l_pi, l_nb_pocs);
      }
#line 448
      return (0);
    }
    {
#line 451
    __cil_tmp23 = opj_malloc((unsigned long )l_image->numcomps * sizeof(OPJ_BOOL ));
#line 451
    first_pass_failed = (OPJ_BOOL *)__cil_tmp23;
    }
#line 452
    if (! first_pass_failed) {
      {
#line 453
      opj_pi_destroy(l_pi, l_nb_pocs);
      }
#line 454
      return (0);
    }
    {
#line 456
    memset((void *)first_pass_failed, 1, (unsigned long )l_image->numcomps * sizeof(OPJ_BOOL ));
    }
    {
#line 458
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 458
      __cil_tmp24 = opj_pi_next(l_current_pi);
      }
#line 458
      if (! __cil_tmp24) {
#line 458
        goto while_break___0;
      }
      {
#line 459
      skip_packet = 0;
#line 460
      opj_null_jas_fprintf(stderr, "packet offset=00000166 prg=%d cmptno=%02d rlvlno=%02d prcno=%03d lyrno=%02d\n\nU",
                           (int )l_current_pi->poc.prg1, l_current_pi->compno, l_current_pi->resno,
                           l_current_pi->precno, l_current_pi->layno);
      }
#line 467
      if (l_current_pi->layno >= l_tcp->num_layers_to_decode) {
#line 468
        skip_packet = 1;
      } else
#line 472
      if (l_current_pi->resno >= (p_tile->comps + l_current_pi->compno)->minimum_num_resolutions) {
#line 474
        skip_packet = 1;
      } else {
#line 479
        tilec = p_tile->comps + l_current_pi->compno;
#line 480
        res = tilec->resolutions + l_current_pi->resno;
#line 482
        skip_packet = 1;
#line 483
        bandno = (OPJ_UINT32 )0;
        {
#line 483
        while (1) {
          while_continue___1: /* CIL Label */ ;

#line 483
          if (! (bandno < res->numbands)) {
#line 483
            goto while_break___1;
          }
          {
#line 484
          band = & res->bands[bandno];
#line 485
          prec = band->precincts + l_current_pi->precno;
#line 487
          __cil_tmp31 = opj_tcd_is_subband_area_of_interest(tcd, l_current_pi->compno,
                                                            l_current_pi->resno, band->bandno,
                                                            (OPJ_UINT32 )prec->x0,
                                                            (OPJ_UINT32 )prec->y0,
                                                            (OPJ_UINT32 )prec->x1,
                                                            (OPJ_UINT32 )prec->y1);
          }
#line 487
          if (__cil_tmp31) {
#line 495
            skip_packet = 0;
#line 496
            goto while_break___1;
          }
#line 483
          bandno ++;
        }
        while_break___4: /* CIL Label */ ;
        }

        while_break___1: ;
      }
#line 506
      if (! skip_packet) {
        {
#line 507
        l_nb_bytes_read = (OPJ_UINT32 )0;
#line 509
        *(first_pass_failed + l_current_pi->compno) = 0;
#line 511
        __cil_tmp32 = opj_t2_decode_packet(p_t2, p_tile, l_tcp, l_current_pi, l_current_data,
                                           & l_nb_bytes_read, p_max_len, l_pack_info,
                                           p_manager);
        }
#line 511
        if (! __cil_tmp32) {
          {
#line 513
          opj_pi_destroy(l_pi, l_nb_pocs);
#line 514
          opj_free((void *)first_pass_failed);
          }
#line 515
          return (0);
        }
        {
#line 518
        l_img_comp = l_image->comps + l_current_pi->compno;
#line 519
        l_img_comp->resno_decoded = opj_uint_max(l_current_pi->resno, l_img_comp->resno_decoded);
        }
      } else {
        {
#line 522
        l_nb_bytes_read = (OPJ_UINT32 )0;
#line 523
        __cil_tmp34 = opj_t2_skip_packet(p_t2, p_tile, l_tcp, l_current_pi, l_current_data,
                                         & l_nb_bytes_read, p_max_len, l_pack_info,
                                         p_manager);
        }
#line 523
        if (! __cil_tmp34) {
          {
#line 525
          opj_pi_destroy(l_pi, l_nb_pocs);
#line 526
          opj_free((void *)first_pass_failed);
          }
#line 527
          return (0);
        }
      }
#line 531
      if (*(first_pass_failed + l_current_pi->compno)) {
#line 532
        l_img_comp = l_image->comps + l_current_pi->compno;
#line 533
        if (l_img_comp->resno_decoded == 0U) {
#line 534
          l_img_comp->resno_decoded = (p_tile->comps + l_current_pi->compno)->minimum_num_resolutions - 1U;
        }
      }
#line 539
      l_current_data += l_nb_bytes_read;
#line 540
      p_max_len -= l_nb_bytes_read;
    }
    while_break___3: /* CIL Label */ ;
    }

    while_break___0: 
    {
#line 571
    l_current_pi ++;
#line 573
    opj_free((void *)first_pass_failed);
#line 436
    pino ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }

  while_break: 
  {
#line 586
  opj_pi_destroy(l_pi, l_nb_pocs);
#line 587
  *p_data_read = (OPJ_UINT32 )(l_current_data - p_src);
  }
#line 588
  return (1);
}
}
#line 600 "/root/patron-new/39/src/lib/openjp2/t2.c"
opj_t2_t *opj_t2_create(opj_image_t *p_image , opj_cp_t *p_cp ) 
{ 
  opj_t2_t *l_t2 ;
  void *__cil_tmp4 ;

  {
  {
#line 603
  __cil_tmp4 = opj_calloc((size_t )1, sizeof(opj_t2_t ));
#line 603
  l_t2 = (opj_t2_t *)__cil_tmp4;
  }
#line 604
  if (! l_t2) {
#line 605
    return ((opj_t2_t *)((void *)0));
  }
#line 608
  l_t2->image = p_image;
#line 609
  l_t2->cp = p_cp;
#line 611
  return (l_t2);
}
}
#line 614 "/root/patron-new/39/src/lib/openjp2/t2.c"
void opj_t2_destroy(opj_t2_t *t2 ) 
{ 


  {
#line 616
  if (t2) {
    {
#line 617
    opj_free((void *)t2);
    }
  }
#line 620
  return;
}
}
#line 621 "/root/patron-new/39/src/lib/openjp2/t2.c"
static OPJ_BOOL opj_t2_decode_packet(opj_t2_t *p_t2 , opj_tcd_tile_t *p_tile , opj_tcp_t *p_tcp ,
                                     opj_pi_iterator_t *p_pi , OPJ_BYTE *p_src , OPJ_UINT32 *p_data_read ,
                                     OPJ_UINT32 p_max_length , opj_packet_info_t *p_pack_info ,
                                     opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL l_read_data ;
  OPJ_UINT32 l_nb_bytes_read ;
  OPJ_UINT32 l_nb_total_bytes_read ;
  OPJ_BOOL __cil_tmp13 ;
  OPJ_BOOL __cil_tmp14 ;

  {
  {
#line 632
  l_nb_bytes_read = (OPJ_UINT32 )0;
#line 633
  l_nb_total_bytes_read = (OPJ_UINT32 )0;
#line 635
  *p_data_read = (OPJ_UINT32 )0;
#line 637
  __cil_tmp13 = opj_t2_read_packet_header(p_t2, p_tile, p_tcp, p_pi, & l_read_data,
                                          p_src, & l_nb_bytes_read, p_max_length,
                                          p_pack_info, p_manager);
  }
#line 637
  if (! __cil_tmp13) {
#line 639
    return (0);
  }
#line 642
  p_src += l_nb_bytes_read;
#line 643
  l_nb_total_bytes_read += l_nb_bytes_read;
#line 644
  p_max_length -= l_nb_bytes_read;
#line 647
  if (l_read_data) {
    {
#line 648
    l_nb_bytes_read = (OPJ_UINT32 )0;
#line 650
    __cil_tmp14 = opj_t2_read_packet_data(p_t2, p_tile, p_pi, p_src, & l_nb_bytes_read,
                                          p_max_length, p_pack_info, p_manager);
    }
#line 650
    if (! __cil_tmp14) {
#line 652
      return (0);
    }
#line 655
    l_nb_total_bytes_read += l_nb_bytes_read;
  }
#line 658
  *p_data_read = l_nb_total_bytes_read;
#line 660
  return (1);
}
}
#line 663 "/root/patron-new/39/src/lib/openjp2/t2.c"
static OPJ_BOOL opj_t2_encode_packet(OPJ_UINT32 tileno , opj_tcd_tile_t *tile , opj_tcp_t *tcp ,
                                     opj_pi_iterator_t *pi , OPJ_BYTE *dest , OPJ_UINT32 *p_data_written ,
                                     OPJ_UINT32 length , opj_codestream_info_t *cstr_info ,
                                     J2K_T2_MODE p_t2_mode , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 bandno ;
  OPJ_UINT32 cblkno ;
  OPJ_BYTE *c ;
  OPJ_UINT32 l_nb_bytes ;
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 precno ;
  OPJ_UINT32 layno ;
  OPJ_UINT32 l_nb_blocks ;
  opj_tcd_band_t *band ;
  opj_tcd_cblk_enc_t *cblk ;
  opj_tcd_pass_t *pass ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *res ;
  opj_bio_t *bio ;
  OPJ_BOOL packet_empty ;
  opj_tcd_precinct_t *prc ;
  OPJ_BOOL __cil_tmp28 ;
  int tmp ;
  opj_tcd_precinct_t *prc___0 ;
  OPJ_BOOL __cil_tmp32 ;
  opj_tcd_layer_t *layer ;
  opj_tcd_layer_t *layer___0 ;
  OPJ_UINT32 increment ;
  OPJ_UINT32 nump ;
  OPJ_UINT32 len ;
  OPJ_UINT32 passno ;
  OPJ_UINT32 l_nb_passes ;
  OPJ_INT32 __cil_tmp40 ;
  OPJ_INT32 __cil_tmp41 ;
  OPJ_INT32 __cil_tmp42 ;
  OPJ_INT32 __cil_tmp44 ;
  OPJ_BOOL __cil_tmp46 ;
  ptrdiff_t __cil_tmp47 ;
  opj_packet_info_t *info_PK ;
  opj_tcd_precinct_t *prc___1 ;
  OPJ_BOOL __cil_tmp50 ;
  opj_tcd_layer_t *layer___1 ;
  opj_packet_info_t *info_PK___0 ;
  OPJ_UINT32 __cil_tmp53 ;

  {
#line 675
  c = dest;
#line 677
  compno = pi->compno;
#line 678
  resno = pi->resno;
#line 679
  precno = pi->precno;
#line 680
  layno = pi->layno;
#line 682
  band = (opj_tcd_band_t *)0;
#line 683
  cblk = (opj_tcd_cblk_enc_t *)0;
#line 684
  pass = (opj_tcd_pass_t *)0;
#line 686
  tilec = tile->comps + compno;
#line 687
  res = tilec->resolutions + resno;
#line 689
  bio = (opj_bio_t *)0;
#line 693
  packet_empty = 0;
#line 705
  if (tcp->csty & 2U) {
#line 706
    if (length < 6U) {
#line 707
      if ((unsigned int )p_t2_mode == 1U) {
        {
#line 708
        opj_event_msg(p_manager, 1, "opj_t2_encode_packet(): only %u bytes remaining in output buffer. %u needed.\n\325\235\004]U",
                      length, 6);
        }
      }
#line 713
      return (0);
    }
#line 715
    *(c + 0) = (OPJ_BYTE )255;
#line 716
    *(c + 1) = (OPJ_BYTE )145;
#line 717
    *(c + 2) = (OPJ_BYTE )0;
#line 718
    *(c + 3) = (OPJ_BYTE )4;
#line 723
    *(c + 4) = (OPJ_BYTE )((tile->packno >> 8) & 255U);
#line 724
    *(c + 5) = (OPJ_BYTE )(tile->packno & 255U);
#line 726
    c += 6;
#line 727
    length -= 6U;
  }
#line 731
  if (! layno) {
#line 732
    band = res->bands;
#line 734
    bandno = (OPJ_UINT32 )0;
    {
#line 734
    while (1) {
      while_continue___8: /* CIL Label */ ;

      while_continue: ;
#line 734
      if (! (bandno < res->numbands)) {
#line 734
        goto while_break;
      }
      {
#line 738
      __cil_tmp28 = opj_tcd_is_band_empty(band);
      }
#line 738
      if (__cil_tmp28) {
#line 739
        goto while_continue;
      }
      {
#line 742
      prc = band->precincts + precno;
#line 743
      opj_tgt_reset(prc->incltree);
#line 744
      opj_tgt_reset(prc->imsbtree);
#line 746
      l_nb_blocks = prc->cw * prc->ch;
#line 747
      cblkno = (OPJ_UINT32 )0;
      }
      {
#line 747
      while (1) {
        while_continue___9: /* CIL Label */ ;

#line 747
        if (! (cblkno < l_nb_blocks)) {
#line 747
          goto while_break___0;
        }
        {
#line 748
        cblk = prc->cblks.enc + cblkno;
#line 750
        cblk->numpasses = (OPJ_UINT32 )0;
#line 751
        opj_tgt_setvalue(prc->imsbtree, cblkno, band->numbps - (OPJ_INT32 )cblk->numbps);
#line 747
        cblkno ++;
        }
      }
      while_break___9: /* CIL Label */ ;
      }

      while_break___0: 
#line 734
      band ++;
#line 734
      bandno ++;
    }
    while_break___8: /* CIL Label */ ;
    }

    while_break: ;
  }
  {
#line 756
  bio = opj_bio_create();
  }
#line 757
  if (! bio) {
#line 759
    return (0);
  }
  {
#line 761
  opj_bio_init_enc(bio, c, length);
  }
#line 796
  if (packet_empty) {
#line 796
    tmp = 0;
  } else {
#line 796
    tmp = 1;
  }
  {
#line 796
  opj_bio_write(bio, (OPJ_UINT32 )tmp, (OPJ_UINT32 )1);
#line 799
  band = res->bands;
#line 800
  bandno = (OPJ_UINT32 )0;
  }
  {
#line 800
  while (1) {
    while_continue___10: /* CIL Label */ ;

    while_continue___1: ;
#line 800
    if (! packet_empty) {
#line 800
      if (! (bandno < res->numbands)) {
#line 800
        goto while_break___1;
      }
    } else {
#line 800
      goto while_break___1;
    }
    {
#line 805
    __cil_tmp32 = opj_tcd_is_band_empty(band);
    }
#line 805
    if (__cil_tmp32) {
#line 806
      goto while_continue___1;
    }
#line 809
    prc___0 = band->precincts + precno;
#line 810
    l_nb_blocks = prc___0->cw * prc___0->ch;
#line 811
    cblk = prc___0->cblks.enc;
#line 813
    cblkno = (OPJ_UINT32 )0;
    {
#line 813
    while (1) {
      while_continue___11: /* CIL Label */ ;

#line 813
      if (! (cblkno < l_nb_blocks)) {
#line 813
        goto while_break___2;
      }
#line 814
      layer = cblk->layers + layno;
#line 816
      if (! cblk->numpasses) {
#line 816
        if (layer->numpasses) {
          {
#line 817
          opj_tgt_setvalue(prc___0->incltree, cblkno, (OPJ_INT32 )layno);
          }
        }
      }
#line 820
      cblk ++;
#line 813
      cblkno ++;
    }
    while_break___11: /* CIL Label */ ;
    }

    while_break___2: 
#line 823
    cblk = prc___0->cblks.enc;
#line 824
    cblkno = (OPJ_UINT32 )0;
    {
#line 824
    while (1) {
      while_continue___12: /* CIL Label */ ;

      while_continue___3: ;
#line 824
      if (! (cblkno < l_nb_blocks)) {
#line 824
        goto while_break___3;
      }
#line 825
      layer___0 = cblk->layers + layno;
#line 826
      increment = (OPJ_UINT32 )0;
#line 827
      nump = (OPJ_UINT32 )0;
#line 828
      len = (OPJ_UINT32 )0;
#line 832
      if (! cblk->numpasses) {
        {
#line 833
        opj_tgt_encode(bio, prc___0->incltree, cblkno, (OPJ_INT32 )(layno + 1U));
        }
      } else {
        {
#line 835
        opj_bio_write(bio, (OPJ_UINT32 )(layer___0->numpasses != 0U), (OPJ_UINT32 )1);
        }
      }
#line 839
      if (! layer___0->numpasses) {
#line 840
        cblk ++;
#line 841
        goto while_continue___3;
      }
#line 845
      if (! cblk->numpasses) {
        {
#line 846
        cblk->numlenbits = (OPJ_UINT32 )3;
#line 847
        opj_tgt_encode(bio, prc___0->imsbtree, cblkno, 999);
        }
      }
      {
#line 851
      opj_t2_putnumpasses(bio, layer___0->numpasses);
#line 852
      l_nb_passes = cblk->numpasses + layer___0->numpasses;
#line 853
      pass = cblk->passes + cblk->numpasses;
#line 856
      passno = cblk->numpasses;
      }
      {
#line 856
      while (1) {
        while_continue___13: /* CIL Label */ ;

#line 856
        if (! (passno < l_nb_passes)) {
#line 856
          goto while_break___4;
        }
#line 857
        nump ++;
#line 858
        len += pass->len;
#line 860
        if ((int )pass->term) {
          _L: 
          {
#line 861
          __cil_tmp41 = opj_int_floorlog2((OPJ_INT32 )nump);
#line 861
          __cil_tmp40 = opj_int_floorlog2((OPJ_INT32 )len);
#line 861
          __cil_tmp42 = opj_int_max((OPJ_INT32 )increment, (__cil_tmp40 + 1) - ((OPJ_INT32 )cblk->numlenbits + __cil_tmp41));
#line 861
          increment = (OPJ_UINT32 )__cil_tmp42;
#line 864
          len = (OPJ_UINT32 )0;
#line 865
          nump = (OPJ_UINT32 )0;
          }
        } else
#line 860
        if (passno == (cblk->numpasses + layer___0->numpasses) - 1U) {
#line 860
          goto _L;
        }
#line 868
        pass ++;
#line 856
        passno ++;
      }
      while_break___13: /* CIL Label */ ;
      }

      while_break___4: 
      {
#line 870
      opj_t2_putcommacode(bio, (OPJ_INT32 )increment);
#line 873
      cblk->numlenbits += increment;
#line 875
      pass = cblk->passes + cblk->numpasses;
#line 877
      passno = cblk->numpasses;
      }
      {
#line 877
      while (1) {
        while_continue___14: /* CIL Label */ ;

#line 877
        if (! (passno < l_nb_passes)) {
#line 877
          goto while_break___5;
        }
#line 878
        nump ++;
#line 879
        len += pass->len;
#line 881
        if ((int )pass->term) {
          {
#line 882
          __cil_tmp44 = opj_int_floorlog2((OPJ_INT32 )nump);
#line 882
          opj_bio_write(bio, len, cblk->numlenbits + (OPJ_UINT32 )__cil_tmp44);
#line 884
          len = (OPJ_UINT32 )0;
#line 885
          nump = (OPJ_UINT32 )0;
          }
        } else
#line 881
        if (passno == (cblk->numpasses + layer___0->numpasses) - 1U) {
          {
#line 882
          __cil_tmp44 = opj_int_floorlog2((OPJ_INT32 )nump);
#line 882
          opj_bio_write(bio, len, cblk->numlenbits + (OPJ_UINT32 )__cil_tmp44);
#line 884
          len = (OPJ_UINT32 )0;
#line 885
          nump = (OPJ_UINT32 )0;
          }
        }
#line 887
        pass ++;
#line 877
        passno ++;
      }
      while_break___14: /* CIL Label */ ;
      }

      while_break___5: 
#line 890
      cblk ++;
#line 824
      cblkno ++;
    }
    while_break___12: /* CIL Label */ ;
    }

    while_break___3: 
#line 801
    band ++;
#line 801
    bandno ++;
  }
  while_break___10: /* CIL Label */ ;
  }

  while_break___1: 
  {
#line 894
  __cil_tmp46 = opj_bio_flush(bio);
  }
#line 894
  if (! __cil_tmp46) {
    {
#line 895
    opj_bio_destroy(bio);
    }
#line 896
    return (0);
  }
  {
#line 899
  __cil_tmp47 = opj_bio_numbytes(bio);
#line 899
  l_nb_bytes = (OPJ_UINT32 )__cil_tmp47;
#line 900
  c += l_nb_bytes;
#line 901
  length -= l_nb_bytes;
#line 903
  opj_bio_destroy(bio);
  }
#line 906
  if (tcp->csty & 4U) {
#line 907
    if (length < 2U) {
#line 908
      if ((unsigned int )p_t2_mode == 1U) {
        {
#line 909
        opj_event_msg(p_manager, 1, "opj_t2_encode_packet(): only %u bytes remaining in output buffer. %u needed.\n",
                      length, 2);
        }
      }
#line 914
      return (0);
    }
#line 916
    *(c + 0) = (OPJ_BYTE )255;
#line 917
    *(c + 1) = (OPJ_BYTE )146;
#line 918
    c += 2;
#line 919
    length -= 2U;
  }
#line 926
  if (cstr_info) {
#line 926
    if (cstr_info->index_write) {
#line 927
      info_PK = (cstr_info->tile + tileno)->packet + cstr_info->packno;
#line 928
      info_PK->end_ph_pos = (OPJ_OFF_T )((OPJ_INT32 )(c - dest));
    }
  }
#line 933
  band = res->bands;
#line 934
  bandno = (OPJ_UINT32 )0;
  {
#line 934
  while (1) {
    while_continue___15: /* CIL Label */ ;

    while_continue___6: ;
#line 934
    if (! packet_empty) {
#line 934
      if (! (bandno < res->numbands)) {
#line 934
        goto while_break___6;
      }
    } else {
#line 934
      goto while_break___6;
    }
    {
#line 938
    __cil_tmp50 = opj_tcd_is_band_empty(band);
    }
#line 938
    if (__cil_tmp50) {
#line 939
      goto while_continue___6;
    }
#line 942
    prc___1 = band->precincts + precno;
#line 943
    l_nb_blocks = prc___1->cw * prc___1->ch;
#line 944
    cblk = prc___1->cblks.enc;
#line 946
    cblkno = (OPJ_UINT32 )0;
    {
#line 946
    while (1) {
      while_continue___16: /* CIL Label */ ;

      while_continue___7: ;
#line 946
      if (! (cblkno < l_nb_blocks)) {
#line 946
        goto while_break___7;
      }
#line 947
      layer___1 = cblk->layers + layno;
#line 949
      if (! layer___1->numpasses) {
#line 950
        cblk ++;
#line 951
        goto while_continue___7;
      }
#line 954
      if (layer___1->len > length) {
#line 955
        if ((unsigned int )p_t2_mode == 1U) {
          {
#line 956
          opj_event_msg(p_manager, 1, "opj_t2_encode_packet(): only %u bytes remaining in output buffer. %u needed.\n",
                        length, layer___1->len);
          }
        }
#line 961
        return (0);
      }
      {
#line 964
      memcpy((void *)c, (void const   *)layer___1->data, (unsigned long )layer___1->len);
#line 965
      cblk->numpasses += layer___1->numpasses;
#line 966
      c += layer___1->len;
#line 967
      length -= layer___1->len;
      }
#line 970
      if (cstr_info) {
#line 970
        if (cstr_info->index_write) {
#line 971
          info_PK___0 = (cstr_info->tile + tileno)->packet + cstr_info->packno;
#line 972
          info_PK___0->disto += layer___1->disto;
#line 973
          if (cstr_info->D_max < info_PK___0->disto) {
#line 974
            cstr_info->D_max = info_PK___0->disto;
          }
        }
      }
#line 978
      cblk ++;
#line 946
      cblkno ++;
    }
    while_break___16: /* CIL Label */ ;
    }

    while_break___7: 
#line 934
    band ++;
#line 934
    __cil_tmp53 = bandno;
#line 934
    bandno ++;
  }
  while_break___15: /* CIL Label */ ;
  }

  while_break___6: 
#line 984
  *p_data_written += (OPJ_UINT32 )(c - dest);
#line 986
  return (1);
}
}
#line 989 "/root/patron-new/39/src/lib/openjp2/t2.c"
static OPJ_BOOL opj_t2_skip_packet(opj_t2_t *p_t2 , opj_tcd_tile_t *p_tile , opj_tcp_t *p_tcp ,
                                   opj_pi_iterator_t *p_pi , OPJ_BYTE *p_src , OPJ_UINT32 *p_data_read ,
                                   OPJ_UINT32 p_max_length , opj_packet_info_t *p_pack_info ,
                                   opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL l_read_data ;
  OPJ_UINT32 l_nb_bytes_read ;
  OPJ_UINT32 l_nb_total_bytes_read ;
  OPJ_BOOL __cil_tmp13 ;
  OPJ_BOOL __cil_tmp14 ;

  {
  {
#line 1000
  l_nb_bytes_read = (OPJ_UINT32 )0;
#line 1001
  l_nb_total_bytes_read = (OPJ_UINT32 )0;
#line 1003
  *p_data_read = (OPJ_UINT32 )0;
#line 1005
  __cil_tmp13 = opj_t2_read_packet_header(p_t2, p_tile, p_tcp, p_pi, & l_read_data,
                                          p_src, & l_nb_bytes_read, p_max_length,
                                          p_pack_info, p_manager);
  }
#line 1005
  if (! __cil_tmp13) {
#line 1007
    return (0);
  }
#line 1010
  p_src += l_nb_bytes_read;
#line 1011
  l_nb_total_bytes_read += l_nb_bytes_read;
#line 1012
  p_max_length -= l_nb_bytes_read;
#line 1015
  if (l_read_data) {
    {
#line 1016
    l_nb_bytes_read = (OPJ_UINT32 )0;
#line 1018
    __cil_tmp14 = opj_t2_skip_packet_data(p_t2, p_tile, p_pi, & l_nb_bytes_read, p_max_length,
                                          p_pack_info, p_manager);
    }
#line 1018
    if (! __cil_tmp14) {
#line 1020
      return (0);
    }
#line 1023
    l_nb_total_bytes_read += l_nb_bytes_read;
  }
#line 1025
  *p_data_read = l_nb_total_bytes_read;
#line 1027
  return (1);
}
}
#line 1031 "/root/patron-new/39/src/lib/openjp2/t2.c"
static OPJ_BOOL opj_t2_read_packet_header(opj_t2_t *p_t2 , opj_tcd_tile_t *p_tile ,
                                          opj_tcp_t *p_tcp , opj_pi_iterator_t *p_pi ,
                                          OPJ_BOOL *p_is_data_present , OPJ_BYTE *p_src_data ,
                                          OPJ_UINT32 *p_data_read , OPJ_UINT32 p_max_length ,
                                          opj_packet_info_t *p_pack_info , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 bandno ;
  OPJ_UINT32 cblkno ;
  OPJ_UINT32 l_nb_code_blocks ;
  OPJ_UINT32 l_remaining_length ;
  OPJ_UINT32 l_header_length ;
  OPJ_UINT32 *l_modified_length_ptr ;
  OPJ_BYTE *l_current_data ;
  opj_cp_t *l_cp ;
  opj_bio_t *l_bio ;
  opj_tcd_band_t *l_band ;
  opj_tcd_cblk_dec_t *l_cblk ;
  opj_tcd_resolution_t *l_res ;
  OPJ_BYTE *l_header_data ;
  OPJ_BYTE **l_header_data_start ;
  OPJ_UINT32 l_present ;
  OPJ_BOOL __cil_tmp26 ;
  opj_tcd_precinct_t *l_prc ;
  ptrdiff_t __cil_tmp30 ;
  opj_tcd_precinct_t *l_prc___0 ;
  OPJ_BOOL __cil_tmp32 ;
  OPJ_UINT32 l_included ;
  OPJ_UINT32 l_increment ;
  OPJ_UINT32 l_segno ;
  OPJ_INT32 n ;
  OPJ_UINT32 i ;
  OPJ_UINT32 __cil_tmp40 ;
  OPJ_BOOL __cil_tmp43 ;
  OPJ_BOOL __cil_tmp44 ;
  OPJ_UINT32 bit_number ;
  OPJ_INT32 __cil_tmp46 ;
  OPJ_UINT32 __cil_tmp47 ;
  OPJ_BOOL __cil_tmp49 ;
  OPJ_BOOL __cil_tmp51 ;
  ptrdiff_t __cil_tmp52 ;

  {
#line 1048
  l_modified_length_ptr = (OPJ_UINT32 *)0;
#line 1049
  l_current_data = p_src_data;
#line 1050
  l_cp = p_t2->cp;
#line 1051
  l_bio = (opj_bio_t *)0;
#line 1052
  l_band = (opj_tcd_band_t *)0;
#line 1053
  l_cblk = (opj_tcd_cblk_dec_t *)0;
#line 1054
  l_res = (p_tile->comps + p_pi->compno)->resolutions + p_pi->resno;
#line 1057
  l_header_data = (OPJ_BYTE *)0;
#line 1058
  l_header_data_start = (OPJ_BYTE **)0;
#line 1062
  if (p_pi->layno == 0U) {
#line 1063
    l_band = l_res->bands;
#line 1066
    bandno = (OPJ_UINT32 )0;
    {
#line 1066
    while (1) {
      while_continue: /* CIL Label */ ;

#line 1066
      if (! (bandno < l_res->numbands)) {
#line 1066
        goto while_break;
      }
      {
#line 1067
      __cil_tmp26 = opj_tcd_is_band_empty(l_band);
      }
#line 1067
      if (! __cil_tmp26) {
#line 1068
        l_prc = l_band->precincts + p_pi->precno;
#line 1069
        if (! ((unsigned long )p_pi->precno < (unsigned long )l_band->precincts_data_size / sizeof(opj_tcd_precinct_t ))) {
          {
#line 1071
          opj_event_msg(p_manager, 1, "Invalid precinct\n");
          }
#line 1072
          return (0);
        }
        {
#line 1076
        opj_tgt_reset(l_prc->incltree);
#line 1077
        opj_tgt_reset(l_prc->imsbtree);
#line 1078
        l_cblk = l_prc->cblks.dec;
#line 1080
        l_nb_code_blocks = l_prc->cw * l_prc->ch;
#line 1081
        cblkno = (OPJ_UINT32 )0;
        }
        {
#line 1081
        while (1) {
          while_continue___3: /* CIL Label */ ;

#line 1081
          if (! (cblkno < l_nb_code_blocks)) {
#line 1081
            goto while_break___0;
          }
#line 1082
          l_cblk->numsegs = (OPJ_UINT32 )0;
#line 1083
          l_cblk->real_num_segs = (OPJ_UINT32 )0;
#line 1084
          l_cblk ++;
#line 1081
          cblkno ++;
        }
        while_break___6: /* CIL Label */ ;
        }

        while_break___0: ;
      }
#line 1088
      l_band ++;
#line 1066
      bandno ++;
    }
    while_break___5: /* CIL Label */ ;
    }

    while_break: ;
  }
#line 1094
  if (p_tcp->csty & 2U) {
#line 1095
    if (p_max_length < 6U) {
      {
#line 1096
      opj_event_msg(p_manager, 2, "Not enough space for expected SOP marker\n");
      }
    } else
#line 1098
    if ((int )*l_current_data != 255) {
      {
#line 1099
      opj_event_msg(p_manager, 2, "Expected SOP marker\n");
      }
    } else
#line 1098
    if ((int )*(l_current_data + 1) != 145) {
      {
#line 1099
      opj_event_msg(p_manager, 2, "Expected SOP marker\n");
      }
    } else {
#line 1101
      l_current_data += 6;
    }
  }
  {
#line 1114
  l_bio = opj_bio_create();
  }
#line 1115
  if (! l_bio) {
#line 1116
    return (0);
  }
#line 1119
  if ((int )l_cp->ppm == 1) {
#line 1120
    l_header_data_start = & l_cp->ppm_data;
#line 1121
    l_header_data = *l_header_data_start;
#line 1122
    l_modified_length_ptr = & l_cp->ppm_len;
  } else
#line 1124
  if ((int )p_tcp->ppt == 1) {
#line 1125
    l_header_data_start = & p_tcp->ppt_data;
#line 1126
    l_header_data = *l_header_data_start;
#line 1127
    l_modified_length_ptr = & p_tcp->ppt_len;
  } else {
#line 1129
    l_header_data_start = & l_current_data;
#line 1130
    l_header_data = *l_header_data_start;
#line 1131
    l_remaining_length = (OPJ_UINT32 )((p_src_data + p_max_length) - l_header_data);
#line 1132
    l_modified_length_ptr = & l_remaining_length;
  }
  {
#line 1135
  opj_bio_init_dec(l_bio, l_header_data, *l_modified_length_ptr);
#line 1137
  l_present = opj_bio_read(l_bio, (OPJ_UINT32 )1);
#line 1138
  opj_null_jas_fprintf(stderr, "present=%d \n]U", l_present);
  }
#line 1139
  if (! l_present) {
    {
#line 1141
    opj_bio_inalign(l_bio);
#line 1142
    __cil_tmp30 = opj_bio_numbytes(l_bio);
#line 1142
    l_header_data += __cil_tmp30;
#line 1143
    opj_bio_destroy(l_bio);
    }
#line 1146
    if (p_tcp->csty & 4U) {
#line 1147
      if (*l_modified_length_ptr - (OPJ_UINT32 )(l_header_data - *l_header_data_start) < 2U) {
        {
#line 1149
        opj_event_msg(p_manager, 2, "Not enough space for expected EPH marker\n");
        }
      } else
#line 1151
      if ((int )*l_header_data != 255) {
        {
#line 1152
        opj_event_msg(p_manager, 2, "Expected EPH marker\n");
        }
      } else
#line 1151
      if ((int )*(l_header_data + 1) != 146) {
        {
#line 1152
        opj_event_msg(p_manager, 2, "Expected EPH marker\n");
        }
      } else {
#line 1154
        l_header_data += 2;
      }
    }
#line 1158
    l_header_length = (OPJ_UINT32 )(l_header_data - *l_header_data_start);
#line 1159
    *l_modified_length_ptr -= l_header_length;
#line 1160
    *l_header_data_start += l_header_length;
#line 1165
    if (p_pack_info) {
#line 1166
      p_pack_info->end_ph_pos = (OPJ_OFF_T )((OPJ_INT32 )(l_current_data - p_src_data));
    }
#line 1170
    *p_is_data_present = 0;
#line 1171
    *p_data_read = (OPJ_UINT32 )(l_current_data - p_src_data);
#line 1172
    return (1);
  }
#line 1175
  l_band = l_res->bands;
#line 1176
  bandno = (OPJ_UINT32 )0;
  {
#line 1176
  while (1) {
    while_continue___4: /* CIL Label */ ;

    while_continue___1: ;
#line 1176
    if (! (bandno < l_res->numbands)) {
#line 1176
      goto while_break___1;
    }
    {
#line 1177
    l_prc___0 = l_band->precincts + p_pi->precno;
#line 1179
    __cil_tmp32 = opj_tcd_is_band_empty(l_band);
    }
#line 1179
    if (__cil_tmp32) {
#line 1180
      goto while_continue___1;
    }
#line 1183
    l_nb_code_blocks = l_prc___0->cw * l_prc___0->ch;
#line 1184
    l_cblk = l_prc___0->cblks.dec;
#line 1185
    cblkno = (OPJ_UINT32 )0;
    {
#line 1185
    while (1) {
      while_continue___5: /* CIL Label */ ;

      while_continue___2: ;
#line 1185
      if (! (cblkno < l_nb_code_blocks)) {
#line 1185
        goto while_break___2;
      }
#line 1190
      if (! l_cblk->numsegs) {
        {
#line 1191
        l_included = opj_tgt_decode(l_bio, l_prc___0->incltree, cblkno, (OPJ_INT32 )(p_pi->layno + 1U));
        }
      } else {
        {
#line 1195
        l_included = opj_bio_read(l_bio, (OPJ_UINT32 )1);
        }
      }
#line 1199
      if (! l_included) {
        {
#line 1200
        l_cblk->numnewpasses = (OPJ_UINT32 )0;
#line 1201
        l_cblk ++;
#line 1202
        opj_null_jas_fprintf(stderr, "included=%d \nU", l_included);
        }
#line 1203
        goto while_continue___2;
      }
#line 1207
      if (! l_cblk->numsegs) {
#line 1208
        i = (OPJ_UINT32 )0;
        {
#line 1210
        while (1) {
          while_continue___6: /* CIL Label */ ;
          {
#line 1210
          __cil_tmp40 = opj_tgt_decode(l_bio, l_prc___0->imsbtree, cblkno, (OPJ_INT32 )i);
          }
#line 1210
          if (! (! __cil_tmp40)) {
#line 1210
            goto while_break___3;
          }
#line 1211
          i ++;
        }
        while_break___9: /* CIL Label */ ;
        }

        while_break___3: 
#line 1214
        l_cblk->numbps = ((OPJ_UINT32 )l_band->numbps + 1U) - i;
#line 1215
        l_cblk->numlenbits = (OPJ_UINT32 )3;
      }
      {
#line 1219
      l_cblk->numnewpasses = opj_t2_getnumpasses(l_bio);
#line 1220
      l_increment = opj_t2_getcommacode(l_bio);
#line 1223
      l_cblk->numlenbits += l_increment;
#line 1224
      l_segno = (OPJ_UINT32 )0;
      }
#line 1226
      if (! l_cblk->numsegs) {
        {
#line 1227
        __cil_tmp43 = opj_t2_init_seg(l_cblk, l_segno, (p_tcp->tccps + p_pi->compno)->cblksty,
                                      (OPJ_UINT32 )1);
        }
#line 1227
        if (! __cil_tmp43) {
          {
#line 1228
          opj_bio_destroy(l_bio);
          }
#line 1229
          return (0);
        }
      } else {
#line 1232
        l_segno = l_cblk->numsegs - 1U;
#line 1233
        if ((l_cblk->segs + l_segno)->numpasses == (l_cblk->segs + l_segno)->maxpasses) {
          {
#line 1234
          l_segno ++;
#line 1235
          __cil_tmp44 = opj_t2_init_seg(l_cblk, l_segno, (p_tcp->tccps + p_pi->compno)->cblksty,
                                        (OPJ_UINT32 )0);
          }
#line 1235
          if (! __cil_tmp44) {
            {
#line 1236
            opj_bio_destroy(l_bio);
            }
#line 1237
            return (0);
          }
        }
      }
#line 1241
      n = (OPJ_INT32 )l_cblk->numnewpasses;
      {
#line 1243
      while (1) {
        while_continue___7: /* CIL Label */ ;
        {
#line 1245
        __cil_tmp46 = opj_int_min((OPJ_INT32 )((l_cblk->segs + l_segno)->maxpasses - (l_cblk->segs + l_segno)->numpasses),
                                  n);
#line 1245
        (l_cblk->segs + l_segno)->numnewpasses = (OPJ_UINT32 )__cil_tmp46;
#line 1247
        __cil_tmp47 = opj_uint_floorlog2((l_cblk->segs + l_segno)->numnewpasses);
#line 1247
        bit_number = l_cblk->numlenbits + __cil_tmp47;
        }
#line 1249
        if (bit_number > 32U) {
          {
#line 1250
          opj_event_msg(p_manager, 1, "Invalid bit number %d in opj_t2_read_packet_header()\nU",
                        bit_number);
#line 1253
          opj_bio_destroy(l_bio);
          }
#line 1254
          return (0);
        }
        {
#line 1256
        (l_cblk->segs + l_segno)->newlen = opj_bio_read(l_bio, bit_number);
#line 1257
        opj_null_jas_fprintf(stderr, "included=%d numnewpasses=%d increment=%d len=%d \n",
                             l_included, (l_cblk->segs + l_segno)->numnewpasses, l_increment,
                             (l_cblk->segs + l_segno)->newlen);
#line 1261
        n -= (OPJ_INT32 )(l_cblk->segs + l_segno)->numnewpasses;
        }
#line 1262
        if (n > 0) {
          {
#line 1263
          l_segno ++;
#line 1265
          __cil_tmp49 = opj_t2_init_seg(l_cblk, l_segno, (p_tcp->tccps + p_pi->compno)->cblksty,
                                        (OPJ_UINT32 )0);
          }
#line 1265
          if (! __cil_tmp49) {
            {
#line 1266
            opj_bio_destroy(l_bio);
            }
#line 1267
            return (0);
          }
        }
#line 1243
        if (! (n > 0)) {
#line 1243
          goto while_break___4;
        }
      }
      while_break___10: /* CIL Label */ ;
      }

      while_break___4: 
#line 1272
      l_cblk ++;
#line 1185
      cblkno ++;
    }
    while_break___8: /* CIL Label */ ;
    }

    while_break___2: 
#line 1176
    l_band ++;
#line 1176
    bandno ++;
  }
  while_break___7: /* CIL Label */ ;
  }

  while_break___1: 
  {
#line 1276
  __cil_tmp51 = opj_bio_inalign(l_bio);
  }
#line 1276
  if (! __cil_tmp51) {
    {
#line 1277
    opj_bio_destroy(l_bio);
    }
#line 1278
    return (0);
  }
  {
#line 1281
  __cil_tmp52 = opj_bio_numbytes(l_bio);
#line 1281
  l_header_data += __cil_tmp52;
#line 1282
  opj_bio_destroy(l_bio);
  }
#line 1285
  if (p_tcp->csty & 4U) {
#line 1286
    if (*l_modified_length_ptr - (OPJ_UINT32 )(l_header_data - *l_header_data_start) < 2U) {
      {
#line 1288
      opj_event_msg(p_manager, 2, "Not enough space for expected EPH marker\n\370\235\004]U");
      }
    } else
#line 1290
    if ((int )*l_header_data != 255) {
      {
#line 1291
      opj_event_msg(p_manager, 2, "Expected EPH marker\n");
      }
    } else
#line 1290
    if ((int )*(l_header_data + 1) != 146) {
      {
#line 1291
      opj_event_msg(p_manager, 2, "Expected EPH marker\n");
      }
    } else {
#line 1293
      l_header_data += 2;
    }
  }
  {
#line 1297
  l_header_length = (OPJ_UINT32 )(l_header_data - *l_header_data_start);
#line 1298
  opj_null_jas_fprintf(stderr, "hdrlen=%d \n\004]U", l_header_length);
#line 1299
  opj_null_jas_fprintf(stderr, "packet body\n]U");
#line 1300
  *l_modified_length_ptr -= l_header_length;
#line 1301
  *l_header_data_start += l_header_length;
  }
#line 1306
  if (p_pack_info) {
#line 1307
    p_pack_info->end_ph_pos = (OPJ_OFF_T )((OPJ_INT32 )(l_current_data - p_src_data));
  }
#line 1311
  *p_is_data_present = 1;
#line 1312
  *p_data_read = (OPJ_UINT32 )(l_current_data - p_src_data);
#line 1314
  return (1);
}
}
#line 1317 "/root/patron-new/39/src/lib/openjp2/t2.c"
static OPJ_BOOL opj_t2_read_packet_data(opj_t2_t *p_t2 , opj_tcd_tile_t *p_tile ,
                                        opj_pi_iterator_t *p_pi , OPJ_BYTE *p_src_data ,
                                        OPJ_UINT32 *p_data_read , OPJ_UINT32 p_max_length ,
                                        opj_packet_info_t *pack_info , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 bandno ;
  OPJ_UINT32 cblkno ;
  OPJ_UINT32 l_nb_code_blocks ;
  OPJ_BYTE *l_current_data ;
  opj_tcd_band_t *l_band ;
  opj_tcd_cblk_dec_t *l_cblk ;
  opj_tcd_resolution_t *l_res ;
  opj_tcd_precinct_t *l_prc ;
  opj_tcd_seg_t *l_seg ;
  OPJ_UINT32 l_numchunksalloc ;
  opj_tcd_seg_data_chunk_t *l_chunks ;
  void *__cil_tmp20 ;

  {
#line 1328
  l_current_data = p_src_data;
#line 1329
  l_band = (opj_tcd_band_t *)0;
#line 1330
  l_cblk = (opj_tcd_cblk_dec_t *)0;
#line 1331
  l_res = (p_tile->comps + p_pi->compno)->resolutions + p_pi->resno;
#line 1337
  l_band = l_res->bands;
#line 1338
  bandno = (OPJ_UINT32 )0;
  {
#line 1338
  while (1) {
    while_continue___1: /* CIL Label */ ;

    while_continue: ;
#line 1338
    if (! (bandno < l_res->numbands)) {
#line 1338
      goto while_break;
    }
#line 1339
    l_prc = l_band->precincts + p_pi->precno;
#line 1341
    if (l_band->x1 - l_band->x0 == 0) {
#line 1342
      l_band ++;
#line 1343
      goto while_continue;
    } else
#line 1341
    if (l_band->y1 - l_band->y0 == 0) {
#line 1342
      l_band ++;
#line 1343
      goto while_continue;
    }
#line 1346
    l_nb_code_blocks = l_prc->cw * l_prc->ch;
#line 1347
    l_cblk = l_prc->cblks.dec;
#line 1349
    cblkno = (OPJ_UINT32 )0;
    {
#line 1349
    while (1) {
      while_continue___2: /* CIL Label */ ;

      while_continue___0: ;
#line 1349
      if (! (cblkno < l_nb_code_blocks)) {
#line 1349
        goto while_break___0;
      }
#line 1350
      l_seg = (opj_tcd_seg_t *)0;
#line 1352
      if (! l_cblk->numnewpasses) {
#line 1354
        l_cblk ++;
#line 1355
        goto while_continue___0;
      }
#line 1358
      if (! l_cblk->numsegs) {
#line 1359
        l_seg = l_cblk->segs;
#line 1360
        (l_cblk->numsegs) ++;
      } else {
#line 1362
        l_seg = l_cblk->segs + (l_cblk->numsegs - 1U);
#line 1364
        if (l_seg->numpasses == l_seg->maxpasses) {
#line 1365
          l_seg ++;
#line 1366
          (l_cblk->numsegs) ++;
        }
      }
      {
#line 1370
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 1372
        if ((unsigned long )(l_current_data + l_seg->newlen) > (unsigned long )(p_src_data + p_max_length)) {
          {
#line 1375
          opj_event_msg(p_manager, 1, "read: segment too long (%d) with max (%d) for codeblock %d (p=%d, b=%d, r=%d, c=%d)\n]U",
                        l_seg->newlen, p_max_length, cblkno, p_pi->precno, bandno,
                        p_pi->resno, p_pi->compno);
          }
#line 1379
          return (0);
        } else
#line 1372
        if ((OPJ_SIZE_T )l_current_data + (OPJ_SIZE_T )l_seg->newlen < (OPJ_SIZE_T )l_current_data) {
          {
#line 1375
          opj_event_msg(p_manager, 1, "read: segment too long (%d) with max (%d) for codeblock %d (p=%d, b=%d, r=%d, c=%d)\n]U",
                        l_seg->newlen, p_max_length, cblkno, p_pi->precno, bandno,
                        p_pi->resno, p_pi->compno);
          }
#line 1379
          return (0);
        }
#line 1403
        if (l_cblk->numchunks == l_cblk->numchunksalloc) {
          {
#line 1404
          l_numchunksalloc = l_cblk->numchunksalloc * 2U + 1U;
#line 1405
          __cil_tmp20 = opj_realloc((void *)l_cblk->chunks, (unsigned long )l_numchunksalloc * sizeof(opj_tcd_seg_data_chunk_t ));
#line 1405
          l_chunks = (opj_tcd_seg_data_chunk_t *)__cil_tmp20;
          }
#line 1408
          if ((unsigned long )l_chunks == (unsigned long )((void *)0)) {
            {
#line 1409
            opj_event_msg(p_manager, 1, "cannot allocate opj_tcd_seg_data_chunk_t* array");
            }
#line 1411
            return (0);
          }
#line 1413
          l_cblk->chunks = l_chunks;
#line 1414
          l_cblk->numchunksalloc = l_numchunksalloc;
        }
#line 1417
        (l_cblk->chunks + l_cblk->numchunks)->data = l_current_data;
#line 1418
        (l_cblk->chunks + l_cblk->numchunks)->len = l_seg->newlen;
#line 1419
        (l_cblk->numchunks) ++;
#line 1421
        l_current_data += l_seg->newlen;
#line 1422
        l_seg->len += l_seg->newlen;
#line 1423
        l_seg->numpasses += l_seg->numnewpasses;
#line 1424
        l_cblk->numnewpasses -= l_seg->numnewpasses;
#line 1426
        l_seg->real_num_passes = l_seg->numpasses;
#line 1428
        if (l_cblk->numnewpasses > 0U) {
#line 1429
          l_seg ++;
#line 1430
          (l_cblk->numsegs) ++;
        }
#line 1370
        if (! (l_cblk->numnewpasses > 0U)) {
#line 1370
          goto while_break___1;
        }
      }
      while_break___4: /* CIL Label */ ;
      }

      while_break___1: 
#line 1434
      l_cblk->real_num_segs = l_cblk->numsegs;
#line 1435
      l_cblk ++;
#line 1349
      cblkno ++;
    }
    while_break___3: /* CIL Label */ ;
    }

    while_break___0: 
#line 1438
    l_band ++;
#line 1338
    bandno ++;
  }
  while_break___2: /* CIL Label */ ;
  }

  while_break: 
#line 1441
  *p_data_read = (OPJ_UINT32 )(l_current_data - p_src_data);
#line 1444
  return (1);
}
}
#line 1447 "/root/patron-new/39/src/lib/openjp2/t2.c"
static OPJ_BOOL opj_t2_skip_packet_data(opj_t2_t *p_t2 , opj_tcd_tile_t *p_tile ,
                                        opj_pi_iterator_t *p_pi , OPJ_UINT32 *p_data_read ,
                                        OPJ_UINT32 p_max_length , opj_packet_info_t *pack_info ,
                                        opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 bandno ;
  OPJ_UINT32 cblkno ;
  OPJ_UINT32 l_nb_code_blocks ;
  opj_tcd_band_t *l_band ;
  opj_tcd_cblk_dec_t *l_cblk ;
  opj_tcd_resolution_t *l_res ;
  opj_tcd_precinct_t *l_prc ;
  opj_tcd_seg_t *l_seg ;

  {
#line 1457
  l_band = (opj_tcd_band_t *)0;
#line 1458
  l_cblk = (opj_tcd_cblk_dec_t *)0;
#line 1459
  l_res = (p_tile->comps + p_pi->compno)->resolutions + p_pi->resno;
#line 1465
  *p_data_read = (OPJ_UINT32 )0;
#line 1466
  l_band = l_res->bands;
#line 1468
  bandno = (OPJ_UINT32 )0;
  {
#line 1468
  while (1) {
    while_continue___1: /* CIL Label */ ;

    while_continue: ;
#line 1468
    if (! (bandno < l_res->numbands)) {
#line 1468
      goto while_break;
    }
#line 1469
    l_prc = l_band->precincts + p_pi->precno;
#line 1471
    if (l_band->x1 - l_band->x0 == 0) {
#line 1472
      l_band ++;
#line 1473
      goto while_continue;
    } else
#line 1471
    if (l_band->y1 - l_band->y0 == 0) {
#line 1472
      l_band ++;
#line 1473
      goto while_continue;
    }
#line 1476
    l_nb_code_blocks = l_prc->cw * l_prc->ch;
#line 1477
    l_cblk = l_prc->cblks.dec;
#line 1479
    cblkno = (OPJ_UINT32 )0;
    {
#line 1479
    while (1) {
      while_continue___2: /* CIL Label */ ;

      while_continue___0: ;
#line 1479
      if (! (cblkno < l_nb_code_blocks)) {
#line 1479
        goto while_break___0;
      }
#line 1480
      l_seg = (opj_tcd_seg_t *)0;
#line 1482
      if (! l_cblk->numnewpasses) {
#line 1484
        l_cblk ++;
#line 1485
        goto while_continue___0;
      }
#line 1488
      if (! l_cblk->numsegs) {
#line 1489
        l_seg = l_cblk->segs;
#line 1490
        (l_cblk->numsegs) ++;
      } else {
#line 1492
        l_seg = l_cblk->segs + (l_cblk->numsegs - 1U);
#line 1494
        if (l_seg->numpasses == l_seg->maxpasses) {
#line 1495
          l_seg ++;
#line 1496
          (l_cblk->numsegs) ++;
        }
      }
      {
#line 1500
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 1502
        if (*p_data_read + l_seg->newlen < *p_data_read) {
          {
#line 1504
          opj_event_msg(p_manager, 1, "skip: segment too long (%d) with max (%d) for codeblock %d (p=%d, b=%d, r=%d, c=%d)\n]U",
                        l_seg->newlen, p_max_length, cblkno, p_pi->precno, bandno,
                        p_pi->resno, p_pi->compno);
          }
#line 1508
          return (0);
        } else
#line 1502
        if (*p_data_read + l_seg->newlen > p_max_length) {
          {
#line 1504
          opj_event_msg(p_manager, 1, "skip: segment too long (%d) with max (%d) for codeblock %d (p=%d, b=%d, r=%d, c=%d)\n]U",
                        l_seg->newlen, p_max_length, cblkno, p_pi->precno, bandno,
                        p_pi->resno, p_pi->compno);
          }
#line 1508
          return (0);
        }
        {
#line 1531
        opj_null_jas_fprintf(stderr, "p_data_read (%d) newlen (%d) \n", *p_data_read,
                             l_seg->newlen);
#line 1533
        *p_data_read += l_seg->newlen;
#line 1535
        l_seg->numpasses += l_seg->numnewpasses;
#line 1536
        l_cblk->numnewpasses -= l_seg->numnewpasses;
        }
#line 1537
        if (l_cblk->numnewpasses > 0U) {
#line 1538
          l_seg ++;
#line 1539
          (l_cblk->numsegs) ++;
        }
#line 1500
        if (! (l_cblk->numnewpasses > 0U)) {
#line 1500
          goto while_break___1;
        }
      }
      while_break___4: /* CIL Label */ ;
      }

      while_break___1: 
#line 1543
      l_cblk ++;
#line 1479
      cblkno ++;
    }
    while_break___3: /* CIL Label */ ;
    }

    while_break___0: 
#line 1546
    l_band ++;
#line 1468
    bandno ++;
  }
  while_break___2: /* CIL Label */ ;
  }

  while_break: ;
#line 1549
  return (1);
}
}
#line 1553 "/root/patron-new/39/src/lib/openjp2/t2.c"
static OPJ_BOOL opj_t2_init_seg(opj_tcd_cblk_dec_t *cblk , OPJ_UINT32 index___0 ,
                                OPJ_UINT32 cblksty , OPJ_UINT32 first ) 
{ 
  opj_tcd_seg_t *seg ;
  OPJ_UINT32 l_nb_segs ;
  opj_tcd_seg_t *new_segs ;
  OPJ_UINT32 l_m_current_max_segs ;
  void *__cil_tmp9 ;
  int tmp ;

  {
#line 1558
  seg = (opj_tcd_seg_t *)0;
#line 1559
  l_nb_segs = index___0 + 1U;
#line 1561
  if (l_nb_segs > cblk->m_current_max_segs) {
    {
#line 1563
    l_m_current_max_segs = cblk->m_current_max_segs + 10U;
#line 1566
    __cil_tmp9 = opj_realloc((void *)cblk->segs, (unsigned long )l_m_current_max_segs * sizeof(opj_tcd_seg_t ));
#line 1566
    new_segs = (opj_tcd_seg_t *)__cil_tmp9;
    }
#line 1568
    if (! new_segs) {
#line 1570
      return (0);
    }
    {
#line 1572
    cblk->segs = new_segs;
#line 1573
    memset((void *)(new_segs + cblk->m_current_max_segs), 0, 10UL * sizeof(opj_tcd_seg_t ));
#line 1575
    cblk->m_current_max_segs = l_m_current_max_segs;
    }
  }
  {
#line 1578
  seg = cblk->segs + index___0;
#line 1579
  opj_tcd_reinit_segment(seg);
  }
#line 1581
  if (cblksty & 4U) {
#line 1582
    seg->maxpasses = (OPJ_UINT32 )1;
  } else
#line 1583
  if (cblksty & 1U) {
#line 1584
    if (first) {
#line 1585
      seg->maxpasses = (OPJ_UINT32 )10;
    } else {
#line 1587
      if ((seg - 1)->maxpasses == 1U) {
#line 1587
        tmp = 2;
      } else
#line 1587
      if ((seg - 1)->maxpasses == 10U) {
#line 1587
        tmp = 2;
      } else {
#line 1587
        tmp = 1;
      }
#line 1587
      seg->maxpasses = (OPJ_UINT32 )tmp;
    }
  } else {
#line 1595
    seg->maxpasses = (OPJ_UINT32 )109;
  }
#line 1598
  return (1);
}
}
#line 45 "/root/patron-new/39/src/lib/openjp2/sparse_array.c"
opj_sparse_array_int32_t *opj_sparse_array_int32_create(OPJ_UINT32 width , OPJ_UINT32 height ,
                                                        OPJ_UINT32 block_width , OPJ_UINT32 block_height ) 
{ 
  opj_sparse_array_int32_t *sa ;
  void *__cil_tmp6 ;
  void *__cil_tmp9 ;

  {
#line 52
  if (width == 0U) {
#line 53
    return ((opj_sparse_array_int32_t *)((void *)0));
  } else
#line 52
  if (height == 0U) {
#line 53
    return ((opj_sparse_array_int32_t *)((void *)0));
  } else
#line 52
  if (block_width == 0U) {
#line 53
    return ((opj_sparse_array_int32_t *)((void *)0));
  } else
#line 52
  if (block_height == 0U) {
#line 53
    return ((opj_sparse_array_int32_t *)((void *)0));
  }
#line 55
  if ((unsigned long )block_width > (unsigned long )(4294967295U / block_height) / sizeof(OPJ_INT32 )) {
#line 56
    return ((opj_sparse_array_int32_t *)((void *)0));
  }
  {
#line 59
  __cil_tmp6 = opj_calloc((size_t )1, sizeof(opj_sparse_array_int32_t ));
#line 59
  sa = (opj_sparse_array_int32_t *)__cil_tmp6;
#line 61
  sa->width = width;
#line 62
  sa->height = height;
#line 63
  sa->block_width = block_width;
#line 64
  sa->block_height = block_height;
#line 65
  sa->block_count_hor = opj_uint_ceildiv(width, block_width);
#line 66
  sa->block_count_ver = opj_uint_ceildiv(height, block_height);
  }
#line 67
  if (sa->block_count_hor > 4294967295U / sa->block_count_ver) {
    {
#line 68
    opj_free((void *)sa);
    }
#line 69
    return ((opj_sparse_array_int32_t *)((void *)0));
  }
  {
#line 71
  __cil_tmp9 = opj_calloc(sizeof(OPJ_INT32 *), (size_t )(sa->block_count_hor * sa->block_count_ver));
#line 71
  sa->data_blocks = (OPJ_INT32 **)__cil_tmp9;
  }
#line 73
  if ((unsigned long )sa->data_blocks == (unsigned long )((void *)0)) {
    {
#line 74
    opj_free((void *)sa);
    }
#line 75
    return ((opj_sparse_array_int32_t *)((void *)0));
  }
#line 78
  return (sa);
}
}
#line 81 "/root/patron-new/39/src/lib/openjp2/sparse_array.c"
void opj_sparse_array_int32_free(opj_sparse_array_int32_t *sa ) 
{ 
  OPJ_UINT32 i ;

  {
#line 83
  if (sa) {
#line 85
    i = (OPJ_UINT32 )0;
    {
#line 85
    while (1) {
      while_continue: /* CIL Label */ ;

#line 85
      if (! (i < sa->block_count_hor * sa->block_count_ver)) {
#line 85
        goto while_break;
      }
#line 86
      if (*(sa->data_blocks + i)) {
        {
#line 87
        opj_free((void *)*(sa->data_blocks + i));
        }
      }
#line 85
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }

    while_break: 
    {
#line 90
    opj_free((void *)sa->data_blocks);
#line 91
    opj_free((void *)sa);
    }
  }
#line 94
  return;
}
}
#line 95 "/root/patron-new/39/src/lib/openjp2/sparse_array.c"
OPJ_BOOL opj_sparse_array_is_region_valid(opj_sparse_array_int32_t *sa , OPJ_UINT32 x0 ,
                                          OPJ_UINT32 y0___0 , OPJ_UINT32 x1 , OPJ_UINT32 y1___0 ) 
{ 
  int tmp ;

  {
#line 101
  if (x0 >= sa->width) {
#line 101
    tmp = 0;
  } else
#line 101
  if (x1 <= x0) {
#line 101
    tmp = 0;
  } else
#line 101
  if (x1 > sa->width) {
#line 101
    tmp = 0;
  } else
#line 101
  if (y0___0 >= sa->height) {
#line 101
    tmp = 0;
  } else
#line 101
  if (y1___0 <= y0___0) {
#line 101
    tmp = 0;
  } else
#line 101
  if (y1___0 > sa->height) {
#line 101
    tmp = 0;
  } else {
#line 101
    tmp = 1;
  }
#line 101
  return (tmp);
}
}
#line 105 "/root/patron-new/39/src/lib/openjp2/sparse_array.c"
static OPJ_BOOL opj_sparse_array_int32_read_or_write(opj_sparse_array_int32_t *sa ,
                                                     OPJ_UINT32 x0 , OPJ_UINT32 y0___0 ,
                                                     OPJ_UINT32 x1 , OPJ_UINT32 y1___0 ,
                                                     OPJ_INT32 *buf , OPJ_UINT32 buf_col_stride ,
                                                     OPJ_UINT32 buf_line_stride ,
                                                     OPJ_BOOL forgiving , OPJ_BOOL is_read_op ) 
{ 
  OPJ_UINT32 y ;
  OPJ_UINT32 block_y ;
  OPJ_UINT32 y_incr ;
  OPJ_UINT32 block_width ;
  OPJ_BOOL __cil_tmp15 ;
  OPJ_UINT32 x ;
  OPJ_UINT32 block_x ;
  OPJ_UINT32 x_incr ;
  OPJ_UINT32 block_y_offset ;
  OPJ_UINT32 tmp ;
  OPJ_UINT32 j ;
  OPJ_UINT32 block_x_offset ;
  OPJ_INT32 *src_block ;
  OPJ_UINT32 tmp___0 ;
  OPJ_INT32 *dest_ptr ;
  OPJ_INT32 *dest_ptr___0 ;
  OPJ_UINT32 k ;
  OPJ_INT32 *src_ptr ;
  OPJ_INT32 *dest_ptr___1 ;
  OPJ_INT32 *dest_ptr___2 ;
  OPJ_UINT32 k___0 ;
  OPJ_UINT32 k___1 ;
  OPJ_UINT32 k___2 ;
  void *__cil_tmp47 ;
  OPJ_INT32 *dest_ptr___3 ;
  OPJ_INT32 *src_ptr___0 ;
  OPJ_INT32 *dest_ptr___4 ;
  OPJ_INT32 *src_ptr___1 ;
  OPJ_UINT32 k___3 ;
  OPJ_UINT32 k___4 ;
  OPJ_UINT32 __cil_tmp61 ;
  OPJ_UINT32 __cil_tmp62 ;

  {
  {
#line 118
  y_incr = (OPJ_UINT32 )0;
#line 119
  block_width = sa->block_width;
#line 121
  __cil_tmp15 = opj_sparse_array_is_region_valid(sa, x0, y0___0, x1, y1___0);
  }
#line 121
  if (! __cil_tmp15) {
#line 122
    return (forgiving);
  }
#line 125
  block_y = y0___0 / sa->block_height;
#line 126
  y = y0___0;
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;

#line 126
    if (! (y < y1___0)) {
#line 126
      goto while_break;
    }
#line 128
    x_incr = (OPJ_UINT32 )0;
#line 130
    if (y == y0___0) {
#line 130
      tmp = sa->block_height - y0___0 % sa->block_height;
    } else {
#line 130
      tmp = sa->block_height;
    }
    {
#line 130
    y_incr = tmp;
#line 132
    block_y_offset = sa->block_height - y_incr;
#line 133
    y_incr = opj_uint_min(y_incr, y1___0 - y);
#line 134
    block_x = x0 / block_width;
#line 135
    x = x0;
    }
    {
#line 135
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 135
      if (! (x < x1)) {
#line 135
        goto while_break___0;
      }
#line 139
      if (x == x0) {
#line 139
        tmp___0 = block_width - x0 % block_width;
      } else {
#line 139
        tmp___0 = block_width;
      }
      {
#line 139
      x_incr = tmp___0;
#line 140
      block_x_offset = block_width - x_incr;
#line 141
      x_incr = opj_uint_min(x_incr, x1 - x);
#line 142
      src_block = *(sa->data_blocks + (block_y * sa->block_count_hor + block_x));
      }
#line 143
      if (is_read_op) {
#line 144
        if ((unsigned long )src_block == (unsigned long )((void *)0)) {
#line 145
          if (buf_col_stride == 1U) {
#line 146
            dest_ptr = (buf + (unsigned long )(y - y0___0) * (OPJ_SIZE_T )buf_line_stride) + (x - x0) * buf_col_stride;
#line 148
            j = (OPJ_UINT32 )0;
            {
#line 148
            while (1) {
              while_continue___1: /* CIL Label */ ;

#line 148
              if (! (j < y_incr)) {
#line 148
                goto while_break___1;
              }
              {
#line 149
              memset((void *)dest_ptr, 0, sizeof(OPJ_INT32 ) * (unsigned long )x_incr);
#line 150
              dest_ptr += buf_line_stride;
#line 148
              j ++;
              }
            }
            while_break___24: /* CIL Label */ ;
            }

            while_break___1: ;
          } else {
#line 153
            dest_ptr___0 = (buf + (unsigned long )(y - y0___0) * (OPJ_SIZE_T )buf_line_stride) + (x - x0) * buf_col_stride;
#line 155
            j = (OPJ_UINT32 )0;
            {
#line 155
            while (1) {
              while_continue___2: /* CIL Label */ ;

#line 155
              if (! (j < y_incr)) {
#line 155
                goto while_break___2;
              }
#line 157
              k = (OPJ_UINT32 )0;
              {
#line 157
              while (1) {
                while_continue___3: /* CIL Label */ ;

#line 157
                if (! (k < x_incr)) {
#line 157
                  goto while_break___3;
                }
#line 158
                *(dest_ptr___0 + k * buf_col_stride) = 0;
#line 157
                k ++;
              }
              while_break___26: /* CIL Label */ ;
              }

              while_break___3: 
#line 160
              dest_ptr___0 += buf_line_stride;
#line 155
              j ++;
            }
            while_break___25: /* CIL Label */ ;
            }

            while_break___2: ;
          }
        } else {
#line 164
          src_ptr = (src_block + (unsigned long )block_y_offset * (OPJ_SIZE_T )block_width) + block_x_offset;
#line 166
          if (buf_col_stride == 1U) {
#line 167
            dest_ptr___1 = (buf + (unsigned long )(y - y0___0) * (OPJ_SIZE_T )buf_line_stride) + (x - x0) * buf_col_stride;
#line 170
            if (x_incr == 4U) {
#line 174
              j = (OPJ_UINT32 )0;
              {
#line 174
              while (1) {
                while_continue___4: /* CIL Label */ ;

#line 174
                if (! (j < y_incr)) {
#line 174
                  goto while_break___4;
                }
                {
#line 175
                memcpy((void *)dest_ptr___1, (void const   *)src_ptr, sizeof(OPJ_INT32 ) * (unsigned long )x_incr);
#line 176
                dest_ptr___1 += buf_line_stride;
#line 177
                src_ptr += block_width;
#line 174
                j ++;
                }
              }
              while_break___27: /* CIL Label */ ;
              }

              while_break___4: ;
            } else {
#line 180
              j = (OPJ_UINT32 )0;
              {
#line 180
              while (1) {
                while_continue___5: /* CIL Label */ ;

#line 180
                if (! (j < y_incr)) {
#line 180
                  goto while_break___5;
                }
                {
#line 181
                memcpy((void *)dest_ptr___1, (void const   *)src_ptr, sizeof(OPJ_INT32 ) * (unsigned long )x_incr);
#line 182
                dest_ptr___1 += buf_line_stride;
#line 183
                src_ptr += block_width;
#line 180
                j ++;
                }
              }
              while_break___28: /* CIL Label */ ;
              }

              while_break___5: ;
            }
          } else {
#line 187
            dest_ptr___2 = (buf + (unsigned long )(y - y0___0) * (OPJ_SIZE_T )buf_line_stride) + (x - x0) * buf_col_stride;
#line 190
            if (x_incr == 1U) {
#line 191
              j = (OPJ_UINT32 )0;
              {
#line 191
              while (1) {
                while_continue___6: /* CIL Label */ ;

#line 191
                if (! (j < y_incr)) {
#line 191
                  goto while_break___6;
                }
#line 192
                *dest_ptr___2 = *src_ptr;
#line 193
                dest_ptr___2 += buf_line_stride;
#line 194
                src_ptr += block_width;
#line 191
                j ++;
              }
              while_break___29: /* CIL Label */ ;
              }

              while_break___6: ;
            } else
#line 196
            if (y_incr == 1U) {
#line 196
              if (buf_col_stride == 2U) {
#line 198
                k___0 = (OPJ_UINT32 )0;
                {
#line 198
                while (1) {
                  while_continue___7: /* CIL Label */ ;

#line 198
                  if (! (k___0 < (x_incr & 4294967292U))) {
#line 198
                    goto while_break___7;
                  }
#line 199
                  *(dest_ptr___2 + k___0 * buf_col_stride) = *(src_ptr + k___0);
#line 200
                  *(dest_ptr___2 + (k___0 + 1U) * buf_col_stride) = *(src_ptr + (k___0 + 1U));
#line 201
                  *(dest_ptr___2 + (k___0 + 2U) * buf_col_stride) = *(src_ptr + (k___0 + 2U));
#line 202
                  *(dest_ptr___2 + (k___0 + 3U) * buf_col_stride) = *(src_ptr + (k___0 + 3U));
#line 198
                  k___0 += 4U;
                }
                while_break___30: /* CIL Label */ ;
                }

                while_break___7: ;
                {
#line 204
                while (1) {
                  while_continue___8: /* CIL Label */ ;

#line 204
                  if (! (k___0 < x_incr)) {
#line 204
                    goto while_break___8;
                  }
#line 205
                  *(dest_ptr___2 + k___0 * buf_col_stride) = *(src_ptr + k___0);
#line 204
                  k___0 ++;
                }
                while_break___31: /* CIL Label */ ;
                }

                while_break___8: ;
              } else {
#line 196
                goto _L___6;
              }
            } else
            _L___6: 
#line 207
            if (x_incr >= 8U) {
#line 207
              if (buf_col_stride == 8U) {
#line 208
                j = (OPJ_UINT32 )0;
                {
#line 208
                while (1) {
                  while_continue___9: /* CIL Label */ ;

#line 208
                  if (! (j < y_incr)) {
#line 208
                    goto while_break___9;
                  }
#line 210
                  k___1 = (OPJ_UINT32 )0;
                  {
#line 210
                  while (1) {
                    while_continue___10: /* CIL Label */ ;

#line 210
                    if (! (k___1 < (x_incr & 4294967292U))) {
#line 210
                      goto while_break___10;
                    }
#line 211
                    *(dest_ptr___2 + k___1 * buf_col_stride) = *(src_ptr + k___1);
#line 212
                    *(dest_ptr___2 + (k___1 + 1U) * buf_col_stride) = *(src_ptr + (k___1 + 1U));
#line 213
                    *(dest_ptr___2 + (k___1 + 2U) * buf_col_stride) = *(src_ptr + (k___1 + 2U));
#line 214
                    *(dest_ptr___2 + (k___1 + 3U) * buf_col_stride) = *(src_ptr + (k___1 + 3U));
#line 210
                    k___1 += 4U;
                  }
                  while_break___33: /* CIL Label */ ;
                  }

                  while_break___10: ;
                  {
#line 216
                  while (1) {
                    while_continue___11: /* CIL Label */ ;

#line 216
                    if (! (k___1 < x_incr)) {
#line 216
                      goto while_break___11;
                    }
#line 217
                    *(dest_ptr___2 + k___1 * buf_col_stride) = *(src_ptr + k___1);
#line 216
                    k___1 ++;
                  }
                  while_break___34: /* CIL Label */ ;
                  }

                  while_break___11: 
#line 219
                  dest_ptr___2 += buf_line_stride;
#line 220
                  src_ptr += block_width;
#line 208
                  j ++;
                }
                while_break___32: /* CIL Label */ ;
                }

                while_break___9: ;
              } else {
#line 207
                goto _L;
              }
            } else {
              _L: 
#line 224
              j = (OPJ_UINT32 )0;
              {
#line 224
              while (1) {
                while_continue___12: /* CIL Label */ ;

#line 224
                if (! (j < y_incr)) {
#line 224
                  goto while_break___12;
                }
#line 226
                k___2 = (OPJ_UINT32 )0;
                {
#line 226
                while (1) {
                  while_continue___13: /* CIL Label */ ;

#line 226
                  if (! (k___2 < x_incr)) {
#line 226
                    goto while_break___13;
                  }
#line 227
                  *(dest_ptr___2 + k___2 * buf_col_stride) = *(src_ptr + k___2);
#line 226
                  k___2 ++;
                }
                while_break___36: /* CIL Label */ ;
                }

                while_break___13: 
#line 229
                dest_ptr___2 += buf_line_stride;
#line 230
                src_ptr += block_width;
#line 224
                j ++;
              }
              while_break___35: /* CIL Label */ ;
              }

              while_break___12: ;
            }
          }
        }
      } else {
#line 236
        if ((unsigned long )src_block == (unsigned long )((void *)0)) {
          {
#line 237
          __cil_tmp47 = opj_calloc((size_t )1, (unsigned long )(sa->block_width * sa->block_height) * sizeof(OPJ_INT32 ));
#line 237
          src_block = (OPJ_INT32 *)__cil_tmp47;
          }
#line 239
          if ((unsigned long )src_block == (unsigned long )((void *)0)) {
#line 240
            return (0);
          }
#line 242
          *(sa->data_blocks + (block_y * sa->block_count_hor + block_x)) = src_block;
        }
#line 245
        if (buf_col_stride == 1U) {
#line 246
          dest_ptr___3 = (src_block + (unsigned long )block_y_offset * (OPJ_SIZE_T )block_width) + block_x_offset;
#line 248
          src_ptr___0 = (buf + (unsigned long )(y - y0___0) * (OPJ_SIZE_T )buf_line_stride) + (x - x0) * buf_col_stride;
#line 250
          if (x_incr == 4U) {
#line 254
            j = (OPJ_UINT32 )0;
            {
#line 254
            while (1) {
              while_continue___14: /* CIL Label */ ;

#line 254
              if (! (j < y_incr)) {
#line 254
                goto while_break___14;
              }
              {
#line 255
              memcpy((void *)dest_ptr___3, (void const   *)src_ptr___0, sizeof(OPJ_INT32 ) * (unsigned long )x_incr);
#line 256
              dest_ptr___3 += block_width;
#line 257
              src_ptr___0 += buf_line_stride;
#line 254
              j ++;
              }
            }
            while_break___37: /* CIL Label */ ;
            }

            while_break___14: ;
          } else {
#line 260
            j = (OPJ_UINT32 )0;
            {
#line 260
            while (1) {
              while_continue___15: /* CIL Label */ ;

#line 260
              if (! (j < y_incr)) {
#line 260
                goto while_break___15;
              }
              {
#line 261
              memcpy((void *)dest_ptr___3, (void const   *)src_ptr___0, sizeof(OPJ_INT32 ) * (unsigned long )x_incr);
#line 262
              dest_ptr___3 += block_width;
#line 263
              src_ptr___0 += buf_line_stride;
#line 260
              j ++;
              }
            }
            while_break___38: /* CIL Label */ ;
            }

            while_break___15: ;
          }
        } else {
#line 267
          dest_ptr___4 = (src_block + (unsigned long )block_y_offset * (OPJ_SIZE_T )block_width) + block_x_offset;
#line 269
          src_ptr___1 = (buf + (unsigned long )(y - y0___0) * (OPJ_SIZE_T )buf_line_stride) + (x - x0) * buf_col_stride;
#line 271
          if (x_incr == 1U) {
#line 272
            j = (OPJ_UINT32 )0;
            {
#line 272
            while (1) {
              while_continue___16: /* CIL Label */ ;

#line 272
              if (! (j < y_incr)) {
#line 272
                goto while_break___16;
              }
#line 273
              *dest_ptr___4 = *src_ptr___1;
#line 274
              src_ptr___1 += buf_line_stride;
#line 275
              dest_ptr___4 += block_width;
#line 272
              j ++;
            }
            while_break___39: /* CIL Label */ ;
            }

            while_break___16: ;
          } else
#line 277
          if (x_incr >= 8U) {
#line 277
            if (buf_col_stride == 8U) {
#line 278
              j = (OPJ_UINT32 )0;
              {
#line 278
              while (1) {
                while_continue___17: /* CIL Label */ ;

#line 278
                if (! (j < y_incr)) {
#line 278
                  goto while_break___17;
                }
#line 280
                k___3 = (OPJ_UINT32 )0;
                {
#line 280
                while (1) {
                  while_continue___18: /* CIL Label */ ;

#line 280
                  if (! (k___3 < (x_incr & 4294967292U))) {
#line 280
                    goto while_break___18;
                  }
#line 281
                  *(dest_ptr___4 + k___3) = *(src_ptr___1 + k___3 * buf_col_stride);
#line 282
                  *(dest_ptr___4 + (k___3 + 1U)) = *(src_ptr___1 + (k___3 + 1U) * buf_col_stride);
#line 283
                  *(dest_ptr___4 + (k___3 + 2U)) = *(src_ptr___1 + (k___3 + 2U) * buf_col_stride);
#line 284
                  *(dest_ptr___4 + (k___3 + 3U)) = *(src_ptr___1 + (k___3 + 3U) * buf_col_stride);
#line 280
                  k___3 += 4U;
                }
                while_break___41: /* CIL Label */ ;
                }

                while_break___18: ;
                {
#line 286
                while (1) {
                  while_continue___19: /* CIL Label */ ;

#line 286
                  if (! (k___3 < x_incr)) {
#line 286
                    goto while_break___19;
                  }
#line 287
                  *(dest_ptr___4 + k___3) = *(src_ptr___1 + k___3 * buf_col_stride);
#line 286
                  k___3 ++;
                }
                while_break___42: /* CIL Label */ ;
                }

                while_break___19: 
#line 289
                src_ptr___1 += buf_line_stride;
#line 290
                dest_ptr___4 += block_width;
#line 278
                j ++;
              }
              while_break___40: /* CIL Label */ ;
              }

              while_break___17: ;
            } else {
#line 277
              goto _L___7;
            }
          } else {
            _L___7: 
#line 294
            j = (OPJ_UINT32 )0;
            {
#line 294
            while (1) {
              while_continue___20: /* CIL Label */ ;

#line 294
              if (! (j < y_incr)) {
#line 294
                goto while_break___20;
              }
#line 296
              k___4 = (OPJ_UINT32 )0;
              {
#line 296
              while (1) {
                while_continue___21: /* CIL Label */ ;

#line 296
                if (! (k___4 < x_incr)) {
#line 296
                  goto while_break___21;
                }
#line 297
                *(dest_ptr___4 + k___4) = *(src_ptr___1 + k___4 * buf_col_stride);
#line 296
                k___4 ++;
              }
              while_break___44: /* CIL Label */ ;
              }

              while_break___21: 
#line 299
              src_ptr___1 += buf_line_stride;
#line 300
              dest_ptr___4 += block_width;
#line 294
              j ++;
            }
            while_break___43: /* CIL Label */ ;
            }

            while_break___20: ;
          }
        }
      }
#line 135
      x += x_incr;
#line 135
      __cil_tmp61 = block_x;
#line 135
      block_x ++;
    }
    while_break___23: /* CIL Label */ ;
    }

    while_break___0: 
#line 126
    y += y_incr;
#line 126
    __cil_tmp62 = block_y;
#line 126
    block_y ++;
  }
  while_break___22: /* CIL Label */ ;
  }

  while_break: ;
#line 308
  return (1);
}
}
#line 311 "/root/patron-new/39/src/lib/openjp2/sparse_array.c"
OPJ_BOOL opj_sparse_array_int32_read(opj_sparse_array_int32_t *sa , OPJ_UINT32 x0 ,
                                     OPJ_UINT32 y0___0 , OPJ_UINT32 x1 , OPJ_UINT32 y1___0 ,
                                     OPJ_INT32 *dest , OPJ_UINT32 dest_col_stride ,
                                     OPJ_UINT32 dest_line_stride , OPJ_BOOL forgiving ) 
{ 
  OPJ_BOOL __cil_tmp10 ;

  {
  {
#line 321
  __cil_tmp10 = opj_sparse_array_int32_read_or_write(sa, x0, y0___0, x1, y1___0, dest,
                                                     dest_col_stride, dest_line_stride,
                                                     forgiving, 1);
  }
#line 321
  return (__cil_tmp10);
}
}
#line 330 "/root/patron-new/39/src/lib/openjp2/sparse_array.c"
OPJ_BOOL opj_sparse_array_int32_write(opj_sparse_array_int32_t *sa , OPJ_UINT32 x0 ,
                                      OPJ_UINT32 y0___0 , OPJ_UINT32 x1 , OPJ_UINT32 y1___0 ,
                                      OPJ_INT32 *src , OPJ_UINT32 src_col_stride ,
                                      OPJ_UINT32 src_line_stride , OPJ_BOOL forgiving ) 
{ 
  OPJ_BOOL __cil_tmp10 ;

  {
  {
#line 340
  __cil_tmp10 = opj_sparse_array_int32_read_or_write(sa, x0, y0___0, x1, y1___0, src,
                                                     src_col_stride, src_line_stride,
                                                     forgiving, 0);
  }
#line 340
  return (__cil_tmp10);
}
}
#line 1359 "/root/patron-new/39/src/lib/openjp2/pi.c"
__asm__("error in function opj_pi_create_decode");
#line 1557
__asm__("error in function opj_get_encoding_packet_count");
#line 1580
__asm__("error in function opj_pi_initialise_encode");
#line 1772
__asm__("error in function opj_pi_create_encode");
#line 2035
__asm__("error in function opj_pi_destroy");
#line 2067
__asm__("error in function opj_pi_update_encoding_parameters");
#line 2100
__asm__("error in function opj_pi_next");
#line 43 "/root/patron-new/39/src/lib/openjp2/opj_malloc.c"
__inline static void *opj_aligned_alloc_n(size_t alignment , size_t size ) 
{ 
  void *ptr ;
  int __cil_tmp6 ;

  {
#line 52
  if (size == 0UL) {
#line 53
    return ((void *)0);
  }
  {
#line 61
  __cil_tmp6 = posix_memalign(& ptr, alignment, size);
  }
#line 61
  if (__cil_tmp6) {
#line 62
    ptr = (void *)0;
  }
#line 105
  return (ptr);
}
}
#line 107 "/root/patron-new/39/src/lib/openjp2/opj_malloc.c"
__inline static void *opj_aligned_realloc_n(void *ptr___0 , size_t alignment___0 ,
                                            size_t new_size ) 
{ 
  void *r_ptr ;
  void *a_ptr ;
  void *__cil_tmp9 ;

  {
#line 117
  if (new_size == 0UL) {
#line 118
    return ((void *)0);
  }
  {
#line 124
  r_ptr = realloc(ptr___0, new_size);
  }
#line 127
  if (((size_t )r_ptr & (alignment___0 - 1UL)) != 0UL) {
    {
#line 132
    __cil_tmp9 = opj_aligned_alloc_n(alignment___0, new_size);
#line 132
    a_ptr = __cil_tmp9;
    }
#line 133
    if ((unsigned long )a_ptr != (unsigned long )((void *)0)) {
      {
#line 134
      memcpy(a_ptr, (void const   *)r_ptr, new_size);
      }
    }
    {
#line 136
    free(r_ptr);
#line 137
    r_ptr = a_ptr;
    }
  }
#line 189
  return (r_ptr);
}
}
#line 191 "/root/patron-new/39/src/lib/openjp2/opj_malloc.c"
void *opj_malloc(size_t size___0 ) 
{ 
  void *__cil_tmp2 ;

  {
#line 193
  if (size___0 == 0UL) {
#line 194
    return ((void *)0);
  }
  {
#line 196
  __cil_tmp2 = malloc(size___0);
  }
#line 196
  return (__cil_tmp2);
}
}
#line 198 "/root/patron-new/39/src/lib/openjp2/opj_malloc.c"
void *opj_calloc(size_t num , size_t size___1 ) 
{ 
  void *__cil_tmp3 ;

  {
#line 200
  if (num == 0UL) {
#line 202
    return ((void *)0);
  } else
#line 200
  if (size___1 == 0UL) {
#line 202
    return ((void *)0);
  }
  {
#line 204
  __cil_tmp3 = calloc(num, size___1);
  }
#line 204
  return (__cil_tmp3);
}
}
#line 207 "/root/patron-new/39/src/lib/openjp2/opj_malloc.c"
void *opj_aligned_malloc(size_t size___2 ) 
{ 
  void *__cil_tmp2___0 ;

  {
  {
#line 209
  __cil_tmp2___0 = opj_aligned_alloc_n((size_t )16U, size___2);
  }
#line 209
  return (__cil_tmp2___0);
}
}
#line 211 "/root/patron-new/39/src/lib/openjp2/opj_malloc.c"
void *opj_aligned_realloc(void *ptr___1 , size_t size___3 ) 
{ 
  void *__cil_tmp3___0 ;

  {
  {
#line 213
  __cil_tmp3___0 = opj_aligned_realloc_n(ptr___1, (size_t )16U, size___3);
  }
#line 213
  return (__cil_tmp3___0);
}
}
#line 216 "/root/patron-new/39/src/lib/openjp2/opj_malloc.c"
void *opj_aligned_32_malloc(size_t size___4 ) 
{ 
  void *__cil_tmp2___1 ;

  {
  {
#line 218
  __cil_tmp2___1 = opj_aligned_alloc_n((size_t )32U, size___4);
  }
#line 218
  return (__cil_tmp2___1);
}
}
#line 220 "/root/patron-new/39/src/lib/openjp2/opj_malloc.c"
void *opj_aligned_32_realloc(void *ptr___2 , size_t size___5 ) 
{ 
  void *__cil_tmp3___1 ;

  {
  {
#line 222
  __cil_tmp3___1 = opj_aligned_realloc_n(ptr___2, (size_t )32U, size___5);
  }
#line 222
  return (__cil_tmp3___1);
}
}
#line 225 "/root/patron-new/39/src/lib/openjp2/opj_malloc.c"
void opj_aligned_free(void *ptr___3 ) 
{ 


  {
  {
#line 228
  free(ptr___3);
  }
#line 230
  return;
}
}
#line 239 "/root/patron-new/39/src/lib/openjp2/opj_malloc.c"
void *opj_realloc(void *ptr___4 , size_t new_size___0 ) 
{ 
  void *__cil_tmp3___2 ;

  {
#line 241
  if (new_size___0 == 0UL) {
#line 242
    return ((void *)0);
  }
  {
#line 244
  __cil_tmp3___2 = realloc(ptr___4, new_size___0);
  }
#line 244
  return (__cil_tmp3___2);
}
}
#line 246 "/root/patron-new/39/src/lib/openjp2/opj_malloc.c"
void opj_free(void *ptr___5 ) 
{ 


  {
  {
#line 248
  free(ptr___5);
  }
#line 250
  return;
}
}
#line 87 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int getrusage(__rusage_who_t __who , struct rusage *__usage ) ;
#line 42 "/root/patron-new/39/src/lib/openjp2/opj_clock.c"
OPJ_FLOAT64 opj_clock(void) 
{ 
  struct rusage t ;
  OPJ_FLOAT64 procTime ;

  {
  {
#line 58
  getrusage(0, & t);
#line 61
  procTime = (OPJ_FLOAT64 )(t.ru_utime.tv_sec + t.ru_stime.tv_sec);
  }
#line 63
  return (procTime + (OPJ_FLOAT64 )(t.ru_utime.tv_usec + t.ru_stime.tv_usec) * 1e-06);
}
}
#line 44 "/root/patron-new/39/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_set_info_handler(opj_codec_t *p_codec , void (*p_callback)(char const   * ,
                                                                        void * ) ,
                              void *p_user_data ) 
{ 
  opj_codec_private_t *l_codec ;

  {
#line 48
  l_codec = (opj_codec_private_t *)p_codec;
#line 49
  if (! l_codec) {
#line 50
    return (0);
  }
#line 53
  l_codec->m_event_mgr.info_handler = p_callback;
#line 54
  l_codec->m_event_mgr.m_info_data = p_user_data;
#line 56
  return (1);
}
}
#line 59 "/root/patron-new/39/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_set_warning_handler(opj_codec_t *p_codec___0 , void (*p_callback___0)(char const   * ,
                                                                                   void * ) ,
                                 void *p_user_data___0 ) 
{ 
  opj_codec_private_t *l_codec___0 ;

  {
#line 63
  l_codec___0 = (opj_codec_private_t *)p_codec___0;
#line 64
  if (! l_codec___0) {
#line 65
    return (0);
  }
#line 68
  l_codec___0->m_event_mgr.warning_handler = p_callback___0;
#line 69
  l_codec___0->m_event_mgr.m_warning_data = p_user_data___0;
#line 71
  return (1);
}
}
#line 74 "/root/patron-new/39/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_set_error_handler(opj_codec_t *p_codec___1 , void (*p_callback___1)(char const   * ,
                                                                                 void * ) ,
                               void *p_user_data___1 ) 
{ 
  opj_codec_private_t *l_codec___1 ;

  {
#line 78
  l_codec___1 = (opj_codec_private_t *)p_codec___1;
#line 79
  if (! l_codec___1) {
#line 80
    return (0);
  }
#line 83
  l_codec___1->m_event_mgr.error_handler = p_callback___1;
#line 84
  l_codec___1->m_event_mgr.m_error_data = p_user_data___1;
#line 86
  return (1);
}
}
#line 91 "/root/patron-new/39/src/lib/openjp2/openjpeg.c"
static OPJ_SIZE_T opj_read_from_file(void *p_buffer , OPJ_SIZE_T p_nb_bytes , FILE *p_file ) 
{ 
  OPJ_SIZE_T l_nb_read ;
  unsigned long __cil_tmp5 ;
  OPJ_SIZE_T tmp___3 ;

  {
  {
#line 94
  __cil_tmp5 = fread(p_buffer, 1UL, p_nb_bytes, p_file);
#line 94
  l_nb_read = __cil_tmp5;
  }
#line 95
  if (l_nb_read) {
#line 95
    tmp___3 = l_nb_read;
  } else {
#line 95
    tmp___3 = (OPJ_SIZE_T )-1;
  }
#line 95
  return (tmp___3);
}
}
#line 98 "/root/patron-new/39/src/lib/openjp2/openjpeg.c"
static OPJ_UINT64 opj_get_data_length_from_file(FILE *p_file___0 ) 
{ 
  OPJ_OFF_T file_length ;
  __off_t __cil_tmp3___3 ;

  {
  {
#line 100
  file_length = (OPJ_OFF_T )0;
#line 102
  fseeko(p_file___0, (__off_t )0, 2);
#line 103
  __cil_tmp3___3 = ftello(p_file___0);
#line 103
  file_length = __cil_tmp3___3;
#line 104
  fseeko(p_file___0, (__off_t )0, 0);
  }
#line 106
  return ((OPJ_UINT64 )file_length);
}
}
#line 109 "/root/patron-new/39/src/lib/openjp2/openjpeg.c"
static OPJ_SIZE_T opj_write_from_file(void *p_buffer___0 , OPJ_SIZE_T p_nb_bytes___0 ,
                                      FILE *p_file___1 ) 
{ 
  unsigned long __cil_tmp4 ;

  {
  {
#line 112
  __cil_tmp4 = fwrite((void const   *)p_buffer___0, 1UL, p_nb_bytes___0, p_file___1);
  }
#line 112
  return (__cil_tmp4);
}
}
#line 115 "/root/patron-new/39/src/lib/openjp2/openjpeg.c"
static OPJ_OFF_T opj_skip_from_file(OPJ_OFF_T p_nb_bytes___1 , FILE *p_user_data___2 ) 
{ 
  int __cil_tmp3___4 ;

  {
  {
#line 117
  __cil_tmp3___4 = fseeko(p_user_data___2, p_nb_bytes___1, 1);
  }
#line 117
  if (__cil_tmp3___4) {
#line 118
    return ((OPJ_OFF_T )-1);
  }
#line 121
  return (p_nb_bytes___1);
}
}
#line 124 "/root/patron-new/39/src/lib/openjp2/openjpeg.c"
static OPJ_BOOL opj_seek_from_file(OPJ_OFF_T p_nb_bytes___2 , FILE *p_user_data___3 ) 
{ 
  int __cil_tmp3___5 ;

  {
  {
#line 126
  __cil_tmp3___5 = fseeko(p_user_data___3, p_nb_bytes___2, 0);
  }
#line 126
  if (__cil_tmp3___5) {
#line 127
    return (0);
  }
#line 130
  return (1);
}
}
#line 160 "/root/patron-new/39/src/lib/openjp2/openjpeg.c"
char const   *opj_version(void) 
{ 


  {
#line 162
  return ("2.3.1U");
}
}
#line 168 "/root/patron-new/39/src/lib/openjp2/openjpeg.c"
opj_codec_t *opj_create_decompress(OPJ_CODEC_FORMAT p_format ) 
{ 
  opj_codec_private_t *l_codec___2 ;
  void *__cil_tmp3___6 ;
  opj_j2k_t *tmp___4 ;
  opj_jp2_t *tmp___5 ;

  {
  {
#line 170
  l_codec___2 = (opj_codec_private_t *)0;
#line 172
  __cil_tmp3___6 = opj_calloc((size_t )1, sizeof(opj_codec_private_t ));
#line 172
  l_codec___2 = (opj_codec_private_t *)__cil_tmp3___6;
  }
#line 173
  if (! l_codec___2) {
#line 174
    return ((opj_codec_t *)0);
  }
#line 177
  l_codec___2->is_decompressor = 1;
#line 180
  if ((int )p_format == 0) {
#line 180
    goto case_0;
  }
#line 266
  if ((int )p_format == 2) {
#line 266
    goto case_2;
  }
#line 355
  goto switch_default;
  case_0: 
  {
#line 181
  l_codec___2->opj_dump_codec = (void (*)(void * , OPJ_INT32  , FILE * ))(& j2k_dump);
#line 183
  l_codec___2->opj_get_codec_info = (opj_codestream_info_v2_t *(*)(void * ))(& j2k_get_cstr_info);
#line 186
  l_codec___2->opj_get_codec_index = (opj_codestream_index_t *(*)(void * ))(& j2k_get_cstr_index);
#line 189
  l_codec___2->m_codec_data.m_decompression.opj_decode = (OPJ_BOOL (*)(void * , struct opj_stream_private * ,
                                                                       opj_image_t * ,
                                                                       struct opj_event_mgr * ))(& opj_j2k_decode);
#line 194
  l_codec___2->m_codec_data.m_decompression.opj_end_decompress = (OPJ_BOOL (*)(void * ,
                                                                               struct opj_stream_private * ,
                                                                               struct opj_event_mgr * ))(& opj_j2k_end_decompress);
#line 199
  l_codec___2->m_codec_data.m_decompression.opj_read_header = (OPJ_BOOL (*)(struct opj_stream_private * ,
                                                                            void * ,
                                                                            opj_image_t ** ,
                                                                            struct opj_event_mgr * ))(& opj_j2k_read_header);
#line 205
  l_codec___2->m_codec_data.m_decompression.opj_destroy = (void (*)(void * ))(& opj_j2k_destroy);
#line 208
  l_codec___2->m_codec_data.m_decompression.opj_setup_decoder = (void (*)(void * ,
                                                                          opj_dparameters_t * ))(& opj_j2k_setup_decoder);
#line 211
  l_codec___2->m_codec_data.m_decompression.opj_read_tile_header = (OPJ_BOOL (*)(void * ,
                                                                                 OPJ_UINT32 * ,
                                                                                 OPJ_UINT32 * ,
                                                                                 OPJ_INT32 * ,
                                                                                 OPJ_INT32 * ,
                                                                                 OPJ_INT32 * ,
                                                                                 OPJ_INT32 * ,
                                                                                 OPJ_UINT32 * ,
                                                                                 OPJ_BOOL * ,
                                                                                 struct opj_stream_private * ,
                                                                                 struct opj_event_mgr * ))(& opj_j2k_read_tile_header);
#line 222
  l_codec___2->m_codec_data.m_decompression.opj_decode_tile_data = (OPJ_BOOL (*)(void * ,
                                                                                 OPJ_UINT32  ,
                                                                                 OPJ_BYTE * ,
                                                                                 OPJ_UINT32  ,
                                                                                 struct opj_stream_private * ,
                                                                                 struct opj_event_mgr * ))(& opj_j2k_decode_tile);
#line 230
  l_codec___2->m_codec_data.m_decompression.opj_set_decode_area = (OPJ_BOOL (*)(void * ,
                                                                                opj_image_t * ,
                                                                                OPJ_INT32  ,
                                                                                OPJ_INT32  ,
                                                                                OPJ_INT32  ,
                                                                                OPJ_INT32  ,
                                                                                struct opj_event_mgr * ))(& opj_j2k_set_decode_area);
#line 236
  l_codec___2->m_codec_data.m_decompression.opj_get_decoded_tile = (OPJ_BOOL (*)(void * ,
                                                                                 opj_stream_private_t * ,
                                                                                 opj_image_t * ,
                                                                                 struct opj_event_mgr * ,
                                                                                 OPJ_UINT32  ))(& opj_j2k_get_tile);
#line 243
  l_codec___2->m_codec_data.m_decompression.opj_set_decoded_resolution_factor = (OPJ_BOOL (*)(void * ,
                                                                                              OPJ_UINT32  ,
                                                                                              struct opj_event_mgr * ))(& opj_j2k_set_decoded_resolution_factor);
#line 248
  l_codec___2->m_codec_data.m_decompression.opj_set_decoded_components = (OPJ_BOOL (*)(void * ,
                                                                                       OPJ_UINT32  ,
                                                                                       OPJ_UINT32 * ,
                                                                                       struct opj_event_mgr * ))(& opj_j2k_set_decoded_components);
#line 254
  l_codec___2->opj_set_threads = (OPJ_BOOL (*)(void * , OPJ_UINT32  ))(& opj_j2k_set_threads);
#line 257
  tmp___4 = opj_j2k_create_decompress();
#line 257
  l_codec___2->m_codec = (void *)tmp___4;
  }
#line 259
  if (! l_codec___2->m_codec) {
    {
#line 260
    opj_free((void *)l_codec___2);
    }
#line 261
    return ((opj_codec_t *)((void *)0));
  }
#line 264
  goto switch_break;
  case_2: 
  {
#line 268
  l_codec___2->opj_dump_codec = (void (*)(void * , OPJ_INT32  , FILE * ))(& jp2_dump);
#line 270
  l_codec___2->opj_get_codec_info = (opj_codestream_info_v2_t *(*)(void * ))(& jp2_get_cstr_info);
#line 273
  l_codec___2->opj_get_codec_index = (opj_codestream_index_t *(*)(void * ))(& jp2_get_cstr_index);
#line 276
  l_codec___2->m_codec_data.m_decompression.opj_decode = (OPJ_BOOL (*)(void * , struct opj_stream_private * ,
                                                                       opj_image_t * ,
                                                                       struct opj_event_mgr * ))(& opj_jp2_decode);
#line 282
  l_codec___2->m_codec_data.m_decompression.opj_end_decompress = (OPJ_BOOL (*)(void * ,
                                                                               struct opj_stream_private * ,
                                                                               struct opj_event_mgr * ))(& opj_jp2_end_decompress);
#line 287
  l_codec___2->m_codec_data.m_decompression.opj_read_header = (OPJ_BOOL (*)(struct opj_stream_private * ,
                                                                            void * ,
                                                                            opj_image_t ** ,
                                                                            struct opj_event_mgr * ))(& opj_jp2_read_header);
#line 293
  l_codec___2->m_codec_data.m_decompression.opj_read_tile_header = (OPJ_BOOL (*)(void * ,
                                                                                 OPJ_UINT32 * ,
                                                                                 OPJ_UINT32 * ,
                                                                                 OPJ_INT32 * ,
                                                                                 OPJ_INT32 * ,
                                                                                 OPJ_INT32 * ,
                                                                                 OPJ_INT32 * ,
                                                                                 OPJ_UINT32 * ,
                                                                                 OPJ_BOOL * ,
                                                                                 struct opj_stream_private * ,
                                                                                 struct opj_event_mgr * ))(& opj_jp2_read_tile_header);
#line 306
  l_codec___2->m_codec_data.m_decompression.opj_decode_tile_data = (OPJ_BOOL (*)(void * ,
                                                                                 OPJ_UINT32  ,
                                                                                 OPJ_BYTE * ,
                                                                                 OPJ_UINT32  ,
                                                                                 struct opj_stream_private * ,
                                                                                 struct opj_event_mgr * ))(& opj_jp2_decode_tile);
#line 312
  l_codec___2->m_codec_data.m_decompression.opj_destroy = (void (*)(void * ))(& opj_jp2_destroy);
#line 315
  l_codec___2->m_codec_data.m_decompression.opj_setup_decoder = (void (*)(void * ,
                                                                          opj_dparameters_t * ))(& opj_jp2_setup_decoder);
#line 318
  l_codec___2->m_codec_data.m_decompression.opj_set_decode_area = (OPJ_BOOL (*)(void * ,
                                                                                opj_image_t * ,
                                                                                OPJ_INT32  ,
                                                                                OPJ_INT32  ,
                                                                                OPJ_INT32  ,
                                                                                OPJ_INT32  ,
                                                                                struct opj_event_mgr * ))(& opj_jp2_set_decode_area);
#line 324
  l_codec___2->m_codec_data.m_decompression.opj_get_decoded_tile = (OPJ_BOOL (*)(void * ,
                                                                                 opj_stream_private_t * ,
                                                                                 opj_image_t * ,
                                                                                 struct opj_event_mgr * ,
                                                                                 OPJ_UINT32  ))(& opj_jp2_get_tile);
#line 331
  l_codec___2->m_codec_data.m_decompression.opj_set_decoded_resolution_factor = (OPJ_BOOL (*)(void * ,
                                                                                              OPJ_UINT32  ,
                                                                                              opj_event_mgr_t * ))(& opj_jp2_set_decoded_resolution_factor);
#line 336
  l_codec___2->m_codec_data.m_decompression.opj_set_decoded_components = (OPJ_BOOL (*)(void * ,
                                                                                       OPJ_UINT32  ,
                                                                                       OPJ_UINT32 * ,
                                                                                       struct opj_event_mgr * ))(& opj_jp2_set_decoded_components);
#line 342
  l_codec___2->opj_set_threads = (OPJ_BOOL (*)(void * , OPJ_UINT32  ))(& opj_jp2_set_threads);
#line 345
  tmp___5 = opj_jp2_create(1);
#line 345
  l_codec___2->m_codec = (void *)tmp___5;
  }
#line 347
  if (! l_codec___2->m_codec) {
    {
#line 348
    opj_free((void *)l_codec___2);
    }
#line 349
    return ((opj_codec_t *)0);
  }
#line 352
  goto switch_break;
  switch_default: 
  {
#line 356
  opj_free((void *)l_codec___2);
  }
#line 357
  return ((opj_codec_t *)0);
  switch_break: 
  {
#line 360
  opj_set_default_event_handler(& l_codec___2->m_event_mgr);
  }
#line 361
  return ((opj_codec_t *)l_codec___2);
}
}
#line 364 "/root/patron-new/39/src/lib/openjp2/openjpeg.c"
void opj_set_default_decoder_parameters(opj_dparameters_t *parameters ) 
{ 


  {
#line 367
  if (parameters) {
    {
#line 368
    memset((void *)parameters, 0, sizeof(opj_dparameters_t ));
#line 370
    parameters->cp_layer = (OPJ_UINT32 )0;
#line 371
    parameters->cp_reduce = (OPJ_UINT32 )0;
#line 373
    parameters->decod_format = -1;
#line 374
    parameters->cod_format = -1;
#line 375
    parameters->flags = 0U;
    }
  }
#line 378
  return;
}
}
#line 387 "/root/patron-new/39/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_codec_set_threads(opj_codec_t *p_codec___2 , int num_threads ) 
{ 
  opj_codec_private_t *l_codec___3 ;
  OPJ_BOOL __cil_tmp4___1 ;

  {
#line 390
  if (p_codec___2) {
#line 390
    if (num_threads >= 0) {
      {
#line 391
      l_codec___3 = (opj_codec_private_t *)p_codec___2;
#line 393
      __cil_tmp4___1 = (*(l_codec___3->opj_set_threads))(l_codec___3->m_codec, (OPJ_UINT32 )num_threads);
      }
#line 393
      return (__cil_tmp4___1);
    }
  }
#line 395
  return (0);
}
}
#line 398 "/root/patron-new/39/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_setup_decoder(opj_codec_t *p_codec___3 , opj_dparameters_t *parameters___0 ) 
{ 
  opj_codec_private_t *l_codec___4 ;

  {
#line 402
  if (p_codec___3) {
#line 402
    if (parameters___0) {
#line 403
      l_codec___4 = (opj_codec_private_t *)p_codec___3;
#line 405
      if (! l_codec___4->is_decompressor) {
        {
#line 406
        opj_event_msg(& l_codec___4->m_event_mgr, 1, "Codec provided to the opj_setup_decoder function is not a decompressor handler.\n0a.\005]U");
        }
#line 408
        return (0);
      }
      {
#line 411
      (*(l_codec___4->m_codec_data.m_decompression.opj_setup_decoder))(l_codec___4->m_codec,
                                                                       parameters___0);
      }
#line 413
      return (1);
    }
  }
#line 415
  return (0);
}
}
#line 418 "/root/patron-new/39/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_read_header(opj_stream_t *p_stream , opj_codec_t *p_codec___4 , opj_image_t **p_image ) 
{ 
  opj_codec_private_t *l_codec___5 ;
  opj_stream_private_t *l_stream ;
  OPJ_BOOL __cil_tmp6___0 ;

  {
#line 422
  if (p_codec___4) {
#line 422
    if (p_stream) {
#line 423
      l_codec___5 = (opj_codec_private_t *)p_codec___4;
#line 424
      l_stream = (opj_stream_private_t *)p_stream;
#line 426
      if (! l_codec___5->is_decompressor) {
        {
#line 427
        opj_event_msg(& l_codec___5->m_event_mgr, 1, "Codec provided to the opj_read_header function is not a decompressor handler.\n");
        }
#line 429
        return (0);
      }
      {
#line 432
      __cil_tmp6___0 = (*(l_codec___5->m_codec_data.m_decompression.opj_read_header))(l_stream,
                                                                                      l_codec___5->m_codec,
                                                                                      p_image,
                                                                                      & l_codec___5->m_event_mgr);
      }
#line 432
      return (__cil_tmp6___0);
    }
  }
#line 438
  return (0);
}
}
#line 442 "/root/patron-new/39/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_set_decoded_components(opj_codec_t *p_codec___5 , OPJ_UINT32 numcomps ,
                                    OPJ_UINT32 *comps_indices , OPJ_BOOL apply_color_transforms ) 
{ 
  opj_codec_private_t *l_codec___6 ;
  OPJ_BOOL __cil_tmp6___1 ;

  {
#line 447
  if (p_codec___5) {
#line 448
    l_codec___6 = (opj_codec_private_t *)p_codec___5;
#line 450
    if (! l_codec___6->is_decompressor) {
      {
#line 451
      opj_event_msg(& l_codec___6->m_event_mgr, 1, "Codec provided to the opj_set_decoded_components function is not a decompressor handler.\n");
      }
#line 453
      return (0);
    }
#line 456
    if (apply_color_transforms) {
      {
#line 457
      opj_event_msg(& l_codec___6->m_event_mgr, 1, "apply_color_transforms = OPJ_TRUE is not supported.\n]U");
      }
#line 459
      return (0);
    }
    {
#line 462
    __cil_tmp6___1 = (*(l_codec___6->m_codec_data.m_decompression.opj_set_decoded_components))(l_codec___6->m_codec,
                                                                                               numcomps,
                                                                                               comps_indices,
                                                                                               & l_codec___6->m_event_mgr);
    }
#line 462
    return (__cil_tmp6___1);
  }
#line 468
  return (0);
}
}
#line 471 "/root/patron-new/39/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_decode(opj_codec_t *p_codec___6 , opj_stream_t *p_stream___0 , opj_image_t *p_image___0 ) 
{ 
  opj_codec_private_t *l_codec___7 ;
  opj_stream_private_t *l_stream___0 ;
  OPJ_BOOL __cil_tmp6___2 ;

  {
#line 475
  if (p_codec___6) {
#line 475
    if (p_stream___0) {
#line 476
      l_codec___7 = (opj_codec_private_t *)p_codec___6;
#line 477
      l_stream___0 = (opj_stream_private_t *)p_stream___0;
#line 479
      if (! l_codec___7->is_decompressor) {
#line 480
        return (0);
      }
      {
#line 483
      __cil_tmp6___2 = (*(l_codec___7->m_codec_data.m_decompression.opj_decode))(l_codec___7->m_codec,
                                                                                 l_stream___0,
                                                                                 p_image___0,
                                                                                 & l_codec___7->m_event_mgr);
      }
#line 483
      return (__cil_tmp6___2);
    }
  }
#line 489
  return (0);
}
}
#line 492 "/root/patron-new/39/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_set_decode_area(opj_codec_t *p_codec___7 , opj_image_t *p_image___1 ,
                             OPJ_INT32 p_start_x , OPJ_INT32 p_start_y , OPJ_INT32 p_end_x ,
                             OPJ_INT32 p_end_y ) 
{ 
  opj_codec_private_t *l_codec___8 ;
  OPJ_BOOL __cil_tmp8 ;

  {
#line 498
  if (p_codec___7) {
#line 499
    l_codec___8 = (opj_codec_private_t *)p_codec___7;
#line 501
    if (! l_codec___8->is_decompressor) {
#line 502
      return (0);
    }
    {
#line 505
    __cil_tmp8 = (*(l_codec___8->m_codec_data.m_decompression.opj_set_decode_area))(l_codec___8->m_codec,
                                                                                    p_image___1,
                                                                                    p_start_x,
                                                                                    p_start_y,
                                                                                    p_end_x,
                                                                                    p_end_y,
                                                                                    & l_codec___8->m_event_mgr);
    }
#line 505
    return (__cil_tmp8);
  }
#line 512
  return (0);
}
}
#line 515 "/root/patron-new/39/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_read_tile_header(opj_codec_t *p_codec___8 , opj_stream_t *p_stream___1 ,
                              OPJ_UINT32 *p_tile_index , OPJ_UINT32 *p_data_size ,
                              OPJ_INT32 *p_tile_x0 , OPJ_INT32 *p_tile_y0 , OPJ_INT32 *p_tile_x1 ,
                              OPJ_INT32 *p_tile_y1 , OPJ_UINT32 *p_nb_comps , OPJ_BOOL *p_should_go_on ) 
{ 
  opj_codec_private_t *l_codec___9 ;
  opj_stream_private_t *l_stream___1 ;
  OPJ_BOOL __cil_tmp13 ;

  {
#line 524
  if (p_codec___8) {
#line 524
    if (p_stream___1) {
#line 524
      if (p_data_size) {
#line 524
        if (p_tile_index) {
#line 525
          l_codec___9 = (opj_codec_private_t *)p_codec___8;
#line 526
          l_stream___1 = (opj_stream_private_t *)p_stream___1;
#line 528
          if (! l_codec___9->is_decompressor) {
#line 529
            return (0);
          }
          {
#line 532
          __cil_tmp13 = (*(l_codec___9->m_codec_data.m_decompression.opj_read_tile_header))(l_codec___9->m_codec,
                                                                                            p_tile_index,
                                                                                            p_data_size,
                                                                                            p_tile_x0,
                                                                                            p_tile_y0,
                                                                                            p_tile_x1,
                                                                                            p_tile_y1,
                                                                                            p_nb_comps,
                                                                                            p_should_go_on,
                                                                                            l_stream___1,
                                                                                            & l_codec___9->m_event_mgr);
          }
#line 532
          return (__cil_tmp13);
        }
      }
    }
  }
#line 543
  return (0);
}
}
#line 546 "/root/patron-new/39/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_decode_tile_data(opj_codec_t *p_codec___9 , OPJ_UINT32 p_tile_index___0 ,
                              OPJ_BYTE *p_data , OPJ_UINT32 p_data_size___0 , opj_stream_t *p_stream___2 ) 
{ 
  opj_codec_private_t *l_codec___10 ;
  opj_stream_private_t *l_stream___2 ;
  OPJ_BOOL __cil_tmp8___0 ;

  {
#line 553
  if (p_codec___9) {
#line 553
    if (p_data) {
#line 553
      if (p_stream___2) {
#line 554
        l_codec___10 = (opj_codec_private_t *)p_codec___9;
#line 555
        l_stream___2 = (opj_stream_private_t *)p_stream___2;
#line 557
        if (! l_codec___10->is_decompressor) {
#line 558
          return (0);
        }
        {
#line 561
        __cil_tmp8___0 = (*(l_codec___10->m_codec_data.m_decompression.opj_decode_tile_data))(l_codec___10->m_codec,
                                                                                              p_tile_index___0,
                                                                                              p_data,
                                                                                              p_data_size___0,
                                                                                              l_stream___2,
                                                                                              & l_codec___10->m_event_mgr);
        }
#line 561
        return (__cil_tmp8___0);
      }
    }
  }
#line 569
  return (0);
}
}
#line 572 "/root/patron-new/39/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_get_decoded_tile(opj_codec_t *p_codec___10 , opj_stream_t *p_stream___3 ,
                              opj_image_t *p_image___2 , OPJ_UINT32 tile_index ) 
{ 
  opj_codec_private_t *l_codec___11 ;
  opj_stream_private_t *l_stream___3 ;
  OPJ_BOOL __cil_tmp7___0 ;

  {
#line 577
  if (p_codec___10) {
#line 577
    if (p_stream___3) {
#line 578
      l_codec___11 = (opj_codec_private_t *)p_codec___10;
#line 579
      l_stream___3 = (opj_stream_private_t *)p_stream___3;
#line 581
      if (! l_codec___11->is_decompressor) {
#line 582
        return (0);
      }
      {
#line 585
      __cil_tmp7___0 = (*(l_codec___11->m_codec_data.m_decompression.opj_get_decoded_tile))(l_codec___11->m_codec,
                                                                                            l_stream___3,
                                                                                            p_image___2,
                                                                                            & l_codec___11->m_event_mgr,
                                                                                            tile_index);
      }
#line 585
      return (__cil_tmp7___0);
    }
  }
#line 593
  return (0);
}
}
#line 596 "/root/patron-new/39/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_set_decoded_resolution_factor(opj_codec_t *p_codec___11 , OPJ_UINT32 res_factor ) 
{ 
  opj_codec_private_t *l_codec___12 ;
  OPJ_BOOL __cil_tmp4___2 ;

  {
#line 599
  l_codec___12 = (opj_codec_private_t *)p_codec___11;
#line 601
  if (! l_codec___12) {
#line 602
    return (0);
  }
  {
#line 605
  __cil_tmp4___2 = (*(l_codec___12->m_codec_data.m_decompression.opj_set_decoded_resolution_factor))(l_codec___12->m_codec,
                                                                                                     res_factor,
                                                                                                     & l_codec___12->m_event_mgr);
  }
#line 605
  return (__cil_tmp4___2);
}
}
#line 614 "/root/patron-new/39/src/lib/openjp2/openjpeg.c"
opj_codec_t *opj_create_compress(OPJ_CODEC_FORMAT p_format___0 ) 
{ 
  opj_codec_private_t *l_codec___13 ;
  void *__cil_tmp3___7 ;
  opj_j2k_t *tmp___6 ;
  opj_jp2_t *tmp___7 ;

  {
  {
#line 616
  l_codec___13 = (opj_codec_private_t *)0;
#line 618
  __cil_tmp3___7 = opj_calloc((size_t )1, sizeof(opj_codec_private_t ));
#line 618
  l_codec___13 = (opj_codec_private_t *)__cil_tmp3___7;
  }
#line 619
  if (! l_codec___13) {
#line 620
    return ((opj_codec_t *)0);
  }
#line 623
  l_codec___13->is_decompressor = 0;
#line 626
  if ((int )p_format___0 == 0) {
#line 626
    goto case_0;
  }
#line 671
  if ((int )p_format___0 == 2) {
#line 671
    goto case_2;
  }
#line 719
  goto switch_default;
  case_0: 
  {
#line 627
  l_codec___13->m_codec_data.m_compression.opj_encode = (OPJ_BOOL (*)(void * , struct opj_stream_private * ,
                                                                      struct opj_event_mgr * ))(& opj_j2k_encode);
#line 631
  l_codec___13->m_codec_data.m_compression.opj_end_compress = (OPJ_BOOL (*)(void * ,
                                                                            struct opj_stream_private * ,
                                                                            struct opj_event_mgr * ))(& opj_j2k_end_compress);
#line 635
  l_codec___13->m_codec_data.m_compression.opj_start_compress = (OPJ_BOOL (*)(void * ,
                                                                              struct opj_stream_private * ,
                                                                              struct opj_image * ,
                                                                              struct opj_event_mgr * ))(& opj_j2k_start_compress);
#line 640
  l_codec___13->m_codec_data.m_compression.opj_write_tile = (OPJ_BOOL (*)(void * ,
                                                                          OPJ_UINT32  ,
                                                                          OPJ_BYTE * ,
                                                                          OPJ_UINT32  ,
                                                                          struct opj_stream_private * ,
                                                                          struct opj_event_mgr * ))(& opj_j2k_write_tile);
#line 647
  l_codec___13->m_codec_data.m_compression.opj_destroy = (void (*)(void * ))(& opj_j2k_destroy);
#line 650
  l_codec___13->m_codec_data.m_compression.opj_setup_encoder = (OPJ_BOOL (*)(void * ,
                                                                             opj_cparameters_t * ,
                                                                             struct opj_image * ,
                                                                             struct opj_event_mgr * ))(& opj_j2k_setup_encoder);
#line 655
  l_codec___13->m_codec_data.m_compression.opj_encoder_set_extra_options = (OPJ_BOOL (*)(void * ,
                                                                                         char const   * const  * ,
                                                                                         struct opj_event_mgr * ))(& opj_j2k_encoder_set_extra_options);
#line 660
  l_codec___13->opj_set_threads = (OPJ_BOOL (*)(void * , OPJ_UINT32  ))(& opj_j2k_set_threads);
#line 663
  tmp___6 = opj_j2k_create_compress();
#line 663
  l_codec___13->m_codec = (void *)tmp___6;
  }
#line 664
  if (! l_codec___13->m_codec) {
    {
#line 665
    opj_free((void *)l_codec___13);
    }
#line 666
    return ((opj_codec_t *)0);
  }
#line 669
  goto switch_break;
  case_2: 
  {
#line 673
  l_codec___13->m_codec_data.m_compression.opj_encode = (OPJ_BOOL (*)(void * , struct opj_stream_private * ,
                                                                      struct opj_event_mgr * ))(& opj_jp2_encode);
#line 677
  l_codec___13->m_codec_data.m_compression.opj_end_compress = (OPJ_BOOL (*)(void * ,
                                                                            struct opj_stream_private * ,
                                                                            struct opj_event_mgr * ))(& opj_jp2_end_compress);
#line 681
  l_codec___13->m_codec_data.m_compression.opj_start_compress = (OPJ_BOOL (*)(void * ,
                                                                              struct opj_stream_private * ,
                                                                              struct opj_image * ,
                                                                              struct opj_event_mgr * ))(& opj_jp2_start_compress);
#line 686
  l_codec___13->m_codec_data.m_compression.opj_write_tile = (OPJ_BOOL (*)(void * ,
                                                                          OPJ_UINT32  ,
                                                                          OPJ_BYTE * ,
                                                                          OPJ_UINT32  ,
                                                                          struct opj_stream_private * ,
                                                                          struct opj_event_mgr * ))(& opj_jp2_write_tile);
#line 693
  l_codec___13->m_codec_data.m_compression.opj_destroy = (void (*)(void * ))(& opj_jp2_destroy);
#line 696
  l_codec___13->m_codec_data.m_compression.opj_setup_encoder = (OPJ_BOOL (*)(void * ,
                                                                             opj_cparameters_t * ,
                                                                             struct opj_image * ,
                                                                             struct opj_event_mgr * ))(& opj_jp2_setup_encoder);
#line 701
  l_codec___13->m_codec_data.m_compression.opj_encoder_set_extra_options = (OPJ_BOOL (*)(void * ,
                                                                                         char const   * const  * ,
                                                                                         struct opj_event_mgr * ))(& opj_jp2_encoder_set_extra_options);
#line 706
  l_codec___13->opj_set_threads = (OPJ_BOOL (*)(void * , OPJ_UINT32  ))(& opj_jp2_set_threads);
#line 709
  tmp___7 = opj_jp2_create(0);
#line 709
  l_codec___13->m_codec = (void *)tmp___7;
  }
#line 710
  if (! l_codec___13->m_codec) {
    {
#line 711
    opj_free((void *)l_codec___13);
    }
#line 712
    return ((opj_codec_t *)0);
  }
#line 715
  goto switch_break;
  switch_default: 
  {
#line 720
  opj_free((void *)l_codec___13);
  }
#line 721
  return ((opj_codec_t *)0);
  switch_break: 
  {
#line 724
  opj_set_default_event_handler(& l_codec___13->m_event_mgr);
  }
#line 725
  return ((opj_codec_t *)l_codec___13);
}
}
#line 728 "/root/patron-new/39/src/lib/openjp2/openjpeg.c"
void opj_set_default_encoder_parameters(opj_cparameters_t *parameters___1 ) 
{ 


  {
#line 731
  if (parameters___1) {
    {
#line 732
    memset((void *)parameters___1, 0, sizeof(opj_cparameters_t ));
#line 734
    parameters___1->cp_cinema = (OPJ_CINEMA_MODE )0;
#line 735
    parameters___1->rsiz = (OPJ_UINT16 )0;
#line 736
    parameters___1->max_comp_size = 0;
#line 737
    parameters___1->numresolution = 6;
#line 738
    parameters___1->cp_rsiz = (OPJ_RSIZ_CAPABILITIES )0;
#line 739
    parameters___1->cblockw_init = 64;
#line 740
    parameters___1->cblockh_init = 64;
#line 741
    parameters___1->prog_order = (OPJ_PROG_ORDER )0;
#line 742
    parameters___1->roi_compno = -1;
#line 743
    parameters___1->subsampling_dx = 1;
#line 744
    parameters___1->subsampling_dy = 1;
#line 745
    parameters___1->tp_on = (char)0;
#line 746
    parameters___1->decod_format = -1;
#line 747
    parameters___1->cod_format = -1;
#line 748
    parameters___1->tcp_rates[0] = (float )0;
#line 749
    parameters___1->tcp_numlayers = 0;
#line 750
    parameters___1->cp_disto_alloc = 0;
#line 751
    parameters___1->cp_fixed_alloc = 0;
#line 752
    parameters___1->cp_fixed_quality = 0;
#line 753
    parameters___1->jpip_on = 0;
    }
  }
#line 756
  return;
}
}
#line 789 "/root/patron-new/39/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_setup_encoder(opj_codec_t *p_codec___12 , opj_cparameters_t *parameters___2 ,
                           opj_image_t *p_image___3 ) 
{ 
  opj_codec_private_t *l_codec___14 ;
  OPJ_BOOL __cil_tmp5___2 ;

  {
#line 793
  if (p_codec___12) {
#line 793
    if (parameters___2) {
#line 793
      if (p_image___3) {
#line 794
        l_codec___14 = (opj_codec_private_t *)p_codec___12;
#line 796
        if (! l_codec___14->is_decompressor) {
          {
#line 797
          __cil_tmp5___2 = (*(l_codec___14->m_codec_data.m_compression.opj_setup_encoder))(l_codec___14->m_codec,
                                                                                           parameters___2,
                                                                                           p_image___3,
                                                                                           & l_codec___14->m_event_mgr);
          }
#line 797
          return (__cil_tmp5___2);
        }
      }
    }
  }
#line 804
  return (0);
}
}
#line 809 "/root/patron-new/39/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_encoder_set_extra_options(opj_codec_t *p_codec___13 , char const   * const  *options ) 
{ 
  opj_codec_private_t *l_codec___15 ;
  OPJ_BOOL __cil_tmp4___4 ;

  {
#line 812
  if (p_codec___13) {
#line 813
    l_codec___15 = (opj_codec_private_t *)p_codec___13;
#line 815
    if (! l_codec___15->is_decompressor) {
      {
#line 816
      __cil_tmp4___4 = (*(l_codec___15->m_codec_data.m_compression.opj_encoder_set_extra_options))(l_codec___15->m_codec,
                                                                                                   options,
                                                                                                   & l_codec___15->m_event_mgr);
      }
#line 816
      return (__cil_tmp4___4);
    }
  }
#line 823
  return (0);
}
}
#line 828 "/root/patron-new/39/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_start_compress(opj_codec_t *p_codec___14 , opj_image_t *p_image___4 ,
                            opj_stream_t *p_stream___4 ) 
{ 
  opj_codec_private_t *l_codec___16 ;
  opj_stream_private_t *l_stream___4 ;
  OPJ_BOOL __cil_tmp6___3 ;

  {
#line 832
  if (p_codec___14) {
#line 832
    if (p_stream___4) {
#line 833
      l_codec___16 = (opj_codec_private_t *)p_codec___14;
#line 834
      l_stream___4 = (opj_stream_private_t *)p_stream___4;
#line 836
      if (! l_codec___16->is_decompressor) {
        {
#line 837
        __cil_tmp6___3 = (*(l_codec___16->m_codec_data.m_compression.opj_start_compress))(l_codec___16->m_codec,
                                                                                          l_stream___4,
                                                                                          p_image___4,
                                                                                          & l_codec___16->m_event_mgr);
        }
#line 837
        return (__cil_tmp6___3);
      }
    }
  }
#line 844
  return (0);
}
}
#line 847 "/root/patron-new/39/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_encode(opj_codec_t *p_info , opj_stream_t *p_stream___5 ) 
{ 
  opj_codec_private_t *l_codec___17 ;
  opj_stream_private_t *l_stream___5 ;
  OPJ_BOOL __cil_tmp5___3 ;

  {
#line 849
  if (p_info) {
#line 849
    if (p_stream___5) {
#line 850
      l_codec___17 = (opj_codec_private_t *)p_info;
#line 851
      l_stream___5 = (opj_stream_private_t *)p_stream___5;
#line 853
      if (! l_codec___17->is_decompressor) {
        {
#line 854
        __cil_tmp5___3 = (*(l_codec___17->m_codec_data.m_compression.opj_encode))(l_codec___17->m_codec,
                                                                                  l_stream___5,
                                                                                  & l_codec___17->m_event_mgr);
        }
#line 854
        return (__cil_tmp5___3);
      }
    }
  }
#line 860
  return (0);
}
}
#line 864 "/root/patron-new/39/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_end_compress(opj_codec_t *p_codec___15 , opj_stream_t *p_stream___6 ) 
{ 
  opj_codec_private_t *l_codec___18 ;
  opj_stream_private_t *l_stream___6 ;
  OPJ_BOOL __cil_tmp5___4 ;

  {
#line 867
  if (p_codec___15) {
#line 867
    if (p_stream___6) {
#line 868
      l_codec___18 = (opj_codec_private_t *)p_codec___15;
#line 869
      l_stream___6 = (opj_stream_private_t *)p_stream___6;
#line 871
      if (! l_codec___18->is_decompressor) {
        {
#line 872
        __cil_tmp5___4 = (*(l_codec___18->m_codec_data.m_compression.opj_end_compress))(l_codec___18->m_codec,
                                                                                        l_stream___6,
                                                                                        & l_codec___18->m_event_mgr);
        }
#line 872
        return (__cil_tmp5___4);
      }
    }
  }
#line 877
  return (0);
}
}
#line 881 "/root/patron-new/39/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_end_decompress(opj_codec_t *p_codec___16 , opj_stream_t *p_stream___7 ) 
{ 
  opj_codec_private_t *l_codec___19 ;
  opj_stream_private_t *l_stream___7 ;
  OPJ_BOOL __cil_tmp5___5 ;

  {
#line 884
  if (p_codec___16) {
#line 884
    if (p_stream___7) {
#line 885
      l_codec___19 = (opj_codec_private_t *)p_codec___16;
#line 886
      l_stream___7 = (opj_stream_private_t *)p_stream___7;
#line 888
      if (! l_codec___19->is_decompressor) {
#line 889
        return (0);
      }
      {
#line 892
      __cil_tmp5___5 = (*(l_codec___19->m_codec_data.m_decompression.opj_end_decompress))(l_codec___19->m_codec,
                                                                                          l_stream___7,
                                                                                          & l_codec___19->m_event_mgr);
      }
#line 892
      return (__cil_tmp5___5);
    }
  }
#line 898
  return (0);
}
}
#line 901 "/root/patron-new/39/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_set_MCT(opj_cparameters_t *parameters___3 , OPJ_FLOAT32 *pEncodingMatrix ,
                     OPJ_INT32 *p_dc_shift , OPJ_UINT32 pNbComp ) 
{ 
  OPJ_UINT32 l_matrix_size ;
  OPJ_UINT32 l_dc_shift_size ;
  OPJ_UINT32 l_mct_total_size ;

  {
#line 905
  l_matrix_size = (pNbComp * pNbComp) * (OPJ_UINT32 )sizeof(OPJ_FLOAT32 );
#line 906
  l_dc_shift_size = pNbComp * (OPJ_UINT32 )sizeof(OPJ_INT32 );
#line 907
  l_mct_total_size = l_matrix_size + l_dc_shift_size;
#line 910
  if ((int )parameters___3->rsiz & 32768) {
#line 911
    parameters___3->rsiz = (OPJ_UINT16 )((int )parameters___3->rsiz | 256);
  } else {
#line 913
    parameters___3->rsiz = (OPJ_UINT16 )33024;
  }
  {
#line 915
  parameters___3->irreversible = 1;
#line 918
  parameters___3->tcp_mct = (char)2;
#line 919
  parameters___3->mct_data = opj_malloc((size_t )l_mct_total_size);
  }
#line 920
  if (! parameters___3->mct_data) {
#line 921
    return (0);
  }
  {
#line 924
  memcpy(parameters___3->mct_data, (void const   *)pEncodingMatrix, (unsigned long )l_matrix_size);
#line 925
  memcpy((void *)((OPJ_BYTE *)parameters___3->mct_data + l_matrix_size), (void const   *)p_dc_shift,
         (unsigned long )l_dc_shift_size);
  }
#line 928
  return (1);
}
}
#line 931 "/root/patron-new/39/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_write_tile(opj_codec_t *p_codec___17 , OPJ_UINT32 p_tile_index___1 ,
                        OPJ_BYTE *p_data___0 , OPJ_UINT32 p_data_size___1 , opj_stream_t *p_stream___8 ) 
{ 
  opj_codec_private_t *l_codec___20 ;
  opj_stream_private_t *l_stream___8 ;
  OPJ_BOOL __cil_tmp8___2 ;

  {
#line 937
  if (p_codec___17) {
#line 937
    if (p_stream___8) {
#line 937
      if (p_data___0) {
#line 938
        l_codec___20 = (opj_codec_private_t *)p_codec___17;
#line 939
        l_stream___8 = (opj_stream_private_t *)p_stream___8;
#line 941
        if (l_codec___20->is_decompressor) {
#line 942
          return (0);
        }
        {
#line 945
        __cil_tmp8___2 = (*(l_codec___20->m_codec_data.m_compression.opj_write_tile))(l_codec___20->m_codec,
                                                                                      p_tile_index___1,
                                                                                      p_data___0,
                                                                                      p_data_size___1,
                                                                                      l_stream___8,
                                                                                      & l_codec___20->m_event_mgr);
        }
#line 945
        return (__cil_tmp8___2);
      }
    }
  }
#line 953
  return (0);
}
}
#line 958 "/root/patron-new/39/src/lib/openjp2/openjpeg.c"
void opj_destroy_codec(opj_codec_t *p_codec___18 ) 
{ 
  opj_codec_private_t *l_codec___21 ;

  {
#line 960
  if (p_codec___18) {
#line 961
    l_codec___21 = (opj_codec_private_t *)p_codec___18;
#line 963
    if (l_codec___21->is_decompressor) {
      {
#line 964
      (*(l_codec___21->m_codec_data.m_decompression.opj_destroy))(l_codec___21->m_codec);
      }
    } else {
      {
#line 966
      (*(l_codec___21->m_codec_data.m_compression.opj_destroy))(l_codec___21->m_codec);
      }
    }
    {
#line 969
    l_codec___21->m_codec = (void *)0;
#line 970
    opj_free((void *)l_codec___21);
    }
  }
#line 973
  return;
}
}
#line 976 "/root/patron-new/39/src/lib/openjp2/openjpeg.c"
void opj_dump_codec(opj_codec_t *p_codec___19 , OPJ_INT32 info_flag , FILE *output_stream ) 
{ 
  opj_codec_private_t *l_codec___22 ;

  {
#line 980
  if (p_codec___19) {
    {
#line 981
    l_codec___22 = (opj_codec_private_t *)p_codec___19;
#line 983
    (*(l_codec___22->opj_dump_codec))(l_codec___22->m_codec, info_flag, output_stream);
    }
#line 984
    return;
  }
#line 989
  return;
}
}
#line 992 "/root/patron-new/39/src/lib/openjp2/openjpeg.c"
opj_codestream_info_v2_t *opj_get_cstr_info(opj_codec_t *p_codec___20 ) 
{ 
  opj_codec_private_t *l_codec___23 ;
  opj_codestream_info_v2_t *__cil_tmp3___8 ;

  {
#line 994
  if (p_codec___20) {
    {
#line 995
    l_codec___23 = (opj_codec_private_t *)p_codec___20;
#line 997
    __cil_tmp3___8 = (*(l_codec___23->opj_get_codec_info))(l_codec___23->m_codec);
    }
#line 997
    return (__cil_tmp3___8);
  }
#line 1000
  return ((opj_codestream_info_v2_t *)((void *)0));
}
}
#line 1003 "/root/patron-new/39/src/lib/openjp2/openjpeg.c"
void opj_destroy_cstr_info(opj_codestream_info_v2_t **cstr_info ) 
{ 


  {
#line 1005
  if (cstr_info) {
#line 1007
    if ((*cstr_info)->m_default_tile_info.tccp_info) {
      {
#line 1008
      opj_free((void *)(*cstr_info)->m_default_tile_info.tccp_info);
      }
    }
    {
#line 1015
    opj_free((void *)*cstr_info);
#line 1016
    *cstr_info = (opj_codestream_info_v2_t *)((void *)0);
    }
  }
#line 1019
  return;
}
}
#line 1020 "/root/patron-new/39/src/lib/openjp2/openjpeg.c"
opj_codestream_index_t *opj_get_cstr_index(opj_codec_t *p_codec___21 ) 
{ 
  opj_codec_private_t *l_codec___24 ;
  opj_codestream_index_t *__cil_tmp3___9 ;

  {
#line 1022
  if (p_codec___21) {
    {
#line 1023
    l_codec___24 = (opj_codec_private_t *)p_codec___21;
#line 1025
    __cil_tmp3___9 = (*(l_codec___24->opj_get_codec_index))(l_codec___24->m_codec);
    }
#line 1025
    return (__cil_tmp3___9);
  }
#line 1028
  return ((opj_codestream_index_t *)((void *)0));
}
}
#line 1031 "/root/patron-new/39/src/lib/openjp2/openjpeg.c"
void opj_destroy_cstr_index(opj_codestream_index_t **p_cstr_index ) 
{ 


  {
#line 1033
  if (*p_cstr_index) {
    {
#line 1034
    j2k_destroy_cstr_index(*p_cstr_index);
#line 1035
    *p_cstr_index = (opj_codestream_index_t *)((void *)0);
    }
  }
#line 1038
  return;
}
}
#line 1039 "/root/patron-new/39/src/lib/openjp2/openjpeg.c"
opj_stream_t *opj_stream_create_default_file_stream(char const   *fname , OPJ_BOOL p_is_read_stream ) 
{ 
  opj_stream_t *__cil_tmp3___10 ;

  {
  {
#line 1042
  __cil_tmp3___10 = opj_stream_create_file_stream(fname, (OPJ_SIZE_T )1048576, p_is_read_stream);
  }
#line 1042
  return (__cil_tmp3___10);
}
}
#line 1046 "/root/patron-new/39/src/lib/openjp2/openjpeg.c"
opj_stream_t *opj_stream_create_file_stream(char const   *fname___0 , OPJ_SIZE_T p_size ,
                                            OPJ_BOOL p_is_read_stream___0 ) 
{ 
  opj_stream_t *l_stream___9 ;
  FILE *p_file___2 ;
  char const   *mode ;
  OPJ_UINT64 __cil_tmp9___0 ;

  {
#line 1051
  l_stream___9 = (opj_stream_t *)0;
#line 1055
  if (! fname___0) {
#line 1056
    return ((opj_stream_t *)((void *)0));
  }
#line 1059
  if (p_is_read_stream___0) {
    {
#line 1060
    strcpy((char *)mode, "rb");
    }
  } else {
    {
#line 1062
    strcpy((char *)mode, "wb");
    }
  }
  {
#line 1065
  p_file___2 = fopen(fname___0, mode);
  }
#line 1067
  if (! p_file___2) {
#line 1068
    return ((opj_stream_t *)((void *)0));
  }
  {
#line 1071
  l_stream___9 = opj_stream_create(p_size, p_is_read_stream___0);
  }
#line 1072
  if (! l_stream___9) {
    {
#line 1073
    fclose(p_file___2);
    }
#line 1074
    return ((opj_stream_t *)((void *)0));
  }
  {
#line 1077
  opj_stream_set_user_data(l_stream___9, (void *)p_file___2, (void (*)(void * ))(& fclose));
#line 1079
  __cil_tmp9___0 = opj_get_data_length_from_file(p_file___2);
#line 1079
  opj_stream_set_user_data_length(l_stream___9, __cil_tmp9___0);
#line 1081
  opj_stream_set_read_function(l_stream___9, (OPJ_SIZE_T (*)(void * , OPJ_SIZE_T  ,
                                                             void * ))(& opj_read_from_file));
#line 1082
  opj_stream_set_write_function(l_stream___9, (OPJ_SIZE_T (*)(void * , OPJ_SIZE_T  ,
                                                              void * ))(& opj_write_from_file));
#line 1084
  opj_stream_set_skip_function(l_stream___9, (OPJ_OFF_T (*)(OPJ_OFF_T  , void * ))(& opj_skip_from_file));
#line 1085
  opj_stream_set_seek_function(l_stream___9, (OPJ_BOOL (*)(OPJ_OFF_T  , void * ))(& opj_seek_from_file));
  }
#line 1087
  return (l_stream___9);
}
}
#line 1091 "/root/patron-new/39/src/lib/openjp2/openjpeg.c"
void *opj_image_data_alloc(OPJ_SIZE_T size___6 ) 
{ 
  void *ret ;
  void *__cil_tmp3___11 ;

  {
  {
#line 1093
  __cil_tmp3___11 = opj_aligned_malloc(size___6);
#line 1093
  ret = __cil_tmp3___11;
  }
#line 1095
  return (ret);
}
}
#line 1098 "/root/patron-new/39/src/lib/openjp2/openjpeg.c"
void opj_image_data_free(void *ptr___6 ) 
{ 


  {
  {
#line 1101
  opj_aligned_free(ptr___6);
  }
#line 1103
  return;
}
}
#line 54 "/root/patron-new/39/src/lib/openjp2/mqc.c"
static void opj_mqc_byteout(opj_mqc_t *mqc ) ;
#line 59
static void opj_mqc_renorme(opj_mqc_t *mqc___0 ) ;
#line 64
static void opj_mqc_codemps(opj_mqc_t *mqc___1 ) ;
#line 69
static void opj_mqc_codelps(opj_mqc_t *mqc___2 ) ;
#line 74
static void opj_mqc_setbits(opj_mqc_t *mqc___3 ) ;
#line 82 "/root/patron-new/39/src/lib/openjp2/mqc.c"
static opj_mqc_state_t mqc_states[94]  = 
#line 82
  {      {(OPJ_UINT32 )22017, (OPJ_UINT32 )0, & mqc_states[2], & mqc_states[3]}, 
        {(OPJ_UINT32 )22017, (OPJ_UINT32 )1, & mqc_states[3], & mqc_states[2]}, 
        {(OPJ_UINT32 )13313, (OPJ_UINT32 )0, & mqc_states[4], & mqc_states[12]}, 
        {(OPJ_UINT32 )13313, (OPJ_UINT32 )1, & mqc_states[5], & mqc_states[13]}, 
        {(OPJ_UINT32 )6145, (OPJ_UINT32 )0, & mqc_states[6], & mqc_states[18]}, 
        {(OPJ_UINT32 )6145, (OPJ_UINT32 )1, & mqc_states[7], & mqc_states[19]}, 
        {(OPJ_UINT32 )2753, (OPJ_UINT32 )0, & mqc_states[8], & mqc_states[24]}, 
        {(OPJ_UINT32 )2753, (OPJ_UINT32 )1, & mqc_states[9], & mqc_states[25]}, 
        {(OPJ_UINT32 )1313, (OPJ_UINT32 )0, & mqc_states[10], & mqc_states[58]}, 
        {(OPJ_UINT32 )1313, (OPJ_UINT32 )1, & mqc_states[11], & mqc_states[59]}, 
        {(OPJ_UINT32 )545, (OPJ_UINT32 )0, & mqc_states[76], & mqc_states[66]}, 
        {(OPJ_UINT32 )545, (OPJ_UINT32 )1, & mqc_states[77], & mqc_states[67]}, 
        {(OPJ_UINT32 )22017, (OPJ_UINT32 )0, & mqc_states[14], & mqc_states[13]}, 
        {(OPJ_UINT32 )22017, (OPJ_UINT32 )1, & mqc_states[15], & mqc_states[12]}, 
        {(OPJ_UINT32 )21505, (OPJ_UINT32 )0, & mqc_states[16], & mqc_states[28]}, 
        {(OPJ_UINT32 )21505, (OPJ_UINT32 )1, & mqc_states[17], & mqc_states[29]}, 
        {(OPJ_UINT32 )18433, (OPJ_UINT32 )0, & mqc_states[18], & mqc_states[28]}, 
        {(OPJ_UINT32 )18433, (OPJ_UINT32 )1, & mqc_states[19], & mqc_states[29]}, 
        {(OPJ_UINT32 )14337, (OPJ_UINT32 )0, & mqc_states[20], & mqc_states[28]}, 
        {(OPJ_UINT32 )14337, (OPJ_UINT32 )1, & mqc_states[21], & mqc_states[29]}, 
        {(OPJ_UINT32 )12289, (OPJ_UINT32 )0, & mqc_states[22], & mqc_states[34]}, 
        {(OPJ_UINT32 )12289, (OPJ_UINT32 )1, & mqc_states[23], & mqc_states[35]}, 
        {(OPJ_UINT32 )9217, (OPJ_UINT32 )0, & mqc_states[24], & mqc_states[36]}, 
        {(OPJ_UINT32 )9217, (OPJ_UINT32 )1, & mqc_states[25], & mqc_states[37]}, 
        {(OPJ_UINT32 )7169, (OPJ_UINT32 )0, & mqc_states[26], & mqc_states[40]}, 
        {(OPJ_UINT32 )7169, (OPJ_UINT32 )1, & mqc_states[27], & mqc_states[41]}, 
        {(OPJ_UINT32 )5633, (OPJ_UINT32 )0, & mqc_states[58], & mqc_states[42]}, 
        {(OPJ_UINT32 )5633, (OPJ_UINT32 )1, & mqc_states[59], & mqc_states[43]}, 
        {(OPJ_UINT32 )22017, (OPJ_UINT32 )0, & mqc_states[30], & mqc_states[29]}, 
        {(OPJ_UINT32 )22017, (OPJ_UINT32 )1, & mqc_states[31], & mqc_states[28]}, 
        {(OPJ_UINT32 )21505, (OPJ_UINT32 )0, & mqc_states[32], & mqc_states[28]}, 
        {(OPJ_UINT32 )21505, (OPJ_UINT32 )1, & mqc_states[33], & mqc_states[29]}, 
        {(OPJ_UINT32 )20737, (OPJ_UINT32 )0, & mqc_states[34], & mqc_states[30]}, 
        {(OPJ_UINT32 )20737, (OPJ_UINT32 )1, & mqc_states[35], & mqc_states[31]}, 
        {(OPJ_UINT32 )18433, (OPJ_UINT32 )0, & mqc_states[36], & mqc_states[32]}, 
        {(OPJ_UINT32 )18433, (OPJ_UINT32 )1, & mqc_states[37], & mqc_states[33]}, 
        {(OPJ_UINT32 )14337, (OPJ_UINT32 )0, & mqc_states[38], & mqc_states[34]}, 
        {(OPJ_UINT32 )14337, (OPJ_UINT32 )1, & mqc_states[39], & mqc_states[35]}, 
        {(OPJ_UINT32 )13313, (OPJ_UINT32 )0, & mqc_states[40], & mqc_states[36]}, 
        {(OPJ_UINT32 )13313, (OPJ_UINT32 )1, & mqc_states[41], & mqc_states[37]}, 
        {(OPJ_UINT32 )12289, (OPJ_UINT32 )0, & mqc_states[42], & mqc_states[38]}, 
        {(OPJ_UINT32 )12289, (OPJ_UINT32 )1, & mqc_states[43], & mqc_states[39]}, 
        {(OPJ_UINT32 )10241, (OPJ_UINT32 )0, & mqc_states[44], & mqc_states[38]}, 
        {(OPJ_UINT32 )10241, (OPJ_UINT32 )1, & mqc_states[45], & mqc_states[39]}, 
        {(OPJ_UINT32 )9217, (OPJ_UINT32 )0, & mqc_states[46], & mqc_states[40]}, 
        {(OPJ_UINT32 )9217, (OPJ_UINT32 )1, & mqc_states[47], & mqc_states[41]}, 
        {(OPJ_UINT32 )8705, (OPJ_UINT32 )0, & mqc_states[48], & mqc_states[42]}, 
        {(OPJ_UINT32 )8705, (OPJ_UINT32 )1, & mqc_states[49], & mqc_states[43]}, 
        {(OPJ_UINT32 )7169, (OPJ_UINT32 )0, & mqc_states[50], & mqc_states[44]}, 
        {(OPJ_UINT32 )7169, (OPJ_UINT32 )1, & mqc_states[51], & mqc_states[45]}, 
        {(OPJ_UINT32 )6145, (OPJ_UINT32 )0, & mqc_states[52], & mqc_states[46]}, 
        {(OPJ_UINT32 )6145, (OPJ_UINT32 )1, & mqc_states[53], & mqc_states[47]}, 
        {(OPJ_UINT32 )5633, (OPJ_UINT32 )0, & mqc_states[54], & mqc_states[48]}, 
        {(OPJ_UINT32 )5633, (OPJ_UINT32 )1, & mqc_states[55], & mqc_states[49]}, 
        {(OPJ_UINT32 )5121, (OPJ_UINT32 )0, & mqc_states[56], & mqc_states[50]}, 
        {(OPJ_UINT32 )5121, (OPJ_UINT32 )1, & mqc_states[57], & mqc_states[51]}, 
        {(OPJ_UINT32 )4609, (OPJ_UINT32 )0, & mqc_states[58], & mqc_states[52]}, 
        {(OPJ_UINT32 )4609, (OPJ_UINT32 )1, & mqc_states[59], & mqc_states[53]}, 
        {(OPJ_UINT32 )4353, (OPJ_UINT32 )0, & mqc_states[60], & mqc_states[54]}, 
        {(OPJ_UINT32 )4353, (OPJ_UINT32 )1, & mqc_states[61], & mqc_states[55]}, 
        {(OPJ_UINT32 )2753, (OPJ_UINT32 )0, & mqc_states[62], & mqc_states[56]}, 
        {(OPJ_UINT32 )2753, (OPJ_UINT32 )1, & mqc_states[63], & mqc_states[57]}, 
        {(OPJ_UINT32 )2497, (OPJ_UINT32 )0, & mqc_states[64], & mqc_states[58]}, 
        {(OPJ_UINT32 )2497, (OPJ_UINT32 )1, & mqc_states[65], & mqc_states[59]}, 
        {(OPJ_UINT32 )2209, (OPJ_UINT32 )0, & mqc_states[66], & mqc_states[60]}, 
        {(OPJ_UINT32 )2209, (OPJ_UINT32 )1, & mqc_states[67], & mqc_states[61]}, 
        {(OPJ_UINT32 )1313, (OPJ_UINT32 )0, & mqc_states[68], & mqc_states[62]}, 
        {(OPJ_UINT32 )1313, (OPJ_UINT32 )1, & mqc_states[69], & mqc_states[63]}, 
        {(OPJ_UINT32 )1089, (OPJ_UINT32 )0, & mqc_states[70], & mqc_states[64]}, 
        {(OPJ_UINT32 )1089, (OPJ_UINT32 )1, & mqc_states[71], & mqc_states[65]}, 
        {(OPJ_UINT32 )673, (OPJ_UINT32 )0, & mqc_states[72], & mqc_states[66]}, 
        {(OPJ_UINT32 )673, (OPJ_UINT32 )1, & mqc_states[73], & mqc_states[67]}, 
        {(OPJ_UINT32 )545, (OPJ_UINT32 )0, & mqc_states[74], & mqc_states[68]}, 
        {(OPJ_UINT32 )545, (OPJ_UINT32 )1, & mqc_states[75], & mqc_states[69]}, 
        {(OPJ_UINT32 )321, (OPJ_UINT32 )0, & mqc_states[76], & mqc_states[70]}, 
        {(OPJ_UINT32 )321, (OPJ_UINT32 )1, & mqc_states[77], & mqc_states[71]}, 
        {(OPJ_UINT32 )273, (OPJ_UINT32 )0, & mqc_states[78], & mqc_states[72]}, 
        {(OPJ_UINT32 )273, (OPJ_UINT32 )1, & mqc_states[79], & mqc_states[73]}, 
        {(OPJ_UINT32 )133, (OPJ_UINT32 )0, & mqc_states[80], & mqc_states[74]}, 
        {(OPJ_UINT32 )133, (OPJ_UINT32 )1, & mqc_states[81], & mqc_states[75]}, 
        {(OPJ_UINT32 )73, (OPJ_UINT32 )0, & mqc_states[82], & mqc_states[76]}, 
        {(OPJ_UINT32 )73, (OPJ_UINT32 )1, & mqc_states[83], & mqc_states[77]}, 
        {(OPJ_UINT32 )37, (OPJ_UINT32 )0, & mqc_states[84], & mqc_states[78]}, 
        {(OPJ_UINT32 )37, (OPJ_UINT32 )1, & mqc_states[85], & mqc_states[79]}, 
        {(OPJ_UINT32 )21, (OPJ_UINT32 )0, & mqc_states[86], & mqc_states[80]}, 
        {(OPJ_UINT32 )21, (OPJ_UINT32 )1, & mqc_states[87], & mqc_states[81]}, 
        {(OPJ_UINT32 )9, (OPJ_UINT32 )0, & mqc_states[88], & mqc_states[82]}, 
        {(OPJ_UINT32 )9, (OPJ_UINT32 )1, & mqc_states[89], & mqc_states[83]}, 
        {(OPJ_UINT32 )5, (OPJ_UINT32 )0, & mqc_states[90], & mqc_states[84]}, 
        {(OPJ_UINT32 )5, (OPJ_UINT32 )1, & mqc_states[91], & mqc_states[85]}, 
        {(OPJ_UINT32 )1, (OPJ_UINT32 )0, & mqc_states[90], & mqc_states[86]}, 
        {(OPJ_UINT32 )1, (OPJ_UINT32 )1, & mqc_states[91], & mqc_states[87]}, 
        {(OPJ_UINT32 )22017, (OPJ_UINT32 )0, & mqc_states[92], & mqc_states[92]}, 
        {(OPJ_UINT32 )22017, (OPJ_UINT32 )1, & mqc_states[93], & mqc_states[93]}};
#line 185 "/root/patron-new/39/src/lib/openjp2/mqc.c"
static void opj_mqc_byteout(opj_mqc_t *mqc ) 
{ 


  {
#line 190
  if ((int )*(mqc->bp) == 255) {
#line 191
    (mqc->bp) ++;
#line 192
    *(mqc->bp) = (OPJ_BYTE )(mqc->c >> 20);
#line 193
    mqc->c &= 1048575U;
#line 194
    mqc->ct = (OPJ_UINT32 )7;
  } else
#line 196
  if ((mqc->c & 134217728U) == 0U) {
#line 197
    (mqc->bp) ++;
#line 198
    *(mqc->bp) = (OPJ_BYTE )(mqc->c >> 19);
#line 199
    mqc->c &= 524287U;
#line 200
    mqc->ct = (OPJ_UINT32 )8;
  } else {
#line 202
    *(mqc->bp) = (OPJ_BYTE )((int )*(mqc->bp) + 1);
#line 203
    if ((int )*(mqc->bp) == 255) {
#line 204
      mqc->c &= 134217727U;
#line 205
      (mqc->bp) ++;
#line 206
      *(mqc->bp) = (OPJ_BYTE )(mqc->c >> 20);
#line 207
      mqc->c &= 1048575U;
#line 208
      mqc->ct = (OPJ_UINT32 )7;
    } else {
#line 210
      (mqc->bp) ++;
#line 211
      *(mqc->bp) = (OPJ_BYTE )(mqc->c >> 19);
#line 212
      mqc->c &= 524287U;
#line 213
      mqc->ct = (OPJ_UINT32 )8;
    }
  }
#line 216
  return;
}
}
#line 219 "/root/patron-new/39/src/lib/openjp2/mqc.c"
static void opj_mqc_renorme(opj_mqc_t *mqc___0 ) 
{ 
  OPJ_UINT32 __cil_tmp2___2 ;

  {
  {
#line 221
  while (1) {
    while_continue: /* CIL Label */ ;
#line 222
    mqc___0->a <<= 1;
#line 223
    mqc___0->c <<= 1;
#line 224
    __cil_tmp2___2 = mqc___0->ct;
#line 224
    (mqc___0->ct) --;
#line 225
    if (mqc___0->ct == 0U) {
      {
#line 226
      opj_mqc_byteout(mqc___0);
      }
    }
#line 221
    if (! ((mqc___0->a & 32768U) == 0U)) {
#line 221
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 226
  return;
}
}
#line 231 "/root/patron-new/39/src/lib/openjp2/mqc.c"
static void opj_mqc_codemps(opj_mqc_t *mqc___1 ) 
{ 


  {
#line 233
  mqc___1->a -= (*(mqc___1->curctx))->qeval;
#line 234
  if ((mqc___1->a & 32768U) == 0U) {
#line 235
    if (mqc___1->a < (*(mqc___1->curctx))->qeval) {
#line 236
      mqc___1->a = (*(mqc___1->curctx))->qeval;
    } else {
#line 238
      mqc___1->c += (*(mqc___1->curctx))->qeval;
    }
    {
#line 240
    *(mqc___1->curctx) = (*(mqc___1->curctx))->nmps;
#line 241
    opj_mqc_renorme(mqc___1);
    }
  } else {
#line 243
    mqc___1->c += (*(mqc___1->curctx))->qeval;
  }
#line 245
  return;
}
}
#line 247 "/root/patron-new/39/src/lib/openjp2/mqc.c"
static void opj_mqc_codelps(opj_mqc_t *mqc___2 ) 
{ 


  {
#line 249
  mqc___2->a -= (*(mqc___2->curctx))->qeval;
#line 250
  if (mqc___2->a < (*(mqc___2->curctx))->qeval) {
#line 251
    mqc___2->c += (*(mqc___2->curctx))->qeval;
  } else {
#line 253
    mqc___2->a = (*(mqc___2->curctx))->qeval;
  }
  {
#line 255
  *(mqc___2->curctx) = (*(mqc___2->curctx))->nlps;
#line 256
  opj_mqc_renorme(mqc___2);
  }
#line 258
  return;
}
}
#line 259 "/root/patron-new/39/src/lib/openjp2/mqc.c"
static void opj_mqc_setbits(opj_mqc_t *mqc___3 ) 
{ 
  OPJ_UINT32 tempc ;

  {
#line 261
  tempc = mqc___3->c + mqc___3->a;
#line 262
  mqc___3->c |= 65535U;
#line 263
  if (mqc___3->c >= tempc) {
#line 264
    mqc___3->c -= 32768U;
  }
#line 266
  return;
}
}
#line 274 "/root/patron-new/39/src/lib/openjp2/mqc.c"
OPJ_UINT32 opj_mqc_numbytes(opj_mqc_t *mqc___4 ) 
{ 
  ptrdiff_t diff ;

  {
#line 276
  diff = mqc___4->bp - mqc___4->start;
#line 280
  return ((OPJ_UINT32 )diff);
}
}
#line 283 "/root/patron-new/39/src/lib/openjp2/mqc.c"
void opj_mqc_init_enc(opj_mqc_t *mqc___5 , OPJ_BYTE *bp ) 
{ 


  {
#line 287
  mqc___5->curctx = & mqc___5->ctxs[(OPJ_UINT32 )0];
#line 291
  mqc___5->a = (OPJ_UINT32 )32768;
#line 292
  mqc___5->c = (OPJ_UINT32 )0;
#line 295
  mqc___5->bp = bp - 1;
#line 296
  mqc___5->ct = (OPJ_UINT32 )12;
#line 302
  mqc___5->start = bp;
#line 303
  mqc___5->end_of_byte_stream_counter = (OPJ_UINT32 )0;
#line 304
  return;
}
}
#line 306 "/root/patron-new/39/src/lib/openjp2/mqc.c"
void opj_mqc_encode(opj_mqc_t *mqc___6 , OPJ_UINT32 d ) 
{ 


  {
#line 308
  if ((*(mqc___6->curctx))->mps == d) {
    {
#line 309
    opj_mqc_codemps(mqc___6);
    }
  } else {
    {
#line 311
    opj_mqc_codelps(mqc___6);
    }
  }
#line 314
  return;
}
}
#line 315 "/root/patron-new/39/src/lib/openjp2/mqc.c"
void opj_mqc_flush(opj_mqc_t *mqc___7 ) 
{ 


  {
  {
#line 319
  opj_mqc_setbits(mqc___7);
#line 320
  mqc___7->c <<= mqc___7->ct;
#line 321
  opj_mqc_byteout(mqc___7);
#line 322
  mqc___7->c <<= mqc___7->ct;
#line 323
  opj_mqc_byteout(mqc___7);
  }
#line 326
  if ((int )*(mqc___7->bp) != 255) {
#line 328
    (mqc___7->bp) ++;
  }
#line 330
  return;
}
}
#line 334 "/root/patron-new/39/src/lib/openjp2/mqc.c"
void opj_mqc_bypass_init_enc(opj_mqc_t *mqc___8 ) 
{ 


  {
#line 340
  mqc___8->c = (OPJ_UINT32 )0;
#line 346
  mqc___8->ct = 3735928559U;
#line 347
  return;
}
}
#line 352 "/root/patron-new/39/src/lib/openjp2/mqc.c"
void opj_mqc_bypass_enc(opj_mqc_t *mqc___9 , OPJ_UINT32 d___0 ) 
{ 
  OPJ_UINT32 __cil_tmp3___13 ;

  {
#line 354
  if (mqc___9->ct == 3735928559U) {
#line 355
    mqc___9->ct = (OPJ_UINT32 )8;
  }
#line 357
  __cil_tmp3___13 = mqc___9->ct;
#line 357
  (mqc___9->ct) --;
#line 358
  mqc___9->c += d___0 << mqc___9->ct;
#line 359
  if (mqc___9->ct == 0U) {
#line 360
    *(mqc___9->bp) = (OPJ_BYTE )mqc___9->c;
#line 361
    mqc___9->ct = (OPJ_UINT32 )8;
#line 363
    if ((int )*(mqc___9->bp) == 255) {
#line 364
      mqc___9->ct = (OPJ_UINT32 )7;
    }
#line 366
    (mqc___9->bp) ++;
#line 367
    mqc___9->c = (OPJ_UINT32 )0;
  }
#line 369
  return;
}
}
#line 371 "/root/patron-new/39/src/lib/openjp2/mqc.c"
OPJ_UINT32 opj_mqc_bypass_get_extra_bytes(opj_mqc_t *mqc___10 , OPJ_BOOL erterm ) 
{ 
  int tmp___12 ;

  {
#line 373
  if (mqc___10->ct < 7U) {
#line 373
    tmp___12 = 1;
  } else
#line 373
  if (mqc___10->ct == 7U) {
#line 373
    if (erterm) {
#line 373
      tmp___12 = 1;
    } else
#line 373
    if ((int )*(mqc___10->bp + -1) != 255) {
#line 373
      tmp___12 = 1;
    } else {
#line 373
      tmp___12 = 0;
    }
  } else {
#line 373
    tmp___12 = 0;
  }
#line 373
  return ((OPJ_UINT32 )tmp___12);
}
}
#line 377 "/root/patron-new/39/src/lib/openjp2/mqc.c"
void opj_mqc_bypass_flush_enc(opj_mqc_t *mqc___11 , OPJ_BOOL erterm___0 ) 
{ 
  OPJ_BYTE bit_value ;
  OPJ_UINT32 __cil_tmp4___7 ;
  OPJ_BYTE *__cil_tmp7___3 ;

  {
#line 385
  if (mqc___11->ct < 7U) {
    _L___8: 
#line 386
    bit_value = (OPJ_BYTE )0;
    {
#line 391
    while (1) {
      while_continue: /* CIL Label */ ;

#line 391
      if (! (mqc___11->ct > 0U)) {
#line 391
        goto while_break;
      }
#line 392
      __cil_tmp4___7 = mqc___11->ct;
#line 392
      (mqc___11->ct) --;
#line 393
      mqc___11->c += (OPJ_UINT32 )((int )bit_value << mqc___11->ct);
#line 394
      bit_value = (OPJ_BYTE )(1U - (unsigned int )bit_value);
    }
    while_break___0: /* CIL Label */ ;
    }

    while_break: 
#line 396
    *(mqc___11->bp) = (OPJ_BYTE )mqc___11->c;
#line 398
    (mqc___11->bp) ++;
  } else
#line 385
  if (mqc___11->ct == 7U) {
#line 385
    if (erterm___0) {
#line 385
      goto _L___8;
    } else
#line 385
    if ((int )*(mqc___11->bp + -1) != 255) {
#line 385
      goto _L___8;
    } else {
#line 385
      goto _L___9;
    }
  } else
  _L___9: 
#line 399
  if (mqc___11->ct == 7U) {
#line 399
    if ((int )*(mqc___11->bp + -1) == 255) {
#line 402
      __cil_tmp7___3 = mqc___11->bp;
#line 402
      (mqc___11->bp) --;
    } else {
#line 399
      goto _L;
    }
  } else
  _L: 
#line 403
  if (mqc___11->ct == 8U) {
#line 403
    if (! erterm___0) {
#line 403
      if ((int )*(mqc___11->bp + -1) == 127) {
#line 403
        if ((int )*(mqc___11->bp + -2) == 255) {
#line 409
          mqc___11->bp -= 2;
        }
      }
    }
  }
#line 414
  return;
}
}
#line 415 "/root/patron-new/39/src/lib/openjp2/mqc.c"
void opj_mqc_reset_enc(opj_mqc_t *mqc___12 ) 
{ 


  {
  {
#line 417
  opj_mqc_resetstates(mqc___12);
#line 418
  opj_mqc_setstate(mqc___12, (OPJ_UINT32 )18, (OPJ_UINT32 )0, 46);
#line 419
  opj_mqc_setstate(mqc___12, (OPJ_UINT32 )17, (OPJ_UINT32 )0, 3);
#line 420
  opj_mqc_setstate(mqc___12, (OPJ_UINT32 )0, (OPJ_UINT32 )0, 4);
  }
#line 422
  return;
}
}
#line 442 "/root/patron-new/39/src/lib/openjp2/mqc.c"
void opj_mqc_restart_init_enc(opj_mqc_t *mqc___13 ) 
{ 
  OPJ_BYTE *__cil_tmp2___4 ;

  {
#line 448
  mqc___13->a = (OPJ_UINT32 )32768;
#line 449
  mqc___13->c = (OPJ_UINT32 )0;
#line 450
  mqc___13->ct = (OPJ_UINT32 )12;
#line 454
  __cil_tmp2___4 = mqc___13->bp;
#line 454
  (mqc___13->bp) --;
#line 457
  if ((int )*(mqc___13->bp) == 255) {
#line 458
    mqc___13->ct = (OPJ_UINT32 )13;
  }
#line 460
  return;
}
}
#line 462 "/root/patron-new/39/src/lib/openjp2/mqc.c"
void opj_mqc_erterm_enc(opj_mqc_t *mqc___14 ) 
{ 
  OPJ_INT32 k ;

  {
#line 464
  k = (OPJ_INT32 )((11U - mqc___14->ct) + 1U);
  {
#line 466
  while (1) {
    while_continue: /* CIL Label */ ;

#line 466
    if (! (k > 0)) {
#line 466
      goto while_break;
    }
    {
#line 467
    mqc___14->c <<= mqc___14->ct;
#line 468
    mqc___14->ct = (OPJ_UINT32 )0;
#line 469
    opj_mqc_byteout(mqc___14);
#line 470
    k -= (OPJ_INT32 )mqc___14->ct;
    }
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 473
  if ((int )*(mqc___14->bp) != 255) {
    {
#line 474
    opj_mqc_byteout(mqc___14);
    }
  }
#line 477
  return;
}
}
#line 478 "/root/patron-new/39/src/lib/openjp2/mqc.c"
void opj_mqc_segmark_enc(opj_mqc_t *mqc___15 ) 
{ 
  OPJ_UINT32 i ;

  {
#line 481
  mqc___15->curctx = & mqc___15->ctxs[(OPJ_UINT32 )18];
#line 483
  i = (OPJ_UINT32 )1;
  {
#line 483
  while (1) {
    while_continue: /* CIL Label */ ;

#line 483
    if (! (i < 5U)) {
#line 483
      goto while_break;
    }
    {
#line 484
    opj_mqc_encode(mqc___15, i % 2U);
#line 483
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 487
  return;
}
}
#line 488 "/root/patron-new/39/src/lib/openjp2/mqc.c"
static void opj_mqc_init_dec_common(opj_mqc_t *mqc___16 , OPJ_BYTE *bp___0 , OPJ_UINT32 len ,
                                    OPJ_UINT32 extra_writable_bytes ) 
{ 


  {
  {
#line 496
  mqc___16->start = bp___0;
#line 497
  mqc___16->end = bp___0 + len;
#line 502
  memcpy((void *)(mqc___16->backup), (void const   *)mqc___16->end, 2UL);
#line 503
  *(mqc___16->end + 0) = (OPJ_BYTE )255;
#line 504
  *(mqc___16->end + 1) = (OPJ_BYTE )255;
#line 505
  mqc___16->bp = bp___0;
  }
#line 507
  return;
}
}
#line 507 "/root/patron-new/39/src/lib/openjp2/mqc.c"
void opj_mqc_init_dec(opj_mqc_t *mqc___17 , OPJ_BYTE *bp___1 , OPJ_UINT32 len___0 ,
                      OPJ_UINT32 extra_writable_bytes___0 ) 
{ 


  {
  {
#line 515
  opj_mqc_init_dec_common(mqc___17, bp___1, len___0, extra_writable_bytes___0);
#line 516
  mqc___17->curctx = & mqc___17->ctxs[(OPJ_UINT32 )0];
#line 517
  mqc___17->end_of_byte_stream_counter = (OPJ_UINT32 )0;
  }
#line 518
  if (len___0 == 0U) {
#line 519
    mqc___17->c = (OPJ_UINT32 )(255 << 16);
  } else {
#line 521
    mqc___17->c = (OPJ_UINT32 )((int )*(mqc___17->bp) << 16);
  }
  {
#line 524
  opj_mqc_bytein(mqc___17);
#line 525
  mqc___17->c <<= 7;
#line 526
  mqc___17->ct -= 7U;
#line 527
  mqc___17->a = (OPJ_UINT32 )32768;
  }
#line 529
  return;
}
}
#line 531 "/root/patron-new/39/src/lib/openjp2/mqc.c"
void opj_mqc_raw_init_dec(opj_mqc_t *mqc___18 , OPJ_BYTE *bp___2 , OPJ_UINT32 len___1 ,
                          OPJ_UINT32 extra_writable_bytes___1 ) 
{ 


  {
  {
#line 534
  opj_mqc_init_dec_common(mqc___18, bp___2, len___1, extra_writable_bytes___1);
#line 535
  mqc___18->c = (OPJ_UINT32 )0;
#line 536
  mqc___18->ct = (OPJ_UINT32 )0;
  }
#line 538
  return;
}
}
#line 540 "/root/patron-new/39/src/lib/openjp2/mqc.c"
void opq_mqc_finish_dec(opj_mqc_t *mqc___19 ) 
{ 


  {
  {
#line 543
  memcpy((void *)mqc___19->end, (void const   *)(mqc___19->backup), 2UL);
  }
#line 545
  return;
}
}
#line 546 "/root/patron-new/39/src/lib/openjp2/mqc.c"
void opj_mqc_resetstates(opj_mqc_t *mqc___20 ) 
{ 
  OPJ_UINT32 i___0 ;

  {
#line 549
  i___0 = (OPJ_UINT32 )0;
  {
#line 549
  while (1) {
    while_continue: /* CIL Label */ ;

#line 549
    if (! (i___0 < 19U)) {
#line 549
      goto while_break;
    }
#line 550
    mqc___20->ctxs[i___0] = mqc_states;
#line 549
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 553
  return;
}
}
#line 554 "/root/patron-new/39/src/lib/openjp2/mqc.c"
void opj_mqc_setstate(opj_mqc_t *mqc___21 , OPJ_UINT32 ctxno , OPJ_UINT32 msb , OPJ_INT32 prob ) 
{ 


  {
#line 557
  mqc___21->ctxs[ctxno] = & mqc_states[msb + (OPJ_UINT32 )(prob << 1)];
#line 558
  return;
}
}
#line 64 "/root/patron-new/39/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_read_ihdr(opj_jp2_t *jp2 , OPJ_BYTE *p_image_header_data ,
                                  OPJ_UINT32 p_image_header_size , opj_event_mgr_t *p_manager___0 ) ;
#line 77
static OPJ_BYTE *opj_jp2_write_ihdr(opj_jp2_t *jp2___0 , OPJ_UINT32 *p_nb_bytes_written ) ;
#line 88
static OPJ_BYTE *opj_jp2_write_bpcc(opj_jp2_t *jp2___1 , OPJ_UINT32 *p_nb_bytes_written___0 ) ;
#line 101
static OPJ_BOOL opj_jp2_read_bpcc(opj_jp2_t *jp2___2 , OPJ_BYTE *p_bpc_header_data ,
                                  OPJ_UINT32 p_bpc_header_size , opj_event_mgr_t *p_manager___1 ) ;
#line 106
static OPJ_BOOL opj_jp2_read_cdef(opj_jp2_t *jp2___7 , OPJ_BYTE *p_cdef_header_data ,
                                  OPJ_UINT32 p_cdef_header_size , opj_event_mgr_t *p_manager___6 ) ;
#line 111
static void opj_jp2_apply_cdef(opj_image_t *image___1 , opj_jp2_color_t *color___2 ,
                               opj_event_mgr_t *manager ) ;
#line 122
static OPJ_BYTE *opj_jp2_write_cdef(opj_jp2_t *jp2___3 , OPJ_UINT32 *p_nb_bytes_written___1 ) ;
#line 133
static OPJ_BYTE *opj_jp2_write_colr(opj_jp2_t *jp2___4 , OPJ_UINT32 *p_nb_bytes_written___2 ) ;
#line 145
static OPJ_BOOL opj_jp2_write_ftyp(opj_jp2_t *jp2___11 , opj_stream_private_t *cio___0 ,
                                   opj_event_mgr_t *p_manager___10 ) ;
#line 159
static OPJ_BOOL opj_jp2_read_ftyp(opj_jp2_t *jp2___27 , OPJ_BYTE *p_header_data___0 ,
                                  OPJ_UINT32 p_header_size___0 , opj_event_mgr_t *p_manager___24 ) ;
#line 164
static OPJ_BOOL opj_jp2_skip_jp2c(opj_jp2_t *jp2___28 , opj_stream_private_t *stream___4 ,
                                  opj_event_mgr_t *p_manager___25 ) ;
#line 178
static OPJ_BOOL opj_jp2_read_jp2h(opj_jp2_t *jp2___30 , OPJ_BYTE *p_header_data___1 ,
                                  OPJ_UINT32 p_header_size___1 , opj_event_mgr_t *p_manager___27 ) ;
#line 192
static OPJ_BOOL opj_jp2_write_jp2h(opj_jp2_t *jp2___10 , opj_stream_private_t *stream ,
                                   opj_event_mgr_t *p_manager___9 ) ;
#line 205
static OPJ_BOOL opj_jp2_write_jp2c(opj_jp2_t *jp2___12 , opj_stream_private_t *cio___1 ,
                                   opj_event_mgr_t *p_manager___11 ) ;
#line 251
static OPJ_BOOL opj_jp2_read_jp(opj_jp2_t *jp2___26 , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                opj_event_mgr_t *p_manager___23 ) ;
#line 265
static OPJ_BOOL opj_jp2_write_jp(opj_jp2_t *jp2___13 , opj_stream_private_t *cio___2 ,
                                 opj_event_mgr_t *p_manager___12 ) ;
#line 276
static OPJ_BOOL opj_jp2_apply_pclr(opj_image_t *image___0 , opj_jp2_color_t *color___1 ,
                                   opj_event_mgr_t *p_manager___3 ) ;
#line 280
static void opj_jp2_free_pclr(opj_jp2_color_t *color ) ;
#line 292
static OPJ_BOOL opj_jp2_read_pclr(opj_jp2_t *jp2___5 , OPJ_BYTE *p_pclr_header_data ,
                                  OPJ_UINT32 p_pclr_header_size , opj_event_mgr_t *p_manager___4 ) ;
#line 308
static OPJ_BOOL opj_jp2_read_cmap(opj_jp2_t *jp2___6 , OPJ_BYTE *p_cmap_header_data ,
                                  OPJ_UINT32 p_cmap_header_size , opj_event_mgr_t *p_manager___5 ) ;
#line 323
static OPJ_BOOL opj_jp2_read_colr(opj_jp2_t *jp2___8 , OPJ_BYTE *p_colr_header_data ,
                                  OPJ_UINT32 p_colr_header_size , opj_event_mgr_t *p_manager___7 ) ;
#line 336
static OPJ_BOOL opj_jp2_setup_end_header_writing(opj_jp2_t *jp2___20 , opj_event_mgr_t *p_manager___17 ) ;
#line 343
static OPJ_BOOL opj_jp2_setup_end_header_reading(opj_jp2_t *jp2___21 , opj_event_mgr_t *p_manager___18 ) ;
#line 355
static OPJ_BOOL opj_jp2_read_header_procedure(opj_jp2_t *jp2___23 , opj_stream_private_t *stream___1 ,
                                              opj_event_mgr_t *p_manager___20 ) ;
#line 369
static OPJ_BOOL opj_jp2_exec(opj_jp2_t *jp2___24 , opj_procedure_list_t *p_procedure_list ,
                             opj_stream_private_t *stream___2 , opj_event_mgr_t *p_manager___21 ) ;
#line 384
static OPJ_BOOL opj_jp2_read_boxhdr(opj_jp2_box_t *box , OPJ_UINT32 *p_number_bytes_read ,
                                    opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) ;
#line 393
static OPJ_BOOL opj_jp2_setup_encoding_validation(opj_jp2_t *jp2___32 , opj_event_mgr_t *p_manager___30 ) ;
#line 399
static OPJ_BOOL opj_jp2_setup_header_writing(opj_jp2_t *jp2___34 , opj_event_mgr_t *p_manager___32 ) ;
#line 402
static OPJ_BOOL opj_jp2_default_validation(opj_jp2_t *jp2___22 , opj_stream_private_t *cio___5 ,
                                           opj_event_mgr_t *p_manager___19 ) ;
#line 413
static opj_jp2_header_handler_t *opj_jp2_img_find_handler(OPJ_UINT32 p_id___0 ) ;
#line 423
static opj_jp2_header_handler_t *opj_jp2_find_handler(OPJ_UINT32 p_id ) ;
#line 425 "/root/patron-new/39/src/lib/openjp2/jp2.c"
static opj_jp2_header_handler_t jp2_header[3]  = {      {(OPJ_UINT32 )1783636000, & opj_jp2_read_jp}, 
        {(OPJ_UINT32 )1718909296, & opj_jp2_read_ftyp}, 
        {(OPJ_UINT32 )1785737832, & opj_jp2_read_jp2h}};
#line 431 "/root/patron-new/39/src/lib/openjp2/jp2.c"
static opj_jp2_header_handler_t jp2_img_header[6]  = {      {(OPJ_UINT32 )1768449138, & opj_jp2_read_ihdr}, 
        {(OPJ_UINT32 )1668246642, & opj_jp2_read_colr}, 
        {(OPJ_UINT32 )1651532643, & opj_jp2_read_bpcc}, 
        {(OPJ_UINT32 )1885564018, & opj_jp2_read_pclr}, 
        {(OPJ_UINT32 )1668112752, & opj_jp2_read_cmap}, 
        {(OPJ_UINT32 )1667523942, & opj_jp2_read_cdef}};
#line 452
static OPJ_BOOL opj_jp2_read_boxhdr_char(opj_jp2_box_t *box___2 , OPJ_BYTE *p_data___1 ,
                                         OPJ_UINT32 *p_number_bytes_read___0 , OPJ_UINT32 p_box_max_size ,
                                         opj_event_mgr_t *p_manager___28 ) ;
#line 462
static OPJ_BOOL opj_jp2_setup_decoding_validation(opj_jp2_t *jp2___33 , opj_event_mgr_t *p_manager___31 ) ;
#line 469
static OPJ_BOOL opj_jp2_setup_header_reading(opj_jp2_t *jp2___35 , opj_event_mgr_t *p_manager___33 ) ;
#line 473 "/root/patron-new/39/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_read_boxhdr(opj_jp2_box_t *box , OPJ_UINT32 *p_number_bytes_read ,
                                    opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BYTE l_data_header[8] ;
  OPJ_SIZE_T __cil_tmp10 ;
  OPJ_OFF_T bleft ;
  OPJ_OFF_T __cil_tmp12 ;
  OPJ_UINT32 l_xl_part_size ;
  OPJ_UINT32 l_nb_bytes_read ;
  OPJ_SIZE_T __cil_tmp16 ;

  {
  {
#line 487
  __cil_tmp10 = opj_stream_read_data(cio, l_data_header, (OPJ_SIZE_T )8, p_manager);
#line 487
  *p_number_bytes_read = (OPJ_UINT32 )__cil_tmp10;
  }
#line 489
  if (*p_number_bytes_read != 8U) {
#line 490
    return (0);
  }
  {
#line 494
  opj_read_bytes_LE(l_data_header, & box->length, (OPJ_UINT32 )4);
#line 495
  opj_read_bytes_LE(l_data_header + 4, & box->type, (OPJ_UINT32 )4);
  }
#line 497
  if (box->length == 0U) {
    {
#line 498
    __cil_tmp12 = opj_stream_get_number_byte_left(cio);
#line 498
    bleft = __cil_tmp12;
    }
#line 499
    if (bleft > 4294967287L) {
      {
#line 500
      opj_event_msg(p_manager, 1, "Cannot handle box sizes higher than 2^32\n");
      }
#line 502
      return (0);
    }
#line 504
    box->length = (OPJ_UINT32 )bleft + 8U;
#line 506
    return (1);
  }
#line 511
  if (box->length == 1U) {
    {
#line 514
    __cil_tmp16 = opj_stream_read_data(cio, l_data_header, (OPJ_SIZE_T )8, p_manager);
#line 514
    l_nb_bytes_read = (OPJ_UINT32 )__cil_tmp16;
    }
#line 516
    if (l_nb_bytes_read != 8U) {
#line 517
      if (l_nb_bytes_read > 0U) {
#line 518
        *p_number_bytes_read += l_nb_bytes_read;
      }
#line 521
      return (0);
    }
    {
#line 524
    *p_number_bytes_read = (OPJ_UINT32 )16;
#line 525
    opj_read_bytes_LE(l_data_header, & l_xl_part_size, (OPJ_UINT32 )4);
    }
#line 526
    if (l_xl_part_size != 0U) {
      {
#line 527
      opj_event_msg(p_manager, 1, "Cannot handle box sizes higher than 2^32\n");
      }
#line 529
      return (0);
    }
    {
#line 531
    opj_read_bytes_LE(l_data_header + 4, & box->length, (OPJ_UINT32 )4);
    }
  }
#line 533
  return (1);
}
}
#line 561 "/root/patron-new/39/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_read_ihdr(opj_jp2_t *jp2 , OPJ_BYTE *p_image_header_data ,
                                  OPJ_UINT32 p_image_header_size , opj_event_mgr_t *p_manager___0 ) 
{ 
  void *__cil_tmp8___4 ;

  {
#line 571
  if ((unsigned long )jp2->comps != (unsigned long )((void *)0)) {
    {
#line 572
    opj_event_msg(p_manager___0, 2, "Ignoring ihdr box. First ihdr box already read\n");
    }
#line 574
    return (1);
  }
#line 577
  if (p_image_header_size != 14U) {
    {
#line 578
    opj_event_msg(p_manager___0, 1, "Bad image header box (bad size)\n\220");
    }
#line 579
    return (0);
  }
  {
#line 582
  opj_read_bytes_LE(p_image_header_data, & jp2->h, (OPJ_UINT32 )4);
#line 583
  p_image_header_data += 4;
#line 584
  opj_read_bytes_LE(p_image_header_data, & jp2->w, (OPJ_UINT32 )4);
#line 585
  p_image_header_data += 4;
#line 586
  opj_read_bytes_LE(p_image_header_data, & jp2->numcomps, (OPJ_UINT32 )2);
#line 587
  p_image_header_data += 2;
  }
#line 589
  if (jp2->numcomps - 1U >= 16384U) {
    {
#line 591
    opj_event_msg(p_manager___0, 1, "Invalid number of components (ihdr)\n");
    }
#line 592
    return (0);
  }
  {
#line 596
  __cil_tmp8___4 = opj_calloc((size_t )jp2->numcomps, sizeof(opj_jp2_comps_t ));
#line 596
  jp2->comps = (opj_jp2_comps_t *)__cil_tmp8___4;
  }
#line 598
  if ((unsigned long )jp2->comps == (unsigned long )((opj_jp2_comps_t *)0)) {
    {
#line 599
    opj_event_msg(p_manager___0, 1, "Not enough memory to handle image header (ihdr)\n\220");
    }
#line 601
    return (0);
  }
  {
#line 604
  opj_read_bytes_LE(p_image_header_data, & jp2->bpc, (OPJ_UINT32 )1);
#line 605
  p_image_header_data ++;
#line 607
  opj_read_bytes_LE(p_image_header_data, & jp2->C, (OPJ_UINT32 )1);
#line 608
  p_image_header_data ++;
  }
#line 611
  if (jp2->C != 7U) {
    {
#line 612
    opj_event_msg(p_manager___0, 4, "JP2 IHDR box: compression type indicate that the file is not a conforming JP2 file (%d) \n",
                  jp2->C);
    }
  }
  {
#line 617
  opj_read_bytes_LE(p_image_header_data, & jp2->UnkC, (OPJ_UINT32 )1);
#line 618
  p_image_header_data ++;
#line 619
  opj_read_bytes_LE(p_image_header_data, & jp2->IPR, (OPJ_UINT32 )1);
#line 620
  p_image_header_data ++;
#line 622
  (jp2->j2k)->m_cp.allow_different_bit_depth_sign = (OPJ_BITFIELD )(jp2->bpc == 255U);
#line 623
  (jp2->j2k)->ihdr_w = jp2->w;
#line 624
  (jp2->j2k)->ihdr_h = jp2->h;
#line 625
  jp2->has_ihdr = (OPJ_BYTE )1;
  }
#line 627
  return (1);
}
}
#line 630 "/root/patron-new/39/src/lib/openjp2/jp2.c"
static OPJ_BYTE *opj_jp2_write_ihdr(opj_jp2_t *jp2___0 , OPJ_UINT32 *p_nb_bytes_written ) 
{ 
  OPJ_BYTE *l_ihdr_data ;
  OPJ_BYTE *l_current_ihdr_ptr ;
  void *__cil_tmp7___4 ;

  {
  {
#line 641
  __cil_tmp7___4 = opj_calloc((size_t )1, (size_t )22);
#line 641
  l_ihdr_data = (OPJ_BYTE *)__cil_tmp7___4;
  }
#line 642
  if ((unsigned long )l_ihdr_data == (unsigned long )((OPJ_BYTE *)0)) {
#line 643
    return ((OPJ_BYTE *)0);
  }
  {
#line 646
  l_current_ihdr_ptr = l_ihdr_data;
#line 648
  opj_write_bytes_LE(l_current_ihdr_ptr, (OPJ_UINT32 )22, (OPJ_UINT32 )4);
#line 649
  l_current_ihdr_ptr += 4;
#line 651
  opj_write_bytes_LE(l_current_ihdr_ptr, (OPJ_UINT32 )1768449138, (OPJ_UINT32 )4);
#line 652
  l_current_ihdr_ptr += 4;
#line 654
  opj_write_bytes_LE(l_current_ihdr_ptr, jp2___0->h, (OPJ_UINT32 )4);
#line 655
  l_current_ihdr_ptr += 4;
#line 657
  opj_write_bytes_LE(l_current_ihdr_ptr, jp2___0->w, (OPJ_UINT32 )4);
#line 658
  l_current_ihdr_ptr += 4;
#line 660
  opj_write_bytes_LE(l_current_ihdr_ptr, jp2___0->numcomps, (OPJ_UINT32 )2);
#line 661
  l_current_ihdr_ptr += 2;
#line 663
  opj_write_bytes_LE(l_current_ihdr_ptr, jp2___0->bpc, (OPJ_UINT32 )1);
#line 664
  l_current_ihdr_ptr ++;
#line 666
  opj_write_bytes_LE(l_current_ihdr_ptr, jp2___0->C, (OPJ_UINT32 )1);
#line 667
  l_current_ihdr_ptr ++;
#line 669
  opj_write_bytes_LE(l_current_ihdr_ptr, jp2___0->UnkC, (OPJ_UINT32 )1);
#line 671
  l_current_ihdr_ptr ++;
#line 673
  opj_write_bytes_LE(l_current_ihdr_ptr, jp2___0->IPR, (OPJ_UINT32 )1);
#line 675
  l_current_ihdr_ptr ++;
#line 677
  *p_nb_bytes_written = (OPJ_UINT32 )22;
  }
#line 679
  return (l_ihdr_data);
}
}
#line 682 "/root/patron-new/39/src/lib/openjp2/jp2.c"
static OPJ_BYTE *opj_jp2_write_bpcc(opj_jp2_t *jp2___1 , OPJ_UINT32 *p_nb_bytes_written___0 ) 
{ 
  OPJ_UINT32 i___1 ;
  OPJ_UINT32 l_bpcc_size ;
  OPJ_BYTE *l_bpcc_data ;
  OPJ_BYTE *l_current_bpcc_ptr ;
  void *__cil_tmp9___1 ;

  {
  {
#line 694
  l_bpcc_size = 8U + jp2___1->numcomps;
#line 696
  __cil_tmp9___1 = opj_calloc((size_t )1, (size_t )l_bpcc_size);
#line 696
  l_bpcc_data = (OPJ_BYTE *)__cil_tmp9___1;
  }
#line 697
  if ((unsigned long )l_bpcc_data == (unsigned long )((OPJ_BYTE *)0)) {
#line 698
    return ((OPJ_BYTE *)0);
  }
  {
#line 701
  l_current_bpcc_ptr = l_bpcc_data;
#line 703
  opj_write_bytes_LE(l_current_bpcc_ptr, l_bpcc_size, (OPJ_UINT32 )4);
#line 705
  l_current_bpcc_ptr += 4;
#line 707
  opj_write_bytes_LE(l_current_bpcc_ptr, (OPJ_UINT32 )1651532643, (OPJ_UINT32 )4);
#line 708
  l_current_bpcc_ptr += 4;
#line 710
  i___1 = (OPJ_UINT32 )0;
  }
  {
#line 710
  while (1) {
    while_continue: /* CIL Label */ ;

#line 710
    if (! (i___1 < jp2___1->numcomps)) {
#line 710
      goto while_break;
    }
    {
#line 711
    opj_write_bytes_LE(l_current_bpcc_ptr, (jp2___1->comps + i___1)->bpcc, (OPJ_UINT32 )1);
#line 713
    l_current_bpcc_ptr ++;
#line 710
    i___1 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: 
#line 716
  *p_nb_bytes_written___0 = l_bpcc_size;
#line 718
  return (l_bpcc_data);
}
}
#line 721 "/root/patron-new/39/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_read_bpcc(opj_jp2_t *jp2___2 , OPJ_BYTE *p_bpc_header_data ,
                                  OPJ_UINT32 p_bpc_header_size , opj_event_mgr_t *p_manager___1 ) 
{ 
  OPJ_UINT32 i___2 ;

  {
#line 735
  if (jp2___2->bpc != 255U) {
    {
#line 736
    opj_event_msg(p_manager___1, 2, "A BPCC header box is available although BPC given by the IHDR box (%d) indicate components bit depth is constant\n",
                  jp2___2->bpc);
    }
  }
#line 742
  if (p_bpc_header_size != jp2___2->numcomps) {
    {
#line 743
    opj_event_msg(p_manager___1, 1, "Bad BPCC header box (bad size)\n");
    }
#line 744
    return (0);
  }
#line 748
  i___2 = (OPJ_UINT32 )0;
  {
#line 748
  while (1) {
    while_continue: /* CIL Label */ ;

#line 748
    if (! (i___2 < jp2___2->numcomps)) {
#line 748
      goto while_break;
    }
    {
#line 749
    opj_read_bytes_LE(p_bpc_header_data, & (jp2___2->comps + i___2)->bpcc, (OPJ_UINT32 )1);
#line 751
    p_bpc_header_data ++;
#line 748
    i___2 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 754
  return (1);
}
}
#line 756 "/root/patron-new/39/src/lib/openjp2/jp2.c"
static OPJ_BYTE *opj_jp2_write_cdef(opj_jp2_t *jp2___3 , OPJ_UINT32 *p_nb_bytes_written___1 ) 
{ 
  OPJ_UINT32 l_cdef_size ;
  OPJ_BYTE *l_cdef_data ;
  OPJ_BYTE *l_current_cdef_ptr ;
  OPJ_UINT32 l_value ;
  OPJ_UINT16 i___3 ;
  void *__cil_tmp13___0 ;

  {
  {
#line 760
  l_cdef_size = (OPJ_UINT32 )10;
#line 772
  l_cdef_size += 6U * (unsigned int )(jp2___3->color.jp2_cdef)->n;
#line 774
  __cil_tmp13___0 = opj_malloc((size_t )l_cdef_size);
#line 774
  l_cdef_data = (OPJ_BYTE *)__cil_tmp13___0;
  }
#line 775
  if ((unsigned long )l_cdef_data == (unsigned long )((OPJ_BYTE *)0)) {
#line 776
    return ((OPJ_BYTE *)0);
  }
  {
#line 779
  l_current_cdef_ptr = l_cdef_data;
#line 781
  opj_write_bytes_LE(l_current_cdef_ptr, l_cdef_size, (OPJ_UINT32 )4);
#line 782
  l_current_cdef_ptr += 4;
#line 784
  opj_write_bytes_LE(l_current_cdef_ptr, (OPJ_UINT32 )1667523942, (OPJ_UINT32 )4);
#line 785
  l_current_cdef_ptr += 4;
#line 787
  l_value = (OPJ_UINT32 )(jp2___3->color.jp2_cdef)->n;
#line 788
  opj_write_bytes_LE(l_current_cdef_ptr, l_value, (OPJ_UINT32 )2);
#line 789
  l_current_cdef_ptr += 2;
#line 791
  i___3 = (OPJ_UINT16 )0U;
  }
  {
#line 791
  while (1) {
    while_continue: /* CIL Label */ ;

#line 791
    if (! ((int )i___3 < (int )(jp2___3->color.jp2_cdef)->n)) {
#line 791
      goto while_break;
    }
    {
#line 792
    l_value = (OPJ_UINT32 )((jp2___3->color.jp2_cdef)->info + (int )i___3)->cn;
#line 793
    opj_write_bytes_LE(l_current_cdef_ptr, l_value, (OPJ_UINT32 )2);
#line 794
    l_current_cdef_ptr += 2;
#line 795
    l_value = (OPJ_UINT32 )((jp2___3->color.jp2_cdef)->info + (int )i___3)->typ;
#line 796
    opj_write_bytes_LE(l_current_cdef_ptr, l_value, (OPJ_UINT32 )2);
#line 797
    l_current_cdef_ptr += 2;
#line 798
    l_value = (OPJ_UINT32 )((jp2___3->color.jp2_cdef)->info + (int )i___3)->asoc;
#line 799
    opj_write_bytes_LE(l_current_cdef_ptr, l_value, (OPJ_UINT32 )2);
#line 800
    l_current_cdef_ptr += 2;
#line 791
    i___3 = (OPJ_UINT16 )((int )i___3 + 1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: 
#line 802
  *p_nb_bytes_written___1 = l_cdef_size;
#line 804
  return (l_cdef_data);
}
}
#line 807 "/root/patron-new/39/src/lib/openjp2/jp2.c"
static OPJ_BYTE *opj_jp2_write_colr(opj_jp2_t *jp2___4 , OPJ_UINT32 *p_nb_bytes_written___2 ) 
{ 
  OPJ_UINT32 l_colr_size ;
  OPJ_BYTE *l_colr_data ;
  OPJ_BYTE *l_current_colr_ptr ;
  void *__cil_tmp10___0 ;
  OPJ_UINT32 i___4 ;

  {
#line 812
  l_colr_size = (OPJ_UINT32 )11;
#line 821
  if (jp2___4->meth == 1U) {
#line 821
    goto case_1;
  }
#line 828
  goto switch_default;
  case_1: 
#line 822
  l_colr_size += 4U;
#line 823
  goto switch_break;
#line 826
  l_colr_size += jp2___4->color.icc_profile_len;
#line 827
  goto switch_break;
  switch_default: 
#line 829
  return ((OPJ_BYTE *)0);
  switch_break: 
  {
#line 832
  __cil_tmp10___0 = opj_calloc((size_t )1, (size_t )l_colr_size);
#line 832
  l_colr_data = (OPJ_BYTE *)__cil_tmp10___0;
  }
#line 833
  if ((unsigned long )l_colr_data == (unsigned long )((OPJ_BYTE *)0)) {
#line 834
    return ((OPJ_BYTE *)0);
  }
  {
#line 837
  l_current_colr_ptr = l_colr_data;
#line 839
  opj_write_bytes_LE(l_current_colr_ptr, l_colr_size, (OPJ_UINT32 )4);
#line 841
  l_current_colr_ptr += 4;
#line 843
  opj_write_bytes_LE(l_current_colr_ptr, (OPJ_UINT32 )1668246642, (OPJ_UINT32 )4);
#line 844
  l_current_colr_ptr += 4;
#line 846
  opj_write_bytes_LE(l_current_colr_ptr, jp2___4->meth, (OPJ_UINT32 )1);
#line 847
  l_current_colr_ptr ++;
#line 849
  opj_write_bytes_LE(l_current_colr_ptr, jp2___4->precedence, (OPJ_UINT32 )1);
#line 850
  l_current_colr_ptr ++;
#line 852
  opj_write_bytes_LE(l_current_colr_ptr, jp2___4->approx, (OPJ_UINT32 )1);
#line 853
  l_current_colr_ptr ++;
  }
#line 855
  if (jp2___4->meth == 1U) {
    {
#line 857
    opj_write_bytes_LE(l_current_colr_ptr, jp2___4->enumcs, (OPJ_UINT32 )4);
    }
  } else
#line 860
  if (jp2___4->meth == 2U) {
#line 862
    i___4 = (OPJ_UINT32 )0;
    {
#line 862
    while (1) {
      while_continue: /* CIL Label */ ;

#line 862
      if (! (i___4 < jp2___4->color.icc_profile_len)) {
#line 862
        goto while_break;
      }
      {
#line 863
      opj_write_bytes_LE(l_current_colr_ptr, (OPJ_UINT32 )*(jp2___4->color.icc_profile_buf + i___4),
                         (OPJ_UINT32 )1);
#line 864
      l_current_colr_ptr ++;
#line 862
      i___4 ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }

    while_break: ;
  }
#line 869
  *p_nb_bytes_written___2 = l_colr_size;
#line 871
  return (l_colr_data);
}
}
#line 874 "/root/patron-new/39/src/lib/openjp2/jp2.c"
static void opj_jp2_free_pclr(opj_jp2_color_t *color ) 
{ 


  {
  {
#line 876
  opj_free((void *)(color->jp2_pclr)->channel_sign);
#line 877
  opj_free((void *)(color->jp2_pclr)->channel_size);
#line 878
  opj_free((void *)(color->jp2_pclr)->entries);
  }
#line 880
  if ((color->jp2_pclr)->cmap) {
    {
#line 881
    opj_free((void *)(color->jp2_pclr)->cmap);
    }
  }
  {
#line 884
  opj_free((void *)color->jp2_pclr);
#line 885
  color->jp2_pclr = (opj_jp2_pclr_t *)((void *)0);
  }
#line 887
  return;
}
}
#line 888 "/root/patron-new/39/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_check_color(opj_image_t *image , opj_jp2_color_t *color___0 ,
                                    opj_event_mgr_t *p_manager___2 ) 
{ 
  OPJ_UINT16 i___5 ;
  opj_jp2_cdef_info_t *info ;
  OPJ_UINT16 n ;
  OPJ_UINT32 nr_channels ;
  OPJ_UINT16 nr_channels___0 ;
  opj_jp2_cmap_comp_t *cmap ;
  OPJ_BOOL *pcol_usage ;
  OPJ_BOOL is_sane ;
  void *__cil_tmp14 ;
  OPJ_BYTE mtyp ;
  OPJ_BYTE pcol ;

  {
#line 894
  if (color___0->jp2_cdef) {
#line 895
    info = (color___0->jp2_cdef)->info;
#line 896
    n = (color___0->jp2_cdef)->n;
#line 897
    nr_channels = image->numcomps;
#line 901
    if (color___0->jp2_pclr) {
#line 901
      if ((color___0->jp2_pclr)->cmap) {
#line 902
        nr_channels = (OPJ_UINT32 )(color___0->jp2_pclr)->nr_channels;
      }
    }
#line 905
    i___5 = (OPJ_UINT16 )0;
    {
#line 905
    while (1) {
      while_continue___0: /* CIL Label */ ;

      while_continue: ;
#line 905
      if (! ((int )i___5 < (int )n)) {
#line 905
        goto while_break;
      }
#line 906
      if ((unsigned int )(info + (int )i___5)->cn >= nr_channels) {
        {
#line 907
        opj_event_msg(p_manager___2, 1, "Invalid component index %d (>= %d).\n", (int )(info + (int )i___5)->cn,
                      nr_channels);
        }
#line 909
        return (0);
      }
#line 911
      if ((unsigned int )(info + (int )i___5)->asoc == 65535U) {
#line 912
        goto while_continue;
      }
#line 915
      if ((int )(info + (int )i___5)->asoc > 0) {
#line 915
        if ((OPJ_UINT32 )((int )(info + (int )i___5)->asoc - 1) >= nr_channels) {
          {
#line 916
          opj_event_msg(p_manager___2, 1, "Invalid component index %d (>= %d).\n",
                        (int )(info + (int )i___5)->asoc - 1, nr_channels);
          }
#line 918
          return (0);
        }
      }
#line 905
      i___5 = (OPJ_UINT16 )((int )i___5 + 1);
    }
    while_break___7: /* CIL Label */ ;
    }

    while_break: ;
    {
#line 924
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 924
      if (! (nr_channels > 0U)) {
#line 924
        goto while_break___0;
      }
#line 925
      i___5 = (OPJ_UINT16 )0;
      {
#line 925
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 925
        if (! ((int )i___5 < (int )n)) {
#line 925
          goto while_break___1;
        }
#line 926
        if ((OPJ_UINT32 )(info + (int )i___5)->cn == nr_channels - 1U) {
#line 927
          goto while_break___1;
        }
#line 925
        i___5 = (OPJ_UINT16 )((int )i___5 + 1);
      }
      while_break___9: /* CIL Label */ ;
      }

      while_break___1: ;
#line 930
      if ((int )i___5 == (int )n) {
        {
#line 931
        opj_event_msg(p_manager___2, 1, "Incomplete channel definitions.\n\220");
        }
#line 932
        return (0);
      }
#line 934
      nr_channels --;
    }
    while_break___8: /* CIL Label */ ;
    }

    while_break___0: ;
  }
#line 940
  if (color___0->jp2_pclr) {
#line 940
    if ((color___0->jp2_pclr)->cmap) {
#line 941
      nr_channels___0 = (OPJ_UINT16 )(color___0->jp2_pclr)->nr_channels;
#line 942
      cmap = (color___0->jp2_pclr)->cmap;
#line 943
      is_sane = 1;
#line 946
      i___5 = (OPJ_UINT16 )0;
      {
#line 946
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 946
        if (! ((int )i___5 < (int )nr_channels___0)) {
#line 946
          goto while_break___2;
        }
#line 947
        if ((unsigned int )(cmap + (int )i___5)->cmp >= image->numcomps) {
          {
#line 948
          opj_event_msg(p_manager___2, 1, "Invalid component index %d (>= %d).\n",
                        (int )(cmap + (int )i___5)->cmp, image->numcomps);
#line 950
          is_sane = 0;
          }
        }
#line 946
        i___5 = (OPJ_UINT16 )((int )i___5 + 1);
      }
      while_break___10: /* CIL Label */ ;
      }

      while_break___2: 
      {
#line 954
      __cil_tmp14 = opj_calloc((size_t )nr_channels___0, sizeof(OPJ_BOOL ));
#line 954
      pcol_usage = (OPJ_BOOL *)__cil_tmp14;
      }
#line 955
      if (! pcol_usage) {
        {
#line 956
        opj_event_msg(p_manager___2, 1, "Unexpected OOM.\n\220");
        }
#line 957
        return (0);
      }
#line 960
      i___5 = (OPJ_UINT16 )0;
      {
#line 960
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 960
        if (! ((int )i___5 < (int )nr_channels___0)) {
#line 960
          goto while_break___3;
        }
#line 961
        mtyp = (cmap + (int )i___5)->mtyp;
#line 962
        pcol = (cmap + (int )i___5)->pcol;
#line 964
        if ((int )mtyp != 0) {
#line 964
          if ((int )mtyp != 1) {
            {
#line 965
            opj_event_msg(p_manager___2, 1, "Invalid value for cmap[%d].mtyp = %d.\n",
                          (int )i___5, (int )mtyp);
#line 968
            is_sane = 0;
            }
          } else {
#line 964
            goto _L___11;
          }
        } else
        _L___11: 
#line 969
        if ((int )pcol >= (int )nr_channels___0) {
          {
#line 970
          opj_event_msg(p_manager___2, 1, "Invalid component/palette index for direct mapping %d.\n",
                        (int )pcol);
#line 972
          is_sane = 0;
          }
        } else
#line 973
        if (*(pcol_usage + (int )pcol)) {
#line 973
          if ((int )mtyp == 1) {
            {
#line 974
            opj_event_msg(p_manager___2, 1, "Component %d is mapped twice.\n", (int )pcol);
#line 975
            is_sane = 0;
            }
          } else {
#line 973
            goto _L___10;
          }
        } else
        _L___10: 
#line 976
        if ((int )mtyp == 0) {
#line 976
          if ((int )pcol != 0) {
            {
#line 979
            opj_event_msg(p_manager___2, 1, "Direct use at #%d however pcol=%d.\n",
                          (int )i___5, (int )pcol);
#line 981
            is_sane = 0;
            }
          } else {
#line 976
            goto _L;
          }
        } else
        _L: 
#line 982
        if ((int )mtyp == 1) {
#line 982
          if ((int )pcol != (int )i___5) {
            {
#line 985
            opj_event_msg(p_manager___2, 1, "Implementation limitation: for palette mapping, pcol[%d] should be equal to %d, but is equal to %d.\n",
                          (int )i___5, (int )i___5, (int )pcol);
#line 989
            is_sane = 0;
            }
          } else {
#line 991
            *(pcol_usage + (int )pcol) = 1;
          }
        } else {
#line 991
          *(pcol_usage + (int )pcol) = 1;
        }
#line 960
        i___5 = (OPJ_UINT16 )((int )i___5 + 1);
      }
      while_break___11: /* CIL Label */ ;
      }

      while_break___3: 
#line 995
      i___5 = (OPJ_UINT16 )0;
      {
#line 995
      while (1) {
        while_continue___5: /* CIL Label */ ;

#line 995
        if (! ((int )i___5 < (int )nr_channels___0)) {
#line 995
          goto while_break___4;
        }
#line 996
        if (! *(pcol_usage + (int )i___5)) {
#line 996
          if ((int )(cmap + (int )i___5)->mtyp != 0) {
            {
#line 997
            opj_event_msg(p_manager___2, 1, "Component %d doesn\'t have a mapping.\n",
                          (int )i___5);
#line 999
            is_sane = 0;
            }
          }
        }
#line 995
        i___5 = (OPJ_UINT16 )((int )i___5 + 1);
      }
      while_break___12: /* CIL Label */ ;
      }

      while_break___4: ;
#line 1003
      if (is_sane) {
#line 1003
        if (image->numcomps == 1U) {
#line 1004
          i___5 = (OPJ_UINT16 )0;
          {
#line 1004
          while (1) {
            while_continue___6: /* CIL Label */ ;

#line 1004
            if (! ((int )i___5 < (int )nr_channels___0)) {
#line 1004
              goto while_break___5;
            }
#line 1005
            if (! *(pcol_usage + (int )i___5)) {
              {
#line 1006
              is_sane = (OPJ_BOOL )0U;
#line 1007
              opj_event_msg(p_manager___2, 2, "Component mapping seems wrong. Trying to correct.\n");
              }
#line 1009
              goto while_break___5;
            }
#line 1004
            i___5 = (OPJ_UINT16 )((int )i___5 + 1);
          }
          while_break___13: /* CIL Label */ ;
          }

          while_break___5: ;
#line 1012
          if (! is_sane) {
#line 1013
            is_sane = 1;
#line 1014
            i___5 = (OPJ_UINT16 )0;
            {
#line 1014
            while (1) {
              while_continue___7: /* CIL Label */ ;

#line 1014
              if (! ((int )i___5 < (int )nr_channels___0)) {
#line 1014
                goto while_break___6;
              }
#line 1015
              (cmap + (int )i___5)->mtyp = (OPJ_BYTE )1U;
#line 1016
              (cmap + (int )i___5)->pcol = (OPJ_BYTE )i___5;
#line 1014
              i___5 = (OPJ_UINT16 )((int )i___5 + 1);
            }
            while_break___14: /* CIL Label */ ;
            }

            while_break___6: ;
          }
        }
      }
      {
#line 1020
      opj_free((void *)pcol_usage);
      }
#line 1021
      if (! is_sane) {
#line 1022
        return (0);
      }
    }
  }
#line 1026
  return (1);
}
}
#line 1030 "/root/patron-new/39/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_apply_pclr(opj_image_t *image___0 , opj_jp2_color_t *color___1 ,
                                   opj_event_mgr_t *p_manager___3 ) 
{ 
  opj_image_comp_t *old_comps ;
  opj_image_comp_t *new_comps ;
  OPJ_BYTE *channel_size ;
  OPJ_BYTE *channel_sign ;
  OPJ_UINT32 *entries ;
  opj_jp2_cmap_comp_t *cmap___0 ;
  OPJ_INT32 *src ;
  OPJ_INT32 *dst ;
  OPJ_UINT32 j ;
  OPJ_UINT32 max ;
  OPJ_UINT16 i___6 ;
  OPJ_UINT16 nr_channels___1 ;
  OPJ_UINT16 cmp ;
  OPJ_UINT16 pcol___0 ;
  OPJ_INT32 k___0 ;
  OPJ_INT32 top_k ;
  void *__cil_tmp20___0 ;
  void *__cil_tmp23 ;

  {
#line 1043
  channel_size = (color___1->jp2_pclr)->channel_size;
#line 1044
  channel_sign = (color___1->jp2_pclr)->channel_sign;
#line 1045
  entries = (color___1->jp2_pclr)->entries;
#line 1046
  cmap___0 = (color___1->jp2_pclr)->cmap;
#line 1047
  nr_channels___1 = (OPJ_UINT16 )(color___1->jp2_pclr)->nr_channels;
#line 1049
  i___6 = (OPJ_UINT16 )0;
  {
#line 1049
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1049
    if (! ((int )i___6 < (int )nr_channels___1)) {
#line 1049
      goto while_break;
    }
#line 1051
    cmp = (cmap___0 + (int )i___6)->cmp;
#line 1052
    if ((unsigned long )(image___0->comps + (int )cmp)->data == (unsigned long )((void *)0)) {
      {
#line 1053
      opj_event_msg(p_manager___3, 1, "image->comps[%d].data == NULL in opj_jp2_apply_pclr().\n",
                    (int )i___6);
      }
#line 1055
      return (0);
    }
#line 1049
    i___6 = (OPJ_UINT16 )((int )i___6 + 1);
  }
  while_break___6: /* CIL Label */ ;
  }

  while_break: 
  {
#line 1059
  old_comps = image___0->comps;
#line 1060
  __cil_tmp20___0 = opj_malloc((unsigned long )nr_channels___1 * sizeof(opj_image_comp_t ));
#line 1060
  new_comps = (opj_image_comp_t *)__cil_tmp20___0;
  }
#line 1062
  if (! new_comps) {
    {
#line 1063
    opj_event_msg(p_manager___3, 1, "Memory allocation failure in opj_jp2_apply_pclr().\n");
    }
#line 1065
    return (0);
  }
#line 1067
  i___6 = (OPJ_UINT16 )0;
  {
#line 1067
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 1067
    if (! ((int )i___6 < (int )nr_channels___1)) {
#line 1067
      goto while_break___0;
    }
#line 1068
    pcol___0 = (OPJ_UINT16 )(cmap___0 + (int )i___6)->pcol;
#line 1069
    cmp = (cmap___0 + (int )i___6)->cmp;
#line 1072
    if ((int )(cmap___0 + (int )i___6)->mtyp == 0) {
#line 1074
      *(new_comps + (int )i___6) = *(old_comps + (int )cmp);
    } else {
#line 1077
      *(new_comps + (int )pcol___0) = *(old_comps + (int )cmp);
    }
    {
#line 1081
    __cil_tmp23 = opj_image_data_alloc((sizeof(OPJ_INT32 ) * (unsigned long )(old_comps + (int )cmp)->w) * (unsigned long )(old_comps + (int )cmp)->h);
#line 1081
    (new_comps + (int )i___6)->data = (OPJ_INT32 *)__cil_tmp23;
    }
#line 1083
    if (! (new_comps + (int )i___6)->data) {
      {
#line 1084
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 1084
        if (! ((int )i___6 > 0)) {
#line 1084
          goto while_break___1;
        }
        {
#line 1085
        i___6 = (OPJ_UINT16 )((int )i___6 - 1);
#line 1086
        opj_image_data_free((void *)(new_comps + (int )i___6)->data);
        }
      }
      while_break___8: /* CIL Label */ ;
      }

      while_break___1: 
      {
#line 1088
      opj_free((void *)new_comps);
#line 1089
      opj_event_msg(p_manager___3, 1, "Memory allocation failure in opj_jp2_apply_pclr().\n\005]U");
      }
#line 1091
      return (0);
    }
#line 1093
    (new_comps + (int )i___6)->prec = (OPJ_UINT32 )*(channel_size + (int )i___6);
#line 1094
    (new_comps + (int )i___6)->sgnd = (OPJ_UINT32 )*(channel_sign + (int )i___6);
#line 1067
    i___6 = (OPJ_UINT16 )((int )i___6 + 1);
  }
  while_break___7: /* CIL Label */ ;
  }

  while_break___0: 
#line 1097
  top_k = (int )(color___1->jp2_pclr)->nr_entries - 1;
#line 1099
  i___6 = (OPJ_UINT16 )0;
  {
#line 1099
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 1099
    if (! ((int )i___6 < (int )nr_channels___1)) {
#line 1099
      goto while_break___2;
    }
#line 1101
    cmp = (cmap___0 + (int )i___6)->cmp;
#line 1102
    pcol___0 = (OPJ_UINT16 )(cmap___0 + (int )i___6)->pcol;
#line 1103
    src = (old_comps + (int )cmp)->data;
#line 1105
    max = (new_comps + (int )pcol___0)->w * (new_comps + (int )pcol___0)->h;
#line 1108
    if ((int )(cmap___0 + (int )i___6)->mtyp == 0) {
#line 1109
      dst = (new_comps + (int )i___6)->data;
#line 1111
      j = (OPJ_UINT32 )0;
      {
#line 1111
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 1111
        if (! (j < max)) {
#line 1111
          goto while_break___3;
        }
#line 1112
        *(dst + j) = *(src + j);
#line 1111
        j ++;
      }
      while_break___10: /* CIL Label */ ;
      }

      while_break___3: ;
    } else {
#line 1116
      dst = (new_comps + (int )pcol___0)->data;
#line 1118
      j = (OPJ_UINT32 )0;
      {
#line 1118
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 1118
        if (! (j < max)) {
#line 1118
          goto while_break___4;
        }
#line 1120
        k___0 = *(src + j);
#line 1120
        if (k___0 < 0) {
#line 1121
          k___0 = 0;
        } else
#line 1122
        if (k___0 > top_k) {
#line 1123
          k___0 = top_k;
        }
#line 1127
        *(dst + j) = (OPJ_INT32 )*(entries + (k___0 * (int )nr_channels___1 + (int )pcol___0));
#line 1118
        j ++;
      }
      while_break___11: /* CIL Label */ ;
      }

      while_break___4: ;
    }
#line 1099
    i___6 = (OPJ_UINT16 )((int )i___6 + 1);
  }
  while_break___9: /* CIL Label */ ;
  }

  while_break___2: 
#line 1132
  max = image___0->numcomps;
#line 1133
  i___6 = (OPJ_UINT16 )0;
  {
#line 1133
  while (1) {
    while_continue___5: /* CIL Label */ ;

#line 1133
    if (! ((unsigned int )i___6 < max)) {
#line 1133
      goto while_break___5;
    }
#line 1134
    if ((old_comps + (int )i___6)->data) {
      {
#line 1135
      opj_image_data_free((void *)(old_comps + (int )i___6)->data);
      }
    }
#line 1133
    i___6 = (OPJ_UINT16 )((int )i___6 + 1);
  }
  while_break___12: /* CIL Label */ ;
  }

  while_break___5: 
  {
#line 1139
  opj_free((void *)old_comps);
#line 1140
  image___0->comps = new_comps;
#line 1141
  image___0->numcomps = (OPJ_UINT32 )nr_channels___1;
  }
#line 1143
  return (1);
}
}
#line 1146 "/root/patron-new/39/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_read_pclr(opj_jp2_t *jp2___5 , OPJ_BYTE *p_pclr_header_data ,
                                  OPJ_UINT32 p_pclr_header_size , opj_event_mgr_t *p_manager___4 ) 
{ 
  opj_jp2_pclr_t *jp2_pclr ;
  OPJ_BYTE *channel_size___0 ;
  OPJ_BYTE *channel_sign___0 ;
  OPJ_UINT32 *entries___0 ;
  OPJ_UINT16 nr_entries ;
  OPJ_UINT16 nr_channels___2 ;
  OPJ_UINT16 i___7 ;
  OPJ_UINT16 j___0 ;
  OPJ_UINT32 l_value___0 ;
  OPJ_BYTE *orig_header_data ;
  void *__cil_tmp18___0 ;
  void *__cil_tmp19___0 ;
  void *__cil_tmp20___1 ;
  void *__cil_tmp21 ;
  int tmp___51 ;
  OPJ_UINT32 bytes_to_read ;

  {
#line 1158
  orig_header_data = p_pclr_header_data;
#line 1166
  if (jp2___5->color.jp2_pclr) {
#line 1167
    return (0);
  }
#line 1170
  if (p_pclr_header_size < 3U) {
#line 1171
    return (0);
  }
  {
#line 1174
  opj_read_bytes_LE(p_pclr_header_data, & l_value___0, (OPJ_UINT32 )2);
#line 1175
  p_pclr_header_data += 2;
#line 1176
  nr_entries = (OPJ_UINT16 )l_value___0;
  }
#line 1177
  if ((unsigned int )nr_entries == 0U) {
    {
#line 1178
    opj_event_msg(p_manager___4, 1, "Invalid PCLR box. Reports %d entries\nU", (int )nr_entries);
    }
#line 1180
    return (0);
  } else
#line 1177
  if ((unsigned int )nr_entries > 1024U) {
    {
#line 1178
    opj_event_msg(p_manager___4, 1, "Invalid PCLR box. Reports %d entries\nU", (int )nr_entries);
    }
#line 1180
    return (0);
  }
  {
#line 1183
  opj_read_bytes_LE(p_pclr_header_data, & l_value___0, (OPJ_UINT32 )1);
#line 1184
  p_pclr_header_data ++;
#line 1185
  nr_channels___2 = (OPJ_UINT16 )l_value___0;
  }
#line 1186
  if ((unsigned int )nr_channels___2 == 0U) {
    {
#line 1187
    opj_event_msg(p_manager___4, 1, "Invalid PCLR box. Reports 0 palette columns\n");
    }
#line 1189
    return (0);
  }
#line 1192
  if (p_pclr_header_size < 3U + (OPJ_UINT32 )nr_channels___2) {
#line 1193
    return (0);
  }
  {
#line 1196
  __cil_tmp18___0 = opj_malloc((sizeof(OPJ_UINT32 ) * (unsigned long )nr_channels___2) * (unsigned long )nr_entries);
#line 1196
  entries___0 = (OPJ_UINT32 *)__cil_tmp18___0;
  }
#line 1198
  if (! entries___0) {
#line 1199
    return (0);
  }
  {
#line 1201
  __cil_tmp19___0 = opj_malloc((size_t )nr_channels___2);
#line 1201
  channel_size___0 = (OPJ_BYTE *)__cil_tmp19___0;
  }
#line 1202
  if (! channel_size___0) {
    {
#line 1203
    opj_free((void *)entries___0);
    }
#line 1204
    return (0);
  }
  {
#line 1206
  __cil_tmp20___1 = opj_malloc((size_t )nr_channels___2);
#line 1206
  channel_sign___0 = (OPJ_BYTE *)__cil_tmp20___1;
  }
#line 1207
  if (! channel_sign___0) {
    {
#line 1208
    opj_free((void *)entries___0);
#line 1209
    opj_free((void *)channel_size___0);
    }
#line 1210
    return (0);
  }
  {
#line 1213
  __cil_tmp21 = opj_malloc(sizeof(opj_jp2_pclr_t ));
#line 1213
  jp2_pclr = (opj_jp2_pclr_t *)__cil_tmp21;
  }
#line 1214
  if (! jp2_pclr) {
    {
#line 1215
    opj_free((void *)entries___0);
#line 1216
    opj_free((void *)channel_size___0);
#line 1217
    opj_free((void *)channel_sign___0);
    }
#line 1218
    return (0);
  }
#line 1221
  jp2_pclr->channel_sign = channel_sign___0;
#line 1222
  jp2_pclr->channel_size = channel_size___0;
#line 1223
  jp2_pclr->entries = entries___0;
#line 1224
  jp2_pclr->nr_entries = nr_entries;
#line 1225
  jp2_pclr->nr_channels = (OPJ_BYTE )l_value___0;
#line 1226
  jp2_pclr->cmap = (opj_jp2_cmap_comp_t *)((void *)0);
#line 1228
  jp2___5->color.jp2_pclr = jp2_pclr;
#line 1230
  i___7 = (OPJ_UINT16 )0;
  {
#line 1230
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1230
    if (! ((int )i___7 < (int )nr_channels___2)) {
#line 1230
      goto while_break;
    }
    {
#line 1231
    opj_read_bytes_LE(p_pclr_header_data, & l_value___0, (OPJ_UINT32 )1);
#line 1232
    p_pclr_header_data ++;
#line 1234
    *(channel_size___0 + (int )i___7) = (OPJ_BYTE )((l_value___0 & 127U) + 1U);
    }
#line 1235
    if (l_value___0 & 128U) {
#line 1235
      tmp___51 = 1;
    } else {
#line 1235
      tmp___51 = 0;
    }
#line 1235
    *(channel_sign___0 + (int )i___7) = (OPJ_BYTE )tmp___51;
#line 1230
    i___7 = (OPJ_UINT16 )((int )i___7 + 1);
  }
  while_break___2: /* CIL Label */ ;
  }

  while_break: 
#line 1238
  j___0 = (OPJ_UINT16 )0;
  {
#line 1238
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 1238
    if (! ((int )j___0 < (int )nr_entries)) {
#line 1238
      goto while_break___0;
    }
#line 1239
    i___7 = (OPJ_UINT16 )0;
    {
#line 1239
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 1239
      if (! ((int )i___7 < (int )nr_channels___2)) {
#line 1239
        goto while_break___1;
      }
#line 1240
      bytes_to_read = (OPJ_UINT32 )(((int )*(channel_size___0 + (int )i___7) + 7) >> 3);
#line 1242
      if ((unsigned long )bytes_to_read > sizeof(OPJ_UINT32 )) {
#line 1243
        bytes_to_read = (OPJ_UINT32 )sizeof(OPJ_UINT32 );
      }
#line 1245
      if ((ptrdiff_t )p_pclr_header_size < (p_pclr_header_data - orig_header_data) + (ptrdiff_t )bytes_to_read) {
#line 1247
        return (0);
      }
      {
#line 1250
      opj_read_bytes_LE(p_pclr_header_data, & l_value___0, bytes_to_read);
#line 1251
      p_pclr_header_data += bytes_to_read;
#line 1252
      *entries___0 = l_value___0;
#line 1253
      entries___0 ++;
#line 1239
      i___7 = (OPJ_UINT16 )((int )i___7 + 1);
      }
    }
    while_break___4: /* CIL Label */ ;
    }

    while_break___1: 
#line 1238
    j___0 = (OPJ_UINT16 )((int )j___0 + 1);
  }
  while_break___3: /* CIL Label */ ;
  }

  while_break___0: ;
#line 1257
  return (1);
}
}
#line 1260 "/root/patron-new/39/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_read_cmap(opj_jp2_t *jp2___6 , OPJ_BYTE *p_cmap_header_data ,
                                  OPJ_UINT32 p_cmap_header_size , opj_event_mgr_t *p_manager___5 ) 
{ 
  opj_jp2_cmap_comp_t *cmap___1 ;
  OPJ_BYTE i___8 ;
  OPJ_BYTE nr_channels___3 ;
  OPJ_UINT32 l_value___1 ;
  void *__cil_tmp12___0 ;

  {
#line 1277
  if ((unsigned long )jp2___6->color.jp2_pclr == (unsigned long )((void *)0)) {
    {
#line 1278
    opj_event_msg(p_manager___5, 1, "Need to read a PCLR box before the CMAP box.\nU");
    }
#line 1280
    return (0);
  }
#line 1286
  if ((jp2___6->color.jp2_pclr)->cmap) {
    {
#line 1287
    opj_event_msg(p_manager___5, 1, "Only one CMAP box is allowed.\n");
    }
#line 1288
    return (0);
  }
#line 1291
  nr_channels___3 = (jp2___6->color.jp2_pclr)->nr_channels;
#line 1292
  if (p_cmap_header_size < (OPJ_UINT32 )nr_channels___3 * 4U) {
    {
#line 1293
    opj_event_msg(p_manager___5, 1, "Insufficient data for CMAP box.\n\220");
    }
#line 1294
    return (0);
  }
  {
#line 1297
  __cil_tmp12___0 = opj_malloc((unsigned long )nr_channels___3 * sizeof(opj_jp2_cmap_comp_t ));
#line 1297
  cmap___1 = (opj_jp2_cmap_comp_t *)__cil_tmp12___0;
  }
#line 1299
  if (! cmap___1) {
#line 1300
    return (0);
  }
#line 1304
  i___8 = (OPJ_BYTE )0;
  {
#line 1304
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1304
    if (! ((int )i___8 < (int )nr_channels___3)) {
#line 1304
      goto while_break;
    }
    {
#line 1305
    opj_read_bytes_LE(p_cmap_header_data, & l_value___1, (OPJ_UINT32 )2);
#line 1306
    p_cmap_header_data += 2;
#line 1307
    (cmap___1 + (int )i___8)->cmp = (OPJ_UINT16 )l_value___1;
#line 1309
    opj_read_bytes_LE(p_cmap_header_data, & l_value___1, (OPJ_UINT32 )1);
#line 1310
    p_cmap_header_data ++;
#line 1311
    (cmap___1 + (int )i___8)->mtyp = (OPJ_BYTE )l_value___1;
#line 1313
    opj_read_bytes_LE(p_cmap_header_data, & l_value___1, (OPJ_UINT32 )1);
#line 1314
    p_cmap_header_data ++;
#line 1315
    (cmap___1 + (int )i___8)->pcol = (OPJ_BYTE )l_value___1;
#line 1304
    i___8 = (OPJ_BYTE )((int )i___8 + 1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: 
#line 1318
  (jp2___6->color.jp2_pclr)->cmap = cmap___1;
#line 1320
  return (1);
}
}
#line 1323 "/root/patron-new/39/src/lib/openjp2/jp2.c"
static void opj_jp2_apply_cdef(opj_image_t *image___1 , opj_jp2_color_t *color___2 ,
                               opj_event_mgr_t *manager ) 
{ 
  opj_jp2_cdef_info_t *info___0 ;
  OPJ_UINT16 i___9 ;
  OPJ_UINT16 n___0 ;
  OPJ_UINT16 cn ;
  OPJ_UINT16 asoc ;
  OPJ_UINT16 acn ;
  opj_image_comp_t saved ;
  OPJ_UINT16 j___1 ;

  {
#line 1329
  info___0 = (color___2->jp2_cdef)->info;
#line 1330
  n___0 = (color___2->jp2_cdef)->n;
#line 1332
  i___9 = (OPJ_UINT16 )0;
  {
#line 1332
  while (1) {
    while_continue___0: /* CIL Label */ ;

    while_continue: ;
#line 1332
    if (! ((int )i___9 < (int )n___0)) {
#line 1332
      goto while_break;
    }
#line 1334
    asoc = (info___0 + (int )i___9)->asoc;
#line 1335
    cn = (info___0 + (int )i___9)->cn;
#line 1337
    if ((unsigned int )cn >= image___1->numcomps) {
      {
#line 1338
      opj_event_msg(manager, 2, "opj_jp2_apply_cdef: cn=%d, numcomps=%d\n", (int )cn,
                    image___1->numcomps);
      }
#line 1340
      goto while_continue;
    }
#line 1342
    if ((int )asoc == 0) {
#line 1343
      (image___1->comps + (int )cn)->alpha = (info___0 + (int )i___9)->typ;
#line 1344
      goto while_continue;
    } else
#line 1342
    if ((int )asoc == 65535) {
#line 1343
      (image___1->comps + (int )cn)->alpha = (info___0 + (int )i___9)->typ;
#line 1344
      goto while_continue;
    }
#line 1347
    acn = (OPJ_UINT16 )((int )asoc - 1);
#line 1348
    if ((unsigned int )acn >= image___1->numcomps) {
      {
#line 1349
      opj_event_msg(manager, 2, "opj_jp2_apply_cdef: acn=%d, numcomps=%d\n\230\001",
                    (int )acn, image___1->numcomps);
      }
#line 1351
      goto while_continue;
    }
#line 1355
    if ((int )cn != (int )acn) {
#line 1355
      if ((int )(info___0 + (int )i___9)->typ == 0) {
        {
#line 1359
        memcpy((void *)(& saved), (void const   *)(image___1->comps + (int )cn), sizeof(opj_image_comp_t ));
#line 1360
        memcpy((void *)(image___1->comps + (int )cn), (void const   *)(image___1->comps + (int )acn),
               sizeof(opj_image_comp_t ));
#line 1361
        memcpy((void *)(image___1->comps + (int )acn), (void const   *)(& saved),
               sizeof(opj_image_comp_t ));
#line 1364
        j___1 = (OPJ_UINT16 )((unsigned int )i___9 + 1U);
        }
        {
#line 1364
        while (1) {
          while_continue___1: /* CIL Label */ ;

#line 1364
          if (! ((int )j___1 < (int )n___0)) {
#line 1364
            goto while_break___0;
          }
#line 1365
          if ((int )(info___0 + (int )j___1)->cn == (int )cn) {
#line 1366
            (info___0 + (int )j___1)->cn = acn;
          } else
#line 1367
          if ((int )(info___0 + (int )j___1)->cn == (int )acn) {
#line 1368
            (info___0 + (int )j___1)->cn = cn;
          }
#line 1364
          j___1 = (OPJ_UINT16 )((int )j___1 + 1);
        }
        while_break___2: /* CIL Label */ ;
        }

        while_break___0: ;
      }
    }
#line 1374
    (image___1->comps + (int )cn)->alpha = (info___0 + (int )i___9)->typ;
#line 1332
    i___9 = (OPJ_UINT16 )((int )i___9 + 1);
  }
  while_break___1: /* CIL Label */ ;
  }

  while_break: ;
#line 1377
  if ((color___2->jp2_cdef)->info) {
    {
#line 1378
    opj_free((void *)(color___2->jp2_cdef)->info);
    }
  }
  {
#line 1381
  opj_free((void *)color___2->jp2_cdef);
#line 1382
  color___2->jp2_cdef = (opj_jp2_cdef_t *)((void *)0);
  }
#line 1384
  return;
}
}
#line 1386 "/root/patron-new/39/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_read_cdef(opj_jp2_t *jp2___7 , OPJ_BYTE *p_cdef_header_data ,
                                  OPJ_UINT32 p_cdef_header_size , opj_event_mgr_t *p_manager___6 ) 
{ 
  opj_jp2_cdef_info_t *cdef_info ;
  OPJ_UINT16 i___10 ;
  OPJ_UINT32 l_value___2 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12___1 ;

  {
#line 1404
  if (jp2___7->color.jp2_cdef) {
#line 1405
    return (0);
  }
#line 1408
  if (p_cdef_header_size < 2U) {
    {
#line 1409
    opj_event_msg(p_manager___6, 1, "Insufficient data for CDEF box.\n\220");
    }
#line 1410
    return (0);
  }
  {
#line 1413
  opj_read_bytes_LE(p_cdef_header_data, & l_value___2, (OPJ_UINT32 )2);
#line 1414
  p_cdef_header_data += 2;
  }
#line 1416
  if ((int )((OPJ_UINT16 )l_value___2) == 0) {
    {
#line 1417
    opj_event_msg(p_manager___6, 1, "Number of channel description is equal to zero in CDEF box.\n");
    }
#line 1419
    return (0);
  }
#line 1422
  if (p_cdef_header_size < 2U + (OPJ_UINT32 )((OPJ_UINT16 )l_value___2) * 6U) {
    {
#line 1423
    opj_event_msg(p_manager___6, 1, "Insufficient data for CDEF box.\n\220");
    }
#line 1424
    return (0);
  }
  {
#line 1427
  __cil_tmp11 = opj_malloc((unsigned long )l_value___2 * sizeof(opj_jp2_cdef_info_t ));
#line 1427
  cdef_info = (opj_jp2_cdef_info_t *)__cil_tmp11;
  }
#line 1429
  if (! cdef_info) {
#line 1430
    return (0);
  }
  {
#line 1433
  __cil_tmp12___1 = opj_malloc(sizeof(opj_jp2_cdef_t ));
#line 1433
  jp2___7->color.jp2_cdef = (opj_jp2_cdef_t *)__cil_tmp12___1;
  }
#line 1434
  if (! jp2___7->color.jp2_cdef) {
    {
#line 1435
    opj_free((void *)cdef_info);
    }
#line 1436
    return (0);
  }
#line 1438
  (jp2___7->color.jp2_cdef)->info = cdef_info;
#line 1439
  (jp2___7->color.jp2_cdef)->n = (OPJ_UINT16 )l_value___2;
#line 1441
  i___10 = (OPJ_UINT16 )0;
  {
#line 1441
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1441
    if (! ((int )i___10 < (int )(jp2___7->color.jp2_cdef)->n)) {
#line 1441
      goto while_break;
    }
    {
#line 1442
    opj_read_bytes_LE(p_cdef_header_data, & l_value___2, (OPJ_UINT32 )2);
#line 1443
    p_cdef_header_data += 2;
#line 1444
    (cdef_info + (int )i___10)->cn = (OPJ_UINT16 )l_value___2;
#line 1446
    opj_read_bytes_LE(p_cdef_header_data, & l_value___2, (OPJ_UINT32 )2);
#line 1447
    p_cdef_header_data += 2;
#line 1448
    (cdef_info + (int )i___10)->typ = (OPJ_UINT16 )l_value___2;
#line 1450
    opj_read_bytes_LE(p_cdef_header_data, & l_value___2, (OPJ_UINT32 )2);
#line 1451
    p_cdef_header_data += 2;
#line 1452
    (cdef_info + (int )i___10)->asoc = (OPJ_UINT16 )l_value___2;
#line 1441
    i___10 = (OPJ_UINT16 )((int )i___10 + 1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 1455
  return (1);
}
}
#line 1458 "/root/patron-new/39/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_read_colr(opj_jp2_t *jp2___8 , OPJ_BYTE *p_colr_header_data ,
                                  OPJ_UINT32 p_colr_header_size , opj_event_mgr_t *p_manager___7 ) 
{ 
  OPJ_UINT32 l_value___3 ;
  OPJ_UINT32 *cielab ;
  OPJ_UINT32 rl ;
  OPJ_UINT32 ol ;
  OPJ_UINT32 ra ;
  OPJ_UINT32 oa ;
  OPJ_UINT32 rb ;
  OPJ_UINT32 ob ;
  OPJ_UINT32 il ;
  void *__cil_tmp17___0 ;
  OPJ_INT32 it_icc_value ;
  OPJ_INT32 icc_len ;
  void *__cil_tmp20___2 ;

  {
#line 1471
  if (p_colr_header_size < 3U) {
    {
#line 1472
    opj_event_msg(p_manager___7, 1, "Bad COLR header box (bad size)\n");
    }
#line 1473
    return (0);
  }
#line 1479
  if (jp2___8->color.jp2_has_colr) {
    {
#line 1480
    opj_event_msg(p_manager___7, 4, "A conforming JP2 reader shall ignore all Colour Specification boxes after the first, so we ignore this one.\n]U");
#line 1482
    p_colr_header_data += p_colr_header_size;
    }
#line 1483
    return (1);
  }
  {
#line 1486
  opj_read_bytes_LE(p_colr_header_data, & jp2___8->meth, (OPJ_UINT32 )1);
#line 1487
  p_colr_header_data ++;
#line 1489
  opj_read_bytes_LE(p_colr_header_data, & jp2___8->precedence, (OPJ_UINT32 )1);
#line 1490
  p_colr_header_data ++;
#line 1492
  opj_read_bytes_LE(p_colr_header_data, & jp2___8->approx, (OPJ_UINT32 )1);
#line 1493
  p_colr_header_data ++;
  }
#line 1495
  if (jp2___8->meth == 1U) {
#line 1496
    if (p_colr_header_size < 7U) {
      {
#line 1497
      opj_event_msg(p_manager___7, 1, "Bad COLR header box (bad size: %d)\n", p_colr_header_size);
      }
#line 1499
      return (0);
    }
#line 1501
    if (p_colr_header_size > 7U) {
#line 1501
      if (jp2___8->enumcs != 14U) {
        {
#line 1504
        opj_event_msg(p_manager___7, 2, "Bad COLR header box (bad size: %d)\n\005]U",
                      p_colr_header_size);
        }
      }
    }
    {
#line 1508
    opj_read_bytes_LE(p_colr_header_data, & jp2___8->enumcs, (OPJ_UINT32 )4);
#line 1510
    p_colr_header_data += 4;
    }
#line 1512
    if (jp2___8->enumcs == 14U) {
      {
#line 1516
      __cil_tmp17___0 = opj_malloc(9UL * sizeof(OPJ_UINT32 ));
#line 1516
      cielab = (OPJ_UINT32 *)__cil_tmp17___0;
      }
#line 1517
      if ((unsigned long )cielab == (unsigned long )((void *)0)) {
        {
#line 1518
        opj_event_msg(p_manager___7, 1, "Not enough memory for cielab\nU");
        }
#line 1519
        return (0);
      }
#line 1521
      *(cielab + 0) = (OPJ_UINT32 )14;
#line 1524
      ob = (OPJ_UINT32 )0;
#line 1524
      oa = ob;
#line 1524
      ol = oa;
#line 1524
      rb = ol;
#line 1524
      ra = rb;
#line 1524
      rl = ra;
#line 1525
      il = (OPJ_UINT32 )4470064;
#line 1526
      *(cielab + 1) = (OPJ_UINT32 )1145390592;
#line 1528
      if (p_colr_header_size == 35U) {
        {
#line 1529
        opj_read_bytes_LE(p_colr_header_data, & rl, (OPJ_UINT32 )4);
#line 1530
        p_colr_header_data += 4;
#line 1531
        opj_read_bytes_LE(p_colr_header_data, & ol, (OPJ_UINT32 )4);
#line 1532
        p_colr_header_data += 4;
#line 1533
        opj_read_bytes_LE(p_colr_header_data, & ra, (OPJ_UINT32 )4);
#line 1534
        p_colr_header_data += 4;
#line 1535
        opj_read_bytes_LE(p_colr_header_data, & oa, (OPJ_UINT32 )4);
#line 1536
        p_colr_header_data += 4;
#line 1537
        opj_read_bytes_LE(p_colr_header_data, & rb, (OPJ_UINT32 )4);
#line 1538
        p_colr_header_data += 4;
#line 1539
        opj_read_bytes_LE(p_colr_header_data, & ob, (OPJ_UINT32 )4);
#line 1540
        p_colr_header_data += 4;
#line 1541
        opj_read_bytes_LE(p_colr_header_data, & il, (OPJ_UINT32 )4);
#line 1542
        p_colr_header_data += 4;
#line 1544
        *(cielab + 1) = (OPJ_UINT32 )0;
        }
      } else
#line 1545
      if (p_colr_header_size != 7U) {
        {
#line 1546
        opj_event_msg(p_manager___7, 2, "Bad COLR header box (CIELab, bad size: %d)\n",
                      p_colr_header_size);
        }
      }
#line 1549
      *(cielab + 2) = rl;
#line 1550
      *(cielab + 4) = ra;
#line 1551
      *(cielab + 6) = rb;
#line 1552
      *(cielab + 3) = ol;
#line 1553
      *(cielab + 5) = oa;
#line 1554
      *(cielab + 7) = ob;
#line 1555
      *(cielab + 8) = il;
#line 1557
      jp2___8->color.icc_profile_buf = (OPJ_BYTE *)cielab;
#line 1558
      jp2___8->color.icc_profile_len = (OPJ_UINT32 )0;
    }
#line 1560
    jp2___8->color.jp2_has_colr = (OPJ_BYTE )1;
  } else
#line 1561
  if (jp2___8->meth == 2U) {
    {
#line 1563
    it_icc_value = 0;
#line 1564
    icc_len = (OPJ_INT32 )p_colr_header_size - 3;
#line 1566
    jp2___8->color.icc_profile_len = (OPJ_UINT32 )icc_len;
#line 1567
    __cil_tmp20___2 = opj_calloc((size_t )1, (size_t )icc_len);
#line 1567
    jp2___8->color.icc_profile_buf = (OPJ_BYTE *)__cil_tmp20___2;
    }
#line 1568
    if (! jp2___8->color.icc_profile_buf) {
#line 1569
      jp2___8->color.icc_profile_len = (OPJ_UINT32 )0;
#line 1570
      return (0);
    }
#line 1573
    it_icc_value = 0;
    {
#line 1573
    while (1) {
      while_continue: /* CIL Label */ ;

#line 1573
      if (! (it_icc_value < icc_len)) {
#line 1573
        goto while_break;
      }
      {
#line 1574
      opj_read_bytes_LE(p_colr_header_data, & l_value___3, (OPJ_UINT32 )1);
#line 1575
      p_colr_header_data ++;
#line 1576
      *(jp2___8->color.icc_profile_buf + it_icc_value) = (OPJ_BYTE )l_value___3;
#line 1573
      it_icc_value ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }

    while_break: 
#line 1579
    jp2___8->color.jp2_has_colr = (OPJ_BYTE )1;
  } else
#line 1580
  if (jp2___8->meth > 2U) {
    {
#line 1583
    opj_event_msg(p_manager___7, 4, "COLR BOX meth value is not a regular value (%d), so we will ignore the entire Colour Specification box. \n",
                  jp2___8->meth);
    }
  }
#line 1588
  return (1);
}
}
#line 1591 "/root/patron-new/39/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_decode(opj_jp2_t *jp2___9 , opj_stream_private_t *p_stream___9 ,
                        opj_image_t *p_image___5 , opj_event_mgr_t *p_manager___8 ) 
{ 
  OPJ_BOOL __cil_tmp5___8 ;
  OPJ_BOOL __cil_tmp6___5 ;
  OPJ_BOOL __cil_tmp7___5 ;

  {
#line 1596
  if (! p_image___5) {
#line 1597
    return (0);
  }
  {
#line 1601
  __cil_tmp5___8 = opj_j2k_decode(jp2___9->j2k, p_stream___9, p_image___5, p_manager___8);
  }
#line 1601
  if (! __cil_tmp5___8) {
    {
#line 1602
    opj_event_msg(p_manager___8, 1, "Failed to decode the codestream in the JP2 file\n\220");
    }
#line 1604
    return (0);
  }
#line 1607
  if ((jp2___9->j2k)->m_specific_param.m_decoder.m_numcomps_to_decode) {
#line 1609
    return (1);
  }
#line 1612
  if (! jp2___9->ignore_pclr_cmap_cdef) {
    {
#line 1613
    __cil_tmp6___5 = opj_jp2_check_color(p_image___5, & jp2___9->color, p_manager___8);
    }
#line 1613
    if (! __cil_tmp6___5) {
#line 1614
      return (0);
    }
#line 1618
    if (jp2___9->enumcs == 16U) {
#line 1619
      p_image___5->color_space = (OPJ_COLOR_SPACE )1;
    } else
#line 1620
    if (jp2___9->enumcs == 17U) {
#line 1621
      p_image___5->color_space = (OPJ_COLOR_SPACE )2;
    } else
#line 1622
    if (jp2___9->enumcs == 18U) {
#line 1623
      p_image___5->color_space = (OPJ_COLOR_SPACE )3;
    } else
#line 1624
    if (jp2___9->enumcs == 24U) {
#line 1625
      p_image___5->color_space = (OPJ_COLOR_SPACE )4;
    } else
#line 1626
    if (jp2___9->enumcs == 12U) {
#line 1627
      p_image___5->color_space = (OPJ_COLOR_SPACE )5;
    } else {
#line 1629
      p_image___5->color_space = (OPJ_COLOR_SPACE )-1;
    }
#line 1632
    if (jp2___9->color.jp2_pclr) {
#line 1634
      if (! (jp2___9->color.jp2_pclr)->cmap) {
        {
#line 1635
        opj_jp2_free_pclr(& jp2___9->color);
        }
      } else {
        {
#line 1637
        __cil_tmp7___5 = opj_jp2_apply_pclr(p_image___5, & jp2___9->color, p_manager___8);
        }
#line 1637
        if (! __cil_tmp7___5) {
#line 1638
          return (0);
        }
      }
    }
#line 1644
    if (jp2___9->color.jp2_cdef) {
      {
#line 1645
      opj_jp2_apply_cdef(p_image___5, & jp2___9->color, p_manager___8);
      }
    }
#line 1648
    if (jp2___9->color.icc_profile_buf) {
#line 1649
      p_image___5->icc_profile_buf = jp2___9->color.icc_profile_buf;
#line 1650
      p_image___5->icc_profile_len = jp2___9->color.icc_profile_len;
#line 1651
      jp2___9->color.icc_profile_buf = (OPJ_BYTE *)((void *)0);
    }
  }
#line 1655
  return (1);
}
}
#line 1658 "/root/patron-new/39/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_write_jp2h(opj_jp2_t *jp2___10 , opj_stream_private_t *stream ,
                                   opj_event_mgr_t *p_manager___9 ) 
{ 
  opj_jp2_img_header_writer_handler_t l_writers[4] ;
  opj_jp2_img_header_writer_handler_t *l_current_writer ;
  OPJ_INT32 i___11 ;
  OPJ_INT32 l_nb_pass ;
  OPJ_UINT32 l_jp2h_size ;
  OPJ_BOOL l_result ;
  OPJ_BYTE l_jp2h_data[8] ;
  OPJ_SIZE_T __cil_tmp16___0 ;
  OPJ_SIZE_T __cil_tmp17___1 ;

  {
  {
#line 1668
  l_jp2h_size = (OPJ_UINT32 )8;
#line 1669
  l_result = 1;
#line 1679
  memset((void *)(l_writers), 0, sizeof(l_writers));
  }
#line 1681
  if (jp2___10->bpc == 255U) {
#line 1682
    l_nb_pass = 3;
#line 1683
    l_writers[0].handler = & opj_jp2_write_ihdr;
#line 1684
    l_writers[1].handler = & opj_jp2_write_bpcc;
#line 1685
    l_writers[2].handler = & opj_jp2_write_colr;
  } else {
#line 1687
    l_nb_pass = 2;
#line 1688
    l_writers[0].handler = & opj_jp2_write_ihdr;
#line 1689
    l_writers[1].handler = & opj_jp2_write_colr;
  }
#line 1692
  if ((unsigned long )jp2___10->color.jp2_cdef != (unsigned long )((void *)0)) {
#line 1693
    l_writers[l_nb_pass].handler = & opj_jp2_write_cdef;
#line 1694
    l_nb_pass ++;
  }
  {
#line 1699
  opj_write_bytes_LE(l_jp2h_data + 4, (OPJ_UINT32 )1785737832, (OPJ_UINT32 )4);
#line 1701
  l_current_writer = l_writers;
#line 1702
  i___11 = 0;
  }
  {
#line 1702
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1702
    if (! (i___11 < l_nb_pass)) {
#line 1702
      goto while_break;
    }
    {
#line 1703
    l_current_writer->m_data = (*(l_current_writer->handler))(jp2___10, & l_current_writer->m_size);
    }
#line 1705
    if ((unsigned long )l_current_writer->m_data == (unsigned long )((OPJ_BYTE *)0)) {
      {
#line 1706
      opj_event_msg(p_manager___9, 1, "Not enough memory to hold JP2 Header data\n");
#line 1708
      l_result = 0;
      }
#line 1709
      goto while_break;
    }
#line 1712
    l_jp2h_size += l_current_writer->m_size;
#line 1713
    l_current_writer ++;
#line 1702
    i___11 ++;
  }
  while_break___3: /* CIL Label */ ;
  }

  while_break: ;
#line 1716
  if (! l_result) {
#line 1717
    l_current_writer = l_writers;
#line 1718
    i___11 = 0;
    {
#line 1718
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1718
      if (! (i___11 < l_nb_pass)) {
#line 1718
        goto while_break___0;
      }
#line 1719
      if ((unsigned long )l_current_writer->m_data != (unsigned long )((OPJ_BYTE *)0)) {
        {
#line 1720
        opj_free((void *)l_current_writer->m_data);
        }
      }
#line 1722
      l_current_writer ++;
#line 1718
      i___11 ++;
    }
    while_break___4: /* CIL Label */ ;
    }

    while_break___0: ;
#line 1725
    return (0);
  }
  {
#line 1729
  opj_write_bytes_LE(l_jp2h_data, l_jp2h_size, (OPJ_UINT32 )4);
#line 1732
  __cil_tmp16___0 = opj_stream_write_data(stream, l_jp2h_data, (OPJ_SIZE_T )8, p_manager___9);
  }
#line 1732
  if (__cil_tmp16___0 != 8UL) {
    {
#line 1733
    opj_event_msg(p_manager___9, 1, "Stream error while writing JP2 Header box\n");
#line 1735
    l_result = 0;
    }
  }
#line 1738
  if (l_result) {
#line 1739
    l_current_writer = l_writers;
#line 1740
    i___11 = 0;
    {
#line 1740
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 1740
      if (! (i___11 < l_nb_pass)) {
#line 1740
        goto while_break___1;
      }
      {
#line 1741
      __cil_tmp17___1 = opj_stream_write_data(stream, l_current_writer->m_data, (OPJ_SIZE_T )l_current_writer->m_size,
                                              p_manager___9);
      }
#line 1741
      if (__cil_tmp17___1 != (unsigned long )l_current_writer->m_size) {
        {
#line 1743
        opj_event_msg(p_manager___9, 1, "Stream error while writing JP2 Header box\n");
#line 1745
        l_result = 0;
        }
#line 1746
        goto while_break___1;
      }
#line 1748
      l_current_writer ++;
#line 1740
      i___11 ++;
    }
    while_break___5: /* CIL Label */ ;
    }

    while_break___1: ;
  }
#line 1752
  l_current_writer = l_writers;
#line 1755
  i___11 = 0;
  {
#line 1755
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 1755
    if (! (i___11 < l_nb_pass)) {
#line 1755
      goto while_break___2;
    }
#line 1756
    if ((unsigned long )l_current_writer->m_data != (unsigned long )((OPJ_BYTE *)0)) {
      {
#line 1757
      opj_free((void *)l_current_writer->m_data);
      }
    }
#line 1759
    l_current_writer ++;
#line 1755
    i___11 ++;
  }
  while_break___6: /* CIL Label */ ;
  }

  while_break___2: ;
#line 1762
  return (l_result);
}
}
#line 1765 "/root/patron-new/39/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_write_ftyp(opj_jp2_t *jp2___11 , opj_stream_private_t *cio___0 ,
                                   opj_event_mgr_t *p_manager___10 ) 
{ 
  OPJ_UINT32 i___12 ;
  OPJ_UINT32 l_ftyp_size ;
  OPJ_BYTE *l_ftyp_data ;
  OPJ_BYTE *l_current_data_ptr ;
  OPJ_BOOL l_result___0 ;
  void *__cil_tmp12___2 ;
  OPJ_SIZE_T __cil_tmp14___1 ;

  {
  {
#line 1778
  l_ftyp_size = 16U + 4U * jp2___11->numcl;
#line 1780
  __cil_tmp12___2 = opj_calloc((size_t )1, (size_t )l_ftyp_size);
#line 1780
  l_ftyp_data = (OPJ_BYTE *)__cil_tmp12___2;
  }
#line 1782
  if ((unsigned long )l_ftyp_data == (unsigned long )((OPJ_BYTE *)0)) {
    {
#line 1783
    opj_event_msg(p_manager___10, 1, "Not enough memory to handle ftyp data\n");
    }
#line 1784
    return (0);
  }
  {
#line 1787
  l_current_data_ptr = l_ftyp_data;
#line 1789
  opj_write_bytes_LE(l_current_data_ptr, l_ftyp_size, (OPJ_UINT32 )4);
#line 1790
  l_current_data_ptr += 4;
#line 1792
  opj_write_bytes_LE(l_current_data_ptr, (OPJ_UINT32 )1718909296, (OPJ_UINT32 )4);
#line 1793
  l_current_data_ptr += 4;
#line 1795
  opj_write_bytes_LE(l_current_data_ptr, jp2___11->brand, (OPJ_UINT32 )4);
#line 1796
  l_current_data_ptr += 4;
#line 1798
  opj_write_bytes_LE(l_current_data_ptr, jp2___11->minversion, (OPJ_UINT32 )4);
#line 1799
  l_current_data_ptr += 4;
#line 1801
  i___12 = (OPJ_UINT32 )0;
  }
  {
#line 1801
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1801
    if (! (i___12 < jp2___11->numcl)) {
#line 1801
      goto while_break;
    }
    {
#line 1802
    opj_write_bytes_LE(l_current_data_ptr, *(jp2___11->cl + i___12), (OPJ_UINT32 )4);
#line 1801
    i___12 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: 
  {
#line 1805
  __cil_tmp14___1 = opj_stream_write_data(cio___0, l_ftyp_data, (OPJ_SIZE_T )l_ftyp_size,
                                          p_manager___10);
#line 1805
  l_result___0 = __cil_tmp14___1 == (unsigned long )l_ftyp_size;
  }
#line 1807
  if (! l_result___0) {
    {
#line 1808
    opj_event_msg(p_manager___10, 1, "Error while writing ftyp data to stream\n\220");
    }
  }
  {
#line 1812
  opj_free((void *)l_ftyp_data);
  }
#line 1814
  return (l_result___0);
}
}
#line 1817 "/root/patron-new/39/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_write_jp2c(opj_jp2_t *jp2___12 , opj_stream_private_t *cio___1 ,
                                   opj_event_mgr_t *p_manager___11 ) 
{ 
  OPJ_OFF_T j2k_codestream_exit ;
  OPJ_BYTE l_data_header___0[8] ;
  OPJ_BOOL __cil_tmp12___3 ;
  OPJ_SIZE_T __cil_tmp13___3 ;
  OPJ_BOOL __cil_tmp14___2 ;

  {
  {
#line 1830
  j2k_codestream_exit = opj_stream_tell(cio___1);
#line 1831
  opj_write_bytes_LE(l_data_header___0, (OPJ_UINT32 )(j2k_codestream_exit - jp2___12->j2k_codestream_offset),
                     (OPJ_UINT32 )4);
#line 1834
  opj_write_bytes_LE(l_data_header___0 + 4, (OPJ_UINT32 )1785737827, (OPJ_UINT32 )4);
#line 1837
  __cil_tmp12___3 = opj_stream_seek(cio___1, jp2___12->j2k_codestream_offset, p_manager___11);
  }
#line 1837
  if (! __cil_tmp12___3) {
    {
#line 1838
    opj_event_msg(p_manager___11, 1, "Failed to seek in the stream.\n");
    }
#line 1839
    return (0);
  }
  {
#line 1842
  __cil_tmp13___3 = opj_stream_write_data(cio___1, l_data_header___0, (OPJ_SIZE_T )8,
                                          p_manager___11);
  }
#line 1842
  if (__cil_tmp13___3 != 8UL) {
    {
#line 1843
    opj_event_msg(p_manager___11, 1, "Failed to seek in the stream.\n");
    }
#line 1844
    return (0);
  }
  {
#line 1847
  __cil_tmp14___2 = opj_stream_seek(cio___1, j2k_codestream_exit, p_manager___11);
  }
#line 1847
  if (! __cil_tmp14___2) {
    {
#line 1848
    opj_event_msg(p_manager___11, 1, "Failed to seek in the stream.\n");
    }
#line 1849
    return (0);
  }
#line 1852
  return (1);
}
}
#line 1855 "/root/patron-new/39/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_write_jp(opj_jp2_t *jp2___13 , opj_stream_private_t *cio___2 ,
                                 opj_event_mgr_t *p_manager___12 ) 
{ 
  OPJ_BYTE l_signature_data[12] ;
  OPJ_SIZE_T __cil_tmp8___6 ;

  {
  {
#line 1870
  opj_write_bytes_LE(l_signature_data, (OPJ_UINT32 )12, (OPJ_UINT32 )4);
#line 1872
  opj_write_bytes_LE(l_signature_data + 4, (OPJ_UINT32 )1783636000, (OPJ_UINT32 )4);
#line 1874
  opj_write_bytes_LE(l_signature_data + 8, (OPJ_UINT32 )218793738, (OPJ_UINT32 )4);
#line 1876
  __cil_tmp8___6 = opj_stream_write_data(cio___2, l_signature_data, (OPJ_SIZE_T )12,
                                         p_manager___12);
  }
#line 1876
  if (__cil_tmp8___6 != 12UL) {
#line 1877
    return (0);
  }
#line 1880
  return (1);
}
}
#line 1887 "/root/patron-new/39/src/lib/openjp2/jp2.c"
void opj_jp2_setup_decoder(opj_jp2_t *jp2___14 , opj_dparameters_t *parameters___4 ) 
{ 


  {
  {
#line 1890
  opj_j2k_setup_decoder(jp2___14->j2k, parameters___4);
#line 1893
  jp2___14->color.jp2_has_colr = (OPJ_BYTE )0;
#line 1894
  jp2___14->ignore_pclr_cmap_cdef = (OPJ_BOOL )(parameters___4->flags & 1U);
  }
#line 1896
  return;
}
}
#line 1898 "/root/patron-new/39/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_set_threads(opj_jp2_t *jp2___15 , OPJ_UINT32 num_threads___0 ) 
{ 
  OPJ_BOOL __cil_tmp3___16 ;

  {
  {
#line 1900
  __cil_tmp3___16 = opj_j2k_set_threads(jp2___15->j2k, num_threads___0);
  }
#line 1900
  return (__cil_tmp3___16);
}
}
#line 1907 "/root/patron-new/39/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_setup_encoder(opj_jp2_t *jp2___16 , opj_cparameters_t *parameters___5 ,
                               opj_image_t *image___2 , opj_event_mgr_t *p_manager___13 ) 
{ 
  OPJ_UINT32 i___13 ;
  OPJ_UINT32 depth_0 ;
  OPJ_UINT32 sign ;
  OPJ_UINT32 alpha_count ;
  OPJ_UINT32 color_channels ;
  OPJ_UINT32 alpha_channel ;
  OPJ_BOOL __cil_tmp11___1 ;
  void *__cil_tmp12___4 ;
  void *__cil_tmp13___4 ;
  OPJ_UINT32 depth ;
  void *__cil_tmp19___1 ;
  void *__cil_tmp20___3 ;

  {
#line 1916
  color_channels = 0U;
#line 1917
  alpha_channel = 0U;
#line 1920
  if (! jp2___16) {
#line 1921
    return (0);
  } else
#line 1920
  if (! parameters___5) {
#line 1921
    return (0);
  } else
#line 1920
  if (! image___2) {
#line 1921
    return (0);
  }
#line 1928
  if (image___2->numcomps < 1U) {
    {
#line 1929
    opj_event_msg(p_manager___13, 1, "Invalid number of components specified while setting up JP2 encoder\n");
    }
#line 1931
    return (0);
  } else
#line 1928
  if (image___2->numcomps > 16384U) {
    {
#line 1929
    opj_event_msg(p_manager___13, 1, "Invalid number of components specified while setting up JP2 encoder\n");
    }
#line 1931
    return (0);
  }
  {
#line 1934
  __cil_tmp11___1 = opj_j2k_setup_encoder(jp2___16->j2k, parameters___5, image___2,
                                          p_manager___13);
  }
#line 1934
  if (__cil_tmp11___1 == 0) {
#line 1936
    return (0);
  }
  {
#line 1944
  jp2___16->brand = (OPJ_UINT32 )1785737760;
#line 1945
  jp2___16->minversion = (OPJ_UINT32 )0;
#line 1946
  jp2___16->numcl = (OPJ_UINT32 )1;
#line 1947
  __cil_tmp12___4 = opj_malloc((unsigned long )jp2___16->numcl * sizeof(OPJ_UINT32 ));
#line 1947
  jp2___16->cl = (OPJ_UINT32 *)__cil_tmp12___4;
  }
#line 1948
  if (! jp2___16->cl) {
    {
#line 1949
    opj_event_msg(p_manager___13, 1, "Not enough memory when setup the JP2 encoder\n");
    }
#line 1951
    return (0);
  }
  {
#line 1953
  *(jp2___16->cl + 0) = (OPJ_UINT32 )1785737760;
#line 1957
  jp2___16->numcomps = image___2->numcomps;
#line 1958
  __cil_tmp13___4 = opj_malloc((unsigned long )jp2___16->numcomps * sizeof(opj_jp2_comps_t ));
#line 1958
  jp2___16->comps = (opj_jp2_comps_t *)__cil_tmp13___4;
  }
#line 1960
  if (! jp2___16->comps) {
    {
#line 1961
    opj_event_msg(p_manager___13, 1, "Not enough memory when setup the JP2 encoder\n");
    }
#line 1964
    return (0);
  }
#line 1967
  jp2___16->h = image___2->y1 - image___2->y0;
#line 1968
  jp2___16->w = image___2->x1 - image___2->x0;
#line 1970
  depth_0 = (image___2->comps + 0)->prec - 1U;
#line 1971
  sign = (image___2->comps + 0)->sgnd;
#line 1972
  jp2___16->bpc = depth_0 + (sign << 7);
#line 1973
  i___13 = (OPJ_UINT32 )1;
  {
#line 1973
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1973
    if (! (i___13 < image___2->numcomps)) {
#line 1973
      goto while_break;
    }
#line 1974
    depth = (image___2->comps + i___13)->prec - 1U;
#line 1975
    sign = (image___2->comps + i___13)->sgnd;
#line 1976
    if (depth_0 != depth) {
#line 1977
      jp2___16->bpc = (OPJ_UINT32 )255;
    }
#line 1973
    i___13 ++;
  }
  while_break___4: /* CIL Label */ ;
  }

  while_break: 
#line 1980
  jp2___16->C = (OPJ_UINT32 )7;
#line 1981
  jp2___16->UnkC = (OPJ_UINT32 )0;
#line 1982
  jp2___16->IPR = (OPJ_UINT32 )0;
#line 1985
  i___13 = (OPJ_UINT32 )0;
  {
#line 1985
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 1985
    if (! (i___13 < image___2->numcomps)) {
#line 1985
      goto while_break___0;
    }
#line 1986
    (jp2___16->comps + i___13)->bpcc = ((image___2->comps + i___13)->prec - 1U) + ((image___2->comps + i___13)->sgnd << 7);
#line 1985
    i___13 ++;
  }
  while_break___5: /* CIL Label */ ;
  }

  while_break___0: ;
#line 1990
  if (image___2->icc_profile_len) {
#line 1991
    jp2___16->meth = (OPJ_UINT32 )2;
#line 1992
    jp2___16->enumcs = (OPJ_UINT32 )0;
  } else {
#line 1994
    jp2___16->meth = (OPJ_UINT32 )1;
#line 1995
    if ((int )image___2->color_space == 1) {
#line 1996
      jp2___16->enumcs = (OPJ_UINT32 )16;
    } else
#line 1997
    if ((int )image___2->color_space == 2) {
#line 1998
      jp2___16->enumcs = (OPJ_UINT32 )17;
    } else
#line 1999
    if ((int )image___2->color_space == 3) {
#line 2000
      jp2___16->enumcs = (OPJ_UINT32 )18;
    }
  }
#line 2007
  alpha_count = 0U;
#line 2008
  i___13 = (OPJ_UINT32 )0;
  {
#line 2008
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 2008
    if (! (i___13 < image___2->numcomps)) {
#line 2008
      goto while_break___1;
    }
#line 2009
    if ((int )(image___2->comps + i___13)->alpha != 0) {
#line 2010
      alpha_count ++;
#line 2011
      alpha_channel = i___13;
    }
#line 2008
    i___13 ++;
  }
  while_break___6: /* CIL Label */ ;
  }

  while_break___1: ;
#line 2014
  if (alpha_count == 1U) {
#line 2017
    if (jp2___16->enumcs == 18U) {
#line 2017
      goto case_18;
    }
#line 2017
    if (jp2___16->enumcs == 16U) {
#line 2017
      goto case_18;
    }
#line 2020
    if (jp2___16->enumcs == 17U) {
#line 2020
      goto case_17;
    }
#line 2023
    goto switch_default;
    case_18: 
#line 2018
    color_channels = (OPJ_UINT32 )3;
#line 2019
    goto switch_break;
    case_17: 
#line 2021
    color_channels = (OPJ_UINT32 )1;
#line 2022
    goto switch_break;
    switch_default: 
#line 2024
    alpha_count = 0U;
#line 2025
    goto switch_break;
    switch_break: ;
#line 2027
    if (alpha_count == 0U) {
      {
#line 2028
      opj_event_msg(p_manager___13, 2, "Alpha channel specified but unknown enumcs. No cdef box will be created.\n");
      }
    } else
#line 2030
    if (image___2->numcomps < color_channels + 1U) {
      {
#line 2031
      opj_event_msg(p_manager___13, 2, "Alpha channel specified but not enough image components for an automatic cdef box creation.\n");
#line 2033
      alpha_count = 0U;
      }
    } else
#line 2034
    if (alpha_channel < color_channels) {
      {
#line 2035
      opj_event_msg(p_manager___13, 2, "Alpha channel position conflicts with color channel. No cdef box will be created.\n");
#line 2037
      alpha_count = 0U;
      }
    }
  } else
#line 2039
  if (alpha_count > 1U) {
    {
#line 2040
    opj_event_msg(p_manager___13, 2, "Multiple alpha channels specified. No cdef box will be created.\n\220");
    }
  }
#line 2043
  if (alpha_count == 1U) {
    {
#line 2044
    __cil_tmp19___1 = opj_malloc(sizeof(opj_jp2_cdef_t ));
#line 2044
    jp2___16->color.jp2_cdef = (opj_jp2_cdef_t *)__cil_tmp19___1;
    }
#line 2045
    if (! jp2___16->color.jp2_cdef) {
      {
#line 2046
      opj_event_msg(p_manager___13, 1, "Not enough memory to setup the JP2 encoder\n");
      }
#line 2048
      return (0);
    }
    {
#line 2052
    __cil_tmp20___3 = opj_malloc((unsigned long )image___2->numcomps * sizeof(opj_jp2_cdef_info_t ));
#line 2052
    (jp2___16->color.jp2_cdef)->info = (opj_jp2_cdef_info_t *)__cil_tmp20___3;
    }
#line 2054
    if (! (jp2___16->color.jp2_cdef)->info) {
      {
#line 2056
      opj_event_msg(p_manager___13, 1, "Not enough memory to setup the JP2 encoder\n");
      }
#line 2058
      return (0);
    }
#line 2060
    (jp2___16->color.jp2_cdef)->n = (OPJ_UINT16 )image___2->numcomps;
#line 2062
    i___13 = 0U;
    {
#line 2062
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 2062
      if (! (i___13 < color_channels)) {
#line 2062
        goto while_break___2;
      }
#line 2063
      ((jp2___16->color.jp2_cdef)->info + i___13)->cn = (OPJ_UINT16 )i___13;
#line 2065
      ((jp2___16->color.jp2_cdef)->info + i___13)->typ = (OPJ_UINT16 )0U;
#line 2066
      ((jp2___16->color.jp2_cdef)->info + i___13)->asoc = (OPJ_UINT16 )(i___13 + 1U);
#line 2062
      i___13 ++;
    }
    while_break___7: /* CIL Label */ ;
    }

    while_break___2: ;
    {
#line 2069
    while (1) {
      while_continue___3: /* CIL Label */ ;

#line 2069
      if (! (i___13 < image___2->numcomps)) {
#line 2069
        goto while_break___3;
      }
#line 2070
      if ((int )(image___2->comps + i___13)->alpha != 0) {
#line 2071
        ((jp2___16->color.jp2_cdef)->info + i___13)->cn = (OPJ_UINT16 )i___13;
#line 2073
        ((jp2___16->color.jp2_cdef)->info + i___13)->typ = (OPJ_UINT16 )1U;
#line 2074
        ((jp2___16->color.jp2_cdef)->info + i___13)->asoc = (OPJ_UINT16 )0U;
      } else {
#line 2078
        ((jp2___16->color.jp2_cdef)->info + i___13)->cn = (OPJ_UINT16 )i___13;
#line 2080
        ((jp2___16->color.jp2_cdef)->info + i___13)->typ = (OPJ_UINT16 )65535U;
#line 2081
        ((jp2___16->color.jp2_cdef)->info + i___13)->asoc = (OPJ_UINT16 )65535U;
      }
#line 2069
      i___13 ++;
    }
    while_break___8: /* CIL Label */ ;
    }

    while_break___3: ;
  }
#line 2086
  jp2___16->precedence = (OPJ_UINT32 )0;
#line 2087
  jp2___16->approx = (OPJ_UINT32 )0;
#line 2089
  jp2___16->jpip_on = parameters___5->jpip_on;
#line 2091
  return (1);
}
}
#line 2094 "/root/patron-new/39/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_encode(opj_jp2_t *jp2___17 , opj_stream_private_t *stream___0 , opj_event_mgr_t *p_manager___14 ) 
{ 
  OPJ_BOOL __cil_tmp4___8 ;

  {
  {
#line 2098
  __cil_tmp4___8 = opj_j2k_encode(jp2___17->j2k, stream___0, p_manager___14);
  }
#line 2098
  return (__cil_tmp4___8);
}
}
#line 2101 "/root/patron-new/39/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_end_decompress(opj_jp2_t *jp2___18 , opj_stream_private_t *cio___3 ,
                                opj_event_mgr_t *p_manager___15 ) 
{ 
  OPJ_BOOL __cil_tmp7___6 ;
  OPJ_BOOL __cil_tmp8___7 ;
  OPJ_BOOL __cil_tmp9___3 ;

  {
  {
#line 2112
  __cil_tmp7___6 = opj_jp2_setup_end_header_reading(jp2___18, p_manager___15);
  }
#line 2112
  if (! __cil_tmp7___6) {
#line 2113
    return (0);
  }
  {
#line 2117
  __cil_tmp8___7 = opj_jp2_exec(jp2___18, jp2___18->m_procedure_list, cio___3, p_manager___15);
  }
#line 2117
  if (! __cil_tmp8___7) {
#line 2118
    return (0);
  }
  {
#line 2121
  __cil_tmp9___3 = opj_j2k_end_decompress(jp2___18->j2k, cio___3, p_manager___15);
  }
#line 2121
  return (__cil_tmp9___3);
}
}
#line 2124 "/root/patron-new/39/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_end_compress(opj_jp2_t *jp2___19 , opj_stream_private_t *cio___4 ,
                              opj_event_mgr_t *p_manager___16 ) 
{ 
  OPJ_BOOL __cil_tmp7___7 ;
  OPJ_BOOL __cil_tmp8___8 ;
  OPJ_BOOL __cil_tmp9___4 ;

  {
  {
#line 2135
  __cil_tmp7___7 = opj_jp2_setup_end_header_writing(jp2___19, p_manager___16);
  }
#line 2135
  if (! __cil_tmp7___7) {
#line 2136
    return (0);
  }
  {
#line 2139
  __cil_tmp8___8 = opj_j2k_end_compress(jp2___19->j2k, cio___4, p_manager___16);
  }
#line 2139
  if (! __cil_tmp8___8) {
#line 2140
    return (0);
  }
  {
#line 2144
  __cil_tmp9___4 = opj_jp2_exec(jp2___19, jp2___19->m_procedure_list, cio___4, p_manager___16);
  }
#line 2144
  return (__cil_tmp9___4);
}
}
#line 2147 "/root/patron-new/39/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_setup_end_header_writing(opj_jp2_t *jp2___20 , opj_event_mgr_t *p_manager___17 ) 
{ 
  OPJ_BOOL __cil_tmp5___9 ;

  {
  {
#line 2162
  __cil_tmp5___9 = opj_procedure_list_add_procedure(jp2___20->m_procedure_list, (void (*)(void))(& opj_jp2_write_jp2c),
                                                    p_manager___17);
  }
#line 2162
  if (! __cil_tmp5___9) {
#line 2164
    return (0);
  }
#line 2179
  return (1);
}
}
#line 2182 "/root/patron-new/39/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_setup_end_header_reading(opj_jp2_t *jp2___21 , opj_event_mgr_t *p_manager___18 ) 
{ 
  OPJ_BOOL __cil_tmp5___10 ;

  {
  {
#line 2189
  __cil_tmp5___10 = opj_procedure_list_add_procedure(jp2___21->m_procedure_list, (void (*)(void))(& opj_jp2_read_header_procedure),
                                                     p_manager___18);
  }
#line 2189
  if (! __cil_tmp5___10) {
#line 2191
    return (0);
  }
#line 2195
  return (1);
}
}
#line 2198 "/root/patron-new/39/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_default_validation(opj_jp2_t *jp2___22 , opj_stream_private_t *cio___5 ,
                                           opj_event_mgr_t *p_manager___19 ) 
{ 
  OPJ_BOOL l_is_valid ;
  OPJ_UINT32 i___14 ;
  OPJ_BOOL __cil_tmp9___5 ;
  int tmp___87 ;

  {
#line 2203
  l_is_valid = 1;
#line 2217
  l_is_valid &= jp2___22->jp2_state == 0U;
#line 2220
  l_is_valid &= jp2___22->jp2_img_state == 0U;
#line 2224
  l_is_valid &= (unsigned long )jp2___22->j2k != (unsigned long )((opj_j2k_t *)0);
#line 2227
  l_is_valid &= (unsigned long )jp2___22->m_procedure_list != (unsigned long )((struct opj_procedure_list *)0);
#line 2230
  l_is_valid &= (unsigned long )jp2___22->m_validation_list != (unsigned long )((struct opj_procedure_list *)0);
#line 2234
  l_is_valid &= jp2___22->numcl > 0U;
#line 2236
  l_is_valid &= jp2___22->h > 0U;
#line 2238
  l_is_valid &= jp2___22->w > 0U;
#line 2240
  i___14 = (OPJ_UINT32 )0;
  {
#line 2240
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2240
    if (! (i___14 < jp2___22->numcomps)) {
#line 2240
      goto while_break;
    }
#line 2241
    l_is_valid &= ((jp2___22->comps + i___14)->bpcc & 127U) < 38U;
#line 2240
    i___14 ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 2246
  if (jp2___22->meth > 0U) {
#line 2246
    if (jp2___22->meth < 3U) {
#line 2246
      tmp___87 = 1;
    } else {
#line 2246
      tmp___87 = 0;
    }
  } else {
#line 2246
    tmp___87 = 0;
  }
  {
#line 2246
  l_is_valid &= tmp___87;
#line 2250
  __cil_tmp9___5 = opj_stream_has_seek(cio___5);
#line 2250
  l_is_valid &= __cil_tmp9___5;
  }
#line 2252
  return (l_is_valid);
}
}
#line 2255 "/root/patron-new/39/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_read_header_procedure(opj_jp2_t *jp2___23 , opj_stream_private_t *stream___1 ,
                                              opj_event_mgr_t *p_manager___20 ) 
{ 
  opj_jp2_box_t box___0 ;
  OPJ_UINT32 l_nb_bytes_read___0 ;
  opj_jp2_header_handler_t *l_current_handler ;
  opj_jp2_header_handler_t *l_current_handler_misplaced ;
  OPJ_UINT32 l_last_data_size ;
  OPJ_UINT32 l_current_data_size ;
  OPJ_BYTE *l_current_data ;
  void *__cil_tmp14___3 ;
  OPJ_BOOL __cil_tmp15___1 ;
  OPJ_OFF_T __cil_tmp18___2 ;
  OPJ_OFF_T __cil_tmp19___2 ;
  OPJ_OFF_T __cil_tmp20___4 ;
  OPJ_BYTE *new_current_data ;
  void *__cil_tmp22___0 ;
  OPJ_SIZE_T __cil_tmp23___0 ;
  OPJ_BOOL __cil_tmp24___0 ;
  OPJ_OFF_T __cil_tmp25 ;

  {
  {
#line 2264
  l_last_data_size = (OPJ_UINT32 )1024;
#line 2266
  l_current_data = (OPJ_BYTE *)0;
#line 2273
  __cil_tmp14___3 = opj_calloc((size_t )1, (size_t )l_last_data_size);
#line 2273
  l_current_data = (OPJ_BYTE *)__cil_tmp14___3;
  }
#line 2275
  if ((unsigned long )l_current_data == (unsigned long )((OPJ_BYTE *)0)) {
    {
#line 2276
    opj_event_msg(p_manager___20, 1, "Not enough memory to handle jpeg2000 file header\n");
    }
#line 2278
    return (0);
  }
  {
#line 2281
  while (1) {
    while_continue___0: /* CIL Label */ ;

    while_continue: 
    {
#line 2281
    __cil_tmp15___1 = opj_jp2_read_boxhdr(& box___0, & l_nb_bytes_read___0, stream___1,
                                          p_manager___20);
    }
#line 2281
    if (! __cil_tmp15___1) {
#line 2281
      goto while_break;
    }
#line 2283
    if (box___0.type == 1785737827U) {
#line 2284
      if (jp2___23->jp2_state & 4U) {
        {
#line 2285
        jp2___23->jp2_state |= 8U;
#line 2286
        opj_free((void *)l_current_data);
        }
#line 2287
        return (1);
      } else {
        {
#line 2289
        opj_event_msg(p_manager___20, 1, "bad placed jpeg codestream\n");
#line 2290
        opj_free((void *)l_current_data);
        }
#line 2291
        return (0);
      }
    } else
#line 2293
    if (box___0.length == 0U) {
      {
#line 2294
      opj_event_msg(p_manager___20, 1, "Cannot handle box of undefined sizes\n");
#line 2295
      opj_free((void *)l_current_data);
      }
#line 2296
      return (0);
    } else
#line 2299
    if (box___0.length < l_nb_bytes_read___0) {
      {
#line 2300
      opj_event_msg(p_manager___20, 1, "invalid box size %d (%x)\n\321d\005]U", box___0.length,
                    box___0.type);
#line 2302
      opj_free((void *)l_current_data);
      }
#line 2303
      return (0);
    }
    {
#line 2306
    l_current_handler = opj_jp2_find_handler(box___0.type);
#line 2307
    l_current_handler_misplaced = opj_jp2_img_find_handler(box___0.type);
#line 2308
    l_current_data_size = box___0.length - l_nb_bytes_read___0;
    }
#line 2310
    if ((unsigned long )l_current_handler != (unsigned long )((opj_jp2_header_handler_t *)0)) {
      _L: 
#line 2311
      if ((unsigned long )l_current_handler == (unsigned long )((opj_jp2_header_handler_t *)0)) {
        {
#line 2312
        opj_event_msg(p_manager___20, 2, "Found a misplaced \'%c%c%c%c\' box outside jp2h box\n",
                      (int )((OPJ_BYTE )(box___0.type >> 24)), (int )((OPJ_BYTE )(box___0.type >> 16)),
                      (int )((OPJ_BYTE )(box___0.type >> 8)), (int )((OPJ_BYTE )box___0.type));
        }
#line 2316
        if (jp2___23->jp2_state & 4U) {
#line 2318
          l_current_handler = l_current_handler_misplaced;
        } else {
          {
#line 2320
          opj_event_msg(p_manager___20, 2, "JPEG2000 Header box not read yet, \'%c%c%c%c\' box will be ignored\n",
                        (int )((OPJ_BYTE )(box___0.type >> 24)), (int )((OPJ_BYTE )(box___0.type >> 16)),
                        (int )((OPJ_BYTE )(box___0.type >> 8)), (int )((OPJ_BYTE )box___0.type));
#line 2324
          jp2___23->jp2_state |= 2147483647U;
#line 2325
          __cil_tmp18___2 = opj_stream_skip(stream___1, (OPJ_OFF_T )l_current_data_size,
                                            p_manager___20);
          }
#line 2325
          if (__cil_tmp18___2 != (long )l_current_data_size) {
            {
#line 2327
            opj_event_msg(p_manager___20, 1, "Problem with skipping JPEG2000 box, stream error\n");
#line 2329
            opj_free((void *)l_current_data);
            }
#line 2330
            return (0);
          }
#line 2332
          goto while_continue;
        }
      }
      {
#line 2335
      __cil_tmp19___2 = opj_stream_get_number_byte_left(stream___1);
      }
#line 2335
      if ((OPJ_OFF_T )l_current_data_size > __cil_tmp19___2) {
        {
#line 2337
        __cil_tmp20___4 = opj_stream_get_number_byte_left(stream___1);
#line 2337
        opj_event_msg(p_manager___20, 1, "Invalid box size %d for box \'%c%c%c%c\'. Need %d bytes, %d bytes remaining \n",
                      box___0.length, (int )((OPJ_BYTE )(box___0.type >> 24)), (int )((OPJ_BYTE )(box___0.type >> 16)),
                      (int )((OPJ_BYTE )(box___0.type >> 8)), (int )((OPJ_BYTE )box___0.type),
                      l_current_data_size, (OPJ_UINT32 )__cil_tmp20___4);
#line 2342
        opj_free((void *)l_current_data);
        }
#line 2343
        return (0);
      }
#line 2345
      if (l_current_data_size > l_last_data_size) {
        {
#line 2346
        __cil_tmp22___0 = opj_realloc((void *)l_current_data, (size_t )l_current_data_size);
#line 2346
        new_current_data = (OPJ_BYTE *)__cil_tmp22___0;
        }
#line 2348
        if (! new_current_data) {
          {
#line 2349
          opj_free((void *)l_current_data);
#line 2350
          opj_event_msg(p_manager___20, 1, "Not enough memory to handle jpeg2000 box\n");
          }
#line 2352
          return (0);
        }
#line 2354
        l_current_data = new_current_data;
#line 2355
        l_last_data_size = l_current_data_size;
      }
      {
#line 2358
      __cil_tmp23___0 = opj_stream_read_data(stream___1, l_current_data, (OPJ_SIZE_T )l_current_data_size,
                                             p_manager___20);
#line 2358
      l_nb_bytes_read___0 = (OPJ_UINT32 )__cil_tmp23___0;
      }
#line 2360
      if (l_nb_bytes_read___0 != l_current_data_size) {
        {
#line 2361
        opj_event_msg(p_manager___20, 1, "Problem with reading JPEG2000 box, stream error\n\220");
#line 2363
        opj_free((void *)l_current_data);
        }
#line 2364
        return (0);
      }
      {
#line 2367
      __cil_tmp24___0 = (*(l_current_handler->handler))(jp2___23, l_current_data,
                                                        l_current_data_size, p_manager___20);
      }
#line 2367
      if (! __cil_tmp24___0) {
        {
#line 2369
        opj_free((void *)l_current_data);
        }
#line 2370
        return (0);
      }
    } else
#line 2310
    if ((unsigned long )l_current_handler_misplaced != (unsigned long )((opj_jp2_header_handler_t *)0)) {
#line 2310
      goto _L;
    } else {
#line 2373
      if (! (jp2___23->jp2_state & 1U)) {
        {
#line 2374
        opj_event_msg(p_manager___20, 1, "Malformed JP2 file format: first box must be JPEG 2000 signature box\n");
#line 2376
        opj_free((void *)l_current_data);
        }
#line 2377
        return (0);
      }
#line 2379
      if (! (jp2___23->jp2_state & 2U)) {
        {
#line 2380
        opj_event_msg(p_manager___20, 1, "Malformed JP2 file format: second box must be file type box\n");
#line 2382
        opj_free((void *)l_current_data);
        }
#line 2383
        return (0);
      }
      {
#line 2385
      jp2___23->jp2_state |= 2147483647U;
#line 2386
      __cil_tmp25 = opj_stream_skip(stream___1, (OPJ_OFF_T )l_current_data_size, p_manager___20);
      }
#line 2386
      if (__cil_tmp25 != (long )l_current_data_size) {
#line 2388
        if (jp2___23->jp2_state & 8U) {
          {
#line 2391
          opj_event_msg(p_manager___20, 2, "Problem with skipping JPEG2000 box, stream error\n");
#line 2393
          opj_free((void *)l_current_data);
          }
#line 2394
          return (1);
        } else {
          {
#line 2396
          opj_event_msg(p_manager___20, 1, "Problem with skipping JPEG2000 box, stream error\n");
#line 2398
          opj_free((void *)l_current_data);
          }
#line 2399
          return (0);
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: 
  {
#line 2405
  opj_free((void *)l_current_data);
  }
#line 2407
  return (1);
}
}
#line 2420 "/root/patron-new/39/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_exec(opj_jp2_t *jp2___24 , opj_procedure_list_t *p_procedure_list ,
                             opj_stream_private_t *stream___2 , opj_event_mgr_t *p_manager___21 ) 
{ 
  OPJ_BOOL (**l_procedure)(opj_jp2_t * , opj_stream_private_t * , opj_event_mgr_t * ) ;
  OPJ_BOOL l_result___1 ;
  OPJ_UINT32 l_nb_proc ;
  OPJ_UINT32 i___15 ;
  opj_procedure *__cil_tmp14___4 ;
  OPJ_BOOL __cil_tmp15___2 ;
  int tmp___95 ;

  {
  {
#line 2427
  l_procedure = (OPJ_BOOL (**)(opj_jp2_t * , opj_stream_private_t * , opj_event_mgr_t * ))0;
#line 2429
  l_result___1 = 1;
#line 2438
  l_nb_proc = opj_procedure_list_get_nb_procedures(p_procedure_list);
#line 2439
  __cil_tmp14___4 = opj_procedure_list_get_first_procedure(p_procedure_list);
#line 2439
  l_procedure = (OPJ_BOOL (**)(opj_jp2_t * , opj_stream_private_t * , opj_event_mgr_t * ))__cil_tmp14___4;
#line 2442
  i___15 = (OPJ_UINT32 )0;
  }
  {
#line 2442
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2442
    if (! (i___15 < l_nb_proc)) {
#line 2442
      goto while_break;
    }
    {
#line 2443
    __cil_tmp15___2 = (*(*l_procedure))(jp2___24, stream___2, p_manager___21);
    }
#line 2443
    if (l_result___1) {
#line 2443
      if (__cil_tmp15___2) {
#line 2443
        tmp___95 = 1;
      } else {
#line 2443
        tmp___95 = 0;
      }
    } else {
#line 2443
      tmp___95 = 0;
    }
#line 2443
    l_result___1 = tmp___95;
#line 2444
    l_procedure ++;
#line 2442
    i___15 ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: 
  {
#line 2448
  opj_procedure_list_clear(p_procedure_list);
  }
#line 2449
  return (l_result___1);
}
}
#line 2452 "/root/patron-new/39/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_start_compress(opj_jp2_t *jp2___25 , opj_stream_private_t *stream___3 ,
                                opj_image_t *p_image___6 , opj_event_mgr_t *p_manager___22 ) 
{ 
  OPJ_BOOL __cil_tmp8___9 ;
  OPJ_BOOL __cil_tmp9___6 ;
  OPJ_BOOL __cil_tmp10___1 ;
  OPJ_BOOL __cil_tmp11___2 ;
  OPJ_BOOL __cil_tmp12___5 ;

  {
  {
#line 2464
  __cil_tmp8___9 = opj_jp2_setup_encoding_validation(jp2___25, p_manager___22);
  }
#line 2464
  if (! __cil_tmp8___9) {
#line 2465
    return (0);
  }
  {
#line 2469
  __cil_tmp9___6 = opj_jp2_exec(jp2___25, jp2___25->m_validation_list, stream___3,
                                p_manager___22);
  }
#line 2469
  if (! __cil_tmp9___6) {
#line 2470
    return (0);
  }
  {
#line 2474
  __cil_tmp10___1 = opj_jp2_setup_header_writing(jp2___25, p_manager___22);
  }
#line 2474
  if (! __cil_tmp10___1) {
#line 2475
    return (0);
  }
  {
#line 2479
  __cil_tmp11___2 = opj_jp2_exec(jp2___25, jp2___25->m_procedure_list, stream___3,
                                 p_manager___22);
  }
#line 2479
  if (! __cil_tmp11___2) {
#line 2480
    return (0);
  }
  {
#line 2483
  __cil_tmp12___5 = opj_j2k_start_compress(jp2___25->j2k, stream___3, p_image___6,
                                           p_manager___22);
  }
#line 2483
  return (__cil_tmp12___5);
}
}
#line 2486 "/root/patron-new/39/src/lib/openjp2/jp2.c"
static opj_jp2_header_handler_t *opj_jp2_find_handler(OPJ_UINT32 p_id ) 
{ 
  OPJ_UINT32 i___16 ;
  OPJ_UINT32 l_handler_size ;

  {
#line 2488
  l_handler_size = (OPJ_UINT32 )(sizeof(jp2_header) / sizeof(opj_jp2_header_handler_t ));
#line 2491
  i___16 = (OPJ_UINT32 )0;
  {
#line 2491
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2491
    if (! (i___16 < l_handler_size)) {
#line 2491
      goto while_break;
    }
#line 2492
    if (jp2_header[i___16].id == p_id) {
#line 2493
      return (& jp2_header[i___16]);
    }
#line 2491
    i___16 ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 2496
  return ((opj_jp2_header_handler_t *)((void *)0));
}
}
#line 2506 "/root/patron-new/39/src/lib/openjp2/jp2.c"
static opj_jp2_header_handler_t *opj_jp2_img_find_handler(OPJ_UINT32 p_id___0 ) 
{ 
  OPJ_UINT32 i___17 ;
  OPJ_UINT32 l_handler_size___0 ;

  {
#line 2509
  l_handler_size___0 = (OPJ_UINT32 )(sizeof(jp2_img_header) / sizeof(opj_jp2_header_handler_t ));
#line 2511
  i___17 = (OPJ_UINT32 )0;
  {
#line 2511
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2511
    if (! (i___17 < l_handler_size___0)) {
#line 2511
      goto while_break;
    }
#line 2512
    if (jp2_img_header[i___17].id == p_id___0) {
#line 2513
      return (& jp2_img_header[i___17]);
    }
#line 2511
    i___17 ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 2517
  return ((opj_jp2_header_handler_t *)((void *)0));
}
}
#line 2530 "/root/patron-new/39/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_read_jp(opj_jp2_t *jp2___26 , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                opj_event_mgr_t *p_manager___23 ) 
{ 
  OPJ_UINT32 l_magic_number ;

  {
#line 2544
  if (jp2___26->jp2_state != 0U) {
    {
#line 2545
    opj_event_msg(p_manager___23, 1, "The signature box must be the first box in the file.\n");
    }
#line 2547
    return (0);
  }
#line 2551
  if (p_header_size != 4U) {
    {
#line 2552
    opj_event_msg(p_manager___23, 1, "Error with JP signature Box size\n");
    }
#line 2553
    return (0);
  }
  {
#line 2557
  opj_read_bytes_LE(p_header_data, & l_magic_number, (OPJ_UINT32 )4);
  }
#line 2558
  if (l_magic_number != 218793738U) {
    {
#line 2559
    opj_event_msg(p_manager___23, 1, "Error with JP Signature : bad magic number\n");
    }
#line 2561
    return (0);
  }
#line 2564
  jp2___26->jp2_state |= 1U;
#line 2566
  return (1);
}
}
#line 2579 "/root/patron-new/39/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_read_ftyp(opj_jp2_t *jp2___27 , OPJ_BYTE *p_header_data___0 ,
                                  OPJ_UINT32 p_header_size___0 , opj_event_mgr_t *p_manager___24 ) 
{ 
  OPJ_UINT32 i___18 ;
  OPJ_UINT32 l_remaining_bytes ;
  void *__cil_tmp10___2 ;

  {
#line 2592
  if (jp2___27->jp2_state != 1U) {
    {
#line 2593
    opj_event_msg(p_manager___24, 1, "The ftyp box must be the second box in the file.\n");
    }
#line 2595
    return (0);
  }
#line 2599
  if (p_header_size___0 < 8U) {
    {
#line 2600
    opj_event_msg(p_manager___24, 1, "Error with FTYP signature Box size\n");
    }
#line 2601
    return (0);
  }
  {
#line 2604
  opj_read_bytes_LE(p_header_data___0, & jp2___27->brand, (OPJ_UINT32 )4);
#line 2605
  p_header_data___0 += 4;
#line 2607
  opj_read_bytes_LE(p_header_data___0, & jp2___27->minversion, (OPJ_UINT32 )4);
#line 2608
  p_header_data___0 += 4;
#line 2610
  l_remaining_bytes = p_header_size___0 - 8U;
  }
#line 2613
  if ((l_remaining_bytes & 3U) != 0U) {
    {
#line 2614
    opj_event_msg(p_manager___24, 1, "Error with FTYP signature Box size\n");
    }
#line 2615
    return (0);
  }
#line 2619
  jp2___27->numcl = l_remaining_bytes >> 2;
#line 2620
  if (jp2___27->numcl) {
    {
#line 2621
    __cil_tmp10___2 = opj_calloc((size_t )jp2___27->numcl, sizeof(OPJ_UINT32 ));
#line 2621
    jp2___27->cl = (OPJ_UINT32 *)__cil_tmp10___2;
    }
#line 2622
    if ((unsigned long )jp2___27->cl == (unsigned long )((OPJ_UINT32 *)0)) {
      {
#line 2623
      opj_event_msg(p_manager___24, 1, "Not enough memory with FTYP Box\n\220");
      }
#line 2624
      return (0);
    }
  }
#line 2628
  i___18 = (OPJ_UINT32 )0;
  {
#line 2628
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2628
    if (! (i___18 < jp2___27->numcl)) {
#line 2628
      goto while_break;
    }
    {
#line 2629
    opj_read_bytes_LE(p_header_data___0, jp2___27->cl + i___18, (OPJ_UINT32 )4);
#line 2630
    p_header_data___0 += 4;
#line 2628
    i___18 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: 
#line 2633
  jp2___27->jp2_state |= 2U;
#line 2635
  return (1);
}
}
#line 2638 "/root/patron-new/39/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_skip_jp2c(opj_jp2_t *jp2___28 , opj_stream_private_t *stream___4 ,
                                  opj_event_mgr_t *p_manager___25 ) 
{ 
  OPJ_OFF_T __cil_tmp8___10 ;

  {
  {
#line 2647
  jp2___28->j2k_codestream_offset = opj_stream_tell(stream___4);
#line 2649
  __cil_tmp8___10 = opj_stream_skip(stream___4, (OPJ_OFF_T )8, p_manager___25);
  }
#line 2649
  if (__cil_tmp8___10 != 8L) {
#line 2650
    return (0);
  }
#line 2653
  return (1);
}
}
#line 2656 "/root/patron-new/39/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jpip_skip_iptr(opj_jp2_t *jp2___29 , opj_stream_private_t *stream___5 ,
                                   opj_event_mgr_t *p_manager___26 ) 
{ 
  OPJ_OFF_T __cil_tmp8___11 ;

  {
  {
#line 2665
  jp2___29->jpip_iptr_offset = opj_stream_tell(stream___5);
#line 2667
  __cil_tmp8___11 = opj_stream_skip(stream___5, (OPJ_OFF_T )24, p_manager___26);
  }
#line 2667
  if (__cil_tmp8___11 != 24L) {
#line 2668
    return (0);
  }
#line 2671
  return (1);
}
}
#line 2684 "/root/patron-new/39/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_read_jp2h(opj_jp2_t *jp2___30 , OPJ_BYTE *p_header_data___1 ,
                                  OPJ_UINT32 p_header_size___1 , opj_event_mgr_t *p_manager___27 ) 
{ 
  OPJ_UINT32 l_box_size ;
  OPJ_UINT32 l_current_data_size___0 ;
  opj_jp2_box_t box___1 ;
  opj_jp2_header_handler_t *l_current_handler___0 ;
  OPJ_BOOL l_has_ihdr ;
  OPJ_BOOL __cil_tmp13___6 ;
  OPJ_BOOL __cil_tmp15___3 ;

  {
#line 2690
  l_box_size = (OPJ_UINT32 )0;
#line 2690
  l_current_data_size___0 = (OPJ_UINT32 )0;
#line 2693
  l_has_ihdr = 0;
#line 2701
  if ((jp2___30->jp2_state & 2U) != 2U) {
    {
#line 2702
    opj_event_msg(p_manager___27, 1, "The  box must be the first box in the file.\n");
    }
#line 2704
    return (0);
  }
#line 2707
  jp2___30->jp2_img_state = (OPJ_UINT32 )0;
  {
#line 2710
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2710
    if (! (p_header_size___1 > 0U)) {
#line 2710
      goto while_break;
    }
    {
#line 2712
    __cil_tmp13___6 = opj_jp2_read_boxhdr_char(& box___1, p_header_data___1, & l_box_size,
                                               p_header_size___1, p_manager___27);
    }
#line 2712
    if (! __cil_tmp13___6) {
      {
#line 2714
      opj_event_msg(p_manager___27, 1, "Stream error while reading JP2 Header box\n");
      }
#line 2716
      return (0);
    }
#line 2719
    if (box___1.length > p_header_size___1) {
      {
#line 2720
      opj_event_msg(p_manager___27, 1, "Stream error while reading JP2 Header box: box length is inconsistent.\n");
      }
#line 2722
      return (0);
    }
    {
#line 2725
    l_current_handler___0 = opj_jp2_img_find_handler(box___1.type);
#line 2726
    l_current_data_size___0 = box___1.length - l_box_size;
#line 2727
    p_header_data___1 += l_box_size;
    }
#line 2729
    if ((unsigned long )l_current_handler___0 != (unsigned long )((opj_jp2_header_handler_t *)0)) {
      {
#line 2730
      __cil_tmp15___3 = (*(l_current_handler___0->handler))(jp2___30, p_header_data___1,
                                                            l_current_data_size___0,
                                                            p_manager___27);
      }
#line 2730
      if (! __cil_tmp15___3) {
#line 2732
        return (0);
      }
    } else {
#line 2735
      jp2___30->jp2_img_state |= 2147483647U;
    }
#line 2738
    if (box___1.type == 1768449138U) {
#line 2739
      l_has_ihdr = 1;
    }
#line 2742
    p_header_data___1 += l_current_data_size___0;
#line 2743
    p_header_size___1 -= box___1.length;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 2746
  if (l_has_ihdr == 0) {
    {
#line 2747
    opj_event_msg(p_manager___27, 1, "Stream error while reading JP2 Header box: no \'ihdr\' box.\n");
    }
#line 2749
    return (0);
  }
#line 2752
  jp2___30->jp2_state |= 4U;
#line 2753
  jp2___30->has_jp2h = (OPJ_BYTE )1;
#line 2755
  return (1);
}
}
#line 2758 "/root/patron-new/39/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_read_boxhdr_char(opj_jp2_box_t *box___2 , OPJ_BYTE *p_data___1 ,
                                         OPJ_UINT32 *p_number_bytes_read___0 , OPJ_UINT32 p_box_max_size ,
                                         opj_event_mgr_t *p_manager___28 ) 
{ 
  OPJ_UINT32 l_value___4 ;
  OPJ_UINT32 l_xl_part_size___0 ;

  {
#line 2773
  if (p_box_max_size < 8U) {
    {
#line 2774
    opj_event_msg(p_manager___28, 1, "Cannot handle box of less than 8 bytes\n");
    }
#line 2775
    return (0);
  }
  {
#line 2779
  opj_read_bytes_LE(p_data___1, & l_value___4, (OPJ_UINT32 )4);
#line 2780
  p_data___1 += 4;
#line 2781
  box___2->length = l_value___4;
#line 2783
  opj_read_bytes_LE(p_data___1, & l_value___4, (OPJ_UINT32 )4);
#line 2784
  p_data___1 += 4;
#line 2785
  box___2->type = l_value___4;
#line 2787
  *p_number_bytes_read___0 = (OPJ_UINT32 )8;
  }
#line 2791
  if (box___2->length == 1U) {
#line 2794
    if (p_box_max_size < 16U) {
      {
#line 2795
      opj_event_msg(p_manager___28, 1, "Cannot handle XL box of less than 16 bytes\n\005]U");
      }
#line 2797
      return (0);
    }
    {
#line 2800
    opj_read_bytes_LE(p_data___1, & l_xl_part_size___0, (OPJ_UINT32 )4);
#line 2801
    p_data___1 += 4;
#line 2802
    *p_number_bytes_read___0 += 4U;
    }
#line 2804
    if (l_xl_part_size___0 != 0U) {
      {
#line 2805
      opj_event_msg(p_manager___28, 1, "Cannot handle box sizes higher than 2^32\n");
      }
#line 2807
      return (0);
    }
    {
#line 2810
    opj_read_bytes_LE(p_data___1, & l_value___4, (OPJ_UINT32 )4);
#line 2811
    *p_number_bytes_read___0 += 4U;
#line 2812
    box___2->length = l_value___4;
    }
#line 2814
    if (box___2->length == 0U) {
      {
#line 2815
      opj_event_msg(p_manager___28, 1, "Cannot handle box of undefined sizes\n");
      }
#line 2816
      return (0);
    }
  } else
#line 2818
  if (box___2->length == 0U) {
    {
#line 2819
    opj_event_msg(p_manager___28, 1, "Cannot handle box of undefined sizes\n");
    }
#line 2820
    return (0);
  }
#line 2822
  if (box___2->length < *p_number_bytes_read___0) {
    {
#line 2823
    opj_event_msg(p_manager___28, 1, "Box length is inconsistent.\n");
    }
#line 2824
    return (0);
  }
#line 2826
  return (1);
}
}
#line 2829 "/root/patron-new/39/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_read_header(opj_stream_private_t *p_stream___10 , opj_jp2_t *jp2___31 ,
                             opj_image_t **p_image___7 , opj_event_mgr_t *p_manager___29 ) 
{ 
  OPJ_BOOL __cil_tmp8___12 ;
  OPJ_BOOL __cil_tmp9___7 ;
  OPJ_BOOL __cil_tmp10___3 ;
  OPJ_BOOL __cil_tmp11___3 ;
  OPJ_BOOL __cil_tmp12___6 ;

  {
  {
#line 2841
  __cil_tmp8___12 = opj_jp2_setup_decoding_validation(jp2___31, p_manager___29);
  }
#line 2841
  if (! __cil_tmp8___12) {
#line 2842
    return (0);
  }
  {
#line 2846
  __cil_tmp9___7 = opj_jp2_setup_header_reading(jp2___31, p_manager___29);
  }
#line 2846
  if (! __cil_tmp9___7) {
#line 2847
    return (0);
  }
  {
#line 2851
  __cil_tmp10___3 = opj_jp2_exec(jp2___31, jp2___31->m_validation_list, p_stream___10,
                                 p_manager___29);
  }
#line 2851
  if (! __cil_tmp10___3) {
#line 2852
    return (0);
  }
  {
#line 2856
  __cil_tmp11___3 = opj_jp2_exec(jp2___31, jp2___31->m_procedure_list, p_stream___10,
                                 p_manager___29);
  }
#line 2856
  if (! __cil_tmp11___3) {
#line 2857
    return (0);
  }
#line 2859
  if ((int )jp2___31->has_jp2h == 0) {
    {
#line 2860
    opj_event_msg(p_manager___29, 1, "JP2H box missing. Required.\n");
    }
#line 2861
    return (0);
  }
#line 2863
  if ((int )jp2___31->has_ihdr == 0) {
    {
#line 2864
    opj_event_msg(p_manager___29, 1, "IHDR box_missing. Required.\n");
    }
#line 2865
    return (0);
  }
  {
#line 2868
  __cil_tmp12___6 = opj_j2k_read_header(p_stream___10, jp2___31->j2k, p_image___7,
                                        p_manager___29);
  }
#line 2868
  return (__cil_tmp12___6);
}
}
#line 2874 "/root/patron-new/39/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_setup_encoding_validation(opj_jp2_t *jp2___32 , opj_event_mgr_t *p_manager___30 ) 
{ 
  OPJ_BOOL __cil_tmp5___11 ;

  {
  {
#line 2881
  __cil_tmp5___11 = opj_procedure_list_add_procedure(jp2___32->m_validation_list,
                                                     (void (*)(void))(& opj_jp2_default_validation),
                                                     p_manager___30);
  }
#line 2881
  if (! __cil_tmp5___11) {
#line 2883
    return (0);
  }
#line 2887
  return (1);
}
}
#line 2890 "/root/patron-new/39/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_setup_decoding_validation(opj_jp2_t *jp2___33 , opj_event_mgr_t *p_manager___31 ) 
{ 


  {
#line 2902
  return (1);
}
}
#line 2905 "/root/patron-new/39/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_setup_header_writing(opj_jp2_t *jp2___34 , opj_event_mgr_t *p_manager___32 ) 
{ 
  OPJ_BOOL __cil_tmp5___12 ;
  OPJ_BOOL __cil_tmp6___6 ;
  OPJ_BOOL __cil_tmp7___10 ;
  OPJ_BOOL __cil_tmp8___13 ;
  OPJ_BOOL __cil_tmp9___8 ;

  {
  {
#line 2912
  __cil_tmp5___12 = opj_procedure_list_add_procedure(jp2___34->m_procedure_list, (void (*)(void))(& opj_jp2_write_jp),
                                                     p_manager___32);
  }
#line 2912
  if (! __cil_tmp5___12) {
#line 2914
    return (0);
  }
  {
#line 2916
  __cil_tmp6___6 = opj_procedure_list_add_procedure(jp2___34->m_procedure_list, (void (*)(void))(& opj_jp2_write_ftyp),
                                                    p_manager___32);
  }
#line 2916
  if (! __cil_tmp6___6) {
#line 2918
    return (0);
  }
  {
#line 2920
  __cil_tmp7___10 = opj_procedure_list_add_procedure(jp2___34->m_procedure_list, (void (*)(void))(& opj_jp2_write_jp2h),
                                                     p_manager___32);
  }
#line 2920
  if (! __cil_tmp7___10) {
#line 2922
    return (0);
  }
#line 2924
  if (jp2___34->jpip_on) {
    {
#line 2925
    __cil_tmp8___13 = opj_procedure_list_add_procedure(jp2___34->m_procedure_list,
                                                       (void (*)(void))(& opj_jpip_skip_iptr),
                                                       p_manager___32);
    }
#line 2925
    if (! __cil_tmp8___13) {
#line 2927
      return (0);
    }
  }
  {
#line 2930
  __cil_tmp9___8 = opj_procedure_list_add_procedure(jp2___34->m_procedure_list, (void (*)(void))(& opj_jp2_skip_jp2c),
                                                    p_manager___32);
  }
#line 2930
  if (! __cil_tmp9___8) {
#line 2932
    return (0);
  }
#line 2937
  return (1);
}
}
#line 2940 "/root/patron-new/39/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_setup_header_reading(opj_jp2_t *jp2___35 , opj_event_mgr_t *p_manager___33 ) 
{ 
  OPJ_BOOL __cil_tmp5___13 ;

  {
  {
#line 2947
  __cil_tmp5___13 = opj_procedure_list_add_procedure(jp2___35->m_procedure_list, (void (*)(void))(& opj_jp2_read_header_procedure),
                                                     p_manager___33);
  }
#line 2947
  if (! __cil_tmp5___13) {
#line 2949
    return (0);
  }
#line 2954
  return (1);
}
}
#line 2957 "/root/patron-new/39/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_read_tile_header(opj_jp2_t *p_jp2 , OPJ_UINT32 *p_tile_index___2 ,
                                  OPJ_UINT32 *p_data_size___2 , OPJ_INT32 *p_tile_x0___0 ,
                                  OPJ_INT32 *p_tile_y0___0 , OPJ_INT32 *p_tile_x1___0 ,
                                  OPJ_INT32 *p_tile_y1___0 , OPJ_UINT32 *p_nb_comps___0 ,
                                  OPJ_BOOL *p_go_on , opj_stream_private_t *p_stream___11 ,
                                  opj_event_mgr_t *p_manager___34 ) 
{ 
  OPJ_BOOL __cil_tmp12___7 ;

  {
  {
#line 2970
  __cil_tmp12___7 = opj_j2k_read_tile_header(p_jp2->j2k, p_tile_index___2, p_data_size___2,
                                             p_tile_x0___0, p_tile_y0___0, p_tile_x1___0,
                                             p_tile_y1___0, p_nb_comps___0, p_go_on,
                                             p_stream___11, p_manager___34);
  }
#line 2970
  return (__cil_tmp12___7);
}
}
#line 2981 "/root/patron-new/39/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_write_tile(opj_jp2_t *p_jp2___0 , OPJ_UINT32 p_tile_index___3 , OPJ_BYTE *p_data___2 ,
                            OPJ_UINT32 p_data_size___3 , opj_stream_private_t *p_stream___12 ,
                            opj_event_mgr_t *p_manager___35 ) 
{ 
  OPJ_BOOL __cil_tmp7___11 ;

  {
  {
#line 2990
  __cil_tmp7___11 = opj_j2k_write_tile(p_jp2___0->j2k, p_tile_index___3, p_data___2,
                                       p_data_size___3, p_stream___12, p_manager___35);
  }
#line 2990
  return (__cil_tmp7___11);
}
}
#line 2994 "/root/patron-new/39/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_decode_tile(opj_jp2_t *p_jp2___1 , OPJ_UINT32 p_tile_index___4 ,
                             OPJ_BYTE *p_data___3 , OPJ_UINT32 p_data_size___4 , opj_stream_private_t *p_stream___13 ,
                             opj_event_mgr_t *p_manager___36 ) 
{ 
  OPJ_BOOL __cil_tmp7___12 ;

  {
  {
#line 3002
  __cil_tmp7___12 = opj_j2k_decode_tile(p_jp2___1->j2k, p_tile_index___4, p_data___3,
                                        p_data_size___4, p_stream___13, p_manager___36);
  }
#line 3002
  return (__cil_tmp7___12);
}
}
#line 3006 "/root/patron-new/39/src/lib/openjp2/jp2.c"
void opj_jp2_destroy(opj_jp2_t *jp2___36 ) 
{ 


  {
#line 3008
  if (jp2___36) {
    {
#line 3010
    opj_j2k_destroy(jp2___36->j2k);
#line 3011
    jp2___36->j2k = (opj_j2k_t *)0;
    }
#line 3013
    if (jp2___36->comps) {
      {
#line 3014
      opj_free((void *)jp2___36->comps);
#line 3015
      jp2___36->comps = (opj_jp2_comps_t *)0;
      }
    }
#line 3018
    if (jp2___36->cl) {
      {
#line 3019
      opj_free((void *)jp2___36->cl);
#line 3020
      jp2___36->cl = (OPJ_UINT32 *)0;
      }
    }
#line 3023
    if (jp2___36->color.icc_profile_buf) {
      {
#line 3024
      opj_free((void *)jp2___36->color.icc_profile_buf);
#line 3025
      jp2___36->color.icc_profile_buf = (OPJ_BYTE *)0;
      }
    }
#line 3028
    if (jp2___36->color.jp2_cdef) {
#line 3029
      if ((jp2___36->color.jp2_cdef)->info) {
        {
#line 3030
        opj_free((void *)(jp2___36->color.jp2_cdef)->info);
#line 3031
        (jp2___36->color.jp2_cdef)->info = (opj_jp2_cdef_info_t *)((void *)0);
        }
      }
      {
#line 3034
      opj_free((void *)jp2___36->color.jp2_cdef);
#line 3035
      jp2___36->color.jp2_cdef = (opj_jp2_cdef_t *)0;
      }
    }
#line 3038
    if (jp2___36->color.jp2_pclr) {
#line 3039
      if ((jp2___36->color.jp2_pclr)->cmap) {
        {
#line 3040
        opj_free((void *)(jp2___36->color.jp2_pclr)->cmap);
#line 3041
        (jp2___36->color.jp2_pclr)->cmap = (opj_jp2_cmap_comp_t *)((void *)0);
        }
      }
#line 3043
      if ((jp2___36->color.jp2_pclr)->channel_sign) {
        {
#line 3044
        opj_free((void *)(jp2___36->color.jp2_pclr)->channel_sign);
#line 3045
        (jp2___36->color.jp2_pclr)->channel_sign = (OPJ_BYTE *)((void *)0);
        }
      }
#line 3047
      if ((jp2___36->color.jp2_pclr)->channel_size) {
        {
#line 3048
        opj_free((void *)(jp2___36->color.jp2_pclr)->channel_size);
#line 3049
        (jp2___36->color.jp2_pclr)->channel_size = (OPJ_BYTE *)((void *)0);
        }
      }
#line 3051
      if ((jp2___36->color.jp2_pclr)->entries) {
        {
#line 3052
        opj_free((void *)(jp2___36->color.jp2_pclr)->entries);
#line 3053
        (jp2___36->color.jp2_pclr)->entries = (OPJ_UINT32 *)((void *)0);
        }
      }
      {
#line 3056
      opj_free((void *)jp2___36->color.jp2_pclr);
#line 3057
      jp2___36->color.jp2_pclr = (opj_jp2_pclr_t *)0;
      }
    }
#line 3060
    if (jp2___36->m_validation_list) {
      {
#line 3061
      opj_procedure_list_destroy(jp2___36->m_validation_list);
#line 3062
      jp2___36->m_validation_list = (struct opj_procedure_list *)0;
      }
    }
#line 3065
    if (jp2___36->m_procedure_list) {
      {
#line 3066
      opj_procedure_list_destroy(jp2___36->m_procedure_list);
#line 3067
      jp2___36->m_procedure_list = (struct opj_procedure_list *)0;
      }
    }
    {
#line 3070
    opj_free((void *)jp2___36);
    }
  }
#line 3073
  return;
}
}
#line 3074 "/root/patron-new/39/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_set_decoded_components(opj_jp2_t *p_jp2___2 , OPJ_UINT32 numcomps___0 ,
                                        OPJ_UINT32 *comps_indices___0 , opj_event_mgr_t *p_manager___37 ) 
{ 
  OPJ_BOOL __cil_tmp5___14 ;

  {
  {
#line 3079
  __cil_tmp5___14 = opj_j2k_set_decoded_components(p_jp2___2->j2k, numcomps___0, comps_indices___0,
                                                   p_manager___37);
  }
#line 3079
  return (__cil_tmp5___14);
}
}
#line 3084 "/root/patron-new/39/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_set_decode_area(opj_jp2_t *p_jp2___3 , opj_image_t *p_image___8 ,
                                 OPJ_INT32 p_start_x___0 , OPJ_INT32 p_start_y___0 ,
                                 OPJ_INT32 p_end_x___0 , OPJ_INT32 p_end_y___0 , opj_event_mgr_t *p_manager___38 ) 
{ 
  OPJ_BOOL __cil_tmp8___14 ;

  {
  {
#line 3091
  __cil_tmp8___14 = opj_j2k_set_decode_area(p_jp2___3->j2k, p_image___8, p_start_x___0,
                                            p_start_y___0, p_end_x___0, p_end_y___0,
                                            p_manager___38);
  }
#line 3091
  return (__cil_tmp8___14);
}
}
#line 3095 "/root/patron-new/39/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_get_tile(opj_jp2_t *p_jp2___4 , opj_stream_private_t *p_stream___14 ,
                          opj_image_t *p_image___9 , opj_event_mgr_t *p_manager___39 ,
                          OPJ_UINT32 tile_index___0 ) 
{ 
  OPJ_BOOL __cil_tmp6___7 ;
  OPJ_BOOL __cil_tmp7___13 ;
  OPJ_BOOL __cil_tmp8___15 ;

  {
#line 3102
  if (! p_image___9) {
#line 3103
    return (0);
  }
  {
#line 3106
  opj_event_msg(p_manager___39, 2, "JP2 box which are after the codestream will not be read by this function.\n");
#line 3109
  __cil_tmp6___7 = opj_j2k_get_tile(p_jp2___4->j2k, p_stream___14, p_image___9, p_manager___39,
                                    tile_index___0);
  }
#line 3109
  if (! __cil_tmp6___7) {
    {
#line 3110
    opj_event_msg(p_manager___39, 1, "Failed to decode the codestream in the JP2 file\n\220");
    }
#line 3112
    return (0);
  }
#line 3115
  if ((p_jp2___4->j2k)->m_specific_param.m_decoder.m_numcomps_to_decode) {
#line 3117
    return (1);
  }
  {
#line 3120
  __cil_tmp7___13 = opj_jp2_check_color(p_image___9, & p_jp2___4->color, p_manager___39);
  }
#line 3120
  if (! __cil_tmp7___13) {
#line 3121
    return (0);
  }
#line 3125
  if (p_jp2___4->enumcs == 16U) {
#line 3126
    p_image___9->color_space = (OPJ_COLOR_SPACE )1;
  } else
#line 3127
  if (p_jp2___4->enumcs == 17U) {
#line 3128
    p_image___9->color_space = (OPJ_COLOR_SPACE )2;
  } else
#line 3129
  if (p_jp2___4->enumcs == 18U) {
#line 3130
    p_image___9->color_space = (OPJ_COLOR_SPACE )3;
  } else
#line 3131
  if (p_jp2___4->enumcs == 24U) {
#line 3132
    p_image___9->color_space = (OPJ_COLOR_SPACE )4;
  } else
#line 3133
  if (p_jp2___4->enumcs == 12U) {
#line 3134
    p_image___9->color_space = (OPJ_COLOR_SPACE )5;
  } else {
#line 3136
    p_image___9->color_space = (OPJ_COLOR_SPACE )-1;
  }
#line 3139
  if (p_jp2___4->color.jp2_pclr) {
#line 3141
    if (! (p_jp2___4->color.jp2_pclr)->cmap) {
      {
#line 3142
      opj_jp2_free_pclr(& p_jp2___4->color);
      }
    } else {
      {
#line 3144
      __cil_tmp8___15 = opj_jp2_apply_pclr(p_image___9, & p_jp2___4->color, p_manager___39);
      }
#line 3144
      if (! __cil_tmp8___15) {
#line 3145
        return (0);
      }
    }
  }
#line 3151
  if (p_jp2___4->color.jp2_cdef) {
    {
#line 3152
    opj_jp2_apply_cdef(p_image___9, & p_jp2___4->color, p_manager___39);
    }
  }
#line 3155
  if (p_jp2___4->color.icc_profile_buf) {
#line 3156
    p_image___9->icc_profile_buf = p_jp2___4->color.icc_profile_buf;
#line 3157
    p_image___9->icc_profile_len = p_jp2___4->color.icc_profile_len;
#line 3158
    p_jp2___4->color.icc_profile_buf = (OPJ_BYTE *)((void *)0);
  }
#line 3161
  return (1);
}
}
#line 3168 "/root/patron-new/39/src/lib/openjp2/jp2.c"
opj_jp2_t *opj_jp2_create(OPJ_BOOL p_is_decoder ) 
{ 
  opj_jp2_t *jp2___37 ;
  void *__cil_tmp3___17 ;

  {
  {
#line 3170
  __cil_tmp3___17 = opj_calloc((size_t )1, sizeof(opj_jp2_t ));
#line 3170
  jp2___37 = (opj_jp2_t *)__cil_tmp3___17;
  }
#line 3171
  if (jp2___37) {
#line 3174
    if (! p_is_decoder) {
      {
#line 3175
      jp2___37->j2k = opj_j2k_create_compress();
      }
    } else {
      {
#line 3177
      jp2___37->j2k = opj_j2k_create_decompress();
      }
    }
#line 3180
    if ((unsigned long )jp2___37->j2k == (unsigned long )((opj_j2k_t *)0)) {
      {
#line 3181
      opj_jp2_destroy(jp2___37);
      }
#line 3182
      return ((opj_jp2_t *)0);
    }
    {
#line 3186
    jp2___37->color.icc_profile_buf = (OPJ_BYTE *)((void *)0);
#line 3187
    jp2___37->color.icc_profile_len = (OPJ_UINT32 )0;
#line 3188
    jp2___37->color.jp2_cdef = (opj_jp2_cdef_t *)((void *)0);
#line 3189
    jp2___37->color.jp2_pclr = (opj_jp2_pclr_t *)((void *)0);
#line 3190
    jp2___37->color.jp2_has_colr = (OPJ_BYTE )0;
#line 3193
    jp2___37->m_validation_list = opj_procedure_list_create();
    }
#line 3194
    if (! jp2___37->m_validation_list) {
      {
#line 3195
      opj_jp2_destroy(jp2___37);
      }
#line 3196
      return ((opj_jp2_t *)0);
    }
    {
#line 3200
    jp2___37->m_procedure_list = opj_procedure_list_create();
    }
#line 3201
    if (! jp2___37->m_procedure_list) {
      {
#line 3202
      opj_jp2_destroy(jp2___37);
      }
#line 3203
      return ((opj_jp2_t *)0);
    }
  }
#line 3207
  return (jp2___37);
}
}
#line 3210 "/root/patron-new/39/src/lib/openjp2/jp2.c"
void jp2_dump(opj_jp2_t *p_jp2___5 , OPJ_INT32 flag , FILE *out_stream ) 
{ 


  {
  {
#line 3215
  j2k_dump(p_jp2___5->j2k, flag, out_stream);
  }
#line 3217
  return;
}
}
#line 3220 "/root/patron-new/39/src/lib/openjp2/jp2.c"
opj_codestream_index_t *jp2_get_cstr_index(opj_jp2_t *p_jp2___6 ) 
{ 
  opj_codestream_index_t *__cil_tmp2___5 ;

  {
  {
#line 3222
  __cil_tmp2___5 = j2k_get_cstr_index(p_jp2___6->j2k);
  }
#line 3222
  return (__cil_tmp2___5);
}
}
#line 3225 "/root/patron-new/39/src/lib/openjp2/jp2.c"
opj_codestream_info_v2_t *jp2_get_cstr_info(opj_jp2_t *p_jp2___7 ) 
{ 
  opj_codestream_info_v2_t *__cil_tmp2___6 ;

  {
  {
#line 3227
  __cil_tmp2___6 = j2k_get_cstr_info(p_jp2___7->j2k);
  }
#line 3227
  return (__cil_tmp2___6);
}
}
#line 3230 "/root/patron-new/39/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_set_decoded_resolution_factor(opj_jp2_t *p_jp2___8 , OPJ_UINT32 res_factor___0 ,
                                               opj_event_mgr_t *p_manager___40 ) 
{ 
  OPJ_BOOL __cil_tmp4___10 ;

  {
  {
#line 3234
  __cil_tmp4___10 = opj_j2k_set_decoded_resolution_factor(p_jp2___8->j2k, res_factor___0,
                                                          p_manager___40);
  }
#line 3234
  return (__cil_tmp4___10);
}
}
#line 3239 "/root/patron-new/39/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_encoder_set_extra_options(opj_jp2_t *p_jp2___9 , char const   * const  *p_options ,
                                           opj_event_mgr_t *p_manager___41 ) 
{ 
  OPJ_BOOL __cil_tmp4___11 ;

  {
  {
#line 3244
  __cil_tmp4___11 = opj_j2k_encoder_set_extra_options(p_jp2___9->j2k, p_options, p_manager___41);
  }
#line 3244
  return (__cil_tmp4___11);
}
}
#line 55 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_setup_header_reading(opj_j2k_t *p_j2k___61 , opj_event_mgr_t *p_manager___104 ) ;
#line 61
static OPJ_BOOL opj_j2k_read_header_procedure(opj_j2k_t *p_j2k___68 , opj_stream_private_t *p_stream___49 ,
                                              opj_event_mgr_t *p_manager___111 ) ;
#line 74
static OPJ_BOOL opj_j2k_encoding_validation(opj_j2k_t *p_j2k___66 , opj_stream_private_t *p_stream___47 ,
                                            opj_event_mgr_t *p_manager___109 ) ;
#line 87
static OPJ_BOOL opj_j2k_decoding_validation(opj_j2k_t *p_j2k___67 , opj_stream_private_t *p_stream___48 ,
                                            opj_event_mgr_t *p_manager___110 ) ;
#line 95
static OPJ_BOOL opj_j2k_setup_encoding_validation(opj_j2k_t *p_j2k___108 , opj_event_mgr_t *p_manager___139 ) ;
#line 102
static OPJ_BOOL opj_j2k_setup_decoding_validation(opj_j2k_t *p_j2k___62 , opj_event_mgr_t *p_manager___105 ) ;
#line 109
static OPJ_BOOL opj_j2k_setup_end_compress(opj_j2k_t *p_j2k___107 , opj_event_mgr_t *p_manager___138 ) ;
#line 121
static OPJ_BOOL opj_j2k_mct_validation(opj_j2k_t *p_j2k___63 , opj_stream_private_t *p_stream___44 ,
                                       opj_event_mgr_t *p_manager___106 ) ;
#line 128
static OPJ_BOOL opj_j2k_build_decoder(opj_j2k_t *p_j2k___64 , opj_stream_private_t *p_stream___45 ,
                                      opj_event_mgr_t *p_manager___107 ) ;
#line 134
static OPJ_BOOL opj_j2k_build_encoder(opj_j2k_t *p_j2k___65 , opj_stream_private_t *p_stream___46 ,
                                      opj_event_mgr_t *p_manager___108 ) ;
#line 145
static OPJ_BOOL opj_j2k_create_tcd(opj_j2k_t *p_j2k___116 , opj_stream_private_t *p_stream___70 ,
                                   opj_event_mgr_t *p_manager___147 ) ;
#line 159
static OPJ_BOOL opj_j2k_exec(opj_j2k_t *p_j2k___69 , opj_procedure_list_t *p_procedure_list___0 ,
                             opj_stream_private_t *p_stream___50 , opj_event_mgr_t *p_manager___112 ) ;
#line 171
static OPJ_BOOL opj_j2k_update_rates(opj_j2k_t *p_j2k___42 , opj_stream_private_t *p_stream___30 ,
                                     opj_event_mgr_t *p_manager___81 ) ;
#line 179
static OPJ_BOOL opj_j2k_copy_default_tcp_and_create_tcd(opj_j2k_t *p_j2k___70 , opj_stream_private_t *p_stream___51 ,
                                                        opj_event_mgr_t *p_manager___113 ) ;
#line 186
static OPJ_BOOL opj_j2k_destroy_header_memory(opj_j2k_t *p_j2k___114 , opj_stream_private_t *p_stream___68 ,
                                              opj_event_mgr_t *p_manager___145 ) ;
#line 197
static struct opj_dec_memory_marker_handler *opj_j2k_get_marker_handler(OPJ_UINT32 p_id___1 ) ;
#line 205
static void opj_j2k_tcp_destroy(opj_tcp_t *p_tcp___4 ) ;
#line 212
static void opj_j2k_tcp_data_destroy(opj_tcp_t *p_tcp___5 ) ;
#line 219
static void opj_j2k_cp_destroy(opj_cp_t *p_cp___0 ) ;
#line 231
static OPJ_BOOL opj_j2k_compare_SPCod_SPCoc(opj_j2k_t *p_j2k___77 , OPJ_UINT32 p_tile_no___2 ,
                                            OPJ_UINT32 p_first_comp_no___1 , OPJ_UINT32 p_second_comp_no___1 ) ;
#line 246
static OPJ_BOOL opj_j2k_write_SPCod_SPCoc(opj_j2k_t *p_j2k___78 , OPJ_UINT32 p_tile_no___3 ,
                                          OPJ_UINT32 p_comp_no___5 , OPJ_BYTE *p_data___11 ,
                                          OPJ_UINT32 *p_header_size___22 , struct opj_event_mgr *p_manager___120 ) ;
#line 262
static OPJ_UINT32 opj_j2k_get_SPCod_SPCoc_size(opj_j2k_t *p_j2k___76 , OPJ_UINT32 p_tile_no___1 ,
                                               OPJ_UINT32 p_comp_no___4 ) ;
#line 274
static OPJ_BOOL opj_j2k_read_SPCod_SPCoc(opj_j2k_t *p_j2k___79 , OPJ_UINT32 compno___3 ,
                                         OPJ_BYTE *p_header_data___22 , OPJ_UINT32 *p_header_size___23 ,
                                         opj_event_mgr_t *p_manager___121 ) ;
#line 289
static OPJ_UINT32 opj_j2k_get_SQcd_SQcc_size(opj_j2k_t *p_j2k___81 , OPJ_UINT32 p_tile_no___4 ,
                                             OPJ_UINT32 p_comp_no___6 ) ;
#line 303
static OPJ_BOOL opj_j2k_compare_SQcd_SQcc(opj_j2k_t *p_j2k___82 , OPJ_UINT32 p_tile_no___5 ,
                                          OPJ_UINT32 p_first_comp_no___2 , OPJ_UINT32 p_second_comp_no___2 ) ;
#line 318
static OPJ_BOOL opj_j2k_write_SQcd_SQcc(opj_j2k_t *p_j2k___83 , OPJ_UINT32 p_tile_no___6 ,
                                        OPJ_UINT32 p_comp_no___7 , OPJ_BYTE *p_data___12 ,
                                        OPJ_UINT32 *p_header_size___24 , struct opj_event_mgr *p_manager___122 ) ;
#line 328
static void opj_j2k_update_tlm(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_part_size ) ;
#line 340
static OPJ_BOOL opj_j2k_read_SQcd_SQcc(opj_j2k_t *p_j2k___84 , OPJ_UINT32 p_comp_no___8 ,
                                       OPJ_BYTE *p_header_data___23 , OPJ_UINT32 *p_header_size___25 ,
                                       opj_event_mgr_t *p_manager___123 ) ;
#line 351
static void opj_j2k_copy_tile_component_parameters(opj_j2k_t *p_j2k___80 ) ;
#line 358
static void opj_j2k_copy_tile_quantization_parameters(opj_j2k_t *p_j2k___85 ) ;
#line 363
static OPJ_BOOL opj_j2k_decode_tiles(opj_j2k_t *p_j2k___93 , opj_stream_private_t *p_stream___55 ,
                                     opj_event_mgr_t *p_manager___125 ) ;
#line 367
static OPJ_BOOL opj_j2k_pre_write_tile(opj_j2k_t *p_j2k___105 , OPJ_UINT32 p_tile_index___7 ,
                                       opj_stream_private_t *p_stream___62 , opj_event_mgr_t *p_manager___136 ) ;
#line 372
static OPJ_BOOL opj_j2k_update_image_data(opj_tcd_t *p_tcd , opj_image_t *p_output_image ) ;
#line 375
static void opj_get_tile_dimensions(opj_image_t *l_image___12 , opj_tcd_tilecomp_t *l_tilec___1 ,
                                    opj_image_comp_t *l_img_comp___6 , OPJ_UINT32 *l_size_comp ,
                                    OPJ_UINT32 *l_width___0 , OPJ_UINT32 *l_height___0 ,
                                    OPJ_UINT32 *l_offset_x , OPJ_UINT32 *l_offset_y ,
                                    OPJ_UINT32 *l_image_width , OPJ_UINT32 *l_stride ,
                                    OPJ_UINT32 *l_tile_offset ) ;
#line 387
static void opj_j2k_get_tile_data(opj_tcd_t *p_tcd___1 , OPJ_BYTE *p_data___13 ) ;
#line 389
static OPJ_BOOL opj_j2k_post_write_tile(opj_j2k_t *p_j2k___106 , opj_stream_private_t *p_stream___63 ,
                                        opj_event_mgr_t *p_manager___137 ) ;
#line 397
static OPJ_BOOL opj_j2k_setup_header_writing(opj_j2k_t *p_j2k___109 , opj_event_mgr_t *p_manager___140 ) ;
#line 400
static OPJ_BOOL opj_j2k_write_first_tile_part(opj_j2k_t *p_j2k___110 , OPJ_BYTE *p_data___14 ,
                                              OPJ_UINT32 *p_data_written___5 , OPJ_UINT32 total_data_size___1 ,
                                              opj_stream_private_t *p_stream___64 ,
                                              struct opj_event_mgr *p_manager___141 ) ;
#line 407
static OPJ_BOOL opj_j2k_write_all_tile_parts(opj_j2k_t *p_j2k___111 , OPJ_BYTE *p_data___15 ,
                                             OPJ_UINT32 *p_data_written___6 , OPJ_UINT32 total_data_size___2 ,
                                             opj_stream_private_t *p_stream___65 ,
                                             struct opj_event_mgr *p_manager___142 ) ;
#line 421
static OPJ_BOOL opj_j2k_get_end_header(opj_j2k_t *p_j2k___43 , struct opj_stream_private *p_stream___31 ,
                                       struct opj_event_mgr *p_manager___82 ) ;
#line 425
static OPJ_BOOL opj_j2k_allocate_tile_element_cstr_index(opj_j2k_t *p_j2k___91 ) ;
#line 440
static OPJ_BOOL opj_j2k_write_soc(opj_j2k_t *p_j2k___1 , opj_stream_private_t *p_stream___15 ,
                                  opj_event_mgr_t *p_manager___44 ) ;
#line 450
static OPJ_BOOL opj_j2k_read_soc(opj_j2k_t *p_j2k___2 , opj_stream_private_t *p_stream___16 ,
                                 opj_event_mgr_t *p_manager___45 ) ;
#line 461
static OPJ_BOOL opj_j2k_write_siz(opj_j2k_t *p_j2k___3 , opj_stream_private_t *p_stream___17 ,
                                  opj_event_mgr_t *p_manager___46 ) ;
#line 472
static OPJ_BOOL opj_j2k_read_siz(opj_j2k_t *p_j2k___4 , OPJ_BYTE *p_header_data___2 ,
                                 OPJ_UINT32 p_header_size___2 , opj_event_mgr_t *p_manager___47 ) ;
#line 484
static OPJ_BOOL opj_j2k_write_com(opj_j2k_t *p_j2k___5 , opj_stream_private_t *p_stream___18 ,
                                  opj_event_mgr_t *p_manager___48 ) ;
#line 495
static OPJ_BOOL opj_j2k_read_com(opj_j2k_t *p_j2k___6 , OPJ_BYTE *p_header_data___3 ,
                                 OPJ_UINT32 p_header_size___3 , opj_event_mgr_t *p_manager___49 ) ;
#line 506
static OPJ_BOOL opj_j2k_write_cod(opj_j2k_t *p_j2k___7 , opj_stream_private_t *p_stream___19 ,
                                  opj_event_mgr_t *p_manager___50 ) ;
#line 517
static OPJ_BOOL opj_j2k_read_cod(opj_j2k_t *p_j2k___8 , OPJ_BYTE *p_header_data___4 ,
                                 OPJ_UINT32 p_header_size___4 , opj_event_mgr_t *p_manager___51 ) ;
#line 531
static OPJ_BOOL opj_j2k_compare_coc(opj_j2k_t *p_j2k___10 , OPJ_UINT32 p_first_comp_no ,
                                    OPJ_UINT32 p_second_comp_no ) ;
#line 542
static OPJ_BOOL opj_j2k_write_coc(opj_j2k_t *p_j2k___9 , OPJ_UINT32 p_comp_no , opj_stream_private_t *p_stream___20 ,
                                  opj_event_mgr_t *p_manager___52 ) ;
#line 556
static void opj_j2k_write_coc_in_memory(opj_j2k_t *p_j2k___11 , OPJ_UINT32 p_comp_no___0 ,
                                        OPJ_BYTE *p_data___4 , OPJ_UINT32 *p_data_written ,
                                        opj_event_mgr_t *p_manager___53 ) ;
#line 567
static OPJ_UINT32 opj_j2k_get_max_coc_size(opj_j2k_t *p_j2k___12 ) ;
#line 576
static OPJ_BOOL opj_j2k_read_coc(opj_j2k_t *p_j2k___13 , OPJ_BYTE *p_header_data___5 ,
                                 OPJ_UINT32 p_header_size___5 , opj_event_mgr_t *p_manager___54 ) ;
#line 588
static OPJ_BOOL opj_j2k_write_qcd(opj_j2k_t *p_j2k___14 , opj_stream_private_t *p_stream___21 ,
                                  opj_event_mgr_t *p_manager___55 ) ;
#line 599
static OPJ_BOOL opj_j2k_read_qcd(opj_j2k_t *p_j2k___15 , OPJ_BYTE *p_header_data___6 ,
                                 OPJ_UINT32 p_header_size___6 , opj_event_mgr_t *p_manager___56 ) ;
#line 613
static OPJ_BOOL opj_j2k_compare_qcc(opj_j2k_t *p_j2k___17 , OPJ_UINT32 p_first_comp_no___0 ,
                                    OPJ_UINT32 p_second_comp_no___0 ) ;
#line 624
static OPJ_BOOL opj_j2k_write_qcc(opj_j2k_t *p_j2k___16 , OPJ_UINT32 p_comp_no___1 ,
                                  opj_stream_private_t *p_stream___22 , opj_event_mgr_t *p_manager___57 ) ;
#line 638
static void opj_j2k_write_qcc_in_memory(opj_j2k_t *p_j2k___18 , OPJ_UINT32 p_comp_no___2 ,
                                        OPJ_BYTE *p_data___5 , OPJ_UINT32 *p_data_written___0 ,
                                        opj_event_mgr_t *p_manager___58 ) ;
#line 647
static OPJ_UINT32 opj_j2k_get_max_qcc_size(opj_j2k_t *p_j2k___19 ) ;
#line 656
static OPJ_BOOL opj_j2k_read_qcc(opj_j2k_t *p_j2k___20 , OPJ_BYTE *p_header_data___7 ,
                                 OPJ_UINT32 p_header_size___7 , opj_event_mgr_t *p_manager___59 ) ;
#line 667
static OPJ_BOOL opj_j2k_write_poc(opj_j2k_t *p_j2k___21 , opj_stream_private_t *p_stream___23 ,
                                  opj_event_mgr_t *p_manager___60 ) ;
#line 678
static void opj_j2k_write_poc_in_memory(opj_j2k_t *p_j2k___22 , OPJ_BYTE *p_data___6 ,
                                        OPJ_UINT32 *p_data_written___1 , opj_event_mgr_t *p_manager___61 ) ;
#line 685
static OPJ_UINT32 opj_j2k_get_max_poc_size(opj_j2k_t *p_j2k___23 ) ;
#line 695
static OPJ_BOOL opj_j2k_read_poc(opj_j2k_t *p_j2k___26 , OPJ_BYTE *p_header_data___8 ,
                                 OPJ_UINT32 p_header_size___8 , opj_event_mgr_t *p_manager___62 ) ;
#line 703
static OPJ_UINT32 opj_j2k_get_max_toc_size(opj_j2k_t *p_j2k___24 ) ;
#line 710
static OPJ_UINT32 opj_j2k_get_specific_header_sizes(opj_j2k_t *p_j2k___25 ) ;
#line 720
static OPJ_BOOL opj_j2k_read_crg(opj_j2k_t *p_j2k___27 , OPJ_BYTE *p_header_data___9 ,
                                 OPJ_UINT32 p_header_size___9 , opj_event_mgr_t *p_manager___63 ) ;
#line 732
static OPJ_BOOL opj_j2k_read_tlm(opj_j2k_t *p_j2k___28 , OPJ_BYTE *p_header_data___10 ,
                                 OPJ_UINT32 p_header_size___10 , opj_event_mgr_t *p_manager___64 ) ;
#line 744
static OPJ_BOOL opj_j2k_write_updated_tlm(opj_j2k_t *p_j2k___112 , struct opj_stream_private *p_stream___66 ,
                                          struct opj_event_mgr *p_manager___143 ) ;
#line 756
static OPJ_BOOL opj_j2k_read_plm(opj_j2k_t *p_j2k___29 , OPJ_BYTE *p_header_data___11 ,
                                 OPJ_UINT32 p_header_size___11 , opj_event_mgr_t *p_manager___65 ) ;
#line 768
static OPJ_BOOL opj_j2k_read_plt(opj_j2k_t *p_j2k___30 , OPJ_BYTE *p_header_data___12 ,
                                 OPJ_UINT32 p_header_size___12 , opj_event_mgr_t *p_manager___66 ) ;
#line 782
static OPJ_BOOL opj_j2k_read_ppm(opj_j2k_t *p_j2k___31 , OPJ_BYTE *p_header_data___13 ,
                                 OPJ_UINT32 p_header_size___13 , opj_event_mgr_t *p_manager___67 ) ;
#line 794
static OPJ_BOOL opj_j2k_merge_ppm(opj_cp_t *p_cp , opj_event_mgr_t *p_manager___68 ) ;
#line 804
static OPJ_BOOL opj_j2k_read_ppt(opj_j2k_t *p_j2k___32 , OPJ_BYTE *p_header_data___14 ,
                                 OPJ_UINT32 p_header_size___14 , opj_event_mgr_t *p_manager___69 ) ;
#line 815
static OPJ_BOOL opj_j2k_merge_ppt(opj_tcp_t *p_tcp , opj_event_mgr_t *p_manager___70 ) ;
#line 826
static OPJ_BOOL opj_j2k_write_tlm(opj_j2k_t *p_j2k___33 , opj_stream_private_t *p_stream___24 ,
                                  opj_event_mgr_t *p_manager___71 ) ;
#line 840
static OPJ_BOOL opj_j2k_write_sot(opj_j2k_t *p_j2k___34 , OPJ_BYTE *p_data___7 , OPJ_UINT32 total_data_size ,
                                  OPJ_UINT32 *p_data_written___2 , opj_stream_private_t *p_stream___25 ,
                                  opj_event_mgr_t *p_manager___72 ) ;
#line 860
static OPJ_BOOL opj_j2k_get_sot_values(OPJ_BYTE *p_header_data___15 , OPJ_UINT32 p_header_size___15 ,
                                       OPJ_UINT32 *p_tile_no , OPJ_UINT32 *p_tot_len ,
                                       OPJ_UINT32 *p_current_part , OPJ_UINT32 *p_num_parts ,
                                       opj_event_mgr_t *p_manager___73 ) ;
#line 875
static OPJ_BOOL opj_j2k_read_sot(opj_j2k_t *p_j2k___35 , OPJ_BYTE *p_header_data___16 ,
                                 OPJ_UINT32 p_header_size___16 , opj_event_mgr_t *p_manager___74 ) ;
#line 892
static OPJ_BOOL opj_j2k_write_sod(opj_j2k_t *p_j2k___37 , opj_tcd_t *p_tile_coder ,
                                  OPJ_BYTE *p_data___9 , OPJ_UINT32 *p_data_written___4 ,
                                  OPJ_UINT32 total_data_size___0 , opj_stream_private_t *p_stream___26 ,
                                  opj_event_mgr_t *p_manager___76 ) ;
#line 907
static OPJ_BOOL opj_j2k_read_sod(opj_j2k_t *p_j2k___38 , opj_stream_private_t *p_stream___27 ,
                                 opj_event_mgr_t *p_manager___77 ) ;
#line 911 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static void opj_j2k_update_tlm(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_part_size ) 
{ 


  {
  {
#line 913
  opj_write_bytes_LE(p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current,
                     p_j2k->m_current_tile_number, (OPJ_UINT32 )1);
#line 915
  (p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current) ++;
#line 917
  opj_write_bytes_LE(p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current,
                     p_tile_part_size, (OPJ_UINT32 )4);
#line 919
  p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current += 4;
  }
#line 921
  return;
}
}
#line 932
static OPJ_BOOL opj_j2k_write_rgn(opj_j2k_t *p_j2k___39 , OPJ_UINT32 p_tile_no___0 ,
                                  OPJ_UINT32 p_comp_no___3 , OPJ_UINT32 nb_comps ,
                                  opj_stream_private_t *p_stream___28 , opj_event_mgr_t *p_manager___78 ) ;
#line 947
static OPJ_BOOL opj_j2k_read_rgn(opj_j2k_t *p_j2k___41 , OPJ_BYTE *p_header_data___17 ,
                                 OPJ_UINT32 p_header_size___17 , opj_event_mgr_t *p_manager___80 ) ;
#line 959
static OPJ_BOOL opj_j2k_write_eoc(opj_j2k_t *p_j2k___40 , opj_stream_private_t *p_stream___29 ,
                                  opj_event_mgr_t *p_manager___79 ) ;
#line 983
static OPJ_BOOL opj_j2k_write_mct_data_group(opj_j2k_t *p_j2k___44 , struct opj_stream_private *p_stream___32 ,
                                             struct opj_event_mgr *p_manager___83 ) ;
#line 994
static OPJ_BOOL opj_j2k_init_info(opj_j2k_t *p_j2k___115 , struct opj_stream_private *p_stream___69 ,
                                  struct opj_event_mgr *p_manager___146 ) ;
#line 1005
static OPJ_BOOL opj_j2k_add_mhmarker(opj_codestream_index_t *cstr_index , OPJ_UINT32 type ,
                                     OPJ_OFF_T pos , OPJ_UINT32 len___2 ) ;
#line 1015
static OPJ_BOOL opj_j2k_add_tlmarker(OPJ_UINT32 tileno___3 , opj_codestream_index_t *cstr_index___0 ,
                                     OPJ_UINT32 type___0 , OPJ_OFF_T pos___0 , OPJ_UINT32 len___3 ) ;
#line 1029
static OPJ_BOOL opj_j2k_read_unk(opj_j2k_t *p_j2k___49 , opj_stream_private_t *p_stream___37 ,
                                 OPJ_UINT32 *output_marker , opj_event_mgr_t *p_manager___88 ) ;
#line 1042
static OPJ_BOOL opj_j2k_write_mct_record(opj_j2k_t *p_j2k___50 , opj_mct_data_t *p_mct_record ,
                                         struct opj_stream_private *p_stream___38 ,
                                         struct opj_event_mgr *p_manager___89 ) ;
#line 1055
static OPJ_BOOL opj_j2k_read_mct(opj_j2k_t *p_j2k___51 , OPJ_BYTE *p_header_data___18 ,
                                 OPJ_UINT32 p_header_size___18 , opj_event_mgr_t *p_manager___90 ) ;
#line 1068
static OPJ_BOOL opj_j2k_write_mcc_record(opj_j2k_t *p_j2k___52 , struct opj_simple_mcc_decorrelation_data *p_mcc_record ,
                                         struct opj_stream_private *p_stream___39 ,
                                         struct opj_event_mgr *p_manager___91 ) ;
#line 1081
static OPJ_BOOL opj_j2k_read_mcc(opj_j2k_t *p_j2k___53 , OPJ_BYTE *p_header_data___19 ,
                                 OPJ_UINT32 p_header_size___19 , opj_event_mgr_t *p_manager___92 ) ;
#line 1093
static OPJ_BOOL opj_j2k_write_mco(opj_j2k_t *p_j2k___54 , struct opj_stream_private *p_stream___40 ,
                                  struct opj_event_mgr *p_manager___93 ) ;
#line 1105
static OPJ_BOOL opj_j2k_read_mco(opj_j2k_t *p_j2k___55 , OPJ_BYTE *p_header_data___20 ,
                                 OPJ_UINT32 p_header_size___20 , opj_event_mgr_t *p_manager___94 ) ;
#line 1110
static OPJ_BOOL opj_j2k_add_mct(opj_tcp_t *p_tcp___2 , opj_image_t *p_image___10 ,
                                OPJ_UINT32 p_index ) ;
#line 1113
static void opj_j2k_read_int16_to_float(void const   *p_src_data , void *p_dest_data ,
                                        OPJ_UINT32 p_nb_elem ) ;
#line 1115
static void opj_j2k_read_int32_to_float(void const   *p_src_data___0 , void *p_dest_data___0 ,
                                        OPJ_UINT32 p_nb_elem___0 ) ;
#line 1117
static void opj_j2k_read_float32_to_float(void const   *p_src_data___1 , void *p_dest_data___1 ,
                                          OPJ_UINT32 p_nb_elem___1 ) ;
#line 1119
static void opj_j2k_read_float64_to_float(void const   *p_src_data___2 , void *p_dest_data___2 ,
                                          OPJ_UINT32 p_nb_elem___2 ) ;
#line 1122
static void opj_j2k_read_int16_to_int32(void const   *p_src_data___3 , void *p_dest_data___3 ,
                                        OPJ_UINT32 p_nb_elem___3 ) ;
#line 1124
static void opj_j2k_read_int32_to_int32(void const   *p_src_data___4 , void *p_dest_data___4 ,
                                        OPJ_UINT32 p_nb_elem___4 ) ;
#line 1126
static void opj_j2k_read_float32_to_int32(void const   *p_src_data___5 , void *p_dest_data___5 ,
                                          OPJ_UINT32 p_nb_elem___5 ) ;
#line 1128
static void opj_j2k_read_float64_to_int32(void const   *p_src_data___6 , void *p_dest_data___6 ,
                                          OPJ_UINT32 p_nb_elem___6 ) ;
#line 1131
static void opj_j2k_write_float_to_int16(void const   *p_src_data___7 , void *p_dest_data___7 ,
                                         OPJ_UINT32 p_nb_elem___7 ) ;
#line 1133
static void opj_j2k_write_float_to_int32(void const   *p_src_data___8 , void *p_dest_data___8 ,
                                         OPJ_UINT32 p_nb_elem___8 ) ;
#line 1135
static void opj_j2k_write_float_to_float(void const   *p_src_data___9 , void *p_dest_data___9 ,
                                         OPJ_UINT32 p_nb_elem___9 ) ;
#line 1137
static void opj_j2k_write_float_to_float64(void const   *p_src_data___10 , void *p_dest_data___10 ,
                                           OPJ_UINT32 p_nb_elem___10 ) ;
#line 1147
static OPJ_BOOL opj_j2k_end_encoding(opj_j2k_t *p_j2k___113 , struct opj_stream_private *p_stream___67 ,
                                     struct opj_event_mgr *p_manager___144 ) ;
#line 1158
static OPJ_BOOL opj_j2k_write_cbd(opj_j2k_t *p_j2k___56 , struct opj_stream_private *p_stream___41 ,
                                  struct opj_event_mgr *p_manager___95 ) ;
#line 1169
static OPJ_BOOL opj_j2k_read_cbd(opj_j2k_t *p_j2k___57 , OPJ_BYTE *p_header_data___21 ,
                                 OPJ_UINT32 p_header_size___21 , opj_event_mgr_t *p_manager___96 ) ;
#line 1182
static OPJ_BOOL opj_j2k_write_all_coc(opj_j2k_t *p_j2k___45 , struct opj_stream_private *p_stream___33 ,
                                      struct opj_event_mgr *p_manager___84 ) ;
#line 1193
static OPJ_BOOL opj_j2k_write_all_qcc(opj_j2k_t *p_j2k___46 , struct opj_stream_private *p_stream___34 ,
                                      struct opj_event_mgr *p_manager___85 ) ;
#line 1204
static OPJ_BOOL opj_j2k_write_regions(opj_j2k_t *p_j2k___47 , struct opj_stream_private *p_stream___35 ,
                                      struct opj_event_mgr *p_manager___86 ) ;
#line 1215
static OPJ_BOOL opj_j2k_write_epc(opj_j2k_t *p_j2k___48 , struct opj_stream_private *p_stream___36 ,
                                  struct opj_event_mgr *p_manager___87 ) ;
#line 1233
static OPJ_BOOL opj_j2k_check_poc_val(opj_poc_t *p_pocs , OPJ_UINT32 tileno , OPJ_UINT32 p_nb_pocs ,
                                      OPJ_UINT32 p_nb_resolutions , OPJ_UINT32 p_num_comps ,
                                      OPJ_UINT32 p_num_layers , opj_event_mgr_t *p_manager___42 ) ;
#line 1250
static OPJ_UINT32 opj_j2k_get_num_tp(opj_cp_t *cp , OPJ_UINT32 pino , OPJ_UINT32 tileno___0 ) ;
#line 1265
static OPJ_BOOL opj_j2k_calculate_tp(opj_j2k_t *p_j2k___0 , opj_cp_t *cp___0 , OPJ_UINT32 *p_nb_tiles ,
                                     opj_image_t *image___3 , opj_event_mgr_t *p_manager___43 ) ;
#line 1271
static void opj_j2k_dump_MH_info(opj_j2k_t *p_j2k___88 , FILE *out_stream___3 ) ;
#line 1273
static void opj_j2k_dump_MH_index(opj_j2k_t *p_j2k___87 , FILE *out_stream___2 ) ;
#line 1275
static opj_codestream_index_t *opj_j2k_create_cstr_index(void) ;
#line 1277
static OPJ_FLOAT32 opj_j2k_get_tp_stride(opj_tcp_t *p_tcp___0 ) ;
#line 1279
static OPJ_FLOAT32 opj_j2k_get_default_stride(opj_tcp_t *p_tcp___1 ) ;
#line 1281
static int opj_j2k_initialise_4K_poc(opj_poc_t *POC , int numres ) ;
#line 1283
static void opj_j2k_set_cinema_parameters(opj_cparameters_t *parameters___7 , opj_image_t *image___4 ,
                                          opj_event_mgr_t *p_manager___97 ) ;
#line 1286
static OPJ_BOOL opj_j2k_is_cinema_compliant(opj_image_t *image___5 , OPJ_UINT16 rsiz ,
                                            opj_event_mgr_t *p_manager___98 ) ;
#line 1289
static void opj_j2k_set_imf_parameters(opj_cparameters_t *parameters___9 , opj_image_t *image___7 ,
                                       opj_event_mgr_t *p_manager___99 ) ;
#line 1292
static OPJ_BOOL opj_j2k_is_imf_compliant(opj_cparameters_t *parameters___10 , opj_image_t *image___8 ,
                                         opj_event_mgr_t *p_manager___100 ) ;
#line 1306
static OPJ_BOOL opj_j2k_need_nb_tile_parts_correction(opj_stream_private_t *p_stream___52 ,
                                                      OPJ_UINT32 tile_no , OPJ_BOOL *p_correction_needed ,
                                                      opj_event_mgr_t *p_manager___114 ) ;
#line 1320 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static j2k_prog_order_t j2k_prog_order_list[6]  = {      {(OPJ_PROG_ORDER )4, {(char )"CPRL", (char)0, (char)0, (char)0, (char)0}}, 
        {(OPJ_PROG_ORDER )0, {(char )"LRCP", (char)0, (char)0, (char)0, (char)0}}, 
        {(OPJ_PROG_ORDER )3, {(char )"PCRL", (char)0, (char)0, (char)0, (char)0}}, 
        {(OPJ_PROG_ORDER )1, {(char )"RLCP", (char)0, (char)0, (char)0, (char)0}}, 
        {(OPJ_PROG_ORDER )2, {(char )"RPCL", (char)0, (char)0, (char)0, (char)0}}, 
        {(OPJ_PROG_ORDER )-1, {(char )"\250", (char)0, (char)0, (char)0, (char)0}}};
#line 1332 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_UINT32 MCT_ELEMENT_SIZE[4]  = {      (OPJ_UINT32 )2,      (OPJ_UINT32 )4,      (OPJ_UINT32 )4,      (OPJ_UINT32 )8};
#line 1342 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static opj_j2k_mct_function j2k_mct_read_functions_to_float[4]  = {      & opj_j2k_read_int16_to_float,      & opj_j2k_read_int32_to_float,      & opj_j2k_read_float32_to_float,      & opj_j2k_read_float64_to_float};
#line 1349 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static opj_j2k_mct_function j2k_mct_read_functions_to_int32[4]  = {      & opj_j2k_read_int16_to_int32,      & opj_j2k_read_int32_to_int32,      & opj_j2k_read_float32_to_int32,      & opj_j2k_read_float64_to_int32};
#line 1356 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static opj_j2k_mct_function j2k_mct_write_functions_from_float[4]  = {      & opj_j2k_write_float_to_int16,      & opj_j2k_write_float_to_int32,      & opj_j2k_write_float_to_float,      & opj_j2k_write_float_to_float64};
#line 1376 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static opj_dec_memory_marker_handler_t j2k_memory_marker_handler_tab[21]  = 
#line 1376
  {      {(OPJ_UINT32 )65424, (OPJ_UINT32 )12, & opj_j2k_read_sot}, 
        {(OPJ_UINT32 )65362, (OPJ_UINT32 )20, & opj_j2k_read_cod}, 
        {(OPJ_UINT32 )65363, (OPJ_UINT32 )20, & opj_j2k_read_coc}, 
        {(OPJ_UINT32 )65374, (OPJ_UINT32 )20, & opj_j2k_read_rgn}, 
        {(OPJ_UINT32 )65372, (OPJ_UINT32 )20, & opj_j2k_read_qcd}, 
        {(OPJ_UINT32 )65373, (OPJ_UINT32 )20, & opj_j2k_read_qcc}, 
        {(OPJ_UINT32 )65375, (OPJ_UINT32 )20, & opj_j2k_read_poc}, 
        {(OPJ_UINT32 )65361, (OPJ_UINT32 )2, & opj_j2k_read_siz}, 
        {(OPJ_UINT32 )65365, (OPJ_UINT32 )4, & opj_j2k_read_tlm}, 
        {(OPJ_UINT32 )65367, (OPJ_UINT32 )4, & opj_j2k_read_plm}, 
        {(OPJ_UINT32 )65368, (OPJ_UINT32 )16, & opj_j2k_read_plt}, 
        {(OPJ_UINT32 )65376, (OPJ_UINT32 )4, & opj_j2k_read_ppm}, 
        {(OPJ_UINT32 )65377, (OPJ_UINT32 )16, & opj_j2k_read_ppt}, 
        {(OPJ_UINT32 )65425, (OPJ_UINT32 )0, (OPJ_BOOL (*)(opj_j2k_t * , OPJ_BYTE * ,
                                                        OPJ_UINT32  , opj_event_mgr_t * ))0}, 
        {(OPJ_UINT32 )65379,
      (OPJ_UINT32 )4, & opj_j2k_read_crg}, 
        {(OPJ_UINT32 )65380, (OPJ_UINT32 )20, & opj_j2k_read_com}, 
        {(OPJ_UINT32 )65396, (OPJ_UINT32 )20, & opj_j2k_read_mct}, 
        {(OPJ_UINT32 )65400, (OPJ_UINT32 )4, & opj_j2k_read_cbd}, 
        {(OPJ_UINT32 )65397, (OPJ_UINT32 )20, & opj_j2k_read_mcc}, 
        {(OPJ_UINT32 )65399, (OPJ_UINT32 )20, & opj_j2k_read_mco}, 
        {(OPJ_UINT32 )0, (OPJ_UINT32 )20, (OPJ_BOOL (*)(opj_j2k_t * , OPJ_BYTE * , OPJ_UINT32  ,
                                                     opj_event_mgr_t * ))0}};
#line 1413 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static void opj_j2k_read_int16_to_float(void const   *p_src_data , void *p_dest_data ,
                                        OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_src_data ;
  OPJ_FLOAT32 *l_dest_data ;
  OPJ_UINT32 i___19 ;
  OPJ_UINT32 l_temp ;
  OPJ_FLOAT32 *__cil_tmp8___16 ;

  {
#line 1416
  l_src_data = (OPJ_BYTE *)p_src_data;
#line 1417
  l_dest_data = (OPJ_FLOAT32 *)p_dest_data;
#line 1421
  i___19 = (OPJ_UINT32 )0;
  {
#line 1421
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1421
    if (! (i___19 < p_nb_elem)) {
#line 1421
      goto while_break;
    }
    {
#line 1422
    opj_read_bytes_LE(l_src_data, & l_temp, (OPJ_UINT32 )2);
#line 1424
    l_src_data += sizeof(OPJ_INT16 );
#line 1426
    __cil_tmp8___16 = l_dest_data;
#line 1426
    l_dest_data ++;
#line 1426
    *__cil_tmp8___16 = (OPJ_FLOAT32 )l_temp;
#line 1421
    i___19 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 1425
  return;
}
}
#line 1430 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static void opj_j2k_read_int32_to_float(void const   *p_src_data___0 , void *p_dest_data___0 ,
                                        OPJ_UINT32 p_nb_elem___0 ) 
{ 
  OPJ_BYTE *l_src_data___0 ;
  OPJ_FLOAT32 *l_dest_data___0 ;
  OPJ_UINT32 i___20 ;
  OPJ_UINT32 l_temp___0 ;
  OPJ_FLOAT32 *__cil_tmp8___17 ;

  {
#line 1433
  l_src_data___0 = (OPJ_BYTE *)p_src_data___0;
#line 1434
  l_dest_data___0 = (OPJ_FLOAT32 *)p_dest_data___0;
#line 1438
  i___20 = (OPJ_UINT32 )0;
  {
#line 1438
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1438
    if (! (i___20 < p_nb_elem___0)) {
#line 1438
      goto while_break;
    }
    {
#line 1439
    opj_read_bytes_LE(l_src_data___0, & l_temp___0, (OPJ_UINT32 )4);
#line 1441
    l_src_data___0 += sizeof(OPJ_INT32 );
#line 1443
    __cil_tmp8___17 = l_dest_data___0;
#line 1443
    l_dest_data___0 ++;
#line 1443
    *__cil_tmp8___17 = (OPJ_FLOAT32 )l_temp___0;
#line 1438
    i___20 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 1442
  return;
}
}
#line 1447 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static void opj_j2k_read_float32_to_float(void const   *p_src_data___1 , void *p_dest_data___1 ,
                                          OPJ_UINT32 p_nb_elem___1 ) 
{ 
  OPJ_BYTE *l_src_data___1 ;
  OPJ_FLOAT32 *l_dest_data___1 ;
  OPJ_UINT32 i___21 ;
  OPJ_FLOAT32 l_temp___1 ;
  OPJ_FLOAT32 *__cil_tmp8___18 ;

  {
#line 1450
  l_src_data___1 = (OPJ_BYTE *)p_src_data___1;
#line 1451
  l_dest_data___1 = (OPJ_FLOAT32 *)p_dest_data___1;
#line 1455
  i___21 = (OPJ_UINT32 )0;
  {
#line 1455
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1455
    if (! (i___21 < p_nb_elem___1)) {
#line 1455
      goto while_break;
    }
    {
#line 1456
    opj_read_float_LE(l_src_data___1, & l_temp___1);
#line 1458
    l_src_data___1 += sizeof(OPJ_FLOAT32 );
#line 1460
    __cil_tmp8___18 = l_dest_data___1;
#line 1460
    l_dest_data___1 ++;
#line 1460
    *__cil_tmp8___18 = l_temp___1;
#line 1455
    i___21 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 1459
  return;
}
}
#line 1464 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static void opj_j2k_read_float64_to_float(void const   *p_src_data___2 , void *p_dest_data___2 ,
                                          OPJ_UINT32 p_nb_elem___2 ) 
{ 
  OPJ_BYTE *l_src_data___2 ;
  OPJ_FLOAT32 *l_dest_data___2 ;
  OPJ_UINT32 i___22 ;
  OPJ_FLOAT64 l_temp___2 ;
  OPJ_FLOAT32 *__cil_tmp8___19 ;

  {
#line 1467
  l_src_data___2 = (OPJ_BYTE *)p_src_data___2;
#line 1468
  l_dest_data___2 = (OPJ_FLOAT32 *)p_dest_data___2;
#line 1472
  i___22 = (OPJ_UINT32 )0;
  {
#line 1472
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1472
    if (! (i___22 < p_nb_elem___2)) {
#line 1472
      goto while_break;
    }
    {
#line 1473
    opj_read_double_LE(l_src_data___2, & l_temp___2);
#line 1475
    l_src_data___2 += sizeof(OPJ_FLOAT64 );
#line 1477
    __cil_tmp8___19 = l_dest_data___2;
#line 1477
    l_dest_data___2 ++;
#line 1477
    *__cil_tmp8___19 = (OPJ_FLOAT32 )l_temp___2;
#line 1472
    i___22 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 1476
  return;
}
}
#line 1481 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static void opj_j2k_read_int16_to_int32(void const   *p_src_data___3 , void *p_dest_data___3 ,
                                        OPJ_UINT32 p_nb_elem___3 ) 
{ 
  OPJ_BYTE *l_src_data___3 ;
  OPJ_INT32 *l_dest_data___3 ;
  OPJ_UINT32 i___23 ;
  OPJ_UINT32 l_temp___3 ;
  OPJ_INT32 *__cil_tmp8___20 ;

  {
#line 1484
  l_src_data___3 = (OPJ_BYTE *)p_src_data___3;
#line 1485
  l_dest_data___3 = (OPJ_INT32 *)p_dest_data___3;
#line 1489
  i___23 = (OPJ_UINT32 )0;
  {
#line 1489
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1489
    if (! (i___23 < p_nb_elem___3)) {
#line 1489
      goto while_break;
    }
    {
#line 1490
    opj_read_bytes_LE(l_src_data___3, & l_temp___3, (OPJ_UINT32 )2);
#line 1492
    l_src_data___3 += sizeof(OPJ_INT16 );
#line 1494
    __cil_tmp8___20 = l_dest_data___3;
#line 1494
    l_dest_data___3 ++;
#line 1494
    *__cil_tmp8___20 = (OPJ_INT32 )l_temp___3;
#line 1489
    i___23 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 1493
  return;
}
}
#line 1498 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static void opj_j2k_read_int32_to_int32(void const   *p_src_data___4 , void *p_dest_data___4 ,
                                        OPJ_UINT32 p_nb_elem___4 ) 
{ 
  OPJ_BYTE *l_src_data___4 ;
  OPJ_INT32 *l_dest_data___4 ;
  OPJ_UINT32 i___24 ;
  OPJ_UINT32 l_temp___4 ;
  OPJ_INT32 *__cil_tmp8___21 ;

  {
#line 1501
  l_src_data___4 = (OPJ_BYTE *)p_src_data___4;
#line 1502
  l_dest_data___4 = (OPJ_INT32 *)p_dest_data___4;
#line 1506
  i___24 = (OPJ_UINT32 )0;
  {
#line 1506
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1506
    if (! (i___24 < p_nb_elem___4)) {
#line 1506
      goto while_break;
    }
    {
#line 1507
    opj_read_bytes_LE(l_src_data___4, & l_temp___4, (OPJ_UINT32 )4);
#line 1509
    l_src_data___4 += sizeof(OPJ_INT32 );
#line 1511
    __cil_tmp8___21 = l_dest_data___4;
#line 1511
    l_dest_data___4 ++;
#line 1511
    *__cil_tmp8___21 = (OPJ_INT32 )l_temp___4;
#line 1506
    i___24 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 1510
  return;
}
}
#line 1515 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static void opj_j2k_read_float32_to_int32(void const   *p_src_data___5 , void *p_dest_data___5 ,
                                          OPJ_UINT32 p_nb_elem___5 ) 
{ 
  OPJ_BYTE *l_src_data___5 ;
  OPJ_INT32 *l_dest_data___5 ;
  OPJ_UINT32 i___25 ;
  OPJ_FLOAT32 l_temp___5 ;
  OPJ_INT32 *__cil_tmp8___22 ;

  {
#line 1518
  l_src_data___5 = (OPJ_BYTE *)p_src_data___5;
#line 1519
  l_dest_data___5 = (OPJ_INT32 *)p_dest_data___5;
#line 1523
  i___25 = (OPJ_UINT32 )0;
  {
#line 1523
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1523
    if (! (i___25 < p_nb_elem___5)) {
#line 1523
      goto while_break;
    }
    {
#line 1524
    opj_read_float_LE(l_src_data___5, & l_temp___5);
#line 1526
    l_src_data___5 += sizeof(OPJ_FLOAT32 );
#line 1528
    __cil_tmp8___22 = l_dest_data___5;
#line 1528
    l_dest_data___5 ++;
#line 1528
    *__cil_tmp8___22 = (OPJ_INT32 )l_temp___5;
#line 1523
    i___25 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 1527
  return;
}
}
#line 1532 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static void opj_j2k_read_float64_to_int32(void const   *p_src_data___6 , void *p_dest_data___6 ,
                                          OPJ_UINT32 p_nb_elem___6 ) 
{ 
  OPJ_BYTE *l_src_data___6 ;
  OPJ_INT32 *l_dest_data___6 ;
  OPJ_UINT32 i___26 ;
  OPJ_FLOAT64 l_temp___6 ;
  OPJ_INT32 *__cil_tmp8___23 ;

  {
#line 1535
  l_src_data___6 = (OPJ_BYTE *)p_src_data___6;
#line 1536
  l_dest_data___6 = (OPJ_INT32 *)p_dest_data___6;
#line 1540
  i___26 = (OPJ_UINT32 )0;
  {
#line 1540
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1540
    if (! (i___26 < p_nb_elem___6)) {
#line 1540
      goto while_break;
    }
    {
#line 1541
    opj_read_double_LE(l_src_data___6, & l_temp___6);
#line 1543
    l_src_data___6 += sizeof(OPJ_FLOAT64 );
#line 1545
    __cil_tmp8___23 = l_dest_data___6;
#line 1545
    l_dest_data___6 ++;
#line 1545
    *__cil_tmp8___23 = (OPJ_INT32 )l_temp___6;
#line 1540
    i___26 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 1544
  return;
}
}
#line 1549 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static void opj_j2k_write_float_to_int16(void const   *p_src_data___7 , void *p_dest_data___7 ,
                                         OPJ_UINT32 p_nb_elem___7 ) 
{ 
  OPJ_BYTE *l_dest_data___7 ;
  OPJ_FLOAT32 *l_src_data___7 ;
  OPJ_UINT32 i___27 ;
  OPJ_UINT32 l_temp___7 ;
  OPJ_FLOAT32 *__cil_tmp8___24 ;

  {
#line 1552
  l_dest_data___7 = (OPJ_BYTE *)p_dest_data___7;
#line 1553
  l_src_data___7 = (OPJ_FLOAT32 *)p_src_data___7;
#line 1557
  i___27 = (OPJ_UINT32 )0;
  {
#line 1557
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1557
    if (! (i___27 < p_nb_elem___7)) {
#line 1557
      goto while_break;
    }
    {
#line 1558
    __cil_tmp8___24 = l_src_data___7;
#line 1558
    l_src_data___7 ++;
#line 1558
    l_temp___7 = (OPJ_UINT32 )*__cil_tmp8___24;
#line 1560
    opj_write_bytes_LE(l_dest_data___7, l_temp___7, (OPJ_UINT32 )sizeof(OPJ_INT16 ));
#line 1562
    l_dest_data___7 += sizeof(OPJ_INT16 );
#line 1557
    i___27 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 1561
  return;
}
}
#line 1566 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static void opj_j2k_write_float_to_int32(void const   *p_src_data___8 , void *p_dest_data___8 ,
                                         OPJ_UINT32 p_nb_elem___8 ) 
{ 
  OPJ_BYTE *l_dest_data___8 ;
  OPJ_FLOAT32 *l_src_data___8 ;
  OPJ_UINT32 i___28 ;
  OPJ_UINT32 l_temp___8 ;
  OPJ_FLOAT32 *__cil_tmp8___25 ;

  {
#line 1569
  l_dest_data___8 = (OPJ_BYTE *)p_dest_data___8;
#line 1570
  l_src_data___8 = (OPJ_FLOAT32 *)p_src_data___8;
#line 1574
  i___28 = (OPJ_UINT32 )0;
  {
#line 1574
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1574
    if (! (i___28 < p_nb_elem___8)) {
#line 1574
      goto while_break;
    }
    {
#line 1575
    __cil_tmp8___25 = l_src_data___8;
#line 1575
    l_src_data___8 ++;
#line 1575
    l_temp___8 = (OPJ_UINT32 )*__cil_tmp8___25;
#line 1577
    opj_write_bytes_LE(l_dest_data___8, l_temp___8, (OPJ_UINT32 )sizeof(OPJ_INT32 ));
#line 1579
    l_dest_data___8 += sizeof(OPJ_INT32 );
#line 1574
    i___28 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 1578
  return;
}
}
#line 1583 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static void opj_j2k_write_float_to_float(void const   *p_src_data___9 , void *p_dest_data___9 ,
                                         OPJ_UINT32 p_nb_elem___9 ) 
{ 
  OPJ_BYTE *l_dest_data___9 ;
  OPJ_FLOAT32 *l_src_data___9 ;
  OPJ_UINT32 i___29 ;
  OPJ_FLOAT32 l_temp___9 ;
  OPJ_FLOAT32 *__cil_tmp8___26 ;

  {
#line 1586
  l_dest_data___9 = (OPJ_BYTE *)p_dest_data___9;
#line 1587
  l_src_data___9 = (OPJ_FLOAT32 *)p_src_data___9;
#line 1591
  i___29 = (OPJ_UINT32 )0;
  {
#line 1591
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1591
    if (! (i___29 < p_nb_elem___9)) {
#line 1591
      goto while_break;
    }
    {
#line 1592
    __cil_tmp8___26 = l_src_data___9;
#line 1592
    l_src_data___9 ++;
#line 1592
    l_temp___9 = *__cil_tmp8___26;
#line 1594
    opj_write_float_LE(l_dest_data___9, l_temp___9);
#line 1596
    l_dest_data___9 += sizeof(OPJ_FLOAT32 );
#line 1591
    i___29 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 1595
  return;
}
}
#line 1600 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static void opj_j2k_write_float_to_float64(void const   *p_src_data___10 , void *p_dest_data___10 ,
                                           OPJ_UINT32 p_nb_elem___10 ) 
{ 
  OPJ_BYTE *l_dest_data___10 ;
  OPJ_FLOAT32 *l_src_data___10 ;
  OPJ_UINT32 i___30 ;
  OPJ_FLOAT64 l_temp___10 ;
  OPJ_FLOAT32 *__cil_tmp8___27 ;

  {
#line 1603
  l_dest_data___10 = (OPJ_BYTE *)p_dest_data___10;
#line 1604
  l_src_data___10 = (OPJ_FLOAT32 *)p_src_data___10;
#line 1608
  i___30 = (OPJ_UINT32 )0;
  {
#line 1608
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1608
    if (! (i___30 < p_nb_elem___10)) {
#line 1608
      goto while_break;
    }
    {
#line 1609
    __cil_tmp8___27 = l_src_data___10;
#line 1609
    l_src_data___10 ++;
#line 1609
    l_temp___10 = (OPJ_FLOAT64 )*__cil_tmp8___27;
#line 1611
    opj_write_double_LE(l_dest_data___10, l_temp___10);
#line 1613
    l_dest_data___10 += sizeof(OPJ_FLOAT64 );
#line 1608
    i___30 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 1612
  return;
}
}
#line 1617 "/root/patron-new/39/src/lib/openjp2/j2k.c"
char const   *opj_j2k_convert_progression_order(OPJ_PROG_ORDER prg_order ) 
{ 
  j2k_prog_order_t *po ;

  {
#line 1620
  po = j2k_prog_order_list;
  {
#line 1620
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1620
    if (! ((int )po->enum_prog != -1)) {
#line 1620
      goto while_break;
    }
#line 1621
    if ((int )po->enum_prog == (int )prg_order) {
#line 1622
      return ((char const   *)(po->str_prog));
    }
#line 1620
    po ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 1625
  return ((char const   *)(po->str_prog));
}
}
#line 1628 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_check_poc_val(opj_poc_t *p_pocs , OPJ_UINT32 tileno , OPJ_UINT32 p_nb_pocs ,
                                      OPJ_UINT32 p_nb_resolutions , OPJ_UINT32 p_num_comps ,
                                      OPJ_UINT32 p_num_layers , opj_event_mgr_t *p_manager___42 ) 
{ 
  OPJ_UINT32 *packet_array ;
  OPJ_UINT32 index___0 ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 compno ;
  OPJ_UINT32 layno ;
  OPJ_UINT32 i___31 ;
  OPJ_UINT32 step_c ;
  OPJ_UINT32 step_r ;
  OPJ_UINT32 step_l ;
  OPJ_BOOL loss ;
  void *__cil_tmp19___3 ;
  opj_poc_t *poc ;
  OPJ_UINT32 __cil_tmp21___1 ;
  OPJ_UINT32 res_index ;
  OPJ_UINT32 __cil_tmp23___1 ;
  OPJ_UINT32 layno0 ;
  OPJ_UINT32 comp_index ;
  OPJ_UINT32 __cil_tmp26 ;

  {
  {
#line 1639
  step_c = (OPJ_UINT32 )1;
#line 1640
  step_r = p_num_comps * step_c;
#line 1641
  step_l = p_nb_resolutions * step_r;
#line 1642
  loss = 0;
#line 1646
  __cil_tmp19___3 = opj_calloc((size_t )(step_l * p_num_layers), sizeof(OPJ_UINT32 ));
#line 1646
  packet_array = (OPJ_UINT32 *)__cil_tmp19___3;
  }
#line 1648
  if ((unsigned long )packet_array == (unsigned long )((OPJ_UINT32 *)0)) {
    {
#line 1649
    opj_event_msg(p_manager___42, 1, "Not enough memory for checking the poc values.\n");
    }
#line 1651
    return (0);
  }
#line 1655
  i___31 = (OPJ_UINT32 )0;
  {
#line 1655
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1655
    if (! (i___31 < p_nb_pocs)) {
#line 1655
      goto while_break;
    }
#line 1656
    poc = p_pocs + i___31;
#line 1657
    if (tileno + 1U == poc->tile) {
#line 1658
      index___0 = step_r * poc->resno0;
#line 1661
      resno = poc->resno0;
      {
#line 1661
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 1661
        if (! (resno < __cil_tmp21___1)) {
#line 1661
          goto while_break___0;
        }
#line 1663
        res_index = index___0 + poc->compno0 * step_c;
#line 1666
        compno = poc->compno0;
        {
#line 1666
        while (1) {
          while_continue___1: /* CIL Label */ ;

#line 1666
          if (! (compno < __cil_tmp23___1)) {
#line 1666
            goto while_break___1;
          }
#line 1669
          layno0 = (OPJ_UINT32 )0;
#line 1670
          comp_index = res_index + layno0 * step_l;
#line 1673
          layno = layno0;
          {
#line 1673
          while (1) {
            while_continue___2: /* CIL Label */ ;

#line 1673
            if (! (layno < __cil_tmp26)) {
#line 1673
              goto while_break___2;
            }
#line 1675
            *(packet_array + comp_index) = (OPJ_UINT32 )1;
#line 1676
            comp_index += step_l;
#line 1674
            layno ++;
          }
          while_break___9: /* CIL Label */ ;
          }

          while_break___2: 
#line 1679
          res_index += step_c;
#line 1667
          compno ++;
        }
        while_break___8: /* CIL Label */ ;
        }

        while_break___1: 
#line 1682
        index___0 += step_r;
#line 1662
        resno ++;
      }
      while_break___7: /* CIL Label */ ;
      }

      while_break___0: ;
    }
#line 1655
    i___31 ++;
  }
  while_break___6: /* CIL Label */ ;
  }

  while_break: 
#line 1687
  index___0 = (OPJ_UINT32 )0;
#line 1688
  layno = (OPJ_UINT32 )0;
  {
#line 1688
  while (1) {
    while_continue___3: /* CIL Label */ ;

#line 1688
    if (! (layno < p_num_layers)) {
#line 1688
      goto while_break___3;
    }
#line 1689
    resno = (OPJ_UINT32 )0;
    {
#line 1689
    while (1) {
      while_continue___4: /* CIL Label */ ;

#line 1689
      if (! (resno < p_nb_resolutions)) {
#line 1689
        goto while_break___4;
      }
#line 1690
      compno = (OPJ_UINT32 )0;
      {
#line 1690
      while (1) {
        while_continue___5: /* CIL Label */ ;

#line 1690
        if (! (compno < p_num_comps)) {
#line 1690
          goto while_break___5;
        }
#line 1691
        loss |= *(packet_array + index___0) != 1U;
#line 1699
        index___0 += step_c;
#line 1690
        compno ++;
      }
      while_break___12: /* CIL Label */ ;
      }

      while_break___5: 
#line 1689
      resno ++;
    }
    while_break___11: /* CIL Label */ ;
    }

    while_break___4: 
#line 1688
    layno ++;
  }
  while_break___10: /* CIL Label */ ;
  }

  while_break___3: ;
#line 1704
  if (loss) {
    {
#line 1705
    opj_event_msg(p_manager___42, 1, "Missing packets possible loss of data\n");
    }
  }
  {
#line 1708
  opj_free((void *)packet_array);
  }
#line 1710
  return (! loss);
}
}
#line 1715 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_UINT32 opj_j2k_get_num_tp(opj_cp_t *cp , OPJ_UINT32 pino , OPJ_UINT32 tileno___0 ) 
{ 
  OPJ_CHAR *prog ;
  OPJ_INT32 i___32 ;
  OPJ_UINT32 tpnum ;
  opj_tcp_t *tcp ;
  opj_poc_t *l_current_poc ;
  char const   *tmp___136 ;

  {
  {
#line 1718
  prog = (OPJ_CHAR *)0;
#line 1720
  tpnum = (OPJ_UINT32 )1;
#line 1721
  tcp = (opj_tcp_t *)0;
#line 1722
  l_current_poc = (opj_poc_t *)0;
#line 1729
  tcp = cp->tcps + tileno___0;
#line 1732
  l_current_poc = & tcp->pocs[pino];
#line 1736
  tmp___136 = opj_j2k_convert_progression_order(tcp->prg);
#line 1736
  prog = (OPJ_CHAR *)tmp___136;
  }
#line 1739
  if ((int )cp->m_specific_param.m_enc.m_tp_on == 1) {
#line 1740
    i___32 = 0;
    {
#line 1740
    while (1) {
      while_continue: /* CIL Label */ ;

#line 1740
      if (! (i___32 < 4)) {
#line 1740
        goto while_break;
      }
#line 1743
      if ((int )*(prog + i___32) == 67) {
#line 1743
        goto case_67;
      }
#line 1747
      if ((int )*(prog + i___32) == 82) {
#line 1747
        goto case_82;
      }
#line 1751
      if ((int )*(prog + i___32) == 80) {
#line 1751
        goto case_80;
      }
#line 1755
      if ((int )*(prog + i___32) == 76) {
#line 1755
        goto case_76;
      }
#line 1741
      goto switch_break;
      case_67: 
#line 1744
      tpnum *= l_current_poc->compE;
#line 1745
      goto switch_break;
      case_82: 
#line 1748
      tpnum *= l_current_poc->resE;
#line 1749
      goto switch_break;
      case_80: 
#line 1752
      tpnum *= l_current_poc->prcE;
#line 1753
      goto switch_break;
      case_76: 
#line 1756
      tpnum *= l_current_poc->layE;
#line 1757
      goto switch_break;
      switch_break: ;
#line 1760
      if ((int )cp->m_specific_param.m_enc.m_tp_flag == (int )*(prog + i___32)) {
#line 1761
        cp->m_specific_param.m_enc.m_tp_pos = i___32;
#line 1762
        goto while_break;
      }
#line 1740
      i___32 ++;
    }
    while_break___0: /* CIL Label */ ;
    }

    while_break: ;
  } else {
#line 1766
    tpnum = (OPJ_UINT32 )1;
  }
#line 1769
  return (tpnum);
}
}
#line 1772 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_calculate_tp(opj_j2k_t *p_j2k___0 , opj_cp_t *cp___0 , OPJ_UINT32 *p_nb_tiles ,
                                     opj_image_t *image___3 , opj_event_mgr_t *p_manager___43 ) 
{ 
  OPJ_UINT32 pino___0 ;
  OPJ_UINT32 tileno___1 ;
  OPJ_UINT32 l_nb_tiles ;
  opj_tcp_t *tcp___0 ;
  OPJ_UINT32 cur_totnum_tp ;
  OPJ_UINT32 tp_num ;
  OPJ_UINT32 __cil_tmp17___4 ;

  {
#line 1793
  l_nb_tiles = cp___0->tw * cp___0->th;
#line 1794
  *p_nb_tiles = (OPJ_UINT32 )0;
#line 1795
  tcp___0 = cp___0->tcps;
#line 1832
  tileno___1 = (OPJ_UINT32 )0;
  {
#line 1832
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1832
    if (! (tileno___1 < l_nb_tiles)) {
#line 1832
      goto while_break;
    }
    {
#line 1833
    cur_totnum_tp = (OPJ_UINT32 )0;
#line 1835
    opj_pi_update_encoding_parameters(image___3, cp___0, tileno___1);
#line 1837
    pino___0 = (OPJ_UINT32 )0;
    }
    {
#line 1837
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1837
      if (! (pino___0 <= tcp___0->numpocs)) {
#line 1837
        goto while_break___0;
      }
      {
#line 1838
      __cil_tmp17___4 = opj_j2k_get_num_tp(cp___0, pino___0, tileno___1);
#line 1838
      tp_num = __cil_tmp17___4;
#line 1840
      *p_nb_tiles += tp_num;
#line 1842
      cur_totnum_tp += tp_num;
#line 1837
      pino___0 ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }

    while_break___0: 
#line 1844
    tcp___0->m_nb_tile_parts = cur_totnum_tp;
#line 1846
    tcp___0 ++;
#line 1832
    tileno___1 ++;
  }
  while_break___1: /* CIL Label */ ;
  }

  while_break: ;
#line 1850
  return (1);
}
}
#line 1853 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_soc(opj_j2k_t *p_j2k___1 , opj_stream_private_t *p_stream___15 ,
                                  opj_event_mgr_t *p_manager___44 ) 
{ 
  OPJ_BYTE *l_start_stream ;
  OPJ_SIZE_T __cil_tmp8___28 ;

  {
  {
#line 1858
  l_start_stream = (OPJ_BYTE *)0;
#line 1865
  l_start_stream = p_j2k___1->m_specific_param.m_encoder.m_header_tile_data;
#line 1868
  opj_write_bytes_LE(l_start_stream, (OPJ_UINT32 )65359, (OPJ_UINT32 )2);
#line 1870
  __cil_tmp8___28 = opj_stream_write_data(p_stream___15, l_start_stream, (OPJ_SIZE_T )2,
                                          p_manager___44);
  }
#line 1870
  if (__cil_tmp8___28 != 2UL) {
#line 1871
    return (0);
  }
#line 1884
  return (1);
}
}
#line 1893 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_soc(opj_j2k_t *p_j2k___2 , opj_stream_private_t *p_stream___16 ,
                                 opj_event_mgr_t *p_manager___45 ) 
{ 
  OPJ_BYTE l_data[2] ;
  OPJ_UINT32 l_marker ;
  OPJ_SIZE_T __cil_tmp9___9 ;
  OPJ_OFF_T __cil_tmp10___4 ;
  OPJ_BOOL __cil_tmp11___4 ;

  {
  {
#line 1906
  __cil_tmp9___9 = opj_stream_read_data(p_stream___16, l_data, (OPJ_SIZE_T )2, p_manager___45);
  }
#line 1906
  if (__cil_tmp9___9 != 2UL) {
#line 1907
    return (0);
  }
  {
#line 1910
  opj_read_bytes_LE(l_data, & l_marker, (OPJ_UINT32 )2);
  }
#line 1911
  if (l_marker != 65359U) {
#line 1912
    return (0);
  }
  {
#line 1916
  p_j2k___2->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )2;
#line 1919
  __cil_tmp10___4 = opj_stream_tell(p_stream___16);
#line 1919
  (p_j2k___2->cstr_index)->main_head_start = __cil_tmp10___4 - 2L;
#line 1921
  opj_event_msg(p_manager___45, 4, "Start to read j2k main header (%ld).\n\314\216\005]U",
                (p_j2k___2->cstr_index)->main_head_start);
#line 1926
  __cil_tmp11___4 = opj_j2k_add_mhmarker(p_j2k___2->cstr_index, (OPJ_UINT32 )65359,
                                         (p_j2k___2->cstr_index)->main_head_start,
                                         (OPJ_UINT32 )2);
  }
#line 1926
  if (0 == __cil_tmp11___4) {
    {
#line 1928
    opj_event_msg(p_manager___45, 1, "Not enough memory to add mh marker\n\005]U");
    }
#line 1929
    return (0);
  }
#line 1931
  return (1);
}
}
#line 1934 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_siz(opj_j2k_t *p_j2k___3 , opj_stream_private_t *p_stream___17 ,
                                  opj_event_mgr_t *p_manager___46 ) 
{ 
  OPJ_UINT32 i___33 ;
  OPJ_UINT32 l_size_len ;
  OPJ_BYTE *l_current_ptr ;
  opj_image_t *l_image ;
  opj_cp_t *cp___1 ;
  opj_image_comp_t *l_img_comp ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp14___7 ;
  OPJ_SIZE_T __cil_tmp15___4 ;

  {
#line 1941
  l_image = (opj_image_t *)0;
#line 1942
  cp___1 = (opj_cp_t *)0;
#line 1943
  l_img_comp = (opj_image_comp_t *)0;
#line 1950
  l_image = p_j2k___3->m_private_image;
#line 1951
  cp___1 = & p_j2k___3->m_cp;
#line 1952
  l_size_len = 40U + 3U * l_image->numcomps;
#line 1953
  l_img_comp = l_image->comps;
#line 1955
  if (l_size_len > p_j2k___3->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 1957
    __cil_tmp14___7 = opj_realloc((void *)p_j2k___3->m_specific_param.m_encoder.m_header_tile_data,
                                  (size_t )l_size_len);
#line 1957
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp14___7;
    }
#line 1959
    if (! new_header_tile_data) {
      {
#line 1960
      opj_free((void *)p_j2k___3->m_specific_param.m_encoder.m_header_tile_data);
#line 1961
      p_j2k___3->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 1962
      p_j2k___3->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 1963
      opj_event_msg(p_manager___46, 1, "Not enough memory for the SIZ marker\nU");
      }
#line 1964
      return (0);
    }
#line 1966
    p_j2k___3->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 1967
    p_j2k___3->m_specific_param.m_encoder.m_header_tile_data_size = l_size_len;
  }
  {
#line 1970
  l_current_ptr = p_j2k___3->m_specific_param.m_encoder.m_header_tile_data;
#line 1973
  opj_write_bytes_LE(l_current_ptr, (OPJ_UINT32 )65361, (OPJ_UINT32 )2);
#line 1974
  l_current_ptr += 2;
#line 1976
  opj_write_bytes_LE(l_current_ptr, l_size_len - 2U, (OPJ_UINT32 )2);
#line 1977
  l_current_ptr += 2;
#line 1979
  opj_write_bytes_LE(l_current_ptr, (OPJ_UINT32 )cp___1->rsiz, (OPJ_UINT32 )2);
#line 1980
  l_current_ptr += 2;
#line 1982
  opj_write_bytes_LE(l_current_ptr, l_image->x1, (OPJ_UINT32 )4);
#line 1983
  l_current_ptr += 4;
#line 1985
  opj_write_bytes_LE(l_current_ptr, l_image->y1, (OPJ_UINT32 )4);
#line 1986
  l_current_ptr += 4;
#line 1988
  opj_write_bytes_LE(l_current_ptr, l_image->x0, (OPJ_UINT32 )4);
#line 1989
  l_current_ptr += 4;
#line 1991
  opj_write_bytes_LE(l_current_ptr, l_image->y0, (OPJ_UINT32 )4);
#line 1992
  l_current_ptr += 4;
#line 1994
  opj_write_bytes_LE(l_current_ptr, cp___1->tdx, (OPJ_UINT32 )4);
#line 1995
  l_current_ptr += 4;
#line 1997
  opj_write_bytes_LE(l_current_ptr, cp___1->tdy, (OPJ_UINT32 )4);
#line 1998
  l_current_ptr += 4;
#line 2000
  opj_write_bytes_LE(l_current_ptr, cp___1->tx0, (OPJ_UINT32 )4);
#line 2001
  l_current_ptr += 4;
#line 2003
  opj_write_bytes_LE(l_current_ptr, cp___1->ty0, (OPJ_UINT32 )4);
#line 2004
  l_current_ptr += 4;
#line 2006
  opj_write_bytes_LE(l_current_ptr, l_image->numcomps, (OPJ_UINT32 )2);
#line 2007
  l_current_ptr += 2;
#line 2009
  i___33 = (OPJ_UINT32 )0;
  }
  {
#line 2009
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2009
    if (! (i___33 < l_image->numcomps)) {
#line 2009
      goto while_break;
    }
    {
#line 2011
    opj_write_bytes_LE(l_current_ptr, (l_img_comp->prec - 1U) + (l_img_comp->sgnd << 7),
                       (OPJ_UINT32 )1);
#line 2013
    l_current_ptr ++;
#line 2015
    opj_write_bytes_LE(l_current_ptr, l_img_comp->dx, (OPJ_UINT32 )1);
#line 2016
    l_current_ptr ++;
#line 2018
    opj_write_bytes_LE(l_current_ptr, l_img_comp->dy, (OPJ_UINT32 )1);
#line 2019
    l_current_ptr ++;
#line 2021
    l_img_comp ++;
#line 2009
    i___33 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: 
  {
#line 2024
  __cil_tmp15___4 = opj_stream_write_data(p_stream___17, p_j2k___3->m_specific_param.m_encoder.m_header_tile_data,
                                          (OPJ_SIZE_T )l_size_len, p_manager___46);
  }
#line 2024
  if (__cil_tmp15___4 != (unsigned long )l_size_len) {
#line 2027
    return (0);
  }
#line 2030
  return (1);
}
}
#line 2040 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_siz(opj_j2k_t *p_j2k___4 , OPJ_BYTE *p_header_data___2 ,
                                 OPJ_UINT32 p_header_size___2 , opj_event_mgr_t *p_manager___47 ) 
{ 
  OPJ_UINT32 i___34 ;
  OPJ_UINT32 l_nb_comp ;
  OPJ_UINT32 l_nb_comp_remain ;
  OPJ_UINT32 l_remaining_size ;
  OPJ_UINT32 l_nb_tiles___0 ;
  OPJ_UINT32 l_tmp ;
  OPJ_UINT32 l_tx1 ;
  OPJ_UINT32 l_ty1 ;
  OPJ_UINT32 l_prec0 ;
  OPJ_UINT32 l_sgnd0 ;
  opj_image_t *l_image___0 ;
  opj_cp_t *l_cp ;
  opj_image_comp_t *l_img_comp___0 ;
  opj_tcp_t *l_current_tile_param ;
  OPJ_UINT32 siz_w ;
  OPJ_UINT32 siz_h ;
  void *__cil_tmp26___0 ;
  OPJ_UINT32 tmp___154 ;
  OPJ_INT32 __cil_tmp28 ;
  OPJ_INT32 __cil_tmp29 ;
  OPJ_INT32 __cil_tmp30 ;
  OPJ_INT32 __cil_tmp31 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;
  void *__cil_tmp34 ;
  void *__cil_tmp35 ;
  void *__cil_tmp36 ;

  {
#line 2053
  l_image___0 = (opj_image_t *)0;
#line 2054
  l_cp = (opj_cp_t *)0;
#line 2055
  l_img_comp___0 = (opj_image_comp_t *)0;
#line 2056
  l_current_tile_param = (opj_tcp_t *)0;
#line 2063
  l_image___0 = p_j2k___4->m_private_image;
#line 2064
  l_cp = & p_j2k___4->m_cp;
#line 2067
  if (p_header_size___2 < 36U) {
    {
#line 2068
    opj_event_msg(p_manager___47, 1, "Error with SIZ marker size\n");
    }
#line 2069
    return (0);
  }
#line 2072
  l_remaining_size = p_header_size___2 - 36U;
#line 2073
  l_nb_comp = l_remaining_size / 3U;
#line 2074
  l_nb_comp_remain = l_remaining_size % 3U;
#line 2075
  if (l_nb_comp_remain != 0U) {
    {
#line 2076
    opj_event_msg(p_manager___47, 1, "Error with SIZ marker size\n");
    }
#line 2077
    return (0);
  }
  {
#line 2080
  opj_read_bytes_LE(p_header_data___2, & l_tmp, (OPJ_UINT32 )2);
#line 2082
  p_header_data___2 += 2;
#line 2083
  l_cp->rsiz = (OPJ_UINT16 )l_tmp;
#line 2084
  opj_read_bytes_LE(p_header_data___2, & l_image___0->x1, (OPJ_UINT32 )4);
#line 2085
  p_header_data___2 += 4;
#line 2086
  opj_read_bytes_LE(p_header_data___2, & l_image___0->y1, (OPJ_UINT32 )4);
#line 2087
  p_header_data___2 += 4;
#line 2088
  opj_read_bytes_LE(p_header_data___2, & l_image___0->x0, (OPJ_UINT32 )4);
#line 2089
  p_header_data___2 += 4;
#line 2090
  opj_read_bytes_LE(p_header_data___2, & l_image___0->y0, (OPJ_UINT32 )4);
#line 2091
  p_header_data___2 += 4;
#line 2092
  opj_read_bytes_LE(p_header_data___2, & l_cp->tdx, (OPJ_UINT32 )4);
#line 2094
  p_header_data___2 += 4;
#line 2095
  opj_read_bytes_LE(p_header_data___2, & l_cp->tdy, (OPJ_UINT32 )4);
#line 2097
  p_header_data___2 += 4;
#line 2098
  opj_read_bytes_LE(p_header_data___2, & l_cp->tx0, (OPJ_UINT32 )4);
#line 2100
  p_header_data___2 += 4;
#line 2101
  opj_read_bytes_LE(p_header_data___2, & l_cp->ty0, (OPJ_UINT32 )4);
#line 2103
  p_header_data___2 += 4;
#line 2104
  opj_read_bytes_LE(p_header_data___2, & l_tmp, (OPJ_UINT32 )2);
#line 2106
  p_header_data___2 += 2;
  }
#line 2107
  if (l_tmp < 16385U) {
#line 2108
    l_image___0->numcomps = (OPJ_UINT32 )((OPJ_UINT16 )l_tmp);
  } else {
    {
#line 2110
    opj_event_msg(p_manager___47, 1, "Error with SIZ marker: number of component is illegal -> %d\n",
                  l_tmp);
    }
#line 2112
    return (0);
  }
#line 2115
  if (l_image___0->numcomps != l_nb_comp) {
    {
#line 2116
    opj_event_msg(p_manager___47, 1, "Error with SIZ marker: number of component is not compatible with the remaining number of parameters ( %d vs %d)\n",
                  l_image___0->numcomps, l_nb_comp);
    }
#line 2119
    return (0);
  }
#line 2124
  if (l_image___0->x0 >= l_image___0->x1) {
    {
#line 2125
    opj_event_msg(p_manager___47, 1, "Error with SIZ marker: negative or zero image size (%ld x %ld)\n",
                  (OPJ_INT64 )l_image___0->x1 - (long )l_image___0->x0, (OPJ_INT64 )l_image___0->y1 - (long )l_image___0->y0);
    }
#line 2129
    return (0);
  } else
#line 2124
  if (l_image___0->y0 >= l_image___0->y1) {
    {
#line 2125
    opj_event_msg(p_manager___47, 1, "Error with SIZ marker: negative or zero image size (%ld x %ld)\n",
                  (OPJ_INT64 )l_image___0->x1 - (long )l_image___0->x0, (OPJ_INT64 )l_image___0->y1 - (long )l_image___0->y0);
    }
#line 2129
    return (0);
  }
#line 2132
  if (l_cp->tdx == 0U) {
    {
#line 2133
    opj_event_msg(p_manager___47, 1, "Error with SIZ marker: invalid tile size (tdx: %d, tdy: %d)\n]U",
                  l_cp->tdx, l_cp->tdy);
    }
#line 2136
    return (0);
  } else
#line 2132
  if (l_cp->tdy == 0U) {
    {
#line 2133
    opj_event_msg(p_manager___47, 1, "Error with SIZ marker: invalid tile size (tdx: %d, tdy: %d)\n]U",
                  l_cp->tdx, l_cp->tdy);
    }
#line 2136
    return (0);
  }
  {
#line 2140
  l_tx1 = opj_uint_adds(l_cp->tx0, l_cp->tdx);
#line 2141
  l_ty1 = opj_uint_adds(l_cp->ty0, l_cp->tdy);
  }
#line 2142
  if (l_cp->tx0 > l_image___0->x0) {
    {
#line 2144
    opj_event_msg(p_manager___47, 1, "Error with SIZ marker: illegal tile offset\n");
    }
#line 2146
    return (0);
  } else
#line 2142
  if (l_cp->ty0 > l_image___0->y0) {
    {
#line 2144
    opj_event_msg(p_manager___47, 1, "Error with SIZ marker: illegal tile offset\n");
    }
#line 2146
    return (0);
  } else
#line 2142
  if (l_tx1 <= l_image___0->x0) {
    {
#line 2144
    opj_event_msg(p_manager___47, 1, "Error with SIZ marker: illegal tile offset\n");
    }
#line 2146
    return (0);
  } else
#line 2142
  if (l_ty1 <= l_image___0->y0) {
    {
#line 2144
    opj_event_msg(p_manager___47, 1, "Error with SIZ marker: illegal tile offset\n");
    }
#line 2146
    return (0);
  }
#line 2148
  if (! p_j2k___4->dump_state) {
#line 2151
    siz_w = l_image___0->x1 - l_image___0->x0;
#line 2152
    siz_h = l_image___0->y1 - l_image___0->y0;
#line 2154
    if (p_j2k___4->ihdr_w > 0U) {
#line 2154
      if (p_j2k___4->ihdr_h > 0U) {
#line 2154
        if (p_j2k___4->ihdr_w != siz_w) {
          {
#line 2156
          opj_event_msg(p_manager___47, 1, "Error with SIZ marker: IHDR w(%u) h(%u) vs. SIZ w(%u) h(%u)\n",
                        p_j2k___4->ihdr_w, p_j2k___4->ihdr_h, siz_w, siz_h);
          }
#line 2159
          return (0);
        } else
#line 2154
        if (p_j2k___4->ihdr_h != siz_h) {
          {
#line 2156
          opj_event_msg(p_manager___47, 1, "Error with SIZ marker: IHDR w(%u) h(%u) vs. SIZ w(%u) h(%u)\n",
                        p_j2k___4->ihdr_w, p_j2k___4->ihdr_h, siz_w, siz_h);
          }
#line 2159
          return (0);
        }
      }
    }
  }
  {
#line 2205
  __cil_tmp26___0 = opj_calloc((size_t )l_image___0->numcomps, sizeof(opj_image_comp_t ));
#line 2205
  l_image___0->comps = (opj_image_comp_t *)__cil_tmp26___0;
  }
#line 2207
  if ((unsigned long )l_image___0->comps == (unsigned long )((opj_image_comp_t *)0)) {
    {
#line 2208
    l_image___0->numcomps = (OPJ_UINT32 )0;
#line 2209
    opj_event_msg(p_manager___47, 1, "Not enough memory to take in charge SIZ marker\n");
    }
#line 2211
    return (0);
  }
#line 2214
  l_img_comp___0 = l_image___0->comps;
#line 2216
  l_prec0 = (OPJ_UINT32 )0;
#line 2217
  l_sgnd0 = (OPJ_UINT32 )0;
#line 2219
  i___34 = (OPJ_UINT32 )0;
  {
#line 2219
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2219
    if (! (i___34 < l_image___0->numcomps)) {
#line 2219
      goto while_break;
    }
    {
#line 2221
    opj_read_bytes_LE(p_header_data___2, & tmp___154, (OPJ_UINT32 )1);
#line 2222
    p_header_data___2 ++;
#line 2223
    l_img_comp___0->prec = (tmp___154 & 127U) + 1U;
#line 2224
    l_img_comp___0->sgnd = tmp___154 >> 7;
    }
#line 2226
    if (p_j2k___4->dump_state == 0U) {
#line 2227
      if (i___34 == 0U) {
#line 2228
        l_prec0 = l_img_comp___0->prec;
#line 2229
        l_sgnd0 = l_img_comp___0->sgnd;
      } else
#line 2230
      if (! l_cp->allow_different_bit_depth_sign) {
#line 2230
        if (l_img_comp___0->prec != l_prec0) {
          {
#line 2232
          opj_event_msg(p_manager___47, 2, "Despite JP2 BPC!=255, precision and/or sgnd values for comp[%d] is different than comp[0]:\n        [0] prec(%d) sgnd(%d) [%d] prec(%d) sgnd(%d)\n",
                        i___34, l_prec0, l_sgnd0, i___34, l_img_comp___0->prec, l_img_comp___0->sgnd);
          }
        } else
#line 2230
        if (l_img_comp___0->sgnd != l_sgnd0) {
          {
#line 2232
          opj_event_msg(p_manager___47, 2, "Despite JP2 BPC!=255, precision and/or sgnd values for comp[%d] is different than comp[0]:\n        [0] prec(%d) sgnd(%d) [%d] prec(%d) sgnd(%d)\n",
                        i___34, l_prec0, l_sgnd0, i___34, l_img_comp___0->prec, l_img_comp___0->sgnd);
          }
        }
      }
    }
    {
#line 2239
    opj_read_bytes_LE(p_header_data___2, & tmp___154, (OPJ_UINT32 )1);
#line 2240
    p_header_data___2 ++;
#line 2241
    l_img_comp___0->dx = tmp___154;
#line 2242
    opj_read_bytes_LE(p_header_data___2, & tmp___154, (OPJ_UINT32 )1);
#line 2243
    p_header_data___2 ++;
#line 2244
    l_img_comp___0->dy = tmp___154;
    }
#line 2245
    if (l_img_comp___0->dx < 1U) {
      {
#line 2247
      opj_event_msg(p_manager___47, 1, "Invalid values for comp = %d : dx=%u dy=%u (should be between 1 and 255 according to the JPEG2000 norm)\n\230\001",
                    i___34, l_img_comp___0->dx, l_img_comp___0->dy);
      }
#line 2250
      return (0);
    } else
#line 2245
    if (l_img_comp___0->dx > 255U) {
      {
#line 2247
      opj_event_msg(p_manager___47, 1, "Invalid values for comp = %d : dx=%u dy=%u (should be between 1 and 255 according to the JPEG2000 norm)\n\230\001",
                    i___34, l_img_comp___0->dx, l_img_comp___0->dy);
      }
#line 2250
      return (0);
    } else
#line 2245
    if (l_img_comp___0->dy < 1U) {
      {
#line 2247
      opj_event_msg(p_manager___47, 1, "Invalid values for comp = %d : dx=%u dy=%u (should be between 1 and 255 according to the JPEG2000 norm)\n\230\001",
                    i___34, l_img_comp___0->dx, l_img_comp___0->dy);
      }
#line 2250
      return (0);
    } else
#line 2245
    if (l_img_comp___0->dy > 255U) {
      {
#line 2247
      opj_event_msg(p_manager___47, 1, "Invalid values for comp = %d : dx=%u dy=%u (should be between 1 and 255 according to the JPEG2000 norm)\n\230\001",
                    i___34, l_img_comp___0->dx, l_img_comp___0->dy);
      }
#line 2250
      return (0);
    }
#line 2255
    if (l_img_comp___0->prec > 31U) {
      {
#line 2256
      opj_event_msg(p_manager___47, 1, "Invalid values for comp = %d : prec=%u (should be between 1 and 38 according to the JPEG2000 norm. OpenJpeg only supports up to 31)\n",
                    i___34, l_img_comp___0->prec);
      }
#line 2259
      return (0);
    }
#line 2290
    l_img_comp___0->resno_decoded = (OPJ_UINT32 )0;
#line 2292
    l_img_comp___0->factor = l_cp->m_specific_param.m_dec.m_reduce;
#line 2294
    l_img_comp___0 ++;
#line 2219
    i___34 ++;
  }
  while_break___2: /* CIL Label */ ;
  }

  while_break: ;
#line 2297
  if (l_cp->tdx == 0U) {
#line 2298
    return (0);
  } else
#line 2297
  if (l_cp->tdy == 0U) {
#line 2298
    return (0);
  }
  {
#line 2302
  __cil_tmp28 = opj_int_ceildiv((OPJ_INT32 )(l_image___0->x1 - l_cp->tx0), (OPJ_INT32 )l_cp->tdx);
#line 2302
  l_cp->tw = (OPJ_UINT32 )__cil_tmp28;
#line 2304
  __cil_tmp29 = opj_int_ceildiv((OPJ_INT32 )(l_image___0->y1 - l_cp->ty0), (OPJ_INT32 )l_cp->tdy);
#line 2304
  l_cp->th = (OPJ_UINT32 )__cil_tmp29;
  }
#line 2308
  if (l_cp->tw == 0U) {
    {
#line 2309
    opj_event_msg(p_manager___47, 1, "Invalid number of tiles : %u x %u (maximum fixed by jpeg2000 norm is 65535 tiles)\n",
                  l_cp->tw, l_cp->th);
    }
#line 2312
    return (0);
  } else
#line 2308
  if (l_cp->th == 0U) {
    {
#line 2309
    opj_event_msg(p_manager___47, 1, "Invalid number of tiles : %u x %u (maximum fixed by jpeg2000 norm is 65535 tiles)\n",
                  l_cp->tw, l_cp->th);
    }
#line 2312
    return (0);
  } else
#line 2308
  if (l_cp->tw > 65535U / l_cp->th) {
    {
#line 2309
    opj_event_msg(p_manager___47, 1, "Invalid number of tiles : %u x %u (maximum fixed by jpeg2000 norm is 65535 tiles)\n",
                  l_cp->tw, l_cp->th);
    }
#line 2312
    return (0);
  }
#line 2314
  l_nb_tiles___0 = l_cp->tw * l_cp->th;
#line 2317
  if (p_j2k___4->m_specific_param.m_decoder.m_discard_tiles) {
    {
#line 2318
    p_j2k___4->m_specific_param.m_decoder.m_start_tile_x = (p_j2k___4->m_specific_param.m_decoder.m_start_tile_x - l_cp->tx0) / l_cp->tdx;
#line 2320
    p_j2k___4->m_specific_param.m_decoder.m_start_tile_y = (p_j2k___4->m_specific_param.m_decoder.m_start_tile_y - l_cp->ty0) / l_cp->tdy;
#line 2322
    __cil_tmp30 = opj_int_ceildiv((OPJ_INT32 )(p_j2k___4->m_specific_param.m_decoder.m_end_tile_x - l_cp->tx0),
                                  (OPJ_INT32 )l_cp->tdx);
#line 2322
    p_j2k___4->m_specific_param.m_decoder.m_end_tile_x = (OPJ_UINT32 )__cil_tmp30;
#line 2325
    __cil_tmp31 = opj_int_ceildiv((OPJ_INT32 )(p_j2k___4->m_specific_param.m_decoder.m_end_tile_y - l_cp->ty0),
                                  (OPJ_INT32 )l_cp->tdy);
#line 2325
    p_j2k___4->m_specific_param.m_decoder.m_end_tile_y = (OPJ_UINT32 )__cil_tmp31;
    }
  } else {
#line 2329
    p_j2k___4->m_specific_param.m_decoder.m_start_tile_x = (OPJ_UINT32 )0;
#line 2330
    p_j2k___4->m_specific_param.m_decoder.m_start_tile_y = (OPJ_UINT32 )0;
#line 2331
    p_j2k___4->m_specific_param.m_decoder.m_end_tile_x = l_cp->tw;
#line 2332
    p_j2k___4->m_specific_param.m_decoder.m_end_tile_y = l_cp->th;
  }
  {
#line 2381
  __cil_tmp32 = opj_calloc((size_t )l_nb_tiles___0, sizeof(opj_tcp_t ));
#line 2381
  l_cp->tcps = (opj_tcp_t *)__cil_tmp32;
  }
#line 2382
  if ((unsigned long )l_cp->tcps == (unsigned long )((opj_tcp_t *)0)) {
    {
#line 2383
    opj_event_msg(p_manager___47, 1, "Not enough memory to take in charge SIZ marker\n");
    }
#line 2385
    return (0);
  }
  {
#line 2401
  __cil_tmp33 = opj_calloc((size_t )l_image___0->numcomps, sizeof(opj_tccp_t ));
#line 2401
  (p_j2k___4->m_specific_param.m_decoder.m_default_tcp)->tccps = (opj_tccp_t *)__cil_tmp33;
  }
#line 2403
  if ((unsigned long )(p_j2k___4->m_specific_param.m_decoder.m_default_tcp)->tccps == (unsigned long )((opj_tccp_t *)0)) {
    {
#line 2404
    opj_event_msg(p_manager___47, 1, "Not enough memory to take in charge SIZ marker\n");
    }
#line 2406
    return (0);
  }
  {
#line 2409
  __cil_tmp34 = opj_calloc((size_t )10, sizeof(opj_mct_data_t ));
#line 2409
  (p_j2k___4->m_specific_param.m_decoder.m_default_tcp)->m_mct_records = (opj_mct_data_t *)__cil_tmp34;
  }
#line 2413
  if (! (p_j2k___4->m_specific_param.m_decoder.m_default_tcp)->m_mct_records) {
    {
#line 2414
    opj_event_msg(p_manager___47, 1, "Not enough memory to take in charge SIZ marker\n");
    }
#line 2416
    return (0);
  }
  {
#line 2418
  (p_j2k___4->m_specific_param.m_decoder.m_default_tcp)->m_nb_max_mct_records = (OPJ_UINT32 )10;
#line 2421
  __cil_tmp35 = opj_calloc((size_t )10, sizeof(opj_simple_mcc_decorrelation_data_t ));
#line 2421
  (p_j2k___4->m_specific_param.m_decoder.m_default_tcp)->m_mcc_records = (opj_simple_mcc_decorrelation_data_t *)__cil_tmp35;
  }
#line 2426
  if (! (p_j2k___4->m_specific_param.m_decoder.m_default_tcp)->m_mcc_records) {
    {
#line 2427
    opj_event_msg(p_manager___47, 1, "Not enough memory to take in charge SIZ marker\n");
    }
#line 2429
    return (0);
  }
#line 2431
  (p_j2k___4->m_specific_param.m_decoder.m_default_tcp)->m_nb_max_mcc_records = (OPJ_UINT32 )10;
#line 2435
  i___34 = (OPJ_UINT32 )0;
  {
#line 2435
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 2435
    if (! (i___34 < l_image___0->numcomps)) {
#line 2435
      goto while_break___0;
    }
#line 2436
    if (! (l_image___0->comps + i___34)->sgnd) {
#line 2437
      ((p_j2k___4->m_specific_param.m_decoder.m_default_tcp)->tccps + i___34)->m_dc_level_shift = 1 << ((l_image___0->comps + i___34)->prec - 1U);
    }
#line 2435
    i___34 ++;
  }
  while_break___3: /* CIL Label */ ;
  }

  while_break___0: 
#line 2442
  l_current_tile_param = l_cp->tcps;
#line 2443
  i___34 = (OPJ_UINT32 )0;
  {
#line 2443
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 2443
    if (! (i___34 < l_nb_tiles___0)) {
#line 2443
      goto while_break___1;
    }
    {
#line 2444
    __cil_tmp36 = opj_calloc((size_t )l_image___0->numcomps, sizeof(opj_tccp_t ));
#line 2444
    l_current_tile_param->tccps = (opj_tccp_t *)__cil_tmp36;
    }
#line 2446
    if ((unsigned long )l_current_tile_param->tccps == (unsigned long )((opj_tccp_t *)0)) {
      {
#line 2447
      opj_event_msg(p_manager___47, 1, "Not enough memory to take in charge SIZ marker\n");
      }
#line 2449
      return (0);
    }
#line 2452
    l_current_tile_param ++;
#line 2443
    i___34 ++;
  }
  while_break___4: /* CIL Label */ ;
  }

  while_break___1: 
  {
#line 2455
  p_j2k___4->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )4;
#line 2456
  opj_image_comp_header_update(l_image___0, l_cp);
  }
#line 2458
  return (1);
}
}
#line 2461 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_com(opj_j2k_t *p_j2k___5 , opj_stream_private_t *p_stream___18 ,
                                  opj_event_mgr_t *p_manager___48 ) 
{ 
  OPJ_UINT32 l_comment_size ;
  OPJ_UINT32 l_total_com_size ;
  OPJ_CHAR *l_comment ;
  OPJ_BYTE *l_current_ptr___0 ;
  unsigned long __cil_tmp11___5 ;
  OPJ_BYTE *new_header_tile_data___0 ;
  void *__cil_tmp13___8 ;
  OPJ_SIZE_T __cil_tmp14___8 ;

  {
  {
#line 2469
  l_current_ptr___0 = (OPJ_BYTE *)0;
#line 2476
  l_comment = p_j2k___5->m_cp.comment;
#line 2477
  __cil_tmp11___5 = strlen((char const   *)l_comment);
#line 2477
  l_comment_size = (OPJ_UINT32 )__cil_tmp11___5;
#line 2478
  l_total_com_size = l_comment_size + 6U;
  }
#line 2480
  if (l_total_com_size > p_j2k___5->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 2482
    __cil_tmp13___8 = opj_realloc((void *)p_j2k___5->m_specific_param.m_encoder.m_header_tile_data,
                                  (size_t )l_total_com_size);
#line 2482
    new_header_tile_data___0 = (OPJ_BYTE *)__cil_tmp13___8;
    }
#line 2484
    if (! new_header_tile_data___0) {
      {
#line 2485
      opj_free((void *)p_j2k___5->m_specific_param.m_encoder.m_header_tile_data);
#line 2486
      p_j2k___5->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 2487
      p_j2k___5->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 2488
      opj_event_msg(p_manager___48, 1, "Not enough memory to write the COM marker\n");
      }
#line 2490
      return (0);
    }
#line 2492
    p_j2k___5->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data___0;
#line 2493
    p_j2k___5->m_specific_param.m_encoder.m_header_tile_data_size = l_total_com_size;
  }
  {
#line 2496
  l_current_ptr___0 = p_j2k___5->m_specific_param.m_encoder.m_header_tile_data;
#line 2498
  opj_write_bytes_LE(l_current_ptr___0, (OPJ_UINT32 )65380, (OPJ_UINT32 )2);
#line 2499
  l_current_ptr___0 += 2;
#line 2501
  opj_write_bytes_LE(l_current_ptr___0, l_total_com_size - 2U, (OPJ_UINT32 )2);
#line 2502
  l_current_ptr___0 += 2;
#line 2504
  opj_write_bytes_LE(l_current_ptr___0, (OPJ_UINT32 )1, (OPJ_UINT32 )2);
#line 2506
  l_current_ptr___0 += 2;
#line 2508
  memcpy((void *)l_current_ptr___0, (void const   *)l_comment, (unsigned long )l_comment_size);
#line 2510
  __cil_tmp14___8 = opj_stream_write_data(p_stream___18, p_j2k___5->m_specific_param.m_encoder.m_header_tile_data,
                                          (OPJ_SIZE_T )l_total_com_size, p_manager___48);
  }
#line 2510
  if (__cil_tmp14___8 != (unsigned long )l_total_com_size) {
#line 2513
    return (0);
  }
#line 2516
  return (1);
}
}
#line 2526 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_com(opj_j2k_t *p_j2k___6 , OPJ_BYTE *p_header_data___3 ,
                                 OPJ_UINT32 p_header_size___3 , opj_event_mgr_t *p_manager___49 ) 
{ 


  {
#line 2542
  return (1);
}
}
#line 2545 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_cod(opj_j2k_t *p_j2k___7 , opj_stream_private_t *p_stream___19 ,
                                  opj_event_mgr_t *p_manager___50 ) 
{ 
  opj_cp_t *l_cp___0 ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 l_code_size ;
  OPJ_UINT32 l_remaining_size___0 ;
  OPJ_BYTE *l_current_data___0 ;
  OPJ_UINT32 __cil_tmp12___8 ;
  OPJ_BYTE *new_header_tile_data___1 ;
  void *__cil_tmp14___9 ;
  OPJ_BOOL __cil_tmp15___5 ;
  OPJ_SIZE_T __cil_tmp16___3 ;

  {
  {
#line 2549
  l_cp___0 = (opj_cp_t *)0;
#line 2550
  l_tcp = (opj_tcp_t *)0;
#line 2552
  l_current_data___0 = (OPJ_BYTE *)0;
#line 2559
  l_cp___0 = & p_j2k___7->m_cp;
#line 2560
  l_tcp = l_cp___0->tcps + p_j2k___7->m_current_tile_number;
#line 2561
  __cil_tmp12___8 = opj_j2k_get_SPCod_SPCoc_size(p_j2k___7, p_j2k___7->m_current_tile_number,
                                                 (OPJ_UINT32 )0);
#line 2561
  l_code_size = 9U + __cil_tmp12___8;
#line 2563
  l_remaining_size___0 = l_code_size;
  }
#line 2565
  if (l_code_size > p_j2k___7->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 2566
    __cil_tmp14___9 = opj_realloc((void *)p_j2k___7->m_specific_param.m_encoder.m_header_tile_data,
                                  (size_t )l_code_size);
#line 2566
    new_header_tile_data___1 = (OPJ_BYTE *)__cil_tmp14___9;
    }
#line 2568
    if (! new_header_tile_data___1) {
      {
#line 2569
      opj_free((void *)p_j2k___7->m_specific_param.m_encoder.m_header_tile_data);
#line 2570
      p_j2k___7->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 2571
      p_j2k___7->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 2572
      opj_event_msg(p_manager___50, 1, "Not enough memory to write COD marker\n");
      }
#line 2573
      return (0);
    }
#line 2575
    p_j2k___7->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data___1;
#line 2576
    p_j2k___7->m_specific_param.m_encoder.m_header_tile_data_size = l_code_size;
  }
  {
#line 2579
  l_current_data___0 = p_j2k___7->m_specific_param.m_encoder.m_header_tile_data;
#line 2581
  opj_write_bytes_LE(l_current_data___0, (OPJ_UINT32 )65362, (OPJ_UINT32 )2);
#line 2582
  l_current_data___0 += 2;
#line 2584
  opj_write_bytes_LE(l_current_data___0, l_code_size - 2U, (OPJ_UINT32 )2);
#line 2585
  l_current_data___0 += 2;
#line 2587
  opj_write_bytes_LE(l_current_data___0, l_tcp->csty, (OPJ_UINT32 )1);
#line 2588
  l_current_data___0 ++;
#line 2590
  opj_write_bytes_LE(l_current_data___0, (OPJ_UINT32 )l_tcp->prg, (OPJ_UINT32 )1);
#line 2591
  l_current_data___0 ++;
#line 2593
  opj_write_bytes_LE(l_current_data___0, l_tcp->numlayers, (OPJ_UINT32 )2);
#line 2594
  l_current_data___0 += 2;
#line 2596
  opj_write_bytes_LE(l_current_data___0, l_tcp->mct, (OPJ_UINT32 )1);
#line 2597
  l_current_data___0 ++;
#line 2599
  l_remaining_size___0 -= 9U;
#line 2601
  __cil_tmp15___5 = opj_j2k_write_SPCod_SPCoc(p_j2k___7, p_j2k___7->m_current_tile_number,
                                              (OPJ_UINT32 )0, l_current_data___0,
                                              & l_remaining_size___0, p_manager___50);
  }
#line 2601
  if (! __cil_tmp15___5) {
    {
#line 2603
    opj_event_msg(p_manager___50, 1, "Error writing COD marker\n\353\220\005]U");
    }
#line 2604
    return (0);
  }
#line 2607
  if (l_remaining_size___0 != 0U) {
    {
#line 2608
    opj_event_msg(p_manager___50, 1, "Error writing COD marker\n\032\220\005]U");
    }
#line 2609
    return (0);
  }
  {
#line 2612
  __cil_tmp16___3 = opj_stream_write_data(p_stream___19, p_j2k___7->m_specific_param.m_encoder.m_header_tile_data,
                                          (OPJ_SIZE_T )l_code_size, p_manager___50);
  }
#line 2612
  if (__cil_tmp16___3 != (unsigned long )l_code_size) {
#line 2615
    return (0);
  }
#line 2618
  return (1);
}
}
#line 2628 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_cod(opj_j2k_t *p_j2k___8 , OPJ_BYTE *p_header_data___4 ,
                                 OPJ_UINT32 p_header_size___4 , opj_event_mgr_t *p_manager___51 ) 
{ 
  OPJ_UINT32 i___35 ;
  OPJ_UINT32 l_tmp___0 ;
  opj_cp_t *l_cp___1 ;
  opj_tcp_t *l_tcp___0 ;
  opj_image_t *l_image___1 ;
  opj_tcp_t *tmp___167 ;
  OPJ_BOOL __cil_tmp14___10 ;

  {
#line 2637
  l_cp___1 = (opj_cp_t *)0;
#line 2638
  l_tcp___0 = (opj_tcp_t *)0;
#line 2639
  l_image___1 = (opj_image_t *)0;
#line 2646
  l_image___1 = p_j2k___8->m_private_image;
#line 2647
  l_cp___1 = & p_j2k___8->m_cp;
#line 2650
  if (p_j2k___8->m_specific_param.m_decoder.m_state == 16U) {
#line 2650
    tmp___167 = l_cp___1->tcps + p_j2k___8->m_current_tile_number;
  } else {
#line 2650
    tmp___167 = p_j2k___8->m_specific_param.m_decoder.m_default_tcp;
  }
#line 2650
  l_tcp___0 = tmp___167;
#line 2665
  l_tcp___0->cod = (OPJ_BITFIELD )1;
#line 2668
  if (p_header_size___4 < 5U) {
    {
#line 2669
    opj_event_msg(p_manager___51, 1, "Error reading COD marker\n\022\316\004]U");
    }
#line 2670
    return (0);
  }
  {
#line 2673
  opj_read_bytes_LE(p_header_data___4, & l_tcp___0->csty, (OPJ_UINT32 )1);
#line 2674
  p_header_data___4 ++;
  }
#line 2676
  if ((l_tcp___0->csty & 4294967288U) != 0U) {
    {
#line 2678
    opj_event_msg(p_manager___51, 1, "Unknown Scod value in COD marker\nP\221\005]U");
    }
#line 2679
    return (0);
  }
  {
#line 2681
  opj_read_bytes_LE(p_header_data___4, & l_tmp___0, (OPJ_UINT32 )1);
#line 2682
  p_header_data___4 ++;
#line 2683
  l_tcp___0->prg = (OPJ_PROG_ORDER )l_tmp___0;
  }
#line 2685
  if ((int )l_tcp___0->prg > 4) {
    {
#line 2686
    opj_event_msg(p_manager___51, 1, "Unknown progression order in COD marker\n\220");
#line 2688
    l_tcp___0->prg = (OPJ_PROG_ORDER )-1;
    }
  }
  {
#line 2690
  opj_read_bytes_LE(p_header_data___4, & l_tcp___0->numlayers, (OPJ_UINT32 )2);
#line 2691
  p_header_data___4 += 2;
  }
#line 2693
  if (l_tcp___0->numlayers < 1U) {
    {
#line 2694
    opj_event_msg(p_manager___51, 1, "Invalid number of layers in COD marker : %d not in range [1-65535]\n",
                  l_tcp___0->numlayers);
    }
#line 2697
    return (0);
  } else
#line 2693
  if (l_tcp___0->numlayers > 65535U) {
    {
#line 2694
    opj_event_msg(p_manager___51, 1, "Invalid number of layers in COD marker : %d not in range [1-65535]\n",
                  l_tcp___0->numlayers);
    }
#line 2697
    return (0);
  }
#line 2701
  if (l_cp___1->m_specific_param.m_dec.m_layer) {
#line 2702
    l_tcp___0->num_layers_to_decode = l_cp___1->m_specific_param.m_dec.m_layer;
  } else {
#line 2704
    l_tcp___0->num_layers_to_decode = l_tcp___0->numlayers;
  }
  {
#line 2707
  opj_read_bytes_LE(p_header_data___4, & l_tcp___0->mct, (OPJ_UINT32 )1);
#line 2708
  p_header_data___4 ++;
#line 2710
  p_header_size___4 -= 5U;
#line 2711
  i___35 = (OPJ_UINT32 )0;
  }
  {
#line 2711
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2711
    if (! (i___35 < l_image___1->numcomps)) {
#line 2711
      goto while_break;
    }
#line 2712
    (l_tcp___0->tccps + i___35)->csty = l_tcp___0->csty & 1U;
#line 2711
    i___35 ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: 
  {
#line 2715
  __cil_tmp14___10 = opj_j2k_read_SPCod_SPCoc(p_j2k___8, (OPJ_UINT32 )0, p_header_data___4,
                                              & p_header_size___4, p_manager___51);
  }
#line 2715
  if (! __cil_tmp14___10) {
    {
#line 2717
    opj_event_msg(p_manager___51, 1, "Error reading COD marker\n");
    }
#line 2718
    return (0);
  }
#line 2721
  if (p_header_size___4 != 0U) {
    {
#line 2722
    opj_event_msg(p_manager___51, 1, "Error reading COD marker\n");
    }
#line 2723
    return (0);
  }
  {
#line 2727
  opj_j2k_copy_tile_component_parameters(p_j2k___8);
  }
#line 2746
  return (1);
}
}
#line 2749 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_coc(opj_j2k_t *p_j2k___9 , OPJ_UINT32 p_comp_no , opj_stream_private_t *p_stream___20 ,
                                  opj_event_mgr_t *p_manager___52 ) 
{ 
  OPJ_UINT32 l_coc_size ;
  OPJ_UINT32 l_remaining_size___1 ;
  OPJ_UINT32 l_comp_room ;
  int tmp___171 ;
  OPJ_UINT32 __cil_tmp12___9 ;
  OPJ_BYTE *new_header_tile_data___2 ;
  void *__cil_tmp14___11 ;
  OPJ_SIZE_T __cil_tmp15___6 ;

  {
#line 2762
  if ((p_j2k___9->m_private_image)->numcomps <= 256U) {
#line 2762
    tmp___171 = 1;
  } else {
#line 2762
    tmp___171 = 2;
  }
  {
#line 2762
  l_comp_room = (OPJ_UINT32 )tmp___171;
#line 2764
  __cil_tmp12___9 = opj_j2k_get_SPCod_SPCoc_size(p_j2k___9, p_j2k___9->m_current_tile_number,
                                                 p_comp_no);
#line 2764
  l_coc_size = (5U + l_comp_room) + __cil_tmp12___9;
  }
#line 2767
  if (l_coc_size > p_j2k___9->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 2774
    __cil_tmp14___11 = opj_realloc((void *)p_j2k___9->m_specific_param.m_encoder.m_header_tile_data,
                                   (size_t )l_coc_size);
#line 2774
    new_header_tile_data___2 = (OPJ_BYTE *)__cil_tmp14___11;
    }
#line 2776
    if (! new_header_tile_data___2) {
      {
#line 2777
      opj_free((void *)p_j2k___9->m_specific_param.m_encoder.m_header_tile_data);
#line 2778
      p_j2k___9->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 2779
      p_j2k___9->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 2780
      opj_event_msg(p_manager___52, 1, "Not enough memory to write COC marker\n");
      }
#line 2781
      return (0);
    }
#line 2783
    p_j2k___9->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data___2;
#line 2784
    p_j2k___9->m_specific_param.m_encoder.m_header_tile_data_size = l_coc_size;
  }
  {
#line 2787
  opj_j2k_write_coc_in_memory(p_j2k___9, p_comp_no, p_j2k___9->m_specific_param.m_encoder.m_header_tile_data,
                              & l_remaining_size___1, p_manager___52);
#line 2791
  __cil_tmp15___6 = opj_stream_write_data(p_stream___20, p_j2k___9->m_specific_param.m_encoder.m_header_tile_data,
                                          (OPJ_SIZE_T )l_coc_size, p_manager___52);
  }
#line 2791
  if (__cil_tmp15___6 != (unsigned long )l_coc_size) {
#line 2794
    return (0);
  }
#line 2797
  return (1);
}
}
#line 2800 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_compare_coc(opj_j2k_t *p_j2k___10 , OPJ_UINT32 p_first_comp_no ,
                                    OPJ_UINT32 p_second_comp_no ) 
{ 
  opj_cp_t *l_cp___2 ;
  opj_tcp_t *l_tcp___1 ;
  OPJ_BOOL __cil_tmp7___15 ;

  {
#line 2803
  l_cp___2 = (opj_cp_t *)((void *)0);
#line 2804
  l_tcp___1 = (opj_tcp_t *)((void *)0);
#line 2809
  l_cp___2 = & p_j2k___10->m_cp;
#line 2810
  l_tcp___1 = l_cp___2->tcps + p_j2k___10->m_current_tile_number;
#line 2812
  if ((l_tcp___1->tccps + p_first_comp_no)->csty != (l_tcp___1->tccps + p_second_comp_no)->csty) {
#line 2813
    return (0);
  }
  {
#line 2817
  __cil_tmp7___15 = opj_j2k_compare_SPCod_SPCoc(p_j2k___10, p_j2k___10->m_current_tile_number,
                                                p_first_comp_no, p_second_comp_no);
  }
#line 2817
  return (__cil_tmp7___15);
}
}
#line 2821 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static void opj_j2k_write_coc_in_memory(opj_j2k_t *p_j2k___11 , OPJ_UINT32 p_comp_no___0 ,
                                        OPJ_BYTE *p_data___4 , OPJ_UINT32 *p_data_written ,
                                        opj_event_mgr_t *p_manager___53 ) 
{ 
  opj_cp_t *l_cp___3 ;
  opj_tcp_t *l_tcp___2 ;
  OPJ_UINT32 l_coc_size___0 ;
  OPJ_UINT32 l_remaining_size___2 ;
  OPJ_BYTE *l_current_data___1 ;
  opj_image_t *l_image___2 ;
  OPJ_UINT32 l_comp_room___0 ;
  int tmp___175 ;
  OPJ_UINT32 __cil_tmp16___4 ;

  {
#line 2828
  l_cp___3 = (opj_cp_t *)0;
#line 2829
  l_tcp___2 = (opj_tcp_t *)0;
#line 2831
  l_current_data___1 = (OPJ_BYTE *)0;
#line 2832
  l_image___2 = (opj_image_t *)0;
#line 2839
  l_cp___3 = & p_j2k___11->m_cp;
#line 2840
  l_tcp___2 = l_cp___3->tcps + p_j2k___11->m_current_tile_number;
#line 2841
  l_image___2 = p_j2k___11->m_private_image;
#line 2842
  if (l_image___2->numcomps <= 256U) {
#line 2842
    tmp___175 = 1;
  } else {
#line 2842
    tmp___175 = 2;
  }
  {
#line 2842
  l_comp_room___0 = (OPJ_UINT32 )tmp___175;
#line 2844
  __cil_tmp16___4 = opj_j2k_get_SPCod_SPCoc_size(p_j2k___11, p_j2k___11->m_current_tile_number,
                                                 p_comp_no___0);
#line 2844
  l_coc_size___0 = (5U + l_comp_room___0) + __cil_tmp16___4;
#line 2846
  l_remaining_size___2 = l_coc_size___0;
#line 2848
  l_current_data___1 = p_data___4;
#line 2850
  opj_write_bytes_LE(l_current_data___1, (OPJ_UINT32 )65363, (OPJ_UINT32 )2);
#line 2852
  l_current_data___1 += 2;
#line 2854
  opj_write_bytes_LE(l_current_data___1, l_coc_size___0 - 2U, (OPJ_UINT32 )2);
#line 2856
  l_current_data___1 += 2;
#line 2858
  opj_write_bytes_LE(l_current_data___1, p_comp_no___0, l_comp_room___0);
#line 2859
  l_current_data___1 += l_comp_room___0;
#line 2861
  opj_write_bytes_LE(l_current_data___1, (l_tcp___2->tccps + p_comp_no___0)->csty,
                     (OPJ_UINT32 )1);
#line 2863
  l_current_data___1 ++;
#line 2865
  l_remaining_size___2 -= 5U + l_comp_room___0;
#line 2866
  opj_j2k_write_SPCod_SPCoc(p_j2k___11, p_j2k___11->m_current_tile_number, (OPJ_UINT32 )0,
                            l_current_data___1, & l_remaining_size___2, p_manager___53);
#line 2868
  *p_data_written = l_coc_size___0;
  }
#line 2870
  return;
}
}
#line 2871 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_UINT32 opj_j2k_get_max_coc_size(opj_j2k_t *p_j2k___12 ) 
{ 
  OPJ_UINT32 i___36 ;
  OPJ_UINT32 j___2 ;
  OPJ_UINT32 l_nb_comp___0 ;
  OPJ_UINT32 l_nb_tiles___1 ;
  OPJ_UINT32 l_max ;
  OPJ_UINT32 __cil_tmp7___16 ;
  OPJ_UINT32 __cil_tmp8___29 ;

  {
#line 2876
  l_max = (OPJ_UINT32 )0;
#line 2880
  l_nb_tiles___1 = p_j2k___12->m_cp.tw * p_j2k___12->m_cp.th;
#line 2881
  l_nb_comp___0 = (p_j2k___12->m_private_image)->numcomps;
#line 2883
  i___36 = (OPJ_UINT32 )0;
  {
#line 2883
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2883
    if (! (i___36 < l_nb_tiles___1)) {
#line 2883
      goto while_break;
    }
#line 2884
    j___2 = (OPJ_UINT32 )0;
    {
#line 2884
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 2884
      if (! (j___2 < l_nb_comp___0)) {
#line 2884
        goto while_break___0;
      }
      {
#line 2885
      __cil_tmp7___16 = opj_j2k_get_SPCod_SPCoc_size(p_j2k___12, i___36, j___2);
#line 2885
      __cil_tmp8___29 = opj_uint_max(l_max, __cil_tmp7___16);
#line 2885
      l_max = __cil_tmp8___29;
#line 2884
      j___2 ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }

    while_break___0: 
#line 2883
    i___36 ++;
  }
  while_break___1: /* CIL Label */ ;
  }

  while_break: ;
#line 2889
  return (6U + l_max);
}
}
#line 2899 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_coc(opj_j2k_t *p_j2k___13 , OPJ_BYTE *p_header_data___5 ,
                                 OPJ_UINT32 p_header_size___5 , opj_event_mgr_t *p_manager___54 ) 
{ 
  opj_cp_t *l_cp___4 ;
  opj_tcp_t *l_tcp___3 ;
  opj_image_t *l_image___3 ;
  OPJ_UINT32 l_comp_room___1 ;
  OPJ_UINT32 l_comp_no ;
  opj_tcp_t *tmp___179 ;
  int tmp___180 ;
  OPJ_BOOL __cil_tmp15___7 ;

  {
#line 2905
  l_cp___4 = (opj_cp_t *)((void *)0);
#line 2906
  l_tcp___3 = (opj_tcp_t *)((void *)0);
#line 2907
  l_image___3 = (opj_image_t *)((void *)0);
#line 2916
  l_cp___4 = & p_j2k___13->m_cp;
#line 2917
  if (p_j2k___13->m_specific_param.m_decoder.m_state == 16U) {
#line 2917
    tmp___179 = l_cp___4->tcps + p_j2k___13->m_current_tile_number;
  } else {
#line 2917
    tmp___179 = p_j2k___13->m_specific_param.m_decoder.m_default_tcp;
  }
#line 2917
  l_tcp___3 = tmp___179;
#line 2921
  l_image___3 = p_j2k___13->m_private_image;
#line 2923
  if (l_image___3->numcomps <= 256U) {
#line 2923
    tmp___180 = 1;
  } else {
#line 2923
    tmp___180 = 2;
  }
#line 2923
  l_comp_room___1 = (OPJ_UINT32 )tmp___180;
#line 2926
  if (p_header_size___5 < l_comp_room___1 + 1U) {
    {
#line 2927
    opj_event_msg(p_manager___54, 1, "Error reading COC marker\nE\222\005]U");
    }
#line 2928
    return (0);
  }
  {
#line 2930
  p_header_size___5 -= l_comp_room___1 + 1U;
#line 2932
  opj_read_bytes_LE(p_header_data___5, & l_comp_no, l_comp_room___1);
#line 2934
  p_header_data___5 += l_comp_room___1;
  }
#line 2935
  if (l_comp_no >= l_image___3->numcomps) {
    {
#line 2936
    opj_event_msg(p_manager___54, 1, "Error reading COC marker (bad number of components)\n]U");
    }
#line 2938
    return (0);
  }
  {
#line 2941
  opj_read_bytes_LE(p_header_data___5, & (l_tcp___3->tccps + l_comp_no)->csty, (OPJ_UINT32 )1);
#line 2943
  p_header_data___5 ++;
#line 2945
  __cil_tmp15___7 = opj_j2k_read_SPCod_SPCoc(p_j2k___13, l_comp_no, p_header_data___5,
                                             & p_header_size___5, p_manager___54);
  }
#line 2945
  if (! __cil_tmp15___7) {
    {
#line 2947
    opj_event_msg(p_manager___54, 1, "Error reading COC marker\n\240\211\005]U");
    }
#line 2948
    return (0);
  }
#line 2951
  if (p_header_size___5 != 0U) {
    {
#line 2952
    opj_event_msg(p_manager___54, 1, "Error reading COC marker\n$\222\005]U");
    }
#line 2953
    return (0);
  }
#line 2955
  return (1);
}
}
#line 2958 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_qcd(opj_j2k_t *p_j2k___14 , opj_stream_private_t *p_stream___21 ,
                                  opj_event_mgr_t *p_manager___55 ) 
{ 
  OPJ_UINT32 l_qcd_size ;
  OPJ_UINT32 l_remaining_size___3 ;
  OPJ_BYTE *l_current_data___2 ;
  OPJ_UINT32 __cil_tmp10___5 ;
  OPJ_BYTE *new_header_tile_data___3 ;
  void *__cil_tmp12___10 ;
  OPJ_BOOL __cil_tmp13___9 ;
  OPJ_SIZE_T __cil_tmp14___12 ;

  {
  {
#line 2964
  l_current_data___2 = (OPJ_BYTE *)0;
#line 2971
  __cil_tmp10___5 = opj_j2k_get_SQcd_SQcc_size(p_j2k___14, p_j2k___14->m_current_tile_number,
                                               (OPJ_UINT32 )0);
#line 2971
  l_qcd_size = 4U + __cil_tmp10___5;
#line 2973
  l_remaining_size___3 = l_qcd_size;
  }
#line 2975
  if (l_qcd_size > p_j2k___14->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 2976
    __cil_tmp12___10 = opj_realloc((void *)p_j2k___14->m_specific_param.m_encoder.m_header_tile_data,
                                   (size_t )l_qcd_size);
#line 2976
    new_header_tile_data___3 = (OPJ_BYTE *)__cil_tmp12___10;
    }
#line 2978
    if (! new_header_tile_data___3) {
      {
#line 2979
      opj_free((void *)p_j2k___14->m_specific_param.m_encoder.m_header_tile_data);
#line 2980
      p_j2k___14->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 2981
      p_j2k___14->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 2982
      opj_event_msg(p_manager___55, 1, "Not enough memory to write QCD marker\n");
      }
#line 2983
      return (0);
    }
#line 2985
    p_j2k___14->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data___3;
#line 2986
    p_j2k___14->m_specific_param.m_encoder.m_header_tile_data_size = l_qcd_size;
  }
  {
#line 2989
  l_current_data___2 = p_j2k___14->m_specific_param.m_encoder.m_header_tile_data;
#line 2991
  opj_write_bytes_LE(l_current_data___2, (OPJ_UINT32 )65372, (OPJ_UINT32 )2);
#line 2992
  l_current_data___2 += 2;
#line 2994
  opj_write_bytes_LE(l_current_data___2, l_qcd_size - 2U, (OPJ_UINT32 )2);
#line 2995
  l_current_data___2 += 2;
#line 2997
  l_remaining_size___3 -= 4U;
#line 2999
  __cil_tmp13___9 = opj_j2k_write_SQcd_SQcc(p_j2k___14, p_j2k___14->m_current_tile_number,
                                            (OPJ_UINT32 )0, l_current_data___2, & l_remaining_size___3,
                                            p_manager___55);
  }
#line 2999
  if (! __cil_tmp13___9) {
    {
#line 3001
    opj_event_msg(p_manager___55, 1, "Error writing QCD marker\n");
    }
#line 3002
    return (0);
  }
#line 3005
  if (l_remaining_size___3 != 0U) {
    {
#line 3006
    opj_event_msg(p_manager___55, 1, "Error writing QCD marker\n");
    }
#line 3007
    return (0);
  }
  {
#line 3010
  __cil_tmp14___12 = opj_stream_write_data(p_stream___21, p_j2k___14->m_specific_param.m_encoder.m_header_tile_data,
                                           (OPJ_SIZE_T )l_qcd_size, p_manager___55);
  }
#line 3010
  if (__cil_tmp14___12 != (unsigned long )l_qcd_size) {
#line 3013
    return (0);
  }
#line 3016
  return (1);
}
}
#line 3026 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_qcd(opj_j2k_t *p_j2k___15 , OPJ_BYTE *p_header_data___6 ,
                                 OPJ_UINT32 p_header_size___6 , opj_event_mgr_t *p_manager___56 ) 
{ 
  OPJ_BOOL __cil_tmp8___30 ;

  {
  {
#line 3037
  __cil_tmp8___30 = opj_j2k_read_SQcd_SQcc(p_j2k___15, (OPJ_UINT32 )0, p_header_data___6,
                                           & p_header_size___6, p_manager___56);
  }
#line 3037
  if (! __cil_tmp8___30) {
    {
#line 3039
    opj_event_msg(p_manager___56, 1, "Error reading QCD marker\n");
    }
#line 3040
    return (0);
  }
#line 3043
  if (p_header_size___6 != 0U) {
    {
#line 3044
    opj_event_msg(p_manager___56, 1, "Error reading QCD marker\n");
    }
#line 3045
    return (0);
  }
  {
#line 3049
  opj_j2k_copy_tile_quantization_parameters(p_j2k___15);
  }
#line 3051
  return (1);
}
}
#line 3054 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_qcc(opj_j2k_t *p_j2k___16 , OPJ_UINT32 p_comp_no___1 ,
                                  opj_stream_private_t *p_stream___22 , opj_event_mgr_t *p_manager___57 ) 
{ 
  OPJ_UINT32 l_qcc_size ;
  OPJ_UINT32 l_remaining_size___4 ;
  OPJ_UINT32 __cil_tmp10___6 ;
  int tmp___190 ;
  OPJ_BYTE *new_header_tile_data___4 ;
  void *__cil_tmp13___10 ;
  OPJ_SIZE_T __cil_tmp14___13 ;

  {
  {
#line 3067
  __cil_tmp10___6 = opj_j2k_get_SQcd_SQcc_size(p_j2k___16, p_j2k___16->m_current_tile_number,
                                               p_comp_no___1);
#line 3067
  l_qcc_size = 5U + __cil_tmp10___6;
  }
#line 3069
  if ((p_j2k___16->m_private_image)->numcomps <= 256U) {
#line 3069
    tmp___190 = 0;
  } else {
#line 3069
    tmp___190 = 1;
  }
#line 3069
  l_qcc_size += (unsigned int )tmp___190;
#line 3070
  l_remaining_size___4 = l_qcc_size;
#line 3072
  if (l_qcc_size > p_j2k___16->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 3073
    __cil_tmp13___10 = opj_realloc((void *)p_j2k___16->m_specific_param.m_encoder.m_header_tile_data,
                                   (size_t )l_qcc_size);
#line 3073
    new_header_tile_data___4 = (OPJ_BYTE *)__cil_tmp13___10;
    }
#line 3075
    if (! new_header_tile_data___4) {
      {
#line 3076
      opj_free((void *)p_j2k___16->m_specific_param.m_encoder.m_header_tile_data);
#line 3077
      p_j2k___16->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 3078
      p_j2k___16->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 3079
      opj_event_msg(p_manager___57, 1, "Not enough memory to write QCC marker\n");
      }
#line 3080
      return (0);
    }
#line 3082
    p_j2k___16->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data___4;
#line 3083
    p_j2k___16->m_specific_param.m_encoder.m_header_tile_data_size = l_qcc_size;
  }
  {
#line 3086
  opj_j2k_write_qcc_in_memory(p_j2k___16, p_comp_no___1, p_j2k___16->m_specific_param.m_encoder.m_header_tile_data,
                              & l_remaining_size___4, p_manager___57);
#line 3090
  __cil_tmp14___13 = opj_stream_write_data(p_stream___22, p_j2k___16->m_specific_param.m_encoder.m_header_tile_data,
                                           (OPJ_SIZE_T )l_qcc_size, p_manager___57);
  }
#line 3090
  if (__cil_tmp14___13 != (unsigned long )l_qcc_size) {
#line 3093
    return (0);
  }
#line 3096
  return (1);
}
}
#line 3099 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_compare_qcc(opj_j2k_t *p_j2k___17 , OPJ_UINT32 p_first_comp_no___0 ,
                                    OPJ_UINT32 p_second_comp_no___0 ) 
{ 
  OPJ_BOOL __cil_tmp4___12 ;

  {
  {
#line 3102
  __cil_tmp4___12 = opj_j2k_compare_SQcd_SQcc(p_j2k___17, p_j2k___17->m_current_tile_number,
                                              p_first_comp_no___0, p_second_comp_no___0);
  }
#line 3102
  return (__cil_tmp4___12);
}
}
#line 3106 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static void opj_j2k_write_qcc_in_memory(opj_j2k_t *p_j2k___18 , OPJ_UINT32 p_comp_no___2 ,
                                        OPJ_BYTE *p_data___5 , OPJ_UINT32 *p_data_written___0 ,
                                        opj_event_mgr_t *p_manager___58 ) 
{ 
  OPJ_UINT32 l_qcc_size___0 ;
  OPJ_UINT32 l_remaining_size___5 ;
  OPJ_BYTE *l_current_data___3 ;
  OPJ_UINT32 __cil_tmp11___6 ;

  {
  {
#line 3114
  l_current_data___3 = (OPJ_BYTE *)0;
#line 3120
  __cil_tmp11___6 = opj_j2k_get_SQcd_SQcc_size(p_j2k___18, p_j2k___18->m_current_tile_number,
                                               p_comp_no___2);
#line 3120
  l_qcc_size___0 = 6U + __cil_tmp11___6;
#line 3122
  l_remaining_size___5 = l_qcc_size___0;
#line 3124
  l_current_data___3 = p_data___5;
#line 3126
  opj_write_bytes_LE(l_current_data___3, (OPJ_UINT32 )65373, (OPJ_UINT32 )2);
#line 3127
  l_current_data___3 += 2;
  }
#line 3129
  if ((p_j2k___18->m_private_image)->numcomps <= 256U) {
    {
#line 3130
    l_qcc_size___0 --;
#line 3132
    opj_write_bytes_LE(l_current_data___3, l_qcc_size___0 - 2U, (OPJ_UINT32 )2);
#line 3133
    l_current_data___3 += 2;
#line 3135
    opj_write_bytes_LE(l_current_data___3, p_comp_no___2, (OPJ_UINT32 )1);
#line 3136
    l_current_data___3 ++;
#line 3139
    l_remaining_size___5 -= 6U;
    }
  } else {
    {
#line 3141
    opj_write_bytes_LE(l_current_data___3, l_qcc_size___0 - 2U, (OPJ_UINT32 )2);
#line 3142
    l_current_data___3 += 2;
#line 3144
    opj_write_bytes_LE(l_current_data___3, p_comp_no___2, (OPJ_UINT32 )2);
#line 3145
    l_current_data___3 += 2;
#line 3147
    l_remaining_size___5 -= 6U;
    }
  }
  {
#line 3150
  opj_j2k_write_SQcd_SQcc(p_j2k___18, p_j2k___18->m_current_tile_number, p_comp_no___2,
                          l_current_data___3, & l_remaining_size___5, p_manager___58);
#line 3153
  *p_data_written___0 = l_qcc_size___0;
  }
#line 3155
  return;
}
}
#line 3156 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_UINT32 opj_j2k_get_max_qcc_size(opj_j2k_t *p_j2k___19 ) 
{ 
  OPJ_UINT32 __cil_tmp2___7 ;

  {
  {
#line 3158
  __cil_tmp2___7 = opj_j2k_get_max_coc_size(p_j2k___19);
  }
#line 3158
  return (__cil_tmp2___7);
}
}
#line 3168 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_qcc(opj_j2k_t *p_j2k___20 , OPJ_BYTE *p_header_data___7 ,
                                 OPJ_UINT32 p_header_size___7 , opj_event_mgr_t *p_manager___59 ) 
{ 
  OPJ_UINT32 l_num_comp ;
  OPJ_UINT32 l_comp_no___0 ;
  OPJ_BOOL __cil_tmp10___7 ;

  {
#line 3181
  l_num_comp = (p_j2k___20->m_private_image)->numcomps;
#line 3183
  if (l_num_comp <= 256U) {
#line 3184
    if (p_header_size___7 < 1U) {
      {
#line 3185
      opj_event_msg(p_manager___59, 1, "Error reading QCC marker\n");
      }
#line 3186
      return (0);
    }
    {
#line 3188
    opj_read_bytes_LE(p_header_data___7, & l_comp_no___0, (OPJ_UINT32 )1);
#line 3189
    p_header_data___7 ++;
#line 3190
    p_header_size___7 --;
    }
  } else {
#line 3192
    if (p_header_size___7 < 2U) {
      {
#line 3193
      opj_event_msg(p_manager___59, 1, "Error reading QCC marker\n");
      }
#line 3194
      return (0);
    }
    {
#line 3196
    opj_read_bytes_LE(p_header_data___7, & l_comp_no___0, (OPJ_UINT32 )2);
#line 3197
    p_header_data___7 += 2;
#line 3198
    p_header_size___7 -= 2U;
    }
  }
#line 3227
  if (l_comp_no___0 >= (p_j2k___20->m_private_image)->numcomps) {
    {
#line 3228
    opj_event_msg(p_manager___59, 1, "Invalid component number: %d, regarding the number of components %d\n",
                  l_comp_no___0, (p_j2k___20->m_private_image)->numcomps);
    }
#line 3231
    return (0);
  }
  {
#line 3234
  __cil_tmp10___7 = opj_j2k_read_SQcd_SQcc(p_j2k___20, l_comp_no___0, p_header_data___7,
                                           & p_header_size___7, p_manager___59);
  }
#line 3234
  if (! __cil_tmp10___7) {
    {
#line 3236
    opj_event_msg(p_manager___59, 1, "Error reading QCC marker\n");
    }
#line 3237
    return (0);
  }
#line 3240
  if (p_header_size___7 != 0U) {
    {
#line 3241
    opj_event_msg(p_manager___59, 1, "Error reading QCC marker\n");
    }
#line 3242
    return (0);
  }
#line 3245
  return (1);
}
}
#line 3248 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_poc(opj_j2k_t *p_j2k___21 , opj_stream_private_t *p_stream___23 ,
                                  opj_event_mgr_t *p_manager___60 ) 
{ 
  OPJ_UINT32 l_nb_comp___1 ;
  OPJ_UINT32 l_nb_poc ;
  OPJ_UINT32 l_poc_size ;
  OPJ_UINT32 l_written_size ;
  opj_tcp_t *l_tcp___4 ;
  OPJ_UINT32 l_poc_room ;
  OPJ_BYTE *new_header_tile_data___5 ;
  void *__cil_tmp14___14 ;
  OPJ_SIZE_T __cil_tmp15___8 ;

  {
#line 3256
  l_written_size = (OPJ_UINT32 )0;
#line 3257
  l_tcp___4 = (opj_tcp_t *)0;
#line 3265
  l_tcp___4 = p_j2k___21->m_cp.tcps + p_j2k___21->m_current_tile_number;
#line 3266
  l_nb_comp___1 = (p_j2k___21->m_private_image)->numcomps;
#line 3267
  l_nb_poc = 1U + l_tcp___4->numpocs;
#line 3269
  if (l_nb_comp___1 <= 256U) {
#line 3270
    l_poc_room = (OPJ_UINT32 )1;
  } else {
#line 3272
    l_poc_room = (OPJ_UINT32 )2;
  }
#line 3274
  l_poc_size = 4U + (5U + 2U * l_poc_room) * l_nb_poc;
#line 3276
  if (l_poc_size > p_j2k___21->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 3277
    __cil_tmp14___14 = opj_realloc((void *)p_j2k___21->m_specific_param.m_encoder.m_header_tile_data,
                                   (size_t )l_poc_size);
#line 3277
    new_header_tile_data___5 = (OPJ_BYTE *)__cil_tmp14___14;
    }
#line 3279
    if (! new_header_tile_data___5) {
      {
#line 3280
      opj_free((void *)p_j2k___21->m_specific_param.m_encoder.m_header_tile_data);
#line 3281
      p_j2k___21->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 3282
      p_j2k___21->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 3283
      opj_event_msg(p_manager___60, 1, "Not enough memory to write POC marker\n");
      }
#line 3284
      return (0);
    }
#line 3286
    p_j2k___21->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data___5;
#line 3287
    p_j2k___21->m_specific_param.m_encoder.m_header_tile_data_size = l_poc_size;
  }
  {
#line 3290
  opj_j2k_write_poc_in_memory(p_j2k___21, p_j2k___21->m_specific_param.m_encoder.m_header_tile_data,
                              & l_written_size, p_manager___60);
#line 3294
  __cil_tmp15___8 = opj_stream_write_data(p_stream___23, p_j2k___21->m_specific_param.m_encoder.m_header_tile_data,
                                          (OPJ_SIZE_T )l_poc_size, p_manager___60);
  }
#line 3294
  if (__cil_tmp15___8 != (unsigned long )l_poc_size) {
#line 3297
    return (0);
  }
#line 3300
  return (1);
}
}
#line 3303 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static void opj_j2k_write_poc_in_memory(opj_j2k_t *p_j2k___22 , OPJ_BYTE *p_data___6 ,
                                        OPJ_UINT32 *p_data_written___1 , opj_event_mgr_t *p_manager___61 ) 
{ 
  OPJ_UINT32 i___37 ;
  OPJ_BYTE *l_current_data___4 ;
  OPJ_UINT32 l_nb_comp___2 ;
  OPJ_UINT32 l_nb_poc___0 ;
  OPJ_UINT32 l_poc_size___0 ;
  opj_image_t *l_image___4 ;
  opj_tcp_t *l_tcp___5 ;
  opj_tccp_t *l_tccp ;
  opj_poc_t *l_current_poc___0 ;
  OPJ_UINT32 l_poc_room___0 ;
  OPJ_INT32 __cil_tmp17___5 ;
  OPJ_INT32 __cil_tmp18___3 ;
  OPJ_INT32 __cil_tmp19___4 ;

  {
#line 3310
  l_current_data___4 = (OPJ_BYTE *)0;
#line 3314
  l_image___4 = (opj_image_t *)0;
#line 3315
  l_tcp___5 = (opj_tcp_t *)0;
#line 3316
  l_tccp = (opj_tccp_t *)0;
#line 3317
  l_current_poc___0 = (opj_poc_t *)0;
#line 3326
  l_tcp___5 = p_j2k___22->m_cp.tcps + p_j2k___22->m_current_tile_number;
#line 3327
  l_tccp = l_tcp___5->tccps + 0;
#line 3328
  l_image___4 = p_j2k___22->m_private_image;
#line 3329
  l_nb_comp___2 = l_image___4->numcomps;
#line 3330
  l_nb_poc___0 = 1U + l_tcp___5->numpocs;
#line 3332
  if (l_nb_comp___2 <= 256U) {
#line 3333
    l_poc_room___0 = (OPJ_UINT32 )1;
  } else {
#line 3335
    l_poc_room___0 = (OPJ_UINT32 )2;
  }
  {
#line 3338
  l_poc_size___0 = 4U + (5U + 2U * l_poc_room___0) * l_nb_poc___0;
#line 3340
  l_current_data___4 = p_data___6;
#line 3342
  opj_write_bytes_LE(l_current_data___4, (OPJ_UINT32 )65375, (OPJ_UINT32 )2);
#line 3344
  l_current_data___4 += 2;
#line 3346
  opj_write_bytes_LE(l_current_data___4, l_poc_size___0 - 2U, (OPJ_UINT32 )2);
#line 3348
  l_current_data___4 += 2;
#line 3350
  l_current_poc___0 = l_tcp___5->pocs;
#line 3351
  i___37 = (OPJ_UINT32 )0;
  }
  {
#line 3351
  while (1) {
    while_continue: /* CIL Label */ ;

#line 3351
    if (! (i___37 < l_nb_poc___0)) {
#line 3351
      goto while_break;
    }
    {
#line 3352
    opj_write_bytes_LE(l_current_data___4, l_current_poc___0->resno0, (OPJ_UINT32 )1);
#line 3354
    l_current_data___4 ++;
#line 3356
    opj_write_bytes_LE(l_current_data___4, l_current_poc___0->compno0, l_poc_room___0);
#line 3358
    l_current_data___4 += l_poc_room___0;
#line 3360
    opj_write_bytes_LE(l_current_data___4, l_current_poc___0->layno1, (OPJ_UINT32 )2);
#line 3362
    l_current_data___4 += 2;
#line 3364
    opj_write_bytes_LE(l_current_data___4, l_current_poc___0->resno1, (OPJ_UINT32 )1);
#line 3366
    l_current_data___4 ++;
#line 3368
    opj_write_bytes_LE(l_current_data___4, l_current_poc___0->compno1, l_poc_room___0);
#line 3370
    l_current_data___4 += l_poc_room___0;
#line 3372
    opj_write_bytes_LE(l_current_data___4, (OPJ_UINT32 )l_current_poc___0->prg, (OPJ_UINT32 )1);
#line 3374
    l_current_data___4 ++;
#line 3377
    __cil_tmp17___5 = opj_int_min((OPJ_INT32 )l_current_poc___0->layno1, (OPJ_INT32 )l_tcp___5->numlayers);
#line 3377
    l_current_poc___0->layno1 = (OPJ_UINT32 )__cil_tmp17___5;
#line 3379
    __cil_tmp18___3 = opj_int_min((OPJ_INT32 )l_current_poc___0->resno1, (OPJ_INT32 )l_tccp->numresolutions);
#line 3379
    l_current_poc___0->resno1 = (OPJ_UINT32 )__cil_tmp18___3;
#line 3381
    __cil_tmp19___4 = opj_int_min((OPJ_INT32 )l_current_poc___0->compno1, (OPJ_INT32 )l_nb_comp___2);
#line 3381
    l_current_poc___0->compno1 = (OPJ_UINT32 )__cil_tmp19___4;
#line 3384
    l_current_poc___0 ++;
#line 3351
    i___37 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: 
#line 3387
  *p_data_written___1 = l_poc_size___0;
#line 3388
  return;
}
}
#line 3390 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_UINT32 opj_j2k_get_max_poc_size(opj_j2k_t *p_j2k___23 ) 
{ 
  opj_tcp_t *l_tcp___6 ;
  OPJ_UINT32 l_nb_tiles___2 ;
  OPJ_UINT32 l_max_poc ;
  OPJ_UINT32 i___38 ;

  {
#line 3392
  l_tcp___6 = (opj_tcp_t *)0;
#line 3393
  l_nb_tiles___2 = (OPJ_UINT32 )0;
#line 3394
  l_max_poc = (OPJ_UINT32 )0;
#line 3397
  l_tcp___6 = p_j2k___23->m_cp.tcps;
#line 3398
  l_nb_tiles___2 = p_j2k___23->m_cp.th * p_j2k___23->m_cp.tw;
#line 3400
  i___38 = (OPJ_UINT32 )0;
  {
#line 3400
  while (1) {
    while_continue: /* CIL Label */ ;

#line 3400
    if (! (i___38 < l_nb_tiles___2)) {
#line 3400
      goto while_break;
    }
    {
#line 3401
    l_max_poc = opj_uint_max(l_max_poc, l_tcp___6->numpocs);
#line 3402
    l_tcp___6 ++;
#line 3400
    i___38 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: 
#line 3405
  l_max_poc ++;
#line 3407
  return (4U + 9U * l_max_poc);
}
}
#line 3410 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_UINT32 opj_j2k_get_max_toc_size(opj_j2k_t *p_j2k___24 ) 
{ 
  OPJ_UINT32 i___39 ;
  OPJ_UINT32 l_nb_tiles___3 ;
  OPJ_UINT32 l_max___0 ;
  opj_tcp_t *l_tcp___7 ;

  {
#line 3414
  l_max___0 = (OPJ_UINT32 )0;
#line 3415
  l_tcp___7 = (opj_tcp_t *)0;
#line 3417
  l_tcp___7 = p_j2k___24->m_cp.tcps;
#line 3418
  l_nb_tiles___3 = p_j2k___24->m_cp.tw * p_j2k___24->m_cp.th;
#line 3420
  i___39 = (OPJ_UINT32 )0;
  {
#line 3420
  while (1) {
    while_continue: /* CIL Label */ ;

#line 3420
    if (! (i___39 < l_nb_tiles___3)) {
#line 3420
      goto while_break;
    }
    {
#line 3421
    l_max___0 = opj_uint_max(l_max___0, l_tcp___7->m_nb_tile_parts);
#line 3423
    l_tcp___7 ++;
#line 3420
    i___39 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 3426
  return (12U * l_max___0);
}
}
#line 3429 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_UINT32 opj_j2k_get_specific_header_sizes(opj_j2k_t *p_j2k___25 ) 
{ 
  OPJ_UINT32 l_nb_bytes ;
  OPJ_UINT32 l_nb_comps ;
  OPJ_UINT32 l_coc_bytes ;
  OPJ_UINT32 l_qcc_bytes ;
  OPJ_UINT32 __cil_tmp6___11 ;
  OPJ_UINT32 __cil_tmp9___10 ;
  OPJ_UINT32 i___40 ;
  opj_cp_t *l_cp___5 ;
  OPJ_UINT32 l_max_packet_count ;
  OPJ_UINT32 __cil_tmp13___11 ;
  OPJ_UINT32 __cil_tmp14___15 ;
  OPJ_UINT32 __cil_tmp15___9 ;

  {
  {
#line 3431
  l_nb_bytes = (OPJ_UINT32 )0;
#line 3435
  l_nb_comps = (p_j2k___25->m_private_image)->numcomps - 1U;
#line 3436
  __cil_tmp6___11 = opj_j2k_get_max_toc_size(p_j2k___25);
#line 3436
  l_nb_bytes += __cil_tmp6___11;
  }
#line 3438
  if ((int )p_j2k___25->m_cp.rsiz >= 3) {
#line 3438
    if (! ((int )p_j2k___25->m_cp.rsiz <= 6)) {
      {
#line 3439
      l_coc_bytes = opj_j2k_get_max_coc_size(p_j2k___25);
#line 3440
      l_nb_bytes += l_nb_comps * l_coc_bytes;
#line 3442
      l_qcc_bytes = opj_j2k_get_max_qcc_size(p_j2k___25);
#line 3443
      l_nb_bytes += l_nb_comps * l_qcc_bytes;
      }
    }
  } else {
    {
#line 3439
    l_coc_bytes = opj_j2k_get_max_coc_size(p_j2k___25);
#line 3440
    l_nb_bytes += l_nb_comps * l_coc_bytes;
#line 3442
    l_qcc_bytes = opj_j2k_get_max_qcc_size(p_j2k___25);
#line 3443
    l_nb_bytes += l_nb_comps * l_qcc_bytes;
    }
  }
  {
#line 3446
  __cil_tmp9___10 = opj_j2k_get_max_poc_size(p_j2k___25);
#line 3446
  l_nb_bytes += __cil_tmp9___10;
  }
#line 3448
  if (p_j2k___25->m_specific_param.m_encoder.m_PLT) {
#line 3452
    l_cp___5 = & p_j2k___25->m_cp;
#line 3453
    l_max_packet_count = (OPJ_UINT32 )0;
#line 3454
    i___40 = (OPJ_UINT32 )0;
    {
#line 3454
    while (1) {
      while_continue: /* CIL Label */ ;

#line 3454
      if (! (i___40 < l_cp___5->th * l_cp___5->tw)) {
#line 3454
        goto while_break;
      }
      {
#line 3455
      __cil_tmp13___11 = opj_get_encoding_packet_count(p_j2k___25->m_private_image,
                                                       l_cp___5, i___40);
#line 3455
      __cil_tmp14___15 = opj_uint_max(l_max_packet_count, __cil_tmp13___11);
#line 3455
      l_max_packet_count = __cil_tmp14___15;
#line 3454
      i___40 ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }

    while_break: 
    {
#line 3461
    __cil_tmp15___9 = opj_uint_ceildiv(l_max_packet_count, (OPJ_UINT32 )16382);
#line 3461
    p_j2k___25->m_specific_param.m_encoder.m_reserved_bytes_for_PLT = 6U * __cil_tmp15___9;
#line 3464
    l_nb_bytes += 5U * l_max_packet_count;
#line 3464
    p_j2k___25->m_specific_param.m_encoder.m_reserved_bytes_for_PLT += l_nb_bytes;
#line 3466
    (p_j2k___25->m_specific_param.m_encoder.m_reserved_bytes_for_PLT) ++;
#line 3467
    l_nb_bytes += p_j2k___25->m_specific_param.m_encoder.m_reserved_bytes_for_PLT;
    }
  }
#line 3472
  return (l_nb_bytes);
}
}
#line 3483 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_poc(opj_j2k_t *p_j2k___26 , OPJ_BYTE *p_header_data___8 ,
                                 OPJ_UINT32 p_header_size___8 , opj_event_mgr_t *p_manager___62 ) 
{ 
  OPJ_UINT32 i___41 ;
  OPJ_UINT32 l_nb_comp___3 ;
  OPJ_UINT32 l_tmp___1 ;
  opj_image_t *l_image___5 ;
  OPJ_UINT32 l_old_poc_nb ;
  OPJ_UINT32 l_current_poc_nb ;
  OPJ_UINT32 l_current_poc_remaining ;
  OPJ_UINT32 l_chunk_size ;
  OPJ_UINT32 l_comp_room___2 ;
  opj_cp_t *l_cp___6 ;
  opj_tcp_t *l_tcp___8 ;
  opj_poc_t *l_current_poc___1 ;
  opj_tcp_t *tmp___204 ;
  OPJ_UINT32 tmp___205 ;

  {
#line 3490
  l_image___5 = (opj_image_t *)0;
#line 3494
  l_cp___6 = (opj_cp_t *)0;
#line 3495
  l_tcp___8 = (opj_tcp_t *)0;
#line 3496
  l_current_poc___1 = (opj_poc_t *)0;
#line 3503
  l_image___5 = p_j2k___26->m_private_image;
#line 3504
  l_nb_comp___3 = l_image___5->numcomps;
#line 3505
  if (l_nb_comp___3 <= 256U) {
#line 3506
    l_comp_room___2 = (OPJ_UINT32 )1;
  } else {
#line 3508
    l_comp_room___2 = (OPJ_UINT32 )2;
  }
#line 3510
  l_chunk_size = 5U + 2U * l_comp_room___2;
#line 3511
  l_current_poc_nb = p_header_size___8 / l_chunk_size;
#line 3512
  l_current_poc_remaining = p_header_size___8 % l_chunk_size;
#line 3514
  if (l_current_poc_nb <= 0U) {
    {
#line 3515
    opj_event_msg(p_manager___62, 1, "Error reading POC marker\n");
    }
#line 3516
    return (0);
  } else
#line 3514
  if (l_current_poc_remaining != 0U) {
    {
#line 3515
    opj_event_msg(p_manager___62, 1, "Error reading POC marker\n");
    }
#line 3516
    return (0);
  }
#line 3519
  l_cp___6 = & p_j2k___26->m_cp;
#line 3520
  if (p_j2k___26->m_specific_param.m_decoder.m_state == 16U) {
#line 3520
    tmp___204 = l_cp___6->tcps + p_j2k___26->m_current_tile_number;
  } else {
#line 3520
    tmp___204 = p_j2k___26->m_specific_param.m_decoder.m_default_tcp;
  }
#line 3520
  l_tcp___8 = tmp___204;
#line 3523
  if ((int )l_tcp___8->POC) {
#line 3523
    tmp___205 = l_tcp___8->numpocs + 1U;
  } else {
#line 3523
    tmp___205 = 0U;
  }
#line 3523
  l_old_poc_nb = tmp___205;
#line 3524
  l_current_poc_nb += l_old_poc_nb;
#line 3526
  if (l_current_poc_nb >= 32U) {
    {
#line 3527
    opj_event_msg(p_manager___62, 1, "Too many POCs %d\n", l_current_poc_nb);
    }
#line 3528
    return (0);
  }
#line 3532
  l_tcp___8->POC = (OPJ_BITFIELD )1;
#line 3534
  l_current_poc___1 = & l_tcp___8->pocs[l_old_poc_nb];
#line 3535
  i___41 = l_old_poc_nb;
  {
#line 3535
  while (1) {
    while_continue: /* CIL Label */ ;

#line 3535
    if (! (i___41 < l_current_poc_nb)) {
#line 3535
      goto while_break;
    }
    {
#line 3536
    opj_read_bytes_LE(p_header_data___8, & l_current_poc___1->resno0, (OPJ_UINT32 )1);
#line 3538
    p_header_data___8 ++;
#line 3539
    opj_read_bytes_LE(p_header_data___8, & l_current_poc___1->compno0, l_comp_room___2);
#line 3541
    p_header_data___8 += l_comp_room___2;
#line 3542
    opj_read_bytes_LE(p_header_data___8, & l_current_poc___1->layno1, (OPJ_UINT32 )2);
#line 3545
    l_current_poc___1->layno1 = opj_uint_min(l_current_poc___1->layno1, l_tcp___8->numlayers);
#line 3546
    p_header_data___8 += 2;
#line 3547
    opj_read_bytes_LE(p_header_data___8, & l_current_poc___1->resno1, (OPJ_UINT32 )1);
#line 3549
    p_header_data___8 ++;
#line 3550
    opj_read_bytes_LE(p_header_data___8, & l_current_poc___1->compno1, l_comp_room___2);
#line 3552
    p_header_data___8 += l_comp_room___2;
#line 3553
    opj_read_bytes_LE(p_header_data___8, & l_tmp___1, (OPJ_UINT32 )1);
#line 3555
    p_header_data___8 ++;
#line 3556
    l_current_poc___1->prg = (OPJ_PROG_ORDER )l_tmp___1;
#line 3558
    l_current_poc___1->compno1 = opj_uint_min(l_current_poc___1->compno1, l_nb_comp___3);
#line 3559
    l_current_poc___1 ++;
#line 3535
    i___41 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: 
#line 3562
  l_tcp___8->numpocs = l_current_poc_nb - 1U;
#line 3563
  return (1);
}
}
#line 3574 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_crg(opj_j2k_t *p_j2k___27 , OPJ_BYTE *p_header_data___9 ,
                                 OPJ_UINT32 p_header_size___9 , opj_event_mgr_t *p_manager___63 ) 
{ 
  OPJ_UINT32 l_nb_comp___4 ;

  {
#line 3588
  l_nb_comp___4 = (p_j2k___27->m_private_image)->numcomps;
#line 3590
  if (p_header_size___9 != l_nb_comp___4 * 4U) {
    {
#line 3591
    opj_event_msg(p_manager___63, 1, "Error reading CRG marker\n");
    }
#line 3592
    return (0);
  }
#line 3605
  return (1);
}
}
#line 3616 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_tlm(opj_j2k_t *p_j2k___28 , OPJ_BYTE *p_header_data___10 ,
                                 OPJ_UINT32 p_header_size___10 , opj_event_mgr_t *p_manager___64 ) 
{ 
  OPJ_UINT32 l_Ztlm ;
  OPJ_UINT32 l_Stlm ;
  OPJ_UINT32 l_ST ;
  OPJ_UINT32 l_SP ;
  OPJ_UINT32 l_tot_num_tp_remaining ;
  OPJ_UINT32 l_quotient ;
  OPJ_UINT32 l_Ptlm_size ;

  {
#line 3631
  if (p_header_size___10 < 2U) {
    {
#line 3632
    opj_event_msg(p_manager___64, 1, "Error reading TLM marker\n\020\224\005]U");
    }
#line 3633
    return (0);
  }
  {
#line 3635
  p_header_size___10 -= 2U;
#line 3637
  opj_read_bytes_LE(p_header_data___10, & l_Ztlm, (OPJ_UINT32 )1);
#line 3639
  p_header_data___10 ++;
#line 3640
  opj_read_bytes_LE(p_header_data___10, & l_Stlm, (OPJ_UINT32 )1);
#line 3642
  p_header_data___10 ++;
#line 3644
  l_ST = (l_Stlm >> 4) & 3U;
#line 3645
  l_SP = (l_Stlm >> 6) & 1U;
#line 3647
  l_Ptlm_size = (l_SP + 1U) * 2U;
#line 3648
  l_quotient = l_Ptlm_size + l_ST;
#line 3650
  l_tot_num_tp_remaining = p_header_size___10 % l_quotient;
  }
#line 3652
  if (l_tot_num_tp_remaining != 0U) {
    {
#line 3653
    opj_event_msg(p_manager___64, 1, "Error reading TLM marker\n");
    }
#line 3654
    return (0);
  }
#line 3666
  return (1);
}
}
#line 3677 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_plm(opj_j2k_t *p_j2k___29 , OPJ_BYTE *p_header_data___11 ,
                                 OPJ_UINT32 p_header_size___11 , opj_event_mgr_t *p_manager___65 ) 
{ 


  {
#line 3691
  if (p_header_size___11 < 1U) {
    {
#line 3692
    opj_event_msg(p_manager___65, 1, "Error reading PLM marker\n3\224\005]U");
    }
#line 3693
    return (0);
  }
#line 3739
  return (1);
}
}
#line 3750 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_plt(opj_j2k_t *p_j2k___30 , OPJ_BYTE *p_header_data___12 ,
                                 OPJ_UINT32 p_header_size___12 , opj_event_mgr_t *p_manager___66 ) 
{ 
  OPJ_UINT32 l_Zplt ;
  OPJ_UINT32 l_tmp___2 ;
  OPJ_UINT32 l_packet_len ;
  OPJ_UINT32 i___42 ;

  {
#line 3756
  l_packet_len = (OPJ_UINT32 )0;
#line 3765
  if (p_header_size___12 < 1U) {
    {
#line 3766
    opj_event_msg(p_manager___66, 1, "Error reading PLT marker\nu\224\005]U");
    }
#line 3767
    return (0);
  }
  {
#line 3770
  opj_read_bytes_LE(p_header_data___12, & l_Zplt, (OPJ_UINT32 )1);
#line 3771
  p_header_data___12 ++;
#line 3772
  p_header_size___12 --;
#line 3774
  i___42 = (OPJ_UINT32 )0;
  }
  {
#line 3774
  while (1) {
    while_continue: /* CIL Label */ ;

#line 3774
    if (! (i___42 < p_header_size___12)) {
#line 3774
      goto while_break;
    }
    {
#line 3775
    opj_read_bytes_LE(p_header_data___12, & l_tmp___2, (OPJ_UINT32 )1);
#line 3776
    p_header_data___12 ++;
#line 3778
    l_packet_len |= l_tmp___2 & 127U;
    }
#line 3779
    if (l_tmp___2 & 128U) {
#line 3780
      l_packet_len <<= 7;
    } else {
#line 3783
      l_packet_len = (OPJ_UINT32 )0;
    }
#line 3774
    i___42 ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 3787
  if (l_packet_len != 0U) {
    {
#line 3788
    opj_event_msg(p_manager___66, 1, "Error reading PLT marker\n");
    }
#line 3789
    return (0);
  }
#line 3792
  return (1);
}
}
#line 3804 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_ppm(opj_j2k_t *p_j2k___31 , OPJ_BYTE *p_header_data___13 ,
                                 OPJ_UINT32 p_header_size___13 , opj_event_mgr_t *p_manager___67 ) 
{ 
  opj_cp_t *l_cp___7 ;
  OPJ_UINT32 l_Z_ppm ;
  OPJ_UINT32 l_newCount ;
  void *__cil_tmp12___11 ;
  OPJ_UINT32 l_newCount___0 ;
  opj_ppx *new_ppm_markers ;
  void *__cil_tmp15___10 ;
  void *__cil_tmp16___5 ;

  {
#line 3810
  l_cp___7 = (opj_cp_t *)0;
#line 3819
  if (p_header_size___13 < 2U) {
    {
#line 3820
    opj_event_msg(p_manager___67, 1, "Error reading PPM marker\n");
    }
#line 3821
    return (0);
  }
  {
#line 3824
  l_cp___7 = & p_j2k___31->m_cp;
#line 3825
  l_cp___7->ppm = (OPJ_BITFIELD )1;
#line 3827
  opj_read_bytes_LE(p_header_data___13, & l_Z_ppm, (OPJ_UINT32 )1);
#line 3828
  p_header_data___13 ++;
#line 3829
  p_header_size___13 --;
  }
#line 3832
  if ((unsigned long )l_cp___7->ppm_markers == (unsigned long )((void *)0)) {
    {
#line 3833
    l_newCount = l_Z_ppm + 1U;
#line 3836
    __cil_tmp12___11 = opj_calloc((size_t )l_newCount, sizeof(opj_ppx ));
#line 3836
    l_cp___7->ppm_markers = (opj_ppx *)__cil_tmp12___11;
    }
#line 3837
    if ((unsigned long )l_cp___7->ppm_markers == (unsigned long )((void *)0)) {
      {
#line 3838
      opj_event_msg(p_manager___67, 1, "Not enough memory to read PPM marker\nU");
      }
#line 3839
      return (0);
    }
#line 3841
    l_cp___7->ppm_markers_count = l_newCount;
  } else
#line 3842
  if (l_cp___7->ppm_markers_count <= l_Z_ppm) {
    {
#line 3843
    l_newCount___0 = l_Z_ppm + 1U;
#line 3845
    __cil_tmp15___10 = opj_realloc((void *)l_cp___7->ppm_markers, (unsigned long )l_newCount___0 * sizeof(opj_ppx ));
#line 3845
    new_ppm_markers = (opj_ppx *)__cil_tmp15___10;
    }
#line 3847
    if ((unsigned long )new_ppm_markers == (unsigned long )((void *)0)) {
      {
#line 3849
      opj_event_msg(p_manager___67, 1, "Not enough memory to read PPM marker\n");
      }
#line 3850
      return (0);
    }
    {
#line 3852
    l_cp___7->ppm_markers = new_ppm_markers;
#line 3853
    memset((void *)(l_cp___7->ppm_markers + l_cp___7->ppm_markers_count), 0, (unsigned long )(l_newCount___0 - l_cp___7->ppm_markers_count) * sizeof(opj_ppx ));
#line 3855
    l_cp___7->ppm_markers_count = l_newCount___0;
    }
  }
#line 3858
  if ((unsigned long )(l_cp___7->ppm_markers + l_Z_ppm)->m_data != (unsigned long )((void *)0)) {
    {
#line 3860
    opj_event_msg(p_manager___67, 1, "Zppm %u already read\n", l_Z_ppm);
    }
#line 3861
    return (0);
  }
  {
#line 3864
  __cil_tmp16___5 = opj_malloc((size_t )p_header_size___13);
#line 3864
  (l_cp___7->ppm_markers + l_Z_ppm)->m_data = (OPJ_BYTE *)__cil_tmp16___5;
  }
#line 3865
  if ((unsigned long )(l_cp___7->ppm_markers + l_Z_ppm)->m_data == (unsigned long )((void *)0)) {
    {
#line 3867
    opj_event_msg(p_manager___67, 1, "Not enough memory to read PPM marker\n");
    }
#line 3868
    return (0);
  }
  {
#line 3870
  (l_cp___7->ppm_markers + l_Z_ppm)->m_data_size = p_header_size___13;
#line 3871
  memcpy((void *)(l_cp___7->ppm_markers + l_Z_ppm)->m_data, (void const   *)p_header_data___13,
         (unsigned long )p_header_size___13);
  }
#line 3873
  return (1);
}
}
#line 3882 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_merge_ppm(opj_cp_t *p_cp , opj_event_mgr_t *p_manager___68 ) 
{ 
  OPJ_UINT32 i___43 ;
  OPJ_UINT32 l_ppm_data_size ;
  OPJ_UINT32 l_N_ppm_remaining ;
  OPJ_UINT32 l_N_ppm ;
  OPJ_UINT32 l_data_size ;
  OPJ_BYTE *l_data___0 ;
  void *__cil_tmp12___12 ;
  OPJ_UINT32 l_N_ppm___0 ;
  OPJ_UINT32 l_data_size___0 ;
  OPJ_BYTE *l_data___1 ;

  {
#line 3891
  if (p_cp->ppm == 0U) {
#line 3892
    return (1);
  }
#line 3895
  l_ppm_data_size = 0U;
#line 3896
  l_N_ppm_remaining = 0U;
#line 3897
  i___43 = 0U;
  {
#line 3897
  while (1) {
    while_continue: /* CIL Label */ ;

#line 3897
    if (! (i___43 < p_cp->ppm_markers_count)) {
#line 3897
      goto while_break;
    }
#line 3898
    if ((unsigned long )(p_cp->ppm_markers + i___43)->m_data != (unsigned long )((void *)0)) {
#line 3901
      l_data_size = (p_cp->ppm_markers + i___43)->m_data_size;
#line 3902
      l_data___0 = (p_cp->ppm_markers + i___43)->m_data;
#line 3904
      if (l_N_ppm_remaining >= l_data_size) {
#line 3905
        l_N_ppm_remaining -= l_data_size;
#line 3906
        l_data_size = 0U;
      } else {
#line 3908
        l_data___0 += l_N_ppm_remaining;
#line 3909
        l_data_size -= l_N_ppm_remaining;
#line 3910
        l_N_ppm_remaining = 0U;
      }
#line 3913
      if (l_data_size > 0U) {
        {
#line 3914
        while (1) {
          while_continue___0: /* CIL Label */ ;

#line 3916
          if (l_data_size < 4U) {
            {
#line 3918
            opj_event_msg(p_manager___68, 1, "Not enough bytes to read Nppm\n");
            }
#line 3919
            return (0);
          }
          {
#line 3921
          opj_read_bytes_LE(l_data___0, & l_N_ppm, (OPJ_UINT32 )4);
#line 3922
          l_data___0 += 4;
#line 3923
          l_data_size -= 4U;
#line 3924
          l_ppm_data_size += l_N_ppm;
          }
#line 3927
          if (l_data_size >= l_N_ppm) {
#line 3928
            l_data_size -= l_N_ppm;
#line 3929
            l_data___0 += l_N_ppm;
          } else {
#line 3931
            l_N_ppm_remaining = l_N_ppm - l_data_size;
#line 3932
            l_data_size = 0U;
          }
#line 3914
          if (! (l_data_size > 0U)) {
#line 3914
            goto while_break___0;
          }
        }
        while_break___4: /* CIL Label */ ;
        }

        while_break___0: ;
      }
    }
#line 3897
    i___43 ++;
  }
  while_break___3: /* CIL Label */ ;
  }

  while_break: ;
#line 3939
  if (l_N_ppm_remaining != 0U) {
    {
#line 3941
    opj_event_msg(p_manager___68, 1, "Corrupted PPM markers\n");
    }
#line 3942
    return (0);
  }
  {
#line 3945
  __cil_tmp12___12 = opj_malloc((size_t )l_ppm_data_size);
#line 3945
  p_cp->ppm_buffer = (OPJ_BYTE *)__cil_tmp12___12;
  }
#line 3946
  if ((unsigned long )p_cp->ppm_buffer == (unsigned long )((OPJ_BYTE *)0)) {
    {
#line 3947
    opj_event_msg(p_manager___68, 1, "Not enough memory to read PPM marker\nU");
    }
#line 3948
    return (0);
  }
#line 3950
  p_cp->ppm_len = l_ppm_data_size;
#line 3951
  l_ppm_data_size = 0U;
#line 3952
  l_N_ppm_remaining = 0U;
#line 3953
  i___43 = 0U;
  {
#line 3953
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 3953
    if (! (i___43 < p_cp->ppm_markers_count)) {
#line 3953
      goto while_break___1;
    }
#line 3954
    if ((unsigned long )(p_cp->ppm_markers + i___43)->m_data != (unsigned long )((void *)0)) {
#line 3957
      l_data_size___0 = (p_cp->ppm_markers + i___43)->m_data_size;
#line 3958
      l_data___1 = (p_cp->ppm_markers + i___43)->m_data;
#line 3960
      if (l_N_ppm_remaining >= l_data_size___0) {
        {
#line 3961
        memcpy((void *)(p_cp->ppm_buffer + l_ppm_data_size), (void const   *)l_data___1,
               (unsigned long )l_data_size___0);
#line 3962
        l_ppm_data_size += l_data_size___0;
#line 3963
        l_N_ppm_remaining -= l_data_size___0;
#line 3964
        l_data_size___0 = 0U;
        }
      } else {
        {
#line 3966
        memcpy((void *)(p_cp->ppm_buffer + l_ppm_data_size), (void const   *)l_data___1,
               (unsigned long )l_N_ppm_remaining);
#line 3967
        l_ppm_data_size += l_N_ppm_remaining;
#line 3968
        l_data___1 += l_N_ppm_remaining;
#line 3969
        l_data_size___0 -= l_N_ppm_remaining;
#line 3970
        l_N_ppm_remaining = 0U;
        }
      }
#line 3973
      if (l_data_size___0 > 0U) {
        {
#line 3974
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 3976
          if (l_data_size___0 < 4U) {
            {
#line 3978
            opj_event_msg(p_manager___68, 1, "Not enough bytes to read Nppm\n");
            }
#line 3979
            return (0);
          }
          {
#line 3981
          opj_read_bytes_LE(l_data___1, & l_N_ppm___0, (OPJ_UINT32 )4);
#line 3982
          l_data___1 += 4;
#line 3983
          l_data_size___0 -= 4U;
          }
#line 3985
          if (l_data_size___0 >= l_N_ppm___0) {
            {
#line 3986
            memcpy((void *)(p_cp->ppm_buffer + l_ppm_data_size), (void const   *)l_data___1,
                   (unsigned long )l_N_ppm___0);
#line 3987
            l_ppm_data_size += l_N_ppm___0;
#line 3988
            l_data_size___0 -= l_N_ppm___0;
#line 3989
            l_data___1 += l_N_ppm___0;
            }
          } else {
            {
#line 3991
            memcpy((void *)(p_cp->ppm_buffer + l_ppm_data_size), (void const   *)l_data___1,
                   (unsigned long )l_data_size___0);
#line 3992
            l_ppm_data_size += l_data_size___0;
#line 3993
            l_N_ppm_remaining = l_N_ppm___0 - l_data_size___0;
#line 3994
            l_data_size___0 = 0U;
            }
          }
#line 3974
          if (! (l_data_size___0 > 0U)) {
#line 3974
            goto while_break___2;
          }
        }
        while_break___6: /* CIL Label */ ;
        }

        while_break___2: ;
      }
      {
#line 3998
      opj_free((void *)(p_cp->ppm_markers + i___43)->m_data);
#line 3999
      (p_cp->ppm_markers + i___43)->m_data = (OPJ_BYTE *)((void *)0);
#line 4000
      (p_cp->ppm_markers + i___43)->m_data_size = 0U;
      }
    }
#line 3953
    i___43 ++;
  }
  while_break___5: /* CIL Label */ ;
  }

  while_break___1: 
  {
#line 4004
  p_cp->ppm_data = p_cp->ppm_buffer;
#line 4005
  p_cp->ppm_data_size = p_cp->ppm_len;
#line 4007
  p_cp->ppm_markers_count = 0U;
#line 4008
  opj_free((void *)p_cp->ppm_markers);
#line 4009
  p_cp->ppm_markers = (opj_ppx *)((void *)0);
  }
#line 4011
  return (1);
}
}
#line 4022 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_ppt(opj_j2k_t *p_j2k___32 , OPJ_BYTE *p_header_data___14 ,
                                 OPJ_UINT32 p_header_size___14 , opj_event_mgr_t *p_manager___69 ) 
{ 
  opj_cp_t *l_cp___8 ;
  opj_tcp_t *l_tcp___9 ;
  OPJ_UINT32 l_Z_ppt ;
  OPJ_UINT32 l_newCount___1 ;
  void *__cil_tmp13___12 ;
  OPJ_UINT32 l_newCount___2 ;
  opj_ppx *new_ppt_markers ;
  void *__cil_tmp16___6 ;
  void *__cil_tmp17___6 ;

  {
#line 4028
  l_cp___8 = (opj_cp_t *)0;
#line 4029
  l_tcp___9 = (opj_tcp_t *)0;
#line 4038
  if (p_header_size___14 < 2U) {
    {
#line 4039
    opj_event_msg(p_manager___69, 1, "Error reading PPT marker\n\036\225\005]U");
    }
#line 4040
    return (0);
  }
#line 4043
  l_cp___8 = & p_j2k___32->m_cp;
#line 4044
  if (l_cp___8->ppm) {
    {
#line 4045
    opj_event_msg(p_manager___69, 1, "Error reading PPT marker: packet header have been previously found in the main header (PPM marker).\n");
    }
#line 4047
    return (0);
  }
  {
#line 4050
  l_tcp___9 = l_cp___8->tcps + p_j2k___32->m_current_tile_number;
#line 4051
  l_tcp___9->ppt = (OPJ_BITFIELD )1;
#line 4053
  opj_read_bytes_LE(p_header_data___14, & l_Z_ppt, (OPJ_UINT32 )1);
#line 4054
  p_header_data___14 ++;
#line 4055
  p_header_size___14 --;
  }
#line 4058
  if ((unsigned long )l_tcp___9->ppt_markers == (unsigned long )((void *)0)) {
    {
#line 4059
    l_newCount___1 = l_Z_ppt + 1U;
#line 4062
    __cil_tmp13___12 = opj_calloc((size_t )l_newCount___1, sizeof(opj_ppx ));
#line 4062
    l_tcp___9->ppt_markers = (opj_ppx *)__cil_tmp13___12;
    }
#line 4063
    if ((unsigned long )l_tcp___9->ppt_markers == (unsigned long )((void *)0)) {
      {
#line 4064
      opj_event_msg(p_manager___69, 1, "Not enough memory to read PPT marker\n");
      }
#line 4065
      return (0);
    }
#line 4067
    l_tcp___9->ppt_markers_count = l_newCount___1;
  } else
#line 4068
  if (l_tcp___9->ppt_markers_count <= l_Z_ppt) {
    {
#line 4069
    l_newCount___2 = l_Z_ppt + 1U;
#line 4071
    __cil_tmp16___6 = opj_realloc((void *)l_tcp___9->ppt_markers, (unsigned long )l_newCount___2 * sizeof(opj_ppx ));
#line 4071
    new_ppt_markers = (opj_ppx *)__cil_tmp16___6;
    }
#line 4073
    if ((unsigned long )new_ppt_markers == (unsigned long )((void *)0)) {
      {
#line 4075
      opj_event_msg(p_manager___69, 1, "Not enough memory to read PPT marker\nU");
      }
#line 4076
      return (0);
    }
    {
#line 4078
    l_tcp___9->ppt_markers = new_ppt_markers;
#line 4079
    memset((void *)(l_tcp___9->ppt_markers + l_tcp___9->ppt_markers_count), 0, (unsigned long )(l_newCount___2 - l_tcp___9->ppt_markers_count) * sizeof(opj_ppx ));
#line 4081
    l_tcp___9->ppt_markers_count = l_newCount___2;
    }
  }
#line 4084
  if ((unsigned long )(l_tcp___9->ppt_markers + l_Z_ppt)->m_data != (unsigned long )((void *)0)) {
    {
#line 4086
    opj_event_msg(p_manager___69, 1, "Zppt %u already read\n", l_Z_ppt);
    }
#line 4087
    return (0);
  }
  {
#line 4090
  __cil_tmp17___6 = opj_malloc((size_t )p_header_size___14);
#line 4090
  (l_tcp___9->ppt_markers + l_Z_ppt)->m_data = (OPJ_BYTE *)__cil_tmp17___6;
  }
#line 4091
  if ((unsigned long )(l_tcp___9->ppt_markers + l_Z_ppt)->m_data == (unsigned long )((void *)0)) {
    {
#line 4093
    opj_event_msg(p_manager___69, 1, "Not enough memory to read PPT marker\nU");
    }
#line 4094
    return (0);
  }
  {
#line 4096
  (l_tcp___9->ppt_markers + l_Z_ppt)->m_data_size = p_header_size___14;
#line 4097
  memcpy((void *)(l_tcp___9->ppt_markers + l_Z_ppt)->m_data, (void const   *)p_header_data___14,
         (unsigned long )p_header_size___14);
  }
#line 4098
  return (1);
}
}
#line 4107 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_merge_ppt(opj_tcp_t *p_tcp , opj_event_mgr_t *p_manager___70 ) 
{ 
  OPJ_UINT32 i___44 ;
  OPJ_UINT32 l_ppt_data_size ;
  void *__cil_tmp7___18 ;

  {
#line 4114
  if ((unsigned long )p_tcp->ppt_buffer != (unsigned long )((void *)0)) {
    {
#line 4115
    opj_event_msg(p_manager___70, 1, "opj_j2k_merge_ppt() has already been called\n]U");
    }
#line 4117
    return (0);
  }
#line 4120
  if (p_tcp->ppt == 0U) {
#line 4121
    return (1);
  }
#line 4124
  l_ppt_data_size = 0U;
#line 4125
  i___44 = 0U;
  {
#line 4125
  while (1) {
    while_continue: /* CIL Label */ ;

#line 4125
    if (! (i___44 < p_tcp->ppt_markers_count)) {
#line 4125
      goto while_break;
    }
#line 4126
    l_ppt_data_size += (p_tcp->ppt_markers + i___44)->m_data_size;
#line 4125
    i___44 ++;
  }
  while_break___1: /* CIL Label */ ;
  }

  while_break: 
  {
#line 4130
  __cil_tmp7___18 = opj_malloc((size_t )l_ppt_data_size);
#line 4130
  p_tcp->ppt_buffer = (OPJ_BYTE *)__cil_tmp7___18;
  }
#line 4131
  if ((unsigned long )p_tcp->ppt_buffer == (unsigned long )((OPJ_BYTE *)0)) {
    {
#line 4132
    opj_event_msg(p_manager___70, 1, "Not enough memory to read PPT marker\n");
    }
#line 4133
    return (0);
  }
#line 4135
  p_tcp->ppt_len = l_ppt_data_size;
#line 4136
  l_ppt_data_size = 0U;
#line 4137
  i___44 = 0U;
  {
#line 4137
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 4137
    if (! (i___44 < p_tcp->ppt_markers_count)) {
#line 4137
      goto while_break___0;
    }
#line 4138
    if ((unsigned long )(p_tcp->ppt_markers + i___44)->m_data != (unsigned long )((void *)0)) {
      {
#line 4140
      memcpy((void *)(p_tcp->ppt_buffer + l_ppt_data_size), (void const   *)(p_tcp->ppt_markers + i___44)->m_data,
             (unsigned long )(p_tcp->ppt_markers + i___44)->m_data_size);
#line 4142
      l_ppt_data_size += (p_tcp->ppt_markers + i___44)->m_data_size;
#line 4145
      opj_free((void *)(p_tcp->ppt_markers + i___44)->m_data);
#line 4146
      (p_tcp->ppt_markers + i___44)->m_data = (OPJ_BYTE *)((void *)0);
#line 4147
      (p_tcp->ppt_markers + i___44)->m_data_size = 0U;
      }
    }
#line 4137
    i___44 ++;
  }
  while_break___2: /* CIL Label */ ;
  }

  while_break___0: 
  {
#line 4151
  p_tcp->ppt_markers_count = 0U;
#line 4152
  opj_free((void *)p_tcp->ppt_markers);
#line 4153
  p_tcp->ppt_markers = (opj_ppx *)((void *)0);
#line 4155
  p_tcp->ppt_data = p_tcp->ppt_buffer;
#line 4156
  p_tcp->ppt_data_size = p_tcp->ppt_len;
  }
#line 4157
  return (1);
}
}
#line 4160 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_tlm(opj_j2k_t *p_j2k___33 , opj_stream_private_t *p_stream___24 ,
                                  opj_event_mgr_t *p_manager___71 ) 
{ 
  OPJ_BYTE *l_current_data___5 ;
  OPJ_UINT32 l_tlm_size ;
  OPJ_BYTE *new_header_tile_data___6 ;
  void *__cil_tmp10___8 ;
  OPJ_SIZE_T __cil_tmp12___13 ;

  {
#line 4165
  l_current_data___5 = (OPJ_BYTE *)0;
#line 4173
  l_tlm_size = 6U + 5U * p_j2k___33->m_specific_param.m_encoder.m_total_tile_parts;
#line 4175
  if (l_tlm_size > p_j2k___33->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 4176
    __cil_tmp10___8 = opj_realloc((void *)p_j2k___33->m_specific_param.m_encoder.m_header_tile_data,
                                  (size_t )l_tlm_size);
#line 4176
    new_header_tile_data___6 = (OPJ_BYTE *)__cil_tmp10___8;
    }
#line 4178
    if (! new_header_tile_data___6) {
      {
#line 4179
      opj_free((void *)p_j2k___33->m_specific_param.m_encoder.m_header_tile_data);
#line 4180
      p_j2k___33->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 4181
      p_j2k___33->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 4182
      opj_event_msg(p_manager___71, 1, "Not enough memory to write TLM marker\n");
      }
#line 4183
      return (0);
    }
#line 4185
    p_j2k___33->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data___6;
#line 4186
    p_j2k___33->m_specific_param.m_encoder.m_header_tile_data_size = l_tlm_size;
  }
  {
#line 4189
  l_current_data___5 = p_j2k___33->m_specific_param.m_encoder.m_header_tile_data;
#line 4193
  p_j2k___33->m_specific_param.m_encoder.m_tlm_start = opj_stream_tell(p_stream___24);
#line 4195
  opj_write_bytes_LE(l_current_data___5, (OPJ_UINT32 )65365, (OPJ_UINT32 )2);
#line 4197
  l_current_data___5 += 2;
#line 4199
  opj_write_bytes_LE(l_current_data___5, l_tlm_size - 2U, (OPJ_UINT32 )2);
#line 4201
  l_current_data___5 += 2;
#line 4203
  opj_write_bytes_LE(l_current_data___5, (OPJ_UINT32 )0, (OPJ_UINT32 )1);
#line 4205
  l_current_data___5 ++;
#line 4207
  opj_write_bytes_LE(l_current_data___5, (OPJ_UINT32 )80, (OPJ_UINT32 )1);
#line 4209
  l_current_data___5 ++;
#line 4212
  __cil_tmp12___13 = opj_stream_write_data(p_stream___24, p_j2k___33->m_specific_param.m_encoder.m_header_tile_data,
                                           (OPJ_SIZE_T )l_tlm_size, p_manager___71);
  }
#line 4212
  if (__cil_tmp12___13 != (unsigned long )l_tlm_size) {
#line 4215
    return (0);
  }
#line 4218
  return (1);
}
}
#line 4221 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_sot(opj_j2k_t *p_j2k___34 , OPJ_BYTE *p_data___7 , OPJ_UINT32 total_data_size ,
                                  OPJ_UINT32 *p_data_written___2 , opj_stream_private_t *p_stream___25 ,
                                  opj_event_mgr_t *p_manager___72 ) 
{ 


  {
#line 4236
  if (total_data_size < 12U) {
    {
#line 4237
    opj_event_msg(p_manager___72, 1, "Not enough bytes in output buffer to write SOT marker\n");
    }
#line 4239
    return (0);
  }
  {
#line 4242
  opj_write_bytes_LE(p_data___7, (OPJ_UINT32 )65424, (OPJ_UINT32 )2);
#line 4244
  p_data___7 += 2;
#line 4246
  opj_write_bytes_LE(p_data___7, (OPJ_UINT32 )10, (OPJ_UINT32 )2);
#line 4248
  p_data___7 += 2;
#line 4250
  opj_write_bytes_LE(p_data___7, p_j2k___34->m_current_tile_number, (OPJ_UINT32 )2);
#line 4252
  p_data___7 += 2;
#line 4255
  p_data___7 += 4;
#line 4257
  opj_write_bytes_LE(p_data___7, p_j2k___34->m_specific_param.m_encoder.m_current_tile_part_number,
                     (OPJ_UINT32 )1);
#line 4260
  p_data___7 ++;
#line 4262
  opj_write_bytes_LE(p_data___7, (p_j2k___34->m_cp.tcps + p_j2k___34->m_current_tile_number)->m_nb_tile_parts,
                     (OPJ_UINT32 )1);
#line 4265
  p_data___7 ++;
#line 4276
  *p_data_written___2 = (OPJ_UINT32 )12;
  }
#line 4278
  return (1);
}
}
#line 4281 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_get_sot_values(OPJ_BYTE *p_header_data___15 , OPJ_UINT32 p_header_size___15 ,
                                       OPJ_UINT32 *p_tile_no , OPJ_UINT32 *p_tot_len ,
                                       OPJ_UINT32 *p_current_part , OPJ_UINT32 *p_num_parts ,
                                       opj_event_mgr_t *p_manager___73 ) 
{ 


  {
#line 4294
  if (p_header_size___15 != 8U) {
    {
#line 4295
    opj_event_msg(p_manager___73, 1, "Error reading SOT marker\n\345\225\005]U");
    }
#line 4296
    return (0);
  }
  {
#line 4299
  opj_read_bytes_LE(p_header_data___15, p_tile_no, (OPJ_UINT32 )2);
#line 4300
  p_header_data___15 += 2;
#line 4301
  opj_read_bytes_LE(p_header_data___15, p_tot_len, (OPJ_UINT32 )4);
#line 4302
  p_header_data___15 += 4;
#line 4303
  opj_read_bytes_LE(p_header_data___15, p_current_part, (OPJ_UINT32 )1);
#line 4304
  p_header_data___15 ++;
#line 4305
  opj_read_bytes_LE(p_header_data___15, p_num_parts, (OPJ_UINT32 )1);
#line 4306
  p_header_data___15 ++;
  }
#line 4307
  return (1);
}
}
#line 4310 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_sot(opj_j2k_t *p_j2k___35 , OPJ_BYTE *p_header_data___16 ,
                                 OPJ_UINT32 p_header_size___16 , opj_event_mgr_t *p_manager___74 ) 
{ 
  opj_cp_t *l_cp___9 ;
  opj_tcp_t *l_tcp___10 ;
  OPJ_UINT32 l_tot_len ;
  OPJ_UINT32 l_num_parts ;
  OPJ_UINT32 l_current_part ;
  OPJ_UINT32 l_tile_x ;
  OPJ_UINT32 l_tile_y ;
  OPJ_BOOL __cil_tmp14___16 ;
  void *__cil_tmp17___7 ;
  opj_tp_index_t *new_tp_index ;
  void *__cil_tmp19___5 ;
  void *__cil_tmp20___5 ;
  opj_tp_index_t *new_tp_index___0 ;
  void *__cil_tmp22___3 ;
  int tmp___243 ;

  {
  {
#line 4315
  l_cp___9 = (opj_cp_t *)0;
#line 4316
  l_tcp___10 = (opj_tcp_t *)0;
#line 4317
  l_num_parts = (OPJ_UINT32 )0;
#line 4326
  __cil_tmp14___16 = opj_j2k_get_sot_values(p_header_data___16, p_header_size___16,
                                            & p_j2k___35->m_current_tile_number, & l_tot_len,
                                            & l_current_part, & l_num_parts, p_manager___74);
  }
#line 4326
  if (! __cil_tmp14___16) {
    {
#line 4329
    opj_event_msg(p_manager___74, 1, "Error reading SOT marker\n");
    }
#line 4330
    return (0);
  }
#line 4337
  l_cp___9 = & p_j2k___35->m_cp;
#line 4340
  if (p_j2k___35->m_current_tile_number >= l_cp___9->tw * l_cp___9->th) {
    {
#line 4341
    opj_event_msg(p_manager___74, 1, "Invalid tile number %d\n", p_j2k___35->m_current_tile_number);
    }
#line 4343
    return (0);
  }
#line 4346
  l_tcp___10 = l_cp___9->tcps + p_j2k___35->m_current_tile_number;
#line 4347
  l_tile_x = p_j2k___35->m_current_tile_number % l_cp___9->tw;
#line 4348
  l_tile_y = p_j2k___35->m_current_tile_number / l_cp___9->tw;
#line 4350
  if (p_j2k___35->m_specific_param.m_decoder.m_tile_ind_to_dec < 0) {
    _L: 
#line 4363
    if (l_tcp___10->m_current_tile_part_number + 1 != (OPJ_INT32 )l_current_part) {
      {
#line 4364
      opj_event_msg(p_manager___74, 1, "Invalid tile part index for tile number %d. Got %d, expected %d\n",
                    p_j2k___35->m_current_tile_number, l_current_part, l_tcp___10->m_current_tile_part_number + 1);
      }
#line 4370
      return (0);
    }
  } else
#line 4350
  if (p_j2k___35->m_current_tile_number == (OPJ_UINT32 )p_j2k___35->m_specific_param.m_decoder.m_tile_ind_to_dec) {
#line 4350
    goto _L;
  }
#line 4374
  l_tcp___10->m_current_tile_part_number = (OPJ_INT32 )l_current_part;
#line 4408
  if (l_tot_len != 0U) {
#line 4408
    if (l_tot_len < 14U) {
#line 4409
      if (l_tot_len == 12U) {
        {
#line 4411
        opj_event_msg(p_manager___74, 2, "Empty SOT marker detected: Psot=%d.\n",
                      l_tot_len);
        }
      } else {
        {
#line 4414
        opj_event_msg(p_manager___74, 1, "Psot value is not correct regards to the JPEG2000 norm: %d.\n]U",
                      l_tot_len);
        }
#line 4416
        return (0);
      }
    }
  }
#line 4444
  if (! l_tot_len) {
    {
#line 4445
    opj_event_msg(p_manager___74, 4, "Psot value of the current tile-part is equal to zero, we assuming it is the last tile-part of the codestream.\n");
#line 4448
    p_j2k___35->m_specific_param.m_decoder.m_last_tile_part = 1;
    }
  }
#line 4451
  if (l_tcp___10->m_nb_tile_parts != 0U) {
#line 4451
    if (l_current_part >= l_tcp___10->m_nb_tile_parts) {
      {
#line 4453
      opj_event_msg(p_manager___74, 1, "In SOT marker, TPSot (%d) is not valid regards to the previous number of tile-part (%d), giving up\n",
                    l_current_part, l_tcp___10->m_nb_tile_parts);
#line 4457
      p_j2k___35->m_specific_param.m_decoder.m_last_tile_part = 1;
      }
#line 4458
      return (0);
    }
  }
#line 4461
  if (l_num_parts != 0U) {
#line 4463
    l_num_parts += p_j2k___35->m_specific_param.m_decoder.m_nb_tile_parts_correction;
#line 4466
    if (l_tcp___10->m_nb_tile_parts) {
#line 4467
      if (l_current_part >= l_tcp___10->m_nb_tile_parts) {
        {
#line 4468
        opj_event_msg(p_manager___74, 1, "In SOT marker, TPSot (%d) is not valid regards to the current number of tile-part (%d), giving up\n",
                      l_current_part, l_tcp___10->m_nb_tile_parts);
#line 4472
        p_j2k___35->m_specific_param.m_decoder.m_last_tile_part = 1;
        }
#line 4473
        return (0);
      }
    }
#line 4476
    if (l_current_part >= l_num_parts) {
      {
#line 4478
      opj_event_msg(p_manager___74, 1, "In SOT marker, TPSot (%d) is not valid regards to the current number of tile-part (header) (%d), giving up\n",
                    l_current_part, l_num_parts);
#line 4481
      p_j2k___35->m_specific_param.m_decoder.m_last_tile_part = 1;
      }
#line 4482
      return (0);
    }
#line 4484
    l_tcp___10->m_nb_tile_parts = l_num_parts;
  }
#line 4488
  if (l_tcp___10->m_nb_tile_parts) {
#line 4489
    if (l_tcp___10->m_nb_tile_parts == l_current_part + 1U) {
#line 4490
      p_j2k___35->m_specific_param.m_decoder.m_can_decode = (OPJ_BITFIELD )1;
    }
  }
#line 4495
  if (! p_j2k___35->m_specific_param.m_decoder.m_last_tile_part) {
#line 4497
    p_j2k___35->m_specific_param.m_decoder.m_sot_length = l_tot_len - 12U;
  } else {
#line 4501
    p_j2k___35->m_specific_param.m_decoder.m_sot_length = (OPJ_UINT32 )0;
  }
#line 4504
  p_j2k___35->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )16;
#line 4507
  if (p_j2k___35->m_specific_param.m_decoder.m_tile_ind_to_dec == -1) {
#line 4508
    if (l_tile_x < p_j2k___35->m_specific_param.m_decoder.m_start_tile_x) {
#line 4508
      tmp___243 = 1;
    } else
#line 4508
    if (l_tile_x >= p_j2k___35->m_specific_param.m_decoder.m_end_tile_x) {
#line 4508
      tmp___243 = 1;
    } else
#line 4508
    if (l_tile_y < p_j2k___35->m_specific_param.m_decoder.m_start_tile_y) {
#line 4508
      tmp___243 = 1;
    } else
#line 4508
    if (l_tile_y >= p_j2k___35->m_specific_param.m_decoder.m_end_tile_y) {
#line 4508
      tmp___243 = 1;
    } else {
#line 4508
      tmp___243 = 0;
    }
#line 4508
    p_j2k___35->m_specific_param.m_decoder.m_skip_data = (OPJ_BITFIELD )tmp___243;
  } else {
#line 4515
    p_j2k___35->m_specific_param.m_decoder.m_skip_data = (OPJ_BITFIELD )(p_j2k___35->m_current_tile_number != (OPJ_UINT32 )p_j2k___35->m_specific_param.m_decoder.m_tile_ind_to_dec);
  }
#line 4521
  if (p_j2k___35->cstr_index) {
#line 4523
    ((p_j2k___35->cstr_index)->tile_index + p_j2k___35->m_current_tile_number)->tileno = p_j2k___35->m_current_tile_number;
#line 4525
    ((p_j2k___35->cstr_index)->tile_index + p_j2k___35->m_current_tile_number)->current_tpsno = l_current_part;
#line 4528
    if (l_num_parts != 0U) {
#line 4529
      ((p_j2k___35->cstr_index)->tile_index + p_j2k___35->m_current_tile_number)->nb_tps = l_num_parts;
#line 4531
      ((p_j2k___35->cstr_index)->tile_index + p_j2k___35->m_current_tile_number)->current_nb_tps = l_num_parts;
#line 4534
      if (! ((p_j2k___35->cstr_index)->tile_index + p_j2k___35->m_current_tile_number)->tp_index) {
        {
#line 4535
        __cil_tmp17___7 = opj_calloc((size_t )l_num_parts, sizeof(opj_tp_index_t ));
#line 4535
        ((p_j2k___35->cstr_index)->tile_index + p_j2k___35->m_current_tile_number)->tp_index = (opj_tp_index_t *)__cil_tmp17___7;
        }
#line 4537
        if (! ((p_j2k___35->cstr_index)->tile_index + p_j2k___35->m_current_tile_number)->tp_index) {
          {
#line 4538
          opj_event_msg(p_manager___74, 1, "Not enough memory to read SOT marker. Tile index allocation failed\n");
          }
#line 4540
          return (0);
        }
      } else {
        {
#line 4543
        __cil_tmp19___5 = opj_realloc((void *)((p_j2k___35->cstr_index)->tile_index + p_j2k___35->m_current_tile_number)->tp_index,
                                      (unsigned long )l_num_parts * sizeof(opj_tp_index_t ));
#line 4543
        new_tp_index = (opj_tp_index_t *)__cil_tmp19___5;
        }
#line 4546
        if (! new_tp_index) {
          {
#line 4547
          opj_free((void *)((p_j2k___35->cstr_index)->tile_index + p_j2k___35->m_current_tile_number)->tp_index);
#line 4548
          ((p_j2k___35->cstr_index)->tile_index + p_j2k___35->m_current_tile_number)->tp_index = (opj_tp_index_t *)((void *)0);
#line 4549
          opj_event_msg(p_manager___74, 1, "Not enough memory to read SOT marker. Tile index allocation failed\n");
          }
#line 4551
          return (0);
        }
#line 4553
        ((p_j2k___35->cstr_index)->tile_index + p_j2k___35->m_current_tile_number)->tp_index = new_tp_index;
      }
    } else {
#line 4559
      if (! ((p_j2k___35->cstr_index)->tile_index + p_j2k___35->m_current_tile_number)->tp_index) {
        {
#line 4560
        ((p_j2k___35->cstr_index)->tile_index + p_j2k___35->m_current_tile_number)->current_nb_tps = (OPJ_UINT32 )10;
#line 4561
        __cil_tmp20___5 = opj_calloc((size_t )((p_j2k___35->cstr_index)->tile_index + p_j2k___35->m_current_tile_number)->current_nb_tps,
                                     sizeof(opj_tp_index_t ));
#line 4561
        ((p_j2k___35->cstr_index)->tile_index + p_j2k___35->m_current_tile_number)->tp_index = (opj_tp_index_t *)__cil_tmp20___5;
        }
#line 4565
        if (! ((p_j2k___35->cstr_index)->tile_index + p_j2k___35->m_current_tile_number)->tp_index) {
          {
#line 4566
          ((p_j2k___35->cstr_index)->tile_index + p_j2k___35->m_current_tile_number)->current_nb_tps = (OPJ_UINT32 )0;
#line 4567
          opj_event_msg(p_manager___74, 1, "Not enough memory to read SOT marker. Tile index allocation failed\n");
          }
#line 4569
          return (0);
        }
      }
#line 4573
      if (l_current_part >= ((p_j2k___35->cstr_index)->tile_index + p_j2k___35->m_current_tile_number)->current_nb_tps) {
        {
#line 4576
        ((p_j2k___35->cstr_index)->tile_index + p_j2k___35->m_current_tile_number)->current_nb_tps = l_current_part + 1U;
#line 4578
        __cil_tmp22___3 = opj_realloc((void *)((p_j2k___35->cstr_index)->tile_index + p_j2k___35->m_current_tile_number)->tp_index,
                                      (unsigned long )((p_j2k___35->cstr_index)->tile_index + p_j2k___35->m_current_tile_number)->current_nb_tps * sizeof(opj_tp_index_t ));
#line 4578
        new_tp_index___0 = (opj_tp_index_t *)__cil_tmp22___3;
        }
#line 4582
        if (! new_tp_index___0) {
          {
#line 4583
          opj_free((void *)((p_j2k___35->cstr_index)->tile_index + p_j2k___35->m_current_tile_number)->tp_index);
#line 4584
          ((p_j2k___35->cstr_index)->tile_index + p_j2k___35->m_current_tile_number)->tp_index = (opj_tp_index_t *)((void *)0);
#line 4585
          ((p_j2k___35->cstr_index)->tile_index + p_j2k___35->m_current_tile_number)->current_nb_tps = (OPJ_UINT32 )0;
#line 4586
          opj_event_msg(p_manager___74, 1, "Not enough memory to read SOT marker. Tile index allocation failed\n");
          }
#line 4588
          return (0);
        }
#line 4590
        ((p_j2k___35->cstr_index)->tile_index + p_j2k___35->m_current_tile_number)->tp_index = new_tp_index___0;
      }
    }
  }
#line 4626
  return (1);
}
}
#line 4632 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_plt_in_memory(opj_j2k_t *p_j2k___36 , opj_tcd_marker_info_t *marker_info ,
                                            OPJ_BYTE *p_data___8 , OPJ_UINT32 *p_data_written___3 ,
                                            opj_event_mgr_t *p_manager___75 ) 
{ 
  OPJ_BYTE Zplt ;
  OPJ_UINT16 Lplt ;
  OPJ_BYTE *p_data_start ;
  OPJ_BYTE *p_data_Lplt ;
  OPJ_UINT32 i___45 ;
  OPJ_BYTE var_bytes[5] ;
  OPJ_UINT8 var_bytes_size ;
  OPJ_UINT32 packet_size ;

  {
  {
#line 4638
  Zplt = (OPJ_BYTE )0;
#line 4640
  p_data_start = p_data___8;
#line 4641
  p_data_Lplt = p_data___8 + 2;
#line 4646
  opj_write_bytes_LE(p_data___8, (OPJ_UINT32 )65368, (OPJ_UINT32 )2);
#line 4647
  p_data___8 += 2;
#line 4650
  p_data___8 += 2;
#line 4652
  opj_write_bytes_LE(p_data___8, (OPJ_UINT32 )Zplt, (OPJ_UINT32 )1);
#line 4653
  p_data___8 ++;
#line 4655
  Lplt = (OPJ_UINT16 )3;
#line 4657
  i___45 = (OPJ_UINT32 )0;
  }
  {
#line 4657
  while (1) {
    while_continue: /* CIL Label */ ;

#line 4657
    if (! (i___45 < marker_info->packet_count)) {
#line 4657
      goto while_break;
    }
#line 4659
    var_bytes_size = (OPJ_UINT8 )0;
#line 4660
    packet_size = *(marker_info->p_packet_size + i___45);
#line 4663
    var_bytes[var_bytes_size] = (OPJ_BYTE )(packet_size & 127U);
#line 4664
    var_bytes_size = (OPJ_UINT8 )((int )var_bytes_size + 1);
#line 4665
    packet_size >>= 7;
    {
#line 4666
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 4666
      if (! (packet_size > 0U)) {
#line 4666
        goto while_break___0;
      }
#line 4667
      var_bytes[var_bytes_size] = (OPJ_BYTE )((packet_size & 127U) | 128U);
#line 4668
      var_bytes_size = (OPJ_UINT8 )((int )var_bytes_size + 1);
#line 4669
      packet_size >>= 7;
    }
    while_break___3: /* CIL Label */ ;
    }

    while_break___0: ;
#line 4674
    if ((int )Lplt + (int )var_bytes_size > 65535) {
#line 4675
      if ((int )Zplt == 255) {
        {
#line 4676
        opj_event_msg(p_manager___75, 1, "More than 255 PLT markers would be needed for current tile-part !\n");
        }
#line 4678
        return (0);
      }
      {
#line 4682
      opj_write_bytes_LE(p_data_Lplt, (OPJ_UINT32 )Lplt, (OPJ_UINT32 )2);
#line 4685
      opj_write_bytes_LE(p_data___8, (OPJ_UINT32 )65368, (OPJ_UINT32 )2);
#line 4686
      p_data___8 += 2;
#line 4689
      p_data_Lplt = p_data___8;
#line 4690
      p_data___8 += 2;
#line 4692
      Zplt = (OPJ_BYTE )((int )Zplt + 1);
#line 4693
      opj_write_bytes_LE(p_data___8, (OPJ_UINT32 )Zplt, (OPJ_UINT32 )1);
#line 4694
      p_data___8 ++;
#line 4696
      Lplt = (OPJ_UINT16 )3;
      }
    }
#line 4699
    Lplt = (OPJ_UINT16 )((int )Lplt + (int )var_bytes_size);
    {
#line 4702
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 4702
      if (! ((int )var_bytes_size > 0)) {
#line 4702
        goto while_break___1;
      }
      {
#line 4703
      opj_write_bytes_LE(p_data___8, (OPJ_UINT32 )var_bytes[(int )var_bytes_size - 1],
                         (OPJ_UINT32 )1);
#line 4704
      p_data___8 ++;
#line 4702
      var_bytes_size = (OPJ_UINT8 )((int )var_bytes_size - 1);
      }
    }
    while_break___4: /* CIL Label */ ;
    }

    while_break___1: 
#line 4657
    i___45 ++;
  }
  while_break___2: /* CIL Label */ ;
  }

  while_break: 
  {
#line 4708
  *p_data_written___3 = (OPJ_UINT32 )(p_data___8 - p_data_start);
#line 4711
  opj_write_bytes_LE(p_data_Lplt, (OPJ_UINT32 )Lplt, (OPJ_UINT32 )2);
  }
#line 4713
  return (1);
}
}
#line 4716 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_sod(opj_j2k_t *p_j2k___37 , opj_tcd_t *p_tile_coder ,
                                  OPJ_BYTE *p_data___9 , OPJ_UINT32 *p_data_written___4 ,
                                  OPJ_UINT32 total_data_size___0 , opj_stream_private_t *p_stream___26 ,
                                  opj_event_mgr_t *p_manager___76 ) 
{ 
  opj_codestream_info_t *l_cstr_info ;
  OPJ_UINT32 l_remaining_data ;
  opj_tcd_marker_info_t *marker_info___0 ;
  OPJ_BOOL __cil_tmp16___8 ;
  OPJ_UINT32 l_data_written_PLT ;
  OPJ_BYTE *p_PLT_buffer ;
  void *__cil_tmp19___6 ;
  OPJ_BOOL __cil_tmp20___6 ;

  {
#line 4725
  l_cstr_info = (opj_codestream_info_t *)0;
#line 4727
  marker_info___0 = (opj_tcd_marker_info_t *)((void *)0);
#line 4736
  if (total_data_size___0 < 4U) {
    {
#line 4737
    opj_event_msg(p_manager___76, 1, "Not enough bytes in output buffer to write SOD marker\n");
    }
#line 4739
    return (0);
  }
  {
#line 4742
  opj_write_bytes_LE(p_data___9, (OPJ_UINT32 )65427, (OPJ_UINT32 )2);
#line 4746
  l_remaining_data = total_data_size___0 - 4U;
#line 4749
  p_tile_coder->tp_num = p_j2k___37->m_specific_param.m_encoder.m_current_poc_tile_part_number;
#line 4751
  p_tile_coder->cur_tp_num = p_j2k___37->m_specific_param.m_encoder.m_current_tile_part_number;
  }
#line 4782
  if (p_j2k___37->m_specific_param.m_encoder.m_current_tile_part_number == 0U) {
#line 4783
    ((p_tile_coder->tcd_image)->tiles)->packno = (OPJ_UINT32 )0;
  }
#line 4791
  *p_data_written___4 = (OPJ_UINT32 )0;
#line 4793
  if (p_j2k___37->m_specific_param.m_encoder.m_PLT) {
    {
#line 4794
    marker_info___0 = opj_tcd_marker_info_create(p_j2k___37->m_specific_param.m_encoder.m_PLT);
    }
#line 4796
    if ((unsigned long )marker_info___0 == (unsigned long )((void *)0)) {
      {
#line 4797
      opj_event_msg(p_manager___76, 1, "Cannot encode tile: opj_tcd_marker_info_create() failed\n\220");
      }
#line 4799
      return (0);
    }
  }
  {
#line 4805
  l_remaining_data -= p_j2k___37->m_specific_param.m_encoder.m_reserved_bytes_for_PLT;
#line 4807
  __cil_tmp16___8 = opj_tcd_encode_tile(p_tile_coder, p_j2k___37->m_current_tile_number,
                                        p_data___9 + 2, p_data_written___4, l_remaining_data,
                                        l_cstr_info, marker_info___0, p_manager___76);
  }
#line 4807
  if (! __cil_tmp16___8) {
    {
#line 4812
    opj_event_msg(p_manager___76, 1, "Cannot encode tile\n");
#line 4813
    opj_tcd_marker_info_destroy(marker_info___0);
    }
#line 4814
    return (0);
  }
#line 4818
  *p_data_written___4 += 2U;
#line 4820
  if (p_j2k___37->m_specific_param.m_encoder.m_PLT) {
    {
#line 4821
    l_data_written_PLT = (OPJ_UINT32 )0;
#line 4822
    __cil_tmp19___6 = opj_malloc((size_t )p_j2k___37->m_specific_param.m_encoder.m_reserved_bytes_for_PLT);
#line 4822
    p_PLT_buffer = (OPJ_BYTE *)__cil_tmp19___6;
    }
#line 4824
    if (! p_PLT_buffer) {
      {
#line 4825
      opj_event_msg(p_manager___76, 1, "Cannot allocate memory\n");
#line 4826
      opj_tcd_marker_info_destroy(marker_info___0);
      }
#line 4827
      return (0);
    }
    {
#line 4829
    __cil_tmp20___6 = opj_j2k_write_plt_in_memory(p_j2k___37, marker_info___0, p_PLT_buffer,
                                                  & l_data_written_PLT, p_manager___76);
    }
#line 4829
    if (! __cil_tmp20___6) {
      {
#line 4834
      opj_tcd_marker_info_destroy(marker_info___0);
#line 4835
      opj_free((void *)p_PLT_buffer);
      }
#line 4836
      return (0);
    }
    {
#line 4843
    memmove((void *)(p_data___9 + l_data_written_PLT), (void const   *)p_data___9,
            (unsigned long )*p_data_written___4);
#line 4844
    memcpy((void *)p_data___9, (void const   *)p_PLT_buffer, (unsigned long )l_data_written_PLT);
#line 4845
    opj_free((void *)p_PLT_buffer);
#line 4846
    *p_data_written___4 += l_data_written_PLT;
    }
  }
  {
#line 4849
  opj_tcd_marker_info_destroy(marker_info___0);
  }
#line 4851
  return (1);
}
}
#line 4854 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_sod(opj_j2k_t *p_j2k___38 , opj_stream_private_t *p_stream___27 ,
                                 opj_event_mgr_t *p_manager___77 ) 
{ 
  OPJ_SIZE_T l_current_read_size ;
  opj_codestream_index_t *l_cstr_index ;
  OPJ_BYTE **l_current_data___6 ;
  opj_tcp_t *l_tcp___11 ;
  OPJ_UINT32 *l_tile_len ;
  OPJ_BOOL l_sot_length_pb_detected ;
  OPJ_OFF_T __cil_tmp13___13 ;
  OPJ_OFF_T __cil_tmp14___19 ;
  void *__cil_tmp15___12 ;
  OPJ_BYTE *l_new_current_data ;
  void *__cil_tmp17___9 ;
  OPJ_OFF_T l_current_pos ;
  OPJ_OFF_T __cil_tmp19___7 ;
  OPJ_UINT32 l_current_tile_part ;
  OPJ_BOOL __cil_tmp21___2 ;

  {
#line 4860
  l_cstr_index = (opj_codestream_index_t *)0;
#line 4861
  l_current_data___6 = (OPJ_BYTE **)0;
#line 4862
  l_tcp___11 = (opj_tcp_t *)0;
#line 4863
  l_tile_len = (OPJ_UINT32 *)0;
#line 4864
  l_sot_length_pb_detected = 0;
#line 4871
  l_tcp___11 = p_j2k___38->m_cp.tcps + p_j2k___38->m_current_tile_number;
#line 4873
  if (p_j2k___38->m_specific_param.m_decoder.m_last_tile_part) {
    {
#line 4878
    __cil_tmp13___13 = opj_stream_get_number_byte_left(p_stream___27);
#line 4878
    p_j2k___38->m_specific_param.m_decoder.m_sot_length = (OPJ_UINT32 )(__cil_tmp13___13 - 2L);
    }
  } else
#line 4882
  if (p_j2k___38->m_specific_param.m_decoder.m_sot_length >= 2U) {
#line 4883
    p_j2k___38->m_specific_param.m_decoder.m_sot_length -= 2U;
  }
#line 4889
  l_current_data___6 = & l_tcp___11->m_data;
#line 4890
  l_tile_len = & l_tcp___11->m_data_size;
#line 4893
  if (p_j2k___38->m_specific_param.m_decoder.m_sot_length) {
    {
#line 4896
    __cil_tmp14___19 = opj_stream_get_number_byte_left(p_stream___27);
    }
#line 4896
    if ((OPJ_OFF_T )p_j2k___38->m_specific_param.m_decoder.m_sot_length > __cil_tmp14___19) {
      {
#line 4898
      opj_event_msg(p_manager___77, 1, "Tile part length size inconsistent with stream length\n");
      }
#line 4900
      return (0);
    }
#line 4902
    if (p_j2k___38->m_specific_param.m_decoder.m_sot_length > 4294967293U) {
      {
#line 4904
      opj_event_msg(p_manager___77, 1, "p_j2k->m_specific_param.m_decoder.m_sot_length > UINT_MAX - OPJ_COMMON_CBLK_DATA_EXTRA\227\005]U");
      }
#line 4907
      return (0);
    }
#line 4912
    if (! *l_current_data___6) {
      {
#line 4916
      __cil_tmp15___12 = opj_malloc((size_t )(p_j2k___38->m_specific_param.m_decoder.m_sot_length + 2U));
#line 4916
      *l_current_data___6 = (OPJ_BYTE *)__cil_tmp15___12;
      }
    } else {
#line 4920
      if (*l_tile_len > 4294967293U - p_j2k___38->m_specific_param.m_decoder.m_sot_length) {
        {
#line 4922
        opj_event_msg(p_manager___77, 1, "*l_tile_len > UINT_MAX - OPJ_COMMON_CBLK_DATA_EXTRA - p_j2k->m_specific_param.m_decoder.m_sot_length\220");
        }
#line 4925
        return (0);
      }
      {
#line 4928
      __cil_tmp17___9 = opj_realloc((void *)*l_current_data___6, (size_t )((*l_tile_len + p_j2k___38->m_specific_param.m_decoder.m_sot_length) + 2U));
#line 4928
      l_new_current_data = (OPJ_BYTE *)__cil_tmp17___9;
      }
#line 4931
      if (! l_new_current_data) {
        {
#line 4932
        opj_free((void *)*l_current_data___6);
        }
      }
#line 4938
      *l_current_data___6 = l_new_current_data;
    }
#line 4941
    if ((unsigned long )*l_current_data___6 == (unsigned long )((OPJ_BYTE *)0)) {
      {
#line 4942
      opj_event_msg(p_manager___77, 1, "Not enough memory to decode tile\n");
      }
#line 4943
      return (0);
    }
  } else {
#line 4946
    l_sot_length_pb_detected = 1;
  }
#line 4950
  l_cstr_index = p_j2k___38->cstr_index;
#line 4951
  if (l_cstr_index) {
    {
#line 4952
    __cil_tmp19___7 = opj_stream_tell(p_stream___27);
#line 4952
    l_current_pos = __cil_tmp19___7 - 2L;
#line 4954
    l_current_tile_part = (l_cstr_index->tile_index + p_j2k___38->m_current_tile_number)->current_tpsno;
#line 4956
    ((l_cstr_index->tile_index + p_j2k___38->m_current_tile_number)->tp_index + l_current_tile_part)->end_header = l_current_pos;
#line 4959
    ((l_cstr_index->tile_index + p_j2k___38->m_current_tile_number)->tp_index + l_current_tile_part)->end_pos = (l_current_pos + (long )p_j2k___38->m_specific_param.m_decoder.m_sot_length) + 2L;
#line 4963
    __cil_tmp21___2 = opj_j2k_add_tlmarker(p_j2k___38->m_current_tile_number, l_cstr_index,
                                           (OPJ_UINT32 )65427, l_current_pos, p_j2k___38->m_specific_param.m_decoder.m_sot_length + 2U);
    }
#line 4963
    if (0 == __cil_tmp21___2) {
      {
#line 4968
      opj_event_msg(p_manager___77, 1, "Not enough memory to add tl marker\n\005]U");
      }
#line 4969
      return (0);
    }
  }
#line 4976
  if (! l_sot_length_pb_detected) {
    {
#line 4977
    l_current_read_size = opj_stream_read_data(p_stream___27, *l_current_data___6 + *l_tile_len,
                                               (OPJ_SIZE_T )p_j2k___38->m_specific_param.m_decoder.m_sot_length,
                                               p_manager___77);
    }
  } else {
#line 4983
    l_current_read_size = (OPJ_SIZE_T )0;
  }
#line 4986
  if (l_current_read_size != (unsigned long )p_j2k___38->m_specific_param.m_decoder.m_sot_length) {
#line 4987
    p_j2k___38->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )64;
  } else {
#line 4989
    p_j2k___38->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )8;
  }
#line 4992
  *l_tile_len += (OPJ_UINT32 )l_current_read_size;
#line 4994
  return (1);
}
}
#line 4997 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_rgn(opj_j2k_t *p_j2k___39 , OPJ_UINT32 p_tile_no___0 ,
                                  OPJ_UINT32 p_comp_no___3 , OPJ_UINT32 nb_comps ,
                                  opj_stream_private_t *p_stream___28 , opj_event_mgr_t *p_manager___78 ) 
{ 
  OPJ_BYTE *l_current_data___7 ;
  OPJ_UINT32 l_rgn_size ;
  opj_cp_t *l_cp___10 ;
  opj_tcp_t *l_tcp___12 ;
  opj_tccp_t *l_tccp___0 ;
  OPJ_UINT32 l_comp_room___3 ;
  OPJ_SIZE_T __cil_tmp16___9 ;

  {
#line 5005
  l_current_data___7 = (OPJ_BYTE *)0;
#line 5007
  l_cp___10 = (opj_cp_t *)0;
#line 5008
  l_tcp___12 = (opj_tcp_t *)0;
#line 5009
  l_tccp___0 = (opj_tccp_t *)0;
#line 5017
  l_cp___10 = & p_j2k___39->m_cp;
#line 5018
  l_tcp___12 = l_cp___10->tcps + p_tile_no___0;
#line 5019
  l_tccp___0 = l_tcp___12->tccps + p_comp_no___3;
#line 5021
  if (nb_comps <= 256U) {
#line 5022
    l_comp_room___3 = (OPJ_UINT32 )1;
  } else {
#line 5024
    l_comp_room___3 = (OPJ_UINT32 )2;
  }
  {
#line 5027
  l_rgn_size = 6U + l_comp_room___3;
#line 5029
  l_current_data___7 = p_j2k___39->m_specific_param.m_encoder.m_header_tile_data;
#line 5031
  opj_write_bytes_LE(l_current_data___7, (OPJ_UINT32 )65374, (OPJ_UINT32 )2);
#line 5033
  l_current_data___7 += 2;
#line 5035
  opj_write_bytes_LE(l_current_data___7, l_rgn_size - 2U, (OPJ_UINT32 )2);
#line 5037
  l_current_data___7 += 2;
#line 5039
  opj_write_bytes_LE(l_current_data___7, p_comp_no___3, l_comp_room___3);
#line 5041
  l_current_data___7 += l_comp_room___3;
#line 5043
  opj_write_bytes_LE(l_current_data___7, (OPJ_UINT32 )0, (OPJ_UINT32 )1);
#line 5045
  l_current_data___7 ++;
#line 5047
  opj_write_bytes_LE(l_current_data___7, (OPJ_UINT32 )l_tccp___0->roishift, (OPJ_UINT32 )1);
#line 5049
  l_current_data___7 ++;
#line 5051
  __cil_tmp16___9 = opj_stream_write_data(p_stream___28, p_j2k___39->m_specific_param.m_encoder.m_header_tile_data,
                                          (OPJ_SIZE_T )l_rgn_size, p_manager___78);
  }
#line 5051
  if (__cil_tmp16___9 != (unsigned long )l_rgn_size) {
#line 5054
    return (0);
  }
#line 5057
  return (1);
}
}
#line 5060 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_eoc(opj_j2k_t *p_j2k___40 , opj_stream_private_t *p_stream___29 ,
                                  opj_event_mgr_t *p_manager___79 ) 
{ 
  OPJ_SIZE_T __cil_tmp7___19 ;
  OPJ_BOOL __cil_tmp8___32 ;

  {
  {
#line 5070
  opj_write_bytes_LE(p_j2k___40->m_specific_param.m_encoder.m_header_tile_data, (OPJ_UINT32 )65497,
                     (OPJ_UINT32 )2);
#line 5081
  __cil_tmp7___19 = opj_stream_write_data(p_stream___29, p_j2k___40->m_specific_param.m_encoder.m_header_tile_data,
                                          (OPJ_SIZE_T )2, p_manager___79);
  }
#line 5081
  if (__cil_tmp7___19 != 2UL) {
#line 5083
    return (0);
  }
  {
#line 5086
  __cil_tmp8___32 = opj_stream_flush(p_stream___29, p_manager___79);
  }
#line 5086
  if (! __cil_tmp8___32) {
#line 5087
    return (0);
  }
#line 5090
  return (1);
}
}
#line 5101 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_rgn(opj_j2k_t *p_j2k___41 , OPJ_BYTE *p_header_data___17 ,
                                 OPJ_UINT32 p_header_size___17 , opj_event_mgr_t *p_manager___80 ) 
{ 
  OPJ_UINT32 l_nb_comp___5 ;
  opj_image_t *l_image___6 ;
  opj_cp_t *l_cp___11 ;
  opj_tcp_t *l_tcp___13 ;
  OPJ_UINT32 l_comp_room___4 ;
  OPJ_UINT32 l_comp_no___1 ;
  OPJ_UINT32 l_roi_sty ;
  opj_tcp_t *tmp___261 ;

  {
#line 5108
  l_image___6 = (opj_image_t *)0;
#line 5110
  l_cp___11 = (opj_cp_t *)0;
#line 5111
  l_tcp___13 = (opj_tcp_t *)0;
#line 5119
  l_image___6 = p_j2k___41->m_private_image;
#line 5120
  l_nb_comp___5 = l_image___6->numcomps;
#line 5122
  if (l_nb_comp___5 <= 256U) {
#line 5123
    l_comp_room___4 = (OPJ_UINT32 )1;
  } else {
#line 5125
    l_comp_room___4 = (OPJ_UINT32 )2;
  }
#line 5128
  if (p_header_size___17 != 2U + l_comp_room___4) {
    {
#line 5129
    opj_event_msg(p_manager___80, 1, "Error reading RGN marker\n\355\227\005]U");
    }
#line 5130
    return (0);
  }
#line 5133
  l_cp___11 = & p_j2k___41->m_cp;
#line 5134
  if (p_j2k___41->m_specific_param.m_decoder.m_state == 16U) {
#line 5134
    tmp___261 = l_cp___11->tcps + p_j2k___41->m_current_tile_number;
  } else {
#line 5134
    tmp___261 = p_j2k___41->m_specific_param.m_decoder.m_default_tcp;
  }
  {
#line 5134
  l_tcp___13 = tmp___261;
#line 5138
  opj_read_bytes_LE(p_header_data___17, & l_comp_no___1, l_comp_room___4);
#line 5139
  p_header_data___17 += l_comp_room___4;
#line 5140
  opj_read_bytes_LE(p_header_data___17, & l_roi_sty, (OPJ_UINT32 )1);
#line 5142
  p_header_data___17 ++;
  }
#line 5160
  if (l_comp_no___1 >= l_nb_comp___5) {
    {
#line 5161
    opj_event_msg(p_manager___80, 1, "bad component number in RGN (%d when there are only %d)\n\230\001",
                  l_comp_no___1, l_nb_comp___5);
    }
#line 5164
    return (0);
  }
  {
#line 5167
  opj_read_bytes_LE(p_header_data___17, (OPJ_UINT32 *)(& (l_tcp___13->tccps + l_comp_no___1)->roishift),
                    (OPJ_UINT32 )1);
#line 5169
  p_header_data___17 ++;
  }
#line 5171
  return (1);
}
}
#line 5175 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_FLOAT32 opj_j2k_get_tp_stride(opj_tcp_t *p_tcp___0 ) 
{ 


  {
#line 5177
  return ((OPJ_FLOAT32 )((p_tcp___0->m_nb_tile_parts - 1U) * 14U));
}
}
#line 5180 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_FLOAT32 opj_j2k_get_default_stride(opj_tcp_t *p_tcp___1 ) 
{ 


  {
#line 5183
  return ((OPJ_FLOAT32 )0);
}
}
#line 5186 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_update_rates(opj_j2k_t *p_j2k___42 , opj_stream_private_t *p_stream___30 ,
                                     opj_event_mgr_t *p_manager___81 ) 
{ 
  opj_cp_t *l_cp___12 ;
  opj_image_t *l_image___7 ;
  opj_tcp_t *l_tcp___14 ;
  opj_image_comp_t *l_img_comp___1 ;
  OPJ_UINT32 i___46 ;
  OPJ_UINT32 j___3 ;
  OPJ_UINT32 k___1 ;
  OPJ_INT32 l_x0 ;
  OPJ_INT32 l_y0 ;
  OPJ_INT32 l_x1 ;
  OPJ_INT32 l_y1 ;
  OPJ_FLOAT32 *l_rates ;
  OPJ_FLOAT32 l_sot_remove ;
  OPJ_UINT32 l_bits_empty ;
  OPJ_UINT32 l_size_pixel ;
  OPJ_UINT32 l_tile_size ;
  OPJ_UINT32 l_last_res ;
  OPJ_FLOAT32 (*l_tp_stride_func)(opj_tcp_t * ) ;
  OPJ_OFF_T __cil_tmp25___0 ;
  OPJ_FLOAT32 l_offset ;
  OPJ_FLOAT32 __cil_tmp27 ;
  OPJ_UINT32 __cil_tmp32___0 ;
  OPJ_UINT32 __cil_tmp33___0 ;
  OPJ_UINT32 __cil_tmp34___0 ;
  void *__cil_tmp35___0 ;
  void *__cil_tmp36___0 ;

  {
  {
#line 5190
  l_cp___12 = (opj_cp_t *)0;
#line 5191
  l_image___7 = (opj_image_t *)0;
#line 5192
  l_tcp___14 = (opj_tcp_t *)0;
#line 5193
  l_img_comp___1 = (opj_image_comp_t *)0;
#line 5197
  l_rates = (OPJ_FLOAT32 *)0;
#line 5200
  l_tile_size = (OPJ_UINT32 )0;
#line 5202
  l_tp_stride_func = (OPJ_FLOAT32 (*)(opj_tcp_t * ))0;
#line 5211
  l_cp___12 = & p_j2k___42->m_cp;
#line 5212
  l_image___7 = p_j2k___42->m_private_image;
#line 5213
  l_tcp___14 = l_cp___12->tcps;
#line 5215
  l_bits_empty = (8U * (l_image___7->comps)->dx) * (l_image___7->comps)->dy;
#line 5216
  l_size_pixel = l_image___7->numcomps * (l_image___7->comps)->prec;
#line 5217
  __cil_tmp25___0 = opj_stream_tell(p_stream___30);
#line 5217
  l_sot_remove = (OPJ_FLOAT32 )__cil_tmp25___0 / (OPJ_FLOAT32 )(l_cp___12->th * l_cp___12->tw);
  }
#line 5220
  if (l_cp___12->m_specific_param.m_enc.m_tp_on) {
#line 5221
    l_tp_stride_func = & opj_j2k_get_tp_stride;
  } else {
#line 5223
    l_tp_stride_func = & opj_j2k_get_default_stride;
  }
#line 5226
  i___46 = (OPJ_UINT32 )0;
  {
#line 5226
  while (1) {
    while_continue: /* CIL Label */ ;

#line 5226
    if (! (i___46 < l_cp___12->th)) {
#line 5226
      goto while_break;
    }
#line 5227
    j___3 = (OPJ_UINT32 )0;
    {
#line 5227
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 5227
      if (! (j___3 < l_cp___12->tw)) {
#line 5227
        goto while_break___0;
      }
      {
#line 5228
      __cil_tmp27 = (*l_tp_stride_func)(l_tcp___14);
#line 5228
      l_offset = __cil_tmp27 / (OPJ_FLOAT32 )l_tcp___14->numlayers;
#line 5232
      l_x0 = opj_int_max((OPJ_INT32 )(l_cp___12->tx0 + j___3 * l_cp___12->tdx), (OPJ_INT32 )l_image___7->x0);
#line 5234
      l_y0 = opj_int_max((OPJ_INT32 )(l_cp___12->ty0 + i___46 * l_cp___12->tdy), (OPJ_INT32 )l_image___7->y0);
#line 5236
      l_x1 = opj_int_min((OPJ_INT32 )(l_cp___12->tx0 + (j___3 + 1U) * l_cp___12->tdx),
                         (OPJ_INT32 )l_image___7->x1);
#line 5238
      l_y1 = opj_int_min((OPJ_INT32 )(l_cp___12->ty0 + (i___46 + 1U) * l_cp___12->tdy),
                         (OPJ_INT32 )l_image___7->y1);
#line 5241
      l_rates = l_tcp___14->rates;
      }
#line 5244
      if (*l_rates > 0.f) {
#line 5245
        *l_rates = (OPJ_FLOAT32 )((l_size_pixel * (OPJ_UINT32 )(l_x1 - l_x0)) * (OPJ_UINT32 )(l_y1 - l_y0)) / (*l_rates * (OPJ_FLOAT32 )l_bits_empty) - l_offset;
      }
#line 5254
      l_rates ++;
#line 5256
      k___1 = (OPJ_UINT32 )1;
      {
#line 5256
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 5256
        if (! (k___1 < l_tcp___14->numlayers)) {
#line 5256
          goto while_break___1;
        }
#line 5257
        if (*l_rates > 0.f) {
#line 5258
          *l_rates = (OPJ_FLOAT32 )((l_size_pixel * (OPJ_UINT32 )(l_x1 - l_x0)) * (OPJ_UINT32 )(l_y1 - l_y0)) / (*l_rates * (OPJ_FLOAT32 )l_bits_empty) - l_offset;
        }
#line 5267
        l_rates ++;
#line 5256
        k___1 ++;
      }
      while_break___8: /* CIL Label */ ;
      }

      while_break___1: 
#line 5270
      l_tcp___14 ++;
#line 5227
      j___3 ++;
    }
    while_break___7: /* CIL Label */ ;
    }

    while_break___0: 
#line 5226
    i___46 ++;
  }
  while_break___6: /* CIL Label */ ;
  }

  while_break: 
#line 5275
  l_tcp___14 = l_cp___12->tcps;
#line 5277
  i___46 = (OPJ_UINT32 )0;
  {
#line 5277
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 5277
    if (! (i___46 < l_cp___12->th)) {
#line 5277
      goto while_break___2;
    }
#line 5278
    j___3 = (OPJ_UINT32 )0;
    {
#line 5278
    while (1) {
      while_continue___3: /* CIL Label */ ;

#line 5278
      if (! (j___3 < l_cp___12->tw)) {
#line 5278
        goto while_break___3;
      }
#line 5279
      l_rates = l_tcp___14->rates;
#line 5281
      if (*l_rates > 0.f) {
#line 5282
        *l_rates -= l_sot_remove;
#line 5284
        if (*l_rates < 30.f) {
#line 5285
          *l_rates = 30.f;
        }
      }
#line 5289
      l_rates ++;
#line 5291
      l_last_res = l_tcp___14->numlayers - 1U;
#line 5293
      k___1 = (OPJ_UINT32 )1;
      {
#line 5293
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 5293
        if (! (k___1 < l_last_res)) {
#line 5293
          goto while_break___4;
        }
#line 5295
        if (*l_rates > 0.f) {
#line 5296
          *l_rates -= l_sot_remove;
#line 5298
          if (*l_rates < *(l_rates - 1) + 10.f) {
#line 5299
            *l_rates = *(l_rates - 1) + 20.f;
          }
        }
#line 5303
        l_rates ++;
#line 5293
        k___1 ++;
      }
      while_break___11: /* CIL Label */ ;
      }

      while_break___4: ;
#line 5306
      if (*l_rates > 0.f) {
#line 5307
        *l_rates -= l_sot_remove + 2.f;
#line 5309
        if (*l_rates < *(l_rates - 1) + 10.f) {
#line 5310
          *l_rates = *(l_rates - 1) + 20.f;
        }
      }
#line 5314
      l_tcp___14 ++;
#line 5278
      j___3 ++;
    }
    while_break___10: /* CIL Label */ ;
    }

    while_break___3: 
#line 5277
    i___46 ++;
  }
  while_break___9: /* CIL Label */ ;
  }

  while_break___2: 
#line 5318
  l_img_comp___1 = l_image___7->comps;
#line 5319
  l_tile_size = (OPJ_UINT32 )0;
#line 5321
  i___46 = (OPJ_UINT32 )0;
  {
#line 5321
  while (1) {
    while_continue___5: /* CIL Label */ ;

#line 5321
    if (! (i___46 < l_image___7->numcomps)) {
#line 5321
      goto while_break___5;
    }
    {
#line 5322
    __cil_tmp33___0 = opj_uint_ceildiv(l_cp___12->tdy, l_img_comp___1->dy);
#line 5322
    __cil_tmp32___0 = opj_uint_ceildiv(l_cp___12->tdx, l_img_comp___1->dx);
#line 5322
    l_tile_size += (__cil_tmp32___0 * __cil_tmp33___0) * l_img_comp___1->prec;
#line 5329
    l_img_comp___1 ++;
#line 5321
    i___46 ++;
    }
  }
  while_break___12: /* CIL Label */ ;
  }

  while_break___5: 
  {
#line 5338
  l_tile_size = (OPJ_UINT32 )(((double )l_tile_size * 1.4) / (double )8);
#line 5342
  l_tile_size += 500U;
#line 5344
  __cil_tmp34___0 = opj_j2k_get_specific_header_sizes(p_j2k___42);
#line 5344
  l_tile_size += __cil_tmp34___0;
#line 5346
  p_j2k___42->m_specific_param.m_encoder.m_encoded_tile_size = l_tile_size;
#line 5347
  __cil_tmp35___0 = opj_malloc((size_t )p_j2k___42->m_specific_param.m_encoder.m_encoded_tile_size);
#line 5347
  p_j2k___42->m_specific_param.m_encoder.m_encoded_tile_data = (OPJ_BYTE *)__cil_tmp35___0;
  }
#line 5349
  if ((unsigned long )p_j2k___42->m_specific_param.m_encoder.m_encoded_tile_data == (unsigned long )((OPJ_BYTE *)0)) {
#line 5350
    return (0);
  }
#line 5353
  if ((int )l_cp___12->rsiz >= 3) {
#line 5353
    if ((int )l_cp___12->rsiz <= 6) {
      _L: 
      {
#line 5354
      __cil_tmp36___0 = opj_malloc((size_t )(5U * p_j2k___42->m_specific_param.m_encoder.m_total_tile_parts));
#line 5354
      p_j2k___42->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer = (OPJ_BYTE *)__cil_tmp36___0;
      }
#line 5357
      if (! p_j2k___42->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer) {
#line 5358
        return (0);
      }
#line 5361
      p_j2k___42->m_specific_param.m_encoder.m_tlm_sot_offsets_current = p_j2k___42->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer;
    } else {
#line 5353
      goto _L___12;
    }
  } else
  _L___12: 
#line 5353
  if ((int )l_cp___12->rsiz >= 1024) {
#line 5353
    if ((int )l_cp___12->rsiz <= 2459) {
#line 5353
      goto _L;
    }
  }
#line 5365
  return (1);
}
}
#line 5420 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_get_end_header(opj_j2k_t *p_j2k___43 , struct opj_stream_private *p_stream___31 ,
                                       struct opj_event_mgr *p_manager___82 ) 
{ 


  {
  {
#line 5431
  (p_j2k___43->cstr_index)->main_head_end = opj_stream_tell(p_stream___31);
  }
#line 5433
  return (1);
}
}
#line 5436 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_mct_data_group(opj_j2k_t *p_j2k___44 , struct opj_stream_private *p_stream___32 ,
                                             struct opj_event_mgr *p_manager___83 ) 
{ 
  OPJ_UINT32 i___47 ;
  opj_simple_mcc_decorrelation_data_t *l_mcc_record ;
  opj_mct_data_t *l_mct_record ;
  opj_tcp_t *l_tcp___15 ;
  OPJ_BOOL __cil_tmp11___8 ;
  OPJ_BOOL __cil_tmp12___14 ;
  OPJ_BOOL __cil_tmp13___14 ;
  OPJ_BOOL __cil_tmp14___20 ;

  {
  {
#line 5450
  __cil_tmp11___8 = opj_j2k_write_cbd(p_j2k___44, p_stream___32, p_manager___83);
  }
#line 5450
  if (! __cil_tmp11___8) {
#line 5451
    return (0);
  }
#line 5454
  l_tcp___15 = p_j2k___44->m_cp.tcps + p_j2k___44->m_current_tile_number;
#line 5455
  l_mct_record = l_tcp___15->m_mct_records;
#line 5457
  i___47 = (OPJ_UINT32 )0;
  {
#line 5457
  while (1) {
    while_continue: /* CIL Label */ ;

#line 5457
    if (! (i___47 < l_tcp___15->m_nb_mct_records)) {
#line 5457
      goto while_break;
    }
    {
#line 5459
    __cil_tmp12___14 = opj_j2k_write_mct_record(p_j2k___44, l_mct_record, p_stream___32,
                                                p_manager___83);
    }
#line 5459
    if (! __cil_tmp12___14) {
#line 5460
      return (0);
    }
#line 5463
    l_mct_record ++;
#line 5457
    i___47 ++;
  }
  while_break___1: /* CIL Label */ ;
  }

  while_break: 
#line 5466
  l_mcc_record = l_tcp___15->m_mcc_records;
#line 5468
  i___47 = (OPJ_UINT32 )0;
  {
#line 5468
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 5468
    if (! (i___47 < l_tcp___15->m_nb_mcc_records)) {
#line 5468
      goto while_break___0;
    }
    {
#line 5470
    __cil_tmp13___14 = opj_j2k_write_mcc_record(p_j2k___44, l_mcc_record, p_stream___32,
                                                p_manager___83);
    }
#line 5470
    if (! __cil_tmp13___14) {
#line 5471
      return (0);
    }
#line 5474
    l_mcc_record ++;
#line 5468
    i___47 ++;
  }
  while_break___2: /* CIL Label */ ;
  }

  while_break___0: 
  {
#line 5477
  __cil_tmp14___20 = opj_j2k_write_mco(p_j2k___44, p_stream___32, p_manager___83);
  }
#line 5477
  if (! __cil_tmp14___20) {
#line 5478
    return (0);
  }
#line 5481
  return (1);
}
}
#line 5484 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_all_coc(opj_j2k_t *p_j2k___45 , struct opj_stream_private *p_stream___33 ,
                                      struct opj_event_mgr *p_manager___84 ) 
{ 
  OPJ_UINT32 compno___0 ;
  OPJ_BOOL __cil_tmp8___33 ;
  OPJ_BOOL __cil_tmp9___11 ;

  {
#line 5496
  compno___0 = (OPJ_UINT32 )1;
  {
#line 5496
  while (1) {
    while_continue: /* CIL Label */ ;

#line 5496
    if (! (compno___0 < (p_j2k___45->m_private_image)->numcomps)) {
#line 5496
      goto while_break;
    }
    {
#line 5498
    __cil_tmp8___33 = opj_j2k_compare_coc(p_j2k___45, (OPJ_UINT32 )0, compno___0);
    }
#line 5498
    if (! __cil_tmp8___33) {
      {
#line 5499
      __cil_tmp9___11 = opj_j2k_write_coc(p_j2k___45, compno___0, p_stream___33, p_manager___84);
      }
#line 5499
      if (! __cil_tmp9___11) {
#line 5500
        return (0);
      }
    }
#line 5496
    compno___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 5505
  return (1);
}
}
#line 5508 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_all_qcc(opj_j2k_t *p_j2k___46 , struct opj_stream_private *p_stream___34 ,
                                      struct opj_event_mgr *p_manager___85 ) 
{ 
  OPJ_UINT32 compno___1 ;
  OPJ_BOOL __cil_tmp8___34 ;
  OPJ_BOOL __cil_tmp9___12 ;

  {
#line 5520
  compno___1 = (OPJ_UINT32 )1;
  {
#line 5520
  while (1) {
    while_continue: /* CIL Label */ ;

#line 5520
    if (! (compno___1 < (p_j2k___46->m_private_image)->numcomps)) {
#line 5520
      goto while_break;
    }
    {
#line 5522
    __cil_tmp8___34 = opj_j2k_compare_qcc(p_j2k___46, (OPJ_UINT32 )0, compno___1);
    }
#line 5522
    if (! __cil_tmp8___34) {
      {
#line 5523
      __cil_tmp9___12 = opj_j2k_write_qcc(p_j2k___46, compno___1, p_stream___34, p_manager___85);
      }
#line 5523
      if (! __cil_tmp9___12) {
#line 5524
        return (0);
      }
    }
#line 5520
    compno___1 ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 5528
  return (1);
}
}
#line 5531 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_regions(opj_j2k_t *p_j2k___47 , struct opj_stream_private *p_stream___35 ,
                                      struct opj_event_mgr *p_manager___86 ) 
{ 
  OPJ_UINT32 compno___2 ;
  opj_tccp_t *l_tccp___1 ;
  OPJ_BOOL __cil_tmp9___13 ;

  {
#line 5536
  l_tccp___1 = (opj_tccp_t *)0;
#line 5543
  l_tccp___1 = (p_j2k___47->m_cp.tcps)->tccps;
#line 5545
  compno___2 = (OPJ_UINT32 )0;
  {
#line 5545
  while (1) {
    while_continue: /* CIL Label */ ;

#line 5545
    if (! (compno___2 < (p_j2k___47->m_private_image)->numcomps)) {
#line 5545
      goto while_break;
    }
#line 5546
    if (l_tccp___1->roishift) {
      {
#line 5548
      __cil_tmp9___13 = opj_j2k_write_rgn(p_j2k___47, (OPJ_UINT32 )0, compno___2,
                                          (p_j2k___47->m_private_image)->numcomps,
                                          p_stream___35, p_manager___86);
      }
#line 5548
      if (! __cil_tmp9___13) {
#line 5550
        return (0);
      }
    }
#line 5554
    l_tccp___1 ++;
#line 5545
    compno___2 ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 5557
  return (1);
}
}
#line 5560 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_epc(opj_j2k_t *p_j2k___48 , struct opj_stream_private *p_stream___36 ,
                                  struct opj_event_mgr *p_manager___87 ) 
{ 
  opj_codestream_index_t *l_cstr_index___0 ;
  OPJ_OFF_T __cil_tmp8___35 ;

  {
#line 5564
  l_cstr_index___0 = (opj_codestream_index_t *)0;
#line 5573
  l_cstr_index___0 = p_j2k___48->cstr_index;
#line 5574
  if (l_cstr_index___0) {
    {
#line 5575
    __cil_tmp8___35 = opj_stream_tell(p_stream___36);
#line 5575
    l_cstr_index___0->codestream_size = (OPJ_UINT64 )__cil_tmp8___35;
#line 5580
    l_cstr_index___0->codestream_size -= (OPJ_UINT64 )l_cstr_index___0->main_head_start;
    }
  }
#line 5597
  return (1);
}
}
#line 5600 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_unk(opj_j2k_t *p_j2k___49 , opj_stream_private_t *p_stream___37 ,
                                 OPJ_UINT32 *output_marker , opj_event_mgr_t *p_manager___88 ) 
{ 
  OPJ_UINT32 l_unknown_marker ;
  opj_dec_memory_marker_handler_t *l_marker_handler ;
  OPJ_UINT32 l_size_unk ;
  OPJ_SIZE_T __cil_tmp11___9 ;
  OPJ_BOOL res ;
  OPJ_OFF_T __cil_tmp14___21 ;
  OPJ_BOOL __cil_tmp15___13 ;

  {
  {
#line 5608
  l_size_unk = (OPJ_UINT32 )2;
#line 5615
  opj_event_msg(p_manager___88, 2, "Unknown marker\n");
  }
  {
#line 5617
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 5619
    __cil_tmp11___9 = opj_stream_read_data(p_stream___37, p_j2k___49->m_specific_param.m_decoder.m_header_data,
                                           (OPJ_SIZE_T )2, p_manager___88);
    }
#line 5619
    if (__cil_tmp11___9 != 2UL) {
      {
#line 5621
      opj_event_msg(p_manager___88, 1, "Stream too short\n");
      }
#line 5622
      return (0);
    }
    {
#line 5626
    opj_read_bytes_LE(p_j2k___49->m_specific_param.m_decoder.m_header_data, & l_unknown_marker,
                      (OPJ_UINT32 )2);
    }
#line 5629
    if (! (l_unknown_marker < 65280U)) {
      {
#line 5632
      l_marker_handler = opj_j2k_get_marker_handler(l_unknown_marker);
      }
#line 5634
      if (! (p_j2k___49->m_specific_param.m_decoder.m_state & l_marker_handler->states)) {
        {
#line 5635
        opj_event_msg(p_manager___88, 1, "Marker is not compliant with its position\n");
        }
#line 5637
        return (0);
      } else
#line 5639
      if (l_marker_handler->id != 0U) {
#line 5641
        if (l_marker_handler->id != 65424U) {
          {
#line 5642
          __cil_tmp14___21 = opj_stream_tell(p_stream___37);
#line 5642
          __cil_tmp15___13 = opj_j2k_add_mhmarker(p_j2k___49->cstr_index, (OPJ_UINT32 )0,
                                                  (OPJ_OFF_T )((OPJ_UINT32 )__cil_tmp14___21 - l_size_unk),
                                                  l_size_unk);
#line 5642
          res = __cil_tmp15___13;
          }
#line 5645
          if (res == 0) {
            {
#line 5646
            opj_event_msg(p_manager___88, 1, "Not enough memory to add mh marker\n");
            }
#line 5647
            return (0);
          }
        }
#line 5650
        goto while_break;
      } else {
#line 5652
        l_size_unk += 2U;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: 
#line 5658
  *output_marker = l_marker_handler->id;
#line 5660
  return (1);
}
}
#line 5663 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_mct_record(opj_j2k_t *p_j2k___50 , opj_mct_data_t *p_mct_record ,
                                         struct opj_stream_private *p_stream___38 ,
                                         struct opj_event_mgr *p_manager___89 ) 
{ 
  OPJ_UINT32 l_mct_size ;
  OPJ_BYTE *l_current_data___8 ;
  OPJ_UINT32 l_tmp___3 ;
  OPJ_BYTE *new_header_tile_data___7 ;
  void *__cil_tmp12___16 ;
  OPJ_SIZE_T __cil_tmp13___15 ;

  {
#line 5669
  l_current_data___8 = (OPJ_BYTE *)0;
#line 5677
  l_mct_size = 10U + p_mct_record->m_data_size;
#line 5679
  if (l_mct_size > p_j2k___50->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 5680
    __cil_tmp12___16 = opj_realloc((void *)p_j2k___50->m_specific_param.m_encoder.m_header_tile_data,
                                   (size_t )l_mct_size);
#line 5680
    new_header_tile_data___7 = (OPJ_BYTE *)__cil_tmp12___16;
    }
#line 5682
    if (! new_header_tile_data___7) {
      {
#line 5683
      opj_free((void *)p_j2k___50->m_specific_param.m_encoder.m_header_tile_data);
#line 5684
      p_j2k___50->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 5685
      p_j2k___50->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 5686
      opj_event_msg(p_manager___89, 1, "Not enough memory to write MCT marker\n");
      }
#line 5687
      return (0);
    }
#line 5689
    p_j2k___50->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data___7;
#line 5690
    p_j2k___50->m_specific_param.m_encoder.m_header_tile_data_size = l_mct_size;
  }
  {
#line 5693
  l_current_data___8 = p_j2k___50->m_specific_param.m_encoder.m_header_tile_data;
#line 5695
  opj_write_bytes_LE(l_current_data___8, (OPJ_UINT32 )65396, (OPJ_UINT32 )2);
#line 5697
  l_current_data___8 += 2;
#line 5699
  opj_write_bytes_LE(l_current_data___8, l_mct_size - 2U, (OPJ_UINT32 )2);
#line 5701
  l_current_data___8 += 2;
#line 5703
  opj_write_bytes_LE(l_current_data___8, (OPJ_UINT32 )0, (OPJ_UINT32 )2);
#line 5705
  l_current_data___8 += 2;
#line 5708
  l_tmp___3 = ((p_mct_record->m_index & 255U) | ((unsigned int )p_mct_record->m_array_type << 8)) | ((unsigned int )p_mct_record->m_element_type << 10);
#line 5711
  opj_write_bytes_LE(l_current_data___8, l_tmp___3, (OPJ_UINT32 )2);
#line 5712
  l_current_data___8 += 2;
#line 5714
  opj_write_bytes_LE(l_current_data___8, (OPJ_UINT32 )0, (OPJ_UINT32 )2);
#line 5716
  l_current_data___8 += 2;
#line 5718
  memcpy((void *)l_current_data___8, (void const   *)p_mct_record->m_data, (unsigned long )p_mct_record->m_data_size);
#line 5720
  __cil_tmp13___15 = opj_stream_write_data(p_stream___38, p_j2k___50->m_specific_param.m_encoder.m_header_tile_data,
                                           (OPJ_SIZE_T )l_mct_size, p_manager___89);
  }
#line 5720
  if (__cil_tmp13___15 != (unsigned long )l_mct_size) {
#line 5723
    return (0);
  }
#line 5726
  return (1);
}
}
#line 5737 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_mct(opj_j2k_t *p_j2k___51 , OPJ_BYTE *p_header_data___18 ,
                                 OPJ_UINT32 p_header_size___18 , opj_event_mgr_t *p_manager___90 ) 
{ 
  OPJ_UINT32 i___48 ;
  opj_tcp_t *l_tcp___16 ;
  OPJ_UINT32 l_tmp___4 ;
  OPJ_UINT32 l_indix ;
  opj_mct_data_t *l_mct_data ;
  opj_tcp_t *tmp___291 ;
  opj_mct_data_t *new_mct_records ;
  void *__cil_tmp14___22 ;
  opj_simple_mcc_decorrelation_data_t *l_mcc_record___0 ;
  void *__cil_tmp16___10 ;

  {
#line 5744
  l_tcp___16 = (opj_tcp_t *)0;
#line 5753
  if (p_j2k___51->m_specific_param.m_decoder.m_state == 16U) {
#line 5753
    tmp___291 = p_j2k___51->m_cp.tcps + p_j2k___51->m_current_tile_number;
  } else {
#line 5753
    tmp___291 = p_j2k___51->m_specific_param.m_decoder.m_default_tcp;
  }
#line 5753
  l_tcp___16 = tmp___291;
#line 5757
  if (p_header_size___18 < 2U) {
    {
#line 5758
    opj_event_msg(p_manager___90, 1, "Error reading MCT marker\n");
    }
#line 5759
    return (0);
  }
  {
#line 5763
  opj_read_bytes_LE(p_header_data___18, & l_tmp___4, (OPJ_UINT32 )2);
#line 5764
  p_header_data___18 += 2;
  }
#line 5765
  if (l_tmp___4 != 0U) {
    {
#line 5766
    opj_event_msg(p_manager___90, 2, "Cannot take in charge mct data within multiple MCT records\n");
    }
#line 5768
    return (1);
  }
#line 5771
  if (p_header_size___18 <= 6U) {
    {
#line 5772
    opj_event_msg(p_manager___90, 1, "Error reading MCT marker\n");
    }
#line 5773
    return (0);
  }
  {
#line 5777
  opj_read_bytes_LE(p_header_data___18, & l_tmp___4, (OPJ_UINT32 )2);
#line 5778
  p_header_data___18 += 2;
#line 5780
  l_indix = l_tmp___4 & 255U;
#line 5781
  l_mct_data = l_tcp___16->m_mct_records;
#line 5783
  i___48 = (OPJ_UINT32 )0;
  }
  {
#line 5783
  while (1) {
    while_continue: /* CIL Label */ ;

#line 5783
    if (! (i___48 < l_tcp___16->m_nb_mct_records)) {
#line 5783
      goto while_break;
    }
#line 5784
    if (l_mct_data->m_index == l_indix) {
#line 5785
      goto while_break;
    }
#line 5787
    l_mct_data ++;
#line 5783
    i___48 ++;
  }
  while_break___1: /* CIL Label */ ;
  }

  while_break: ;
#line 5791
  if (i___48 == l_tcp___16->m_nb_mct_records) {
#line 5792
    if (l_tcp___16->m_nb_mct_records == l_tcp___16->m_nb_max_mct_records) {
      {
#line 5794
      l_tcp___16->m_nb_max_mct_records += 10U;
#line 5796
      __cil_tmp14___22 = opj_realloc((void *)l_tcp___16->m_mct_records, (unsigned long )l_tcp___16->m_nb_max_mct_records * sizeof(opj_mct_data_t ));
#line 5796
      new_mct_records = (opj_mct_data_t *)__cil_tmp14___22;
      }
#line 5798
      if (! new_mct_records) {
        {
#line 5799
        opj_free((void *)l_tcp___16->m_mct_records);
#line 5800
        l_tcp___16->m_mct_records = (opj_mct_data_t *)((void *)0);
#line 5801
        l_tcp___16->m_nb_max_mct_records = (OPJ_UINT32 )0;
#line 5802
        l_tcp___16->m_nb_mct_records = (OPJ_UINT32 )0;
#line 5803
        opj_event_msg(p_manager___90, 1, "Not enough memory to read MCT marker\n");
        }
#line 5804
        return (0);
      }
#line 5809
      if ((unsigned long )new_mct_records != (unsigned long )l_tcp___16->m_mct_records) {
#line 5810
        i___48 = (OPJ_UINT32 )0;
        {
#line 5810
        while (1) {
          while_continue___0: /* CIL Label */ ;

#line 5810
          if (! (i___48 < l_tcp___16->m_nb_mcc_records)) {
#line 5810
            goto while_break___0;
          }
#line 5811
          l_mcc_record___0 = l_tcp___16->m_mcc_records + i___48;
#line 5813
          if (l_mcc_record___0->m_decorrelation_array) {
#line 5814
            l_mcc_record___0->m_decorrelation_array = new_mct_records + (l_mcc_record___0->m_decorrelation_array - l_tcp___16->m_mct_records);
          }
#line 5819
          if (l_mcc_record___0->m_offset_array) {
#line 5820
            l_mcc_record___0->m_offset_array = new_mct_records + (l_mcc_record___0->m_offset_array - l_tcp___16->m_mct_records);
          }
#line 5810
          i___48 ++;
        }
        while_break___2: /* CIL Label */ ;
        }

        while_break___0: ;
      }
      {
#line 5828
      l_tcp___16->m_mct_records = new_mct_records;
#line 5829
      l_mct_data = l_tcp___16->m_mct_records + l_tcp___16->m_nb_mct_records;
#line 5830
      memset((void *)l_mct_data, 0, (unsigned long )(l_tcp___16->m_nb_max_mct_records - l_tcp___16->m_nb_mct_records) * sizeof(opj_mct_data_t ));
      }
    }
#line 5834
    l_mct_data = l_tcp___16->m_mct_records + l_tcp___16->m_nb_mct_records;
#line 5835
    (l_tcp___16->m_nb_mct_records) ++;
  }
#line 5838
  if (l_mct_data->m_data) {
    {
#line 5839
    opj_free((void *)l_mct_data->m_data);
#line 5840
    l_mct_data->m_data = (OPJ_BYTE *)0;
#line 5841
    l_mct_data->m_data_size = (OPJ_UINT32 )0;
    }
  }
  {
#line 5844
  l_mct_data->m_index = l_indix;
#line 5845
  l_mct_data->m_array_type = (J2K_MCT_ARRAY_TYPE )((l_tmp___4 >> 8) & 3U);
#line 5846
  l_mct_data->m_element_type = (J2K_MCT_ELEMENT_TYPE )((l_tmp___4 >> 10) & 3U);
#line 5848
  opj_read_bytes_LE(p_header_data___18, & l_tmp___4, (OPJ_UINT32 )2);
#line 5849
  p_header_data___18 += 2;
  }
#line 5850
  if (l_tmp___4 != 0U) {
    {
#line 5851
    opj_event_msg(p_manager___90, 2, "Cannot take in charge multiple MCT markers\n");
    }
#line 5853
    return (1);
  }
  {
#line 5856
  p_header_size___18 -= 6U;
#line 5858
  __cil_tmp16___10 = opj_malloc((size_t )p_header_size___18);
#line 5858
  l_mct_data->m_data = (OPJ_BYTE *)__cil_tmp16___10;
  }
#line 5859
  if (! l_mct_data->m_data) {
    {
#line 5860
    opj_event_msg(p_manager___90, 1, "Error reading MCT marker\n");
    }
#line 5861
    return (0);
  }
  {
#line 5863
  memcpy((void *)l_mct_data->m_data, (void const   *)p_header_data___18, (unsigned long )p_header_size___18);
#line 5865
  l_mct_data->m_data_size = p_header_size___18;
  }
#line 5867
  return (1);
}
}
#line 5870 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_mcc_record(opj_j2k_t *p_j2k___52 , struct opj_simple_mcc_decorrelation_data *p_mcc_record ,
                                         struct opj_stream_private *p_stream___39 ,
                                         struct opj_event_mgr *p_manager___91 ) 
{ 
  OPJ_UINT32 i___49 ;
  OPJ_UINT32 l_mcc_size ;
  OPJ_BYTE *l_current_data___9 ;
  OPJ_UINT32 l_nb_bytes_for_comp ;
  OPJ_UINT32 l_mask ;
  OPJ_UINT32 l_tmcc ;
  OPJ_BYTE *new_header_tile_data___8 ;
  void *__cil_tmp15___14 ;
  OPJ_SIZE_T __cil_tmp16___11 ;

  {
#line 5877
  l_current_data___9 = (OPJ_BYTE *)0;
#line 5887
  if (p_mcc_record->m_nb_comps > 255U) {
#line 5888
    l_nb_bytes_for_comp = (OPJ_UINT32 )2;
#line 5889
    l_mask = (OPJ_UINT32 )32768;
  } else {
#line 5891
    l_nb_bytes_for_comp = (OPJ_UINT32 )1;
#line 5892
    l_mask = (OPJ_UINT32 )0;
  }
#line 5895
  l_mcc_size = (p_mcc_record->m_nb_comps * 2U) * l_nb_bytes_for_comp + 19U;
#line 5896
  if (l_mcc_size > p_j2k___52->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 5897
    __cil_tmp15___14 = opj_realloc((void *)p_j2k___52->m_specific_param.m_encoder.m_header_tile_data,
                                   (size_t )l_mcc_size);
#line 5897
    new_header_tile_data___8 = (OPJ_BYTE *)__cil_tmp15___14;
    }
#line 5899
    if (! new_header_tile_data___8) {
      {
#line 5900
      opj_free((void *)p_j2k___52->m_specific_param.m_encoder.m_header_tile_data);
#line 5901
      p_j2k___52->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 5902
      p_j2k___52->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 5903
      opj_event_msg(p_manager___91, 1, "Not enough memory to write MCC marker\n");
      }
#line 5904
      return (0);
    }
#line 5906
    p_j2k___52->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data___8;
#line 5907
    p_j2k___52->m_specific_param.m_encoder.m_header_tile_data_size = l_mcc_size;
  }
  {
#line 5910
  l_current_data___9 = p_j2k___52->m_specific_param.m_encoder.m_header_tile_data;
#line 5912
  opj_write_bytes_LE(l_current_data___9, (OPJ_UINT32 )65397, (OPJ_UINT32 )2);
#line 5914
  l_current_data___9 += 2;
#line 5916
  opj_write_bytes_LE(l_current_data___9, l_mcc_size - 2U, (OPJ_UINT32 )2);
#line 5918
  l_current_data___9 += 2;
#line 5921
  opj_write_bytes_LE(l_current_data___9, (OPJ_UINT32 )0, (OPJ_UINT32 )2);
#line 5923
  l_current_data___9 += 2;
#line 5925
  opj_write_bytes_LE(l_current_data___9, p_mcc_record->m_index, (OPJ_UINT32 )1);
#line 5927
  l_current_data___9 ++;
#line 5930
  opj_write_bytes_LE(l_current_data___9, (OPJ_UINT32 )0, (OPJ_UINT32 )2);
#line 5932
  l_current_data___9 += 2;
#line 5934
  opj_write_bytes_LE(l_current_data___9, (OPJ_UINT32 )1, (OPJ_UINT32 )2);
#line 5936
  l_current_data___9 += 2;
#line 5938
  opj_write_bytes_LE(l_current_data___9, (OPJ_UINT32 )1, (OPJ_UINT32 )1);
#line 5940
  l_current_data___9 ++;
#line 5942
  opj_write_bytes_LE(l_current_data___9, p_mcc_record->m_nb_comps | l_mask, (OPJ_UINT32 )2);
#line 5944
  l_current_data___9 += 2;
#line 5946
  i___49 = (OPJ_UINT32 )0;
  }
  {
#line 5946
  while (1) {
    while_continue: /* CIL Label */ ;

#line 5946
    if (! (i___49 < p_mcc_record->m_nb_comps)) {
#line 5946
      goto while_break;
    }
    {
#line 5947
    opj_write_bytes_LE(l_current_data___9, i___49, l_nb_bytes_for_comp);
#line 5949
    l_current_data___9 += l_nb_bytes_for_comp;
#line 5946
    i___49 ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }

  while_break: 
  {
#line 5952
  opj_write_bytes_LE(l_current_data___9, p_mcc_record->m_nb_comps | l_mask, (OPJ_UINT32 )2);
#line 5954
  l_current_data___9 += 2;
#line 5956
  i___49 = (OPJ_UINT32 )0;
  }
  {
#line 5956
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 5956
    if (! (i___49 < p_mcc_record->m_nb_comps)) {
#line 5956
      goto while_break___0;
    }
    {
#line 5957
    opj_write_bytes_LE(l_current_data___9, i___49, l_nb_bytes_for_comp);
#line 5959
    l_current_data___9 += l_nb_bytes_for_comp;
#line 5956
    i___49 ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }

  while_break___0: 
#line 5962
  l_tmcc = ((unsigned int )(! p_mcc_record->m_is_irreversible) & 1U) << 16;
#line 5964
  if (p_mcc_record->m_decorrelation_array) {
#line 5965
    l_tmcc |= (p_mcc_record->m_decorrelation_array)->m_index;
  }
#line 5968
  if (p_mcc_record->m_offset_array) {
#line 5969
    l_tmcc |= (p_mcc_record->m_offset_array)->m_index << 8;
  }
  {
#line 5972
  opj_write_bytes_LE(l_current_data___9, l_tmcc, (OPJ_UINT32 )3);
#line 5974
  l_current_data___9 += 3;
#line 5976
  __cil_tmp16___11 = opj_stream_write_data(p_stream___39, p_j2k___52->m_specific_param.m_encoder.m_header_tile_data,
                                           (OPJ_SIZE_T )l_mcc_size, p_manager___91);
  }
#line 5976
  if (__cil_tmp16___11 != (unsigned long )l_mcc_size) {
#line 5979
    return (0);
  }
#line 5982
  return (1);
}
}
#line 5985 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_mcc(opj_j2k_t *p_j2k___53 , OPJ_BYTE *p_header_data___19 ,
                                 OPJ_UINT32 p_header_size___19 , opj_event_mgr_t *p_manager___92 ) 
{ 
  OPJ_UINT32 i___50 ;
  OPJ_UINT32 j___4 ;
  OPJ_UINT32 l_tmp___5 ;
  OPJ_UINT32 l_indix___0 ;
  opj_tcp_t *l_tcp___17 ;
  opj_simple_mcc_decorrelation_data_t *l_mcc_record___1 ;
  opj_mct_data_t *l_mct_data___0 ;
  OPJ_UINT32 l_nb_collections ;
  OPJ_UINT32 l_nb_comps___0 ;
  OPJ_UINT32 l_nb_bytes_by_comp ;
  OPJ_BOOL l_new_mcc ;
  opj_tcp_t *tmp___298 ;
  opj_simple_mcc_decorrelation_data_t *new_mcc_records ;
  void *__cil_tmp21___3 ;

  {
#line 5999
  l_new_mcc = 0;
#line 6006
  if (p_j2k___53->m_specific_param.m_decoder.m_state == 16U) {
#line 6006
    tmp___298 = p_j2k___53->m_cp.tcps + p_j2k___53->m_current_tile_number;
  } else {
#line 6006
    tmp___298 = p_j2k___53->m_specific_param.m_decoder.m_default_tcp;
  }
#line 6006
  l_tcp___17 = tmp___298;
#line 6010
  if (p_header_size___19 < 2U) {
    {
#line 6011
    opj_event_msg(p_manager___92, 1, "Error reading MCC marker\n");
    }
#line 6012
    return (0);
  }
  {
#line 6016
  opj_read_bytes_LE(p_header_data___19, & l_tmp___5, (OPJ_UINT32 )2);
#line 6017
  p_header_data___19 += 2;
  }
#line 6018
  if (l_tmp___5 != 0U) {
    {
#line 6019
    opj_event_msg(p_manager___92, 2, "Cannot take in charge multiple data spanning\n");
    }
#line 6021
    return (1);
  }
#line 6024
  if (p_header_size___19 < 7U) {
    {
#line 6025
    opj_event_msg(p_manager___92, 1, "Error reading MCC marker\n");
    }
#line 6026
    return (0);
  }
  {
#line 6029
  opj_read_bytes_LE(p_header_data___19, & l_indix___0, (OPJ_UINT32 )1);
#line 6031
  p_header_data___19 ++;
#line 6033
  l_mcc_record___1 = l_tcp___17->m_mcc_records;
#line 6035
  i___50 = (OPJ_UINT32 )0;
  }
  {
#line 6035
  while (1) {
    while_continue: /* CIL Label */ ;

#line 6035
    if (! (i___50 < l_tcp___17->m_nb_mcc_records)) {
#line 6035
      goto while_break;
    }
#line 6036
    if (l_mcc_record___1->m_index == l_indix___0) {
#line 6037
      goto while_break;
    }
#line 6039
    l_mcc_record___1 ++;
#line 6035
    i___50 ++;
  }
  while_break___5: /* CIL Label */ ;
  }

  while_break: ;
#line 6043
  if (i___50 == l_tcp___17->m_nb_mcc_records) {
#line 6044
    if (l_tcp___17->m_nb_mcc_records == l_tcp___17->m_nb_max_mcc_records) {
      {
#line 6046
      l_tcp___17->m_nb_max_mcc_records += 10U;
#line 6048
      __cil_tmp21___3 = opj_realloc((void *)l_tcp___17->m_mcc_records, (unsigned long )l_tcp___17->m_nb_max_mcc_records * sizeof(opj_simple_mcc_decorrelation_data_t ));
#line 6048
      new_mcc_records = (opj_simple_mcc_decorrelation_data_t *)__cil_tmp21___3;
      }
#line 6051
      if (! new_mcc_records) {
        {
#line 6052
        opj_free((void *)l_tcp___17->m_mcc_records);
#line 6053
        l_tcp___17->m_mcc_records = (opj_simple_mcc_decorrelation_data_t *)((void *)0);
#line 6054
        l_tcp___17->m_nb_max_mcc_records = (OPJ_UINT32 )0;
#line 6055
        l_tcp___17->m_nb_mcc_records = (OPJ_UINT32 )0;
#line 6056
        opj_event_msg(p_manager___92, 1, "Not enough memory to read MCC marker\n");
        }
#line 6057
        return (0);
      }
      {
#line 6059
      l_tcp___17->m_mcc_records = new_mcc_records;
#line 6060
      l_mcc_record___1 = l_tcp___17->m_mcc_records + l_tcp___17->m_nb_mcc_records;
#line 6061
      memset((void *)l_mcc_record___1, 0, (unsigned long )(l_tcp___17->m_nb_max_mcc_records - l_tcp___17->m_nb_mcc_records) * sizeof(opj_simple_mcc_decorrelation_data_t ));
      }
    }
#line 6064
    l_mcc_record___1 = l_tcp___17->m_mcc_records + l_tcp___17->m_nb_mcc_records;
#line 6065
    l_new_mcc = 1;
  }
  {
#line 6067
  l_mcc_record___1->m_index = l_indix___0;
#line 6070
  opj_read_bytes_LE(p_header_data___19, & l_tmp___5, (OPJ_UINT32 )2);
#line 6071
  p_header_data___19 += 2;
  }
#line 6072
  if (l_tmp___5 != 0U) {
    {
#line 6073
    opj_event_msg(p_manager___92, 2, "Cannot take in charge multiple data spanning\n");
    }
#line 6075
    return (1);
  }
  {
#line 6078
  opj_read_bytes_LE(p_header_data___19, & l_nb_collections, (OPJ_UINT32 )2);
#line 6080
  p_header_data___19 += 2;
  }
#line 6082
  if (l_nb_collections > 1U) {
    {
#line 6083
    opj_event_msg(p_manager___92, 2, "Cannot take in charge multiple collections\n");
    }
#line 6085
    return (1);
  }
#line 6088
  p_header_size___19 -= 7U;
#line 6090
  i___50 = (OPJ_UINT32 )0;
  {
#line 6090
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 6090
    if (! (i___50 < l_nb_collections)) {
#line 6090
      goto while_break___0;
    }
#line 6091
    if (p_header_size___19 < 3U) {
      {
#line 6092
      opj_event_msg(p_manager___92, 1, "Error reading MCC marker\n");
      }
#line 6093
      return (0);
    }
    {
#line 6096
    opj_read_bytes_LE(p_header_data___19, & l_tmp___5, (OPJ_UINT32 )1);
#line 6098
    p_header_data___19 ++;
    }
#line 6100
    if (l_tmp___5 != 1U) {
      {
#line 6101
      opj_event_msg(p_manager___92, 2, "Cannot take in charge collections other than array decorrelation\n");
      }
#line 6103
      return (1);
    }
    {
#line 6106
    opj_read_bytes_LE(p_header_data___19, & l_nb_comps___0, (OPJ_UINT32 )2);
#line 6108
    p_header_data___19 += 2;
#line 6109
    p_header_size___19 -= 3U;
#line 6111
    l_nb_bytes_by_comp = 1U + (l_nb_comps___0 >> 15);
#line 6112
    l_mcc_record___1->m_nb_comps = l_nb_comps___0 & 32767U;
    }
#line 6114
    if (p_header_size___19 < l_nb_bytes_by_comp * l_mcc_record___1->m_nb_comps + 2U) {
      {
#line 6115
      opj_event_msg(p_manager___92, 1, "Error reading MCC marker\n");
      }
#line 6116
      return (0);
    }
#line 6119
    p_header_size___19 -= l_nb_bytes_by_comp * l_mcc_record___1->m_nb_comps + 2U;
#line 6121
    j___4 = (OPJ_UINT32 )0;
    {
#line 6121
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 6121
      if (! (j___4 < l_mcc_record___1->m_nb_comps)) {
#line 6121
        goto while_break___1;
      }
      {
#line 6122
      opj_read_bytes_LE(p_header_data___19, & l_tmp___5, l_nb_bytes_by_comp);
#line 6124
      p_header_data___19 += l_nb_bytes_by_comp;
      }
#line 6126
      if (l_tmp___5 != j___4) {
        {
#line 6127
        opj_event_msg(p_manager___92, 2, "Cannot take in charge collections with indix shuffle\n");
        }
#line 6129
        return (1);
      }
#line 6121
      j___4 ++;
    }
    while_break___7: /* CIL Label */ ;
    }

    while_break___1: 
    {
#line 6133
    opj_read_bytes_LE(p_header_data___19, & l_nb_comps___0, (OPJ_UINT32 )2);
#line 6134
    p_header_data___19 += 2;
#line 6136
    l_nb_bytes_by_comp = 1U + (l_nb_comps___0 >> 15);
#line 6137
    l_nb_comps___0 &= 32767U;
    }
#line 6139
    if (l_nb_comps___0 != l_mcc_record___1->m_nb_comps) {
      {
#line 6140
      opj_event_msg(p_manager___92, 2, "Cannot take in charge collections without same number of indixes\n\001");
      }
#line 6142
      return (1);
    }
#line 6145
    if (p_header_size___19 < l_nb_bytes_by_comp * l_mcc_record___1->m_nb_comps + 3U) {
      {
#line 6146
      opj_event_msg(p_manager___92, 1, "Error reading MCC marker\n\001");
      }
#line 6147
      return (0);
    }
#line 6150
    p_header_size___19 -= l_nb_bytes_by_comp * l_mcc_record___1->m_nb_comps + 3U;
#line 6152
    j___4 = (OPJ_UINT32 )0;
    {
#line 6152
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 6152
      if (! (j___4 < l_mcc_record___1->m_nb_comps)) {
#line 6152
        goto while_break___2;
      }
      {
#line 6153
      opj_read_bytes_LE(p_header_data___19, & l_tmp___5, l_nb_bytes_by_comp);
#line 6155
      p_header_data___19 += l_nb_bytes_by_comp;
      }
#line 6157
      if (l_tmp___5 != j___4) {
        {
#line 6158
        opj_event_msg(p_manager___92, 2, "Cannot take in charge collections with indix shuffle\np\002");
        }
#line 6160
        return (1);
      }
#line 6152
      j___4 ++;
    }
    while_break___8: /* CIL Label */ ;
    }

    while_break___2: 
    {
#line 6164
    opj_read_bytes_LE(p_header_data___19, & l_tmp___5, (OPJ_UINT32 )3);
#line 6165
    p_header_data___19 += 3;
#line 6167
    l_mcc_record___1->m_is_irreversible = (OPJ_BITFIELD )(! ((l_tmp___5 >> 16) & 1U));
#line 6168
    l_mcc_record___1->m_decorrelation_array = (opj_mct_data_t *)0;
#line 6169
    l_mcc_record___1->m_offset_array = (opj_mct_data_t *)0;
#line 6171
    l_indix___0 = l_tmp___5 & 255U;
    }
#line 6172
    if (l_indix___0 != 0U) {
#line 6173
      l_mct_data___0 = l_tcp___17->m_mct_records;
#line 6174
      j___4 = (OPJ_UINT32 )0;
      {
#line 6174
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 6174
        if (! (j___4 < l_tcp___17->m_nb_mct_records)) {
#line 6174
          goto while_break___3;
        }
#line 6175
        if (l_mct_data___0->m_index == l_indix___0) {
#line 6176
          l_mcc_record___1->m_decorrelation_array = l_mct_data___0;
#line 6177
          goto while_break___3;
        }
#line 6179
        l_mct_data___0 ++;
#line 6174
        j___4 ++;
      }
      while_break___9: /* CIL Label */ ;
      }

      while_break___3: ;
#line 6182
      if ((unsigned long )l_mcc_record___1->m_decorrelation_array == (unsigned long )((opj_mct_data_t *)0)) {
        {
#line 6183
        opj_event_msg(p_manager___92, 1, "Error reading MCC marker\nG\003");
        }
#line 6184
        return (0);
      }
    }
#line 6188
    l_indix___0 = (l_tmp___5 >> 8) & 255U;
#line 6189
    if (l_indix___0 != 0U) {
#line 6190
      l_mct_data___0 = l_tcp___17->m_mct_records;
#line 6191
      j___4 = (OPJ_UINT32 )0;
      {
#line 6191
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 6191
        if (! (j___4 < l_tcp___17->m_nb_mct_records)) {
#line 6191
          goto while_break___4;
        }
#line 6192
        if (l_mct_data___0->m_index == l_indix___0) {
#line 6193
          l_mcc_record___1->m_offset_array = l_mct_data___0;
#line 6194
          goto while_break___4;
        }
#line 6196
        l_mct_data___0 ++;
#line 6191
        j___4 ++;
      }
      while_break___10: /* CIL Label */ ;
      }

      while_break___4: ;
#line 6199
      if ((unsigned long )l_mcc_record___1->m_offset_array == (unsigned long )((opj_mct_data_t *)0)) {
        {
#line 6200
        opj_event_msg(p_manager___92, 1, "Error reading MCC marker\n");
        }
#line 6201
        return (0);
      }
    }
#line 6090
    i___50 ++;
  }
  while_break___6: /* CIL Label */ ;
  }

  while_break___0: ;
#line 6206
  if (p_header_size___19 != 0U) {
    {
#line 6207
    opj_event_msg(p_manager___92, 1, "Error reading MCC marker\n");
    }
#line 6208
    return (0);
  }
#line 6211
  if (l_new_mcc) {
#line 6212
    (l_tcp___17->m_nb_mcc_records) ++;
  }
#line 6215
  return (1);
}
}
#line 6218 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_mco(opj_j2k_t *p_j2k___54 , struct opj_stream_private *p_stream___40 ,
                                  struct opj_event_mgr *p_manager___93 ) 
{ 
  OPJ_BYTE *l_current_data___10 ;
  OPJ_UINT32 l_mco_size ;
  opj_tcp_t *l_tcp___18 ;
  opj_simple_mcc_decorrelation_data_t *l_mcc_record___2 ;
  OPJ_UINT32 i___51 ;
  OPJ_BYTE *new_header_tile_data___9 ;
  void *__cil_tmp13___16 ;
  OPJ_SIZE_T __cil_tmp14___23 ;

  {
#line 6223
  l_current_data___10 = (OPJ_BYTE *)0;
#line 6225
  l_tcp___18 = (opj_tcp_t *)0;
#line 6234
  l_tcp___18 = p_j2k___54->m_cp.tcps + p_j2k___54->m_current_tile_number;
#line 6236
  l_mco_size = 5U + l_tcp___18->m_nb_mcc_records;
#line 6237
  if (l_mco_size > p_j2k___54->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 6239
    __cil_tmp13___16 = opj_realloc((void *)p_j2k___54->m_specific_param.m_encoder.m_header_tile_data,
                                   (size_t )l_mco_size);
#line 6239
    new_header_tile_data___9 = (OPJ_BYTE *)__cil_tmp13___16;
    }
#line 6241
    if (! new_header_tile_data___9) {
      {
#line 6242
      opj_free((void *)p_j2k___54->m_specific_param.m_encoder.m_header_tile_data);
#line 6243
      p_j2k___54->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 6244
      p_j2k___54->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 6245
      opj_event_msg(p_manager___93, 1, "Not enough memory to write MCO marker\n\004");
      }
#line 6246
      return (0);
    }
#line 6248
    p_j2k___54->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data___9;
#line 6249
    p_j2k___54->m_specific_param.m_encoder.m_header_tile_data_size = l_mco_size;
  }
  {
#line 6251
  l_current_data___10 = p_j2k___54->m_specific_param.m_encoder.m_header_tile_data;
#line 6254
  opj_write_bytes_LE(l_current_data___10, (OPJ_UINT32 )65399, (OPJ_UINT32 )2);
#line 6255
  l_current_data___10 += 2;
#line 6257
  opj_write_bytes_LE(l_current_data___10, l_mco_size - 2U, (OPJ_UINT32 )2);
#line 6258
  l_current_data___10 += 2;
#line 6260
  opj_write_bytes_LE(l_current_data___10, l_tcp___18->m_nb_mcc_records, (OPJ_UINT32 )1);
#line 6262
  l_current_data___10 ++;
#line 6264
  l_mcc_record___2 = l_tcp___18->m_mcc_records;
#line 6265
  i___51 = (OPJ_UINT32 )0;
  }
  {
#line 6265
  while (1) {
    while_continue: /* CIL Label */ ;

#line 6265
    if (! (i___51 < l_tcp___18->m_nb_mcc_records)) {
#line 6265
      goto while_break;
    }
    {
#line 6266
    opj_write_bytes_LE(l_current_data___10, l_mcc_record___2->m_index, (OPJ_UINT32 )1);
#line 6268
    l_current_data___10 ++;
#line 6269
    l_mcc_record___2 ++;
#line 6265
    i___51 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: 
  {
#line 6272
  __cil_tmp14___23 = opj_stream_write_data(p_stream___40, p_j2k___54->m_specific_param.m_encoder.m_header_tile_data,
                                           (OPJ_SIZE_T )l_mco_size, p_manager___93);
  }
#line 6272
  if (__cil_tmp14___23 != (unsigned long )l_mco_size) {
#line 6275
    return (0);
  }
#line 6278
  return (1);
}
}
#line 6289 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_mco(opj_j2k_t *p_j2k___55 , OPJ_BYTE *p_header_data___20 ,
                                 OPJ_UINT32 p_header_size___20 , opj_event_mgr_t *p_manager___94 ) 
{ 
  OPJ_UINT32 l_tmp___6 ;
  OPJ_UINT32 i___52 ;
  OPJ_UINT32 l_nb_stages ;
  opj_tcp_t *l_tcp___19 ;
  opj_tccp_t *l_tccp___2 ;
  opj_image_t *l_image___8 ;
  opj_tcp_t *tmp___305 ;
  OPJ_BOOL __cil_tmp15___15 ;

  {
#line 6306
  l_image___8 = p_j2k___55->m_private_image;
#line 6307
  if (p_j2k___55->m_specific_param.m_decoder.m_state == 16U) {
#line 6307
    tmp___305 = p_j2k___55->m_cp.tcps + p_j2k___55->m_current_tile_number;
  } else {
#line 6307
    tmp___305 = p_j2k___55->m_specific_param.m_decoder.m_default_tcp;
  }
#line 6307
  l_tcp___19 = tmp___305;
#line 6311
  if (p_header_size___20 < 1U) {
    {
#line 6312
    opj_event_msg(p_manager___94, 1, "Error reading MCO marker\n-\234\005]U");
    }
#line 6313
    return (0);
  }
  {
#line 6316
  opj_read_bytes_LE(p_header_data___20, & l_nb_stages, (OPJ_UINT32 )1);
#line 6318
  p_header_data___20 ++;
  }
#line 6320
  if (l_nb_stages > 1U) {
    {
#line 6321
    opj_event_msg(p_manager___94, 2, "Cannot take in charge multiple transformation stages.\n");
    }
#line 6323
    return (1);
  }
#line 6326
  if (p_header_size___20 != l_nb_stages + 1U) {
    {
#line 6327
    opj_event_msg(p_manager___94, 2, "Error reading MCO marker\n\233\221\005]U");
    }
#line 6328
    return (0);
  }
#line 6331
  l_tccp___2 = l_tcp___19->tccps;
#line 6333
  i___52 = (OPJ_UINT32 )0;
  {
#line 6333
  while (1) {
    while_continue: /* CIL Label */ ;

#line 6333
    if (! (i___52 < l_image___8->numcomps)) {
#line 6333
      goto while_break;
    }
#line 6334
    l_tccp___2->m_dc_level_shift = 0;
#line 6335
    l_tccp___2 ++;
#line 6333
    i___52 ++;
  }
  while_break___1: /* CIL Label */ ;
  }

  while_break: ;
#line 6338
  if (l_tcp___19->m_mct_decoding_matrix) {
    {
#line 6339
    opj_free((void *)l_tcp___19->m_mct_decoding_matrix);
#line 6340
    l_tcp___19->m_mct_decoding_matrix = (OPJ_FLOAT32 *)0;
    }
  }
#line 6343
  i___52 = (OPJ_UINT32 )0;
  {
#line 6343
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 6343
    if (! (i___52 < l_nb_stages)) {
#line 6343
      goto while_break___0;
    }
    {
#line 6344
    opj_read_bytes_LE(p_header_data___20, & l_tmp___6, (OPJ_UINT32 )1);
#line 6345
    p_header_data___20 ++;
#line 6347
    __cil_tmp15___15 = opj_j2k_add_mct(l_tcp___19, p_j2k___55->m_private_image, l_tmp___6);
    }
#line 6347
    if (! __cil_tmp15___15) {
#line 6348
      return (0);
    }
#line 6343
    i___52 ++;
  }
  while_break___2: /* CIL Label */ ;
  }

  while_break___0: ;
#line 6352
  return (1);
}
}
#line 6355 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_add_mct(opj_tcp_t *p_tcp___2 , opj_image_t *p_image___10 ,
                                OPJ_UINT32 p_index ) 
{ 
  OPJ_UINT32 i___53 ;
  opj_simple_mcc_decorrelation_data_t *l_mcc_record___3 ;
  opj_mct_data_t *l_deco_array ;
  opj_mct_data_t *l_offset_array ;
  OPJ_UINT32 l_data_size___1 ;
  OPJ_UINT32 l_mct_size___0 ;
  OPJ_UINT32 l_offset_size ;
  OPJ_UINT32 l_nb_elem ;
  OPJ_UINT32 *l_offset_data ;
  OPJ_UINT32 *l_current_offset_data ;
  opj_tccp_t *l_tccp___3 ;
  void *__cil_tmp16___12 ;
  void *__cil_tmp17___10 ;
  OPJ_UINT32 *__cil_tmp18___4 ;

  {
#line 6369
  l_mcc_record___3 = p_tcp___2->m_mcc_records;
#line 6371
  i___53 = (OPJ_UINT32 )0;
  {
#line 6371
  while (1) {
    while_continue: /* CIL Label */ ;

#line 6371
    if (! (i___53 < p_tcp___2->m_nb_mcc_records)) {
#line 6371
      goto while_break;
    }
#line 6372
    if (l_mcc_record___3->m_index == p_index) {
#line 6373
      goto while_break;
    }
#line 6371
    i___53 ++;
  }
  while_break___1: /* CIL Label */ ;
  }

  while_break: ;
#line 6377
  if (i___53 == p_tcp___2->m_nb_mcc_records) {
#line 6379
    return (1);
  }
#line 6382
  if (l_mcc_record___3->m_nb_comps != p_image___10->numcomps) {
#line 6384
    return (1);
  }
#line 6387
  l_deco_array = l_mcc_record___3->m_decorrelation_array;
#line 6389
  if (l_deco_array) {
#line 6390
    l_data_size___1 = (MCT_ELEMENT_SIZE[l_deco_array->m_element_type] * p_image___10->numcomps) * p_image___10->numcomps;
#line 6392
    if (l_deco_array->m_data_size != l_data_size___1) {
#line 6393
      return (0);
    }
    {
#line 6396
    l_nb_elem = p_image___10->numcomps * p_image___10->numcomps;
#line 6397
    l_mct_size___0 = l_nb_elem * (OPJ_UINT32 )sizeof(OPJ_FLOAT32 );
#line 6398
    __cil_tmp16___12 = opj_malloc((size_t )l_mct_size___0);
#line 6398
    p_tcp___2->m_mct_decoding_matrix = (OPJ_FLOAT32 *)__cil_tmp16___12;
    }
#line 6400
    if (! p_tcp___2->m_mct_decoding_matrix) {
#line 6401
      return (0);
    }
    {
#line 6404
    (*(j2k_mct_read_functions_to_float[l_deco_array->m_element_type]))((void const   *)l_deco_array->m_data,
                                                                       (void *)p_tcp___2->m_mct_decoding_matrix,
                                                                       l_nb_elem);
    }
  }
#line 6408
  l_offset_array = l_mcc_record___3->m_offset_array;
#line 6410
  if (l_offset_array) {
#line 6411
    l_data_size___1 = MCT_ELEMENT_SIZE[l_offset_array->m_element_type] * p_image___10->numcomps;
#line 6413
    if (l_offset_array->m_data_size != l_data_size___1) {
#line 6414
      return (0);
    }
    {
#line 6417
    l_nb_elem = p_image___10->numcomps;
#line 6418
    l_offset_size = l_nb_elem * (OPJ_UINT32 )sizeof(OPJ_UINT32 );
#line 6419
    __cil_tmp17___10 = opj_malloc((size_t )l_offset_size);
#line 6419
    l_offset_data = (OPJ_UINT32 *)__cil_tmp17___10;
    }
#line 6421
    if (! l_offset_data) {
#line 6422
      return (0);
    }
    {
#line 6425
    (*(j2k_mct_read_functions_to_int32[l_offset_array->m_element_type]))((void const   *)l_offset_array->m_data,
                                                                         (void *)l_offset_data,
                                                                         l_nb_elem);
#line 6428
    l_tccp___3 = p_tcp___2->tccps;
#line 6429
    l_current_offset_data = l_offset_data;
#line 6431
    i___53 = (OPJ_UINT32 )0;
    }
    {
#line 6431
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 6431
      if (! (i___53 < p_image___10->numcomps)) {
#line 6431
        goto while_break___0;
      }
#line 6432
      __cil_tmp18___4 = l_current_offset_data;
#line 6432
      l_current_offset_data ++;
#line 6432
      l_tccp___3->m_dc_level_shift = (OPJ_INT32 )*__cil_tmp18___4;
#line 6433
      l_tccp___3 ++;
#line 6431
      i___53 ++;
    }
    while_break___2: /* CIL Label */ ;
    }

    while_break___0: 
    {
#line 6436
    opj_free((void *)l_offset_data);
    }
  }
#line 6439
  return (1);
}
}
#line 6442 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_cbd(opj_j2k_t *p_j2k___56 , struct opj_stream_private *p_stream___41 ,
                                  struct opj_event_mgr *p_manager___95 ) 
{ 
  OPJ_UINT32 i___54 ;
  OPJ_UINT32 l_cbd_size ;
  OPJ_BYTE *l_current_data___11 ;
  opj_image_t *l_image___9 ;
  opj_image_comp_t *l_comp ;
  OPJ_BYTE *new_header_tile_data___10 ;
  void *__cil_tmp13___17 ;
  OPJ_SIZE_T __cil_tmp14___24 ;

  {
#line 6448
  l_current_data___11 = (OPJ_BYTE *)0;
#line 6449
  l_image___9 = (opj_image_t *)0;
#line 6450
  l_comp = (opj_image_comp_t *)0;
#line 6457
  l_image___9 = p_j2k___56->m_private_image;
#line 6458
  l_cbd_size = 6U + (p_j2k___56->m_private_image)->numcomps;
#line 6460
  if (l_cbd_size > p_j2k___56->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 6461
    __cil_tmp13___17 = opj_realloc((void *)p_j2k___56->m_specific_param.m_encoder.m_header_tile_data,
                                   (size_t )l_cbd_size);
#line 6461
    new_header_tile_data___10 = (OPJ_BYTE *)__cil_tmp13___17;
    }
#line 6463
    if (! new_header_tile_data___10) {
      {
#line 6464
      opj_free((void *)p_j2k___56->m_specific_param.m_encoder.m_header_tile_data);
#line 6465
      p_j2k___56->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 6466
      p_j2k___56->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 6467
      opj_event_msg(p_manager___95, 1, "Not enough memory to write CBD marker\n");
      }
#line 6468
      return (0);
    }
#line 6470
    p_j2k___56->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data___10;
#line 6471
    p_j2k___56->m_specific_param.m_encoder.m_header_tile_data_size = l_cbd_size;
  }
  {
#line 6474
  l_current_data___11 = p_j2k___56->m_specific_param.m_encoder.m_header_tile_data;
#line 6476
  opj_write_bytes_LE(l_current_data___11, (OPJ_UINT32 )65400, (OPJ_UINT32 )2);
#line 6477
  l_current_data___11 += 2;
#line 6479
  opj_write_bytes_LE(l_current_data___11, l_cbd_size - 2U, (OPJ_UINT32 )2);
#line 6480
  l_current_data___11 += 2;
#line 6482
  opj_write_bytes_LE(l_current_data___11, l_image___9->numcomps, (OPJ_UINT32 )2);
#line 6483
  l_current_data___11 += 2;
#line 6485
  l_comp = l_image___9->comps;
#line 6487
  i___54 = (OPJ_UINT32 )0;
  }
  {
#line 6487
  while (1) {
    while_continue: /* CIL Label */ ;

#line 6487
    if (! (i___54 < l_image___9->numcomps)) {
#line 6487
      goto while_break;
    }
    {
#line 6488
    opj_write_bytes_LE(l_current_data___11, (l_comp->sgnd << 7) | (l_comp->prec - 1U),
                       (OPJ_UINT32 )1);
#line 6490
    l_current_data___11 ++;
#line 6492
    l_comp ++;
#line 6487
    i___54 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: 
  {
#line 6495
  __cil_tmp14___24 = opj_stream_write_data(p_stream___41, p_j2k___56->m_specific_param.m_encoder.m_header_tile_data,
                                           (OPJ_SIZE_T )l_cbd_size, p_manager___95);
  }
#line 6495
  if (__cil_tmp14___24 != (unsigned long )l_cbd_size) {
#line 6498
    return (0);
  }
#line 6501
  return (1);
}
}
#line 6511 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_cbd(opj_j2k_t *p_j2k___57 , OPJ_BYTE *p_header_data___21 ,
                                 OPJ_UINT32 p_header_size___21 , opj_event_mgr_t *p_manager___96 ) 
{ 
  OPJ_UINT32 l_nb_comp___6 ;
  OPJ_UINT32 l_num_comp___0 ;
  OPJ_UINT32 l_comp_def ;
  OPJ_UINT32 i___55 ;
  opj_image_comp_t *l_comp___0 ;

  {
#line 6520
  l_comp___0 = (opj_image_comp_t *)0;
#line 6527
  l_num_comp___0 = (p_j2k___57->m_private_image)->numcomps;
#line 6529
  if (p_header_size___21 != (p_j2k___57->m_private_image)->numcomps + 2U) {
    {
#line 6530
    opj_event_msg(p_manager___96, 1, "Crror reading CBD marker\n");
    }
#line 6531
    return (0);
  }
  {
#line 6534
  opj_read_bytes_LE(p_header_data___21, & l_nb_comp___6, (OPJ_UINT32 )2);
#line 6536
  p_header_data___21 += 2;
  }
#line 6538
  if (l_nb_comp___6 != l_num_comp___0) {
    {
#line 6539
    opj_event_msg(p_manager___96, 1, "Crror reading CBD marker\n");
    }
#line 6540
    return (0);
  }
#line 6543
  l_comp___0 = (p_j2k___57->m_private_image)->comps;
#line 6544
  i___55 = (OPJ_UINT32 )0;
  {
#line 6544
  while (1) {
    while_continue: /* CIL Label */ ;

#line 6544
    if (! (i___55 < l_num_comp___0)) {
#line 6544
      goto while_break;
    }
    {
#line 6545
    opj_read_bytes_LE(p_header_data___21, & l_comp_def, (OPJ_UINT32 )1);
#line 6547
    p_header_data___21 ++;
#line 6548
    l_comp___0->sgnd = (l_comp_def >> 7) & 1U;
#line 6549
    l_comp___0->prec = (l_comp_def & 127U) + 1U;
    }
#line 6551
    if (l_comp___0->prec > 31U) {
      {
#line 6552
      opj_event_msg(p_manager___96, 1, "Invalid values for comp = %d : prec=%u (should be between 1 and 38 according to the JPEG2000 norm. OpenJpeg only supports up to 31)\n",
                    i___55, l_comp___0->prec);
      }
#line 6555
      return (0);
    }
#line 6557
    l_comp___0 ++;
#line 6544
    i___55 ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 6560
  return (1);
}
}
#line 6567 "/root/patron-new/39/src/lib/openjp2/j2k.c"
void opj_j2k_setup_decoder(opj_j2k_t *j2k , opj_dparameters_t *parameters___6 ) 
{ 


  {
#line 6569
  if (j2k) {
#line 6569
    if (parameters___6) {
#line 6570
      j2k->m_cp.m_specific_param.m_dec.m_layer = parameters___6->cp_layer;
#line 6571
      j2k->m_cp.m_specific_param.m_dec.m_reduce = parameters___6->cp_reduce;
#line 6573
      j2k->dump_state = parameters___6->flags & 2U;
    }
  }
#line 6576
  return;
}
}
#line 6582 "/root/patron-new/39/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_set_threads(opj_j2k_t *j2k___0 , OPJ_UINT32 num_threads___1 ) 
{ 
  OPJ_BOOL __cil_tmp3___19 ;

  {
  {
#line 6586
  __cil_tmp3___19 = opj_has_thread_support();
  }
#line 6586
  if ((unsigned long )j2k___0->m_tcd == (unsigned long )((void *)0)) {
#line 6586
    if (__cil_tmp3___19) {
      {
#line 6587
      opj_thread_pool_destroy(j2k___0->m_tp);
#line 6588
      j2k___0->m_tp = (opj_thread_pool_t *)((void *)0);
      }
#line 6589
      if (num_threads___1 <= 2147483647U) {
        {
#line 6590
        j2k___0->m_tp = opj_thread_pool_create((int )num_threads___1);
        }
      }
#line 6592
      if ((unsigned long )j2k___0->m_tp == (unsigned long )((void *)0)) {
        {
#line 6593
        j2k___0->m_tp = opj_thread_pool_create(0);
        }
#line 6594
        return (0);
      }
#line 6596
      return (1);
    }
  }
#line 6598
  return (0);
}
}
#line 6601 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static int opj_j2k_get_default_thread_count(void) 
{ 
  char const   *num_threads_str ;
  char *__cil_tmp2___8 ;
  int num_cpus ;
  int num_threads___2 ;
  OPJ_BOOL __cil_tmp5___17 ;
  int __cil_tmp7___21 ;

  {
  {
#line 6603
  __cil_tmp2___8 = getenv("OPJ_NUM_THREADS");
#line 6603
  num_threads_str = (char const   *)__cil_tmp2___8;
#line 6607
  __cil_tmp5___17 = opj_has_thread_support();
  }
#line 6607
  if ((unsigned long )num_threads_str == (unsigned long )((void *)0)) {
#line 6608
    return (0);
  } else
#line 6607
  if (! __cil_tmp5___17) {
#line 6608
    return (0);
  }
  {
#line 6610
  num_cpus = opj_get_num_cpus();
#line 6611
  __cil_tmp7___21 = strcmp(num_threads_str, "ALL_CPUS\220");
  }
#line 6611
  if (__cil_tmp7___21 == 0) {
#line 6612
    return (num_cpus);
  }
#line 6614
  if (num_cpus == 0) {
#line 6615
    num_cpus = 32;
  }
  {
#line 6617
  num_threads___2 = atoi(num_threads_str);
  }
#line 6618
  if (num_threads___2 < 0) {
#line 6619
    num_threads___2 = 0;
  } else
#line 6620
  if (num_threads___2 > 2 * num_cpus) {
#line 6621
    num_threads___2 = 2 * num_cpus;
  }
#line 6623
  return (num_threads___2);
}
}
#line 6630 "/root/patron-new/39/src/lib/openjp2/j2k.c"
opj_j2k_t *opj_j2k_create_compress(void) 
{ 
  opj_j2k_t *l_j2k ;
  void *__cil_tmp2___9 ;
  void *__cil_tmp3___20 ;
  int __cil_tmp6___13 ;
  opj_thread_pool_t *__cil_tmp7___22 ;

  {
  {
#line 6632
  __cil_tmp2___9 = opj_calloc((size_t )1, sizeof(opj_j2k_t ));
#line 6632
  l_j2k = (opj_j2k_t *)__cil_tmp2___9;
  }
#line 6633
  if (! l_j2k) {
#line 6634
    return ((opj_j2k_t *)((void *)0));
  }
  {
#line 6638
  l_j2k->m_is_decoder = 0;
#line 6639
  l_j2k->m_cp.m_is_decoder = (OPJ_BITFIELD )0;
#line 6641
  __cil_tmp3___20 = opj_malloc((size_t )1000);
#line 6641
  l_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)__cil_tmp3___20;
  }
#line 6643
  if (! l_j2k->m_specific_param.m_encoder.m_header_tile_data) {
    {
#line 6644
    opj_j2k_destroy(l_j2k);
    }
#line 6645
    return ((opj_j2k_t *)((void *)0));
  }
  {
#line 6648
  l_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )1000;
#line 6652
  l_j2k->m_validation_list = opj_procedure_list_create();
  }
#line 6653
  if (! l_j2k->m_validation_list) {
    {
#line 6654
    opj_j2k_destroy(l_j2k);
    }
#line 6655
    return ((opj_j2k_t *)((void *)0));
  }
  {
#line 6659
  l_j2k->m_procedure_list = opj_procedure_list_create();
  }
#line 6660
  if (! l_j2k->m_procedure_list) {
    {
#line 6661
    opj_j2k_destroy(l_j2k);
    }
#line 6662
    return ((opj_j2k_t *)((void *)0));
  }
  {
#line 6665
  __cil_tmp6___13 = opj_j2k_get_default_thread_count();
#line 6665
  __cil_tmp7___22 = opj_thread_pool_create(__cil_tmp6___13);
#line 6665
  l_j2k->m_tp = __cil_tmp7___22;
  }
#line 6666
  if (! l_j2k->m_tp) {
    {
#line 6667
    l_j2k->m_tp = opj_thread_pool_create(0);
    }
  }
#line 6669
  if (! l_j2k->m_tp) {
    {
#line 6670
    opj_j2k_destroy(l_j2k);
    }
#line 6671
    return ((opj_j2k_t *)((void *)0));
  }
#line 6674
  return (l_j2k);
}
}
#line 6677 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static int opj_j2k_initialise_4K_poc(opj_poc_t *POC , int numres ) 
{ 


  {
#line 6679
  (POC + 0)->tile = (OPJ_UINT32 )1;
#line 6680
  (POC + 0)->resno0 = (OPJ_UINT32 )0;
#line 6681
  (POC + 0)->compno0 = (OPJ_UINT32 )0;
#line 6682
  (POC + 0)->layno1 = (OPJ_UINT32 )1;
#line 6683
  (POC + 0)->resno1 = (OPJ_UINT32 )(numres - 1);
#line 6684
  (POC + 0)->compno1 = (OPJ_UINT32 )3;
#line 6685
  (POC + 0)->prg1 = (OPJ_PROG_ORDER )4;
#line 6686
  (POC + 1)->tile = (OPJ_UINT32 )1;
#line 6687
  (POC + 1)->resno0 = (OPJ_UINT32 )(numres - 1);
#line 6688
  (POC + 1)->compno0 = (OPJ_UINT32 )0;
#line 6689
  (POC + 1)->layno1 = (OPJ_UINT32 )1;
#line 6690
  (POC + 1)->resno1 = (OPJ_UINT32 )numres;
#line 6691
  (POC + 1)->compno1 = (OPJ_UINT32 )3;
#line 6692
  (POC + 1)->prg1 = (OPJ_PROG_ORDER )4;
#line 6693
  return (2);
}
}
#line 6696 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static void opj_j2k_set_cinema_parameters(opj_cparameters_t *parameters___7 , opj_image_t *image___4 ,
                                          opj_event_mgr_t *p_manager___97 ) 
{ 
  int i___56 ;
  int __cil_tmp6___14 ;

  {
#line 6703
  parameters___7->tile_size_on = 0;
#line 6704
  parameters___7->cp_tdx = 1;
#line 6705
  parameters___7->cp_tdy = 1;
#line 6708
  parameters___7->tp_flag = (char )'C';
#line 6709
  parameters___7->tp_on = (char)1;
#line 6712
  parameters___7->cp_tx0 = 0;
#line 6713
  parameters___7->cp_ty0 = 0;
#line 6714
  parameters___7->image_offset_x0 = 0;
#line 6715
  parameters___7->image_offset_y0 = 0;
#line 6718
  parameters___7->cblockw_init = 32;
#line 6719
  parameters___7->cblockh_init = 32;
#line 6722
  parameters___7->mode = 0;
#line 6725
  parameters___7->roi_compno = -1;
#line 6728
  parameters___7->subsampling_dx = 1;
#line 6729
  parameters___7->subsampling_dy = 1;
#line 6732
  parameters___7->irreversible = 1;
#line 6735
  if (parameters___7->tcp_numlayers > 1) {
    {
#line 6736
    opj_event_msg(p_manager___97, 2, "JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\n1 single quality layer-> Number of layers forced to 1 (rather than %d)\n-> Rate of the last layer (%3.1f) will be used\230\001",
                  parameters___7->tcp_numlayers, (double )parameters___7->tcp_rates[parameters___7->tcp_numlayers - 1]);
#line 6743
    parameters___7->tcp_rates[0] = parameters___7->tcp_rates[parameters___7->tcp_numlayers - 1];
#line 6744
    parameters___7->tcp_numlayers = 1;
    }
  }
#line 6749
  if ((int )parameters___7->rsiz == 3) {
#line 6749
    goto case_3;
  }
#line 6759
  if ((int )parameters___7->rsiz == 4) {
#line 6759
    goto case_4;
  }
#line 6776
  goto switch_default;
  case_3: 
#line 6750
  if (parameters___7->numresolution > 6) {
    {
#line 6751
    opj_event_msg(p_manager___97, 2, "JPEG 2000 Profile-3 (2k dc profile) requires:\nNumber of decomposition levels <= 5\n-> Number of decomposition levels forced to 5 (rather than %d)\n",
                  parameters___7->numresolution + 1);
#line 6756
    parameters___7->numresolution = 6;
    }
  }
#line 6758
  goto switch_break;
  case_4: 
#line 6760
  if (parameters___7->numresolution < 2) {
    {
#line 6761
    opj_event_msg(p_manager___97, 2, "JPEG 2000 Profile-4 (4k dc profile) requires:\nNumber of decomposition levels >= 1 && <= 6\n-> Number of decomposition levels forced to 1 (rather than %d)\n",
                  parameters___7->numresolution + 1);
#line 6766
    parameters___7->numresolution = 1;
    }
  } else
#line 6767
  if (parameters___7->numresolution > 7) {
    {
#line 6768
    opj_event_msg(p_manager___97, 2, "JPEG 2000 Profile-4 (4k dc profile) requires:\nNumber of decomposition levels >= 1 && <= 6\n-> Number of decomposition levels forced to 6 (rather than %d)\n",
                  parameters___7->numresolution + 1);
#line 6773
    parameters___7->numresolution = 7;
    }
  }
#line 6775
  goto switch_break;
  switch_default: 
#line 6777
  goto switch_break;
  switch_break: 
#line 6781
  parameters___7->csty |= 1;
#line 6782
  if (parameters___7->numresolution == 1) {
#line 6783
    parameters___7->res_spec = 1;
#line 6784
    parameters___7->prcw_init[0] = 128;
#line 6785
    parameters___7->prch_init[0] = 128;
  } else {
#line 6787
    parameters___7->res_spec = parameters___7->numresolution - 1;
#line 6788
    i___56 = 0;
    {
#line 6788
    while (1) {
      while_continue: /* CIL Label */ ;

#line 6788
      if (! (i___56 < parameters___7->res_spec)) {
#line 6788
        goto while_break;
      }
#line 6789
      parameters___7->prcw_init[i___56] = 256;
#line 6790
      parameters___7->prch_init[i___56] = 256;
#line 6788
      i___56 ++;
    }
    while_break___0: /* CIL Label */ ;
    }

    while_break: ;
  }
#line 6795
  parameters___7->prog_order = (OPJ_PROG_ORDER )4;
#line 6798
  if ((int )parameters___7->rsiz == 4) {
    {
#line 6799
    __cil_tmp6___14 = opj_j2k_initialise_4K_poc(parameters___7->POC, parameters___7->numresolution);
#line 6799
    parameters___7->numpocs = (OPJ_UINT32 )__cil_tmp6___14;
    }
  } else {
#line 6802
    parameters___7->numpocs = (OPJ_UINT32 )0;
  }
#line 6806
  parameters___7->cp_disto_alloc = 1;
#line 6807
  if (parameters___7->max_cs_size <= 0) {
    {
#line 6809
    parameters___7->max_cs_size = 1302083;
#line 6810
    opj_event_msg(p_manager___97, 2, "JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\nMaximum 1302083 compressed bytes @ 24fps\nAs no rate has been given, this limit will be used.\n");
    }
  } else
#line 6814
  if (parameters___7->max_cs_size > 1302083) {
    {
#line 6815
    opj_event_msg(p_manager___97, 2, "JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\nMaximum 1302083 compressed bytes @ 24fps\n-> Specified rate exceeds this limit. Rate will be forced to 1302083 bytes.\n");
#line 6819
    parameters___7->max_cs_size = 1302083;
    }
  }
#line 6822
  if (parameters___7->max_comp_size <= 0) {
    {
#line 6824
    parameters___7->max_comp_size = 1041666;
#line 6825
    opj_event_msg(p_manager___97, 2, "JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\nMaximum 1041666 compressed bytes @ 24fps\nAs no rate has been given, this limit will be used.\n");
    }
  } else
#line 6829
  if (parameters___7->max_comp_size > 1041666) {
    {
#line 6830
    opj_event_msg(p_manager___97, 2, "JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\nMaximum 1041666 compressed bytes @ 24fps\n-> Specified rate exceeds this limit. Rate will be forced to 1041666 bytes.\n");
#line 6834
    parameters___7->max_comp_size = 1041666;
    }
  }
#line 6837
  parameters___7->tcp_rates[0] = (OPJ_FLOAT32 )(((image___4->numcomps * (image___4->comps + 0)->w) * (image___4->comps + 0)->h) * (image___4->comps + 0)->prec) / (OPJ_FLOAT32 )((((OPJ_UINT32 )parameters___7->max_cs_size * 8U) * (image___4->comps + 0)->dx) * (image___4->comps + 0)->dy);
#line 6838
  return;
}
}
#line 6844 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_is_cinema_compliant(opj_image_t *image___5 , OPJ_UINT16 rsiz ,
                                            opj_event_mgr_t *p_manager___98 ) 
{ 
  OPJ_UINT32 i___57 ;
  char signed_str[7] ;
  char unsigned_str[9] ;
  char *tmp_str ;
  char *tmp___313 ;

  {
#line 6850
  if (image___5->numcomps != 3U) {
    {
#line 6851
    opj_event_msg(p_manager___98, 2, "JPEG 2000 Profile-3 (2k dc profile) requires:\n3 components-> Number of components of input image (%d) is not compliant\n-> Non-profile-3 codestream will be generated\n",
                  image___5->numcomps);
    }
#line 6857
    return (0);
  }
#line 6861
  i___57 = (OPJ_UINT32 )0;
  {
#line 6861
  while (1) {
    while_continue: /* CIL Label */ ;

#line 6861
    if (! (i___57 < image___5->numcomps)) {
#line 6861
      goto while_break;
    }
#line 6862
    if ((unsigned int )((image___5->comps + i___57)->bpp != 12U) | (image___5->comps + i___57)->sgnd) {
#line 6863
      __asm__  ("booo_exp(/root/patron-new/39/src/lib/openjp2/j2k.c:6863)":);
#line 6864
      __asm__  ("booo_exp(/root/patron-new/39/src/lib/openjp2/j2k.c:6864)":);
#line 6865
      if ((image___5->comps + i___57)->sgnd) {
#line 6865
        tmp___313 = signed_str;
      } else {
#line 6865
        tmp___313 = unsigned_str;
      }
      {
#line 6865
      tmp_str = tmp___313;
#line 6866
      opj_event_msg(p_manager___98, 2, "JPEG 2000 Profile-3 (2k dc profile) requires:\nPrecision of each component shall be 12 bits unsigned-> At least component %d of input image (%d bits, %s) is not compliant\n-> Non-profile-3 codestream will be generated\n",
                    i___57, (image___5->comps + i___57)->bpp, tmp_str);
      }
#line 6872
      return (0);
    }
#line 6861
    i___57 ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 6878
  if ((int )rsiz == 3) {
#line 6878
    goto case_3;
  }
#line 6889
  if ((int )rsiz == 4) {
#line 6889
    goto case_4;
  }
#line 6900
  goto switch_default;
  case_3: 
#line 6879
  if (((image___5->comps + 0)->w > 2048U) | ((image___5->comps + 0)->h > 1080U)) {
    {
#line 6880
    opj_event_msg(p_manager___98, 2, "JPEG 2000 Profile-3 (2k dc profile) requires:\nwidth <= 2048 and height <= 1080\n-> Input image size %d x %d is not compliant\n-> Non-profile-3 codestream will be generated\n",
                  (image___5->comps + 0)->w, (image___5->comps + 0)->h);
    }
#line 6886
    return (0);
  }
#line 6888
  goto switch_break;
  case_4: 
#line 6890
  if (((image___5->comps + 0)->w > 4096U) | ((image___5->comps + 0)->h > 2160U)) {
    {
#line 6891
    opj_event_msg(p_manager___98, 2, "JPEG 2000 Profile-4 (4k dc profile) requires:\nwidth <= 4096 and height <= 2160\n-> Image size %d x %d is not compliant\n-> Non-profile-4 codestream will be generated\n\230\001",
                  (image___5->comps + 0)->w, (image___5->comps + 0)->h);
    }
#line 6897
    return (0);
  }
#line 6899
  goto switch_break;
  switch_default: 
#line 6901
  goto switch_break;
  switch_break: ;
#line 6904
  return (1);
}
}
#line 6907 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static int opj_j2k_get_imf_max_NL(opj_cparameters_t *parameters___8 , opj_image_t *image___6 ) 
{ 
  OPJ_UINT16 rsiz___0 ;
  OPJ_UINT16 profile ;
  OPJ_UINT32 XTsiz ;
  OPJ_UINT32 tmp___314 ;

  {
#line 6911
  rsiz___0 = parameters___8->rsiz;
#line 6912
  profile = (OPJ_UINT16 )((int )rsiz___0 & 65280);
#line 6913
  if (parameters___8->tile_size_on) {
#line 6913
    tmp___314 = (OPJ_UINT32 )parameters___8->cp_tdx;
  } else {
#line 6913
    tmp___314 = image___6->x1;
  }
#line 6913
  XTsiz = tmp___314;
#line 6916
  if ((int )profile == 1024) {
#line 6916
    goto case_1024;
  }
#line 6918
  if ((int )profile == 1280) {
#line 6918
    goto case_1280;
  }
#line 6920
  if ((int )profile == 1536) {
#line 6920
    goto case_1536;
  }
#line 6922
  if ((int )profile == 1792) {
#line 6922
    goto case_1792;
  }
#line 6930
  if ((int )profile == 2048) {
#line 6930
    goto case_2048;
  }
#line 6940
  if ((int )profile == 2304) {
#line 6940
    goto case_2304;
  }
#line 6952
  goto switch_default;
  case_1024: 
#line 6917
  return (5);
  case_1280: 
#line 6919
  return (6);
  case_1536: 
#line 6921
  return (7);
  case_1792: 
#line 6923
  if (XTsiz >= 2048U) {
#line 6924
    return (5);
  } else
#line 6925
  if (XTsiz >= 1024U) {
#line 6926
    return (4);
  }
#line 6928
  goto switch_break;
  case_2048: 
#line 6931
  if (XTsiz >= 4096U) {
#line 6932
    return (6);
  } else
#line 6933
  if (XTsiz >= 2048U) {
#line 6934
    return (5);
  } else
#line 6935
  if (XTsiz >= 1024U) {
#line 6936
    return (4);
  }
#line 6938
  goto switch_break;
  case_2304: 
#line 6941
  if (XTsiz >= 8192U) {
#line 6942
    return (7);
  } else
#line 6943
  if (XTsiz >= 4096U) {
#line 6944
    return (6);
  } else
#line 6945
  if (XTsiz >= 2048U) {
#line 6946
    return (5);
  } else
#line 6947
  if (XTsiz >= 1024U) {
#line 6948
    return (4);
  }
#line 6950
  goto switch_break;
  switch_default: 
#line 6953
  goto switch_break;
  switch_break: ;
#line 6955
  return (-1);
}
}
#line 6958 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static void opj_j2k_set_imf_parameters(opj_cparameters_t *parameters___9 , opj_image_t *image___7 ,
                                       opj_event_mgr_t *p_manager___99 ) 
{ 
  OPJ_UINT16 rsiz___1 ;
  OPJ_UINT16 profile___0 ;
  int max_NL ;
  int __cil_tmp7___23 ;
  int __cil_tmp8___38 ;
  int __cil_tmp9___15 ;
  int i___58 ;

  {
#line 6961
  rsiz___1 = parameters___9->rsiz;
#line 6962
  profile___0 = (OPJ_UINT16 )((int )rsiz___1 & 65280);
#line 6967
  if (parameters___9->cblockw_init == 64) {
#line 6967
    if (parameters___9->cblockh_init == 64) {
#line 6969
      parameters___9->cblockw_init = 32;
#line 6970
      parameters___9->cblockh_init = 32;
    }
  }
#line 6974
  parameters___9->tp_flag = (char )'C';
#line 6975
  parameters___9->tp_on = (char)1;
#line 6977
  if ((int )parameters___9->prog_order == 0) {
#line 6978
    parameters___9->prog_order = (OPJ_PROG_ORDER )4;
  }
#line 6981
  if ((int )profile___0 == 1024) {
#line 6985
    parameters___9->irreversible = 1;
  } else
#line 6981
  if ((int )profile___0 == 1280) {
#line 6985
    parameters___9->irreversible = 1;
  } else
#line 6981
  if ((int )profile___0 == 1536) {
#line 6985
    parameters___9->irreversible = 1;
  }
#line 6989
  if (parameters___9->numresolution == 6) {
#line 6989
    if (image___7->x0 == 0U) {
#line 6989
      if (image___7->y0 == 0U) {
        {
#line 6992
        __cil_tmp7___23 = opj_j2k_get_imf_max_NL(parameters___9, image___7);
#line 6992
        max_NL = __cil_tmp7___23;
        }
#line 6993
        if (max_NL >= 0) {
#line 6993
          if (parameters___9->numresolution > max_NL) {
#line 6994
            parameters___9->numresolution = max_NL + 1;
          }
        }
#line 6998
        if (! parameters___9->tile_size_on) {
          {
#line 6999
          while (1) {
            while_continue___0: /* CIL Label */ ;

            while_continue: ;
#line 6999
            if (! (parameters___9->numresolution > 0)) {
#line 6999
              goto while_break;
            }
#line 7000
            if (image___7->x1 < 1U << ((OPJ_UINT32 )parameters___9->numresolution - 1U)) {
#line 7001
              __cil_tmp8___38 = parameters___9->numresolution;
#line 7001
              (parameters___9->numresolution) --;
#line 7002
              goto while_continue;
            }
#line 7004
            if (image___7->y1 < 1U << ((OPJ_UINT32 )parameters___9->numresolution - 1U)) {
#line 7005
              __cil_tmp9___15 = parameters___9->numresolution;
#line 7005
              (parameters___9->numresolution) --;
#line 7006
              goto while_continue;
            }
#line 7008
            goto while_break;
          }
          while_break___1: /* CIL Label */ ;
          }

          while_break: ;
        }
      }
    }
  }
#line 7014
  if (parameters___9->csty == 0) {
#line 7015
    parameters___9->csty |= 1;
#line 7016
    if (parameters___9->numresolution == 1) {
#line 7017
      parameters___9->res_spec = 1;
#line 7018
      parameters___9->prcw_init[0] = 128;
#line 7019
      parameters___9->prch_init[0] = 128;
    } else {
#line 7022
      parameters___9->res_spec = parameters___9->numresolution - 1;
#line 7023
      i___58 = 0;
      {
#line 7023
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 7023
        if (! (i___58 < parameters___9->res_spec)) {
#line 7023
          goto while_break___0;
        }
#line 7024
        parameters___9->prcw_init[i___58] = 256;
#line 7025
        parameters___9->prch_init[i___58] = 256;
#line 7023
        i___58 ++;
      }
      while_break___2: /* CIL Label */ ;
      }

      while_break___0: ;
    }
  }
#line 7029
  return;
}
}
#line 7032 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_UINT16 tabMaxSubLevelFromMainLevel[12]  = 
#line 7032
  {      (OPJ_UINT16 )15,      (OPJ_UINT16 )1,      (OPJ_UINT16 )1,      (OPJ_UINT16 )1, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )3,      (OPJ_UINT16 )4,      (OPJ_UINT16 )5, 
        (OPJ_UINT16 )6,      (OPJ_UINT16 )7,      (OPJ_UINT16 )8,      (OPJ_UINT16 )9};
#line 7047 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_is_imf_compliant(opj_cparameters_t *parameters___10 , opj_image_t *image___8 ,
                                         opj_event_mgr_t *p_manager___100 ) 
{ 
  OPJ_UINT32 i___59 ;
  OPJ_UINT16 rsiz___2 ;
  OPJ_UINT16 profile___1 ;
  OPJ_UINT16 mainlevel ;
  OPJ_UINT16 sublevel ;
  int NL ;
  OPJ_UINT32 XTsiz___0 ;
  OPJ_UINT32 tmp___315 ;
  OPJ_BOOL ret___0 ;
  char signed_str___0[7] ;
  char unsigned_str___0[9] ;
  char *tmp_str___0 ;
  char *tmp___317 ;
  int i___60 ;

  {
#line 7052
  rsiz___2 = parameters___10->rsiz;
#line 7053
  profile___1 = (OPJ_UINT16 )((int )rsiz___2 & 65280);
#line 7054
  mainlevel = (OPJ_UINT16 )((int )rsiz___2 & 15);
#line 7055
  sublevel = (OPJ_UINT16 )(((int )rsiz___2 >> 4) & 15);
#line 7056
  NL = parameters___10->numresolution - 1;
#line 7057
  if (parameters___10->tile_size_on) {
#line 7057
    tmp___315 = (OPJ_UINT32 )parameters___10->cp_tdx;
  } else {
#line 7057
    tmp___315 = image___8->x1;
  }
#line 7057
  XTsiz___0 = tmp___315;
#line 7059
  ret___0 = 1;
#line 7062
  if ((int )mainlevel > 11) {
    {
#line 7063
    opj_event_msg(p_manager___100, 2, "IMF profile require mainlevel <= 11.\n-> %d is thus not compliant\n-> Non-IMF codestream will be generated\n",
                  (int )mainlevel);
#line 7068
    ret___0 = 0;
    }
  }
#line 7074
  if ((int )sublevel > (int )tabMaxSubLevelFromMainLevel[mainlevel]) {
    {
#line 7075
    opj_event_msg(p_manager___100, 2, "IMF profile require sublevel <= %d for mainlevel = %d.\n-> %d is thus not compliant\n-> Non-IMF codestream will be generated\n",
                  (int )tabMaxSubLevelFromMainLevel[mainlevel], (int )mainlevel, (int )sublevel);
#line 7082
    ret___0 = 0;
    }
  }
#line 7086
  if (image___8->numcomps > 3U) {
    {
#line 7087
    opj_event_msg(p_manager___100, 2, "IMF profiles require at most 3 components.\n-> Number of components of input image (%d) is not compliant\n-> Non-IMF codestream will be generated\n\230\001",
                  image___8->numcomps);
#line 7092
    ret___0 = 0;
    }
  }
#line 7095
  if (image___8->x0 != 0U) {
    {
#line 7096
    opj_event_msg(p_manager___100, 2, "IMF profiles require image origin to be at 0,0.\n-> %d,%d is not compliant\n-> Non-IMF codestream will be generated\n",
                  image___8->x0, image___8->y0 != 0U);
#line 7101
    ret___0 = 0;
    }
  } else
#line 7095
  if (image___8->y0 != 0U) {
    {
#line 7096
    opj_event_msg(p_manager___100, 2, "IMF profiles require image origin to be at 0,0.\n-> %d,%d is not compliant\n-> Non-IMF codestream will be generated\n",
                  image___8->x0, image___8->y0 != 0U);
#line 7101
    ret___0 = 0;
    }
  }
#line 7104
  if (parameters___10->cp_tx0 != 0) {
    {
#line 7105
    opj_event_msg(p_manager___100, 2, "IMF profiles require tile origin to be at 0,0.\n-> %d,%d is not compliant\n-> Non-IMF codestream will be generated\n",
                  parameters___10->cp_tx0, parameters___10->cp_ty0);
#line 7110
    ret___0 = 0;
    }
  } else
#line 7104
  if (parameters___10->cp_ty0 != 0) {
    {
#line 7105
    opj_event_msg(p_manager___100, 2, "IMF profiles require tile origin to be at 0,0.\n-> %d,%d is not compliant\n-> Non-IMF codestream will be generated\n",
                  parameters___10->cp_tx0, parameters___10->cp_ty0);
#line 7110
    ret___0 = 0;
    }
  }
#line 7113
  if (parameters___10->tile_size_on) {
#line 7114
    if ((int )profile___1 == 1024) {
      _L___16: 
#line 7117
      if ((OPJ_UINT32 )parameters___10->cp_tdx < image___8->x1) {
        {
#line 7119
        opj_event_msg(p_manager___100, 2, "IMF 2K/4K/8K single tile profiles require tile to be greater or equal to image size.\n-> %d,%d is lesser than %d,%d\n-> Non-IMF codestream will be generated\n",
                      parameters___10->cp_tdx, parameters___10->cp_tdy, image___8->x1,
                      image___8->y1);
#line 7127
        ret___0 = 0;
        }
      } else
#line 7117
      if ((OPJ_UINT32 )parameters___10->cp_tdy < image___8->y1) {
        {
#line 7119
        opj_event_msg(p_manager___100, 2, "IMF 2K/4K/8K single tile profiles require tile to be greater or equal to image size.\n-> %d,%d is lesser than %d,%d\n-> Non-IMF codestream will be generated\n",
                      parameters___10->cp_tdx, parameters___10->cp_tdy, image___8->x1,
                      image___8->y1);
#line 7127
        ret___0 = 0;
        }
      }
    } else
#line 7114
    if ((int )profile___1 == 1280) {
#line 7114
      goto _L___16;
    } else
#line 7114
    if ((int )profile___1 == 1536) {
#line 7114
      goto _L___16;
    } else
#line 7130
    if ((OPJ_UINT32 )parameters___10->cp_tdx >= image___8->x1) {
#line 7130
      if (! ((OPJ_UINT32 )parameters___10->cp_tdy >= image___8->y1)) {
#line 7130
        goto _L___15;
      }
    } else
    _L___15: 
#line 7133
    if (parameters___10->cp_tdx == 1024) {
#line 7133
      if (! (parameters___10->cp_tdy == 1024)) {
#line 7133
        goto _L___14;
      }
    } else
    _L___14: 
#line 7136
    if (parameters___10->cp_tdx == 2048) {
#line 7136
      if (parameters___10->cp_tdy == 2048) {
#line 7136
        if (! ((int )profile___1 == 1280)) {
#line 7136
          if (! ((int )profile___1 == 1536)) {
#line 7136
            goto _L;
          }
        }
      } else {
#line 7136
        goto _L;
      }
    } else
    _L: 
#line 7141
    if (parameters___10->cp_tdx == 4096) {
#line 7141
      if (parameters___10->cp_tdy == 4096) {
#line 7141
        if (! ((int )profile___1 == 1536)) {
          {
#line 7146
          opj_event_msg(p_manager___100, 2, "IMF 2K_R/4K_R/8K_R single/multiple tile profiles require tile to be greater or equal to image size,\nor to be (1024,1024), or (2048,2048) for 4K_R/8K_R or (4096,4096) for 8K_R.\n-> %d,%d is non conformant\n-> Non-IMF codestream will be generated\n",
                        parameters___10->cp_tdx, parameters___10->cp_tdy);
#line 7155
          ret___0 = 0;
          }
        }
      } else {
        {
#line 7146
        opj_event_msg(p_manager___100, 2, "IMF 2K_R/4K_R/8K_R single/multiple tile profiles require tile to be greater or equal to image size,\nor to be (1024,1024), or (2048,2048) for 4K_R/8K_R or (4096,4096) for 8K_R.\n-> %d,%d is non conformant\n-> Non-IMF codestream will be generated\n",
                      parameters___10->cp_tdx, parameters___10->cp_tdy);
#line 7155
        ret___0 = 0;
        }
      }
    } else {
      {
#line 7146
      opj_event_msg(p_manager___100, 2, "IMF 2K_R/4K_R/8K_R single/multiple tile profiles require tile to be greater or equal to image size,\nor to be (1024,1024), or (2048,2048) for 4K_R/8K_R or (4096,4096) for 8K_R.\n-> %d,%d is non conformant\n-> Non-IMF codestream will be generated\n",
                    parameters___10->cp_tdx, parameters___10->cp_tdy);
#line 7155
      ret___0 = 0;
      }
    }
  }
#line 7161
  i___59 = (OPJ_UINT32 )0;
  {
#line 7161
  while (1) {
    while_continue: /* CIL Label */ ;

#line 7161
    if (! (i___59 < image___8->numcomps)) {
#line 7161
      goto while_break;
    }
#line 7162
    if ((image___8->comps + i___59)->bpp >= 8U) {
#line 7162
      if ((image___8->comps + i___59)->bpp <= 16U) {
#line 7162
        if ((image___8->comps + i___59)->sgnd) {
#line 7162
          goto _L___18;
        }
      } else {
#line 7162
        goto _L___18;
      }
    } else {
      _L___18: 
#line 7164
      __asm__  ("booo_exp(/root/patron-new/39/src/lib/openjp2/j2k.c:7164)":);
#line 7165
      __asm__  ("booo_exp(/root/patron-new/39/src/lib/openjp2/j2k.c:7165)":);
#line 7166
      if ((image___8->comps + i___59)->sgnd) {
#line 7166
        tmp___317 = signed_str___0;
      } else {
#line 7166
        tmp___317 = unsigned_str___0;
      }
      {
#line 7166
      tmp_str___0 = tmp___317;
#line 7167
      opj_event_msg(p_manager___100, 2, "IMF profiles require precision of each component to b in [8-16] bits unsigned-> At least component %d of input image (%d bits, %s) is not compliant\n-> Non-IMF codestream will be generated\n",
                    i___59, (image___8->comps + i___59)->bpp, tmp_str___0);
#line 7172
      ret___0 = 0;
      }
    }
#line 7161
    i___59 ++;
  }
  while_break___2: /* CIL Label */ ;
  }

  while_break: 
#line 7177
  i___59 = (OPJ_UINT32 )0;
  {
#line 7177
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 7177
    if (! (i___59 < image___8->numcomps)) {
#line 7177
      goto while_break___0;
    }
#line 7178
    if (i___59 == 0U) {
#line 7178
      if ((image___8->comps + i___59)->dx != 1U) {
        {
#line 7179
        opj_event_msg(p_manager___100, 2, "IMF profiles require XRSiz1 == 1. Here it is set to %d.\n-> Non-IMF codestream will be generated\n",
                      (image___8->comps + i___59)->dx);
#line 7183
        ret___0 = 0;
        }
      }
    }
#line 7185
    if (i___59 == 1U) {
#line 7185
      if ((image___8->comps + i___59)->dx != 1U) {
#line 7185
        if ((image___8->comps + i___59)->dx != 2U) {
          {
#line 7186
          opj_event_msg(p_manager___100, 2, "IMF profiles require XRSiz2 == 1 or 2. Here it is set to %d.\n-> Non-IMF codestream will be generated\n",
                        (image___8->comps + i___59)->dx);
#line 7190
          ret___0 = 0;
          }
        }
      }
    }
#line 7192
    if (i___59 > 1U) {
#line 7192
      if ((image___8->comps + i___59)->dx != (image___8->comps + (i___59 - 1U))->dx) {
        {
#line 7193
        opj_event_msg(p_manager___100, 2, "IMF profiles require XRSiz%d to be the same as XRSiz2. Here it is set to %d instead of %d.\n-> Non-IMF codestream will be generated\n",
                      i___59 + 1U, (image___8->comps + i___59)->dx, (image___8->comps + (i___59 - 1U))->dx);
#line 7198
        ret___0 = 0;
        }
      }
    }
#line 7200
    if ((image___8->comps + i___59)->dy != 1U) {
      {
#line 7201
      opj_event_msg(p_manager___100, 2, "IMF profiles require YRsiz == 1. Here it is set to %d for component i.\n-> Non-IMF codestream will be generated\n",
                    (image___8->comps + i___59)->dy, i___59);
#line 7206
      ret___0 = 0;
      }
    }
#line 7177
    i___59 ++;
  }
  while_break___3: /* CIL Label */ ;
  }

  while_break___0: ;
#line 7213
  if ((int )profile___1 == 1792) {
#line 7213
    goto case_1792;
  }
#line 7213
  if ((int )profile___1 == 1024) {
#line 7213
    goto case_1792;
  }
#line 7225
  if ((int )profile___1 == 2048) {
#line 7225
    goto case_2048;
  }
#line 7225
  if ((int )profile___1 == 1280) {
#line 7225
    goto case_2048;
  }
#line 7237
  if ((int )profile___1 == 2304) {
#line 7237
    goto case_2304;
  }
#line 7237
  if ((int )profile___1 == 1536) {
#line 7237
    goto case_2304;
  }
#line 7211
  goto switch_break;
  case_1792: 
#line 7214
  if (((image___8->comps + 0)->w > 2048U) | ((image___8->comps + 0)->h > 1556U)) {
    {
#line 7215
    opj_event_msg(p_manager___100, 2, "IMF 2K/2K_R profile require:\nwidth <= 2048 and height <= 1556\n-> Input image size %d x %d is not compliant\n-> Non-IMF codestream will be generated\n",
                  (image___8->comps + 0)->w, (image___8->comps + 0)->h);
#line 7221
    ret___0 = 0;
    }
  }
#line 7223
  goto switch_break;
  case_2048: 
#line 7226
  if (((image___8->comps + 0)->w > 4096U) | ((image___8->comps + 0)->h > 3112U)) {
    {
#line 7227
    opj_event_msg(p_manager___100, 2, "IMF 4K/4K_R profile require:\nwidth <= 4096 and height <= 3112\n-> Input image size %d x %d is not compliant\n-> Non-IMF codestream will be generated\n",
                  (image___8->comps + 0)->w, (image___8->comps + 0)->h);
#line 7233
    ret___0 = 0;
    }
  }
#line 7235
  goto switch_break;
  case_2304: 
#line 7238
  if (((image___8->comps + 0)->w > 8192U) | ((image___8->comps + 0)->h > 6224U)) {
    {
#line 7239
    opj_event_msg(p_manager___100, 2, "IMF 8K/8K_R profile require:\nwidth <= 8192 and height <= 6224\n-> Input image size %d x %d is not compliant\n-> Non-IMF codestream will be generated\n",
                  (image___8->comps + 0)->w, (image___8->comps + 0)->h);
#line 7245
    ret___0 = 0;
    }
  }
#line 7247
  goto switch_break;
#line 7250
  return (0);
  switch_break: ;
#line 7253
  if (parameters___10->roi_compno != -1) {
    {
#line 7254
    opj_event_msg(p_manager___100, 2, "IMF profile forbid RGN / region of interest marker.\n-> Compression parameters specify a ROI\n-> Non-IMF codestream will be generated\n");
#line 7258
    ret___0 = 0;
    }
  }
#line 7261
  if (parameters___10->cblockw_init != 32) {
    {
#line 7262
    opj_event_msg(p_manager___100, 2, "IMF profile require code block size to be 32x32.\n-> Compression parameters set it to %dx%d.\n-> Non-IMF codestream will be generated\n",
                  parameters___10->cblockw_init, parameters___10->cblockh_init);
#line 7268
    ret___0 = 0;
    }
  } else
#line 7261
  if (parameters___10->cblockh_init != 32) {
    {
#line 7262
    opj_event_msg(p_manager___100, 2, "IMF profile require code block size to be 32x32.\n-> Compression parameters set it to %dx%d.\n-> Non-IMF codestream will be generated\n",
                  parameters___10->cblockw_init, parameters___10->cblockh_init);
#line 7268
    ret___0 = 0;
    }
  }
#line 7271
  if ((int )parameters___10->prog_order != 4) {
    {
#line 7272
    opj_event_msg(p_manager___100, 2, "IMF profile require progression order to be CPRL.\n-> Compression parameters set it to %d.\n-> Non-IMF codestream will be generated\n",
                  (int )parameters___10->prog_order);
#line 7277
    ret___0 = 0;
    }
  }
#line 7280
  if (parameters___10->numpocs != 0U) {
    {
#line 7281
    opj_event_msg(p_manager___100, 2, "IMF profile forbid POC markers.\n-> Compression parameters set %d POC.\n-> Non-IMF codestream will be generated\n",
                  parameters___10->numpocs);
#line 7286
    ret___0 = 0;
    }
  }
#line 7290
  if (parameters___10->mode != 0) {
    {
#line 7291
    opj_event_msg(p_manager___100, 2, "IMF profile forbid mode switch in code block style.\n-> Compression parameters set code block style to %d.\n-> Non-IMF codestream will be generated\n",
                  parameters___10->mode);
#line 7296
    ret___0 = 0;
    }
  }
#line 7299
  if ((int )profile___1 == 1024) {
    _L___19: 
#line 7303
    if (parameters___10->irreversible != 1) {
      {
#line 7304
      opj_event_msg(p_manager___100, 2, "IMF 2K/4K/8K profiles require 9-7 Irreversible Transform.\n-> Compression parameters set it to reversible.\n-> Non-IMF codestream will be generated\n");
#line 7308
      ret___0 = 0;
      }
    }
  } else
#line 7299
  if ((int )profile___1 == 1280) {
#line 7299
    goto _L___19;
  } else
#line 7299
  if ((int )profile___1 == 1536) {
#line 7299
    goto _L___19;
  } else
#line 7312
  if (parameters___10->irreversible != 0) {
    {
#line 7313
    opj_event_msg(p_manager___100, 2, "IMF 2K/4K/8K profiles require 5-3 reversible Transform.\n-> Compression parameters set it to irreversible.\n-> Non-IMF codestream will be generated\n");
#line 7317
    ret___0 = 0;
    }
  }
#line 7322
  if (parameters___10->tcp_numlayers != 1) {
    {
#line 7323
    opj_event_msg(p_manager___100, 2, "IMF 2K/4K/8K profiles require 1 single quality layer.\n-> Number of layers is %d.\n-> Non-IMF codestream will be generated\n",
                  parameters___10->tcp_numlayers);
#line 7328
    ret___0 = 0;
    }
  }
#line 7333
  if ((int )profile___1 == 1024) {
#line 7333
    goto case_1024___0;
  }
#line 7343
  if ((int )profile___1 == 1280) {
#line 7343
    goto case_1280___0;
  }
#line 7353
  if ((int )profile___1 == 1536) {
#line 7353
    goto case_1536___0;
  }
#line 7363
  if ((int )profile___1 == 1792) {
#line 7363
    goto case_1792___0;
  }
#line 7385
  if ((int )profile___1 == 2048) {
#line 7385
    goto case_2048___0;
  }
#line 7416
  if ((int )profile___1 == 2304) {
#line 7416
    goto case_2304___0;
  }
#line 7456
  goto switch_default;
  case_1024___0: 
#line 7334
  if (NL >= 1) {
#line 7334
    if (! (NL <= 5)) {
      {
#line 7335
      opj_event_msg(p_manager___100, 2, "IMF 2K profile requires 1 <= NL <= 5:\n-> Number of decomposition levels is %d.\n-> Non-IMF codestream will be generated\n",
                    NL);
#line 7340
      ret___0 = 0;
      }
    }
  } else {
    {
#line 7335
    opj_event_msg(p_manager___100, 2, "IMF 2K profile requires 1 <= NL <= 5:\n-> Number of decomposition levels is %d.\n-> Non-IMF codestream will be generated\n",
                  NL);
#line 7340
    ret___0 = 0;
    }
  }
#line 7342
  goto switch_break___0;
  case_1280___0: 
#line 7344
  if (NL >= 1) {
#line 7344
    if (! (NL <= 6)) {
      {
#line 7345
      opj_event_msg(p_manager___100, 2, "IMF 4K profile requires 1 <= NL <= 6:\n-> Number of decomposition levels is %d.\n-> Non-IMF codestream will be generated\n",
                    NL);
#line 7350
      ret___0 = 0;
      }
    }
  } else {
    {
#line 7345
    opj_event_msg(p_manager___100, 2, "IMF 4K profile requires 1 <= NL <= 6:\n-> Number of decomposition levels is %d.\n-> Non-IMF codestream will be generated\n",
                  NL);
#line 7350
    ret___0 = 0;
    }
  }
#line 7352
  goto switch_break___0;
  case_1536___0: 
#line 7354
  if (NL >= 1) {
#line 7354
    if (! (NL <= 7)) {
      {
#line 7355
      opj_event_msg(p_manager___100, 2, "IMF 8K profile requires 1 <= NL <= 7:\n-> Number of decomposition levels is %d.\n-> Non-IMF codestream will be generated\n",
                    NL);
#line 7360
      ret___0 = 0;
      }
    }
  } else {
    {
#line 7355
    opj_event_msg(p_manager___100, 2, "IMF 8K profile requires 1 <= NL <= 7:\n-> Number of decomposition levels is %d.\n-> Non-IMF codestream will be generated\n",
                  NL);
#line 7360
    ret___0 = 0;
    }
  }
#line 7362
  goto switch_break___0;
  case_1792___0: 
#line 7364
  if (XTsiz___0 >= 2048U) {
#line 7365
    if (NL >= 1) {
#line 7365
      if (! (NL <= 5)) {
        {
#line 7366
        opj_event_msg(p_manager___100, 2, "IMF 2K_R profile requires 1 <= NL <= 5 for XTsiz >= 2048:\n-> Number of decomposition levels is %d.\n-> Non-IMF codestream will be generated\n",
                      NL);
#line 7371
        ret___0 = 0;
        }
      }
    } else {
      {
#line 7366
      opj_event_msg(p_manager___100, 2, "IMF 2K_R profile requires 1 <= NL <= 5 for XTsiz >= 2048:\n-> Number of decomposition levels is %d.\n-> Non-IMF codestream will be generated\n",
                    NL);
#line 7371
      ret___0 = 0;
      }
    }
  } else
#line 7373
  if (XTsiz___0 >= 1024U) {
#line 7374
    if (NL >= 1) {
#line 7374
      if (! (NL <= 4)) {
        {
#line 7375
        opj_event_msg(p_manager___100, 2, "IMF 2K_R profile requires 1 <= NL <= 4 for XTsiz in [1024,2048[:\n-> Number of decomposition levels is %d.\n-> Non-IMF codestream will be generated\n",
                      NL);
#line 7380
        ret___0 = 0;
        }
      }
    } else {
      {
#line 7375
      opj_event_msg(p_manager___100, 2, "IMF 2K_R profile requires 1 <= NL <= 4 for XTsiz in [1024,2048[:\n-> Number of decomposition levels is %d.\n-> Non-IMF codestream will be generated\n",
                    NL);
#line 7380
      ret___0 = 0;
      }
    }
  }
#line 7383
  goto switch_break___0;
  case_2048___0: 
#line 7386
  if (XTsiz___0 >= 4096U) {
#line 7387
    if (NL >= 1) {
#line 7387
      if (! (NL <= 6)) {
        {
#line 7388
        opj_event_msg(p_manager___100, 2, "IMF 4K_R profile requires 1 <= NL <= 6 for XTsiz >= 4096:\n-> Number of decomposition levels is %d.\n-> Non-IMF codestream will be generated\n",
                      NL);
#line 7393
        ret___0 = 0;
        }
      }
    } else {
      {
#line 7388
      opj_event_msg(p_manager___100, 2, "IMF 4K_R profile requires 1 <= NL <= 6 for XTsiz >= 4096:\n-> Number of decomposition levels is %d.\n-> Non-IMF codestream will be generated\n",
                    NL);
#line 7393
      ret___0 = 0;
      }
    }
  } else
#line 7395
  if (XTsiz___0 >= 2048U) {
#line 7396
    if (NL >= 1) {
#line 7396
      if (! (NL <= 5)) {
        {
#line 7397
        opj_event_msg(p_manager___100, 2, "IMF 4K_R profile requires 1 <= NL <= 5 for XTsiz in [2048,4096[:\n-> Number of decomposition levels is %d.\n-> Non-IMF codestream will be generated\n",
                      NL);
#line 7402
        ret___0 = 0;
        }
      }
    } else {
      {
#line 7397
      opj_event_msg(p_manager___100, 2, "IMF 4K_R profile requires 1 <= NL <= 5 for XTsiz in [2048,4096[:\n-> Number of decomposition levels is %d.\n-> Non-IMF codestream will be generated\n",
                    NL);
#line 7402
      ret___0 = 0;
      }
    }
  } else
#line 7404
  if (XTsiz___0 >= 1024U) {
#line 7405
    if (NL >= 1) {
#line 7405
      if (! (NL <= 4)) {
        {
#line 7406
        opj_event_msg(p_manager___100, 2, "IMF 4K_R profile requires 1 <= NL <= 4 for XTsiz in [1024,2048[:\n-> Number of decomposition levels is %d.\n-> Non-IMF codestream will be generated\n",
                      NL);
#line 7411
        ret___0 = 0;
        }
      }
    } else {
      {
#line 7406
      opj_event_msg(p_manager___100, 2, "IMF 4K_R profile requires 1 <= NL <= 4 for XTsiz in [1024,2048[:\n-> Number of decomposition levels is %d.\n-> Non-IMF codestream will be generated\n",
                    NL);
#line 7411
      ret___0 = 0;
      }
    }
  }
#line 7414
  goto switch_break___0;
  case_2304___0: 
#line 7417
  if (XTsiz___0 >= 8192U) {
#line 7418
    if (NL >= 1) {
#line 7418
      if (! (NL <= 7)) {
        {
#line 7419
        opj_event_msg(p_manager___100, 2, "IMF 4K_R profile requires 1 <= NL <= 7 for XTsiz >= 8192:\n-> Number of decomposition levels is %d.\n-> Non-IMF codestream will be generated\n",
                      NL);
#line 7424
        ret___0 = 0;
        }
      }
    } else {
      {
#line 7419
      opj_event_msg(p_manager___100, 2, "IMF 4K_R profile requires 1 <= NL <= 7 for XTsiz >= 8192:\n-> Number of decomposition levels is %d.\n-> Non-IMF codestream will be generated\n",
                    NL);
#line 7424
      ret___0 = 0;
      }
    }
  } else
#line 7426
  if (XTsiz___0 >= 4096U) {
#line 7427
    if (NL >= 1) {
#line 7427
      if (! (NL <= 6)) {
        {
#line 7428
        opj_event_msg(p_manager___100, 2, "IMF 4K_R profile requires 1 <= NL <= 6 for XTsiz in [4096,8192[:\n-> Number of decomposition levels is %d.\n-> Non-IMF codestream will be generated\n",
                      NL);
#line 7433
        ret___0 = 0;
        }
      }
    } else {
      {
#line 7428
      opj_event_msg(p_manager___100, 2, "IMF 4K_R profile requires 1 <= NL <= 6 for XTsiz in [4096,8192[:\n-> Number of decomposition levels is %d.\n-> Non-IMF codestream will be generated\n",
                    NL);
#line 7433
      ret___0 = 0;
      }
    }
  } else
#line 7435
  if (XTsiz___0 >= 2048U) {
#line 7436
    if (NL >= 1) {
#line 7436
      if (! (NL <= 5)) {
        {
#line 7437
        opj_event_msg(p_manager___100, 2, "IMF 4K_R profile requires 1 <= NL <= 5 for XTsiz in [2048,4096[:\n-> Number of decomposition levels is %d.\n-> Non-IMF codestream will be generated\n",
                      NL);
#line 7442
        ret___0 = 0;
        }
      }
    } else {
      {
#line 7437
      opj_event_msg(p_manager___100, 2, "IMF 4K_R profile requires 1 <= NL <= 5 for XTsiz in [2048,4096[:\n-> Number of decomposition levels is %d.\n-> Non-IMF codestream will be generated\n",
                    NL);
#line 7442
      ret___0 = 0;
      }
    }
  } else
#line 7444
  if (XTsiz___0 >= 1024U) {
#line 7445
    if (NL >= 1) {
#line 7445
      if (! (NL <= 4)) {
        {
#line 7446
        opj_event_msg(p_manager___100, 2, "IMF 4K_R profile requires 1 <= NL <= 4 for XTsiz in [1024,2048[:\n-> Number of decomposition levels is %d.\n-> Non-IMF codestream will be generated\n",
                      NL);
#line 7451
        ret___0 = 0;
        }
      }
    } else {
      {
#line 7446
      opj_event_msg(p_manager___100, 2, "IMF 4K_R profile requires 1 <= NL <= 4 for XTsiz in [1024,2048[:\n-> Number of decomposition levels is %d.\n-> Non-IMF codestream will be generated\n",
                    NL);
#line 7451
      ret___0 = 0;
      }
    }
  }
#line 7454
  goto switch_break___0;
  switch_default: 
#line 7457
  goto switch_break___0;
  switch_break___0: ;
#line 7460
  if (parameters___10->numresolution == 1) {
#line 7461
    if (parameters___10->res_spec != 1) {
      {
#line 7464
      opj_event_msg(p_manager___100, 2, "IMF profiles require PPx = PPy = 7 for NLLL band, else 8.\n-> Supplied values are different from that.\n-> Non-IMF codestream will be generated\n",
                    NL);
#line 7469
      ret___0 = 0;
      }
    } else
#line 7461
    if (parameters___10->prcw_init[0] != 128) {
      {
#line 7464
      opj_event_msg(p_manager___100, 2, "IMF profiles require PPx = PPy = 7 for NLLL band, else 8.\n-> Supplied values are different from that.\n-> Non-IMF codestream will be generated\n",
                    NL);
#line 7469
      ret___0 = 0;
      }
    } else
#line 7461
    if (parameters___10->prch_init[0] != 128) {
      {
#line 7464
      opj_event_msg(p_manager___100, 2, "IMF profiles require PPx = PPy = 7 for NLLL band, else 8.\n-> Supplied values are different from that.\n-> Non-IMF codestream will be generated\n",
                    NL);
#line 7469
      ret___0 = 0;
      }
    }
  } else {
#line 7473
    i___60 = 0;
    {
#line 7473
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 7473
      if (! (i___60 < parameters___10->res_spec)) {
#line 7473
        goto while_break___1;
      }
#line 7474
      if (parameters___10->prcw_init[i___60] != 256) {
        {
#line 7476
        opj_event_msg(p_manager___100, 2, "IMF profiles require PPx = PPy = 7 for NLLL band, else 8.\n-> Supplied values are different from that.\n-> Non-IMF codestream will be generated\n",
                      NL);
#line 7481
        ret___0 = 0;
        }
      } else
#line 7474
      if (parameters___10->prch_init[i___60] != 256) {
        {
#line 7476
        opj_event_msg(p_manager___100, 2, "IMF profiles require PPx = PPy = 7 for NLLL band, else 8.\n-> Supplied values are different from that.\n-> Non-IMF codestream will be generated\n",
                      NL);
#line 7481
        ret___0 = 0;
        }
      }
#line 7473
      i___60 ++;
    }
    while_break___4: /* CIL Label */ ;
    }

    while_break___1: ;
  }
#line 7486
  return (ret___0);
}
}
#line 7490 "/root/patron-new/39/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_setup_encoder(opj_j2k_t *p_j2k___58 , opj_cparameters_t *parameters___11 ,
                               opj_image_t *image___9 , opj_event_mgr_t *p_manager___101 ) 
{ 
  OPJ_UINT32 i___61 ;
  OPJ_UINT32 j___5 ;
  OPJ_UINT32 tileno___2 ;
  OPJ_UINT32 numpocs_tile ;
  opj_cp_t *cp___2 ;
  OPJ_UINT32 cblkw ;
  OPJ_UINT32 cblkh ;
  OPJ_INT32 __cil_tmp12___17 ;
  OPJ_INT32 __cil_tmp13___18 ;
  OPJ_BOOL deprecated_used ;
  OPJ_FLOAT32 rate_i_corr ;
  OPJ_FLOAT32 rate_i_m_1_corr ;
  OPJ_FLOAT32 temp_size ;
  double __cil_tmp20___7 ;
  OPJ_FLOAT32 temp_rate ;
  OPJ_BOOL cap ;
  OPJ_BOOL __cil_tmp24___1 ;
  OPJ_BOOL __cil_tmp25___1 ;
  size_t array_size ;
  void *__cil_tmp27___0 ;
  unsigned long __cil_tmp28___1 ;
  void *__cil_tmp29___1 ;
  char comment[29] ;
  size_t clen ;
  unsigned long __cil_tmp32___1 ;
  char const   *version ;
  char const   *__cil_tmp34___1 ;
  unsigned long __cil_tmp35___1 ;
  void *__cil_tmp36___1 ;
  OPJ_INT32 __cil_tmp37 ;
  OPJ_INT32 __cil_tmp38 ;
  void *__cil_tmp39 ;
  opj_tcp_t *tcp___1 ;
  opj_poc_t *tcp_poc ;
  void *__cil_tmp45 ;
  OPJ_UINT32 lMctSize ;
  OPJ_FLOAT32 *lTmpBuf ;
  void *__cil_tmp48 ;
  OPJ_INT32 *l_dc_shift ;
  void *__cil_tmp50 ;
  void *__cil_tmp51 ;
  OPJ_BOOL __cil_tmp52 ;
  void *__cil_tmp53 ;
  opj_tccp_t *tccp ;
  OPJ_BOOL __cil_tmp56 ;
  opj_tccp_t *tccp___0 ;
  opj_image_comp_t *l_comp___1 ;
  opj_tccp_t *tccp___1 ;
  OPJ_INT32 __cil_tmp61 ;
  OPJ_INT32 __cil_tmp62 ;
  int tmp___319 ;
  int tmp___320 ;
  OPJ_INT32 p ;
  OPJ_INT32 it_res ;
  OPJ_INT32 __cil_tmp68 ;
  OPJ_INT32 __cil_tmp69 ;
  OPJ_INT32 res_spec ;
  OPJ_INT32 size_prcw ;
  OPJ_INT32 size_prch ;
  OPJ_INT32 __cil_tmp74 ;
  OPJ_INT32 __cil_tmp75 ;
  OPJ_INT32 __cil_tmp77 ;

  {
#line 7496
  cp___2 = (opj_cp_t *)0;
#line 7499
  if (! p_j2k___58) {
#line 7500
    return (0);
  } else
#line 7499
  if (! parameters___11) {
#line 7500
    return (0);
  } else
#line 7499
  if (! image___9) {
#line 7500
    return (0);
  }
#line 7503
  if (parameters___11->numresolution <= 0) {
    {
#line 7505
    opj_event_msg(p_manager___101, 1, "Invalid number of resolutions : %d not in range [1,%d]\n",
                  parameters___11->numresolution, 33);
    }
#line 7508
    return (0);
  } else
#line 7503
  if (parameters___11->numresolution > 33) {
    {
#line 7505
    opj_event_msg(p_manager___101, 1, "Invalid number of resolutions : %d not in range [1,%d]\n",
                  parameters___11->numresolution, 33);
    }
#line 7508
    return (0);
  }
#line 7511
  if (parameters___11->cblockw_init < 4) {
    {
#line 7512
    opj_event_msg(p_manager___101, 1, "Invalid value for cblockw_init: %d not a power of 2 in range [4,1024]\n",
                  parameters___11->cblockw_init);
    }
#line 7515
    return (0);
  } else
#line 7511
  if (parameters___11->cblockw_init > 1024) {
    {
#line 7512
    opj_event_msg(p_manager___101, 1, "Invalid value for cblockw_init: %d not a power of 2 in range [4,1024]\n",
                  parameters___11->cblockw_init);
    }
#line 7515
    return (0);
  }
#line 7517
  if (parameters___11->cblockh_init < 4) {
    {
#line 7518
    opj_event_msg(p_manager___101, 1, "Invalid value for cblockh_init: %d not a power of 2 not in range [4,1024]\n",
                  parameters___11->cblockh_init);
    }
#line 7521
    return (0);
  } else
#line 7517
  if (parameters___11->cblockh_init > 1024) {
    {
#line 7518
    opj_event_msg(p_manager___101, 1, "Invalid value for cblockh_init: %d not a power of 2 not in range [4,1024]\n",
                  parameters___11->cblockh_init);
    }
#line 7521
    return (0);
  }
#line 7523
  if (parameters___11->cblockw_init * parameters___11->cblockh_init > 4096) {
    {
#line 7524
    opj_event_msg(p_manager___101, 1, "Invalid value for cblockw_init * cblockh_init: should be <= 4096\n");
    }
#line 7526
    return (0);
  }
  {
#line 7528
  __cil_tmp12___17 = opj_int_floorlog2(parameters___11->cblockw_init);
#line 7528
  cblkw = (OPJ_UINT32 )__cil_tmp12___17;
#line 7529
  __cil_tmp13___18 = opj_int_floorlog2(parameters___11->cblockh_init);
#line 7529
  cblkh = (OPJ_UINT32 )__cil_tmp13___18;
  }
#line 7530
  if (parameters___11->cblockw_init != 1 << cblkw) {
    {
#line 7531
    opj_event_msg(p_manager___101, 1, "Invalid value for cblockw_init: %d not a power of 2 in range [4,1024]\n",
                  parameters___11->cblockw_init);
    }
#line 7534
    return (0);
  }
#line 7536
  if (parameters___11->cblockh_init != 1 << cblkh) {
    {
#line 7537
    opj_event_msg(p_manager___101, 1, "Invalid value for cblockw_init: %d not a power of 2 in range [4,1024]\n",
                  parameters___11->cblockh_init);
    }
#line 7540
    return (0);
  }
#line 7544
  cp___2 = & p_j2k___58->m_cp;
#line 7547
  cp___2->tw = (OPJ_UINT32 )1;
#line 7548
  cp___2->th = (OPJ_UINT32 )1;
#line 7551
  if ((int )parameters___11->rsiz == 0) {
#line 7553
    deprecated_used = 0;
#line 7555
    if ((unsigned int )parameters___11->cp_cinema == 1U) {
#line 7555
      goto case_1;
    }
#line 7561
    if ((unsigned int )parameters___11->cp_cinema == 2U) {
#line 7561
      goto case_2;
    }
#line 7567
    if ((unsigned int )parameters___11->cp_cinema == 3U) {
#line 7567
      goto case_3;
    }
#line 7574
    goto switch_default;
    case_1: 
#line 7556
    parameters___11->rsiz = (OPJ_UINT16 )3;
#line 7557
    parameters___11->max_cs_size = 1302083;
#line 7558
    parameters___11->max_comp_size = 1041666;
#line 7559
    deprecated_used = 1;
#line 7560
    goto switch_break;
    case_2: 
#line 7562
    parameters___11->rsiz = (OPJ_UINT16 )3;
#line 7563
    parameters___11->max_cs_size = 651041;
#line 7564
    parameters___11->max_comp_size = 520833;
#line 7565
    deprecated_used = 1;
#line 7566
    goto switch_break;
    case_3: 
#line 7568
    parameters___11->rsiz = (OPJ_UINT16 )4;
#line 7569
    parameters___11->max_cs_size = 1302083;
#line 7570
    parameters___11->max_comp_size = 1041666;
#line 7571
    deprecated_used = 1;
#line 7572
    goto switch_break;
    switch_default: 
#line 7575
    goto switch_break;
    switch_break: ;
#line 7578
    if ((unsigned int )parameters___11->cp_rsiz == 3U) {
#line 7578
      goto case_3___0;
    }
#line 7582
    if ((unsigned int )parameters___11->cp_rsiz == 4U) {
#line 7582
      goto case_4;
    }
#line 7586
    if ((unsigned int )parameters___11->cp_rsiz == 33024U) {
#line 7586
      goto case_33024;
    }
#line 7590
    goto switch_default___0;
    case_3___0: 
#line 7579
    parameters___11->rsiz = (OPJ_UINT16 )3;
#line 7580
    deprecated_used = 1;
#line 7581
    goto switch_break___0;
    case_4: 
#line 7583
    parameters___11->rsiz = (OPJ_UINT16 )4;
#line 7584
    deprecated_used = 1;
#line 7585
    goto switch_break___0;
    case_33024: 
#line 7587
    parameters___11->rsiz = (OPJ_UINT16 )33024;
#line 7588
    deprecated_used = 1;
    switch_default___0: 
#line 7591
    goto switch_break___0;
    switch_break___0: ;
#line 7593
    if (deprecated_used) {
      {
#line 7594
      opj_event_msg(p_manager___101, 2, "Deprecated fields cp_cinema or cp_rsiz are used\nPlease consider using only the rsiz field\nSee openjpeg.h documentation for more details\n\220");
      }
    }
  }
#line 7602
  if (parameters___11->tcp_numlayers == 0) {
#line 7603
    parameters___11->tcp_numlayers = 1;
#line 7604
    parameters___11->cp_disto_alloc = 1;
#line 7605
    parameters___11->tcp_rates[0] = (float )0;
  }
#line 7608
  if (parameters___11->cp_disto_alloc) {
#line 7610
    i___61 = (OPJ_UINT32 )1;
    {
#line 7610
    while (1) {
      while_continue: /* CIL Label */ ;

#line 7610
      if (! (i___61 < (OPJ_UINT32 )parameters___11->tcp_numlayers)) {
#line 7610
        goto while_break;
      }
#line 7611
      rate_i_corr = parameters___11->tcp_rates[i___61];
#line 7612
      rate_i_m_1_corr = parameters___11->tcp_rates[i___61 - 1U];
#line 7613
      if ((double )rate_i_corr <= 1.) {
#line 7614
        rate_i_corr = (OPJ_FLOAT32 )1.;
      }
#line 7616
      if ((double )rate_i_m_1_corr <= 1.) {
#line 7617
        rate_i_m_1_corr = (OPJ_FLOAT32 )1.;
      }
#line 7619
      if (rate_i_corr >= rate_i_m_1_corr) {
#line 7620
        if (rate_i_corr != parameters___11->tcp_rates[i___61]) {
#line 7620
          if (rate_i_m_1_corr != parameters___11->tcp_rates[i___61 - 1U]) {
            {
#line 7622
            opj_event_msg(p_manager___101, 2, "tcp_rates[%d]=%f (corrected as %f) should be strictly lesser than tcp_rates[%d]=%f (corrected as %f)\n",
                          i___61, (double )parameters___11->tcp_rates[i___61], (double )rate_i_corr,
                          i___61 - 1U, (double )parameters___11->tcp_rates[i___61 - 1U],
                          (double )rate_i_m_1_corr);
            }
          } else {
#line 7620
            goto _L;
          }
        } else
        _L: 
#line 7627
        if (rate_i_corr != parameters___11->tcp_rates[i___61]) {
          {
#line 7628
          opj_event_msg(p_manager___101, 2, "tcp_rates[%d]=%f (corrected as %f) should be strictly lesser than tcp_rates[%d]=%f\n",
                        i___61, (double )parameters___11->tcp_rates[i___61], (double )rate_i_corr,
                        i___61 - 1U, (double )parameters___11->tcp_rates[i___61 - 1U]);
          }
        } else
#line 7633
        if (rate_i_m_1_corr != parameters___11->tcp_rates[i___61 - 1U]) {
          {
#line 7634
          opj_event_msg(p_manager___101, 2, "tcp_rates[%d]=%f should be strictly lesser than tcp_rates[%d]=%f (corrected as %f)\n",
                        i___61, (double )parameters___11->tcp_rates[i___61], i___61 - 1U,
                        (double )parameters___11->tcp_rates[i___61 - 1U], (double )rate_i_m_1_corr);
          }
        } else {
          {
#line 7640
          opj_event_msg(p_manager___101, 2, "tcp_rates[%d]=%f should be strictly lesser than tcp_rates[%d]=%f\n",
                        i___61, (double )parameters___11->tcp_rates[i___61], i___61 - 1U,
                        (double )parameters___11->tcp_rates[i___61 - 1U]);
          }
        }
      }
#line 7610
      i___61 ++;
    }
    while_break___10: /* CIL Label */ ;
    }

    while_break: ;
  } else
#line 7648
  if (parameters___11->cp_fixed_quality) {
#line 7650
    i___61 = (OPJ_UINT32 )1;
    {
#line 7650
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 7650
      if (! (i___61 < (OPJ_UINT32 )parameters___11->tcp_numlayers)) {
#line 7650
        goto while_break___0;
      }
#line 7651
      if (parameters___11->tcp_distoratio[i___61] < parameters___11->tcp_distoratio[i___61 - 1U]) {
#line 7651
        if (i___61 == (OPJ_UINT32 )parameters___11->tcp_numlayers - 1U) {
#line 7651
          if (! (parameters___11->tcp_distoratio[i___61] == (float )0)) {
            {
#line 7654
            opj_event_msg(p_manager___101, 2, "tcp_distoratio[%d]=%f should be strictly greater than tcp_distoratio[%d]=%f\n\230\001",
                          i___61, (double )parameters___11->tcp_distoratio[i___61],
                          i___61 - 1U, (double )parameters___11->tcp_distoratio[i___61 - 1U]);
            }
          }
        } else {
          {
#line 7654
          opj_event_msg(p_manager___101, 2, "tcp_distoratio[%d]=%f should be strictly greater than tcp_distoratio[%d]=%f\n\230\001",
                        i___61, (double )parameters___11->tcp_distoratio[i___61],
                        i___61 - 1U, (double )parameters___11->tcp_distoratio[i___61 - 1U]);
          }
        }
      }
#line 7650
      i___61 ++;
    }
    while_break___11: /* CIL Label */ ;
    }

    while_break___0: ;
  }
#line 7664
  if (parameters___11->max_cs_size <= 0) {
#line 7665
    if (parameters___11->tcp_rates[parameters___11->tcp_numlayers - 1] > (float )0) {
#line 7667
      temp_size = (OPJ_FLOAT32 )(((((double )image___9->numcomps * (double )(image___9->comps + 0)->w) * (double )(image___9->comps + 0)->h) * (double )(image___9->comps + 0)->prec) / ((((double )parameters___11->tcp_rates[parameters___11->tcp_numlayers - 1] * (double )8) * (double )(image___9->comps + 0)->dx) * (double )(image___9->comps + 0)->dy));
#line 7671
      if (temp_size > (float )2147483647) {
#line 7672
        parameters___11->max_cs_size = 2147483647;
      } else {
        {
#line 7674
        __cil_tmp20___7 = floor((double )temp_size);
#line 7674
        parameters___11->max_cs_size = (int )__cil_tmp20___7;
        }
      }
    } else {
#line 7677
      parameters___11->max_cs_size = 0;
    }
  } else {
#line 7681
    cap = 0;
#line 7683
    if ((int )parameters___11->rsiz >= 1024) {
#line 7683
      if ((int )parameters___11->rsiz <= 2459) {
#line 7683
        if (parameters___11->max_cs_size > 0) {
#line 7683
          if (parameters___11->tcp_numlayers == 1) {
#line 7683
            if (parameters___11->tcp_rates[0] == (float )0) {
#line 7685
              parameters___11->tcp_rates[0] = (OPJ_FLOAT32 )(((image___9->numcomps * (image___9->comps + 0)->w) * (image___9->comps + 0)->h) * (image___9->comps + 0)->prec) / (OPJ_FLOAT32 )((((OPJ_UINT32 )parameters___11->max_cs_size * 8U) * (image___9->comps + 0)->dx) * (image___9->comps + 0)->dy);
            }
          }
        }
      }
    }
#line 7691
    temp_rate = (OPJ_FLOAT32 )(((((double )image___9->numcomps * (double )(image___9->comps + 0)->w) * (double )(image___9->comps + 0)->h) * (double )(image___9->comps + 0)->prec) / ((((double )parameters___11->max_cs_size * (double )8) * (double )(image___9->comps + 0)->dx) * (double )(image___9->comps + 0)->dy));
#line 7695
    i___61 = (OPJ_UINT32 )0;
    {
#line 7695
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 7695
      if (! (i___61 < (OPJ_UINT32 )parameters___11->tcp_numlayers)) {
#line 7695
        goto while_break___1;
      }
#line 7696
      if (parameters___11->tcp_rates[i___61] < temp_rate) {
#line 7697
        parameters___11->tcp_rates[i___61] = temp_rate;
#line 7698
        cap = 1;
      }
#line 7695
      i___61 ++;
    }
    while_break___12: /* CIL Label */ ;
    }

    while_break___1: ;
#line 7701
    if (cap) {
      {
#line 7702
      opj_event_msg(p_manager___101, 2, "The desired maximum codestream size has limited\nat least one of the desired quality layers\n");
      }
    }
  }
#line 7710
  if ((int )parameters___11->rsiz >= 3) {
#line 7710
    if ((int )parameters___11->rsiz <= 6) {
#line 7711
      if ((int )parameters___11->rsiz == 5) {
        {
#line 7713
        opj_event_msg(p_manager___101, 2, "JPEG 2000 Scalable Digital Cinema profiles not yet supported\n");
#line 7715
        parameters___11->rsiz = (OPJ_UINT16 )0;
        }
      } else
#line 7711
      if ((int )parameters___11->rsiz == 6) {
        {
#line 7713
        opj_event_msg(p_manager___101, 2, "JPEG 2000 Scalable Digital Cinema profiles not yet supported\n");
#line 7715
        parameters___11->rsiz = (OPJ_UINT16 )0;
        }
      } else {
        {
#line 7717
        opj_j2k_set_cinema_parameters(parameters___11, image___9, p_manager___101);
#line 7718
        __cil_tmp24___1 = opj_j2k_is_cinema_compliant(image___9, parameters___11->rsiz,
                                                      p_manager___101);
        }
#line 7718
        if (! __cil_tmp24___1) {
#line 7719
          parameters___11->rsiz = (OPJ_UINT16 )0;
        }
      }
    } else {
#line 7710
      goto _L___24;
    }
  } else
  _L___24: 
#line 7722
  if ((int )parameters___11->rsiz == 7) {
    {
#line 7723
    opj_event_msg(p_manager___101, 2, "JPEG 2000 Long Term Storage profile not yet supported\n");
#line 7725
    parameters___11->rsiz = (OPJ_UINT16 )0;
    }
  } else
#line 7726
  if ((int )parameters___11->rsiz >= 256) {
#line 7726
    if ((int )parameters___11->rsiz <= 779) {
      {
#line 7727
      opj_event_msg(p_manager___101, 2, "JPEG 2000 Broadcast profiles not yet supported\n");
#line 7729
      parameters___11->rsiz = (OPJ_UINT16 )0;
      }
    } else {
#line 7726
      goto _L___23;
    }
  } else
  _L___23: 
#line 7730
  if ((int )parameters___11->rsiz >= 1024) {
#line 7730
    if ((int )parameters___11->rsiz <= 2459) {
      {
#line 7731
      opj_j2k_set_imf_parameters(parameters___11, image___9, p_manager___101);
#line 7732
      __cil_tmp25___1 = opj_j2k_is_imf_compliant(parameters___11, image___9, p_manager___101);
      }
#line 7732
      if (! __cil_tmp25___1) {
#line 7733
        parameters___11->rsiz = (OPJ_UINT16 )0;
      }
    } else {
#line 7730
      goto _L___22;
    }
  } else
  _L___22: 
#line 7735
  if ((int )parameters___11->rsiz & 32768) {
#line 7736
    if ((int )parameters___11->rsiz == 32768) {
      {
#line 7737
      opj_event_msg(p_manager___101, 2, "JPEG 2000 Part-2 profile defined\nbut no Part-2 extension enabled.\nProfile set to NONE.\n");
#line 7741
      parameters___11->rsiz = (OPJ_UINT16 )0;
      }
    } else
#line 7742
    if ((int )parameters___11->rsiz != 33024) {
      {
#line 7743
      opj_event_msg(p_manager___101, 2, "Unsupported Part-2 extension enabled\nProfile set to NONE.\n");
#line 7746
      parameters___11->rsiz = (OPJ_UINT16 )0;
      }
    }
  }
#line 7753
  cp___2->m_specific_param.m_enc.m_max_comp_size = (OPJ_UINT32 )parameters___11->max_comp_size;
#line 7755
  cp___2->rsiz = parameters___11->rsiz;
#line 7756
  cp___2->m_specific_param.m_enc.m_disto_alloc = (OPJ_UINT32 )parameters___11->cp_disto_alloc & 1U;
#line 7758
  cp___2->m_specific_param.m_enc.m_fixed_alloc = (OPJ_UINT32 )parameters___11->cp_fixed_alloc & 1U;
#line 7760
  cp___2->m_specific_param.m_enc.m_fixed_quality = (OPJ_UINT32 )parameters___11->cp_fixed_quality & 1U;
#line 7764
  if (parameters___11->cp_matrice) {
#line 7764
    if (parameters___11->cp_fixed_alloc) {
      {
#line 7765
      array_size = (((size_t )parameters___11->tcp_numlayers * (size_t )parameters___11->numresolution) * 3UL) * sizeof(OPJ_INT32 );
#line 7767
      __cil_tmp27___0 = opj_malloc(array_size);
#line 7767
      cp___2->m_specific_param.m_enc.m_matrice = (OPJ_INT32 *)__cil_tmp27___0;
      }
#line 7768
      if (! cp___2->m_specific_param.m_enc.m_matrice) {
        {
#line 7769
        opj_event_msg(p_manager___101, 1, "Not enough memory to allocate copy of user encoding parameters matrix \n");
        }
#line 7771
        return (0);
      }
      {
#line 7773
      memcpy((void *)cp___2->m_specific_param.m_enc.m_matrice, (void const   *)parameters___11->cp_matrice,
             array_size);
      }
    }
  }
#line 7778
  cp___2->tdx = (OPJ_UINT32 )parameters___11->cp_tdx;
#line 7779
  cp___2->tdy = (OPJ_UINT32 )parameters___11->cp_tdy;
#line 7782
  cp___2->tx0 = (OPJ_UINT32 )parameters___11->cp_tx0;
#line 7783
  cp___2->ty0 = (OPJ_UINT32 )parameters___11->cp_ty0;
#line 7786
  if (parameters___11->cp_comment) {
    {
#line 7787
    __cil_tmp28___1 = strlen((char const   *)parameters___11->cp_comment);
#line 7787
    __cil_tmp29___1 = opj_malloc(__cil_tmp28___1 + 1UL);
#line 7787
    cp___2->comment = (char *)__cil_tmp29___1;
    }
#line 7788
    if (! cp___2->comment) {
      {
#line 7789
      opj_event_msg(p_manager___101, 1, "Not enough memory to allocate copy of comment string\n");
      }
#line 7791
      return (0);
    }
    {
#line 7793
    strcpy(cp___2->comment, (char const   *)parameters___11->cp_comment);
    }
  } else {
    {
#line 7796
    __asm__  ("booo_exp(/root/patron-new/39/src/lib/openjp2/j2k.c:7796)":);
#line 7797
    __cil_tmp32___1 = strlen((char const   *)(comment));
#line 7797
    clen = __cil_tmp32___1;
#line 7798
    __cil_tmp34___1 = opj_version();
#line 7798
    version = __cil_tmp34___1;
#line 7810
    __cil_tmp35___1 = strlen(version);
#line 7810
    __cil_tmp36___1 = opj_malloc((clen + __cil_tmp35___1) + 1UL);
#line 7810
    cp___2->comment = (char *)__cil_tmp36___1;
    }
#line 7811
    if (! cp___2->comment) {
      {
#line 7812
      opj_event_msg(p_manager___101, 1, "Not enough memory to allocate comment string\n");
      }
#line 7814
      return (0);
    }
    {
#line 7816
    sprintf(cp___2->comment, "%s%s", (char const   *)(comment), version);
    }
  }
#line 7825
  if (parameters___11->tile_size_on) {
#line 7826
    if (cp___2->tdx == 0U) {
      {
#line 7827
      opj_event_msg(p_manager___101, 1, "Invalid tile width\n\005]U");
      }
#line 7828
      return (0);
    }
#line 7834
    __cil_tmp37 = (OPJ_INT32 )((((image___9->x1 - cp___2->tx0) + cp___2->tdx) - 1U) / cp___2->tdx);
#line 7834
    cp___2->tw = (OPJ_UINT32 )__cil_tmp37;
#line 7836
    __cil_tmp38 = (OPJ_INT32 )((((image___9->y1 - cp___2->ty0) + cp___2->tdy) - 1U) / cp___2->tdy);
#line 7836
    cp___2->th = (OPJ_UINT32 )__cil_tmp38;
  } else {
#line 7839
    cp___2->tdx = image___9->x1 - cp___2->tx0;
#line 7840
    cp___2->tdy = image___9->y1 - cp___2->ty0;
  }
#line 7843
  if (parameters___11->tp_on) {
#line 7844
    cp___2->m_specific_param.m_enc.m_tp_flag = (OPJ_BYTE )parameters___11->tp_flag;
#line 7845
    cp___2->m_specific_param.m_enc.m_tp_on = (OPJ_BITFIELD )1;
  }
  {
#line 7906
  __cil_tmp39 = opj_calloc((size_t )(cp___2->tw * cp___2->th), sizeof(opj_tcp_t ));
#line 7906
  cp___2->tcps = (opj_tcp_t *)__cil_tmp39;
  }
#line 7907
  if (! cp___2->tcps) {
    {
#line 7908
    opj_event_msg(p_manager___101, 1, "Not enough memory to allocate tile coding parameters\nU");
    }
#line 7910
    return (0);
  }
#line 7913
  tileno___2 = (OPJ_UINT32 )0;
  {
#line 7913
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 7913
    if (! (tileno___2 < cp___2->tw * cp___2->th)) {
#line 7913
      goto while_break___2;
    }
#line 7914
    tcp___1 = cp___2->tcps + tileno___2;
#line 7915
    tcp___1->numlayers = (OPJ_UINT32 )parameters___11->tcp_numlayers;
#line 7917
    j___5 = (OPJ_UINT32 )0;
    {
#line 7917
    while (1) {
      while_continue___3: /* CIL Label */ ;

#line 7917
      if (! (j___5 < tcp___1->numlayers)) {
#line 7917
        goto while_break___3;
      }
#line 7918
      if ((int )cp___2->rsiz >= 3) {
#line 7918
        if ((int )cp___2->rsiz <= 6) {
          _L___25: 
#line 7919
          if (cp___2->m_specific_param.m_enc.m_fixed_quality) {
#line 7920
            tcp___1->distoratio[j___5] = parameters___11->tcp_distoratio[j___5];
          }
#line 7922
          tcp___1->rates[j___5] = parameters___11->tcp_rates[j___5];
        } else {
#line 7918
          goto _L___27;
        }
      } else
      _L___27: 
#line 7918
      if ((int )cp___2->rsiz >= 1024) {
#line 7918
        if ((int )cp___2->rsiz <= 2459) {
#line 7918
          goto _L___25;
        } else {
#line 7918
          goto _L___26;
        }
      } else
      _L___26: 
#line 7924
      if (cp___2->m_specific_param.m_enc.m_fixed_quality) {
#line 7925
        tcp___1->distoratio[j___5] = parameters___11->tcp_distoratio[j___5];
      } else {
#line 7927
        tcp___1->rates[j___5] = parameters___11->tcp_rates[j___5];
      }
#line 7930
      if (! cp___2->m_specific_param.m_enc.m_fixed_quality) {
#line 7930
        if ((double )tcp___1->rates[j___5] <= 1.) {
#line 7932
          tcp___1->rates[j___5] = (OPJ_FLOAT32 )0.;
        }
      }
#line 7917
      j___5 ++;
    }
    while_break___14: /* CIL Label */ ;
    }

    while_break___3: 
#line 7936
    tcp___1->csty = (OPJ_UINT32 )parameters___11->csty;
#line 7937
    tcp___1->prg = parameters___11->prog_order;
#line 7938
    tcp___1->mct = (OPJ_UINT32 )parameters___11->tcp_mct;
#line 7940
    numpocs_tile = (OPJ_UINT32 )0;
#line 7941
    tcp___1->POC = (OPJ_BITFIELD )0;
#line 7943
    if (parameters___11->numpocs) {
#line 7945
      i___61 = (OPJ_UINT32 )0;
      {
#line 7945
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 7945
        if (! (i___61 < parameters___11->numpocs)) {
#line 7945
          goto while_break___4;
        }
#line 7946
        if (tileno___2 + 1U == parameters___11->POC[i___61].tile) {
#line 7947
          tcp_poc = & tcp___1->pocs[numpocs_tile];
#line 7949
          tcp_poc->resno0 = parameters___11->POC[numpocs_tile].resno0;
#line 7950
          tcp_poc->compno0 = parameters___11->POC[numpocs_tile].compno0;
#line 7951
          tcp_poc->layno1 = parameters___11->POC[numpocs_tile].layno1;
#line 7952
          tcp_poc->resno1 = parameters___11->POC[numpocs_tile].resno1;
#line 7953
          tcp_poc->compno1 = parameters___11->POC[numpocs_tile].compno1;
#line 7954
          tcp_poc->prg1 = parameters___11->POC[numpocs_tile].prg1;
#line 7955
          tcp_poc->tile = parameters___11->POC[numpocs_tile].tile;
#line 7957
          numpocs_tile ++;
        }
#line 7945
        i___61 ++;
      }
      while_break___15: /* CIL Label */ ;
      }

      while_break___4: ;
#line 7961
      if (numpocs_tile) {
        {
#line 7964
        opj_j2k_check_poc_val(parameters___11->POC, tileno___2, parameters___11->numpocs,
                              (OPJ_UINT32 )parameters___11->numresolution, image___9->numcomps,
                              (OPJ_UINT32 )parameters___11->tcp_numlayers, p_manager___101);
#line 7968
        tcp___1->POC = (OPJ_BITFIELD )1;
#line 7969
        tcp___1->numpocs = numpocs_tile - 1U;
        }
      }
    } else {
#line 7972
      tcp___1->numpocs = (OPJ_UINT32 )0;
    }
    {
#line 7975
    __cil_tmp45 = opj_calloc((size_t )image___9->numcomps, sizeof(opj_tccp_t ));
#line 7975
    tcp___1->tccps = (opj_tccp_t *)__cil_tmp45;
    }
#line 7976
    if (! tcp___1->tccps) {
      {
#line 7977
      opj_event_msg(p_manager___101, 1, "Not enough memory to allocate tile component coding parameters\n");
      }
#line 7979
      return (0);
    }
#line 7981
    if (parameters___11->mct_data) {
      {
#line 7983
      lMctSize = (image___9->numcomps * image___9->numcomps) * (OPJ_UINT32 )sizeof(OPJ_FLOAT32 );
#line 7985
      __cil_tmp48 = opj_malloc((size_t )lMctSize);
#line 7985
      lTmpBuf = (OPJ_FLOAT32 *)__cil_tmp48;
#line 7986
      l_dc_shift = (OPJ_INT32 *)((OPJ_BYTE *)parameters___11->mct_data + lMctSize);
      }
#line 7989
      if (! lTmpBuf) {
        {
#line 7990
        opj_event_msg(p_manager___101, 1, "Not enough memory to allocate temp buffer\n");
        }
#line 7992
        return (0);
      }
      {
#line 7995
      tcp___1->mct = (OPJ_UINT32 )2;
#line 7996
      __cil_tmp50 = opj_malloc((size_t )lMctSize);
#line 7996
      tcp___1->m_mct_coding_matrix = (OPJ_FLOAT32 *)__cil_tmp50;
      }
#line 7997
      if (! tcp___1->m_mct_coding_matrix) {
        {
#line 7998
        opj_free((void *)lTmpBuf);
#line 7999
        lTmpBuf = (OPJ_FLOAT32 *)((void *)0);
#line 8000
        opj_event_msg(p_manager___101, 1, "Not enough memory to allocate encoder MCT coding matrix \n");
        }
#line 8002
        return (0);
      }
      {
#line 8004
      memcpy((void *)tcp___1->m_mct_coding_matrix, (void const   *)parameters___11->mct_data,
             (unsigned long )lMctSize);
#line 8005
      memcpy((void *)lTmpBuf, (void const   *)parameters___11->mct_data, (unsigned long )lMctSize);
#line 8007
      __cil_tmp51 = opj_malloc((size_t )lMctSize);
#line 8007
      tcp___1->m_mct_decoding_matrix = (OPJ_FLOAT32 *)__cil_tmp51;
      }
#line 8008
      if (! tcp___1->m_mct_decoding_matrix) {
        {
#line 8009
        opj_free((void *)lTmpBuf);
#line 8010
        lTmpBuf = (OPJ_FLOAT32 *)((void *)0);
#line 8011
        opj_event_msg(p_manager___101, 1, "Not enough memory to allocate encoder MCT decoding matrix \n");
        }
#line 8013
        return (0);
      }
      {
#line 8015
      __cil_tmp52 = opj_matrix_inversion_f(lTmpBuf, tcp___1->m_mct_decoding_matrix,
                                           image___9->numcomps);
      }
#line 8015
      if (__cil_tmp52 == 0) {
        {
#line 8017
        opj_free((void *)lTmpBuf);
#line 8018
        lTmpBuf = (OPJ_FLOAT32 *)((void *)0);
#line 8019
        opj_event_msg(p_manager___101, 1, "Failed to inverse encoder MCT decoding matrix \n");
        }
#line 8021
        return (0);
      }
      {
#line 8024
      __cil_tmp53 = opj_malloc((unsigned long )image___9->numcomps * sizeof(OPJ_FLOAT64 ));
#line 8024
      tcp___1->mct_norms = (OPJ_FLOAT64 *)__cil_tmp53;
      }
#line 8026
      if (! tcp___1->mct_norms) {
        {
#line 8027
        opj_free((void *)lTmpBuf);
#line 8028
        lTmpBuf = (OPJ_FLOAT32 *)((void *)0);
#line 8029
        opj_event_msg(p_manager___101, 1, "Not enough memory to allocate encoder MCT norms \n");
        }
#line 8031
        return (0);
      }
      {
#line 8033
      opj_calculate_norms(tcp___1->mct_norms, image___9->numcomps, tcp___1->m_mct_decoding_matrix);
#line 8035
      opj_free((void *)lTmpBuf);
#line 8037
      i___61 = (OPJ_UINT32 )0;
      }
      {
#line 8037
      while (1) {
        while_continue___5: /* CIL Label */ ;

#line 8037
        if (! (i___61 < image___9->numcomps)) {
#line 8037
          goto while_break___5;
        }
#line 8038
        tccp = tcp___1->tccps + i___61;
#line 8039
        tccp->m_dc_level_shift = *(l_dc_shift + i___61);
#line 8037
        i___61 ++;
      }
      while_break___16: /* CIL Label */ ;
      }

      while_break___5: 
      {
#line 8042
      __cil_tmp56 = opj_j2k_setup_mct_encoding(tcp___1, image___9);
      }
#line 8042
      if (__cil_tmp56 == 0) {
        {
#line 8044
        opj_event_msg(p_manager___101, 1, "Failed to setup j2k mct encoding\n");
        }
#line 8045
        return (0);
      }
    } else {
#line 8048
      if (tcp___1->mct == 1U) {
#line 8048
        if (image___9->numcomps >= 3U) {
#line 8049
          if ((image___9->comps + 0)->dx != (image___9->comps + 1)->dx) {
            {
#line 8053
            opj_event_msg(p_manager___101, 2, "Cannot perform MCT on components with different sizes. Disabling MCT.\n");
#line 8055
            tcp___1->mct = (OPJ_UINT32 )0;
            }
          } else
#line 8049
          if ((image___9->comps + 0)->dx != (image___9->comps + 2)->dx) {
            {
#line 8053
            opj_event_msg(p_manager___101, 2, "Cannot perform MCT on components with different sizes. Disabling MCT.\n");
#line 8055
            tcp___1->mct = (OPJ_UINT32 )0;
            }
          } else
#line 8049
          if ((image___9->comps + 0)->dy != (image___9->comps + 1)->dy) {
            {
#line 8053
            opj_event_msg(p_manager___101, 2, "Cannot perform MCT on components with different sizes. Disabling MCT.\n");
#line 8055
            tcp___1->mct = (OPJ_UINT32 )0;
            }
          } else
#line 8049
          if ((image___9->comps + 0)->dy != (image___9->comps + 2)->dy) {
            {
#line 8053
            opj_event_msg(p_manager___101, 2, "Cannot perform MCT on components with different sizes. Disabling MCT.\n");
#line 8055
            tcp___1->mct = (OPJ_UINT32 )0;
            }
          }
        }
      }
#line 8058
      i___61 = (OPJ_UINT32 )0;
      {
#line 8058
      while (1) {
        while_continue___6: /* CIL Label */ ;

#line 8058
        if (! (i___61 < image___9->numcomps)) {
#line 8058
          goto while_break___6;
        }
#line 8059
        tccp___0 = tcp___1->tccps + i___61;
#line 8060
        l_comp___1 = image___9->comps + i___61;
#line 8062
        if (! l_comp___1->sgnd) {
#line 8063
          tccp___0->m_dc_level_shift = 1 << (l_comp___1->prec - 1U);
        }
#line 8058
        i___61 ++;
      }
      while_break___17: /* CIL Label */ ;
      }

      while_break___6: ;
    }
#line 8068
    i___61 = (OPJ_UINT32 )0;
    {
#line 8068
    while (1) {
      while_continue___7: /* CIL Label */ ;

#line 8068
      if (! (i___61 < image___9->numcomps)) {
#line 8068
        goto while_break___7;
      }
      {
#line 8069
      tccp___1 = tcp___1->tccps + i___61;
#line 8071
      tccp___1->csty = (OPJ_UINT32 )(parameters___11->csty & 1);
#line 8073
      tccp___1->numresolutions = (OPJ_UINT32 )parameters___11->numresolution;
#line 8074
      __cil_tmp61 = opj_int_floorlog2(parameters___11->cblockw_init);
#line 8074
      tccp___1->cblkw = (OPJ_UINT32 )__cil_tmp61;
#line 8075
      __cil_tmp62 = opj_int_floorlog2(parameters___11->cblockh_init);
#line 8075
      tccp___1->cblkh = (OPJ_UINT32 )__cil_tmp62;
#line 8076
      tccp___1->cblksty = (OPJ_UINT32 )parameters___11->mode;
      }
#line 8077
      if (parameters___11->irreversible) {
#line 8077
        tmp___319 = 0;
      } else {
#line 8077
        tmp___319 = 1;
      }
#line 8077
      tccp___1->qmfbid = (OPJ_UINT32 )tmp___319;
#line 8078
      if (parameters___11->irreversible) {
#line 8078
        tmp___320 = 2;
      } else {
#line 8078
        tmp___320 = 0;
      }
#line 8078
      tccp___1->qntsty = (OPJ_UINT32 )tmp___320;
#line 8080
      tccp___1->numgbits = (OPJ_UINT32 )2;
#line 8082
      if ((OPJ_INT32 )i___61 == parameters___11->roi_compno) {
#line 8083
        tccp___1->roishift = parameters___11->roi_shift;
      } else {
#line 8085
        tccp___1->roishift = 0;
      }
#line 8088
      if (parameters___11->csty & 1) {
#line 8089
        p = 0;
#line 8091
        it_res = (OPJ_INT32 )tccp___1->numresolutions - 1;
        {
#line 8091
        while (1) {
          while_continue___8: /* CIL Label */ ;

#line 8091
          if (! (it_res >= 0)) {
#line 8091
            goto while_break___8;
          }
#line 8092
          if (p < parameters___11->res_spec) {
#line 8094
            if (parameters___11->prcw_init[p] < 1) {
#line 8095
              tccp___1->prcw[it_res] = (OPJ_UINT32 )1;
            } else {
              {
#line 8097
              __cil_tmp68 = opj_int_floorlog2(parameters___11->prcw_init[p]);
#line 8097
              tccp___1->prcw[it_res] = (OPJ_UINT32 )__cil_tmp68;
              }
            }
#line 8100
            if (parameters___11->prch_init[p] < 1) {
#line 8101
              tccp___1->prch[it_res] = (OPJ_UINT32 )1;
            } else {
              {
#line 8103
              __cil_tmp69 = opj_int_floorlog2(parameters___11->prch_init[p]);
#line 8103
              tccp___1->prch[it_res] = (OPJ_UINT32 )__cil_tmp69;
              }
            }
          } else {
#line 8107
            res_spec = parameters___11->res_spec;
#line 8108
            size_prcw = 0;
#line 8109
            size_prch = 0;
#line 8112
            size_prcw = parameters___11->prcw_init[res_spec - 1] >> (p - (res_spec - 1));
#line 8113
            size_prch = parameters___11->prch_init[res_spec - 1] >> (p - (res_spec - 1));
#line 8116
            if (size_prcw < 1) {
#line 8117
              tccp___1->prcw[it_res] = (OPJ_UINT32 )1;
            } else {
              {
#line 8119
              __cil_tmp74 = opj_int_floorlog2(size_prcw);
#line 8119
              tccp___1->prcw[it_res] = (OPJ_UINT32 )__cil_tmp74;
              }
            }
#line 8122
            if (size_prch < 1) {
#line 8123
              tccp___1->prch[it_res] = (OPJ_UINT32 )1;
            } else {
              {
#line 8125
              __cil_tmp75 = opj_int_floorlog2(size_prch);
#line 8125
              tccp___1->prch[it_res] = (OPJ_UINT32 )__cil_tmp75;
              }
            }
          }
#line 8128
          p ++;
#line 8091
          __cil_tmp77 = it_res;
#line 8091
          it_res --;
        }
        while_break___19: /* CIL Label */ ;
        }

        while_break___8: ;
      } else {
#line 8132
        j___5 = (OPJ_UINT32 )0;
        {
#line 8132
        while (1) {
          while_continue___9: /* CIL Label */ ;

#line 8132
          if (! (j___5 < tccp___1->numresolutions)) {
#line 8132
            goto while_break___9;
          }
#line 8133
          tccp___1->prcw[j___5] = (OPJ_UINT32 )15;
#line 8134
          tccp___1->prch[j___5] = (OPJ_UINT32 )15;
#line 8132
          j___5 ++;
        }
        while_break___20: /* CIL Label */ ;
        }

        while_break___9: ;
      }
      {
#line 8138
      opj_dwt_calc_explicit_stepsizes(tccp___1, (image___9->comps + i___61)->prec);
#line 8068
      i___61 ++;
      }
    }
    while_break___18: /* CIL Label */ ;
    }

    while_break___7: 
#line 7913
    tileno___2 ++;
  }
  while_break___13: /* CIL Label */ ;
  }

  while_break___2: ;
#line 8142
  if (parameters___11->mct_data) {
    {
#line 8143
    opj_free(parameters___11->mct_data);
#line 8144
    parameters___11->mct_data = (void *)0;
    }
  }
#line 8146
  return (1);
}
}
#line 8149 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_add_mhmarker(opj_codestream_index_t *cstr_index , OPJ_UINT32 type ,
                                     OPJ_OFF_T pos , OPJ_UINT32 len___2 ) 
{ 
  opj_marker_info_t *new_marker ;
  void *__cil_tmp7___24 ;

  {
#line 8155
  if (cstr_index->marknum + 1U > cstr_index->maxmarknum) {
    {
#line 8157
    cstr_index->maxmarknum = (OPJ_UINT32 )((float )100 + (OPJ_FLOAT32 )cstr_index->maxmarknum);
#line 8159
    __cil_tmp7___24 = opj_realloc((void *)cstr_index->marker, (unsigned long )cstr_index->maxmarknum * sizeof(opj_marker_info_t ));
#line 8159
    new_marker = (opj_marker_info_t *)__cil_tmp7___24;
    }
#line 8161
    if (! new_marker) {
      {
#line 8162
      opj_free((void *)cstr_index->marker);
#line 8163
      cstr_index->marker = (opj_marker_info_t *)((void *)0);
#line 8164
      cstr_index->maxmarknum = (OPJ_UINT32 )0;
#line 8165
      cstr_index->marknum = (OPJ_UINT32 )0;
      }
#line 8167
      return (0);
    }
#line 8169
    cstr_index->marker = new_marker;
  }
#line 8173
  (cstr_index->marker + cstr_index->marknum)->type = (OPJ_UINT16 )type;
#line 8174
  (cstr_index->marker + cstr_index->marknum)->pos = (OPJ_OFF_T )((OPJ_INT32 )pos);
#line 8175
  (cstr_index->marker + cstr_index->marknum)->len = (OPJ_INT32 )len___2;
#line 8176
  (cstr_index->marknum) ++;
#line 8177
  return (1);
}
}
#line 8180 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_add_tlmarker(OPJ_UINT32 tileno___3 , opj_codestream_index_t *cstr_index___0 ,
                                     OPJ_UINT32 type___0 , OPJ_OFF_T pos___0 , OPJ_UINT32 len___3 ) 
{ 
  opj_marker_info_t *new_marker___0 ;
  void *__cil_tmp9___16 ;
  OPJ_UINT32 l_current_tile_part___0 ;

  {
#line 8188
  if ((cstr_index___0->tile_index + tileno___3)->marknum + 1U > (cstr_index___0->tile_index + tileno___3)->maxmarknum) {
    {
#line 8191
    (cstr_index___0->tile_index + tileno___3)->maxmarknum = (OPJ_UINT32 )((float )100 + (OPJ_FLOAT32 )(cstr_index___0->tile_index + tileno___3)->maxmarknum);
#line 8193
    __cil_tmp9___16 = opj_realloc((void *)(cstr_index___0->tile_index + tileno___3)->marker,
                                  (unsigned long )(cstr_index___0->tile_index + tileno___3)->maxmarknum * sizeof(opj_marker_info_t ));
#line 8193
    new_marker___0 = (opj_marker_info_t *)__cil_tmp9___16;
    }
#line 8196
    if (! new_marker___0) {
      {
#line 8197
      opj_free((void *)(cstr_index___0->tile_index + tileno___3)->marker);
#line 8198
      (cstr_index___0->tile_index + tileno___3)->marker = (opj_marker_info_t *)((void *)0);
#line 8199
      (cstr_index___0->tile_index + tileno___3)->maxmarknum = (OPJ_UINT32 )0;
#line 8200
      (cstr_index___0->tile_index + tileno___3)->marknum = (OPJ_UINT32 )0;
      }
#line 8202
      return (0);
    }
#line 8204
    (cstr_index___0->tile_index + tileno___3)->marker = new_marker___0;
  }
#line 8208
  ((cstr_index___0->tile_index + tileno___3)->marker + (cstr_index___0->tile_index + tileno___3)->marknum)->type = (OPJ_UINT16 )type___0;
#line 8210
  ((cstr_index___0->tile_index + tileno___3)->marker + (cstr_index___0->tile_index + tileno___3)->marknum)->pos = (OPJ_OFF_T )((OPJ_INT32 )pos___0);
#line 8212
  ((cstr_index___0->tile_index + tileno___3)->marker + (cstr_index___0->tile_index + tileno___3)->marknum)->len = (OPJ_INT32 )len___3;
#line 8214
  ((cstr_index___0->tile_index + tileno___3)->marknum) ++;
#line 8216
  if (type___0 == 65424U) {
#line 8217
    l_current_tile_part___0 = (cstr_index___0->tile_index + tileno___3)->current_tpsno;
#line 8219
    if ((cstr_index___0->tile_index + tileno___3)->tp_index) {
#line 8220
      ((cstr_index___0->tile_index + tileno___3)->tp_index + l_current_tile_part___0)->start_pos = pos___0;
    }
  }
#line 8224
  return (1);
}
}
#line 8233 "/root/patron-new/39/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_end_decompress(opj_j2k_t *p_j2k___59 , opj_stream_private_t *p_stream___42 ,
                                opj_event_mgr_t *p_manager___102 ) 
{ 


  {
#line 8241
  return (1);
}
}
#line 8244 "/root/patron-new/39/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_read_header(opj_stream_private_t *p_stream___43 , opj_j2k_t *p_j2k___60 ,
                             opj_image_t **p_image___11 , opj_event_mgr_t *p_manager___103 ) 
{ 
  OPJ_BOOL __cil_tmp9___17 ;
  OPJ_BOOL __cil_tmp10___10 ;
  OPJ_BOOL __cil_tmp11___11 ;
  OPJ_BOOL __cil_tmp12___18 ;
  OPJ_BOOL __cil_tmp14___25 ;

  {
  {
#line 8255
  p_j2k___60->m_private_image = opj_image_create0();
  }
#line 8256
  if (! p_j2k___60->m_private_image) {
#line 8257
    return (0);
  }
  {
#line 8261
  __cil_tmp9___17 = opj_j2k_setup_decoding_validation(p_j2k___60, p_manager___103);
  }
#line 8261
  if (! __cil_tmp9___17) {
    {
#line 8262
    opj_image_destroy(p_j2k___60->m_private_image);
#line 8263
    p_j2k___60->m_private_image = (opj_image_t *)((void *)0);
    }
#line 8264
    return (0);
  }
  {
#line 8268
  __cil_tmp10___10 = opj_j2k_exec(p_j2k___60, p_j2k___60->m_validation_list, p_stream___43,
                                  p_manager___103);
  }
#line 8268
  if (! __cil_tmp10___10) {
    {
#line 8269
    opj_image_destroy(p_j2k___60->m_private_image);
#line 8270
    p_j2k___60->m_private_image = (opj_image_t *)((void *)0);
    }
#line 8271
    return (0);
  }
  {
#line 8275
  __cil_tmp11___11 = opj_j2k_setup_header_reading(p_j2k___60, p_manager___103);
  }
#line 8275
  if (! __cil_tmp11___11) {
    {
#line 8276
    opj_image_destroy(p_j2k___60->m_private_image);
#line 8277
    p_j2k___60->m_private_image = (opj_image_t *)((void *)0);
    }
#line 8278
    return (0);
  }
  {
#line 8282
  __cil_tmp12___18 = opj_j2k_exec(p_j2k___60, p_j2k___60->m_procedure_list, p_stream___43,
                                  p_manager___103);
  }
#line 8282
  if (! __cil_tmp12___18) {
    {
#line 8283
    opj_image_destroy(p_j2k___60->m_private_image);
#line 8284
    p_j2k___60->m_private_image = (opj_image_t *)((void *)0);
    }
#line 8285
    return (0);
  }
  {
#line 8288
  *p_image___11 = opj_image_create0();
  }
#line 8289
  if (! *p_image___11) {
#line 8290
    return (0);
  }
  {
#line 8294
  opj_copy_image_header(p_j2k___60->m_private_image, *p_image___11);
#line 8297
  __cil_tmp14___25 = opj_j2k_allocate_tile_element_cstr_index(p_j2k___60);
  }
#line 8297
  if (! __cil_tmp14___25) {
#line 8298
    return (0);
  }
#line 8301
  return (1);
}
}
#line 8304 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_setup_header_reading(opj_j2k_t *p_j2k___61 , opj_event_mgr_t *p_manager___104 ) 
{ 
  OPJ_BOOL __cil_tmp5___20 ;
  OPJ_BOOL __cil_tmp6___15 ;

  {
  {
#line 8311
  __cil_tmp5___20 = opj_procedure_list_add_procedure(p_j2k___61->m_procedure_list,
                                                     (void (*)(void))(& opj_j2k_read_header_procedure),
                                                     p_manager___104);
  }
#line 8311
  if (! __cil_tmp5___20) {
#line 8313
    return (0);
  }
  {
#line 8317
  __cil_tmp6___15 = opj_procedure_list_add_procedure(p_j2k___61->m_procedure_list,
                                                     (void (*)(void))(& opj_j2k_copy_default_tcp_and_create_tcd),
                                                     p_manager___104);
  }
#line 8317
  if (! __cil_tmp6___15) {
#line 8319
    return (0);
  }
#line 8322
  return (1);
}
}
#line 8325 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_setup_decoding_validation(opj_j2k_t *p_j2k___62 , opj_event_mgr_t *p_manager___105 ) 
{ 
  OPJ_BOOL __cil_tmp5___21 ;
  OPJ_BOOL __cil_tmp6___16 ;

  {
  {
#line 8332
  __cil_tmp5___21 = opj_procedure_list_add_procedure(p_j2k___62->m_validation_list,
                                                     (void (*)(void))(& opj_j2k_build_decoder),
                                                     p_manager___105);
  }
#line 8332
  if (! __cil_tmp5___21) {
#line 8334
    return (0);
  }
  {
#line 8336
  __cil_tmp6___16 = opj_procedure_list_add_procedure(p_j2k___62->m_validation_list,
                                                     (void (*)(void))(& opj_j2k_decoding_validation),
                                                     p_manager___105);
  }
#line 8336
  if (! __cil_tmp6___16) {
#line 8338
    return (0);
  }
#line 8342
  return (1);
}
}
#line 8345 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_mct_validation(opj_j2k_t *p_j2k___63 , opj_stream_private_t *p_stream___44 ,
                                       opj_event_mgr_t *p_manager___106 ) 
{ 
  OPJ_BOOL l_is_valid___0 ;
  OPJ_UINT32 i___62 ;
  OPJ_UINT32 j___6 ;
  OPJ_UINT32 l_nb_tiles___4 ;
  opj_tcp_t *l_tcp___20 ;
  opj_tccp_t *l_tccp___4 ;

  {
#line 8349
  l_is_valid___0 = 1;
#line 8360
  if (((int )p_j2k___63->m_cp.rsiz & 33280) == 33280) {
#line 8361
    l_nb_tiles___4 = p_j2k___63->m_cp.th * p_j2k___63->m_cp.tw;
#line 8362
    l_tcp___20 = p_j2k___63->m_cp.tcps;
#line 8364
    i___62 = (OPJ_UINT32 )0;
    {
#line 8364
    while (1) {
      while_continue: /* CIL Label */ ;

#line 8364
      if (! (i___62 < l_nb_tiles___4)) {
#line 8364
        goto while_break;
      }
#line 8365
      if (l_tcp___20->mct == 2U) {
#line 8366
        l_tccp___4 = l_tcp___20->tccps;
#line 8367
        l_is_valid___0 &= (unsigned long )l_tcp___20->m_mct_coding_matrix != (unsigned long )((OPJ_FLOAT32 *)0);
#line 8369
        j___6 = (OPJ_UINT32 )0;
        {
#line 8369
        while (1) {
          while_continue___0: /* CIL Label */ ;

#line 8369
          if (! (j___6 < (p_j2k___63->m_private_image)->numcomps)) {
#line 8369
            goto while_break___0;
          }
#line 8370
          l_is_valid___0 &= ! (l_tccp___4->qmfbid & 1U);
#line 8371
          l_tccp___4 ++;
#line 8369
          j___6 ++;
        }
        while_break___2: /* CIL Label */ ;
        }

        while_break___0: ;
      }
#line 8374
      l_tcp___20 ++;
#line 8364
      i___62 ++;
    }
    while_break___1: /* CIL Label */ ;
    }

    while_break: ;
  }
#line 8378
  return (l_is_valid___0);
}
}
#line 8381 "/root/patron-new/39/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_setup_mct_encoding(opj_tcp_t *p_tcp___3 , opj_image_t *p_image___12 ) 
{ 
  OPJ_UINT32 i___63 ;
  OPJ_UINT32 l_indix___1 ;
  opj_mct_data_t *l_mct_deco_data ;
  opj_mct_data_t *l_mct_offset_data ;
  opj_simple_mcc_decorrelation_data_t *l_mcc_data ;
  OPJ_UINT32 l_mct_size___1 ;
  OPJ_UINT32 l_nb_elem___0 ;
  OPJ_FLOAT32 *l_data___2 ;
  OPJ_FLOAT32 *l_current_data___12 ;
  opj_tccp_t *l_tccp___5 ;
  opj_mct_data_t *new_mct_records___0 ;
  void *__cil_tmp15___16 ;
  OPJ_UINT32 __cil_tmp16___13 ;
  void *__cil_tmp17___12 ;
  opj_mct_data_t *new_mct_records___1 ;
  void *__cil_tmp19___9 ;
  OPJ_UINT32 __cil_tmp20___8 ;
  void *__cil_tmp21___4 ;
  void *__cil_tmp22___6 ;
  OPJ_FLOAT32 *__cil_tmp23___5 ;
  opj_simple_mcc_decorrelation_data_t *new_mcc_records___0 ;
  void *__cil_tmp25___2 ;
  OPJ_UINT32 __cil_tmp26___1 ;

  {
#line 8384
  l_indix___1 = (OPJ_UINT32 )1;
#line 8385
  l_mct_deco_data = (opj_mct_data_t *)0;
#line 8385
  l_mct_offset_data = (opj_mct_data_t *)0;
#line 8394
  if (p_tcp___3->mct != 2U) {
#line 8395
    return (1);
  }
#line 8398
  if (p_tcp___3->m_mct_decoding_matrix) {
#line 8399
    if (p_tcp___3->m_nb_mct_records == p_tcp___3->m_nb_max_mct_records) {
      {
#line 8401
      p_tcp___3->m_nb_max_mct_records += 10U;
#line 8403
      __cil_tmp15___16 = opj_realloc((void *)p_tcp___3->m_mct_records, (unsigned long )p_tcp___3->m_nb_max_mct_records * sizeof(opj_mct_data_t ));
#line 8403
      new_mct_records___0 = (opj_mct_data_t *)__cil_tmp15___16;
      }
#line 8405
      if (! new_mct_records___0) {
        {
#line 8406
        opj_free((void *)p_tcp___3->m_mct_records);
#line 8407
        p_tcp___3->m_mct_records = (opj_mct_data_t *)((void *)0);
#line 8408
        p_tcp___3->m_nb_max_mct_records = (OPJ_UINT32 )0;
#line 8409
        p_tcp___3->m_nb_mct_records = (OPJ_UINT32 )0;
        }
#line 8411
        return (0);
      }
      {
#line 8413
      p_tcp___3->m_mct_records = new_mct_records___0;
#line 8414
      l_mct_deco_data = p_tcp___3->m_mct_records + p_tcp___3->m_nb_mct_records;
#line 8416
      memset((void *)l_mct_deco_data, 0, (unsigned long )(p_tcp___3->m_nb_max_mct_records - p_tcp___3->m_nb_mct_records) * sizeof(opj_mct_data_t ));
      }
    }
#line 8420
    l_mct_deco_data = p_tcp___3->m_mct_records + p_tcp___3->m_nb_mct_records;
#line 8422
    if (l_mct_deco_data->m_data) {
      {
#line 8423
      opj_free((void *)l_mct_deco_data->m_data);
#line 8424
      l_mct_deco_data->m_data = (OPJ_BYTE *)0;
      }
    }
    {
#line 8427
    __cil_tmp16___13 = l_indix___1;
#line 8427
    l_indix___1 ++;
#line 8427
    l_mct_deco_data->m_index = __cil_tmp16___13;
#line 8428
    l_mct_deco_data->m_array_type = (J2K_MCT_ARRAY_TYPE )1;
#line 8429
    l_mct_deco_data->m_element_type = (J2K_MCT_ELEMENT_TYPE )2;
#line 8430
    l_nb_elem___0 = p_image___12->numcomps * p_image___12->numcomps;
#line 8431
    l_mct_size___1 = l_nb_elem___0 * MCT_ELEMENT_SIZE[l_mct_deco_data->m_element_type];
#line 8432
    __cil_tmp17___12 = opj_malloc((size_t )l_mct_size___1);
#line 8432
    l_mct_deco_data->m_data = (OPJ_BYTE *)__cil_tmp17___12;
    }
#line 8434
    if (! l_mct_deco_data->m_data) {
#line 8435
      return (0);
    }
    {
#line 8438
    (*(j2k_mct_write_functions_from_float[l_mct_deco_data->m_element_type]))((void const   *)p_tcp___3->m_mct_decoding_matrix,
                                                                             (void *)l_mct_deco_data->m_data,
                                                                             l_nb_elem___0);
#line 8441
    l_mct_deco_data->m_data_size = l_mct_size___1;
#line 8442
    (p_tcp___3->m_nb_mct_records) ++;
    }
  }
#line 8445
  if (p_tcp___3->m_nb_mct_records == p_tcp___3->m_nb_max_mct_records) {
    {
#line 8447
    p_tcp___3->m_nb_max_mct_records += 10U;
#line 8448
    __cil_tmp19___9 = opj_realloc((void *)p_tcp___3->m_mct_records, (unsigned long )p_tcp___3->m_nb_max_mct_records * sizeof(opj_mct_data_t ));
#line 8448
    new_mct_records___1 = (opj_mct_data_t *)__cil_tmp19___9;
    }
#line 8450
    if (! new_mct_records___1) {
      {
#line 8451
      opj_free((void *)p_tcp___3->m_mct_records);
#line 8452
      p_tcp___3->m_mct_records = (opj_mct_data_t *)((void *)0);
#line 8453
      p_tcp___3->m_nb_max_mct_records = (OPJ_UINT32 )0;
#line 8454
      p_tcp___3->m_nb_mct_records = (OPJ_UINT32 )0;
      }
#line 8456
      return (0);
    }
    {
#line 8458
    p_tcp___3->m_mct_records = new_mct_records___1;
#line 8459
    l_mct_offset_data = p_tcp___3->m_mct_records + p_tcp___3->m_nb_mct_records;
#line 8461
    memset((void *)l_mct_offset_data, 0, (unsigned long )(p_tcp___3->m_nb_max_mct_records - p_tcp___3->m_nb_mct_records) * sizeof(opj_mct_data_t ));
    }
#line 8465
    if (l_mct_deco_data) {
#line 8466
      l_mct_deco_data = l_mct_offset_data - 1;
    }
  }
#line 8470
  l_mct_offset_data = p_tcp___3->m_mct_records + p_tcp___3->m_nb_mct_records;
#line 8472
  if (l_mct_offset_data->m_data) {
    {
#line 8473
    opj_free((void *)l_mct_offset_data->m_data);
#line 8474
    l_mct_offset_data->m_data = (OPJ_BYTE *)0;
    }
  }
  {
#line 8477
  __cil_tmp20___8 = l_indix___1;
#line 8477
  l_indix___1 ++;
#line 8477
  l_mct_offset_data->m_index = __cil_tmp20___8;
#line 8478
  l_mct_offset_data->m_array_type = (J2K_MCT_ARRAY_TYPE )2;
#line 8479
  l_mct_offset_data->m_element_type = (J2K_MCT_ELEMENT_TYPE )2;
#line 8480
  l_nb_elem___0 = p_image___12->numcomps;
#line 8481
  l_mct_size___1 = l_nb_elem___0 * MCT_ELEMENT_SIZE[l_mct_offset_data->m_element_type];
#line 8482
  __cil_tmp21___4 = opj_malloc((size_t )l_mct_size___1);
#line 8482
  l_mct_offset_data->m_data = (OPJ_BYTE *)__cil_tmp21___4;
  }
#line 8484
  if (! l_mct_offset_data->m_data) {
#line 8485
    return (0);
  }
  {
#line 8488
  __cil_tmp22___6 = opj_malloc((unsigned long )l_nb_elem___0 * sizeof(OPJ_FLOAT32 ));
#line 8488
  l_data___2 = (OPJ_FLOAT32 *)__cil_tmp22___6;
  }
#line 8489
  if (! l_data___2) {
    {
#line 8490
    opj_free((void *)l_mct_offset_data->m_data);
#line 8491
    l_mct_offset_data->m_data = (OPJ_BYTE *)0;
    }
#line 8492
    return (0);
  }
#line 8495
  l_tccp___5 = p_tcp___3->tccps;
#line 8496
  l_current_data___12 = l_data___2;
#line 8498
  i___63 = (OPJ_UINT32 )0;
  {
#line 8498
  while (1) {
    while_continue: /* CIL Label */ ;

#line 8498
    if (! (i___63 < l_nb_elem___0)) {
#line 8498
      goto while_break;
    }
#line 8499
    __cil_tmp23___5 = l_current_data___12;
#line 8499
    l_current_data___12 ++;
#line 8499
    *__cil_tmp23___5 = (OPJ_FLOAT32 )l_tccp___5->m_dc_level_shift;
#line 8500
    l_tccp___5 ++;
#line 8498
    i___63 ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: 
  {
#line 8503
  (*(j2k_mct_write_functions_from_float[l_mct_offset_data->m_element_type]))((void const   *)l_data___2,
                                                                             (void *)l_mct_offset_data->m_data,
                                                                             l_nb_elem___0);
#line 8506
  opj_free((void *)l_data___2);
#line 8508
  l_mct_offset_data->m_data_size = l_mct_size___1;
#line 8510
  (p_tcp___3->m_nb_mct_records) ++;
  }
#line 8512
  if (p_tcp___3->m_nb_mcc_records == p_tcp___3->m_nb_max_mcc_records) {
    {
#line 8514
    p_tcp___3->m_nb_max_mcc_records += 10U;
#line 8515
    __cil_tmp25___2 = opj_realloc((void *)p_tcp___3->m_mcc_records, (unsigned long )p_tcp___3->m_nb_max_mcc_records * sizeof(opj_simple_mcc_decorrelation_data_t ));
#line 8515
    new_mcc_records___0 = (opj_simple_mcc_decorrelation_data_t *)__cil_tmp25___2;
    }
#line 8518
    if (! new_mcc_records___0) {
      {
#line 8519
      opj_free((void *)p_tcp___3->m_mcc_records);
#line 8520
      p_tcp___3->m_mcc_records = (opj_simple_mcc_decorrelation_data_t *)((void *)0);
#line 8521
      p_tcp___3->m_nb_max_mcc_records = (OPJ_UINT32 )0;
#line 8522
      p_tcp___3->m_nb_mcc_records = (OPJ_UINT32 )0;
      }
#line 8524
      return (0);
    }
    {
#line 8526
    p_tcp___3->m_mcc_records = new_mcc_records___0;
#line 8527
    l_mcc_data = p_tcp___3->m_mcc_records + p_tcp___3->m_nb_mcc_records;
#line 8528
    memset((void *)l_mcc_data, 0, (unsigned long )(p_tcp___3->m_nb_max_mcc_records - p_tcp___3->m_nb_mcc_records) * sizeof(opj_simple_mcc_decorrelation_data_t ));
    }
  }
#line 8533
  l_mcc_data = p_tcp___3->m_mcc_records + p_tcp___3->m_nb_mcc_records;
#line 8534
  l_mcc_data->m_decorrelation_array = l_mct_deco_data;
#line 8535
  l_mcc_data->m_is_irreversible = (OPJ_BITFIELD )1;
#line 8536
  l_mcc_data->m_nb_comps = p_image___12->numcomps;
#line 8537
  __cil_tmp26___1 = l_indix___1;
#line 8537
  l_indix___1 ++;
#line 8537
  l_mcc_data->m_index = __cil_tmp26___1;
#line 8538
  l_mcc_data->m_offset_array = l_mct_offset_data;
#line 8539
  (p_tcp___3->m_nb_mcc_records) ++;
#line 8541
  return (1);
}
}
#line 8544 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_build_decoder(opj_j2k_t *p_j2k___64 , opj_stream_private_t *p_stream___45 ,
                                      opj_event_mgr_t *p_manager___107 ) 
{ 


  {
#line 8553
  return (1);
}
}
#line 8556 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_build_encoder(opj_j2k_t *p_j2k___65 , opj_stream_private_t *p_stream___46 ,
                                      opj_event_mgr_t *p_manager___108 ) 
{ 


  {
#line 8565
  return (1);
}
}
#line 8568 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_encoding_validation(opj_j2k_t *p_j2k___66 , opj_stream_private_t *p_stream___47 ,
                                            opj_event_mgr_t *p_manager___109 ) 
{ 
  OPJ_BOOL l_is_valid___1 ;

  {
#line 8572
  l_is_valid___1 = 1;
#line 8583
  l_is_valid___1 &= p_j2k___66->m_specific_param.m_decoder.m_state == 0U;
#line 8587
  l_is_valid___1 &= (unsigned long )p_j2k___66->m_procedure_list != (unsigned long )((opj_procedure_list_t *)0);
#line 8589
  l_is_valid___1 &= (unsigned long )p_j2k___66->m_validation_list != (unsigned long )((opj_procedure_list_t *)0);
#line 8594
  if (((p_j2k___66->m_cp.tcps)->tccps)->numresolutions <= 0U) {
    {
#line 8596
    opj_event_msg(p_manager___109, 1, "Number of resolutions is too high in comparison to the size of tiles\nU");
    }
#line 8598
    return (0);
  } else
#line 8594
  if (((p_j2k___66->m_cp.tcps)->tccps)->numresolutions > 32U) {
    {
#line 8596
    opj_event_msg(p_manager___109, 1, "Number of resolutions is too high in comparison to the size of tiles\nU");
    }
#line 8598
    return (0);
  }
#line 8601
  if (p_j2k___66->m_cp.tdx < (OPJ_UINT32 )(1 << (((p_j2k___66->m_cp.tcps)->tccps)->numresolutions - 1U))) {
    {
#line 8603
    opj_event_msg(p_manager___109, 1, "Number of resolutions is too high in comparison to the size of tiles\n");
    }
#line 8605
    return (0);
  }
#line 8608
  if (p_j2k___66->m_cp.tdy < (OPJ_UINT32 )(1 << (((p_j2k___66->m_cp.tcps)->tccps)->numresolutions - 1U))) {
    {
#line 8610
    opj_event_msg(p_manager___109, 1, "Number of resolutions is too high in comparison to the size of tiles\n");
    }
#line 8612
    return (0);
  }
#line 8616
  return (l_is_valid___1);
}
}
#line 8619 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_decoding_validation(opj_j2k_t *p_j2k___67 , opj_stream_private_t *p_stream___48 ,
                                            opj_event_mgr_t *p_manager___110 ) 
{ 
  OPJ_BOOL l_is_valid___2 ;

  {
#line 8624
  l_is_valid___2 = 1;
#line 8639
  l_is_valid___2 &= p_j2k___67->m_specific_param.m_decoder.m_state == 0U;
#line 8644
  l_is_valid___2 &= (unsigned long )p_j2k___67->m_procedure_list != (unsigned long )((opj_procedure_list_t *)0);
#line 8646
  l_is_valid___2 &= (unsigned long )p_j2k___67->m_validation_list != (unsigned long )((opj_procedure_list_t *)0);
#line 8649
  return (l_is_valid___2);
}
}
#line 8652 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_header_procedure(opj_j2k_t *p_j2k___68 , opj_stream_private_t *p_stream___49 ,
                                              opj_event_mgr_t *p_manager___111 ) 
{ 
  OPJ_UINT32 l_current_marker ;
  OPJ_UINT32 l_marker_size ;
  opj_dec_memory_marker_handler_t *l_marker_handler___0 ;
  OPJ_BOOL l_has_siz ;
  OPJ_BOOL l_has_cod ;
  OPJ_BOOL l_has_qcd ;
  OPJ_BOOL __cil_tmp13___20 ;
  OPJ_SIZE_T __cil_tmp14___26 ;
  OPJ_BOOL __cil_tmp16___14 ;
  OPJ_SIZE_T __cil_tmp18___7 ;
  OPJ_BYTE *new_header_data ;
  void *__cil_tmp20___9 ;
  OPJ_SIZE_T __cil_tmp21___5 ;
  OPJ_BOOL __cil_tmp22___7 ;
  OPJ_OFF_T __cil_tmp23___6 ;
  OPJ_BOOL __cil_tmp24___2 ;
  OPJ_SIZE_T __cil_tmp25___3 ;
  OPJ_BOOL __cil_tmp26___2 ;
  OPJ_OFF_T __cil_tmp27___1 ;

  {
  {
#line 8658
  l_marker_handler___0 = (opj_dec_memory_marker_handler_t *)0;
#line 8659
  l_has_siz = 0;
#line 8660
  l_has_cod = 0;
#line 8661
  l_has_qcd = 0;
#line 8669
  p_j2k___68->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )1;
#line 8672
  __cil_tmp13___20 = opj_j2k_read_soc(p_j2k___68, p_stream___49, p_manager___111);
  }
#line 8672
  if (! __cil_tmp13___20) {
    {
#line 8673
    opj_event_msg(p_manager___111, 1, "Expected a SOC marker \n");
    }
#line 8674
    return (0);
  }
  {
#line 8678
  __cil_tmp14___26 = opj_stream_read_data(p_stream___49, p_j2k___68->m_specific_param.m_decoder.m_header_data,
                                          (OPJ_SIZE_T )2, p_manager___111);
  }
#line 8678
  if (__cil_tmp14___26 != 2UL) {
    {
#line 8680
    opj_event_msg(p_manager___111, 1, "Stream too short\n");
    }
#line 8681
    return (0);
  }
  {
#line 8685
  opj_read_bytes_LE(p_j2k___68->m_specific_param.m_decoder.m_header_data, & l_current_marker,
                    (OPJ_UINT32 )2);
  }
  {
#line 8689
  while (1) {
    while_continue: /* CIL Label */ ;

#line 8689
    if (! (l_current_marker != 65424U)) {
#line 8689
      goto while_break;
    }
#line 8692
    if (l_current_marker < 65280U) {
      {
#line 8693
      opj_event_msg(p_manager___111, 1, "A marker ID was expected (0xff--) instead of %.8x\n",
                    l_current_marker);
      }
#line 8695
      return (0);
    }
    {
#line 8699
    l_marker_handler___0 = opj_j2k_get_marker_handler(l_current_marker);
    }
#line 8702
    if (l_marker_handler___0->id == 0U) {
      {
#line 8703
      __cil_tmp16___14 = opj_j2k_read_unk(p_j2k___68, p_stream___49, & l_current_marker,
                                          p_manager___111);
      }
#line 8703
      if (! __cil_tmp16___14) {
        {
#line 8704
        opj_event_msg(p_manager___111, 1, "Unknow marker have been detected and generated error.\n");
        }
#line 8706
        return (0);
      }
#line 8709
      if (l_current_marker == 65424U) {
#line 8710
        goto while_break;
      } else {
        {
#line 8712
        l_marker_handler___0 = opj_j2k_get_marker_handler(l_current_marker);
        }
      }
    }
#line 8716
    if (l_marker_handler___0->id == 65361U) {
#line 8718
      l_has_siz = 1;
    }
#line 8720
    if (l_marker_handler___0->id == 65362U) {
#line 8722
      l_has_cod = 1;
    }
#line 8724
    if (l_marker_handler___0->id == 65372U) {
#line 8726
      l_has_qcd = 1;
    }
#line 8730
    if (! (p_j2k___68->m_specific_param.m_decoder.m_state & l_marker_handler___0->states)) {
      {
#line 8731
      opj_event_msg(p_manager___111, 1, "Marker is not compliant with its position\n");
      }
#line 8733
      return (0);
    }
    {
#line 8737
    __cil_tmp18___7 = opj_stream_read_data(p_stream___49, p_j2k___68->m_specific_param.m_decoder.m_header_data,
                                           (OPJ_SIZE_T )2, p_manager___111);
    }
#line 8737
    if (__cil_tmp18___7 != 2UL) {
      {
#line 8739
      opj_event_msg(p_manager___111, 1, "Stream too short\n/\237\005]U");
      }
#line 8740
      return (0);
    }
    {
#line 8744
    opj_read_bytes_LE(p_j2k___68->m_specific_param.m_decoder.m_header_data, & l_marker_size,
                      (OPJ_UINT32 )2);
    }
#line 8746
    if (l_marker_size < 2U) {
      {
#line 8747
      opj_event_msg(p_manager___111, 1, "Invalid marker size\n]U");
      }
#line 8748
      return (0);
    }
#line 8750
    l_marker_size -= 2U;
#line 8753
    if (l_marker_size > p_j2k___68->m_specific_param.m_decoder.m_header_data_size) {
      {
#line 8754
      __cil_tmp20___9 = opj_realloc((void *)p_j2k___68->m_specific_param.m_decoder.m_header_data,
                                    (size_t )l_marker_size);
#line 8754
      new_header_data = (OPJ_BYTE *)__cil_tmp20___9;
      }
#line 8756
      if (! new_header_data) {
        {
#line 8757
        opj_free((void *)p_j2k___68->m_specific_param.m_decoder.m_header_data);
#line 8758
        p_j2k___68->m_specific_param.m_decoder.m_header_data = (OPJ_BYTE *)((void *)0);
#line 8759
        p_j2k___68->m_specific_param.m_decoder.m_header_data_size = (OPJ_UINT32 )0;
#line 8760
        opj_event_msg(p_manager___111, 1, "Not enough memory to read header\n");
        }
#line 8761
        return (0);
      }
#line 8763
      p_j2k___68->m_specific_param.m_decoder.m_header_data = new_header_data;
#line 8764
      p_j2k___68->m_specific_param.m_decoder.m_header_data_size = l_marker_size;
    }
    {
#line 8768
    __cil_tmp21___5 = opj_stream_read_data(p_stream___49, p_j2k___68->m_specific_param.m_decoder.m_header_data,
                                           (OPJ_SIZE_T )l_marker_size, p_manager___111);
    }
#line 8768
    if (__cil_tmp21___5 != (unsigned long )l_marker_size) {
      {
#line 8771
      opj_event_msg(p_manager___111, 1, "Stream too short\n");
      }
#line 8772
      return (0);
    }
    {
#line 8776
    __cil_tmp22___7 = (*(l_marker_handler___0->handler))(p_j2k___68, p_j2k___68->m_specific_param.m_decoder.m_header_data,
                                                         l_marker_size, p_manager___111);
    }
#line 8776
    if (! __cil_tmp22___7) {
      {
#line 8778
      opj_event_msg(p_manager___111, 1, "Marker handler function failed to read the marker segment\n");
      }
#line 8780
      return (0);
    }
    {
#line 8784
    __cil_tmp23___6 = opj_stream_tell(p_stream___49);
#line 8784
    __cil_tmp24___2 = opj_j2k_add_mhmarker(p_j2k___68->cstr_index, l_marker_handler___0->id,
                                           (OPJ_OFF_T )(((OPJ_UINT32 )__cil_tmp23___6 - l_marker_size) - 4U),
                                           l_marker_size + 4U);
    }
#line 8784
    if (0 == __cil_tmp24___2) {
      {
#line 8789
      opj_event_msg(p_manager___111, 1, "Not enough memory to add mh marker\n\005]U");
      }
#line 8790
      return (0);
    }
    {
#line 8794
    __cil_tmp25___3 = opj_stream_read_data(p_stream___49, p_j2k___68->m_specific_param.m_decoder.m_header_data,
                                           (OPJ_SIZE_T )2, p_manager___111);
    }
#line 8794
    if (__cil_tmp25___3 != 2UL) {
      {
#line 8796
      opj_event_msg(p_manager___111, 1, "Stream too short\n\261\242\005]U");
      }
#line 8797
      return (0);
    }
    {
#line 8801
    opj_read_bytes_LE(p_j2k___68->m_specific_param.m_decoder.m_header_data, & l_current_marker,
                      (OPJ_UINT32 )2);
    }
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 8805
  if (l_has_siz == 0) {
    {
#line 8806
    opj_event_msg(p_manager___111, 1, "required SIZ marker not found in main header\n");
    }
#line 8808
    return (0);
  }
#line 8810
  if (l_has_cod == 0) {
    {
#line 8811
    opj_event_msg(p_manager___111, 1, "required COD marker not found in main header\n");
    }
#line 8813
    return (0);
  }
#line 8815
  if (l_has_qcd == 0) {
    {
#line 8816
    opj_event_msg(p_manager___111, 1, "required QCD marker not found in main header\nU");
    }
#line 8818
    return (0);
  }
  {
#line 8821
  __cil_tmp26___2 = opj_j2k_merge_ppm(& p_j2k___68->m_cp, p_manager___111);
  }
#line 8821
  if (! __cil_tmp26___2) {
    {
#line 8822
    opj_event_msg(p_manager___111, 1, "Failed to merge PPM data\n\a\237\005]U");
    }
#line 8823
    return (0);
  }
  {
#line 8826
  opj_event_msg(p_manager___111, 4, "Main header has been correctly decoded.\n\220");
#line 8829
  __cil_tmp27___1 = opj_stream_tell(p_stream___49);
#line 8829
  (p_j2k___68->cstr_index)->main_head_end = (OPJ_OFF_T )((OPJ_UINT32 )__cil_tmp27___1 - 2U);
#line 8832
  p_j2k___68->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )8;
  }
#line 8834
  return (1);
}
}
#line 8837 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_exec(opj_j2k_t *p_j2k___69 , opj_procedure_list_t *p_procedure_list___0 ,
                             opj_stream_private_t *p_stream___50 , opj_event_mgr_t *p_manager___112 ) 
{ 
  OPJ_BOOL (**l_procedure___0)(opj_j2k_t * , opj_stream_private_t * , opj_event_mgr_t * ) ;
  OPJ_BOOL l_result___2 ;
  OPJ_UINT32 l_nb_proc___0 ;
  OPJ_UINT32 i___64 ;
  opj_procedure *__cil_tmp14___27 ;
  OPJ_BOOL __cil_tmp15___18 ;
  int tmp___350 ;

  {
  {
#line 8842
  l_procedure___0 = (OPJ_BOOL (**)(opj_j2k_t * , opj_stream_private_t * , opj_event_mgr_t * ))0;
#line 8844
  l_result___2 = 1;
#line 8853
  l_nb_proc___0 = opj_procedure_list_get_nb_procedures(p_procedure_list___0);
#line 8854
  __cil_tmp14___27 = opj_procedure_list_get_first_procedure(p_procedure_list___0);
#line 8854
  l_procedure___0 = (OPJ_BOOL (**)(opj_j2k_t * , opj_stream_private_t * , opj_event_mgr_t * ))__cil_tmp14___27;
#line 8857
  i___64 = (OPJ_UINT32 )0;
  }
  {
#line 8857
  while (1) {
    while_continue: /* CIL Label */ ;

#line 8857
    if (! (i___64 < l_nb_proc___0)) {
#line 8857
      goto while_break;
    }
    {
#line 8858
    __cil_tmp15___18 = (*(*l_procedure___0))(p_j2k___69, p_stream___50, p_manager___112);
    }
#line 8858
    if (l_result___2) {
#line 8858
      if (__cil_tmp15___18) {
#line 8858
        tmp___350 = 1;
      } else {
#line 8858
        tmp___350 = 0;
      }
    } else {
#line 8858
      tmp___350 = 0;
    }
#line 8858
    l_result___2 = tmp___350;
#line 8859
    l_procedure___0 ++;
#line 8857
    i___64 ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: 
  {
#line 8863
  opj_procedure_list_clear(p_procedure_list___0);
  }
#line 8864
  return (l_result___2);
}
}
#line 8868 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_copy_default_tcp_and_create_tcd(opj_j2k_t *p_j2k___70 , opj_stream_private_t *p_stream___51 ,
                                                        opj_event_mgr_t *p_manager___113 ) 
{ 
  opj_tcp_t *l_tcp___21 ;
  opj_tcp_t *l_default_tcp ;
  OPJ_UINT32 l_nb_tiles___5 ;
  OPJ_UINT32 i___65 ;
  OPJ_UINT32 j___7 ;
  opj_tccp_t *l_current_tccp ;
  OPJ_UINT32 l_tccp_size ;
  OPJ_UINT32 l_mct_size___2 ;
  opj_image_t *l_image___10 ;
  OPJ_UINT32 l_mcc_records_size ;
  OPJ_UINT32 l_mct_records_size ;
  opj_mct_data_t *l_src_mct_rec ;
  opj_mct_data_t *l_dest_mct_rec ;
  opj_simple_mcc_decorrelation_data_t *l_src_mcc_rec ;
  opj_simple_mcc_decorrelation_data_t *l_dest_mcc_rec ;
  OPJ_UINT32 l_offset___0 ;
  void *__cil_tmp23___7 ;
  void *__cil_tmp24___3 ;
  void *__cil_tmp25___4 ;
  void *__cil_tmp26___3 ;
  OPJ_BOOL __cil_tmp28___2 ;

  {
#line 8873
  l_tcp___21 = (opj_tcp_t *)0;
#line 8874
  l_default_tcp = (opj_tcp_t *)0;
#line 8877
  l_current_tccp = (opj_tccp_t *)0;
#line 8893
  l_image___10 = p_j2k___70->m_private_image;
#line 8894
  l_nb_tiles___5 = p_j2k___70->m_cp.th * p_j2k___70->m_cp.tw;
#line 8895
  l_tcp___21 = p_j2k___70->m_cp.tcps;
#line 8896
  l_tccp_size = l_image___10->numcomps * (OPJ_UINT32 )sizeof(opj_tccp_t );
#line 8897
  l_default_tcp = p_j2k___70->m_specific_param.m_decoder.m_default_tcp;
#line 8898
  l_mct_size___2 = (l_image___10->numcomps * l_image___10->numcomps) * (OPJ_UINT32 )sizeof(OPJ_FLOAT32 );
#line 8902
  i___65 = (OPJ_UINT32 )0;
  {
#line 8902
  while (1) {
    while_continue: /* CIL Label */ ;

#line 8902
    if (! (i___65 < l_nb_tiles___5)) {
#line 8902
      goto while_break;
    }
    {
#line 8904
    l_current_tccp = l_tcp___21->tccps;
#line 8906
    memcpy((void *)l_tcp___21, (void const   *)l_default_tcp, sizeof(opj_tcp_t ));
#line 8908
    l_tcp___21->cod = (OPJ_BITFIELD )0;
#line 8909
    l_tcp___21->ppt = (OPJ_BITFIELD )0;
#line 8910
    l_tcp___21->ppt_data = (OPJ_BYTE *)0;
#line 8911
    l_tcp___21->m_current_tile_part_number = -1;
#line 8913
    l_tcp___21->m_mct_decoding_matrix = (OPJ_FLOAT32 *)0;
#line 8914
    l_tcp___21->m_nb_max_mct_records = (OPJ_UINT32 )0;
#line 8915
    l_tcp___21->m_mct_records = (opj_mct_data_t *)0;
#line 8916
    l_tcp___21->m_nb_max_mcc_records = (OPJ_UINT32 )0;
#line 8917
    l_tcp___21->m_mcc_records = (opj_simple_mcc_decorrelation_data_t *)0;
#line 8919
    l_tcp___21->tccps = l_current_tccp;
    }
#line 8922
    if (l_default_tcp->m_mct_decoding_matrix) {
      {
#line 8923
      __cil_tmp23___7 = opj_malloc((size_t )l_mct_size___2);
#line 8923
      l_tcp___21->m_mct_decoding_matrix = (OPJ_FLOAT32 *)__cil_tmp23___7;
      }
#line 8924
      if (! l_tcp___21->m_mct_decoding_matrix) {
#line 8925
        return (0);
      }
      {
#line 8927
      memcpy((void *)l_tcp___21->m_mct_decoding_matrix, (void const   *)l_default_tcp->m_mct_decoding_matrix,
             (unsigned long )l_mct_size___2);
      }
    }
    {
#line 8932
    l_mct_records_size = l_default_tcp->m_nb_max_mct_records * (OPJ_UINT32 )sizeof(opj_mct_data_t );
#line 8934
    __cil_tmp24___3 = opj_malloc((size_t )l_mct_records_size);
#line 8934
    l_tcp___21->m_mct_records = (opj_mct_data_t *)__cil_tmp24___3;
    }
#line 8935
    if (! l_tcp___21->m_mct_records) {
#line 8936
      return (0);
    }
    {
#line 8938
    memcpy((void *)l_tcp___21->m_mct_records, (void const   *)l_default_tcp->m_mct_records,
           (unsigned long )l_mct_records_size);
#line 8941
    l_src_mct_rec = l_default_tcp->m_mct_records;
#line 8942
    l_dest_mct_rec = l_tcp___21->m_mct_records;
#line 8944
    j___7 = (OPJ_UINT32 )0;
    }
    {
#line 8944
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 8944
      if (! (j___7 < l_default_tcp->m_nb_mct_records)) {
#line 8944
        goto while_break___0;
      }
#line 8946
      if (l_src_mct_rec->m_data) {
        {
#line 8948
        __cil_tmp25___4 = opj_malloc((size_t )l_src_mct_rec->m_data_size);
#line 8948
        l_dest_mct_rec->m_data = (OPJ_BYTE *)__cil_tmp25___4;
        }
#line 8949
        if (! l_dest_mct_rec->m_data) {
#line 8950
          return (0);
        }
        {
#line 8952
        memcpy((void *)l_dest_mct_rec->m_data, (void const   *)l_src_mct_rec->m_data,
               (unsigned long )l_src_mct_rec->m_data_size);
        }
      }
#line 8956
      l_src_mct_rec ++;
#line 8957
      l_dest_mct_rec ++;
#line 8959
      (l_tcp___21->m_nb_max_mct_records) ++;
#line 8944
      j___7 ++;
    }
    while_break___3: /* CIL Label */ ;
    }

    while_break___0: 
    {
#line 8963
    l_mcc_records_size = l_default_tcp->m_nb_max_mcc_records * (OPJ_UINT32 )sizeof(opj_simple_mcc_decorrelation_data_t );
#line 8965
    __cil_tmp26___3 = opj_malloc((size_t )l_mcc_records_size);
#line 8965
    l_tcp___21->m_mcc_records = (opj_simple_mcc_decorrelation_data_t *)__cil_tmp26___3;
    }
#line 8967
    if (! l_tcp___21->m_mcc_records) {
#line 8968
      return (0);
    }
    {
#line 8970
    memcpy((void *)l_tcp___21->m_mcc_records, (void const   *)l_default_tcp->m_mcc_records,
           (unsigned long )l_mcc_records_size);
#line 8971
    l_tcp___21->m_nb_max_mcc_records = l_default_tcp->m_nb_max_mcc_records;
#line 8974
    l_src_mcc_rec = l_default_tcp->m_mcc_records;
#line 8975
    l_dest_mcc_rec = l_tcp___21->m_mcc_records;
#line 8977
    j___7 = (OPJ_UINT32 )0;
    }
    {
#line 8977
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 8977
      if (! (j___7 < l_default_tcp->m_nb_max_mcc_records)) {
#line 8977
        goto while_break___1;
      }
#line 8979
      if (l_src_mcc_rec->m_decorrelation_array) {
#line 8980
        l_offset___0 = (OPJ_UINT32 )(l_src_mcc_rec->m_decorrelation_array - l_default_tcp->m_mct_records);
#line 8982
        l_dest_mcc_rec->m_decorrelation_array = l_tcp___21->m_mct_records + l_offset___0;
      }
#line 8985
      if (l_src_mcc_rec->m_offset_array) {
#line 8986
        l_offset___0 = (OPJ_UINT32 )(l_src_mcc_rec->m_offset_array - l_default_tcp->m_mct_records);
#line 8988
        l_dest_mcc_rec->m_offset_array = l_tcp___21->m_mct_records + l_offset___0;
      }
#line 8991
      l_src_mcc_rec ++;
#line 8992
      l_dest_mcc_rec ++;
#line 8977
      j___7 ++;
    }
    while_break___4: /* CIL Label */ ;
    }

    while_break___1: 
    {
#line 8996
    memcpy((void *)l_current_tccp, (void const   *)l_default_tcp->tccps, (unsigned long )l_tccp_size);
#line 8999
    l_tcp___21 ++;
#line 8902
    i___65 ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }

  while_break: 
  {
#line 9003
  p_j2k___70->m_tcd = opj_tcd_create(1);
  }
#line 9004
  if (! p_j2k___70->m_tcd) {
#line 9005
    return (0);
  }
  {
#line 9008
  __cil_tmp28___2 = opj_tcd_init(p_j2k___70->m_tcd, l_image___10, & p_j2k___70->m_cp,
                                 p_j2k___70->m_tp);
  }
#line 9008
  if (! __cil_tmp28___2) {
    {
#line 9009
    opj_tcd_destroy(p_j2k___70->m_tcd);
#line 9010
    p_j2k___70->m_tcd = (struct opj_tcd *)0;
#line 9011
    opj_event_msg(p_manager___113, 1, "Cannot decode tile, memory error\n");
    }
#line 9012
    return (0);
  }
#line 9015
  return (1);
}
}
#line 9018 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static struct opj_dec_memory_marker_handler *opj_j2k_get_marker_handler(OPJ_UINT32 p_id___1 ) 
{ 
  opj_dec_memory_marker_handler_t *e ;

  {
#line 9022
  e = j2k_memory_marker_handler_tab;
  {
#line 9022
  while (1) {
    while_continue: /* CIL Label */ ;

#line 9022
    if (! (e->id != 0U)) {
#line 9022
      goto while_break;
    }
#line 9023
    if (e->id == p_id___1) {
#line 9024
      goto while_break;
    }
#line 9022
    e ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 9027
  return (e);
}
}
#line 9030 "/root/patron-new/39/src/lib/openjp2/j2k.c"
void opj_j2k_destroy(opj_j2k_t *p_j2k___71 ) 
{ 


  {
#line 9032
  if ((unsigned long )p_j2k___71 == (unsigned long )((opj_j2k_t *)0)) {
#line 9033
    return;
  }
#line 9036
  if (p_j2k___71->m_is_decoder) {
#line 9038
    if ((unsigned long )p_j2k___71->m_specific_param.m_decoder.m_default_tcp != (unsigned long )((opj_tcp_t *)0)) {
      {
#line 9039
      opj_j2k_tcp_destroy(p_j2k___71->m_specific_param.m_decoder.m_default_tcp);
#line 9040
      opj_free((void *)p_j2k___71->m_specific_param.m_decoder.m_default_tcp);
#line 9041
      p_j2k___71->m_specific_param.m_decoder.m_default_tcp = (opj_tcp_t *)0;
      }
    }
#line 9044
    if ((unsigned long )p_j2k___71->m_specific_param.m_decoder.m_header_data != (unsigned long )((OPJ_BYTE *)0)) {
      {
#line 9045
      opj_free((void *)p_j2k___71->m_specific_param.m_decoder.m_header_data);
#line 9046
      p_j2k___71->m_specific_param.m_decoder.m_header_data = (OPJ_BYTE *)0;
#line 9047
      p_j2k___71->m_specific_param.m_decoder.m_header_data_size = (OPJ_UINT32 )0;
      }
    }
    {
#line 9050
    opj_free((void *)p_j2k___71->m_specific_param.m_decoder.m_comps_indices_to_decode);
#line 9051
    p_j2k___71->m_specific_param.m_decoder.m_comps_indices_to_decode = (OPJ_UINT32 *)0;
#line 9052
    p_j2k___71->m_specific_param.m_decoder.m_numcomps_to_decode = (OPJ_UINT32 )0;
    }
  } else {
#line 9056
    if (p_j2k___71->m_specific_param.m_encoder.m_encoded_tile_data) {
      {
#line 9057
      opj_free((void *)p_j2k___71->m_specific_param.m_encoder.m_encoded_tile_data);
#line 9058
      p_j2k___71->m_specific_param.m_encoder.m_encoded_tile_data = (OPJ_BYTE *)0;
      }
    }
#line 9061
    if (p_j2k___71->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer) {
      {
#line 9062
      opj_free((void *)p_j2k___71->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer);
#line 9063
      p_j2k___71->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer = (OPJ_BYTE *)0;
#line 9064
      p_j2k___71->m_specific_param.m_encoder.m_tlm_sot_offsets_current = (OPJ_BYTE *)0;
      }
    }
#line 9067
    if (p_j2k___71->m_specific_param.m_encoder.m_header_tile_data) {
      {
#line 9068
      opj_free((void *)p_j2k___71->m_specific_param.m_encoder.m_header_tile_data);
#line 9069
      p_j2k___71->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)0;
#line 9070
      p_j2k___71->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
      }
    }
  }
  {
#line 9074
  opj_tcd_destroy(p_j2k___71->m_tcd);
#line 9076
  opj_j2k_cp_destroy(& p_j2k___71->m_cp);
#line 9077
  memset((void *)(& p_j2k___71->m_cp), 0, sizeof(opj_cp_t ));
#line 9079
  opj_procedure_list_destroy(p_j2k___71->m_procedure_list);
#line 9080
  p_j2k___71->m_procedure_list = (opj_procedure_list_t *)0;
#line 9082
  opj_procedure_list_destroy(p_j2k___71->m_validation_list);
#line 9083
  p_j2k___71->m_procedure_list = (opj_procedure_list_t *)0;
#line 9085
  j2k_destroy_cstr_index(p_j2k___71->cstr_index);
#line 9086
  p_j2k___71->cstr_index = (opj_codestream_index_t *)((void *)0);
#line 9088
  opj_image_destroy(p_j2k___71->m_private_image);
#line 9089
  p_j2k___71->m_private_image = (opj_image_t *)((void *)0);
#line 9091
  opj_image_destroy(p_j2k___71->m_output_image);
#line 9092
  p_j2k___71->m_output_image = (opj_image_t *)((void *)0);
#line 9094
  opj_thread_pool_destroy(p_j2k___71->m_tp);
#line 9095
  p_j2k___71->m_tp = (opj_thread_pool_t *)((void *)0);
#line 9097
  opj_free((void *)p_j2k___71);
  }
#line 9099
  return;
}
}
#line 9100 "/root/patron-new/39/src/lib/openjp2/j2k.c"
void j2k_destroy_cstr_index(opj_codestream_index_t *p_cstr_ind ) 
{ 
  OPJ_UINT32 it_tile ;

  {
#line 9102
  if (p_cstr_ind) {
#line 9104
    if (p_cstr_ind->marker) {
      {
#line 9105
      opj_free((void *)p_cstr_ind->marker);
#line 9106
      p_cstr_ind->marker = (opj_marker_info_t *)((void *)0);
      }
    }
#line 9109
    if (p_cstr_ind->tile_index) {
#line 9110
      it_tile = (OPJ_UINT32 )0;
#line 9112
      it_tile = (OPJ_UINT32 )0;
      {
#line 9112
      while (1) {
        while_continue: /* CIL Label */ ;

#line 9112
        if (! (it_tile < p_cstr_ind->nb_of_tiles)) {
#line 9112
          goto while_break;
        }
#line 9114
        if ((p_cstr_ind->tile_index + it_tile)->packet_index) {
          {
#line 9115
          opj_free((void *)(p_cstr_ind->tile_index + it_tile)->packet_index);
#line 9116
          (p_cstr_ind->tile_index + it_tile)->packet_index = (opj_packet_info_t *)((void *)0);
          }
        }
#line 9119
        if ((p_cstr_ind->tile_index + it_tile)->tp_index) {
          {
#line 9120
          opj_free((void *)(p_cstr_ind->tile_index + it_tile)->tp_index);
#line 9121
          (p_cstr_ind->tile_index + it_tile)->tp_index = (opj_tp_index_t *)((void *)0);
          }
        }
#line 9124
        if ((p_cstr_ind->tile_index + it_tile)->marker) {
          {
#line 9125
          opj_free((void *)(p_cstr_ind->tile_index + it_tile)->marker);
#line 9126
          (p_cstr_ind->tile_index + it_tile)->marker = (opj_marker_info_t *)((void *)0);
          }
        }
#line 9112
        it_tile ++;
      }
      while_break___0: /* CIL Label */ ;
      }

      while_break: 
      {
#line 9131
      opj_free((void *)p_cstr_ind->tile_index);
#line 9132
      p_cstr_ind->tile_index = (opj_tile_index_t *)((void *)0);
      }
    }
    {
#line 9135
    opj_free((void *)p_cstr_ind);
    }
  }
#line 9138
  return;
}
}
#line 9139 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static void opj_j2k_tcp_destroy(opj_tcp_t *p_tcp___4 ) 
{ 
  OPJ_UINT32 i___66 ;
  opj_mct_data_t *l_mct_data___1 ;
  OPJ_UINT32 i___67 ;

  {
#line 9141
  if ((unsigned long )p_tcp___4 == (unsigned long )((opj_tcp_t *)0)) {
#line 9142
    return;
  }
#line 9145
  if ((unsigned long )p_tcp___4->ppt_markers != (unsigned long )((opj_ppx *)0)) {
#line 9147
    i___66 = 0U;
    {
#line 9147
    while (1) {
      while_continue: /* CIL Label */ ;

#line 9147
      if (! (i___66 < p_tcp___4->ppt_markers_count)) {
#line 9147
        goto while_break;
      }
#line 9148
      if ((unsigned long )(p_tcp___4->ppt_markers + i___66)->m_data != (unsigned long )((void *)0)) {
        {
#line 9149
        opj_free((void *)(p_tcp___4->ppt_markers + i___66)->m_data);
        }
      }
#line 9147
      i___66 ++;
    }
    while_break___1: /* CIL Label */ ;
    }

    while_break: 
    {
#line 9152
    p_tcp___4->ppt_markers_count = 0U;
#line 9153
    opj_free((void *)p_tcp___4->ppt_markers);
#line 9154
    p_tcp___4->ppt_markers = (opj_ppx *)((void *)0);
    }
  }
#line 9157
  if ((unsigned long )p_tcp___4->ppt_buffer != (unsigned long )((OPJ_BYTE *)0)) {
    {
#line 9158
    opj_free((void *)p_tcp___4->ppt_buffer);
#line 9159
    p_tcp___4->ppt_buffer = (OPJ_BYTE *)0;
    }
  }
#line 9162
  if ((unsigned long )p_tcp___4->tccps != (unsigned long )((opj_tccp_t *)0)) {
    {
#line 9163
    opj_free((void *)p_tcp___4->tccps);
#line 9164
    p_tcp___4->tccps = (opj_tccp_t *)0;
    }
  }
#line 9167
  if ((unsigned long )p_tcp___4->m_mct_coding_matrix != (unsigned long )((OPJ_FLOAT32 *)0)) {
    {
#line 9168
    opj_free((void *)p_tcp___4->m_mct_coding_matrix);
#line 9169
    p_tcp___4->m_mct_coding_matrix = (OPJ_FLOAT32 *)0;
    }
  }
#line 9172
  if ((unsigned long )p_tcp___4->m_mct_decoding_matrix != (unsigned long )((OPJ_FLOAT32 *)0)) {
    {
#line 9173
    opj_free((void *)p_tcp___4->m_mct_decoding_matrix);
#line 9174
    p_tcp___4->m_mct_decoding_matrix = (OPJ_FLOAT32 *)0;
    }
  }
#line 9177
  if (p_tcp___4->m_mcc_records) {
    {
#line 9178
    opj_free((void *)p_tcp___4->m_mcc_records);
#line 9179
    p_tcp___4->m_mcc_records = (opj_simple_mcc_decorrelation_data_t *)0;
#line 9180
    p_tcp___4->m_nb_max_mcc_records = (OPJ_UINT32 )0;
#line 9181
    p_tcp___4->m_nb_mcc_records = (OPJ_UINT32 )0;
    }
  }
#line 9184
  if (p_tcp___4->m_mct_records) {
#line 9185
    l_mct_data___1 = p_tcp___4->m_mct_records;
#line 9188
    i___67 = (OPJ_UINT32 )0;
    {
#line 9188
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 9188
      if (! (i___67 < p_tcp___4->m_nb_mct_records)) {
#line 9188
        goto while_break___0;
      }
#line 9189
      if (l_mct_data___1->m_data) {
        {
#line 9190
        opj_free((void *)l_mct_data___1->m_data);
#line 9191
        l_mct_data___1->m_data = (OPJ_BYTE *)0;
        }
      }
#line 9194
      l_mct_data___1 ++;
#line 9188
      i___67 ++;
    }
    while_break___2: /* CIL Label */ ;
    }

    while_break___0: 
    {
#line 9197
    opj_free((void *)p_tcp___4->m_mct_records);
#line 9198
    p_tcp___4->m_mct_records = (opj_mct_data_t *)0;
    }
  }
#line 9201
  if ((unsigned long )p_tcp___4->mct_norms != (unsigned long )((OPJ_FLOAT64 *)0)) {
    {
#line 9202
    opj_free((void *)p_tcp___4->mct_norms);
#line 9203
    p_tcp___4->mct_norms = (OPJ_FLOAT64 *)0;
    }
  }
  {
#line 9206
  opj_j2k_tcp_data_destroy(p_tcp___4);
  }
#line 9208
  return;
}
}
#line 9210 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static void opj_j2k_tcp_data_destroy(opj_tcp_t *p_tcp___5 ) 
{ 


  {
#line 9212
  if (p_tcp___5->m_data) {
    {
#line 9213
    opj_free((void *)p_tcp___5->m_data);
#line 9214
    p_tcp___5->m_data = (OPJ_BYTE *)((void *)0);
#line 9215
    p_tcp___5->m_data_size = (OPJ_UINT32 )0;
    }
  }
#line 9218
  return;
}
}
#line 9219 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static void opj_j2k_cp_destroy(opj_cp_t *p_cp___0 ) 
{ 
  OPJ_UINT32 l_nb_tiles___6 ;
  opj_tcp_t *l_current_tile ;
  OPJ_UINT32 i___68 ;
  OPJ_UINT32 i___69 ;

  {
#line 9222
  l_current_tile = (opj_tcp_t *)0;
#line 9224
  if ((unsigned long )p_cp___0 == (unsigned long )((opj_cp_t *)0)) {
#line 9225
    return;
  }
#line 9227
  if ((unsigned long )p_cp___0->tcps != (unsigned long )((opj_tcp_t *)0)) {
#line 9229
    l_current_tile = p_cp___0->tcps;
#line 9230
    l_nb_tiles___6 = p_cp___0->th * p_cp___0->tw;
#line 9232
    i___68 = 0U;
    {
#line 9232
    while (1) {
      while_continue: /* CIL Label */ ;

#line 9232
      if (! (i___68 < l_nb_tiles___6)) {
#line 9232
        goto while_break;
      }
      {
#line 9233
      opj_j2k_tcp_destroy(l_current_tile);
#line 9234
      l_current_tile ++;
#line 9232
      i___68 ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }

    while_break: 
    {
#line 9236
    opj_free((void *)p_cp___0->tcps);
#line 9237
    p_cp___0->tcps = (opj_tcp_t *)0;
    }
  }
#line 9239
  if ((unsigned long )p_cp___0->ppm_markers != (unsigned long )((opj_ppx *)0)) {
#line 9241
    i___69 = 0U;
    {
#line 9241
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 9241
      if (! (i___69 < p_cp___0->ppm_markers_count)) {
#line 9241
        goto while_break___0;
      }
#line 9242
      if ((unsigned long )(p_cp___0->ppm_markers + i___69)->m_data != (unsigned long )((void *)0)) {
        {
#line 9243
        opj_free((void *)(p_cp___0->ppm_markers + i___69)->m_data);
        }
      }
#line 9241
      i___69 ++;
    }
    while_break___2: /* CIL Label */ ;
    }

    while_break___0: 
    {
#line 9246
    p_cp___0->ppm_markers_count = 0U;
#line 9247
    opj_free((void *)p_cp___0->ppm_markers);
#line 9248
    p_cp___0->ppm_markers = (opj_ppx *)((void *)0);
    }
  }
  {
#line 9250
  opj_free((void *)p_cp___0->ppm_buffer);
#line 9251
  p_cp___0->ppm_buffer = (OPJ_BYTE *)0;
#line 9252
  p_cp___0->ppm_data = (OPJ_BYTE *)((void *)0);
#line 9254
  opj_free((void *)p_cp___0->comment);
#line 9255
  p_cp___0->comment = (OPJ_CHAR *)0;
  }
#line 9256
  if (! p_cp___0->m_is_decoder) {
    {
#line 9257
    opj_free((void *)p_cp___0->m_specific_param.m_enc.m_matrice);
#line 9258
    p_cp___0->m_specific_param.m_enc.m_matrice = (OPJ_INT32 *)0;
    }
  }
#line 9261
  return;
}
}
#line 9262 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_need_nb_tile_parts_correction(opj_stream_private_t *p_stream___52 ,
                                                      OPJ_UINT32 tile_no , OPJ_BOOL *p_correction_needed ,
                                                      opj_event_mgr_t *p_manager___114 ) 
{ 
  OPJ_BYTE l_header_data[10] ;
  OPJ_OFF_T l_stream_pos_backup ;
  OPJ_UINT32 l_current_marker___0 ;
  OPJ_UINT32 l_marker_size___0 ;
  OPJ_UINT32 l_tile_no ;
  OPJ_UINT32 l_tot_len___0 ;
  OPJ_UINT32 l_current_part___0 ;
  OPJ_UINT32 l_num_parts___0 ;
  OPJ_BOOL __cil_tmp13___22 ;
  OPJ_SIZE_T __cil_tmp15___19 ;
  OPJ_BOOL __cil_tmp16___15 ;
  OPJ_BOOL __cil_tmp17___14 ;
  OPJ_SIZE_T __cil_tmp18___8 ;
  OPJ_SIZE_T __cil_tmp19___10 ;
  OPJ_BOOL __cil_tmp20___10 ;
  OPJ_BOOL __cil_tmp21___6 ;
  OPJ_OFF_T __cil_tmp22___8 ;
  OPJ_BOOL __cil_tmp23___8 ;
  OPJ_BOOL __cil_tmp24___4 ;

  {
  {
#line 9273
  *p_correction_needed = 0;
#line 9275
  __cil_tmp13___22 = opj_stream_has_seek(p_stream___52);
  }
#line 9275
  if (! __cil_tmp13___22) {
#line 9277
    return (1);
  }
  {
#line 9280
  l_stream_pos_backup = opj_stream_tell(p_stream___52);
  }
#line 9281
  if (l_stream_pos_backup == -1L) {
#line 9283
    return (1);
  }
  {
#line 9286
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 9288
    __cil_tmp15___19 = opj_stream_read_data(p_stream___52, l_header_data, (OPJ_SIZE_T )2,
                                            p_manager___114);
    }
#line 9288
    if (__cil_tmp15___19 != 2UL) {
      {
#line 9290
      __cil_tmp16___15 = opj_stream_seek(p_stream___52, l_stream_pos_backup, p_manager___114);
      }
#line 9290
      if (! __cil_tmp16___15) {
#line 9291
        return (0);
      }
#line 9293
      return (1);
    }
    {
#line 9297
    opj_read_bytes_LE(l_header_data, & l_current_marker___0, (OPJ_UINT32 )2);
    }
#line 9299
    if (l_current_marker___0 != 65424U) {
      {
#line 9301
      __cil_tmp17___14 = opj_stream_seek(p_stream___52, l_stream_pos_backup, p_manager___114);
      }
#line 9301
      if (! __cil_tmp17___14) {
#line 9302
        return (0);
      }
#line 9304
      return (1);
    }
    {
#line 9308
    __cil_tmp18___8 = opj_stream_read_data(p_stream___52, l_header_data, (OPJ_SIZE_T )2,
                                           p_manager___114);
    }
#line 9308
    if (__cil_tmp18___8 != 2UL) {
      {
#line 9309
      opj_event_msg(p_manager___114, 1, "Stream too short\n");
      }
#line 9310
      return (0);
    }
    {
#line 9314
    opj_read_bytes_LE(l_header_data, & l_marker_size___0, (OPJ_UINT32 )2);
    }
#line 9317
    if (l_marker_size___0 != 10U) {
      {
#line 9318
      opj_event_msg(p_manager___114, 1, "Inconsistent marker size\n");
      }
#line 9319
      return (0);
    }
    {
#line 9321
    l_marker_size___0 -= 2U;
#line 9323
    __cil_tmp19___10 = opj_stream_read_data(p_stream___52, l_header_data, (OPJ_SIZE_T )l_marker_size___0,
                                            p_manager___114);
    }
#line 9323
    if (__cil_tmp19___10 != (unsigned long )l_marker_size___0) {
      {
#line 9325
      opj_event_msg(p_manager___114, 1, "Stream too short\n");
      }
#line 9326
      return (0);
    }
    {
#line 9329
    __cil_tmp20___10 = opj_j2k_get_sot_values(l_header_data, l_marker_size___0, & l_tile_no,
                                              & l_tot_len___0, & l_current_part___0,
                                              & l_num_parts___0, p_manager___114);
    }
#line 9329
    if (! __cil_tmp20___10) {
#line 9331
      return (0);
    }
#line 9334
    if (l_tile_no == tile_no) {
#line 9336
      goto while_break;
    }
#line 9339
    if (l_tot_len___0 < 14U) {
      {
#line 9342
      __cil_tmp21___6 = opj_stream_seek(p_stream___52, l_stream_pos_backup, p_manager___114);
      }
#line 9342
      if (! __cil_tmp21___6) {
#line 9343
        return (0);
      }
#line 9345
      return (1);
    }
    {
#line 9347
    l_tot_len___0 -= 12U;
#line 9349
    __cil_tmp22___8 = opj_stream_skip(p_stream___52, (OPJ_OFF_T )l_tot_len___0, p_manager___114);
    }
#line 9349
    if (__cil_tmp22___8 != (OPJ_OFF_T )l_tot_len___0) {
      {
#line 9352
      __cil_tmp23___8 = opj_stream_seek(p_stream___52, l_stream_pos_backup, p_manager___114);
      }
#line 9352
      if (! __cil_tmp23___8) {
#line 9353
        return (0);
      }
#line 9355
      return (1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 9360
  if (l_current_part___0 == l_num_parts___0) {
#line 9361
    *p_correction_needed = 1;
  }
  {
#line 9364
  __cil_tmp24___4 = opj_stream_seek(p_stream___52, l_stream_pos_backup, p_manager___114);
  }
#line 9364
  if (! __cil_tmp24___4) {
#line 9365
    return (0);
  }
#line 9367
  return (1);
}
}
#line 9370 "/root/patron-new/39/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_read_tile_header(opj_j2k_t *p_j2k___72 , OPJ_UINT32 *p_tile_index___5 ,
                                  OPJ_UINT32 *p_data_size___5 , OPJ_INT32 *p_tile_x0___1 ,
                                  OPJ_INT32 *p_tile_y0___1 , OPJ_INT32 *p_tile_x1___1 ,
                                  OPJ_INT32 *p_tile_y1___1 , OPJ_UINT32 *p_nb_comps___1 ,
                                  OPJ_BOOL *p_go_on___0 , opj_stream_private_t *p_stream___53 ,
                                  opj_event_mgr_t *p_manager___115 ) 
{ 
  OPJ_UINT32 l_current_marker___1 ;
  OPJ_UINT32 l_marker_size___1 ;
  opj_dec_memory_marker_handler_t *l_marker_handler___1 ;
  opj_tcp_t *l_tcp___22 ;
  OPJ_OFF_T __cil_tmp19___11 ;
  OPJ_SIZE_T __cil_tmp20___11 ;
  OPJ_OFF_T __cil_tmp21___7 ;
  OPJ_BYTE *new_header_data___0 ;
  OPJ_OFF_T __cil_tmp24___5 ;
  void *__cil_tmp25___5 ;
  OPJ_SIZE_T __cil_tmp26___4 ;
  OPJ_BOOL __cil_tmp27___3 ;
  OPJ_OFF_T __cil_tmp28___3 ;
  OPJ_BOOL __cil_tmp29___2 ;
  OPJ_UINT32 sot_pos ;
  OPJ_OFF_T __cil_tmp31___1 ;
  OPJ_OFF_T __cil_tmp32___2 ;
  OPJ_SIZE_T __cil_tmp33___1 ;
  OPJ_OFF_T __cil_tmp34___2 ;
  OPJ_BOOL __cil_tmp35___2 ;
  OPJ_BOOL l_correction_needed ;
  OPJ_BOOL __cil_tmp37___0 ;
  OPJ_UINT32 l_nb_tiles___7 ;
  OPJ_UINT32 l_tile_no___0 ;
  OPJ_SIZE_T __cil_tmp40 ;
  OPJ_SIZE_T __cil_tmp41___0 ;
  OPJ_UINT32 l_nb_tiles___8 ;
  OPJ_BOOL __cil_tmp43___0 ;
  OPJ_BOOL __cil_tmp44___0 ;

  {
#line 9380
  l_current_marker___1 = (OPJ_UINT32 )65424;
#line 9382
  l_marker_handler___1 = (opj_dec_memory_marker_handler_t *)0;
#line 9383
  l_tcp___22 = (opj_tcp_t *)((void *)0);
#line 9391
  if (p_j2k___72->m_specific_param.m_decoder.m_state == 256U) {
#line 9392
    l_current_marker___1 = (OPJ_UINT32 )65497;
  } else
#line 9395
  if (p_j2k___72->m_specific_param.m_decoder.m_state != 8U) {
#line 9396
    return (0);
  }
  {
#line 9400
  while (1) {
    while_continue: /* CIL Label */ ;

#line 9400
    if (! p_j2k___72->m_specific_param.m_decoder.m_can_decode) {
#line 9400
      if (! (l_current_marker___1 != 65497U)) {
#line 9400
        goto while_break;
      }
    } else {
#line 9400
      goto while_break;
    }
    {
#line 9404
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 9404
      if (! (l_current_marker___1 != 65427U)) {
#line 9404
        goto while_break___0;
      }
      {
#line 9406
      __cil_tmp19___11 = opj_stream_get_number_byte_left(p_stream___53);
      }
#line 9406
      if (__cil_tmp19___11 == 0L) {
#line 9407
        p_j2k___72->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )64;
#line 9408
        goto while_break___0;
      }
      {
#line 9412
      __cil_tmp20___11 = opj_stream_read_data(p_stream___53, p_j2k___72->m_specific_param.m_decoder.m_header_data,
                                              (OPJ_SIZE_T )2, p_manager___115);
      }
#line 9412
      if (__cil_tmp20___11 != 2UL) {
        {
#line 9414
        opj_event_msg(p_manager___115, 1, "Stream too short\n");
        }
#line 9415
        return (0);
      }
      {
#line 9419
      opj_read_bytes_LE(p_j2k___72->m_specific_param.m_decoder.m_header_data, & l_marker_size___1,
                        (OPJ_UINT32 )2);
      }
#line 9423
      if (l_marker_size___1 < 2U) {
        {
#line 9424
        opj_event_msg(p_manager___115, 1, "Inconsistent marker size\n");
        }
#line 9425
        return (0);
      }
      {
#line 9429
      __cil_tmp21___7 = opj_stream_get_number_byte_left(p_stream___53);
      }
#line 9429
      if (l_current_marker___1 == 32896U) {
#line 9429
        if (__cil_tmp21___7 == 0L) {
#line 9431
          p_j2k___72->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )64;
#line 9432
          goto while_break___0;
        }
      }
#line 9436
      if (p_j2k___72->m_specific_param.m_decoder.m_state & 16U) {
#line 9437
        p_j2k___72->m_specific_param.m_decoder.m_sot_length -= l_marker_size___1 + 2U;
      }
      {
#line 9439
      l_marker_size___1 -= 2U;
#line 9442
      l_marker_handler___1 = opj_j2k_get_marker_handler(l_current_marker___1);
      }
#line 9445
      if (! (p_j2k___72->m_specific_param.m_decoder.m_state & l_marker_handler___1->states)) {
        {
#line 9446
        opj_event_msg(p_manager___115, 1, "Marker is not compliant with its position\n\243\005]U");
        }
#line 9448
        return (0);
      }
#line 9453
      if (l_marker_size___1 > p_j2k___72->m_specific_param.m_decoder.m_header_data_size) {
        {
#line 9454
        new_header_data___0 = (OPJ_BYTE *)((void *)0);
#line 9457
        __cil_tmp24___5 = opj_stream_get_number_byte_left(p_stream___53);
        }
#line 9457
        if ((OPJ_OFF_T )l_marker_size___1 > __cil_tmp24___5) {
          {
#line 9458
          opj_event_msg(p_manager___115, 1, "Marker size inconsistent with stream length\n");
          }
#line 9460
          return (0);
        }
        {
#line 9462
        __cil_tmp25___5 = opj_realloc((void *)p_j2k___72->m_specific_param.m_decoder.m_header_data,
                                      (size_t )l_marker_size___1);
#line 9462
        new_header_data___0 = (OPJ_BYTE *)__cil_tmp25___5;
        }
#line 9464
        if (! new_header_data___0) {
          {
#line 9465
          opj_free((void *)p_j2k___72->m_specific_param.m_decoder.m_header_data);
#line 9466
          p_j2k___72->m_specific_param.m_decoder.m_header_data = (OPJ_BYTE *)((void *)0);
#line 9467
          p_j2k___72->m_specific_param.m_decoder.m_header_data_size = (OPJ_UINT32 )0;
#line 9468
          opj_event_msg(p_manager___115, 1, "Not enough memory to read header\n\366\243\005]U");
          }
#line 9469
          return (0);
        }
#line 9471
        p_j2k___72->m_specific_param.m_decoder.m_header_data = new_header_data___0;
#line 9472
        p_j2k___72->m_specific_param.m_decoder.m_header_data_size = l_marker_size___1;
      }
      {
#line 9476
      __cil_tmp26___4 = opj_stream_read_data(p_stream___53, p_j2k___72->m_specific_param.m_decoder.m_header_data,
                                             (OPJ_SIZE_T )l_marker_size___1, p_manager___115);
      }
#line 9476
      if (__cil_tmp26___4 != (unsigned long )l_marker_size___1) {
        {
#line 9479
        opj_event_msg(p_manager___115, 1, "Stream too short\n");
        }
#line 9480
        return (0);
      }
#line 9483
      if (! l_marker_handler___1->handler) {
        {
#line 9485
        opj_event_msg(p_manager___115, 1, "Not sure how that happened.\n");
        }
#line 9486
        return (0);
      }
      {
#line 9489
      __cil_tmp27___3 = (*(l_marker_handler___1->handler))(p_j2k___72, p_j2k___72->m_specific_param.m_decoder.m_header_data,
                                                           l_marker_size___1, p_manager___115);
      }
#line 9489
      if (! __cil_tmp27___3) {
        {
#line 9491
        opj_event_msg(p_manager___115, 1, "Fail to read the current marker segment (%#x)\n",
                      l_current_marker___1);
        }
#line 9493
        return (0);
      }
      {
#line 9497
      __cil_tmp28___3 = opj_stream_tell(p_stream___53);
#line 9497
      __cil_tmp29___2 = opj_j2k_add_tlmarker(p_j2k___72->m_current_tile_number, p_j2k___72->cstr_index,
                                             l_marker_handler___1->id, (OPJ_OFF_T )(((OPJ_UINT32 )__cil_tmp28___3 - l_marker_size___1) - 4U),
                                             l_marker_size___1 + 4U);
      }
#line 9497
      if (0 == __cil_tmp29___2) {
        {
#line 9502
        opj_event_msg(p_manager___115, 1, "Not enough memory to add tl marker\n");
        }
#line 9503
        return (0);
      }
#line 9507
      if (l_marker_handler___1->id == 65424U) {
        {
#line 9508
        __cil_tmp31___1 = opj_stream_tell(p_stream___53);
#line 9508
        sot_pos = ((OPJ_UINT32 )__cil_tmp31___1 - l_marker_size___1) - 4U;
        }
#line 9510
        if ((long )sot_pos > p_j2k___72->m_specific_param.m_decoder.m_last_sot_read_pos) {
#line 9511
          p_j2k___72->m_specific_param.m_decoder.m_last_sot_read_pos = (OPJ_OFF_T )sot_pos;
        }
      }
#line 9515
      if (p_j2k___72->m_specific_param.m_decoder.m_skip_data) {
        {
#line 9517
        __cil_tmp32___2 = opj_stream_skip(p_stream___53, (OPJ_OFF_T )p_j2k___72->m_specific_param.m_decoder.m_sot_length,
                                          p_manager___115);
        }
#line 9517
        if (__cil_tmp32___2 != (long )p_j2k___72->m_specific_param.m_decoder.m_sot_length) {
          {
#line 9519
          opj_event_msg(p_manager___115, 1, "Stream too short\n");
          }
#line 9520
          return (0);
        }
#line 9522
        l_current_marker___1 = (OPJ_UINT32 )65427;
      } else {
        {
#line 9525
        __cil_tmp33___1 = opj_stream_read_data(p_stream___53, p_j2k___72->m_specific_param.m_decoder.m_header_data,
                                               (OPJ_SIZE_T )2, p_manager___115);
        }
#line 9525
        if (__cil_tmp33___1 != 2UL) {
          {
#line 9527
          opj_event_msg(p_manager___115, 1, "Stream too short\n");
          }
#line 9528
          return (0);
        }
        {
#line 9531
        opj_read_bytes_LE(p_j2k___72->m_specific_param.m_decoder.m_header_data, & l_current_marker___1,
                          (OPJ_UINT32 )2);
        }
      }
    }
    while_break___4: /* CIL Label */ ;
    }

    while_break___0: 
    {
#line 9535
    __cil_tmp34___2 = opj_stream_get_number_byte_left(p_stream___53);
    }
#line 9535
    if (__cil_tmp34___2 == 0L) {
#line 9535
      if (p_j2k___72->m_specific_param.m_decoder.m_state == 64U) {
#line 9537
        goto while_break;
      }
    }
#line 9541
    if (! p_j2k___72->m_specific_param.m_decoder.m_skip_data) {
      {
#line 9543
      __cil_tmp35___2 = opj_j2k_read_sod(p_j2k___72, p_stream___53, p_manager___115);
      }
#line 9543
      if (! __cil_tmp35___2) {
#line 9544
        return (0);
      }
#line 9546
      if ((int )p_j2k___72->m_specific_param.m_decoder.m_can_decode) {
#line 9546
        if (! p_j2k___72->m_specific_param.m_decoder.m_nb_tile_parts_correction_checked) {
          {
#line 9551
          p_j2k___72->m_specific_param.m_decoder.m_nb_tile_parts_correction_checked = (OPJ_BITFIELD )1;
#line 9552
          __cil_tmp37___0 = opj_j2k_need_nb_tile_parts_correction(p_stream___53, p_j2k___72->m_current_tile_number,
                                                                  & l_correction_needed,
                                                                  p_manager___115);
          }
#line 9552
          if (! __cil_tmp37___0) {
            {
#line 9554
            opj_event_msg(p_manager___115, 1, "opj_j2k_apply_nb_tile_parts_correction error\n");
            }
#line 9556
            return (0);
          }
#line 9558
          if (l_correction_needed) {
#line 9559
            l_nb_tiles___7 = p_j2k___72->m_cp.tw * p_j2k___72->m_cp.th;
#line 9562
            p_j2k___72->m_specific_param.m_decoder.m_can_decode = (OPJ_BITFIELD )0;
#line 9563
            p_j2k___72->m_specific_param.m_decoder.m_nb_tile_parts_correction = (OPJ_BITFIELD )1;
#line 9565
            l_tile_no___0 = 0U;
            {
#line 9565
            while (1) {
              while_continue___1: /* CIL Label */ ;

#line 9565
              if (! (l_tile_no___0 < l_nb_tiles___7)) {
#line 9565
                goto while_break___1;
              }
#line 9566
              if ((p_j2k___72->m_cp.tcps + l_tile_no___0)->m_nb_tile_parts != 0U) {
#line 9567
                ((p_j2k___72->m_cp.tcps + l_tile_no___0)->m_nb_tile_parts) ++;
              }
#line 9565
              l_tile_no___0 ++;
            }
            while_break___5: /* CIL Label */ ;
            }

            while_break___1: 
            {
#line 9570
            opj_event_msg(p_manager___115, 2, "Non conformant codestream TPsot==TNsot.\n\220");
            }
          }
        }
      }
#line 9574
      if (! p_j2k___72->m_specific_param.m_decoder.m_can_decode) {
        {
#line 9576
        __cil_tmp40 = opj_stream_read_data(p_stream___53, p_j2k___72->m_specific_param.m_decoder.m_header_data,
                                           (OPJ_SIZE_T )2, p_manager___115);
        }
#line 9576
        if (__cil_tmp40 != 2UL) {
          {
#line 9578
          opj_event_msg(p_manager___115, 1, "Stream too short\n");
          }
#line 9579
          return (0);
        }
        {
#line 9583
        opj_read_bytes_LE(p_j2k___72->m_specific_param.m_decoder.m_header_data, & l_current_marker___1,
                          (OPJ_UINT32 )2);
        }
      }
    } else {
      {
#line 9588
      p_j2k___72->m_specific_param.m_decoder.m_skip_data = (OPJ_BITFIELD )0;
#line 9589
      p_j2k___72->m_specific_param.m_decoder.m_can_decode = (OPJ_BITFIELD )0;
#line 9590
      p_j2k___72->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )8;
#line 9593
      __cil_tmp41___0 = opj_stream_read_data(p_stream___53, p_j2k___72->m_specific_param.m_decoder.m_header_data,
                                             (OPJ_SIZE_T )2, p_manager___115);
      }
#line 9593
      if (__cil_tmp41___0 != 2UL) {
        {
#line 9595
        opj_event_msg(p_manager___115, 1, "Stream too short\n");
        }
#line 9596
        return (0);
      }
      {
#line 9600
      opj_read_bytes_LE(p_j2k___72->m_specific_param.m_decoder.m_header_data, & l_current_marker___1,
                        (OPJ_UINT32 )2);
      }
    }
  }
  while_break___3: /* CIL Label */ ;
  }

  while_break: ;
#line 9606
  if (l_current_marker___1 == 65497U) {
#line 9607
    if (p_j2k___72->m_specific_param.m_decoder.m_state != 256U) {
#line 9608
      p_j2k___72->m_current_tile_number = (OPJ_UINT32 )0;
#line 9609
      p_j2k___72->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )256;
    }
  }
#line 9614
  if (! p_j2k___72->m_specific_param.m_decoder.m_can_decode) {
#line 9615
    l_nb_tiles___8 = p_j2k___72->m_cp.th * p_j2k___72->m_cp.tw;
#line 9616
    l_tcp___22 = p_j2k___72->m_cp.tcps + p_j2k___72->m_current_tile_number;
    {
#line 9618
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 9618
      if ((unsigned long )l_tcp___22->m_data == (unsigned long )((OPJ_BYTE *)0)) {
#line 9618
        if (! (p_j2k___72->m_current_tile_number < l_nb_tiles___8)) {
#line 9618
          goto while_break___2;
        }
      } else {
#line 9618
        goto while_break___2;
      }
#line 9619
      (p_j2k___72->m_current_tile_number) ++;
#line 9620
      l_tcp___22 ++;
    }
    while_break___6: /* CIL Label */ ;
    }

    while_break___2: ;
#line 9623
    if (p_j2k___72->m_current_tile_number == l_nb_tiles___8) {
#line 9624
      *p_go_on___0 = 0;
#line 9625
      return (1);
    }
  }
  {
#line 9629
  __cil_tmp43___0 = opj_j2k_merge_ppt(p_j2k___72->m_cp.tcps + p_j2k___72->m_current_tile_number,
                                      p_manager___115);
  }
#line 9629
  if (! __cil_tmp43___0) {
    {
#line 9631
    opj_event_msg(p_manager___115, 1, "Failed to merge PPT data\n");
    }
#line 9632
    return (0);
  }
  {
#line 9635
  __cil_tmp44___0 = opj_tcd_init_decode_tile(p_j2k___72->m_tcd, p_j2k___72->m_current_tile_number,
                                             p_manager___115);
  }
#line 9635
  if (! __cil_tmp44___0) {
    {
#line 9637
    opj_event_msg(p_manager___115, 1, "Cannot decode tile, memory error\n");
    }
#line 9638
    return (0);
  }
  {
#line 9641
  opj_event_msg(p_manager___115, 4, "Header of tile %d / %d has been read.\n", p_j2k___72->m_current_tile_number + 1U,
                p_j2k___72->m_cp.th * p_j2k___72->m_cp.tw);
#line 9644
  *p_tile_index___5 = p_j2k___72->m_current_tile_number;
#line 9645
  *p_go_on___0 = 1;
  }
#line 9646
  if (p_data_size___5) {
    {
#line 9649
    *p_data_size___5 = opj_tcd_get_decoded_tile_size(p_j2k___72->m_tcd, 0);
    }
#line 9650
    if (*p_data_size___5 == 4294967295U) {
#line 9651
      return (0);
    }
  }
#line 9654
  *p_tile_x0___1 = (((p_j2k___72->m_tcd)->tcd_image)->tiles)->x0;
#line 9655
  *p_tile_y0___1 = (((p_j2k___72->m_tcd)->tcd_image)->tiles)->y0;
#line 9656
  *p_tile_x1___1 = (((p_j2k___72->m_tcd)->tcd_image)->tiles)->x1;
#line 9657
  *p_tile_y1___1 = (((p_j2k___72->m_tcd)->tcd_image)->tiles)->y1;
#line 9658
  *p_nb_comps___1 = (((p_j2k___72->m_tcd)->tcd_image)->tiles)->numcomps;
#line 9660
  p_j2k___72->m_specific_param.m_decoder.m_state |= 128U;
#line 9662
  return (1);
}
}
#line 9665 "/root/patron-new/39/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_decode_tile(opj_j2k_t *p_j2k___73 , OPJ_UINT32 p_tile_index___6 ,
                             OPJ_BYTE *p_data___10 , OPJ_UINT32 p_data_size___6 ,
                             opj_stream_private_t *p_stream___54 , opj_event_mgr_t *p_manager___116 ) 
{ 
  OPJ_UINT32 l_current_marker___2 ;
  OPJ_BYTE l_data___3[2] ;
  opj_tcp_t *l_tcp___23 ;
  opj_image_t *l_image_for_bounds ;
  opj_image_t *tmp___360 ;
  OPJ_BOOL __cil_tmp15___20 ;
  OPJ_BOOL __cil_tmp16___16 ;
  OPJ_OFF_T __cil_tmp17___15 ;
  OPJ_SIZE_T __cil_tmp18___9 ;
  OPJ_OFF_T __cil_tmp19___12 ;

  {
#line 9682
  if (! (p_j2k___73->m_specific_param.m_decoder.m_state & 128U)) {
#line 9684
    return (0);
  } else
#line 9682
  if (p_tile_index___6 != p_j2k___73->m_current_tile_number) {
#line 9684
    return (0);
  }
#line 9687
  l_tcp___23 = p_j2k___73->m_cp.tcps + p_tile_index___6;
#line 9688
  if (! l_tcp___23->m_data) {
    {
#line 9689
    opj_j2k_tcp_destroy(l_tcp___23);
    }
#line 9690
    return (0);
  }
#line 9698
  if (p_j2k___73->m_output_image) {
#line 9698
    tmp___360 = p_j2k___73->m_output_image;
  } else {
#line 9698
    tmp___360 = p_j2k___73->m_private_image;
  }
  {
#line 9698
  l_image_for_bounds = tmp___360;
#line 9700
  __cil_tmp15___20 = opj_tcd_decode_tile(p_j2k___73->m_tcd, l_image_for_bounds->x0,
                                         l_image_for_bounds->y0, l_image_for_bounds->x1,
                                         l_image_for_bounds->y1, p_j2k___73->m_specific_param.m_decoder.m_numcomps_to_decode,
                                         p_j2k___73->m_specific_param.m_decoder.m_comps_indices_to_decode,
                                         l_tcp___23->m_data, l_tcp___23->m_data_size,
                                         p_tile_index___6, p_j2k___73->cstr_index,
                                         p_manager___116);
  }
#line 9700
  if (! __cil_tmp15___20) {
    {
#line 9711
    opj_j2k_tcp_destroy(l_tcp___23);
#line 9712
    p_j2k___73->m_specific_param.m_decoder.m_state |= 32768U;
#line 9713
    opj_event_msg(p_manager___116, 1, "Failed to decode.\n");
    }
#line 9714
    return (0);
  }
#line 9720
  if ((unsigned long )p_data___10 != (unsigned long )((void *)0)) {
    {
#line 9721
    __cil_tmp16___16 = opj_tcd_update_tile_data(p_j2k___73->m_tcd, p_data___10, p_data_size___6);
    }
#line 9721
    if (! __cil_tmp16___16) {
#line 9722
      return (0);
    }
    {
#line 9729
    opj_j2k_tcp_data_destroy(l_tcp___23);
    }
  }
  {
#line 9732
  p_j2k___73->m_specific_param.m_decoder.m_can_decode = (OPJ_BITFIELD )0;
#line 9733
  p_j2k___73->m_specific_param.m_decoder.m_state &= 4294967167U;
#line 9735
  __cil_tmp17___15 = opj_stream_get_number_byte_left(p_stream___54);
  }
#line 9735
  if (__cil_tmp17___15 == 0L) {
#line 9735
    if (p_j2k___73->m_specific_param.m_decoder.m_state == 64U) {
#line 9737
      return (1);
    }
  }
#line 9740
  if (p_j2k___73->m_specific_param.m_decoder.m_state != 256U) {
    {
#line 9741
    __cil_tmp18___9 = opj_stream_read_data(p_stream___54, l_data___3, (OPJ_SIZE_T )2,
                                           p_manager___116);
    }
#line 9741
    if (__cil_tmp18___9 != 2UL) {
      {
#line 9742
      opj_event_msg(p_manager___116, 1, "Stream too short\n\020\245\005]U");
      }
#line 9743
      return (0);
    }
    {
#line 9746
    opj_read_bytes_LE(l_data___3, & l_current_marker___2, (OPJ_UINT32 )2);
    }
#line 9748
    if (l_current_marker___2 == 65497U) {
#line 9749
      p_j2k___73->m_current_tile_number = (OPJ_UINT32 )0;
#line 9750
      p_j2k___73->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )256;
    } else
#line 9751
    if (l_current_marker___2 != 65424U) {
      {
#line 9752
      __cil_tmp19___12 = opj_stream_get_number_byte_left(p_stream___54);
      }
#line 9752
      if (__cil_tmp19___12 == 0L) {
        {
#line 9753
        p_j2k___73->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )64;
#line 9754
        opj_event_msg(p_manager___116, 2, "Stream does not end with EOC\n");
        }
#line 9755
        return (1);
      }
      {
#line 9757
      opj_event_msg(p_manager___116, 1, "Stream too short, expected SOT\n");
      }
#line 9758
      return (0);
    }
  }
#line 9762
  return (1);
}
}
#line 9765 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_update_image_data(opj_tcd_t *p_tcd , opj_image_t *p_output_image ) 
{ 
  OPJ_UINT32 i___70 ;
  OPJ_UINT32 j___8 ;
  OPJ_UINT32 l_width_src ;
  OPJ_UINT32 l_height_src ;
  OPJ_UINT32 l_width_dest ;
  OPJ_UINT32 l_height_dest ;
  OPJ_INT32 l_offset_x0_src ;
  OPJ_INT32 l_offset_y0_src ;
  OPJ_INT32 l_offset_x1_src ;
  OPJ_INT32 l_offset_y1_src ;
  OPJ_SIZE_T l_start_offset_src ;
  OPJ_UINT32 l_start_x_dest ;
  OPJ_UINT32 l_start_y_dest ;
  OPJ_UINT32 l_x0_dest ;
  OPJ_UINT32 l_y0_dest ;
  OPJ_UINT32 l_x1_dest ;
  OPJ_UINT32 l_y1_dest ;
  OPJ_SIZE_T l_start_offset_dest ;
  opj_image_comp_t *l_img_comp_src ;
  opj_image_comp_t *l_img_comp_dest ;
  opj_tcd_tilecomp_t *l_tilec ;
  opj_image_t *l_image_src ;
  OPJ_INT32 *l_dest_ptr ;
  OPJ_INT32 res_x0 ;
  OPJ_INT32 res_x1 ;
  OPJ_INT32 res_y0 ;
  OPJ_INT32 res_y1 ;
  OPJ_UINT32 src_data_stride ;
  OPJ_INT32 *p_src_data___11 ;
  opj_tcd_resolution_t *l_res ;
  opj_tcd_resolution_t *l_res___0 ;
  OPJ_SIZE_T l_width ;
  OPJ_SIZE_T l_height ;
  void *__cil_tmp40___0 ;
  OPJ_INT32 *l_src_ptr ;
  OPJ_UINT32 __cil_tmp42 ;

  {
#line 9777
  l_img_comp_src = (opj_image_comp_t *)0;
#line 9778
  l_img_comp_dest = (opj_image_comp_t *)0;
#line 9780
  l_tilec = (opj_tcd_tilecomp_t *)0;
#line 9781
  l_image_src = (opj_image_t *)0;
#line 9784
  l_tilec = ((p_tcd->tcd_image)->tiles)->comps;
#line 9785
  l_image_src = p_tcd->image;
#line 9786
  l_img_comp_src = l_image_src->comps;
#line 9788
  l_img_comp_dest = p_output_image->comps;
#line 9790
  i___70 = (OPJ_UINT32 )0;
  {
#line 9790
  while (1) {
    while_continue___0: /* CIL Label */ ;

    while_continue: ;
#line 9790
    if (! (i___70 < l_image_src->numcomps)) {
#line 9790
      goto while_break;
    }
#line 9797
    l_img_comp_dest->resno_decoded = l_img_comp_src->resno_decoded;
#line 9799
    if (p_tcd->whole_tile_decoding) {
#line 9800
      l_res = l_tilec->resolutions + l_img_comp_src->resno_decoded;
#line 9802
      res_x0 = l_res->x0;
#line 9803
      res_y0 = l_res->y0;
#line 9804
      res_x1 = l_res->x1;
#line 9805
      res_y1 = l_res->y1;
#line 9806
      src_data_stride = (OPJ_UINT32 )((l_tilec->resolutions + (l_tilec->minimum_num_resolutions - 1U))->x1 - (l_tilec->resolutions + (l_tilec->minimum_num_resolutions - 1U))->x0);
#line 9809
      p_src_data___11 = l_tilec->data;
    } else {
#line 9811
      l_res___0 = l_tilec->resolutions + l_img_comp_src->resno_decoded;
#line 9813
      res_x0 = (OPJ_INT32 )l_res___0->win_x0;
#line 9814
      res_y0 = (OPJ_INT32 )l_res___0->win_y0;
#line 9815
      res_x1 = (OPJ_INT32 )l_res___0->win_x1;
#line 9816
      res_y1 = (OPJ_INT32 )l_res___0->win_y1;
#line 9817
      src_data_stride = l_res___0->win_x1 - l_res___0->win_x0;
#line 9818
      p_src_data___11 = l_tilec->data_win;
    }
#line 9821
    if ((unsigned long )p_src_data___11 == (unsigned long )((void *)0)) {
#line 9823
      goto while_continue;
    }
    {
#line 9826
    l_width_src = (OPJ_UINT32 )(res_x1 - res_x0);
#line 9827
    l_height_src = (OPJ_UINT32 )(res_y1 - res_y0);
#line 9838
    l_x0_dest = opj_uint_ceildivpow2(l_img_comp_dest->x0, l_img_comp_dest->factor);
#line 9839
    l_y0_dest = opj_uint_ceildivpow2(l_img_comp_dest->y0, l_img_comp_dest->factor);
#line 9840
    l_x1_dest = l_x0_dest + l_img_comp_dest->w;
#line 9842
    l_y1_dest = l_y0_dest + l_img_comp_dest->h;
    }
#line 9858
    if (l_x0_dest < (OPJ_UINT32 )res_x0) {
#line 9859
      l_start_x_dest = (OPJ_UINT32 )res_x0 - l_x0_dest;
#line 9860
      l_offset_x0_src = 0;
#line 9862
      if (l_x1_dest >= (OPJ_UINT32 )res_x1) {
#line 9863
        l_width_dest = l_width_src;
#line 9864
        l_offset_x1_src = 0;
      } else {
#line 9866
        l_width_dest = l_x1_dest - (OPJ_UINT32 )res_x0;
#line 9867
        l_offset_x1_src = (OPJ_INT32 )(l_width_src - l_width_dest);
      }
    } else {
#line 9870
      l_start_x_dest = 0U;
#line 9871
      l_offset_x0_src = (OPJ_INT32 )l_x0_dest - res_x0;
#line 9873
      if (l_x1_dest >= (OPJ_UINT32 )res_x1) {
#line 9874
        l_width_dest = l_width_src - (OPJ_UINT32 )l_offset_x0_src;
#line 9875
        l_offset_x1_src = 0;
      } else {
#line 9877
        l_width_dest = l_img_comp_dest->w;
#line 9878
        l_offset_x1_src = res_x1 - (OPJ_INT32 )l_x1_dest;
      }
    }
#line 9882
    if (l_y0_dest < (OPJ_UINT32 )res_y0) {
#line 9883
      l_start_y_dest = (OPJ_UINT32 )res_y0 - l_y0_dest;
#line 9884
      l_offset_y0_src = 0;
#line 9886
      if (l_y1_dest >= (OPJ_UINT32 )res_y1) {
#line 9887
        l_height_dest = l_height_src;
#line 9888
        l_offset_y1_src = 0;
      } else {
#line 9890
        l_height_dest = l_y1_dest - (OPJ_UINT32 )res_y0;
#line 9891
        l_offset_y1_src = (OPJ_INT32 )(l_height_src - l_height_dest);
      }
    } else {
#line 9894
      l_start_y_dest = 0U;
#line 9895
      l_offset_y0_src = (OPJ_INT32 )l_y0_dest - res_y0;
#line 9897
      if (l_y1_dest >= (OPJ_UINT32 )res_y1) {
#line 9898
        l_height_dest = l_height_src - (OPJ_UINT32 )l_offset_y0_src;
#line 9899
        l_offset_y1_src = 0;
      } else {
#line 9901
        l_height_dest = l_img_comp_dest->h;
#line 9902
        l_offset_y1_src = res_y1 - (OPJ_INT32 )l_y1_dest;
      }
    }
#line 9906
    if (l_offset_x0_src < 0) {
#line 9908
      return (0);
    } else
#line 9906
    if (l_offset_y0_src < 0) {
#line 9908
      return (0);
    } else
#line 9906
    if (l_offset_x1_src < 0) {
#line 9908
      return (0);
    } else
#line 9906
    if (l_offset_y1_src < 0) {
#line 9908
      return (0);
    }
#line 9911
    if ((OPJ_INT32 )l_width_dest < 0) {
#line 9912
      return (0);
    } else
#line 9911
    if ((OPJ_INT32 )l_height_dest < 0) {
#line 9912
      return (0);
    }
#line 9917
    l_start_offset_src = (OPJ_SIZE_T )l_offset_x0_src + (OPJ_SIZE_T )l_offset_y0_src * (OPJ_SIZE_T )src_data_stride;
#line 9921
    l_start_offset_dest = (OPJ_SIZE_T )l_start_x_dest + (OPJ_SIZE_T )l_start_y_dest * (OPJ_SIZE_T )l_img_comp_dest->w;
#line 9925
    if ((unsigned long )l_img_comp_dest->data == (unsigned long )((void *)0)) {
#line 9925
      if (l_start_offset_src == 0UL) {
#line 9925
        if (l_start_offset_dest == 0UL) {
#line 9925
          if (src_data_stride == l_img_comp_dest->w) {
#line 9925
            if (l_width_dest == l_img_comp_dest->w) {
#line 9925
              if (l_height_dest == l_img_comp_dest->h) {
#line 9932
                if (p_tcd->whole_tile_decoding) {
#line 9933
                  l_img_comp_dest->data = l_tilec->data;
#line 9934
                  l_tilec->data = (OPJ_INT32 *)((void *)0);
                } else {
#line 9936
                  l_img_comp_dest->data = l_tilec->data_win;
#line 9937
                  l_tilec->data_win = (OPJ_INT32 *)((void *)0);
                }
#line 9939
                goto while_continue;
              } else {
#line 9925
                goto _L;
              }
            } else {
#line 9925
              goto _L;
            }
          } else {
#line 9925
            goto _L;
          }
        } else {
#line 9925
          goto _L;
        }
      } else {
#line 9925
        goto _L;
      }
    } else
    _L: 
#line 9940
    if ((unsigned long )l_img_comp_dest->data == (unsigned long )((void *)0)) {
#line 9941
      l_width = (OPJ_SIZE_T )l_img_comp_dest->w;
#line 9942
      l_height = (OPJ_SIZE_T )l_img_comp_dest->h;
#line 9944
      if (l_height == 0UL) {
#line 9947
        return (0);
      } else
#line 9944
      if (l_width > 0xffffffffffffffffUL / l_height) {
#line 9947
        return (0);
      } else
#line 9944
      if (l_width * l_height > 0xffffffffffffffffUL / sizeof(OPJ_INT32 )) {
#line 9947
        return (0);
      }
      {
#line 9949
      __cil_tmp40___0 = opj_image_data_alloc((l_width * l_height) * sizeof(OPJ_INT32 ));
#line 9949
      l_img_comp_dest->data = (OPJ_INT32 *)__cil_tmp40___0;
      }
#line 9951
      if (! l_img_comp_dest->data) {
#line 9952
        return (0);
      }
#line 9955
      if (l_img_comp_dest->w != l_width_dest) {
        {
#line 9957
        memset((void *)l_img_comp_dest->data, 0, ((OPJ_SIZE_T )l_img_comp_dest->w * (unsigned long )l_img_comp_dest->h) * sizeof(OPJ_INT32 ));
        }
      } else
#line 9955
      if (l_img_comp_dest->h != l_height_dest) {
        {
#line 9957
        memset((void *)l_img_comp_dest->data, 0, ((OPJ_SIZE_T )l_img_comp_dest->w * (unsigned long )l_img_comp_dest->h) * sizeof(OPJ_INT32 ));
        }
      }
    }
#line 9963
    l_dest_ptr = l_img_comp_dest->data + l_start_offset_dest;
#line 9966
    l_src_ptr = p_src_data___11;
#line 9967
    l_src_ptr += l_start_offset_src;
#line 9969
    j___8 = (OPJ_UINT32 )0;
    {
#line 9969
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 9969
      if (! (j___8 < l_height_dest)) {
#line 9969
        goto while_break___0;
      }
      {
#line 9970
      memcpy((void *)l_dest_ptr, (void const   *)l_src_ptr, (unsigned long )l_width_dest * sizeof(OPJ_INT32 ));
#line 9971
      l_dest_ptr += l_img_comp_dest->w;
#line 9972
      l_src_ptr += src_data_stride;
#line 9969
      j___8 ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }

    while_break___0: 
#line 9791
    l_tilec ++;
#line 9791
    l_img_comp_src ++;
#line 9791
    l_img_comp_dest ++;
#line 9791
    __cil_tmp42 = i___70;
#line 9791
    i___70 ++;
  }
  while_break___1: /* CIL Label */ ;
  }

  while_break: ;
#line 9979
  return (1);
}
}
#line 9982 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_update_image_dimensions(opj_image_t *p_image___13 , opj_event_mgr_t *p_manager___117 ) 
{ 
  OPJ_UINT32 it_comp ;
  OPJ_INT32 l_comp_x1 ;
  OPJ_INT32 l_comp_y1 ;
  opj_image_comp_t *l_img_comp___2 ;
  OPJ_INT32 l_h ;
  OPJ_INT32 l_w ;
  OPJ_INT32 __cil_tmp9___18 ;
  OPJ_INT32 __cil_tmp10___11 ;
  OPJ_INT32 __cil_tmp13___23 ;
  OPJ_INT32 __cil_tmp14___29 ;
  OPJ_INT32 __cil_tmp15___21 ;
  OPJ_INT32 __cil_tmp16___17 ;

  {
#line 9987
  l_img_comp___2 = (opj_image_comp_t *)((void *)0);
#line 9989
  l_img_comp___2 = p_image___13->comps;
#line 9990
  it_comp = (OPJ_UINT32 )0;
  {
#line 9990
  while (1) {
    while_continue: /* CIL Label */ ;

#line 9990
    if (! (it_comp < p_image___13->numcomps)) {
#line 9990
      goto while_break;
    }
#line 9992
    if (p_image___13->x0 > 2147483647U) {
      {
#line 9996
      opj_event_msg(p_manager___117, 1, "Image coordinates above INT_MAX are not supported\n\245\005]U");
      }
#line 9998
      return (0);
    } else
#line 9992
    if (p_image___13->y0 > 2147483647U) {
      {
#line 9996
      opj_event_msg(p_manager___117, 1, "Image coordinates above INT_MAX are not supported\n\245\005]U");
      }
#line 9998
      return (0);
    } else
#line 9992
    if (p_image___13->x1 > 2147483647U) {
      {
#line 9996
      opj_event_msg(p_manager___117, 1, "Image coordinates above INT_MAX are not supported\n\245\005]U");
      }
#line 9998
      return (0);
    } else
#line 9992
    if (p_image___13->y1 > 2147483647U) {
      {
#line 9996
      opj_event_msg(p_manager___117, 1, "Image coordinates above INT_MAX are not supported\n\245\005]U");
      }
#line 9998
      return (0);
    }
    {
#line 10001
    __cil_tmp9___18 = opj_int_ceildiv((OPJ_INT32 )p_image___13->x0, (OPJ_INT32 )l_img_comp___2->dx);
#line 10001
    l_img_comp___2->x0 = (OPJ_UINT32 )__cil_tmp9___18;
#line 10003
    __cil_tmp10___11 = opj_int_ceildiv((OPJ_INT32 )p_image___13->y0, (OPJ_INT32 )l_img_comp___2->dy);
#line 10003
    l_img_comp___2->y0 = (OPJ_UINT32 )__cil_tmp10___11;
#line 10005
    l_comp_x1 = opj_int_ceildiv((OPJ_INT32 )p_image___13->x1, (OPJ_INT32 )l_img_comp___2->dx);
#line 10006
    l_comp_y1 = opj_int_ceildiv((OPJ_INT32 )p_image___13->y1, (OPJ_INT32 )l_img_comp___2->dy);
#line 10008
    __cil_tmp14___29 = opj_int_ceildivpow2((OPJ_INT32 )l_img_comp___2->x0, (OPJ_INT32 )l_img_comp___2->factor);
#line 10008
    __cil_tmp13___23 = opj_int_ceildivpow2(l_comp_x1, (OPJ_INT32 )l_img_comp___2->factor);
#line 10008
    l_w = __cil_tmp13___23 - __cil_tmp14___29;
    }
#line 10010
    if (l_w < 0) {
      {
#line 10011
      opj_event_msg(p_manager___117, 1, "Size x of the decoded component image is incorrect (comp[%d].w=%d).\n",
                    it_comp, l_w);
      }
#line 10014
      return (0);
    }
    {
#line 10016
    l_img_comp___2->w = (OPJ_UINT32 )l_w;
#line 10018
    __cil_tmp16___17 = opj_int_ceildivpow2((OPJ_INT32 )l_img_comp___2->y0, (OPJ_INT32 )l_img_comp___2->factor);
#line 10018
    __cil_tmp15___21 = opj_int_ceildivpow2(l_comp_y1, (OPJ_INT32 )l_img_comp___2->factor);
#line 10018
    l_h = __cil_tmp15___21 - __cil_tmp16___17;
    }
#line 10020
    if (l_h < 0) {
      {
#line 10021
      opj_event_msg(p_manager___117, 1, "Size y of the decoded component image is incorrect (comp[%d].h=%d).\n]U",
                    it_comp, l_h);
      }
#line 10024
      return (0);
    }
#line 10026
    l_img_comp___2->h = (OPJ_UINT32 )l_h;
#line 10028
    l_img_comp___2 ++;
#line 9990
    it_comp ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 10031
  return (1);
}
}
#line 10034 "/root/patron-new/39/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_set_decoded_components(opj_j2k_t *p_j2k___74 , OPJ_UINT32 numcomps___1 ,
                                        OPJ_UINT32 *comps_indices___1 , opj_event_mgr_t *p_manager___118 ) 
{ 
  OPJ_UINT32 i___71 ;
  OPJ_BOOL *already_mapped ;
  void *__cil_tmp7___25 ;
  void *__cil_tmp9___19 ;

  {
#line 10042
  if ((unsigned long )p_j2k___74->m_private_image == (unsigned long )((void *)0)) {
    {
#line 10043
    opj_event_msg(p_manager___118, 1, "opj_read_header() should be called before opj_set_decoded_components().\n");
    }
#line 10046
    return (0);
  }
  {
#line 10049
  __cil_tmp7___25 = opj_calloc(sizeof(OPJ_BOOL ), (size_t )(p_j2k___74->m_private_image)->numcomps);
#line 10049
  already_mapped = (OPJ_BOOL *)__cil_tmp7___25;
  }
#line 10051
  if ((unsigned long )already_mapped == (unsigned long )((void *)0)) {
#line 10052
    return (0);
  }
#line 10055
  i___71 = (OPJ_UINT32 )0;
  {
#line 10055
  while (1) {
    while_continue: /* CIL Label */ ;

#line 10055
    if (! (i___71 < numcomps___1)) {
#line 10055
      goto while_break;
    }
#line 10056
    if (*(comps_indices___1 + i___71) >= (p_j2k___74->m_private_image)->numcomps) {
      {
#line 10057
      opj_event_msg(p_manager___118, 1, "Invalid component index: %u\n]U", *(comps_indices___1 + i___71));
#line 10060
      opj_free((void *)already_mapped);
      }
#line 10061
      return (0);
    }
#line 10063
    if (*(already_mapped + *(comps_indices___1 + i___71))) {
      {
#line 10064
      opj_event_msg(p_manager___118, 1, "Component index %u used several times\n",
                    *(comps_indices___1 + i___71));
#line 10067
      opj_free((void *)already_mapped);
      }
#line 10068
      return (0);
    }
#line 10070
    *(already_mapped + *(comps_indices___1 + i___71)) = 1;
#line 10055
    i___71 ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: 
  {
#line 10072
  opj_free((void *)already_mapped);
#line 10074
  opj_free((void *)p_j2k___74->m_specific_param.m_decoder.m_comps_indices_to_decode);
  }
#line 10075
  if (numcomps___1) {
    {
#line 10076
    __cil_tmp9___19 = opj_malloc((unsigned long )numcomps___1 * sizeof(OPJ_UINT32 ));
#line 10076
    p_j2k___74->m_specific_param.m_decoder.m_comps_indices_to_decode = (OPJ_UINT32 *)__cil_tmp9___19;
    }
#line 10078
    if ((unsigned long )p_j2k___74->m_specific_param.m_decoder.m_comps_indices_to_decode == (unsigned long )((void *)0)) {
#line 10079
      p_j2k___74->m_specific_param.m_decoder.m_numcomps_to_decode = (OPJ_UINT32 )0;
#line 10080
      return (0);
    }
    {
#line 10082
    memcpy((void *)p_j2k___74->m_specific_param.m_decoder.m_comps_indices_to_decode,
           (void const   *)comps_indices___1, (unsigned long )numcomps___1 * sizeof(OPJ_UINT32 ));
    }
  } else {
#line 10086
    p_j2k___74->m_specific_param.m_decoder.m_comps_indices_to_decode = (OPJ_UINT32 *)((void *)0);
  }
#line 10088
  p_j2k___74->m_specific_param.m_decoder.m_numcomps_to_decode = numcomps___1;
#line 10090
  return (1);
}
}
#line 10094 "/root/patron-new/39/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_set_decode_area(opj_j2k_t *p_j2k___75 , opj_image_t *p_image___14 ,
                                 OPJ_INT32 p_start_x___1 , OPJ_INT32 p_start_y___1 ,
                                 OPJ_INT32 p_end_x___1 , OPJ_INT32 p_end_y___1 , opj_event_mgr_t *p_manager___119 ) 
{ 
  opj_cp_t *l_cp___13 ;
  opj_image_t *l_image___11 ;
  OPJ_BOOL ret___1 ;
  OPJ_UINT32 it_comp___0 ;
  OPJ_BOOL __cil_tmp12___20 ;
  OPJ_INT32 __cil_tmp13___24 ;
  OPJ_INT32 __cil_tmp14___30 ;

  {
#line 10100
  l_cp___13 = & p_j2k___75->m_cp;
#line 10101
  l_image___11 = p_j2k___75->m_private_image;
#line 10105
  if ((unsigned long )(p_j2k___75->m_cp.tcps + 0)->m_data != (unsigned long )((void *)0)) {
#line 10105
    if (p_j2k___75->m_cp.tw == 1U) {
#line 10105
      if (! (p_j2k___75->m_cp.th == 1U)) {
#line 10105
        goto _L;
      }
    } else {
#line 10105
      goto _L;
    }
  } else
  _L: 
#line 10111
  if (p_j2k___75->m_specific_param.m_decoder.m_state != 8U) {
    {
#line 10112
    opj_event_msg(p_manager___119, 1, "Need to decode the main header before begin to decode the remaining codestream.\n\220");
    }
#line 10114
    return (0);
  }
#line 10119
  it_comp___0 = (OPJ_UINT32 )0;
  {
#line 10119
  while (1) {
    while_continue: /* CIL Label */ ;

#line 10119
    if (! (it_comp___0 < p_image___14->numcomps)) {
#line 10119
      goto while_break;
    }
#line 10120
    (p_image___14->comps + it_comp___0)->factor = p_j2k___75->m_cp.m_specific_param.m_dec.m_reduce;
#line 10119
    it_comp___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 10123
  if (! p_start_x___1) {
#line 10123
    if (! p_start_y___1) {
#line 10123
      if (! p_end_x___1) {
#line 10123
        if (! p_end_y___1) {
          {
#line 10124
          opj_event_msg(p_manager___119, 4, "No decoded area parameters, set the decoded area to the whole image\n");
#line 10127
          p_j2k___75->m_specific_param.m_decoder.m_start_tile_x = (OPJ_UINT32 )0;
#line 10128
          p_j2k___75->m_specific_param.m_decoder.m_start_tile_y = (OPJ_UINT32 )0;
#line 10129
          p_j2k___75->m_specific_param.m_decoder.m_end_tile_x = l_cp___13->tw;
#line 10130
          p_j2k___75->m_specific_param.m_decoder.m_end_tile_y = l_cp___13->th;
#line 10132
          p_image___14->x0 = l_image___11->x0;
#line 10133
          p_image___14->y0 = l_image___11->y0;
#line 10134
          p_image___14->x1 = l_image___11->x1;
#line 10135
          p_image___14->y1 = l_image___11->y1;
#line 10137
          __cil_tmp12___20 = opj_j2k_update_image_dimensions(p_image___14, p_manager___119);
          }
#line 10137
          return (__cil_tmp12___20);
        }
      }
    }
  }
#line 10144
  if (p_start_x___1 < 0) {
    {
#line 10145
    opj_event_msg(p_manager___119, 1, "Left position of the decoded area (region_x0=%d) should be >= 0.\n\335\245\005]U",
                  p_start_x___1);
    }
#line 10148
    return (0);
  } else
#line 10149
  if ((OPJ_UINT32 )p_start_x___1 > l_image___11->x1) {
    {
#line 10150
    opj_event_msg(p_manager___119, 1, "Left position of the decoded area (region_x0=%d) is outside the image area (Xsiz=%d).\n",
                  p_start_x___1, l_image___11->x1);
    }
#line 10153
    return (0);
  } else
#line 10154
  if ((OPJ_UINT32 )p_start_x___1 < l_image___11->x0) {
    {
#line 10155
    opj_event_msg(p_manager___119, 2, "Left position of the decoded area (region_x0=%d) is outside the image area (XOsiz=%d).\n",
                  p_start_x___1, l_image___11->x0);
#line 10158
    p_j2k___75->m_specific_param.m_decoder.m_start_tile_x = (OPJ_UINT32 )0;
#line 10159
    p_image___14->x0 = l_image___11->x0;
    }
  } else {
#line 10161
    p_j2k___75->m_specific_param.m_decoder.m_start_tile_x = ((OPJ_UINT32 )p_start_x___1 - l_cp___13->tx0) / l_cp___13->tdx;
#line 10163
    p_image___14->x0 = (OPJ_UINT32 )p_start_x___1;
  }
#line 10167
  if (p_start_y___1 < 0) {
    {
#line 10168
    opj_event_msg(p_manager___119, 1, "Up position of the decoded area (region_y0=%d) should be >= 0.\n",
                  p_start_y___1);
    }
#line 10171
    return (0);
  } else
#line 10172
  if ((OPJ_UINT32 )p_start_y___1 > l_image___11->y1) {
    {
#line 10173
    opj_event_msg(p_manager___119, 1, "Up position of the decoded area (region_y0=%d) is outside the image area (Ysiz=%d).\n",
                  p_start_y___1, l_image___11->y1);
    }
#line 10176
    return (0);
  } else
#line 10177
  if ((OPJ_UINT32 )p_start_y___1 < l_image___11->y0) {
    {
#line 10178
    opj_event_msg(p_manager___119, 2, "Up position of the decoded area (region_y0=%d) is outside the image area (YOsiz=%d).\nU",
                  p_start_y___1, l_image___11->y0);
#line 10181
    p_j2k___75->m_specific_param.m_decoder.m_start_tile_y = (OPJ_UINT32 )0;
#line 10182
    p_image___14->y0 = l_image___11->y0;
    }
  } else {
#line 10184
    p_j2k___75->m_specific_param.m_decoder.m_start_tile_y = ((OPJ_UINT32 )p_start_y___1 - l_cp___13->ty0) / l_cp___13->tdy;
#line 10186
    p_image___14->y0 = (OPJ_UINT32 )p_start_y___1;
  }
#line 10190
  if (p_end_x___1 <= 0) {
    {
#line 10191
    opj_event_msg(p_manager___119, 1, "Right position of the decoded area (region_x1=%d) should be > 0.\n",
                  p_end_x___1);
    }
#line 10194
    return (0);
  } else
#line 10195
  if ((OPJ_UINT32 )p_end_x___1 < l_image___11->x0) {
    {
#line 10196
    opj_event_msg(p_manager___119, 1, "Right position of the decoded area (region_x1=%d) is outside the image area (XOsiz=%d).\n\230\001",
                  p_end_x___1, l_image___11->x0);
    }
#line 10199
    return (0);
  } else
#line 10200
  if ((OPJ_UINT32 )p_end_x___1 > l_image___11->x1) {
    {
#line 10201
    opj_event_msg(p_manager___119, 2, "Right position of the decoded area (region_x1=%d) is outside the image area (Xsiz=%d).\n",
                  p_end_x___1, l_image___11->x1);
#line 10204
    p_j2k___75->m_specific_param.m_decoder.m_end_tile_x = l_cp___13->tw;
#line 10205
    p_image___14->x1 = l_image___11->x1;
    }
  } else {
    {
#line 10207
    __cil_tmp13___24 = opj_int_ceildiv(p_end_x___1 - (OPJ_INT32 )l_cp___13->tx0, (OPJ_INT32 )l_cp___13->tdx);
#line 10207
    p_j2k___75->m_specific_param.m_decoder.m_end_tile_x = (OPJ_UINT32 )__cil_tmp13___24;
#line 10209
    p_image___14->x1 = (OPJ_UINT32 )p_end_x___1;
    }
  }
#line 10213
  if (p_end_y___1 <= 0) {
    {
#line 10214
    opj_event_msg(p_manager___119, 1, "Bottom position of the decoded area (region_y1=%d) should be > 0.\n",
                  p_end_y___1);
    }
#line 10217
    return (0);
  } else
#line 10218
  if ((OPJ_UINT32 )p_end_y___1 < l_image___11->y0) {
    {
#line 10219
    opj_event_msg(p_manager___119, 1, "Bottom position of the decoded area (region_y1=%d) is outside the image area (YOsiz=%d).\n",
                  p_end_y___1, l_image___11->y0);
    }
#line 10222
    return (0);
  }
#line 10224
  if ((OPJ_UINT32 )p_end_y___1 > l_image___11->y1) {
    {
#line 10225
    opj_event_msg(p_manager___119, 2, "Bottom position of the decoded area (region_y1=%d) is outside the image area (Ysiz=%d).\n\230\001",
                  p_end_y___1, l_image___11->y1);
#line 10228
    p_j2k___75->m_specific_param.m_decoder.m_end_tile_y = l_cp___13->th;
#line 10229
    p_image___14->y1 = l_image___11->y1;
    }
  } else {
    {
#line 10231
    __cil_tmp14___30 = opj_int_ceildiv(p_end_y___1 - (OPJ_INT32 )l_cp___13->ty0, (OPJ_INT32 )l_cp___13->tdy);
#line 10231
    p_j2k___75->m_specific_param.m_decoder.m_end_tile_y = (OPJ_UINT32 )__cil_tmp14___30;
#line 10233
    p_image___14->y1 = (OPJ_UINT32 )p_end_y___1;
    }
  }
  {
#line 10237
  p_j2k___75->m_specific_param.m_decoder.m_discard_tiles = (OPJ_BITFIELD )1;
#line 10239
  ret___1 = opj_j2k_update_image_dimensions(p_image___14, p_manager___119);
  }
#line 10241
  if (ret___1) {
    {
#line 10242
    opj_event_msg(p_manager___119, 4, "Setting decoding area to %d,%d,%d,%d\n", p_image___14->x0,
                  p_image___14->y0, p_image___14->x1, p_image___14->y1);
    }
  }
#line 10246
  return (ret___1);
}
}
#line 10249 "/root/patron-new/39/src/lib/openjp2/j2k.c"
opj_j2k_t *opj_j2k_create_decompress(void) 
{ 
  opj_j2k_t *l_j2k___0 ;
  void *__cil_tmp2___10 ;
  void *__cil_tmp3___22 ;
  void *__cil_tmp4___15 ;
  int __cil_tmp8___42 ;
  opj_thread_pool_t *__cil_tmp9___20 ;

  {
  {
#line 10251
  __cil_tmp2___10 = opj_calloc((size_t )1, sizeof(opj_j2k_t ));
#line 10251
  l_j2k___0 = (opj_j2k_t *)__cil_tmp2___10;
  }
#line 10252
  if (! l_j2k___0) {
#line 10253
    return ((opj_j2k_t *)0);
  }
  {
#line 10256
  l_j2k___0->m_is_decoder = 1;
#line 10257
  l_j2k___0->m_cp.m_is_decoder = (OPJ_BITFIELD )1;
#line 10260
  l_j2k___0->m_cp.allow_different_bit_depth_sign = (OPJ_BITFIELD )1;
#line 10266
  __cil_tmp3___22 = opj_calloc((size_t )1, sizeof(opj_tcp_t ));
#line 10266
  l_j2k___0->m_specific_param.m_decoder.m_default_tcp = (opj_tcp_t *)__cil_tmp3___22;
  }
#line 10268
  if (! l_j2k___0->m_specific_param.m_decoder.m_default_tcp) {
    {
#line 10269
    opj_j2k_destroy(l_j2k___0);
    }
#line 10270
    return ((opj_j2k_t *)0);
  }
  {
#line 10273
  __cil_tmp4___15 = opj_calloc((size_t )1, (size_t )1000);
#line 10273
  l_j2k___0->m_specific_param.m_decoder.m_header_data = (OPJ_BYTE *)__cil_tmp4___15;
  }
#line 10275
  if (! l_j2k___0->m_specific_param.m_decoder.m_header_data) {
    {
#line 10276
    opj_j2k_destroy(l_j2k___0);
    }
#line 10277
    return ((opj_j2k_t *)0);
  }
  {
#line 10280
  l_j2k___0->m_specific_param.m_decoder.m_header_data_size = (OPJ_UINT32 )1000;
#line 10283
  l_j2k___0->m_specific_param.m_decoder.m_tile_ind_to_dec = -1;
#line 10285
  l_j2k___0->m_specific_param.m_decoder.m_last_sot_read_pos = (OPJ_OFF_T )0;
#line 10288
  l_j2k___0->cstr_index = opj_j2k_create_cstr_index();
  }
#line 10289
  if (! l_j2k___0->cstr_index) {
    {
#line 10290
    opj_j2k_destroy(l_j2k___0);
    }
#line 10291
    return ((opj_j2k_t *)0);
  }
  {
#line 10295
  l_j2k___0->m_validation_list = opj_procedure_list_create();
  }
#line 10296
  if (! l_j2k___0->m_validation_list) {
    {
#line 10297
    opj_j2k_destroy(l_j2k___0);
    }
#line 10298
    return ((opj_j2k_t *)0);
  }
  {
#line 10302
  l_j2k___0->m_procedure_list = opj_procedure_list_create();
  }
#line 10303
  if (! l_j2k___0->m_procedure_list) {
    {
#line 10304
    opj_j2k_destroy(l_j2k___0);
    }
#line 10305
    return ((opj_j2k_t *)0);
  }
  {
#line 10308
  __cil_tmp8___42 = opj_j2k_get_default_thread_count();
#line 10308
  __cil_tmp9___20 = opj_thread_pool_create(__cil_tmp8___42);
#line 10308
  l_j2k___0->m_tp = __cil_tmp9___20;
  }
#line 10309
  if (! l_j2k___0->m_tp) {
    {
#line 10310
    l_j2k___0->m_tp = opj_thread_pool_create(0);
    }
  }
#line 10312
  if (! l_j2k___0->m_tp) {
    {
#line 10313
    opj_j2k_destroy(l_j2k___0);
    }
#line 10314
    return ((opj_j2k_t *)((void *)0));
  }
#line 10317
  return (l_j2k___0);
}
}
#line 10320 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static opj_codestream_index_t *opj_j2k_create_cstr_index(void) 
{ 
  opj_codestream_index_t *cstr_index___1 ;
  void *__cil_tmp2___11 ;
  void *__cil_tmp3___23 ;

  {
  {
#line 10322
  __cil_tmp2___11 = opj_calloc((size_t )1, sizeof(opj_codestream_index_t ));
#line 10322
  cstr_index___1 = (opj_codestream_index_t *)__cil_tmp2___11;
  }
#line 10324
  if (! cstr_index___1) {
#line 10325
    return ((opj_codestream_index_t *)((void *)0));
  }
  {
#line 10328
  cstr_index___1->maxmarknum = (OPJ_UINT32 )100;
#line 10329
  cstr_index___1->marknum = (OPJ_UINT32 )0;
#line 10330
  __cil_tmp3___23 = opj_calloc((size_t )cstr_index___1->maxmarknum, sizeof(opj_marker_info_t ));
#line 10330
  cstr_index___1->marker = (opj_marker_info_t *)__cil_tmp3___23;
  }
#line 10332
  if (! cstr_index___1->marker) {
    {
#line 10333
    opj_free((void *)cstr_index___1);
    }
#line 10334
    return ((opj_codestream_index_t *)((void *)0));
  }
#line 10337
  cstr_index___1->tile_index = (opj_tile_index_t *)((void *)0);
#line 10339
  return (cstr_index___1);
}
}
#line 10342 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_UINT32 opj_j2k_get_SPCod_SPCoc_size(opj_j2k_t *p_j2k___76 , OPJ_UINT32 p_tile_no___1 ,
                                               OPJ_UINT32 p_comp_no___4 ) 
{ 
  opj_cp_t *l_cp___14 ;
  opj_tcp_t *l_tcp___24 ;
  opj_tccp_t *l_tccp___6 ;

  {
#line 10346
  l_cp___14 = (opj_cp_t *)0;
#line 10347
  l_tcp___24 = (opj_tcp_t *)0;
#line 10348
  l_tccp___6 = (opj_tccp_t *)0;
#line 10353
  l_cp___14 = & p_j2k___76->m_cp;
#line 10354
  l_tcp___24 = l_cp___14->tcps + p_tile_no___1;
#line 10355
  l_tccp___6 = l_tcp___24->tccps + p_comp_no___4;
#line 10361
  if (l_tccp___6->csty & 1U) {
#line 10362
    return (5U + l_tccp___6->numresolutions);
  } else {
#line 10364
    return ((OPJ_UINT32 )5);
  }
}
}
#line 10368 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_compare_SPCod_SPCoc(opj_j2k_t *p_j2k___77 , OPJ_UINT32 p_tile_no___2 ,
                                            OPJ_UINT32 p_first_comp_no___1 , OPJ_UINT32 p_second_comp_no___1 ) 
{ 
  OPJ_UINT32 i___72 ;
  opj_cp_t *l_cp___15 ;
  opj_tcp_t *l_tcp___25 ;
  opj_tccp_t *l_tccp0 ;
  opj_tccp_t *l_tccp1 ;

  {
#line 10372
  l_cp___15 = (opj_cp_t *)((void *)0);
#line 10373
  l_tcp___25 = (opj_tcp_t *)((void *)0);
#line 10374
  l_tccp0 = (opj_tccp_t *)((void *)0);
#line 10375
  l_tccp1 = (opj_tccp_t *)((void *)0);
#line 10380
  l_cp___15 = & p_j2k___77->m_cp;
#line 10381
  l_tcp___25 = l_cp___15->tcps + p_tile_no___2;
#line 10382
  l_tccp0 = l_tcp___25->tccps + p_first_comp_no___1;
#line 10383
  l_tccp1 = l_tcp___25->tccps + p_second_comp_no___1;
#line 10385
  if (l_tccp0->numresolutions != l_tccp1->numresolutions) {
#line 10386
    return (0);
  }
#line 10388
  if (l_tccp0->cblkw != l_tccp1->cblkw) {
#line 10389
    return (0);
  }
#line 10391
  if (l_tccp0->cblkh != l_tccp1->cblkh) {
#line 10392
    return (0);
  }
#line 10394
  if (l_tccp0->cblksty != l_tccp1->cblksty) {
#line 10395
    return (0);
  }
#line 10397
  if (l_tccp0->qmfbid != l_tccp1->qmfbid) {
#line 10398
    return (0);
  }
#line 10400
  if ((l_tccp0->csty & 1U) != (l_tccp1->csty & 1U)) {
#line 10401
    return (0);
  }
#line 10404
  i___72 = 0U;
  {
#line 10404
  while (1) {
    while_continue: /* CIL Label */ ;

#line 10404
    if (! (i___72 < l_tccp0->numresolutions)) {
#line 10404
      goto while_break;
    }
#line 10405
    if (l_tccp0->prcw[i___72] != l_tccp1->prcw[i___72]) {
#line 10406
      return (0);
    }
#line 10408
    if (l_tccp0->prch[i___72] != l_tccp1->prch[i___72]) {
#line 10409
      return (0);
    }
#line 10404
    i___72 ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 10412
  return (1);
}
}
#line 10415 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_SPCod_SPCoc(opj_j2k_t *p_j2k___78 , OPJ_UINT32 p_tile_no___3 ,
                                          OPJ_UINT32 p_comp_no___5 , OPJ_BYTE *p_data___11 ,
                                          OPJ_UINT32 *p_header_size___22 , struct opj_event_mgr *p_manager___120 ) 
{ 
  OPJ_UINT32 i___73 ;
  opj_cp_t *l_cp___16 ;
  opj_tcp_t *l_tcp___26 ;
  opj_tccp_t *l_tccp___7 ;

  {
#line 10423
  l_cp___16 = (opj_cp_t *)0;
#line 10424
  l_tcp___26 = (opj_tcp_t *)0;
#line 10425
  l_tccp___7 = (opj_tccp_t *)0;
#line 10433
  l_cp___16 = & p_j2k___78->m_cp;
#line 10434
  l_tcp___26 = l_cp___16->tcps + p_tile_no___3;
#line 10435
  l_tccp___7 = l_tcp___26->tccps + p_comp_no___5;
#line 10441
  if (*p_header_size___22 < 5U) {
    {
#line 10442
    opj_event_msg(p_manager___120, 1, "Error writing SPCod SPCoc element\n");
    }
#line 10443
    return (0);
  }
  {
#line 10446
  opj_write_bytes_LE(p_data___11, l_tccp___7->numresolutions - 1U, (OPJ_UINT32 )1);
#line 10447
  p_data___11 ++;
#line 10449
  opj_write_bytes_LE(p_data___11, l_tccp___7->cblkw - 2U, (OPJ_UINT32 )1);
#line 10450
  p_data___11 ++;
#line 10452
  opj_write_bytes_LE(p_data___11, l_tccp___7->cblkh - 2U, (OPJ_UINT32 )1);
#line 10453
  p_data___11 ++;
#line 10455
  opj_write_bytes_LE(p_data___11, l_tccp___7->cblksty, (OPJ_UINT32 )1);
#line 10457
  p_data___11 ++;
#line 10459
  opj_write_bytes_LE(p_data___11, l_tccp___7->qmfbid, (OPJ_UINT32 )1);
#line 10461
  p_data___11 ++;
#line 10463
  *p_header_size___22 -= 5U;
  }
#line 10465
  if (l_tccp___7->csty & 1U) {
#line 10467
    if (*p_header_size___22 < l_tccp___7->numresolutions) {
      {
#line 10468
      opj_event_msg(p_manager___120, 1, "Error writing SPCod SPCoc element\n");
      }
#line 10469
      return (0);
    }
#line 10472
    i___73 = (OPJ_UINT32 )0;
    {
#line 10472
    while (1) {
      while_continue: /* CIL Label */ ;

#line 10472
      if (! (i___73 < l_tccp___7->numresolutions)) {
#line 10472
        goto while_break;
      }
      {
#line 10473
      opj_write_bytes_LE(p_data___11, l_tccp___7->prcw[i___73] + (l_tccp___7->prch[i___73] << 4),
                         (OPJ_UINT32 )1);
#line 10475
      p_data___11 ++;
#line 10472
      i___73 ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }

    while_break: 
#line 10478
    *p_header_size___22 -= l_tccp___7->numresolutions;
  }
#line 10481
  return (1);
}
}
#line 10484 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_SPCod_SPCoc(opj_j2k_t *p_j2k___79 , OPJ_UINT32 compno___3 ,
                                         OPJ_BYTE *p_header_data___22 , OPJ_UINT32 *p_header_size___23 ,
                                         opj_event_mgr_t *p_manager___121 ) 
{ 
  OPJ_UINT32 i___74 ;
  OPJ_UINT32 l_tmp___7 ;
  opj_cp_t *l_cp___17 ;
  opj_tcp_t *l_tcp___27 ;
  opj_tccp_t *l_tccp___8 ;
  OPJ_BYTE *l_current_ptr___1 ;
  opj_tcp_t *tmp___376 ;

  {
#line 10491
  l_cp___17 = (opj_cp_t *)((void *)0);
#line 10492
  l_tcp___27 = (opj_tcp_t *)((void *)0);
#line 10493
  l_tccp___8 = (opj_tccp_t *)((void *)0);
#line 10494
  l_current_ptr___1 = (OPJ_BYTE *)((void *)0);
#line 10501
  l_cp___17 = & p_j2k___79->m_cp;
#line 10502
  if (p_j2k___79->m_specific_param.m_decoder.m_state == 16U) {
#line 10502
    tmp___376 = l_cp___17->tcps + p_j2k___79->m_current_tile_number;
  } else {
#line 10502
    tmp___376 = p_j2k___79->m_specific_param.m_decoder.m_default_tcp;
  }
#line 10502
  l_tcp___27 = tmp___376;
#line 10509
  l_tccp___8 = l_tcp___27->tccps + compno___3;
#line 10510
  l_current_ptr___1 = p_header_data___22;
#line 10513
  if (*p_header_size___23 < 5U) {
    {
#line 10514
    opj_event_msg(p_manager___121, 1, "Error reading SPCod SPCoc element\n");
    }
#line 10515
    return (0);
  }
  {
#line 10518
  opj_read_bytes_LE(l_current_ptr___1, & l_tccp___8->numresolutions, (OPJ_UINT32 )1);
#line 10520
  (l_tccp___8->numresolutions) ++;
  }
#line 10521
  if (l_tccp___8->numresolutions > 33U) {
    {
#line 10522
    opj_event_msg(p_manager___121, 1, "Invalid value for numresolutions : %d, max value is set in openjpeg.h at %d\n",
                  l_tccp___8->numresolutions, 33);
    }
#line 10525
    return (0);
  }
#line 10527
  l_current_ptr___1 ++;
#line 10530
  if (l_cp___17->m_specific_param.m_dec.m_reduce >= l_tccp___8->numresolutions) {
    {
#line 10531
    opj_event_msg(p_manager___121, 1, "Error decoding component %d.\nThe number of resolutions to remove (%d) is greater or equal than the number of resolutions of this component (%d)\nModify the cp_reduce parameter.\n\n",
                  compno___3, l_cp___17->m_specific_param.m_dec.m_reduce, l_tccp___8->numresolutions);
#line 10536
    p_j2k___79->m_specific_param.m_decoder.m_state |= 32768U;
    }
#line 10538
    return (0);
  }
  {
#line 10541
  opj_read_bytes_LE(l_current_ptr___1, & l_tccp___8->cblkw, (OPJ_UINT32 )1);
#line 10542
  l_current_ptr___1 ++;
#line 10543
  l_tccp___8->cblkw += 2U;
#line 10545
  opj_read_bytes_LE(l_current_ptr___1, & l_tccp___8->cblkh, (OPJ_UINT32 )1);
#line 10546
  l_current_ptr___1 ++;
#line 10547
  l_tccp___8->cblkh += 2U;
  }
#line 10549
  if (l_tccp___8->cblkw > 10U) {
    {
#line 10551
    opj_event_msg(p_manager___121, 1, "Error reading SPCod SPCoc element, Invalid cblkw/cblkh combination\n");
    }
#line 10553
    return (0);
  } else
#line 10549
  if (l_tccp___8->cblkh > 10U) {
    {
#line 10551
    opj_event_msg(p_manager___121, 1, "Error reading SPCod SPCoc element, Invalid cblkw/cblkh combination\n");
    }
#line 10553
    return (0);
  } else
#line 10549
  if (l_tccp___8->cblkw + l_tccp___8->cblkh > 12U) {
    {
#line 10551
    opj_event_msg(p_manager___121, 1, "Error reading SPCod SPCoc element, Invalid cblkw/cblkh combination\n");
    }
#line 10553
    return (0);
  }
  {
#line 10557
  opj_read_bytes_LE(l_current_ptr___1, & l_tccp___8->cblksty, (OPJ_UINT32 )1);
#line 10558
  l_current_ptr___1 ++;
  }
#line 10559
  if (l_tccp___8->cblksty & 192U) {
    {
#line 10560
    opj_event_msg(p_manager___121, 1, "Error reading SPCod SPCoc element, Invalid code-block style found\n\246\005]U");
    }
#line 10562
    return (0);
  }
  {
#line 10565
  opj_read_bytes_LE(l_current_ptr___1, & l_tccp___8->qmfbid, (OPJ_UINT32 )1);
#line 10566
  l_current_ptr___1 ++;
#line 10568
  *p_header_size___23 -= 5U;
  }
#line 10571
  if (l_tccp___8->csty & 1U) {
#line 10572
    if (*p_header_size___23 < l_tccp___8->numresolutions) {
      {
#line 10573
      opj_event_msg(p_manager___121, 1, "Error reading SPCod SPCoc element\n");
      }
#line 10574
      return (0);
    }
#line 10577
    i___74 = (OPJ_UINT32 )0;
    {
#line 10577
    while (1) {
      while_continue: /* CIL Label */ ;

#line 10577
      if (! (i___74 < l_tccp___8->numresolutions)) {
#line 10577
        goto while_break;
      }
      {
#line 10578
      opj_read_bytes_LE(l_current_ptr___1, & l_tmp___7, (OPJ_UINT32 )1);
#line 10579
      l_current_ptr___1 ++;
      }
#line 10581
      if (i___74 != 0U) {
#line 10581
        if ((l_tmp___7 & 15U) == 0U) {
          {
#line 10582
          opj_event_msg(p_manager___121, 1, "Invalid precinct size\n");
          }
#line 10583
          return (0);
        } else
#line 10581
        if (l_tmp___7 >> 4 == 0U) {
          {
#line 10582
          opj_event_msg(p_manager___121, 1, "Invalid precinct size\n");
          }
#line 10583
          return (0);
        }
      }
#line 10585
      l_tccp___8->prcw[i___74] = l_tmp___7 & 15U;
#line 10586
      l_tccp___8->prch[i___74] = l_tmp___7 >> 4;
#line 10577
      i___74 ++;
    }
    while_break___1: /* CIL Label */ ;
    }

    while_break: 
#line 10589
    *p_header_size___23 -= l_tccp___8->numresolutions;
  } else {
#line 10592
    i___74 = (OPJ_UINT32 )0;
    {
#line 10592
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 10592
      if (! (i___74 < l_tccp___8->numresolutions)) {
#line 10592
        goto while_break___0;
      }
#line 10593
      l_tccp___8->prcw[i___74] = (OPJ_UINT32 )15;
#line 10594
      l_tccp___8->prch[i___74] = (OPJ_UINT32 )15;
#line 10592
      i___74 ++;
    }
    while_break___2: /* CIL Label */ ;
    }

    while_break___0: ;
  }
#line 10622
  return (1);
}
}
#line 10625 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static void opj_j2k_copy_tile_component_parameters(opj_j2k_t *p_j2k___80 ) 
{ 
  OPJ_UINT32 i___75 ;
  opj_cp_t *l_cp___18 ;
  opj_tcp_t *l_tcp___28 ;
  opj_tccp_t *l_ref_tccp ;
  opj_tccp_t *l_copied_tccp ;
  OPJ_UINT32 l_prc_size ;
  opj_tcp_t *tmp___379 ;

  {
#line 10629
  l_cp___18 = (opj_cp_t *)((void *)0);
#line 10630
  l_tcp___28 = (opj_tcp_t *)((void *)0);
#line 10631
  l_ref_tccp = (opj_tccp_t *)((void *)0);
#line 10631
  l_copied_tccp = (opj_tccp_t *)((void *)0);
#line 10637
  l_cp___18 = & p_j2k___80->m_cp;
#line 10638
  if (p_j2k___80->m_specific_param.m_decoder.m_state == 16U) {
#line 10638
    tmp___379 = l_cp___18->tcps + p_j2k___80->m_current_tile_number;
  } else {
#line 10638
    tmp___379 = p_j2k___80->m_specific_param.m_decoder.m_default_tcp;
  }
#line 10638
  l_tcp___28 = tmp___379;
#line 10643
  l_ref_tccp = l_tcp___28->tccps + 0;
#line 10644
  l_copied_tccp = l_ref_tccp + 1;
#line 10645
  l_prc_size = l_ref_tccp->numresolutions * (OPJ_UINT32 )sizeof(OPJ_UINT32 );
#line 10647
  i___75 = (OPJ_UINT32 )1;
  {
#line 10647
  while (1) {
    while_continue: /* CIL Label */ ;

#line 10647
    if (! (i___75 < (p_j2k___80->m_private_image)->numcomps)) {
#line 10647
      goto while_break;
    }
    {
#line 10648
    l_copied_tccp->numresolutions = l_ref_tccp->numresolutions;
#line 10649
    l_copied_tccp->cblkw = l_ref_tccp->cblkw;
#line 10650
    l_copied_tccp->cblkh = l_ref_tccp->cblkh;
#line 10651
    l_copied_tccp->cblksty = l_ref_tccp->cblksty;
#line 10652
    l_copied_tccp->qmfbid = l_ref_tccp->qmfbid;
#line 10653
    memcpy((void *)(l_copied_tccp->prcw), (void const   *)(l_ref_tccp->prcw), (unsigned long )l_prc_size);
#line 10654
    memcpy((void *)(l_copied_tccp->prch), (void const   *)(l_ref_tccp->prch), (unsigned long )l_prc_size);
#line 10655
    l_copied_tccp ++;
#line 10647
    i___75 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 10651
  return;
}
}
#line 10659 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_UINT32 opj_j2k_get_SQcd_SQcc_size(opj_j2k_t *p_j2k___81 , OPJ_UINT32 p_tile_no___4 ,
                                             OPJ_UINT32 p_comp_no___6 ) 
{ 
  OPJ_UINT32 l_num_bands ;
  opj_cp_t *l_cp___19 ;
  opj_tcp_t *l_tcp___29 ;
  opj_tccp_t *l_tccp___9 ;
  unsigned int tmp___383 ;

  {
#line 10665
  l_cp___19 = (opj_cp_t *)0;
#line 10666
  l_tcp___29 = (opj_tcp_t *)0;
#line 10667
  l_tccp___9 = (opj_tccp_t *)0;
#line 10672
  l_cp___19 = & p_j2k___81->m_cp;
#line 10673
  l_tcp___29 = l_cp___19->tcps + p_tile_no___4;
#line 10674
  l_tccp___9 = l_tcp___29->tccps + p_comp_no___6;
#line 10680
  if (l_tccp___9->qntsty == 1U) {
#line 10680
    tmp___383 = 1U;
  } else {
#line 10680
    tmp___383 = l_tccp___9->numresolutions * 3U - 2U;
  }
#line 10680
  l_num_bands = tmp___383;
#line 10683
  if (l_tccp___9->qntsty == 0U) {
#line 10684
    return (1U + l_num_bands);
  } else {
#line 10686
    return (1U + 2U * l_num_bands);
  }
}
}
#line 10690 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_compare_SQcd_SQcc(opj_j2k_t *p_j2k___82 , OPJ_UINT32 p_tile_no___5 ,
                                          OPJ_UINT32 p_first_comp_no___2 , OPJ_UINT32 p_second_comp_no___2 ) 
{ 
  opj_cp_t *l_cp___20 ;
  opj_tcp_t *l_tcp___30 ;
  opj_tccp_t *l_tccp0___0 ;
  opj_tccp_t *l_tccp1___0 ;
  OPJ_UINT32 l_band_no ;
  OPJ_UINT32 l_num_bands___0 ;

  {
#line 10693
  l_cp___20 = (opj_cp_t *)((void *)0);
#line 10694
  l_tcp___30 = (opj_tcp_t *)((void *)0);
#line 10695
  l_tccp0___0 = (opj_tccp_t *)((void *)0);
#line 10696
  l_tccp1___0 = (opj_tccp_t *)((void *)0);
#line 10702
  l_cp___20 = & p_j2k___82->m_cp;
#line 10703
  l_tcp___30 = l_cp___20->tcps + p_tile_no___5;
#line 10704
  l_tccp0___0 = l_tcp___30->tccps + p_first_comp_no___2;
#line 10705
  l_tccp1___0 = l_tcp___30->tccps + p_second_comp_no___2;
#line 10707
  if (l_tccp0___0->qntsty != l_tccp1___0->qntsty) {
#line 10708
    return (0);
  }
#line 10710
  if (l_tccp0___0->numgbits != l_tccp1___0->numgbits) {
#line 10711
    return (0);
  }
#line 10713
  if (l_tccp0___0->qntsty == 1U) {
#line 10714
    l_num_bands___0 = 1U;
  } else {
#line 10716
    l_num_bands___0 = l_tccp0___0->numresolutions * 3U - 2U;
#line 10717
    if (l_num_bands___0 != l_tccp1___0->numresolutions * 3U - 2U) {
#line 10718
      return (0);
    }
  }
#line 10722
  l_band_no = (OPJ_UINT32 )0;
  {
#line 10722
  while (1) {
    while_continue: /* CIL Label */ ;

#line 10722
    if (! (l_band_no < l_num_bands___0)) {
#line 10722
      goto while_break;
    }
#line 10723
    if (l_tccp0___0->stepsizes[l_band_no].expn != l_tccp1___0->stepsizes[l_band_no].expn) {
#line 10724
      return (0);
    }
#line 10722
    l_band_no ++;
  }
  while_break___1: /* CIL Label */ ;
  }

  while_break: ;
#line 10727
  if (l_tccp0___0->qntsty != 0U) {
#line 10728
    l_band_no = (OPJ_UINT32 )0;
    {
#line 10728
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 10728
      if (! (l_band_no < l_num_bands___0)) {
#line 10728
        goto while_break___0;
      }
#line 10729
      if (l_tccp0___0->stepsizes[l_band_no].mant != l_tccp1___0->stepsizes[l_band_no].mant) {
#line 10730
        return (0);
      }
#line 10728
      l_band_no ++;
    }
    while_break___2: /* CIL Label */ ;
    }

    while_break___0: ;
  }
#line 10734
  return (1);
}
}
#line 10738 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_SQcd_SQcc(opj_j2k_t *p_j2k___83 , OPJ_UINT32 p_tile_no___6 ,
                                        OPJ_UINT32 p_comp_no___7 , OPJ_BYTE *p_data___12 ,
                                        OPJ_UINT32 *p_header_size___24 , struct opj_event_mgr *p_manager___122 ) 
{ 
  OPJ_UINT32 l_header_size ;
  OPJ_UINT32 l_band_no___0 ;
  OPJ_UINT32 l_num_bands___1 ;
  OPJ_UINT32 l_expn ;
  OPJ_UINT32 l_mant ;
  opj_cp_t *l_cp___21 ;
  opj_tcp_t *l_tcp___31 ;
  opj_tccp_t *l_tccp___10 ;
  unsigned int tmp___391 ;

  {
#line 10749
  l_cp___21 = (opj_cp_t *)0;
#line 10750
  l_tcp___31 = (opj_tcp_t *)0;
#line 10751
  l_tccp___10 = (opj_tccp_t *)0;
#line 10759
  l_cp___21 = & p_j2k___83->m_cp;
#line 10760
  l_tcp___31 = l_cp___21->tcps + p_tile_no___6;
#line 10761
  l_tccp___10 = l_tcp___31->tccps + p_comp_no___7;
#line 10767
  if (l_tccp___10->qntsty == 1U) {
#line 10767
    tmp___391 = 1U;
  } else {
#line 10767
    tmp___391 = l_tccp___10->numresolutions * 3U - 2U;
  }
#line 10767
  l_num_bands___1 = tmp___391;
#line 10770
  if (l_tccp___10->qntsty == 0U) {
#line 10771
    l_header_size = 1U + l_num_bands___1;
#line 10773
    if (*p_header_size___24 < l_header_size) {
      {
#line 10774
      opj_event_msg(p_manager___122, 1, "Error writing SQcd SQcc element\n\220");
      }
#line 10775
      return (0);
    }
    {
#line 10778
    opj_write_bytes_LE(p_data___12, l_tccp___10->qntsty + (l_tccp___10->numgbits << 5),
                       (OPJ_UINT32 )1);
#line 10780
    p_data___12 ++;
#line 10782
    l_band_no___0 = (OPJ_UINT32 )0;
    }
    {
#line 10782
    while (1) {
      while_continue: /* CIL Label */ ;

#line 10782
      if (! (l_band_no___0 < l_num_bands___1)) {
#line 10782
        goto while_break;
      }
      {
#line 10783
      l_expn = (OPJ_UINT32 )l_tccp___10->stepsizes[l_band_no___0].expn;
#line 10784
      opj_write_bytes_LE(p_data___12, l_expn << 3, (OPJ_UINT32 )1);
#line 10785
      p_data___12 ++;
#line 10782
      l_band_no___0 ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }

    while_break: ;
  } else {
#line 10788
    l_header_size = 1U + 2U * l_num_bands___1;
#line 10790
    if (*p_header_size___24 < l_header_size) {
      {
#line 10791
      opj_event_msg(p_manager___122, 1, "Error writing SQcd SQcc element\n\220");
      }
#line 10792
      return (0);
    }
    {
#line 10795
    opj_write_bytes_LE(p_data___12, l_tccp___10->qntsty + (l_tccp___10->numgbits << 5),
                       (OPJ_UINT32 )1);
#line 10797
    p_data___12 ++;
#line 10799
    l_band_no___0 = (OPJ_UINT32 )0;
    }
    {
#line 10799
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 10799
      if (! (l_band_no___0 < l_num_bands___1)) {
#line 10799
        goto while_break___0;
      }
      {
#line 10800
      l_expn = (OPJ_UINT32 )l_tccp___10->stepsizes[l_band_no___0].expn;
#line 10801
      l_mant = (OPJ_UINT32 )l_tccp___10->stepsizes[l_band_no___0].mant;
#line 10803
      opj_write_bytes_LE(p_data___12, (l_expn << 11) + l_mant, (OPJ_UINT32 )2);
#line 10804
      p_data___12 += 2;
#line 10799
      l_band_no___0 ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }

    while_break___0: ;
  }
#line 10808
  *p_header_size___24 -= l_header_size;
#line 10810
  return (1);
}
}
#line 10813 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_SQcd_SQcc(opj_j2k_t *p_j2k___84 , OPJ_UINT32 p_comp_no___8 ,
                                       OPJ_BYTE *p_header_data___23 , OPJ_UINT32 *p_header_size___25 ,
                                       opj_event_mgr_t *p_manager___123 ) 
{ 
  OPJ_UINT32 l_band_no___1 ;
  opj_cp_t *l_cp___22 ;
  opj_tcp_t *l_tcp___32 ;
  opj_tccp_t *l_tccp___11 ;
  OPJ_BYTE *l_current_ptr___2 ;
  OPJ_UINT32 l_tmp___8 ;
  OPJ_UINT32 l_num_band ;
  opj_tcp_t *tmp___395 ;
  OPJ_UINT32 tmp___397 ;
  OPJ_INT32 tmp___398 ;

  {
#line 10822
  l_cp___22 = (opj_cp_t *)0;
#line 10823
  l_tcp___32 = (opj_tcp_t *)0;
#line 10824
  l_tccp___11 = (opj_tccp_t *)0;
#line 10825
  l_current_ptr___2 = (OPJ_BYTE *)0;
#line 10833
  l_cp___22 = & p_j2k___84->m_cp;
#line 10835
  if (p_j2k___84->m_specific_param.m_decoder.m_state == 16U) {
#line 10835
    tmp___395 = l_cp___22->tcps + p_j2k___84->m_current_tile_number;
  } else {
#line 10835
    tmp___395 = p_j2k___84->m_specific_param.m_decoder.m_default_tcp;
  }
#line 10835
  l_tcp___32 = tmp___395;
#line 10843
  l_tccp___11 = l_tcp___32->tccps + p_comp_no___8;
#line 10844
  l_current_ptr___2 = p_header_data___23;
#line 10846
  if (*p_header_size___25 < 1U) {
    {
#line 10847
    opj_event_msg(p_manager___123, 1, "Error reading SQcd or SQcc element\n");
    }
#line 10848
    return (0);
  }
  {
#line 10850
  (*p_header_size___25) --;
#line 10852
  opj_read_bytes_LE(l_current_ptr___2, & l_tmp___8, (OPJ_UINT32 )1);
#line 10853
  l_current_ptr___2 ++;
#line 10855
  l_tccp___11->qntsty = l_tmp___8 & 31U;
#line 10856
  l_tccp___11->numgbits = l_tmp___8 >> 5;
  }
#line 10857
  if (l_tccp___11->qntsty == 1U) {
#line 10858
    l_num_band = (OPJ_UINT32 )1;
  } else {
#line 10860
    if (l_tccp___11->qntsty == 0U) {
#line 10860
      tmp___397 = *p_header_size___25;
    } else {
#line 10860
      tmp___397 = *p_header_size___25 / 2U;
    }
#line 10860
    l_num_band = tmp___397;
#line 10864
    if (l_num_band > 97U) {
      {
#line 10865
      opj_event_msg(p_manager___123, 2, "While reading CCP_QNTSTY element inside QCD or QCC marker segment, number of subbands (%d) is greater to OPJ_J2K_MAXBANDS (%d). So we limit the number of elements stored to OPJ_J2K_MAXBANDS (%d) and skip the rest. \n",
                    l_num_band, 97, 97);
      }
    }
  }
#line 10896
  if (l_tccp___11->qntsty == 0U) {
#line 10897
    l_band_no___1 = (OPJ_UINT32 )0;
    {
#line 10897
    while (1) {
      while_continue: /* CIL Label */ ;

#line 10897
      if (! (l_band_no___1 < l_num_band)) {
#line 10897
        goto while_break;
      }
      {
#line 10898
      opj_read_bytes_LE(l_current_ptr___2, & l_tmp___8, (OPJ_UINT32 )1);
#line 10899
      l_current_ptr___2 ++;
      }
#line 10900
      if (l_band_no___1 < 97U) {
#line 10901
        l_tccp___11->stepsizes[l_band_no___1].expn = (OPJ_INT32 )(l_tmp___8 >> 3);
#line 10902
        l_tccp___11->stepsizes[l_band_no___1].mant = 0;
      }
#line 10897
      l_band_no___1 ++;
    }
    while_break___2: /* CIL Label */ ;
    }

    while_break: 
#line 10905
    *p_header_size___25 -= l_num_band;
  } else {
#line 10907
    l_band_no___1 = (OPJ_UINT32 )0;
    {
#line 10907
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 10907
      if (! (l_band_no___1 < l_num_band)) {
#line 10907
        goto while_break___0;
      }
      {
#line 10908
      opj_read_bytes_LE(l_current_ptr___2, & l_tmp___8, (OPJ_UINT32 )2);
#line 10909
      l_current_ptr___2 += 2;
      }
#line 10910
      if (l_band_no___1 < 97U) {
#line 10911
        l_tccp___11->stepsizes[l_band_no___1].expn = (OPJ_INT32 )(l_tmp___8 >> 11);
#line 10912
        l_tccp___11->stepsizes[l_band_no___1].mant = (OPJ_INT32 )(l_tmp___8 & 2047U);
      }
#line 10907
      l_band_no___1 ++;
    }
    while_break___3: /* CIL Label */ ;
    }

    while_break___0: 
#line 10915
    *p_header_size___25 -= 2U * l_num_band;
  }
#line 10919
  if (l_tccp___11->qntsty == 1U) {
#line 10920
    l_band_no___1 = (OPJ_UINT32 )1;
    {
#line 10920
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 10920
      if (! (l_band_no___1 < 97U)) {
#line 10920
        goto while_break___1;
      }
#line 10921
      if (l_tccp___11->stepsizes[0].expn - (OPJ_INT32 )((l_band_no___1 - 1U) / 3U) > 0) {
#line 10921
        tmp___398 = l_tccp___11->stepsizes[0].expn - (OPJ_INT32 )((l_band_no___1 - 1U) / 3U);
      } else {
#line 10921
        tmp___398 = 0;
      }
#line 10921
      l_tccp___11->stepsizes[l_band_no___1].expn = tmp___398;
#line 10925
      l_tccp___11->stepsizes[l_band_no___1].mant = l_tccp___11->stepsizes[0].mant;
#line 10920
      l_band_no___1 ++;
    }
    while_break___4: /* CIL Label */ ;
    }

    while_break___1: ;
  }
#line 10929
  return (1);
}
}
#line 10932 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static void opj_j2k_copy_tile_quantization_parameters(opj_j2k_t *p_j2k___85 ) 
{ 
  OPJ_UINT32 i___76 ;
  opj_cp_t *l_cp___23 ;
  opj_tcp_t *l_tcp___33 ;
  opj_tccp_t *l_ref_tccp___0 ;
  opj_tccp_t *l_copied_tccp___0 ;
  OPJ_UINT32 l_size ;
  opj_tcp_t *tmp___400 ;

  {
#line 10935
  l_cp___23 = (opj_cp_t *)((void *)0);
#line 10936
  l_tcp___33 = (opj_tcp_t *)((void *)0);
#line 10937
  l_ref_tccp___0 = (opj_tccp_t *)((void *)0);
#line 10938
  l_copied_tccp___0 = (opj_tccp_t *)((void *)0);
#line 10944
  l_cp___23 = & p_j2k___85->m_cp;
#line 10945
  if (p_j2k___85->m_specific_param.m_decoder.m_state == 16U) {
#line 10945
    tmp___400 = l_cp___23->tcps + p_j2k___85->m_current_tile_number;
  } else {
#line 10945
    tmp___400 = p_j2k___85->m_specific_param.m_decoder.m_default_tcp;
  }
#line 10945
  l_tcp___33 = tmp___400;
#line 10949
  l_ref_tccp___0 = l_tcp___33->tccps + 0;
#line 10950
  l_copied_tccp___0 = l_ref_tccp___0 + 1;
#line 10951
  l_size = (OPJ_UINT32 )(97UL * sizeof(opj_stepsize_t ));
#line 10953
  i___76 = (OPJ_UINT32 )1;
  {
#line 10953
  while (1) {
    while_continue: /* CIL Label */ ;

#line 10953
    if (! (i___76 < (p_j2k___85->m_private_image)->numcomps)) {
#line 10953
      goto while_break;
    }
    {
#line 10954
    l_copied_tccp___0->qntsty = l_ref_tccp___0->qntsty;
#line 10955
    l_copied_tccp___0->numgbits = l_ref_tccp___0->numgbits;
#line 10956
    memcpy((void *)(l_copied_tccp___0->stepsizes), (void const   *)(l_ref_tccp___0->stepsizes),
           (unsigned long )l_size);
#line 10957
    l_copied_tccp___0 ++;
#line 10953
    i___76 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 10957
  return;
}
}
#line 10961 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static void opj_j2k_dump_tile_info(opj_tcp_t *l_default_tile , OPJ_INT32 numcomps___2 ,
                                   FILE *out_stream___0 ) 
{ 
  OPJ_INT32 compno___4 ;
  opj_tccp_t *l_tccp___12 ;
  OPJ_UINT32 resno___0 ;
  OPJ_INT32 bandno ;
  OPJ_INT32 numbands ;
  int tmp___401 ;

  {
#line 10964
  if (l_default_tile) {
    {
#line 10967
    fprintf(out_stream___0, "\t default tile {\n");
#line 10968
    fprintf(out_stream___0, "\t\t csty=%#x\n]U", l_default_tile->csty);
#line 10969
    fprintf(out_stream___0, "\t\t prg=%#x\n", (int )l_default_tile->prg);
#line 10970
    fprintf(out_stream___0, "\t\t numlayers=%d\n\230\001", l_default_tile->numlayers);
#line 10971
    fprintf(out_stream___0, "\t\t mct=%x\n\251\005]U", l_default_tile->mct);
#line 10973
    compno___4 = 0;
    }
    {
#line 10973
    while (1) {
      while_continue: /* CIL Label */ ;

#line 10973
      if (! (compno___4 < numcomps___2)) {
#line 10973
        goto while_break;
      }
      {
#line 10974
      l_tccp___12 = l_default_tile->tccps + compno___4;
#line 10979
      fprintf(out_stream___0, "\t\t comp %d {\n", compno___4);
#line 10980
      fprintf(out_stream___0, "\t\t\t csty=%#x\n", l_tccp___12->csty);
#line 10981
      fprintf(out_stream___0, "\t\t\t numresolutions=%d\n", l_tccp___12->numresolutions);
#line 10982
      fprintf(out_stream___0, "\t\t\t cblkw=2^%d\n", l_tccp___12->cblkw);
#line 10983
      fprintf(out_stream___0, "\t\t\t cblkh=2^%d\n", l_tccp___12->cblkh);
#line 10984
      fprintf(out_stream___0, "\t\t\t cblksty=%#x\n\230\001", l_tccp___12->cblksty);
#line 10985
      fprintf(out_stream___0, "\t\t\t qmfbid=%d\n", l_tccp___12->qmfbid);
#line 10987
      fprintf(out_stream___0, "\t\t\t preccintsize (w,h)=");
#line 10988
      resno___0 = (OPJ_UINT32 )0;
      }
      {
#line 10988
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 10988
        if (! (resno___0 < l_tccp___12->numresolutions)) {
#line 10988
          goto while_break___0;
        }
        {
#line 10989
        fprintf(out_stream___0, "(%d,%d) \230\001", l_tccp___12->prcw[resno___0],
                l_tccp___12->prch[resno___0]);
#line 10988
        resno___0 ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }

      while_break___0: 
      {
#line 10991
      fprintf(out_stream___0, "\n\302\250\005]U");
#line 10994
      fprintf(out_stream___0, "\t\t\t qntsty=%d\n", l_tccp___12->qntsty);
#line 10995
      fprintf(out_stream___0, "\t\t\t numgbits=%d\n\230\001", l_tccp___12->numgbits);
#line 10996
      fprintf(out_stream___0, "\t\t\t stepsizes (m,e)=");
      }
#line 10997
      if (l_tccp___12->qntsty == 1U) {
#line 10997
        tmp___401 = 1;
      } else {
#line 10997
        tmp___401 = (OPJ_INT32 )l_tccp___12->numresolutions * 3 - 2;
      }
#line 10997
      numbands = tmp___401;
#line 10999
      bandno = 0;
      {
#line 10999
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 10999
        if (! (bandno < numbands)) {
#line 10999
          goto while_break___1;
        }
        {
#line 11000
        fprintf(out_stream___0, "(%d,%d) \230\001", l_tccp___12->stepsizes[bandno].mant,
                l_tccp___12->stepsizes[bandno].expn);
#line 10999
        bandno ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }

      while_break___1: 
      {
#line 11003
      fprintf(out_stream___0, "\n\264\250\005]U");
#line 11006
      fprintf(out_stream___0, "\t\t\t roishift=%d\n\230\001", l_tccp___12->roishift);
#line 11008
      fprintf(out_stream___0, "\t\t }\nU");
#line 10973
      compno___4 ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }

    while_break: 
    {
#line 11010
    fprintf(out_stream___0, "\t }\n]U");
    }
  }
#line 11013
  return;
}
}
#line 11014 "/root/patron-new/39/src/lib/openjp2/j2k.c"
void j2k_dump(opj_j2k_t *p_j2k___86 , OPJ_INT32 flag___0 , FILE *out_stream___1 ) 
{ 
  OPJ_UINT32 l_nb_tiles___9 ;
  OPJ_UINT32 i___77 ;
  opj_tcp_t *l_tcp___34 ;

  {
#line 11017
  if (flag___0 & 128) {
    {
#line 11018
    fprintf(out_stream___1, "Wrong flag\n");
    }
#line 11019
    return;
  } else
#line 11017
  if (flag___0 & 256) {
    {
#line 11018
    fprintf(out_stream___1, "Wrong flag\n");
    }
#line 11019
    return;
  }
#line 11023
  if (flag___0 & 1) {
#line 11024
    if (p_j2k___86->m_private_image) {
      {
#line 11025
      j2k_dump_image_header(p_j2k___86->m_private_image, 0, out_stream___1);
      }
    }
  }
#line 11030
  if (flag___0 & 2) {
#line 11031
    if (p_j2k___86->m_private_image) {
      {
#line 11032
      opj_j2k_dump_MH_info(p_j2k___86, out_stream___1);
      }
    }
  }
#line 11036
  if (flag___0 & 8) {
#line 11037
    l_nb_tiles___9 = p_j2k___86->m_cp.th * p_j2k___86->m_cp.tw;
#line 11039
    l_tcp___34 = p_j2k___86->m_cp.tcps;
#line 11040
    if (p_j2k___86->m_private_image) {
#line 11041
      i___77 = (OPJ_UINT32 )0;
      {
#line 11041
      while (1) {
        while_continue: /* CIL Label */ ;

#line 11041
        if (! (i___77 < l_nb_tiles___9)) {
#line 11041
          goto while_break;
        }
        {
#line 11042
        opj_j2k_dump_tile_info(l_tcp___34, (OPJ_INT32 )(p_j2k___86->m_private_image)->numcomps,
                               out_stream___1);
#line 11044
        l_tcp___34 ++;
#line 11041
        i___77 ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }

      while_break: ;
    }
  }
#line 11055
  if (flag___0 & 16) {
    {
#line 11056
    opj_j2k_dump_MH_index(p_j2k___86, out_stream___1);
    }
  }
#line 11063
  return;
}
}
#line 11066 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static void opj_j2k_dump_MH_index(opj_j2k_t *p_j2k___87 , FILE *out_stream___2 ) 
{ 
  opj_codestream_index_t *cstr_index___2 ;
  OPJ_UINT32 it_marker ;
  OPJ_UINT32 it_tile___0 ;
  OPJ_UINT32 it_tile_part ;
  OPJ_UINT32 l_acc_nb_of_tile_part ;
  OPJ_UINT32 nb_of_tile_part ;

  {
  {
#line 11068
  cstr_index___2 = p_j2k___87->cstr_index;
#line 11071
  fprintf(out_stream___2, "Codestream index from main header: {\n");
#line 11073
  fprintf(out_stream___2, "\t Main header start position=%li\n\t Main header end position=%li\n",
          cstr_index___2->main_head_start, cstr_index___2->main_head_end);
#line 11077
  fprintf(out_stream___2, "\t Marker list: {\n");
  }
#line 11079
  if (cstr_index___2->marker) {
#line 11080
    it_marker = (OPJ_UINT32 )0;
    {
#line 11080
    while (1) {
      while_continue: /* CIL Label */ ;

#line 11080
      if (! (it_marker < cstr_index___2->marknum)) {
#line 11080
        goto while_break;
      }
      {
#line 11081
      fprintf(out_stream___2, "\t\t type=%#x, pos=%li, len=%d\n", (int )(cstr_index___2->marker + it_marker)->type,
              (cstr_index___2->marker + it_marker)->pos, (cstr_index___2->marker + it_marker)->len);
#line 11080
      it_marker ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }

    while_break: ;
  }
  {
#line 11088
  fprintf(out_stream___2, "\t }\n");
  }
#line 11090
  if (cstr_index___2->tile_index) {
#line 11093
    l_acc_nb_of_tile_part = (OPJ_UINT32 )0;
#line 11094
    it_tile___0 = (OPJ_UINT32 )0;
    {
#line 11094
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 11094
      if (! (it_tile___0 < cstr_index___2->nb_of_tiles)) {
#line 11094
        goto while_break___0;
      }
#line 11095
      l_acc_nb_of_tile_part += (cstr_index___2->tile_index + it_tile___0)->nb_tps;
#line 11094
      it_tile___0 ++;
    }
    while_break___5: /* CIL Label */ ;
    }

    while_break___0: ;
#line 11098
    if (l_acc_nb_of_tile_part) {
      {
#line 11099
      fprintf(out_stream___2, "\t Tile index: {\n\220");
#line 11101
      it_tile___0 = (OPJ_UINT32 )0;
      }
      {
#line 11101
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 11101
        if (! (it_tile___0 < cstr_index___2->nb_of_tiles)) {
#line 11101
          goto while_break___1;
        }
        {
#line 11102
        nb_of_tile_part = (cstr_index___2->tile_index + it_tile___0)->nb_tps;
#line 11104
        fprintf(out_stream___2, "\t\t nb of tile-part in tile [%d]=%d\n", it_tile___0,
                nb_of_tile_part);
        }
#line 11107
        if ((cstr_index___2->tile_index + it_tile___0)->tp_index) {
#line 11108
          it_tile_part = (OPJ_UINT32 )0;
          {
#line 11108
          while (1) {
            while_continue___2: /* CIL Label */ ;

#line 11108
            if (! (it_tile_part < nb_of_tile_part)) {
#line 11108
              goto while_break___2;
            }
            {
#line 11109
            fprintf(out_stream___2, "\t\t\t tile-part[%d]: star_pos=%li, end_header=%li, end_pos=%li.\n",
                    it_tile_part, ((cstr_index___2->tile_index + it_tile___0)->tp_index + it_tile_part)->start_pos,
                    ((cstr_index___2->tile_index + it_tile___0)->tp_index + it_tile_part)->end_header,
                    ((cstr_index___2->tile_index + it_tile___0)->tp_index + it_tile_part)->end_pos);
#line 11108
            it_tile_part ++;
            }
          }
          while_break___7: /* CIL Label */ ;
          }

          while_break___2: ;
        }
#line 11118
        if ((cstr_index___2->tile_index + it_tile___0)->marker) {
#line 11119
          it_marker = (OPJ_UINT32 )0;
          {
#line 11119
          while (1) {
            while_continue___3: /* CIL Label */ ;

#line 11119
            if (! (it_marker < (cstr_index___2->tile_index + it_tile___0)->marknum)) {
#line 11119
              goto while_break___3;
            }
            {
#line 11121
            fprintf(out_stream___2, "\t\t type=%#x, pos=%li, len=%d\n", (int )((cstr_index___2->tile_index + it_tile___0)->marker + it_marker)->type,
                    ((cstr_index___2->tile_index + it_tile___0)->marker + it_marker)->pos,
                    ((cstr_index___2->tile_index + it_tile___0)->marker + it_marker)->len);
#line 11120
            it_marker ++;
            }
          }
          while_break___8: /* CIL Label */ ;
          }

          while_break___3: ;
        }
#line 11101
        it_tile___0 ++;
      }
      while_break___6: /* CIL Label */ ;
      }

      while_break___1: 
      {
#line 11128
      fprintf(out_stream___2, "\t }\n");
      }
    }
  }
  {
#line 11132
  fprintf(out_stream___2, "}\n");
  }
#line 11134
  return;
}
}
#line 11137 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static void opj_j2k_dump_MH_info(opj_j2k_t *p_j2k___88 , FILE *out_stream___3 ) 
{ 


  {
  {
#line 11140
  fprintf(out_stream___3, "Codestream info from main header: {\n");
#line 11142
  fprintf(out_stream___3, "\t tx0=%d, ty0=%d\n", p_j2k___88->m_cp.tx0, p_j2k___88->m_cp.ty0);
#line 11143
  fprintf(out_stream___3, "\t tdx=%d, tdy=%d\n", p_j2k___88->m_cp.tdx, p_j2k___88->m_cp.tdy);
#line 11144
  fprintf(out_stream___3, "\t tw=%d, th=%d\n", p_j2k___88->m_cp.tw, p_j2k___88->m_cp.th);
#line 11145
  opj_j2k_dump_tile_info(p_j2k___88->m_specific_param.m_decoder.m_default_tcp, (OPJ_INT32 )(p_j2k___88->m_private_image)->numcomps,
                         out_stream___3);
#line 11147
  fprintf(out_stream___3, "}\n");
  }
#line 11149
  return;
}
}
#line 11150 "/root/patron-new/39/src/lib/openjp2/j2k.c"
void j2k_dump_image_header(opj_image_t *img_header , OPJ_BOOL dev_dump_flag , FILE *out_stream___4 ) 
{ 
  char tab[2] ;
  OPJ_UINT32 compno___5 ;

  {
#line 11155
  if (dev_dump_flag) {
    {
#line 11156
    fprintf(stdout, "[DEV] Dump an image_header struct {\n");
#line 11157
    tab[0] = (char )'\000';
    }
  } else {
    {
#line 11159
    fprintf(out_stream___4, "Image info {\n");
#line 11160
    tab[0] = (char )'\t';
#line 11161
    tab[1] = (char )'\000';
    }
  }
  {
#line 11164
  fprintf(out_stream___4, "%s x0=%d, y0=%d\n\230\001", tab, img_header->x0, img_header->y0);
#line 11165
  fprintf(out_stream___4, "%s x1=%d, y1=%d\n\230\001", tab, img_header->x1, img_header->y1);
#line 11167
  fprintf(out_stream___4, "%s numcomps=%d\n", tab, img_header->numcomps);
  }
#line 11169
  if (img_header->comps) {
#line 11171
    compno___5 = (OPJ_UINT32 )0;
    {
#line 11171
    while (1) {
      while_continue: /* CIL Label */ ;

#line 11171
      if (! (compno___5 < img_header->numcomps)) {
#line 11171
        goto while_break;
      }
      {
#line 11172
      fprintf(out_stream___4, "%s\t component %d {\n", tab, compno___5);
#line 11173
      j2k_dump_image_comp_header(img_header->comps + compno___5, dev_dump_flag, out_stream___4);
#line 11175
      fprintf(out_stream___4, "%s}\n", tab);
#line 11171
      compno___5 ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }

    while_break: ;
  }
  {
#line 11179
  fprintf(out_stream___4, "}\n");
  }
#line 11181
  return;
}
}
#line 11182 "/root/patron-new/39/src/lib/openjp2/j2k.c"
void j2k_dump_image_comp_header(opj_image_comp_t *comp_header , OPJ_BOOL dev_dump_flag___0 ,
                                FILE *out_stream___5 ) 
{ 
  char tab___0[3] ;

  {
#line 11187
  if (dev_dump_flag___0) {
    {
#line 11188
    fprintf(stdout, "[DEV] Dump an image_comp_header struct {\n");
#line 11189
    tab___0[0] = (char )'\000';
    }
  } else {
#line 11191
    tab___0[0] = (char )'\t';
#line 11192
    tab___0[1] = (char )'\t';
#line 11193
    tab___0[2] = (char )'\000';
  }
  {
#line 11196
  fprintf(out_stream___5, "%s dx=%d, dy=%d\n\230\001", tab___0, comp_header->dx, comp_header->dy);
#line 11197
  fprintf(out_stream___5, "%s prec=%d\n", tab___0, comp_header->prec);
#line 11198
  fprintf(out_stream___5, "%s sgnd=%d\n", tab___0, comp_header->sgnd);
  }
#line 11200
  if (dev_dump_flag___0) {
    {
#line 11201
    fprintf(out_stream___5, "}\n");
    }
  }
#line 11204
  return;
}
}
#line 11205 "/root/patron-new/39/src/lib/openjp2/j2k.c"
opj_codestream_info_v2_t *j2k_get_cstr_info(opj_j2k_t *p_j2k___89 ) 
{ 
  OPJ_UINT32 compno___6 ;
  OPJ_UINT32 numcomps___3 ;
  opj_tcp_t *l_default_tile___0 ;
  opj_codestream_info_v2_t *cstr_info___0 ;
  void *__cil_tmp6___19 ;
  void *__cil_tmp7___28 ;
  opj_tccp_t *l_tccp___13 ;
  opj_tccp_info_t *l_tccp_info ;
  OPJ_INT32 bandno___0 ;
  OPJ_INT32 numbands___0 ;
  int tmp___402 ;

  {
  {
#line 11208
  numcomps___3 = (p_j2k___89->m_private_image)->numcomps;
#line 11210
  __cil_tmp6___19 = opj_calloc((size_t )1, sizeof(opj_codestream_info_v2_t ));
#line 11210
  cstr_info___0 = (opj_codestream_info_v2_t *)__cil_tmp6___19;
  }
#line 11212
  if (! cstr_info___0) {
#line 11213
    return ((opj_codestream_info_v2_t *)((void *)0));
  }
  {
#line 11216
  cstr_info___0->nbcomps = (p_j2k___89->m_private_image)->numcomps;
#line 11218
  cstr_info___0->tx0 = p_j2k___89->m_cp.tx0;
#line 11219
  cstr_info___0->ty0 = p_j2k___89->m_cp.ty0;
#line 11220
  cstr_info___0->tdx = p_j2k___89->m_cp.tdx;
#line 11221
  cstr_info___0->tdy = p_j2k___89->m_cp.tdy;
#line 11222
  cstr_info___0->tw = p_j2k___89->m_cp.tw;
#line 11223
  cstr_info___0->th = p_j2k___89->m_cp.th;
#line 11225
  cstr_info___0->tile_info = (opj_tile_info_v2_t *)((void *)0);
#line 11227
  l_default_tile___0 = p_j2k___89->m_specific_param.m_decoder.m_default_tcp;
#line 11229
  cstr_info___0->m_default_tile_info.csty = l_default_tile___0->csty;
#line 11230
  cstr_info___0->m_default_tile_info.prg = l_default_tile___0->prg;
#line 11231
  cstr_info___0->m_default_tile_info.numlayers = l_default_tile___0->numlayers;
#line 11232
  cstr_info___0->m_default_tile_info.mct = l_default_tile___0->mct;
#line 11234
  __cil_tmp7___28 = opj_calloc((size_t )cstr_info___0->nbcomps, sizeof(opj_tccp_info_t ));
#line 11234
  cstr_info___0->m_default_tile_info.tccp_info = (opj_tccp_info_t *)__cil_tmp7___28;
  }
#line 11236
  if (! cstr_info___0->m_default_tile_info.tccp_info) {
    {
#line 11237
    opj_destroy_cstr_info(& cstr_info___0);
    }
#line 11238
    return ((opj_codestream_info_v2_t *)((void *)0));
  }
#line 11241
  compno___6 = (OPJ_UINT32 )0;
  {
#line 11241
  while (1) {
    while_continue: /* CIL Label */ ;

#line 11241
    if (! (compno___6 < numcomps___3)) {
#line 11241
      goto while_break;
    }
#line 11242
    l_tccp___13 = l_default_tile___0->tccps + compno___6;
#line 11243
    l_tccp_info = cstr_info___0->m_default_tile_info.tccp_info + compno___6;
#line 11248
    l_tccp_info->csty = l_tccp___13->csty;
#line 11249
    l_tccp_info->numresolutions = l_tccp___13->numresolutions;
#line 11250
    l_tccp_info->cblkw = l_tccp___13->cblkw;
#line 11251
    l_tccp_info->cblkh = l_tccp___13->cblkh;
#line 11252
    l_tccp_info->cblksty = l_tccp___13->cblksty;
#line 11253
    l_tccp_info->qmfbid = l_tccp___13->qmfbid;
#line 11254
    if (l_tccp___13->numresolutions < 33U) {
      {
#line 11255
      memcpy((void *)(l_tccp_info->prch), (void const   *)(l_tccp___13->prch), (unsigned long )l_tccp___13->numresolutions);
#line 11256
      memcpy((void *)(l_tccp_info->prcw), (void const   *)(l_tccp___13->prcw), (unsigned long )l_tccp___13->numresolutions);
      }
    }
#line 11260
    l_tccp_info->qntsty = l_tccp___13->qntsty;
#line 11261
    l_tccp_info->numgbits = l_tccp___13->numgbits;
#line 11263
    if (l_tccp___13->qntsty == 1U) {
#line 11263
      tmp___402 = 1;
    } else {
#line 11263
      tmp___402 = (OPJ_INT32 )l_tccp___13->numresolutions * 3 - 2;
    }
#line 11263
    numbands___0 = tmp___402;
#line 11265
    if (numbands___0 < 97) {
#line 11266
      bandno___0 = 0;
      {
#line 11266
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 11266
        if (! (bandno___0 < numbands___0)) {
#line 11266
          goto while_break___0;
        }
#line 11267
        l_tccp_info->stepsizes_mant[bandno___0] = (OPJ_UINT32 )l_tccp___13->stepsizes[bandno___0].mant;
#line 11269
        l_tccp_info->stepsizes_expn[bandno___0] = (OPJ_UINT32 )l_tccp___13->stepsizes[bandno___0].expn;
#line 11266
        bandno___0 ++;
      }
      while_break___2: /* CIL Label */ ;
      }

      while_break___0: ;
    }
#line 11275
    l_tccp_info->roishift = l_tccp___13->roishift;
#line 11241
    compno___6 ++;
  }
  while_break___1: /* CIL Label */ ;
  }

  while_break: ;
#line 11278
  return (cstr_info___0);
}
}
#line 11281 "/root/patron-new/39/src/lib/openjp2/j2k.c"
opj_codestream_index_t *j2k_get_cstr_index(opj_j2k_t *p_j2k___90 ) 
{ 
  opj_codestream_index_t *l_cstr_index___1 ;
  void *__cil_tmp3___24 ;
  void *__cil_tmp4___16 ;
  void *__cil_tmp5___23 ;
  OPJ_UINT32 it_tile___1 ;
  void *__cil_tmp7___29 ;
  OPJ_UINT32 it_tile_free ;
  void *__cil_tmp10___13 ;
  OPJ_UINT32 it_tile_free___0 ;

  {
  {
#line 11283
  __cil_tmp3___24 = opj_calloc((size_t )1, sizeof(opj_codestream_index_t ));
#line 11283
  l_cstr_index___1 = (opj_codestream_index_t *)__cil_tmp3___24;
  }
#line 11285
  if (! l_cstr_index___1) {
#line 11286
    return ((opj_codestream_index_t *)((void *)0));
  }
  {
#line 11289
  l_cstr_index___1->main_head_start = (p_j2k___90->cstr_index)->main_head_start;
#line 11290
  l_cstr_index___1->main_head_end = (p_j2k___90->cstr_index)->main_head_end;
#line 11291
  l_cstr_index___1->codestream_size = (p_j2k___90->cstr_index)->codestream_size;
#line 11293
  l_cstr_index___1->marknum = (p_j2k___90->cstr_index)->marknum;
#line 11294
  __cil_tmp4___16 = opj_malloc((unsigned long )l_cstr_index___1->marknum * sizeof(opj_marker_info_t ));
#line 11294
  l_cstr_index___1->marker = (opj_marker_info_t *)__cil_tmp4___16;
  }
#line 11296
  if (! l_cstr_index___1->marker) {
    {
#line 11297
    opj_free((void *)l_cstr_index___1);
    }
#line 11298
    return ((opj_codestream_index_t *)((void *)0));
  }
#line 11301
  if ((p_j2k___90->cstr_index)->marker) {
    {
#line 11302
    memcpy((void *)l_cstr_index___1->marker, (void const   *)(p_j2k___90->cstr_index)->marker,
           (unsigned long )l_cstr_index___1->marknum * sizeof(opj_marker_info_t ));
    }
  } else {
    {
#line 11305
    opj_free((void *)l_cstr_index___1->marker);
#line 11306
    l_cstr_index___1->marker = (opj_marker_info_t *)((void *)0);
    }
  }
  {
#line 11309
  l_cstr_index___1->nb_of_tiles = (p_j2k___90->cstr_index)->nb_of_tiles;
#line 11310
  __cil_tmp5___23 = opj_calloc((size_t )l_cstr_index___1->nb_of_tiles, sizeof(opj_tile_index_t ));
#line 11310
  l_cstr_index___1->tile_index = (opj_tile_index_t *)__cil_tmp5___23;
  }
#line 11312
  if (! l_cstr_index___1->tile_index) {
    {
#line 11313
    opj_free((void *)l_cstr_index___1->marker);
#line 11314
    opj_free((void *)l_cstr_index___1);
    }
#line 11315
    return ((opj_codestream_index_t *)((void *)0));
  }
#line 11318
  if (! (p_j2k___90->cstr_index)->tile_index) {
    {
#line 11319
    opj_free((void *)l_cstr_index___1->tile_index);
#line 11320
    l_cstr_index___1->tile_index = (opj_tile_index_t *)((void *)0);
    }
  } else {
#line 11322
    it_tile___1 = (OPJ_UINT32 )0;
#line 11323
    it_tile___1 = (OPJ_UINT32 )0;
    {
#line 11323
    while (1) {
      while_continue: /* CIL Label */ ;

#line 11323
      if (! (it_tile___1 < l_cstr_index___1->nb_of_tiles)) {
#line 11323
        goto while_break;
      }
      {
#line 11326
      (l_cstr_index___1->tile_index + it_tile___1)->marknum = ((p_j2k___90->cstr_index)->tile_index + it_tile___1)->marknum;
#line 11329
      __cil_tmp7___29 = opj_malloc((unsigned long )(l_cstr_index___1->tile_index + it_tile___1)->marknum * sizeof(opj_marker_info_t ));
#line 11329
      (l_cstr_index___1->tile_index + it_tile___1)->marker = (opj_marker_info_t *)__cil_tmp7___29;
      }
#line 11333
      if (! (l_cstr_index___1->tile_index + it_tile___1)->marker) {
#line 11336
        it_tile_free = (OPJ_UINT32 )0;
        {
#line 11336
        while (1) {
          while_continue___0: /* CIL Label */ ;

#line 11336
          if (! (it_tile_free < it_tile___1)) {
#line 11336
            goto while_break___0;
          }
          {
#line 11337
          opj_free((void *)(l_cstr_index___1->tile_index + it_tile_free)->marker);
#line 11336
          it_tile_free ++;
          }
        }
        while_break___3: /* CIL Label */ ;
        }

        while_break___0: 
        {
#line 11340
        opj_free((void *)l_cstr_index___1->tile_index);
#line 11341
        opj_free((void *)l_cstr_index___1->marker);
#line 11342
        opj_free((void *)l_cstr_index___1);
        }
#line 11343
        return ((opj_codestream_index_t *)((void *)0));
      }
#line 11346
      if (((p_j2k___90->cstr_index)->tile_index + it_tile___1)->marker) {
        {
#line 11347
        memcpy((void *)(l_cstr_index___1->tile_index + it_tile___1)->marker, (void const   *)((p_j2k___90->cstr_index)->tile_index + it_tile___1)->marker,
               (unsigned long )(l_cstr_index___1->tile_index + it_tile___1)->marknum * sizeof(opj_marker_info_t ));
        }
      } else {
        {
#line 11351
        opj_free((void *)(l_cstr_index___1->tile_index + it_tile___1)->marker);
#line 11352
        (l_cstr_index___1->tile_index + it_tile___1)->marker = (opj_marker_info_t *)((void *)0);
        }
      }
      {
#line 11356
      (l_cstr_index___1->tile_index + it_tile___1)->nb_tps = ((p_j2k___90->cstr_index)->tile_index + it_tile___1)->nb_tps;
#line 11359
      __cil_tmp10___13 = opj_malloc((unsigned long )(l_cstr_index___1->tile_index + it_tile___1)->nb_tps * sizeof(opj_tp_index_t ));
#line 11359
      (l_cstr_index___1->tile_index + it_tile___1)->tp_index = (opj_tp_index_t *)__cil_tmp10___13;
      }
#line 11363
      if (! (l_cstr_index___1->tile_index + it_tile___1)->tp_index) {
#line 11366
        it_tile_free___0 = (OPJ_UINT32 )0;
        {
#line 11366
        while (1) {
          while_continue___1: /* CIL Label */ ;

#line 11366
          if (! (it_tile_free___0 < it_tile___1)) {
#line 11366
            goto while_break___1;
          }
          {
#line 11367
          opj_free((void *)(l_cstr_index___1->tile_index + it_tile_free___0)->marker);
#line 11368
          opj_free((void *)(l_cstr_index___1->tile_index + it_tile_free___0)->tp_index);
#line 11366
          it_tile_free___0 ++;
          }
        }
        while_break___4: /* CIL Label */ ;
        }

        while_break___1: 
        {
#line 11371
        opj_free((void *)l_cstr_index___1->tile_index);
#line 11372
        opj_free((void *)l_cstr_index___1->marker);
#line 11373
        opj_free((void *)l_cstr_index___1);
        }
#line 11374
        return ((opj_codestream_index_t *)((void *)0));
      }
#line 11377
      if (((p_j2k___90->cstr_index)->tile_index + it_tile___1)->tp_index) {
        {
#line 11378
        memcpy((void *)(l_cstr_index___1->tile_index + it_tile___1)->tp_index, (void const   *)((p_j2k___90->cstr_index)->tile_index + it_tile___1)->tp_index,
               (unsigned long )(l_cstr_index___1->tile_index + it_tile___1)->nb_tps * sizeof(opj_tp_index_t ));
        }
      } else {
        {
#line 11382
        opj_free((void *)(l_cstr_index___1->tile_index + it_tile___1)->tp_index);
#line 11383
        (l_cstr_index___1->tile_index + it_tile___1)->tp_index = (opj_tp_index_t *)((void *)0);
        }
      }
#line 11387
      (l_cstr_index___1->tile_index + it_tile___1)->nb_packet = (OPJ_UINT32 )0;
#line 11388
      (l_cstr_index___1->tile_index + it_tile___1)->packet_index = (opj_packet_info_t *)((void *)0);
#line 11323
      it_tile___1 ++;
    }
    while_break___2: /* CIL Label */ ;
    }

    while_break: ;
  }
#line 11393
  return (l_cstr_index___1);
}
}
#line 11396 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_allocate_tile_element_cstr_index(opj_j2k_t *p_j2k___91 ) 
{ 
  OPJ_UINT32 it_tile___2 ;
  void *__cil_tmp3___25 ;
  void *__cil_tmp4___17 ;

  {
  {
#line 11398
  it_tile___2 = (OPJ_UINT32 )0;
#line 11400
  (p_j2k___91->cstr_index)->nb_of_tiles = p_j2k___91->m_cp.tw * p_j2k___91->m_cp.th;
#line 11401
  __cil_tmp3___25 = opj_calloc((size_t )(p_j2k___91->cstr_index)->nb_of_tiles, sizeof(opj_tile_index_t ));
#line 11401
  (p_j2k___91->cstr_index)->tile_index = (opj_tile_index_t *)__cil_tmp3___25;
  }
#line 11403
  if (! (p_j2k___91->cstr_index)->tile_index) {
#line 11404
    return (0);
  }
#line 11407
  it_tile___2 = (OPJ_UINT32 )0;
  {
#line 11407
  while (1) {
    while_continue: /* CIL Label */ ;

#line 11407
    if (! (it_tile___2 < (p_j2k___91->cstr_index)->nb_of_tiles)) {
#line 11407
      goto while_break;
    }
    {
#line 11408
    ((p_j2k___91->cstr_index)->tile_index + it_tile___2)->maxmarknum = (OPJ_UINT32 )100;
#line 11409
    ((p_j2k___91->cstr_index)->tile_index + it_tile___2)->marknum = (OPJ_UINT32 )0;
#line 11410
    __cil_tmp4___17 = opj_calloc((size_t )((p_j2k___91->cstr_index)->tile_index + it_tile___2)->maxmarknum,
                                 sizeof(opj_marker_info_t ));
#line 11410
    ((p_j2k___91->cstr_index)->tile_index + it_tile___2)->marker = (opj_marker_info_t *)__cil_tmp4___17;
    }
#line 11413
    if (! ((p_j2k___91->cstr_index)->tile_index + it_tile___2)->marker) {
#line 11414
      return (0);
    }
#line 11407
    it_tile___2 ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 11418
  return (1);
}
}
#line 11421 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_are_all_used_components_decoded(opj_j2k_t *p_j2k___92 , opj_event_mgr_t *p_manager___124 ) 
{ 
  OPJ_UINT32 compno___7 ;
  OPJ_BOOL decoded_all_used_components ;
  OPJ_UINT32 dec_compno ;

  {
#line 11425
  decoded_all_used_components = 1;
#line 11427
  if (p_j2k___92->m_specific_param.m_decoder.m_numcomps_to_decode) {
#line 11428
    compno___7 = (OPJ_UINT32 )0;
    {
#line 11428
    while (1) {
      while_continue: /* CIL Label */ ;

#line 11428
      if (! (compno___7 < p_j2k___92->m_specific_param.m_decoder.m_numcomps_to_decode)) {
#line 11428
        goto while_break;
      }
#line 11430
      dec_compno = *(p_j2k___92->m_specific_param.m_decoder.m_comps_indices_to_decode + compno___7);
#line 11432
      if ((unsigned long )((p_j2k___92->m_output_image)->comps + dec_compno)->data == (unsigned long )((void *)0)) {
        {
#line 11433
        opj_event_msg(p_manager___124, 2, "Failed to decode component %d\n", dec_compno);
#line 11435
        decoded_all_used_components = 0;
        }
      }
#line 11429
      compno___7 ++;
    }
    while_break___1: /* CIL Label */ ;
    }

    while_break: ;
  } else {
#line 11439
    compno___7 = (OPJ_UINT32 )0;
    {
#line 11439
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 11439
      if (! (compno___7 < (p_j2k___92->m_output_image)->numcomps)) {
#line 11439
        goto while_break___0;
      }
#line 11440
      if ((unsigned long )((p_j2k___92->m_output_image)->comps + compno___7)->data == (unsigned long )((void *)0)) {
        {
#line 11441
        opj_event_msg(p_manager___124, 2, "Failed to decode component %d\n", compno___7);
#line 11443
        decoded_all_used_components = 0;
        }
      }
#line 11439
      compno___7 ++;
    }
    while_break___2: /* CIL Label */ ;
    }

    while_break___0: ;
  }
#line 11448
  if (decoded_all_used_components == 0) {
    {
#line 11449
    opj_event_msg(p_manager___124, 1, "Failed to decode all used components\nU");
    }
#line 11450
    return (0);
  }
#line 11453
  return (1);
}
}
#line 11457 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_decode_tiles(opj_j2k_t *p_j2k___93 , opj_stream_private_t *p_stream___55 ,
                                     opj_event_mgr_t *p_manager___125 ) 
{ 
  OPJ_BOOL l_go_on ;
  OPJ_UINT32 l_current_tile_no ;
  OPJ_INT32 l_tile_x0 ;
  OPJ_INT32 l_tile_y0 ;
  OPJ_INT32 l_tile_x1 ;
  OPJ_INT32 l_tile_y1 ;
  OPJ_UINT32 l_nb_comps___1 ;
  OPJ_UINT32 nr_tiles ;
  OPJ_UINT32 i___78 ;
  OPJ_BOOL __cil_tmp13___28 ;
  OPJ_BOOL __cil_tmp14___32 ;
  OPJ_BOOL __cil_tmp16___18 ;
  OPJ_BOOL __cil_tmp17___17 ;
  OPJ_BOOL __cil_tmp18___10 ;
  OPJ_OFF_T __cil_tmp19___14 ;
  OPJ_BOOL __cil_tmp20___13 ;

  {
#line 11461
  l_go_on = 1;
#line 11465
  nr_tiles = (OPJ_UINT32 )0;
#line 11469
  if (p_j2k___93->m_cp.tw == 1U) {
#line 11469
    if (p_j2k___93->m_cp.th == 1U) {
#line 11469
      if (p_j2k___93->m_cp.tx0 == 0U) {
#line 11469
        if (p_j2k___93->m_cp.ty0 == 0U) {
#line 11469
          if ((p_j2k___93->m_output_image)->x0 == 0U) {
#line 11469
            if ((p_j2k___93->m_output_image)->y0 == 0U) {
#line 11469
              if ((p_j2k___93->m_output_image)->x1 == p_j2k___93->m_cp.tdx) {
#line 11469
                if ((p_j2k___93->m_output_image)->y1 == p_j2k___93->m_cp.tdy) {
                  {
#line 11476
                  __cil_tmp13___28 = opj_j2k_read_tile_header(p_j2k___93, & l_current_tile_no,
                                                              (OPJ_UINT32 *)((void *)0),
                                                              & l_tile_x0, & l_tile_y0,
                                                              & l_tile_x1, & l_tile_y1,
                                                              & l_nb_comps___1, & l_go_on,
                                                              p_stream___55, p_manager___125);
                  }
#line 11476
                  if (! __cil_tmp13___28) {
#line 11485
                    return (0);
                  }
                  {
#line 11488
                  __cil_tmp14___32 = opj_j2k_decode_tile(p_j2k___93, l_current_tile_no,
                                                         (OPJ_BYTE *)((void *)0),
                                                         (OPJ_UINT32 )0, p_stream___55,
                                                         p_manager___125);
                  }
#line 11488
                  if (! __cil_tmp14___32) {
                    {
#line 11490
                    opj_event_msg(p_manager___125, 1, "Failed to decode tile 1/1\n");
                    }
#line 11491
                    return (0);
                  }
#line 11495
                  i___78 = (OPJ_UINT32 )0;
                  {
#line 11495
                  while (1) {
                    while_continue: /* CIL Label */ ;

#line 11495
                    if (! (i___78 < (p_j2k___93->m_output_image)->numcomps)) {
#line 11495
                      goto while_break;
                    }
                    {
#line 11496
                    opj_image_data_free((void *)((p_j2k___93->m_output_image)->comps + i___78)->data);
#line 11497
                    ((p_j2k___93->m_output_image)->comps + i___78)->data = ((((p_j2k___93->m_tcd)->tcd_image)->tiles)->comps + i___78)->data;
#line 11499
                    ((p_j2k___93->m_output_image)->comps + i___78)->resno_decoded = (((p_j2k___93->m_tcd)->image)->comps + i___78)->resno_decoded;
#line 11501
                    ((((p_j2k___93->m_tcd)->tcd_image)->tiles)->comps + i___78)->data = (OPJ_INT32 *)((void *)0);
#line 11495
                    i___78 ++;
                    }
                  }
                  while_break___1: /* CIL Label */ ;
                  }

                  while_break: ;
#line 11504
                  return (1);
                }
              }
            }
          }
        }
      }
    }
  }
  {
#line 11507
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 11508
    if ((unsigned long )(p_j2k___93->m_cp.tcps + 0)->m_data != (unsigned long )((void *)0)) {
#line 11508
      if (p_j2k___93->m_cp.tw == 1U) {
#line 11508
        if (p_j2k___93->m_cp.th == 1U) {
#line 11510
          l_current_tile_no = (OPJ_UINT32 )0;
#line 11511
          p_j2k___93->m_current_tile_number = (OPJ_UINT32 )0;
#line 11512
          p_j2k___93->m_specific_param.m_decoder.m_state |= 128U;
        } else {
#line 11508
          goto _L;
        }
      } else {
#line 11508
        goto _L;
      }
    } else {
      _L: 
      {
#line 11514
      __cil_tmp16___18 = opj_j2k_read_tile_header(p_j2k___93, & l_current_tile_no,
                                                  (OPJ_UINT32 *)((void *)0), & l_tile_x0,
                                                  & l_tile_y0, & l_tile_x1, & l_tile_y1,
                                                  & l_nb_comps___1, & l_go_on, p_stream___55,
                                                  p_manager___125);
      }
#line 11514
      if (! __cil_tmp16___18) {
#line 11523
        return (0);
      }
#line 11526
      if (! l_go_on) {
#line 11527
        goto while_break___0;
      }
    }
    {
#line 11531
    __cil_tmp17___17 = opj_j2k_decode_tile(p_j2k___93, l_current_tile_no, (OPJ_BYTE *)((void *)0),
                                           (OPJ_UINT32 )0, p_stream___55, p_manager___125);
    }
#line 11531
    if (! __cil_tmp17___17) {
      {
#line 11533
      opj_event_msg(p_manager___125, 1, "Failed to decode tile %d/%d\n]U", l_current_tile_no + 1U,
                    p_j2k___93->m_cp.th * p_j2k___93->m_cp.tw);
      }
#line 11535
      return (0);
    }
    {
#line 11538
    opj_event_msg(p_manager___125, 4, "Tile %d/%d has been decoded.\n", l_current_tile_no + 1U,
                  p_j2k___93->m_cp.th * p_j2k___93->m_cp.tw);
#line 11541
    __cil_tmp18___10 = opj_j2k_update_image_data(p_j2k___93->m_tcd, p_j2k___93->m_output_image);
    }
#line 11541
    if (! __cil_tmp18___10) {
#line 11543
      return (0);
    }
#line 11546
    if (p_j2k___93->m_cp.tw == 1U) {
#line 11546
      if (p_j2k___93->m_cp.th == 1U) {
#line 11546
        if ((p_j2k___93->m_output_image)->x0 == (p_j2k___93->m_private_image)->x0) {
#line 11546
          if ((p_j2k___93->m_output_image)->y0 == (p_j2k___93->m_private_image)->y0) {
#line 11546
            if ((p_j2k___93->m_output_image)->x1 == (p_j2k___93->m_private_image)->x1) {
#line 11546
              if ((p_j2k___93->m_output_image)->y1 == (p_j2k___93->m_private_image)->y1) {
                {
#line 11553
                opj_j2k_tcp_data_destroy(p_j2k___93->m_cp.tcps + l_current_tile_no);
                }
              }
            }
          }
        }
      } else {
        {
#line 11553
        opj_j2k_tcp_data_destroy(p_j2k___93->m_cp.tcps + l_current_tile_no);
        }
      }
    } else {
      {
#line 11553
      opj_j2k_tcp_data_destroy(p_j2k___93->m_cp.tcps + l_current_tile_no);
      }
    }
    {
#line 11556
    opj_event_msg(p_manager___125, 4, "Image data has been updated with tile %d.\n\n",
                  l_current_tile_no + 1U);
#line 11559
    __cil_tmp19___14 = opj_stream_get_number_byte_left(p_stream___55);
    }
#line 11559
    if (__cil_tmp19___14 == 0L) {
#line 11559
      if (p_j2k___93->m_specific_param.m_decoder.m_state == 64U) {
#line 11561
        goto while_break___0;
      }
    }
#line 11563
    nr_tiles ++;
#line 11563
    if (nr_tiles == p_j2k___93->m_cp.th * p_j2k___93->m_cp.tw) {
#line 11564
      goto while_break___0;
    }
  }
  while_break___2: /* CIL Label */ ;
  }

  while_break___0: 
  {
#line 11568
  __cil_tmp20___13 = opj_j2k_are_all_used_components_decoded(p_j2k___93, p_manager___125);
  }
#line 11568
  if (! __cil_tmp20___13) {
#line 11569
    return (0);
  }
#line 11572
  return (1);
}
}
#line 11578 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_setup_decoding(opj_j2k_t *p_j2k___94 , opj_event_mgr_t *p_manager___126 ) 
{ 
  OPJ_BOOL __cil_tmp5___25 ;

  {
  {
#line 11585
  __cil_tmp5___25 = opj_procedure_list_add_procedure(p_j2k___94->m_procedure_list,
                                                     (void (*)(void))(& opj_j2k_decode_tiles),
                                                     p_manager___126);
  }
#line 11585
  if (! __cil_tmp5___25) {
#line 11587
    return (0);
  }
#line 11591
  return (1);
}
}
#line 11597 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_decode_one_tile(opj_j2k_t *p_j2k___95 , opj_stream_private_t *p_stream___56 ,
                                        opj_event_mgr_t *p_manager___127 ) 
{ 
  OPJ_BOOL l_go_on___0 ;
  OPJ_UINT32 l_current_tile_no___0 ;
  OPJ_UINT32 l_tile_no_to_dec ;
  OPJ_INT32 l_tile_x0___0 ;
  OPJ_INT32 l_tile_y0___0 ;
  OPJ_INT32 l_tile_x1___0 ;
  OPJ_INT32 l_tile_y1___0 ;
  OPJ_UINT32 l_nb_comps___2 ;
  OPJ_UINT32 l_nb_tiles___10 ;
  OPJ_UINT32 i___79 ;
  OPJ_BOOL __cil_tmp14___33 ;
  OPJ_BOOL __cil_tmp15___24 ;
  OPJ_BOOL __cil_tmp16___19 ;
  OPJ_BOOL __cil_tmp17___18 ;
  OPJ_BOOL __cil_tmp18___11 ;
  OPJ_BOOL __cil_tmp19___15 ;
  OPJ_BOOL __cil_tmp20___14 ;
  OPJ_BOOL __cil_tmp21___8 ;

  {
#line 11601
  l_go_on___0 = 1;
#line 11610
  if (! (p_j2k___95->cstr_index)->tile_index) {
    {
#line 11611
    __cil_tmp14___33 = opj_j2k_allocate_tile_element_cstr_index(p_j2k___95);
    }
#line 11611
    if (! __cil_tmp14___33) {
#line 11612
      return (0);
    }
  }
#line 11616
  l_tile_no_to_dec = (OPJ_UINT32 )p_j2k___95->m_specific_param.m_decoder.m_tile_ind_to_dec;
#line 11618
  if ((p_j2k___95->cstr_index)->tile_index) {
#line 11619
    if (((p_j2k___95->cstr_index)->tile_index)->tp_index) {
#line 11620
      if (! ((p_j2k___95->cstr_index)->tile_index + l_tile_no_to_dec)->nb_tps) {
        {
#line 11623
        __cil_tmp15___24 = opj_stream_read_seek(p_stream___56, p_j2k___95->m_specific_param.m_decoder.m_last_sot_read_pos + 2L,
                                                p_manager___127);
        }
#line 11623
        if (! __cil_tmp15___24) {
          {
#line 11625
          opj_event_msg(p_manager___127, 1, "Problem with seek function\n");
          }
#line 11626
          return (0);
        }
      } else {
        {
#line 11629
        __cil_tmp16___19 = opj_stream_read_seek(p_stream___56, (((p_j2k___95->cstr_index)->tile_index + l_tile_no_to_dec)->tp_index + 0)->start_pos + 2L,
                                                p_manager___127);
        }
#line 11629
        if (! __cil_tmp16___19) {
          {
#line 11632
          opj_event_msg(p_manager___127, 1, "Problem with seek function\n\005]U");
          }
#line 11633
          return (0);
        }
      }
#line 11637
      if (p_j2k___95->m_specific_param.m_decoder.m_state == 256U) {
#line 11638
        p_j2k___95->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )8;
      }
    }
  }
#line 11646
  l_nb_tiles___10 = p_j2k___95->m_cp.tw * p_j2k___95->m_cp.th;
#line 11647
  i___79 = (OPJ_UINT32 )0;
  {
#line 11647
  while (1) {
    while_continue: /* CIL Label */ ;

#line 11647
    if (! (i___79 < l_nb_tiles___10)) {
#line 11647
      goto while_break;
    }
#line 11648
    (p_j2k___95->m_cp.tcps + i___79)->m_current_tile_part_number = -1;
#line 11647
    i___79 ++;
  }
  while_break___1: /* CIL Label */ ;
  }

  while_break: ;
  {
#line 11651
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 11652
    __cil_tmp17___18 = opj_j2k_read_tile_header(p_j2k___95, & l_current_tile_no___0,
                                                (OPJ_UINT32 *)((void *)0), & l_tile_x0___0,
                                                & l_tile_y0___0, & l_tile_x1___0,
                                                & l_tile_y1___0, & l_nb_comps___2,
                                                & l_go_on___0, p_stream___56, p_manager___127);
    }
#line 11652
    if (! __cil_tmp17___18) {
#line 11661
      return (0);
    }
#line 11664
    if (! l_go_on___0) {
#line 11665
      goto while_break___0;
    }
    {
#line 11668
    __cil_tmp18___11 = opj_j2k_decode_tile(p_j2k___95, l_current_tile_no___0, (OPJ_BYTE *)((void *)0),
                                           (OPJ_UINT32 )0, p_stream___56, p_manager___127);
    }
#line 11668
    if (! __cil_tmp18___11) {
#line 11670
      return (0);
    }
    {
#line 11672
    opj_event_msg(p_manager___127, 4, "Tile %d/%d has been decoded.\nU", l_current_tile_no___0 + 1U,
                  p_j2k___95->m_cp.th * p_j2k___95->m_cp.tw);
#line 11675
    __cil_tmp19___15 = opj_j2k_update_image_data(p_j2k___95->m_tcd, p_j2k___95->m_output_image);
    }
#line 11675
    if (! __cil_tmp19___15) {
#line 11677
      return (0);
    }
    {
#line 11679
    opj_j2k_tcp_data_destroy(p_j2k___95->m_cp.tcps + l_current_tile_no___0);
#line 11681
    opj_event_msg(p_manager___127, 4, "Image data has been updated with tile %d.\n\n",
                  l_current_tile_no___0 + 1U);
    }
#line 11684
    if (l_current_tile_no___0 == l_tile_no_to_dec) {
      {
#line 11686
      __cil_tmp20___14 = opj_stream_read_seek(p_stream___56, (p_j2k___95->cstr_index)->main_head_end + 2L,
                                              p_manager___127);
      }
#line 11686
      if (! __cil_tmp20___14) {
        {
#line 11688
        opj_event_msg(p_manager___127, 1, "Problem with seek function\n");
        }
#line 11689
        return (0);
      }
#line 11691
      goto while_break___0;
    } else {
      {
#line 11693
      opj_event_msg(p_manager___127, 2, "Tile read, decoded and updated is not the desired one (%d vs %d).\n\253\005]U",
                    l_current_tile_no___0 + 1U, l_tile_no_to_dec + 1U);
      }
    }
  }
  while_break___2: /* CIL Label */ ;
  }

  while_break___0: 
  {
#line 11700
  __cil_tmp21___8 = opj_j2k_are_all_used_components_decoded(p_j2k___95, p_manager___127);
  }
#line 11700
  if (! __cil_tmp21___8) {
#line 11701
    return (0);
  }
#line 11704
  return (1);
}
}
#line 11710 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_setup_decoding_tile(opj_j2k_t *p_j2k___96 , opj_event_mgr_t *p_manager___128 ) 
{ 
  OPJ_BOOL __cil_tmp5___26 ;

  {
  {
#line 11717
  __cil_tmp5___26 = opj_procedure_list_add_procedure(p_j2k___96->m_procedure_list,
                                                     (void (*)(void))(& opj_j2k_decode_one_tile),
                                                     p_manager___128);
  }
#line 11717
  if (! __cil_tmp5___26) {
#line 11719
    return (0);
  }
#line 11723
  return (1);
}
}
#line 11726 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_move_data_from_codec_to_output_image(opj_j2k_t *p_j2k___97 ,
                                                             opj_image_t *p_image___15 ) 
{ 
  OPJ_UINT32 compno___8 ;
  opj_image_comp_t *newcomps ;
  void *__cil_tmp5___27 ;
  OPJ_UINT32 src_compno ;

  {
#line 11732
  if (p_j2k___97->m_specific_param.m_decoder.m_numcomps_to_decode > 0U) {
    {
#line 11733
    __cil_tmp5___27 = opj_malloc((unsigned long )p_j2k___97->m_specific_param.m_decoder.m_numcomps_to_decode * sizeof(opj_image_comp_t ));
#line 11733
    newcomps = (opj_image_comp_t *)__cil_tmp5___27;
    }
#line 11737
    if ((unsigned long )newcomps == (unsigned long )((void *)0)) {
      {
#line 11738
      opj_image_destroy(p_j2k___97->m_private_image);
#line 11739
      p_j2k___97->m_private_image = (opj_image_t *)((void *)0);
      }
#line 11740
      return (0);
    }
#line 11742
    compno___8 = (OPJ_UINT32 )0;
    {
#line 11742
    while (1) {
      while_continue: /* CIL Label */ ;

#line 11742
      if (! (compno___8 < p_image___15->numcomps)) {
#line 11742
        goto while_break;
      }
      {
#line 11743
      opj_image_data_free((void *)(p_image___15->comps + compno___8)->data);
#line 11744
      (p_image___15->comps + compno___8)->data = (OPJ_INT32 *)((void *)0);
#line 11742
      compno___8 ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }

    while_break: 
#line 11746
    compno___8 = (OPJ_UINT32 )0;
    {
#line 11746
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 11746
      if (! (compno___8 < p_j2k___97->m_specific_param.m_decoder.m_numcomps_to_decode)) {
#line 11746
        goto while_break___0;
      }
      {
#line 11748
      src_compno = *(p_j2k___97->m_specific_param.m_decoder.m_comps_indices_to_decode + compno___8);
#line 11750
      memcpy((void *)(newcomps + compno___8), (void const   *)((p_j2k___97->m_output_image)->comps + src_compno),
             sizeof(opj_image_comp_t ));
#line 11753
      (newcomps + compno___8)->resno_decoded = ((p_j2k___97->m_output_image)->comps + src_compno)->resno_decoded;
#line 11755
      (newcomps + compno___8)->data = ((p_j2k___97->m_output_image)->comps + src_compno)->data;
#line 11756
      ((p_j2k___97->m_output_image)->comps + src_compno)->data = (OPJ_INT32 *)((void *)0);
#line 11747
      compno___8 ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }

    while_break___0: 
#line 11758
    compno___8 = (OPJ_UINT32 )0;
    {
#line 11758
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 11758
      if (! (compno___8 < p_image___15->numcomps)) {
#line 11758
        goto while_break___1;
      }
      {
#line 11760
      opj_image_data_free((void *)((p_j2k___97->m_output_image)->comps + compno___8)->data);
#line 11761
      ((p_j2k___97->m_output_image)->comps + compno___8)->data = (OPJ_INT32 *)((void *)0);
#line 11758
      compno___8 ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }

    while_break___1: 
    {
#line 11763
    p_image___15->numcomps = p_j2k___97->m_specific_param.m_decoder.m_numcomps_to_decode;
#line 11764
    opj_free((void *)p_image___15->comps);
#line 11765
    p_image___15->comps = newcomps;
    }
  } else {
#line 11767
    compno___8 = (OPJ_UINT32 )0;
    {
#line 11767
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 11767
      if (! (compno___8 < p_image___15->numcomps)) {
#line 11767
        goto while_break___2;
      }
      {
#line 11768
      (p_image___15->comps + compno___8)->resno_decoded = ((p_j2k___97->m_output_image)->comps + compno___8)->resno_decoded;
#line 11770
      opj_image_data_free((void *)(p_image___15->comps + compno___8)->data);
#line 11771
      (p_image___15->comps + compno___8)->data = ((p_j2k___97->m_output_image)->comps + compno___8)->data;
#line 11780
      ((p_j2k___97->m_output_image)->comps + compno___8)->data = (OPJ_INT32 *)((void *)0);
#line 11767
      compno___8 ++;
      }
    }
    while_break___6: /* CIL Label */ ;
    }

    while_break___2: ;
  }
#line 11783
  return (1);
}
}
#line 11786 "/root/patron-new/39/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_decode(opj_j2k_t *p_j2k___98 , opj_stream_private_t *p_stream___57 ,
                        opj_image_t *p_image___16 , opj_event_mgr_t *p_manager___129 ) 
{ 
  OPJ_UINT32 it_comp___1 ;
  OPJ_BOOL __cil_tmp6___22 ;
  OPJ_BOOL __cil_tmp8___44 ;
  OPJ_BOOL __cil_tmp9___24 ;
  OPJ_BOOL __cil_tmp10___15 ;

  {
#line 11791
  if (! p_image___16) {
#line 11792
    return (0);
  }
#line 11799
  if ((unsigned long )p_j2k___98->m_private_image != (unsigned long )((void *)0)) {
#line 11799
    if (p_j2k___98->m_cp.m_specific_param.m_dec.m_reduce > 0U) {
#line 11799
      if ((p_j2k___98->m_private_image)->numcomps > 0U) {
#line 11799
        if (((p_j2k___98->m_private_image)->comps + 0)->factor == p_j2k___98->m_cp.m_specific_param.m_dec.m_reduce) {
#line 11799
          if (p_image___16->numcomps > 0U) {
#line 11799
            if ((p_image___16->comps + 0)->factor == 0U) {
#line 11799
              if ((unsigned long )(p_image___16->comps + 0)->data == (unsigned long )((void *)0)) {
#line 11812
                it_comp___1 = (OPJ_UINT32 )0;
                {
#line 11812
                while (1) {
                  while_continue: /* CIL Label */ ;

#line 11812
                  if (! (it_comp___1 < p_image___16->numcomps)) {
#line 11812
                    goto while_break;
                  }
#line 11813
                  (p_image___16->comps + it_comp___1)->factor = p_j2k___98->m_cp.m_specific_param.m_dec.m_reduce;
#line 11812
                  it_comp___1 ++;
                }
                while_break___0: /* CIL Label */ ;
                }

                while_break: 
                {
#line 11815
                __cil_tmp6___22 = opj_j2k_update_image_dimensions(p_image___16, p_manager___129);
                }
#line 11815
                if (! __cil_tmp6___22) {
#line 11816
                  return (0);
                }
              }
            }
          }
        }
      }
    }
  }
#line 11820
  if ((unsigned long )p_j2k___98->m_output_image == (unsigned long )((void *)0)) {
    {
#line 11821
    p_j2k___98->m_output_image = opj_image_create0();
    }
#line 11822
    if (! p_j2k___98->m_output_image) {
#line 11823
      return (0);
    }
  }
  {
#line 11826
  opj_copy_image_header(p_image___16, p_j2k___98->m_output_image);
#line 11829
  __cil_tmp8___44 = opj_j2k_setup_decoding(p_j2k___98, p_manager___129);
  }
#line 11829
  if (! __cil_tmp8___44) {
#line 11830
    return (0);
  }
  {
#line 11834
  __cil_tmp9___24 = opj_j2k_exec(p_j2k___98, p_j2k___98->m_procedure_list, p_stream___57,
                                 p_manager___129);
  }
#line 11834
  if (! __cil_tmp9___24) {
    {
#line 11835
    opj_image_destroy(p_j2k___98->m_private_image);
#line 11836
    p_j2k___98->m_private_image = (opj_image_t *)((void *)0);
    }
#line 11837
    return (0);
  }
  {
#line 11841
  __cil_tmp10___15 = opj_j2k_move_data_from_codec_to_output_image(p_j2k___98, p_image___16);
  }
#line 11841
  return (__cil_tmp10___15);
}
}
#line 11844 "/root/patron-new/39/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_get_tile(opj_j2k_t *p_j2k___99 , opj_stream_private_t *p_stream___58 ,
                          opj_image_t *p_image___17 , opj_event_mgr_t *p_manager___130 ,
                          OPJ_UINT32 tile_index___1 ) 
{ 
  OPJ_UINT32 compno___9 ;
  OPJ_UINT32 l_tile_x___0 ;
  OPJ_UINT32 l_tile_y___0 ;
  opj_image_comp_t *l_img_comp___3 ;
  OPJ_INT32 l_comp_x1___0 ;
  OPJ_INT32 l_comp_y1___0 ;
  OPJ_INT32 __cil_tmp12___24 ;
  OPJ_INT32 __cil_tmp13___29 ;
  OPJ_INT32 __cil_tmp16___20 ;
  OPJ_INT32 __cil_tmp17___19 ;
  OPJ_INT32 __cil_tmp18___12 ;
  OPJ_INT32 __cil_tmp19___16 ;
  OPJ_BOOL __cil_tmp22___11 ;
  OPJ_BOOL __cil_tmp23___9 ;
  OPJ_BOOL __cil_tmp24___6 ;

  {
#line 11854
  if (! p_image___17) {
    {
#line 11855
    opj_event_msg(p_manager___130, 1, "We need an image previously created.\n");
    }
#line 11856
    return (0);
  }
#line 11859
  if (p_image___17->numcomps < (p_j2k___99->m_private_image)->numcomps) {
    {
#line 11860
    opj_event_msg(p_manager___130, 1, "Image has less components than codestream.\n\005]U");
    }
#line 11862
    return (0);
  }
#line 11865
  if (tile_index___1 >= p_j2k___99->m_cp.tw * p_j2k___99->m_cp.th) {
    {
#line 11866
    opj_event_msg(p_manager___130, 1, "Tile index provided by the user is incorrect %d (max = %d) \n",
                  tile_index___1, p_j2k___99->m_cp.tw * p_j2k___99->m_cp.th - 1U);
    }
#line 11869
    return (0);
  }
#line 11873
  l_tile_x___0 = tile_index___1 % p_j2k___99->m_cp.tw;
#line 11874
  l_tile_y___0 = tile_index___1 / p_j2k___99->m_cp.tw;
#line 11876
  p_image___17->x0 = l_tile_x___0 * p_j2k___99->m_cp.tdx + p_j2k___99->m_cp.tx0;
#line 11877
  if (p_image___17->x0 < (p_j2k___99->m_private_image)->x0) {
#line 11878
    p_image___17->x0 = (p_j2k___99->m_private_image)->x0;
  }
#line 11880
  p_image___17->x1 = (l_tile_x___0 + 1U) * p_j2k___99->m_cp.tdx + p_j2k___99->m_cp.tx0;
#line 11881
  if (p_image___17->x1 > (p_j2k___99->m_private_image)->x1) {
#line 11882
    p_image___17->x1 = (p_j2k___99->m_private_image)->x1;
  }
#line 11885
  p_image___17->y0 = l_tile_y___0 * p_j2k___99->m_cp.tdy + p_j2k___99->m_cp.ty0;
#line 11886
  if (p_image___17->y0 < (p_j2k___99->m_private_image)->y0) {
#line 11887
    p_image___17->y0 = (p_j2k___99->m_private_image)->y0;
  }
#line 11889
  p_image___17->y1 = (l_tile_y___0 + 1U) * p_j2k___99->m_cp.tdy + p_j2k___99->m_cp.ty0;
#line 11890
  if (p_image___17->y1 > (p_j2k___99->m_private_image)->y1) {
#line 11891
    p_image___17->y1 = (p_j2k___99->m_private_image)->y1;
  }
#line 11894
  l_img_comp___3 = p_image___17->comps;
#line 11895
  compno___9 = (OPJ_UINT32 )0;
  {
#line 11895
  while (1) {
    while_continue: /* CIL Label */ ;

#line 11895
    if (! (compno___9 < (p_j2k___99->m_private_image)->numcomps)) {
#line 11895
      goto while_break;
    }
    {
#line 11898
    l_img_comp___3->factor = ((p_j2k___99->m_private_image)->comps + compno___9)->factor;
#line 11900
    __cil_tmp12___24 = opj_int_ceildiv((OPJ_INT32 )p_image___17->x0, (OPJ_INT32 )l_img_comp___3->dx);
#line 11900
    l_img_comp___3->x0 = (OPJ_UINT32 )__cil_tmp12___24;
#line 11902
    __cil_tmp13___29 = opj_int_ceildiv((OPJ_INT32 )p_image___17->y0, (OPJ_INT32 )l_img_comp___3->dy);
#line 11902
    l_img_comp___3->y0 = (OPJ_UINT32 )__cil_tmp13___29;
#line 11904
    l_comp_x1___0 = opj_int_ceildiv((OPJ_INT32 )p_image___17->x1, (OPJ_INT32 )l_img_comp___3->dx);
#line 11905
    l_comp_y1___0 = opj_int_ceildiv((OPJ_INT32 )p_image___17->y1, (OPJ_INT32 )l_img_comp___3->dy);
#line 11907
    __cil_tmp17___19 = opj_int_ceildivpow2((OPJ_INT32 )l_img_comp___3->x0, (OPJ_INT32 )l_img_comp___3->factor);
#line 11907
    __cil_tmp16___20 = opj_int_ceildivpow2(l_comp_x1___0, (OPJ_INT32 )l_img_comp___3->factor);
#line 11907
    l_img_comp___3->w = (OPJ_UINT32 )(__cil_tmp16___20 - __cil_tmp17___19);
#line 11910
    __cil_tmp19___16 = opj_int_ceildivpow2((OPJ_INT32 )l_img_comp___3->y0, (OPJ_INT32 )l_img_comp___3->factor);
#line 11910
    __cil_tmp18___12 = opj_int_ceildivpow2(l_comp_y1___0, (OPJ_INT32 )l_img_comp___3->factor);
#line 11910
    l_img_comp___3->h = (OPJ_UINT32 )(__cil_tmp18___12 - __cil_tmp19___16);
#line 11914
    l_img_comp___3 ++;
#line 11895
    compno___9 ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }

  while_break: ;
#line 11917
  if (p_image___17->numcomps > (p_j2k___99->m_private_image)->numcomps) {
#line 11921
    compno___9 = (p_j2k___99->m_private_image)->numcomps;
    {
#line 11921
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 11921
      if (! (compno___9 < p_image___17->numcomps)) {
#line 11921
        goto while_break___0;
      }
      {
#line 11923
      opj_image_data_free((void *)(p_image___17->comps + compno___9)->data);
#line 11924
      (p_image___17->comps + compno___9)->data = (OPJ_INT32 *)((void *)0);
#line 11922
      compno___9 ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }

    while_break___0: 
#line 11926
    p_image___17->numcomps = (p_j2k___99->m_private_image)->numcomps;
  }
#line 11930
  if (p_j2k___99->m_output_image) {
    {
#line 11931
    opj_image_destroy(p_j2k___99->m_output_image);
    }
  }
  {
#line 11935
  p_j2k___99->m_output_image = opj_image_create0();
  }
#line 11936
  if (! p_j2k___99->m_output_image) {
#line 11937
    return (0);
  }
  {
#line 11939
  opj_copy_image_header(p_image___17, p_j2k___99->m_output_image);
#line 11941
  p_j2k___99->m_specific_param.m_decoder.m_tile_ind_to_dec = (OPJ_INT32 )tile_index___1;
#line 11944
  __cil_tmp22___11 = opj_j2k_setup_decoding_tile(p_j2k___99, p_manager___130);
  }
#line 11944
  if (! __cil_tmp22___11) {
#line 11945
    return (0);
  }
  {
#line 11949
  __cil_tmp23___9 = opj_j2k_exec(p_j2k___99, p_j2k___99->m_procedure_list, p_stream___58,
                                 p_manager___130);
  }
#line 11949
  if (! __cil_tmp23___9) {
    {
#line 11950
    opj_image_destroy(p_j2k___99->m_private_image);
#line 11951
    p_j2k___99->m_private_image = (opj_image_t *)((void *)0);
    }
#line 11952
    return (0);
  }
  {
#line 11956
  __cil_tmp24___6 = opj_j2k_move_data_from_codec_to_output_image(p_j2k___99, p_image___17);
  }
#line 11956
  return (__cil_tmp24___6);
}
}
#line 11959 "/root/patron-new/39/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_set_decoded_resolution_factor(opj_j2k_t *p_j2k___100 , OPJ_UINT32 res_factor___1 ,
                                               opj_event_mgr_t *p_manager___131 ) 
{ 
  OPJ_UINT32 it_comp___2 ;
  OPJ_UINT32 max_res ;

  {
#line 11965
  p_j2k___100->m_cp.m_specific_param.m_dec.m_reduce = res_factor___1;
#line 11967
  if (p_j2k___100->m_private_image) {
#line 11968
    if ((p_j2k___100->m_private_image)->comps) {
#line 11969
      if (p_j2k___100->m_specific_param.m_decoder.m_default_tcp) {
#line 11970
        if ((p_j2k___100->m_specific_param.m_decoder.m_default_tcp)->tccps) {
#line 11971
          it_comp___2 = (OPJ_UINT32 )0;
          {
#line 11971
          while (1) {
            while_continue: /* CIL Label */ ;

#line 11971
            if (! (it_comp___2 < (p_j2k___100->m_private_image)->numcomps)) {
#line 11971
              goto while_break;
            }
#line 11972
            max_res = ((p_j2k___100->m_specific_param.m_decoder.m_default_tcp)->tccps + it_comp___2)->numresolutions;
#line 11974
            if (res_factor___1 >= max_res) {
              {
#line 11975
              opj_event_msg(p_manager___131, 1, "Resolution factor is greater than the maximum resolution in the component.\n");
              }
#line 11977
              return (0);
            }
#line 11979
            ((p_j2k___100->m_private_image)->comps + it_comp___2)->factor = res_factor___1;
#line 11971
            it_comp___2 ++;
          }
          while_break___0: /* CIL Label */ ;
          }

          while_break: ;
#line 11981
          return (1);
        }
      }
    }
  }
#line 11987
  return (0);
}
}
#line 11992 "/root/patron-new/39/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_encoder_set_extra_options(opj_j2k_t *p_j2k___101 , char const   * const  *p_options___0 ,
                                           opj_event_mgr_t *p_manager___132 ) 
{ 
  char const   * const  *p_option_iter ;
  int __cil_tmp5___28 ;
  int __cil_tmp6___24 ;
  int __cil_tmp7___32 ;

  {
#line 11999
  if ((unsigned long )p_options___0 == (unsigned long )((void *)0)) {
#line 12000
    return (1);
  }
#line 12003
  p_option_iter = p_options___0;
  {
#line 12003
  while (1) {
    while_continue: /* CIL Label */ ;

#line 12003
    if (! ((unsigned long )*p_option_iter != (unsigned long )((void *)0))) {
#line 12003
      goto while_break;
    }
    {
#line 12004
    __cil_tmp5___28 = strncmp((char const   *)*p_option_iter, "PLT=", 4UL);
    }
#line 12004
    if (__cil_tmp5___28 == 0) {
      {
#line 12005
      __cil_tmp6___24 = strcmp((char const   *)*p_option_iter, "PLT=YES");
      }
#line 12005
      if (__cil_tmp6___24 == 0) {
#line 12006
        p_j2k___101->m_specific_param.m_encoder.m_PLT = 1;
      } else {
        {
#line 12007
        __cil_tmp7___32 = strcmp((char const   *)*p_option_iter, "PLT=NO");
        }
#line 12007
        if (__cil_tmp7___32 == 0) {
#line 12008
          p_j2k___101->m_specific_param.m_encoder.m_PLT = 0;
        } else {
          {
#line 12010
          opj_event_msg(p_manager___132, 1, "Invalid value for option: %s.\n", *p_option_iter);
          }
#line 12012
          return (0);
        }
      }
    } else {
      {
#line 12015
      opj_event_msg(p_manager___132, 1, "Invalid option: %s.\n", *p_option_iter);
      }
#line 12017
      return (0);
    }
#line 12003
    p_option_iter ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 12021
  return (1);
}
}
#line 12026 "/root/patron-new/39/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_encode(opj_j2k_t *p_j2k___102 , opj_stream_private_t *p_stream___59 ,
                        opj_event_mgr_t *p_manager___133 ) 
{ 
  OPJ_UINT32 i___80 ;
  OPJ_UINT32 j___9 ;
  OPJ_UINT32 l_nb_tiles___11 ;
  OPJ_SIZE_T l_max_tile_size ;
  OPJ_SIZE_T l_current_tile_size ;
  OPJ_BYTE *l_current_data___13 ;
  OPJ_BOOL l_reuse_data ;
  opj_tcd_t *p_tcd___0 ;
  opj_image_comp_t *l_img_comp___4 ;
  OPJ_BOOL __cil_tmp16___21 ;
  opj_tcd_tilecomp_t *l_tilec___0 ;
  opj_image_comp_t *l_img_comp___5 ;
  OPJ_BOOL __cil_tmp19___17 ;
  OPJ_BYTE *l_new_current_data___0 ;
  void *__cil_tmp22___12 ;
  OPJ_BOOL __cil_tmp24___7 ;
  OPJ_BOOL __cil_tmp25___6 ;

  {
#line 12032
  l_max_tile_size = (OPJ_SIZE_T )0;
#line 12033
  l_current_data___13 = (OPJ_BYTE *)0;
#line 12034
  l_reuse_data = 0;
#line 12035
  p_tcd___0 = (opj_tcd_t *)0;
#line 12042
  p_tcd___0 = p_j2k___102->m_tcd;
#line 12044
  l_nb_tiles___11 = p_j2k___102->m_cp.th * p_j2k___102->m_cp.tw;
#line 12045
  if (l_nb_tiles___11 == 1U) {
#line 12046
    l_reuse_data = 1;
#line 12048
    j___9 = (OPJ_UINT32 )0;
    {
#line 12048
    while (1) {
      while_continue: /* CIL Label */ ;

#line 12048
      if (! (j___9 < ((p_j2k___102->m_tcd)->image)->numcomps)) {
#line 12048
        goto while_break;
      }
#line 12049
      l_img_comp___4 = (p_tcd___0->image)->comps + j___9;
#line 12050
      if (((size_t )l_img_comp___4->data & 15UL) != 0UL) {
#line 12052
        l_reuse_data = 0;
      }
#line 12048
      j___9 ++;
    }
    while_break___2: /* CIL Label */ ;
    }

    while_break: ;
  }
#line 12057
  i___80 = (OPJ_UINT32 )0;
  {
#line 12057
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 12057
    if (! (i___80 < l_nb_tiles___11)) {
#line 12057
      goto while_break___0;
    }
    {
#line 12058
    __cil_tmp16___21 = opj_j2k_pre_write_tile(p_j2k___102, i___80, p_stream___59,
                                              p_manager___133);
    }
#line 12058
    if (! __cil_tmp16___21) {
#line 12059
      if (l_current_data___13) {
        {
#line 12060
        opj_free((void *)l_current_data___13);
        }
      }
#line 12062
      return (0);
    }
#line 12067
    j___9 = (OPJ_UINT32 )0;
    {
#line 12067
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 12067
      if (! (j___9 < ((p_j2k___102->m_tcd)->image)->numcomps)) {
#line 12067
        goto while_break___1;
      }
#line 12068
      l_tilec___0 = ((p_tcd___0->tcd_image)->tiles)->comps + j___9;
#line 12069
      if (l_reuse_data) {
#line 12070
        l_img_comp___5 = (p_tcd___0->image)->comps + j___9;
#line 12071
        l_tilec___0->data = l_img_comp___5->data;
#line 12072
        l_tilec___0->ownsData = 0;
      } else {
        {
#line 12074
        __cil_tmp19___17 = opj_alloc_tile_component_data(l_tilec___0);
        }
#line 12074
        if (! __cil_tmp19___17) {
          {
#line 12075
          opj_event_msg(p_manager___133, 1, "Error allocating tile component data.");
          }
#line 12076
          if (l_current_data___13) {
            {
#line 12077
            opj_free((void *)l_current_data___13);
            }
          }
#line 12079
          return (0);
        }
      }
#line 12067
      j___9 ++;
    }
    while_break___4: /* CIL Label */ ;
    }

    while_break___1: 
    {
#line 12083
    l_current_tile_size = opj_tcd_get_encoder_input_buffer_size(p_j2k___102->m_tcd);
    }
#line 12084
    if (! l_reuse_data) {
#line 12085
      if (l_current_tile_size > l_max_tile_size) {
        {
#line 12086
        __cil_tmp22___12 = opj_realloc((void *)l_current_data___13, l_current_tile_size);
#line 12086
        l_new_current_data___0 = (OPJ_BYTE *)__cil_tmp22___12;
        }
#line 12088
        if (! l_new_current_data___0) {
#line 12089
          if (l_current_data___13) {
            {
#line 12090
            opj_free((void *)l_current_data___13);
            }
          }
          {
#line 12092
          opj_event_msg(p_manager___133, 1, "Not enough memory to encode all tiles\n");
          }
#line 12093
          return (0);
        }
#line 12095
        l_current_data___13 = l_new_current_data___0;
#line 12096
        l_max_tile_size = l_current_tile_size;
      }
#line 12098
      if ((unsigned long )l_current_data___13 == (unsigned long )((void *)0)) {
#line 12102
        return (0);
      }
      {
#line 12108
      opj_j2k_get_tile_data(p_j2k___102->m_tcd, l_current_data___13);
#line 12111
      __cil_tmp24___7 = opj_tcd_copy_tile_data(p_j2k___102->m_tcd, l_current_data___13,
                                               l_current_tile_size);
      }
#line 12111
      if (! __cil_tmp24___7) {
        {
#line 12113
        opj_event_msg(p_manager___133, 1, "Size mismatch between tile data and sent data.");
#line 12115
        opj_free((void *)l_current_data___13);
        }
#line 12116
        return (0);
      }
    }
    {
#line 12120
    __cil_tmp25___6 = opj_j2k_post_write_tile(p_j2k___102, p_stream___59, p_manager___133);
    }
#line 12120
    if (! __cil_tmp25___6) {
#line 12121
      if (l_current_data___13) {
        {
#line 12122
        opj_free((void *)l_current_data___13);
        }
      }
#line 12124
      return (0);
    }
#line 12057
    i___80 ++;
  }
  while_break___3: /* CIL Label */ ;
  }

  while_break___0: ;
#line 12128
  if (l_current_data___13) {
    {
#line 12129
    opj_free((void *)l_current_data___13);
    }
  }
#line 12131
  return (1);
}
}
#line 12134 "/root/patron-new/39/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_end_compress(opj_j2k_t *p_j2k___103 , opj_stream_private_t *p_stream___60 ,
                              opj_event_mgr_t *p_manager___134 ) 
{ 
  OPJ_BOOL __cil_tmp4___18 ;
  OPJ_BOOL __cil_tmp5___29 ;

  {
  {
#line 12139
  __cil_tmp4___18 = opj_j2k_setup_end_compress(p_j2k___103, p_manager___134);
  }
#line 12139
  if (! __cil_tmp4___18) {
#line 12140
    return (0);
  }
  {
#line 12143
  __cil_tmp5___29 = opj_j2k_exec(p_j2k___103, p_j2k___103->m_procedure_list, p_stream___60,
                                 p_manager___134);
  }
#line 12143
  if (! __cil_tmp5___29) {
#line 12144
    return (0);
  }
#line 12147
  return (1);
}
}
#line 12150 "/root/patron-new/39/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_start_compress(opj_j2k_t *p_j2k___104 , opj_stream_private_t *p_stream___61 ,
                                opj_image_t *p_image___18 , opj_event_mgr_t *p_manager___135 ) 
{ 
  OPJ_UINT32 it_comp___3 ;
  OPJ_BOOL __cil_tmp11___16 ;
  OPJ_BOOL __cil_tmp12___25 ;
  OPJ_BOOL __cil_tmp13___30 ;
  OPJ_BOOL __cil_tmp14___35 ;

  {
  {
#line 12160
  p_j2k___104->m_private_image = opj_image_create0();
  }
#line 12161
  if (! p_j2k___104->m_private_image) {
    {
#line 12162
    opj_event_msg(p_manager___135, 1, "Failed to allocate image header.\220");
    }
#line 12163
    return (0);
  }
  {
#line 12165
  opj_copy_image_header(p_image___18, p_j2k___104->m_private_image);
  }
#line 12168
  if (p_image___18->comps) {
#line 12170
    it_comp___3 = (OPJ_UINT32 )0;
    {
#line 12170
    while (1) {
      while_continue: /* CIL Label */ ;

#line 12170
      if (! (it_comp___3 < p_image___18->numcomps)) {
#line 12170
        goto while_break;
      }
#line 12171
      if ((p_image___18->comps + it_comp___3)->data) {
#line 12172
        ((p_j2k___104->m_private_image)->comps + it_comp___3)->data = (p_image___18->comps + it_comp___3)->data;
#line 12173
        (p_image___18->comps + it_comp___3)->data = (OPJ_INT32 *)((void *)0);
      }
#line 12170
      it_comp___3 ++;
    }
    while_break___0: /* CIL Label */ ;
    }

    while_break: ;
  }
  {
#line 12180
  __cil_tmp11___16 = opj_j2k_setup_encoding_validation(p_j2k___104, p_manager___135);
  }
#line 12180
  if (! __cil_tmp11___16) {
#line 12181
    return (0);
  }
  {
#line 12185
  __cil_tmp12___25 = opj_j2k_exec(p_j2k___104, p_j2k___104->m_validation_list, p_stream___61,
                                  p_manager___135);
  }
#line 12185
  if (! __cil_tmp12___25) {
#line 12186
    return (0);
  }
  {
#line 12190
  __cil_tmp13___30 = opj_j2k_setup_header_writing(p_j2k___104, p_manager___135);
  }
#line 12190
  if (! __cil_tmp13___30) {
#line 12191
    return (0);
  }
  {
#line 12195
  __cil_tmp14___35 = opj_j2k_exec(p_j2k___104, p_j2k___104->m_procedure_list, p_stream___61,
                                  p_manager___135);
  }
#line 12195
  if (! __cil_tmp14___35) {
#line 12196
    return (0);
  }
#line 12199
  return (1);
}
}
#line 12202 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_pre_write_tile(opj_j2k_t *p_j2k___105 , OPJ_UINT32 p_tile_index___7 ,
                                       opj_stream_private_t *p_stream___62 , opj_event_mgr_t *p_manager___136 ) 
{ 
  OPJ_BOOL __cil_tmp5___30 ;

  {
#line 12208
  if (p_tile_index___7 != p_j2k___105->m_current_tile_number) {
    {
#line 12209
    opj_event_msg(p_manager___136, 1, "The given tile index does not match.]U");
    }
#line 12210
    return (0);
  }
  {
#line 12213
  opj_event_msg(p_manager___136, 4, "tile number %d / %d\n", p_j2k___105->m_current_tile_number + 1U,
                p_j2k___105->m_cp.tw * p_j2k___105->m_cp.th);
#line 12216
  p_j2k___105->m_specific_param.m_encoder.m_current_tile_part_number = (OPJ_UINT32 )0;
#line 12217
  (p_j2k___105->m_tcd)->cur_totnum_tp = (p_j2k___105->m_cp.tcps + p_tile_index___7)->m_nb_tile_parts;
#line 12218
  p_j2k___105->m_specific_param.m_encoder.m_current_poc_tile_part_number = (OPJ_UINT32 )0;
#line 12221
  __cil_tmp5___30 = opj_tcd_init_encode_tile(p_j2k___105->m_tcd, p_j2k___105->m_current_tile_number,
                                             p_manager___136);
  }
#line 12221
  if (! __cil_tmp5___30) {
#line 12223
    return (0);
  }
#line 12226
  return (1);
}
}
#line 12229 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static void opj_get_tile_dimensions(opj_image_t *l_image___12 , opj_tcd_tilecomp_t *l_tilec___1 ,
                                    opj_image_comp_t *l_img_comp___6 , OPJ_UINT32 *l_size_comp ,
                                    OPJ_UINT32 *l_width___0 , OPJ_UINT32 *l_height___0 ,
                                    OPJ_UINT32 *l_offset_x , OPJ_UINT32 *l_offset_y ,
                                    OPJ_UINT32 *l_image_width , OPJ_UINT32 *l_stride ,
                                    OPJ_UINT32 *l_tile_offset ) 
{ 
  OPJ_UINT32 l_remaining ;
  OPJ_INT32 __cil_tmp13___31 ;
  OPJ_INT32 __cil_tmp14___36 ;
  OPJ_INT32 __cil_tmp15___26 ;

  {
#line 12242
  *l_size_comp = l_img_comp___6->prec >> 3;
#line 12243
  l_remaining = l_img_comp___6->prec & 7U;
#line 12244
  if (l_remaining) {
#line 12245
    (*l_size_comp) ++;
  }
#line 12248
  if (*l_size_comp == 3U) {
#line 12249
    *l_size_comp = (OPJ_UINT32 )4;
  }
  {
#line 12252
  *l_width___0 = (OPJ_UINT32 )(l_tilec___1->x1 - l_tilec___1->x0);
#line 12253
  *l_height___0 = (OPJ_UINT32 )(l_tilec___1->y1 - l_tilec___1->y0);
#line 12254
  __cil_tmp13___31 = opj_int_ceildiv((OPJ_INT32 )l_image___12->x0, (OPJ_INT32 )l_img_comp___6->dx);
#line 12254
  *l_offset_x = (OPJ_UINT32 )__cil_tmp13___31;
#line 12256
  __cil_tmp14___36 = opj_int_ceildiv((OPJ_INT32 )l_image___12->y0, (OPJ_INT32 )l_img_comp___6->dy);
#line 12256
  *l_offset_y = (OPJ_UINT32 )__cil_tmp14___36;
#line 12258
  __cil_tmp15___26 = opj_int_ceildiv((OPJ_INT32 )l_image___12->x1 - (OPJ_INT32 )l_image___12->x0,
                                     (OPJ_INT32 )l_img_comp___6->dx);
#line 12258
  *l_image_width = (OPJ_UINT32 )__cil_tmp15___26;
#line 12260
  *l_stride = *l_image_width - *l_width___0;
#line 12261
  *l_tile_offset = ((OPJ_UINT32 )l_tilec___1->x0 - *l_offset_x) + ((OPJ_UINT32 )l_tilec___1->y0 - *l_offset_y) * *l_image_width;
  }
#line 12263
  return;
}
}
#line 12265 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static void opj_j2k_get_tile_data(opj_tcd_t *p_tcd___1 , OPJ_BYTE *p_data___13 ) 
{ 
  OPJ_UINT32 i___81 ;
  OPJ_UINT32 j___10 ;
  OPJ_UINT32 k___2 ;
  opj_image_t *l_image___13 ;
  OPJ_INT32 *l_src_ptr___0 ;
  opj_tcd_tilecomp_t *l_tilec___2 ;
  opj_image_comp_t *l_img_comp___7 ;
  OPJ_UINT32 l_size_comp___0 ;
  OPJ_UINT32 l_width___1 ;
  OPJ_UINT32 l_height___1 ;
  OPJ_UINT32 l_offset_x___0 ;
  OPJ_UINT32 l_offset_y___0 ;
  OPJ_UINT32 l_image_width___0 ;
  OPJ_UINT32 l_stride___0 ;
  OPJ_UINT32 l_tile_offset___0 ;
  OPJ_CHAR *l_dest_ptr___0 ;
  OPJ_INT16 *l_dest_ptr___1 ;
  OPJ_INT16 *__cil_tmp20___17 ;
  OPJ_INT32 *__cil_tmp21___10 ;
  OPJ_INT16 *__cil_tmp22___13 ;
  OPJ_INT32 *__cil_tmp23___10 ;
  OPJ_INT32 *l_dest_ptr___2 ;
  OPJ_INT32 *__cil_tmp25___7 ;
  OPJ_INT32 *__cil_tmp26___5 ;

  {
#line 12267
  k___2 = (OPJ_UINT32 )0;
#line 12269
  i___81 = (OPJ_UINT32 )0;
  {
#line 12269
  while (1) {
    while_continue: /* CIL Label */ ;

#line 12269
    if (! (i___81 < (p_tcd___1->image)->numcomps)) {
#line 12269
      goto while_break;
    }
    {
#line 12270
    l_image___13 = p_tcd___1->image;
#line 12272
    l_tilec___2 = ((p_tcd___1->tcd_image)->tiles)->comps + i___81;
#line 12273
    l_img_comp___7 = l_image___13->comps + i___81;
#line 12277
    opj_get_tile_dimensions(l_image___13, l_tilec___2, l_img_comp___7, & l_size_comp___0,
                            & l_width___1, & l_height___1, & l_offset_x___0, & l_offset_y___0,
                            & l_image_width___0, & l_stride___0, & l_tile_offset___0);
#line 12289
    l_src_ptr___0 = l_img_comp___7->data + l_tile_offset___0;
    }
#line 12292
    if (l_size_comp___0 == 1U) {
#line 12292
      goto case_1;
    }
#line 12317
    if (l_size_comp___0 == 2U) {
#line 12317
      goto case_2;
    }
#line 12338
    if (l_size_comp___0 == 4U) {
#line 12338
      goto case_4;
    }
#line 12291
    goto switch_break;
    case_1: 
#line 12293
    l_dest_ptr___0 = (OPJ_CHAR *)p_data___13;
#line 12294
    if (l_img_comp___7->sgnd) {
#line 12295
      j___10 = (OPJ_UINT32 )0;
      {
#line 12295
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 12295
        if (! (j___10 < l_height___1)) {
#line 12295
          goto while_break___0;
        }
#line 12296
        k___2 = (OPJ_UINT32 )0;
        {
#line 12296
        while (1) {
          while_continue___1: /* CIL Label */ ;

#line 12296
          if (! (k___2 < l_width___1)) {
#line 12296
            goto while_break___1;
          }
#line 12297
          *l_dest_ptr___0 = (OPJ_CHAR )*l_src_ptr___0;
#line 12298
          l_dest_ptr___0 ++;
#line 12299
          l_src_ptr___0 ++;
#line 12296
          k___2 ++;
        }
        while_break___12: /* CIL Label */ ;
        }

        while_break___1: 
#line 12301
        l_src_ptr___0 += l_stride___0;
#line 12295
        j___10 ++;
      }
      while_break___11: /* CIL Label */ ;
      }

      while_break___0: ;
    } else {
#line 12304
      j___10 = (OPJ_UINT32 )0;
      {
#line 12304
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 12304
        if (! (j___10 < l_height___1)) {
#line 12304
          goto while_break___2;
        }
#line 12305
        k___2 = (OPJ_UINT32 )0;
        {
#line 12305
        while (1) {
          while_continue___3: /* CIL Label */ ;

#line 12305
          if (! (k___2 < l_width___1)) {
#line 12305
            goto while_break___3;
          }
#line 12306
          *l_dest_ptr___0 = (OPJ_CHAR )(*l_src_ptr___0 & 255);
#line 12307
          l_dest_ptr___0 ++;
#line 12308
          l_src_ptr___0 ++;
#line 12305
          k___2 ++;
        }
        while_break___14: /* CIL Label */ ;
        }

        while_break___3: 
#line 12310
        l_src_ptr___0 += l_stride___0;
#line 12304
        j___10 ++;
      }
      while_break___13: /* CIL Label */ ;
      }

      while_break___2: ;
    }
#line 12314
    p_data___13 = (OPJ_BYTE *)l_dest_ptr___0;
#line 12316
    goto switch_break;
    case_2: 
#line 12318
    l_dest_ptr___1 = (OPJ_INT16 *)p_data___13;
#line 12319
    if (l_img_comp___7->sgnd) {
#line 12320
      j___10 = (OPJ_UINT32 )0;
      {
#line 12320
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 12320
        if (! (j___10 < l_height___1)) {
#line 12320
          goto while_break___4;
        }
#line 12321
        k___2 = (OPJ_UINT32 )0;
        {
#line 12321
        while (1) {
          while_continue___5: /* CIL Label */ ;

#line 12321
          if (! (k___2 < l_width___1)) {
#line 12321
            goto while_break___5;
          }
#line 12322
          __cil_tmp21___10 = l_src_ptr___0;
#line 12322
          l_src_ptr___0 ++;
#line 12322
          __cil_tmp20___17 = l_dest_ptr___1;
#line 12322
          l_dest_ptr___1 ++;
#line 12322
          *__cil_tmp20___17 = (OPJ_INT16 )*__cil_tmp21___10;
#line 12321
          k___2 ++;
        }
        while_break___16: /* CIL Label */ ;
        }

        while_break___5: 
#line 12324
        l_src_ptr___0 += l_stride___0;
#line 12320
        j___10 ++;
      }
      while_break___15: /* CIL Label */ ;
      }

      while_break___4: ;
    } else {
#line 12327
      j___10 = (OPJ_UINT32 )0;
      {
#line 12327
      while (1) {
        while_continue___6: /* CIL Label */ ;

#line 12327
        if (! (j___10 < l_height___1)) {
#line 12327
          goto while_break___6;
        }
#line 12328
        k___2 = (OPJ_UINT32 )0;
        {
#line 12328
        while (1) {
          while_continue___7: /* CIL Label */ ;

#line 12328
          if (! (k___2 < l_width___1)) {
#line 12328
            goto while_break___7;
          }
#line 12329
          __cil_tmp23___10 = l_src_ptr___0;
#line 12329
          l_src_ptr___0 ++;
#line 12329
          __cil_tmp22___13 = l_dest_ptr___1;
#line 12329
          l_dest_ptr___1 ++;
#line 12329
          *__cil_tmp22___13 = (OPJ_INT16 )(*__cil_tmp23___10 & 65535);
#line 12328
          k___2 ++;
        }
        while_break___18: /* CIL Label */ ;
        }

        while_break___7: 
#line 12331
        l_src_ptr___0 += l_stride___0;
#line 12327
        j___10 ++;
      }
      while_break___17: /* CIL Label */ ;
      }

      while_break___6: ;
    }
#line 12335
    p_data___13 = (OPJ_BYTE *)l_dest_ptr___1;
#line 12337
    goto switch_break;
    case_4: 
#line 12339
    l_dest_ptr___2 = (OPJ_INT32 *)p_data___13;
#line 12340
    j___10 = (OPJ_UINT32 )0;
    {
#line 12340
    while (1) {
      while_continue___8: /* CIL Label */ ;

#line 12340
      if (! (j___10 < l_height___1)) {
#line 12340
        goto while_break___8;
      }
#line 12341
      k___2 = (OPJ_UINT32 )0;
      {
#line 12341
      while (1) {
        while_continue___9: /* CIL Label */ ;

#line 12341
        if (! (k___2 < l_width___1)) {
#line 12341
          goto while_break___9;
        }
#line 12342
        __cil_tmp26___5 = l_src_ptr___0;
#line 12342
        l_src_ptr___0 ++;
#line 12342
        __cil_tmp25___7 = l_dest_ptr___2;
#line 12342
        l_dest_ptr___2 ++;
#line 12342
        *__cil_tmp25___7 = *__cil_tmp26___5;
#line 12341
        k___2 ++;
      }
      while_break___20: /* CIL Label */ ;
      }

      while_break___9: 
#line 12344
      l_src_ptr___0 += l_stride___0;
#line 12340
      j___10 ++;
    }
    while_break___19: /* CIL Label */ ;
    }

    while_break___8: 
#line 12347
    p_data___13 = (OPJ_BYTE *)l_dest_ptr___2;
#line 12349
    goto switch_break;
    switch_break: 
#line 12269
    i___81 ++;
  }
  while_break___10: /* CIL Label */ ;
  }

  while_break: ;
#line 12273
  return;
}
}
#line 12354 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_post_write_tile(opj_j2k_t *p_j2k___106 , opj_stream_private_t *p_stream___63 ,
                                        opj_event_mgr_t *p_manager___137 ) 
{ 
  OPJ_UINT32 l_nb_bytes_written ;
  OPJ_BYTE *l_current_data___14 ;
  OPJ_UINT32 l_tile_size___0 ;
  OPJ_UINT32 l_available_data ;
  OPJ_BOOL __cil_tmp9___25 ;
  OPJ_BOOL __cil_tmp10___17 ;
  OPJ_SIZE_T __cil_tmp11___17 ;

  {
  {
#line 12359
  l_current_data___14 = (OPJ_BYTE *)0;
#line 12360
  l_tile_size___0 = (OPJ_UINT32 )0;
#line 12366
  l_tile_size___0 = p_j2k___106->m_specific_param.m_encoder.m_encoded_tile_size;
#line 12367
  l_available_data = l_tile_size___0;
#line 12368
  l_current_data___14 = p_j2k___106->m_specific_param.m_encoder.m_encoded_tile_data;
#line 12370
  l_nb_bytes_written = (OPJ_UINT32 )0;
#line 12371
  __cil_tmp9___25 = opj_j2k_write_first_tile_part(p_j2k___106, l_current_data___14,
                                                  & l_nb_bytes_written, l_available_data,
                                                  p_stream___63, p_manager___137);
  }
#line 12371
  if (! __cil_tmp9___25) {
#line 12373
    return (0);
  }
  {
#line 12375
  l_current_data___14 += l_nb_bytes_written;
#line 12376
  l_available_data -= l_nb_bytes_written;
#line 12378
  l_nb_bytes_written = (OPJ_UINT32 )0;
#line 12379
  __cil_tmp10___17 = opj_j2k_write_all_tile_parts(p_j2k___106, l_current_data___14,
                                                  & l_nb_bytes_written, l_available_data,
                                                  p_stream___63, p_manager___137);
  }
#line 12379
  if (! __cil_tmp10___17) {
#line 12381
    return (0);
  }
  {
#line 12384
  l_available_data -= l_nb_bytes_written;
#line 12385
  l_nb_bytes_written = l_tile_size___0 - l_available_data;
#line 12387
  __cil_tmp11___17 = opj_stream_write_data(p_stream___63, p_j2k___106->m_specific_param.m_encoder.m_encoded_tile_data,
                                           (OPJ_SIZE_T )l_nb_bytes_written, p_manager___137);
  }
#line 12387
  if (__cil_tmp11___17 != (unsigned long )l_nb_bytes_written) {
#line 12390
    return (0);
  }
#line 12393
  (p_j2k___106->m_current_tile_number) ++;
#line 12395
  return (1);
}
}
#line 12398 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_setup_end_compress(opj_j2k_t *p_j2k___107 , opj_event_mgr_t *p_manager___138 ) 
{ 
  OPJ_BOOL __cil_tmp5___31 ;
  OPJ_BOOL __cil_tmp6___25 ;
  OPJ_BOOL __cil_tmp7___33 ;
  OPJ_BOOL __cil_tmp8___46 ;
  OPJ_BOOL __cil_tmp9___26 ;

  {
  {
#line 12406
  __cil_tmp5___31 = opj_procedure_list_add_procedure(p_j2k___107->m_procedure_list,
                                                     (void (*)(void))(& opj_j2k_write_eoc),
                                                     p_manager___138);
  }
#line 12406
  if (! __cil_tmp5___31) {
#line 12408
    return (0);
  }
#line 12411
  if ((int )p_j2k___107->m_cp.rsiz >= 3) {
#line 12411
    if ((int )p_j2k___107->m_cp.rsiz <= 6) {
      _L: 
      {
#line 12412
      __cil_tmp6___25 = opj_procedure_list_add_procedure(p_j2k___107->m_procedure_list,
                                                         (void (*)(void))(& opj_j2k_write_updated_tlm),
                                                         p_manager___138);
      }
#line 12412
      if (! __cil_tmp6___25) {
#line 12414
        return (0);
      }
    } else {
#line 12411
      goto _L___32;
    }
  } else
  _L___32: 
#line 12411
  if ((int )p_j2k___107->m_cp.rsiz >= 1024) {
#line 12411
    if ((int )p_j2k___107->m_cp.rsiz <= 2459) {
#line 12411
      goto _L;
    }
  }
  {
#line 12418
  __cil_tmp7___33 = opj_procedure_list_add_procedure(p_j2k___107->m_procedure_list,
                                                     (void (*)(void))(& opj_j2k_write_epc),
                                                     p_manager___138);
  }
#line 12418
  if (! __cil_tmp7___33) {
#line 12420
    return (0);
  }
  {
#line 12422
  __cil_tmp8___46 = opj_procedure_list_add_procedure(p_j2k___107->m_procedure_list,
                                                     (void (*)(void))(& opj_j2k_end_encoding),
                                                     p_manager___138);
  }
#line 12422
  if (! __cil_tmp8___46) {
#line 12424
    return (0);
  }
  {
#line 12426
  __cil_tmp9___26 = opj_procedure_list_add_procedure(p_j2k___107->m_procedure_list,
                                                     (void (*)(void))(& opj_j2k_destroy_header_memory),
                                                     p_manager___138);
  }
#line 12426
  if (! __cil_tmp9___26) {
#line 12428
    return (0);
  }
#line 12430
  return (1);
}
}
#line 12433 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_setup_encoding_validation(opj_j2k_t *p_j2k___108 , opj_event_mgr_t *p_manager___139 ) 
{ 
  OPJ_BOOL __cil_tmp5___32 ;
  OPJ_BOOL __cil_tmp6___26 ;
  OPJ_BOOL __cil_tmp7___34 ;

  {
  {
#line 12440
  __cil_tmp5___32 = opj_procedure_list_add_procedure(p_j2k___108->m_validation_list,
                                                     (void (*)(void))(& opj_j2k_build_encoder),
                                                     p_manager___139);
  }
#line 12440
  if (! __cil_tmp5___32) {
#line 12442
    return (0);
  }
  {
#line 12444
  __cil_tmp6___26 = opj_procedure_list_add_procedure(p_j2k___108->m_validation_list,
                                                     (void (*)(void))(& opj_j2k_encoding_validation),
                                                     p_manager___139);
  }
#line 12444
  if (! __cil_tmp6___26) {
#line 12446
    return (0);
  }
  {
#line 12450
  __cil_tmp7___34 = opj_procedure_list_add_procedure(p_j2k___108->m_validation_list,
                                                     (void (*)(void))(& opj_j2k_mct_validation),
                                                     p_manager___139);
  }
#line 12450
  if (! __cil_tmp7___34) {
#line 12452
    return (0);
  }
#line 12455
  return (1);
}
}
#line 12458 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_setup_header_writing(opj_j2k_t *p_j2k___109 , opj_event_mgr_t *p_manager___140 ) 
{ 
  OPJ_BOOL __cil_tmp5___33 ;
  OPJ_BOOL __cil_tmp6___27 ;
  OPJ_BOOL __cil_tmp7___35 ;
  OPJ_BOOL __cil_tmp8___47 ;
  OPJ_BOOL __cil_tmp9___27 ;
  OPJ_BOOL __cil_tmp10___18 ;
  OPJ_BOOL __cil_tmp11___18 ;
  OPJ_BOOL __cil_tmp12___26 ;
  OPJ_BOOL __cil_tmp13___32 ;
  OPJ_BOOL __cil_tmp14___37 ;
  OPJ_BOOL __cil_tmp15___27 ;
  OPJ_BOOL __cil_tmp16___22 ;
  OPJ_BOOL __cil_tmp17___20 ;
  OPJ_BOOL __cil_tmp18___13 ;
  OPJ_BOOL __cil_tmp19___18 ;

  {
  {
#line 12465
  __cil_tmp5___33 = opj_procedure_list_add_procedure(p_j2k___109->m_procedure_list,
                                                     (void (*)(void))(& opj_j2k_init_info),
                                                     p_manager___140);
  }
#line 12465
  if (! __cil_tmp5___33) {
#line 12467
    return (0);
  }
  {
#line 12469
  __cil_tmp6___27 = opj_procedure_list_add_procedure(p_j2k___109->m_procedure_list,
                                                     (void (*)(void))(& opj_j2k_write_soc),
                                                     p_manager___140);
  }
#line 12469
  if (! __cil_tmp6___27) {
#line 12471
    return (0);
  }
  {
#line 12473
  __cil_tmp7___35 = opj_procedure_list_add_procedure(p_j2k___109->m_procedure_list,
                                                     (void (*)(void))(& opj_j2k_write_siz),
                                                     p_manager___140);
  }
#line 12473
  if (! __cil_tmp7___35) {
#line 12475
    return (0);
  }
  {
#line 12477
  __cil_tmp8___47 = opj_procedure_list_add_procedure(p_j2k___109->m_procedure_list,
                                                     (void (*)(void))(& opj_j2k_write_cod),
                                                     p_manager___140);
  }
#line 12477
  if (! __cil_tmp8___47) {
#line 12479
    return (0);
  }
  {
#line 12481
  __cil_tmp9___27 = opj_procedure_list_add_procedure(p_j2k___109->m_procedure_list,
                                                     (void (*)(void))(& opj_j2k_write_qcd),
                                                     p_manager___140);
  }
#line 12481
  if (! __cil_tmp9___27) {
#line 12483
    return (0);
  }
  {
#line 12485
  __cil_tmp10___18 = opj_procedure_list_add_procedure(p_j2k___109->m_procedure_list,
                                                      (void (*)(void))(& opj_j2k_write_all_coc),
                                                      p_manager___140);
  }
#line 12485
  if (! __cil_tmp10___18) {
#line 12487
    return (0);
  }
  {
#line 12489
  __cil_tmp11___18 = opj_procedure_list_add_procedure(p_j2k___109->m_procedure_list,
                                                      (void (*)(void))(& opj_j2k_write_all_qcc),
                                                      p_manager___140);
  }
#line 12489
  if (! __cil_tmp11___18) {
#line 12491
    return (0);
  }
#line 12494
  if ((int )p_j2k___109->m_cp.rsiz >= 3) {
#line 12494
    if ((int )p_j2k___109->m_cp.rsiz <= 6) {
      _L: 
      {
#line 12495
      __cil_tmp12___26 = opj_procedure_list_add_procedure(p_j2k___109->m_procedure_list,
                                                          (void (*)(void))(& opj_j2k_write_tlm),
                                                          p_manager___140);
      }
#line 12495
      if (! __cil_tmp12___26) {
#line 12497
        return (0);
      }
#line 12500
      if ((int )p_j2k___109->m_cp.rsiz == 4) {
        {
#line 12501
        __cil_tmp13___32 = opj_procedure_list_add_procedure(p_j2k___109->m_procedure_list,
                                                            (void (*)(void))(& opj_j2k_write_poc),
                                                            p_manager___140);
        }
#line 12501
        if (! __cil_tmp13___32) {
#line 12503
          return (0);
        }
      }
    } else {
#line 12494
      goto _L___33;
    }
  } else
  _L___33: 
#line 12494
  if ((int )p_j2k___109->m_cp.rsiz >= 1024) {
#line 12494
    if ((int )p_j2k___109->m_cp.rsiz <= 2459) {
#line 12494
      goto _L;
    }
  }
  {
#line 12508
  __cil_tmp14___37 = opj_procedure_list_add_procedure(p_j2k___109->m_procedure_list,
                                                      (void (*)(void))(& opj_j2k_write_regions),
                                                      p_manager___140);
  }
#line 12508
  if (! __cil_tmp14___37) {
#line 12510
    return (0);
  }
#line 12513
  if ((unsigned long )p_j2k___109->m_cp.comment != (unsigned long )((OPJ_CHAR *)0)) {
    {
#line 12514
    __cil_tmp15___27 = opj_procedure_list_add_procedure(p_j2k___109->m_procedure_list,
                                                        (void (*)(void))(& opj_j2k_write_com),
                                                        p_manager___140);
    }
#line 12514
    if (! __cil_tmp15___27) {
#line 12516
      return (0);
    }
  }
#line 12521
  if (((int )p_j2k___109->m_cp.rsiz & 33024) == 33024) {
    {
#line 12523
    __cil_tmp16___22 = opj_procedure_list_add_procedure(p_j2k___109->m_procedure_list,
                                                        (void (*)(void))(& opj_j2k_write_mct_data_group),
                                                        p_manager___140);
    }
#line 12523
    if (! __cil_tmp16___22) {
#line 12525
      return (0);
    }
  }
#line 12530
  if (p_j2k___109->cstr_index) {
    {
#line 12531
    __cil_tmp17___20 = opj_procedure_list_add_procedure(p_j2k___109->m_procedure_list,
                                                        (void (*)(void))(& opj_j2k_get_end_header),
                                                        p_manager___140);
    }
#line 12531
    if (! __cil_tmp17___20) {
#line 12533
      return (0);
    }
  }
  {
#line 12537
  __cil_tmp18___13 = opj_procedure_list_add_procedure(p_j2k___109->m_procedure_list,
                                                      (void (*)(void))(& opj_j2k_create_tcd),
                                                      p_manager___140);
  }
#line 12537
  if (! __cil_tmp18___13) {
#line 12539
    return (0);
  }
  {
#line 12541
  __cil_tmp19___18 = opj_procedure_list_add_procedure(p_j2k___109->m_procedure_list,
                                                      (void (*)(void))(& opj_j2k_update_rates),
                                                      p_manager___140);
  }
#line 12541
  if (! __cil_tmp19___18) {
#line 12543
    return (0);
  }
#line 12546
  return (1);
}
}
#line 12549 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_first_tile_part(opj_j2k_t *p_j2k___110 , OPJ_BYTE *p_data___14 ,
                                              OPJ_UINT32 *p_data_written___5 , OPJ_UINT32 total_data_size___1 ,
                                              opj_stream_private_t *p_stream___64 ,
                                              struct opj_event_mgr *p_manager___141 ) 
{ 
  OPJ_UINT32 l_nb_bytes_written___0 ;
  OPJ_UINT32 l_current_nb_bytes_written ;
  OPJ_BYTE *l_begin_data ;
  opj_tcd_t *l_tcd ;
  opj_cp_t *l_cp___24 ;
  OPJ_BOOL __cil_tmp12___27 ;
  OPJ_BOOL __cil_tmp13___33 ;

  {
  {
#line 12556
  l_nb_bytes_written___0 = (OPJ_UINT32 )0;
#line 12558
  l_begin_data = (OPJ_BYTE *)0;
#line 12560
  l_tcd = (opj_tcd_t *)0;
#line 12561
  l_cp___24 = (opj_cp_t *)0;
#line 12563
  l_tcd = p_j2k___110->m_tcd;
#line 12564
  l_cp___24 = & p_j2k___110->m_cp;
#line 12566
  l_tcd->cur_pino = (OPJ_UINT32 )0;
#line 12569
  p_j2k___110->m_specific_param.m_encoder.m_current_poc_tile_part_number = (OPJ_UINT32 )0;
#line 12574
  l_current_nb_bytes_written = (OPJ_UINT32 )0;
#line 12575
  l_begin_data = p_data___14;
#line 12576
  __cil_tmp12___27 = opj_j2k_write_sot(p_j2k___110, p_data___14, total_data_size___1,
                                       & l_current_nb_bytes_written, p_stream___64,
                                       p_manager___141);
  }
#line 12576
  if (! __cil_tmp12___27) {
#line 12579
    return (0);
  }
#line 12582
  l_nb_bytes_written___0 += l_current_nb_bytes_written;
#line 12583
  p_data___14 += l_current_nb_bytes_written;
#line 12584
  total_data_size___1 -= l_current_nb_bytes_written;
#line 12586
  if ((int )l_cp___24->rsiz >= 3) {
#line 12586
    if (! ((int )l_cp___24->rsiz <= 6)) {
#line 12586
      goto _L___34;
    }
  } else
  _L___34: 
#line 12604
  if ((l_cp___24->tcps + p_j2k___110->m_current_tile_number)->POC) {
    {
#line 12605
    l_current_nb_bytes_written = (OPJ_UINT32 )0;
#line 12606
    opj_j2k_write_poc_in_memory(p_j2k___110, p_data___14, & l_current_nb_bytes_written,
                                p_manager___141);
#line 12608
    l_nb_bytes_written___0 += l_current_nb_bytes_written;
#line 12609
    p_data___14 += l_current_nb_bytes_written;
#line 12610
    total_data_size___1 -= l_current_nb_bytes_written;
    }
  }
  {
#line 12614
  l_current_nb_bytes_written = (OPJ_UINT32 )0;
#line 12615
  __cil_tmp13___33 = opj_j2k_write_sod(p_j2k___110, l_tcd, p_data___14, & l_current_nb_bytes_written,
                                       total_data_size___1, p_stream___64, p_manager___141);
  }
#line 12615
  if (! __cil_tmp13___33) {
#line 12617
    return (0);
  }
  {
#line 12620
  l_nb_bytes_written___0 += l_current_nb_bytes_written;
#line 12621
  *p_data_written___5 = l_nb_bytes_written___0;
#line 12624
  opj_write_bytes_LE(l_begin_data + 6, l_nb_bytes_written___0, (OPJ_UINT32 )4);
  }
#line 12627
  if ((int )l_cp___24->rsiz >= 3) {
#line 12627
    if ((int )l_cp___24->rsiz <= 6) {
      {
#line 12628
      opj_j2k_update_tlm(p_j2k___110, l_nb_bytes_written___0);
      }
    } else {
#line 12627
      goto _L;
    }
  } else
  _L: 
#line 12627
  if ((int )l_cp___24->rsiz >= 1024) {
#line 12627
    if ((int )l_cp___24->rsiz <= 2459) {
      {
#line 12628
      opj_j2k_update_tlm(p_j2k___110, l_nb_bytes_written___0);
      }
    }
  }
#line 12631
  return (1);
}
}
#line 12634 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_all_tile_parts(opj_j2k_t *p_j2k___111 , OPJ_BYTE *p_data___15 ,
                                             OPJ_UINT32 *p_data_written___6 , OPJ_UINT32 total_data_size___2 ,
                                             opj_stream_private_t *p_stream___65 ,
                                             struct opj_event_mgr *p_manager___142 ) 
{ 
  OPJ_UINT32 tilepartno ;
  OPJ_UINT32 l_nb_bytes_written___1 ;
  OPJ_UINT32 l_current_nb_bytes_written___0 ;
  OPJ_UINT32 l_part_tile_size ;
  OPJ_UINT32 tot_num_tp ;
  OPJ_UINT32 pino___1 ;
  OPJ_BYTE *l_begin_data___0 ;
  opj_tcp_t *l_tcp___35 ;
  opj_tcd_t *l_tcd___0 ;
  opj_cp_t *l_cp___25 ;
  OPJ_BOOL __cil_tmp18___14 ;
  OPJ_BOOL __cil_tmp19___19 ;
  OPJ_BOOL __cil_tmp21___11 ;
  OPJ_BOOL __cil_tmp22___14 ;

  {
  {
#line 12642
  tilepartno = (OPJ_UINT32 )0;
#line 12643
  l_nb_bytes_written___1 = (OPJ_UINT32 )0;
#line 12650
  l_tcp___35 = (opj_tcp_t *)0;
#line 12651
  l_tcd___0 = (opj_tcd_t *)0;
#line 12652
  l_cp___25 = (opj_cp_t *)0;
#line 12654
  l_tcd___0 = p_j2k___111->m_tcd;
#line 12655
  l_cp___25 = & p_j2k___111->m_cp;
#line 12656
  l_tcp___35 = l_cp___25->tcps + p_j2k___111->m_current_tile_number;
#line 12659
  tot_num_tp = opj_j2k_get_num_tp(l_cp___25, (OPJ_UINT32 )0, p_j2k___111->m_current_tile_number);
#line 12662
  (p_j2k___111->m_specific_param.m_encoder.m_current_tile_part_number) ++;
#line 12663
  tilepartno = (OPJ_UINT32 )1;
  }
  {
#line 12663
  while (1) {
    while_continue: /* CIL Label */ ;

#line 12663
    if (! (tilepartno < tot_num_tp)) {
#line 12663
      goto while_break;
    }
    {
#line 12664
    p_j2k___111->m_specific_param.m_encoder.m_current_poc_tile_part_number = tilepartno;
#line 12665
    l_current_nb_bytes_written___0 = (OPJ_UINT32 )0;
#line 12666
    l_part_tile_size = (OPJ_UINT32 )0;
#line 12667
    l_begin_data___0 = p_data___15;
#line 12669
    __cil_tmp18___14 = opj_j2k_write_sot(p_j2k___111, p_data___15, total_data_size___2,
                                         & l_current_nb_bytes_written___0, p_stream___65,
                                         p_manager___142);
    }
#line 12669
    if (! __cil_tmp18___14) {
#line 12674
      return (0);
    }
    {
#line 12677
    l_nb_bytes_written___1 += l_current_nb_bytes_written___0;
#line 12678
    p_data___15 += l_current_nb_bytes_written___0;
#line 12679
    total_data_size___2 -= l_current_nb_bytes_written___0;
#line 12680
    l_part_tile_size += l_current_nb_bytes_written___0;
#line 12682
    l_current_nb_bytes_written___0 = (OPJ_UINT32 )0;
#line 12683
    __cil_tmp19___19 = opj_j2k_write_sod(p_j2k___111, l_tcd___0, p_data___15, & l_current_nb_bytes_written___0,
                                         total_data_size___2, p_stream___65, p_manager___142);
    }
#line 12683
    if (! __cil_tmp19___19) {
#line 12685
      return (0);
    }
    {
#line 12688
    p_data___15 += l_current_nb_bytes_written___0;
#line 12689
    l_nb_bytes_written___1 += l_current_nb_bytes_written___0;
#line 12690
    total_data_size___2 -= l_current_nb_bytes_written___0;
#line 12691
    l_part_tile_size += l_current_nb_bytes_written___0;
#line 12694
    opj_write_bytes_LE(l_begin_data___0 + 6, l_part_tile_size, (OPJ_UINT32 )4);
    }
#line 12697
    if ((int )l_cp___25->rsiz >= 3) {
#line 12697
      if ((int )l_cp___25->rsiz <= 6) {
        {
#line 12698
        opj_j2k_update_tlm(p_j2k___111, l_part_tile_size);
        }
      } else {
#line 12697
        goto _L;
      }
    } else
    _L: 
#line 12697
    if ((int )l_cp___25->rsiz >= 1024) {
#line 12697
      if ((int )l_cp___25->rsiz <= 2459) {
        {
#line 12698
        opj_j2k_update_tlm(p_j2k___111, l_part_tile_size);
        }
      }
    }
#line 12701
    (p_j2k___111->m_specific_param.m_encoder.m_current_tile_part_number) ++;
#line 12663
    tilepartno ++;
  }
  while_break___2: /* CIL Label */ ;
  }

  while_break: 
#line 12704
  pino___1 = (OPJ_UINT32 )1;
  {
#line 12704
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 12704
    if (! (pino___1 <= l_tcp___35->numpocs)) {
#line 12704
      goto while_break___0;
    }
    {
#line 12705
    l_tcd___0->cur_pino = pino___1;
#line 12708
    tot_num_tp = opj_j2k_get_num_tp(l_cp___25, pino___1, p_j2k___111->m_current_tile_number);
#line 12709
    tilepartno = (OPJ_UINT32 )0;
    }
    {
#line 12709
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 12709
      if (! (tilepartno < tot_num_tp)) {
#line 12709
        goto while_break___1;
      }
      {
#line 12710
      p_j2k___111->m_specific_param.m_encoder.m_current_poc_tile_part_number = tilepartno;
#line 12711
      l_current_nb_bytes_written___0 = (OPJ_UINT32 )0;
#line 12712
      l_part_tile_size = (OPJ_UINT32 )0;
#line 12713
      l_begin_data___0 = p_data___15;
#line 12715
      __cil_tmp21___11 = opj_j2k_write_sot(p_j2k___111, p_data___15, total_data_size___2,
                                           & l_current_nb_bytes_written___0, p_stream___65,
                                           p_manager___142);
      }
#line 12715
      if (! __cil_tmp21___11) {
#line 12719
        return (0);
      }
      {
#line 12722
      l_nb_bytes_written___1 += l_current_nb_bytes_written___0;
#line 12723
      p_data___15 += l_current_nb_bytes_written___0;
#line 12724
      total_data_size___2 -= l_current_nb_bytes_written___0;
#line 12725
      l_part_tile_size += l_current_nb_bytes_written___0;
#line 12727
      l_current_nb_bytes_written___0 = (OPJ_UINT32 )0;
#line 12729
      __cil_tmp22___14 = opj_j2k_write_sod(p_j2k___111, l_tcd___0, p_data___15, & l_current_nb_bytes_written___0,
                                           total_data_size___2, p_stream___65, p_manager___142);
      }
#line 12729
      if (! __cil_tmp22___14) {
#line 12731
        return (0);
      }
      {
#line 12734
      l_nb_bytes_written___1 += l_current_nb_bytes_written___0;
#line 12735
      p_data___15 += l_current_nb_bytes_written___0;
#line 12736
      total_data_size___2 -= l_current_nb_bytes_written___0;
#line 12737
      l_part_tile_size += l_current_nb_bytes_written___0;
#line 12740
      opj_write_bytes_LE(l_begin_data___0 + 6, l_part_tile_size, (OPJ_UINT32 )4);
      }
#line 12743
      if ((int )l_cp___25->rsiz >= 3) {
#line 12743
        if ((int )l_cp___25->rsiz <= 6) {
          {
#line 12744
          opj_j2k_update_tlm(p_j2k___111, l_part_tile_size);
          }
        } else {
#line 12743
          goto _L___34;
        }
      } else
      _L___34: 
#line 12743
      if ((int )l_cp___25->rsiz >= 1024) {
#line 12743
        if ((int )l_cp___25->rsiz <= 2459) {
          {
#line 12744
          opj_j2k_update_tlm(p_j2k___111, l_part_tile_size);
          }
        }
      }
#line 12747
      (p_j2k___111->m_specific_param.m_encoder.m_current_tile_part_number) ++;
#line 12709
      tilepartno ++;
    }
    while_break___4: /* CIL Label */ ;
    }

    while_break___1: 
#line 12704
    pino___1 ++;
  }
  while_break___3: /* CIL Label */ ;
  }

  while_break___0: 
#line 12751
  *p_data_written___6 = l_nb_bytes_written___1;
#line 12753
  return (1);
}
}
#line 12756 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_updated_tlm(opj_j2k_t *p_j2k___112 , struct opj_stream_private *p_stream___66 ,
                                          struct opj_event_mgr *p_manager___143 ) 
{ 
  OPJ_UINT32 l_tlm_size___0 ;
  OPJ_OFF_T l_tlm_position ;
  OPJ_OFF_T l_current_position ;
  OPJ_BOOL __cil_tmp11___19 ;
  OPJ_SIZE_T __cil_tmp12___28 ;
  OPJ_BOOL __cil_tmp13___34 ;

  {
  {
#line 12768
  l_tlm_size___0 = 5U * p_j2k___112->m_specific_param.m_encoder.m_total_tile_parts;
#line 12769
  l_tlm_position = 6L + p_j2k___112->m_specific_param.m_encoder.m_tlm_start;
#line 12770
  l_current_position = opj_stream_tell(p_stream___66);
#line 12772
  __cil_tmp11___19 = opj_stream_seek(p_stream___66, l_tlm_position, p_manager___143);
  }
#line 12772
  if (! __cil_tmp11___19) {
#line 12773
    return (0);
  }
  {
#line 12776
  __cil_tmp12___28 = opj_stream_write_data(p_stream___66, p_j2k___112->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer,
                                           (OPJ_SIZE_T )l_tlm_size___0, p_manager___143);
  }
#line 12776
  if (__cil_tmp12___28 != (unsigned long )l_tlm_size___0) {
#line 12779
    return (0);
  }
  {
#line 12782
  __cil_tmp13___34 = opj_stream_seek(p_stream___66, l_current_position, p_manager___143);
  }
#line 12782
  if (! __cil_tmp13___34) {
#line 12783
    return (0);
  }
#line 12786
  return (1);
}
}
#line 12789 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_end_encoding(opj_j2k_t *p_j2k___113 , struct opj_stream_private *p_stream___67 ,
                                     struct opj_event_mgr *p_manager___144 ) 
{ 


  {
  {
#line 12801
  opj_tcd_destroy(p_j2k___113->m_tcd);
#line 12802
  p_j2k___113->m_tcd = (struct opj_tcd *)0;
  }
#line 12804
  if (p_j2k___113->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer) {
    {
#line 12805
    opj_free((void *)p_j2k___113->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer);
#line 12806
    p_j2k___113->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer = (OPJ_BYTE *)0;
#line 12807
    p_j2k___113->m_specific_param.m_encoder.m_tlm_sot_offsets_current = (OPJ_BYTE *)0;
    }
  }
#line 12810
  if (p_j2k___113->m_specific_param.m_encoder.m_encoded_tile_data) {
    {
#line 12811
    opj_free((void *)p_j2k___113->m_specific_param.m_encoder.m_encoded_tile_data);
#line 12812
    p_j2k___113->m_specific_param.m_encoder.m_encoded_tile_data = (OPJ_BYTE *)0;
    }
  }
#line 12815
  p_j2k___113->m_specific_param.m_encoder.m_encoded_tile_size = (OPJ_UINT32 )0;
#line 12817
  return (1);
}
}
#line 12823 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_destroy_header_memory(opj_j2k_t *p_j2k___114 , opj_stream_private_t *p_stream___68 ,
                                              opj_event_mgr_t *p_manager___145 ) 
{ 


  {
#line 12836
  if (p_j2k___114->m_specific_param.m_encoder.m_header_tile_data) {
    {
#line 12837
    opj_free((void *)p_j2k___114->m_specific_param.m_encoder.m_header_tile_data);
#line 12838
    p_j2k___114->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)0;
    }
  }
#line 12841
  p_j2k___114->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 12843
  return (1);
}
}
#line 12846 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_init_info(opj_j2k_t *p_j2k___115 , struct opj_stream_private *p_stream___69 ,
                                  struct opj_event_mgr *p_manager___146 ) 
{ 
  opj_codestream_info_t *l_cstr_info___0 ;
  OPJ_BOOL __cil_tmp8___48 ;

  {
  {
#line 12850
  l_cstr_info___0 = (opj_codestream_info_t *)0;
#line 12899
  __cil_tmp8___48 = opj_j2k_calculate_tp(p_j2k___115, & p_j2k___115->m_cp, & p_j2k___115->m_specific_param.m_encoder.m_total_tile_parts,
                                         p_j2k___115->m_private_image, p_manager___146);
  }
#line 12899
  return (__cil_tmp8___48);
}
}
#line 12911 "/root/patron-new/39/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_create_tcd(opj_j2k_t *p_j2k___116 , opj_stream_private_t *p_stream___70 ,
                                   opj_event_mgr_t *p_manager___147 ) 
{ 
  OPJ_BOOL __cil_tmp8___49 ;

  {
  {
#line 12923
  p_j2k___116->m_tcd = opj_tcd_create(0);
  }
#line 12925
  if (! p_j2k___116->m_tcd) {
    {
#line 12926
    opj_event_msg(p_manager___147, 1, "Not enough memory to create Tile Coder\n");
    }
#line 12927
    return (0);
  }
  {
#line 12930
  __cil_tmp8___49 = opj_tcd_init(p_j2k___116->m_tcd, p_j2k___116->m_private_image,
                                 & p_j2k___116->m_cp, p_j2k___116->m_tp);
  }
#line 12930
  if (! __cil_tmp8___49) {
    {
#line 12932
    opj_tcd_destroy(p_j2k___116->m_tcd);
#line 12933
    p_j2k___116->m_tcd = (struct opj_tcd *)0;
    }
#line 12934
    return (0);
  }
#line 12937
  return (1);
}
}
#line 12940 "/root/patron-new/39/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_tile(opj_j2k_t *p_j2k___117 , OPJ_UINT32 p_tile_index___8 ,
                            OPJ_BYTE *p_data___16 , OPJ_UINT32 p_data_size___7 , opj_stream_private_t *p_stream___71 ,
                            opj_event_mgr_t *p_manager___148 ) 
{ 
  OPJ_BOOL __cil_tmp7___37 ;
  OPJ_UINT32 j___11 ;
  opj_tcd_tilecomp_t *l_tilec___3 ;
  OPJ_BOOL __cil_tmp10___20 ;
  OPJ_BOOL __cil_tmp11___20 ;
  OPJ_BOOL __cil_tmp12___29 ;

  {
  {
#line 12947
  __cil_tmp7___37 = opj_j2k_pre_write_tile(p_j2k___117, p_tile_index___8, p_stream___71,
                                           p_manager___148);
  }
#line 12947
  if (! __cil_tmp7___37) {
    {
#line 12948
    opj_event_msg(p_manager___148, 1, "Error while opj_j2k_pre_write_tile with tile index = %d\n\230\001",
                  p_tile_index___8);
    }
#line 12950
    return (0);
  } else {
#line 12954
    j___11 = (OPJ_UINT32 )0;
    {
#line 12954
    while (1) {
      while_continue: /* CIL Label */ ;

#line 12954
      if (! (j___11 < ((p_j2k___117->m_tcd)->image)->numcomps)) {
#line 12954
        goto while_break;
      }
      {
#line 12955
      l_tilec___3 = (((p_j2k___117->m_tcd)->tcd_image)->tiles)->comps + j___11;
#line 12957
      __cil_tmp10___20 = opj_alloc_tile_component_data(l_tilec___3);
      }
#line 12957
      if (! __cil_tmp10___20) {
        {
#line 12958
        opj_event_msg(p_manager___148, 1, "Error allocating tile component data.");
        }
#line 12959
        return (0);
      }
#line 12954
      j___11 ++;
    }
    while_break___0: /* CIL Label */ ;
    }

    while_break: 
    {
#line 12964
    __cil_tmp11___20 = opj_tcd_copy_tile_data(p_j2k___117->m_tcd, p_data___16, (OPJ_SIZE_T )p_data_size___7);
    }
#line 12964
    if (! __cil_tmp11___20) {
      {
#line 12965
      opj_event_msg(p_manager___148, 1, "Size mismatch between tile data and sent data.");
      }
#line 12967
      return (0);
    }
    {
#line 12969
    __cil_tmp12___29 = opj_j2k_post_write_tile(p_j2k___117, p_stream___71, p_manager___148);
    }
#line 12969
    if (! __cil_tmp12___29) {
      {
#line 12970
      opj_event_msg(p_manager___148, 1, "Error while opj_j2k_post_write_tile with tile index = %d\n",
                    p_tile_index___8);
      }
#line 12972
      return (0);
    }
  }
#line 12976
  return (1);
}
}
#line 37 "/root/patron-new/39/src/lib/openjp2/invert.c"
static OPJ_BOOL opj_lupDecompose(OPJ_FLOAT32 *matrix , OPJ_UINT32 *permutations ,
                                 OPJ_FLOAT32 *p_swap_area , OPJ_UINT32 nb_compo___0 ) ;
#line 44
static void opj_lupSolve(OPJ_FLOAT32 *pResult , OPJ_FLOAT32 *pMatrix , OPJ_FLOAT32 *pVector ,
                         OPJ_UINT32 *pPermutations , OPJ_UINT32 nb_compo___1 , OPJ_FLOAT32 *p_intermediate_data ) ;
#line 54
static void opj_lupInvert(OPJ_FLOAT32 *pSrcMatrix___0 , OPJ_FLOAT32 *pDestMatrix___0 ,
                          OPJ_UINT32 nb_compo___2 , OPJ_UINT32 *pPermutations___0 ,
                          OPJ_FLOAT32 *p_src_temp , OPJ_FLOAT32 *p_dest_temp , OPJ_FLOAT32 *p_swap_area___0 ) ;
#line 70 "/root/patron-new/39/src/lib/openjp2/invert.c"
OPJ_BOOL opj_matrix_inversion_f(OPJ_FLOAT32 *pSrcMatrix , OPJ_FLOAT32 *pDestMatrix ,
                                OPJ_UINT32 nb_compo ) 
{ 
  OPJ_BYTE *l_data___4 ;
  OPJ_UINT32 l_permutation_size ;
  OPJ_UINT32 l_swap_size ;
  OPJ_UINT32 l_total_size ;
  OPJ_UINT32 *lPermutations ;
  OPJ_FLOAT32 *l_double_data ;
  void *__cil_tmp10___21 ;
  OPJ_BOOL __cil_tmp11___21 ;

  {
  {
#line 74
  l_data___4 = (OPJ_BYTE *)0;
#line 75
  l_permutation_size = nb_compo * (OPJ_UINT32 )sizeof(OPJ_UINT32 );
#line 76
  l_swap_size = nb_compo * (OPJ_UINT32 )sizeof(OPJ_FLOAT32 );
#line 77
  l_total_size = l_permutation_size + 3U * l_swap_size;
#line 78
  lPermutations = (OPJ_UINT32 *)0;
#line 79
  l_double_data = (OPJ_FLOAT32 *)0;
#line 81
  __cil_tmp10___21 = opj_malloc((size_t )l_total_size);
#line 81
  l_data___4 = (OPJ_BYTE *)__cil_tmp10___21;
  }
#line 82
  if ((unsigned long )l_data___4 == (unsigned long )((OPJ_BYTE *)0)) {
#line 83
    return (0);
  }
  {
#line 85
  lPermutations = (OPJ_UINT32 *)l_data___4;
#line 86
  l_double_data = (OPJ_FLOAT32 *)(l_data___4 + l_permutation_size);
#line 87
  memset((void *)lPermutations, 0, (unsigned long )l_permutation_size);
#line 89
  __cil_tmp11___21 = opj_lupDecompose(pSrcMatrix, lPermutations, l_double_data, nb_compo);
  }
#line 89
  if (! __cil_tmp11___21) {
    {
#line 90
    opj_free((void *)l_data___4);
    }
#line 91
    return (0);
  }
  {
#line 94
  opj_lupInvert(pSrcMatrix, pDestMatrix, nb_compo, lPermutations, l_double_data, l_double_data + nb_compo,
                l_double_data + 2U * nb_compo);
#line 96
  opj_free((void *)l_data___4);
  }
#line 98
  return (1);
}
}
#line 107 "/root/patron-new/39/src/lib/openjp2/invert.c"
static OPJ_BOOL opj_lupDecompose(OPJ_FLOAT32 *matrix , OPJ_UINT32 *permutations ,
                                 OPJ_FLOAT32 *p_swap_area , OPJ_UINT32 nb_compo___0 ) 
{ 
  OPJ_UINT32 *tmpPermutations ;
  OPJ_UINT32 *dstPermutations ;
  OPJ_UINT32 k2 ;
  OPJ_UINT32 t___0 ;
  OPJ_FLOAT32 temp ;
  OPJ_UINT32 i___82 ;
  OPJ_UINT32 j___12 ;
  OPJ_UINT32 k___3 ;
  OPJ_FLOAT32 p___0 ;
  OPJ_UINT32 lLastColum ;
  OPJ_UINT32 lSwapSize ;
  OPJ_FLOAT32 *lTmpMatrix ;
  OPJ_FLOAT32 *lColumnMatrix ;
  OPJ_FLOAT32 *lDestMatrix ;
  OPJ_UINT32 offset ;
  OPJ_UINT32 lStride ;
  OPJ_UINT32 *__cil_tmp21___12 ;
  OPJ_FLOAT32 tmp___437 ;
  OPJ_FLOAT32 *__cil_tmp23___11 ;
  OPJ_FLOAT32 *__cil_tmp24___8 ;
  OPJ_FLOAT32 *__cil_tmp25___8 ;
  OPJ_FLOAT32 *__cil_tmp26___6 ;

  {
#line 112
  tmpPermutations = permutations;
#line 114
  k2 = (OPJ_UINT32 )0;
#line 118
  lLastColum = nb_compo___0 - 1U;
#line 119
  lSwapSize = nb_compo___0 * (OPJ_UINT32 )sizeof(OPJ_FLOAT32 );
#line 120
  lTmpMatrix = matrix;
#line 122
  offset = (OPJ_UINT32 )1;
#line 123
  lStride = nb_compo___0 - 1U;
#line 126
  i___82 = (OPJ_UINT32 )0;
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;

#line 126
    if (! (i___82 < nb_compo___0)) {
#line 126
      goto while_break;
    }
#line 127
    __cil_tmp21___12 = tmpPermutations;
#line 127
    tmpPermutations ++;
#line 127
    *__cil_tmp21___12 = i___82;
#line 126
    i___82 ++;
  }
  while_break___4: /* CIL Label */ ;
  }

  while_break: 
#line 130
  tmpPermutations = permutations;
#line 131
  k___3 = (OPJ_UINT32 )0;
  {
#line 131
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 131
    if (! (k___3 < lLastColum)) {
#line 131
      goto while_break___0;
    }
#line 132
    p___0 = (OPJ_FLOAT32 )0.;
#line 135
    lColumnMatrix = lTmpMatrix + k___3;
#line 138
    i___82 = k___3;
    {
#line 138
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 138
      if (! (i___82 < nb_compo___0)) {
#line 138
        goto while_break___1;
      }
#line 139
      if (*lColumnMatrix > (float )0) {
#line 139
        tmp___437 = *lColumnMatrix;
      } else {
#line 139
        tmp___437 = - *lColumnMatrix;
      }
#line 139
      temp = tmp___437;
#line 140
      if (temp > p___0) {
#line 141
        p___0 = temp;
#line 142
        k2 = i___82;
      }
#line 145
      lColumnMatrix += nb_compo___0;
#line 138
      i___82 ++;
    }
    while_break___6: /* CIL Label */ ;
    }

    while_break___1: ;
#line 149
    if ((double )p___0 == 0.) {
#line 150
      return (0);
    }
#line 154
    if (k2 != k___3) {
      {
#line 157
      dstPermutations = (tmpPermutations + k2) - k___3;
#line 159
      t___0 = *tmpPermutations;
#line 160
      *tmpPermutations = *dstPermutations;
#line 161
      *dstPermutations = t___0;
#line 164
      lColumnMatrix = lTmpMatrix + (k2 - k___3) * nb_compo___0;
#line 165
      memcpy((void *)p_swap_area, (void const   *)lColumnMatrix, (unsigned long )lSwapSize);
#line 166
      memcpy((void *)lColumnMatrix, (void const   *)lTmpMatrix, (unsigned long )lSwapSize);
#line 167
      memcpy((void *)lTmpMatrix, (void const   *)p_swap_area, (unsigned long )lSwapSize);
      }
    }
#line 171
    lDestMatrix = lTmpMatrix + k___3;
#line 172
    lColumnMatrix = lDestMatrix + nb_compo___0;
#line 174
    __cil_tmp23___11 = lDestMatrix;
#line 174
    lDestMatrix ++;
#line 174
    temp = *__cil_tmp23___11;
#line 177
    i___82 = offset;
    {
#line 177
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 177
      if (! (i___82 < nb_compo___0)) {
#line 177
        goto while_break___2;
      }
#line 183
      p___0 = *lColumnMatrix / temp;
#line 184
      __cil_tmp24___8 = lColumnMatrix;
#line 184
      lColumnMatrix ++;
#line 184
      *__cil_tmp24___8 = p___0;
#line 186
      j___12 = offset;
      {
#line 186
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 186
        if (! (j___12 < nb_compo___0)) {
#line 186
          goto while_break___3;
        }
#line 188
        __cil_tmp26___6 = lDestMatrix;
#line 188
        lDestMatrix ++;
#line 188
        __cil_tmp25___8 = lColumnMatrix;
#line 188
        lColumnMatrix ++;
#line 188
        *__cil_tmp25___8 -= p___0 * *__cil_tmp26___6;
#line 186
        j___12 ++;
      }
      while_break___8: /* CIL Label */ ;
      }

      while_break___3: 
#line 191
      lDestMatrix -= lStride;
#line 193
      lColumnMatrix += k___3;
#line 177
      i___82 ++;
    }
    while_break___7: /* CIL Label */ ;
    }

    while_break___2: 
#line 197
    offset ++;
#line 199
    lStride --;
#line 201
    lTmpMatrix += nb_compo___0;
#line 203
    tmpPermutations ++;
#line 131
    k___3 ++;
  }
  while_break___5: /* CIL Label */ ;
  }

  while_break___0: ;
#line 205
  return (1);
}
}
#line 208 "/root/patron-new/39/src/lib/openjp2/invert.c"
static void opj_lupSolve(OPJ_FLOAT32 *pResult , OPJ_FLOAT32 *pMatrix , OPJ_FLOAT32 *pVector ,
                         OPJ_UINT32 *pPermutations , OPJ_UINT32 nb_compo___1 , OPJ_FLOAT32 *p_intermediate_data ) 
{ 
  OPJ_INT32 k___4 ;
  OPJ_UINT32 i___83 ;
  OPJ_UINT32 j___13 ;
  OPJ_FLOAT32 sum ;
  OPJ_FLOAT32 u ;
  OPJ_UINT32 lStride___0 ;
  OPJ_FLOAT32 *lCurrentPtr ;
  OPJ_FLOAT32 *lIntermediatePtr ;
  OPJ_FLOAT32 *lDestPtr ;
  OPJ_FLOAT32 *lTmpMatrix___0 ;
  OPJ_FLOAT32 *lLineMatrix ;
  OPJ_FLOAT32 *lBeginPtr ;
  OPJ_FLOAT32 *lGeneratedData ;
  OPJ_UINT32 *lCurrentPermutationPtr ;
  OPJ_FLOAT32 *__cil_tmp21___13 ;
  OPJ_FLOAT32 *__cil_tmp22___15 ;
  OPJ_FLOAT32 *__cil_tmp23___12 ;
  OPJ_UINT32 *__cil_tmp24___9 ;
  OPJ_FLOAT32 *__cil_tmp26___7 ;
  OPJ_FLOAT32 *__cil_tmp27___4 ;
  OPJ_FLOAT32 *__cil_tmp28___4 ;
  OPJ_FLOAT32 *__cil_tmp29___3 ;
  OPJ_FLOAT32 *__cil_tmp30___1 ;
  OPJ_FLOAT32 *__cil_tmp31___2 ;

  {
#line 218
  lStride___0 = nb_compo___1 + 1U;
#line 223
  lLineMatrix = pMatrix;
#line 224
  lBeginPtr = (pResult + nb_compo___1) - 1;
#line 226
  lCurrentPermutationPtr = pPermutations;
#line 229
  lIntermediatePtr = p_intermediate_data;
#line 230
  lGeneratedData = (p_intermediate_data + nb_compo___1) - 1;
#line 232
  i___83 = (OPJ_UINT32 )0;
  {
#line 232
  while (1) {
    while_continue: /* CIL Label */ ;

#line 232
    if (! (i___83 < nb_compo___1)) {
#line 232
      goto while_break;
    }
#line 233
    sum = (OPJ_FLOAT32 )0.;
#line 234
    lCurrentPtr = p_intermediate_data;
#line 235
    lTmpMatrix___0 = lLineMatrix;
#line 236
    j___13 = (OPJ_UINT32 )1;
    {
#line 236
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 236
      if (! (j___13 <= i___83)) {
#line 236
        goto while_break___0;
      }
#line 238
      __cil_tmp22___15 = lCurrentPtr;
#line 238
      lCurrentPtr ++;
#line 238
      __cil_tmp21___13 = lTmpMatrix___0;
#line 238
      lTmpMatrix___0 ++;
#line 238
      sum += *__cil_tmp21___13 * *__cil_tmp22___15;
#line 236
      j___13 ++;
    }
    while_break___4: /* CIL Label */ ;
    }

    while_break___0: 
#line 241
    __cil_tmp24___9 = lCurrentPermutationPtr;
#line 241
    lCurrentPermutationPtr ++;
#line 241
    __cil_tmp23___12 = lIntermediatePtr;
#line 241
    lIntermediatePtr ++;
#line 241
    *__cil_tmp23___12 = *(pVector + *__cil_tmp24___9) - sum;
#line 242
    lLineMatrix += nb_compo___1;
#line 232
    i___83 ++;
  }
  while_break___3: /* CIL Label */ ;
  }

  while_break: 
#line 246
  lLineMatrix = (pMatrix + nb_compo___1 * nb_compo___1) - 1;
#line 249
  lDestPtr = pResult + nb_compo___1;
#line 253
  k___4 = (OPJ_INT32 )nb_compo___1 - 1;
  {
#line 253
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 253
    if (! (k___4 != -1)) {
#line 253
      goto while_break___1;
    }
#line 254
    sum = (OPJ_FLOAT32 )0.;
#line 255
    lTmpMatrix___0 = lLineMatrix;
#line 256
    __cil_tmp26___7 = lTmpMatrix___0;
#line 256
    lTmpMatrix___0 ++;
#line 256
    u = *__cil_tmp26___7;
#line 257
    __cil_tmp27___4 = lDestPtr;
#line 257
    lDestPtr --;
#line 257
    lCurrentPtr = __cil_tmp27___4;
#line 258
    j___13 = (OPJ_UINT32 )(k___4 + 1);
    {
#line 258
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 258
      if (! (j___13 < nb_compo___1)) {
#line 258
        goto while_break___2;
      }
#line 260
      __cil_tmp29___3 = lCurrentPtr;
#line 260
      lCurrentPtr ++;
#line 260
      __cil_tmp28___4 = lTmpMatrix___0;
#line 260
      lTmpMatrix___0 ++;
#line 260
      sum += *__cil_tmp28___4 * *__cil_tmp29___3;
#line 258
      j___13 ++;
    }
    while_break___6: /* CIL Label */ ;
    }

    while_break___2: 
#line 263
    __cil_tmp31___2 = lGeneratedData;
#line 263
    lGeneratedData --;
#line 263
    __cil_tmp30___1 = lBeginPtr;
#line 263
    lBeginPtr --;
#line 263
    *__cil_tmp30___1 = (*__cil_tmp31___2 - sum) / u;
#line 264
    lLineMatrix -= lStride___0;
#line 253
    k___4 --;
  }
  while_break___5: /* CIL Label */ ;
  }

  while_break___1: ;
#line 257
  return;
}
}
#line 269 "/root/patron-new/39/src/lib/openjp2/invert.c"
static void opj_lupInvert(OPJ_FLOAT32 *pSrcMatrix___0 , OPJ_FLOAT32 *pDestMatrix___0 ,
                          OPJ_UINT32 nb_compo___2 , OPJ_UINT32 *pPermutations___0 ,
                          OPJ_FLOAT32 *p_src_temp , OPJ_FLOAT32 *p_dest_temp , OPJ_FLOAT32 *p_swap_area___0 ) 
{ 
  OPJ_UINT32 j___14 ;
  OPJ_UINT32 i___84 ;
  OPJ_FLOAT32 *lCurrentPtr___0 ;
  OPJ_FLOAT32 *lLineMatrix___0 ;
  OPJ_UINT32 lSwapSize___0 ;
  OPJ_FLOAT32 *__cil_tmp13___35 ;

  {
#line 279
  lLineMatrix___0 = pDestMatrix___0;
#line 280
  lSwapSize___0 = nb_compo___2 * (OPJ_UINT32 )sizeof(OPJ_FLOAT32 );
#line 282
  j___14 = (OPJ_UINT32 )0;
  {
#line 282
  while (1) {
    while_continue: /* CIL Label */ ;

#line 282
    if (! (j___14 < nb_compo___2)) {
#line 282
      goto while_break;
    }
    {
#line 283
    __cil_tmp13___35 = lLineMatrix___0;
#line 283
    lLineMatrix___0 ++;
#line 283
    lCurrentPtr___0 = __cil_tmp13___35;
#line 284
    memset((void *)p_src_temp, 0, (unsigned long )lSwapSize___0);
#line 285
    *(p_src_temp + j___14) = (OPJ_FLOAT32 )1.;
#line 286
    opj_lupSolve(p_dest_temp, pSrcMatrix___0, p_src_temp, pPermutations___0, nb_compo___2,
                 p_swap_area___0);
#line 289
    i___84 = (OPJ_UINT32 )0;
    }
    {
#line 289
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 289
      if (! (i___84 < nb_compo___2)) {
#line 289
        goto while_break___0;
      }
#line 290
      *lCurrentPtr___0 = *(p_dest_temp + i___84);
#line 291
      lCurrentPtr___0 += nb_compo___2;
#line 289
      i___84 ++;
    }
    while_break___2: /* CIL Label */ ;
    }

    while_break___0: 
#line 282
    j___14 ++;
  }
  while_break___1: /* CIL Label */ ;
  }

  while_break: ;
#line 286
  return;
}
}
#line 34 "/root/patron-new/39/src/lib/openjp2/image.c"
opj_image_t *opj_image_create0(void) 
{ 
  opj_image_t *image___10 ;
  void *__cil_tmp2___12 ;

  {
  {
#line 36
  __cil_tmp2___12 = opj_calloc((size_t )1, sizeof(opj_image_t ));
#line 36
  image___10 = (opj_image_t *)__cil_tmp2___12;
  }
#line 37
  return (image___10);
}
}
#line 40 "/root/patron-new/39/src/lib/openjp2/image.c"
opj_image_t *opj_image_create(OPJ_UINT32 numcmpts , opj_image_cmptparm_t *cmptparms ,
                              OPJ_COLOR_SPACE clrspc ) 
{ 
  OPJ_UINT32 compno___10 ;
  opj_image_t *image___11 ;
  void *__cil_tmp6___28 ;
  void *__cil_tmp7___38 ;
  opj_image_comp_t *comp ;
  void *__cil_tmp9___28 ;

  {
  {
#line 44
  image___11 = (opj_image_t *)((void *)0);
#line 46
  __cil_tmp6___28 = opj_calloc((size_t )1, sizeof(opj_image_t ));
#line 46
  image___11 = (opj_image_t *)__cil_tmp6___28;
  }
#line 47
  if (image___11) {
    {
#line 48
    image___11->color_space = clrspc;
#line 49
    image___11->numcomps = numcmpts;
#line 51
    __cil_tmp7___38 = opj_calloc((size_t )image___11->numcomps, sizeof(opj_image_comp_t ));
#line 51
    image___11->comps = (opj_image_comp_t *)__cil_tmp7___38;
    }
#line 53
    if (! image___11->comps) {
      {
#line 56
      opj_image_destroy(image___11);
      }
#line 57
      return ((opj_image_t *)((void *)0));
    }
#line 60
    compno___10 = (OPJ_UINT32 )0;
    {
#line 60
    while (1) {
      while_continue: /* CIL Label */ ;

#line 60
      if (! (compno___10 < numcmpts)) {
#line 60
        goto while_break;
      }
#line 61
      comp = image___11->comps + compno___10;
#line 62
      comp->dx = (cmptparms + compno___10)->dx;
#line 63
      comp->dy = (cmptparms + compno___10)->dy;
#line 64
      comp->w = (cmptparms + compno___10)->w;
#line 65
      comp->h = (cmptparms + compno___10)->h;
#line 66
      comp->x0 = (cmptparms + compno___10)->x0;
#line 67
      comp->y0 = (cmptparms + compno___10)->y0;
#line 68
      comp->prec = (cmptparms + compno___10)->prec;
#line 69
      comp->bpp = (cmptparms + compno___10)->bpp;
#line 70
      comp->sgnd = (cmptparms + compno___10)->sgnd;
#line 71
      if (comp->h != 0U) {
#line 71
        if ((OPJ_SIZE_T )comp->w > (0xffffffffffffffffUL / (unsigned long )comp->h) / sizeof(OPJ_INT32 )) {
          {
#line 74
          opj_image_destroy(image___11);
          }
#line 75
          return ((opj_image_t *)((void *)0));
        }
      }
      {
#line 77
      __cil_tmp9___28 = opj_image_data_alloc(((size_t )comp->w * (unsigned long )comp->h) * sizeof(OPJ_INT32 ));
#line 77
      comp->data = (OPJ_INT32 *)__cil_tmp9___28;
      }
#line 79
      if (! comp->data) {
        {
#line 82
        opj_image_destroy(image___11);
        }
#line 83
        return ((opj_image_t *)((void *)0));
      }
      {
#line 85
      memset((void *)comp->data, 0, ((size_t )comp->w * (unsigned long )comp->h) * sizeof(OPJ_INT32 ));
#line 60
      compno___10 ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }

    while_break: ;
  }
#line 89
  return (image___11);
}
}
#line 92 "/root/patron-new/39/src/lib/openjp2/image.c"
void opj_image_destroy(opj_image_t *image___12 ) 
{ 
  OPJ_UINT32 compno___11 ;
  opj_image_comp_t *image_comp ;

  {
#line 94
  if (image___12) {
#line 95
    if (image___12->comps) {
#line 99
      compno___11 = (OPJ_UINT32 )0;
      {
#line 99
      while (1) {
        while_continue: /* CIL Label */ ;

#line 99
        if (! (compno___11 < image___12->numcomps)) {
#line 99
          goto while_break;
        }
#line 100
        image_comp = image___12->comps + compno___11;
#line 101
        if (image_comp->data) {
          {
#line 102
          opj_image_data_free((void *)image_comp->data);
          }
        }
#line 99
        compno___11 ++;
      }
      while_break___0: /* CIL Label */ ;
      }

      while_break: 
      {
#line 105
      opj_free((void *)image___12->comps);
      }
    }
#line 108
    if (image___12->icc_profile_buf) {
      {
#line 109
      opj_free((void *)image___12->icc_profile_buf);
      }
    }
    {
#line 112
    opj_free((void *)image___12);
    }
  }
#line 115
  return;
}
}
#line 122 "/root/patron-new/39/src/lib/openjp2/image.c"
void opj_image_comp_header_update(opj_image_t *p_image_header , struct opj_cp *p_cp___1 ) 
{ 
  OPJ_UINT32 i___85 ;
  OPJ_UINT32 l_width___2 ;
  OPJ_UINT32 l_height___2 ;
  OPJ_UINT32 l_x0___0 ;
  OPJ_UINT32 l_y0___0 ;
  OPJ_UINT32 l_x1___0 ;
  OPJ_UINT32 l_y1___0 ;
  OPJ_UINT32 l_comp_x0 ;
  OPJ_UINT32 l_comp_y0 ;
  OPJ_UINT32 l_comp_x1___1 ;
  OPJ_UINT32 l_comp_y1___1 ;
  opj_image_comp_t *l_img_comp___8 ;
  OPJ_UINT32 __cil_tmp17___22 ;
  OPJ_UINT32 __cil_tmp18___15 ;
  OPJ_UINT32 __cil_tmp19___20 ;
  OPJ_UINT32 __cil_tmp20___19 ;

  {
  {
#line 128
  l_img_comp___8 = (opj_image_comp_t *)((void *)0);
#line 130
  l_x0___0 = opj_uint_max(p_cp___1->tx0, p_image_header->x0);
#line 131
  l_y0___0 = opj_uint_max(p_cp___1->ty0, p_image_header->y0);
#line 132
  l_x1___0 = p_cp___1->tx0 + (p_cp___1->tw - 1U) * p_cp___1->tdx;
#line 134
  l_y1___0 = p_cp___1->ty0 + (p_cp___1->th - 1U) * p_cp___1->tdy;
#line 135
  __cil_tmp17___22 = opj_uint_adds(l_x1___0, p_cp___1->tdx);
#line 135
  __cil_tmp18___15 = opj_uint_min(__cil_tmp17___22, p_image_header->x1);
#line 135
  l_x1___0 = __cil_tmp18___15;
#line 137
  __cil_tmp19___20 = opj_uint_adds(l_y1___0, p_cp___1->tdy);
#line 137
  __cil_tmp20___19 = opj_uint_min(__cil_tmp19___20, p_image_header->y1);
#line 137
  l_y1___0 = __cil_tmp20___19;
#line 140
  l_img_comp___8 = p_image_header->comps;
#line 141
  i___85 = (OPJ_UINT32 )0;
  }
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;

#line 141
    if (! (i___85 < p_image_header->numcomps)) {
#line 141
      goto while_break;
    }
    {
#line 142
    l_comp_x0 = opj_uint_ceildiv(l_x0___0, l_img_comp___8->dx);
#line 143
    l_comp_y0 = opj_uint_ceildiv(l_y0___0, l_img_comp___8->dy);
#line 144
    l_comp_x1___1 = opj_uint_ceildiv(l_x1___0, l_img_comp___8->dx);
#line 145
    l_comp_y1___1 = opj_uint_ceildiv(l_y1___0, l_img_comp___8->dy);
#line 146
    l_width___2 = opj_uint_ceildivpow2(l_comp_x1___1 - l_comp_x0, l_img_comp___8->factor);
#line 147
    l_height___2 = opj_uint_ceildivpow2(l_comp_y1___1 - l_comp_y0, l_img_comp___8->factor);
#line 148
    l_img_comp___8->w = l_width___2;
#line 149
    l_img_comp___8->h = l_height___2;
#line 150
    l_img_comp___8->x0 = l_comp_x0;
#line 151
    l_img_comp___8->y0 = l_comp_y0;
#line 152
    l_img_comp___8 ++;
#line 141
    i___85 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 145
  return;
}
}
#line 165 "/root/patron-new/39/src/lib/openjp2/image.c"
void opj_copy_image_header(opj_image_t *p_image_src , opj_image_t *p_image_dest ) 
{ 
  OPJ_UINT32 compno___12 ;
  opj_image_comp_t *image_comp___0 ;
  void *__cil_tmp8___50 ;
  void *__cil_tmp10___23 ;

  {
#line 174
  p_image_dest->x0 = p_image_src->x0;
#line 175
  p_image_dest->y0 = p_image_src->y0;
#line 176
  p_image_dest->x1 = p_image_src->x1;
#line 177
  p_image_dest->y1 = p_image_src->y1;
#line 179
  if (p_image_dest->comps) {
#line 180
    compno___12 = (OPJ_UINT32 )0;
    {
#line 180
    while (1) {
      while_continue: /* CIL Label */ ;

#line 180
      if (! (compno___12 < p_image_dest->numcomps)) {
#line 180
        goto while_break;
      }
#line 181
      image_comp___0 = p_image_dest->comps + compno___12;
#line 182
      if (image_comp___0->data) {
        {
#line 183
        opj_image_data_free((void *)image_comp___0->data);
        }
      }
#line 180
      compno___12 ++;
    }
    while_break___1: /* CIL Label */ ;
    }

    while_break: 
    {
#line 186
    opj_free((void *)p_image_dest->comps);
#line 187
    p_image_dest->comps = (opj_image_comp_t *)((void *)0);
    }
  }
  {
#line 190
  p_image_dest->numcomps = p_image_src->numcomps;
#line 192
  __cil_tmp8___50 = opj_malloc((unsigned long )p_image_dest->numcomps * sizeof(opj_image_comp_t ));
#line 192
  p_image_dest->comps = (opj_image_comp_t *)__cil_tmp8___50;
  }
#line 194
  if (! p_image_dest->comps) {
#line 195
    p_image_dest->comps = (opj_image_comp_t *)((void *)0);
#line 196
    p_image_dest->numcomps = (OPJ_UINT32 )0;
#line 197
    return;
  }
#line 200
  compno___12 = (OPJ_UINT32 )0;
  {
#line 200
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 200
    if (! (compno___12 < p_image_dest->numcomps)) {
#line 200
      goto while_break___0;
    }
    {
#line 201
    memcpy((void *)(p_image_dest->comps + compno___12), (void const   *)(p_image_src->comps + compno___12),
           sizeof(opj_image_comp_t ));
#line 204
    (p_image_dest->comps + compno___12)->data = (OPJ_INT32 *)((void *)0);
#line 200
    compno___12 ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }

  while_break___0: 
#line 207
  p_image_dest->color_space = p_image_src->color_space;
#line 208
  p_image_dest->icc_profile_len = p_image_src->icc_profile_len;
#line 210
  if (p_image_dest->icc_profile_len) {
    {
#line 211
    __cil_tmp10___23 = opj_malloc((size_t )p_image_dest->icc_profile_len);
#line 211
    p_image_dest->icc_profile_buf = (OPJ_BYTE *)__cil_tmp10___23;
    }
#line 213
    if (! p_image_dest->icc_profile_buf) {
#line 214
      p_image_dest->icc_profile_buf = (OPJ_BYTE *)((void *)0);
#line 215
      p_image_dest->icc_profile_len = (OPJ_UINT32 )0;
#line 216
      return;
    }
    {
#line 218
    memcpy((void *)p_image_dest->icc_profile_buf, (void const   *)p_image_src->icc_profile_buf,
           (unsigned long )p_image_src->icc_profile_len);
    }
  } else {
#line 222
    p_image_dest->icc_profile_buf = (OPJ_BYTE *)((void *)0);
  }
#line 225
  return;
}
}
#line 228 "/root/patron-new/39/src/lib/openjp2/image.c"
opj_image_t *opj_image_tile_create(OPJ_UINT32 numcmpts___0 , opj_image_cmptparm_t *cmptparms___0 ,
                                   OPJ_COLOR_SPACE clrspc___0 ) 
{ 
  OPJ_UINT32 compno___13 ;
  opj_image_t *image___13 ;
  void *__cil_tmp6___29 ;
  void *__cil_tmp7___40 ;
  opj_image_comp_t *comp___0 ;

  {
  {
#line 232
  image___13 = (opj_image_t *)0;
#line 234
  __cil_tmp6___29 = opj_calloc((size_t )1, sizeof(opj_image_t ));
#line 234
  image___13 = (opj_image_t *)__cil_tmp6___29;
  }
#line 235
  if (image___13) {
    {
#line 237
    image___13->color_space = clrspc___0;
#line 238
    image___13->numcomps = numcmpts___0;
#line 241
    __cil_tmp7___40 = opj_calloc((size_t )image___13->numcomps, sizeof(opj_image_comp_t ));
#line 241
    image___13->comps = (opj_image_comp_t *)__cil_tmp7___40;
    }
#line 243
    if (! image___13->comps) {
      {
#line 244
      opj_image_destroy(image___13);
      }
#line 245
      return ((opj_image_t *)0);
    }
#line 249
    compno___13 = (OPJ_UINT32 )0;
    {
#line 249
    while (1) {
      while_continue: /* CIL Label */ ;

#line 249
      if (! (compno___13 < numcmpts___0)) {
#line 249
        goto while_break;
      }
#line 250
      comp___0 = image___13->comps + compno___13;
#line 251
      comp___0->dx = (cmptparms___0 + compno___13)->dx;
#line 252
      comp___0->dy = (cmptparms___0 + compno___13)->dy;
#line 253
      comp___0->w = (cmptparms___0 + compno___13)->w;
#line 254
      comp___0->h = (cmptparms___0 + compno___13)->h;
#line 255
      comp___0->x0 = (cmptparms___0 + compno___13)->x0;
#line 256
      comp___0->y0 = (cmptparms___0 + compno___13)->y0;
#line 257
      comp___0->prec = (cmptparms___0 + compno___13)->prec;
#line 258
      comp___0->sgnd = (cmptparms___0 + compno___13)->sgnd;
#line 259
      comp___0->data = (OPJ_INT32 *)0;
#line 249
      compno___13 ++;
    }
    while_break___0: /* CIL Label */ ;
    }

    while_break: ;
  }
#line 263
  return (image___13);
}
}
#line 39 "/root/patron-new/39/src/lib/openjp2/function_list.c"
opj_procedure_list_t *opj_procedure_list_create(void) 
{ 
  opj_procedure_list_t *l_validation ;
  void *__cil_tmp2___13 ;
  void *__cil_tmp3___26 ;

  {
  {
#line 42
  __cil_tmp2___13 = opj_calloc((size_t )1, sizeof(opj_procedure_list_t ));
#line 42
  l_validation = (opj_procedure_list_t *)__cil_tmp2___13;
  }
#line 44
  if (! l_validation) {
#line 45
    return ((opj_procedure_list_t *)0);
  }
  {
#line 48
  l_validation->m_nb_max_procedures = (OPJ_UINT32 )10;
#line 49
  __cil_tmp3___26 = opj_calloc((size_t )10, sizeof(void (*)(void)));
#line 49
  l_validation->m_procedures = (opj_procedure *)__cil_tmp3___26;
  }
#line 51
  if (! l_validation->m_procedures) {
    {
#line 52
    opj_free((void *)l_validation);
    }
#line 53
    return ((opj_procedure_list_t *)0);
  }
#line 55
  return (l_validation);
}
}
#line 58 "/root/patron-new/39/src/lib/openjp2/function_list.c"
void opj_procedure_list_destroy(opj_procedure_list_t *p_list ) 
{ 


  {
#line 60
  if (! p_list) {
#line 61
    return;
  }
#line 64
  if (p_list->m_procedures) {
    {
#line 65
    opj_free((void *)p_list->m_procedures);
    }
  }
  {
#line 67
  opj_free((void *)p_list);
  }
#line 69
  return;
}
}
#line 70 "/root/patron-new/39/src/lib/openjp2/function_list.c"
OPJ_BOOL opj_procedure_list_add_procedure(opj_procedure_list_t *p_validation_list ,
                                          void (*p_procedure)(void) , opj_event_mgr_t *p_manager___149 ) 
{ 
  opj_procedure *new_procedures ;
  void *__cil_tmp6___30 ;

  {
#line 76
  if (p_validation_list->m_nb_max_procedures == p_validation_list->m_nb_procedures) {
    {
#line 80
    p_validation_list->m_nb_max_procedures += 10U;
#line 81
    __cil_tmp6___30 = opj_realloc((void *)p_validation_list->m_procedures, (unsigned long )p_validation_list->m_nb_max_procedures * sizeof(void (*)(void)));
#line 81
    new_procedures = (opj_procedure *)__cil_tmp6___30;
    }
#line 84
    if (! new_procedures) {
      {
#line 85
      opj_free((void *)p_validation_list->m_procedures);
#line 86
      p_validation_list->m_nb_max_procedures = (OPJ_UINT32 )0;
#line 87
      p_validation_list->m_nb_procedures = (OPJ_UINT32 )0;
#line 88
      opj_event_msg(p_manager___149, 1, "Not enough memory to add a new validation procedure\n");
      }
#line 90
      return (0);
    } else {
#line 92
      p_validation_list->m_procedures = new_procedures;
    }
  }
#line 95
  *(p_validation_list->m_procedures + p_validation_list->m_nb_procedures) = p_procedure;
#line 97
  (p_validation_list->m_nb_procedures) ++;
#line 99
  return (1);
}
}
#line 102 "/root/patron-new/39/src/lib/openjp2/function_list.c"
OPJ_UINT32 opj_procedure_list_get_nb_procedures(opj_procedure_list_t *p_validation_list___0 ) 
{ 


  {
#line 105
  return (p_validation_list___0->m_nb_procedures);
}
}
#line 108 "/root/patron-new/39/src/lib/openjp2/function_list.c"
opj_procedure *opj_procedure_list_get_first_procedure(opj_procedure_list_t *p_validation_list___1 ) 
{ 


  {
#line 111
  return (p_validation_list___1->m_procedures);
}
}
#line 114 "/root/patron-new/39/src/lib/openjp2/function_list.c"
void opj_procedure_list_clear(opj_procedure_list_t *p_validation_list___2 ) 
{ 


  {
#line 116
  p_validation_list___2->m_nb_procedures = (OPJ_UINT32 )0;
#line 117
  return;
}
}
#line 81 "/root/patron-new/39/src/lib/openjp2/event.c"
static void opj_default_callback(char const   *msg , void *client_data ) 
{ 


  {
#line 86
  return;
}
}
#line 91 "/root/patron-new/39/src/lib/openjp2/event.c"
OPJ_BOOL opj_event_msg(opj_event_mgr_t *p_event_mgr , OPJ_INT32 event_type , char const   *fmt 
                       , ...) 
{ 
  void (*msg_handler)(char const   * , void * ) ;
  void *l_data___5 ;
  va_list arg ;
  char message[512] ;

  {
#line 95
  msg_handler = (void (*)(char const   * , void * ))0;
#line 96
  l_data___5 = (void *)0;
#line 98
  if ((unsigned long )p_event_mgr != (unsigned long )((opj_event_mgr_t *)0)) {
#line 100
    if (event_type == 1) {
#line 100
      goto case_1;
    }
#line 104
    if (event_type == 2) {
#line 104
      goto case_2;
    }
#line 108
    if (event_type == 4) {
#line 108
      goto case_4;
    }
#line 112
    goto switch_default;
    case_1: 
#line 101
    msg_handler = p_event_mgr->error_handler;
#line 102
    l_data___5 = p_event_mgr->m_error_data;
#line 103
    goto switch_break;
    case_2: 
#line 105
    msg_handler = p_event_mgr->warning_handler;
#line 106
    l_data___5 = p_event_mgr->m_warning_data;
#line 107
    goto switch_break;
    case_4: 
#line 109
    msg_handler = p_event_mgr->info_handler;
#line 110
    l_data___5 = p_event_mgr->m_info_data;
#line 111
    goto switch_break;
    switch_default: 
#line 113
    goto switch_break;
    switch_break: ;
#line 115
    if ((unsigned long )msg_handler == (unsigned long )((void (*)(char const   * ,
                                                                  void * ))0)) {
#line 116
      return (0);
    }
  } else {
#line 119
    return (0);
  }
#line 122
  if ((unsigned long )fmt != (unsigned long )((char const   *)0)) {
#line 122
    if ((unsigned long )p_event_mgr != (unsigned long )((opj_event_mgr_t *)0)) {
      {
#line 125
      memset((void *)(message), 0, 512UL);
#line 127
      __builtin_va_start((__builtin_va_list )((void *)arg), fmt);
#line 129
      vsnprintf(message, 512UL, fmt, (__gnuc_va_list )((void *)arg));
#line 131
      message[511] = (char )'\000';
#line 133
      __builtin_va_end((__builtin_va_list )((void *)arg));
#line 136
      (*msg_handler)((char const   *)(message), l_data___5);
      }
    }
  }
#line 139
  return (1);
}
}
#line 142 "/root/patron-new/39/src/lib/openjp2/event.c"
void opj_set_default_event_handler(opj_event_mgr_t *p_manager___150 ) 
{ 


  {
#line 144
  p_manager___150->m_error_data = (void *)0;
#line 145
  p_manager___150->m_warning_data = (void *)0;
#line 146
  p_manager___150->m_info_data = (void *)0;
#line 147
  p_manager___150->error_handler = & opj_default_callback;
#line 148
  p_manager___150->info_handler = & opj_default_callback;
#line 149
  p_manager___150->warning_handler = & opj_default_callback;
#line 150
  return;
}
}
#line 47 "/root/patron-new/39/src/lib/openjp2/cio.c"
void opj_write_bytes_BE(OPJ_BYTE *p_buffer___1 , OPJ_UINT32 p_value , OPJ_UINT32 p_nb_bytes___3 ) 
{ 
  OPJ_BYTE *l_data_ptr ;

  {
  {
#line 50
  l_data_ptr = ((OPJ_BYTE *)(& p_value) + sizeof(OPJ_UINT32 )) - p_nb_bytes___3;
#line 55
  memcpy((void *)p_buffer___1, (void const   *)l_data_ptr, (unsigned long )p_nb_bytes___3);
  }
#line 57
  return;
}
}
#line 58 "/root/patron-new/39/src/lib/openjp2/cio.c"
void opj_write_bytes_LE(OPJ_BYTE *p_buffer___2 , OPJ_UINT32 p_value___0 , OPJ_UINT32 p_nb_bytes___4 ) 
{ 
  OPJ_BYTE *l_data_ptr___0 ;
  OPJ_UINT32 i___86 ;
  OPJ_BYTE *__cil_tmp7___41 ;
  OPJ_BYTE *__cil_tmp8___51 ;

  {
#line 61
  l_data_ptr___0 = ((OPJ_BYTE *)(& p_value___0) + p_nb_bytes___4) - 1;
#line 66
  i___86 = (OPJ_UINT32 )0;
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;

#line 66
    if (! (i___86 < p_nb_bytes___4)) {
#line 66
      goto while_break;
    }
#line 67
    __cil_tmp8___51 = l_data_ptr___0;
#line 67
    l_data_ptr___0 --;
#line 67
    __cil_tmp7___41 = p_buffer___2;
#line 67
    p_buffer___2 ++;
#line 67
    *__cil_tmp7___41 = *__cil_tmp8___51;
#line 66
    i___86 ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 70
  return;
}
}
#line 71 "/root/patron-new/39/src/lib/openjp2/cio.c"
void opj_read_bytes_BE(OPJ_BYTE *p_buffer___3 , OPJ_UINT32 *p_value___1 , OPJ_UINT32 p_nb_bytes___5 ) 
{ 
  OPJ_BYTE *l_data_ptr___1 ;

  {
  {
#line 74
  l_data_ptr___1 = (OPJ_BYTE *)p_value___1;
#line 78
  *p_value___1 = (OPJ_UINT32 )0;
#line 79
  memcpy((void *)((l_data_ptr___1 + sizeof(OPJ_UINT32 )) - p_nb_bytes___5), (void const   *)p_buffer___3,
         (unsigned long )p_nb_bytes___5);
  }
#line 81
  return;
}
}
#line 82 "/root/patron-new/39/src/lib/openjp2/cio.c"
void opj_read_bytes_LE(OPJ_BYTE *p_buffer___4 , OPJ_UINT32 *p_value___2 , OPJ_UINT32 p_nb_bytes___6 ) 
{ 
  OPJ_BYTE *l_data_ptr___2 ;
  OPJ_UINT32 i___87 ;
  OPJ_BYTE *__cil_tmp7___42 ;
  OPJ_BYTE *__cil_tmp8___52 ;

  {
#line 85
  l_data_ptr___2 = ((OPJ_BYTE *)p_value___2 + p_nb_bytes___6) - 1;
#line 90
  *p_value___2 = (OPJ_UINT32 )0;
#line 91
  i___87 = (OPJ_UINT32 )0;
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;

#line 91
    if (! (i___87 < p_nb_bytes___6)) {
#line 91
      goto while_break;
    }
#line 92
    __cil_tmp8___52 = p_buffer___4;
#line 92
    p_buffer___4 ++;
#line 92
    __cil_tmp7___42 = l_data_ptr___2;
#line 92
    l_data_ptr___2 --;
#line 92
    *__cil_tmp7___42 = *__cil_tmp8___52;
#line 91
    i___87 ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 95
  return;
}
}
#line 96 "/root/patron-new/39/src/lib/openjp2/cio.c"
void opj_write_double_BE(OPJ_BYTE *p_buffer___5 , OPJ_FLOAT64 p_value___3 ) 
{ 
  OPJ_BYTE *l_data_ptr___3 ;

  {
  {
#line 98
  l_data_ptr___3 = (OPJ_BYTE *)(& p_value___3);
#line 99
  memcpy((void *)p_buffer___5, (void const   *)l_data_ptr___3, sizeof(OPJ_FLOAT64 ));
  }
#line 101
  return;
}
}
#line 102 "/root/patron-new/39/src/lib/openjp2/cio.c"
void opj_write_double_LE(OPJ_BYTE *p_buffer___6 , OPJ_FLOAT64 p_value___4 ) 
{ 
  OPJ_BYTE *l_data_ptr___4 ;
  OPJ_UINT32 i___88 ;
  OPJ_BYTE *__cil_tmp5___34 ;
  OPJ_BYTE *__cil_tmp6___31 ;

  {
#line 104
  l_data_ptr___4 = ((OPJ_BYTE *)(& p_value___4) + sizeof(OPJ_FLOAT64 )) - 1;
#line 107
  i___88 = (OPJ_UINT32 )0;
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;

#line 107
    if (! ((unsigned long )i___88 < sizeof(OPJ_FLOAT64 ))) {
#line 107
      goto while_break;
    }
#line 108
    __cil_tmp6___31 = l_data_ptr___4;
#line 108
    l_data_ptr___4 --;
#line 108
    __cil_tmp5___34 = p_buffer___6;
#line 108
    p_buffer___6 ++;
#line 108
    *__cil_tmp5___34 = *__cil_tmp6___31;
#line 107
    i___88 ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 111
  return;
}
}
#line 112 "/root/patron-new/39/src/lib/openjp2/cio.c"
void opj_read_double_BE(OPJ_BYTE *p_buffer___7 , OPJ_FLOAT64 *p_value___5 ) 
{ 
  OPJ_BYTE *l_data_ptr___5 ;

  {
  {
#line 114
  l_data_ptr___5 = (OPJ_BYTE *)p_value___5;
#line 115
  memcpy((void *)l_data_ptr___5, (void const   *)p_buffer___7, sizeof(OPJ_FLOAT64 ));
  }
#line 117
  return;
}
}
#line 118 "/root/patron-new/39/src/lib/openjp2/cio.c"
void opj_read_double_LE(OPJ_BYTE *p_buffer___8 , OPJ_FLOAT64 *p_value___6 ) 
{ 
  OPJ_BYTE *l_data_ptr___6 ;
  OPJ_UINT32 i___89 ;
  OPJ_BYTE *__cil_tmp5___35 ;
  OPJ_BYTE *__cil_tmp6___32 ;

  {
#line 120
  l_data_ptr___6 = ((OPJ_BYTE *)p_value___6 + sizeof(OPJ_FLOAT64 )) - 1;
#line 122
  i___89 = (OPJ_UINT32 )0;
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;

#line 122
    if (! ((unsigned long )i___89 < sizeof(OPJ_FLOAT64 ))) {
#line 122
      goto while_break;
    }
#line 123
    __cil_tmp6___32 = p_buffer___8;
#line 123
    p_buffer___8 ++;
#line 123
    __cil_tmp5___35 = l_data_ptr___6;
#line 123
    l_data_ptr___6 --;
#line 123
    *__cil_tmp5___35 = *__cil_tmp6___32;
#line 122
    i___89 ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 126
  return;
}
}
#line 127 "/root/patron-new/39/src/lib/openjp2/cio.c"
void opj_write_float_BE(OPJ_BYTE *p_buffer___9 , OPJ_FLOAT32 p_value___7 ) 
{ 
  OPJ_BYTE *l_data_ptr___7 ;

  {
  {
#line 129
  l_data_ptr___7 = (OPJ_BYTE *)(& p_value___7);
#line 130
  memcpy((void *)p_buffer___9, (void const   *)l_data_ptr___7, sizeof(OPJ_FLOAT32 ));
  }
#line 132
  return;
}
}
#line 133 "/root/patron-new/39/src/lib/openjp2/cio.c"
void opj_write_float_LE(OPJ_BYTE *p_buffer___10 , OPJ_FLOAT32 p_value___8 ) 
{ 
  OPJ_BYTE *l_data_ptr___8 ;
  OPJ_UINT32 i___90 ;
  OPJ_BYTE *__cil_tmp5___36 ;
  OPJ_BYTE *__cil_tmp6___33 ;

  {
#line 135
  l_data_ptr___8 = ((OPJ_BYTE *)(& p_value___8) + sizeof(OPJ_FLOAT32 )) - 1;
#line 138
  i___90 = (OPJ_UINT32 )0;
  {
#line 138
  while (1) {
    while_continue: /* CIL Label */ ;

#line 138
    if (! ((unsigned long )i___90 < sizeof(OPJ_FLOAT32 ))) {
#line 138
      goto while_break;
    }
#line 139
    __cil_tmp6___33 = l_data_ptr___8;
#line 139
    l_data_ptr___8 --;
#line 139
    __cil_tmp5___36 = p_buffer___10;
#line 139
    p_buffer___10 ++;
#line 139
    *__cil_tmp5___36 = *__cil_tmp6___33;
#line 138
    i___90 ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 142
  return;
}
}
#line 143 "/root/patron-new/39/src/lib/openjp2/cio.c"
void opj_read_float_BE(OPJ_BYTE *p_buffer___11 , OPJ_FLOAT32 *p_value___9 ) 
{ 
  OPJ_BYTE *l_data_ptr___9 ;

  {
  {
#line 145
  l_data_ptr___9 = (OPJ_BYTE *)p_value___9;
#line 146
  memcpy((void *)l_data_ptr___9, (void const   *)p_buffer___11, sizeof(OPJ_FLOAT32 ));
  }
#line 148
  return;
}
}
#line 149 "/root/patron-new/39/src/lib/openjp2/cio.c"
void opj_read_float_LE(OPJ_BYTE *p_buffer___12 , OPJ_FLOAT32 *p_value___10 ) 
{ 
  OPJ_BYTE *l_data_ptr___10 ;
  OPJ_UINT32 i___91 ;
  OPJ_BYTE *__cil_tmp5___37 ;
  OPJ_BYTE *__cil_tmp6___34 ;

  {
#line 151
  l_data_ptr___10 = ((OPJ_BYTE *)p_value___10 + sizeof(OPJ_FLOAT32 )) - 1;
#line 153
  i___91 = (OPJ_UINT32 )0;
  {
#line 153
  while (1) {
    while_continue: /* CIL Label */ ;

#line 153
    if (! ((unsigned long )i___91 < sizeof(OPJ_FLOAT32 ))) {
#line 153
      goto while_break;
    }
#line 154
    __cil_tmp6___34 = p_buffer___12;
#line 154
    p_buffer___12 ++;
#line 154
    __cil_tmp5___37 = l_data_ptr___10;
#line 154
    l_data_ptr___10 --;
#line 154
    *__cil_tmp5___37 = *__cil_tmp6___34;
#line 153
    i___91 ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 157
  return;
}
}
#line 158 "/root/patron-new/39/src/lib/openjp2/cio.c"
opj_stream_t *opj_stream_create(OPJ_SIZE_T p_buffer_size , OPJ_BOOL l_is_input ) 
{ 
  opj_stream_private_t *l_stream___10 ;
  void *__cil_tmp4___20 ;
  void *__cil_tmp5___38 ;

  {
  {
#line 161
  l_stream___10 = (opj_stream_private_t *)0;
#line 162
  __cil_tmp4___20 = opj_calloc((size_t )1, sizeof(opj_stream_private_t ));
#line 162
  l_stream___10 = (opj_stream_private_t *)__cil_tmp4___20;
  }
#line 163
  if (! l_stream___10) {
#line 164
    return ((opj_stream_t *)0);
  }
  {
#line 167
  l_stream___10->m_buffer_size = p_buffer_size;
#line 168
  __cil_tmp5___38 = opj_malloc(p_buffer_size);
#line 168
  l_stream___10->m_stored_data = (OPJ_BYTE *)__cil_tmp5___38;
  }
#line 169
  if (! l_stream___10->m_stored_data) {
    {
#line 170
    opj_free((void *)l_stream___10);
    }
#line 171
    return ((opj_stream_t *)0);
  }
#line 174
  l_stream___10->m_current_data = l_stream___10->m_stored_data;
#line 176
  if (l_is_input) {
#line 177
    l_stream___10->m_status |= 2U;
#line 178
    l_stream___10->m_opj_skip = & opj_stream_read_skip;
#line 179
    l_stream___10->m_opj_seek = & opj_stream_read_seek;
  } else {
#line 181
    l_stream___10->m_status |= 1U;
#line 182
    l_stream___10->m_opj_skip = & opj_stream_write_skip;
#line 183
    l_stream___10->m_opj_seek = & opj_stream_write_seek;
  }
#line 186
  l_stream___10->m_read_fn = & opj_stream_default_read;
#line 187
  l_stream___10->m_write_fn = & opj_stream_default_write;
#line 188
  l_stream___10->m_skip_fn = & opj_stream_default_skip;
#line 189
  l_stream___10->m_seek_fn = & opj_stream_default_seek;
#line 191
  return ((opj_stream_t *)l_stream___10);
}
}
#line 194 "/root/patron-new/39/src/lib/openjp2/cio.c"
opj_stream_t *opj_stream_default_create(OPJ_BOOL l_is_input___0 ) 
{ 
  opj_stream_t *__cil_tmp2___14 ;

  {
  {
#line 196
  __cil_tmp2___14 = opj_stream_create((OPJ_SIZE_T )1048576, l_is_input___0);
  }
#line 196
  return (__cil_tmp2___14);
}
}
#line 199 "/root/patron-new/39/src/lib/openjp2/cio.c"
void opj_stream_destroy(opj_stream_t *p_stream___72 ) 
{ 
  opj_stream_private_t *l_stream___11 ;

  {
#line 201
  l_stream___11 = (opj_stream_private_t *)p_stream___72;
#line 203
  if (l_stream___11) {
#line 204
    if (l_stream___11->m_free_user_data_fn) {
      {
#line 205
      (*(l_stream___11->m_free_user_data_fn))(l_stream___11->m_user_data);
      }
    }
    {
#line 207
    opj_free((void *)l_stream___11->m_stored_data);
#line 208
    l_stream___11->m_stored_data = (OPJ_BYTE *)0;
#line 209
    opj_free((void *)l_stream___11);
    }
  }
#line 212
  return;
}
}
#line 213 "/root/patron-new/39/src/lib/openjp2/cio.c"
void opj_stream_set_read_function(opj_stream_t *p_stream___73 , OPJ_SIZE_T (*p_function)(void * ,
                                                                                         OPJ_SIZE_T  ,
                                                                                         void * ) ) 
{ 
  opj_stream_private_t *l_stream___12 ;

  {
#line 216
  l_stream___12 = (opj_stream_private_t *)p_stream___73;
#line 218
  if (! l_stream___12) {
#line 219
    return;
  } else
#line 218
  if (! (l_stream___12->m_status & 2U)) {
#line 219
    return;
  }
#line 222
  l_stream___12->m_read_fn = p_function;
#line 223
  return;
}
}
#line 225 "/root/patron-new/39/src/lib/openjp2/cio.c"
void opj_stream_set_seek_function(opj_stream_t *p_stream___74 , OPJ_BOOL (*p_function___0)(OPJ_OFF_T  ,
                                                                                           void * ) ) 
{ 
  opj_stream_private_t *l_stream___13 ;

  {
#line 228
  l_stream___13 = (opj_stream_private_t *)p_stream___74;
#line 230
  if (! l_stream___13) {
#line 231
    return;
  }
#line 233
  l_stream___13->m_seek_fn = p_function___0;
#line 234
  return;
}
}
#line 236 "/root/patron-new/39/src/lib/openjp2/cio.c"
void opj_stream_set_write_function(opj_stream_t *p_stream___75 , OPJ_SIZE_T (*p_function___1)(void * ,
                                                                                              OPJ_SIZE_T  ,
                                                                                              void * ) ) 
{ 
  opj_stream_private_t *l_stream___14 ;

  {
#line 239
  l_stream___14 = (opj_stream_private_t *)p_stream___75;
#line 241
  if (! l_stream___14) {
#line 242
    return;
  } else
#line 241
  if (! (l_stream___14->m_status & 1U)) {
#line 242
    return;
  }
#line 245
  l_stream___14->m_write_fn = p_function___1;
#line 246
  return;
}
}
#line 248 "/root/patron-new/39/src/lib/openjp2/cio.c"
void opj_stream_set_skip_function(opj_stream_t *p_stream___76 , OPJ_OFF_T (*p_function___2)(OPJ_OFF_T  ,
                                                                                            void * ) ) 
{ 
  opj_stream_private_t *l_stream___15 ;

  {
#line 251
  l_stream___15 = (opj_stream_private_t *)p_stream___76;
#line 253
  if (! l_stream___15) {
#line 254
    return;
  }
#line 257
  l_stream___15->m_skip_fn = p_function___2;
#line 258
  return;
}
}
#line 260 "/root/patron-new/39/src/lib/openjp2/cio.c"
void opj_stream_set_user_data(opj_stream_t *p_stream___77 , void *p_data___17 , void (*p_function___3)(void * ) ) 
{ 
  opj_stream_private_t *l_stream___16 ;

  {
#line 263
  l_stream___16 = (opj_stream_private_t *)p_stream___77;
#line 264
  if (! l_stream___16) {
#line 265
    return;
  }
#line 267
  l_stream___16->m_user_data = p_data___17;
#line 268
  l_stream___16->m_free_user_data_fn = p_function___3;
#line 269
  return;
}
}
#line 271 "/root/patron-new/39/src/lib/openjp2/cio.c"
void opj_stream_set_user_data_length(opj_stream_t *p_stream___78 , OPJ_UINT64 data_length ) 
{ 
  opj_stream_private_t *l_stream___17 ;

  {
#line 274
  l_stream___17 = (opj_stream_private_t *)p_stream___78;
#line 275
  if (! l_stream___17) {
#line 276
    return;
  }
#line 278
  l_stream___17->m_user_data_length = data_length;
#line 279
  return;
}
}
#line 281 "/root/patron-new/39/src/lib/openjp2/cio.c"
OPJ_SIZE_T opj_stream_read_data(opj_stream_private_t *p_stream___79 , OPJ_BYTE *p_buffer___13 ,
                                OPJ_SIZE_T p_size___0 , opj_event_mgr_t *p_event_mgr___0 ) 
{ 
  OPJ_SIZE_T l_read_nb_bytes ;
  OPJ_SIZE_T tmp___446 ;
  OPJ_SIZE_T tmp___447 ;
  OPJ_SIZE_T tmp___448 ;

  {
#line 284
  l_read_nb_bytes = (OPJ_SIZE_T )0;
#line 285
  if (p_stream___79->m_bytes_in_buffer >= p_size___0) {
    {
#line 286
    memcpy((void *)p_buffer___13, (void const   *)p_stream___79->m_current_data, p_size___0);
#line 287
    p_stream___79->m_current_data += p_size___0;
#line 288
    p_stream___79->m_bytes_in_buffer -= p_size___0;
#line 289
    l_read_nb_bytes += p_size___0;
#line 290
    p_stream___79->m_byte_offset += (OPJ_OFF_T )p_size___0;
    }
#line 291
    return (l_read_nb_bytes);
  }
#line 295
  if (p_stream___79->m_status & 4U) {
    {
#line 296
    l_read_nb_bytes += p_stream___79->m_bytes_in_buffer;
#line 297
    memcpy((void *)p_buffer___13, (void const   *)p_stream___79->m_current_data, p_stream___79->m_bytes_in_buffer);
#line 298
    p_stream___79->m_current_data += p_stream___79->m_bytes_in_buffer;
#line 299
    p_stream___79->m_byte_offset += (OPJ_OFF_T )p_stream___79->m_bytes_in_buffer;
#line 300
    p_stream___79->m_bytes_in_buffer = (OPJ_SIZE_T )0;
    }
#line 301
    if (l_read_nb_bytes) {
#line 301
      tmp___446 = l_read_nb_bytes;
    } else {
#line 301
      tmp___446 = (OPJ_SIZE_T )-1;
    }
#line 301
    return (tmp___446);
  }
#line 305
  if (p_stream___79->m_bytes_in_buffer) {
    {
#line 306
    l_read_nb_bytes += p_stream___79->m_bytes_in_buffer;
#line 307
    memcpy((void *)p_buffer___13, (void const   *)p_stream___79->m_current_data, p_stream___79->m_bytes_in_buffer);
#line 308
    p_stream___79->m_current_data = p_stream___79->m_stored_data;
#line 309
    p_buffer___13 += p_stream___79->m_bytes_in_buffer;
#line 310
    p_size___0 -= p_stream___79->m_bytes_in_buffer;
#line 311
    p_stream___79->m_byte_offset += (OPJ_OFF_T )p_stream___79->m_bytes_in_buffer;
#line 312
    p_stream___79->m_bytes_in_buffer = (OPJ_SIZE_T )0;
    }
  } else {
#line 317
    p_stream___79->m_current_data = p_stream___79->m_stored_data;
  }
  {
#line 320
  while (1) {
    while_continue: /* CIL Label */ ;

#line 322
    if (p_size___0 < p_stream___79->m_buffer_size) {
      {
#line 324
      p_stream___79->m_bytes_in_buffer = (*(p_stream___79->m_read_fn))((void *)p_stream___79->m_stored_data,
                                                                       p_stream___79->m_buffer_size,
                                                                       p_stream___79->m_user_data);
      }
#line 327
      if (p_stream___79->m_bytes_in_buffer == 0xffffffffffffffffUL) {
        {
#line 329
        opj_event_msg(p_event_mgr___0, 4, "Stream reached its end !\n");
#line 331
        p_stream___79->m_bytes_in_buffer = (OPJ_SIZE_T )0;
#line 332
        p_stream___79->m_status |= 4U;
        }
#line 334
        if (l_read_nb_bytes) {
#line 334
          tmp___447 = l_read_nb_bytes;
        } else {
#line 334
          tmp___447 = (OPJ_SIZE_T )-1;
        }
#line 334
        return (tmp___447);
      } else
#line 335
      if (p_stream___79->m_bytes_in_buffer < p_size___0) {
        {
#line 337
        l_read_nb_bytes += p_stream___79->m_bytes_in_buffer;
#line 338
        memcpy((void *)p_buffer___13, (void const   *)p_stream___79->m_current_data,
               p_stream___79->m_bytes_in_buffer);
#line 339
        p_stream___79->m_current_data = p_stream___79->m_stored_data;
#line 340
        p_buffer___13 += p_stream___79->m_bytes_in_buffer;
#line 341
        p_size___0 -= p_stream___79->m_bytes_in_buffer;
#line 342
        p_stream___79->m_byte_offset += (OPJ_OFF_T )p_stream___79->m_bytes_in_buffer;
#line 343
        p_stream___79->m_bytes_in_buffer = (OPJ_SIZE_T )0;
        }
      } else {
        {
#line 345
        l_read_nb_bytes += p_size___0;
#line 346
        memcpy((void *)p_buffer___13, (void const   *)p_stream___79->m_current_data,
               p_size___0);
#line 347
        p_stream___79->m_current_data += p_size___0;
#line 348
        p_stream___79->m_bytes_in_buffer -= p_size___0;
#line 349
        p_stream___79->m_byte_offset += (OPJ_OFF_T )p_size___0;
        }
#line 350
        return (l_read_nb_bytes);
      }
    } else {
      {
#line 354
      p_stream___79->m_bytes_in_buffer = (*(p_stream___79->m_read_fn))((void *)p_buffer___13,
                                                                       p_size___0,
                                                                       p_stream___79->m_user_data);
      }
#line 357
      if (p_stream___79->m_bytes_in_buffer == 0xffffffffffffffffUL) {
        {
#line 359
        opj_event_msg(p_event_mgr___0, 4, "Stream reached its end !\n");
#line 361
        p_stream___79->m_bytes_in_buffer = (OPJ_SIZE_T )0;
#line 362
        p_stream___79->m_status |= 4U;
        }
#line 364
        if (l_read_nb_bytes) {
#line 364
          tmp___448 = l_read_nb_bytes;
        } else {
#line 364
          tmp___448 = (OPJ_SIZE_T )-1;
        }
#line 364
        return (tmp___448);
      } else
#line 365
      if (p_stream___79->m_bytes_in_buffer < p_size___0) {
#line 367
        l_read_nb_bytes += p_stream___79->m_bytes_in_buffer;
#line 368
        p_stream___79->m_current_data = p_stream___79->m_stored_data;
#line 369
        p_buffer___13 += p_stream___79->m_bytes_in_buffer;
#line 370
        p_size___0 -= p_stream___79->m_bytes_in_buffer;
#line 371
        p_stream___79->m_byte_offset += (OPJ_OFF_T )p_stream___79->m_bytes_in_buffer;
#line 372
        p_stream___79->m_bytes_in_buffer = (OPJ_SIZE_T )0;
      } else {
#line 375
        l_read_nb_bytes += p_stream___79->m_bytes_in_buffer;
#line 376
        p_stream___79->m_byte_offset += (OPJ_OFF_T )p_stream___79->m_bytes_in_buffer;
#line 377
        p_stream___79->m_current_data = p_stream___79->m_stored_data;
#line 378
        p_stream___79->m_bytes_in_buffer = (OPJ_SIZE_T )0;
#line 379
        return (l_read_nb_bytes);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 385
  return;
}
}
#line 385 "/root/patron-new/39/src/lib/openjp2/cio.c"
OPJ_SIZE_T opj_stream_write_data(opj_stream_private_t *p_stream___80 , OPJ_BYTE *p_buffer___14 ,
                                 OPJ_SIZE_T p_size___1 , opj_event_mgr_t *p_event_mgr___1 ) 
{ 
  OPJ_SIZE_T l_remaining_bytes___0 ;
  OPJ_SIZE_T l_write_nb_bytes ;
  OPJ_BOOL __cil_tmp7___44 ;

  {
#line 390
  l_remaining_bytes___0 = (OPJ_SIZE_T )0;
#line 391
  l_write_nb_bytes = (OPJ_SIZE_T )0;
#line 393
  if (p_stream___80->m_status & 8U) {
#line 394
    return ((OPJ_SIZE_T )-1);
  }
  {
#line 397
  while (1) {
    while_continue: /* CIL Label */ ;
#line 398
    l_remaining_bytes___0 = p_stream___80->m_buffer_size - p_stream___80->m_bytes_in_buffer;
#line 401
    if (l_remaining_bytes___0 >= p_size___1) {
      {
#line 402
      memcpy((void *)p_stream___80->m_current_data, (void const   *)p_buffer___14,
             p_size___1);
#line 404
      p_stream___80->m_current_data += p_size___1;
#line 405
      p_stream___80->m_bytes_in_buffer += p_size___1;
#line 406
      l_write_nb_bytes += p_size___1;
#line 407
      p_stream___80->m_byte_offset += (OPJ_OFF_T )p_size___1;
      }
#line 409
      return (l_write_nb_bytes);
    }
#line 413
    if (l_remaining_bytes___0) {
      {
#line 414
      l_write_nb_bytes += l_remaining_bytes___0;
#line 416
      memcpy((void *)p_stream___80->m_current_data, (void const   *)p_buffer___14,
             l_remaining_bytes___0);
#line 418
      p_stream___80->m_current_data = p_stream___80->m_stored_data;
#line 420
      p_buffer___14 += l_remaining_bytes___0;
#line 421
      p_size___1 -= l_remaining_bytes___0;
#line 422
      p_stream___80->m_bytes_in_buffer += l_remaining_bytes___0;
#line 423
      p_stream___80->m_byte_offset += (OPJ_OFF_T )l_remaining_bytes___0;
      }
    }
    {
#line 426
    __cil_tmp7___44 = opj_stream_flush(p_stream___80, p_event_mgr___1);
    }
#line 426
    if (! __cil_tmp7___44) {
#line 427
      return ((OPJ_SIZE_T )-1);
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 432
  return;
}
}
#line 433 "/root/patron-new/39/src/lib/openjp2/cio.c"
OPJ_BOOL opj_stream_flush(opj_stream_private_t *p_stream___81 , opj_event_mgr_t *p_event_mgr___2 ) 
{ 
  OPJ_SIZE_T l_current_write_nb_bytes ;

  {
#line 437
  l_current_write_nb_bytes = (OPJ_SIZE_T )0;
#line 439
  p_stream___81->m_current_data = p_stream___81->m_stored_data;
  {
#line 441
  while (1) {
    while_continue: /* CIL Label */ ;

#line 441
    if (! p_stream___81->m_bytes_in_buffer) {
#line 441
      goto while_break;
    }
    {
#line 443
    l_current_write_nb_bytes = (*(p_stream___81->m_write_fn))((void *)p_stream___81->m_current_data,
                                                              p_stream___81->m_bytes_in_buffer,
                                                              p_stream___81->m_user_data);
    }
#line 447
    if (l_current_write_nb_bytes == 0xffffffffffffffffUL) {
      {
#line 448
      p_stream___81->m_status |= 8U;
#line 449
      opj_event_msg(p_event_mgr___2, 4, "Error on writing stream!\n\2615\006]U");
      }
#line 451
      return (0);
    }
#line 454
    p_stream___81->m_current_data += l_current_write_nb_bytes;
#line 455
    p_stream___81->m_bytes_in_buffer -= l_current_write_nb_bytes;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: 
#line 458
  p_stream___81->m_current_data = p_stream___81->m_stored_data;
#line 460
  return (1);
}
}
#line 463 "/root/patron-new/39/src/lib/openjp2/cio.c"
OPJ_OFF_T opj_stream_read_skip(opj_stream_private_t *p_stream___82 , OPJ_OFF_T p_size___2 ,
                               opj_event_mgr_t *p_event_mgr___3 ) 
{ 
  OPJ_OFF_T l_skip_nb_bytes ;
  OPJ_OFF_T l_current_skip_nb_bytes ;
  OPJ_OFF_T tmp___450 ;
  OPJ_OFF_T tmp___451 ;
  OPJ_OFF_T tmp___452 ;

  {
#line 466
  l_skip_nb_bytes = (OPJ_OFF_T )0;
#line 467
  l_current_skip_nb_bytes = (OPJ_OFF_T )0;
#line 471
  if (p_stream___82->m_bytes_in_buffer >= (OPJ_SIZE_T )p_size___2) {
#line 472
    p_stream___82->m_current_data += p_size___2;
#line 475
    p_stream___82->m_bytes_in_buffer -= (OPJ_SIZE_T )p_size___2;
#line 476
    l_skip_nb_bytes += p_size___2;
#line 477
    p_stream___82->m_byte_offset += l_skip_nb_bytes;
#line 478
    return (l_skip_nb_bytes);
  }
#line 482
  if (p_stream___82->m_status & 4U) {
#line 483
    l_skip_nb_bytes += (OPJ_OFF_T )p_stream___82->m_bytes_in_buffer;
#line 484
    p_stream___82->m_current_data += p_stream___82->m_bytes_in_buffer;
#line 485
    p_stream___82->m_bytes_in_buffer = (OPJ_SIZE_T )0;
#line 486
    p_stream___82->m_byte_offset += l_skip_nb_bytes;
#line 487
    if (l_skip_nb_bytes) {
#line 487
      tmp___450 = l_skip_nb_bytes;
    } else {
#line 487
      tmp___450 = (OPJ_OFF_T )-1;
    }
#line 487
    return (tmp___450);
  }
#line 491
  if (p_stream___82->m_bytes_in_buffer) {
#line 492
    l_skip_nb_bytes += (OPJ_OFF_T )p_stream___82->m_bytes_in_buffer;
#line 493
    p_stream___82->m_current_data = p_stream___82->m_stored_data;
#line 494
    p_size___2 -= (OPJ_OFF_T )p_stream___82->m_bytes_in_buffer;
#line 495
    p_stream___82->m_bytes_in_buffer = (OPJ_SIZE_T )0;
  }
  {
#line 498
  while (1) {
    while_continue: /* CIL Label */ ;

#line 498
    if (! (p_size___2 > 0L)) {
#line 498
      goto while_break;
    }
#line 503
    if ((OPJ_UINT64 )((p_stream___82->m_byte_offset + l_skip_nb_bytes) + p_size___2) > p_stream___82->m_user_data_length) {
      {
#line 505
      opj_event_msg(p_event_mgr___3, 4, "Stream reached its end !\n");
#line 507
      p_stream___82->m_byte_offset += l_skip_nb_bytes;
#line 508
      l_skip_nb_bytes = (OPJ_OFF_T )(p_stream___82->m_user_data_length - (OPJ_UINT64 )p_stream___82->m_byte_offset);
#line 511
      opj_stream_read_seek(p_stream___82, (OPJ_OFF_T )p_stream___82->m_user_data_length,
                           p_event_mgr___3);
#line 513
      p_stream___82->m_status |= 4U;
      }
#line 516
      if (l_skip_nb_bytes) {
#line 516
        tmp___451 = l_skip_nb_bytes;
      } else {
#line 516
        tmp___451 = (OPJ_OFF_T )-1;
      }
#line 516
      return (tmp___451);
    }
    {
#line 520
    l_current_skip_nb_bytes = (*(p_stream___82->m_skip_fn))(p_size___2, p_stream___82->m_user_data);
    }
#line 521
    if (l_current_skip_nb_bytes == -1L) {
      {
#line 522
      opj_event_msg(p_event_mgr___3, 4, "Stream reached its end !\n");
#line 524
      p_stream___82->m_status |= 4U;
#line 525
      p_stream___82->m_byte_offset += l_skip_nb_bytes;
      }
#line 527
      if (l_skip_nb_bytes) {
#line 527
        tmp___452 = l_skip_nb_bytes;
      } else {
#line 527
        tmp___452 = (OPJ_OFF_T )-1;
      }
#line 527
      return (tmp___452);
    }
#line 529
    p_size___2 -= l_current_skip_nb_bytes;
#line 530
    l_skip_nb_bytes += l_current_skip_nb_bytes;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: 
#line 533
  p_stream___82->m_byte_offset += l_skip_nb_bytes;
#line 535
  return (l_skip_nb_bytes);
}
}
#line 538 "/root/patron-new/39/src/lib/openjp2/cio.c"
OPJ_OFF_T opj_stream_write_skip(opj_stream_private_t *p_stream___83 , OPJ_OFF_T p_size___3 ,
                                opj_event_mgr_t *p_event_mgr___4 ) 
{ 
  OPJ_BOOL l_is_written ;
  OPJ_OFF_T l_current_skip_nb_bytes___0 ;
  OPJ_OFF_T l_skip_nb_bytes___0 ;
  OPJ_OFF_T tmp___453 ;

  {
#line 541
  l_is_written = 0;
#line 542
  l_current_skip_nb_bytes___0 = (OPJ_OFF_T )0;
#line 543
  l_skip_nb_bytes___0 = (OPJ_OFF_T )0;
#line 545
  if (p_stream___83->m_status & 8U) {
#line 546
    return ((OPJ_OFF_T )-1);
  }
  {
#line 550
  l_is_written = opj_stream_flush(p_stream___83, p_event_mgr___4);
  }
#line 551
  if (! l_is_written) {
#line 552
    p_stream___83->m_status |= 8U;
#line 553
    p_stream___83->m_bytes_in_buffer = (OPJ_SIZE_T )0;
#line 554
    return ((OPJ_OFF_T )-1);
  }
  {
#line 558
  while (1) {
    while_continue: /* CIL Label */ ;

#line 558
    if (! (p_size___3 > 0L)) {
#line 558
      goto while_break;
    }
    {
#line 560
    l_current_skip_nb_bytes___0 = (*(p_stream___83->m_skip_fn))(p_size___3, p_stream___83->m_user_data);
    }
#line 562
    if (l_current_skip_nb_bytes___0 == -1L) {
      {
#line 563
      opj_event_msg(p_event_mgr___4, 4, "Stream error!\n");
#line 565
      p_stream___83->m_status |= 8U;
#line 566
      p_stream___83->m_byte_offset += l_skip_nb_bytes___0;
      }
#line 568
      if (l_skip_nb_bytes___0) {
#line 568
        tmp___453 = l_skip_nb_bytes___0;
      } else {
#line 568
        tmp___453 = (OPJ_OFF_T )-1;
      }
#line 568
      return (tmp___453);
    }
#line 570
    p_size___3 -= l_current_skip_nb_bytes___0;
#line 571
    l_skip_nb_bytes___0 += l_current_skip_nb_bytes___0;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: 
#line 574
  p_stream___83->m_byte_offset += l_skip_nb_bytes___0;
#line 576
  return (l_skip_nb_bytes___0);
}
}
#line 579 "/root/patron-new/39/src/lib/openjp2/cio.c"
OPJ_OFF_T opj_stream_tell(opj_stream_private_t *p_stream___84 ) 
{ 


  {
#line 581
  return (p_stream___84->m_byte_offset);
}
}
#line 584 "/root/patron-new/39/src/lib/openjp2/cio.c"
OPJ_OFF_T opj_stream_get_number_byte_left(opj_stream_private_t *p_stream___85 ) 
{ 
  OPJ_OFF_T tmp___456 ;

  {
#line 588
  if (p_stream___85->m_user_data_length) {
#line 588
    tmp___456 = (OPJ_OFF_T )p_stream___85->m_user_data_length - p_stream___85->m_byte_offset;
  } else {
#line 588
    tmp___456 = 0L;
  }
#line 588
  return (tmp___456);
}
}
#line 593 "/root/patron-new/39/src/lib/openjp2/cio.c"
OPJ_OFF_T opj_stream_skip(opj_stream_private_t *p_stream___86 , OPJ_OFF_T p_size___4 ,
                          opj_event_mgr_t *p_event_mgr___5 ) 
{ 
  OPJ_OFF_T __cil_tmp5___39 ;

  {
  {
#line 597
  __cil_tmp5___39 = (*(p_stream___86->m_opj_skip))(p_stream___86, p_size___4, p_event_mgr___5);
  }
#line 597
  return (__cil_tmp5___39);
}
}
#line 600 "/root/patron-new/39/src/lib/openjp2/cio.c"
OPJ_BOOL opj_stream_read_seek(opj_stream_private_t *p_stream___87 , OPJ_OFF_T p_size___5 ,
                              opj_event_mgr_t *p_event_mgr___6 ) 
{ 
  OPJ_BOOL __cil_tmp4___22 ;

  {
  {
#line 604
  p_stream___87->m_current_data = p_stream___87->m_stored_data;
#line 605
  p_stream___87->m_bytes_in_buffer = (OPJ_SIZE_T )0;
#line 607
  __cil_tmp4___22 = (*(p_stream___87->m_seek_fn))(p_size___5, p_stream___87->m_user_data);
  }
#line 607
  if (! __cil_tmp4___22) {
#line 608
    p_stream___87->m_status |= 4U;
#line 609
    return (0);
  } else {
#line 612
    p_stream___87->m_status &= 4294967291U;
#line 613
    p_stream___87->m_byte_offset = p_size___5;
  }
#line 617
  return (1);
}
}
#line 620 "/root/patron-new/39/src/lib/openjp2/cio.c"
OPJ_BOOL opj_stream_write_seek(opj_stream_private_t *p_stream___88 , OPJ_OFF_T p_size___6 ,
                               opj_event_mgr_t *p_event_mgr___7 ) 
{ 
  OPJ_BOOL __cil_tmp4___23 ;
  OPJ_BOOL __cil_tmp5___40 ;

  {
  {
#line 623
  __cil_tmp4___23 = opj_stream_flush(p_stream___88, p_event_mgr___7);
  }
#line 623
  if (! __cil_tmp4___23) {
#line 624
    p_stream___88->m_status |= 8U;
#line 625
    return (0);
  }
  {
#line 628
  p_stream___88->m_current_data = p_stream___88->m_stored_data;
#line 629
  p_stream___88->m_bytes_in_buffer = (OPJ_SIZE_T )0;
#line 631
  __cil_tmp5___40 = (*(p_stream___88->m_seek_fn))(p_size___6, p_stream___88->m_user_data);
  }
#line 631
  if (! __cil_tmp5___40) {
#line 632
    p_stream___88->m_status |= 8U;
#line 633
    return (0);
  } else {
#line 635
    p_stream___88->m_byte_offset = p_size___6;
  }
#line 638
  return (1);
}
}
#line 641 "/root/patron-new/39/src/lib/openjp2/cio.c"
OPJ_BOOL opj_stream_seek(opj_stream_private_t *p_stream___89 , OPJ_OFF_T p_size___7 ,
                         struct opj_event_mgr *p_event_mgr___8 ) 
{ 
  OPJ_BOOL __cil_tmp5___41 ;

  {
  {
#line 645
  __cil_tmp5___41 = (*(p_stream___89->m_opj_seek))(p_stream___89, p_size___7, p_event_mgr___8);
  }
#line 645
  return (__cil_tmp5___41);
}
}
#line 648 "/root/patron-new/39/src/lib/openjp2/cio.c"
OPJ_BOOL opj_stream_has_seek(opj_stream_private_t *p_stream___90 ) 
{ 


  {
#line 650
  return ((unsigned long )p_stream___90->m_seek_fn != (unsigned long )(& opj_stream_default_seek));
}
}
#line 653 "/root/patron-new/39/src/lib/openjp2/cio.c"
OPJ_SIZE_T opj_stream_default_read(void *p_buffer___15 , OPJ_SIZE_T p_nb_bytes___7 ,
                                   void *p_user_data___4 ) 
{ 


  {
#line 659
  return ((OPJ_SIZE_T )-1);
}
}
#line 662 "/root/patron-new/39/src/lib/openjp2/cio.c"
OPJ_SIZE_T opj_stream_default_write(void *p_buffer___16 , OPJ_SIZE_T p_nb_bytes___8 ,
                                    void *p_user_data___5 ) 
{ 


  {
#line 668
  return ((OPJ_SIZE_T )-1);
}
}
#line 671 "/root/patron-new/39/src/lib/openjp2/cio.c"
OPJ_OFF_T opj_stream_default_skip(OPJ_OFF_T p_nb_bytes___9 , void *p_user_data___6 ) 
{ 


  {
#line 675
  return ((OPJ_OFF_T )-1);
}
}
#line 678 "/root/patron-new/39/src/lib/openjp2/cio.c"
OPJ_BOOL opj_stream_default_seek(OPJ_OFF_T p_nb_bytes___10 , void *p_user_data___7 ) 
{ 


  {
#line 682
  return (0);
}
}
#line 51 "/root/patron-new/39/src/lib/openjp2/bio.c"
static void opj_bio_putbit(opj_bio_t *bio___1 , OPJ_UINT32 b ) ;
#line 57
static OPJ_UINT32 opj_bio_getbit(opj_bio_t *bio___2 ) ;
#line 63
static OPJ_BOOL opj_bio_byteout(opj_bio_t *bio ) ;
#line 69
static OPJ_BOOL opj_bio_bytein(opj_bio_t *bio___0 ) ;
#line 81 "/root/patron-new/39/src/lib/openjp2/bio.c"
static OPJ_BOOL opj_bio_byteout(opj_bio_t *bio ) 
{ 
  int tmp___459 ;
  OPJ_BYTE *__cil_tmp3___27 ;

  {
#line 83
  bio->buf = (bio->buf << 8) & 65535U;
#line 84
  if (bio->buf == 65280U) {
#line 84
    tmp___459 = 7;
  } else {
#line 84
    tmp___459 = 8;
  }
#line 84
  bio->ct = (OPJ_UINT32 )tmp___459;
#line 85
  if ((OPJ_SIZE_T )bio->bp >= (OPJ_SIZE_T )bio->end) {
#line 86
    return (0);
  }
#line 88
  __cil_tmp3___27 = bio->bp;
#line 88
  (bio->bp) ++;
#line 88
  *__cil_tmp3___27 = (OPJ_BYTE )(bio->buf >> 8);
#line 89
  return (1);
}
}
#line 92 "/root/patron-new/39/src/lib/openjp2/bio.c"
static OPJ_BOOL opj_bio_bytein(opj_bio_t *bio___0 ) 
{ 
  int tmp___460 ;
  OPJ_BYTE *__cil_tmp3___28 ;

  {
#line 94
  bio___0->buf = (bio___0->buf << 8) & 65535U;
#line 95
  if (bio___0->buf == 65280U) {
#line 95
    tmp___460 = 7;
  } else {
#line 95
    tmp___460 = 8;
  }
#line 95
  bio___0->ct = (OPJ_UINT32 )tmp___460;
#line 96
  if ((OPJ_SIZE_T )bio___0->bp >= (OPJ_SIZE_T )bio___0->end) {
#line 97
    return (0);
  }
#line 99
  __cil_tmp3___28 = bio___0->bp;
#line 99
  (bio___0->bp) ++;
#line 99
  bio___0->buf |= (unsigned int )*__cil_tmp3___28;
#line 100
  return (1);
}
}
#line 103 "/root/patron-new/39/src/lib/openjp2/bio.c"
static void opj_bio_putbit(opj_bio_t *bio___1 , OPJ_UINT32 b ) 
{ 
  OPJ_UINT32 __cil_tmp3___29 ;

  {
#line 105
  if (bio___1->ct == 0U) {
    {
#line 106
    opj_bio_byteout(bio___1);
    }
  }
#line 109
  __cil_tmp3___29 = bio___1->ct;
#line 109
  (bio___1->ct) --;
#line 110
  bio___1->buf |= b << bio___1->ct;
#line 111
  return;
}
}
#line 113 "/root/patron-new/39/src/lib/openjp2/bio.c"
static OPJ_UINT32 opj_bio_getbit(opj_bio_t *bio___2 ) 
{ 
  OPJ_UINT32 __cil_tmp2___15 ;

  {
#line 115
  if (bio___2->ct == 0U) {
    {
#line 116
    opj_bio_bytein(bio___2);
    }
  }
#line 119
  __cil_tmp2___15 = bio___2->ct;
#line 119
  (bio___2->ct) --;
#line 120
  return ((bio___2->buf >> bio___2->ct) & 1U);
}
}
#line 129 "/root/patron-new/39/src/lib/openjp2/bio.c"
opj_bio_t *opj_bio_create(void) 
{ 
  opj_bio_t *bio___3 ;
  void *__cil_tmp2___16 ;

  {
  {
#line 131
  __cil_tmp2___16 = opj_malloc(sizeof(opj_bio_t ));
#line 131
  bio___3 = (opj_bio_t *)__cil_tmp2___16;
  }
#line 132
  return (bio___3);
}
}
#line 135 "/root/patron-new/39/src/lib/openjp2/bio.c"
void opj_bio_destroy(opj_bio_t *bio___4 ) 
{ 


  {
#line 137
  if (bio___4) {
    {
#line 138
    opj_free((void *)bio___4);
    }
  }
#line 141
  return;
}
}
#line 142 "/root/patron-new/39/src/lib/openjp2/bio.c"
ptrdiff_t opj_bio_numbytes(opj_bio_t *bio___5 ) 
{ 


  {
#line 144
  return (bio___5->bp - bio___5->start);
}
}
#line 147 "/root/patron-new/39/src/lib/openjp2/bio.c"
void opj_bio_init_enc(opj_bio_t *bio___6 , OPJ_BYTE *bp___3 , OPJ_UINT32 len___4 ) 
{ 


  {
#line 149
  bio___6->start = bp___3;
#line 150
  bio___6->end = bp___3 + len___4;
#line 151
  bio___6->bp = bp___3;
#line 152
  bio___6->buf = (OPJ_UINT32 )0;
#line 153
  bio___6->ct = (OPJ_UINT32 )8;
#line 154
  return;
}
}
#line 156 "/root/patron-new/39/src/lib/openjp2/bio.c"
void opj_bio_init_dec(opj_bio_t *bio___7 , OPJ_BYTE *bp___4 , OPJ_UINT32 len___5 ) 
{ 


  {
#line 158
  bio___7->start = bp___4;
#line 159
  bio___7->end = bp___4 + len___5;
#line 160
  bio___7->bp = bp___4;
#line 161
  bio___7->buf = (OPJ_UINT32 )0;
#line 162
  bio___7->ct = (OPJ_UINT32 )0;
#line 163
  return;
}
}
#line 165 "/root/patron-new/39/src/lib/openjp2/bio.c"
void opj_bio_write(opj_bio_t *bio___8 , OPJ_UINT32 v , OPJ_UINT32 n___1 ) 
{ 
  OPJ_INT32 i___92 ;
  OPJ_INT32 __cil_tmp6___35 ;

  {
#line 170
  i___92 = (OPJ_INT32 )n___1 - 1;
  {
#line 170
  while (1) {
    while_continue: /* CIL Label */ ;

#line 170
    if (! (i___92 >= 0)) {
#line 170
      goto while_break;
    }
    {
#line 171
    opj_bio_putbit(bio___8, (v >> i___92) & 1U);
#line 170
    __cil_tmp6___35 = i___92;
#line 170
    i___92 --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 174
  return;
}
}
#line 175 "/root/patron-new/39/src/lib/openjp2/bio.c"
OPJ_UINT32 opj_bio_read(opj_bio_t *bio___9 , OPJ_UINT32 n___2 ) 
{ 
  OPJ_INT32 i___93 ;
  OPJ_UINT32 v___0 ;
  OPJ_UINT32 __cil_tmp6___36 ;
  OPJ_INT32 __cil_tmp7___46 ;

  {
#line 187
  v___0 = 0U;
#line 188
  i___93 = (OPJ_INT32 )n___2 - 1;
  {
#line 188
  while (1) {
    while_continue: /* CIL Label */ ;

#line 188
    if (! (i___93 >= 0)) {
#line 188
      goto while_break;
    }
    {
#line 189
    __cil_tmp6___36 = opj_bio_getbit(bio___9);
#line 189
    v___0 |= __cil_tmp6___36 << i___93;
#line 188
    __cil_tmp7___46 = i___93;
#line 188
    i___93 --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 192
  return (v___0);
}
}
#line 195 "/root/patron-new/39/src/lib/openjp2/bio.c"
OPJ_BOOL opj_bio_flush(opj_bio_t *bio___10 ) 
{ 
  OPJ_BOOL __cil_tmp2___17 ;
  OPJ_BOOL __cil_tmp3___30 ;

  {
  {
#line 197
  __cil_tmp2___17 = opj_bio_byteout(bio___10);
  }
#line 197
  if (! __cil_tmp2___17) {
#line 198
    return (0);
  }
#line 200
  if (bio___10->ct == 7U) {
    {
#line 201
    __cil_tmp3___30 = opj_bio_byteout(bio___10);
    }
#line 201
    if (! __cil_tmp3___30) {
#line 202
      return (0);
    }
  }
#line 205
  return (1);
}
}
#line 208 "/root/patron-new/39/src/lib/openjp2/bio.c"
OPJ_BOOL opj_bio_inalign(opj_bio_t *bio___11 ) 
{ 
  OPJ_BOOL __cil_tmp2___18 ;

  {
#line 210
  if ((bio___11->buf & 255U) == 255U) {
    {
#line 211
    __cil_tmp2___18 = opj_bio_bytein(bio___11);
    }
#line 211
    if (! __cil_tmp2___18) {
#line 212
      return (0);
    }
  }
#line 215
  bio___11->ct = (OPJ_UINT32 )0;
#line 216
  return (1);
}
}
#line 299 "/usr/include/x86_64-linux-gnu/tiffio.h"
extern void _TIFFfree(void *p ) ;
#line 343
extern void TIFFClose(TIFF *tif ) ;
#line 346
extern int TIFFGetField(TIFF *tif , uint32 tag  , ...) ;
#line 358
extern tmsize_t TIFFStripSize(TIFF *tif ) ;
#line 407
extern int TIFFSetField(TIFF * , uint32   , ...) ;
#line 440
extern TIFF *TIFFOpen(char const   * , char const   * ) ;
#line 469
extern tmsize_t TIFFReadEncodedStrip(TIFF *tif , uint32 strip , void *buf , tmsize_t size ) ;
#line 476
extern tmsize_t TIFFWriteEncodedStrip(TIFF *tif , uint32 strip , void *data , tmsize_t cc ) ;
#line 69 "/root/patron-new/39/src/bin/jp2/convert.h"
void clip_component(opj_image_comp_t *component , OPJ_UINT32 precision ) ;
#line 71
void scale_component(opj_image_comp_t *component___1 , OPJ_UINT32 precision___1 ) ;
#line 76
convert_32s_CXPX convert_32s_CXPX_LUT[5] ;
#line 79
convert_32s_PXCX convert_32s_PXCX_LUT[5] ;
#line 83
convert_XXx32s_C1R convert_XXu32s_C1R_LUT[9] ;
#line 86
convert_32sXXx_C1R convert_32sXXu_C1R_LUT[9] ;
#line 90
opj_image_t *tgatoimage(char const   *filename___1 , opj_cparameters_t *parameters___14 ) ;
#line 91
int imagetotga(opj_image_t *image___25 , char const   *outfile___1 ) ;
#line 94
opj_image_t *bmptoimage(char const   *filename___0 , opj_cparameters_t *parameters___13 ) ;
#line 95
int imagetobmp(opj_image_t *image___23 , char const   *outfile___0 ) ;
#line 98
opj_image_t *tiftoimage(char const   *filename , opj_cparameters_t *parameters___12 ) ;
#line 99
int imagetotif(opj_image_t *image___14 , char const   *outfile ) ;
#line 106
opj_image_t *pgxtoimage(char const   *filename___2 , opj_cparameters_t *parameters___15 ) ;
#line 107
int imagetopgx(opj_image_t *image___27 , char const   *outfile___2 ) ;
#line 109
opj_image_t *pnmtoimage(char const   *filename___3 , opj_cparameters_t *parameters___16 ) ;
#line 110
int imagetopnm(opj_image_t *image___30 , char const   *outfile___3 , int force_split ) ;
#line 113
int imagetoraw(opj_image_t *image___33 , char const   *outfile___5 ) ;
#line 114
int imagetorawl(opj_image_t *image___34 , char const   *outfile___6 ) ;
#line 115
opj_image_t *rawtoimage(char const   *filename___6 , opj_cparameters_t *parameters___19 ,
                        raw_cparameters_t *raw_cp___1 ) ;
#line 117
opj_image_t *rawltoimage(char const   *filename___5 , opj_cparameters_t *parameters___18 ,
                         raw_cparameters_t *raw_cp___0 ) ;
#line 121
int imagetopng(opj_image_t *image___17 , char const   *write_idf ) ;
#line 122
opj_image_t *pngtoimage(char const   *read_idf , opj_cparameters_t *params ) ;
#line 88 "/root/patron-new/39/src/bin/jp2/converttif.c"
static void tif_32sto3u(OPJ_INT32 *pSrc , OPJ_BYTE *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i___94 ;
  OPJ_UINT32 src0 ;
  OPJ_UINT32 src1 ;
  OPJ_UINT32 src2 ;
  OPJ_UINT32 src3 ;
  OPJ_UINT32 src4 ;
  OPJ_UINT32 src5 ;
  OPJ_UINT32 src6 ;
  OPJ_UINT32 src7 ;
  OPJ_BYTE *__cil_tmp13___36 ;
  OPJ_BYTE *__cil_tmp14___38 ;
  OPJ_BYTE *__cil_tmp15___29 ;
  unsigned int trailing ;
  int remaining ;
  OPJ_BYTE *__cil_tmp18___16 ;
  OPJ_BYTE *__cil_tmp19___21 ;
  OPJ_BYTE *__cil_tmp20___20 ;
  OPJ_BYTE *__cil_tmp21___15 ;
  OPJ_BYTE *__cil_tmp22___17 ;
  OPJ_BYTE *__cil_tmp23___14 ;
  OPJ_BYTE *__cil_tmp24___11 ;
  OPJ_BYTE *__cil_tmp25___10 ;
  OPJ_BYTE *__cil_tmp26___9 ;
  OPJ_BYTE *__cil_tmp27___5 ;
  OPJ_BYTE *__cil_tmp28___5 ;
  OPJ_BYTE *__cil_tmp29___4 ;
  OPJ_BYTE *__cil_tmp30___2 ;
  OPJ_BYTE *__cil_tmp31___3 ;
  OPJ_BYTE *__cil_tmp32___3 ;

  {
#line 93
  i___94 = (OPJ_SIZE_T )0;
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;

#line 93
    if (! (i___94 < (length & 0xfffffffffffffff8UL))) {
#line 93
      goto while_break;
    }
#line 94
    src0 = (OPJ_UINT32 )*(pSrc + i___94);
#line 95
    src1 = (OPJ_UINT32 )*(pSrc + (i___94 + 1UL));
#line 96
    src2 = (OPJ_UINT32 )*(pSrc + (i___94 + 2UL));
#line 97
    src3 = (OPJ_UINT32 )*(pSrc + (i___94 + 3UL));
#line 98
    src4 = (OPJ_UINT32 )*(pSrc + (i___94 + 4UL));
#line 99
    src5 = (OPJ_UINT32 )*(pSrc + (i___94 + 5UL));
#line 100
    src6 = (OPJ_UINT32 )*(pSrc + (i___94 + 6UL));
#line 101
    src7 = (OPJ_UINT32 )*(pSrc + (i___94 + 7UL));
#line 103
    __cil_tmp13___36 = pDst;
#line 103
    pDst ++;
#line 103
    *__cil_tmp13___36 = (OPJ_BYTE )(((src0 << 5) | (src1 << 2)) | (src2 >> 1));
#line 104
    __cil_tmp14___38 = pDst;
#line 104
    pDst ++;
#line 104
    *__cil_tmp14___38 = (OPJ_BYTE )((((src2 << 7) | (src3 << 4)) | (src4 << 1)) | (src5 >> 2));
#line 105
    __cil_tmp15___29 = pDst;
#line 105
    pDst ++;
#line 105
    *__cil_tmp15___29 = (OPJ_BYTE )(((src5 << 6) | (src6 << 3)) | src7);
#line 93
    i___94 += 8UL;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 108
  if (length & 7UL) {
#line 109
    trailing = 0U;
#line 110
    remaining = 8;
#line 111
    length &= 7UL;
#line 112
    if (3 >= remaining) {
#line 112
      trailing <<= remaining;
#line 112
      trailing |= (OPJ_UINT32 )*(pSrc + i___94) >> (3 - remaining);
#line 112
      __cil_tmp18___16 = pDst;
#line 112
      pDst ++;
#line 112
      *__cil_tmp18___16 = (OPJ_BYTE )trailing;
#line 112
      trailing = (OPJ_UINT32 )*(pSrc + i___94) & ((1U << (3 - remaining)) - 1U);
#line 112
      if (3 >= remaining + 8) {
#line 112
        __cil_tmp19___21 = pDst;
#line 112
        pDst ++;
#line 112
        *__cil_tmp19___21 = (OPJ_BYTE )(trailing >> (3 - (remaining + 8)));
#line 112
        trailing &= (1U << (3 - (remaining + 8))) - 1U;
#line 112
        remaining += 13;
      } else {
#line 112
        remaining += 5;
      }
    } else {
#line 112
      trailing <<= 3;
#line 112
      trailing |= (OPJ_UINT32 )*(pSrc + i___94);
#line 112
      remaining -= 3;
    }
#line 113
    if (length > 1UL) {
#line 114
      if (3 >= remaining) {
#line 114
        trailing <<= remaining;
#line 114
        trailing |= (OPJ_UINT32 )*(pSrc + (i___94 + 1UL)) >> (3 - remaining);
#line 114
        __cil_tmp20___20 = pDst;
#line 114
        pDst ++;
#line 114
        *__cil_tmp20___20 = (OPJ_BYTE )trailing;
#line 114
        trailing = (OPJ_UINT32 )*(pSrc + (i___94 + 1UL)) & ((1U << (3 - remaining)) - 1U);
#line 114
        if (3 >= remaining + 8) {
#line 114
          __cil_tmp21___15 = pDst;
#line 114
          pDst ++;
#line 114
          *__cil_tmp21___15 = (OPJ_BYTE )(trailing >> (3 - (remaining + 8)));
#line 114
          trailing &= (1U << (3 - (remaining + 8))) - 1U;
#line 114
          remaining += 13;
        } else {
#line 114
          remaining += 5;
        }
      } else {
#line 114
        trailing <<= 3;
#line 114
        trailing |= (OPJ_UINT32 )*(pSrc + (i___94 + 1UL));
#line 114
        remaining -= 3;
      }
#line 115
      if (length > 2UL) {
#line 116
        if (3 >= remaining) {
#line 116
          trailing <<= remaining;
#line 116
          trailing |= (OPJ_UINT32 )*(pSrc + (i___94 + 2UL)) >> (3 - remaining);
#line 116
          __cil_tmp22___17 = pDst;
#line 116
          pDst ++;
#line 116
          *__cil_tmp22___17 = (OPJ_BYTE )trailing;
#line 116
          trailing = (OPJ_UINT32 )*(pSrc + (i___94 + 2UL)) & ((1U << (3 - remaining)) - 1U);
#line 116
          if (3 >= remaining + 8) {
#line 116
            __cil_tmp23___14 = pDst;
#line 116
            pDst ++;
#line 116
            *__cil_tmp23___14 = (OPJ_BYTE )(trailing >> (3 - (remaining + 8)));
#line 116
            trailing &= (1U << (3 - (remaining + 8))) - 1U;
#line 116
            remaining += 13;
          } else {
#line 116
            remaining += 5;
          }
        } else {
#line 116
          trailing <<= 3;
#line 116
          trailing |= (OPJ_UINT32 )*(pSrc + (i___94 + 2UL));
#line 116
          remaining -= 3;
        }
#line 117
        if (length > 3UL) {
#line 118
          if (3 >= remaining) {
#line 118
            trailing <<= remaining;
#line 118
            trailing |= (OPJ_UINT32 )*(pSrc + (i___94 + 3UL)) >> (3 - remaining);
#line 118
            __cil_tmp24___11 = pDst;
#line 118
            pDst ++;
#line 118
            *__cil_tmp24___11 = (OPJ_BYTE )trailing;
#line 118
            trailing = (OPJ_UINT32 )*(pSrc + (i___94 + 3UL)) & ((1U << (3 - remaining)) - 1U);
#line 118
            if (3 >= remaining + 8) {
#line 118
              __cil_tmp25___10 = pDst;
#line 118
              pDst ++;
#line 118
              *__cil_tmp25___10 = (OPJ_BYTE )(trailing >> (3 - (remaining + 8)));
#line 118
              trailing &= (1U << (3 - (remaining + 8))) - 1U;
#line 118
              remaining += 13;
            } else {
#line 118
              remaining += 5;
            }
          } else {
#line 118
            trailing <<= 3;
#line 118
            trailing |= (OPJ_UINT32 )*(pSrc + (i___94 + 3UL));
#line 118
            remaining -= 3;
          }
#line 119
          if (length > 4UL) {
#line 120
            if (3 >= remaining) {
#line 120
              trailing <<= remaining;
#line 120
              trailing |= (OPJ_UINT32 )*(pSrc + (i___94 + 4UL)) >> (3 - remaining);
#line 120
              __cil_tmp26___9 = pDst;
#line 120
              pDst ++;
#line 120
              *__cil_tmp26___9 = (OPJ_BYTE )trailing;
#line 120
              trailing = (OPJ_UINT32 )*(pSrc + (i___94 + 4UL)) & ((1U << (3 - remaining)) - 1U);
#line 120
              if (3 >= remaining + 8) {
#line 120
                __cil_tmp27___5 = pDst;
#line 120
                pDst ++;
#line 120
                *__cil_tmp27___5 = (OPJ_BYTE )(trailing >> (3 - (remaining + 8)));
#line 120
                trailing &= (1U << (3 - (remaining + 8))) - 1U;
#line 120
                remaining += 13;
              } else {
#line 120
                remaining += 5;
              }
            } else {
#line 120
              trailing <<= 3;
#line 120
              trailing |= (OPJ_UINT32 )*(pSrc + (i___94 + 4UL));
#line 120
              remaining -= 3;
            }
#line 121
            if (length > 5UL) {
#line 122
              if (3 >= remaining) {
#line 122
                trailing <<= remaining;
#line 122
                trailing |= (OPJ_UINT32 )*(pSrc + (i___94 + 5UL)) >> (3 - remaining);
#line 122
                __cil_tmp28___5 = pDst;
#line 122
                pDst ++;
#line 122
                *__cil_tmp28___5 = (OPJ_BYTE )trailing;
#line 122
                trailing = (OPJ_UINT32 )*(pSrc + (i___94 + 5UL)) & ((1U << (3 - remaining)) - 1U);
#line 122
                if (3 >= remaining + 8) {
#line 122
                  __cil_tmp29___4 = pDst;
#line 122
                  pDst ++;
#line 122
                  *__cil_tmp29___4 = (OPJ_BYTE )(trailing >> (3 - (remaining + 8)));
#line 122
                  trailing &= (1U << (3 - (remaining + 8))) - 1U;
#line 122
                  remaining += 13;
                } else {
#line 122
                  remaining += 5;
                }
              } else {
#line 122
                trailing <<= 3;
#line 122
                trailing |= (OPJ_UINT32 )*(pSrc + (i___94 + 5UL));
#line 122
                remaining -= 3;
              }
#line 123
              if (length > 6UL) {
#line 124
                if (3 >= remaining) {
#line 124
                  trailing <<= remaining;
#line 124
                  trailing |= (OPJ_UINT32 )*(pSrc + (i___94 + 6UL)) >> (3 - remaining);
#line 124
                  __cil_tmp30___2 = pDst;
#line 124
                  pDst ++;
#line 124
                  *__cil_tmp30___2 = (OPJ_BYTE )trailing;
#line 124
                  trailing = (OPJ_UINT32 )*(pSrc + (i___94 + 6UL)) & ((1U << (3 - remaining)) - 1U);
#line 124
                  if (3 >= remaining + 8) {
#line 124
                    __cil_tmp31___3 = pDst;
#line 124
                    pDst ++;
#line 124
                    *__cil_tmp31___3 = (OPJ_BYTE )(trailing >> (3 - (remaining + 8)));
#line 124
                    trailing &= (1U << (3 - (remaining + 8))) - 1U;
#line 124
                    remaining += 13;
                  } else {
#line 124
                    remaining += 5;
                  }
                } else {
#line 124
                  trailing <<= 3;
#line 124
                  trailing |= (OPJ_UINT32 )*(pSrc + (i___94 + 6UL));
#line 124
                  remaining -= 3;
                }
              }
            }
          }
        }
      }
    }
#line 131
    if (remaining != 8) {
#line 131
      trailing <<= remaining;
#line 131
      __cil_tmp32___3 = pDst;
#line 131
      pDst ++;
#line 131
      *__cil_tmp32___3 = (OPJ_BYTE )trailing;
    }
  }
#line 134
  return;
}
}
#line 135 "/root/patron-new/39/src/bin/jp2/converttif.c"
static void tif_32sto5u(OPJ_INT32 *pSrc___0 , OPJ_BYTE *pDst___0 , OPJ_SIZE_T length___0 ) 
{ 
  OPJ_SIZE_T i___95 ;
  OPJ_UINT32 src0___0 ;
  OPJ_UINT32 src1___0 ;
  OPJ_UINT32 src2___0 ;
  OPJ_UINT32 src3___0 ;
  OPJ_UINT32 src4___0 ;
  OPJ_UINT32 src5___0 ;
  OPJ_UINT32 src6___0 ;
  OPJ_UINT32 src7___0 ;
  OPJ_BYTE *__cil_tmp13___37 ;
  OPJ_BYTE *__cil_tmp14___39 ;
  OPJ_BYTE *__cil_tmp15___30 ;
  OPJ_BYTE *__cil_tmp16___24 ;
  OPJ_BYTE *__cil_tmp17___23 ;
  unsigned int trailing___0 ;
  int remaining___0 ;
  OPJ_BYTE *__cil_tmp20___21 ;
  OPJ_BYTE *__cil_tmp21___16 ;
  OPJ_BYTE *__cil_tmp22___18 ;
  OPJ_BYTE *__cil_tmp23___15 ;
  OPJ_BYTE *__cil_tmp24___12 ;
  OPJ_BYTE *__cil_tmp25___11 ;
  OPJ_BYTE *__cil_tmp26___10 ;
  OPJ_BYTE *__cil_tmp27___6 ;
  OPJ_BYTE *__cil_tmp28___6 ;
  OPJ_BYTE *__cil_tmp29___5 ;
  OPJ_BYTE *__cil_tmp30___3 ;
  OPJ_BYTE *__cil_tmp31___4 ;
  OPJ_BYTE *__cil_tmp32___4 ;
  OPJ_BYTE *__cil_tmp33___2 ;
  OPJ_BYTE *__cil_tmp34___4 ;

  {
#line 140
  i___95 = (OPJ_SIZE_T )0;
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;

#line 140
    if (! (i___95 < (length___0 & 0xfffffffffffffff8UL))) {
#line 140
      goto while_break;
    }
#line 141
    src0___0 = (OPJ_UINT32 )*(pSrc___0 + i___95);
#line 142
    src1___0 = (OPJ_UINT32 )*(pSrc___0 + (i___95 + 1UL));
#line 143
    src2___0 = (OPJ_UINT32 )*(pSrc___0 + (i___95 + 2UL));
#line 144
    src3___0 = (OPJ_UINT32 )*(pSrc___0 + (i___95 + 3UL));
#line 145
    src4___0 = (OPJ_UINT32 )*(pSrc___0 + (i___95 + 4UL));
#line 146
    src5___0 = (OPJ_UINT32 )*(pSrc___0 + (i___95 + 5UL));
#line 147
    src6___0 = (OPJ_UINT32 )*(pSrc___0 + (i___95 + 6UL));
#line 148
    src7___0 = (OPJ_UINT32 )*(pSrc___0 + (i___95 + 7UL));
#line 150
    __cil_tmp13___37 = pDst___0;
#line 150
    pDst___0 ++;
#line 150
    *__cil_tmp13___37 = (OPJ_BYTE )((src0___0 << 3) | (src1___0 >> 2));
#line 151
    __cil_tmp14___39 = pDst___0;
#line 151
    pDst___0 ++;
#line 151
    *__cil_tmp14___39 = (OPJ_BYTE )(((src1___0 << 6) | (src2___0 << 1)) | (src3___0 >> 4));
#line 152
    __cil_tmp15___30 = pDst___0;
#line 152
    pDst___0 ++;
#line 152
    *__cil_tmp15___30 = (OPJ_BYTE )((src3___0 << 4) | (src4___0 >> 1));
#line 153
    __cil_tmp16___24 = pDst___0;
#line 153
    pDst___0 ++;
#line 153
    *__cil_tmp16___24 = (OPJ_BYTE )(((src4___0 << 7) | (src5___0 << 2)) | (src6___0 >> 3));
#line 154
    __cil_tmp17___23 = pDst___0;
#line 154
    pDst___0 ++;
#line 154
    *__cil_tmp17___23 = (OPJ_BYTE )((src6___0 << 5) | src7___0);
#line 140
    i___95 += 8UL;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 158
  if (length___0 & 7UL) {
#line 159
    trailing___0 = 0U;
#line 160
    remaining___0 = 8;
#line 161
    length___0 &= 7UL;
#line 162
    if (5 >= remaining___0) {
#line 162
      trailing___0 <<= remaining___0;
#line 162
      trailing___0 |= (OPJ_UINT32 )*(pSrc___0 + i___95) >> (5 - remaining___0);
#line 162
      __cil_tmp20___21 = pDst___0;
#line 162
      pDst___0 ++;
#line 162
      *__cil_tmp20___21 = (OPJ_BYTE )trailing___0;
#line 162
      trailing___0 = (OPJ_UINT32 )*(pSrc___0 + i___95) & ((1U << (5 - remaining___0)) - 1U);
#line 162
      if (5 >= remaining___0 + 8) {
#line 162
        __cil_tmp21___16 = pDst___0;
#line 162
        pDst___0 ++;
#line 162
        *__cil_tmp21___16 = (OPJ_BYTE )(trailing___0 >> (5 - (remaining___0 + 8)));
#line 162
        trailing___0 &= (1U << (5 - (remaining___0 + 8))) - 1U;
#line 162
        remaining___0 += 11;
      } else {
#line 162
        remaining___0 += 3;
      }
    } else {
#line 162
      trailing___0 <<= 5;
#line 162
      trailing___0 |= (OPJ_UINT32 )*(pSrc___0 + i___95);
#line 162
      remaining___0 -= 5;
    }
#line 163
    if (length___0 > 1UL) {
#line 164
      if (5 >= remaining___0) {
#line 164
        trailing___0 <<= remaining___0;
#line 164
        trailing___0 |= (OPJ_UINT32 )*(pSrc___0 + (i___95 + 1UL)) >> (5 - remaining___0);
#line 164
        __cil_tmp22___18 = pDst___0;
#line 164
        pDst___0 ++;
#line 164
        *__cil_tmp22___18 = (OPJ_BYTE )trailing___0;
#line 164
        trailing___0 = (OPJ_UINT32 )*(pSrc___0 + (i___95 + 1UL)) & ((1U << (5 - remaining___0)) - 1U);
#line 164
        if (5 >= remaining___0 + 8) {
#line 164
          __cil_tmp23___15 = pDst___0;
#line 164
          pDst___0 ++;
#line 164
          *__cil_tmp23___15 = (OPJ_BYTE )(trailing___0 >> (5 - (remaining___0 + 8)));
#line 164
          trailing___0 &= (1U << (5 - (remaining___0 + 8))) - 1U;
#line 164
          remaining___0 += 11;
        } else {
#line 164
          remaining___0 += 3;
        }
      } else {
#line 164
        trailing___0 <<= 5;
#line 164
        trailing___0 |= (OPJ_UINT32 )*(pSrc___0 + (i___95 + 1UL));
#line 164
        remaining___0 -= 5;
      }
#line 165
      if (length___0 > 2UL) {
#line 166
        if (5 >= remaining___0) {
#line 166
          trailing___0 <<= remaining___0;
#line 166
          trailing___0 |= (OPJ_UINT32 )*(pSrc___0 + (i___95 + 2UL)) >> (5 - remaining___0);
#line 166
          __cil_tmp24___12 = pDst___0;
#line 166
          pDst___0 ++;
#line 166
          *__cil_tmp24___12 = (OPJ_BYTE )trailing___0;
#line 166
          trailing___0 = (OPJ_UINT32 )*(pSrc___0 + (i___95 + 2UL)) & ((1U << (5 - remaining___0)) - 1U);
#line 166
          if (5 >= remaining___0 + 8) {
#line 166
            __cil_tmp25___11 = pDst___0;
#line 166
            pDst___0 ++;
#line 166
            *__cil_tmp25___11 = (OPJ_BYTE )(trailing___0 >> (5 - (remaining___0 + 8)));
#line 166
            trailing___0 &= (1U << (5 - (remaining___0 + 8))) - 1U;
#line 166
            remaining___0 += 11;
          } else {
#line 166
            remaining___0 += 3;
          }
        } else {
#line 166
          trailing___0 <<= 5;
#line 166
          trailing___0 |= (OPJ_UINT32 )*(pSrc___0 + (i___95 + 2UL));
#line 166
          remaining___0 -= 5;
        }
#line 167
        if (length___0 > 3UL) {
#line 168
          if (5 >= remaining___0) {
#line 168
            trailing___0 <<= remaining___0;
#line 168
            trailing___0 |= (OPJ_UINT32 )*(pSrc___0 + (i___95 + 3UL)) >> (5 - remaining___0);
#line 168
            __cil_tmp26___10 = pDst___0;
#line 168
            pDst___0 ++;
#line 168
            *__cil_tmp26___10 = (OPJ_BYTE )trailing___0;
#line 168
            trailing___0 = (OPJ_UINT32 )*(pSrc___0 + (i___95 + 3UL)) & ((1U << (5 - remaining___0)) - 1U);
#line 168
            if (5 >= remaining___0 + 8) {
#line 168
              __cil_tmp27___6 = pDst___0;
#line 168
              pDst___0 ++;
#line 168
              *__cil_tmp27___6 = (OPJ_BYTE )(trailing___0 >> (5 - (remaining___0 + 8)));
#line 168
              trailing___0 &= (1U << (5 - (remaining___0 + 8))) - 1U;
#line 168
              remaining___0 += 11;
            } else {
#line 168
              remaining___0 += 3;
            }
          } else {
#line 168
            trailing___0 <<= 5;
#line 168
            trailing___0 |= (OPJ_UINT32 )*(pSrc___0 + (i___95 + 3UL));
#line 168
            remaining___0 -= 5;
          }
#line 169
          if (length___0 > 4UL) {
#line 170
            if (5 >= remaining___0) {
#line 170
              trailing___0 <<= remaining___0;
#line 170
              trailing___0 |= (OPJ_UINT32 )*(pSrc___0 + (i___95 + 4UL)) >> (5 - remaining___0);
#line 170
              __cil_tmp28___6 = pDst___0;
#line 170
              pDst___0 ++;
#line 170
              *__cil_tmp28___6 = (OPJ_BYTE )trailing___0;
#line 170
              trailing___0 = (OPJ_UINT32 )*(pSrc___0 + (i___95 + 4UL)) & ((1U << (5 - remaining___0)) - 1U);
#line 170
              if (5 >= remaining___0 + 8) {
#line 170
                __cil_tmp29___5 = pDst___0;
#line 170
                pDst___0 ++;
#line 170
                *__cil_tmp29___5 = (OPJ_BYTE )(trailing___0 >> (5 - (remaining___0 + 8)));
#line 170
                trailing___0 &= (1U << (5 - (remaining___0 + 8))) - 1U;
#line 170
                remaining___0 += 11;
              } else {
#line 170
                remaining___0 += 3;
              }
            } else {
#line 170
              trailing___0 <<= 5;
#line 170
              trailing___0 |= (OPJ_UINT32 )*(pSrc___0 + (i___95 + 4UL));
#line 170
              remaining___0 -= 5;
            }
#line 171
            if (length___0 > 5UL) {
#line 172
              if (5 >= remaining___0) {
#line 172
                trailing___0 <<= remaining___0;
#line 172
                trailing___0 |= (OPJ_UINT32 )*(pSrc___0 + (i___95 + 5UL)) >> (5 - remaining___0);
#line 172
                __cil_tmp30___3 = pDst___0;
#line 172
                pDst___0 ++;
#line 172
                *__cil_tmp30___3 = (OPJ_BYTE )trailing___0;
#line 172
                trailing___0 = (OPJ_UINT32 )*(pSrc___0 + (i___95 + 5UL)) & ((1U << (5 - remaining___0)) - 1U);
#line 172
                if (5 >= remaining___0 + 8) {
#line 172
                  __cil_tmp31___4 = pDst___0;
#line 172
                  pDst___0 ++;
#line 172
                  *__cil_tmp31___4 = (OPJ_BYTE )(trailing___0 >> (5 - (remaining___0 + 8)));
#line 172
                  trailing___0 &= (1U << (5 - (remaining___0 + 8))) - 1U;
#line 172
                  remaining___0 += 11;
                } else {
#line 172
                  remaining___0 += 3;
                }
              } else {
#line 172
                trailing___0 <<= 5;
#line 172
                trailing___0 |= (OPJ_UINT32 )*(pSrc___0 + (i___95 + 5UL));
#line 172
                remaining___0 -= 5;
              }
#line 173
              if (length___0 > 6UL) {
#line 174
                if (5 >= remaining___0) {
#line 174
                  trailing___0 <<= remaining___0;
#line 174
                  trailing___0 |= (OPJ_UINT32 )*(pSrc___0 + (i___95 + 6UL)) >> (5 - remaining___0);
#line 174
                  __cil_tmp32___4 = pDst___0;
#line 174
                  pDst___0 ++;
#line 174
                  *__cil_tmp32___4 = (OPJ_BYTE )trailing___0;
#line 174
                  trailing___0 = (OPJ_UINT32 )*(pSrc___0 + (i___95 + 6UL)) & ((1U << (5 - remaining___0)) - 1U);
#line 174
                  if (5 >= remaining___0 + 8) {
#line 174
                    __cil_tmp33___2 = pDst___0;
#line 174
                    pDst___0 ++;
#line 174
                    *__cil_tmp33___2 = (OPJ_BYTE )(trailing___0 >> (5 - (remaining___0 + 8)));
#line 174
                    trailing___0 &= (1U << (5 - (remaining___0 + 8))) - 1U;
#line 174
                    remaining___0 += 11;
                  } else {
#line 174
                    remaining___0 += 3;
                  }
                } else {
#line 174
                  trailing___0 <<= 5;
#line 174
                  trailing___0 |= (OPJ_UINT32 )*(pSrc___0 + (i___95 + 6UL));
#line 174
                  remaining___0 -= 5;
                }
              }
            }
          }
        }
      }
    }
#line 181
    if (remaining___0 != 8) {
#line 181
      trailing___0 <<= remaining___0;
#line 181
      __cil_tmp34___4 = pDst___0;
#line 181
      pDst___0 ++;
#line 181
      *__cil_tmp34___4 = (OPJ_BYTE )trailing___0;
    }
  }
#line 184
  return;
}
}
#line 185 "/root/patron-new/39/src/bin/jp2/converttif.c"
static void tif_32sto7u(OPJ_INT32 *pSrc___1 , OPJ_BYTE *pDst___1 , OPJ_SIZE_T length___1 ) 
{ 
  OPJ_SIZE_T i___96 ;
  OPJ_UINT32 src0___1 ;
  OPJ_UINT32 src1___1 ;
  OPJ_UINT32 src2___1 ;
  OPJ_UINT32 src3___1 ;
  OPJ_UINT32 src4___1 ;
  OPJ_UINT32 src5___1 ;
  OPJ_UINT32 src6___1 ;
  OPJ_UINT32 src7___1 ;
  OPJ_BYTE *__cil_tmp13___38 ;
  OPJ_BYTE *__cil_tmp14___40 ;
  OPJ_BYTE *__cil_tmp15___31 ;
  OPJ_BYTE *__cil_tmp16___25 ;
  OPJ_BYTE *__cil_tmp17___24 ;
  OPJ_BYTE *__cil_tmp18___17 ;
  OPJ_BYTE *__cil_tmp19___22 ;
  unsigned int trailing___1 ;
  int remaining___1 ;
  OPJ_BYTE *__cil_tmp22___19 ;
  OPJ_BYTE *__cil_tmp23___16 ;
  OPJ_BYTE *__cil_tmp24___13 ;
  OPJ_BYTE *__cil_tmp25___12 ;
  OPJ_BYTE *__cil_tmp26___11 ;
  OPJ_BYTE *__cil_tmp27___7 ;
  OPJ_BYTE *__cil_tmp28___7 ;
  OPJ_BYTE *__cil_tmp29___6 ;
  OPJ_BYTE *__cil_tmp30___4 ;
  OPJ_BYTE *__cil_tmp31___5 ;
  OPJ_BYTE *__cil_tmp32___5 ;
  OPJ_BYTE *__cil_tmp33___3 ;
  OPJ_BYTE *__cil_tmp34___5 ;
  OPJ_BYTE *__cil_tmp35___4 ;
  OPJ_BYTE *__cil_tmp36___2 ;

  {
#line 190
  i___96 = (OPJ_SIZE_T )0;
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;

#line 190
    if (! (i___96 < (length___1 & 0xfffffffffffffff8UL))) {
#line 190
      goto while_break;
    }
#line 191
    src0___1 = (OPJ_UINT32 )*(pSrc___1 + i___96);
#line 192
    src1___1 = (OPJ_UINT32 )*(pSrc___1 + (i___96 + 1UL));
#line 193
    src2___1 = (OPJ_UINT32 )*(pSrc___1 + (i___96 + 2UL));
#line 194
    src3___1 = (OPJ_UINT32 )*(pSrc___1 + (i___96 + 3UL));
#line 195
    src4___1 = (OPJ_UINT32 )*(pSrc___1 + (i___96 + 4UL));
#line 196
    src5___1 = (OPJ_UINT32 )*(pSrc___1 + (i___96 + 5UL));
#line 197
    src6___1 = (OPJ_UINT32 )*(pSrc___1 + (i___96 + 6UL));
#line 198
    src7___1 = (OPJ_UINT32 )*(pSrc___1 + (i___96 + 7UL));
#line 200
    __cil_tmp13___38 = pDst___1;
#line 200
    pDst___1 ++;
#line 200
    *__cil_tmp13___38 = (OPJ_BYTE )((src0___1 << 1) | (src1___1 >> 6));
#line 201
    __cil_tmp14___40 = pDst___1;
#line 201
    pDst___1 ++;
#line 201
    *__cil_tmp14___40 = (OPJ_BYTE )((src1___1 << 2) | (src2___1 >> 5));
#line 202
    __cil_tmp15___31 = pDst___1;
#line 202
    pDst___1 ++;
#line 202
    *__cil_tmp15___31 = (OPJ_BYTE )((src2___1 << 3) | (src3___1 >> 4));
#line 203
    __cil_tmp16___25 = pDst___1;
#line 203
    pDst___1 ++;
#line 203
    *__cil_tmp16___25 = (OPJ_BYTE )((src3___1 << 4) | (src4___1 >> 3));
#line 204
    __cil_tmp17___24 = pDst___1;
#line 204
    pDst___1 ++;
#line 204
    *__cil_tmp17___24 = (OPJ_BYTE )((src4___1 << 5) | (src5___1 >> 2));
#line 205
    __cil_tmp18___17 = pDst___1;
#line 205
    pDst___1 ++;
#line 205
    *__cil_tmp18___17 = (OPJ_BYTE )((src5___1 << 6) | (src6___1 >> 1));
#line 206
    __cil_tmp19___22 = pDst___1;
#line 206
    pDst___1 ++;
#line 206
    *__cil_tmp19___22 = (OPJ_BYTE )((src6___1 << 7) | src7___1);
#line 190
    i___96 += 8UL;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 209
  if (length___1 & 7UL) {
#line 210
    trailing___1 = 0U;
#line 211
    remaining___1 = 8;
#line 212
    length___1 &= 7UL;
#line 213
    if (7 >= remaining___1) {
#line 213
      trailing___1 <<= remaining___1;
#line 213
      trailing___1 |= (OPJ_UINT32 )*(pSrc___1 + i___96) >> (7 - remaining___1);
#line 213
      __cil_tmp22___19 = pDst___1;
#line 213
      pDst___1 ++;
#line 213
      *__cil_tmp22___19 = (OPJ_BYTE )trailing___1;
#line 213
      trailing___1 = (OPJ_UINT32 )*(pSrc___1 + i___96) & ((1U << (7 - remaining___1)) - 1U);
#line 213
      if (7 >= remaining___1 + 8) {
#line 213
        __cil_tmp23___16 = pDst___1;
#line 213
        pDst___1 ++;
#line 213
        *__cil_tmp23___16 = (OPJ_BYTE )(trailing___1 >> (7 - (remaining___1 + 8)));
#line 213
        trailing___1 &= (1U << (7 - (remaining___1 + 8))) - 1U;
#line 213
        remaining___1 += 9;
      } else {
#line 213
        remaining___1 ++;
      }
    } else {
#line 213
      trailing___1 <<= 7;
#line 213
      trailing___1 |= (OPJ_UINT32 )*(pSrc___1 + i___96);
#line 213
      remaining___1 -= 7;
    }
#line 214
    if (length___1 > 1UL) {
#line 215
      if (7 >= remaining___1) {
#line 215
        trailing___1 <<= remaining___1;
#line 215
        trailing___1 |= (OPJ_UINT32 )*(pSrc___1 + (i___96 + 1UL)) >> (7 - remaining___1);
#line 215
        __cil_tmp24___13 = pDst___1;
#line 215
        pDst___1 ++;
#line 215
        *__cil_tmp24___13 = (OPJ_BYTE )trailing___1;
#line 215
        trailing___1 = (OPJ_UINT32 )*(pSrc___1 + (i___96 + 1UL)) & ((1U << (7 - remaining___1)) - 1U);
#line 215
        if (7 >= remaining___1 + 8) {
#line 215
          __cil_tmp25___12 = pDst___1;
#line 215
          pDst___1 ++;
#line 215
          *__cil_tmp25___12 = (OPJ_BYTE )(trailing___1 >> (7 - (remaining___1 + 8)));
#line 215
          trailing___1 &= (1U << (7 - (remaining___1 + 8))) - 1U;
#line 215
          remaining___1 += 9;
        } else {
#line 215
          remaining___1 ++;
        }
      } else {
#line 215
        trailing___1 <<= 7;
#line 215
        trailing___1 |= (OPJ_UINT32 )*(pSrc___1 + (i___96 + 1UL));
#line 215
        remaining___1 -= 7;
      }
#line 216
      if (length___1 > 2UL) {
#line 217
        if (7 >= remaining___1) {
#line 217
          trailing___1 <<= remaining___1;
#line 217
          trailing___1 |= (OPJ_UINT32 )*(pSrc___1 + (i___96 + 2UL)) >> (7 - remaining___1);
#line 217
          __cil_tmp26___11 = pDst___1;
#line 217
          pDst___1 ++;
#line 217
          *__cil_tmp26___11 = (OPJ_BYTE )trailing___1;
#line 217
          trailing___1 = (OPJ_UINT32 )*(pSrc___1 + (i___96 + 2UL)) & ((1U << (7 - remaining___1)) - 1U);
#line 217
          if (7 >= remaining___1 + 8) {
#line 217
            __cil_tmp27___7 = pDst___1;
#line 217
            pDst___1 ++;
#line 217
            *__cil_tmp27___7 = (OPJ_BYTE )(trailing___1 >> (7 - (remaining___1 + 8)));
#line 217
            trailing___1 &= (1U << (7 - (remaining___1 + 8))) - 1U;
#line 217
            remaining___1 += 9;
          } else {
#line 217
            remaining___1 ++;
          }
        } else {
#line 217
          trailing___1 <<= 7;
#line 217
          trailing___1 |= (OPJ_UINT32 )*(pSrc___1 + (i___96 + 2UL));
#line 217
          remaining___1 -= 7;
        }
#line 218
        if (length___1 > 3UL) {
#line 219
          if (7 >= remaining___1) {
#line 219
            trailing___1 <<= remaining___1;
#line 219
            trailing___1 |= (OPJ_UINT32 )*(pSrc___1 + (i___96 + 3UL)) >> (7 - remaining___1);
#line 219
            __cil_tmp28___7 = pDst___1;
#line 219
            pDst___1 ++;
#line 219
            *__cil_tmp28___7 = (OPJ_BYTE )trailing___1;
#line 219
            trailing___1 = (OPJ_UINT32 )*(pSrc___1 + (i___96 + 3UL)) & ((1U << (7 - remaining___1)) - 1U);
#line 219
            if (7 >= remaining___1 + 8) {
#line 219
              __cil_tmp29___6 = pDst___1;
#line 219
              pDst___1 ++;
#line 219
              *__cil_tmp29___6 = (OPJ_BYTE )(trailing___1 >> (7 - (remaining___1 + 8)));
#line 219
              trailing___1 &= (1U << (7 - (remaining___1 + 8))) - 1U;
#line 219
              remaining___1 += 9;
            } else {
#line 219
              remaining___1 ++;
            }
          } else {
#line 219
            trailing___1 <<= 7;
#line 219
            trailing___1 |= (OPJ_UINT32 )*(pSrc___1 + (i___96 + 3UL));
#line 219
            remaining___1 -= 7;
          }
#line 220
          if (length___1 > 4UL) {
#line 221
            if (7 >= remaining___1) {
#line 221
              trailing___1 <<= remaining___1;
#line 221
              trailing___1 |= (OPJ_UINT32 )*(pSrc___1 + (i___96 + 4UL)) >> (7 - remaining___1);
#line 221
              __cil_tmp30___4 = pDst___1;
#line 221
              pDst___1 ++;
#line 221
              *__cil_tmp30___4 = (OPJ_BYTE )trailing___1;
#line 221
              trailing___1 = (OPJ_UINT32 )*(pSrc___1 + (i___96 + 4UL)) & ((1U << (7 - remaining___1)) - 1U);
#line 221
              if (7 >= remaining___1 + 8) {
#line 221
                __cil_tmp31___5 = pDst___1;
#line 221
                pDst___1 ++;
#line 221
                *__cil_tmp31___5 = (OPJ_BYTE )(trailing___1 >> (7 - (remaining___1 + 8)));
#line 221
                trailing___1 &= (1U << (7 - (remaining___1 + 8))) - 1U;
#line 221
                remaining___1 += 9;
              } else {
#line 221
                remaining___1 ++;
              }
            } else {
#line 221
              trailing___1 <<= 7;
#line 221
              trailing___1 |= (OPJ_UINT32 )*(pSrc___1 + (i___96 + 4UL));
#line 221
              remaining___1 -= 7;
            }
#line 222
            if (length___1 > 5UL) {
#line 223
              if (7 >= remaining___1) {
#line 223
                trailing___1 <<= remaining___1;
#line 223
                trailing___1 |= (OPJ_UINT32 )*(pSrc___1 + (i___96 + 5UL)) >> (7 - remaining___1);
#line 223
                __cil_tmp32___5 = pDst___1;
#line 223
                pDst___1 ++;
#line 223
                *__cil_tmp32___5 = (OPJ_BYTE )trailing___1;
#line 223
                trailing___1 = (OPJ_UINT32 )*(pSrc___1 + (i___96 + 5UL)) & ((1U << (7 - remaining___1)) - 1U);
#line 223
                if (7 >= remaining___1 + 8) {
#line 223
                  __cil_tmp33___3 = pDst___1;
#line 223
                  pDst___1 ++;
#line 223
                  *__cil_tmp33___3 = (OPJ_BYTE )(trailing___1 >> (7 - (remaining___1 + 8)));
#line 223
                  trailing___1 &= (1U << (7 - (remaining___1 + 8))) - 1U;
#line 223
                  remaining___1 += 9;
                } else {
#line 223
                  remaining___1 ++;
                }
              } else {
#line 223
                trailing___1 <<= 7;
#line 223
                trailing___1 |= (OPJ_UINT32 )*(pSrc___1 + (i___96 + 5UL));
#line 223
                remaining___1 -= 7;
              }
#line 224
              if (length___1 > 6UL) {
#line 225
                if (7 >= remaining___1) {
#line 225
                  trailing___1 <<= remaining___1;
#line 225
                  trailing___1 |= (OPJ_UINT32 )*(pSrc___1 + (i___96 + 6UL)) >> (7 - remaining___1);
#line 225
                  __cil_tmp34___5 = pDst___1;
#line 225
                  pDst___1 ++;
#line 225
                  *__cil_tmp34___5 = (OPJ_BYTE )trailing___1;
#line 225
                  trailing___1 = (OPJ_UINT32 )*(pSrc___1 + (i___96 + 6UL)) & ((1U << (7 - remaining___1)) - 1U);
#line 225
                  if (7 >= remaining___1 + 8) {
#line 225
                    __cil_tmp35___4 = pDst___1;
#line 225
                    pDst___1 ++;
#line 225
                    *__cil_tmp35___4 = (OPJ_BYTE )(trailing___1 >> (7 - (remaining___1 + 8)));
#line 225
                    trailing___1 &= (1U << (7 - (remaining___1 + 8))) - 1U;
#line 225
                    remaining___1 += 9;
                  } else {
#line 225
                    remaining___1 ++;
                  }
                } else {
#line 225
                  trailing___1 <<= 7;
#line 225
                  trailing___1 |= (OPJ_UINT32 )*(pSrc___1 + (i___96 + 6UL));
#line 225
                  remaining___1 -= 7;
                }
              }
            }
          }
        }
      }
    }
#line 232
    if (remaining___1 != 8) {
#line 232
      trailing___1 <<= remaining___1;
#line 232
      __cil_tmp36___2 = pDst___1;
#line 232
      pDst___1 ++;
#line 232
      *__cil_tmp36___2 = (OPJ_BYTE )trailing___1;
    }
  }
#line 235
  return;
}
}
#line 236 "/root/patron-new/39/src/bin/jp2/converttif.c"
static void tif_32sto9u(OPJ_INT32 *pSrc___2 , OPJ_BYTE *pDst___2 , OPJ_SIZE_T length___2 ) 
{ 
  OPJ_SIZE_T i___97 ;
  OPJ_UINT32 src0___2 ;
  OPJ_UINT32 src1___2 ;
  OPJ_UINT32 src2___2 ;
  OPJ_UINT32 src3___2 ;
  OPJ_UINT32 src4___2 ;
  OPJ_UINT32 src5___2 ;
  OPJ_UINT32 src6___2 ;
  OPJ_UINT32 src7___2 ;
  OPJ_BYTE *__cil_tmp13___39 ;
  OPJ_BYTE *__cil_tmp14___41 ;
  OPJ_BYTE *__cil_tmp15___32 ;
  OPJ_BYTE *__cil_tmp16___26 ;
  OPJ_BYTE *__cil_tmp17___25 ;
  OPJ_BYTE *__cil_tmp18___18 ;
  OPJ_BYTE *__cil_tmp19___23 ;
  OPJ_BYTE *__cil_tmp20___22 ;
  OPJ_BYTE *__cil_tmp21___17 ;
  unsigned int trailing___2 ;
  int remaining___2 ;
  OPJ_BYTE *__cil_tmp24___14 ;
  OPJ_BYTE *__cil_tmp25___13 ;
  OPJ_BYTE *__cil_tmp26___12 ;
  OPJ_BYTE *__cil_tmp27___8 ;
  OPJ_BYTE *__cil_tmp28___8 ;
  OPJ_BYTE *__cil_tmp29___7 ;
  OPJ_BYTE *__cil_tmp30___5 ;
  OPJ_BYTE *__cil_tmp31___6 ;
  OPJ_BYTE *__cil_tmp32___6 ;
  OPJ_BYTE *__cil_tmp33___4 ;
  OPJ_BYTE *__cil_tmp34___6 ;
  OPJ_BYTE *__cil_tmp35___5 ;
  OPJ_BYTE *__cil_tmp36___3 ;
  OPJ_BYTE *__cil_tmp37___1 ;
  OPJ_BYTE *__cil_tmp38___0 ;

  {
#line 241
  i___97 = (OPJ_SIZE_T )0;
  {
#line 241
  while (1) {
    while_continue: /* CIL Label */ ;

#line 241
    if (! (i___97 < (length___2 & 0xfffffffffffffff8UL))) {
#line 241
      goto while_break;
    }
#line 242
    src0___2 = (OPJ_UINT32 )*(pSrc___2 + i___97);
#line 243
    src1___2 = (OPJ_UINT32 )*(pSrc___2 + (i___97 + 1UL));
#line 244
    src2___2 = (OPJ_UINT32 )*(pSrc___2 + (i___97 + 2UL));
#line 245
    src3___2 = (OPJ_UINT32 )*(pSrc___2 + (i___97 + 3UL));
#line 246
    src4___2 = (OPJ_UINT32 )*(pSrc___2 + (i___97 + 4UL));
#line 247
    src5___2 = (OPJ_UINT32 )*(pSrc___2 + (i___97 + 5UL));
#line 248
    src6___2 = (OPJ_UINT32 )*(pSrc___2 + (i___97 + 6UL));
#line 249
    src7___2 = (OPJ_UINT32 )*(pSrc___2 + (i___97 + 7UL));
#line 251
    __cil_tmp13___39 = pDst___2;
#line 251
    pDst___2 ++;
#line 251
    *__cil_tmp13___39 = (OPJ_BYTE )(src0___2 >> 1);
#line 252
    __cil_tmp14___41 = pDst___2;
#line 252
    pDst___2 ++;
#line 252
    *__cil_tmp14___41 = (OPJ_BYTE )((src0___2 << 7) | (src1___2 >> 2));
#line 253
    __cil_tmp15___32 = pDst___2;
#line 253
    pDst___2 ++;
#line 253
    *__cil_tmp15___32 = (OPJ_BYTE )((src1___2 << 6) | (src2___2 >> 3));
#line 254
    __cil_tmp16___26 = pDst___2;
#line 254
    pDst___2 ++;
#line 254
    *__cil_tmp16___26 = (OPJ_BYTE )((src2___2 << 5) | (src3___2 >> 4));
#line 255
    __cil_tmp17___25 = pDst___2;
#line 255
    pDst___2 ++;
#line 255
    *__cil_tmp17___25 = (OPJ_BYTE )((src3___2 << 4) | (src4___2 >> 5));
#line 256
    __cil_tmp18___18 = pDst___2;
#line 256
    pDst___2 ++;
#line 256
    *__cil_tmp18___18 = (OPJ_BYTE )((src4___2 << 3) | (src5___2 >> 6));
#line 257
    __cil_tmp19___23 = pDst___2;
#line 257
    pDst___2 ++;
#line 257
    *__cil_tmp19___23 = (OPJ_BYTE )((src5___2 << 2) | (src6___2 >> 7));
#line 258
    __cil_tmp20___22 = pDst___2;
#line 258
    pDst___2 ++;
#line 258
    *__cil_tmp20___22 = (OPJ_BYTE )((src6___2 << 1) | (src7___2 >> 8));
#line 259
    __cil_tmp21___17 = pDst___2;
#line 259
    pDst___2 ++;
#line 259
    *__cil_tmp21___17 = (OPJ_BYTE )src7___2;
#line 241
    i___97 += 8UL;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 262
  if (length___2 & 7UL) {
#line 263
    trailing___2 = 0U;
#line 264
    remaining___2 = 8;
#line 265
    length___2 &= 7UL;
#line 266
    trailing___2 <<= remaining___2;
#line 266
    trailing___2 |= (OPJ_UINT32 )*(pSrc___2 + i___97) >> (9 - remaining___2);
#line 266
    __cil_tmp24___14 = pDst___2;
#line 266
    pDst___2 ++;
#line 266
    *__cil_tmp24___14 = (OPJ_BYTE )trailing___2;
#line 266
    trailing___2 = (OPJ_UINT32 )*(pSrc___2 + i___97) & ((1U << (9 - remaining___2)) - 1U);
#line 266
    if (9 >= remaining___2 + 8) {
#line 266
      __cil_tmp25___13 = pDst___2;
#line 266
      pDst___2 ++;
#line 266
      *__cil_tmp25___13 = (OPJ_BYTE )(trailing___2 >> (9 - (remaining___2 + 8)));
#line 266
      trailing___2 &= (1U << (9 - (remaining___2 + 8))) - 1U;
#line 266
      remaining___2 += 7;
    } else {
#line 266
      remaining___2 --;
    }
#line 267
    if (length___2 > 1UL) {
#line 268
      trailing___2 <<= remaining___2;
#line 268
      trailing___2 |= (OPJ_UINT32 )*(pSrc___2 + (i___97 + 1UL)) >> (9 - remaining___2);
#line 268
      __cil_tmp26___12 = pDst___2;
#line 268
      pDst___2 ++;
#line 268
      *__cil_tmp26___12 = (OPJ_BYTE )trailing___2;
#line 268
      trailing___2 = (OPJ_UINT32 )*(pSrc___2 + (i___97 + 1UL)) & ((1U << (9 - remaining___2)) - 1U);
#line 268
      if (9 >= remaining___2 + 8) {
#line 268
        __cil_tmp27___8 = pDst___2;
#line 268
        pDst___2 ++;
#line 268
        *__cil_tmp27___8 = (OPJ_BYTE )(trailing___2 >> (9 - (remaining___2 + 8)));
#line 268
        trailing___2 &= (1U << (9 - (remaining___2 + 8))) - 1U;
#line 268
        remaining___2 += 7;
      } else {
#line 268
        remaining___2 --;
      }
#line 269
      if (length___2 > 2UL) {
#line 270
        trailing___2 <<= remaining___2;
#line 270
        trailing___2 |= (OPJ_UINT32 )*(pSrc___2 + (i___97 + 2UL)) >> (9 - remaining___2);
#line 270
        __cil_tmp28___8 = pDst___2;
#line 270
        pDst___2 ++;
#line 270
        *__cil_tmp28___8 = (OPJ_BYTE )trailing___2;
#line 270
        trailing___2 = (OPJ_UINT32 )*(pSrc___2 + (i___97 + 2UL)) & ((1U << (9 - remaining___2)) - 1U);
#line 270
        if (9 >= remaining___2 + 8) {
#line 270
          __cil_tmp29___7 = pDst___2;
#line 270
          pDst___2 ++;
#line 270
          *__cil_tmp29___7 = (OPJ_BYTE )(trailing___2 >> (9 - (remaining___2 + 8)));
#line 270
          trailing___2 &= (1U << (9 - (remaining___2 + 8))) - 1U;
#line 270
          remaining___2 += 7;
        } else {
#line 270
          remaining___2 --;
        }
#line 271
        if (length___2 > 3UL) {
#line 272
          trailing___2 <<= remaining___2;
#line 272
          trailing___2 |= (OPJ_UINT32 )*(pSrc___2 + (i___97 + 3UL)) >> (9 - remaining___2);
#line 272
          __cil_tmp30___5 = pDst___2;
#line 272
          pDst___2 ++;
#line 272
          *__cil_tmp30___5 = (OPJ_BYTE )trailing___2;
#line 272
          trailing___2 = (OPJ_UINT32 )*(pSrc___2 + (i___97 + 3UL)) & ((1U << (9 - remaining___2)) - 1U);
#line 272
          if (9 >= remaining___2 + 8) {
#line 272
            __cil_tmp31___6 = pDst___2;
#line 272
            pDst___2 ++;
#line 272
            *__cil_tmp31___6 = (OPJ_BYTE )(trailing___2 >> (9 - (remaining___2 + 8)));
#line 272
            trailing___2 &= (1U << (9 - (remaining___2 + 8))) - 1U;
#line 272
            remaining___2 += 7;
          } else {
#line 272
            remaining___2 --;
          }
#line 273
          if (length___2 > 4UL) {
#line 274
            trailing___2 <<= remaining___2;
#line 274
            trailing___2 |= (OPJ_UINT32 )*(pSrc___2 + (i___97 + 4UL)) >> (9 - remaining___2);
#line 274
            __cil_tmp32___6 = pDst___2;
#line 274
            pDst___2 ++;
#line 274
            *__cil_tmp32___6 = (OPJ_BYTE )trailing___2;
#line 274
            trailing___2 = (OPJ_UINT32 )*(pSrc___2 + (i___97 + 4UL)) & ((1U << (9 - remaining___2)) - 1U);
#line 274
            if (9 >= remaining___2 + 8) {
#line 274
              __cil_tmp33___4 = pDst___2;
#line 274
              pDst___2 ++;
#line 274
              *__cil_tmp33___4 = (OPJ_BYTE )(trailing___2 >> (9 - (remaining___2 + 8)));
#line 274
              trailing___2 &= (1U << (9 - (remaining___2 + 8))) - 1U;
#line 274
              remaining___2 += 7;
            } else {
#line 274
              remaining___2 --;
            }
#line 275
            if (length___2 > 5UL) {
#line 276
              trailing___2 <<= remaining___2;
#line 276
              trailing___2 |= (OPJ_UINT32 )*(pSrc___2 + (i___97 + 5UL)) >> (9 - remaining___2);
#line 276
              __cil_tmp34___6 = pDst___2;
#line 276
              pDst___2 ++;
#line 276
              *__cil_tmp34___6 = (OPJ_BYTE )trailing___2;
#line 276
              trailing___2 = (OPJ_UINT32 )*(pSrc___2 + (i___97 + 5UL)) & ((1U << (9 - remaining___2)) - 1U);
#line 276
              if (9 >= remaining___2 + 8) {
#line 276
                __cil_tmp35___5 = pDst___2;
#line 276
                pDst___2 ++;
#line 276
                *__cil_tmp35___5 = (OPJ_BYTE )(trailing___2 >> (9 - (remaining___2 + 8)));
#line 276
                trailing___2 &= (1U << (9 - (remaining___2 + 8))) - 1U;
#line 276
                remaining___2 += 7;
              } else {
#line 276
                remaining___2 --;
              }
#line 277
              if (length___2 > 6UL) {
#line 278
                trailing___2 <<= remaining___2;
#line 278
                trailing___2 |= (OPJ_UINT32 )*(pSrc___2 + (i___97 + 6UL)) >> (9 - remaining___2);
#line 278
                __cil_tmp36___3 = pDst___2;
#line 278
                pDst___2 ++;
#line 278
                *__cil_tmp36___3 = (OPJ_BYTE )trailing___2;
#line 278
                trailing___2 = (OPJ_UINT32 )*(pSrc___2 + (i___97 + 6UL)) & ((1U << (9 - remaining___2)) - 1U);
#line 278
                if (9 >= remaining___2 + 8) {
#line 278
                  __cil_tmp37___1 = pDst___2;
#line 278
                  pDst___2 ++;
#line 278
                  *__cil_tmp37___1 = (OPJ_BYTE )(trailing___2 >> (9 - (remaining___2 + 8)));
#line 278
                  trailing___2 &= (1U << (9 - (remaining___2 + 8))) - 1U;
#line 278
                  remaining___2 += 7;
                } else {
#line 278
                  remaining___2 --;
                }
              }
            }
          }
        }
      }
    }
#line 285
    if (remaining___2 != 8) {
#line 285
      trailing___2 <<= remaining___2;
#line 285
      __cil_tmp38___0 = pDst___2;
#line 285
      pDst___2 ++;
#line 285
      *__cil_tmp38___0 = (OPJ_BYTE )trailing___2;
    }
  }
#line 288
  return;
}
}
#line 289 "/root/patron-new/39/src/bin/jp2/converttif.c"
static void tif_32sto10u(OPJ_INT32 *pSrc___3 , OPJ_BYTE *pDst___3 , OPJ_SIZE_T length___3 ) 
{ 
  OPJ_SIZE_T i___98 ;
  OPJ_UINT32 src0___3 ;
  OPJ_UINT32 src1___3 ;
  OPJ_UINT32 src2___3 ;
  OPJ_UINT32 src3___3 ;
  OPJ_BYTE *__cil_tmp9___33 ;
  OPJ_BYTE *__cil_tmp10___24 ;
  OPJ_BYTE *__cil_tmp11___22 ;
  OPJ_BYTE *__cil_tmp12___30 ;
  OPJ_BYTE *__cil_tmp13___40 ;
  OPJ_UINT32 src0___4 ;
  OPJ_UINT32 src1___4 ;
  OPJ_UINT32 src2___4 ;
  OPJ_BYTE *__cil_tmp17___26 ;
  OPJ_BYTE *__cil_tmp18___19 ;
  OPJ_BYTE *__cil_tmp19___24 ;
  OPJ_BYTE *__cil_tmp20___23 ;

  {
#line 293
  i___98 = (OPJ_SIZE_T )0;
  {
#line 293
  while (1) {
    while_continue: /* CIL Label */ ;

#line 293
    if (! (i___98 < (length___3 & 0xfffffffffffffffcUL))) {
#line 293
      goto while_break;
    }
#line 294
    src0___3 = (OPJ_UINT32 )*(pSrc___3 + i___98);
#line 295
    src1___3 = (OPJ_UINT32 )*(pSrc___3 + (i___98 + 1UL));
#line 296
    src2___3 = (OPJ_UINT32 )*(pSrc___3 + (i___98 + 2UL));
#line 297
    src3___3 = (OPJ_UINT32 )*(pSrc___3 + (i___98 + 3UL));
#line 299
    __cil_tmp9___33 = pDst___3;
#line 299
    pDst___3 ++;
#line 299
    *__cil_tmp9___33 = (OPJ_BYTE )(src0___3 >> 2);
#line 300
    __cil_tmp10___24 = pDst___3;
#line 300
    pDst___3 ++;
#line 300
    *__cil_tmp10___24 = (OPJ_BYTE )(((src0___3 & 3U) << 6) | (src1___3 >> 4));
#line 301
    __cil_tmp11___22 = pDst___3;
#line 301
    pDst___3 ++;
#line 301
    *__cil_tmp11___22 = (OPJ_BYTE )(((src1___3 & 15U) << 4) | (src2___3 >> 6));
#line 302
    __cil_tmp12___30 = pDst___3;
#line 302
    pDst___3 ++;
#line 302
    *__cil_tmp12___30 = (OPJ_BYTE )(((src2___3 & 63U) << 2) | (src3___3 >> 8));
#line 303
    __cil_tmp13___40 = pDst___3;
#line 303
    pDst___3 ++;
#line 303
    *__cil_tmp13___40 = (OPJ_BYTE )src3___3;
#line 293
    i___98 += 4UL;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 306
  if (length___3 & 3UL) {
#line 307
    src0___4 = (OPJ_UINT32 )*(pSrc___3 + i___98);
#line 308
    src1___4 = 0U;
#line 309
    src2___4 = 0U;
#line 310
    length___3 &= 3UL;
#line 312
    if (length___3 > 1UL) {
#line 313
      src1___4 = (OPJ_UINT32 )*(pSrc___3 + (i___98 + 1UL));
#line 314
      if (length___3 > 2UL) {
#line 315
        src2___4 = (OPJ_UINT32 )*(pSrc___3 + (i___98 + 2UL));
      }
    }
#line 318
    __cil_tmp17___26 = pDst___3;
#line 318
    pDst___3 ++;
#line 318
    *__cil_tmp17___26 = (OPJ_BYTE )(src0___4 >> 2);
#line 319
    __cil_tmp18___19 = pDst___3;
#line 319
    pDst___3 ++;
#line 319
    *__cil_tmp18___19 = (OPJ_BYTE )(((src0___4 & 3U) << 6) | (src1___4 >> 4));
#line 320
    if (length___3 > 1UL) {
#line 321
      __cil_tmp19___24 = pDst___3;
#line 321
      pDst___3 ++;
#line 321
      *__cil_tmp19___24 = (OPJ_BYTE )(((src1___4 & 15U) << 4) | (src2___4 >> 6));
#line 322
      if (length___3 > 2UL) {
#line 323
        __cil_tmp20___23 = pDst___3;
#line 323
        pDst___3 ++;
#line 323
        *__cil_tmp20___23 = (OPJ_BYTE )((src2___4 & 63U) << 2);
      }
    }
  }
#line 327
  return;
}
}
#line 328 "/root/patron-new/39/src/bin/jp2/converttif.c"
static void tif_32sto11u(OPJ_INT32 *pSrc___4 , OPJ_BYTE *pDst___4 , OPJ_SIZE_T length___4 ) 
{ 
  OPJ_SIZE_T i___99 ;
  OPJ_UINT32 src0___5 ;
  OPJ_UINT32 src1___5 ;
  OPJ_UINT32 src2___5 ;
  OPJ_UINT32 src3___4 ;
  OPJ_UINT32 src4___3 ;
  OPJ_UINT32 src5___3 ;
  OPJ_UINT32 src6___3 ;
  OPJ_UINT32 src7___3 ;
  OPJ_BYTE *__cil_tmp13___41 ;
  OPJ_BYTE *__cil_tmp14___42 ;
  OPJ_BYTE *__cil_tmp15___33 ;
  OPJ_BYTE *__cil_tmp16___27 ;
  OPJ_BYTE *__cil_tmp17___27 ;
  OPJ_BYTE *__cil_tmp18___20 ;
  OPJ_BYTE *__cil_tmp19___25 ;
  OPJ_BYTE *__cil_tmp20___24 ;
  OPJ_BYTE *__cil_tmp21___18 ;
  OPJ_BYTE *__cil_tmp22___20 ;
  OPJ_BYTE *__cil_tmp23___17 ;
  unsigned int trailing___3 ;
  int remaining___3 ;
  OPJ_BYTE *__cil_tmp26___13 ;
  OPJ_BYTE *__cil_tmp27___9 ;
  OPJ_BYTE *__cil_tmp28___9 ;
  OPJ_BYTE *__cil_tmp29___8 ;
  OPJ_BYTE *__cil_tmp30___6 ;
  OPJ_BYTE *__cil_tmp31___7 ;
  OPJ_BYTE *__cil_tmp32___7 ;
  OPJ_BYTE *__cil_tmp33___5 ;
  OPJ_BYTE *__cil_tmp34___7 ;
  OPJ_BYTE *__cil_tmp35___6 ;
  OPJ_BYTE *__cil_tmp36___4 ;
  OPJ_BYTE *__cil_tmp37___2 ;
  OPJ_BYTE *__cil_tmp38___1 ;
  OPJ_BYTE *__cil_tmp39___0 ;
  OPJ_BYTE *__cil_tmp40___1 ;

  {
#line 333
  i___99 = (OPJ_SIZE_T )0;
  {
#line 333
  while (1) {
    while_continue: /* CIL Label */ ;

#line 333
    if (! (i___99 < (length___4 & 0xfffffffffffffff8UL))) {
#line 333
      goto while_break;
    }
#line 334
    src0___5 = (OPJ_UINT32 )*(pSrc___4 + i___99);
#line 335
    src1___5 = (OPJ_UINT32 )*(pSrc___4 + (i___99 + 1UL));
#line 336
    src2___5 = (OPJ_UINT32 )*(pSrc___4 + (i___99 + 2UL));
#line 337
    src3___4 = (OPJ_UINT32 )*(pSrc___4 + (i___99 + 3UL));
#line 338
    src4___3 = (OPJ_UINT32 )*(pSrc___4 + (i___99 + 4UL));
#line 339
    src5___3 = (OPJ_UINT32 )*(pSrc___4 + (i___99 + 5UL));
#line 340
    src6___3 = (OPJ_UINT32 )*(pSrc___4 + (i___99 + 6UL));
#line 341
    src7___3 = (OPJ_UINT32 )*(pSrc___4 + (i___99 + 7UL));
#line 343
    __cil_tmp13___41 = pDst___4;
#line 343
    pDst___4 ++;
#line 343
    *__cil_tmp13___41 = (OPJ_BYTE )(src0___5 >> 3);
#line 344
    __cil_tmp14___42 = pDst___4;
#line 344
    pDst___4 ++;
#line 344
    *__cil_tmp14___42 = (OPJ_BYTE )((src0___5 << 5) | (src1___5 >> 6));
#line 345
    __cil_tmp15___33 = pDst___4;
#line 345
    pDst___4 ++;
#line 345
    *__cil_tmp15___33 = (OPJ_BYTE )((src1___5 << 2) | (src2___5 >> 9));
#line 346
    __cil_tmp16___27 = pDst___4;
#line 346
    pDst___4 ++;
#line 346
    *__cil_tmp16___27 = (OPJ_BYTE )(src2___5 >> 1);
#line 347
    __cil_tmp17___27 = pDst___4;
#line 347
    pDst___4 ++;
#line 347
    *__cil_tmp17___27 = (OPJ_BYTE )((src2___5 << 7) | (src3___4 >> 4));
#line 348
    __cil_tmp18___20 = pDst___4;
#line 348
    pDst___4 ++;
#line 348
    *__cil_tmp18___20 = (OPJ_BYTE )((src3___4 << 4) | (src4___3 >> 7));
#line 349
    __cil_tmp19___25 = pDst___4;
#line 349
    pDst___4 ++;
#line 349
    *__cil_tmp19___25 = (OPJ_BYTE )((src4___3 << 1) | (src5___3 >> 10));
#line 350
    __cil_tmp20___24 = pDst___4;
#line 350
    pDst___4 ++;
#line 350
    *__cil_tmp20___24 = (OPJ_BYTE )(src5___3 >> 2);
#line 351
    __cil_tmp21___18 = pDst___4;
#line 351
    pDst___4 ++;
#line 351
    *__cil_tmp21___18 = (OPJ_BYTE )((src5___3 << 6) | (src6___3 >> 5));
#line 352
    __cil_tmp22___20 = pDst___4;
#line 352
    pDst___4 ++;
#line 352
    *__cil_tmp22___20 = (OPJ_BYTE )((src6___3 << 3) | (src7___3 >> 8));
#line 353
    __cil_tmp23___17 = pDst___4;
#line 353
    pDst___4 ++;
#line 353
    *__cil_tmp23___17 = (OPJ_BYTE )src7___3;
#line 333
    i___99 += 8UL;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 356
  if (length___4 & 7UL) {
#line 357
    trailing___3 = 0U;
#line 358
    remaining___3 = 8;
#line 359
    length___4 &= 7UL;
#line 360
    trailing___3 <<= remaining___3;
#line 360
    trailing___3 |= (OPJ_UINT32 )*(pSrc___4 + i___99) >> (11 - remaining___3);
#line 360
    __cil_tmp26___13 = pDst___4;
#line 360
    pDst___4 ++;
#line 360
    *__cil_tmp26___13 = (OPJ_BYTE )trailing___3;
#line 360
    trailing___3 = (OPJ_UINT32 )*(pSrc___4 + i___99) & ((1U << (11 - remaining___3)) - 1U);
#line 360
    if (11 >= remaining___3 + 8) {
#line 360
      __cil_tmp27___9 = pDst___4;
#line 360
      pDst___4 ++;
#line 360
      *__cil_tmp27___9 = (OPJ_BYTE )(trailing___3 >> (11 - (remaining___3 + 8)));
#line 360
      trailing___3 &= (1U << (11 - (remaining___3 + 8))) - 1U;
#line 360
      remaining___3 += 5;
    } else {
#line 360
      remaining___3 += -3;
    }
#line 361
    if (length___4 > 1UL) {
#line 362
      trailing___3 <<= remaining___3;
#line 362
      trailing___3 |= (OPJ_UINT32 )*(pSrc___4 + (i___99 + 1UL)) >> (11 - remaining___3);
#line 362
      __cil_tmp28___9 = pDst___4;
#line 362
      pDst___4 ++;
#line 362
      *__cil_tmp28___9 = (OPJ_BYTE )trailing___3;
#line 362
      trailing___3 = (OPJ_UINT32 )*(pSrc___4 + (i___99 + 1UL)) & ((1U << (11 - remaining___3)) - 1U);
#line 362
      if (11 >= remaining___3 + 8) {
#line 362
        __cil_tmp29___8 = pDst___4;
#line 362
        pDst___4 ++;
#line 362
        *__cil_tmp29___8 = (OPJ_BYTE )(trailing___3 >> (11 - (remaining___3 + 8)));
#line 362
        trailing___3 &= (1U << (11 - (remaining___3 + 8))) - 1U;
#line 362
        remaining___3 += 5;
      } else {
#line 362
        remaining___3 += -3;
      }
#line 363
      if (length___4 > 2UL) {
#line 364
        trailing___3 <<= remaining___3;
#line 364
        trailing___3 |= (OPJ_UINT32 )*(pSrc___4 + (i___99 + 2UL)) >> (11 - remaining___3);
#line 364
        __cil_tmp30___6 = pDst___4;
#line 364
        pDst___4 ++;
#line 364
        *__cil_tmp30___6 = (OPJ_BYTE )trailing___3;
#line 364
        trailing___3 = (OPJ_UINT32 )*(pSrc___4 + (i___99 + 2UL)) & ((1U << (11 - remaining___3)) - 1U);
#line 364
        if (11 >= remaining___3 + 8) {
#line 364
          __cil_tmp31___7 = pDst___4;
#line 364
          pDst___4 ++;
#line 364
          *__cil_tmp31___7 = (OPJ_BYTE )(trailing___3 >> (11 - (remaining___3 + 8)));
#line 364
          trailing___3 &= (1U << (11 - (remaining___3 + 8))) - 1U;
#line 364
          remaining___3 += 5;
        } else {
#line 364
          remaining___3 += -3;
        }
#line 365
        if (length___4 > 3UL) {
#line 366
          trailing___3 <<= remaining___3;
#line 366
          trailing___3 |= (OPJ_UINT32 )*(pSrc___4 + (i___99 + 3UL)) >> (11 - remaining___3);
#line 366
          __cil_tmp32___7 = pDst___4;
#line 366
          pDst___4 ++;
#line 366
          *__cil_tmp32___7 = (OPJ_BYTE )trailing___3;
#line 366
          trailing___3 = (OPJ_UINT32 )*(pSrc___4 + (i___99 + 3UL)) & ((1U << (11 - remaining___3)) - 1U);
#line 366
          if (11 >= remaining___3 + 8) {
#line 366
            __cil_tmp33___5 = pDst___4;
#line 366
            pDst___4 ++;
#line 366
            *__cil_tmp33___5 = (OPJ_BYTE )(trailing___3 >> (11 - (remaining___3 + 8)));
#line 366
            trailing___3 &= (1U << (11 - (remaining___3 + 8))) - 1U;
#line 366
            remaining___3 += 5;
          } else {
#line 366
            remaining___3 += -3;
          }
#line 367
          if (length___4 > 4UL) {
#line 368
            trailing___3 <<= remaining___3;
#line 368
            trailing___3 |= (OPJ_UINT32 )*(pSrc___4 + (i___99 + 4UL)) >> (11 - remaining___3);
#line 368
            __cil_tmp34___7 = pDst___4;
#line 368
            pDst___4 ++;
#line 368
            *__cil_tmp34___7 = (OPJ_BYTE )trailing___3;
#line 368
            trailing___3 = (OPJ_UINT32 )*(pSrc___4 + (i___99 + 4UL)) & ((1U << (11 - remaining___3)) - 1U);
#line 368
            if (11 >= remaining___3 + 8) {
#line 368
              __cil_tmp35___6 = pDst___4;
#line 368
              pDst___4 ++;
#line 368
              *__cil_tmp35___6 = (OPJ_BYTE )(trailing___3 >> (11 - (remaining___3 + 8)));
#line 368
              trailing___3 &= (1U << (11 - (remaining___3 + 8))) - 1U;
#line 368
              remaining___3 += 5;
            } else {
#line 368
              remaining___3 += -3;
            }
#line 369
            if (length___4 > 5UL) {
#line 370
              trailing___3 <<= remaining___3;
#line 370
              trailing___3 |= (OPJ_UINT32 )*(pSrc___4 + (i___99 + 5UL)) >> (11 - remaining___3);
#line 370
              __cil_tmp36___4 = pDst___4;
#line 370
              pDst___4 ++;
#line 370
              *__cil_tmp36___4 = (OPJ_BYTE )trailing___3;
#line 370
              trailing___3 = (OPJ_UINT32 )*(pSrc___4 + (i___99 + 5UL)) & ((1U << (11 - remaining___3)) - 1U);
#line 370
              if (11 >= remaining___3 + 8) {
#line 370
                __cil_tmp37___2 = pDst___4;
#line 370
                pDst___4 ++;
#line 370
                *__cil_tmp37___2 = (OPJ_BYTE )(trailing___3 >> (11 - (remaining___3 + 8)));
#line 370
                trailing___3 &= (1U << (11 - (remaining___3 + 8))) - 1U;
#line 370
                remaining___3 += 5;
              } else {
#line 370
                remaining___3 += -3;
              }
#line 371
              if (length___4 > 6UL) {
#line 372
                trailing___3 <<= remaining___3;
#line 372
                trailing___3 |= (OPJ_UINT32 )*(pSrc___4 + (i___99 + 6UL)) >> (11 - remaining___3);
#line 372
                __cil_tmp38___1 = pDst___4;
#line 372
                pDst___4 ++;
#line 372
                *__cil_tmp38___1 = (OPJ_BYTE )trailing___3;
#line 372
                trailing___3 = (OPJ_UINT32 )*(pSrc___4 + (i___99 + 6UL)) & ((1U << (11 - remaining___3)) - 1U);
#line 372
                if (11 >= remaining___3 + 8) {
#line 372
                  __cil_tmp39___0 = pDst___4;
#line 372
                  pDst___4 ++;
#line 372
                  *__cil_tmp39___0 = (OPJ_BYTE )(trailing___3 >> (11 - (remaining___3 + 8)));
#line 372
                  trailing___3 &= (1U << (11 - (remaining___3 + 8))) - 1U;
#line 372
                  remaining___3 += 5;
                } else {
#line 372
                  remaining___3 += -3;
                }
              }
            }
          }
        }
      }
    }
#line 379
    if (remaining___3 != 8) {
#line 379
      trailing___3 <<= remaining___3;
#line 379
      __cil_tmp40___1 = pDst___4;
#line 379
      pDst___4 ++;
#line 379
      *__cil_tmp40___1 = (OPJ_BYTE )trailing___3;
    }
  }
#line 382
  return;
}
}
#line 382 "/root/patron-new/39/src/bin/jp2/converttif.c"
static void tif_32sto12u(OPJ_INT32 *pSrc___5 , OPJ_BYTE *pDst___5 , OPJ_SIZE_T length___5 ) 
{ 
  OPJ_SIZE_T i___100 ;
  OPJ_UINT32 src0___6 ;
  OPJ_UINT32 src1___6 ;
  OPJ_BYTE *__cil_tmp7___47 ;
  OPJ_BYTE *__cil_tmp8___54 ;
  OPJ_BYTE *__cil_tmp9___34 ;
  OPJ_UINT32 src0___7 ;
  OPJ_BYTE *__cil_tmp11___23 ;
  OPJ_BYTE *__cil_tmp12___31 ;

  {
#line 386
  i___100 = (OPJ_SIZE_T )0;
  {
#line 386
  while (1) {
    while_continue: /* CIL Label */ ;

#line 386
    if (! (i___100 < (length___5 & 0xfffffffffffffffeUL))) {
#line 386
      goto while_break;
    }
#line 387
    src0___6 = (OPJ_UINT32 )*(pSrc___5 + i___100);
#line 388
    src1___6 = (OPJ_UINT32 )*(pSrc___5 + (i___100 + 1UL));
#line 390
    __cil_tmp7___47 = pDst___5;
#line 390
    pDst___5 ++;
#line 390
    *__cil_tmp7___47 = (OPJ_BYTE )(src0___6 >> 4);
#line 391
    __cil_tmp8___54 = pDst___5;
#line 391
    pDst___5 ++;
#line 391
    *__cil_tmp8___54 = (OPJ_BYTE )(((src0___6 & 15U) << 4) | (src1___6 >> 8));
#line 392
    __cil_tmp9___34 = pDst___5;
#line 392
    pDst___5 ++;
#line 392
    *__cil_tmp9___34 = (OPJ_BYTE )src1___6;
#line 386
    i___100 += 2UL;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 395
  if (length___5 & 1UL) {
#line 396
    src0___7 = (OPJ_UINT32 )*(pSrc___5 + i___100);
#line 397
    __cil_tmp11___23 = pDst___5;
#line 397
    pDst___5 ++;
#line 397
    *__cil_tmp11___23 = (OPJ_BYTE )(src0___7 >> 4);
#line 398
    __cil_tmp12___31 = pDst___5;
#line 398
    pDst___5 ++;
#line 398
    *__cil_tmp12___31 = (OPJ_BYTE )((src0___7 & 15U) << 4);
  }
#line 400
  return;
}
}
#line 401 "/root/patron-new/39/src/bin/jp2/converttif.c"
static void tif_32sto13u(OPJ_INT32 *pSrc___6 , OPJ_BYTE *pDst___6 , OPJ_SIZE_T length___6 ) 
{ 
  OPJ_SIZE_T i___101 ;
  OPJ_UINT32 src0___8 ;
  OPJ_UINT32 src1___7 ;
  OPJ_UINT32 src2___6 ;
  OPJ_UINT32 src3___5 ;
  OPJ_UINT32 src4___4 ;
  OPJ_UINT32 src5___4 ;
  OPJ_UINT32 src6___4 ;
  OPJ_UINT32 src7___4 ;
  OPJ_BYTE *__cil_tmp13___42 ;
  OPJ_BYTE *__cil_tmp14___43 ;
  OPJ_BYTE *__cil_tmp15___34 ;
  OPJ_BYTE *__cil_tmp16___28 ;
  OPJ_BYTE *__cil_tmp17___28 ;
  OPJ_BYTE *__cil_tmp18___21 ;
  OPJ_BYTE *__cil_tmp19___26 ;
  OPJ_BYTE *__cil_tmp20___25 ;
  OPJ_BYTE *__cil_tmp21___19 ;
  OPJ_BYTE *__cil_tmp22___21 ;
  OPJ_BYTE *__cil_tmp23___18 ;
  OPJ_BYTE *__cil_tmp24___15 ;
  OPJ_BYTE *__cil_tmp25___14 ;
  unsigned int trailing___4 ;
  int remaining___4 ;
  OPJ_BYTE *__cil_tmp28___10 ;
  OPJ_BYTE *__cil_tmp29___9 ;
  OPJ_BYTE *__cil_tmp30___7 ;
  OPJ_BYTE *__cil_tmp31___8 ;
  OPJ_BYTE *__cil_tmp32___8 ;
  OPJ_BYTE *__cil_tmp33___6 ;
  OPJ_BYTE *__cil_tmp34___8 ;
  OPJ_BYTE *__cil_tmp35___7 ;
  OPJ_BYTE *__cil_tmp36___5 ;
  OPJ_BYTE *__cil_tmp37___3 ;
  OPJ_BYTE *__cil_tmp38___2 ;
  OPJ_BYTE *__cil_tmp39___1 ;
  OPJ_BYTE *__cil_tmp40___2 ;
  OPJ_BYTE *__cil_tmp41___1 ;
  OPJ_BYTE *__cil_tmp42___0 ;

  {
#line 406
  i___101 = (OPJ_SIZE_T )0;
  {
#line 406
  while (1) {
    while_continue: /* CIL Label */ ;

#line 406
    if (! (i___101 < (length___6 & 0xfffffffffffffff8UL))) {
#line 406
      goto while_break;
    }
#line 407
    src0___8 = (OPJ_UINT32 )*(pSrc___6 + i___101);
#line 408
    src1___7 = (OPJ_UINT32 )*(pSrc___6 + (i___101 + 1UL));
#line 409
    src2___6 = (OPJ_UINT32 )*(pSrc___6 + (i___101 + 2UL));
#line 410
    src3___5 = (OPJ_UINT32 )*(pSrc___6 + (i___101 + 3UL));
#line 411
    src4___4 = (OPJ_UINT32 )*(pSrc___6 + (i___101 + 4UL));
#line 412
    src5___4 = (OPJ_UINT32 )*(pSrc___6 + (i___101 + 5UL));
#line 413
    src6___4 = (OPJ_UINT32 )*(pSrc___6 + (i___101 + 6UL));
#line 414
    src7___4 = (OPJ_UINT32 )*(pSrc___6 + (i___101 + 7UL));
#line 416
    __cil_tmp13___42 = pDst___6;
#line 416
    pDst___6 ++;
#line 416
    *__cil_tmp13___42 = (OPJ_BYTE )(src0___8 >> 5);
#line 417
    __cil_tmp14___43 = pDst___6;
#line 417
    pDst___6 ++;
#line 417
    *__cil_tmp14___43 = (OPJ_BYTE )((src0___8 << 3) | (src1___7 >> 10));
#line 418
    __cil_tmp15___34 = pDst___6;
#line 418
    pDst___6 ++;
#line 418
    *__cil_tmp15___34 = (OPJ_BYTE )(src1___7 >> 2);
#line 419
    __cil_tmp16___28 = pDst___6;
#line 419
    pDst___6 ++;
#line 419
    *__cil_tmp16___28 = (OPJ_BYTE )((src1___7 << 6) | (src2___6 >> 7));
#line 420
    __cil_tmp17___28 = pDst___6;
#line 420
    pDst___6 ++;
#line 420
    *__cil_tmp17___28 = (OPJ_BYTE )((src2___6 << 1) | (src3___5 >> 12));
#line 421
    __cil_tmp18___21 = pDst___6;
#line 421
    pDst___6 ++;
#line 421
    *__cil_tmp18___21 = (OPJ_BYTE )(src3___5 >> 4);
#line 422
    __cil_tmp19___26 = pDst___6;
#line 422
    pDst___6 ++;
#line 422
    *__cil_tmp19___26 = (OPJ_BYTE )((src3___5 << 4) | (src4___4 >> 9));
#line 423
    __cil_tmp20___25 = pDst___6;
#line 423
    pDst___6 ++;
#line 423
    *__cil_tmp20___25 = (OPJ_BYTE )(src4___4 >> 1);
#line 424
    __cil_tmp21___19 = pDst___6;
#line 424
    pDst___6 ++;
#line 424
    *__cil_tmp21___19 = (OPJ_BYTE )((src4___4 << 7) | (src5___4 >> 6));
#line 425
    __cil_tmp22___21 = pDst___6;
#line 425
    pDst___6 ++;
#line 425
    *__cil_tmp22___21 = (OPJ_BYTE )((src5___4 << 2) | (src6___4 >> 11));
#line 426
    __cil_tmp23___18 = pDst___6;
#line 426
    pDst___6 ++;
#line 426
    *__cil_tmp23___18 = (OPJ_BYTE )(src6___4 >> 3);
#line 427
    __cil_tmp24___15 = pDst___6;
#line 427
    pDst___6 ++;
#line 427
    *__cil_tmp24___15 = (OPJ_BYTE )((src6___4 << 5) | (src7___4 >> 8));
#line 428
    __cil_tmp25___14 = pDst___6;
#line 428
    pDst___6 ++;
#line 428
    *__cil_tmp25___14 = (OPJ_BYTE )src7___4;
#line 406
    i___101 += 8UL;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 431
  if (length___6 & 7UL) {
#line 432
    trailing___4 = 0U;
#line 433
    remaining___4 = 8;
#line 434
    length___6 &= 7UL;
#line 435
    trailing___4 <<= remaining___4;
#line 435
    trailing___4 |= (OPJ_UINT32 )*(pSrc___6 + i___101) >> (13 - remaining___4);
#line 435
    __cil_tmp28___10 = pDst___6;
#line 435
    pDst___6 ++;
#line 435
    *__cil_tmp28___10 = (OPJ_BYTE )trailing___4;
#line 435
    trailing___4 = (OPJ_UINT32 )*(pSrc___6 + i___101) & ((1U << (13 - remaining___4)) - 1U);
#line 435
    if (13 >= remaining___4 + 8) {
#line 435
      __cil_tmp29___9 = pDst___6;
#line 435
      pDst___6 ++;
#line 435
      *__cil_tmp29___9 = (OPJ_BYTE )(trailing___4 >> (13 - (remaining___4 + 8)));
#line 435
      trailing___4 &= (1U << (13 - (remaining___4 + 8))) - 1U;
#line 435
      remaining___4 += 3;
    } else {
#line 435
      remaining___4 += -5;
    }
#line 436
    if (length___6 > 1UL) {
#line 437
      trailing___4 <<= remaining___4;
#line 437
      trailing___4 |= (OPJ_UINT32 )*(pSrc___6 + (i___101 + 1UL)) >> (13 - remaining___4);
#line 437
      __cil_tmp30___7 = pDst___6;
#line 437
      pDst___6 ++;
#line 437
      *__cil_tmp30___7 = (OPJ_BYTE )trailing___4;
#line 437
      trailing___4 = (OPJ_UINT32 )*(pSrc___6 + (i___101 + 1UL)) & ((1U << (13 - remaining___4)) - 1U);
#line 437
      if (13 >= remaining___4 + 8) {
#line 437
        __cil_tmp31___8 = pDst___6;
#line 437
        pDst___6 ++;
#line 437
        *__cil_tmp31___8 = (OPJ_BYTE )(trailing___4 >> (13 - (remaining___4 + 8)));
#line 437
        trailing___4 &= (1U << (13 - (remaining___4 + 8))) - 1U;
#line 437
        remaining___4 += 3;
      } else {
#line 437
        remaining___4 += -5;
      }
#line 438
      if (length___6 > 2UL) {
#line 439
        trailing___4 <<= remaining___4;
#line 439
        trailing___4 |= (OPJ_UINT32 )*(pSrc___6 + (i___101 + 2UL)) >> (13 - remaining___4);
#line 439
        __cil_tmp32___8 = pDst___6;
#line 439
        pDst___6 ++;
#line 439
        *__cil_tmp32___8 = (OPJ_BYTE )trailing___4;
#line 439
        trailing___4 = (OPJ_UINT32 )*(pSrc___6 + (i___101 + 2UL)) & ((1U << (13 - remaining___4)) - 1U);
#line 439
        if (13 >= remaining___4 + 8) {
#line 439
          __cil_tmp33___6 = pDst___6;
#line 439
          pDst___6 ++;
#line 439
          *__cil_tmp33___6 = (OPJ_BYTE )(trailing___4 >> (13 - (remaining___4 + 8)));
#line 439
          trailing___4 &= (1U << (13 - (remaining___4 + 8))) - 1U;
#line 439
          remaining___4 += 3;
        } else {
#line 439
          remaining___4 += -5;
        }
#line 440
        if (length___6 > 3UL) {
#line 441
          trailing___4 <<= remaining___4;
#line 441
          trailing___4 |= (OPJ_UINT32 )*(pSrc___6 + (i___101 + 3UL)) >> (13 - remaining___4);
#line 441
          __cil_tmp34___8 = pDst___6;
#line 441
          pDst___6 ++;
#line 441
          *__cil_tmp34___8 = (OPJ_BYTE )trailing___4;
#line 441
          trailing___4 = (OPJ_UINT32 )*(pSrc___6 + (i___101 + 3UL)) & ((1U << (13 - remaining___4)) - 1U);
#line 441
          if (13 >= remaining___4 + 8) {
#line 441
            __cil_tmp35___7 = pDst___6;
#line 441
            pDst___6 ++;
#line 441
            *__cil_tmp35___7 = (OPJ_BYTE )(trailing___4 >> (13 - (remaining___4 + 8)));
#line 441
            trailing___4 &= (1U << (13 - (remaining___4 + 8))) - 1U;
#line 441
            remaining___4 += 3;
          } else {
#line 441
            remaining___4 += -5;
          }
#line 442
          if (length___6 > 4UL) {
#line 443
            trailing___4 <<= remaining___4;
#line 443
            trailing___4 |= (OPJ_UINT32 )*(pSrc___6 + (i___101 + 4UL)) >> (13 - remaining___4);
#line 443
            __cil_tmp36___5 = pDst___6;
#line 443
            pDst___6 ++;
#line 443
            *__cil_tmp36___5 = (OPJ_BYTE )trailing___4;
#line 443
            trailing___4 = (OPJ_UINT32 )*(pSrc___6 + (i___101 + 4UL)) & ((1U << (13 - remaining___4)) - 1U);
#line 443
            if (13 >= remaining___4 + 8) {
#line 443
              __cil_tmp37___3 = pDst___6;
#line 443
              pDst___6 ++;
#line 443
              *__cil_tmp37___3 = (OPJ_BYTE )(trailing___4 >> (13 - (remaining___4 + 8)));
#line 443
              trailing___4 &= (1U << (13 - (remaining___4 + 8))) - 1U;
#line 443
              remaining___4 += 3;
            } else {
#line 443
              remaining___4 += -5;
            }
#line 444
            if (length___6 > 5UL) {
#line 445
              trailing___4 <<= remaining___4;
#line 445
              trailing___4 |= (OPJ_UINT32 )*(pSrc___6 + (i___101 + 5UL)) >> (13 - remaining___4);
#line 445
              __cil_tmp38___2 = pDst___6;
#line 445
              pDst___6 ++;
#line 445
              *__cil_tmp38___2 = (OPJ_BYTE )trailing___4;
#line 445
              trailing___4 = (OPJ_UINT32 )*(pSrc___6 + (i___101 + 5UL)) & ((1U << (13 - remaining___4)) - 1U);
#line 445
              if (13 >= remaining___4 + 8) {
#line 445
                __cil_tmp39___1 = pDst___6;
#line 445
                pDst___6 ++;
#line 445
                *__cil_tmp39___1 = (OPJ_BYTE )(trailing___4 >> (13 - (remaining___4 + 8)));
#line 445
                trailing___4 &= (1U << (13 - (remaining___4 + 8))) - 1U;
#line 445
                remaining___4 += 3;
              } else {
#line 445
                remaining___4 += -5;
              }
#line 446
              if (length___6 > 6UL) {
#line 447
                trailing___4 <<= remaining___4;
#line 447
                trailing___4 |= (OPJ_UINT32 )*(pSrc___6 + (i___101 + 6UL)) >> (13 - remaining___4);
#line 447
                __cil_tmp40___2 = pDst___6;
#line 447
                pDst___6 ++;
#line 447
                *__cil_tmp40___2 = (OPJ_BYTE )trailing___4;
#line 447
                trailing___4 = (OPJ_UINT32 )*(pSrc___6 + (i___101 + 6UL)) & ((1U << (13 - remaining___4)) - 1U);
#line 447
                if (13 >= remaining___4 + 8) {
#line 447
                  __cil_tmp41___1 = pDst___6;
#line 447
                  pDst___6 ++;
#line 447
                  *__cil_tmp41___1 = (OPJ_BYTE )(trailing___4 >> (13 - (remaining___4 + 8)));
#line 447
                  trailing___4 &= (1U << (13 - (remaining___4 + 8))) - 1U;
#line 447
                  remaining___4 += 3;
                } else {
#line 447
                  remaining___4 += -5;
                }
              }
            }
          }
        }
      }
    }
#line 454
    if (remaining___4 != 8) {
#line 454
      trailing___4 <<= remaining___4;
#line 454
      __cil_tmp42___0 = pDst___6;
#line 454
      pDst___6 ++;
#line 454
      *__cil_tmp42___0 = (OPJ_BYTE )trailing___4;
    }
  }
#line 457
  return;
}
}
#line 457 "/root/patron-new/39/src/bin/jp2/converttif.c"
static void tif_32sto14u(OPJ_INT32 *pSrc___7 , OPJ_BYTE *pDst___7 , OPJ_SIZE_T length___7 ) 
{ 
  OPJ_SIZE_T i___102 ;
  OPJ_UINT32 src0___9 ;
  OPJ_UINT32 src1___8 ;
  OPJ_UINT32 src2___7 ;
  OPJ_UINT32 src3___6 ;
  OPJ_BYTE *__cil_tmp9___35 ;
  OPJ_BYTE *__cil_tmp10___25 ;
  OPJ_BYTE *__cil_tmp11___24 ;
  OPJ_BYTE *__cil_tmp12___32 ;
  OPJ_BYTE *__cil_tmp13___43 ;
  OPJ_BYTE *__cil_tmp14___44 ;
  OPJ_BYTE *__cil_tmp15___35 ;
  OPJ_UINT32 src0___10 ;
  OPJ_UINT32 src1___9 ;
  OPJ_UINT32 src2___8 ;
  OPJ_BYTE *__cil_tmp19___27 ;
  OPJ_BYTE *__cil_tmp20___26 ;
  OPJ_BYTE *__cil_tmp21___20 ;
  OPJ_BYTE *__cil_tmp22___22 ;
  OPJ_BYTE *__cil_tmp23___19 ;
  OPJ_BYTE *__cil_tmp24___16 ;

  {
#line 461
  i___102 = (OPJ_SIZE_T )0;
  {
#line 461
  while (1) {
    while_continue: /* CIL Label */ ;

#line 461
    if (! (i___102 < (length___7 & 0xfffffffffffffffcUL))) {
#line 461
      goto while_break;
    }
#line 462
    src0___9 = (OPJ_UINT32 )*(pSrc___7 + i___102);
#line 463
    src1___8 = (OPJ_UINT32 )*(pSrc___7 + (i___102 + 1UL));
#line 464
    src2___7 = (OPJ_UINT32 )*(pSrc___7 + (i___102 + 2UL));
#line 465
    src3___6 = (OPJ_UINT32 )*(pSrc___7 + (i___102 + 3UL));
#line 467
    __cil_tmp9___35 = pDst___7;
#line 467
    pDst___7 ++;
#line 467
    *__cil_tmp9___35 = (OPJ_BYTE )(src0___9 >> 6);
#line 468
    __cil_tmp10___25 = pDst___7;
#line 468
    pDst___7 ++;
#line 468
    *__cil_tmp10___25 = (OPJ_BYTE )(((src0___9 & 63U) << 2) | (src1___8 >> 12));
#line 469
    __cil_tmp11___24 = pDst___7;
#line 469
    pDst___7 ++;
#line 469
    *__cil_tmp11___24 = (OPJ_BYTE )(src1___8 >> 4);
#line 470
    __cil_tmp12___32 = pDst___7;
#line 470
    pDst___7 ++;
#line 470
    *__cil_tmp12___32 = (OPJ_BYTE )(((src1___8 & 15U) << 4) | (src2___7 >> 10));
#line 471
    __cil_tmp13___43 = pDst___7;
#line 471
    pDst___7 ++;
#line 471
    *__cil_tmp13___43 = (OPJ_BYTE )(src2___7 >> 2);
#line 472
    __cil_tmp14___44 = pDst___7;
#line 472
    pDst___7 ++;
#line 472
    *__cil_tmp14___44 = (OPJ_BYTE )(((src2___7 & 3U) << 6) | (src3___6 >> 8));
#line 473
    __cil_tmp15___35 = pDst___7;
#line 473
    pDst___7 ++;
#line 473
    *__cil_tmp15___35 = (OPJ_BYTE )src3___6;
#line 461
    i___102 += 4UL;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 476
  if (length___7 & 3UL) {
#line 477
    src0___10 = (OPJ_UINT32 )*(pSrc___7 + i___102);
#line 478
    src1___9 = 0U;
#line 479
    src2___8 = 0U;
#line 480
    length___7 &= 3UL;
#line 482
    if (length___7 > 1UL) {
#line 483
      src1___9 = (OPJ_UINT32 )*(pSrc___7 + (i___102 + 1UL));
#line 484
      if (length___7 > 2UL) {
#line 485
        src2___8 = (OPJ_UINT32 )*(pSrc___7 + (i___102 + 2UL));
      }
    }
#line 488
    __cil_tmp19___27 = pDst___7;
#line 488
    pDst___7 ++;
#line 488
    *__cil_tmp19___27 = (OPJ_BYTE )(src0___10 >> 6);
#line 489
    __cil_tmp20___26 = pDst___7;
#line 489
    pDst___7 ++;
#line 489
    *__cil_tmp20___26 = (OPJ_BYTE )(((src0___10 & 63U) << 2) | (src1___9 >> 12));
#line 490
    if (length___7 > 1UL) {
#line 491
      __cil_tmp21___20 = pDst___7;
#line 491
      pDst___7 ++;
#line 491
      *__cil_tmp21___20 = (OPJ_BYTE )(src1___9 >> 4);
#line 492
      __cil_tmp22___22 = pDst___7;
#line 492
      pDst___7 ++;
#line 492
      *__cil_tmp22___22 = (OPJ_BYTE )(((src1___9 & 15U) << 4) | (src2___8 >> 10));
#line 493
      if (length___7 > 2UL) {
#line 494
        __cil_tmp23___19 = pDst___7;
#line 494
        pDst___7 ++;
#line 494
        *__cil_tmp23___19 = (OPJ_BYTE )(src2___8 >> 2);
#line 495
        __cil_tmp24___16 = pDst___7;
#line 495
        pDst___7 ++;
#line 495
        *__cil_tmp24___16 = (OPJ_BYTE )((src2___8 & 3U) << 6);
      }
    }
  }
#line 499
  return;
}
}
#line 500 "/root/patron-new/39/src/bin/jp2/converttif.c"
static void tif_32sto15u(OPJ_INT32 *pSrc___8 , OPJ_BYTE *pDst___8 , OPJ_SIZE_T length___8 ) 
{ 
  OPJ_SIZE_T i___103 ;
  OPJ_UINT32 src0___11 ;
  OPJ_UINT32 src1___10 ;
  OPJ_UINT32 src2___9 ;
  OPJ_UINT32 src3___7 ;
  OPJ_UINT32 src4___5 ;
  OPJ_UINT32 src5___5 ;
  OPJ_UINT32 src6___5 ;
  OPJ_UINT32 src7___5 ;
  OPJ_BYTE *__cil_tmp13___44 ;
  OPJ_BYTE *__cil_tmp14___45 ;
  OPJ_BYTE *__cil_tmp15___36 ;
  OPJ_BYTE *__cil_tmp16___29 ;
  OPJ_BYTE *__cil_tmp17___29 ;
  OPJ_BYTE *__cil_tmp18___22 ;
  OPJ_BYTE *__cil_tmp19___28 ;
  OPJ_BYTE *__cil_tmp20___27 ;
  OPJ_BYTE *__cil_tmp21___21 ;
  OPJ_BYTE *__cil_tmp22___23 ;
  OPJ_BYTE *__cil_tmp23___20 ;
  OPJ_BYTE *__cil_tmp24___17 ;
  OPJ_BYTE *__cil_tmp25___15 ;
  OPJ_BYTE *__cil_tmp26___14 ;
  OPJ_BYTE *__cil_tmp27___10 ;
  unsigned int trailing___5 ;
  int remaining___5 ;
  OPJ_BYTE *__cil_tmp30___8 ;
  OPJ_BYTE *__cil_tmp31___9 ;
  OPJ_BYTE *__cil_tmp32___9 ;
  OPJ_BYTE *__cil_tmp33___7 ;
  OPJ_BYTE *__cil_tmp34___9 ;
  OPJ_BYTE *__cil_tmp35___8 ;
  OPJ_BYTE *__cil_tmp36___6 ;
  OPJ_BYTE *__cil_tmp37___4 ;
  OPJ_BYTE *__cil_tmp38___3 ;
  OPJ_BYTE *__cil_tmp39___2 ;
  OPJ_BYTE *__cil_tmp40___3 ;
  OPJ_BYTE *__cil_tmp41___2 ;
  OPJ_BYTE *__cil_tmp42___1 ;
  OPJ_BYTE *__cil_tmp43___1 ;
  OPJ_BYTE *__cil_tmp44___1 ;

  {
#line 505
  i___103 = (OPJ_SIZE_T )0;
  {
#line 505
  while (1) {
    while_continue: /* CIL Label */ ;

#line 505
    if (! (i___103 < (length___8 & 0xfffffffffffffff8UL))) {
#line 505
      goto while_break;
    }
#line 506
    src0___11 = (OPJ_UINT32 )*(pSrc___8 + i___103);
#line 507
    src1___10 = (OPJ_UINT32 )*(pSrc___8 + (i___103 + 1UL));
#line 508
    src2___9 = (OPJ_UINT32 )*(pSrc___8 + (i___103 + 2UL));
#line 509
    src3___7 = (OPJ_UINT32 )*(pSrc___8 + (i___103 + 3UL));
#line 510
    src4___5 = (OPJ_UINT32 )*(pSrc___8 + (i___103 + 4UL));
#line 511
    src5___5 = (OPJ_UINT32 )*(pSrc___8 + (i___103 + 5UL));
#line 512
    src6___5 = (OPJ_UINT32 )*(pSrc___8 + (i___103 + 6UL));
#line 513
    src7___5 = (OPJ_UINT32 )*(pSrc___8 + (i___103 + 7UL));
#line 515
    __cil_tmp13___44 = pDst___8;
#line 515
    pDst___8 ++;
#line 515
    *__cil_tmp13___44 = (OPJ_BYTE )(src0___11 >> 7);
#line 516
    __cil_tmp14___45 = pDst___8;
#line 516
    pDst___8 ++;
#line 516
    *__cil_tmp14___45 = (OPJ_BYTE )((src0___11 << 1) | (src1___10 >> 14));
#line 517
    __cil_tmp15___36 = pDst___8;
#line 517
    pDst___8 ++;
#line 517
    *__cil_tmp15___36 = (OPJ_BYTE )(src1___10 >> 6);
#line 518
    __cil_tmp16___29 = pDst___8;
#line 518
    pDst___8 ++;
#line 518
    *__cil_tmp16___29 = (OPJ_BYTE )((src1___10 << 2) | (src2___9 >> 13));
#line 519
    __cil_tmp17___29 = pDst___8;
#line 519
    pDst___8 ++;
#line 519
    *__cil_tmp17___29 = (OPJ_BYTE )(src2___9 >> 5);
#line 520
    __cil_tmp18___22 = pDst___8;
#line 520
    pDst___8 ++;
#line 520
    *__cil_tmp18___22 = (OPJ_BYTE )((src2___9 << 3) | (src3___7 >> 12));
#line 521
    __cil_tmp19___28 = pDst___8;
#line 521
    pDst___8 ++;
#line 521
    *__cil_tmp19___28 = (OPJ_BYTE )(src3___7 >> 4);
#line 522
    __cil_tmp20___27 = pDst___8;
#line 522
    pDst___8 ++;
#line 522
    *__cil_tmp20___27 = (OPJ_BYTE )((src3___7 << 4) | (src4___5 >> 11));
#line 523
    __cil_tmp21___21 = pDst___8;
#line 523
    pDst___8 ++;
#line 523
    *__cil_tmp21___21 = (OPJ_BYTE )(src4___5 >> 3);
#line 524
    __cil_tmp22___23 = pDst___8;
#line 524
    pDst___8 ++;
#line 524
    *__cil_tmp22___23 = (OPJ_BYTE )((src4___5 << 5) | (src5___5 >> 10));
#line 525
    __cil_tmp23___20 = pDst___8;
#line 525
    pDst___8 ++;
#line 525
    *__cil_tmp23___20 = (OPJ_BYTE )(src5___5 >> 2);
#line 526
    __cil_tmp24___17 = pDst___8;
#line 526
    pDst___8 ++;
#line 526
    *__cil_tmp24___17 = (OPJ_BYTE )((src5___5 << 6) | (src6___5 >> 9));
#line 527
    __cil_tmp25___15 = pDst___8;
#line 527
    pDst___8 ++;
#line 527
    *__cil_tmp25___15 = (OPJ_BYTE )(src6___5 >> 1);
#line 528
    __cil_tmp26___14 = pDst___8;
#line 528
    pDst___8 ++;
#line 528
    *__cil_tmp26___14 = (OPJ_BYTE )((src6___5 << 7) | (src7___5 >> 8));
#line 529
    __cil_tmp27___10 = pDst___8;
#line 529
    pDst___8 ++;
#line 529
    *__cil_tmp27___10 = (OPJ_BYTE )src7___5;
#line 505
    i___103 += 8UL;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 532
  if (length___8 & 7UL) {
#line 533
    trailing___5 = 0U;
#line 534
    remaining___5 = 8;
#line 535
    length___8 &= 7UL;
#line 536
    trailing___5 <<= remaining___5;
#line 536
    trailing___5 |= (OPJ_UINT32 )*(pSrc___8 + i___103) >> (15 - remaining___5);
#line 536
    __cil_tmp30___8 = pDst___8;
#line 536
    pDst___8 ++;
#line 536
    *__cil_tmp30___8 = (OPJ_BYTE )trailing___5;
#line 536
    trailing___5 = (OPJ_UINT32 )*(pSrc___8 + i___103) & ((1U << (15 - remaining___5)) - 1U);
#line 536
    if (15 >= remaining___5 + 8) {
#line 536
      __cil_tmp31___9 = pDst___8;
#line 536
      pDst___8 ++;
#line 536
      *__cil_tmp31___9 = (OPJ_BYTE )(trailing___5 >> (15 - (remaining___5 + 8)));
#line 536
      trailing___5 &= (1U << (15 - (remaining___5 + 8))) - 1U;
#line 536
      remaining___5 ++;
    } else {
#line 536
      remaining___5 += -7;
    }
#line 537
    if (length___8 > 1UL) {
#line 538
      trailing___5 <<= remaining___5;
#line 538
      trailing___5 |= (OPJ_UINT32 )*(pSrc___8 + (i___103 + 1UL)) >> (15 - remaining___5);
#line 538
      __cil_tmp32___9 = pDst___8;
#line 538
      pDst___8 ++;
#line 538
      *__cil_tmp32___9 = (OPJ_BYTE )trailing___5;
#line 538
      trailing___5 = (OPJ_UINT32 )*(pSrc___8 + (i___103 + 1UL)) & ((1U << (15 - remaining___5)) - 1U);
#line 538
      if (15 >= remaining___5 + 8) {
#line 538
        __cil_tmp33___7 = pDst___8;
#line 538
        pDst___8 ++;
#line 538
        *__cil_tmp33___7 = (OPJ_BYTE )(trailing___5 >> (15 - (remaining___5 + 8)));
#line 538
        trailing___5 &= (1U << (15 - (remaining___5 + 8))) - 1U;
#line 538
        remaining___5 ++;
      } else {
#line 538
        remaining___5 += -7;
      }
#line 539
      if (length___8 > 2UL) {
#line 540
        trailing___5 <<= remaining___5;
#line 540
        trailing___5 |= (OPJ_UINT32 )*(pSrc___8 + (i___103 + 2UL)) >> (15 - remaining___5);
#line 540
        __cil_tmp34___9 = pDst___8;
#line 540
        pDst___8 ++;
#line 540
        *__cil_tmp34___9 = (OPJ_BYTE )trailing___5;
#line 540
        trailing___5 = (OPJ_UINT32 )*(pSrc___8 + (i___103 + 2UL)) & ((1U << (15 - remaining___5)) - 1U);
#line 540
        if (15 >= remaining___5 + 8) {
#line 540
          __cil_tmp35___8 = pDst___8;
#line 540
          pDst___8 ++;
#line 540
          *__cil_tmp35___8 = (OPJ_BYTE )(trailing___5 >> (15 - (remaining___5 + 8)));
#line 540
          trailing___5 &= (1U << (15 - (remaining___5 + 8))) - 1U;
#line 540
          remaining___5 ++;
        } else {
#line 540
          remaining___5 += -7;
        }
#line 541
        if (length___8 > 3UL) {
#line 542
          trailing___5 <<= remaining___5;
#line 542
          trailing___5 |= (OPJ_UINT32 )*(pSrc___8 + (i___103 + 3UL)) >> (15 - remaining___5);
#line 542
          __cil_tmp36___6 = pDst___8;
#line 542
          pDst___8 ++;
#line 542
          *__cil_tmp36___6 = (OPJ_BYTE )trailing___5;
#line 542
          trailing___5 = (OPJ_UINT32 )*(pSrc___8 + (i___103 + 3UL)) & ((1U << (15 - remaining___5)) - 1U);
#line 542
          if (15 >= remaining___5 + 8) {
#line 542
            __cil_tmp37___4 = pDst___8;
#line 542
            pDst___8 ++;
#line 542
            *__cil_tmp37___4 = (OPJ_BYTE )(trailing___5 >> (15 - (remaining___5 + 8)));
#line 542
            trailing___5 &= (1U << (15 - (remaining___5 + 8))) - 1U;
#line 542
            remaining___5 ++;
          } else {
#line 542
            remaining___5 += -7;
          }
#line 543
          if (length___8 > 4UL) {
#line 544
            trailing___5 <<= remaining___5;
#line 544
            trailing___5 |= (OPJ_UINT32 )*(pSrc___8 + (i___103 + 4UL)) >> (15 - remaining___5);
#line 544
            __cil_tmp38___3 = pDst___8;
#line 544
            pDst___8 ++;
#line 544
            *__cil_tmp38___3 = (OPJ_BYTE )trailing___5;
#line 544
            trailing___5 = (OPJ_UINT32 )*(pSrc___8 + (i___103 + 4UL)) & ((1U << (15 - remaining___5)) - 1U);
#line 544
            if (15 >= remaining___5 + 8) {
#line 544
              __cil_tmp39___2 = pDst___8;
#line 544
              pDst___8 ++;
#line 544
              *__cil_tmp39___2 = (OPJ_BYTE )(trailing___5 >> (15 - (remaining___5 + 8)));
#line 544
              trailing___5 &= (1U << (15 - (remaining___5 + 8))) - 1U;
#line 544
              remaining___5 ++;
            } else {
#line 544
              remaining___5 += -7;
            }
#line 545
            if (length___8 > 5UL) {
#line 546
              trailing___5 <<= remaining___5;
#line 546
              trailing___5 |= (OPJ_UINT32 )*(pSrc___8 + (i___103 + 5UL)) >> (15 - remaining___5);
#line 546
              __cil_tmp40___3 = pDst___8;
#line 546
              pDst___8 ++;
#line 546
              *__cil_tmp40___3 = (OPJ_BYTE )trailing___5;
#line 546
              trailing___5 = (OPJ_UINT32 )*(pSrc___8 + (i___103 + 5UL)) & ((1U << (15 - remaining___5)) - 1U);
#line 546
              if (15 >= remaining___5 + 8) {
#line 546
                __cil_tmp41___2 = pDst___8;
#line 546
                pDst___8 ++;
#line 546
                *__cil_tmp41___2 = (OPJ_BYTE )(trailing___5 >> (15 - (remaining___5 + 8)));
#line 546
                trailing___5 &= (1U << (15 - (remaining___5 + 8))) - 1U;
#line 546
                remaining___5 ++;
              } else {
#line 546
                remaining___5 += -7;
              }
#line 547
              if (length___8 > 6UL) {
#line 548
                trailing___5 <<= remaining___5;
#line 548
                trailing___5 |= (OPJ_UINT32 )*(pSrc___8 + (i___103 + 6UL)) >> (15 - remaining___5);
#line 548
                __cil_tmp42___1 = pDst___8;
#line 548
                pDst___8 ++;
#line 548
                *__cil_tmp42___1 = (OPJ_BYTE )trailing___5;
#line 548
                trailing___5 = (OPJ_UINT32 )*(pSrc___8 + (i___103 + 6UL)) & ((1U << (15 - remaining___5)) - 1U);
#line 548
                if (15 >= remaining___5 + 8) {
#line 548
                  __cil_tmp43___1 = pDst___8;
#line 548
                  pDst___8 ++;
#line 548
                  *__cil_tmp43___1 = (OPJ_BYTE )(trailing___5 >> (15 - (remaining___5 + 8)));
#line 548
                  trailing___5 &= (1U << (15 - (remaining___5 + 8))) - 1U;
#line 548
                  remaining___5 ++;
                } else {
#line 548
                  remaining___5 += -7;
                }
              }
            }
          }
        }
      }
    }
#line 555
    if (remaining___5 != 8) {
#line 555
      trailing___5 <<= remaining___5;
#line 555
      __cil_tmp44___1 = pDst___8;
#line 555
      pDst___8 ++;
#line 555
      *__cil_tmp44___1 = (OPJ_BYTE )trailing___5;
    }
  }
#line 558
  return;
}
}
#line 558 "/root/patron-new/39/src/bin/jp2/converttif.c"
static void tif_32sto16u(OPJ_INT32 *pSrc___9 , OPJ_UINT16 *pDst___9 , OPJ_SIZE_T length___9 ) 
{ 
  OPJ_SIZE_T i___104 ;

  {
#line 562
  i___104 = (OPJ_SIZE_T )0;
  {
#line 562
  while (1) {
    while_continue: /* CIL Label */ ;

#line 562
    if (! (i___104 < length___9)) {
#line 562
      goto while_break;
    }
#line 563
    *(pDst___9 + i___104) = (OPJ_UINT16 )*(pSrc___9 + i___104);
#line 562
    i___104 ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 566
  return;
}
}
#line 567 "/root/patron-new/39/src/bin/jp2/converttif.c"
int imagetotif(opj_image_t *image___14 , char const   *outfile ) 
{ 
  TIFF *tif ;
  tdata_t buf ;
  uint32 width ;
  uint32 height ;
  uint16 bps ;
  uint16 tiPhoto ;
  int adjust ;
  int sgnd ;
  int64_t strip_size ;
  int64_t rowStride ;
  int64_t TIFF_MAX ;
  OPJ_UINT32 i___105 ;
  OPJ_UINT32 numcomps___4 ;
  OPJ_INT32 *buffer32s ;
  OPJ_INT32 *planes[4] ;
  void (*cvtPxToCx)(OPJ_INT32 * const  * , OPJ_INT32 * , OPJ_SIZE_T  , OPJ_INT32  ) ;
  void (*cvt32sToTif)(OPJ_INT32 * , OPJ_BYTE * , OPJ_SIZE_T  ) ;
  int tmp___463 ;
  tmsize_t __cil_tmp22___24 ;
  void *__cil_tmp24___18 ;

  {
#line 576
  buffer32s = (OPJ_INT32 *)((void *)0);
#line 578
  cvtPxToCx = (void (*)(OPJ_INT32 * const  * , OPJ_INT32 * , OPJ_SIZE_T  , OPJ_INT32  ))((void *)0);
#line 579
  cvt32sToTif = (void (*)(OPJ_INT32 * , OPJ_BYTE * , OPJ_SIZE_T  ))((void *)0);
#line 581
  bps = (uint16 )(image___14->comps + 0)->prec;
#line 582
  planes[0] = (image___14->comps + 0)->data;
#line 584
  numcomps___4 = image___14->numcomps;
#line 586
  if ((int )image___14->color_space == 5) {
#line 587
    if (numcomps___4 < 4U) {
      {
#line 588
      fprintf(stderr, "imagetotif: CMYK images shall be composed of at least 4 planes.\n\220");
#line 590
      fprintf(stderr, "\tAborting\n");
      }
#line 591
      return (1);
    }
#line 593
    tiPhoto = (uint16 )5;
#line 594
    if (numcomps___4 > 4U) {
#line 595
      numcomps___4 = 4U;
    }
  } else
#line 597
  if (numcomps___4 > 2U) {
#line 598
    tiPhoto = (uint16 )2;
#line 599
    if (numcomps___4 > 4U) {
#line 600
      numcomps___4 = 4U;
    }
  } else {
#line 603
    tiPhoto = (uint16 )1;
  }
#line 605
  i___105 = 1U;
  {
#line 605
  while (1) {
    while_continue: /* CIL Label */ ;

#line 605
    if (! (i___105 < numcomps___4)) {
#line 605
      goto while_break;
    }
#line 606
    if ((image___14->comps + 0)->dx != (image___14->comps + i___105)->dx) {
#line 607
      goto while_break;
    }
#line 609
    if ((image___14->comps + 0)->dy != (image___14->comps + i___105)->dy) {
#line 610
      goto while_break;
    }
#line 612
    if ((image___14->comps + 0)->prec != (image___14->comps + i___105)->prec) {
#line 613
      goto while_break;
    }
#line 615
    if ((image___14->comps + 0)->sgnd != (image___14->comps + i___105)->sgnd) {
#line 616
      goto while_break;
    }
#line 618
    planes[i___105] = (image___14->comps + i___105)->data;
#line 619
    if ((unsigned long )planes[i___105] == (unsigned long )((void *)0)) {
      {
#line 620
      fprintf(stderr, "imagetotif: planes[%d] == NULL.\n\230\001", i___105);
#line 622
      fprintf(stderr, "\tAborting\n");
      }
#line 623
      return (1);
    }
#line 605
    i___105 ++;
  }
  while_break___2: /* CIL Label */ ;
  }

  while_break: ;
#line 626
  if (i___105 != numcomps___4) {
    {
#line 627
    fprintf(stderr, "imagetotif: All components shall have the same subsampling, same bit depth.\n");
#line 629
    fprintf(stderr, "\tAborting\n");
    }
#line 630
    return (1);
  }
#line 633
  if ((int )bps > 16) {
#line 634
    bps = (uint16 )0;
  }
#line 636
  if ((int )bps == 0) {
    {
#line 637
    fprintf(stderr, "imagetotif: Bits=%d, Only 1 to 16 bits implemented\n", (int )bps);
#line 638
    fprintf(stderr, "\tAborting\n");
    }
#line 639
    return (1);
  }
  {
#line 641
  tif = TIFFOpen(outfile, "wb");
  }
#line 642
  if (! tif) {
    {
#line 643
    fprintf(stderr, "imagetotif:failed to open %s for writing\n", outfile);
    }
#line 644
    return (1);
  }
#line 646
  i___105 = 0U;
  {
#line 646
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 646
    if (! (i___105 < numcomps___4)) {
#line 646
      goto while_break___0;
    }
    {
#line 647
    clip_component(image___14->comps + i___105, (image___14->comps + 0)->prec);
#line 646
    i___105 ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }

  while_break___0: 
#line 649
  cvtPxToCx = convert_32s_PXCX_LUT[numcomps___4];
#line 655
  if ((int )bps == 8) {
#line 655
    goto case_8;
  }
#line 655
  if ((int )bps == 6) {
#line 655
    goto case_8;
  }
#line 655
  if ((int )bps == 4) {
#line 655
    goto case_8;
  }
#line 655
  if ((int )bps == 2) {
#line 655
    goto case_8;
  }
#line 655
  if ((int )bps == 1) {
#line 655
    goto case_8;
  }
#line 658
  if ((int )bps == 3) {
#line 658
    goto case_3;
  }
#line 661
  if ((int )bps == 5) {
#line 661
    goto case_5;
  }
#line 664
  if ((int )bps == 7) {
#line 664
    goto case_7;
  }
#line 667
  if ((int )bps == 9) {
#line 667
    goto case_9;
  }
#line 670
  if ((int )bps == 10) {
#line 670
    goto case_10;
  }
#line 673
  if ((int )bps == 11) {
#line 673
    goto case_11;
  }
#line 676
  if ((int )bps == 12) {
#line 676
    goto case_12;
  }
#line 679
  if ((int )bps == 13) {
#line 679
    goto case_13;
  }
#line 682
  if ((int )bps == 14) {
#line 682
    goto case_14;
  }
#line 685
  if ((int )bps == 15) {
#line 685
    goto case_15;
  }
#line 688
  if ((int )bps == 16) {
#line 688
    goto case_16;
  }
#line 691
  goto switch_default;
  case_8: 
#line 656
  cvt32sToTif = convert_32sXXu_C1R_LUT[bps];
#line 657
  goto switch_break;
  case_3: 
#line 659
  cvt32sToTif = & tif_32sto3u;
#line 660
  goto switch_break;
  case_5: 
#line 662
  cvt32sToTif = & tif_32sto5u;
#line 663
  goto switch_break;
  case_7: 
#line 665
  cvt32sToTif = & tif_32sto7u;
#line 666
  goto switch_break;
  case_9: 
#line 668
  cvt32sToTif = & tif_32sto9u;
#line 669
  goto switch_break;
  case_10: 
#line 671
  cvt32sToTif = & tif_32sto10u;
#line 672
  goto switch_break;
  case_11: 
#line 674
  cvt32sToTif = & tif_32sto11u;
#line 675
  goto switch_break;
  case_12: 
#line 677
  cvt32sToTif = & tif_32sto12u;
#line 678
  goto switch_break;
  case_13: 
#line 680
  cvt32sToTif = & tif_32sto13u;
#line 681
  goto switch_break;
  case_14: 
#line 683
  cvt32sToTif = & tif_32sto14u;
#line 684
  goto switch_break;
  case_15: 
#line 686
  cvt32sToTif = & tif_32sto15u;
#line 687
  goto switch_break;
  case_16: 
#line 689
  cvt32sToTif = (void (*)(OPJ_INT32 * , OPJ_BYTE * , OPJ_SIZE_T  ))(& tif_32sto16u);
#line 690
  goto switch_break;
  switch_default: 
#line 693
  goto switch_break;
  switch_break: 
#line 695
  sgnd = (int )(image___14->comps + 0)->sgnd;
#line 696
  if (sgnd) {
#line 696
    tmp___463 = 1 << ((image___14->comps + 0)->prec - 1U);
  } else {
#line 696
    tmp___463 = 0;
  }
  {
#line 696
  adjust = tmp___463;
#line 697
  width = (image___14->comps + 0)->w;
#line 698
  height = (image___14->comps + 0)->h;
#line 700
  TIFFSetField(tif, (uint32 )256, width);
#line 701
  TIFFSetField(tif, (uint32 )257, height);
#line 702
  TIFFSetField(tif, (uint32 )277, (int )((uint16 )numcomps___4));
#line 703
  TIFFSetField(tif, (uint32 )258, (int )bps);
#line 704
  TIFFSetField(tif, (uint32 )274, 1);
#line 705
  TIFFSetField(tif, (uint32 )284, 1);
#line 706
  TIFFSetField(tif, (uint32 )262, (int )tiPhoto);
#line 707
  TIFFSetField(tif, (uint32 )278, 1);
  }
#line 708
  if (sizeof(tsize_t ) == 4UL) {
#line 709
    TIFF_MAX = (int64_t )2147483647;
  } else {
#line 711
    TIFF_MAX = (int64_t )4294967295U;
  }
  {
#line 713
  __cil_tmp22___24 = TIFFStripSize(tif);
#line 713
  strip_size = __cil_tmp22___24;
  }
#line 715
  if ((int64_t )width > TIFF_MAX / (long )numcomps___4) {
    {
#line 719
    fprintf(stderr, "Buffer overflow\n\220");
#line 720
    TIFFClose(tif);
    }
#line 721
    return (1);
  } else
#line 715
  if ((int64_t )(width * numcomps___4) > TIFF_MAX / (long )bps) {
    {
#line 719
    fprintf(stderr, "Buffer overflow\n\220");
#line 720
    TIFFClose(tif);
    }
#line 721
    return (1);
  } else
#line 715
  if ((int64_t )(width * numcomps___4) > TIFF_MAX / (int64_t )sizeof(OPJ_INT32 )) {
    {
#line 719
    fprintf(stderr, "Buffer overflow\n\220");
#line 720
    TIFFClose(tif);
    }
#line 721
    return (1);
  }
#line 723
  rowStride = (int64_t )(((width * numcomps___4) * (unsigned int )bps + 7U) / 8U);
#line 724
  if (rowStride != strip_size) {
    {
#line 725
    fprintf(stderr, "Invalid TIFF strip size\n\220");
#line 726
    TIFFClose(tif);
    }
#line 727
    return (1);
  }
  {
#line 729
  buf = malloc((OPJ_SIZE_T )strip_size);
  }
#line 730
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    {
#line 731
    TIFFClose(tif);
    }
#line 732
    return (1);
  }
  {
#line 734
  __cil_tmp24___18 = malloc((sizeof(OPJ_INT32 ) * (unsigned long )width) * (unsigned long )numcomps___4);
#line 734
  buffer32s = (OPJ_INT32 *)__cil_tmp24___18;
  }
#line 735
  if ((unsigned long )buffer32s == (unsigned long )((void *)0)) {
    {
#line 736
    _TIFFfree(buf);
#line 737
    TIFFClose(tif);
    }
#line 738
    return (1);
  }
#line 741
  i___105 = (OPJ_UINT32 )0;
  {
#line 741
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 741
    if (! (i___105 < (image___14->comps + 0)->h)) {
#line 741
      goto while_break___1;
    }
    {
#line 742
    (*cvtPxToCx)((OPJ_INT32 * const  *)(planes), buffer32s, (OPJ_SIZE_T )width, adjust);
#line 743
    (*cvt32sToTif)(buffer32s, (OPJ_BYTE *)buf, (OPJ_SIZE_T )width * (unsigned long )numcomps___4);
#line 744
    TIFFWriteEncodedStrip(tif, i___105, buf, strip_size);
#line 745
    planes[0] += width;
#line 746
    planes[1] += width;
#line 747
    planes[2] += width;
#line 748
    planes[3] += width;
#line 741
    i___105 ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }

  while_break___1: 
  {
#line 750
  _TIFFfree(buf);
#line 751
  TIFFClose(tif);
#line 752
  free((void *)buffer32s);
  }
#line 754
  return (0);
}
}
#line 776 "/root/patron-new/39/src/bin/jp2/converttif.c"
static void tif_3uto32s(OPJ_BYTE *pSrc___10 , OPJ_INT32 *pDst___10 , OPJ_SIZE_T length___10 ) 
{ 
  OPJ_SIZE_T i___106 ;
  OPJ_UINT32 val0 ;
  OPJ_BYTE *__cil_tmp6___37 ;
  OPJ_UINT32 val1 ;
  OPJ_BYTE *__cil_tmp8___55 ;
  OPJ_UINT32 val2 ;
  OPJ_BYTE *__cil_tmp10___26 ;
  unsigned int val ;
  int available ;
  int needed ;
  unsigned int dst___0 ;
  OPJ_BYTE *__cil_tmp15___37 ;
  OPJ_BYTE *__cil_tmp16___30 ;
  int needed___0 ;
  unsigned int dst___1 ;
  OPJ_BYTE *__cil_tmp19___29 ;
  OPJ_BYTE *__cil_tmp20___29 ;
  int needed___1 ;
  unsigned int dst___2 ;
  OPJ_BYTE *__cil_tmp23___22 ;
  OPJ_BYTE *__cil_tmp24___19 ;
  int needed___2 ;
  unsigned int dst___3 ;
  OPJ_BYTE *__cil_tmp27___11 ;
  OPJ_BYTE *__cil_tmp28___11 ;
  int needed___3 ;
  unsigned int dst___4 ;
  OPJ_BYTE *__cil_tmp31___10 ;
  OPJ_BYTE *__cil_tmp32___10 ;
  int needed___4 ;
  unsigned int dst___5 ;
  OPJ_BYTE *__cil_tmp35___9 ;
  OPJ_BYTE *__cil_tmp36___7 ;
  int needed___5 ;
  unsigned int dst___6 ;
  OPJ_BYTE *__cil_tmp39___3 ;
  OPJ_BYTE *__cil_tmp40___4 ;

  {
#line 780
  i___106 = (OPJ_SIZE_T )0;
  {
#line 780
  while (1) {
    while_continue: /* CIL Label */ ;

#line 780
    if (! (i___106 < (length___10 & 0xfffffffffffffff8UL))) {
#line 780
      goto while_break;
    }
#line 781
    __cil_tmp6___37 = pSrc___10;
#line 781
    pSrc___10 ++;
#line 781
    val0 = (OPJ_UINT32 )*__cil_tmp6___37;
#line 782
    __cil_tmp8___55 = pSrc___10;
#line 782
    pSrc___10 ++;
#line 782
    val1 = (OPJ_UINT32 )*__cil_tmp8___55;
#line 783
    __cil_tmp10___26 = pSrc___10;
#line 783
    pSrc___10 ++;
#line 783
    val2 = (OPJ_UINT32 )*__cil_tmp10___26;
#line 785
    *(pDst___10 + i___106) = (OPJ_INT32 )(val0 >> 5);
#line 786
    *(pDst___10 + (i___106 + 1UL)) = (OPJ_INT32 )((val0 & 31U) >> 2);
#line 787
    *(pDst___10 + (i___106 + 2UL)) = (OPJ_INT32 )(((val0 & 3U) << 1) | (val1 >> 7));
#line 788
    *(pDst___10 + (i___106 + 3UL)) = (OPJ_INT32 )((val1 & 127U) >> 4);
#line 789
    *(pDst___10 + (i___106 + 4UL)) = (OPJ_INT32 )((val1 & 15U) >> 1);
#line 790
    *(pDst___10 + (i___106 + 5UL)) = (OPJ_INT32 )(((val1 & 1U) << 2) | (val2 >> 6));
#line 791
    *(pDst___10 + (i___106 + 6UL)) = (OPJ_INT32 )((val2 & 63U) >> 3);
#line 792
    *(pDst___10 + (i___106 + 7UL)) = (OPJ_INT32 )(val2 & 7U);
#line 780
    i___106 += 8UL;
  }
  while_break___7: /* CIL Label */ ;
  }

  while_break: ;
#line 795
  if (length___10 & 7UL) {
#line 797
    available = 0;
#line 799
    length___10 &= 7UL;
#line 801
    needed = 3;
#line 801
    dst___0 = 0U;
#line 801
    if (available == 0) {
#line 801
      __cil_tmp15___37 = pSrc___10;
#line 801
      pSrc___10 ++;
#line 801
      val = (unsigned int )*__cil_tmp15___37;
#line 801
      available = 8;
    }
    {
#line 801
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 801
      if (! (needed > available)) {
#line 801
        goto while_break___0;
      }
#line 801
      dst___0 |= val & ((1U << available) - 1U);
#line 801
      needed -= available;
#line 801
      dst___0 <<= needed;
#line 801
      __cil_tmp16___30 = pSrc___10;
#line 801
      pSrc___10 ++;
#line 801
      val = (unsigned int )*__cil_tmp16___30;
#line 801
      available = 8;
    }
    while_break___8: /* CIL Label */ ;
    }

    while_break___0: 
#line 801
    dst___0 |= (val >> (available - needed)) & ((1U << needed) - 1U);
#line 801
    available -= needed;
#line 801
    *(pDst___10 + i___106) = (OPJ_INT32 )dst___0;
#line 803
    if (length___10 > 1UL) {
#line 804
      needed___0 = 3;
#line 804
      dst___1 = 0U;
#line 804
      if (available == 0) {
#line 804
        __cil_tmp19___29 = pSrc___10;
#line 804
        pSrc___10 ++;
#line 804
        val = (unsigned int )*__cil_tmp19___29;
#line 804
        available = 8;
      }
      {
#line 804
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 804
        if (! (needed___0 > available)) {
#line 804
          goto while_break___1;
        }
#line 804
        dst___1 |= val & ((1U << available) - 1U);
#line 804
        needed___0 -= available;
#line 804
        dst___1 <<= needed___0;
#line 804
        __cil_tmp20___29 = pSrc___10;
#line 804
        pSrc___10 ++;
#line 804
        val = (unsigned int )*__cil_tmp20___29;
#line 804
        available = 8;
      }
      while_break___9: /* CIL Label */ ;
      }

      while_break___1: 
#line 804
      dst___1 |= (val >> (available - needed___0)) & ((1U << needed___0) - 1U);
#line 804
      available -= needed___0;
#line 804
      *(pDst___10 + (i___106 + 1UL)) = (OPJ_INT32 )dst___1;
#line 805
      if (length___10 > 2UL) {
#line 806
        needed___1 = 3;
#line 806
        dst___2 = 0U;
#line 806
        if (available == 0) {
#line 806
          __cil_tmp23___22 = pSrc___10;
#line 806
          pSrc___10 ++;
#line 806
          val = (unsigned int )*__cil_tmp23___22;
#line 806
          available = 8;
        }
        {
#line 806
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 806
          if (! (needed___1 > available)) {
#line 806
            goto while_break___2;
          }
#line 806
          dst___2 |= val & ((1U << available) - 1U);
#line 806
          needed___1 -= available;
#line 806
          dst___2 <<= needed___1;
#line 806
          __cil_tmp24___19 = pSrc___10;
#line 806
          pSrc___10 ++;
#line 806
          val = (unsigned int )*__cil_tmp24___19;
#line 806
          available = 8;
        }
        while_break___10: /* CIL Label */ ;
        }

        while_break___2: 
#line 806
        dst___2 |= (val >> (available - needed___1)) & ((1U << needed___1) - 1U);
#line 806
        available -= needed___1;
#line 806
        *(pDst___10 + (i___106 + 2UL)) = (OPJ_INT32 )dst___2;
#line 807
        if (length___10 > 3UL) {
#line 808
          needed___2 = 3;
#line 808
          dst___3 = 0U;
#line 808
          if (available == 0) {
#line 808
            __cil_tmp27___11 = pSrc___10;
#line 808
            pSrc___10 ++;
#line 808
            val = (unsigned int )*__cil_tmp27___11;
#line 808
            available = 8;
          }
          {
#line 808
          while (1) {
            while_continue___3: /* CIL Label */ ;

#line 808
            if (! (needed___2 > available)) {
#line 808
              goto while_break___3;
            }
#line 808
            dst___3 |= val & ((1U << available) - 1U);
#line 808
            needed___2 -= available;
#line 808
            dst___3 <<= needed___2;
#line 808
            __cil_tmp28___11 = pSrc___10;
#line 808
            pSrc___10 ++;
#line 808
            val = (unsigned int )*__cil_tmp28___11;
#line 808
            available = 8;
          }
          while_break___11: /* CIL Label */ ;
          }

          while_break___3: 
#line 808
          dst___3 |= (val >> (available - needed___2)) & ((1U << needed___2) - 1U);
#line 808
          available -= needed___2;
#line 808
          *(pDst___10 + (i___106 + 3UL)) = (OPJ_INT32 )dst___3;
#line 809
          if (length___10 > 4UL) {
#line 810
            needed___3 = 3;
#line 810
            dst___4 = 0U;
#line 810
            if (available == 0) {
#line 810
              __cil_tmp31___10 = pSrc___10;
#line 810
              pSrc___10 ++;
#line 810
              val = (unsigned int )*__cil_tmp31___10;
#line 810
              available = 8;
            }
            {
#line 810
            while (1) {
              while_continue___4: /* CIL Label */ ;

#line 810
              if (! (needed___3 > available)) {
#line 810
                goto while_break___4;
              }
#line 810
              dst___4 |= val & ((1U << available) - 1U);
#line 810
              needed___3 -= available;
#line 810
              dst___4 <<= needed___3;
#line 810
              __cil_tmp32___10 = pSrc___10;
#line 810
              pSrc___10 ++;
#line 810
              val = (unsigned int )*__cil_tmp32___10;
#line 810
              available = 8;
            }
            while_break___12: /* CIL Label */ ;
            }

            while_break___4: 
#line 810
            dst___4 |= (val >> (available - needed___3)) & ((1U << needed___3) - 1U);
#line 810
            available -= needed___3;
#line 810
            *(pDst___10 + (i___106 + 4UL)) = (OPJ_INT32 )dst___4;
#line 811
            if (length___10 > 5UL) {
#line 812
              needed___4 = 3;
#line 812
              dst___5 = 0U;
#line 812
              if (available == 0) {
#line 812
                __cil_tmp35___9 = pSrc___10;
#line 812
                pSrc___10 ++;
#line 812
                val = (unsigned int )*__cil_tmp35___9;
#line 812
                available = 8;
              }
              {
#line 812
              while (1) {
                while_continue___5: /* CIL Label */ ;

#line 812
                if (! (needed___4 > available)) {
#line 812
                  goto while_break___5;
                }
#line 812
                dst___5 |= val & ((1U << available) - 1U);
#line 812
                needed___4 -= available;
#line 812
                dst___5 <<= needed___4;
#line 812
                __cil_tmp36___7 = pSrc___10;
#line 812
                pSrc___10 ++;
#line 812
                val = (unsigned int )*__cil_tmp36___7;
#line 812
                available = 8;
              }
              while_break___13: /* CIL Label */ ;
              }

              while_break___5: 
#line 812
              dst___5 |= (val >> (available - needed___4)) & ((1U << needed___4) - 1U);
#line 812
              available -= needed___4;
#line 812
              *(pDst___10 + (i___106 + 5UL)) = (OPJ_INT32 )dst___5;
#line 813
              if (length___10 > 6UL) {
#line 814
                needed___5 = 3;
#line 814
                dst___6 = 0U;
#line 814
                if (available == 0) {
#line 814
                  __cil_tmp39___3 = pSrc___10;
#line 814
                  pSrc___10 ++;
#line 814
                  val = (unsigned int )*__cil_tmp39___3;
#line 814
                  available = 8;
                }
                {
#line 814
                while (1) {
                  while_continue___6: /* CIL Label */ ;

#line 814
                  if (! (needed___5 > available)) {
#line 814
                    goto while_break___6;
                  }
#line 814
                  dst___6 |= val & ((1U << available) - 1U);
#line 814
                  needed___5 -= available;
#line 814
                  dst___6 <<= needed___5;
#line 814
                  __cil_tmp40___4 = pSrc___10;
#line 814
                  pSrc___10 ++;
#line 814
                  val = (unsigned int )*__cil_tmp40___4;
#line 814
                  available = 8;
                }
                while_break___14: /* CIL Label */ ;
                }

                while_break___6: 
#line 814
                dst___6 |= (val >> (available - needed___5)) & ((1U << needed___5) - 1U);
#line 814
                available -= needed___5;
#line 814
                *(pDst___10 + (i___106 + 6UL)) = (OPJ_INT32 )dst___6;
              }
            }
          }
        }
      }
    }
  }
#line 822
  return;
}
}
#line 823 "/root/patron-new/39/src/bin/jp2/converttif.c"
static void tif_5uto32s(OPJ_BYTE *pSrc___11 , OPJ_INT32 *pDst___11 , OPJ_SIZE_T length___11 ) 
{ 
  OPJ_SIZE_T i___107 ;
  OPJ_UINT32 val0___0 ;
  OPJ_BYTE *__cil_tmp6___38 ;
  OPJ_UINT32 val1___0 ;
  OPJ_BYTE *__cil_tmp8___56 ;
  OPJ_UINT32 val2___0 ;
  OPJ_BYTE *__cil_tmp10___27 ;
  OPJ_UINT32 val3 ;
  OPJ_BYTE *__cil_tmp12___33 ;
  OPJ_UINT32 val4 ;
  OPJ_BYTE *__cil_tmp14___46 ;
  unsigned int val___0 ;
  int available___0 ;
  int needed___6 ;
  unsigned int dst___7 ;
  OPJ_BYTE *__cil_tmp19___30 ;
  OPJ_BYTE *__cil_tmp20___30 ;
  int needed___7 ;
  unsigned int dst___8 ;
  OPJ_BYTE *__cil_tmp23___23 ;
  OPJ_BYTE *__cil_tmp24___20 ;
  int needed___8 ;
  unsigned int dst___9 ;
  OPJ_BYTE *__cil_tmp27___12 ;
  OPJ_BYTE *__cil_tmp28___12 ;
  int needed___9 ;
  unsigned int dst___10 ;
  OPJ_BYTE *__cil_tmp31___11 ;
  OPJ_BYTE *__cil_tmp32___11 ;
  int needed___10 ;
  unsigned int dst___11 ;
  OPJ_BYTE *__cil_tmp35___10 ;
  OPJ_BYTE *__cil_tmp36___8 ;
  int needed___11 ;
  unsigned int dst___12 ;
  OPJ_BYTE *__cil_tmp39___4 ;
  OPJ_BYTE *__cil_tmp40___5 ;
  int needed___12 ;
  unsigned int dst___13 ;
  OPJ_BYTE *__cil_tmp43___2 ;
  OPJ_BYTE *__cil_tmp44___2 ;

  {
#line 827
  i___107 = (OPJ_SIZE_T )0;
  {
#line 827
  while (1) {
    while_continue: /* CIL Label */ ;

#line 827
    if (! (i___107 < (length___11 & 0xfffffffffffffff8UL))) {
#line 827
      goto while_break;
    }
#line 828
    __cil_tmp6___38 = pSrc___11;
#line 828
    pSrc___11 ++;
#line 828
    val0___0 = (OPJ_UINT32 )*__cil_tmp6___38;
#line 829
    __cil_tmp8___56 = pSrc___11;
#line 829
    pSrc___11 ++;
#line 829
    val1___0 = (OPJ_UINT32 )*__cil_tmp8___56;
#line 830
    __cil_tmp10___27 = pSrc___11;
#line 830
    pSrc___11 ++;
#line 830
    val2___0 = (OPJ_UINT32 )*__cil_tmp10___27;
#line 831
    __cil_tmp12___33 = pSrc___11;
#line 831
    pSrc___11 ++;
#line 831
    val3 = (OPJ_UINT32 )*__cil_tmp12___33;
#line 832
    __cil_tmp14___46 = pSrc___11;
#line 832
    pSrc___11 ++;
#line 832
    val4 = (OPJ_UINT32 )*__cil_tmp14___46;
#line 834
    *(pDst___11 + i___107) = (OPJ_INT32 )(val0___0 >> 3);
#line 835
    *(pDst___11 + (i___107 + 1UL)) = (OPJ_INT32 )(((val0___0 & 7U) << 2) | (val1___0 >> 6));
#line 836
    *(pDst___11 + (i___107 + 2UL)) = (OPJ_INT32 )((val1___0 & 63U) >> 1);
#line 837
    *(pDst___11 + (i___107 + 3UL)) = (OPJ_INT32 )(((val1___0 & 1U) << 4) | (val2___0 >> 4));
#line 838
    *(pDst___11 + (i___107 + 4UL)) = (OPJ_INT32 )(((val2___0 & 15U) << 1) | (val3 >> 7));
#line 839
    *(pDst___11 + (i___107 + 5UL)) = (OPJ_INT32 )((val3 & 127U) >> 2);
#line 840
    *(pDst___11 + (i___107 + 6UL)) = (OPJ_INT32 )(((val3 & 3U) << 3) | (val4 >> 5));
#line 841
    *(pDst___11 + (i___107 + 7UL)) = (OPJ_INT32 )(val4 & 31U);
#line 827
    i___107 += 8UL;
  }
  while_break___7: /* CIL Label */ ;
  }

  while_break: ;
#line 844
  if (length___11 & 7UL) {
#line 846
    available___0 = 0;
#line 848
    length___11 &= 7UL;
#line 850
    needed___6 = 5;
#line 850
    dst___7 = 0U;
#line 850
    if (available___0 == 0) {
#line 850
      __cil_tmp19___30 = pSrc___11;
#line 850
      pSrc___11 ++;
#line 850
      val___0 = (unsigned int )*__cil_tmp19___30;
#line 850
      available___0 = 8;
    }
    {
#line 850
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 850
      if (! (needed___6 > available___0)) {
#line 850
        goto while_break___0;
      }
#line 850
      dst___7 |= val___0 & ((1U << available___0) - 1U);
#line 850
      needed___6 -= available___0;
#line 850
      dst___7 <<= needed___6;
#line 850
      __cil_tmp20___30 = pSrc___11;
#line 850
      pSrc___11 ++;
#line 850
      val___0 = (unsigned int )*__cil_tmp20___30;
#line 850
      available___0 = 8;
    }
    while_break___8: /* CIL Label */ ;
    }

    while_break___0: 
#line 850
    dst___7 |= (val___0 >> (available___0 - needed___6)) & ((1U << needed___6) - 1U);
#line 850
    available___0 -= needed___6;
#line 850
    *(pDst___11 + i___107) = (OPJ_INT32 )dst___7;
#line 852
    if (length___11 > 1UL) {
#line 853
      needed___7 = 5;
#line 853
      dst___8 = 0U;
#line 853
      if (available___0 == 0) {
#line 853
        __cil_tmp23___23 = pSrc___11;
#line 853
        pSrc___11 ++;
#line 853
        val___0 = (unsigned int )*__cil_tmp23___23;
#line 853
        available___0 = 8;
      }
      {
#line 853
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 853
        if (! (needed___7 > available___0)) {
#line 853
          goto while_break___1;
        }
#line 853
        dst___8 |= val___0 & ((1U << available___0) - 1U);
#line 853
        needed___7 -= available___0;
#line 853
        dst___8 <<= needed___7;
#line 853
        __cil_tmp24___20 = pSrc___11;
#line 853
        pSrc___11 ++;
#line 853
        val___0 = (unsigned int )*__cil_tmp24___20;
#line 853
        available___0 = 8;
      }
      while_break___9: /* CIL Label */ ;
      }

      while_break___1: 
#line 853
      dst___8 |= (val___0 >> (available___0 - needed___7)) & ((1U << needed___7) - 1U);
#line 853
      available___0 -= needed___7;
#line 853
      *(pDst___11 + (i___107 + 1UL)) = (OPJ_INT32 )dst___8;
#line 854
      if (length___11 > 2UL) {
#line 855
        needed___8 = 5;
#line 855
        dst___9 = 0U;
#line 855
        if (available___0 == 0) {
#line 855
          __cil_tmp27___12 = pSrc___11;
#line 855
          pSrc___11 ++;
#line 855
          val___0 = (unsigned int )*__cil_tmp27___12;
#line 855
          available___0 = 8;
        }
        {
#line 855
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 855
          if (! (needed___8 > available___0)) {
#line 855
            goto while_break___2;
          }
#line 855
          dst___9 |= val___0 & ((1U << available___0) - 1U);
#line 855
          needed___8 -= available___0;
#line 855
          dst___9 <<= needed___8;
#line 855
          __cil_tmp28___12 = pSrc___11;
#line 855
          pSrc___11 ++;
#line 855
          val___0 = (unsigned int )*__cil_tmp28___12;
#line 855
          available___0 = 8;
        }
        while_break___10: /* CIL Label */ ;
        }

        while_break___2: 
#line 855
        dst___9 |= (val___0 >> (available___0 - needed___8)) & ((1U << needed___8) - 1U);
#line 855
        available___0 -= needed___8;
#line 855
        *(pDst___11 + (i___107 + 2UL)) = (OPJ_INT32 )dst___9;
#line 856
        if (length___11 > 3UL) {
#line 857
          needed___9 = 5;
#line 857
          dst___10 = 0U;
#line 857
          if (available___0 == 0) {
#line 857
            __cil_tmp31___11 = pSrc___11;
#line 857
            pSrc___11 ++;
#line 857
            val___0 = (unsigned int )*__cil_tmp31___11;
#line 857
            available___0 = 8;
          }
          {
#line 857
          while (1) {
            while_continue___3: /* CIL Label */ ;

#line 857
            if (! (needed___9 > available___0)) {
#line 857
              goto while_break___3;
            }
#line 857
            dst___10 |= val___0 & ((1U << available___0) - 1U);
#line 857
            needed___9 -= available___0;
#line 857
            dst___10 <<= needed___9;
#line 857
            __cil_tmp32___11 = pSrc___11;
#line 857
            pSrc___11 ++;
#line 857
            val___0 = (unsigned int )*__cil_tmp32___11;
#line 857
            available___0 = 8;
          }
          while_break___11: /* CIL Label */ ;
          }

          while_break___3: 
#line 857
          dst___10 |= (val___0 >> (available___0 - needed___9)) & ((1U << needed___9) - 1U);
#line 857
          available___0 -= needed___9;
#line 857
          *(pDst___11 + (i___107 + 3UL)) = (OPJ_INT32 )dst___10;
#line 858
          if (length___11 > 4UL) {
#line 859
            needed___10 = 5;
#line 859
            dst___11 = 0U;
#line 859
            if (available___0 == 0) {
#line 859
              __cil_tmp35___10 = pSrc___11;
#line 859
              pSrc___11 ++;
#line 859
              val___0 = (unsigned int )*__cil_tmp35___10;
#line 859
              available___0 = 8;
            }
            {
#line 859
            while (1) {
              while_continue___4: /* CIL Label */ ;

#line 859
              if (! (needed___10 > available___0)) {
#line 859
                goto while_break___4;
              }
#line 859
              dst___11 |= val___0 & ((1U << available___0) - 1U);
#line 859
              needed___10 -= available___0;
#line 859
              dst___11 <<= needed___10;
#line 859
              __cil_tmp36___8 = pSrc___11;
#line 859
              pSrc___11 ++;
#line 859
              val___0 = (unsigned int )*__cil_tmp36___8;
#line 859
              available___0 = 8;
            }
            while_break___12: /* CIL Label */ ;
            }

            while_break___4: 
#line 859
            dst___11 |= (val___0 >> (available___0 - needed___10)) & ((1U << needed___10) - 1U);
#line 859
            available___0 -= needed___10;
#line 859
            *(pDst___11 + (i___107 + 4UL)) = (OPJ_INT32 )dst___11;
#line 860
            if (length___11 > 5UL) {
#line 861
              needed___11 = 5;
#line 861
              dst___12 = 0U;
#line 861
              if (available___0 == 0) {
#line 861
                __cil_tmp39___4 = pSrc___11;
#line 861
                pSrc___11 ++;
#line 861
                val___0 = (unsigned int )*__cil_tmp39___4;
#line 861
                available___0 = 8;
              }
              {
#line 861
              while (1) {
                while_continue___5: /* CIL Label */ ;

#line 861
                if (! (needed___11 > available___0)) {
#line 861
                  goto while_break___5;
                }
#line 861
                dst___12 |= val___0 & ((1U << available___0) - 1U);
#line 861
                needed___11 -= available___0;
#line 861
                dst___12 <<= needed___11;
#line 861
                __cil_tmp40___5 = pSrc___11;
#line 861
                pSrc___11 ++;
#line 861
                val___0 = (unsigned int )*__cil_tmp40___5;
#line 861
                available___0 = 8;
              }
              while_break___13: /* CIL Label */ ;
              }

              while_break___5: 
#line 861
              dst___12 |= (val___0 >> (available___0 - needed___11)) & ((1U << needed___11) - 1U);
#line 861
              available___0 -= needed___11;
#line 861
              *(pDst___11 + (i___107 + 5UL)) = (OPJ_INT32 )dst___12;
#line 862
              if (length___11 > 6UL) {
#line 863
                needed___12 = 5;
#line 863
                dst___13 = 0U;
#line 863
                if (available___0 == 0) {
#line 863
                  __cil_tmp43___2 = pSrc___11;
#line 863
                  pSrc___11 ++;
#line 863
                  val___0 = (unsigned int )*__cil_tmp43___2;
#line 863
                  available___0 = 8;
                }
                {
#line 863
                while (1) {
                  while_continue___6: /* CIL Label */ ;

#line 863
                  if (! (needed___12 > available___0)) {
#line 863
                    goto while_break___6;
                  }
#line 863
                  dst___13 |= val___0 & ((1U << available___0) - 1U);
#line 863
                  needed___12 -= available___0;
#line 863
                  dst___13 <<= needed___12;
#line 863
                  __cil_tmp44___2 = pSrc___11;
#line 863
                  pSrc___11 ++;
#line 863
                  val___0 = (unsigned int )*__cil_tmp44___2;
#line 863
                  available___0 = 8;
                }
                while_break___14: /* CIL Label */ ;
                }

                while_break___6: 
#line 863
                dst___13 |= (val___0 >> (available___0 - needed___12)) & ((1U << needed___12) - 1U);
#line 863
                available___0 -= needed___12;
#line 863
                *(pDst___11 + (i___107 + 6UL)) = (OPJ_INT32 )dst___13;
              }
            }
          }
        }
      }
    }
  }
#line 871
  return;
}
}
#line 872 "/root/patron-new/39/src/bin/jp2/converttif.c"
static void tif_7uto32s(OPJ_BYTE *pSrc___12 , OPJ_INT32 *pDst___12 , OPJ_SIZE_T length___12 ) 
{ 
  OPJ_SIZE_T i___108 ;
  OPJ_UINT32 val0___1 ;
  OPJ_BYTE *__cil_tmp6___39 ;
  OPJ_UINT32 val1___1 ;
  OPJ_BYTE *__cil_tmp8___57 ;
  OPJ_UINT32 val2___1 ;
  OPJ_BYTE *__cil_tmp10___28 ;
  OPJ_UINT32 val3___0 ;
  OPJ_BYTE *__cil_tmp12___34 ;
  OPJ_UINT32 val4___0 ;
  OPJ_BYTE *__cil_tmp14___47 ;
  OPJ_UINT32 val5 ;
  OPJ_BYTE *__cil_tmp16___31 ;
  OPJ_UINT32 val6 ;
  OPJ_BYTE *__cil_tmp18___23 ;
  unsigned int val___1 ;
  int available___1 ;
  int needed___13 ;
  unsigned int dst___14 ;
  OPJ_BYTE *__cil_tmp23___24 ;
  OPJ_BYTE *__cil_tmp24___21 ;
  int needed___14 ;
  unsigned int dst___15 ;
  OPJ_BYTE *__cil_tmp27___13 ;
  OPJ_BYTE *__cil_tmp28___13 ;
  int needed___15 ;
  unsigned int dst___16 ;
  OPJ_BYTE *__cil_tmp31___12 ;
  OPJ_BYTE *__cil_tmp32___12 ;
  int needed___16 ;
  unsigned int dst___17 ;
  OPJ_BYTE *__cil_tmp35___11 ;
  OPJ_BYTE *__cil_tmp36___9 ;
  int needed___17 ;
  unsigned int dst___18 ;
  OPJ_BYTE *__cil_tmp39___5 ;
  OPJ_BYTE *__cil_tmp40___6 ;
  int needed___18 ;
  unsigned int dst___19 ;
  OPJ_BYTE *__cil_tmp43___3 ;
  OPJ_BYTE *__cil_tmp44___3 ;
  int needed___19 ;
  unsigned int dst___20 ;
  OPJ_BYTE *__cil_tmp47 ;
  OPJ_BYTE *__cil_tmp48___0 ;

  {
#line 876
  i___108 = (OPJ_SIZE_T )0;
  {
#line 876
  while (1) {
    while_continue: /* CIL Label */ ;

#line 876
    if (! (i___108 < (length___12 & 0xfffffffffffffff8UL))) {
#line 876
      goto while_break;
    }
#line 877
    __cil_tmp6___39 = pSrc___12;
#line 877
    pSrc___12 ++;
#line 877
    val0___1 = (OPJ_UINT32 )*__cil_tmp6___39;
#line 878
    __cil_tmp8___57 = pSrc___12;
#line 878
    pSrc___12 ++;
#line 878
    val1___1 = (OPJ_UINT32 )*__cil_tmp8___57;
#line 879
    __cil_tmp10___28 = pSrc___12;
#line 879
    pSrc___12 ++;
#line 879
    val2___1 = (OPJ_UINT32 )*__cil_tmp10___28;
#line 880
    __cil_tmp12___34 = pSrc___12;
#line 880
    pSrc___12 ++;
#line 880
    val3___0 = (OPJ_UINT32 )*__cil_tmp12___34;
#line 881
    __cil_tmp14___47 = pSrc___12;
#line 881
    pSrc___12 ++;
#line 881
    val4___0 = (OPJ_UINT32 )*__cil_tmp14___47;
#line 882
    __cil_tmp16___31 = pSrc___12;
#line 882
    pSrc___12 ++;
#line 882
    val5 = (OPJ_UINT32 )*__cil_tmp16___31;
#line 883
    __cil_tmp18___23 = pSrc___12;
#line 883
    pSrc___12 ++;
#line 883
    val6 = (OPJ_UINT32 )*__cil_tmp18___23;
#line 885
    *(pDst___12 + i___108) = (OPJ_INT32 )(val0___1 >> 1);
#line 886
    *(pDst___12 + (i___108 + 1UL)) = (OPJ_INT32 )(((val0___1 & 1U) << 6) | (val1___1 >> 2));
#line 887
    *(pDst___12 + (i___108 + 2UL)) = (OPJ_INT32 )(((val1___1 & 3U) << 5) | (val2___1 >> 3));
#line 888
    *(pDst___12 + (i___108 + 3UL)) = (OPJ_INT32 )(((val2___1 & 7U) << 4) | (val3___0 >> 4));
#line 889
    *(pDst___12 + (i___108 + 4UL)) = (OPJ_INT32 )(((val3___0 & 15U) << 3) | (val4___0 >> 5));
#line 890
    *(pDst___12 + (i___108 + 5UL)) = (OPJ_INT32 )(((val4___0 & 31U) << 2) | (val5 >> 6));
#line 891
    *(pDst___12 + (i___108 + 6UL)) = (OPJ_INT32 )(((val5 & 63U) << 1) | (val6 >> 7));
#line 892
    *(pDst___12 + (i___108 + 7UL)) = (OPJ_INT32 )(val6 & 127U);
#line 876
    i___108 += 8UL;
  }
  while_break___7: /* CIL Label */ ;
  }

  while_break: ;
#line 895
  if (length___12 & 7UL) {
#line 897
    available___1 = 0;
#line 899
    length___12 &= 7UL;
#line 901
    needed___13 = 7;
#line 901
    dst___14 = 0U;
#line 901
    if (available___1 == 0) {
#line 901
      __cil_tmp23___24 = pSrc___12;
#line 901
      pSrc___12 ++;
#line 901
      val___1 = (unsigned int )*__cil_tmp23___24;
#line 901
      available___1 = 8;
    }
    {
#line 901
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 901
      if (! (needed___13 > available___1)) {
#line 901
        goto while_break___0;
      }
#line 901
      dst___14 |= val___1 & ((1U << available___1) - 1U);
#line 901
      needed___13 -= available___1;
#line 901
      dst___14 <<= needed___13;
#line 901
      __cil_tmp24___21 = pSrc___12;
#line 901
      pSrc___12 ++;
#line 901
      val___1 = (unsigned int )*__cil_tmp24___21;
#line 901
      available___1 = 8;
    }
    while_break___8: /* CIL Label */ ;
    }

    while_break___0: 
#line 901
    dst___14 |= (val___1 >> (available___1 - needed___13)) & ((1U << needed___13) - 1U);
#line 901
    available___1 -= needed___13;
#line 901
    *(pDst___12 + i___108) = (OPJ_INT32 )dst___14;
#line 903
    if (length___12 > 1UL) {
#line 904
      needed___14 = 7;
#line 904
      dst___15 = 0U;
#line 904
      if (available___1 == 0) {
#line 904
        __cil_tmp27___13 = pSrc___12;
#line 904
        pSrc___12 ++;
#line 904
        val___1 = (unsigned int )*__cil_tmp27___13;
#line 904
        available___1 = 8;
      }
      {
#line 904
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 904
        if (! (needed___14 > available___1)) {
#line 904
          goto while_break___1;
        }
#line 904
        dst___15 |= val___1 & ((1U << available___1) - 1U);
#line 904
        needed___14 -= available___1;
#line 904
        dst___15 <<= needed___14;
#line 904
        __cil_tmp28___13 = pSrc___12;
#line 904
        pSrc___12 ++;
#line 904
        val___1 = (unsigned int )*__cil_tmp28___13;
#line 904
        available___1 = 8;
      }
      while_break___9: /* CIL Label */ ;
      }

      while_break___1: 
#line 904
      dst___15 |= (val___1 >> (available___1 - needed___14)) & ((1U << needed___14) - 1U);
#line 904
      available___1 -= needed___14;
#line 904
      *(pDst___12 + (i___108 + 1UL)) = (OPJ_INT32 )dst___15;
#line 905
      if (length___12 > 2UL) {
#line 906
        needed___15 = 7;
#line 906
        dst___16 = 0U;
#line 906
        if (available___1 == 0) {
#line 906
          __cil_tmp31___12 = pSrc___12;
#line 906
          pSrc___12 ++;
#line 906
          val___1 = (unsigned int )*__cil_tmp31___12;
#line 906
          available___1 = 8;
        }
        {
#line 906
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 906
          if (! (needed___15 > available___1)) {
#line 906
            goto while_break___2;
          }
#line 906
          dst___16 |= val___1 & ((1U << available___1) - 1U);
#line 906
          needed___15 -= available___1;
#line 906
          dst___16 <<= needed___15;
#line 906
          __cil_tmp32___12 = pSrc___12;
#line 906
          pSrc___12 ++;
#line 906
          val___1 = (unsigned int )*__cil_tmp32___12;
#line 906
          available___1 = 8;
        }
        while_break___10: /* CIL Label */ ;
        }

        while_break___2: 
#line 906
        dst___16 |= (val___1 >> (available___1 - needed___15)) & ((1U << needed___15) - 1U);
#line 906
        available___1 -= needed___15;
#line 906
        *(pDst___12 + (i___108 + 2UL)) = (OPJ_INT32 )dst___16;
#line 907
        if (length___12 > 3UL) {
#line 908
          needed___16 = 7;
#line 908
          dst___17 = 0U;
#line 908
          if (available___1 == 0) {
#line 908
            __cil_tmp35___11 = pSrc___12;
#line 908
            pSrc___12 ++;
#line 908
            val___1 = (unsigned int )*__cil_tmp35___11;
#line 908
            available___1 = 8;
          }
          {
#line 908
          while (1) {
            while_continue___3: /* CIL Label */ ;

#line 908
            if (! (needed___16 > available___1)) {
#line 908
              goto while_break___3;
            }
#line 908
            dst___17 |= val___1 & ((1U << available___1) - 1U);
#line 908
            needed___16 -= available___1;
#line 908
            dst___17 <<= needed___16;
#line 908
            __cil_tmp36___9 = pSrc___12;
#line 908
            pSrc___12 ++;
#line 908
            val___1 = (unsigned int )*__cil_tmp36___9;
#line 908
            available___1 = 8;
          }
          while_break___11: /* CIL Label */ ;
          }

          while_break___3: 
#line 908
          dst___17 |= (val___1 >> (available___1 - needed___16)) & ((1U << needed___16) - 1U);
#line 908
          available___1 -= needed___16;
#line 908
          *(pDst___12 + (i___108 + 3UL)) = (OPJ_INT32 )dst___17;
#line 909
          if (length___12 > 4UL) {
#line 910
            needed___17 = 7;
#line 910
            dst___18 = 0U;
#line 910
            if (available___1 == 0) {
#line 910
              __cil_tmp39___5 = pSrc___12;
#line 910
              pSrc___12 ++;
#line 910
              val___1 = (unsigned int )*__cil_tmp39___5;
#line 910
              available___1 = 8;
            }
            {
#line 910
            while (1) {
              while_continue___4: /* CIL Label */ ;

#line 910
              if (! (needed___17 > available___1)) {
#line 910
                goto while_break___4;
              }
#line 910
              dst___18 |= val___1 & ((1U << available___1) - 1U);
#line 910
              needed___17 -= available___1;
#line 910
              dst___18 <<= needed___17;
#line 910
              __cil_tmp40___6 = pSrc___12;
#line 910
              pSrc___12 ++;
#line 910
              val___1 = (unsigned int )*__cil_tmp40___6;
#line 910
              available___1 = 8;
            }
            while_break___12: /* CIL Label */ ;
            }

            while_break___4: 
#line 910
            dst___18 |= (val___1 >> (available___1 - needed___17)) & ((1U << needed___17) - 1U);
#line 910
            available___1 -= needed___17;
#line 910
            *(pDst___12 + (i___108 + 4UL)) = (OPJ_INT32 )dst___18;
#line 911
            if (length___12 > 5UL) {
#line 912
              needed___18 = 7;
#line 912
              dst___19 = 0U;
#line 912
              if (available___1 == 0) {
#line 912
                __cil_tmp43___3 = pSrc___12;
#line 912
                pSrc___12 ++;
#line 912
                val___1 = (unsigned int )*__cil_tmp43___3;
#line 912
                available___1 = 8;
              }
              {
#line 912
              while (1) {
                while_continue___5: /* CIL Label */ ;

#line 912
                if (! (needed___18 > available___1)) {
#line 912
                  goto while_break___5;
                }
#line 912
                dst___19 |= val___1 & ((1U << available___1) - 1U);
#line 912
                needed___18 -= available___1;
#line 912
                dst___19 <<= needed___18;
#line 912
                __cil_tmp44___3 = pSrc___12;
#line 912
                pSrc___12 ++;
#line 912
                val___1 = (unsigned int )*__cil_tmp44___3;
#line 912
                available___1 = 8;
              }
              while_break___13: /* CIL Label */ ;
              }

              while_break___5: 
#line 912
              dst___19 |= (val___1 >> (available___1 - needed___18)) & ((1U << needed___18) - 1U);
#line 912
              available___1 -= needed___18;
#line 912
              *(pDst___12 + (i___108 + 5UL)) = (OPJ_INT32 )dst___19;
#line 913
              if (length___12 > 6UL) {
#line 914
                needed___19 = 7;
#line 914
                dst___20 = 0U;
#line 914
                if (available___1 == 0) {
#line 914
                  __cil_tmp47 = pSrc___12;
#line 914
                  pSrc___12 ++;
#line 914
                  val___1 = (unsigned int )*__cil_tmp47;
#line 914
                  available___1 = 8;
                }
                {
#line 914
                while (1) {
                  while_continue___6: /* CIL Label */ ;

#line 914
                  if (! (needed___19 > available___1)) {
#line 914
                    goto while_break___6;
                  }
#line 914
                  dst___20 |= val___1 & ((1U << available___1) - 1U);
#line 914
                  needed___19 -= available___1;
#line 914
                  dst___20 <<= needed___19;
#line 914
                  __cil_tmp48___0 = pSrc___12;
#line 914
                  pSrc___12 ++;
#line 914
                  val___1 = (unsigned int )*__cil_tmp48___0;
#line 914
                  available___1 = 8;
                }
                while_break___14: /* CIL Label */ ;
                }

                while_break___6: 
#line 914
                dst___20 |= (val___1 >> (available___1 - needed___19)) & ((1U << needed___19) - 1U);
#line 914
                available___1 -= needed___19;
#line 914
                *(pDst___12 + (i___108 + 6UL)) = (OPJ_INT32 )dst___20;
              }
            }
          }
        }
      }
    }
  }
#line 922
  return;
}
}
#line 923 "/root/patron-new/39/src/bin/jp2/converttif.c"
static void tif_9uto32s(OPJ_BYTE *pSrc___13 , OPJ_INT32 *pDst___13 , OPJ_SIZE_T length___13 ) 
{ 
  OPJ_SIZE_T i___109 ;
  OPJ_UINT32 val0___2 ;
  OPJ_BYTE *__cil_tmp6___40 ;
  OPJ_UINT32 val1___2 ;
  OPJ_BYTE *__cil_tmp8___58 ;
  OPJ_UINT32 val2___2 ;
  OPJ_BYTE *__cil_tmp10___29 ;
  OPJ_UINT32 val3___1 ;
  OPJ_BYTE *__cil_tmp12___35 ;
  OPJ_UINT32 val4___1 ;
  OPJ_BYTE *__cil_tmp14___48 ;
  OPJ_UINT32 val5___0 ;
  OPJ_BYTE *__cil_tmp16___32 ;
  OPJ_UINT32 val6___0 ;
  OPJ_BYTE *__cil_tmp18___24 ;
  OPJ_UINT32 val7 ;
  OPJ_BYTE *__cil_tmp20___31 ;
  OPJ_UINT32 val8 ;
  OPJ_BYTE *__cil_tmp22___25 ;
  unsigned int val___2 ;
  int available___2 ;
  int needed___20 ;
  unsigned int dst___21 ;
  OPJ_BYTE *__cil_tmp27___14 ;
  OPJ_BYTE *__cil_tmp28___14 ;
  int needed___21 ;
  unsigned int dst___22 ;
  OPJ_BYTE *__cil_tmp31___13 ;
  OPJ_BYTE *__cil_tmp32___13 ;
  int needed___22 ;
  unsigned int dst___23 ;
  OPJ_BYTE *__cil_tmp35___12 ;
  OPJ_BYTE *__cil_tmp36___10 ;
  int needed___23 ;
  unsigned int dst___24 ;
  OPJ_BYTE *__cil_tmp39___6 ;
  OPJ_BYTE *__cil_tmp40___7 ;
  int needed___24 ;
  unsigned int dst___25 ;
  OPJ_BYTE *__cil_tmp43___4 ;
  OPJ_BYTE *__cil_tmp44___4 ;
  int needed___25 ;
  unsigned int dst___26 ;
  OPJ_BYTE *__cil_tmp47___0 ;
  OPJ_BYTE *__cil_tmp48___1 ;
  int needed___26 ;
  unsigned int dst___27 ;
  OPJ_BYTE *__cil_tmp51___0 ;
  OPJ_BYTE *__cil_tmp52___0 ;

  {
#line 927
  i___109 = (OPJ_SIZE_T )0;
  {
#line 927
  while (1) {
    while_continue: /* CIL Label */ ;

#line 927
    if (! (i___109 < (length___13 & 0xfffffffffffffff8UL))) {
#line 927
      goto while_break;
    }
#line 928
    __cil_tmp6___40 = pSrc___13;
#line 928
    pSrc___13 ++;
#line 928
    val0___2 = (OPJ_UINT32 )*__cil_tmp6___40;
#line 929
    __cil_tmp8___58 = pSrc___13;
#line 929
    pSrc___13 ++;
#line 929
    val1___2 = (OPJ_UINT32 )*__cil_tmp8___58;
#line 930
    __cil_tmp10___29 = pSrc___13;
#line 930
    pSrc___13 ++;
#line 930
    val2___2 = (OPJ_UINT32 )*__cil_tmp10___29;
#line 931
    __cil_tmp12___35 = pSrc___13;
#line 931
    pSrc___13 ++;
#line 931
    val3___1 = (OPJ_UINT32 )*__cil_tmp12___35;
#line 932
    __cil_tmp14___48 = pSrc___13;
#line 932
    pSrc___13 ++;
#line 932
    val4___1 = (OPJ_UINT32 )*__cil_tmp14___48;
#line 933
    __cil_tmp16___32 = pSrc___13;
#line 933
    pSrc___13 ++;
#line 933
    val5___0 = (OPJ_UINT32 )*__cil_tmp16___32;
#line 934
    __cil_tmp18___24 = pSrc___13;
#line 934
    pSrc___13 ++;
#line 934
    val6___0 = (OPJ_UINT32 )*__cil_tmp18___24;
#line 935
    __cil_tmp20___31 = pSrc___13;
#line 935
    pSrc___13 ++;
#line 935
    val7 = (OPJ_UINT32 )*__cil_tmp20___31;
#line 936
    __cil_tmp22___25 = pSrc___13;
#line 936
    pSrc___13 ++;
#line 936
    val8 = (OPJ_UINT32 )*__cil_tmp22___25;
#line 938
    *(pDst___13 + i___109) = (OPJ_INT32 )((val0___2 << 1) | (val1___2 >> 7));
#line 939
    *(pDst___13 + (i___109 + 1UL)) = (OPJ_INT32 )(((val1___2 & 127U) << 2) | (val2___2 >> 6));
#line 940
    *(pDst___13 + (i___109 + 2UL)) = (OPJ_INT32 )(((val2___2 & 63U) << 3) | (val3___1 >> 5));
#line 941
    *(pDst___13 + (i___109 + 3UL)) = (OPJ_INT32 )(((val3___1 & 31U) << 4) | (val4___1 >> 4));
#line 942
    *(pDst___13 + (i___109 + 4UL)) = (OPJ_INT32 )(((val4___1 & 15U) << 5) | (val5___0 >> 3));
#line 943
    *(pDst___13 + (i___109 + 5UL)) = (OPJ_INT32 )(((val5___0 & 7U) << 6) | (val6___0 >> 2));
#line 944
    *(pDst___13 + (i___109 + 6UL)) = (OPJ_INT32 )(((val6___0 & 3U) << 7) | (val7 >> 1));
#line 945
    *(pDst___13 + (i___109 + 7UL)) = (OPJ_INT32 )(((val7 & 1U) << 8) | val8);
#line 927
    i___109 += 8UL;
  }
  while_break___7: /* CIL Label */ ;
  }

  while_break: ;
#line 948
  if (length___13 & 7UL) {
#line 950
    available___2 = 0;
#line 952
    length___13 &= 7UL;
#line 954
    needed___20 = 9;
#line 954
    dst___21 = 0U;
#line 954
    if (available___2 == 0) {
#line 954
      __cil_tmp27___14 = pSrc___13;
#line 954
      pSrc___13 ++;
#line 954
      val___2 = (unsigned int )*__cil_tmp27___14;
#line 954
      available___2 = 8;
    }
    {
#line 954
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 954
      if (! (needed___20 > available___2)) {
#line 954
        goto while_break___0;
      }
#line 954
      dst___21 |= val___2 & ((1U << available___2) - 1U);
#line 954
      needed___20 -= available___2;
#line 954
      dst___21 <<= needed___20;
#line 954
      __cil_tmp28___14 = pSrc___13;
#line 954
      pSrc___13 ++;
#line 954
      val___2 = (unsigned int )*__cil_tmp28___14;
#line 954
      available___2 = 8;
    }
    while_break___8: /* CIL Label */ ;
    }

    while_break___0: 
#line 954
    dst___21 |= (val___2 >> (available___2 - needed___20)) & ((1U << needed___20) - 1U);
#line 954
    available___2 -= needed___20;
#line 954
    *(pDst___13 + i___109) = (OPJ_INT32 )dst___21;
#line 956
    if (length___13 > 1UL) {
#line 957
      needed___21 = 9;
#line 957
      dst___22 = 0U;
#line 957
      if (available___2 == 0) {
#line 957
        __cil_tmp31___13 = pSrc___13;
#line 957
        pSrc___13 ++;
#line 957
        val___2 = (unsigned int )*__cil_tmp31___13;
#line 957
        available___2 = 8;
      }
      {
#line 957
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 957
        if (! (needed___21 > available___2)) {
#line 957
          goto while_break___1;
        }
#line 957
        dst___22 |= val___2 & ((1U << available___2) - 1U);
#line 957
        needed___21 -= available___2;
#line 957
        dst___22 <<= needed___21;
#line 957
        __cil_tmp32___13 = pSrc___13;
#line 957
        pSrc___13 ++;
#line 957
        val___2 = (unsigned int )*__cil_tmp32___13;
#line 957
        available___2 = 8;
      }
      while_break___9: /* CIL Label */ ;
      }

      while_break___1: 
#line 957
      dst___22 |= (val___2 >> (available___2 - needed___21)) & ((1U << needed___21) - 1U);
#line 957
      available___2 -= needed___21;
#line 957
      *(pDst___13 + (i___109 + 1UL)) = (OPJ_INT32 )dst___22;
#line 958
      if (length___13 > 2UL) {
#line 959
        needed___22 = 9;
#line 959
        dst___23 = 0U;
#line 959
        if (available___2 == 0) {
#line 959
          __cil_tmp35___12 = pSrc___13;
#line 959
          pSrc___13 ++;
#line 959
          val___2 = (unsigned int )*__cil_tmp35___12;
#line 959
          available___2 = 8;
        }
        {
#line 959
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 959
          if (! (needed___22 > available___2)) {
#line 959
            goto while_break___2;
          }
#line 959
          dst___23 |= val___2 & ((1U << available___2) - 1U);
#line 959
          needed___22 -= available___2;
#line 959
          dst___23 <<= needed___22;
#line 959
          __cil_tmp36___10 = pSrc___13;
#line 959
          pSrc___13 ++;
#line 959
          val___2 = (unsigned int )*__cil_tmp36___10;
#line 959
          available___2 = 8;
        }
        while_break___10: /* CIL Label */ ;
        }

        while_break___2: 
#line 959
        dst___23 |= (val___2 >> (available___2 - needed___22)) & ((1U << needed___22) - 1U);
#line 959
        available___2 -= needed___22;
#line 959
        *(pDst___13 + (i___109 + 2UL)) = (OPJ_INT32 )dst___23;
#line 960
        if (length___13 > 3UL) {
#line 961
          needed___23 = 9;
#line 961
          dst___24 = 0U;
#line 961
          if (available___2 == 0) {
#line 961
            __cil_tmp39___6 = pSrc___13;
#line 961
            pSrc___13 ++;
#line 961
            val___2 = (unsigned int )*__cil_tmp39___6;
#line 961
            available___2 = 8;
          }
          {
#line 961
          while (1) {
            while_continue___3: /* CIL Label */ ;

#line 961
            if (! (needed___23 > available___2)) {
#line 961
              goto while_break___3;
            }
#line 961
            dst___24 |= val___2 & ((1U << available___2) - 1U);
#line 961
            needed___23 -= available___2;
#line 961
            dst___24 <<= needed___23;
#line 961
            __cil_tmp40___7 = pSrc___13;
#line 961
            pSrc___13 ++;
#line 961
            val___2 = (unsigned int )*__cil_tmp40___7;
#line 961
            available___2 = 8;
          }
          while_break___11: /* CIL Label */ ;
          }

          while_break___3: 
#line 961
          dst___24 |= (val___2 >> (available___2 - needed___23)) & ((1U << needed___23) - 1U);
#line 961
          available___2 -= needed___23;
#line 961
          *(pDst___13 + (i___109 + 3UL)) = (OPJ_INT32 )dst___24;
#line 962
          if (length___13 > 4UL) {
#line 963
            needed___24 = 9;
#line 963
            dst___25 = 0U;
#line 963
            if (available___2 == 0) {
#line 963
              __cil_tmp43___4 = pSrc___13;
#line 963
              pSrc___13 ++;
#line 963
              val___2 = (unsigned int )*__cil_tmp43___4;
#line 963
              available___2 = 8;
            }
            {
#line 963
            while (1) {
              while_continue___4: /* CIL Label */ ;

#line 963
              if (! (needed___24 > available___2)) {
#line 963
                goto while_break___4;
              }
#line 963
              dst___25 |= val___2 & ((1U << available___2) - 1U);
#line 963
              needed___24 -= available___2;
#line 963
              dst___25 <<= needed___24;
#line 963
              __cil_tmp44___4 = pSrc___13;
#line 963
              pSrc___13 ++;
#line 963
              val___2 = (unsigned int )*__cil_tmp44___4;
#line 963
              available___2 = 8;
            }
            while_break___12: /* CIL Label */ ;
            }

            while_break___4: 
#line 963
            dst___25 |= (val___2 >> (available___2 - needed___24)) & ((1U << needed___24) - 1U);
#line 963
            available___2 -= needed___24;
#line 963
            *(pDst___13 + (i___109 + 4UL)) = (OPJ_INT32 )dst___25;
#line 964
            if (length___13 > 5UL) {
#line 965
              needed___25 = 9;
#line 965
              dst___26 = 0U;
#line 965
              if (available___2 == 0) {
#line 965
                __cil_tmp47___0 = pSrc___13;
#line 965
                pSrc___13 ++;
#line 965
                val___2 = (unsigned int )*__cil_tmp47___0;
#line 965
                available___2 = 8;
              }
              {
#line 965
              while (1) {
                while_continue___5: /* CIL Label */ ;

#line 965
                if (! (needed___25 > available___2)) {
#line 965
                  goto while_break___5;
                }
#line 965
                dst___26 |= val___2 & ((1U << available___2) - 1U);
#line 965
                needed___25 -= available___2;
#line 965
                dst___26 <<= needed___25;
#line 965
                __cil_tmp48___1 = pSrc___13;
#line 965
                pSrc___13 ++;
#line 965
                val___2 = (unsigned int )*__cil_tmp48___1;
#line 965
                available___2 = 8;
              }
              while_break___13: /* CIL Label */ ;
              }

              while_break___5: 
#line 965
              dst___26 |= (val___2 >> (available___2 - needed___25)) & ((1U << needed___25) - 1U);
#line 965
              available___2 -= needed___25;
#line 965
              *(pDst___13 + (i___109 + 5UL)) = (OPJ_INT32 )dst___26;
#line 966
              if (length___13 > 6UL) {
#line 967
                needed___26 = 9;
#line 967
                dst___27 = 0U;
#line 967
                if (available___2 == 0) {
#line 967
                  __cil_tmp51___0 = pSrc___13;
#line 967
                  pSrc___13 ++;
#line 967
                  val___2 = (unsigned int )*__cil_tmp51___0;
#line 967
                  available___2 = 8;
                }
                {
#line 967
                while (1) {
                  while_continue___6: /* CIL Label */ ;

#line 967
                  if (! (needed___26 > available___2)) {
#line 967
                    goto while_break___6;
                  }
#line 967
                  dst___27 |= val___2 & ((1U << available___2) - 1U);
#line 967
                  needed___26 -= available___2;
#line 967
                  dst___27 <<= needed___26;
#line 967
                  __cil_tmp52___0 = pSrc___13;
#line 967
                  pSrc___13 ++;
#line 967
                  val___2 = (unsigned int )*__cil_tmp52___0;
#line 967
                  available___2 = 8;
                }
                while_break___14: /* CIL Label */ ;
                }

                while_break___6: 
#line 967
                dst___27 |= (val___2 >> (available___2 - needed___26)) & ((1U << needed___26) - 1U);
#line 967
                available___2 -= needed___26;
#line 967
                *(pDst___13 + (i___109 + 6UL)) = (OPJ_INT32 )dst___27;
              }
            }
          }
        }
      }
    }
  }
#line 975
  return;
}
}
#line 976 "/root/patron-new/39/src/bin/jp2/converttif.c"
static void tif_10uto32s(OPJ_BYTE *pSrc___14 , OPJ_INT32 *pDst___14 , OPJ_SIZE_T length___14 ) 
{ 
  OPJ_SIZE_T i___110 ;
  OPJ_UINT32 val0___3 ;
  OPJ_BYTE *__cil_tmp6___41 ;
  OPJ_UINT32 val1___3 ;
  OPJ_BYTE *__cil_tmp8___59 ;
  OPJ_UINT32 val2___3 ;
  OPJ_BYTE *__cil_tmp10___30 ;
  OPJ_UINT32 val3___2 ;
  OPJ_BYTE *__cil_tmp12___36 ;
  OPJ_UINT32 val4___2 ;
  OPJ_BYTE *__cil_tmp14___49 ;
  OPJ_UINT32 val0___4 ;
  OPJ_BYTE *__cil_tmp16___33 ;
  OPJ_UINT32 val1___4 ;
  OPJ_BYTE *__cil_tmp18___25 ;
  OPJ_UINT32 val2___4 ;
  OPJ_BYTE *__cil_tmp20___32 ;
  OPJ_UINT32 val3___3 ;
  OPJ_BYTE *__cil_tmp22___26 ;

  {
#line 980
  i___110 = (OPJ_SIZE_T )0;
  {
#line 980
  while (1) {
    while_continue: /* CIL Label */ ;

#line 980
    if (! (i___110 < (length___14 & 0xfffffffffffffffcUL))) {
#line 980
      goto while_break;
    }
#line 981
    __cil_tmp6___41 = pSrc___14;
#line 981
    pSrc___14 ++;
#line 981
    val0___3 = (OPJ_UINT32 )*__cil_tmp6___41;
#line 982
    __cil_tmp8___59 = pSrc___14;
#line 982
    pSrc___14 ++;
#line 982
    val1___3 = (OPJ_UINT32 )*__cil_tmp8___59;
#line 983
    __cil_tmp10___30 = pSrc___14;
#line 983
    pSrc___14 ++;
#line 983
    val2___3 = (OPJ_UINT32 )*__cil_tmp10___30;
#line 984
    __cil_tmp12___36 = pSrc___14;
#line 984
    pSrc___14 ++;
#line 984
    val3___2 = (OPJ_UINT32 )*__cil_tmp12___36;
#line 985
    __cil_tmp14___49 = pSrc___14;
#line 985
    pSrc___14 ++;
#line 985
    val4___2 = (OPJ_UINT32 )*__cil_tmp14___49;
#line 987
    *(pDst___14 + i___110) = (OPJ_INT32 )((val0___3 << 2) | (val1___3 >> 6));
#line 988
    *(pDst___14 + (i___110 + 1UL)) = (OPJ_INT32 )(((val1___3 & 63U) << 4) | (val2___3 >> 4));
#line 989
    *(pDst___14 + (i___110 + 2UL)) = (OPJ_INT32 )(((val2___3 & 15U) << 6) | (val3___2 >> 2));
#line 990
    *(pDst___14 + (i___110 + 3UL)) = (OPJ_INT32 )(((val3___2 & 3U) << 8) | val4___2);
#line 980
    i___110 += 4UL;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 993
  if (length___14 & 3UL) {
#line 994
    __cil_tmp16___33 = pSrc___14;
#line 994
    pSrc___14 ++;
#line 994
    val0___4 = (OPJ_UINT32 )*__cil_tmp16___33;
#line 995
    __cil_tmp18___25 = pSrc___14;
#line 995
    pSrc___14 ++;
#line 995
    val1___4 = (OPJ_UINT32 )*__cil_tmp18___25;
#line 996
    length___14 &= 3UL;
#line 997
    *(pDst___14 + i___110) = (OPJ_INT32 )((val0___4 << 2) | (val1___4 >> 6));
#line 999
    if (length___14 > 1UL) {
#line 1000
      __cil_tmp20___32 = pSrc___14;
#line 1000
      pSrc___14 ++;
#line 1000
      val2___4 = (OPJ_UINT32 )*__cil_tmp20___32;
#line 1001
      *(pDst___14 + (i___110 + 1UL)) = (OPJ_INT32 )(((val1___4 & 63U) << 4) | (val2___4 >> 4));
#line 1002
      if (length___14 > 2UL) {
#line 1003
        __cil_tmp22___26 = pSrc___14;
#line 1003
        pSrc___14 ++;
#line 1003
        val3___3 = (OPJ_UINT32 )*__cil_tmp22___26;
#line 1004
        *(pDst___14 + (i___110 + 2UL)) = (OPJ_INT32 )(((val2___4 & 15U) << 6) | (val3___3 >> 2));
      }
    }
  }
#line 1008
  return;
}
}
#line 1009 "/root/patron-new/39/src/bin/jp2/converttif.c"
static void tif_11uto32s(OPJ_BYTE *pSrc___15 , OPJ_INT32 *pDst___15 , OPJ_SIZE_T length___15 ) 
{ 
  OPJ_SIZE_T i___111 ;
  OPJ_UINT32 val0___5 ;
  OPJ_BYTE *__cil_tmp6___42 ;
  OPJ_UINT32 val1___5 ;
  OPJ_BYTE *__cil_tmp8___60 ;
  OPJ_UINT32 val2___5 ;
  OPJ_BYTE *__cil_tmp10___31 ;
  OPJ_UINT32 val3___4 ;
  OPJ_BYTE *__cil_tmp12___37 ;
  OPJ_UINT32 val4___3 ;
  OPJ_BYTE *__cil_tmp14___50 ;
  OPJ_UINT32 val5___1 ;
  OPJ_BYTE *__cil_tmp16___34 ;
  OPJ_UINT32 val6___1 ;
  OPJ_BYTE *__cil_tmp18___26 ;
  OPJ_UINT32 val7___0 ;
  OPJ_BYTE *__cil_tmp20___33 ;
  OPJ_UINT32 val8___0 ;
  OPJ_BYTE *__cil_tmp22___27 ;
  OPJ_UINT32 val9 ;
  OPJ_BYTE *__cil_tmp24___22 ;
  OPJ_UINT32 val10 ;
  OPJ_BYTE *__cil_tmp26___15 ;
  unsigned int val___3 ;
  int available___3 ;
  int needed___27 ;
  unsigned int dst___28 ;
  OPJ_BYTE *__cil_tmp31___14 ;
  OPJ_BYTE *__cil_tmp32___14 ;
  int needed___28 ;
  unsigned int dst___29 ;
  OPJ_BYTE *__cil_tmp35___13 ;
  OPJ_BYTE *__cil_tmp36___11 ;
  int needed___29 ;
  unsigned int dst___30 ;
  OPJ_BYTE *__cil_tmp39___7 ;
  OPJ_BYTE *__cil_tmp40___8 ;
  int needed___30 ;
  unsigned int dst___31 ;
  OPJ_BYTE *__cil_tmp43___5 ;
  OPJ_BYTE *__cil_tmp44___5 ;
  int needed___31 ;
  unsigned int dst___32 ;
  OPJ_BYTE *__cil_tmp47___1 ;
  OPJ_BYTE *__cil_tmp48___2 ;
  int needed___32 ;
  unsigned int dst___33 ;
  OPJ_BYTE *__cil_tmp51___1 ;
  OPJ_BYTE *__cil_tmp52___1 ;
  int needed___33 ;
  unsigned int dst___34 ;
  OPJ_BYTE *__cil_tmp55___0 ;
  OPJ_BYTE *__cil_tmp56___0 ;

  {
#line 1013
  i___111 = (OPJ_SIZE_T )0;
  {
#line 1013
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1013
    if (! (i___111 < (length___15 & 0xfffffffffffffff8UL))) {
#line 1013
      goto while_break;
    }
#line 1014
    __cil_tmp6___42 = pSrc___15;
#line 1014
    pSrc___15 ++;
#line 1014
    val0___5 = (OPJ_UINT32 )*__cil_tmp6___42;
#line 1015
    __cil_tmp8___60 = pSrc___15;
#line 1015
    pSrc___15 ++;
#line 1015
    val1___5 = (OPJ_UINT32 )*__cil_tmp8___60;
#line 1016
    __cil_tmp10___31 = pSrc___15;
#line 1016
    pSrc___15 ++;
#line 1016
    val2___5 = (OPJ_UINT32 )*__cil_tmp10___31;
#line 1017
    __cil_tmp12___37 = pSrc___15;
#line 1017
    pSrc___15 ++;
#line 1017
    val3___4 = (OPJ_UINT32 )*__cil_tmp12___37;
#line 1018
    __cil_tmp14___50 = pSrc___15;
#line 1018
    pSrc___15 ++;
#line 1018
    val4___3 = (OPJ_UINT32 )*__cil_tmp14___50;
#line 1019
    __cil_tmp16___34 = pSrc___15;
#line 1019
    pSrc___15 ++;
#line 1019
    val5___1 = (OPJ_UINT32 )*__cil_tmp16___34;
#line 1020
    __cil_tmp18___26 = pSrc___15;
#line 1020
    pSrc___15 ++;
#line 1020
    val6___1 = (OPJ_UINT32 )*__cil_tmp18___26;
#line 1021
    __cil_tmp20___33 = pSrc___15;
#line 1021
    pSrc___15 ++;
#line 1021
    val7___0 = (OPJ_UINT32 )*__cil_tmp20___33;
#line 1022
    __cil_tmp22___27 = pSrc___15;
#line 1022
    pSrc___15 ++;
#line 1022
    val8___0 = (OPJ_UINT32 )*__cil_tmp22___27;
#line 1023
    __cil_tmp24___22 = pSrc___15;
#line 1023
    pSrc___15 ++;
#line 1023
    val9 = (OPJ_UINT32 )*__cil_tmp24___22;
#line 1024
    __cil_tmp26___15 = pSrc___15;
#line 1024
    pSrc___15 ++;
#line 1024
    val10 = (OPJ_UINT32 )*__cil_tmp26___15;
#line 1026
    *(pDst___15 + i___111) = (OPJ_INT32 )((val0___5 << 3) | (val1___5 >> 5));
#line 1027
    *(pDst___15 + (i___111 + 1UL)) = (OPJ_INT32 )(((val1___5 & 31U) << 6) | (val2___5 >> 2));
#line 1028
    *(pDst___15 + (i___111 + 2UL)) = (OPJ_INT32 )((((val2___5 & 3U) << 9) | (val3___4 << 1)) | (val4___3 >> 7));
#line 1029
    *(pDst___15 + (i___111 + 3UL)) = (OPJ_INT32 )(((val4___3 & 127U) << 4) | (val5___1 >> 4));
#line 1030
    *(pDst___15 + (i___111 + 4UL)) = (OPJ_INT32 )(((val5___1 & 15U) << 7) | (val6___1 >> 1));
#line 1031
    *(pDst___15 + (i___111 + 5UL)) = (OPJ_INT32 )((((val6___1 & 1U) << 10) | (val7___0 << 2)) | (val8___0 >> 6));
#line 1032
    *(pDst___15 + (i___111 + 6UL)) = (OPJ_INT32 )(((val8___0 & 63U) << 5) | (val9 >> 3));
#line 1033
    *(pDst___15 + (i___111 + 7UL)) = (OPJ_INT32 )(((val9 & 7U) << 8) | val10);
#line 1013
    i___111 += 8UL;
  }
  while_break___7: /* CIL Label */ ;
  }

  while_break: ;
#line 1036
  if (length___15 & 7UL) {
#line 1038
    available___3 = 0;
#line 1040
    length___15 &= 7UL;
#line 1042
    needed___27 = 11;
#line 1042
    dst___28 = 0U;
#line 1042
    if (available___3 == 0) {
#line 1042
      __cil_tmp31___14 = pSrc___15;
#line 1042
      pSrc___15 ++;
#line 1042
      val___3 = (unsigned int )*__cil_tmp31___14;
#line 1042
      available___3 = 8;
    }
    {
#line 1042
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1042
      if (! (needed___27 > available___3)) {
#line 1042
        goto while_break___0;
      }
#line 1042
      dst___28 |= val___3 & ((1U << available___3) - 1U);
#line 1042
      needed___27 -= available___3;
#line 1042
      dst___28 <<= needed___27;
#line 1042
      __cil_tmp32___14 = pSrc___15;
#line 1042
      pSrc___15 ++;
#line 1042
      val___3 = (unsigned int )*__cil_tmp32___14;
#line 1042
      available___3 = 8;
    }
    while_break___8: /* CIL Label */ ;
    }

    while_break___0: 
#line 1042
    dst___28 |= (val___3 >> (available___3 - needed___27)) & ((1U << needed___27) - 1U);
#line 1042
    available___3 -= needed___27;
#line 1042
    *(pDst___15 + i___111) = (OPJ_INT32 )dst___28;
#line 1044
    if (length___15 > 1UL) {
#line 1045
      needed___28 = 11;
#line 1045
      dst___29 = 0U;
#line 1045
      if (available___3 == 0) {
#line 1045
        __cil_tmp35___13 = pSrc___15;
#line 1045
        pSrc___15 ++;
#line 1045
        val___3 = (unsigned int )*__cil_tmp35___13;
#line 1045
        available___3 = 8;
      }
      {
#line 1045
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 1045
        if (! (needed___28 > available___3)) {
#line 1045
          goto while_break___1;
        }
#line 1045
        dst___29 |= val___3 & ((1U << available___3) - 1U);
#line 1045
        needed___28 -= available___3;
#line 1045
        dst___29 <<= needed___28;
#line 1045
        __cil_tmp36___11 = pSrc___15;
#line 1045
        pSrc___15 ++;
#line 1045
        val___3 = (unsigned int )*__cil_tmp36___11;
#line 1045
        available___3 = 8;
      }
      while_break___9: /* CIL Label */ ;
      }

      while_break___1: 
#line 1045
      dst___29 |= (val___3 >> (available___3 - needed___28)) & ((1U << needed___28) - 1U);
#line 1045
      available___3 -= needed___28;
#line 1045
      *(pDst___15 + (i___111 + 1UL)) = (OPJ_INT32 )dst___29;
#line 1046
      if (length___15 > 2UL) {
#line 1047
        needed___29 = 11;
#line 1047
        dst___30 = 0U;
#line 1047
        if (available___3 == 0) {
#line 1047
          __cil_tmp39___7 = pSrc___15;
#line 1047
          pSrc___15 ++;
#line 1047
          val___3 = (unsigned int )*__cil_tmp39___7;
#line 1047
          available___3 = 8;
        }
        {
#line 1047
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 1047
          if (! (needed___29 > available___3)) {
#line 1047
            goto while_break___2;
          }
#line 1047
          dst___30 |= val___3 & ((1U << available___3) - 1U);
#line 1047
          needed___29 -= available___3;
#line 1047
          dst___30 <<= needed___29;
#line 1047
          __cil_tmp40___8 = pSrc___15;
#line 1047
          pSrc___15 ++;
#line 1047
          val___3 = (unsigned int )*__cil_tmp40___8;
#line 1047
          available___3 = 8;
        }
        while_break___10: /* CIL Label */ ;
        }

        while_break___2: 
#line 1047
        dst___30 |= (val___3 >> (available___3 - needed___29)) & ((1U << needed___29) - 1U);
#line 1047
        available___3 -= needed___29;
#line 1047
        *(pDst___15 + (i___111 + 2UL)) = (OPJ_INT32 )dst___30;
#line 1048
        if (length___15 > 3UL) {
#line 1049
          needed___30 = 11;
#line 1049
          dst___31 = 0U;
#line 1049
          if (available___3 == 0) {
#line 1049
            __cil_tmp43___5 = pSrc___15;
#line 1049
            pSrc___15 ++;
#line 1049
            val___3 = (unsigned int )*__cil_tmp43___5;
#line 1049
            available___3 = 8;
          }
          {
#line 1049
          while (1) {
            while_continue___3: /* CIL Label */ ;

#line 1049
            if (! (needed___30 > available___3)) {
#line 1049
              goto while_break___3;
            }
#line 1049
            dst___31 |= val___3 & ((1U << available___3) - 1U);
#line 1049
            needed___30 -= available___3;
#line 1049
            dst___31 <<= needed___30;
#line 1049
            __cil_tmp44___5 = pSrc___15;
#line 1049
            pSrc___15 ++;
#line 1049
            val___3 = (unsigned int )*__cil_tmp44___5;
#line 1049
            available___3 = 8;
          }
          while_break___11: /* CIL Label */ ;
          }

          while_break___3: 
#line 1049
          dst___31 |= (val___3 >> (available___3 - needed___30)) & ((1U << needed___30) - 1U);
#line 1049
          available___3 -= needed___30;
#line 1049
          *(pDst___15 + (i___111 + 3UL)) = (OPJ_INT32 )dst___31;
#line 1050
          if (length___15 > 4UL) {
#line 1051
            needed___31 = 11;
#line 1051
            dst___32 = 0U;
#line 1051
            if (available___3 == 0) {
#line 1051
              __cil_tmp47___1 = pSrc___15;
#line 1051
              pSrc___15 ++;
#line 1051
              val___3 = (unsigned int )*__cil_tmp47___1;
#line 1051
              available___3 = 8;
            }
            {
#line 1051
            while (1) {
              while_continue___4: /* CIL Label */ ;

#line 1051
              if (! (needed___31 > available___3)) {
#line 1051
                goto while_break___4;
              }
#line 1051
              dst___32 |= val___3 & ((1U << available___3) - 1U);
#line 1051
              needed___31 -= available___3;
#line 1051
              dst___32 <<= needed___31;
#line 1051
              __cil_tmp48___2 = pSrc___15;
#line 1051
              pSrc___15 ++;
#line 1051
              val___3 = (unsigned int )*__cil_tmp48___2;
#line 1051
              available___3 = 8;
            }
            while_break___12: /* CIL Label */ ;
            }

            while_break___4: 
#line 1051
            dst___32 |= (val___3 >> (available___3 - needed___31)) & ((1U << needed___31) - 1U);
#line 1051
            available___3 -= needed___31;
#line 1051
            *(pDst___15 + (i___111 + 4UL)) = (OPJ_INT32 )dst___32;
#line 1052
            if (length___15 > 5UL) {
#line 1053
              needed___32 = 11;
#line 1053
              dst___33 = 0U;
#line 1053
              if (available___3 == 0) {
#line 1053
                __cil_tmp51___1 = pSrc___15;
#line 1053
                pSrc___15 ++;
#line 1053
                val___3 = (unsigned int )*__cil_tmp51___1;
#line 1053
                available___3 = 8;
              }
              {
#line 1053
              while (1) {
                while_continue___5: /* CIL Label */ ;

#line 1053
                if (! (needed___32 > available___3)) {
#line 1053
                  goto while_break___5;
                }
#line 1053
                dst___33 |= val___3 & ((1U << available___3) - 1U);
#line 1053
                needed___32 -= available___3;
#line 1053
                dst___33 <<= needed___32;
#line 1053
                __cil_tmp52___1 = pSrc___15;
#line 1053
                pSrc___15 ++;
#line 1053
                val___3 = (unsigned int )*__cil_tmp52___1;
#line 1053
                available___3 = 8;
              }
              while_break___13: /* CIL Label */ ;
              }

              while_break___5: 
#line 1053
              dst___33 |= (val___3 >> (available___3 - needed___32)) & ((1U << needed___32) - 1U);
#line 1053
              available___3 -= needed___32;
#line 1053
              *(pDst___15 + (i___111 + 5UL)) = (OPJ_INT32 )dst___33;
#line 1054
              if (length___15 > 6UL) {
#line 1055
                needed___33 = 11;
#line 1055
                dst___34 = 0U;
#line 1055
                if (available___3 == 0) {
#line 1055
                  __cil_tmp55___0 = pSrc___15;
#line 1055
                  pSrc___15 ++;
#line 1055
                  val___3 = (unsigned int )*__cil_tmp55___0;
#line 1055
                  available___3 = 8;
                }
                {
#line 1055
                while (1) {
                  while_continue___6: /* CIL Label */ ;

#line 1055
                  if (! (needed___33 > available___3)) {
#line 1055
                    goto while_break___6;
                  }
#line 1055
                  dst___34 |= val___3 & ((1U << available___3) - 1U);
#line 1055
                  needed___33 -= available___3;
#line 1055
                  dst___34 <<= needed___33;
#line 1055
                  __cil_tmp56___0 = pSrc___15;
#line 1055
                  pSrc___15 ++;
#line 1055
                  val___3 = (unsigned int )*__cil_tmp56___0;
#line 1055
                  available___3 = 8;
                }
                while_break___14: /* CIL Label */ ;
                }

                while_break___6: 
#line 1055
                dst___34 |= (val___3 >> (available___3 - needed___33)) & ((1U << needed___33) - 1U);
#line 1055
                available___3 -= needed___33;
#line 1055
                *(pDst___15 + (i___111 + 6UL)) = (OPJ_INT32 )dst___34;
              }
            }
          }
        }
      }
    }
  }
#line 1063
  return;
}
}
#line 1064 "/root/patron-new/39/src/bin/jp2/converttif.c"
static void tif_12uto32s(OPJ_BYTE *pSrc___16 , OPJ_INT32 *pDst___16 , OPJ_SIZE_T length___16 ) 
{ 
  OPJ_SIZE_T i___112 ;
  OPJ_UINT32 val0___6 ;
  OPJ_BYTE *__cil_tmp6___43 ;
  OPJ_UINT32 val1___6 ;
  OPJ_BYTE *__cil_tmp8___61 ;
  OPJ_UINT32 val2___6 ;
  OPJ_BYTE *__cil_tmp10___32 ;
  OPJ_UINT32 val0___7 ;
  OPJ_BYTE *__cil_tmp12___38 ;
  OPJ_UINT32 val1___7 ;
  OPJ_BYTE *__cil_tmp14___51 ;

  {
#line 1068
  i___112 = (OPJ_SIZE_T )0;
  {
#line 1068
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1068
    if (! (i___112 < (length___16 & 0xfffffffffffffffeUL))) {
#line 1068
      goto while_break;
    }
#line 1069
    __cil_tmp6___43 = pSrc___16;
#line 1069
    pSrc___16 ++;
#line 1069
    val0___6 = (OPJ_UINT32 )*__cil_tmp6___43;
#line 1070
    __cil_tmp8___61 = pSrc___16;
#line 1070
    pSrc___16 ++;
#line 1070
    val1___6 = (OPJ_UINT32 )*__cil_tmp8___61;
#line 1071
    __cil_tmp10___32 = pSrc___16;
#line 1071
    pSrc___16 ++;
#line 1071
    val2___6 = (OPJ_UINT32 )*__cil_tmp10___32;
#line 1073
    *(pDst___16 + i___112) = (OPJ_INT32 )((val0___6 << 4) | (val1___6 >> 4));
#line 1074
    *(pDst___16 + (i___112 + 1UL)) = (OPJ_INT32 )(((val1___6 & 15U) << 8) | val2___6);
#line 1068
    i___112 += 2UL;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 1076
  if (length___16 & 1UL) {
#line 1077
    __cil_tmp12___38 = pSrc___16;
#line 1077
    pSrc___16 ++;
#line 1077
    val0___7 = (OPJ_UINT32 )*__cil_tmp12___38;
#line 1078
    __cil_tmp14___51 = pSrc___16;
#line 1078
    pSrc___16 ++;
#line 1078
    val1___7 = (OPJ_UINT32 )*__cil_tmp14___51;
#line 1079
    *(pDst___16 + i___112) = (OPJ_INT32 )((val0___7 << 4) | (val1___7 >> 4));
  }
#line 1081
  return;
}
}
#line 1082 "/root/patron-new/39/src/bin/jp2/converttif.c"
static void tif_13uto32s(OPJ_BYTE *pSrc___17 , OPJ_INT32 *pDst___17 , OPJ_SIZE_T length___17 ) 
{ 
  OPJ_SIZE_T i___113 ;
  OPJ_UINT32 val0___8 ;
  OPJ_BYTE *__cil_tmp6___44 ;
  OPJ_UINT32 val1___8 ;
  OPJ_BYTE *__cil_tmp8___62 ;
  OPJ_UINT32 val2___7 ;
  OPJ_BYTE *__cil_tmp10___33 ;
  OPJ_UINT32 val3___5 ;
  OPJ_BYTE *__cil_tmp12___39 ;
  OPJ_UINT32 val4___4 ;
  OPJ_BYTE *__cil_tmp14___52 ;
  OPJ_UINT32 val5___2 ;
  OPJ_BYTE *__cil_tmp16___35 ;
  OPJ_UINT32 val6___2 ;
  OPJ_BYTE *__cil_tmp18___27 ;
  OPJ_UINT32 val7___1 ;
  OPJ_BYTE *__cil_tmp20___34 ;
  OPJ_UINT32 val8___1 ;
  OPJ_BYTE *__cil_tmp22___28 ;
  OPJ_UINT32 val9___0 ;
  OPJ_BYTE *__cil_tmp24___23 ;
  OPJ_UINT32 val10___0 ;
  OPJ_BYTE *__cil_tmp26___16 ;
  OPJ_UINT32 val11 ;
  OPJ_BYTE *__cil_tmp28___15 ;
  OPJ_UINT32 val12 ;
  OPJ_BYTE *__cil_tmp30___9 ;
  unsigned int val___4 ;
  int available___4 ;
  int needed___34 ;
  unsigned int dst___35 ;
  OPJ_BYTE *__cil_tmp35___14 ;
  OPJ_BYTE *__cil_tmp36___12 ;
  int needed___35 ;
  unsigned int dst___36 ;
  OPJ_BYTE *__cil_tmp39___8 ;
  OPJ_BYTE *__cil_tmp40___9 ;
  int needed___36 ;
  unsigned int dst___37 ;
  OPJ_BYTE *__cil_tmp43___6 ;
  OPJ_BYTE *__cil_tmp44___6 ;
  int needed___37 ;
  unsigned int dst___38 ;
  OPJ_BYTE *__cil_tmp47___2 ;
  OPJ_BYTE *__cil_tmp48___3 ;
  int needed___38 ;
  unsigned int dst___39 ;
  OPJ_BYTE *__cil_tmp51___2 ;
  OPJ_BYTE *__cil_tmp52___2 ;
  int needed___39 ;
  unsigned int dst___40 ;
  OPJ_BYTE *__cil_tmp55___1 ;
  OPJ_BYTE *__cil_tmp56___1 ;
  int needed___40 ;
  unsigned int dst___41 ;
  OPJ_BYTE *__cil_tmp59___0 ;
  OPJ_BYTE *__cil_tmp60 ;

  {
#line 1086
  i___113 = (OPJ_SIZE_T )0;
  {
#line 1086
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1086
    if (! (i___113 < (length___17 & 0xfffffffffffffff8UL))) {
#line 1086
      goto while_break;
    }
#line 1087
    __cil_tmp6___44 = pSrc___17;
#line 1087
    pSrc___17 ++;
#line 1087
    val0___8 = (OPJ_UINT32 )*__cil_tmp6___44;
#line 1088
    __cil_tmp8___62 = pSrc___17;
#line 1088
    pSrc___17 ++;
#line 1088
    val1___8 = (OPJ_UINT32 )*__cil_tmp8___62;
#line 1089
    __cil_tmp10___33 = pSrc___17;
#line 1089
    pSrc___17 ++;
#line 1089
    val2___7 = (OPJ_UINT32 )*__cil_tmp10___33;
#line 1090
    __cil_tmp12___39 = pSrc___17;
#line 1090
    pSrc___17 ++;
#line 1090
    val3___5 = (OPJ_UINT32 )*__cil_tmp12___39;
#line 1091
    __cil_tmp14___52 = pSrc___17;
#line 1091
    pSrc___17 ++;
#line 1091
    val4___4 = (OPJ_UINT32 )*__cil_tmp14___52;
#line 1092
    __cil_tmp16___35 = pSrc___17;
#line 1092
    pSrc___17 ++;
#line 1092
    val5___2 = (OPJ_UINT32 )*__cil_tmp16___35;
#line 1093
    __cil_tmp18___27 = pSrc___17;
#line 1093
    pSrc___17 ++;
#line 1093
    val6___2 = (OPJ_UINT32 )*__cil_tmp18___27;
#line 1094
    __cil_tmp20___34 = pSrc___17;
#line 1094
    pSrc___17 ++;
#line 1094
    val7___1 = (OPJ_UINT32 )*__cil_tmp20___34;
#line 1095
    __cil_tmp22___28 = pSrc___17;
#line 1095
    pSrc___17 ++;
#line 1095
    val8___1 = (OPJ_UINT32 )*__cil_tmp22___28;
#line 1096
    __cil_tmp24___23 = pSrc___17;
#line 1096
    pSrc___17 ++;
#line 1096
    val9___0 = (OPJ_UINT32 )*__cil_tmp24___23;
#line 1097
    __cil_tmp26___16 = pSrc___17;
#line 1097
    pSrc___17 ++;
#line 1097
    val10___0 = (OPJ_UINT32 )*__cil_tmp26___16;
#line 1098
    __cil_tmp28___15 = pSrc___17;
#line 1098
    pSrc___17 ++;
#line 1098
    val11 = (OPJ_UINT32 )*__cil_tmp28___15;
#line 1099
    __cil_tmp30___9 = pSrc___17;
#line 1099
    pSrc___17 ++;
#line 1099
    val12 = (OPJ_UINT32 )*__cil_tmp30___9;
#line 1101
    *(pDst___17 + i___113) = (OPJ_INT32 )((val0___8 << 5) | (val1___8 >> 3));
#line 1102
    *(pDst___17 + (i___113 + 1UL)) = (OPJ_INT32 )((((val1___8 & 7U) << 10) | (val2___7 << 2)) | (val3___5 >> 6));
#line 1103
    *(pDst___17 + (i___113 + 2UL)) = (OPJ_INT32 )(((val3___5 & 63U) << 7) | (val4___4 >> 1));
#line 1104
    *(pDst___17 + (i___113 + 3UL)) = (OPJ_INT32 )((((val4___4 & 1U) << 12) | (val5___2 << 4)) | (val6___2 >> 4));
#line 1105
    *(pDst___17 + (i___113 + 4UL)) = (OPJ_INT32 )((((val6___2 & 15U) << 9) | (val7___1 << 1)) | (val8___1 >> 7));
#line 1106
    *(pDst___17 + (i___113 + 5UL)) = (OPJ_INT32 )(((val8___1 & 127U) << 6) | (val9___0 >> 2));
#line 1107
    *(pDst___17 + (i___113 + 6UL)) = (OPJ_INT32 )((((val9___0 & 3U) << 11) | (val10___0 << 3)) | (val11 >> 5));
#line 1108
    *(pDst___17 + (i___113 + 7UL)) = (OPJ_INT32 )(((val11 & 31U) << 8) | val12);
#line 1086
    i___113 += 8UL;
  }
  while_break___7: /* CIL Label */ ;
  }

  while_break: ;
#line 1111
  if (length___17 & 7UL) {
#line 1113
    available___4 = 0;
#line 1115
    length___17 &= 7UL;
#line 1117
    needed___34 = 13;
#line 1117
    dst___35 = 0U;
#line 1117
    if (available___4 == 0) {
#line 1117
      __cil_tmp35___14 = pSrc___17;
#line 1117
      pSrc___17 ++;
#line 1117
      val___4 = (unsigned int )*__cil_tmp35___14;
#line 1117
      available___4 = 8;
    }
    {
#line 1117
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1117
      if (! (needed___34 > available___4)) {
#line 1117
        goto while_break___0;
      }
#line 1117
      dst___35 |= val___4 & ((1U << available___4) - 1U);
#line 1117
      needed___34 -= available___4;
#line 1117
      dst___35 <<= needed___34;
#line 1117
      __cil_tmp36___12 = pSrc___17;
#line 1117
      pSrc___17 ++;
#line 1117
      val___4 = (unsigned int )*__cil_tmp36___12;
#line 1117
      available___4 = 8;
    }
    while_break___8: /* CIL Label */ ;
    }

    while_break___0: 
#line 1117
    dst___35 |= (val___4 >> (available___4 - needed___34)) & ((1U << needed___34) - 1U);
#line 1117
    available___4 -= needed___34;
#line 1117
    *(pDst___17 + i___113) = (OPJ_INT32 )dst___35;
#line 1119
    if (length___17 > 1UL) {
#line 1120
      needed___35 = 13;
#line 1120
      dst___36 = 0U;
#line 1120
      if (available___4 == 0) {
#line 1120
        __cil_tmp39___8 = pSrc___17;
#line 1120
        pSrc___17 ++;
#line 1120
        val___4 = (unsigned int )*__cil_tmp39___8;
#line 1120
        available___4 = 8;
      }
      {
#line 1120
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 1120
        if (! (needed___35 > available___4)) {
#line 1120
          goto while_break___1;
        }
#line 1120
        dst___36 |= val___4 & ((1U << available___4) - 1U);
#line 1120
        needed___35 -= available___4;
#line 1120
        dst___36 <<= needed___35;
#line 1120
        __cil_tmp40___9 = pSrc___17;
#line 1120
        pSrc___17 ++;
#line 1120
        val___4 = (unsigned int )*__cil_tmp40___9;
#line 1120
        available___4 = 8;
      }
      while_break___9: /* CIL Label */ ;
      }

      while_break___1: 
#line 1120
      dst___36 |= (val___4 >> (available___4 - needed___35)) & ((1U << needed___35) - 1U);
#line 1120
      available___4 -= needed___35;
#line 1120
      *(pDst___17 + (i___113 + 1UL)) = (OPJ_INT32 )dst___36;
#line 1121
      if (length___17 > 2UL) {
#line 1122
        needed___36 = 13;
#line 1122
        dst___37 = 0U;
#line 1122
        if (available___4 == 0) {
#line 1122
          __cil_tmp43___6 = pSrc___17;
#line 1122
          pSrc___17 ++;
#line 1122
          val___4 = (unsigned int )*__cil_tmp43___6;
#line 1122
          available___4 = 8;
        }
        {
#line 1122
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 1122
          if (! (needed___36 > available___4)) {
#line 1122
            goto while_break___2;
          }
#line 1122
          dst___37 |= val___4 & ((1U << available___4) - 1U);
#line 1122
          needed___36 -= available___4;
#line 1122
          dst___37 <<= needed___36;
#line 1122
          __cil_tmp44___6 = pSrc___17;
#line 1122
          pSrc___17 ++;
#line 1122
          val___4 = (unsigned int )*__cil_tmp44___6;
#line 1122
          available___4 = 8;
        }
        while_break___10: /* CIL Label */ ;
        }

        while_break___2: 
#line 1122
        dst___37 |= (val___4 >> (available___4 - needed___36)) & ((1U << needed___36) - 1U);
#line 1122
        available___4 -= needed___36;
#line 1122
        *(pDst___17 + (i___113 + 2UL)) = (OPJ_INT32 )dst___37;
#line 1123
        if (length___17 > 3UL) {
#line 1124
          needed___37 = 13;
#line 1124
          dst___38 = 0U;
#line 1124
          if (available___4 == 0) {
#line 1124
            __cil_tmp47___2 = pSrc___17;
#line 1124
            pSrc___17 ++;
#line 1124
            val___4 = (unsigned int )*__cil_tmp47___2;
#line 1124
            available___4 = 8;
          }
          {
#line 1124
          while (1) {
            while_continue___3: /* CIL Label */ ;

#line 1124
            if (! (needed___37 > available___4)) {
#line 1124
              goto while_break___3;
            }
#line 1124
            dst___38 |= val___4 & ((1U << available___4) - 1U);
#line 1124
            needed___37 -= available___4;
#line 1124
            dst___38 <<= needed___37;
#line 1124
            __cil_tmp48___3 = pSrc___17;
#line 1124
            pSrc___17 ++;
#line 1124
            val___4 = (unsigned int )*__cil_tmp48___3;
#line 1124
            available___4 = 8;
          }
          while_break___11: /* CIL Label */ ;
          }

          while_break___3: 
#line 1124
          dst___38 |= (val___4 >> (available___4 - needed___37)) & ((1U << needed___37) - 1U);
#line 1124
          available___4 -= needed___37;
#line 1124
          *(pDst___17 + (i___113 + 3UL)) = (OPJ_INT32 )dst___38;
#line 1125
          if (length___17 > 4UL) {
#line 1126
            needed___38 = 13;
#line 1126
            dst___39 = 0U;
#line 1126
            if (available___4 == 0) {
#line 1126
              __cil_tmp51___2 = pSrc___17;
#line 1126
              pSrc___17 ++;
#line 1126
              val___4 = (unsigned int )*__cil_tmp51___2;
#line 1126
              available___4 = 8;
            }
            {
#line 1126
            while (1) {
              while_continue___4: /* CIL Label */ ;

#line 1126
              if (! (needed___38 > available___4)) {
#line 1126
                goto while_break___4;
              }
#line 1126
              dst___39 |= val___4 & ((1U << available___4) - 1U);
#line 1126
              needed___38 -= available___4;
#line 1126
              dst___39 <<= needed___38;
#line 1126
              __cil_tmp52___2 = pSrc___17;
#line 1126
              pSrc___17 ++;
#line 1126
              val___4 = (unsigned int )*__cil_tmp52___2;
#line 1126
              available___4 = 8;
            }
            while_break___12: /* CIL Label */ ;
            }

            while_break___4: 
#line 1126
            dst___39 |= (val___4 >> (available___4 - needed___38)) & ((1U << needed___38) - 1U);
#line 1126
            available___4 -= needed___38;
#line 1126
            *(pDst___17 + (i___113 + 4UL)) = (OPJ_INT32 )dst___39;
#line 1127
            if (length___17 > 5UL) {
#line 1128
              needed___39 = 13;
#line 1128
              dst___40 = 0U;
#line 1128
              if (available___4 == 0) {
#line 1128
                __cil_tmp55___1 = pSrc___17;
#line 1128
                pSrc___17 ++;
#line 1128
                val___4 = (unsigned int )*__cil_tmp55___1;
#line 1128
                available___4 = 8;
              }
              {
#line 1128
              while (1) {
                while_continue___5: /* CIL Label */ ;

#line 1128
                if (! (needed___39 > available___4)) {
#line 1128
                  goto while_break___5;
                }
#line 1128
                dst___40 |= val___4 & ((1U << available___4) - 1U);
#line 1128
                needed___39 -= available___4;
#line 1128
                dst___40 <<= needed___39;
#line 1128
                __cil_tmp56___1 = pSrc___17;
#line 1128
                pSrc___17 ++;
#line 1128
                val___4 = (unsigned int )*__cil_tmp56___1;
#line 1128
                available___4 = 8;
              }
              while_break___13: /* CIL Label */ ;
              }

              while_break___5: 
#line 1128
              dst___40 |= (val___4 >> (available___4 - needed___39)) & ((1U << needed___39) - 1U);
#line 1128
              available___4 -= needed___39;
#line 1128
              *(pDst___17 + (i___113 + 5UL)) = (OPJ_INT32 )dst___40;
#line 1129
              if (length___17 > 6UL) {
#line 1130
                needed___40 = 13;
#line 1130
                dst___41 = 0U;
#line 1130
                if (available___4 == 0) {
#line 1130
                  __cil_tmp59___0 = pSrc___17;
#line 1130
                  pSrc___17 ++;
#line 1130
                  val___4 = (unsigned int )*__cil_tmp59___0;
#line 1130
                  available___4 = 8;
                }
                {
#line 1130
                while (1) {
                  while_continue___6: /* CIL Label */ ;

#line 1130
                  if (! (needed___40 > available___4)) {
#line 1130
                    goto while_break___6;
                  }
#line 1130
                  dst___41 |= val___4 & ((1U << available___4) - 1U);
#line 1130
                  needed___40 -= available___4;
#line 1130
                  dst___41 <<= needed___40;
#line 1130
                  __cil_tmp60 = pSrc___17;
#line 1130
                  pSrc___17 ++;
#line 1130
                  val___4 = (unsigned int )*__cil_tmp60;
#line 1130
                  available___4 = 8;
                }
                while_break___14: /* CIL Label */ ;
                }

                while_break___6: 
#line 1130
                dst___41 |= (val___4 >> (available___4 - needed___40)) & ((1U << needed___40) - 1U);
#line 1130
                available___4 -= needed___40;
#line 1130
                *(pDst___17 + (i___113 + 6UL)) = (OPJ_INT32 )dst___41;
              }
            }
          }
        }
      }
    }
  }
#line 1138
  return;
}
}
#line 1139 "/root/patron-new/39/src/bin/jp2/converttif.c"
static void tif_14uto32s(OPJ_BYTE *pSrc___18 , OPJ_INT32 *pDst___18 , OPJ_SIZE_T length___18 ) 
{ 
  OPJ_SIZE_T i___114 ;
  OPJ_UINT32 val0___9 ;
  OPJ_BYTE *__cil_tmp6___45 ;
  OPJ_UINT32 val1___9 ;
  OPJ_BYTE *__cil_tmp8___63 ;
  OPJ_UINT32 val2___8 ;
  OPJ_BYTE *__cil_tmp10___34 ;
  OPJ_UINT32 val3___6 ;
  OPJ_BYTE *__cil_tmp12___40 ;
  OPJ_UINT32 val4___5 ;
  OPJ_BYTE *__cil_tmp14___53 ;
  OPJ_UINT32 val5___3 ;
  OPJ_BYTE *__cil_tmp16___36 ;
  OPJ_UINT32 val6___3 ;
  OPJ_BYTE *__cil_tmp18___28 ;
  OPJ_UINT32 val0___10 ;
  OPJ_BYTE *__cil_tmp20___35 ;
  OPJ_UINT32 val1___10 ;
  OPJ_BYTE *__cil_tmp22___29 ;
  OPJ_UINT32 val2___9 ;
  OPJ_BYTE *__cil_tmp24___24 ;
  OPJ_UINT32 val3___7 ;
  OPJ_BYTE *__cil_tmp26___17 ;
  OPJ_UINT32 val4___6 ;
  OPJ_BYTE *__cil_tmp28___16 ;
  OPJ_UINT32 val5___4 ;
  OPJ_BYTE *__cil_tmp30___10 ;

  {
#line 1143
  i___114 = (OPJ_SIZE_T )0;
  {
#line 1143
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1143
    if (! (i___114 < (length___18 & 0xfffffffffffffffcUL))) {
#line 1143
      goto while_break;
    }
#line 1144
    __cil_tmp6___45 = pSrc___18;
#line 1144
    pSrc___18 ++;
#line 1144
    val0___9 = (OPJ_UINT32 )*__cil_tmp6___45;
#line 1145
    __cil_tmp8___63 = pSrc___18;
#line 1145
    pSrc___18 ++;
#line 1145
    val1___9 = (OPJ_UINT32 )*__cil_tmp8___63;
#line 1146
    __cil_tmp10___34 = pSrc___18;
#line 1146
    pSrc___18 ++;
#line 1146
    val2___8 = (OPJ_UINT32 )*__cil_tmp10___34;
#line 1147
    __cil_tmp12___40 = pSrc___18;
#line 1147
    pSrc___18 ++;
#line 1147
    val3___6 = (OPJ_UINT32 )*__cil_tmp12___40;
#line 1148
    __cil_tmp14___53 = pSrc___18;
#line 1148
    pSrc___18 ++;
#line 1148
    val4___5 = (OPJ_UINT32 )*__cil_tmp14___53;
#line 1149
    __cil_tmp16___36 = pSrc___18;
#line 1149
    pSrc___18 ++;
#line 1149
    val5___3 = (OPJ_UINT32 )*__cil_tmp16___36;
#line 1150
    __cil_tmp18___28 = pSrc___18;
#line 1150
    pSrc___18 ++;
#line 1150
    val6___3 = (OPJ_UINT32 )*__cil_tmp18___28;
#line 1152
    *(pDst___18 + i___114) = (OPJ_INT32 )((val0___9 << 6) | (val1___9 >> 2));
#line 1153
    *(pDst___18 + (i___114 + 1UL)) = (OPJ_INT32 )((((val1___9 & 3U) << 12) | (val2___8 << 4)) | (val3___6 >> 4));
#line 1154
    *(pDst___18 + (i___114 + 2UL)) = (OPJ_INT32 )((((val3___6 & 15U) << 10) | (val4___5 << 2)) | (val5___3 >> 6));
#line 1155
    *(pDst___18 + (i___114 + 3UL)) = (OPJ_INT32 )(((val5___3 & 63U) << 8) | val6___3);
#line 1143
    i___114 += 4UL;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 1158
  if (length___18 & 3UL) {
#line 1159
    __cil_tmp20___35 = pSrc___18;
#line 1159
    pSrc___18 ++;
#line 1159
    val0___10 = (OPJ_UINT32 )*__cil_tmp20___35;
#line 1160
    __cil_tmp22___29 = pSrc___18;
#line 1160
    pSrc___18 ++;
#line 1160
    val1___10 = (OPJ_UINT32 )*__cil_tmp22___29;
#line 1161
    length___18 &= 3UL;
#line 1162
    *(pDst___18 + i___114) = (OPJ_INT32 )((val0___10 << 6) | (val1___10 >> 2));
#line 1164
    if (length___18 > 1UL) {
#line 1165
      __cil_tmp24___24 = pSrc___18;
#line 1165
      pSrc___18 ++;
#line 1165
      val2___9 = (OPJ_UINT32 )*__cil_tmp24___24;
#line 1166
      __cil_tmp26___17 = pSrc___18;
#line 1166
      pSrc___18 ++;
#line 1166
      val3___7 = (OPJ_UINT32 )*__cil_tmp26___17;
#line 1167
      *(pDst___18 + (i___114 + 1UL)) = (OPJ_INT32 )((((val1___10 & 3U) << 12) | (val2___9 << 4)) | (val3___7 >> 4));
#line 1168
      if (length___18 > 2UL) {
#line 1169
        __cil_tmp28___16 = pSrc___18;
#line 1169
        pSrc___18 ++;
#line 1169
        val4___6 = (OPJ_UINT32 )*__cil_tmp28___16;
#line 1170
        __cil_tmp30___10 = pSrc___18;
#line 1170
        pSrc___18 ++;
#line 1170
        val5___4 = (OPJ_UINT32 )*__cil_tmp30___10;
#line 1171
        *(pDst___18 + (i___114 + 2UL)) = (OPJ_INT32 )((((val3___7 & 15U) << 10) | (val4___6 << 2)) | (val5___4 >> 6));
      }
    }
  }
#line 1175
  return;
}
}
#line 1176 "/root/patron-new/39/src/bin/jp2/converttif.c"
static void tif_15uto32s(OPJ_BYTE *pSrc___19 , OPJ_INT32 *pDst___19 , OPJ_SIZE_T length___19 ) 
{ 
  OPJ_SIZE_T i___115 ;
  OPJ_UINT32 val0___11 ;
  OPJ_BYTE *__cil_tmp6___46 ;
  OPJ_UINT32 val1___11 ;
  OPJ_BYTE *__cil_tmp8___64 ;
  OPJ_UINT32 val2___10 ;
  OPJ_BYTE *__cil_tmp10___35 ;
  OPJ_UINT32 val3___8 ;
  OPJ_BYTE *__cil_tmp12___41 ;
  OPJ_UINT32 val4___7 ;
  OPJ_BYTE *__cil_tmp14___54 ;
  OPJ_UINT32 val5___5 ;
  OPJ_BYTE *__cil_tmp16___37 ;
  OPJ_UINT32 val6___4 ;
  OPJ_BYTE *__cil_tmp18___29 ;
  OPJ_UINT32 val7___2 ;
  OPJ_BYTE *__cil_tmp20___36 ;
  OPJ_UINT32 val8___2 ;
  OPJ_BYTE *__cil_tmp22___30 ;
  OPJ_UINT32 val9___1 ;
  OPJ_BYTE *__cil_tmp24___25 ;
  OPJ_UINT32 val10___1 ;
  OPJ_BYTE *__cil_tmp26___18 ;
  OPJ_UINT32 val11___0 ;
  OPJ_BYTE *__cil_tmp28___17 ;
  OPJ_UINT32 val12___0 ;
  OPJ_BYTE *__cil_tmp30___11 ;
  OPJ_UINT32 val13 ;
  OPJ_BYTE *__cil_tmp32___15 ;
  OPJ_UINT32 val14 ;
  OPJ_BYTE *__cil_tmp34___10 ;
  unsigned int val___5 ;
  int available___5 ;
  int needed___41 ;
  unsigned int dst___42 ;
  OPJ_BYTE *__cil_tmp39___9 ;
  OPJ_BYTE *__cil_tmp40___10 ;
  int needed___42 ;
  unsigned int dst___43 ;
  OPJ_BYTE *__cil_tmp43___7 ;
  OPJ_BYTE *__cil_tmp44___7 ;
  int needed___43 ;
  unsigned int dst___44 ;
  OPJ_BYTE *__cil_tmp47___3 ;
  OPJ_BYTE *__cil_tmp48___4 ;
  int needed___44 ;
  unsigned int dst___45 ;
  OPJ_BYTE *__cil_tmp51___3 ;
  OPJ_BYTE *__cil_tmp52___3 ;
  int needed___45 ;
  unsigned int dst___46 ;
  OPJ_BYTE *__cil_tmp55___2 ;
  OPJ_BYTE *__cil_tmp56___2 ;
  int needed___46 ;
  unsigned int dst___47 ;
  OPJ_BYTE *__cil_tmp59___1 ;
  OPJ_BYTE *__cil_tmp60___0 ;
  int needed___47 ;
  unsigned int dst___48 ;
  OPJ_BYTE *__cil_tmp63 ;
  OPJ_BYTE *__cil_tmp64 ;

  {
#line 1180
  i___115 = (OPJ_SIZE_T )0;
  {
#line 1180
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1180
    if (! (i___115 < (length___19 & 0xfffffffffffffff8UL))) {
#line 1180
      goto while_break;
    }
#line 1181
    __cil_tmp6___46 = pSrc___19;
#line 1181
    pSrc___19 ++;
#line 1181
    val0___11 = (OPJ_UINT32 )*__cil_tmp6___46;
#line 1182
    __cil_tmp8___64 = pSrc___19;
#line 1182
    pSrc___19 ++;
#line 1182
    val1___11 = (OPJ_UINT32 )*__cil_tmp8___64;
#line 1183
    __cil_tmp10___35 = pSrc___19;
#line 1183
    pSrc___19 ++;
#line 1183
    val2___10 = (OPJ_UINT32 )*__cil_tmp10___35;
#line 1184
    __cil_tmp12___41 = pSrc___19;
#line 1184
    pSrc___19 ++;
#line 1184
    val3___8 = (OPJ_UINT32 )*__cil_tmp12___41;
#line 1185
    __cil_tmp14___54 = pSrc___19;
#line 1185
    pSrc___19 ++;
#line 1185
    val4___7 = (OPJ_UINT32 )*__cil_tmp14___54;
#line 1186
    __cil_tmp16___37 = pSrc___19;
#line 1186
    pSrc___19 ++;
#line 1186
    val5___5 = (OPJ_UINT32 )*__cil_tmp16___37;
#line 1187
    __cil_tmp18___29 = pSrc___19;
#line 1187
    pSrc___19 ++;
#line 1187
    val6___4 = (OPJ_UINT32 )*__cil_tmp18___29;
#line 1188
    __cil_tmp20___36 = pSrc___19;
#line 1188
    pSrc___19 ++;
#line 1188
    val7___2 = (OPJ_UINT32 )*__cil_tmp20___36;
#line 1189
    __cil_tmp22___30 = pSrc___19;
#line 1189
    pSrc___19 ++;
#line 1189
    val8___2 = (OPJ_UINT32 )*__cil_tmp22___30;
#line 1190
    __cil_tmp24___25 = pSrc___19;
#line 1190
    pSrc___19 ++;
#line 1190
    val9___1 = (OPJ_UINT32 )*__cil_tmp24___25;
#line 1191
    __cil_tmp26___18 = pSrc___19;
#line 1191
    pSrc___19 ++;
#line 1191
    val10___1 = (OPJ_UINT32 )*__cil_tmp26___18;
#line 1192
    __cil_tmp28___17 = pSrc___19;
#line 1192
    pSrc___19 ++;
#line 1192
    val11___0 = (OPJ_UINT32 )*__cil_tmp28___17;
#line 1193
    __cil_tmp30___11 = pSrc___19;
#line 1193
    pSrc___19 ++;
#line 1193
    val12___0 = (OPJ_UINT32 )*__cil_tmp30___11;
#line 1194
    __cil_tmp32___15 = pSrc___19;
#line 1194
    pSrc___19 ++;
#line 1194
    val13 = (OPJ_UINT32 )*__cil_tmp32___15;
#line 1195
    __cil_tmp34___10 = pSrc___19;
#line 1195
    pSrc___19 ++;
#line 1195
    val14 = (OPJ_UINT32 )*__cil_tmp34___10;
#line 1197
    *(pDst___19 + i___115) = (OPJ_INT32 )((val0___11 << 7) | (val1___11 >> 1));
#line 1198
    *(pDst___19 + (i___115 + 1UL)) = (OPJ_INT32 )((((val1___11 & 1U) << 14) | (val2___10 << 6)) | (val3___8 >> 2));
#line 1199
    *(pDst___19 + (i___115 + 2UL)) = (OPJ_INT32 )((((val3___8 & 3U) << 13) | (val4___7 << 5)) | (val5___5 >> 3));
#line 1200
    *(pDst___19 + (i___115 + 3UL)) = (OPJ_INT32 )((((val5___5 & 7U) << 12) | (val6___4 << 4)) | (val7___2 >> 4));
#line 1201
    *(pDst___19 + (i___115 + 4UL)) = (OPJ_INT32 )((((val7___2 & 15U) << 11) | (val8___2 << 3)) | (val9___1 >> 5));
#line 1202
    *(pDst___19 + (i___115 + 5UL)) = (OPJ_INT32 )((((val9___1 & 31U) << 10) | (val10___1 << 2)) | (val11___0 >> 6));
#line 1203
    *(pDst___19 + (i___115 + 6UL)) = (OPJ_INT32 )((((val11___0 & 63U) << 9) | (val12___0 << 1)) | (val13 >> 7));
#line 1204
    *(pDst___19 + (i___115 + 7UL)) = (OPJ_INT32 )(((val13 & 127U) << 8) | val14);
#line 1180
    i___115 += 8UL;
  }
  while_break___7: /* CIL Label */ ;
  }

  while_break: ;
#line 1207
  if (length___19 & 7UL) {
#line 1209
    available___5 = 0;
#line 1211
    length___19 &= 7UL;
#line 1213
    needed___41 = 15;
#line 1213
    dst___42 = 0U;
#line 1213
    if (available___5 == 0) {
#line 1213
      __cil_tmp39___9 = pSrc___19;
#line 1213
      pSrc___19 ++;
#line 1213
      val___5 = (unsigned int )*__cil_tmp39___9;
#line 1213
      available___5 = 8;
    }
    {
#line 1213
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1213
      if (! (needed___41 > available___5)) {
#line 1213
        goto while_break___0;
      }
#line 1213
      dst___42 |= val___5 & ((1U << available___5) - 1U);
#line 1213
      needed___41 -= available___5;
#line 1213
      dst___42 <<= needed___41;
#line 1213
      __cil_tmp40___10 = pSrc___19;
#line 1213
      pSrc___19 ++;
#line 1213
      val___5 = (unsigned int )*__cil_tmp40___10;
#line 1213
      available___5 = 8;
    }
    while_break___8: /* CIL Label */ ;
    }

    while_break___0: 
#line 1213
    dst___42 |= (val___5 >> (available___5 - needed___41)) & ((1U << needed___41) - 1U);
#line 1213
    available___5 -= needed___41;
#line 1213
    *(pDst___19 + i___115) = (OPJ_INT32 )dst___42;
#line 1215
    if (length___19 > 1UL) {
#line 1216
      needed___42 = 15;
#line 1216
      dst___43 = 0U;
#line 1216
      if (available___5 == 0) {
#line 1216
        __cil_tmp43___7 = pSrc___19;
#line 1216
        pSrc___19 ++;
#line 1216
        val___5 = (unsigned int )*__cil_tmp43___7;
#line 1216
        available___5 = 8;
      }
      {
#line 1216
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 1216
        if (! (needed___42 > available___5)) {
#line 1216
          goto while_break___1;
        }
#line 1216
        dst___43 |= val___5 & ((1U << available___5) - 1U);
#line 1216
        needed___42 -= available___5;
#line 1216
        dst___43 <<= needed___42;
#line 1216
        __cil_tmp44___7 = pSrc___19;
#line 1216
        pSrc___19 ++;
#line 1216
        val___5 = (unsigned int )*__cil_tmp44___7;
#line 1216
        available___5 = 8;
      }
      while_break___9: /* CIL Label */ ;
      }

      while_break___1: 
#line 1216
      dst___43 |= (val___5 >> (available___5 - needed___42)) & ((1U << needed___42) - 1U);
#line 1216
      available___5 -= needed___42;
#line 1216
      *(pDst___19 + (i___115 + 1UL)) = (OPJ_INT32 )dst___43;
#line 1217
      if (length___19 > 2UL) {
#line 1218
        needed___43 = 15;
#line 1218
        dst___44 = 0U;
#line 1218
        if (available___5 == 0) {
#line 1218
          __cil_tmp47___3 = pSrc___19;
#line 1218
          pSrc___19 ++;
#line 1218
          val___5 = (unsigned int )*__cil_tmp47___3;
#line 1218
          available___5 = 8;
        }
        {
#line 1218
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 1218
          if (! (needed___43 > available___5)) {
#line 1218
            goto while_break___2;
          }
#line 1218
          dst___44 |= val___5 & ((1U << available___5) - 1U);
#line 1218
          needed___43 -= available___5;
#line 1218
          dst___44 <<= needed___43;
#line 1218
          __cil_tmp48___4 = pSrc___19;
#line 1218
          pSrc___19 ++;
#line 1218
          val___5 = (unsigned int )*__cil_tmp48___4;
#line 1218
          available___5 = 8;
        }
        while_break___10: /* CIL Label */ ;
        }

        while_break___2: 
#line 1218
        dst___44 |= (val___5 >> (available___5 - needed___43)) & ((1U << needed___43) - 1U);
#line 1218
        available___5 -= needed___43;
#line 1218
        *(pDst___19 + (i___115 + 2UL)) = (OPJ_INT32 )dst___44;
#line 1219
        if (length___19 > 3UL) {
#line 1220
          needed___44 = 15;
#line 1220
          dst___45 = 0U;
#line 1220
          if (available___5 == 0) {
#line 1220
            __cil_tmp51___3 = pSrc___19;
#line 1220
            pSrc___19 ++;
#line 1220
            val___5 = (unsigned int )*__cil_tmp51___3;
#line 1220
            available___5 = 8;
          }
          {
#line 1220
          while (1) {
            while_continue___3: /* CIL Label */ ;

#line 1220
            if (! (needed___44 > available___5)) {
#line 1220
              goto while_break___3;
            }
#line 1220
            dst___45 |= val___5 & ((1U << available___5) - 1U);
#line 1220
            needed___44 -= available___5;
#line 1220
            dst___45 <<= needed___44;
#line 1220
            __cil_tmp52___3 = pSrc___19;
#line 1220
            pSrc___19 ++;
#line 1220
            val___5 = (unsigned int )*__cil_tmp52___3;
#line 1220
            available___5 = 8;
          }
          while_break___11: /* CIL Label */ ;
          }

          while_break___3: 
#line 1220
          dst___45 |= (val___5 >> (available___5 - needed___44)) & ((1U << needed___44) - 1U);
#line 1220
          available___5 -= needed___44;
#line 1220
          *(pDst___19 + (i___115 + 3UL)) = (OPJ_INT32 )dst___45;
#line 1221
          if (length___19 > 4UL) {
#line 1222
            needed___45 = 15;
#line 1222
            dst___46 = 0U;
#line 1222
            if (available___5 == 0) {
#line 1222
              __cil_tmp55___2 = pSrc___19;
#line 1222
              pSrc___19 ++;
#line 1222
              val___5 = (unsigned int )*__cil_tmp55___2;
#line 1222
              available___5 = 8;
            }
            {
#line 1222
            while (1) {
              while_continue___4: /* CIL Label */ ;

#line 1222
              if (! (needed___45 > available___5)) {
#line 1222
                goto while_break___4;
              }
#line 1222
              dst___46 |= val___5 & ((1U << available___5) - 1U);
#line 1222
              needed___45 -= available___5;
#line 1222
              dst___46 <<= needed___45;
#line 1222
              __cil_tmp56___2 = pSrc___19;
#line 1222
              pSrc___19 ++;
#line 1222
              val___5 = (unsigned int )*__cil_tmp56___2;
#line 1222
              available___5 = 8;
            }
            while_break___12: /* CIL Label */ ;
            }

            while_break___4: 
#line 1222
            dst___46 |= (val___5 >> (available___5 - needed___45)) & ((1U << needed___45) - 1U);
#line 1222
            available___5 -= needed___45;
#line 1222
            *(pDst___19 + (i___115 + 4UL)) = (OPJ_INT32 )dst___46;
#line 1223
            if (length___19 > 5UL) {
#line 1224
              needed___46 = 15;
#line 1224
              dst___47 = 0U;
#line 1224
              if (available___5 == 0) {
#line 1224
                __cil_tmp59___1 = pSrc___19;
#line 1224
                pSrc___19 ++;
#line 1224
                val___5 = (unsigned int )*__cil_tmp59___1;
#line 1224
                available___5 = 8;
              }
              {
#line 1224
              while (1) {
                while_continue___5: /* CIL Label */ ;

#line 1224
                if (! (needed___46 > available___5)) {
#line 1224
                  goto while_break___5;
                }
#line 1224
                dst___47 |= val___5 & ((1U << available___5) - 1U);
#line 1224
                needed___46 -= available___5;
#line 1224
                dst___47 <<= needed___46;
#line 1224
                __cil_tmp60___0 = pSrc___19;
#line 1224
                pSrc___19 ++;
#line 1224
                val___5 = (unsigned int )*__cil_tmp60___0;
#line 1224
                available___5 = 8;
              }
              while_break___13: /* CIL Label */ ;
              }

              while_break___5: 
#line 1224
              dst___47 |= (val___5 >> (available___5 - needed___46)) & ((1U << needed___46) - 1U);
#line 1224
              available___5 -= needed___46;
#line 1224
              *(pDst___19 + (i___115 + 5UL)) = (OPJ_INT32 )dst___47;
#line 1225
              if (length___19 > 6UL) {
#line 1226
                needed___47 = 15;
#line 1226
                dst___48 = 0U;
#line 1226
                if (available___5 == 0) {
#line 1226
                  __cil_tmp63 = pSrc___19;
#line 1226
                  pSrc___19 ++;
#line 1226
                  val___5 = (unsigned int )*__cil_tmp63;
#line 1226
                  available___5 = 8;
                }
                {
#line 1226
                while (1) {
                  while_continue___6: /* CIL Label */ ;

#line 1226
                  if (! (needed___47 > available___5)) {
#line 1226
                    goto while_break___6;
                  }
#line 1226
                  dst___48 |= val___5 & ((1U << available___5) - 1U);
#line 1226
                  needed___47 -= available___5;
#line 1226
                  dst___48 <<= needed___47;
#line 1226
                  __cil_tmp64 = pSrc___19;
#line 1226
                  pSrc___19 ++;
#line 1226
                  val___5 = (unsigned int )*__cil_tmp64;
#line 1226
                  available___5 = 8;
                }
                while_break___14: /* CIL Label */ ;
                }

                while_break___6: 
#line 1226
                dst___48 |= (val___5 >> (available___5 - needed___47)) & ((1U << needed___47) - 1U);
#line 1226
                available___5 -= needed___47;
#line 1226
                *(pDst___19 + (i___115 + 6UL)) = (OPJ_INT32 )dst___48;
              }
            }
          }
        }
      }
    }
  }
#line 1234
  return;
}
}
#line 1237 "/root/patron-new/39/src/bin/jp2/converttif.c"
static void tif_16uto32s(OPJ_UINT16 *pSrc___20 , OPJ_INT32 *pDst___20 , OPJ_SIZE_T length___20 ) 
{ 
  OPJ_SIZE_T i___116 ;

  {
#line 1241
  i___116 = (OPJ_SIZE_T )0;
  {
#line 1241
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1241
    if (! (i___116 < length___20)) {
#line 1241
      goto while_break;
    }
#line 1242
    *(pDst___20 + i___116) = (OPJ_INT32 )*(pSrc___20 + i___116);
#line 1241
    i___116 ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 1245
  return;
}
}
#line 1250 "/root/patron-new/39/src/bin/jp2/converttif.c"
opj_image_t *tiftoimage(char const   *filename , opj_cparameters_t *parameters___12 ) 
{ 
  int subsampling_dx ;
  int subsampling_dy ;
  TIFF *tif___0 ;
  tdata_t buf___0 ;
  tstrip_t strip ;
  int64_t strip_size___0 ;
  int64_t rowStride___0 ;
  int64_t TIFF_MAX___0 ;
  int j___15 ;
  int currentPlane ;
  int numcomps___5 ;
  int w ;
  int h ;
  OPJ_COLOR_SPACE color_space ;
  opj_image_cmptparm_t cmptparm[4] ;
  opj_image_t *image___15 ;
  uint16 tiBps ;
  uint16 tiPhoto___0 ;
  uint16 tiSf ;
  uint16 tiSpp ;
  uint16 tiPC ;
  uint32 tiWidth ;
  uint32 tiHeight ;
  OPJ_BOOL is_cinema ;
  void (*cvtTifTo32s)(OPJ_BYTE * , OPJ_INT32 * , OPJ_SIZE_T  ) ;
  void (*cvtCxToPx)(OPJ_INT32 * , OPJ_INT32 * const  * , OPJ_SIZE_T  ) ;
  OPJ_INT32 *buffer32s___0 ;
  OPJ_INT32 *planes___0[4] ;
  OPJ_UINT32 tmp___464 ;
  OPJ_UINT32 tmp___465 ;
  tmsize_t __cil_tmp37___5 ;
  void *__cil_tmp39___10 ;
  uint32 __cil_tmp40___11 ;
  OPJ_UINT8 *dat8 ;
  int64_t ssize ;
  tmsize_t __cil_tmp43___8 ;
  int __cil_tmp44___8 ;
  int tmp___466 ;

  {
#line 1252
  subsampling_dx = parameters___12->subsampling_dx;
#line 1253
  subsampling_dy = parameters___12->subsampling_dy;
#line 1258
  numcomps___5 = 0;
#line 1259
  color_space = (OPJ_COLOR_SPACE )-1;
#line 1261
  image___15 = (opj_image_t *)((void *)0);
#line 1264
  if ((int )parameters___12->rsiz >= 3) {
#line 1264
    if ((int )parameters___12->rsiz <= 6) {
#line 1264
      tmp___466 = 1;
    } else {
#line 1264
      tmp___466 = 0;
    }
  } else {
#line 1264
    tmp___466 = 0;
  }
  {
#line 1264
  is_cinema = tmp___466;
#line 1265
  cvtTifTo32s = (void (*)(OPJ_BYTE * , OPJ_INT32 * , OPJ_SIZE_T  ))((void *)0);
#line 1266
  cvtCxToPx = (void (*)(OPJ_INT32 * , OPJ_INT32 * const  * , OPJ_SIZE_T  ))((void *)0);
#line 1267
  buffer32s___0 = (OPJ_INT32 *)((void *)0);
#line 1270
  tif___0 = TIFFOpen(filename, "r");
  }
#line 1272
  if (! tif___0) {
    {
#line 1273
    fprintf(stderr, "tiftoimage:Failed to open %s for reading\n", filename);
    }
#line 1274
    return ((opj_image_t *)0);
  }
  {
#line 1276
  tiPC = (uint16 )0;
#line 1276
  tiSpp = tiPC;
#line 1276
  tiSf = tiSpp;
#line 1276
  tiPhoto___0 = tiSf;
#line 1276
  tiBps = tiPhoto___0;
#line 1277
  tiHeight = (uint32 )0;
#line 1277
  tiWidth = tiHeight;
#line 1279
  TIFFGetField(tif___0, (uint32 )256, & tiWidth);
#line 1280
  TIFFGetField(tif___0, (uint32 )257, & tiHeight);
#line 1281
  TIFFGetField(tif___0, (uint32 )258, & tiBps);
#line 1282
  TIFFGetField(tif___0, (uint32 )339, & tiSf);
#line 1283
  TIFFGetField(tif___0, (uint32 )277, & tiSpp);
#line 1284
  TIFFGetField(tif___0, (uint32 )262, & tiPhoto___0);
#line 1285
  TIFFGetField(tif___0, (uint32 )284, & tiPC);
#line 1286
  w = (int )tiWidth;
#line 1287
  h = (int )tiHeight;
  }
#line 1289
  if ((int )tiSpp == 0) {
    {
#line 1290
    fprintf(stderr, "tiftoimage: Bad value for samples per pixel == %d.\n\tAborting.\n",
            (int )tiSpp);
#line 1292
    TIFFClose(tif___0);
    }
#line 1293
    return ((opj_image_t *)((void *)0));
  } else
#line 1289
  if ((int )tiSpp > 4) {
    {
#line 1290
    fprintf(stderr, "tiftoimage: Bad value for samples per pixel == %d.\n\tAborting.\n",
            (int )tiSpp);
#line 1292
    TIFFClose(tif___0);
    }
#line 1293
    return ((opj_image_t *)((void *)0));
  }
#line 1295
  if ((unsigned int )tiBps > 16U) {
    {
#line 1296
    fprintf(stderr, "tiftoimage: Bad values for Bits == %d.\n\tMax. 16 Bits are allowed here.\n\tAborting.\n",
            (int )tiBps);
#line 1298
    TIFFClose(tif___0);
    }
#line 1299
    return ((opj_image_t *)((void *)0));
  } else
#line 1295
  if ((int )tiBps == 0) {
    {
#line 1296
    fprintf(stderr, "tiftoimage: Bad values for Bits == %d.\n\tMax. 16 Bits are allowed here.\n\tAborting.\n",
            (int )tiBps);
#line 1298
    TIFFClose(tif___0);
    }
#line 1299
    return ((opj_image_t *)((void *)0));
  }
#line 1301
  if ((int )tiPhoto___0 != 1) {
#line 1301
    if ((int )tiPhoto___0 != 2) {
      {
#line 1302
      fprintf(stderr, "tiftoimage: Bad color format %d.\n\tOnly RGB(A) and GRAY(A) has been implemented\n\tAborting.\n",
              (int )tiPhoto___0);
#line 1305
      TIFFClose(tif___0);
      }
#line 1306
      return ((opj_image_t *)((void *)0));
    }
  }
#line 1308
  if (tiWidth == 0U) {
    {
#line 1309
    fprintf(stderr, "tiftoimage: Bad values for width(%u) and/or height(%u)\n\tAborting.\n",
            tiWidth, tiHeight);
#line 1311
    TIFFClose(tif___0);
    }
#line 1312
    return ((opj_image_t *)((void *)0));
  } else
#line 1308
  if (tiHeight == 0U) {
    {
#line 1309
    fprintf(stderr, "tiftoimage: Bad values for width(%u) and/or height(%u)\n\tAborting.\n",
            tiWidth, tiHeight);
#line 1311
    TIFFClose(tif___0);
    }
#line 1312
    return ((opj_image_t *)((void *)0));
  }
#line 1314
  w = (int )tiWidth;
#line 1315
  h = (int )tiHeight;
#line 1322
  if ((int )tiBps == 8) {
#line 1322
    goto case_8;
  }
#line 1322
  if ((int )tiBps == 6) {
#line 1322
    goto case_8;
  }
#line 1322
  if ((int )tiBps == 4) {
#line 1322
    goto case_8;
  }
#line 1322
  if ((int )tiBps == 2) {
#line 1322
    goto case_8;
  }
#line 1322
  if ((int )tiBps == 1) {
#line 1322
    goto case_8;
  }
#line 1326
  if ((int )tiBps == 3) {
#line 1326
    goto case_3;
  }
#line 1329
  if ((int )tiBps == 5) {
#line 1329
    goto case_5;
  }
#line 1332
  if ((int )tiBps == 7) {
#line 1332
    goto case_7;
  }
#line 1335
  if ((int )tiBps == 9) {
#line 1335
    goto case_9;
  }
#line 1338
  if ((int )tiBps == 10) {
#line 1338
    goto case_10;
  }
#line 1341
  if ((int )tiBps == 11) {
#line 1341
    goto case_11;
  }
#line 1344
  if ((int )tiBps == 12) {
#line 1344
    goto case_12;
  }
#line 1347
  if ((int )tiBps == 13) {
#line 1347
    goto case_13;
  }
#line 1350
  if ((int )tiBps == 14) {
#line 1350
    goto case_14;
  }
#line 1353
  if ((int )tiBps == 15) {
#line 1353
    goto case_15;
  }
#line 1356
  if ((int )tiBps == 16) {
#line 1356
    goto case_16;
  }
#line 1359
  goto switch_default;
  case_8: 
#line 1323
  cvtTifTo32s = convert_XXu32s_C1R_LUT[tiBps];
#line 1324
  goto switch_break;
  case_3: 
#line 1327
  cvtTifTo32s = & tif_3uto32s;
#line 1328
  goto switch_break;
  case_5: 
#line 1330
  cvtTifTo32s = & tif_5uto32s;
#line 1331
  goto switch_break;
  case_7: 
#line 1333
  cvtTifTo32s = & tif_7uto32s;
#line 1334
  goto switch_break;
  case_9: 
#line 1336
  cvtTifTo32s = & tif_9uto32s;
#line 1337
  goto switch_break;
  case_10: 
#line 1339
  cvtTifTo32s = & tif_10uto32s;
#line 1340
  goto switch_break;
  case_11: 
#line 1342
  cvtTifTo32s = & tif_11uto32s;
#line 1343
  goto switch_break;
  case_12: 
#line 1345
  cvtTifTo32s = & tif_12uto32s;
#line 1346
  goto switch_break;
  case_13: 
#line 1348
  cvtTifTo32s = & tif_13uto32s;
#line 1349
  goto switch_break;
  case_14: 
#line 1351
  cvtTifTo32s = & tif_14uto32s;
#line 1352
  goto switch_break;
  case_15: 
#line 1354
  cvtTifTo32s = & tif_15uto32s;
#line 1355
  goto switch_break;
  case_16: 
#line 1357
  cvtTifTo32s = (void (*)(OPJ_BYTE * , OPJ_INT32 * , OPJ_SIZE_T  ))(& tif_16uto32s);
#line 1358
  goto switch_break;
  switch_default: 
#line 1361
  goto switch_break;
  switch_break: 
  {
#line 1365
  memset((void *)(& cmptparm[0]), 0, 4UL * sizeof(opj_image_cmptparm_t ));
  }
#line 1367
  if ((int )tiPhoto___0 == 2) {
#line 1367
    if (is_cinema) {
#line 1367
      if ((unsigned int )tiBps != 12U) {
        {
#line 1368
        fprintf(stdout, "WARNING:\nInput image bitdepth is %d bits\nTIF conversion has automatically rescaled to 12-bits\nto comply with cinema profiles.\n",
                (int )tiBps);
        }
      } else {
#line 1374
        is_cinema = (OPJ_BOOL )0U;
      }
    } else {
#line 1374
      is_cinema = (OPJ_BOOL )0U;
    }
  } else {
#line 1374
    is_cinema = (OPJ_BOOL )0U;
  }
#line 1377
  numcomps___5 = (int )tiSpp;
#line 1378
  if ((int )tiPhoto___0 == 2) {
#line 1379
    color_space = (OPJ_COLOR_SPACE )1;
  } else
#line 1380
  if ((int )tiPhoto___0 == 1) {
#line 1381
    color_space = (OPJ_COLOR_SPACE )2;
  }
#line 1384
  cvtCxToPx = convert_32s_CXPX_LUT[numcomps___5];
#line 1385
  if ((int )tiPC == 2) {
#line 1386
    cvtCxToPx = convert_32s_CXPX_LUT[1];
#line 1387
    tiSpp = (uint16 )1U;
  }
#line 1390
  j___15 = 0;
  {
#line 1390
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1390
    if (! (j___15 < numcomps___5)) {
#line 1390
      goto while_break;
    }
#line 1391
    cmptparm[j___15].prec = (OPJ_UINT32 )tiBps;
#line 1392
    cmptparm[j___15].bpp = (OPJ_UINT32 )tiBps;
#line 1393
    cmptparm[j___15].dx = (OPJ_UINT32 )subsampling_dx;
#line 1394
    cmptparm[j___15].dy = (OPJ_UINT32 )subsampling_dy;
#line 1395
    cmptparm[j___15].w = (OPJ_UINT32 )w;
#line 1396
    cmptparm[j___15].h = (OPJ_UINT32 )h;
#line 1390
    j___15 ++;
  }
  while_break___5: /* CIL Label */ ;
  }

  while_break: 
  {
#line 1399
  image___15 = opj_image_create((OPJ_UINT32 )numcomps___5, & cmptparm[0], color_space);
  }
#line 1400
  if (! image___15) {
    {
#line 1401
    TIFFClose(tif___0);
    }
#line 1402
    return ((opj_image_t *)((void *)0));
  }
#line 1405
  image___15->x0 = (OPJ_UINT32 )parameters___12->image_offset_x0;
#line 1406
  image___15->y0 = (OPJ_UINT32 )parameters___12->image_offset_y0;
#line 1407
  if (! image___15->x0) {
#line 1407
    tmp___464 = (OPJ_UINT32 )(w - 1) * (OPJ_UINT32 )subsampling_dx + 1U;
  } else {
#line 1407
    tmp___464 = (image___15->x0 + (OPJ_UINT32 )(w - 1) * (OPJ_UINT32 )subsampling_dx) + 1U;
  }
#line 1407
  image___15->x1 = tmp___464;
#line 1409
  if (image___15->x1 <= image___15->x0) {
    {
#line 1410
    fprintf(stderr, "tiftoimage: Bad value for image->x1(%d) vs. image->x0(%d)\n\tAborting.\n",
            image___15->x1, image___15->x0);
#line 1412
    TIFFClose(tif___0);
#line 1413
    opj_image_destroy(image___15);
    }
#line 1414
    return ((opj_image_t *)((void *)0));
  }
#line 1416
  if (! image___15->y0) {
#line 1416
    tmp___465 = (OPJ_UINT32 )(h - 1) * (OPJ_UINT32 )subsampling_dy + 1U;
  } else {
#line 1416
    tmp___465 = (image___15->y0 + (OPJ_UINT32 )(h - 1) * (OPJ_UINT32 )subsampling_dy) + 1U;
  }
#line 1416
  image___15->y1 = tmp___465;
#line 1418
  if (image___15->y1 <= image___15->y0) {
    {
#line 1419
    fprintf(stderr, "tiftoimage: Bad value for image->y1(%d) vs. image->y0(%d)\n\tAborting.\n",
            image___15->y1, image___15->y0);
#line 1421
    TIFFClose(tif___0);
#line 1422
    opj_image_destroy(image___15);
    }
#line 1423
    return ((opj_image_t *)((void *)0));
  }
#line 1426
  j___15 = 0;
  {
#line 1426
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 1426
    if (! (j___15 < numcomps___5)) {
#line 1426
      goto while_break___0;
    }
#line 1427
    planes___0[j___15] = (image___15->comps + j___15)->data;
#line 1426
    j___15 ++;
  }
  while_break___6: /* CIL Label */ ;
  }

  while_break___0: 
  {
#line 1429
  (image___15->comps + (numcomps___5 - 1))->alpha = (OPJ_UINT16 )(1 - (numcomps___5 & 1));
#line 1431
  __cil_tmp37___5 = TIFFStripSize(tif___0);
#line 1431
  strip_size___0 = __cil_tmp37___5;
#line 1433
  buf___0 = malloc((OPJ_SIZE_T )strip_size___0);
  }
#line 1434
  if ((unsigned long )buf___0 == (unsigned long )((void *)0)) {
    {
#line 1435
    TIFFClose(tif___0);
#line 1436
    opj_image_destroy(image___15);
    }
#line 1437
    return ((opj_image_t *)((void *)0));
  }
#line 1439
  if (sizeof(tsize_t ) == 4UL) {
#line 1440
    TIFF_MAX___0 = (int64_t )2147483647;
  } else {
#line 1442
    TIFF_MAX___0 = (int64_t )4294967295U;
  }
#line 1444
  if ((int64_t )tiWidth > TIFF_MAX___0 / (long )tiSpp) {
    {
#line 1447
    fprintf(stderr, "Buffer overflow\n\220");
#line 1448
    _TIFFfree(buf___0);
#line 1449
    TIFFClose(tif___0);
#line 1450
    opj_image_destroy(image___15);
    }
#line 1451
    return ((opj_image_t *)((void *)0));
  } else
#line 1444
  if ((int64_t )(tiWidth * (unsigned int )tiSpp) > TIFF_MAX___0 / (long )tiBps) {
    {
#line 1447
    fprintf(stderr, "Buffer overflow\n\220");
#line 1448
    _TIFFfree(buf___0);
#line 1449
    TIFFClose(tif___0);
#line 1450
    opj_image_destroy(image___15);
    }
#line 1451
    return ((opj_image_t *)((void *)0));
  } else
#line 1444
  if ((int64_t )(tiWidth * (unsigned int )tiSpp) > TIFF_MAX___0 / (int64_t )sizeof(OPJ_INT32 )) {
    {
#line 1447
    fprintf(stderr, "Buffer overflow\n\220");
#line 1448
    _TIFFfree(buf___0);
#line 1449
    TIFFClose(tif___0);
#line 1450
    opj_image_destroy(image___15);
    }
#line 1451
    return ((opj_image_t *)((void *)0));
  }
  {
#line 1454
  rowStride___0 = (int64_t )(((tiWidth * (unsigned int )tiSpp) * (unsigned int )tiBps + 7U) / 8U);
#line 1455
  __cil_tmp39___10 = malloc((sizeof(OPJ_INT32 ) * (unsigned long )tiWidth) * (unsigned long )tiSpp);
#line 1455
  buffer32s___0 = (OPJ_INT32 *)__cil_tmp39___10;
  }
#line 1456
  if ((unsigned long )buffer32s___0 == (unsigned long )((void *)0)) {
    {
#line 1457
    _TIFFfree(buf___0);
#line 1458
    TIFFClose(tif___0);
#line 1459
    opj_image_destroy(image___15);
    }
#line 1460
    return ((opj_image_t *)((void *)0));
  }
#line 1463
  strip = (tstrip_t )0;
#line 1464
  currentPlane = 0;
  {
#line 1465
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1466
    planes___0[0] = (image___15->comps + currentPlane)->data;
#line 1467
    h = (int )tiHeight;
    {
#line 1469
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 1469
      if (h > 0) {
#line 1469
        if (! (strip < __cil_tmp40___11)) {
#line 1469
          goto while_break___2;
        }
      } else {
#line 1469
        goto while_break___2;
      }
      {
#line 1473
      __cil_tmp43___8 = TIFFReadEncodedStrip(tif___0, strip, buf___0, strip_size___0);
#line 1473
      ssize = __cil_tmp43___8;
      }
#line 1475
      if (ssize < 1L) {
        {
#line 1476
        fprintf(stderr, "tiftoimage: Bad value for ssize(%ld) vs. strip_size(%ld).\n\tAborting.\n",
                ssize, strip_size___0);
#line 1478
        _TIFFfree(buf___0);
#line 1479
        _TIFFfree((void *)buffer32s___0);
#line 1480
        TIFFClose(tif___0);
#line 1481
        opj_image_destroy(image___15);
        }
#line 1482
        return ((opj_image_t *)((void *)0));
      } else
#line 1475
      if (ssize > strip_size___0) {
        {
#line 1476
        fprintf(stderr, "tiftoimage: Bad value for ssize(%ld) vs. strip_size(%ld).\n\tAborting.\n",
                ssize, strip_size___0);
#line 1478
        _TIFFfree(buf___0);
#line 1479
        _TIFFfree((void *)buffer32s___0);
#line 1480
        TIFFClose(tif___0);
#line 1481
        opj_image_destroy(image___15);
        }
#line 1482
        return ((opj_image_t *)((void *)0));
      }
#line 1484
      dat8 = (OPJ_UINT8 *)buf___0;
      {
#line 1486
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 1486
        if (! (ssize >= rowStride___0)) {
#line 1486
          goto while_break___3;
        }
        {
#line 1487
        (*cvtTifTo32s)(dat8, buffer32s___0, (OPJ_SIZE_T )w * (unsigned long )tiSpp);
#line 1488
        (*cvtCxToPx)(buffer32s___0, (OPJ_INT32 * const  *)(planes___0), (OPJ_SIZE_T )w);
#line 1489
        planes___0[0] += w;
#line 1490
        planes___0[1] += w;
#line 1491
        planes___0[2] += w;
#line 1492
        planes___0[3] += w;
#line 1493
        dat8 += rowStride___0;
#line 1494
        ssize -= rowStride___0;
#line 1495
        __cil_tmp44___8 = h;
#line 1495
        h --;
        }
      }
      while_break___9: /* CIL Label */ ;
      }

      while_break___3: 
#line 1469
      strip ++;
    }
    while_break___8: /* CIL Label */ ;
    }

    while_break___2: 
#line 1498
    currentPlane ++;
#line 1465
    if ((int )tiPC == 2) {
#line 1465
      if (! (currentPlane < numcomps___5)) {
#line 1465
        goto while_break___1;
      }
    } else {
#line 1465
      goto while_break___1;
    }
  }
  while_break___7: /* CIL Label */ ;
  }

  while_break___1: 
  {
#line 1501
  free((void *)buffer32s___0);
#line 1502
  _TIFFfree(buf___0);
#line 1503
  TIFFClose(tif___0);
  }
#line 1505
  if (is_cinema) {
#line 1506
    j___15 = 0;
    {
#line 1506
    while (1) {
      while_continue___4: /* CIL Label */ ;

#line 1506
      if (! (j___15 < numcomps___5)) {
#line 1506
        goto while_break___4;
      }
      {
#line 1507
      scale_component(image___15->comps + j___15, (OPJ_UINT32 )12);
#line 1506
      j___15 ++;
      }
    }
    while_break___10: /* CIL Label */ ;
    }

    while_break___4: ;
  }
#line 1511
  return (image___15);
}
}
#line 58 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__)) int _setjmp(struct __jmp_buf_tag *__env ) ;
#line 67
extern  __attribute__((__nothrow__)) void longjmp(struct __jmp_buf_tag *__env , int __val ) ;
#line 929 "/usr/include/png.h"
extern void png_set_sig_bytes(png_structrp png_ptr , int num_bytes ) ;
#line 945
extern png_structp png_create_read_struct(png_const_charp user_png_ver , png_voidp error_ptr ,
                                          void (*error_fn)(png_structp  , png_const_charp  ) ,
                                          void (*warn_fn)(png_structp  , png_const_charp  ) ) ;
#line 951
extern png_structp png_create_write_struct(png_const_charp user_png_ver , png_voidp error_ptr ,
                                           void (*error_fn)(png_structp  , png_const_charp  ) ,
                                           void (*warn_fn)(png_structp  , png_const_charp  ) ) ;
#line 973
extern jmp_buf *png_set_longjmp_fn(png_structrp png_ptr , void (*longjmp_fn)(struct __jmp_buf_tag * ,
                                                                             int  ) ,
                                   size_t jmp_buf_size ) ;
#line 1027
extern png_infop png_create_info_struct(png_const_structrp png_ptr ) ;
#line 1040
extern void png_write_info(png_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1045
extern void png_read_info(png_structrp png_ptr , png_inforp info_ptr ) ;
#line 1074
extern void png_set_expand(png_structrp png_ptr ) ;
#line 1373
extern void png_set_gamma(png_structrp png_ptr , double screen_gamma , double override_file_gamma ) ;
#line 1390
extern void png_read_update_info(png_structrp png_ptr , png_inforp info_ptr ) ;
#line 1407
extern void png_read_image(png_structrp png_ptr , png_bytepp image ) ;
#line 1411
extern void png_write_row(png_structrp png_ptr , png_const_bytep row ) ;
#line 1426
extern void png_write_end(png_structrp png_ptr , png_inforp info_ptr ) ;
#line 1439
extern void png_destroy_read_struct(png_structpp png_ptr_ptr , png_infopp info_ptr_ptr ,
                                    png_infopp end_info_ptr_ptr ) ;
#line 1443
extern void png_destroy_write_struct(png_structpp png_ptr_ptr , png_infopp info_ptr_ptr ) ;
#line 1531
extern void png_set_compression_level(png_structrp png_ptr , int level ) ;
#line 1583
extern void png_init_io(png_structrp png_ptr , png_FILE_p fp ) ;
#line 1861
extern png_uint_32 png_get_valid(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                 png_uint_32 flag ) ;
#line 1865
extern size_t png_get_rowbytes(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1896
extern png_byte png_get_bit_depth(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1900
extern png_byte png_get_color_type(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 2017
extern png_uint_32 png_get_gAMA(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                double *file_gamma ) ;
#line 2038
extern png_uint_32 png_get_IHDR(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                png_uint_32 *width , png_uint_32 *height , int *bit_depth ,
                                int *color_type , int *interlace_method , int *compression_method ,
                                int *filter_method ) ;
#line 2043
extern void png_set_IHDR(png_const_structrp png_ptr , png_inforp info_ptr , png_uint_32 width ,
                         png_uint_32 height , int bit_depth , int color_type , int interlace_method ,
                         int compression_method , int filter_method ) ;
#line 2096
extern void png_set_sBIT(png_const_structrp png_ptr , png_inforp info_ptr , png_const_color_8p sig_bit ) ;
#line 57 "/root/patron-new/39/src/bin/jp2/convertpng.c"
static void convert_16u32s_C1R(OPJ_BYTE *pSrc___21 , OPJ_INT32 *pDst___21 , OPJ_SIZE_T length___21 ) 
{ 
  OPJ_SIZE_T i___117 ;
  OPJ_INT32 val0___12 ;
  OPJ_BYTE *__cil_tmp6___47 ;
  OPJ_INT32 val1___12 ;
  OPJ_BYTE *__cil_tmp8___65 ;

  {
#line 61
  i___117 = (OPJ_SIZE_T )0;
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;

#line 61
    if (! (i___117 < length___21)) {
#line 61
      goto while_break;
    }
#line 62
    __cil_tmp6___47 = pSrc___21;
#line 62
    pSrc___21 ++;
#line 62
    val0___12 = (OPJ_INT32 )*__cil_tmp6___47;
#line 63
    __cil_tmp8___65 = pSrc___21;
#line 63
    pSrc___21 ++;
#line 63
    val1___12 = (OPJ_INT32 )*__cil_tmp8___65;
#line 64
    *(pDst___21 + i___117) = (val0___12 << 8) | val1___12;
#line 61
    i___117 ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 65
  return;
}
}
#line 68 "/root/patron-new/39/src/bin/jp2/convertpng.c"
opj_image_t *pngtoimage(char const   *read_idf , opj_cparameters_t *params ) 
{ 
  png_structp png ;
  png_infop info___1 ;
  double gamma___0 ;
  int bit_depth ;
  int interlace_type ;
  int compression_type ;
  int filter_type ;
  OPJ_UINT32 i___118 ;
  png_uint_32 width___0 ;
  png_uint_32 height___0 ;
  int color_type ;
  FILE *reader ;
  OPJ_BYTE **rows ;
  OPJ_INT32 *row32s ;
  opj_image_t *image___16 ;
  opj_image_cmptparm_t cmptparm___0[4] ;
  OPJ_UINT32 nr_comp ;
  OPJ_BYTE sigbuf[8] ;
  void (*cvtXXTo32s)(OPJ_BYTE * , OPJ_INT32 * , OPJ_SIZE_T  ) ;
  void (*cvtCxToPx___0)(OPJ_INT32 * , OPJ_INT32 * const  * , OPJ_SIZE_T  ) ;
  OPJ_INT32 *planes___1[4] ;
  unsigned long __cil_tmp25___16 ;
  int __cil_tmp26___19 ;
  jmp_buf *__cil_tmp29___10 ;
  int __cil_tmp30___12 ;
  png_uint_32 __cil_tmp31___16 ;
  png_uint_32 __cil_tmp32___17 ;
  png_uint_32 __cil_tmp33___9 ;
  png_byte __cil_tmp34___11 ;
  png_byte __cil_tmp35___15 ;
  void *__cil_tmp36___14 ;
  size_t __cil_tmp37___6 ;
  void *__cil_tmp38___5 ;
  int tmp___467 ;
  opj_image_t *__cil_tmp40___12 ;
  void *__cil_tmp41___3 ;

  {
  {
#line 70
  png = (png_structp )((void *)0);
#line 71
  info___1 = (png_infop )((void *)0);
#line 75
  height___0 = 0U;
#line 77
  reader = (FILE *)((void *)0);
#line 78
  rows = (OPJ_BYTE **)((void *)0);
#line 79
  row32s = (OPJ_INT32 *)((void *)0);
#line 81
  image___16 = (opj_image_t *)((void *)0);
#line 85
  cvtXXTo32s = (void (*)(OPJ_BYTE * , OPJ_INT32 * , OPJ_SIZE_T  ))((void *)0);
#line 86
  cvtCxToPx___0 = (void (*)(OPJ_INT32 * , OPJ_INT32 * const  * , OPJ_SIZE_T  ))((void *)0);
#line 89
  reader = fopen(read_idf, "rb");
  }
#line 89
  if ((unsigned long )reader == (unsigned long )((void *)0)) {
    {
#line 90
    fprintf(stderr, "pngtoimage: can not open %s\n", read_idf);
    }
#line 91
    return ((opj_image_t *)((void *)0));
  }
  {
#line 94
  __cil_tmp26___19 = memcmp((void const   *)(sigbuf), (void const   *)"\211PNG\r\n\032\n\251",
                            8UL);
#line 94
  __cil_tmp25___16 = fread((void *)(sigbuf), 1UL, 8UL, reader);
  }
#line 94
  if (__cil_tmp25___16 != 8UL) {
    {
#line 96
    fprintf(stderr, "pngtoimage: %s is no valid PNG file\n", read_idf);
    }
#line 97
    goto fin;
  } else
#line 94
  if (__cil_tmp26___19 != 0) {
    {
#line 96
    fprintf(stderr, "pngtoimage: %s is no valid PNG file\n", read_idf);
    }
#line 97
    goto fin;
  }
  {
#line 100
  png = png_create_read_struct("1.6.37", (void *)0, (void (*)(png_structp  , png_const_charp  ))((void *)0),
                               (void (*)(png_structp  , png_const_charp  ))((void *)0));
  }
#line 100
  if ((unsigned long )png == (unsigned long )((void *)0)) {
#line 102
    goto fin;
  }
  {
#line 104
  info___1 = png_create_info_struct(png);
  }
#line 104
  if ((unsigned long )info___1 == (unsigned long )((void *)0)) {
#line 105
    goto fin;
  }
  {
#line 108
  __cil_tmp29___10 = png_set_longjmp_fn(png, & longjmp, sizeof(jmp_buf ));
#line 108
  __cil_tmp30___12 = _setjmp(*__cil_tmp29___10);
  }
#line 108
  if (__cil_tmp30___12) {
#line 109
    goto fin;
  }
  {
#line 112
  png_init_io(png, reader);
#line 113
  png_set_sig_bytes(png, 8);
#line 115
  png_read_info(png, info___1);
#line 117
  __cil_tmp31___16 = png_get_IHDR(png, info___1, & width___0, & height___0, & bit_depth,
                                  & color_type, & interlace_type, & compression_type,
                                  & filter_type);
  }
#line 117
  if (__cil_tmp31___16 == 0U) {
#line 120
    goto fin;
  }
#line 128
  if (color_type == 3) {
    {
#line 129
    png_set_expand(png);
    }
  }
  {
#line 132
  __cil_tmp32___17 = png_get_valid(png, info___1, 16U);
  }
#line 132
  if (__cil_tmp32___17) {
    {
#line 133
    png_set_expand(png);
    }
  }
  {
#line 144
  __cil_tmp33___9 = png_get_gAMA(png, info___1, & gamma___0);
  }
#line 144
  if (! __cil_tmp33___9) {
#line 145
    gamma___0 = 1.;
  }
  {
#line 149
  png_set_gamma(png, 1., gamma___0);
#line 151
  png_read_update_info(png, info___1);
#line 153
  __cil_tmp34___11 = png_get_color_type(png, info___1);
#line 153
  color_type = (int )__cil_tmp34___11;
  }
#line 156
  if (color_type == 0) {
#line 156
    goto case_0;
  }
#line 159
  if (color_type == 4) {
#line 159
    goto case_4;
  }
#line 162
  if (color_type == 2) {
#line 162
    goto case_2;
  }
#line 165
  if (color_type == 6) {
#line 165
    goto case_6;
  }
#line 168
  goto switch_default;
  case_0: 
#line 157
  nr_comp = (OPJ_UINT32 )1;
#line 158
  goto switch_break;
  case_4: 
#line 160
  nr_comp = (OPJ_UINT32 )2;
#line 161
  goto switch_break;
  case_2: 
#line 163
  nr_comp = (OPJ_UINT32 )3;
#line 164
  goto switch_break;
  case_6: 
#line 166
  nr_comp = (OPJ_UINT32 )4;
#line 167
  goto switch_break;
  switch_default: 
  {
#line 169
  fprintf(stderr, "pngtoimage: colortype %d is not supported\n", color_type);
  }
#line 170
  goto fin;
  switch_break: 
  {
#line 172
  cvtCxToPx___0 = convert_32s_CXPX_LUT[nr_comp];
#line 173
  __cil_tmp35___15 = png_get_bit_depth(png, info___1);
#line 173
  bit_depth = (int )__cil_tmp35___15;
  }
#line 179
  if (bit_depth == 8) {
#line 179
    goto case_8;
  }
#line 179
  if (bit_depth == 4) {
#line 179
    goto case_8;
  }
#line 179
  if (bit_depth == 2) {
#line 179
    goto case_8;
  }
#line 179
  if (bit_depth == 1) {
#line 179
    goto case_8;
  }
#line 182
  if (bit_depth == 16) {
#line 182
    goto case_16;
  }
#line 185
  goto switch_default___0;
  case_8: 
#line 180
  cvtXXTo32s = convert_XXu32s_C1R_LUT[bit_depth];
#line 181
  goto switch_break___0;
  case_16: 
#line 183
  cvtXXTo32s = & convert_16u32s_C1R;
#line 184
  goto switch_break___0;
  switch_default___0: 
  {
#line 186
  fprintf(stderr, "pngtoimage: bit depth %d is not supported\n", bit_depth);
  }
#line 187
  goto fin;
  switch_break___0: 
  {
#line 191
  __cil_tmp36___14 = calloc((unsigned long )(height___0 + 1U), sizeof(OPJ_BYTE *));
#line 191
  rows = (OPJ_BYTE **)__cil_tmp36___14;
  }
#line 192
  if ((unsigned long )rows == (unsigned long )((void *)0)) {
    {
#line 193
    fprintf(stderr, "pngtoimage: memory out\n");
    }
#line 194
    goto fin;
  }
#line 196
  i___118 = (OPJ_UINT32 )0;
  {
#line 196
  while (1) {
    while_continue: /* CIL Label */ ;

#line 196
    if (! (i___118 < height___0)) {
#line 196
      goto while_break;
    }
    {
#line 197
    __cil_tmp37___6 = png_get_rowbytes(png, info___1);
#line 197
    __cil_tmp38___5 = malloc(__cil_tmp37___6);
#line 197
    *(rows + i___118) = (OPJ_BYTE *)__cil_tmp38___5;
    }
#line 198
    if ((unsigned long )*(rows + i___118) == (unsigned long )((void *)0)) {
      {
#line 199
      fprintf(stderr, "pngtoimage: memory out\n");
      }
#line 200
      goto fin;
    }
#line 196
    i___118 ++;
  }
  while_break___4: /* CIL Label */ ;
  }

  while_break: 
  {
#line 203
  png_read_image(png, rows);
#line 206
  memset((void *)(cmptparm___0), 0, sizeof(cmptparm___0));
#line 207
  i___118 = (OPJ_UINT32 )0;
  }
  {
#line 207
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 207
    if (! (i___118 < nr_comp)) {
#line 207
      goto while_break___0;
    }
#line 208
    cmptparm___0[i___118].prec = (OPJ_UINT32 )bit_depth;
#line 210
    cmptparm___0[i___118].bpp = (OPJ_UINT32 )bit_depth;
#line 211
    cmptparm___0[i___118].sgnd = (OPJ_UINT32 )0;
#line 212
    cmptparm___0[i___118].dx = (OPJ_UINT32 )params->subsampling_dx;
#line 213
    cmptparm___0[i___118].dy = (OPJ_UINT32 )params->subsampling_dy;
#line 214
    cmptparm___0[i___118].w = width___0;
#line 215
    cmptparm___0[i___118].h = height___0;
#line 207
    i___118 ++;
  }
  while_break___5: /* CIL Label */ ;
  }

  while_break___0: ;
#line 218
  if (nr_comp > 2U) {
#line 218
    tmp___467 = 1;
  } else {
#line 218
    tmp___467 = 2;
  }
  {
#line 218
  __cil_tmp40___12 = opj_image_create(nr_comp, & cmptparm___0[0], (OPJ_COLOR_SPACE )tmp___467);
#line 218
  image___16 = __cil_tmp40___12;
  }
#line 220
  if ((unsigned long )image___16 == (unsigned long )((void *)0)) {
#line 221
    goto fin;
  }
  {
#line 223
  image___16->x0 = (OPJ_UINT32 )params->image_offset_x0;
#line 224
  image___16->y0 = (OPJ_UINT32 )params->image_offset_y0;
#line 225
  image___16->x1 = ((image___16->x0 + (width___0 - 1U) * (OPJ_UINT32 )params->subsampling_dx) + 1U) + image___16->x0;
#line 227
  image___16->y1 = ((image___16->y0 + (height___0 - 1U) * (OPJ_UINT32 )params->subsampling_dy) + 1U) + image___16->y0;
#line 230
  __cil_tmp41___3 = malloc(((size_t )width___0 * (unsigned long )nr_comp) * sizeof(OPJ_INT32 ));
#line 230
  row32s = (OPJ_INT32 *)__cil_tmp41___3;
  }
#line 231
  if ((unsigned long )row32s == (unsigned long )((void *)0)) {
#line 232
    goto fin;
  }
#line 236
  (image___16->comps + (nr_comp - 1U))->alpha = (OPJ_UINT16 )(1U - (nr_comp & 1U));
#line 238
  i___118 = (OPJ_UINT32 )0;
  {
#line 238
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 238
    if (! (i___118 < nr_comp)) {
#line 238
      goto while_break___1;
    }
#line 239
    planes___1[i___118] = (image___16->comps + i___118)->data;
#line 238
    i___118 ++;
  }
  while_break___6: /* CIL Label */ ;
  }

  while_break___1: 
#line 242
  i___118 = (OPJ_UINT32 )0;
  {
#line 242
  while (1) {
    while_continue___2: /* CIL Label */ ;

#line 242
    if (! (i___118 < height___0)) {
#line 242
      goto while_break___2;
    }
    {
#line 243
    (*cvtXXTo32s)(*(rows + i___118), row32s, (OPJ_SIZE_T )width___0 * (unsigned long )nr_comp);
#line 244
    (*cvtCxToPx___0)(row32s, (OPJ_INT32 * const  *)(planes___1), (OPJ_SIZE_T )width___0);
#line 245
    planes___1[0] += width___0;
#line 246
    planes___1[1] += width___0;
#line 247
    planes___1[2] += width___0;
#line 248
    planes___1[3] += width___0;
#line 242
    i___118 ++;
    }
  }
  while_break___7: /* CIL Label */ ;
  }

  while_break___2: ;
  fin: 
#line 251
  if (rows) {
#line 252
    i___118 = (OPJ_UINT32 )0;
    {
#line 252
    while (1) {
      while_continue___3: /* CIL Label */ ;

#line 252
      if (! (i___118 < height___0)) {
#line 252
        goto while_break___3;
      }
#line 253
      if (*(rows + i___118)) {
        {
#line 254
        free((void *)*(rows + i___118));
        }
      }
#line 252
      i___118 ++;
    }
    while_break___8: /* CIL Label */ ;
    }

    while_break___3: 
    {
#line 256
    free((void *)rows);
    }
  }
#line 258
  if (row32s) {
    {
#line 259
    free((void *)row32s);
    }
  }
#line 261
  if (png) {
    {
#line 262
    png_destroy_read_struct(& png, & info___1, (png_infopp )((void *)0));
    }
  }
  {
#line 265
  fclose(reader);
  }
#line 267
  return (image___16);
}
}
#line 272 "/root/patron-new/39/src/bin/jp2/convertpng.c"
static void convert_32s16u_C1R(OPJ_INT32 *pSrc___22 , OPJ_BYTE *pDst___22 , OPJ_SIZE_T length___22 ) 
{ 
  OPJ_SIZE_T i___119 ;
  OPJ_UINT32 val___6 ;
  OPJ_BYTE *__cil_tmp6___48 ;
  OPJ_BYTE *__cil_tmp7___48 ;

  {
#line 276
  i___119 = (OPJ_SIZE_T )0;
  {
#line 276
  while (1) {
    while_continue: /* CIL Label */ ;

#line 276
    if (! (i___119 < length___22)) {
#line 276
      goto while_break;
    }
#line 277
    val___6 = (OPJ_UINT32 )*(pSrc___22 + i___119);
#line 278
    __cil_tmp6___48 = pDst___22;
#line 278
    pDst___22 ++;
#line 278
    *__cil_tmp6___48 = (OPJ_BYTE )(val___6 >> 8);
#line 279
    __cil_tmp7___48 = pDst___22;
#line 279
    pDst___22 ++;
#line 279
    *__cil_tmp7___48 = (OPJ_BYTE )val___6;
#line 276
    i___119 ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 280
  return;
}
}
#line 282 "/root/patron-new/39/src/bin/jp2/convertpng.c"
int imagetopng(opj_image_t *image___17 , char const   *write_idf ) 
{ 
  FILE *writer ;
  png_structp png___0 ;
  png_infop info___2 ;
  png_bytep row_buf ;
  int nr_comp___0 ;
  int color_type___0 ;
  int prec ;
  png_color_8 sig_bit ;
  OPJ_INT32 *planes___2[4] ;
  int i___120 ;
  OPJ_INT32 *buffer32s___1 ;
  int fails ;
  jmp_buf *__cil_tmp19___31 ;
  int __cil_tmp20___37 ;
  OPJ_SIZE_T rowStride___1 ;
  png_size_t png_row_size ;
  void *__cil_tmp24___27 ;
  void *__cil_tmp25___17 ;
  OPJ_SIZE_T width___1 ;
  OPJ_UINT32 y ;
  void (*cvtPxToCx___0)(OPJ_INT32 * const  * , OPJ_INT32 * , OPJ_SIZE_T  , OPJ_INT32  ) ;
  void (*cvt32sToPack)(OPJ_INT32 * , OPJ_BYTE * , OPJ_SIZE_T  ) ;
  OPJ_INT32 adjust___0 ;
  int tmp___468 ;
  png_bytep row_buf_cpy ;
  OPJ_INT32 *buffer32s_cpy ;

  {
  {
#line 284
  writer = (FILE *)((void *)0);
#line 285
  png___0 = (png_structp )((void *)0);
#line 286
  info___2 = (png_infop )((void *)0);
#line 287
  row_buf = (png_bytep )((void *)0);
#line 293
  buffer32s___1 = (OPJ_INT32 *)((void *)0);
#line 295
  fails = 1;
#line 297
  memset((void *)(& sig_bit), 0, sizeof(sig_bit));
#line 298
  prec = (int )(image___17->comps + 0)->prec;
#line 299
  planes___2[0] = (image___17->comps + 0)->data;
  }
#line 300
  if ((unsigned long )planes___2[0] == (unsigned long )((void *)0)) {
    {
#line 301
    fprintf(stderr, "imagetopng: planes[%d] == NULL.\n\251", 0);
#line 303
    fprintf(stderr, "\tAborting\n");
    }
#line 304
    return (1);
  }
#line 306
  nr_comp___0 = (int )image___17->numcomps;
#line 308
  if (nr_comp___0 > 4) {
#line 309
    nr_comp___0 = 4;
  }
#line 311
  i___120 = 1;
  {
#line 311
  while (1) {
    while_continue: /* CIL Label */ ;

#line 311
    if (! (i___120 < nr_comp___0)) {
#line 311
      goto while_break;
    }
#line 312
    if ((image___17->comps + 0)->dx != (image___17->comps + i___120)->dx) {
#line 313
      goto while_break;
    }
#line 315
    if ((image___17->comps + 0)->dy != (image___17->comps + i___120)->dy) {
#line 316
      goto while_break;
    }
#line 318
    if ((image___17->comps + 0)->prec != (image___17->comps + i___120)->prec) {
#line 319
      goto while_break;
    }
#line 321
    if ((image___17->comps + 0)->sgnd != (image___17->comps + i___120)->sgnd) {
#line 322
      goto while_break;
    }
#line 324
    planes___2[i___120] = (image___17->comps + i___120)->data;
#line 325
    if ((unsigned long )planes___2[i___120] == (unsigned long )((void *)0)) {
      {
#line 326
      fprintf(stderr, "imagetopng: planes[%d] == NULL.\n\230\001", i___120);
#line 328
      fprintf(stderr, "\tAborting\n\206\006]U");
      }
#line 329
      return (1);
    }
#line 311
    i___120 ++;
  }
  while_break___5: /* CIL Label */ ;
  }

  while_break: ;
#line 332
  if (i___120 != nr_comp___0) {
    {
#line 333
    fprintf(stderr, "imagetopng: All components shall have the same subsampling, same bit depth, same sign.\n");
#line 335
    fprintf(stderr, "\tAborting\n\205\006]U");
    }
#line 336
    return (1);
  }
#line 338
  i___120 = 0;
  {
#line 338
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 338
    if (! (i___120 < nr_comp___0)) {
#line 338
      goto while_break___0;
    }
    {
#line 339
    clip_component(image___17->comps + i___120, (image___17->comps + 0)->prec);
#line 338
    i___120 ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }

  while_break___0: ;
#line 341
  if (prec > 8) {
#line 341
    if (prec < 16) {
#line 342
      i___120 = 0;
      {
#line 342
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 342
        if (! (i___120 < nr_comp___0)) {
#line 342
          goto while_break___1;
        }
        {
#line 343
        scale_component(image___17->comps + i___120, (OPJ_UINT32 )16);
#line 342
        i___120 ++;
        }
      }
      while_break___7: /* CIL Label */ ;
      }

      while_break___1: 
#line 345
      prec = 16;
    } else {
#line 341
      goto _L___36;
    }
  } else
  _L___36: 
#line 346
  if (prec < 8) {
#line 346
    if (nr_comp___0 > 1) {
#line 347
      i___120 = 0;
      {
#line 347
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 347
        if (! (i___120 < nr_comp___0)) {
#line 347
          goto while_break___2;
        }
        {
#line 348
        scale_component(image___17->comps + i___120, (OPJ_UINT32 )8);
#line 347
        i___120 ++;
        }
      }
      while_break___8: /* CIL Label */ ;
      }

      while_break___2: 
#line 350
      prec = 8;
    } else {
#line 346
      goto _L___35;
    }
  } else
  _L___35: 
#line 351
  if (prec > 1) {
#line 351
    if (prec < 8) {
#line 351
      if (prec == 6) {
        _L: 
#line 353
        if (prec == 5) {
#line 354
          prec = 8;
        } else
#line 353
        if (prec == 6) {
#line 354
          prec = 8;
        } else {
#line 356
          prec ++;
        }
#line 358
        i___120 = 0;
        {
#line 358
        while (1) {
          while_continue___3: /* CIL Label */ ;

#line 358
          if (! (i___120 < nr_comp___0)) {
#line 358
            goto while_break___3;
          }
          {
#line 359
          scale_component(image___17->comps + i___120, (OPJ_UINT32 )prec);
#line 358
          i___120 ++;
          }
        }
        while_break___9: /* CIL Label */ ;
        }

        while_break___3: ;
      } else
#line 351
      if ((prec & 1) == 1) {
#line 351
        goto _L;
      }
    }
  }
#line 363
  if (prec != 1) {
#line 363
    if (prec != 2) {
#line 363
      if (prec != 4) {
#line 363
        if (prec != 8) {
#line 363
          if (prec != 16) {
            {
#line 364
            fprintf(stderr, "imagetopng: can not create %s\n\twrong bit_depth %d\n",
                    write_idf, prec);
            }
#line 366
            return (fails);
          }
        }
      }
    }
  }
  {
#line 369
  writer = fopen(write_idf, "wb\205\006]U");
  }
#line 371
  if ((unsigned long )writer == (unsigned long )((void *)0)) {
#line 372
    return (fails);
  }
  {
#line 381
  png___0 = png_create_write_struct("1.6.37", (void *)0, (void (*)(png_structp  ,
                                                                   png_const_charp  ))((void *)0),
                                    (void (*)(png_structp  , png_const_charp  ))((void *)0));
  }
#line 385
  if ((unsigned long )png___0 == (unsigned long )((void *)0)) {
#line 386
    goto fin;
  }
  {
#line 391
  info___2 = png_create_info_struct(png___0);
  }
#line 393
  if ((unsigned long )info___2 == (unsigned long )((void *)0)) {
#line 394
    goto fin;
  }
  {
#line 400
  __cil_tmp19___31 = png_set_longjmp_fn(png___0, & longjmp, sizeof(jmp_buf ));
#line 400
  __cil_tmp20___37 = _setjmp(*__cil_tmp19___31);
  }
#line 400
  if (__cil_tmp20___37) {
#line 401
    goto fin;
  }
  {
#line 406
  png_init_io(png___0, writer);
#line 425
  png_set_compression_level(png___0, 9);
  }
#line 427
  if (nr_comp___0 >= 3) {
#line 428
    color_type___0 = 2;
#line 429
    sig_bit.blue = (png_byte )prec;
#line 429
    sig_bit.green = sig_bit.blue;
#line 429
    sig_bit.red = sig_bit.green;
  } else {
#line 431
    color_type___0 = 0;
#line 432
    sig_bit.gray = (png_byte )prec;
  }
#line 434
  if ((nr_comp___0 & 1) == 0) {
#line 435
    color_type___0 |= 4;
#line 436
    sig_bit.alpha = (png_byte )prec;
  }
  {
#line 439
  png_set_IHDR(png___0, info___2, (image___17->comps + 0)->w, (image___17->comps + 0)->h,
               prec, color_type___0, 0, 0, 0);
#line 442
  png_set_sBIT(png___0, info___2, & sig_bit);
#line 445
  png_write_info(png___0, info___2);
#line 452
  png_row_size = png_get_rowbytes(png___0, info___2);
#line 453
  rowStride___1 = (((OPJ_SIZE_T )(image___17->comps + 0)->w * (OPJ_SIZE_T )nr_comp___0) * (OPJ_SIZE_T )prec + 7UL) / 8UL;
  }
#line 455
  if (rowStride___1 != png_row_size) {
    {
#line 456
    fprintf(stderr, "Invalid PNG row size\nU");
    }
#line 457
    goto fin;
  }
  {
#line 459
  __cil_tmp24___27 = malloc(png_row_size);
#line 459
  row_buf = (png_bytep )__cil_tmp24___27;
  }
#line 460
  if ((unsigned long )row_buf == (unsigned long )((void *)0)) {
    {
#line 461
    fprintf(stderr, "Can\'t allocate memory for PNG row\n");
    }
#line 462
    goto fin;
  }
  {
#line 464
  __cil_tmp25___17 = malloc(((OPJ_SIZE_T )(image___17->comps + 0)->w * (OPJ_SIZE_T )nr_comp___0) * sizeof(OPJ_INT32 ));
#line 464
  buffer32s___1 = (OPJ_INT32 *)__cil_tmp25___17;
  }
#line 466
  if ((unsigned long )buffer32s___1 == (unsigned long )((void *)0)) {
    {
#line 467
    fprintf(stderr, "Can\'t allocate memory for interleaved 32s row\n");
    }
#line 468
    goto fin;
  }
#line 474
  width___1 = (OPJ_SIZE_T )(image___17->comps + 0)->w;
#line 476
  cvtPxToCx___0 = convert_32s_PXCX_LUT[nr_comp___0];
#line 477
  cvt32sToPack = (void (*)(OPJ_INT32 * , OPJ_BYTE * , OPJ_SIZE_T  ))((void *)0);
#line 478
  if ((image___17->comps + 0)->sgnd) {
#line 478
    tmp___468 = 1 << (prec - 1);
  } else {
#line 478
    tmp___468 = 0;
  }
#line 478
  adjust___0 = tmp___468;
#line 479
  row_buf_cpy = row_buf;
#line 480
  buffer32s_cpy = buffer32s___1;
#line 486
  if (prec == 8) {
#line 486
    goto case_8;
  }
#line 486
  if (prec == 4) {
#line 486
    goto case_8;
  }
#line 486
  if (prec == 2) {
#line 486
    goto case_8;
  }
#line 486
  if (prec == 1) {
#line 486
    goto case_8;
  }
#line 489
  if (prec == 16) {
#line 489
    goto case_16;
  }
#line 492
  goto switch_default;
  case_8: 
#line 487
  cvt32sToPack = convert_32sXXu_C1R_LUT[prec];
#line 488
  goto switch_break;
  case_16: 
#line 490
  cvt32sToPack = & convert_32s16u_C1R;
#line 491
  goto switch_break;
  switch_default: 
#line 494
  goto switch_break;
  switch_break: 
#line 497
  y = (OPJ_UINT32 )0;
  {
#line 497
  while (1) {
    while_continue___4: /* CIL Label */ ;

#line 497
    if (! (y < (image___17->comps + 0)->h)) {
#line 497
      goto while_break___4;
    }
    {
#line 498
    (*cvtPxToCx___0)((OPJ_INT32 * const  *)(planes___2), buffer32s_cpy, width___1,
                     adjust___0);
#line 499
    (*cvt32sToPack)(buffer32s_cpy, row_buf_cpy, width___1 * (OPJ_SIZE_T )nr_comp___0);
#line 500
    png_write_row(png___0, row_buf_cpy);
#line 501
    planes___2[0] += width___1;
#line 502
    planes___2[1] += width___1;
#line 503
    planes___2[2] += width___1;
#line 504
    planes___2[3] += width___1;
#line 497
    y ++;
    }
  }
  while_break___10: /* CIL Label */ ;
  }

  while_break___4: 
  {
#line 508
  png_write_end(png___0, info___2);
#line 510
  fails = 0;
  }
  fin: 
#line 513
  if (png___0) {
    {
#line 514
    png_destroy_write_struct(& png___0, & info___2);
    }
  }
#line 516
  if (row_buf) {
    {
#line 517
    free((void *)row_buf);
    }
  }
#line 519
  if (buffer32s___1) {
    {
#line 520
    free((void *)buffer32s___1);
    }
  }
  {
#line 522
  fclose(writer);
  }
#line 524
  if (fails) {
    {
#line 525
    remove(write_idf);
    }
  }
#line 528
  return (fails);
}
}
#line 83 "/root/patron-new/39/src/bin/jp2/convertbmp.c"
static void opj_applyLUT8u_8u32s_C1R(OPJ_UINT8 *pSrc___23 , OPJ_INT32 srcStride ,
                                     OPJ_INT32 *pDst___23 , OPJ_INT32 dstStride ,
                                     OPJ_UINT8 *pLUT , OPJ_UINT32 width___2 , OPJ_UINT32 height___1 ) 
{ 
  OPJ_UINT32 y___0 ;
  OPJ_UINT32 x ;

  {
#line 91
  y___0 = height___1;
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;

#line 91
    if (! (y___0 != 0U)) {
#line 91
      goto while_break;
    }
#line 94
    x = (OPJ_UINT32 )0;
    {
#line 94
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 94
      if (! (x < width___2)) {
#line 94
        goto while_break___0;
      }
#line 95
      *(pDst___23 + x) = (OPJ_INT32 )*(pLUT + (int )*(pSrc___23 + x));
#line 94
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }

    while_break___0: 
#line 97
    pSrc___23 += srcStride;
#line 98
    pDst___23 += dstStride;
#line 91
    y___0 --;
  }
  while_break___1: /* CIL Label */ ;
  }

  while_break: ;
#line 95
  return;
}
}
#line 102 "/root/patron-new/39/src/bin/jp2/convertbmp.c"
static void opj_applyLUT8u_8u32s_C1P3R(OPJ_UINT8 *pSrc___24 , OPJ_INT32 srcStride___0 ,
                                       OPJ_INT32 * const  *pDst___24 , OPJ_INT32 *pDstStride ,
                                       OPJ_UINT8 * const  *pLUT___0 , OPJ_UINT32 width___3 ,
                                       OPJ_UINT32 height___2 ) 
{ 
  OPJ_UINT32 y___1 ;
  OPJ_INT32 *pR ;
  OPJ_INT32 *pG ;
  OPJ_INT32 *pB ;
  OPJ_UINT8 *pLUT_R ;
  OPJ_UINT8 *pLUT_G ;
  OPJ_UINT8 *pLUT_B ;
  OPJ_UINT32 x___0 ;
  OPJ_UINT8 idx ;

  {
#line 109
  pR = (OPJ_INT32 *)*(pDst___24 + 0);
#line 110
  pG = (OPJ_INT32 *)*(pDst___24 + 1);
#line 111
  pB = (OPJ_INT32 *)*(pDst___24 + 2);
#line 112
  pLUT_R = (OPJ_UINT8 *)*(pLUT___0 + 0);
#line 113
  pLUT_G = (OPJ_UINT8 *)*(pLUT___0 + 1);
#line 114
  pLUT_B = (OPJ_UINT8 *)*(pLUT___0 + 2);
#line 116
  y___1 = height___2;
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;

#line 116
    if (! (y___1 != 0U)) {
#line 116
      goto while_break;
    }
#line 119
    x___0 = (OPJ_UINT32 )0;
    {
#line 119
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 119
      if (! (x___0 < width___3)) {
#line 119
        goto while_break___0;
      }
#line 120
      idx = *(pSrc___24 + x___0);
#line 121
      *(pR + x___0) = (OPJ_INT32 )*(pLUT_R + (int )idx);
#line 122
      *(pG + x___0) = (OPJ_INT32 )*(pLUT_G + (int )idx);
#line 123
      *(pB + x___0) = (OPJ_INT32 )*(pLUT_B + (int )idx);
#line 119
      x___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }

    while_break___0: 
#line 125
    pSrc___24 += srcStride___0;
#line 126
    pR += *(pDstStride + 0);
#line 127
    pG += *(pDstStride + 1);
#line 128
    pB += *(pDstStride + 2);
#line 116
    y___1 --;
  }
  while_break___1: /* CIL Label */ ;
  }

  while_break: ;
#line 120
  return;
}
}
#line 132 "/root/patron-new/39/src/bin/jp2/convertbmp.c"
static void bmp24toimage(OPJ_UINT8 *pData , OPJ_UINT32 stride , opj_image_t *image___18 ) 
{ 
  int index___1 ;
  OPJ_UINT32 width___4 ;
  OPJ_UINT32 height___3 ;
  OPJ_UINT32 x___1 ;
  OPJ_UINT32 y___2 ;
  OPJ_UINT8 *pSrc___25 ;

  {
#line 138
  pSrc___25 = (OPJ_UINT8 *)((void *)0);
#line 140
  width___4 = (image___18->comps + 0)->w;
#line 141
  height___3 = (image___18->comps + 0)->h;
#line 143
  index___1 = 0;
#line 144
  pSrc___25 = pData + (height___3 - 1U) * stride;
#line 145
  y___2 = (OPJ_UINT32 )0;
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;

#line 145
    if (! (y___2 < height___3)) {
#line 145
      goto while_break;
    }
#line 146
    x___1 = (OPJ_UINT32 )0;
    {
#line 146
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 146
      if (! (x___1 < width___4)) {
#line 146
        goto while_break___0;
      }
#line 147
      *((image___18->comps + 0)->data + index___1) = (OPJ_INT32 )*(pSrc___25 + (3U * x___1 + 2U));
#line 148
      *((image___18->comps + 1)->data + index___1) = (OPJ_INT32 )*(pSrc___25 + (3U * x___1 + 1U));
#line 149
      *((image___18->comps + 2)->data + index___1) = (OPJ_INT32 )*(pSrc___25 + 3U * x___1);
#line 150
      index___1 ++;
#line 146
      x___1 ++;
    }
    while_break___2: /* CIL Label */ ;
    }

    while_break___0: 
#line 152
    pSrc___25 -= stride;
#line 145
    y___2 ++;
  }
  while_break___1: /* CIL Label */ ;
  }

  while_break: ;
#line 149
  return;
}
}
#line 156 "/root/patron-new/39/src/bin/jp2/convertbmp.c"
static void bmp_mask_get_shift_and_prec(OPJ_UINT32 mask , OPJ_UINT32 *shift , OPJ_UINT32 *prec___0 ) 
{ 
  OPJ_UINT32 l_shift ;
  OPJ_UINT32 l_prec ;

  {
#line 161
  l_prec = 0U;
#line 161
  l_shift = l_prec;
#line 163
  if (mask != 0U) {
    {
#line 164
    while (1) {
      while_continue: /* CIL Label */ ;

#line 164
      if (! ((mask & 1U) == 0U)) {
#line 164
        goto while_break;
      }
#line 165
      mask >>= 1;
#line 166
      l_shift ++;
    }
    while_break___1: /* CIL Label */ ;
    }

    while_break: ;
    {
#line 168
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 168
      if (! (mask & 1U)) {
#line 168
        goto while_break___0;
      }
#line 169
      mask >>= 1;
#line 170
      l_prec ++;
    }
    while_break___2: /* CIL Label */ ;
    }

    while_break___0: ;
  }
#line 173
  *shift = l_shift;
#line 174
  *prec___0 = l_prec;
#line 175
  return;
}
}
#line 177 "/root/patron-new/39/src/bin/jp2/convertbmp.c"
static void bmpmask32toimage(OPJ_UINT8 *pData___0 , OPJ_UINT32 stride___0 , opj_image_t *image___19 ,
                             OPJ_UINT32 redMask , OPJ_UINT32 greenMask , OPJ_UINT32 blueMask ,
                             OPJ_UINT32 alphaMask ) 
{ 
  int index___2 ;
  OPJ_UINT32 width___5 ;
  OPJ_UINT32 height___4 ;
  OPJ_UINT32 x___2 ;
  OPJ_UINT32 y___3 ;
  OPJ_UINT8 *pSrc___26 ;
  OPJ_BOOL hasAlpha ;
  OPJ_UINT32 redShift ;
  OPJ_UINT32 redPrec ;
  OPJ_UINT32 greenShift ;
  OPJ_UINT32 greenPrec ;
  OPJ_UINT32 blueShift ;
  OPJ_UINT32 bluePrec ;
  OPJ_UINT32 alphaShift ;
  OPJ_UINT32 alphaPrec ;
  OPJ_UINT32 value ;

  {
  {
#line 184
  pSrc___26 = (OPJ_UINT8 *)((void *)0);
#line 191
  width___5 = (image___19->comps + 0)->w;
#line 192
  height___4 = (image___19->comps + 0)->h;
#line 194
  hasAlpha = image___19->numcomps > 3U;
#line 196
  bmp_mask_get_shift_and_prec(redMask, & redShift, & redPrec);
#line 197
  bmp_mask_get_shift_and_prec(greenMask, & greenShift, & greenPrec);
#line 198
  bmp_mask_get_shift_and_prec(blueMask, & blueShift, & bluePrec);
#line 199
  bmp_mask_get_shift_and_prec(alphaMask, & alphaShift, & alphaPrec);
#line 201
  (image___19->comps + 0)->bpp = redPrec;
#line 202
  (image___19->comps + 0)->prec = redPrec;
#line 203
  (image___19->comps + 1)->bpp = greenPrec;
#line 204
  (image___19->comps + 1)->prec = greenPrec;
#line 205
  (image___19->comps + 2)->bpp = bluePrec;
#line 206
  (image___19->comps + 2)->prec = bluePrec;
  }
#line 207
  if (hasAlpha) {
#line 208
    (image___19->comps + 3)->bpp = alphaPrec;
#line 209
    (image___19->comps + 3)->prec = alphaPrec;
  }
#line 212
  index___2 = 0;
#line 213
  pSrc___26 = pData___0 + (height___4 - 1U) * stride___0;
#line 214
  y___3 = (OPJ_UINT32 )0;
  {
#line 214
  while (1) {
    while_continue: /* CIL Label */ ;

#line 214
    if (! (y___3 < height___4)) {
#line 214
      goto while_break;
    }
#line 215
    x___2 = (OPJ_UINT32 )0;
    {
#line 215
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 215
      if (! (x___2 < width___5)) {
#line 215
        goto while_break___0;
      }
#line 216
      value = 0U;
#line 218
      value |= (OPJ_UINT32 )*(pSrc___26 + 4U * x___2);
#line 219
      value |= (OPJ_UINT32 )*(pSrc___26 + (4U * x___2 + 1U)) << 8;
#line 220
      value |= (OPJ_UINT32 )*(pSrc___26 + (4U * x___2 + 2U)) << 16;
#line 221
      value |= (OPJ_UINT32 )*(pSrc___26 + (4U * x___2 + 3U)) << 24;
#line 223
      *((image___19->comps + 0)->data + index___2) = (OPJ_INT32 )((value & redMask) >> redShift);
#line 225
      *((image___19->comps + 1)->data + index___2) = (OPJ_INT32 )((value & greenMask) >> greenShift);
#line 227
      *((image___19->comps + 2)->data + index___2) = (OPJ_INT32 )((value & blueMask) >> blueShift);
#line 229
      if (hasAlpha) {
#line 230
        *((image___19->comps + 3)->data + index___2) = (OPJ_INT32 )((value & alphaMask) >> alphaShift);
      }
#line 233
      index___2 ++;
#line 215
      x___2 ++;
    }
    while_break___2: /* CIL Label */ ;
    }

    while_break___0: 
#line 235
    pSrc___26 -= stride___0;
#line 214
    y___3 ++;
  }
  while_break___1: /* CIL Label */ ;
  }

  while_break: ;
#line 218
  return;
}
}
#line 239 "/root/patron-new/39/src/bin/jp2/convertbmp.c"
static void bmpmask16toimage(OPJ_UINT8 *pData___1 , OPJ_UINT32 stride___1 , opj_image_t *image___20 ,
                             OPJ_UINT32 redMask___0 , OPJ_UINT32 greenMask___0 , OPJ_UINT32 blueMask___0 ,
                             OPJ_UINT32 alphaMask___0 ) 
{ 
  int index___3 ;
  OPJ_UINT32 width___6 ;
  OPJ_UINT32 height___5 ;
  OPJ_UINT32 x___3 ;
  OPJ_UINT32 y___4 ;
  OPJ_UINT8 *pSrc___27 ;
  OPJ_BOOL hasAlpha___0 ;
  OPJ_UINT32 redShift___0 ;
  OPJ_UINT32 redPrec___0 ;
  OPJ_UINT32 greenShift___0 ;
  OPJ_UINT32 greenPrec___0 ;
  OPJ_UINT32 blueShift___0 ;
  OPJ_UINT32 bluePrec___0 ;
  OPJ_UINT32 alphaShift___0 ;
  OPJ_UINT32 alphaPrec___0 ;
  OPJ_UINT32 value___0 ;

  {
  {
#line 246
  pSrc___27 = (OPJ_UINT8 *)((void *)0);
#line 253
  width___6 = (image___20->comps + 0)->w;
#line 254
  height___5 = (image___20->comps + 0)->h;
#line 256
  hasAlpha___0 = image___20->numcomps > 3U;
#line 258
  bmp_mask_get_shift_and_prec(redMask___0, & redShift___0, & redPrec___0);
#line 259
  bmp_mask_get_shift_and_prec(greenMask___0, & greenShift___0, & greenPrec___0);
#line 260
  bmp_mask_get_shift_and_prec(blueMask___0, & blueShift___0, & bluePrec___0);
#line 261
  bmp_mask_get_shift_and_prec(alphaMask___0, & alphaShift___0, & alphaPrec___0);
#line 263
  (image___20->comps + 0)->bpp = redPrec___0;
#line 264
  (image___20->comps + 0)->prec = redPrec___0;
#line 265
  (image___20->comps + 1)->bpp = greenPrec___0;
#line 266
  (image___20->comps + 1)->prec = greenPrec___0;
#line 267
  (image___20->comps + 2)->bpp = bluePrec___0;
#line 268
  (image___20->comps + 2)->prec = bluePrec___0;
  }
#line 269
  if (hasAlpha___0) {
#line 270
    (image___20->comps + 3)->bpp = alphaPrec___0;
#line 271
    (image___20->comps + 3)->prec = alphaPrec___0;
  }
#line 274
  index___3 = 0;
#line 275
  pSrc___27 = pData___1 + (height___5 - 1U) * stride___1;
#line 276
  y___4 = (OPJ_UINT32 )0;
  {
#line 276
  while (1) {
    while_continue: /* CIL Label */ ;

#line 276
    if (! (y___4 < height___5)) {
#line 276
      goto while_break;
    }
#line 277
    x___3 = (OPJ_UINT32 )0;
    {
#line 277
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 277
      if (! (x___3 < width___6)) {
#line 277
        goto while_break___0;
      }
#line 278
      value___0 = 0U;
#line 280
      value___0 |= (OPJ_UINT32 )*(pSrc___27 + 2U * x___3);
#line 281
      value___0 |= (OPJ_UINT32 )*(pSrc___27 + (2U * x___3 + 1U)) << 8;
#line 283
      *((image___20->comps + 0)->data + index___3) = (OPJ_INT32 )((value___0 & redMask___0) >> redShift___0);
#line 285
      *((image___20->comps + 1)->data + index___3) = (OPJ_INT32 )((value___0 & greenMask___0) >> greenShift___0);
#line 287
      *((image___20->comps + 2)->data + index___3) = (OPJ_INT32 )((value___0 & blueMask___0) >> blueShift___0);
#line 289
      if (hasAlpha___0) {
#line 290
        *((image___20->comps + 3)->data + index___3) = (OPJ_INT32 )((value___0 & alphaMask___0) >> alphaShift___0);
      }
#line 293
      index___3 ++;
#line 277
      x___3 ++;
    }
    while_break___2: /* CIL Label */ ;
    }

    while_break___0: 
#line 295
    pSrc___27 -= stride___1;
#line 276
    y___4 ++;
  }
  while_break___1: /* CIL Label */ ;
  }

  while_break: ;
#line 280
  return;
}
}
#line 299 "/root/patron-new/39/src/bin/jp2/convertbmp.c"
static opj_image_t *bmp8toimage(OPJ_UINT8 *pData___2 , OPJ_UINT32 stride___2 , opj_image_t *image___21 ,
                                OPJ_UINT8 * const  *pLUT___1 ) 
{ 
  OPJ_UINT32 width___7 ;
  OPJ_UINT32 height___6 ;
  OPJ_UINT8 *pSrc___28 ;
  OPJ_INT32 *pDst___25[3] ;
  OPJ_INT32 pDstStride___0[3] ;

  {
#line 303
  pSrc___28 = (OPJ_UINT8 *)((void *)0);
#line 305
  width___7 = (image___21->comps + 0)->w;
#line 306
  height___6 = (image___21->comps + 0)->h;
#line 308
  pSrc___28 = pData___2 + (height___6 - 1U) * stride___2;
#line 309
  if (image___21->numcomps == 1U) {
    {
#line 310
    opj_applyLUT8u_8u32s_C1R(pSrc___28, - ((OPJ_INT32 )stride___2), (image___21->comps + 0)->data,
                             (OPJ_INT32 )width___7, (OPJ_UINT8 *)*(pLUT___1 + 0),
                             width___7, height___6);
    }
  } else {
    {
#line 316
    pDst___25[0] = (image___21->comps + 0)->data;
#line 317
    pDst___25[1] = (image___21->comps + 1)->data;
#line 318
    pDst___25[2] = (image___21->comps + 2)->data;
#line 319
    pDstStride___0[0] = (OPJ_INT32 )width___7;
#line 320
    pDstStride___0[1] = (OPJ_INT32 )width___7;
#line 321
    pDstStride___0[2] = (OPJ_INT32 )width___7;
#line 322
    opj_applyLUT8u_8u32s_C1P3R(pSrc___28, - ((OPJ_INT32 )stride___2), (OPJ_INT32 * const  *)(pDst___25),
                               pDstStride___0, pLUT___1, width___7, height___6);
    }
  }
#line 325
  return (image___21);
}
}
#line 328 "/root/patron-new/39/src/bin/jp2/convertbmp.c"
static OPJ_BOOL bmp_read_file_header(FILE *IN , OPJ_BITMAPFILEHEADER *header ) 
{ 
  int __cil_tmp3___31 ;
  int __cil_tmp4___24 ;
  int __cil_tmp5___43 ;
  int __cil_tmp6___50 ;
  int __cil_tmp7___50 ;
  int __cil_tmp8___67 ;
  int __cil_tmp9___37 ;
  int __cil_tmp10___38 ;
  int __cil_tmp11___26 ;
  int __cil_tmp12___43 ;
  int __cil_tmp13___45 ;
  int __cil_tmp14___55 ;
  int __cil_tmp15___39 ;
  int __cil_tmp16___39 ;

  {
  {
#line 330
  __cil_tmp3___31 = getc(IN);
#line 330
  header->bfType = (OPJ_UINT16 )__cil_tmp3___31;
#line 331
  __cil_tmp4___24 = getc(IN);
#line 331
  header->bfType = (OPJ_UINT16 )((int )header->bfType | (int )((OPJ_UINT16 )((OPJ_UINT32 )__cil_tmp4___24 << 8)));
  }
#line 333
  if ((int )header->bfType != 19778) {
    {
#line 334
    fprintf(stderr, "Error, not a BMP file!\n");
    }
#line 335
    return (0);
  }
  {
#line 340
  __cil_tmp5___43 = getc(IN);
#line 340
  header->bfSize = (OPJ_UINT32 )__cil_tmp5___43;
#line 341
  __cil_tmp6___50 = getc(IN);
#line 341
  header->bfSize |= (OPJ_UINT32 )__cil_tmp6___50 << 8;
#line 342
  __cil_tmp7___50 = getc(IN);
#line 342
  header->bfSize |= (OPJ_UINT32 )__cil_tmp7___50 << 16;
#line 343
  __cil_tmp8___67 = getc(IN);
#line 343
  header->bfSize |= (OPJ_UINT32 )__cil_tmp8___67 << 24;
#line 345
  __cil_tmp9___37 = getc(IN);
#line 345
  header->bfReserved1 = (OPJ_UINT16 )__cil_tmp9___37;
#line 346
  __cil_tmp10___38 = getc(IN);
#line 346
  header->bfReserved1 = (OPJ_UINT16 )((int )header->bfReserved1 | (int )((OPJ_UINT16 )((OPJ_UINT32 )__cil_tmp10___38 << 8)));
#line 348
  __cil_tmp11___26 = getc(IN);
#line 348
  header->bfReserved2 = (OPJ_UINT16 )__cil_tmp11___26;
#line 349
  __cil_tmp12___43 = getc(IN);
#line 349
  header->bfReserved2 = (OPJ_UINT16 )((int )header->bfReserved2 | (int )((OPJ_UINT16 )((OPJ_UINT32 )__cil_tmp12___43 << 8)));
#line 351
  __cil_tmp13___45 = getc(IN);
#line 351
  header->bfOffBits = (OPJ_UINT32 )__cil_tmp13___45;
#line 352
  __cil_tmp14___55 = getc(IN);
#line 352
  header->bfOffBits |= (OPJ_UINT32 )__cil_tmp14___55 << 8;
#line 353
  __cil_tmp15___39 = getc(IN);
#line 353
  header->bfOffBits |= (OPJ_UINT32 )__cil_tmp15___39 << 16;
#line 354
  __cil_tmp16___39 = getc(IN);
#line 354
  header->bfOffBits |= (OPJ_UINT32 )__cil_tmp16___39 << 24;
  }
#line 355
  return (1);
}
}
#line 357 "/root/patron-new/39/src/bin/jp2/convertbmp.c"
static OPJ_BOOL bmp_read_info_header(FILE *IN___0 , OPJ_BITMAPINFOHEADER *header___0 ) 
{ 
  int __cil_tmp3___32 ;
  int __cil_tmp4___25 ;
  int __cil_tmp5___44 ;
  int __cil_tmp6___51 ;
  int __cil_tmp7___51 ;
  int __cil_tmp8___68 ;
  int __cil_tmp9___38 ;
  int __cil_tmp10___39 ;
  int __cil_tmp11___27 ;
  int __cil_tmp12___44 ;
  int __cil_tmp13___46 ;
  int __cil_tmp14___56 ;
  int __cil_tmp15___40 ;
  int __cil_tmp16___40 ;
  int __cil_tmp17___32 ;
  int __cil_tmp18___31 ;
  int __cil_tmp19___32 ;
  int __cil_tmp20___38 ;
  int __cil_tmp21___22 ;
  int __cil_tmp22___31 ;
  int __cil_tmp23___26 ;
  int __cil_tmp24___30 ;
  int __cil_tmp25___20 ;
  int __cil_tmp26___22 ;
  int __cil_tmp27___16 ;
  int __cil_tmp28___19 ;
  int __cil_tmp29___11 ;
  int __cil_tmp30___13 ;
  int __cil_tmp31___17 ;
  int __cil_tmp32___18 ;
  int __cil_tmp33___10 ;
  int __cil_tmp34___12 ;
  int __cil_tmp35___16 ;
  int __cil_tmp36___15 ;
  int __cil_tmp37___7 ;
  int __cil_tmp38___6 ;
  int __cil_tmp39___11 ;
  int __cil_tmp40___13 ;
  int __cil_tmp41___4 ;
  int __cil_tmp42___3 ;
  int __cil_tmp43___9 ;
  int __cil_tmp44___9 ;
  int __cil_tmp45___2 ;
  int __cil_tmp46___0 ;
  int __cil_tmp47___4 ;
  int __cil_tmp48___5 ;
  int __cil_tmp49 ;
  int __cil_tmp50___0 ;
  int __cil_tmp51___4 ;
  int __cil_tmp52___4 ;
  int __cil_tmp53___0 ;
  int __cil_tmp54 ;
  int __cil_tmp55___3 ;
  int __cil_tmp56___3 ;
  int __cil_tmp57 ;
  int __cil_tmp58 ;
  int __cil_tmp59___2 ;
  int __cil_tmp60___1 ;
  int __cil_tmp61___0 ;
  int __cil_tmp62___0 ;
  unsigned long __cil_tmp63___0 ;
  int __cil_tmp64___0 ;
  int __cil_tmp65 ;
  int __cil_tmp66 ;
  int __cil_tmp67 ;
  int __cil_tmp68___0 ;
  int __cil_tmp69___0 ;
  int __cil_tmp70 ;
  int __cil_tmp71 ;
  int __cil_tmp72 ;
  int __cil_tmp73 ;
  int __cil_tmp74___0 ;
  int __cil_tmp75___0 ;
  int __cil_tmp76___0 ;
  int __cil_tmp77___0 ;
  int __cil_tmp78___0 ;
  int __cil_tmp79___0 ;
  int __cil_tmp80___0 ;
  int __cil_tmp81 ;
  int __cil_tmp82 ;
  int __cil_tmp83 ;
  int __cil_tmp84 ;
  int __cil_tmp85 ;
  int __cil_tmp86 ;
  int __cil_tmp87 ;
  int __cil_tmp88 ;
  int __cil_tmp89 ;
  int __cil_tmp90 ;
  int __cil_tmp91 ;

  {
  {
#line 359
  memset((void *)header___0, 0, sizeof(*header___0));
#line 362
  __cil_tmp3___32 = getc(IN___0);
#line 362
  header___0->biSize = (OPJ_UINT32 )__cil_tmp3___32;
#line 363
  __cil_tmp4___25 = getc(IN___0);
#line 363
  header___0->biSize |= (OPJ_UINT32 )__cil_tmp4___25 << 8;
#line 364
  __cil_tmp5___44 = getc(IN___0);
#line 364
  header___0->biSize |= (OPJ_UINT32 )__cil_tmp5___44 << 16;
#line 365
  __cil_tmp6___51 = getc(IN___0);
#line 365
  header___0->biSize |= (OPJ_UINT32 )__cil_tmp6___51 << 24;
  }
#line 373
  if (header___0->biSize == 124U) {
#line 373
    goto case_124;
  }
#line 373
  if (header___0->biSize == 108U) {
#line 373
    goto case_124;
  }
#line 373
  if (header___0->biSize == 56U) {
#line 373
    goto case_124;
  }
#line 373
  if (header___0->biSize == 52U) {
#line 373
    goto case_124;
  }
#line 373
  if (header___0->biSize == 40U) {
#line 373
    goto case_124;
  }
#line 373
  if (header___0->biSize == 12U) {
#line 373
    goto case_124;
  }
#line 375
  goto switch_default;
  case_124: 
#line 374
  goto switch_break;
  switch_default: 
  {
#line 376
  fprintf(stderr, "Error, unknown BMP header size %d\n", header___0->biSize);
  }
#line 377
  return (0);
  switch_break: 
  {
#line 380
  __cil_tmp7___51 = getc(IN___0);
#line 380
  header___0->biWidth = (OPJ_UINT32 )__cil_tmp7___51;
#line 381
  __cil_tmp8___68 = getc(IN___0);
#line 381
  header___0->biWidth |= (OPJ_UINT32 )__cil_tmp8___68 << 8;
#line 382
  __cil_tmp9___38 = getc(IN___0);
#line 382
  header___0->biWidth |= (OPJ_UINT32 )__cil_tmp9___38 << 16;
#line 383
  __cil_tmp10___39 = getc(IN___0);
#line 383
  header___0->biWidth |= (OPJ_UINT32 )__cil_tmp10___39 << 24;
#line 385
  __cil_tmp11___27 = getc(IN___0);
#line 385
  header___0->biHeight = (OPJ_UINT32 )__cil_tmp11___27;
#line 386
  __cil_tmp12___44 = getc(IN___0);
#line 386
  header___0->biHeight |= (OPJ_UINT32 )__cil_tmp12___44 << 8;
#line 387
  __cil_tmp13___46 = getc(IN___0);
#line 387
  header___0->biHeight |= (OPJ_UINT32 )__cil_tmp13___46 << 16;
#line 388
  __cil_tmp14___56 = getc(IN___0);
#line 388
  header___0->biHeight |= (OPJ_UINT32 )__cil_tmp14___56 << 24;
#line 390
  __cil_tmp15___40 = getc(IN___0);
#line 390
  header___0->biPlanes = (OPJ_UINT16 )__cil_tmp15___40;
#line 391
  __cil_tmp16___40 = getc(IN___0);
#line 391
  header___0->biPlanes = (OPJ_UINT16 )((int )header___0->biPlanes | (int )((OPJ_UINT16 )((OPJ_UINT32 )__cil_tmp16___40 << 8)));
#line 393
  __cil_tmp17___32 = getc(IN___0);
#line 393
  header___0->biBitCount = (OPJ_UINT16 )__cil_tmp17___32;
#line 394
  __cil_tmp18___31 = getc(IN___0);
#line 394
  header___0->biBitCount = (OPJ_UINT16 )((int )header___0->biBitCount | (int )((OPJ_UINT16 )((OPJ_UINT32 )__cil_tmp18___31 << 8)));
  }
#line 395
  if ((int )header___0->biBitCount == 0) {
    {
#line 396
    fprintf(stderr, "Error, invalid biBitCount %d\n", 0);
    }
#line 397
    return (0);
  }
#line 400
  if (header___0->biSize >= 40U) {
    {
#line 401
    __cil_tmp19___32 = getc(IN___0);
#line 401
    header___0->biCompression = (OPJ_UINT32 )__cil_tmp19___32;
#line 402
    __cil_tmp20___38 = getc(IN___0);
#line 402
    header___0->biCompression |= (OPJ_UINT32 )__cil_tmp20___38 << 8;
#line 403
    __cil_tmp21___22 = getc(IN___0);
#line 403
    header___0->biCompression |= (OPJ_UINT32 )__cil_tmp21___22 << 16;
#line 404
    __cil_tmp22___31 = getc(IN___0);
#line 404
    header___0->biCompression |= (OPJ_UINT32 )__cil_tmp22___31 << 24;
#line 406
    __cil_tmp23___26 = getc(IN___0);
#line 406
    header___0->biSizeImage = (OPJ_UINT32 )__cil_tmp23___26;
#line 407
    __cil_tmp24___30 = getc(IN___0);
#line 407
    header___0->biSizeImage |= (OPJ_UINT32 )__cil_tmp24___30 << 8;
#line 408
    __cil_tmp25___20 = getc(IN___0);
#line 408
    header___0->biSizeImage |= (OPJ_UINT32 )__cil_tmp25___20 << 16;
#line 409
    __cil_tmp26___22 = getc(IN___0);
#line 409
    header___0->biSizeImage |= (OPJ_UINT32 )__cil_tmp26___22 << 24;
#line 411
    __cil_tmp27___16 = getc(IN___0);
#line 411
    header___0->biXpelsPerMeter = (OPJ_UINT32 )__cil_tmp27___16;
#line 412
    __cil_tmp28___19 = getc(IN___0);
#line 412
    header___0->biXpelsPerMeter |= (OPJ_UINT32 )__cil_tmp28___19 << 8;
#line 413
    __cil_tmp29___11 = getc(IN___0);
#line 413
    header___0->biXpelsPerMeter |= (OPJ_UINT32 )__cil_tmp29___11 << 16;
#line 414
    __cil_tmp30___13 = getc(IN___0);
#line 414
    header___0->biXpelsPerMeter |= (OPJ_UINT32 )__cil_tmp30___13 << 24;
#line 416
    __cil_tmp31___17 = getc(IN___0);
#line 416
    header___0->biYpelsPerMeter = (OPJ_UINT32 )__cil_tmp31___17;
#line 417
    __cil_tmp32___18 = getc(IN___0);
#line 417
    header___0->biYpelsPerMeter |= (OPJ_UINT32 )__cil_tmp32___18 << 8;
#line 418
    __cil_tmp33___10 = getc(IN___0);
#line 418
    header___0->biYpelsPerMeter |= (OPJ_UINT32 )__cil_tmp33___10 << 16;
#line 419
    __cil_tmp34___12 = getc(IN___0);
#line 419
    header___0->biYpelsPerMeter |= (OPJ_UINT32 )__cil_tmp34___12 << 24;
#line 421
    __cil_tmp35___16 = getc(IN___0);
#line 421
    header___0->biClrUsed = (OPJ_UINT32 )__cil_tmp35___16;
#line 422
    __cil_tmp36___15 = getc(IN___0);
#line 422
    header___0->biClrUsed |= (OPJ_UINT32 )__cil_tmp36___15 << 8;
#line 423
    __cil_tmp37___7 = getc(IN___0);
#line 423
    header___0->biClrUsed |= (OPJ_UINT32 )__cil_tmp37___7 << 16;
#line 424
    __cil_tmp38___6 = getc(IN___0);
#line 424
    header___0->biClrUsed |= (OPJ_UINT32 )__cil_tmp38___6 << 24;
#line 426
    __cil_tmp39___11 = getc(IN___0);
#line 426
    header___0->biClrImportant = (OPJ_UINT32 )__cil_tmp39___11;
#line 427
    __cil_tmp40___13 = getc(IN___0);
#line 427
    header___0->biClrImportant |= (OPJ_UINT32 )__cil_tmp40___13 << 8;
#line 428
    __cil_tmp41___4 = getc(IN___0);
#line 428
    header___0->biClrImportant |= (OPJ_UINT32 )__cil_tmp41___4 << 16;
#line 429
    __cil_tmp42___3 = getc(IN___0);
#line 429
    header___0->biClrImportant |= (OPJ_UINT32 )__cil_tmp42___3 << 24;
    }
  }
#line 432
  if (header___0->biSize >= 56U) {
    {
#line 433
    __cil_tmp43___9 = getc(IN___0);
#line 433
    header___0->biRedMask = (OPJ_UINT32 )__cil_tmp43___9;
#line 434
    __cil_tmp44___9 = getc(IN___0);
#line 434
    header___0->biRedMask |= (OPJ_UINT32 )__cil_tmp44___9 << 8;
#line 435
    __cil_tmp45___2 = getc(IN___0);
#line 435
    header___0->biRedMask |= (OPJ_UINT32 )__cil_tmp45___2 << 16;
#line 436
    __cil_tmp46___0 = getc(IN___0);
#line 436
    header___0->biRedMask |= (OPJ_UINT32 )__cil_tmp46___0 << 24;
    }
#line 438
    if (! header___0->biRedMask) {
      {
#line 439
      fprintf(stderr, "Error, invalid red mask value %d\n", header___0->biRedMask);
      }
#line 440
      return (0);
    }
    {
#line 443
    __cil_tmp47___4 = getc(IN___0);
#line 443
    header___0->biGreenMask = (OPJ_UINT32 )__cil_tmp47___4;
#line 444
    __cil_tmp48___5 = getc(IN___0);
#line 444
    header___0->biGreenMask |= (OPJ_UINT32 )__cil_tmp48___5 << 8;
#line 445
    __cil_tmp49 = getc(IN___0);
#line 445
    header___0->biGreenMask |= (OPJ_UINT32 )__cil_tmp49 << 16;
#line 446
    __cil_tmp50___0 = getc(IN___0);
#line 446
    header___0->biGreenMask |= (OPJ_UINT32 )__cil_tmp50___0 << 24;
    }
#line 448
    if (! header___0->biGreenMask) {
      {
#line 449
      fprintf(stderr, "Error, invalid green mask value %d\n", header___0->biGreenMask);
      }
#line 450
      return (0);
    }
    {
#line 453
    __cil_tmp51___4 = getc(IN___0);
#line 453
    header___0->biBlueMask = (OPJ_UINT32 )__cil_tmp51___4;
#line 454
    __cil_tmp52___4 = getc(IN___0);
#line 454
    header___0->biBlueMask |= (OPJ_UINT32 )__cil_tmp52___4 << 8;
#line 455
    __cil_tmp53___0 = getc(IN___0);
#line 455
    header___0->biBlueMask |= (OPJ_UINT32 )__cil_tmp53___0 << 16;
#line 456
    __cil_tmp54 = getc(IN___0);
#line 456
    header___0->biBlueMask |= (OPJ_UINT32 )__cil_tmp54 << 24;
    }
#line 458
    if (! header___0->biBlueMask) {
      {
#line 459
      fprintf(stderr, "Error, invalid blue mask value %d\n", header___0->biBlueMask);
      }
#line 460
      return (0);
    }
    {
#line 463
    __cil_tmp55___3 = getc(IN___0);
#line 463
    header___0->biAlphaMask = (OPJ_UINT32 )__cil_tmp55___3;
#line 464
    __cil_tmp56___3 = getc(IN___0);
#line 464
    header___0->biAlphaMask |= (OPJ_UINT32 )__cil_tmp56___3 << 8;
#line 465
    __cil_tmp57 = getc(IN___0);
#line 465
    header___0->biAlphaMask |= (OPJ_UINT32 )__cil_tmp57 << 16;
#line 466
    __cil_tmp58 = getc(IN___0);
#line 466
    header___0->biAlphaMask |= (OPJ_UINT32 )__cil_tmp58 << 24;
    }
  }
#line 469
  if (header___0->biSize >= 108U) {
    {
#line 470
    __cil_tmp59___2 = getc(IN___0);
#line 470
    header___0->biColorSpaceType = (OPJ_UINT32 )__cil_tmp59___2;
#line 471
    __cil_tmp60___1 = getc(IN___0);
#line 471
    header___0->biColorSpaceType |= (OPJ_UINT32 )__cil_tmp60___1 << 8;
#line 472
    __cil_tmp61___0 = getc(IN___0);
#line 472
    header___0->biColorSpaceType |= (OPJ_UINT32 )__cil_tmp61___0 << 16;
#line 473
    __cil_tmp62___0 = getc(IN___0);
#line 473
    header___0->biColorSpaceType |= (OPJ_UINT32 )__cil_tmp62___0 << 24;
#line 475
    __cil_tmp63___0 = fread((void *)(& header___0->biColorSpaceEP), 1UL, sizeof(header___0->biColorSpaceEP),
                            IN___0);
    }
#line 475
    if (__cil_tmp63___0 != sizeof(header___0->biColorSpaceEP)) {
      {
#line 477
      fprintf(stderr, "Error, can\'t  read BMP header\n");
      }
#line 478
      return (0);
    }
    {
#line 481
    __cil_tmp64___0 = getc(IN___0);
#line 481
    header___0->biRedGamma = (OPJ_UINT32 )__cil_tmp64___0;
#line 482
    __cil_tmp65 = getc(IN___0);
#line 482
    header___0->biRedGamma |= (OPJ_UINT32 )__cil_tmp65 << 8;
#line 483
    __cil_tmp66 = getc(IN___0);
#line 483
    header___0->biRedGamma |= (OPJ_UINT32 )__cil_tmp66 << 16;
#line 484
    __cil_tmp67 = getc(IN___0);
#line 484
    header___0->biRedGamma |= (OPJ_UINT32 )__cil_tmp67 << 24;
#line 486
    __cil_tmp68___0 = getc(IN___0);
#line 486
    header___0->biGreenGamma = (OPJ_UINT32 )__cil_tmp68___0;
#line 487
    __cil_tmp69___0 = getc(IN___0);
#line 487
    header___0->biGreenGamma |= (OPJ_UINT32 )__cil_tmp69___0 << 8;
#line 488
    __cil_tmp70 = getc(IN___0);
#line 488
    header___0->biGreenGamma |= (OPJ_UINT32 )__cil_tmp70 << 16;
#line 489
    __cil_tmp71 = getc(IN___0);
#line 489
    header___0->biGreenGamma |= (OPJ_UINT32 )__cil_tmp71 << 24;
#line 491
    __cil_tmp72 = getc(IN___0);
#line 491
    header___0->biBlueGamma = (OPJ_UINT32 )__cil_tmp72;
#line 492
    __cil_tmp73 = getc(IN___0);
#line 492
    header___0->biBlueGamma |= (OPJ_UINT32 )__cil_tmp73 << 8;
#line 493
    __cil_tmp74___0 = getc(IN___0);
#line 493
    header___0->biBlueGamma |= (OPJ_UINT32 )__cil_tmp74___0 << 16;
#line 494
    __cil_tmp75___0 = getc(IN___0);
#line 494
    header___0->biBlueGamma |= (OPJ_UINT32 )__cil_tmp75___0 << 24;
    }
  }
#line 497
  if (header___0->biSize >= 124U) {
    {
#line 498
    __cil_tmp76___0 = getc(IN___0);
#line 498
    header___0->biIntent = (OPJ_UINT32 )__cil_tmp76___0;
#line 499
    __cil_tmp77___0 = getc(IN___0);
#line 499
    header___0->biIntent |= (OPJ_UINT32 )__cil_tmp77___0 << 8;
#line 500
    __cil_tmp78___0 = getc(IN___0);
#line 500
    header___0->biIntent |= (OPJ_UINT32 )__cil_tmp78___0 << 16;
#line 501
    __cil_tmp79___0 = getc(IN___0);
#line 501
    header___0->biIntent |= (OPJ_UINT32 )__cil_tmp79___0 << 24;
#line 503
    __cil_tmp80___0 = getc(IN___0);
#line 503
    header___0->biIccProfileData = (OPJ_UINT32 )__cil_tmp80___0;
#line 504
    __cil_tmp81 = getc(IN___0);
#line 504
    header___0->biIccProfileData |= (OPJ_UINT32 )__cil_tmp81 << 8;
#line 505
    __cil_tmp82 = getc(IN___0);
#line 505
    header___0->biIccProfileData |= (OPJ_UINT32 )__cil_tmp82 << 16;
#line 506
    __cil_tmp83 = getc(IN___0);
#line 506
    header___0->biIccProfileData |= (OPJ_UINT32 )__cil_tmp83 << 24;
#line 508
    __cil_tmp84 = getc(IN___0);
#line 508
    header___0->biIccProfileSize = (OPJ_UINT32 )__cil_tmp84;
#line 509
    __cil_tmp85 = getc(IN___0);
#line 509
    header___0->biIccProfileSize |= (OPJ_UINT32 )__cil_tmp85 << 8;
#line 510
    __cil_tmp86 = getc(IN___0);
#line 510
    header___0->biIccProfileSize |= (OPJ_UINT32 )__cil_tmp86 << 16;
#line 511
    __cil_tmp87 = getc(IN___0);
#line 511
    header___0->biIccProfileSize |= (OPJ_UINT32 )__cil_tmp87 << 24;
#line 513
    __cil_tmp88 = getc(IN___0);
#line 513
    header___0->biReserved = (OPJ_UINT32 )__cil_tmp88;
#line 514
    __cil_tmp89 = getc(IN___0);
#line 514
    header___0->biReserved |= (OPJ_UINT32 )__cil_tmp89 << 8;
#line 515
    __cil_tmp90 = getc(IN___0);
#line 515
    header___0->biReserved |= (OPJ_UINT32 )__cil_tmp90 << 16;
#line 516
    __cil_tmp91 = getc(IN___0);
#line 516
    header___0->biReserved |= (OPJ_UINT32 )__cil_tmp91 << 24;
    }
  }
#line 518
  return (1);
}
}
#line 521 "/root/patron-new/39/src/bin/jp2/convertbmp.c"
static OPJ_BOOL bmp_read_raw_data(FILE *IN___1 , OPJ_UINT8 *pData___3 , OPJ_UINT32 stride___3 ,
                                  OPJ_UINT32 width___8 , OPJ_UINT32 height___7 ) 
{ 
  unsigned long __cil_tmp6___52 ;

  {
  {
#line 526
  __cil_tmp6___52 = fread((void *)pData___3, sizeof(OPJ_UINT8 ), (unsigned long )(stride___3 * height___7),
                          IN___1);
  }
#line 526
  if (__cil_tmp6___52 != (unsigned long )(stride___3 * height___7)) {
    {
#line 527
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 529
    return (0);
  }
#line 531
  return (1);
}
}
#line 534 "/root/patron-new/39/src/bin/jp2/convertbmp.c"
static OPJ_BOOL bmp_read_rle8_data(FILE *IN___2 , OPJ_UINT8 *pData___4 , OPJ_UINT32 stride___4 ,
                                   OPJ_UINT32 width___9 , OPJ_UINT32 height___8 ) 
{ 
  OPJ_UINT32 x___4 ;
  OPJ_UINT32 y___5 ;
  OPJ_UINT32 written ;
  OPJ_UINT8 *pix ;
  OPJ_UINT8 *beyond ;
  int c ;
  int __cil_tmp12___45 ;
  int j___16 ;
  int c1_int ;
  OPJ_UINT8 c1 ;
  int __cil_tmp18___32 ;
  OPJ_UINT32 __cil_tmp19___33 ;
  OPJ_UINT8 *__cil_tmp20___39 ;
  int j___17 ;
  int c1_int___0 ;
  OPJ_UINT8 c1___0 ;
  int __cil_tmp29___12 ;
  OPJ_UINT32 __cil_tmp30___14 ;
  OPJ_UINT8 *__cil_tmp31___18 ;

  {
#line 541
  beyond = pData___4 + stride___4 * height___8;
#line 542
  pix = pData___4;
#line 544
  written = 0U;
#line 544
  y___5 = written;
#line 544
  x___4 = y___5;
  {
#line 545
  while (1) {
    while_continue: /* CIL Label */ ;

#line 545
    if (! (y___5 < height___8)) {
#line 545
      goto while_break;
    }
    {
#line 546
    __cil_tmp12___45 = getc(IN___2);
#line 546
    c = __cil_tmp12___45;
    }
#line 547
    if (c == -1) {
#line 548
      return (0);
    }
#line 551
    if (c) {
      {
#line 555
      c1_int = getc(IN___2);
      }
#line 556
      if (c1_int == -1) {
#line 557
        return (0);
      }
#line 559
      c1 = (OPJ_UINT8 )c1_int;
#line 561
      j___16 = 0;
      {
#line 561
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 561
        if (j___16 < c) {
#line 561
          if (x___4 < width___9) {
#line 561
            if (! ((OPJ_SIZE_T )pix < (OPJ_SIZE_T )beyond)) {
#line 561
              goto while_break___0;
            }
          } else {
#line 561
            goto while_break___0;
          }
        } else {
#line 561
          goto while_break___0;
        }
#line 563
        *pix = c1;
#line 564
        written ++;
#line 562
        __cil_tmp20___39 = pix;
#line 562
        pix ++;
#line 562
        __cil_tmp19___33 = x___4;
#line 562
        x___4 ++;
#line 562
        __cil_tmp18___32 = j___16;
#line 562
        j___16 ++;
      }
      while_break___3: /* CIL Label */ ;
      }

      while_break___0: ;
    } else {
      {
#line 567
      c = getc(IN___2);
      }
#line 568
      if (c == -1) {
#line 569
        return (0);
      }
#line 572
      if (c == 0) {
#line 573
        x___4 = (OPJ_UINT32 )0;
#line 574
        y___5 ++;
#line 575
        pix = (pData___4 + y___5 * stride___4) + x___4;
      } else
#line 576
      if (c == 1) {
#line 577
        goto while_break;
      } else
#line 578
      if (c == 2) {
        {
#line 579
        c = getc(IN___2);
        }
#line 580
        if (c == -1) {
#line 581
          return (0);
        }
        {
#line 583
        x___4 += (OPJ_UINT32 )c;
#line 584
        c = getc(IN___2);
        }
#line 585
        if (c == -1) {
#line 586
          return (0);
        }
#line 588
        y___5 += (OPJ_UINT32 )c;
#line 589
        pix = (pData___4 + y___5 * stride___4) + x___4;
      } else {
#line 592
        j___17 = 0;
        {
#line 592
        while (1) {
          while_continue___1: /* CIL Label */ ;

#line 592
          if (j___17 < c) {
#line 592
            if (x___4 < width___9) {
#line 592
              if (! ((OPJ_SIZE_T )pix < (OPJ_SIZE_T )beyond)) {
#line 592
                goto while_break___1;
              }
            } else {
#line 592
              goto while_break___1;
            }
          } else {
#line 592
            goto while_break___1;
          }
          {
#line 596
          c1_int___0 = getc(IN___2);
          }
#line 597
          if (c1_int___0 == -1) {
#line 598
            return (0);
          }
#line 600
          c1___0 = (OPJ_UINT8 )c1_int___0;
#line 601
          *pix = c1___0;
#line 602
          written ++;
#line 593
          __cil_tmp31___18 = pix;
#line 593
          pix ++;
#line 593
          __cil_tmp30___14 = x___4;
#line 593
          x___4 ++;
#line 593
          __cil_tmp29___12 = j___17;
#line 593
          j___17 ++;
        }
        while_break___4: /* CIL Label */ ;
        }

        while_break___1: ;
#line 604
        if ((OPJ_UINT32 )c & 1U) {
          {
#line 605
          c = getc(IN___2);
          }
#line 606
          if (c == -1) {
#line 607
            return (0);
          }
        }
      }
    }
  }
  while_break___2: /* CIL Label */ ;
  }

  while_break: ;
#line 614
  if (written != width___9 * height___8) {
    {
#line 615
    fprintf(stderr, "warning, image\'s actual size does not match advertized one\n");
    }
#line 616
    return (0);
  }
#line 619
  return (1);
}
}
#line 622 "/root/patron-new/39/src/bin/jp2/convertbmp.c"
static OPJ_BOOL bmp_read_rle4_data(FILE *IN___3 , OPJ_UINT8 *pData___5 , OPJ_UINT32 stride___5 ,
                                   OPJ_UINT32 width___10 , OPJ_UINT32 height___9 ) 
{ 
  OPJ_UINT32 x___5 ;
  OPJ_UINT32 y___6 ;
  OPJ_UINT32 written___0 ;
  OPJ_UINT8 *pix___0 ;
  OPJ_UINT8 *beyond___0 ;
  int c___0 ;
  int __cil_tmp12___46 ;
  int j___18 ;
  int c1_int___1 ;
  OPJ_UINT8 c1___1 ;
  unsigned int tmp___469 ;
  int __cil_tmp19___34 ;
  OPJ_UINT32 __cil_tmp20___40 ;
  OPJ_UINT8 *__cil_tmp21___24 ;
  int j___19 ;
  OPJ_UINT8 c1___2 ;
  int c1_int___2 ;
  unsigned int tmp___470 ;
  int __cil_tmp32___20 ;
  OPJ_UINT32 __cil_tmp33___11 ;
  OPJ_UINT8 *__cil_tmp34___13 ;

  {
#line 629
  beyond___0 = pData___5 + stride___5 * height___9;
#line 630
  pix___0 = pData___5;
#line 631
  written___0 = 0U;
#line 631
  y___6 = written___0;
#line 631
  x___5 = y___6;
  {
#line 632
  while (1) {
    while_continue: /* CIL Label */ ;

#line 632
    if (! (y___6 < height___9)) {
#line 632
      goto while_break;
    }
    {
#line 633
    __cil_tmp12___46 = getc(IN___3);
#line 633
    c___0 = __cil_tmp12___46;
    }
#line 634
    if (c___0 == -1) {
#line 635
      return (0);
    }
#line 638
    if (c___0) {
      {
#line 642
      c1_int___1 = getc(IN___3);
      }
#line 643
      if (c1_int___1 == -1) {
#line 644
        return (0);
      }
#line 646
      c1___1 = (OPJ_UINT8 )c1_int___1;
#line 648
      j___18 = 0;
      {
#line 648
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 648
        if (j___18 < c___0) {
#line 648
          if (x___5 < width___10) {
#line 648
            if (! ((OPJ_SIZE_T )pix___0 < (OPJ_SIZE_T )beyond___0)) {
#line 648
              goto while_break___0;
            }
          } else {
#line 648
            goto while_break___0;
          }
        } else {
#line 648
          goto while_break___0;
        }
#line 650
        if (j___18 & 1) {
#line 650
          tmp___469 = (unsigned int )c1___1 & 15U;
        } else {
#line 650
          tmp___469 = (unsigned int )((int )c1___1 >> 4) & 15U;
        }
#line 650
        *pix___0 = (OPJ_UINT8 )tmp___469;
#line 651
        written___0 ++;
#line 649
        __cil_tmp21___24 = pix___0;
#line 649
        pix___0 ++;
#line 649
        __cil_tmp20___40 = x___5;
#line 649
        x___5 ++;
#line 649
        __cil_tmp19___34 = j___18;
#line 649
        j___18 ++;
      }
      while_break___3: /* CIL Label */ ;
      }

      while_break___0: ;
    } else {
      {
#line 654
      c___0 = getc(IN___3);
      }
#line 655
      if (c___0 == -1) {
#line 656
        return (0);
      }
#line 659
      if (c___0 == 0) {
#line 660
        x___5 = (OPJ_UINT32 )0;
#line 661
        y___6 ++;
#line 662
        pix___0 = pData___5 + y___6 * stride___5;
      } else
#line 663
      if (c___0 == 1) {
#line 664
        goto while_break;
      } else
#line 665
      if (c___0 == 2) {
        {
#line 666
        c___0 = getc(IN___3);
        }
#line 667
        if (c___0 == -1) {
#line 668
          return (0);
        }
        {
#line 670
        x___5 += (OPJ_UINT32 )c___0;
#line 671
        c___0 = getc(IN___3);
        }
#line 672
        if (c___0 == -1) {
#line 673
          return (0);
        }
#line 675
        y___6 += (OPJ_UINT32 )c___0;
#line 676
        pix___0 = (pData___5 + y___6 * stride___5) + x___5;
      } else {
#line 679
        c1___2 = (OPJ_UINT8 )0U;
#line 681
        j___19 = 0;
        {
#line 681
        while (1) {
          while_continue___1: /* CIL Label */ ;

#line 681
          if (j___19 < c___0) {
#line 681
            if (x___5 < width___10) {
#line 681
              if (! ((OPJ_SIZE_T )pix___0 < (OPJ_SIZE_T )beyond___0)) {
#line 681
                goto while_break___1;
              }
            } else {
#line 681
              goto while_break___1;
            }
          } else {
#line 681
            goto while_break___1;
          }
#line 683
          if ((j___19 & 1) == 0) {
            {
#line 685
            c1_int___2 = getc(IN___3);
            }
#line 686
            if (c1_int___2 == -1) {
#line 687
              return (0);
            }
#line 689
            c1___2 = (OPJ_UINT8 )c1_int___2;
          }
#line 691
          if (j___19 & 1) {
#line 691
            tmp___470 = (unsigned int )c1___2 & 15U;
          } else {
#line 691
            tmp___470 = (unsigned int )((int )c1___2 >> 4) & 15U;
          }
#line 691
          *pix___0 = (OPJ_UINT8 )tmp___470;
#line 692
          written___0 ++;
#line 682
          __cil_tmp34___13 = pix___0;
#line 682
          pix___0 ++;
#line 682
          __cil_tmp33___11 = x___5;
#line 682
          x___5 ++;
#line 682
          __cil_tmp32___20 = j___19;
#line 682
          j___19 ++;
        }
        while_break___4: /* CIL Label */ ;
        }

        while_break___1: ;
#line 694
        if ((c___0 & 3) == 1) {
          _L: 
          {
#line 695
          c___0 = getc(IN___3);
          }
#line 696
          if (c___0 == -1) {
#line 697
            return (0);
          }
        } else
#line 694
        if ((c___0 & 3) == 2) {
#line 694
          goto _L;
        }
      }
    }
  }
  while_break___2: /* CIL Label */ ;
  }

  while_break: ;
#line 703
  if (written___0 != width___10 * height___9) {
    {
#line 704
    fprintf(stderr, "warning, image\'s actual size does not match advertized one\n");
    }
#line 705
    return (0);
  }
#line 707
  return (1);
}
}
#line 710 "/root/patron-new/39/src/bin/jp2/convertbmp.c"
opj_image_t *bmptoimage(char const   *filename___0 , opj_cparameters_t *parameters___13 ) 
{ 
  opj_image_cmptparm_t cmptparm___1[4] ;
  OPJ_UINT8 lut_R[256] ;
  OPJ_UINT8 lut_G[256] ;
  OPJ_UINT8 lut_B[256] ;
  OPJ_UINT8 *pLUT___2[3] ;
  opj_image_t *image___22 ;
  FILE *IN___4 ;
  OPJ_BITMAPFILEHEADER File_h ;
  OPJ_BITMAPINFOHEADER Info_h ;
  OPJ_UINT32 i___121 ;
  OPJ_UINT32 palette_len ;
  OPJ_UINT32 numcmpts___1 ;
  OPJ_BOOL l_result___3 ;
  OPJ_UINT8 *pData___6 ;
  OPJ_UINT32 stride___6 ;
  OPJ_BOOL __cil_tmp19___35 ;
  OPJ_BOOL __cil_tmp20___41 ;
  OPJ_UINT8 has_color ;
  int __cil_tmp22___34 ;
  int __cil_tmp23___29 ;
  int __cil_tmp24___32 ;
  void *__cil_tmp27___18 ;
  int tmp___471 ;
  opj_image_t *__cil_tmp33___12 ;

  {
  {
#line 715
  image___22 = (opj_image_t *)((void *)0);
#line 719
  numcmpts___1 = 1U;
#line 720
  l_result___3 = 0;
#line 721
  pData___6 = (OPJ_UINT8 *)((void *)0);
#line 724
  pLUT___2[0] = lut_R;
#line 725
  pLUT___2[1] = lut_G;
#line 726
  pLUT___2[2] = lut_B;
#line 728
  IN___4 = fopen(filename___0, "rb\226\006]U");
  }
#line 729
  if (! IN___4) {
    {
#line 730
    fprintf(stderr, "Failed to open %s for reading !!\n", filename___0);
    }
#line 731
    return ((opj_image_t *)((void *)0));
  }
  {
#line 734
  __cil_tmp19___35 = bmp_read_file_header(IN___4, & File_h);
  }
#line 734
  if (! __cil_tmp19___35) {
    {
#line 735
    fclose(IN___4);
    }
#line 736
    return ((opj_image_t *)((void *)0));
  }
  {
#line 738
  __cil_tmp20___41 = bmp_read_info_header(IN___4, & Info_h);
  }
#line 738
  if (! __cil_tmp20___41) {
    {
#line 739
    fclose(IN___4);
    }
#line 740
    return ((opj_image_t *)((void *)0));
  }
#line 744
  if ((unsigned int )Info_h.biBitCount <= 8U) {
    {
#line 745
    memset((void *)(& lut_R[0]), 0, sizeof(lut_R));
#line 746
    memset((void *)(& lut_G[0]), 0, sizeof(lut_G));
#line 747
    memset((void *)(& lut_B[0]), 0, sizeof(lut_B));
#line 749
    palette_len = Info_h.biClrUsed;
    }
#line 750
    if (palette_len == 0U) {
#line 750
      if ((unsigned int )Info_h.biBitCount <= 8U) {
#line 751
        palette_len = 1U << (int )Info_h.biBitCount;
      }
    }
#line 753
    if (palette_len > 256U) {
#line 754
      palette_len = 256U;
    }
#line 756
    if (palette_len > 0U) {
#line 757
      has_color = (OPJ_UINT8 )0U;
#line 758
      i___121 = 0U;
      {
#line 758
      while (1) {
        while_continue: /* CIL Label */ ;

#line 758
        if (! (i___121 < palette_len)) {
#line 758
          goto while_break;
        }
        {
#line 759
        __cil_tmp22___34 = getc(IN___4);
#line 759
        lut_B[i___121] = (OPJ_UINT8 )__cil_tmp22___34;
#line 760
        __cil_tmp23___29 = getc(IN___4);
#line 760
        lut_G[i___121] = (OPJ_UINT8 )__cil_tmp23___29;
#line 761
        __cil_tmp24___32 = getc(IN___4);
#line 761
        lut_R[i___121] = (OPJ_UINT8 )__cil_tmp24___32;
#line 762
        getc(IN___4);
#line 763
        has_color = (OPJ_UINT8 )((int )has_color | (((int )lut_B[i___121] ^ (int )lut_G[i___121]) | ((int )lut_G[i___121] ^ (int )lut_R[i___121])));
#line 758
        i___121 ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }

      while_break: ;
#line 765
      if (has_color) {
#line 766
        numcmpts___1 = 3U;
      }
    }
  } else {
#line 770
    numcmpts___1 = 3U;
#line 771
    if (Info_h.biCompression == 3U) {
#line 771
      if (Info_h.biAlphaMask != 0U) {
#line 772
        numcmpts___1 ++;
      }
    }
  }
#line 776
  if (Info_h.biWidth == 0U) {
    {
#line 777
    fclose(IN___4);
    }
#line 778
    return ((opj_image_t *)((void *)0));
  } else
#line 776
  if (Info_h.biHeight == 0U) {
    {
#line 777
    fclose(IN___4);
    }
#line 778
    return ((opj_image_t *)((void *)0));
  }
#line 781
  if ((unsigned int )Info_h.biBitCount > 4294967264U / Info_h.biWidth) {
    {
#line 782
    fclose(IN___4);
    }
#line 783
    return ((opj_image_t *)((void *)0));
  }
#line 785
  stride___6 = ((Info_h.biWidth * (unsigned int )Info_h.biBitCount + 31U) / 32U) * 4U;
#line 787
  if ((int )Info_h.biBitCount == 4) {
#line 787
    if (Info_h.biCompression == 2U) {
#line 789
      if (8U > 4294967264U / Info_h.biWidth) {
        {
#line 790
        fclose(IN___4);
        }
#line 791
        return ((opj_image_t *)((void *)0));
      }
#line 793
      stride___6 = ((Info_h.biWidth * 8U + 31U) / 32U) * 4U;
    }
  }
#line 796
  if ((unsigned long )stride___6 > (4294967295UL / sizeof(OPJ_UINT8 )) / (unsigned long )Info_h.biHeight) {
    {
#line 797
    fclose(IN___4);
    }
#line 798
    return ((opj_image_t *)((void *)0));
  }
  {
#line 800
  __cil_tmp27___18 = calloc(1UL, (sizeof(OPJ_UINT8 ) * (unsigned long )stride___6) * (unsigned long )Info_h.biHeight);
#line 800
  pData___6 = (OPJ_UINT8 *)__cil_tmp27___18;
  }
#line 801
  if ((unsigned long )pData___6 == (unsigned long )((void *)0)) {
    {
#line 802
    fclose(IN___4);
    }
#line 803
    return ((opj_image_t *)((void *)0));
  }
  {
#line 806
  fseek(IN___4, 0L, 0);
#line 807
  fseek(IN___4, (long )File_h.bfOffBits, 0);
  }
#line 811
  if (Info_h.biCompression == 3U) {
#line 811
    goto case_3;
  }
#line 811
  if (Info_h.biCompression == 0U) {
#line 811
    goto case_3;
  }
#line 816
  if (Info_h.biCompression == 1U) {
#line 816
    goto case_1;
  }
#line 821
  if (Info_h.biCompression == 2U) {
#line 821
    goto case_2;
  }
#line 826
  goto switch_default;
  case_3: 
  {
#line 813
  l_result___3 = bmp_read_raw_data(IN___4, pData___6, stride___6, Info_h.biWidth,
                                   Info_h.biHeight);
  }
#line 815
  goto switch_break;
  case_1: 
  {
#line 818
  l_result___3 = bmp_read_rle8_data(IN___4, pData___6, stride___6, Info_h.biWidth,
                                    Info_h.biHeight);
  }
#line 820
  goto switch_break;
  case_2: 
  {
#line 823
  l_result___3 = bmp_read_rle4_data(IN___4, pData___6, stride___6, Info_h.biWidth,
                                    Info_h.biHeight);
  }
#line 825
  goto switch_break;
  switch_default: 
  {
#line 827
  fprintf(stderr, "Unsupported BMP compression\n");
#line 828
  l_result___3 = 0;
  }
#line 829
  goto switch_break;
  switch_break: ;
#line 831
  if (! l_result___3) {
    {
#line 832
    free((void *)pData___6);
#line 833
    fclose(IN___4);
    }
#line 834
    return ((opj_image_t *)((void *)0));
  }
  {
#line 838
  memset((void *)(& cmptparm___1[0]), 0, sizeof(cmptparm___1));
#line 839
  i___121 = (OPJ_UINT32 )0;
  }
  {
#line 839
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 839
    if (! (i___121 < 4U)) {
#line 839
      goto while_break___0;
    }
#line 840
    cmptparm___1[i___121].prec = (OPJ_UINT32 )8;
#line 841
    cmptparm___1[i___121].bpp = (OPJ_UINT32 )8;
#line 842
    cmptparm___1[i___121].sgnd = (OPJ_UINT32 )0;
#line 843
    cmptparm___1[i___121].dx = (OPJ_UINT32 )parameters___13->subsampling_dx;
#line 844
    cmptparm___1[i___121].dy = (OPJ_UINT32 )parameters___13->subsampling_dy;
#line 845
    cmptparm___1[i___121].w = Info_h.biWidth;
#line 846
    cmptparm___1[i___121].h = Info_h.biHeight;
#line 839
    i___121 ++;
  }
  while_break___2: /* CIL Label */ ;
  }

  while_break___0: ;
#line 849
  if (numcmpts___1 == 1U) {
#line 849
    tmp___471 = 2;
  } else {
#line 849
    tmp___471 = 1;
  }
  {
#line 849
  __cil_tmp33___12 = opj_image_create(numcmpts___1, & cmptparm___1[0], (OPJ_COLOR_SPACE )tmp___471);
#line 849
  image___22 = __cil_tmp33___12;
  }
#line 851
  if (! image___22) {
    {
#line 852
    fclose(IN___4);
#line 853
    free((void *)pData___6);
    }
#line 854
    return ((opj_image_t *)((void *)0));
  }
#line 856
  if (numcmpts___1 == 4U) {
#line 857
    (image___22->comps + 3)->alpha = (OPJ_UINT16 )1;
  }
#line 861
  image___22->x0 = (OPJ_UINT32 )parameters___13->image_offset_x0;
#line 862
  image___22->y0 = (OPJ_UINT32 )parameters___13->image_offset_y0;
#line 863
  image___22->x1 = (image___22->x0 + (Info_h.biWidth - 1U) * (OPJ_UINT32 )parameters___13->subsampling_dx) + 1U;
#line 865
  image___22->y1 = (image___22->y0 + (Info_h.biHeight - 1U) * (OPJ_UINT32 )parameters___13->subsampling_dy) + 1U;
#line 869
  if ((int )Info_h.biBitCount == 24) {
#line 869
    if (Info_h.biCompression == 0U) {
      {
#line 870
      bmp24toimage(pData___6, stride___6, image___22);
      }
    } else {
#line 869
      goto _L___42;
    }
  } else
  _L___42: 
#line 871
  if ((int )Info_h.biBitCount == 8) {
#line 871
    if (Info_h.biCompression == 0U) {
      {
#line 873
      bmp8toimage(pData___6, stride___6, image___22, (OPJ_UINT8 * const  *)(pLUT___2));
      }
    } else {
#line 871
      goto _L___41;
    }
  } else
  _L___41: 
#line 874
  if ((int )Info_h.biBitCount == 8) {
#line 874
    if (Info_h.biCompression == 1U) {
      {
#line 875
      bmp8toimage(pData___6, stride___6, image___22, (OPJ_UINT8 * const  *)(pLUT___2));
      }
    } else {
#line 874
      goto _L___40;
    }
  } else
  _L___40: 
#line 876
  if ((int )Info_h.biBitCount == 4) {
#line 876
    if (Info_h.biCompression == 2U) {
      {
#line 877
      bmp8toimage(pData___6, stride___6, image___22, (OPJ_UINT8 * const  *)(pLUT___2));
      }
    } else {
#line 876
      goto _L___39;
    }
  } else
  _L___39: 
#line 879
  if ((int )Info_h.biBitCount == 32) {
#line 879
    if (Info_h.biCompression == 0U) {
      {
#line 880
      bmpmask32toimage(pData___6, stride___6, image___22, 16711680U, 65280U, 255U,
                       0U);
      }
    } else {
#line 879
      goto _L___38;
    }
  } else
  _L___38: 
#line 882
  if ((int )Info_h.biBitCount == 32) {
#line 882
    if (Info_h.biCompression == 3U) {
#line 883
      if (Info_h.biRedMask == 0U) {
#line 883
        if (Info_h.biGreenMask == 0U) {
#line 883
          if (Info_h.biBlueMask == 0U) {
#line 885
            Info_h.biRedMask = 16711680U;
#line 886
            Info_h.biGreenMask = 65280U;
#line 887
            Info_h.biBlueMask = 255U;
          }
        }
      }
      {
#line 889
      bmpmask32toimage(pData___6, stride___6, image___22, Info_h.biRedMask, Info_h.biGreenMask,
                       Info_h.biBlueMask, Info_h.biAlphaMask);
      }
    } else {
#line 882
      goto _L___37;
    }
  } else
  _L___37: 
#line 891
  if ((int )Info_h.biBitCount == 16) {
#line 891
    if (Info_h.biCompression == 0U) {
      {
#line 892
      bmpmask16toimage(pData___6, stride___6, image___22, 31744U, 992U, 31U, 0U);
      }
    } else {
#line 891
      goto _L;
    }
  } else
  _L: 
#line 893
  if ((int )Info_h.biBitCount == 16) {
#line 893
    if (Info_h.biCompression == 3U) {
#line 894
      if (Info_h.biRedMask == 0U) {
#line 894
        if (Info_h.biGreenMask == 0U) {
#line 894
          if (Info_h.biBlueMask == 0U) {
#line 896
            Info_h.biRedMask = 63488U;
#line 897
            Info_h.biGreenMask = 2016U;
#line 898
            Info_h.biBlueMask = 31U;
          }
        }
      }
      {
#line 900
      bmpmask16toimage(pData___6, stride___6, image___22, Info_h.biRedMask, Info_h.biGreenMask,
                       Info_h.biBlueMask, Info_h.biAlphaMask);
      }
    } else {
      {
#line 903
      opj_image_destroy(image___22);
#line 904
      image___22 = (opj_image_t *)((void *)0);
#line 905
      fprintf(stderr, "Other system than 24 bits/pixels or 8 bits (no RLE coding) is not yet implemented [%d]\n",
              (int )Info_h.biBitCount);
      }
    }
  } else {
    {
#line 903
    opj_image_destroy(image___22);
#line 904
    image___22 = (opj_image_t *)((void *)0);
#line 905
    fprintf(stderr, "Other system than 24 bits/pixels or 8 bits (no RLE coding) is not yet implemented [%d]\n",
            (int )Info_h.biBitCount);
    }
  }
  {
#line 909
  free((void *)pData___6);
#line 910
  fclose(IN___4);
  }
#line 911
  return (image___22);
}
}
#line 914 "/root/patron-new/39/src/bin/jp2/convertbmp.c"
int imagetobmp(opj_image_t *image___23 , char const   *outfile___0 ) 
{ 
  int w___0 ;
  int h___0 ;
  int i___122 ;
  int pad ;
  FILE *fdest ;
  int adjustR ;
  int adjustG ;
  int adjustB ;
  OPJ_UINT8 rc ;
  OPJ_UINT8 gc ;
  OPJ_UINT8 bc ;
  int r ;
  int g ;
  int b___0 ;
  int tmp___472 ;
  int tmp___473 ;
  int tmp___474 ;
  int tmp___475 ;
  int __cil_tmp22___35 ;
  int r___0 ;
  int tmp___476 ;
  int tmp___477 ;
  int __cil_tmp29___15 ;

  {
#line 918
  fdest = (FILE *)((void *)0);
#line 921
  if ((image___23->comps + 0)->prec < 8U) {
    {
#line 922
    fprintf(stderr, "imagetobmp: Unsupported precision: %d\n", (image___23->comps + 0)->prec);
    }
#line 924
    return (1);
  }
#line 926
  if (image___23->numcomps >= 3U) {
#line 926
    if ((image___23->comps + 0)->dx == (image___23->comps + 1)->dx) {
#line 926
      if ((image___23->comps + 1)->dx == (image___23->comps + 2)->dx) {
#line 926
        if ((image___23->comps + 0)->dy == (image___23->comps + 1)->dy) {
#line 926
          if ((image___23->comps + 1)->dy == (image___23->comps + 2)->dy) {
#line 926
            if ((image___23->comps + 0)->prec == (image___23->comps + 1)->prec) {
#line 926
              if ((image___23->comps + 1)->prec == (image___23->comps + 2)->prec) {
#line 926
                if ((image___23->comps + 0)->sgnd == (image___23->comps + 1)->sgnd) {
#line 926
                  if ((image___23->comps + 1)->sgnd == (image___23->comps + 2)->sgnd) {
                    {
#line 939
                    fdest = fopen(outfile___0, "wb");
                    }
#line 940
                    if (! fdest) {
                      {
#line 941
                      fprintf(stderr, "ERROR -> failed to open %s for writing\n",
                              outfile___0);
                      }
#line 942
                      return (1);
                    }
                    {
#line 945
                    w___0 = (int )(image___23->comps + 0)->w;
#line 946
                    h___0 = (int )(image___23->comps + 0)->h;
#line 948
                    fprintf(fdest, "BM\230\006]U");
#line 952
                    fprintf(fdest, "%c%c%c%c\230\001", (int )((OPJ_UINT8 )(((h___0 * w___0) * 3 + (3 * h___0) * (w___0 % 2)) + 54)) & 255,
                            (int )((OPJ_UINT8 )((((h___0 * w___0) * 3 + (3 * h___0) * (w___0 % 2)) + 54) >> 8)) & 255,
                            (int )((OPJ_UINT8 )((((h___0 * w___0) * 3 + (3 * h___0) * (w___0 % 2)) + 54) >> 16)) & 255,
                            (int )((OPJ_UINT8 )((((h___0 * w___0) * 3 + (3 * h___0) * (w___0 % 2)) + 54) >> 24)) & 255);
#line 957
                    fprintf(fdest, "%c%c%c%c\251", 0, 0, 0, 0);
#line 959
                    fprintf(fdest, "%c%c%c%c\251", 54, (54 >> 8) & 255, (54 >> 16) & 255,
                            (54 >> 24) & 255);
#line 964
                    fprintf(fdest, "%c%c%c%c\251", 40, (40 >> 8) & 255, (40 >> 16) & 255,
                            (40 >> 24) & 255);
#line 966
                    fprintf(fdest, "%c%c%c%c\230\001", (int )((OPJ_UINT8 )(w___0 & 255)),
                            (int )((OPJ_UINT8 )(w___0 >> 8)) & 255, (int )((OPJ_UINT8 )(w___0 >> 16)) & 255,
                            (int )((OPJ_UINT8 )(w___0 >> 24)) & 255);
#line 970
                    fprintf(fdest, "%c%c%c%c\230\001", (int )((OPJ_UINT8 )(h___0 & 255)),
                            (int )((OPJ_UINT8 )(h___0 >> 8)) & 255, (int )((OPJ_UINT8 )(h___0 >> 16)) & 255,
                            (int )((OPJ_UINT8 )(h___0 >> 24)) & 255);
#line 974
                    fprintf(fdest, "%c%c", 1, (1 >> 8) & 255);
#line 975
                    fprintf(fdest, "%c%c]U", 24, (24 >> 8) & 255);
#line 976
                    fprintf(fdest, "%c%c%c%c\251", 0, 0, 0, 0);
#line 978
                    fprintf(fdest, "%c%c%c%c\251", (int )((OPJ_UINT8 )((3 * h___0) * w___0 + (3 * h___0) * (w___0 % 2))) & 255,
                            (int )((OPJ_UINT8 )(((h___0 * w___0) * 3 + (3 * h___0) * (w___0 % 2)) >> 8)) & 255,
                            (int )((OPJ_UINT8 )(((h___0 * w___0) * 3 + (3 * h___0) * (w___0 % 2)) >> 16)) & 255,
                            (int )((OPJ_UINT8 )(((h___0 * w___0) * 3 + (3 * h___0) * (w___0 % 2)) >> 24)) & 255);
#line 982
                    fprintf(fdest, "%c%c%c%c\251", 154, (7834 >> 8) & 255, (7834 >> 16) & 255,
                            (7834 >> 24) & 255);
#line 984
                    fprintf(fdest, "%c%c%c%c\251", 154, (7834 >> 8) & 255, (7834 >> 16) & 255,
                            (7834 >> 24) & 255);
#line 986
                    fprintf(fdest, "%c%c%c%c\251", 0, 0, 0, 0);
#line 988
                    fprintf(fdest, "%c%c%c%c\251", 0, 0, 0, 0);
                    }
#line 991
                    if ((image___23->comps + 0)->prec > 8U) {
                      {
#line 992
                      adjustR = (int )(image___23->comps + 0)->prec - 8;
#line 993
                      printf("BMP CONVERSION: Truncating component 0 from %d bits to 8 bits\n",
                             (image___23->comps + 0)->prec);
                      }
                    } else {
#line 996
                      adjustR = 0;
                    }
#line 998
                    if ((image___23->comps + 1)->prec > 8U) {
                      {
#line 999
                      adjustG = (int )(image___23->comps + 1)->prec - 8;
#line 1000
                      printf("BMP CONVERSION: Truncating component 1 from %d bits to 8 bits\n",
                             (image___23->comps + 1)->prec);
                      }
                    } else {
#line 1003
                      adjustG = 0;
                    }
#line 1005
                    if ((image___23->comps + 2)->prec > 8U) {
                      {
#line 1006
                      adjustB = (int )(image___23->comps + 2)->prec - 8;
#line 1007
                      printf("BMP CONVERSION: Truncating component 2 from %d bits to 8 bits\n",
                             (image___23->comps + 2)->prec);
                      }
                    } else {
#line 1010
                      adjustB = 0;
                    }
#line 1013
                    i___122 = 0;
                    {
#line 1013
                    while (1) {
                      while_continue: /* CIL Label */ ;

#line 1013
                      if (! (i___122 < w___0 * h___0)) {
#line 1013
                        goto while_break;
                      }
#line 1017
                      r = *((image___23->comps + 0)->data + ((w___0 * h___0 - (i___122 / w___0 + 1) * w___0) + i___122 % w___0));
#line 1018
                      if ((image___23->comps + 0)->sgnd) {
#line 1018
                        tmp___472 = 1 << ((image___23->comps + 0)->prec - 1U);
                      } else {
#line 1018
                        tmp___472 = 0;
                      }
#line 1018
                      r += tmp___472;
#line 1019
                      if (adjustR > 0) {
#line 1020
                        r = (r >> adjustR) + (r >> (adjustR - 1)) % 2;
                      }
#line 1022
                      if (r > 255) {
#line 1023
                        r = 255;
                      } else
#line 1024
                      if (r < 0) {
#line 1025
                        r = 0;
                      }
#line 1027
                      rc = (OPJ_UINT8 )r;
#line 1029
                      g = *((image___23->comps + 1)->data + ((w___0 * h___0 - (i___122 / w___0 + 1) * w___0) + i___122 % w___0));
#line 1030
                      if ((image___23->comps + 1)->sgnd) {
#line 1030
                        tmp___473 = 1 << ((image___23->comps + 1)->prec - 1U);
                      } else {
#line 1030
                        tmp___473 = 0;
                      }
#line 1030
                      g += tmp___473;
#line 1031
                      if (adjustG > 0) {
#line 1032
                        g = (g >> adjustG) + (g >> (adjustG - 1)) % 2;
                      }
#line 1034
                      if (g > 255) {
#line 1035
                        g = 255;
                      } else
#line 1036
                      if (g < 0) {
#line 1037
                        g = 0;
                      }
#line 1039
                      gc = (OPJ_UINT8 )g;
#line 1041
                      b___0 = *((image___23->comps + 2)->data + ((w___0 * h___0 - (i___122 / w___0 + 1) * w___0) + i___122 % w___0));
#line 1042
                      if ((image___23->comps + 2)->sgnd) {
#line 1042
                        tmp___474 = 1 << ((image___23->comps + 2)->prec - 1U);
                      } else {
#line 1042
                        tmp___474 = 0;
                      }
#line 1042
                      b___0 += tmp___474;
#line 1043
                      if (adjustB > 0) {
#line 1044
                        b___0 = (b___0 >> adjustB) + (b___0 >> (adjustB - 1)) % 2;
                      }
#line 1046
                      if (b___0 > 255) {
#line 1047
                        b___0 = 255;
                      } else
#line 1048
                      if (b___0 < 0) {
#line 1049
                        b___0 = 0;
                      }
                      {
#line 1051
                      bc = (OPJ_UINT8 )b___0;
#line 1053
                      fprintf(fdest, "%c%c%c", (int )bc, (int )gc, (int )rc);
                      }
#line 1055
                      if ((i___122 + 1) % w___0 == 0) {
#line 1056
                        if ((3 * w___0) % 4) {
#line 1056
                          tmp___475 = 4 - (3 * w___0) % 4;
                        } else {
#line 1056
                          tmp___475 = 0;
                        }
#line 1056
                        pad = tmp___475;
                        {
#line 1056
                        while (1) {
                          while_continue___0: /* CIL Label */ ;

#line 1056
                          if (! (pad > 0)) {
#line 1056
                            goto while_break___0;
                          }
                          {
#line 1057
                          fprintf(fdest, "%c", 0);
#line 1056
                          __cil_tmp22___35 = pad;
#line 1056
                          pad --;
                          }
                        }
                        while_break___5: /* CIL Label */ ;
                        }

                        while_break___0: ;
                      }
#line 1013
                      i___122 ++;
                    }
                    while_break___4: /* CIL Label */ ;
                    }

                    while_break: 
                    {
#line 1061
                    fclose(fdest);
                    }
                  } else {
#line 926
                    goto _L;
                  }
                } else {
#line 926
                  goto _L;
                }
              } else {
#line 926
                goto _L;
              }
            } else {
#line 926
              goto _L;
            }
          } else {
#line 926
            goto _L;
          }
        } else {
#line 926
          goto _L;
        }
      } else {
#line 926
        goto _L;
      }
    } else {
#line 926
      goto _L;
    }
  } else {
    _L: 
    {
#line 1068
    fdest = fopen(outfile___0, "wb\377\377\377\377\377\377\220");
    }
#line 1069
    if (! fdest) {
      {
#line 1070
      fprintf(stderr, "ERROR -> failed to open %s for writing\n\377\230\001", outfile___0);
      }
#line 1071
      return (1);
    }
#line 1073
    if (image___23->numcomps > 1U) {
      {
#line 1074
      fprintf(stderr, "imagetobmp: only first component of %d is used.\n\230\001",
              image___23->numcomps);
      }
    }
    {
#line 1077
    w___0 = (int )(image___23->comps + 0)->w;
#line 1078
    h___0 = (int )(image___23->comps + 0)->h;
#line 1080
    fprintf(fdest, "BM");
#line 1084
    fprintf(fdest, "%c%c%c%c\230\001", (int )((OPJ_UINT8 )(((h___0 * w___0 + 54) + 1024) + h___0 * (w___0 % 2))) & 255,
            (int )((OPJ_UINT8 )((((h___0 * w___0 + 54) + 1024) + h___0 * (w___0 % 2)) >> 8)) & 255,
            (int )((OPJ_UINT8 )((((h___0 * w___0 + 54) + 1024) + h___0 * (w___0 % 2)) >> 16)) & 255,
            (int )((OPJ_UINT8 )((((h___0 * w___0 + 54) + 1024) + w___0 * (w___0 % 2)) >> 24)) & 255);
#line 1088
    fprintf(fdest, "%c%c%c%c\251", 0, 0, 0, 0);
#line 1090
    fprintf(fdest, "%c%c%c%c\251", 54, (1078 >> 8) & 255, (1078 >> 16) & 255, (1078 >> 24) & 255);
#line 1096
    fprintf(fdest, "%c%c%c%c\251", 40, (40 >> 8) & 255, (40 >> 16) & 255, (40 >> 24) & 255);
#line 1098
    fprintf(fdest, "%c%c%c%c\230\001", (int )((OPJ_UINT8 )(w___0 & 255)), (int )((OPJ_UINT8 )(w___0 >> 8)) & 255,
            (int )((OPJ_UINT8 )(w___0 >> 16)) & 255, (int )((OPJ_UINT8 )(w___0 >> 24)) & 255);
#line 1102
    fprintf(fdest, "%c%c%c%c\230\001", (int )((OPJ_UINT8 )(h___0 & 255)), (int )((OPJ_UINT8 )(h___0 >> 8)) & 255,
            (int )((OPJ_UINT8 )(h___0 >> 16)) & 255, (int )((OPJ_UINT8 )(h___0 >> 24)) & 255);
#line 1106
    fprintf(fdest, "%c%c", 1, (1 >> 8) & 255);
#line 1107
    fprintf(fdest, "%c%c", 8, (8 >> 8) & 255);
#line 1108
    fprintf(fdest, "%c%c%c%c\251", 0, 0, 0, 0);
#line 1110
    fprintf(fdest, "%c%c%c%c\230\001", (int )((OPJ_UINT8 )(h___0 * w___0 + h___0 * (w___0 % 2))) & 255,
            (int )((OPJ_UINT8 )((h___0 * w___0 + h___0 * (w___0 % 2)) >> 8)) & 255,
            (int )((OPJ_UINT8 )((h___0 * w___0 + h___0 * (w___0 % 2)) >> 16)) & 255,
            (int )((OPJ_UINT8 )((h___0 * w___0 + h___0 * (w___0 % 2)) >> 24)) & 255);
#line 1114
    fprintf(fdest, "%c%c%c%c\251", 154, (7834 >> 8) & 255, (7834 >> 16) & 255, (7834 >> 24) & 255);
#line 1116
    fprintf(fdest, "%c%c%c%c\251", 154, (7834 >> 8) & 255, (7834 >> 16) & 255, (7834 >> 24) & 255);
#line 1118
    fprintf(fdest, "%c%c%c%c\251", 0, (256 >> 8) & 255, (256 >> 16) & 255, (256 >> 24) & 255);
#line 1120
    fprintf(fdest, "%c%c%c%c\251", 0, (256 >> 8) & 255, (256 >> 16) & 255, (256 >> 24) & 255);
    }
#line 1123
    if ((image___23->comps + 0)->prec > 8U) {
      {
#line 1124
      adjustR = (int )(image___23->comps + 0)->prec - 8;
#line 1125
      printf("BMP CONVERSION: Truncating component 0 from %d bits to 8 bits\n", (image___23->comps + 0)->prec);
      }
    } else {
#line 1128
      adjustR = 0;
    }
#line 1131
    i___122 = 0;
    {
#line 1131
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 1131
      if (! (i___122 < 256)) {
#line 1131
        goto while_break___1;
      }
      {
#line 1132
      fprintf(fdest, "%c%c%c%c\230\001", i___122, i___122, i___122, 0);
#line 1131
      i___122 ++;
      }
    }
    while_break___6: /* CIL Label */ ;
    }

    while_break___1: 
#line 1135
    i___122 = 0;
    {
#line 1135
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 1135
      if (! (i___122 < w___0 * h___0)) {
#line 1135
        goto while_break___2;
      }
#line 1138
      r___0 = *((image___23->comps + 0)->data + ((w___0 * h___0 - (i___122 / w___0 + 1) * w___0) + i___122 % w___0));
#line 1139
      if ((image___23->comps + 0)->sgnd) {
#line 1139
        tmp___476 = 1 << ((image___23->comps + 0)->prec - 1U);
      } else {
#line 1139
        tmp___476 = 0;
      }
#line 1139
      r___0 += tmp___476;
#line 1140
      if (adjustR > 0) {
#line 1141
        r___0 = (r___0 >> adjustR) + (r___0 >> (adjustR - 1)) % 2;
      }
#line 1143
      if (r___0 > 255) {
#line 1144
        r___0 = 255;
      } else
#line 1145
      if (r___0 < 0) {
#line 1146
        r___0 = 0;
      }
      {
#line 1149
      fprintf(fdest, "%c", (int )((OPJ_UINT8 )r___0));
      }
#line 1151
      if ((i___122 + 1) % w___0 == 0) {
#line 1152
        if (w___0 % 4) {
#line 1152
          tmp___477 = 4 - w___0 % 4;
        } else {
#line 1152
          tmp___477 = 0;
        }
#line 1152
        pad = tmp___477;
        {
#line 1152
        while (1) {
          while_continue___3: /* CIL Label */ ;

#line 1152
          if (! (pad > 0)) {
#line 1152
            goto while_break___3;
          }
          {
#line 1153
          fprintf(fdest, "%c", 0);
#line 1152
          __cil_tmp29___15 = pad;
#line 1152
          pad --;
          }
        }
        while_break___8: /* CIL Label */ ;
        }

        while_break___3: ;
      }
#line 1135
      i___122 ++;
    }
    while_break___7: /* CIL Label */ ;
    }

    while_break___2: 
    {
#line 1157
    fclose(fdest);
    }
  }
#line 1160
  return (0);
}
}
#line 54 "/root/patron-new/39/src/bin/jp2/convert.c"
static int int_floorlog2(int a ) 
{ 
  int l ;

  {
#line 57
  l = 0;
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;

#line 57
    if (! (a > 1)) {
#line 57
      goto while_break;
    }
#line 58
    a >>= 1;
#line 57
    l ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 60
  return (l);
}
}
#line 64 "/root/patron-new/39/src/bin/jp2/convert.c"
void clip_component(opj_image_comp_t *component , OPJ_UINT32 precision ) 
{ 
  OPJ_SIZE_T i___123 ;
  OPJ_SIZE_T len___6 ;
  OPJ_UINT32 umax ;
  OPJ_INT32 *l_data___6 ;
  OPJ_INT32 max___0 ;
  OPJ_INT32 min ;
  OPJ_UINT32 *l_data___7 ;

  {
#line 68
  umax = (OPJ_UINT32 )-1;
#line 70
  len___6 = (OPJ_SIZE_T )component->w * (OPJ_SIZE_T )component->h;
#line 71
  if (precision < 32U) {
#line 72
    umax = (1U << precision) - 1U;
  }
#line 75
  if (component->sgnd) {
#line 76
    l_data___6 = component->data;
#line 77
    max___0 = (OPJ_INT32 )(umax / 2U);
#line 78
    min = - max___0 - 1;
#line 79
    i___123 = (OPJ_SIZE_T )0;
    {
#line 79
    while (1) {
      while_continue: /* CIL Label */ ;

#line 79
      if (! (i___123 < len___6)) {
#line 79
        goto while_break;
      }
#line 80
      if (*(l_data___6 + i___123) > max___0) {
#line 81
        *(l_data___6 + i___123) = max___0;
      } else
#line 82
      if (*(l_data___6 + i___123) < min) {
#line 83
        *(l_data___6 + i___123) = min;
      }
#line 79
      i___123 ++;
    }
    while_break___1: /* CIL Label */ ;
    }

    while_break: ;
  } else {
#line 87
    l_data___7 = (OPJ_UINT32 *)component->data;
#line 88
    i___123 = (OPJ_SIZE_T )0;
    {
#line 88
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 88
      if (! (i___123 < len___6)) {
#line 88
        goto while_break___0;
      }
#line 89
      if (*(l_data___7 + i___123) > umax) {
#line 90
        *(l_data___7 + i___123) = umax;
      }
#line 88
      i___123 ++;
    }
    while_break___2: /* CIL Label */ ;
    }

    while_break___0: ;
  }
#line 94
  component->prec = precision;
#line 95
  return;
}
}
#line 98 "/root/patron-new/39/src/bin/jp2/convert.c"
static void scale_component_up(opj_image_comp_t *component___0 , OPJ_UINT32 precision___0 ) 
{ 
  OPJ_SIZE_T i___124 ;
  OPJ_SIZE_T len___7 ;
  OPJ_INT64 newMax ;
  OPJ_INT64 oldMax ;
  OPJ_INT32 *l_data___8 ;
  OPJ_UINT64 newMax___0 ;
  OPJ_UINT64 oldMax___0 ;
  OPJ_UINT32 *l_data___9 ;

  {
#line 103
  len___7 = (OPJ_SIZE_T )component___0->w * (OPJ_SIZE_T )component___0->h;
#line 104
  if (component___0->sgnd) {
#line 105
    newMax = (OPJ_INT64 )(1U << (precision___0 - 1U));
#line 106
    oldMax = (OPJ_INT64 )(1U << (component___0->prec - 1U));
#line 107
    l_data___8 = component___0->data;
#line 108
    i___124 = (OPJ_SIZE_T )0;
    {
#line 108
    while (1) {
      while_continue: /* CIL Label */ ;

#line 108
      if (! (i___124 < len___7)) {
#line 108
        goto while_break;
      }
#line 109
      *(l_data___8 + i___124) = (OPJ_INT32 )(((OPJ_INT64 )*(l_data___8 + i___124) * newMax) / oldMax);
#line 108
      i___124 ++;
    }
    while_break___1: /* CIL Label */ ;
    }

    while_break: ;
  } else {
#line 112
    newMax___0 = (OPJ_UINT64 )((1U << precision___0) - 1U);
#line 113
    oldMax___0 = (OPJ_UINT64 )((1U << component___0->prec) - 1U);
#line 114
    l_data___9 = (OPJ_UINT32 *)component___0->data;
#line 115
    i___124 = (OPJ_SIZE_T )0;
    {
#line 115
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 115
      if (! (i___124 < len___7)) {
#line 115
        goto while_break___0;
      }
#line 116
      *(l_data___9 + i___124) = (OPJ_UINT32 )(((OPJ_UINT64 )*(l_data___9 + i___124) * newMax___0) / oldMax___0);
#line 115
      i___124 ++;
    }
    while_break___2: /* CIL Label */ ;
    }

    while_break___0: ;
  }
#line 119
  component___0->prec = precision___0;
#line 120
  component___0->bpp = precision___0;
#line 121
  return;
}
}
#line 122 "/root/patron-new/39/src/bin/jp2/convert.c"
void scale_component(opj_image_comp_t *component___1 , OPJ_UINT32 precision___1 ) 
{ 
  int shift___0 ;
  OPJ_SIZE_T i___125 ;
  OPJ_SIZE_T len___8 ;
  OPJ_INT32 *l_data___10 ;
  OPJ_UINT32 *l_data___11 ;

  {
#line 127
  if (component___1->prec == precision___1) {
#line 128
    return;
  }
#line 130
  if (component___1->prec < precision___1) {
    {
#line 131
    scale_component_up(component___1, precision___1);
    }
#line 132
    return;
  }
#line 134
  shift___0 = (int )(component___1->prec - precision___1);
#line 135
  len___8 = (OPJ_SIZE_T )component___1->w * (OPJ_SIZE_T )component___1->h;
#line 136
  if (component___1->sgnd) {
#line 137
    l_data___10 = component___1->data;
#line 138
    i___125 = (OPJ_SIZE_T )0;
    {
#line 138
    while (1) {
      while_continue: /* CIL Label */ ;

#line 138
      if (! (i___125 < len___8)) {
#line 138
        goto while_break;
      }
#line 139
      *(l_data___10 + i___125) >>= shift___0;
#line 138
      i___125 ++;
    }
    while_break___1: /* CIL Label */ ;
    }

    while_break: ;
  } else {
#line 142
    l_data___11 = (OPJ_UINT32 *)component___1->data;
#line 143
    i___125 = (OPJ_SIZE_T )0;
    {
#line 143
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 143
      if (! (i___125 < len___8)) {
#line 143
        goto while_break___0;
      }
#line 144
      *(l_data___11 + i___125) >>= shift___0;
#line 143
      i___125 ++;
    }
    while_break___2: /* CIL Label */ ;
    }

    while_break___0: ;
  }
#line 147
  component___1->bpp = precision___1;
#line 148
  component___1->prec = precision___1;
#line 149
  return;
}
}
#line 154 "/root/patron-new/39/src/bin/jp2/convert.c"
static void convert_32s_C1P1(OPJ_INT32 *pSrc___29 , OPJ_INT32 * const  *pDst___26 ,
                             OPJ_SIZE_T length___23 ) 
{ 


  {
  {
#line 157
  memcpy((void *)*(pDst___26 + 0), (void const   *)pSrc___29, length___23 * sizeof(OPJ_INT32 ));
  }
#line 159
  return;
}
}
#line 159 "/root/patron-new/39/src/bin/jp2/convert.c"
static void convert_32s_C2P2(OPJ_INT32 *pSrc___30 , OPJ_INT32 * const  *pDst___27 ,
                             OPJ_SIZE_T length___24 ) 
{ 
  OPJ_SIZE_T i___126 ;
  OPJ_INT32 *pDst0 ;
  OPJ_INT32 *pDst1 ;

  {
#line 163
  pDst0 = (OPJ_INT32 *)*(pDst___27 + 0);
#line 164
  pDst1 = (OPJ_INT32 *)*(pDst___27 + 1);
#line 166
  i___126 = (OPJ_SIZE_T )0;
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;

#line 166
    if (! (i___126 < length___24)) {
#line 166
      goto while_break;
    }
#line 167
    *(pDst0 + i___126) = *(pSrc___30 + 2UL * i___126);
#line 168
    *(pDst1 + i___126) = *(pSrc___30 + (2UL * i___126 + 1UL));
#line 166
    i___126 ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 170
  return;
}
}
#line 171 "/root/patron-new/39/src/bin/jp2/convert.c"
static void convert_32s_C3P3(OPJ_INT32 *pSrc___31 , OPJ_INT32 * const  *pDst___28 ,
                             OPJ_SIZE_T length___25 ) 
{ 
  OPJ_SIZE_T i___127 ;
  OPJ_INT32 *pDst0___0 ;
  OPJ_INT32 *pDst1___0 ;
  OPJ_INT32 *pDst2 ;

  {
#line 175
  pDst0___0 = (OPJ_INT32 *)*(pDst___28 + 0);
#line 176
  pDst1___0 = (OPJ_INT32 *)*(pDst___28 + 1);
#line 177
  pDst2 = (OPJ_INT32 *)*(pDst___28 + 2);
#line 179
  i___127 = (OPJ_SIZE_T )0;
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;

#line 179
    if (! (i___127 < length___25)) {
#line 179
      goto while_break;
    }
#line 180
    *(pDst0___0 + i___127) = *(pSrc___31 + 3UL * i___127);
#line 181
    *(pDst1___0 + i___127) = *(pSrc___31 + (3UL * i___127 + 1UL));
#line 182
    *(pDst2 + i___127) = *(pSrc___31 + (3UL * i___127 + 2UL));
#line 179
    i___127 ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 183
  return;
}
}
#line 185 "/root/patron-new/39/src/bin/jp2/convert.c"
static void convert_32s_C4P4(OPJ_INT32 *pSrc___32 , OPJ_INT32 * const  *pDst___29 ,
                             OPJ_SIZE_T length___26 ) 
{ 
  OPJ_SIZE_T i___128 ;
  OPJ_INT32 *pDst0___1 ;
  OPJ_INT32 *pDst1___1 ;
  OPJ_INT32 *pDst2___0 ;
  OPJ_INT32 *pDst3 ;

  {
#line 189
  pDst0___1 = (OPJ_INT32 *)*(pDst___29 + 0);
#line 190
  pDst1___1 = (OPJ_INT32 *)*(pDst___29 + 1);
#line 191
  pDst2___0 = (OPJ_INT32 *)*(pDst___29 + 2);
#line 192
  pDst3 = (OPJ_INT32 *)*(pDst___29 + 3);
#line 194
  i___128 = (OPJ_SIZE_T )0;
  {
#line 194
  while (1) {
    while_continue: /* CIL Label */ ;

#line 194
    if (! (i___128 < length___26)) {
#line 194
      goto while_break;
    }
#line 195
    *(pDst0___1 + i___128) = *(pSrc___32 + 4UL * i___128);
#line 196
    *(pDst1___1 + i___128) = *(pSrc___32 + (4UL * i___128 + 1UL));
#line 197
    *(pDst2___0 + i___128) = *(pSrc___32 + (4UL * i___128 + 2UL));
#line 198
    *(pDst3 + i___128) = *(pSrc___32 + (4UL * i___128 + 3UL));
#line 194
    i___128 ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 198
  return;
}
}
#line 201 "/root/patron-new/39/src/bin/jp2/convert.c"
convert_32s_CXPX convert_32s_CXPX_LUT[5]  = {      (void (*)(OPJ_INT32 * , OPJ_INT32 * const  * , OPJ_SIZE_T  ))((void *)0),      & convert_32s_C1P1,      & convert_32s_C2P2,      & convert_32s_C3P3, 
        & convert_32s_C4P4};
#line 209 "/root/patron-new/39/src/bin/jp2/convert.c"
static void convert_32s_P1C1(OPJ_INT32 * const  *pSrc___33 , OPJ_INT32 *pDst___30 ,
                             OPJ_SIZE_T length___27 , OPJ_INT32 adjust___1 ) 
{ 
  OPJ_SIZE_T i___129 ;
  OPJ_INT32 *pSrc0 ;

  {
#line 213
  pSrc0 = (OPJ_INT32 *)*(pSrc___33 + 0);
#line 215
  i___129 = (OPJ_SIZE_T )0;
  {
#line 215
  while (1) {
    while_continue: /* CIL Label */ ;

#line 215
    if (! (i___129 < length___27)) {
#line 215
      goto while_break;
    }
#line 216
    *(pDst___30 + i___129) = *(pSrc0 + i___129) + adjust___1;
#line 215
    i___129 ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 219
  return;
}
}
#line 219 "/root/patron-new/39/src/bin/jp2/convert.c"
static void convert_32s_P2C2(OPJ_INT32 * const  *pSrc___34 , OPJ_INT32 *pDst___31 ,
                             OPJ_SIZE_T length___28 , OPJ_INT32 adjust___2 ) 
{ 
  OPJ_SIZE_T i___130 ;
  OPJ_INT32 *pSrc0___0 ;
  OPJ_INT32 *pSrc1 ;

  {
#line 223
  pSrc0___0 = (OPJ_INT32 *)*(pSrc___34 + 0);
#line 224
  pSrc1 = (OPJ_INT32 *)*(pSrc___34 + 1);
#line 226
  i___130 = (OPJ_SIZE_T )0;
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;

#line 226
    if (! (i___130 < length___28)) {
#line 226
      goto while_break;
    }
#line 227
    *(pDst___31 + 2UL * i___130) = *(pSrc0___0 + i___130) + adjust___2;
#line 228
    *(pDst___31 + (2UL * i___130 + 1UL)) = *(pSrc1 + i___130) + adjust___2;
#line 226
    i___130 ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 230
  return;
}
}
#line 231 "/root/patron-new/39/src/bin/jp2/convert.c"
static void convert_32s_P3C3(OPJ_INT32 * const  *pSrc___35 , OPJ_INT32 *pDst___32 ,
                             OPJ_SIZE_T length___29 , OPJ_INT32 adjust___3 ) 
{ 
  OPJ_SIZE_T i___131 ;
  OPJ_INT32 *pSrc0___1 ;
  OPJ_INT32 *pSrc1___0 ;
  OPJ_INT32 *pSrc2 ;

  {
#line 235
  pSrc0___1 = (OPJ_INT32 *)*(pSrc___35 + 0);
#line 236
  pSrc1___0 = (OPJ_INT32 *)*(pSrc___35 + 1);
#line 237
  pSrc2 = (OPJ_INT32 *)*(pSrc___35 + 2);
#line 239
  i___131 = (OPJ_SIZE_T )0;
  {
#line 239
  while (1) {
    while_continue: /* CIL Label */ ;

#line 239
    if (! (i___131 < length___29)) {
#line 239
      goto while_break;
    }
#line 240
    *(pDst___32 + 3UL * i___131) = *(pSrc0___1 + i___131) + adjust___3;
#line 241
    *(pDst___32 + (3UL * i___131 + 1UL)) = *(pSrc1___0 + i___131) + adjust___3;
#line 242
    *(pDst___32 + (3UL * i___131 + 2UL)) = *(pSrc2 + i___131) + adjust___3;
#line 239
    i___131 ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 243
  return;
}
}
#line 245 "/root/patron-new/39/src/bin/jp2/convert.c"
static void convert_32s_P4C4(OPJ_INT32 * const  *pSrc___36 , OPJ_INT32 *pDst___33 ,
                             OPJ_SIZE_T length___30 , OPJ_INT32 adjust___4 ) 
{ 
  OPJ_SIZE_T i___132 ;
  OPJ_INT32 *pSrc0___2 ;
  OPJ_INT32 *pSrc1___1 ;
  OPJ_INT32 *pSrc2___0 ;
  OPJ_INT32 *pSrc3 ;

  {
#line 249
  pSrc0___2 = (OPJ_INT32 *)*(pSrc___36 + 0);
#line 250
  pSrc1___1 = (OPJ_INT32 *)*(pSrc___36 + 1);
#line 251
  pSrc2___0 = (OPJ_INT32 *)*(pSrc___36 + 2);
#line 252
  pSrc3 = (OPJ_INT32 *)*(pSrc___36 + 3);
#line 254
  i___132 = (OPJ_SIZE_T )0;
  {
#line 254
  while (1) {
    while_continue: /* CIL Label */ ;

#line 254
    if (! (i___132 < length___30)) {
#line 254
      goto while_break;
    }
#line 255
    *(pDst___33 + 4UL * i___132) = *(pSrc0___2 + i___132) + adjust___4;
#line 256
    *(pDst___33 + (4UL * i___132 + 1UL)) = *(pSrc1___1 + i___132) + adjust___4;
#line 257
    *(pDst___33 + (4UL * i___132 + 2UL)) = *(pSrc2___0 + i___132) + adjust___4;
#line 258
    *(pDst___33 + (4UL * i___132 + 3UL)) = *(pSrc3 + i___132) + adjust___4;
#line 254
    i___132 ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 258
  return;
}
}
#line 261 "/root/patron-new/39/src/bin/jp2/convert.c"
convert_32s_PXCX convert_32s_PXCX_LUT[5]  = {      (void (*)(OPJ_INT32 * const  * , OPJ_INT32 * , OPJ_SIZE_T  , OPJ_INT32  ))((void *)0),      & convert_32s_P1C1,      & convert_32s_P2C2,      & convert_32s_P3C3, 
        & convert_32s_P4C4};
#line 271 "/root/patron-new/39/src/bin/jp2/convert.c"
static void convert_1u32s_C1R(OPJ_BYTE *pSrc___37 , OPJ_INT32 *pDst___34 , OPJ_SIZE_T length___31 ) 
{ 
  OPJ_SIZE_T i___133 ;
  OPJ_UINT32 val___7 ;
  OPJ_BYTE *__cil_tmp6___53 ;
  OPJ_UINT32 val___8 ;
  OPJ_BYTE *__cil_tmp8___71 ;

  {
#line 275
  i___133 = (OPJ_SIZE_T )0;
  {
#line 275
  while (1) {
    while_continue: /* CIL Label */ ;

#line 275
    if (! (i___133 < (length___31 & 0xfffffffffffffff8UL))) {
#line 275
      goto while_break;
    }
#line 276
    __cil_tmp6___53 = pSrc___37;
#line 276
    pSrc___37 ++;
#line 276
    val___7 = (OPJ_UINT32 )*__cil_tmp6___53;
#line 277
    *(pDst___34 + i___133) = (OPJ_INT32 )(val___7 >> 7);
#line 278
    *(pDst___34 + (i___133 + 1UL)) = (OPJ_INT32 )((val___7 >> 6) & 1U);
#line 279
    *(pDst___34 + (i___133 + 2UL)) = (OPJ_INT32 )((val___7 >> 5) & 1U);
#line 280
    *(pDst___34 + (i___133 + 3UL)) = (OPJ_INT32 )((val___7 >> 4) & 1U);
#line 281
    *(pDst___34 + (i___133 + 4UL)) = (OPJ_INT32 )((val___7 >> 3) & 1U);
#line 282
    *(pDst___34 + (i___133 + 5UL)) = (OPJ_INT32 )((val___7 >> 2) & 1U);
#line 283
    *(pDst___34 + (i___133 + 6UL)) = (OPJ_INT32 )((val___7 >> 1) & 1U);
#line 284
    *(pDst___34 + (i___133 + 7UL)) = (OPJ_INT32 )(val___7 & 1U);
#line 275
    i___133 += 8UL;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 286
  if (length___31 & 7UL) {
#line 287
    __cil_tmp8___71 = pSrc___37;
#line 287
    pSrc___37 ++;
#line 287
    val___8 = (OPJ_UINT32 )*__cil_tmp8___71;
#line 288
    length___31 &= 7UL;
#line 289
    *(pDst___34 + i___133) = (OPJ_INT32 )(val___8 >> 7);
#line 291
    if (length___31 > 1UL) {
#line 292
      *(pDst___34 + (i___133 + 1UL)) = (OPJ_INT32 )((val___8 >> 6) & 1U);
#line 293
      if (length___31 > 2UL) {
#line 294
        *(pDst___34 + (i___133 + 2UL)) = (OPJ_INT32 )((val___8 >> 5) & 1U);
#line 295
        if (length___31 > 3UL) {
#line 296
          *(pDst___34 + (i___133 + 3UL)) = (OPJ_INT32 )((val___8 >> 4) & 1U);
#line 297
          if (length___31 > 4UL) {
#line 298
            *(pDst___34 + (i___133 + 4UL)) = (OPJ_INT32 )((val___8 >> 3) & 1U);
#line 299
            if (length___31 > 5UL) {
#line 300
              *(pDst___34 + (i___133 + 5UL)) = (OPJ_INT32 )((val___8 >> 2) & 1U);
#line 301
              if (length___31 > 6UL) {
#line 302
                *(pDst___34 + (i___133 + 6UL)) = (OPJ_INT32 )((val___8 >> 1) & 1U);
              }
            }
          }
        }
      }
    }
  }
#line 310
  return;
}
}
#line 311 "/root/patron-new/39/src/bin/jp2/convert.c"
static void convert_2u32s_C1R(OPJ_BYTE *pSrc___38 , OPJ_INT32 *pDst___35 , OPJ_SIZE_T length___32 ) 
{ 
  OPJ_SIZE_T i___134 ;
  OPJ_UINT32 val___9 ;
  OPJ_BYTE *__cil_tmp6___54 ;
  OPJ_UINT32 val___10 ;
  OPJ_BYTE *__cil_tmp8___72 ;

  {
#line 315
  i___134 = (OPJ_SIZE_T )0;
  {
#line 315
  while (1) {
    while_continue: /* CIL Label */ ;

#line 315
    if (! (i___134 < (length___32 & 0xfffffffffffffffcUL))) {
#line 315
      goto while_break;
    }
#line 316
    __cil_tmp6___54 = pSrc___38;
#line 316
    pSrc___38 ++;
#line 316
    val___9 = (OPJ_UINT32 )*__cil_tmp6___54;
#line 317
    *(pDst___35 + i___134) = (OPJ_INT32 )(val___9 >> 6);
#line 318
    *(pDst___35 + (i___134 + 1UL)) = (OPJ_INT32 )((val___9 >> 4) & 3U);
#line 319
    *(pDst___35 + (i___134 + 2UL)) = (OPJ_INT32 )((val___9 >> 2) & 3U);
#line 320
    *(pDst___35 + (i___134 + 3UL)) = (OPJ_INT32 )(val___9 & 3U);
#line 315
    i___134 += 4UL;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 322
  if (length___32 & 3UL) {
#line 323
    __cil_tmp8___72 = pSrc___38;
#line 323
    pSrc___38 ++;
#line 323
    val___10 = (OPJ_UINT32 )*__cil_tmp8___72;
#line 324
    length___32 &= 3UL;
#line 325
    *(pDst___35 + i___134) = (OPJ_INT32 )(val___10 >> 6);
#line 327
    if (length___32 > 1UL) {
#line 328
      *(pDst___35 + (i___134 + 1UL)) = (OPJ_INT32 )((val___10 >> 4) & 3U);
#line 329
      if (length___32 > 2UL) {
#line 330
        *(pDst___35 + (i___134 + 2UL)) = (OPJ_INT32 )((val___10 >> 2) & 3U);
      }
    }
  }
#line 334
  return;
}
}
#line 336 "/root/patron-new/39/src/bin/jp2/convert.c"
static void convert_4u32s_C1R(OPJ_BYTE *pSrc___39 , OPJ_INT32 *pDst___36 , OPJ_SIZE_T length___33 ) 
{ 
  OPJ_SIZE_T i___135 ;
  OPJ_UINT32 val___11 ;
  OPJ_BYTE *__cil_tmp6___55 ;
  OPJ_UINT8 val___12 ;
  OPJ_BYTE *__cil_tmp8___73 ;

  {
#line 340
  i___135 = (OPJ_SIZE_T )0;
  {
#line 340
  while (1) {
    while_continue: /* CIL Label */ ;

#line 340
    if (! (i___135 < (length___33 & 0xfffffffffffffffeUL))) {
#line 340
      goto while_break;
    }
#line 341
    __cil_tmp6___55 = pSrc___39;
#line 341
    pSrc___39 ++;
#line 341
    val___11 = (OPJ_UINT32 )*__cil_tmp6___55;
#line 342
    *(pDst___36 + i___135) = (OPJ_INT32 )(val___11 >> 4);
#line 343
    *(pDst___36 + (i___135 + 1UL)) = (OPJ_INT32 )(val___11 & 15U);
#line 340
    i___135 += 2UL;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 345
  if (length___33 & 1UL) {
#line 346
    __cil_tmp8___73 = pSrc___39;
#line 346
    pSrc___39 ++;
#line 346
    val___12 = *__cil_tmp8___73;
#line 347
    *(pDst___36 + i___135) = (int )val___12 >> 4;
  }
#line 349
  return;
}
}
#line 350 "/root/patron-new/39/src/bin/jp2/convert.c"
static void convert_6u32s_C1R(OPJ_BYTE *pSrc___40 , OPJ_INT32 *pDst___37 , OPJ_SIZE_T length___34 ) 
{ 
  OPJ_SIZE_T i___136 ;
  OPJ_UINT32 val0___13 ;
  OPJ_BYTE *__cil_tmp6___56 ;
  OPJ_UINT32 val1___13 ;
  OPJ_BYTE *__cil_tmp8___74 ;
  OPJ_UINT32 val2___11 ;
  OPJ_BYTE *__cil_tmp10___41 ;
  OPJ_UINT32 val0___14 ;
  OPJ_BYTE *__cil_tmp12___47 ;
  OPJ_UINT32 val1___14 ;
  OPJ_BYTE *__cil_tmp14___57 ;
  OPJ_UINT32 val2___12 ;
  OPJ_BYTE *__cil_tmp16___43 ;

  {
#line 354
  i___136 = (OPJ_SIZE_T )0;
  {
#line 354
  while (1) {
    while_continue: /* CIL Label */ ;

#line 354
    if (! (i___136 < (length___34 & 0xfffffffffffffffcUL))) {
#line 354
      goto while_break;
    }
#line 355
    __cil_tmp6___56 = pSrc___40;
#line 355
    pSrc___40 ++;
#line 355
    val0___13 = (OPJ_UINT32 )*__cil_tmp6___56;
#line 356
    __cil_tmp8___74 = pSrc___40;
#line 356
    pSrc___40 ++;
#line 356
    val1___13 = (OPJ_UINT32 )*__cil_tmp8___74;
#line 357
    __cil_tmp10___41 = pSrc___40;
#line 357
    pSrc___40 ++;
#line 357
    val2___11 = (OPJ_UINT32 )*__cil_tmp10___41;
#line 358
    *(pDst___37 + i___136) = (OPJ_INT32 )(val0___13 >> 2);
#line 359
    *(pDst___37 + (i___136 + 1UL)) = (OPJ_INT32 )(((val0___13 & 3U) << 4) | (val1___13 >> 4));
#line 360
    *(pDst___37 + (i___136 + 2UL)) = (OPJ_INT32 )(((val1___13 & 15U) << 2) | (val2___11 >> 6));
#line 361
    *(pDst___37 + (i___136 + 3UL)) = (OPJ_INT32 )(val2___11 & 63U);
#line 354
    i___136 += 4UL;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 364
  if (length___34 & 3UL) {
#line 365
    __cil_tmp12___47 = pSrc___40;
#line 365
    pSrc___40 ++;
#line 365
    val0___14 = (OPJ_UINT32 )*__cil_tmp12___47;
#line 366
    length___34 &= 3UL;
#line 367
    *(pDst___37 + i___136) = (OPJ_INT32 )(val0___14 >> 2);
#line 369
    if (length___34 > 1UL) {
#line 370
      __cil_tmp14___57 = pSrc___40;
#line 370
      pSrc___40 ++;
#line 370
      val1___14 = (OPJ_UINT32 )*__cil_tmp14___57;
#line 371
      *(pDst___37 + (i___136 + 1UL)) = (OPJ_INT32 )(((val0___14 & 3U) << 4) | (val1___14 >> 4));
#line 372
      if (length___34 > 2UL) {
#line 373
        __cil_tmp16___43 = pSrc___40;
#line 373
        pSrc___40 ++;
#line 373
        val2___12 = (OPJ_UINT32 )*__cil_tmp16___43;
#line 374
        *(pDst___37 + (i___136 + 2UL)) = (OPJ_INT32 )(((val1___14 & 15U) << 2) | (val2___12 >> 6));
      }
    }
  }
#line 378
  return;
}
}
#line 379 "/root/patron-new/39/src/bin/jp2/convert.c"
static void convert_8u32s_C1R(OPJ_BYTE *pSrc___41 , OPJ_INT32 *pDst___38 , OPJ_SIZE_T length___35 ) 
{ 
  OPJ_SIZE_T i___137 ;

  {
#line 383
  i___137 = (OPJ_SIZE_T )0;
  {
#line 383
  while (1) {
    while_continue: /* CIL Label */ ;

#line 383
    if (! (i___137 < length___35)) {
#line 383
      goto while_break;
    }
#line 384
    *(pDst___38 + i___137) = (OPJ_INT32 )*(pSrc___41 + i___137);
#line 383
    i___137 ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 387
  return;
}
}
#line 387 "/root/patron-new/39/src/bin/jp2/convert.c"
convert_XXx32s_C1R convert_XXu32s_C1R_LUT[9]  = 
#line 387
  {      (void (*)(OPJ_BYTE * , OPJ_INT32 * , OPJ_SIZE_T  ))((void *)0),      & convert_1u32s_C1R,      & convert_2u32s_C1R,      (void (*)(OPJ_BYTE * , OPJ_INT32 * , OPJ_SIZE_T  ))((void *)0), 
        & convert_4u32s_C1R,      (void (*)(OPJ_BYTE * , OPJ_INT32 * , OPJ_SIZE_T  ))((void *)0),      & convert_6u32s_C1R,      (void (*)(OPJ_BYTE * , OPJ_INT32 * , OPJ_SIZE_T  ))((void *)0), 
        & convert_8u32s_C1R};
#line 400 "/root/patron-new/39/src/bin/jp2/convert.c"
static void convert_32s1u_C1R(OPJ_INT32 *pSrc___42 , OPJ_BYTE *pDst___39 , OPJ_SIZE_T length___36 ) 
{ 
  OPJ_SIZE_T i___138 ;
  OPJ_UINT32 src0___12 ;
  OPJ_UINT32 src1___11 ;
  OPJ_UINT32 src2___10 ;
  OPJ_UINT32 src3___8 ;
  OPJ_UINT32 src4___6 ;
  OPJ_UINT32 src5___6 ;
  OPJ_UINT32 src6___6 ;
  OPJ_UINT32 src7___6 ;
  OPJ_BYTE *__cil_tmp13___47 ;
  OPJ_UINT32 src0___13 ;
  OPJ_UINT32 src1___12 ;
  OPJ_UINT32 src2___11 ;
  OPJ_UINT32 src3___9 ;
  OPJ_UINT32 src4___7 ;
  OPJ_UINT32 src5___7 ;
  OPJ_UINT32 src6___7 ;
  OPJ_BYTE *__cil_tmp21___25 ;

  {
#line 404
  i___138 = (OPJ_SIZE_T )0;
  {
#line 404
  while (1) {
    while_continue: /* CIL Label */ ;

#line 404
    if (! (i___138 < (length___36 & 0xfffffffffffffff8UL))) {
#line 404
      goto while_break;
    }
#line 405
    src0___12 = (OPJ_UINT32 )*(pSrc___42 + i___138);
#line 406
    src1___11 = (OPJ_UINT32 )*(pSrc___42 + (i___138 + 1UL));
#line 407
    src2___10 = (OPJ_UINT32 )*(pSrc___42 + (i___138 + 2UL));
#line 408
    src3___8 = (OPJ_UINT32 )*(pSrc___42 + (i___138 + 3UL));
#line 409
    src4___6 = (OPJ_UINT32 )*(pSrc___42 + (i___138 + 4UL));
#line 410
    src5___6 = (OPJ_UINT32 )*(pSrc___42 + (i___138 + 5UL));
#line 411
    src6___6 = (OPJ_UINT32 )*(pSrc___42 + (i___138 + 6UL));
#line 412
    src7___6 = (OPJ_UINT32 )*(pSrc___42 + (i___138 + 7UL));
#line 414
    __cil_tmp13___47 = pDst___39;
#line 414
    pDst___39 ++;
#line 414
    *__cil_tmp13___47 = (OPJ_BYTE )((((((((src0___12 << 7) | (src1___11 << 6)) | (src2___10 << 5)) | (src3___8 << 4)) | (src4___6 << 3)) | (src5___6 << 2)) | (src6___6 << 1)) | src7___6);
#line 404
    i___138 += 8UL;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 418
  if (length___36 & 7UL) {
#line 419
    src0___13 = (OPJ_UINT32 )*(pSrc___42 + i___138);
#line 420
    src1___12 = 0U;
#line 421
    src2___11 = 0U;
#line 422
    src3___9 = 0U;
#line 423
    src4___7 = 0U;
#line 424
    src5___7 = 0U;
#line 425
    src6___7 = 0U;
#line 426
    length___36 &= 7UL;
#line 428
    if (length___36 > 1UL) {
#line 429
      src1___12 = (OPJ_UINT32 )*(pSrc___42 + (i___138 + 1UL));
#line 430
      if (length___36 > 2UL) {
#line 431
        src2___11 = (OPJ_UINT32 )*(pSrc___42 + (i___138 + 2UL));
#line 432
        if (length___36 > 3UL) {
#line 433
          src3___9 = (OPJ_UINT32 )*(pSrc___42 + (i___138 + 3UL));
#line 434
          if (length___36 > 4UL) {
#line 435
            src4___7 = (OPJ_UINT32 )*(pSrc___42 + (i___138 + 4UL));
#line 436
            if (length___36 > 5UL) {
#line 437
              src5___7 = (OPJ_UINT32 )*(pSrc___42 + (i___138 + 5UL));
#line 438
              if (length___36 > 6UL) {
#line 439
                src6___7 = (OPJ_UINT32 )*(pSrc___42 + (i___138 + 6UL));
              }
            }
          }
        }
      }
    }
#line 446
    __cil_tmp21___25 = pDst___39;
#line 446
    pDst___39 ++;
#line 446
    *__cil_tmp21___25 = (OPJ_BYTE )(((((((src0___13 << 7) | (src1___12 << 6)) | (src2___11 << 5)) | (src3___9 << 4)) | (src4___7 << 3)) | (src5___7 << 2)) | (src6___7 << 1));
  }
#line 448
  return;
}
}
#line 451 "/root/patron-new/39/src/bin/jp2/convert.c"
static void convert_32s2u_C1R(OPJ_INT32 *pSrc___43 , OPJ_BYTE *pDst___40 , OPJ_SIZE_T length___37 ) 
{ 
  OPJ_SIZE_T i___139 ;
  OPJ_UINT32 src0___14 ;
  OPJ_UINT32 src1___13 ;
  OPJ_UINT32 src2___12 ;
  OPJ_UINT32 src3___10 ;
  OPJ_BYTE *__cil_tmp9___41 ;
  OPJ_UINT32 src0___15 ;
  OPJ_UINT32 src1___14 ;
  OPJ_UINT32 src2___13 ;
  OPJ_BYTE *__cil_tmp13___48 ;

  {
#line 455
  i___139 = (OPJ_SIZE_T )0;
  {
#line 455
  while (1) {
    while_continue: /* CIL Label */ ;

#line 455
    if (! (i___139 < (length___37 & 0xfffffffffffffffcUL))) {
#line 455
      goto while_break;
    }
#line 456
    src0___14 = (OPJ_UINT32 )*(pSrc___43 + i___139);
#line 457
    src1___13 = (OPJ_UINT32 )*(pSrc___43 + (i___139 + 1UL));
#line 458
    src2___12 = (OPJ_UINT32 )*(pSrc___43 + (i___139 + 2UL));
#line 459
    src3___10 = (OPJ_UINT32 )*(pSrc___43 + (i___139 + 3UL));
#line 461
    __cil_tmp9___41 = pDst___40;
#line 461
    pDst___40 ++;
#line 461
    *__cil_tmp9___41 = (OPJ_BYTE )((((src0___14 << 6) | (src1___13 << 4)) | (src2___12 << 2)) | src3___10);
#line 455
    i___139 += 4UL;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 464
  if (length___37 & 3UL) {
#line 465
    src0___15 = (OPJ_UINT32 )*(pSrc___43 + i___139);
#line 466
    src1___14 = 0U;
#line 467
    src2___13 = 0U;
#line 468
    length___37 &= 3UL;
#line 470
    if (length___37 > 1UL) {
#line 471
      src1___14 = (OPJ_UINT32 )*(pSrc___43 + (i___139 + 1UL));
#line 472
      if (length___37 > 2UL) {
#line 473
        src2___13 = (OPJ_UINT32 )*(pSrc___43 + (i___139 + 2UL));
      }
    }
#line 476
    __cil_tmp13___48 = pDst___40;
#line 476
    pDst___40 ++;
#line 476
    *__cil_tmp13___48 = (OPJ_BYTE )(((src0___15 << 6) | (src1___14 << 4)) | (src2___13 << 2));
  }
#line 478
  return;
}
}
#line 480 "/root/patron-new/39/src/bin/jp2/convert.c"
static void convert_32s4u_C1R(OPJ_INT32 *pSrc___44 , OPJ_BYTE *pDst___41 , OPJ_SIZE_T length___38 ) 
{ 
  OPJ_SIZE_T i___140 ;
  OPJ_UINT32 src0___16 ;
  OPJ_UINT32 src1___15 ;
  OPJ_BYTE *__cil_tmp7___54 ;
  OPJ_UINT32 src0___17 ;
  OPJ_BYTE *__cil_tmp9___42 ;

  {
#line 484
  i___140 = (OPJ_SIZE_T )0;
  {
#line 484
  while (1) {
    while_continue: /* CIL Label */ ;

#line 484
    if (! (i___140 < (length___38 & 0xfffffffffffffffeUL))) {
#line 484
      goto while_break;
    }
#line 485
    src0___16 = (OPJ_UINT32 )*(pSrc___44 + i___140);
#line 486
    src1___15 = (OPJ_UINT32 )*(pSrc___44 + (i___140 + 1UL));
#line 488
    __cil_tmp7___54 = pDst___41;
#line 488
    pDst___41 ++;
#line 488
    *__cil_tmp7___54 = (OPJ_BYTE )((src0___16 << 4) | src1___15);
#line 484
    i___140 += 2UL;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 491
  if (length___38 & 1UL) {
#line 492
    src0___17 = (OPJ_UINT32 )*(pSrc___44 + i___140);
#line 493
    __cil_tmp9___42 = pDst___41;
#line 493
    pDst___41 ++;
#line 493
    *__cil_tmp9___42 = (OPJ_BYTE )(src0___17 << 4);
  }
#line 495
  return;
}
}
#line 497 "/root/patron-new/39/src/bin/jp2/convert.c"
static void convert_32s6u_C1R(OPJ_INT32 *pSrc___45 , OPJ_BYTE *pDst___42 , OPJ_SIZE_T length___39 ) 
{ 
  OPJ_SIZE_T i___141 ;
  OPJ_UINT32 src0___18 ;
  OPJ_UINT32 src1___16 ;
  OPJ_UINT32 src2___14 ;
  OPJ_UINT32 src3___11 ;
  OPJ_BYTE *__cil_tmp9___43 ;
  OPJ_BYTE *__cil_tmp10___42 ;
  OPJ_BYTE *__cil_tmp11___29 ;
  OPJ_UINT32 src0___19 ;
  OPJ_UINT32 src1___17 ;
  OPJ_UINT32 src2___15 ;
  OPJ_BYTE *__cil_tmp15___41 ;
  OPJ_BYTE *__cil_tmp16___44 ;
  OPJ_BYTE *__cil_tmp17___34 ;

  {
#line 501
  i___141 = (OPJ_SIZE_T )0;
  {
#line 501
  while (1) {
    while_continue: /* CIL Label */ ;

#line 501
    if (! (i___141 < (length___39 & 0xfffffffffffffffcUL))) {
#line 501
      goto while_break;
    }
#line 502
    src0___18 = (OPJ_UINT32 )*(pSrc___45 + i___141);
#line 503
    src1___16 = (OPJ_UINT32 )*(pSrc___45 + (i___141 + 1UL));
#line 504
    src2___14 = (OPJ_UINT32 )*(pSrc___45 + (i___141 + 2UL));
#line 505
    src3___11 = (OPJ_UINT32 )*(pSrc___45 + (i___141 + 3UL));
#line 507
    __cil_tmp9___43 = pDst___42;
#line 507
    pDst___42 ++;
#line 507
    *__cil_tmp9___43 = (OPJ_BYTE )((src0___18 << 2) | (src1___16 >> 4));
#line 508
    __cil_tmp10___42 = pDst___42;
#line 508
    pDst___42 ++;
#line 508
    *__cil_tmp10___42 = (OPJ_BYTE )(((src1___16 & 15U) << 4) | (src2___14 >> 2));
#line 509
    __cil_tmp11___29 = pDst___42;
#line 509
    pDst___42 ++;
#line 509
    *__cil_tmp11___29 = (OPJ_BYTE )(((src2___14 & 3U) << 6) | src3___11);
#line 501
    i___141 += 4UL;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 512
  if (length___39 & 3UL) {
#line 513
    src0___19 = (OPJ_UINT32 )*(pSrc___45 + i___141);
#line 514
    src1___17 = 0U;
#line 515
    src2___15 = 0U;
#line 516
    length___39 &= 3UL;
#line 518
    if (length___39 > 1UL) {
#line 519
      src1___17 = (OPJ_UINT32 )*(pSrc___45 + (i___141 + 1UL));
#line 520
      if (length___39 > 2UL) {
#line 521
        src2___15 = (OPJ_UINT32 )*(pSrc___45 + (i___141 + 2UL));
      }
    }
#line 524
    __cil_tmp15___41 = pDst___42;
#line 524
    pDst___42 ++;
#line 524
    *__cil_tmp15___41 = (OPJ_BYTE )((src0___19 << 2) | (src1___17 >> 4));
#line 525
    if (length___39 > 1UL) {
#line 526
      __cil_tmp16___44 = pDst___42;
#line 526
      pDst___42 ++;
#line 526
      *__cil_tmp16___44 = (OPJ_BYTE )(((src1___17 & 15U) << 4) | (src2___15 >> 2));
#line 527
      if (length___39 > 2UL) {
#line 528
        __cil_tmp17___34 = pDst___42;
#line 528
        pDst___42 ++;
#line 528
        *__cil_tmp17___34 = (OPJ_BYTE )((src2___15 & 3U) << 6);
      }
    }
  }
#line 532
  return;
}
}
#line 533 "/root/patron-new/39/src/bin/jp2/convert.c"
static void convert_32s8u_C1R(OPJ_INT32 *pSrc___46 , OPJ_BYTE *pDst___43 , OPJ_SIZE_T length___40 ) 
{ 
  OPJ_SIZE_T i___142 ;

  {
#line 537
  i___142 = (OPJ_SIZE_T )0;
  {
#line 537
  while (1) {
    while_continue: /* CIL Label */ ;

#line 537
    if (! (i___142 < length___40)) {
#line 537
      goto while_break;
    }
#line 538
    *(pDst___43 + i___142) = (OPJ_BYTE )*(pSrc___46 + i___142);
#line 537
    i___142 ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 541
  return;
}
}
#line 541 "/root/patron-new/39/src/bin/jp2/convert.c"
convert_32sXXx_C1R convert_32sXXu_C1R_LUT[9]  = 
#line 541
  {      (void (*)(OPJ_INT32 * , OPJ_BYTE * , OPJ_SIZE_T  ))((void *)0),      & convert_32s1u_C1R,      & convert_32s2u_C1R,      (void (*)(OPJ_INT32 * , OPJ_BYTE * , OPJ_SIZE_T  ))((void *)0), 
        & convert_32s4u_C1R,      (void (*)(OPJ_INT32 * , OPJ_BYTE * , OPJ_SIZE_T  ))((void *)0),      & convert_32s6u_C1R,      (void (*)(OPJ_INT32 * , OPJ_BYTE * , OPJ_SIZE_T  ))((void *)0), 
        & convert_32s8u_C1R};
#line 584 "/root/patron-new/39/src/bin/jp2/convert.c"
static unsigned short get_tga_ushort(unsigned char const   *data ) 
{ 


  {
#line 586
  return ((unsigned short )((int )*(data + 0) | ((int )*(data + 1) << 8)));
}
}
#line 591 "/root/patron-new/39/src/bin/jp2/convert.c"
static int tga_readheader(FILE *fp , unsigned int *bits_per_pixel , unsigned int *width___11 ,
                          unsigned int *height___10 , int *flip_image ) 
{ 
  int palette_size ;
  unsigned char tga[18] ;
  unsigned char id_len ;
  unsigned char image_type ;
  unsigned char pixel_depth ;
  unsigned char image_desc ;
  unsigned short cmap_len ;
  unsigned short cmap_entry_size ;
  unsigned short image_w ;
  unsigned short image_h ;
  unsigned long __cil_tmp16___45 ;
  unsigned char *id ;
  void *__cil_tmp21___26 ;
  unsigned long __cil_tmp22___36 ;

  {
#line 601
  if (! bits_per_pixel) {
#line 602
    return (0);
  } else
#line 601
  if (! width___11) {
#line 602
    return (0);
  } else
#line 601
  if (! height___10) {
#line 602
    return (0);
  } else
#line 601
  if (! flip_image) {
#line 602
    return (0);
  }
  {
#line 605
  __cil_tmp16___45 = fread((void *)(tga), 18UL, 1UL, fp);
  }
#line 605
  if (__cil_tmp16___45 != 1UL) {
    {
#line 606
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 608
    return (0);
  }
  {
#line 610
  id_len = tga[0];
#line 612
  image_type = tga[2];
#line 614
  cmap_len = get_tga_ushort((unsigned char const   *)(& tga[5]));
#line 615
  cmap_entry_size = (unsigned short )tga[7];
#line 622
  image_w = get_tga_ushort((unsigned char const   *)(& tga[12]));
#line 623
  image_h = get_tga_ushort((unsigned char const   *)(& tga[14]));
#line 624
  pixel_depth = tga[16];
#line 625
  image_desc = tga[17];
#line 627
  *bits_per_pixel = (unsigned int )pixel_depth;
#line 628
  *width___11 = (unsigned int )image_w;
#line 629
  *height___10 = (unsigned int )image_h;
  }
#line 632
  if (id_len) {
    {
#line 633
    __cil_tmp21___26 = malloc((unsigned long )id_len);
#line 633
    id = (unsigned char *)__cil_tmp21___26;
    }
#line 634
    if ((unsigned long )id == (unsigned long )((unsigned char *)0)) {
      {
#line 635
      fprintf(stderr, "tga_readheader: memory out\n");
      }
#line 636
      return (0);
    }
    {
#line 638
    __cil_tmp22___36 = fread((void *)id, (unsigned long )id_len, 1UL, fp);
    }
#line 638
    if (! __cil_tmp22___36) {
      {
#line 639
      fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 641
      free((void *)id);
      }
#line 642
      return (0);
    }
    {
#line 644
    free((void *)id);
    }
  }
#line 650
  if ((int )image_type > 8) {
    {
#line 651
    fprintf(stderr, "Sorry, compressed tga files are not currently supported.\n");
    }
#line 652
    return (0);
  }
#line 655
  *flip_image = ! ((int )image_desc & 32);
#line 658
  palette_size = (int )cmap_len * ((int )cmap_entry_size / 8);
#line 660
  if (palette_size > 0) {
    {
#line 661
    fprintf(stderr, "File contains a palette - not yet supported.");
#line 662
    fseek(fp, (long )palette_size, 1);
    }
  }
#line 664
  return (1);
}
}
#line 676 "/root/patron-new/39/src/bin/jp2/convert.c"
static int tga_writeheader(FILE *fp___0 , int bits_per_pixel___0 , int width___12 ,
                           int height___11 , OPJ_BOOL flip_image___0 ) 
{ 
  OPJ_UINT16 image_w___0 ;
  OPJ_UINT16 image_h___0 ;
  OPJ_UINT16 us0 ;
  unsigned char uc0 ;
  unsigned char image_type___0 ;
  unsigned char pixel_depth___0 ;
  unsigned char image_desc___0 ;
  unsigned long __cil_tmp13___49 ;
  unsigned long __cil_tmp14___58 ;
  unsigned long __cil_tmp15___42 ;
  unsigned long __cil_tmp16___46 ;
  unsigned long __cil_tmp17___36 ;
  unsigned long __cil_tmp18___36 ;
  unsigned long __cil_tmp19___37 ;
  unsigned long __cil_tmp20___42 ;
  unsigned long __cil_tmp21___27 ;
  unsigned long __cil_tmp22___37 ;
  unsigned long __cil_tmp23___31 ;
  unsigned long __cil_tmp24___34 ;

  {
#line 683
  if (! bits_per_pixel___0) {
#line 684
    return (0);
  } else
#line 683
  if (! width___12) {
#line 684
    return (0);
  } else
#line 683
  if (! height___11) {
#line 684
    return (0);
  }
#line 687
  pixel_depth___0 = (unsigned char)0;
#line 689
  if (bits_per_pixel___0 < 256) {
#line 690
    pixel_depth___0 = (unsigned char )bits_per_pixel___0;
  } else {
    {
#line 692
    fprintf(stderr, "ERROR: Wrong bits per pixel inside tga_header");
    }
#line 693
    return (0);
  }
  {
#line 695
  uc0 = (unsigned char)0;
#line 697
  __cil_tmp13___49 = fwrite((void const   *)(& uc0), 1UL, 1UL, fp___0);
  }
#line 697
  if (__cil_tmp13___49 != 1UL) {
#line 698
    goto fails;
  }
  {
#line 700
  __cil_tmp14___58 = fwrite((void const   *)(& uc0), 1UL, 1UL, fp___0);
  }
#line 700
  if (__cil_tmp14___58 != 1UL) {
#line 701
    goto fails;
  }
  {
#line 704
  image_type___0 = (unsigned char)2;
#line 705
  __cil_tmp15___42 = fwrite((void const   *)(& image_type___0), 1UL, 1UL, fp___0);
  }
#line 705
  if (__cil_tmp15___42 != 1UL) {
#line 706
    goto fails;
  }
  {
#line 709
  us0 = (OPJ_UINT16 )0;
#line 710
  __cil_tmp16___46 = fwrite((void const   *)(& us0), 2UL, 1UL, fp___0);
  }
#line 710
  if (__cil_tmp16___46 != 1UL) {
#line 711
    goto fails;
  }
  {
#line 713
  __cil_tmp17___36 = fwrite((void const   *)(& us0), 2UL, 1UL, fp___0);
  }
#line 713
  if (__cil_tmp17___36 != 1UL) {
#line 714
    goto fails;
  }
  {
#line 716
  __cil_tmp18___36 = fwrite((void const   *)(& uc0), 1UL, 1UL, fp___0);
  }
#line 716
  if (__cil_tmp18___36 != 1UL) {
#line 717
    goto fails;
  }
  {
#line 720
  __cil_tmp19___37 = fwrite((void const   *)(& us0), 2UL, 1UL, fp___0);
  }
#line 720
  if (__cil_tmp19___37 != 1UL) {
#line 721
    goto fails;
  }
  {
#line 723
  __cil_tmp20___42 = fwrite((void const   *)(& us0), 2UL, 1UL, fp___0);
  }
#line 723
  if (__cil_tmp20___42 != 1UL) {
#line 724
    goto fails;
  }
  {
#line 727
  image_w___0 = (unsigned short )width___12;
#line 728
  image_h___0 = (unsigned short )height___11;
#line 731
  __cil_tmp21___27 = fwrite((void const   *)(& image_w___0), 2UL, 1UL, fp___0);
  }
#line 731
  if (__cil_tmp21___27 != 1UL) {
#line 732
    goto fails;
  }
  {
#line 734
  __cil_tmp22___37 = fwrite((void const   *)(& image_h___0), 2UL, 1UL, fp___0);
  }
#line 734
  if (__cil_tmp22___37 != 1UL) {
#line 735
    goto fails;
  }
  {
#line 748
  __cil_tmp23___31 = fwrite((void const   *)(& pixel_depth___0), 1UL, 1UL, fp___0);
  }
#line 748
  if (__cil_tmp23___31 != 1UL) {
#line 749
    goto fails;
  }
#line 752
  image_desc___0 = (unsigned char)8;
#line 754
  if (flip_image___0) {
#line 755
    image_desc___0 = (unsigned char )((int )image_desc___0 | 32);
  }
  {
#line 757
  __cil_tmp24___34 = fwrite((void const   *)(& image_desc___0), 1UL, 1UL, fp___0);
  }
#line 757
  if (__cil_tmp24___34 != 1UL) {
#line 758
    goto fails;
  }
#line 761
  return (1);
  fails: 
  {
#line 764
  fputs("\nwrite_tgaheader: write ERROR\n", stderr);
  }
#line 765
  return (0);
}
}
#line 768 "/root/patron-new/39/src/bin/jp2/convert.c"
opj_image_t *tgatoimage(char const   *filename___1 , opj_cparameters_t *parameters___14 ) 
{ 
  FILE *f ;
  opj_image_t *image___24 ;
  unsigned int image_width ;
  unsigned int image_height ;
  unsigned int pixel_bit_depth ;
  unsigned int x___6 ;
  unsigned int y___7 ;
  int flip_image___1 ;
  opj_image_cmptparm_t cmptparm___2[4] ;
  int numcomps___6 ;
  OPJ_COLOR_SPACE color_space___0 ;
  OPJ_BOOL mono ;
  OPJ_BOOL save_alpha ;
  int subsampling_dx___0 ;
  int subsampling_dy___0 ;
  int i___143 ;
  int __cil_tmp20___43 ;
  int tmp___478 ;
  int tmp___479 ;
  char ch ;
  OPJ_UINT64 expected_file_size ;
  long curpos ;
  long __cil_tmp26___24 ;
  unsigned long __cil_tmp27___19 ;
  OPJ_UINT32 tmp___480 ;
  OPJ_UINT32 tmp___481 ;
  int index___4 ;
  unsigned char r___1 ;
  unsigned char g___0 ;
  unsigned char b___1 ;
  unsigned long __cil_tmp36___16 ;
  unsigned long __cil_tmp37___8 ;
  unsigned long __cil_tmp38___7 ;
  unsigned char r___2 ;
  unsigned char g___1 ;
  unsigned char b___2 ;
  unsigned char a___0 ;
  unsigned long __cil_tmp45___3 ;
  unsigned long __cil_tmp46___1 ;
  unsigned long __cil_tmp47___5 ;
  unsigned long __cil_tmp48___6 ;
  int tmp___482 ;
  int tmp___483 ;

  {
  {
#line 774
  flip_image___1 = 0;
#line 783
  f = fopen(filename___1, "rb");
  }
#line 784
  if (! f) {
    {
#line 785
    fprintf(stderr, "Failed to open %s for reading !!\n", filename___1);
    }
#line 786
    return ((opj_image_t *)0);
  }
  {
#line 789
  __cil_tmp20___43 = tga_readheader(f, & pixel_bit_depth, & image_width, & image_height,
                                    & flip_image___1);
  }
#line 789
  if (! __cil_tmp20___43) {
    {
#line 791
    fclose(f);
    }
#line 792
    return ((opj_image_t *)((void *)0));
  }
#line 796
  if (! (pixel_bit_depth == 24U)) {
#line 796
    if (! (pixel_bit_depth == 32U)) {
      {
#line 797
      fclose(f);
      }
#line 798
      return ((opj_image_t *)((void *)0));
    }
  }
  {
#line 802
  memset((void *)(& cmptparm___2[0]), 0, 4UL * sizeof(opj_image_cmptparm_t ));
  }
#line 804
  if (pixel_bit_depth == 8U) {
#line 804
    tmp___482 = 1;
  } else
#line 804
  if (pixel_bit_depth == 16U) {
#line 804
    tmp___482 = 1;
  } else {
#line 804
    tmp___482 = 0;
  }
#line 804
  mono = tmp___482;
#line 806
  if (pixel_bit_depth == 16U) {
#line 806
    tmp___483 = 1;
  } else
#line 806
  if (pixel_bit_depth == 32U) {
#line 806
    tmp___483 = 1;
  } else {
#line 806
    tmp___483 = 0;
  }
#line 806
  save_alpha = tmp___483;
#line 809
  if (mono) {
#line 810
    color_space___0 = (OPJ_COLOR_SPACE )2;
#line 811
    if (save_alpha) {
#line 811
      tmp___478 = 2;
    } else {
#line 811
      tmp___478 = 1;
    }
#line 811
    numcomps___6 = tmp___478;
  } else {
#line 813
    if (save_alpha) {
#line 813
      tmp___479 = 4;
    } else {
#line 813
      tmp___479 = 3;
    }
#line 813
    numcomps___6 = tmp___479;
#line 814
    color_space___0 = (OPJ_COLOR_SPACE )1;
  }
#line 819
  if (image_height != 0U) {
#line 819
    if (image_width > (10000000U / image_height) / (OPJ_UINT32 )numcomps___6) {
      {
#line 822
      expected_file_size = ((OPJ_UINT64 )image_width * (unsigned long )image_height) * (unsigned long )((OPJ_UINT32 )numcomps___6);
#line 824
      __cil_tmp26___24 = ftell(f);
#line 824
      curpos = __cil_tmp26___24;
      }
#line 825
      if (expected_file_size > 2147483647UL) {
#line 826
        expected_file_size = (OPJ_UINT64 )2147483647;
      }
      {
#line 828
      fseek(f, (long )expected_file_size - 1L, 0);
#line 829
      __cil_tmp27___19 = fread((void *)(& ch), 1UL, 1UL, f);
      }
#line 829
      if (__cil_tmp27___19 != 1UL) {
        {
#line 830
        fclose(f);
        }
#line 831
        return ((opj_image_t *)((void *)0));
      }
      {
#line 833
      fseek(f, curpos, 0);
      }
    }
  }
#line 836
  subsampling_dx___0 = parameters___14->subsampling_dx;
#line 837
  subsampling_dy___0 = parameters___14->subsampling_dy;
#line 839
  i___143 = 0;
  {
#line 839
  while (1) {
    while_continue: /* CIL Label */ ;

#line 839
    if (! (i___143 < numcomps___6)) {
#line 839
      goto while_break;
    }
#line 840
    cmptparm___2[i___143].prec = (OPJ_UINT32 )8;
#line 841
    cmptparm___2[i___143].bpp = (OPJ_UINT32 )8;
#line 842
    cmptparm___2[i___143].sgnd = (OPJ_UINT32 )0;
#line 843
    cmptparm___2[i___143].dx = (OPJ_UINT32 )subsampling_dx___0;
#line 844
    cmptparm___2[i___143].dy = (OPJ_UINT32 )subsampling_dy___0;
#line 845
    cmptparm___2[i___143].w = image_width;
#line 846
    cmptparm___2[i___143].h = image_height;
#line 839
    i___143 ++;
  }
  while_break___3: /* CIL Label */ ;
  }

  while_break: 
  {
#line 850
  image___24 = opj_image_create((OPJ_UINT32 )numcomps___6, & cmptparm___2[0], color_space___0);
  }
#line 852
  if (! image___24) {
    {
#line 853
    fclose(f);
    }
#line 854
    return ((opj_image_t *)((void *)0));
  }
#line 859
  image___24->x0 = (OPJ_UINT32 )parameters___14->image_offset_x0;
#line 860
  image___24->y0 = (OPJ_UINT32 )parameters___14->image_offset_y0;
#line 861
  if (! image___24->x0) {
#line 861
    tmp___480 = (image_width - 1U) * (OPJ_UINT32 )subsampling_dx___0 + 1U;
  } else {
#line 861
    tmp___480 = (image___24->x0 + (image_width - 1U) * (OPJ_UINT32 )subsampling_dx___0) + 1U;
  }
#line 861
  image___24->x1 = tmp___480;
#line 864
  if (! image___24->y0) {
#line 864
    tmp___481 = (image_height - 1U) * (OPJ_UINT32 )subsampling_dy___0 + 1U;
  } else {
#line 864
    tmp___481 = (image___24->y0 + (image_height - 1U) * (OPJ_UINT32 )subsampling_dy___0) + 1U;
  }
#line 864
  image___24->y1 = tmp___481;
#line 869
  y___7 = 0U;
  {
#line 869
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 869
    if (! (y___7 < image_height)) {
#line 869
      goto while_break___0;
    }
#line 872
    if (flip_image___1) {
#line 873
      index___4 = (int )(((image_height - y___7) - 1U) * image_width);
    } else {
#line 875
      index___4 = (int )(y___7 * image_width);
    }
#line 878
    if (numcomps___6 == 3) {
#line 879
      x___6 = 0U;
      {
#line 879
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 879
        if (! (x___6 < image_width)) {
#line 879
          goto while_break___1;
        }
        {
#line 882
        __cil_tmp36___16 = fread((void *)(& b___1), 1UL, 1UL, f);
        }
#line 882
        if (! __cil_tmp36___16) {
          {
#line 883
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 885
          opj_image_destroy(image___24);
#line 886
          fclose(f);
          }
#line 887
          return ((opj_image_t *)((void *)0));
        }
        {
#line 889
        __cil_tmp37___8 = fread((void *)(& g___0), 1UL, 1UL, f);
        }
#line 889
        if (! __cil_tmp37___8) {
          {
#line 890
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 892
          opj_image_destroy(image___24);
#line 893
          fclose(f);
          }
#line 894
          return ((opj_image_t *)((void *)0));
        }
        {
#line 896
        __cil_tmp38___7 = fread((void *)(& r___1), 1UL, 1UL, f);
        }
#line 896
        if (! __cil_tmp38___7) {
          {
#line 897
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 899
          opj_image_destroy(image___24);
#line 900
          fclose(f);
          }
#line 901
          return ((opj_image_t *)((void *)0));
        }
#line 904
        *((image___24->comps + 0)->data + index___4) = (OPJ_INT32 )r___1;
#line 905
        *((image___24->comps + 1)->data + index___4) = (OPJ_INT32 )g___0;
#line 906
        *((image___24->comps + 2)->data + index___4) = (OPJ_INT32 )b___1;
#line 907
        index___4 ++;
#line 879
        x___6 ++;
      }
      while_break___5: /* CIL Label */ ;
      }

      while_break___1: ;
    } else
#line 909
    if (numcomps___6 == 4) {
#line 910
      x___6 = 0U;
      {
#line 910
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 910
        if (! (x___6 < image_width)) {
#line 910
          goto while_break___2;
        }
        {
#line 912
        __cil_tmp45___3 = fread((void *)(& b___2), 1UL, 1UL, f);
        }
#line 912
        if (! __cil_tmp45___3) {
          {
#line 913
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 915
          opj_image_destroy(image___24);
#line 916
          fclose(f);
          }
#line 917
          return ((opj_image_t *)((void *)0));
        }
        {
#line 919
        __cil_tmp46___1 = fread((void *)(& g___1), 1UL, 1UL, f);
        }
#line 919
        if (! __cil_tmp46___1) {
          {
#line 920
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 922
          opj_image_destroy(image___24);
#line 923
          fclose(f);
          }
#line 924
          return ((opj_image_t *)((void *)0));
        }
        {
#line 926
        __cil_tmp47___5 = fread((void *)(& r___2), 1UL, 1UL, f);
        }
#line 926
        if (! __cil_tmp47___5) {
          {
#line 927
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 929
          opj_image_destroy(image___24);
#line 930
          fclose(f);
          }
#line 931
          return ((opj_image_t *)((void *)0));
        }
        {
#line 933
        __cil_tmp48___6 = fread((void *)(& a___0), 1UL, 1UL, f);
        }
#line 933
        if (! __cil_tmp48___6) {
          {
#line 934
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 936
          opj_image_destroy(image___24);
#line 937
          fclose(f);
          }
#line 938
          return ((opj_image_t *)((void *)0));
        }
#line 941
        *((image___24->comps + 0)->data + index___4) = (OPJ_INT32 )r___2;
#line 942
        *((image___24->comps + 1)->data + index___4) = (OPJ_INT32 )g___1;
#line 943
        *((image___24->comps + 2)->data + index___4) = (OPJ_INT32 )b___2;
#line 944
        *((image___24->comps + 3)->data + index___4) = (OPJ_INT32 )a___0;
#line 945
        index___4 ++;
#line 910
        x___6 ++;
      }
      while_break___6: /* CIL Label */ ;
      }

      while_break___2: ;
    } else {
      {
#line 948
      fprintf(stderr, "Currently unsupported bit depth : %s\n", filename___1);
      }
    }
#line 869
    y___7 ++;
  }
  while_break___4: /* CIL Label */ ;
  }

  while_break___0: 
  {
#line 951
  fclose(f);
  }
#line 952
  return (image___24);
}
}
#line 955 "/root/patron-new/39/src/bin/jp2/convert.c"
int imagetotga(opj_image_t *image___25 , char const   *outfile___1 ) 
{ 
  int width___13 ;
  int height___12 ;
  int bpp ;
  int x___7 ;
  int y___8 ;
  OPJ_BOOL write_alpha ;
  unsigned int i___144 ;
  int adjustR___0 ;
  int adjustG___0 ;
  int adjustB___0 ;
  int fails___0 ;
  unsigned int alpha_channel___0 ;
  float r___3 ;
  float g___2 ;
  float b___3 ;
  float a___1 ;
  unsigned char value___1 ;
  float scale ;
  FILE *fdest___0 ;
  size_t res___0 ;
  int tmp___484 ;
  int __cil_tmp26___25 ;
  int tmp___485 ;
  int tmp___486 ;
  int tmp___487 ;
  unsigned int index___5 ;
  int __cil_tmp35___18 ;
  unsigned int __cil_tmp36___17 ;
  int tmp___488 ;

  {
  {
#line 960
  adjustG___0 = 0;
#line 960
  adjustB___0 = 0;
#line 967
  fails___0 = 1;
#line 969
  fdest___0 = fopen(outfile___1, "wb\252\006]U");
  }
#line 970
  if (! fdest___0) {
    {
#line 971
    fprintf(stderr, "ERROR -> failed to open %s for writing\n", outfile___1);
    }
#line 972
    return (1);
  }
#line 975
  i___144 = 0U;
  {
#line 975
  while (1) {
    while_continue: /* CIL Label */ ;

#line 975
    if (! (i___144 < image___25->numcomps - 1U)) {
#line 975
      goto while_break;
    }
#line 976
    if ((image___25->comps + 0)->dx != (image___25->comps + (i___144 + 1U))->dx) {
      {
#line 980
      fclose(fdest___0);
#line 981
      fprintf(stderr, "Unable to create a tga file with such J2K image charateristics.\n\220");
      }
#line 983
      return (1);
    } else
#line 976
    if ((image___25->comps + 0)->dy != (image___25->comps + (i___144 + 1U))->dy) {
      {
#line 980
      fclose(fdest___0);
#line 981
      fprintf(stderr, "Unable to create a tga file with such J2K image charateristics.\n\220");
      }
#line 983
      return (1);
    } else
#line 976
    if ((image___25->comps + 0)->prec != (image___25->comps + (i___144 + 1U))->prec) {
      {
#line 980
      fclose(fdest___0);
#line 981
      fprintf(stderr, "Unable to create a tga file with such J2K image charateristics.\n\220");
      }
#line 983
      return (1);
    } else
#line 976
    if ((image___25->comps + 0)->sgnd != (image___25->comps + (i___144 + 1U))->sgnd) {
      {
#line 980
      fclose(fdest___0);
#line 981
      fprintf(stderr, "Unable to create a tga file with such J2K image charateristics.\n\220");
      }
#line 983
      return (1);
    }
#line 975
    i___144 ++;
  }
  while_break___2: /* CIL Label */ ;
  }

  while_break: 
#line 987
  width___13 = (int )(image___25->comps + 0)->w;
#line 988
  height___12 = (int )(image___25->comps + 0)->h;
#line 991
  if (image___25->numcomps == 2U) {
#line 991
    tmp___488 = 1;
  } else
#line 991
  if (image___25->numcomps == 4U) {
#line 991
    tmp___488 = 1;
  } else {
#line 991
    tmp___488 = 0;
  }
#line 991
  write_alpha = tmp___488;
#line 994
  if (write_alpha) {
#line 994
    tmp___484 = 32;
  } else {
#line 994
    tmp___484 = 24;
  }
  {
#line 994
  bpp = tmp___484;
#line 996
  __cil_tmp26___25 = tga_writeheader(fdest___0, bpp, width___13, height___12, 1);
  }
#line 996
  if (! __cil_tmp26___25) {
#line 997
    goto fin;
  }
#line 1000
  alpha_channel___0 = image___25->numcomps - 1U;
#line 1002
  scale = 255.f / (float )((1 << (image___25->comps + 0)->prec) - 1);
#line 1004
  if ((image___25->comps + 0)->sgnd) {
#line 1004
    tmp___485 = 1 << ((image___25->comps + 0)->prec - 1U);
  } else {
#line 1004
    tmp___485 = 0;
  }
#line 1004
  adjustR___0 = tmp___485;
#line 1005
  if (image___25->numcomps >= 3U) {
#line 1006
    if ((image___25->comps + 1)->sgnd) {
#line 1006
      tmp___486 = 1 << ((image___25->comps + 1)->prec - 1U);
    } else {
#line 1006
      tmp___486 = 0;
    }
#line 1006
    adjustG___0 = tmp___486;
#line 1007
    if ((image___25->comps + 2)->sgnd) {
#line 1007
      tmp___487 = 1 << ((image___25->comps + 2)->prec - 1U);
    } else {
#line 1007
      tmp___487 = 0;
    }
#line 1007
    adjustB___0 = tmp___487;
  }
#line 1010
  y___8 = 0;
  {
#line 1010
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 1010
    if (! (y___8 < height___12)) {
#line 1010
      goto while_break___0;
    }
#line 1011
    index___5 = (unsigned int )(y___8 * width___13);
#line 1013
    x___7 = 0;
    {
#line 1013
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 1013
      if (! (x___7 < width___13)) {
#line 1013
        goto while_break___1;
      }
#line 1014
      r___3 = (float )(*((image___25->comps + 0)->data + index___5) + adjustR___0);
#line 1016
      if (image___25->numcomps > 2U) {
#line 1017
        g___2 = (float )(*((image___25->comps + 1)->data + index___5) + adjustG___0);
#line 1018
        b___3 = (float )(*((image___25->comps + 2)->data + index___5) + adjustB___0);
      } else {
#line 1021
        g___2 = r___3;
#line 1022
        b___3 = r___3;
      }
#line 1026
      if ((double )b___3 > 255.) {
#line 1027
        b___3 = (float )255.;
      } else
#line 1028
      if ((double )b___3 < 0.) {
#line 1029
        b___3 = (float )0.;
      }
      {
#line 1031
      value___1 = (unsigned char )(b___3 * scale);
#line 1032
      res___0 = fwrite((void const   *)(& value___1), 1UL, 1UL, fdest___0);
      }
#line 1034
      if (res___0 < 1UL) {
        {
#line 1035
        fprintf(stderr, "failed to write 1 byte for %s\n", outfile___1);
        }
#line 1036
        goto fin;
      }
#line 1038
      if ((double )g___2 > 255.) {
#line 1039
        g___2 = (float )255.;
      } else
#line 1040
      if ((double )g___2 < 0.) {
#line 1041
        g___2 = (float )0.;
      }
      {
#line 1043
      value___1 = (unsigned char )(g___2 * scale);
#line 1044
      res___0 = fwrite((void const   *)(& value___1), 1UL, 1UL, fdest___0);
      }
#line 1046
      if (res___0 < 1UL) {
        {
#line 1047
        fprintf(stderr, "failed to write 1 byte for %s\n", outfile___1);
        }
#line 1048
        goto fin;
      }
#line 1050
      if ((double )r___3 > 255.) {
#line 1051
        r___3 = (float )255.;
      } else
#line 1052
      if ((double )r___3 < 0.) {
#line 1053
        r___3 = (float )0.;
      }
      {
#line 1055
      value___1 = (unsigned char )(r___3 * scale);
#line 1056
      res___0 = fwrite((void const   *)(& value___1), 1UL, 1UL, fdest___0);
      }
#line 1058
      if (res___0 < 1UL) {
        {
#line 1059
        fprintf(stderr, "failed to write 1 byte for %s\n", outfile___1);
        }
#line 1060
        goto fin;
      }
#line 1063
      if (write_alpha) {
#line 1064
        a___1 = (float )*((image___25->comps + alpha_channel___0)->data + index___5);
#line 1065
        if ((double )a___1 > 255.) {
#line 1066
          a___1 = (float )255.;
        } else
#line 1067
        if ((double )a___1 < 0.) {
#line 1068
          a___1 = (float )0.;
        }
        {
#line 1070
        value___1 = (unsigned char )(a___1 * scale);
#line 1071
        res___0 = fwrite((void const   *)(& value___1), 1UL, 1UL, fdest___0);
        }
#line 1073
        if (res___0 < 1UL) {
          {
#line 1074
          fprintf(stderr, "failed to write 1 byte for %s\n", outfile___1);
          }
#line 1075
          goto fin;
        }
      }
#line 1013
      __cil_tmp36___17 = index___5;
#line 1013
      index___5 ++;
#line 1013
      __cil_tmp35___18 = x___7;
#line 1013
      x___7 ++;
    }
    while_break___4: /* CIL Label */ ;
    }

    while_break___1: 
#line 1010
    y___8 ++;
  }
  while_break___3: /* CIL Label */ ;
  }

  while_break___0: 
#line 1080
  fails___0 = 0;
  fin: 
  {
#line 1082
  fclose(fdest___0);
  }
#line 1084
  return (fails___0);
}
}
#line 1094 "/root/patron-new/39/src/bin/jp2/convert.c"
static unsigned char readuchar(FILE *f___0 ) 
{ 
  unsigned char c1___3 ;
  unsigned long __cil_tmp3___34 ;

  {
  {
#line 1097
  __cil_tmp3___34 = fread((void *)(& c1___3), 1UL, 1UL, f___0);
  }
#line 1097
  if (! __cil_tmp3___34) {
    {
#line 1098
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1100
    return ((unsigned char)0);
  }
#line 1102
  return (c1___3);
}
}
#line 1105 "/root/patron-new/39/src/bin/jp2/convert.c"
static unsigned short readushort(FILE *f___1 , int bigendian ) 
{ 
  unsigned char c1___4 ;
  unsigned char c2 ;
  unsigned long __cil_tmp5___46 ;
  unsigned long __cil_tmp6___57 ;

  {
  {
#line 1108
  __cil_tmp5___46 = fread((void *)(& c1___4), 1UL, 1UL, f___1);
  }
#line 1108
  if (! __cil_tmp5___46) {
    {
#line 1109
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1111
    return ((unsigned short)0);
  }
  {
#line 1113
  __cil_tmp6___57 = fread((void *)(& c2), 1UL, 1UL, f___1);
  }
#line 1113
  if (! __cil_tmp6___57) {
    {
#line 1114
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n\377\377\220");
    }
#line 1116
    return ((unsigned short)0);
  }
#line 1118
  if (bigendian) {
#line 1119
    return ((unsigned short )(((int )c1___4 << 8) + (int )c2));
  } else {
#line 1121
    return ((unsigned short )(((int )c2 << 8) + (int )c1___4));
  }
}
}
#line 1125 "/root/patron-new/39/src/bin/jp2/convert.c"
static unsigned int readuint(FILE *f___2 , int bigendian___0 ) 
{ 
  unsigned char c1___5 ;
  unsigned char c2___0 ;
  unsigned char c3 ;
  unsigned char c4 ;
  unsigned long __cil_tmp7___55 ;
  unsigned long __cil_tmp8___75 ;
  unsigned long __cil_tmp9___44 ;
  unsigned long __cil_tmp10___43 ;

  {
  {
#line 1128
  __cil_tmp7___55 = fread((void *)(& c1___5), 1UL, 1UL, f___2);
  }
#line 1128
  if (! __cil_tmp7___55) {
    {
#line 1129
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1131
    return (0U);
  }
  {
#line 1133
  __cil_tmp8___75 = fread((void *)(& c2___0), 1UL, 1UL, f___2);
  }
#line 1133
  if (! __cil_tmp8___75) {
    {
#line 1134
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1136
    return (0U);
  }
  {
#line 1138
  __cil_tmp9___44 = fread((void *)(& c3), 1UL, 1UL, f___2);
  }
#line 1138
  if (! __cil_tmp9___44) {
    {
#line 1139
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1141
    return (0U);
  }
  {
#line 1143
  __cil_tmp10___43 = fread((void *)(& c4), 1UL, 1UL, f___2);
  }
#line 1143
  if (! __cil_tmp10___43) {
    {
#line 1144
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1146
    return (0U);
  }
#line 1148
  if (bigendian___0) {
#line 1149
    return ((((unsigned int )((int )c1___5 << 24) + (unsigned int )((int )c2___0 << 16)) + (unsigned int )((int )c3 << 8)) + (unsigned int )c4);
  } else {
#line 1152
    return ((((unsigned int )((int )c4 << 24) + (unsigned int )((int )c3 << 16)) + (unsigned int )((int )c2___0 << 8)) + (unsigned int )c1___5);
  }
}
}
#line 1157 "/root/patron-new/39/src/bin/jp2/convert.c"
opj_image_t *pgxtoimage(char const   *filename___2 , opj_cparameters_t *parameters___15 ) 
{ 
  FILE *f___3 ;
  int w___1 ;
  int h___1 ;
  int prec___1 ;
  int i___145 ;
  int numcomps___7 ;
  int max___1 ;
  OPJ_COLOR_SPACE color_space___1 ;
  opj_image_cmptparm_t cmptparm___3 ;
  opj_image_t *image___26 ;
  int adjustS ;
  int ushift ;
  int dshift ;
  int force8 ;
  OPJ_UINT64 expected_file_size___0 ;
  char endian1 ;
  char endian2 ;
  char sign___0 ;
  char signtmp[32] ;
  char temp___0[32] ;
  int bigendian___1 ;
  opj_image_comp_t *comp___1 ;
  int __cil_tmp26___26 ;
  int tmp___489 ;
  int tmp___490 ;
  char ch___0 ;
  long curpos___0 ;
  long __cil_tmp32___22 ;
  unsigned long __cil_tmp33___14 ;
  OPJ_UINT32 tmp___491 ;
  OPJ_UINT32 tmp___492 ;
  int v___1 ;
  unsigned char __cil_tmp38___8 ;
  unsigned char __cil_tmp39___13 ;
  unsigned char __cil_tmp40___15 ;
  unsigned short __cil_tmp41___5 ;
  unsigned short __cil_tmp42___4 ;
  unsigned int __cil_tmp43___10 ;
  unsigned int __cil_tmp44___10 ;
  int __cil_tmp46___2 ;

  {
  {
#line 1159
  f___3 = (FILE *)((void *)0);
#line 1164
  image___26 = (opj_image_t *)((void *)0);
#line 1173
  comp___1 = (opj_image_comp_t *)((void *)0);
#line 1175
  numcomps___7 = 1;
#line 1176
  color_space___1 = (OPJ_COLOR_SPACE )2;
#line 1178
  memset((void *)(& cmptparm___3), 0, sizeof(opj_image_cmptparm_t ));
#line 1180
  max___1 = 0;
#line 1182
  f___3 = fopen(filename___2, "rb");
  }
#line 1183
  if (! f___3) {
    {
#line 1184
    fprintf(stderr, "Failed to open %s for reading !\n\230\001", filename___2);
    }
#line 1185
    return ((opj_image_t *)((void *)0));
  }
  {
#line 1188
  fseek(f___3, 0L, 0);
#line 1189
  __cil_tmp26___26 = fscanf(f___3, "PG%31[ \t]%c%c%31[ \t+-]%d%31[ \t]%d%31[ \t]%d",
                            temp___0, & endian1, & endian2, signtmp, & prec___1, temp___0,
                            & w___1, temp___0, & h___1);
  }
#line 1189
  if (__cil_tmp26___26 != 9) {
    {
#line 1191
    fclose(f___3);
#line 1192
    fprintf(stderr, "ERROR: Failed to read the right number of element from the fscanf() function!\n");
    }
#line 1194
    return ((opj_image_t *)((void *)0));
  }
#line 1197
  i___145 = 0;
#line 1198
  sign___0 = (char )'+';
  {
#line 1199
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1199
    if (! ((int )signtmp[i___145] != 0)) {
#line 1199
      goto while_break;
    }
#line 1200
    if ((int )signtmp[i___145] == 45) {
#line 1201
      sign___0 = (char )'-';
    }
#line 1203
    i___145 ++;
  }
  while_break___1: /* CIL Label */ ;
  }

  while_break: 
  {
#line 1206
  fgetc(f___3);
  }
#line 1207
  if ((int )endian1 == 77) {
#line 1207
    if ((int )endian2 == 76) {
#line 1208
      bigendian___1 = 1;
    } else {
#line 1207
      goto _L;
    }
  } else
  _L: 
#line 1209
  if ((int )endian2 == 77) {
#line 1209
    if ((int )endian1 == 76) {
#line 1210
      bigendian___1 = 0;
    } else {
      {
#line 1212
      fclose(f___3);
#line 1213
      fprintf(stderr, "Bad pgx header, please check input file\n\220");
      }
#line 1214
      return ((opj_image_t *)((void *)0));
    }
  } else {
    {
#line 1212
    fclose(f___3);
#line 1213
    fprintf(stderr, "Bad pgx header, please check input file\n\220");
    }
#line 1214
    return ((opj_image_t *)((void *)0));
  }
#line 1217
  if (w___1 < 1) {
    {
#line 1218
    fclose(f___3);
#line 1219
    fprintf(stderr, "Bad pgx header, please check input file\n\220");
    }
#line 1220
    return ((opj_image_t *)((void *)0));
  } else
#line 1217
  if (h___1 < 1) {
    {
#line 1218
    fclose(f___3);
#line 1219
    fprintf(stderr, "Bad pgx header, please check input file\n\220");
    }
#line 1220
    return ((opj_image_t *)((void *)0));
  } else
#line 1217
  if (prec___1 < 1) {
    {
#line 1218
    fclose(f___3);
#line 1219
    fprintf(stderr, "Bad pgx header, please check input file\n\220");
    }
#line 1220
    return ((opj_image_t *)((void *)0));
  } else
#line 1217
  if (prec___1 > 31) {
    {
#line 1218
    fclose(f___3);
#line 1219
    fprintf(stderr, "Bad pgx header, please check input file\n\220");
    }
#line 1220
    return ((opj_image_t *)((void *)0));
  }
#line 1223
  if (prec___1 > 16) {
#line 1223
    tmp___490 = 4;
  } else {
#line 1223
    if (prec___1 > 8) {
#line 1223
      tmp___489 = 2;
    } else {
#line 1223
      tmp___489 = 1;
    }
#line 1223
    tmp___490 = tmp___489;
  }
#line 1223
  expected_file_size___0 = ((OPJ_UINT64 )w___1 * (OPJ_UINT64 )h___1) * (unsigned long )tmp___490;
#line 1225
  if (expected_file_size___0 > 10000000UL) {
    {
#line 1227
    __cil_tmp32___22 = ftell(f___3);
#line 1227
    curpos___0 = __cil_tmp32___22;
    }
#line 1228
    if (expected_file_size___0 > 2147483647UL) {
#line 1229
      expected_file_size___0 = (OPJ_UINT64 )2147483647;
    }
    {
#line 1231
    fseek(f___3, (long )expected_file_size___0 - 1L, 0);
#line 1232
    __cil_tmp33___14 = fread((void *)(& ch___0), 1UL, 1UL, f___3);
    }
#line 1232
    if (__cil_tmp33___14 != 1UL) {
      {
#line 1233
      fprintf(stderr, "File too short\n");
#line 1234
      fclose(f___3);
      }
#line 1235
      return ((opj_image_t *)((void *)0));
    }
    {
#line 1237
    fseek(f___3, curpos___0, 0);
    }
  }
#line 1242
  cmptparm___3.x0 = (OPJ_UINT32 )parameters___15->image_offset_x0;
#line 1243
  cmptparm___3.y0 = (OPJ_UINT32 )parameters___15->image_offset_y0;
#line 1244
  if (! cmptparm___3.x0) {
#line 1244
    tmp___491 = (OPJ_UINT32 )((w___1 - 1) * parameters___15->subsampling_dx + 1);
  } else {
#line 1244
    tmp___491 = (cmptparm___3.x0 + (OPJ_UINT32 )(w___1 - 1) * (OPJ_UINT32 )parameters___15->subsampling_dx) + 1U;
  }
#line 1244
  cmptparm___3.w = tmp___491;
#line 1247
  if (! cmptparm___3.y0) {
#line 1247
    tmp___492 = (OPJ_UINT32 )((h___1 - 1) * parameters___15->subsampling_dy + 1);
  } else {
#line 1247
    tmp___492 = (cmptparm___3.y0 + (OPJ_UINT32 )(h___1 - 1) * (OPJ_UINT32 )parameters___15->subsampling_dy) + 1U;
  }
#line 1247
  cmptparm___3.h = tmp___492;
#line 1251
  if ((int )sign___0 == 45) {
#line 1252
    cmptparm___3.sgnd = (OPJ_UINT32 )1;
  } else {
#line 1254
    cmptparm___3.sgnd = (OPJ_UINT32 )0;
  }
#line 1256
  if (prec___1 < 8) {
#line 1257
    force8 = 1;
#line 1258
    ushift = 8 - prec___1;
#line 1259
    dshift = prec___1 - ushift;
#line 1260
    if (cmptparm___3.sgnd) {
#line 1261
      adjustS = 1 << (prec___1 - 1);
    } else {
#line 1263
      adjustS = 0;
    }
#line 1265
    cmptparm___3.sgnd = (OPJ_UINT32 )0;
#line 1266
    prec___1 = 8;
  } else {
#line 1268
    adjustS = 0;
#line 1268
    force8 = adjustS;
#line 1268
    dshift = force8;
#line 1268
    ushift = dshift;
  }
  {
#line 1271
  cmptparm___3.prec = (OPJ_UINT32 )prec___1;
#line 1272
  cmptparm___3.bpp = (OPJ_UINT32 )prec___1;
#line 1273
  cmptparm___3.dx = (OPJ_UINT32 )parameters___15->subsampling_dx;
#line 1274
  cmptparm___3.dy = (OPJ_UINT32 )parameters___15->subsampling_dy;
#line 1277
  image___26 = opj_image_create((OPJ_UINT32 )numcomps___7, & cmptparm___3, color_space___1);
  }
#line 1278
  if (! image___26) {
    {
#line 1279
    fclose(f___3);
    }
#line 1280
    return ((opj_image_t *)((void *)0));
  }
#line 1283
  image___26->x0 = cmptparm___3.x0;
#line 1284
  image___26->y0 = cmptparm___3.x0;
#line 1285
  image___26->x1 = cmptparm___3.w;
#line 1286
  image___26->y1 = cmptparm___3.h;
#line 1290
  comp___1 = image___26->comps + 0;
#line 1292
  i___145 = 0;
  {
#line 1292
  while (1) {
    while_continue___1: /* CIL Label */ ;

    while_continue___0: ;
#line 1292
    if (! (i___145 < w___1 * h___1)) {
#line 1292
      goto while_break___0;
    }
#line 1294
    if (force8) {
      {
#line 1295
      __cil_tmp38___8 = readuchar(f___3);
#line 1295
      v___1 = (int )__cil_tmp38___8 + adjustS;
#line 1296
      v___1 = (v___1 << ushift) + (v___1 >> dshift);
#line 1297
      *(comp___1->data + i___145) = (OPJ_INT32 )((unsigned char )v___1);
      }
#line 1299
      if (v___1 > max___1) {
#line 1300
        max___1 = v___1;
      }
#line 1303
      goto while_continue___0;
    }
#line 1305
    if (comp___1->prec == 8U) {
#line 1306
      if (! comp___1->sgnd) {
        {
#line 1307
        __cil_tmp39___13 = readuchar(f___3);
#line 1307
        v___1 = (int )__cil_tmp39___13;
        }
      } else {
        {
#line 1309
        __cil_tmp40___15 = readuchar(f___3);
#line 1309
        v___1 = (int )((char )__cil_tmp40___15);
        }
      }
    } else
#line 1311
    if (comp___1->prec <= 16U) {
#line 1312
      if (! comp___1->sgnd) {
        {
#line 1313
        __cil_tmp41___5 = readushort(f___3, bigendian___1);
#line 1313
        v___1 = (int )__cil_tmp41___5;
        }
      } else {
        {
#line 1315
        __cil_tmp42___4 = readushort(f___3, bigendian___1);
#line 1315
        v___1 = (int )((short )__cil_tmp42___4);
        }
      }
    } else
#line 1318
    if (! comp___1->sgnd) {
      {
#line 1319
      __cil_tmp43___10 = readuint(f___3, bigendian___1);
#line 1319
      v___1 = (int )__cil_tmp43___10;
      }
    } else {
      {
#line 1321
      __cil_tmp44___10 = readuint(f___3, bigendian___1);
#line 1321
      v___1 = (int )__cil_tmp44___10;
      }
    }
#line 1324
    if (v___1 > max___1) {
#line 1325
      max___1 = v___1;
    }
#line 1327
    *(comp___1->data + i___145) = v___1;
#line 1292
    i___145 ++;
  }
  while_break___2: /* CIL Label */ ;
  }

  while_break___0: 
  {
#line 1329
  fclose(f___3);
#line 1330
  __cil_tmp46___2 = int_floorlog2(max___1);
#line 1330
  comp___1->bpp = (OPJ_UINT32 )__cil_tmp46___2 + 1U;
  }
#line 1332
  return (image___26);
}
}
#line 1337 "/root/patron-new/39/src/bin/jp2/convert.c"
__inline static int clamp(int value___2 , int prec___2 , int sgnd___0 ) 
{ 
  int tmp___493 ;
  int tmp___494 ;
  int tmp___495 ;
  int tmp___496 ;
  int tmp___497 ;
  int tmp___498 ;
  int tmp___499 ;
  int tmp___500 ;
  int tmp___501 ;
  int tmp___502 ;

  {
#line 1339
  if (sgnd___0) {
#line 1340
    if (prec___2 <= 8) {
#line 1341
      if (value___2 < -128) {
#line 1341
        tmp___494 = -128;
      } else {
#line 1341
        if (value___2 > 127) {
#line 1341
          tmp___493 = 127;
        } else {
#line 1341
          tmp___493 = value___2;
        }
#line 1341
        tmp___494 = tmp___493;
      }
#line 1341
      return (tmp___494);
    } else
#line 1342
    if (prec___2 <= 16) {
#line 1343
      if (value___2 < -32768) {
#line 1343
        tmp___496 = -32768;
      } else {
#line 1343
        if (value___2 > 32767) {
#line 1343
          tmp___495 = 32767;
        } else {
#line 1343
          tmp___495 = value___2;
        }
#line 1343
        tmp___496 = tmp___495;
      }
#line 1343
      return (tmp___496);
    } else {
#line 1345
      if (value___2 < (-0x7FFFFFFF-1)) {
#line 1345
        tmp___498 = (-0x7FFFFFFF-1);
      } else {
#line 1345
        if (value___2 > 2147483647) {
#line 1345
          tmp___497 = 2147483647;
        } else {
#line 1345
          tmp___497 = value___2;
        }
#line 1345
        tmp___498 = tmp___497;
      }
#line 1345
      return (tmp___498);
    }
  } else
#line 1348
  if (prec___2 <= 8) {
#line 1349
    if (value___2 < 0) {
#line 1349
      tmp___500 = 0;
    } else {
#line 1349
      if (value___2 > 255) {
#line 1349
        tmp___499 = 255;
      } else {
#line 1349
        tmp___499 = value___2;
      }
#line 1349
      tmp___500 = tmp___499;
    }
#line 1349
    return (tmp___500);
  } else
#line 1350
  if (prec___2 <= 16) {
#line 1351
    if (value___2 < 0) {
#line 1351
      tmp___502 = 0;
    } else {
#line 1351
      if (value___2 > 65535) {
#line 1351
        tmp___501 = 65535;
      } else {
#line 1351
        tmp___501 = value___2;
      }
#line 1351
      tmp___502 = tmp___501;
    }
#line 1351
    return (tmp___502);
  } else {
#line 1353
    return (value___2);
  }
}
}
#line 1358 "/root/patron-new/39/src/bin/jp2/convert.c"
int imagetopgx(opj_image_t *image___27 , char const   *outfile___2 ) 
{ 
  int w___2 ;
  int h___2 ;
  int i___146 ;
  int j___20 ;
  int fails___1 ;
  unsigned int compno___14 ;
  FILE *fdest___1 ;
  opj_image_comp_t *comp___2 ;
  char bname[256] ;
  char *name ;
  int nbytes ;
  size_t res___1 ;
  size_t olen ;
  unsigned long __cil_tmp16___47 ;
  size_t dotpos ;
  size_t total ;
  void *__cil_tmp19___39 ;
  int tmp___503 ;
  unsigned char *line_buffer ;
  void *__cil_tmp23___33 ;
  int tmp___504 ;
  int tmp___505 ;
  int __cil_tmp27___21 ;
  int val___13 ;
  int __cil_tmp32___23 ;
  int v___2 ;
  unsigned char byte ;
  int __cil_tmp36___19 ;

  {
#line 1361
  fails___1 = 1;
#line 1363
  fdest___1 = (FILE *)((void *)0);
#line 1365
  compno___14 = 0U;
  {
#line 1365
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1365
    if (! (compno___14 < image___27->numcomps)) {
#line 1365
      goto while_break;
    }
    {
#line 1366
    comp___2 = image___27->comps + compno___14;
#line 1368
    name = bname;
#line 1369
    nbytes = 0;
#line 1371
    __cil_tmp16___47 = strlen(outfile___2);
#line 1371
    olen = __cil_tmp16___47;
#line 1372
    dotpos = olen - 4UL;
#line 1373
    total = ((dotpos + 1UL) + 1UL) + 4UL;
    }
#line 1375
    if ((int )*(outfile___2 + dotpos) != 46) {
      {
#line 1377
      fprintf(stderr, "ERROR -> Impossible happen.\006]U");
      }
#line 1378
      goto fin;
    }
#line 1380
    if (total > 256UL) {
      {
#line 1381
      __cil_tmp19___39 = malloc(total + 1UL);
#line 1381
      name = (char *)__cil_tmp19___39;
      }
#line 1382
      if ((unsigned long )name == (unsigned long )((void *)0)) {
        {
#line 1383
        fprintf(stderr, "imagetopgx: memory out\n");
        }
#line 1384
        goto fin;
      }
    }
    {
#line 1387
    strncpy(name, outfile___2, dotpos);
#line 1388
    sprintf(name + dotpos, "_%u.pgx", compno___14);
#line 1389
    fdest___1 = fopen((char const   *)name, "wb\254\006]U");
    }
#line 1392
    if (! fdest___1) {
      {
#line 1394
      fprintf(stderr, "ERROR -> failed to open %s for writing\n", name);
      }
#line 1395
      if (total > 256UL) {
        {
#line 1396
        free((void *)name);
        }
      }
#line 1398
      goto fin;
    }
#line 1401
    w___2 = (int )(image___27->comps + compno___14)->w;
#line 1402
    h___2 = (int )(image___27->comps + compno___14)->h;
#line 1404
    if (comp___2->sgnd) {
#line 1404
      tmp___503 = '-';
    } else {
#line 1404
      tmp___503 = '+';
    }
    {
#line 1404
    fprintf(fdest___1, "PG ML %c %d %d %d\n\254\006]U", tmp___503, comp___2->prec,
            w___2, h___2);
    }
#line 1407
    if (comp___2->prec <= 8U) {
#line 1408
      nbytes = 1;
    } else
#line 1409
    if (comp___2->prec <= 16U) {
#line 1410
      nbytes = 2;
    } else {
#line 1412
      nbytes = 4;
    }
#line 1415
    if (nbytes == 1) {
      {
#line 1416
      __cil_tmp23___33 = malloc((size_t )w___2);
#line 1416
      line_buffer = (unsigned char *)__cil_tmp23___33;
      }
#line 1417
      if ((unsigned long )line_buffer == (unsigned long )((void *)0)) {
        {
#line 1418
        fprintf(stderr, "Out of memoryU");
        }
#line 1419
        if (total > 256UL) {
          {
#line 1420
          free((void *)name);
          }
        }
#line 1422
        goto fin;
      }
#line 1424
      j___20 = 0;
      {
#line 1424
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 1424
        if (! (j___20 < h___2)) {
#line 1424
          goto while_break___0;
        }
#line 1425
        if (comp___2->prec == 8U) {
#line 1425
          if (comp___2->sgnd == 0U) {
#line 1426
            i___146 = 0;
            {
#line 1426
            while (1) {
              while_continue___1: /* CIL Label */ ;

#line 1426
              if (! (i___146 < w___2)) {
#line 1426
                goto while_break___1;
              }
#line 1427
              if (*((image___27->comps + compno___14)->data + (j___20 * w___2 + i___146)) < 0) {
#line 1427
                tmp___505 = 0;
              } else {
#line 1427
                if (*((image___27->comps + compno___14)->data + (j___20 * w___2 + i___146)) > 255) {
#line 1427
                  tmp___504 = 255;
                } else {
#line 1427
                  tmp___504 = *((image___27->comps + compno___14)->data + (j___20 * w___2 + i___146));
                }
#line 1427
                tmp___505 = tmp___504;
              }
#line 1427
              *(line_buffer + i___146) = (unsigned char )tmp___505;
#line 1426
              i___146 ++;
            }
            while_break___7: /* CIL Label */ ;
            }

            while_break___1: ;
          } else {
#line 1425
            goto _L;
          }
        } else {
          _L: 
#line 1431
          i___146 = 0;
          {
#line 1431
          while (1) {
            while_continue___2: /* CIL Label */ ;

#line 1431
            if (! (i___146 < w___2)) {
#line 1431
              goto while_break___2;
            }
            {
#line 1432
            __cil_tmp27___21 = clamp(*((image___27->comps + compno___14)->data + (j___20 * w___2 + i___146)),
                                     (int )comp___2->prec, (int )comp___2->sgnd);
#line 1432
            *(line_buffer + i___146) = (unsigned char )__cil_tmp27___21;
#line 1431
            i___146 ++;
            }
          }
          while_break___8: /* CIL Label */ ;
          }

          while_break___2: ;
        }
        {
#line 1437
        res___1 = fwrite((void const   *)line_buffer, 1UL, (size_t )w___2, fdest___1);
        }
#line 1438
        if (res___1 != (size_t )w___2) {
          {
#line 1439
          fprintf(stderr, "failed to write %d bytes for %s\n\230\001", w___2, name);
          }
#line 1440
          if (total > 256UL) {
            {
#line 1441
            free((void *)name);
            }
          }
          {
#line 1443
          free((void *)line_buffer);
          }
#line 1444
          goto fin;
        }
#line 1424
        j___20 ++;
      }
      while_break___6: /* CIL Label */ ;
      }

      while_break___0: 
      {
#line 1447
      free((void *)line_buffer);
      }
    } else {
#line 1450
      i___146 = 0;
      {
#line 1450
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 1450
        if (! (i___146 < w___2 * h___2)) {
#line 1450
          goto while_break___3;
        }
        {
#line 1452
        __cil_tmp32___23 = clamp(*((image___27->comps + compno___14)->data + i___146),
                                 (int )comp___2->prec, (int )comp___2->sgnd);
#line 1452
        val___13 = __cil_tmp32___23;
#line 1455
        j___20 = nbytes - 1;
        }
        {
#line 1455
        while (1) {
          while_continue___4: /* CIL Label */ ;

#line 1455
          if (! (j___20 >= 0)) {
#line 1455
            goto while_break___4;
          }
          {
#line 1456
          v___2 = val___13 >> j___20 * 8;
#line 1457
          byte = (unsigned char )v___2;
#line 1458
          res___1 = fwrite((void const   *)(& byte), 1UL, 1UL, fdest___1);
          }
#line 1460
          if (res___1 < 1UL) {
            {
#line 1461
            fprintf(stderr, "failed to write 1 byte for %s\n", name);
            }
#line 1462
            if (total > 256UL) {
              {
#line 1463
              free((void *)name);
              }
            }
#line 1465
            goto fin;
          }
#line 1455
          __cil_tmp36___19 = j___20;
#line 1455
          j___20 --;
        }
        while_break___10: /* CIL Label */ ;
        }

        while_break___4: 
#line 1450
        i___146 ++;
      }
      while_break___9: /* CIL Label */ ;
      }

      while_break___3: ;
    }
#line 1471
    if (total > 256UL) {
      {
#line 1472
      free((void *)name);
      }
    }
    {
#line 1474
    fclose(fdest___1);
#line 1475
    fdest___1 = (FILE *)((void *)0);
#line 1365
    compno___14 ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }

  while_break: 
#line 1477
  fails___1 = 0;
  fin: 
#line 1479
  if (fdest___1) {
    {
#line 1480
    fclose(fdest___1);
    }
  }
#line 1483
  return (fails___1);
}
}
#line 1498 "/root/patron-new/39/src/bin/jp2/convert.c"
static char *skip_white(char *s ) 
{ 
  unsigned short const   **__cil_tmp2___19 ;

  {
#line 1500
  if ((unsigned long )s != (unsigned long )((void *)0)) {
    {
#line 1501
    while (1) {
      while_continue___0: /* CIL Label */ ;

      while_continue: ;
#line 1501
      if (! *s) {
#line 1501
        goto while_break;
      }
#line 1502
      if ((int )*s == 10) {
#line 1503
        return ((char *)((void *)0));
      } else
#line 1502
      if ((int )*s == 13) {
#line 1503
        return ((char *)((void *)0));
      }
      {
#line 1505
      __cil_tmp2___19 = __ctype_b_loc();
      }
#line 1505
      if ((int )*(*__cil_tmp2___19 + (int )*s) & 8192) {
#line 1506
        s ++;
#line 1507
        goto while_continue;
      }
#line 1509
      return (s);
    }
    while_break___0: /* CIL Label */ ;
    }

    while_break: ;
  }
#line 1512
  return ((char *)((void *)0));
}
}
#line 1515 "/root/patron-new/39/src/bin/jp2/convert.c"
static char *skip_int(char *start , int *out_n ) 
{ 
  char *s___0 ;
  char c___1 ;
  unsigned short const   **__cil_tmp6___58 ;

  {
  {
#line 1520
  *out_n = 0;
#line 1522
  s___0 = skip_white(start);
  }
#line 1523
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 1524
    return ((char *)((void *)0));
  }
#line 1526
  start = s___0;
  {
#line 1528
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1528
    if (! *s___0) {
#line 1528
      goto while_break;
    }
    {
#line 1529
    __cil_tmp6___58 = __ctype_b_loc();
    }
#line 1529
    if (! ((int )*(*__cil_tmp6___58 + (int )*s___0) & 2048)) {
#line 1530
      goto while_break;
    }
#line 1532
    s___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: 
  {
#line 1534
  c___1 = *s___0;
#line 1535
  *s___0 = (char)0;
#line 1536
  *out_n = atoi((char const   *)start);
#line 1537
  *s___0 = c___1;
  }
#line 1538
  return (s___0);
}
}
#line 1541 "/root/patron-new/39/src/bin/jp2/convert.c"
static char *skip_idf(char *start___0 , char *out_idf ) 
{ 
  char *s___1 ;
  char c___2 ;
  unsigned short const   **__cil_tmp6___59 ;

  {
  {
#line 1546
  s___1 = skip_white(start___0);
  }
#line 1547
  if ((unsigned long )s___1 == (unsigned long )((void *)0)) {
#line 1548
    return ((char *)((void *)0));
  }
#line 1550
  start___0 = s___1;
  {
#line 1552
  while (1) {
    while_continue___0: /* CIL Label */ ;

    while_continue: ;
#line 1552
    if (! *s___1) {
#line 1552
      goto while_break;
    }
    {
#line 1553
    __cil_tmp6___59 = __ctype_b_loc();
    }
#line 1553
    if ((int )*(*__cil_tmp6___59 + (int )*s___1) & 1024) {
#line 1554
      s___1 ++;
#line 1555
      goto while_continue;
    } else
#line 1553
    if ((int )*s___1 == 95) {
#line 1554
      s___1 ++;
#line 1555
      goto while_continue;
    }
#line 1557
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: 
  {
#line 1559
  c___2 = *s___1;
#line 1560
  *s___1 = (char)0;
#line 1561
  strncpy(out_idf, (char const   *)start___0, 255UL);
#line 1562
  *s___1 = c___2;
  }
#line 1563
  return (s___1);
}
}
#line 1566 "/root/patron-new/39/src/bin/jp2/convert.c"
static void read_pnm_header(FILE *reader___0 , struct pnm_header *ph ) 
{ 
  int format ;
  int end ;
  int ttype ;
  char idf[256] ;
  char type___1[256] ;
  char line[256] ;
  char *__cil_tmp9___45 ;
  char *__cil_tmp11___30 ;
  char *s___2 ;
  int allow_null ;
  int __cil_tmp15___43 ;
  int __cil_tmp16___48 ;
  int __cil_tmp18___37 ;
  int __cil_tmp20___45 ;
  int __cil_tmp22___38 ;
  int __cil_tmp24___36 ;
  int __cil_tmp26___28 ;
  int __cil_tmp27___22 ;
  int __cil_tmp28___24 ;
  int __cil_tmp29___18 ;
  int __cil_tmp30___18 ;

  {
  {
#line 1572
  __cil_tmp9___45 = fgets(line, 250, reader___0);
  }
#line 1572
  if ((unsigned long )__cil_tmp9___45 == (unsigned long )((void *)0)) {
    {
#line 1573
    fprintf(stderr, "\nWARNING: fgets return a NULL value");
    }
#line 1574
    return;
  }
#line 1577
  if ((int )line[0] != 80) {
    {
#line 1578
    fprintf(stderr, "read_pnm_header:PNM:magic P missing\n");
    }
#line 1579
    return;
  }
  {
#line 1581
  format = atoi((char const   *)(line + 1));
  }
#line 1582
  if (format < 1) {
    {
#line 1583
    fprintf(stderr, "read_pnm_header:magic format %d invalid\n\230\001", format);
    }
#line 1584
    return;
  } else
#line 1582
  if (format > 7) {
    {
#line 1583
    fprintf(stderr, "read_pnm_header:magic format %d invalid\n\230\001", format);
    }
#line 1584
    return;
  }
#line 1586
  ph->format = format;
#line 1587
  end = 0;
#line 1587
  ttype = end;
  {
#line 1589
  while (1) {
    while_continue___0: /* CIL Label */ ;

    while_continue: 
    {
#line 1589
    __cil_tmp11___30 = fgets(line, 250, reader___0);
    }
#line 1589
    if (! __cil_tmp11___30) {
#line 1589
      goto while_break;
    }
#line 1591
    allow_null = 0;
#line 1593
    if ((int )line[0] == 35) {
#line 1594
      goto while_continue;
    }
#line 1597
    s___2 = line;
#line 1599
    if (format == 7) {
      {
#line 1600
      s___2 = skip_idf(s___2, idf);
      }
#line 1602
      if ((unsigned long )s___2 == (unsigned long )((void *)0)) {
#line 1603
        return;
      } else
#line 1602
      if ((int )*s___2 == 0) {
#line 1603
        return;
      }
      {
#line 1606
      __cil_tmp15___43 = strcmp((char const   *)(idf), "ENDHDR");
      }
#line 1606
      if (__cil_tmp15___43 == 0) {
#line 1607
        end = 1;
#line 1608
        goto while_break;
      }
      {
#line 1610
      __cil_tmp16___48 = strcmp((char const   *)(idf), "WIDTH");
      }
#line 1610
      if (__cil_tmp16___48 == 0) {
        {
#line 1611
        s___2 = skip_int(s___2, & ph->width);
        }
#line 1612
        if ((unsigned long )s___2 == (unsigned long )((void *)0)) {
#line 1613
          return;
        } else
#line 1612
        if ((int )*s___2 == 0) {
#line 1613
          return;
        }
#line 1616
        goto while_continue;
      }
      {
#line 1618
      __cil_tmp18___37 = strcmp((char const   *)(idf), "HEIGHT");
      }
#line 1618
      if (__cil_tmp18___37 == 0) {
        {
#line 1619
        s___2 = skip_int(s___2, & ph->height);
        }
#line 1620
        if ((unsigned long )s___2 == (unsigned long )((void *)0)) {
#line 1621
          return;
        } else
#line 1620
        if ((int )*s___2 == 0) {
#line 1621
          return;
        }
#line 1624
        goto while_continue;
      }
      {
#line 1626
      __cil_tmp20___45 = strcmp((char const   *)(idf), "DEPTH");
      }
#line 1626
      if (__cil_tmp20___45 == 0) {
        {
#line 1627
        s___2 = skip_int(s___2, & ph->depth);
        }
#line 1628
        if ((unsigned long )s___2 == (unsigned long )((void *)0)) {
#line 1629
          return;
        } else
#line 1628
        if ((int )*s___2 == 0) {
#line 1629
          return;
        }
#line 1632
        goto while_continue;
      }
      {
#line 1634
      __cil_tmp22___38 = strcmp((char const   *)(idf), "MAXVAL");
      }
#line 1634
      if (__cil_tmp22___38 == 0) {
        {
#line 1635
        s___2 = skip_int(s___2, & ph->maxval);
        }
#line 1636
        if ((unsigned long )s___2 == (unsigned long )((void *)0)) {
#line 1637
          return;
        } else
#line 1636
        if ((int )*s___2 == 0) {
#line 1637
          return;
        }
#line 1640
        goto while_continue;
      }
      {
#line 1642
      __cil_tmp24___36 = strcmp((char const   *)(idf), "TUPLTYPE\220");
      }
#line 1642
      if (__cil_tmp24___36 == 0) {
        {
#line 1643
        s___2 = skip_idf(s___2, type___1);
        }
#line 1644
        if ((unsigned long )s___2 == (unsigned long )((void *)0)) {
#line 1645
          return;
        } else
#line 1644
        if ((int )*s___2 == 0) {
#line 1645
          return;
        }
        {
#line 1648
        __cil_tmp26___28 = strcmp((char const   *)(type___1), "BLACKANDWHITEU");
        }
#line 1648
        if (__cil_tmp26___28 == 0) {
#line 1649
          ph->bw = (char)1;
#line 1650
          ttype = 1;
#line 1651
          goto while_continue;
        }
        {
#line 1653
        __cil_tmp27___22 = strcmp((char const   *)(type___1), "GRAYSCALE");
        }
#line 1653
        if (__cil_tmp27___22 == 0) {
#line 1654
          ph->gray = (char)1;
#line 1655
          ttype = 1;
#line 1656
          goto while_continue;
        }
        {
#line 1658
        __cil_tmp28___24 = strcmp((char const   *)(type___1), "GRAYSCALE_ALPHA");
        }
#line 1658
        if (__cil_tmp28___24 == 0) {
#line 1659
          ph->graya = (char)1;
#line 1660
          ttype = 1;
#line 1661
          goto while_continue;
        }
        {
#line 1663
        __cil_tmp29___18 = strcmp((char const   *)(type___1), "RGB\006]U");
        }
#line 1663
        if (__cil_tmp29___18 == 0) {
#line 1664
          ph->rgb = (char)1;
#line 1665
          ttype = 1;
#line 1666
          goto while_continue;
        }
        {
#line 1668
        __cil_tmp30___18 = strcmp((char const   *)(type___1), "RGB_ALPHA");
        }
#line 1668
        if (__cil_tmp30___18 == 0) {
#line 1669
          ph->rgba = (char)1;
#line 1670
          ttype = 1;
#line 1671
          goto while_continue;
        }
        {
#line 1673
        fprintf(stderr, "read_pnm_header:unknown P7 TUPLTYPE %s\n", type___1);
        }
#line 1674
        return;
      }
      {
#line 1676
      fprintf(stderr, "read_pnm_header:unknown P7 idf %s\n\254\006]U", idf);
      }
#line 1677
      return;
    }
#line 1681
    if (ph->width == 0) {
      {
#line 1682
      s___2 = skip_int(s___2, & ph->width);
      }
#line 1683
      if ((unsigned long )s___2 == (unsigned long )((void *)0)) {
#line 1684
        return;
      } else
#line 1683
      if ((int )*s___2 == 0) {
#line 1684
        return;
      } else
#line 1683
      if (ph->width < 1) {
#line 1684
        return;
      }
#line 1686
      allow_null = 1;
    }
#line 1688
    if (ph->height == 0) {
      {
#line 1689
      s___2 = skip_int(s___2, & ph->height);
      }
#line 1690
      if ((unsigned long )s___2 == (unsigned long )((void *)0)) {
#line 1690
        if (allow_null) {
#line 1691
          goto while_continue;
        }
      }
#line 1693
      if ((unsigned long )s___2 == (unsigned long )((void *)0)) {
#line 1694
        return;
      } else
#line 1693
      if ((int )*s___2 == 0) {
#line 1694
        return;
      } else
#line 1693
      if (ph->height < 1) {
#line 1694
        return;
      }
#line 1696
      if (format == 1) {
#line 1697
        goto while_break;
      } else
#line 1696
      if (format == 4) {
#line 1697
        goto while_break;
      }
#line 1699
      allow_null = 1;
    }
    {
#line 1702
    s___2 = skip_int(s___2, & ph->maxval);
    }
#line 1703
    if ((unsigned long )s___2 == (unsigned long )((void *)0)) {
#line 1703
      if (allow_null) {
#line 1704
        goto while_continue;
      }
    }
#line 1706
    if ((unsigned long )s___2 == (unsigned long )((void *)0)) {
#line 1707
      return;
    } else
#line 1706
    if ((int )*s___2 == 0) {
#line 1707
      return;
    }
#line 1709
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 1711
  if (format == 2) {
    _L: 
#line 1712
    if (ph->maxval < 1) {
#line 1713
      return;
    } else
#line 1712
    if (ph->maxval > 65535) {
#line 1713
      return;
    }
  } else
#line 1711
  if (format == 3) {
#line 1711
    goto _L;
  } else
#line 1711
  if (format > 4) {
#line 1711
    goto _L;
  }
#line 1716
  if (ph->width < 1) {
#line 1717
    return;
  } else
#line 1716
  if (ph->height < 1) {
#line 1717
    return;
  }
#line 1720
  if (format == 7) {
#line 1721
    if (! end) {
      {
#line 1722
      fprintf(stderr, "read_pnm_header:P7 without ENDHDR\n");
      }
#line 1723
      return;
    }
#line 1725
    if (ph->depth < 1) {
#line 1726
      return;
    } else
#line 1725
    if (ph->depth > 4) {
#line 1726
      return;
    }
#line 1729
    if (ttype) {
#line 1730
      ph->ok = (char)1;
    }
  } else {
#line 1733
    ph->ok = (char)1;
#line 1734
    if (format == 1) {
#line 1735
      ph->maxval = 255;
    } else
#line 1734
    if (format == 4) {
#line 1735
      ph->maxval = 255;
    }
  }
#line 1738
  return;
}
}
#line 1740 "/root/patron-new/39/src/bin/jp2/convert.c"
static int has_prec(int val___14 ) 
{ 


  {
#line 1742
  if (val___14 < 2) {
#line 1743
    return (1);
  }
#line 1745
  if (val___14 < 4) {
#line 1746
    return (2);
  }
#line 1748
  if (val___14 < 8) {
#line 1749
    return (3);
  }
#line 1751
  if (val___14 < 16) {
#line 1752
    return (4);
  }
#line 1754
  if (val___14 < 32) {
#line 1755
    return (5);
  }
#line 1757
  if (val___14 < 64) {
#line 1758
    return (6);
  }
#line 1760
  if (val___14 < 128) {
#line 1761
    return (7);
  }
#line 1763
  if (val___14 < 256) {
#line 1764
    return (8);
  }
#line 1766
  if (val___14 < 512) {
#line 1767
    return (9);
  }
#line 1769
  if (val___14 < 1024) {
#line 1770
    return (10);
  }
#line 1772
  if (val___14 < 2048) {
#line 1773
    return (11);
  }
#line 1775
  if (val___14 < 4096) {
#line 1776
    return (12);
  }
#line 1778
  if (val___14 < 8192) {
#line 1779
    return (13);
  }
#line 1781
  if (val___14 < 16384) {
#line 1782
    return (14);
  }
#line 1784
  if (val___14 < 32768) {
#line 1785
    return (15);
  }
#line 1787
  return (16);
}
}
#line 1790 "/root/patron-new/39/src/bin/jp2/convert.c"
opj_image_t *pnmtoimage(char const   *filename___3 , opj_cparameters_t *parameters___16 ) 
{ 
  int subsampling_dx___1 ;
  int subsampling_dy___1 ;
  FILE *fp___1 ;
  int i___147 ;
  int compno___15 ;
  int numcomps___8 ;
  int w___3 ;
  int h___3 ;
  int prec___3 ;
  int format___0 ;
  OPJ_COLOR_SPACE color_space___2 ;
  opj_image_cmptparm_t cmptparm___4[4] ;
  opj_image_t *image___28 ;
  struct pnm_header header_info ;
  unsigned int index___6 ;
  int __cil_tmp22___39 ;
  unsigned char c0 ;
  unsigned char c1___6 ;
  unsigned char one ;
  unsigned long __cil_tmp28___25 ;
  unsigned long __cil_tmp29___19 ;
  unsigned int index___7 ;
  int __cil_tmp33___16 ;
  int tmp___506 ;
  int x___8 ;
  int y___9 ;
  int bit ;
  int uc ;
  int tmp___507 ;
  unsigned char uc___0 ;
  unsigned long __cil_tmp43___11 ;
  int tmp___508 ;

  {
  {
#line 1792
  subsampling_dx___1 = parameters___16->subsampling_dx;
#line 1793
  subsampling_dy___1 = parameters___16->subsampling_dy;
#line 1795
  fp___1 = (FILE *)((void *)0);
#line 1799
  image___28 = (opj_image_t *)((void *)0);
#line 1802
  fp___1 = fopen(filename___3, "rb");
  }
#line 1802
  if ((unsigned long )fp___1 == (unsigned long )((void *)0)) {
    {
#line 1803
    fprintf(stderr, "pnmtoimage:Failed to open %s for reading!\n", filename___3);
    }
#line 1804
    return ((opj_image_t *)((void *)0));
  }
  {
#line 1806
  memset((void *)(& header_info), 0, sizeof(struct pnm_header ));
#line 1808
  read_pnm_header(fp___1, & header_info);
  }
#line 1810
  if (! header_info.ok) {
    {
#line 1811
    fclose(fp___1);
    }
#line 1812
    return ((opj_image_t *)((void *)0));
  }
#line 1815
  if (header_info.width == 0) {
    {
#line 1818
    fclose(fp___1);
    }
#line 1819
    return ((opj_image_t *)((void *)0));
  } else
#line 1815
  if (header_info.height == 0) {
    {
#line 1818
    fclose(fp___1);
    }
#line 1819
    return ((opj_image_t *)((void *)0));
  } else
#line 1815
  if (header_info.format == 7) {
#line 1815
    if (header_info.depth == 0) {
      {
#line 1818
      fclose(fp___1);
      }
#line 1819
      return ((opj_image_t *)((void *)0));
    }
  }
#line 1823
  if (header_info.height != 0) {
#line 1823
    if (header_info.width > 2147483647 / header_info.height) {
      {
#line 1825
      fprintf(stderr, "pnmtoimage:Image %dx%d too big!\n\230\001", header_info.width,
              header_info.height);
#line 1827
      fclose(fp___1);
      }
#line 1828
      return ((opj_image_t *)((void *)0));
    }
  }
#line 1831
  format___0 = header_info.format;
#line 1835
  if (format___0 == 4) {
#line 1835
    goto case_4;
  }
#line 1835
  if (format___0 == 1) {
#line 1835
    goto case_4;
  }
#line 1840
  if (format___0 == 5) {
#line 1840
    goto case_5;
  }
#line 1840
  if (format___0 == 2) {
#line 1840
    goto case_5;
  }
#line 1845
  if (format___0 == 6) {
#line 1845
    goto case_6;
  }
#line 1845
  if (format___0 == 3) {
#line 1845
    goto case_6;
  }
#line 1849
  if (format___0 == 7) {
#line 1849
    goto case_7;
  }
#line 1853
  goto switch_default;
  case_4: 
#line 1836
  numcomps___8 = 1;
#line 1837
  goto switch_break;
  case_5: 
#line 1841
  numcomps___8 = 1;
#line 1842
  goto switch_break;
  case_6: 
#line 1846
  numcomps___8 = 3;
#line 1847
  goto switch_break;
  case_7: 
#line 1850
  numcomps___8 = header_info.depth;
#line 1851
  goto switch_break;
  switch_default: 
  {
#line 1854
  fclose(fp___1);
  }
#line 1855
  return ((opj_image_t *)((void *)0));
  switch_break: ;
#line 1857
  if (numcomps___8 < 3) {
#line 1858
    color_space___2 = (OPJ_COLOR_SPACE )2;
  } else {
#line 1860
    color_space___2 = (OPJ_COLOR_SPACE )1;
  }
  {
#line 1863
  prec___3 = has_prec(header_info.maxval);
  }
#line 1865
  if (prec___3 < 8) {
#line 1866
    prec___3 = 8;
  }
  {
#line 1869
  w___3 = header_info.width;
#line 1870
  h___3 = header_info.height;
#line 1871
  subsampling_dx___1 = parameters___16->subsampling_dx;
#line 1872
  subsampling_dy___1 = parameters___16->subsampling_dy;
#line 1874
  memset((void *)(& cmptparm___4[0]), 0, (size_t )numcomps___8 * sizeof(opj_image_cmptparm_t ));
#line 1876
  i___147 = 0;
  }
  {
#line 1876
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1876
    if (! (i___147 < numcomps___8)) {
#line 1876
      goto while_break;
    }
#line 1877
    cmptparm___4[i___147].prec = (OPJ_UINT32 )prec___3;
#line 1878
    cmptparm___4[i___147].bpp = (OPJ_UINT32 )prec___3;
#line 1879
    cmptparm___4[i___147].sgnd = (OPJ_UINT32 )0;
#line 1880
    cmptparm___4[i___147].dx = (OPJ_UINT32 )subsampling_dx___1;
#line 1881
    cmptparm___4[i___147].dy = (OPJ_UINT32 )subsampling_dy___1;
#line 1882
    cmptparm___4[i___147].w = (OPJ_UINT32 )w___3;
#line 1883
    cmptparm___4[i___147].h = (OPJ_UINT32 )h___3;
#line 1876
    i___147 ++;
  }
  while_break___8: /* CIL Label */ ;
  }

  while_break: 
  {
#line 1885
  image___28 = opj_image_create((OPJ_UINT32 )numcomps___8, & cmptparm___4[0], color_space___2);
  }
#line 1887
  if (! image___28) {
    {
#line 1888
    fclose(fp___1);
    }
#line 1889
    return ((opj_image_t *)((void *)0));
  }
#line 1893
  image___28->x0 = (OPJ_UINT32 )parameters___16->image_offset_x0;
#line 1894
  image___28->y0 = (OPJ_UINT32 )parameters___16->image_offset_y0;
#line 1895
  image___28->x1 = (OPJ_UINT32 )((parameters___16->image_offset_x0 + (w___3 - 1) * subsampling_dx___1) + 1);
#line 1897
  image___28->y1 = (OPJ_UINT32 )((parameters___16->image_offset_y0 + (h___3 - 1) * subsampling_dy___1) + 1);
#line 1900
  if (format___0 == 2) {
    _L___53: 
#line 1903
    i___147 = 0;
    {
#line 1903
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1903
      if (! (i___147 < w___3 * h___3)) {
#line 1903
        goto while_break___0;
      }
#line 1904
      compno___15 = 0;
      {
#line 1904
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 1904
        if (! (compno___15 < numcomps___8)) {
#line 1904
          goto while_break___1;
        }
        {
#line 1905
        index___6 = 0U;
#line 1906
        __cil_tmp22___39 = fscanf(fp___1, "%u", & index___6);
        }
#line 1906
        if (__cil_tmp22___39 != 1) {
          {
#line 1907
          fprintf(stderr, "Missing data. Quitting.\n\220");
#line 1908
          opj_image_destroy(image___28);
#line 1909
          fclose(fp___1);
          }
#line 1910
          return ((opj_image_t *)((void *)0));
        }
#line 1913
        *((image___28->comps + compno___15)->data + i___147) = (OPJ_INT32 )(index___6 * 255U) / header_info.maxval;
#line 1904
        compno___15 ++;
      }
      while_break___10: /* CIL Label */ ;
      }

      while_break___1: 
#line 1903
      i___147 ++;
    }
    while_break___9: /* CIL Label */ ;
    }

    while_break___0: ;
  } else
#line 1900
  if (format___0 == 3) {
#line 1900
    goto _L___53;
  } else
#line 1916
  if (format___0 == 5) {
    _L: 
#line 1923
    one = (unsigned char )(prec___3 < 9);
#line 1925
    i___147 = 0;
    {
#line 1925
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 1925
      if (! (i___147 < w___3 * h___3)) {
#line 1925
        goto while_break___2;
      }
#line 1926
      compno___15 = 0;
      {
#line 1926
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 1926
        if (! (compno___15 < numcomps___8)) {
#line 1926
          goto while_break___3;
        }
        {
#line 1927
        __cil_tmp28___25 = fread((void *)(& c0), 1UL, 1UL, fp___1);
        }
#line 1927
        if (! __cil_tmp28___25) {
          {
#line 1928
          fprintf(stderr, "Missing data. Quitting.\n\220");
#line 1929
          opj_image_destroy(image___28);
#line 1930
          fclose(fp___1);
          }
#line 1931
          return ((opj_image_t *)((void *)0));
        }
#line 1933
        if (one) {
#line 1934
          *((image___28->comps + compno___15)->data + i___147) = (OPJ_INT32 )c0;
        } else {
          {
#line 1936
          __cil_tmp29___19 = fread((void *)(& c1___6), 1UL, 1UL, fp___1);
          }
#line 1936
          if (! __cil_tmp29___19) {
            {
#line 1937
            fprintf(stderr, "Missing data. Quitting.\n\220");
#line 1938
            opj_image_destroy(image___28);
#line 1939
            fclose(fp___1);
            }
#line 1940
            return ((opj_image_t *)((void *)0));
          }
#line 1943
          *((image___28->comps + compno___15)->data + i___147) = ((int )c0 << 8) | (int )c1___6;
        }
#line 1926
        compno___15 ++;
      }
      while_break___12: /* CIL Label */ ;
      }

      while_break___3: 
#line 1925
      i___147 ++;
    }
    while_break___11: /* CIL Label */ ;
    }

    while_break___2: ;
  } else
#line 1916
  if (format___0 == 6) {
#line 1916
    goto _L;
  } else
#line 1916
  if (format___0 == 7) {
#line 1916
    if ((int )header_info.gray) {
#line 1916
      goto _L;
    } else
#line 1916
    if ((int )header_info.graya) {
#line 1916
      goto _L;
    } else
#line 1916
    if ((int )header_info.rgb) {
#line 1916
      goto _L;
    } else
#line 1916
    if ((int )header_info.rgba) {
#line 1916
      goto _L;
    } else {
#line 1916
      goto _L___51;
    }
  } else
  _L___51: 
#line 1947
  if (format___0 == 1) {
#line 1948
    i___147 = 0;
    {
#line 1948
    while (1) {
      while_continue___4: /* CIL Label */ ;

#line 1948
      if (! (i___147 < w___3 * h___3)) {
#line 1948
        goto while_break___4;
      }
      {
#line 1951
      __cil_tmp33___16 = fscanf(fp___1, "%u\001", & index___7);
      }
#line 1951
      if (__cil_tmp33___16 != 1) {
        {
#line 1952
        fprintf(stderr, "Missing data. Quitting.\n\220");
#line 1953
        opj_image_destroy(image___28);
#line 1954
        fclose(fp___1);
        }
#line 1955
        return ((opj_image_t *)((void *)0));
      }
#line 1958
      if (index___7) {
#line 1958
        tmp___506 = 0;
      } else {
#line 1958
        tmp___506 = 255;
      }
#line 1958
      *((image___28->comps + 0)->data + i___147) = tmp___506;
#line 1948
      i___147 ++;
    }
    while_break___13: /* CIL Label */ ;
    }

    while_break___4: ;
  } else
#line 1960
  if (format___0 == 4) {
#line 1964
    i___147 = 0;
#line 1965
    y___9 = 0;
    {
#line 1965
    while (1) {
      while_continue___5: /* CIL Label */ ;

#line 1965
      if (! (y___9 < h___3)) {
#line 1965
        goto while_break___5;
      }
#line 1966
      bit = -1;
#line 1967
      uc = 0;
#line 1969
      x___8 = 0;
      {
#line 1969
      while (1) {
        while_continue___6: /* CIL Label */ ;

#line 1969
        if (! (x___8 < w___3)) {
#line 1969
          goto while_break___6;
        }
#line 1970
        if (bit == -1) {
          {
#line 1971
          bit = 7;
#line 1972
          uc = getc(fp___1);
          }
#line 1973
          if (uc == -1) {
            {
#line 1974
            fprintf(stderr, "Missing data. Quitting.\n\220");
#line 1975
            opj_image_destroy(image___28);
#line 1976
            fclose(fp___1);
            }
#line 1977
            return ((opj_image_t *)((void *)0));
          }
        }
#line 1980
        if (((int )((unsigned char )uc) >> bit) & 1) {
#line 1980
          tmp___507 = 0;
        } else {
#line 1980
          tmp___507 = 255;
        }
#line 1980
        *((image___28->comps + 0)->data + i___147) = tmp___507;
#line 1981
        bit --;
#line 1982
        i___147 ++;
#line 1969
        x___8 ++;
      }
      while_break___15: /* CIL Label */ ;
      }

      while_break___6: 
#line 1965
      y___9 ++;
    }
    while_break___14: /* CIL Label */ ;
    }

    while_break___5: ;
  } else
#line 1985
  if (format___0 == 7) {
#line 1985
    if ((int )header_info.bw) {
#line 1988
      i___147 = 0;
      {
#line 1988
      while (1) {
        while_continue___7: /* CIL Label */ ;

#line 1988
        if (! (i___147 < w___3 * h___3)) {
#line 1988
          goto while_break___7;
        }
        {
#line 1989
        __cil_tmp43___11 = fread((void *)(& uc___0), 1UL, 1UL, fp___1);
        }
#line 1989
        if (! __cil_tmp43___11) {
          {
#line 1990
          fprintf(stderr, "Missing data. Quitting.\n\220");
#line 1991
          opj_image_destroy(image___28);
#line 1992
          fclose(fp___1);
          }
#line 1993
          return ((opj_image_t *)((void *)0));
        }
#line 1995
        if ((int )uc___0 & 1) {
#line 1995
          tmp___508 = 0;
        } else {
#line 1995
          tmp___508 = 255;
        }
#line 1995
        *((image___28->comps + 0)->data + i___147) = tmp___508;
#line 1988
        i___147 ++;
      }
      while_break___16: /* CIL Label */ ;
      }

      while_break___7: ;
    }
  }
  {
#line 1998
  fclose(fp___1);
  }
#line 2000
  return (image___28);
}
}
#line 2003 "/root/patron-new/39/src/bin/jp2/convert.c"
static int are_comps_similar(opj_image_t *image___29 ) 
{ 
  unsigned int i___148 ;

  {
#line 2006
  i___148 = 1U;
  {
#line 2006
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2006
    if (! (i___148 < image___29->numcomps)) {
#line 2006
      goto while_break;
    }
#line 2007
    if ((image___29->comps + 0)->dx != (image___29->comps + i___148)->dx) {
#line 2012
      return (0);
    } else
#line 2007
    if ((image___29->comps + 0)->dy != (image___29->comps + i___148)->dy) {
#line 2012
      return (0);
    } else
#line 2007
    if (i___148 <= 2U) {
#line 2007
      if ((image___29->comps + 0)->prec != (image___29->comps + i___148)->prec) {
#line 2012
        return (0);
      } else
#line 2007
      if ((image___29->comps + 0)->sgnd != (image___29->comps + i___148)->sgnd) {
#line 2012
        return (0);
      }
    }
#line 2006
    i___148 ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 2015
  return (1);
}
}
#line 2019 "/root/patron-new/39/src/bin/jp2/convert.c"
int imagetopnm(opj_image_t *image___30 , char const   *outfile___3 , int force_split ) 
{ 
  int *red ;
  int *green ;
  int *blue ;
  int *alpha ;
  int wr ;
  int hr ;
  int max___2 ;
  int i___149 ;
  unsigned int compno___16 ;
  unsigned int ncomp ;
  int adjustR___1 ;
  int adjustG___1 ;
  int adjustB___1 ;
  int adjustA ;
  int fails___2 ;
  int two ;
  int want_gray ;
  int has_alpha ;
  int triple ;
  int prec___4 ;
  int v___3 ;
  FILE *fdest___2 ;
  char const   *tmp___509 ;
  char *destname ;
  int __cil_tmp28___26 ;
  char const   *tt ;
  char const   *tmp___510 ;
  char const   *__cil_tmp33___17 ;
  int tmp___511 ;
  char const   *__cil_tmp35___21 ;
  int tmp___512 ;
  int tmp___513 ;
  int tmp___514 ;
  int *__cil_tmp39___14 ;
  int *__cil_tmp40___17 ;
  int *__cil_tmp41___6 ;
  int *__cil_tmp42___5 ;
  unsigned long __cil_tmp43___12 ;
  void *__cil_tmp44___11 ;
  size_t olen___0 ;
  unsigned long __cil_tmp46___3 ;
  size_t dotpos___0 ;
  char const   *__cil_tmp49___1 ;
  int tmp___515 ;
  int *__cil_tmp51___6 ;
  int tmp___516 ;
  int tmp___517 ;

  {
#line 2028
  fdest___2 = (FILE *)((void *)0);
#line 2029
  tmp___509 = outfile___3;
#line 2032
  alpha = (int *)((void *)0);
#line 2034
  prec___4 = (int )(image___30->comps + 0)->prec;
#line 2034
  if (prec___4 > 16) {
    {
#line 2035
    fprintf(stderr, "%s:%d:imagetopnm\n\tprecision %d is larger than 16\n\t: refused.\n",
            "/root/patron-new/39/src/bin/jp2/convert.c\330\256\006]U", 2036, prec___4);
    }
#line 2037
    return (1);
  }
#line 2039
  has_alpha = 0;
#line 2039
  two = has_alpha;
#line 2040
  fails___2 = 1;
#line 2041
  ncomp = image___30->numcomps;
  {
#line 2043
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2043
    if (! *tmp___509) {
#line 2043
      goto while_break;
    }
#line 2044
    tmp___509 ++;
  }
  while_break___5: /* CIL Label */ ;
  }

  while_break: 
#line 2046
  tmp___509 -= 2;
#line 2047
  if ((int )*tmp___509 == 103) {
#line 2047
    tmp___516 = 1;
  } else
#line 2047
  if ((int )*tmp___509 == 71) {
#line 2047
    tmp___516 = 1;
  } else {
#line 2047
    tmp___516 = 0;
  }
#line 2047
  want_gray = tmp___516;
#line 2048
  ncomp = image___30->numcomps;
#line 2050
  if (want_gray) {
#line 2051
    ncomp = 1U;
  }
  {
#line 2054
  __cil_tmp28___26 = are_comps_similar(image___30);
  }
#line 2054
  if (force_split == 0) {
#line 2054
    if (ncomp >= 2U) {
#line 2054
      if (__cil_tmp28___26) {
        {
#line 2056
        fdest___2 = fopen(outfile___3, "wbo\006]U");
        }
#line 2058
        if (! fdest___2) {
          {
#line 2059
          fprintf(stderr, "ERROR -> failed to open %s for writing\n", outfile___3);
          }
#line 2060
          return (fails___2);
        }
#line 2062
        two = prec___4 > 8;
#line 2063
        triple = ncomp > 2U;
#line 2064
        wr = (int )(image___30->comps + 0)->w;
#line 2065
        hr = (int )(image___30->comps + 0)->h;
#line 2066
        max___2 = (1 << prec___4) - 1;
#line 2067
        if (ncomp == 4U) {
#line 2067
          tmp___517 = 1;
        } else
#line 2067
        if (ncomp == 2U) {
#line 2067
          tmp___517 = 1;
        } else {
#line 2067
          tmp___517 = 0;
        }
#line 2067
        has_alpha = tmp___517;
#line 2069
        red = (image___30->comps + 0)->data;
#line 2070
        if ((unsigned long )red == (unsigned long )((void *)0)) {
          {
#line 2071
          fprintf(stderr, "imagetopnm: planes[%d] == NULL.\n\251", 0);
#line 2073
          fprintf(stderr, "\tAborting\n");
#line 2074
          fclose(fdest___2);
          }
#line 2075
          return (fails___2);
        }
#line 2078
        if (triple) {
#line 2079
          green = (image___30->comps + 1)->data;
#line 2080
          blue = (image___30->comps + 2)->data;
#line 2081
          i___149 = 1;
          {
#line 2081
          while (1) {
            while_continue___3: /* CIL Label */ ;

#line 2081
            if (! (i___149 <= 2)) {
#line 2081
              goto while_break___0;
            }
#line 2082
            if ((unsigned long )(image___30->comps + i___149)->data == (unsigned long )((void *)0)) {
              {
#line 2083
              fprintf(stderr, "imagetopnm: planes[%d] == NULL.\n\230\001", i___149);
#line 2085
              fprintf(stderr, "\tAborting\n\256\006]U");
#line 2086
              fclose(fdest___2);
              }
#line 2087
              return (fails___2);
            }
#line 2081
            i___149 ++;
          }
          while_break___6: /* CIL Label */ ;
          }

          while_break___0: ;
        } else {
#line 2091
          blue = (int *)((void *)0);
#line 2091
          green = blue;
        }
#line 2094
        if (has_alpha) {
#line 2095
          if (triple) {
            {
#line 2095
            strcpy((char *)tmp___510, "RGB_ALPHA(\256\006]U");
            }
          } else {
            {
#line 2095
            strcpy((char *)tmp___510, "GRAYSCALE_ALPHA");
            }
          }
          {
#line 2095
          tt = tmp___510;
#line 2097
          __cil_tmp33___17 = opj_version();
#line 2097
          fprintf(fdest___2, "P7\n# OpenJPEG-%s\nWIDTH %d\nHEIGHT %d\nDEPTH %u\nMAXVAL %d\nTUPLTYPE %s\nENDHDR\n",
                  __cil_tmp33___17, wr, hr, ncomp, max___2, tt);
#line 2100
          alpha = (image___30->comps + (ncomp - 1U))->data;
          }
#line 2101
          if ((image___30->comps + (ncomp - 1U))->sgnd) {
#line 2101
            tmp___511 = 1 << ((image___30->comps + (ncomp - 1U))->prec - 1U);
          } else {
#line 2101
            tmp___511 = 0;
          }
#line 2101
          adjustA = tmp___511;
        } else {
          {
#line 2104
          __cil_tmp35___21 = opj_version();
#line 2104
          fprintf(fdest___2, "P6\n# OpenJPEG-%s\n%d %d\n%d\n", __cil_tmp35___21, wr,
                  hr, max___2);
#line 2106
          adjustA = 0;
          }
        }
#line 2108
        if ((image___30->comps + 0)->sgnd) {
#line 2108
          tmp___512 = 1 << ((image___30->comps + 0)->prec - 1U);
        } else {
#line 2108
          tmp___512 = 0;
        }
#line 2108
        adjustR___1 = tmp___512;
#line 2110
        if (triple) {
#line 2111
          if ((image___30->comps + 1)->sgnd) {
#line 2111
            tmp___513 = 1 << ((image___30->comps + 1)->prec - 1U);
          } else {
#line 2111
            tmp___513 = 0;
          }
#line 2111
          adjustG___1 = tmp___513;
#line 2112
          if ((image___30->comps + 2)->sgnd) {
#line 2112
            tmp___514 = 1 << ((image___30->comps + 2)->prec - 1U);
          } else {
#line 2112
            tmp___514 = 0;
          }
#line 2112
          adjustB___1 = tmp___514;
        } else {
#line 2114
          adjustB___1 = 0;
#line 2114
          adjustG___1 = adjustB___1;
        }
#line 2117
        i___149 = 0;
        {
#line 2117
        while (1) {
          while_continue___4: /* CIL Label */ ;

          while_continue___1: ;
#line 2117
          if (! (i___149 < wr * hr)) {
#line 2117
            goto while_break___1;
          }
#line 2118
          if (two) {
#line 2119
            v___3 = *red + adjustR___1;
#line 2120
            red ++;
#line 2121
            if (v___3 > 65535) {
#line 2122
              v___3 = 65535;
            } else
#line 2123
            if (v___3 < 0) {
#line 2124
              v___3 = 0;
            }
            {
#line 2128
            fprintf(fdest___2, "%c%c", (int )((unsigned char )(v___3 >> 8)), (int )((unsigned char )v___3));
            }
#line 2130
            if (triple) {
#line 2131
              v___3 = *green + adjustG___1;
#line 2132
              green ++;
#line 2133
              if (v___3 > 65535) {
#line 2134
                v___3 = 65535;
              } else
#line 2135
              if (v___3 < 0) {
#line 2136
                v___3 = 0;
              }
              {
#line 2140
              fprintf(fdest___2, "%c%c]U", (int )((unsigned char )(v___3 >> 8)), (int )((unsigned char )v___3));
#line 2142
              v___3 = *blue + adjustB___1;
#line 2143
              blue ++;
              }
#line 2144
              if (v___3 > 65535) {
#line 2145
                v___3 = 65535;
              } else
#line 2146
              if (v___3 < 0) {
#line 2147
                v___3 = 0;
              }
              {
#line 2151
              fprintf(fdest___2, "%c%c", (int )((unsigned char )(v___3 >> 8)), (int )((unsigned char )v___3));
              }
            }
#line 2155
            if (has_alpha) {
#line 2156
              v___3 = *alpha + adjustA;
#line 2157
              alpha ++;
#line 2158
              if (v___3 > 65535) {
#line 2159
                v___3 = 65535;
              } else
#line 2160
              if (v___3 < 0) {
#line 2161
                v___3 = 0;
              }
              {
#line 2165
              fprintf(fdest___2, "%c%c", (int )((unsigned char )(v___3 >> 8)), (int )((unsigned char )v___3));
              }
            }
#line 2167
            goto while_continue___1;
          }
#line 2172
          __cil_tmp39___14 = red;
#line 2172
          red ++;
#line 2172
          v___3 = *__cil_tmp39___14;
#line 2173
          if (v___3 > 255) {
#line 2174
            v___3 = 255;
          } else
#line 2175
          if (v___3 < 0) {
#line 2176
            v___3 = 0;
          }
          {
#line 2179
          fprintf(fdest___2, "%c\255\006]U", (int )((unsigned char )v___3));
          }
#line 2180
          if (triple) {
#line 2181
            __cil_tmp40___17 = green;
#line 2181
            green ++;
#line 2181
            v___3 = *__cil_tmp40___17;
#line 2182
            if (v___3 > 255) {
#line 2183
              v___3 = 255;
            } else
#line 2184
            if (v___3 < 0) {
#line 2185
              v___3 = 0;
            }
            {
#line 2188
            fprintf(fdest___2, "%c\255\006]U", (int )((unsigned char )v___3));
#line 2189
            __cil_tmp41___6 = blue;
#line 2189
            blue ++;
#line 2189
            v___3 = *__cil_tmp41___6;
            }
#line 2190
            if (v___3 > 255) {
#line 2191
              v___3 = 255;
            } else
#line 2192
            if (v___3 < 0) {
#line 2193
              v___3 = 0;
            }
            {
#line 2196
            fprintf(fdest___2, "%c", (int )((unsigned char )v___3));
            }
          }
#line 2198
          if (has_alpha) {
#line 2199
            __cil_tmp42___5 = alpha;
#line 2199
            alpha ++;
#line 2199
            v___3 = *__cil_tmp42___5;
#line 2200
            if (v___3 > 255) {
#line 2201
              v___3 = 255;
            } else
#line 2202
            if (v___3 < 0) {
#line 2203
              v___3 = 0;
            }
            {
#line 2206
            fprintf(fdest___2, "%c\255\006]U", (int )((unsigned char )v___3));
            }
          }
#line 2117
          i___149 ++;
        }
        while_break___7: /* CIL Label */ ;
        }

        while_break___1: 
        {
#line 2210
        fclose(fdest___2);
        }
#line 2211
        return (0);
      }
    }
  }
#line 2216
  if (image___30->numcomps > ncomp) {
    {
#line 2217
    fprintf(stderr, "WARNING -> [PGM file] Only the first component\n");
#line 2218
    fprintf(stderr, "           is written to the file\n");
    }
  }
  {
#line 2220
  __cil_tmp43___12 = strlen(outfile___3);
#line 2220
  __cil_tmp44___11 = malloc(__cil_tmp43___12 + 8UL);
#line 2220
  destname = (char *)__cil_tmp44___11;
  }
#line 2221
  if ((unsigned long )destname == (unsigned long )((void *)0)) {
    {
#line 2222
    fprintf(stderr, "imagetopnm: memory out\n");
    }
#line 2223
    return (1);
  }
#line 2225
  compno___16 = 0U;
  {
#line 2225
  while (1) {
    while_continue___5: /* CIL Label */ ;

    while_continue___2: ;
#line 2225
    if (! (compno___16 < ncomp)) {
#line 2225
      goto while_break___2;
    }
#line 2226
    if (ncomp > 1U) {
      {
#line 2228
      __cil_tmp46___3 = strlen(outfile___3);
#line 2228
      olen___0 = __cil_tmp46___3;
#line 2229
      dotpos___0 = olen___0 - 4UL;
#line 2231
      strncpy(destname, outfile___3, dotpos___0);
#line 2232
      sprintf(destname + dotpos___0, "_%u.pgm", compno___16);
      }
    } else {
      {
#line 2234
      sprintf(destname, "%s\255\006]U", outfile___3);
      }
    }
    {
#line 2237
    fdest___2 = fopen((char const   *)destname, "wb");
    }
#line 2238
    if (! fdest___2) {
      {
#line 2239
      fprintf(stderr, "ERROR -> failed to open %s for writing\n", destname);
#line 2240
      free((void *)destname);
      }
#line 2241
      return (1);
    }
    {
#line 2243
    wr = (int )(image___30->comps + compno___16)->w;
#line 2244
    hr = (int )(image___30->comps + compno___16)->h;
#line 2245
    prec___4 = (int )(image___30->comps + compno___16)->prec;
#line 2246
    max___2 = (1 << prec___4) - 1;
#line 2248
    __cil_tmp49___1 = opj_version();
#line 2248
    fprintf(fdest___2, "P5\n#OpenJPEG-%s\n%d %d\n%d\n", __cil_tmp49___1, wr, hr, max___2);
#line 2251
    red = (image___30->comps + compno___16)->data;
    }
#line 2252
    if (! red) {
      {
#line 2253
      fclose(fdest___2);
      }
#line 2254
      goto while_continue___2;
    }
#line 2257
    if ((image___30->comps + compno___16)->sgnd) {
#line 2257
      tmp___515 = 1 << ((image___30->comps + compno___16)->prec - 1U);
    } else {
#line 2257
      tmp___515 = 0;
    }
#line 2257
    adjustR___1 = tmp___515;
#line 2260
    if (prec___4 > 8) {
#line 2261
      i___149 = 0;
      {
#line 2261
      while (1) {
        while_continue___6: /* CIL Label */ ;

#line 2261
        if (! (i___149 < wr * hr)) {
#line 2261
          goto while_break___3;
        }
#line 2262
        v___3 = *red + adjustR___1;
#line 2263
        red ++;
#line 2264
        if (v___3 > 65535) {
#line 2265
          v___3 = 65535;
        } else
#line 2266
        if (v___3 < 0) {
#line 2267
          v___3 = 0;
        }
        {
#line 2271
        fprintf(fdest___2, "%c%c]U", (int )((unsigned char )(v___3 >> 8)), (int )((unsigned char )v___3));
        }
#line 2273
        if (has_alpha) {
#line 2274
          __cil_tmp51___6 = alpha;
#line 2274
          alpha ++;
#line 2274
          v___3 = *__cil_tmp51___6;
#line 2275
          if (v___3 > 65535) {
#line 2276
            v___3 = 65535;
          } else
#line 2277
          if (v___3 < 0) {
#line 2278
            v___3 = 0;
          }
          {
#line 2282
          fprintf(fdest___2, "%c%c]U", (int )((unsigned char )(v___3 >> 8)), (int )((unsigned char )v___3));
          }
        }
#line 2261
        i___149 ++;
      }
      while_break___9: /* CIL Label */ ;
      }

      while_break___3: ;
    } else {
#line 2286
      i___149 = 0;
      {
#line 2286
      while (1) {
        while_continue___7: /* CIL Label */ ;

#line 2286
        if (! (i___149 < wr * hr)) {
#line 2286
          goto while_break___4;
        }
#line 2287
        v___3 = *red + adjustR___1;
#line 2288
        red ++;
#line 2289
        if (v___3 > 255) {
#line 2290
          v___3 = 255;
        } else
#line 2291
        if (v___3 < 0) {
#line 2292
          v___3 = 0;
        }
        {
#line 2295
        fprintf(fdest___2, "%c\255\006]U", (int )((unsigned char )v___3));
#line 2286
        i___149 ++;
        }
      }
      while_break___10: /* CIL Label */ ;
      }

      while_break___4: ;
    }
    {
#line 2298
    fclose(fdest___2);
#line 2225
    compno___16 ++;
    }
  }
  while_break___8: /* CIL Label */ ;
  }

  while_break___2: 
  {
#line 2300
  free((void *)destname);
  }
#line 2302
  return (0);
}
}
#line 2310 "/root/patron-new/39/src/bin/jp2/convert.c"
static opj_image_t *rawtoimage_common(char const   *filename___4 , opj_cparameters_t *parameters___17 ,
                                      raw_cparameters_t *raw_cp , OPJ_BOOL big_endian ) 
{ 
  int subsampling_dx___2 ;
  int subsampling_dy___2 ;
  FILE *f___4 ;
  int i___150 ;
  int compno___17 ;
  int numcomps___9 ;
  int w___4 ;
  int h___4 ;
  OPJ_COLOR_SPACE color_space___3 ;
  opj_image_cmptparm_t *cmptparm___5 ;
  opj_image_t *image___31 ;
  unsigned short ch___1 ;
  void *__cil_tmp18___39 ;
  unsigned char value___3 ;
  int nloop ;
  unsigned long __cil_tmp23___36 ;
  int tmp___518 ;
  unsigned short value___4 ;
  int nloop___0 ;
  unsigned char temp1 ;
  unsigned char temp2 ;
  unsigned long __cil_tmp31___24 ;
  unsigned long __cil_tmp32___25 ;
  int tmp___519 ;
  unsigned long __cil_tmp36___20 ;

  {
#line 2313
  subsampling_dx___2 = parameters___17->subsampling_dx;
#line 2314
  subsampling_dy___2 = parameters___17->subsampling_dy;
#line 2316
  f___4 = (FILE *)((void *)0);
#line 2320
  image___31 = (opj_image_t *)((void *)0);
#line 2323
  if (! (((raw_cp->rawWidth & raw_cp->rawHeight) & raw_cp->rawComp) & raw_cp->rawBitDepth) == 0) {
    {
#line 2325
    fprintf(stderr, "\nError: invalid raw image parameters\nU");
#line 2326
    fprintf(stderr, "Please use the Format option -F:\n\241\256\006]U");
#line 2327
    fprintf(stderr, "-F <width>,<height>,<ncomp>,<bitdepth>,{s,u}@<dx1>x<dy1>:...:<dxn>x<dyn>\n");
#line 2329
    fprintf(stderr, "If subsampling is omitted, 1x1 is assumed for all components\n");
#line 2331
    fprintf(stderr, "Example: -i image.raw -o image.j2k -F 512,512,3,8,u@1x1:2x2:2x2\n\220");
#line 2333
    fprintf(stderr, "         for raw 512x512 image with 4:2:0 subsampling\n");
#line 2334
    fprintf(stderr, "Aborting.\n\256\006]U");
    }
#line 2335
    return ((opj_image_t *)((void *)0));
  }
  {
#line 2338
  f___4 = fopen(filename___4, "rb\256\006]U");
  }
#line 2339
  if (! f___4) {
    {
#line 2340
    fprintf(stderr, "Failed to open %s for reading !!\n", filename___4);
#line 2341
    fprintf(stderr, "Aborting\n\b\257\006]U");
    }
#line 2342
    return ((opj_image_t *)((void *)0));
  }
#line 2344
  numcomps___9 = raw_cp->rawComp;
#line 2347
  if (numcomps___9 == 1) {
#line 2348
    color_space___3 = (OPJ_COLOR_SPACE )2;
  } else
#line 2349
  if (numcomps___9 >= 3) {
#line 2349
    if ((int )parameters___17->tcp_mct == 0) {
#line 2350
      color_space___3 = (OPJ_COLOR_SPACE )3;
    } else {
#line 2349
      goto _L;
    }
  } else
  _L: 
#line 2351
  if (numcomps___9 >= 3) {
#line 2351
    if ((int )parameters___17->tcp_mct != 2) {
#line 2352
      color_space___3 = (OPJ_COLOR_SPACE )1;
    } else {
#line 2354
      color_space___3 = (OPJ_COLOR_SPACE )-1;
    }
  } else {
#line 2354
    color_space___3 = (OPJ_COLOR_SPACE )-1;
  }
  {
#line 2356
  w___4 = raw_cp->rawWidth;
#line 2357
  h___4 = raw_cp->rawHeight;
#line 2358
  __cil_tmp18___39 = calloc((unsigned long )((OPJ_UINT32 )numcomps___9), sizeof(opj_image_cmptparm_t ));
#line 2358
  cmptparm___5 = (opj_image_cmptparm_t *)__cil_tmp18___39;
  }
#line 2360
  if (! cmptparm___5) {
    {
#line 2361
    fprintf(stderr, "Failed to allocate image components parameters !!\n\256\006]U");
#line 2362
    fprintf(stderr, "Aborting\n");
#line 2363
    fclose(f___4);
    }
#line 2364
    return ((opj_image_t *)((void *)0));
  }
#line 2367
  i___150 = 0;
  {
#line 2367
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2367
    if (! (i___150 < numcomps___9)) {
#line 2367
      goto while_break;
    }
#line 2368
    (cmptparm___5 + i___150)->prec = (OPJ_UINT32 )raw_cp->rawBitDepth;
#line 2369
    (cmptparm___5 + i___150)->bpp = (OPJ_UINT32 )raw_cp->rawBitDepth;
#line 2370
    (cmptparm___5 + i___150)->sgnd = (OPJ_UINT32 )raw_cp->rawSigned;
#line 2371
    (cmptparm___5 + i___150)->dx = (OPJ_UINT32 )(subsampling_dx___2 * (raw_cp->rawComps + i___150)->dx);
#line 2372
    (cmptparm___5 + i___150)->dy = (OPJ_UINT32 )(subsampling_dy___2 * (raw_cp->rawComps + i___150)->dy);
#line 2373
    (cmptparm___5 + i___150)->w = (OPJ_UINT32 )w___4;
#line 2374
    (cmptparm___5 + i___150)->h = (OPJ_UINT32 )h___4;
#line 2367
    i___150 ++;
  }
  while_break___4: /* CIL Label */ ;
  }

  while_break: 
  {
#line 2377
  image___31 = opj_image_create((OPJ_UINT32 )numcomps___9, cmptparm___5 + 0, color_space___3);
#line 2378
  free((void *)cmptparm___5);
  }
#line 2379
  if (! image___31) {
    {
#line 2380
    fclose(f___4);
    }
#line 2381
    return ((opj_image_t *)((void *)0));
  }
#line 2384
  image___31->x0 = (OPJ_UINT32 )parameters___17->image_offset_x0;
#line 2385
  image___31->y0 = (OPJ_UINT32 )parameters___17->image_offset_y0;
#line 2386
  image___31->x1 = ((OPJ_UINT32 )parameters___17->image_offset_x0 + (OPJ_UINT32 )(w___4 - 1) * (OPJ_UINT32 )subsampling_dx___2) + 1U;
#line 2388
  image___31->y1 = ((OPJ_UINT32 )parameters___17->image_offset_y0 + (OPJ_UINT32 )(h___4 - 1) * (OPJ_UINT32 )subsampling_dy___2) + 1U;
#line 2391
  if (raw_cp->rawBitDepth <= 8) {
#line 2392
    value___3 = (unsigned char)0;
#line 2393
    compno___17 = 0;
    {
#line 2393
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 2393
      if (! (compno___17 < numcomps___9)) {
#line 2393
        goto while_break___0;
      }
#line 2394
      nloop = (w___4 * h___4) / ((raw_cp->rawComps + compno___17)->dx * (raw_cp->rawComps + compno___17)->dy);
#line 2396
      i___150 = 0;
      {
#line 2396
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 2396
        if (! (i___150 < nloop)) {
#line 2396
          goto while_break___1;
        }
        {
#line 2397
        __cil_tmp23___36 = fread((void *)(& value___3), 1UL, 1UL, f___4);
        }
#line 2397
        if (! __cil_tmp23___36) {
          {
#line 2398
          fprintf(stderr, "Error reading raw file. End of file probably reached.\n");
#line 2399
          opj_image_destroy(image___31);
#line 2400
          fclose(f___4);
          }
#line 2401
          return ((opj_image_t *)((void *)0));
        }
#line 2403
        if (raw_cp->rawSigned) {
#line 2403
          tmp___518 = (int )((char )value___3);
        } else {
#line 2403
          tmp___518 = (int )value___3;
        }
#line 2403
        *((image___31->comps + compno___17)->data + i___150) = tmp___518;
#line 2396
        i___150 ++;
      }
      while_break___6: /* CIL Label */ ;
      }

      while_break___1: 
#line 2393
      compno___17 ++;
    }
    while_break___5: /* CIL Label */ ;
    }

    while_break___0: ;
  } else
#line 2406
  if (raw_cp->rawBitDepth <= 16) {
#line 2408
    compno___17 = 0;
    {
#line 2408
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 2408
      if (! (compno___17 < numcomps___9)) {
#line 2408
        goto while_break___2;
      }
#line 2409
      nloop___0 = (w___4 * h___4) / ((raw_cp->rawComps + compno___17)->dx * (raw_cp->rawComps + compno___17)->dy);
#line 2411
      i___150 = 0;
      {
#line 2411
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 2411
        if (! (i___150 < nloop___0)) {
#line 2411
          goto while_break___3;
        }
        {
#line 2414
        __cil_tmp31___24 = fread((void *)(& temp1), 1UL, 1UL, f___4);
        }
#line 2414
        if (! __cil_tmp31___24) {
          {
#line 2415
          fprintf(stderr, "Error reading raw file. End of file probably reached.\n");
#line 2416
          opj_image_destroy(image___31);
#line 2417
          fclose(f___4);
          }
#line 2418
          return ((opj_image_t *)((void *)0));
        }
        {
#line 2420
        __cil_tmp32___25 = fread((void *)(& temp2), 1UL, 1UL, f___4);
        }
#line 2420
        if (! __cil_tmp32___25) {
          {
#line 2421
          fprintf(stderr, "Error reading raw file. End of file probably reached.\n");
#line 2422
          opj_image_destroy(image___31);
#line 2423
          fclose(f___4);
          }
#line 2424
          return ((opj_image_t *)((void *)0));
        }
#line 2426
        if (big_endian) {
#line 2427
          value___4 = (unsigned short )(((int )temp1 << 8) + (int )temp2);
        } else {
#line 2429
          value___4 = (unsigned short )(((int )temp2 << 8) + (int )temp1);
        }
#line 2431
        if (raw_cp->rawSigned) {
#line 2431
          tmp___519 = (int )((short )value___4);
        } else {
#line 2431
          tmp___519 = (int )value___4;
        }
#line 2431
        *((image___31->comps + compno___17)->data + i___150) = tmp___519;
#line 2411
        i___150 ++;
      }
      while_break___8: /* CIL Label */ ;
      }

      while_break___3: 
#line 2408
      compno___17 ++;
    }
    while_break___7: /* CIL Label */ ;
    }

    while_break___2: ;
  } else {
    {
#line 2435
    fprintf(stderr, "OpenJPEG cannot encode raw components with bit depth higher than 16 bits.\n");
#line 2437
    opj_image_destroy(image___31);
#line 2438
    fclose(f___4);
    }
#line 2439
    return ((opj_image_t *)((void *)0));
  }
  {
#line 2442
  __cil_tmp36___20 = fread((void *)(& ch___1), 1UL, 1UL, f___4);
  }
#line 2442
  if (__cil_tmp36___20) {
    {
#line 2443
    fprintf(stderr, "Warning. End of raw file not reached... processing anyway\n\256\006]U");
    }
  }
  {
#line 2445
  fclose(f___4);
  }
#line 2447
  return (image___31);
}
}
#line 2450 "/root/patron-new/39/src/bin/jp2/convert.c"
opj_image_t *rawltoimage(char const   *filename___5 , opj_cparameters_t *parameters___18 ,
                         raw_cparameters_t *raw_cp___0 ) 
{ 
  opj_image_t *__cil_tmp4___26 ;

  {
  {
#line 2453
  __cil_tmp4___26 = rawtoimage_common(filename___5, parameters___18, raw_cp___0, 0);
  }
#line 2453
  return (__cil_tmp4___26);
}
}
#line 2456 "/root/patron-new/39/src/bin/jp2/convert.c"
opj_image_t *rawtoimage(char const   *filename___6 , opj_cparameters_t *parameters___19 ,
                        raw_cparameters_t *raw_cp___1 ) 
{ 
  opj_image_t *__cil_tmp4___27 ;

  {
  {
#line 2459
  __cil_tmp4___27 = rawtoimage_common(filename___6, parameters___19, raw_cp___1, 1);
  }
#line 2459
  return (__cil_tmp4___27);
}
}
#line 2462 "/root/patron-new/39/src/bin/jp2/convert.c"
static int imagetoraw_common(opj_image_t *image___32 , char const   *outfile___4 ,
                             OPJ_BOOL big_endian___0 ) 
{ 
  FILE *rawFile ;
  size_t res___2 ;
  unsigned int compno___18 ;
  unsigned int numcomps___10 ;
  int w___5 ;
  int h___5 ;
  int fails___3 ;
  int line___0 ;
  int row ;
  int curr ;
  int mask___0 ;
  int *ptr___7 ;
  unsigned char uc___1 ;
  char const   *tmp___520 ;

  {
#line 2465
  rawFile = (FILE *)((void *)0);
#line 2474
  if ((image___32->numcomps * image___32->x1) * image___32->y1 == 0U) {
    {
#line 2475
    fprintf(stderr, "\nError: invalid raw image parameters\nU");
    }
#line 2476
    return (1);
  }
#line 2479
  numcomps___10 = image___32->numcomps;
#line 2481
  if (numcomps___10 > 4U) {
#line 2482
    numcomps___10 = 4U;
  }
#line 2485
  compno___18 = 1U;
  {
#line 2485
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2485
    if (! (compno___18 < numcomps___10)) {
#line 2485
      goto while_break;
    }
#line 2486
    if ((image___32->comps + 0)->dx != (image___32->comps + compno___18)->dx) {
#line 2487
      goto while_break;
    }
#line 2489
    if ((image___32->comps + 0)->dy != (image___32->comps + compno___18)->dy) {
#line 2490
      goto while_break;
    }
#line 2492
    if ((image___32->comps + 0)->prec != (image___32->comps + compno___18)->prec) {
#line 2493
      goto while_break;
    }
#line 2495
    if ((image___32->comps + 0)->sgnd != (image___32->comps + compno___18)->sgnd) {
#line 2496
      goto while_break;
    }
#line 2485
    compno___18 ++;
  }
  while_break___9: /* CIL Label */ ;
  }

  while_break: ;
#line 2499
  if (compno___18 != numcomps___10) {
    {
#line 2500
    fprintf(stderr, "imagetoraw_common: All components shall have the same subsampling, same bit depth, same sign.\n");
#line 2502
    fprintf(stderr, "\tAborting\n");
    }
#line 2503
    return (1);
  }
  {
#line 2506
  rawFile = fopen(outfile___4, "wb\257\006]U");
  }
#line 2507
  if (! rawFile) {
    {
#line 2508
    fprintf(stderr, "Failed to open %s for writing !!\n\272\256\006]U", outfile___4);
    }
#line 2509
    return (1);
  }
  {
#line 2512
  fails___3 = 1;
#line 2513
  fprintf(stdout, "Raw image characteristics: %d components\n<\257\006]U", image___32->numcomps);
#line 2515
  compno___18 = 0U;
  }
  {
#line 2515
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 2515
    if (! (compno___18 < image___32->numcomps)) {
#line 2515
      goto while_break___0;
    }
#line 2516
    if ((image___32->comps + compno___18)->sgnd == 1U) {
      {
#line 2516
      strcpy((char *)tmp___520, "signed");
      }
    } else {
      {
#line 2516
      strcpy((char *)tmp___520, "unsigned\220");
      }
    }
    {
#line 2516
    fprintf(stdout, "Component %u characteristics: %dx%dx%d %s\n\257\006]U", compno___18,
            (image___32->comps + compno___18)->w, (image___32->comps + compno___18)->h,
            (image___32->comps + compno___18)->prec, tmp___520);
#line 2521
    w___5 = (int )(image___32->comps + compno___18)->w;
#line 2522
    h___5 = (int )(image___32->comps + compno___18)->h;
    }
#line 2524
    if ((image___32->comps + compno___18)->prec <= 8U) {
#line 2525
      if ((image___32->comps + compno___18)->sgnd == 1U) {
#line 2526
        mask___0 = (1 << (image___32->comps + compno___18)->prec) - 1;
#line 2527
        ptr___7 = (image___32->comps + compno___18)->data;
#line 2528
        line___0 = 0;
        {
#line 2528
        while (1) {
          while_continue___1: /* CIL Label */ ;

#line 2528
          if (! (line___0 < h___5)) {
#line 2528
            goto while_break___1;
          }
#line 2529
          row = 0;
          {
#line 2529
          while (1) {
            while_continue___2: /* CIL Label */ ;

#line 2529
            if (! (row < w___5)) {
#line 2529
              goto while_break___2;
            }
#line 2530
            curr = *ptr___7;
#line 2531
            if (curr > 127) {
#line 2532
              curr = 127;
            } else
#line 2533
            if (curr < -128) {
#line 2534
              curr = -128;
            }
            {
#line 2536
            uc___1 = (unsigned char )(curr & mask___0);
#line 2537
            res___2 = fwrite((void const   *)(& uc___1), 1UL, 1UL, rawFile);
            }
#line 2538
            if (res___2 < 1UL) {
              {
#line 2539
              fprintf(stderr, "failed to write 1 byte for %s\n", outfile___4);
              }
#line 2540
              goto fin;
            }
#line 2542
            ptr___7 ++;
#line 2529
            row ++;
          }
          while_break___12: /* CIL Label */ ;
          }

          while_break___2: 
#line 2528
          line___0 ++;
        }
        while_break___11: /* CIL Label */ ;
        }

        while_break___1: ;
      } else
#line 2545
      if ((image___32->comps + compno___18)->sgnd == 0U) {
#line 2546
        mask___0 = (1 << (image___32->comps + compno___18)->prec) - 1;
#line 2547
        ptr___7 = (image___32->comps + compno___18)->data;
#line 2548
        line___0 = 0;
        {
#line 2548
        while (1) {
          while_continue___3: /* CIL Label */ ;

#line 2548
          if (! (line___0 < h___5)) {
#line 2548
            goto while_break___3;
          }
#line 2549
          row = 0;
          {
#line 2549
          while (1) {
            while_continue___4: /* CIL Label */ ;

#line 2549
            if (! (row < w___5)) {
#line 2549
              goto while_break___4;
            }
#line 2550
            curr = *ptr___7;
#line 2551
            if (curr > 255) {
#line 2552
              curr = 255;
            } else
#line 2553
            if (curr < 0) {
#line 2554
              curr = 0;
            }
            {
#line 2556
            uc___1 = (unsigned char )(curr & mask___0);
#line 2557
            res___2 = fwrite((void const   *)(& uc___1), 1UL, 1UL, rawFile);
            }
#line 2558
            if (res___2 < 1UL) {
              {
#line 2559
              fprintf(stderr, "failed to write 1 byte for %s\n", outfile___4);
              }
#line 2560
              goto fin;
            }
#line 2562
            ptr___7 ++;
#line 2549
            row ++;
          }
          while_break___14: /* CIL Label */ ;
          }

          while_break___4: 
#line 2548
          line___0 ++;
        }
        while_break___13: /* CIL Label */ ;
        }

        while_break___3: ;
      }
    } else
#line 2566
    if ((image___32->comps + compno___18)->prec <= 16U) {
#line 2567
      if ((image___32->comps + compno___18)->sgnd == 1U) {
#line 2572
        mask___0 = (1 << (image___32->comps + compno___18)->prec) - 1;
#line 2573
        ptr___7 = (image___32->comps + compno___18)->data;
#line 2574
        line___0 = 0;
        {
#line 2574
        while (1) {
          while_continue___5: /* CIL Label */ ;

#line 2574
          if (! (line___0 < h___5)) {
#line 2574
            goto while_break___5;
          }
#line 2575
          row = 0;
          {
#line 2575
          while (1) {
            while_continue___6: /* CIL Label */ ;

#line 2575
            if (! (row < w___5)) {
#line 2575
              goto while_break___6;
            }
#line 2576
            curr = *ptr___7;
#line 2577
            if (curr > 32767) {
#line 2578
              curr = 32767;
            } else
#line 2579
            if (curr < -32768) {
#line 2580
              curr = -32768;
            }
            {
#line 2582
            __asm__  ("booo_exp(/root/patron-new/39/src/bin/jp2/convert.c:2582)":);
#line 2583
            __asm__  ("booo_exp(/root/patron-new/39/src/bin/jp2/convert.c:2583)":);
#line 2583
            res___2 = fwrite((void const   *)((signed char *)0), 1UL, 2UL, rawFile);
            }
#line 2584
            if (res___2 < 2UL) {
              {
#line 2585
              fprintf(stderr, "failed to write 2 byte for %s\n", outfile___4);
              }
#line 2586
              goto fin;
            }
#line 2588
            ptr___7 ++;
#line 2575
            row ++;
          }
          while_break___16: /* CIL Label */ ;
          }

          while_break___6: 
#line 2574
          line___0 ++;
        }
        while_break___15: /* CIL Label */ ;
        }

        while_break___5: ;
      } else
#line 2591
      if ((image___32->comps + compno___18)->sgnd == 0U) {
#line 2596
        mask___0 = (1 << (image___32->comps + compno___18)->prec) - 1;
#line 2597
        ptr___7 = (image___32->comps + compno___18)->data;
#line 2598
        line___0 = 0;
        {
#line 2598
        while (1) {
          while_continue___7: /* CIL Label */ ;

#line 2598
          if (! (line___0 < h___5)) {
#line 2598
            goto while_break___7;
          }
#line 2599
          row = 0;
          {
#line 2599
          while (1) {
            while_continue___8: /* CIL Label */ ;

#line 2599
            if (! (row < w___5)) {
#line 2599
              goto while_break___8;
            }
#line 2600
            curr = *ptr___7;
#line 2601
            if (curr > 65535) {
#line 2602
              curr = 65535;
            } else
#line 2603
            if (curr < 0) {
#line 2604
              curr = 0;
            }
            {
#line 2606
            __asm__  ("booo_exp(/root/patron-new/39/src/bin/jp2/convert.c:2606)":);
#line 2607
            __asm__  ("booo_exp(/root/patron-new/39/src/bin/jp2/convert.c:2607)":);
#line 2607
            res___2 = fwrite((void const   *)((unsigned char *)0), 1UL, 2UL, rawFile);
            }
#line 2608
            if (res___2 < 2UL) {
              {
#line 2609
              fprintf(stderr, "failed to write 2 byte for %s\n", outfile___4);
              }
#line 2610
              goto fin;
            }
#line 2612
            ptr___7 ++;
#line 2599
            row ++;
          }
          while_break___18: /* CIL Label */ ;
          }

          while_break___8: 
#line 2598
          line___0 ++;
        }
        while_break___17: /* CIL Label */ ;
        }

        while_break___7: ;
      }
    } else
#line 2616
    if ((image___32->comps + compno___18)->prec <= 32U) {
      {
#line 2617
      fprintf(stderr, "More than 16 bits per component not handled yet\n\220");
      }
#line 2618
      goto fin;
    } else {
      {
#line 2620
      fprintf(stderr, "Error: invalid precision: %d\n", (image___32->comps + compno___18)->prec);
      }
#line 2621
      goto fin;
    }
#line 2515
    compno___18 ++;
  }
  while_break___10: /* CIL Label */ ;
  }

  while_break___0: 
#line 2624
  fails___3 = 0;
  fin: 
  {
#line 2626
  fclose(rawFile);
  }
#line 2627
  return (fails___3);
}
}
#line 2630 "/root/patron-new/39/src/bin/jp2/convert.c"
int imagetoraw(opj_image_t *image___33 , char const   *outfile___5 ) 
{ 
  int __cil_tmp3___36 ;

  {
  {
#line 2632
  __cil_tmp3___36 = imagetoraw_common(image___33, outfile___5, 1);
  }
#line 2632
  return (__cil_tmp3___36);
}
}
#line 2635 "/root/patron-new/39/src/bin/jp2/convert.c"
int imagetorawl(opj_image_t *image___34 , char const   *outfile___6 ) 
{ 
  int __cil_tmp3___37 ;

  {
  {
#line 2637
  __cil_tmp3___37 = imagetoraw_common(image___34, outfile___6, 0);
  }
#line 2637
  return (__cil_tmp3___37);
}
}
#line 47 "/root/patron-new/39/src/bin/jp2/index.h"
int write_index_file(opj_codestream_info_t *cstr_info___1 , char *index___8 ) ;
#line 49 "/root/patron-new/39/src/bin/jp2/index.c"
int write_index_file(opj_codestream_info_t *cstr_info___1 , char *index___8 ) 
{ 
  int tileno___4 ;
  int compno___19 ;
  int layno___0 ;
  int resno___1 ;
  int precno ;
  int pack_nb ;
  int x___9 ;
  int y___10 ;
  FILE *stream___6 ;
  double total_disto ;
  int tilepartno___0 ;
  char disto_on ;
  char numpix_on ;
  int __cil_tmp17___41 ;
  OPJ_OFF_T start_pos ;
  OPJ_OFF_T end_ph_pos ;
  OPJ_OFF_T end_pos ;
  double disto ;
  int max_numdecompos ;
  int prec_max ;
  int prec_max___0 ;
  int numprec ;
  int x0 ;
  double __cil_tmp40___18 ;
  int y0___60 ;
  double __cil_tmp42___6 ;
  int x1 ;
  int y1___61 ;
  int pcnx ;
  int pcx ;
  double __cil_tmp47___6 ;
  int pcy ;
  double __cil_tmp49___2 ;
  int precno_x ;
  double __cil_tmp51___7 ;
  int precno_y ;
  double __cil_tmp53___2 ;
  int x0___0 ;
  double __cil_tmp62___1 ;
  int y0___62 ;
  double __cil_tmp64___1 ;
  int x1___0 ;
  int y1___63 ;
  int max_numprec ;
  int numprec___0 ;
  int numprec___1 ;
  int pcnx___0 ;
  int pcx___0 ;
  double __cil_tmp73___0 ;
  int pcy___0 ;
  double __cil_tmp75___1 ;
  int precno_x___0 ;
  double __cil_tmp77___1 ;
  int precno_y___0 ;
  double __cil_tmp79___1 ;
  int max_numprec___0 ;
  int numprec___2 ;
  int x0___1 ;
  double __cil_tmp91___0 ;
  int y0___64 ;
  double __cil_tmp93 ;
  int x1___1 ;
  int y1___65 ;
  int numprec___3 ;
  int pcnx___1 ;
  int pcx___1 ;
  double __cil_tmp99 ;
  int pcy___1 ;
  double __cil_tmp101 ;
  int precno_x___1 ;
  double __cil_tmp103 ;
  int precno_y___1 ;
  double __cil_tmp105 ;

  {
#line 52
  stream___6 = (FILE *)((void *)0);
#line 53
  total_disto = (double )0;
#line 65
  if (! cstr_info___1) {
#line 66
    return (1);
  }
  {
#line 69
  stream___6 = fopen((char const   *)index___8, "w");
  }
#line 70
  if (! stream___6) {
    {
#line 71
    fprintf(stderr, "failed to open index file [%s] for writing\n", index___8);
    }
#line 72
    return (1);
  }
#line 75
  if ((cstr_info___1->tile + 0)->distotile > 0.) {
#line 76
    disto_on = (char)1;
  } else {
#line 78
    disto_on = (char)0;
  }
#line 81
  if ((cstr_info___1->tile + 0)->numpix) {
#line 82
    numpix_on = (char)1;
  } else {
#line 84
    numpix_on = (char)0;
  }
  {
#line 87
  fprintf(stream___6, "%d %d\n", cstr_info___1->image_w, cstr_info___1->image_h);
#line 88
  fprintf(stream___6, "%d\n", (int )cstr_info___1->prog);
#line 89
  fprintf(stream___6, "%d %d\n", cstr_info___1->tile_x, cstr_info___1->tile_y);
#line 90
  fprintf(stream___6, "%d %d\n", cstr_info___1->tw, cstr_info___1->th);
#line 91
  fprintf(stream___6, "%d\n", cstr_info___1->numcomps);
#line 92
  fprintf(stream___6, "%d\n", cstr_info___1->numlayers);
#line 93
  fprintf(stream___6, "%d\n", *(cstr_info___1->numdecompos + 0));
#line 95
  resno___1 = *(cstr_info___1->numdecompos + 0);
  }
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;

#line 95
    if (! (resno___1 >= 0)) {
#line 95
      goto while_break;
    }
    {
#line 96
    fprintf(stream___6, "[%d,%d] \251", 1 << (cstr_info___1->tile + 0)->pdx[resno___1],
            1 << (cstr_info___1->tile + 0)->pdx[resno___1]);
#line 95
    __cil_tmp17___41 = resno___1;
#line 95
    resno___1 --;
    }
  }
  while_break___33: /* CIL Label */ ;
  }

  while_break: 
  {
#line 101
  fprintf(stream___6, "\n");
#line 103
  fprintf(stream___6, "%d\n", cstr_info___1->main_head_start);
#line 105
  fprintf(stream___6, "%d\n", cstr_info___1->main_head_end);
#line 106
  fprintf(stream___6, "%d\n", cstr_info___1->codestream_size);
#line 108
  fprintf(stream___6, "\nINFO ON TILES\n");
#line 109
  fprintf(stream___6, "tileno start_pos  end_hd  end_tile   nbparts");
  }
#line 110
  if (disto_on) {
    {
#line 111
    fprintf(stream___6, "         disto");
    }
  }
#line 113
  if (numpix_on) {
    {
#line 114
    fprintf(stream___6, "     nbpix");
    }
  }
#line 116
  if ((int )disto_on) {
#line 116
    if ((int )numpix_on) {
      {
#line 117
      fprintf(stream___6, "  disto/nbpix");
      }
    }
  }
  {
#line 119
  fprintf(stream___6, "\n");
#line 121
  tileno___4 = 0;
  }
  {
#line 121
  while (1) {
    while_continue___29: /* CIL Label */ ;

#line 121
    if (! (tileno___4 < cstr_info___1->tw * cstr_info___1->th)) {
#line 121
      goto while_break___0;
    }
    {
#line 122
    fprintf(stream___6, "%4d %9d %9d %9d %9d", (cstr_info___1->tile + tileno___4)->tileno,
            (cstr_info___1->tile + tileno___4)->start_pos, (cstr_info___1->tile + tileno___4)->end_header,
            (cstr_info___1->tile + tileno___4)->end_pos, (cstr_info___1->tile + tileno___4)->num_tps);
    }
#line 128
    if (disto_on) {
      {
#line 129
      fprintf(stream___6, " %9e", (cstr_info___1->tile + tileno___4)->distotile);
      }
    }
#line 131
    if (numpix_on) {
      {
#line 132
      fprintf(stream___6, " %9d", (cstr_info___1->tile + tileno___4)->numpix);
      }
    }
#line 134
    if ((int )disto_on) {
#line 134
      if ((int )numpix_on) {
        {
#line 135
        fprintf(stream___6, " %9e", (cstr_info___1->tile + tileno___4)->distotile / (double )(cstr_info___1->tile + tileno___4)->numpix);
        }
      }
    }
    {
#line 138
    fprintf(stream___6, "\n");
#line 121
    tileno___4 ++;
    }
  }
  while_break___34: /* CIL Label */ ;
  }

  while_break___0: 
#line 141
  tileno___4 = 0;
  {
#line 141
  while (1) {
    while_continue___30: /* CIL Label */ ;

#line 141
    if (! (tileno___4 < cstr_info___1->tw * cstr_info___1->th)) {
#line 141
      goto while_break___1;
    }
#line 143
    disto = (double )0;
#line 144
    max_numdecompos = 0;
#line 145
    pack_nb = 0;
#line 147
    compno___19 = 0;
    {
#line 147
    while (1) {
      while_continue___31: /* CIL Label */ ;

#line 147
      if (! (compno___19 < cstr_info___1->numcomps)) {
#line 147
        goto while_break___2;
      }
#line 148
      if (max_numdecompos < *(cstr_info___1->numdecompos + compno___19)) {
#line 149
        max_numdecompos = *(cstr_info___1->numdecompos + compno___19);
      }
#line 147
      compno___19 ++;
    }
    while_break___36: /* CIL Label */ ;
    }

    while_break___2: 
    {
#line 153
    fprintf(stream___6, "\nTILE %d DETAILS\n", tileno___4);
#line 154
    fprintf(stream___6, "part_nb tileno  start_pack num_packs  start_pos end_tph_pos   end_pos\n");
#line 156
    tilepartno___0 = 0;
    }
    {
#line 156
    while (1) {
      while_continue___32: /* CIL Label */ ;

#line 156
      if (! (tilepartno___0 < (cstr_info___1->tile + tileno___4)->num_tps)) {
#line 156
        goto while_break___3;
      }
      {
#line 157
      fprintf(stream___6, "%4d %9d   %9d %9d  %9d %11d %9d\n\230\001", tilepartno___0,
              tileno___4, ((cstr_info___1->tile + tileno___4)->tp + tilepartno___0)->tp_start_pack,
              ((cstr_info___1->tile + tileno___4)->tp + tilepartno___0)->tp_numpacks,
              ((cstr_info___1->tile + tileno___4)->tp + tilepartno___0)->tp_start_pos,
              ((cstr_info___1->tile + tileno___4)->tp + tilepartno___0)->tp_end_header,
              ((cstr_info___1->tile + tileno___4)->tp + tilepartno___0)->tp_end_pos);
#line 156
      tilepartno___0 ++;
      }
    }
    while_break___37: /* CIL Label */ ;
    }

    while_break___3: ;
#line 166
    if ((int )cstr_info___1->prog == 0) {
      {
#line 167
      fprintf(stream___6, "LRCP\npack_nb tileno layno resno compno precno start_pos end_ph_pos end_pos");
      }
#line 169
      if (disto_on) {
        {
#line 170
        fprintf(stream___6, " disto");
        }
      }
      {
#line 172
      fprintf(stream___6, "\n");
#line 174
      layno___0 = 0;
      }
      {
#line 174
      while (1) {
        while_continue___33: /* CIL Label */ ;

#line 174
        if (! (layno___0 < cstr_info___1->numlayers)) {
#line 174
          goto while_break___4;
        }
#line 175
        resno___1 = 0;
        {
#line 175
        while (1) {
          while_continue___34: /* CIL Label */ ;

#line 175
          if (! (resno___1 < max_numdecompos + 1)) {
#line 175
            goto while_break___5;
          }
#line 176
          compno___19 = 0;
          {
#line 176
          while (1) {
            while_continue___35: /* CIL Label */ ;

#line 176
            if (! (compno___19 < cstr_info___1->numcomps)) {
#line 176
              goto while_break___6;
            }
#line 178
            if (resno___1 > *(cstr_info___1->numdecompos + compno___19)) {
#line 179
              goto while_break___6;
            }
#line 181
            prec_max = (cstr_info___1->tile + tileno___4)->pw[resno___1] * (cstr_info___1->tile + tileno___4)->ph[resno___1];
#line 183
            precno = 0;
            {
#line 183
            while (1) {
              while_continue___36: /* CIL Label */ ;

#line 183
              if (! (precno < prec_max)) {
#line 183
                goto while_break___7;
              }
              {
#line 184
              start_pos = ((cstr_info___1->tile + tileno___4)->packet + pack_nb)->start_pos;
#line 185
              end_ph_pos = ((cstr_info___1->tile + tileno___4)->packet + pack_nb)->end_ph_pos;
#line 186
              end_pos = ((cstr_info___1->tile + tileno___4)->packet + pack_nb)->end_pos;
#line 187
              disto = ((cstr_info___1->tile + tileno___4)->packet + pack_nb)->disto;
#line 188
              fprintf(stream___6, "%4d %6d %7d %5d %6d  %6d    %6ld     %6ld %7ld",
                      pack_nb, tileno___4, layno___0, resno___1, compno___19, precno,
                      start_pos, end_ph_pos, end_pos);
              }
#line 191
              if (disto_on) {
                {
#line 192
                fprintf(stream___6, " %8e", disto);
                }
              }
              {
#line 194
              fprintf(stream___6, "\n");
#line 195
              total_disto += disto;
#line 196
              pack_nb ++;
#line 183
              precno ++;
              }
            }
            while_break___41: /* CIL Label */ ;
            }

            while_break___7: 
#line 176
            compno___19 ++;
          }
          while_break___40: /* CIL Label */ ;
          }

          while_break___6: 
#line 175
          resno___1 ++;
        }
        while_break___39: /* CIL Label */ ;
        }

        while_break___5: 
#line 174
        layno___0 ++;
      }
      while_break___38: /* CIL Label */ ;
      }

      while_break___4: ;
    } else
#line 203
    if ((int )cstr_info___1->prog == 1) {
      {
#line 204
      fprintf(stream___6, "RLCP\npack_nb tileno resno layno compno precno start_pos end_ph_pos end_pos\n");
      }
#line 206
      if (disto_on) {
        {
#line 207
        fprintf(stream___6, " disto");
        }
      }
      {
#line 209
      fprintf(stream___6, "\n");
#line 211
      resno___1 = 0;
      }
      {
#line 211
      while (1) {
        while_continue___37: /* CIL Label */ ;

#line 211
        if (! (resno___1 < max_numdecompos + 1)) {
#line 211
          goto while_break___8;
        }
#line 212
        layno___0 = 0;
        {
#line 212
        while (1) {
          while_continue___38: /* CIL Label */ ;

#line 212
          if (! (layno___0 < cstr_info___1->numlayers)) {
#line 212
            goto while_break___9;
          }
#line 213
          compno___19 = 0;
          {
#line 213
          while (1) {
            while_continue___39: /* CIL Label */ ;

#line 213
            if (! (compno___19 < cstr_info___1->numcomps)) {
#line 213
              goto while_break___10;
            }
#line 215
            if (resno___1 > *(cstr_info___1->numdecompos + compno___19)) {
#line 216
              goto while_break___10;
            }
#line 218
            prec_max___0 = (cstr_info___1->tile + tileno___4)->pw[resno___1] * (cstr_info___1->tile + tileno___4)->ph[resno___1];
#line 220
            precno = 0;
            {
#line 220
            while (1) {
              while_continue___40: /* CIL Label */ ;

#line 220
              if (! (precno < prec_max___0)) {
#line 220
                goto while_break___11;
              }
              {
#line 221
              start_pos = ((cstr_info___1->tile + tileno___4)->packet + pack_nb)->start_pos;
#line 222
              end_ph_pos = ((cstr_info___1->tile + tileno___4)->packet + pack_nb)->end_ph_pos;
#line 223
              end_pos = ((cstr_info___1->tile + tileno___4)->packet + pack_nb)->end_pos;
#line 224
              disto = ((cstr_info___1->tile + tileno___4)->packet + pack_nb)->disto;
#line 225
              fprintf(stream___6, "%4d %6d %5d %7d %6d %6d %9ld   %9ld %7ld\230\001",
                      pack_nb, tileno___4, resno___1, layno___0, compno___19, precno,
                      start_pos, end_ph_pos, end_pos);
              }
#line 227
              if (disto_on) {
                {
#line 228
                fprintf(stream___6, " %8e", disto);
                }
              }
              {
#line 230
              fprintf(stream___6, "\n");
#line 231
              total_disto += disto;
#line 232
              pack_nb ++;
#line 220
              precno ++;
              }
            }
            while_break___45: /* CIL Label */ ;
            }

            while_break___11: 
#line 213
            compno___19 ++;
          }
          while_break___44: /* CIL Label */ ;
          }

          while_break___10: 
#line 212
          layno___0 ++;
        }
        while_break___43: /* CIL Label */ ;
        }

        while_break___9: 
#line 211
        resno___1 ++;
      }
      while_break___42: /* CIL Label */ ;
      }

      while_break___8: ;
    } else
#line 239
    if ((int )cstr_info___1->prog == 2) {
      {
#line 241
      fprintf(stream___6, "RPCL\npack_nb tileno resno precno compno layno start_pos end_ph_pos end_pos");
      }
#line 243
      if (disto_on) {
        {
#line 244
        fprintf(stream___6, " disto");
        }
      }
      {
#line 246
      fprintf(stream___6, "\n");
#line 248
      resno___1 = 0;
      }
      {
#line 248
      while (1) {
        while_continue___41: /* CIL Label */ ;

#line 248
        if (! (resno___1 < max_numdecompos + 1)) {
#line 248
          goto while_break___12;
        }
#line 249
        numprec = (cstr_info___1->tile + tileno___4)->pw[resno___1] * (cstr_info___1->tile + tileno___4)->ph[resno___1];
#line 251
        precno = 0;
        {
#line 251
        while (1) {
          while_continue___42: /* CIL Label */ ;

#line 251
          if (! (precno < numprec)) {
#line 251
            goto while_break___13;
          }
          {
#line 253
          __cil_tmp40___18 = floor((double )((float )tileno___4 / (float )cstr_info___1->tw));
#line 253
          x0 = (cstr_info___1->tile_Ox + tileno___4) - ((int )__cil_tmp40___18 * cstr_info___1->tw) * cstr_info___1->tile_x;
#line 255
          __cil_tmp42___6 = floor((double )((float )tileno___4 / (float )cstr_info___1->tw));
#line 255
          y0___60 = cstr_info___1->tile_Ox + (int )__cil_tmp42___6 * cstr_info___1->tile_y;
#line 257
          x1 = x0 + cstr_info___1->tile_x;
#line 258
          y1___61 = y0___60 + cstr_info___1->tile_y;
#line 259
          compno___19 = 0;
          }
          {
#line 259
          while (1) {
            while_continue___43: /* CIL Label */ ;

#line 259
            if (! (compno___19 < cstr_info___1->numcomps)) {
#line 259
              goto while_break___14;
            }
            {
#line 260
            pcnx = (cstr_info___1->tile + tileno___4)->pw[resno___1];
#line 261
            __cil_tmp47___6 = pow((double )2, (double )(((cstr_info___1->tile + tileno___4)->pdx[resno___1] + *(cstr_info___1->numdecompos + compno___19)) - resno___1));
#line 261
            pcx = (int )__cil_tmp47___6;
#line 263
            __cil_tmp49___2 = pow((double )2, (double )(((cstr_info___1->tile + tileno___4)->pdy[resno___1] + *(cstr_info___1->numdecompos + compno___19)) - resno___1));
#line 263
            pcy = (int )__cil_tmp49___2;
#line 265
            __cil_tmp51___7 = floor((double )((float )precno / (float )pcnx));
#line 265
            precno_x = precno - (int )__cil_tmp51___7 * pcnx;
#line 266
            __cil_tmp53___2 = floor((double )((float )precno / (float )pcnx));
#line 266
            precno_y = (int )__cil_tmp53___2;
            }
#line 267
            if (resno___1 > *(cstr_info___1->numdecompos + compno___19)) {
#line 268
              goto while_break___14;
            }
#line 270
            y___10 = y0___60;
            {
#line 270
            while (1) {
              while_continue___44: /* CIL Label */ ;

#line 270
              if (! (y___10 < y1___61)) {
#line 270
                goto while_break___15;
              }
#line 271
              if (precno_y * pcy == y___10) {
#line 272
                x___9 = x0;
                {
#line 272
                while (1) {
                  while_continue___45: /* CIL Label */ ;

#line 272
                  if (! (x___9 < x1)) {
#line 272
                    goto while_break___16;
                  }
#line 273
                  if (precno_x * pcx == x___9) {
#line 274
                    layno___0 = 0;
                    {
#line 274
                    while (1) {
                      while_continue___46: /* CIL Label */ ;

#line 274
                      if (! (layno___0 < cstr_info___1->numlayers)) {
#line 274
                        goto while_break___17;
                      }
                      {
#line 275
                      start_pos = ((cstr_info___1->tile + tileno___4)->packet + pack_nb)->start_pos;
#line 276
                      end_ph_pos = ((cstr_info___1->tile + tileno___4)->packet + pack_nb)->end_ph_pos;
#line 277
                      end_pos = ((cstr_info___1->tile + tileno___4)->packet + pack_nb)->end_pos;
#line 278
                      disto = ((cstr_info___1->tile + tileno___4)->packet + pack_nb)->disto;
#line 279
                      fprintf(stream___6, "%4d %6d %5d %6d %6d %7d %9ld   %9ld %7ld\230\001",
                              pack_nb, tileno___4, resno___1, precno, compno___19,
                              layno___0, start_pos, end_ph_pos, end_pos);
                      }
#line 281
                      if (disto_on) {
                        {
#line 282
                        fprintf(stream___6, " %8e", disto);
                        }
                      }
                      {
#line 284
                      fprintf(stream___6, "\n");
#line 285
                      total_disto += disto;
#line 286
                      pack_nb ++;
#line 274
                      layno___0 ++;
                      }
                    }
                    while_break___51: /* CIL Label */ ;
                    }

                    while_break___17: ;
                  }
#line 272
                  x___9 ++;
                }
                while_break___50: /* CIL Label */ ;
                }

                while_break___16: ;
              }
#line 270
              y___10 ++;
            }
            while_break___49: /* CIL Label */ ;
            }

            while_break___15: 
#line 259
            compno___19 ++;
          }
          while_break___48: /* CIL Label */ ;
          }

          while_break___14: 
#line 251
          precno ++;
        }
        while_break___47: /* CIL Label */ ;
        }

        while_break___13: 
#line 248
        resno___1 ++;
      }
      while_break___46: /* CIL Label */ ;
      }

      while_break___12: ;
    } else
#line 297
    if ((int )cstr_info___1->prog == 3) {
      {
#line 299
      __cil_tmp62___1 = floor((double )((float )tileno___4 / (float )cstr_info___1->tw));
#line 299
      x0___0 = (cstr_info___1->tile_Ox + tileno___4) - ((int )__cil_tmp62___1 * cstr_info___1->tw) * cstr_info___1->tile_x;
#line 301
      __cil_tmp64___1 = floor((double )((float )tileno___4 / (float )cstr_info___1->tw));
#line 301
      y0___62 = cstr_info___1->tile_Ox + (int )__cil_tmp64___1 * cstr_info___1->tile_y;
#line 303
      x1___0 = x0___0 + cstr_info___1->tile_x;
#line 304
      y1___63 = y0___62 + cstr_info___1->tile_y;
#line 307
      max_numprec = 0;
#line 308
      resno___1 = 0;
      }
      {
#line 308
      while (1) {
        while_continue___47: /* CIL Label */ ;

#line 308
        if (! (resno___1 < max_numdecompos + 1)) {
#line 308
          goto while_break___18;
        }
#line 309
        numprec___0 = (cstr_info___1->tile + tileno___4)->pw[resno___1] * (cstr_info___1->tile + tileno___4)->ph[resno___1];
#line 311
        if (numprec___0 > max_numprec) {
#line 312
          max_numprec = numprec___0;
        }
#line 308
        resno___1 ++;
      }
      while_break___52: /* CIL Label */ ;
      }

      while_break___18: 
      {
#line 316
      fprintf(stream___6, "PCRL\npack_nb tileno precno compno resno layno start_pos end_ph_pos end_pos");
      }
#line 318
      if (disto_on) {
        {
#line 319
        fprintf(stream___6, " disto");
        }
      }
      {
#line 321
      fprintf(stream___6, "\n");
#line 323
      precno = 0;
      }
      {
#line 323
      while (1) {
        while_continue___48: /* CIL Label */ ;

#line 323
        if (! (precno < max_numprec)) {
#line 323
          goto while_break___19;
        }
#line 324
        compno___19 = 0;
        {
#line 324
        while (1) {
          while_continue___49: /* CIL Label */ ;

#line 324
          if (! (compno___19 < cstr_info___1->numcomps)) {
#line 324
            goto while_break___20;
          }
#line 325
          resno___1 = 0;
          {
#line 325
          while (1) {
            while_continue___50: /* CIL Label */ ;

            while_continue___21: ;
#line 325
            if (! (resno___1 < *(cstr_info___1->numdecompos + compno___19) + 1)) {
#line 325
              goto while_break___21;
            }
            {
#line 326
            numprec___1 = (cstr_info___1->tile + tileno___4)->pw[resno___1] * (cstr_info___1->tile + tileno___4)->ph[resno___1];
#line 328
            pcnx___0 = (cstr_info___1->tile + tileno___4)->pw[resno___1];
#line 329
            __cil_tmp73___0 = pow((double )2, (double )(((cstr_info___1->tile + tileno___4)->pdx[resno___1] + *(cstr_info___1->numdecompos + compno___19)) - resno___1));
#line 329
            pcx___0 = (int )__cil_tmp73___0;
#line 331
            __cil_tmp75___1 = pow((double )2, (double )(((cstr_info___1->tile + tileno___4)->pdy[resno___1] + *(cstr_info___1->numdecompos + compno___19)) - resno___1));
#line 331
            pcy___0 = (int )__cil_tmp75___1;
#line 333
            __cil_tmp77___1 = floor((double )((float )precno / (float )pcnx___0));
#line 333
            precno_x___0 = precno - (int )__cil_tmp77___1 * pcnx___0;
#line 334
            __cil_tmp79___1 = floor((double )((float )precno / (float )pcnx___0));
#line 334
            precno_y___0 = (int )__cil_tmp79___1;
            }
#line 335
            if (precno >= numprec___1) {
#line 336
              goto while_continue___21;
            }
#line 338
            y___10 = y0___62;
            {
#line 338
            while (1) {
              while_continue___51: /* CIL Label */ ;

#line 338
              if (! (y___10 < y1___63)) {
#line 338
                goto while_break___22;
              }
#line 339
              if (precno_y___0 * pcy___0 == y___10) {
#line 340
                x___9 = x0___0;
                {
#line 340
                while (1) {
                  while_continue___52: /* CIL Label */ ;

#line 340
                  if (! (x___9 < x1___0)) {
#line 340
                    goto while_break___23;
                  }
#line 341
                  if (precno_x___0 * pcx___0 == x___9) {
#line 342
                    layno___0 = 0;
                    {
#line 342
                    while (1) {
                      while_continue___53: /* CIL Label */ ;

#line 342
                      if (! (layno___0 < cstr_info___1->numlayers)) {
#line 342
                        goto while_break___24;
                      }
                      {
#line 343
                      start_pos = ((cstr_info___1->tile + tileno___4)->packet + pack_nb)->start_pos;
#line 344
                      end_ph_pos = ((cstr_info___1->tile + tileno___4)->packet + pack_nb)->end_ph_pos;
#line 345
                      end_pos = ((cstr_info___1->tile + tileno___4)->packet + pack_nb)->end_pos;
#line 346
                      disto = ((cstr_info___1->tile + tileno___4)->packet + pack_nb)->disto;
#line 347
                      fprintf(stream___6, "%4d %6d %6d %6d %5d %7d %9ld   %9ld %7ld\230\001",
                              pack_nb, tileno___4, precno, compno___19, resno___1,
                              layno___0, start_pos, end_ph_pos, end_pos);
                      }
#line 349
                      if (disto_on) {
                        {
#line 350
                        fprintf(stream___6, " %8e", disto);
                        }
                      }
                      {
#line 352
                      fprintf(stream___6, "\n");
#line 353
                      total_disto += disto;
#line 354
                      pack_nb ++;
#line 342
                      layno___0 ++;
                      }
                    }
                    while_break___58: /* CIL Label */ ;
                    }

                    while_break___24: ;
                  }
#line 340
                  x___9 ++;
                }
                while_break___57: /* CIL Label */ ;
                }

                while_break___23: ;
              }
#line 338
              y___10 ++;
            }
            while_break___56: /* CIL Label */ ;
            }

            while_break___22: 
#line 325
            resno___1 ++;
          }
          while_break___55: /* CIL Label */ ;
          }

          while_break___21: 
#line 324
          compno___19 ++;
        }
        while_break___54: /* CIL Label */ ;
        }

        while_break___20: 
#line 323
        precno ++;
      }
      while_break___53: /* CIL Label */ ;
      }

      while_break___19: ;
    } else {
#line 367
      max_numprec___0 = 0;
#line 368
      resno___1 = 0;
      {
#line 368
      while (1) {
        while_continue___54: /* CIL Label */ ;

#line 368
        if (! (resno___1 < max_numdecompos + 1)) {
#line 368
          goto while_break___25;
        }
#line 369
        numprec___2 = (cstr_info___1->tile + tileno___4)->pw[resno___1] * (cstr_info___1->tile + tileno___4)->ph[resno___1];
#line 371
        if (numprec___2 > max_numprec___0) {
#line 372
          max_numprec___0 = numprec___2;
        }
#line 368
        resno___1 ++;
      }
      while_break___59: /* CIL Label */ ;
      }

      while_break___25: 
      {
#line 376
      fprintf(stream___6, "CPRL\npack_nb tileno compno precno resno layno start_pos end_ph_pos end_pos");
      }
#line 378
      if (disto_on) {
        {
#line 379
        fprintf(stream___6, " disto");
        }
      }
      {
#line 381
      fprintf(stream___6, "\n");
#line 383
      compno___19 = 0;
      }
      {
#line 383
      while (1) {
        while_continue___55: /* CIL Label */ ;

#line 383
        if (! (compno___19 < cstr_info___1->numcomps)) {
#line 383
          goto while_break___26;
        }
        {
#line 385
        __cil_tmp91___0 = floor((double )((float )tileno___4 / (float )cstr_info___1->tw));
#line 385
        x0___1 = (cstr_info___1->tile_Ox + tileno___4) - ((int )__cil_tmp91___0 * cstr_info___1->tw) * cstr_info___1->tile_x;
#line 387
        __cil_tmp93 = floor((double )((float )tileno___4 / (float )cstr_info___1->tw));
#line 387
        y0___64 = cstr_info___1->tile_Ox + (int )__cil_tmp93 * cstr_info___1->tile_y;
#line 389
        x1___1 = x0___1 + cstr_info___1->tile_x;
#line 390
        y1___65 = y0___64 + cstr_info___1->tile_y;
#line 392
        precno = 0;
        }
        {
#line 392
        while (1) {
          while_continue___56: /* CIL Label */ ;

#line 392
          if (! (precno < max_numprec___0)) {
#line 392
            goto while_break___27;
          }
#line 393
          resno___1 = 0;
          {
#line 393
          while (1) {
            while_continue___57: /* CIL Label */ ;

            while_continue___28: ;
#line 393
            if (! (resno___1 < *(cstr_info___1->numdecompos + compno___19) + 1)) {
#line 393
              goto while_break___28;
            }
            {
#line 394
            numprec___3 = (cstr_info___1->tile + tileno___4)->pw[resno___1] * (cstr_info___1->tile + tileno___4)->ph[resno___1];
#line 396
            pcnx___1 = (cstr_info___1->tile + tileno___4)->pw[resno___1];
#line 397
            __cil_tmp99 = pow((double )2, (double )(((cstr_info___1->tile + tileno___4)->pdx[resno___1] + *(cstr_info___1->numdecompos + compno___19)) - resno___1));
#line 397
            pcx___1 = (int )__cil_tmp99;
#line 399
            __cil_tmp101 = pow((double )2, (double )(((cstr_info___1->tile + tileno___4)->pdy[resno___1] + *(cstr_info___1->numdecompos + compno___19)) - resno___1));
#line 399
            pcy___1 = (int )__cil_tmp101;
#line 401
            __cil_tmp103 = floor((double )((float )precno / (float )pcnx___1));
#line 401
            precno_x___1 = precno - (int )__cil_tmp103 * pcnx___1;
#line 402
            __cil_tmp105 = floor((double )((float )precno / (float )pcnx___1));
#line 402
            precno_y___1 = (int )__cil_tmp105;
            }
#line 403
            if (precno >= numprec___3) {
#line 404
              goto while_continue___28;
            }
#line 407
            y___10 = y0___64;
            {
#line 407
            while (1) {
              while_continue___58: /* CIL Label */ ;

#line 407
              if (! (y___10 < y1___65)) {
#line 407
                goto while_break___29;
              }
#line 408
              if (precno_y___1 * pcy___1 == y___10) {
#line 409
                x___9 = x0___1;
                {
#line 409
                while (1) {
                  while_continue___59: /* CIL Label */ ;

#line 409
                  if (! (x___9 < x1___1)) {
#line 409
                    goto while_break___30;
                  }
#line 410
                  if (precno_x___1 * pcx___1 == x___9) {
#line 411
                    layno___0 = 0;
                    {
#line 411
                    while (1) {
                      while_continue___60: /* CIL Label */ ;

#line 411
                      if (! (layno___0 < cstr_info___1->numlayers)) {
#line 411
                        goto while_break___31;
                      }
                      {
#line 412
                      start_pos = ((cstr_info___1->tile + tileno___4)->packet + pack_nb)->start_pos;
#line 413
                      end_ph_pos = ((cstr_info___1->tile + tileno___4)->packet + pack_nb)->end_ph_pos;
#line 414
                      end_pos = ((cstr_info___1->tile + tileno___4)->packet + pack_nb)->end_pos;
#line 415
                      disto = ((cstr_info___1->tile + tileno___4)->packet + pack_nb)->disto;
#line 416
                      fprintf(stream___6, "%4d %6d %6d %6d %5d %7d %9ld   %9ld %7ld\230\001",
                              pack_nb, tileno___4, compno___19, precno, resno___1,
                              layno___0, start_pos, end_ph_pos, end_pos);
                      }
#line 418
                      if (disto_on) {
                        {
#line 419
                        fprintf(stream___6, " %8e", disto);
                        }
                      }
                      {
#line 421
                      fprintf(stream___6, "\n");
#line 422
                      total_disto += disto;
#line 423
                      pack_nb ++;
#line 411
                      layno___0 ++;
                      }
                    }
                    while_break___65: /* CIL Label */ ;
                    }

                    while_break___31: ;
                  }
#line 409
                  x___9 ++;
                }
                while_break___64: /* CIL Label */ ;
                }

                while_break___30: ;
              }
#line 407
              y___10 ++;
            }
            while_break___63: /* CIL Label */ ;
            }

            while_break___29: 
#line 393
            resno___1 ++;
          }
          while_break___62: /* CIL Label */ ;
          }

          while_break___28: 
#line 392
          precno ++;
        }
        while_break___61: /* CIL Label */ ;
        }

        while_break___27: 
#line 383
        compno___19 ++;
      }
      while_break___60: /* CIL Label */ ;
      }

      while_break___26: ;
    }
#line 141
    tileno___4 ++;
  }
  while_break___35: /* CIL Label */ ;
  }

  while_break___1: ;
#line 435
  if (disto_on) {
    {
#line 436
    fprintf(stream___6, "%8e\n", cstr_info___1->D_max);
#line 437
    fprintf(stream___6, "%.8e\n", total_disto);
    }
  }
#line 441
  if (cstr_info___1->marknum) {
    {
#line 442
    fprintf(stream___6, "\nMARKER LIST\n");
#line 443
    fprintf(stream___6, "%d\n", cstr_info___1->marknum);
#line 444
    fprintf(stream___6, "type\tstart_pos    length\n");
#line 445
    x___9 = 0;
    }
    {
#line 445
    while (1) {
      while_continue___61: /* CIL Label */ ;

#line 445
      if (! (x___9 < cstr_info___1->marknum)) {
#line 445
        goto while_break___32;
      }
      {
#line 446
      fprintf(stream___6, "%X\t%9ld %9d\n\230\001", (int )(cstr_info___1->marker + x___9)->type,
              (cstr_info___1->marker + x___9)->pos, (cstr_info___1->marker + x___9)->len);
#line 445
      x___9 ++;
      }
    }
    while_break___66: /* CIL Label */ ;
    }

    while_break___32: ;
  }
  {
#line 451
  fclose(stream___6);
#line 453
  fprintf(stderr, "Generated index file %s\n\230\001", index___8);
  }
#line 455
  return (0);
}
}
#line 134 "/usr/include/dirent.h"
extern DIR *opendir(char const   *__name ) ;
#line 149
extern int closedir(DIR *__dirp ) ;
#line 162
extern struct dirent *readdir(DIR *__dirp ) ;
#line 17 "/root/patron-new/39/src/bin/common/opj_getopt.h"
int opj_opterr ;
#line 18
int opj_optind ;
#line 19 "/root/patron-new/39/src/bin/common/opj_getopt.h"
int opj_optopt  ;
#line 20 "/root/patron-new/39/src/bin/common/opj_getopt.h"
int opj_optreset  ;
#line 21 "/root/patron-new/39/src/bin/common/opj_getopt.h"
char *opj_optarg  ;
#line 23
int opj_getopt(int nargc , char * const  *nargv , char const   *ostr ) ;
#line 24
int opj_getopt_long(int argc___1 , char * const  *argv___1 , char const   *optstring ,
                    opj_option_t *longopts , int totlen___0 ) ;
#line 26
void opj_reset_options_reading(void) ;
#line 40 "/root/patron-new/39/src/bin/common/opj_string.h"
static size_t opj_strnlen_s(char const   *src___0 , size_t max_len ) 
{ 
  size_t len___9 ;
  char const   *__cil_tmp4___28 ;
  size_t __cil_tmp5___49 ;

  {
#line 44
  if ((unsigned long )src___0 == (unsigned long )((void *)0)) {
#line 45
    return ((size_t )0U);
  }
#line 47
  len___9 = (size_t )0U;
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;

#line 47
    if ((int )*src___0 != 0) {
#line 47
      if (! (len___9 < max_len)) {
#line 47
        goto while_break;
      }
    } else {
#line 47
      goto while_break;
    }
#line 47
    __cil_tmp5___49 = len___9;
#line 47
    len___9 ++;
#line 47
    __cil_tmp4___28 = src___0;
#line 47
    src___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 48
  return (len___9);
}
}
#line 53 "/root/patron-new/39/src/bin/common/opj_string.h"
static int opj_strcpy_s(char *dst___49 , size_t dst_size , char const   *src___1 ) 
{ 
  size_t src_len ;

  {
#line 55
  src_len = (size_t )0U;
#line 56
  if ((unsigned long )dst___49 == (unsigned long )((void *)0)) {
#line 57
    return (22);
  } else
#line 56
  if (dst_size == 0UL) {
#line 57
    return (22);
  }
#line 59
  if ((unsigned long )src___1 == (unsigned long )((void *)0)) {
#line 60
    *(dst___49 + 0) = (char )'\000';
#line 61
    return (22);
  }
  {
#line 63
  src_len = opj_strnlen_s(src___1, dst_size);
  }
#line 64
  if (src_len >= dst_size) {
#line 65
    return (34);
  }
  {
#line 67
  memcpy((void *)dst___49, (void const   *)src___1, src_len);
#line 68
  *(dst___49 + src_len) = (char )'\000';
  }
#line 69
  return (0);
}
}
#line 92 "/root/patron-new/39/src/bin/jp2/opj_compress.c"
static void encode_help_display(void) 
{ 
  char const   *__cil_tmp1 ;
  OPJ_BOOL __cil_tmp2___20 ;

  {
  {
#line 94
  __cil_tmp1 = opj_version();
#line 94
  fprintf(stdout, "\nThis is the opj_compress utility from the OpenJPEG project.\nIt compresses various image formats with the JPEG 2000 algorithm.\nIt has been compiled against openjp2 library v%s.\n\n",
          __cil_tmp1);
#line 99
  fprintf(stdout, "Default encoding options:\n");
#line 100
  fprintf(stdout, "-------------------------\n");
#line 101
  fprintf(stdout, "\n");
#line 102
  fprintf(stdout, " * Lossless\n");
#line 103
  fprintf(stdout, " * 1 tile\n");
#line 104
  fprintf(stdout, " * RGB->YCC conversion if at least 3 components\n\220");
#line 105
  fprintf(stdout, " * Size of precinct : 2^15 x 2^15 (means 1 precinct)\n");
#line 106
  fprintf(stdout, " * Size of code-block : 64 x 64\n\220");
#line 107
  fprintf(stdout, " * Number of resolutions: 6\n\317\v");
#line 108
  fprintf(stdout, " * No SOP marker in the codestream\n");
#line 109
  fprintf(stdout, " * No EPH marker in the codestream\n");
#line 110
  fprintf(stdout, " * No sub-sampling in x or y direction\n");
#line 111
  fprintf(stdout, " * No mode switch activated\n\342");
#line 112
  fprintf(stdout, " * Progression order: LRCP\n");
#line 116
  fprintf(stdout, " * No ROI upshifted\n\002");
#line 117
  fprintf(stdout, " * No offset of the origin of the image\n\220");
#line 118
  fprintf(stdout, " * No offset of the origin of the tiles\n\220");
#line 119
  fprintf(stdout, " * Reversible DWT 5-3\n");
#line 125
  fprintf(stdout, "\n");
#line 127
  fprintf(stdout, "Note:\n");
#line 128
  fprintf(stdout, "-----\n");
#line 129
  fprintf(stdout, "\n\320");
#line 130
  fprintf(stdout, "The markers written to the main_header are : SOC SIZ COD QCD COM.\n");
#line 132
  fprintf(stdout, "COD and QCD never appear in the tile_header.\n");
#line 133
  fprintf(stdout, "\n");
#line 135
  fprintf(stdout, "Parameters:\n\002");
#line 136
  fprintf(stdout, "-----------\nH");
#line 137
  fprintf(stdout, "\n");
#line 138
  fprintf(stdout, "Required Parameters (except with -h):\n");
#line 139
  fprintf(stdout, "One of the two options -ImgDir or -i must be used\n");
#line 140
  fprintf(stdout, "\n");
#line 141
  fprintf(stdout, "-i <file>\n");
#line 142
  fprintf(stdout, "    Input file\n");
#line 143
  fprintf(stdout, "    Known extensions are <PBM|PGM|PPM|PNM|PAM|PGX|PNG|BMP|TIF|RAW|RAWL|TGA>\n");
#line 145
  fprintf(stdout, "    If used, \'-o <file>\' must be provided\n");
#line 146
  fprintf(stdout, "-o <compressed file>\n");
#line 147
  fprintf(stdout, "    Output file (accepted extensions are j2k or jp2).\n");
#line 148
  fprintf(stdout, "-ImgDir <dir>\n");
#line 149
  fprintf(stdout, "    Image file Directory path (example ../Images) \n");
#line 150
  fprintf(stdout, "    When using this option -OutFor must be used\n\220");
#line 151
  fprintf(stdout, "-OutFor <J2K|J2C|JP2>\n");
#line 152
  fprintf(stdout, "    Output format for compressed files.\n\220");
#line 153
  fprintf(stdout, "    Required only if -ImgDir is used\n");
#line 154
  fprintf(stdout, "-F <width>,<height>,<ncomp>,<bitdepth>,{s,u}@<dx1>x<dy1>:...:<dxn>x<dyn>\n");
#line 156
  fprintf(stdout, "    Characteristics of the raw input image\n");
#line 157
  fprintf(stdout, "    If subsampling is omitted, 1x1 is assumed for all components\n");
#line 159
  fprintf(stdout, "      Example: -F 512,512,3,8,u@1x1:2x2:2x2\n");
#line 160
  fprintf(stdout, "               for raw 512x512 image with 4:2:0 subsampling\n");
#line 162
  fprintf(stdout, "    Required only if RAW or RAWL input file is provided.\n");
#line 163
  fprintf(stdout, "\n");
#line 164
  fprintf(stdout, "Optional Parameters:\n");
#line 165
  fprintf(stdout, "\n");
#line 166
  fprintf(stdout, "-h\n");
#line 167
  fprintf(stdout, "    Display the help information.\n");
#line 168
  fprintf(stdout, "-r <compression ratio>,<compression ratio>,...\n");
#line 169
  fprintf(stdout, "    Different compression ratios for successive layers.\n\220");
#line 170
  fprintf(stdout, "    The rate specified for each quality level is the desired\n");
#line 172
  fprintf(stdout, "    compression factor (use 1 for lossless)\n");
#line 173
  fprintf(stdout, "    Decreasing ratios required.\n\220");
#line 174
  fprintf(stdout, "      Example: -r 20,10,1 means \n");
#line 175
  fprintf(stdout, "            quality layer 1: compress 20x, \n");
#line 176
  fprintf(stdout, "            quality layer 2: compress 10x \n");
#line 177
  fprintf(stdout, "            quality layer 3: compress lossless\n");
#line 178
  fprintf(stdout, "    Options -r and -q cannot be used together.\n");
#line 179
  fprintf(stdout, "-q <psnr value>,<psnr value>,<psnr value>,...\n");
#line 180
  fprintf(stdout, "    Different psnr for successive layers (-q 30,40,50).\n\220");
#line 181
  fprintf(stdout, "    Increasing PSNR values required, except 0 which can\n\220");
#line 182
  fprintf(stdout, "    be used for the last layer to indicate it is lossless.\n");
#line 183
  fprintf(stdout, "    Options -r and -q cannot be used together.\n");
#line 184
  fprintf(stdout, "-n <number of resolutions>\n");
#line 185
  fprintf(stdout, "    Number of resolutions.\n");
#line 186
  fprintf(stdout, "    It corresponds to the number of DWT decompositions +1. \n");
#line 188
  fprintf(stdout, "    Default: 6.\n\220");
#line 189
  fprintf(stdout, "-b <cblk width>,<cblk height>\n");
#line 190
  fprintf(stdout, "    Code-block size. The dimension must respect the constraint \n\220");
#line 192
  fprintf(stdout, "    defined in the JPEG-2000 standard (no dimension smaller than 4 \n");
#line 194
  fprintf(stdout, "    or greater than 1024, no code-block with more than 4096 coefficients).\n");
#line 196
  fprintf(stdout, "    The maximum value authorized is 64x64. \n");
#line 197
  fprintf(stdout, "    Default: 64x64.\n");
#line 198
  fprintf(stdout, "-c [<prec width>,<prec height>],[<prec width>,<prec height>],...\n");
#line 200
  fprintf(stdout, "    Precinct size. Values specified must be power of 2. \n");
#line 201
  fprintf(stdout, "    Multiple records may be supplied, in which case the first record refers\n");
#line 203
  fprintf(stdout, "    to the highest resolution level and subsequent records to lower \n");
#line 205
  fprintf(stdout, "    resolution levels. The last specified record is halved successively for each \n");
#line 207
  fprintf(stdout, "    remaining lower resolution levels.\n");
#line 208
  fprintf(stdout, "    Default: 2^15x2^15 at each resolution.\n");
#line 209
  fprintf(stdout, "-t <tile width>,<tile height>\n");
#line 210
  fprintf(stdout, "    Tile size.\n");
#line 211
  fprintf(stdout, "    Default: the dimension of the whole image, thus only one tile.\n");
#line 213
  fprintf(stdout, "-p <LRCP|RLCP|RPCL|PCRL|CPRL>\n");
#line 214
  fprintf(stdout, "    Progression order.\n");
#line 215
  fprintf(stdout, "    Default: LRCP.\n");
#line 216
  fprintf(stdout, "-s  <subX,subY>\n\220");
#line 217
  fprintf(stdout, "    Subsampling factor.\n\220");
#line 218
  fprintf(stdout, "    Subsampling bigger than 2 can produce error\n\220");
#line 219
  fprintf(stdout, "    Default: no subsampling.\n");
#line 220
  fprintf(stdout, "-POC <progression order change>/<progression order change>/...\n");
#line 222
  fprintf(stdout, "    Progression order change.\n");
#line 223
  fprintf(stdout, "    The syntax of a progression order change is the following:\n");
#line 225
  fprintf(stdout, "    T<tile>=<resStart>,<compStart>,<layerEnd>,<resEnd>,<compEnd>,<progOrder>\n");
#line 227
  fprintf(stdout, "      Example: -POC T1=0,0,1,5,3,CPRL/T1=5,0,1,6,3,CPRL\n\220");
#line 228
  fprintf(stdout, "-SOP\n");
#line 229
  fprintf(stdout, "    Write SOP marker before each packet.\n");
#line 230
  fprintf(stdout, "-EPH\n");
#line 231
  fprintf(stdout, "    Write EPH marker after each header packet.\n");
#line 232
  fprintf(stdout, "-PLT\n");
#line 233
  fprintf(stdout, "    Write PLT marker in tile-part header.\n");
#line 234
  fprintf(stdout, "-M <key value>\n");
#line 235
  fprintf(stdout, "    Mode switch.\n");
#line 236
  fprintf(stdout, "    [1=BYPASS(LAZY) 2=RESET 4=RESTART(TERMALL)\n");
#line 237
  fprintf(stdout, "    8=VSC 16=ERTERM(SEGTERM) 32=SEGMARK(SEGSYM)]\n");
#line 238
  fprintf(stdout, "    Indicate multiple modes by adding their values.\n");
#line 239
  fprintf(stdout, "      Example: RESTART(4) + RESET(2) + SEGMARK(32) => -M 38\n");
#line 241
  fprintf(stdout, "-TP <R|L|C>\n");
#line 242
  fprintf(stdout, "    Divide packets of every tile into tile-parts.\n");
#line 243
  fprintf(stdout, "    Division is made by grouping Resolutions (R), Layers (L)\n");
#line 245
  fprintf(stdout, "    or Components (C).\n");
#line 250
  fprintf(stdout, "-ROI c=<component index>,U=<upshifting value>\n");
#line 251
  fprintf(stdout, "    Quantization indices upshifted for a component. \n");
#line 252
  fprintf(stdout, "    Warning: This option does not implement the usual ROI (Region of Interest).\n\220");
#line 254
  fprintf(stdout, "    It should be understood as a \'Component of Interest\'. It offers the \n");
#line 256
  fprintf(stdout, "    possibility to upshift the value of a component during quantization step.\n");
#line 258
  fprintf(stdout, "    The value after c= is the component number [0, 1, 2, ...] and the value \n");
#line 260
  fprintf(stdout, "    after U= is the value of upshifting. U must be in the range [0, 37].\n");
#line 262
  fprintf(stdout, "-d <image offset X,image offset Y>\n");
#line 263
  fprintf(stdout, "    Offset of the origin of the image.\n");
#line 264
  fprintf(stdout, "-T <tile offset X,tile offset Y>\n");
#line 265
  fprintf(stdout, "    Offset of the origin of the tiles.\n");
#line 266
  fprintf(stdout, "-I\n");
#line 267
  fprintf(stdout, "    Use the irreversible DWT 9-7.\n");
#line 268
  fprintf(stdout, "-mct <0|1|2>\n");
#line 269
  fprintf(stdout, "    Explicitly specifies if a Multiple Component Transform has to be used.\n");
#line 271
  fprintf(stdout, "    0: no MCT ; 1: RGB->YCC conversion ; 2: custom MCT.\n\220");
#line 272
  fprintf(stdout, "    If custom MCT, \"-m\" option has to be used (see hereunder).\n");
#line 274
  fprintf(stdout, "    By default, RGB->YCC conversion is used if there are 3 components or more,\n");
#line 276
  fprintf(stdout, "    no conversion otherwise.\n");
#line 277
  fprintf(stdout, "-m <file>\n");
#line 278
  fprintf(stdout, "    Use array-based MCT, values are coma separated, line by line\n");
#line 280
  fprintf(stdout, "    No specific separators between lines, no space allowed between values.\n");
#line 282
  fprintf(stdout, "    If this option is used, it automatically sets \"-mct\" option to 2.\n");
#line 284
  fprintf(stdout, "-cinema2K <24|48>\n");
#line 285
  fprintf(stdout, "    Digital Cinema 2K profile compliant codestream.\n");
#line 286
  fprintf(stdout, "\tNeed to specify the frames per second for a 2K resolution.\n");
#line 288
  fprintf(stdout, "    Only 24 or 48 fps are currently allowed.\n");
#line 289
  fprintf(stdout, "-cinema4K\n");
#line 290
  fprintf(stdout, "    Digital Cinema 4K profile compliant codestream.\n");
#line 291
  fprintf(stdout, "\tFrames per second not required. Default value is 24fps.\n");
#line 292
  fprintf(stdout, "-IMF <PROFILE>[,mainlevel=X][,sublevel=Y][,framerate=FPS]\n");
#line 293
  fprintf(stdout, "    Interoperable Master Format compliant codestream.\n");
#line 294
  fprintf(stdout, "    <PROFILE>=2K, 4K, 8K, 2K_R, 4K_R or 8K_R.\n");
#line 295
  fprintf(stdout, "    X >= 0 and X <= 11.\n\220");
#line 296
  fprintf(stdout, "    Y >= 0 and Y <= 9.\n");
#line 297
  fprintf(stdout, "    framerate > 0 may be specified to enhance checks and set maximum bit rate when Y > 0.\n");
#line 299
  fprintf(stdout, "-jpip\n");
#line 300
  fprintf(stdout, "    Write jpip codestream index box in JP2 output file.\n\220");
#line 301
  fprintf(stdout, "    Currently supports only RPCL order.\n\220");
#line 302
  fprintf(stdout, "-C <comment>\n");
#line 303
  fprintf(stdout, "    Add <comment> in the comment marker segment.\n");
#line 304
  __cil_tmp2___20 = opj_has_thread_support();
  }
#line 304
  if (__cil_tmp2___20) {
    {
#line 305
    fprintf(stdout, "  -threads <num_threads|ALL_CPUS>\n    Number of threads to use for encoding or ALL_CPUS for all available cores.\n");
    }
  }
  {
#line 396
  fprintf(stdout, "\n");
  }
#line 398
  return;
}
}
#line 441 "/root/patron-new/39/src/bin/jp2/opj_compress.c"
static OPJ_PROG_ORDER give_progression(char const   *progression ) 
{ 
  int __cil_tmp2___21 ;
  int __cil_tmp3___38 ;
  int __cil_tmp4___29 ;
  int __cil_tmp5___51 ;
  int __cil_tmp6___60 ;

  {
  {
#line 443
  __cil_tmp2___21 = strncmp(progression, "LRCP", 4UL);
  }
#line 443
  if (__cil_tmp2___21 == 0) {
#line 444
    return ((OPJ_PROG_ORDER )0);
  }
  {
#line 446
  __cil_tmp3___38 = strncmp(progression, "RLCP", 4UL);
  }
#line 446
  if (__cil_tmp3___38 == 0) {
#line 447
    return ((OPJ_PROG_ORDER )1);
  }
  {
#line 449
  __cil_tmp4___29 = strncmp(progression, "RPCL", 4UL);
  }
#line 449
  if (__cil_tmp4___29 == 0) {
#line 450
    return ((OPJ_PROG_ORDER )2);
  }
  {
#line 452
  __cil_tmp5___51 = strncmp(progression, "PCRL", 4UL);
  }
#line 452
  if (__cil_tmp5___51 == 0) {
#line 453
    return ((OPJ_PROG_ORDER )3);
  }
  {
#line 455
  __cil_tmp6___60 = strncmp(progression, "CPRL", 4UL);
  }
#line 455
  if (__cil_tmp6___60 == 0) {
#line 456
    return ((OPJ_PROG_ORDER )4);
  }
#line 459
  return ((OPJ_PROG_ORDER )-1);
}
}
#line 462 "/root/patron-new/39/src/bin/jp2/opj_compress.c"
static unsigned int get_num_images(char *imgdirpath ) 
{ 
  DIR *dir ;
  struct dirent *content ;
  unsigned int num_images ;
  int __cil_tmp7___57 ;
  int __cil_tmp8___76 ;

  {
  {
#line 466
  num_images = 0U;
#line 470
  dir = opendir((char const   *)imgdirpath);
  }
#line 471
  if (! dir) {
    {
#line 472
    fprintf(stderr, "Could not open Folder %s\n", imgdirpath);
    }
#line 473
    return (0U);
  }
#line 476
  num_images = 0U;
  {
#line 477
  while (1) {
    while_continue___0: /* CIL Label */ ;

    while_continue: 
    {
#line 477
    content = readdir(dir);
    }
#line 477
    if (! ((unsigned long )content != (unsigned long )((void *)0))) {
#line 477
      goto while_break;
    }
    {
#line 478
    __cil_tmp8___76 = strcmp("..", (char const   *)(content->d_name));
#line 478
    __cil_tmp7___57 = strcmp(".", (char const   *)(content->d_name));
    }
#line 478
    if (__cil_tmp7___57 == 0) {
#line 479
      goto while_continue;
    } else
#line 478
    if (__cil_tmp8___76 == 0) {
#line 479
      goto while_continue;
    }
#line 481
    num_images ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: 
  {
#line 483
  closedir(dir);
  }
#line 484
  return (num_images);
}
}
#line 487 "/root/patron-new/39/src/bin/jp2/opj_compress.c"
static int load_images(dircnt_t *dirptr , char *imgdirpath___0 ) 
{ 
  DIR *dir___0 ;
  struct dirent *content___0 ;
  int i___151 ;
  int __cil_tmp8___77 ;
  int __cil_tmp9___47 ;

  {
  {
#line 491
  i___151 = 0;
#line 495
  dir___0 = opendir((char const   *)imgdirpath___0);
  }
#line 496
  if (! dir___0) {
    {
#line 497
    fprintf(stderr, "Could not open Folder %s\n", imgdirpath___0);
    }
#line 498
    return (1);
  } else {
    {
#line 500
    fprintf(stderr, "Folder opened successfully\n");
    }
  }
  {
#line 503
  while (1) {
    while_continue___0: /* CIL Label */ ;

    while_continue: 
    {
#line 503
    content___0 = readdir(dir___0);
    }
#line 503
    if (! ((unsigned long )content___0 != (unsigned long )((void *)0))) {
#line 503
      goto while_break;
    }
    {
#line 504
    __cil_tmp9___47 = strcmp("..", (char const   *)(content___0->d_name));
#line 504
    __cil_tmp8___77 = strcmp(".", (char const   *)(content___0->d_name));
    }
#line 504
    if (__cil_tmp8___77 == 0) {
#line 505
      goto while_continue;
    } else
#line 504
    if (__cil_tmp9___47 == 0) {
#line 505
      goto while_continue;
    }
    {
#line 508
    strcpy(*(dirptr->filename + i___151), (char const   *)(content___0->d_name));
#line 509
    i___151 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: 
  {
#line 511
  closedir(dir___0);
  }
#line 512
  return (0);
}
}
#line 518 "/root/patron-new/39/src/bin/jp2/opj_compress.c"
static char const   *extension[16]  ;
#line 519 "/root/patron-new/39/src/bin/jp2/opj_compress.c"
static int const   format___1[16]  ;
#line 515 "/root/patron-new/39/src/bin/jp2/opj_compress.c"
static int get_file_format(char *filename___7 ) 
{ 
  unsigned int i___152 ;
  char *ext ;
  char *__cil_tmp6___63 ;
  int __cil_tmp8___78 ;

  {
  {
#line 518
  strcpy((char *)extension[0], "pgx\006]U");
#line 518
  strcpy((char *)extension[1], "pnm");
#line 518
  strcpy((char *)extension[2], "pgm");
#line 518
  strcpy((char *)extension[3], "ppm");
#line 518
  strcpy((char *)extension[4], "pbm");
#line 518
  strcpy((char *)extension[5], "pam\006]U");
#line 518
  strcpy((char *)extension[6], "bmp");
#line 518
  strcpy((char *)extension[7], "tif\006]U");
#line 518
  strcpy((char *)extension[8], "raw");
#line 518
  strcpy((char *)extension[9], "rawl]U");
#line 518
  strcpy((char *)extension[10], "tga\006]U");
#line 518
  strcpy((char *)extension[11], "png\006]U");
#line 518
  strcpy((char *)extension[12], "j2k\006]U");
#line 518
  strcpy((char *)extension[13], "jp2\006]U");
#line 518
  strcpy((char *)extension[14], "j2c\006]U");
#line 518
  strcpy((char *)extension[15], "jpc\006]U");
#line 521
  format___1[0] = (int const   )11;
#line 521
  format___1[1] = (int const   )10;
#line 521
  format___1[2] = (int const   )10;
#line 521
  format___1[3] = (int const   )10;
#line 521
  format___1[4] = (int const   )10;
#line 521
  format___1[5] = (int const   )10;
#line 521
  format___1[6] = (int const   )12;
#line 521
  format___1[7] = (int const   )14;
#line 521
  format___1[8] = (int const   )15;
#line 521
  format___1[9] = (int const   )18;
#line 521
  format___1[10] = (int const   )16;
#line 521
  format___1[11] = (int const   )17;
#line 521
  format___1[12] = (int const   )0;
#line 521
  format___1[13] = (int const   )1;
#line 521
  format___1[14] = (int const   )0;
#line 521
  format___1[15] = (int const   )0;
#line 524
  __cil_tmp6___63 = strrchr((char const   *)filename___7, '.');
#line 524
  ext = __cil_tmp6___63;
  }
#line 525
  if ((unsigned long )ext == (unsigned long )((void *)0)) {
#line 526
    return (-1);
  }
#line 528
  ext ++;
#line 529
  i___152 = 0U;
  {
#line 529
  while (1) {
    while_continue: /* CIL Label */ ;

#line 529
    if (! ((unsigned long )i___152 < sizeof(format___1) / sizeof(format___1[0]))) {
#line 529
      goto while_break;
    }
    {
#line 530
    __cil_tmp8___78 = strcasecmp((char const   *)ext, extension[i___152]);
    }
#line 530
    if (__cil_tmp8___78 == 0) {
#line 531
      return ((int )format___1[i___152]);
    }
#line 529
    i___152 ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 534
  return (-1);
}
}
#line 537 "/root/patron-new/39/src/bin/jp2/opj_compress.c"
static char *get_file_name(char *name___0 ) 
{ 
  char *fname___1 ;
  char *__cil_tmp3___39 ;

  {
  {
#line 539
  __cil_tmp3___39 = strtok(name___0, ".u\337\006]U");
#line 539
  fname___1 = __cil_tmp3___39;
  }
#line 540
  return (fname___1);
}
}
#line 543 "/root/patron-new/39/src/bin/jp2/opj_compress.c"
static char get_next_file(int imageno , dircnt_t *dirptr___0 , img_fol_t *img_fol ,
                          opj_cparameters_t *parameters___20 ) 
{ 
  char image_filename[4096] ;
  char infilename[4096] ;
  char outfilename[4096] ;
  char temp_ofname[4096] ;
  char *temp_p ;
  char temp1___0[4096] ;
  int __cil_tmp12___48 ;
  char *__cil_tmp13___50 ;
  int __cil_tmp15___44 ;

  {
  {
#line 548
  __asm__  ("booo_exp(/root/patron-new/39/src/bin/jp2/opj_compress.c:548)":);
#line 550
  strcpy(image_filename, (char const   *)*(dirptr___0->filename + imageno));
#line 551
  fprintf(stderr, "File Number %d \"%s\"\n]U", imageno, image_filename);
#line 552
  parameters___20->decod_format = get_file_format(image_filename);
  }
#line 553
  if (parameters___20->decod_format == -1) {
#line 554
    return ((char)1);
  }
  {
#line 556
  sprintf(infilename, "%s/%sU", img_fol->imgdirpath, image_filename);
#line 557
  __cil_tmp12___48 = opj_strcpy_s(parameters___20->infile, sizeof(parameters___20->infile),
                                  (char const   *)(infilename));
  }
#line 557
  if (__cil_tmp12___48 != 0) {
#line 559
    return ((char)1);
  }
  {
#line 563
  __cil_tmp13___50 = get_file_name(image_filename);
#line 563
  strcpy(temp_ofname, (char const   *)__cil_tmp13___50);
  }
  {
#line 564
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 564
    temp_p = strtok((char *)((void *)0), ".");
    }
#line 564
    if (! ((unsigned long )temp_p != (unsigned long )((void *)0))) {
#line 564
      goto while_break;
    }
    {
#line 565
    strcat(temp_ofname, (char const   *)(temp1___0));
#line 566
    sprintf(temp1___0, ".%s", temp_p);
    }
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 568
  if ((int )img_fol->set_out_format == 1) {
    {
#line 569
    sprintf(outfilename, "%s/%s.%s", img_fol->imgdirpath, temp_ofname, img_fol->out_format);
#line 571
    __cil_tmp15___44 = opj_strcpy_s(parameters___20->outfile, sizeof(parameters___20->outfile),
                                    (char const   *)(outfilename));
    }
#line 571
    if (__cil_tmp15___44 != 0) {
#line 573
      return ((char)1);
    }
  }
#line 576
  return ((char)0);
}
}
#line 581 "/root/patron-new/39/src/bin/jp2/opj_compress.c"
static int parse_cmdline_encoder(int argc , char **argv , opj_cparameters_t *parameters___21 ,
                                 img_fol_t *img_fol___0 , raw_cparameters_t *raw_cp___2 ,
                                 char *indexfilename , size_t indexfilename_size ,
                                 int *pOutFramerate , OPJ_BOOL *pOutPLT , int *pOutNumThreads ) 
{ 
  OPJ_UINT32 i___153 ;
  OPJ_UINT32 j___21 ;
  int totlen ;
  int c___3 ;
  opj_option_t long_option[14] ;
  char optlist[48] ;
  char *infile ;
  int __cil_tmp20___49 ;
  char *outfile___7 ;
  int __cil_tmp23___38 ;
  char outformat[50] ;
  char *of ;
  char *s___3 ;
  int __cil_tmp28___29 ;
  OPJ_BOOL wrong ;
  char *substr1 ;
  char *substr2 ;
  char *sep ;
  char signo ;
  int width___14 ;
  int height___13 ;
  int bitdepth ;
  int ncomp___0 ;
  OPJ_UINT32 len___10 ;
  OPJ_BOOL raw_signed ;
  unsigned long __cil_tmp44___12 ;
  void *__cil_tmp46___4 ;
  int __cil_tmp47___7 ;
  int compno___20 ;
  int lastdx ;
  int lastdy ;
  void *__cil_tmp51___8 ;
  int dx ;
  int dy ;
  int __cil_tmp55___5 ;
  int __cil_tmp56___5 ;
  char *s___4 ;
  int __cil_tmp59___4 ;
  int *row___0 ;
  int *col ;
  OPJ_UINT32 numlayers ;
  OPJ_UINT32 numresolution ;
  OPJ_UINT32 matrix_width ;
  char *s___5 ;
  void *__cil_tmp71___0 ;
  char sep___0 ;
  int res_spec___0 ;
  char *s___6 ;
  int ret___2 ;
  char *__cil_tmp85___1 ;
  int cblockw_init ;
  int cblockh_init ;
  int __cil_tmp88___0 ;
  char progression___0[4] ;
  int __cil_tmp91___1 ;
  int __cil_tmp92 ;
  int numpocs ;
  opj_poc_t *POC___0 ;
  char *s___7 ;
  int __cil_tmp96 ;
  int value___5 ;
  int __cil_tmp102 ;
  int cache ;
  int __cil_tmp105___0 ;
  int __cil_tmp106___0 ;
  unsigned long __cil_tmp107___0 ;
  void *__cil_tmp108___0 ;
  unsigned long __cil_tmp109___0 ;
  void *__cil_tmp110___0 ;
  int fps ;
  int mainlevel___0 ;
  int sublevel___0 ;
  int profile___2 ;
  int framerate ;
  char const   *msg___0 ;
  char *comma ;
  int __cil_tmp119 ;
  int __cil_tmp121 ;
  int __cil_tmp123 ;
  int __cil_tmp125 ;
  int __cil_tmp126 ;
  int __cil_tmp127 ;
  int __cil_tmp128 ;
  int __cil_tmp129 ;
  int __cil_tmp130 ;
  int limitMBitsSec[10] ;
  int mct_mode ;
  char *lFilename ;
  char *lMatrix ;
  char *lCurrentPtr___1 ;
  float *lCurrentDoublePtr ;
  float *lSpace ;
  int *l_int_ptr ;
  int lNbComp ;
  int lTotalComp ;
  int lMctComp ;
  int i2 ;
  size_t lStrLen ;
  size_t lStrFread ;
  FILE *lFile ;
  FILE *__cil_tmp146 ;
  long __cil_tmp147 ;
  void *__cil_tmp148 ;
  double __cil_tmp150 ;
  void *__cil_tmp151 ;
  unsigned long __cil_tmp152 ;
  float *__cil_tmp153 ;
  double __cil_tmp154 ;
  unsigned long __cil_tmp155 ;
  int *__cil_tmp156 ;
  int __cil_tmp158 ;

  {
  {
#line 591
  strcpy((char *)long_option[0].name, "cinema2K\251");
#line 591
  long_option[0].has_arg = 1;
#line 591
  long_option[0].flag = (int *)((void *)0);
#line 591
  long_option[0].val = 'w';
#line 591
  strcpy((char *)long_option[1].name, "cinema4K\251");
#line 591
  long_option[1].has_arg = 0;
#line 591
  long_option[1].flag = (int *)((void *)0);
#line 591
  long_option[1].val = 'y';
#line 591
  strcpy((char *)long_option[2].name, "ImgDir");
#line 591
  long_option[2].has_arg = 1;
#line 591
  long_option[2].flag = (int *)((void *)0);
#line 591
  long_option[2].val = 'z';
#line 591
  strcpy((char *)long_option[3].name, "TP");
#line 591
  long_option[3].has_arg = 1;
#line 591
  long_option[3].flag = (int *)((void *)0);
#line 591
  long_option[3].val = 'u';
#line 591
  strcpy((char *)long_option[4].name, "SOP");
#line 591
  long_option[4].has_arg = 0;
#line 591
  long_option[4].flag = (int *)((void *)0);
#line 591
  long_option[4].val = 'S';
#line 591
  strcpy((char *)long_option[5].name, "EPH");
#line 591
  long_option[5].has_arg = 0;
#line 591
  long_option[5].flag = (int *)((void *)0);
#line 591
  long_option[5].val = 'E';
#line 591
  strcpy((char *)long_option[6].name, "OutFor");
#line 591
  long_option[6].has_arg = 1;
#line 591
  long_option[6].flag = (int *)((void *)0);
#line 591
  long_option[6].val = 'O';
#line 591
  strcpy((char *)long_option[7].name, "POC");
#line 591
  long_option[7].has_arg = 1;
#line 591
  long_option[7].flag = (int *)((void *)0);
#line 591
  long_option[7].val = 'P';
#line 591
  strcpy((char *)long_option[8].name, "ROI");
#line 591
  long_option[8].has_arg = 1;
#line 591
  long_option[8].flag = (int *)((void *)0);
#line 591
  long_option[8].val = 'R';
#line 591
  strcpy((char *)long_option[9].name, "jpip");
#line 591
  long_option[9].has_arg = 0;
#line 591
  long_option[9].flag = (int *)((void *)0);
#line 591
  long_option[9].val = 'J';
#line 591
  strcpy((char *)long_option[10].name, "mct");
#line 591
  long_option[10].has_arg = 1;
#line 591
  long_option[10].flag = (int *)((void *)0);
#line 591
  long_option[10].val = 'Y';
#line 591
  strcpy((char *)long_option[11].name, "IMF");
#line 591
  long_option[11].has_arg = 1;
#line 591
  long_option[11].flag = (int *)((void *)0);
#line 591
  long_option[11].val = 'Z';
#line 591
  strcpy((char *)long_option[12].name, "PLT");
#line 591
  long_option[12].has_arg = 0;
#line 591
  long_option[12].flag = (int *)((void *)0);
#line 591
  long_option[12].val = 'A';
#line 591
  strcpy((char *)long_option[13].name, "threads");
#line 591
  long_option[13].has_arg = 1;
#line 591
  long_option[13].flag = (int *)((void *)0);
#line 591
  long_option[13].val = 'B';
#line 609
  __asm__  ("booo_exp(/root/patron-new/39/src/bin/jp2/opj_compress.c:609)":);
#line 615
  totlen = (int )sizeof(long_option);
#line 616
  img_fol___0->set_out_format = (char)0;
#line 617
  raw_cp___2->rawWidth = 0;
  }
  {
#line 619
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 620
    c___3 = opj_getopt_long(argc, (char * const  *)argv, (char const   *)(optlist),
                            long_option, totlen);
    }
#line 621
    if (c___3 == -1) {
#line 622
      goto while_break;
    }
#line 625
    if (c___3 == 105) {
#line 625
      goto case_105;
    }
#line 636
    if (c___3 == 17) {
#line 636
      goto case_17;
    }
#line 636
    if (c___3 == 16) {
#line 636
      goto case_17;
    }
#line 636
    if (c___3 == 18) {
#line 636
      goto case_17;
    }
#line 636
    if (c___3 == 15) {
#line 636
      goto case_17;
    }
#line 636
    if (c___3 == 14) {
#line 636
      goto case_17;
    }
#line 636
    if (c___3 == 12) {
#line 636
      goto case_17;
    }
#line 636
    if (c___3 == 10) {
#line 636
      goto case_17;
    }
#line 636
    if (c___3 == 11) {
#line 636
      goto case_17;
    }
#line 653
    if (c___3 == 111) {
#line 653
      goto case_111;
    }
#line 658
    if (c___3 == 1) {
#line 658
      goto case_1;
    }
#line 658
    if (c___3 == 0) {
#line 658
      goto case_1;
    }
#line 673
    if (c___3 == 79) {
#line 673
      goto case_79;
    }
#line 681
    if (c___3 == 1) {
#line 681
      goto case_1___0;
    }
#line 681
    if (c___3 == 0) {
#line 681
      goto case_1___0;
    }
#line 695
    if (c___3 == 114) {
#line 695
      goto case_114;
    }
#line 716
    if (c___3 == 70) {
#line 716
      goto case_70;
    }
#line 812
    if (c___3 == 113) {
#line 812
      goto case_113;
    }
#line 832
    if (c___3 == 102) {
#line 832
      goto case_102;
    }
#line 887
    if (c___3 == 116) {
#line 887
      goto case_116;
    }
#line 895
    if (c___3 == 110) {
#line 895
      goto case_110;
    }
#line 901
    if (c___3 == 99) {
#line 901
      goto case_99;
    }
#line 927
    if (c___3 == 98) {
#line 927
      goto case_98;
    }
#line 945
    if (c___3 == 120) {
#line 945
      goto case_120;
    }
#line 959
    if (c___3 == 112) {
#line 959
      goto case_112;
    }
#line 974
    if (c___3 == 115) {
#line 974
      goto case_115;
    }
#line 985
    if (c___3 == 100) {
#line 985
      goto case_100;
    }
#line 997
    if (c___3 == 104) {
#line 997
      goto case_104;
    }
#line 1003
    if (c___3 == 80) {
#line 1003
      goto case_80;
    }
#line 1030
    if (c___3 == 83) {
#line 1030
      goto case_83;
    }
#line 1037
    if (c___3 == 69) {
#line 1037
      goto case_69;
    }
#line 1044
    if (c___3 == 77) {
#line 1044
      goto case_77;
    }
#line 1059
    if (c___3 == 82) {
#line 1059
      goto case_82;
    }
#line 1070
    if (c___3 == 84) {
#line 1070
      goto case_84;
    }
#line 1081
    if (c___3 == 67) {
#line 1081
      goto case_67;
    }
#line 1092
    if (c___3 == 73) {
#line 1092
      goto case_73;
    }
#line 1099
    if (c___3 == 117) {
#line 1099
      goto case_117;
    }
#line 1107
    if (c___3 == 122) {
#line 1107
      goto case_122;
    }
#line 1119
    if (c___3 == 119) {
#line 1119
      goto case_119;
    }
#line 1142
    if (c___3 == 121) {
#line 1142
      goto case_121;
    }
#line 1151
    if (c___3 == 90) {
#line 1151
      goto case_90;
    }
#line 1243
    if (c___3 == 89) {
#line 1243
      goto case_89;
    }
#line 1258
    if (c___3 == 109) {
#line 1258
      goto case_109;
    }
#line 1677
    if (c___3 == 74) {
#line 1677
      goto case_74;
    }
#line 1683
    if (c___3 == 65) {
#line 1683
      goto case_65;
    }
#line 1689
    if (c___3 == 66) {
#line 1689
      goto case_66;
    }
#line 1704
    goto switch_default___2;
    case_105: 
    {
#line 626
    infile = opj_optarg;
#line 627
    parameters___21->decod_format = get_file_format(infile);
    }
#line 636
    if (parameters___21->decod_format == 17) {
#line 636
      goto case_17;
    }
#line 636
    if (parameters___21->decod_format == 16) {
#line 636
      goto case_17;
    }
#line 636
    if (parameters___21->decod_format == 18) {
#line 636
      goto case_17;
    }
#line 636
    if (parameters___21->decod_format == 15) {
#line 636
      goto case_17;
    }
#line 636
    if (parameters___21->decod_format == 14) {
#line 636
      goto case_17;
    }
#line 636
    if (parameters___21->decod_format == 12) {
#line 636
      goto case_17;
    }
#line 636
    if (parameters___21->decod_format == 10) {
#line 636
      goto case_17;
    }
#line 636
    if (parameters___21->decod_format == 11) {
#line 636
      goto case_17;
    }
#line 638
    goto switch_default;
    case_17: 
#line 637
    goto switch_break___0;
    switch_default: 
    {
#line 639
    fprintf(stderr, "[ERROR] Unknown input file format: %s \n        Known file formats are *.pnm, *.pgm, *.ppm, *.pgx, *png, *.bmp, *.tif, *.raw or *.tga\n\203\337\006]U",
            infile);
    }
#line 643
    return (1);
    switch_break___0: 
    {
#line 645
    __cil_tmp20___49 = opj_strcpy_s(parameters___21->infile, sizeof(parameters___21->infile),
                                    (char const   *)infile);
    }
#line 645
    if (__cil_tmp20___49 != 0) {
#line 646
      return (1);
    }
#line 649
    goto switch_break;
    case_111: 
    {
#line 654
    outfile___7 = opj_optarg;
#line 655
    parameters___21->cod_format = get_file_format(outfile___7);
    }
#line 658
    if (parameters___21->cod_format == 1) {
#line 658
      goto case_1;
    }
#line 658
    if (parameters___21->cod_format == 0) {
#line 658
      goto case_1;
    }
#line 660
    goto switch_default___0;
    case_1: 
#line 659
    goto switch_break___1;
    switch_default___0: 
    {
#line 661
    fprintf(stderr, "Unknown output format image %s [only *.j2k, *.j2c or *.jp2]!! \n",
            outfile___7);
    }
#line 663
    return (1);
    switch_break___1: 
    {
#line 665
    __cil_tmp23___38 = opj_strcpy_s(parameters___21->outfile, sizeof(parameters___21->outfile),
                                    (char const   *)outfile___7);
    }
#line 665
    if (__cil_tmp23___38 != 0) {
#line 667
      return (1);
    }
#line 670
    goto switch_break;
    case_79: 
    {
#line 675
    of = opj_optarg;
#line 676
    sprintf(outformat, ".%s", of);
#line 677
    img_fol___0->set_out_format = (char)1;
#line 678
    parameters___21->cod_format = get_file_format(outformat);
    }
#line 681
    if (parameters___21->cod_format == 1) {
#line 681
      goto case_1___0;
    }
#line 681
    if (parameters___21->cod_format == 0) {
#line 681
      goto case_1___0;
    }
#line 684
    goto switch_default___1;
    case_1___0: 
#line 682
    img_fol___0->out_format = opj_optarg;
#line 683
    goto switch_break___2;
    switch_default___1: 
    {
#line 685
    fprintf(stderr, "Unknown output format image [only j2k, j2c, jp2]!! \n");
    }
#line 686
    return (1);
    switch_break___2: ;
#line 689
    goto switch_break;
    case_114: 
#line 696
    s___3 = opj_optarg;
#line 697
    parameters___21->tcp_numlayers = 0;
    {
#line 698
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 698
      __cil_tmp28___29 = sscanf((char const   *)s___3, "%f", & parameters___21->tcp_rates[parameters___21->tcp_numlayers]);
      }
#line 698
      if (! (__cil_tmp28___29 == 1)) {
#line 698
        goto while_break___0;
      }
#line 700
      (parameters___21->tcp_numlayers) ++;
      {
#line 701
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 701
        if ((int )*s___3) {
#line 701
          if (! ((int )*s___3 != 44)) {
#line 701
            goto while_break___1;
          }
        } else {
#line 701
          goto while_break___1;
        }
#line 702
        s___3 ++;
      }
      while_break___17: /* CIL Label */ ;
      }

      while_break___1: ;
#line 704
      if (! *s___3) {
#line 705
        goto while_break___0;
      }
#line 707
      s___3 ++;
    }
    while_break___16: /* CIL Label */ ;
    }

    while_break___0: 
#line 709
    parameters___21->cp_disto_alloc = 1;
#line 711
    goto switch_break;
    case_70: 
    {
#line 717
    wrong = 0;
#line 724
    raw_signed = 0;
#line 725
    substr2 = strchr((char const   *)opj_optarg, '@');
    }
#line 726
    if ((unsigned long )substr2 == (unsigned long )((void *)0)) {
      {
#line 727
      __cil_tmp44___12 = strlen((char const   *)opj_optarg);
#line 727
      len___10 = (OPJ_UINT32 )__cil_tmp44___12;
      }
    } else {
#line 729
      len___10 = (OPJ_UINT32 )(substr2 - opj_optarg);
#line 730
      substr2 ++;
    }
    {
#line 732
    __cil_tmp46___4 = malloc((unsigned long )(len___10 + 1U) * sizeof(char ));
#line 732
    substr1 = (char *)__cil_tmp46___4;
    }
#line 733
    if ((unsigned long )substr1 == (unsigned long )((void *)0)) {
#line 734
      return (1);
    }
    {
#line 736
    memcpy((void *)substr1, (void const   *)opj_optarg, (unsigned long )len___10);
#line 737
    *(substr1 + len___10) = (char )'\000';
#line 738
    __cil_tmp47___7 = sscanf((char const   *)substr1, "%d,%d,%d,%d,%c", & width___14,
                             & height___13, & ncomp___0, & bitdepth, & signo);
    }
#line 738
    if (__cil_tmp47___7 == 5) {
#line 740
      if ((int )signo == 115) {
#line 741
        raw_signed = 1;
      } else
#line 742
      if ((int )signo == 117) {
#line 743
        raw_signed = 0;
      } else {
#line 745
        wrong = 1;
      }
    } else {
#line 748
      wrong = 1;
    }
#line 750
    if (! wrong) {
      {
#line 752
      lastdx = 1;
#line 753
      lastdy = 1;
#line 754
      raw_cp___2->rawWidth = width___14;
#line 755
      raw_cp___2->rawHeight = height___13;
#line 756
      raw_cp___2->rawComp = ncomp___0;
#line 757
      raw_cp___2->rawBitDepth = bitdepth;
#line 758
      raw_cp___2->rawSigned = raw_signed;
#line 759
      __cil_tmp51___8 = malloc((unsigned long )((OPJ_UINT32 )ncomp___0) * sizeof(raw_comp_cparameters_t ));
#line 759
      raw_cp___2->rawComps = (raw_comp_cparameters_t *)__cil_tmp51___8;
      }
#line 761
      if ((unsigned long )raw_cp___2->rawComps == (unsigned long )((void *)0)) {
        {
#line 762
        free((void *)substr1);
        }
#line 763
        return (1);
      }
#line 765
      compno___20 = 0;
      {
#line 765
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 765
        if (compno___20 < ncomp___0) {
#line 765
          if (! (! wrong)) {
#line 765
            goto while_break___2;
          }
        } else {
#line 765
          goto while_break___2;
        }
#line 766
        if ((unsigned long )substr2 == (unsigned long )((void *)0)) {
#line 767
          (raw_cp___2->rawComps + compno___20)->dx = lastdx;
#line 768
          (raw_cp___2->rawComps + compno___20)->dy = lastdy;
        } else {
          {
#line 771
          sep = strchr((char const   *)substr2, ':');
          }
#line 772
          if ((unsigned long )sep == (unsigned long )((void *)0)) {
            {
#line 773
            __cil_tmp55___5 = sscanf((char const   *)substr2, "%dx%d", & dx, & dy);
            }
#line 773
            if (__cil_tmp55___5 == 2) {
#line 774
              lastdx = dx;
#line 775
              lastdy = dy;
#line 776
              (raw_cp___2->rawComps + compno___20)->dx = dx;
#line 777
              (raw_cp___2->rawComps + compno___20)->dy = dy;
#line 778
              substr2 = (char *)((void *)0);
            } else {
#line 780
              wrong = 1;
            }
          } else {
            {
#line 783
            __cil_tmp56___5 = sscanf((char const   *)substr2, "%dx%d:%s\230\001",
                                     & dx, & dy, substr2);
            }
#line 783
            if (__cil_tmp56___5 == 3) {
#line 784
              (raw_cp___2->rawComps + compno___20)->dx = dx;
#line 785
              (raw_cp___2->rawComps + compno___20)->dy = dy;
            } else {
#line 787
              wrong = 1;
            }
          }
        }
#line 765
        compno___20 ++;
      }
      while_break___18: /* CIL Label */ ;
      }

      while_break___2: ;
    }
    {
#line 793
    free((void *)substr1);
    }
#line 794
    if (wrong) {
      {
#line 795
      fprintf(stderr, "\nError: invalid raw image parameters\n");
#line 796
      fprintf(stderr, "Please use the Format option -F:\n");
#line 797
      fprintf(stderr, "-F <width>,<height>,<ncomp>,<bitdepth>,{s,u}@<dx1>x<dy1>:...:<dxn>x<dyn>\n");
#line 799
      fprintf(stderr, "If subsampling is omitted, 1x1 is assumed for all components\n");
#line 801
      fprintf(stderr, "Example: -i image.raw -o image.j2k -F 512,512,3,8,u@1x1:2x2:2x2\n\220");
#line 803
      fprintf(stderr, "         for raw 512x512 image with 4:2:0 subsampling\n");
#line 804
      fprintf(stderr, "Aborting.\n");
      }
#line 805
      return (1);
    }
#line 808
    goto switch_break;
    case_113: 
#line 813
    s___4 = opj_optarg;
    {
#line 814
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 814
      __cil_tmp59___4 = sscanf((char const   *)s___4, "%f", & parameters___21->tcp_distoratio[parameters___21->tcp_numlayers]);
      }
#line 814
      if (! (__cil_tmp59___4 == 1)) {
#line 814
        goto while_break___3;
      }
#line 816
      (parameters___21->tcp_numlayers) ++;
      {
#line 817
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 817
        if ((int )*s___4) {
#line 817
          if (! ((int )*s___4 != 44)) {
#line 817
            goto while_break___4;
          }
        } else {
#line 817
          goto while_break___4;
        }
#line 818
        s___4 ++;
      }
      while_break___20: /* CIL Label */ ;
      }

      while_break___4: ;
#line 820
      if (! *s___4) {
#line 821
        goto while_break___3;
      }
#line 823
      s___4 ++;
    }
    while_break___19: /* CIL Label */ ;
    }

    while_break___3: 
#line 825
    parameters___21->cp_fixed_quality = 1;
#line 827
    goto switch_break;
    case_102: 
    {
#line 833
    row___0 = (int *)((void *)0);
#line 833
    col = (int *)((void *)0);
#line 834
    numlayers = (OPJ_UINT32 )0;
#line 834
    numresolution = (OPJ_UINT32 )0;
#line 834
    matrix_width = (OPJ_UINT32 )0;
#line 836
    s___5 = opj_optarg;
#line 837
    sscanf((char const   *)s___5, "%u", & numlayers);
#line 838
    s___5 ++;
    }
#line 839
    if (numlayers > 9U) {
#line 840
      s___5 ++;
    }
    {
#line 843
    parameters___21->tcp_numlayers = (int )numlayers;
#line 844
    numresolution = (OPJ_UINT32 )parameters___21->numresolution;
#line 845
    matrix_width = numresolution * 3U;
#line 846
    __cil_tmp71___0 = malloc((sizeof(int ) * (unsigned long )numlayers) * (unsigned long )matrix_width);
#line 846
    parameters___21->cp_matrice = (int *)__cil_tmp71___0;
    }
#line 847
    if ((unsigned long )parameters___21->cp_matrice == (unsigned long )((void *)0)) {
#line 848
      return (1);
    }
#line 850
    s___5 += 2;
#line 852
    i___153 = (OPJ_UINT32 )0;
    {
#line 852
    while (1) {
      while_continue___5: /* CIL Label */ ;

#line 852
      if (! (i___153 < numlayers)) {
#line 852
        goto while_break___5;
      }
      {
#line 853
      row___0 = parameters___21->cp_matrice + i___153 * matrix_width;
#line 854
      col = row___0;
#line 855
      parameters___21->tcp_rates[i___153] = (float )1;
#line 856
      sscanf((char const   *)s___5, "%d,", col + 0);
#line 857
      s___5 += 2;
      }
#line 858
      if (*(col + 0) > 9) {
#line 859
        s___5 ++;
      }
#line 861
      *(col + 1) = 0;
#line 862
      *(col + 2) = 0;
#line 863
      j___21 = (OPJ_UINT32 )1;
      {
#line 863
      while (1) {
        while_continue___6: /* CIL Label */ ;

#line 863
        if (! (j___21 < numresolution)) {
#line 863
          goto while_break___6;
        }
        {
#line 864
        col += 3;
#line 865
        sscanf((char const   *)s___5, "%d,%d,%d\230\001", col + 0, col + 1, col + 2);
#line 866
        s___5 += 6;
        }
#line 867
        if (*(col + 0) > 9) {
#line 868
          s___5 ++;
        }
#line 870
        if (*(col + 1) > 9) {
#line 871
          s___5 ++;
        }
#line 873
        if (*(col + 2) > 9) {
#line 874
          s___5 ++;
        }
#line 863
        j___21 ++;
      }
      while_break___22: /* CIL Label */ ;
      }

      while_break___6: ;
#line 877
      if (i___153 < numlayers - 1U) {
#line 878
        s___5 ++;
      }
#line 852
      i___153 ++;
    }
    while_break___21: /* CIL Label */ ;
    }

    while_break___5: 
#line 881
    parameters___21->cp_fixed_alloc = 1;
#line 883
    goto switch_break;
    case_116: 
    {
#line 888
    sscanf((char const   *)opj_optarg, "%d,%d", & parameters___21->cp_tdx, & parameters___21->cp_tdy);
#line 889
    parameters___21->tile_size_on = 1;
    }
#line 891
    goto switch_break;
    case_110: 
    {
#line 896
    sscanf((char const   *)opj_optarg, "%d", & parameters___21->numresolution);
    }
#line 898
    goto switch_break;
    case_99: 
#line 903
    res_spec___0 = 0;
#line 905
    s___6 = opj_optarg;
    {
#line 907
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 908
      sep___0 = (char)0;
#line 909
      ret___2 = sscanf((char const   *)s___6, "[%d,%d]%c", & parameters___21->prcw_init[res_spec___0],
                       & parameters___21->prch_init[res_spec___0], & sep___0);
      }
#line 911
      if (ret___2 == 2) {
#line 911
        if (! ((int )sep___0 == 0)) {
#line 911
          goto _L___70;
        }
      } else
      _L___70: 
#line 911
      if (ret___2 == 3) {
#line 911
        if (! ((int )sep___0 == 44)) {
          {
#line 912
          fprintf(stderr, "\nError: could not parse precinct dimension: \'%s\' %x\n",
                  s___6, (int )sep___0);
#line 914
          fprintf(stderr, "Example: -i lena.raw -o lena.j2k -c [128,128],[128,128]\n\220");
          }
#line 915
          return (1);
        }
      } else {
        {
#line 912
        fprintf(stderr, "\nError: could not parse precinct dimension: \'%s\' %x\n",
                s___6, (int )sep___0);
#line 914
        fprintf(stderr, "Example: -i lena.raw -o lena.j2k -c [128,128],[128,128]\n\220");
        }
#line 915
        return (1);
      }
      {
#line 917
      parameters___21->csty |= 1;
#line 918
      res_spec___0 ++;
#line 919
      __cil_tmp85___1 = strpbrk((char const   *)s___6, "]");
#line 919
      s___6 = __cil_tmp85___1 + 2;
      }
#line 907
      if (! ((int )sep___0 == 44)) {
#line 907
        goto while_break___7;
      }
    }
    while_break___23: /* CIL Label */ ;
    }

    while_break___7: 
#line 921
    parameters___21->res_spec = res_spec___0;
#line 923
    goto switch_break;
    case_98: 
    {
#line 928
    cblockw_init = 0;
#line 928
    cblockh_init = 0;
#line 929
    sscanf((char const   *)opj_optarg, "%d,%d", & cblockw_init, & cblockh_init);
    }
#line 930
    if (cblockw_init > 1024) {
      {
#line 933
      fprintf(stderr, "!! Size of code_block error (option -b) !!\n\nRestriction :\n    * width*height<=4096\n    * 4<=width,height<= 1024\n\n");
      }
#line 936
      return (1);
    } else
#line 930
    if (cblockw_init < 4) {
      {
#line 933
      fprintf(stderr, "!! Size of code_block error (option -b) !!\n\nRestriction :\n    * width*height<=4096\n    * 4<=width,height<= 1024\n\n");
      }
#line 936
      return (1);
    } else
#line 930
    if (cblockh_init > 1024) {
      {
#line 933
      fprintf(stderr, "!! Size of code_block error (option -b) !!\n\nRestriction :\n    * width*height<=4096\n    * 4<=width,height<= 1024\n\n");
      }
#line 936
      return (1);
    } else
#line 930
    if (cblockh_init < 4) {
      {
#line 933
      fprintf(stderr, "!! Size of code_block error (option -b) !!\n\nRestriction :\n    * width*height<=4096\n    * 4<=width,height<= 1024\n\n");
      }
#line 936
      return (1);
    } else
#line 930
    if (cblockw_init * cblockh_init > 4096) {
      {
#line 933
      fprintf(stderr, "!! Size of code_block error (option -b) !!\n\nRestriction :\n    * width*height<=4096\n    * 4<=width,height<= 1024\n\n");
      }
#line 936
      return (1);
    }
#line 938
    parameters___21->cblockw_init = cblockw_init;
#line 939
    parameters___21->cblockh_init = cblockh_init;
#line 941
    goto switch_break;
    case_120: 
    {
#line 946
    __cil_tmp88___0 = opj_strcpy_s(indexfilename, indexfilename_size, (char const   *)opj_optarg);
    }
#line 946
    if (__cil_tmp88___0 != 0) {
#line 947
      return (1);
    }
    {
#line 950
    fprintf(stderr, "[WARNING] Index file generation is currently broken.\n          \'-x\' option ignored.\n\220");
    }
#line 955
    goto switch_break;
    case_112: 
    {
#line 962
    strncpy(progression___0, (char const   *)opj_optarg, 4UL);
#line 963
    __asm__  ("booo_exp(/root/patron-new/39/src/bin/jp2/opj_compress.c:963)":);
#line 963
    parameters___21->prog_order = give_progression((char const   *)0);
    }
#line 964
    if ((int )parameters___21->prog_order == -1) {
      {
#line 965
      fprintf(stderr, "Unrecognized progression order [LRCP, RLCP, RPCL, PCRL, CPRL] !!\n");
      }
#line 967
      return (1);
    }
#line 970
    goto switch_break;
    case_115: 
    {
#line 975
    __cil_tmp91___1 = sscanf((char const   *)opj_optarg, "%d,%d", & parameters___21->subsampling_dx,
                             & parameters___21->subsampling_dy);
    }
#line 975
    if (__cil_tmp91___1 != 2) {
      {
#line 977
      fprintf(stderr, "\'-s\' sub-sampling argument error !  [-s dx,dy]\n");
      }
#line 978
      return (1);
    }
#line 981
    goto switch_break;
    case_100: 
    {
#line 986
    __cil_tmp92 = sscanf((char const   *)opj_optarg, "%d,%d", & parameters___21->image_offset_x0,
                         & parameters___21->image_offset_y0);
    }
#line 986
    if (__cil_tmp92 != 2) {
      {
#line 988
      fprintf(stderr, "-d \'coordonnate of the reference grid\' argument error !! [-d x0,y0]\n\220");
      }
#line 990
      return (1);
    }
#line 993
    goto switch_break;
    case_104: 
    {
#line 998
    encode_help_display();
    }
#line 999
    return (1);
    case_80: 
#line 1004
    numpocs = 0;
#line 1005
    POC___0 = (opj_poc_t *)((void *)0);
#line 1007
    s___7 = opj_optarg;
#line 1008
    POC___0 = parameters___21->POC;
    {
#line 1010
    while (1) {
      while_continue___8: /* CIL Label */ ;
      {
#line 1010
      __cil_tmp96 = sscanf((char const   *)s___7, "T%u=%u,%u,%u,%u,%u,%4s", & (POC___0 + numpocs)->tile,
                           & (POC___0 + numpocs)->resno0, & (POC___0 + numpocs)->compno0,
                           & (POC___0 + numpocs)->layno1, & (POC___0 + numpocs)->resno1,
                           & (POC___0 + numpocs)->compno1, (POC___0 + numpocs)->progorder);
      }
#line 1010
      if (! (__cil_tmp96 == 7)) {
#line 1010
        goto while_break___8;
      }
      {
#line 1014
      __asm__  ("booo_exp(/root/patron-new/39/src/bin/jp2/opj_compress.c:1014)":);
#line 1014
      (POC___0 + numpocs)->prg1 = give_progression((char const   *)0);
#line 1015
      numpocs ++;
      }
      {
#line 1016
      while (1) {
        while_continue___9: /* CIL Label */ ;

#line 1016
        if ((int )*s___7) {
#line 1016
          if (! ((int )*s___7 != 47)) {
#line 1016
            goto while_break___9;
          }
        } else {
#line 1016
          goto while_break___9;
        }
#line 1017
        s___7 ++;
      }
      while_break___25: /* CIL Label */ ;
      }

      while_break___9: ;
#line 1019
      if (! *s___7) {
#line 1020
        goto while_break___8;
      }
#line 1022
      s___7 ++;
    }
    while_break___24: /* CIL Label */ ;
    }

    while_break___8: 
#line 1024
    parameters___21->numpocs = (OPJ_UINT32 )numpocs;
#line 1026
    goto switch_break;
    case_83: 
#line 1031
    parameters___21->csty |= 2;
#line 1033
    goto switch_break;
    case_69: 
#line 1038
    parameters___21->csty |= 4;
#line 1040
    goto switch_break;
    case_77: 
    {
#line 1045
    value___5 = 0;
#line 1046
    __cil_tmp102 = sscanf((char const   *)opj_optarg, "%d", & value___5);
    }
#line 1046
    if (__cil_tmp102 == 1) {
#line 1047
      i___153 = (OPJ_UINT32 )0;
      {
#line 1047
      while (1) {
        while_continue___10: /* CIL Label */ ;

#line 1047
        if (! (i___153 <= 5U)) {
#line 1047
          goto while_break___10;
        }
#line 1048
        cache = value___5 & (1 << i___153);
#line 1049
        if (cache) {
#line 1050
          parameters___21->mode |= 1 << i___153;
        }
#line 1047
        i___153 ++;
      }
      while_break___26: /* CIL Label */ ;
      }

      while_break___10: ;
    }
#line 1055
    goto switch_break;
    case_82: 
    {
#line 1060
    __cil_tmp105___0 = sscanf((char const   *)opj_optarg, "c=%d,U=%d", & parameters___21->roi_compno,
                              & parameters___21->roi_shift);
    }
#line 1060
    if (__cil_tmp105___0 != 2) {
      {
#line 1062
      fprintf(stderr, "ROI error !! [-ROI c=\'compno\',U=\'shift\']\n");
      }
#line 1063
      return (1);
    }
#line 1066
    goto switch_break;
    case_84: 
    {
#line 1071
    __cil_tmp106___0 = sscanf((char const   *)opj_optarg, "%d,%d", & parameters___21->cp_tx0,
                              & parameters___21->cp_ty0);
    }
#line 1071
    if (__cil_tmp106___0 != 2) {
      {
#line 1073
      fprintf(stderr, "-T \'tile offset\' argument error !! [-T X0,Y0]");
      }
#line 1074
      return (1);
    }
#line 1077
    goto switch_break;
    case_67: 
    {
#line 1082
    __cil_tmp107___0 = strlen((char const   *)opj_optarg);
#line 1082
    __cil_tmp108___0 = malloc(__cil_tmp107___0 + 1UL);
#line 1082
    parameters___21->cp_comment = (char *)__cil_tmp108___0;
    }
#line 1083
    if (parameters___21->cp_comment) {
      {
#line 1084
      strcpy(parameters___21->cp_comment, (char const   *)opj_optarg);
      }
    }
#line 1087
    goto switch_break;
    case_73: 
#line 1093
    parameters___21->irreversible = 1;
#line 1095
    goto switch_break;
    case_117: 
#line 1100
    parameters___21->tp_flag = *(opj_optarg + 0);
#line 1101
    parameters___21->tp_on = (char)1;
#line 1103
    goto switch_break;
    case_122: 
    {
#line 1108
    __cil_tmp109___0 = strlen((char const   *)opj_optarg);
#line 1108
    __cil_tmp110___0 = malloc(__cil_tmp109___0 + 1UL);
#line 1108
    img_fol___0->imgdirpath = (char *)__cil_tmp110___0;
    }
#line 1109
    if ((unsigned long )img_fol___0->imgdirpath == (unsigned long )((void *)0)) {
#line 1110
      return (1);
    }
    {
#line 1112
    strcpy(img_fol___0->imgdirpath, (char const   *)opj_optarg);
#line 1113
    img_fol___0->set_imgdir = (char)1;
    }
#line 1115
    goto switch_break;
    case_119: 
    {
#line 1120
    fps = 0;
#line 1121
    sscanf((char const   *)opj_optarg, "%d", & fps);
    }
#line 1122
    if (fps == 24) {
#line 1123
      parameters___21->rsiz = (OPJ_UINT16 )3;
#line 1124
      parameters___21->max_comp_size = 1041666;
#line 1125
      parameters___21->max_cs_size = 1302083;
    } else
#line 1126
    if (fps == 48) {
#line 1127
      parameters___21->rsiz = (OPJ_UINT16 )3;
#line 1128
      parameters___21->max_comp_size = 520833;
#line 1129
      parameters___21->max_cs_size = 651041;
    } else {
      {
#line 1131
      fprintf(stderr, "Incorrect value!! must be 24 or 48\n");
      }
#line 1132
      return (1);
    }
    {
#line 1134
    fprintf(stdout, "CINEMA 2K profile activated\nOther options specified could be overridden\n");
    }
#line 1138
    goto switch_break;
    case_121: 
    {
#line 1143
    parameters___21->rsiz = (OPJ_UINT16 )4;
#line 1144
    fprintf(stdout, "CINEMA 4K profile activated\nOther options specified could be overridden\n");
    }
#line 1147
    goto switch_break;
    case_90: 
    {
#line 1152
    mainlevel___0 = 0;
#line 1153
    sublevel___0 = 0;
#line 1154
    profile___2 = 0;
#line 1155
    framerate = 0;
#line 1156
    strcpy((char *)msg___0, "Wrong value for -IMF. Should be <PROFILE>[,mainlevel=X][,sublevel=Y][,framerate=FPS] where <PROFILE> is one of 2K/4K/8K/2K_R/4K_R/8K_R.\n\220");
#line 1162
    comma = strstr((char const   *)opj_optarg, ",mainlevel=");
#line 1163
    __cil_tmp119 = sscanf((char const   *)(comma + 1), "mainlevel=%d", & mainlevel___0);
    }
#line 1163
    if (comma) {
#line 1163
      if (__cil_tmp119 != 1) {
        {
#line 1164
        fprintf(stderr, "%s", msg___0);
        }
#line 1165
        return (1);
      }
    }
    {
#line 1168
    comma = strstr((char const   *)opj_optarg, ",sublevel=");
#line 1169
    __cil_tmp121 = sscanf((char const   *)(comma + 1), "sublevel=%d", & sublevel___0);
    }
#line 1169
    if (comma) {
#line 1169
      if (__cil_tmp121 != 1) {
        {
#line 1170
        fprintf(stderr, "%s", msg___0);
        }
#line 1171
        return (1);
      }
    }
    {
#line 1174
    comma = strstr((char const   *)opj_optarg, ",framerate=");
#line 1175
    __cil_tmp123 = sscanf((char const   *)(comma + 1), "framerate=%d", & framerate);
    }
#line 1175
    if (comma) {
#line 1175
      if (__cil_tmp123 != 1) {
        {
#line 1176
        fprintf(stderr, "%s", msg___0);
        }
#line 1177
        return (1);
      }
    }
    {
#line 1180
    comma = strchr((char const   *)opj_optarg, ',');
    }
#line 1181
    if ((unsigned long )comma != (unsigned long )((void *)0)) {
#line 1182
      *comma = (char)0;
    }
    {
#line 1185
    __cil_tmp125 = strcmp((char const   *)opj_optarg, "2K");
    }
#line 1185
    if (__cil_tmp125 == 0) {
#line 1186
      profile___2 = 1024;
    } else {
      {
#line 1187
      __cil_tmp126 = strcmp((char const   *)opj_optarg, "4K");
      }
#line 1187
      if (__cil_tmp126 == 0) {
#line 1188
        profile___2 = 1280;
      } else {
        {
#line 1189
        __cil_tmp127 = strcmp((char const   *)opj_optarg, "8K");
        }
#line 1189
        if (__cil_tmp127 == 0) {
#line 1190
          profile___2 = 1536;
        } else {
          {
#line 1191
          __cil_tmp128 = strcmp((char const   *)opj_optarg, "2K_R");
          }
#line 1191
          if (__cil_tmp128 == 0) {
#line 1192
            profile___2 = 1792;
          } else {
            {
#line 1193
            __cil_tmp129 = strcmp((char const   *)opj_optarg, "4K_R");
            }
#line 1193
            if (__cil_tmp129 == 0) {
#line 1194
              profile___2 = 2048;
            } else {
              {
#line 1195
              __cil_tmp130 = strcmp((char const   *)opj_optarg, "8K_R");
              }
#line 1195
              if (__cil_tmp130 == 0) {
#line 1196
                profile___2 = 2304;
              } else {
                {
#line 1198
                fprintf(stderr, "%s", msg___0);
                }
#line 1199
                return (1);
              }
            }
          }
        }
      }
    }
#line 1202
    if (mainlevel___0 >= 0) {
#line 1202
      if (! (mainlevel___0 <= 15)) {
        {
#line 1204
        fprintf(stderr, "Invalid mainlevel value.\n");
        }
#line 1205
        return (1);
      }
    } else {
      {
#line 1204
      fprintf(stderr, "Invalid mainlevel value.\n");
      }
#line 1205
      return (1);
    }
#line 1207
    if (sublevel___0 >= 0) {
#line 1207
      if (! (sublevel___0 <= 15)) {
        {
#line 1209
        fprintf(stderr, "Invalid sublevel value.\n\220");
        }
#line 1210
        return (1);
      }
    } else {
      {
#line 1209
      fprintf(stderr, "Invalid sublevel value.\n\220");
      }
#line 1210
      return (1);
    }
    {
#line 1212
    parameters___21->rsiz = (OPJ_UINT16 )((profile___2 | (sublevel___0 << 4)) | mainlevel___0);
#line 1214
    fprintf(stdout, "IMF profile activated\nOther options specified could be overridden\n");
    }
#line 1217
    if (pOutFramerate) {
#line 1218
      *pOutFramerate = framerate;
    }
#line 1220
    if (framerate > 0) {
#line 1220
      if (sublevel___0 > 0) {
#line 1220
        if (sublevel___0 <= 9) {
          {
#line 1221
          limitMBitsSec[0] = 0;
#line 1221
          limitMBitsSec[1] = 200;
#line 1221
          limitMBitsSec[2] = 400;
#line 1221
          limitMBitsSec[3] = 800;
#line 1221
          limitMBitsSec[4] = 1600;
#line 1221
          limitMBitsSec[5] = 3200;
#line 1221
          limitMBitsSec[6] = 6400;
#line 1221
          limitMBitsSec[7] = 12800;
#line 1221
          limitMBitsSec[8] = 25600;
#line 1221
          limitMBitsSec[9] = 51200;
#line 1233
          parameters___21->max_cs_size = (limitMBitsSec[sublevel___0] * 125000) / framerate;
#line 1235
          fprintf(stdout, "Setting max codestream size to %d bytes.\n", parameters___21->max_cs_size);
          }
        }
      }
    }
#line 1239
    goto switch_break;
    case_89: 
    {
#line 1244
    mct_mode = 0;
#line 1245
    sscanf((char const   *)opj_optarg, "%d", & mct_mode);
    }
#line 1246
    if (mct_mode < 0) {
      {
#line 1247
      fprintf(stderr, "MCT incorrect value!! Current accepted values are 0, 1 or 2.\n");
      }
#line 1249
      return (1);
    } else
#line 1246
    if (mct_mode > 2) {
      {
#line 1247
      fprintf(stderr, "MCT incorrect value!! Current accepted values are 0, 1 or 2.\n");
      }
#line 1249
      return (1);
    }
#line 1251
    parameters___21->tcp_mct = (char )mct_mode;
#line 1253
    goto switch_break;
    case_109: 
    {
#line 1259
    lFilename = opj_optarg;
#line 1265
    lNbComp = 0;
#line 1269
    __cil_tmp146 = fopen((char const   *)lFilename, "r");
#line 1269
    lFile = __cil_tmp146;
    }
#line 1270
    if ((unsigned long )lFile == (unsigned long )((void *)0)) {
#line 1271
      return (1);
    }
    {
#line 1275
    fseek(lFile, 0L, 2);
#line 1276
    __cil_tmp147 = ftell(lFile);
#line 1276
    lStrLen = (size_t )__cil_tmp147;
#line 1277
    fseek(lFile, 0L, 0);
#line 1278
    __cil_tmp148 = malloc(lStrLen + 1UL);
#line 1278
    lMatrix = (char *)__cil_tmp148;
    }
#line 1279
    if ((unsigned long )lMatrix == (unsigned long )((void *)0)) {
      {
#line 1280
      fclose(lFile);
      }
#line 1281
      return (1);
    }
    {
#line 1283
    lStrFread = fread((void *)lMatrix, 1UL, lStrLen, lFile);
#line 1284
    fclose(lFile);
    }
#line 1285
    if (lStrLen != lStrFread) {
      {
#line 1286
      free((void *)lMatrix);
      }
#line 1287
      return (1);
    }
#line 1290
    *(lMatrix + lStrLen) = (char)0;
#line 1291
    lCurrentPtr___1 = lMatrix;
    {
#line 1294
    while (1) {
      while_continue___11: /* CIL Label */ ;

#line 1294
      if (! ((int )*lCurrentPtr___1 != 0)) {
#line 1294
        goto while_break___11;
      }
#line 1295
      if ((int )*lCurrentPtr___1 == 32) {
#line 1296
        *lCurrentPtr___1 = (char)0;
#line 1297
        lNbComp ++;
      }
#line 1299
      lCurrentPtr___1 ++;
    }
    while_break___27: /* CIL Label */ ;
    }

    while_break___11: 
    {
#line 1301
    lNbComp ++;
#line 1302
    lCurrentPtr___1 = lMatrix;
#line 1304
    __cil_tmp150 = sqrt((double )(4 * lNbComp + 1));
#line 1304
    lNbComp = (int )(__cil_tmp150 / 2. - 0.5);
#line 1305
    lMctComp = lNbComp * lNbComp;
#line 1306
    lTotalComp = lMctComp + lNbComp;
#line 1307
    __cil_tmp151 = malloc((size_t )lTotalComp * sizeof(float ));
#line 1307
    lSpace = (float *)__cil_tmp151;
    }
#line 1308
    if ((unsigned long )lSpace == (unsigned long )((void *)0)) {
      {
#line 1309
      free((void *)lMatrix);
      }
#line 1310
      return (1);
    }
#line 1312
    lCurrentDoublePtr = lSpace;
#line 1313
    i2 = 0;
    {
#line 1313
    while (1) {
      while_continue___12: /* CIL Label */ ;

#line 1313
      if (! (i2 < lMctComp)) {
#line 1313
        goto while_break___12;
      }
      {
#line 1314
      __cil_tmp152 = strlen((char const   *)lCurrentPtr___1);
#line 1314
      lStrLen = __cil_tmp152 + 1UL;
#line 1315
      __cil_tmp154 = atof((char const   *)lCurrentPtr___1);
#line 1315
      __cil_tmp153 = lCurrentDoublePtr;
#line 1315
      lCurrentDoublePtr ++;
#line 1315
      *__cil_tmp153 = (float )__cil_tmp154;
#line 1316
      lCurrentPtr___1 += lStrLen;
#line 1313
      i2 ++;
      }
    }
    while_break___28: /* CIL Label */ ;
    }

    while_break___12: 
#line 1319
    l_int_ptr = (int *)lCurrentDoublePtr;
#line 1320
    i2 = 0;
    {
#line 1320
    while (1) {
      while_continue___13: /* CIL Label */ ;

#line 1320
      if (! (i2 < lNbComp)) {
#line 1320
        goto while_break___13;
      }
      {
#line 1321
      __cil_tmp155 = strlen((char const   *)lCurrentPtr___1);
#line 1321
      lStrLen = __cil_tmp155 + 1UL;
#line 1322
      __cil_tmp156 = l_int_ptr;
#line 1322
      l_int_ptr ++;
#line 1322
      *__cil_tmp156 = atoi((char const   *)lCurrentPtr___1);
#line 1323
      lCurrentPtr___1 += lStrLen;
#line 1320
      i2 ++;
      }
    }
    while_break___29: /* CIL Label */ ;
    }

    while_break___13: 
    {
#line 1327
    opj_set_MCT(parameters___21, lSpace, (int *)(lSpace + lMctComp), (OPJ_UINT32 )lNbComp);
#line 1331
    free((void *)lSpace);
#line 1332
    free((void *)lMatrix);
    }
#line 1334
    goto switch_break;
    case_74: 
#line 1678
    parameters___21->jpip_on = 1;
#line 1680
    goto switch_break;
    case_65: 
#line 1684
    *pOutPLT = 1;
#line 1686
    goto switch_break;
    case_66: 
    {
#line 1690
    __cil_tmp158 = strcmp((char const   *)opj_optarg, "ALL_CPUS\220");
    }
#line 1690
    if (__cil_tmp158 == 0) {
      {
#line 1691
      *pOutNumThreads = opj_get_num_cpus();
      }
#line 1692
      if (*pOutNumThreads == 1) {
#line 1693
        *pOutNumThreads = 0;
      }
    } else {
      {
#line 1696
      sscanf((char const   *)opj_optarg, "%d", pOutNumThreads);
      }
    }
#line 1699
    goto switch_break;
    switch_default___2: 
    {
#line 1705
    fprintf(stderr, "[WARNING] An invalid option has been ignored\n");
    }
#line 1706
    goto switch_break;
    switch_break: ;
#line 619
    if (! (c___3 != -1)) {
#line 619
      goto while_break;
    }
  }
  while_break___15: /* CIL Label */ ;
  }

  while_break: ;
#line 1710
  if ((int )img_fol___0->set_imgdir == 1) {
#line 1711
    if (! ((int )parameters___21->infile[0] == 0)) {
      {
#line 1712
      fprintf(stderr, "[ERROR] options -ImgDir and -i cannot be used together !!\n");
      }
#line 1713
      return (1);
    }
#line 1715
    if ((int )img_fol___0->set_out_format == 0) {
      {
#line 1716
      fprintf(stderr, "[ERROR] When -ImgDir is used, -OutFor <FORMAT> must be used !!\n");
#line 1718
      fprintf(stderr, "Only one format allowed! Valid formats are j2k and jp2!!\n");
      }
#line 1719
      return (1);
    }
#line 1721
    if (! ((int )parameters___21->outfile[0] == 0)) {
      {
#line 1722
      fprintf(stderr, "[ERROR] options -ImgDir and -o cannot be used together !!\n");
#line 1723
      fprintf(stderr, "Specify OutputFormat using -OutFor<FORMAT> !!\n");
      }
#line 1724
      return (1);
    }
  } else
#line 1727
  if ((int )parameters___21->infile[0] == 0) {
    {
#line 1728
    fprintf(stderr, "[ERROR] Required parameters are missing\nExample: %s -i image.pgm -o image.j2k\n",
            *(argv + 0));
#line 1730
    fprintf(stderr, "   Help: %s -h\n", *(argv + 0));
    }
#line 1731
    return (1);
  } else
#line 1727
  if ((int )parameters___21->outfile[0] == 0) {
    {
#line 1728
    fprintf(stderr, "[ERROR] Required parameters are missing\nExample: %s -i image.pgm -o image.j2k\n",
            *(argv + 0));
#line 1730
    fprintf(stderr, "   Help: %s -h\n", *(argv + 0));
    }
#line 1731
    return (1);
  }
#line 1735
  if (parameters___21->decod_format == 15) {
#line 1735
    if (raw_cp___2->rawWidth == 0) {
      {
#line 1737
      fprintf(stderr, "[ERROR] invalid raw image parameters\n");
#line 1738
      fprintf(stderr, "Please use the Format option -F:\n");
#line 1739
      fprintf(stderr, "-F rawWidth,rawHeight,rawComp,rawBitDepth,s/u (Signed/Unsigned)\n\220");
#line 1741
      fprintf(stderr, "Example: -i lena.raw -o lena.j2k -F 512,512,3,8,u\n");
#line 1742
      fprintf(stderr, "Aborting\n");
      }
#line 1743
      return (1);
    } else {
#line 1735
      goto _L;
    }
  } else
  _L: 
#line 1735
  if (parameters___21->decod_format == 18) {
#line 1735
    if (raw_cp___2->rawWidth == 0) {
      {
#line 1737
      fprintf(stderr, "[ERROR] invalid raw image parameters\n");
#line 1738
      fprintf(stderr, "Please use the Format option -F:\n");
#line 1739
      fprintf(stderr, "-F rawWidth,rawHeight,rawComp,rawBitDepth,s/u (Signed/Unsigned)\n\220");
#line 1741
      fprintf(stderr, "Example: -i lena.raw -o lena.j2k -F 512,512,3,8,u\n");
#line 1742
      fprintf(stderr, "Aborting\n");
      }
#line 1743
      return (1);
    }
  }
#line 1746
  if (parameters___21->cp_disto_alloc) {
    _L___66: 
#line 1746
    if (! ((parameters___21->cp_disto_alloc ^ parameters___21->cp_fixed_alloc) ^ parameters___21->cp_fixed_quality)) {
      {
#line 1750
      fprintf(stderr, "[ERROR] options -r -q and -f cannot be used together !!\n\220");
      }
#line 1751
      return (1);
    }
  } else
#line 1746
  if (parameters___21->cp_fixed_alloc) {
#line 1746
    goto _L___66;
  } else
#line 1746
  if (parameters___21->cp_fixed_quality) {
#line 1746
    goto _L___66;
  }
#line 1758
  if (parameters___21->tcp_numlayers == 0) {
#line 1759
    parameters___21->tcp_rates[0] = (float )0;
#line 1760
    (parameters___21->tcp_numlayers) ++;
#line 1761
    parameters___21->cp_disto_alloc = 1;
  }
#line 1764
  if (parameters___21->cp_tx0 > parameters___21->image_offset_x0) {
    {
#line 1766
    fprintf(stderr, "[ERROR] Tile offset dimension is unnappropriate --> TX0(%d)<=IMG_X0(%d) TYO(%d)<=IMG_Y0(%d) \n",
            parameters___21->cp_tx0, parameters___21->image_offset_x0, parameters___21->cp_ty0,
            parameters___21->image_offset_y0);
    }
#line 1770
    return (1);
  } else
#line 1764
  if (parameters___21->cp_ty0 > parameters___21->image_offset_y0) {
    {
#line 1766
    fprintf(stderr, "[ERROR] Tile offset dimension is unnappropriate --> TX0(%d)<=IMG_X0(%d) TYO(%d)<=IMG_Y0(%d) \n",
            parameters___21->cp_tx0, parameters___21->image_offset_x0, parameters___21->cp_ty0,
            parameters___21->image_offset_y0);
    }
#line 1770
    return (1);
  }
#line 1773
  i___153 = (OPJ_UINT32 )0;
  {
#line 1773
  while (1) {
    while_continue___14: /* CIL Label */ ;

#line 1773
    if (! (i___153 < parameters___21->numpocs)) {
#line 1773
      goto while_break___14;
    }
#line 1774
    if ((int )parameters___21->POC[i___153].prg == -1) {
      {
#line 1775
      fprintf(stderr, "Unrecognized progression order in option -P (POC n %d) [LRCP, RLCP, RPCL, PCRL, CPRL] !!\n",
              i___153 + 1U);
      }
    }
#line 1773
    i___153 ++;
  }
  while_break___30: /* CIL Label */ ;
  }

  while_break___14: ;
#line 1782
  if (parameters___21->decod_format == 15) {
    _L___69: 
#line 1782
    if (raw_cp___2->rawComp > 1) {
#line 1782
      if ((raw_cp___2->rawComps + 1)->dx > 1) {
#line 1789
        parameters___21->tcp_mct = (char)0;
      } else
#line 1782
      if ((raw_cp___2->rawComps + 1)->dy > 1) {
#line 1789
        parameters___21->tcp_mct = (char)0;
      } else {
#line 1782
        goto _L___68;
      }
    } else
    _L___68: 
#line 1782
    if (raw_cp___2->rawComp > 2) {
#line 1782
      if ((raw_cp___2->rawComps + 2)->dx > 1) {
#line 1789
        parameters___21->tcp_mct = (char)0;
      } else
#line 1782
      if ((raw_cp___2->rawComps + 2)->dy > 1) {
#line 1789
        parameters___21->tcp_mct = (char)0;
      }
    }
  } else
#line 1782
  if (parameters___21->decod_format == 18) {
#line 1782
    goto _L___69;
  }
#line 1792
  return (0);
}
}
#line 1801 "/root/patron-new/39/src/bin/jp2/opj_compress.c"
static void error_callback(char const   *msg___1 , void *client_data___0 ) 
{ 


  {
  {
#line 1804
  fprintf(stdout, "[ERROR] %s", msg___1);
  }
#line 1806
  return;
}
}
#line 1809 "/root/patron-new/39/src/bin/jp2/opj_compress.c"
static void warning_callback(char const   *msg___2 , void *client_data___1 ) 
{ 


  {
  {
#line 1812
  fprintf(stdout, "[WARNING] %s]U", msg___2);
  }
#line 1814
  return;
}
}
#line 1817 "/root/patron-new/39/src/bin/jp2/opj_compress.c"
static void info_callback(char const   *msg___3 , void *client_data___2 ) 
{ 


  {
  {
#line 1820
  fprintf(stdout, "[INFO] %s\341\341\006]U", msg___3);
  }
#line 1822
  return;
}
}
#line 1856 "/root/patron-new/39/src/bin/jp2/opj_compress.c"
int main(int argc___0 , char **argv___0 ) 
{ 
  opj_cparameters_t parameters___22 ;
  opj_stream_t *l_stream___18 ;
  opj_codec_t *l_codec___25 ;
  opj_image_t *image___35 ;
  raw_cparameters_t raw_cp___3 ;
  OPJ_SIZE_T num_compressed_files ;
  char indexfilename___0[4096] ;
  unsigned int i___154 ;
  unsigned int num_images___0 ;
  unsigned int imageno___0 ;
  img_fol_t img_fol___1 ;
  dircnt_t *dirptr___1 ;
  int ret___3 ;
  OPJ_BOOL bSuccess ;
  OPJ_BOOL bUseTiles ;
  OPJ_UINT32 l_nb_tiles___12 ;
  int framerate___0 ;
  OPJ_FLOAT64 t___1 ;
  OPJ_FLOAT64 __cil_tmp21___30 ;
  OPJ_BOOL PLT ;
  int num_threads___3 ;
  int __cil_tmp24___40 ;
  void *__cil_tmp26___32 ;
  void *__cil_tmp27___24 ;
  void *__cil_tmp28___30 ;
  int __cil_tmp30___24 ;
  char __cil_tmp31___28 ;
  int tmp___521 ;
  int mainlevel___1 ;
  int limitMSamplesSec[12] ;
  OPJ_UINT32 avgcomponents ;
  double msamplespersec ;
  OPJ_BOOL __cil_tmp47___8 ;
  char const   *options___0[2] ;
  OPJ_BOOL __cil_tmp49___3 ;
  OPJ_BOOL __cil_tmp50___2 ;
  OPJ_BYTE *l_data___12 ;
  OPJ_UINT32 l_data_size___2 ;
  void *__cil_tmp55___6 ;
  OPJ_BOOL __cil_tmp56___6 ;
  OPJ_BOOL __cil_tmp57___2 ;
  OPJ_BOOL __cil_tmp58___1 ;
  OPJ_FLOAT64 __cil_tmp61___2 ;
  int tmp___522 ;
  int tmp___523 ;

  {
  {
#line 1861
  l_stream___18 = (opj_stream_t *)0;
#line 1862
  l_codec___25 = (opj_codec_t *)0;
#line 1863
  image___35 = (opj_image_t *)((void *)0);
#line 1865
  num_compressed_files = (OPJ_SIZE_T )0;
#line 1871
  dirptr___1 = (dircnt_t *)((void *)0);
#line 1873
  ret___3 = 0;
#line 1876
  bUseTiles = 0;
#line 1877
  l_nb_tiles___12 = (OPJ_UINT32 )4;
#line 1878
  framerate___0 = 0;
#line 1879
  __cil_tmp21___30 = opj_clock();
#line 1879
  t___1 = __cil_tmp21___30;
#line 1881
  PLT = 0;
#line 1882
  num_threads___3 = 0;
#line 1885
  opj_set_default_encoder_parameters(& parameters___22);
#line 1888
  indexfilename___0[0] = (char)0;
#line 1889
  memset((void *)(& img_fol___1), 0, sizeof(img_fol_t ));
#line 1892
  raw_cp___3.rawBitDepth = 0;
#line 1893
  raw_cp___3.rawComp = 0;
#line 1894
  raw_cp___3.rawComps = (raw_comp_cparameters_t *)0;
#line 1895
  raw_cp___3.rawHeight = 0;
#line 1896
  raw_cp___3.rawSigned = 0;
#line 1897
  raw_cp___3.rawWidth = 0;
#line 1900
  parameters___22.tcp_mct = (char)-1;
#line 1902
  __cil_tmp24___40 = parse_cmdline_encoder(argc___0, argv___0, & parameters___22,
                                           & img_fol___1, & raw_cp___3, indexfilename___0,
                                           sizeof(indexfilename___0), & framerate___0,
                                           & PLT, & num_threads___3);
  }
#line 1902
  if (__cil_tmp24___40 == 1) {
#line 1904
    ret___3 = 1;
#line 1905
    goto fin;
  }
#line 1909
  if ((int )img_fol___1.set_imgdir == 1) {
    {
#line 1910
    num_images___0 = get_num_images(img_fol___1.imgdirpath);
#line 1911
    __cil_tmp26___32 = malloc(sizeof(dircnt_t ));
#line 1911
    dirptr___1 = (dircnt_t *)__cil_tmp26___32;
    }
#line 1912
    if (dirptr___1) {
      {
#line 1913
      __cil_tmp27___24 = malloc((unsigned long )(num_images___0 * 4096U) * sizeof(char ));
#line 1913
      dirptr___1->filename_buf = (char *)__cil_tmp27___24;
#line 1915
      __cil_tmp28___30 = malloc((unsigned long )num_images___0 * sizeof(char *));
#line 1915
      dirptr___1->filename = (char **)__cil_tmp28___30;
      }
#line 1916
      if (! dirptr___1->filename_buf) {
#line 1917
        ret___3 = 0;
#line 1918
        goto fin;
      }
#line 1920
      i___154 = 0U;
      {
#line 1920
      while (1) {
        while_continue: /* CIL Label */ ;

#line 1920
        if (! (i___154 < num_images___0)) {
#line 1920
          goto while_break;
        }
#line 1921
        *(dirptr___1->filename + i___154) = dirptr___1->filename_buf + i___154 * 4096U;
#line 1920
        i___154 ++;
      }
      while_break___2: /* CIL Label */ ;
      }

      while_break: ;
    }
    {
#line 1924
    __cil_tmp30___24 = load_images(dirptr___1, img_fol___1.imgdirpath);
    }
#line 1924
    if (__cil_tmp30___24 == 1) {
#line 1925
      ret___3 = 0;
#line 1926
      goto fin;
    }
#line 1928
    if (num_images___0 == 0U) {
      {
#line 1929
      fprintf(stdout, "Folder is empty\n\220");
#line 1930
      ret___3 = 0;
      }
#line 1931
      goto fin;
    }
  } else {
#line 1934
    num_images___0 = 1U;
  }
#line 1937
  imageno___0 = 0U;
  {
#line 1937
  while (1) {
    while_continue___1: /* CIL Label */ ;

    while_continue___0: ;
#line 1937
    if (! (imageno___0 < num_images___0)) {
#line 1937
      goto while_break___0;
    }
    {
#line 1938
    image___35 = (opj_image_t *)((void *)0);
#line 1939
    fprintf(stderr, "\n&\342\006]U");
    }
#line 1941
    if ((int )img_fol___1.set_imgdir == 1) {
      {
#line 1942
      __cil_tmp31___28 = get_next_file((int )imageno___0, dirptr___1, & img_fol___1,
                                       & parameters___22);
      }
#line 1942
      if (__cil_tmp31___28) {
        {
#line 1943
        fprintf(stderr, "skipping file...\n*\342\006]U");
        }
#line 1944
        goto while_continue___0;
      }
    }
#line 1949
    if (parameters___22.decod_format == 11) {
#line 1949
      goto case_11;
    }
#line 1951
    if (parameters___22.decod_format == 10) {
#line 1951
      goto case_10;
    }
#line 1953
    if (parameters___22.decod_format == 12) {
#line 1953
      goto case_12;
    }
#line 1955
    if (parameters___22.decod_format == 14) {
#line 1955
      goto case_14;
    }
#line 1958
    if (parameters___22.decod_format == 18) {
#line 1958
      goto case_18;
    }
#line 1958
    if (parameters___22.decod_format == 15) {
#line 1958
      goto case_18;
    }
#line 1960
    if (parameters___22.decod_format == 16) {
#line 1960
      goto case_16;
    }
#line 1962
    if (parameters___22.decod_format == 17) {
#line 1962
      goto case_17;
    }
#line 1964
    goto switch_default;
    case_11: 
#line 1950
    goto switch_break;
    case_10: 
#line 1952
    goto switch_break;
    case_12: 
#line 1954
    goto switch_break;
    case_14: 
#line 1956
    goto switch_break;
    case_18: 
#line 1959
    goto switch_break;
    case_16: 
#line 1961
    goto switch_break;
    case_17: 
#line 1963
    goto switch_break;
    switch_default: 
    {
#line 1965
    fprintf(stderr, "skipping file...\n\202\342\006]U");
    }
#line 1966
    goto while_continue___0;
    switch_break: ;
#line 1973
    if (parameters___22.decod_format == 11) {
#line 1973
      goto case_11___0;
    }
#line 1982
    if (parameters___22.decod_format == 10) {
#line 1982
      goto case_10___0;
    }
#line 1991
    if (parameters___22.decod_format == 12) {
#line 1991
      goto case_12___0;
    }
#line 2001
    if (parameters___22.decod_format == 14) {
#line 2001
      goto case_14___0;
    }
#line 2011
    if (parameters___22.decod_format == 15) {
#line 2011
      goto case_15___0;
    }
#line 2020
    if (parameters___22.decod_format == 18) {
#line 2020
      goto case_18___0;
    }
#line 2029
    if (parameters___22.decod_format == 16) {
#line 2029
      goto case_16___0;
    }
#line 2039
    if (parameters___22.decod_format == 17) {
#line 2039
      goto case_17___0;
    }
#line 1972
    goto switch_break___0;
    case_11___0: 
    {
#line 1974
    image___35 = pgxtoimage((char const   *)(parameters___22.infile), & parameters___22);
    }
#line 1975
    if (! image___35) {
      {
#line 1976
      fprintf(stderr, "Unable to load pgx file\n\220");
#line 1977
      ret___3 = 1;
      }
#line 1978
      goto fin;
    }
#line 1980
    goto switch_break___0;
    case_10___0: 
    {
#line 1983
    image___35 = pnmtoimage((char const   *)(parameters___22.infile), & parameters___22);
    }
#line 1984
    if (! image___35) {
      {
#line 1985
      fprintf(stderr, "Unable to load pnm file\n\220");
#line 1986
      ret___3 = 1;
      }
#line 1987
      goto fin;
    }
#line 1989
    goto switch_break___0;
    case_12___0: 
    {
#line 1992
    image___35 = bmptoimage((char const   *)(parameters___22.infile), & parameters___22);
    }
#line 1993
    if (! image___35) {
      {
#line 1994
      fprintf(stderr, "Unable to load bmp file\n\220");
#line 1995
      ret___3 = 1;
      }
#line 1996
      goto fin;
    }
#line 1998
    goto switch_break___0;
    case_14___0: 
    {
#line 2002
    image___35 = tiftoimage((char const   *)(parameters___22.infile), & parameters___22);
    }
#line 2003
    if (! image___35) {
      {
#line 2004
      fprintf(stderr, "Unable to load tiff file\n");
#line 2005
      ret___3 = 1;
      }
#line 2006
      goto fin;
    }
#line 2008
    goto switch_break___0;
    case_15___0: 
    {
#line 2012
    image___35 = rawtoimage((char const   *)(parameters___22.infile), & parameters___22,
                            & raw_cp___3);
    }
#line 2013
    if (! image___35) {
      {
#line 2014
      fprintf(stderr, "Unable to load raw file\n\220");
#line 2015
      ret___3 = 1;
      }
#line 2016
      goto fin;
    }
#line 2018
    goto switch_break___0;
    case_18___0: 
    {
#line 2021
    image___35 = rawltoimage((char const   *)(parameters___22.infile), & parameters___22,
                             & raw_cp___3);
    }
#line 2022
    if (! image___35) {
      {
#line 2023
      fprintf(stderr, "Unable to load raw file\n\220");
#line 2024
      ret___3 = 1;
      }
#line 2025
      goto fin;
    }
#line 2027
    goto switch_break___0;
    case_16___0: 
    {
#line 2030
    image___35 = tgatoimage((char const   *)(parameters___22.infile), & parameters___22);
    }
#line 2031
    if (! image___35) {
      {
#line 2032
      fprintf(stderr, "Unable to load tga file\n\220");
#line 2033
      ret___3 = 1;
      }
#line 2034
      goto fin;
    }
#line 2036
    goto switch_break___0;
    case_17___0: 
    {
#line 2040
    image___35 = pngtoimage((char const   *)(parameters___22.infile), & parameters___22);
    }
#line 2041
    if (! image___35) {
      {
#line 2042
      fprintf(stderr, "Unable to load png file\n\220");
#line 2043
      ret___3 = 1;
      }
#line 2044
      goto fin;
    }
#line 2046
    goto switch_break___0;
    switch_break___0: ;
#line 2053
    if (! image___35) {
      {
#line 2054
      fprintf(stderr, "Unable to load file: got no image\n\001");
#line 2055
      ret___3 = 1;
      }
#line 2056
      goto fin;
    }
#line 2060
    if ((int )parameters___22.tcp_mct == -1) {
#line 2062
      if (image___35->numcomps >= 3U) {
#line 2062
        tmp___521 = 1;
      } else {
#line 2062
        tmp___521 = 0;
      }
#line 2062
      parameters___22.tcp_mct = (char )tmp___521;
    } else {
#line 2064
      if ((int )parameters___22.tcp_mct == 1) {
#line 2064
        if (image___35->numcomps < 3U) {
          {
#line 2065
          fprintf(stderr, "RGB->YCC conversion cannot be used:\n");
#line 2066
          fprintf(stderr, "Input image has less than 3 components\n");
#line 2067
          ret___3 = 1;
          }
#line 2068
          goto fin;
        }
      }
#line 2070
      if (! parameters___22.mct_data) {
#line 2070
        if ((int )parameters___22.tcp_mct == 2) {
          {
#line 2071
          fprintf(stderr, "Custom MCT has been set but no array-based MCT\n");
#line 2072
          fprintf(stderr, "has been provided. Aborting.\n");
#line 2073
          ret___3 = 1;
          }
#line 2074
          goto fin;
        }
      }
    }
#line 2078
    if ((int )parameters___22.rsiz >= 1024) {
#line 2078
      if ((int )parameters___22.rsiz <= 2459) {
#line 2078
        if (framerate___0 > 0) {
#line 2079
          mainlevel___1 = (int )parameters___22.rsiz & 15;
#line 2080
          if (mainlevel___1 > 0) {
#line 2080
            if (mainlevel___1 <= 11) {
#line 2081
              limitMSamplesSec[0] = 0;
#line 2081
              limitMSamplesSec[1] = 65;
#line 2081
              limitMSamplesSec[2] = 130;
#line 2081
              limitMSamplesSec[3] = 195;
#line 2081
              limitMSamplesSec[4] = 260;
#line 2081
              limitMSamplesSec[5] = 520;
#line 2081
              limitMSamplesSec[6] = 1200;
#line 2081
              limitMSamplesSec[7] = 2400;
#line 2081
              limitMSamplesSec[8] = 4800;
#line 2081
              limitMSamplesSec[9] = 9600;
#line 2081
              limitMSamplesSec[10] = 19200;
#line 2081
              limitMSamplesSec[11] = 38400;
#line 2095
              avgcomponents = image___35->numcomps;
#line 2097
              if (image___35->numcomps == 3U) {
#line 2097
                if ((image___35->comps + 1)->dx == 2U) {
#line 2097
                  if ((image___35->comps + 1)->dy == 2U) {
#line 2100
                    avgcomponents = (OPJ_UINT32 )2;
                  }
                }
              }
#line 2102
              msamplespersec = ((((double )image___35->x1 * (double )image___35->y1) * (double )avgcomponents) * (double )framerate___0) / 1000000.;
#line 2104
              if (msamplespersec > (double )limitMSamplesSec[mainlevel___1]) {
                {
#line 2105
                fprintf(stderr, "Warning: MSamples/sec is %f, whereas limit is %d.\n",
                        msamplespersec, limitMSamplesSec[mainlevel___1]);
                }
              }
            }
          }
        }
      }
    }
#line 2117
    if (parameters___22.cod_format == 0) {
#line 2117
      goto case_0;
    }
#line 2122
    if (parameters___22.cod_format == 1) {
#line 2122
      goto case_1;
    }
#line 2127
    goto switch_default___0;
    case_0: 
    {
#line 2119
    l_codec___25 = opj_create_compress((OPJ_CODEC_FORMAT )0);
    }
#line 2120
    goto switch_break___1;
    case_1: 
    {
#line 2124
    l_codec___25 = opj_create_compress((OPJ_CODEC_FORMAT )2);
    }
#line 2125
    goto switch_break___1;
    switch_default___0: 
    {
#line 2128
    fprintf(stderr, "skipping file..\n\220");
#line 2129
    opj_stream_destroy(l_stream___18);
    }
#line 2130
    goto while_continue___0;
    switch_break___1: 
    {
#line 2134
    opj_set_info_handler(l_codec___25, & info_callback, (void *)0);
#line 2135
    opj_set_warning_handler(l_codec___25, & warning_callback, (void *)0);
#line 2136
    opj_set_error_handler(l_codec___25, & error_callback, (void *)0);
    }
#line 2138
    if (bUseTiles) {
#line 2139
      parameters___22.cp_tx0 = 0;
#line 2140
      parameters___22.cp_ty0 = 0;
#line 2141
      parameters___22.tile_size_on = 1;
#line 2142
      parameters___22.cp_tdx = 512;
#line 2143
      parameters___22.cp_tdy = 512;
    }
    {
#line 2145
    __cil_tmp47___8 = opj_setup_encoder(l_codec___25, & parameters___22, image___35);
    }
#line 2145
    if (! __cil_tmp47___8) {
      {
#line 2146
      fprintf(stderr, "failed to encode image: opj_setup_encoder\n\340\006]U");
#line 2147
      opj_destroy_codec(l_codec___25);
#line 2148
      opj_image_destroy(image___35);
#line 2149
      ret___3 = 1;
      }
#line 2150
      goto fin;
    }
#line 2153
    if (PLT) {
      {
#line 2154
      strcpy((char *)options___0[0], "PLT=YES");
#line 2154
      options___0[1] = (char const   *)((void *)0);
#line 2155
      __cil_tmp49___3 = opj_encoder_set_extra_options(l_codec___25, (char const   * const  *)(options___0));
      }
#line 2155
      if (! __cil_tmp49___3) {
        {
#line 2156
        fprintf(stderr, "failed to encode image: opj_encoder_set_extra_options\n");
#line 2157
        opj_destroy_codec(l_codec___25);
#line 2158
        opj_image_destroy(image___35);
#line 2159
        ret___3 = 1;
        }
#line 2160
        goto fin;
      }
    }
    {
#line 2164
    __cil_tmp50___2 = opj_codec_set_threads(l_codec___25, num_threads___3);
    }
#line 2164
    if (num_threads___3 >= 1) {
#line 2164
      if (! __cil_tmp50___2) {
        {
#line 2166
        fprintf(stderr, "failed to set number of threads\n\220");
#line 2167
        opj_destroy_codec(l_codec___25);
#line 2168
        opj_image_destroy(image___35);
#line 2169
        ret___3 = 1;
        }
#line 2170
        goto fin;
      }
    }
    {
#line 2174
    l_stream___18 = opj_stream_create_default_file_stream((char const   *)(parameters___22.outfile),
                                                          0);
    }
#line 2175
    if (! l_stream___18) {
#line 2176
      ret___3 = 1;
#line 2177
      goto fin;
    }
    {
#line 2181
    bSuccess = opj_start_compress(l_codec___25, image___35, l_stream___18);
    }
#line 2182
    if (! bSuccess) {
      {
#line 2183
      fprintf(stderr, "failed to encode image: opj_start_compress\n\006]U");
      }
    }
#line 2185
    if (bSuccess) {
#line 2185
      if (bUseTiles) {
        {
#line 2187
        l_data_size___2 = (OPJ_UINT32 )786432;
#line 2188
        __cil_tmp55___6 = calloc(1UL, (unsigned long )l_data_size___2);
#line 2188
        l_data___12 = (OPJ_BYTE *)__cil_tmp55___6;
        }
#line 2189
        if ((unsigned long )l_data___12 == (unsigned long )((void *)0)) {
#line 2190
          ret___3 = 1;
#line 2191
          goto fin;
        }
#line 2193
        i___154 = 0U;
        {
#line 2193
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 2193
          if (! (i___154 < l_nb_tiles___12)) {
#line 2193
            goto while_break___1;
          }
          {
#line 2194
          __cil_tmp56___6 = opj_write_tile(l_codec___25, i___154, l_data___12, l_data_size___2,
                                           l_stream___18);
          }
#line 2194
          if (! __cil_tmp56___6) {
            {
#line 2195
            fprintf(stderr, "ERROR -> test_tile_encoder: failed to write the tile %d!\n\300\340\006]U",
                    i___154);
#line 2197
            opj_stream_destroy(l_stream___18);
#line 2198
            opj_destroy_codec(l_codec___25);
#line 2199
            opj_image_destroy(image___35);
#line 2200
            ret___3 = 1;
            }
#line 2201
            goto fin;
          }
#line 2193
          i___154 ++;
        }
        while_break___4: /* CIL Label */ ;
        }

        while_break___1: 
        {
#line 2204
        free((void *)l_data___12);
        }
      } else {
#line 2185
        goto _L;
      }
    } else {
      _L: 
      {
#line 2206
      __cil_tmp57___2 = opj_encode(l_codec___25, l_stream___18);
      }
#line 2206
      if (bSuccess) {
#line 2206
        if (__cil_tmp57___2) {
#line 2206
          tmp___522 = 1;
        } else {
#line 2206
          tmp___522 = 0;
        }
      } else {
#line 2206
        tmp___522 = 0;
      }
#line 2206
      bSuccess = tmp___522;
#line 2207
      if (! bSuccess) {
        {
#line 2208
        fprintf(stderr, "failed to encode image: opj_encode\n\006]U");
        }
      }
    }
    {
#line 2211
    __cil_tmp58___1 = opj_end_compress(l_codec___25, l_stream___18);
    }
#line 2211
    if (bSuccess) {
#line 2211
      if (__cil_tmp58___1) {
#line 2211
        tmp___523 = 1;
      } else {
#line 2211
        tmp___523 = 0;
      }
    } else {
#line 2211
      tmp___523 = 0;
    }
#line 2211
    bSuccess = tmp___523;
#line 2212
    if (! bSuccess) {
      {
#line 2213
      fprintf(stderr, "failed to encode image: opj_end_compress\n");
      }
    }
#line 2216
    if (! bSuccess) {
      {
#line 2217
      opj_stream_destroy(l_stream___18);
#line 2218
      opj_destroy_codec(l_codec___25);
#line 2219
      opj_image_destroy(image___35);
#line 2220
      fprintf(stderr, "failed to encode image\n");
#line 2221
      remove((char const   *)(parameters___22.outfile));
#line 2222
      ret___3 = 1;
      }
#line 2223
      goto fin;
    }
    {
#line 2226
    num_compressed_files ++;
#line 2227
    fprintf(stdout, "[INFO] Generated outfile %s\n]U", parameters___22.outfile);
#line 2229
    opj_stream_destroy(l_stream___18);
#line 2232
    opj_destroy_codec(l_codec___25);
#line 2235
    opj_image_destroy(image___35);
#line 1937
    imageno___0 ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }

  while_break___0: 
  {
#line 2239
  __cil_tmp61___2 = opj_clock();
#line 2239
  t___1 = __cil_tmp61___2 - t___1;
  }
#line 2240
  if (num_compressed_files) {
    {
#line 2241
    fprintf(stdout, "encode time: %d ms \n]U", (int )((t___1 * 1000.) / (OPJ_FLOAT64 )num_compressed_files));
    }
  }
#line 2245
  ret___3 = 0;
  fin: 
#line 2248
  if (parameters___22.cp_comment) {
    {
#line 2249
    free((void *)parameters___22.cp_comment);
    }
  }
#line 2251
  if (parameters___22.cp_matrice) {
    {
#line 2252
    free((void *)parameters___22.cp_matrice);
    }
  }
#line 2254
  if (raw_cp___3.rawComps) {
    {
#line 2255
    free((void *)raw_cp___3.rawComps);
    }
  }
#line 2257
  if (img_fol___1.imgdirpath) {
    {
#line 2258
    free((void *)img_fol___1.imgdirpath);
    }
  }
#line 2260
  if (dirptr___1) {
#line 2261
    if (dirptr___1->filename_buf) {
      {
#line 2262
      free((void *)dirptr___1->filename_buf);
      }
    }
#line 2264
    if (dirptr___1->filename) {
      {
#line 2265
      free((void *)dirptr___1->filename);
      }
    }
    {
#line 2267
    free((void *)dirptr___1);
    }
  }
#line 2269
  return (ret___3);
}
}
#line 46 "/root/patron-new/39/src/bin/common/opj_getopt.c"
int opj_opterr  =    1;
#line 47 "/root/patron-new/39/src/bin/common/opj_getopt.c"
int opj_optind  =    1;
#line 54 "/root/patron-new/39/src/bin/common/opj_getopt.c"
static char EMSG[1]  = {      (char )'\250'};
#line 57 "/root/patron-new/39/src/bin/common/opj_getopt.c"
void opj_reset_options_reading(void) 
{ 


  {
#line 59
  opj_opterr = 1;
#line 60
  opj_optind = 1;
#line 61
  return;
}
}
#line 69 "/root/patron-new/39/src/bin/common/opj_getopt.c"
static char *place  ;
#line 67 "/root/patron-new/39/src/bin/common/opj_getopt.c"
int opj_getopt(int nargc , char * const  *nargv , char const   *ostr ) 
{ 
  char const   *oli ;
  char *__cil_tmp6___64 ;
  char *__cil_tmp7___60 ;

  {
#line 70
  place = EMSG;
#line 71
  oli = (char const   *)((void *)0);
#line 73
  if (opj_optreset) {
    _L: 
#line 74
    opj_optreset = 0;
#line 75
    place = (char *)*(nargv + opj_optind);
#line 75
    if (opj_optind >= nargc) {
#line 76
      place = EMSG;
#line 77
      return (-1);
    } else
#line 75
    if ((int )*place != 45) {
#line 76
      place = EMSG;
#line 77
      return (-1);
    }
#line 79
    place ++;
#line 79
    if ((int )*(place + 1)) {
#line 79
      if ((int )*place == 45) {
#line 80
        opj_optind ++;
#line 81
        place = EMSG;
#line 82
        return (-1);
      }
    }
  } else
#line 73
  if (! *place) {
#line 73
    goto _L;
  }
  {
#line 85
  __cil_tmp7___60 = strchr(ostr, opj_optopt);
#line 85
  oli = (char const   *)__cil_tmp7___60;
#line 85
  __cil_tmp6___64 = place;
#line 85
  place ++;
#line 85
  opj_optopt = (int )*__cil_tmp6___64;
  }
#line 85
  if (! oli) {
    _L___70: 
#line 91
    if (opj_optopt == 45) {
#line 92
      return (-1);
    }
#line 94
    if (! *place) {
#line 95
      opj_optind ++;
    }
#line 97
    if (opj_opterr) {
#line 97
      if ((int )*ostr != 58) {
        {
#line 98
        fprintf(stderr, "%s: illegal option -- %c\n", *(nargv + 0), opj_optopt);
        }
#line 100
        return ('?');
      }
    }
  } else
#line 85
  if (opj_optopt == 58) {
#line 85
    goto _L___70;
  }
#line 103
  oli ++;
#line 103
  if ((int )*oli != 58) {
#line 104
    opj_optarg = (char *)((void *)0);
#line 105
    if (! *place) {
#line 106
      opj_optind ++;
    }
  } else {
#line 109
    if (*place) {
#line 110
      opj_optarg = place;
    } else {
#line 111
      opj_optind ++;
#line 111
      if (nargc <= opj_optind) {
#line 112
        place = EMSG;
#line 113
        if ((int )*ostr == 58) {
#line 114
          return (':');
        }
#line 116
        if (opj_opterr) {
          {
#line 117
          fprintf(stderr, "%s: option requires an argument -- %c\n", *(nargv + 0),
                  opj_optopt);
          }
#line 120
          return ('?');
        }
      } else {
#line 123
        opj_optarg = (char *)*(nargv + opj_optind);
      }
    }
#line 125
    place = EMSG;
#line 126
    opj_optind ++;
  }
#line 128
  return (opj_optopt);
}
}
#line 135 "/root/patron-new/39/src/bin/common/opj_getopt.c"
static int lastidx  ;
#line 136 "/root/patron-new/39/src/bin/common/opj_getopt.c"
static int lastofs  ;
#line 132 "/root/patron-new/39/src/bin/common/opj_getopt.c"
int opj_getopt_long(int argc___1 , char * const  *argv___1 , char const   *optstring ,
                    opj_option_t *longopts , int totlen___0 ) 
{ 
  char const   *tmp___524 ;
  int i___155 ;
  int len___11 ;
  char param ;
  char *arg___0 ;
  opj_option_t *o ;
  unsigned long __cil_tmp15___45 ;
  int __cil_tmp16___50 ;
  opj_option_t *__cil_tmp17___43 ;
  char *__cil_tmp18___41 ;

  {
#line 138
  param = (char)1;
  again: 
#line 141
  if (! *(argv___1 + opj_optind)) {
#line 142
    return (-1);
  } else
#line 141
  if (opj_optind >= argc___1) {
#line 142
    return (-1);
  } else
#line 141
  if ((int )*(*(argv___1 + opj_optind)) != 45) {
#line 142
    return (-1);
  }
#line 145
  if ((int )*(*(argv___1 + opj_optind) + 0) == 45) {
#line 145
    if ((int )*(*(argv___1 + opj_optind) + 1) == 0) {
#line 146
      if (opj_optind >= argc___1 - 1) {
#line 147
        param = (char)0;
      } else
#line 149
      if ((int )*(*(argv___1 + (opj_optind + 1)) + 0) == 45) {
#line 150
        param = (char)0;
      } else {
#line 152
        param = (char)2;
      }
    }
  }
#line 157
  if ((int )param == 0) {
#line 158
    opj_optind ++;
#line 159
    return ('?');
  }
#line 162
  if ((int )*(*(argv___1 + opj_optind) + 0) == 45) {
#line 165
    o = longopts;
#line 166
    len___11 = (int )sizeof(*(longopts + 0));
#line 168
    if ((int )param > 1) {
#line 169
      if (opj_optind + 1 >= argc___1) {
#line 170
        return (-1);
      }
#line 172
      arg___0 = (char *)*(argv___1 + (opj_optind + 1));
#line 173
      opj_optind ++;
    } else {
#line 175
      arg___0 = (char *)(*(argv___1 + opj_optind) + 1);
    }
    {
#line 178
    __cil_tmp15___45 = strlen((char const   *)arg___0);
    }
#line 178
    if (__cil_tmp15___45 > 1UL) {
#line 179
      i___155 = 0;
      {
#line 179
      while (1) {
        while_continue: /* CIL Label */ ;

#line 179
        if (! (i___155 < totlen___0)) {
#line 179
          goto while_break;
        }
        {
#line 180
        __cil_tmp16___50 = strcmp(o->name, (char const   *)arg___0);
        }
#line 180
        if (! __cil_tmp16___50) {
#line 181
          if (o->has_arg == 0) {
#line 182
            if (*(argv___1 + (opj_optind + 1))) {
#line 182
              if (! ((int )*(*(argv___1 + (opj_optind + 1)) + 0) == 45)) {
                {
#line 183
                fprintf(stderr, "%s: option does not require an argument. Ignoring %s\nU",
                        arg___0, *(argv___1 + (opj_optind + 1)));
#line 185
                opj_optind ++;
                }
              }
            }
          } else {
#line 188
            opj_optarg = (char *)*(argv___1 + (opj_optind + 1));
#line 189
            if (opj_optarg) {
#line 190
              if ((int )*(opj_optarg + 0) == 45) {
#line 192
                if (opj_opterr) {
                  {
#line 193
                  fprintf(stderr, "%s: option requires an argument\n\230\001", arg___0);
                  }
#line 194
                  return ('?');
                }
              }
            }
#line 198
            if (! opj_optarg) {
#line 198
              if (o->has_arg == 1) {
#line 199
                if (opj_opterr) {
                  {
#line 200
                  fprintf(stderr, "%s: option requires an argument \n", arg___0);
                  }
#line 201
                  return ('?');
                }
              }
            }
#line 204
            opj_optind ++;
          }
#line 206
          opj_optind ++;
#line 207
          if (o->flag) {
#line 208
            *(o->flag) = o->val;
          } else {
#line 210
            return (o->val);
          }
#line 212
          return (0);
        }
#line 179
        __cil_tmp17___43 = o;
#line 179
        o ++;
#line 179
        i___155 += len___11;
      }
      while_break___0: /* CIL Label */ ;
      }

      while_break: 
      {
#line 215
      fprintf(stderr, "Invalid option %s\n", arg___0);
#line 216
      opj_optind ++;
      }
#line 217
      return ('?');
    } else {
#line 219
      if ((int )*optstring == 58) {
#line 220
        return (':');
      }
#line 222
      if (lastidx != opj_optind) {
#line 223
        lastidx = opj_optind;
#line 224
        lastofs = 0;
      }
      {
#line 226
      opj_optopt = (int )*(*(argv___1 + opj_optind) + (lastofs + 1));
#line 227
      __cil_tmp18___41 = strchr(optstring, opj_optopt);
#line 227
      tmp___524 = (char const   *)__cil_tmp18___41;
      }
#line 227
      if (tmp___524) {
#line 228
        if ((int )*tmp___524 == 0) {
#line 229
          opj_optind ++;
#line 230
          goto again;
        }
#line 232
        if ((int )*(tmp___524 + 1) == 58) {
#line 233
          if ((int )*(tmp___524 + 2) == 58) {
            _L: 
#line 235
            opj_optarg = (char *)((*(argv___1 + opj_optind) + lastofs) + 2);
#line 235
            if (! *opj_optarg) {
#line 236
              opj_optarg = (char *)0;
            }
#line 238
            goto found;
          } else
#line 233
          if ((int )*(*(argv___1 + opj_optind) + (lastofs + 2))) {
#line 233
            goto _L;
          }
#line 240
          opj_optarg = (char *)*(argv___1 + (opj_optind + 1));
#line 241
          if (opj_optarg) {
#line 242
            if ((int )*(opj_optarg + 0) == 45) {
#line 244
              if (opj_opterr) {
                {
#line 245
                fprintf(stderr, "%s: option requires an argument\n\230\001", arg___0);
#line 246
                opj_optind ++;
                }
#line 247
                return ('?');
              }
            }
          }
#line 251
          if (! opj_optarg) {
#line 252
            if (opj_opterr) {
              {
#line 253
              fprintf(stderr, "%s: option requires an argument\n\230\001", arg___0);
#line 254
              opj_optind ++;
              }
#line 255
              return ('?');
            }
          }
#line 258
          opj_optind ++;
        } else {
#line 260
          lastofs ++;
#line 261
          return (opj_optopt);
        }
        found: 
#line 264
        opj_optind ++;
#line 265
        return (opj_optopt);
      } else {
        {
#line 267
        fprintf(stderr, "Invalid option %s\n", arg___0);
#line 268
        opj_optind ++;
        }
#line 269
        return ('?');
      }
    }
  }
  {
#line 274
  fprintf(stderr, "Invalid option\n");
#line 275
  opj_optind ++;
  }
#line 276
  return ('?');
}
}
#line 41 "/root/patron-new/39/src/bin/common/color.h"
void color_sycc_to_rgb(opj_image_t *img___2 ) ;
#line 45
void color_cmyk_to_rgb(opj_image_t *image___36 ) ;
#line 46
void color_esycc_to_rgb(opj_image_t *image___37 ) ;
#line 74 "/root/patron-new/39/src/bin/common/color.c"
static void sycc_to_rgb(int offset___0 , int upb , int y___11 , int cb , int cr ,
                        int *out_r , int *out_g , int *out_b ) 
{ 
  int r___4 ;
  int g___3 ;
  int b___4 ;

  {
#line 79
  cb -= offset___0;
#line 80
  cr -= offset___0;
#line 81
  r___4 = y___11 + (int )(1.402 * (double )((float )cr));
#line 82
  if (r___4 < 0) {
#line 83
    r___4 = 0;
  } else
#line 84
  if (r___4 > upb) {
#line 85
    r___4 = upb;
  }
#line 87
  *out_r = r___4;
#line 89
  g___3 = y___11 - (int )(0.344 * (double )((float )cb) + 0.714 * (double )((float )cr));
#line 90
  if (g___3 < 0) {
#line 91
    g___3 = 0;
  } else
#line 92
  if (g___3 > upb) {
#line 93
    g___3 = upb;
  }
#line 95
  *out_g = g___3;
#line 97
  b___4 = y___11 + (int )(1.77200000001 * (double )((float )cb));
#line 98
  if (b___4 < 0) {
#line 99
    b___4 = 0;
  } else
#line 100
  if (b___4 > upb) {
#line 101
    b___4 = upb;
  }
#line 103
  *out_b = b___4;
#line 104
  return;
}
}
#line 106 "/root/patron-new/39/src/bin/common/color.c"
static void sycc444_to_rgb(opj_image_t *img ) 
{ 
  int *d0 ;
  int *d1 ;
  int *d2 ;
  int *r___5 ;
  int *g___4 ;
  int *b___5 ;
  int const   *y___12 ;
  int const   *cb___0 ;
  int const   *cr___0 ;
  size_t maxw ;
  size_t maxh ;
  size_t max___3 ;
  size_t i___156 ;
  int offset___1 ;
  int upb___0 ;
  void *__cil_tmp17___44 ;
  void *__cil_tmp18___42 ;
  void *__cil_tmp19___45 ;

  {
  {
#line 113
  upb___0 = (int )(img->comps + 0)->prec;
#line 114
  offset___1 = 1 << (upb___0 - 1);
#line 115
  upb___0 = (1 << upb___0) - 1;
#line 117
  maxw = (size_t )(img->comps + 0)->w;
#line 118
  maxh = (size_t )(img->comps + 0)->h;
#line 119
  max___3 = maxw * maxh;
#line 121
  y___12 = (int const   *)(img->comps + 0)->data;
#line 122
  cb___0 = (int const   *)(img->comps + 1)->data;
#line 123
  cr___0 = (int const   *)(img->comps + 2)->data;
#line 125
  __cil_tmp17___44 = opj_image_data_alloc(sizeof(int ) * max___3);
#line 125
  r___5 = (int *)__cil_tmp17___44;
#line 125
  d0 = r___5;
#line 126
  __cil_tmp18___42 = opj_image_data_alloc(sizeof(int ) * max___3);
#line 126
  g___4 = (int *)__cil_tmp18___42;
#line 126
  d1 = g___4;
#line 127
  __cil_tmp19___45 = opj_image_data_alloc(sizeof(int ) * max___3);
#line 127
  b___5 = (int *)__cil_tmp19___45;
#line 127
  d2 = b___5;
  }
#line 129
  if ((unsigned long )r___5 == (unsigned long )((void *)0)) {
#line 130
    goto fails;
  } else
#line 129
  if ((unsigned long )g___4 == (unsigned long )((void *)0)) {
#line 130
    goto fails;
  } else
#line 129
  if ((unsigned long )b___5 == (unsigned long )((void *)0)) {
#line 130
    goto fails;
  }
#line 133
  i___156 = (size_t )0U;
  {
#line 133
  while (1) {
    while_continue: /* CIL Label */ ;

#line 133
    if (! (i___156 < max___3)) {
#line 133
      goto while_break;
    }
    {
#line 134
    sycc_to_rgb(offset___1, upb___0, (int )*y___12, (int )*cb___0, (int )*cr___0,
                r___5, g___4, b___5);
#line 135
    y___12 ++;
#line 136
    cb___0 ++;
#line 137
    cr___0 ++;
#line 138
    r___5 ++;
#line 139
    g___4 ++;
#line 140
    b___5 ++;
#line 133
    i___156 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: 
  {
#line 142
  opj_image_data_free((void *)(img->comps + 0)->data);
#line 143
  (img->comps + 0)->data = d0;
#line 144
  opj_image_data_free((void *)(img->comps + 1)->data);
#line 145
  (img->comps + 1)->data = d1;
#line 146
  opj_image_data_free((void *)(img->comps + 2)->data);
#line 147
  (img->comps + 2)->data = d2;
#line 148
  img->color_space = (OPJ_COLOR_SPACE )1;
  }
#line 149
  return;
  fails: 
  {
#line 152
  opj_image_data_free((void *)r___5);
#line 153
  opj_image_data_free((void *)g___4);
#line 154
  opj_image_data_free((void *)b___5);
  }
#line 156
  return;
}
}
#line 157 "/root/patron-new/39/src/bin/common/color.c"
static void sycc422_to_rgb(opj_image_t *img___0 ) 
{ 
  int *d0___0 ;
  int *d1___0 ;
  int *d2___0 ;
  int *r___6 ;
  int *g___5 ;
  int *b___6 ;
  int const   *y___13 ;
  int const   *cb___1 ;
  int const   *cr___1 ;
  size_t maxw___0 ;
  size_t maxh___0 ;
  size_t max___4 ;
  size_t offx ;
  size_t loopmaxw ;
  int offset___2 ;
  int upb___1 ;
  size_t i___157 ;
  void *__cil_tmp19___46 ;
  void *__cil_tmp20___50 ;
  void *__cil_tmp21___31 ;
  size_t j___22 ;

  {
  {
#line 165
  upb___1 = (int )(img___0->comps + 0)->prec;
#line 166
  offset___2 = 1 << (upb___1 - 1);
#line 167
  upb___1 = (1 << upb___1) - 1;
#line 169
  maxw___0 = (size_t )(img___0->comps + 0)->w;
#line 170
  maxh___0 = (size_t )(img___0->comps + 0)->h;
#line 171
  max___4 = maxw___0 * maxh___0;
#line 173
  y___13 = (int const   *)(img___0->comps + 0)->data;
#line 174
  cb___1 = (int const   *)(img___0->comps + 1)->data;
#line 175
  cr___1 = (int const   *)(img___0->comps + 2)->data;
#line 177
  __cil_tmp19___46 = opj_image_data_alloc(sizeof(int ) * max___4);
#line 177
  r___6 = (int *)__cil_tmp19___46;
#line 177
  d0___0 = r___6;
#line 178
  __cil_tmp20___50 = opj_image_data_alloc(sizeof(int ) * max___4);
#line 178
  g___5 = (int *)__cil_tmp20___50;
#line 178
  d1___0 = g___5;
#line 179
  __cil_tmp21___31 = opj_image_data_alloc(sizeof(int ) * max___4);
#line 179
  b___6 = (int *)__cil_tmp21___31;
#line 179
  d2___0 = b___6;
  }
#line 181
  if ((unsigned long )r___6 == (unsigned long )((void *)0)) {
#line 182
    goto fails;
  } else
#line 181
  if ((unsigned long )g___5 == (unsigned long )((void *)0)) {
#line 182
    goto fails;
  } else
#line 181
  if ((unsigned long )b___6 == (unsigned long )((void *)0)) {
#line 182
    goto fails;
  }
#line 186
  offx = (size_t )(img___0->x0 & 1U);
#line 187
  loopmaxw = maxw___0 - offx;
#line 189
  i___157 = (size_t )0U;
  {
#line 189
  while (1) {
    while_continue: /* CIL Label */ ;

#line 189
    if (! (i___157 < maxh___0)) {
#line 189
      goto while_break;
    }
#line 192
    if (offx > 0UL) {
      {
#line 193
      sycc_to_rgb(offset___2, upb___1, (int )*y___13, 0, 0, r___6, g___5, b___6);
#line 194
      y___13 ++;
#line 195
      r___6 ++;
#line 196
      g___5 ++;
#line 197
      b___6 ++;
      }
    }
#line 200
    j___22 = (size_t )0U;
    {
#line 200
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 200
      if (! (j___22 < (loopmaxw & 0xfffffffffffffffeUL))) {
#line 200
        goto while_break___0;
      }
      {
#line 201
      sycc_to_rgb(offset___2, upb___1, (int )*y___13, (int )*cb___1, (int )*cr___1,
                  r___6, g___5, b___6);
#line 202
      y___13 ++;
#line 203
      r___6 ++;
#line 204
      g___5 ++;
#line 205
      b___6 ++;
#line 206
      sycc_to_rgb(offset___2, upb___1, (int )*y___13, (int )*cb___1, (int )*cr___1,
                  r___6, g___5, b___6);
#line 207
      y___13 ++;
#line 208
      r___6 ++;
#line 209
      g___5 ++;
#line 210
      b___6 ++;
#line 211
      cb___1 ++;
#line 212
      cr___1 ++;
#line 200
      j___22 += 2UL;
      }
    }
    while_break___2: /* CIL Label */ ;
    }

    while_break___0: ;
#line 214
    if (j___22 < loopmaxw) {
      {
#line 215
      sycc_to_rgb(offset___2, upb___1, (int )*y___13, (int )*cb___1, (int )*cr___1,
                  r___6, g___5, b___6);
#line 216
      y___13 ++;
#line 217
      r___6 ++;
#line 218
      g___5 ++;
#line 219
      b___6 ++;
#line 220
      cb___1 ++;
#line 221
      cr___1 ++;
      }
    }
#line 189
    i___157 ++;
  }
  while_break___1: /* CIL Label */ ;
  }

  while_break: 
  {
#line 225
  opj_image_data_free((void *)(img___0->comps + 0)->data);
#line 226
  (img___0->comps + 0)->data = d0___0;
#line 227
  opj_image_data_free((void *)(img___0->comps + 1)->data);
#line 228
  (img___0->comps + 1)->data = d1___0;
#line 229
  opj_image_data_free((void *)(img___0->comps + 2)->data);
#line 230
  (img___0->comps + 2)->data = d2___0;
#line 232
  (img___0->comps + 2)->w = (img___0->comps + 0)->w;
#line 232
  (img___0->comps + 1)->w = (img___0->comps + 2)->w;
#line 233
  (img___0->comps + 2)->h = (img___0->comps + 0)->h;
#line 233
  (img___0->comps + 1)->h = (img___0->comps + 2)->h;
#line 234
  (img___0->comps + 2)->dx = (img___0->comps + 0)->dx;
#line 234
  (img___0->comps + 1)->dx = (img___0->comps + 2)->dx;
#line 235
  (img___0->comps + 2)->dy = (img___0->comps + 0)->dy;
#line 235
  (img___0->comps + 1)->dy = (img___0->comps + 2)->dy;
#line 236
  img___0->color_space = (OPJ_COLOR_SPACE )1;
  }
#line 237
  return;
  fails: 
  {
#line 240
  opj_image_data_free((void *)r___6);
#line 241
  opj_image_data_free((void *)g___5);
#line 242
  opj_image_data_free((void *)b___6);
  }
#line 244
  return;
}
}
#line 245 "/root/patron-new/39/src/bin/common/color.c"
static void sycc420_to_rgb(opj_image_t *img___1 ) 
{ 
  int *d0___1 ;
  int *d1___1 ;
  int *d2___1 ;
  int *r___7 ;
  int *g___6 ;
  int *b___7 ;
  int *nr ;
  int *ng ;
  int *nb ;
  int const   *y___14 ;
  int const   *cb___2 ;
  int const   *cr___2 ;
  int const   *ny ;
  size_t maxw___1 ;
  size_t maxh___1 ;
  size_t max___5 ;
  size_t offx___0 ;
  size_t loopmaxw___0 ;
  size_t offy ;
  size_t loopmaxh ;
  int offset___3 ;
  int upb___2 ;
  size_t i___158 ;
  void *__cil_tmp25___30 ;
  void *__cil_tmp26___33 ;
  void *__cil_tmp27___25 ;
  size_t j___23 ;
  size_t j___24 ;
  size_t j___25 ;

  {
  {
#line 253
  upb___2 = (int )(img___1->comps + 0)->prec;
#line 254
  offset___3 = 1 << (upb___2 - 1);
#line 255
  upb___2 = (1 << upb___2) - 1;
#line 257
  maxw___1 = (size_t )(img___1->comps + 0)->w;
#line 258
  maxh___1 = (size_t )(img___1->comps + 0)->h;
#line 259
  max___5 = maxw___1 * maxh___1;
#line 261
  y___14 = (int const   *)(img___1->comps + 0)->data;
#line 262
  cb___2 = (int const   *)(img___1->comps + 1)->data;
#line 263
  cr___2 = (int const   *)(img___1->comps + 2)->data;
#line 265
  __cil_tmp25___30 = opj_image_data_alloc(sizeof(int ) * max___5);
#line 265
  r___7 = (int *)__cil_tmp25___30;
#line 265
  d0___1 = r___7;
#line 266
  __cil_tmp26___33 = opj_image_data_alloc(sizeof(int ) * max___5);
#line 266
  g___6 = (int *)__cil_tmp26___33;
#line 266
  d1___1 = g___6;
#line 267
  __cil_tmp27___25 = opj_image_data_alloc(sizeof(int ) * max___5);
#line 267
  b___7 = (int *)__cil_tmp27___25;
#line 267
  d2___1 = b___7;
  }
#line 269
  if ((unsigned long )r___7 == (unsigned long )((void *)0)) {
#line 270
    goto fails;
  } else
#line 269
  if ((unsigned long )g___6 == (unsigned long )((void *)0)) {
#line 270
    goto fails;
  } else
#line 269
  if ((unsigned long )b___7 == (unsigned long )((void *)0)) {
#line 270
    goto fails;
  }
#line 274
  offx___0 = (size_t )(img___1->x0 & 1U);
#line 275
  loopmaxw___0 = maxw___1 - offx___0;
#line 277
  offy = (size_t )(img___1->y0 & 1U);
#line 278
  loopmaxh = maxh___1 - offy;
#line 280
  if (offy > 0UL) {
#line 283
    j___23 = (size_t )0;
    {
#line 283
    while (1) {
      while_continue: /* CIL Label */ ;

#line 283
      if (! (j___23 < maxw___1)) {
#line 283
        goto while_break;
      }
      {
#line 284
      sycc_to_rgb(offset___3, upb___2, (int )*y___14, 0, 0, r___7, g___6, b___7);
#line 285
      y___14 ++;
#line 286
      r___7 ++;
#line 287
      g___6 ++;
#line 288
      b___7 ++;
#line 283
      j___23 ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }

    while_break: ;
  }
#line 292
  i___158 = (size_t )0U;
  {
#line 292
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 292
    if (! (i___158 < (loopmaxh & 0xfffffffffffffffeUL))) {
#line 292
      goto while_break___0;
    }
#line 295
    ny = y___14 + maxw___1;
#line 296
    nr = r___7 + maxw___1;
#line 297
    ng = g___6 + maxw___1;
#line 298
    nb = b___7 + maxw___1;
#line 300
    if (offx___0 > 0UL) {
      {
#line 301
      sycc_to_rgb(offset___3, upb___2, (int )*y___14, 0, 0, r___7, g___6, b___7);
#line 302
      y___14 ++;
#line 303
      r___7 ++;
#line 304
      g___6 ++;
#line 305
      b___7 ++;
#line 306
      sycc_to_rgb(offset___3, upb___2, (int )*ny, (int )*cb___2, (int )*cr___2, nr,
                  ng, nb);
#line 307
      ny ++;
#line 308
      nr ++;
#line 309
      ng ++;
#line 310
      nb ++;
      }
    }
#line 313
    j___24 = (size_t )0;
    {
#line 313
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 313
      if (! (j___24 < (loopmaxw___0 & 0xfffffffffffffffeUL))) {
#line 313
        goto while_break___1;
      }
      {
#line 314
      sycc_to_rgb(offset___3, upb___2, (int )*y___14, (int )*cb___2, (int )*cr___2,
                  r___7, g___6, b___7);
#line 315
      y___14 ++;
#line 316
      r___7 ++;
#line 317
      g___6 ++;
#line 318
      b___7 ++;
#line 319
      sycc_to_rgb(offset___3, upb___2, (int )*y___14, (int )*cb___2, (int )*cr___2,
                  r___7, g___6, b___7);
#line 320
      y___14 ++;
#line 321
      r___7 ++;
#line 322
      g___6 ++;
#line 323
      b___7 ++;
#line 325
      sycc_to_rgb(offset___3, upb___2, (int )*ny, (int )*cb___2, (int )*cr___2, nr,
                  ng, nb);
#line 326
      ny ++;
#line 327
      nr ++;
#line 328
      ng ++;
#line 329
      nb ++;
#line 330
      sycc_to_rgb(offset___3, upb___2, (int )*ny, (int )*cb___2, (int )*cr___2, nr,
                  ng, nb);
#line 331
      ny ++;
#line 332
      nr ++;
#line 333
      ng ++;
#line 334
      nb ++;
#line 335
      cb___2 ++;
#line 336
      cr___2 ++;
#line 313
      j___24 += 2UL;
      }
    }
    while_break___5: /* CIL Label */ ;
    }

    while_break___1: ;
#line 338
    if (j___24 < loopmaxw___0) {
      {
#line 339
      sycc_to_rgb(offset___3, upb___2, (int )*y___14, (int )*cb___2, (int )*cr___2,
                  r___7, g___6, b___7);
#line 340
      y___14 ++;
#line 341
      r___7 ++;
#line 342
      g___6 ++;
#line 343
      b___7 ++;
#line 345
      sycc_to_rgb(offset___3, upb___2, (int )*ny, (int )*cb___2, (int )*cr___2, nr,
                  ng, nb);
#line 346
      ny ++;
#line 347
      nr ++;
#line 348
      ng ++;
#line 349
      nb ++;
#line 350
      cb___2 ++;
#line 351
      cr___2 ++;
      }
    }
#line 353
    y___14 += maxw___1;
#line 354
    r___7 += maxw___1;
#line 355
    g___6 += maxw___1;
#line 356
    b___7 += maxw___1;
#line 292
    i___158 += 2UL;
  }
  while_break___4: /* CIL Label */ ;
  }

  while_break___0: ;
#line 358
  if (i___158 < loopmaxh) {
#line 361
    j___25 = (size_t )0U;
    {
#line 361
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 361
      if (! (j___25 < (maxw___1 & 0xfffffffffffffffeUL))) {
#line 361
        goto while_break___2;
      }
      {
#line 362
      sycc_to_rgb(offset___3, upb___2, (int )*y___14, (int )*cb___2, (int )*cr___2,
                  r___7, g___6, b___7);
#line 364
      y___14 ++;
#line 365
      r___7 ++;
#line 366
      g___6 ++;
#line 367
      b___7 ++;
#line 369
      sycc_to_rgb(offset___3, upb___2, (int )*y___14, (int )*cb___2, (int )*cr___2,
                  r___7, g___6, b___7);
#line 371
      y___14 ++;
#line 372
      r___7 ++;
#line 373
      g___6 ++;
#line 374
      b___7 ++;
#line 375
      cb___2 ++;
#line 376
      cr___2 ++;
#line 361
      j___25 += 2UL;
      }
    }
    while_break___6: /* CIL Label */ ;
    }

    while_break___2: ;
#line 378
    if (j___25 < maxw___1) {
      {
#line 379
      sycc_to_rgb(offset___3, upb___2, (int )*y___14, (int )*cb___2, (int )*cr___2,
                  r___7, g___6, b___7);
      }
    }
  }
  {
#line 383
  opj_image_data_free((void *)(img___1->comps + 0)->data);
#line 384
  (img___1->comps + 0)->data = d0___1;
#line 385
  opj_image_data_free((void *)(img___1->comps + 1)->data);
#line 386
  (img___1->comps + 1)->data = d1___1;
#line 387
  opj_image_data_free((void *)(img___1->comps + 2)->data);
#line 388
  (img___1->comps + 2)->data = d2___1;
#line 390
  (img___1->comps + 2)->w = (img___1->comps + 0)->w;
#line 390
  (img___1->comps + 1)->w = (img___1->comps + 2)->w;
#line 391
  (img___1->comps + 2)->h = (img___1->comps + 0)->h;
#line 391
  (img___1->comps + 1)->h = (img___1->comps + 2)->h;
#line 392
  (img___1->comps + 2)->dx = (img___1->comps + 0)->dx;
#line 392
  (img___1->comps + 1)->dx = (img___1->comps + 2)->dx;
#line 393
  (img___1->comps + 2)->dy = (img___1->comps + 0)->dy;
#line 393
  (img___1->comps + 1)->dy = (img___1->comps + 2)->dy;
#line 394
  img___1->color_space = (OPJ_COLOR_SPACE )1;
  }
#line 395
  return;
  fails: 
  {
#line 398
  opj_image_data_free((void *)r___7);
#line 399
  opj_image_data_free((void *)g___6);
#line 400
  opj_image_data_free((void *)b___7);
  }
#line 402
  return;
}
}
#line 403 "/root/patron-new/39/src/bin/common/color.c"
void color_sycc_to_rgb(opj_image_t *img___2 ) 
{ 


  {
#line 405
  if (img___2->numcomps < 3U) {
#line 406
    img___2->color_space = (OPJ_COLOR_SPACE )2;
#line 407
    return;
  }
#line 410
  if ((img___2->comps + 0)->dx == 1U) {
#line 410
    if ((img___2->comps + 1)->dx == 2U) {
#line 410
      if ((img___2->comps + 2)->dx == 2U) {
#line 410
        if ((img___2->comps + 0)->dy == 1U) {
#line 410
          if ((img___2->comps + 1)->dy == 2U) {
#line 410
            if ((img___2->comps + 2)->dy == 2U) {
              {
#line 416
              sycc420_to_rgb(img___2);
              }
            } else {
#line 410
              goto _L___75;
            }
          } else {
#line 410
            goto _L___75;
          }
        } else {
#line 410
          goto _L___75;
        }
      } else {
#line 410
        goto _L___75;
      }
    } else {
#line 410
      goto _L___75;
    }
  } else
  _L___75: 
#line 417
  if ((img___2->comps + 0)->dx == 1U) {
#line 417
    if ((img___2->comps + 1)->dx == 2U) {
#line 417
      if ((img___2->comps + 2)->dx == 2U) {
#line 417
        if ((img___2->comps + 0)->dy == 1U) {
#line 417
          if ((img___2->comps + 1)->dy == 1U) {
#line 417
            if ((img___2->comps + 2)->dy == 1U) {
              {
#line 423
              sycc422_to_rgb(img___2);
              }
            } else {
#line 417
              goto _L;
            }
          } else {
#line 417
            goto _L;
          }
        } else {
#line 417
          goto _L;
        }
      } else {
#line 417
        goto _L;
      }
    } else {
#line 417
      goto _L;
    }
  } else
  _L: 
#line 424
  if ((img___2->comps + 0)->dx == 1U) {
#line 424
    if ((img___2->comps + 1)->dx == 1U) {
#line 424
      if ((img___2->comps + 2)->dx == 1U) {
#line 424
        if ((img___2->comps + 0)->dy == 1U) {
#line 424
          if ((img___2->comps + 1)->dy == 1U) {
#line 424
            if ((img___2->comps + 2)->dy == 1U) {
              {
#line 430
              sycc444_to_rgb(img___2);
              }
            } else {
              {
#line 432
              fprintf(stderr, "%s:%d:color_sycc_to_rgb\n\tCAN NOT CONVERT\n", "/root/patron-new/39/src/bin/common/color.c",
                      433);
              }
#line 434
              return;
            }
          } else {
            {
#line 432
            fprintf(stderr, "%s:%d:color_sycc_to_rgb\n\tCAN NOT CONVERT\n", "/root/patron-new/39/src/bin/common/color.c",
                    433);
            }
#line 434
            return;
          }
        } else {
          {
#line 432
          fprintf(stderr, "%s:%d:color_sycc_to_rgb\n\tCAN NOT CONVERT\n", "/root/patron-new/39/src/bin/common/color.c",
                  433);
          }
#line 434
          return;
        }
      } else {
        {
#line 432
        fprintf(stderr, "%s:%d:color_sycc_to_rgb\n\tCAN NOT CONVERT\n", "/root/patron-new/39/src/bin/common/color.c",
                433);
        }
#line 434
        return;
      }
    } else {
      {
#line 432
      fprintf(stderr, "%s:%d:color_sycc_to_rgb\n\tCAN NOT CONVERT\n", "/root/patron-new/39/src/bin/common/color.c",
              433);
      }
#line 434
      return;
    }
  } else {
    {
#line 432
    fprintf(stderr, "%s:%d:color_sycc_to_rgb\n\tCAN NOT CONVERT\n", "/root/patron-new/39/src/bin/common/color.c",
            433);
    }
#line 434
    return;
  }
#line 436
  return;
}
}
#line 1004 "/root/patron-new/39/src/bin/common/color.c"
void color_cmyk_to_rgb(opj_image_t *image___36 ) 
{ 
  float C ;
  float M ;
  float Y ;
  float K ;
  float sC ;
  float sM ;
  float sY ;
  float sK ;
  unsigned int w___6 ;
  unsigned int h___6 ;
  unsigned int max___6 ;
  unsigned int i___159 ;

  {
#line 1010
  w___6 = (image___36->comps + 0)->w;
#line 1011
  h___6 = (image___36->comps + 0)->h;
#line 1013
  if (image___36->numcomps < 4U) {
    {
#line 1022
    fprintf(stderr, "%s:%d:color_cmyk_to_rgb\n\tCAN NOT CONVERT\n", "/root/patron-new/39/src/bin/common/color.c",
            1023);
    }
#line 1024
    return;
  } else
#line 1013
  if ((image___36->comps + 0)->dx != (image___36->comps + 1)->dx) {
    {
#line 1022
    fprintf(stderr, "%s:%d:color_cmyk_to_rgb\n\tCAN NOT CONVERT\n", "/root/patron-new/39/src/bin/common/color.c",
            1023);
    }
#line 1024
    return;
  } else
#line 1013
  if ((image___36->comps + 0)->dx != (image___36->comps + 2)->dx) {
    {
#line 1022
    fprintf(stderr, "%s:%d:color_cmyk_to_rgb\n\tCAN NOT CONVERT\n", "/root/patron-new/39/src/bin/common/color.c",
            1023);
    }
#line 1024
    return;
  } else
#line 1013
  if ((image___36->comps + 0)->dx != (image___36->comps + 3)->dx) {
    {
#line 1022
    fprintf(stderr, "%s:%d:color_cmyk_to_rgb\n\tCAN NOT CONVERT\n", "/root/patron-new/39/src/bin/common/color.c",
            1023);
    }
#line 1024
    return;
  } else
#line 1013
  if ((image___36->comps + 0)->dy != (image___36->comps + 1)->dy) {
    {
#line 1022
    fprintf(stderr, "%s:%d:color_cmyk_to_rgb\n\tCAN NOT CONVERT\n", "/root/patron-new/39/src/bin/common/color.c",
            1023);
    }
#line 1024
    return;
  } else
#line 1013
  if ((image___36->comps + 0)->dy != (image___36->comps + 2)->dy) {
    {
#line 1022
    fprintf(stderr, "%s:%d:color_cmyk_to_rgb\n\tCAN NOT CONVERT\n", "/root/patron-new/39/src/bin/common/color.c",
            1023);
    }
#line 1024
    return;
  } else
#line 1013
  if ((image___36->comps + 0)->dy != (image___36->comps + 3)->dy) {
    {
#line 1022
    fprintf(stderr, "%s:%d:color_cmyk_to_rgb\n\tCAN NOT CONVERT\n", "/root/patron-new/39/src/bin/common/color.c",
            1023);
    }
#line 1024
    return;
  }
#line 1027
  max___6 = w___6 * h___6;
#line 1029
  sC = 1.f / (float )((1 << (image___36->comps + 0)->prec) - 1);
#line 1030
  sM = 1.f / (float )((1 << (image___36->comps + 1)->prec) - 1);
#line 1031
  sY = 1.f / (float )((1 << (image___36->comps + 2)->prec) - 1);
#line 1032
  sK = 1.f / (float )((1 << (image___36->comps + 3)->prec) - 1);
#line 1034
  i___159 = 0U;
  {
#line 1034
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1034
    if (! (i___159 < max___6)) {
#line 1034
      goto while_break;
    }
#line 1036
    C = (float )*((image___36->comps + 0)->data + i___159) * sC;
#line 1037
    M = (float )*((image___36->comps + 1)->data + i___159) * sM;
#line 1038
    Y = (float )*((image___36->comps + 2)->data + i___159) * sY;
#line 1039
    K = (float )*((image___36->comps + 3)->data + i___159) * sK;
#line 1042
    C = 1.f - C;
#line 1043
    M = 1.f - M;
#line 1044
    Y = 1.f - Y;
#line 1045
    K = 1.f - K;
#line 1048
    *((image___36->comps + 0)->data + i___159) = (int )((255.f * C) * K);
#line 1049
    *((image___36->comps + 1)->data + i___159) = (int )((255.f * M) * K);
#line 1050
    *((image___36->comps + 2)->data + i___159) = (int )((255.f * Y) * K);
#line 1034
    i___159 ++;
  }
  while_break___1: /* CIL Label */ ;
  }

  while_break: 
  {
#line 1053
  opj_image_data_free((void *)(image___36->comps + 3)->data);
#line 1054
  (image___36->comps + 3)->data = (OPJ_INT32 *)((void *)0);
#line 1055
  (image___36->comps + 0)->prec = (OPJ_UINT32 )8;
#line 1056
  (image___36->comps + 1)->prec = (OPJ_UINT32 )8;
#line 1057
  (image___36->comps + 2)->prec = (OPJ_UINT32 )8;
#line 1058
  (image___36->numcomps) --;
#line 1059
  image___36->color_space = (OPJ_COLOR_SPACE )1;
#line 1061
  i___159 = 3U;
  }
  {
#line 1061
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 1061
    if (! (i___159 < image___36->numcomps)) {
#line 1061
      goto while_break___0;
    }
    {
#line 1062
    memcpy((void *)(image___36->comps + i___159), (void const   *)(image___36->comps + (i___159 + 1U)),
           sizeof(*(image___36->comps + i___159)));
#line 1061
    i___159 ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }

  while_break___0: ;
#line 1065
  return;
}
}
#line 1070 "/root/patron-new/39/src/bin/common/color.c"
void color_esycc_to_rgb(opj_image_t *image___37 ) 
{ 
  int y___15 ;
  int cb___3 ;
  int cr___3 ;
  int sign1 ;
  int sign2 ;
  int val___15 ;
  unsigned int w___7 ;
  unsigned int h___7 ;
  unsigned int max___7 ;
  unsigned int i___160 ;
  int flip_value ;
  int max_value ;

  {
#line 1074
  flip_value = 1 << ((image___37->comps + 0)->prec - 1U);
#line 1075
  max_value = (1 << (image___37->comps + 0)->prec) - 1;
#line 1077
  if (image___37->numcomps < 3U) {
    {
#line 1084
    fprintf(stderr, "%s:%d:color_esycc_to_rgb\n\tCAN NOT CONVERT\n", "/root/patron-new/39/src/bin/common/color.c\372\006]U",
            1085);
    }
#line 1086
    return;
  } else
#line 1077
  if ((image___37->comps + 0)->dx != (image___37->comps + 1)->dx) {
    {
#line 1084
    fprintf(stderr, "%s:%d:color_esycc_to_rgb\n\tCAN NOT CONVERT\n", "/root/patron-new/39/src/bin/common/color.c\372\006]U",
            1085);
    }
#line 1086
    return;
  } else
#line 1077
  if ((image___37->comps + 0)->dx != (image___37->comps + 2)->dx) {
    {
#line 1084
    fprintf(stderr, "%s:%d:color_esycc_to_rgb\n\tCAN NOT CONVERT\n", "/root/patron-new/39/src/bin/common/color.c\372\006]U",
            1085);
    }
#line 1086
    return;
  } else
#line 1077
  if ((image___37->comps + 0)->dy != (image___37->comps + 1)->dy) {
    {
#line 1084
    fprintf(stderr, "%s:%d:color_esycc_to_rgb\n\tCAN NOT CONVERT\n", "/root/patron-new/39/src/bin/common/color.c\372\006]U",
            1085);
    }
#line 1086
    return;
  } else
#line 1077
  if ((image___37->comps + 0)->dy != (image___37->comps + 2)->dy) {
    {
#line 1084
    fprintf(stderr, "%s:%d:color_esycc_to_rgb\n\tCAN NOT CONVERT\n", "/root/patron-new/39/src/bin/common/color.c\372\006]U",
            1085);
    }
#line 1086
    return;
  }
#line 1089
  w___7 = (image___37->comps + 0)->w;
#line 1090
  h___7 = (image___37->comps + 0)->h;
#line 1092
  sign1 = (int )(image___37->comps + 1)->sgnd;
#line 1093
  sign2 = (int )(image___37->comps + 2)->sgnd;
#line 1095
  max___7 = w___7 * h___7;
#line 1097
  i___160 = 0U;
  {
#line 1097
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1097
    if (! (i___160 < max___7)) {
#line 1097
      goto while_break;
    }
#line 1099
    y___15 = *((image___37->comps + 0)->data + i___160);
#line 1100
    cb___3 = *((image___37->comps + 1)->data + i___160);
#line 1101
    cr___3 = *((image___37->comps + 2)->data + i___160);
#line 1103
    if (! sign1) {
#line 1104
      cb___3 -= flip_value;
    }
#line 1106
    if (! sign2) {
#line 1107
      cr___3 -= flip_value;
    }
#line 1110
    val___15 = (int )((((float )y___15 - (float )3.68000000001e-05 * (float )cb___3) + (float )1.40199000001 * (float )cr___3) + (float )0.5);
#line 1114
    if (val___15 > max_value) {
#line 1115
      val___15 = max_value;
    } else
#line 1116
    if (val___15 < 0) {
#line 1117
      val___15 = 0;
    }
#line 1119
    *((image___37->comps + 0)->data + i___160) = val___15;
#line 1121
    val___15 = (int )((((float )1.0003 * (float )y___15 - (float )0.344125000001 * (float )cb___3) - (float )0.7141128 * (float )cr___3) + (float )0.5);
#line 1125
    if (val___15 > max_value) {
#line 1126
      val___15 = max_value;
    } else
#line 1127
    if (val___15 < 0) {
#line 1128
      val___15 = 0;
    }
#line 1130
    *((image___37->comps + 1)->data + i___160) = val___15;
#line 1132
    val___15 = (int )((((float )0.999823000001 * (float )y___15 + (float )1.77204000001 * (float )cb___3) - (float )8e-06 * (float )cr___3) + (float )0.5);
#line 1136
    if (val___15 > max_value) {
#line 1137
      val___15 = max_value;
    } else
#line 1138
    if (val___15 < 0) {
#line 1139
      val___15 = 0;
    }
#line 1141
    *((image___37->comps + 2)->data + i___160) = val___15;
#line 1097
    i___160 ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: 
#line 1143
  image___37->color_space = (OPJ_COLOR_SPACE )1;
#line 1144
  return;
}
}
