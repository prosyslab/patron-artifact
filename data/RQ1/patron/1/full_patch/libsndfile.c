/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 22 "/root/libsndfile/src/GSM610/gsm610_priv.h"
typedef short word;
#line 23 "/root/libsndfile/src/GSM610/gsm610_priv.h"
typedef int longword;
#line 25 "/root/libsndfile/src/GSM610/gsm610_priv.h"
typedef unsigned short uword;
#line 26 "/root/libsndfile/src/GSM610/gsm610_priv.h"
typedef unsigned int ulongword;
#line 28 "/root/libsndfile/src/GSM610/gsm610_priv.h"
struct gsm_state {
   word dp0[280] ;
   word z1 ;
   longword L_z2 ;
   int mp ;
   word u[8] ;
   word LARpp[2][8] ;
   word j ;
   word ltp_cut ;
   word nrp ;
   word v[9] ;
   word msr ;
   char verbose ;
   char fast ;
   char wav_fmt ;
   unsigned char frame_index ;
   unsigned char frame_chain ;
   word e[50] ;
};
#line 55 "/root/libsndfile/src/GSM610/gsm610_priv.h"
typedef struct gsm_state GSM_STATE;
#line 216 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stddef.h"
typedef unsigned long size_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 31 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __u_char;
#line 32 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __u_short;
#line 33 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __u_int;
#line 34 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_long;
#line 37 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef signed char __int8_t;
#line 38 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __uint8_t;
#line 39 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef short __int16_t;
#line 40 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __uint16_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __int32_t;
#line 42 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uint32_t;
#line 44 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __int64_t;
#line 45 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uint64_t;
#line 52 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int8_t __int_least8_t;
#line 53 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint8_t __uint_least8_t;
#line 54 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int16_t __int_least16_t;
#line 55 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint16_t __uint_least16_t;
#line 56 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int32_t __int_least32_t;
#line 57 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint32_t __uint_least32_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int64_t __int_least64_t;
#line 59 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint64_t __uint_least64_t;
#line 63 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __quad_t;
#line 64 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_quad_t;
#line 72 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intmax_t;
#line 73 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uintmax_t;
#line 145 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 146 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 147 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino64_t;
#line 150 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 151 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 152 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 154 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 155 "/usr/include/x86_64-linux-gnu/bits/types.h"
struct __anonstruct_0 {
   int __val[2] ;
};
#line 155 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef struct __anonstruct_0 __fsid_t;
#line 156 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 157 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim64_t;
#line 159 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __id_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 161 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 164 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __daddr_t;
#line 165 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __key_t;
#line 168 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __clockid_t;
#line 171 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef void *__timer_t;
#line 174 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 179 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 180 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt64_t;
#line 183 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt_t;
#line 184 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt64_t;
#line 187 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt_t;
#line 188 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt64_t;
#line 191 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __fsword_t;
#line 193 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 196 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 198 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __syscall_ulong_t;
#line 202 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __off64_t __loff_t;
#line 203 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 206 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intptr_t;
#line 209 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 214 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __sig_atomic_t;
#line 16 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
union __anonunion_2 {
   unsigned int __wch ;
   char __wchb[4] ;
};
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
struct __anonstruct_1 {
   int __count ;
   union __anonunion_2 __value ;
};
#line 21 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
typedef struct __anonstruct_1 __mbstate_t;
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h"
struct _G_fpos_t {
   __off_t __pos ;
   __mbstate_t __state ;
};
#line 14 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h"
typedef struct _G_fpos_t __fpos_t;
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h"
struct _G_fpos64_t {
   __off64_t __pos ;
   __mbstate_t __state ;
};
#line 14 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h"
typedef struct _G_fpos64_t __fpos64_t;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE ;
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
typedef struct _IO_FILE __FILE;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_marker ;
#line 37
struct _IO_codecvt ;
#line 38
struct _IO_wide_data ;
#line 43 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
typedef void _IO_lock_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[20] ;
};
#line 52 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 77 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 84 "/usr/include/stdio.h"
typedef __fpos_t fpos_t;
#line 16 "/root/libsndfile/src/GSM610/gsm.h"
typedef struct gsm_state *gsm;
#line 17 "/root/libsndfile/src/GSM610/gsm.h"
typedef short gsm_signal;
#line 18 "/root/libsndfile/src/GSM610/gsm.h"
typedef unsigned char gsm_byte;
#line 19 "/root/libsndfile/src/GSM610/gsm.h"
typedef gsm_byte gsm_frame[33];
#line 328 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stddef.h"
typedef int wchar_t;
#line 52 "/usr/include/x86_64-linux-gnu/bits/waitflags.h"
enum __anonenum__6 {
    P_ALL = 0,
    P_PID = 1,
    P_PGID = 2
} ;
#line 57 "/usr/include/x86_64-linux-gnu/bits/waitflags.h"
typedef enum __anonenum__6 idtype_t;
#line 58 "/usr/include/stdlib.h"
struct __anonstruct_7 {
   int quot ;
   int rem ;
};
#line 62 "/usr/include/stdlib.h"
typedef struct __anonstruct_7 div_t;
#line 66 "/usr/include/stdlib.h"
struct __anonstruct_8 {
   long quot ;
   long rem ;
};
#line 70 "/usr/include/stdlib.h"
typedef struct __anonstruct_8 ldiv_t;
#line 76 "/usr/include/stdlib.h"
struct __anonstruct_9 {
   long long quot ;
   long long rem ;
};
#line 80 "/usr/include/stdlib.h"
typedef struct __anonstruct_9 lldiv_t;
#line 33 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_char u_char;
#line 34 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_short u_short;
#line 35 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_int u_int;
#line 36 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_long u_long;
#line 37 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __quad_t quad_t;
#line 38 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_quad_t u_quad_t;
#line 39 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsid_t fsid_t;
#line 42 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __loff_t loff_t;
#line 47 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ino_t ino_t;
#line 59 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __dev_t dev_t;
#line 64 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __gid_t gid_t;
#line 69 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 74 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __nlink_t nlink_t;
#line 79 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 97 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 103 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __id_t id_t;
#line 114 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __daddr_t daddr_t;
#line 115 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __caddr_t caddr_t;
#line 121 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __key_t key_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/clock_t.h"
typedef __clock_t clock_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h"
typedef __clockid_t clockid_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h"
typedef __time_t time_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/timer_t.h"
typedef __timer_t timer_t;
#line 148 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned long ulong;
#line 149 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned short ushort;
#line 150 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int uint;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int8_t int8_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int16_t int16_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int32_t int32_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int64_t int64_t;
#line 158 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint8_t u_int8_t;
#line 159 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint16_t u_int16_t;
#line 160 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint32_t u_int32_t;
#line 161 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint64_t u_int64_t;
#line 164 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef long register_t;
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
struct __anonstruct_10 {
   unsigned long __val[16] ;
};
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
typedef struct __anonstruct_10 __sigset_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h"
typedef __sigset_t sigset_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 43 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __suseconds_t suseconds_t;
#line 49 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 59 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_11 {
   __fd_mask __fds_bits[16] ;
};
#line 70 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_11 fd_set;
#line 77 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __fd_mask fd_mask;
#line 185 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __blksize_t blksize_t;
#line 192 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __blkcnt_t blkcnt_t;
#line 196 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsblkcnt_t fsblkcnt_t;
#line 200 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsfilcnt_t fsfilcnt_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 53 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 55 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_internal_slist {
   struct __pthread_internal_slist *__next ;
};
#line 58 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef struct __pthread_internal_slist __pthread_slist_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
#line 23 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h"
struct __pthread_rwlock_arch_t {
   unsigned int __readers ;
   unsigned int __writers ;
   unsigned int __wrphase_futex ;
   unsigned int __writers_futex ;
   unsigned int __pad3 ;
   unsigned int __pad4 ;
   int __cur_writer ;
   int __shared ;
   signed char __rwelision ;
   unsigned char __pad1[7] ;
   unsigned long __pad2 ;
   unsigned int __flags ;
};
#line 97 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __anonstruct_13 {
   unsigned int __low ;
   unsigned int __high ;
};
#line 94 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
union __anonunion_12 {
   unsigned long long __wseq ;
   struct __anonstruct_13 __wseq32 ;
};
#line 106 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __anonstruct_15 {
   unsigned int __low ;
   unsigned int __high ;
};
#line 103 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
union __anonunion_14 {
   unsigned long long __g1_start ;
   struct __anonstruct_15 __g1_start32 ;
};
#line 92 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_cond_s {
   union __anonunion_12  ;
   unsigned long long __wseq ;
   struct __anonstruct_13 __wseq32 ;
   union __anonunion_14  ;
   unsigned long long __g1_start ;
   struct __anonstruct_15 __g1_start32 ;
   unsigned int __g_refs[2] ;
   unsigned int __g_size[2] ;
   unsigned int __g1_orig_size ;
   unsigned int __wrefs ;
   unsigned int __g_signals[2] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_16 {
   char __size[4] ;
   int __align ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_16 pthread_mutexattr_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_17 {
   char __size[4] ;
   int __align ;
};
#line 45 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_17 pthread_condattr_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned int pthread_key_t;
#line 53 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef int pthread_once_t;
#line 56 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union pthread_attr_t pthread_attr_t;
#line 67 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_18 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 72 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_18 pthread_mutex_t;
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_19 {
   struct __pthread_cond_s __data ;
   char __size[48] ;
   long long __align ;
};
#line 80 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_19 pthread_cond_t;
#line 86 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_20 {
   struct __pthread_rwlock_arch_t __data ;
   char __size[56] ;
   long __align ;
};
#line 91 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_20 pthread_rwlock_t;
#line 93 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_21 {
   char __size[8] ;
   long __align ;
};
#line 97 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_21 pthread_rwlockattr_t;
#line 103 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef int pthread_spinlock_t;
#line 108 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_22 {
   char __size[32] ;
   long __align ;
};
#line 112 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_22 pthread_barrier_t;
#line 114 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_23 {
   char __size[4] ;
   int __align ;
};
#line 118 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_23 pthread_barrierattr_t;
#line 423 "/usr/include/stdlib.h"
struct random_data {
   int32_t *fptr ;
   int32_t *rptr ;
   int32_t *state ;
   int rand_type ;
   int rand_deg ;
   int rand_sep ;
   int32_t *end_ptr ;
};
#line 490 "/usr/include/stdlib.h"
struct drand48_data {
   unsigned short __x[3] ;
   unsigned short __old_x[3] ;
   unsigned short __c ;
   unsigned short __init ;
   unsigned long long __a ;
};
#line 808 "/usr/include/stdlib.h"
typedef int (*__compar_fn_t)(void const   * , void const   * );
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
struct __locale_data ;
#line 28 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
struct __locale_struct {
   struct __locale_data *__locales[13] ;
   unsigned short const   *__ctype_b ;
   int const   *__ctype_tolower ;
   int const   *__ctype_toupper ;
   char const   *__names[13] ;
};
#line 42 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
typedef struct __locale_struct *__locale_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h"
typedef __locale_t locale_t;
#line 149 "/usr/include/math.h"
typedef float float_t;
#line 150 "/usr/include/math.h"
typedef double double_t;
#line 853
enum __anonenum__43 {
    FP_NAN = 0,
    FP_INFINITE = 1,
    FP_ZERO = 2,
    FP_SUBNORMAL = 3,
    FP_NORMAL = 4
} ;
#line 46 "/root/libsndfile/src/sndfile.h"
enum __anonenum__44 {
    SF_FORMAT_WAV = 65536,
    SF_FORMAT_AIFF = 131072,
    SF_FORMAT_AU = 196608,
    SF_FORMAT_RAW = 262144,
    SF_FORMAT_PAF = 327680,
    SF_FORMAT_SVX = 393216,
    SF_FORMAT_NIST = 458752,
    SF_FORMAT_VOC = 524288,
    SF_FORMAT_IRCAM = 655360,
    SF_FORMAT_W64 = 720896,
    SF_FORMAT_MAT4 = 786432,
    SF_FORMAT_MAT5 = 851968,
    SF_FORMAT_PVF = 917504,
    SF_FORMAT_XI = 983040,
    SF_FORMAT_HTK = 1048576,
    SF_FORMAT_SDS = 1114112,
    SF_FORMAT_AVR = 1179648,
    SF_FORMAT_WAVEX = 1245184,
    SF_FORMAT_SD2 = 1441792,
    SF_FORMAT_FLAC = 1507328,
    SF_FORMAT_CAF = 1572864,
    SF_FORMAT_WVE = 1638400,
    SF_FORMAT_OGG = 2097152,
    SF_FORMAT_MPC2K = 2162688,
    SF_FORMAT_RF64 = 2228224,
    SF_FORMAT_PCM_S8 = 1,
    SF_FORMAT_PCM_16 = 2,
    SF_FORMAT_PCM_24 = 3,
    SF_FORMAT_PCM_32 = 4,
    SF_FORMAT_PCM_U8 = 5,
    SF_FORMAT_FLOAT = 6,
    SF_FORMAT_DOUBLE = 7,
    SF_FORMAT_ULAW = 16,
    SF_FORMAT_ALAW = 17,
    SF_FORMAT_IMA_ADPCM = 18,
    SF_FORMAT_MS_ADPCM = 19,
    SF_FORMAT_GSM610 = 32,
    SF_FORMAT_VOX_ADPCM = 33,
    SF_FORMAT_G721_32 = 48,
    SF_FORMAT_G723_24 = 49,
    SF_FORMAT_G723_40 = 50,
    SF_FORMAT_DWVW_12 = 64,
    SF_FORMAT_DWVW_16 = 65,
    SF_FORMAT_DWVW_24 = 66,
    SF_FORMAT_DWVW_N = 67,
    SF_FORMAT_DPCM_8 = 80,
    SF_FORMAT_DPCM_16 = 81,
    SF_FORMAT_VORBIS = 96,
    SF_ENDIAN_FILE = 0,
    SF_ENDIAN_LITTLE = 268435456,
    SF_ENDIAN_BIG = 536870912,
    SF_ENDIAN_CPU = 805306368,
    SF_FORMAT_SUBMASK = 65535,
    SF_FORMAT_TYPEMASK = 268369920,
    SF_FORMAT_ENDMASK = 805306368
} ;
#line 126
enum __anonenum__45 {
    SFC_GET_LIB_VERSION = 4096,
    SFC_GET_LOG_INFO = 4097,
    SFC_GET_CURRENT_SF_INFO = 4098,
    SFC_GET_NORM_DOUBLE = 4112,
    SFC_GET_NORM_FLOAT = 4113,
    SFC_SET_NORM_DOUBLE = 4114,
    SFC_SET_NORM_FLOAT = 4115,
    SFC_SET_SCALE_FLOAT_INT_READ = 4116,
    SFC_SET_SCALE_INT_FLOAT_WRITE = 4117,
    SFC_GET_SIMPLE_FORMAT_COUNT = 4128,
    SFC_GET_SIMPLE_FORMAT = 4129,
    SFC_GET_FORMAT_INFO = 4136,
    SFC_GET_FORMAT_MAJOR_COUNT = 4144,
    SFC_GET_FORMAT_MAJOR = 4145,
    SFC_GET_FORMAT_SUBTYPE_COUNT = 4146,
    SFC_GET_FORMAT_SUBTYPE = 4147,
    SFC_CALC_SIGNAL_MAX = 4160,
    SFC_CALC_NORM_SIGNAL_MAX = 4161,
    SFC_CALC_MAX_ALL_CHANNELS = 4162,
    SFC_CALC_NORM_MAX_ALL_CHANNELS = 4163,
    SFC_GET_SIGNAL_MAX = 4164,
    SFC_GET_MAX_ALL_CHANNELS = 4165,
    SFC_SET_ADD_PEAK_CHUNK = 4176,
    SFC_SET_ADD_HEADER_PAD_CHUNK = 4177,
    SFC_UPDATE_HEADER_NOW = 4192,
    SFC_SET_UPDATE_HEADER_AUTO = 4193,
    SFC_FILE_TRUNCATE = 4224,
    SFC_SET_RAW_START_OFFSET = 4240,
    SFC_SET_DITHER_ON_WRITE = 4256,
    SFC_SET_DITHER_ON_READ = 4257,
    SFC_GET_DITHER_INFO_COUNT = 4258,
    SFC_GET_DITHER_INFO = 4259,
    SFC_GET_EMBED_FILE_INFO = 4272,
    SFC_SET_CLIPPING = 4288,
    SFC_GET_CLIPPING = 4289,
    SFC_GET_INSTRUMENT = 4304,
    SFC_SET_INSTRUMENT = 4305,
    SFC_GET_LOOP_INFO = 4320,
    SFC_GET_BROADCAST_INFO = 4336,
    SFC_SET_BROADCAST_INFO = 4337,
    SFC_GET_CHANNEL_MAP_INFO = 4352,
    SFC_SET_CHANNEL_MAP_INFO = 4353,
    SFC_RAW_DATA_NEEDS_ENDSWAP = 4368,
    SFC_WAVEX_SET_AMBISONIC = 4608,
    SFC_WAVEX_GET_AMBISONIC = 4609,
    SFC_SET_VBR_ENCODING_QUALITY = 4864,
    SFC_TEST_IEEE_FLOAT_REPLACE = 24577,
    SFC_SET_ADD_DITHER_ON_WRITE = 4208,
    SFC_SET_ADD_DITHER_ON_READ = 4209
} ;
#line 216
enum __anonenum__46 {
    SF_STR_TITLE = 1,
    SF_STR_COPYRIGHT = 2,
    SF_STR_SOFTWARE = 3,
    SF_STR_ARTIST = 4,
    SF_STR_COMMENT = 5,
    SF_STR_DATE = 6,
    SF_STR_ALBUM = 7,
    SF_STR_LICENSE = 8
} ;
#line 235
enum __anonenum__47 {
    SF_FALSE = 0,
    SF_TRUE = 1,
    SFM_READ = 16,
    SFM_WRITE = 32,
    SFM_RDWR = 48,
    SF_AMBISONIC_NONE = 64,
    SF_AMBISONIC_B_FORMAT = 65
} ;
#line 255
enum __anonenum__48 {
    SF_ERR_NO_ERROR = 0,
    SF_ERR_UNRECOGNISED_FORMAT = 1,
    SF_ERR_SYSTEM = 2,
    SF_ERR_MALFORMED_FILE = 3,
    SF_ERR_UNSUPPORTED_ENCODING = 4
} ;
#line 267
enum __anonenum__49 {
    SF_CHANNEL_MAP_INVALID = 0,
    SF_CHANNEL_MAP_MONO = 1,
    SF_CHANNEL_MAP_LEFT = 2,
    SF_CHANNEL_MAP_RIGHT = 3,
    SF_CHANNEL_MAP_CENTER = 4,
    SF_CHANNEL_MAP_FRONT_LEFT = 5,
    SF_CHANNEL_MAP_FRONT_RIGHT = 6,
    SF_CHANNEL_MAP_FRONT_CENTER = 7,
    SF_CHANNEL_MAP_REAR_CENTER = 8,
    SF_CHANNEL_MAP_REAR_LEFT = 9,
    SF_CHANNEL_MAP_REAR_RIGHT = 10,
    SF_CHANNEL_MAP_LFE = 11,
    SF_CHANNEL_MAP_FRONT_LEFT_OF_CENTER = 12,
    SF_CHANNEL_MAP_FRONT_RIGHT_OF_CENTER = 13,
    SF_CHANNEL_MAP_SIDE_LEFT = 14,
    SF_CHANNEL_MAP_SIDE_RIGHT = 15,
    SF_CHANNEL_MAP_TOP_CENTER = 16,
    SF_CHANNEL_MAP_TOP_FRONT_LEFT = 17,
    SF_CHANNEL_MAP_TOP_FRONT_RIGHT = 18,
    SF_CHANNEL_MAP_TOP_FRONT_CENTER = 19,
    SF_CHANNEL_MAP_TOP_REAR_LEFT = 20,
    SF_CHANNEL_MAP_TOP_REAR_RIGHT = 21,
    SF_CHANNEL_MAP_TOP_REAR_CENTER = 22
} ;
#line 296
struct SNDFILE_tag ;
#line 296 "/root/libsndfile/src/sndfile.h"
typedef struct SNDFILE_tag SNDFILE;
#line 308 "/root/libsndfile/src/sndfile.h"
typedef __off_t sf_count_t;
#line 318 "/root/libsndfile/src/sndfile.h"
struct SF_INFO {
   sf_count_t frames ;
   int samplerate ;
   int channels ;
   int format ;
   int sections ;
   int seekable ;
};
#line 327 "/root/libsndfile/src/sndfile.h"
typedef struct SF_INFO SF_INFO;
#line 340 "/root/libsndfile/src/sndfile.h"
struct __anonstruct_50 {
   int format ;
   char const   *name ;
   char const   *extension ;
};
#line 344 "/root/libsndfile/src/sndfile.h"
typedef struct __anonstruct_50 SF_FORMAT_INFO;
#line 352
enum __anonenum__51 {
    SFD_DEFAULT_LEVEL = 0,
    SFD_CUSTOM_LEVEL = 1073741824,
    SFD_NO_DITHER = 500,
    SFD_WHITE = 501,
    SFD_TRIANGULAR_PDF = 502
} ;
#line 361 "/root/libsndfile/src/sndfile.h"
struct __anonstruct_52 {
   int type ;
   double level ;
   char const   *name ;
};
#line 365 "/root/libsndfile/src/sndfile.h"
typedef struct __anonstruct_52 SF_DITHER_INFO;
#line 371 "/root/libsndfile/src/sndfile.h"
struct __anonstruct_53 {
   sf_count_t offset ;
   sf_count_t length ;
};
#line 374 "/root/libsndfile/src/sndfile.h"
typedef struct __anonstruct_53 SF_EMBED_FILE_INFO;
#line 380
enum __anonenum__54 {
    SF_LOOP_NONE = 800,
    SF_LOOP_FORWARD = 801,
    SF_LOOP_BACKWARD = 802,
    SF_LOOP_ALTERNATING = 803
} ;
#line 397 "/root/libsndfile/src/sndfile.h"
struct __anonstruct_56 {
   int mode ;
   unsigned int start ;
   unsigned int end ;
   unsigned int count ;
};
#line 390 "/root/libsndfile/src/sndfile.h"
struct __anonstruct_55 {
   int gain ;
   char basenote ;
   char detune ;
   char velocity_lo ;
   char velocity_hi ;
   char key_lo ;
   char key_hi ;
   int loop_count ;
   struct __anonstruct_56 loops[16] ;
};
#line 403 "/root/libsndfile/src/sndfile.h"
typedef struct __anonstruct_55 SF_INSTRUMENT;
#line 408 "/root/libsndfile/src/sndfile.h"
struct __anonstruct_57 {
   short time_sig_num ;
   short time_sig_den ;
   int loop_mode ;
   int num_beats ;
   float bpm ;
   int root_key ;
   int future[6] ;
};
#line 424 "/root/libsndfile/src/sndfile.h"
typedef struct __anonstruct_57 SF_LOOP_INFO;
#line 447 "/root/libsndfile/src/sndfile.h"
struct __anonstruct_58 {
   char description[256] ;
   char originator[32] ;
   char originator_reference[32] ;
   char origination_date[10] ;
   char origination_time[8] ;
   unsigned int time_reference_low ;
   unsigned int time_reference_high ;
   short version ;
   char umid[64] ;
   char reserved[190] ;
   unsigned int coding_history_size ;
   char coding_history[256] ;
};
#line 447 "/root/libsndfile/src/sndfile.h"
typedef struct __anonstruct_58 SF_BROADCAST_INFO;
#line 452 "/root/libsndfile/src/sndfile.h"
typedef sf_count_t (*sf_vio_get_filelen)(void * );
#line 453 "/root/libsndfile/src/sndfile.h"
typedef sf_count_t (*sf_vio_seek)(sf_count_t  , int  , void * );
#line 454 "/root/libsndfile/src/sndfile.h"
typedef sf_count_t (*sf_vio_read)(void * , sf_count_t  , void * );
#line 455 "/root/libsndfile/src/sndfile.h"
typedef sf_count_t (*sf_vio_write)(void const   * , sf_count_t  , void * );
#line 456 "/root/libsndfile/src/sndfile.h"
typedef sf_count_t (*sf_vio_tell)(void * );
#line 458 "/root/libsndfile/src/sndfile.h"
struct SF_VIRTUAL_IO {
   sf_vio_get_filelen get_filelen ;
   sf_vio_seek seek ;
   sf_vio_read read ;
   sf_vio_write write ;
   sf_vio_tell tell ;
};
#line 466 "/root/libsndfile/src/sndfile.h"
typedef struct SF_VIRTUAL_IO SF_VIRTUAL_IO;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint8_t uint8_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint16_t uint16_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint32_t uint32_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint64_t uint64_t;
#line 43 "/usr/include/stdint.h"
typedef __int_least8_t int_least8_t;
#line 44 "/usr/include/stdint.h"
typedef __int_least16_t int_least16_t;
#line 45 "/usr/include/stdint.h"
typedef __int_least32_t int_least32_t;
#line 46 "/usr/include/stdint.h"
typedef __int_least64_t int_least64_t;
#line 49 "/usr/include/stdint.h"
typedef __uint_least8_t uint_least8_t;
#line 50 "/usr/include/stdint.h"
typedef __uint_least16_t uint_least16_t;
#line 51 "/usr/include/stdint.h"
typedef __uint_least32_t uint_least32_t;
#line 52 "/usr/include/stdint.h"
typedef __uint_least64_t uint_least64_t;
#line 58 "/usr/include/stdint.h"
typedef signed char int_fast8_t;
#line 60 "/usr/include/stdint.h"
typedef long int_fast16_t;
#line 61 "/usr/include/stdint.h"
typedef long int_fast32_t;
#line 62 "/usr/include/stdint.h"
typedef long int_fast64_t;
#line 71 "/usr/include/stdint.h"
typedef unsigned char uint_fast8_t;
#line 73 "/usr/include/stdint.h"
typedef unsigned long uint_fast16_t;
#line 74 "/usr/include/stdint.h"
typedef unsigned long uint_fast32_t;
#line 75 "/usr/include/stdint.h"
typedef unsigned long uint_fast64_t;
#line 87 "/usr/include/stdint.h"
typedef long intptr_t;
#line 90 "/usr/include/stdint.h"
typedef unsigned long uintptr_t;
#line 101 "/usr/include/stdint.h"
typedef __intmax_t intmax_t;
#line 102 "/usr/include/stdint.h"
typedef __uintmax_t uintmax_t;
#line 121 "/root/libsndfile/src/common.h"
enum __anonenum__59 {
    SF_PEAK_START = 42,
    SF_PEAK_END = 43,
    SF_SCALE_MAX = 52,
    SF_SCALE_MIN = 53,
    SF_STR_ALLOW_START = 256,
    SF_STR_ALLOW_END = 512,
    SF_STR_LOCATE_START = 1024,
    SF_STR_LOCATE_END = 2048,
    SFD_TYPEMASK = 268435455
} ;
#line 149
enum __anonenum__60 {
    SF_FORMAT_TXW = 67305472,
    SF_FORMAT_DWD = 67371008,
    SF_FORMAT_REX = 67764224,
    SF_FORMAT_REX2 = 67960832,
    SF_FORMAT_KRZ = 68026368,
    SF_FORMAT_WMA = 68157440,
    SF_FORMAT_SHN = 68222976,
    SF_FORMAT_SVX_FIB = 4128,
    SF_FORMAT_SVX_EXP = 4129,
    SF_FORMAT_PCM_N = 4144
} ;
#line 175 "/root/libsndfile/src/common.h"
struct __anonstruct_61 {
   double value ;
   sf_count_t position ;
};
#line 178 "/root/libsndfile/src/common.h"
typedef struct __anonstruct_61 PEAK_POS;
#line 180 "/root/libsndfile/src/common.h"
struct __anonstruct_62 {
   int peak_loc ;
   unsigned int version ;
   unsigned int timestamp ;
   unsigned int edit_number ;
   PEAK_POS peaks[] ;
};
#line 204 "/root/libsndfile/src/common.h"
typedef struct __anonstruct_62 PEAK_INFO;
#line 211 "/root/libsndfile/src/common.h"
struct __anonstruct_63 {
   int type ;
   int flags ;
   char *str ;
};
#line 215 "/root/libsndfile/src/common.h"
typedef struct __anonstruct_63 STR_DATA;
#line 229 "/root/libsndfile/src/common.h"
struct __anonstruct_64 {
   int size ;
   SF_BROADCAST_INFO binfo ;
};
#line 232 "/root/libsndfile/src/common.h"
typedef struct __anonstruct_64 SF_BROADCAST_VAR;
#line 240 "/root/libsndfile/src/common.h"
union __anonunion_65 {
   double dbuf[2048] ;
   int64_t lbuf[2048] ;
   float fbuf[4096] ;
   int ibuf[4096] ;
   short sbuf[8192] ;
   char cbuf[16384] ;
   signed char scbuf[16384] ;
   unsigned char ucbuf[16384] ;
};
#line 234 "/root/libsndfile/src/common.h"
struct sf_private_tag {
   char canary[64] ;
   union __anonunion_65 u ;
   char filepath[512] ;
   char rsrcpath[512] ;
   char directory[512] ;
   char filename[128] ;
   char syserr[256] ;
   char logbuffer[16384] ;
   unsigned char header[12292] ;
   int rwf_endian ;
   STR_DATA strings[32] ;
   char str_storage[8192] ;
   char *str_end ;
   int str_flags ;
   int Magick ;
   unsigned int unique_id ;
   int logindex ;
   int headindex ;
   int headend ;
   int has_text ;
   int do_not_close_descriptor ;
   int filedes ;
   int rsrcdes ;
   int savedes ;
   int error ;
   int mode ;
   int endian ;
   int data_endswap ;
   int float_int_mult ;
   float float_max ;
   int scale_int_float ;
   int is_pipe ;
   sf_count_t pipeoffset ;
   int add_clipping ;
   SF_INFO sf ;
   int have_written ;
   PEAK_INFO *peak_info ;
   SF_LOOP_INFO *loop_info ;
   SF_INSTRUMENT *instrument ;
   SF_BROADCAST_VAR *broadcast_var ;
   int *channel_map ;
   sf_count_t filelength ;
   sf_count_t fileoffset ;
   sf_count_t rsrclength ;
   sf_count_t dataoffset ;
   sf_count_t datalength ;
   sf_count_t dataend ;
   int blockwidth ;
   int bytewidth ;
   void *dither ;
   void *interleave ;
   int last_op ;
   sf_count_t read_current ;
   sf_count_t write_current ;
   void *container_data ;
   void *codec_data ;
   SF_DITHER_INFO write_dither ;
   SF_DITHER_INFO read_dither ;
   int norm_double ;
   int norm_float ;
   int auto_header ;
   int ieee_replace ;
   sf_count_t (*read_short)(struct sf_private_tag * , short * , sf_count_t  ) ;
   sf_count_t (*read_int)(struct sf_private_tag * , int * , sf_count_t  ) ;
   sf_count_t (*read_float)(struct sf_private_tag * , float * , sf_count_t  ) ;
   sf_count_t (*read_double)(struct sf_private_tag * , double * , sf_count_t  ) ;
   sf_count_t (*write_short)(struct sf_private_tag * , short const   * , sf_count_t  ) ;
   sf_count_t (*write_int)(struct sf_private_tag * , int const   * , sf_count_t  ) ;
   sf_count_t (*write_float)(struct sf_private_tag * , float const   * , sf_count_t  ) ;
   sf_count_t (*write_double)(struct sf_private_tag * , double const   * , sf_count_t  ) ;
   sf_count_t (*seek)(struct sf_private_tag * , int  , sf_count_t  ) ;
   int (*write_header)(struct sf_private_tag * , int  ) ;
   int (*command)(struct sf_private_tag * , int  , void * , int  ) ;
   int (*codec_close)(struct sf_private_tag * ) ;
   int (*container_close)(struct sf_private_tag * ) ;
   char *format_desc ;
   int virtual_io ;
   SF_VIRTUAL_IO vio ;
   void *vio_user_data ;
};
#line 401 "/root/libsndfile/src/common.h"
typedef struct sf_private_tag SF_PRIVATE;
#line 405
enum __anonenum__66 {
    SFE_NO_ERROR = 0,
    SFE_BAD_OPEN_FORMAT = 1,
    SFE_SYSTEM = 2,
    SFE_MALFORMED_FILE = 3,
    SFE_UNSUPPORTED_ENCODING = 4,
    SFE_ZERO_MAJOR_FORMAT = 5,
    SFE_ZERO_MINOR_FORMAT = 6,
    SFE_BAD_FILE = 7,
    SFE_BAD_FILE_READ = 8,
    SFE_OPEN_FAILED = 9,
    SFE_BAD_SNDFILE_PTR = 10,
    SFE_BAD_SF_INFO_PTR = 11,
    SFE_BAD_SF_INCOMPLETE = 12,
    SFE_BAD_FILE_PTR = 13,
    SFE_BAD_INT_PTR = 14,
    SFE_BAD_STAT_SIZE = 15,
    SFE_MALLOC_FAILED = 16,
    SFE_UNIMPLEMENTED = 17,
    SFE_BAD_READ_ALIGN = 18,
    SFE_BAD_WRITE_ALIGN = 19,
    SFE_UNKNOWN_FORMAT = 20,
    SFE_NOT_READMODE = 21,
    SFE_NOT_WRITEMODE = 22,
    SFE_BAD_MODE_RW = 23,
    SFE_BAD_SF_INFO = 24,
    SFE_BAD_OFFSET = 25,
    SFE_NO_EMBED_SUPPORT = 26,
    SFE_NO_EMBEDDED_RDWR = 27,
    SFE_NO_PIPE_WRITE = 28,
    SFE_INTERNAL = 29,
    SFE_BAD_COMMAND_PARAM = 30,
    SFE_BAD_ENDIAN = 31,
    SFE_CHANNEL_COUNT_ZERO = 32,
    SFE_CHANNEL_COUNT = 33,
    SFE_BAD_VIRTUAL_IO = 34,
    SFE_INTERLEAVE_MODE = 35,
    SFE_INTERLEAVE_SEEK = 36,
    SFE_INTERLEAVE_READ = 37,
    SFE_BAD_SEEK = 38,
    SFE_NOT_SEEKABLE = 39,
    SFE_AMBIGUOUS_SEEK = 40,
    SFE_WRONG_SEEK = 41,
    SFE_SEEK_FAILED = 42,
    SFE_BAD_OPEN_MODE = 43,
    SFE_OPEN_PIPE_RDWR = 44,
    SFE_RDWR_POSITION = 45,
    SFE_RDWR_BAD_HEADER = 46,
    SFE_CMD_HAS_DATA = 47,
    SFE_BAD_BROADCAST_INFO_SIZE = 48,
    SFE_STR_NO_SUPPORT = 49,
    SFE_STR_NOT_WRITE = 50,
    SFE_STR_MAX_DATA = 51,
    SFE_STR_MAX_COUNT = 52,
    SFE_STR_BAD_TYPE = 53,
    SFE_STR_NO_ADD_END = 54,
    SFE_STR_BAD_STRING = 55,
    SFE_STR_WEIRD = 56,
    SFE_WAV_NO_RIFF = 57,
    SFE_WAV_NO_WAVE = 58,
    SFE_WAV_NO_FMT = 59,
    SFE_WAV_BAD_FMT = 60,
    SFE_WAV_FMT_SHORT = 61,
    SFE_WAV_BAD_FACT = 62,
    SFE_WAV_BAD_PEAK = 63,
    SFE_WAV_PEAK_B4_FMT = 64,
    SFE_WAV_BAD_FORMAT = 65,
    SFE_WAV_BAD_BLOCKALIGN = 66,
    SFE_WAV_NO_DATA = 67,
    SFE_WAV_BAD_LIST = 68,
    SFE_WAV_ADPCM_NOT4BIT = 69,
    SFE_WAV_ADPCM_CHANNELS = 70,
    SFE_WAV_GSM610_FORMAT = 71,
    SFE_WAV_UNKNOWN_CHUNK = 72,
    SFE_WAV_WVPK_DATA = 73,
    SFE_AIFF_NO_FORM = 74,
    SFE_AIFF_AIFF_NO_FORM = 75,
    SFE_AIFF_COMM_NO_FORM = 76,
    SFE_AIFF_SSND_NO_COMM = 77,
    SFE_AIFF_UNKNOWN_CHUNK = 78,
    SFE_AIFF_COMM_CHUNK_SIZE = 79,
    SFE_AIFF_BAD_COMM_CHUNK = 80,
    SFE_AIFF_PEAK_B4_COMM = 81,
    SFE_AIFF_BAD_PEAK = 82,
    SFE_AIFF_NO_SSND = 83,
    SFE_AIFF_NO_DATA = 84,
    SFE_AIFF_RW_SSND_NOT_LAST = 85,
    SFE_AU_UNKNOWN_FORMAT = 86,
    SFE_AU_NO_DOTSND = 87,
    SFE_AU_EMBED_BAD_LEN = 88,
    SFE_RAW_READ_BAD_SPEC = 89,
    SFE_RAW_BAD_BITWIDTH = 90,
    SFE_RAW_BAD_FORMAT = 91,
    SFE_PAF_NO_MARKER = 92,
    SFE_PAF_VERSION = 93,
    SFE_PAF_UNKNOWN_FORMAT = 94,
    SFE_PAF_SHORT_HEADER = 95,
    SFE_SVX_NO_FORM = 96,
    SFE_SVX_NO_BODY = 97,
    SFE_SVX_NO_DATA = 98,
    SFE_SVX_BAD_COMP = 99,
    SFE_SVX_BAD_NAME_LENGTH = 100,
    SFE_NIST_BAD_HEADER = 101,
    SFE_NIST_CRLF_CONVERISON = 102,
    SFE_NIST_BAD_ENCODING = 103,
    SFE_VOC_NO_CREATIVE = 104,
    SFE_VOC_BAD_FORMAT = 105,
    SFE_VOC_BAD_VERSION = 106,
    SFE_VOC_BAD_MARKER = 107,
    SFE_VOC_BAD_SECTIONS = 108,
    SFE_VOC_MULTI_SAMPLERATE = 109,
    SFE_VOC_MULTI_SECTION = 110,
    SFE_VOC_MULTI_PARAM = 111,
    SFE_VOC_SECTION_COUNT = 112,
    SFE_VOC_NO_PIPE = 113,
    SFE_IRCAM_NO_MARKER = 114,
    SFE_IRCAM_BAD_CHANNELS = 115,
    SFE_IRCAM_UNKNOWN_FORMAT = 116,
    SFE_W64_64_BIT = 117,
    SFE_W64_NO_RIFF = 118,
    SFE_W64_NO_WAVE = 119,
    SFE_W64_NO_DATA = 120,
    SFE_W64_ADPCM_NOT4BIT = 121,
    SFE_W64_ADPCM_CHANNELS = 122,
    SFE_W64_GSM610_FORMAT = 123,
    SFE_MAT4_BAD_NAME = 124,
    SFE_MAT4_NO_SAMPLERATE = 125,
    SFE_MAT5_BAD_ENDIAN = 126,
    SFE_MAT5_NO_BLOCK = 127,
    SFE_MAT5_SAMPLE_RATE = 128,
    SFE_PVF_NO_PVF1 = 129,
    SFE_PVF_BAD_HEADER = 130,
    SFE_PVF_BAD_BITWIDTH = 131,
    SFE_DWVW_BAD_BITWIDTH = 132,
    SFE_G72X_NOT_MONO = 133,
    SFE_XI_BAD_HEADER = 134,
    SFE_XI_EXCESS_SAMPLES = 135,
    SFE_XI_NO_PIPE = 136,
    SFE_HTK_NO_PIPE = 137,
    SFE_SDS_NOT_SDS = 138,
    SFE_SDS_BAD_BIT_WIDTH = 139,
    SFE_SD2_FD_DISALLOWED = 140,
    SFE_SD2_BAD_DATA_OFFSET = 141,
    SFE_SD2_BAD_MAP_OFFSET = 142,
    SFE_SD2_BAD_DATA_LENGTH = 143,
    SFE_SD2_BAD_MAP_LENGTH = 144,
    SFE_SD2_BAD_RSRC = 145,
    SFE_SD2_BAD_SAMPLE_SIZE = 146,
    SFE_FLAC_BAD_HEADER = 147,
    SFE_FLAC_NEW_DECODER = 148,
    SFE_FLAC_INIT_DECODER = 149,
    SFE_FLAC_LOST_SYNC = 150,
    SFE_FLAC_BAD_SAMPLE_RATE = 151,
    SFE_FLAC_UNKOWN_ERROR = 152,
    SFE_WVE_NOT_WVE = 153,
    SFE_WVE_NO_PIPE = 154,
    SFE_VORBIS_ENCODER_BUG = 155,
    SFE_RF64_NOT_RF64 = 156,
    SFE_MAX_ERROR = 157
} ;
#line 770 "/root/libsndfile/src/common.h"
struct __anonstruct_68 {
   int chunk ;
   sf_count_t offset ;
   sf_count_t len ;
};
#line 769 "/root/libsndfile/src/common.h"
struct __anonstruct_67 {
   struct __anonstruct_68 l[100] ;
   int count ;
};
#line 777 "/root/libsndfile/src/common.h"
typedef struct __anonstruct_67 PRIV_CHUNK4;
#line 800 "/root/libsndfile/src/common.h"
struct __anonstruct_69 {
   int channels ;
   int endianness ;
};
#line 803 "/root/libsndfile/src/common.h"
typedef struct __anonstruct_69 AUDIO_DETECT;
#line 823
enum __anonenum__70 {
    SFC_TEST_AIFF_ADD_INST_CHUNK = 8192,
    SFC_TEST_WAV_ADD_INFO_CHUNK = 8208
} ;
#line 26 "/root/libsndfile/src/ima_oki_adpcm.h"
struct __anonstruct_71 {
   int mask ;
   int last_output ;
   int step_index ;
   int max_step_index ;
   int const   *steps ;
   int errors ;
   int code_count ;
   int pcm_count ;
   unsigned char codes[256] ;
   short pcm[512] ;
};
#line 41 "/root/libsndfile/src/ima_oki_adpcm.h"
typedef struct __anonstruct_71 IMA_OKI_ADPCM;
#line 43
enum __anonenum__72 {
    IMA_OKI_ADPCM_TYPE_IMA = 0,
    IMA_OKI_ADPCM_TYPE_OKI = 1
} ;
#line 46 "/root/libsndfile/src/ima_oki_adpcm.h"
typedef enum __anonenum__72 IMA_OKI_ADPCM_TYPE;
#line 853 "/usr/include/math.h"
enum __anonenum__74 {
    FP_NAN___0 = 0,
    FP_INFINITE___0 = 1,
    FP_ZERO___0 = 2,
    FP_SUBNORMAL___0 = 3,
    FP_NORMAL___0 = 4
} ;
#line 46 "/root/libsndfile/src/sndfile.h"
enum __anonenum__91 {
    SF_FORMAT_WAV___0 = 65536,
    SF_FORMAT_AIFF___0 = 131072,
    SF_FORMAT_AU___0 = 196608,
    SF_FORMAT_RAW___0 = 262144,
    SF_FORMAT_PAF___0 = 327680,
    SF_FORMAT_SVX___0 = 393216,
    SF_FORMAT_NIST___0 = 458752,
    SF_FORMAT_VOC___0 = 524288,
    SF_FORMAT_IRCAM___0 = 655360,
    SF_FORMAT_W64___0 = 720896,
    SF_FORMAT_MAT4___0 = 786432,
    SF_FORMAT_MAT5___0 = 851968,
    SF_FORMAT_PVF___0 = 917504,
    SF_FORMAT_XI___0 = 983040,
    SF_FORMAT_HTK___0 = 1048576,
    SF_FORMAT_SDS___0 = 1114112,
    SF_FORMAT_AVR___0 = 1179648,
    SF_FORMAT_WAVEX___0 = 1245184,
    SF_FORMAT_SD2___0 = 1441792,
    SF_FORMAT_FLAC___0 = 1507328,
    SF_FORMAT_CAF___0 = 1572864,
    SF_FORMAT_WVE___0 = 1638400,
    SF_FORMAT_OGG___0 = 2097152,
    SF_FORMAT_MPC2K___0 = 2162688,
    SF_FORMAT_RF64___0 = 2228224,
    SF_FORMAT_PCM_S8___0 = 1,
    SF_FORMAT_PCM_16___0 = 2,
    SF_FORMAT_PCM_24___0 = 3,
    SF_FORMAT_PCM_32___0 = 4,
    SF_FORMAT_PCM_U8___0 = 5,
    SF_FORMAT_FLOAT___0 = 6,
    SF_FORMAT_DOUBLE___0 = 7,
    SF_FORMAT_ULAW___0 = 16,
    SF_FORMAT_ALAW___0 = 17,
    SF_FORMAT_IMA_ADPCM___0 = 18,
    SF_FORMAT_MS_ADPCM___0 = 19,
    SF_FORMAT_GSM610___0 = 32,
    SF_FORMAT_VOX_ADPCM___0 = 33,
    SF_FORMAT_G721_32___0 = 48,
    SF_FORMAT_G723_24___0 = 49,
    SF_FORMAT_G723_40___0 = 50,
    SF_FORMAT_DWVW_12___0 = 64,
    SF_FORMAT_DWVW_16___0 = 65,
    SF_FORMAT_DWVW_24___0 = 66,
    SF_FORMAT_DWVW_N___0 = 67,
    SF_FORMAT_DPCM_8___0 = 80,
    SF_FORMAT_DPCM_16___0 = 81,
    SF_FORMAT_VORBIS___0 = 96,
    SF_ENDIAN_FILE___0 = 0,
    SF_ENDIAN_LITTLE___0 = 268435456,
    SF_ENDIAN_BIG___0 = 536870912,
    SF_ENDIAN_CPU___0 = 805306368,
    SF_FORMAT_SUBMASK___0 = 65535,
    SF_FORMAT_TYPEMASK___0 = 268369920,
    SF_FORMAT_ENDMASK___0 = 805306368
} ;
#line 126
enum __anonenum__92 {
    SFC_GET_LIB_VERSION___0 = 4096,
    SFC_GET_LOG_INFO___0 = 4097,
    SFC_GET_CURRENT_SF_INFO___0 = 4098,
    SFC_GET_NORM_DOUBLE___0 = 4112,
    SFC_GET_NORM_FLOAT___0 = 4113,
    SFC_SET_NORM_DOUBLE___0 = 4114,
    SFC_SET_NORM_FLOAT___0 = 4115,
    SFC_SET_SCALE_FLOAT_INT_READ___0 = 4116,
    SFC_SET_SCALE_INT_FLOAT_WRITE___0 = 4117,
    SFC_GET_SIMPLE_FORMAT_COUNT___0 = 4128,
    SFC_GET_SIMPLE_FORMAT___0 = 4129,
    SFC_GET_FORMAT_INFO___0 = 4136,
    SFC_GET_FORMAT_MAJOR_COUNT___0 = 4144,
    SFC_GET_FORMAT_MAJOR___0 = 4145,
    SFC_GET_FORMAT_SUBTYPE_COUNT___0 = 4146,
    SFC_GET_FORMAT_SUBTYPE___0 = 4147,
    SFC_CALC_SIGNAL_MAX___0 = 4160,
    SFC_CALC_NORM_SIGNAL_MAX___0 = 4161,
    SFC_CALC_MAX_ALL_CHANNELS___0 = 4162,
    SFC_CALC_NORM_MAX_ALL_CHANNELS___0 = 4163,
    SFC_GET_SIGNAL_MAX___0 = 4164,
    SFC_GET_MAX_ALL_CHANNELS___0 = 4165,
    SFC_SET_ADD_PEAK_CHUNK___0 = 4176,
    SFC_SET_ADD_HEADER_PAD_CHUNK___0 = 4177,
    SFC_UPDATE_HEADER_NOW___0 = 4192,
    SFC_SET_UPDATE_HEADER_AUTO___0 = 4193,
    SFC_FILE_TRUNCATE___0 = 4224,
    SFC_SET_RAW_START_OFFSET___0 = 4240,
    SFC_SET_DITHER_ON_WRITE___0 = 4256,
    SFC_SET_DITHER_ON_READ___0 = 4257,
    SFC_GET_DITHER_INFO_COUNT___0 = 4258,
    SFC_GET_DITHER_INFO___0 = 4259,
    SFC_GET_EMBED_FILE_INFO___0 = 4272,
    SFC_SET_CLIPPING___0 = 4288,
    SFC_GET_CLIPPING___0 = 4289,
    SFC_GET_INSTRUMENT___0 = 4304,
    SFC_SET_INSTRUMENT___0 = 4305,
    SFC_GET_LOOP_INFO___0 = 4320,
    SFC_GET_BROADCAST_INFO___0 = 4336,
    SFC_SET_BROADCAST_INFO___0 = 4337,
    SFC_GET_CHANNEL_MAP_INFO___0 = 4352,
    SFC_SET_CHANNEL_MAP_INFO___0 = 4353,
    SFC_RAW_DATA_NEEDS_ENDSWAP___0 = 4368,
    SFC_WAVEX_SET_AMBISONIC___0 = 4608,
    SFC_WAVEX_GET_AMBISONIC___0 = 4609,
    SFC_SET_VBR_ENCODING_QUALITY___0 = 4864,
    SFC_TEST_IEEE_FLOAT_REPLACE___0 = 24577,
    SFC_SET_ADD_DITHER_ON_WRITE___0 = 4208,
    SFC_SET_ADD_DITHER_ON_READ___0 = 4209
} ;
#line 216
enum __anonenum__93 {
    SF_STR_TITLE___0 = 1,
    SF_STR_COPYRIGHT___0 = 2,
    SF_STR_SOFTWARE___0 = 3,
    SF_STR_ARTIST___0 = 4,
    SF_STR_COMMENT___0 = 5,
    SF_STR_DATE___0 = 6,
    SF_STR_ALBUM___0 = 7,
    SF_STR_LICENSE___0 = 8
} ;
#line 235
enum __anonenum__94 {
    SF_FALSE___0 = 0,
    SF_TRUE___0 = 1,
    SFM_READ___0 = 16,
    SFM_WRITE___0 = 32,
    SFM_RDWR___0 = 48,
    SF_AMBISONIC_NONE___0 = 64,
    SF_AMBISONIC_B_FORMAT___0 = 65
} ;
#line 255
enum __anonenum__95 {
    SF_ERR_NO_ERROR___0 = 0,
    SF_ERR_UNRECOGNISED_FORMAT___0 = 1,
    SF_ERR_SYSTEM___0 = 2,
    SF_ERR_MALFORMED_FILE___0 = 3,
    SF_ERR_UNSUPPORTED_ENCODING___0 = 4
} ;
#line 267
enum __anonenum__96 {
    SF_CHANNEL_MAP_INVALID___0 = 0,
    SF_CHANNEL_MAP_MONO___0 = 1,
    SF_CHANNEL_MAP_LEFT___0 = 2,
    SF_CHANNEL_MAP_RIGHT___0 = 3,
    SF_CHANNEL_MAP_CENTER___0 = 4,
    SF_CHANNEL_MAP_FRONT_LEFT___0 = 5,
    SF_CHANNEL_MAP_FRONT_RIGHT___0 = 6,
    SF_CHANNEL_MAP_FRONT_CENTER___0 = 7,
    SF_CHANNEL_MAP_REAR_CENTER___0 = 8,
    SF_CHANNEL_MAP_REAR_LEFT___0 = 9,
    SF_CHANNEL_MAP_REAR_RIGHT___0 = 10,
    SF_CHANNEL_MAP_LFE___0 = 11,
    SF_CHANNEL_MAP_FRONT_LEFT_OF_CENTER___0 = 12,
    SF_CHANNEL_MAP_FRONT_RIGHT_OF_CENTER___0 = 13,
    SF_CHANNEL_MAP_SIDE_LEFT___0 = 14,
    SF_CHANNEL_MAP_SIDE_RIGHT___0 = 15,
    SF_CHANNEL_MAP_TOP_CENTER___0 = 16,
    SF_CHANNEL_MAP_TOP_FRONT_LEFT___0 = 17,
    SF_CHANNEL_MAP_TOP_FRONT_RIGHT___0 = 18,
    SF_CHANNEL_MAP_TOP_FRONT_CENTER___0 = 19,
    SF_CHANNEL_MAP_TOP_REAR_LEFT___0 = 20,
    SF_CHANNEL_MAP_TOP_REAR_RIGHT___0 = 21,
    SF_CHANNEL_MAP_TOP_REAR_CENTER___0 = 22
} ;
#line 352
enum __anonenum__98 {
    SFD_DEFAULT_LEVEL___0 = 0,
    SFD_CUSTOM_LEVEL___0 = 1073741824,
    SFD_NO_DITHER___0 = 500,
    SFD_WHITE___0 = 501,
    SFD_TRIANGULAR_PDF___0 = 502
} ;
#line 380
enum __anonenum__101 {
    SF_LOOP_NONE___0 = 800,
    SF_LOOP_FORWARD___0 = 801,
    SF_LOOP_BACKWARD___0 = 802,
    SF_LOOP_ALTERNATING___0 = 803
} ;
#line 121 "/root/libsndfile/src/common.h"
enum __anonenum__110 {
    SF_PEAK_START___0 = 42,
    SF_PEAK_END___0 = 43,
    SF_SCALE_MAX___0 = 52,
    SF_SCALE_MIN___0 = 53,
    SF_STR_ALLOW_START___0 = 256,
    SF_STR_ALLOW_END___0 = 512,
    SF_STR_LOCATE_START___0 = 1024,
    SF_STR_LOCATE_END___0 = 2048,
    SFD_TYPEMASK___0 = 268435455
} ;
#line 149
enum __anonenum__111 {
    SF_FORMAT_TXW___0 = 67305472,
    SF_FORMAT_DWD___0 = 67371008,
    SF_FORMAT_REX___0 = 67764224,
    SF_FORMAT_REX2___0 = 67960832,
    SF_FORMAT_KRZ___0 = 68026368,
    SF_FORMAT_WMA___0 = 68157440,
    SF_FORMAT_SHN___0 = 68222976,
    SF_FORMAT_SVX_FIB___0 = 4128,
    SF_FORMAT_SVX_EXP___0 = 4129,
    SF_FORMAT_PCM_N___0 = 4144
} ;
#line 405
enum __anonenum__117 {
    SFE_NO_ERROR___0 = 0,
    SFE_BAD_OPEN_FORMAT___0 = 1,
    SFE_SYSTEM___0 = 2,
    SFE_MALFORMED_FILE___0 = 3,
    SFE_UNSUPPORTED_ENCODING___0 = 4,
    SFE_ZERO_MAJOR_FORMAT___0 = 5,
    SFE_ZERO_MINOR_FORMAT___0 = 6,
    SFE_BAD_FILE___0 = 7,
    SFE_BAD_FILE_READ___0 = 8,
    SFE_OPEN_FAILED___0 = 9,
    SFE_BAD_SNDFILE_PTR___0 = 10,
    SFE_BAD_SF_INFO_PTR___0 = 11,
    SFE_BAD_SF_INCOMPLETE___0 = 12,
    SFE_BAD_FILE_PTR___0 = 13,
    SFE_BAD_INT_PTR___0 = 14,
    SFE_BAD_STAT_SIZE___0 = 15,
    SFE_MALLOC_FAILED___0 = 16,
    SFE_UNIMPLEMENTED___0 = 17,
    SFE_BAD_READ_ALIGN___0 = 18,
    SFE_BAD_WRITE_ALIGN___0 = 19,
    SFE_UNKNOWN_FORMAT___0 = 20,
    SFE_NOT_READMODE___0 = 21,
    SFE_NOT_WRITEMODE___0 = 22,
    SFE_BAD_MODE_RW___0 = 23,
    SFE_BAD_SF_INFO___0 = 24,
    SFE_BAD_OFFSET___0 = 25,
    SFE_NO_EMBED_SUPPORT___0 = 26,
    SFE_NO_EMBEDDED_RDWR___0 = 27,
    SFE_NO_PIPE_WRITE___0 = 28,
    SFE_INTERNAL___0 = 29,
    SFE_BAD_COMMAND_PARAM___0 = 30,
    SFE_BAD_ENDIAN___0 = 31,
    SFE_CHANNEL_COUNT_ZERO___0 = 32,
    SFE_CHANNEL_COUNT___0 = 33,
    SFE_BAD_VIRTUAL_IO___0 = 34,
    SFE_INTERLEAVE_MODE___0 = 35,
    SFE_INTERLEAVE_SEEK___0 = 36,
    SFE_INTERLEAVE_READ___0 = 37,
    SFE_BAD_SEEK___0 = 38,
    SFE_NOT_SEEKABLE___0 = 39,
    SFE_AMBIGUOUS_SEEK___0 = 40,
    SFE_WRONG_SEEK___0 = 41,
    SFE_SEEK_FAILED___0 = 42,
    SFE_BAD_OPEN_MODE___0 = 43,
    SFE_OPEN_PIPE_RDWR___0 = 44,
    SFE_RDWR_POSITION___0 = 45,
    SFE_RDWR_BAD_HEADER___0 = 46,
    SFE_CMD_HAS_DATA___0 = 47,
    SFE_BAD_BROADCAST_INFO_SIZE___0 = 48,
    SFE_STR_NO_SUPPORT___0 = 49,
    SFE_STR_NOT_WRITE___0 = 50,
    SFE_STR_MAX_DATA___0 = 51,
    SFE_STR_MAX_COUNT___0 = 52,
    SFE_STR_BAD_TYPE___0 = 53,
    SFE_STR_NO_ADD_END___0 = 54,
    SFE_STR_BAD_STRING___0 = 55,
    SFE_STR_WEIRD___0 = 56,
    SFE_WAV_NO_RIFF___0 = 57,
    SFE_WAV_NO_WAVE___0 = 58,
    SFE_WAV_NO_FMT___0 = 59,
    SFE_WAV_BAD_FMT___0 = 60,
    SFE_WAV_FMT_SHORT___0 = 61,
    SFE_WAV_BAD_FACT___0 = 62,
    SFE_WAV_BAD_PEAK___0 = 63,
    SFE_WAV_PEAK_B4_FMT___0 = 64,
    SFE_WAV_BAD_FORMAT___0 = 65,
    SFE_WAV_BAD_BLOCKALIGN___0 = 66,
    SFE_WAV_NO_DATA___0 = 67,
    SFE_WAV_BAD_LIST___0 = 68,
    SFE_WAV_ADPCM_NOT4BIT___0 = 69,
    SFE_WAV_ADPCM_CHANNELS___0 = 70,
    SFE_WAV_GSM610_FORMAT___0 = 71,
    SFE_WAV_UNKNOWN_CHUNK___0 = 72,
    SFE_WAV_WVPK_DATA___0 = 73,
    SFE_AIFF_NO_FORM___0 = 74,
    SFE_AIFF_AIFF_NO_FORM___0 = 75,
    SFE_AIFF_COMM_NO_FORM___0 = 76,
    SFE_AIFF_SSND_NO_COMM___0 = 77,
    SFE_AIFF_UNKNOWN_CHUNK___0 = 78,
    SFE_AIFF_COMM_CHUNK_SIZE___0 = 79,
    SFE_AIFF_BAD_COMM_CHUNK___0 = 80,
    SFE_AIFF_PEAK_B4_COMM___0 = 81,
    SFE_AIFF_BAD_PEAK___0 = 82,
    SFE_AIFF_NO_SSND___0 = 83,
    SFE_AIFF_NO_DATA___0 = 84,
    SFE_AIFF_RW_SSND_NOT_LAST___0 = 85,
    SFE_AU_UNKNOWN_FORMAT___0 = 86,
    SFE_AU_NO_DOTSND___0 = 87,
    SFE_AU_EMBED_BAD_LEN___0 = 88,
    SFE_RAW_READ_BAD_SPEC___0 = 89,
    SFE_RAW_BAD_BITWIDTH___0 = 90,
    SFE_RAW_BAD_FORMAT___0 = 91,
    SFE_PAF_NO_MARKER___0 = 92,
    SFE_PAF_VERSION___0 = 93,
    SFE_PAF_UNKNOWN_FORMAT___0 = 94,
    SFE_PAF_SHORT_HEADER___0 = 95,
    SFE_SVX_NO_FORM___0 = 96,
    SFE_SVX_NO_BODY___0 = 97,
    SFE_SVX_NO_DATA___0 = 98,
    SFE_SVX_BAD_COMP___0 = 99,
    SFE_SVX_BAD_NAME_LENGTH___0 = 100,
    SFE_NIST_BAD_HEADER___0 = 101,
    SFE_NIST_CRLF_CONVERISON___0 = 102,
    SFE_NIST_BAD_ENCODING___0 = 103,
    SFE_VOC_NO_CREATIVE___0 = 104,
    SFE_VOC_BAD_FORMAT___0 = 105,
    SFE_VOC_BAD_VERSION___0 = 106,
    SFE_VOC_BAD_MARKER___0 = 107,
    SFE_VOC_BAD_SECTIONS___0 = 108,
    SFE_VOC_MULTI_SAMPLERATE___0 = 109,
    SFE_VOC_MULTI_SECTION___0 = 110,
    SFE_VOC_MULTI_PARAM___0 = 111,
    SFE_VOC_SECTION_COUNT___0 = 112,
    SFE_VOC_NO_PIPE___0 = 113,
    SFE_IRCAM_NO_MARKER___0 = 114,
    SFE_IRCAM_BAD_CHANNELS___0 = 115,
    SFE_IRCAM_UNKNOWN_FORMAT___0 = 116,
    SFE_W64_64_BIT___0 = 117,
    SFE_W64_NO_RIFF___0 = 118,
    SFE_W64_NO_WAVE___0 = 119,
    SFE_W64_NO_DATA___0 = 120,
    SFE_W64_ADPCM_NOT4BIT___0 = 121,
    SFE_W64_ADPCM_CHANNELS___0 = 122,
    SFE_W64_GSM610_FORMAT___0 = 123,
    SFE_MAT4_BAD_NAME___0 = 124,
    SFE_MAT4_NO_SAMPLERATE___0 = 125,
    SFE_MAT5_BAD_ENDIAN___0 = 126,
    SFE_MAT5_NO_BLOCK___0 = 127,
    SFE_MAT5_SAMPLE_RATE___0 = 128,
    SFE_PVF_NO_PVF1___0 = 129,
    SFE_PVF_BAD_HEADER___0 = 130,
    SFE_PVF_BAD_BITWIDTH___0 = 131,
    SFE_DWVW_BAD_BITWIDTH___0 = 132,
    SFE_G72X_NOT_MONO___0 = 133,
    SFE_XI_BAD_HEADER___0 = 134,
    SFE_XI_EXCESS_SAMPLES___0 = 135,
    SFE_XI_NO_PIPE___0 = 136,
    SFE_HTK_NO_PIPE___0 = 137,
    SFE_SDS_NOT_SDS___0 = 138,
    SFE_SDS_BAD_BIT_WIDTH___0 = 139,
    SFE_SD2_FD_DISALLOWED___0 = 140,
    SFE_SD2_BAD_DATA_OFFSET___0 = 141,
    SFE_SD2_BAD_MAP_OFFSET___0 = 142,
    SFE_SD2_BAD_DATA_LENGTH___0 = 143,
    SFE_SD2_BAD_MAP_LENGTH___0 = 144,
    SFE_SD2_BAD_RSRC___0 = 145,
    SFE_SD2_BAD_SAMPLE_SIZE___0 = 146,
    SFE_FLAC_BAD_HEADER___0 = 147,
    SFE_FLAC_NEW_DECODER___0 = 148,
    SFE_FLAC_INIT_DECODER___0 = 149,
    SFE_FLAC_LOST_SYNC___0 = 150,
    SFE_FLAC_BAD_SAMPLE_RATE___0 = 151,
    SFE_FLAC_UNKOWN_ERROR___0 = 152,
    SFE_WVE_NOT_WVE___0 = 153,
    SFE_WVE_NO_PIPE___0 = 154,
    SFE_VORBIS_ENCODER_BUG___0 = 155,
    SFE_RF64_NOT_RF64___0 = 156,
    SFE_MAX_ERROR___0 = 157
} ;
#line 823
enum __anonenum__121 {
    SFC_TEST_AIFF_ADD_INST_CHUNK___0 = 8192,
    SFC_TEST_WAV_ADD_INFO_CHUNK___0 = 8208
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__122 {
    FP_NAN___1 = 0,
    FP_INFINITE___1 = 1,
    FP_ZERO___1 = 2,
    FP_SUBNORMAL___1 = 3,
    FP_NORMAL___1 = 4
} ;
#line 46 "/root/libsndfile/src/sndfile.h"
enum __anonenum__137 {
    SF_FORMAT_WAV___1 = 65536,
    SF_FORMAT_AIFF___1 = 131072,
    SF_FORMAT_AU___1 = 196608,
    SF_FORMAT_RAW___1 = 262144,
    SF_FORMAT_PAF___1 = 327680,
    SF_FORMAT_SVX___1 = 393216,
    SF_FORMAT_NIST___1 = 458752,
    SF_FORMAT_VOC___1 = 524288,
    SF_FORMAT_IRCAM___1 = 655360,
    SF_FORMAT_W64___1 = 720896,
    SF_FORMAT_MAT4___1 = 786432,
    SF_FORMAT_MAT5___1 = 851968,
    SF_FORMAT_PVF___1 = 917504,
    SF_FORMAT_XI___1 = 983040,
    SF_FORMAT_HTK___1 = 1048576,
    SF_FORMAT_SDS___1 = 1114112,
    SF_FORMAT_AVR___1 = 1179648,
    SF_FORMAT_WAVEX___1 = 1245184,
    SF_FORMAT_SD2___1 = 1441792,
    SF_FORMAT_FLAC___1 = 1507328,
    SF_FORMAT_CAF___1 = 1572864,
    SF_FORMAT_WVE___1 = 1638400,
    SF_FORMAT_OGG___1 = 2097152,
    SF_FORMAT_MPC2K___1 = 2162688,
    SF_FORMAT_RF64___1 = 2228224,
    SF_FORMAT_PCM_S8___1 = 1,
    SF_FORMAT_PCM_16___1 = 2,
    SF_FORMAT_PCM_24___1 = 3,
    SF_FORMAT_PCM_32___1 = 4,
    SF_FORMAT_PCM_U8___1 = 5,
    SF_FORMAT_FLOAT___1 = 6,
    SF_FORMAT_DOUBLE___1 = 7,
    SF_FORMAT_ULAW___1 = 16,
    SF_FORMAT_ALAW___1 = 17,
    SF_FORMAT_IMA_ADPCM___1 = 18,
    SF_FORMAT_MS_ADPCM___1 = 19,
    SF_FORMAT_GSM610___1 = 32,
    SF_FORMAT_VOX_ADPCM___1 = 33,
    SF_FORMAT_G721_32___1 = 48,
    SF_FORMAT_G723_24___1 = 49,
    SF_FORMAT_G723_40___1 = 50,
    SF_FORMAT_DWVW_12___1 = 64,
    SF_FORMAT_DWVW_16___1 = 65,
    SF_FORMAT_DWVW_24___1 = 66,
    SF_FORMAT_DWVW_N___1 = 67,
    SF_FORMAT_DPCM_8___1 = 80,
    SF_FORMAT_DPCM_16___1 = 81,
    SF_FORMAT_VORBIS___1 = 96,
    SF_ENDIAN_FILE___1 = 0,
    SF_ENDIAN_LITTLE___1 = 268435456,
    SF_ENDIAN_BIG___1 = 536870912,
    SF_ENDIAN_CPU___1 = 805306368,
    SF_FORMAT_SUBMASK___1 = 65535,
    SF_FORMAT_TYPEMASK___1 = 268369920,
    SF_FORMAT_ENDMASK___1 = 805306368
} ;
#line 126
enum __anonenum__138 {
    SFC_GET_LIB_VERSION___1 = 4096,
    SFC_GET_LOG_INFO___1 = 4097,
    SFC_GET_CURRENT_SF_INFO___1 = 4098,
    SFC_GET_NORM_DOUBLE___1 = 4112,
    SFC_GET_NORM_FLOAT___1 = 4113,
    SFC_SET_NORM_DOUBLE___1 = 4114,
    SFC_SET_NORM_FLOAT___1 = 4115,
    SFC_SET_SCALE_FLOAT_INT_READ___1 = 4116,
    SFC_SET_SCALE_INT_FLOAT_WRITE___1 = 4117,
    SFC_GET_SIMPLE_FORMAT_COUNT___1 = 4128,
    SFC_GET_SIMPLE_FORMAT___1 = 4129,
    SFC_GET_FORMAT_INFO___1 = 4136,
    SFC_GET_FORMAT_MAJOR_COUNT___1 = 4144,
    SFC_GET_FORMAT_MAJOR___1 = 4145,
    SFC_GET_FORMAT_SUBTYPE_COUNT___1 = 4146,
    SFC_GET_FORMAT_SUBTYPE___1 = 4147,
    SFC_CALC_SIGNAL_MAX___1 = 4160,
    SFC_CALC_NORM_SIGNAL_MAX___1 = 4161,
    SFC_CALC_MAX_ALL_CHANNELS___1 = 4162,
    SFC_CALC_NORM_MAX_ALL_CHANNELS___1 = 4163,
    SFC_GET_SIGNAL_MAX___1 = 4164,
    SFC_GET_MAX_ALL_CHANNELS___1 = 4165,
    SFC_SET_ADD_PEAK_CHUNK___1 = 4176,
    SFC_SET_ADD_HEADER_PAD_CHUNK___1 = 4177,
    SFC_UPDATE_HEADER_NOW___1 = 4192,
    SFC_SET_UPDATE_HEADER_AUTO___1 = 4193,
    SFC_FILE_TRUNCATE___1 = 4224,
    SFC_SET_RAW_START_OFFSET___1 = 4240,
    SFC_SET_DITHER_ON_WRITE___1 = 4256,
    SFC_SET_DITHER_ON_READ___1 = 4257,
    SFC_GET_DITHER_INFO_COUNT___1 = 4258,
    SFC_GET_DITHER_INFO___1 = 4259,
    SFC_GET_EMBED_FILE_INFO___1 = 4272,
    SFC_SET_CLIPPING___1 = 4288,
    SFC_GET_CLIPPING___1 = 4289,
    SFC_GET_INSTRUMENT___1 = 4304,
    SFC_SET_INSTRUMENT___1 = 4305,
    SFC_GET_LOOP_INFO___1 = 4320,
    SFC_GET_BROADCAST_INFO___1 = 4336,
    SFC_SET_BROADCAST_INFO___1 = 4337,
    SFC_GET_CHANNEL_MAP_INFO___1 = 4352,
    SFC_SET_CHANNEL_MAP_INFO___1 = 4353,
    SFC_RAW_DATA_NEEDS_ENDSWAP___1 = 4368,
    SFC_WAVEX_SET_AMBISONIC___1 = 4608,
    SFC_WAVEX_GET_AMBISONIC___1 = 4609,
    SFC_SET_VBR_ENCODING_QUALITY___1 = 4864,
    SFC_TEST_IEEE_FLOAT_REPLACE___1 = 24577,
    SFC_SET_ADD_DITHER_ON_WRITE___1 = 4208,
    SFC_SET_ADD_DITHER_ON_READ___1 = 4209
} ;
#line 216
enum __anonenum__139 {
    SF_STR_TITLE___1 = 1,
    SF_STR_COPYRIGHT___1 = 2,
    SF_STR_SOFTWARE___1 = 3,
    SF_STR_ARTIST___1 = 4,
    SF_STR_COMMENT___1 = 5,
    SF_STR_DATE___1 = 6,
    SF_STR_ALBUM___1 = 7,
    SF_STR_LICENSE___1 = 8
} ;
#line 235
enum __anonenum__140 {
    SF_FALSE___1 = 0,
    SF_TRUE___1 = 1,
    SFM_READ___1 = 16,
    SFM_WRITE___1 = 32,
    SFM_RDWR___1 = 48,
    SF_AMBISONIC_NONE___1 = 64,
    SF_AMBISONIC_B_FORMAT___1 = 65
} ;
#line 255
enum __anonenum__141 {
    SF_ERR_NO_ERROR___1 = 0,
    SF_ERR_UNRECOGNISED_FORMAT___1 = 1,
    SF_ERR_SYSTEM___1 = 2,
    SF_ERR_MALFORMED_FILE___1 = 3,
    SF_ERR_UNSUPPORTED_ENCODING___1 = 4
} ;
#line 267
enum __anonenum__142 {
    SF_CHANNEL_MAP_INVALID___1 = 0,
    SF_CHANNEL_MAP_MONO___1 = 1,
    SF_CHANNEL_MAP_LEFT___1 = 2,
    SF_CHANNEL_MAP_RIGHT___1 = 3,
    SF_CHANNEL_MAP_CENTER___1 = 4,
    SF_CHANNEL_MAP_FRONT_LEFT___1 = 5,
    SF_CHANNEL_MAP_FRONT_RIGHT___1 = 6,
    SF_CHANNEL_MAP_FRONT_CENTER___1 = 7,
    SF_CHANNEL_MAP_REAR_CENTER___1 = 8,
    SF_CHANNEL_MAP_REAR_LEFT___1 = 9,
    SF_CHANNEL_MAP_REAR_RIGHT___1 = 10,
    SF_CHANNEL_MAP_LFE___1 = 11,
    SF_CHANNEL_MAP_FRONT_LEFT_OF_CENTER___1 = 12,
    SF_CHANNEL_MAP_FRONT_RIGHT_OF_CENTER___1 = 13,
    SF_CHANNEL_MAP_SIDE_LEFT___1 = 14,
    SF_CHANNEL_MAP_SIDE_RIGHT___1 = 15,
    SF_CHANNEL_MAP_TOP_CENTER___1 = 16,
    SF_CHANNEL_MAP_TOP_FRONT_LEFT___1 = 17,
    SF_CHANNEL_MAP_TOP_FRONT_RIGHT___1 = 18,
    SF_CHANNEL_MAP_TOP_FRONT_CENTER___1 = 19,
    SF_CHANNEL_MAP_TOP_REAR_LEFT___1 = 20,
    SF_CHANNEL_MAP_TOP_REAR_RIGHT___1 = 21,
    SF_CHANNEL_MAP_TOP_REAR_CENTER___1 = 22
} ;
#line 352
enum __anonenum__144 {
    SFD_DEFAULT_LEVEL___1 = 0,
    SFD_CUSTOM_LEVEL___1 = 1073741824,
    SFD_NO_DITHER___1 = 500,
    SFD_WHITE___1 = 501,
    SFD_TRIANGULAR_PDF___1 = 502
} ;
#line 380
enum __anonenum__147 {
    SF_LOOP_NONE___1 = 800,
    SF_LOOP_FORWARD___1 = 801,
    SF_LOOP_BACKWARD___1 = 802,
    SF_LOOP_ALTERNATING___1 = 803
} ;
#line 121 "/root/libsndfile/src/common.h"
enum __anonenum__156 {
    SF_PEAK_START___1 = 42,
    SF_PEAK_END___1 = 43,
    SF_SCALE_MAX___1 = 52,
    SF_SCALE_MIN___1 = 53,
    SF_STR_ALLOW_START___1 = 256,
    SF_STR_ALLOW_END___1 = 512,
    SF_STR_LOCATE_START___1 = 1024,
    SF_STR_LOCATE_END___1 = 2048,
    SFD_TYPEMASK___1 = 268435455
} ;
#line 149
enum __anonenum__157 {
    SF_FORMAT_TXW___1 = 67305472,
    SF_FORMAT_DWD___1 = 67371008,
    SF_FORMAT_REX___1 = 67764224,
    SF_FORMAT_REX2___1 = 67960832,
    SF_FORMAT_KRZ___1 = 68026368,
    SF_FORMAT_WMA___1 = 68157440,
    SF_FORMAT_SHN___1 = 68222976,
    SF_FORMAT_SVX_FIB___1 = 4128,
    SF_FORMAT_SVX_EXP___1 = 4129,
    SF_FORMAT_PCM_N___1 = 4144
} ;
#line 405
enum __anonenum__163 {
    SFE_NO_ERROR___1 = 0,
    SFE_BAD_OPEN_FORMAT___1 = 1,
    SFE_SYSTEM___1 = 2,
    SFE_MALFORMED_FILE___1 = 3,
    SFE_UNSUPPORTED_ENCODING___1 = 4,
    SFE_ZERO_MAJOR_FORMAT___1 = 5,
    SFE_ZERO_MINOR_FORMAT___1 = 6,
    SFE_BAD_FILE___1 = 7,
    SFE_BAD_FILE_READ___1 = 8,
    SFE_OPEN_FAILED___1 = 9,
    SFE_BAD_SNDFILE_PTR___1 = 10,
    SFE_BAD_SF_INFO_PTR___1 = 11,
    SFE_BAD_SF_INCOMPLETE___1 = 12,
    SFE_BAD_FILE_PTR___1 = 13,
    SFE_BAD_INT_PTR___1 = 14,
    SFE_BAD_STAT_SIZE___1 = 15,
    SFE_MALLOC_FAILED___1 = 16,
    SFE_UNIMPLEMENTED___1 = 17,
    SFE_BAD_READ_ALIGN___1 = 18,
    SFE_BAD_WRITE_ALIGN___1 = 19,
    SFE_UNKNOWN_FORMAT___1 = 20,
    SFE_NOT_READMODE___1 = 21,
    SFE_NOT_WRITEMODE___1 = 22,
    SFE_BAD_MODE_RW___1 = 23,
    SFE_BAD_SF_INFO___1 = 24,
    SFE_BAD_OFFSET___1 = 25,
    SFE_NO_EMBED_SUPPORT___1 = 26,
    SFE_NO_EMBEDDED_RDWR___1 = 27,
    SFE_NO_PIPE_WRITE___1 = 28,
    SFE_INTERNAL___1 = 29,
    SFE_BAD_COMMAND_PARAM___1 = 30,
    SFE_BAD_ENDIAN___1 = 31,
    SFE_CHANNEL_COUNT_ZERO___1 = 32,
    SFE_CHANNEL_COUNT___1 = 33,
    SFE_BAD_VIRTUAL_IO___1 = 34,
    SFE_INTERLEAVE_MODE___1 = 35,
    SFE_INTERLEAVE_SEEK___1 = 36,
    SFE_INTERLEAVE_READ___1 = 37,
    SFE_BAD_SEEK___1 = 38,
    SFE_NOT_SEEKABLE___1 = 39,
    SFE_AMBIGUOUS_SEEK___1 = 40,
    SFE_WRONG_SEEK___1 = 41,
    SFE_SEEK_FAILED___1 = 42,
    SFE_BAD_OPEN_MODE___1 = 43,
    SFE_OPEN_PIPE_RDWR___1 = 44,
    SFE_RDWR_POSITION___1 = 45,
    SFE_RDWR_BAD_HEADER___1 = 46,
    SFE_CMD_HAS_DATA___1 = 47,
    SFE_BAD_BROADCAST_INFO_SIZE___1 = 48,
    SFE_STR_NO_SUPPORT___1 = 49,
    SFE_STR_NOT_WRITE___1 = 50,
    SFE_STR_MAX_DATA___1 = 51,
    SFE_STR_MAX_COUNT___1 = 52,
    SFE_STR_BAD_TYPE___1 = 53,
    SFE_STR_NO_ADD_END___1 = 54,
    SFE_STR_BAD_STRING___1 = 55,
    SFE_STR_WEIRD___1 = 56,
    SFE_WAV_NO_RIFF___1 = 57,
    SFE_WAV_NO_WAVE___1 = 58,
    SFE_WAV_NO_FMT___1 = 59,
    SFE_WAV_BAD_FMT___1 = 60,
    SFE_WAV_FMT_SHORT___1 = 61,
    SFE_WAV_BAD_FACT___1 = 62,
    SFE_WAV_BAD_PEAK___1 = 63,
    SFE_WAV_PEAK_B4_FMT___1 = 64,
    SFE_WAV_BAD_FORMAT___1 = 65,
    SFE_WAV_BAD_BLOCKALIGN___1 = 66,
    SFE_WAV_NO_DATA___1 = 67,
    SFE_WAV_BAD_LIST___1 = 68,
    SFE_WAV_ADPCM_NOT4BIT___1 = 69,
    SFE_WAV_ADPCM_CHANNELS___1 = 70,
    SFE_WAV_GSM610_FORMAT___1 = 71,
    SFE_WAV_UNKNOWN_CHUNK___1 = 72,
    SFE_WAV_WVPK_DATA___1 = 73,
    SFE_AIFF_NO_FORM___1 = 74,
    SFE_AIFF_AIFF_NO_FORM___1 = 75,
    SFE_AIFF_COMM_NO_FORM___1 = 76,
    SFE_AIFF_SSND_NO_COMM___1 = 77,
    SFE_AIFF_UNKNOWN_CHUNK___1 = 78,
    SFE_AIFF_COMM_CHUNK_SIZE___1 = 79,
    SFE_AIFF_BAD_COMM_CHUNK___1 = 80,
    SFE_AIFF_PEAK_B4_COMM___1 = 81,
    SFE_AIFF_BAD_PEAK___1 = 82,
    SFE_AIFF_NO_SSND___1 = 83,
    SFE_AIFF_NO_DATA___1 = 84,
    SFE_AIFF_RW_SSND_NOT_LAST___1 = 85,
    SFE_AU_UNKNOWN_FORMAT___1 = 86,
    SFE_AU_NO_DOTSND___1 = 87,
    SFE_AU_EMBED_BAD_LEN___1 = 88,
    SFE_RAW_READ_BAD_SPEC___1 = 89,
    SFE_RAW_BAD_BITWIDTH___1 = 90,
    SFE_RAW_BAD_FORMAT___1 = 91,
    SFE_PAF_NO_MARKER___1 = 92,
    SFE_PAF_VERSION___1 = 93,
    SFE_PAF_UNKNOWN_FORMAT___1 = 94,
    SFE_PAF_SHORT_HEADER___1 = 95,
    SFE_SVX_NO_FORM___1 = 96,
    SFE_SVX_NO_BODY___1 = 97,
    SFE_SVX_NO_DATA___1 = 98,
    SFE_SVX_BAD_COMP___1 = 99,
    SFE_SVX_BAD_NAME_LENGTH___1 = 100,
    SFE_NIST_BAD_HEADER___1 = 101,
    SFE_NIST_CRLF_CONVERISON___1 = 102,
    SFE_NIST_BAD_ENCODING___1 = 103,
    SFE_VOC_NO_CREATIVE___1 = 104,
    SFE_VOC_BAD_FORMAT___1 = 105,
    SFE_VOC_BAD_VERSION___1 = 106,
    SFE_VOC_BAD_MARKER___1 = 107,
    SFE_VOC_BAD_SECTIONS___1 = 108,
    SFE_VOC_MULTI_SAMPLERATE___1 = 109,
    SFE_VOC_MULTI_SECTION___1 = 110,
    SFE_VOC_MULTI_PARAM___1 = 111,
    SFE_VOC_SECTION_COUNT___1 = 112,
    SFE_VOC_NO_PIPE___1 = 113,
    SFE_IRCAM_NO_MARKER___1 = 114,
    SFE_IRCAM_BAD_CHANNELS___1 = 115,
    SFE_IRCAM_UNKNOWN_FORMAT___1 = 116,
    SFE_W64_64_BIT___1 = 117,
    SFE_W64_NO_RIFF___1 = 118,
    SFE_W64_NO_WAVE___1 = 119,
    SFE_W64_NO_DATA___1 = 120,
    SFE_W64_ADPCM_NOT4BIT___1 = 121,
    SFE_W64_ADPCM_CHANNELS___1 = 122,
    SFE_W64_GSM610_FORMAT___1 = 123,
    SFE_MAT4_BAD_NAME___1 = 124,
    SFE_MAT4_NO_SAMPLERATE___1 = 125,
    SFE_MAT5_BAD_ENDIAN___1 = 126,
    SFE_MAT5_NO_BLOCK___1 = 127,
    SFE_MAT5_SAMPLE_RATE___1 = 128,
    SFE_PVF_NO_PVF1___1 = 129,
    SFE_PVF_BAD_HEADER___1 = 130,
    SFE_PVF_BAD_BITWIDTH___1 = 131,
    SFE_DWVW_BAD_BITWIDTH___1 = 132,
    SFE_G72X_NOT_MONO___1 = 133,
    SFE_XI_BAD_HEADER___1 = 134,
    SFE_XI_EXCESS_SAMPLES___1 = 135,
    SFE_XI_NO_PIPE___1 = 136,
    SFE_HTK_NO_PIPE___1 = 137,
    SFE_SDS_NOT_SDS___1 = 138,
    SFE_SDS_BAD_BIT_WIDTH___1 = 139,
    SFE_SD2_FD_DISALLOWED___1 = 140,
    SFE_SD2_BAD_DATA_OFFSET___1 = 141,
    SFE_SD2_BAD_MAP_OFFSET___1 = 142,
    SFE_SD2_BAD_DATA_LENGTH___1 = 143,
    SFE_SD2_BAD_MAP_LENGTH___1 = 144,
    SFE_SD2_BAD_RSRC___1 = 145,
    SFE_SD2_BAD_SAMPLE_SIZE___1 = 146,
    SFE_FLAC_BAD_HEADER___1 = 147,
    SFE_FLAC_NEW_DECODER___1 = 148,
    SFE_FLAC_INIT_DECODER___1 = 149,
    SFE_FLAC_LOST_SYNC___1 = 150,
    SFE_FLAC_BAD_SAMPLE_RATE___1 = 151,
    SFE_FLAC_UNKOWN_ERROR___1 = 152,
    SFE_WVE_NOT_WVE___1 = 153,
    SFE_WVE_NO_PIPE___1 = 154,
    SFE_VORBIS_ENCODER_BUG___1 = 155,
    SFE_RF64_NOT_RF64___1 = 156,
    SFE_MAX_ERROR___1 = 157
} ;
#line 823
enum __anonenum__167 {
    SFC_TEST_AIFF_ADD_INST_CHUNK___1 = 8192,
    SFC_TEST_WAV_ADD_INFO_CHUNK___1 = 8208
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__74___0 {
    FP_NAN___2 = 0,
    FP_INFINITE___2 = 1,
    FP_ZERO___2 = 2,
    FP_SUBNORMAL___2 = 3,
    FP_NORMAL___2 = 4
} ;
#line 46 "/root/libsndfile/src/sndfile.h"
enum __anonenum__91___0 {
    SF_FORMAT_WAV___2 = 65536,
    SF_FORMAT_AIFF___2 = 131072,
    SF_FORMAT_AU___2 = 196608,
    SF_FORMAT_RAW___2 = 262144,
    SF_FORMAT_PAF___2 = 327680,
    SF_FORMAT_SVX___2 = 393216,
    SF_FORMAT_NIST___2 = 458752,
    SF_FORMAT_VOC___2 = 524288,
    SF_FORMAT_IRCAM___2 = 655360,
    SF_FORMAT_W64___2 = 720896,
    SF_FORMAT_MAT4___2 = 786432,
    SF_FORMAT_MAT5___2 = 851968,
    SF_FORMAT_PVF___2 = 917504,
    SF_FORMAT_XI___2 = 983040,
    SF_FORMAT_HTK___2 = 1048576,
    SF_FORMAT_SDS___2 = 1114112,
    SF_FORMAT_AVR___2 = 1179648,
    SF_FORMAT_WAVEX___2 = 1245184,
    SF_FORMAT_SD2___2 = 1441792,
    SF_FORMAT_FLAC___2 = 1507328,
    SF_FORMAT_CAF___2 = 1572864,
    SF_FORMAT_WVE___2 = 1638400,
    SF_FORMAT_OGG___2 = 2097152,
    SF_FORMAT_MPC2K___2 = 2162688,
    SF_FORMAT_RF64___2 = 2228224,
    SF_FORMAT_PCM_S8___2 = 1,
    SF_FORMAT_PCM_16___2 = 2,
    SF_FORMAT_PCM_24___2 = 3,
    SF_FORMAT_PCM_32___2 = 4,
    SF_FORMAT_PCM_U8___2 = 5,
    SF_FORMAT_FLOAT___2 = 6,
    SF_FORMAT_DOUBLE___2 = 7,
    SF_FORMAT_ULAW___2 = 16,
    SF_FORMAT_ALAW___2 = 17,
    SF_FORMAT_IMA_ADPCM___2 = 18,
    SF_FORMAT_MS_ADPCM___2 = 19,
    SF_FORMAT_GSM610___2 = 32,
    SF_FORMAT_VOX_ADPCM___2 = 33,
    SF_FORMAT_G721_32___2 = 48,
    SF_FORMAT_G723_24___2 = 49,
    SF_FORMAT_G723_40___2 = 50,
    SF_FORMAT_DWVW_12___2 = 64,
    SF_FORMAT_DWVW_16___2 = 65,
    SF_FORMAT_DWVW_24___2 = 66,
    SF_FORMAT_DWVW_N___2 = 67,
    SF_FORMAT_DPCM_8___2 = 80,
    SF_FORMAT_DPCM_16___2 = 81,
    SF_FORMAT_VORBIS___2 = 96,
    SF_ENDIAN_FILE___2 = 0,
    SF_ENDIAN_LITTLE___2 = 268435456,
    SF_ENDIAN_BIG___2 = 536870912,
    SF_ENDIAN_CPU___2 = 805306368,
    SF_FORMAT_SUBMASK___2 = 65535,
    SF_FORMAT_TYPEMASK___2 = 268369920,
    SF_FORMAT_ENDMASK___2 = 805306368
} ;
#line 126
enum __anonenum__92___0 {
    SFC_GET_LIB_VERSION___2 = 4096,
    SFC_GET_LOG_INFO___2 = 4097,
    SFC_GET_CURRENT_SF_INFO___2 = 4098,
    SFC_GET_NORM_DOUBLE___2 = 4112,
    SFC_GET_NORM_FLOAT___2 = 4113,
    SFC_SET_NORM_DOUBLE___2 = 4114,
    SFC_SET_NORM_FLOAT___2 = 4115,
    SFC_SET_SCALE_FLOAT_INT_READ___2 = 4116,
    SFC_SET_SCALE_INT_FLOAT_WRITE___2 = 4117,
    SFC_GET_SIMPLE_FORMAT_COUNT___2 = 4128,
    SFC_GET_SIMPLE_FORMAT___2 = 4129,
    SFC_GET_FORMAT_INFO___2 = 4136,
    SFC_GET_FORMAT_MAJOR_COUNT___2 = 4144,
    SFC_GET_FORMAT_MAJOR___2 = 4145,
    SFC_GET_FORMAT_SUBTYPE_COUNT___2 = 4146,
    SFC_GET_FORMAT_SUBTYPE___2 = 4147,
    SFC_CALC_SIGNAL_MAX___2 = 4160,
    SFC_CALC_NORM_SIGNAL_MAX___2 = 4161,
    SFC_CALC_MAX_ALL_CHANNELS___2 = 4162,
    SFC_CALC_NORM_MAX_ALL_CHANNELS___2 = 4163,
    SFC_GET_SIGNAL_MAX___2 = 4164,
    SFC_GET_MAX_ALL_CHANNELS___2 = 4165,
    SFC_SET_ADD_PEAK_CHUNK___2 = 4176,
    SFC_SET_ADD_HEADER_PAD_CHUNK___2 = 4177,
    SFC_UPDATE_HEADER_NOW___2 = 4192,
    SFC_SET_UPDATE_HEADER_AUTO___2 = 4193,
    SFC_FILE_TRUNCATE___2 = 4224,
    SFC_SET_RAW_START_OFFSET___2 = 4240,
    SFC_SET_DITHER_ON_WRITE___2 = 4256,
    SFC_SET_DITHER_ON_READ___2 = 4257,
    SFC_GET_DITHER_INFO_COUNT___2 = 4258,
    SFC_GET_DITHER_INFO___2 = 4259,
    SFC_GET_EMBED_FILE_INFO___2 = 4272,
    SFC_SET_CLIPPING___2 = 4288,
    SFC_GET_CLIPPING___2 = 4289,
    SFC_GET_INSTRUMENT___2 = 4304,
    SFC_SET_INSTRUMENT___2 = 4305,
    SFC_GET_LOOP_INFO___2 = 4320,
    SFC_GET_BROADCAST_INFO___2 = 4336,
    SFC_SET_BROADCAST_INFO___2 = 4337,
    SFC_GET_CHANNEL_MAP_INFO___2 = 4352,
    SFC_SET_CHANNEL_MAP_INFO___2 = 4353,
    SFC_RAW_DATA_NEEDS_ENDSWAP___2 = 4368,
    SFC_WAVEX_SET_AMBISONIC___2 = 4608,
    SFC_WAVEX_GET_AMBISONIC___2 = 4609,
    SFC_SET_VBR_ENCODING_QUALITY___2 = 4864,
    SFC_TEST_IEEE_FLOAT_REPLACE___2 = 24577,
    SFC_SET_ADD_DITHER_ON_WRITE___2 = 4208,
    SFC_SET_ADD_DITHER_ON_READ___2 = 4209
} ;
#line 216
enum __anonenum__93___0 {
    SF_STR_TITLE___2 = 1,
    SF_STR_COPYRIGHT___2 = 2,
    SF_STR_SOFTWARE___2 = 3,
    SF_STR_ARTIST___2 = 4,
    SF_STR_COMMENT___2 = 5,
    SF_STR_DATE___2 = 6,
    SF_STR_ALBUM___2 = 7,
    SF_STR_LICENSE___2 = 8
} ;
#line 235
enum __anonenum__94___0 {
    SF_FALSE___2 = 0,
    SF_TRUE___2 = 1,
    SFM_READ___2 = 16,
    SFM_WRITE___2 = 32,
    SFM_RDWR___2 = 48,
    SF_AMBISONIC_NONE___2 = 64,
    SF_AMBISONIC_B_FORMAT___2 = 65
} ;
#line 255
enum __anonenum__95___0 {
    SF_ERR_NO_ERROR___2 = 0,
    SF_ERR_UNRECOGNISED_FORMAT___2 = 1,
    SF_ERR_SYSTEM___2 = 2,
    SF_ERR_MALFORMED_FILE___2 = 3,
    SF_ERR_UNSUPPORTED_ENCODING___2 = 4
} ;
#line 267
enum __anonenum__96___0 {
    SF_CHANNEL_MAP_INVALID___2 = 0,
    SF_CHANNEL_MAP_MONO___2 = 1,
    SF_CHANNEL_MAP_LEFT___2 = 2,
    SF_CHANNEL_MAP_RIGHT___2 = 3,
    SF_CHANNEL_MAP_CENTER___2 = 4,
    SF_CHANNEL_MAP_FRONT_LEFT___2 = 5,
    SF_CHANNEL_MAP_FRONT_RIGHT___2 = 6,
    SF_CHANNEL_MAP_FRONT_CENTER___2 = 7,
    SF_CHANNEL_MAP_REAR_CENTER___2 = 8,
    SF_CHANNEL_MAP_REAR_LEFT___2 = 9,
    SF_CHANNEL_MAP_REAR_RIGHT___2 = 10,
    SF_CHANNEL_MAP_LFE___2 = 11,
    SF_CHANNEL_MAP_FRONT_LEFT_OF_CENTER___2 = 12,
    SF_CHANNEL_MAP_FRONT_RIGHT_OF_CENTER___2 = 13,
    SF_CHANNEL_MAP_SIDE_LEFT___2 = 14,
    SF_CHANNEL_MAP_SIDE_RIGHT___2 = 15,
    SF_CHANNEL_MAP_TOP_CENTER___2 = 16,
    SF_CHANNEL_MAP_TOP_FRONT_LEFT___2 = 17,
    SF_CHANNEL_MAP_TOP_FRONT_RIGHT___2 = 18,
    SF_CHANNEL_MAP_TOP_FRONT_CENTER___2 = 19,
    SF_CHANNEL_MAP_TOP_REAR_LEFT___2 = 20,
    SF_CHANNEL_MAP_TOP_REAR_RIGHT___2 = 21,
    SF_CHANNEL_MAP_TOP_REAR_CENTER___2 = 22
} ;
#line 352
enum __anonenum__98___0 {
    SFD_DEFAULT_LEVEL___2 = 0,
    SFD_CUSTOM_LEVEL___2 = 1073741824,
    SFD_NO_DITHER___2 = 500,
    SFD_WHITE___2 = 501,
    SFD_TRIANGULAR_PDF___2 = 502
} ;
#line 380
enum __anonenum__101___0 {
    SF_LOOP_NONE___2 = 800,
    SF_LOOP_FORWARD___2 = 801,
    SF_LOOP_BACKWARD___2 = 802,
    SF_LOOP_ALTERNATING___2 = 803
} ;
#line 121 "/root/libsndfile/src/common.h"
enum __anonenum__172 {
    SF_PEAK_START___2 = 42,
    SF_PEAK_END___2 = 43,
    SF_SCALE_MAX___2 = 52,
    SF_SCALE_MIN___2 = 53,
    SF_STR_ALLOW_START___2 = 256,
    SF_STR_ALLOW_END___2 = 512,
    SF_STR_LOCATE_START___2 = 1024,
    SF_STR_LOCATE_END___2 = 2048,
    SFD_TYPEMASK___2 = 268435455
} ;
#line 149
enum __anonenum__173 {
    SF_FORMAT_TXW___2 = 67305472,
    SF_FORMAT_DWD___2 = 67371008,
    SF_FORMAT_REX___2 = 67764224,
    SF_FORMAT_REX2___2 = 67960832,
    SF_FORMAT_KRZ___2 = 68026368,
    SF_FORMAT_WMA___2 = 68157440,
    SF_FORMAT_SHN___2 = 68222976,
    SF_FORMAT_SVX_FIB___2 = 4128,
    SF_FORMAT_SVX_EXP___2 = 4129,
    SF_FORMAT_PCM_N___2 = 4144
} ;
#line 405
enum __anonenum__179 {
    SFE_NO_ERROR___2 = 0,
    SFE_BAD_OPEN_FORMAT___2 = 1,
    SFE_SYSTEM___2 = 2,
    SFE_MALFORMED_FILE___2 = 3,
    SFE_UNSUPPORTED_ENCODING___2 = 4,
    SFE_ZERO_MAJOR_FORMAT___2 = 5,
    SFE_ZERO_MINOR_FORMAT___2 = 6,
    SFE_BAD_FILE___2 = 7,
    SFE_BAD_FILE_READ___2 = 8,
    SFE_OPEN_FAILED___2 = 9,
    SFE_BAD_SNDFILE_PTR___2 = 10,
    SFE_BAD_SF_INFO_PTR___2 = 11,
    SFE_BAD_SF_INCOMPLETE___2 = 12,
    SFE_BAD_FILE_PTR___2 = 13,
    SFE_BAD_INT_PTR___2 = 14,
    SFE_BAD_STAT_SIZE___2 = 15,
    SFE_MALLOC_FAILED___2 = 16,
    SFE_UNIMPLEMENTED___2 = 17,
    SFE_BAD_READ_ALIGN___2 = 18,
    SFE_BAD_WRITE_ALIGN___2 = 19,
    SFE_UNKNOWN_FORMAT___2 = 20,
    SFE_NOT_READMODE___2 = 21,
    SFE_NOT_WRITEMODE___2 = 22,
    SFE_BAD_MODE_RW___2 = 23,
    SFE_BAD_SF_INFO___2 = 24,
    SFE_BAD_OFFSET___2 = 25,
    SFE_NO_EMBED_SUPPORT___2 = 26,
    SFE_NO_EMBEDDED_RDWR___2 = 27,
    SFE_NO_PIPE_WRITE___2 = 28,
    SFE_INTERNAL___2 = 29,
    SFE_BAD_COMMAND_PARAM___2 = 30,
    SFE_BAD_ENDIAN___2 = 31,
    SFE_CHANNEL_COUNT_ZERO___2 = 32,
    SFE_CHANNEL_COUNT___2 = 33,
    SFE_BAD_VIRTUAL_IO___2 = 34,
    SFE_INTERLEAVE_MODE___2 = 35,
    SFE_INTERLEAVE_SEEK___2 = 36,
    SFE_INTERLEAVE_READ___2 = 37,
    SFE_BAD_SEEK___2 = 38,
    SFE_NOT_SEEKABLE___2 = 39,
    SFE_AMBIGUOUS_SEEK___2 = 40,
    SFE_WRONG_SEEK___2 = 41,
    SFE_SEEK_FAILED___2 = 42,
    SFE_BAD_OPEN_MODE___2 = 43,
    SFE_OPEN_PIPE_RDWR___2 = 44,
    SFE_RDWR_POSITION___2 = 45,
    SFE_RDWR_BAD_HEADER___2 = 46,
    SFE_CMD_HAS_DATA___2 = 47,
    SFE_BAD_BROADCAST_INFO_SIZE___2 = 48,
    SFE_STR_NO_SUPPORT___2 = 49,
    SFE_STR_NOT_WRITE___2 = 50,
    SFE_STR_MAX_DATA___2 = 51,
    SFE_STR_MAX_COUNT___2 = 52,
    SFE_STR_BAD_TYPE___2 = 53,
    SFE_STR_NO_ADD_END___2 = 54,
    SFE_STR_BAD_STRING___2 = 55,
    SFE_STR_WEIRD___2 = 56,
    SFE_WAV_NO_RIFF___2 = 57,
    SFE_WAV_NO_WAVE___2 = 58,
    SFE_WAV_NO_FMT___2 = 59,
    SFE_WAV_BAD_FMT___2 = 60,
    SFE_WAV_FMT_SHORT___2 = 61,
    SFE_WAV_BAD_FACT___2 = 62,
    SFE_WAV_BAD_PEAK___2 = 63,
    SFE_WAV_PEAK_B4_FMT___2 = 64,
    SFE_WAV_BAD_FORMAT___2 = 65,
    SFE_WAV_BAD_BLOCKALIGN___2 = 66,
    SFE_WAV_NO_DATA___2 = 67,
    SFE_WAV_BAD_LIST___2 = 68,
    SFE_WAV_ADPCM_NOT4BIT___2 = 69,
    SFE_WAV_ADPCM_CHANNELS___2 = 70,
    SFE_WAV_GSM610_FORMAT___2 = 71,
    SFE_WAV_UNKNOWN_CHUNK___2 = 72,
    SFE_WAV_WVPK_DATA___2 = 73,
    SFE_AIFF_NO_FORM___2 = 74,
    SFE_AIFF_AIFF_NO_FORM___2 = 75,
    SFE_AIFF_COMM_NO_FORM___2 = 76,
    SFE_AIFF_SSND_NO_COMM___2 = 77,
    SFE_AIFF_UNKNOWN_CHUNK___2 = 78,
    SFE_AIFF_COMM_CHUNK_SIZE___2 = 79,
    SFE_AIFF_BAD_COMM_CHUNK___2 = 80,
    SFE_AIFF_PEAK_B4_COMM___2 = 81,
    SFE_AIFF_BAD_PEAK___2 = 82,
    SFE_AIFF_NO_SSND___2 = 83,
    SFE_AIFF_NO_DATA___2 = 84,
    SFE_AIFF_RW_SSND_NOT_LAST___2 = 85,
    SFE_AU_UNKNOWN_FORMAT___2 = 86,
    SFE_AU_NO_DOTSND___2 = 87,
    SFE_AU_EMBED_BAD_LEN___2 = 88,
    SFE_RAW_READ_BAD_SPEC___2 = 89,
    SFE_RAW_BAD_BITWIDTH___2 = 90,
    SFE_RAW_BAD_FORMAT___2 = 91,
    SFE_PAF_NO_MARKER___2 = 92,
    SFE_PAF_VERSION___2 = 93,
    SFE_PAF_UNKNOWN_FORMAT___2 = 94,
    SFE_PAF_SHORT_HEADER___2 = 95,
    SFE_SVX_NO_FORM___2 = 96,
    SFE_SVX_NO_BODY___2 = 97,
    SFE_SVX_NO_DATA___2 = 98,
    SFE_SVX_BAD_COMP___2 = 99,
    SFE_SVX_BAD_NAME_LENGTH___2 = 100,
    SFE_NIST_BAD_HEADER___2 = 101,
    SFE_NIST_CRLF_CONVERISON___2 = 102,
    SFE_NIST_BAD_ENCODING___2 = 103,
    SFE_VOC_NO_CREATIVE___2 = 104,
    SFE_VOC_BAD_FORMAT___2 = 105,
    SFE_VOC_BAD_VERSION___2 = 106,
    SFE_VOC_BAD_MARKER___2 = 107,
    SFE_VOC_BAD_SECTIONS___2 = 108,
    SFE_VOC_MULTI_SAMPLERATE___2 = 109,
    SFE_VOC_MULTI_SECTION___2 = 110,
    SFE_VOC_MULTI_PARAM___2 = 111,
    SFE_VOC_SECTION_COUNT___2 = 112,
    SFE_VOC_NO_PIPE___2 = 113,
    SFE_IRCAM_NO_MARKER___2 = 114,
    SFE_IRCAM_BAD_CHANNELS___2 = 115,
    SFE_IRCAM_UNKNOWN_FORMAT___2 = 116,
    SFE_W64_64_BIT___2 = 117,
    SFE_W64_NO_RIFF___2 = 118,
    SFE_W64_NO_WAVE___2 = 119,
    SFE_W64_NO_DATA___2 = 120,
    SFE_W64_ADPCM_NOT4BIT___2 = 121,
    SFE_W64_ADPCM_CHANNELS___2 = 122,
    SFE_W64_GSM610_FORMAT___2 = 123,
    SFE_MAT4_BAD_NAME___2 = 124,
    SFE_MAT4_NO_SAMPLERATE___2 = 125,
    SFE_MAT5_BAD_ENDIAN___2 = 126,
    SFE_MAT5_NO_BLOCK___2 = 127,
    SFE_MAT5_SAMPLE_RATE___2 = 128,
    SFE_PVF_NO_PVF1___2 = 129,
    SFE_PVF_BAD_HEADER___2 = 130,
    SFE_PVF_BAD_BITWIDTH___2 = 131,
    SFE_DWVW_BAD_BITWIDTH___2 = 132,
    SFE_G72X_NOT_MONO___2 = 133,
    SFE_XI_BAD_HEADER___2 = 134,
    SFE_XI_EXCESS_SAMPLES___2 = 135,
    SFE_XI_NO_PIPE___2 = 136,
    SFE_HTK_NO_PIPE___2 = 137,
    SFE_SDS_NOT_SDS___2 = 138,
    SFE_SDS_BAD_BIT_WIDTH___2 = 139,
    SFE_SD2_FD_DISALLOWED___2 = 140,
    SFE_SD2_BAD_DATA_OFFSET___2 = 141,
    SFE_SD2_BAD_MAP_OFFSET___2 = 142,
    SFE_SD2_BAD_DATA_LENGTH___2 = 143,
    SFE_SD2_BAD_MAP_LENGTH___2 = 144,
    SFE_SD2_BAD_RSRC___2 = 145,
    SFE_SD2_BAD_SAMPLE_SIZE___2 = 146,
    SFE_FLAC_BAD_HEADER___2 = 147,
    SFE_FLAC_NEW_DECODER___2 = 148,
    SFE_FLAC_INIT_DECODER___2 = 149,
    SFE_FLAC_LOST_SYNC___2 = 150,
    SFE_FLAC_BAD_SAMPLE_RATE___2 = 151,
    SFE_FLAC_UNKOWN_ERROR___2 = 152,
    SFE_WVE_NOT_WVE___2 = 153,
    SFE_WVE_NO_PIPE___2 = 154,
    SFE_VORBIS_ENCODER_BUG___2 = 155,
    SFE_RF64_NOT_RF64___2 = 156,
    SFE_MAX_ERROR___2 = 157
} ;
#line 823
enum __anonenum__183 {
    SFC_TEST_AIFF_ADD_INST_CHUNK___2 = 8192,
    SFC_TEST_WAV_ADD_INFO_CHUNK___2 = 8208
} ;
#line 31 "/root/libsndfile/src/pcm.c"
typedef void tribyte;
#line 110
enum __anonenum__184 {
    SF_CHARS_SIGNED = 200,
    SF_CHARS_UNSIGNED = 201
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__43___0 {
    FP_NAN___3 = 0,
    FP_INFINITE___3 = 1,
    FP_ZERO___3 = 2,
    FP_SUBNORMAL___3 = 3,
    FP_NORMAL___3 = 4
} ;
#line 46 "/root/libsndfile/src/sndfile.h"
enum __anonenum__44___0 {
    SF_FORMAT_WAV___3 = 65536,
    SF_FORMAT_AIFF___3 = 131072,
    SF_FORMAT_AU___3 = 196608,
    SF_FORMAT_RAW___3 = 262144,
    SF_FORMAT_PAF___3 = 327680,
    SF_FORMAT_SVX___3 = 393216,
    SF_FORMAT_NIST___3 = 458752,
    SF_FORMAT_VOC___3 = 524288,
    SF_FORMAT_IRCAM___3 = 655360,
    SF_FORMAT_W64___3 = 720896,
    SF_FORMAT_MAT4___3 = 786432,
    SF_FORMAT_MAT5___3 = 851968,
    SF_FORMAT_PVF___3 = 917504,
    SF_FORMAT_XI___3 = 983040,
    SF_FORMAT_HTK___3 = 1048576,
    SF_FORMAT_SDS___3 = 1114112,
    SF_FORMAT_AVR___3 = 1179648,
    SF_FORMAT_WAVEX___3 = 1245184,
    SF_FORMAT_SD2___3 = 1441792,
    SF_FORMAT_FLAC___3 = 1507328,
    SF_FORMAT_CAF___3 = 1572864,
    SF_FORMAT_WVE___3 = 1638400,
    SF_FORMAT_OGG___3 = 2097152,
    SF_FORMAT_MPC2K___3 = 2162688,
    SF_FORMAT_RF64___3 = 2228224,
    SF_FORMAT_PCM_S8___3 = 1,
    SF_FORMAT_PCM_16___3 = 2,
    SF_FORMAT_PCM_24___3 = 3,
    SF_FORMAT_PCM_32___3 = 4,
    SF_FORMAT_PCM_U8___3 = 5,
    SF_FORMAT_FLOAT___3 = 6,
    SF_FORMAT_DOUBLE___3 = 7,
    SF_FORMAT_ULAW___3 = 16,
    SF_FORMAT_ALAW___3 = 17,
    SF_FORMAT_IMA_ADPCM___3 = 18,
    SF_FORMAT_MS_ADPCM___3 = 19,
    SF_FORMAT_GSM610___3 = 32,
    SF_FORMAT_VOX_ADPCM___3 = 33,
    SF_FORMAT_G721_32___3 = 48,
    SF_FORMAT_G723_24___3 = 49,
    SF_FORMAT_G723_40___3 = 50,
    SF_FORMAT_DWVW_12___3 = 64,
    SF_FORMAT_DWVW_16___3 = 65,
    SF_FORMAT_DWVW_24___3 = 66,
    SF_FORMAT_DWVW_N___3 = 67,
    SF_FORMAT_DPCM_8___3 = 80,
    SF_FORMAT_DPCM_16___3 = 81,
    SF_FORMAT_VORBIS___3 = 96,
    SF_ENDIAN_FILE___3 = 0,
    SF_ENDIAN_LITTLE___3 = 268435456,
    SF_ENDIAN_BIG___3 = 536870912,
    SF_ENDIAN_CPU___3 = 805306368,
    SF_FORMAT_SUBMASK___3 = 65535,
    SF_FORMAT_TYPEMASK___3 = 268369920,
    SF_FORMAT_ENDMASK___3 = 805306368
} ;
#line 126
enum __anonenum__45___0 {
    SFC_GET_LIB_VERSION___3 = 4096,
    SFC_GET_LOG_INFO___3 = 4097,
    SFC_GET_CURRENT_SF_INFO___3 = 4098,
    SFC_GET_NORM_DOUBLE___3 = 4112,
    SFC_GET_NORM_FLOAT___3 = 4113,
    SFC_SET_NORM_DOUBLE___3 = 4114,
    SFC_SET_NORM_FLOAT___3 = 4115,
    SFC_SET_SCALE_FLOAT_INT_READ___3 = 4116,
    SFC_SET_SCALE_INT_FLOAT_WRITE___3 = 4117,
    SFC_GET_SIMPLE_FORMAT_COUNT___3 = 4128,
    SFC_GET_SIMPLE_FORMAT___3 = 4129,
    SFC_GET_FORMAT_INFO___3 = 4136,
    SFC_GET_FORMAT_MAJOR_COUNT___3 = 4144,
    SFC_GET_FORMAT_MAJOR___3 = 4145,
    SFC_GET_FORMAT_SUBTYPE_COUNT___3 = 4146,
    SFC_GET_FORMAT_SUBTYPE___3 = 4147,
    SFC_CALC_SIGNAL_MAX___3 = 4160,
    SFC_CALC_NORM_SIGNAL_MAX___3 = 4161,
    SFC_CALC_MAX_ALL_CHANNELS___3 = 4162,
    SFC_CALC_NORM_MAX_ALL_CHANNELS___3 = 4163,
    SFC_GET_SIGNAL_MAX___3 = 4164,
    SFC_GET_MAX_ALL_CHANNELS___3 = 4165,
    SFC_SET_ADD_PEAK_CHUNK___3 = 4176,
    SFC_SET_ADD_HEADER_PAD_CHUNK___3 = 4177,
    SFC_UPDATE_HEADER_NOW___3 = 4192,
    SFC_SET_UPDATE_HEADER_AUTO___3 = 4193,
    SFC_FILE_TRUNCATE___3 = 4224,
    SFC_SET_RAW_START_OFFSET___3 = 4240,
    SFC_SET_DITHER_ON_WRITE___3 = 4256,
    SFC_SET_DITHER_ON_READ___3 = 4257,
    SFC_GET_DITHER_INFO_COUNT___3 = 4258,
    SFC_GET_DITHER_INFO___3 = 4259,
    SFC_GET_EMBED_FILE_INFO___3 = 4272,
    SFC_SET_CLIPPING___3 = 4288,
    SFC_GET_CLIPPING___3 = 4289,
    SFC_GET_INSTRUMENT___3 = 4304,
    SFC_SET_INSTRUMENT___3 = 4305,
    SFC_GET_LOOP_INFO___3 = 4320,
    SFC_GET_BROADCAST_INFO___3 = 4336,
    SFC_SET_BROADCAST_INFO___3 = 4337,
    SFC_GET_CHANNEL_MAP_INFO___3 = 4352,
    SFC_SET_CHANNEL_MAP_INFO___3 = 4353,
    SFC_RAW_DATA_NEEDS_ENDSWAP___3 = 4368,
    SFC_WAVEX_SET_AMBISONIC___3 = 4608,
    SFC_WAVEX_GET_AMBISONIC___3 = 4609,
    SFC_SET_VBR_ENCODING_QUALITY___3 = 4864,
    SFC_TEST_IEEE_FLOAT_REPLACE___3 = 24577,
    SFC_SET_ADD_DITHER_ON_WRITE___3 = 4208,
    SFC_SET_ADD_DITHER_ON_READ___3 = 4209
} ;
#line 216
enum __anonenum__46___0 {
    SF_STR_TITLE___3 = 1,
    SF_STR_COPYRIGHT___3 = 2,
    SF_STR_SOFTWARE___3 = 3,
    SF_STR_ARTIST___3 = 4,
    SF_STR_COMMENT___3 = 5,
    SF_STR_DATE___3 = 6,
    SF_STR_ALBUM___3 = 7,
    SF_STR_LICENSE___3 = 8
} ;
#line 235
enum __anonenum__47___0 {
    SF_FALSE___3 = 0,
    SF_TRUE___3 = 1,
    SFM_READ___3 = 16,
    SFM_WRITE___3 = 32,
    SFM_RDWR___3 = 48,
    SF_AMBISONIC_NONE___3 = 64,
    SF_AMBISONIC_B_FORMAT___3 = 65
} ;
#line 255
enum __anonenum__48___0 {
    SF_ERR_NO_ERROR___3 = 0,
    SF_ERR_UNRECOGNISED_FORMAT___3 = 1,
    SF_ERR_SYSTEM___3 = 2,
    SF_ERR_MALFORMED_FILE___3 = 3,
    SF_ERR_UNSUPPORTED_ENCODING___3 = 4
} ;
#line 267
enum __anonenum__49___0 {
    SF_CHANNEL_MAP_INVALID___3 = 0,
    SF_CHANNEL_MAP_MONO___3 = 1,
    SF_CHANNEL_MAP_LEFT___3 = 2,
    SF_CHANNEL_MAP_RIGHT___3 = 3,
    SF_CHANNEL_MAP_CENTER___3 = 4,
    SF_CHANNEL_MAP_FRONT_LEFT___3 = 5,
    SF_CHANNEL_MAP_FRONT_RIGHT___3 = 6,
    SF_CHANNEL_MAP_FRONT_CENTER___3 = 7,
    SF_CHANNEL_MAP_REAR_CENTER___3 = 8,
    SF_CHANNEL_MAP_REAR_LEFT___3 = 9,
    SF_CHANNEL_MAP_REAR_RIGHT___3 = 10,
    SF_CHANNEL_MAP_LFE___3 = 11,
    SF_CHANNEL_MAP_FRONT_LEFT_OF_CENTER___3 = 12,
    SF_CHANNEL_MAP_FRONT_RIGHT_OF_CENTER___3 = 13,
    SF_CHANNEL_MAP_SIDE_LEFT___3 = 14,
    SF_CHANNEL_MAP_SIDE_RIGHT___3 = 15,
    SF_CHANNEL_MAP_TOP_CENTER___3 = 16,
    SF_CHANNEL_MAP_TOP_FRONT_LEFT___3 = 17,
    SF_CHANNEL_MAP_TOP_FRONT_RIGHT___3 = 18,
    SF_CHANNEL_MAP_TOP_FRONT_CENTER___3 = 19,
    SF_CHANNEL_MAP_TOP_REAR_LEFT___3 = 20,
    SF_CHANNEL_MAP_TOP_REAR_RIGHT___3 = 21,
    SF_CHANNEL_MAP_TOP_REAR_CENTER___3 = 22
} ;
#line 352
enum __anonenum__51___0 {
    SFD_DEFAULT_LEVEL___3 = 0,
    SFD_CUSTOM_LEVEL___3 = 1073741824,
    SFD_NO_DITHER___3 = 500,
    SFD_WHITE___3 = 501,
    SFD_TRIANGULAR_PDF___3 = 502
} ;
#line 380
enum __anonenum__54___0 {
    SF_LOOP_NONE___3 = 800,
    SF_LOOP_FORWARD___3 = 801,
    SF_LOOP_BACKWARD___3 = 802,
    SF_LOOP_ALTERNATING___3 = 803
} ;
#line 121 "/root/libsndfile/src/common.h"
enum __anonenum__59___0 {
    SF_PEAK_START___3 = 42,
    SF_PEAK_END___3 = 43,
    SF_SCALE_MAX___3 = 52,
    SF_SCALE_MIN___3 = 53,
    SF_STR_ALLOW_START___3 = 256,
    SF_STR_ALLOW_END___3 = 512,
    SF_STR_LOCATE_START___3 = 1024,
    SF_STR_LOCATE_END___3 = 2048,
    SFD_TYPEMASK___3 = 268435455
} ;
#line 149
enum __anonenum__60___0 {
    SF_FORMAT_TXW___3 = 67305472,
    SF_FORMAT_DWD___3 = 67371008,
    SF_FORMAT_REX___3 = 67764224,
    SF_FORMAT_REX2___3 = 67960832,
    SF_FORMAT_KRZ___3 = 68026368,
    SF_FORMAT_WMA___3 = 68157440,
    SF_FORMAT_SHN___3 = 68222976,
    SF_FORMAT_SVX_FIB___3 = 4128,
    SF_FORMAT_SVX_EXP___3 = 4129,
    SF_FORMAT_PCM_N___3 = 4144
} ;
#line 405
enum __anonenum__66___0 {
    SFE_NO_ERROR___3 = 0,
    SFE_BAD_OPEN_FORMAT___3 = 1,
    SFE_SYSTEM___3 = 2,
    SFE_MALFORMED_FILE___3 = 3,
    SFE_UNSUPPORTED_ENCODING___3 = 4,
    SFE_ZERO_MAJOR_FORMAT___3 = 5,
    SFE_ZERO_MINOR_FORMAT___3 = 6,
    SFE_BAD_FILE___3 = 7,
    SFE_BAD_FILE_READ___3 = 8,
    SFE_OPEN_FAILED___3 = 9,
    SFE_BAD_SNDFILE_PTR___3 = 10,
    SFE_BAD_SF_INFO_PTR___3 = 11,
    SFE_BAD_SF_INCOMPLETE___3 = 12,
    SFE_BAD_FILE_PTR___3 = 13,
    SFE_BAD_INT_PTR___3 = 14,
    SFE_BAD_STAT_SIZE___3 = 15,
    SFE_MALLOC_FAILED___3 = 16,
    SFE_UNIMPLEMENTED___3 = 17,
    SFE_BAD_READ_ALIGN___3 = 18,
    SFE_BAD_WRITE_ALIGN___3 = 19,
    SFE_UNKNOWN_FORMAT___3 = 20,
    SFE_NOT_READMODE___3 = 21,
    SFE_NOT_WRITEMODE___3 = 22,
    SFE_BAD_MODE_RW___3 = 23,
    SFE_BAD_SF_INFO___3 = 24,
    SFE_BAD_OFFSET___3 = 25,
    SFE_NO_EMBED_SUPPORT___3 = 26,
    SFE_NO_EMBEDDED_RDWR___3 = 27,
    SFE_NO_PIPE_WRITE___3 = 28,
    SFE_INTERNAL___3 = 29,
    SFE_BAD_COMMAND_PARAM___3 = 30,
    SFE_BAD_ENDIAN___3 = 31,
    SFE_CHANNEL_COUNT_ZERO___3 = 32,
    SFE_CHANNEL_COUNT___3 = 33,
    SFE_BAD_VIRTUAL_IO___3 = 34,
    SFE_INTERLEAVE_MODE___3 = 35,
    SFE_INTERLEAVE_SEEK___3 = 36,
    SFE_INTERLEAVE_READ___3 = 37,
    SFE_BAD_SEEK___3 = 38,
    SFE_NOT_SEEKABLE___3 = 39,
    SFE_AMBIGUOUS_SEEK___3 = 40,
    SFE_WRONG_SEEK___3 = 41,
    SFE_SEEK_FAILED___3 = 42,
    SFE_BAD_OPEN_MODE___3 = 43,
    SFE_OPEN_PIPE_RDWR___3 = 44,
    SFE_RDWR_POSITION___3 = 45,
    SFE_RDWR_BAD_HEADER___3 = 46,
    SFE_CMD_HAS_DATA___3 = 47,
    SFE_BAD_BROADCAST_INFO_SIZE___3 = 48,
    SFE_STR_NO_SUPPORT___3 = 49,
    SFE_STR_NOT_WRITE___3 = 50,
    SFE_STR_MAX_DATA___3 = 51,
    SFE_STR_MAX_COUNT___3 = 52,
    SFE_STR_BAD_TYPE___3 = 53,
    SFE_STR_NO_ADD_END___3 = 54,
    SFE_STR_BAD_STRING___3 = 55,
    SFE_STR_WEIRD___3 = 56,
    SFE_WAV_NO_RIFF___3 = 57,
    SFE_WAV_NO_WAVE___3 = 58,
    SFE_WAV_NO_FMT___3 = 59,
    SFE_WAV_BAD_FMT___3 = 60,
    SFE_WAV_FMT_SHORT___3 = 61,
    SFE_WAV_BAD_FACT___3 = 62,
    SFE_WAV_BAD_PEAK___3 = 63,
    SFE_WAV_PEAK_B4_FMT___3 = 64,
    SFE_WAV_BAD_FORMAT___3 = 65,
    SFE_WAV_BAD_BLOCKALIGN___3 = 66,
    SFE_WAV_NO_DATA___3 = 67,
    SFE_WAV_BAD_LIST___3 = 68,
    SFE_WAV_ADPCM_NOT4BIT___3 = 69,
    SFE_WAV_ADPCM_CHANNELS___3 = 70,
    SFE_WAV_GSM610_FORMAT___3 = 71,
    SFE_WAV_UNKNOWN_CHUNK___3 = 72,
    SFE_WAV_WVPK_DATA___3 = 73,
    SFE_AIFF_NO_FORM___3 = 74,
    SFE_AIFF_AIFF_NO_FORM___3 = 75,
    SFE_AIFF_COMM_NO_FORM___3 = 76,
    SFE_AIFF_SSND_NO_COMM___3 = 77,
    SFE_AIFF_UNKNOWN_CHUNK___3 = 78,
    SFE_AIFF_COMM_CHUNK_SIZE___3 = 79,
    SFE_AIFF_BAD_COMM_CHUNK___3 = 80,
    SFE_AIFF_PEAK_B4_COMM___3 = 81,
    SFE_AIFF_BAD_PEAK___3 = 82,
    SFE_AIFF_NO_SSND___3 = 83,
    SFE_AIFF_NO_DATA___3 = 84,
    SFE_AIFF_RW_SSND_NOT_LAST___3 = 85,
    SFE_AU_UNKNOWN_FORMAT___3 = 86,
    SFE_AU_NO_DOTSND___3 = 87,
    SFE_AU_EMBED_BAD_LEN___3 = 88,
    SFE_RAW_READ_BAD_SPEC___3 = 89,
    SFE_RAW_BAD_BITWIDTH___3 = 90,
    SFE_RAW_BAD_FORMAT___3 = 91,
    SFE_PAF_NO_MARKER___3 = 92,
    SFE_PAF_VERSION___3 = 93,
    SFE_PAF_UNKNOWN_FORMAT___3 = 94,
    SFE_PAF_SHORT_HEADER___3 = 95,
    SFE_SVX_NO_FORM___3 = 96,
    SFE_SVX_NO_BODY___3 = 97,
    SFE_SVX_NO_DATA___3 = 98,
    SFE_SVX_BAD_COMP___3 = 99,
    SFE_SVX_BAD_NAME_LENGTH___3 = 100,
    SFE_NIST_BAD_HEADER___3 = 101,
    SFE_NIST_CRLF_CONVERISON___3 = 102,
    SFE_NIST_BAD_ENCODING___3 = 103,
    SFE_VOC_NO_CREATIVE___3 = 104,
    SFE_VOC_BAD_FORMAT___3 = 105,
    SFE_VOC_BAD_VERSION___3 = 106,
    SFE_VOC_BAD_MARKER___3 = 107,
    SFE_VOC_BAD_SECTIONS___3 = 108,
    SFE_VOC_MULTI_SAMPLERATE___3 = 109,
    SFE_VOC_MULTI_SECTION___3 = 110,
    SFE_VOC_MULTI_PARAM___3 = 111,
    SFE_VOC_SECTION_COUNT___3 = 112,
    SFE_VOC_NO_PIPE___3 = 113,
    SFE_IRCAM_NO_MARKER___3 = 114,
    SFE_IRCAM_BAD_CHANNELS___3 = 115,
    SFE_IRCAM_UNKNOWN_FORMAT___3 = 116,
    SFE_W64_64_BIT___3 = 117,
    SFE_W64_NO_RIFF___3 = 118,
    SFE_W64_NO_WAVE___3 = 119,
    SFE_W64_NO_DATA___3 = 120,
    SFE_W64_ADPCM_NOT4BIT___3 = 121,
    SFE_W64_ADPCM_CHANNELS___3 = 122,
    SFE_W64_GSM610_FORMAT___3 = 123,
    SFE_MAT4_BAD_NAME___3 = 124,
    SFE_MAT4_NO_SAMPLERATE___3 = 125,
    SFE_MAT5_BAD_ENDIAN___3 = 126,
    SFE_MAT5_NO_BLOCK___3 = 127,
    SFE_MAT5_SAMPLE_RATE___3 = 128,
    SFE_PVF_NO_PVF1___3 = 129,
    SFE_PVF_BAD_HEADER___3 = 130,
    SFE_PVF_BAD_BITWIDTH___3 = 131,
    SFE_DWVW_BAD_BITWIDTH___3 = 132,
    SFE_G72X_NOT_MONO___3 = 133,
    SFE_XI_BAD_HEADER___3 = 134,
    SFE_XI_EXCESS_SAMPLES___3 = 135,
    SFE_XI_NO_PIPE___3 = 136,
    SFE_HTK_NO_PIPE___3 = 137,
    SFE_SDS_NOT_SDS___3 = 138,
    SFE_SDS_BAD_BIT_WIDTH___3 = 139,
    SFE_SD2_FD_DISALLOWED___3 = 140,
    SFE_SD2_BAD_DATA_OFFSET___3 = 141,
    SFE_SD2_BAD_MAP_OFFSET___3 = 142,
    SFE_SD2_BAD_DATA_LENGTH___3 = 143,
    SFE_SD2_BAD_MAP_LENGTH___3 = 144,
    SFE_SD2_BAD_RSRC___3 = 145,
    SFE_SD2_BAD_SAMPLE_SIZE___3 = 146,
    SFE_FLAC_BAD_HEADER___3 = 147,
    SFE_FLAC_NEW_DECODER___3 = 148,
    SFE_FLAC_INIT_DECODER___3 = 149,
    SFE_FLAC_LOST_SYNC___3 = 150,
    SFE_FLAC_BAD_SAMPLE_RATE___3 = 151,
    SFE_FLAC_UNKOWN_ERROR___3 = 152,
    SFE_WVE_NOT_WVE___3 = 153,
    SFE_WVE_NO_PIPE___3 = 154,
    SFE_VORBIS_ENCODER_BUG___3 = 155,
    SFE_RF64_NOT_RF64___3 = 156,
    SFE_MAX_ERROR___3 = 157
} ;
#line 823
enum __anonenum__70___0 {
    SFC_TEST_AIFF_ADD_INST_CHUNK___3 = 8192,
    SFC_TEST_WAV_ADD_INFO_CHUNK___3 = 8208
} ;
#line 29 "/root/libsndfile/src/wav_w64.h"
enum __anonstruct_71 {
    WAVE_FORMAT_UNKNOWN = 0,
    WAVE_FORMAT_PCM = 1,
    WAVE_FORMAT_MS_ADPCM = 2,
    WAVE_FORMAT_IEEE_FLOAT = 3,
    WAVE_FORMAT_VSELP = 4,
    WAVE_FORMAT_IBM_CVSD = 5,
    WAVE_FORMAT_ALAW = 6,
    WAVE_FORMAT_MULAW = 7,
    WAVE_FORMAT_OKI_ADPCM = 16,
    WAVE_FORMAT_IMA_ADPCM = 17,
    WAVE_FORMAT_MEDIASPACE_ADPCM = 18,
    WAVE_FORMAT_SIERRA_ADPCM = 19,
    WAVE_FORMAT_G723_ADPCM = 20,
    WAVE_FORMAT_DIGISTD = 21,
    WAVE_FORMAT_DIGIFIX = 22,
    WAVE_FORMAT_DIALOGIC_OKI_ADPCM = 23,
    WAVE_FORMAT_MEDIAVISION_ADPCM = 24,
    WAVE_FORMAT_CU_CODEC = 25,
    WAVE_FORMAT_YAMAHA_ADPCM = 32,
    WAVE_FORMAT_SONARC = 33,
    WAVE_FORMAT_DSPGROUP_TRUESPEECH = 34,
    WAVE_FORMAT_ECHOSC1 = 35,
    WAVE_FORMAT_AUDIOFILE_AF36 = 36,
    WAVE_FORMAT_APTX = 37,
    WAVE_FORMAT_AUDIOFILE_AF10 = 38,
    WAVE_FORMAT_PROSODY_1612 = 39,
    WAVE_FORMAT_LRC = 40,
    WAVE_FORMAT_DOLBY_AC2 = 48,
    WAVE_FORMAT_GSM610 = 49,
    WAVE_FORMAT_MSNAUDIO = 50,
    WAVE_FORMAT_ANTEX_ADPCME = 51,
    WAVE_FORMAT_CONTROL_RES_VQLPC = 52,
    WAVE_FORMAT_DIGIREAL = 53,
    WAVE_FORMAT_DIGIADPCM = 54,
    WAVE_FORMAT_CONTROL_RES_CR10 = 55,
    WAVE_FORMAT_NMS_VBXADPCM = 56,
    WAVE_FORMAT_ROLAND_RDAC = 57,
    WAVE_FORMAT_ECHOSC3 = 58,
    WAVE_FORMAT_ROCKWELL_ADPCM = 59,
    WAVE_FORMAT_ROCKWELL_DIGITALK = 60,
    WAVE_FORMAT_XEBEC = 61,
    WAVE_FORMAT_G721_ADPCM = 64,
    WAVE_FORMAT_G728_CELP = 65,
    WAVE_FORMAT_MSG723 = 66,
    WAVE_FORMAT_MPEG = 80,
    WAVE_FORMAT_RT24 = 82,
    WAVE_FORMAT_PAC = 83,
    WAVE_FORMAT_MPEGLAYER3 = 85,
    WAVE_FORMAT_LUCENT_G723 = 89,
    WAVE_FORMAT_CIRRUS = 96,
    WAVE_FORMAT_ESPCM = 97,
    WAVE_FORMAT_VOXWARE = 98,
    WAVE_FORMAT_CANOPUS_ATRAC = 99,
    WAVE_FORMAT_G726_ADPCM = 100,
    WAVE_FORMAT_G722_ADPCM = 101,
    WAVE_FORMAT_DSAT = 102,
    WAVE_FORMAT_DSAT_DISPLAY = 103,
    WAVE_FORMAT_VOXWARE_BYTE_ALIGNED = 105,
    WAVE_FORMAT_VOXWARE_AC8 = 112,
    WAVE_FORMAT_VOXWARE_AC10 = 113,
    WAVE_FORMAT_VOXWARE_AC16 = 114,
    WAVE_FORMAT_VOXWARE_AC20 = 115,
    WAVE_FORMAT_VOXWARE_RT24 = 116,
    WAVE_FORMAT_VOXWARE_RT29 = 117,
    WAVE_FORMAT_VOXWARE_RT29HW = 118,
    WAVE_FORMAT_VOXWARE_VR12 = 119,
    WAVE_FORMAT_VOXWARE_VR18 = 120,
    WAVE_FORMAT_VOXWARE_TQ40 = 121,
    WAVE_FORMAT_SOFTSOUND = 128,
    WAVE_FORMAT_VOXARE_TQ60 = 129,
    WAVE_FORMAT_MSRT24 = 130,
    WAVE_FORMAT_G729A = 131,
    WAVE_FORMAT_MVI_MV12 = 132,
    WAVE_FORMAT_DF_G726 = 133,
    WAVE_FORMAT_DF_GSM610 = 134,
    WAVE_FORMAT_ONLIVE = 137,
    WAVE_FORMAT_SBC24 = 145,
    WAVE_FORMAT_DOLBY_AC3_SPDIF = 146,
    WAVE_FORMAT_ZYXEL_ADPCM = 151,
    WAVE_FORMAT_PHILIPS_LPCBB = 152,
    WAVE_FORMAT_PACKED = 153,
    WAVE_FORMAT_RHETOREX_ADPCM = 256,
    IBM_FORMAT_MULAW = 257,
    IBM_FORMAT_ALAW = 258,
    IBM_FORMAT_ADPCM = 259,
    WAVE_FORMAT_VIVO_G723 = 273,
    WAVE_FORMAT_VIVO_SIREN = 274,
    WAVE_FORMAT_DIGITAL_G723 = 291,
    WAVE_FORMAT_CREATIVE_ADPCM = 512,
    WAVE_FORMAT_CREATIVE_FASTSPEECH8 = 514,
    WAVE_FORMAT_CREATIVE_FASTSPEECH10 = 515,
    WAVE_FORMAT_QUARTERDECK = 544,
    WAVE_FORMAT_FM_TOWNS_SND = 768,
    WAVE_FORMAT_BZV_DIGITAL = 1024,
    WAVE_FORMAT_VME_VMPCM = 1664,
    WAVE_FORMAT_OLIGSM = 4096,
    WAVE_FORMAT_OLIADPCM = 4097,
    WAVE_FORMAT_OLICELP = 4098,
    WAVE_FORMAT_OLISBC = 4099,
    WAVE_FORMAT_OLIOPR = 4100,
    WAVE_FORMAT_LH_CODEC = 4352,
    WAVE_FORMAT_NORRIS = 5120,
    WAVE_FORMAT_SOUNDSPACE_MUSICOMPRESS = 5376,
    WAVE_FORMAT_DVM = 8192,
    WAVE_FORMAT_INTERWAV_VSC112 = 29008,
    WAVE_FORMAT_IPP_ITU_G_723_1 = 29232,
    WAVE_FORMAT_EXTENSIBLE = 65534
} ;
#line 153 "/root/libsndfile/src/wav_w64.h"
struct __anonstruct_185 {
   unsigned short format ;
   unsigned short channels ;
   unsigned int samplerate ;
   unsigned int bytespersec ;
   unsigned short blockalign ;
   unsigned short bitwidth ;
};
#line 160 "/root/libsndfile/src/wav_w64.h"
typedef struct __anonstruct_185 MIN_WAV_FMT;
#line 162 "/root/libsndfile/src/wav_w64.h"
struct __anonstruct_186 {
   unsigned short format ;
   unsigned short channels ;
   unsigned int samplerate ;
   unsigned int bytespersec ;
   unsigned short blockalign ;
   unsigned short bitwidth ;
   unsigned short extrabytes ;
   unsigned short dummy ;
};
#line 171 "/root/libsndfile/src/wav_w64.h"
typedef struct __anonstruct_186 WAV_FMT_SIZE20;
#line 183 "/root/libsndfile/src/wav_w64.h"
struct __anonstruct_188 {
   short coeff1 ;
   short coeff2 ;
};
#line 173 "/root/libsndfile/src/wav_w64.h"
struct __anonstruct_187 {
   unsigned short format ;
   unsigned short channels ;
   unsigned int samplerate ;
   unsigned int bytespersec ;
   unsigned short blockalign ;
   unsigned short bitwidth ;
   unsigned short extrabytes ;
   unsigned short samplesperblock ;
   unsigned short numcoeffs ;
   struct __anonstruct_188 coeffs[7] ;
};
#line 187 "/root/libsndfile/src/wav_w64.h"
typedef struct __anonstruct_187 MS_ADPCM_WAV_FMT;
#line 189 "/root/libsndfile/src/wav_w64.h"
struct __anonstruct_189 {
   unsigned short format ;
   unsigned short channels ;
   unsigned int samplerate ;
   unsigned int bytespersec ;
   unsigned short blockalign ;
   unsigned short bitwidth ;
   unsigned short extrabytes ;
   unsigned short samplesperblock ;
};
#line 198 "/root/libsndfile/src/wav_w64.h"
typedef struct __anonstruct_189 IMA_ADPCM_WAV_FMT;
#line 200 "/root/libsndfile/src/wav_w64.h"
struct __anonstruct_190 {
   unsigned short format ;
   unsigned short channels ;
   unsigned int samplerate ;
   unsigned int bytespersec ;
   unsigned short blockalign ;
   unsigned short bitwidth ;
   unsigned short extrabytes ;
   unsigned short auxblocksize ;
};
#line 209 "/root/libsndfile/src/wav_w64.h"
typedef struct __anonstruct_190 G72x_ADPCM_WAV_FMT;
#line 212 "/root/libsndfile/src/wav_w64.h"
struct __anonstruct_191 {
   unsigned short format ;
   unsigned short channels ;
   unsigned int samplerate ;
   unsigned int bytespersec ;
   unsigned short blockalign ;
   unsigned short bitwidth ;
   unsigned short extrabytes ;
   unsigned short samplesperblock ;
};
#line 221 "/root/libsndfile/src/wav_w64.h"
typedef struct __anonstruct_191 GSM610_WAV_FMT;
#line 223 "/root/libsndfile/src/wav_w64.h"
struct __anonstruct_192 {
   unsigned int esf_field1 ;
   unsigned short esf_field2 ;
   unsigned short esf_field3 ;
   char esf_field4[8] ;
};
#line 228 "/root/libsndfile/src/wav_w64.h"
typedef struct __anonstruct_192 EXT_SUBFORMAT;
#line 230 "/root/libsndfile/src/wav_w64.h"
struct __anonstruct_193 {
   unsigned short format ;
   unsigned short channels ;
   unsigned int samplerate ;
   unsigned int bytespersec ;
   unsigned short blockalign ;
   unsigned short bitwidth ;
   unsigned short extrabytes ;
   unsigned short validbits ;
   unsigned int channelmask ;
   EXT_SUBFORMAT esf ;
};
#line 241 "/root/libsndfile/src/wav_w64.h"
typedef struct __anonstruct_193 EXTENSIBLE_WAV_FMT;
#line 243 "/root/libsndfile/src/wav_w64.h"
union __anonunion_194 {
   unsigned short format ;
   MIN_WAV_FMT min ;
   IMA_ADPCM_WAV_FMT ima ;
   MS_ADPCM_WAV_FMT msadpcm ;
   G72x_ADPCM_WAV_FMT g72x ;
   EXTENSIBLE_WAV_FMT ext ;
   GSM610_WAV_FMT gsm610 ;
   WAV_FMT_SIZE20 size20 ;
   char padding[512] ;
};
#line 253 "/root/libsndfile/src/wav_w64.h"
typedef union __anonunion_194 WAV_FMT;
#line 255 "/root/libsndfile/src/wav_w64.h"
struct __anonstruct_195 {
   int frames ;
};
#line 257 "/root/libsndfile/src/wav_w64.h"
typedef struct __anonstruct_195 FACT_CHUNK;
#line 259 "/root/libsndfile/src/wav_w64.h"
struct __anonstruct_196 {
   int wavex_ambisonic ;
   int fmt_is_broken ;
   WAV_FMT wav_fmt ;
};
#line 266 "/root/libsndfile/src/wav_w64.h"
typedef struct __anonstruct_196 WAV_PRIVATE;
#line 41 "/root/libsndfile/src/ms_adpcm.c"
struct __anonstruct_197 {
   int channels ;
   int blocksize ;
   int samplesperblock ;
   int blocks ;
   int dataremaining ;
   int blockcount ;
   sf_count_t samplecount ;
   short *samples ;
   unsigned char *block ;
   short dummydata[] ;
};
#line 52 "/root/libsndfile/src/ms_adpcm.c"
typedef struct __anonstruct_197 MSADPCM_PRIVATE;
#line 46 "/root/libsndfile/src/sndfile.h"
enum __anonenum__218 {
    SF_FORMAT_WAV___4 = 65536,
    SF_FORMAT_AIFF___4 = 131072,
    SF_FORMAT_AU___4 = 196608,
    SF_FORMAT_RAW___4 = 262144,
    SF_FORMAT_PAF___4 = 327680,
    SF_FORMAT_SVX___4 = 393216,
    SF_FORMAT_NIST___4 = 458752,
    SF_FORMAT_VOC___4 = 524288,
    SF_FORMAT_IRCAM___4 = 655360,
    SF_FORMAT_W64___4 = 720896,
    SF_FORMAT_MAT4___4 = 786432,
    SF_FORMAT_MAT5___4 = 851968,
    SF_FORMAT_PVF___4 = 917504,
    SF_FORMAT_XI___4 = 983040,
    SF_FORMAT_HTK___4 = 1048576,
    SF_FORMAT_SDS___4 = 1114112,
    SF_FORMAT_AVR___4 = 1179648,
    SF_FORMAT_WAVEX___4 = 1245184,
    SF_FORMAT_SD2___4 = 1441792,
    SF_FORMAT_FLAC___4 = 1507328,
    SF_FORMAT_CAF___4 = 1572864,
    SF_FORMAT_WVE___4 = 1638400,
    SF_FORMAT_OGG___4 = 2097152,
    SF_FORMAT_MPC2K___4 = 2162688,
    SF_FORMAT_RF64___4 = 2228224,
    SF_FORMAT_PCM_S8___4 = 1,
    SF_FORMAT_PCM_16___4 = 2,
    SF_FORMAT_PCM_24___4 = 3,
    SF_FORMAT_PCM_32___4 = 4,
    SF_FORMAT_PCM_U8___4 = 5,
    SF_FORMAT_FLOAT___4 = 6,
    SF_FORMAT_DOUBLE___4 = 7,
    SF_FORMAT_ULAW___4 = 16,
    SF_FORMAT_ALAW___4 = 17,
    SF_FORMAT_IMA_ADPCM___4 = 18,
    SF_FORMAT_MS_ADPCM___4 = 19,
    SF_FORMAT_GSM610___4 = 32,
    SF_FORMAT_VOX_ADPCM___4 = 33,
    SF_FORMAT_G721_32___4 = 48,
    SF_FORMAT_G723_24___4 = 49,
    SF_FORMAT_G723_40___4 = 50,
    SF_FORMAT_DWVW_12___4 = 64,
    SF_FORMAT_DWVW_16___4 = 65,
    SF_FORMAT_DWVW_24___4 = 66,
    SF_FORMAT_DWVW_N___4 = 67,
    SF_FORMAT_DPCM_8___4 = 80,
    SF_FORMAT_DPCM_16___4 = 81,
    SF_FORMAT_VORBIS___4 = 96,
    SF_ENDIAN_FILE___4 = 0,
    SF_ENDIAN_LITTLE___4 = 268435456,
    SF_ENDIAN_BIG___4 = 536870912,
    SF_ENDIAN_CPU___4 = 805306368,
    SF_FORMAT_SUBMASK___4 = 65535,
    SF_FORMAT_TYPEMASK___4 = 268369920,
    SF_FORMAT_ENDMASK___4 = 805306368
} ;
#line 126
enum __anonenum__219 {
    SFC_GET_LIB_VERSION___4 = 4096,
    SFC_GET_LOG_INFO___4 = 4097,
    SFC_GET_CURRENT_SF_INFO___4 = 4098,
    SFC_GET_NORM_DOUBLE___4 = 4112,
    SFC_GET_NORM_FLOAT___4 = 4113,
    SFC_SET_NORM_DOUBLE___4 = 4114,
    SFC_SET_NORM_FLOAT___4 = 4115,
    SFC_SET_SCALE_FLOAT_INT_READ___4 = 4116,
    SFC_SET_SCALE_INT_FLOAT_WRITE___4 = 4117,
    SFC_GET_SIMPLE_FORMAT_COUNT___4 = 4128,
    SFC_GET_SIMPLE_FORMAT___4 = 4129,
    SFC_GET_FORMAT_INFO___4 = 4136,
    SFC_GET_FORMAT_MAJOR_COUNT___4 = 4144,
    SFC_GET_FORMAT_MAJOR___4 = 4145,
    SFC_GET_FORMAT_SUBTYPE_COUNT___4 = 4146,
    SFC_GET_FORMAT_SUBTYPE___4 = 4147,
    SFC_CALC_SIGNAL_MAX___4 = 4160,
    SFC_CALC_NORM_SIGNAL_MAX___4 = 4161,
    SFC_CALC_MAX_ALL_CHANNELS___4 = 4162,
    SFC_CALC_NORM_MAX_ALL_CHANNELS___4 = 4163,
    SFC_GET_SIGNAL_MAX___4 = 4164,
    SFC_GET_MAX_ALL_CHANNELS___4 = 4165,
    SFC_SET_ADD_PEAK_CHUNK___4 = 4176,
    SFC_SET_ADD_HEADER_PAD_CHUNK___4 = 4177,
    SFC_UPDATE_HEADER_NOW___4 = 4192,
    SFC_SET_UPDATE_HEADER_AUTO___4 = 4193,
    SFC_FILE_TRUNCATE___4 = 4224,
    SFC_SET_RAW_START_OFFSET___4 = 4240,
    SFC_SET_DITHER_ON_WRITE___4 = 4256,
    SFC_SET_DITHER_ON_READ___4 = 4257,
    SFC_GET_DITHER_INFO_COUNT___4 = 4258,
    SFC_GET_DITHER_INFO___4 = 4259,
    SFC_GET_EMBED_FILE_INFO___4 = 4272,
    SFC_SET_CLIPPING___4 = 4288,
    SFC_GET_CLIPPING___4 = 4289,
    SFC_GET_INSTRUMENT___4 = 4304,
    SFC_SET_INSTRUMENT___4 = 4305,
    SFC_GET_LOOP_INFO___4 = 4320,
    SFC_GET_BROADCAST_INFO___4 = 4336,
    SFC_SET_BROADCAST_INFO___4 = 4337,
    SFC_GET_CHANNEL_MAP_INFO___4 = 4352,
    SFC_SET_CHANNEL_MAP_INFO___4 = 4353,
    SFC_RAW_DATA_NEEDS_ENDSWAP___4 = 4368,
    SFC_WAVEX_SET_AMBISONIC___4 = 4608,
    SFC_WAVEX_GET_AMBISONIC___4 = 4609,
    SFC_SET_VBR_ENCODING_QUALITY___4 = 4864,
    SFC_TEST_IEEE_FLOAT_REPLACE___4 = 24577,
    SFC_SET_ADD_DITHER_ON_WRITE___4 = 4208,
    SFC_SET_ADD_DITHER_ON_READ___4 = 4209
} ;
#line 216
enum __anonenum__220 {
    SF_STR_TITLE___4 = 1,
    SF_STR_COPYRIGHT___4 = 2,
    SF_STR_SOFTWARE___4 = 3,
    SF_STR_ARTIST___4 = 4,
    SF_STR_COMMENT___4 = 5,
    SF_STR_DATE___4 = 6,
    SF_STR_ALBUM___4 = 7,
    SF_STR_LICENSE___4 = 8
} ;
#line 235
enum __anonenum__221 {
    SF_FALSE___4 = 0,
    SF_TRUE___4 = 1,
    SFM_READ___4 = 16,
    SFM_WRITE___4 = 32,
    SFM_RDWR___4 = 48,
    SF_AMBISONIC_NONE___4 = 64,
    SF_AMBISONIC_B_FORMAT___4 = 65
} ;
#line 255
enum __anonenum__222 {
    SF_ERR_NO_ERROR___4 = 0,
    SF_ERR_UNRECOGNISED_FORMAT___4 = 1,
    SF_ERR_SYSTEM___4 = 2,
    SF_ERR_MALFORMED_FILE___4 = 3,
    SF_ERR_UNSUPPORTED_ENCODING___4 = 4
} ;
#line 267
enum __anonenum__223 {
    SF_CHANNEL_MAP_INVALID___4 = 0,
    SF_CHANNEL_MAP_MONO___4 = 1,
    SF_CHANNEL_MAP_LEFT___4 = 2,
    SF_CHANNEL_MAP_RIGHT___4 = 3,
    SF_CHANNEL_MAP_CENTER___4 = 4,
    SF_CHANNEL_MAP_FRONT_LEFT___4 = 5,
    SF_CHANNEL_MAP_FRONT_RIGHT___4 = 6,
    SF_CHANNEL_MAP_FRONT_CENTER___4 = 7,
    SF_CHANNEL_MAP_REAR_CENTER___4 = 8,
    SF_CHANNEL_MAP_REAR_LEFT___4 = 9,
    SF_CHANNEL_MAP_REAR_RIGHT___4 = 10,
    SF_CHANNEL_MAP_LFE___4 = 11,
    SF_CHANNEL_MAP_FRONT_LEFT_OF_CENTER___4 = 12,
    SF_CHANNEL_MAP_FRONT_RIGHT_OF_CENTER___4 = 13,
    SF_CHANNEL_MAP_SIDE_LEFT___4 = 14,
    SF_CHANNEL_MAP_SIDE_RIGHT___4 = 15,
    SF_CHANNEL_MAP_TOP_CENTER___4 = 16,
    SF_CHANNEL_MAP_TOP_FRONT_LEFT___4 = 17,
    SF_CHANNEL_MAP_TOP_FRONT_RIGHT___4 = 18,
    SF_CHANNEL_MAP_TOP_FRONT_CENTER___4 = 19,
    SF_CHANNEL_MAP_TOP_REAR_LEFT___4 = 20,
    SF_CHANNEL_MAP_TOP_REAR_RIGHT___4 = 21,
    SF_CHANNEL_MAP_TOP_REAR_CENTER___4 = 22
} ;
#line 352
enum __anonenum__225 {
    SFD_DEFAULT_LEVEL___4 = 0,
    SFD_CUSTOM_LEVEL___4 = 1073741824,
    SFD_NO_DITHER___4 = 500,
    SFD_WHITE___4 = 501,
    SFD_TRIANGULAR_PDF___4 = 502
} ;
#line 380
enum __anonenum__228 {
    SF_LOOP_NONE___4 = 800,
    SF_LOOP_FORWARD___4 = 801,
    SF_LOOP_BACKWARD___4 = 802,
    SF_LOOP_ALTERNATING___4 = 803
} ;
#line 121 "/root/libsndfile/src/common.h"
enum __anonenum__233 {
    SF_PEAK_START___4 = 42,
    SF_PEAK_END___4 = 43,
    SF_SCALE_MAX___4 = 52,
    SF_SCALE_MIN___4 = 53,
    SF_STR_ALLOW_START___4 = 256,
    SF_STR_ALLOW_END___4 = 512,
    SF_STR_LOCATE_START___4 = 1024,
    SF_STR_LOCATE_END___4 = 2048,
    SFD_TYPEMASK___4 = 268435455
} ;
#line 149
enum __anonenum__234 {
    SF_FORMAT_TXW___4 = 67305472,
    SF_FORMAT_DWD___4 = 67371008,
    SF_FORMAT_REX___4 = 67764224,
    SF_FORMAT_REX2___4 = 67960832,
    SF_FORMAT_KRZ___4 = 68026368,
    SF_FORMAT_WMA___4 = 68157440,
    SF_FORMAT_SHN___4 = 68222976,
    SF_FORMAT_SVX_FIB___4 = 4128,
    SF_FORMAT_SVX_EXP___4 = 4129,
    SF_FORMAT_PCM_N___4 = 4144
} ;
#line 405
enum __anonenum__240 {
    SFE_NO_ERROR___4 = 0,
    SFE_BAD_OPEN_FORMAT___4 = 1,
    SFE_SYSTEM___4 = 2,
    SFE_MALFORMED_FILE___4 = 3,
    SFE_UNSUPPORTED_ENCODING___4 = 4,
    SFE_ZERO_MAJOR_FORMAT___4 = 5,
    SFE_ZERO_MINOR_FORMAT___4 = 6,
    SFE_BAD_FILE___4 = 7,
    SFE_BAD_FILE_READ___4 = 8,
    SFE_OPEN_FAILED___4 = 9,
    SFE_BAD_SNDFILE_PTR___4 = 10,
    SFE_BAD_SF_INFO_PTR___4 = 11,
    SFE_BAD_SF_INCOMPLETE___4 = 12,
    SFE_BAD_FILE_PTR___4 = 13,
    SFE_BAD_INT_PTR___4 = 14,
    SFE_BAD_STAT_SIZE___4 = 15,
    SFE_MALLOC_FAILED___4 = 16,
    SFE_UNIMPLEMENTED___4 = 17,
    SFE_BAD_READ_ALIGN___4 = 18,
    SFE_BAD_WRITE_ALIGN___4 = 19,
    SFE_UNKNOWN_FORMAT___4 = 20,
    SFE_NOT_READMODE___4 = 21,
    SFE_NOT_WRITEMODE___4 = 22,
    SFE_BAD_MODE_RW___4 = 23,
    SFE_BAD_SF_INFO___4 = 24,
    SFE_BAD_OFFSET___4 = 25,
    SFE_NO_EMBED_SUPPORT___4 = 26,
    SFE_NO_EMBEDDED_RDWR___4 = 27,
    SFE_NO_PIPE_WRITE___4 = 28,
    SFE_INTERNAL___4 = 29,
    SFE_BAD_COMMAND_PARAM___4 = 30,
    SFE_BAD_ENDIAN___4 = 31,
    SFE_CHANNEL_COUNT_ZERO___4 = 32,
    SFE_CHANNEL_COUNT___4 = 33,
    SFE_BAD_VIRTUAL_IO___4 = 34,
    SFE_INTERLEAVE_MODE___4 = 35,
    SFE_INTERLEAVE_SEEK___4 = 36,
    SFE_INTERLEAVE_READ___4 = 37,
    SFE_BAD_SEEK___4 = 38,
    SFE_NOT_SEEKABLE___4 = 39,
    SFE_AMBIGUOUS_SEEK___4 = 40,
    SFE_WRONG_SEEK___4 = 41,
    SFE_SEEK_FAILED___4 = 42,
    SFE_BAD_OPEN_MODE___4 = 43,
    SFE_OPEN_PIPE_RDWR___4 = 44,
    SFE_RDWR_POSITION___4 = 45,
    SFE_RDWR_BAD_HEADER___4 = 46,
    SFE_CMD_HAS_DATA___4 = 47,
    SFE_BAD_BROADCAST_INFO_SIZE___4 = 48,
    SFE_STR_NO_SUPPORT___4 = 49,
    SFE_STR_NOT_WRITE___4 = 50,
    SFE_STR_MAX_DATA___4 = 51,
    SFE_STR_MAX_COUNT___4 = 52,
    SFE_STR_BAD_TYPE___4 = 53,
    SFE_STR_NO_ADD_END___4 = 54,
    SFE_STR_BAD_STRING___4 = 55,
    SFE_STR_WEIRD___4 = 56,
    SFE_WAV_NO_RIFF___4 = 57,
    SFE_WAV_NO_WAVE___4 = 58,
    SFE_WAV_NO_FMT___4 = 59,
    SFE_WAV_BAD_FMT___4 = 60,
    SFE_WAV_FMT_SHORT___4 = 61,
    SFE_WAV_BAD_FACT___4 = 62,
    SFE_WAV_BAD_PEAK___4 = 63,
    SFE_WAV_PEAK_B4_FMT___4 = 64,
    SFE_WAV_BAD_FORMAT___4 = 65,
    SFE_WAV_BAD_BLOCKALIGN___4 = 66,
    SFE_WAV_NO_DATA___4 = 67,
    SFE_WAV_BAD_LIST___4 = 68,
    SFE_WAV_ADPCM_NOT4BIT___4 = 69,
    SFE_WAV_ADPCM_CHANNELS___4 = 70,
    SFE_WAV_GSM610_FORMAT___4 = 71,
    SFE_WAV_UNKNOWN_CHUNK___4 = 72,
    SFE_WAV_WVPK_DATA___4 = 73,
    SFE_AIFF_NO_FORM___4 = 74,
    SFE_AIFF_AIFF_NO_FORM___4 = 75,
    SFE_AIFF_COMM_NO_FORM___4 = 76,
    SFE_AIFF_SSND_NO_COMM___4 = 77,
    SFE_AIFF_UNKNOWN_CHUNK___4 = 78,
    SFE_AIFF_COMM_CHUNK_SIZE___4 = 79,
    SFE_AIFF_BAD_COMM_CHUNK___4 = 80,
    SFE_AIFF_PEAK_B4_COMM___4 = 81,
    SFE_AIFF_BAD_PEAK___4 = 82,
    SFE_AIFF_NO_SSND___4 = 83,
    SFE_AIFF_NO_DATA___4 = 84,
    SFE_AIFF_RW_SSND_NOT_LAST___4 = 85,
    SFE_AU_UNKNOWN_FORMAT___4 = 86,
    SFE_AU_NO_DOTSND___4 = 87,
    SFE_AU_EMBED_BAD_LEN___4 = 88,
    SFE_RAW_READ_BAD_SPEC___4 = 89,
    SFE_RAW_BAD_BITWIDTH___4 = 90,
    SFE_RAW_BAD_FORMAT___4 = 91,
    SFE_PAF_NO_MARKER___4 = 92,
    SFE_PAF_VERSION___4 = 93,
    SFE_PAF_UNKNOWN_FORMAT___4 = 94,
    SFE_PAF_SHORT_HEADER___4 = 95,
    SFE_SVX_NO_FORM___4 = 96,
    SFE_SVX_NO_BODY___4 = 97,
    SFE_SVX_NO_DATA___4 = 98,
    SFE_SVX_BAD_COMP___4 = 99,
    SFE_SVX_BAD_NAME_LENGTH___4 = 100,
    SFE_NIST_BAD_HEADER___4 = 101,
    SFE_NIST_CRLF_CONVERISON___4 = 102,
    SFE_NIST_BAD_ENCODING___4 = 103,
    SFE_VOC_NO_CREATIVE___4 = 104,
    SFE_VOC_BAD_FORMAT___4 = 105,
    SFE_VOC_BAD_VERSION___4 = 106,
    SFE_VOC_BAD_MARKER___4 = 107,
    SFE_VOC_BAD_SECTIONS___4 = 108,
    SFE_VOC_MULTI_SAMPLERATE___4 = 109,
    SFE_VOC_MULTI_SECTION___4 = 110,
    SFE_VOC_MULTI_PARAM___4 = 111,
    SFE_VOC_SECTION_COUNT___4 = 112,
    SFE_VOC_NO_PIPE___4 = 113,
    SFE_IRCAM_NO_MARKER___4 = 114,
    SFE_IRCAM_BAD_CHANNELS___4 = 115,
    SFE_IRCAM_UNKNOWN_FORMAT___4 = 116,
    SFE_W64_64_BIT___4 = 117,
    SFE_W64_NO_RIFF___4 = 118,
    SFE_W64_NO_WAVE___4 = 119,
    SFE_W64_NO_DATA___4 = 120,
    SFE_W64_ADPCM_NOT4BIT___4 = 121,
    SFE_W64_ADPCM_CHANNELS___4 = 122,
    SFE_W64_GSM610_FORMAT___4 = 123,
    SFE_MAT4_BAD_NAME___4 = 124,
    SFE_MAT4_NO_SAMPLERATE___4 = 125,
    SFE_MAT5_BAD_ENDIAN___4 = 126,
    SFE_MAT5_NO_BLOCK___4 = 127,
    SFE_MAT5_SAMPLE_RATE___4 = 128,
    SFE_PVF_NO_PVF1___4 = 129,
    SFE_PVF_BAD_HEADER___4 = 130,
    SFE_PVF_BAD_BITWIDTH___4 = 131,
    SFE_DWVW_BAD_BITWIDTH___4 = 132,
    SFE_G72X_NOT_MONO___4 = 133,
    SFE_XI_BAD_HEADER___4 = 134,
    SFE_XI_EXCESS_SAMPLES___4 = 135,
    SFE_XI_NO_PIPE___4 = 136,
    SFE_HTK_NO_PIPE___4 = 137,
    SFE_SDS_NOT_SDS___4 = 138,
    SFE_SDS_BAD_BIT_WIDTH___4 = 139,
    SFE_SD2_FD_DISALLOWED___4 = 140,
    SFE_SD2_BAD_DATA_OFFSET___4 = 141,
    SFE_SD2_BAD_MAP_OFFSET___4 = 142,
    SFE_SD2_BAD_DATA_LENGTH___4 = 143,
    SFE_SD2_BAD_MAP_LENGTH___4 = 144,
    SFE_SD2_BAD_RSRC___4 = 145,
    SFE_SD2_BAD_SAMPLE_SIZE___4 = 146,
    SFE_FLAC_BAD_HEADER___4 = 147,
    SFE_FLAC_NEW_DECODER___4 = 148,
    SFE_FLAC_INIT_DECODER___4 = 149,
    SFE_FLAC_LOST_SYNC___4 = 150,
    SFE_FLAC_BAD_SAMPLE_RATE___4 = 151,
    SFE_FLAC_UNKOWN_ERROR___4 = 152,
    SFE_WVE_NOT_WVE___4 = 153,
    SFE_WVE_NO_PIPE___4 = 154,
    SFE_VORBIS_ENCODER_BUG___4 = 155,
    SFE_RF64_NOT_RF64___4 = 156,
    SFE_MAX_ERROR___4 = 157
} ;
#line 823
enum __anonenum__244 {
    SFC_TEST_AIFF_ADD_INST_CHUNK___4 = 8192,
    SFC_TEST_WAV_ADD_INFO_CHUNK___4 = 8208
} ;
#line 28 "/root/libsndfile/src/interleave.c"
struct __anonstruct_245 {
   double buffer[2048] ;
   sf_count_t channel_len ;
   sf_count_t (*read_short)(SF_PRIVATE * , short * , sf_count_t  ) ;
   sf_count_t (*read_int)(SF_PRIVATE * , int * , sf_count_t  ) ;
   sf_count_t (*read_float)(SF_PRIVATE * , float * , sf_count_t  ) ;
   sf_count_t (*read_double)(SF_PRIVATE * , double * , sf_count_t  ) ;
};
#line 38 "/root/libsndfile/src/interleave.c"
typedef struct __anonstruct_245 INTERLEAVE_DATA;
#line 46 "/root/libsndfile/src/sndfile.h"
enum __anonenum__267 {
    SF_FORMAT_WAV___5 = 65536,
    SF_FORMAT_AIFF___5 = 131072,
    SF_FORMAT_AU___5 = 196608,
    SF_FORMAT_RAW___5 = 262144,
    SF_FORMAT_PAF___5 = 327680,
    SF_FORMAT_SVX___5 = 393216,
    SF_FORMAT_NIST___5 = 458752,
    SF_FORMAT_VOC___5 = 524288,
    SF_FORMAT_IRCAM___5 = 655360,
    SF_FORMAT_W64___5 = 720896,
    SF_FORMAT_MAT4___5 = 786432,
    SF_FORMAT_MAT5___5 = 851968,
    SF_FORMAT_PVF___5 = 917504,
    SF_FORMAT_XI___5 = 983040,
    SF_FORMAT_HTK___5 = 1048576,
    SF_FORMAT_SDS___5 = 1114112,
    SF_FORMAT_AVR___5 = 1179648,
    SF_FORMAT_WAVEX___5 = 1245184,
    SF_FORMAT_SD2___5 = 1441792,
    SF_FORMAT_FLAC___5 = 1507328,
    SF_FORMAT_CAF___5 = 1572864,
    SF_FORMAT_WVE___5 = 1638400,
    SF_FORMAT_OGG___5 = 2097152,
    SF_FORMAT_MPC2K___5 = 2162688,
    SF_FORMAT_RF64___5 = 2228224,
    SF_FORMAT_PCM_S8___5 = 1,
    SF_FORMAT_PCM_16___5 = 2,
    SF_FORMAT_PCM_24___5 = 3,
    SF_FORMAT_PCM_32___5 = 4,
    SF_FORMAT_PCM_U8___5 = 5,
    SF_FORMAT_FLOAT___5 = 6,
    SF_FORMAT_DOUBLE___5 = 7,
    SF_FORMAT_ULAW___5 = 16,
    SF_FORMAT_ALAW___5 = 17,
    SF_FORMAT_IMA_ADPCM___5 = 18,
    SF_FORMAT_MS_ADPCM___5 = 19,
    SF_FORMAT_GSM610___5 = 32,
    SF_FORMAT_VOX_ADPCM___5 = 33,
    SF_FORMAT_G721_32___5 = 48,
    SF_FORMAT_G723_24___5 = 49,
    SF_FORMAT_G723_40___5 = 50,
    SF_FORMAT_DWVW_12___5 = 64,
    SF_FORMAT_DWVW_16___5 = 65,
    SF_FORMAT_DWVW_24___5 = 66,
    SF_FORMAT_DWVW_N___5 = 67,
    SF_FORMAT_DPCM_8___5 = 80,
    SF_FORMAT_DPCM_16___5 = 81,
    SF_FORMAT_VORBIS___5 = 96,
    SF_ENDIAN_FILE___5 = 0,
    SF_ENDIAN_LITTLE___5 = 268435456,
    SF_ENDIAN_BIG___5 = 536870912,
    SF_ENDIAN_CPU___5 = 805306368,
    SF_FORMAT_SUBMASK___5 = 65535,
    SF_FORMAT_TYPEMASK___5 = 268369920,
    SF_FORMAT_ENDMASK___5 = 805306368
} ;
#line 126
enum __anonenum__268 {
    SFC_GET_LIB_VERSION___5 = 4096,
    SFC_GET_LOG_INFO___5 = 4097,
    SFC_GET_CURRENT_SF_INFO___5 = 4098,
    SFC_GET_NORM_DOUBLE___5 = 4112,
    SFC_GET_NORM_FLOAT___5 = 4113,
    SFC_SET_NORM_DOUBLE___5 = 4114,
    SFC_SET_NORM_FLOAT___5 = 4115,
    SFC_SET_SCALE_FLOAT_INT_READ___5 = 4116,
    SFC_SET_SCALE_INT_FLOAT_WRITE___5 = 4117,
    SFC_GET_SIMPLE_FORMAT_COUNT___5 = 4128,
    SFC_GET_SIMPLE_FORMAT___5 = 4129,
    SFC_GET_FORMAT_INFO___5 = 4136,
    SFC_GET_FORMAT_MAJOR_COUNT___5 = 4144,
    SFC_GET_FORMAT_MAJOR___5 = 4145,
    SFC_GET_FORMAT_SUBTYPE_COUNT___5 = 4146,
    SFC_GET_FORMAT_SUBTYPE___5 = 4147,
    SFC_CALC_SIGNAL_MAX___5 = 4160,
    SFC_CALC_NORM_SIGNAL_MAX___5 = 4161,
    SFC_CALC_MAX_ALL_CHANNELS___5 = 4162,
    SFC_CALC_NORM_MAX_ALL_CHANNELS___5 = 4163,
    SFC_GET_SIGNAL_MAX___5 = 4164,
    SFC_GET_MAX_ALL_CHANNELS___5 = 4165,
    SFC_SET_ADD_PEAK_CHUNK___5 = 4176,
    SFC_SET_ADD_HEADER_PAD_CHUNK___5 = 4177,
    SFC_UPDATE_HEADER_NOW___5 = 4192,
    SFC_SET_UPDATE_HEADER_AUTO___5 = 4193,
    SFC_FILE_TRUNCATE___5 = 4224,
    SFC_SET_RAW_START_OFFSET___5 = 4240,
    SFC_SET_DITHER_ON_WRITE___5 = 4256,
    SFC_SET_DITHER_ON_READ___5 = 4257,
    SFC_GET_DITHER_INFO_COUNT___5 = 4258,
    SFC_GET_DITHER_INFO___5 = 4259,
    SFC_GET_EMBED_FILE_INFO___5 = 4272,
    SFC_SET_CLIPPING___5 = 4288,
    SFC_GET_CLIPPING___5 = 4289,
    SFC_GET_INSTRUMENT___5 = 4304,
    SFC_SET_INSTRUMENT___5 = 4305,
    SFC_GET_LOOP_INFO___5 = 4320,
    SFC_GET_BROADCAST_INFO___5 = 4336,
    SFC_SET_BROADCAST_INFO___5 = 4337,
    SFC_GET_CHANNEL_MAP_INFO___5 = 4352,
    SFC_SET_CHANNEL_MAP_INFO___5 = 4353,
    SFC_RAW_DATA_NEEDS_ENDSWAP___5 = 4368,
    SFC_WAVEX_SET_AMBISONIC___5 = 4608,
    SFC_WAVEX_GET_AMBISONIC___5 = 4609,
    SFC_SET_VBR_ENCODING_QUALITY___5 = 4864,
    SFC_TEST_IEEE_FLOAT_REPLACE___5 = 24577,
    SFC_SET_ADD_DITHER_ON_WRITE___5 = 4208,
    SFC_SET_ADD_DITHER_ON_READ___5 = 4209
} ;
#line 216
enum __anonenum__269 {
    SF_STR_TITLE___5 = 1,
    SF_STR_COPYRIGHT___5 = 2,
    SF_STR_SOFTWARE___5 = 3,
    SF_STR_ARTIST___5 = 4,
    SF_STR_COMMENT___5 = 5,
    SF_STR_DATE___5 = 6,
    SF_STR_ALBUM___5 = 7,
    SF_STR_LICENSE___5 = 8
} ;
#line 235
enum __anonenum__270 {
    SF_FALSE___5 = 0,
    SF_TRUE___5 = 1,
    SFM_READ___5 = 16,
    SFM_WRITE___5 = 32,
    SFM_RDWR___5 = 48,
    SF_AMBISONIC_NONE___5 = 64,
    SF_AMBISONIC_B_FORMAT___5 = 65
} ;
#line 255
enum __anonenum__271 {
    SF_ERR_NO_ERROR___5 = 0,
    SF_ERR_UNRECOGNISED_FORMAT___5 = 1,
    SF_ERR_SYSTEM___5 = 2,
    SF_ERR_MALFORMED_FILE___5 = 3,
    SF_ERR_UNSUPPORTED_ENCODING___5 = 4
} ;
#line 267
enum __anonenum__272 {
    SF_CHANNEL_MAP_INVALID___5 = 0,
    SF_CHANNEL_MAP_MONO___5 = 1,
    SF_CHANNEL_MAP_LEFT___5 = 2,
    SF_CHANNEL_MAP_RIGHT___5 = 3,
    SF_CHANNEL_MAP_CENTER___5 = 4,
    SF_CHANNEL_MAP_FRONT_LEFT___5 = 5,
    SF_CHANNEL_MAP_FRONT_RIGHT___5 = 6,
    SF_CHANNEL_MAP_FRONT_CENTER___5 = 7,
    SF_CHANNEL_MAP_REAR_CENTER___5 = 8,
    SF_CHANNEL_MAP_REAR_LEFT___5 = 9,
    SF_CHANNEL_MAP_REAR_RIGHT___5 = 10,
    SF_CHANNEL_MAP_LFE___5 = 11,
    SF_CHANNEL_MAP_FRONT_LEFT_OF_CENTER___5 = 12,
    SF_CHANNEL_MAP_FRONT_RIGHT_OF_CENTER___5 = 13,
    SF_CHANNEL_MAP_SIDE_LEFT___5 = 14,
    SF_CHANNEL_MAP_SIDE_RIGHT___5 = 15,
    SF_CHANNEL_MAP_TOP_CENTER___5 = 16,
    SF_CHANNEL_MAP_TOP_FRONT_LEFT___5 = 17,
    SF_CHANNEL_MAP_TOP_FRONT_RIGHT___5 = 18,
    SF_CHANNEL_MAP_TOP_FRONT_CENTER___5 = 19,
    SF_CHANNEL_MAP_TOP_REAR_LEFT___5 = 20,
    SF_CHANNEL_MAP_TOP_REAR_RIGHT___5 = 21,
    SF_CHANNEL_MAP_TOP_REAR_CENTER___5 = 22
} ;
#line 352
enum __anonenum__274 {
    SFD_DEFAULT_LEVEL___5 = 0,
    SFD_CUSTOM_LEVEL___5 = 1073741824,
    SFD_NO_DITHER___5 = 500,
    SFD_WHITE___5 = 501,
    SFD_TRIANGULAR_PDF___5 = 502
} ;
#line 380
enum __anonenum__277 {
    SF_LOOP_NONE___5 = 800,
    SF_LOOP_FORWARD___5 = 801,
    SF_LOOP_BACKWARD___5 = 802,
    SF_LOOP_ALTERNATING___5 = 803
} ;
#line 121 "/root/libsndfile/src/common.h"
enum __anonenum__282 {
    SF_PEAK_START___5 = 42,
    SF_PEAK_END___5 = 43,
    SF_SCALE_MAX___5 = 52,
    SF_SCALE_MIN___5 = 53,
    SF_STR_ALLOW_START___5 = 256,
    SF_STR_ALLOW_END___5 = 512,
    SF_STR_LOCATE_START___5 = 1024,
    SF_STR_LOCATE_END___5 = 2048,
    SFD_TYPEMASK___5 = 268435455
} ;
#line 149
enum __anonenum__283 {
    SF_FORMAT_TXW___5 = 67305472,
    SF_FORMAT_DWD___5 = 67371008,
    SF_FORMAT_REX___5 = 67764224,
    SF_FORMAT_REX2___5 = 67960832,
    SF_FORMAT_KRZ___5 = 68026368,
    SF_FORMAT_WMA___5 = 68157440,
    SF_FORMAT_SHN___5 = 68222976,
    SF_FORMAT_SVX_FIB___5 = 4128,
    SF_FORMAT_SVX_EXP___5 = 4129,
    SF_FORMAT_PCM_N___5 = 4144
} ;
#line 405
enum __anonenum__289 {
    SFE_NO_ERROR___5 = 0,
    SFE_BAD_OPEN_FORMAT___5 = 1,
    SFE_SYSTEM___5 = 2,
    SFE_MALFORMED_FILE___5 = 3,
    SFE_UNSUPPORTED_ENCODING___5 = 4,
    SFE_ZERO_MAJOR_FORMAT___5 = 5,
    SFE_ZERO_MINOR_FORMAT___5 = 6,
    SFE_BAD_FILE___5 = 7,
    SFE_BAD_FILE_READ___5 = 8,
    SFE_OPEN_FAILED___5 = 9,
    SFE_BAD_SNDFILE_PTR___5 = 10,
    SFE_BAD_SF_INFO_PTR___5 = 11,
    SFE_BAD_SF_INCOMPLETE___5 = 12,
    SFE_BAD_FILE_PTR___5 = 13,
    SFE_BAD_INT_PTR___5 = 14,
    SFE_BAD_STAT_SIZE___5 = 15,
    SFE_MALLOC_FAILED___5 = 16,
    SFE_UNIMPLEMENTED___5 = 17,
    SFE_BAD_READ_ALIGN___5 = 18,
    SFE_BAD_WRITE_ALIGN___5 = 19,
    SFE_UNKNOWN_FORMAT___5 = 20,
    SFE_NOT_READMODE___5 = 21,
    SFE_NOT_WRITEMODE___5 = 22,
    SFE_BAD_MODE_RW___5 = 23,
    SFE_BAD_SF_INFO___5 = 24,
    SFE_BAD_OFFSET___5 = 25,
    SFE_NO_EMBED_SUPPORT___5 = 26,
    SFE_NO_EMBEDDED_RDWR___5 = 27,
    SFE_NO_PIPE_WRITE___5 = 28,
    SFE_INTERNAL___5 = 29,
    SFE_BAD_COMMAND_PARAM___5 = 30,
    SFE_BAD_ENDIAN___5 = 31,
    SFE_CHANNEL_COUNT_ZERO___5 = 32,
    SFE_CHANNEL_COUNT___5 = 33,
    SFE_BAD_VIRTUAL_IO___5 = 34,
    SFE_INTERLEAVE_MODE___5 = 35,
    SFE_INTERLEAVE_SEEK___5 = 36,
    SFE_INTERLEAVE_READ___5 = 37,
    SFE_BAD_SEEK___5 = 38,
    SFE_NOT_SEEKABLE___5 = 39,
    SFE_AMBIGUOUS_SEEK___5 = 40,
    SFE_WRONG_SEEK___5 = 41,
    SFE_SEEK_FAILED___5 = 42,
    SFE_BAD_OPEN_MODE___5 = 43,
    SFE_OPEN_PIPE_RDWR___5 = 44,
    SFE_RDWR_POSITION___5 = 45,
    SFE_RDWR_BAD_HEADER___5 = 46,
    SFE_CMD_HAS_DATA___5 = 47,
    SFE_BAD_BROADCAST_INFO_SIZE___5 = 48,
    SFE_STR_NO_SUPPORT___5 = 49,
    SFE_STR_NOT_WRITE___5 = 50,
    SFE_STR_MAX_DATA___5 = 51,
    SFE_STR_MAX_COUNT___5 = 52,
    SFE_STR_BAD_TYPE___5 = 53,
    SFE_STR_NO_ADD_END___5 = 54,
    SFE_STR_BAD_STRING___5 = 55,
    SFE_STR_WEIRD___5 = 56,
    SFE_WAV_NO_RIFF___5 = 57,
    SFE_WAV_NO_WAVE___5 = 58,
    SFE_WAV_NO_FMT___5 = 59,
    SFE_WAV_BAD_FMT___5 = 60,
    SFE_WAV_FMT_SHORT___5 = 61,
    SFE_WAV_BAD_FACT___5 = 62,
    SFE_WAV_BAD_PEAK___5 = 63,
    SFE_WAV_PEAK_B4_FMT___5 = 64,
    SFE_WAV_BAD_FORMAT___5 = 65,
    SFE_WAV_BAD_BLOCKALIGN___5 = 66,
    SFE_WAV_NO_DATA___5 = 67,
    SFE_WAV_BAD_LIST___5 = 68,
    SFE_WAV_ADPCM_NOT4BIT___5 = 69,
    SFE_WAV_ADPCM_CHANNELS___5 = 70,
    SFE_WAV_GSM610_FORMAT___5 = 71,
    SFE_WAV_UNKNOWN_CHUNK___5 = 72,
    SFE_WAV_WVPK_DATA___5 = 73,
    SFE_AIFF_NO_FORM___5 = 74,
    SFE_AIFF_AIFF_NO_FORM___5 = 75,
    SFE_AIFF_COMM_NO_FORM___5 = 76,
    SFE_AIFF_SSND_NO_COMM___5 = 77,
    SFE_AIFF_UNKNOWN_CHUNK___5 = 78,
    SFE_AIFF_COMM_CHUNK_SIZE___5 = 79,
    SFE_AIFF_BAD_COMM_CHUNK___5 = 80,
    SFE_AIFF_PEAK_B4_COMM___5 = 81,
    SFE_AIFF_BAD_PEAK___5 = 82,
    SFE_AIFF_NO_SSND___5 = 83,
    SFE_AIFF_NO_DATA___5 = 84,
    SFE_AIFF_RW_SSND_NOT_LAST___5 = 85,
    SFE_AU_UNKNOWN_FORMAT___5 = 86,
    SFE_AU_NO_DOTSND___5 = 87,
    SFE_AU_EMBED_BAD_LEN___5 = 88,
    SFE_RAW_READ_BAD_SPEC___5 = 89,
    SFE_RAW_BAD_BITWIDTH___5 = 90,
    SFE_RAW_BAD_FORMAT___5 = 91,
    SFE_PAF_NO_MARKER___5 = 92,
    SFE_PAF_VERSION___5 = 93,
    SFE_PAF_UNKNOWN_FORMAT___5 = 94,
    SFE_PAF_SHORT_HEADER___5 = 95,
    SFE_SVX_NO_FORM___5 = 96,
    SFE_SVX_NO_BODY___5 = 97,
    SFE_SVX_NO_DATA___5 = 98,
    SFE_SVX_BAD_COMP___5 = 99,
    SFE_SVX_BAD_NAME_LENGTH___5 = 100,
    SFE_NIST_BAD_HEADER___5 = 101,
    SFE_NIST_CRLF_CONVERISON___5 = 102,
    SFE_NIST_BAD_ENCODING___5 = 103,
    SFE_VOC_NO_CREATIVE___5 = 104,
    SFE_VOC_BAD_FORMAT___5 = 105,
    SFE_VOC_BAD_VERSION___5 = 106,
    SFE_VOC_BAD_MARKER___5 = 107,
    SFE_VOC_BAD_SECTIONS___5 = 108,
    SFE_VOC_MULTI_SAMPLERATE___5 = 109,
    SFE_VOC_MULTI_SECTION___5 = 110,
    SFE_VOC_MULTI_PARAM___5 = 111,
    SFE_VOC_SECTION_COUNT___5 = 112,
    SFE_VOC_NO_PIPE___5 = 113,
    SFE_IRCAM_NO_MARKER___5 = 114,
    SFE_IRCAM_BAD_CHANNELS___5 = 115,
    SFE_IRCAM_UNKNOWN_FORMAT___5 = 116,
    SFE_W64_64_BIT___5 = 117,
    SFE_W64_NO_RIFF___5 = 118,
    SFE_W64_NO_WAVE___5 = 119,
    SFE_W64_NO_DATA___5 = 120,
    SFE_W64_ADPCM_NOT4BIT___5 = 121,
    SFE_W64_ADPCM_CHANNELS___5 = 122,
    SFE_W64_GSM610_FORMAT___5 = 123,
    SFE_MAT4_BAD_NAME___5 = 124,
    SFE_MAT4_NO_SAMPLERATE___5 = 125,
    SFE_MAT5_BAD_ENDIAN___5 = 126,
    SFE_MAT5_NO_BLOCK___5 = 127,
    SFE_MAT5_SAMPLE_RATE___5 = 128,
    SFE_PVF_NO_PVF1___5 = 129,
    SFE_PVF_BAD_HEADER___5 = 130,
    SFE_PVF_BAD_BITWIDTH___5 = 131,
    SFE_DWVW_BAD_BITWIDTH___5 = 132,
    SFE_G72X_NOT_MONO___5 = 133,
    SFE_XI_BAD_HEADER___5 = 134,
    SFE_XI_EXCESS_SAMPLES___5 = 135,
    SFE_XI_NO_PIPE___5 = 136,
    SFE_HTK_NO_PIPE___5 = 137,
    SFE_SDS_NOT_SDS___5 = 138,
    SFE_SDS_BAD_BIT_WIDTH___5 = 139,
    SFE_SD2_FD_DISALLOWED___5 = 140,
    SFE_SD2_BAD_DATA_OFFSET___5 = 141,
    SFE_SD2_BAD_MAP_OFFSET___5 = 142,
    SFE_SD2_BAD_DATA_LENGTH___5 = 143,
    SFE_SD2_BAD_MAP_LENGTH___5 = 144,
    SFE_SD2_BAD_RSRC___5 = 145,
    SFE_SD2_BAD_SAMPLE_SIZE___5 = 146,
    SFE_FLAC_BAD_HEADER___5 = 147,
    SFE_FLAC_NEW_DECODER___5 = 148,
    SFE_FLAC_INIT_DECODER___5 = 149,
    SFE_FLAC_LOST_SYNC___5 = 150,
    SFE_FLAC_BAD_SAMPLE_RATE___5 = 151,
    SFE_FLAC_UNKOWN_ERROR___5 = 152,
    SFE_WVE_NOT_WVE___5 = 153,
    SFE_WVE_NO_PIPE___5 = 154,
    SFE_VORBIS_ENCODER_BUG___5 = 155,
    SFE_RF64_NOT_RF64___5 = 156,
    SFE_MAX_ERROR___5 = 157
} ;
#line 823
enum __anonenum__293 {
    SFC_TEST_AIFF_ADD_INST_CHUNK___5 = 8192,
    SFC_TEST_WAV_ADD_INFO_CHUNK___5 = 8208
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__43___1 {
    FP_NAN___4 = 0,
    FP_INFINITE___4 = 1,
    FP_ZERO___4 = 2,
    FP_SUBNORMAL___4 = 3,
    FP_NORMAL___4 = 4
} ;
#line 46 "/root/libsndfile/src/sndfile.h"
enum __anonenum__44___1 {
    SF_FORMAT_WAV___6 = 65536,
    SF_FORMAT_AIFF___6 = 131072,
    SF_FORMAT_AU___6 = 196608,
    SF_FORMAT_RAW___6 = 262144,
    SF_FORMAT_PAF___6 = 327680,
    SF_FORMAT_SVX___6 = 393216,
    SF_FORMAT_NIST___6 = 458752,
    SF_FORMAT_VOC___6 = 524288,
    SF_FORMAT_IRCAM___6 = 655360,
    SF_FORMAT_W64___6 = 720896,
    SF_FORMAT_MAT4___6 = 786432,
    SF_FORMAT_MAT5___6 = 851968,
    SF_FORMAT_PVF___6 = 917504,
    SF_FORMAT_XI___6 = 983040,
    SF_FORMAT_HTK___6 = 1048576,
    SF_FORMAT_SDS___6 = 1114112,
    SF_FORMAT_AVR___6 = 1179648,
    SF_FORMAT_WAVEX___6 = 1245184,
    SF_FORMAT_SD2___6 = 1441792,
    SF_FORMAT_FLAC___6 = 1507328,
    SF_FORMAT_CAF___6 = 1572864,
    SF_FORMAT_WVE___6 = 1638400,
    SF_FORMAT_OGG___6 = 2097152,
    SF_FORMAT_MPC2K___6 = 2162688,
    SF_FORMAT_RF64___6 = 2228224,
    SF_FORMAT_PCM_S8___6 = 1,
    SF_FORMAT_PCM_16___6 = 2,
    SF_FORMAT_PCM_24___6 = 3,
    SF_FORMAT_PCM_32___6 = 4,
    SF_FORMAT_PCM_U8___6 = 5,
    SF_FORMAT_FLOAT___6 = 6,
    SF_FORMAT_DOUBLE___6 = 7,
    SF_FORMAT_ULAW___6 = 16,
    SF_FORMAT_ALAW___6 = 17,
    SF_FORMAT_IMA_ADPCM___6 = 18,
    SF_FORMAT_MS_ADPCM___6 = 19,
    SF_FORMAT_GSM610___6 = 32,
    SF_FORMAT_VOX_ADPCM___6 = 33,
    SF_FORMAT_G721_32___6 = 48,
    SF_FORMAT_G723_24___6 = 49,
    SF_FORMAT_G723_40___6 = 50,
    SF_FORMAT_DWVW_12___6 = 64,
    SF_FORMAT_DWVW_16___6 = 65,
    SF_FORMAT_DWVW_24___6 = 66,
    SF_FORMAT_DWVW_N___6 = 67,
    SF_FORMAT_DPCM_8___6 = 80,
    SF_FORMAT_DPCM_16___6 = 81,
    SF_FORMAT_VORBIS___6 = 96,
    SF_ENDIAN_FILE___6 = 0,
    SF_ENDIAN_LITTLE___6 = 268435456,
    SF_ENDIAN_BIG___6 = 536870912,
    SF_ENDIAN_CPU___6 = 805306368,
    SF_FORMAT_SUBMASK___6 = 65535,
    SF_FORMAT_TYPEMASK___6 = 268369920,
    SF_FORMAT_ENDMASK___6 = 805306368
} ;
#line 126
enum __anonenum__45___1 {
    SFC_GET_LIB_VERSION___6 = 4096,
    SFC_GET_LOG_INFO___6 = 4097,
    SFC_GET_CURRENT_SF_INFO___6 = 4098,
    SFC_GET_NORM_DOUBLE___6 = 4112,
    SFC_GET_NORM_FLOAT___6 = 4113,
    SFC_SET_NORM_DOUBLE___6 = 4114,
    SFC_SET_NORM_FLOAT___6 = 4115,
    SFC_SET_SCALE_FLOAT_INT_READ___6 = 4116,
    SFC_SET_SCALE_INT_FLOAT_WRITE___6 = 4117,
    SFC_GET_SIMPLE_FORMAT_COUNT___6 = 4128,
    SFC_GET_SIMPLE_FORMAT___6 = 4129,
    SFC_GET_FORMAT_INFO___6 = 4136,
    SFC_GET_FORMAT_MAJOR_COUNT___6 = 4144,
    SFC_GET_FORMAT_MAJOR___6 = 4145,
    SFC_GET_FORMAT_SUBTYPE_COUNT___6 = 4146,
    SFC_GET_FORMAT_SUBTYPE___6 = 4147,
    SFC_CALC_SIGNAL_MAX___6 = 4160,
    SFC_CALC_NORM_SIGNAL_MAX___6 = 4161,
    SFC_CALC_MAX_ALL_CHANNELS___6 = 4162,
    SFC_CALC_NORM_MAX_ALL_CHANNELS___6 = 4163,
    SFC_GET_SIGNAL_MAX___6 = 4164,
    SFC_GET_MAX_ALL_CHANNELS___6 = 4165,
    SFC_SET_ADD_PEAK_CHUNK___6 = 4176,
    SFC_SET_ADD_HEADER_PAD_CHUNK___6 = 4177,
    SFC_UPDATE_HEADER_NOW___6 = 4192,
    SFC_SET_UPDATE_HEADER_AUTO___6 = 4193,
    SFC_FILE_TRUNCATE___6 = 4224,
    SFC_SET_RAW_START_OFFSET___6 = 4240,
    SFC_SET_DITHER_ON_WRITE___6 = 4256,
    SFC_SET_DITHER_ON_READ___6 = 4257,
    SFC_GET_DITHER_INFO_COUNT___6 = 4258,
    SFC_GET_DITHER_INFO___6 = 4259,
    SFC_GET_EMBED_FILE_INFO___6 = 4272,
    SFC_SET_CLIPPING___6 = 4288,
    SFC_GET_CLIPPING___6 = 4289,
    SFC_GET_INSTRUMENT___6 = 4304,
    SFC_SET_INSTRUMENT___6 = 4305,
    SFC_GET_LOOP_INFO___6 = 4320,
    SFC_GET_BROADCAST_INFO___6 = 4336,
    SFC_SET_BROADCAST_INFO___6 = 4337,
    SFC_GET_CHANNEL_MAP_INFO___6 = 4352,
    SFC_SET_CHANNEL_MAP_INFO___6 = 4353,
    SFC_RAW_DATA_NEEDS_ENDSWAP___6 = 4368,
    SFC_WAVEX_SET_AMBISONIC___6 = 4608,
    SFC_WAVEX_GET_AMBISONIC___6 = 4609,
    SFC_SET_VBR_ENCODING_QUALITY___6 = 4864,
    SFC_TEST_IEEE_FLOAT_REPLACE___6 = 24577,
    SFC_SET_ADD_DITHER_ON_WRITE___6 = 4208,
    SFC_SET_ADD_DITHER_ON_READ___6 = 4209
} ;
#line 216
enum __anonenum__46___1 {
    SF_STR_TITLE___6 = 1,
    SF_STR_COPYRIGHT___6 = 2,
    SF_STR_SOFTWARE___6 = 3,
    SF_STR_ARTIST___6 = 4,
    SF_STR_COMMENT___6 = 5,
    SF_STR_DATE___6 = 6,
    SF_STR_ALBUM___6 = 7,
    SF_STR_LICENSE___6 = 8
} ;
#line 235
enum __anonenum__47___1 {
    SF_FALSE___6 = 0,
    SF_TRUE___6 = 1,
    SFM_READ___6 = 16,
    SFM_WRITE___6 = 32,
    SFM_RDWR___6 = 48,
    SF_AMBISONIC_NONE___6 = 64,
    SF_AMBISONIC_B_FORMAT___6 = 65
} ;
#line 255
enum __anonenum__48___1 {
    SF_ERR_NO_ERROR___6 = 0,
    SF_ERR_UNRECOGNISED_FORMAT___6 = 1,
    SF_ERR_SYSTEM___6 = 2,
    SF_ERR_MALFORMED_FILE___6 = 3,
    SF_ERR_UNSUPPORTED_ENCODING___6 = 4
} ;
#line 267
enum __anonenum__49___1 {
    SF_CHANNEL_MAP_INVALID___6 = 0,
    SF_CHANNEL_MAP_MONO___6 = 1,
    SF_CHANNEL_MAP_LEFT___6 = 2,
    SF_CHANNEL_MAP_RIGHT___6 = 3,
    SF_CHANNEL_MAP_CENTER___6 = 4,
    SF_CHANNEL_MAP_FRONT_LEFT___6 = 5,
    SF_CHANNEL_MAP_FRONT_RIGHT___6 = 6,
    SF_CHANNEL_MAP_FRONT_CENTER___6 = 7,
    SF_CHANNEL_MAP_REAR_CENTER___6 = 8,
    SF_CHANNEL_MAP_REAR_LEFT___6 = 9,
    SF_CHANNEL_MAP_REAR_RIGHT___6 = 10,
    SF_CHANNEL_MAP_LFE___6 = 11,
    SF_CHANNEL_MAP_FRONT_LEFT_OF_CENTER___6 = 12,
    SF_CHANNEL_MAP_FRONT_RIGHT_OF_CENTER___6 = 13,
    SF_CHANNEL_MAP_SIDE_LEFT___6 = 14,
    SF_CHANNEL_MAP_SIDE_RIGHT___6 = 15,
    SF_CHANNEL_MAP_TOP_CENTER___6 = 16,
    SF_CHANNEL_MAP_TOP_FRONT_LEFT___6 = 17,
    SF_CHANNEL_MAP_TOP_FRONT_RIGHT___6 = 18,
    SF_CHANNEL_MAP_TOP_FRONT_CENTER___6 = 19,
    SF_CHANNEL_MAP_TOP_REAR_LEFT___6 = 20,
    SF_CHANNEL_MAP_TOP_REAR_RIGHT___6 = 21,
    SF_CHANNEL_MAP_TOP_REAR_CENTER___6 = 22
} ;
#line 352
enum __anonenum__51___1 {
    SFD_DEFAULT_LEVEL___6 = 0,
    SFD_CUSTOM_LEVEL___6 = 1073741824,
    SFD_NO_DITHER___6 = 500,
    SFD_WHITE___6 = 501,
    SFD_TRIANGULAR_PDF___6 = 502
} ;
#line 380
enum __anonenum__54___1 {
    SF_LOOP_NONE___6 = 800,
    SF_LOOP_FORWARD___6 = 801,
    SF_LOOP_BACKWARD___6 = 802,
    SF_LOOP_ALTERNATING___6 = 803
} ;
#line 121 "/root/libsndfile/src/common.h"
enum __anonenum__59___1 {
    SF_PEAK_START___6 = 42,
    SF_PEAK_END___6 = 43,
    SF_SCALE_MAX___6 = 52,
    SF_SCALE_MIN___6 = 53,
    SF_STR_ALLOW_START___6 = 256,
    SF_STR_ALLOW_END___6 = 512,
    SF_STR_LOCATE_START___6 = 1024,
    SF_STR_LOCATE_END___6 = 2048,
    SFD_TYPEMASK___6 = 268435455
} ;
#line 149
enum __anonenum__60___1 {
    SF_FORMAT_TXW___6 = 67305472,
    SF_FORMAT_DWD___6 = 67371008,
    SF_FORMAT_REX___6 = 67764224,
    SF_FORMAT_REX2___6 = 67960832,
    SF_FORMAT_KRZ___6 = 68026368,
    SF_FORMAT_WMA___6 = 68157440,
    SF_FORMAT_SHN___6 = 68222976,
    SF_FORMAT_SVX_FIB___6 = 4128,
    SF_FORMAT_SVX_EXP___6 = 4129,
    SF_FORMAT_PCM_N___6 = 4144
} ;
#line 405
enum __anonenum__66___1 {
    SFE_NO_ERROR___6 = 0,
    SFE_BAD_OPEN_FORMAT___6 = 1,
    SFE_SYSTEM___6 = 2,
    SFE_MALFORMED_FILE___6 = 3,
    SFE_UNSUPPORTED_ENCODING___6 = 4,
    SFE_ZERO_MAJOR_FORMAT___6 = 5,
    SFE_ZERO_MINOR_FORMAT___6 = 6,
    SFE_BAD_FILE___6 = 7,
    SFE_BAD_FILE_READ___6 = 8,
    SFE_OPEN_FAILED___6 = 9,
    SFE_BAD_SNDFILE_PTR___6 = 10,
    SFE_BAD_SF_INFO_PTR___6 = 11,
    SFE_BAD_SF_INCOMPLETE___6 = 12,
    SFE_BAD_FILE_PTR___6 = 13,
    SFE_BAD_INT_PTR___6 = 14,
    SFE_BAD_STAT_SIZE___6 = 15,
    SFE_MALLOC_FAILED___6 = 16,
    SFE_UNIMPLEMENTED___6 = 17,
    SFE_BAD_READ_ALIGN___6 = 18,
    SFE_BAD_WRITE_ALIGN___6 = 19,
    SFE_UNKNOWN_FORMAT___6 = 20,
    SFE_NOT_READMODE___6 = 21,
    SFE_NOT_WRITEMODE___6 = 22,
    SFE_BAD_MODE_RW___6 = 23,
    SFE_BAD_SF_INFO___6 = 24,
    SFE_BAD_OFFSET___6 = 25,
    SFE_NO_EMBED_SUPPORT___6 = 26,
    SFE_NO_EMBEDDED_RDWR___6 = 27,
    SFE_NO_PIPE_WRITE___6 = 28,
    SFE_INTERNAL___6 = 29,
    SFE_BAD_COMMAND_PARAM___6 = 30,
    SFE_BAD_ENDIAN___6 = 31,
    SFE_CHANNEL_COUNT_ZERO___6 = 32,
    SFE_CHANNEL_COUNT___6 = 33,
    SFE_BAD_VIRTUAL_IO___6 = 34,
    SFE_INTERLEAVE_MODE___6 = 35,
    SFE_INTERLEAVE_SEEK___6 = 36,
    SFE_INTERLEAVE_READ___6 = 37,
    SFE_BAD_SEEK___6 = 38,
    SFE_NOT_SEEKABLE___6 = 39,
    SFE_AMBIGUOUS_SEEK___6 = 40,
    SFE_WRONG_SEEK___6 = 41,
    SFE_SEEK_FAILED___6 = 42,
    SFE_BAD_OPEN_MODE___6 = 43,
    SFE_OPEN_PIPE_RDWR___6 = 44,
    SFE_RDWR_POSITION___6 = 45,
    SFE_RDWR_BAD_HEADER___6 = 46,
    SFE_CMD_HAS_DATA___6 = 47,
    SFE_BAD_BROADCAST_INFO_SIZE___6 = 48,
    SFE_STR_NO_SUPPORT___6 = 49,
    SFE_STR_NOT_WRITE___6 = 50,
    SFE_STR_MAX_DATA___6 = 51,
    SFE_STR_MAX_COUNT___6 = 52,
    SFE_STR_BAD_TYPE___6 = 53,
    SFE_STR_NO_ADD_END___6 = 54,
    SFE_STR_BAD_STRING___6 = 55,
    SFE_STR_WEIRD___6 = 56,
    SFE_WAV_NO_RIFF___6 = 57,
    SFE_WAV_NO_WAVE___6 = 58,
    SFE_WAV_NO_FMT___6 = 59,
    SFE_WAV_BAD_FMT___6 = 60,
    SFE_WAV_FMT_SHORT___6 = 61,
    SFE_WAV_BAD_FACT___6 = 62,
    SFE_WAV_BAD_PEAK___6 = 63,
    SFE_WAV_PEAK_B4_FMT___6 = 64,
    SFE_WAV_BAD_FORMAT___6 = 65,
    SFE_WAV_BAD_BLOCKALIGN___6 = 66,
    SFE_WAV_NO_DATA___6 = 67,
    SFE_WAV_BAD_LIST___6 = 68,
    SFE_WAV_ADPCM_NOT4BIT___6 = 69,
    SFE_WAV_ADPCM_CHANNELS___6 = 70,
    SFE_WAV_GSM610_FORMAT___6 = 71,
    SFE_WAV_UNKNOWN_CHUNK___6 = 72,
    SFE_WAV_WVPK_DATA___6 = 73,
    SFE_AIFF_NO_FORM___6 = 74,
    SFE_AIFF_AIFF_NO_FORM___6 = 75,
    SFE_AIFF_COMM_NO_FORM___6 = 76,
    SFE_AIFF_SSND_NO_COMM___6 = 77,
    SFE_AIFF_UNKNOWN_CHUNK___6 = 78,
    SFE_AIFF_COMM_CHUNK_SIZE___6 = 79,
    SFE_AIFF_BAD_COMM_CHUNK___6 = 80,
    SFE_AIFF_PEAK_B4_COMM___6 = 81,
    SFE_AIFF_BAD_PEAK___6 = 82,
    SFE_AIFF_NO_SSND___6 = 83,
    SFE_AIFF_NO_DATA___6 = 84,
    SFE_AIFF_RW_SSND_NOT_LAST___6 = 85,
    SFE_AU_UNKNOWN_FORMAT___6 = 86,
    SFE_AU_NO_DOTSND___6 = 87,
    SFE_AU_EMBED_BAD_LEN___6 = 88,
    SFE_RAW_READ_BAD_SPEC___6 = 89,
    SFE_RAW_BAD_BITWIDTH___6 = 90,
    SFE_RAW_BAD_FORMAT___6 = 91,
    SFE_PAF_NO_MARKER___6 = 92,
    SFE_PAF_VERSION___6 = 93,
    SFE_PAF_UNKNOWN_FORMAT___6 = 94,
    SFE_PAF_SHORT_HEADER___6 = 95,
    SFE_SVX_NO_FORM___6 = 96,
    SFE_SVX_NO_BODY___6 = 97,
    SFE_SVX_NO_DATA___6 = 98,
    SFE_SVX_BAD_COMP___6 = 99,
    SFE_SVX_BAD_NAME_LENGTH___6 = 100,
    SFE_NIST_BAD_HEADER___6 = 101,
    SFE_NIST_CRLF_CONVERISON___6 = 102,
    SFE_NIST_BAD_ENCODING___6 = 103,
    SFE_VOC_NO_CREATIVE___6 = 104,
    SFE_VOC_BAD_FORMAT___6 = 105,
    SFE_VOC_BAD_VERSION___6 = 106,
    SFE_VOC_BAD_MARKER___6 = 107,
    SFE_VOC_BAD_SECTIONS___6 = 108,
    SFE_VOC_MULTI_SAMPLERATE___6 = 109,
    SFE_VOC_MULTI_SECTION___6 = 110,
    SFE_VOC_MULTI_PARAM___6 = 111,
    SFE_VOC_SECTION_COUNT___6 = 112,
    SFE_VOC_NO_PIPE___6 = 113,
    SFE_IRCAM_NO_MARKER___6 = 114,
    SFE_IRCAM_BAD_CHANNELS___6 = 115,
    SFE_IRCAM_UNKNOWN_FORMAT___6 = 116,
    SFE_W64_64_BIT___6 = 117,
    SFE_W64_NO_RIFF___6 = 118,
    SFE_W64_NO_WAVE___6 = 119,
    SFE_W64_NO_DATA___6 = 120,
    SFE_W64_ADPCM_NOT4BIT___6 = 121,
    SFE_W64_ADPCM_CHANNELS___6 = 122,
    SFE_W64_GSM610_FORMAT___6 = 123,
    SFE_MAT4_BAD_NAME___6 = 124,
    SFE_MAT4_NO_SAMPLERATE___6 = 125,
    SFE_MAT5_BAD_ENDIAN___6 = 126,
    SFE_MAT5_NO_BLOCK___6 = 127,
    SFE_MAT5_SAMPLE_RATE___6 = 128,
    SFE_PVF_NO_PVF1___6 = 129,
    SFE_PVF_BAD_HEADER___6 = 130,
    SFE_PVF_BAD_BITWIDTH___6 = 131,
    SFE_DWVW_BAD_BITWIDTH___6 = 132,
    SFE_G72X_NOT_MONO___6 = 133,
    SFE_XI_BAD_HEADER___6 = 134,
    SFE_XI_EXCESS_SAMPLES___6 = 135,
    SFE_XI_NO_PIPE___6 = 136,
    SFE_HTK_NO_PIPE___6 = 137,
    SFE_SDS_NOT_SDS___6 = 138,
    SFE_SDS_BAD_BIT_WIDTH___6 = 139,
    SFE_SD2_FD_DISALLOWED___6 = 140,
    SFE_SD2_BAD_DATA_OFFSET___6 = 141,
    SFE_SD2_BAD_MAP_OFFSET___6 = 142,
    SFE_SD2_BAD_DATA_LENGTH___6 = 143,
    SFE_SD2_BAD_MAP_LENGTH___6 = 144,
    SFE_SD2_BAD_RSRC___6 = 145,
    SFE_SD2_BAD_SAMPLE_SIZE___6 = 146,
    SFE_FLAC_BAD_HEADER___6 = 147,
    SFE_FLAC_NEW_DECODER___6 = 148,
    SFE_FLAC_INIT_DECODER___6 = 149,
    SFE_FLAC_LOST_SYNC___6 = 150,
    SFE_FLAC_BAD_SAMPLE_RATE___6 = 151,
    SFE_FLAC_UNKOWN_ERROR___6 = 152,
    SFE_WVE_NOT_WVE___6 = 153,
    SFE_WVE_NO_PIPE___6 = 154,
    SFE_VORBIS_ENCODER_BUG___6 = 155,
    SFE_RF64_NOT_RF64___6 = 156,
    SFE_MAX_ERROR___6 = 157
} ;
#line 823
enum __anonenum__70___1 {
    SFC_TEST_AIFF_ADD_INST_CHUNK___6 = 8192,
    SFC_TEST_WAV_ADD_INFO_CHUNK___6 = 8208
} ;
#line 30 "/root/libsndfile/src/ima_adpcm.c"
struct IMA_ADPCM_PRIVATE_tag {
   int (*decode_block)(SF_PRIVATE * , struct IMA_ADPCM_PRIVATE_tag * ) ;
   int (*encode_block)(SF_PRIVATE * , struct IMA_ADPCM_PRIVATE_tag * ) ;
   int channels ;
   int blocksize ;
   int samplesperblock ;
   int blocks ;
   int blockcount ;
   int samplecount ;
   int previous[2] ;
   int stepindx[2] ;
   unsigned char *block ;
   short *samples ;
   short data[] ;
};
#line 45 "/root/libsndfile/src/ima_adpcm.c"
typedef struct IMA_ADPCM_PRIVATE_tag IMA_ADPCM_PRIVATE;
#line 853 "/usr/include/math.h"
enum __anonenum__43___2 {
    FP_NAN___5 = 0,
    FP_INFINITE___5 = 1,
    FP_ZERO___5 = 2,
    FP_SUBNORMAL___5 = 3,
    FP_NORMAL___5 = 4
} ;
#line 46 "/root/libsndfile/src/sndfile.h"
enum __anonenum__44___2 {
    SF_FORMAT_WAV___7 = 65536,
    SF_FORMAT_AIFF___7 = 131072,
    SF_FORMAT_AU___7 = 196608,
    SF_FORMAT_RAW___7 = 262144,
    SF_FORMAT_PAF___7 = 327680,
    SF_FORMAT_SVX___7 = 393216,
    SF_FORMAT_NIST___7 = 458752,
    SF_FORMAT_VOC___7 = 524288,
    SF_FORMAT_IRCAM___7 = 655360,
    SF_FORMAT_W64___7 = 720896,
    SF_FORMAT_MAT4___7 = 786432,
    SF_FORMAT_MAT5___7 = 851968,
    SF_FORMAT_PVF___7 = 917504,
    SF_FORMAT_XI___7 = 983040,
    SF_FORMAT_HTK___7 = 1048576,
    SF_FORMAT_SDS___7 = 1114112,
    SF_FORMAT_AVR___7 = 1179648,
    SF_FORMAT_WAVEX___7 = 1245184,
    SF_FORMAT_SD2___7 = 1441792,
    SF_FORMAT_FLAC___7 = 1507328,
    SF_FORMAT_CAF___7 = 1572864,
    SF_FORMAT_WVE___7 = 1638400,
    SF_FORMAT_OGG___7 = 2097152,
    SF_FORMAT_MPC2K___7 = 2162688,
    SF_FORMAT_RF64___7 = 2228224,
    SF_FORMAT_PCM_S8___7 = 1,
    SF_FORMAT_PCM_16___7 = 2,
    SF_FORMAT_PCM_24___7 = 3,
    SF_FORMAT_PCM_32___7 = 4,
    SF_FORMAT_PCM_U8___7 = 5,
    SF_FORMAT_FLOAT___7 = 6,
    SF_FORMAT_DOUBLE___7 = 7,
    SF_FORMAT_ULAW___7 = 16,
    SF_FORMAT_ALAW___7 = 17,
    SF_FORMAT_IMA_ADPCM___7 = 18,
    SF_FORMAT_MS_ADPCM___7 = 19,
    SF_FORMAT_GSM610___7 = 32,
    SF_FORMAT_VOX_ADPCM___7 = 33,
    SF_FORMAT_G721_32___7 = 48,
    SF_FORMAT_G723_24___7 = 49,
    SF_FORMAT_G723_40___7 = 50,
    SF_FORMAT_DWVW_12___7 = 64,
    SF_FORMAT_DWVW_16___7 = 65,
    SF_FORMAT_DWVW_24___7 = 66,
    SF_FORMAT_DWVW_N___7 = 67,
    SF_FORMAT_DPCM_8___7 = 80,
    SF_FORMAT_DPCM_16___7 = 81,
    SF_FORMAT_VORBIS___7 = 96,
    SF_ENDIAN_FILE___7 = 0,
    SF_ENDIAN_LITTLE___7 = 268435456,
    SF_ENDIAN_BIG___7 = 536870912,
    SF_ENDIAN_CPU___7 = 805306368,
    SF_FORMAT_SUBMASK___7 = 65535,
    SF_FORMAT_TYPEMASK___7 = 268369920,
    SF_FORMAT_ENDMASK___7 = 805306368
} ;
#line 126
enum __anonenum__45___2 {
    SFC_GET_LIB_VERSION___7 = 4096,
    SFC_GET_LOG_INFO___7 = 4097,
    SFC_GET_CURRENT_SF_INFO___7 = 4098,
    SFC_GET_NORM_DOUBLE___7 = 4112,
    SFC_GET_NORM_FLOAT___7 = 4113,
    SFC_SET_NORM_DOUBLE___7 = 4114,
    SFC_SET_NORM_FLOAT___7 = 4115,
    SFC_SET_SCALE_FLOAT_INT_READ___7 = 4116,
    SFC_SET_SCALE_INT_FLOAT_WRITE___7 = 4117,
    SFC_GET_SIMPLE_FORMAT_COUNT___7 = 4128,
    SFC_GET_SIMPLE_FORMAT___7 = 4129,
    SFC_GET_FORMAT_INFO___7 = 4136,
    SFC_GET_FORMAT_MAJOR_COUNT___7 = 4144,
    SFC_GET_FORMAT_MAJOR___7 = 4145,
    SFC_GET_FORMAT_SUBTYPE_COUNT___7 = 4146,
    SFC_GET_FORMAT_SUBTYPE___7 = 4147,
    SFC_CALC_SIGNAL_MAX___7 = 4160,
    SFC_CALC_NORM_SIGNAL_MAX___7 = 4161,
    SFC_CALC_MAX_ALL_CHANNELS___7 = 4162,
    SFC_CALC_NORM_MAX_ALL_CHANNELS___7 = 4163,
    SFC_GET_SIGNAL_MAX___7 = 4164,
    SFC_GET_MAX_ALL_CHANNELS___7 = 4165,
    SFC_SET_ADD_PEAK_CHUNK___7 = 4176,
    SFC_SET_ADD_HEADER_PAD_CHUNK___7 = 4177,
    SFC_UPDATE_HEADER_NOW___7 = 4192,
    SFC_SET_UPDATE_HEADER_AUTO___7 = 4193,
    SFC_FILE_TRUNCATE___7 = 4224,
    SFC_SET_RAW_START_OFFSET___7 = 4240,
    SFC_SET_DITHER_ON_WRITE___7 = 4256,
    SFC_SET_DITHER_ON_READ___7 = 4257,
    SFC_GET_DITHER_INFO_COUNT___7 = 4258,
    SFC_GET_DITHER_INFO___7 = 4259,
    SFC_GET_EMBED_FILE_INFO___7 = 4272,
    SFC_SET_CLIPPING___7 = 4288,
    SFC_GET_CLIPPING___7 = 4289,
    SFC_GET_INSTRUMENT___7 = 4304,
    SFC_SET_INSTRUMENT___7 = 4305,
    SFC_GET_LOOP_INFO___7 = 4320,
    SFC_GET_BROADCAST_INFO___7 = 4336,
    SFC_SET_BROADCAST_INFO___7 = 4337,
    SFC_GET_CHANNEL_MAP_INFO___7 = 4352,
    SFC_SET_CHANNEL_MAP_INFO___7 = 4353,
    SFC_RAW_DATA_NEEDS_ENDSWAP___7 = 4368,
    SFC_WAVEX_SET_AMBISONIC___7 = 4608,
    SFC_WAVEX_GET_AMBISONIC___7 = 4609,
    SFC_SET_VBR_ENCODING_QUALITY___7 = 4864,
    SFC_TEST_IEEE_FLOAT_REPLACE___7 = 24577,
    SFC_SET_ADD_DITHER_ON_WRITE___7 = 4208,
    SFC_SET_ADD_DITHER_ON_READ___7 = 4209
} ;
#line 216
enum __anonenum__46___2 {
    SF_STR_TITLE___7 = 1,
    SF_STR_COPYRIGHT___7 = 2,
    SF_STR_SOFTWARE___7 = 3,
    SF_STR_ARTIST___7 = 4,
    SF_STR_COMMENT___7 = 5,
    SF_STR_DATE___7 = 6,
    SF_STR_ALBUM___7 = 7,
    SF_STR_LICENSE___7 = 8
} ;
#line 235
enum __anonenum__47___2 {
    SF_FALSE___7 = 0,
    SF_TRUE___7 = 1,
    SFM_READ___7 = 16,
    SFM_WRITE___7 = 32,
    SFM_RDWR___7 = 48,
    SF_AMBISONIC_NONE___7 = 64,
    SF_AMBISONIC_B_FORMAT___7 = 65
} ;
#line 255
enum __anonenum__48___2 {
    SF_ERR_NO_ERROR___7 = 0,
    SF_ERR_UNRECOGNISED_FORMAT___7 = 1,
    SF_ERR_SYSTEM___7 = 2,
    SF_ERR_MALFORMED_FILE___7 = 3,
    SF_ERR_UNSUPPORTED_ENCODING___7 = 4
} ;
#line 267
enum __anonenum__49___2 {
    SF_CHANNEL_MAP_INVALID___7 = 0,
    SF_CHANNEL_MAP_MONO___7 = 1,
    SF_CHANNEL_MAP_LEFT___7 = 2,
    SF_CHANNEL_MAP_RIGHT___7 = 3,
    SF_CHANNEL_MAP_CENTER___7 = 4,
    SF_CHANNEL_MAP_FRONT_LEFT___7 = 5,
    SF_CHANNEL_MAP_FRONT_RIGHT___7 = 6,
    SF_CHANNEL_MAP_FRONT_CENTER___7 = 7,
    SF_CHANNEL_MAP_REAR_CENTER___7 = 8,
    SF_CHANNEL_MAP_REAR_LEFT___7 = 9,
    SF_CHANNEL_MAP_REAR_RIGHT___7 = 10,
    SF_CHANNEL_MAP_LFE___7 = 11,
    SF_CHANNEL_MAP_FRONT_LEFT_OF_CENTER___7 = 12,
    SF_CHANNEL_MAP_FRONT_RIGHT_OF_CENTER___7 = 13,
    SF_CHANNEL_MAP_SIDE_LEFT___7 = 14,
    SF_CHANNEL_MAP_SIDE_RIGHT___7 = 15,
    SF_CHANNEL_MAP_TOP_CENTER___7 = 16,
    SF_CHANNEL_MAP_TOP_FRONT_LEFT___7 = 17,
    SF_CHANNEL_MAP_TOP_FRONT_RIGHT___7 = 18,
    SF_CHANNEL_MAP_TOP_FRONT_CENTER___7 = 19,
    SF_CHANNEL_MAP_TOP_REAR_LEFT___7 = 20,
    SF_CHANNEL_MAP_TOP_REAR_RIGHT___7 = 21,
    SF_CHANNEL_MAP_TOP_REAR_CENTER___7 = 22
} ;
#line 352
enum __anonenum__51___2 {
    SFD_DEFAULT_LEVEL___7 = 0,
    SFD_CUSTOM_LEVEL___7 = 1073741824,
    SFD_NO_DITHER___7 = 500,
    SFD_WHITE___7 = 501,
    SFD_TRIANGULAR_PDF___7 = 502
} ;
#line 380
enum __anonenum__54___2 {
    SF_LOOP_NONE___7 = 800,
    SF_LOOP_FORWARD___7 = 801,
    SF_LOOP_BACKWARD___7 = 802,
    SF_LOOP_ALTERNATING___7 = 803
} ;
#line 121 "/root/libsndfile/src/common.h"
enum __anonenum__59___2 {
    SF_PEAK_START___7 = 42,
    SF_PEAK_END___7 = 43,
    SF_SCALE_MAX___7 = 52,
    SF_SCALE_MIN___7 = 53,
    SF_STR_ALLOW_START___7 = 256,
    SF_STR_ALLOW_END___7 = 512,
    SF_STR_LOCATE_START___7 = 1024,
    SF_STR_LOCATE_END___7 = 2048,
    SFD_TYPEMASK___7 = 268435455
} ;
#line 149
enum __anonenum__60___2 {
    SF_FORMAT_TXW___7 = 67305472,
    SF_FORMAT_DWD___7 = 67371008,
    SF_FORMAT_REX___7 = 67764224,
    SF_FORMAT_REX2___7 = 67960832,
    SF_FORMAT_KRZ___7 = 68026368,
    SF_FORMAT_WMA___7 = 68157440,
    SF_FORMAT_SHN___7 = 68222976,
    SF_FORMAT_SVX_FIB___7 = 4128,
    SF_FORMAT_SVX_EXP___7 = 4129,
    SF_FORMAT_PCM_N___7 = 4144
} ;
#line 405
enum __anonenum__66___2 {
    SFE_NO_ERROR___7 = 0,
    SFE_BAD_OPEN_FORMAT___7 = 1,
    SFE_SYSTEM___7 = 2,
    SFE_MALFORMED_FILE___7 = 3,
    SFE_UNSUPPORTED_ENCODING___7 = 4,
    SFE_ZERO_MAJOR_FORMAT___7 = 5,
    SFE_ZERO_MINOR_FORMAT___7 = 6,
    SFE_BAD_FILE___7 = 7,
    SFE_BAD_FILE_READ___7 = 8,
    SFE_OPEN_FAILED___7 = 9,
    SFE_BAD_SNDFILE_PTR___7 = 10,
    SFE_BAD_SF_INFO_PTR___7 = 11,
    SFE_BAD_SF_INCOMPLETE___7 = 12,
    SFE_BAD_FILE_PTR___7 = 13,
    SFE_BAD_INT_PTR___7 = 14,
    SFE_BAD_STAT_SIZE___7 = 15,
    SFE_MALLOC_FAILED___7 = 16,
    SFE_UNIMPLEMENTED___7 = 17,
    SFE_BAD_READ_ALIGN___7 = 18,
    SFE_BAD_WRITE_ALIGN___7 = 19,
    SFE_UNKNOWN_FORMAT___7 = 20,
    SFE_NOT_READMODE___7 = 21,
    SFE_NOT_WRITEMODE___7 = 22,
    SFE_BAD_MODE_RW___7 = 23,
    SFE_BAD_SF_INFO___7 = 24,
    SFE_BAD_OFFSET___7 = 25,
    SFE_NO_EMBED_SUPPORT___7 = 26,
    SFE_NO_EMBEDDED_RDWR___7 = 27,
    SFE_NO_PIPE_WRITE___7 = 28,
    SFE_INTERNAL___7 = 29,
    SFE_BAD_COMMAND_PARAM___7 = 30,
    SFE_BAD_ENDIAN___7 = 31,
    SFE_CHANNEL_COUNT_ZERO___7 = 32,
    SFE_CHANNEL_COUNT___7 = 33,
    SFE_BAD_VIRTUAL_IO___7 = 34,
    SFE_INTERLEAVE_MODE___7 = 35,
    SFE_INTERLEAVE_SEEK___7 = 36,
    SFE_INTERLEAVE_READ___7 = 37,
    SFE_BAD_SEEK___7 = 38,
    SFE_NOT_SEEKABLE___7 = 39,
    SFE_AMBIGUOUS_SEEK___7 = 40,
    SFE_WRONG_SEEK___7 = 41,
    SFE_SEEK_FAILED___7 = 42,
    SFE_BAD_OPEN_MODE___7 = 43,
    SFE_OPEN_PIPE_RDWR___7 = 44,
    SFE_RDWR_POSITION___7 = 45,
    SFE_RDWR_BAD_HEADER___7 = 46,
    SFE_CMD_HAS_DATA___7 = 47,
    SFE_BAD_BROADCAST_INFO_SIZE___7 = 48,
    SFE_STR_NO_SUPPORT___7 = 49,
    SFE_STR_NOT_WRITE___7 = 50,
    SFE_STR_MAX_DATA___7 = 51,
    SFE_STR_MAX_COUNT___7 = 52,
    SFE_STR_BAD_TYPE___7 = 53,
    SFE_STR_NO_ADD_END___7 = 54,
    SFE_STR_BAD_STRING___7 = 55,
    SFE_STR_WEIRD___7 = 56,
    SFE_WAV_NO_RIFF___7 = 57,
    SFE_WAV_NO_WAVE___7 = 58,
    SFE_WAV_NO_FMT___7 = 59,
    SFE_WAV_BAD_FMT___7 = 60,
    SFE_WAV_FMT_SHORT___7 = 61,
    SFE_WAV_BAD_FACT___7 = 62,
    SFE_WAV_BAD_PEAK___7 = 63,
    SFE_WAV_PEAK_B4_FMT___7 = 64,
    SFE_WAV_BAD_FORMAT___7 = 65,
    SFE_WAV_BAD_BLOCKALIGN___7 = 66,
    SFE_WAV_NO_DATA___7 = 67,
    SFE_WAV_BAD_LIST___7 = 68,
    SFE_WAV_ADPCM_NOT4BIT___7 = 69,
    SFE_WAV_ADPCM_CHANNELS___7 = 70,
    SFE_WAV_GSM610_FORMAT___7 = 71,
    SFE_WAV_UNKNOWN_CHUNK___7 = 72,
    SFE_WAV_WVPK_DATA___7 = 73,
    SFE_AIFF_NO_FORM___7 = 74,
    SFE_AIFF_AIFF_NO_FORM___7 = 75,
    SFE_AIFF_COMM_NO_FORM___7 = 76,
    SFE_AIFF_SSND_NO_COMM___7 = 77,
    SFE_AIFF_UNKNOWN_CHUNK___7 = 78,
    SFE_AIFF_COMM_CHUNK_SIZE___7 = 79,
    SFE_AIFF_BAD_COMM_CHUNK___7 = 80,
    SFE_AIFF_PEAK_B4_COMM___7 = 81,
    SFE_AIFF_BAD_PEAK___7 = 82,
    SFE_AIFF_NO_SSND___7 = 83,
    SFE_AIFF_NO_DATA___7 = 84,
    SFE_AIFF_RW_SSND_NOT_LAST___7 = 85,
    SFE_AU_UNKNOWN_FORMAT___7 = 86,
    SFE_AU_NO_DOTSND___7 = 87,
    SFE_AU_EMBED_BAD_LEN___7 = 88,
    SFE_RAW_READ_BAD_SPEC___7 = 89,
    SFE_RAW_BAD_BITWIDTH___7 = 90,
    SFE_RAW_BAD_FORMAT___7 = 91,
    SFE_PAF_NO_MARKER___7 = 92,
    SFE_PAF_VERSION___7 = 93,
    SFE_PAF_UNKNOWN_FORMAT___7 = 94,
    SFE_PAF_SHORT_HEADER___7 = 95,
    SFE_SVX_NO_FORM___7 = 96,
    SFE_SVX_NO_BODY___7 = 97,
    SFE_SVX_NO_DATA___7 = 98,
    SFE_SVX_BAD_COMP___7 = 99,
    SFE_SVX_BAD_NAME_LENGTH___7 = 100,
    SFE_NIST_BAD_HEADER___7 = 101,
    SFE_NIST_CRLF_CONVERISON___7 = 102,
    SFE_NIST_BAD_ENCODING___7 = 103,
    SFE_VOC_NO_CREATIVE___7 = 104,
    SFE_VOC_BAD_FORMAT___7 = 105,
    SFE_VOC_BAD_VERSION___7 = 106,
    SFE_VOC_BAD_MARKER___7 = 107,
    SFE_VOC_BAD_SECTIONS___7 = 108,
    SFE_VOC_MULTI_SAMPLERATE___7 = 109,
    SFE_VOC_MULTI_SECTION___7 = 110,
    SFE_VOC_MULTI_PARAM___7 = 111,
    SFE_VOC_SECTION_COUNT___7 = 112,
    SFE_VOC_NO_PIPE___7 = 113,
    SFE_IRCAM_NO_MARKER___7 = 114,
    SFE_IRCAM_BAD_CHANNELS___7 = 115,
    SFE_IRCAM_UNKNOWN_FORMAT___7 = 116,
    SFE_W64_64_BIT___7 = 117,
    SFE_W64_NO_RIFF___7 = 118,
    SFE_W64_NO_WAVE___7 = 119,
    SFE_W64_NO_DATA___7 = 120,
    SFE_W64_ADPCM_NOT4BIT___7 = 121,
    SFE_W64_ADPCM_CHANNELS___7 = 122,
    SFE_W64_GSM610_FORMAT___7 = 123,
    SFE_MAT4_BAD_NAME___7 = 124,
    SFE_MAT4_NO_SAMPLERATE___7 = 125,
    SFE_MAT5_BAD_ENDIAN___7 = 126,
    SFE_MAT5_NO_BLOCK___7 = 127,
    SFE_MAT5_SAMPLE_RATE___7 = 128,
    SFE_PVF_NO_PVF1___7 = 129,
    SFE_PVF_BAD_HEADER___7 = 130,
    SFE_PVF_BAD_BITWIDTH___7 = 131,
    SFE_DWVW_BAD_BITWIDTH___7 = 132,
    SFE_G72X_NOT_MONO___7 = 133,
    SFE_XI_BAD_HEADER___7 = 134,
    SFE_XI_EXCESS_SAMPLES___7 = 135,
    SFE_XI_NO_PIPE___7 = 136,
    SFE_HTK_NO_PIPE___7 = 137,
    SFE_SDS_NOT_SDS___7 = 138,
    SFE_SDS_BAD_BIT_WIDTH___7 = 139,
    SFE_SD2_FD_DISALLOWED___7 = 140,
    SFE_SD2_BAD_DATA_OFFSET___7 = 141,
    SFE_SD2_BAD_MAP_OFFSET___7 = 142,
    SFE_SD2_BAD_DATA_LENGTH___7 = 143,
    SFE_SD2_BAD_MAP_LENGTH___7 = 144,
    SFE_SD2_BAD_RSRC___7 = 145,
    SFE_SD2_BAD_SAMPLE_SIZE___7 = 146,
    SFE_FLAC_BAD_HEADER___7 = 147,
    SFE_FLAC_NEW_DECODER___7 = 148,
    SFE_FLAC_INIT_DECODER___7 = 149,
    SFE_FLAC_LOST_SYNC___7 = 150,
    SFE_FLAC_BAD_SAMPLE_RATE___7 = 151,
    SFE_FLAC_UNKOWN_ERROR___7 = 152,
    SFE_WVE_NOT_WVE___7 = 153,
    SFE_WVE_NO_PIPE___7 = 154,
    SFE_VORBIS_ENCODER_BUG___7 = 155,
    SFE_RF64_NOT_RF64___7 = 156,
    SFE_MAX_ERROR___7 = 157
} ;
#line 823
enum __anonenum__70___2 {
    SFC_TEST_AIFF_ADD_INST_CHUNK___7 = 8192,
    SFC_TEST_WAV_ADD_INFO_CHUNK___7 = 8208
} ;
#line 29 "/root/libsndfile/src/wav_w64.h"
enum __anonstruct_71___0 {
    WAVE_FORMAT_UNKNOWN___0 = 0,
    WAVE_FORMAT_PCM___0 = 1,
    WAVE_FORMAT_MS_ADPCM___0 = 2,
    WAVE_FORMAT_IEEE_FLOAT___0 = 3,
    WAVE_FORMAT_VSELP___0 = 4,
    WAVE_FORMAT_IBM_CVSD___0 = 5,
    WAVE_FORMAT_ALAW___0 = 6,
    WAVE_FORMAT_MULAW___0 = 7,
    WAVE_FORMAT_OKI_ADPCM___0 = 16,
    WAVE_FORMAT_IMA_ADPCM___0 = 17,
    WAVE_FORMAT_MEDIASPACE_ADPCM___0 = 18,
    WAVE_FORMAT_SIERRA_ADPCM___0 = 19,
    WAVE_FORMAT_G723_ADPCM___0 = 20,
    WAVE_FORMAT_DIGISTD___0 = 21,
    WAVE_FORMAT_DIGIFIX___0 = 22,
    WAVE_FORMAT_DIALOGIC_OKI_ADPCM___0 = 23,
    WAVE_FORMAT_MEDIAVISION_ADPCM___0 = 24,
    WAVE_FORMAT_CU_CODEC___0 = 25,
    WAVE_FORMAT_YAMAHA_ADPCM___0 = 32,
    WAVE_FORMAT_SONARC___0 = 33,
    WAVE_FORMAT_DSPGROUP_TRUESPEECH___0 = 34,
    WAVE_FORMAT_ECHOSC1___0 = 35,
    WAVE_FORMAT_AUDIOFILE_AF36___0 = 36,
    WAVE_FORMAT_APTX___0 = 37,
    WAVE_FORMAT_AUDIOFILE_AF10___0 = 38,
    WAVE_FORMAT_PROSODY_1612___0 = 39,
    WAVE_FORMAT_LRC___0 = 40,
    WAVE_FORMAT_DOLBY_AC2___0 = 48,
    WAVE_FORMAT_GSM610___0 = 49,
    WAVE_FORMAT_MSNAUDIO___0 = 50,
    WAVE_FORMAT_ANTEX_ADPCME___0 = 51,
    WAVE_FORMAT_CONTROL_RES_VQLPC___0 = 52,
    WAVE_FORMAT_DIGIREAL___0 = 53,
    WAVE_FORMAT_DIGIADPCM___0 = 54,
    WAVE_FORMAT_CONTROL_RES_CR10___0 = 55,
    WAVE_FORMAT_NMS_VBXADPCM___0 = 56,
    WAVE_FORMAT_ROLAND_RDAC___0 = 57,
    WAVE_FORMAT_ECHOSC3___0 = 58,
    WAVE_FORMAT_ROCKWELL_ADPCM___0 = 59,
    WAVE_FORMAT_ROCKWELL_DIGITALK___0 = 60,
    WAVE_FORMAT_XEBEC___0 = 61,
    WAVE_FORMAT_G721_ADPCM___0 = 64,
    WAVE_FORMAT_G728_CELP___0 = 65,
    WAVE_FORMAT_MSG723___0 = 66,
    WAVE_FORMAT_MPEG___0 = 80,
    WAVE_FORMAT_RT24___0 = 82,
    WAVE_FORMAT_PAC___0 = 83,
    WAVE_FORMAT_MPEGLAYER3___0 = 85,
    WAVE_FORMAT_LUCENT_G723___0 = 89,
    WAVE_FORMAT_CIRRUS___0 = 96,
    WAVE_FORMAT_ESPCM___0 = 97,
    WAVE_FORMAT_VOXWARE___0 = 98,
    WAVE_FORMAT_CANOPUS_ATRAC___0 = 99,
    WAVE_FORMAT_G726_ADPCM___0 = 100,
    WAVE_FORMAT_G722_ADPCM___0 = 101,
    WAVE_FORMAT_DSAT___0 = 102,
    WAVE_FORMAT_DSAT_DISPLAY___0 = 103,
    WAVE_FORMAT_VOXWARE_BYTE_ALIGNED___0 = 105,
    WAVE_FORMAT_VOXWARE_AC8___0 = 112,
    WAVE_FORMAT_VOXWARE_AC10___0 = 113,
    WAVE_FORMAT_VOXWARE_AC16___0 = 114,
    WAVE_FORMAT_VOXWARE_AC20___0 = 115,
    WAVE_FORMAT_VOXWARE_RT24___0 = 116,
    WAVE_FORMAT_VOXWARE_RT29___0 = 117,
    WAVE_FORMAT_VOXWARE_RT29HW___0 = 118,
    WAVE_FORMAT_VOXWARE_VR12___0 = 119,
    WAVE_FORMAT_VOXWARE_VR18___0 = 120,
    WAVE_FORMAT_VOXWARE_TQ40___0 = 121,
    WAVE_FORMAT_SOFTSOUND___0 = 128,
    WAVE_FORMAT_VOXARE_TQ60___0 = 129,
    WAVE_FORMAT_MSRT24___0 = 130,
    WAVE_FORMAT_G729A___0 = 131,
    WAVE_FORMAT_MVI_MV12___0 = 132,
    WAVE_FORMAT_DF_G726___0 = 133,
    WAVE_FORMAT_DF_GSM610___0 = 134,
    WAVE_FORMAT_ONLIVE___0 = 137,
    WAVE_FORMAT_SBC24___0 = 145,
    WAVE_FORMAT_DOLBY_AC3_SPDIF___0 = 146,
    WAVE_FORMAT_ZYXEL_ADPCM___0 = 151,
    WAVE_FORMAT_PHILIPS_LPCBB___0 = 152,
    WAVE_FORMAT_PACKED___0 = 153,
    WAVE_FORMAT_RHETOREX_ADPCM___0 = 256,
    IBM_FORMAT_MULAW___0 = 257,
    IBM_FORMAT_ALAW___0 = 258,
    IBM_FORMAT_ADPCM___0 = 259,
    WAVE_FORMAT_VIVO_G723___0 = 273,
    WAVE_FORMAT_VIVO_SIREN___0 = 274,
    WAVE_FORMAT_DIGITAL_G723___0 = 291,
    WAVE_FORMAT_CREATIVE_ADPCM___0 = 512,
    WAVE_FORMAT_CREATIVE_FASTSPEECH8___0 = 514,
    WAVE_FORMAT_CREATIVE_FASTSPEECH10___0 = 515,
    WAVE_FORMAT_QUARTERDECK___0 = 544,
    WAVE_FORMAT_FM_TOWNS_SND___0 = 768,
    WAVE_FORMAT_BZV_DIGITAL___0 = 1024,
    WAVE_FORMAT_VME_VMPCM___0 = 1664,
    WAVE_FORMAT_OLIGSM___0 = 4096,
    WAVE_FORMAT_OLIADPCM___0 = 4097,
    WAVE_FORMAT_OLICELP___0 = 4098,
    WAVE_FORMAT_OLISBC___0 = 4099,
    WAVE_FORMAT_OLIOPR___0 = 4100,
    WAVE_FORMAT_LH_CODEC___0 = 4352,
    WAVE_FORMAT_NORRIS___0 = 5120,
    WAVE_FORMAT_SOUNDSPACE_MUSICOMPRESS___0 = 5376,
    WAVE_FORMAT_DVM___0 = 8192,
    WAVE_FORMAT_INTERWAV_VSC112___0 = 29008,
    WAVE_FORMAT_IPP_ITU_G_723_1___0 = 29232,
    WAVE_FORMAT_EXTENSIBLE___0 = 65534
} ;
#line 35 "/root/libsndfile/src/gsm610.c"
struct gsm610_tag {
   int blocks ;
   int blockcount ;
   int samplecount ;
   int samplesperblock ;
   int blocksize ;
   int (*decode_block)(SF_PRIVATE * , struct gsm610_tag * ) ;
   int (*encode_block)(SF_PRIVATE * , struct gsm610_tag * ) ;
   short samples[320] ;
   unsigned char block[65] ;
   gsm gsm_data ;
};
#line 48 "/root/libsndfile/src/gsm610.c"
typedef struct gsm610_tag GSM610_PRIVATE;
#line 853 "/usr/include/math.h"
enum __anonenum__43___3 {
    FP_NAN___6 = 0,
    FP_INFINITE___6 = 1,
    FP_ZERO___6 = 2,
    FP_SUBNORMAL___6 = 3,
    FP_NORMAL___6 = 4
} ;
#line 46 "/root/libsndfile/src/sndfile.h"
enum __anonenum__44___3 {
    SF_FORMAT_WAV___8 = 65536,
    SF_FORMAT_AIFF___8 = 131072,
    SF_FORMAT_AU___8 = 196608,
    SF_FORMAT_RAW___8 = 262144,
    SF_FORMAT_PAF___8 = 327680,
    SF_FORMAT_SVX___8 = 393216,
    SF_FORMAT_NIST___8 = 458752,
    SF_FORMAT_VOC___8 = 524288,
    SF_FORMAT_IRCAM___8 = 655360,
    SF_FORMAT_W64___8 = 720896,
    SF_FORMAT_MAT4___8 = 786432,
    SF_FORMAT_MAT5___8 = 851968,
    SF_FORMAT_PVF___8 = 917504,
    SF_FORMAT_XI___8 = 983040,
    SF_FORMAT_HTK___8 = 1048576,
    SF_FORMAT_SDS___8 = 1114112,
    SF_FORMAT_AVR___8 = 1179648,
    SF_FORMAT_WAVEX___8 = 1245184,
    SF_FORMAT_SD2___8 = 1441792,
    SF_FORMAT_FLAC___8 = 1507328,
    SF_FORMAT_CAF___8 = 1572864,
    SF_FORMAT_WVE___8 = 1638400,
    SF_FORMAT_OGG___8 = 2097152,
    SF_FORMAT_MPC2K___8 = 2162688,
    SF_FORMAT_RF64___8 = 2228224,
    SF_FORMAT_PCM_S8___8 = 1,
    SF_FORMAT_PCM_16___8 = 2,
    SF_FORMAT_PCM_24___8 = 3,
    SF_FORMAT_PCM_32___8 = 4,
    SF_FORMAT_PCM_U8___8 = 5,
    SF_FORMAT_FLOAT___8 = 6,
    SF_FORMAT_DOUBLE___8 = 7,
    SF_FORMAT_ULAW___8 = 16,
    SF_FORMAT_ALAW___8 = 17,
    SF_FORMAT_IMA_ADPCM___8 = 18,
    SF_FORMAT_MS_ADPCM___8 = 19,
    SF_FORMAT_GSM610___8 = 32,
    SF_FORMAT_VOX_ADPCM___8 = 33,
    SF_FORMAT_G721_32___8 = 48,
    SF_FORMAT_G723_24___8 = 49,
    SF_FORMAT_G723_40___8 = 50,
    SF_FORMAT_DWVW_12___8 = 64,
    SF_FORMAT_DWVW_16___8 = 65,
    SF_FORMAT_DWVW_24___8 = 66,
    SF_FORMAT_DWVW_N___8 = 67,
    SF_FORMAT_DPCM_8___8 = 80,
    SF_FORMAT_DPCM_16___8 = 81,
    SF_FORMAT_VORBIS___8 = 96,
    SF_ENDIAN_FILE___8 = 0,
    SF_ENDIAN_LITTLE___8 = 268435456,
    SF_ENDIAN_BIG___8 = 536870912,
    SF_ENDIAN_CPU___8 = 805306368,
    SF_FORMAT_SUBMASK___8 = 65535,
    SF_FORMAT_TYPEMASK___8 = 268369920,
    SF_FORMAT_ENDMASK___8 = 805306368
} ;
#line 126
enum __anonenum__45___3 {
    SFC_GET_LIB_VERSION___8 = 4096,
    SFC_GET_LOG_INFO___8 = 4097,
    SFC_GET_CURRENT_SF_INFO___8 = 4098,
    SFC_GET_NORM_DOUBLE___8 = 4112,
    SFC_GET_NORM_FLOAT___8 = 4113,
    SFC_SET_NORM_DOUBLE___8 = 4114,
    SFC_SET_NORM_FLOAT___8 = 4115,
    SFC_SET_SCALE_FLOAT_INT_READ___8 = 4116,
    SFC_SET_SCALE_INT_FLOAT_WRITE___8 = 4117,
    SFC_GET_SIMPLE_FORMAT_COUNT___8 = 4128,
    SFC_GET_SIMPLE_FORMAT___8 = 4129,
    SFC_GET_FORMAT_INFO___8 = 4136,
    SFC_GET_FORMAT_MAJOR_COUNT___8 = 4144,
    SFC_GET_FORMAT_MAJOR___8 = 4145,
    SFC_GET_FORMAT_SUBTYPE_COUNT___8 = 4146,
    SFC_GET_FORMAT_SUBTYPE___8 = 4147,
    SFC_CALC_SIGNAL_MAX___8 = 4160,
    SFC_CALC_NORM_SIGNAL_MAX___8 = 4161,
    SFC_CALC_MAX_ALL_CHANNELS___8 = 4162,
    SFC_CALC_NORM_MAX_ALL_CHANNELS___8 = 4163,
    SFC_GET_SIGNAL_MAX___8 = 4164,
    SFC_GET_MAX_ALL_CHANNELS___8 = 4165,
    SFC_SET_ADD_PEAK_CHUNK___8 = 4176,
    SFC_SET_ADD_HEADER_PAD_CHUNK___8 = 4177,
    SFC_UPDATE_HEADER_NOW___8 = 4192,
    SFC_SET_UPDATE_HEADER_AUTO___8 = 4193,
    SFC_FILE_TRUNCATE___8 = 4224,
    SFC_SET_RAW_START_OFFSET___8 = 4240,
    SFC_SET_DITHER_ON_WRITE___8 = 4256,
    SFC_SET_DITHER_ON_READ___8 = 4257,
    SFC_GET_DITHER_INFO_COUNT___8 = 4258,
    SFC_GET_DITHER_INFO___8 = 4259,
    SFC_GET_EMBED_FILE_INFO___8 = 4272,
    SFC_SET_CLIPPING___8 = 4288,
    SFC_GET_CLIPPING___8 = 4289,
    SFC_GET_INSTRUMENT___8 = 4304,
    SFC_SET_INSTRUMENT___8 = 4305,
    SFC_GET_LOOP_INFO___8 = 4320,
    SFC_GET_BROADCAST_INFO___8 = 4336,
    SFC_SET_BROADCAST_INFO___8 = 4337,
    SFC_GET_CHANNEL_MAP_INFO___8 = 4352,
    SFC_SET_CHANNEL_MAP_INFO___8 = 4353,
    SFC_RAW_DATA_NEEDS_ENDSWAP___8 = 4368,
    SFC_WAVEX_SET_AMBISONIC___8 = 4608,
    SFC_WAVEX_GET_AMBISONIC___8 = 4609,
    SFC_SET_VBR_ENCODING_QUALITY___8 = 4864,
    SFC_TEST_IEEE_FLOAT_REPLACE___8 = 24577,
    SFC_SET_ADD_DITHER_ON_WRITE___8 = 4208,
    SFC_SET_ADD_DITHER_ON_READ___8 = 4209
} ;
#line 216
enum __anonenum__46___3 {
    SF_STR_TITLE___8 = 1,
    SF_STR_COPYRIGHT___8 = 2,
    SF_STR_SOFTWARE___8 = 3,
    SF_STR_ARTIST___8 = 4,
    SF_STR_COMMENT___8 = 5,
    SF_STR_DATE___8 = 6,
    SF_STR_ALBUM___8 = 7,
    SF_STR_LICENSE___8 = 8
} ;
#line 235
enum __anonenum__47___3 {
    SF_FALSE___8 = 0,
    SF_TRUE___8 = 1,
    SFM_READ___8 = 16,
    SFM_WRITE___8 = 32,
    SFM_RDWR___8 = 48,
    SF_AMBISONIC_NONE___8 = 64,
    SF_AMBISONIC_B_FORMAT___8 = 65
} ;
#line 255
enum __anonenum__48___3 {
    SF_ERR_NO_ERROR___8 = 0,
    SF_ERR_UNRECOGNISED_FORMAT___8 = 1,
    SF_ERR_SYSTEM___8 = 2,
    SF_ERR_MALFORMED_FILE___8 = 3,
    SF_ERR_UNSUPPORTED_ENCODING___8 = 4
} ;
#line 267
enum __anonenum__49___3 {
    SF_CHANNEL_MAP_INVALID___8 = 0,
    SF_CHANNEL_MAP_MONO___8 = 1,
    SF_CHANNEL_MAP_LEFT___8 = 2,
    SF_CHANNEL_MAP_RIGHT___8 = 3,
    SF_CHANNEL_MAP_CENTER___8 = 4,
    SF_CHANNEL_MAP_FRONT_LEFT___8 = 5,
    SF_CHANNEL_MAP_FRONT_RIGHT___8 = 6,
    SF_CHANNEL_MAP_FRONT_CENTER___8 = 7,
    SF_CHANNEL_MAP_REAR_CENTER___8 = 8,
    SF_CHANNEL_MAP_REAR_LEFT___8 = 9,
    SF_CHANNEL_MAP_REAR_RIGHT___8 = 10,
    SF_CHANNEL_MAP_LFE___8 = 11,
    SF_CHANNEL_MAP_FRONT_LEFT_OF_CENTER___8 = 12,
    SF_CHANNEL_MAP_FRONT_RIGHT_OF_CENTER___8 = 13,
    SF_CHANNEL_MAP_SIDE_LEFT___8 = 14,
    SF_CHANNEL_MAP_SIDE_RIGHT___8 = 15,
    SF_CHANNEL_MAP_TOP_CENTER___8 = 16,
    SF_CHANNEL_MAP_TOP_FRONT_LEFT___8 = 17,
    SF_CHANNEL_MAP_TOP_FRONT_RIGHT___8 = 18,
    SF_CHANNEL_MAP_TOP_FRONT_CENTER___8 = 19,
    SF_CHANNEL_MAP_TOP_REAR_LEFT___8 = 20,
    SF_CHANNEL_MAP_TOP_REAR_RIGHT___8 = 21,
    SF_CHANNEL_MAP_TOP_REAR_CENTER___8 = 22
} ;
#line 352
enum __anonenum__51___3 {
    SFD_DEFAULT_LEVEL___8 = 0,
    SFD_CUSTOM_LEVEL___8 = 1073741824,
    SFD_NO_DITHER___8 = 500,
    SFD_WHITE___8 = 501,
    SFD_TRIANGULAR_PDF___8 = 502
} ;
#line 380
enum __anonenum__54___3 {
    SF_LOOP_NONE___8 = 800,
    SF_LOOP_FORWARD___8 = 801,
    SF_LOOP_BACKWARD___8 = 802,
    SF_LOOP_ALTERNATING___8 = 803
} ;
#line 121 "/root/libsndfile/src/common.h"
enum __anonenum__59___3 {
    SF_PEAK_START___8 = 42,
    SF_PEAK_END___8 = 43,
    SF_SCALE_MAX___8 = 52,
    SF_SCALE_MIN___8 = 53,
    SF_STR_ALLOW_START___8 = 256,
    SF_STR_ALLOW_END___8 = 512,
    SF_STR_LOCATE_START___8 = 1024,
    SF_STR_LOCATE_END___8 = 2048,
    SFD_TYPEMASK___8 = 268435455
} ;
#line 149
enum __anonenum__60___3 {
    SF_FORMAT_TXW___8 = 67305472,
    SF_FORMAT_DWD___8 = 67371008,
    SF_FORMAT_REX___8 = 67764224,
    SF_FORMAT_REX2___8 = 67960832,
    SF_FORMAT_KRZ___8 = 68026368,
    SF_FORMAT_WMA___8 = 68157440,
    SF_FORMAT_SHN___8 = 68222976,
    SF_FORMAT_SVX_FIB___8 = 4128,
    SF_FORMAT_SVX_EXP___8 = 4129,
    SF_FORMAT_PCM_N___8 = 4144
} ;
#line 405
enum __anonenum__66___3 {
    SFE_NO_ERROR___8 = 0,
    SFE_BAD_OPEN_FORMAT___8 = 1,
    SFE_SYSTEM___8 = 2,
    SFE_MALFORMED_FILE___8 = 3,
    SFE_UNSUPPORTED_ENCODING___8 = 4,
    SFE_ZERO_MAJOR_FORMAT___8 = 5,
    SFE_ZERO_MINOR_FORMAT___8 = 6,
    SFE_BAD_FILE___8 = 7,
    SFE_BAD_FILE_READ___8 = 8,
    SFE_OPEN_FAILED___8 = 9,
    SFE_BAD_SNDFILE_PTR___8 = 10,
    SFE_BAD_SF_INFO_PTR___8 = 11,
    SFE_BAD_SF_INCOMPLETE___8 = 12,
    SFE_BAD_FILE_PTR___8 = 13,
    SFE_BAD_INT_PTR___8 = 14,
    SFE_BAD_STAT_SIZE___8 = 15,
    SFE_MALLOC_FAILED___8 = 16,
    SFE_UNIMPLEMENTED___8 = 17,
    SFE_BAD_READ_ALIGN___8 = 18,
    SFE_BAD_WRITE_ALIGN___8 = 19,
    SFE_UNKNOWN_FORMAT___8 = 20,
    SFE_NOT_READMODE___8 = 21,
    SFE_NOT_WRITEMODE___8 = 22,
    SFE_BAD_MODE_RW___8 = 23,
    SFE_BAD_SF_INFO___8 = 24,
    SFE_BAD_OFFSET___8 = 25,
    SFE_NO_EMBED_SUPPORT___8 = 26,
    SFE_NO_EMBEDDED_RDWR___8 = 27,
    SFE_NO_PIPE_WRITE___8 = 28,
    SFE_INTERNAL___8 = 29,
    SFE_BAD_COMMAND_PARAM___8 = 30,
    SFE_BAD_ENDIAN___8 = 31,
    SFE_CHANNEL_COUNT_ZERO___8 = 32,
    SFE_CHANNEL_COUNT___8 = 33,
    SFE_BAD_VIRTUAL_IO___8 = 34,
    SFE_INTERLEAVE_MODE___8 = 35,
    SFE_INTERLEAVE_SEEK___8 = 36,
    SFE_INTERLEAVE_READ___8 = 37,
    SFE_BAD_SEEK___8 = 38,
    SFE_NOT_SEEKABLE___8 = 39,
    SFE_AMBIGUOUS_SEEK___8 = 40,
    SFE_WRONG_SEEK___8 = 41,
    SFE_SEEK_FAILED___8 = 42,
    SFE_BAD_OPEN_MODE___8 = 43,
    SFE_OPEN_PIPE_RDWR___8 = 44,
    SFE_RDWR_POSITION___8 = 45,
    SFE_RDWR_BAD_HEADER___8 = 46,
    SFE_CMD_HAS_DATA___8 = 47,
    SFE_BAD_BROADCAST_INFO_SIZE___8 = 48,
    SFE_STR_NO_SUPPORT___8 = 49,
    SFE_STR_NOT_WRITE___8 = 50,
    SFE_STR_MAX_DATA___8 = 51,
    SFE_STR_MAX_COUNT___8 = 52,
    SFE_STR_BAD_TYPE___8 = 53,
    SFE_STR_NO_ADD_END___8 = 54,
    SFE_STR_BAD_STRING___8 = 55,
    SFE_STR_WEIRD___8 = 56,
    SFE_WAV_NO_RIFF___8 = 57,
    SFE_WAV_NO_WAVE___8 = 58,
    SFE_WAV_NO_FMT___8 = 59,
    SFE_WAV_BAD_FMT___8 = 60,
    SFE_WAV_FMT_SHORT___8 = 61,
    SFE_WAV_BAD_FACT___8 = 62,
    SFE_WAV_BAD_PEAK___8 = 63,
    SFE_WAV_PEAK_B4_FMT___8 = 64,
    SFE_WAV_BAD_FORMAT___8 = 65,
    SFE_WAV_BAD_BLOCKALIGN___8 = 66,
    SFE_WAV_NO_DATA___8 = 67,
    SFE_WAV_BAD_LIST___8 = 68,
    SFE_WAV_ADPCM_NOT4BIT___8 = 69,
    SFE_WAV_ADPCM_CHANNELS___8 = 70,
    SFE_WAV_GSM610_FORMAT___8 = 71,
    SFE_WAV_UNKNOWN_CHUNK___8 = 72,
    SFE_WAV_WVPK_DATA___8 = 73,
    SFE_AIFF_NO_FORM___8 = 74,
    SFE_AIFF_AIFF_NO_FORM___8 = 75,
    SFE_AIFF_COMM_NO_FORM___8 = 76,
    SFE_AIFF_SSND_NO_COMM___8 = 77,
    SFE_AIFF_UNKNOWN_CHUNK___8 = 78,
    SFE_AIFF_COMM_CHUNK_SIZE___8 = 79,
    SFE_AIFF_BAD_COMM_CHUNK___8 = 80,
    SFE_AIFF_PEAK_B4_COMM___8 = 81,
    SFE_AIFF_BAD_PEAK___8 = 82,
    SFE_AIFF_NO_SSND___8 = 83,
    SFE_AIFF_NO_DATA___8 = 84,
    SFE_AIFF_RW_SSND_NOT_LAST___8 = 85,
    SFE_AU_UNKNOWN_FORMAT___8 = 86,
    SFE_AU_NO_DOTSND___8 = 87,
    SFE_AU_EMBED_BAD_LEN___8 = 88,
    SFE_RAW_READ_BAD_SPEC___8 = 89,
    SFE_RAW_BAD_BITWIDTH___8 = 90,
    SFE_RAW_BAD_FORMAT___8 = 91,
    SFE_PAF_NO_MARKER___8 = 92,
    SFE_PAF_VERSION___8 = 93,
    SFE_PAF_UNKNOWN_FORMAT___8 = 94,
    SFE_PAF_SHORT_HEADER___8 = 95,
    SFE_SVX_NO_FORM___8 = 96,
    SFE_SVX_NO_BODY___8 = 97,
    SFE_SVX_NO_DATA___8 = 98,
    SFE_SVX_BAD_COMP___8 = 99,
    SFE_SVX_BAD_NAME_LENGTH___8 = 100,
    SFE_NIST_BAD_HEADER___8 = 101,
    SFE_NIST_CRLF_CONVERISON___8 = 102,
    SFE_NIST_BAD_ENCODING___8 = 103,
    SFE_VOC_NO_CREATIVE___8 = 104,
    SFE_VOC_BAD_FORMAT___8 = 105,
    SFE_VOC_BAD_VERSION___8 = 106,
    SFE_VOC_BAD_MARKER___8 = 107,
    SFE_VOC_BAD_SECTIONS___8 = 108,
    SFE_VOC_MULTI_SAMPLERATE___8 = 109,
    SFE_VOC_MULTI_SECTION___8 = 110,
    SFE_VOC_MULTI_PARAM___8 = 111,
    SFE_VOC_SECTION_COUNT___8 = 112,
    SFE_VOC_NO_PIPE___8 = 113,
    SFE_IRCAM_NO_MARKER___8 = 114,
    SFE_IRCAM_BAD_CHANNELS___8 = 115,
    SFE_IRCAM_UNKNOWN_FORMAT___8 = 116,
    SFE_W64_64_BIT___8 = 117,
    SFE_W64_NO_RIFF___8 = 118,
    SFE_W64_NO_WAVE___8 = 119,
    SFE_W64_NO_DATA___8 = 120,
    SFE_W64_ADPCM_NOT4BIT___8 = 121,
    SFE_W64_ADPCM_CHANNELS___8 = 122,
    SFE_W64_GSM610_FORMAT___8 = 123,
    SFE_MAT4_BAD_NAME___8 = 124,
    SFE_MAT4_NO_SAMPLERATE___8 = 125,
    SFE_MAT5_BAD_ENDIAN___8 = 126,
    SFE_MAT5_NO_BLOCK___8 = 127,
    SFE_MAT5_SAMPLE_RATE___8 = 128,
    SFE_PVF_NO_PVF1___8 = 129,
    SFE_PVF_BAD_HEADER___8 = 130,
    SFE_PVF_BAD_BITWIDTH___8 = 131,
    SFE_DWVW_BAD_BITWIDTH___8 = 132,
    SFE_G72X_NOT_MONO___8 = 133,
    SFE_XI_BAD_HEADER___8 = 134,
    SFE_XI_EXCESS_SAMPLES___8 = 135,
    SFE_XI_NO_PIPE___8 = 136,
    SFE_HTK_NO_PIPE___8 = 137,
    SFE_SDS_NOT_SDS___8 = 138,
    SFE_SDS_BAD_BIT_WIDTH___8 = 139,
    SFE_SD2_FD_DISALLOWED___8 = 140,
    SFE_SD2_BAD_DATA_OFFSET___8 = 141,
    SFE_SD2_BAD_MAP_OFFSET___8 = 142,
    SFE_SD2_BAD_DATA_LENGTH___8 = 143,
    SFE_SD2_BAD_MAP_LENGTH___8 = 144,
    SFE_SD2_BAD_RSRC___8 = 145,
    SFE_SD2_BAD_SAMPLE_SIZE___8 = 146,
    SFE_FLAC_BAD_HEADER___8 = 147,
    SFE_FLAC_NEW_DECODER___8 = 148,
    SFE_FLAC_INIT_DECODER___8 = 149,
    SFE_FLAC_LOST_SYNC___8 = 150,
    SFE_FLAC_BAD_SAMPLE_RATE___8 = 151,
    SFE_FLAC_UNKOWN_ERROR___8 = 152,
    SFE_WVE_NOT_WVE___8 = 153,
    SFE_WVE_NO_PIPE___8 = 154,
    SFE_VORBIS_ENCODER_BUG___8 = 155,
    SFE_RF64_NOT_RF64___8 = 156,
    SFE_MAX_ERROR___8 = 157
} ;
#line 823
enum __anonenum__70___3 {
    SFC_TEST_AIFF_ADD_INST_CHUNK___8 = 8192,
    SFC_TEST_WAV_ADD_INFO_CHUNK___8 = 8208
} ;
#line 44 "/root/libsndfile/src/float32.c"
enum __anonstruct_71___1 {
    FLOAT_UNKNOWN = 0,
    FLOAT_CAN_RW_LE = 18,
    FLOAT_CAN_RW_BE = 35,
    FLOAT_BROKEN_LE = 52,
    FLOAT_BROKEN_BE = 69
} ;
#line 405 "/root/libsndfile/src/float32.c"
union __anonunion_296 {
   float f ;
   int i ;
   unsigned char c[4] ;
};
#line 255 "/usr/include/unistd.h"
typedef __useconds_t useconds_t;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__297 {
    _PC_LINK_MAX = 0,
    _PC_MAX_CANON = 1,
    _PC_MAX_INPUT = 2,
    _PC_NAME_MAX = 3,
    _PC_PATH_MAX = 4,
    _PC_PIPE_BUF = 5,
    _PC_CHOWN_RESTRICTED = 6,
    _PC_NO_TRUNC = 7,
    _PC_VDISABLE = 8,
    _PC_SYNC_IO = 9,
    _PC_ASYNC_IO = 10,
    _PC_PRIO_IO = 11,
    _PC_SOCK_MAXBUF = 12,
    _PC_FILESIZEBITS = 13,
    _PC_REC_INCR_XFER_SIZE = 14,
    _PC_REC_MAX_XFER_SIZE = 15,
    _PC_REC_MIN_XFER_SIZE = 16,
    _PC_REC_XFER_ALIGN = 17,
    _PC_ALLOC_SIZE_MIN = 18,
    _PC_SYMLINK_MAX = 19,
    _PC_2_SYMLINKS = 20
} ;
#line 71
enum __anonenum__298 {
    _SC_ARG_MAX = 0,
    _SC_CHILD_MAX = 1,
    _SC_CLK_TCK = 2,
    _SC_NGROUPS_MAX = 3,
    _SC_OPEN_MAX = 4,
    _SC_STREAM_MAX = 5,
    _SC_TZNAME_MAX = 6,
    _SC_JOB_CONTROL = 7,
    _SC_SAVED_IDS = 8,
    _SC_REALTIME_SIGNALS = 9,
    _SC_PRIORITY_SCHEDULING = 10,
    _SC_TIMERS = 11,
    _SC_ASYNCHRONOUS_IO = 12,
    _SC_PRIORITIZED_IO = 13,
    _SC_SYNCHRONIZED_IO = 14,
    _SC_FSYNC = 15,
    _SC_MAPPED_FILES = 16,
    _SC_MEMLOCK = 17,
    _SC_MEMLOCK_RANGE = 18,
    _SC_MEMORY_PROTECTION = 19,
    _SC_MESSAGE_PASSING = 20,
    _SC_SEMAPHORES = 21,
    _SC_SHARED_MEMORY_OBJECTS = 22,
    _SC_AIO_LISTIO_MAX = 23,
    _SC_AIO_MAX = 24,
    _SC_AIO_PRIO_DELTA_MAX = 25,
    _SC_DELAYTIMER_MAX = 26,
    _SC_MQ_OPEN_MAX = 27,
    _SC_MQ_PRIO_MAX = 28,
    _SC_VERSION = 29,
    _SC_PAGESIZE = 30,
    _SC_RTSIG_MAX = 31,
    _SC_SEM_NSEMS_MAX = 32,
    _SC_SEM_VALUE_MAX = 33,
    _SC_SIGQUEUE_MAX = 34,
    _SC_TIMER_MAX = 35,
    _SC_BC_BASE_MAX = 36,
    _SC_BC_DIM_MAX = 37,
    _SC_BC_SCALE_MAX = 38,
    _SC_BC_STRING_MAX = 39,
    _SC_COLL_WEIGHTS_MAX = 40,
    _SC_EQUIV_CLASS_MAX = 41,
    _SC_EXPR_NEST_MAX = 42,
    _SC_LINE_MAX = 43,
    _SC_RE_DUP_MAX = 44,
    _SC_CHARCLASS_NAME_MAX = 45,
    _SC_2_VERSION = 46,
    _SC_2_C_BIND = 47,
    _SC_2_C_DEV = 48,
    _SC_2_FORT_DEV = 49,
    _SC_2_FORT_RUN = 50,
    _SC_2_SW_DEV = 51,
    _SC_2_LOCALEDEF = 52,
    _SC_PII = 53,
    _SC_PII_XTI = 54,
    _SC_PII_SOCKET = 55,
    _SC_PII_INTERNET = 56,
    _SC_PII_OSI = 57,
    _SC_POLL = 58,
    _SC_SELECT = 59,
    _SC_UIO_MAXIOV = 60,
    _SC_IOV_MAX = 60,
    _SC_PII_INTERNET_STREAM = 61,
    _SC_PII_INTERNET_DGRAM = 62,
    _SC_PII_OSI_COTS = 63,
    _SC_PII_OSI_CLTS = 64,
    _SC_PII_OSI_M = 65,
    _SC_T_IOV_MAX = 66,
    _SC_THREADS = 67,
    _SC_THREAD_SAFE_FUNCTIONS = 68,
    _SC_GETGR_R_SIZE_MAX = 69,
    _SC_GETPW_R_SIZE_MAX = 70,
    _SC_LOGIN_NAME_MAX = 71,
    _SC_TTY_NAME_MAX = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS = 73,
    _SC_THREAD_KEYS_MAX = 74,
    _SC_THREAD_STACK_MIN = 75,
    _SC_THREAD_THREADS_MAX = 76,
    _SC_THREAD_ATTR_STACKADDR = 77,
    _SC_THREAD_ATTR_STACKSIZE = 78,
    _SC_THREAD_PRIORITY_SCHEDULING = 79,
    _SC_THREAD_PRIO_INHERIT = 80,
    _SC_THREAD_PRIO_PROTECT = 81,
    _SC_THREAD_PROCESS_SHARED = 82,
    _SC_NPROCESSORS_CONF = 83,
    _SC_NPROCESSORS_ONLN = 84,
    _SC_PHYS_PAGES = 85,
    _SC_AVPHYS_PAGES = 86,
    _SC_ATEXIT_MAX = 87,
    _SC_PASS_MAX = 88,
    _SC_XOPEN_VERSION = 89,
    _SC_XOPEN_XCU_VERSION = 90,
    _SC_XOPEN_UNIX = 91,
    _SC_XOPEN_CRYPT = 92,
    _SC_XOPEN_ENH_I18N = 93,
    _SC_XOPEN_SHM = 94,
    _SC_2_CHAR_TERM = 95,
    _SC_2_C_VERSION = 96,
    _SC_2_UPE = 97,
    _SC_XOPEN_XPG2 = 98,
    _SC_XOPEN_XPG3 = 99,
    _SC_XOPEN_XPG4 = 100,
    _SC_CHAR_BIT = 101,
    _SC_CHAR_MAX = 102,
    _SC_CHAR_MIN = 103,
    _SC_INT_MAX = 104,
    _SC_INT_MIN = 105,
    _SC_LONG_BIT = 106,
    _SC_WORD_BIT = 107,
    _SC_MB_LEN_MAX = 108,
    _SC_NZERO = 109,
    _SC_SSIZE_MAX = 110,
    _SC_SCHAR_MAX = 111,
    _SC_SCHAR_MIN = 112,
    _SC_SHRT_MAX = 113,
    _SC_SHRT_MIN = 114,
    _SC_UCHAR_MAX = 115,
    _SC_UINT_MAX = 116,
    _SC_ULONG_MAX = 117,
    _SC_USHRT_MAX = 118,
    _SC_NL_ARGMAX = 119,
    _SC_NL_LANGMAX = 120,
    _SC_NL_MSGMAX = 121,
    _SC_NL_NMAX = 122,
    _SC_NL_SETMAX = 123,
    _SC_NL_TEXTMAX = 124,
    _SC_XBS5_ILP32_OFF32 = 125,
    _SC_XBS5_ILP32_OFFBIG = 126,
    _SC_XBS5_LP64_OFF64 = 127,
    _SC_XBS5_LPBIG_OFFBIG = 128,
    _SC_XOPEN_LEGACY = 129,
    _SC_XOPEN_REALTIME = 130,
    _SC_XOPEN_REALTIME_THREADS = 131,
    _SC_ADVISORY_INFO = 132,
    _SC_BARRIERS = 133,
    _SC_BASE = 134,
    _SC_C_LANG_SUPPORT = 135,
    _SC_C_LANG_SUPPORT_R = 136,
    _SC_CLOCK_SELECTION = 137,
    _SC_CPUTIME = 138,
    _SC_THREAD_CPUTIME = 139,
    _SC_DEVICE_IO = 140,
    _SC_DEVICE_SPECIFIC = 141,
    _SC_DEVICE_SPECIFIC_R = 142,
    _SC_FD_MGMT = 143,
    _SC_FIFO = 144,
    _SC_PIPE = 145,
    _SC_FILE_ATTRIBUTES = 146,
    _SC_FILE_LOCKING = 147,
    _SC_FILE_SYSTEM = 148,
    _SC_MONOTONIC_CLOCK = 149,
    _SC_MULTI_PROCESS = 150,
    _SC_SINGLE_PROCESS = 151,
    _SC_NETWORKING = 152,
    _SC_READER_WRITER_LOCKS = 153,
    _SC_SPIN_LOCKS = 154,
    _SC_REGEXP = 155,
    _SC_REGEX_VERSION = 156,
    _SC_SHELL = 157,
    _SC_SIGNALS = 158,
    _SC_SPAWN = 159,
    _SC_SPORADIC_SERVER = 160,
    _SC_THREAD_SPORADIC_SERVER = 161,
    _SC_SYSTEM_DATABASE = 162,
    _SC_SYSTEM_DATABASE_R = 163,
    _SC_TIMEOUTS = 164,
    _SC_TYPED_MEMORY_OBJECTS = 165,
    _SC_USER_GROUPS = 166,
    _SC_USER_GROUPS_R = 167,
    _SC_2_PBS = 168,
    _SC_2_PBS_ACCOUNTING = 169,
    _SC_2_PBS_LOCATE = 170,
    _SC_2_PBS_MESSAGE = 171,
    _SC_2_PBS_TRACK = 172,
    _SC_SYMLOOP_MAX = 173,
    _SC_STREAMS = 174,
    _SC_2_PBS_CHECKPOINT = 175,
    _SC_V6_ILP32_OFF32 = 176,
    _SC_V6_ILP32_OFFBIG = 177,
    _SC_V6_LP64_OFF64 = 178,
    _SC_V6_LPBIG_OFFBIG = 179,
    _SC_HOST_NAME_MAX = 180,
    _SC_TRACE = 181,
    _SC_TRACE_EVENT_FILTER = 182,
    _SC_TRACE_INHERIT = 183,
    _SC_TRACE_LOG = 184,
    _SC_LEVEL1_ICACHE_SIZE = 185,
    _SC_LEVEL1_ICACHE_ASSOC = 186,
    _SC_LEVEL1_ICACHE_LINESIZE = 187,
    _SC_LEVEL1_DCACHE_SIZE = 188,
    _SC_LEVEL1_DCACHE_ASSOC = 189,
    _SC_LEVEL1_DCACHE_LINESIZE = 190,
    _SC_LEVEL2_CACHE_SIZE = 191,
    _SC_LEVEL2_CACHE_ASSOC = 192,
    _SC_LEVEL2_CACHE_LINESIZE = 193,
    _SC_LEVEL3_CACHE_SIZE = 194,
    _SC_LEVEL3_CACHE_ASSOC = 195,
    _SC_LEVEL3_CACHE_LINESIZE = 196,
    _SC_LEVEL4_CACHE_SIZE = 197,
    _SC_LEVEL4_CACHE_ASSOC = 198,
    _SC_LEVEL4_CACHE_LINESIZE = 199,
    _SC_IPV6 = 235,
    _SC_RAW_SOCKETS = 236,
    _SC_V7_ILP32_OFF32 = 237,
    _SC_V7_ILP32_OFFBIG = 238,
    _SC_V7_LP64_OFF64 = 239,
    _SC_V7_LPBIG_OFFBIG = 240,
    _SC_SS_REPL_MAX = 241,
    _SC_TRACE_EVENT_NAME_MAX = 242,
    _SC_TRACE_NAME_MAX = 243,
    _SC_TRACE_SYS_MAX = 244,
    _SC_TRACE_USER_EVENT_MAX = 245,
    _SC_XOPEN_STREAMS = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT = 248
} ;
#line 533
enum __anonenum__299 {
    _CS_PATH = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS = 1,
    _CS_GNU_LIBC_VERSION = 2,
    _CS_GNU_LIBPTHREAD_VERSION = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS = 5,
    _CS_LFS_CFLAGS = 1000,
    _CS_LFS_LDFLAGS = 1001,
    _CS_LFS_LIBS = 1002,
    _CS_LFS_LINTFLAGS = 1003,
    _CS_LFS64_CFLAGS = 1004,
    _CS_LFS64_LDFLAGS = 1005,
    _CS_LFS64_LIBS = 1006,
    _CS_LFS64_LINTFLAGS = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS = 1109,
    _CS_XBS5_LP64_OFF64_LIBS = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS = 1147,
    _CS_V6_ENV = 1148,
    _CS_V7_ENV = 1149
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/fcntl.h"
struct flock {
   short l_type ;
   short l_whence ;
   __off_t l_start ;
   __off_t l_len ;
   __pid_t l_pid ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 46 "/root/libsndfile/src/sndfile.h"
enum __anonenum__300 {
    SF_FORMAT_WAV___9 = 65536,
    SF_FORMAT_AIFF___9 = 131072,
    SF_FORMAT_AU___9 = 196608,
    SF_FORMAT_RAW___9 = 262144,
    SF_FORMAT_PAF___9 = 327680,
    SF_FORMAT_SVX___9 = 393216,
    SF_FORMAT_NIST___9 = 458752,
    SF_FORMAT_VOC___9 = 524288,
    SF_FORMAT_IRCAM___9 = 655360,
    SF_FORMAT_W64___9 = 720896,
    SF_FORMAT_MAT4___9 = 786432,
    SF_FORMAT_MAT5___9 = 851968,
    SF_FORMAT_PVF___9 = 917504,
    SF_FORMAT_XI___9 = 983040,
    SF_FORMAT_HTK___9 = 1048576,
    SF_FORMAT_SDS___9 = 1114112,
    SF_FORMAT_AVR___9 = 1179648,
    SF_FORMAT_WAVEX___9 = 1245184,
    SF_FORMAT_SD2___9 = 1441792,
    SF_FORMAT_FLAC___9 = 1507328,
    SF_FORMAT_CAF___9 = 1572864,
    SF_FORMAT_WVE___9 = 1638400,
    SF_FORMAT_OGG___9 = 2097152,
    SF_FORMAT_MPC2K___9 = 2162688,
    SF_FORMAT_RF64___9 = 2228224,
    SF_FORMAT_PCM_S8___9 = 1,
    SF_FORMAT_PCM_16___9 = 2,
    SF_FORMAT_PCM_24___9 = 3,
    SF_FORMAT_PCM_32___9 = 4,
    SF_FORMAT_PCM_U8___9 = 5,
    SF_FORMAT_FLOAT___9 = 6,
    SF_FORMAT_DOUBLE___9 = 7,
    SF_FORMAT_ULAW___9 = 16,
    SF_FORMAT_ALAW___9 = 17,
    SF_FORMAT_IMA_ADPCM___9 = 18,
    SF_FORMAT_MS_ADPCM___9 = 19,
    SF_FORMAT_GSM610___9 = 32,
    SF_FORMAT_VOX_ADPCM___9 = 33,
    SF_FORMAT_G721_32___9 = 48,
    SF_FORMAT_G723_24___9 = 49,
    SF_FORMAT_G723_40___9 = 50,
    SF_FORMAT_DWVW_12___9 = 64,
    SF_FORMAT_DWVW_16___9 = 65,
    SF_FORMAT_DWVW_24___9 = 66,
    SF_FORMAT_DWVW_N___9 = 67,
    SF_FORMAT_DPCM_8___9 = 80,
    SF_FORMAT_DPCM_16___9 = 81,
    SF_FORMAT_VORBIS___9 = 96,
    SF_ENDIAN_FILE___9 = 0,
    SF_ENDIAN_LITTLE___9 = 268435456,
    SF_ENDIAN_BIG___9 = 536870912,
    SF_ENDIAN_CPU___9 = 805306368,
    SF_FORMAT_SUBMASK___9 = 65535,
    SF_FORMAT_TYPEMASK___9 = 268369920,
    SF_FORMAT_ENDMASK___9 = 805306368
} ;
#line 126
enum __anonenum__301 {
    SFC_GET_LIB_VERSION___9 = 4096,
    SFC_GET_LOG_INFO___9 = 4097,
    SFC_GET_CURRENT_SF_INFO___9 = 4098,
    SFC_GET_NORM_DOUBLE___9 = 4112,
    SFC_GET_NORM_FLOAT___9 = 4113,
    SFC_SET_NORM_DOUBLE___9 = 4114,
    SFC_SET_NORM_FLOAT___9 = 4115,
    SFC_SET_SCALE_FLOAT_INT_READ___9 = 4116,
    SFC_SET_SCALE_INT_FLOAT_WRITE___9 = 4117,
    SFC_GET_SIMPLE_FORMAT_COUNT___9 = 4128,
    SFC_GET_SIMPLE_FORMAT___9 = 4129,
    SFC_GET_FORMAT_INFO___9 = 4136,
    SFC_GET_FORMAT_MAJOR_COUNT___9 = 4144,
    SFC_GET_FORMAT_MAJOR___9 = 4145,
    SFC_GET_FORMAT_SUBTYPE_COUNT___9 = 4146,
    SFC_GET_FORMAT_SUBTYPE___9 = 4147,
    SFC_CALC_SIGNAL_MAX___9 = 4160,
    SFC_CALC_NORM_SIGNAL_MAX___9 = 4161,
    SFC_CALC_MAX_ALL_CHANNELS___9 = 4162,
    SFC_CALC_NORM_MAX_ALL_CHANNELS___9 = 4163,
    SFC_GET_SIGNAL_MAX___9 = 4164,
    SFC_GET_MAX_ALL_CHANNELS___9 = 4165,
    SFC_SET_ADD_PEAK_CHUNK___9 = 4176,
    SFC_SET_ADD_HEADER_PAD_CHUNK___9 = 4177,
    SFC_UPDATE_HEADER_NOW___9 = 4192,
    SFC_SET_UPDATE_HEADER_AUTO___9 = 4193,
    SFC_FILE_TRUNCATE___9 = 4224,
    SFC_SET_RAW_START_OFFSET___9 = 4240,
    SFC_SET_DITHER_ON_WRITE___9 = 4256,
    SFC_SET_DITHER_ON_READ___9 = 4257,
    SFC_GET_DITHER_INFO_COUNT___9 = 4258,
    SFC_GET_DITHER_INFO___9 = 4259,
    SFC_GET_EMBED_FILE_INFO___9 = 4272,
    SFC_SET_CLIPPING___9 = 4288,
    SFC_GET_CLIPPING___9 = 4289,
    SFC_GET_INSTRUMENT___9 = 4304,
    SFC_SET_INSTRUMENT___9 = 4305,
    SFC_GET_LOOP_INFO___9 = 4320,
    SFC_GET_BROADCAST_INFO___9 = 4336,
    SFC_SET_BROADCAST_INFO___9 = 4337,
    SFC_GET_CHANNEL_MAP_INFO___9 = 4352,
    SFC_SET_CHANNEL_MAP_INFO___9 = 4353,
    SFC_RAW_DATA_NEEDS_ENDSWAP___9 = 4368,
    SFC_WAVEX_SET_AMBISONIC___9 = 4608,
    SFC_WAVEX_GET_AMBISONIC___9 = 4609,
    SFC_SET_VBR_ENCODING_QUALITY___9 = 4864,
    SFC_TEST_IEEE_FLOAT_REPLACE___9 = 24577,
    SFC_SET_ADD_DITHER_ON_WRITE___9 = 4208,
    SFC_SET_ADD_DITHER_ON_READ___9 = 4209
} ;
#line 216
enum __anonenum__302 {
    SF_STR_TITLE___9 = 1,
    SF_STR_COPYRIGHT___9 = 2,
    SF_STR_SOFTWARE___9 = 3,
    SF_STR_ARTIST___9 = 4,
    SF_STR_COMMENT___9 = 5,
    SF_STR_DATE___9 = 6,
    SF_STR_ALBUM___9 = 7,
    SF_STR_LICENSE___9 = 8
} ;
#line 235
enum __anonenum__303 {
    SF_FALSE___9 = 0,
    SF_TRUE___9 = 1,
    SFM_READ___9 = 16,
    SFM_WRITE___9 = 32,
    SFM_RDWR___9 = 48,
    SF_AMBISONIC_NONE___9 = 64,
    SF_AMBISONIC_B_FORMAT___9 = 65
} ;
#line 255
enum __anonenum__304 {
    SF_ERR_NO_ERROR___9 = 0,
    SF_ERR_UNRECOGNISED_FORMAT___9 = 1,
    SF_ERR_SYSTEM___9 = 2,
    SF_ERR_MALFORMED_FILE___9 = 3,
    SF_ERR_UNSUPPORTED_ENCODING___9 = 4
} ;
#line 267
enum __anonenum__305 {
    SF_CHANNEL_MAP_INVALID___9 = 0,
    SF_CHANNEL_MAP_MONO___9 = 1,
    SF_CHANNEL_MAP_LEFT___9 = 2,
    SF_CHANNEL_MAP_RIGHT___9 = 3,
    SF_CHANNEL_MAP_CENTER___9 = 4,
    SF_CHANNEL_MAP_FRONT_LEFT___9 = 5,
    SF_CHANNEL_MAP_FRONT_RIGHT___9 = 6,
    SF_CHANNEL_MAP_FRONT_CENTER___9 = 7,
    SF_CHANNEL_MAP_REAR_CENTER___9 = 8,
    SF_CHANNEL_MAP_REAR_LEFT___9 = 9,
    SF_CHANNEL_MAP_REAR_RIGHT___9 = 10,
    SF_CHANNEL_MAP_LFE___9 = 11,
    SF_CHANNEL_MAP_FRONT_LEFT_OF_CENTER___9 = 12,
    SF_CHANNEL_MAP_FRONT_RIGHT_OF_CENTER___9 = 13,
    SF_CHANNEL_MAP_SIDE_LEFT___9 = 14,
    SF_CHANNEL_MAP_SIDE_RIGHT___9 = 15,
    SF_CHANNEL_MAP_TOP_CENTER___9 = 16,
    SF_CHANNEL_MAP_TOP_FRONT_LEFT___9 = 17,
    SF_CHANNEL_MAP_TOP_FRONT_RIGHT___9 = 18,
    SF_CHANNEL_MAP_TOP_FRONT_CENTER___9 = 19,
    SF_CHANNEL_MAP_TOP_REAR_LEFT___9 = 20,
    SF_CHANNEL_MAP_TOP_REAR_RIGHT___9 = 21,
    SF_CHANNEL_MAP_TOP_REAR_CENTER___9 = 22
} ;
#line 352
enum __anonenum__307 {
    SFD_DEFAULT_LEVEL___9 = 0,
    SFD_CUSTOM_LEVEL___9 = 1073741824,
    SFD_NO_DITHER___9 = 500,
    SFD_WHITE___9 = 501,
    SFD_TRIANGULAR_PDF___9 = 502
} ;
#line 380
enum __anonenum__310 {
    SF_LOOP_NONE___9 = 800,
    SF_LOOP_FORWARD___9 = 801,
    SF_LOOP_BACKWARD___9 = 802,
    SF_LOOP_ALTERNATING___9 = 803
} ;
#line 121 "/root/libsndfile/src/common.h"
enum __anonenum__315 {
    SF_PEAK_START___9 = 42,
    SF_PEAK_END___9 = 43,
    SF_SCALE_MAX___9 = 52,
    SF_SCALE_MIN___9 = 53,
    SF_STR_ALLOW_START___9 = 256,
    SF_STR_ALLOW_END___9 = 512,
    SF_STR_LOCATE_START___9 = 1024,
    SF_STR_LOCATE_END___9 = 2048,
    SFD_TYPEMASK___9 = 268435455
} ;
#line 149
enum __anonenum__316 {
    SF_FORMAT_TXW___9 = 67305472,
    SF_FORMAT_DWD___9 = 67371008,
    SF_FORMAT_REX___9 = 67764224,
    SF_FORMAT_REX2___9 = 67960832,
    SF_FORMAT_KRZ___9 = 68026368,
    SF_FORMAT_WMA___9 = 68157440,
    SF_FORMAT_SHN___9 = 68222976,
    SF_FORMAT_SVX_FIB___9 = 4128,
    SF_FORMAT_SVX_EXP___9 = 4129,
    SF_FORMAT_PCM_N___9 = 4144
} ;
#line 405
enum __anonenum__322 {
    SFE_NO_ERROR___9 = 0,
    SFE_BAD_OPEN_FORMAT___9 = 1,
    SFE_SYSTEM___9 = 2,
    SFE_MALFORMED_FILE___9 = 3,
    SFE_UNSUPPORTED_ENCODING___9 = 4,
    SFE_ZERO_MAJOR_FORMAT___9 = 5,
    SFE_ZERO_MINOR_FORMAT___9 = 6,
    SFE_BAD_FILE___9 = 7,
    SFE_BAD_FILE_READ___9 = 8,
    SFE_OPEN_FAILED___9 = 9,
    SFE_BAD_SNDFILE_PTR___9 = 10,
    SFE_BAD_SF_INFO_PTR___9 = 11,
    SFE_BAD_SF_INCOMPLETE___9 = 12,
    SFE_BAD_FILE_PTR___9 = 13,
    SFE_BAD_INT_PTR___9 = 14,
    SFE_BAD_STAT_SIZE___9 = 15,
    SFE_MALLOC_FAILED___9 = 16,
    SFE_UNIMPLEMENTED___9 = 17,
    SFE_BAD_READ_ALIGN___9 = 18,
    SFE_BAD_WRITE_ALIGN___9 = 19,
    SFE_UNKNOWN_FORMAT___9 = 20,
    SFE_NOT_READMODE___9 = 21,
    SFE_NOT_WRITEMODE___9 = 22,
    SFE_BAD_MODE_RW___9 = 23,
    SFE_BAD_SF_INFO___9 = 24,
    SFE_BAD_OFFSET___9 = 25,
    SFE_NO_EMBED_SUPPORT___9 = 26,
    SFE_NO_EMBEDDED_RDWR___9 = 27,
    SFE_NO_PIPE_WRITE___9 = 28,
    SFE_INTERNAL___9 = 29,
    SFE_BAD_COMMAND_PARAM___9 = 30,
    SFE_BAD_ENDIAN___9 = 31,
    SFE_CHANNEL_COUNT_ZERO___9 = 32,
    SFE_CHANNEL_COUNT___9 = 33,
    SFE_BAD_VIRTUAL_IO___9 = 34,
    SFE_INTERLEAVE_MODE___9 = 35,
    SFE_INTERLEAVE_SEEK___9 = 36,
    SFE_INTERLEAVE_READ___9 = 37,
    SFE_BAD_SEEK___9 = 38,
    SFE_NOT_SEEKABLE___9 = 39,
    SFE_AMBIGUOUS_SEEK___9 = 40,
    SFE_WRONG_SEEK___9 = 41,
    SFE_SEEK_FAILED___9 = 42,
    SFE_BAD_OPEN_MODE___9 = 43,
    SFE_OPEN_PIPE_RDWR___9 = 44,
    SFE_RDWR_POSITION___9 = 45,
    SFE_RDWR_BAD_HEADER___9 = 46,
    SFE_CMD_HAS_DATA___9 = 47,
    SFE_BAD_BROADCAST_INFO_SIZE___9 = 48,
    SFE_STR_NO_SUPPORT___9 = 49,
    SFE_STR_NOT_WRITE___9 = 50,
    SFE_STR_MAX_DATA___9 = 51,
    SFE_STR_MAX_COUNT___9 = 52,
    SFE_STR_BAD_TYPE___9 = 53,
    SFE_STR_NO_ADD_END___9 = 54,
    SFE_STR_BAD_STRING___9 = 55,
    SFE_STR_WEIRD___9 = 56,
    SFE_WAV_NO_RIFF___9 = 57,
    SFE_WAV_NO_WAVE___9 = 58,
    SFE_WAV_NO_FMT___9 = 59,
    SFE_WAV_BAD_FMT___9 = 60,
    SFE_WAV_FMT_SHORT___9 = 61,
    SFE_WAV_BAD_FACT___9 = 62,
    SFE_WAV_BAD_PEAK___9 = 63,
    SFE_WAV_PEAK_B4_FMT___9 = 64,
    SFE_WAV_BAD_FORMAT___9 = 65,
    SFE_WAV_BAD_BLOCKALIGN___9 = 66,
    SFE_WAV_NO_DATA___9 = 67,
    SFE_WAV_BAD_LIST___9 = 68,
    SFE_WAV_ADPCM_NOT4BIT___9 = 69,
    SFE_WAV_ADPCM_CHANNELS___9 = 70,
    SFE_WAV_GSM610_FORMAT___9 = 71,
    SFE_WAV_UNKNOWN_CHUNK___9 = 72,
    SFE_WAV_WVPK_DATA___9 = 73,
    SFE_AIFF_NO_FORM___9 = 74,
    SFE_AIFF_AIFF_NO_FORM___9 = 75,
    SFE_AIFF_COMM_NO_FORM___9 = 76,
    SFE_AIFF_SSND_NO_COMM___9 = 77,
    SFE_AIFF_UNKNOWN_CHUNK___9 = 78,
    SFE_AIFF_COMM_CHUNK_SIZE___9 = 79,
    SFE_AIFF_BAD_COMM_CHUNK___9 = 80,
    SFE_AIFF_PEAK_B4_COMM___9 = 81,
    SFE_AIFF_BAD_PEAK___9 = 82,
    SFE_AIFF_NO_SSND___9 = 83,
    SFE_AIFF_NO_DATA___9 = 84,
    SFE_AIFF_RW_SSND_NOT_LAST___9 = 85,
    SFE_AU_UNKNOWN_FORMAT___9 = 86,
    SFE_AU_NO_DOTSND___9 = 87,
    SFE_AU_EMBED_BAD_LEN___9 = 88,
    SFE_RAW_READ_BAD_SPEC___9 = 89,
    SFE_RAW_BAD_BITWIDTH___9 = 90,
    SFE_RAW_BAD_FORMAT___9 = 91,
    SFE_PAF_NO_MARKER___9 = 92,
    SFE_PAF_VERSION___9 = 93,
    SFE_PAF_UNKNOWN_FORMAT___9 = 94,
    SFE_PAF_SHORT_HEADER___9 = 95,
    SFE_SVX_NO_FORM___9 = 96,
    SFE_SVX_NO_BODY___9 = 97,
    SFE_SVX_NO_DATA___9 = 98,
    SFE_SVX_BAD_COMP___9 = 99,
    SFE_SVX_BAD_NAME_LENGTH___9 = 100,
    SFE_NIST_BAD_HEADER___9 = 101,
    SFE_NIST_CRLF_CONVERISON___9 = 102,
    SFE_NIST_BAD_ENCODING___9 = 103,
    SFE_VOC_NO_CREATIVE___9 = 104,
    SFE_VOC_BAD_FORMAT___9 = 105,
    SFE_VOC_BAD_VERSION___9 = 106,
    SFE_VOC_BAD_MARKER___9 = 107,
    SFE_VOC_BAD_SECTIONS___9 = 108,
    SFE_VOC_MULTI_SAMPLERATE___9 = 109,
    SFE_VOC_MULTI_SECTION___9 = 110,
    SFE_VOC_MULTI_PARAM___9 = 111,
    SFE_VOC_SECTION_COUNT___9 = 112,
    SFE_VOC_NO_PIPE___9 = 113,
    SFE_IRCAM_NO_MARKER___9 = 114,
    SFE_IRCAM_BAD_CHANNELS___9 = 115,
    SFE_IRCAM_UNKNOWN_FORMAT___9 = 116,
    SFE_W64_64_BIT___9 = 117,
    SFE_W64_NO_RIFF___9 = 118,
    SFE_W64_NO_WAVE___9 = 119,
    SFE_W64_NO_DATA___9 = 120,
    SFE_W64_ADPCM_NOT4BIT___9 = 121,
    SFE_W64_ADPCM_CHANNELS___9 = 122,
    SFE_W64_GSM610_FORMAT___9 = 123,
    SFE_MAT4_BAD_NAME___9 = 124,
    SFE_MAT4_NO_SAMPLERATE___9 = 125,
    SFE_MAT5_BAD_ENDIAN___9 = 126,
    SFE_MAT5_NO_BLOCK___9 = 127,
    SFE_MAT5_SAMPLE_RATE___9 = 128,
    SFE_PVF_NO_PVF1___9 = 129,
    SFE_PVF_BAD_HEADER___9 = 130,
    SFE_PVF_BAD_BITWIDTH___9 = 131,
    SFE_DWVW_BAD_BITWIDTH___9 = 132,
    SFE_G72X_NOT_MONO___9 = 133,
    SFE_XI_BAD_HEADER___9 = 134,
    SFE_XI_EXCESS_SAMPLES___9 = 135,
    SFE_XI_NO_PIPE___9 = 136,
    SFE_HTK_NO_PIPE___9 = 137,
    SFE_SDS_NOT_SDS___9 = 138,
    SFE_SDS_BAD_BIT_WIDTH___9 = 139,
    SFE_SD2_FD_DISALLOWED___9 = 140,
    SFE_SD2_BAD_DATA_OFFSET___9 = 141,
    SFE_SD2_BAD_MAP_OFFSET___9 = 142,
    SFE_SD2_BAD_DATA_LENGTH___9 = 143,
    SFE_SD2_BAD_MAP_LENGTH___9 = 144,
    SFE_SD2_BAD_RSRC___9 = 145,
    SFE_SD2_BAD_SAMPLE_SIZE___9 = 146,
    SFE_FLAC_BAD_HEADER___9 = 147,
    SFE_FLAC_NEW_DECODER___9 = 148,
    SFE_FLAC_INIT_DECODER___9 = 149,
    SFE_FLAC_LOST_SYNC___9 = 150,
    SFE_FLAC_BAD_SAMPLE_RATE___9 = 151,
    SFE_FLAC_UNKOWN_ERROR___9 = 152,
    SFE_WVE_NOT_WVE___9 = 153,
    SFE_WVE_NO_PIPE___9 = 154,
    SFE_VORBIS_ENCODER_BUG___9 = 155,
    SFE_RF64_NOT_RF64___9 = 156,
    SFE_MAX_ERROR___9 = 157
} ;
#line 823
enum __anonenum__326 {
    SFC_TEST_AIFF_ADD_INST_CHUNK___9 = 8192,
    SFC_TEST_WAV_ADD_INFO_CHUNK___9 = 8208
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__43___4 {
    FP_NAN___7 = 0,
    FP_INFINITE___7 = 1,
    FP_ZERO___7 = 2,
    FP_SUBNORMAL___7 = 3,
    FP_NORMAL___7 = 4
} ;
#line 46 "/root/libsndfile/src/sndfile.h"
enum __anonenum__44___4 {
    SF_FORMAT_WAV___10 = 65536,
    SF_FORMAT_AIFF___10 = 131072,
    SF_FORMAT_AU___10 = 196608,
    SF_FORMAT_RAW___10 = 262144,
    SF_FORMAT_PAF___10 = 327680,
    SF_FORMAT_SVX___10 = 393216,
    SF_FORMAT_NIST___10 = 458752,
    SF_FORMAT_VOC___10 = 524288,
    SF_FORMAT_IRCAM___10 = 655360,
    SF_FORMAT_W64___10 = 720896,
    SF_FORMAT_MAT4___10 = 786432,
    SF_FORMAT_MAT5___10 = 851968,
    SF_FORMAT_PVF___10 = 917504,
    SF_FORMAT_XI___10 = 983040,
    SF_FORMAT_HTK___10 = 1048576,
    SF_FORMAT_SDS___10 = 1114112,
    SF_FORMAT_AVR___10 = 1179648,
    SF_FORMAT_WAVEX___10 = 1245184,
    SF_FORMAT_SD2___10 = 1441792,
    SF_FORMAT_FLAC___10 = 1507328,
    SF_FORMAT_CAF___10 = 1572864,
    SF_FORMAT_WVE___10 = 1638400,
    SF_FORMAT_OGG___10 = 2097152,
    SF_FORMAT_MPC2K___10 = 2162688,
    SF_FORMAT_RF64___10 = 2228224,
    SF_FORMAT_PCM_S8___10 = 1,
    SF_FORMAT_PCM_16___10 = 2,
    SF_FORMAT_PCM_24___10 = 3,
    SF_FORMAT_PCM_32___10 = 4,
    SF_FORMAT_PCM_U8___10 = 5,
    SF_FORMAT_FLOAT___10 = 6,
    SF_FORMAT_DOUBLE___10 = 7,
    SF_FORMAT_ULAW___10 = 16,
    SF_FORMAT_ALAW___10 = 17,
    SF_FORMAT_IMA_ADPCM___10 = 18,
    SF_FORMAT_MS_ADPCM___10 = 19,
    SF_FORMAT_GSM610___10 = 32,
    SF_FORMAT_VOX_ADPCM___10 = 33,
    SF_FORMAT_G721_32___10 = 48,
    SF_FORMAT_G723_24___10 = 49,
    SF_FORMAT_G723_40___10 = 50,
    SF_FORMAT_DWVW_12___10 = 64,
    SF_FORMAT_DWVW_16___10 = 65,
    SF_FORMAT_DWVW_24___10 = 66,
    SF_FORMAT_DWVW_N___10 = 67,
    SF_FORMAT_DPCM_8___10 = 80,
    SF_FORMAT_DPCM_16___10 = 81,
    SF_FORMAT_VORBIS___10 = 96,
    SF_ENDIAN_FILE___10 = 0,
    SF_ENDIAN_LITTLE___10 = 268435456,
    SF_ENDIAN_BIG___10 = 536870912,
    SF_ENDIAN_CPU___10 = 805306368,
    SF_FORMAT_SUBMASK___10 = 65535,
    SF_FORMAT_TYPEMASK___10 = 268369920,
    SF_FORMAT_ENDMASK___10 = 805306368
} ;
#line 126
enum __anonenum__45___4 {
    SFC_GET_LIB_VERSION___10 = 4096,
    SFC_GET_LOG_INFO___10 = 4097,
    SFC_GET_CURRENT_SF_INFO___10 = 4098,
    SFC_GET_NORM_DOUBLE___10 = 4112,
    SFC_GET_NORM_FLOAT___10 = 4113,
    SFC_SET_NORM_DOUBLE___10 = 4114,
    SFC_SET_NORM_FLOAT___10 = 4115,
    SFC_SET_SCALE_FLOAT_INT_READ___10 = 4116,
    SFC_SET_SCALE_INT_FLOAT_WRITE___10 = 4117,
    SFC_GET_SIMPLE_FORMAT_COUNT___10 = 4128,
    SFC_GET_SIMPLE_FORMAT___10 = 4129,
    SFC_GET_FORMAT_INFO___10 = 4136,
    SFC_GET_FORMAT_MAJOR_COUNT___10 = 4144,
    SFC_GET_FORMAT_MAJOR___10 = 4145,
    SFC_GET_FORMAT_SUBTYPE_COUNT___10 = 4146,
    SFC_GET_FORMAT_SUBTYPE___10 = 4147,
    SFC_CALC_SIGNAL_MAX___10 = 4160,
    SFC_CALC_NORM_SIGNAL_MAX___10 = 4161,
    SFC_CALC_MAX_ALL_CHANNELS___10 = 4162,
    SFC_CALC_NORM_MAX_ALL_CHANNELS___10 = 4163,
    SFC_GET_SIGNAL_MAX___10 = 4164,
    SFC_GET_MAX_ALL_CHANNELS___10 = 4165,
    SFC_SET_ADD_PEAK_CHUNK___10 = 4176,
    SFC_SET_ADD_HEADER_PAD_CHUNK___10 = 4177,
    SFC_UPDATE_HEADER_NOW___10 = 4192,
    SFC_SET_UPDATE_HEADER_AUTO___10 = 4193,
    SFC_FILE_TRUNCATE___10 = 4224,
    SFC_SET_RAW_START_OFFSET___10 = 4240,
    SFC_SET_DITHER_ON_WRITE___10 = 4256,
    SFC_SET_DITHER_ON_READ___10 = 4257,
    SFC_GET_DITHER_INFO_COUNT___10 = 4258,
    SFC_GET_DITHER_INFO___10 = 4259,
    SFC_GET_EMBED_FILE_INFO___10 = 4272,
    SFC_SET_CLIPPING___10 = 4288,
    SFC_GET_CLIPPING___10 = 4289,
    SFC_GET_INSTRUMENT___10 = 4304,
    SFC_SET_INSTRUMENT___10 = 4305,
    SFC_GET_LOOP_INFO___10 = 4320,
    SFC_GET_BROADCAST_INFO___10 = 4336,
    SFC_SET_BROADCAST_INFO___10 = 4337,
    SFC_GET_CHANNEL_MAP_INFO___10 = 4352,
    SFC_SET_CHANNEL_MAP_INFO___10 = 4353,
    SFC_RAW_DATA_NEEDS_ENDSWAP___10 = 4368,
    SFC_WAVEX_SET_AMBISONIC___10 = 4608,
    SFC_WAVEX_GET_AMBISONIC___10 = 4609,
    SFC_SET_VBR_ENCODING_QUALITY___10 = 4864,
    SFC_TEST_IEEE_FLOAT_REPLACE___10 = 24577,
    SFC_SET_ADD_DITHER_ON_WRITE___10 = 4208,
    SFC_SET_ADD_DITHER_ON_READ___10 = 4209
} ;
#line 216
enum __anonenum__46___4 {
    SF_STR_TITLE___10 = 1,
    SF_STR_COPYRIGHT___10 = 2,
    SF_STR_SOFTWARE___10 = 3,
    SF_STR_ARTIST___10 = 4,
    SF_STR_COMMENT___10 = 5,
    SF_STR_DATE___10 = 6,
    SF_STR_ALBUM___10 = 7,
    SF_STR_LICENSE___10 = 8
} ;
#line 235
enum __anonenum__47___4 {
    SF_FALSE___10 = 0,
    SF_TRUE___10 = 1,
    SFM_READ___10 = 16,
    SFM_WRITE___10 = 32,
    SFM_RDWR___10 = 48,
    SF_AMBISONIC_NONE___10 = 64,
    SF_AMBISONIC_B_FORMAT___10 = 65
} ;
#line 255
enum __anonenum__48___4 {
    SF_ERR_NO_ERROR___10 = 0,
    SF_ERR_UNRECOGNISED_FORMAT___10 = 1,
    SF_ERR_SYSTEM___10 = 2,
    SF_ERR_MALFORMED_FILE___10 = 3,
    SF_ERR_UNSUPPORTED_ENCODING___10 = 4
} ;
#line 267
enum __anonenum__49___4 {
    SF_CHANNEL_MAP_INVALID___10 = 0,
    SF_CHANNEL_MAP_MONO___10 = 1,
    SF_CHANNEL_MAP_LEFT___10 = 2,
    SF_CHANNEL_MAP_RIGHT___10 = 3,
    SF_CHANNEL_MAP_CENTER___10 = 4,
    SF_CHANNEL_MAP_FRONT_LEFT___10 = 5,
    SF_CHANNEL_MAP_FRONT_RIGHT___10 = 6,
    SF_CHANNEL_MAP_FRONT_CENTER___10 = 7,
    SF_CHANNEL_MAP_REAR_CENTER___10 = 8,
    SF_CHANNEL_MAP_REAR_LEFT___10 = 9,
    SF_CHANNEL_MAP_REAR_RIGHT___10 = 10,
    SF_CHANNEL_MAP_LFE___10 = 11,
    SF_CHANNEL_MAP_FRONT_LEFT_OF_CENTER___10 = 12,
    SF_CHANNEL_MAP_FRONT_RIGHT_OF_CENTER___10 = 13,
    SF_CHANNEL_MAP_SIDE_LEFT___10 = 14,
    SF_CHANNEL_MAP_SIDE_RIGHT___10 = 15,
    SF_CHANNEL_MAP_TOP_CENTER___10 = 16,
    SF_CHANNEL_MAP_TOP_FRONT_LEFT___10 = 17,
    SF_CHANNEL_MAP_TOP_FRONT_RIGHT___10 = 18,
    SF_CHANNEL_MAP_TOP_FRONT_CENTER___10 = 19,
    SF_CHANNEL_MAP_TOP_REAR_LEFT___10 = 20,
    SF_CHANNEL_MAP_TOP_REAR_RIGHT___10 = 21,
    SF_CHANNEL_MAP_TOP_REAR_CENTER___10 = 22
} ;
#line 352
enum __anonenum__51___4 {
    SFD_DEFAULT_LEVEL___10 = 0,
    SFD_CUSTOM_LEVEL___10 = 1073741824,
    SFD_NO_DITHER___10 = 500,
    SFD_WHITE___10 = 501,
    SFD_TRIANGULAR_PDF___10 = 502
} ;
#line 380
enum __anonenum__54___4 {
    SF_LOOP_NONE___10 = 800,
    SF_LOOP_FORWARD___10 = 801,
    SF_LOOP_BACKWARD___10 = 802,
    SF_LOOP_ALTERNATING___10 = 803
} ;
#line 121 "/root/libsndfile/src/common.h"
enum __anonenum__59___4 {
    SF_PEAK_START___10 = 42,
    SF_PEAK_END___10 = 43,
    SF_SCALE_MAX___10 = 52,
    SF_SCALE_MIN___10 = 53,
    SF_STR_ALLOW_START___10 = 256,
    SF_STR_ALLOW_END___10 = 512,
    SF_STR_LOCATE_START___10 = 1024,
    SF_STR_LOCATE_END___10 = 2048,
    SFD_TYPEMASK___10 = 268435455
} ;
#line 149
enum __anonenum__60___4 {
    SF_FORMAT_TXW___10 = 67305472,
    SF_FORMAT_DWD___10 = 67371008,
    SF_FORMAT_REX___10 = 67764224,
    SF_FORMAT_REX2___10 = 67960832,
    SF_FORMAT_KRZ___10 = 68026368,
    SF_FORMAT_WMA___10 = 68157440,
    SF_FORMAT_SHN___10 = 68222976,
    SF_FORMAT_SVX_FIB___10 = 4128,
    SF_FORMAT_SVX_EXP___10 = 4129,
    SF_FORMAT_PCM_N___10 = 4144
} ;
#line 405
enum __anonenum__66___4 {
    SFE_NO_ERROR___10 = 0,
    SFE_BAD_OPEN_FORMAT___10 = 1,
    SFE_SYSTEM___10 = 2,
    SFE_MALFORMED_FILE___10 = 3,
    SFE_UNSUPPORTED_ENCODING___10 = 4,
    SFE_ZERO_MAJOR_FORMAT___10 = 5,
    SFE_ZERO_MINOR_FORMAT___10 = 6,
    SFE_BAD_FILE___10 = 7,
    SFE_BAD_FILE_READ___10 = 8,
    SFE_OPEN_FAILED___10 = 9,
    SFE_BAD_SNDFILE_PTR___10 = 10,
    SFE_BAD_SF_INFO_PTR___10 = 11,
    SFE_BAD_SF_INCOMPLETE___10 = 12,
    SFE_BAD_FILE_PTR___10 = 13,
    SFE_BAD_INT_PTR___10 = 14,
    SFE_BAD_STAT_SIZE___10 = 15,
    SFE_MALLOC_FAILED___10 = 16,
    SFE_UNIMPLEMENTED___10 = 17,
    SFE_BAD_READ_ALIGN___10 = 18,
    SFE_BAD_WRITE_ALIGN___10 = 19,
    SFE_UNKNOWN_FORMAT___10 = 20,
    SFE_NOT_READMODE___10 = 21,
    SFE_NOT_WRITEMODE___10 = 22,
    SFE_BAD_MODE_RW___10 = 23,
    SFE_BAD_SF_INFO___10 = 24,
    SFE_BAD_OFFSET___10 = 25,
    SFE_NO_EMBED_SUPPORT___10 = 26,
    SFE_NO_EMBEDDED_RDWR___10 = 27,
    SFE_NO_PIPE_WRITE___10 = 28,
    SFE_INTERNAL___10 = 29,
    SFE_BAD_COMMAND_PARAM___10 = 30,
    SFE_BAD_ENDIAN___10 = 31,
    SFE_CHANNEL_COUNT_ZERO___10 = 32,
    SFE_CHANNEL_COUNT___10 = 33,
    SFE_BAD_VIRTUAL_IO___10 = 34,
    SFE_INTERLEAVE_MODE___10 = 35,
    SFE_INTERLEAVE_SEEK___10 = 36,
    SFE_INTERLEAVE_READ___10 = 37,
    SFE_BAD_SEEK___10 = 38,
    SFE_NOT_SEEKABLE___10 = 39,
    SFE_AMBIGUOUS_SEEK___10 = 40,
    SFE_WRONG_SEEK___10 = 41,
    SFE_SEEK_FAILED___10 = 42,
    SFE_BAD_OPEN_MODE___10 = 43,
    SFE_OPEN_PIPE_RDWR___10 = 44,
    SFE_RDWR_POSITION___10 = 45,
    SFE_RDWR_BAD_HEADER___10 = 46,
    SFE_CMD_HAS_DATA___10 = 47,
    SFE_BAD_BROADCAST_INFO_SIZE___10 = 48,
    SFE_STR_NO_SUPPORT___10 = 49,
    SFE_STR_NOT_WRITE___10 = 50,
    SFE_STR_MAX_DATA___10 = 51,
    SFE_STR_MAX_COUNT___10 = 52,
    SFE_STR_BAD_TYPE___10 = 53,
    SFE_STR_NO_ADD_END___10 = 54,
    SFE_STR_BAD_STRING___10 = 55,
    SFE_STR_WEIRD___10 = 56,
    SFE_WAV_NO_RIFF___10 = 57,
    SFE_WAV_NO_WAVE___10 = 58,
    SFE_WAV_NO_FMT___10 = 59,
    SFE_WAV_BAD_FMT___10 = 60,
    SFE_WAV_FMT_SHORT___10 = 61,
    SFE_WAV_BAD_FACT___10 = 62,
    SFE_WAV_BAD_PEAK___10 = 63,
    SFE_WAV_PEAK_B4_FMT___10 = 64,
    SFE_WAV_BAD_FORMAT___10 = 65,
    SFE_WAV_BAD_BLOCKALIGN___10 = 66,
    SFE_WAV_NO_DATA___10 = 67,
    SFE_WAV_BAD_LIST___10 = 68,
    SFE_WAV_ADPCM_NOT4BIT___10 = 69,
    SFE_WAV_ADPCM_CHANNELS___10 = 70,
    SFE_WAV_GSM610_FORMAT___10 = 71,
    SFE_WAV_UNKNOWN_CHUNK___10 = 72,
    SFE_WAV_WVPK_DATA___10 = 73,
    SFE_AIFF_NO_FORM___10 = 74,
    SFE_AIFF_AIFF_NO_FORM___10 = 75,
    SFE_AIFF_COMM_NO_FORM___10 = 76,
    SFE_AIFF_SSND_NO_COMM___10 = 77,
    SFE_AIFF_UNKNOWN_CHUNK___10 = 78,
    SFE_AIFF_COMM_CHUNK_SIZE___10 = 79,
    SFE_AIFF_BAD_COMM_CHUNK___10 = 80,
    SFE_AIFF_PEAK_B4_COMM___10 = 81,
    SFE_AIFF_BAD_PEAK___10 = 82,
    SFE_AIFF_NO_SSND___10 = 83,
    SFE_AIFF_NO_DATA___10 = 84,
    SFE_AIFF_RW_SSND_NOT_LAST___10 = 85,
    SFE_AU_UNKNOWN_FORMAT___10 = 86,
    SFE_AU_NO_DOTSND___10 = 87,
    SFE_AU_EMBED_BAD_LEN___10 = 88,
    SFE_RAW_READ_BAD_SPEC___10 = 89,
    SFE_RAW_BAD_BITWIDTH___10 = 90,
    SFE_RAW_BAD_FORMAT___10 = 91,
    SFE_PAF_NO_MARKER___10 = 92,
    SFE_PAF_VERSION___10 = 93,
    SFE_PAF_UNKNOWN_FORMAT___10 = 94,
    SFE_PAF_SHORT_HEADER___10 = 95,
    SFE_SVX_NO_FORM___10 = 96,
    SFE_SVX_NO_BODY___10 = 97,
    SFE_SVX_NO_DATA___10 = 98,
    SFE_SVX_BAD_COMP___10 = 99,
    SFE_SVX_BAD_NAME_LENGTH___10 = 100,
    SFE_NIST_BAD_HEADER___10 = 101,
    SFE_NIST_CRLF_CONVERISON___10 = 102,
    SFE_NIST_BAD_ENCODING___10 = 103,
    SFE_VOC_NO_CREATIVE___10 = 104,
    SFE_VOC_BAD_FORMAT___10 = 105,
    SFE_VOC_BAD_VERSION___10 = 106,
    SFE_VOC_BAD_MARKER___10 = 107,
    SFE_VOC_BAD_SECTIONS___10 = 108,
    SFE_VOC_MULTI_SAMPLERATE___10 = 109,
    SFE_VOC_MULTI_SECTION___10 = 110,
    SFE_VOC_MULTI_PARAM___10 = 111,
    SFE_VOC_SECTION_COUNT___10 = 112,
    SFE_VOC_NO_PIPE___10 = 113,
    SFE_IRCAM_NO_MARKER___10 = 114,
    SFE_IRCAM_BAD_CHANNELS___10 = 115,
    SFE_IRCAM_UNKNOWN_FORMAT___10 = 116,
    SFE_W64_64_BIT___10 = 117,
    SFE_W64_NO_RIFF___10 = 118,
    SFE_W64_NO_WAVE___10 = 119,
    SFE_W64_NO_DATA___10 = 120,
    SFE_W64_ADPCM_NOT4BIT___10 = 121,
    SFE_W64_ADPCM_CHANNELS___10 = 122,
    SFE_W64_GSM610_FORMAT___10 = 123,
    SFE_MAT4_BAD_NAME___10 = 124,
    SFE_MAT4_NO_SAMPLERATE___10 = 125,
    SFE_MAT5_BAD_ENDIAN___10 = 126,
    SFE_MAT5_NO_BLOCK___10 = 127,
    SFE_MAT5_SAMPLE_RATE___10 = 128,
    SFE_PVF_NO_PVF1___10 = 129,
    SFE_PVF_BAD_HEADER___10 = 130,
    SFE_PVF_BAD_BITWIDTH___10 = 131,
    SFE_DWVW_BAD_BITWIDTH___10 = 132,
    SFE_G72X_NOT_MONO___10 = 133,
    SFE_XI_BAD_HEADER___10 = 134,
    SFE_XI_EXCESS_SAMPLES___10 = 135,
    SFE_XI_NO_PIPE___10 = 136,
    SFE_HTK_NO_PIPE___10 = 137,
    SFE_SDS_NOT_SDS___10 = 138,
    SFE_SDS_BAD_BIT_WIDTH___10 = 139,
    SFE_SD2_FD_DISALLOWED___10 = 140,
    SFE_SD2_BAD_DATA_OFFSET___10 = 141,
    SFE_SD2_BAD_MAP_OFFSET___10 = 142,
    SFE_SD2_BAD_DATA_LENGTH___10 = 143,
    SFE_SD2_BAD_MAP_LENGTH___10 = 144,
    SFE_SD2_BAD_RSRC___10 = 145,
    SFE_SD2_BAD_SAMPLE_SIZE___10 = 146,
    SFE_FLAC_BAD_HEADER___10 = 147,
    SFE_FLAC_NEW_DECODER___10 = 148,
    SFE_FLAC_INIT_DECODER___10 = 149,
    SFE_FLAC_LOST_SYNC___10 = 150,
    SFE_FLAC_BAD_SAMPLE_RATE___10 = 151,
    SFE_FLAC_UNKOWN_ERROR___10 = 152,
    SFE_WVE_NOT_WVE___10 = 153,
    SFE_WVE_NO_PIPE___10 = 154,
    SFE_VORBIS_ENCODER_BUG___10 = 155,
    SFE_RF64_NOT_RF64___10 = 156,
    SFE_MAX_ERROR___10 = 157
} ;
#line 823
enum __anonenum__70___4 {
    SFC_TEST_AIFF_ADD_INST_CHUNK___10 = 8192,
    SFC_TEST_WAV_ADD_INFO_CHUNK___10 = 8208
} ;
#line 44 "/root/libsndfile/src/dwvw.c"
struct __anonstruct_327 {
   int index ;
   int end ;
   unsigned char buffer[256] ;
};
#line 40 "/root/libsndfile/src/dwvw.c"
struct __anonstruct_71___0 {
   int dwm_maxsize ;
   int bit_width ;
   int max_delta ;
   int span ;
   int samplecount ;
   int bit_count ;
   int bits ;
   int last_delta_width ;
   int last_sample ;
   struct __anonstruct_327 b ;
};
#line 48 "/root/libsndfile/src/dwvw.c"
typedef struct __anonstruct_71___0 DWVW_PRIVATE;
#line 853 "/usr/include/math.h"
enum __anonenum__43___5 {
    FP_NAN___8 = 0,
    FP_INFINITE___8 = 1,
    FP_ZERO___8 = 2,
    FP_SUBNORMAL___8 = 3,
    FP_NORMAL___8 = 4
} ;
#line 46 "/root/libsndfile/src/sndfile.h"
enum __anonenum__44___5 {
    SF_FORMAT_WAV___11 = 65536,
    SF_FORMAT_AIFF___11 = 131072,
    SF_FORMAT_AU___11 = 196608,
    SF_FORMAT_RAW___11 = 262144,
    SF_FORMAT_PAF___11 = 327680,
    SF_FORMAT_SVX___11 = 393216,
    SF_FORMAT_NIST___11 = 458752,
    SF_FORMAT_VOC___11 = 524288,
    SF_FORMAT_IRCAM___11 = 655360,
    SF_FORMAT_W64___11 = 720896,
    SF_FORMAT_MAT4___11 = 786432,
    SF_FORMAT_MAT5___11 = 851968,
    SF_FORMAT_PVF___11 = 917504,
    SF_FORMAT_XI___11 = 983040,
    SF_FORMAT_HTK___11 = 1048576,
    SF_FORMAT_SDS___11 = 1114112,
    SF_FORMAT_AVR___11 = 1179648,
    SF_FORMAT_WAVEX___11 = 1245184,
    SF_FORMAT_SD2___11 = 1441792,
    SF_FORMAT_FLAC___11 = 1507328,
    SF_FORMAT_CAF___11 = 1572864,
    SF_FORMAT_WVE___11 = 1638400,
    SF_FORMAT_OGG___11 = 2097152,
    SF_FORMAT_MPC2K___11 = 2162688,
    SF_FORMAT_RF64___11 = 2228224,
    SF_FORMAT_PCM_S8___11 = 1,
    SF_FORMAT_PCM_16___11 = 2,
    SF_FORMAT_PCM_24___11 = 3,
    SF_FORMAT_PCM_32___11 = 4,
    SF_FORMAT_PCM_U8___11 = 5,
    SF_FORMAT_FLOAT___11 = 6,
    SF_FORMAT_DOUBLE___11 = 7,
    SF_FORMAT_ULAW___11 = 16,
    SF_FORMAT_ALAW___11 = 17,
    SF_FORMAT_IMA_ADPCM___11 = 18,
    SF_FORMAT_MS_ADPCM___11 = 19,
    SF_FORMAT_GSM610___11 = 32,
    SF_FORMAT_VOX_ADPCM___11 = 33,
    SF_FORMAT_G721_32___11 = 48,
    SF_FORMAT_G723_24___11 = 49,
    SF_FORMAT_G723_40___11 = 50,
    SF_FORMAT_DWVW_12___11 = 64,
    SF_FORMAT_DWVW_16___11 = 65,
    SF_FORMAT_DWVW_24___11 = 66,
    SF_FORMAT_DWVW_N___11 = 67,
    SF_FORMAT_DPCM_8___11 = 80,
    SF_FORMAT_DPCM_16___11 = 81,
    SF_FORMAT_VORBIS___11 = 96,
    SF_ENDIAN_FILE___11 = 0,
    SF_ENDIAN_LITTLE___11 = 268435456,
    SF_ENDIAN_BIG___11 = 536870912,
    SF_ENDIAN_CPU___11 = 805306368,
    SF_FORMAT_SUBMASK___11 = 65535,
    SF_FORMAT_TYPEMASK___11 = 268369920,
    SF_FORMAT_ENDMASK___11 = 805306368
} ;
#line 126
enum __anonenum__45___5 {
    SFC_GET_LIB_VERSION___11 = 4096,
    SFC_GET_LOG_INFO___11 = 4097,
    SFC_GET_CURRENT_SF_INFO___11 = 4098,
    SFC_GET_NORM_DOUBLE___11 = 4112,
    SFC_GET_NORM_FLOAT___11 = 4113,
    SFC_SET_NORM_DOUBLE___11 = 4114,
    SFC_SET_NORM_FLOAT___11 = 4115,
    SFC_SET_SCALE_FLOAT_INT_READ___11 = 4116,
    SFC_SET_SCALE_INT_FLOAT_WRITE___11 = 4117,
    SFC_GET_SIMPLE_FORMAT_COUNT___11 = 4128,
    SFC_GET_SIMPLE_FORMAT___11 = 4129,
    SFC_GET_FORMAT_INFO___11 = 4136,
    SFC_GET_FORMAT_MAJOR_COUNT___11 = 4144,
    SFC_GET_FORMAT_MAJOR___11 = 4145,
    SFC_GET_FORMAT_SUBTYPE_COUNT___11 = 4146,
    SFC_GET_FORMAT_SUBTYPE___11 = 4147,
    SFC_CALC_SIGNAL_MAX___11 = 4160,
    SFC_CALC_NORM_SIGNAL_MAX___11 = 4161,
    SFC_CALC_MAX_ALL_CHANNELS___11 = 4162,
    SFC_CALC_NORM_MAX_ALL_CHANNELS___11 = 4163,
    SFC_GET_SIGNAL_MAX___11 = 4164,
    SFC_GET_MAX_ALL_CHANNELS___11 = 4165,
    SFC_SET_ADD_PEAK_CHUNK___11 = 4176,
    SFC_SET_ADD_HEADER_PAD_CHUNK___11 = 4177,
    SFC_UPDATE_HEADER_NOW___11 = 4192,
    SFC_SET_UPDATE_HEADER_AUTO___11 = 4193,
    SFC_FILE_TRUNCATE___11 = 4224,
    SFC_SET_RAW_START_OFFSET___11 = 4240,
    SFC_SET_DITHER_ON_WRITE___11 = 4256,
    SFC_SET_DITHER_ON_READ___11 = 4257,
    SFC_GET_DITHER_INFO_COUNT___11 = 4258,
    SFC_GET_DITHER_INFO___11 = 4259,
    SFC_GET_EMBED_FILE_INFO___11 = 4272,
    SFC_SET_CLIPPING___11 = 4288,
    SFC_GET_CLIPPING___11 = 4289,
    SFC_GET_INSTRUMENT___11 = 4304,
    SFC_SET_INSTRUMENT___11 = 4305,
    SFC_GET_LOOP_INFO___11 = 4320,
    SFC_GET_BROADCAST_INFO___11 = 4336,
    SFC_SET_BROADCAST_INFO___11 = 4337,
    SFC_GET_CHANNEL_MAP_INFO___11 = 4352,
    SFC_SET_CHANNEL_MAP_INFO___11 = 4353,
    SFC_RAW_DATA_NEEDS_ENDSWAP___11 = 4368,
    SFC_WAVEX_SET_AMBISONIC___11 = 4608,
    SFC_WAVEX_GET_AMBISONIC___11 = 4609,
    SFC_SET_VBR_ENCODING_QUALITY___11 = 4864,
    SFC_TEST_IEEE_FLOAT_REPLACE___11 = 24577,
    SFC_SET_ADD_DITHER_ON_WRITE___11 = 4208,
    SFC_SET_ADD_DITHER_ON_READ___11 = 4209
} ;
#line 216
enum __anonenum__46___5 {
    SF_STR_TITLE___11 = 1,
    SF_STR_COPYRIGHT___11 = 2,
    SF_STR_SOFTWARE___11 = 3,
    SF_STR_ARTIST___11 = 4,
    SF_STR_COMMENT___11 = 5,
    SF_STR_DATE___11 = 6,
    SF_STR_ALBUM___11 = 7,
    SF_STR_LICENSE___11 = 8
} ;
#line 235
enum __anonenum__47___5 {
    SF_FALSE___11 = 0,
    SF_TRUE___11 = 1,
    SFM_READ___11 = 16,
    SFM_WRITE___11 = 32,
    SFM_RDWR___11 = 48,
    SF_AMBISONIC_NONE___11 = 64,
    SF_AMBISONIC_B_FORMAT___11 = 65
} ;
#line 255
enum __anonenum__48___5 {
    SF_ERR_NO_ERROR___11 = 0,
    SF_ERR_UNRECOGNISED_FORMAT___11 = 1,
    SF_ERR_SYSTEM___11 = 2,
    SF_ERR_MALFORMED_FILE___11 = 3,
    SF_ERR_UNSUPPORTED_ENCODING___11 = 4
} ;
#line 267
enum __anonenum__49___5 {
    SF_CHANNEL_MAP_INVALID___11 = 0,
    SF_CHANNEL_MAP_MONO___11 = 1,
    SF_CHANNEL_MAP_LEFT___11 = 2,
    SF_CHANNEL_MAP_RIGHT___11 = 3,
    SF_CHANNEL_MAP_CENTER___11 = 4,
    SF_CHANNEL_MAP_FRONT_LEFT___11 = 5,
    SF_CHANNEL_MAP_FRONT_RIGHT___11 = 6,
    SF_CHANNEL_MAP_FRONT_CENTER___11 = 7,
    SF_CHANNEL_MAP_REAR_CENTER___11 = 8,
    SF_CHANNEL_MAP_REAR_LEFT___11 = 9,
    SF_CHANNEL_MAP_REAR_RIGHT___11 = 10,
    SF_CHANNEL_MAP_LFE___11 = 11,
    SF_CHANNEL_MAP_FRONT_LEFT_OF_CENTER___11 = 12,
    SF_CHANNEL_MAP_FRONT_RIGHT_OF_CENTER___11 = 13,
    SF_CHANNEL_MAP_SIDE_LEFT___11 = 14,
    SF_CHANNEL_MAP_SIDE_RIGHT___11 = 15,
    SF_CHANNEL_MAP_TOP_CENTER___11 = 16,
    SF_CHANNEL_MAP_TOP_FRONT_LEFT___11 = 17,
    SF_CHANNEL_MAP_TOP_FRONT_RIGHT___11 = 18,
    SF_CHANNEL_MAP_TOP_FRONT_CENTER___11 = 19,
    SF_CHANNEL_MAP_TOP_REAR_LEFT___11 = 20,
    SF_CHANNEL_MAP_TOP_REAR_RIGHT___11 = 21,
    SF_CHANNEL_MAP_TOP_REAR_CENTER___11 = 22
} ;
#line 352
enum __anonenum__51___5 {
    SFD_DEFAULT_LEVEL___11 = 0,
    SFD_CUSTOM_LEVEL___11 = 1073741824,
    SFD_NO_DITHER___11 = 500,
    SFD_WHITE___11 = 501,
    SFD_TRIANGULAR_PDF___11 = 502
} ;
#line 380
enum __anonenum__54___5 {
    SF_LOOP_NONE___11 = 800,
    SF_LOOP_FORWARD___11 = 801,
    SF_LOOP_BACKWARD___11 = 802,
    SF_LOOP_ALTERNATING___11 = 803
} ;
#line 121 "/root/libsndfile/src/common.h"
enum __anonenum__59___5 {
    SF_PEAK_START___11 = 42,
    SF_PEAK_END___11 = 43,
    SF_SCALE_MAX___11 = 52,
    SF_SCALE_MIN___11 = 53,
    SF_STR_ALLOW_START___11 = 256,
    SF_STR_ALLOW_END___11 = 512,
    SF_STR_LOCATE_START___11 = 1024,
    SF_STR_LOCATE_END___11 = 2048,
    SFD_TYPEMASK___11 = 268435455
} ;
#line 149
enum __anonenum__60___5 {
    SF_FORMAT_TXW___11 = 67305472,
    SF_FORMAT_DWD___11 = 67371008,
    SF_FORMAT_REX___11 = 67764224,
    SF_FORMAT_REX2___11 = 67960832,
    SF_FORMAT_KRZ___11 = 68026368,
    SF_FORMAT_WMA___11 = 68157440,
    SF_FORMAT_SHN___11 = 68222976,
    SF_FORMAT_SVX_FIB___11 = 4128,
    SF_FORMAT_SVX_EXP___11 = 4129,
    SF_FORMAT_PCM_N___11 = 4144
} ;
#line 405
enum __anonenum__66___5 {
    SFE_NO_ERROR___11 = 0,
    SFE_BAD_OPEN_FORMAT___11 = 1,
    SFE_SYSTEM___11 = 2,
    SFE_MALFORMED_FILE___11 = 3,
    SFE_UNSUPPORTED_ENCODING___11 = 4,
    SFE_ZERO_MAJOR_FORMAT___11 = 5,
    SFE_ZERO_MINOR_FORMAT___11 = 6,
    SFE_BAD_FILE___11 = 7,
    SFE_BAD_FILE_READ___11 = 8,
    SFE_OPEN_FAILED___11 = 9,
    SFE_BAD_SNDFILE_PTR___11 = 10,
    SFE_BAD_SF_INFO_PTR___11 = 11,
    SFE_BAD_SF_INCOMPLETE___11 = 12,
    SFE_BAD_FILE_PTR___11 = 13,
    SFE_BAD_INT_PTR___11 = 14,
    SFE_BAD_STAT_SIZE___11 = 15,
    SFE_MALLOC_FAILED___11 = 16,
    SFE_UNIMPLEMENTED___11 = 17,
    SFE_BAD_READ_ALIGN___11 = 18,
    SFE_BAD_WRITE_ALIGN___11 = 19,
    SFE_UNKNOWN_FORMAT___11 = 20,
    SFE_NOT_READMODE___11 = 21,
    SFE_NOT_WRITEMODE___11 = 22,
    SFE_BAD_MODE_RW___11 = 23,
    SFE_BAD_SF_INFO___11 = 24,
    SFE_BAD_OFFSET___11 = 25,
    SFE_NO_EMBED_SUPPORT___11 = 26,
    SFE_NO_EMBEDDED_RDWR___11 = 27,
    SFE_NO_PIPE_WRITE___11 = 28,
    SFE_INTERNAL___11 = 29,
    SFE_BAD_COMMAND_PARAM___11 = 30,
    SFE_BAD_ENDIAN___11 = 31,
    SFE_CHANNEL_COUNT_ZERO___11 = 32,
    SFE_CHANNEL_COUNT___11 = 33,
    SFE_BAD_VIRTUAL_IO___11 = 34,
    SFE_INTERLEAVE_MODE___11 = 35,
    SFE_INTERLEAVE_SEEK___11 = 36,
    SFE_INTERLEAVE_READ___11 = 37,
    SFE_BAD_SEEK___11 = 38,
    SFE_NOT_SEEKABLE___11 = 39,
    SFE_AMBIGUOUS_SEEK___11 = 40,
    SFE_WRONG_SEEK___11 = 41,
    SFE_SEEK_FAILED___11 = 42,
    SFE_BAD_OPEN_MODE___11 = 43,
    SFE_OPEN_PIPE_RDWR___11 = 44,
    SFE_RDWR_POSITION___11 = 45,
    SFE_RDWR_BAD_HEADER___11 = 46,
    SFE_CMD_HAS_DATA___11 = 47,
    SFE_BAD_BROADCAST_INFO_SIZE___11 = 48,
    SFE_STR_NO_SUPPORT___11 = 49,
    SFE_STR_NOT_WRITE___11 = 50,
    SFE_STR_MAX_DATA___11 = 51,
    SFE_STR_MAX_COUNT___11 = 52,
    SFE_STR_BAD_TYPE___11 = 53,
    SFE_STR_NO_ADD_END___11 = 54,
    SFE_STR_BAD_STRING___11 = 55,
    SFE_STR_WEIRD___11 = 56,
    SFE_WAV_NO_RIFF___11 = 57,
    SFE_WAV_NO_WAVE___11 = 58,
    SFE_WAV_NO_FMT___11 = 59,
    SFE_WAV_BAD_FMT___11 = 60,
    SFE_WAV_FMT_SHORT___11 = 61,
    SFE_WAV_BAD_FACT___11 = 62,
    SFE_WAV_BAD_PEAK___11 = 63,
    SFE_WAV_PEAK_B4_FMT___11 = 64,
    SFE_WAV_BAD_FORMAT___11 = 65,
    SFE_WAV_BAD_BLOCKALIGN___11 = 66,
    SFE_WAV_NO_DATA___11 = 67,
    SFE_WAV_BAD_LIST___11 = 68,
    SFE_WAV_ADPCM_NOT4BIT___11 = 69,
    SFE_WAV_ADPCM_CHANNELS___11 = 70,
    SFE_WAV_GSM610_FORMAT___11 = 71,
    SFE_WAV_UNKNOWN_CHUNK___11 = 72,
    SFE_WAV_WVPK_DATA___11 = 73,
    SFE_AIFF_NO_FORM___11 = 74,
    SFE_AIFF_AIFF_NO_FORM___11 = 75,
    SFE_AIFF_COMM_NO_FORM___11 = 76,
    SFE_AIFF_SSND_NO_COMM___11 = 77,
    SFE_AIFF_UNKNOWN_CHUNK___11 = 78,
    SFE_AIFF_COMM_CHUNK_SIZE___11 = 79,
    SFE_AIFF_BAD_COMM_CHUNK___11 = 80,
    SFE_AIFF_PEAK_B4_COMM___11 = 81,
    SFE_AIFF_BAD_PEAK___11 = 82,
    SFE_AIFF_NO_SSND___11 = 83,
    SFE_AIFF_NO_DATA___11 = 84,
    SFE_AIFF_RW_SSND_NOT_LAST___11 = 85,
    SFE_AU_UNKNOWN_FORMAT___11 = 86,
    SFE_AU_NO_DOTSND___11 = 87,
    SFE_AU_EMBED_BAD_LEN___11 = 88,
    SFE_RAW_READ_BAD_SPEC___11 = 89,
    SFE_RAW_BAD_BITWIDTH___11 = 90,
    SFE_RAW_BAD_FORMAT___11 = 91,
    SFE_PAF_NO_MARKER___11 = 92,
    SFE_PAF_VERSION___11 = 93,
    SFE_PAF_UNKNOWN_FORMAT___11 = 94,
    SFE_PAF_SHORT_HEADER___11 = 95,
    SFE_SVX_NO_FORM___11 = 96,
    SFE_SVX_NO_BODY___11 = 97,
    SFE_SVX_NO_DATA___11 = 98,
    SFE_SVX_BAD_COMP___11 = 99,
    SFE_SVX_BAD_NAME_LENGTH___11 = 100,
    SFE_NIST_BAD_HEADER___11 = 101,
    SFE_NIST_CRLF_CONVERISON___11 = 102,
    SFE_NIST_BAD_ENCODING___11 = 103,
    SFE_VOC_NO_CREATIVE___11 = 104,
    SFE_VOC_BAD_FORMAT___11 = 105,
    SFE_VOC_BAD_VERSION___11 = 106,
    SFE_VOC_BAD_MARKER___11 = 107,
    SFE_VOC_BAD_SECTIONS___11 = 108,
    SFE_VOC_MULTI_SAMPLERATE___11 = 109,
    SFE_VOC_MULTI_SECTION___11 = 110,
    SFE_VOC_MULTI_PARAM___11 = 111,
    SFE_VOC_SECTION_COUNT___11 = 112,
    SFE_VOC_NO_PIPE___11 = 113,
    SFE_IRCAM_NO_MARKER___11 = 114,
    SFE_IRCAM_BAD_CHANNELS___11 = 115,
    SFE_IRCAM_UNKNOWN_FORMAT___11 = 116,
    SFE_W64_64_BIT___11 = 117,
    SFE_W64_NO_RIFF___11 = 118,
    SFE_W64_NO_WAVE___11 = 119,
    SFE_W64_NO_DATA___11 = 120,
    SFE_W64_ADPCM_NOT4BIT___11 = 121,
    SFE_W64_ADPCM_CHANNELS___11 = 122,
    SFE_W64_GSM610_FORMAT___11 = 123,
    SFE_MAT4_BAD_NAME___11 = 124,
    SFE_MAT4_NO_SAMPLERATE___11 = 125,
    SFE_MAT5_BAD_ENDIAN___11 = 126,
    SFE_MAT5_NO_BLOCK___11 = 127,
    SFE_MAT5_SAMPLE_RATE___11 = 128,
    SFE_PVF_NO_PVF1___11 = 129,
    SFE_PVF_BAD_HEADER___11 = 130,
    SFE_PVF_BAD_BITWIDTH___11 = 131,
    SFE_DWVW_BAD_BITWIDTH___11 = 132,
    SFE_G72X_NOT_MONO___11 = 133,
    SFE_XI_BAD_HEADER___11 = 134,
    SFE_XI_EXCESS_SAMPLES___11 = 135,
    SFE_XI_NO_PIPE___11 = 136,
    SFE_HTK_NO_PIPE___11 = 137,
    SFE_SDS_NOT_SDS___11 = 138,
    SFE_SDS_BAD_BIT_WIDTH___11 = 139,
    SFE_SD2_FD_DISALLOWED___11 = 140,
    SFE_SD2_BAD_DATA_OFFSET___11 = 141,
    SFE_SD2_BAD_MAP_OFFSET___11 = 142,
    SFE_SD2_BAD_DATA_LENGTH___11 = 143,
    SFE_SD2_BAD_MAP_LENGTH___11 = 144,
    SFE_SD2_BAD_RSRC___11 = 145,
    SFE_SD2_BAD_SAMPLE_SIZE___11 = 146,
    SFE_FLAC_BAD_HEADER___11 = 147,
    SFE_FLAC_NEW_DECODER___11 = 148,
    SFE_FLAC_INIT_DECODER___11 = 149,
    SFE_FLAC_LOST_SYNC___11 = 150,
    SFE_FLAC_BAD_SAMPLE_RATE___11 = 151,
    SFE_FLAC_UNKOWN_ERROR___11 = 152,
    SFE_WVE_NOT_WVE___11 = 153,
    SFE_WVE_NO_PIPE___11 = 154,
    SFE_VORBIS_ENCODER_BUG___11 = 155,
    SFE_RF64_NOT_RF64___11 = 156,
    SFE_MAX_ERROR___11 = 157
} ;
#line 823
enum __anonenum__70___5 {
    SFC_TEST_AIFF_ADD_INST_CHUNK___11 = 8192,
    SFC_TEST_WAV_ADD_INFO_CHUNK___11 = 8208
} ;
#line 47 "/root/libsndfile/src/double64.c"
enum __anonstruct_71___2 {
    DOUBLE_UNKNOWN = 0,
    DOUBLE_CAN_RW_LE = 35,
    DOUBLE_CAN_RW_BE = 52,
    DOUBLE_BROKEN_LE = 69,
    DOUBLE_BROKEN_BE = 86
} ;
#line 454 "/root/libsndfile/src/double64.c"
union __anonunion_328 {
   double d ;
   unsigned char c[8] ;
};
#line 46 "/root/libsndfile/src/sndfile.h"
enum __anonenum__331 {
    SF_FORMAT_WAV___12 = 65536,
    SF_FORMAT_AIFF___12 = 131072,
    SF_FORMAT_AU___12 = 196608,
    SF_FORMAT_RAW___12 = 262144,
    SF_FORMAT_PAF___12 = 327680,
    SF_FORMAT_SVX___12 = 393216,
    SF_FORMAT_NIST___12 = 458752,
    SF_FORMAT_VOC___12 = 524288,
    SF_FORMAT_IRCAM___12 = 655360,
    SF_FORMAT_W64___12 = 720896,
    SF_FORMAT_MAT4___12 = 786432,
    SF_FORMAT_MAT5___12 = 851968,
    SF_FORMAT_PVF___12 = 917504,
    SF_FORMAT_XI___12 = 983040,
    SF_FORMAT_HTK___12 = 1048576,
    SF_FORMAT_SDS___12 = 1114112,
    SF_FORMAT_AVR___12 = 1179648,
    SF_FORMAT_WAVEX___12 = 1245184,
    SF_FORMAT_SD2___12 = 1441792,
    SF_FORMAT_FLAC___12 = 1507328,
    SF_FORMAT_CAF___12 = 1572864,
    SF_FORMAT_WVE___12 = 1638400,
    SF_FORMAT_OGG___12 = 2097152,
    SF_FORMAT_MPC2K___12 = 2162688,
    SF_FORMAT_RF64___12 = 2228224,
    SF_FORMAT_PCM_S8___12 = 1,
    SF_FORMAT_PCM_16___12 = 2,
    SF_FORMAT_PCM_24___12 = 3,
    SF_FORMAT_PCM_32___12 = 4,
    SF_FORMAT_PCM_U8___12 = 5,
    SF_FORMAT_FLOAT___12 = 6,
    SF_FORMAT_DOUBLE___12 = 7,
    SF_FORMAT_ULAW___12 = 16,
    SF_FORMAT_ALAW___12 = 17,
    SF_FORMAT_IMA_ADPCM___12 = 18,
    SF_FORMAT_MS_ADPCM___12 = 19,
    SF_FORMAT_GSM610___12 = 32,
    SF_FORMAT_VOX_ADPCM___12 = 33,
    SF_FORMAT_G721_32___12 = 48,
    SF_FORMAT_G723_24___12 = 49,
    SF_FORMAT_G723_40___12 = 50,
    SF_FORMAT_DWVW_12___12 = 64,
    SF_FORMAT_DWVW_16___12 = 65,
    SF_FORMAT_DWVW_24___12 = 66,
    SF_FORMAT_DWVW_N___12 = 67,
    SF_FORMAT_DPCM_8___12 = 80,
    SF_FORMAT_DPCM_16___12 = 81,
    SF_FORMAT_VORBIS___12 = 96,
    SF_ENDIAN_FILE___12 = 0,
    SF_ENDIAN_LITTLE___12 = 268435456,
    SF_ENDIAN_BIG___12 = 536870912,
    SF_ENDIAN_CPU___12 = 805306368,
    SF_FORMAT_SUBMASK___12 = 65535,
    SF_FORMAT_TYPEMASK___12 = 268369920,
    SF_FORMAT_ENDMASK___12 = 805306368
} ;
#line 126
enum __anonenum__332 {
    SFC_GET_LIB_VERSION___12 = 4096,
    SFC_GET_LOG_INFO___12 = 4097,
    SFC_GET_CURRENT_SF_INFO___12 = 4098,
    SFC_GET_NORM_DOUBLE___12 = 4112,
    SFC_GET_NORM_FLOAT___12 = 4113,
    SFC_SET_NORM_DOUBLE___12 = 4114,
    SFC_SET_NORM_FLOAT___12 = 4115,
    SFC_SET_SCALE_FLOAT_INT_READ___12 = 4116,
    SFC_SET_SCALE_INT_FLOAT_WRITE___12 = 4117,
    SFC_GET_SIMPLE_FORMAT_COUNT___12 = 4128,
    SFC_GET_SIMPLE_FORMAT___12 = 4129,
    SFC_GET_FORMAT_INFO___12 = 4136,
    SFC_GET_FORMAT_MAJOR_COUNT___12 = 4144,
    SFC_GET_FORMAT_MAJOR___12 = 4145,
    SFC_GET_FORMAT_SUBTYPE_COUNT___12 = 4146,
    SFC_GET_FORMAT_SUBTYPE___12 = 4147,
    SFC_CALC_SIGNAL_MAX___12 = 4160,
    SFC_CALC_NORM_SIGNAL_MAX___12 = 4161,
    SFC_CALC_MAX_ALL_CHANNELS___12 = 4162,
    SFC_CALC_NORM_MAX_ALL_CHANNELS___12 = 4163,
    SFC_GET_SIGNAL_MAX___12 = 4164,
    SFC_GET_MAX_ALL_CHANNELS___12 = 4165,
    SFC_SET_ADD_PEAK_CHUNK___12 = 4176,
    SFC_SET_ADD_HEADER_PAD_CHUNK___12 = 4177,
    SFC_UPDATE_HEADER_NOW___12 = 4192,
    SFC_SET_UPDATE_HEADER_AUTO___12 = 4193,
    SFC_FILE_TRUNCATE___12 = 4224,
    SFC_SET_RAW_START_OFFSET___12 = 4240,
    SFC_SET_DITHER_ON_WRITE___12 = 4256,
    SFC_SET_DITHER_ON_READ___12 = 4257,
    SFC_GET_DITHER_INFO_COUNT___12 = 4258,
    SFC_GET_DITHER_INFO___12 = 4259,
    SFC_GET_EMBED_FILE_INFO___12 = 4272,
    SFC_SET_CLIPPING___12 = 4288,
    SFC_GET_CLIPPING___12 = 4289,
    SFC_GET_INSTRUMENT___12 = 4304,
    SFC_SET_INSTRUMENT___12 = 4305,
    SFC_GET_LOOP_INFO___12 = 4320,
    SFC_GET_BROADCAST_INFO___12 = 4336,
    SFC_SET_BROADCAST_INFO___12 = 4337,
    SFC_GET_CHANNEL_MAP_INFO___12 = 4352,
    SFC_SET_CHANNEL_MAP_INFO___12 = 4353,
    SFC_RAW_DATA_NEEDS_ENDSWAP___12 = 4368,
    SFC_WAVEX_SET_AMBISONIC___12 = 4608,
    SFC_WAVEX_GET_AMBISONIC___12 = 4609,
    SFC_SET_VBR_ENCODING_QUALITY___12 = 4864,
    SFC_TEST_IEEE_FLOAT_REPLACE___12 = 24577,
    SFC_SET_ADD_DITHER_ON_WRITE___12 = 4208,
    SFC_SET_ADD_DITHER_ON_READ___12 = 4209
} ;
#line 216
enum __anonenum__333 {
    SF_STR_TITLE___12 = 1,
    SF_STR_COPYRIGHT___12 = 2,
    SF_STR_SOFTWARE___12 = 3,
    SF_STR_ARTIST___12 = 4,
    SF_STR_COMMENT___12 = 5,
    SF_STR_DATE___12 = 6,
    SF_STR_ALBUM___12 = 7,
    SF_STR_LICENSE___12 = 8
} ;
#line 235
enum __anonenum__334 {
    SF_FALSE___12 = 0,
    SF_TRUE___12 = 1,
    SFM_READ___12 = 16,
    SFM_WRITE___12 = 32,
    SFM_RDWR___12 = 48,
    SF_AMBISONIC_NONE___12 = 64,
    SF_AMBISONIC_B_FORMAT___12 = 65
} ;
#line 255
enum __anonenum__335 {
    SF_ERR_NO_ERROR___12 = 0,
    SF_ERR_UNRECOGNISED_FORMAT___12 = 1,
    SF_ERR_SYSTEM___12 = 2,
    SF_ERR_MALFORMED_FILE___12 = 3,
    SF_ERR_UNSUPPORTED_ENCODING___12 = 4
} ;
#line 267
enum __anonenum__336 {
    SF_CHANNEL_MAP_INVALID___12 = 0,
    SF_CHANNEL_MAP_MONO___12 = 1,
    SF_CHANNEL_MAP_LEFT___12 = 2,
    SF_CHANNEL_MAP_RIGHT___12 = 3,
    SF_CHANNEL_MAP_CENTER___12 = 4,
    SF_CHANNEL_MAP_FRONT_LEFT___12 = 5,
    SF_CHANNEL_MAP_FRONT_RIGHT___12 = 6,
    SF_CHANNEL_MAP_FRONT_CENTER___12 = 7,
    SF_CHANNEL_MAP_REAR_CENTER___12 = 8,
    SF_CHANNEL_MAP_REAR_LEFT___12 = 9,
    SF_CHANNEL_MAP_REAR_RIGHT___12 = 10,
    SF_CHANNEL_MAP_LFE___12 = 11,
    SF_CHANNEL_MAP_FRONT_LEFT_OF_CENTER___12 = 12,
    SF_CHANNEL_MAP_FRONT_RIGHT_OF_CENTER___12 = 13,
    SF_CHANNEL_MAP_SIDE_LEFT___12 = 14,
    SF_CHANNEL_MAP_SIDE_RIGHT___12 = 15,
    SF_CHANNEL_MAP_TOP_CENTER___12 = 16,
    SF_CHANNEL_MAP_TOP_FRONT_LEFT___12 = 17,
    SF_CHANNEL_MAP_TOP_FRONT_RIGHT___12 = 18,
    SF_CHANNEL_MAP_TOP_FRONT_CENTER___12 = 19,
    SF_CHANNEL_MAP_TOP_REAR_LEFT___12 = 20,
    SF_CHANNEL_MAP_TOP_REAR_RIGHT___12 = 21,
    SF_CHANNEL_MAP_TOP_REAR_CENTER___12 = 22
} ;
#line 352
enum __anonenum__338 {
    SFD_DEFAULT_LEVEL___12 = 0,
    SFD_CUSTOM_LEVEL___12 = 1073741824,
    SFD_NO_DITHER___12 = 500,
    SFD_WHITE___12 = 501,
    SFD_TRIANGULAR_PDF___12 = 502
} ;
#line 380
enum __anonenum__341 {
    SF_LOOP_NONE___12 = 800,
    SF_LOOP_FORWARD___12 = 801,
    SF_LOOP_BACKWARD___12 = 802,
    SF_LOOP_ALTERNATING___12 = 803
} ;
#line 121 "/root/libsndfile/src/common.h"
enum __anonenum__346 {
    SF_PEAK_START___12 = 42,
    SF_PEAK_END___12 = 43,
    SF_SCALE_MAX___12 = 52,
    SF_SCALE_MIN___12 = 53,
    SF_STR_ALLOW_START___12 = 256,
    SF_STR_ALLOW_END___12 = 512,
    SF_STR_LOCATE_START___12 = 1024,
    SF_STR_LOCATE_END___12 = 2048,
    SFD_TYPEMASK___12 = 268435455
} ;
#line 149
enum __anonenum__347 {
    SF_FORMAT_TXW___12 = 67305472,
    SF_FORMAT_DWD___12 = 67371008,
    SF_FORMAT_REX___12 = 67764224,
    SF_FORMAT_REX2___12 = 67960832,
    SF_FORMAT_KRZ___12 = 68026368,
    SF_FORMAT_WMA___12 = 68157440,
    SF_FORMAT_SHN___12 = 68222976,
    SF_FORMAT_SVX_FIB___12 = 4128,
    SF_FORMAT_SVX_EXP___12 = 4129,
    SF_FORMAT_PCM_N___12 = 4144
} ;
#line 405
enum __anonenum__353 {
    SFE_NO_ERROR___12 = 0,
    SFE_BAD_OPEN_FORMAT___12 = 1,
    SFE_SYSTEM___12 = 2,
    SFE_MALFORMED_FILE___12 = 3,
    SFE_UNSUPPORTED_ENCODING___12 = 4,
    SFE_ZERO_MAJOR_FORMAT___12 = 5,
    SFE_ZERO_MINOR_FORMAT___12 = 6,
    SFE_BAD_FILE___12 = 7,
    SFE_BAD_FILE_READ___12 = 8,
    SFE_OPEN_FAILED___12 = 9,
    SFE_BAD_SNDFILE_PTR___12 = 10,
    SFE_BAD_SF_INFO_PTR___12 = 11,
    SFE_BAD_SF_INCOMPLETE___12 = 12,
    SFE_BAD_FILE_PTR___12 = 13,
    SFE_BAD_INT_PTR___12 = 14,
    SFE_BAD_STAT_SIZE___12 = 15,
    SFE_MALLOC_FAILED___12 = 16,
    SFE_UNIMPLEMENTED___12 = 17,
    SFE_BAD_READ_ALIGN___12 = 18,
    SFE_BAD_WRITE_ALIGN___12 = 19,
    SFE_UNKNOWN_FORMAT___12 = 20,
    SFE_NOT_READMODE___12 = 21,
    SFE_NOT_WRITEMODE___12 = 22,
    SFE_BAD_MODE_RW___12 = 23,
    SFE_BAD_SF_INFO___12 = 24,
    SFE_BAD_OFFSET___12 = 25,
    SFE_NO_EMBED_SUPPORT___12 = 26,
    SFE_NO_EMBEDDED_RDWR___12 = 27,
    SFE_NO_PIPE_WRITE___12 = 28,
    SFE_INTERNAL___12 = 29,
    SFE_BAD_COMMAND_PARAM___12 = 30,
    SFE_BAD_ENDIAN___12 = 31,
    SFE_CHANNEL_COUNT_ZERO___12 = 32,
    SFE_CHANNEL_COUNT___12 = 33,
    SFE_BAD_VIRTUAL_IO___12 = 34,
    SFE_INTERLEAVE_MODE___12 = 35,
    SFE_INTERLEAVE_SEEK___12 = 36,
    SFE_INTERLEAVE_READ___12 = 37,
    SFE_BAD_SEEK___12 = 38,
    SFE_NOT_SEEKABLE___12 = 39,
    SFE_AMBIGUOUS_SEEK___12 = 40,
    SFE_WRONG_SEEK___12 = 41,
    SFE_SEEK_FAILED___12 = 42,
    SFE_BAD_OPEN_MODE___12 = 43,
    SFE_OPEN_PIPE_RDWR___12 = 44,
    SFE_RDWR_POSITION___12 = 45,
    SFE_RDWR_BAD_HEADER___12 = 46,
    SFE_CMD_HAS_DATA___12 = 47,
    SFE_BAD_BROADCAST_INFO_SIZE___12 = 48,
    SFE_STR_NO_SUPPORT___12 = 49,
    SFE_STR_NOT_WRITE___12 = 50,
    SFE_STR_MAX_DATA___12 = 51,
    SFE_STR_MAX_COUNT___12 = 52,
    SFE_STR_BAD_TYPE___12 = 53,
    SFE_STR_NO_ADD_END___12 = 54,
    SFE_STR_BAD_STRING___12 = 55,
    SFE_STR_WEIRD___12 = 56,
    SFE_WAV_NO_RIFF___12 = 57,
    SFE_WAV_NO_WAVE___12 = 58,
    SFE_WAV_NO_FMT___12 = 59,
    SFE_WAV_BAD_FMT___12 = 60,
    SFE_WAV_FMT_SHORT___12 = 61,
    SFE_WAV_BAD_FACT___12 = 62,
    SFE_WAV_BAD_PEAK___12 = 63,
    SFE_WAV_PEAK_B4_FMT___12 = 64,
    SFE_WAV_BAD_FORMAT___12 = 65,
    SFE_WAV_BAD_BLOCKALIGN___12 = 66,
    SFE_WAV_NO_DATA___12 = 67,
    SFE_WAV_BAD_LIST___12 = 68,
    SFE_WAV_ADPCM_NOT4BIT___12 = 69,
    SFE_WAV_ADPCM_CHANNELS___12 = 70,
    SFE_WAV_GSM610_FORMAT___12 = 71,
    SFE_WAV_UNKNOWN_CHUNK___12 = 72,
    SFE_WAV_WVPK_DATA___12 = 73,
    SFE_AIFF_NO_FORM___12 = 74,
    SFE_AIFF_AIFF_NO_FORM___12 = 75,
    SFE_AIFF_COMM_NO_FORM___12 = 76,
    SFE_AIFF_SSND_NO_COMM___12 = 77,
    SFE_AIFF_UNKNOWN_CHUNK___12 = 78,
    SFE_AIFF_COMM_CHUNK_SIZE___12 = 79,
    SFE_AIFF_BAD_COMM_CHUNK___12 = 80,
    SFE_AIFF_PEAK_B4_COMM___12 = 81,
    SFE_AIFF_BAD_PEAK___12 = 82,
    SFE_AIFF_NO_SSND___12 = 83,
    SFE_AIFF_NO_DATA___12 = 84,
    SFE_AIFF_RW_SSND_NOT_LAST___12 = 85,
    SFE_AU_UNKNOWN_FORMAT___12 = 86,
    SFE_AU_NO_DOTSND___12 = 87,
    SFE_AU_EMBED_BAD_LEN___12 = 88,
    SFE_RAW_READ_BAD_SPEC___12 = 89,
    SFE_RAW_BAD_BITWIDTH___12 = 90,
    SFE_RAW_BAD_FORMAT___12 = 91,
    SFE_PAF_NO_MARKER___12 = 92,
    SFE_PAF_VERSION___12 = 93,
    SFE_PAF_UNKNOWN_FORMAT___12 = 94,
    SFE_PAF_SHORT_HEADER___12 = 95,
    SFE_SVX_NO_FORM___12 = 96,
    SFE_SVX_NO_BODY___12 = 97,
    SFE_SVX_NO_DATA___12 = 98,
    SFE_SVX_BAD_COMP___12 = 99,
    SFE_SVX_BAD_NAME_LENGTH___12 = 100,
    SFE_NIST_BAD_HEADER___12 = 101,
    SFE_NIST_CRLF_CONVERISON___12 = 102,
    SFE_NIST_BAD_ENCODING___12 = 103,
    SFE_VOC_NO_CREATIVE___12 = 104,
    SFE_VOC_BAD_FORMAT___12 = 105,
    SFE_VOC_BAD_VERSION___12 = 106,
    SFE_VOC_BAD_MARKER___12 = 107,
    SFE_VOC_BAD_SECTIONS___12 = 108,
    SFE_VOC_MULTI_SAMPLERATE___12 = 109,
    SFE_VOC_MULTI_SECTION___12 = 110,
    SFE_VOC_MULTI_PARAM___12 = 111,
    SFE_VOC_SECTION_COUNT___12 = 112,
    SFE_VOC_NO_PIPE___12 = 113,
    SFE_IRCAM_NO_MARKER___12 = 114,
    SFE_IRCAM_BAD_CHANNELS___12 = 115,
    SFE_IRCAM_UNKNOWN_FORMAT___12 = 116,
    SFE_W64_64_BIT___12 = 117,
    SFE_W64_NO_RIFF___12 = 118,
    SFE_W64_NO_WAVE___12 = 119,
    SFE_W64_NO_DATA___12 = 120,
    SFE_W64_ADPCM_NOT4BIT___12 = 121,
    SFE_W64_ADPCM_CHANNELS___12 = 122,
    SFE_W64_GSM610_FORMAT___12 = 123,
    SFE_MAT4_BAD_NAME___12 = 124,
    SFE_MAT4_NO_SAMPLERATE___12 = 125,
    SFE_MAT5_BAD_ENDIAN___12 = 126,
    SFE_MAT5_NO_BLOCK___12 = 127,
    SFE_MAT5_SAMPLE_RATE___12 = 128,
    SFE_PVF_NO_PVF1___12 = 129,
    SFE_PVF_BAD_HEADER___12 = 130,
    SFE_PVF_BAD_BITWIDTH___12 = 131,
    SFE_DWVW_BAD_BITWIDTH___12 = 132,
    SFE_G72X_NOT_MONO___12 = 133,
    SFE_XI_BAD_HEADER___12 = 134,
    SFE_XI_EXCESS_SAMPLES___12 = 135,
    SFE_XI_NO_PIPE___12 = 136,
    SFE_HTK_NO_PIPE___12 = 137,
    SFE_SDS_NOT_SDS___12 = 138,
    SFE_SDS_BAD_BIT_WIDTH___12 = 139,
    SFE_SD2_FD_DISALLOWED___12 = 140,
    SFE_SD2_BAD_DATA_OFFSET___12 = 141,
    SFE_SD2_BAD_MAP_OFFSET___12 = 142,
    SFE_SD2_BAD_DATA_LENGTH___12 = 143,
    SFE_SD2_BAD_MAP_LENGTH___12 = 144,
    SFE_SD2_BAD_RSRC___12 = 145,
    SFE_SD2_BAD_SAMPLE_SIZE___12 = 146,
    SFE_FLAC_BAD_HEADER___12 = 147,
    SFE_FLAC_NEW_DECODER___12 = 148,
    SFE_FLAC_INIT_DECODER___12 = 149,
    SFE_FLAC_LOST_SYNC___12 = 150,
    SFE_FLAC_BAD_SAMPLE_RATE___12 = 151,
    SFE_FLAC_UNKOWN_ERROR___12 = 152,
    SFE_WVE_NOT_WVE___12 = 153,
    SFE_WVE_NO_PIPE___12 = 154,
    SFE_VORBIS_ENCODER_BUG___12 = 155,
    SFE_RF64_NOT_RF64___12 = 156,
    SFE_MAX_ERROR___12 = 157
} ;
#line 823
enum __anonenum__357 {
    SFC_TEST_AIFF_ADD_INST_CHUNK___12 = 8192,
    SFC_TEST_WAV_ADD_INFO_CHUNK___12 = 8208
} ;
#line 59 "/root/libsndfile/src/dither.c"
struct __anonstruct_358 {
   int read_short_dither_bits ;
   int read_int_dither_bits ;
   int write_short_dither_bits ;
   int write_int_dither_bits ;
   double read_float_dither_scale ;
   double read_double_dither_bits ;
   double write_float_dither_scale ;
   double write_double_dither_bits ;
   sf_count_t (*read_short)(SF_PRIVATE * , short * , sf_count_t  ) ;
   sf_count_t (*read_int)(SF_PRIVATE * , int * , sf_count_t  ) ;
   sf_count_t (*read_float)(SF_PRIVATE * , float * , sf_count_t  ) ;
   sf_count_t (*read_double)(SF_PRIVATE * , double * , sf_count_t  ) ;
   sf_count_t (*write_short)(SF_PRIVATE * , short const   * , sf_count_t  ) ;
   sf_count_t (*write_int)(SF_PRIVATE * , int const   * , sf_count_t  ) ;
   sf_count_t (*write_float)(SF_PRIVATE * , float const   * , sf_count_t  ) ;
   sf_count_t (*write_double)(SF_PRIVATE * , double const   * , sf_count_t  ) ;
   double buffer[2048] ;
};
#line 76 "/root/libsndfile/src/dither.c"
typedef struct __anonstruct_358 DITHER_DATA;
#line 46 "/usr/include/ctype.h"
enum __anonenum__360 {
    _ISupper = 256,
    _ISlower = 512,
    _ISalpha = 1024,
    _ISdigit = 2048,
    _ISxdigit = 4096,
    _ISspace = 8192,
    _ISprint = 16384,
    _ISgraph = 32768,
    _ISblank = 1,
    _IScntrl = 2,
    _ISpunct = 4,
    _ISalnum = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__361 {
    FP_NAN___9 = 0,
    FP_INFINITE___9 = 1,
    FP_ZERO___9 = 2,
    FP_SUBNORMAL___9 = 3,
    FP_NORMAL___9 = 4
} ;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h"
struct itimerspec {
   struct timespec it_interval ;
   struct timespec it_value ;
};
#line 49 "/usr/include/time.h"
struct sigevent ;
#line 52 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 89
enum __itimer_which {
    ITIMER_REAL = 0,
    ITIMER_VIRTUAL = 1,
    ITIMER_PROF = 2
} ;
#line 105 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct itimerval {
   struct timeval it_interval ;
   struct timeval it_value ;
};
#line 118 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef int __itimer_which_t;
#line 46 "/root/libsndfile/src/sndfile.h"
enum __anonenum__378 {
    SF_FORMAT_WAV___13 = 65536,
    SF_FORMAT_AIFF___13 = 131072,
    SF_FORMAT_AU___13 = 196608,
    SF_FORMAT_RAW___13 = 262144,
    SF_FORMAT_PAF___13 = 327680,
    SF_FORMAT_SVX___13 = 393216,
    SF_FORMAT_NIST___13 = 458752,
    SF_FORMAT_VOC___13 = 524288,
    SF_FORMAT_IRCAM___13 = 655360,
    SF_FORMAT_W64___13 = 720896,
    SF_FORMAT_MAT4___13 = 786432,
    SF_FORMAT_MAT5___13 = 851968,
    SF_FORMAT_PVF___13 = 917504,
    SF_FORMAT_XI___13 = 983040,
    SF_FORMAT_HTK___13 = 1048576,
    SF_FORMAT_SDS___13 = 1114112,
    SF_FORMAT_AVR___13 = 1179648,
    SF_FORMAT_WAVEX___13 = 1245184,
    SF_FORMAT_SD2___13 = 1441792,
    SF_FORMAT_FLAC___13 = 1507328,
    SF_FORMAT_CAF___13 = 1572864,
    SF_FORMAT_WVE___13 = 1638400,
    SF_FORMAT_OGG___13 = 2097152,
    SF_FORMAT_MPC2K___13 = 2162688,
    SF_FORMAT_RF64___13 = 2228224,
    SF_FORMAT_PCM_S8___13 = 1,
    SF_FORMAT_PCM_16___13 = 2,
    SF_FORMAT_PCM_24___13 = 3,
    SF_FORMAT_PCM_32___13 = 4,
    SF_FORMAT_PCM_U8___13 = 5,
    SF_FORMAT_FLOAT___13 = 6,
    SF_FORMAT_DOUBLE___13 = 7,
    SF_FORMAT_ULAW___13 = 16,
    SF_FORMAT_ALAW___13 = 17,
    SF_FORMAT_IMA_ADPCM___13 = 18,
    SF_FORMAT_MS_ADPCM___13 = 19,
    SF_FORMAT_GSM610___13 = 32,
    SF_FORMAT_VOX_ADPCM___13 = 33,
    SF_FORMAT_G721_32___13 = 48,
    SF_FORMAT_G723_24___13 = 49,
    SF_FORMAT_G723_40___13 = 50,
    SF_FORMAT_DWVW_12___13 = 64,
    SF_FORMAT_DWVW_16___13 = 65,
    SF_FORMAT_DWVW_24___13 = 66,
    SF_FORMAT_DWVW_N___13 = 67,
    SF_FORMAT_DPCM_8___13 = 80,
    SF_FORMAT_DPCM_16___13 = 81,
    SF_FORMAT_VORBIS___13 = 96,
    SF_ENDIAN_FILE___13 = 0,
    SF_ENDIAN_LITTLE___13 = 268435456,
    SF_ENDIAN_BIG___13 = 536870912,
    SF_ENDIAN_CPU___13 = 805306368,
    SF_FORMAT_SUBMASK___13 = 65535,
    SF_FORMAT_TYPEMASK___13 = 268369920,
    SF_FORMAT_ENDMASK___13 = 805306368
} ;
#line 126
enum __anonenum__379 {
    SFC_GET_LIB_VERSION___13 = 4096,
    SFC_GET_LOG_INFO___13 = 4097,
    SFC_GET_CURRENT_SF_INFO___13 = 4098,
    SFC_GET_NORM_DOUBLE___13 = 4112,
    SFC_GET_NORM_FLOAT___13 = 4113,
    SFC_SET_NORM_DOUBLE___13 = 4114,
    SFC_SET_NORM_FLOAT___13 = 4115,
    SFC_SET_SCALE_FLOAT_INT_READ___13 = 4116,
    SFC_SET_SCALE_INT_FLOAT_WRITE___13 = 4117,
    SFC_GET_SIMPLE_FORMAT_COUNT___13 = 4128,
    SFC_GET_SIMPLE_FORMAT___13 = 4129,
    SFC_GET_FORMAT_INFO___13 = 4136,
    SFC_GET_FORMAT_MAJOR_COUNT___13 = 4144,
    SFC_GET_FORMAT_MAJOR___13 = 4145,
    SFC_GET_FORMAT_SUBTYPE_COUNT___13 = 4146,
    SFC_GET_FORMAT_SUBTYPE___13 = 4147,
    SFC_CALC_SIGNAL_MAX___13 = 4160,
    SFC_CALC_NORM_SIGNAL_MAX___13 = 4161,
    SFC_CALC_MAX_ALL_CHANNELS___13 = 4162,
    SFC_CALC_NORM_MAX_ALL_CHANNELS___13 = 4163,
    SFC_GET_SIGNAL_MAX___13 = 4164,
    SFC_GET_MAX_ALL_CHANNELS___13 = 4165,
    SFC_SET_ADD_PEAK_CHUNK___13 = 4176,
    SFC_SET_ADD_HEADER_PAD_CHUNK___13 = 4177,
    SFC_UPDATE_HEADER_NOW___13 = 4192,
    SFC_SET_UPDATE_HEADER_AUTO___13 = 4193,
    SFC_FILE_TRUNCATE___13 = 4224,
    SFC_SET_RAW_START_OFFSET___13 = 4240,
    SFC_SET_DITHER_ON_WRITE___13 = 4256,
    SFC_SET_DITHER_ON_READ___13 = 4257,
    SFC_GET_DITHER_INFO_COUNT___13 = 4258,
    SFC_GET_DITHER_INFO___13 = 4259,
    SFC_GET_EMBED_FILE_INFO___13 = 4272,
    SFC_SET_CLIPPING___13 = 4288,
    SFC_GET_CLIPPING___13 = 4289,
    SFC_GET_INSTRUMENT___13 = 4304,
    SFC_SET_INSTRUMENT___13 = 4305,
    SFC_GET_LOOP_INFO___13 = 4320,
    SFC_GET_BROADCAST_INFO___13 = 4336,
    SFC_SET_BROADCAST_INFO___13 = 4337,
    SFC_GET_CHANNEL_MAP_INFO___13 = 4352,
    SFC_SET_CHANNEL_MAP_INFO___13 = 4353,
    SFC_RAW_DATA_NEEDS_ENDSWAP___13 = 4368,
    SFC_WAVEX_SET_AMBISONIC___13 = 4608,
    SFC_WAVEX_GET_AMBISONIC___13 = 4609,
    SFC_SET_VBR_ENCODING_QUALITY___13 = 4864,
    SFC_TEST_IEEE_FLOAT_REPLACE___13 = 24577,
    SFC_SET_ADD_DITHER_ON_WRITE___13 = 4208,
    SFC_SET_ADD_DITHER_ON_READ___13 = 4209
} ;
#line 216
enum __anonenum__380 {
    SF_STR_TITLE___13 = 1,
    SF_STR_COPYRIGHT___13 = 2,
    SF_STR_SOFTWARE___13 = 3,
    SF_STR_ARTIST___13 = 4,
    SF_STR_COMMENT___13 = 5,
    SF_STR_DATE___13 = 6,
    SF_STR_ALBUM___13 = 7,
    SF_STR_LICENSE___13 = 8
} ;
#line 235
enum __anonenum__381 {
    SF_FALSE___13 = 0,
    SF_TRUE___13 = 1,
    SFM_READ___13 = 16,
    SFM_WRITE___13 = 32,
    SFM_RDWR___13 = 48,
    SF_AMBISONIC_NONE___13 = 64,
    SF_AMBISONIC_B_FORMAT___13 = 65
} ;
#line 255
enum __anonenum__382 {
    SF_ERR_NO_ERROR___13 = 0,
    SF_ERR_UNRECOGNISED_FORMAT___13 = 1,
    SF_ERR_SYSTEM___13 = 2,
    SF_ERR_MALFORMED_FILE___13 = 3,
    SF_ERR_UNSUPPORTED_ENCODING___13 = 4
} ;
#line 267
enum __anonenum__383 {
    SF_CHANNEL_MAP_INVALID___13 = 0,
    SF_CHANNEL_MAP_MONO___13 = 1,
    SF_CHANNEL_MAP_LEFT___13 = 2,
    SF_CHANNEL_MAP_RIGHT___13 = 3,
    SF_CHANNEL_MAP_CENTER___13 = 4,
    SF_CHANNEL_MAP_FRONT_LEFT___13 = 5,
    SF_CHANNEL_MAP_FRONT_RIGHT___13 = 6,
    SF_CHANNEL_MAP_FRONT_CENTER___13 = 7,
    SF_CHANNEL_MAP_REAR_CENTER___13 = 8,
    SF_CHANNEL_MAP_REAR_LEFT___13 = 9,
    SF_CHANNEL_MAP_REAR_RIGHT___13 = 10,
    SF_CHANNEL_MAP_LFE___13 = 11,
    SF_CHANNEL_MAP_FRONT_LEFT_OF_CENTER___13 = 12,
    SF_CHANNEL_MAP_FRONT_RIGHT_OF_CENTER___13 = 13,
    SF_CHANNEL_MAP_SIDE_LEFT___13 = 14,
    SF_CHANNEL_MAP_SIDE_RIGHT___13 = 15,
    SF_CHANNEL_MAP_TOP_CENTER___13 = 16,
    SF_CHANNEL_MAP_TOP_FRONT_LEFT___13 = 17,
    SF_CHANNEL_MAP_TOP_FRONT_RIGHT___13 = 18,
    SF_CHANNEL_MAP_TOP_FRONT_CENTER___13 = 19,
    SF_CHANNEL_MAP_TOP_REAR_LEFT___13 = 20,
    SF_CHANNEL_MAP_TOP_REAR_RIGHT___13 = 21,
    SF_CHANNEL_MAP_TOP_REAR_CENTER___13 = 22
} ;
#line 352
enum __anonenum__385 {
    SFD_DEFAULT_LEVEL___13 = 0,
    SFD_CUSTOM_LEVEL___13 = 1073741824,
    SFD_NO_DITHER___13 = 500,
    SFD_WHITE___13 = 501,
    SFD_TRIANGULAR_PDF___13 = 502
} ;
#line 380
enum __anonenum__388 {
    SF_LOOP_NONE___13 = 800,
    SF_LOOP_FORWARD___13 = 801,
    SF_LOOP_BACKWARD___13 = 802,
    SF_LOOP_ALTERNATING___13 = 803
} ;
#line 121 "/root/libsndfile/src/common.h"
enum __anonenum__397 {
    SF_PEAK_START___13 = 42,
    SF_PEAK_END___13 = 43,
    SF_SCALE_MAX___13 = 52,
    SF_SCALE_MIN___13 = 53,
    SF_STR_ALLOW_START___13 = 256,
    SF_STR_ALLOW_END___13 = 512,
    SF_STR_LOCATE_START___13 = 1024,
    SF_STR_LOCATE_END___13 = 2048,
    SFD_TYPEMASK___13 = 268435455
} ;
#line 149
enum __anonenum__398 {
    SF_FORMAT_TXW___13 = 67305472,
    SF_FORMAT_DWD___13 = 67371008,
    SF_FORMAT_REX___13 = 67764224,
    SF_FORMAT_REX2___13 = 67960832,
    SF_FORMAT_KRZ___13 = 68026368,
    SF_FORMAT_WMA___13 = 68157440,
    SF_FORMAT_SHN___13 = 68222976,
    SF_FORMAT_SVX_FIB___13 = 4128,
    SF_FORMAT_SVX_EXP___13 = 4129,
    SF_FORMAT_PCM_N___13 = 4144
} ;
#line 405
enum __anonenum__404 {
    SFE_NO_ERROR___13 = 0,
    SFE_BAD_OPEN_FORMAT___13 = 1,
    SFE_SYSTEM___13 = 2,
    SFE_MALFORMED_FILE___13 = 3,
    SFE_UNSUPPORTED_ENCODING___13 = 4,
    SFE_ZERO_MAJOR_FORMAT___13 = 5,
    SFE_ZERO_MINOR_FORMAT___13 = 6,
    SFE_BAD_FILE___13 = 7,
    SFE_BAD_FILE_READ___13 = 8,
    SFE_OPEN_FAILED___13 = 9,
    SFE_BAD_SNDFILE_PTR___13 = 10,
    SFE_BAD_SF_INFO_PTR___13 = 11,
    SFE_BAD_SF_INCOMPLETE___13 = 12,
    SFE_BAD_FILE_PTR___13 = 13,
    SFE_BAD_INT_PTR___13 = 14,
    SFE_BAD_STAT_SIZE___13 = 15,
    SFE_MALLOC_FAILED___13 = 16,
    SFE_UNIMPLEMENTED___13 = 17,
    SFE_BAD_READ_ALIGN___13 = 18,
    SFE_BAD_WRITE_ALIGN___13 = 19,
    SFE_UNKNOWN_FORMAT___13 = 20,
    SFE_NOT_READMODE___13 = 21,
    SFE_NOT_WRITEMODE___13 = 22,
    SFE_BAD_MODE_RW___13 = 23,
    SFE_BAD_SF_INFO___13 = 24,
    SFE_BAD_OFFSET___13 = 25,
    SFE_NO_EMBED_SUPPORT___13 = 26,
    SFE_NO_EMBEDDED_RDWR___13 = 27,
    SFE_NO_PIPE_WRITE___13 = 28,
    SFE_INTERNAL___13 = 29,
    SFE_BAD_COMMAND_PARAM___13 = 30,
    SFE_BAD_ENDIAN___13 = 31,
    SFE_CHANNEL_COUNT_ZERO___13 = 32,
    SFE_CHANNEL_COUNT___13 = 33,
    SFE_BAD_VIRTUAL_IO___13 = 34,
    SFE_INTERLEAVE_MODE___13 = 35,
    SFE_INTERLEAVE_SEEK___13 = 36,
    SFE_INTERLEAVE_READ___13 = 37,
    SFE_BAD_SEEK___13 = 38,
    SFE_NOT_SEEKABLE___13 = 39,
    SFE_AMBIGUOUS_SEEK___13 = 40,
    SFE_WRONG_SEEK___13 = 41,
    SFE_SEEK_FAILED___13 = 42,
    SFE_BAD_OPEN_MODE___13 = 43,
    SFE_OPEN_PIPE_RDWR___13 = 44,
    SFE_RDWR_POSITION___13 = 45,
    SFE_RDWR_BAD_HEADER___13 = 46,
    SFE_CMD_HAS_DATA___13 = 47,
    SFE_BAD_BROADCAST_INFO_SIZE___13 = 48,
    SFE_STR_NO_SUPPORT___13 = 49,
    SFE_STR_NOT_WRITE___13 = 50,
    SFE_STR_MAX_DATA___13 = 51,
    SFE_STR_MAX_COUNT___13 = 52,
    SFE_STR_BAD_TYPE___13 = 53,
    SFE_STR_NO_ADD_END___13 = 54,
    SFE_STR_BAD_STRING___13 = 55,
    SFE_STR_WEIRD___13 = 56,
    SFE_WAV_NO_RIFF___13 = 57,
    SFE_WAV_NO_WAVE___13 = 58,
    SFE_WAV_NO_FMT___13 = 59,
    SFE_WAV_BAD_FMT___13 = 60,
    SFE_WAV_FMT_SHORT___13 = 61,
    SFE_WAV_BAD_FACT___13 = 62,
    SFE_WAV_BAD_PEAK___13 = 63,
    SFE_WAV_PEAK_B4_FMT___13 = 64,
    SFE_WAV_BAD_FORMAT___13 = 65,
    SFE_WAV_BAD_BLOCKALIGN___13 = 66,
    SFE_WAV_NO_DATA___13 = 67,
    SFE_WAV_BAD_LIST___13 = 68,
    SFE_WAV_ADPCM_NOT4BIT___13 = 69,
    SFE_WAV_ADPCM_CHANNELS___13 = 70,
    SFE_WAV_GSM610_FORMAT___13 = 71,
    SFE_WAV_UNKNOWN_CHUNK___13 = 72,
    SFE_WAV_WVPK_DATA___13 = 73,
    SFE_AIFF_NO_FORM___13 = 74,
    SFE_AIFF_AIFF_NO_FORM___13 = 75,
    SFE_AIFF_COMM_NO_FORM___13 = 76,
    SFE_AIFF_SSND_NO_COMM___13 = 77,
    SFE_AIFF_UNKNOWN_CHUNK___13 = 78,
    SFE_AIFF_COMM_CHUNK_SIZE___13 = 79,
    SFE_AIFF_BAD_COMM_CHUNK___13 = 80,
    SFE_AIFF_PEAK_B4_COMM___13 = 81,
    SFE_AIFF_BAD_PEAK___13 = 82,
    SFE_AIFF_NO_SSND___13 = 83,
    SFE_AIFF_NO_DATA___13 = 84,
    SFE_AIFF_RW_SSND_NOT_LAST___13 = 85,
    SFE_AU_UNKNOWN_FORMAT___13 = 86,
    SFE_AU_NO_DOTSND___13 = 87,
    SFE_AU_EMBED_BAD_LEN___13 = 88,
    SFE_RAW_READ_BAD_SPEC___13 = 89,
    SFE_RAW_BAD_BITWIDTH___13 = 90,
    SFE_RAW_BAD_FORMAT___13 = 91,
    SFE_PAF_NO_MARKER___13 = 92,
    SFE_PAF_VERSION___13 = 93,
    SFE_PAF_UNKNOWN_FORMAT___13 = 94,
    SFE_PAF_SHORT_HEADER___13 = 95,
    SFE_SVX_NO_FORM___13 = 96,
    SFE_SVX_NO_BODY___13 = 97,
    SFE_SVX_NO_DATA___13 = 98,
    SFE_SVX_BAD_COMP___13 = 99,
    SFE_SVX_BAD_NAME_LENGTH___13 = 100,
    SFE_NIST_BAD_HEADER___13 = 101,
    SFE_NIST_CRLF_CONVERISON___13 = 102,
    SFE_NIST_BAD_ENCODING___13 = 103,
    SFE_VOC_NO_CREATIVE___13 = 104,
    SFE_VOC_BAD_FORMAT___13 = 105,
    SFE_VOC_BAD_VERSION___13 = 106,
    SFE_VOC_BAD_MARKER___13 = 107,
    SFE_VOC_BAD_SECTIONS___13 = 108,
    SFE_VOC_MULTI_SAMPLERATE___13 = 109,
    SFE_VOC_MULTI_SECTION___13 = 110,
    SFE_VOC_MULTI_PARAM___13 = 111,
    SFE_VOC_SECTION_COUNT___13 = 112,
    SFE_VOC_NO_PIPE___13 = 113,
    SFE_IRCAM_NO_MARKER___13 = 114,
    SFE_IRCAM_BAD_CHANNELS___13 = 115,
    SFE_IRCAM_UNKNOWN_FORMAT___13 = 116,
    SFE_W64_64_BIT___13 = 117,
    SFE_W64_NO_RIFF___13 = 118,
    SFE_W64_NO_WAVE___13 = 119,
    SFE_W64_NO_DATA___13 = 120,
    SFE_W64_ADPCM_NOT4BIT___13 = 121,
    SFE_W64_ADPCM_CHANNELS___13 = 122,
    SFE_W64_GSM610_FORMAT___13 = 123,
    SFE_MAT4_BAD_NAME___13 = 124,
    SFE_MAT4_NO_SAMPLERATE___13 = 125,
    SFE_MAT5_BAD_ENDIAN___13 = 126,
    SFE_MAT5_NO_BLOCK___13 = 127,
    SFE_MAT5_SAMPLE_RATE___13 = 128,
    SFE_PVF_NO_PVF1___13 = 129,
    SFE_PVF_BAD_HEADER___13 = 130,
    SFE_PVF_BAD_BITWIDTH___13 = 131,
    SFE_DWVW_BAD_BITWIDTH___13 = 132,
    SFE_G72X_NOT_MONO___13 = 133,
    SFE_XI_BAD_HEADER___13 = 134,
    SFE_XI_EXCESS_SAMPLES___13 = 135,
    SFE_XI_NO_PIPE___13 = 136,
    SFE_HTK_NO_PIPE___13 = 137,
    SFE_SDS_NOT_SDS___13 = 138,
    SFE_SDS_BAD_BIT_WIDTH___13 = 139,
    SFE_SD2_FD_DISALLOWED___13 = 140,
    SFE_SD2_BAD_DATA_OFFSET___13 = 141,
    SFE_SD2_BAD_MAP_OFFSET___13 = 142,
    SFE_SD2_BAD_DATA_LENGTH___13 = 143,
    SFE_SD2_BAD_MAP_LENGTH___13 = 144,
    SFE_SD2_BAD_RSRC___13 = 145,
    SFE_SD2_BAD_SAMPLE_SIZE___13 = 146,
    SFE_FLAC_BAD_HEADER___13 = 147,
    SFE_FLAC_NEW_DECODER___13 = 148,
    SFE_FLAC_INIT_DECODER___13 = 149,
    SFE_FLAC_LOST_SYNC___13 = 150,
    SFE_FLAC_BAD_SAMPLE_RATE___13 = 151,
    SFE_FLAC_UNKOWN_ERROR___13 = 152,
    SFE_WVE_NOT_WVE___13 = 153,
    SFE_WVE_NO_PIPE___13 = 154,
    SFE_VORBIS_ENCODER_BUG___13 = 155,
    SFE_RF64_NOT_RF64___13 = 156,
    SFE_MAX_ERROR___13 = 157
} ;
#line 823
enum __anonenum__408 {
    SFC_TEST_AIFF_ADD_INST_CHUNK___13 = 8192,
    SFC_TEST_WAV_ADD_INFO_CHUNK___13 = 8208
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__122___0 {
    FP_NAN___10 = 0,
    FP_INFINITE___10 = 1,
    FP_ZERO___10 = 2,
    FP_SUBNORMAL___10 = 3,
    FP_NORMAL___10 = 4
} ;
#line 46 "/root/libsndfile/src/sndfile.h"
enum __anonenum__137___0 {
    SF_FORMAT_WAV___14 = 65536,
    SF_FORMAT_AIFF___14 = 131072,
    SF_FORMAT_AU___14 = 196608,
    SF_FORMAT_RAW___14 = 262144,
    SF_FORMAT_PAF___14 = 327680,
    SF_FORMAT_SVX___14 = 393216,
    SF_FORMAT_NIST___14 = 458752,
    SF_FORMAT_VOC___14 = 524288,
    SF_FORMAT_IRCAM___14 = 655360,
    SF_FORMAT_W64___14 = 720896,
    SF_FORMAT_MAT4___14 = 786432,
    SF_FORMAT_MAT5___14 = 851968,
    SF_FORMAT_PVF___14 = 917504,
    SF_FORMAT_XI___14 = 983040,
    SF_FORMAT_HTK___14 = 1048576,
    SF_FORMAT_SDS___14 = 1114112,
    SF_FORMAT_AVR___14 = 1179648,
    SF_FORMAT_WAVEX___14 = 1245184,
    SF_FORMAT_SD2___14 = 1441792,
    SF_FORMAT_FLAC___14 = 1507328,
    SF_FORMAT_CAF___14 = 1572864,
    SF_FORMAT_WVE___14 = 1638400,
    SF_FORMAT_OGG___14 = 2097152,
    SF_FORMAT_MPC2K___14 = 2162688,
    SF_FORMAT_RF64___14 = 2228224,
    SF_FORMAT_PCM_S8___14 = 1,
    SF_FORMAT_PCM_16___14 = 2,
    SF_FORMAT_PCM_24___14 = 3,
    SF_FORMAT_PCM_32___14 = 4,
    SF_FORMAT_PCM_U8___14 = 5,
    SF_FORMAT_FLOAT___14 = 6,
    SF_FORMAT_DOUBLE___14 = 7,
    SF_FORMAT_ULAW___14 = 16,
    SF_FORMAT_ALAW___14 = 17,
    SF_FORMAT_IMA_ADPCM___14 = 18,
    SF_FORMAT_MS_ADPCM___14 = 19,
    SF_FORMAT_GSM610___14 = 32,
    SF_FORMAT_VOX_ADPCM___14 = 33,
    SF_FORMAT_G721_32___14 = 48,
    SF_FORMAT_G723_24___14 = 49,
    SF_FORMAT_G723_40___14 = 50,
    SF_FORMAT_DWVW_12___14 = 64,
    SF_FORMAT_DWVW_16___14 = 65,
    SF_FORMAT_DWVW_24___14 = 66,
    SF_FORMAT_DWVW_N___14 = 67,
    SF_FORMAT_DPCM_8___14 = 80,
    SF_FORMAT_DPCM_16___14 = 81,
    SF_FORMAT_VORBIS___14 = 96,
    SF_ENDIAN_FILE___14 = 0,
    SF_ENDIAN_LITTLE___14 = 268435456,
    SF_ENDIAN_BIG___14 = 536870912,
    SF_ENDIAN_CPU___14 = 805306368,
    SF_FORMAT_SUBMASK___14 = 65535,
    SF_FORMAT_TYPEMASK___14 = 268369920,
    SF_FORMAT_ENDMASK___14 = 805306368
} ;
#line 126
enum __anonenum__138___0 {
    SFC_GET_LIB_VERSION___14 = 4096,
    SFC_GET_LOG_INFO___14 = 4097,
    SFC_GET_CURRENT_SF_INFO___14 = 4098,
    SFC_GET_NORM_DOUBLE___14 = 4112,
    SFC_GET_NORM_FLOAT___14 = 4113,
    SFC_SET_NORM_DOUBLE___14 = 4114,
    SFC_SET_NORM_FLOAT___14 = 4115,
    SFC_SET_SCALE_FLOAT_INT_READ___14 = 4116,
    SFC_SET_SCALE_INT_FLOAT_WRITE___14 = 4117,
    SFC_GET_SIMPLE_FORMAT_COUNT___14 = 4128,
    SFC_GET_SIMPLE_FORMAT___14 = 4129,
    SFC_GET_FORMAT_INFO___14 = 4136,
    SFC_GET_FORMAT_MAJOR_COUNT___14 = 4144,
    SFC_GET_FORMAT_MAJOR___14 = 4145,
    SFC_GET_FORMAT_SUBTYPE_COUNT___14 = 4146,
    SFC_GET_FORMAT_SUBTYPE___14 = 4147,
    SFC_CALC_SIGNAL_MAX___14 = 4160,
    SFC_CALC_NORM_SIGNAL_MAX___14 = 4161,
    SFC_CALC_MAX_ALL_CHANNELS___14 = 4162,
    SFC_CALC_NORM_MAX_ALL_CHANNELS___14 = 4163,
    SFC_GET_SIGNAL_MAX___14 = 4164,
    SFC_GET_MAX_ALL_CHANNELS___14 = 4165,
    SFC_SET_ADD_PEAK_CHUNK___14 = 4176,
    SFC_SET_ADD_HEADER_PAD_CHUNK___14 = 4177,
    SFC_UPDATE_HEADER_NOW___14 = 4192,
    SFC_SET_UPDATE_HEADER_AUTO___14 = 4193,
    SFC_FILE_TRUNCATE___14 = 4224,
    SFC_SET_RAW_START_OFFSET___14 = 4240,
    SFC_SET_DITHER_ON_WRITE___14 = 4256,
    SFC_SET_DITHER_ON_READ___14 = 4257,
    SFC_GET_DITHER_INFO_COUNT___14 = 4258,
    SFC_GET_DITHER_INFO___14 = 4259,
    SFC_GET_EMBED_FILE_INFO___14 = 4272,
    SFC_SET_CLIPPING___14 = 4288,
    SFC_GET_CLIPPING___14 = 4289,
    SFC_GET_INSTRUMENT___14 = 4304,
    SFC_SET_INSTRUMENT___14 = 4305,
    SFC_GET_LOOP_INFO___14 = 4320,
    SFC_GET_BROADCAST_INFO___14 = 4336,
    SFC_SET_BROADCAST_INFO___14 = 4337,
    SFC_GET_CHANNEL_MAP_INFO___14 = 4352,
    SFC_SET_CHANNEL_MAP_INFO___14 = 4353,
    SFC_RAW_DATA_NEEDS_ENDSWAP___14 = 4368,
    SFC_WAVEX_SET_AMBISONIC___14 = 4608,
    SFC_WAVEX_GET_AMBISONIC___14 = 4609,
    SFC_SET_VBR_ENCODING_QUALITY___14 = 4864,
    SFC_TEST_IEEE_FLOAT_REPLACE___14 = 24577,
    SFC_SET_ADD_DITHER_ON_WRITE___14 = 4208,
    SFC_SET_ADD_DITHER_ON_READ___14 = 4209
} ;
#line 216
enum __anonenum__139___0 {
    SF_STR_TITLE___14 = 1,
    SF_STR_COPYRIGHT___14 = 2,
    SF_STR_SOFTWARE___14 = 3,
    SF_STR_ARTIST___14 = 4,
    SF_STR_COMMENT___14 = 5,
    SF_STR_DATE___14 = 6,
    SF_STR_ALBUM___14 = 7,
    SF_STR_LICENSE___14 = 8
} ;
#line 235
enum __anonenum__140___0 {
    SF_FALSE___14 = 0,
    SF_TRUE___14 = 1,
    SFM_READ___14 = 16,
    SFM_WRITE___14 = 32,
    SFM_RDWR___14 = 48,
    SF_AMBISONIC_NONE___14 = 64,
    SF_AMBISONIC_B_FORMAT___14 = 65
} ;
#line 255
enum __anonenum__141___0 {
    SF_ERR_NO_ERROR___14 = 0,
    SF_ERR_UNRECOGNISED_FORMAT___14 = 1,
    SF_ERR_SYSTEM___14 = 2,
    SF_ERR_MALFORMED_FILE___14 = 3,
    SF_ERR_UNSUPPORTED_ENCODING___14 = 4
} ;
#line 267
enum __anonenum__142___0 {
    SF_CHANNEL_MAP_INVALID___14 = 0,
    SF_CHANNEL_MAP_MONO___14 = 1,
    SF_CHANNEL_MAP_LEFT___14 = 2,
    SF_CHANNEL_MAP_RIGHT___14 = 3,
    SF_CHANNEL_MAP_CENTER___14 = 4,
    SF_CHANNEL_MAP_FRONT_LEFT___14 = 5,
    SF_CHANNEL_MAP_FRONT_RIGHT___14 = 6,
    SF_CHANNEL_MAP_FRONT_CENTER___14 = 7,
    SF_CHANNEL_MAP_REAR_CENTER___14 = 8,
    SF_CHANNEL_MAP_REAR_LEFT___14 = 9,
    SF_CHANNEL_MAP_REAR_RIGHT___14 = 10,
    SF_CHANNEL_MAP_LFE___14 = 11,
    SF_CHANNEL_MAP_FRONT_LEFT_OF_CENTER___14 = 12,
    SF_CHANNEL_MAP_FRONT_RIGHT_OF_CENTER___14 = 13,
    SF_CHANNEL_MAP_SIDE_LEFT___14 = 14,
    SF_CHANNEL_MAP_SIDE_RIGHT___14 = 15,
    SF_CHANNEL_MAP_TOP_CENTER___14 = 16,
    SF_CHANNEL_MAP_TOP_FRONT_LEFT___14 = 17,
    SF_CHANNEL_MAP_TOP_FRONT_RIGHT___14 = 18,
    SF_CHANNEL_MAP_TOP_FRONT_CENTER___14 = 19,
    SF_CHANNEL_MAP_TOP_REAR_LEFT___14 = 20,
    SF_CHANNEL_MAP_TOP_REAR_RIGHT___14 = 21,
    SF_CHANNEL_MAP_TOP_REAR_CENTER___14 = 22
} ;
#line 352
enum __anonenum__144___0 {
    SFD_DEFAULT_LEVEL___14 = 0,
    SFD_CUSTOM_LEVEL___14 = 1073741824,
    SFD_NO_DITHER___14 = 500,
    SFD_WHITE___14 = 501,
    SFD_TRIANGULAR_PDF___14 = 502
} ;
#line 380
enum __anonenum__147___0 {
    SF_LOOP_NONE___14 = 800,
    SF_LOOP_FORWARD___14 = 801,
    SF_LOOP_BACKWARD___14 = 802,
    SF_LOOP_ALTERNATING___14 = 803
} ;
#line 121 "/root/libsndfile/src/common.h"
enum __anonenum__156___0 {
    SF_PEAK_START___14 = 42,
    SF_PEAK_END___14 = 43,
    SF_SCALE_MAX___14 = 52,
    SF_SCALE_MIN___14 = 53,
    SF_STR_ALLOW_START___14 = 256,
    SF_STR_ALLOW_END___14 = 512,
    SF_STR_LOCATE_START___14 = 1024,
    SF_STR_LOCATE_END___14 = 2048,
    SFD_TYPEMASK___14 = 268435455
} ;
#line 149
enum __anonenum__157___0 {
    SF_FORMAT_TXW___14 = 67305472,
    SF_FORMAT_DWD___14 = 67371008,
    SF_FORMAT_REX___14 = 67764224,
    SF_FORMAT_REX2___14 = 67960832,
    SF_FORMAT_KRZ___14 = 68026368,
    SF_FORMAT_WMA___14 = 68157440,
    SF_FORMAT_SHN___14 = 68222976,
    SF_FORMAT_SVX_FIB___14 = 4128,
    SF_FORMAT_SVX_EXP___14 = 4129,
    SF_FORMAT_PCM_N___14 = 4144
} ;
#line 405
enum __anonenum__163___0 {
    SFE_NO_ERROR___14 = 0,
    SFE_BAD_OPEN_FORMAT___14 = 1,
    SFE_SYSTEM___14 = 2,
    SFE_MALFORMED_FILE___14 = 3,
    SFE_UNSUPPORTED_ENCODING___14 = 4,
    SFE_ZERO_MAJOR_FORMAT___14 = 5,
    SFE_ZERO_MINOR_FORMAT___14 = 6,
    SFE_BAD_FILE___14 = 7,
    SFE_BAD_FILE_READ___14 = 8,
    SFE_OPEN_FAILED___14 = 9,
    SFE_BAD_SNDFILE_PTR___14 = 10,
    SFE_BAD_SF_INFO_PTR___14 = 11,
    SFE_BAD_SF_INCOMPLETE___14 = 12,
    SFE_BAD_FILE_PTR___14 = 13,
    SFE_BAD_INT_PTR___14 = 14,
    SFE_BAD_STAT_SIZE___14 = 15,
    SFE_MALLOC_FAILED___14 = 16,
    SFE_UNIMPLEMENTED___14 = 17,
    SFE_BAD_READ_ALIGN___14 = 18,
    SFE_BAD_WRITE_ALIGN___14 = 19,
    SFE_UNKNOWN_FORMAT___14 = 20,
    SFE_NOT_READMODE___14 = 21,
    SFE_NOT_WRITEMODE___14 = 22,
    SFE_BAD_MODE_RW___14 = 23,
    SFE_BAD_SF_INFO___14 = 24,
    SFE_BAD_OFFSET___14 = 25,
    SFE_NO_EMBED_SUPPORT___14 = 26,
    SFE_NO_EMBEDDED_RDWR___14 = 27,
    SFE_NO_PIPE_WRITE___14 = 28,
    SFE_INTERNAL___14 = 29,
    SFE_BAD_COMMAND_PARAM___14 = 30,
    SFE_BAD_ENDIAN___14 = 31,
    SFE_CHANNEL_COUNT_ZERO___14 = 32,
    SFE_CHANNEL_COUNT___14 = 33,
    SFE_BAD_VIRTUAL_IO___14 = 34,
    SFE_INTERLEAVE_MODE___14 = 35,
    SFE_INTERLEAVE_SEEK___14 = 36,
    SFE_INTERLEAVE_READ___14 = 37,
    SFE_BAD_SEEK___14 = 38,
    SFE_NOT_SEEKABLE___14 = 39,
    SFE_AMBIGUOUS_SEEK___14 = 40,
    SFE_WRONG_SEEK___14 = 41,
    SFE_SEEK_FAILED___14 = 42,
    SFE_BAD_OPEN_MODE___14 = 43,
    SFE_OPEN_PIPE_RDWR___14 = 44,
    SFE_RDWR_POSITION___14 = 45,
    SFE_RDWR_BAD_HEADER___14 = 46,
    SFE_CMD_HAS_DATA___14 = 47,
    SFE_BAD_BROADCAST_INFO_SIZE___14 = 48,
    SFE_STR_NO_SUPPORT___14 = 49,
    SFE_STR_NOT_WRITE___14 = 50,
    SFE_STR_MAX_DATA___14 = 51,
    SFE_STR_MAX_COUNT___14 = 52,
    SFE_STR_BAD_TYPE___14 = 53,
    SFE_STR_NO_ADD_END___14 = 54,
    SFE_STR_BAD_STRING___14 = 55,
    SFE_STR_WEIRD___14 = 56,
    SFE_WAV_NO_RIFF___14 = 57,
    SFE_WAV_NO_WAVE___14 = 58,
    SFE_WAV_NO_FMT___14 = 59,
    SFE_WAV_BAD_FMT___14 = 60,
    SFE_WAV_FMT_SHORT___14 = 61,
    SFE_WAV_BAD_FACT___14 = 62,
    SFE_WAV_BAD_PEAK___14 = 63,
    SFE_WAV_PEAK_B4_FMT___14 = 64,
    SFE_WAV_BAD_FORMAT___14 = 65,
    SFE_WAV_BAD_BLOCKALIGN___14 = 66,
    SFE_WAV_NO_DATA___14 = 67,
    SFE_WAV_BAD_LIST___14 = 68,
    SFE_WAV_ADPCM_NOT4BIT___14 = 69,
    SFE_WAV_ADPCM_CHANNELS___14 = 70,
    SFE_WAV_GSM610_FORMAT___14 = 71,
    SFE_WAV_UNKNOWN_CHUNK___14 = 72,
    SFE_WAV_WVPK_DATA___14 = 73,
    SFE_AIFF_NO_FORM___14 = 74,
    SFE_AIFF_AIFF_NO_FORM___14 = 75,
    SFE_AIFF_COMM_NO_FORM___14 = 76,
    SFE_AIFF_SSND_NO_COMM___14 = 77,
    SFE_AIFF_UNKNOWN_CHUNK___14 = 78,
    SFE_AIFF_COMM_CHUNK_SIZE___14 = 79,
    SFE_AIFF_BAD_COMM_CHUNK___14 = 80,
    SFE_AIFF_PEAK_B4_COMM___14 = 81,
    SFE_AIFF_BAD_PEAK___14 = 82,
    SFE_AIFF_NO_SSND___14 = 83,
    SFE_AIFF_NO_DATA___14 = 84,
    SFE_AIFF_RW_SSND_NOT_LAST___14 = 85,
    SFE_AU_UNKNOWN_FORMAT___14 = 86,
    SFE_AU_NO_DOTSND___14 = 87,
    SFE_AU_EMBED_BAD_LEN___14 = 88,
    SFE_RAW_READ_BAD_SPEC___14 = 89,
    SFE_RAW_BAD_BITWIDTH___14 = 90,
    SFE_RAW_BAD_FORMAT___14 = 91,
    SFE_PAF_NO_MARKER___14 = 92,
    SFE_PAF_VERSION___14 = 93,
    SFE_PAF_UNKNOWN_FORMAT___14 = 94,
    SFE_PAF_SHORT_HEADER___14 = 95,
    SFE_SVX_NO_FORM___14 = 96,
    SFE_SVX_NO_BODY___14 = 97,
    SFE_SVX_NO_DATA___14 = 98,
    SFE_SVX_BAD_COMP___14 = 99,
    SFE_SVX_BAD_NAME_LENGTH___14 = 100,
    SFE_NIST_BAD_HEADER___14 = 101,
    SFE_NIST_CRLF_CONVERISON___14 = 102,
    SFE_NIST_BAD_ENCODING___14 = 103,
    SFE_VOC_NO_CREATIVE___14 = 104,
    SFE_VOC_BAD_FORMAT___14 = 105,
    SFE_VOC_BAD_VERSION___14 = 106,
    SFE_VOC_BAD_MARKER___14 = 107,
    SFE_VOC_BAD_SECTIONS___14 = 108,
    SFE_VOC_MULTI_SAMPLERATE___14 = 109,
    SFE_VOC_MULTI_SECTION___14 = 110,
    SFE_VOC_MULTI_PARAM___14 = 111,
    SFE_VOC_SECTION_COUNT___14 = 112,
    SFE_VOC_NO_PIPE___14 = 113,
    SFE_IRCAM_NO_MARKER___14 = 114,
    SFE_IRCAM_BAD_CHANNELS___14 = 115,
    SFE_IRCAM_UNKNOWN_FORMAT___14 = 116,
    SFE_W64_64_BIT___14 = 117,
    SFE_W64_NO_RIFF___14 = 118,
    SFE_W64_NO_WAVE___14 = 119,
    SFE_W64_NO_DATA___14 = 120,
    SFE_W64_ADPCM_NOT4BIT___14 = 121,
    SFE_W64_ADPCM_CHANNELS___14 = 122,
    SFE_W64_GSM610_FORMAT___14 = 123,
    SFE_MAT4_BAD_NAME___14 = 124,
    SFE_MAT4_NO_SAMPLERATE___14 = 125,
    SFE_MAT5_BAD_ENDIAN___14 = 126,
    SFE_MAT5_NO_BLOCK___14 = 127,
    SFE_MAT5_SAMPLE_RATE___14 = 128,
    SFE_PVF_NO_PVF1___14 = 129,
    SFE_PVF_BAD_HEADER___14 = 130,
    SFE_PVF_BAD_BITWIDTH___14 = 131,
    SFE_DWVW_BAD_BITWIDTH___14 = 132,
    SFE_G72X_NOT_MONO___14 = 133,
    SFE_XI_BAD_HEADER___14 = 134,
    SFE_XI_EXCESS_SAMPLES___14 = 135,
    SFE_XI_NO_PIPE___14 = 136,
    SFE_HTK_NO_PIPE___14 = 137,
    SFE_SDS_NOT_SDS___14 = 138,
    SFE_SDS_BAD_BIT_WIDTH___14 = 139,
    SFE_SD2_FD_DISALLOWED___14 = 140,
    SFE_SD2_BAD_DATA_OFFSET___14 = 141,
    SFE_SD2_BAD_MAP_OFFSET___14 = 142,
    SFE_SD2_BAD_DATA_LENGTH___14 = 143,
    SFE_SD2_BAD_MAP_LENGTH___14 = 144,
    SFE_SD2_BAD_RSRC___14 = 145,
    SFE_SD2_BAD_SAMPLE_SIZE___14 = 146,
    SFE_FLAC_BAD_HEADER___14 = 147,
    SFE_FLAC_NEW_DECODER___14 = 148,
    SFE_FLAC_INIT_DECODER___14 = 149,
    SFE_FLAC_LOST_SYNC___14 = 150,
    SFE_FLAC_BAD_SAMPLE_RATE___14 = 151,
    SFE_FLAC_UNKOWN_ERROR___14 = 152,
    SFE_WVE_NOT_WVE___14 = 153,
    SFE_WVE_NO_PIPE___14 = 154,
    SFE_VORBIS_ENCODER_BUG___14 = 155,
    SFE_RF64_NOT_RF64___14 = 156,
    SFE_MAX_ERROR___14 = 157
} ;
#line 823
enum __anonenum__167___0 {
    SFC_TEST_AIFF_ADD_INST_CHUNK___14 = 8192,
    SFC_TEST_WAV_ADD_INFO_CHUNK___14 = 8208
} ;
#line 46 "/root/libsndfile/src/sndfile.h"
enum __anonenum__411 {
    SF_FORMAT_WAV___15 = 65536,
    SF_FORMAT_AIFF___15 = 131072,
    SF_FORMAT_AU___15 = 196608,
    SF_FORMAT_RAW___15 = 262144,
    SF_FORMAT_PAF___15 = 327680,
    SF_FORMAT_SVX___15 = 393216,
    SF_FORMAT_NIST___15 = 458752,
    SF_FORMAT_VOC___15 = 524288,
    SF_FORMAT_IRCAM___15 = 655360,
    SF_FORMAT_W64___15 = 720896,
    SF_FORMAT_MAT4___15 = 786432,
    SF_FORMAT_MAT5___15 = 851968,
    SF_FORMAT_PVF___15 = 917504,
    SF_FORMAT_XI___15 = 983040,
    SF_FORMAT_HTK___15 = 1048576,
    SF_FORMAT_SDS___15 = 1114112,
    SF_FORMAT_AVR___15 = 1179648,
    SF_FORMAT_WAVEX___15 = 1245184,
    SF_FORMAT_SD2___15 = 1441792,
    SF_FORMAT_FLAC___15 = 1507328,
    SF_FORMAT_CAF___15 = 1572864,
    SF_FORMAT_WVE___15 = 1638400,
    SF_FORMAT_OGG___15 = 2097152,
    SF_FORMAT_MPC2K___15 = 2162688,
    SF_FORMAT_RF64___15 = 2228224,
    SF_FORMAT_PCM_S8___15 = 1,
    SF_FORMAT_PCM_16___15 = 2,
    SF_FORMAT_PCM_24___15 = 3,
    SF_FORMAT_PCM_32___15 = 4,
    SF_FORMAT_PCM_U8___15 = 5,
    SF_FORMAT_FLOAT___15 = 6,
    SF_FORMAT_DOUBLE___15 = 7,
    SF_FORMAT_ULAW___15 = 16,
    SF_FORMAT_ALAW___15 = 17,
    SF_FORMAT_IMA_ADPCM___15 = 18,
    SF_FORMAT_MS_ADPCM___15 = 19,
    SF_FORMAT_GSM610___15 = 32,
    SF_FORMAT_VOX_ADPCM___15 = 33,
    SF_FORMAT_G721_32___15 = 48,
    SF_FORMAT_G723_24___15 = 49,
    SF_FORMAT_G723_40___15 = 50,
    SF_FORMAT_DWVW_12___15 = 64,
    SF_FORMAT_DWVW_16___15 = 65,
    SF_FORMAT_DWVW_24___15 = 66,
    SF_FORMAT_DWVW_N___15 = 67,
    SF_FORMAT_DPCM_8___15 = 80,
    SF_FORMAT_DPCM_16___15 = 81,
    SF_FORMAT_VORBIS___15 = 96,
    SF_ENDIAN_FILE___15 = 0,
    SF_ENDIAN_LITTLE___15 = 268435456,
    SF_ENDIAN_BIG___15 = 536870912,
    SF_ENDIAN_CPU___15 = 805306368,
    SF_FORMAT_SUBMASK___15 = 65535,
    SF_FORMAT_TYPEMASK___15 = 268369920,
    SF_FORMAT_ENDMASK___15 = 805306368
} ;
#line 126
enum __anonenum__412 {
    SFC_GET_LIB_VERSION___15 = 4096,
    SFC_GET_LOG_INFO___15 = 4097,
    SFC_GET_CURRENT_SF_INFO___15 = 4098,
    SFC_GET_NORM_DOUBLE___15 = 4112,
    SFC_GET_NORM_FLOAT___15 = 4113,
    SFC_SET_NORM_DOUBLE___15 = 4114,
    SFC_SET_NORM_FLOAT___15 = 4115,
    SFC_SET_SCALE_FLOAT_INT_READ___15 = 4116,
    SFC_SET_SCALE_INT_FLOAT_WRITE___15 = 4117,
    SFC_GET_SIMPLE_FORMAT_COUNT___15 = 4128,
    SFC_GET_SIMPLE_FORMAT___15 = 4129,
    SFC_GET_FORMAT_INFO___15 = 4136,
    SFC_GET_FORMAT_MAJOR_COUNT___15 = 4144,
    SFC_GET_FORMAT_MAJOR___15 = 4145,
    SFC_GET_FORMAT_SUBTYPE_COUNT___15 = 4146,
    SFC_GET_FORMAT_SUBTYPE___15 = 4147,
    SFC_CALC_SIGNAL_MAX___15 = 4160,
    SFC_CALC_NORM_SIGNAL_MAX___15 = 4161,
    SFC_CALC_MAX_ALL_CHANNELS___15 = 4162,
    SFC_CALC_NORM_MAX_ALL_CHANNELS___15 = 4163,
    SFC_GET_SIGNAL_MAX___15 = 4164,
    SFC_GET_MAX_ALL_CHANNELS___15 = 4165,
    SFC_SET_ADD_PEAK_CHUNK___15 = 4176,
    SFC_SET_ADD_HEADER_PAD_CHUNK___15 = 4177,
    SFC_UPDATE_HEADER_NOW___15 = 4192,
    SFC_SET_UPDATE_HEADER_AUTO___15 = 4193,
    SFC_FILE_TRUNCATE___15 = 4224,
    SFC_SET_RAW_START_OFFSET___15 = 4240,
    SFC_SET_DITHER_ON_WRITE___15 = 4256,
    SFC_SET_DITHER_ON_READ___15 = 4257,
    SFC_GET_DITHER_INFO_COUNT___15 = 4258,
    SFC_GET_DITHER_INFO___15 = 4259,
    SFC_GET_EMBED_FILE_INFO___15 = 4272,
    SFC_SET_CLIPPING___15 = 4288,
    SFC_GET_CLIPPING___15 = 4289,
    SFC_GET_INSTRUMENT___15 = 4304,
    SFC_SET_INSTRUMENT___15 = 4305,
    SFC_GET_LOOP_INFO___15 = 4320,
    SFC_GET_BROADCAST_INFO___15 = 4336,
    SFC_SET_BROADCAST_INFO___15 = 4337,
    SFC_GET_CHANNEL_MAP_INFO___15 = 4352,
    SFC_SET_CHANNEL_MAP_INFO___15 = 4353,
    SFC_RAW_DATA_NEEDS_ENDSWAP___15 = 4368,
    SFC_WAVEX_SET_AMBISONIC___15 = 4608,
    SFC_WAVEX_GET_AMBISONIC___15 = 4609,
    SFC_SET_VBR_ENCODING_QUALITY___15 = 4864,
    SFC_TEST_IEEE_FLOAT_REPLACE___15 = 24577,
    SFC_SET_ADD_DITHER_ON_WRITE___15 = 4208,
    SFC_SET_ADD_DITHER_ON_READ___15 = 4209
} ;
#line 216
enum __anonenum__413 {
    SF_STR_TITLE___15 = 1,
    SF_STR_COPYRIGHT___15 = 2,
    SF_STR_SOFTWARE___15 = 3,
    SF_STR_ARTIST___15 = 4,
    SF_STR_COMMENT___15 = 5,
    SF_STR_DATE___15 = 6,
    SF_STR_ALBUM___15 = 7,
    SF_STR_LICENSE___15 = 8
} ;
#line 235
enum __anonenum__414 {
    SF_FALSE___15 = 0,
    SF_TRUE___15 = 1,
    SFM_READ___15 = 16,
    SFM_WRITE___15 = 32,
    SFM_RDWR___15 = 48,
    SF_AMBISONIC_NONE___15 = 64,
    SF_AMBISONIC_B_FORMAT___15 = 65
} ;
#line 255
enum __anonenum__415 {
    SF_ERR_NO_ERROR___15 = 0,
    SF_ERR_UNRECOGNISED_FORMAT___15 = 1,
    SF_ERR_SYSTEM___15 = 2,
    SF_ERR_MALFORMED_FILE___15 = 3,
    SF_ERR_UNSUPPORTED_ENCODING___15 = 4
} ;
#line 267
enum __anonenum__416 {
    SF_CHANNEL_MAP_INVALID___15 = 0,
    SF_CHANNEL_MAP_MONO___15 = 1,
    SF_CHANNEL_MAP_LEFT___15 = 2,
    SF_CHANNEL_MAP_RIGHT___15 = 3,
    SF_CHANNEL_MAP_CENTER___15 = 4,
    SF_CHANNEL_MAP_FRONT_LEFT___15 = 5,
    SF_CHANNEL_MAP_FRONT_RIGHT___15 = 6,
    SF_CHANNEL_MAP_FRONT_CENTER___15 = 7,
    SF_CHANNEL_MAP_REAR_CENTER___15 = 8,
    SF_CHANNEL_MAP_REAR_LEFT___15 = 9,
    SF_CHANNEL_MAP_REAR_RIGHT___15 = 10,
    SF_CHANNEL_MAP_LFE___15 = 11,
    SF_CHANNEL_MAP_FRONT_LEFT_OF_CENTER___15 = 12,
    SF_CHANNEL_MAP_FRONT_RIGHT_OF_CENTER___15 = 13,
    SF_CHANNEL_MAP_SIDE_LEFT___15 = 14,
    SF_CHANNEL_MAP_SIDE_RIGHT___15 = 15,
    SF_CHANNEL_MAP_TOP_CENTER___15 = 16,
    SF_CHANNEL_MAP_TOP_FRONT_LEFT___15 = 17,
    SF_CHANNEL_MAP_TOP_FRONT_RIGHT___15 = 18,
    SF_CHANNEL_MAP_TOP_FRONT_CENTER___15 = 19,
    SF_CHANNEL_MAP_TOP_REAR_LEFT___15 = 20,
    SF_CHANNEL_MAP_TOP_REAR_RIGHT___15 = 21,
    SF_CHANNEL_MAP_TOP_REAR_CENTER___15 = 22
} ;
#line 352
enum __anonenum__418 {
    SFD_DEFAULT_LEVEL___15 = 0,
    SFD_CUSTOM_LEVEL___15 = 1073741824,
    SFD_NO_DITHER___15 = 500,
    SFD_WHITE___15 = 501,
    SFD_TRIANGULAR_PDF___15 = 502
} ;
#line 380
enum __anonenum__421 {
    SF_LOOP_NONE___15 = 800,
    SF_LOOP_FORWARD___15 = 801,
    SF_LOOP_BACKWARD___15 = 802,
    SF_LOOP_ALTERNATING___15 = 803
} ;
#line 121 "/root/libsndfile/src/common.h"
enum __anonenum__425 {
    SF_PEAK_START___15 = 42,
    SF_PEAK_END___15 = 43,
    SF_SCALE_MAX___15 = 52,
    SF_SCALE_MIN___15 = 53,
    SF_STR_ALLOW_START___15 = 256,
    SF_STR_ALLOW_END___15 = 512,
    SF_STR_LOCATE_START___15 = 1024,
    SF_STR_LOCATE_END___15 = 2048,
    SFD_TYPEMASK___15 = 268435455
} ;
#line 149
enum __anonenum__426 {
    SF_FORMAT_TXW___15 = 67305472,
    SF_FORMAT_DWD___15 = 67371008,
    SF_FORMAT_REX___15 = 67764224,
    SF_FORMAT_REX2___15 = 67960832,
    SF_FORMAT_KRZ___15 = 68026368,
    SF_FORMAT_WMA___15 = 68157440,
    SF_FORMAT_SHN___15 = 68222976,
    SF_FORMAT_SVX_FIB___15 = 4128,
    SF_FORMAT_SVX_EXP___15 = 4129,
    SF_FORMAT_PCM_N___15 = 4144
} ;
#line 405
enum __anonenum__432 {
    SFE_NO_ERROR___15 = 0,
    SFE_BAD_OPEN_FORMAT___15 = 1,
    SFE_SYSTEM___15 = 2,
    SFE_MALFORMED_FILE___15 = 3,
    SFE_UNSUPPORTED_ENCODING___15 = 4,
    SFE_ZERO_MAJOR_FORMAT___15 = 5,
    SFE_ZERO_MINOR_FORMAT___15 = 6,
    SFE_BAD_FILE___15 = 7,
    SFE_BAD_FILE_READ___15 = 8,
    SFE_OPEN_FAILED___15 = 9,
    SFE_BAD_SNDFILE_PTR___15 = 10,
    SFE_BAD_SF_INFO_PTR___15 = 11,
    SFE_BAD_SF_INCOMPLETE___15 = 12,
    SFE_BAD_FILE_PTR___15 = 13,
    SFE_BAD_INT_PTR___15 = 14,
    SFE_BAD_STAT_SIZE___15 = 15,
    SFE_MALLOC_FAILED___15 = 16,
    SFE_UNIMPLEMENTED___15 = 17,
    SFE_BAD_READ_ALIGN___15 = 18,
    SFE_BAD_WRITE_ALIGN___15 = 19,
    SFE_UNKNOWN_FORMAT___15 = 20,
    SFE_NOT_READMODE___15 = 21,
    SFE_NOT_WRITEMODE___15 = 22,
    SFE_BAD_MODE_RW___15 = 23,
    SFE_BAD_SF_INFO___15 = 24,
    SFE_BAD_OFFSET___15 = 25,
    SFE_NO_EMBED_SUPPORT___15 = 26,
    SFE_NO_EMBEDDED_RDWR___15 = 27,
    SFE_NO_PIPE_WRITE___15 = 28,
    SFE_INTERNAL___15 = 29,
    SFE_BAD_COMMAND_PARAM___15 = 30,
    SFE_BAD_ENDIAN___15 = 31,
    SFE_CHANNEL_COUNT_ZERO___15 = 32,
    SFE_CHANNEL_COUNT___15 = 33,
    SFE_BAD_VIRTUAL_IO___15 = 34,
    SFE_INTERLEAVE_MODE___15 = 35,
    SFE_INTERLEAVE_SEEK___15 = 36,
    SFE_INTERLEAVE_READ___15 = 37,
    SFE_BAD_SEEK___15 = 38,
    SFE_NOT_SEEKABLE___15 = 39,
    SFE_AMBIGUOUS_SEEK___15 = 40,
    SFE_WRONG_SEEK___15 = 41,
    SFE_SEEK_FAILED___15 = 42,
    SFE_BAD_OPEN_MODE___15 = 43,
    SFE_OPEN_PIPE_RDWR___15 = 44,
    SFE_RDWR_POSITION___15 = 45,
    SFE_RDWR_BAD_HEADER___15 = 46,
    SFE_CMD_HAS_DATA___15 = 47,
    SFE_BAD_BROADCAST_INFO_SIZE___15 = 48,
    SFE_STR_NO_SUPPORT___15 = 49,
    SFE_STR_NOT_WRITE___15 = 50,
    SFE_STR_MAX_DATA___15 = 51,
    SFE_STR_MAX_COUNT___15 = 52,
    SFE_STR_BAD_TYPE___15 = 53,
    SFE_STR_NO_ADD_END___15 = 54,
    SFE_STR_BAD_STRING___15 = 55,
    SFE_STR_WEIRD___15 = 56,
    SFE_WAV_NO_RIFF___15 = 57,
    SFE_WAV_NO_WAVE___15 = 58,
    SFE_WAV_NO_FMT___15 = 59,
    SFE_WAV_BAD_FMT___15 = 60,
    SFE_WAV_FMT_SHORT___15 = 61,
    SFE_WAV_BAD_FACT___15 = 62,
    SFE_WAV_BAD_PEAK___15 = 63,
    SFE_WAV_PEAK_B4_FMT___15 = 64,
    SFE_WAV_BAD_FORMAT___15 = 65,
    SFE_WAV_BAD_BLOCKALIGN___15 = 66,
    SFE_WAV_NO_DATA___15 = 67,
    SFE_WAV_BAD_LIST___15 = 68,
    SFE_WAV_ADPCM_NOT4BIT___15 = 69,
    SFE_WAV_ADPCM_CHANNELS___15 = 70,
    SFE_WAV_GSM610_FORMAT___15 = 71,
    SFE_WAV_UNKNOWN_CHUNK___15 = 72,
    SFE_WAV_WVPK_DATA___15 = 73,
    SFE_AIFF_NO_FORM___15 = 74,
    SFE_AIFF_AIFF_NO_FORM___15 = 75,
    SFE_AIFF_COMM_NO_FORM___15 = 76,
    SFE_AIFF_SSND_NO_COMM___15 = 77,
    SFE_AIFF_UNKNOWN_CHUNK___15 = 78,
    SFE_AIFF_COMM_CHUNK_SIZE___15 = 79,
    SFE_AIFF_BAD_COMM_CHUNK___15 = 80,
    SFE_AIFF_PEAK_B4_COMM___15 = 81,
    SFE_AIFF_BAD_PEAK___15 = 82,
    SFE_AIFF_NO_SSND___15 = 83,
    SFE_AIFF_NO_DATA___15 = 84,
    SFE_AIFF_RW_SSND_NOT_LAST___15 = 85,
    SFE_AU_UNKNOWN_FORMAT___15 = 86,
    SFE_AU_NO_DOTSND___15 = 87,
    SFE_AU_EMBED_BAD_LEN___15 = 88,
    SFE_RAW_READ_BAD_SPEC___15 = 89,
    SFE_RAW_BAD_BITWIDTH___15 = 90,
    SFE_RAW_BAD_FORMAT___15 = 91,
    SFE_PAF_NO_MARKER___15 = 92,
    SFE_PAF_VERSION___15 = 93,
    SFE_PAF_UNKNOWN_FORMAT___15 = 94,
    SFE_PAF_SHORT_HEADER___15 = 95,
    SFE_SVX_NO_FORM___15 = 96,
    SFE_SVX_NO_BODY___15 = 97,
    SFE_SVX_NO_DATA___15 = 98,
    SFE_SVX_BAD_COMP___15 = 99,
    SFE_SVX_BAD_NAME_LENGTH___15 = 100,
    SFE_NIST_BAD_HEADER___15 = 101,
    SFE_NIST_CRLF_CONVERISON___15 = 102,
    SFE_NIST_BAD_ENCODING___15 = 103,
    SFE_VOC_NO_CREATIVE___15 = 104,
    SFE_VOC_BAD_FORMAT___15 = 105,
    SFE_VOC_BAD_VERSION___15 = 106,
    SFE_VOC_BAD_MARKER___15 = 107,
    SFE_VOC_BAD_SECTIONS___15 = 108,
    SFE_VOC_MULTI_SAMPLERATE___15 = 109,
    SFE_VOC_MULTI_SECTION___15 = 110,
    SFE_VOC_MULTI_PARAM___15 = 111,
    SFE_VOC_SECTION_COUNT___15 = 112,
    SFE_VOC_NO_PIPE___15 = 113,
    SFE_IRCAM_NO_MARKER___15 = 114,
    SFE_IRCAM_BAD_CHANNELS___15 = 115,
    SFE_IRCAM_UNKNOWN_FORMAT___15 = 116,
    SFE_W64_64_BIT___15 = 117,
    SFE_W64_NO_RIFF___15 = 118,
    SFE_W64_NO_WAVE___15 = 119,
    SFE_W64_NO_DATA___15 = 120,
    SFE_W64_ADPCM_NOT4BIT___15 = 121,
    SFE_W64_ADPCM_CHANNELS___15 = 122,
    SFE_W64_GSM610_FORMAT___15 = 123,
    SFE_MAT4_BAD_NAME___15 = 124,
    SFE_MAT4_NO_SAMPLERATE___15 = 125,
    SFE_MAT5_BAD_ENDIAN___15 = 126,
    SFE_MAT5_NO_BLOCK___15 = 127,
    SFE_MAT5_SAMPLE_RATE___15 = 128,
    SFE_PVF_NO_PVF1___15 = 129,
    SFE_PVF_BAD_HEADER___15 = 130,
    SFE_PVF_BAD_BITWIDTH___15 = 131,
    SFE_DWVW_BAD_BITWIDTH___15 = 132,
    SFE_G72X_NOT_MONO___15 = 133,
    SFE_XI_BAD_HEADER___15 = 134,
    SFE_XI_EXCESS_SAMPLES___15 = 135,
    SFE_XI_NO_PIPE___15 = 136,
    SFE_HTK_NO_PIPE___15 = 137,
    SFE_SDS_NOT_SDS___15 = 138,
    SFE_SDS_BAD_BIT_WIDTH___15 = 139,
    SFE_SD2_FD_DISALLOWED___15 = 140,
    SFE_SD2_BAD_DATA_OFFSET___15 = 141,
    SFE_SD2_BAD_MAP_OFFSET___15 = 142,
    SFE_SD2_BAD_DATA_LENGTH___15 = 143,
    SFE_SD2_BAD_MAP_LENGTH___15 = 144,
    SFE_SD2_BAD_RSRC___15 = 145,
    SFE_SD2_BAD_SAMPLE_SIZE___15 = 146,
    SFE_FLAC_BAD_HEADER___15 = 147,
    SFE_FLAC_NEW_DECODER___15 = 148,
    SFE_FLAC_INIT_DECODER___15 = 149,
    SFE_FLAC_LOST_SYNC___15 = 150,
    SFE_FLAC_BAD_SAMPLE_RATE___15 = 151,
    SFE_FLAC_UNKOWN_ERROR___15 = 152,
    SFE_WVE_NOT_WVE___15 = 153,
    SFE_WVE_NO_PIPE___15 = 154,
    SFE_VORBIS_ENCODER_BUG___15 = 155,
    SFE_RF64_NOT_RF64___15 = 156,
    SFE_MAX_ERROR___15 = 157
} ;
#line 823
enum __anonenum__436 {
    SFC_TEST_AIFF_ADD_INST_CHUNK___15 = 8192,
    SFC_TEST_WAV_ADD_INFO_CHUNK___15 = 8208
} ;
#line 149 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stddef.h"
typedef long ptrdiff_t;
#line 46 "/root/libsndfile/src/sndfile.h"
enum __anonenum__455 {
    SF_FORMAT_WAV___16 = 65536,
    SF_FORMAT_AIFF___16 = 131072,
    SF_FORMAT_AU___16 = 196608,
    SF_FORMAT_RAW___16 = 262144,
    SF_FORMAT_PAF___16 = 327680,
    SF_FORMAT_SVX___16 = 393216,
    SF_FORMAT_NIST___16 = 458752,
    SF_FORMAT_VOC___16 = 524288,
    SF_FORMAT_IRCAM___16 = 655360,
    SF_FORMAT_W64___16 = 720896,
    SF_FORMAT_MAT4___16 = 786432,
    SF_FORMAT_MAT5___16 = 851968,
    SF_FORMAT_PVF___16 = 917504,
    SF_FORMAT_XI___16 = 983040,
    SF_FORMAT_HTK___16 = 1048576,
    SF_FORMAT_SDS___16 = 1114112,
    SF_FORMAT_AVR___16 = 1179648,
    SF_FORMAT_WAVEX___16 = 1245184,
    SF_FORMAT_SD2___16 = 1441792,
    SF_FORMAT_FLAC___16 = 1507328,
    SF_FORMAT_CAF___16 = 1572864,
    SF_FORMAT_WVE___16 = 1638400,
    SF_FORMAT_OGG___16 = 2097152,
    SF_FORMAT_MPC2K___16 = 2162688,
    SF_FORMAT_RF64___16 = 2228224,
    SF_FORMAT_PCM_S8___16 = 1,
    SF_FORMAT_PCM_16___16 = 2,
    SF_FORMAT_PCM_24___16 = 3,
    SF_FORMAT_PCM_32___16 = 4,
    SF_FORMAT_PCM_U8___16 = 5,
    SF_FORMAT_FLOAT___16 = 6,
    SF_FORMAT_DOUBLE___16 = 7,
    SF_FORMAT_ULAW___16 = 16,
    SF_FORMAT_ALAW___16 = 17,
    SF_FORMAT_IMA_ADPCM___16 = 18,
    SF_FORMAT_MS_ADPCM___16 = 19,
    SF_FORMAT_GSM610___16 = 32,
    SF_FORMAT_VOX_ADPCM___16 = 33,
    SF_FORMAT_G721_32___16 = 48,
    SF_FORMAT_G723_24___16 = 49,
    SF_FORMAT_G723_40___16 = 50,
    SF_FORMAT_DWVW_12___16 = 64,
    SF_FORMAT_DWVW_16___16 = 65,
    SF_FORMAT_DWVW_24___16 = 66,
    SF_FORMAT_DWVW_N___16 = 67,
    SF_FORMAT_DPCM_8___16 = 80,
    SF_FORMAT_DPCM_16___16 = 81,
    SF_FORMAT_VORBIS___16 = 96,
    SF_ENDIAN_FILE___16 = 0,
    SF_ENDIAN_LITTLE___16 = 268435456,
    SF_ENDIAN_BIG___16 = 536870912,
    SF_ENDIAN_CPU___16 = 805306368,
    SF_FORMAT_SUBMASK___16 = 65535,
    SF_FORMAT_TYPEMASK___16 = 268369920,
    SF_FORMAT_ENDMASK___16 = 805306368
} ;
#line 126
enum __anonenum__456 {
    SFC_GET_LIB_VERSION___16 = 4096,
    SFC_GET_LOG_INFO___16 = 4097,
    SFC_GET_CURRENT_SF_INFO___16 = 4098,
    SFC_GET_NORM_DOUBLE___16 = 4112,
    SFC_GET_NORM_FLOAT___16 = 4113,
    SFC_SET_NORM_DOUBLE___16 = 4114,
    SFC_SET_NORM_FLOAT___16 = 4115,
    SFC_SET_SCALE_FLOAT_INT_READ___16 = 4116,
    SFC_SET_SCALE_INT_FLOAT_WRITE___16 = 4117,
    SFC_GET_SIMPLE_FORMAT_COUNT___16 = 4128,
    SFC_GET_SIMPLE_FORMAT___16 = 4129,
    SFC_GET_FORMAT_INFO___16 = 4136,
    SFC_GET_FORMAT_MAJOR_COUNT___16 = 4144,
    SFC_GET_FORMAT_MAJOR___16 = 4145,
    SFC_GET_FORMAT_SUBTYPE_COUNT___16 = 4146,
    SFC_GET_FORMAT_SUBTYPE___16 = 4147,
    SFC_CALC_SIGNAL_MAX___16 = 4160,
    SFC_CALC_NORM_SIGNAL_MAX___16 = 4161,
    SFC_CALC_MAX_ALL_CHANNELS___16 = 4162,
    SFC_CALC_NORM_MAX_ALL_CHANNELS___16 = 4163,
    SFC_GET_SIGNAL_MAX___16 = 4164,
    SFC_GET_MAX_ALL_CHANNELS___16 = 4165,
    SFC_SET_ADD_PEAK_CHUNK___16 = 4176,
    SFC_SET_ADD_HEADER_PAD_CHUNK___16 = 4177,
    SFC_UPDATE_HEADER_NOW___16 = 4192,
    SFC_SET_UPDATE_HEADER_AUTO___16 = 4193,
    SFC_FILE_TRUNCATE___16 = 4224,
    SFC_SET_RAW_START_OFFSET___16 = 4240,
    SFC_SET_DITHER_ON_WRITE___16 = 4256,
    SFC_SET_DITHER_ON_READ___16 = 4257,
    SFC_GET_DITHER_INFO_COUNT___16 = 4258,
    SFC_GET_DITHER_INFO___16 = 4259,
    SFC_GET_EMBED_FILE_INFO___16 = 4272,
    SFC_SET_CLIPPING___16 = 4288,
    SFC_GET_CLIPPING___16 = 4289,
    SFC_GET_INSTRUMENT___16 = 4304,
    SFC_SET_INSTRUMENT___16 = 4305,
    SFC_GET_LOOP_INFO___16 = 4320,
    SFC_GET_BROADCAST_INFO___16 = 4336,
    SFC_SET_BROADCAST_INFO___16 = 4337,
    SFC_GET_CHANNEL_MAP_INFO___16 = 4352,
    SFC_SET_CHANNEL_MAP_INFO___16 = 4353,
    SFC_RAW_DATA_NEEDS_ENDSWAP___16 = 4368,
    SFC_WAVEX_SET_AMBISONIC___16 = 4608,
    SFC_WAVEX_GET_AMBISONIC___16 = 4609,
    SFC_SET_VBR_ENCODING_QUALITY___16 = 4864,
    SFC_TEST_IEEE_FLOAT_REPLACE___16 = 24577,
    SFC_SET_ADD_DITHER_ON_WRITE___16 = 4208,
    SFC_SET_ADD_DITHER_ON_READ___16 = 4209
} ;
#line 216
enum __anonenum__457 {
    SF_STR_TITLE___16 = 1,
    SF_STR_COPYRIGHT___16 = 2,
    SF_STR_SOFTWARE___16 = 3,
    SF_STR_ARTIST___16 = 4,
    SF_STR_COMMENT___16 = 5,
    SF_STR_DATE___16 = 6,
    SF_STR_ALBUM___16 = 7,
    SF_STR_LICENSE___16 = 8
} ;
#line 235
enum __anonenum__458 {
    SF_FALSE___16 = 0,
    SF_TRUE___16 = 1,
    SFM_READ___16 = 16,
    SFM_WRITE___16 = 32,
    SFM_RDWR___16 = 48,
    SF_AMBISONIC_NONE___16 = 64,
    SF_AMBISONIC_B_FORMAT___16 = 65
} ;
#line 255
enum __anonenum__459 {
    SF_ERR_NO_ERROR___16 = 0,
    SF_ERR_UNRECOGNISED_FORMAT___16 = 1,
    SF_ERR_SYSTEM___16 = 2,
    SF_ERR_MALFORMED_FILE___16 = 3,
    SF_ERR_UNSUPPORTED_ENCODING___16 = 4
} ;
#line 267
enum __anonenum__460 {
    SF_CHANNEL_MAP_INVALID___16 = 0,
    SF_CHANNEL_MAP_MONO___16 = 1,
    SF_CHANNEL_MAP_LEFT___16 = 2,
    SF_CHANNEL_MAP_RIGHT___16 = 3,
    SF_CHANNEL_MAP_CENTER___16 = 4,
    SF_CHANNEL_MAP_FRONT_LEFT___16 = 5,
    SF_CHANNEL_MAP_FRONT_RIGHT___16 = 6,
    SF_CHANNEL_MAP_FRONT_CENTER___16 = 7,
    SF_CHANNEL_MAP_REAR_CENTER___16 = 8,
    SF_CHANNEL_MAP_REAR_LEFT___16 = 9,
    SF_CHANNEL_MAP_REAR_RIGHT___16 = 10,
    SF_CHANNEL_MAP_LFE___16 = 11,
    SF_CHANNEL_MAP_FRONT_LEFT_OF_CENTER___16 = 12,
    SF_CHANNEL_MAP_FRONT_RIGHT_OF_CENTER___16 = 13,
    SF_CHANNEL_MAP_SIDE_LEFT___16 = 14,
    SF_CHANNEL_MAP_SIDE_RIGHT___16 = 15,
    SF_CHANNEL_MAP_TOP_CENTER___16 = 16,
    SF_CHANNEL_MAP_TOP_FRONT_LEFT___16 = 17,
    SF_CHANNEL_MAP_TOP_FRONT_RIGHT___16 = 18,
    SF_CHANNEL_MAP_TOP_FRONT_CENTER___16 = 19,
    SF_CHANNEL_MAP_TOP_REAR_LEFT___16 = 20,
    SF_CHANNEL_MAP_TOP_REAR_RIGHT___16 = 21,
    SF_CHANNEL_MAP_TOP_REAR_CENTER___16 = 22
} ;
#line 352
enum __anonenum__462 {
    SFD_DEFAULT_LEVEL___16 = 0,
    SFD_CUSTOM_LEVEL___16 = 1073741824,
    SFD_NO_DITHER___16 = 500,
    SFD_WHITE___16 = 501,
    SFD_TRIANGULAR_PDF___16 = 502
} ;
#line 380
enum __anonenum__465 {
    SF_LOOP_NONE___16 = 800,
    SF_LOOP_FORWARD___16 = 801,
    SF_LOOP_BACKWARD___16 = 802,
    SF_LOOP_ALTERNATING___16 = 803
} ;
#line 121 "/root/libsndfile/src/common.h"
enum __anonenum__470 {
    SF_PEAK_START___16 = 42,
    SF_PEAK_END___16 = 43,
    SF_SCALE_MAX___16 = 52,
    SF_SCALE_MIN___16 = 53,
    SF_STR_ALLOW_START___16 = 256,
    SF_STR_ALLOW_END___16 = 512,
    SF_STR_LOCATE_START___16 = 1024,
    SF_STR_LOCATE_END___16 = 2048,
    SFD_TYPEMASK___16 = 268435455
} ;
#line 149
enum __anonenum__471 {
    SF_FORMAT_TXW___16 = 67305472,
    SF_FORMAT_DWD___16 = 67371008,
    SF_FORMAT_REX___16 = 67764224,
    SF_FORMAT_REX2___16 = 67960832,
    SF_FORMAT_KRZ___16 = 68026368,
    SF_FORMAT_WMA___16 = 68157440,
    SF_FORMAT_SHN___16 = 68222976,
    SF_FORMAT_SVX_FIB___16 = 4128,
    SF_FORMAT_SVX_EXP___16 = 4129,
    SF_FORMAT_PCM_N___16 = 4144
} ;
#line 405
enum __anonenum__477 {
    SFE_NO_ERROR___16 = 0,
    SFE_BAD_OPEN_FORMAT___16 = 1,
    SFE_SYSTEM___16 = 2,
    SFE_MALFORMED_FILE___16 = 3,
    SFE_UNSUPPORTED_ENCODING___16 = 4,
    SFE_ZERO_MAJOR_FORMAT___16 = 5,
    SFE_ZERO_MINOR_FORMAT___16 = 6,
    SFE_BAD_FILE___16 = 7,
    SFE_BAD_FILE_READ___16 = 8,
    SFE_OPEN_FAILED___16 = 9,
    SFE_BAD_SNDFILE_PTR___16 = 10,
    SFE_BAD_SF_INFO_PTR___16 = 11,
    SFE_BAD_SF_INCOMPLETE___16 = 12,
    SFE_BAD_FILE_PTR___16 = 13,
    SFE_BAD_INT_PTR___16 = 14,
    SFE_BAD_STAT_SIZE___16 = 15,
    SFE_MALLOC_FAILED___16 = 16,
    SFE_UNIMPLEMENTED___16 = 17,
    SFE_BAD_READ_ALIGN___16 = 18,
    SFE_BAD_WRITE_ALIGN___16 = 19,
    SFE_UNKNOWN_FORMAT___16 = 20,
    SFE_NOT_READMODE___16 = 21,
    SFE_NOT_WRITEMODE___16 = 22,
    SFE_BAD_MODE_RW___16 = 23,
    SFE_BAD_SF_INFO___16 = 24,
    SFE_BAD_OFFSET___16 = 25,
    SFE_NO_EMBED_SUPPORT___16 = 26,
    SFE_NO_EMBEDDED_RDWR___16 = 27,
    SFE_NO_PIPE_WRITE___16 = 28,
    SFE_INTERNAL___16 = 29,
    SFE_BAD_COMMAND_PARAM___16 = 30,
    SFE_BAD_ENDIAN___16 = 31,
    SFE_CHANNEL_COUNT_ZERO___16 = 32,
    SFE_CHANNEL_COUNT___16 = 33,
    SFE_BAD_VIRTUAL_IO___16 = 34,
    SFE_INTERLEAVE_MODE___16 = 35,
    SFE_INTERLEAVE_SEEK___16 = 36,
    SFE_INTERLEAVE_READ___16 = 37,
    SFE_BAD_SEEK___16 = 38,
    SFE_NOT_SEEKABLE___16 = 39,
    SFE_AMBIGUOUS_SEEK___16 = 40,
    SFE_WRONG_SEEK___16 = 41,
    SFE_SEEK_FAILED___16 = 42,
    SFE_BAD_OPEN_MODE___16 = 43,
    SFE_OPEN_PIPE_RDWR___16 = 44,
    SFE_RDWR_POSITION___16 = 45,
    SFE_RDWR_BAD_HEADER___16 = 46,
    SFE_CMD_HAS_DATA___16 = 47,
    SFE_BAD_BROADCAST_INFO_SIZE___16 = 48,
    SFE_STR_NO_SUPPORT___16 = 49,
    SFE_STR_NOT_WRITE___16 = 50,
    SFE_STR_MAX_DATA___16 = 51,
    SFE_STR_MAX_COUNT___16 = 52,
    SFE_STR_BAD_TYPE___16 = 53,
    SFE_STR_NO_ADD_END___16 = 54,
    SFE_STR_BAD_STRING___16 = 55,
    SFE_STR_WEIRD___16 = 56,
    SFE_WAV_NO_RIFF___16 = 57,
    SFE_WAV_NO_WAVE___16 = 58,
    SFE_WAV_NO_FMT___16 = 59,
    SFE_WAV_BAD_FMT___16 = 60,
    SFE_WAV_FMT_SHORT___16 = 61,
    SFE_WAV_BAD_FACT___16 = 62,
    SFE_WAV_BAD_PEAK___16 = 63,
    SFE_WAV_PEAK_B4_FMT___16 = 64,
    SFE_WAV_BAD_FORMAT___16 = 65,
    SFE_WAV_BAD_BLOCKALIGN___16 = 66,
    SFE_WAV_NO_DATA___16 = 67,
    SFE_WAV_BAD_LIST___16 = 68,
    SFE_WAV_ADPCM_NOT4BIT___16 = 69,
    SFE_WAV_ADPCM_CHANNELS___16 = 70,
    SFE_WAV_GSM610_FORMAT___16 = 71,
    SFE_WAV_UNKNOWN_CHUNK___16 = 72,
    SFE_WAV_WVPK_DATA___16 = 73,
    SFE_AIFF_NO_FORM___16 = 74,
    SFE_AIFF_AIFF_NO_FORM___16 = 75,
    SFE_AIFF_COMM_NO_FORM___16 = 76,
    SFE_AIFF_SSND_NO_COMM___16 = 77,
    SFE_AIFF_UNKNOWN_CHUNK___16 = 78,
    SFE_AIFF_COMM_CHUNK_SIZE___16 = 79,
    SFE_AIFF_BAD_COMM_CHUNK___16 = 80,
    SFE_AIFF_PEAK_B4_COMM___16 = 81,
    SFE_AIFF_BAD_PEAK___16 = 82,
    SFE_AIFF_NO_SSND___16 = 83,
    SFE_AIFF_NO_DATA___16 = 84,
    SFE_AIFF_RW_SSND_NOT_LAST___16 = 85,
    SFE_AU_UNKNOWN_FORMAT___16 = 86,
    SFE_AU_NO_DOTSND___16 = 87,
    SFE_AU_EMBED_BAD_LEN___16 = 88,
    SFE_RAW_READ_BAD_SPEC___16 = 89,
    SFE_RAW_BAD_BITWIDTH___16 = 90,
    SFE_RAW_BAD_FORMAT___16 = 91,
    SFE_PAF_NO_MARKER___16 = 92,
    SFE_PAF_VERSION___16 = 93,
    SFE_PAF_UNKNOWN_FORMAT___16 = 94,
    SFE_PAF_SHORT_HEADER___16 = 95,
    SFE_SVX_NO_FORM___16 = 96,
    SFE_SVX_NO_BODY___16 = 97,
    SFE_SVX_NO_DATA___16 = 98,
    SFE_SVX_BAD_COMP___16 = 99,
    SFE_SVX_BAD_NAME_LENGTH___16 = 100,
    SFE_NIST_BAD_HEADER___16 = 101,
    SFE_NIST_CRLF_CONVERISON___16 = 102,
    SFE_NIST_BAD_ENCODING___16 = 103,
    SFE_VOC_NO_CREATIVE___16 = 104,
    SFE_VOC_BAD_FORMAT___16 = 105,
    SFE_VOC_BAD_VERSION___16 = 106,
    SFE_VOC_BAD_MARKER___16 = 107,
    SFE_VOC_BAD_SECTIONS___16 = 108,
    SFE_VOC_MULTI_SAMPLERATE___16 = 109,
    SFE_VOC_MULTI_SECTION___16 = 110,
    SFE_VOC_MULTI_PARAM___16 = 111,
    SFE_VOC_SECTION_COUNT___16 = 112,
    SFE_VOC_NO_PIPE___16 = 113,
    SFE_IRCAM_NO_MARKER___16 = 114,
    SFE_IRCAM_BAD_CHANNELS___16 = 115,
    SFE_IRCAM_UNKNOWN_FORMAT___16 = 116,
    SFE_W64_64_BIT___16 = 117,
    SFE_W64_NO_RIFF___16 = 118,
    SFE_W64_NO_WAVE___16 = 119,
    SFE_W64_NO_DATA___16 = 120,
    SFE_W64_ADPCM_NOT4BIT___16 = 121,
    SFE_W64_ADPCM_CHANNELS___16 = 122,
    SFE_W64_GSM610_FORMAT___16 = 123,
    SFE_MAT4_BAD_NAME___16 = 124,
    SFE_MAT4_NO_SAMPLERATE___16 = 125,
    SFE_MAT5_BAD_ENDIAN___16 = 126,
    SFE_MAT5_NO_BLOCK___16 = 127,
    SFE_MAT5_SAMPLE_RATE___16 = 128,
    SFE_PVF_NO_PVF1___16 = 129,
    SFE_PVF_BAD_HEADER___16 = 130,
    SFE_PVF_BAD_BITWIDTH___16 = 131,
    SFE_DWVW_BAD_BITWIDTH___16 = 132,
    SFE_G72X_NOT_MONO___16 = 133,
    SFE_XI_BAD_HEADER___16 = 134,
    SFE_XI_EXCESS_SAMPLES___16 = 135,
    SFE_XI_NO_PIPE___16 = 136,
    SFE_HTK_NO_PIPE___16 = 137,
    SFE_SDS_NOT_SDS___16 = 138,
    SFE_SDS_BAD_BIT_WIDTH___16 = 139,
    SFE_SD2_FD_DISALLOWED___16 = 140,
    SFE_SD2_BAD_DATA_OFFSET___16 = 141,
    SFE_SD2_BAD_MAP_OFFSET___16 = 142,
    SFE_SD2_BAD_DATA_LENGTH___16 = 143,
    SFE_SD2_BAD_MAP_LENGTH___16 = 144,
    SFE_SD2_BAD_RSRC___16 = 145,
    SFE_SD2_BAD_SAMPLE_SIZE___16 = 146,
    SFE_FLAC_BAD_HEADER___16 = 147,
    SFE_FLAC_NEW_DECODER___16 = 148,
    SFE_FLAC_INIT_DECODER___16 = 149,
    SFE_FLAC_LOST_SYNC___16 = 150,
    SFE_FLAC_BAD_SAMPLE_RATE___16 = 151,
    SFE_FLAC_UNKOWN_ERROR___16 = 152,
    SFE_WVE_NOT_WVE___16 = 153,
    SFE_WVE_NO_PIPE___16 = 154,
    SFE_VORBIS_ENCODER_BUG___16 = 155,
    SFE_RF64_NOT_RF64___16 = 156,
    SFE_MAX_ERROR___16 = 157
} ;
#line 823
enum __anonenum__481 {
    SFC_TEST_AIFF_ADD_INST_CHUNK___16 = 8192,
    SFC_TEST_WAV_ADD_INFO_CHUNK___16 = 8208
} ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__297___0 {
    _PC_LINK_MAX___0 = 0,
    _PC_MAX_CANON___0 = 1,
    _PC_MAX_INPUT___0 = 2,
    _PC_NAME_MAX___0 = 3,
    _PC_PATH_MAX___0 = 4,
    _PC_PIPE_BUF___0 = 5,
    _PC_CHOWN_RESTRICTED___0 = 6,
    _PC_NO_TRUNC___0 = 7,
    _PC_VDISABLE___0 = 8,
    _PC_SYNC_IO___0 = 9,
    _PC_ASYNC_IO___0 = 10,
    _PC_PRIO_IO___0 = 11,
    _PC_SOCK_MAXBUF___0 = 12,
    _PC_FILESIZEBITS___0 = 13,
    _PC_REC_INCR_XFER_SIZE___0 = 14,
    _PC_REC_MAX_XFER_SIZE___0 = 15,
    _PC_REC_MIN_XFER_SIZE___0 = 16,
    _PC_REC_XFER_ALIGN___0 = 17,
    _PC_ALLOC_SIZE_MIN___0 = 18,
    _PC_SYMLINK_MAX___0 = 19,
    _PC_2_SYMLINKS___0 = 20
} ;
#line 71
enum __anonenum__298___0 {
    _SC_ARG_MAX___0 = 0,
    _SC_CHILD_MAX___0 = 1,
    _SC_CLK_TCK___0 = 2,
    _SC_NGROUPS_MAX___0 = 3,
    _SC_OPEN_MAX___0 = 4,
    _SC_STREAM_MAX___0 = 5,
    _SC_TZNAME_MAX___0 = 6,
    _SC_JOB_CONTROL___0 = 7,
    _SC_SAVED_IDS___0 = 8,
    _SC_REALTIME_SIGNALS___0 = 9,
    _SC_PRIORITY_SCHEDULING___0 = 10,
    _SC_TIMERS___0 = 11,
    _SC_ASYNCHRONOUS_IO___0 = 12,
    _SC_PRIORITIZED_IO___0 = 13,
    _SC_SYNCHRONIZED_IO___0 = 14,
    _SC_FSYNC___0 = 15,
    _SC_MAPPED_FILES___0 = 16,
    _SC_MEMLOCK___0 = 17,
    _SC_MEMLOCK_RANGE___0 = 18,
    _SC_MEMORY_PROTECTION___0 = 19,
    _SC_MESSAGE_PASSING___0 = 20,
    _SC_SEMAPHORES___0 = 21,
    _SC_SHARED_MEMORY_OBJECTS___0 = 22,
    _SC_AIO_LISTIO_MAX___0 = 23,
    _SC_AIO_MAX___0 = 24,
    _SC_AIO_PRIO_DELTA_MAX___0 = 25,
    _SC_DELAYTIMER_MAX___0 = 26,
    _SC_MQ_OPEN_MAX___0 = 27,
    _SC_MQ_PRIO_MAX___0 = 28,
    _SC_VERSION___0 = 29,
    _SC_PAGESIZE___0 = 30,
    _SC_RTSIG_MAX___0 = 31,
    _SC_SEM_NSEMS_MAX___0 = 32,
    _SC_SEM_VALUE_MAX___0 = 33,
    _SC_SIGQUEUE_MAX___0 = 34,
    _SC_TIMER_MAX___0 = 35,
    _SC_BC_BASE_MAX___0 = 36,
    _SC_BC_DIM_MAX___0 = 37,
    _SC_BC_SCALE_MAX___0 = 38,
    _SC_BC_STRING_MAX___0 = 39,
    _SC_COLL_WEIGHTS_MAX___0 = 40,
    _SC_EQUIV_CLASS_MAX___0 = 41,
    _SC_EXPR_NEST_MAX___0 = 42,
    _SC_LINE_MAX___0 = 43,
    _SC_RE_DUP_MAX___0 = 44,
    _SC_CHARCLASS_NAME_MAX___0 = 45,
    _SC_2_VERSION___0 = 46,
    _SC_2_C_BIND___0 = 47,
    _SC_2_C_DEV___0 = 48,
    _SC_2_FORT_DEV___0 = 49,
    _SC_2_FORT_RUN___0 = 50,
    _SC_2_SW_DEV___0 = 51,
    _SC_2_LOCALEDEF___0 = 52,
    _SC_PII___0 = 53,
    _SC_PII_XTI___0 = 54,
    _SC_PII_SOCKET___0 = 55,
    _SC_PII_INTERNET___0 = 56,
    _SC_PII_OSI___0 = 57,
    _SC_POLL___0 = 58,
    _SC_SELECT___0 = 59,
    _SC_UIO_MAXIOV___0 = 60,
    _SC_IOV_MAX___0 = 60,
    _SC_PII_INTERNET_STREAM___0 = 61,
    _SC_PII_INTERNET_DGRAM___0 = 62,
    _SC_PII_OSI_COTS___0 = 63,
    _SC_PII_OSI_CLTS___0 = 64,
    _SC_PII_OSI_M___0 = 65,
    _SC_T_IOV_MAX___0 = 66,
    _SC_THREADS___0 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___0 = 68,
    _SC_GETGR_R_SIZE_MAX___0 = 69,
    _SC_GETPW_R_SIZE_MAX___0 = 70,
    _SC_LOGIN_NAME_MAX___0 = 71,
    _SC_TTY_NAME_MAX___0 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___0 = 73,
    _SC_THREAD_KEYS_MAX___0 = 74,
    _SC_THREAD_STACK_MIN___0 = 75,
    _SC_THREAD_THREADS_MAX___0 = 76,
    _SC_THREAD_ATTR_STACKADDR___0 = 77,
    _SC_THREAD_ATTR_STACKSIZE___0 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___0 = 79,
    _SC_THREAD_PRIO_INHERIT___0 = 80,
    _SC_THREAD_PRIO_PROTECT___0 = 81,
    _SC_THREAD_PROCESS_SHARED___0 = 82,
    _SC_NPROCESSORS_CONF___0 = 83,
    _SC_NPROCESSORS_ONLN___0 = 84,
    _SC_PHYS_PAGES___0 = 85,
    _SC_AVPHYS_PAGES___0 = 86,
    _SC_ATEXIT_MAX___0 = 87,
    _SC_PASS_MAX___0 = 88,
    _SC_XOPEN_VERSION___0 = 89,
    _SC_XOPEN_XCU_VERSION___0 = 90,
    _SC_XOPEN_UNIX___0 = 91,
    _SC_XOPEN_CRYPT___0 = 92,
    _SC_XOPEN_ENH_I18N___0 = 93,
    _SC_XOPEN_SHM___0 = 94,
    _SC_2_CHAR_TERM___0 = 95,
    _SC_2_C_VERSION___0 = 96,
    _SC_2_UPE___0 = 97,
    _SC_XOPEN_XPG2___0 = 98,
    _SC_XOPEN_XPG3___0 = 99,
    _SC_XOPEN_XPG4___0 = 100,
    _SC_CHAR_BIT___0 = 101,
    _SC_CHAR_MAX___0 = 102,
    _SC_CHAR_MIN___0 = 103,
    _SC_INT_MAX___0 = 104,
    _SC_INT_MIN___0 = 105,
    _SC_LONG_BIT___0 = 106,
    _SC_WORD_BIT___0 = 107,
    _SC_MB_LEN_MAX___0 = 108,
    _SC_NZERO___0 = 109,
    _SC_SSIZE_MAX___0 = 110,
    _SC_SCHAR_MAX___0 = 111,
    _SC_SCHAR_MIN___0 = 112,
    _SC_SHRT_MAX___0 = 113,
    _SC_SHRT_MIN___0 = 114,
    _SC_UCHAR_MAX___0 = 115,
    _SC_UINT_MAX___0 = 116,
    _SC_ULONG_MAX___0 = 117,
    _SC_USHRT_MAX___0 = 118,
    _SC_NL_ARGMAX___0 = 119,
    _SC_NL_LANGMAX___0 = 120,
    _SC_NL_MSGMAX___0 = 121,
    _SC_NL_NMAX___0 = 122,
    _SC_NL_SETMAX___0 = 123,
    _SC_NL_TEXTMAX___0 = 124,
    _SC_XBS5_ILP32_OFF32___0 = 125,
    _SC_XBS5_ILP32_OFFBIG___0 = 126,
    _SC_XBS5_LP64_OFF64___0 = 127,
    _SC_XBS5_LPBIG_OFFBIG___0 = 128,
    _SC_XOPEN_LEGACY___0 = 129,
    _SC_XOPEN_REALTIME___0 = 130,
    _SC_XOPEN_REALTIME_THREADS___0 = 131,
    _SC_ADVISORY_INFO___0 = 132,
    _SC_BARRIERS___0 = 133,
    _SC_BASE___0 = 134,
    _SC_C_LANG_SUPPORT___0 = 135,
    _SC_C_LANG_SUPPORT_R___0 = 136,
    _SC_CLOCK_SELECTION___0 = 137,
    _SC_CPUTIME___0 = 138,
    _SC_THREAD_CPUTIME___0 = 139,
    _SC_DEVICE_IO___0 = 140,
    _SC_DEVICE_SPECIFIC___0 = 141,
    _SC_DEVICE_SPECIFIC_R___0 = 142,
    _SC_FD_MGMT___0 = 143,
    _SC_FIFO___0 = 144,
    _SC_PIPE___0 = 145,
    _SC_FILE_ATTRIBUTES___0 = 146,
    _SC_FILE_LOCKING___0 = 147,
    _SC_FILE_SYSTEM___0 = 148,
    _SC_MONOTONIC_CLOCK___0 = 149,
    _SC_MULTI_PROCESS___0 = 150,
    _SC_SINGLE_PROCESS___0 = 151,
    _SC_NETWORKING___0 = 152,
    _SC_READER_WRITER_LOCKS___0 = 153,
    _SC_SPIN_LOCKS___0 = 154,
    _SC_REGEXP___0 = 155,
    _SC_REGEX_VERSION___0 = 156,
    _SC_SHELL___0 = 157,
    _SC_SIGNALS___0 = 158,
    _SC_SPAWN___0 = 159,
    _SC_SPORADIC_SERVER___0 = 160,
    _SC_THREAD_SPORADIC_SERVER___0 = 161,
    _SC_SYSTEM_DATABASE___0 = 162,
    _SC_SYSTEM_DATABASE_R___0 = 163,
    _SC_TIMEOUTS___0 = 164,
    _SC_TYPED_MEMORY_OBJECTS___0 = 165,
    _SC_USER_GROUPS___0 = 166,
    _SC_USER_GROUPS_R___0 = 167,
    _SC_2_PBS___0 = 168,
    _SC_2_PBS_ACCOUNTING___0 = 169,
    _SC_2_PBS_LOCATE___0 = 170,
    _SC_2_PBS_MESSAGE___0 = 171,
    _SC_2_PBS_TRACK___0 = 172,
    _SC_SYMLOOP_MAX___0 = 173,
    _SC_STREAMS___0 = 174,
    _SC_2_PBS_CHECKPOINT___0 = 175,
    _SC_V6_ILP32_OFF32___0 = 176,
    _SC_V6_ILP32_OFFBIG___0 = 177,
    _SC_V6_LP64_OFF64___0 = 178,
    _SC_V6_LPBIG_OFFBIG___0 = 179,
    _SC_HOST_NAME_MAX___0 = 180,
    _SC_TRACE___0 = 181,
    _SC_TRACE_EVENT_FILTER___0 = 182,
    _SC_TRACE_INHERIT___0 = 183,
    _SC_TRACE_LOG___0 = 184,
    _SC_LEVEL1_ICACHE_SIZE___0 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___0 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___0 = 187,
    _SC_LEVEL1_DCACHE_SIZE___0 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___0 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___0 = 190,
    _SC_LEVEL2_CACHE_SIZE___0 = 191,
    _SC_LEVEL2_CACHE_ASSOC___0 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___0 = 193,
    _SC_LEVEL3_CACHE_SIZE___0 = 194,
    _SC_LEVEL3_CACHE_ASSOC___0 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___0 = 196,
    _SC_LEVEL4_CACHE_SIZE___0 = 197,
    _SC_LEVEL4_CACHE_ASSOC___0 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___0 = 199,
    _SC_IPV6___0 = 235,
    _SC_RAW_SOCKETS___0 = 236,
    _SC_V7_ILP32_OFF32___0 = 237,
    _SC_V7_ILP32_OFFBIG___0 = 238,
    _SC_V7_LP64_OFF64___0 = 239,
    _SC_V7_LPBIG_OFFBIG___0 = 240,
    _SC_SS_REPL_MAX___0 = 241,
    _SC_TRACE_EVENT_NAME_MAX___0 = 242,
    _SC_TRACE_NAME_MAX___0 = 243,
    _SC_TRACE_SYS_MAX___0 = 244,
    _SC_TRACE_USER_EVENT_MAX___0 = 245,
    _SC_XOPEN_STREAMS___0 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___0 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___0 = 248
} ;
#line 533
enum __anonenum__299___0 {
    _CS_PATH___0 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___0 = 1,
    _CS_GNU_LIBC_VERSION___0 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___0 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___0 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___0 = 5,
    _CS_LFS_CFLAGS___0 = 1000,
    _CS_LFS_LDFLAGS___0 = 1001,
    _CS_LFS_LIBS___0 = 1002,
    _CS_LFS_LINTFLAGS___0 = 1003,
    _CS_LFS64_CFLAGS___0 = 1004,
    _CS_LFS64_LDFLAGS___0 = 1005,
    _CS_LFS64_LIBS___0 = 1006,
    _CS_LFS64_LINTFLAGS___0 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___0 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___0 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___0 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___0 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___0 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___0 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___0 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___0 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___0 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___0 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___0 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___0 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___0 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___0 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___0 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___0 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___0 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___0 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___0 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___0 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___0 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___0 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___0 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___0 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___0 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___0 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___0 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___0 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___0 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___0 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___0 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___0 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___0 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___0 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___0 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___0 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___0 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___0 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___0 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___0 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___0 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___0 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___0 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___0 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___0 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___0 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___0 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___0 = 1147,
    _CS_V6_ENV___0 = 1148,
    _CS_V7_ENV___0 = 1149
} ;
#line 46 "/root/libsndfile/src/sndfile.h"
enum __anonenum__482 {
    SF_FORMAT_WAV___17 = 65536,
    SF_FORMAT_AIFF___17 = 131072,
    SF_FORMAT_AU___17 = 196608,
    SF_FORMAT_RAW___17 = 262144,
    SF_FORMAT_PAF___17 = 327680,
    SF_FORMAT_SVX___17 = 393216,
    SF_FORMAT_NIST___17 = 458752,
    SF_FORMAT_VOC___17 = 524288,
    SF_FORMAT_IRCAM___17 = 655360,
    SF_FORMAT_W64___17 = 720896,
    SF_FORMAT_MAT4___17 = 786432,
    SF_FORMAT_MAT5___17 = 851968,
    SF_FORMAT_PVF___17 = 917504,
    SF_FORMAT_XI___17 = 983040,
    SF_FORMAT_HTK___17 = 1048576,
    SF_FORMAT_SDS___17 = 1114112,
    SF_FORMAT_AVR___17 = 1179648,
    SF_FORMAT_WAVEX___17 = 1245184,
    SF_FORMAT_SD2___17 = 1441792,
    SF_FORMAT_FLAC___17 = 1507328,
    SF_FORMAT_CAF___17 = 1572864,
    SF_FORMAT_WVE___17 = 1638400,
    SF_FORMAT_OGG___17 = 2097152,
    SF_FORMAT_MPC2K___17 = 2162688,
    SF_FORMAT_RF64___17 = 2228224,
    SF_FORMAT_PCM_S8___17 = 1,
    SF_FORMAT_PCM_16___17 = 2,
    SF_FORMAT_PCM_24___17 = 3,
    SF_FORMAT_PCM_32___17 = 4,
    SF_FORMAT_PCM_U8___17 = 5,
    SF_FORMAT_FLOAT___17 = 6,
    SF_FORMAT_DOUBLE___17 = 7,
    SF_FORMAT_ULAW___17 = 16,
    SF_FORMAT_ALAW___17 = 17,
    SF_FORMAT_IMA_ADPCM___17 = 18,
    SF_FORMAT_MS_ADPCM___17 = 19,
    SF_FORMAT_GSM610___17 = 32,
    SF_FORMAT_VOX_ADPCM___17 = 33,
    SF_FORMAT_G721_32___17 = 48,
    SF_FORMAT_G723_24___17 = 49,
    SF_FORMAT_G723_40___17 = 50,
    SF_FORMAT_DWVW_12___17 = 64,
    SF_FORMAT_DWVW_16___17 = 65,
    SF_FORMAT_DWVW_24___17 = 66,
    SF_FORMAT_DWVW_N___17 = 67,
    SF_FORMAT_DPCM_8___17 = 80,
    SF_FORMAT_DPCM_16___17 = 81,
    SF_FORMAT_VORBIS___17 = 96,
    SF_ENDIAN_FILE___17 = 0,
    SF_ENDIAN_LITTLE___17 = 268435456,
    SF_ENDIAN_BIG___17 = 536870912,
    SF_ENDIAN_CPU___17 = 805306368,
    SF_FORMAT_SUBMASK___17 = 65535,
    SF_FORMAT_TYPEMASK___17 = 268369920,
    SF_FORMAT_ENDMASK___17 = 805306368
} ;
#line 126
enum __anonenum__483 {
    SFC_GET_LIB_VERSION___17 = 4096,
    SFC_GET_LOG_INFO___17 = 4097,
    SFC_GET_CURRENT_SF_INFO___17 = 4098,
    SFC_GET_NORM_DOUBLE___17 = 4112,
    SFC_GET_NORM_FLOAT___17 = 4113,
    SFC_SET_NORM_DOUBLE___17 = 4114,
    SFC_SET_NORM_FLOAT___17 = 4115,
    SFC_SET_SCALE_FLOAT_INT_READ___17 = 4116,
    SFC_SET_SCALE_INT_FLOAT_WRITE___17 = 4117,
    SFC_GET_SIMPLE_FORMAT_COUNT___17 = 4128,
    SFC_GET_SIMPLE_FORMAT___17 = 4129,
    SFC_GET_FORMAT_INFO___17 = 4136,
    SFC_GET_FORMAT_MAJOR_COUNT___17 = 4144,
    SFC_GET_FORMAT_MAJOR___17 = 4145,
    SFC_GET_FORMAT_SUBTYPE_COUNT___17 = 4146,
    SFC_GET_FORMAT_SUBTYPE___17 = 4147,
    SFC_CALC_SIGNAL_MAX___17 = 4160,
    SFC_CALC_NORM_SIGNAL_MAX___17 = 4161,
    SFC_CALC_MAX_ALL_CHANNELS___17 = 4162,
    SFC_CALC_NORM_MAX_ALL_CHANNELS___17 = 4163,
    SFC_GET_SIGNAL_MAX___17 = 4164,
    SFC_GET_MAX_ALL_CHANNELS___17 = 4165,
    SFC_SET_ADD_PEAK_CHUNK___17 = 4176,
    SFC_SET_ADD_HEADER_PAD_CHUNK___17 = 4177,
    SFC_UPDATE_HEADER_NOW___17 = 4192,
    SFC_SET_UPDATE_HEADER_AUTO___17 = 4193,
    SFC_FILE_TRUNCATE___17 = 4224,
    SFC_SET_RAW_START_OFFSET___17 = 4240,
    SFC_SET_DITHER_ON_WRITE___17 = 4256,
    SFC_SET_DITHER_ON_READ___17 = 4257,
    SFC_GET_DITHER_INFO_COUNT___17 = 4258,
    SFC_GET_DITHER_INFO___17 = 4259,
    SFC_GET_EMBED_FILE_INFO___17 = 4272,
    SFC_SET_CLIPPING___17 = 4288,
    SFC_GET_CLIPPING___17 = 4289,
    SFC_GET_INSTRUMENT___17 = 4304,
    SFC_SET_INSTRUMENT___17 = 4305,
    SFC_GET_LOOP_INFO___17 = 4320,
    SFC_GET_BROADCAST_INFO___17 = 4336,
    SFC_SET_BROADCAST_INFO___17 = 4337,
    SFC_GET_CHANNEL_MAP_INFO___17 = 4352,
    SFC_SET_CHANNEL_MAP_INFO___17 = 4353,
    SFC_RAW_DATA_NEEDS_ENDSWAP___17 = 4368,
    SFC_WAVEX_SET_AMBISONIC___17 = 4608,
    SFC_WAVEX_GET_AMBISONIC___17 = 4609,
    SFC_SET_VBR_ENCODING_QUALITY___17 = 4864,
    SFC_TEST_IEEE_FLOAT_REPLACE___17 = 24577,
    SFC_SET_ADD_DITHER_ON_WRITE___17 = 4208,
    SFC_SET_ADD_DITHER_ON_READ___17 = 4209
} ;
#line 216
enum __anonenum__484 {
    SF_STR_TITLE___17 = 1,
    SF_STR_COPYRIGHT___17 = 2,
    SF_STR_SOFTWARE___17 = 3,
    SF_STR_ARTIST___17 = 4,
    SF_STR_COMMENT___17 = 5,
    SF_STR_DATE___17 = 6,
    SF_STR_ALBUM___17 = 7,
    SF_STR_LICENSE___17 = 8
} ;
#line 235
enum __anonenum__485 {
    SF_FALSE___17 = 0,
    SF_TRUE___17 = 1,
    SFM_READ___17 = 16,
    SFM_WRITE___17 = 32,
    SFM_RDWR___17 = 48,
    SF_AMBISONIC_NONE___17 = 64,
    SF_AMBISONIC_B_FORMAT___17 = 65
} ;
#line 255
enum __anonenum__486 {
    SF_ERR_NO_ERROR___17 = 0,
    SF_ERR_UNRECOGNISED_FORMAT___17 = 1,
    SF_ERR_SYSTEM___17 = 2,
    SF_ERR_MALFORMED_FILE___17 = 3,
    SF_ERR_UNSUPPORTED_ENCODING___17 = 4
} ;
#line 267
enum __anonenum__487 {
    SF_CHANNEL_MAP_INVALID___17 = 0,
    SF_CHANNEL_MAP_MONO___17 = 1,
    SF_CHANNEL_MAP_LEFT___17 = 2,
    SF_CHANNEL_MAP_RIGHT___17 = 3,
    SF_CHANNEL_MAP_CENTER___17 = 4,
    SF_CHANNEL_MAP_FRONT_LEFT___17 = 5,
    SF_CHANNEL_MAP_FRONT_RIGHT___17 = 6,
    SF_CHANNEL_MAP_FRONT_CENTER___17 = 7,
    SF_CHANNEL_MAP_REAR_CENTER___17 = 8,
    SF_CHANNEL_MAP_REAR_LEFT___17 = 9,
    SF_CHANNEL_MAP_REAR_RIGHT___17 = 10,
    SF_CHANNEL_MAP_LFE___17 = 11,
    SF_CHANNEL_MAP_FRONT_LEFT_OF_CENTER___17 = 12,
    SF_CHANNEL_MAP_FRONT_RIGHT_OF_CENTER___17 = 13,
    SF_CHANNEL_MAP_SIDE_LEFT___17 = 14,
    SF_CHANNEL_MAP_SIDE_RIGHT___17 = 15,
    SF_CHANNEL_MAP_TOP_CENTER___17 = 16,
    SF_CHANNEL_MAP_TOP_FRONT_LEFT___17 = 17,
    SF_CHANNEL_MAP_TOP_FRONT_RIGHT___17 = 18,
    SF_CHANNEL_MAP_TOP_FRONT_CENTER___17 = 19,
    SF_CHANNEL_MAP_TOP_REAR_LEFT___17 = 20,
    SF_CHANNEL_MAP_TOP_REAR_RIGHT___17 = 21,
    SF_CHANNEL_MAP_TOP_REAR_CENTER___17 = 22
} ;
#line 352
enum __anonenum__489 {
    SFD_DEFAULT_LEVEL___17 = 0,
    SFD_CUSTOM_LEVEL___17 = 1073741824,
    SFD_NO_DITHER___17 = 500,
    SFD_WHITE___17 = 501,
    SFD_TRIANGULAR_PDF___17 = 502
} ;
#line 380
enum __anonenum__492 {
    SF_LOOP_NONE___17 = 800,
    SF_LOOP_FORWARD___17 = 801,
    SF_LOOP_BACKWARD___17 = 802,
    SF_LOOP_ALTERNATING___17 = 803
} ;
#line 121 "/root/libsndfile/src/common.h"
enum __anonenum__497 {
    SF_PEAK_START___17 = 42,
    SF_PEAK_END___17 = 43,
    SF_SCALE_MAX___17 = 52,
    SF_SCALE_MIN___17 = 53,
    SF_STR_ALLOW_START___17 = 256,
    SF_STR_ALLOW_END___17 = 512,
    SF_STR_LOCATE_START___17 = 1024,
    SF_STR_LOCATE_END___17 = 2048,
    SFD_TYPEMASK___17 = 268435455
} ;
#line 149
enum __anonenum__498 {
    SF_FORMAT_TXW___17 = 67305472,
    SF_FORMAT_DWD___17 = 67371008,
    SF_FORMAT_REX___17 = 67764224,
    SF_FORMAT_REX2___17 = 67960832,
    SF_FORMAT_KRZ___17 = 68026368,
    SF_FORMAT_WMA___17 = 68157440,
    SF_FORMAT_SHN___17 = 68222976,
    SF_FORMAT_SVX_FIB___17 = 4128,
    SF_FORMAT_SVX_EXP___17 = 4129,
    SF_FORMAT_PCM_N___17 = 4144
} ;
#line 405
enum __anonenum__504 {
    SFE_NO_ERROR___17 = 0,
    SFE_BAD_OPEN_FORMAT___17 = 1,
    SFE_SYSTEM___17 = 2,
    SFE_MALFORMED_FILE___17 = 3,
    SFE_UNSUPPORTED_ENCODING___17 = 4,
    SFE_ZERO_MAJOR_FORMAT___17 = 5,
    SFE_ZERO_MINOR_FORMAT___17 = 6,
    SFE_BAD_FILE___17 = 7,
    SFE_BAD_FILE_READ___17 = 8,
    SFE_OPEN_FAILED___17 = 9,
    SFE_BAD_SNDFILE_PTR___17 = 10,
    SFE_BAD_SF_INFO_PTR___17 = 11,
    SFE_BAD_SF_INCOMPLETE___17 = 12,
    SFE_BAD_FILE_PTR___17 = 13,
    SFE_BAD_INT_PTR___17 = 14,
    SFE_BAD_STAT_SIZE___17 = 15,
    SFE_MALLOC_FAILED___17 = 16,
    SFE_UNIMPLEMENTED___17 = 17,
    SFE_BAD_READ_ALIGN___17 = 18,
    SFE_BAD_WRITE_ALIGN___17 = 19,
    SFE_UNKNOWN_FORMAT___17 = 20,
    SFE_NOT_READMODE___17 = 21,
    SFE_NOT_WRITEMODE___17 = 22,
    SFE_BAD_MODE_RW___17 = 23,
    SFE_BAD_SF_INFO___17 = 24,
    SFE_BAD_OFFSET___17 = 25,
    SFE_NO_EMBED_SUPPORT___17 = 26,
    SFE_NO_EMBEDDED_RDWR___17 = 27,
    SFE_NO_PIPE_WRITE___17 = 28,
    SFE_INTERNAL___17 = 29,
    SFE_BAD_COMMAND_PARAM___17 = 30,
    SFE_BAD_ENDIAN___17 = 31,
    SFE_CHANNEL_COUNT_ZERO___17 = 32,
    SFE_CHANNEL_COUNT___17 = 33,
    SFE_BAD_VIRTUAL_IO___17 = 34,
    SFE_INTERLEAVE_MODE___17 = 35,
    SFE_INTERLEAVE_SEEK___17 = 36,
    SFE_INTERLEAVE_READ___17 = 37,
    SFE_BAD_SEEK___17 = 38,
    SFE_NOT_SEEKABLE___17 = 39,
    SFE_AMBIGUOUS_SEEK___17 = 40,
    SFE_WRONG_SEEK___17 = 41,
    SFE_SEEK_FAILED___17 = 42,
    SFE_BAD_OPEN_MODE___17 = 43,
    SFE_OPEN_PIPE_RDWR___17 = 44,
    SFE_RDWR_POSITION___17 = 45,
    SFE_RDWR_BAD_HEADER___17 = 46,
    SFE_CMD_HAS_DATA___17 = 47,
    SFE_BAD_BROADCAST_INFO_SIZE___17 = 48,
    SFE_STR_NO_SUPPORT___17 = 49,
    SFE_STR_NOT_WRITE___17 = 50,
    SFE_STR_MAX_DATA___17 = 51,
    SFE_STR_MAX_COUNT___17 = 52,
    SFE_STR_BAD_TYPE___17 = 53,
    SFE_STR_NO_ADD_END___17 = 54,
    SFE_STR_BAD_STRING___17 = 55,
    SFE_STR_WEIRD___17 = 56,
    SFE_WAV_NO_RIFF___17 = 57,
    SFE_WAV_NO_WAVE___17 = 58,
    SFE_WAV_NO_FMT___17 = 59,
    SFE_WAV_BAD_FMT___17 = 60,
    SFE_WAV_FMT_SHORT___17 = 61,
    SFE_WAV_BAD_FACT___17 = 62,
    SFE_WAV_BAD_PEAK___17 = 63,
    SFE_WAV_PEAK_B4_FMT___17 = 64,
    SFE_WAV_BAD_FORMAT___17 = 65,
    SFE_WAV_BAD_BLOCKALIGN___17 = 66,
    SFE_WAV_NO_DATA___17 = 67,
    SFE_WAV_BAD_LIST___17 = 68,
    SFE_WAV_ADPCM_NOT4BIT___17 = 69,
    SFE_WAV_ADPCM_CHANNELS___17 = 70,
    SFE_WAV_GSM610_FORMAT___17 = 71,
    SFE_WAV_UNKNOWN_CHUNK___17 = 72,
    SFE_WAV_WVPK_DATA___17 = 73,
    SFE_AIFF_NO_FORM___17 = 74,
    SFE_AIFF_AIFF_NO_FORM___17 = 75,
    SFE_AIFF_COMM_NO_FORM___17 = 76,
    SFE_AIFF_SSND_NO_COMM___17 = 77,
    SFE_AIFF_UNKNOWN_CHUNK___17 = 78,
    SFE_AIFF_COMM_CHUNK_SIZE___17 = 79,
    SFE_AIFF_BAD_COMM_CHUNK___17 = 80,
    SFE_AIFF_PEAK_B4_COMM___17 = 81,
    SFE_AIFF_BAD_PEAK___17 = 82,
    SFE_AIFF_NO_SSND___17 = 83,
    SFE_AIFF_NO_DATA___17 = 84,
    SFE_AIFF_RW_SSND_NOT_LAST___17 = 85,
    SFE_AU_UNKNOWN_FORMAT___17 = 86,
    SFE_AU_NO_DOTSND___17 = 87,
    SFE_AU_EMBED_BAD_LEN___17 = 88,
    SFE_RAW_READ_BAD_SPEC___17 = 89,
    SFE_RAW_BAD_BITWIDTH___17 = 90,
    SFE_RAW_BAD_FORMAT___17 = 91,
    SFE_PAF_NO_MARKER___17 = 92,
    SFE_PAF_VERSION___17 = 93,
    SFE_PAF_UNKNOWN_FORMAT___17 = 94,
    SFE_PAF_SHORT_HEADER___17 = 95,
    SFE_SVX_NO_FORM___17 = 96,
    SFE_SVX_NO_BODY___17 = 97,
    SFE_SVX_NO_DATA___17 = 98,
    SFE_SVX_BAD_COMP___17 = 99,
    SFE_SVX_BAD_NAME_LENGTH___17 = 100,
    SFE_NIST_BAD_HEADER___17 = 101,
    SFE_NIST_CRLF_CONVERISON___17 = 102,
    SFE_NIST_BAD_ENCODING___17 = 103,
    SFE_VOC_NO_CREATIVE___17 = 104,
    SFE_VOC_BAD_FORMAT___17 = 105,
    SFE_VOC_BAD_VERSION___17 = 106,
    SFE_VOC_BAD_MARKER___17 = 107,
    SFE_VOC_BAD_SECTIONS___17 = 108,
    SFE_VOC_MULTI_SAMPLERATE___17 = 109,
    SFE_VOC_MULTI_SECTION___17 = 110,
    SFE_VOC_MULTI_PARAM___17 = 111,
    SFE_VOC_SECTION_COUNT___17 = 112,
    SFE_VOC_NO_PIPE___17 = 113,
    SFE_IRCAM_NO_MARKER___17 = 114,
    SFE_IRCAM_BAD_CHANNELS___17 = 115,
    SFE_IRCAM_UNKNOWN_FORMAT___17 = 116,
    SFE_W64_64_BIT___17 = 117,
    SFE_W64_NO_RIFF___17 = 118,
    SFE_W64_NO_WAVE___17 = 119,
    SFE_W64_NO_DATA___17 = 120,
    SFE_W64_ADPCM_NOT4BIT___17 = 121,
    SFE_W64_ADPCM_CHANNELS___17 = 122,
    SFE_W64_GSM610_FORMAT___17 = 123,
    SFE_MAT4_BAD_NAME___17 = 124,
    SFE_MAT4_NO_SAMPLERATE___17 = 125,
    SFE_MAT5_BAD_ENDIAN___17 = 126,
    SFE_MAT5_NO_BLOCK___17 = 127,
    SFE_MAT5_SAMPLE_RATE___17 = 128,
    SFE_PVF_NO_PVF1___17 = 129,
    SFE_PVF_BAD_HEADER___17 = 130,
    SFE_PVF_BAD_BITWIDTH___17 = 131,
    SFE_DWVW_BAD_BITWIDTH___17 = 132,
    SFE_G72X_NOT_MONO___17 = 133,
    SFE_XI_BAD_HEADER___17 = 134,
    SFE_XI_EXCESS_SAMPLES___17 = 135,
    SFE_XI_NO_PIPE___17 = 136,
    SFE_HTK_NO_PIPE___17 = 137,
    SFE_SDS_NOT_SDS___17 = 138,
    SFE_SDS_BAD_BIT_WIDTH___17 = 139,
    SFE_SD2_FD_DISALLOWED___17 = 140,
    SFE_SD2_BAD_DATA_OFFSET___17 = 141,
    SFE_SD2_BAD_MAP_OFFSET___17 = 142,
    SFE_SD2_BAD_DATA_LENGTH___17 = 143,
    SFE_SD2_BAD_MAP_LENGTH___17 = 144,
    SFE_SD2_BAD_RSRC___17 = 145,
    SFE_SD2_BAD_SAMPLE_SIZE___17 = 146,
    SFE_FLAC_BAD_HEADER___17 = 147,
    SFE_FLAC_NEW_DECODER___17 = 148,
    SFE_FLAC_INIT_DECODER___17 = 149,
    SFE_FLAC_LOST_SYNC___17 = 150,
    SFE_FLAC_BAD_SAMPLE_RATE___17 = 151,
    SFE_FLAC_UNKOWN_ERROR___17 = 152,
    SFE_WVE_NOT_WVE___17 = 153,
    SFE_WVE_NO_PIPE___17 = 154,
    SFE_VORBIS_ENCODER_BUG___17 = 155,
    SFE_RF64_NOT_RF64___17 = 156,
    SFE_MAX_ERROR___17 = 157
} ;
#line 823
enum __anonenum__508 {
    SFC_TEST_AIFF_ADD_INST_CHUNK___17 = 8192,
    SFC_TEST_WAV_ADD_INFO_CHUNK___17 = 8208
} ;
#line 34 "/root/libsndfile/src/audio_detect.c"
struct __anonstruct_509 {
   int le_float ;
   int be_float ;
   int le_int_24_32 ;
   int be_int_24_32 ;
};
#line 39 "/root/libsndfile/src/audio_detect.c"
typedef struct __anonstruct_509 VOTE;
#line 853 "/usr/include/math.h"
enum __anonenum__74___1 {
    FP_NAN___11 = 0,
    FP_INFINITE___11 = 1,
    FP_ZERO___11 = 2,
    FP_SUBNORMAL___11 = 3,
    FP_NORMAL___11 = 4
} ;
#line 46 "/root/libsndfile/src/sndfile.h"
enum __anonenum__91___1 {
    SF_FORMAT_WAV___18 = 65536,
    SF_FORMAT_AIFF___18 = 131072,
    SF_FORMAT_AU___18 = 196608,
    SF_FORMAT_RAW___18 = 262144,
    SF_FORMAT_PAF___18 = 327680,
    SF_FORMAT_SVX___18 = 393216,
    SF_FORMAT_NIST___18 = 458752,
    SF_FORMAT_VOC___18 = 524288,
    SF_FORMAT_IRCAM___18 = 655360,
    SF_FORMAT_W64___18 = 720896,
    SF_FORMAT_MAT4___18 = 786432,
    SF_FORMAT_MAT5___18 = 851968,
    SF_FORMAT_PVF___18 = 917504,
    SF_FORMAT_XI___18 = 983040,
    SF_FORMAT_HTK___18 = 1048576,
    SF_FORMAT_SDS___18 = 1114112,
    SF_FORMAT_AVR___18 = 1179648,
    SF_FORMAT_WAVEX___18 = 1245184,
    SF_FORMAT_SD2___18 = 1441792,
    SF_FORMAT_FLAC___18 = 1507328,
    SF_FORMAT_CAF___18 = 1572864,
    SF_FORMAT_WVE___18 = 1638400,
    SF_FORMAT_OGG___18 = 2097152,
    SF_FORMAT_MPC2K___18 = 2162688,
    SF_FORMAT_RF64___18 = 2228224,
    SF_FORMAT_PCM_S8___18 = 1,
    SF_FORMAT_PCM_16___18 = 2,
    SF_FORMAT_PCM_24___18 = 3,
    SF_FORMAT_PCM_32___18 = 4,
    SF_FORMAT_PCM_U8___18 = 5,
    SF_FORMAT_FLOAT___18 = 6,
    SF_FORMAT_DOUBLE___18 = 7,
    SF_FORMAT_ULAW___18 = 16,
    SF_FORMAT_ALAW___18 = 17,
    SF_FORMAT_IMA_ADPCM___18 = 18,
    SF_FORMAT_MS_ADPCM___18 = 19,
    SF_FORMAT_GSM610___18 = 32,
    SF_FORMAT_VOX_ADPCM___18 = 33,
    SF_FORMAT_G721_32___18 = 48,
    SF_FORMAT_G723_24___18 = 49,
    SF_FORMAT_G723_40___18 = 50,
    SF_FORMAT_DWVW_12___18 = 64,
    SF_FORMAT_DWVW_16___18 = 65,
    SF_FORMAT_DWVW_24___18 = 66,
    SF_FORMAT_DWVW_N___18 = 67,
    SF_FORMAT_DPCM_8___18 = 80,
    SF_FORMAT_DPCM_16___18 = 81,
    SF_FORMAT_VORBIS___18 = 96,
    SF_ENDIAN_FILE___18 = 0,
    SF_ENDIAN_LITTLE___18 = 268435456,
    SF_ENDIAN_BIG___18 = 536870912,
    SF_ENDIAN_CPU___18 = 805306368,
    SF_FORMAT_SUBMASK___18 = 65535,
    SF_FORMAT_TYPEMASK___18 = 268369920,
    SF_FORMAT_ENDMASK___18 = 805306368
} ;
#line 126
enum __anonenum__92___1 {
    SFC_GET_LIB_VERSION___18 = 4096,
    SFC_GET_LOG_INFO___18 = 4097,
    SFC_GET_CURRENT_SF_INFO___18 = 4098,
    SFC_GET_NORM_DOUBLE___18 = 4112,
    SFC_GET_NORM_FLOAT___18 = 4113,
    SFC_SET_NORM_DOUBLE___18 = 4114,
    SFC_SET_NORM_FLOAT___18 = 4115,
    SFC_SET_SCALE_FLOAT_INT_READ___18 = 4116,
    SFC_SET_SCALE_INT_FLOAT_WRITE___18 = 4117,
    SFC_GET_SIMPLE_FORMAT_COUNT___18 = 4128,
    SFC_GET_SIMPLE_FORMAT___18 = 4129,
    SFC_GET_FORMAT_INFO___18 = 4136,
    SFC_GET_FORMAT_MAJOR_COUNT___18 = 4144,
    SFC_GET_FORMAT_MAJOR___18 = 4145,
    SFC_GET_FORMAT_SUBTYPE_COUNT___18 = 4146,
    SFC_GET_FORMAT_SUBTYPE___18 = 4147,
    SFC_CALC_SIGNAL_MAX___18 = 4160,
    SFC_CALC_NORM_SIGNAL_MAX___18 = 4161,
    SFC_CALC_MAX_ALL_CHANNELS___18 = 4162,
    SFC_CALC_NORM_MAX_ALL_CHANNELS___18 = 4163,
    SFC_GET_SIGNAL_MAX___18 = 4164,
    SFC_GET_MAX_ALL_CHANNELS___18 = 4165,
    SFC_SET_ADD_PEAK_CHUNK___18 = 4176,
    SFC_SET_ADD_HEADER_PAD_CHUNK___18 = 4177,
    SFC_UPDATE_HEADER_NOW___18 = 4192,
    SFC_SET_UPDATE_HEADER_AUTO___18 = 4193,
    SFC_FILE_TRUNCATE___18 = 4224,
    SFC_SET_RAW_START_OFFSET___18 = 4240,
    SFC_SET_DITHER_ON_WRITE___18 = 4256,
    SFC_SET_DITHER_ON_READ___18 = 4257,
    SFC_GET_DITHER_INFO_COUNT___18 = 4258,
    SFC_GET_DITHER_INFO___18 = 4259,
    SFC_GET_EMBED_FILE_INFO___18 = 4272,
    SFC_SET_CLIPPING___18 = 4288,
    SFC_GET_CLIPPING___18 = 4289,
    SFC_GET_INSTRUMENT___18 = 4304,
    SFC_SET_INSTRUMENT___18 = 4305,
    SFC_GET_LOOP_INFO___18 = 4320,
    SFC_GET_BROADCAST_INFO___18 = 4336,
    SFC_SET_BROADCAST_INFO___18 = 4337,
    SFC_GET_CHANNEL_MAP_INFO___18 = 4352,
    SFC_SET_CHANNEL_MAP_INFO___18 = 4353,
    SFC_RAW_DATA_NEEDS_ENDSWAP___18 = 4368,
    SFC_WAVEX_SET_AMBISONIC___18 = 4608,
    SFC_WAVEX_GET_AMBISONIC___18 = 4609,
    SFC_SET_VBR_ENCODING_QUALITY___18 = 4864,
    SFC_TEST_IEEE_FLOAT_REPLACE___18 = 24577,
    SFC_SET_ADD_DITHER_ON_WRITE___18 = 4208,
    SFC_SET_ADD_DITHER_ON_READ___18 = 4209
} ;
#line 216
enum __anonenum__93___1 {
    SF_STR_TITLE___18 = 1,
    SF_STR_COPYRIGHT___18 = 2,
    SF_STR_SOFTWARE___18 = 3,
    SF_STR_ARTIST___18 = 4,
    SF_STR_COMMENT___18 = 5,
    SF_STR_DATE___18 = 6,
    SF_STR_ALBUM___18 = 7,
    SF_STR_LICENSE___18 = 8
} ;
#line 235
enum __anonenum__94___1 {
    SF_FALSE___18 = 0,
    SF_TRUE___18 = 1,
    SFM_READ___18 = 16,
    SFM_WRITE___18 = 32,
    SFM_RDWR___18 = 48,
    SF_AMBISONIC_NONE___18 = 64,
    SF_AMBISONIC_B_FORMAT___18 = 65
} ;
#line 255
enum __anonenum__95___1 {
    SF_ERR_NO_ERROR___18 = 0,
    SF_ERR_UNRECOGNISED_FORMAT___18 = 1,
    SF_ERR_SYSTEM___18 = 2,
    SF_ERR_MALFORMED_FILE___18 = 3,
    SF_ERR_UNSUPPORTED_ENCODING___18 = 4
} ;
#line 267
enum __anonenum__96___1 {
    SF_CHANNEL_MAP_INVALID___18 = 0,
    SF_CHANNEL_MAP_MONO___18 = 1,
    SF_CHANNEL_MAP_LEFT___18 = 2,
    SF_CHANNEL_MAP_RIGHT___18 = 3,
    SF_CHANNEL_MAP_CENTER___18 = 4,
    SF_CHANNEL_MAP_FRONT_LEFT___18 = 5,
    SF_CHANNEL_MAP_FRONT_RIGHT___18 = 6,
    SF_CHANNEL_MAP_FRONT_CENTER___18 = 7,
    SF_CHANNEL_MAP_REAR_CENTER___18 = 8,
    SF_CHANNEL_MAP_REAR_LEFT___18 = 9,
    SF_CHANNEL_MAP_REAR_RIGHT___18 = 10,
    SF_CHANNEL_MAP_LFE___18 = 11,
    SF_CHANNEL_MAP_FRONT_LEFT_OF_CENTER___18 = 12,
    SF_CHANNEL_MAP_FRONT_RIGHT_OF_CENTER___18 = 13,
    SF_CHANNEL_MAP_SIDE_LEFT___18 = 14,
    SF_CHANNEL_MAP_SIDE_RIGHT___18 = 15,
    SF_CHANNEL_MAP_TOP_CENTER___18 = 16,
    SF_CHANNEL_MAP_TOP_FRONT_LEFT___18 = 17,
    SF_CHANNEL_MAP_TOP_FRONT_RIGHT___18 = 18,
    SF_CHANNEL_MAP_TOP_FRONT_CENTER___18 = 19,
    SF_CHANNEL_MAP_TOP_REAR_LEFT___18 = 20,
    SF_CHANNEL_MAP_TOP_REAR_RIGHT___18 = 21,
    SF_CHANNEL_MAP_TOP_REAR_CENTER___18 = 22
} ;
#line 352
enum __anonenum__98___1 {
    SFD_DEFAULT_LEVEL___18 = 0,
    SFD_CUSTOM_LEVEL___18 = 1073741824,
    SFD_NO_DITHER___18 = 500,
    SFD_WHITE___18 = 501,
    SFD_TRIANGULAR_PDF___18 = 502
} ;
#line 380
enum __anonenum__101___1 {
    SF_LOOP_NONE___18 = 800,
    SF_LOOP_FORWARD___18 = 801,
    SF_LOOP_BACKWARD___18 = 802,
    SF_LOOP_ALTERNATING___18 = 803
} ;
#line 121 "/root/libsndfile/src/common.h"
enum __anonenum__110___0 {
    SF_PEAK_START___18 = 42,
    SF_PEAK_END___18 = 43,
    SF_SCALE_MAX___18 = 52,
    SF_SCALE_MIN___18 = 53,
    SF_STR_ALLOW_START___18 = 256,
    SF_STR_ALLOW_END___18 = 512,
    SF_STR_LOCATE_START___18 = 1024,
    SF_STR_LOCATE_END___18 = 2048,
    SFD_TYPEMASK___18 = 268435455
} ;
#line 149
enum __anonenum__111___0 {
    SF_FORMAT_TXW___18 = 67305472,
    SF_FORMAT_DWD___18 = 67371008,
    SF_FORMAT_REX___18 = 67764224,
    SF_FORMAT_REX2___18 = 67960832,
    SF_FORMAT_KRZ___18 = 68026368,
    SF_FORMAT_WMA___18 = 68157440,
    SF_FORMAT_SHN___18 = 68222976,
    SF_FORMAT_SVX_FIB___18 = 4128,
    SF_FORMAT_SVX_EXP___18 = 4129,
    SF_FORMAT_PCM_N___18 = 4144
} ;
#line 405
enum __anonenum__117___0 {
    SFE_NO_ERROR___18 = 0,
    SFE_BAD_OPEN_FORMAT___18 = 1,
    SFE_SYSTEM___18 = 2,
    SFE_MALFORMED_FILE___18 = 3,
    SFE_UNSUPPORTED_ENCODING___18 = 4,
    SFE_ZERO_MAJOR_FORMAT___18 = 5,
    SFE_ZERO_MINOR_FORMAT___18 = 6,
    SFE_BAD_FILE___18 = 7,
    SFE_BAD_FILE_READ___18 = 8,
    SFE_OPEN_FAILED___18 = 9,
    SFE_BAD_SNDFILE_PTR___18 = 10,
    SFE_BAD_SF_INFO_PTR___18 = 11,
    SFE_BAD_SF_INCOMPLETE___18 = 12,
    SFE_BAD_FILE_PTR___18 = 13,
    SFE_BAD_INT_PTR___18 = 14,
    SFE_BAD_STAT_SIZE___18 = 15,
    SFE_MALLOC_FAILED___18 = 16,
    SFE_UNIMPLEMENTED___18 = 17,
    SFE_BAD_READ_ALIGN___18 = 18,
    SFE_BAD_WRITE_ALIGN___18 = 19,
    SFE_UNKNOWN_FORMAT___18 = 20,
    SFE_NOT_READMODE___18 = 21,
    SFE_NOT_WRITEMODE___18 = 22,
    SFE_BAD_MODE_RW___18 = 23,
    SFE_BAD_SF_INFO___18 = 24,
    SFE_BAD_OFFSET___18 = 25,
    SFE_NO_EMBED_SUPPORT___18 = 26,
    SFE_NO_EMBEDDED_RDWR___18 = 27,
    SFE_NO_PIPE_WRITE___18 = 28,
    SFE_INTERNAL___18 = 29,
    SFE_BAD_COMMAND_PARAM___18 = 30,
    SFE_BAD_ENDIAN___18 = 31,
    SFE_CHANNEL_COUNT_ZERO___18 = 32,
    SFE_CHANNEL_COUNT___18 = 33,
    SFE_BAD_VIRTUAL_IO___18 = 34,
    SFE_INTERLEAVE_MODE___18 = 35,
    SFE_INTERLEAVE_SEEK___18 = 36,
    SFE_INTERLEAVE_READ___18 = 37,
    SFE_BAD_SEEK___18 = 38,
    SFE_NOT_SEEKABLE___18 = 39,
    SFE_AMBIGUOUS_SEEK___18 = 40,
    SFE_WRONG_SEEK___18 = 41,
    SFE_SEEK_FAILED___18 = 42,
    SFE_BAD_OPEN_MODE___18 = 43,
    SFE_OPEN_PIPE_RDWR___18 = 44,
    SFE_RDWR_POSITION___18 = 45,
    SFE_RDWR_BAD_HEADER___18 = 46,
    SFE_CMD_HAS_DATA___18 = 47,
    SFE_BAD_BROADCAST_INFO_SIZE___18 = 48,
    SFE_STR_NO_SUPPORT___18 = 49,
    SFE_STR_NOT_WRITE___18 = 50,
    SFE_STR_MAX_DATA___18 = 51,
    SFE_STR_MAX_COUNT___18 = 52,
    SFE_STR_BAD_TYPE___18 = 53,
    SFE_STR_NO_ADD_END___18 = 54,
    SFE_STR_BAD_STRING___18 = 55,
    SFE_STR_WEIRD___18 = 56,
    SFE_WAV_NO_RIFF___18 = 57,
    SFE_WAV_NO_WAVE___18 = 58,
    SFE_WAV_NO_FMT___18 = 59,
    SFE_WAV_BAD_FMT___18 = 60,
    SFE_WAV_FMT_SHORT___18 = 61,
    SFE_WAV_BAD_FACT___18 = 62,
    SFE_WAV_BAD_PEAK___18 = 63,
    SFE_WAV_PEAK_B4_FMT___18 = 64,
    SFE_WAV_BAD_FORMAT___18 = 65,
    SFE_WAV_BAD_BLOCKALIGN___18 = 66,
    SFE_WAV_NO_DATA___18 = 67,
    SFE_WAV_BAD_LIST___18 = 68,
    SFE_WAV_ADPCM_NOT4BIT___18 = 69,
    SFE_WAV_ADPCM_CHANNELS___18 = 70,
    SFE_WAV_GSM610_FORMAT___18 = 71,
    SFE_WAV_UNKNOWN_CHUNK___18 = 72,
    SFE_WAV_WVPK_DATA___18 = 73,
    SFE_AIFF_NO_FORM___18 = 74,
    SFE_AIFF_AIFF_NO_FORM___18 = 75,
    SFE_AIFF_COMM_NO_FORM___18 = 76,
    SFE_AIFF_SSND_NO_COMM___18 = 77,
    SFE_AIFF_UNKNOWN_CHUNK___18 = 78,
    SFE_AIFF_COMM_CHUNK_SIZE___18 = 79,
    SFE_AIFF_BAD_COMM_CHUNK___18 = 80,
    SFE_AIFF_PEAK_B4_COMM___18 = 81,
    SFE_AIFF_BAD_PEAK___18 = 82,
    SFE_AIFF_NO_SSND___18 = 83,
    SFE_AIFF_NO_DATA___18 = 84,
    SFE_AIFF_RW_SSND_NOT_LAST___18 = 85,
    SFE_AU_UNKNOWN_FORMAT___18 = 86,
    SFE_AU_NO_DOTSND___18 = 87,
    SFE_AU_EMBED_BAD_LEN___18 = 88,
    SFE_RAW_READ_BAD_SPEC___18 = 89,
    SFE_RAW_BAD_BITWIDTH___18 = 90,
    SFE_RAW_BAD_FORMAT___18 = 91,
    SFE_PAF_NO_MARKER___18 = 92,
    SFE_PAF_VERSION___18 = 93,
    SFE_PAF_UNKNOWN_FORMAT___18 = 94,
    SFE_PAF_SHORT_HEADER___18 = 95,
    SFE_SVX_NO_FORM___18 = 96,
    SFE_SVX_NO_BODY___18 = 97,
    SFE_SVX_NO_DATA___18 = 98,
    SFE_SVX_BAD_COMP___18 = 99,
    SFE_SVX_BAD_NAME_LENGTH___18 = 100,
    SFE_NIST_BAD_HEADER___18 = 101,
    SFE_NIST_CRLF_CONVERISON___18 = 102,
    SFE_NIST_BAD_ENCODING___18 = 103,
    SFE_VOC_NO_CREATIVE___18 = 104,
    SFE_VOC_BAD_FORMAT___18 = 105,
    SFE_VOC_BAD_VERSION___18 = 106,
    SFE_VOC_BAD_MARKER___18 = 107,
    SFE_VOC_BAD_SECTIONS___18 = 108,
    SFE_VOC_MULTI_SAMPLERATE___18 = 109,
    SFE_VOC_MULTI_SECTION___18 = 110,
    SFE_VOC_MULTI_PARAM___18 = 111,
    SFE_VOC_SECTION_COUNT___18 = 112,
    SFE_VOC_NO_PIPE___18 = 113,
    SFE_IRCAM_NO_MARKER___18 = 114,
    SFE_IRCAM_BAD_CHANNELS___18 = 115,
    SFE_IRCAM_UNKNOWN_FORMAT___18 = 116,
    SFE_W64_64_BIT___18 = 117,
    SFE_W64_NO_RIFF___18 = 118,
    SFE_W64_NO_WAVE___18 = 119,
    SFE_W64_NO_DATA___18 = 120,
    SFE_W64_ADPCM_NOT4BIT___18 = 121,
    SFE_W64_ADPCM_CHANNELS___18 = 122,
    SFE_W64_GSM610_FORMAT___18 = 123,
    SFE_MAT4_BAD_NAME___18 = 124,
    SFE_MAT4_NO_SAMPLERATE___18 = 125,
    SFE_MAT5_BAD_ENDIAN___18 = 126,
    SFE_MAT5_NO_BLOCK___18 = 127,
    SFE_MAT5_SAMPLE_RATE___18 = 128,
    SFE_PVF_NO_PVF1___18 = 129,
    SFE_PVF_BAD_HEADER___18 = 130,
    SFE_PVF_BAD_BITWIDTH___18 = 131,
    SFE_DWVW_BAD_BITWIDTH___18 = 132,
    SFE_G72X_NOT_MONO___18 = 133,
    SFE_XI_BAD_HEADER___18 = 134,
    SFE_XI_EXCESS_SAMPLES___18 = 135,
    SFE_XI_NO_PIPE___18 = 136,
    SFE_HTK_NO_PIPE___18 = 137,
    SFE_SDS_NOT_SDS___18 = 138,
    SFE_SDS_BAD_BIT_WIDTH___18 = 139,
    SFE_SD2_FD_DISALLOWED___18 = 140,
    SFE_SD2_BAD_DATA_OFFSET___18 = 141,
    SFE_SD2_BAD_MAP_OFFSET___18 = 142,
    SFE_SD2_BAD_DATA_LENGTH___18 = 143,
    SFE_SD2_BAD_MAP_LENGTH___18 = 144,
    SFE_SD2_BAD_RSRC___18 = 145,
    SFE_SD2_BAD_SAMPLE_SIZE___18 = 146,
    SFE_FLAC_BAD_HEADER___18 = 147,
    SFE_FLAC_NEW_DECODER___18 = 148,
    SFE_FLAC_INIT_DECODER___18 = 149,
    SFE_FLAC_LOST_SYNC___18 = 150,
    SFE_FLAC_BAD_SAMPLE_RATE___18 = 151,
    SFE_FLAC_UNKOWN_ERROR___18 = 152,
    SFE_WVE_NOT_WVE___18 = 153,
    SFE_WVE_NO_PIPE___18 = 154,
    SFE_VORBIS_ENCODER_BUG___18 = 155,
    SFE_RF64_NOT_RF64___18 = 156,
    SFE_MAX_ERROR___18 = 157
} ;
#line 823
enum __anonenum__121___0 {
    SFC_TEST_AIFF_ADD_INST_CHUNK___18 = 8192,
    SFC_TEST_WAV_ADD_INFO_CHUNK___18 = 8208
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__510 {
    _ISupper___0 = 256,
    _ISlower___0 = 512,
    _ISalpha___0 = 1024,
    _ISdigit___0 = 2048,
    _ISxdigit___0 = 4096,
    _ISspace___0 = 8192,
    _ISprint___0 = 16384,
    _ISgraph___0 = 32768,
    _ISblank___0 = 1,
    _IScntrl___0 = 2,
    _ISpunct___0 = 4,
    _ISalnum___0 = 8
} ;
#line 46 "/root/libsndfile/src/sndfile.h"
enum __anonenum__524 {
    SF_FORMAT_WAV___19 = 65536,
    SF_FORMAT_AIFF___19 = 131072,
    SF_FORMAT_AU___19 = 196608,
    SF_FORMAT_RAW___19 = 262144,
    SF_FORMAT_PAF___19 = 327680,
    SF_FORMAT_SVX___19 = 393216,
    SF_FORMAT_NIST___19 = 458752,
    SF_FORMAT_VOC___19 = 524288,
    SF_FORMAT_IRCAM___19 = 655360,
    SF_FORMAT_W64___19 = 720896,
    SF_FORMAT_MAT4___19 = 786432,
    SF_FORMAT_MAT5___19 = 851968,
    SF_FORMAT_PVF___19 = 917504,
    SF_FORMAT_XI___19 = 983040,
    SF_FORMAT_HTK___19 = 1048576,
    SF_FORMAT_SDS___19 = 1114112,
    SF_FORMAT_AVR___19 = 1179648,
    SF_FORMAT_WAVEX___19 = 1245184,
    SF_FORMAT_SD2___19 = 1441792,
    SF_FORMAT_FLAC___19 = 1507328,
    SF_FORMAT_CAF___19 = 1572864,
    SF_FORMAT_WVE___19 = 1638400,
    SF_FORMAT_OGG___19 = 2097152,
    SF_FORMAT_MPC2K___19 = 2162688,
    SF_FORMAT_RF64___19 = 2228224,
    SF_FORMAT_PCM_S8___19 = 1,
    SF_FORMAT_PCM_16___19 = 2,
    SF_FORMAT_PCM_24___19 = 3,
    SF_FORMAT_PCM_32___19 = 4,
    SF_FORMAT_PCM_U8___19 = 5,
    SF_FORMAT_FLOAT___19 = 6,
    SF_FORMAT_DOUBLE___19 = 7,
    SF_FORMAT_ULAW___19 = 16,
    SF_FORMAT_ALAW___19 = 17,
    SF_FORMAT_IMA_ADPCM___19 = 18,
    SF_FORMAT_MS_ADPCM___19 = 19,
    SF_FORMAT_GSM610___19 = 32,
    SF_FORMAT_VOX_ADPCM___19 = 33,
    SF_FORMAT_G721_32___19 = 48,
    SF_FORMAT_G723_24___19 = 49,
    SF_FORMAT_G723_40___19 = 50,
    SF_FORMAT_DWVW_12___19 = 64,
    SF_FORMAT_DWVW_16___19 = 65,
    SF_FORMAT_DWVW_24___19 = 66,
    SF_FORMAT_DWVW_N___19 = 67,
    SF_FORMAT_DPCM_8___19 = 80,
    SF_FORMAT_DPCM_16___19 = 81,
    SF_FORMAT_VORBIS___19 = 96,
    SF_ENDIAN_FILE___19 = 0,
    SF_ENDIAN_LITTLE___19 = 268435456,
    SF_ENDIAN_BIG___19 = 536870912,
    SF_ENDIAN_CPU___19 = 805306368,
    SF_FORMAT_SUBMASK___19 = 65535,
    SF_FORMAT_TYPEMASK___19 = 268369920,
    SF_FORMAT_ENDMASK___19 = 805306368
} ;
#line 126
enum __anonenum__525 {
    SFC_GET_LIB_VERSION___19 = 4096,
    SFC_GET_LOG_INFO___19 = 4097,
    SFC_GET_CURRENT_SF_INFO___19 = 4098,
    SFC_GET_NORM_DOUBLE___19 = 4112,
    SFC_GET_NORM_FLOAT___19 = 4113,
    SFC_SET_NORM_DOUBLE___19 = 4114,
    SFC_SET_NORM_FLOAT___19 = 4115,
    SFC_SET_SCALE_FLOAT_INT_READ___19 = 4116,
    SFC_SET_SCALE_INT_FLOAT_WRITE___19 = 4117,
    SFC_GET_SIMPLE_FORMAT_COUNT___19 = 4128,
    SFC_GET_SIMPLE_FORMAT___19 = 4129,
    SFC_GET_FORMAT_INFO___19 = 4136,
    SFC_GET_FORMAT_MAJOR_COUNT___19 = 4144,
    SFC_GET_FORMAT_MAJOR___19 = 4145,
    SFC_GET_FORMAT_SUBTYPE_COUNT___19 = 4146,
    SFC_GET_FORMAT_SUBTYPE___19 = 4147,
    SFC_CALC_SIGNAL_MAX___19 = 4160,
    SFC_CALC_NORM_SIGNAL_MAX___19 = 4161,
    SFC_CALC_MAX_ALL_CHANNELS___19 = 4162,
    SFC_CALC_NORM_MAX_ALL_CHANNELS___19 = 4163,
    SFC_GET_SIGNAL_MAX___19 = 4164,
    SFC_GET_MAX_ALL_CHANNELS___19 = 4165,
    SFC_SET_ADD_PEAK_CHUNK___19 = 4176,
    SFC_SET_ADD_HEADER_PAD_CHUNK___19 = 4177,
    SFC_UPDATE_HEADER_NOW___19 = 4192,
    SFC_SET_UPDATE_HEADER_AUTO___19 = 4193,
    SFC_FILE_TRUNCATE___19 = 4224,
    SFC_SET_RAW_START_OFFSET___19 = 4240,
    SFC_SET_DITHER_ON_WRITE___19 = 4256,
    SFC_SET_DITHER_ON_READ___19 = 4257,
    SFC_GET_DITHER_INFO_COUNT___19 = 4258,
    SFC_GET_DITHER_INFO___19 = 4259,
    SFC_GET_EMBED_FILE_INFO___19 = 4272,
    SFC_SET_CLIPPING___19 = 4288,
    SFC_GET_CLIPPING___19 = 4289,
    SFC_GET_INSTRUMENT___19 = 4304,
    SFC_SET_INSTRUMENT___19 = 4305,
    SFC_GET_LOOP_INFO___19 = 4320,
    SFC_GET_BROADCAST_INFO___19 = 4336,
    SFC_SET_BROADCAST_INFO___19 = 4337,
    SFC_GET_CHANNEL_MAP_INFO___19 = 4352,
    SFC_SET_CHANNEL_MAP_INFO___19 = 4353,
    SFC_RAW_DATA_NEEDS_ENDSWAP___19 = 4368,
    SFC_WAVEX_SET_AMBISONIC___19 = 4608,
    SFC_WAVEX_GET_AMBISONIC___19 = 4609,
    SFC_SET_VBR_ENCODING_QUALITY___19 = 4864,
    SFC_TEST_IEEE_FLOAT_REPLACE___19 = 24577,
    SFC_SET_ADD_DITHER_ON_WRITE___19 = 4208,
    SFC_SET_ADD_DITHER_ON_READ___19 = 4209
} ;
#line 216
enum __anonenum__526 {
    SF_STR_TITLE___19 = 1,
    SF_STR_COPYRIGHT___19 = 2,
    SF_STR_SOFTWARE___19 = 3,
    SF_STR_ARTIST___19 = 4,
    SF_STR_COMMENT___19 = 5,
    SF_STR_DATE___19 = 6,
    SF_STR_ALBUM___19 = 7,
    SF_STR_LICENSE___19 = 8
} ;
#line 235
enum __anonenum__527 {
    SF_FALSE___19 = 0,
    SF_TRUE___19 = 1,
    SFM_READ___19 = 16,
    SFM_WRITE___19 = 32,
    SFM_RDWR___19 = 48,
    SF_AMBISONIC_NONE___19 = 64,
    SF_AMBISONIC_B_FORMAT___19 = 65
} ;
#line 255
enum __anonenum__528 {
    SF_ERR_NO_ERROR___19 = 0,
    SF_ERR_UNRECOGNISED_FORMAT___19 = 1,
    SF_ERR_SYSTEM___19 = 2,
    SF_ERR_MALFORMED_FILE___19 = 3,
    SF_ERR_UNSUPPORTED_ENCODING___19 = 4
} ;
#line 267
enum __anonenum__529 {
    SF_CHANNEL_MAP_INVALID___19 = 0,
    SF_CHANNEL_MAP_MONO___19 = 1,
    SF_CHANNEL_MAP_LEFT___19 = 2,
    SF_CHANNEL_MAP_RIGHT___19 = 3,
    SF_CHANNEL_MAP_CENTER___19 = 4,
    SF_CHANNEL_MAP_FRONT_LEFT___19 = 5,
    SF_CHANNEL_MAP_FRONT_RIGHT___19 = 6,
    SF_CHANNEL_MAP_FRONT_CENTER___19 = 7,
    SF_CHANNEL_MAP_REAR_CENTER___19 = 8,
    SF_CHANNEL_MAP_REAR_LEFT___19 = 9,
    SF_CHANNEL_MAP_REAR_RIGHT___19 = 10,
    SF_CHANNEL_MAP_LFE___19 = 11,
    SF_CHANNEL_MAP_FRONT_LEFT_OF_CENTER___19 = 12,
    SF_CHANNEL_MAP_FRONT_RIGHT_OF_CENTER___19 = 13,
    SF_CHANNEL_MAP_SIDE_LEFT___19 = 14,
    SF_CHANNEL_MAP_SIDE_RIGHT___19 = 15,
    SF_CHANNEL_MAP_TOP_CENTER___19 = 16,
    SF_CHANNEL_MAP_TOP_FRONT_LEFT___19 = 17,
    SF_CHANNEL_MAP_TOP_FRONT_RIGHT___19 = 18,
    SF_CHANNEL_MAP_TOP_FRONT_CENTER___19 = 19,
    SF_CHANNEL_MAP_TOP_REAR_LEFT___19 = 20,
    SF_CHANNEL_MAP_TOP_REAR_RIGHT___19 = 21,
    SF_CHANNEL_MAP_TOP_REAR_CENTER___19 = 22
} ;
#line 352
enum __anonenum__531 {
    SFD_DEFAULT_LEVEL___19 = 0,
    SFD_CUSTOM_LEVEL___19 = 1073741824,
    SFD_NO_DITHER___19 = 500,
    SFD_WHITE___19 = 501,
    SFD_TRIANGULAR_PDF___19 = 502
} ;
#line 380
enum __anonenum__534 {
    SF_LOOP_NONE___19 = 800,
    SF_LOOP_FORWARD___19 = 801,
    SF_LOOP_BACKWARD___19 = 802,
    SF_LOOP_ALTERNATING___19 = 803
} ;
#line 121 "/root/libsndfile/src/common.h"
enum __anonenum__543 {
    SF_PEAK_START___19 = 42,
    SF_PEAK_END___19 = 43,
    SF_SCALE_MAX___19 = 52,
    SF_SCALE_MIN___19 = 53,
    SF_STR_ALLOW_START___19 = 256,
    SF_STR_ALLOW_END___19 = 512,
    SF_STR_LOCATE_START___19 = 1024,
    SF_STR_LOCATE_END___19 = 2048,
    SFD_TYPEMASK___19 = 268435455
} ;
#line 149
enum __anonenum__544 {
    SF_FORMAT_TXW___19 = 67305472,
    SF_FORMAT_DWD___19 = 67371008,
    SF_FORMAT_REX___19 = 67764224,
    SF_FORMAT_REX2___19 = 67960832,
    SF_FORMAT_KRZ___19 = 68026368,
    SF_FORMAT_WMA___19 = 68157440,
    SF_FORMAT_SHN___19 = 68222976,
    SF_FORMAT_SVX_FIB___19 = 4128,
    SF_FORMAT_SVX_EXP___19 = 4129,
    SF_FORMAT_PCM_N___19 = 4144
} ;
#line 405
enum __anonenum__550 {
    SFE_NO_ERROR___19 = 0,
    SFE_BAD_OPEN_FORMAT___19 = 1,
    SFE_SYSTEM___19 = 2,
    SFE_MALFORMED_FILE___19 = 3,
    SFE_UNSUPPORTED_ENCODING___19 = 4,
    SFE_ZERO_MAJOR_FORMAT___19 = 5,
    SFE_ZERO_MINOR_FORMAT___19 = 6,
    SFE_BAD_FILE___19 = 7,
    SFE_BAD_FILE_READ___19 = 8,
    SFE_OPEN_FAILED___19 = 9,
    SFE_BAD_SNDFILE_PTR___19 = 10,
    SFE_BAD_SF_INFO_PTR___19 = 11,
    SFE_BAD_SF_INCOMPLETE___19 = 12,
    SFE_BAD_FILE_PTR___19 = 13,
    SFE_BAD_INT_PTR___19 = 14,
    SFE_BAD_STAT_SIZE___19 = 15,
    SFE_MALLOC_FAILED___19 = 16,
    SFE_UNIMPLEMENTED___19 = 17,
    SFE_BAD_READ_ALIGN___19 = 18,
    SFE_BAD_WRITE_ALIGN___19 = 19,
    SFE_UNKNOWN_FORMAT___19 = 20,
    SFE_NOT_READMODE___19 = 21,
    SFE_NOT_WRITEMODE___19 = 22,
    SFE_BAD_MODE_RW___19 = 23,
    SFE_BAD_SF_INFO___19 = 24,
    SFE_BAD_OFFSET___19 = 25,
    SFE_NO_EMBED_SUPPORT___19 = 26,
    SFE_NO_EMBEDDED_RDWR___19 = 27,
    SFE_NO_PIPE_WRITE___19 = 28,
    SFE_INTERNAL___19 = 29,
    SFE_BAD_COMMAND_PARAM___19 = 30,
    SFE_BAD_ENDIAN___19 = 31,
    SFE_CHANNEL_COUNT_ZERO___19 = 32,
    SFE_CHANNEL_COUNT___19 = 33,
    SFE_BAD_VIRTUAL_IO___19 = 34,
    SFE_INTERLEAVE_MODE___19 = 35,
    SFE_INTERLEAVE_SEEK___19 = 36,
    SFE_INTERLEAVE_READ___19 = 37,
    SFE_BAD_SEEK___19 = 38,
    SFE_NOT_SEEKABLE___19 = 39,
    SFE_AMBIGUOUS_SEEK___19 = 40,
    SFE_WRONG_SEEK___19 = 41,
    SFE_SEEK_FAILED___19 = 42,
    SFE_BAD_OPEN_MODE___19 = 43,
    SFE_OPEN_PIPE_RDWR___19 = 44,
    SFE_RDWR_POSITION___19 = 45,
    SFE_RDWR_BAD_HEADER___19 = 46,
    SFE_CMD_HAS_DATA___19 = 47,
    SFE_BAD_BROADCAST_INFO_SIZE___19 = 48,
    SFE_STR_NO_SUPPORT___19 = 49,
    SFE_STR_NOT_WRITE___19 = 50,
    SFE_STR_MAX_DATA___19 = 51,
    SFE_STR_MAX_COUNT___19 = 52,
    SFE_STR_BAD_TYPE___19 = 53,
    SFE_STR_NO_ADD_END___19 = 54,
    SFE_STR_BAD_STRING___19 = 55,
    SFE_STR_WEIRD___19 = 56,
    SFE_WAV_NO_RIFF___19 = 57,
    SFE_WAV_NO_WAVE___19 = 58,
    SFE_WAV_NO_FMT___19 = 59,
    SFE_WAV_BAD_FMT___19 = 60,
    SFE_WAV_FMT_SHORT___19 = 61,
    SFE_WAV_BAD_FACT___19 = 62,
    SFE_WAV_BAD_PEAK___19 = 63,
    SFE_WAV_PEAK_B4_FMT___19 = 64,
    SFE_WAV_BAD_FORMAT___19 = 65,
    SFE_WAV_BAD_BLOCKALIGN___19 = 66,
    SFE_WAV_NO_DATA___19 = 67,
    SFE_WAV_BAD_LIST___19 = 68,
    SFE_WAV_ADPCM_NOT4BIT___19 = 69,
    SFE_WAV_ADPCM_CHANNELS___19 = 70,
    SFE_WAV_GSM610_FORMAT___19 = 71,
    SFE_WAV_UNKNOWN_CHUNK___19 = 72,
    SFE_WAV_WVPK_DATA___19 = 73,
    SFE_AIFF_NO_FORM___19 = 74,
    SFE_AIFF_AIFF_NO_FORM___19 = 75,
    SFE_AIFF_COMM_NO_FORM___19 = 76,
    SFE_AIFF_SSND_NO_COMM___19 = 77,
    SFE_AIFF_UNKNOWN_CHUNK___19 = 78,
    SFE_AIFF_COMM_CHUNK_SIZE___19 = 79,
    SFE_AIFF_BAD_COMM_CHUNK___19 = 80,
    SFE_AIFF_PEAK_B4_COMM___19 = 81,
    SFE_AIFF_BAD_PEAK___19 = 82,
    SFE_AIFF_NO_SSND___19 = 83,
    SFE_AIFF_NO_DATA___19 = 84,
    SFE_AIFF_RW_SSND_NOT_LAST___19 = 85,
    SFE_AU_UNKNOWN_FORMAT___19 = 86,
    SFE_AU_NO_DOTSND___19 = 87,
    SFE_AU_EMBED_BAD_LEN___19 = 88,
    SFE_RAW_READ_BAD_SPEC___19 = 89,
    SFE_RAW_BAD_BITWIDTH___19 = 90,
    SFE_RAW_BAD_FORMAT___19 = 91,
    SFE_PAF_NO_MARKER___19 = 92,
    SFE_PAF_VERSION___19 = 93,
    SFE_PAF_UNKNOWN_FORMAT___19 = 94,
    SFE_PAF_SHORT_HEADER___19 = 95,
    SFE_SVX_NO_FORM___19 = 96,
    SFE_SVX_NO_BODY___19 = 97,
    SFE_SVX_NO_DATA___19 = 98,
    SFE_SVX_BAD_COMP___19 = 99,
    SFE_SVX_BAD_NAME_LENGTH___19 = 100,
    SFE_NIST_BAD_HEADER___19 = 101,
    SFE_NIST_CRLF_CONVERISON___19 = 102,
    SFE_NIST_BAD_ENCODING___19 = 103,
    SFE_VOC_NO_CREATIVE___19 = 104,
    SFE_VOC_BAD_FORMAT___19 = 105,
    SFE_VOC_BAD_VERSION___19 = 106,
    SFE_VOC_BAD_MARKER___19 = 107,
    SFE_VOC_BAD_SECTIONS___19 = 108,
    SFE_VOC_MULTI_SAMPLERATE___19 = 109,
    SFE_VOC_MULTI_SECTION___19 = 110,
    SFE_VOC_MULTI_PARAM___19 = 111,
    SFE_VOC_SECTION_COUNT___19 = 112,
    SFE_VOC_NO_PIPE___19 = 113,
    SFE_IRCAM_NO_MARKER___19 = 114,
    SFE_IRCAM_BAD_CHANNELS___19 = 115,
    SFE_IRCAM_UNKNOWN_FORMAT___19 = 116,
    SFE_W64_64_BIT___19 = 117,
    SFE_W64_NO_RIFF___19 = 118,
    SFE_W64_NO_WAVE___19 = 119,
    SFE_W64_NO_DATA___19 = 120,
    SFE_W64_ADPCM_NOT4BIT___19 = 121,
    SFE_W64_ADPCM_CHANNELS___19 = 122,
    SFE_W64_GSM610_FORMAT___19 = 123,
    SFE_MAT4_BAD_NAME___19 = 124,
    SFE_MAT4_NO_SAMPLERATE___19 = 125,
    SFE_MAT5_BAD_ENDIAN___19 = 126,
    SFE_MAT5_NO_BLOCK___19 = 127,
    SFE_MAT5_SAMPLE_RATE___19 = 128,
    SFE_PVF_NO_PVF1___19 = 129,
    SFE_PVF_BAD_HEADER___19 = 130,
    SFE_PVF_BAD_BITWIDTH___19 = 131,
    SFE_DWVW_BAD_BITWIDTH___19 = 132,
    SFE_G72X_NOT_MONO___19 = 133,
    SFE_XI_BAD_HEADER___19 = 134,
    SFE_XI_EXCESS_SAMPLES___19 = 135,
    SFE_XI_NO_PIPE___19 = 136,
    SFE_HTK_NO_PIPE___19 = 137,
    SFE_SDS_NOT_SDS___19 = 138,
    SFE_SDS_BAD_BIT_WIDTH___19 = 139,
    SFE_SD2_FD_DISALLOWED___19 = 140,
    SFE_SD2_BAD_DATA_OFFSET___19 = 141,
    SFE_SD2_BAD_MAP_OFFSET___19 = 142,
    SFE_SD2_BAD_DATA_LENGTH___19 = 143,
    SFE_SD2_BAD_MAP_LENGTH___19 = 144,
    SFE_SD2_BAD_RSRC___19 = 145,
    SFE_SD2_BAD_SAMPLE_SIZE___19 = 146,
    SFE_FLAC_BAD_HEADER___19 = 147,
    SFE_FLAC_NEW_DECODER___19 = 148,
    SFE_FLAC_INIT_DECODER___19 = 149,
    SFE_FLAC_LOST_SYNC___19 = 150,
    SFE_FLAC_BAD_SAMPLE_RATE___19 = 151,
    SFE_FLAC_UNKOWN_ERROR___19 = 152,
    SFE_WVE_NOT_WVE___19 = 153,
    SFE_WVE_NO_PIPE___19 = 154,
    SFE_VORBIS_ENCODER_BUG___19 = 155,
    SFE_RF64_NOT_RF64___19 = 156,
    SFE_MAX_ERROR___19 = 157
} ;
#line 823
enum __anonenum__554 {
    SFC_TEST_AIFF_ADD_INST_CHUNK___19 = 8192,
    SFC_TEST_WAV_ADD_INFO_CHUNK___19 = 8208
} ;
#line 29 "/root/libsndfile/src/wav_w64.h"
enum __anonenum__555 {
    WAVE_FORMAT_UNKNOWN___1 = 0,
    WAVE_FORMAT_PCM___1 = 1,
    WAVE_FORMAT_MS_ADPCM___1 = 2,
    WAVE_FORMAT_IEEE_FLOAT___1 = 3,
    WAVE_FORMAT_VSELP___1 = 4,
    WAVE_FORMAT_IBM_CVSD___1 = 5,
    WAVE_FORMAT_ALAW___1 = 6,
    WAVE_FORMAT_MULAW___1 = 7,
    WAVE_FORMAT_OKI_ADPCM___1 = 16,
    WAVE_FORMAT_IMA_ADPCM___1 = 17,
    WAVE_FORMAT_MEDIASPACE_ADPCM___1 = 18,
    WAVE_FORMAT_SIERRA_ADPCM___1 = 19,
    WAVE_FORMAT_G723_ADPCM___1 = 20,
    WAVE_FORMAT_DIGISTD___1 = 21,
    WAVE_FORMAT_DIGIFIX___1 = 22,
    WAVE_FORMAT_DIALOGIC_OKI_ADPCM___1 = 23,
    WAVE_FORMAT_MEDIAVISION_ADPCM___1 = 24,
    WAVE_FORMAT_CU_CODEC___1 = 25,
    WAVE_FORMAT_YAMAHA_ADPCM___1 = 32,
    WAVE_FORMAT_SONARC___1 = 33,
    WAVE_FORMAT_DSPGROUP_TRUESPEECH___1 = 34,
    WAVE_FORMAT_ECHOSC1___1 = 35,
    WAVE_FORMAT_AUDIOFILE_AF36___1 = 36,
    WAVE_FORMAT_APTX___1 = 37,
    WAVE_FORMAT_AUDIOFILE_AF10___1 = 38,
    WAVE_FORMAT_PROSODY_1612___1 = 39,
    WAVE_FORMAT_LRC___1 = 40,
    WAVE_FORMAT_DOLBY_AC2___1 = 48,
    WAVE_FORMAT_GSM610___1 = 49,
    WAVE_FORMAT_MSNAUDIO___1 = 50,
    WAVE_FORMAT_ANTEX_ADPCME___1 = 51,
    WAVE_FORMAT_CONTROL_RES_VQLPC___1 = 52,
    WAVE_FORMAT_DIGIREAL___1 = 53,
    WAVE_FORMAT_DIGIADPCM___1 = 54,
    WAVE_FORMAT_CONTROL_RES_CR10___1 = 55,
    WAVE_FORMAT_NMS_VBXADPCM___1 = 56,
    WAVE_FORMAT_ROLAND_RDAC___1 = 57,
    WAVE_FORMAT_ECHOSC3___1 = 58,
    WAVE_FORMAT_ROCKWELL_ADPCM___1 = 59,
    WAVE_FORMAT_ROCKWELL_DIGITALK___1 = 60,
    WAVE_FORMAT_XEBEC___1 = 61,
    WAVE_FORMAT_G721_ADPCM___1 = 64,
    WAVE_FORMAT_G728_CELP___1 = 65,
    WAVE_FORMAT_MSG723___1 = 66,
    WAVE_FORMAT_MPEG___1 = 80,
    WAVE_FORMAT_RT24___1 = 82,
    WAVE_FORMAT_PAC___1 = 83,
    WAVE_FORMAT_MPEGLAYER3___1 = 85,
    WAVE_FORMAT_LUCENT_G723___1 = 89,
    WAVE_FORMAT_CIRRUS___1 = 96,
    WAVE_FORMAT_ESPCM___1 = 97,
    WAVE_FORMAT_VOXWARE___1 = 98,
    WAVE_FORMAT_CANOPUS_ATRAC___1 = 99,
    WAVE_FORMAT_G726_ADPCM___1 = 100,
    WAVE_FORMAT_G722_ADPCM___1 = 101,
    WAVE_FORMAT_DSAT___1 = 102,
    WAVE_FORMAT_DSAT_DISPLAY___1 = 103,
    WAVE_FORMAT_VOXWARE_BYTE_ALIGNED___1 = 105,
    WAVE_FORMAT_VOXWARE_AC8___1 = 112,
    WAVE_FORMAT_VOXWARE_AC10___1 = 113,
    WAVE_FORMAT_VOXWARE_AC16___1 = 114,
    WAVE_FORMAT_VOXWARE_AC20___1 = 115,
    WAVE_FORMAT_VOXWARE_RT24___1 = 116,
    WAVE_FORMAT_VOXWARE_RT29___1 = 117,
    WAVE_FORMAT_VOXWARE_RT29HW___1 = 118,
    WAVE_FORMAT_VOXWARE_VR12___1 = 119,
    WAVE_FORMAT_VOXWARE_VR18___1 = 120,
    WAVE_FORMAT_VOXWARE_TQ40___1 = 121,
    WAVE_FORMAT_SOFTSOUND___1 = 128,
    WAVE_FORMAT_VOXARE_TQ60___1 = 129,
    WAVE_FORMAT_MSRT24___1 = 130,
    WAVE_FORMAT_G729A___1 = 131,
    WAVE_FORMAT_MVI_MV12___1 = 132,
    WAVE_FORMAT_DF_G726___1 = 133,
    WAVE_FORMAT_DF_GSM610___1 = 134,
    WAVE_FORMAT_ONLIVE___1 = 137,
    WAVE_FORMAT_SBC24___1 = 145,
    WAVE_FORMAT_DOLBY_AC3_SPDIF___1 = 146,
    WAVE_FORMAT_ZYXEL_ADPCM___1 = 151,
    WAVE_FORMAT_PHILIPS_LPCBB___1 = 152,
    WAVE_FORMAT_PACKED___1 = 153,
    WAVE_FORMAT_RHETOREX_ADPCM___1 = 256,
    IBM_FORMAT_MULAW___1 = 257,
    IBM_FORMAT_ALAW___1 = 258,
    IBM_FORMAT_ADPCM___1 = 259,
    WAVE_FORMAT_VIVO_G723___1 = 273,
    WAVE_FORMAT_VIVO_SIREN___1 = 274,
    WAVE_FORMAT_DIGITAL_G723___1 = 291,
    WAVE_FORMAT_CREATIVE_ADPCM___1 = 512,
    WAVE_FORMAT_CREATIVE_FASTSPEECH8___1 = 514,
    WAVE_FORMAT_CREATIVE_FASTSPEECH10___1 = 515,
    WAVE_FORMAT_QUARTERDECK___1 = 544,
    WAVE_FORMAT_FM_TOWNS_SND___1 = 768,
    WAVE_FORMAT_BZV_DIGITAL___1 = 1024,
    WAVE_FORMAT_VME_VMPCM___1 = 1664,
    WAVE_FORMAT_OLIGSM___1 = 4096,
    WAVE_FORMAT_OLIADPCM___1 = 4097,
    WAVE_FORMAT_OLICELP___1 = 4098,
    WAVE_FORMAT_OLISBC___1 = 4099,
    WAVE_FORMAT_OLIOPR___1 = 4100,
    WAVE_FORMAT_LH_CODEC___1 = 4352,
    WAVE_FORMAT_NORRIS___1 = 5120,
    WAVE_FORMAT_SOUNDSPACE_MUSICOMPRESS___1 = 5376,
    WAVE_FORMAT_DVM___1 = 8192,
    WAVE_FORMAT_INTERWAV_VSC112___1 = 29008,
    WAVE_FORMAT_IPP_ITU_G_723_1___1 = 29232,
    WAVE_FORMAT_EXTENSIBLE___1 = 65534
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__510___0 {
    _ISupper___1 = 256,
    _ISlower___1 = 512,
    _ISalpha___1 = 1024,
    _ISdigit___1 = 2048,
    _ISxdigit___1 = 4096,
    _ISspace___1 = 8192,
    _ISprint___1 = 16384,
    _ISgraph___1 = 32768,
    _ISblank___1 = 1,
    _IScntrl___1 = 2,
    _ISpunct___1 = 4,
    _ISalnum___1 = 8
} ;
#line 46 "/root/libsndfile/src/sndfile.h"
enum __anonenum__524___0 {
    SF_FORMAT_WAV___20 = 65536,
    SF_FORMAT_AIFF___20 = 131072,
    SF_FORMAT_AU___20 = 196608,
    SF_FORMAT_RAW___20 = 262144,
    SF_FORMAT_PAF___20 = 327680,
    SF_FORMAT_SVX___20 = 393216,
    SF_FORMAT_NIST___20 = 458752,
    SF_FORMAT_VOC___20 = 524288,
    SF_FORMAT_IRCAM___20 = 655360,
    SF_FORMAT_W64___20 = 720896,
    SF_FORMAT_MAT4___20 = 786432,
    SF_FORMAT_MAT5___20 = 851968,
    SF_FORMAT_PVF___20 = 917504,
    SF_FORMAT_XI___20 = 983040,
    SF_FORMAT_HTK___20 = 1048576,
    SF_FORMAT_SDS___20 = 1114112,
    SF_FORMAT_AVR___20 = 1179648,
    SF_FORMAT_WAVEX___20 = 1245184,
    SF_FORMAT_SD2___20 = 1441792,
    SF_FORMAT_FLAC___20 = 1507328,
    SF_FORMAT_CAF___20 = 1572864,
    SF_FORMAT_WVE___20 = 1638400,
    SF_FORMAT_OGG___20 = 2097152,
    SF_FORMAT_MPC2K___20 = 2162688,
    SF_FORMAT_RF64___20 = 2228224,
    SF_FORMAT_PCM_S8___20 = 1,
    SF_FORMAT_PCM_16___20 = 2,
    SF_FORMAT_PCM_24___20 = 3,
    SF_FORMAT_PCM_32___20 = 4,
    SF_FORMAT_PCM_U8___20 = 5,
    SF_FORMAT_FLOAT___20 = 6,
    SF_FORMAT_DOUBLE___20 = 7,
    SF_FORMAT_ULAW___20 = 16,
    SF_FORMAT_ALAW___20 = 17,
    SF_FORMAT_IMA_ADPCM___20 = 18,
    SF_FORMAT_MS_ADPCM___20 = 19,
    SF_FORMAT_GSM610___20 = 32,
    SF_FORMAT_VOX_ADPCM___20 = 33,
    SF_FORMAT_G721_32___20 = 48,
    SF_FORMAT_G723_24___20 = 49,
    SF_FORMAT_G723_40___20 = 50,
    SF_FORMAT_DWVW_12___20 = 64,
    SF_FORMAT_DWVW_16___20 = 65,
    SF_FORMAT_DWVW_24___20 = 66,
    SF_FORMAT_DWVW_N___20 = 67,
    SF_FORMAT_DPCM_8___20 = 80,
    SF_FORMAT_DPCM_16___20 = 81,
    SF_FORMAT_VORBIS___20 = 96,
    SF_ENDIAN_FILE___20 = 0,
    SF_ENDIAN_LITTLE___20 = 268435456,
    SF_ENDIAN_BIG___20 = 536870912,
    SF_ENDIAN_CPU___20 = 805306368,
    SF_FORMAT_SUBMASK___20 = 65535,
    SF_FORMAT_TYPEMASK___20 = 268369920,
    SF_FORMAT_ENDMASK___20 = 805306368
} ;
#line 126
enum __anonenum__525___0 {
    SFC_GET_LIB_VERSION___20 = 4096,
    SFC_GET_LOG_INFO___20 = 4097,
    SFC_GET_CURRENT_SF_INFO___20 = 4098,
    SFC_GET_NORM_DOUBLE___20 = 4112,
    SFC_GET_NORM_FLOAT___20 = 4113,
    SFC_SET_NORM_DOUBLE___20 = 4114,
    SFC_SET_NORM_FLOAT___20 = 4115,
    SFC_SET_SCALE_FLOAT_INT_READ___20 = 4116,
    SFC_SET_SCALE_INT_FLOAT_WRITE___20 = 4117,
    SFC_GET_SIMPLE_FORMAT_COUNT___20 = 4128,
    SFC_GET_SIMPLE_FORMAT___20 = 4129,
    SFC_GET_FORMAT_INFO___20 = 4136,
    SFC_GET_FORMAT_MAJOR_COUNT___20 = 4144,
    SFC_GET_FORMAT_MAJOR___20 = 4145,
    SFC_GET_FORMAT_SUBTYPE_COUNT___20 = 4146,
    SFC_GET_FORMAT_SUBTYPE___20 = 4147,
    SFC_CALC_SIGNAL_MAX___20 = 4160,
    SFC_CALC_NORM_SIGNAL_MAX___20 = 4161,
    SFC_CALC_MAX_ALL_CHANNELS___20 = 4162,
    SFC_CALC_NORM_MAX_ALL_CHANNELS___20 = 4163,
    SFC_GET_SIGNAL_MAX___20 = 4164,
    SFC_GET_MAX_ALL_CHANNELS___20 = 4165,
    SFC_SET_ADD_PEAK_CHUNK___20 = 4176,
    SFC_SET_ADD_HEADER_PAD_CHUNK___20 = 4177,
    SFC_UPDATE_HEADER_NOW___20 = 4192,
    SFC_SET_UPDATE_HEADER_AUTO___20 = 4193,
    SFC_FILE_TRUNCATE___20 = 4224,
    SFC_SET_RAW_START_OFFSET___20 = 4240,
    SFC_SET_DITHER_ON_WRITE___20 = 4256,
    SFC_SET_DITHER_ON_READ___20 = 4257,
    SFC_GET_DITHER_INFO_COUNT___20 = 4258,
    SFC_GET_DITHER_INFO___20 = 4259,
    SFC_GET_EMBED_FILE_INFO___20 = 4272,
    SFC_SET_CLIPPING___20 = 4288,
    SFC_GET_CLIPPING___20 = 4289,
    SFC_GET_INSTRUMENT___20 = 4304,
    SFC_SET_INSTRUMENT___20 = 4305,
    SFC_GET_LOOP_INFO___20 = 4320,
    SFC_GET_BROADCAST_INFO___20 = 4336,
    SFC_SET_BROADCAST_INFO___20 = 4337,
    SFC_GET_CHANNEL_MAP_INFO___20 = 4352,
    SFC_SET_CHANNEL_MAP_INFO___20 = 4353,
    SFC_RAW_DATA_NEEDS_ENDSWAP___20 = 4368,
    SFC_WAVEX_SET_AMBISONIC___20 = 4608,
    SFC_WAVEX_GET_AMBISONIC___20 = 4609,
    SFC_SET_VBR_ENCODING_QUALITY___20 = 4864,
    SFC_TEST_IEEE_FLOAT_REPLACE___20 = 24577,
    SFC_SET_ADD_DITHER_ON_WRITE___20 = 4208,
    SFC_SET_ADD_DITHER_ON_READ___20 = 4209
} ;
#line 216
enum __anonenum__526___0 {
    SF_STR_TITLE___20 = 1,
    SF_STR_COPYRIGHT___20 = 2,
    SF_STR_SOFTWARE___20 = 3,
    SF_STR_ARTIST___20 = 4,
    SF_STR_COMMENT___20 = 5,
    SF_STR_DATE___20 = 6,
    SF_STR_ALBUM___20 = 7,
    SF_STR_LICENSE___20 = 8
} ;
#line 235
enum __anonenum__527___0 {
    SF_FALSE___20 = 0,
    SF_TRUE___20 = 1,
    SFM_READ___20 = 16,
    SFM_WRITE___20 = 32,
    SFM_RDWR___20 = 48,
    SF_AMBISONIC_NONE___20 = 64,
    SF_AMBISONIC_B_FORMAT___20 = 65
} ;
#line 255
enum __anonenum__528___0 {
    SF_ERR_NO_ERROR___20 = 0,
    SF_ERR_UNRECOGNISED_FORMAT___20 = 1,
    SF_ERR_SYSTEM___20 = 2,
    SF_ERR_MALFORMED_FILE___20 = 3,
    SF_ERR_UNSUPPORTED_ENCODING___20 = 4
} ;
#line 267
enum __anonenum__529___0 {
    SF_CHANNEL_MAP_INVALID___20 = 0,
    SF_CHANNEL_MAP_MONO___20 = 1,
    SF_CHANNEL_MAP_LEFT___20 = 2,
    SF_CHANNEL_MAP_RIGHT___20 = 3,
    SF_CHANNEL_MAP_CENTER___20 = 4,
    SF_CHANNEL_MAP_FRONT_LEFT___20 = 5,
    SF_CHANNEL_MAP_FRONT_RIGHT___20 = 6,
    SF_CHANNEL_MAP_FRONT_CENTER___20 = 7,
    SF_CHANNEL_MAP_REAR_CENTER___20 = 8,
    SF_CHANNEL_MAP_REAR_LEFT___20 = 9,
    SF_CHANNEL_MAP_REAR_RIGHT___20 = 10,
    SF_CHANNEL_MAP_LFE___20 = 11,
    SF_CHANNEL_MAP_FRONT_LEFT_OF_CENTER___20 = 12,
    SF_CHANNEL_MAP_FRONT_RIGHT_OF_CENTER___20 = 13,
    SF_CHANNEL_MAP_SIDE_LEFT___20 = 14,
    SF_CHANNEL_MAP_SIDE_RIGHT___20 = 15,
    SF_CHANNEL_MAP_TOP_CENTER___20 = 16,
    SF_CHANNEL_MAP_TOP_FRONT_LEFT___20 = 17,
    SF_CHANNEL_MAP_TOP_FRONT_RIGHT___20 = 18,
    SF_CHANNEL_MAP_TOP_FRONT_CENTER___20 = 19,
    SF_CHANNEL_MAP_TOP_REAR_LEFT___20 = 20,
    SF_CHANNEL_MAP_TOP_REAR_RIGHT___20 = 21,
    SF_CHANNEL_MAP_TOP_REAR_CENTER___20 = 22
} ;
#line 352
enum __anonenum__531___0 {
    SFD_DEFAULT_LEVEL___20 = 0,
    SFD_CUSTOM_LEVEL___20 = 1073741824,
    SFD_NO_DITHER___20 = 500,
    SFD_WHITE___20 = 501,
    SFD_TRIANGULAR_PDF___20 = 502
} ;
#line 380
enum __anonenum__534___0 {
    SF_LOOP_NONE___20 = 800,
    SF_LOOP_FORWARD___20 = 801,
    SF_LOOP_BACKWARD___20 = 802,
    SF_LOOP_ALTERNATING___20 = 803
} ;
#line 121 "/root/libsndfile/src/common.h"
enum __anonenum__543___0 {
    SF_PEAK_START___20 = 42,
    SF_PEAK_END___20 = 43,
    SF_SCALE_MAX___20 = 52,
    SF_SCALE_MIN___20 = 53,
    SF_STR_ALLOW_START___20 = 256,
    SF_STR_ALLOW_END___20 = 512,
    SF_STR_LOCATE_START___20 = 1024,
    SF_STR_LOCATE_END___20 = 2048,
    SFD_TYPEMASK___20 = 268435455
} ;
#line 149
enum __anonenum__544___0 {
    SF_FORMAT_TXW___20 = 67305472,
    SF_FORMAT_DWD___20 = 67371008,
    SF_FORMAT_REX___20 = 67764224,
    SF_FORMAT_REX2___20 = 67960832,
    SF_FORMAT_KRZ___20 = 68026368,
    SF_FORMAT_WMA___20 = 68157440,
    SF_FORMAT_SHN___20 = 68222976,
    SF_FORMAT_SVX_FIB___20 = 4128,
    SF_FORMAT_SVX_EXP___20 = 4129,
    SF_FORMAT_PCM_N___20 = 4144
} ;
#line 405
enum __anonenum__550___0 {
    SFE_NO_ERROR___20 = 0,
    SFE_BAD_OPEN_FORMAT___20 = 1,
    SFE_SYSTEM___20 = 2,
    SFE_MALFORMED_FILE___20 = 3,
    SFE_UNSUPPORTED_ENCODING___20 = 4,
    SFE_ZERO_MAJOR_FORMAT___20 = 5,
    SFE_ZERO_MINOR_FORMAT___20 = 6,
    SFE_BAD_FILE___20 = 7,
    SFE_BAD_FILE_READ___20 = 8,
    SFE_OPEN_FAILED___20 = 9,
    SFE_BAD_SNDFILE_PTR___20 = 10,
    SFE_BAD_SF_INFO_PTR___20 = 11,
    SFE_BAD_SF_INCOMPLETE___20 = 12,
    SFE_BAD_FILE_PTR___20 = 13,
    SFE_BAD_INT_PTR___20 = 14,
    SFE_BAD_STAT_SIZE___20 = 15,
    SFE_MALLOC_FAILED___20 = 16,
    SFE_UNIMPLEMENTED___20 = 17,
    SFE_BAD_READ_ALIGN___20 = 18,
    SFE_BAD_WRITE_ALIGN___20 = 19,
    SFE_UNKNOWN_FORMAT___20 = 20,
    SFE_NOT_READMODE___20 = 21,
    SFE_NOT_WRITEMODE___20 = 22,
    SFE_BAD_MODE_RW___20 = 23,
    SFE_BAD_SF_INFO___20 = 24,
    SFE_BAD_OFFSET___20 = 25,
    SFE_NO_EMBED_SUPPORT___20 = 26,
    SFE_NO_EMBEDDED_RDWR___20 = 27,
    SFE_NO_PIPE_WRITE___20 = 28,
    SFE_INTERNAL___20 = 29,
    SFE_BAD_COMMAND_PARAM___20 = 30,
    SFE_BAD_ENDIAN___20 = 31,
    SFE_CHANNEL_COUNT_ZERO___20 = 32,
    SFE_CHANNEL_COUNT___20 = 33,
    SFE_BAD_VIRTUAL_IO___20 = 34,
    SFE_INTERLEAVE_MODE___20 = 35,
    SFE_INTERLEAVE_SEEK___20 = 36,
    SFE_INTERLEAVE_READ___20 = 37,
    SFE_BAD_SEEK___20 = 38,
    SFE_NOT_SEEKABLE___20 = 39,
    SFE_AMBIGUOUS_SEEK___20 = 40,
    SFE_WRONG_SEEK___20 = 41,
    SFE_SEEK_FAILED___20 = 42,
    SFE_BAD_OPEN_MODE___20 = 43,
    SFE_OPEN_PIPE_RDWR___20 = 44,
    SFE_RDWR_POSITION___20 = 45,
    SFE_RDWR_BAD_HEADER___20 = 46,
    SFE_CMD_HAS_DATA___20 = 47,
    SFE_BAD_BROADCAST_INFO_SIZE___20 = 48,
    SFE_STR_NO_SUPPORT___20 = 49,
    SFE_STR_NOT_WRITE___20 = 50,
    SFE_STR_MAX_DATA___20 = 51,
    SFE_STR_MAX_COUNT___20 = 52,
    SFE_STR_BAD_TYPE___20 = 53,
    SFE_STR_NO_ADD_END___20 = 54,
    SFE_STR_BAD_STRING___20 = 55,
    SFE_STR_WEIRD___20 = 56,
    SFE_WAV_NO_RIFF___20 = 57,
    SFE_WAV_NO_WAVE___20 = 58,
    SFE_WAV_NO_FMT___20 = 59,
    SFE_WAV_BAD_FMT___20 = 60,
    SFE_WAV_FMT_SHORT___20 = 61,
    SFE_WAV_BAD_FACT___20 = 62,
    SFE_WAV_BAD_PEAK___20 = 63,
    SFE_WAV_PEAK_B4_FMT___20 = 64,
    SFE_WAV_BAD_FORMAT___20 = 65,
    SFE_WAV_BAD_BLOCKALIGN___20 = 66,
    SFE_WAV_NO_DATA___20 = 67,
    SFE_WAV_BAD_LIST___20 = 68,
    SFE_WAV_ADPCM_NOT4BIT___20 = 69,
    SFE_WAV_ADPCM_CHANNELS___20 = 70,
    SFE_WAV_GSM610_FORMAT___20 = 71,
    SFE_WAV_UNKNOWN_CHUNK___20 = 72,
    SFE_WAV_WVPK_DATA___20 = 73,
    SFE_AIFF_NO_FORM___20 = 74,
    SFE_AIFF_AIFF_NO_FORM___20 = 75,
    SFE_AIFF_COMM_NO_FORM___20 = 76,
    SFE_AIFF_SSND_NO_COMM___20 = 77,
    SFE_AIFF_UNKNOWN_CHUNK___20 = 78,
    SFE_AIFF_COMM_CHUNK_SIZE___20 = 79,
    SFE_AIFF_BAD_COMM_CHUNK___20 = 80,
    SFE_AIFF_PEAK_B4_COMM___20 = 81,
    SFE_AIFF_BAD_PEAK___20 = 82,
    SFE_AIFF_NO_SSND___20 = 83,
    SFE_AIFF_NO_DATA___20 = 84,
    SFE_AIFF_RW_SSND_NOT_LAST___20 = 85,
    SFE_AU_UNKNOWN_FORMAT___20 = 86,
    SFE_AU_NO_DOTSND___20 = 87,
    SFE_AU_EMBED_BAD_LEN___20 = 88,
    SFE_RAW_READ_BAD_SPEC___20 = 89,
    SFE_RAW_BAD_BITWIDTH___20 = 90,
    SFE_RAW_BAD_FORMAT___20 = 91,
    SFE_PAF_NO_MARKER___20 = 92,
    SFE_PAF_VERSION___20 = 93,
    SFE_PAF_UNKNOWN_FORMAT___20 = 94,
    SFE_PAF_SHORT_HEADER___20 = 95,
    SFE_SVX_NO_FORM___20 = 96,
    SFE_SVX_NO_BODY___20 = 97,
    SFE_SVX_NO_DATA___20 = 98,
    SFE_SVX_BAD_COMP___20 = 99,
    SFE_SVX_BAD_NAME_LENGTH___20 = 100,
    SFE_NIST_BAD_HEADER___20 = 101,
    SFE_NIST_CRLF_CONVERISON___20 = 102,
    SFE_NIST_BAD_ENCODING___20 = 103,
    SFE_VOC_NO_CREATIVE___20 = 104,
    SFE_VOC_BAD_FORMAT___20 = 105,
    SFE_VOC_BAD_VERSION___20 = 106,
    SFE_VOC_BAD_MARKER___20 = 107,
    SFE_VOC_BAD_SECTIONS___20 = 108,
    SFE_VOC_MULTI_SAMPLERATE___20 = 109,
    SFE_VOC_MULTI_SECTION___20 = 110,
    SFE_VOC_MULTI_PARAM___20 = 111,
    SFE_VOC_SECTION_COUNT___20 = 112,
    SFE_VOC_NO_PIPE___20 = 113,
    SFE_IRCAM_NO_MARKER___20 = 114,
    SFE_IRCAM_BAD_CHANNELS___20 = 115,
    SFE_IRCAM_UNKNOWN_FORMAT___20 = 116,
    SFE_W64_64_BIT___20 = 117,
    SFE_W64_NO_RIFF___20 = 118,
    SFE_W64_NO_WAVE___20 = 119,
    SFE_W64_NO_DATA___20 = 120,
    SFE_W64_ADPCM_NOT4BIT___20 = 121,
    SFE_W64_ADPCM_CHANNELS___20 = 122,
    SFE_W64_GSM610_FORMAT___20 = 123,
    SFE_MAT4_BAD_NAME___20 = 124,
    SFE_MAT4_NO_SAMPLERATE___20 = 125,
    SFE_MAT5_BAD_ENDIAN___20 = 126,
    SFE_MAT5_NO_BLOCK___20 = 127,
    SFE_MAT5_SAMPLE_RATE___20 = 128,
    SFE_PVF_NO_PVF1___20 = 129,
    SFE_PVF_BAD_HEADER___20 = 130,
    SFE_PVF_BAD_BITWIDTH___20 = 131,
    SFE_DWVW_BAD_BITWIDTH___20 = 132,
    SFE_G72X_NOT_MONO___20 = 133,
    SFE_XI_BAD_HEADER___20 = 134,
    SFE_XI_EXCESS_SAMPLES___20 = 135,
    SFE_XI_NO_PIPE___20 = 136,
    SFE_HTK_NO_PIPE___20 = 137,
    SFE_SDS_NOT_SDS___20 = 138,
    SFE_SDS_BAD_BIT_WIDTH___20 = 139,
    SFE_SD2_FD_DISALLOWED___20 = 140,
    SFE_SD2_BAD_DATA_OFFSET___20 = 141,
    SFE_SD2_BAD_MAP_OFFSET___20 = 142,
    SFE_SD2_BAD_DATA_LENGTH___20 = 143,
    SFE_SD2_BAD_MAP_LENGTH___20 = 144,
    SFE_SD2_BAD_RSRC___20 = 145,
    SFE_SD2_BAD_SAMPLE_SIZE___20 = 146,
    SFE_FLAC_BAD_HEADER___20 = 147,
    SFE_FLAC_NEW_DECODER___20 = 148,
    SFE_FLAC_INIT_DECODER___20 = 149,
    SFE_FLAC_LOST_SYNC___20 = 150,
    SFE_FLAC_BAD_SAMPLE_RATE___20 = 151,
    SFE_FLAC_UNKOWN_ERROR___20 = 152,
    SFE_WVE_NOT_WVE___20 = 153,
    SFE_WVE_NO_PIPE___20 = 154,
    SFE_VORBIS_ENCODER_BUG___20 = 155,
    SFE_RF64_NOT_RF64___20 = 156,
    SFE_MAX_ERROR___20 = 157
} ;
#line 823
enum __anonenum__554___0 {
    SFC_TEST_AIFF_ADD_INST_CHUNK___20 = 8192,
    SFC_TEST_WAV_ADD_INFO_CHUNK___20 = 8208
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__568 {
    _ISupper___2 = 256,
    _ISlower___2 = 512,
    _ISalpha___2 = 1024,
    _ISdigit___2 = 2048,
    _ISxdigit___2 = 4096,
    _ISspace___2 = 8192,
    _ISprint___2 = 16384,
    _ISgraph___2 = 32768,
    _ISblank___2 = 1,
    _IScntrl___2 = 2,
    _ISpunct___2 = 4,
    _ISalnum___2 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__569 {
    FP_NAN___12 = 0,
    FP_INFINITE___12 = 1,
    FP_ZERO___12 = 2,
    FP_SUBNORMAL___12 = 3,
    FP_NORMAL___12 = 4
} ;
#line 46 "/root/libsndfile/src/sndfile.h"
enum __anonenum__570 {
    SF_FORMAT_WAV___21 = 65536,
    SF_FORMAT_AIFF___21 = 131072,
    SF_FORMAT_AU___21 = 196608,
    SF_FORMAT_RAW___21 = 262144,
    SF_FORMAT_PAF___21 = 327680,
    SF_FORMAT_SVX___21 = 393216,
    SF_FORMAT_NIST___21 = 458752,
    SF_FORMAT_VOC___21 = 524288,
    SF_FORMAT_IRCAM___21 = 655360,
    SF_FORMAT_W64___21 = 720896,
    SF_FORMAT_MAT4___21 = 786432,
    SF_FORMAT_MAT5___21 = 851968,
    SF_FORMAT_PVF___21 = 917504,
    SF_FORMAT_XI___21 = 983040,
    SF_FORMAT_HTK___21 = 1048576,
    SF_FORMAT_SDS___21 = 1114112,
    SF_FORMAT_AVR___21 = 1179648,
    SF_FORMAT_WAVEX___21 = 1245184,
    SF_FORMAT_SD2___21 = 1441792,
    SF_FORMAT_FLAC___21 = 1507328,
    SF_FORMAT_CAF___21 = 1572864,
    SF_FORMAT_WVE___21 = 1638400,
    SF_FORMAT_OGG___21 = 2097152,
    SF_FORMAT_MPC2K___21 = 2162688,
    SF_FORMAT_RF64___21 = 2228224,
    SF_FORMAT_PCM_S8___21 = 1,
    SF_FORMAT_PCM_16___21 = 2,
    SF_FORMAT_PCM_24___21 = 3,
    SF_FORMAT_PCM_32___21 = 4,
    SF_FORMAT_PCM_U8___21 = 5,
    SF_FORMAT_FLOAT___21 = 6,
    SF_FORMAT_DOUBLE___21 = 7,
    SF_FORMAT_ULAW___21 = 16,
    SF_FORMAT_ALAW___21 = 17,
    SF_FORMAT_IMA_ADPCM___21 = 18,
    SF_FORMAT_MS_ADPCM___21 = 19,
    SF_FORMAT_GSM610___21 = 32,
    SF_FORMAT_VOX_ADPCM___21 = 33,
    SF_FORMAT_G721_32___21 = 48,
    SF_FORMAT_G723_24___21 = 49,
    SF_FORMAT_G723_40___21 = 50,
    SF_FORMAT_DWVW_12___21 = 64,
    SF_FORMAT_DWVW_16___21 = 65,
    SF_FORMAT_DWVW_24___21 = 66,
    SF_FORMAT_DWVW_N___21 = 67,
    SF_FORMAT_DPCM_8___21 = 80,
    SF_FORMAT_DPCM_16___21 = 81,
    SF_FORMAT_VORBIS___21 = 96,
    SF_ENDIAN_FILE___21 = 0,
    SF_ENDIAN_LITTLE___21 = 268435456,
    SF_ENDIAN_BIG___21 = 536870912,
    SF_ENDIAN_CPU___21 = 805306368,
    SF_FORMAT_SUBMASK___21 = 65535,
    SF_FORMAT_TYPEMASK___21 = 268369920,
    SF_FORMAT_ENDMASK___21 = 805306368
} ;
#line 126
enum __anonenum__571 {
    SFC_GET_LIB_VERSION___21 = 4096,
    SFC_GET_LOG_INFO___21 = 4097,
    SFC_GET_CURRENT_SF_INFO___21 = 4098,
    SFC_GET_NORM_DOUBLE___21 = 4112,
    SFC_GET_NORM_FLOAT___21 = 4113,
    SFC_SET_NORM_DOUBLE___21 = 4114,
    SFC_SET_NORM_FLOAT___21 = 4115,
    SFC_SET_SCALE_FLOAT_INT_READ___21 = 4116,
    SFC_SET_SCALE_INT_FLOAT_WRITE___21 = 4117,
    SFC_GET_SIMPLE_FORMAT_COUNT___21 = 4128,
    SFC_GET_SIMPLE_FORMAT___21 = 4129,
    SFC_GET_FORMAT_INFO___21 = 4136,
    SFC_GET_FORMAT_MAJOR_COUNT___21 = 4144,
    SFC_GET_FORMAT_MAJOR___21 = 4145,
    SFC_GET_FORMAT_SUBTYPE_COUNT___21 = 4146,
    SFC_GET_FORMAT_SUBTYPE___21 = 4147,
    SFC_CALC_SIGNAL_MAX___21 = 4160,
    SFC_CALC_NORM_SIGNAL_MAX___21 = 4161,
    SFC_CALC_MAX_ALL_CHANNELS___21 = 4162,
    SFC_CALC_NORM_MAX_ALL_CHANNELS___21 = 4163,
    SFC_GET_SIGNAL_MAX___21 = 4164,
    SFC_GET_MAX_ALL_CHANNELS___21 = 4165,
    SFC_SET_ADD_PEAK_CHUNK___21 = 4176,
    SFC_SET_ADD_HEADER_PAD_CHUNK___21 = 4177,
    SFC_UPDATE_HEADER_NOW___21 = 4192,
    SFC_SET_UPDATE_HEADER_AUTO___21 = 4193,
    SFC_FILE_TRUNCATE___21 = 4224,
    SFC_SET_RAW_START_OFFSET___21 = 4240,
    SFC_SET_DITHER_ON_WRITE___21 = 4256,
    SFC_SET_DITHER_ON_READ___21 = 4257,
    SFC_GET_DITHER_INFO_COUNT___21 = 4258,
    SFC_GET_DITHER_INFO___21 = 4259,
    SFC_GET_EMBED_FILE_INFO___21 = 4272,
    SFC_SET_CLIPPING___21 = 4288,
    SFC_GET_CLIPPING___21 = 4289,
    SFC_GET_INSTRUMENT___21 = 4304,
    SFC_SET_INSTRUMENT___21 = 4305,
    SFC_GET_LOOP_INFO___21 = 4320,
    SFC_GET_BROADCAST_INFO___21 = 4336,
    SFC_SET_BROADCAST_INFO___21 = 4337,
    SFC_GET_CHANNEL_MAP_INFO___21 = 4352,
    SFC_SET_CHANNEL_MAP_INFO___21 = 4353,
    SFC_RAW_DATA_NEEDS_ENDSWAP___21 = 4368,
    SFC_WAVEX_SET_AMBISONIC___21 = 4608,
    SFC_WAVEX_GET_AMBISONIC___21 = 4609,
    SFC_SET_VBR_ENCODING_QUALITY___21 = 4864,
    SFC_TEST_IEEE_FLOAT_REPLACE___21 = 24577,
    SFC_SET_ADD_DITHER_ON_WRITE___21 = 4208,
    SFC_SET_ADD_DITHER_ON_READ___21 = 4209
} ;
#line 216
enum __anonenum__572 {
    SF_STR_TITLE___21 = 1,
    SF_STR_COPYRIGHT___21 = 2,
    SF_STR_SOFTWARE___21 = 3,
    SF_STR_ARTIST___21 = 4,
    SF_STR_COMMENT___21 = 5,
    SF_STR_DATE___21 = 6,
    SF_STR_ALBUM___21 = 7,
    SF_STR_LICENSE___21 = 8
} ;
#line 235
enum __anonenum__573 {
    SF_FALSE___21 = 0,
    SF_TRUE___21 = 1,
    SFM_READ___21 = 16,
    SFM_WRITE___21 = 32,
    SFM_RDWR___21 = 48,
    SF_AMBISONIC_NONE___21 = 64,
    SF_AMBISONIC_B_FORMAT___21 = 65
} ;
#line 255
enum __anonenum__574 {
    SF_ERR_NO_ERROR___21 = 0,
    SF_ERR_UNRECOGNISED_FORMAT___21 = 1,
    SF_ERR_SYSTEM___21 = 2,
    SF_ERR_MALFORMED_FILE___21 = 3,
    SF_ERR_UNSUPPORTED_ENCODING___21 = 4
} ;
#line 267
enum __anonenum__575 {
    SF_CHANNEL_MAP_INVALID___21 = 0,
    SF_CHANNEL_MAP_MONO___21 = 1,
    SF_CHANNEL_MAP_LEFT___21 = 2,
    SF_CHANNEL_MAP_RIGHT___21 = 3,
    SF_CHANNEL_MAP_CENTER___21 = 4,
    SF_CHANNEL_MAP_FRONT_LEFT___21 = 5,
    SF_CHANNEL_MAP_FRONT_RIGHT___21 = 6,
    SF_CHANNEL_MAP_FRONT_CENTER___21 = 7,
    SF_CHANNEL_MAP_REAR_CENTER___21 = 8,
    SF_CHANNEL_MAP_REAR_LEFT___21 = 9,
    SF_CHANNEL_MAP_REAR_RIGHT___21 = 10,
    SF_CHANNEL_MAP_LFE___21 = 11,
    SF_CHANNEL_MAP_FRONT_LEFT_OF_CENTER___21 = 12,
    SF_CHANNEL_MAP_FRONT_RIGHT_OF_CENTER___21 = 13,
    SF_CHANNEL_MAP_SIDE_LEFT___21 = 14,
    SF_CHANNEL_MAP_SIDE_RIGHT___21 = 15,
    SF_CHANNEL_MAP_TOP_CENTER___21 = 16,
    SF_CHANNEL_MAP_TOP_FRONT_LEFT___21 = 17,
    SF_CHANNEL_MAP_TOP_FRONT_RIGHT___21 = 18,
    SF_CHANNEL_MAP_TOP_FRONT_CENTER___21 = 19,
    SF_CHANNEL_MAP_TOP_REAR_LEFT___21 = 20,
    SF_CHANNEL_MAP_TOP_REAR_RIGHT___21 = 21,
    SF_CHANNEL_MAP_TOP_REAR_CENTER___21 = 22
} ;
#line 352
enum __anonenum__577 {
    SFD_DEFAULT_LEVEL___21 = 0,
    SFD_CUSTOM_LEVEL___21 = 1073741824,
    SFD_NO_DITHER___21 = 500,
    SFD_WHITE___21 = 501,
    SFD_TRIANGULAR_PDF___21 = 502
} ;
#line 380
enum __anonenum__580 {
    SF_LOOP_NONE___21 = 800,
    SF_LOOP_FORWARD___21 = 801,
    SF_LOOP_BACKWARD___21 = 802,
    SF_LOOP_ALTERNATING___21 = 803
} ;
#line 121 "/root/libsndfile/src/common.h"
enum __anonenum__585 {
    SF_PEAK_START___21 = 42,
    SF_PEAK_END___21 = 43,
    SF_SCALE_MAX___21 = 52,
    SF_SCALE_MIN___21 = 53,
    SF_STR_ALLOW_START___21 = 256,
    SF_STR_ALLOW_END___21 = 512,
    SF_STR_LOCATE_START___21 = 1024,
    SF_STR_LOCATE_END___21 = 2048,
    SFD_TYPEMASK___21 = 268435455
} ;
#line 149
enum __anonenum__586 {
    SF_FORMAT_TXW___21 = 67305472,
    SF_FORMAT_DWD___21 = 67371008,
    SF_FORMAT_REX___21 = 67764224,
    SF_FORMAT_REX2___21 = 67960832,
    SF_FORMAT_KRZ___21 = 68026368,
    SF_FORMAT_WMA___21 = 68157440,
    SF_FORMAT_SHN___21 = 68222976,
    SF_FORMAT_SVX_FIB___21 = 4128,
    SF_FORMAT_SVX_EXP___21 = 4129,
    SF_FORMAT_PCM_N___21 = 4144
} ;
#line 405
enum __anonenum__592 {
    SFE_NO_ERROR___21 = 0,
    SFE_BAD_OPEN_FORMAT___21 = 1,
    SFE_SYSTEM___21 = 2,
    SFE_MALFORMED_FILE___21 = 3,
    SFE_UNSUPPORTED_ENCODING___21 = 4,
    SFE_ZERO_MAJOR_FORMAT___21 = 5,
    SFE_ZERO_MINOR_FORMAT___21 = 6,
    SFE_BAD_FILE___21 = 7,
    SFE_BAD_FILE_READ___21 = 8,
    SFE_OPEN_FAILED___21 = 9,
    SFE_BAD_SNDFILE_PTR___21 = 10,
    SFE_BAD_SF_INFO_PTR___21 = 11,
    SFE_BAD_SF_INCOMPLETE___21 = 12,
    SFE_BAD_FILE_PTR___21 = 13,
    SFE_BAD_INT_PTR___21 = 14,
    SFE_BAD_STAT_SIZE___21 = 15,
    SFE_MALLOC_FAILED___21 = 16,
    SFE_UNIMPLEMENTED___21 = 17,
    SFE_BAD_READ_ALIGN___21 = 18,
    SFE_BAD_WRITE_ALIGN___21 = 19,
    SFE_UNKNOWN_FORMAT___21 = 20,
    SFE_NOT_READMODE___21 = 21,
    SFE_NOT_WRITEMODE___21 = 22,
    SFE_BAD_MODE_RW___21 = 23,
    SFE_BAD_SF_INFO___21 = 24,
    SFE_BAD_OFFSET___21 = 25,
    SFE_NO_EMBED_SUPPORT___21 = 26,
    SFE_NO_EMBEDDED_RDWR___21 = 27,
    SFE_NO_PIPE_WRITE___21 = 28,
    SFE_INTERNAL___21 = 29,
    SFE_BAD_COMMAND_PARAM___21 = 30,
    SFE_BAD_ENDIAN___21 = 31,
    SFE_CHANNEL_COUNT_ZERO___21 = 32,
    SFE_CHANNEL_COUNT___21 = 33,
    SFE_BAD_VIRTUAL_IO___21 = 34,
    SFE_INTERLEAVE_MODE___21 = 35,
    SFE_INTERLEAVE_SEEK___21 = 36,
    SFE_INTERLEAVE_READ___21 = 37,
    SFE_BAD_SEEK___21 = 38,
    SFE_NOT_SEEKABLE___21 = 39,
    SFE_AMBIGUOUS_SEEK___21 = 40,
    SFE_WRONG_SEEK___21 = 41,
    SFE_SEEK_FAILED___21 = 42,
    SFE_BAD_OPEN_MODE___21 = 43,
    SFE_OPEN_PIPE_RDWR___21 = 44,
    SFE_RDWR_POSITION___21 = 45,
    SFE_RDWR_BAD_HEADER___21 = 46,
    SFE_CMD_HAS_DATA___21 = 47,
    SFE_BAD_BROADCAST_INFO_SIZE___21 = 48,
    SFE_STR_NO_SUPPORT___21 = 49,
    SFE_STR_NOT_WRITE___21 = 50,
    SFE_STR_MAX_DATA___21 = 51,
    SFE_STR_MAX_COUNT___21 = 52,
    SFE_STR_BAD_TYPE___21 = 53,
    SFE_STR_NO_ADD_END___21 = 54,
    SFE_STR_BAD_STRING___21 = 55,
    SFE_STR_WEIRD___21 = 56,
    SFE_WAV_NO_RIFF___21 = 57,
    SFE_WAV_NO_WAVE___21 = 58,
    SFE_WAV_NO_FMT___21 = 59,
    SFE_WAV_BAD_FMT___21 = 60,
    SFE_WAV_FMT_SHORT___21 = 61,
    SFE_WAV_BAD_FACT___21 = 62,
    SFE_WAV_BAD_PEAK___21 = 63,
    SFE_WAV_PEAK_B4_FMT___21 = 64,
    SFE_WAV_BAD_FORMAT___21 = 65,
    SFE_WAV_BAD_BLOCKALIGN___21 = 66,
    SFE_WAV_NO_DATA___21 = 67,
    SFE_WAV_BAD_LIST___21 = 68,
    SFE_WAV_ADPCM_NOT4BIT___21 = 69,
    SFE_WAV_ADPCM_CHANNELS___21 = 70,
    SFE_WAV_GSM610_FORMAT___21 = 71,
    SFE_WAV_UNKNOWN_CHUNK___21 = 72,
    SFE_WAV_WVPK_DATA___21 = 73,
    SFE_AIFF_NO_FORM___21 = 74,
    SFE_AIFF_AIFF_NO_FORM___21 = 75,
    SFE_AIFF_COMM_NO_FORM___21 = 76,
    SFE_AIFF_SSND_NO_COMM___21 = 77,
    SFE_AIFF_UNKNOWN_CHUNK___21 = 78,
    SFE_AIFF_COMM_CHUNK_SIZE___21 = 79,
    SFE_AIFF_BAD_COMM_CHUNK___21 = 80,
    SFE_AIFF_PEAK_B4_COMM___21 = 81,
    SFE_AIFF_BAD_PEAK___21 = 82,
    SFE_AIFF_NO_SSND___21 = 83,
    SFE_AIFF_NO_DATA___21 = 84,
    SFE_AIFF_RW_SSND_NOT_LAST___21 = 85,
    SFE_AU_UNKNOWN_FORMAT___21 = 86,
    SFE_AU_NO_DOTSND___21 = 87,
    SFE_AU_EMBED_BAD_LEN___21 = 88,
    SFE_RAW_READ_BAD_SPEC___21 = 89,
    SFE_RAW_BAD_BITWIDTH___21 = 90,
    SFE_RAW_BAD_FORMAT___21 = 91,
    SFE_PAF_NO_MARKER___21 = 92,
    SFE_PAF_VERSION___21 = 93,
    SFE_PAF_UNKNOWN_FORMAT___21 = 94,
    SFE_PAF_SHORT_HEADER___21 = 95,
    SFE_SVX_NO_FORM___21 = 96,
    SFE_SVX_NO_BODY___21 = 97,
    SFE_SVX_NO_DATA___21 = 98,
    SFE_SVX_BAD_COMP___21 = 99,
    SFE_SVX_BAD_NAME_LENGTH___21 = 100,
    SFE_NIST_BAD_HEADER___21 = 101,
    SFE_NIST_CRLF_CONVERISON___21 = 102,
    SFE_NIST_BAD_ENCODING___21 = 103,
    SFE_VOC_NO_CREATIVE___21 = 104,
    SFE_VOC_BAD_FORMAT___21 = 105,
    SFE_VOC_BAD_VERSION___21 = 106,
    SFE_VOC_BAD_MARKER___21 = 107,
    SFE_VOC_BAD_SECTIONS___21 = 108,
    SFE_VOC_MULTI_SAMPLERATE___21 = 109,
    SFE_VOC_MULTI_SECTION___21 = 110,
    SFE_VOC_MULTI_PARAM___21 = 111,
    SFE_VOC_SECTION_COUNT___21 = 112,
    SFE_VOC_NO_PIPE___21 = 113,
    SFE_IRCAM_NO_MARKER___21 = 114,
    SFE_IRCAM_BAD_CHANNELS___21 = 115,
    SFE_IRCAM_UNKNOWN_FORMAT___21 = 116,
    SFE_W64_64_BIT___21 = 117,
    SFE_W64_NO_RIFF___21 = 118,
    SFE_W64_NO_WAVE___21 = 119,
    SFE_W64_NO_DATA___21 = 120,
    SFE_W64_ADPCM_NOT4BIT___21 = 121,
    SFE_W64_ADPCM_CHANNELS___21 = 122,
    SFE_W64_GSM610_FORMAT___21 = 123,
    SFE_MAT4_BAD_NAME___21 = 124,
    SFE_MAT4_NO_SAMPLERATE___21 = 125,
    SFE_MAT5_BAD_ENDIAN___21 = 126,
    SFE_MAT5_NO_BLOCK___21 = 127,
    SFE_MAT5_SAMPLE_RATE___21 = 128,
    SFE_PVF_NO_PVF1___21 = 129,
    SFE_PVF_BAD_HEADER___21 = 130,
    SFE_PVF_BAD_BITWIDTH___21 = 131,
    SFE_DWVW_BAD_BITWIDTH___21 = 132,
    SFE_G72X_NOT_MONO___21 = 133,
    SFE_XI_BAD_HEADER___21 = 134,
    SFE_XI_EXCESS_SAMPLES___21 = 135,
    SFE_XI_NO_PIPE___21 = 136,
    SFE_HTK_NO_PIPE___21 = 137,
    SFE_SDS_NOT_SDS___21 = 138,
    SFE_SDS_BAD_BIT_WIDTH___21 = 139,
    SFE_SD2_FD_DISALLOWED___21 = 140,
    SFE_SD2_BAD_DATA_OFFSET___21 = 141,
    SFE_SD2_BAD_MAP_OFFSET___21 = 142,
    SFE_SD2_BAD_DATA_LENGTH___21 = 143,
    SFE_SD2_BAD_MAP_LENGTH___21 = 144,
    SFE_SD2_BAD_RSRC___21 = 145,
    SFE_SD2_BAD_SAMPLE_SIZE___21 = 146,
    SFE_FLAC_BAD_HEADER___21 = 147,
    SFE_FLAC_NEW_DECODER___21 = 148,
    SFE_FLAC_INIT_DECODER___21 = 149,
    SFE_FLAC_LOST_SYNC___21 = 150,
    SFE_FLAC_BAD_SAMPLE_RATE___21 = 151,
    SFE_FLAC_UNKOWN_ERROR___21 = 152,
    SFE_WVE_NOT_WVE___21 = 153,
    SFE_WVE_NO_PIPE___21 = 154,
    SFE_VORBIS_ENCODER_BUG___21 = 155,
    SFE_RF64_NOT_RF64___21 = 156,
    SFE_MAX_ERROR___21 = 157
} ;
#line 823
enum __anonenum__596 {
    SFC_TEST_AIFF_ADD_INST_CHUNK___21 = 8192,
    SFC_TEST_WAV_ADD_INFO_CHUNK___21 = 8208
} ;
#line 38 "/root/libsndfile/src/xi.c"
struct __anonstruct_597 {
   char filename[22] ;
   char software[20] ;
   char sample_name[22] ;
   int loop_begin ;
   int loop_end ;
   int sample_flags ;
   short last_16 ;
};
#line 49 "/root/libsndfile/src/xi.c"
typedef struct __anonstruct_597 XI_PRIVATE;
#line 46 "/usr/include/ctype.h"
enum __anonenum__598 {
    _ISupper___3 = 256,
    _ISlower___3 = 512,
    _ISalpha___3 = 1024,
    _ISdigit___3 = 2048,
    _ISxdigit___3 = 4096,
    _ISspace___3 = 8192,
    _ISprint___3 = 16384,
    _ISgraph___3 = 32768,
    _ISblank___3 = 1,
    _IScntrl___3 = 2,
    _ISpunct___3 = 4,
    _ISalnum___3 = 8
} ;
#line 46 "/root/libsndfile/src/sndfile.h"
enum __anonenum__599 {
    SF_FORMAT_WAV___22 = 65536,
    SF_FORMAT_AIFF___22 = 131072,
    SF_FORMAT_AU___22 = 196608,
    SF_FORMAT_RAW___22 = 262144,
    SF_FORMAT_PAF___22 = 327680,
    SF_FORMAT_SVX___22 = 393216,
    SF_FORMAT_NIST___22 = 458752,
    SF_FORMAT_VOC___22 = 524288,
    SF_FORMAT_IRCAM___22 = 655360,
    SF_FORMAT_W64___22 = 720896,
    SF_FORMAT_MAT4___22 = 786432,
    SF_FORMAT_MAT5___22 = 851968,
    SF_FORMAT_PVF___22 = 917504,
    SF_FORMAT_XI___22 = 983040,
    SF_FORMAT_HTK___22 = 1048576,
    SF_FORMAT_SDS___22 = 1114112,
    SF_FORMAT_AVR___22 = 1179648,
    SF_FORMAT_WAVEX___22 = 1245184,
    SF_FORMAT_SD2___22 = 1441792,
    SF_FORMAT_FLAC___22 = 1507328,
    SF_FORMAT_CAF___22 = 1572864,
    SF_FORMAT_WVE___22 = 1638400,
    SF_FORMAT_OGG___22 = 2097152,
    SF_FORMAT_MPC2K___22 = 2162688,
    SF_FORMAT_RF64___22 = 2228224,
    SF_FORMAT_PCM_S8___22 = 1,
    SF_FORMAT_PCM_16___22 = 2,
    SF_FORMAT_PCM_24___22 = 3,
    SF_FORMAT_PCM_32___22 = 4,
    SF_FORMAT_PCM_U8___22 = 5,
    SF_FORMAT_FLOAT___22 = 6,
    SF_FORMAT_DOUBLE___22 = 7,
    SF_FORMAT_ULAW___22 = 16,
    SF_FORMAT_ALAW___22 = 17,
    SF_FORMAT_IMA_ADPCM___22 = 18,
    SF_FORMAT_MS_ADPCM___22 = 19,
    SF_FORMAT_GSM610___22 = 32,
    SF_FORMAT_VOX_ADPCM___22 = 33,
    SF_FORMAT_G721_32___22 = 48,
    SF_FORMAT_G723_24___22 = 49,
    SF_FORMAT_G723_40___22 = 50,
    SF_FORMAT_DWVW_12___22 = 64,
    SF_FORMAT_DWVW_16___22 = 65,
    SF_FORMAT_DWVW_24___22 = 66,
    SF_FORMAT_DWVW_N___22 = 67,
    SF_FORMAT_DPCM_8___22 = 80,
    SF_FORMAT_DPCM_16___22 = 81,
    SF_FORMAT_VORBIS___22 = 96,
    SF_ENDIAN_FILE___22 = 0,
    SF_ENDIAN_LITTLE___22 = 268435456,
    SF_ENDIAN_BIG___22 = 536870912,
    SF_ENDIAN_CPU___22 = 805306368,
    SF_FORMAT_SUBMASK___22 = 65535,
    SF_FORMAT_TYPEMASK___22 = 268369920,
    SF_FORMAT_ENDMASK___22 = 805306368
} ;
#line 126
enum __anonenum__600 {
    SFC_GET_LIB_VERSION___22 = 4096,
    SFC_GET_LOG_INFO___22 = 4097,
    SFC_GET_CURRENT_SF_INFO___22 = 4098,
    SFC_GET_NORM_DOUBLE___22 = 4112,
    SFC_GET_NORM_FLOAT___22 = 4113,
    SFC_SET_NORM_DOUBLE___22 = 4114,
    SFC_SET_NORM_FLOAT___22 = 4115,
    SFC_SET_SCALE_FLOAT_INT_READ___22 = 4116,
    SFC_SET_SCALE_INT_FLOAT_WRITE___22 = 4117,
    SFC_GET_SIMPLE_FORMAT_COUNT___22 = 4128,
    SFC_GET_SIMPLE_FORMAT___22 = 4129,
    SFC_GET_FORMAT_INFO___22 = 4136,
    SFC_GET_FORMAT_MAJOR_COUNT___22 = 4144,
    SFC_GET_FORMAT_MAJOR___22 = 4145,
    SFC_GET_FORMAT_SUBTYPE_COUNT___22 = 4146,
    SFC_GET_FORMAT_SUBTYPE___22 = 4147,
    SFC_CALC_SIGNAL_MAX___22 = 4160,
    SFC_CALC_NORM_SIGNAL_MAX___22 = 4161,
    SFC_CALC_MAX_ALL_CHANNELS___22 = 4162,
    SFC_CALC_NORM_MAX_ALL_CHANNELS___22 = 4163,
    SFC_GET_SIGNAL_MAX___22 = 4164,
    SFC_GET_MAX_ALL_CHANNELS___22 = 4165,
    SFC_SET_ADD_PEAK_CHUNK___22 = 4176,
    SFC_SET_ADD_HEADER_PAD_CHUNK___22 = 4177,
    SFC_UPDATE_HEADER_NOW___22 = 4192,
    SFC_SET_UPDATE_HEADER_AUTO___22 = 4193,
    SFC_FILE_TRUNCATE___22 = 4224,
    SFC_SET_RAW_START_OFFSET___22 = 4240,
    SFC_SET_DITHER_ON_WRITE___22 = 4256,
    SFC_SET_DITHER_ON_READ___22 = 4257,
    SFC_GET_DITHER_INFO_COUNT___22 = 4258,
    SFC_GET_DITHER_INFO___22 = 4259,
    SFC_GET_EMBED_FILE_INFO___22 = 4272,
    SFC_SET_CLIPPING___22 = 4288,
    SFC_GET_CLIPPING___22 = 4289,
    SFC_GET_INSTRUMENT___22 = 4304,
    SFC_SET_INSTRUMENT___22 = 4305,
    SFC_GET_LOOP_INFO___22 = 4320,
    SFC_GET_BROADCAST_INFO___22 = 4336,
    SFC_SET_BROADCAST_INFO___22 = 4337,
    SFC_GET_CHANNEL_MAP_INFO___22 = 4352,
    SFC_SET_CHANNEL_MAP_INFO___22 = 4353,
    SFC_RAW_DATA_NEEDS_ENDSWAP___22 = 4368,
    SFC_WAVEX_SET_AMBISONIC___22 = 4608,
    SFC_WAVEX_GET_AMBISONIC___22 = 4609,
    SFC_SET_VBR_ENCODING_QUALITY___22 = 4864,
    SFC_TEST_IEEE_FLOAT_REPLACE___22 = 24577,
    SFC_SET_ADD_DITHER_ON_WRITE___22 = 4208,
    SFC_SET_ADD_DITHER_ON_READ___22 = 4209
} ;
#line 216
enum __anonenum__601 {
    SF_STR_TITLE___22 = 1,
    SF_STR_COPYRIGHT___22 = 2,
    SF_STR_SOFTWARE___22 = 3,
    SF_STR_ARTIST___22 = 4,
    SF_STR_COMMENT___22 = 5,
    SF_STR_DATE___22 = 6,
    SF_STR_ALBUM___22 = 7,
    SF_STR_LICENSE___22 = 8
} ;
#line 235
enum __anonenum__602 {
    SF_FALSE___22 = 0,
    SF_TRUE___22 = 1,
    SFM_READ___22 = 16,
    SFM_WRITE___22 = 32,
    SFM_RDWR___22 = 48,
    SF_AMBISONIC_NONE___22 = 64,
    SF_AMBISONIC_B_FORMAT___22 = 65
} ;
#line 255
enum __anonenum__603 {
    SF_ERR_NO_ERROR___22 = 0,
    SF_ERR_UNRECOGNISED_FORMAT___22 = 1,
    SF_ERR_SYSTEM___22 = 2,
    SF_ERR_MALFORMED_FILE___22 = 3,
    SF_ERR_UNSUPPORTED_ENCODING___22 = 4
} ;
#line 267
enum __anonenum__604 {
    SF_CHANNEL_MAP_INVALID___22 = 0,
    SF_CHANNEL_MAP_MONO___22 = 1,
    SF_CHANNEL_MAP_LEFT___22 = 2,
    SF_CHANNEL_MAP_RIGHT___22 = 3,
    SF_CHANNEL_MAP_CENTER___22 = 4,
    SF_CHANNEL_MAP_FRONT_LEFT___22 = 5,
    SF_CHANNEL_MAP_FRONT_RIGHT___22 = 6,
    SF_CHANNEL_MAP_FRONT_CENTER___22 = 7,
    SF_CHANNEL_MAP_REAR_CENTER___22 = 8,
    SF_CHANNEL_MAP_REAR_LEFT___22 = 9,
    SF_CHANNEL_MAP_REAR_RIGHT___22 = 10,
    SF_CHANNEL_MAP_LFE___22 = 11,
    SF_CHANNEL_MAP_FRONT_LEFT_OF_CENTER___22 = 12,
    SF_CHANNEL_MAP_FRONT_RIGHT_OF_CENTER___22 = 13,
    SF_CHANNEL_MAP_SIDE_LEFT___22 = 14,
    SF_CHANNEL_MAP_SIDE_RIGHT___22 = 15,
    SF_CHANNEL_MAP_TOP_CENTER___22 = 16,
    SF_CHANNEL_MAP_TOP_FRONT_LEFT___22 = 17,
    SF_CHANNEL_MAP_TOP_FRONT_RIGHT___22 = 18,
    SF_CHANNEL_MAP_TOP_FRONT_CENTER___22 = 19,
    SF_CHANNEL_MAP_TOP_REAR_LEFT___22 = 20,
    SF_CHANNEL_MAP_TOP_REAR_RIGHT___22 = 21,
    SF_CHANNEL_MAP_TOP_REAR_CENTER___22 = 22
} ;
#line 352
enum __anonenum__606 {
    SFD_DEFAULT_LEVEL___22 = 0,
    SFD_CUSTOM_LEVEL___22 = 1073741824,
    SFD_NO_DITHER___22 = 500,
    SFD_WHITE___22 = 501,
    SFD_TRIANGULAR_PDF___22 = 502
} ;
#line 380
enum __anonenum__609 {
    SF_LOOP_NONE___22 = 800,
    SF_LOOP_FORWARD___22 = 801,
    SF_LOOP_BACKWARD___22 = 802,
    SF_LOOP_ALTERNATING___22 = 803
} ;
#line 121 "/root/libsndfile/src/common.h"
enum __anonenum__614 {
    SF_PEAK_START___22 = 42,
    SF_PEAK_END___22 = 43,
    SF_SCALE_MAX___22 = 52,
    SF_SCALE_MIN___22 = 53,
    SF_STR_ALLOW_START___22 = 256,
    SF_STR_ALLOW_END___22 = 512,
    SF_STR_LOCATE_START___22 = 1024,
    SF_STR_LOCATE_END___22 = 2048,
    SFD_TYPEMASK___22 = 268435455
} ;
#line 149
enum __anonenum__615 {
    SF_FORMAT_TXW___22 = 67305472,
    SF_FORMAT_DWD___22 = 67371008,
    SF_FORMAT_REX___22 = 67764224,
    SF_FORMAT_REX2___22 = 67960832,
    SF_FORMAT_KRZ___22 = 68026368,
    SF_FORMAT_WMA___22 = 68157440,
    SF_FORMAT_SHN___22 = 68222976,
    SF_FORMAT_SVX_FIB___22 = 4128,
    SF_FORMAT_SVX_EXP___22 = 4129,
    SF_FORMAT_PCM_N___22 = 4144
} ;
#line 405
enum __anonenum__621 {
    SFE_NO_ERROR___22 = 0,
    SFE_BAD_OPEN_FORMAT___22 = 1,
    SFE_SYSTEM___22 = 2,
    SFE_MALFORMED_FILE___22 = 3,
    SFE_UNSUPPORTED_ENCODING___22 = 4,
    SFE_ZERO_MAJOR_FORMAT___22 = 5,
    SFE_ZERO_MINOR_FORMAT___22 = 6,
    SFE_BAD_FILE___22 = 7,
    SFE_BAD_FILE_READ___22 = 8,
    SFE_OPEN_FAILED___22 = 9,
    SFE_BAD_SNDFILE_PTR___22 = 10,
    SFE_BAD_SF_INFO_PTR___22 = 11,
    SFE_BAD_SF_INCOMPLETE___22 = 12,
    SFE_BAD_FILE_PTR___22 = 13,
    SFE_BAD_INT_PTR___22 = 14,
    SFE_BAD_STAT_SIZE___22 = 15,
    SFE_MALLOC_FAILED___22 = 16,
    SFE_UNIMPLEMENTED___22 = 17,
    SFE_BAD_READ_ALIGN___22 = 18,
    SFE_BAD_WRITE_ALIGN___22 = 19,
    SFE_UNKNOWN_FORMAT___22 = 20,
    SFE_NOT_READMODE___22 = 21,
    SFE_NOT_WRITEMODE___22 = 22,
    SFE_BAD_MODE_RW___22 = 23,
    SFE_BAD_SF_INFO___22 = 24,
    SFE_BAD_OFFSET___22 = 25,
    SFE_NO_EMBED_SUPPORT___22 = 26,
    SFE_NO_EMBEDDED_RDWR___22 = 27,
    SFE_NO_PIPE_WRITE___22 = 28,
    SFE_INTERNAL___22 = 29,
    SFE_BAD_COMMAND_PARAM___22 = 30,
    SFE_BAD_ENDIAN___22 = 31,
    SFE_CHANNEL_COUNT_ZERO___22 = 32,
    SFE_CHANNEL_COUNT___22 = 33,
    SFE_BAD_VIRTUAL_IO___22 = 34,
    SFE_INTERLEAVE_MODE___22 = 35,
    SFE_INTERLEAVE_SEEK___22 = 36,
    SFE_INTERLEAVE_READ___22 = 37,
    SFE_BAD_SEEK___22 = 38,
    SFE_NOT_SEEKABLE___22 = 39,
    SFE_AMBIGUOUS_SEEK___22 = 40,
    SFE_WRONG_SEEK___22 = 41,
    SFE_SEEK_FAILED___22 = 42,
    SFE_BAD_OPEN_MODE___22 = 43,
    SFE_OPEN_PIPE_RDWR___22 = 44,
    SFE_RDWR_POSITION___22 = 45,
    SFE_RDWR_BAD_HEADER___22 = 46,
    SFE_CMD_HAS_DATA___22 = 47,
    SFE_BAD_BROADCAST_INFO_SIZE___22 = 48,
    SFE_STR_NO_SUPPORT___22 = 49,
    SFE_STR_NOT_WRITE___22 = 50,
    SFE_STR_MAX_DATA___22 = 51,
    SFE_STR_MAX_COUNT___22 = 52,
    SFE_STR_BAD_TYPE___22 = 53,
    SFE_STR_NO_ADD_END___22 = 54,
    SFE_STR_BAD_STRING___22 = 55,
    SFE_STR_WEIRD___22 = 56,
    SFE_WAV_NO_RIFF___22 = 57,
    SFE_WAV_NO_WAVE___22 = 58,
    SFE_WAV_NO_FMT___22 = 59,
    SFE_WAV_BAD_FMT___22 = 60,
    SFE_WAV_FMT_SHORT___22 = 61,
    SFE_WAV_BAD_FACT___22 = 62,
    SFE_WAV_BAD_PEAK___22 = 63,
    SFE_WAV_PEAK_B4_FMT___22 = 64,
    SFE_WAV_BAD_FORMAT___22 = 65,
    SFE_WAV_BAD_BLOCKALIGN___22 = 66,
    SFE_WAV_NO_DATA___22 = 67,
    SFE_WAV_BAD_LIST___22 = 68,
    SFE_WAV_ADPCM_NOT4BIT___22 = 69,
    SFE_WAV_ADPCM_CHANNELS___22 = 70,
    SFE_WAV_GSM610_FORMAT___22 = 71,
    SFE_WAV_UNKNOWN_CHUNK___22 = 72,
    SFE_WAV_WVPK_DATA___22 = 73,
    SFE_AIFF_NO_FORM___22 = 74,
    SFE_AIFF_AIFF_NO_FORM___22 = 75,
    SFE_AIFF_COMM_NO_FORM___22 = 76,
    SFE_AIFF_SSND_NO_COMM___22 = 77,
    SFE_AIFF_UNKNOWN_CHUNK___22 = 78,
    SFE_AIFF_COMM_CHUNK_SIZE___22 = 79,
    SFE_AIFF_BAD_COMM_CHUNK___22 = 80,
    SFE_AIFF_PEAK_B4_COMM___22 = 81,
    SFE_AIFF_BAD_PEAK___22 = 82,
    SFE_AIFF_NO_SSND___22 = 83,
    SFE_AIFF_NO_DATA___22 = 84,
    SFE_AIFF_RW_SSND_NOT_LAST___22 = 85,
    SFE_AU_UNKNOWN_FORMAT___22 = 86,
    SFE_AU_NO_DOTSND___22 = 87,
    SFE_AU_EMBED_BAD_LEN___22 = 88,
    SFE_RAW_READ_BAD_SPEC___22 = 89,
    SFE_RAW_BAD_BITWIDTH___22 = 90,
    SFE_RAW_BAD_FORMAT___22 = 91,
    SFE_PAF_NO_MARKER___22 = 92,
    SFE_PAF_VERSION___22 = 93,
    SFE_PAF_UNKNOWN_FORMAT___22 = 94,
    SFE_PAF_SHORT_HEADER___22 = 95,
    SFE_SVX_NO_FORM___22 = 96,
    SFE_SVX_NO_BODY___22 = 97,
    SFE_SVX_NO_DATA___22 = 98,
    SFE_SVX_BAD_COMP___22 = 99,
    SFE_SVX_BAD_NAME_LENGTH___22 = 100,
    SFE_NIST_BAD_HEADER___22 = 101,
    SFE_NIST_CRLF_CONVERISON___22 = 102,
    SFE_NIST_BAD_ENCODING___22 = 103,
    SFE_VOC_NO_CREATIVE___22 = 104,
    SFE_VOC_BAD_FORMAT___22 = 105,
    SFE_VOC_BAD_VERSION___22 = 106,
    SFE_VOC_BAD_MARKER___22 = 107,
    SFE_VOC_BAD_SECTIONS___22 = 108,
    SFE_VOC_MULTI_SAMPLERATE___22 = 109,
    SFE_VOC_MULTI_SECTION___22 = 110,
    SFE_VOC_MULTI_PARAM___22 = 111,
    SFE_VOC_SECTION_COUNT___22 = 112,
    SFE_VOC_NO_PIPE___22 = 113,
    SFE_IRCAM_NO_MARKER___22 = 114,
    SFE_IRCAM_BAD_CHANNELS___22 = 115,
    SFE_IRCAM_UNKNOWN_FORMAT___22 = 116,
    SFE_W64_64_BIT___22 = 117,
    SFE_W64_NO_RIFF___22 = 118,
    SFE_W64_NO_WAVE___22 = 119,
    SFE_W64_NO_DATA___22 = 120,
    SFE_W64_ADPCM_NOT4BIT___22 = 121,
    SFE_W64_ADPCM_CHANNELS___22 = 122,
    SFE_W64_GSM610_FORMAT___22 = 123,
    SFE_MAT4_BAD_NAME___22 = 124,
    SFE_MAT4_NO_SAMPLERATE___22 = 125,
    SFE_MAT5_BAD_ENDIAN___22 = 126,
    SFE_MAT5_NO_BLOCK___22 = 127,
    SFE_MAT5_SAMPLE_RATE___22 = 128,
    SFE_PVF_NO_PVF1___22 = 129,
    SFE_PVF_BAD_HEADER___22 = 130,
    SFE_PVF_BAD_BITWIDTH___22 = 131,
    SFE_DWVW_BAD_BITWIDTH___22 = 132,
    SFE_G72X_NOT_MONO___22 = 133,
    SFE_XI_BAD_HEADER___22 = 134,
    SFE_XI_EXCESS_SAMPLES___22 = 135,
    SFE_XI_NO_PIPE___22 = 136,
    SFE_HTK_NO_PIPE___22 = 137,
    SFE_SDS_NOT_SDS___22 = 138,
    SFE_SDS_BAD_BIT_WIDTH___22 = 139,
    SFE_SD2_FD_DISALLOWED___22 = 140,
    SFE_SD2_BAD_DATA_OFFSET___22 = 141,
    SFE_SD2_BAD_MAP_OFFSET___22 = 142,
    SFE_SD2_BAD_DATA_LENGTH___22 = 143,
    SFE_SD2_BAD_MAP_LENGTH___22 = 144,
    SFE_SD2_BAD_RSRC___22 = 145,
    SFE_SD2_BAD_SAMPLE_SIZE___22 = 146,
    SFE_FLAC_BAD_HEADER___22 = 147,
    SFE_FLAC_NEW_DECODER___22 = 148,
    SFE_FLAC_INIT_DECODER___22 = 149,
    SFE_FLAC_LOST_SYNC___22 = 150,
    SFE_FLAC_BAD_SAMPLE_RATE___22 = 151,
    SFE_FLAC_UNKOWN_ERROR___22 = 152,
    SFE_WVE_NOT_WVE___22 = 153,
    SFE_WVE_NO_PIPE___22 = 154,
    SFE_VORBIS_ENCODER_BUG___22 = 155,
    SFE_RF64_NOT_RF64___22 = 156,
    SFE_MAX_ERROR___22 = 157
} ;
#line 823
enum __anonenum__625 {
    SFC_TEST_AIFF_ADD_INST_CHUNK___22 = 8192,
    SFC_TEST_WAV_ADD_INFO_CHUNK___22 = 8208
} ;
#line 29 "/root/libsndfile/src/wav_w64.h"
enum __anonenum__626 {
    WAVE_FORMAT_UNKNOWN___2 = 0,
    WAVE_FORMAT_PCM___2 = 1,
    WAVE_FORMAT_MS_ADPCM___2 = 2,
    WAVE_FORMAT_IEEE_FLOAT___2 = 3,
    WAVE_FORMAT_VSELP___2 = 4,
    WAVE_FORMAT_IBM_CVSD___2 = 5,
    WAVE_FORMAT_ALAW___2 = 6,
    WAVE_FORMAT_MULAW___2 = 7,
    WAVE_FORMAT_OKI_ADPCM___2 = 16,
    WAVE_FORMAT_IMA_ADPCM___2 = 17,
    WAVE_FORMAT_MEDIASPACE_ADPCM___2 = 18,
    WAVE_FORMAT_SIERRA_ADPCM___2 = 19,
    WAVE_FORMAT_G723_ADPCM___2 = 20,
    WAVE_FORMAT_DIGISTD___2 = 21,
    WAVE_FORMAT_DIGIFIX___2 = 22,
    WAVE_FORMAT_DIALOGIC_OKI_ADPCM___2 = 23,
    WAVE_FORMAT_MEDIAVISION_ADPCM___2 = 24,
    WAVE_FORMAT_CU_CODEC___2 = 25,
    WAVE_FORMAT_YAMAHA_ADPCM___2 = 32,
    WAVE_FORMAT_SONARC___2 = 33,
    WAVE_FORMAT_DSPGROUP_TRUESPEECH___2 = 34,
    WAVE_FORMAT_ECHOSC1___2 = 35,
    WAVE_FORMAT_AUDIOFILE_AF36___2 = 36,
    WAVE_FORMAT_APTX___2 = 37,
    WAVE_FORMAT_AUDIOFILE_AF10___2 = 38,
    WAVE_FORMAT_PROSODY_1612___2 = 39,
    WAVE_FORMAT_LRC___2 = 40,
    WAVE_FORMAT_DOLBY_AC2___2 = 48,
    WAVE_FORMAT_GSM610___2 = 49,
    WAVE_FORMAT_MSNAUDIO___2 = 50,
    WAVE_FORMAT_ANTEX_ADPCME___2 = 51,
    WAVE_FORMAT_CONTROL_RES_VQLPC___2 = 52,
    WAVE_FORMAT_DIGIREAL___2 = 53,
    WAVE_FORMAT_DIGIADPCM___2 = 54,
    WAVE_FORMAT_CONTROL_RES_CR10___2 = 55,
    WAVE_FORMAT_NMS_VBXADPCM___2 = 56,
    WAVE_FORMAT_ROLAND_RDAC___2 = 57,
    WAVE_FORMAT_ECHOSC3___2 = 58,
    WAVE_FORMAT_ROCKWELL_ADPCM___2 = 59,
    WAVE_FORMAT_ROCKWELL_DIGITALK___2 = 60,
    WAVE_FORMAT_XEBEC___2 = 61,
    WAVE_FORMAT_G721_ADPCM___2 = 64,
    WAVE_FORMAT_G728_CELP___2 = 65,
    WAVE_FORMAT_MSG723___2 = 66,
    WAVE_FORMAT_MPEG___2 = 80,
    WAVE_FORMAT_RT24___2 = 82,
    WAVE_FORMAT_PAC___2 = 83,
    WAVE_FORMAT_MPEGLAYER3___2 = 85,
    WAVE_FORMAT_LUCENT_G723___2 = 89,
    WAVE_FORMAT_CIRRUS___2 = 96,
    WAVE_FORMAT_ESPCM___2 = 97,
    WAVE_FORMAT_VOXWARE___2 = 98,
    WAVE_FORMAT_CANOPUS_ATRAC___2 = 99,
    WAVE_FORMAT_G726_ADPCM___2 = 100,
    WAVE_FORMAT_G722_ADPCM___2 = 101,
    WAVE_FORMAT_DSAT___2 = 102,
    WAVE_FORMAT_DSAT_DISPLAY___2 = 103,
    WAVE_FORMAT_VOXWARE_BYTE_ALIGNED___2 = 105,
    WAVE_FORMAT_VOXWARE_AC8___2 = 112,
    WAVE_FORMAT_VOXWARE_AC10___2 = 113,
    WAVE_FORMAT_VOXWARE_AC16___2 = 114,
    WAVE_FORMAT_VOXWARE_AC20___2 = 115,
    WAVE_FORMAT_VOXWARE_RT24___2 = 116,
    WAVE_FORMAT_VOXWARE_RT29___2 = 117,
    WAVE_FORMAT_VOXWARE_RT29HW___2 = 118,
    WAVE_FORMAT_VOXWARE_VR12___2 = 119,
    WAVE_FORMAT_VOXWARE_VR18___2 = 120,
    WAVE_FORMAT_VOXWARE_TQ40___2 = 121,
    WAVE_FORMAT_SOFTSOUND___2 = 128,
    WAVE_FORMAT_VOXARE_TQ60___2 = 129,
    WAVE_FORMAT_MSRT24___2 = 130,
    WAVE_FORMAT_G729A___2 = 131,
    WAVE_FORMAT_MVI_MV12___2 = 132,
    WAVE_FORMAT_DF_G726___2 = 133,
    WAVE_FORMAT_DF_GSM610___2 = 134,
    WAVE_FORMAT_ONLIVE___2 = 137,
    WAVE_FORMAT_SBC24___2 = 145,
    WAVE_FORMAT_DOLBY_AC3_SPDIF___2 = 146,
    WAVE_FORMAT_ZYXEL_ADPCM___2 = 151,
    WAVE_FORMAT_PHILIPS_LPCBB___2 = 152,
    WAVE_FORMAT_PACKED___2 = 153,
    WAVE_FORMAT_RHETOREX_ADPCM___2 = 256,
    IBM_FORMAT_MULAW___2 = 257,
    IBM_FORMAT_ALAW___2 = 258,
    IBM_FORMAT_ADPCM___2 = 259,
    WAVE_FORMAT_VIVO_G723___2 = 273,
    WAVE_FORMAT_VIVO_SIREN___2 = 274,
    WAVE_FORMAT_DIGITAL_G723___2 = 291,
    WAVE_FORMAT_CREATIVE_ADPCM___2 = 512,
    WAVE_FORMAT_CREATIVE_FASTSPEECH8___2 = 514,
    WAVE_FORMAT_CREATIVE_FASTSPEECH10___2 = 515,
    WAVE_FORMAT_QUARTERDECK___2 = 544,
    WAVE_FORMAT_FM_TOWNS_SND___2 = 768,
    WAVE_FORMAT_BZV_DIGITAL___2 = 1024,
    WAVE_FORMAT_VME_VMPCM___2 = 1664,
    WAVE_FORMAT_OLIGSM___2 = 4096,
    WAVE_FORMAT_OLIADPCM___2 = 4097,
    WAVE_FORMAT_OLICELP___2 = 4098,
    WAVE_FORMAT_OLISBC___2 = 4099,
    WAVE_FORMAT_OLIOPR___2 = 4100,
    WAVE_FORMAT_LH_CODEC___2 = 4352,
    WAVE_FORMAT_NORRIS___2 = 5120,
    WAVE_FORMAT_SOUNDSPACE_MUSICOMPRESS___2 = 5376,
    WAVE_FORMAT_DVM___2 = 8192,
    WAVE_FORMAT_INTERWAV_VSC112___2 = 29008,
    WAVE_FORMAT_IPP_ITU_G_723_1___2 = 29232,
    WAVE_FORMAT_EXTENSIBLE___2 = 65534
} ;
#line 100 "/root/libsndfile/src/wav.c"
enum __anonenum__638 {
    HAVE_RIFF = 1,
    HAVE_WAVE = 2,
    HAVE_fmt = 4,
    HAVE_fact = 8,
    HAVE_PEAK = 16,
    HAVE_data = 32,
    HAVE_other = (-0x7FFFFFFF-1)
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__437 {
    _ISupper___4 = 256,
    _ISlower___4 = 512,
    _ISalpha___4 = 1024,
    _ISdigit___4 = 2048,
    _ISxdigit___4 = 4096,
    _ISspace___4 = 8192,
    _ISprint___4 = 16384,
    _ISgraph___4 = 32768,
    _ISblank___4 = 1,
    _IScntrl___4 = 2,
    _ISpunct___4 = 4,
    _ISalnum___4 = 8
} ;
#line 46 "/root/libsndfile/src/sndfile.h"
enum __anonenum__653 {
    SF_FORMAT_WAV___23 = 65536,
    SF_FORMAT_AIFF___23 = 131072,
    SF_FORMAT_AU___23 = 196608,
    SF_FORMAT_RAW___23 = 262144,
    SF_FORMAT_PAF___23 = 327680,
    SF_FORMAT_SVX___23 = 393216,
    SF_FORMAT_NIST___23 = 458752,
    SF_FORMAT_VOC___23 = 524288,
    SF_FORMAT_IRCAM___23 = 655360,
    SF_FORMAT_W64___23 = 720896,
    SF_FORMAT_MAT4___23 = 786432,
    SF_FORMAT_MAT5___23 = 851968,
    SF_FORMAT_PVF___23 = 917504,
    SF_FORMAT_XI___23 = 983040,
    SF_FORMAT_HTK___23 = 1048576,
    SF_FORMAT_SDS___23 = 1114112,
    SF_FORMAT_AVR___23 = 1179648,
    SF_FORMAT_WAVEX___23 = 1245184,
    SF_FORMAT_SD2___23 = 1441792,
    SF_FORMAT_FLAC___23 = 1507328,
    SF_FORMAT_CAF___23 = 1572864,
    SF_FORMAT_WVE___23 = 1638400,
    SF_FORMAT_OGG___23 = 2097152,
    SF_FORMAT_MPC2K___23 = 2162688,
    SF_FORMAT_RF64___23 = 2228224,
    SF_FORMAT_PCM_S8___23 = 1,
    SF_FORMAT_PCM_16___23 = 2,
    SF_FORMAT_PCM_24___23 = 3,
    SF_FORMAT_PCM_32___23 = 4,
    SF_FORMAT_PCM_U8___23 = 5,
    SF_FORMAT_FLOAT___23 = 6,
    SF_FORMAT_DOUBLE___23 = 7,
    SF_FORMAT_ULAW___23 = 16,
    SF_FORMAT_ALAW___23 = 17,
    SF_FORMAT_IMA_ADPCM___23 = 18,
    SF_FORMAT_MS_ADPCM___23 = 19,
    SF_FORMAT_GSM610___23 = 32,
    SF_FORMAT_VOX_ADPCM___23 = 33,
    SF_FORMAT_G721_32___23 = 48,
    SF_FORMAT_G723_24___23 = 49,
    SF_FORMAT_G723_40___23 = 50,
    SF_FORMAT_DWVW_12___23 = 64,
    SF_FORMAT_DWVW_16___23 = 65,
    SF_FORMAT_DWVW_24___23 = 66,
    SF_FORMAT_DWVW_N___23 = 67,
    SF_FORMAT_DPCM_8___23 = 80,
    SF_FORMAT_DPCM_16___23 = 81,
    SF_FORMAT_VORBIS___23 = 96,
    SF_ENDIAN_FILE___23 = 0,
    SF_ENDIAN_LITTLE___23 = 268435456,
    SF_ENDIAN_BIG___23 = 536870912,
    SF_ENDIAN_CPU___23 = 805306368,
    SF_FORMAT_SUBMASK___23 = 65535,
    SF_FORMAT_TYPEMASK___23 = 268369920,
    SF_FORMAT_ENDMASK___23 = 805306368
} ;
#line 126
enum __anonenum__654 {
    SFC_GET_LIB_VERSION___23 = 4096,
    SFC_GET_LOG_INFO___23 = 4097,
    SFC_GET_CURRENT_SF_INFO___23 = 4098,
    SFC_GET_NORM_DOUBLE___23 = 4112,
    SFC_GET_NORM_FLOAT___23 = 4113,
    SFC_SET_NORM_DOUBLE___23 = 4114,
    SFC_SET_NORM_FLOAT___23 = 4115,
    SFC_SET_SCALE_FLOAT_INT_READ___23 = 4116,
    SFC_SET_SCALE_INT_FLOAT_WRITE___23 = 4117,
    SFC_GET_SIMPLE_FORMAT_COUNT___23 = 4128,
    SFC_GET_SIMPLE_FORMAT___23 = 4129,
    SFC_GET_FORMAT_INFO___23 = 4136,
    SFC_GET_FORMAT_MAJOR_COUNT___23 = 4144,
    SFC_GET_FORMAT_MAJOR___23 = 4145,
    SFC_GET_FORMAT_SUBTYPE_COUNT___23 = 4146,
    SFC_GET_FORMAT_SUBTYPE___23 = 4147,
    SFC_CALC_SIGNAL_MAX___23 = 4160,
    SFC_CALC_NORM_SIGNAL_MAX___23 = 4161,
    SFC_CALC_MAX_ALL_CHANNELS___23 = 4162,
    SFC_CALC_NORM_MAX_ALL_CHANNELS___23 = 4163,
    SFC_GET_SIGNAL_MAX___23 = 4164,
    SFC_GET_MAX_ALL_CHANNELS___23 = 4165,
    SFC_SET_ADD_PEAK_CHUNK___23 = 4176,
    SFC_SET_ADD_HEADER_PAD_CHUNK___23 = 4177,
    SFC_UPDATE_HEADER_NOW___23 = 4192,
    SFC_SET_UPDATE_HEADER_AUTO___23 = 4193,
    SFC_FILE_TRUNCATE___23 = 4224,
    SFC_SET_RAW_START_OFFSET___23 = 4240,
    SFC_SET_DITHER_ON_WRITE___23 = 4256,
    SFC_SET_DITHER_ON_READ___23 = 4257,
    SFC_GET_DITHER_INFO_COUNT___23 = 4258,
    SFC_GET_DITHER_INFO___23 = 4259,
    SFC_GET_EMBED_FILE_INFO___23 = 4272,
    SFC_SET_CLIPPING___23 = 4288,
    SFC_GET_CLIPPING___23 = 4289,
    SFC_GET_INSTRUMENT___23 = 4304,
    SFC_SET_INSTRUMENT___23 = 4305,
    SFC_GET_LOOP_INFO___23 = 4320,
    SFC_GET_BROADCAST_INFO___23 = 4336,
    SFC_SET_BROADCAST_INFO___23 = 4337,
    SFC_GET_CHANNEL_MAP_INFO___23 = 4352,
    SFC_SET_CHANNEL_MAP_INFO___23 = 4353,
    SFC_RAW_DATA_NEEDS_ENDSWAP___23 = 4368,
    SFC_WAVEX_SET_AMBISONIC___23 = 4608,
    SFC_WAVEX_GET_AMBISONIC___23 = 4609,
    SFC_SET_VBR_ENCODING_QUALITY___23 = 4864,
    SFC_TEST_IEEE_FLOAT_REPLACE___23 = 24577,
    SFC_SET_ADD_DITHER_ON_WRITE___23 = 4208,
    SFC_SET_ADD_DITHER_ON_READ___23 = 4209
} ;
#line 216
enum __anonenum__655 {
    SF_STR_TITLE___23 = 1,
    SF_STR_COPYRIGHT___23 = 2,
    SF_STR_SOFTWARE___23 = 3,
    SF_STR_ARTIST___23 = 4,
    SF_STR_COMMENT___23 = 5,
    SF_STR_DATE___23 = 6,
    SF_STR_ALBUM___23 = 7,
    SF_STR_LICENSE___23 = 8
} ;
#line 235
enum __anonenum__656 {
    SF_FALSE___23 = 0,
    SF_TRUE___23 = 1,
    SFM_READ___23 = 16,
    SFM_WRITE___23 = 32,
    SFM_RDWR___23 = 48,
    SF_AMBISONIC_NONE___23 = 64,
    SF_AMBISONIC_B_FORMAT___23 = 65
} ;
#line 255
enum __anonenum__657 {
    SF_ERR_NO_ERROR___23 = 0,
    SF_ERR_UNRECOGNISED_FORMAT___23 = 1,
    SF_ERR_SYSTEM___23 = 2,
    SF_ERR_MALFORMED_FILE___23 = 3,
    SF_ERR_UNSUPPORTED_ENCODING___23 = 4
} ;
#line 267
enum __anonenum__658 {
    SF_CHANNEL_MAP_INVALID___23 = 0,
    SF_CHANNEL_MAP_MONO___23 = 1,
    SF_CHANNEL_MAP_LEFT___23 = 2,
    SF_CHANNEL_MAP_RIGHT___23 = 3,
    SF_CHANNEL_MAP_CENTER___23 = 4,
    SF_CHANNEL_MAP_FRONT_LEFT___23 = 5,
    SF_CHANNEL_MAP_FRONT_RIGHT___23 = 6,
    SF_CHANNEL_MAP_FRONT_CENTER___23 = 7,
    SF_CHANNEL_MAP_REAR_CENTER___23 = 8,
    SF_CHANNEL_MAP_REAR_LEFT___23 = 9,
    SF_CHANNEL_MAP_REAR_RIGHT___23 = 10,
    SF_CHANNEL_MAP_LFE___23 = 11,
    SF_CHANNEL_MAP_FRONT_LEFT_OF_CENTER___23 = 12,
    SF_CHANNEL_MAP_FRONT_RIGHT_OF_CENTER___23 = 13,
    SF_CHANNEL_MAP_SIDE_LEFT___23 = 14,
    SF_CHANNEL_MAP_SIDE_RIGHT___23 = 15,
    SF_CHANNEL_MAP_TOP_CENTER___23 = 16,
    SF_CHANNEL_MAP_TOP_FRONT_LEFT___23 = 17,
    SF_CHANNEL_MAP_TOP_FRONT_RIGHT___23 = 18,
    SF_CHANNEL_MAP_TOP_FRONT_CENTER___23 = 19,
    SF_CHANNEL_MAP_TOP_REAR_LEFT___23 = 20,
    SF_CHANNEL_MAP_TOP_REAR_RIGHT___23 = 21,
    SF_CHANNEL_MAP_TOP_REAR_CENTER___23 = 22
} ;
#line 352
enum __anonenum__660 {
    SFD_DEFAULT_LEVEL___23 = 0,
    SFD_CUSTOM_LEVEL___23 = 1073741824,
    SFD_NO_DITHER___23 = 500,
    SFD_WHITE___23 = 501,
    SFD_TRIANGULAR_PDF___23 = 502
} ;
#line 380
enum __anonenum__663 {
    SF_LOOP_NONE___23 = 800,
    SF_LOOP_FORWARD___23 = 801,
    SF_LOOP_BACKWARD___23 = 802,
    SF_LOOP_ALTERNATING___23 = 803
} ;
#line 121 "/root/libsndfile/src/common.h"
enum __anonenum__672 {
    SF_PEAK_START___23 = 42,
    SF_PEAK_END___23 = 43,
    SF_SCALE_MAX___23 = 52,
    SF_SCALE_MIN___23 = 53,
    SF_STR_ALLOW_START___23 = 256,
    SF_STR_ALLOW_END___23 = 512,
    SF_STR_LOCATE_START___23 = 1024,
    SF_STR_LOCATE_END___23 = 2048,
    SFD_TYPEMASK___23 = 268435455
} ;
#line 149
enum __anonenum__673 {
    SF_FORMAT_TXW___23 = 67305472,
    SF_FORMAT_DWD___23 = 67371008,
    SF_FORMAT_REX___23 = 67764224,
    SF_FORMAT_REX2___23 = 67960832,
    SF_FORMAT_KRZ___23 = 68026368,
    SF_FORMAT_WMA___23 = 68157440,
    SF_FORMAT_SHN___23 = 68222976,
    SF_FORMAT_SVX_FIB___23 = 4128,
    SF_FORMAT_SVX_EXP___23 = 4129,
    SF_FORMAT_PCM_N___23 = 4144
} ;
#line 405
enum __anonenum__679 {
    SFE_NO_ERROR___23 = 0,
    SFE_BAD_OPEN_FORMAT___23 = 1,
    SFE_SYSTEM___23 = 2,
    SFE_MALFORMED_FILE___23 = 3,
    SFE_UNSUPPORTED_ENCODING___23 = 4,
    SFE_ZERO_MAJOR_FORMAT___23 = 5,
    SFE_ZERO_MINOR_FORMAT___23 = 6,
    SFE_BAD_FILE___23 = 7,
    SFE_BAD_FILE_READ___23 = 8,
    SFE_OPEN_FAILED___23 = 9,
    SFE_BAD_SNDFILE_PTR___23 = 10,
    SFE_BAD_SF_INFO_PTR___23 = 11,
    SFE_BAD_SF_INCOMPLETE___23 = 12,
    SFE_BAD_FILE_PTR___23 = 13,
    SFE_BAD_INT_PTR___23 = 14,
    SFE_BAD_STAT_SIZE___23 = 15,
    SFE_MALLOC_FAILED___23 = 16,
    SFE_UNIMPLEMENTED___23 = 17,
    SFE_BAD_READ_ALIGN___23 = 18,
    SFE_BAD_WRITE_ALIGN___23 = 19,
    SFE_UNKNOWN_FORMAT___23 = 20,
    SFE_NOT_READMODE___23 = 21,
    SFE_NOT_WRITEMODE___23 = 22,
    SFE_BAD_MODE_RW___23 = 23,
    SFE_BAD_SF_INFO___23 = 24,
    SFE_BAD_OFFSET___23 = 25,
    SFE_NO_EMBED_SUPPORT___23 = 26,
    SFE_NO_EMBEDDED_RDWR___23 = 27,
    SFE_NO_PIPE_WRITE___23 = 28,
    SFE_INTERNAL___23 = 29,
    SFE_BAD_COMMAND_PARAM___23 = 30,
    SFE_BAD_ENDIAN___23 = 31,
    SFE_CHANNEL_COUNT_ZERO___23 = 32,
    SFE_CHANNEL_COUNT___23 = 33,
    SFE_BAD_VIRTUAL_IO___23 = 34,
    SFE_INTERLEAVE_MODE___23 = 35,
    SFE_INTERLEAVE_SEEK___23 = 36,
    SFE_INTERLEAVE_READ___23 = 37,
    SFE_BAD_SEEK___23 = 38,
    SFE_NOT_SEEKABLE___23 = 39,
    SFE_AMBIGUOUS_SEEK___23 = 40,
    SFE_WRONG_SEEK___23 = 41,
    SFE_SEEK_FAILED___23 = 42,
    SFE_BAD_OPEN_MODE___23 = 43,
    SFE_OPEN_PIPE_RDWR___23 = 44,
    SFE_RDWR_POSITION___23 = 45,
    SFE_RDWR_BAD_HEADER___23 = 46,
    SFE_CMD_HAS_DATA___23 = 47,
    SFE_BAD_BROADCAST_INFO_SIZE___23 = 48,
    SFE_STR_NO_SUPPORT___23 = 49,
    SFE_STR_NOT_WRITE___23 = 50,
    SFE_STR_MAX_DATA___23 = 51,
    SFE_STR_MAX_COUNT___23 = 52,
    SFE_STR_BAD_TYPE___23 = 53,
    SFE_STR_NO_ADD_END___23 = 54,
    SFE_STR_BAD_STRING___23 = 55,
    SFE_STR_WEIRD___23 = 56,
    SFE_WAV_NO_RIFF___23 = 57,
    SFE_WAV_NO_WAVE___23 = 58,
    SFE_WAV_NO_FMT___23 = 59,
    SFE_WAV_BAD_FMT___23 = 60,
    SFE_WAV_FMT_SHORT___23 = 61,
    SFE_WAV_BAD_FACT___23 = 62,
    SFE_WAV_BAD_PEAK___23 = 63,
    SFE_WAV_PEAK_B4_FMT___23 = 64,
    SFE_WAV_BAD_FORMAT___23 = 65,
    SFE_WAV_BAD_BLOCKALIGN___23 = 66,
    SFE_WAV_NO_DATA___23 = 67,
    SFE_WAV_BAD_LIST___23 = 68,
    SFE_WAV_ADPCM_NOT4BIT___23 = 69,
    SFE_WAV_ADPCM_CHANNELS___23 = 70,
    SFE_WAV_GSM610_FORMAT___23 = 71,
    SFE_WAV_UNKNOWN_CHUNK___23 = 72,
    SFE_WAV_WVPK_DATA___23 = 73,
    SFE_AIFF_NO_FORM___23 = 74,
    SFE_AIFF_AIFF_NO_FORM___23 = 75,
    SFE_AIFF_COMM_NO_FORM___23 = 76,
    SFE_AIFF_SSND_NO_COMM___23 = 77,
    SFE_AIFF_UNKNOWN_CHUNK___23 = 78,
    SFE_AIFF_COMM_CHUNK_SIZE___23 = 79,
    SFE_AIFF_BAD_COMM_CHUNK___23 = 80,
    SFE_AIFF_PEAK_B4_COMM___23 = 81,
    SFE_AIFF_BAD_PEAK___23 = 82,
    SFE_AIFF_NO_SSND___23 = 83,
    SFE_AIFF_NO_DATA___23 = 84,
    SFE_AIFF_RW_SSND_NOT_LAST___23 = 85,
    SFE_AU_UNKNOWN_FORMAT___23 = 86,
    SFE_AU_NO_DOTSND___23 = 87,
    SFE_AU_EMBED_BAD_LEN___23 = 88,
    SFE_RAW_READ_BAD_SPEC___23 = 89,
    SFE_RAW_BAD_BITWIDTH___23 = 90,
    SFE_RAW_BAD_FORMAT___23 = 91,
    SFE_PAF_NO_MARKER___23 = 92,
    SFE_PAF_VERSION___23 = 93,
    SFE_PAF_UNKNOWN_FORMAT___23 = 94,
    SFE_PAF_SHORT_HEADER___23 = 95,
    SFE_SVX_NO_FORM___23 = 96,
    SFE_SVX_NO_BODY___23 = 97,
    SFE_SVX_NO_DATA___23 = 98,
    SFE_SVX_BAD_COMP___23 = 99,
    SFE_SVX_BAD_NAME_LENGTH___23 = 100,
    SFE_NIST_BAD_HEADER___23 = 101,
    SFE_NIST_CRLF_CONVERISON___23 = 102,
    SFE_NIST_BAD_ENCODING___23 = 103,
    SFE_VOC_NO_CREATIVE___23 = 104,
    SFE_VOC_BAD_FORMAT___23 = 105,
    SFE_VOC_BAD_VERSION___23 = 106,
    SFE_VOC_BAD_MARKER___23 = 107,
    SFE_VOC_BAD_SECTIONS___23 = 108,
    SFE_VOC_MULTI_SAMPLERATE___23 = 109,
    SFE_VOC_MULTI_SECTION___23 = 110,
    SFE_VOC_MULTI_PARAM___23 = 111,
    SFE_VOC_SECTION_COUNT___23 = 112,
    SFE_VOC_NO_PIPE___23 = 113,
    SFE_IRCAM_NO_MARKER___23 = 114,
    SFE_IRCAM_BAD_CHANNELS___23 = 115,
    SFE_IRCAM_UNKNOWN_FORMAT___23 = 116,
    SFE_W64_64_BIT___23 = 117,
    SFE_W64_NO_RIFF___23 = 118,
    SFE_W64_NO_WAVE___23 = 119,
    SFE_W64_NO_DATA___23 = 120,
    SFE_W64_ADPCM_NOT4BIT___23 = 121,
    SFE_W64_ADPCM_CHANNELS___23 = 122,
    SFE_W64_GSM610_FORMAT___23 = 123,
    SFE_MAT4_BAD_NAME___23 = 124,
    SFE_MAT4_NO_SAMPLERATE___23 = 125,
    SFE_MAT5_BAD_ENDIAN___23 = 126,
    SFE_MAT5_NO_BLOCK___23 = 127,
    SFE_MAT5_SAMPLE_RATE___23 = 128,
    SFE_PVF_NO_PVF1___23 = 129,
    SFE_PVF_BAD_HEADER___23 = 130,
    SFE_PVF_BAD_BITWIDTH___23 = 131,
    SFE_DWVW_BAD_BITWIDTH___23 = 132,
    SFE_G72X_NOT_MONO___23 = 133,
    SFE_XI_BAD_HEADER___23 = 134,
    SFE_XI_EXCESS_SAMPLES___23 = 135,
    SFE_XI_NO_PIPE___23 = 136,
    SFE_HTK_NO_PIPE___23 = 137,
    SFE_SDS_NOT_SDS___23 = 138,
    SFE_SDS_BAD_BIT_WIDTH___23 = 139,
    SFE_SD2_FD_DISALLOWED___23 = 140,
    SFE_SD2_BAD_DATA_OFFSET___23 = 141,
    SFE_SD2_BAD_MAP_OFFSET___23 = 142,
    SFE_SD2_BAD_DATA_LENGTH___23 = 143,
    SFE_SD2_BAD_MAP_LENGTH___23 = 144,
    SFE_SD2_BAD_RSRC___23 = 145,
    SFE_SD2_BAD_SAMPLE_SIZE___23 = 146,
    SFE_FLAC_BAD_HEADER___23 = 147,
    SFE_FLAC_NEW_DECODER___23 = 148,
    SFE_FLAC_INIT_DECODER___23 = 149,
    SFE_FLAC_LOST_SYNC___23 = 150,
    SFE_FLAC_BAD_SAMPLE_RATE___23 = 151,
    SFE_FLAC_UNKOWN_ERROR___23 = 152,
    SFE_WVE_NOT_WVE___23 = 153,
    SFE_WVE_NO_PIPE___23 = 154,
    SFE_VORBIS_ENCODER_BUG___23 = 155,
    SFE_RF64_NOT_RF64___23 = 156,
    SFE_MAX_ERROR___23 = 157
} ;
#line 823
enum __anonenum__683 {
    SFC_TEST_AIFF_ADD_INST_CHUNK___23 = 8192,
    SFC_TEST_WAV_ADD_INFO_CHUNK___23 = 8208
} ;
#line 29 "/root/libsndfile/src/wav_w64.h"
enum __anonenum__684 {
    WAVE_FORMAT_UNKNOWN___3 = 0,
    WAVE_FORMAT_PCM___3 = 1,
    WAVE_FORMAT_MS_ADPCM___3 = 2,
    WAVE_FORMAT_IEEE_FLOAT___3 = 3,
    WAVE_FORMAT_VSELP___3 = 4,
    WAVE_FORMAT_IBM_CVSD___3 = 5,
    WAVE_FORMAT_ALAW___3 = 6,
    WAVE_FORMAT_MULAW___3 = 7,
    WAVE_FORMAT_OKI_ADPCM___3 = 16,
    WAVE_FORMAT_IMA_ADPCM___3 = 17,
    WAVE_FORMAT_MEDIASPACE_ADPCM___3 = 18,
    WAVE_FORMAT_SIERRA_ADPCM___3 = 19,
    WAVE_FORMAT_G723_ADPCM___3 = 20,
    WAVE_FORMAT_DIGISTD___3 = 21,
    WAVE_FORMAT_DIGIFIX___3 = 22,
    WAVE_FORMAT_DIALOGIC_OKI_ADPCM___3 = 23,
    WAVE_FORMAT_MEDIAVISION_ADPCM___3 = 24,
    WAVE_FORMAT_CU_CODEC___3 = 25,
    WAVE_FORMAT_YAMAHA_ADPCM___3 = 32,
    WAVE_FORMAT_SONARC___3 = 33,
    WAVE_FORMAT_DSPGROUP_TRUESPEECH___3 = 34,
    WAVE_FORMAT_ECHOSC1___3 = 35,
    WAVE_FORMAT_AUDIOFILE_AF36___3 = 36,
    WAVE_FORMAT_APTX___3 = 37,
    WAVE_FORMAT_AUDIOFILE_AF10___3 = 38,
    WAVE_FORMAT_PROSODY_1612___3 = 39,
    WAVE_FORMAT_LRC___3 = 40,
    WAVE_FORMAT_DOLBY_AC2___3 = 48,
    WAVE_FORMAT_GSM610___3 = 49,
    WAVE_FORMAT_MSNAUDIO___3 = 50,
    WAVE_FORMAT_ANTEX_ADPCME___3 = 51,
    WAVE_FORMAT_CONTROL_RES_VQLPC___3 = 52,
    WAVE_FORMAT_DIGIREAL___3 = 53,
    WAVE_FORMAT_DIGIADPCM___3 = 54,
    WAVE_FORMAT_CONTROL_RES_CR10___3 = 55,
    WAVE_FORMAT_NMS_VBXADPCM___3 = 56,
    WAVE_FORMAT_ROLAND_RDAC___3 = 57,
    WAVE_FORMAT_ECHOSC3___3 = 58,
    WAVE_FORMAT_ROCKWELL_ADPCM___3 = 59,
    WAVE_FORMAT_ROCKWELL_DIGITALK___3 = 60,
    WAVE_FORMAT_XEBEC___3 = 61,
    WAVE_FORMAT_G721_ADPCM___3 = 64,
    WAVE_FORMAT_G728_CELP___3 = 65,
    WAVE_FORMAT_MSG723___3 = 66,
    WAVE_FORMAT_MPEG___3 = 80,
    WAVE_FORMAT_RT24___3 = 82,
    WAVE_FORMAT_PAC___3 = 83,
    WAVE_FORMAT_MPEGLAYER3___3 = 85,
    WAVE_FORMAT_LUCENT_G723___3 = 89,
    WAVE_FORMAT_CIRRUS___3 = 96,
    WAVE_FORMAT_ESPCM___3 = 97,
    WAVE_FORMAT_VOXWARE___3 = 98,
    WAVE_FORMAT_CANOPUS_ATRAC___3 = 99,
    WAVE_FORMAT_G726_ADPCM___3 = 100,
    WAVE_FORMAT_G722_ADPCM___3 = 101,
    WAVE_FORMAT_DSAT___3 = 102,
    WAVE_FORMAT_DSAT_DISPLAY___3 = 103,
    WAVE_FORMAT_VOXWARE_BYTE_ALIGNED___3 = 105,
    WAVE_FORMAT_VOXWARE_AC8___3 = 112,
    WAVE_FORMAT_VOXWARE_AC10___3 = 113,
    WAVE_FORMAT_VOXWARE_AC16___3 = 114,
    WAVE_FORMAT_VOXWARE_AC20___3 = 115,
    WAVE_FORMAT_VOXWARE_RT24___3 = 116,
    WAVE_FORMAT_VOXWARE_RT29___3 = 117,
    WAVE_FORMAT_VOXWARE_RT29HW___3 = 118,
    WAVE_FORMAT_VOXWARE_VR12___3 = 119,
    WAVE_FORMAT_VOXWARE_VR18___3 = 120,
    WAVE_FORMAT_VOXWARE_TQ40___3 = 121,
    WAVE_FORMAT_SOFTSOUND___3 = 128,
    WAVE_FORMAT_VOXARE_TQ60___3 = 129,
    WAVE_FORMAT_MSRT24___3 = 130,
    WAVE_FORMAT_G729A___3 = 131,
    WAVE_FORMAT_MVI_MV12___3 = 132,
    WAVE_FORMAT_DF_G726___3 = 133,
    WAVE_FORMAT_DF_GSM610___3 = 134,
    WAVE_FORMAT_ONLIVE___3 = 137,
    WAVE_FORMAT_SBC24___3 = 145,
    WAVE_FORMAT_DOLBY_AC3_SPDIF___3 = 146,
    WAVE_FORMAT_ZYXEL_ADPCM___3 = 151,
    WAVE_FORMAT_PHILIPS_LPCBB___3 = 152,
    WAVE_FORMAT_PACKED___3 = 153,
    WAVE_FORMAT_RHETOREX_ADPCM___3 = 256,
    IBM_FORMAT_MULAW___3 = 257,
    IBM_FORMAT_ALAW___3 = 258,
    IBM_FORMAT_ADPCM___3 = 259,
    WAVE_FORMAT_VIVO_G723___3 = 273,
    WAVE_FORMAT_VIVO_SIREN___3 = 274,
    WAVE_FORMAT_DIGITAL_G723___3 = 291,
    WAVE_FORMAT_CREATIVE_ADPCM___3 = 512,
    WAVE_FORMAT_CREATIVE_FASTSPEECH8___3 = 514,
    WAVE_FORMAT_CREATIVE_FASTSPEECH10___3 = 515,
    WAVE_FORMAT_QUARTERDECK___3 = 544,
    WAVE_FORMAT_FM_TOWNS_SND___3 = 768,
    WAVE_FORMAT_BZV_DIGITAL___3 = 1024,
    WAVE_FORMAT_VME_VMPCM___3 = 1664,
    WAVE_FORMAT_OLIGSM___3 = 4096,
    WAVE_FORMAT_OLIADPCM___3 = 4097,
    WAVE_FORMAT_OLICELP___3 = 4098,
    WAVE_FORMAT_OLISBC___3 = 4099,
    WAVE_FORMAT_OLIOPR___3 = 4100,
    WAVE_FORMAT_LH_CODEC___3 = 4352,
    WAVE_FORMAT_NORRIS___3 = 5120,
    WAVE_FORMAT_SOUNDSPACE_MUSICOMPRESS___3 = 5376,
    WAVE_FORMAT_DVM___3 = 8192,
    WAVE_FORMAT_INTERWAV_VSC112___3 = 29008,
    WAVE_FORMAT_IPP_ITU_G_723_1___3 = 29232,
    WAVE_FORMAT_EXTENSIBLE___3 = 65534
} ;
#line 431 "/root/libsndfile/src/wav_w64.c"
struct __anonstruct_697 {
   int ID ;
   char const   *name ;
};
#line 434 "/root/libsndfile/src/wav_w64.c"
typedef struct __anonstruct_697 WAV_FORMAT_DESC;
#line 46 "/usr/include/ctype.h"
enum __anonenum__437___0 {
    _ISupper___5 = 256,
    _ISlower___5 = 512,
    _ISalpha___5 = 1024,
    _ISdigit___5 = 2048,
    _ISxdigit___5 = 4096,
    _ISspace___5 = 8192,
    _ISprint___5 = 16384,
    _ISgraph___5 = 32768,
    _ISblank___5 = 1,
    _IScntrl___5 = 2,
    _ISpunct___5 = 4,
    _ISalnum___5 = 8
} ;
#line 46 "/root/libsndfile/src/sndfile.h"
enum __anonenum__653___0 {
    SF_FORMAT_WAV___24 = 65536,
    SF_FORMAT_AIFF___24 = 131072,
    SF_FORMAT_AU___24 = 196608,
    SF_FORMAT_RAW___24 = 262144,
    SF_FORMAT_PAF___24 = 327680,
    SF_FORMAT_SVX___24 = 393216,
    SF_FORMAT_NIST___24 = 458752,
    SF_FORMAT_VOC___24 = 524288,
    SF_FORMAT_IRCAM___24 = 655360,
    SF_FORMAT_W64___24 = 720896,
    SF_FORMAT_MAT4___24 = 786432,
    SF_FORMAT_MAT5___24 = 851968,
    SF_FORMAT_PVF___24 = 917504,
    SF_FORMAT_XI___24 = 983040,
    SF_FORMAT_HTK___24 = 1048576,
    SF_FORMAT_SDS___24 = 1114112,
    SF_FORMAT_AVR___24 = 1179648,
    SF_FORMAT_WAVEX___24 = 1245184,
    SF_FORMAT_SD2___24 = 1441792,
    SF_FORMAT_FLAC___24 = 1507328,
    SF_FORMAT_CAF___24 = 1572864,
    SF_FORMAT_WVE___24 = 1638400,
    SF_FORMAT_OGG___24 = 2097152,
    SF_FORMAT_MPC2K___24 = 2162688,
    SF_FORMAT_RF64___24 = 2228224,
    SF_FORMAT_PCM_S8___24 = 1,
    SF_FORMAT_PCM_16___24 = 2,
    SF_FORMAT_PCM_24___24 = 3,
    SF_FORMAT_PCM_32___24 = 4,
    SF_FORMAT_PCM_U8___24 = 5,
    SF_FORMAT_FLOAT___24 = 6,
    SF_FORMAT_DOUBLE___24 = 7,
    SF_FORMAT_ULAW___24 = 16,
    SF_FORMAT_ALAW___24 = 17,
    SF_FORMAT_IMA_ADPCM___24 = 18,
    SF_FORMAT_MS_ADPCM___24 = 19,
    SF_FORMAT_GSM610___24 = 32,
    SF_FORMAT_VOX_ADPCM___24 = 33,
    SF_FORMAT_G721_32___24 = 48,
    SF_FORMAT_G723_24___24 = 49,
    SF_FORMAT_G723_40___24 = 50,
    SF_FORMAT_DWVW_12___24 = 64,
    SF_FORMAT_DWVW_16___24 = 65,
    SF_FORMAT_DWVW_24___24 = 66,
    SF_FORMAT_DWVW_N___24 = 67,
    SF_FORMAT_DPCM_8___24 = 80,
    SF_FORMAT_DPCM_16___24 = 81,
    SF_FORMAT_VORBIS___24 = 96,
    SF_ENDIAN_FILE___24 = 0,
    SF_ENDIAN_LITTLE___24 = 268435456,
    SF_ENDIAN_BIG___24 = 536870912,
    SF_ENDIAN_CPU___24 = 805306368,
    SF_FORMAT_SUBMASK___24 = 65535,
    SF_FORMAT_TYPEMASK___24 = 268369920,
    SF_FORMAT_ENDMASK___24 = 805306368
} ;
#line 126
enum __anonenum__654___0 {
    SFC_GET_LIB_VERSION___24 = 4096,
    SFC_GET_LOG_INFO___24 = 4097,
    SFC_GET_CURRENT_SF_INFO___24 = 4098,
    SFC_GET_NORM_DOUBLE___24 = 4112,
    SFC_GET_NORM_FLOAT___24 = 4113,
    SFC_SET_NORM_DOUBLE___24 = 4114,
    SFC_SET_NORM_FLOAT___24 = 4115,
    SFC_SET_SCALE_FLOAT_INT_READ___24 = 4116,
    SFC_SET_SCALE_INT_FLOAT_WRITE___24 = 4117,
    SFC_GET_SIMPLE_FORMAT_COUNT___24 = 4128,
    SFC_GET_SIMPLE_FORMAT___24 = 4129,
    SFC_GET_FORMAT_INFO___24 = 4136,
    SFC_GET_FORMAT_MAJOR_COUNT___24 = 4144,
    SFC_GET_FORMAT_MAJOR___24 = 4145,
    SFC_GET_FORMAT_SUBTYPE_COUNT___24 = 4146,
    SFC_GET_FORMAT_SUBTYPE___24 = 4147,
    SFC_CALC_SIGNAL_MAX___24 = 4160,
    SFC_CALC_NORM_SIGNAL_MAX___24 = 4161,
    SFC_CALC_MAX_ALL_CHANNELS___24 = 4162,
    SFC_CALC_NORM_MAX_ALL_CHANNELS___24 = 4163,
    SFC_GET_SIGNAL_MAX___24 = 4164,
    SFC_GET_MAX_ALL_CHANNELS___24 = 4165,
    SFC_SET_ADD_PEAK_CHUNK___24 = 4176,
    SFC_SET_ADD_HEADER_PAD_CHUNK___24 = 4177,
    SFC_UPDATE_HEADER_NOW___24 = 4192,
    SFC_SET_UPDATE_HEADER_AUTO___24 = 4193,
    SFC_FILE_TRUNCATE___24 = 4224,
    SFC_SET_RAW_START_OFFSET___24 = 4240,
    SFC_SET_DITHER_ON_WRITE___24 = 4256,
    SFC_SET_DITHER_ON_READ___24 = 4257,
    SFC_GET_DITHER_INFO_COUNT___24 = 4258,
    SFC_GET_DITHER_INFO___24 = 4259,
    SFC_GET_EMBED_FILE_INFO___24 = 4272,
    SFC_SET_CLIPPING___24 = 4288,
    SFC_GET_CLIPPING___24 = 4289,
    SFC_GET_INSTRUMENT___24 = 4304,
    SFC_SET_INSTRUMENT___24 = 4305,
    SFC_GET_LOOP_INFO___24 = 4320,
    SFC_GET_BROADCAST_INFO___24 = 4336,
    SFC_SET_BROADCAST_INFO___24 = 4337,
    SFC_GET_CHANNEL_MAP_INFO___24 = 4352,
    SFC_SET_CHANNEL_MAP_INFO___24 = 4353,
    SFC_RAW_DATA_NEEDS_ENDSWAP___24 = 4368,
    SFC_WAVEX_SET_AMBISONIC___24 = 4608,
    SFC_WAVEX_GET_AMBISONIC___24 = 4609,
    SFC_SET_VBR_ENCODING_QUALITY___24 = 4864,
    SFC_TEST_IEEE_FLOAT_REPLACE___24 = 24577,
    SFC_SET_ADD_DITHER_ON_WRITE___24 = 4208,
    SFC_SET_ADD_DITHER_ON_READ___24 = 4209
} ;
#line 216
enum __anonenum__655___0 {
    SF_STR_TITLE___24 = 1,
    SF_STR_COPYRIGHT___24 = 2,
    SF_STR_SOFTWARE___24 = 3,
    SF_STR_ARTIST___24 = 4,
    SF_STR_COMMENT___24 = 5,
    SF_STR_DATE___24 = 6,
    SF_STR_ALBUM___24 = 7,
    SF_STR_LICENSE___24 = 8
} ;
#line 235
enum __anonenum__656___0 {
    SF_FALSE___24 = 0,
    SF_TRUE___24 = 1,
    SFM_READ___24 = 16,
    SFM_WRITE___24 = 32,
    SFM_RDWR___24 = 48,
    SF_AMBISONIC_NONE___24 = 64,
    SF_AMBISONIC_B_FORMAT___24 = 65
} ;
#line 255
enum __anonenum__657___0 {
    SF_ERR_NO_ERROR___24 = 0,
    SF_ERR_UNRECOGNISED_FORMAT___24 = 1,
    SF_ERR_SYSTEM___24 = 2,
    SF_ERR_MALFORMED_FILE___24 = 3,
    SF_ERR_UNSUPPORTED_ENCODING___24 = 4
} ;
#line 267
enum __anonenum__658___0 {
    SF_CHANNEL_MAP_INVALID___24 = 0,
    SF_CHANNEL_MAP_MONO___24 = 1,
    SF_CHANNEL_MAP_LEFT___24 = 2,
    SF_CHANNEL_MAP_RIGHT___24 = 3,
    SF_CHANNEL_MAP_CENTER___24 = 4,
    SF_CHANNEL_MAP_FRONT_LEFT___24 = 5,
    SF_CHANNEL_MAP_FRONT_RIGHT___24 = 6,
    SF_CHANNEL_MAP_FRONT_CENTER___24 = 7,
    SF_CHANNEL_MAP_REAR_CENTER___24 = 8,
    SF_CHANNEL_MAP_REAR_LEFT___24 = 9,
    SF_CHANNEL_MAP_REAR_RIGHT___24 = 10,
    SF_CHANNEL_MAP_LFE___24 = 11,
    SF_CHANNEL_MAP_FRONT_LEFT_OF_CENTER___24 = 12,
    SF_CHANNEL_MAP_FRONT_RIGHT_OF_CENTER___24 = 13,
    SF_CHANNEL_MAP_SIDE_LEFT___24 = 14,
    SF_CHANNEL_MAP_SIDE_RIGHT___24 = 15,
    SF_CHANNEL_MAP_TOP_CENTER___24 = 16,
    SF_CHANNEL_MAP_TOP_FRONT_LEFT___24 = 17,
    SF_CHANNEL_MAP_TOP_FRONT_RIGHT___24 = 18,
    SF_CHANNEL_MAP_TOP_FRONT_CENTER___24 = 19,
    SF_CHANNEL_MAP_TOP_REAR_LEFT___24 = 20,
    SF_CHANNEL_MAP_TOP_REAR_RIGHT___24 = 21,
    SF_CHANNEL_MAP_TOP_REAR_CENTER___24 = 22
} ;
#line 352
enum __anonenum__660___0 {
    SFD_DEFAULT_LEVEL___24 = 0,
    SFD_CUSTOM_LEVEL___24 = 1073741824,
    SFD_NO_DITHER___24 = 500,
    SFD_WHITE___24 = 501,
    SFD_TRIANGULAR_PDF___24 = 502
} ;
#line 380
enum __anonenum__663___0 {
    SF_LOOP_NONE___24 = 800,
    SF_LOOP_FORWARD___24 = 801,
    SF_LOOP_BACKWARD___24 = 802,
    SF_LOOP_ALTERNATING___24 = 803
} ;
#line 121 "/root/libsndfile/src/common.h"
enum __anonenum__672___0 {
    SF_PEAK_START___24 = 42,
    SF_PEAK_END___24 = 43,
    SF_SCALE_MAX___24 = 52,
    SF_SCALE_MIN___24 = 53,
    SF_STR_ALLOW_START___24 = 256,
    SF_STR_ALLOW_END___24 = 512,
    SF_STR_LOCATE_START___24 = 1024,
    SF_STR_LOCATE_END___24 = 2048,
    SFD_TYPEMASK___24 = 268435455
} ;
#line 149
enum __anonenum__673___0 {
    SF_FORMAT_TXW___24 = 67305472,
    SF_FORMAT_DWD___24 = 67371008,
    SF_FORMAT_REX___24 = 67764224,
    SF_FORMAT_REX2___24 = 67960832,
    SF_FORMAT_KRZ___24 = 68026368,
    SF_FORMAT_WMA___24 = 68157440,
    SF_FORMAT_SHN___24 = 68222976,
    SF_FORMAT_SVX_FIB___24 = 4128,
    SF_FORMAT_SVX_EXP___24 = 4129,
    SF_FORMAT_PCM_N___24 = 4144
} ;
#line 405
enum __anonenum__679___0 {
    SFE_NO_ERROR___24 = 0,
    SFE_BAD_OPEN_FORMAT___24 = 1,
    SFE_SYSTEM___24 = 2,
    SFE_MALFORMED_FILE___24 = 3,
    SFE_UNSUPPORTED_ENCODING___24 = 4,
    SFE_ZERO_MAJOR_FORMAT___24 = 5,
    SFE_ZERO_MINOR_FORMAT___24 = 6,
    SFE_BAD_FILE___24 = 7,
    SFE_BAD_FILE_READ___24 = 8,
    SFE_OPEN_FAILED___24 = 9,
    SFE_BAD_SNDFILE_PTR___24 = 10,
    SFE_BAD_SF_INFO_PTR___24 = 11,
    SFE_BAD_SF_INCOMPLETE___24 = 12,
    SFE_BAD_FILE_PTR___24 = 13,
    SFE_BAD_INT_PTR___24 = 14,
    SFE_BAD_STAT_SIZE___24 = 15,
    SFE_MALLOC_FAILED___24 = 16,
    SFE_UNIMPLEMENTED___24 = 17,
    SFE_BAD_READ_ALIGN___24 = 18,
    SFE_BAD_WRITE_ALIGN___24 = 19,
    SFE_UNKNOWN_FORMAT___24 = 20,
    SFE_NOT_READMODE___24 = 21,
    SFE_NOT_WRITEMODE___24 = 22,
    SFE_BAD_MODE_RW___24 = 23,
    SFE_BAD_SF_INFO___24 = 24,
    SFE_BAD_OFFSET___24 = 25,
    SFE_NO_EMBED_SUPPORT___24 = 26,
    SFE_NO_EMBEDDED_RDWR___24 = 27,
    SFE_NO_PIPE_WRITE___24 = 28,
    SFE_INTERNAL___24 = 29,
    SFE_BAD_COMMAND_PARAM___24 = 30,
    SFE_BAD_ENDIAN___24 = 31,
    SFE_CHANNEL_COUNT_ZERO___24 = 32,
    SFE_CHANNEL_COUNT___24 = 33,
    SFE_BAD_VIRTUAL_IO___24 = 34,
    SFE_INTERLEAVE_MODE___24 = 35,
    SFE_INTERLEAVE_SEEK___24 = 36,
    SFE_INTERLEAVE_READ___24 = 37,
    SFE_BAD_SEEK___24 = 38,
    SFE_NOT_SEEKABLE___24 = 39,
    SFE_AMBIGUOUS_SEEK___24 = 40,
    SFE_WRONG_SEEK___24 = 41,
    SFE_SEEK_FAILED___24 = 42,
    SFE_BAD_OPEN_MODE___24 = 43,
    SFE_OPEN_PIPE_RDWR___24 = 44,
    SFE_RDWR_POSITION___24 = 45,
    SFE_RDWR_BAD_HEADER___24 = 46,
    SFE_CMD_HAS_DATA___24 = 47,
    SFE_BAD_BROADCAST_INFO_SIZE___24 = 48,
    SFE_STR_NO_SUPPORT___24 = 49,
    SFE_STR_NOT_WRITE___24 = 50,
    SFE_STR_MAX_DATA___24 = 51,
    SFE_STR_MAX_COUNT___24 = 52,
    SFE_STR_BAD_TYPE___24 = 53,
    SFE_STR_NO_ADD_END___24 = 54,
    SFE_STR_BAD_STRING___24 = 55,
    SFE_STR_WEIRD___24 = 56,
    SFE_WAV_NO_RIFF___24 = 57,
    SFE_WAV_NO_WAVE___24 = 58,
    SFE_WAV_NO_FMT___24 = 59,
    SFE_WAV_BAD_FMT___24 = 60,
    SFE_WAV_FMT_SHORT___24 = 61,
    SFE_WAV_BAD_FACT___24 = 62,
    SFE_WAV_BAD_PEAK___24 = 63,
    SFE_WAV_PEAK_B4_FMT___24 = 64,
    SFE_WAV_BAD_FORMAT___24 = 65,
    SFE_WAV_BAD_BLOCKALIGN___24 = 66,
    SFE_WAV_NO_DATA___24 = 67,
    SFE_WAV_BAD_LIST___24 = 68,
    SFE_WAV_ADPCM_NOT4BIT___24 = 69,
    SFE_WAV_ADPCM_CHANNELS___24 = 70,
    SFE_WAV_GSM610_FORMAT___24 = 71,
    SFE_WAV_UNKNOWN_CHUNK___24 = 72,
    SFE_WAV_WVPK_DATA___24 = 73,
    SFE_AIFF_NO_FORM___24 = 74,
    SFE_AIFF_AIFF_NO_FORM___24 = 75,
    SFE_AIFF_COMM_NO_FORM___24 = 76,
    SFE_AIFF_SSND_NO_COMM___24 = 77,
    SFE_AIFF_UNKNOWN_CHUNK___24 = 78,
    SFE_AIFF_COMM_CHUNK_SIZE___24 = 79,
    SFE_AIFF_BAD_COMM_CHUNK___24 = 80,
    SFE_AIFF_PEAK_B4_COMM___24 = 81,
    SFE_AIFF_BAD_PEAK___24 = 82,
    SFE_AIFF_NO_SSND___24 = 83,
    SFE_AIFF_NO_DATA___24 = 84,
    SFE_AIFF_RW_SSND_NOT_LAST___24 = 85,
    SFE_AU_UNKNOWN_FORMAT___24 = 86,
    SFE_AU_NO_DOTSND___24 = 87,
    SFE_AU_EMBED_BAD_LEN___24 = 88,
    SFE_RAW_READ_BAD_SPEC___24 = 89,
    SFE_RAW_BAD_BITWIDTH___24 = 90,
    SFE_RAW_BAD_FORMAT___24 = 91,
    SFE_PAF_NO_MARKER___24 = 92,
    SFE_PAF_VERSION___24 = 93,
    SFE_PAF_UNKNOWN_FORMAT___24 = 94,
    SFE_PAF_SHORT_HEADER___24 = 95,
    SFE_SVX_NO_FORM___24 = 96,
    SFE_SVX_NO_BODY___24 = 97,
    SFE_SVX_NO_DATA___24 = 98,
    SFE_SVX_BAD_COMP___24 = 99,
    SFE_SVX_BAD_NAME_LENGTH___24 = 100,
    SFE_NIST_BAD_HEADER___24 = 101,
    SFE_NIST_CRLF_CONVERISON___24 = 102,
    SFE_NIST_BAD_ENCODING___24 = 103,
    SFE_VOC_NO_CREATIVE___24 = 104,
    SFE_VOC_BAD_FORMAT___24 = 105,
    SFE_VOC_BAD_VERSION___24 = 106,
    SFE_VOC_BAD_MARKER___24 = 107,
    SFE_VOC_BAD_SECTIONS___24 = 108,
    SFE_VOC_MULTI_SAMPLERATE___24 = 109,
    SFE_VOC_MULTI_SECTION___24 = 110,
    SFE_VOC_MULTI_PARAM___24 = 111,
    SFE_VOC_SECTION_COUNT___24 = 112,
    SFE_VOC_NO_PIPE___24 = 113,
    SFE_IRCAM_NO_MARKER___24 = 114,
    SFE_IRCAM_BAD_CHANNELS___24 = 115,
    SFE_IRCAM_UNKNOWN_FORMAT___24 = 116,
    SFE_W64_64_BIT___24 = 117,
    SFE_W64_NO_RIFF___24 = 118,
    SFE_W64_NO_WAVE___24 = 119,
    SFE_W64_NO_DATA___24 = 120,
    SFE_W64_ADPCM_NOT4BIT___24 = 121,
    SFE_W64_ADPCM_CHANNELS___24 = 122,
    SFE_W64_GSM610_FORMAT___24 = 123,
    SFE_MAT4_BAD_NAME___24 = 124,
    SFE_MAT4_NO_SAMPLERATE___24 = 125,
    SFE_MAT5_BAD_ENDIAN___24 = 126,
    SFE_MAT5_NO_BLOCK___24 = 127,
    SFE_MAT5_SAMPLE_RATE___24 = 128,
    SFE_PVF_NO_PVF1___24 = 129,
    SFE_PVF_BAD_HEADER___24 = 130,
    SFE_PVF_BAD_BITWIDTH___24 = 131,
    SFE_DWVW_BAD_BITWIDTH___24 = 132,
    SFE_G72X_NOT_MONO___24 = 133,
    SFE_XI_BAD_HEADER___24 = 134,
    SFE_XI_EXCESS_SAMPLES___24 = 135,
    SFE_XI_NO_PIPE___24 = 136,
    SFE_HTK_NO_PIPE___24 = 137,
    SFE_SDS_NOT_SDS___24 = 138,
    SFE_SDS_BAD_BIT_WIDTH___24 = 139,
    SFE_SD2_FD_DISALLOWED___24 = 140,
    SFE_SD2_BAD_DATA_OFFSET___24 = 141,
    SFE_SD2_BAD_MAP_OFFSET___24 = 142,
    SFE_SD2_BAD_DATA_LENGTH___24 = 143,
    SFE_SD2_BAD_MAP_LENGTH___24 = 144,
    SFE_SD2_BAD_RSRC___24 = 145,
    SFE_SD2_BAD_SAMPLE_SIZE___24 = 146,
    SFE_FLAC_BAD_HEADER___24 = 147,
    SFE_FLAC_NEW_DECODER___24 = 148,
    SFE_FLAC_INIT_DECODER___24 = 149,
    SFE_FLAC_LOST_SYNC___24 = 150,
    SFE_FLAC_BAD_SAMPLE_RATE___24 = 151,
    SFE_FLAC_UNKOWN_ERROR___24 = 152,
    SFE_WVE_NOT_WVE___24 = 153,
    SFE_WVE_NO_PIPE___24 = 154,
    SFE_VORBIS_ENCODER_BUG___24 = 155,
    SFE_RF64_NOT_RF64___24 = 156,
    SFE_MAX_ERROR___24 = 157
} ;
#line 823
enum __anonenum__683___0 {
    SFC_TEST_AIFF_ADD_INST_CHUNK___24 = 8192,
    SFC_TEST_WAV_ADD_INFO_CHUNK___24 = 8208
} ;
#line 29 "/root/libsndfile/src/wav_w64.h"
enum __anonenum__684___0 {
    WAVE_FORMAT_UNKNOWN___4 = 0,
    WAVE_FORMAT_PCM___4 = 1,
    WAVE_FORMAT_MS_ADPCM___4 = 2,
    WAVE_FORMAT_IEEE_FLOAT___4 = 3,
    WAVE_FORMAT_VSELP___4 = 4,
    WAVE_FORMAT_IBM_CVSD___4 = 5,
    WAVE_FORMAT_ALAW___4 = 6,
    WAVE_FORMAT_MULAW___4 = 7,
    WAVE_FORMAT_OKI_ADPCM___4 = 16,
    WAVE_FORMAT_IMA_ADPCM___4 = 17,
    WAVE_FORMAT_MEDIASPACE_ADPCM___4 = 18,
    WAVE_FORMAT_SIERRA_ADPCM___4 = 19,
    WAVE_FORMAT_G723_ADPCM___4 = 20,
    WAVE_FORMAT_DIGISTD___4 = 21,
    WAVE_FORMAT_DIGIFIX___4 = 22,
    WAVE_FORMAT_DIALOGIC_OKI_ADPCM___4 = 23,
    WAVE_FORMAT_MEDIAVISION_ADPCM___4 = 24,
    WAVE_FORMAT_CU_CODEC___4 = 25,
    WAVE_FORMAT_YAMAHA_ADPCM___4 = 32,
    WAVE_FORMAT_SONARC___4 = 33,
    WAVE_FORMAT_DSPGROUP_TRUESPEECH___4 = 34,
    WAVE_FORMAT_ECHOSC1___4 = 35,
    WAVE_FORMAT_AUDIOFILE_AF36___4 = 36,
    WAVE_FORMAT_APTX___4 = 37,
    WAVE_FORMAT_AUDIOFILE_AF10___4 = 38,
    WAVE_FORMAT_PROSODY_1612___4 = 39,
    WAVE_FORMAT_LRC___4 = 40,
    WAVE_FORMAT_DOLBY_AC2___4 = 48,
    WAVE_FORMAT_GSM610___4 = 49,
    WAVE_FORMAT_MSNAUDIO___4 = 50,
    WAVE_FORMAT_ANTEX_ADPCME___4 = 51,
    WAVE_FORMAT_CONTROL_RES_VQLPC___4 = 52,
    WAVE_FORMAT_DIGIREAL___4 = 53,
    WAVE_FORMAT_DIGIADPCM___4 = 54,
    WAVE_FORMAT_CONTROL_RES_CR10___4 = 55,
    WAVE_FORMAT_NMS_VBXADPCM___4 = 56,
    WAVE_FORMAT_ROLAND_RDAC___4 = 57,
    WAVE_FORMAT_ECHOSC3___4 = 58,
    WAVE_FORMAT_ROCKWELL_ADPCM___4 = 59,
    WAVE_FORMAT_ROCKWELL_DIGITALK___4 = 60,
    WAVE_FORMAT_XEBEC___4 = 61,
    WAVE_FORMAT_G721_ADPCM___4 = 64,
    WAVE_FORMAT_G728_CELP___4 = 65,
    WAVE_FORMAT_MSG723___4 = 66,
    WAVE_FORMAT_MPEG___4 = 80,
    WAVE_FORMAT_RT24___4 = 82,
    WAVE_FORMAT_PAC___4 = 83,
    WAVE_FORMAT_MPEGLAYER3___4 = 85,
    WAVE_FORMAT_LUCENT_G723___4 = 89,
    WAVE_FORMAT_CIRRUS___4 = 96,
    WAVE_FORMAT_ESPCM___4 = 97,
    WAVE_FORMAT_VOXWARE___4 = 98,
    WAVE_FORMAT_CANOPUS_ATRAC___4 = 99,
    WAVE_FORMAT_G726_ADPCM___4 = 100,
    WAVE_FORMAT_G722_ADPCM___4 = 101,
    WAVE_FORMAT_DSAT___4 = 102,
    WAVE_FORMAT_DSAT_DISPLAY___4 = 103,
    WAVE_FORMAT_VOXWARE_BYTE_ALIGNED___4 = 105,
    WAVE_FORMAT_VOXWARE_AC8___4 = 112,
    WAVE_FORMAT_VOXWARE_AC10___4 = 113,
    WAVE_FORMAT_VOXWARE_AC16___4 = 114,
    WAVE_FORMAT_VOXWARE_AC20___4 = 115,
    WAVE_FORMAT_VOXWARE_RT24___4 = 116,
    WAVE_FORMAT_VOXWARE_RT29___4 = 117,
    WAVE_FORMAT_VOXWARE_RT29HW___4 = 118,
    WAVE_FORMAT_VOXWARE_VR12___4 = 119,
    WAVE_FORMAT_VOXWARE_VR18___4 = 120,
    WAVE_FORMAT_VOXWARE_TQ40___4 = 121,
    WAVE_FORMAT_SOFTSOUND___4 = 128,
    WAVE_FORMAT_VOXARE_TQ60___4 = 129,
    WAVE_FORMAT_MSRT24___4 = 130,
    WAVE_FORMAT_G729A___4 = 131,
    WAVE_FORMAT_MVI_MV12___4 = 132,
    WAVE_FORMAT_DF_G726___4 = 133,
    WAVE_FORMAT_DF_GSM610___4 = 134,
    WAVE_FORMAT_ONLIVE___4 = 137,
    WAVE_FORMAT_SBC24___4 = 145,
    WAVE_FORMAT_DOLBY_AC3_SPDIF___4 = 146,
    WAVE_FORMAT_ZYXEL_ADPCM___4 = 151,
    WAVE_FORMAT_PHILIPS_LPCBB___4 = 152,
    WAVE_FORMAT_PACKED___4 = 153,
    WAVE_FORMAT_RHETOREX_ADPCM___4 = 256,
    IBM_FORMAT_MULAW___4 = 257,
    IBM_FORMAT_ALAW___4 = 258,
    IBM_FORMAT_ADPCM___4 = 259,
    WAVE_FORMAT_VIVO_G723___4 = 273,
    WAVE_FORMAT_VIVO_SIREN___4 = 274,
    WAVE_FORMAT_DIGITAL_G723___4 = 291,
    WAVE_FORMAT_CREATIVE_ADPCM___4 = 512,
    WAVE_FORMAT_CREATIVE_FASTSPEECH8___4 = 514,
    WAVE_FORMAT_CREATIVE_FASTSPEECH10___4 = 515,
    WAVE_FORMAT_QUARTERDECK___4 = 544,
    WAVE_FORMAT_FM_TOWNS_SND___4 = 768,
    WAVE_FORMAT_BZV_DIGITAL___4 = 1024,
    WAVE_FORMAT_VME_VMPCM___4 = 1664,
    WAVE_FORMAT_OLIGSM___4 = 4096,
    WAVE_FORMAT_OLIADPCM___4 = 4097,
    WAVE_FORMAT_OLICELP___4 = 4098,
    WAVE_FORMAT_OLISBC___4 = 4099,
    WAVE_FORMAT_OLIOPR___4 = 4100,
    WAVE_FORMAT_LH_CODEC___4 = 4352,
    WAVE_FORMAT_NORRIS___4 = 5120,
    WAVE_FORMAT_SOUNDSPACE_MUSICOMPRESS___4 = 5376,
    WAVE_FORMAT_DVM___4 = 8192,
    WAVE_FORMAT_INTERWAV_VSC112___4 = 29008,
    WAVE_FORMAT_IPP_ITU_G_723_1___4 = 29232,
    WAVE_FORMAT_EXTENSIBLE___4 = 65534
} ;
#line 103 "/root/libsndfile/src/w64.c"
enum __anonenum__698 {
    HAVE_riff = 1,
    HAVE_wave = 2,
    HAVE_fmt___0 = 4,
    HAVE_fact___0 = 8,
    HAVE_data___0 = 32
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__510___1 {
    _ISupper___6 = 256,
    _ISlower___6 = 512,
    _ISalpha___6 = 1024,
    _ISdigit___6 = 2048,
    _ISxdigit___6 = 4096,
    _ISspace___6 = 8192,
    _ISprint___6 = 16384,
    _ISgraph___6 = 32768,
    _ISblank___6 = 1,
    _IScntrl___6 = 2,
    _ISpunct___6 = 4,
    _ISalnum___6 = 8
} ;
#line 46 "/root/libsndfile/src/sndfile.h"
enum __anonenum__524___1 {
    SF_FORMAT_WAV___25 = 65536,
    SF_FORMAT_AIFF___25 = 131072,
    SF_FORMAT_AU___25 = 196608,
    SF_FORMAT_RAW___25 = 262144,
    SF_FORMAT_PAF___25 = 327680,
    SF_FORMAT_SVX___25 = 393216,
    SF_FORMAT_NIST___25 = 458752,
    SF_FORMAT_VOC___25 = 524288,
    SF_FORMAT_IRCAM___25 = 655360,
    SF_FORMAT_W64___25 = 720896,
    SF_FORMAT_MAT4___25 = 786432,
    SF_FORMAT_MAT5___25 = 851968,
    SF_FORMAT_PVF___25 = 917504,
    SF_FORMAT_XI___25 = 983040,
    SF_FORMAT_HTK___25 = 1048576,
    SF_FORMAT_SDS___25 = 1114112,
    SF_FORMAT_AVR___25 = 1179648,
    SF_FORMAT_WAVEX___25 = 1245184,
    SF_FORMAT_SD2___25 = 1441792,
    SF_FORMAT_FLAC___25 = 1507328,
    SF_FORMAT_CAF___25 = 1572864,
    SF_FORMAT_WVE___25 = 1638400,
    SF_FORMAT_OGG___25 = 2097152,
    SF_FORMAT_MPC2K___25 = 2162688,
    SF_FORMAT_RF64___25 = 2228224,
    SF_FORMAT_PCM_S8___25 = 1,
    SF_FORMAT_PCM_16___25 = 2,
    SF_FORMAT_PCM_24___25 = 3,
    SF_FORMAT_PCM_32___25 = 4,
    SF_FORMAT_PCM_U8___25 = 5,
    SF_FORMAT_FLOAT___25 = 6,
    SF_FORMAT_DOUBLE___25 = 7,
    SF_FORMAT_ULAW___25 = 16,
    SF_FORMAT_ALAW___25 = 17,
    SF_FORMAT_IMA_ADPCM___25 = 18,
    SF_FORMAT_MS_ADPCM___25 = 19,
    SF_FORMAT_GSM610___25 = 32,
    SF_FORMAT_VOX_ADPCM___25 = 33,
    SF_FORMAT_G721_32___25 = 48,
    SF_FORMAT_G723_24___25 = 49,
    SF_FORMAT_G723_40___25 = 50,
    SF_FORMAT_DWVW_12___25 = 64,
    SF_FORMAT_DWVW_16___25 = 65,
    SF_FORMAT_DWVW_24___25 = 66,
    SF_FORMAT_DWVW_N___25 = 67,
    SF_FORMAT_DPCM_8___25 = 80,
    SF_FORMAT_DPCM_16___25 = 81,
    SF_FORMAT_VORBIS___25 = 96,
    SF_ENDIAN_FILE___25 = 0,
    SF_ENDIAN_LITTLE___25 = 268435456,
    SF_ENDIAN_BIG___25 = 536870912,
    SF_ENDIAN_CPU___25 = 805306368,
    SF_FORMAT_SUBMASK___25 = 65535,
    SF_FORMAT_TYPEMASK___25 = 268369920,
    SF_FORMAT_ENDMASK___25 = 805306368
} ;
#line 126
enum __anonenum__525___1 {
    SFC_GET_LIB_VERSION___25 = 4096,
    SFC_GET_LOG_INFO___25 = 4097,
    SFC_GET_CURRENT_SF_INFO___25 = 4098,
    SFC_GET_NORM_DOUBLE___25 = 4112,
    SFC_GET_NORM_FLOAT___25 = 4113,
    SFC_SET_NORM_DOUBLE___25 = 4114,
    SFC_SET_NORM_FLOAT___25 = 4115,
    SFC_SET_SCALE_FLOAT_INT_READ___25 = 4116,
    SFC_SET_SCALE_INT_FLOAT_WRITE___25 = 4117,
    SFC_GET_SIMPLE_FORMAT_COUNT___25 = 4128,
    SFC_GET_SIMPLE_FORMAT___25 = 4129,
    SFC_GET_FORMAT_INFO___25 = 4136,
    SFC_GET_FORMAT_MAJOR_COUNT___25 = 4144,
    SFC_GET_FORMAT_MAJOR___25 = 4145,
    SFC_GET_FORMAT_SUBTYPE_COUNT___25 = 4146,
    SFC_GET_FORMAT_SUBTYPE___25 = 4147,
    SFC_CALC_SIGNAL_MAX___25 = 4160,
    SFC_CALC_NORM_SIGNAL_MAX___25 = 4161,
    SFC_CALC_MAX_ALL_CHANNELS___25 = 4162,
    SFC_CALC_NORM_MAX_ALL_CHANNELS___25 = 4163,
    SFC_GET_SIGNAL_MAX___25 = 4164,
    SFC_GET_MAX_ALL_CHANNELS___25 = 4165,
    SFC_SET_ADD_PEAK_CHUNK___25 = 4176,
    SFC_SET_ADD_HEADER_PAD_CHUNK___25 = 4177,
    SFC_UPDATE_HEADER_NOW___25 = 4192,
    SFC_SET_UPDATE_HEADER_AUTO___25 = 4193,
    SFC_FILE_TRUNCATE___25 = 4224,
    SFC_SET_RAW_START_OFFSET___25 = 4240,
    SFC_SET_DITHER_ON_WRITE___25 = 4256,
    SFC_SET_DITHER_ON_READ___25 = 4257,
    SFC_GET_DITHER_INFO_COUNT___25 = 4258,
    SFC_GET_DITHER_INFO___25 = 4259,
    SFC_GET_EMBED_FILE_INFO___25 = 4272,
    SFC_SET_CLIPPING___25 = 4288,
    SFC_GET_CLIPPING___25 = 4289,
    SFC_GET_INSTRUMENT___25 = 4304,
    SFC_SET_INSTRUMENT___25 = 4305,
    SFC_GET_LOOP_INFO___25 = 4320,
    SFC_GET_BROADCAST_INFO___25 = 4336,
    SFC_SET_BROADCAST_INFO___25 = 4337,
    SFC_GET_CHANNEL_MAP_INFO___25 = 4352,
    SFC_SET_CHANNEL_MAP_INFO___25 = 4353,
    SFC_RAW_DATA_NEEDS_ENDSWAP___25 = 4368,
    SFC_WAVEX_SET_AMBISONIC___25 = 4608,
    SFC_WAVEX_GET_AMBISONIC___25 = 4609,
    SFC_SET_VBR_ENCODING_QUALITY___25 = 4864,
    SFC_TEST_IEEE_FLOAT_REPLACE___25 = 24577,
    SFC_SET_ADD_DITHER_ON_WRITE___25 = 4208,
    SFC_SET_ADD_DITHER_ON_READ___25 = 4209
} ;
#line 216
enum __anonenum__526___1 {
    SF_STR_TITLE___25 = 1,
    SF_STR_COPYRIGHT___25 = 2,
    SF_STR_SOFTWARE___25 = 3,
    SF_STR_ARTIST___25 = 4,
    SF_STR_COMMENT___25 = 5,
    SF_STR_DATE___25 = 6,
    SF_STR_ALBUM___25 = 7,
    SF_STR_LICENSE___25 = 8
} ;
#line 235
enum __anonenum__527___1 {
    SF_FALSE___25 = 0,
    SF_TRUE___25 = 1,
    SFM_READ___25 = 16,
    SFM_WRITE___25 = 32,
    SFM_RDWR___25 = 48,
    SF_AMBISONIC_NONE___25 = 64,
    SF_AMBISONIC_B_FORMAT___25 = 65
} ;
#line 255
enum __anonenum__528___1 {
    SF_ERR_NO_ERROR___25 = 0,
    SF_ERR_UNRECOGNISED_FORMAT___25 = 1,
    SF_ERR_SYSTEM___25 = 2,
    SF_ERR_MALFORMED_FILE___25 = 3,
    SF_ERR_UNSUPPORTED_ENCODING___25 = 4
} ;
#line 267
enum __anonenum__529___1 {
    SF_CHANNEL_MAP_INVALID___25 = 0,
    SF_CHANNEL_MAP_MONO___25 = 1,
    SF_CHANNEL_MAP_LEFT___25 = 2,
    SF_CHANNEL_MAP_RIGHT___25 = 3,
    SF_CHANNEL_MAP_CENTER___25 = 4,
    SF_CHANNEL_MAP_FRONT_LEFT___25 = 5,
    SF_CHANNEL_MAP_FRONT_RIGHT___25 = 6,
    SF_CHANNEL_MAP_FRONT_CENTER___25 = 7,
    SF_CHANNEL_MAP_REAR_CENTER___25 = 8,
    SF_CHANNEL_MAP_REAR_LEFT___25 = 9,
    SF_CHANNEL_MAP_REAR_RIGHT___25 = 10,
    SF_CHANNEL_MAP_LFE___25 = 11,
    SF_CHANNEL_MAP_FRONT_LEFT_OF_CENTER___25 = 12,
    SF_CHANNEL_MAP_FRONT_RIGHT_OF_CENTER___25 = 13,
    SF_CHANNEL_MAP_SIDE_LEFT___25 = 14,
    SF_CHANNEL_MAP_SIDE_RIGHT___25 = 15,
    SF_CHANNEL_MAP_TOP_CENTER___25 = 16,
    SF_CHANNEL_MAP_TOP_FRONT_LEFT___25 = 17,
    SF_CHANNEL_MAP_TOP_FRONT_RIGHT___25 = 18,
    SF_CHANNEL_MAP_TOP_FRONT_CENTER___25 = 19,
    SF_CHANNEL_MAP_TOP_REAR_LEFT___25 = 20,
    SF_CHANNEL_MAP_TOP_REAR_RIGHT___25 = 21,
    SF_CHANNEL_MAP_TOP_REAR_CENTER___25 = 22
} ;
#line 352
enum __anonenum__531___1 {
    SFD_DEFAULT_LEVEL___25 = 0,
    SFD_CUSTOM_LEVEL___25 = 1073741824,
    SFD_NO_DITHER___25 = 500,
    SFD_WHITE___25 = 501,
    SFD_TRIANGULAR_PDF___25 = 502
} ;
#line 380
enum __anonenum__534___1 {
    SF_LOOP_NONE___25 = 800,
    SF_LOOP_FORWARD___25 = 801,
    SF_LOOP_BACKWARD___25 = 802,
    SF_LOOP_ALTERNATING___25 = 803
} ;
#line 121 "/root/libsndfile/src/common.h"
enum __anonenum__543___1 {
    SF_PEAK_START___25 = 42,
    SF_PEAK_END___25 = 43,
    SF_SCALE_MAX___25 = 52,
    SF_SCALE_MIN___25 = 53,
    SF_STR_ALLOW_START___25 = 256,
    SF_STR_ALLOW_END___25 = 512,
    SF_STR_LOCATE_START___25 = 1024,
    SF_STR_LOCATE_END___25 = 2048,
    SFD_TYPEMASK___25 = 268435455
} ;
#line 149
enum __anonenum__544___1 {
    SF_FORMAT_TXW___25 = 67305472,
    SF_FORMAT_DWD___25 = 67371008,
    SF_FORMAT_REX___25 = 67764224,
    SF_FORMAT_REX2___25 = 67960832,
    SF_FORMAT_KRZ___25 = 68026368,
    SF_FORMAT_WMA___25 = 68157440,
    SF_FORMAT_SHN___25 = 68222976,
    SF_FORMAT_SVX_FIB___25 = 4128,
    SF_FORMAT_SVX_EXP___25 = 4129,
    SF_FORMAT_PCM_N___25 = 4144
} ;
#line 405
enum __anonenum__550___1 {
    SFE_NO_ERROR___25 = 0,
    SFE_BAD_OPEN_FORMAT___25 = 1,
    SFE_SYSTEM___25 = 2,
    SFE_MALFORMED_FILE___25 = 3,
    SFE_UNSUPPORTED_ENCODING___25 = 4,
    SFE_ZERO_MAJOR_FORMAT___25 = 5,
    SFE_ZERO_MINOR_FORMAT___25 = 6,
    SFE_BAD_FILE___25 = 7,
    SFE_BAD_FILE_READ___25 = 8,
    SFE_OPEN_FAILED___25 = 9,
    SFE_BAD_SNDFILE_PTR___25 = 10,
    SFE_BAD_SF_INFO_PTR___25 = 11,
    SFE_BAD_SF_INCOMPLETE___25 = 12,
    SFE_BAD_FILE_PTR___25 = 13,
    SFE_BAD_INT_PTR___25 = 14,
    SFE_BAD_STAT_SIZE___25 = 15,
    SFE_MALLOC_FAILED___25 = 16,
    SFE_UNIMPLEMENTED___25 = 17,
    SFE_BAD_READ_ALIGN___25 = 18,
    SFE_BAD_WRITE_ALIGN___25 = 19,
    SFE_UNKNOWN_FORMAT___25 = 20,
    SFE_NOT_READMODE___25 = 21,
    SFE_NOT_WRITEMODE___25 = 22,
    SFE_BAD_MODE_RW___25 = 23,
    SFE_BAD_SF_INFO___25 = 24,
    SFE_BAD_OFFSET___25 = 25,
    SFE_NO_EMBED_SUPPORT___25 = 26,
    SFE_NO_EMBEDDED_RDWR___25 = 27,
    SFE_NO_PIPE_WRITE___25 = 28,
    SFE_INTERNAL___25 = 29,
    SFE_BAD_COMMAND_PARAM___25 = 30,
    SFE_BAD_ENDIAN___25 = 31,
    SFE_CHANNEL_COUNT_ZERO___25 = 32,
    SFE_CHANNEL_COUNT___25 = 33,
    SFE_BAD_VIRTUAL_IO___25 = 34,
    SFE_INTERLEAVE_MODE___25 = 35,
    SFE_INTERLEAVE_SEEK___25 = 36,
    SFE_INTERLEAVE_READ___25 = 37,
    SFE_BAD_SEEK___25 = 38,
    SFE_NOT_SEEKABLE___25 = 39,
    SFE_AMBIGUOUS_SEEK___25 = 40,
    SFE_WRONG_SEEK___25 = 41,
    SFE_SEEK_FAILED___25 = 42,
    SFE_BAD_OPEN_MODE___25 = 43,
    SFE_OPEN_PIPE_RDWR___25 = 44,
    SFE_RDWR_POSITION___25 = 45,
    SFE_RDWR_BAD_HEADER___25 = 46,
    SFE_CMD_HAS_DATA___25 = 47,
    SFE_BAD_BROADCAST_INFO_SIZE___25 = 48,
    SFE_STR_NO_SUPPORT___25 = 49,
    SFE_STR_NOT_WRITE___25 = 50,
    SFE_STR_MAX_DATA___25 = 51,
    SFE_STR_MAX_COUNT___25 = 52,
    SFE_STR_BAD_TYPE___25 = 53,
    SFE_STR_NO_ADD_END___25 = 54,
    SFE_STR_BAD_STRING___25 = 55,
    SFE_STR_WEIRD___25 = 56,
    SFE_WAV_NO_RIFF___25 = 57,
    SFE_WAV_NO_WAVE___25 = 58,
    SFE_WAV_NO_FMT___25 = 59,
    SFE_WAV_BAD_FMT___25 = 60,
    SFE_WAV_FMT_SHORT___25 = 61,
    SFE_WAV_BAD_FACT___25 = 62,
    SFE_WAV_BAD_PEAK___25 = 63,
    SFE_WAV_PEAK_B4_FMT___25 = 64,
    SFE_WAV_BAD_FORMAT___25 = 65,
    SFE_WAV_BAD_BLOCKALIGN___25 = 66,
    SFE_WAV_NO_DATA___25 = 67,
    SFE_WAV_BAD_LIST___25 = 68,
    SFE_WAV_ADPCM_NOT4BIT___25 = 69,
    SFE_WAV_ADPCM_CHANNELS___25 = 70,
    SFE_WAV_GSM610_FORMAT___25 = 71,
    SFE_WAV_UNKNOWN_CHUNK___25 = 72,
    SFE_WAV_WVPK_DATA___25 = 73,
    SFE_AIFF_NO_FORM___25 = 74,
    SFE_AIFF_AIFF_NO_FORM___25 = 75,
    SFE_AIFF_COMM_NO_FORM___25 = 76,
    SFE_AIFF_SSND_NO_COMM___25 = 77,
    SFE_AIFF_UNKNOWN_CHUNK___25 = 78,
    SFE_AIFF_COMM_CHUNK_SIZE___25 = 79,
    SFE_AIFF_BAD_COMM_CHUNK___25 = 80,
    SFE_AIFF_PEAK_B4_COMM___25 = 81,
    SFE_AIFF_BAD_PEAK___25 = 82,
    SFE_AIFF_NO_SSND___25 = 83,
    SFE_AIFF_NO_DATA___25 = 84,
    SFE_AIFF_RW_SSND_NOT_LAST___25 = 85,
    SFE_AU_UNKNOWN_FORMAT___25 = 86,
    SFE_AU_NO_DOTSND___25 = 87,
    SFE_AU_EMBED_BAD_LEN___25 = 88,
    SFE_RAW_READ_BAD_SPEC___25 = 89,
    SFE_RAW_BAD_BITWIDTH___25 = 90,
    SFE_RAW_BAD_FORMAT___25 = 91,
    SFE_PAF_NO_MARKER___25 = 92,
    SFE_PAF_VERSION___25 = 93,
    SFE_PAF_UNKNOWN_FORMAT___25 = 94,
    SFE_PAF_SHORT_HEADER___25 = 95,
    SFE_SVX_NO_FORM___25 = 96,
    SFE_SVX_NO_BODY___25 = 97,
    SFE_SVX_NO_DATA___25 = 98,
    SFE_SVX_BAD_COMP___25 = 99,
    SFE_SVX_BAD_NAME_LENGTH___25 = 100,
    SFE_NIST_BAD_HEADER___25 = 101,
    SFE_NIST_CRLF_CONVERISON___25 = 102,
    SFE_NIST_BAD_ENCODING___25 = 103,
    SFE_VOC_NO_CREATIVE___25 = 104,
    SFE_VOC_BAD_FORMAT___25 = 105,
    SFE_VOC_BAD_VERSION___25 = 106,
    SFE_VOC_BAD_MARKER___25 = 107,
    SFE_VOC_BAD_SECTIONS___25 = 108,
    SFE_VOC_MULTI_SAMPLERATE___25 = 109,
    SFE_VOC_MULTI_SECTION___25 = 110,
    SFE_VOC_MULTI_PARAM___25 = 111,
    SFE_VOC_SECTION_COUNT___25 = 112,
    SFE_VOC_NO_PIPE___25 = 113,
    SFE_IRCAM_NO_MARKER___25 = 114,
    SFE_IRCAM_BAD_CHANNELS___25 = 115,
    SFE_IRCAM_UNKNOWN_FORMAT___25 = 116,
    SFE_W64_64_BIT___25 = 117,
    SFE_W64_NO_RIFF___25 = 118,
    SFE_W64_NO_WAVE___25 = 119,
    SFE_W64_NO_DATA___25 = 120,
    SFE_W64_ADPCM_NOT4BIT___25 = 121,
    SFE_W64_ADPCM_CHANNELS___25 = 122,
    SFE_W64_GSM610_FORMAT___25 = 123,
    SFE_MAT4_BAD_NAME___25 = 124,
    SFE_MAT4_NO_SAMPLERATE___25 = 125,
    SFE_MAT5_BAD_ENDIAN___25 = 126,
    SFE_MAT5_NO_BLOCK___25 = 127,
    SFE_MAT5_SAMPLE_RATE___25 = 128,
    SFE_PVF_NO_PVF1___25 = 129,
    SFE_PVF_BAD_HEADER___25 = 130,
    SFE_PVF_BAD_BITWIDTH___25 = 131,
    SFE_DWVW_BAD_BITWIDTH___25 = 132,
    SFE_G72X_NOT_MONO___25 = 133,
    SFE_XI_BAD_HEADER___25 = 134,
    SFE_XI_EXCESS_SAMPLES___25 = 135,
    SFE_XI_NO_PIPE___25 = 136,
    SFE_HTK_NO_PIPE___25 = 137,
    SFE_SDS_NOT_SDS___25 = 138,
    SFE_SDS_BAD_BIT_WIDTH___25 = 139,
    SFE_SD2_FD_DISALLOWED___25 = 140,
    SFE_SD2_BAD_DATA_OFFSET___25 = 141,
    SFE_SD2_BAD_MAP_OFFSET___25 = 142,
    SFE_SD2_BAD_DATA_LENGTH___25 = 143,
    SFE_SD2_BAD_MAP_LENGTH___25 = 144,
    SFE_SD2_BAD_RSRC___25 = 145,
    SFE_SD2_BAD_SAMPLE_SIZE___25 = 146,
    SFE_FLAC_BAD_HEADER___25 = 147,
    SFE_FLAC_NEW_DECODER___25 = 148,
    SFE_FLAC_INIT_DECODER___25 = 149,
    SFE_FLAC_LOST_SYNC___25 = 150,
    SFE_FLAC_BAD_SAMPLE_RATE___25 = 151,
    SFE_FLAC_UNKOWN_ERROR___25 = 152,
    SFE_WVE_NOT_WVE___25 = 153,
    SFE_WVE_NO_PIPE___25 = 154,
    SFE_VORBIS_ENCODER_BUG___25 = 155,
    SFE_RF64_NOT_RF64___25 = 156,
    SFE_MAX_ERROR___25 = 157
} ;
#line 823
enum __anonenum__554___1 {
    SFC_TEST_AIFF_ADD_INST_CHUNK___25 = 8192,
    SFC_TEST_WAV_ADD_INFO_CHUNK___25 = 8208
} ;
#line 46 "/root/libsndfile/src/sndfile.h"
enum __anonenum__598___0 {
    SF_FORMAT_WAV___26 = 65536,
    SF_FORMAT_AIFF___26 = 131072,
    SF_FORMAT_AU___26 = 196608,
    SF_FORMAT_RAW___26 = 262144,
    SF_FORMAT_PAF___26 = 327680,
    SF_FORMAT_SVX___26 = 393216,
    SF_FORMAT_NIST___26 = 458752,
    SF_FORMAT_VOC___26 = 524288,
    SF_FORMAT_IRCAM___26 = 655360,
    SF_FORMAT_W64___26 = 720896,
    SF_FORMAT_MAT4___26 = 786432,
    SF_FORMAT_MAT5___26 = 851968,
    SF_FORMAT_PVF___26 = 917504,
    SF_FORMAT_XI___26 = 983040,
    SF_FORMAT_HTK___26 = 1048576,
    SF_FORMAT_SDS___26 = 1114112,
    SF_FORMAT_AVR___26 = 1179648,
    SF_FORMAT_WAVEX___26 = 1245184,
    SF_FORMAT_SD2___26 = 1441792,
    SF_FORMAT_FLAC___26 = 1507328,
    SF_FORMAT_CAF___26 = 1572864,
    SF_FORMAT_WVE___26 = 1638400,
    SF_FORMAT_OGG___26 = 2097152,
    SF_FORMAT_MPC2K___26 = 2162688,
    SF_FORMAT_RF64___26 = 2228224,
    SF_FORMAT_PCM_S8___26 = 1,
    SF_FORMAT_PCM_16___26 = 2,
    SF_FORMAT_PCM_24___26 = 3,
    SF_FORMAT_PCM_32___26 = 4,
    SF_FORMAT_PCM_U8___26 = 5,
    SF_FORMAT_FLOAT___26 = 6,
    SF_FORMAT_DOUBLE___26 = 7,
    SF_FORMAT_ULAW___26 = 16,
    SF_FORMAT_ALAW___26 = 17,
    SF_FORMAT_IMA_ADPCM___26 = 18,
    SF_FORMAT_MS_ADPCM___26 = 19,
    SF_FORMAT_GSM610___26 = 32,
    SF_FORMAT_VOX_ADPCM___26 = 33,
    SF_FORMAT_G721_32___26 = 48,
    SF_FORMAT_G723_24___26 = 49,
    SF_FORMAT_G723_40___26 = 50,
    SF_FORMAT_DWVW_12___26 = 64,
    SF_FORMAT_DWVW_16___26 = 65,
    SF_FORMAT_DWVW_24___26 = 66,
    SF_FORMAT_DWVW_N___26 = 67,
    SF_FORMAT_DPCM_8___26 = 80,
    SF_FORMAT_DPCM_16___26 = 81,
    SF_FORMAT_VORBIS___26 = 96,
    SF_ENDIAN_FILE___26 = 0,
    SF_ENDIAN_LITTLE___26 = 268435456,
    SF_ENDIAN_BIG___26 = 536870912,
    SF_ENDIAN_CPU___26 = 805306368,
    SF_FORMAT_SUBMASK___26 = 65535,
    SF_FORMAT_TYPEMASK___26 = 268369920,
    SF_FORMAT_ENDMASK___26 = 805306368
} ;
#line 126
enum __anonenum__699 {
    SFC_GET_LIB_VERSION___26 = 4096,
    SFC_GET_LOG_INFO___26 = 4097,
    SFC_GET_CURRENT_SF_INFO___26 = 4098,
    SFC_GET_NORM_DOUBLE___26 = 4112,
    SFC_GET_NORM_FLOAT___26 = 4113,
    SFC_SET_NORM_DOUBLE___26 = 4114,
    SFC_SET_NORM_FLOAT___26 = 4115,
    SFC_SET_SCALE_FLOAT_INT_READ___26 = 4116,
    SFC_SET_SCALE_INT_FLOAT_WRITE___26 = 4117,
    SFC_GET_SIMPLE_FORMAT_COUNT___26 = 4128,
    SFC_GET_SIMPLE_FORMAT___26 = 4129,
    SFC_GET_FORMAT_INFO___26 = 4136,
    SFC_GET_FORMAT_MAJOR_COUNT___26 = 4144,
    SFC_GET_FORMAT_MAJOR___26 = 4145,
    SFC_GET_FORMAT_SUBTYPE_COUNT___26 = 4146,
    SFC_GET_FORMAT_SUBTYPE___26 = 4147,
    SFC_CALC_SIGNAL_MAX___26 = 4160,
    SFC_CALC_NORM_SIGNAL_MAX___26 = 4161,
    SFC_CALC_MAX_ALL_CHANNELS___26 = 4162,
    SFC_CALC_NORM_MAX_ALL_CHANNELS___26 = 4163,
    SFC_GET_SIGNAL_MAX___26 = 4164,
    SFC_GET_MAX_ALL_CHANNELS___26 = 4165,
    SFC_SET_ADD_PEAK_CHUNK___26 = 4176,
    SFC_SET_ADD_HEADER_PAD_CHUNK___26 = 4177,
    SFC_UPDATE_HEADER_NOW___26 = 4192,
    SFC_SET_UPDATE_HEADER_AUTO___26 = 4193,
    SFC_FILE_TRUNCATE___26 = 4224,
    SFC_SET_RAW_START_OFFSET___26 = 4240,
    SFC_SET_DITHER_ON_WRITE___26 = 4256,
    SFC_SET_DITHER_ON_READ___26 = 4257,
    SFC_GET_DITHER_INFO_COUNT___26 = 4258,
    SFC_GET_DITHER_INFO___26 = 4259,
    SFC_GET_EMBED_FILE_INFO___26 = 4272,
    SFC_SET_CLIPPING___26 = 4288,
    SFC_GET_CLIPPING___26 = 4289,
    SFC_GET_INSTRUMENT___26 = 4304,
    SFC_SET_INSTRUMENT___26 = 4305,
    SFC_GET_LOOP_INFO___26 = 4320,
    SFC_GET_BROADCAST_INFO___26 = 4336,
    SFC_SET_BROADCAST_INFO___26 = 4337,
    SFC_GET_CHANNEL_MAP_INFO___26 = 4352,
    SFC_SET_CHANNEL_MAP_INFO___26 = 4353,
    SFC_RAW_DATA_NEEDS_ENDSWAP___26 = 4368,
    SFC_WAVEX_SET_AMBISONIC___26 = 4608,
    SFC_WAVEX_GET_AMBISONIC___26 = 4609,
    SFC_SET_VBR_ENCODING_QUALITY___26 = 4864,
    SFC_TEST_IEEE_FLOAT_REPLACE___26 = 24577,
    SFC_SET_ADD_DITHER_ON_WRITE___26 = 4208,
    SFC_SET_ADD_DITHER_ON_READ___26 = 4209
} ;
#line 216
enum __anonenum__700 {
    SF_STR_TITLE___26 = 1,
    SF_STR_COPYRIGHT___26 = 2,
    SF_STR_SOFTWARE___26 = 3,
    SF_STR_ARTIST___26 = 4,
    SF_STR_COMMENT___26 = 5,
    SF_STR_DATE___26 = 6,
    SF_STR_ALBUM___26 = 7,
    SF_STR_LICENSE___26 = 8
} ;
#line 235
enum __anonenum__701 {
    SF_FALSE___26 = 0,
    SF_TRUE___26 = 1,
    SFM_READ___26 = 16,
    SFM_WRITE___26 = 32,
    SFM_RDWR___26 = 48,
    SF_AMBISONIC_NONE___26 = 64,
    SF_AMBISONIC_B_FORMAT___26 = 65
} ;
#line 255
enum __anonenum__702 {
    SF_ERR_NO_ERROR___26 = 0,
    SF_ERR_UNRECOGNISED_FORMAT___26 = 1,
    SF_ERR_SYSTEM___26 = 2,
    SF_ERR_MALFORMED_FILE___26 = 3,
    SF_ERR_UNSUPPORTED_ENCODING___26 = 4
} ;
#line 267
enum __anonenum__703 {
    SF_CHANNEL_MAP_INVALID___26 = 0,
    SF_CHANNEL_MAP_MONO___26 = 1,
    SF_CHANNEL_MAP_LEFT___26 = 2,
    SF_CHANNEL_MAP_RIGHT___26 = 3,
    SF_CHANNEL_MAP_CENTER___26 = 4,
    SF_CHANNEL_MAP_FRONT_LEFT___26 = 5,
    SF_CHANNEL_MAP_FRONT_RIGHT___26 = 6,
    SF_CHANNEL_MAP_FRONT_CENTER___26 = 7,
    SF_CHANNEL_MAP_REAR_CENTER___26 = 8,
    SF_CHANNEL_MAP_REAR_LEFT___26 = 9,
    SF_CHANNEL_MAP_REAR_RIGHT___26 = 10,
    SF_CHANNEL_MAP_LFE___26 = 11,
    SF_CHANNEL_MAP_FRONT_LEFT_OF_CENTER___26 = 12,
    SF_CHANNEL_MAP_FRONT_RIGHT_OF_CENTER___26 = 13,
    SF_CHANNEL_MAP_SIDE_LEFT___26 = 14,
    SF_CHANNEL_MAP_SIDE_RIGHT___26 = 15,
    SF_CHANNEL_MAP_TOP_CENTER___26 = 16,
    SF_CHANNEL_MAP_TOP_FRONT_LEFT___26 = 17,
    SF_CHANNEL_MAP_TOP_FRONT_RIGHT___26 = 18,
    SF_CHANNEL_MAP_TOP_FRONT_CENTER___26 = 19,
    SF_CHANNEL_MAP_TOP_REAR_LEFT___26 = 20,
    SF_CHANNEL_MAP_TOP_REAR_RIGHT___26 = 21,
    SF_CHANNEL_MAP_TOP_REAR_CENTER___26 = 22
} ;
#line 352
enum __anonenum__705 {
    SFD_DEFAULT_LEVEL___26 = 0,
    SFD_CUSTOM_LEVEL___26 = 1073741824,
    SFD_NO_DITHER___26 = 500,
    SFD_WHITE___26 = 501,
    SFD_TRIANGULAR_PDF___26 = 502
} ;
#line 380
enum __anonenum__708 {
    SF_LOOP_NONE___26 = 800,
    SF_LOOP_FORWARD___26 = 801,
    SF_LOOP_BACKWARD___26 = 802,
    SF_LOOP_ALTERNATING___26 = 803
} ;
#line 121 "/root/libsndfile/src/common.h"
enum __anonenum__713 {
    SF_PEAK_START___26 = 42,
    SF_PEAK_END___26 = 43,
    SF_SCALE_MAX___26 = 52,
    SF_SCALE_MIN___26 = 53,
    SF_STR_ALLOW_START___26 = 256,
    SF_STR_ALLOW_END___26 = 512,
    SF_STR_LOCATE_START___26 = 1024,
    SF_STR_LOCATE_END___26 = 2048,
    SFD_TYPEMASK___26 = 268435455
} ;
#line 149
enum __anonenum__714 {
    SF_FORMAT_TXW___26 = 67305472,
    SF_FORMAT_DWD___26 = 67371008,
    SF_FORMAT_REX___26 = 67764224,
    SF_FORMAT_REX2___26 = 67960832,
    SF_FORMAT_KRZ___26 = 68026368,
    SF_FORMAT_WMA___26 = 68157440,
    SF_FORMAT_SHN___26 = 68222976,
    SF_FORMAT_SVX_FIB___26 = 4128,
    SF_FORMAT_SVX_EXP___26 = 4129,
    SF_FORMAT_PCM_N___26 = 4144
} ;
#line 405
enum __anonenum__720 {
    SFE_NO_ERROR___26 = 0,
    SFE_BAD_OPEN_FORMAT___26 = 1,
    SFE_SYSTEM___26 = 2,
    SFE_MALFORMED_FILE___26 = 3,
    SFE_UNSUPPORTED_ENCODING___26 = 4,
    SFE_ZERO_MAJOR_FORMAT___26 = 5,
    SFE_ZERO_MINOR_FORMAT___26 = 6,
    SFE_BAD_FILE___26 = 7,
    SFE_BAD_FILE_READ___26 = 8,
    SFE_OPEN_FAILED___26 = 9,
    SFE_BAD_SNDFILE_PTR___26 = 10,
    SFE_BAD_SF_INFO_PTR___26 = 11,
    SFE_BAD_SF_INCOMPLETE___26 = 12,
    SFE_BAD_FILE_PTR___26 = 13,
    SFE_BAD_INT_PTR___26 = 14,
    SFE_BAD_STAT_SIZE___26 = 15,
    SFE_MALLOC_FAILED___26 = 16,
    SFE_UNIMPLEMENTED___26 = 17,
    SFE_BAD_READ_ALIGN___26 = 18,
    SFE_BAD_WRITE_ALIGN___26 = 19,
    SFE_UNKNOWN_FORMAT___26 = 20,
    SFE_NOT_READMODE___26 = 21,
    SFE_NOT_WRITEMODE___26 = 22,
    SFE_BAD_MODE_RW___26 = 23,
    SFE_BAD_SF_INFO___26 = 24,
    SFE_BAD_OFFSET___26 = 25,
    SFE_NO_EMBED_SUPPORT___26 = 26,
    SFE_NO_EMBEDDED_RDWR___26 = 27,
    SFE_NO_PIPE_WRITE___26 = 28,
    SFE_INTERNAL___26 = 29,
    SFE_BAD_COMMAND_PARAM___26 = 30,
    SFE_BAD_ENDIAN___26 = 31,
    SFE_CHANNEL_COUNT_ZERO___26 = 32,
    SFE_CHANNEL_COUNT___26 = 33,
    SFE_BAD_VIRTUAL_IO___26 = 34,
    SFE_INTERLEAVE_MODE___26 = 35,
    SFE_INTERLEAVE_SEEK___26 = 36,
    SFE_INTERLEAVE_READ___26 = 37,
    SFE_BAD_SEEK___26 = 38,
    SFE_NOT_SEEKABLE___26 = 39,
    SFE_AMBIGUOUS_SEEK___26 = 40,
    SFE_WRONG_SEEK___26 = 41,
    SFE_SEEK_FAILED___26 = 42,
    SFE_BAD_OPEN_MODE___26 = 43,
    SFE_OPEN_PIPE_RDWR___26 = 44,
    SFE_RDWR_POSITION___26 = 45,
    SFE_RDWR_BAD_HEADER___26 = 46,
    SFE_CMD_HAS_DATA___26 = 47,
    SFE_BAD_BROADCAST_INFO_SIZE___26 = 48,
    SFE_STR_NO_SUPPORT___26 = 49,
    SFE_STR_NOT_WRITE___26 = 50,
    SFE_STR_MAX_DATA___26 = 51,
    SFE_STR_MAX_COUNT___26 = 52,
    SFE_STR_BAD_TYPE___26 = 53,
    SFE_STR_NO_ADD_END___26 = 54,
    SFE_STR_BAD_STRING___26 = 55,
    SFE_STR_WEIRD___26 = 56,
    SFE_WAV_NO_RIFF___26 = 57,
    SFE_WAV_NO_WAVE___26 = 58,
    SFE_WAV_NO_FMT___26 = 59,
    SFE_WAV_BAD_FMT___26 = 60,
    SFE_WAV_FMT_SHORT___26 = 61,
    SFE_WAV_BAD_FACT___26 = 62,
    SFE_WAV_BAD_PEAK___26 = 63,
    SFE_WAV_PEAK_B4_FMT___26 = 64,
    SFE_WAV_BAD_FORMAT___26 = 65,
    SFE_WAV_BAD_BLOCKALIGN___26 = 66,
    SFE_WAV_NO_DATA___26 = 67,
    SFE_WAV_BAD_LIST___26 = 68,
    SFE_WAV_ADPCM_NOT4BIT___26 = 69,
    SFE_WAV_ADPCM_CHANNELS___26 = 70,
    SFE_WAV_GSM610_FORMAT___26 = 71,
    SFE_WAV_UNKNOWN_CHUNK___26 = 72,
    SFE_WAV_WVPK_DATA___26 = 73,
    SFE_AIFF_NO_FORM___26 = 74,
    SFE_AIFF_AIFF_NO_FORM___26 = 75,
    SFE_AIFF_COMM_NO_FORM___26 = 76,
    SFE_AIFF_SSND_NO_COMM___26 = 77,
    SFE_AIFF_UNKNOWN_CHUNK___26 = 78,
    SFE_AIFF_COMM_CHUNK_SIZE___26 = 79,
    SFE_AIFF_BAD_COMM_CHUNK___26 = 80,
    SFE_AIFF_PEAK_B4_COMM___26 = 81,
    SFE_AIFF_BAD_PEAK___26 = 82,
    SFE_AIFF_NO_SSND___26 = 83,
    SFE_AIFF_NO_DATA___26 = 84,
    SFE_AIFF_RW_SSND_NOT_LAST___26 = 85,
    SFE_AU_UNKNOWN_FORMAT___26 = 86,
    SFE_AU_NO_DOTSND___26 = 87,
    SFE_AU_EMBED_BAD_LEN___26 = 88,
    SFE_RAW_READ_BAD_SPEC___26 = 89,
    SFE_RAW_BAD_BITWIDTH___26 = 90,
    SFE_RAW_BAD_FORMAT___26 = 91,
    SFE_PAF_NO_MARKER___26 = 92,
    SFE_PAF_VERSION___26 = 93,
    SFE_PAF_UNKNOWN_FORMAT___26 = 94,
    SFE_PAF_SHORT_HEADER___26 = 95,
    SFE_SVX_NO_FORM___26 = 96,
    SFE_SVX_NO_BODY___26 = 97,
    SFE_SVX_NO_DATA___26 = 98,
    SFE_SVX_BAD_COMP___26 = 99,
    SFE_SVX_BAD_NAME_LENGTH___26 = 100,
    SFE_NIST_BAD_HEADER___26 = 101,
    SFE_NIST_CRLF_CONVERISON___26 = 102,
    SFE_NIST_BAD_ENCODING___26 = 103,
    SFE_VOC_NO_CREATIVE___26 = 104,
    SFE_VOC_BAD_FORMAT___26 = 105,
    SFE_VOC_BAD_VERSION___26 = 106,
    SFE_VOC_BAD_MARKER___26 = 107,
    SFE_VOC_BAD_SECTIONS___26 = 108,
    SFE_VOC_MULTI_SAMPLERATE___26 = 109,
    SFE_VOC_MULTI_SECTION___26 = 110,
    SFE_VOC_MULTI_PARAM___26 = 111,
    SFE_VOC_SECTION_COUNT___26 = 112,
    SFE_VOC_NO_PIPE___26 = 113,
    SFE_IRCAM_NO_MARKER___26 = 114,
    SFE_IRCAM_BAD_CHANNELS___26 = 115,
    SFE_IRCAM_UNKNOWN_FORMAT___26 = 116,
    SFE_W64_64_BIT___26 = 117,
    SFE_W64_NO_RIFF___26 = 118,
    SFE_W64_NO_WAVE___26 = 119,
    SFE_W64_NO_DATA___26 = 120,
    SFE_W64_ADPCM_NOT4BIT___26 = 121,
    SFE_W64_ADPCM_CHANNELS___26 = 122,
    SFE_W64_GSM610_FORMAT___26 = 123,
    SFE_MAT4_BAD_NAME___26 = 124,
    SFE_MAT4_NO_SAMPLERATE___26 = 125,
    SFE_MAT5_BAD_ENDIAN___26 = 126,
    SFE_MAT5_NO_BLOCK___26 = 127,
    SFE_MAT5_SAMPLE_RATE___26 = 128,
    SFE_PVF_NO_PVF1___26 = 129,
    SFE_PVF_BAD_HEADER___26 = 130,
    SFE_PVF_BAD_BITWIDTH___26 = 131,
    SFE_DWVW_BAD_BITWIDTH___26 = 132,
    SFE_G72X_NOT_MONO___26 = 133,
    SFE_XI_BAD_HEADER___26 = 134,
    SFE_XI_EXCESS_SAMPLES___26 = 135,
    SFE_XI_NO_PIPE___26 = 136,
    SFE_HTK_NO_PIPE___26 = 137,
    SFE_SDS_NOT_SDS___26 = 138,
    SFE_SDS_BAD_BIT_WIDTH___26 = 139,
    SFE_SD2_FD_DISALLOWED___26 = 140,
    SFE_SD2_BAD_DATA_OFFSET___26 = 141,
    SFE_SD2_BAD_MAP_OFFSET___26 = 142,
    SFE_SD2_BAD_DATA_LENGTH___26 = 143,
    SFE_SD2_BAD_MAP_LENGTH___26 = 144,
    SFE_SD2_BAD_RSRC___26 = 145,
    SFE_SD2_BAD_SAMPLE_SIZE___26 = 146,
    SFE_FLAC_BAD_HEADER___26 = 147,
    SFE_FLAC_NEW_DECODER___26 = 148,
    SFE_FLAC_INIT_DECODER___26 = 149,
    SFE_FLAC_LOST_SYNC___26 = 150,
    SFE_FLAC_BAD_SAMPLE_RATE___26 = 151,
    SFE_FLAC_UNKOWN_ERROR___26 = 152,
    SFE_WVE_NOT_WVE___26 = 153,
    SFE_WVE_NO_PIPE___26 = 154,
    SFE_VORBIS_ENCODER_BUG___26 = 155,
    SFE_RF64_NOT_RF64___26 = 156,
    SFE_MAX_ERROR___26 = 157
} ;
#line 823
enum __anonenum__724 {
    SFC_TEST_AIFF_ADD_INST_CHUNK___26 = 8192,
    SFC_TEST_WAV_ADD_INFO_CHUNK___26 = 8208
} ;
#line 44 "/root/libsndfile/src/voc.c"
enum __anonenum__725 {
    VOC_TERMINATOR = 0,
    VOC_SOUND_DATA = 1,
    VOC_SOUND_CONTINUE = 2,
    VOC_SILENCE = 3,
    VOC_MARKER = 4,
    VOC_ASCII = 5,
    VOC_REPEAT = 6,
    VOC_END_REPEAT = 7,
    VOC_EXTENDED = 8,
    VOC_EXTENDED_II = 9
} ;
#line 57 "/root/libsndfile/src/voc.c"
struct __anonstruct_726 {
   int samples ;
   int offset ;
};
#line 60 "/root/libsndfile/src/voc.c"
typedef struct __anonstruct_726 SND_DATA_BLOCKS;
#line 62 "/root/libsndfile/src/voc.c"
struct __anonstruct_727 {
   unsigned int sections ;
   unsigned int section_types ;
   int samplerate ;
   int channels ;
   int bitwidth ;
   SND_DATA_BLOCKS blocks[200] ;
};
#line 66 "/root/libsndfile/src/voc.c"
typedef struct __anonstruct_727 VOC_DATA;
#line 46 "/usr/include/ctype.h"
enum __anonenum__510___2 {
    _ISupper___7 = 256,
    _ISlower___7 = 512,
    _ISalpha___7 = 1024,
    _ISdigit___7 = 2048,
    _ISxdigit___7 = 4096,
    _ISspace___7 = 8192,
    _ISprint___7 = 16384,
    _ISgraph___7 = 32768,
    _ISblank___7 = 1,
    _IScntrl___7 = 2,
    _ISpunct___7 = 4,
    _ISalnum___7 = 8
} ;
#line 46 "/root/libsndfile/src/sndfile.h"
enum __anonenum__524___2 {
    SF_FORMAT_WAV___27 = 65536,
    SF_FORMAT_AIFF___27 = 131072,
    SF_FORMAT_AU___27 = 196608,
    SF_FORMAT_RAW___27 = 262144,
    SF_FORMAT_PAF___27 = 327680,
    SF_FORMAT_SVX___27 = 393216,
    SF_FORMAT_NIST___27 = 458752,
    SF_FORMAT_VOC___27 = 524288,
    SF_FORMAT_IRCAM___27 = 655360,
    SF_FORMAT_W64___27 = 720896,
    SF_FORMAT_MAT4___27 = 786432,
    SF_FORMAT_MAT5___27 = 851968,
    SF_FORMAT_PVF___27 = 917504,
    SF_FORMAT_XI___27 = 983040,
    SF_FORMAT_HTK___27 = 1048576,
    SF_FORMAT_SDS___27 = 1114112,
    SF_FORMAT_AVR___27 = 1179648,
    SF_FORMAT_WAVEX___27 = 1245184,
    SF_FORMAT_SD2___27 = 1441792,
    SF_FORMAT_FLAC___27 = 1507328,
    SF_FORMAT_CAF___27 = 1572864,
    SF_FORMAT_WVE___27 = 1638400,
    SF_FORMAT_OGG___27 = 2097152,
    SF_FORMAT_MPC2K___27 = 2162688,
    SF_FORMAT_RF64___27 = 2228224,
    SF_FORMAT_PCM_S8___27 = 1,
    SF_FORMAT_PCM_16___27 = 2,
    SF_FORMAT_PCM_24___27 = 3,
    SF_FORMAT_PCM_32___27 = 4,
    SF_FORMAT_PCM_U8___27 = 5,
    SF_FORMAT_FLOAT___27 = 6,
    SF_FORMAT_DOUBLE___27 = 7,
    SF_FORMAT_ULAW___27 = 16,
    SF_FORMAT_ALAW___27 = 17,
    SF_FORMAT_IMA_ADPCM___27 = 18,
    SF_FORMAT_MS_ADPCM___27 = 19,
    SF_FORMAT_GSM610___27 = 32,
    SF_FORMAT_VOX_ADPCM___27 = 33,
    SF_FORMAT_G721_32___27 = 48,
    SF_FORMAT_G723_24___27 = 49,
    SF_FORMAT_G723_40___27 = 50,
    SF_FORMAT_DWVW_12___27 = 64,
    SF_FORMAT_DWVW_16___27 = 65,
    SF_FORMAT_DWVW_24___27 = 66,
    SF_FORMAT_DWVW_N___27 = 67,
    SF_FORMAT_DPCM_8___27 = 80,
    SF_FORMAT_DPCM_16___27 = 81,
    SF_FORMAT_VORBIS___27 = 96,
    SF_ENDIAN_FILE___27 = 0,
    SF_ENDIAN_LITTLE___27 = 268435456,
    SF_ENDIAN_BIG___27 = 536870912,
    SF_ENDIAN_CPU___27 = 805306368,
    SF_FORMAT_SUBMASK___27 = 65535,
    SF_FORMAT_TYPEMASK___27 = 268369920,
    SF_FORMAT_ENDMASK___27 = 805306368
} ;
#line 126
enum __anonenum__525___2 {
    SFC_GET_LIB_VERSION___27 = 4096,
    SFC_GET_LOG_INFO___27 = 4097,
    SFC_GET_CURRENT_SF_INFO___27 = 4098,
    SFC_GET_NORM_DOUBLE___27 = 4112,
    SFC_GET_NORM_FLOAT___27 = 4113,
    SFC_SET_NORM_DOUBLE___27 = 4114,
    SFC_SET_NORM_FLOAT___27 = 4115,
    SFC_SET_SCALE_FLOAT_INT_READ___27 = 4116,
    SFC_SET_SCALE_INT_FLOAT_WRITE___27 = 4117,
    SFC_GET_SIMPLE_FORMAT_COUNT___27 = 4128,
    SFC_GET_SIMPLE_FORMAT___27 = 4129,
    SFC_GET_FORMAT_INFO___27 = 4136,
    SFC_GET_FORMAT_MAJOR_COUNT___27 = 4144,
    SFC_GET_FORMAT_MAJOR___27 = 4145,
    SFC_GET_FORMAT_SUBTYPE_COUNT___27 = 4146,
    SFC_GET_FORMAT_SUBTYPE___27 = 4147,
    SFC_CALC_SIGNAL_MAX___27 = 4160,
    SFC_CALC_NORM_SIGNAL_MAX___27 = 4161,
    SFC_CALC_MAX_ALL_CHANNELS___27 = 4162,
    SFC_CALC_NORM_MAX_ALL_CHANNELS___27 = 4163,
    SFC_GET_SIGNAL_MAX___27 = 4164,
    SFC_GET_MAX_ALL_CHANNELS___27 = 4165,
    SFC_SET_ADD_PEAK_CHUNK___27 = 4176,
    SFC_SET_ADD_HEADER_PAD_CHUNK___27 = 4177,
    SFC_UPDATE_HEADER_NOW___27 = 4192,
    SFC_SET_UPDATE_HEADER_AUTO___27 = 4193,
    SFC_FILE_TRUNCATE___27 = 4224,
    SFC_SET_RAW_START_OFFSET___27 = 4240,
    SFC_SET_DITHER_ON_WRITE___27 = 4256,
    SFC_SET_DITHER_ON_READ___27 = 4257,
    SFC_GET_DITHER_INFO_COUNT___27 = 4258,
    SFC_GET_DITHER_INFO___27 = 4259,
    SFC_GET_EMBED_FILE_INFO___27 = 4272,
    SFC_SET_CLIPPING___27 = 4288,
    SFC_GET_CLIPPING___27 = 4289,
    SFC_GET_INSTRUMENT___27 = 4304,
    SFC_SET_INSTRUMENT___27 = 4305,
    SFC_GET_LOOP_INFO___27 = 4320,
    SFC_GET_BROADCAST_INFO___27 = 4336,
    SFC_SET_BROADCAST_INFO___27 = 4337,
    SFC_GET_CHANNEL_MAP_INFO___27 = 4352,
    SFC_SET_CHANNEL_MAP_INFO___27 = 4353,
    SFC_RAW_DATA_NEEDS_ENDSWAP___27 = 4368,
    SFC_WAVEX_SET_AMBISONIC___27 = 4608,
    SFC_WAVEX_GET_AMBISONIC___27 = 4609,
    SFC_SET_VBR_ENCODING_QUALITY___27 = 4864,
    SFC_TEST_IEEE_FLOAT_REPLACE___27 = 24577,
    SFC_SET_ADD_DITHER_ON_WRITE___27 = 4208,
    SFC_SET_ADD_DITHER_ON_READ___27 = 4209
} ;
#line 216
enum __anonenum__526___2 {
    SF_STR_TITLE___27 = 1,
    SF_STR_COPYRIGHT___27 = 2,
    SF_STR_SOFTWARE___27 = 3,
    SF_STR_ARTIST___27 = 4,
    SF_STR_COMMENT___27 = 5,
    SF_STR_DATE___27 = 6,
    SF_STR_ALBUM___27 = 7,
    SF_STR_LICENSE___27 = 8
} ;
#line 235
enum __anonenum__527___2 {
    SF_FALSE___27 = 0,
    SF_TRUE___27 = 1,
    SFM_READ___27 = 16,
    SFM_WRITE___27 = 32,
    SFM_RDWR___27 = 48,
    SF_AMBISONIC_NONE___27 = 64,
    SF_AMBISONIC_B_FORMAT___27 = 65
} ;
#line 255
enum __anonenum__528___2 {
    SF_ERR_NO_ERROR___27 = 0,
    SF_ERR_UNRECOGNISED_FORMAT___27 = 1,
    SF_ERR_SYSTEM___27 = 2,
    SF_ERR_MALFORMED_FILE___27 = 3,
    SF_ERR_UNSUPPORTED_ENCODING___27 = 4
} ;
#line 267
enum __anonenum__529___2 {
    SF_CHANNEL_MAP_INVALID___27 = 0,
    SF_CHANNEL_MAP_MONO___27 = 1,
    SF_CHANNEL_MAP_LEFT___27 = 2,
    SF_CHANNEL_MAP_RIGHT___27 = 3,
    SF_CHANNEL_MAP_CENTER___27 = 4,
    SF_CHANNEL_MAP_FRONT_LEFT___27 = 5,
    SF_CHANNEL_MAP_FRONT_RIGHT___27 = 6,
    SF_CHANNEL_MAP_FRONT_CENTER___27 = 7,
    SF_CHANNEL_MAP_REAR_CENTER___27 = 8,
    SF_CHANNEL_MAP_REAR_LEFT___27 = 9,
    SF_CHANNEL_MAP_REAR_RIGHT___27 = 10,
    SF_CHANNEL_MAP_LFE___27 = 11,
    SF_CHANNEL_MAP_FRONT_LEFT_OF_CENTER___27 = 12,
    SF_CHANNEL_MAP_FRONT_RIGHT_OF_CENTER___27 = 13,
    SF_CHANNEL_MAP_SIDE_LEFT___27 = 14,
    SF_CHANNEL_MAP_SIDE_RIGHT___27 = 15,
    SF_CHANNEL_MAP_TOP_CENTER___27 = 16,
    SF_CHANNEL_MAP_TOP_FRONT_LEFT___27 = 17,
    SF_CHANNEL_MAP_TOP_FRONT_RIGHT___27 = 18,
    SF_CHANNEL_MAP_TOP_FRONT_CENTER___27 = 19,
    SF_CHANNEL_MAP_TOP_REAR_LEFT___27 = 20,
    SF_CHANNEL_MAP_TOP_REAR_RIGHT___27 = 21,
    SF_CHANNEL_MAP_TOP_REAR_CENTER___27 = 22
} ;
#line 352
enum __anonenum__531___2 {
    SFD_DEFAULT_LEVEL___27 = 0,
    SFD_CUSTOM_LEVEL___27 = 1073741824,
    SFD_NO_DITHER___27 = 500,
    SFD_WHITE___27 = 501,
    SFD_TRIANGULAR_PDF___27 = 502
} ;
#line 380
enum __anonenum__534___2 {
    SF_LOOP_NONE___27 = 800,
    SF_LOOP_FORWARD___27 = 801,
    SF_LOOP_BACKWARD___27 = 802,
    SF_LOOP_ALTERNATING___27 = 803
} ;
#line 121 "/root/libsndfile/src/common.h"
enum __anonenum__543___2 {
    SF_PEAK_START___27 = 42,
    SF_PEAK_END___27 = 43,
    SF_SCALE_MAX___27 = 52,
    SF_SCALE_MIN___27 = 53,
    SF_STR_ALLOW_START___27 = 256,
    SF_STR_ALLOW_END___27 = 512,
    SF_STR_LOCATE_START___27 = 1024,
    SF_STR_LOCATE_END___27 = 2048,
    SFD_TYPEMASK___27 = 268435455
} ;
#line 149
enum __anonenum__544___2 {
    SF_FORMAT_TXW___27 = 67305472,
    SF_FORMAT_DWD___27 = 67371008,
    SF_FORMAT_REX___27 = 67764224,
    SF_FORMAT_REX2___27 = 67960832,
    SF_FORMAT_KRZ___27 = 68026368,
    SF_FORMAT_WMA___27 = 68157440,
    SF_FORMAT_SHN___27 = 68222976,
    SF_FORMAT_SVX_FIB___27 = 4128,
    SF_FORMAT_SVX_EXP___27 = 4129,
    SF_FORMAT_PCM_N___27 = 4144
} ;
#line 405
enum __anonenum__550___2 {
    SFE_NO_ERROR___27 = 0,
    SFE_BAD_OPEN_FORMAT___27 = 1,
    SFE_SYSTEM___27 = 2,
    SFE_MALFORMED_FILE___27 = 3,
    SFE_UNSUPPORTED_ENCODING___27 = 4,
    SFE_ZERO_MAJOR_FORMAT___27 = 5,
    SFE_ZERO_MINOR_FORMAT___27 = 6,
    SFE_BAD_FILE___27 = 7,
    SFE_BAD_FILE_READ___27 = 8,
    SFE_OPEN_FAILED___27 = 9,
    SFE_BAD_SNDFILE_PTR___27 = 10,
    SFE_BAD_SF_INFO_PTR___27 = 11,
    SFE_BAD_SF_INCOMPLETE___27 = 12,
    SFE_BAD_FILE_PTR___27 = 13,
    SFE_BAD_INT_PTR___27 = 14,
    SFE_BAD_STAT_SIZE___27 = 15,
    SFE_MALLOC_FAILED___27 = 16,
    SFE_UNIMPLEMENTED___27 = 17,
    SFE_BAD_READ_ALIGN___27 = 18,
    SFE_BAD_WRITE_ALIGN___27 = 19,
    SFE_UNKNOWN_FORMAT___27 = 20,
    SFE_NOT_READMODE___27 = 21,
    SFE_NOT_WRITEMODE___27 = 22,
    SFE_BAD_MODE_RW___27 = 23,
    SFE_BAD_SF_INFO___27 = 24,
    SFE_BAD_OFFSET___27 = 25,
    SFE_NO_EMBED_SUPPORT___27 = 26,
    SFE_NO_EMBEDDED_RDWR___27 = 27,
    SFE_NO_PIPE_WRITE___27 = 28,
    SFE_INTERNAL___27 = 29,
    SFE_BAD_COMMAND_PARAM___27 = 30,
    SFE_BAD_ENDIAN___27 = 31,
    SFE_CHANNEL_COUNT_ZERO___27 = 32,
    SFE_CHANNEL_COUNT___27 = 33,
    SFE_BAD_VIRTUAL_IO___27 = 34,
    SFE_INTERLEAVE_MODE___27 = 35,
    SFE_INTERLEAVE_SEEK___27 = 36,
    SFE_INTERLEAVE_READ___27 = 37,
    SFE_BAD_SEEK___27 = 38,
    SFE_NOT_SEEKABLE___27 = 39,
    SFE_AMBIGUOUS_SEEK___27 = 40,
    SFE_WRONG_SEEK___27 = 41,
    SFE_SEEK_FAILED___27 = 42,
    SFE_BAD_OPEN_MODE___27 = 43,
    SFE_OPEN_PIPE_RDWR___27 = 44,
    SFE_RDWR_POSITION___27 = 45,
    SFE_RDWR_BAD_HEADER___27 = 46,
    SFE_CMD_HAS_DATA___27 = 47,
    SFE_BAD_BROADCAST_INFO_SIZE___27 = 48,
    SFE_STR_NO_SUPPORT___27 = 49,
    SFE_STR_NOT_WRITE___27 = 50,
    SFE_STR_MAX_DATA___27 = 51,
    SFE_STR_MAX_COUNT___27 = 52,
    SFE_STR_BAD_TYPE___27 = 53,
    SFE_STR_NO_ADD_END___27 = 54,
    SFE_STR_BAD_STRING___27 = 55,
    SFE_STR_WEIRD___27 = 56,
    SFE_WAV_NO_RIFF___27 = 57,
    SFE_WAV_NO_WAVE___27 = 58,
    SFE_WAV_NO_FMT___27 = 59,
    SFE_WAV_BAD_FMT___27 = 60,
    SFE_WAV_FMT_SHORT___27 = 61,
    SFE_WAV_BAD_FACT___27 = 62,
    SFE_WAV_BAD_PEAK___27 = 63,
    SFE_WAV_PEAK_B4_FMT___27 = 64,
    SFE_WAV_BAD_FORMAT___27 = 65,
    SFE_WAV_BAD_BLOCKALIGN___27 = 66,
    SFE_WAV_NO_DATA___27 = 67,
    SFE_WAV_BAD_LIST___27 = 68,
    SFE_WAV_ADPCM_NOT4BIT___27 = 69,
    SFE_WAV_ADPCM_CHANNELS___27 = 70,
    SFE_WAV_GSM610_FORMAT___27 = 71,
    SFE_WAV_UNKNOWN_CHUNK___27 = 72,
    SFE_WAV_WVPK_DATA___27 = 73,
    SFE_AIFF_NO_FORM___27 = 74,
    SFE_AIFF_AIFF_NO_FORM___27 = 75,
    SFE_AIFF_COMM_NO_FORM___27 = 76,
    SFE_AIFF_SSND_NO_COMM___27 = 77,
    SFE_AIFF_UNKNOWN_CHUNK___27 = 78,
    SFE_AIFF_COMM_CHUNK_SIZE___27 = 79,
    SFE_AIFF_BAD_COMM_CHUNK___27 = 80,
    SFE_AIFF_PEAK_B4_COMM___27 = 81,
    SFE_AIFF_BAD_PEAK___27 = 82,
    SFE_AIFF_NO_SSND___27 = 83,
    SFE_AIFF_NO_DATA___27 = 84,
    SFE_AIFF_RW_SSND_NOT_LAST___27 = 85,
    SFE_AU_UNKNOWN_FORMAT___27 = 86,
    SFE_AU_NO_DOTSND___27 = 87,
    SFE_AU_EMBED_BAD_LEN___27 = 88,
    SFE_RAW_READ_BAD_SPEC___27 = 89,
    SFE_RAW_BAD_BITWIDTH___27 = 90,
    SFE_RAW_BAD_FORMAT___27 = 91,
    SFE_PAF_NO_MARKER___27 = 92,
    SFE_PAF_VERSION___27 = 93,
    SFE_PAF_UNKNOWN_FORMAT___27 = 94,
    SFE_PAF_SHORT_HEADER___27 = 95,
    SFE_SVX_NO_FORM___27 = 96,
    SFE_SVX_NO_BODY___27 = 97,
    SFE_SVX_NO_DATA___27 = 98,
    SFE_SVX_BAD_COMP___27 = 99,
    SFE_SVX_BAD_NAME_LENGTH___27 = 100,
    SFE_NIST_BAD_HEADER___27 = 101,
    SFE_NIST_CRLF_CONVERISON___27 = 102,
    SFE_NIST_BAD_ENCODING___27 = 103,
    SFE_VOC_NO_CREATIVE___27 = 104,
    SFE_VOC_BAD_FORMAT___27 = 105,
    SFE_VOC_BAD_VERSION___27 = 106,
    SFE_VOC_BAD_MARKER___27 = 107,
    SFE_VOC_BAD_SECTIONS___27 = 108,
    SFE_VOC_MULTI_SAMPLERATE___27 = 109,
    SFE_VOC_MULTI_SECTION___27 = 110,
    SFE_VOC_MULTI_PARAM___27 = 111,
    SFE_VOC_SECTION_COUNT___27 = 112,
    SFE_VOC_NO_PIPE___27 = 113,
    SFE_IRCAM_NO_MARKER___27 = 114,
    SFE_IRCAM_BAD_CHANNELS___27 = 115,
    SFE_IRCAM_UNKNOWN_FORMAT___27 = 116,
    SFE_W64_64_BIT___27 = 117,
    SFE_W64_NO_RIFF___27 = 118,
    SFE_W64_NO_WAVE___27 = 119,
    SFE_W64_NO_DATA___27 = 120,
    SFE_W64_ADPCM_NOT4BIT___27 = 121,
    SFE_W64_ADPCM_CHANNELS___27 = 122,
    SFE_W64_GSM610_FORMAT___27 = 123,
    SFE_MAT4_BAD_NAME___27 = 124,
    SFE_MAT4_NO_SAMPLERATE___27 = 125,
    SFE_MAT5_BAD_ENDIAN___27 = 126,
    SFE_MAT5_NO_BLOCK___27 = 127,
    SFE_MAT5_SAMPLE_RATE___27 = 128,
    SFE_PVF_NO_PVF1___27 = 129,
    SFE_PVF_BAD_HEADER___27 = 130,
    SFE_PVF_BAD_BITWIDTH___27 = 131,
    SFE_DWVW_BAD_BITWIDTH___27 = 132,
    SFE_G72X_NOT_MONO___27 = 133,
    SFE_XI_BAD_HEADER___27 = 134,
    SFE_XI_EXCESS_SAMPLES___27 = 135,
    SFE_XI_NO_PIPE___27 = 136,
    SFE_HTK_NO_PIPE___27 = 137,
    SFE_SDS_NOT_SDS___27 = 138,
    SFE_SDS_BAD_BIT_WIDTH___27 = 139,
    SFE_SD2_FD_DISALLOWED___27 = 140,
    SFE_SD2_BAD_DATA_OFFSET___27 = 141,
    SFE_SD2_BAD_MAP_OFFSET___27 = 142,
    SFE_SD2_BAD_DATA_LENGTH___27 = 143,
    SFE_SD2_BAD_MAP_LENGTH___27 = 144,
    SFE_SD2_BAD_RSRC___27 = 145,
    SFE_SD2_BAD_SAMPLE_SIZE___27 = 146,
    SFE_FLAC_BAD_HEADER___27 = 147,
    SFE_FLAC_NEW_DECODER___27 = 148,
    SFE_FLAC_INIT_DECODER___27 = 149,
    SFE_FLAC_LOST_SYNC___27 = 150,
    SFE_FLAC_BAD_SAMPLE_RATE___27 = 151,
    SFE_FLAC_UNKOWN_ERROR___27 = 152,
    SFE_WVE_NOT_WVE___27 = 153,
    SFE_WVE_NO_PIPE___27 = 154,
    SFE_VORBIS_ENCODER_BUG___27 = 155,
    SFE_RF64_NOT_RF64___27 = 156,
    SFE_MAX_ERROR___27 = 157
} ;
#line 823
enum __anonenum__554___2 {
    SFC_TEST_AIFF_ADD_INST_CHUNK___27 = 8192,
    SFC_TEST_WAV_ADD_INFO_CHUNK___27 = 8208
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__437___1 {
    _ISupper___8 = 256,
    _ISlower___8 = 512,
    _ISalpha___8 = 1024,
    _ISdigit___8 = 2048,
    _ISxdigit___8 = 4096,
    _ISspace___8 = 8192,
    _ISprint___8 = 16384,
    _ISgraph___8 = 32768,
    _ISblank___8 = 1,
    _IScntrl___8 = 2,
    _ISpunct___8 = 4,
    _ISalnum___8 = 8
} ;
#line 46 "/root/libsndfile/src/sndfile.h"
enum __anonenum__742 {
    SF_FORMAT_WAV___28 = 65536,
    SF_FORMAT_AIFF___28 = 131072,
    SF_FORMAT_AU___28 = 196608,
    SF_FORMAT_RAW___28 = 262144,
    SF_FORMAT_PAF___28 = 327680,
    SF_FORMAT_SVX___28 = 393216,
    SF_FORMAT_NIST___28 = 458752,
    SF_FORMAT_VOC___28 = 524288,
    SF_FORMAT_IRCAM___28 = 655360,
    SF_FORMAT_W64___28 = 720896,
    SF_FORMAT_MAT4___28 = 786432,
    SF_FORMAT_MAT5___28 = 851968,
    SF_FORMAT_PVF___28 = 917504,
    SF_FORMAT_XI___28 = 983040,
    SF_FORMAT_HTK___28 = 1048576,
    SF_FORMAT_SDS___28 = 1114112,
    SF_FORMAT_AVR___28 = 1179648,
    SF_FORMAT_WAVEX___28 = 1245184,
    SF_FORMAT_SD2___28 = 1441792,
    SF_FORMAT_FLAC___28 = 1507328,
    SF_FORMAT_CAF___28 = 1572864,
    SF_FORMAT_WVE___28 = 1638400,
    SF_FORMAT_OGG___28 = 2097152,
    SF_FORMAT_MPC2K___28 = 2162688,
    SF_FORMAT_RF64___28 = 2228224,
    SF_FORMAT_PCM_S8___28 = 1,
    SF_FORMAT_PCM_16___28 = 2,
    SF_FORMAT_PCM_24___28 = 3,
    SF_FORMAT_PCM_32___28 = 4,
    SF_FORMAT_PCM_U8___28 = 5,
    SF_FORMAT_FLOAT___28 = 6,
    SF_FORMAT_DOUBLE___28 = 7,
    SF_FORMAT_ULAW___28 = 16,
    SF_FORMAT_ALAW___28 = 17,
    SF_FORMAT_IMA_ADPCM___28 = 18,
    SF_FORMAT_MS_ADPCM___28 = 19,
    SF_FORMAT_GSM610___28 = 32,
    SF_FORMAT_VOX_ADPCM___28 = 33,
    SF_FORMAT_G721_32___28 = 48,
    SF_FORMAT_G723_24___28 = 49,
    SF_FORMAT_G723_40___28 = 50,
    SF_FORMAT_DWVW_12___28 = 64,
    SF_FORMAT_DWVW_16___28 = 65,
    SF_FORMAT_DWVW_24___28 = 66,
    SF_FORMAT_DWVW_N___28 = 67,
    SF_FORMAT_DPCM_8___28 = 80,
    SF_FORMAT_DPCM_16___28 = 81,
    SF_FORMAT_VORBIS___28 = 96,
    SF_ENDIAN_FILE___28 = 0,
    SF_ENDIAN_LITTLE___28 = 268435456,
    SF_ENDIAN_BIG___28 = 536870912,
    SF_ENDIAN_CPU___28 = 805306368,
    SF_FORMAT_SUBMASK___28 = 65535,
    SF_FORMAT_TYPEMASK___28 = 268369920,
    SF_FORMAT_ENDMASK___28 = 805306368
} ;
#line 126
enum __anonenum__743 {
    SFC_GET_LIB_VERSION___28 = 4096,
    SFC_GET_LOG_INFO___28 = 4097,
    SFC_GET_CURRENT_SF_INFO___28 = 4098,
    SFC_GET_NORM_DOUBLE___28 = 4112,
    SFC_GET_NORM_FLOAT___28 = 4113,
    SFC_SET_NORM_DOUBLE___28 = 4114,
    SFC_SET_NORM_FLOAT___28 = 4115,
    SFC_SET_SCALE_FLOAT_INT_READ___28 = 4116,
    SFC_SET_SCALE_INT_FLOAT_WRITE___28 = 4117,
    SFC_GET_SIMPLE_FORMAT_COUNT___28 = 4128,
    SFC_GET_SIMPLE_FORMAT___28 = 4129,
    SFC_GET_FORMAT_INFO___28 = 4136,
    SFC_GET_FORMAT_MAJOR_COUNT___28 = 4144,
    SFC_GET_FORMAT_MAJOR___28 = 4145,
    SFC_GET_FORMAT_SUBTYPE_COUNT___28 = 4146,
    SFC_GET_FORMAT_SUBTYPE___28 = 4147,
    SFC_CALC_SIGNAL_MAX___28 = 4160,
    SFC_CALC_NORM_SIGNAL_MAX___28 = 4161,
    SFC_CALC_MAX_ALL_CHANNELS___28 = 4162,
    SFC_CALC_NORM_MAX_ALL_CHANNELS___28 = 4163,
    SFC_GET_SIGNAL_MAX___28 = 4164,
    SFC_GET_MAX_ALL_CHANNELS___28 = 4165,
    SFC_SET_ADD_PEAK_CHUNK___28 = 4176,
    SFC_SET_ADD_HEADER_PAD_CHUNK___28 = 4177,
    SFC_UPDATE_HEADER_NOW___28 = 4192,
    SFC_SET_UPDATE_HEADER_AUTO___28 = 4193,
    SFC_FILE_TRUNCATE___28 = 4224,
    SFC_SET_RAW_START_OFFSET___28 = 4240,
    SFC_SET_DITHER_ON_WRITE___28 = 4256,
    SFC_SET_DITHER_ON_READ___28 = 4257,
    SFC_GET_DITHER_INFO_COUNT___28 = 4258,
    SFC_GET_DITHER_INFO___28 = 4259,
    SFC_GET_EMBED_FILE_INFO___28 = 4272,
    SFC_SET_CLIPPING___28 = 4288,
    SFC_GET_CLIPPING___28 = 4289,
    SFC_GET_INSTRUMENT___28 = 4304,
    SFC_SET_INSTRUMENT___28 = 4305,
    SFC_GET_LOOP_INFO___28 = 4320,
    SFC_GET_BROADCAST_INFO___28 = 4336,
    SFC_SET_BROADCAST_INFO___28 = 4337,
    SFC_GET_CHANNEL_MAP_INFO___28 = 4352,
    SFC_SET_CHANNEL_MAP_INFO___28 = 4353,
    SFC_RAW_DATA_NEEDS_ENDSWAP___28 = 4368,
    SFC_WAVEX_SET_AMBISONIC___28 = 4608,
    SFC_WAVEX_GET_AMBISONIC___28 = 4609,
    SFC_SET_VBR_ENCODING_QUALITY___28 = 4864,
    SFC_TEST_IEEE_FLOAT_REPLACE___28 = 24577,
    SFC_SET_ADD_DITHER_ON_WRITE___28 = 4208,
    SFC_SET_ADD_DITHER_ON_READ___28 = 4209
} ;
#line 216
enum __anonenum__744 {
    SF_STR_TITLE___28 = 1,
    SF_STR_COPYRIGHT___28 = 2,
    SF_STR_SOFTWARE___28 = 3,
    SF_STR_ARTIST___28 = 4,
    SF_STR_COMMENT___28 = 5,
    SF_STR_DATE___28 = 6,
    SF_STR_ALBUM___28 = 7,
    SF_STR_LICENSE___28 = 8
} ;
#line 235
enum __anonenum__745 {
    SF_FALSE___28 = 0,
    SF_TRUE___28 = 1,
    SFM_READ___28 = 16,
    SFM_WRITE___28 = 32,
    SFM_RDWR___28 = 48,
    SF_AMBISONIC_NONE___28 = 64,
    SF_AMBISONIC_B_FORMAT___28 = 65
} ;
#line 255
enum __anonenum__746 {
    SF_ERR_NO_ERROR___28 = 0,
    SF_ERR_UNRECOGNISED_FORMAT___28 = 1,
    SF_ERR_SYSTEM___28 = 2,
    SF_ERR_MALFORMED_FILE___28 = 3,
    SF_ERR_UNSUPPORTED_ENCODING___28 = 4
} ;
#line 267
enum __anonenum__747 {
    SF_CHANNEL_MAP_INVALID___28 = 0,
    SF_CHANNEL_MAP_MONO___28 = 1,
    SF_CHANNEL_MAP_LEFT___28 = 2,
    SF_CHANNEL_MAP_RIGHT___28 = 3,
    SF_CHANNEL_MAP_CENTER___28 = 4,
    SF_CHANNEL_MAP_FRONT_LEFT___28 = 5,
    SF_CHANNEL_MAP_FRONT_RIGHT___28 = 6,
    SF_CHANNEL_MAP_FRONT_CENTER___28 = 7,
    SF_CHANNEL_MAP_REAR_CENTER___28 = 8,
    SF_CHANNEL_MAP_REAR_LEFT___28 = 9,
    SF_CHANNEL_MAP_REAR_RIGHT___28 = 10,
    SF_CHANNEL_MAP_LFE___28 = 11,
    SF_CHANNEL_MAP_FRONT_LEFT_OF_CENTER___28 = 12,
    SF_CHANNEL_MAP_FRONT_RIGHT_OF_CENTER___28 = 13,
    SF_CHANNEL_MAP_SIDE_LEFT___28 = 14,
    SF_CHANNEL_MAP_SIDE_RIGHT___28 = 15,
    SF_CHANNEL_MAP_TOP_CENTER___28 = 16,
    SF_CHANNEL_MAP_TOP_FRONT_LEFT___28 = 17,
    SF_CHANNEL_MAP_TOP_FRONT_RIGHT___28 = 18,
    SF_CHANNEL_MAP_TOP_FRONT_CENTER___28 = 19,
    SF_CHANNEL_MAP_TOP_REAR_LEFT___28 = 20,
    SF_CHANNEL_MAP_TOP_REAR_RIGHT___28 = 21,
    SF_CHANNEL_MAP_TOP_REAR_CENTER___28 = 22
} ;
#line 352
enum __anonenum__749 {
    SFD_DEFAULT_LEVEL___28 = 0,
    SFD_CUSTOM_LEVEL___28 = 1073741824,
    SFD_NO_DITHER___28 = 500,
    SFD_WHITE___28 = 501,
    SFD_TRIANGULAR_PDF___28 = 502
} ;
#line 380
enum __anonenum__752 {
    SF_LOOP_NONE___28 = 800,
    SF_LOOP_FORWARD___28 = 801,
    SF_LOOP_BACKWARD___28 = 802,
    SF_LOOP_ALTERNATING___28 = 803
} ;
#line 121 "/root/libsndfile/src/common.h"
enum __anonenum__761 {
    SF_PEAK_START___28 = 42,
    SF_PEAK_END___28 = 43,
    SF_SCALE_MAX___28 = 52,
    SF_SCALE_MIN___28 = 53,
    SF_STR_ALLOW_START___28 = 256,
    SF_STR_ALLOW_END___28 = 512,
    SF_STR_LOCATE_START___28 = 1024,
    SF_STR_LOCATE_END___28 = 2048,
    SFD_TYPEMASK___28 = 268435455
} ;
#line 149
enum __anonenum__762 {
    SF_FORMAT_TXW___28 = 67305472,
    SF_FORMAT_DWD___28 = 67371008,
    SF_FORMAT_REX___28 = 67764224,
    SF_FORMAT_REX2___28 = 67960832,
    SF_FORMAT_KRZ___28 = 68026368,
    SF_FORMAT_WMA___28 = 68157440,
    SF_FORMAT_SHN___28 = 68222976,
    SF_FORMAT_SVX_FIB___28 = 4128,
    SF_FORMAT_SVX_EXP___28 = 4129,
    SF_FORMAT_PCM_N___28 = 4144
} ;
#line 405
enum __anonenum__768 {
    SFE_NO_ERROR___28 = 0,
    SFE_BAD_OPEN_FORMAT___28 = 1,
    SFE_SYSTEM___28 = 2,
    SFE_MALFORMED_FILE___28 = 3,
    SFE_UNSUPPORTED_ENCODING___28 = 4,
    SFE_ZERO_MAJOR_FORMAT___28 = 5,
    SFE_ZERO_MINOR_FORMAT___28 = 6,
    SFE_BAD_FILE___28 = 7,
    SFE_BAD_FILE_READ___28 = 8,
    SFE_OPEN_FAILED___28 = 9,
    SFE_BAD_SNDFILE_PTR___28 = 10,
    SFE_BAD_SF_INFO_PTR___28 = 11,
    SFE_BAD_SF_INCOMPLETE___28 = 12,
    SFE_BAD_FILE_PTR___28 = 13,
    SFE_BAD_INT_PTR___28 = 14,
    SFE_BAD_STAT_SIZE___28 = 15,
    SFE_MALLOC_FAILED___28 = 16,
    SFE_UNIMPLEMENTED___28 = 17,
    SFE_BAD_READ_ALIGN___28 = 18,
    SFE_BAD_WRITE_ALIGN___28 = 19,
    SFE_UNKNOWN_FORMAT___28 = 20,
    SFE_NOT_READMODE___28 = 21,
    SFE_NOT_WRITEMODE___28 = 22,
    SFE_BAD_MODE_RW___28 = 23,
    SFE_BAD_SF_INFO___28 = 24,
    SFE_BAD_OFFSET___28 = 25,
    SFE_NO_EMBED_SUPPORT___28 = 26,
    SFE_NO_EMBEDDED_RDWR___28 = 27,
    SFE_NO_PIPE_WRITE___28 = 28,
    SFE_INTERNAL___28 = 29,
    SFE_BAD_COMMAND_PARAM___28 = 30,
    SFE_BAD_ENDIAN___28 = 31,
    SFE_CHANNEL_COUNT_ZERO___28 = 32,
    SFE_CHANNEL_COUNT___28 = 33,
    SFE_BAD_VIRTUAL_IO___28 = 34,
    SFE_INTERLEAVE_MODE___28 = 35,
    SFE_INTERLEAVE_SEEK___28 = 36,
    SFE_INTERLEAVE_READ___28 = 37,
    SFE_BAD_SEEK___28 = 38,
    SFE_NOT_SEEKABLE___28 = 39,
    SFE_AMBIGUOUS_SEEK___28 = 40,
    SFE_WRONG_SEEK___28 = 41,
    SFE_SEEK_FAILED___28 = 42,
    SFE_BAD_OPEN_MODE___28 = 43,
    SFE_OPEN_PIPE_RDWR___28 = 44,
    SFE_RDWR_POSITION___28 = 45,
    SFE_RDWR_BAD_HEADER___28 = 46,
    SFE_CMD_HAS_DATA___28 = 47,
    SFE_BAD_BROADCAST_INFO_SIZE___28 = 48,
    SFE_STR_NO_SUPPORT___28 = 49,
    SFE_STR_NOT_WRITE___28 = 50,
    SFE_STR_MAX_DATA___28 = 51,
    SFE_STR_MAX_COUNT___28 = 52,
    SFE_STR_BAD_TYPE___28 = 53,
    SFE_STR_NO_ADD_END___28 = 54,
    SFE_STR_BAD_STRING___28 = 55,
    SFE_STR_WEIRD___28 = 56,
    SFE_WAV_NO_RIFF___28 = 57,
    SFE_WAV_NO_WAVE___28 = 58,
    SFE_WAV_NO_FMT___28 = 59,
    SFE_WAV_BAD_FMT___28 = 60,
    SFE_WAV_FMT_SHORT___28 = 61,
    SFE_WAV_BAD_FACT___28 = 62,
    SFE_WAV_BAD_PEAK___28 = 63,
    SFE_WAV_PEAK_B4_FMT___28 = 64,
    SFE_WAV_BAD_FORMAT___28 = 65,
    SFE_WAV_BAD_BLOCKALIGN___28 = 66,
    SFE_WAV_NO_DATA___28 = 67,
    SFE_WAV_BAD_LIST___28 = 68,
    SFE_WAV_ADPCM_NOT4BIT___28 = 69,
    SFE_WAV_ADPCM_CHANNELS___28 = 70,
    SFE_WAV_GSM610_FORMAT___28 = 71,
    SFE_WAV_UNKNOWN_CHUNK___28 = 72,
    SFE_WAV_WVPK_DATA___28 = 73,
    SFE_AIFF_NO_FORM___28 = 74,
    SFE_AIFF_AIFF_NO_FORM___28 = 75,
    SFE_AIFF_COMM_NO_FORM___28 = 76,
    SFE_AIFF_SSND_NO_COMM___28 = 77,
    SFE_AIFF_UNKNOWN_CHUNK___28 = 78,
    SFE_AIFF_COMM_CHUNK_SIZE___28 = 79,
    SFE_AIFF_BAD_COMM_CHUNK___28 = 80,
    SFE_AIFF_PEAK_B4_COMM___28 = 81,
    SFE_AIFF_BAD_PEAK___28 = 82,
    SFE_AIFF_NO_SSND___28 = 83,
    SFE_AIFF_NO_DATA___28 = 84,
    SFE_AIFF_RW_SSND_NOT_LAST___28 = 85,
    SFE_AU_UNKNOWN_FORMAT___28 = 86,
    SFE_AU_NO_DOTSND___28 = 87,
    SFE_AU_EMBED_BAD_LEN___28 = 88,
    SFE_RAW_READ_BAD_SPEC___28 = 89,
    SFE_RAW_BAD_BITWIDTH___28 = 90,
    SFE_RAW_BAD_FORMAT___28 = 91,
    SFE_PAF_NO_MARKER___28 = 92,
    SFE_PAF_VERSION___28 = 93,
    SFE_PAF_UNKNOWN_FORMAT___28 = 94,
    SFE_PAF_SHORT_HEADER___28 = 95,
    SFE_SVX_NO_FORM___28 = 96,
    SFE_SVX_NO_BODY___28 = 97,
    SFE_SVX_NO_DATA___28 = 98,
    SFE_SVX_BAD_COMP___28 = 99,
    SFE_SVX_BAD_NAME_LENGTH___28 = 100,
    SFE_NIST_BAD_HEADER___28 = 101,
    SFE_NIST_CRLF_CONVERISON___28 = 102,
    SFE_NIST_BAD_ENCODING___28 = 103,
    SFE_VOC_NO_CREATIVE___28 = 104,
    SFE_VOC_BAD_FORMAT___28 = 105,
    SFE_VOC_BAD_VERSION___28 = 106,
    SFE_VOC_BAD_MARKER___28 = 107,
    SFE_VOC_BAD_SECTIONS___28 = 108,
    SFE_VOC_MULTI_SAMPLERATE___28 = 109,
    SFE_VOC_MULTI_SECTION___28 = 110,
    SFE_VOC_MULTI_PARAM___28 = 111,
    SFE_VOC_SECTION_COUNT___28 = 112,
    SFE_VOC_NO_PIPE___28 = 113,
    SFE_IRCAM_NO_MARKER___28 = 114,
    SFE_IRCAM_BAD_CHANNELS___28 = 115,
    SFE_IRCAM_UNKNOWN_FORMAT___28 = 116,
    SFE_W64_64_BIT___28 = 117,
    SFE_W64_NO_RIFF___28 = 118,
    SFE_W64_NO_WAVE___28 = 119,
    SFE_W64_NO_DATA___28 = 120,
    SFE_W64_ADPCM_NOT4BIT___28 = 121,
    SFE_W64_ADPCM_CHANNELS___28 = 122,
    SFE_W64_GSM610_FORMAT___28 = 123,
    SFE_MAT4_BAD_NAME___28 = 124,
    SFE_MAT4_NO_SAMPLERATE___28 = 125,
    SFE_MAT5_BAD_ENDIAN___28 = 126,
    SFE_MAT5_NO_BLOCK___28 = 127,
    SFE_MAT5_SAMPLE_RATE___28 = 128,
    SFE_PVF_NO_PVF1___28 = 129,
    SFE_PVF_BAD_HEADER___28 = 130,
    SFE_PVF_BAD_BITWIDTH___28 = 131,
    SFE_DWVW_BAD_BITWIDTH___28 = 132,
    SFE_G72X_NOT_MONO___28 = 133,
    SFE_XI_BAD_HEADER___28 = 134,
    SFE_XI_EXCESS_SAMPLES___28 = 135,
    SFE_XI_NO_PIPE___28 = 136,
    SFE_HTK_NO_PIPE___28 = 137,
    SFE_SDS_NOT_SDS___28 = 138,
    SFE_SDS_BAD_BIT_WIDTH___28 = 139,
    SFE_SD2_FD_DISALLOWED___28 = 140,
    SFE_SD2_BAD_DATA_OFFSET___28 = 141,
    SFE_SD2_BAD_MAP_OFFSET___28 = 142,
    SFE_SD2_BAD_DATA_LENGTH___28 = 143,
    SFE_SD2_BAD_MAP_LENGTH___28 = 144,
    SFE_SD2_BAD_RSRC___28 = 145,
    SFE_SD2_BAD_SAMPLE_SIZE___28 = 146,
    SFE_FLAC_BAD_HEADER___28 = 147,
    SFE_FLAC_NEW_DECODER___28 = 148,
    SFE_FLAC_INIT_DECODER___28 = 149,
    SFE_FLAC_LOST_SYNC___28 = 150,
    SFE_FLAC_BAD_SAMPLE_RATE___28 = 151,
    SFE_FLAC_UNKOWN_ERROR___28 = 152,
    SFE_WVE_NOT_WVE___28 = 153,
    SFE_WVE_NO_PIPE___28 = 154,
    SFE_VORBIS_ENCODER_BUG___28 = 155,
    SFE_RF64_NOT_RF64___28 = 156,
    SFE_MAX_ERROR___28 = 157
} ;
#line 823
enum __anonenum__772 {
    SFC_TEST_AIFF_ADD_INST_CHUNK___28 = 8192,
    SFC_TEST_WAV_ADD_INFO_CHUNK___28 = 8208
} ;
#line 54 "/root/libsndfile/src/svx.c"
struct __anonstruct_773 {
   unsigned int oneShotHiSamples ;
   unsigned int repeatHiSamples ;
   unsigned int samplesPerHiCycle ;
   unsigned short samplesPerSec ;
   unsigned char octave ;
   unsigned char compression ;
   unsigned int volume ;
};
#line 59 "/root/libsndfile/src/svx.c"
typedef struct __anonstruct_773 VHDR_CHUNK;
#line 61
enum __anonenum__774 {
    HAVE_FORM = 1,
    HAVE_SVX = 2,
    HAVE_VHDR = 4,
    HAVE_BODY = 8
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__568___0 {
    _ISupper___9 = 256,
    _ISlower___9 = 512,
    _ISalpha___9 = 1024,
    _ISdigit___9 = 2048,
    _ISxdigit___9 = 4096,
    _ISspace___9 = 8192,
    _ISprint___9 = 16384,
    _ISgraph___9 = 32768,
    _ISblank___9 = 1,
    _IScntrl___9 = 2,
    _ISpunct___9 = 4,
    _ISalnum___9 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__569___0 {
    FP_NAN___13 = 0,
    FP_INFINITE___13 = 1,
    FP_ZERO___13 = 2,
    FP_SUBNORMAL___13 = 3,
    FP_NORMAL___13 = 4
} ;
#line 46 "/root/libsndfile/src/sndfile.h"
enum __anonenum__570___0 {
    SF_FORMAT_WAV___29 = 65536,
    SF_FORMAT_AIFF___29 = 131072,
    SF_FORMAT_AU___29 = 196608,
    SF_FORMAT_RAW___29 = 262144,
    SF_FORMAT_PAF___29 = 327680,
    SF_FORMAT_SVX___29 = 393216,
    SF_FORMAT_NIST___29 = 458752,
    SF_FORMAT_VOC___29 = 524288,
    SF_FORMAT_IRCAM___29 = 655360,
    SF_FORMAT_W64___29 = 720896,
    SF_FORMAT_MAT4___29 = 786432,
    SF_FORMAT_MAT5___29 = 851968,
    SF_FORMAT_PVF___29 = 917504,
    SF_FORMAT_XI___29 = 983040,
    SF_FORMAT_HTK___29 = 1048576,
    SF_FORMAT_SDS___29 = 1114112,
    SF_FORMAT_AVR___29 = 1179648,
    SF_FORMAT_WAVEX___29 = 1245184,
    SF_FORMAT_SD2___29 = 1441792,
    SF_FORMAT_FLAC___29 = 1507328,
    SF_FORMAT_CAF___29 = 1572864,
    SF_FORMAT_WVE___29 = 1638400,
    SF_FORMAT_OGG___29 = 2097152,
    SF_FORMAT_MPC2K___29 = 2162688,
    SF_FORMAT_RF64___29 = 2228224,
    SF_FORMAT_PCM_S8___29 = 1,
    SF_FORMAT_PCM_16___29 = 2,
    SF_FORMAT_PCM_24___29 = 3,
    SF_FORMAT_PCM_32___29 = 4,
    SF_FORMAT_PCM_U8___29 = 5,
    SF_FORMAT_FLOAT___29 = 6,
    SF_FORMAT_DOUBLE___29 = 7,
    SF_FORMAT_ULAW___29 = 16,
    SF_FORMAT_ALAW___29 = 17,
    SF_FORMAT_IMA_ADPCM___29 = 18,
    SF_FORMAT_MS_ADPCM___29 = 19,
    SF_FORMAT_GSM610___29 = 32,
    SF_FORMAT_VOX_ADPCM___29 = 33,
    SF_FORMAT_G721_32___29 = 48,
    SF_FORMAT_G723_24___29 = 49,
    SF_FORMAT_G723_40___29 = 50,
    SF_FORMAT_DWVW_12___29 = 64,
    SF_FORMAT_DWVW_16___29 = 65,
    SF_FORMAT_DWVW_24___29 = 66,
    SF_FORMAT_DWVW_N___29 = 67,
    SF_FORMAT_DPCM_8___29 = 80,
    SF_FORMAT_DPCM_16___29 = 81,
    SF_FORMAT_VORBIS___29 = 96,
    SF_ENDIAN_FILE___29 = 0,
    SF_ENDIAN_LITTLE___29 = 268435456,
    SF_ENDIAN_BIG___29 = 536870912,
    SF_ENDIAN_CPU___29 = 805306368,
    SF_FORMAT_SUBMASK___29 = 65535,
    SF_FORMAT_TYPEMASK___29 = 268369920,
    SF_FORMAT_ENDMASK___29 = 805306368
} ;
#line 126
enum __anonenum__571___0 {
    SFC_GET_LIB_VERSION___29 = 4096,
    SFC_GET_LOG_INFO___29 = 4097,
    SFC_GET_CURRENT_SF_INFO___29 = 4098,
    SFC_GET_NORM_DOUBLE___29 = 4112,
    SFC_GET_NORM_FLOAT___29 = 4113,
    SFC_SET_NORM_DOUBLE___29 = 4114,
    SFC_SET_NORM_FLOAT___29 = 4115,
    SFC_SET_SCALE_FLOAT_INT_READ___29 = 4116,
    SFC_SET_SCALE_INT_FLOAT_WRITE___29 = 4117,
    SFC_GET_SIMPLE_FORMAT_COUNT___29 = 4128,
    SFC_GET_SIMPLE_FORMAT___29 = 4129,
    SFC_GET_FORMAT_INFO___29 = 4136,
    SFC_GET_FORMAT_MAJOR_COUNT___29 = 4144,
    SFC_GET_FORMAT_MAJOR___29 = 4145,
    SFC_GET_FORMAT_SUBTYPE_COUNT___29 = 4146,
    SFC_GET_FORMAT_SUBTYPE___29 = 4147,
    SFC_CALC_SIGNAL_MAX___29 = 4160,
    SFC_CALC_NORM_SIGNAL_MAX___29 = 4161,
    SFC_CALC_MAX_ALL_CHANNELS___29 = 4162,
    SFC_CALC_NORM_MAX_ALL_CHANNELS___29 = 4163,
    SFC_GET_SIGNAL_MAX___29 = 4164,
    SFC_GET_MAX_ALL_CHANNELS___29 = 4165,
    SFC_SET_ADD_PEAK_CHUNK___29 = 4176,
    SFC_SET_ADD_HEADER_PAD_CHUNK___29 = 4177,
    SFC_UPDATE_HEADER_NOW___29 = 4192,
    SFC_SET_UPDATE_HEADER_AUTO___29 = 4193,
    SFC_FILE_TRUNCATE___29 = 4224,
    SFC_SET_RAW_START_OFFSET___29 = 4240,
    SFC_SET_DITHER_ON_WRITE___29 = 4256,
    SFC_SET_DITHER_ON_READ___29 = 4257,
    SFC_GET_DITHER_INFO_COUNT___29 = 4258,
    SFC_GET_DITHER_INFO___29 = 4259,
    SFC_GET_EMBED_FILE_INFO___29 = 4272,
    SFC_SET_CLIPPING___29 = 4288,
    SFC_GET_CLIPPING___29 = 4289,
    SFC_GET_INSTRUMENT___29 = 4304,
    SFC_SET_INSTRUMENT___29 = 4305,
    SFC_GET_LOOP_INFO___29 = 4320,
    SFC_GET_BROADCAST_INFO___29 = 4336,
    SFC_SET_BROADCAST_INFO___29 = 4337,
    SFC_GET_CHANNEL_MAP_INFO___29 = 4352,
    SFC_SET_CHANNEL_MAP_INFO___29 = 4353,
    SFC_RAW_DATA_NEEDS_ENDSWAP___29 = 4368,
    SFC_WAVEX_SET_AMBISONIC___29 = 4608,
    SFC_WAVEX_GET_AMBISONIC___29 = 4609,
    SFC_SET_VBR_ENCODING_QUALITY___29 = 4864,
    SFC_TEST_IEEE_FLOAT_REPLACE___29 = 24577,
    SFC_SET_ADD_DITHER_ON_WRITE___29 = 4208,
    SFC_SET_ADD_DITHER_ON_READ___29 = 4209
} ;
#line 216
enum __anonenum__572___0 {
    SF_STR_TITLE___29 = 1,
    SF_STR_COPYRIGHT___29 = 2,
    SF_STR_SOFTWARE___29 = 3,
    SF_STR_ARTIST___29 = 4,
    SF_STR_COMMENT___29 = 5,
    SF_STR_DATE___29 = 6,
    SF_STR_ALBUM___29 = 7,
    SF_STR_LICENSE___29 = 8
} ;
#line 235
enum __anonenum__573___0 {
    SF_FALSE___29 = 0,
    SF_TRUE___29 = 1,
    SFM_READ___29 = 16,
    SFM_WRITE___29 = 32,
    SFM_RDWR___29 = 48,
    SF_AMBISONIC_NONE___29 = 64,
    SF_AMBISONIC_B_FORMAT___29 = 65
} ;
#line 255
enum __anonenum__574___0 {
    SF_ERR_NO_ERROR___29 = 0,
    SF_ERR_UNRECOGNISED_FORMAT___29 = 1,
    SF_ERR_SYSTEM___29 = 2,
    SF_ERR_MALFORMED_FILE___29 = 3,
    SF_ERR_UNSUPPORTED_ENCODING___29 = 4
} ;
#line 267
enum __anonenum__575___0 {
    SF_CHANNEL_MAP_INVALID___29 = 0,
    SF_CHANNEL_MAP_MONO___29 = 1,
    SF_CHANNEL_MAP_LEFT___29 = 2,
    SF_CHANNEL_MAP_RIGHT___29 = 3,
    SF_CHANNEL_MAP_CENTER___29 = 4,
    SF_CHANNEL_MAP_FRONT_LEFT___29 = 5,
    SF_CHANNEL_MAP_FRONT_RIGHT___29 = 6,
    SF_CHANNEL_MAP_FRONT_CENTER___29 = 7,
    SF_CHANNEL_MAP_REAR_CENTER___29 = 8,
    SF_CHANNEL_MAP_REAR_LEFT___29 = 9,
    SF_CHANNEL_MAP_REAR_RIGHT___29 = 10,
    SF_CHANNEL_MAP_LFE___29 = 11,
    SF_CHANNEL_MAP_FRONT_LEFT_OF_CENTER___29 = 12,
    SF_CHANNEL_MAP_FRONT_RIGHT_OF_CENTER___29 = 13,
    SF_CHANNEL_MAP_SIDE_LEFT___29 = 14,
    SF_CHANNEL_MAP_SIDE_RIGHT___29 = 15,
    SF_CHANNEL_MAP_TOP_CENTER___29 = 16,
    SF_CHANNEL_MAP_TOP_FRONT_LEFT___29 = 17,
    SF_CHANNEL_MAP_TOP_FRONT_RIGHT___29 = 18,
    SF_CHANNEL_MAP_TOP_FRONT_CENTER___29 = 19,
    SF_CHANNEL_MAP_TOP_REAR_LEFT___29 = 20,
    SF_CHANNEL_MAP_TOP_REAR_RIGHT___29 = 21,
    SF_CHANNEL_MAP_TOP_REAR_CENTER___29 = 22
} ;
#line 352
enum __anonenum__577___0 {
    SFD_DEFAULT_LEVEL___29 = 0,
    SFD_CUSTOM_LEVEL___29 = 1073741824,
    SFD_NO_DITHER___29 = 500,
    SFD_WHITE___29 = 501,
    SFD_TRIANGULAR_PDF___29 = 502
} ;
#line 380
enum __anonenum__580___0 {
    SF_LOOP_NONE___29 = 800,
    SF_LOOP_FORWARD___29 = 801,
    SF_LOOP_BACKWARD___29 = 802,
    SF_LOOP_ALTERNATING___29 = 803
} ;
#line 121 "/root/libsndfile/src/common.h"
enum __anonenum__585___0 {
    SF_PEAK_START___29 = 42,
    SF_PEAK_END___29 = 43,
    SF_SCALE_MAX___29 = 52,
    SF_SCALE_MIN___29 = 53,
    SF_STR_ALLOW_START___29 = 256,
    SF_STR_ALLOW_END___29 = 512,
    SF_STR_LOCATE_START___29 = 1024,
    SF_STR_LOCATE_END___29 = 2048,
    SFD_TYPEMASK___29 = 268435455
} ;
#line 149
enum __anonenum__586___0 {
    SF_FORMAT_TXW___29 = 67305472,
    SF_FORMAT_DWD___29 = 67371008,
    SF_FORMAT_REX___29 = 67764224,
    SF_FORMAT_REX2___29 = 67960832,
    SF_FORMAT_KRZ___29 = 68026368,
    SF_FORMAT_WMA___29 = 68157440,
    SF_FORMAT_SHN___29 = 68222976,
    SF_FORMAT_SVX_FIB___29 = 4128,
    SF_FORMAT_SVX_EXP___29 = 4129,
    SF_FORMAT_PCM_N___29 = 4144
} ;
#line 405
enum __anonenum__592___0 {
    SFE_NO_ERROR___29 = 0,
    SFE_BAD_OPEN_FORMAT___29 = 1,
    SFE_SYSTEM___29 = 2,
    SFE_MALFORMED_FILE___29 = 3,
    SFE_UNSUPPORTED_ENCODING___29 = 4,
    SFE_ZERO_MAJOR_FORMAT___29 = 5,
    SFE_ZERO_MINOR_FORMAT___29 = 6,
    SFE_BAD_FILE___29 = 7,
    SFE_BAD_FILE_READ___29 = 8,
    SFE_OPEN_FAILED___29 = 9,
    SFE_BAD_SNDFILE_PTR___29 = 10,
    SFE_BAD_SF_INFO_PTR___29 = 11,
    SFE_BAD_SF_INCOMPLETE___29 = 12,
    SFE_BAD_FILE_PTR___29 = 13,
    SFE_BAD_INT_PTR___29 = 14,
    SFE_BAD_STAT_SIZE___29 = 15,
    SFE_MALLOC_FAILED___29 = 16,
    SFE_UNIMPLEMENTED___29 = 17,
    SFE_BAD_READ_ALIGN___29 = 18,
    SFE_BAD_WRITE_ALIGN___29 = 19,
    SFE_UNKNOWN_FORMAT___29 = 20,
    SFE_NOT_READMODE___29 = 21,
    SFE_NOT_WRITEMODE___29 = 22,
    SFE_BAD_MODE_RW___29 = 23,
    SFE_BAD_SF_INFO___29 = 24,
    SFE_BAD_OFFSET___29 = 25,
    SFE_NO_EMBED_SUPPORT___29 = 26,
    SFE_NO_EMBEDDED_RDWR___29 = 27,
    SFE_NO_PIPE_WRITE___29 = 28,
    SFE_INTERNAL___29 = 29,
    SFE_BAD_COMMAND_PARAM___29 = 30,
    SFE_BAD_ENDIAN___29 = 31,
    SFE_CHANNEL_COUNT_ZERO___29 = 32,
    SFE_CHANNEL_COUNT___29 = 33,
    SFE_BAD_VIRTUAL_IO___29 = 34,
    SFE_INTERLEAVE_MODE___29 = 35,
    SFE_INTERLEAVE_SEEK___29 = 36,
    SFE_INTERLEAVE_READ___29 = 37,
    SFE_BAD_SEEK___29 = 38,
    SFE_NOT_SEEKABLE___29 = 39,
    SFE_AMBIGUOUS_SEEK___29 = 40,
    SFE_WRONG_SEEK___29 = 41,
    SFE_SEEK_FAILED___29 = 42,
    SFE_BAD_OPEN_MODE___29 = 43,
    SFE_OPEN_PIPE_RDWR___29 = 44,
    SFE_RDWR_POSITION___29 = 45,
    SFE_RDWR_BAD_HEADER___29 = 46,
    SFE_CMD_HAS_DATA___29 = 47,
    SFE_BAD_BROADCAST_INFO_SIZE___29 = 48,
    SFE_STR_NO_SUPPORT___29 = 49,
    SFE_STR_NOT_WRITE___29 = 50,
    SFE_STR_MAX_DATA___29 = 51,
    SFE_STR_MAX_COUNT___29 = 52,
    SFE_STR_BAD_TYPE___29 = 53,
    SFE_STR_NO_ADD_END___29 = 54,
    SFE_STR_BAD_STRING___29 = 55,
    SFE_STR_WEIRD___29 = 56,
    SFE_WAV_NO_RIFF___29 = 57,
    SFE_WAV_NO_WAVE___29 = 58,
    SFE_WAV_NO_FMT___29 = 59,
    SFE_WAV_BAD_FMT___29 = 60,
    SFE_WAV_FMT_SHORT___29 = 61,
    SFE_WAV_BAD_FACT___29 = 62,
    SFE_WAV_BAD_PEAK___29 = 63,
    SFE_WAV_PEAK_B4_FMT___29 = 64,
    SFE_WAV_BAD_FORMAT___29 = 65,
    SFE_WAV_BAD_BLOCKALIGN___29 = 66,
    SFE_WAV_NO_DATA___29 = 67,
    SFE_WAV_BAD_LIST___29 = 68,
    SFE_WAV_ADPCM_NOT4BIT___29 = 69,
    SFE_WAV_ADPCM_CHANNELS___29 = 70,
    SFE_WAV_GSM610_FORMAT___29 = 71,
    SFE_WAV_UNKNOWN_CHUNK___29 = 72,
    SFE_WAV_WVPK_DATA___29 = 73,
    SFE_AIFF_NO_FORM___29 = 74,
    SFE_AIFF_AIFF_NO_FORM___29 = 75,
    SFE_AIFF_COMM_NO_FORM___29 = 76,
    SFE_AIFF_SSND_NO_COMM___29 = 77,
    SFE_AIFF_UNKNOWN_CHUNK___29 = 78,
    SFE_AIFF_COMM_CHUNK_SIZE___29 = 79,
    SFE_AIFF_BAD_COMM_CHUNK___29 = 80,
    SFE_AIFF_PEAK_B4_COMM___29 = 81,
    SFE_AIFF_BAD_PEAK___29 = 82,
    SFE_AIFF_NO_SSND___29 = 83,
    SFE_AIFF_NO_DATA___29 = 84,
    SFE_AIFF_RW_SSND_NOT_LAST___29 = 85,
    SFE_AU_UNKNOWN_FORMAT___29 = 86,
    SFE_AU_NO_DOTSND___29 = 87,
    SFE_AU_EMBED_BAD_LEN___29 = 88,
    SFE_RAW_READ_BAD_SPEC___29 = 89,
    SFE_RAW_BAD_BITWIDTH___29 = 90,
    SFE_RAW_BAD_FORMAT___29 = 91,
    SFE_PAF_NO_MARKER___29 = 92,
    SFE_PAF_VERSION___29 = 93,
    SFE_PAF_UNKNOWN_FORMAT___29 = 94,
    SFE_PAF_SHORT_HEADER___29 = 95,
    SFE_SVX_NO_FORM___29 = 96,
    SFE_SVX_NO_BODY___29 = 97,
    SFE_SVX_NO_DATA___29 = 98,
    SFE_SVX_BAD_COMP___29 = 99,
    SFE_SVX_BAD_NAME_LENGTH___29 = 100,
    SFE_NIST_BAD_HEADER___29 = 101,
    SFE_NIST_CRLF_CONVERISON___29 = 102,
    SFE_NIST_BAD_ENCODING___29 = 103,
    SFE_VOC_NO_CREATIVE___29 = 104,
    SFE_VOC_BAD_FORMAT___29 = 105,
    SFE_VOC_BAD_VERSION___29 = 106,
    SFE_VOC_BAD_MARKER___29 = 107,
    SFE_VOC_BAD_SECTIONS___29 = 108,
    SFE_VOC_MULTI_SAMPLERATE___29 = 109,
    SFE_VOC_MULTI_SECTION___29 = 110,
    SFE_VOC_MULTI_PARAM___29 = 111,
    SFE_VOC_SECTION_COUNT___29 = 112,
    SFE_VOC_NO_PIPE___29 = 113,
    SFE_IRCAM_NO_MARKER___29 = 114,
    SFE_IRCAM_BAD_CHANNELS___29 = 115,
    SFE_IRCAM_UNKNOWN_FORMAT___29 = 116,
    SFE_W64_64_BIT___29 = 117,
    SFE_W64_NO_RIFF___29 = 118,
    SFE_W64_NO_WAVE___29 = 119,
    SFE_W64_NO_DATA___29 = 120,
    SFE_W64_ADPCM_NOT4BIT___29 = 121,
    SFE_W64_ADPCM_CHANNELS___29 = 122,
    SFE_W64_GSM610_FORMAT___29 = 123,
    SFE_MAT4_BAD_NAME___29 = 124,
    SFE_MAT4_NO_SAMPLERATE___29 = 125,
    SFE_MAT5_BAD_ENDIAN___29 = 126,
    SFE_MAT5_NO_BLOCK___29 = 127,
    SFE_MAT5_SAMPLE_RATE___29 = 128,
    SFE_PVF_NO_PVF1___29 = 129,
    SFE_PVF_BAD_HEADER___29 = 130,
    SFE_PVF_BAD_BITWIDTH___29 = 131,
    SFE_DWVW_BAD_BITWIDTH___29 = 132,
    SFE_G72X_NOT_MONO___29 = 133,
    SFE_XI_BAD_HEADER___29 = 134,
    SFE_XI_EXCESS_SAMPLES___29 = 135,
    SFE_XI_NO_PIPE___29 = 136,
    SFE_HTK_NO_PIPE___29 = 137,
    SFE_SDS_NOT_SDS___29 = 138,
    SFE_SDS_BAD_BIT_WIDTH___29 = 139,
    SFE_SD2_FD_DISALLOWED___29 = 140,
    SFE_SD2_BAD_DATA_OFFSET___29 = 141,
    SFE_SD2_BAD_MAP_OFFSET___29 = 142,
    SFE_SD2_BAD_DATA_LENGTH___29 = 143,
    SFE_SD2_BAD_MAP_LENGTH___29 = 144,
    SFE_SD2_BAD_RSRC___29 = 145,
    SFE_SD2_BAD_SAMPLE_SIZE___29 = 146,
    SFE_FLAC_BAD_HEADER___29 = 147,
    SFE_FLAC_NEW_DECODER___29 = 148,
    SFE_FLAC_INIT_DECODER___29 = 149,
    SFE_FLAC_LOST_SYNC___29 = 150,
    SFE_FLAC_BAD_SAMPLE_RATE___29 = 151,
    SFE_FLAC_UNKOWN_ERROR___29 = 152,
    SFE_WVE_NOT_WVE___29 = 153,
    SFE_WVE_NO_PIPE___29 = 154,
    SFE_VORBIS_ENCODER_BUG___29 = 155,
    SFE_RF64_NOT_RF64___29 = 156,
    SFE_MAX_ERROR___29 = 157
} ;
#line 823
enum __anonenum__596___0 {
    SFC_TEST_AIFF_ADD_INST_CHUNK___29 = 8192,
    SFC_TEST_WAV_ADD_INFO_CHUNK___29 = 8208
} ;
#line 47 "/root/libsndfile/src/sds.c"
struct tag_SDS_PRIVATE {
   int bitwidth ;
   int frames ;
   int samplesperblock ;
   int total_blocks ;
   int (*reader)(SF_PRIVATE * , struct tag_SDS_PRIVATE * ) ;
   int (*writer)(SF_PRIVATE * , struct tag_SDS_PRIVATE * ) ;
   int read_block ;
   int read_count ;
   unsigned char read_data[127] ;
   int read_samples[63] ;
   int write_block ;
   int write_count ;
   unsigned char write_data[127] ;
   int write_samples[63] ;
};
#line 61 "/root/libsndfile/src/sds.c"
typedef struct tag_SDS_PRIVATE SDS_PRIVATE;
#line 46 "/usr/include/ctype.h"
enum __anonenum__598___1 {
    _ISupper___10 = 256,
    _ISlower___10 = 512,
    _ISalpha___10 = 1024,
    _ISdigit___10 = 2048,
    _ISxdigit___10 = 4096,
    _ISspace___10 = 8192,
    _ISprint___10 = 16384,
    _ISgraph___10 = 32768,
    _ISblank___10 = 1,
    _IScntrl___10 = 2,
    _ISpunct___10 = 4,
    _ISalnum___10 = 8
} ;
#line 46 "/root/libsndfile/src/sndfile.h"
enum __anonenum__775 {
    SF_FORMAT_WAV___30 = 65536,
    SF_FORMAT_AIFF___30 = 131072,
    SF_FORMAT_AU___30 = 196608,
    SF_FORMAT_RAW___30 = 262144,
    SF_FORMAT_PAF___30 = 327680,
    SF_FORMAT_SVX___30 = 393216,
    SF_FORMAT_NIST___30 = 458752,
    SF_FORMAT_VOC___30 = 524288,
    SF_FORMAT_IRCAM___30 = 655360,
    SF_FORMAT_W64___30 = 720896,
    SF_FORMAT_MAT4___30 = 786432,
    SF_FORMAT_MAT5___30 = 851968,
    SF_FORMAT_PVF___30 = 917504,
    SF_FORMAT_XI___30 = 983040,
    SF_FORMAT_HTK___30 = 1048576,
    SF_FORMAT_SDS___30 = 1114112,
    SF_FORMAT_AVR___30 = 1179648,
    SF_FORMAT_WAVEX___30 = 1245184,
    SF_FORMAT_SD2___30 = 1441792,
    SF_FORMAT_FLAC___30 = 1507328,
    SF_FORMAT_CAF___30 = 1572864,
    SF_FORMAT_WVE___30 = 1638400,
    SF_FORMAT_OGG___30 = 2097152,
    SF_FORMAT_MPC2K___30 = 2162688,
    SF_FORMAT_RF64___30 = 2228224,
    SF_FORMAT_PCM_S8___30 = 1,
    SF_FORMAT_PCM_16___30 = 2,
    SF_FORMAT_PCM_24___30 = 3,
    SF_FORMAT_PCM_32___30 = 4,
    SF_FORMAT_PCM_U8___30 = 5,
    SF_FORMAT_FLOAT___30 = 6,
    SF_FORMAT_DOUBLE___30 = 7,
    SF_FORMAT_ULAW___30 = 16,
    SF_FORMAT_ALAW___30 = 17,
    SF_FORMAT_IMA_ADPCM___30 = 18,
    SF_FORMAT_MS_ADPCM___30 = 19,
    SF_FORMAT_GSM610___30 = 32,
    SF_FORMAT_VOX_ADPCM___30 = 33,
    SF_FORMAT_G721_32___30 = 48,
    SF_FORMAT_G723_24___30 = 49,
    SF_FORMAT_G723_40___30 = 50,
    SF_FORMAT_DWVW_12___30 = 64,
    SF_FORMAT_DWVW_16___30 = 65,
    SF_FORMAT_DWVW_24___30 = 66,
    SF_FORMAT_DWVW_N___30 = 67,
    SF_FORMAT_DPCM_8___30 = 80,
    SF_FORMAT_DPCM_16___30 = 81,
    SF_FORMAT_VORBIS___30 = 96,
    SF_ENDIAN_FILE___30 = 0,
    SF_ENDIAN_LITTLE___30 = 268435456,
    SF_ENDIAN_BIG___30 = 536870912,
    SF_ENDIAN_CPU___30 = 805306368,
    SF_FORMAT_SUBMASK___30 = 65535,
    SF_FORMAT_TYPEMASK___30 = 268369920,
    SF_FORMAT_ENDMASK___30 = 805306368
} ;
#line 126
enum __anonenum__776 {
    SFC_GET_LIB_VERSION___30 = 4096,
    SFC_GET_LOG_INFO___30 = 4097,
    SFC_GET_CURRENT_SF_INFO___30 = 4098,
    SFC_GET_NORM_DOUBLE___30 = 4112,
    SFC_GET_NORM_FLOAT___30 = 4113,
    SFC_SET_NORM_DOUBLE___30 = 4114,
    SFC_SET_NORM_FLOAT___30 = 4115,
    SFC_SET_SCALE_FLOAT_INT_READ___30 = 4116,
    SFC_SET_SCALE_INT_FLOAT_WRITE___30 = 4117,
    SFC_GET_SIMPLE_FORMAT_COUNT___30 = 4128,
    SFC_GET_SIMPLE_FORMAT___30 = 4129,
    SFC_GET_FORMAT_INFO___30 = 4136,
    SFC_GET_FORMAT_MAJOR_COUNT___30 = 4144,
    SFC_GET_FORMAT_MAJOR___30 = 4145,
    SFC_GET_FORMAT_SUBTYPE_COUNT___30 = 4146,
    SFC_GET_FORMAT_SUBTYPE___30 = 4147,
    SFC_CALC_SIGNAL_MAX___30 = 4160,
    SFC_CALC_NORM_SIGNAL_MAX___30 = 4161,
    SFC_CALC_MAX_ALL_CHANNELS___30 = 4162,
    SFC_CALC_NORM_MAX_ALL_CHANNELS___30 = 4163,
    SFC_GET_SIGNAL_MAX___30 = 4164,
    SFC_GET_MAX_ALL_CHANNELS___30 = 4165,
    SFC_SET_ADD_PEAK_CHUNK___30 = 4176,
    SFC_SET_ADD_HEADER_PAD_CHUNK___30 = 4177,
    SFC_UPDATE_HEADER_NOW___30 = 4192,
    SFC_SET_UPDATE_HEADER_AUTO___30 = 4193,
    SFC_FILE_TRUNCATE___30 = 4224,
    SFC_SET_RAW_START_OFFSET___30 = 4240,
    SFC_SET_DITHER_ON_WRITE___30 = 4256,
    SFC_SET_DITHER_ON_READ___30 = 4257,
    SFC_GET_DITHER_INFO_COUNT___30 = 4258,
    SFC_GET_DITHER_INFO___30 = 4259,
    SFC_GET_EMBED_FILE_INFO___30 = 4272,
    SFC_SET_CLIPPING___30 = 4288,
    SFC_GET_CLIPPING___30 = 4289,
    SFC_GET_INSTRUMENT___30 = 4304,
    SFC_SET_INSTRUMENT___30 = 4305,
    SFC_GET_LOOP_INFO___30 = 4320,
    SFC_GET_BROADCAST_INFO___30 = 4336,
    SFC_SET_BROADCAST_INFO___30 = 4337,
    SFC_GET_CHANNEL_MAP_INFO___30 = 4352,
    SFC_SET_CHANNEL_MAP_INFO___30 = 4353,
    SFC_RAW_DATA_NEEDS_ENDSWAP___30 = 4368,
    SFC_WAVEX_SET_AMBISONIC___30 = 4608,
    SFC_WAVEX_GET_AMBISONIC___30 = 4609,
    SFC_SET_VBR_ENCODING_QUALITY___30 = 4864,
    SFC_TEST_IEEE_FLOAT_REPLACE___30 = 24577,
    SFC_SET_ADD_DITHER_ON_WRITE___30 = 4208,
    SFC_SET_ADD_DITHER_ON_READ___30 = 4209
} ;
#line 216
enum __anonenum__777 {
    SF_STR_TITLE___30 = 1,
    SF_STR_COPYRIGHT___30 = 2,
    SF_STR_SOFTWARE___30 = 3,
    SF_STR_ARTIST___30 = 4,
    SF_STR_COMMENT___30 = 5,
    SF_STR_DATE___30 = 6,
    SF_STR_ALBUM___30 = 7,
    SF_STR_LICENSE___30 = 8
} ;
#line 235
enum __anonenum__778 {
    SF_FALSE___30 = 0,
    SF_TRUE___30 = 1,
    SFM_READ___30 = 16,
    SFM_WRITE___30 = 32,
    SFM_RDWR___30 = 48,
    SF_AMBISONIC_NONE___30 = 64,
    SF_AMBISONIC_B_FORMAT___30 = 65
} ;
#line 255
enum __anonenum__779 {
    SF_ERR_NO_ERROR___30 = 0,
    SF_ERR_UNRECOGNISED_FORMAT___30 = 1,
    SF_ERR_SYSTEM___30 = 2,
    SF_ERR_MALFORMED_FILE___30 = 3,
    SF_ERR_UNSUPPORTED_ENCODING___30 = 4
} ;
#line 267
enum __anonenum__780 {
    SF_CHANNEL_MAP_INVALID___30 = 0,
    SF_CHANNEL_MAP_MONO___30 = 1,
    SF_CHANNEL_MAP_LEFT___30 = 2,
    SF_CHANNEL_MAP_RIGHT___30 = 3,
    SF_CHANNEL_MAP_CENTER___30 = 4,
    SF_CHANNEL_MAP_FRONT_LEFT___30 = 5,
    SF_CHANNEL_MAP_FRONT_RIGHT___30 = 6,
    SF_CHANNEL_MAP_FRONT_CENTER___30 = 7,
    SF_CHANNEL_MAP_REAR_CENTER___30 = 8,
    SF_CHANNEL_MAP_REAR_LEFT___30 = 9,
    SF_CHANNEL_MAP_REAR_RIGHT___30 = 10,
    SF_CHANNEL_MAP_LFE___30 = 11,
    SF_CHANNEL_MAP_FRONT_LEFT_OF_CENTER___30 = 12,
    SF_CHANNEL_MAP_FRONT_RIGHT_OF_CENTER___30 = 13,
    SF_CHANNEL_MAP_SIDE_LEFT___30 = 14,
    SF_CHANNEL_MAP_SIDE_RIGHT___30 = 15,
    SF_CHANNEL_MAP_TOP_CENTER___30 = 16,
    SF_CHANNEL_MAP_TOP_FRONT_LEFT___30 = 17,
    SF_CHANNEL_MAP_TOP_FRONT_RIGHT___30 = 18,
    SF_CHANNEL_MAP_TOP_FRONT_CENTER___30 = 19,
    SF_CHANNEL_MAP_TOP_REAR_LEFT___30 = 20,
    SF_CHANNEL_MAP_TOP_REAR_RIGHT___30 = 21,
    SF_CHANNEL_MAP_TOP_REAR_CENTER___30 = 22
} ;
#line 352
enum __anonenum__782 {
    SFD_DEFAULT_LEVEL___30 = 0,
    SFD_CUSTOM_LEVEL___30 = 1073741824,
    SFD_NO_DITHER___30 = 500,
    SFD_WHITE___30 = 501,
    SFD_TRIANGULAR_PDF___30 = 502
} ;
#line 380
enum __anonenum__785 {
    SF_LOOP_NONE___30 = 800,
    SF_LOOP_FORWARD___30 = 801,
    SF_LOOP_BACKWARD___30 = 802,
    SF_LOOP_ALTERNATING___30 = 803
} ;
#line 121 "/root/libsndfile/src/common.h"
enum __anonenum__790 {
    SF_PEAK_START___30 = 42,
    SF_PEAK_END___30 = 43,
    SF_SCALE_MAX___30 = 52,
    SF_SCALE_MIN___30 = 53,
    SF_STR_ALLOW_START___30 = 256,
    SF_STR_ALLOW_END___30 = 512,
    SF_STR_LOCATE_START___30 = 1024,
    SF_STR_LOCATE_END___30 = 2048,
    SFD_TYPEMASK___30 = 268435455
} ;
#line 149
enum __anonenum__791 {
    SF_FORMAT_TXW___30 = 67305472,
    SF_FORMAT_DWD___30 = 67371008,
    SF_FORMAT_REX___30 = 67764224,
    SF_FORMAT_REX2___30 = 67960832,
    SF_FORMAT_KRZ___30 = 68026368,
    SF_FORMAT_WMA___30 = 68157440,
    SF_FORMAT_SHN___30 = 68222976,
    SF_FORMAT_SVX_FIB___30 = 4128,
    SF_FORMAT_SVX_EXP___30 = 4129,
    SF_FORMAT_PCM_N___30 = 4144
} ;
#line 405
enum __anonenum__797 {
    SFE_NO_ERROR___30 = 0,
    SFE_BAD_OPEN_FORMAT___30 = 1,
    SFE_SYSTEM___30 = 2,
    SFE_MALFORMED_FILE___30 = 3,
    SFE_UNSUPPORTED_ENCODING___30 = 4,
    SFE_ZERO_MAJOR_FORMAT___30 = 5,
    SFE_ZERO_MINOR_FORMAT___30 = 6,
    SFE_BAD_FILE___30 = 7,
    SFE_BAD_FILE_READ___30 = 8,
    SFE_OPEN_FAILED___30 = 9,
    SFE_BAD_SNDFILE_PTR___30 = 10,
    SFE_BAD_SF_INFO_PTR___30 = 11,
    SFE_BAD_SF_INCOMPLETE___30 = 12,
    SFE_BAD_FILE_PTR___30 = 13,
    SFE_BAD_INT_PTR___30 = 14,
    SFE_BAD_STAT_SIZE___30 = 15,
    SFE_MALLOC_FAILED___30 = 16,
    SFE_UNIMPLEMENTED___30 = 17,
    SFE_BAD_READ_ALIGN___30 = 18,
    SFE_BAD_WRITE_ALIGN___30 = 19,
    SFE_UNKNOWN_FORMAT___30 = 20,
    SFE_NOT_READMODE___30 = 21,
    SFE_NOT_WRITEMODE___30 = 22,
    SFE_BAD_MODE_RW___30 = 23,
    SFE_BAD_SF_INFO___30 = 24,
    SFE_BAD_OFFSET___30 = 25,
    SFE_NO_EMBED_SUPPORT___30 = 26,
    SFE_NO_EMBEDDED_RDWR___30 = 27,
    SFE_NO_PIPE_WRITE___30 = 28,
    SFE_INTERNAL___30 = 29,
    SFE_BAD_COMMAND_PARAM___30 = 30,
    SFE_BAD_ENDIAN___30 = 31,
    SFE_CHANNEL_COUNT_ZERO___30 = 32,
    SFE_CHANNEL_COUNT___30 = 33,
    SFE_BAD_VIRTUAL_IO___30 = 34,
    SFE_INTERLEAVE_MODE___30 = 35,
    SFE_INTERLEAVE_SEEK___30 = 36,
    SFE_INTERLEAVE_READ___30 = 37,
    SFE_BAD_SEEK___30 = 38,
    SFE_NOT_SEEKABLE___30 = 39,
    SFE_AMBIGUOUS_SEEK___30 = 40,
    SFE_WRONG_SEEK___30 = 41,
    SFE_SEEK_FAILED___30 = 42,
    SFE_BAD_OPEN_MODE___30 = 43,
    SFE_OPEN_PIPE_RDWR___30 = 44,
    SFE_RDWR_POSITION___30 = 45,
    SFE_RDWR_BAD_HEADER___30 = 46,
    SFE_CMD_HAS_DATA___30 = 47,
    SFE_BAD_BROADCAST_INFO_SIZE___30 = 48,
    SFE_STR_NO_SUPPORT___30 = 49,
    SFE_STR_NOT_WRITE___30 = 50,
    SFE_STR_MAX_DATA___30 = 51,
    SFE_STR_MAX_COUNT___30 = 52,
    SFE_STR_BAD_TYPE___30 = 53,
    SFE_STR_NO_ADD_END___30 = 54,
    SFE_STR_BAD_STRING___30 = 55,
    SFE_STR_WEIRD___30 = 56,
    SFE_WAV_NO_RIFF___30 = 57,
    SFE_WAV_NO_WAVE___30 = 58,
    SFE_WAV_NO_FMT___30 = 59,
    SFE_WAV_BAD_FMT___30 = 60,
    SFE_WAV_FMT_SHORT___30 = 61,
    SFE_WAV_BAD_FACT___30 = 62,
    SFE_WAV_BAD_PEAK___30 = 63,
    SFE_WAV_PEAK_B4_FMT___30 = 64,
    SFE_WAV_BAD_FORMAT___30 = 65,
    SFE_WAV_BAD_BLOCKALIGN___30 = 66,
    SFE_WAV_NO_DATA___30 = 67,
    SFE_WAV_BAD_LIST___30 = 68,
    SFE_WAV_ADPCM_NOT4BIT___30 = 69,
    SFE_WAV_ADPCM_CHANNELS___30 = 70,
    SFE_WAV_GSM610_FORMAT___30 = 71,
    SFE_WAV_UNKNOWN_CHUNK___30 = 72,
    SFE_WAV_WVPK_DATA___30 = 73,
    SFE_AIFF_NO_FORM___30 = 74,
    SFE_AIFF_AIFF_NO_FORM___30 = 75,
    SFE_AIFF_COMM_NO_FORM___30 = 76,
    SFE_AIFF_SSND_NO_COMM___30 = 77,
    SFE_AIFF_UNKNOWN_CHUNK___30 = 78,
    SFE_AIFF_COMM_CHUNK_SIZE___30 = 79,
    SFE_AIFF_BAD_COMM_CHUNK___30 = 80,
    SFE_AIFF_PEAK_B4_COMM___30 = 81,
    SFE_AIFF_BAD_PEAK___30 = 82,
    SFE_AIFF_NO_SSND___30 = 83,
    SFE_AIFF_NO_DATA___30 = 84,
    SFE_AIFF_RW_SSND_NOT_LAST___30 = 85,
    SFE_AU_UNKNOWN_FORMAT___30 = 86,
    SFE_AU_NO_DOTSND___30 = 87,
    SFE_AU_EMBED_BAD_LEN___30 = 88,
    SFE_RAW_READ_BAD_SPEC___30 = 89,
    SFE_RAW_BAD_BITWIDTH___30 = 90,
    SFE_RAW_BAD_FORMAT___30 = 91,
    SFE_PAF_NO_MARKER___30 = 92,
    SFE_PAF_VERSION___30 = 93,
    SFE_PAF_UNKNOWN_FORMAT___30 = 94,
    SFE_PAF_SHORT_HEADER___30 = 95,
    SFE_SVX_NO_FORM___30 = 96,
    SFE_SVX_NO_BODY___30 = 97,
    SFE_SVX_NO_DATA___30 = 98,
    SFE_SVX_BAD_COMP___30 = 99,
    SFE_SVX_BAD_NAME_LENGTH___30 = 100,
    SFE_NIST_BAD_HEADER___30 = 101,
    SFE_NIST_CRLF_CONVERISON___30 = 102,
    SFE_NIST_BAD_ENCODING___30 = 103,
    SFE_VOC_NO_CREATIVE___30 = 104,
    SFE_VOC_BAD_FORMAT___30 = 105,
    SFE_VOC_BAD_VERSION___30 = 106,
    SFE_VOC_BAD_MARKER___30 = 107,
    SFE_VOC_BAD_SECTIONS___30 = 108,
    SFE_VOC_MULTI_SAMPLERATE___30 = 109,
    SFE_VOC_MULTI_SECTION___30 = 110,
    SFE_VOC_MULTI_PARAM___30 = 111,
    SFE_VOC_SECTION_COUNT___30 = 112,
    SFE_VOC_NO_PIPE___30 = 113,
    SFE_IRCAM_NO_MARKER___30 = 114,
    SFE_IRCAM_BAD_CHANNELS___30 = 115,
    SFE_IRCAM_UNKNOWN_FORMAT___30 = 116,
    SFE_W64_64_BIT___30 = 117,
    SFE_W64_NO_RIFF___30 = 118,
    SFE_W64_NO_WAVE___30 = 119,
    SFE_W64_NO_DATA___30 = 120,
    SFE_W64_ADPCM_NOT4BIT___30 = 121,
    SFE_W64_ADPCM_CHANNELS___30 = 122,
    SFE_W64_GSM610_FORMAT___30 = 123,
    SFE_MAT4_BAD_NAME___30 = 124,
    SFE_MAT4_NO_SAMPLERATE___30 = 125,
    SFE_MAT5_BAD_ENDIAN___30 = 126,
    SFE_MAT5_NO_BLOCK___30 = 127,
    SFE_MAT5_SAMPLE_RATE___30 = 128,
    SFE_PVF_NO_PVF1___30 = 129,
    SFE_PVF_BAD_HEADER___30 = 130,
    SFE_PVF_BAD_BITWIDTH___30 = 131,
    SFE_DWVW_BAD_BITWIDTH___30 = 132,
    SFE_G72X_NOT_MONO___30 = 133,
    SFE_XI_BAD_HEADER___30 = 134,
    SFE_XI_EXCESS_SAMPLES___30 = 135,
    SFE_XI_NO_PIPE___30 = 136,
    SFE_HTK_NO_PIPE___30 = 137,
    SFE_SDS_NOT_SDS___30 = 138,
    SFE_SDS_BAD_BIT_WIDTH___30 = 139,
    SFE_SD2_FD_DISALLOWED___30 = 140,
    SFE_SD2_BAD_DATA_OFFSET___30 = 141,
    SFE_SD2_BAD_MAP_OFFSET___30 = 142,
    SFE_SD2_BAD_DATA_LENGTH___30 = 143,
    SFE_SD2_BAD_MAP_LENGTH___30 = 144,
    SFE_SD2_BAD_RSRC___30 = 145,
    SFE_SD2_BAD_SAMPLE_SIZE___30 = 146,
    SFE_FLAC_BAD_HEADER___30 = 147,
    SFE_FLAC_NEW_DECODER___30 = 148,
    SFE_FLAC_INIT_DECODER___30 = 149,
    SFE_FLAC_LOST_SYNC___30 = 150,
    SFE_FLAC_BAD_SAMPLE_RATE___30 = 151,
    SFE_FLAC_UNKOWN_ERROR___30 = 152,
    SFE_WVE_NOT_WVE___30 = 153,
    SFE_WVE_NO_PIPE___30 = 154,
    SFE_VORBIS_ENCODER_BUG___30 = 155,
    SFE_RF64_NOT_RF64___30 = 156,
    SFE_MAX_ERROR___30 = 157
} ;
#line 823
enum __anonenum__801 {
    SFC_TEST_AIFF_ADD_INST_CHUNK___30 = 8192,
    SFC_TEST_WAV_ADD_INFO_CHUNK___30 = 8208
} ;
#line 53 "/root/libsndfile/src/sd2.c"
enum __anonenum__802 {
    RSRC_STR = 111,
    RSRC_BIN = 112
} ;
#line 58 "/root/libsndfile/src/sd2.c"
struct __anonstruct_803 {
   unsigned char *rsrc_data ;
   int rsrc_len ;
   int need_to_free_rsrc_data ;
   int data_offset ;
   int data_length ;
   int map_offset ;
   int map_length ;
   int type_count ;
   int type_offset ;
   int item_offset ;
   int str_index ;
   int str_count ;
   int string_offset ;
   int sample_size ;
   int sample_rate ;
   int channels ;
};
#line 75 "/root/libsndfile/src/sd2.c"
typedef struct __anonstruct_803 SD2_RSRC;
#line 77 "/root/libsndfile/src/sd2.c"
struct __anonstruct_804 {
   int type ;
   int id ;
   char name[32] ;
   char value[32] ;
   int value_len ;
};
#line 83 "/root/libsndfile/src/sd2.c"
typedef struct __anonstruct_804 STR_RSRC;
#line 46 "/usr/include/ctype.h"
enum __anonenum__437___2 {
    _ISupper___11 = 256,
    _ISlower___11 = 512,
    _ISalpha___11 = 1024,
    _ISdigit___11 = 2048,
    _ISxdigit___11 = 4096,
    _ISspace___11 = 8192,
    _ISprint___11 = 16384,
    _ISgraph___11 = 32768,
    _ISblank___11 = 1,
    _IScntrl___11 = 2,
    _ISpunct___11 = 4,
    _ISalnum___11 = 8
} ;
#line 46 "/root/libsndfile/src/sndfile.h"
enum __anonenum__742___0 {
    SF_FORMAT_WAV___31 = 65536,
    SF_FORMAT_AIFF___31 = 131072,
    SF_FORMAT_AU___31 = 196608,
    SF_FORMAT_RAW___31 = 262144,
    SF_FORMAT_PAF___31 = 327680,
    SF_FORMAT_SVX___31 = 393216,
    SF_FORMAT_NIST___31 = 458752,
    SF_FORMAT_VOC___31 = 524288,
    SF_FORMAT_IRCAM___31 = 655360,
    SF_FORMAT_W64___31 = 720896,
    SF_FORMAT_MAT4___31 = 786432,
    SF_FORMAT_MAT5___31 = 851968,
    SF_FORMAT_PVF___31 = 917504,
    SF_FORMAT_XI___31 = 983040,
    SF_FORMAT_HTK___31 = 1048576,
    SF_FORMAT_SDS___31 = 1114112,
    SF_FORMAT_AVR___31 = 1179648,
    SF_FORMAT_WAVEX___31 = 1245184,
    SF_FORMAT_SD2___31 = 1441792,
    SF_FORMAT_FLAC___31 = 1507328,
    SF_FORMAT_CAF___31 = 1572864,
    SF_FORMAT_WVE___31 = 1638400,
    SF_FORMAT_OGG___31 = 2097152,
    SF_FORMAT_MPC2K___31 = 2162688,
    SF_FORMAT_RF64___31 = 2228224,
    SF_FORMAT_PCM_S8___31 = 1,
    SF_FORMAT_PCM_16___31 = 2,
    SF_FORMAT_PCM_24___31 = 3,
    SF_FORMAT_PCM_32___31 = 4,
    SF_FORMAT_PCM_U8___31 = 5,
    SF_FORMAT_FLOAT___31 = 6,
    SF_FORMAT_DOUBLE___31 = 7,
    SF_FORMAT_ULAW___31 = 16,
    SF_FORMAT_ALAW___31 = 17,
    SF_FORMAT_IMA_ADPCM___31 = 18,
    SF_FORMAT_MS_ADPCM___31 = 19,
    SF_FORMAT_GSM610___31 = 32,
    SF_FORMAT_VOX_ADPCM___31 = 33,
    SF_FORMAT_G721_32___31 = 48,
    SF_FORMAT_G723_24___31 = 49,
    SF_FORMAT_G723_40___31 = 50,
    SF_FORMAT_DWVW_12___31 = 64,
    SF_FORMAT_DWVW_16___31 = 65,
    SF_FORMAT_DWVW_24___31 = 66,
    SF_FORMAT_DWVW_N___31 = 67,
    SF_FORMAT_DPCM_8___31 = 80,
    SF_FORMAT_DPCM_16___31 = 81,
    SF_FORMAT_VORBIS___31 = 96,
    SF_ENDIAN_FILE___31 = 0,
    SF_ENDIAN_LITTLE___31 = 268435456,
    SF_ENDIAN_BIG___31 = 536870912,
    SF_ENDIAN_CPU___31 = 805306368,
    SF_FORMAT_SUBMASK___31 = 65535,
    SF_FORMAT_TYPEMASK___31 = 268369920,
    SF_FORMAT_ENDMASK___31 = 805306368
} ;
#line 126
enum __anonenum__743___0 {
    SFC_GET_LIB_VERSION___31 = 4096,
    SFC_GET_LOG_INFO___31 = 4097,
    SFC_GET_CURRENT_SF_INFO___31 = 4098,
    SFC_GET_NORM_DOUBLE___31 = 4112,
    SFC_GET_NORM_FLOAT___31 = 4113,
    SFC_SET_NORM_DOUBLE___31 = 4114,
    SFC_SET_NORM_FLOAT___31 = 4115,
    SFC_SET_SCALE_FLOAT_INT_READ___31 = 4116,
    SFC_SET_SCALE_INT_FLOAT_WRITE___31 = 4117,
    SFC_GET_SIMPLE_FORMAT_COUNT___31 = 4128,
    SFC_GET_SIMPLE_FORMAT___31 = 4129,
    SFC_GET_FORMAT_INFO___31 = 4136,
    SFC_GET_FORMAT_MAJOR_COUNT___31 = 4144,
    SFC_GET_FORMAT_MAJOR___31 = 4145,
    SFC_GET_FORMAT_SUBTYPE_COUNT___31 = 4146,
    SFC_GET_FORMAT_SUBTYPE___31 = 4147,
    SFC_CALC_SIGNAL_MAX___31 = 4160,
    SFC_CALC_NORM_SIGNAL_MAX___31 = 4161,
    SFC_CALC_MAX_ALL_CHANNELS___31 = 4162,
    SFC_CALC_NORM_MAX_ALL_CHANNELS___31 = 4163,
    SFC_GET_SIGNAL_MAX___31 = 4164,
    SFC_GET_MAX_ALL_CHANNELS___31 = 4165,
    SFC_SET_ADD_PEAK_CHUNK___31 = 4176,
    SFC_SET_ADD_HEADER_PAD_CHUNK___31 = 4177,
    SFC_UPDATE_HEADER_NOW___31 = 4192,
    SFC_SET_UPDATE_HEADER_AUTO___31 = 4193,
    SFC_FILE_TRUNCATE___31 = 4224,
    SFC_SET_RAW_START_OFFSET___31 = 4240,
    SFC_SET_DITHER_ON_WRITE___31 = 4256,
    SFC_SET_DITHER_ON_READ___31 = 4257,
    SFC_GET_DITHER_INFO_COUNT___31 = 4258,
    SFC_GET_DITHER_INFO___31 = 4259,
    SFC_GET_EMBED_FILE_INFO___31 = 4272,
    SFC_SET_CLIPPING___31 = 4288,
    SFC_GET_CLIPPING___31 = 4289,
    SFC_GET_INSTRUMENT___31 = 4304,
    SFC_SET_INSTRUMENT___31 = 4305,
    SFC_GET_LOOP_INFO___31 = 4320,
    SFC_GET_BROADCAST_INFO___31 = 4336,
    SFC_SET_BROADCAST_INFO___31 = 4337,
    SFC_GET_CHANNEL_MAP_INFO___31 = 4352,
    SFC_SET_CHANNEL_MAP_INFO___31 = 4353,
    SFC_RAW_DATA_NEEDS_ENDSWAP___31 = 4368,
    SFC_WAVEX_SET_AMBISONIC___31 = 4608,
    SFC_WAVEX_GET_AMBISONIC___31 = 4609,
    SFC_SET_VBR_ENCODING_QUALITY___31 = 4864,
    SFC_TEST_IEEE_FLOAT_REPLACE___31 = 24577,
    SFC_SET_ADD_DITHER_ON_WRITE___31 = 4208,
    SFC_SET_ADD_DITHER_ON_READ___31 = 4209
} ;
#line 216
enum __anonenum__744___0 {
    SF_STR_TITLE___31 = 1,
    SF_STR_COPYRIGHT___31 = 2,
    SF_STR_SOFTWARE___31 = 3,
    SF_STR_ARTIST___31 = 4,
    SF_STR_COMMENT___31 = 5,
    SF_STR_DATE___31 = 6,
    SF_STR_ALBUM___31 = 7,
    SF_STR_LICENSE___31 = 8
} ;
#line 235
enum __anonenum__745___0 {
    SF_FALSE___31 = 0,
    SF_TRUE___31 = 1,
    SFM_READ___31 = 16,
    SFM_WRITE___31 = 32,
    SFM_RDWR___31 = 48,
    SF_AMBISONIC_NONE___31 = 64,
    SF_AMBISONIC_B_FORMAT___31 = 65
} ;
#line 255
enum __anonenum__746___0 {
    SF_ERR_NO_ERROR___31 = 0,
    SF_ERR_UNRECOGNISED_FORMAT___31 = 1,
    SF_ERR_SYSTEM___31 = 2,
    SF_ERR_MALFORMED_FILE___31 = 3,
    SF_ERR_UNSUPPORTED_ENCODING___31 = 4
} ;
#line 267
enum __anonenum__747___0 {
    SF_CHANNEL_MAP_INVALID___31 = 0,
    SF_CHANNEL_MAP_MONO___31 = 1,
    SF_CHANNEL_MAP_LEFT___31 = 2,
    SF_CHANNEL_MAP_RIGHT___31 = 3,
    SF_CHANNEL_MAP_CENTER___31 = 4,
    SF_CHANNEL_MAP_FRONT_LEFT___31 = 5,
    SF_CHANNEL_MAP_FRONT_RIGHT___31 = 6,
    SF_CHANNEL_MAP_FRONT_CENTER___31 = 7,
    SF_CHANNEL_MAP_REAR_CENTER___31 = 8,
    SF_CHANNEL_MAP_REAR_LEFT___31 = 9,
    SF_CHANNEL_MAP_REAR_RIGHT___31 = 10,
    SF_CHANNEL_MAP_LFE___31 = 11,
    SF_CHANNEL_MAP_FRONT_LEFT_OF_CENTER___31 = 12,
    SF_CHANNEL_MAP_FRONT_RIGHT_OF_CENTER___31 = 13,
    SF_CHANNEL_MAP_SIDE_LEFT___31 = 14,
    SF_CHANNEL_MAP_SIDE_RIGHT___31 = 15,
    SF_CHANNEL_MAP_TOP_CENTER___31 = 16,
    SF_CHANNEL_MAP_TOP_FRONT_LEFT___31 = 17,
    SF_CHANNEL_MAP_TOP_FRONT_RIGHT___31 = 18,
    SF_CHANNEL_MAP_TOP_FRONT_CENTER___31 = 19,
    SF_CHANNEL_MAP_TOP_REAR_LEFT___31 = 20,
    SF_CHANNEL_MAP_TOP_REAR_RIGHT___31 = 21,
    SF_CHANNEL_MAP_TOP_REAR_CENTER___31 = 22
} ;
#line 352
enum __anonenum__749___0 {
    SFD_DEFAULT_LEVEL___31 = 0,
    SFD_CUSTOM_LEVEL___31 = 1073741824,
    SFD_NO_DITHER___31 = 500,
    SFD_WHITE___31 = 501,
    SFD_TRIANGULAR_PDF___31 = 502
} ;
#line 380
enum __anonenum__752___0 {
    SF_LOOP_NONE___31 = 800,
    SF_LOOP_FORWARD___31 = 801,
    SF_LOOP_BACKWARD___31 = 802,
    SF_LOOP_ALTERNATING___31 = 803
} ;
#line 121 "/root/libsndfile/src/common.h"
enum __anonenum__761___0 {
    SF_PEAK_START___31 = 42,
    SF_PEAK_END___31 = 43,
    SF_SCALE_MAX___31 = 52,
    SF_SCALE_MIN___31 = 53,
    SF_STR_ALLOW_START___31 = 256,
    SF_STR_ALLOW_END___31 = 512,
    SF_STR_LOCATE_START___31 = 1024,
    SF_STR_LOCATE_END___31 = 2048,
    SFD_TYPEMASK___31 = 268435455
} ;
#line 149
enum __anonenum__762___0 {
    SF_FORMAT_TXW___31 = 67305472,
    SF_FORMAT_DWD___31 = 67371008,
    SF_FORMAT_REX___31 = 67764224,
    SF_FORMAT_REX2___31 = 67960832,
    SF_FORMAT_KRZ___31 = 68026368,
    SF_FORMAT_WMA___31 = 68157440,
    SF_FORMAT_SHN___31 = 68222976,
    SF_FORMAT_SVX_FIB___31 = 4128,
    SF_FORMAT_SVX_EXP___31 = 4129,
    SF_FORMAT_PCM_N___31 = 4144
} ;
#line 405
enum __anonenum__768___0 {
    SFE_NO_ERROR___31 = 0,
    SFE_BAD_OPEN_FORMAT___31 = 1,
    SFE_SYSTEM___31 = 2,
    SFE_MALFORMED_FILE___31 = 3,
    SFE_UNSUPPORTED_ENCODING___31 = 4,
    SFE_ZERO_MAJOR_FORMAT___31 = 5,
    SFE_ZERO_MINOR_FORMAT___31 = 6,
    SFE_BAD_FILE___31 = 7,
    SFE_BAD_FILE_READ___31 = 8,
    SFE_OPEN_FAILED___31 = 9,
    SFE_BAD_SNDFILE_PTR___31 = 10,
    SFE_BAD_SF_INFO_PTR___31 = 11,
    SFE_BAD_SF_INCOMPLETE___31 = 12,
    SFE_BAD_FILE_PTR___31 = 13,
    SFE_BAD_INT_PTR___31 = 14,
    SFE_BAD_STAT_SIZE___31 = 15,
    SFE_MALLOC_FAILED___31 = 16,
    SFE_UNIMPLEMENTED___31 = 17,
    SFE_BAD_READ_ALIGN___31 = 18,
    SFE_BAD_WRITE_ALIGN___31 = 19,
    SFE_UNKNOWN_FORMAT___31 = 20,
    SFE_NOT_READMODE___31 = 21,
    SFE_NOT_WRITEMODE___31 = 22,
    SFE_BAD_MODE_RW___31 = 23,
    SFE_BAD_SF_INFO___31 = 24,
    SFE_BAD_OFFSET___31 = 25,
    SFE_NO_EMBED_SUPPORT___31 = 26,
    SFE_NO_EMBEDDED_RDWR___31 = 27,
    SFE_NO_PIPE_WRITE___31 = 28,
    SFE_INTERNAL___31 = 29,
    SFE_BAD_COMMAND_PARAM___31 = 30,
    SFE_BAD_ENDIAN___31 = 31,
    SFE_CHANNEL_COUNT_ZERO___31 = 32,
    SFE_CHANNEL_COUNT___31 = 33,
    SFE_BAD_VIRTUAL_IO___31 = 34,
    SFE_INTERLEAVE_MODE___31 = 35,
    SFE_INTERLEAVE_SEEK___31 = 36,
    SFE_INTERLEAVE_READ___31 = 37,
    SFE_BAD_SEEK___31 = 38,
    SFE_NOT_SEEKABLE___31 = 39,
    SFE_AMBIGUOUS_SEEK___31 = 40,
    SFE_WRONG_SEEK___31 = 41,
    SFE_SEEK_FAILED___31 = 42,
    SFE_BAD_OPEN_MODE___31 = 43,
    SFE_OPEN_PIPE_RDWR___31 = 44,
    SFE_RDWR_POSITION___31 = 45,
    SFE_RDWR_BAD_HEADER___31 = 46,
    SFE_CMD_HAS_DATA___31 = 47,
    SFE_BAD_BROADCAST_INFO_SIZE___31 = 48,
    SFE_STR_NO_SUPPORT___31 = 49,
    SFE_STR_NOT_WRITE___31 = 50,
    SFE_STR_MAX_DATA___31 = 51,
    SFE_STR_MAX_COUNT___31 = 52,
    SFE_STR_BAD_TYPE___31 = 53,
    SFE_STR_NO_ADD_END___31 = 54,
    SFE_STR_BAD_STRING___31 = 55,
    SFE_STR_WEIRD___31 = 56,
    SFE_WAV_NO_RIFF___31 = 57,
    SFE_WAV_NO_WAVE___31 = 58,
    SFE_WAV_NO_FMT___31 = 59,
    SFE_WAV_BAD_FMT___31 = 60,
    SFE_WAV_FMT_SHORT___31 = 61,
    SFE_WAV_BAD_FACT___31 = 62,
    SFE_WAV_BAD_PEAK___31 = 63,
    SFE_WAV_PEAK_B4_FMT___31 = 64,
    SFE_WAV_BAD_FORMAT___31 = 65,
    SFE_WAV_BAD_BLOCKALIGN___31 = 66,
    SFE_WAV_NO_DATA___31 = 67,
    SFE_WAV_BAD_LIST___31 = 68,
    SFE_WAV_ADPCM_NOT4BIT___31 = 69,
    SFE_WAV_ADPCM_CHANNELS___31 = 70,
    SFE_WAV_GSM610_FORMAT___31 = 71,
    SFE_WAV_UNKNOWN_CHUNK___31 = 72,
    SFE_WAV_WVPK_DATA___31 = 73,
    SFE_AIFF_NO_FORM___31 = 74,
    SFE_AIFF_AIFF_NO_FORM___31 = 75,
    SFE_AIFF_COMM_NO_FORM___31 = 76,
    SFE_AIFF_SSND_NO_COMM___31 = 77,
    SFE_AIFF_UNKNOWN_CHUNK___31 = 78,
    SFE_AIFF_COMM_CHUNK_SIZE___31 = 79,
    SFE_AIFF_BAD_COMM_CHUNK___31 = 80,
    SFE_AIFF_PEAK_B4_COMM___31 = 81,
    SFE_AIFF_BAD_PEAK___31 = 82,
    SFE_AIFF_NO_SSND___31 = 83,
    SFE_AIFF_NO_DATA___31 = 84,
    SFE_AIFF_RW_SSND_NOT_LAST___31 = 85,
    SFE_AU_UNKNOWN_FORMAT___31 = 86,
    SFE_AU_NO_DOTSND___31 = 87,
    SFE_AU_EMBED_BAD_LEN___31 = 88,
    SFE_RAW_READ_BAD_SPEC___31 = 89,
    SFE_RAW_BAD_BITWIDTH___31 = 90,
    SFE_RAW_BAD_FORMAT___31 = 91,
    SFE_PAF_NO_MARKER___31 = 92,
    SFE_PAF_VERSION___31 = 93,
    SFE_PAF_UNKNOWN_FORMAT___31 = 94,
    SFE_PAF_SHORT_HEADER___31 = 95,
    SFE_SVX_NO_FORM___31 = 96,
    SFE_SVX_NO_BODY___31 = 97,
    SFE_SVX_NO_DATA___31 = 98,
    SFE_SVX_BAD_COMP___31 = 99,
    SFE_SVX_BAD_NAME_LENGTH___31 = 100,
    SFE_NIST_BAD_HEADER___31 = 101,
    SFE_NIST_CRLF_CONVERISON___31 = 102,
    SFE_NIST_BAD_ENCODING___31 = 103,
    SFE_VOC_NO_CREATIVE___31 = 104,
    SFE_VOC_BAD_FORMAT___31 = 105,
    SFE_VOC_BAD_VERSION___31 = 106,
    SFE_VOC_BAD_MARKER___31 = 107,
    SFE_VOC_BAD_SECTIONS___31 = 108,
    SFE_VOC_MULTI_SAMPLERATE___31 = 109,
    SFE_VOC_MULTI_SECTION___31 = 110,
    SFE_VOC_MULTI_PARAM___31 = 111,
    SFE_VOC_SECTION_COUNT___31 = 112,
    SFE_VOC_NO_PIPE___31 = 113,
    SFE_IRCAM_NO_MARKER___31 = 114,
    SFE_IRCAM_BAD_CHANNELS___31 = 115,
    SFE_IRCAM_UNKNOWN_FORMAT___31 = 116,
    SFE_W64_64_BIT___31 = 117,
    SFE_W64_NO_RIFF___31 = 118,
    SFE_W64_NO_WAVE___31 = 119,
    SFE_W64_NO_DATA___31 = 120,
    SFE_W64_ADPCM_NOT4BIT___31 = 121,
    SFE_W64_ADPCM_CHANNELS___31 = 122,
    SFE_W64_GSM610_FORMAT___31 = 123,
    SFE_MAT4_BAD_NAME___31 = 124,
    SFE_MAT4_NO_SAMPLERATE___31 = 125,
    SFE_MAT5_BAD_ENDIAN___31 = 126,
    SFE_MAT5_NO_BLOCK___31 = 127,
    SFE_MAT5_SAMPLE_RATE___31 = 128,
    SFE_PVF_NO_PVF1___31 = 129,
    SFE_PVF_BAD_HEADER___31 = 130,
    SFE_PVF_BAD_BITWIDTH___31 = 131,
    SFE_DWVW_BAD_BITWIDTH___31 = 132,
    SFE_G72X_NOT_MONO___31 = 133,
    SFE_XI_BAD_HEADER___31 = 134,
    SFE_XI_EXCESS_SAMPLES___31 = 135,
    SFE_XI_NO_PIPE___31 = 136,
    SFE_HTK_NO_PIPE___31 = 137,
    SFE_SDS_NOT_SDS___31 = 138,
    SFE_SDS_BAD_BIT_WIDTH___31 = 139,
    SFE_SD2_FD_DISALLOWED___31 = 140,
    SFE_SD2_BAD_DATA_OFFSET___31 = 141,
    SFE_SD2_BAD_MAP_OFFSET___31 = 142,
    SFE_SD2_BAD_DATA_LENGTH___31 = 143,
    SFE_SD2_BAD_MAP_LENGTH___31 = 144,
    SFE_SD2_BAD_RSRC___31 = 145,
    SFE_SD2_BAD_SAMPLE_SIZE___31 = 146,
    SFE_FLAC_BAD_HEADER___31 = 147,
    SFE_FLAC_NEW_DECODER___31 = 148,
    SFE_FLAC_INIT_DECODER___31 = 149,
    SFE_FLAC_LOST_SYNC___31 = 150,
    SFE_FLAC_BAD_SAMPLE_RATE___31 = 151,
    SFE_FLAC_UNKOWN_ERROR___31 = 152,
    SFE_WVE_NOT_WVE___31 = 153,
    SFE_WVE_NO_PIPE___31 = 154,
    SFE_VORBIS_ENCODER_BUG___31 = 155,
    SFE_RF64_NOT_RF64___31 = 156,
    SFE_MAX_ERROR___31 = 157
} ;
#line 823
enum __anonenum__772___0 {
    SFC_TEST_AIFF_ADD_INST_CHUNK___31 = 8192,
    SFC_TEST_WAV_ADD_INFO_CHUNK___31 = 8208
} ;
#line 46 "/root/libsndfile/src/sndfile.h"
enum __anonenum__819 {
    SF_FORMAT_WAV___32 = 65536,
    SF_FORMAT_AIFF___32 = 131072,
    SF_FORMAT_AU___32 = 196608,
    SF_FORMAT_RAW___32 = 262144,
    SF_FORMAT_PAF___32 = 327680,
    SF_FORMAT_SVX___32 = 393216,
    SF_FORMAT_NIST___32 = 458752,
    SF_FORMAT_VOC___32 = 524288,
    SF_FORMAT_IRCAM___32 = 655360,
    SF_FORMAT_W64___32 = 720896,
    SF_FORMAT_MAT4___32 = 786432,
    SF_FORMAT_MAT5___32 = 851968,
    SF_FORMAT_PVF___32 = 917504,
    SF_FORMAT_XI___32 = 983040,
    SF_FORMAT_HTK___32 = 1048576,
    SF_FORMAT_SDS___32 = 1114112,
    SF_FORMAT_AVR___32 = 1179648,
    SF_FORMAT_WAVEX___32 = 1245184,
    SF_FORMAT_SD2___32 = 1441792,
    SF_FORMAT_FLAC___32 = 1507328,
    SF_FORMAT_CAF___32 = 1572864,
    SF_FORMAT_WVE___32 = 1638400,
    SF_FORMAT_OGG___32 = 2097152,
    SF_FORMAT_MPC2K___32 = 2162688,
    SF_FORMAT_RF64___32 = 2228224,
    SF_FORMAT_PCM_S8___32 = 1,
    SF_FORMAT_PCM_16___32 = 2,
    SF_FORMAT_PCM_24___32 = 3,
    SF_FORMAT_PCM_32___32 = 4,
    SF_FORMAT_PCM_U8___32 = 5,
    SF_FORMAT_FLOAT___32 = 6,
    SF_FORMAT_DOUBLE___32 = 7,
    SF_FORMAT_ULAW___32 = 16,
    SF_FORMAT_ALAW___32 = 17,
    SF_FORMAT_IMA_ADPCM___32 = 18,
    SF_FORMAT_MS_ADPCM___32 = 19,
    SF_FORMAT_GSM610___32 = 32,
    SF_FORMAT_VOX_ADPCM___32 = 33,
    SF_FORMAT_G721_32___32 = 48,
    SF_FORMAT_G723_24___32 = 49,
    SF_FORMAT_G723_40___32 = 50,
    SF_FORMAT_DWVW_12___32 = 64,
    SF_FORMAT_DWVW_16___32 = 65,
    SF_FORMAT_DWVW_24___32 = 66,
    SF_FORMAT_DWVW_N___32 = 67,
    SF_FORMAT_DPCM_8___32 = 80,
    SF_FORMAT_DPCM_16___32 = 81,
    SF_FORMAT_VORBIS___32 = 96,
    SF_ENDIAN_FILE___32 = 0,
    SF_ENDIAN_LITTLE___32 = 268435456,
    SF_ENDIAN_BIG___32 = 536870912,
    SF_ENDIAN_CPU___32 = 805306368,
    SF_FORMAT_SUBMASK___32 = 65535,
    SF_FORMAT_TYPEMASK___32 = 268369920,
    SF_FORMAT_ENDMASK___32 = 805306368
} ;
#line 126
enum __anonenum__820 {
    SFC_GET_LIB_VERSION___32 = 4096,
    SFC_GET_LOG_INFO___32 = 4097,
    SFC_GET_CURRENT_SF_INFO___32 = 4098,
    SFC_GET_NORM_DOUBLE___32 = 4112,
    SFC_GET_NORM_FLOAT___32 = 4113,
    SFC_SET_NORM_DOUBLE___32 = 4114,
    SFC_SET_NORM_FLOAT___32 = 4115,
    SFC_SET_SCALE_FLOAT_INT_READ___32 = 4116,
    SFC_SET_SCALE_INT_FLOAT_WRITE___32 = 4117,
    SFC_GET_SIMPLE_FORMAT_COUNT___32 = 4128,
    SFC_GET_SIMPLE_FORMAT___32 = 4129,
    SFC_GET_FORMAT_INFO___32 = 4136,
    SFC_GET_FORMAT_MAJOR_COUNT___32 = 4144,
    SFC_GET_FORMAT_MAJOR___32 = 4145,
    SFC_GET_FORMAT_SUBTYPE_COUNT___32 = 4146,
    SFC_GET_FORMAT_SUBTYPE___32 = 4147,
    SFC_CALC_SIGNAL_MAX___32 = 4160,
    SFC_CALC_NORM_SIGNAL_MAX___32 = 4161,
    SFC_CALC_MAX_ALL_CHANNELS___32 = 4162,
    SFC_CALC_NORM_MAX_ALL_CHANNELS___32 = 4163,
    SFC_GET_SIGNAL_MAX___32 = 4164,
    SFC_GET_MAX_ALL_CHANNELS___32 = 4165,
    SFC_SET_ADD_PEAK_CHUNK___32 = 4176,
    SFC_SET_ADD_HEADER_PAD_CHUNK___32 = 4177,
    SFC_UPDATE_HEADER_NOW___32 = 4192,
    SFC_SET_UPDATE_HEADER_AUTO___32 = 4193,
    SFC_FILE_TRUNCATE___32 = 4224,
    SFC_SET_RAW_START_OFFSET___32 = 4240,
    SFC_SET_DITHER_ON_WRITE___32 = 4256,
    SFC_SET_DITHER_ON_READ___32 = 4257,
    SFC_GET_DITHER_INFO_COUNT___32 = 4258,
    SFC_GET_DITHER_INFO___32 = 4259,
    SFC_GET_EMBED_FILE_INFO___32 = 4272,
    SFC_SET_CLIPPING___32 = 4288,
    SFC_GET_CLIPPING___32 = 4289,
    SFC_GET_INSTRUMENT___32 = 4304,
    SFC_SET_INSTRUMENT___32 = 4305,
    SFC_GET_LOOP_INFO___32 = 4320,
    SFC_GET_BROADCAST_INFO___32 = 4336,
    SFC_SET_BROADCAST_INFO___32 = 4337,
    SFC_GET_CHANNEL_MAP_INFO___32 = 4352,
    SFC_SET_CHANNEL_MAP_INFO___32 = 4353,
    SFC_RAW_DATA_NEEDS_ENDSWAP___32 = 4368,
    SFC_WAVEX_SET_AMBISONIC___32 = 4608,
    SFC_WAVEX_GET_AMBISONIC___32 = 4609,
    SFC_SET_VBR_ENCODING_QUALITY___32 = 4864,
    SFC_TEST_IEEE_FLOAT_REPLACE___32 = 24577,
    SFC_SET_ADD_DITHER_ON_WRITE___32 = 4208,
    SFC_SET_ADD_DITHER_ON_READ___32 = 4209
} ;
#line 216
enum __anonenum__821 {
    SF_STR_TITLE___32 = 1,
    SF_STR_COPYRIGHT___32 = 2,
    SF_STR_SOFTWARE___32 = 3,
    SF_STR_ARTIST___32 = 4,
    SF_STR_COMMENT___32 = 5,
    SF_STR_DATE___32 = 6,
    SF_STR_ALBUM___32 = 7,
    SF_STR_LICENSE___32 = 8
} ;
#line 235
enum __anonenum__822 {
    SF_FALSE___32 = 0,
    SF_TRUE___32 = 1,
    SFM_READ___32 = 16,
    SFM_WRITE___32 = 32,
    SFM_RDWR___32 = 48,
    SF_AMBISONIC_NONE___32 = 64,
    SF_AMBISONIC_B_FORMAT___32 = 65
} ;
#line 255
enum __anonenum__823 {
    SF_ERR_NO_ERROR___32 = 0,
    SF_ERR_UNRECOGNISED_FORMAT___32 = 1,
    SF_ERR_SYSTEM___32 = 2,
    SF_ERR_MALFORMED_FILE___32 = 3,
    SF_ERR_UNSUPPORTED_ENCODING___32 = 4
} ;
#line 267
enum __anonenum__824 {
    SF_CHANNEL_MAP_INVALID___32 = 0,
    SF_CHANNEL_MAP_MONO___32 = 1,
    SF_CHANNEL_MAP_LEFT___32 = 2,
    SF_CHANNEL_MAP_RIGHT___32 = 3,
    SF_CHANNEL_MAP_CENTER___32 = 4,
    SF_CHANNEL_MAP_FRONT_LEFT___32 = 5,
    SF_CHANNEL_MAP_FRONT_RIGHT___32 = 6,
    SF_CHANNEL_MAP_FRONT_CENTER___32 = 7,
    SF_CHANNEL_MAP_REAR_CENTER___32 = 8,
    SF_CHANNEL_MAP_REAR_LEFT___32 = 9,
    SF_CHANNEL_MAP_REAR_RIGHT___32 = 10,
    SF_CHANNEL_MAP_LFE___32 = 11,
    SF_CHANNEL_MAP_FRONT_LEFT_OF_CENTER___32 = 12,
    SF_CHANNEL_MAP_FRONT_RIGHT_OF_CENTER___32 = 13,
    SF_CHANNEL_MAP_SIDE_LEFT___32 = 14,
    SF_CHANNEL_MAP_SIDE_RIGHT___32 = 15,
    SF_CHANNEL_MAP_TOP_CENTER___32 = 16,
    SF_CHANNEL_MAP_TOP_FRONT_LEFT___32 = 17,
    SF_CHANNEL_MAP_TOP_FRONT_RIGHT___32 = 18,
    SF_CHANNEL_MAP_TOP_FRONT_CENTER___32 = 19,
    SF_CHANNEL_MAP_TOP_REAR_LEFT___32 = 20,
    SF_CHANNEL_MAP_TOP_REAR_RIGHT___32 = 21,
    SF_CHANNEL_MAP_TOP_REAR_CENTER___32 = 22
} ;
#line 352
enum __anonenum__826 {
    SFD_DEFAULT_LEVEL___32 = 0,
    SFD_CUSTOM_LEVEL___32 = 1073741824,
    SFD_NO_DITHER___32 = 500,
    SFD_WHITE___32 = 501,
    SFD_TRIANGULAR_PDF___32 = 502
} ;
#line 380
enum __anonenum__829 {
    SF_LOOP_NONE___32 = 800,
    SF_LOOP_FORWARD___32 = 801,
    SF_LOOP_BACKWARD___32 = 802,
    SF_LOOP_ALTERNATING___32 = 803
} ;
#line 121 "/root/libsndfile/src/common.h"
enum __anonenum__838 {
    SF_PEAK_START___32 = 42,
    SF_PEAK_END___32 = 43,
    SF_SCALE_MAX___32 = 52,
    SF_SCALE_MIN___32 = 53,
    SF_STR_ALLOW_START___32 = 256,
    SF_STR_ALLOW_END___32 = 512,
    SF_STR_LOCATE_START___32 = 1024,
    SF_STR_LOCATE_END___32 = 2048,
    SFD_TYPEMASK___32 = 268435455
} ;
#line 149
enum __anonenum__839 {
    SF_FORMAT_TXW___32 = 67305472,
    SF_FORMAT_DWD___32 = 67371008,
    SF_FORMAT_REX___32 = 67764224,
    SF_FORMAT_REX2___32 = 67960832,
    SF_FORMAT_KRZ___32 = 68026368,
    SF_FORMAT_WMA___32 = 68157440,
    SF_FORMAT_SHN___32 = 68222976,
    SF_FORMAT_SVX_FIB___32 = 4128,
    SF_FORMAT_SVX_EXP___32 = 4129,
    SF_FORMAT_PCM_N___32 = 4144
} ;
#line 405
enum __anonenum__845 {
    SFE_NO_ERROR___32 = 0,
    SFE_BAD_OPEN_FORMAT___32 = 1,
    SFE_SYSTEM___32 = 2,
    SFE_MALFORMED_FILE___32 = 3,
    SFE_UNSUPPORTED_ENCODING___32 = 4,
    SFE_ZERO_MAJOR_FORMAT___32 = 5,
    SFE_ZERO_MINOR_FORMAT___32 = 6,
    SFE_BAD_FILE___32 = 7,
    SFE_BAD_FILE_READ___32 = 8,
    SFE_OPEN_FAILED___32 = 9,
    SFE_BAD_SNDFILE_PTR___32 = 10,
    SFE_BAD_SF_INFO_PTR___32 = 11,
    SFE_BAD_SF_INCOMPLETE___32 = 12,
    SFE_BAD_FILE_PTR___32 = 13,
    SFE_BAD_INT_PTR___32 = 14,
    SFE_BAD_STAT_SIZE___32 = 15,
    SFE_MALLOC_FAILED___32 = 16,
    SFE_UNIMPLEMENTED___32 = 17,
    SFE_BAD_READ_ALIGN___32 = 18,
    SFE_BAD_WRITE_ALIGN___32 = 19,
    SFE_UNKNOWN_FORMAT___32 = 20,
    SFE_NOT_READMODE___32 = 21,
    SFE_NOT_WRITEMODE___32 = 22,
    SFE_BAD_MODE_RW___32 = 23,
    SFE_BAD_SF_INFO___32 = 24,
    SFE_BAD_OFFSET___32 = 25,
    SFE_NO_EMBED_SUPPORT___32 = 26,
    SFE_NO_EMBEDDED_RDWR___32 = 27,
    SFE_NO_PIPE_WRITE___32 = 28,
    SFE_INTERNAL___32 = 29,
    SFE_BAD_COMMAND_PARAM___32 = 30,
    SFE_BAD_ENDIAN___32 = 31,
    SFE_CHANNEL_COUNT_ZERO___32 = 32,
    SFE_CHANNEL_COUNT___32 = 33,
    SFE_BAD_VIRTUAL_IO___32 = 34,
    SFE_INTERLEAVE_MODE___32 = 35,
    SFE_INTERLEAVE_SEEK___32 = 36,
    SFE_INTERLEAVE_READ___32 = 37,
    SFE_BAD_SEEK___32 = 38,
    SFE_NOT_SEEKABLE___32 = 39,
    SFE_AMBIGUOUS_SEEK___32 = 40,
    SFE_WRONG_SEEK___32 = 41,
    SFE_SEEK_FAILED___32 = 42,
    SFE_BAD_OPEN_MODE___32 = 43,
    SFE_OPEN_PIPE_RDWR___32 = 44,
    SFE_RDWR_POSITION___32 = 45,
    SFE_RDWR_BAD_HEADER___32 = 46,
    SFE_CMD_HAS_DATA___32 = 47,
    SFE_BAD_BROADCAST_INFO_SIZE___32 = 48,
    SFE_STR_NO_SUPPORT___32 = 49,
    SFE_STR_NOT_WRITE___32 = 50,
    SFE_STR_MAX_DATA___32 = 51,
    SFE_STR_MAX_COUNT___32 = 52,
    SFE_STR_BAD_TYPE___32 = 53,
    SFE_STR_NO_ADD_END___32 = 54,
    SFE_STR_BAD_STRING___32 = 55,
    SFE_STR_WEIRD___32 = 56,
    SFE_WAV_NO_RIFF___32 = 57,
    SFE_WAV_NO_WAVE___32 = 58,
    SFE_WAV_NO_FMT___32 = 59,
    SFE_WAV_BAD_FMT___32 = 60,
    SFE_WAV_FMT_SHORT___32 = 61,
    SFE_WAV_BAD_FACT___32 = 62,
    SFE_WAV_BAD_PEAK___32 = 63,
    SFE_WAV_PEAK_B4_FMT___32 = 64,
    SFE_WAV_BAD_FORMAT___32 = 65,
    SFE_WAV_BAD_BLOCKALIGN___32 = 66,
    SFE_WAV_NO_DATA___32 = 67,
    SFE_WAV_BAD_LIST___32 = 68,
    SFE_WAV_ADPCM_NOT4BIT___32 = 69,
    SFE_WAV_ADPCM_CHANNELS___32 = 70,
    SFE_WAV_GSM610_FORMAT___32 = 71,
    SFE_WAV_UNKNOWN_CHUNK___32 = 72,
    SFE_WAV_WVPK_DATA___32 = 73,
    SFE_AIFF_NO_FORM___32 = 74,
    SFE_AIFF_AIFF_NO_FORM___32 = 75,
    SFE_AIFF_COMM_NO_FORM___32 = 76,
    SFE_AIFF_SSND_NO_COMM___32 = 77,
    SFE_AIFF_UNKNOWN_CHUNK___32 = 78,
    SFE_AIFF_COMM_CHUNK_SIZE___32 = 79,
    SFE_AIFF_BAD_COMM_CHUNK___32 = 80,
    SFE_AIFF_PEAK_B4_COMM___32 = 81,
    SFE_AIFF_BAD_PEAK___32 = 82,
    SFE_AIFF_NO_SSND___32 = 83,
    SFE_AIFF_NO_DATA___32 = 84,
    SFE_AIFF_RW_SSND_NOT_LAST___32 = 85,
    SFE_AU_UNKNOWN_FORMAT___32 = 86,
    SFE_AU_NO_DOTSND___32 = 87,
    SFE_AU_EMBED_BAD_LEN___32 = 88,
    SFE_RAW_READ_BAD_SPEC___32 = 89,
    SFE_RAW_BAD_BITWIDTH___32 = 90,
    SFE_RAW_BAD_FORMAT___32 = 91,
    SFE_PAF_NO_MARKER___32 = 92,
    SFE_PAF_VERSION___32 = 93,
    SFE_PAF_UNKNOWN_FORMAT___32 = 94,
    SFE_PAF_SHORT_HEADER___32 = 95,
    SFE_SVX_NO_FORM___32 = 96,
    SFE_SVX_NO_BODY___32 = 97,
    SFE_SVX_NO_DATA___32 = 98,
    SFE_SVX_BAD_COMP___32 = 99,
    SFE_SVX_BAD_NAME_LENGTH___32 = 100,
    SFE_NIST_BAD_HEADER___32 = 101,
    SFE_NIST_CRLF_CONVERISON___32 = 102,
    SFE_NIST_BAD_ENCODING___32 = 103,
    SFE_VOC_NO_CREATIVE___32 = 104,
    SFE_VOC_BAD_FORMAT___32 = 105,
    SFE_VOC_BAD_VERSION___32 = 106,
    SFE_VOC_BAD_MARKER___32 = 107,
    SFE_VOC_BAD_SECTIONS___32 = 108,
    SFE_VOC_MULTI_SAMPLERATE___32 = 109,
    SFE_VOC_MULTI_SECTION___32 = 110,
    SFE_VOC_MULTI_PARAM___32 = 111,
    SFE_VOC_SECTION_COUNT___32 = 112,
    SFE_VOC_NO_PIPE___32 = 113,
    SFE_IRCAM_NO_MARKER___32 = 114,
    SFE_IRCAM_BAD_CHANNELS___32 = 115,
    SFE_IRCAM_UNKNOWN_FORMAT___32 = 116,
    SFE_W64_64_BIT___32 = 117,
    SFE_W64_NO_RIFF___32 = 118,
    SFE_W64_NO_WAVE___32 = 119,
    SFE_W64_NO_DATA___32 = 120,
    SFE_W64_ADPCM_NOT4BIT___32 = 121,
    SFE_W64_ADPCM_CHANNELS___32 = 122,
    SFE_W64_GSM610_FORMAT___32 = 123,
    SFE_MAT4_BAD_NAME___32 = 124,
    SFE_MAT4_NO_SAMPLERATE___32 = 125,
    SFE_MAT5_BAD_ENDIAN___32 = 126,
    SFE_MAT5_NO_BLOCK___32 = 127,
    SFE_MAT5_SAMPLE_RATE___32 = 128,
    SFE_PVF_NO_PVF1___32 = 129,
    SFE_PVF_BAD_HEADER___32 = 130,
    SFE_PVF_BAD_BITWIDTH___32 = 131,
    SFE_DWVW_BAD_BITWIDTH___32 = 132,
    SFE_G72X_NOT_MONO___32 = 133,
    SFE_XI_BAD_HEADER___32 = 134,
    SFE_XI_EXCESS_SAMPLES___32 = 135,
    SFE_XI_NO_PIPE___32 = 136,
    SFE_HTK_NO_PIPE___32 = 137,
    SFE_SDS_NOT_SDS___32 = 138,
    SFE_SDS_BAD_BIT_WIDTH___32 = 139,
    SFE_SD2_FD_DISALLOWED___32 = 140,
    SFE_SD2_BAD_DATA_OFFSET___32 = 141,
    SFE_SD2_BAD_MAP_OFFSET___32 = 142,
    SFE_SD2_BAD_DATA_LENGTH___32 = 143,
    SFE_SD2_BAD_MAP_LENGTH___32 = 144,
    SFE_SD2_BAD_RSRC___32 = 145,
    SFE_SD2_BAD_SAMPLE_SIZE___32 = 146,
    SFE_FLAC_BAD_HEADER___32 = 147,
    SFE_FLAC_NEW_DECODER___32 = 148,
    SFE_FLAC_INIT_DECODER___32 = 149,
    SFE_FLAC_LOST_SYNC___32 = 150,
    SFE_FLAC_BAD_SAMPLE_RATE___32 = 151,
    SFE_FLAC_UNKOWN_ERROR___32 = 152,
    SFE_WVE_NOT_WVE___32 = 153,
    SFE_WVE_NO_PIPE___32 = 154,
    SFE_VORBIS_ENCODER_BUG___32 = 155,
    SFE_RF64_NOT_RF64___32 = 156,
    SFE_MAX_ERROR___32 = 157
} ;
#line 823
enum __anonenum__849 {
    SFC_TEST_AIFF_ADD_INST_CHUNK___32 = 8192,
    SFC_TEST_WAV_ADD_INFO_CHUNK___32 = 8208
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__510___3 {
    _ISupper___12 = 256,
    _ISlower___12 = 512,
    _ISalpha___12 = 1024,
    _ISdigit___12 = 2048,
    _ISxdigit___12 = 4096,
    _ISspace___12 = 8192,
    _ISprint___12 = 16384,
    _ISgraph___12 = 32768,
    _ISblank___12 = 1,
    _IScntrl___12 = 2,
    _ISpunct___12 = 4,
    _ISalnum___12 = 8
} ;
#line 46 "/root/libsndfile/src/sndfile.h"
enum __anonenum__524___3 {
    SF_FORMAT_WAV___33 = 65536,
    SF_FORMAT_AIFF___33 = 131072,
    SF_FORMAT_AU___33 = 196608,
    SF_FORMAT_RAW___33 = 262144,
    SF_FORMAT_PAF___33 = 327680,
    SF_FORMAT_SVX___33 = 393216,
    SF_FORMAT_NIST___33 = 458752,
    SF_FORMAT_VOC___33 = 524288,
    SF_FORMAT_IRCAM___33 = 655360,
    SF_FORMAT_W64___33 = 720896,
    SF_FORMAT_MAT4___33 = 786432,
    SF_FORMAT_MAT5___33 = 851968,
    SF_FORMAT_PVF___33 = 917504,
    SF_FORMAT_XI___33 = 983040,
    SF_FORMAT_HTK___33 = 1048576,
    SF_FORMAT_SDS___33 = 1114112,
    SF_FORMAT_AVR___33 = 1179648,
    SF_FORMAT_WAVEX___33 = 1245184,
    SF_FORMAT_SD2___33 = 1441792,
    SF_FORMAT_FLAC___33 = 1507328,
    SF_FORMAT_CAF___33 = 1572864,
    SF_FORMAT_WVE___33 = 1638400,
    SF_FORMAT_OGG___33 = 2097152,
    SF_FORMAT_MPC2K___33 = 2162688,
    SF_FORMAT_RF64___33 = 2228224,
    SF_FORMAT_PCM_S8___33 = 1,
    SF_FORMAT_PCM_16___33 = 2,
    SF_FORMAT_PCM_24___33 = 3,
    SF_FORMAT_PCM_32___33 = 4,
    SF_FORMAT_PCM_U8___33 = 5,
    SF_FORMAT_FLOAT___33 = 6,
    SF_FORMAT_DOUBLE___33 = 7,
    SF_FORMAT_ULAW___33 = 16,
    SF_FORMAT_ALAW___33 = 17,
    SF_FORMAT_IMA_ADPCM___33 = 18,
    SF_FORMAT_MS_ADPCM___33 = 19,
    SF_FORMAT_GSM610___33 = 32,
    SF_FORMAT_VOX_ADPCM___33 = 33,
    SF_FORMAT_G721_32___33 = 48,
    SF_FORMAT_G723_24___33 = 49,
    SF_FORMAT_G723_40___33 = 50,
    SF_FORMAT_DWVW_12___33 = 64,
    SF_FORMAT_DWVW_16___33 = 65,
    SF_FORMAT_DWVW_24___33 = 66,
    SF_FORMAT_DWVW_N___33 = 67,
    SF_FORMAT_DPCM_8___33 = 80,
    SF_FORMAT_DPCM_16___33 = 81,
    SF_FORMAT_VORBIS___33 = 96,
    SF_ENDIAN_FILE___33 = 0,
    SF_ENDIAN_LITTLE___33 = 268435456,
    SF_ENDIAN_BIG___33 = 536870912,
    SF_ENDIAN_CPU___33 = 805306368,
    SF_FORMAT_SUBMASK___33 = 65535,
    SF_FORMAT_TYPEMASK___33 = 268369920,
    SF_FORMAT_ENDMASK___33 = 805306368
} ;
#line 126
enum __anonenum__525___3 {
    SFC_GET_LIB_VERSION___33 = 4096,
    SFC_GET_LOG_INFO___33 = 4097,
    SFC_GET_CURRENT_SF_INFO___33 = 4098,
    SFC_GET_NORM_DOUBLE___33 = 4112,
    SFC_GET_NORM_FLOAT___33 = 4113,
    SFC_SET_NORM_DOUBLE___33 = 4114,
    SFC_SET_NORM_FLOAT___33 = 4115,
    SFC_SET_SCALE_FLOAT_INT_READ___33 = 4116,
    SFC_SET_SCALE_INT_FLOAT_WRITE___33 = 4117,
    SFC_GET_SIMPLE_FORMAT_COUNT___33 = 4128,
    SFC_GET_SIMPLE_FORMAT___33 = 4129,
    SFC_GET_FORMAT_INFO___33 = 4136,
    SFC_GET_FORMAT_MAJOR_COUNT___33 = 4144,
    SFC_GET_FORMAT_MAJOR___33 = 4145,
    SFC_GET_FORMAT_SUBTYPE_COUNT___33 = 4146,
    SFC_GET_FORMAT_SUBTYPE___33 = 4147,
    SFC_CALC_SIGNAL_MAX___33 = 4160,
    SFC_CALC_NORM_SIGNAL_MAX___33 = 4161,
    SFC_CALC_MAX_ALL_CHANNELS___33 = 4162,
    SFC_CALC_NORM_MAX_ALL_CHANNELS___33 = 4163,
    SFC_GET_SIGNAL_MAX___33 = 4164,
    SFC_GET_MAX_ALL_CHANNELS___33 = 4165,
    SFC_SET_ADD_PEAK_CHUNK___33 = 4176,
    SFC_SET_ADD_HEADER_PAD_CHUNK___33 = 4177,
    SFC_UPDATE_HEADER_NOW___33 = 4192,
    SFC_SET_UPDATE_HEADER_AUTO___33 = 4193,
    SFC_FILE_TRUNCATE___33 = 4224,
    SFC_SET_RAW_START_OFFSET___33 = 4240,
    SFC_SET_DITHER_ON_WRITE___33 = 4256,
    SFC_SET_DITHER_ON_READ___33 = 4257,
    SFC_GET_DITHER_INFO_COUNT___33 = 4258,
    SFC_GET_DITHER_INFO___33 = 4259,
    SFC_GET_EMBED_FILE_INFO___33 = 4272,
    SFC_SET_CLIPPING___33 = 4288,
    SFC_GET_CLIPPING___33 = 4289,
    SFC_GET_INSTRUMENT___33 = 4304,
    SFC_SET_INSTRUMENT___33 = 4305,
    SFC_GET_LOOP_INFO___33 = 4320,
    SFC_GET_BROADCAST_INFO___33 = 4336,
    SFC_SET_BROADCAST_INFO___33 = 4337,
    SFC_GET_CHANNEL_MAP_INFO___33 = 4352,
    SFC_SET_CHANNEL_MAP_INFO___33 = 4353,
    SFC_RAW_DATA_NEEDS_ENDSWAP___33 = 4368,
    SFC_WAVEX_SET_AMBISONIC___33 = 4608,
    SFC_WAVEX_GET_AMBISONIC___33 = 4609,
    SFC_SET_VBR_ENCODING_QUALITY___33 = 4864,
    SFC_TEST_IEEE_FLOAT_REPLACE___33 = 24577,
    SFC_SET_ADD_DITHER_ON_WRITE___33 = 4208,
    SFC_SET_ADD_DITHER_ON_READ___33 = 4209
} ;
#line 216
enum __anonenum__526___3 {
    SF_STR_TITLE___33 = 1,
    SF_STR_COPYRIGHT___33 = 2,
    SF_STR_SOFTWARE___33 = 3,
    SF_STR_ARTIST___33 = 4,
    SF_STR_COMMENT___33 = 5,
    SF_STR_DATE___33 = 6,
    SF_STR_ALBUM___33 = 7,
    SF_STR_LICENSE___33 = 8
} ;
#line 235
enum __anonenum__527___3 {
    SF_FALSE___33 = 0,
    SF_TRUE___33 = 1,
    SFM_READ___33 = 16,
    SFM_WRITE___33 = 32,
    SFM_RDWR___33 = 48,
    SF_AMBISONIC_NONE___33 = 64,
    SF_AMBISONIC_B_FORMAT___33 = 65
} ;
#line 255
enum __anonenum__528___3 {
    SF_ERR_NO_ERROR___33 = 0,
    SF_ERR_UNRECOGNISED_FORMAT___33 = 1,
    SF_ERR_SYSTEM___33 = 2,
    SF_ERR_MALFORMED_FILE___33 = 3,
    SF_ERR_UNSUPPORTED_ENCODING___33 = 4
} ;
#line 267
enum __anonenum__529___3 {
    SF_CHANNEL_MAP_INVALID___33 = 0,
    SF_CHANNEL_MAP_MONO___33 = 1,
    SF_CHANNEL_MAP_LEFT___33 = 2,
    SF_CHANNEL_MAP_RIGHT___33 = 3,
    SF_CHANNEL_MAP_CENTER___33 = 4,
    SF_CHANNEL_MAP_FRONT_LEFT___33 = 5,
    SF_CHANNEL_MAP_FRONT_RIGHT___33 = 6,
    SF_CHANNEL_MAP_FRONT_CENTER___33 = 7,
    SF_CHANNEL_MAP_REAR_CENTER___33 = 8,
    SF_CHANNEL_MAP_REAR_LEFT___33 = 9,
    SF_CHANNEL_MAP_REAR_RIGHT___33 = 10,
    SF_CHANNEL_MAP_LFE___33 = 11,
    SF_CHANNEL_MAP_FRONT_LEFT_OF_CENTER___33 = 12,
    SF_CHANNEL_MAP_FRONT_RIGHT_OF_CENTER___33 = 13,
    SF_CHANNEL_MAP_SIDE_LEFT___33 = 14,
    SF_CHANNEL_MAP_SIDE_RIGHT___33 = 15,
    SF_CHANNEL_MAP_TOP_CENTER___33 = 16,
    SF_CHANNEL_MAP_TOP_FRONT_LEFT___33 = 17,
    SF_CHANNEL_MAP_TOP_FRONT_RIGHT___33 = 18,
    SF_CHANNEL_MAP_TOP_FRONT_CENTER___33 = 19,
    SF_CHANNEL_MAP_TOP_REAR_LEFT___33 = 20,
    SF_CHANNEL_MAP_TOP_REAR_RIGHT___33 = 21,
    SF_CHANNEL_MAP_TOP_REAR_CENTER___33 = 22
} ;
#line 352
enum __anonenum__531___3 {
    SFD_DEFAULT_LEVEL___33 = 0,
    SFD_CUSTOM_LEVEL___33 = 1073741824,
    SFD_NO_DITHER___33 = 500,
    SFD_WHITE___33 = 501,
    SFD_TRIANGULAR_PDF___33 = 502
} ;
#line 380
enum __anonenum__534___3 {
    SF_LOOP_NONE___33 = 800,
    SF_LOOP_FORWARD___33 = 801,
    SF_LOOP_BACKWARD___33 = 802,
    SF_LOOP_ALTERNATING___33 = 803
} ;
#line 121 "/root/libsndfile/src/common.h"
enum __anonenum__543___3 {
    SF_PEAK_START___33 = 42,
    SF_PEAK_END___33 = 43,
    SF_SCALE_MAX___33 = 52,
    SF_SCALE_MIN___33 = 53,
    SF_STR_ALLOW_START___33 = 256,
    SF_STR_ALLOW_END___33 = 512,
    SF_STR_LOCATE_START___33 = 1024,
    SF_STR_LOCATE_END___33 = 2048,
    SFD_TYPEMASK___33 = 268435455
} ;
#line 149
enum __anonenum__544___3 {
    SF_FORMAT_TXW___33 = 67305472,
    SF_FORMAT_DWD___33 = 67371008,
    SF_FORMAT_REX___33 = 67764224,
    SF_FORMAT_REX2___33 = 67960832,
    SF_FORMAT_KRZ___33 = 68026368,
    SF_FORMAT_WMA___33 = 68157440,
    SF_FORMAT_SHN___33 = 68222976,
    SF_FORMAT_SVX_FIB___33 = 4128,
    SF_FORMAT_SVX_EXP___33 = 4129,
    SF_FORMAT_PCM_N___33 = 4144
} ;
#line 405
enum __anonenum__550___3 {
    SFE_NO_ERROR___33 = 0,
    SFE_BAD_OPEN_FORMAT___33 = 1,
    SFE_SYSTEM___33 = 2,
    SFE_MALFORMED_FILE___33 = 3,
    SFE_UNSUPPORTED_ENCODING___33 = 4,
    SFE_ZERO_MAJOR_FORMAT___33 = 5,
    SFE_ZERO_MINOR_FORMAT___33 = 6,
    SFE_BAD_FILE___33 = 7,
    SFE_BAD_FILE_READ___33 = 8,
    SFE_OPEN_FAILED___33 = 9,
    SFE_BAD_SNDFILE_PTR___33 = 10,
    SFE_BAD_SF_INFO_PTR___33 = 11,
    SFE_BAD_SF_INCOMPLETE___33 = 12,
    SFE_BAD_FILE_PTR___33 = 13,
    SFE_BAD_INT_PTR___33 = 14,
    SFE_BAD_STAT_SIZE___33 = 15,
    SFE_MALLOC_FAILED___33 = 16,
    SFE_UNIMPLEMENTED___33 = 17,
    SFE_BAD_READ_ALIGN___33 = 18,
    SFE_BAD_WRITE_ALIGN___33 = 19,
    SFE_UNKNOWN_FORMAT___33 = 20,
    SFE_NOT_READMODE___33 = 21,
    SFE_NOT_WRITEMODE___33 = 22,
    SFE_BAD_MODE_RW___33 = 23,
    SFE_BAD_SF_INFO___33 = 24,
    SFE_BAD_OFFSET___33 = 25,
    SFE_NO_EMBED_SUPPORT___33 = 26,
    SFE_NO_EMBEDDED_RDWR___33 = 27,
    SFE_NO_PIPE_WRITE___33 = 28,
    SFE_INTERNAL___33 = 29,
    SFE_BAD_COMMAND_PARAM___33 = 30,
    SFE_BAD_ENDIAN___33 = 31,
    SFE_CHANNEL_COUNT_ZERO___33 = 32,
    SFE_CHANNEL_COUNT___33 = 33,
    SFE_BAD_VIRTUAL_IO___33 = 34,
    SFE_INTERLEAVE_MODE___33 = 35,
    SFE_INTERLEAVE_SEEK___33 = 36,
    SFE_INTERLEAVE_READ___33 = 37,
    SFE_BAD_SEEK___33 = 38,
    SFE_NOT_SEEKABLE___33 = 39,
    SFE_AMBIGUOUS_SEEK___33 = 40,
    SFE_WRONG_SEEK___33 = 41,
    SFE_SEEK_FAILED___33 = 42,
    SFE_BAD_OPEN_MODE___33 = 43,
    SFE_OPEN_PIPE_RDWR___33 = 44,
    SFE_RDWR_POSITION___33 = 45,
    SFE_RDWR_BAD_HEADER___33 = 46,
    SFE_CMD_HAS_DATA___33 = 47,
    SFE_BAD_BROADCAST_INFO_SIZE___33 = 48,
    SFE_STR_NO_SUPPORT___33 = 49,
    SFE_STR_NOT_WRITE___33 = 50,
    SFE_STR_MAX_DATA___33 = 51,
    SFE_STR_MAX_COUNT___33 = 52,
    SFE_STR_BAD_TYPE___33 = 53,
    SFE_STR_NO_ADD_END___33 = 54,
    SFE_STR_BAD_STRING___33 = 55,
    SFE_STR_WEIRD___33 = 56,
    SFE_WAV_NO_RIFF___33 = 57,
    SFE_WAV_NO_WAVE___33 = 58,
    SFE_WAV_NO_FMT___33 = 59,
    SFE_WAV_BAD_FMT___33 = 60,
    SFE_WAV_FMT_SHORT___33 = 61,
    SFE_WAV_BAD_FACT___33 = 62,
    SFE_WAV_BAD_PEAK___33 = 63,
    SFE_WAV_PEAK_B4_FMT___33 = 64,
    SFE_WAV_BAD_FORMAT___33 = 65,
    SFE_WAV_BAD_BLOCKALIGN___33 = 66,
    SFE_WAV_NO_DATA___33 = 67,
    SFE_WAV_BAD_LIST___33 = 68,
    SFE_WAV_ADPCM_NOT4BIT___33 = 69,
    SFE_WAV_ADPCM_CHANNELS___33 = 70,
    SFE_WAV_GSM610_FORMAT___33 = 71,
    SFE_WAV_UNKNOWN_CHUNK___33 = 72,
    SFE_WAV_WVPK_DATA___33 = 73,
    SFE_AIFF_NO_FORM___33 = 74,
    SFE_AIFF_AIFF_NO_FORM___33 = 75,
    SFE_AIFF_COMM_NO_FORM___33 = 76,
    SFE_AIFF_SSND_NO_COMM___33 = 77,
    SFE_AIFF_UNKNOWN_CHUNK___33 = 78,
    SFE_AIFF_COMM_CHUNK_SIZE___33 = 79,
    SFE_AIFF_BAD_COMM_CHUNK___33 = 80,
    SFE_AIFF_PEAK_B4_COMM___33 = 81,
    SFE_AIFF_BAD_PEAK___33 = 82,
    SFE_AIFF_NO_SSND___33 = 83,
    SFE_AIFF_NO_DATA___33 = 84,
    SFE_AIFF_RW_SSND_NOT_LAST___33 = 85,
    SFE_AU_UNKNOWN_FORMAT___33 = 86,
    SFE_AU_NO_DOTSND___33 = 87,
    SFE_AU_EMBED_BAD_LEN___33 = 88,
    SFE_RAW_READ_BAD_SPEC___33 = 89,
    SFE_RAW_BAD_BITWIDTH___33 = 90,
    SFE_RAW_BAD_FORMAT___33 = 91,
    SFE_PAF_NO_MARKER___33 = 92,
    SFE_PAF_VERSION___33 = 93,
    SFE_PAF_UNKNOWN_FORMAT___33 = 94,
    SFE_PAF_SHORT_HEADER___33 = 95,
    SFE_SVX_NO_FORM___33 = 96,
    SFE_SVX_NO_BODY___33 = 97,
    SFE_SVX_NO_DATA___33 = 98,
    SFE_SVX_BAD_COMP___33 = 99,
    SFE_SVX_BAD_NAME_LENGTH___33 = 100,
    SFE_NIST_BAD_HEADER___33 = 101,
    SFE_NIST_CRLF_CONVERISON___33 = 102,
    SFE_NIST_BAD_ENCODING___33 = 103,
    SFE_VOC_NO_CREATIVE___33 = 104,
    SFE_VOC_BAD_FORMAT___33 = 105,
    SFE_VOC_BAD_VERSION___33 = 106,
    SFE_VOC_BAD_MARKER___33 = 107,
    SFE_VOC_BAD_SECTIONS___33 = 108,
    SFE_VOC_MULTI_SAMPLERATE___33 = 109,
    SFE_VOC_MULTI_SECTION___33 = 110,
    SFE_VOC_MULTI_PARAM___33 = 111,
    SFE_VOC_SECTION_COUNT___33 = 112,
    SFE_VOC_NO_PIPE___33 = 113,
    SFE_IRCAM_NO_MARKER___33 = 114,
    SFE_IRCAM_BAD_CHANNELS___33 = 115,
    SFE_IRCAM_UNKNOWN_FORMAT___33 = 116,
    SFE_W64_64_BIT___33 = 117,
    SFE_W64_NO_RIFF___33 = 118,
    SFE_W64_NO_WAVE___33 = 119,
    SFE_W64_NO_DATA___33 = 120,
    SFE_W64_ADPCM_NOT4BIT___33 = 121,
    SFE_W64_ADPCM_CHANNELS___33 = 122,
    SFE_W64_GSM610_FORMAT___33 = 123,
    SFE_MAT4_BAD_NAME___33 = 124,
    SFE_MAT4_NO_SAMPLERATE___33 = 125,
    SFE_MAT5_BAD_ENDIAN___33 = 126,
    SFE_MAT5_NO_BLOCK___33 = 127,
    SFE_MAT5_SAMPLE_RATE___33 = 128,
    SFE_PVF_NO_PVF1___33 = 129,
    SFE_PVF_BAD_HEADER___33 = 130,
    SFE_PVF_BAD_BITWIDTH___33 = 131,
    SFE_DWVW_BAD_BITWIDTH___33 = 132,
    SFE_G72X_NOT_MONO___33 = 133,
    SFE_XI_BAD_HEADER___33 = 134,
    SFE_XI_EXCESS_SAMPLES___33 = 135,
    SFE_XI_NO_PIPE___33 = 136,
    SFE_HTK_NO_PIPE___33 = 137,
    SFE_SDS_NOT_SDS___33 = 138,
    SFE_SDS_BAD_BIT_WIDTH___33 = 139,
    SFE_SD2_FD_DISALLOWED___33 = 140,
    SFE_SD2_BAD_DATA_OFFSET___33 = 141,
    SFE_SD2_BAD_MAP_OFFSET___33 = 142,
    SFE_SD2_BAD_DATA_LENGTH___33 = 143,
    SFE_SD2_BAD_MAP_LENGTH___33 = 144,
    SFE_SD2_BAD_RSRC___33 = 145,
    SFE_SD2_BAD_SAMPLE_SIZE___33 = 146,
    SFE_FLAC_BAD_HEADER___33 = 147,
    SFE_FLAC_NEW_DECODER___33 = 148,
    SFE_FLAC_INIT_DECODER___33 = 149,
    SFE_FLAC_LOST_SYNC___33 = 150,
    SFE_FLAC_BAD_SAMPLE_RATE___33 = 151,
    SFE_FLAC_UNKOWN_ERROR___33 = 152,
    SFE_WVE_NOT_WVE___33 = 153,
    SFE_WVE_NO_PIPE___33 = 154,
    SFE_VORBIS_ENCODER_BUG___33 = 155,
    SFE_RF64_NOT_RF64___33 = 156,
    SFE_MAX_ERROR___33 = 157
} ;
#line 823
enum __anonenum__554___3 {
    SFC_TEST_AIFF_ADD_INST_CHUNK___33 = 8192,
    SFC_TEST_WAV_ADD_INFO_CHUNK___33 = 8208
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__568___1 {
    _ISupper___13 = 256,
    _ISlower___13 = 512,
    _ISalpha___13 = 1024,
    _ISdigit___13 = 2048,
    _ISxdigit___13 = 4096,
    _ISspace___13 = 8192,
    _ISprint___13 = 16384,
    _ISgraph___13 = 32768,
    _ISblank___13 = 1,
    _IScntrl___13 = 2,
    _ISpunct___13 = 4,
    _ISalnum___13 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__569___1 {
    FP_NAN___14 = 0,
    FP_INFINITE___14 = 1,
    FP_ZERO___14 = 2,
    FP_SUBNORMAL___14 = 3,
    FP_NORMAL___14 = 4
} ;
#line 46 "/root/libsndfile/src/sndfile.h"
enum __anonenum__570___1 {
    SF_FORMAT_WAV___34 = 65536,
    SF_FORMAT_AIFF___34 = 131072,
    SF_FORMAT_AU___34 = 196608,
    SF_FORMAT_RAW___34 = 262144,
    SF_FORMAT_PAF___34 = 327680,
    SF_FORMAT_SVX___34 = 393216,
    SF_FORMAT_NIST___34 = 458752,
    SF_FORMAT_VOC___34 = 524288,
    SF_FORMAT_IRCAM___34 = 655360,
    SF_FORMAT_W64___34 = 720896,
    SF_FORMAT_MAT4___34 = 786432,
    SF_FORMAT_MAT5___34 = 851968,
    SF_FORMAT_PVF___34 = 917504,
    SF_FORMAT_XI___34 = 983040,
    SF_FORMAT_HTK___34 = 1048576,
    SF_FORMAT_SDS___34 = 1114112,
    SF_FORMAT_AVR___34 = 1179648,
    SF_FORMAT_WAVEX___34 = 1245184,
    SF_FORMAT_SD2___34 = 1441792,
    SF_FORMAT_FLAC___34 = 1507328,
    SF_FORMAT_CAF___34 = 1572864,
    SF_FORMAT_WVE___34 = 1638400,
    SF_FORMAT_OGG___34 = 2097152,
    SF_FORMAT_MPC2K___34 = 2162688,
    SF_FORMAT_RF64___34 = 2228224,
    SF_FORMAT_PCM_S8___34 = 1,
    SF_FORMAT_PCM_16___34 = 2,
    SF_FORMAT_PCM_24___34 = 3,
    SF_FORMAT_PCM_32___34 = 4,
    SF_FORMAT_PCM_U8___34 = 5,
    SF_FORMAT_FLOAT___34 = 6,
    SF_FORMAT_DOUBLE___34 = 7,
    SF_FORMAT_ULAW___34 = 16,
    SF_FORMAT_ALAW___34 = 17,
    SF_FORMAT_IMA_ADPCM___34 = 18,
    SF_FORMAT_MS_ADPCM___34 = 19,
    SF_FORMAT_GSM610___34 = 32,
    SF_FORMAT_VOX_ADPCM___34 = 33,
    SF_FORMAT_G721_32___34 = 48,
    SF_FORMAT_G723_24___34 = 49,
    SF_FORMAT_G723_40___34 = 50,
    SF_FORMAT_DWVW_12___34 = 64,
    SF_FORMAT_DWVW_16___34 = 65,
    SF_FORMAT_DWVW_24___34 = 66,
    SF_FORMAT_DWVW_N___34 = 67,
    SF_FORMAT_DPCM_8___34 = 80,
    SF_FORMAT_DPCM_16___34 = 81,
    SF_FORMAT_VORBIS___34 = 96,
    SF_ENDIAN_FILE___34 = 0,
    SF_ENDIAN_LITTLE___34 = 268435456,
    SF_ENDIAN_BIG___34 = 536870912,
    SF_ENDIAN_CPU___34 = 805306368,
    SF_FORMAT_SUBMASK___34 = 65535,
    SF_FORMAT_TYPEMASK___34 = 268369920,
    SF_FORMAT_ENDMASK___34 = 805306368
} ;
#line 126
enum __anonenum__571___1 {
    SFC_GET_LIB_VERSION___34 = 4096,
    SFC_GET_LOG_INFO___34 = 4097,
    SFC_GET_CURRENT_SF_INFO___34 = 4098,
    SFC_GET_NORM_DOUBLE___34 = 4112,
    SFC_GET_NORM_FLOAT___34 = 4113,
    SFC_SET_NORM_DOUBLE___34 = 4114,
    SFC_SET_NORM_FLOAT___34 = 4115,
    SFC_SET_SCALE_FLOAT_INT_READ___34 = 4116,
    SFC_SET_SCALE_INT_FLOAT_WRITE___34 = 4117,
    SFC_GET_SIMPLE_FORMAT_COUNT___34 = 4128,
    SFC_GET_SIMPLE_FORMAT___34 = 4129,
    SFC_GET_FORMAT_INFO___34 = 4136,
    SFC_GET_FORMAT_MAJOR_COUNT___34 = 4144,
    SFC_GET_FORMAT_MAJOR___34 = 4145,
    SFC_GET_FORMAT_SUBTYPE_COUNT___34 = 4146,
    SFC_GET_FORMAT_SUBTYPE___34 = 4147,
    SFC_CALC_SIGNAL_MAX___34 = 4160,
    SFC_CALC_NORM_SIGNAL_MAX___34 = 4161,
    SFC_CALC_MAX_ALL_CHANNELS___34 = 4162,
    SFC_CALC_NORM_MAX_ALL_CHANNELS___34 = 4163,
    SFC_GET_SIGNAL_MAX___34 = 4164,
    SFC_GET_MAX_ALL_CHANNELS___34 = 4165,
    SFC_SET_ADD_PEAK_CHUNK___34 = 4176,
    SFC_SET_ADD_HEADER_PAD_CHUNK___34 = 4177,
    SFC_UPDATE_HEADER_NOW___34 = 4192,
    SFC_SET_UPDATE_HEADER_AUTO___34 = 4193,
    SFC_FILE_TRUNCATE___34 = 4224,
    SFC_SET_RAW_START_OFFSET___34 = 4240,
    SFC_SET_DITHER_ON_WRITE___34 = 4256,
    SFC_SET_DITHER_ON_READ___34 = 4257,
    SFC_GET_DITHER_INFO_COUNT___34 = 4258,
    SFC_GET_DITHER_INFO___34 = 4259,
    SFC_GET_EMBED_FILE_INFO___34 = 4272,
    SFC_SET_CLIPPING___34 = 4288,
    SFC_GET_CLIPPING___34 = 4289,
    SFC_GET_INSTRUMENT___34 = 4304,
    SFC_SET_INSTRUMENT___34 = 4305,
    SFC_GET_LOOP_INFO___34 = 4320,
    SFC_GET_BROADCAST_INFO___34 = 4336,
    SFC_SET_BROADCAST_INFO___34 = 4337,
    SFC_GET_CHANNEL_MAP_INFO___34 = 4352,
    SFC_SET_CHANNEL_MAP_INFO___34 = 4353,
    SFC_RAW_DATA_NEEDS_ENDSWAP___34 = 4368,
    SFC_WAVEX_SET_AMBISONIC___34 = 4608,
    SFC_WAVEX_GET_AMBISONIC___34 = 4609,
    SFC_SET_VBR_ENCODING_QUALITY___34 = 4864,
    SFC_TEST_IEEE_FLOAT_REPLACE___34 = 24577,
    SFC_SET_ADD_DITHER_ON_WRITE___34 = 4208,
    SFC_SET_ADD_DITHER_ON_READ___34 = 4209
} ;
#line 216
enum __anonenum__572___1 {
    SF_STR_TITLE___34 = 1,
    SF_STR_COPYRIGHT___34 = 2,
    SF_STR_SOFTWARE___34 = 3,
    SF_STR_ARTIST___34 = 4,
    SF_STR_COMMENT___34 = 5,
    SF_STR_DATE___34 = 6,
    SF_STR_ALBUM___34 = 7,
    SF_STR_LICENSE___34 = 8
} ;
#line 235
enum __anonenum__573___1 {
    SF_FALSE___34 = 0,
    SF_TRUE___34 = 1,
    SFM_READ___34 = 16,
    SFM_WRITE___34 = 32,
    SFM_RDWR___34 = 48,
    SF_AMBISONIC_NONE___34 = 64,
    SF_AMBISONIC_B_FORMAT___34 = 65
} ;
#line 255
enum __anonenum__574___1 {
    SF_ERR_NO_ERROR___34 = 0,
    SF_ERR_UNRECOGNISED_FORMAT___34 = 1,
    SF_ERR_SYSTEM___34 = 2,
    SF_ERR_MALFORMED_FILE___34 = 3,
    SF_ERR_UNSUPPORTED_ENCODING___34 = 4
} ;
#line 267
enum __anonenum__575___1 {
    SF_CHANNEL_MAP_INVALID___34 = 0,
    SF_CHANNEL_MAP_MONO___34 = 1,
    SF_CHANNEL_MAP_LEFT___34 = 2,
    SF_CHANNEL_MAP_RIGHT___34 = 3,
    SF_CHANNEL_MAP_CENTER___34 = 4,
    SF_CHANNEL_MAP_FRONT_LEFT___34 = 5,
    SF_CHANNEL_MAP_FRONT_RIGHT___34 = 6,
    SF_CHANNEL_MAP_FRONT_CENTER___34 = 7,
    SF_CHANNEL_MAP_REAR_CENTER___34 = 8,
    SF_CHANNEL_MAP_REAR_LEFT___34 = 9,
    SF_CHANNEL_MAP_REAR_RIGHT___34 = 10,
    SF_CHANNEL_MAP_LFE___34 = 11,
    SF_CHANNEL_MAP_FRONT_LEFT_OF_CENTER___34 = 12,
    SF_CHANNEL_MAP_FRONT_RIGHT_OF_CENTER___34 = 13,
    SF_CHANNEL_MAP_SIDE_LEFT___34 = 14,
    SF_CHANNEL_MAP_SIDE_RIGHT___34 = 15,
    SF_CHANNEL_MAP_TOP_CENTER___34 = 16,
    SF_CHANNEL_MAP_TOP_FRONT_LEFT___34 = 17,
    SF_CHANNEL_MAP_TOP_FRONT_RIGHT___34 = 18,
    SF_CHANNEL_MAP_TOP_FRONT_CENTER___34 = 19,
    SF_CHANNEL_MAP_TOP_REAR_LEFT___34 = 20,
    SF_CHANNEL_MAP_TOP_REAR_RIGHT___34 = 21,
    SF_CHANNEL_MAP_TOP_REAR_CENTER___34 = 22
} ;
#line 352
enum __anonenum__577___1 {
    SFD_DEFAULT_LEVEL___34 = 0,
    SFD_CUSTOM_LEVEL___34 = 1073741824,
    SFD_NO_DITHER___34 = 500,
    SFD_WHITE___34 = 501,
    SFD_TRIANGULAR_PDF___34 = 502
} ;
#line 380
enum __anonenum__580___1 {
    SF_LOOP_NONE___34 = 800,
    SF_LOOP_FORWARD___34 = 801,
    SF_LOOP_BACKWARD___34 = 802,
    SF_LOOP_ALTERNATING___34 = 803
} ;
#line 121 "/root/libsndfile/src/common.h"
enum __anonenum__585___1 {
    SF_PEAK_START___34 = 42,
    SF_PEAK_END___34 = 43,
    SF_SCALE_MAX___34 = 52,
    SF_SCALE_MIN___34 = 53,
    SF_STR_ALLOW_START___34 = 256,
    SF_STR_ALLOW_END___34 = 512,
    SF_STR_LOCATE_START___34 = 1024,
    SF_STR_LOCATE_END___34 = 2048,
    SFD_TYPEMASK___34 = 268435455
} ;
#line 149
enum __anonenum__586___1 {
    SF_FORMAT_TXW___34 = 67305472,
    SF_FORMAT_DWD___34 = 67371008,
    SF_FORMAT_REX___34 = 67764224,
    SF_FORMAT_REX2___34 = 67960832,
    SF_FORMAT_KRZ___34 = 68026368,
    SF_FORMAT_WMA___34 = 68157440,
    SF_FORMAT_SHN___34 = 68222976,
    SF_FORMAT_SVX_FIB___34 = 4128,
    SF_FORMAT_SVX_EXP___34 = 4129,
    SF_FORMAT_PCM_N___34 = 4144
} ;
#line 405
enum __anonenum__592___1 {
    SFE_NO_ERROR___34 = 0,
    SFE_BAD_OPEN_FORMAT___34 = 1,
    SFE_SYSTEM___34 = 2,
    SFE_MALFORMED_FILE___34 = 3,
    SFE_UNSUPPORTED_ENCODING___34 = 4,
    SFE_ZERO_MAJOR_FORMAT___34 = 5,
    SFE_ZERO_MINOR_FORMAT___34 = 6,
    SFE_BAD_FILE___34 = 7,
    SFE_BAD_FILE_READ___34 = 8,
    SFE_OPEN_FAILED___34 = 9,
    SFE_BAD_SNDFILE_PTR___34 = 10,
    SFE_BAD_SF_INFO_PTR___34 = 11,
    SFE_BAD_SF_INCOMPLETE___34 = 12,
    SFE_BAD_FILE_PTR___34 = 13,
    SFE_BAD_INT_PTR___34 = 14,
    SFE_BAD_STAT_SIZE___34 = 15,
    SFE_MALLOC_FAILED___34 = 16,
    SFE_UNIMPLEMENTED___34 = 17,
    SFE_BAD_READ_ALIGN___34 = 18,
    SFE_BAD_WRITE_ALIGN___34 = 19,
    SFE_UNKNOWN_FORMAT___34 = 20,
    SFE_NOT_READMODE___34 = 21,
    SFE_NOT_WRITEMODE___34 = 22,
    SFE_BAD_MODE_RW___34 = 23,
    SFE_BAD_SF_INFO___34 = 24,
    SFE_BAD_OFFSET___34 = 25,
    SFE_NO_EMBED_SUPPORT___34 = 26,
    SFE_NO_EMBEDDED_RDWR___34 = 27,
    SFE_NO_PIPE_WRITE___34 = 28,
    SFE_INTERNAL___34 = 29,
    SFE_BAD_COMMAND_PARAM___34 = 30,
    SFE_BAD_ENDIAN___34 = 31,
    SFE_CHANNEL_COUNT_ZERO___34 = 32,
    SFE_CHANNEL_COUNT___34 = 33,
    SFE_BAD_VIRTUAL_IO___34 = 34,
    SFE_INTERLEAVE_MODE___34 = 35,
    SFE_INTERLEAVE_SEEK___34 = 36,
    SFE_INTERLEAVE_READ___34 = 37,
    SFE_BAD_SEEK___34 = 38,
    SFE_NOT_SEEKABLE___34 = 39,
    SFE_AMBIGUOUS_SEEK___34 = 40,
    SFE_WRONG_SEEK___34 = 41,
    SFE_SEEK_FAILED___34 = 42,
    SFE_BAD_OPEN_MODE___34 = 43,
    SFE_OPEN_PIPE_RDWR___34 = 44,
    SFE_RDWR_POSITION___34 = 45,
    SFE_RDWR_BAD_HEADER___34 = 46,
    SFE_CMD_HAS_DATA___34 = 47,
    SFE_BAD_BROADCAST_INFO_SIZE___34 = 48,
    SFE_STR_NO_SUPPORT___34 = 49,
    SFE_STR_NOT_WRITE___34 = 50,
    SFE_STR_MAX_DATA___34 = 51,
    SFE_STR_MAX_COUNT___34 = 52,
    SFE_STR_BAD_TYPE___34 = 53,
    SFE_STR_NO_ADD_END___34 = 54,
    SFE_STR_BAD_STRING___34 = 55,
    SFE_STR_WEIRD___34 = 56,
    SFE_WAV_NO_RIFF___34 = 57,
    SFE_WAV_NO_WAVE___34 = 58,
    SFE_WAV_NO_FMT___34 = 59,
    SFE_WAV_BAD_FMT___34 = 60,
    SFE_WAV_FMT_SHORT___34 = 61,
    SFE_WAV_BAD_FACT___34 = 62,
    SFE_WAV_BAD_PEAK___34 = 63,
    SFE_WAV_PEAK_B4_FMT___34 = 64,
    SFE_WAV_BAD_FORMAT___34 = 65,
    SFE_WAV_BAD_BLOCKALIGN___34 = 66,
    SFE_WAV_NO_DATA___34 = 67,
    SFE_WAV_BAD_LIST___34 = 68,
    SFE_WAV_ADPCM_NOT4BIT___34 = 69,
    SFE_WAV_ADPCM_CHANNELS___34 = 70,
    SFE_WAV_GSM610_FORMAT___34 = 71,
    SFE_WAV_UNKNOWN_CHUNK___34 = 72,
    SFE_WAV_WVPK_DATA___34 = 73,
    SFE_AIFF_NO_FORM___34 = 74,
    SFE_AIFF_AIFF_NO_FORM___34 = 75,
    SFE_AIFF_COMM_NO_FORM___34 = 76,
    SFE_AIFF_SSND_NO_COMM___34 = 77,
    SFE_AIFF_UNKNOWN_CHUNK___34 = 78,
    SFE_AIFF_COMM_CHUNK_SIZE___34 = 79,
    SFE_AIFF_BAD_COMM_CHUNK___34 = 80,
    SFE_AIFF_PEAK_B4_COMM___34 = 81,
    SFE_AIFF_BAD_PEAK___34 = 82,
    SFE_AIFF_NO_SSND___34 = 83,
    SFE_AIFF_NO_DATA___34 = 84,
    SFE_AIFF_RW_SSND_NOT_LAST___34 = 85,
    SFE_AU_UNKNOWN_FORMAT___34 = 86,
    SFE_AU_NO_DOTSND___34 = 87,
    SFE_AU_EMBED_BAD_LEN___34 = 88,
    SFE_RAW_READ_BAD_SPEC___34 = 89,
    SFE_RAW_BAD_BITWIDTH___34 = 90,
    SFE_RAW_BAD_FORMAT___34 = 91,
    SFE_PAF_NO_MARKER___34 = 92,
    SFE_PAF_VERSION___34 = 93,
    SFE_PAF_UNKNOWN_FORMAT___34 = 94,
    SFE_PAF_SHORT_HEADER___34 = 95,
    SFE_SVX_NO_FORM___34 = 96,
    SFE_SVX_NO_BODY___34 = 97,
    SFE_SVX_NO_DATA___34 = 98,
    SFE_SVX_BAD_COMP___34 = 99,
    SFE_SVX_BAD_NAME_LENGTH___34 = 100,
    SFE_NIST_BAD_HEADER___34 = 101,
    SFE_NIST_CRLF_CONVERISON___34 = 102,
    SFE_NIST_BAD_ENCODING___34 = 103,
    SFE_VOC_NO_CREATIVE___34 = 104,
    SFE_VOC_BAD_FORMAT___34 = 105,
    SFE_VOC_BAD_VERSION___34 = 106,
    SFE_VOC_BAD_MARKER___34 = 107,
    SFE_VOC_BAD_SECTIONS___34 = 108,
    SFE_VOC_MULTI_SAMPLERATE___34 = 109,
    SFE_VOC_MULTI_SECTION___34 = 110,
    SFE_VOC_MULTI_PARAM___34 = 111,
    SFE_VOC_SECTION_COUNT___34 = 112,
    SFE_VOC_NO_PIPE___34 = 113,
    SFE_IRCAM_NO_MARKER___34 = 114,
    SFE_IRCAM_BAD_CHANNELS___34 = 115,
    SFE_IRCAM_UNKNOWN_FORMAT___34 = 116,
    SFE_W64_64_BIT___34 = 117,
    SFE_W64_NO_RIFF___34 = 118,
    SFE_W64_NO_WAVE___34 = 119,
    SFE_W64_NO_DATA___34 = 120,
    SFE_W64_ADPCM_NOT4BIT___34 = 121,
    SFE_W64_ADPCM_CHANNELS___34 = 122,
    SFE_W64_GSM610_FORMAT___34 = 123,
    SFE_MAT4_BAD_NAME___34 = 124,
    SFE_MAT4_NO_SAMPLERATE___34 = 125,
    SFE_MAT5_BAD_ENDIAN___34 = 126,
    SFE_MAT5_NO_BLOCK___34 = 127,
    SFE_MAT5_SAMPLE_RATE___34 = 128,
    SFE_PVF_NO_PVF1___34 = 129,
    SFE_PVF_BAD_HEADER___34 = 130,
    SFE_PVF_BAD_BITWIDTH___34 = 131,
    SFE_DWVW_BAD_BITWIDTH___34 = 132,
    SFE_G72X_NOT_MONO___34 = 133,
    SFE_XI_BAD_HEADER___34 = 134,
    SFE_XI_EXCESS_SAMPLES___34 = 135,
    SFE_XI_NO_PIPE___34 = 136,
    SFE_HTK_NO_PIPE___34 = 137,
    SFE_SDS_NOT_SDS___34 = 138,
    SFE_SDS_BAD_BIT_WIDTH___34 = 139,
    SFE_SD2_FD_DISALLOWED___34 = 140,
    SFE_SD2_BAD_DATA_OFFSET___34 = 141,
    SFE_SD2_BAD_MAP_OFFSET___34 = 142,
    SFE_SD2_BAD_DATA_LENGTH___34 = 143,
    SFE_SD2_BAD_MAP_LENGTH___34 = 144,
    SFE_SD2_BAD_RSRC___34 = 145,
    SFE_SD2_BAD_SAMPLE_SIZE___34 = 146,
    SFE_FLAC_BAD_HEADER___34 = 147,
    SFE_FLAC_NEW_DECODER___34 = 148,
    SFE_FLAC_INIT_DECODER___34 = 149,
    SFE_FLAC_LOST_SYNC___34 = 150,
    SFE_FLAC_BAD_SAMPLE_RATE___34 = 151,
    SFE_FLAC_UNKOWN_ERROR___34 = 152,
    SFE_WVE_NOT_WVE___34 = 153,
    SFE_WVE_NO_PIPE___34 = 154,
    SFE_VORBIS_ENCODER_BUG___34 = 155,
    SFE_RF64_NOT_RF64___34 = 156,
    SFE_MAX_ERROR___34 = 157
} ;
#line 823
enum __anonenum__596___1 {
    SFC_TEST_AIFF_ADD_INST_CHUNK___34 = 8192,
    SFC_TEST_WAV_ADD_INFO_CHUNK___34 = 8208
} ;
#line 52 "/root/libsndfile/src/paf.c"
struct __anonstruct_597___0 {
   int version ;
   int endianness ;
   int samplerate ;
   int format ;
   int channels ;
   int source ;
};
#line 59 "/root/libsndfile/src/paf.c"
typedef struct __anonstruct_597___0 PAF_FMT;
#line 61 "/root/libsndfile/src/paf.c"
struct __anonstruct_850 {
   int max_blocks ;
   int channels ;
   int samplesperblock ;
   int blocksize ;
   int read_block ;
   int write_block ;
   int read_count ;
   int write_count ;
   sf_count_t sample_count ;
   int *samples ;
   unsigned char *block ;
   int data[] ;
};
#line 72 "/root/libsndfile/src/paf.c"
typedef struct __anonstruct_850 PAF24_PRIVATE;
#line 95
enum __anonenum__851 {
    PAF_PCM_16 = 0,
    PAF_PCM_24 = 1,
    PAF_PCM_S8 = 2
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__510___4 {
    _ISupper___14 = 256,
    _ISlower___14 = 512,
    _ISalpha___14 = 1024,
    _ISdigit___14 = 2048,
    _ISxdigit___14 = 4096,
    _ISspace___14 = 8192,
    _ISprint___14 = 16384,
    _ISgraph___14 = 32768,
    _ISblank___14 = 1,
    _IScntrl___14 = 2,
    _ISpunct___14 = 4,
    _ISalnum___14 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__852 {
    FP_NAN___15 = 0,
    FP_INFINITE___15 = 1,
    FP_ZERO___15 = 2,
    FP_SUBNORMAL___15 = 3,
    FP_NORMAL___15 = 4
} ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__853 {
    _PC_LINK_MAX___1 = 0,
    _PC_MAX_CANON___1 = 1,
    _PC_MAX_INPUT___1 = 2,
    _PC_NAME_MAX___1 = 3,
    _PC_PATH_MAX___1 = 4,
    _PC_PIPE_BUF___1 = 5,
    _PC_CHOWN_RESTRICTED___1 = 6,
    _PC_NO_TRUNC___1 = 7,
    _PC_VDISABLE___1 = 8,
    _PC_SYNC_IO___1 = 9,
    _PC_ASYNC_IO___1 = 10,
    _PC_PRIO_IO___1 = 11,
    _PC_SOCK_MAXBUF___1 = 12,
    _PC_FILESIZEBITS___1 = 13,
    _PC_REC_INCR_XFER_SIZE___1 = 14,
    _PC_REC_MAX_XFER_SIZE___1 = 15,
    _PC_REC_MIN_XFER_SIZE___1 = 16,
    _PC_REC_XFER_ALIGN___1 = 17,
    _PC_ALLOC_SIZE_MIN___1 = 18,
    _PC_SYMLINK_MAX___1 = 19,
    _PC_2_SYMLINKS___1 = 20
} ;
#line 71
enum __anonenum__854 {
    _SC_ARG_MAX___1 = 0,
    _SC_CHILD_MAX___1 = 1,
    _SC_CLK_TCK___1 = 2,
    _SC_NGROUPS_MAX___1 = 3,
    _SC_OPEN_MAX___1 = 4,
    _SC_STREAM_MAX___1 = 5,
    _SC_TZNAME_MAX___1 = 6,
    _SC_JOB_CONTROL___1 = 7,
    _SC_SAVED_IDS___1 = 8,
    _SC_REALTIME_SIGNALS___1 = 9,
    _SC_PRIORITY_SCHEDULING___1 = 10,
    _SC_TIMERS___1 = 11,
    _SC_ASYNCHRONOUS_IO___1 = 12,
    _SC_PRIORITIZED_IO___1 = 13,
    _SC_SYNCHRONIZED_IO___1 = 14,
    _SC_FSYNC___1 = 15,
    _SC_MAPPED_FILES___1 = 16,
    _SC_MEMLOCK___1 = 17,
    _SC_MEMLOCK_RANGE___1 = 18,
    _SC_MEMORY_PROTECTION___1 = 19,
    _SC_MESSAGE_PASSING___1 = 20,
    _SC_SEMAPHORES___1 = 21,
    _SC_SHARED_MEMORY_OBJECTS___1 = 22,
    _SC_AIO_LISTIO_MAX___1 = 23,
    _SC_AIO_MAX___1 = 24,
    _SC_AIO_PRIO_DELTA_MAX___1 = 25,
    _SC_DELAYTIMER_MAX___1 = 26,
    _SC_MQ_OPEN_MAX___1 = 27,
    _SC_MQ_PRIO_MAX___1 = 28,
    _SC_VERSION___1 = 29,
    _SC_PAGESIZE___1 = 30,
    _SC_RTSIG_MAX___1 = 31,
    _SC_SEM_NSEMS_MAX___1 = 32,
    _SC_SEM_VALUE_MAX___1 = 33,
    _SC_SIGQUEUE_MAX___1 = 34,
    _SC_TIMER_MAX___1 = 35,
    _SC_BC_BASE_MAX___1 = 36,
    _SC_BC_DIM_MAX___1 = 37,
    _SC_BC_SCALE_MAX___1 = 38,
    _SC_BC_STRING_MAX___1 = 39,
    _SC_COLL_WEIGHTS_MAX___1 = 40,
    _SC_EQUIV_CLASS_MAX___1 = 41,
    _SC_EXPR_NEST_MAX___1 = 42,
    _SC_LINE_MAX___1 = 43,
    _SC_RE_DUP_MAX___1 = 44,
    _SC_CHARCLASS_NAME_MAX___1 = 45,
    _SC_2_VERSION___1 = 46,
    _SC_2_C_BIND___1 = 47,
    _SC_2_C_DEV___1 = 48,
    _SC_2_FORT_DEV___1 = 49,
    _SC_2_FORT_RUN___1 = 50,
    _SC_2_SW_DEV___1 = 51,
    _SC_2_LOCALEDEF___1 = 52,
    _SC_PII___1 = 53,
    _SC_PII_XTI___1 = 54,
    _SC_PII_SOCKET___1 = 55,
    _SC_PII_INTERNET___1 = 56,
    _SC_PII_OSI___1 = 57,
    _SC_POLL___1 = 58,
    _SC_SELECT___1 = 59,
    _SC_UIO_MAXIOV___1 = 60,
    _SC_IOV_MAX___1 = 60,
    _SC_PII_INTERNET_STREAM___1 = 61,
    _SC_PII_INTERNET_DGRAM___1 = 62,
    _SC_PII_OSI_COTS___1 = 63,
    _SC_PII_OSI_CLTS___1 = 64,
    _SC_PII_OSI_M___1 = 65,
    _SC_T_IOV_MAX___1 = 66,
    _SC_THREADS___1 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___1 = 68,
    _SC_GETGR_R_SIZE_MAX___1 = 69,
    _SC_GETPW_R_SIZE_MAX___1 = 70,
    _SC_LOGIN_NAME_MAX___1 = 71,
    _SC_TTY_NAME_MAX___1 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___1 = 73,
    _SC_THREAD_KEYS_MAX___1 = 74,
    _SC_THREAD_STACK_MIN___1 = 75,
    _SC_THREAD_THREADS_MAX___1 = 76,
    _SC_THREAD_ATTR_STACKADDR___1 = 77,
    _SC_THREAD_ATTR_STACKSIZE___1 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___1 = 79,
    _SC_THREAD_PRIO_INHERIT___1 = 80,
    _SC_THREAD_PRIO_PROTECT___1 = 81,
    _SC_THREAD_PROCESS_SHARED___1 = 82,
    _SC_NPROCESSORS_CONF___1 = 83,
    _SC_NPROCESSORS_ONLN___1 = 84,
    _SC_PHYS_PAGES___1 = 85,
    _SC_AVPHYS_PAGES___1 = 86,
    _SC_ATEXIT_MAX___1 = 87,
    _SC_PASS_MAX___1 = 88,
    _SC_XOPEN_VERSION___1 = 89,
    _SC_XOPEN_XCU_VERSION___1 = 90,
    _SC_XOPEN_UNIX___1 = 91,
    _SC_XOPEN_CRYPT___1 = 92,
    _SC_XOPEN_ENH_I18N___1 = 93,
    _SC_XOPEN_SHM___1 = 94,
    _SC_2_CHAR_TERM___1 = 95,
    _SC_2_C_VERSION___1 = 96,
    _SC_2_UPE___1 = 97,
    _SC_XOPEN_XPG2___1 = 98,
    _SC_XOPEN_XPG3___1 = 99,
    _SC_XOPEN_XPG4___1 = 100,
    _SC_CHAR_BIT___1 = 101,
    _SC_CHAR_MAX___1 = 102,
    _SC_CHAR_MIN___1 = 103,
    _SC_INT_MAX___1 = 104,
    _SC_INT_MIN___1 = 105,
    _SC_LONG_BIT___1 = 106,
    _SC_WORD_BIT___1 = 107,
    _SC_MB_LEN_MAX___1 = 108,
    _SC_NZERO___1 = 109,
    _SC_SSIZE_MAX___1 = 110,
    _SC_SCHAR_MAX___1 = 111,
    _SC_SCHAR_MIN___1 = 112,
    _SC_SHRT_MAX___1 = 113,
    _SC_SHRT_MIN___1 = 114,
    _SC_UCHAR_MAX___1 = 115,
    _SC_UINT_MAX___1 = 116,
    _SC_ULONG_MAX___1 = 117,
    _SC_USHRT_MAX___1 = 118,
    _SC_NL_ARGMAX___1 = 119,
    _SC_NL_LANGMAX___1 = 120,
    _SC_NL_MSGMAX___1 = 121,
    _SC_NL_NMAX___1 = 122,
    _SC_NL_SETMAX___1 = 123,
    _SC_NL_TEXTMAX___1 = 124,
    _SC_XBS5_ILP32_OFF32___1 = 125,
    _SC_XBS5_ILP32_OFFBIG___1 = 126,
    _SC_XBS5_LP64_OFF64___1 = 127,
    _SC_XBS5_LPBIG_OFFBIG___1 = 128,
    _SC_XOPEN_LEGACY___1 = 129,
    _SC_XOPEN_REALTIME___1 = 130,
    _SC_XOPEN_REALTIME_THREADS___1 = 131,
    _SC_ADVISORY_INFO___1 = 132,
    _SC_BARRIERS___1 = 133,
    _SC_BASE___1 = 134,
    _SC_C_LANG_SUPPORT___1 = 135,
    _SC_C_LANG_SUPPORT_R___1 = 136,
    _SC_CLOCK_SELECTION___1 = 137,
    _SC_CPUTIME___1 = 138,
    _SC_THREAD_CPUTIME___1 = 139,
    _SC_DEVICE_IO___1 = 140,
    _SC_DEVICE_SPECIFIC___1 = 141,
    _SC_DEVICE_SPECIFIC_R___1 = 142,
    _SC_FD_MGMT___1 = 143,
    _SC_FIFO___1 = 144,
    _SC_PIPE___1 = 145,
    _SC_FILE_ATTRIBUTES___1 = 146,
    _SC_FILE_LOCKING___1 = 147,
    _SC_FILE_SYSTEM___1 = 148,
    _SC_MONOTONIC_CLOCK___1 = 149,
    _SC_MULTI_PROCESS___1 = 150,
    _SC_SINGLE_PROCESS___1 = 151,
    _SC_NETWORKING___1 = 152,
    _SC_READER_WRITER_LOCKS___1 = 153,
    _SC_SPIN_LOCKS___1 = 154,
    _SC_REGEXP___1 = 155,
    _SC_REGEX_VERSION___1 = 156,
    _SC_SHELL___1 = 157,
    _SC_SIGNALS___1 = 158,
    _SC_SPAWN___1 = 159,
    _SC_SPORADIC_SERVER___1 = 160,
    _SC_THREAD_SPORADIC_SERVER___1 = 161,
    _SC_SYSTEM_DATABASE___1 = 162,
    _SC_SYSTEM_DATABASE_R___1 = 163,
    _SC_TIMEOUTS___1 = 164,
    _SC_TYPED_MEMORY_OBJECTS___1 = 165,
    _SC_USER_GROUPS___1 = 166,
    _SC_USER_GROUPS_R___1 = 167,
    _SC_2_PBS___1 = 168,
    _SC_2_PBS_ACCOUNTING___1 = 169,
    _SC_2_PBS_LOCATE___1 = 170,
    _SC_2_PBS_MESSAGE___1 = 171,
    _SC_2_PBS_TRACK___1 = 172,
    _SC_SYMLOOP_MAX___1 = 173,
    _SC_STREAMS___1 = 174,
    _SC_2_PBS_CHECKPOINT___1 = 175,
    _SC_V6_ILP32_OFF32___1 = 176,
    _SC_V6_ILP32_OFFBIG___1 = 177,
    _SC_V6_LP64_OFF64___1 = 178,
    _SC_V6_LPBIG_OFFBIG___1 = 179,
    _SC_HOST_NAME_MAX___1 = 180,
    _SC_TRACE___1 = 181,
    _SC_TRACE_EVENT_FILTER___1 = 182,
    _SC_TRACE_INHERIT___1 = 183,
    _SC_TRACE_LOG___1 = 184,
    _SC_LEVEL1_ICACHE_SIZE___1 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___1 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___1 = 187,
    _SC_LEVEL1_DCACHE_SIZE___1 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___1 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___1 = 190,
    _SC_LEVEL2_CACHE_SIZE___1 = 191,
    _SC_LEVEL2_CACHE_ASSOC___1 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___1 = 193,
    _SC_LEVEL3_CACHE_SIZE___1 = 194,
    _SC_LEVEL3_CACHE_ASSOC___1 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___1 = 196,
    _SC_LEVEL4_CACHE_SIZE___1 = 197,
    _SC_LEVEL4_CACHE_ASSOC___1 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___1 = 199,
    _SC_IPV6___1 = 235,
    _SC_RAW_SOCKETS___1 = 236,
    _SC_V7_ILP32_OFF32___1 = 237,
    _SC_V7_ILP32_OFFBIG___1 = 238,
    _SC_V7_LP64_OFF64___1 = 239,
    _SC_V7_LPBIG_OFFBIG___1 = 240,
    _SC_SS_REPL_MAX___1 = 241,
    _SC_TRACE_EVENT_NAME_MAX___1 = 242,
    _SC_TRACE_NAME_MAX___1 = 243,
    _SC_TRACE_SYS_MAX___1 = 244,
    _SC_TRACE_USER_EVENT_MAX___1 = 245,
    _SC_XOPEN_STREAMS___1 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___1 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___1 = 248
} ;
#line 533
enum __anonenum__855 {
    _CS_PATH___1 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___1 = 1,
    _CS_GNU_LIBC_VERSION___1 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___1 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___1 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___1 = 5,
    _CS_LFS_CFLAGS___1 = 1000,
    _CS_LFS_LDFLAGS___1 = 1001,
    _CS_LFS_LIBS___1 = 1002,
    _CS_LFS_LINTFLAGS___1 = 1003,
    _CS_LFS64_CFLAGS___1 = 1004,
    _CS_LFS64_LDFLAGS___1 = 1005,
    _CS_LFS64_LIBS___1 = 1006,
    _CS_LFS64_LINTFLAGS___1 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___1 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___1 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___1 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___1 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___1 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___1 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___1 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___1 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___1 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___1 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___1 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___1 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___1 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___1 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___1 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___1 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___1 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___1 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___1 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___1 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___1 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___1 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___1 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___1 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___1 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___1 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___1 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___1 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___1 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___1 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___1 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___1 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___1 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___1 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___1 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___1 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___1 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___1 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___1 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___1 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___1 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___1 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___1 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___1 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___1 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___1 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___1 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___1 = 1147,
    _CS_V6_ENV___1 = 1148,
    _CS_V7_ENV___1 = 1149
} ;
#line 46 "/root/libsndfile/src/sndfile.h"
enum __anonenum__870 {
    SF_FORMAT_WAV___35 = 65536,
    SF_FORMAT_AIFF___35 = 131072,
    SF_FORMAT_AU___35 = 196608,
    SF_FORMAT_RAW___35 = 262144,
    SF_FORMAT_PAF___35 = 327680,
    SF_FORMAT_SVX___35 = 393216,
    SF_FORMAT_NIST___35 = 458752,
    SF_FORMAT_VOC___35 = 524288,
    SF_FORMAT_IRCAM___35 = 655360,
    SF_FORMAT_W64___35 = 720896,
    SF_FORMAT_MAT4___35 = 786432,
    SF_FORMAT_MAT5___35 = 851968,
    SF_FORMAT_PVF___35 = 917504,
    SF_FORMAT_XI___35 = 983040,
    SF_FORMAT_HTK___35 = 1048576,
    SF_FORMAT_SDS___35 = 1114112,
    SF_FORMAT_AVR___35 = 1179648,
    SF_FORMAT_WAVEX___35 = 1245184,
    SF_FORMAT_SD2___35 = 1441792,
    SF_FORMAT_FLAC___35 = 1507328,
    SF_FORMAT_CAF___35 = 1572864,
    SF_FORMAT_WVE___35 = 1638400,
    SF_FORMAT_OGG___35 = 2097152,
    SF_FORMAT_MPC2K___35 = 2162688,
    SF_FORMAT_RF64___35 = 2228224,
    SF_FORMAT_PCM_S8___35 = 1,
    SF_FORMAT_PCM_16___35 = 2,
    SF_FORMAT_PCM_24___35 = 3,
    SF_FORMAT_PCM_32___35 = 4,
    SF_FORMAT_PCM_U8___35 = 5,
    SF_FORMAT_FLOAT___35 = 6,
    SF_FORMAT_DOUBLE___35 = 7,
    SF_FORMAT_ULAW___35 = 16,
    SF_FORMAT_ALAW___35 = 17,
    SF_FORMAT_IMA_ADPCM___35 = 18,
    SF_FORMAT_MS_ADPCM___35 = 19,
    SF_FORMAT_GSM610___35 = 32,
    SF_FORMAT_VOX_ADPCM___35 = 33,
    SF_FORMAT_G721_32___35 = 48,
    SF_FORMAT_G723_24___35 = 49,
    SF_FORMAT_G723_40___35 = 50,
    SF_FORMAT_DWVW_12___35 = 64,
    SF_FORMAT_DWVW_16___35 = 65,
    SF_FORMAT_DWVW_24___35 = 66,
    SF_FORMAT_DWVW_N___35 = 67,
    SF_FORMAT_DPCM_8___35 = 80,
    SF_FORMAT_DPCM_16___35 = 81,
    SF_FORMAT_VORBIS___35 = 96,
    SF_ENDIAN_FILE___35 = 0,
    SF_ENDIAN_LITTLE___35 = 268435456,
    SF_ENDIAN_BIG___35 = 536870912,
    SF_ENDIAN_CPU___35 = 805306368,
    SF_FORMAT_SUBMASK___35 = 65535,
    SF_FORMAT_TYPEMASK___35 = 268369920,
    SF_FORMAT_ENDMASK___35 = 805306368
} ;
#line 126
enum __anonenum__871 {
    SFC_GET_LIB_VERSION___35 = 4096,
    SFC_GET_LOG_INFO___35 = 4097,
    SFC_GET_CURRENT_SF_INFO___35 = 4098,
    SFC_GET_NORM_DOUBLE___35 = 4112,
    SFC_GET_NORM_FLOAT___35 = 4113,
    SFC_SET_NORM_DOUBLE___35 = 4114,
    SFC_SET_NORM_FLOAT___35 = 4115,
    SFC_SET_SCALE_FLOAT_INT_READ___35 = 4116,
    SFC_SET_SCALE_INT_FLOAT_WRITE___35 = 4117,
    SFC_GET_SIMPLE_FORMAT_COUNT___35 = 4128,
    SFC_GET_SIMPLE_FORMAT___35 = 4129,
    SFC_GET_FORMAT_INFO___35 = 4136,
    SFC_GET_FORMAT_MAJOR_COUNT___35 = 4144,
    SFC_GET_FORMAT_MAJOR___35 = 4145,
    SFC_GET_FORMAT_SUBTYPE_COUNT___35 = 4146,
    SFC_GET_FORMAT_SUBTYPE___35 = 4147,
    SFC_CALC_SIGNAL_MAX___35 = 4160,
    SFC_CALC_NORM_SIGNAL_MAX___35 = 4161,
    SFC_CALC_MAX_ALL_CHANNELS___35 = 4162,
    SFC_CALC_NORM_MAX_ALL_CHANNELS___35 = 4163,
    SFC_GET_SIGNAL_MAX___35 = 4164,
    SFC_GET_MAX_ALL_CHANNELS___35 = 4165,
    SFC_SET_ADD_PEAK_CHUNK___35 = 4176,
    SFC_SET_ADD_HEADER_PAD_CHUNK___35 = 4177,
    SFC_UPDATE_HEADER_NOW___35 = 4192,
    SFC_SET_UPDATE_HEADER_AUTO___35 = 4193,
    SFC_FILE_TRUNCATE___35 = 4224,
    SFC_SET_RAW_START_OFFSET___35 = 4240,
    SFC_SET_DITHER_ON_WRITE___35 = 4256,
    SFC_SET_DITHER_ON_READ___35 = 4257,
    SFC_GET_DITHER_INFO_COUNT___35 = 4258,
    SFC_GET_DITHER_INFO___35 = 4259,
    SFC_GET_EMBED_FILE_INFO___35 = 4272,
    SFC_SET_CLIPPING___35 = 4288,
    SFC_GET_CLIPPING___35 = 4289,
    SFC_GET_INSTRUMENT___35 = 4304,
    SFC_SET_INSTRUMENT___35 = 4305,
    SFC_GET_LOOP_INFO___35 = 4320,
    SFC_GET_BROADCAST_INFO___35 = 4336,
    SFC_SET_BROADCAST_INFO___35 = 4337,
    SFC_GET_CHANNEL_MAP_INFO___35 = 4352,
    SFC_SET_CHANNEL_MAP_INFO___35 = 4353,
    SFC_RAW_DATA_NEEDS_ENDSWAP___35 = 4368,
    SFC_WAVEX_SET_AMBISONIC___35 = 4608,
    SFC_WAVEX_GET_AMBISONIC___35 = 4609,
    SFC_SET_VBR_ENCODING_QUALITY___35 = 4864,
    SFC_TEST_IEEE_FLOAT_REPLACE___35 = 24577,
    SFC_SET_ADD_DITHER_ON_WRITE___35 = 4208,
    SFC_SET_ADD_DITHER_ON_READ___35 = 4209
} ;
#line 216
enum __anonenum__872 {
    SF_STR_TITLE___35 = 1,
    SF_STR_COPYRIGHT___35 = 2,
    SF_STR_SOFTWARE___35 = 3,
    SF_STR_ARTIST___35 = 4,
    SF_STR_COMMENT___35 = 5,
    SF_STR_DATE___35 = 6,
    SF_STR_ALBUM___35 = 7,
    SF_STR_LICENSE___35 = 8
} ;
#line 235
enum __anonenum__873 {
    SF_FALSE___35 = 0,
    SF_TRUE___35 = 1,
    SFM_READ___35 = 16,
    SFM_WRITE___35 = 32,
    SFM_RDWR___35 = 48,
    SF_AMBISONIC_NONE___35 = 64,
    SF_AMBISONIC_B_FORMAT___35 = 65
} ;
#line 255
enum __anonenum__874 {
    SF_ERR_NO_ERROR___35 = 0,
    SF_ERR_UNRECOGNISED_FORMAT___35 = 1,
    SF_ERR_SYSTEM___35 = 2,
    SF_ERR_MALFORMED_FILE___35 = 3,
    SF_ERR_UNSUPPORTED_ENCODING___35 = 4
} ;
#line 267
enum __anonenum__875 {
    SF_CHANNEL_MAP_INVALID___35 = 0,
    SF_CHANNEL_MAP_MONO___35 = 1,
    SF_CHANNEL_MAP_LEFT___35 = 2,
    SF_CHANNEL_MAP_RIGHT___35 = 3,
    SF_CHANNEL_MAP_CENTER___35 = 4,
    SF_CHANNEL_MAP_FRONT_LEFT___35 = 5,
    SF_CHANNEL_MAP_FRONT_RIGHT___35 = 6,
    SF_CHANNEL_MAP_FRONT_CENTER___35 = 7,
    SF_CHANNEL_MAP_REAR_CENTER___35 = 8,
    SF_CHANNEL_MAP_REAR_LEFT___35 = 9,
    SF_CHANNEL_MAP_REAR_RIGHT___35 = 10,
    SF_CHANNEL_MAP_LFE___35 = 11,
    SF_CHANNEL_MAP_FRONT_LEFT_OF_CENTER___35 = 12,
    SF_CHANNEL_MAP_FRONT_RIGHT_OF_CENTER___35 = 13,
    SF_CHANNEL_MAP_SIDE_LEFT___35 = 14,
    SF_CHANNEL_MAP_SIDE_RIGHT___35 = 15,
    SF_CHANNEL_MAP_TOP_CENTER___35 = 16,
    SF_CHANNEL_MAP_TOP_FRONT_LEFT___35 = 17,
    SF_CHANNEL_MAP_TOP_FRONT_RIGHT___35 = 18,
    SF_CHANNEL_MAP_TOP_FRONT_CENTER___35 = 19,
    SF_CHANNEL_MAP_TOP_REAR_LEFT___35 = 20,
    SF_CHANNEL_MAP_TOP_REAR_RIGHT___35 = 21,
    SF_CHANNEL_MAP_TOP_REAR_CENTER___35 = 22
} ;
#line 352
enum __anonenum__877 {
    SFD_DEFAULT_LEVEL___35 = 0,
    SFD_CUSTOM_LEVEL___35 = 1073741824,
    SFD_NO_DITHER___35 = 500,
    SFD_WHITE___35 = 501,
    SFD_TRIANGULAR_PDF___35 = 502
} ;
#line 380
enum __anonenum__880 {
    SF_LOOP_NONE___35 = 800,
    SF_LOOP_FORWARD___35 = 801,
    SF_LOOP_BACKWARD___35 = 802,
    SF_LOOP_ALTERNATING___35 = 803
} ;
#line 121 "/root/libsndfile/src/common.h"
enum __anonenum__889 {
    SF_PEAK_START___35 = 42,
    SF_PEAK_END___35 = 43,
    SF_SCALE_MAX___35 = 52,
    SF_SCALE_MIN___35 = 53,
    SF_STR_ALLOW_START___35 = 256,
    SF_STR_ALLOW_END___35 = 512,
    SF_STR_LOCATE_START___35 = 1024,
    SF_STR_LOCATE_END___35 = 2048,
    SFD_TYPEMASK___35 = 268435455
} ;
#line 149
enum __anonenum__890 {
    SF_FORMAT_TXW___35 = 67305472,
    SF_FORMAT_DWD___35 = 67371008,
    SF_FORMAT_REX___35 = 67764224,
    SF_FORMAT_REX2___35 = 67960832,
    SF_FORMAT_KRZ___35 = 68026368,
    SF_FORMAT_WMA___35 = 68157440,
    SF_FORMAT_SHN___35 = 68222976,
    SF_FORMAT_SVX_FIB___35 = 4128,
    SF_FORMAT_SVX_EXP___35 = 4129,
    SF_FORMAT_PCM_N___35 = 4144
} ;
#line 405
enum __anonenum__896 {
    SFE_NO_ERROR___35 = 0,
    SFE_BAD_OPEN_FORMAT___35 = 1,
    SFE_SYSTEM___35 = 2,
    SFE_MALFORMED_FILE___35 = 3,
    SFE_UNSUPPORTED_ENCODING___35 = 4,
    SFE_ZERO_MAJOR_FORMAT___35 = 5,
    SFE_ZERO_MINOR_FORMAT___35 = 6,
    SFE_BAD_FILE___35 = 7,
    SFE_BAD_FILE_READ___35 = 8,
    SFE_OPEN_FAILED___35 = 9,
    SFE_BAD_SNDFILE_PTR___35 = 10,
    SFE_BAD_SF_INFO_PTR___35 = 11,
    SFE_BAD_SF_INCOMPLETE___35 = 12,
    SFE_BAD_FILE_PTR___35 = 13,
    SFE_BAD_INT_PTR___35 = 14,
    SFE_BAD_STAT_SIZE___35 = 15,
    SFE_MALLOC_FAILED___35 = 16,
    SFE_UNIMPLEMENTED___35 = 17,
    SFE_BAD_READ_ALIGN___35 = 18,
    SFE_BAD_WRITE_ALIGN___35 = 19,
    SFE_UNKNOWN_FORMAT___35 = 20,
    SFE_NOT_READMODE___35 = 21,
    SFE_NOT_WRITEMODE___35 = 22,
    SFE_BAD_MODE_RW___35 = 23,
    SFE_BAD_SF_INFO___35 = 24,
    SFE_BAD_OFFSET___35 = 25,
    SFE_NO_EMBED_SUPPORT___35 = 26,
    SFE_NO_EMBEDDED_RDWR___35 = 27,
    SFE_NO_PIPE_WRITE___35 = 28,
    SFE_INTERNAL___35 = 29,
    SFE_BAD_COMMAND_PARAM___35 = 30,
    SFE_BAD_ENDIAN___35 = 31,
    SFE_CHANNEL_COUNT_ZERO___35 = 32,
    SFE_CHANNEL_COUNT___35 = 33,
    SFE_BAD_VIRTUAL_IO___35 = 34,
    SFE_INTERLEAVE_MODE___35 = 35,
    SFE_INTERLEAVE_SEEK___35 = 36,
    SFE_INTERLEAVE_READ___35 = 37,
    SFE_BAD_SEEK___35 = 38,
    SFE_NOT_SEEKABLE___35 = 39,
    SFE_AMBIGUOUS_SEEK___35 = 40,
    SFE_WRONG_SEEK___35 = 41,
    SFE_SEEK_FAILED___35 = 42,
    SFE_BAD_OPEN_MODE___35 = 43,
    SFE_OPEN_PIPE_RDWR___35 = 44,
    SFE_RDWR_POSITION___35 = 45,
    SFE_RDWR_BAD_HEADER___35 = 46,
    SFE_CMD_HAS_DATA___35 = 47,
    SFE_BAD_BROADCAST_INFO_SIZE___35 = 48,
    SFE_STR_NO_SUPPORT___35 = 49,
    SFE_STR_NOT_WRITE___35 = 50,
    SFE_STR_MAX_DATA___35 = 51,
    SFE_STR_MAX_COUNT___35 = 52,
    SFE_STR_BAD_TYPE___35 = 53,
    SFE_STR_NO_ADD_END___35 = 54,
    SFE_STR_BAD_STRING___35 = 55,
    SFE_STR_WEIRD___35 = 56,
    SFE_WAV_NO_RIFF___35 = 57,
    SFE_WAV_NO_WAVE___35 = 58,
    SFE_WAV_NO_FMT___35 = 59,
    SFE_WAV_BAD_FMT___35 = 60,
    SFE_WAV_FMT_SHORT___35 = 61,
    SFE_WAV_BAD_FACT___35 = 62,
    SFE_WAV_BAD_PEAK___35 = 63,
    SFE_WAV_PEAK_B4_FMT___35 = 64,
    SFE_WAV_BAD_FORMAT___35 = 65,
    SFE_WAV_BAD_BLOCKALIGN___35 = 66,
    SFE_WAV_NO_DATA___35 = 67,
    SFE_WAV_BAD_LIST___35 = 68,
    SFE_WAV_ADPCM_NOT4BIT___35 = 69,
    SFE_WAV_ADPCM_CHANNELS___35 = 70,
    SFE_WAV_GSM610_FORMAT___35 = 71,
    SFE_WAV_UNKNOWN_CHUNK___35 = 72,
    SFE_WAV_WVPK_DATA___35 = 73,
    SFE_AIFF_NO_FORM___35 = 74,
    SFE_AIFF_AIFF_NO_FORM___35 = 75,
    SFE_AIFF_COMM_NO_FORM___35 = 76,
    SFE_AIFF_SSND_NO_COMM___35 = 77,
    SFE_AIFF_UNKNOWN_CHUNK___35 = 78,
    SFE_AIFF_COMM_CHUNK_SIZE___35 = 79,
    SFE_AIFF_BAD_COMM_CHUNK___35 = 80,
    SFE_AIFF_PEAK_B4_COMM___35 = 81,
    SFE_AIFF_BAD_PEAK___35 = 82,
    SFE_AIFF_NO_SSND___35 = 83,
    SFE_AIFF_NO_DATA___35 = 84,
    SFE_AIFF_RW_SSND_NOT_LAST___35 = 85,
    SFE_AU_UNKNOWN_FORMAT___35 = 86,
    SFE_AU_NO_DOTSND___35 = 87,
    SFE_AU_EMBED_BAD_LEN___35 = 88,
    SFE_RAW_READ_BAD_SPEC___35 = 89,
    SFE_RAW_BAD_BITWIDTH___35 = 90,
    SFE_RAW_BAD_FORMAT___35 = 91,
    SFE_PAF_NO_MARKER___35 = 92,
    SFE_PAF_VERSION___35 = 93,
    SFE_PAF_UNKNOWN_FORMAT___35 = 94,
    SFE_PAF_SHORT_HEADER___35 = 95,
    SFE_SVX_NO_FORM___35 = 96,
    SFE_SVX_NO_BODY___35 = 97,
    SFE_SVX_NO_DATA___35 = 98,
    SFE_SVX_BAD_COMP___35 = 99,
    SFE_SVX_BAD_NAME_LENGTH___35 = 100,
    SFE_NIST_BAD_HEADER___35 = 101,
    SFE_NIST_CRLF_CONVERISON___35 = 102,
    SFE_NIST_BAD_ENCODING___35 = 103,
    SFE_VOC_NO_CREATIVE___35 = 104,
    SFE_VOC_BAD_FORMAT___35 = 105,
    SFE_VOC_BAD_VERSION___35 = 106,
    SFE_VOC_BAD_MARKER___35 = 107,
    SFE_VOC_BAD_SECTIONS___35 = 108,
    SFE_VOC_MULTI_SAMPLERATE___35 = 109,
    SFE_VOC_MULTI_SECTION___35 = 110,
    SFE_VOC_MULTI_PARAM___35 = 111,
    SFE_VOC_SECTION_COUNT___35 = 112,
    SFE_VOC_NO_PIPE___35 = 113,
    SFE_IRCAM_NO_MARKER___35 = 114,
    SFE_IRCAM_BAD_CHANNELS___35 = 115,
    SFE_IRCAM_UNKNOWN_FORMAT___35 = 116,
    SFE_W64_64_BIT___35 = 117,
    SFE_W64_NO_RIFF___35 = 118,
    SFE_W64_NO_WAVE___35 = 119,
    SFE_W64_NO_DATA___35 = 120,
    SFE_W64_ADPCM_NOT4BIT___35 = 121,
    SFE_W64_ADPCM_CHANNELS___35 = 122,
    SFE_W64_GSM610_FORMAT___35 = 123,
    SFE_MAT4_BAD_NAME___35 = 124,
    SFE_MAT4_NO_SAMPLERATE___35 = 125,
    SFE_MAT5_BAD_ENDIAN___35 = 126,
    SFE_MAT5_NO_BLOCK___35 = 127,
    SFE_MAT5_SAMPLE_RATE___35 = 128,
    SFE_PVF_NO_PVF1___35 = 129,
    SFE_PVF_BAD_HEADER___35 = 130,
    SFE_PVF_BAD_BITWIDTH___35 = 131,
    SFE_DWVW_BAD_BITWIDTH___35 = 132,
    SFE_G72X_NOT_MONO___35 = 133,
    SFE_XI_BAD_HEADER___35 = 134,
    SFE_XI_EXCESS_SAMPLES___35 = 135,
    SFE_XI_NO_PIPE___35 = 136,
    SFE_HTK_NO_PIPE___35 = 137,
    SFE_SDS_NOT_SDS___35 = 138,
    SFE_SDS_BAD_BIT_WIDTH___35 = 139,
    SFE_SD2_FD_DISALLOWED___35 = 140,
    SFE_SD2_BAD_DATA_OFFSET___35 = 141,
    SFE_SD2_BAD_MAP_OFFSET___35 = 142,
    SFE_SD2_BAD_DATA_LENGTH___35 = 143,
    SFE_SD2_BAD_MAP_LENGTH___35 = 144,
    SFE_SD2_BAD_RSRC___35 = 145,
    SFE_SD2_BAD_SAMPLE_SIZE___35 = 146,
    SFE_FLAC_BAD_HEADER___35 = 147,
    SFE_FLAC_NEW_DECODER___35 = 148,
    SFE_FLAC_INIT_DECODER___35 = 149,
    SFE_FLAC_LOST_SYNC___35 = 150,
    SFE_FLAC_BAD_SAMPLE_RATE___35 = 151,
    SFE_FLAC_UNKOWN_ERROR___35 = 152,
    SFE_WVE_NOT_WVE___35 = 153,
    SFE_WVE_NO_PIPE___35 = 154,
    SFE_VORBIS_ENCODER_BUG___35 = 155,
    SFE_RF64_NOT_RF64___35 = 156,
    SFE_MAX_ERROR___35 = 157
} ;
#line 823
enum __anonenum__900 {
    SFC_TEST_AIFF_ADD_INST_CHUNK___35 = 8192,
    SFC_TEST_WAV_ADD_INFO_CHUNK___35 = 8208
} ;
#line 34 "/usr/include/inttypes.h"
typedef int __gwchar_t;
#line 271 "/usr/include/inttypes.h"
struct __anonstruct_901 {
   long quot ;
   long rem ;
};
#line 275 "/usr/include/inttypes.h"
typedef struct __anonstruct_901 imaxdiv_t;
#line 19 "/usr/include/ogg/config_types.h"
typedef int16_t ogg_int16_t;
#line 20 "/usr/include/ogg/config_types.h"
typedef uint16_t ogg_uint16_t;
#line 21 "/usr/include/ogg/config_types.h"
typedef int32_t ogg_int32_t;
#line 22 "/usr/include/ogg/config_types.h"
typedef uint32_t ogg_uint32_t;
#line 23 "/usr/include/ogg/config_types.h"
typedef int64_t ogg_int64_t;
#line 24 "/usr/include/ogg/config_types.h"
typedef uint64_t ogg_uint64_t;
#line 26 "/usr/include/ogg/ogg.h"
struct __anonstruct_902 {
   void *iov_base ;
   size_t iov_len ;
};
#line 29 "/usr/include/ogg/ogg.h"
typedef struct __anonstruct_902 ogg_iovec_t;
#line 31 "/usr/include/ogg/ogg.h"
struct __anonstruct_903 {
   long endbyte ;
   int endbit ;
   unsigned char *buffer ;
   unsigned char *ptr ;
   long storage ;
};
#line 38 "/usr/include/ogg/ogg.h"
typedef struct __anonstruct_903 oggpack_buffer;
#line 42 "/usr/include/ogg/ogg.h"
struct __anonstruct_904 {
   unsigned char *header ;
   long header_len ;
   unsigned char *body ;
   long body_len ;
};
#line 47 "/usr/include/ogg/ogg.h"
typedef struct __anonstruct_904 ogg_page;
#line 52 "/usr/include/ogg/ogg.h"
struct __anonstruct_905 {
   unsigned char *body_data ;
   long body_storage ;
   long body_fill ;
   long body_returned ;
   int *lacing_vals ;
   ogg_int64_t *granule_vals ;
   long lacing_storage ;
   long lacing_fill ;
   long lacing_packet ;
   long lacing_returned ;
   unsigned char header[282] ;
   int header_fill ;
   int e_o_s ;
   int b_o_s ;
   long serialno ;
   long pageno ;
   ogg_int64_t packetno ;
   ogg_int64_t granulepos ;
};
#line 84 "/usr/include/ogg/ogg.h"
typedef struct __anonstruct_905 ogg_stream_state;
#line 89 "/usr/include/ogg/ogg.h"
struct __anonstruct_906 {
   unsigned char *packet ;
   long bytes ;
   long b_o_s ;
   long e_o_s ;
   ogg_int64_t granulepos ;
   ogg_int64_t packetno ;
};
#line 102 "/usr/include/ogg/ogg.h"
typedef struct __anonstruct_906 ogg_packet;
#line 104 "/usr/include/ogg/ogg.h"
struct __anonstruct_907 {
   unsigned char *data ;
   int storage ;
   int fill ;
   int returned ;
   int unsynced ;
   int headerbytes ;
   int bodybytes ;
};
#line 113 "/usr/include/ogg/ogg.h"
typedef struct __anonstruct_907 ogg_sync_state;
#line 27 "/usr/include/vorbis/codec.h"
struct vorbis_info {
   int version ;
   int channels ;
   long rate ;
   long bitrate_upper ;
   long bitrate_nominal ;
   long bitrate_lower ;
   long bitrate_window ;
   void *codec_setup ;
};
#line 53 "/usr/include/vorbis/codec.h"
typedef struct vorbis_info vorbis_info;
#line 58 "/usr/include/vorbis/codec.h"
struct vorbis_dsp_state {
   int analysisp ;
   vorbis_info *vi ;
   float **pcm ;
   float **pcmret ;
   int pcm_storage ;
   int pcm_current ;
   int pcm_returned ;
   int preextrapolate ;
   int eofflag ;
   long lW ;
   long W ;
   long nW ;
   long centerW ;
   ogg_int64_t granulepos ;
   ogg_int64_t sequence ;
   ogg_int64_t glue_bits ;
   ogg_int64_t time_bits ;
   ogg_int64_t floor_bits ;
   ogg_int64_t res_bits ;
   void *backend_state ;
};
#line 85 "/usr/include/vorbis/codec.h"
typedef struct vorbis_dsp_state vorbis_dsp_state;
#line 109
struct alloc_chain ;
#line 87 "/usr/include/vorbis/codec.h"
struct vorbis_block {
   float **pcm ;
   oggpack_buffer opb ;
   long lW ;
   long W ;
   long nW ;
   int pcmend ;
   int mode ;
   int eofflag ;
   ogg_int64_t granulepos ;
   ogg_int64_t sequence ;
   vorbis_dsp_state *vd ;
   void *localstore ;
   long localtop ;
   long localalloc ;
   long totaluse ;
   struct alloc_chain *reap ;
   long glue_bits ;
   long time_bits ;
   long floor_bits ;
   long res_bits ;
   void *internal ;
};
#line 119 "/usr/include/vorbis/codec.h"
typedef struct vorbis_block vorbis_block;
#line 126 "/usr/include/vorbis/codec.h"
struct alloc_chain {
   void *ptr ;
   struct alloc_chain *next ;
};
#line 139 "/usr/include/vorbis/codec.h"
struct vorbis_comment {
   char **user_comments ;
   int *comment_lengths ;
   int comments ;
   char *vendor ;
};
#line 147 "/usr/include/vorbis/codec.h"
typedef struct vorbis_comment vorbis_comment;
#line 232 "/usr/include/vorbis/vorbisenc.h"
struct ovectl_ratemanage_arg {
   int management_active ;
   long bitrate_hard_min ;
   long bitrate_hard_max ;
   double bitrate_hard_window ;
   long bitrate_av_lo ;
   long bitrate_av_hi ;
   double bitrate_av_window ;
   double bitrate_av_window_center ;
};
#line 269 "/usr/include/vorbis/vorbisenc.h"
struct ovectl_ratemanage2_arg {
   int management_active ;
   long bitrate_limit_min_kbps ;
   long bitrate_limit_max_kbps ;
   long bitrate_limit_reservoir_bits ;
   double bitrate_limit_reservoir_bias ;
   long bitrate_average_kbps ;
   double bitrate_average_damping ;
};
#line 75 "/root/libsndfile/src/ogg.c"
typedef int convert_func(int  , void * , int  , int  , float ** );
#line 93 "/root/libsndfile/src/ogg.c"
struct __anonstruct_908 {
   int id ;
   char const   *name ;
};
#line 96 "/root/libsndfile/src/ogg.c"
typedef struct __anonstruct_908 STR_PAIRS;
#line 109 "/root/libsndfile/src/ogg.c"
struct __anonstruct_909 {
   ogg_sync_state oy ;
   ogg_stream_state os ;
   ogg_page og ;
   ogg_packet op ;
   int eos ;
};
#line 119 "/root/libsndfile/src/ogg.c"
typedef struct __anonstruct_909 OGG_PRIVATE;
#line 121 "/root/libsndfile/src/ogg.c"
struct __anonstruct_910 {
   sf_count_t loc ;
   vorbis_info vi ;
   vorbis_comment vc ;
   vorbis_dsp_state vd ;
   vorbis_block vb ;
   double quality ;
};
#line 135 "/root/libsndfile/src/ogg.c"
typedef struct __anonstruct_910 VORBIS_PRIVATE;
#line 897 "/root/libsndfile/src/ogg.c"
struct __anonstruct_911 {
   int isillegal ;
   int shownillegal ;
   int isnew ;
   int end ;
   uint32_t serial ;
   ogg_stream_state os ;
   vorbis_info vi ;
   vorbis_comment vc ;
   sf_count_t lastgranulepos ;
   int doneheaders ;
};
#line 911 "/root/libsndfile/src/ogg.c"
typedef struct __anonstruct_911 stream_processor;
#line 913 "/root/libsndfile/src/ogg.c"
struct __anonstruct_912 {
   stream_processor *streams ;
   int allocated ;
   int used ;
   int in_headers ;
};
#line 919 "/root/libsndfile/src/ogg.c"
typedef struct __anonstruct_912 stream_set;
#line 46 "/usr/include/ctype.h"
enum __anonenum__510___5 {
    _ISupper___15 = 256,
    _ISlower___15 = 512,
    _ISalpha___15 = 1024,
    _ISdigit___15 = 2048,
    _ISxdigit___15 = 4096,
    _ISspace___15 = 8192,
    _ISprint___15 = 16384,
    _ISgraph___15 = 32768,
    _ISblank___15 = 1,
    _IScntrl___15 = 2,
    _ISpunct___15 = 4,
    _ISalnum___15 = 8
} ;
#line 46 "/root/libsndfile/src/sndfile.h"
enum __anonenum__524___4 {
    SF_FORMAT_WAV___36 = 65536,
    SF_FORMAT_AIFF___36 = 131072,
    SF_FORMAT_AU___36 = 196608,
    SF_FORMAT_RAW___36 = 262144,
    SF_FORMAT_PAF___36 = 327680,
    SF_FORMAT_SVX___36 = 393216,
    SF_FORMAT_NIST___36 = 458752,
    SF_FORMAT_VOC___36 = 524288,
    SF_FORMAT_IRCAM___36 = 655360,
    SF_FORMAT_W64___36 = 720896,
    SF_FORMAT_MAT4___36 = 786432,
    SF_FORMAT_MAT5___36 = 851968,
    SF_FORMAT_PVF___36 = 917504,
    SF_FORMAT_XI___36 = 983040,
    SF_FORMAT_HTK___36 = 1048576,
    SF_FORMAT_SDS___36 = 1114112,
    SF_FORMAT_AVR___36 = 1179648,
    SF_FORMAT_WAVEX___36 = 1245184,
    SF_FORMAT_SD2___36 = 1441792,
    SF_FORMAT_FLAC___36 = 1507328,
    SF_FORMAT_CAF___36 = 1572864,
    SF_FORMAT_WVE___36 = 1638400,
    SF_FORMAT_OGG___36 = 2097152,
    SF_FORMAT_MPC2K___36 = 2162688,
    SF_FORMAT_RF64___36 = 2228224,
    SF_FORMAT_PCM_S8___36 = 1,
    SF_FORMAT_PCM_16___36 = 2,
    SF_FORMAT_PCM_24___36 = 3,
    SF_FORMAT_PCM_32___36 = 4,
    SF_FORMAT_PCM_U8___36 = 5,
    SF_FORMAT_FLOAT___36 = 6,
    SF_FORMAT_DOUBLE___36 = 7,
    SF_FORMAT_ULAW___36 = 16,
    SF_FORMAT_ALAW___36 = 17,
    SF_FORMAT_IMA_ADPCM___36 = 18,
    SF_FORMAT_MS_ADPCM___36 = 19,
    SF_FORMAT_GSM610___36 = 32,
    SF_FORMAT_VOX_ADPCM___36 = 33,
    SF_FORMAT_G721_32___36 = 48,
    SF_FORMAT_G723_24___36 = 49,
    SF_FORMAT_G723_40___36 = 50,
    SF_FORMAT_DWVW_12___36 = 64,
    SF_FORMAT_DWVW_16___36 = 65,
    SF_FORMAT_DWVW_24___36 = 66,
    SF_FORMAT_DWVW_N___36 = 67,
    SF_FORMAT_DPCM_8___36 = 80,
    SF_FORMAT_DPCM_16___36 = 81,
    SF_FORMAT_VORBIS___36 = 96,
    SF_ENDIAN_FILE___36 = 0,
    SF_ENDIAN_LITTLE___36 = 268435456,
    SF_ENDIAN_BIG___36 = 536870912,
    SF_ENDIAN_CPU___36 = 805306368,
    SF_FORMAT_SUBMASK___36 = 65535,
    SF_FORMAT_TYPEMASK___36 = 268369920,
    SF_FORMAT_ENDMASK___36 = 805306368
} ;
#line 126
enum __anonenum__525___4 {
    SFC_GET_LIB_VERSION___36 = 4096,
    SFC_GET_LOG_INFO___36 = 4097,
    SFC_GET_CURRENT_SF_INFO___36 = 4098,
    SFC_GET_NORM_DOUBLE___36 = 4112,
    SFC_GET_NORM_FLOAT___36 = 4113,
    SFC_SET_NORM_DOUBLE___36 = 4114,
    SFC_SET_NORM_FLOAT___36 = 4115,
    SFC_SET_SCALE_FLOAT_INT_READ___36 = 4116,
    SFC_SET_SCALE_INT_FLOAT_WRITE___36 = 4117,
    SFC_GET_SIMPLE_FORMAT_COUNT___36 = 4128,
    SFC_GET_SIMPLE_FORMAT___36 = 4129,
    SFC_GET_FORMAT_INFO___36 = 4136,
    SFC_GET_FORMAT_MAJOR_COUNT___36 = 4144,
    SFC_GET_FORMAT_MAJOR___36 = 4145,
    SFC_GET_FORMAT_SUBTYPE_COUNT___36 = 4146,
    SFC_GET_FORMAT_SUBTYPE___36 = 4147,
    SFC_CALC_SIGNAL_MAX___36 = 4160,
    SFC_CALC_NORM_SIGNAL_MAX___36 = 4161,
    SFC_CALC_MAX_ALL_CHANNELS___36 = 4162,
    SFC_CALC_NORM_MAX_ALL_CHANNELS___36 = 4163,
    SFC_GET_SIGNAL_MAX___36 = 4164,
    SFC_GET_MAX_ALL_CHANNELS___36 = 4165,
    SFC_SET_ADD_PEAK_CHUNK___36 = 4176,
    SFC_SET_ADD_HEADER_PAD_CHUNK___36 = 4177,
    SFC_UPDATE_HEADER_NOW___36 = 4192,
    SFC_SET_UPDATE_HEADER_AUTO___36 = 4193,
    SFC_FILE_TRUNCATE___36 = 4224,
    SFC_SET_RAW_START_OFFSET___36 = 4240,
    SFC_SET_DITHER_ON_WRITE___36 = 4256,
    SFC_SET_DITHER_ON_READ___36 = 4257,
    SFC_GET_DITHER_INFO_COUNT___36 = 4258,
    SFC_GET_DITHER_INFO___36 = 4259,
    SFC_GET_EMBED_FILE_INFO___36 = 4272,
    SFC_SET_CLIPPING___36 = 4288,
    SFC_GET_CLIPPING___36 = 4289,
    SFC_GET_INSTRUMENT___36 = 4304,
    SFC_SET_INSTRUMENT___36 = 4305,
    SFC_GET_LOOP_INFO___36 = 4320,
    SFC_GET_BROADCAST_INFO___36 = 4336,
    SFC_SET_BROADCAST_INFO___36 = 4337,
    SFC_GET_CHANNEL_MAP_INFO___36 = 4352,
    SFC_SET_CHANNEL_MAP_INFO___36 = 4353,
    SFC_RAW_DATA_NEEDS_ENDSWAP___36 = 4368,
    SFC_WAVEX_SET_AMBISONIC___36 = 4608,
    SFC_WAVEX_GET_AMBISONIC___36 = 4609,
    SFC_SET_VBR_ENCODING_QUALITY___36 = 4864,
    SFC_TEST_IEEE_FLOAT_REPLACE___36 = 24577,
    SFC_SET_ADD_DITHER_ON_WRITE___36 = 4208,
    SFC_SET_ADD_DITHER_ON_READ___36 = 4209
} ;
#line 216
enum __anonenum__526___4 {
    SF_STR_TITLE___36 = 1,
    SF_STR_COPYRIGHT___36 = 2,
    SF_STR_SOFTWARE___36 = 3,
    SF_STR_ARTIST___36 = 4,
    SF_STR_COMMENT___36 = 5,
    SF_STR_DATE___36 = 6,
    SF_STR_ALBUM___36 = 7,
    SF_STR_LICENSE___36 = 8
} ;
#line 235
enum __anonenum__527___4 {
    SF_FALSE___36 = 0,
    SF_TRUE___36 = 1,
    SFM_READ___36 = 16,
    SFM_WRITE___36 = 32,
    SFM_RDWR___36 = 48,
    SF_AMBISONIC_NONE___36 = 64,
    SF_AMBISONIC_B_FORMAT___36 = 65
} ;
#line 255
enum __anonenum__528___4 {
    SF_ERR_NO_ERROR___36 = 0,
    SF_ERR_UNRECOGNISED_FORMAT___36 = 1,
    SF_ERR_SYSTEM___36 = 2,
    SF_ERR_MALFORMED_FILE___36 = 3,
    SF_ERR_UNSUPPORTED_ENCODING___36 = 4
} ;
#line 267
enum __anonenum__529___4 {
    SF_CHANNEL_MAP_INVALID___36 = 0,
    SF_CHANNEL_MAP_MONO___36 = 1,
    SF_CHANNEL_MAP_LEFT___36 = 2,
    SF_CHANNEL_MAP_RIGHT___36 = 3,
    SF_CHANNEL_MAP_CENTER___36 = 4,
    SF_CHANNEL_MAP_FRONT_LEFT___36 = 5,
    SF_CHANNEL_MAP_FRONT_RIGHT___36 = 6,
    SF_CHANNEL_MAP_FRONT_CENTER___36 = 7,
    SF_CHANNEL_MAP_REAR_CENTER___36 = 8,
    SF_CHANNEL_MAP_REAR_LEFT___36 = 9,
    SF_CHANNEL_MAP_REAR_RIGHT___36 = 10,
    SF_CHANNEL_MAP_LFE___36 = 11,
    SF_CHANNEL_MAP_FRONT_LEFT_OF_CENTER___36 = 12,
    SF_CHANNEL_MAP_FRONT_RIGHT_OF_CENTER___36 = 13,
    SF_CHANNEL_MAP_SIDE_LEFT___36 = 14,
    SF_CHANNEL_MAP_SIDE_RIGHT___36 = 15,
    SF_CHANNEL_MAP_TOP_CENTER___36 = 16,
    SF_CHANNEL_MAP_TOP_FRONT_LEFT___36 = 17,
    SF_CHANNEL_MAP_TOP_FRONT_RIGHT___36 = 18,
    SF_CHANNEL_MAP_TOP_FRONT_CENTER___36 = 19,
    SF_CHANNEL_MAP_TOP_REAR_LEFT___36 = 20,
    SF_CHANNEL_MAP_TOP_REAR_RIGHT___36 = 21,
    SF_CHANNEL_MAP_TOP_REAR_CENTER___36 = 22
} ;
#line 352
enum __anonenum__531___4 {
    SFD_DEFAULT_LEVEL___36 = 0,
    SFD_CUSTOM_LEVEL___36 = 1073741824,
    SFD_NO_DITHER___36 = 500,
    SFD_WHITE___36 = 501,
    SFD_TRIANGULAR_PDF___36 = 502
} ;
#line 380
enum __anonenum__534___4 {
    SF_LOOP_NONE___36 = 800,
    SF_LOOP_FORWARD___36 = 801,
    SF_LOOP_BACKWARD___36 = 802,
    SF_LOOP_ALTERNATING___36 = 803
} ;
#line 121 "/root/libsndfile/src/common.h"
enum __anonenum__543___4 {
    SF_PEAK_START___36 = 42,
    SF_PEAK_END___36 = 43,
    SF_SCALE_MAX___36 = 52,
    SF_SCALE_MIN___36 = 53,
    SF_STR_ALLOW_START___36 = 256,
    SF_STR_ALLOW_END___36 = 512,
    SF_STR_LOCATE_START___36 = 1024,
    SF_STR_LOCATE_END___36 = 2048,
    SFD_TYPEMASK___36 = 268435455
} ;
#line 149
enum __anonenum__544___4 {
    SF_FORMAT_TXW___36 = 67305472,
    SF_FORMAT_DWD___36 = 67371008,
    SF_FORMAT_REX___36 = 67764224,
    SF_FORMAT_REX2___36 = 67960832,
    SF_FORMAT_KRZ___36 = 68026368,
    SF_FORMAT_WMA___36 = 68157440,
    SF_FORMAT_SHN___36 = 68222976,
    SF_FORMAT_SVX_FIB___36 = 4128,
    SF_FORMAT_SVX_EXP___36 = 4129,
    SF_FORMAT_PCM_N___36 = 4144
} ;
#line 405
enum __anonenum__550___4 {
    SFE_NO_ERROR___36 = 0,
    SFE_BAD_OPEN_FORMAT___36 = 1,
    SFE_SYSTEM___36 = 2,
    SFE_MALFORMED_FILE___36 = 3,
    SFE_UNSUPPORTED_ENCODING___36 = 4,
    SFE_ZERO_MAJOR_FORMAT___36 = 5,
    SFE_ZERO_MINOR_FORMAT___36 = 6,
    SFE_BAD_FILE___36 = 7,
    SFE_BAD_FILE_READ___36 = 8,
    SFE_OPEN_FAILED___36 = 9,
    SFE_BAD_SNDFILE_PTR___36 = 10,
    SFE_BAD_SF_INFO_PTR___36 = 11,
    SFE_BAD_SF_INCOMPLETE___36 = 12,
    SFE_BAD_FILE_PTR___36 = 13,
    SFE_BAD_INT_PTR___36 = 14,
    SFE_BAD_STAT_SIZE___36 = 15,
    SFE_MALLOC_FAILED___36 = 16,
    SFE_UNIMPLEMENTED___36 = 17,
    SFE_BAD_READ_ALIGN___36 = 18,
    SFE_BAD_WRITE_ALIGN___36 = 19,
    SFE_UNKNOWN_FORMAT___36 = 20,
    SFE_NOT_READMODE___36 = 21,
    SFE_NOT_WRITEMODE___36 = 22,
    SFE_BAD_MODE_RW___36 = 23,
    SFE_BAD_SF_INFO___36 = 24,
    SFE_BAD_OFFSET___36 = 25,
    SFE_NO_EMBED_SUPPORT___36 = 26,
    SFE_NO_EMBEDDED_RDWR___36 = 27,
    SFE_NO_PIPE_WRITE___36 = 28,
    SFE_INTERNAL___36 = 29,
    SFE_BAD_COMMAND_PARAM___36 = 30,
    SFE_BAD_ENDIAN___36 = 31,
    SFE_CHANNEL_COUNT_ZERO___36 = 32,
    SFE_CHANNEL_COUNT___36 = 33,
    SFE_BAD_VIRTUAL_IO___36 = 34,
    SFE_INTERLEAVE_MODE___36 = 35,
    SFE_INTERLEAVE_SEEK___36 = 36,
    SFE_INTERLEAVE_READ___36 = 37,
    SFE_BAD_SEEK___36 = 38,
    SFE_NOT_SEEKABLE___36 = 39,
    SFE_AMBIGUOUS_SEEK___36 = 40,
    SFE_WRONG_SEEK___36 = 41,
    SFE_SEEK_FAILED___36 = 42,
    SFE_BAD_OPEN_MODE___36 = 43,
    SFE_OPEN_PIPE_RDWR___36 = 44,
    SFE_RDWR_POSITION___36 = 45,
    SFE_RDWR_BAD_HEADER___36 = 46,
    SFE_CMD_HAS_DATA___36 = 47,
    SFE_BAD_BROADCAST_INFO_SIZE___36 = 48,
    SFE_STR_NO_SUPPORT___36 = 49,
    SFE_STR_NOT_WRITE___36 = 50,
    SFE_STR_MAX_DATA___36 = 51,
    SFE_STR_MAX_COUNT___36 = 52,
    SFE_STR_BAD_TYPE___36 = 53,
    SFE_STR_NO_ADD_END___36 = 54,
    SFE_STR_BAD_STRING___36 = 55,
    SFE_STR_WEIRD___36 = 56,
    SFE_WAV_NO_RIFF___36 = 57,
    SFE_WAV_NO_WAVE___36 = 58,
    SFE_WAV_NO_FMT___36 = 59,
    SFE_WAV_BAD_FMT___36 = 60,
    SFE_WAV_FMT_SHORT___36 = 61,
    SFE_WAV_BAD_FACT___36 = 62,
    SFE_WAV_BAD_PEAK___36 = 63,
    SFE_WAV_PEAK_B4_FMT___36 = 64,
    SFE_WAV_BAD_FORMAT___36 = 65,
    SFE_WAV_BAD_BLOCKALIGN___36 = 66,
    SFE_WAV_NO_DATA___36 = 67,
    SFE_WAV_BAD_LIST___36 = 68,
    SFE_WAV_ADPCM_NOT4BIT___36 = 69,
    SFE_WAV_ADPCM_CHANNELS___36 = 70,
    SFE_WAV_GSM610_FORMAT___36 = 71,
    SFE_WAV_UNKNOWN_CHUNK___36 = 72,
    SFE_WAV_WVPK_DATA___36 = 73,
    SFE_AIFF_NO_FORM___36 = 74,
    SFE_AIFF_AIFF_NO_FORM___36 = 75,
    SFE_AIFF_COMM_NO_FORM___36 = 76,
    SFE_AIFF_SSND_NO_COMM___36 = 77,
    SFE_AIFF_UNKNOWN_CHUNK___36 = 78,
    SFE_AIFF_COMM_CHUNK_SIZE___36 = 79,
    SFE_AIFF_BAD_COMM_CHUNK___36 = 80,
    SFE_AIFF_PEAK_B4_COMM___36 = 81,
    SFE_AIFF_BAD_PEAK___36 = 82,
    SFE_AIFF_NO_SSND___36 = 83,
    SFE_AIFF_NO_DATA___36 = 84,
    SFE_AIFF_RW_SSND_NOT_LAST___36 = 85,
    SFE_AU_UNKNOWN_FORMAT___36 = 86,
    SFE_AU_NO_DOTSND___36 = 87,
    SFE_AU_EMBED_BAD_LEN___36 = 88,
    SFE_RAW_READ_BAD_SPEC___36 = 89,
    SFE_RAW_BAD_BITWIDTH___36 = 90,
    SFE_RAW_BAD_FORMAT___36 = 91,
    SFE_PAF_NO_MARKER___36 = 92,
    SFE_PAF_VERSION___36 = 93,
    SFE_PAF_UNKNOWN_FORMAT___36 = 94,
    SFE_PAF_SHORT_HEADER___36 = 95,
    SFE_SVX_NO_FORM___36 = 96,
    SFE_SVX_NO_BODY___36 = 97,
    SFE_SVX_NO_DATA___36 = 98,
    SFE_SVX_BAD_COMP___36 = 99,
    SFE_SVX_BAD_NAME_LENGTH___36 = 100,
    SFE_NIST_BAD_HEADER___36 = 101,
    SFE_NIST_CRLF_CONVERISON___36 = 102,
    SFE_NIST_BAD_ENCODING___36 = 103,
    SFE_VOC_NO_CREATIVE___36 = 104,
    SFE_VOC_BAD_FORMAT___36 = 105,
    SFE_VOC_BAD_VERSION___36 = 106,
    SFE_VOC_BAD_MARKER___36 = 107,
    SFE_VOC_BAD_SECTIONS___36 = 108,
    SFE_VOC_MULTI_SAMPLERATE___36 = 109,
    SFE_VOC_MULTI_SECTION___36 = 110,
    SFE_VOC_MULTI_PARAM___36 = 111,
    SFE_VOC_SECTION_COUNT___36 = 112,
    SFE_VOC_NO_PIPE___36 = 113,
    SFE_IRCAM_NO_MARKER___36 = 114,
    SFE_IRCAM_BAD_CHANNELS___36 = 115,
    SFE_IRCAM_UNKNOWN_FORMAT___36 = 116,
    SFE_W64_64_BIT___36 = 117,
    SFE_W64_NO_RIFF___36 = 118,
    SFE_W64_NO_WAVE___36 = 119,
    SFE_W64_NO_DATA___36 = 120,
    SFE_W64_ADPCM_NOT4BIT___36 = 121,
    SFE_W64_ADPCM_CHANNELS___36 = 122,
    SFE_W64_GSM610_FORMAT___36 = 123,
    SFE_MAT4_BAD_NAME___36 = 124,
    SFE_MAT4_NO_SAMPLERATE___36 = 125,
    SFE_MAT5_BAD_ENDIAN___36 = 126,
    SFE_MAT5_NO_BLOCK___36 = 127,
    SFE_MAT5_SAMPLE_RATE___36 = 128,
    SFE_PVF_NO_PVF1___36 = 129,
    SFE_PVF_BAD_HEADER___36 = 130,
    SFE_PVF_BAD_BITWIDTH___36 = 131,
    SFE_DWVW_BAD_BITWIDTH___36 = 132,
    SFE_G72X_NOT_MONO___36 = 133,
    SFE_XI_BAD_HEADER___36 = 134,
    SFE_XI_EXCESS_SAMPLES___36 = 135,
    SFE_XI_NO_PIPE___36 = 136,
    SFE_HTK_NO_PIPE___36 = 137,
    SFE_SDS_NOT_SDS___36 = 138,
    SFE_SDS_BAD_BIT_WIDTH___36 = 139,
    SFE_SD2_FD_DISALLOWED___36 = 140,
    SFE_SD2_BAD_DATA_OFFSET___36 = 141,
    SFE_SD2_BAD_MAP_OFFSET___36 = 142,
    SFE_SD2_BAD_DATA_LENGTH___36 = 143,
    SFE_SD2_BAD_MAP_LENGTH___36 = 144,
    SFE_SD2_BAD_RSRC___36 = 145,
    SFE_SD2_BAD_SAMPLE_SIZE___36 = 146,
    SFE_FLAC_BAD_HEADER___36 = 147,
    SFE_FLAC_NEW_DECODER___36 = 148,
    SFE_FLAC_INIT_DECODER___36 = 149,
    SFE_FLAC_LOST_SYNC___36 = 150,
    SFE_FLAC_BAD_SAMPLE_RATE___36 = 151,
    SFE_FLAC_UNKOWN_ERROR___36 = 152,
    SFE_WVE_NOT_WVE___36 = 153,
    SFE_WVE_NO_PIPE___36 = 154,
    SFE_VORBIS_ENCODER_BUG___36 = 155,
    SFE_RF64_NOT_RF64___36 = 156,
    SFE_MAX_ERROR___36 = 157
} ;
#line 823
enum __anonenum__554___4 {
    SFC_TEST_AIFF_ADD_INST_CHUNK___36 = 8192,
    SFC_TEST_WAV_ADD_INFO_CHUNK___36 = 8208
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__510___6 {
    _ISupper___16 = 256,
    _ISlower___16 = 512,
    _ISalpha___16 = 1024,
    _ISdigit___16 = 2048,
    _ISxdigit___16 = 4096,
    _ISspace___16 = 8192,
    _ISprint___16 = 16384,
    _ISgraph___16 = 32768,
    _ISblank___16 = 1,
    _IScntrl___16 = 2,
    _ISpunct___16 = 4,
    _ISalnum___16 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__913 {
    FP_NAN___16 = 0,
    FP_INFINITE___16 = 1,
    FP_ZERO___16 = 2,
    FP_SUBNORMAL___16 = 3,
    FP_NORMAL___16 = 4
} ;
#line 46 "/root/libsndfile/src/sndfile.h"
enum __anonenum__928 {
    SF_FORMAT_WAV___37 = 65536,
    SF_FORMAT_AIFF___37 = 131072,
    SF_FORMAT_AU___37 = 196608,
    SF_FORMAT_RAW___37 = 262144,
    SF_FORMAT_PAF___37 = 327680,
    SF_FORMAT_SVX___37 = 393216,
    SF_FORMAT_NIST___37 = 458752,
    SF_FORMAT_VOC___37 = 524288,
    SF_FORMAT_IRCAM___37 = 655360,
    SF_FORMAT_W64___37 = 720896,
    SF_FORMAT_MAT4___37 = 786432,
    SF_FORMAT_MAT5___37 = 851968,
    SF_FORMAT_PVF___37 = 917504,
    SF_FORMAT_XI___37 = 983040,
    SF_FORMAT_HTK___37 = 1048576,
    SF_FORMAT_SDS___37 = 1114112,
    SF_FORMAT_AVR___37 = 1179648,
    SF_FORMAT_WAVEX___37 = 1245184,
    SF_FORMAT_SD2___37 = 1441792,
    SF_FORMAT_FLAC___37 = 1507328,
    SF_FORMAT_CAF___37 = 1572864,
    SF_FORMAT_WVE___37 = 1638400,
    SF_FORMAT_OGG___37 = 2097152,
    SF_FORMAT_MPC2K___37 = 2162688,
    SF_FORMAT_RF64___37 = 2228224,
    SF_FORMAT_PCM_S8___37 = 1,
    SF_FORMAT_PCM_16___37 = 2,
    SF_FORMAT_PCM_24___37 = 3,
    SF_FORMAT_PCM_32___37 = 4,
    SF_FORMAT_PCM_U8___37 = 5,
    SF_FORMAT_FLOAT___37 = 6,
    SF_FORMAT_DOUBLE___37 = 7,
    SF_FORMAT_ULAW___37 = 16,
    SF_FORMAT_ALAW___37 = 17,
    SF_FORMAT_IMA_ADPCM___37 = 18,
    SF_FORMAT_MS_ADPCM___37 = 19,
    SF_FORMAT_GSM610___37 = 32,
    SF_FORMAT_VOX_ADPCM___37 = 33,
    SF_FORMAT_G721_32___37 = 48,
    SF_FORMAT_G723_24___37 = 49,
    SF_FORMAT_G723_40___37 = 50,
    SF_FORMAT_DWVW_12___37 = 64,
    SF_FORMAT_DWVW_16___37 = 65,
    SF_FORMAT_DWVW_24___37 = 66,
    SF_FORMAT_DWVW_N___37 = 67,
    SF_FORMAT_DPCM_8___37 = 80,
    SF_FORMAT_DPCM_16___37 = 81,
    SF_FORMAT_VORBIS___37 = 96,
    SF_ENDIAN_FILE___37 = 0,
    SF_ENDIAN_LITTLE___37 = 268435456,
    SF_ENDIAN_BIG___37 = 536870912,
    SF_ENDIAN_CPU___37 = 805306368,
    SF_FORMAT_SUBMASK___37 = 65535,
    SF_FORMAT_TYPEMASK___37 = 268369920,
    SF_FORMAT_ENDMASK___37 = 805306368
} ;
#line 126
enum __anonenum__929 {
    SFC_GET_LIB_VERSION___37 = 4096,
    SFC_GET_LOG_INFO___37 = 4097,
    SFC_GET_CURRENT_SF_INFO___37 = 4098,
    SFC_GET_NORM_DOUBLE___37 = 4112,
    SFC_GET_NORM_FLOAT___37 = 4113,
    SFC_SET_NORM_DOUBLE___37 = 4114,
    SFC_SET_NORM_FLOAT___37 = 4115,
    SFC_SET_SCALE_FLOAT_INT_READ___37 = 4116,
    SFC_SET_SCALE_INT_FLOAT_WRITE___37 = 4117,
    SFC_GET_SIMPLE_FORMAT_COUNT___37 = 4128,
    SFC_GET_SIMPLE_FORMAT___37 = 4129,
    SFC_GET_FORMAT_INFO___37 = 4136,
    SFC_GET_FORMAT_MAJOR_COUNT___37 = 4144,
    SFC_GET_FORMAT_MAJOR___37 = 4145,
    SFC_GET_FORMAT_SUBTYPE_COUNT___37 = 4146,
    SFC_GET_FORMAT_SUBTYPE___37 = 4147,
    SFC_CALC_SIGNAL_MAX___37 = 4160,
    SFC_CALC_NORM_SIGNAL_MAX___37 = 4161,
    SFC_CALC_MAX_ALL_CHANNELS___37 = 4162,
    SFC_CALC_NORM_MAX_ALL_CHANNELS___37 = 4163,
    SFC_GET_SIGNAL_MAX___37 = 4164,
    SFC_GET_MAX_ALL_CHANNELS___37 = 4165,
    SFC_SET_ADD_PEAK_CHUNK___37 = 4176,
    SFC_SET_ADD_HEADER_PAD_CHUNK___37 = 4177,
    SFC_UPDATE_HEADER_NOW___37 = 4192,
    SFC_SET_UPDATE_HEADER_AUTO___37 = 4193,
    SFC_FILE_TRUNCATE___37 = 4224,
    SFC_SET_RAW_START_OFFSET___37 = 4240,
    SFC_SET_DITHER_ON_WRITE___37 = 4256,
    SFC_SET_DITHER_ON_READ___37 = 4257,
    SFC_GET_DITHER_INFO_COUNT___37 = 4258,
    SFC_GET_DITHER_INFO___37 = 4259,
    SFC_GET_EMBED_FILE_INFO___37 = 4272,
    SFC_SET_CLIPPING___37 = 4288,
    SFC_GET_CLIPPING___37 = 4289,
    SFC_GET_INSTRUMENT___37 = 4304,
    SFC_SET_INSTRUMENT___37 = 4305,
    SFC_GET_LOOP_INFO___37 = 4320,
    SFC_GET_BROADCAST_INFO___37 = 4336,
    SFC_SET_BROADCAST_INFO___37 = 4337,
    SFC_GET_CHANNEL_MAP_INFO___37 = 4352,
    SFC_SET_CHANNEL_MAP_INFO___37 = 4353,
    SFC_RAW_DATA_NEEDS_ENDSWAP___37 = 4368,
    SFC_WAVEX_SET_AMBISONIC___37 = 4608,
    SFC_WAVEX_GET_AMBISONIC___37 = 4609,
    SFC_SET_VBR_ENCODING_QUALITY___37 = 4864,
    SFC_TEST_IEEE_FLOAT_REPLACE___37 = 24577,
    SFC_SET_ADD_DITHER_ON_WRITE___37 = 4208,
    SFC_SET_ADD_DITHER_ON_READ___37 = 4209
} ;
#line 216
enum __anonenum__930 {
    SF_STR_TITLE___37 = 1,
    SF_STR_COPYRIGHT___37 = 2,
    SF_STR_SOFTWARE___37 = 3,
    SF_STR_ARTIST___37 = 4,
    SF_STR_COMMENT___37 = 5,
    SF_STR_DATE___37 = 6,
    SF_STR_ALBUM___37 = 7,
    SF_STR_LICENSE___37 = 8
} ;
#line 235
enum __anonenum__931 {
    SF_FALSE___37 = 0,
    SF_TRUE___37 = 1,
    SFM_READ___37 = 16,
    SFM_WRITE___37 = 32,
    SFM_RDWR___37 = 48,
    SF_AMBISONIC_NONE___37 = 64,
    SF_AMBISONIC_B_FORMAT___37 = 65
} ;
#line 255
enum __anonenum__932 {
    SF_ERR_NO_ERROR___37 = 0,
    SF_ERR_UNRECOGNISED_FORMAT___37 = 1,
    SF_ERR_SYSTEM___37 = 2,
    SF_ERR_MALFORMED_FILE___37 = 3,
    SF_ERR_UNSUPPORTED_ENCODING___37 = 4
} ;
#line 267
enum __anonenum__933 {
    SF_CHANNEL_MAP_INVALID___37 = 0,
    SF_CHANNEL_MAP_MONO___37 = 1,
    SF_CHANNEL_MAP_LEFT___37 = 2,
    SF_CHANNEL_MAP_RIGHT___37 = 3,
    SF_CHANNEL_MAP_CENTER___37 = 4,
    SF_CHANNEL_MAP_FRONT_LEFT___37 = 5,
    SF_CHANNEL_MAP_FRONT_RIGHT___37 = 6,
    SF_CHANNEL_MAP_FRONT_CENTER___37 = 7,
    SF_CHANNEL_MAP_REAR_CENTER___37 = 8,
    SF_CHANNEL_MAP_REAR_LEFT___37 = 9,
    SF_CHANNEL_MAP_REAR_RIGHT___37 = 10,
    SF_CHANNEL_MAP_LFE___37 = 11,
    SF_CHANNEL_MAP_FRONT_LEFT_OF_CENTER___37 = 12,
    SF_CHANNEL_MAP_FRONT_RIGHT_OF_CENTER___37 = 13,
    SF_CHANNEL_MAP_SIDE_LEFT___37 = 14,
    SF_CHANNEL_MAP_SIDE_RIGHT___37 = 15,
    SF_CHANNEL_MAP_TOP_CENTER___37 = 16,
    SF_CHANNEL_MAP_TOP_FRONT_LEFT___37 = 17,
    SF_CHANNEL_MAP_TOP_FRONT_RIGHT___37 = 18,
    SF_CHANNEL_MAP_TOP_FRONT_CENTER___37 = 19,
    SF_CHANNEL_MAP_TOP_REAR_LEFT___37 = 20,
    SF_CHANNEL_MAP_TOP_REAR_RIGHT___37 = 21,
    SF_CHANNEL_MAP_TOP_REAR_CENTER___37 = 22
} ;
#line 352
enum __anonenum__935 {
    SFD_DEFAULT_LEVEL___37 = 0,
    SFD_CUSTOM_LEVEL___37 = 1073741824,
    SFD_NO_DITHER___37 = 500,
    SFD_WHITE___37 = 501,
    SFD_TRIANGULAR_PDF___37 = 502
} ;
#line 380
enum __anonenum__938 {
    SF_LOOP_NONE___37 = 800,
    SF_LOOP_FORWARD___37 = 801,
    SF_LOOP_BACKWARD___37 = 802,
    SF_LOOP_ALTERNATING___37 = 803
} ;
#line 121 "/root/libsndfile/src/common.h"
enum __anonenum__947 {
    SF_PEAK_START___37 = 42,
    SF_PEAK_END___37 = 43,
    SF_SCALE_MAX___37 = 52,
    SF_SCALE_MIN___37 = 53,
    SF_STR_ALLOW_START___37 = 256,
    SF_STR_ALLOW_END___37 = 512,
    SF_STR_LOCATE_START___37 = 1024,
    SF_STR_LOCATE_END___37 = 2048,
    SFD_TYPEMASK___37 = 268435455
} ;
#line 149
enum __anonenum__948 {
    SF_FORMAT_TXW___37 = 67305472,
    SF_FORMAT_DWD___37 = 67371008,
    SF_FORMAT_REX___37 = 67764224,
    SF_FORMAT_REX2___37 = 67960832,
    SF_FORMAT_KRZ___37 = 68026368,
    SF_FORMAT_WMA___37 = 68157440,
    SF_FORMAT_SHN___37 = 68222976,
    SF_FORMAT_SVX_FIB___37 = 4128,
    SF_FORMAT_SVX_EXP___37 = 4129,
    SF_FORMAT_PCM_N___37 = 4144
} ;
#line 405
enum __anonenum__954 {
    SFE_NO_ERROR___37 = 0,
    SFE_BAD_OPEN_FORMAT___37 = 1,
    SFE_SYSTEM___37 = 2,
    SFE_MALFORMED_FILE___37 = 3,
    SFE_UNSUPPORTED_ENCODING___37 = 4,
    SFE_ZERO_MAJOR_FORMAT___37 = 5,
    SFE_ZERO_MINOR_FORMAT___37 = 6,
    SFE_BAD_FILE___37 = 7,
    SFE_BAD_FILE_READ___37 = 8,
    SFE_OPEN_FAILED___37 = 9,
    SFE_BAD_SNDFILE_PTR___37 = 10,
    SFE_BAD_SF_INFO_PTR___37 = 11,
    SFE_BAD_SF_INCOMPLETE___37 = 12,
    SFE_BAD_FILE_PTR___37 = 13,
    SFE_BAD_INT_PTR___37 = 14,
    SFE_BAD_STAT_SIZE___37 = 15,
    SFE_MALLOC_FAILED___37 = 16,
    SFE_UNIMPLEMENTED___37 = 17,
    SFE_BAD_READ_ALIGN___37 = 18,
    SFE_BAD_WRITE_ALIGN___37 = 19,
    SFE_UNKNOWN_FORMAT___37 = 20,
    SFE_NOT_READMODE___37 = 21,
    SFE_NOT_WRITEMODE___37 = 22,
    SFE_BAD_MODE_RW___37 = 23,
    SFE_BAD_SF_INFO___37 = 24,
    SFE_BAD_OFFSET___37 = 25,
    SFE_NO_EMBED_SUPPORT___37 = 26,
    SFE_NO_EMBEDDED_RDWR___37 = 27,
    SFE_NO_PIPE_WRITE___37 = 28,
    SFE_INTERNAL___37 = 29,
    SFE_BAD_COMMAND_PARAM___37 = 30,
    SFE_BAD_ENDIAN___37 = 31,
    SFE_CHANNEL_COUNT_ZERO___37 = 32,
    SFE_CHANNEL_COUNT___37 = 33,
    SFE_BAD_VIRTUAL_IO___37 = 34,
    SFE_INTERLEAVE_MODE___37 = 35,
    SFE_INTERLEAVE_SEEK___37 = 36,
    SFE_INTERLEAVE_READ___37 = 37,
    SFE_BAD_SEEK___37 = 38,
    SFE_NOT_SEEKABLE___37 = 39,
    SFE_AMBIGUOUS_SEEK___37 = 40,
    SFE_WRONG_SEEK___37 = 41,
    SFE_SEEK_FAILED___37 = 42,
    SFE_BAD_OPEN_MODE___37 = 43,
    SFE_OPEN_PIPE_RDWR___37 = 44,
    SFE_RDWR_POSITION___37 = 45,
    SFE_RDWR_BAD_HEADER___37 = 46,
    SFE_CMD_HAS_DATA___37 = 47,
    SFE_BAD_BROADCAST_INFO_SIZE___37 = 48,
    SFE_STR_NO_SUPPORT___37 = 49,
    SFE_STR_NOT_WRITE___37 = 50,
    SFE_STR_MAX_DATA___37 = 51,
    SFE_STR_MAX_COUNT___37 = 52,
    SFE_STR_BAD_TYPE___37 = 53,
    SFE_STR_NO_ADD_END___37 = 54,
    SFE_STR_BAD_STRING___37 = 55,
    SFE_STR_WEIRD___37 = 56,
    SFE_WAV_NO_RIFF___37 = 57,
    SFE_WAV_NO_WAVE___37 = 58,
    SFE_WAV_NO_FMT___37 = 59,
    SFE_WAV_BAD_FMT___37 = 60,
    SFE_WAV_FMT_SHORT___37 = 61,
    SFE_WAV_BAD_FACT___37 = 62,
    SFE_WAV_BAD_PEAK___37 = 63,
    SFE_WAV_PEAK_B4_FMT___37 = 64,
    SFE_WAV_BAD_FORMAT___37 = 65,
    SFE_WAV_BAD_BLOCKALIGN___37 = 66,
    SFE_WAV_NO_DATA___37 = 67,
    SFE_WAV_BAD_LIST___37 = 68,
    SFE_WAV_ADPCM_NOT4BIT___37 = 69,
    SFE_WAV_ADPCM_CHANNELS___37 = 70,
    SFE_WAV_GSM610_FORMAT___37 = 71,
    SFE_WAV_UNKNOWN_CHUNK___37 = 72,
    SFE_WAV_WVPK_DATA___37 = 73,
    SFE_AIFF_NO_FORM___37 = 74,
    SFE_AIFF_AIFF_NO_FORM___37 = 75,
    SFE_AIFF_COMM_NO_FORM___37 = 76,
    SFE_AIFF_SSND_NO_COMM___37 = 77,
    SFE_AIFF_UNKNOWN_CHUNK___37 = 78,
    SFE_AIFF_COMM_CHUNK_SIZE___37 = 79,
    SFE_AIFF_BAD_COMM_CHUNK___37 = 80,
    SFE_AIFF_PEAK_B4_COMM___37 = 81,
    SFE_AIFF_BAD_PEAK___37 = 82,
    SFE_AIFF_NO_SSND___37 = 83,
    SFE_AIFF_NO_DATA___37 = 84,
    SFE_AIFF_RW_SSND_NOT_LAST___37 = 85,
    SFE_AU_UNKNOWN_FORMAT___37 = 86,
    SFE_AU_NO_DOTSND___37 = 87,
    SFE_AU_EMBED_BAD_LEN___37 = 88,
    SFE_RAW_READ_BAD_SPEC___37 = 89,
    SFE_RAW_BAD_BITWIDTH___37 = 90,
    SFE_RAW_BAD_FORMAT___37 = 91,
    SFE_PAF_NO_MARKER___37 = 92,
    SFE_PAF_VERSION___37 = 93,
    SFE_PAF_UNKNOWN_FORMAT___37 = 94,
    SFE_PAF_SHORT_HEADER___37 = 95,
    SFE_SVX_NO_FORM___37 = 96,
    SFE_SVX_NO_BODY___37 = 97,
    SFE_SVX_NO_DATA___37 = 98,
    SFE_SVX_BAD_COMP___37 = 99,
    SFE_SVX_BAD_NAME_LENGTH___37 = 100,
    SFE_NIST_BAD_HEADER___37 = 101,
    SFE_NIST_CRLF_CONVERISON___37 = 102,
    SFE_NIST_BAD_ENCODING___37 = 103,
    SFE_VOC_NO_CREATIVE___37 = 104,
    SFE_VOC_BAD_FORMAT___37 = 105,
    SFE_VOC_BAD_VERSION___37 = 106,
    SFE_VOC_BAD_MARKER___37 = 107,
    SFE_VOC_BAD_SECTIONS___37 = 108,
    SFE_VOC_MULTI_SAMPLERATE___37 = 109,
    SFE_VOC_MULTI_SECTION___37 = 110,
    SFE_VOC_MULTI_PARAM___37 = 111,
    SFE_VOC_SECTION_COUNT___37 = 112,
    SFE_VOC_NO_PIPE___37 = 113,
    SFE_IRCAM_NO_MARKER___37 = 114,
    SFE_IRCAM_BAD_CHANNELS___37 = 115,
    SFE_IRCAM_UNKNOWN_FORMAT___37 = 116,
    SFE_W64_64_BIT___37 = 117,
    SFE_W64_NO_RIFF___37 = 118,
    SFE_W64_NO_WAVE___37 = 119,
    SFE_W64_NO_DATA___37 = 120,
    SFE_W64_ADPCM_NOT4BIT___37 = 121,
    SFE_W64_ADPCM_CHANNELS___37 = 122,
    SFE_W64_GSM610_FORMAT___37 = 123,
    SFE_MAT4_BAD_NAME___37 = 124,
    SFE_MAT4_NO_SAMPLERATE___37 = 125,
    SFE_MAT5_BAD_ENDIAN___37 = 126,
    SFE_MAT5_NO_BLOCK___37 = 127,
    SFE_MAT5_SAMPLE_RATE___37 = 128,
    SFE_PVF_NO_PVF1___37 = 129,
    SFE_PVF_BAD_HEADER___37 = 130,
    SFE_PVF_BAD_BITWIDTH___37 = 131,
    SFE_DWVW_BAD_BITWIDTH___37 = 132,
    SFE_G72X_NOT_MONO___37 = 133,
    SFE_XI_BAD_HEADER___37 = 134,
    SFE_XI_EXCESS_SAMPLES___37 = 135,
    SFE_XI_NO_PIPE___37 = 136,
    SFE_HTK_NO_PIPE___37 = 137,
    SFE_SDS_NOT_SDS___37 = 138,
    SFE_SDS_BAD_BIT_WIDTH___37 = 139,
    SFE_SD2_FD_DISALLOWED___37 = 140,
    SFE_SD2_BAD_DATA_OFFSET___37 = 141,
    SFE_SD2_BAD_MAP_OFFSET___37 = 142,
    SFE_SD2_BAD_DATA_LENGTH___37 = 143,
    SFE_SD2_BAD_MAP_LENGTH___37 = 144,
    SFE_SD2_BAD_RSRC___37 = 145,
    SFE_SD2_BAD_SAMPLE_SIZE___37 = 146,
    SFE_FLAC_BAD_HEADER___37 = 147,
    SFE_FLAC_NEW_DECODER___37 = 148,
    SFE_FLAC_INIT_DECODER___37 = 149,
    SFE_FLAC_LOST_SYNC___37 = 150,
    SFE_FLAC_BAD_SAMPLE_RATE___37 = 151,
    SFE_FLAC_UNKOWN_ERROR___37 = 152,
    SFE_WVE_NOT_WVE___37 = 153,
    SFE_WVE_NO_PIPE___37 = 154,
    SFE_VORBIS_ENCODER_BUG___37 = 155,
    SFE_RF64_NOT_RF64___37 = 156,
    SFE_MAX_ERROR___37 = 157
} ;
#line 823
enum __anonenum__958 {
    SFC_TEST_AIFF_ADD_INST_CHUNK___37 = 8192,
    SFC_TEST_WAV_ADD_INFO_CHUNK___37 = 8208
} ;
#line 51 "/root/libsndfile/src/mat5.c"
enum __anonenum__959 {
    MAT5_TYPE_SCHAR = 1,
    MAT5_TYPE_UCHAR = 2,
    MAT5_TYPE_INT16 = 3,
    MAT5_TYPE_UINT16 = 4,
    MAT5_TYPE_INT32 = 5,
    MAT5_TYPE_UINT32 = 6,
    MAT5_TYPE_FLOAT = 7,
    MAT5_TYPE_DOUBLE = 9,
    MAT5_TYPE_ARRAY = 14,
    MAT5_TYPE_COMP_USHORT = 131076,
    MAT5_TYPE_COMP_UINT = 262150
} ;
#line 66 "/root/libsndfile/src/mat5.c"
struct __anonstruct_960 {
   sf_count_t size ;
   int rows ;
   int cols ;
   char name[32] ;
};
#line 70 "/root/libsndfile/src/mat5.c"
typedef struct __anonstruct_960 MAT5_MATRIX;
#line 46 "/usr/include/ctype.h"
enum __anonenum__510___7 {
    _ISupper___17 = 256,
    _ISlower___17 = 512,
    _ISalpha___17 = 1024,
    _ISdigit___17 = 2048,
    _ISxdigit___17 = 4096,
    _ISspace___17 = 8192,
    _ISprint___17 = 16384,
    _ISgraph___17 = 32768,
    _ISblank___17 = 1,
    _IScntrl___17 = 2,
    _ISpunct___17 = 4,
    _ISalnum___17 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__913___0 {
    FP_NAN___17 = 0,
    FP_INFINITE___17 = 1,
    FP_ZERO___17 = 2,
    FP_SUBNORMAL___17 = 3,
    FP_NORMAL___17 = 4
} ;
#line 46 "/root/libsndfile/src/sndfile.h"
enum __anonenum__928___0 {
    SF_FORMAT_WAV___38 = 65536,
    SF_FORMAT_AIFF___38 = 131072,
    SF_FORMAT_AU___38 = 196608,
    SF_FORMAT_RAW___38 = 262144,
    SF_FORMAT_PAF___38 = 327680,
    SF_FORMAT_SVX___38 = 393216,
    SF_FORMAT_NIST___38 = 458752,
    SF_FORMAT_VOC___38 = 524288,
    SF_FORMAT_IRCAM___38 = 655360,
    SF_FORMAT_W64___38 = 720896,
    SF_FORMAT_MAT4___38 = 786432,
    SF_FORMAT_MAT5___38 = 851968,
    SF_FORMAT_PVF___38 = 917504,
    SF_FORMAT_XI___38 = 983040,
    SF_FORMAT_HTK___38 = 1048576,
    SF_FORMAT_SDS___38 = 1114112,
    SF_FORMAT_AVR___38 = 1179648,
    SF_FORMAT_WAVEX___38 = 1245184,
    SF_FORMAT_SD2___38 = 1441792,
    SF_FORMAT_FLAC___38 = 1507328,
    SF_FORMAT_CAF___38 = 1572864,
    SF_FORMAT_WVE___38 = 1638400,
    SF_FORMAT_OGG___38 = 2097152,
    SF_FORMAT_MPC2K___38 = 2162688,
    SF_FORMAT_RF64___38 = 2228224,
    SF_FORMAT_PCM_S8___38 = 1,
    SF_FORMAT_PCM_16___38 = 2,
    SF_FORMAT_PCM_24___38 = 3,
    SF_FORMAT_PCM_32___38 = 4,
    SF_FORMAT_PCM_U8___38 = 5,
    SF_FORMAT_FLOAT___38 = 6,
    SF_FORMAT_DOUBLE___38 = 7,
    SF_FORMAT_ULAW___38 = 16,
    SF_FORMAT_ALAW___38 = 17,
    SF_FORMAT_IMA_ADPCM___38 = 18,
    SF_FORMAT_MS_ADPCM___38 = 19,
    SF_FORMAT_GSM610___38 = 32,
    SF_FORMAT_VOX_ADPCM___38 = 33,
    SF_FORMAT_G721_32___38 = 48,
    SF_FORMAT_G723_24___38 = 49,
    SF_FORMAT_G723_40___38 = 50,
    SF_FORMAT_DWVW_12___38 = 64,
    SF_FORMAT_DWVW_16___38 = 65,
    SF_FORMAT_DWVW_24___38 = 66,
    SF_FORMAT_DWVW_N___38 = 67,
    SF_FORMAT_DPCM_8___38 = 80,
    SF_FORMAT_DPCM_16___38 = 81,
    SF_FORMAT_VORBIS___38 = 96,
    SF_ENDIAN_FILE___38 = 0,
    SF_ENDIAN_LITTLE___38 = 268435456,
    SF_ENDIAN_BIG___38 = 536870912,
    SF_ENDIAN_CPU___38 = 805306368,
    SF_FORMAT_SUBMASK___38 = 65535,
    SF_FORMAT_TYPEMASK___38 = 268369920,
    SF_FORMAT_ENDMASK___38 = 805306368
} ;
#line 126
enum __anonenum__929___0 {
    SFC_GET_LIB_VERSION___38 = 4096,
    SFC_GET_LOG_INFO___38 = 4097,
    SFC_GET_CURRENT_SF_INFO___38 = 4098,
    SFC_GET_NORM_DOUBLE___38 = 4112,
    SFC_GET_NORM_FLOAT___38 = 4113,
    SFC_SET_NORM_DOUBLE___38 = 4114,
    SFC_SET_NORM_FLOAT___38 = 4115,
    SFC_SET_SCALE_FLOAT_INT_READ___38 = 4116,
    SFC_SET_SCALE_INT_FLOAT_WRITE___38 = 4117,
    SFC_GET_SIMPLE_FORMAT_COUNT___38 = 4128,
    SFC_GET_SIMPLE_FORMAT___38 = 4129,
    SFC_GET_FORMAT_INFO___38 = 4136,
    SFC_GET_FORMAT_MAJOR_COUNT___38 = 4144,
    SFC_GET_FORMAT_MAJOR___38 = 4145,
    SFC_GET_FORMAT_SUBTYPE_COUNT___38 = 4146,
    SFC_GET_FORMAT_SUBTYPE___38 = 4147,
    SFC_CALC_SIGNAL_MAX___38 = 4160,
    SFC_CALC_NORM_SIGNAL_MAX___38 = 4161,
    SFC_CALC_MAX_ALL_CHANNELS___38 = 4162,
    SFC_CALC_NORM_MAX_ALL_CHANNELS___38 = 4163,
    SFC_GET_SIGNAL_MAX___38 = 4164,
    SFC_GET_MAX_ALL_CHANNELS___38 = 4165,
    SFC_SET_ADD_PEAK_CHUNK___38 = 4176,
    SFC_SET_ADD_HEADER_PAD_CHUNK___38 = 4177,
    SFC_UPDATE_HEADER_NOW___38 = 4192,
    SFC_SET_UPDATE_HEADER_AUTO___38 = 4193,
    SFC_FILE_TRUNCATE___38 = 4224,
    SFC_SET_RAW_START_OFFSET___38 = 4240,
    SFC_SET_DITHER_ON_WRITE___38 = 4256,
    SFC_SET_DITHER_ON_READ___38 = 4257,
    SFC_GET_DITHER_INFO_COUNT___38 = 4258,
    SFC_GET_DITHER_INFO___38 = 4259,
    SFC_GET_EMBED_FILE_INFO___38 = 4272,
    SFC_SET_CLIPPING___38 = 4288,
    SFC_GET_CLIPPING___38 = 4289,
    SFC_GET_INSTRUMENT___38 = 4304,
    SFC_SET_INSTRUMENT___38 = 4305,
    SFC_GET_LOOP_INFO___38 = 4320,
    SFC_GET_BROADCAST_INFO___38 = 4336,
    SFC_SET_BROADCAST_INFO___38 = 4337,
    SFC_GET_CHANNEL_MAP_INFO___38 = 4352,
    SFC_SET_CHANNEL_MAP_INFO___38 = 4353,
    SFC_RAW_DATA_NEEDS_ENDSWAP___38 = 4368,
    SFC_WAVEX_SET_AMBISONIC___38 = 4608,
    SFC_WAVEX_GET_AMBISONIC___38 = 4609,
    SFC_SET_VBR_ENCODING_QUALITY___38 = 4864,
    SFC_TEST_IEEE_FLOAT_REPLACE___38 = 24577,
    SFC_SET_ADD_DITHER_ON_WRITE___38 = 4208,
    SFC_SET_ADD_DITHER_ON_READ___38 = 4209
} ;
#line 216
enum __anonenum__930___0 {
    SF_STR_TITLE___38 = 1,
    SF_STR_COPYRIGHT___38 = 2,
    SF_STR_SOFTWARE___38 = 3,
    SF_STR_ARTIST___38 = 4,
    SF_STR_COMMENT___38 = 5,
    SF_STR_DATE___38 = 6,
    SF_STR_ALBUM___38 = 7,
    SF_STR_LICENSE___38 = 8
} ;
#line 235
enum __anonenum__931___0 {
    SF_FALSE___38 = 0,
    SF_TRUE___38 = 1,
    SFM_READ___38 = 16,
    SFM_WRITE___38 = 32,
    SFM_RDWR___38 = 48,
    SF_AMBISONIC_NONE___38 = 64,
    SF_AMBISONIC_B_FORMAT___38 = 65
} ;
#line 255
enum __anonenum__932___0 {
    SF_ERR_NO_ERROR___38 = 0,
    SF_ERR_UNRECOGNISED_FORMAT___38 = 1,
    SF_ERR_SYSTEM___38 = 2,
    SF_ERR_MALFORMED_FILE___38 = 3,
    SF_ERR_UNSUPPORTED_ENCODING___38 = 4
} ;
#line 267
enum __anonenum__933___0 {
    SF_CHANNEL_MAP_INVALID___38 = 0,
    SF_CHANNEL_MAP_MONO___38 = 1,
    SF_CHANNEL_MAP_LEFT___38 = 2,
    SF_CHANNEL_MAP_RIGHT___38 = 3,
    SF_CHANNEL_MAP_CENTER___38 = 4,
    SF_CHANNEL_MAP_FRONT_LEFT___38 = 5,
    SF_CHANNEL_MAP_FRONT_RIGHT___38 = 6,
    SF_CHANNEL_MAP_FRONT_CENTER___38 = 7,
    SF_CHANNEL_MAP_REAR_CENTER___38 = 8,
    SF_CHANNEL_MAP_REAR_LEFT___38 = 9,
    SF_CHANNEL_MAP_REAR_RIGHT___38 = 10,
    SF_CHANNEL_MAP_LFE___38 = 11,
    SF_CHANNEL_MAP_FRONT_LEFT_OF_CENTER___38 = 12,
    SF_CHANNEL_MAP_FRONT_RIGHT_OF_CENTER___38 = 13,
    SF_CHANNEL_MAP_SIDE_LEFT___38 = 14,
    SF_CHANNEL_MAP_SIDE_RIGHT___38 = 15,
    SF_CHANNEL_MAP_TOP_CENTER___38 = 16,
    SF_CHANNEL_MAP_TOP_FRONT_LEFT___38 = 17,
    SF_CHANNEL_MAP_TOP_FRONT_RIGHT___38 = 18,
    SF_CHANNEL_MAP_TOP_FRONT_CENTER___38 = 19,
    SF_CHANNEL_MAP_TOP_REAR_LEFT___38 = 20,
    SF_CHANNEL_MAP_TOP_REAR_RIGHT___38 = 21,
    SF_CHANNEL_MAP_TOP_REAR_CENTER___38 = 22
} ;
#line 352
enum __anonenum__935___0 {
    SFD_DEFAULT_LEVEL___38 = 0,
    SFD_CUSTOM_LEVEL___38 = 1073741824,
    SFD_NO_DITHER___38 = 500,
    SFD_WHITE___38 = 501,
    SFD_TRIANGULAR_PDF___38 = 502
} ;
#line 380
enum __anonenum__938___0 {
    SF_LOOP_NONE___38 = 800,
    SF_LOOP_FORWARD___38 = 801,
    SF_LOOP_BACKWARD___38 = 802,
    SF_LOOP_ALTERNATING___38 = 803
} ;
#line 121 "/root/libsndfile/src/common.h"
enum __anonenum__947___0 {
    SF_PEAK_START___38 = 42,
    SF_PEAK_END___38 = 43,
    SF_SCALE_MAX___38 = 52,
    SF_SCALE_MIN___38 = 53,
    SF_STR_ALLOW_START___38 = 256,
    SF_STR_ALLOW_END___38 = 512,
    SF_STR_LOCATE_START___38 = 1024,
    SF_STR_LOCATE_END___38 = 2048,
    SFD_TYPEMASK___38 = 268435455
} ;
#line 149
enum __anonenum__948___0 {
    SF_FORMAT_TXW___38 = 67305472,
    SF_FORMAT_DWD___38 = 67371008,
    SF_FORMAT_REX___38 = 67764224,
    SF_FORMAT_REX2___38 = 67960832,
    SF_FORMAT_KRZ___38 = 68026368,
    SF_FORMAT_WMA___38 = 68157440,
    SF_FORMAT_SHN___38 = 68222976,
    SF_FORMAT_SVX_FIB___38 = 4128,
    SF_FORMAT_SVX_EXP___38 = 4129,
    SF_FORMAT_PCM_N___38 = 4144
} ;
#line 405
enum __anonenum__954___0 {
    SFE_NO_ERROR___38 = 0,
    SFE_BAD_OPEN_FORMAT___38 = 1,
    SFE_SYSTEM___38 = 2,
    SFE_MALFORMED_FILE___38 = 3,
    SFE_UNSUPPORTED_ENCODING___38 = 4,
    SFE_ZERO_MAJOR_FORMAT___38 = 5,
    SFE_ZERO_MINOR_FORMAT___38 = 6,
    SFE_BAD_FILE___38 = 7,
    SFE_BAD_FILE_READ___38 = 8,
    SFE_OPEN_FAILED___38 = 9,
    SFE_BAD_SNDFILE_PTR___38 = 10,
    SFE_BAD_SF_INFO_PTR___38 = 11,
    SFE_BAD_SF_INCOMPLETE___38 = 12,
    SFE_BAD_FILE_PTR___38 = 13,
    SFE_BAD_INT_PTR___38 = 14,
    SFE_BAD_STAT_SIZE___38 = 15,
    SFE_MALLOC_FAILED___38 = 16,
    SFE_UNIMPLEMENTED___38 = 17,
    SFE_BAD_READ_ALIGN___38 = 18,
    SFE_BAD_WRITE_ALIGN___38 = 19,
    SFE_UNKNOWN_FORMAT___38 = 20,
    SFE_NOT_READMODE___38 = 21,
    SFE_NOT_WRITEMODE___38 = 22,
    SFE_BAD_MODE_RW___38 = 23,
    SFE_BAD_SF_INFO___38 = 24,
    SFE_BAD_OFFSET___38 = 25,
    SFE_NO_EMBED_SUPPORT___38 = 26,
    SFE_NO_EMBEDDED_RDWR___38 = 27,
    SFE_NO_PIPE_WRITE___38 = 28,
    SFE_INTERNAL___38 = 29,
    SFE_BAD_COMMAND_PARAM___38 = 30,
    SFE_BAD_ENDIAN___38 = 31,
    SFE_CHANNEL_COUNT_ZERO___38 = 32,
    SFE_CHANNEL_COUNT___38 = 33,
    SFE_BAD_VIRTUAL_IO___38 = 34,
    SFE_INTERLEAVE_MODE___38 = 35,
    SFE_INTERLEAVE_SEEK___38 = 36,
    SFE_INTERLEAVE_READ___38 = 37,
    SFE_BAD_SEEK___38 = 38,
    SFE_NOT_SEEKABLE___38 = 39,
    SFE_AMBIGUOUS_SEEK___38 = 40,
    SFE_WRONG_SEEK___38 = 41,
    SFE_SEEK_FAILED___38 = 42,
    SFE_BAD_OPEN_MODE___38 = 43,
    SFE_OPEN_PIPE_RDWR___38 = 44,
    SFE_RDWR_POSITION___38 = 45,
    SFE_RDWR_BAD_HEADER___38 = 46,
    SFE_CMD_HAS_DATA___38 = 47,
    SFE_BAD_BROADCAST_INFO_SIZE___38 = 48,
    SFE_STR_NO_SUPPORT___38 = 49,
    SFE_STR_NOT_WRITE___38 = 50,
    SFE_STR_MAX_DATA___38 = 51,
    SFE_STR_MAX_COUNT___38 = 52,
    SFE_STR_BAD_TYPE___38 = 53,
    SFE_STR_NO_ADD_END___38 = 54,
    SFE_STR_BAD_STRING___38 = 55,
    SFE_STR_WEIRD___38 = 56,
    SFE_WAV_NO_RIFF___38 = 57,
    SFE_WAV_NO_WAVE___38 = 58,
    SFE_WAV_NO_FMT___38 = 59,
    SFE_WAV_BAD_FMT___38 = 60,
    SFE_WAV_FMT_SHORT___38 = 61,
    SFE_WAV_BAD_FACT___38 = 62,
    SFE_WAV_BAD_PEAK___38 = 63,
    SFE_WAV_PEAK_B4_FMT___38 = 64,
    SFE_WAV_BAD_FORMAT___38 = 65,
    SFE_WAV_BAD_BLOCKALIGN___38 = 66,
    SFE_WAV_NO_DATA___38 = 67,
    SFE_WAV_BAD_LIST___38 = 68,
    SFE_WAV_ADPCM_NOT4BIT___38 = 69,
    SFE_WAV_ADPCM_CHANNELS___38 = 70,
    SFE_WAV_GSM610_FORMAT___38 = 71,
    SFE_WAV_UNKNOWN_CHUNK___38 = 72,
    SFE_WAV_WVPK_DATA___38 = 73,
    SFE_AIFF_NO_FORM___38 = 74,
    SFE_AIFF_AIFF_NO_FORM___38 = 75,
    SFE_AIFF_COMM_NO_FORM___38 = 76,
    SFE_AIFF_SSND_NO_COMM___38 = 77,
    SFE_AIFF_UNKNOWN_CHUNK___38 = 78,
    SFE_AIFF_COMM_CHUNK_SIZE___38 = 79,
    SFE_AIFF_BAD_COMM_CHUNK___38 = 80,
    SFE_AIFF_PEAK_B4_COMM___38 = 81,
    SFE_AIFF_BAD_PEAK___38 = 82,
    SFE_AIFF_NO_SSND___38 = 83,
    SFE_AIFF_NO_DATA___38 = 84,
    SFE_AIFF_RW_SSND_NOT_LAST___38 = 85,
    SFE_AU_UNKNOWN_FORMAT___38 = 86,
    SFE_AU_NO_DOTSND___38 = 87,
    SFE_AU_EMBED_BAD_LEN___38 = 88,
    SFE_RAW_READ_BAD_SPEC___38 = 89,
    SFE_RAW_BAD_BITWIDTH___38 = 90,
    SFE_RAW_BAD_FORMAT___38 = 91,
    SFE_PAF_NO_MARKER___38 = 92,
    SFE_PAF_VERSION___38 = 93,
    SFE_PAF_UNKNOWN_FORMAT___38 = 94,
    SFE_PAF_SHORT_HEADER___38 = 95,
    SFE_SVX_NO_FORM___38 = 96,
    SFE_SVX_NO_BODY___38 = 97,
    SFE_SVX_NO_DATA___38 = 98,
    SFE_SVX_BAD_COMP___38 = 99,
    SFE_SVX_BAD_NAME_LENGTH___38 = 100,
    SFE_NIST_BAD_HEADER___38 = 101,
    SFE_NIST_CRLF_CONVERISON___38 = 102,
    SFE_NIST_BAD_ENCODING___38 = 103,
    SFE_VOC_NO_CREATIVE___38 = 104,
    SFE_VOC_BAD_FORMAT___38 = 105,
    SFE_VOC_BAD_VERSION___38 = 106,
    SFE_VOC_BAD_MARKER___38 = 107,
    SFE_VOC_BAD_SECTIONS___38 = 108,
    SFE_VOC_MULTI_SAMPLERATE___38 = 109,
    SFE_VOC_MULTI_SECTION___38 = 110,
    SFE_VOC_MULTI_PARAM___38 = 111,
    SFE_VOC_SECTION_COUNT___38 = 112,
    SFE_VOC_NO_PIPE___38 = 113,
    SFE_IRCAM_NO_MARKER___38 = 114,
    SFE_IRCAM_BAD_CHANNELS___38 = 115,
    SFE_IRCAM_UNKNOWN_FORMAT___38 = 116,
    SFE_W64_64_BIT___38 = 117,
    SFE_W64_NO_RIFF___38 = 118,
    SFE_W64_NO_WAVE___38 = 119,
    SFE_W64_NO_DATA___38 = 120,
    SFE_W64_ADPCM_NOT4BIT___38 = 121,
    SFE_W64_ADPCM_CHANNELS___38 = 122,
    SFE_W64_GSM610_FORMAT___38 = 123,
    SFE_MAT4_BAD_NAME___38 = 124,
    SFE_MAT4_NO_SAMPLERATE___38 = 125,
    SFE_MAT5_BAD_ENDIAN___38 = 126,
    SFE_MAT5_NO_BLOCK___38 = 127,
    SFE_MAT5_SAMPLE_RATE___38 = 128,
    SFE_PVF_NO_PVF1___38 = 129,
    SFE_PVF_BAD_HEADER___38 = 130,
    SFE_PVF_BAD_BITWIDTH___38 = 131,
    SFE_DWVW_BAD_BITWIDTH___38 = 132,
    SFE_G72X_NOT_MONO___38 = 133,
    SFE_XI_BAD_HEADER___38 = 134,
    SFE_XI_EXCESS_SAMPLES___38 = 135,
    SFE_XI_NO_PIPE___38 = 136,
    SFE_HTK_NO_PIPE___38 = 137,
    SFE_SDS_NOT_SDS___38 = 138,
    SFE_SDS_BAD_BIT_WIDTH___38 = 139,
    SFE_SD2_FD_DISALLOWED___38 = 140,
    SFE_SD2_BAD_DATA_OFFSET___38 = 141,
    SFE_SD2_BAD_MAP_OFFSET___38 = 142,
    SFE_SD2_BAD_DATA_LENGTH___38 = 143,
    SFE_SD2_BAD_MAP_LENGTH___38 = 144,
    SFE_SD2_BAD_RSRC___38 = 145,
    SFE_SD2_BAD_SAMPLE_SIZE___38 = 146,
    SFE_FLAC_BAD_HEADER___38 = 147,
    SFE_FLAC_NEW_DECODER___38 = 148,
    SFE_FLAC_INIT_DECODER___38 = 149,
    SFE_FLAC_LOST_SYNC___38 = 150,
    SFE_FLAC_BAD_SAMPLE_RATE___38 = 151,
    SFE_FLAC_UNKOWN_ERROR___38 = 152,
    SFE_WVE_NOT_WVE___38 = 153,
    SFE_WVE_NO_PIPE___38 = 154,
    SFE_VORBIS_ENCODER_BUG___38 = 155,
    SFE_RF64_NOT_RF64___38 = 156,
    SFE_MAX_ERROR___38 = 157
} ;
#line 823
enum __anonenum__958___0 {
    SFC_TEST_AIFF_ADD_INST_CHUNK___38 = 8192,
    SFC_TEST_WAV_ADD_INFO_CHUNK___38 = 8208
} ;
#line 46 "/root/libsndfile/src/sndfile.h"
enum __anonenum__963 {
    SF_FORMAT_WAV___39 = 65536,
    SF_FORMAT_AIFF___39 = 131072,
    SF_FORMAT_AU___39 = 196608,
    SF_FORMAT_RAW___39 = 262144,
    SF_FORMAT_PAF___39 = 327680,
    SF_FORMAT_SVX___39 = 393216,
    SF_FORMAT_NIST___39 = 458752,
    SF_FORMAT_VOC___39 = 524288,
    SF_FORMAT_IRCAM___39 = 655360,
    SF_FORMAT_W64___39 = 720896,
    SF_FORMAT_MAT4___39 = 786432,
    SF_FORMAT_MAT5___39 = 851968,
    SF_FORMAT_PVF___39 = 917504,
    SF_FORMAT_XI___39 = 983040,
    SF_FORMAT_HTK___39 = 1048576,
    SF_FORMAT_SDS___39 = 1114112,
    SF_FORMAT_AVR___39 = 1179648,
    SF_FORMAT_WAVEX___39 = 1245184,
    SF_FORMAT_SD2___39 = 1441792,
    SF_FORMAT_FLAC___39 = 1507328,
    SF_FORMAT_CAF___39 = 1572864,
    SF_FORMAT_WVE___39 = 1638400,
    SF_FORMAT_OGG___39 = 2097152,
    SF_FORMAT_MPC2K___39 = 2162688,
    SF_FORMAT_RF64___39 = 2228224,
    SF_FORMAT_PCM_S8___39 = 1,
    SF_FORMAT_PCM_16___39 = 2,
    SF_FORMAT_PCM_24___39 = 3,
    SF_FORMAT_PCM_32___39 = 4,
    SF_FORMAT_PCM_U8___39 = 5,
    SF_FORMAT_FLOAT___39 = 6,
    SF_FORMAT_DOUBLE___39 = 7,
    SF_FORMAT_ULAW___39 = 16,
    SF_FORMAT_ALAW___39 = 17,
    SF_FORMAT_IMA_ADPCM___39 = 18,
    SF_FORMAT_MS_ADPCM___39 = 19,
    SF_FORMAT_GSM610___39 = 32,
    SF_FORMAT_VOX_ADPCM___39 = 33,
    SF_FORMAT_G721_32___39 = 48,
    SF_FORMAT_G723_24___39 = 49,
    SF_FORMAT_G723_40___39 = 50,
    SF_FORMAT_DWVW_12___39 = 64,
    SF_FORMAT_DWVW_16___39 = 65,
    SF_FORMAT_DWVW_24___39 = 66,
    SF_FORMAT_DWVW_N___39 = 67,
    SF_FORMAT_DPCM_8___39 = 80,
    SF_FORMAT_DPCM_16___39 = 81,
    SF_FORMAT_VORBIS___39 = 96,
    SF_ENDIAN_FILE___39 = 0,
    SF_ENDIAN_LITTLE___39 = 268435456,
    SF_ENDIAN_BIG___39 = 536870912,
    SF_ENDIAN_CPU___39 = 805306368,
    SF_FORMAT_SUBMASK___39 = 65535,
    SF_FORMAT_TYPEMASK___39 = 268369920,
    SF_FORMAT_ENDMASK___39 = 805306368
} ;
#line 126
enum __anonenum__964 {
    SFC_GET_LIB_VERSION___39 = 4096,
    SFC_GET_LOG_INFO___39 = 4097,
    SFC_GET_CURRENT_SF_INFO___39 = 4098,
    SFC_GET_NORM_DOUBLE___39 = 4112,
    SFC_GET_NORM_FLOAT___39 = 4113,
    SFC_SET_NORM_DOUBLE___39 = 4114,
    SFC_SET_NORM_FLOAT___39 = 4115,
    SFC_SET_SCALE_FLOAT_INT_READ___39 = 4116,
    SFC_SET_SCALE_INT_FLOAT_WRITE___39 = 4117,
    SFC_GET_SIMPLE_FORMAT_COUNT___39 = 4128,
    SFC_GET_SIMPLE_FORMAT___39 = 4129,
    SFC_GET_FORMAT_INFO___39 = 4136,
    SFC_GET_FORMAT_MAJOR_COUNT___39 = 4144,
    SFC_GET_FORMAT_MAJOR___39 = 4145,
    SFC_GET_FORMAT_SUBTYPE_COUNT___39 = 4146,
    SFC_GET_FORMAT_SUBTYPE___39 = 4147,
    SFC_CALC_SIGNAL_MAX___39 = 4160,
    SFC_CALC_NORM_SIGNAL_MAX___39 = 4161,
    SFC_CALC_MAX_ALL_CHANNELS___39 = 4162,
    SFC_CALC_NORM_MAX_ALL_CHANNELS___39 = 4163,
    SFC_GET_SIGNAL_MAX___39 = 4164,
    SFC_GET_MAX_ALL_CHANNELS___39 = 4165,
    SFC_SET_ADD_PEAK_CHUNK___39 = 4176,
    SFC_SET_ADD_HEADER_PAD_CHUNK___39 = 4177,
    SFC_UPDATE_HEADER_NOW___39 = 4192,
    SFC_SET_UPDATE_HEADER_AUTO___39 = 4193,
    SFC_FILE_TRUNCATE___39 = 4224,
    SFC_SET_RAW_START_OFFSET___39 = 4240,
    SFC_SET_DITHER_ON_WRITE___39 = 4256,
    SFC_SET_DITHER_ON_READ___39 = 4257,
    SFC_GET_DITHER_INFO_COUNT___39 = 4258,
    SFC_GET_DITHER_INFO___39 = 4259,
    SFC_GET_EMBED_FILE_INFO___39 = 4272,
    SFC_SET_CLIPPING___39 = 4288,
    SFC_GET_CLIPPING___39 = 4289,
    SFC_GET_INSTRUMENT___39 = 4304,
    SFC_SET_INSTRUMENT___39 = 4305,
    SFC_GET_LOOP_INFO___39 = 4320,
    SFC_GET_BROADCAST_INFO___39 = 4336,
    SFC_SET_BROADCAST_INFO___39 = 4337,
    SFC_GET_CHANNEL_MAP_INFO___39 = 4352,
    SFC_SET_CHANNEL_MAP_INFO___39 = 4353,
    SFC_RAW_DATA_NEEDS_ENDSWAP___39 = 4368,
    SFC_WAVEX_SET_AMBISONIC___39 = 4608,
    SFC_WAVEX_GET_AMBISONIC___39 = 4609,
    SFC_SET_VBR_ENCODING_QUALITY___39 = 4864,
    SFC_TEST_IEEE_FLOAT_REPLACE___39 = 24577,
    SFC_SET_ADD_DITHER_ON_WRITE___39 = 4208,
    SFC_SET_ADD_DITHER_ON_READ___39 = 4209
} ;
#line 216
enum __anonenum__965 {
    SF_STR_TITLE___39 = 1,
    SF_STR_COPYRIGHT___39 = 2,
    SF_STR_SOFTWARE___39 = 3,
    SF_STR_ARTIST___39 = 4,
    SF_STR_COMMENT___39 = 5,
    SF_STR_DATE___39 = 6,
    SF_STR_ALBUM___39 = 7,
    SF_STR_LICENSE___39 = 8
} ;
#line 235
enum __anonenum__966 {
    SF_FALSE___39 = 0,
    SF_TRUE___39 = 1,
    SFM_READ___39 = 16,
    SFM_WRITE___39 = 32,
    SFM_RDWR___39 = 48,
    SF_AMBISONIC_NONE___39 = 64,
    SF_AMBISONIC_B_FORMAT___39 = 65
} ;
#line 255
enum __anonenum__967 {
    SF_ERR_NO_ERROR___39 = 0,
    SF_ERR_UNRECOGNISED_FORMAT___39 = 1,
    SF_ERR_SYSTEM___39 = 2,
    SF_ERR_MALFORMED_FILE___39 = 3,
    SF_ERR_UNSUPPORTED_ENCODING___39 = 4
} ;
#line 267
enum __anonenum__968 {
    SF_CHANNEL_MAP_INVALID___39 = 0,
    SF_CHANNEL_MAP_MONO___39 = 1,
    SF_CHANNEL_MAP_LEFT___39 = 2,
    SF_CHANNEL_MAP_RIGHT___39 = 3,
    SF_CHANNEL_MAP_CENTER___39 = 4,
    SF_CHANNEL_MAP_FRONT_LEFT___39 = 5,
    SF_CHANNEL_MAP_FRONT_RIGHT___39 = 6,
    SF_CHANNEL_MAP_FRONT_CENTER___39 = 7,
    SF_CHANNEL_MAP_REAR_CENTER___39 = 8,
    SF_CHANNEL_MAP_REAR_LEFT___39 = 9,
    SF_CHANNEL_MAP_REAR_RIGHT___39 = 10,
    SF_CHANNEL_MAP_LFE___39 = 11,
    SF_CHANNEL_MAP_FRONT_LEFT_OF_CENTER___39 = 12,
    SF_CHANNEL_MAP_FRONT_RIGHT_OF_CENTER___39 = 13,
    SF_CHANNEL_MAP_SIDE_LEFT___39 = 14,
    SF_CHANNEL_MAP_SIDE_RIGHT___39 = 15,
    SF_CHANNEL_MAP_TOP_CENTER___39 = 16,
    SF_CHANNEL_MAP_TOP_FRONT_LEFT___39 = 17,
    SF_CHANNEL_MAP_TOP_FRONT_RIGHT___39 = 18,
    SF_CHANNEL_MAP_TOP_FRONT_CENTER___39 = 19,
    SF_CHANNEL_MAP_TOP_REAR_LEFT___39 = 20,
    SF_CHANNEL_MAP_TOP_REAR_RIGHT___39 = 21,
    SF_CHANNEL_MAP_TOP_REAR_CENTER___39 = 22
} ;
#line 352
enum __anonenum__970 {
    SFD_DEFAULT_LEVEL___39 = 0,
    SFD_CUSTOM_LEVEL___39 = 1073741824,
    SFD_NO_DITHER___39 = 500,
    SFD_WHITE___39 = 501,
    SFD_TRIANGULAR_PDF___39 = 502
} ;
#line 380
enum __anonenum__973 {
    SF_LOOP_NONE___39 = 800,
    SF_LOOP_FORWARD___39 = 801,
    SF_LOOP_BACKWARD___39 = 802,
    SF_LOOP_ALTERNATING___39 = 803
} ;
#line 121 "/root/libsndfile/src/common.h"
enum __anonenum__977 {
    SF_PEAK_START___39 = 42,
    SF_PEAK_END___39 = 43,
    SF_SCALE_MAX___39 = 52,
    SF_SCALE_MIN___39 = 53,
    SF_STR_ALLOW_START___39 = 256,
    SF_STR_ALLOW_END___39 = 512,
    SF_STR_LOCATE_START___39 = 1024,
    SF_STR_LOCATE_END___39 = 2048,
    SFD_TYPEMASK___39 = 268435455
} ;
#line 149
enum __anonenum__978 {
    SF_FORMAT_TXW___39 = 67305472,
    SF_FORMAT_DWD___39 = 67371008,
    SF_FORMAT_REX___39 = 67764224,
    SF_FORMAT_REX2___39 = 67960832,
    SF_FORMAT_KRZ___39 = 68026368,
    SF_FORMAT_WMA___39 = 68157440,
    SF_FORMAT_SHN___39 = 68222976,
    SF_FORMAT_SVX_FIB___39 = 4128,
    SF_FORMAT_SVX_EXP___39 = 4129,
    SF_FORMAT_PCM_N___39 = 4144
} ;
#line 405
enum __anonenum__984 {
    SFE_NO_ERROR___39 = 0,
    SFE_BAD_OPEN_FORMAT___39 = 1,
    SFE_SYSTEM___39 = 2,
    SFE_MALFORMED_FILE___39 = 3,
    SFE_UNSUPPORTED_ENCODING___39 = 4,
    SFE_ZERO_MAJOR_FORMAT___39 = 5,
    SFE_ZERO_MINOR_FORMAT___39 = 6,
    SFE_BAD_FILE___39 = 7,
    SFE_BAD_FILE_READ___39 = 8,
    SFE_OPEN_FAILED___39 = 9,
    SFE_BAD_SNDFILE_PTR___39 = 10,
    SFE_BAD_SF_INFO_PTR___39 = 11,
    SFE_BAD_SF_INCOMPLETE___39 = 12,
    SFE_BAD_FILE_PTR___39 = 13,
    SFE_BAD_INT_PTR___39 = 14,
    SFE_BAD_STAT_SIZE___39 = 15,
    SFE_MALLOC_FAILED___39 = 16,
    SFE_UNIMPLEMENTED___39 = 17,
    SFE_BAD_READ_ALIGN___39 = 18,
    SFE_BAD_WRITE_ALIGN___39 = 19,
    SFE_UNKNOWN_FORMAT___39 = 20,
    SFE_NOT_READMODE___39 = 21,
    SFE_NOT_WRITEMODE___39 = 22,
    SFE_BAD_MODE_RW___39 = 23,
    SFE_BAD_SF_INFO___39 = 24,
    SFE_BAD_OFFSET___39 = 25,
    SFE_NO_EMBED_SUPPORT___39 = 26,
    SFE_NO_EMBEDDED_RDWR___39 = 27,
    SFE_NO_PIPE_WRITE___39 = 28,
    SFE_INTERNAL___39 = 29,
    SFE_BAD_COMMAND_PARAM___39 = 30,
    SFE_BAD_ENDIAN___39 = 31,
    SFE_CHANNEL_COUNT_ZERO___39 = 32,
    SFE_CHANNEL_COUNT___39 = 33,
    SFE_BAD_VIRTUAL_IO___39 = 34,
    SFE_INTERLEAVE_MODE___39 = 35,
    SFE_INTERLEAVE_SEEK___39 = 36,
    SFE_INTERLEAVE_READ___39 = 37,
    SFE_BAD_SEEK___39 = 38,
    SFE_NOT_SEEKABLE___39 = 39,
    SFE_AMBIGUOUS_SEEK___39 = 40,
    SFE_WRONG_SEEK___39 = 41,
    SFE_SEEK_FAILED___39 = 42,
    SFE_BAD_OPEN_MODE___39 = 43,
    SFE_OPEN_PIPE_RDWR___39 = 44,
    SFE_RDWR_POSITION___39 = 45,
    SFE_RDWR_BAD_HEADER___39 = 46,
    SFE_CMD_HAS_DATA___39 = 47,
    SFE_BAD_BROADCAST_INFO_SIZE___39 = 48,
    SFE_STR_NO_SUPPORT___39 = 49,
    SFE_STR_NOT_WRITE___39 = 50,
    SFE_STR_MAX_DATA___39 = 51,
    SFE_STR_MAX_COUNT___39 = 52,
    SFE_STR_BAD_TYPE___39 = 53,
    SFE_STR_NO_ADD_END___39 = 54,
    SFE_STR_BAD_STRING___39 = 55,
    SFE_STR_WEIRD___39 = 56,
    SFE_WAV_NO_RIFF___39 = 57,
    SFE_WAV_NO_WAVE___39 = 58,
    SFE_WAV_NO_FMT___39 = 59,
    SFE_WAV_BAD_FMT___39 = 60,
    SFE_WAV_FMT_SHORT___39 = 61,
    SFE_WAV_BAD_FACT___39 = 62,
    SFE_WAV_BAD_PEAK___39 = 63,
    SFE_WAV_PEAK_B4_FMT___39 = 64,
    SFE_WAV_BAD_FORMAT___39 = 65,
    SFE_WAV_BAD_BLOCKALIGN___39 = 66,
    SFE_WAV_NO_DATA___39 = 67,
    SFE_WAV_BAD_LIST___39 = 68,
    SFE_WAV_ADPCM_NOT4BIT___39 = 69,
    SFE_WAV_ADPCM_CHANNELS___39 = 70,
    SFE_WAV_GSM610_FORMAT___39 = 71,
    SFE_WAV_UNKNOWN_CHUNK___39 = 72,
    SFE_WAV_WVPK_DATA___39 = 73,
    SFE_AIFF_NO_FORM___39 = 74,
    SFE_AIFF_AIFF_NO_FORM___39 = 75,
    SFE_AIFF_COMM_NO_FORM___39 = 76,
    SFE_AIFF_SSND_NO_COMM___39 = 77,
    SFE_AIFF_UNKNOWN_CHUNK___39 = 78,
    SFE_AIFF_COMM_CHUNK_SIZE___39 = 79,
    SFE_AIFF_BAD_COMM_CHUNK___39 = 80,
    SFE_AIFF_PEAK_B4_COMM___39 = 81,
    SFE_AIFF_BAD_PEAK___39 = 82,
    SFE_AIFF_NO_SSND___39 = 83,
    SFE_AIFF_NO_DATA___39 = 84,
    SFE_AIFF_RW_SSND_NOT_LAST___39 = 85,
    SFE_AU_UNKNOWN_FORMAT___39 = 86,
    SFE_AU_NO_DOTSND___39 = 87,
    SFE_AU_EMBED_BAD_LEN___39 = 88,
    SFE_RAW_READ_BAD_SPEC___39 = 89,
    SFE_RAW_BAD_BITWIDTH___39 = 90,
    SFE_RAW_BAD_FORMAT___39 = 91,
    SFE_PAF_NO_MARKER___39 = 92,
    SFE_PAF_VERSION___39 = 93,
    SFE_PAF_UNKNOWN_FORMAT___39 = 94,
    SFE_PAF_SHORT_HEADER___39 = 95,
    SFE_SVX_NO_FORM___39 = 96,
    SFE_SVX_NO_BODY___39 = 97,
    SFE_SVX_NO_DATA___39 = 98,
    SFE_SVX_BAD_COMP___39 = 99,
    SFE_SVX_BAD_NAME_LENGTH___39 = 100,
    SFE_NIST_BAD_HEADER___39 = 101,
    SFE_NIST_CRLF_CONVERISON___39 = 102,
    SFE_NIST_BAD_ENCODING___39 = 103,
    SFE_VOC_NO_CREATIVE___39 = 104,
    SFE_VOC_BAD_FORMAT___39 = 105,
    SFE_VOC_BAD_VERSION___39 = 106,
    SFE_VOC_BAD_MARKER___39 = 107,
    SFE_VOC_BAD_SECTIONS___39 = 108,
    SFE_VOC_MULTI_SAMPLERATE___39 = 109,
    SFE_VOC_MULTI_SECTION___39 = 110,
    SFE_VOC_MULTI_PARAM___39 = 111,
    SFE_VOC_SECTION_COUNT___39 = 112,
    SFE_VOC_NO_PIPE___39 = 113,
    SFE_IRCAM_NO_MARKER___39 = 114,
    SFE_IRCAM_BAD_CHANNELS___39 = 115,
    SFE_IRCAM_UNKNOWN_FORMAT___39 = 116,
    SFE_W64_64_BIT___39 = 117,
    SFE_W64_NO_RIFF___39 = 118,
    SFE_W64_NO_WAVE___39 = 119,
    SFE_W64_NO_DATA___39 = 120,
    SFE_W64_ADPCM_NOT4BIT___39 = 121,
    SFE_W64_ADPCM_CHANNELS___39 = 122,
    SFE_W64_GSM610_FORMAT___39 = 123,
    SFE_MAT4_BAD_NAME___39 = 124,
    SFE_MAT4_NO_SAMPLERATE___39 = 125,
    SFE_MAT5_BAD_ENDIAN___39 = 126,
    SFE_MAT5_NO_BLOCK___39 = 127,
    SFE_MAT5_SAMPLE_RATE___39 = 128,
    SFE_PVF_NO_PVF1___39 = 129,
    SFE_PVF_BAD_HEADER___39 = 130,
    SFE_PVF_BAD_BITWIDTH___39 = 131,
    SFE_DWVW_BAD_BITWIDTH___39 = 132,
    SFE_G72X_NOT_MONO___39 = 133,
    SFE_XI_BAD_HEADER___39 = 134,
    SFE_XI_EXCESS_SAMPLES___39 = 135,
    SFE_XI_NO_PIPE___39 = 136,
    SFE_HTK_NO_PIPE___39 = 137,
    SFE_SDS_NOT_SDS___39 = 138,
    SFE_SDS_BAD_BIT_WIDTH___39 = 139,
    SFE_SD2_FD_DISALLOWED___39 = 140,
    SFE_SD2_BAD_DATA_OFFSET___39 = 141,
    SFE_SD2_BAD_MAP_OFFSET___39 = 142,
    SFE_SD2_BAD_DATA_LENGTH___39 = 143,
    SFE_SD2_BAD_MAP_LENGTH___39 = 144,
    SFE_SD2_BAD_RSRC___39 = 145,
    SFE_SD2_BAD_SAMPLE_SIZE___39 = 146,
    SFE_FLAC_BAD_HEADER___39 = 147,
    SFE_FLAC_NEW_DECODER___39 = 148,
    SFE_FLAC_INIT_DECODER___39 = 149,
    SFE_FLAC_LOST_SYNC___39 = 150,
    SFE_FLAC_BAD_SAMPLE_RATE___39 = 151,
    SFE_FLAC_UNKOWN_ERROR___39 = 152,
    SFE_WVE_NOT_WVE___39 = 153,
    SFE_WVE_NO_PIPE___39 = 154,
    SFE_VORBIS_ENCODER_BUG___39 = 155,
    SFE_RF64_NOT_RF64___39 = 156,
    SFE_MAX_ERROR___39 = 157
} ;
#line 823
enum __anonenum__988 {
    SFC_TEST_AIFF_ADD_INST_CHUNK___39 = 8192,
    SFC_TEST_WAV_ADD_INFO_CHUNK___39 = 8208
} ;
#line 46 "/root/libsndfile/src/sndfile.h"
enum __anonenum__411___0 {
    SF_FORMAT_WAV___40 = 65536,
    SF_FORMAT_AIFF___40 = 131072,
    SF_FORMAT_AU___40 = 196608,
    SF_FORMAT_RAW___40 = 262144,
    SF_FORMAT_PAF___40 = 327680,
    SF_FORMAT_SVX___40 = 393216,
    SF_FORMAT_NIST___40 = 458752,
    SF_FORMAT_VOC___40 = 524288,
    SF_FORMAT_IRCAM___40 = 655360,
    SF_FORMAT_W64___40 = 720896,
    SF_FORMAT_MAT4___40 = 786432,
    SF_FORMAT_MAT5___40 = 851968,
    SF_FORMAT_PVF___40 = 917504,
    SF_FORMAT_XI___40 = 983040,
    SF_FORMAT_HTK___40 = 1048576,
    SF_FORMAT_SDS___40 = 1114112,
    SF_FORMAT_AVR___40 = 1179648,
    SF_FORMAT_WAVEX___40 = 1245184,
    SF_FORMAT_SD2___40 = 1441792,
    SF_FORMAT_FLAC___40 = 1507328,
    SF_FORMAT_CAF___40 = 1572864,
    SF_FORMAT_WVE___40 = 1638400,
    SF_FORMAT_OGG___40 = 2097152,
    SF_FORMAT_MPC2K___40 = 2162688,
    SF_FORMAT_RF64___40 = 2228224,
    SF_FORMAT_PCM_S8___40 = 1,
    SF_FORMAT_PCM_16___40 = 2,
    SF_FORMAT_PCM_24___40 = 3,
    SF_FORMAT_PCM_32___40 = 4,
    SF_FORMAT_PCM_U8___40 = 5,
    SF_FORMAT_FLOAT___40 = 6,
    SF_FORMAT_DOUBLE___40 = 7,
    SF_FORMAT_ULAW___40 = 16,
    SF_FORMAT_ALAW___40 = 17,
    SF_FORMAT_IMA_ADPCM___40 = 18,
    SF_FORMAT_MS_ADPCM___40 = 19,
    SF_FORMAT_GSM610___40 = 32,
    SF_FORMAT_VOX_ADPCM___40 = 33,
    SF_FORMAT_G721_32___40 = 48,
    SF_FORMAT_G723_24___40 = 49,
    SF_FORMAT_G723_40___40 = 50,
    SF_FORMAT_DWVW_12___40 = 64,
    SF_FORMAT_DWVW_16___40 = 65,
    SF_FORMAT_DWVW_24___40 = 66,
    SF_FORMAT_DWVW_N___40 = 67,
    SF_FORMAT_DPCM_8___40 = 80,
    SF_FORMAT_DPCM_16___40 = 81,
    SF_FORMAT_VORBIS___40 = 96,
    SF_ENDIAN_FILE___40 = 0,
    SF_ENDIAN_LITTLE___40 = 268435456,
    SF_ENDIAN_BIG___40 = 536870912,
    SF_ENDIAN_CPU___40 = 805306368,
    SF_FORMAT_SUBMASK___40 = 65535,
    SF_FORMAT_TYPEMASK___40 = 268369920,
    SF_FORMAT_ENDMASK___40 = 805306368
} ;
#line 126
enum __anonenum__412___0 {
    SFC_GET_LIB_VERSION___40 = 4096,
    SFC_GET_LOG_INFO___40 = 4097,
    SFC_GET_CURRENT_SF_INFO___40 = 4098,
    SFC_GET_NORM_DOUBLE___40 = 4112,
    SFC_GET_NORM_FLOAT___40 = 4113,
    SFC_SET_NORM_DOUBLE___40 = 4114,
    SFC_SET_NORM_FLOAT___40 = 4115,
    SFC_SET_SCALE_FLOAT_INT_READ___40 = 4116,
    SFC_SET_SCALE_INT_FLOAT_WRITE___40 = 4117,
    SFC_GET_SIMPLE_FORMAT_COUNT___40 = 4128,
    SFC_GET_SIMPLE_FORMAT___40 = 4129,
    SFC_GET_FORMAT_INFO___40 = 4136,
    SFC_GET_FORMAT_MAJOR_COUNT___40 = 4144,
    SFC_GET_FORMAT_MAJOR___40 = 4145,
    SFC_GET_FORMAT_SUBTYPE_COUNT___40 = 4146,
    SFC_GET_FORMAT_SUBTYPE___40 = 4147,
    SFC_CALC_SIGNAL_MAX___40 = 4160,
    SFC_CALC_NORM_SIGNAL_MAX___40 = 4161,
    SFC_CALC_MAX_ALL_CHANNELS___40 = 4162,
    SFC_CALC_NORM_MAX_ALL_CHANNELS___40 = 4163,
    SFC_GET_SIGNAL_MAX___40 = 4164,
    SFC_GET_MAX_ALL_CHANNELS___40 = 4165,
    SFC_SET_ADD_PEAK_CHUNK___40 = 4176,
    SFC_SET_ADD_HEADER_PAD_CHUNK___40 = 4177,
    SFC_UPDATE_HEADER_NOW___40 = 4192,
    SFC_SET_UPDATE_HEADER_AUTO___40 = 4193,
    SFC_FILE_TRUNCATE___40 = 4224,
    SFC_SET_RAW_START_OFFSET___40 = 4240,
    SFC_SET_DITHER_ON_WRITE___40 = 4256,
    SFC_SET_DITHER_ON_READ___40 = 4257,
    SFC_GET_DITHER_INFO_COUNT___40 = 4258,
    SFC_GET_DITHER_INFO___40 = 4259,
    SFC_GET_EMBED_FILE_INFO___40 = 4272,
    SFC_SET_CLIPPING___40 = 4288,
    SFC_GET_CLIPPING___40 = 4289,
    SFC_GET_INSTRUMENT___40 = 4304,
    SFC_SET_INSTRUMENT___40 = 4305,
    SFC_GET_LOOP_INFO___40 = 4320,
    SFC_GET_BROADCAST_INFO___40 = 4336,
    SFC_SET_BROADCAST_INFO___40 = 4337,
    SFC_GET_CHANNEL_MAP_INFO___40 = 4352,
    SFC_SET_CHANNEL_MAP_INFO___40 = 4353,
    SFC_RAW_DATA_NEEDS_ENDSWAP___40 = 4368,
    SFC_WAVEX_SET_AMBISONIC___40 = 4608,
    SFC_WAVEX_GET_AMBISONIC___40 = 4609,
    SFC_SET_VBR_ENCODING_QUALITY___40 = 4864,
    SFC_TEST_IEEE_FLOAT_REPLACE___40 = 24577,
    SFC_SET_ADD_DITHER_ON_WRITE___40 = 4208,
    SFC_SET_ADD_DITHER_ON_READ___40 = 4209
} ;
#line 216
enum __anonenum__413___0 {
    SF_STR_TITLE___40 = 1,
    SF_STR_COPYRIGHT___40 = 2,
    SF_STR_SOFTWARE___40 = 3,
    SF_STR_ARTIST___40 = 4,
    SF_STR_COMMENT___40 = 5,
    SF_STR_DATE___40 = 6,
    SF_STR_ALBUM___40 = 7,
    SF_STR_LICENSE___40 = 8
} ;
#line 235
enum __anonenum__414___0 {
    SF_FALSE___40 = 0,
    SF_TRUE___40 = 1,
    SFM_READ___40 = 16,
    SFM_WRITE___40 = 32,
    SFM_RDWR___40 = 48,
    SF_AMBISONIC_NONE___40 = 64,
    SF_AMBISONIC_B_FORMAT___40 = 65
} ;
#line 255
enum __anonenum__415___0 {
    SF_ERR_NO_ERROR___40 = 0,
    SF_ERR_UNRECOGNISED_FORMAT___40 = 1,
    SF_ERR_SYSTEM___40 = 2,
    SF_ERR_MALFORMED_FILE___40 = 3,
    SF_ERR_UNSUPPORTED_ENCODING___40 = 4
} ;
#line 267
enum __anonenum__416___0 {
    SF_CHANNEL_MAP_INVALID___40 = 0,
    SF_CHANNEL_MAP_MONO___40 = 1,
    SF_CHANNEL_MAP_LEFT___40 = 2,
    SF_CHANNEL_MAP_RIGHT___40 = 3,
    SF_CHANNEL_MAP_CENTER___40 = 4,
    SF_CHANNEL_MAP_FRONT_LEFT___40 = 5,
    SF_CHANNEL_MAP_FRONT_RIGHT___40 = 6,
    SF_CHANNEL_MAP_FRONT_CENTER___40 = 7,
    SF_CHANNEL_MAP_REAR_CENTER___40 = 8,
    SF_CHANNEL_MAP_REAR_LEFT___40 = 9,
    SF_CHANNEL_MAP_REAR_RIGHT___40 = 10,
    SF_CHANNEL_MAP_LFE___40 = 11,
    SF_CHANNEL_MAP_FRONT_LEFT_OF_CENTER___40 = 12,
    SF_CHANNEL_MAP_FRONT_RIGHT_OF_CENTER___40 = 13,
    SF_CHANNEL_MAP_SIDE_LEFT___40 = 14,
    SF_CHANNEL_MAP_SIDE_RIGHT___40 = 15,
    SF_CHANNEL_MAP_TOP_CENTER___40 = 16,
    SF_CHANNEL_MAP_TOP_FRONT_LEFT___40 = 17,
    SF_CHANNEL_MAP_TOP_FRONT_RIGHT___40 = 18,
    SF_CHANNEL_MAP_TOP_FRONT_CENTER___40 = 19,
    SF_CHANNEL_MAP_TOP_REAR_LEFT___40 = 20,
    SF_CHANNEL_MAP_TOP_REAR_RIGHT___40 = 21,
    SF_CHANNEL_MAP_TOP_REAR_CENTER___40 = 22
} ;
#line 352
enum __anonenum__418___0 {
    SFD_DEFAULT_LEVEL___40 = 0,
    SFD_CUSTOM_LEVEL___40 = 1073741824,
    SFD_NO_DITHER___40 = 500,
    SFD_WHITE___40 = 501,
    SFD_TRIANGULAR_PDF___40 = 502
} ;
#line 380
enum __anonenum__421___0 {
    SF_LOOP_NONE___40 = 800,
    SF_LOOP_FORWARD___40 = 801,
    SF_LOOP_BACKWARD___40 = 802,
    SF_LOOP_ALTERNATING___40 = 803
} ;
#line 121 "/root/libsndfile/src/common.h"
enum __anonenum__425___0 {
    SF_PEAK_START___40 = 42,
    SF_PEAK_END___40 = 43,
    SF_SCALE_MAX___40 = 52,
    SF_SCALE_MIN___40 = 53,
    SF_STR_ALLOW_START___40 = 256,
    SF_STR_ALLOW_END___40 = 512,
    SF_STR_LOCATE_START___40 = 1024,
    SF_STR_LOCATE_END___40 = 2048,
    SFD_TYPEMASK___40 = 268435455
} ;
#line 149
enum __anonenum__426___0 {
    SF_FORMAT_TXW___40 = 67305472,
    SF_FORMAT_DWD___40 = 67371008,
    SF_FORMAT_REX___40 = 67764224,
    SF_FORMAT_REX2___40 = 67960832,
    SF_FORMAT_KRZ___40 = 68026368,
    SF_FORMAT_WMA___40 = 68157440,
    SF_FORMAT_SHN___40 = 68222976,
    SF_FORMAT_SVX_FIB___40 = 4128,
    SF_FORMAT_SVX_EXP___40 = 4129,
    SF_FORMAT_PCM_N___40 = 4144
} ;
#line 405
enum __anonenum__432___0 {
    SFE_NO_ERROR___40 = 0,
    SFE_BAD_OPEN_FORMAT___40 = 1,
    SFE_SYSTEM___40 = 2,
    SFE_MALFORMED_FILE___40 = 3,
    SFE_UNSUPPORTED_ENCODING___40 = 4,
    SFE_ZERO_MAJOR_FORMAT___40 = 5,
    SFE_ZERO_MINOR_FORMAT___40 = 6,
    SFE_BAD_FILE___40 = 7,
    SFE_BAD_FILE_READ___40 = 8,
    SFE_OPEN_FAILED___40 = 9,
    SFE_BAD_SNDFILE_PTR___40 = 10,
    SFE_BAD_SF_INFO_PTR___40 = 11,
    SFE_BAD_SF_INCOMPLETE___40 = 12,
    SFE_BAD_FILE_PTR___40 = 13,
    SFE_BAD_INT_PTR___40 = 14,
    SFE_BAD_STAT_SIZE___40 = 15,
    SFE_MALLOC_FAILED___40 = 16,
    SFE_UNIMPLEMENTED___40 = 17,
    SFE_BAD_READ_ALIGN___40 = 18,
    SFE_BAD_WRITE_ALIGN___40 = 19,
    SFE_UNKNOWN_FORMAT___40 = 20,
    SFE_NOT_READMODE___40 = 21,
    SFE_NOT_WRITEMODE___40 = 22,
    SFE_BAD_MODE_RW___40 = 23,
    SFE_BAD_SF_INFO___40 = 24,
    SFE_BAD_OFFSET___40 = 25,
    SFE_NO_EMBED_SUPPORT___40 = 26,
    SFE_NO_EMBEDDED_RDWR___40 = 27,
    SFE_NO_PIPE_WRITE___40 = 28,
    SFE_INTERNAL___40 = 29,
    SFE_BAD_COMMAND_PARAM___40 = 30,
    SFE_BAD_ENDIAN___40 = 31,
    SFE_CHANNEL_COUNT_ZERO___40 = 32,
    SFE_CHANNEL_COUNT___40 = 33,
    SFE_BAD_VIRTUAL_IO___40 = 34,
    SFE_INTERLEAVE_MODE___40 = 35,
    SFE_INTERLEAVE_SEEK___40 = 36,
    SFE_INTERLEAVE_READ___40 = 37,
    SFE_BAD_SEEK___40 = 38,
    SFE_NOT_SEEKABLE___40 = 39,
    SFE_AMBIGUOUS_SEEK___40 = 40,
    SFE_WRONG_SEEK___40 = 41,
    SFE_SEEK_FAILED___40 = 42,
    SFE_BAD_OPEN_MODE___40 = 43,
    SFE_OPEN_PIPE_RDWR___40 = 44,
    SFE_RDWR_POSITION___40 = 45,
    SFE_RDWR_BAD_HEADER___40 = 46,
    SFE_CMD_HAS_DATA___40 = 47,
    SFE_BAD_BROADCAST_INFO_SIZE___40 = 48,
    SFE_STR_NO_SUPPORT___40 = 49,
    SFE_STR_NOT_WRITE___40 = 50,
    SFE_STR_MAX_DATA___40 = 51,
    SFE_STR_MAX_COUNT___40 = 52,
    SFE_STR_BAD_TYPE___40 = 53,
    SFE_STR_NO_ADD_END___40 = 54,
    SFE_STR_BAD_STRING___40 = 55,
    SFE_STR_WEIRD___40 = 56,
    SFE_WAV_NO_RIFF___40 = 57,
    SFE_WAV_NO_WAVE___40 = 58,
    SFE_WAV_NO_FMT___40 = 59,
    SFE_WAV_BAD_FMT___40 = 60,
    SFE_WAV_FMT_SHORT___40 = 61,
    SFE_WAV_BAD_FACT___40 = 62,
    SFE_WAV_BAD_PEAK___40 = 63,
    SFE_WAV_PEAK_B4_FMT___40 = 64,
    SFE_WAV_BAD_FORMAT___40 = 65,
    SFE_WAV_BAD_BLOCKALIGN___40 = 66,
    SFE_WAV_NO_DATA___40 = 67,
    SFE_WAV_BAD_LIST___40 = 68,
    SFE_WAV_ADPCM_NOT4BIT___40 = 69,
    SFE_WAV_ADPCM_CHANNELS___40 = 70,
    SFE_WAV_GSM610_FORMAT___40 = 71,
    SFE_WAV_UNKNOWN_CHUNK___40 = 72,
    SFE_WAV_WVPK_DATA___40 = 73,
    SFE_AIFF_NO_FORM___40 = 74,
    SFE_AIFF_AIFF_NO_FORM___40 = 75,
    SFE_AIFF_COMM_NO_FORM___40 = 76,
    SFE_AIFF_SSND_NO_COMM___40 = 77,
    SFE_AIFF_UNKNOWN_CHUNK___40 = 78,
    SFE_AIFF_COMM_CHUNK_SIZE___40 = 79,
    SFE_AIFF_BAD_COMM_CHUNK___40 = 80,
    SFE_AIFF_PEAK_B4_COMM___40 = 81,
    SFE_AIFF_BAD_PEAK___40 = 82,
    SFE_AIFF_NO_SSND___40 = 83,
    SFE_AIFF_NO_DATA___40 = 84,
    SFE_AIFF_RW_SSND_NOT_LAST___40 = 85,
    SFE_AU_UNKNOWN_FORMAT___40 = 86,
    SFE_AU_NO_DOTSND___40 = 87,
    SFE_AU_EMBED_BAD_LEN___40 = 88,
    SFE_RAW_READ_BAD_SPEC___40 = 89,
    SFE_RAW_BAD_BITWIDTH___40 = 90,
    SFE_RAW_BAD_FORMAT___40 = 91,
    SFE_PAF_NO_MARKER___40 = 92,
    SFE_PAF_VERSION___40 = 93,
    SFE_PAF_UNKNOWN_FORMAT___40 = 94,
    SFE_PAF_SHORT_HEADER___40 = 95,
    SFE_SVX_NO_FORM___40 = 96,
    SFE_SVX_NO_BODY___40 = 97,
    SFE_SVX_NO_DATA___40 = 98,
    SFE_SVX_BAD_COMP___40 = 99,
    SFE_SVX_BAD_NAME_LENGTH___40 = 100,
    SFE_NIST_BAD_HEADER___40 = 101,
    SFE_NIST_CRLF_CONVERISON___40 = 102,
    SFE_NIST_BAD_ENCODING___40 = 103,
    SFE_VOC_NO_CREATIVE___40 = 104,
    SFE_VOC_BAD_FORMAT___40 = 105,
    SFE_VOC_BAD_VERSION___40 = 106,
    SFE_VOC_BAD_MARKER___40 = 107,
    SFE_VOC_BAD_SECTIONS___40 = 108,
    SFE_VOC_MULTI_SAMPLERATE___40 = 109,
    SFE_VOC_MULTI_SECTION___40 = 110,
    SFE_VOC_MULTI_PARAM___40 = 111,
    SFE_VOC_SECTION_COUNT___40 = 112,
    SFE_VOC_NO_PIPE___40 = 113,
    SFE_IRCAM_NO_MARKER___40 = 114,
    SFE_IRCAM_BAD_CHANNELS___40 = 115,
    SFE_IRCAM_UNKNOWN_FORMAT___40 = 116,
    SFE_W64_64_BIT___40 = 117,
    SFE_W64_NO_RIFF___40 = 118,
    SFE_W64_NO_WAVE___40 = 119,
    SFE_W64_NO_DATA___40 = 120,
    SFE_W64_ADPCM_NOT4BIT___40 = 121,
    SFE_W64_ADPCM_CHANNELS___40 = 122,
    SFE_W64_GSM610_FORMAT___40 = 123,
    SFE_MAT4_BAD_NAME___40 = 124,
    SFE_MAT4_NO_SAMPLERATE___40 = 125,
    SFE_MAT5_BAD_ENDIAN___40 = 126,
    SFE_MAT5_NO_BLOCK___40 = 127,
    SFE_MAT5_SAMPLE_RATE___40 = 128,
    SFE_PVF_NO_PVF1___40 = 129,
    SFE_PVF_BAD_HEADER___40 = 130,
    SFE_PVF_BAD_BITWIDTH___40 = 131,
    SFE_DWVW_BAD_BITWIDTH___40 = 132,
    SFE_G72X_NOT_MONO___40 = 133,
    SFE_XI_BAD_HEADER___40 = 134,
    SFE_XI_EXCESS_SAMPLES___40 = 135,
    SFE_XI_NO_PIPE___40 = 136,
    SFE_HTK_NO_PIPE___40 = 137,
    SFE_SDS_NOT_SDS___40 = 138,
    SFE_SDS_BAD_BIT_WIDTH___40 = 139,
    SFE_SD2_FD_DISALLOWED___40 = 140,
    SFE_SD2_BAD_DATA_OFFSET___40 = 141,
    SFE_SD2_BAD_MAP_OFFSET___40 = 142,
    SFE_SD2_BAD_DATA_LENGTH___40 = 143,
    SFE_SD2_BAD_MAP_LENGTH___40 = 144,
    SFE_SD2_BAD_RSRC___40 = 145,
    SFE_SD2_BAD_SAMPLE_SIZE___40 = 146,
    SFE_FLAC_BAD_HEADER___40 = 147,
    SFE_FLAC_NEW_DECODER___40 = 148,
    SFE_FLAC_INIT_DECODER___40 = 149,
    SFE_FLAC_LOST_SYNC___40 = 150,
    SFE_FLAC_BAD_SAMPLE_RATE___40 = 151,
    SFE_FLAC_UNKOWN_ERROR___40 = 152,
    SFE_WVE_NOT_WVE___40 = 153,
    SFE_WVE_NO_PIPE___40 = 154,
    SFE_VORBIS_ENCODER_BUG___40 = 155,
    SFE_RF64_NOT_RF64___40 = 156,
    SFE_MAX_ERROR___40 = 157
} ;
#line 823
enum __anonenum__436___0 {
    SFC_TEST_AIFF_ADD_INST_CHUNK___40 = 8192,
    SFC_TEST_WAV_ADD_INFO_CHUNK___40 = 8208
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__510___8 {
    _ISupper___18 = 256,
    _ISlower___18 = 512,
    _ISalpha___18 = 1024,
    _ISdigit___18 = 2048,
    _ISxdigit___18 = 4096,
    _ISspace___18 = 8192,
    _ISprint___18 = 16384,
    _ISgraph___18 = 32768,
    _ISblank___18 = 1,
    _IScntrl___18 = 2,
    _ISpunct___18 = 4,
    _ISalnum___18 = 8
} ;
#line 46 "/root/libsndfile/src/sndfile.h"
enum __anonenum__524___5 {
    SF_FORMAT_WAV___41 = 65536,
    SF_FORMAT_AIFF___41 = 131072,
    SF_FORMAT_AU___41 = 196608,
    SF_FORMAT_RAW___41 = 262144,
    SF_FORMAT_PAF___41 = 327680,
    SF_FORMAT_SVX___41 = 393216,
    SF_FORMAT_NIST___41 = 458752,
    SF_FORMAT_VOC___41 = 524288,
    SF_FORMAT_IRCAM___41 = 655360,
    SF_FORMAT_W64___41 = 720896,
    SF_FORMAT_MAT4___41 = 786432,
    SF_FORMAT_MAT5___41 = 851968,
    SF_FORMAT_PVF___41 = 917504,
    SF_FORMAT_XI___41 = 983040,
    SF_FORMAT_HTK___41 = 1048576,
    SF_FORMAT_SDS___41 = 1114112,
    SF_FORMAT_AVR___41 = 1179648,
    SF_FORMAT_WAVEX___41 = 1245184,
    SF_FORMAT_SD2___41 = 1441792,
    SF_FORMAT_FLAC___41 = 1507328,
    SF_FORMAT_CAF___41 = 1572864,
    SF_FORMAT_WVE___41 = 1638400,
    SF_FORMAT_OGG___41 = 2097152,
    SF_FORMAT_MPC2K___41 = 2162688,
    SF_FORMAT_RF64___41 = 2228224,
    SF_FORMAT_PCM_S8___41 = 1,
    SF_FORMAT_PCM_16___41 = 2,
    SF_FORMAT_PCM_24___41 = 3,
    SF_FORMAT_PCM_32___41 = 4,
    SF_FORMAT_PCM_U8___41 = 5,
    SF_FORMAT_FLOAT___41 = 6,
    SF_FORMAT_DOUBLE___41 = 7,
    SF_FORMAT_ULAW___41 = 16,
    SF_FORMAT_ALAW___41 = 17,
    SF_FORMAT_IMA_ADPCM___41 = 18,
    SF_FORMAT_MS_ADPCM___41 = 19,
    SF_FORMAT_GSM610___41 = 32,
    SF_FORMAT_VOX_ADPCM___41 = 33,
    SF_FORMAT_G721_32___41 = 48,
    SF_FORMAT_G723_24___41 = 49,
    SF_FORMAT_G723_40___41 = 50,
    SF_FORMAT_DWVW_12___41 = 64,
    SF_FORMAT_DWVW_16___41 = 65,
    SF_FORMAT_DWVW_24___41 = 66,
    SF_FORMAT_DWVW_N___41 = 67,
    SF_FORMAT_DPCM_8___41 = 80,
    SF_FORMAT_DPCM_16___41 = 81,
    SF_FORMAT_VORBIS___41 = 96,
    SF_ENDIAN_FILE___41 = 0,
    SF_ENDIAN_LITTLE___41 = 268435456,
    SF_ENDIAN_BIG___41 = 536870912,
    SF_ENDIAN_CPU___41 = 805306368,
    SF_FORMAT_SUBMASK___41 = 65535,
    SF_FORMAT_TYPEMASK___41 = 268369920,
    SF_FORMAT_ENDMASK___41 = 805306368
} ;
#line 126
enum __anonenum__525___5 {
    SFC_GET_LIB_VERSION___41 = 4096,
    SFC_GET_LOG_INFO___41 = 4097,
    SFC_GET_CURRENT_SF_INFO___41 = 4098,
    SFC_GET_NORM_DOUBLE___41 = 4112,
    SFC_GET_NORM_FLOAT___41 = 4113,
    SFC_SET_NORM_DOUBLE___41 = 4114,
    SFC_SET_NORM_FLOAT___41 = 4115,
    SFC_SET_SCALE_FLOAT_INT_READ___41 = 4116,
    SFC_SET_SCALE_INT_FLOAT_WRITE___41 = 4117,
    SFC_GET_SIMPLE_FORMAT_COUNT___41 = 4128,
    SFC_GET_SIMPLE_FORMAT___41 = 4129,
    SFC_GET_FORMAT_INFO___41 = 4136,
    SFC_GET_FORMAT_MAJOR_COUNT___41 = 4144,
    SFC_GET_FORMAT_MAJOR___41 = 4145,
    SFC_GET_FORMAT_SUBTYPE_COUNT___41 = 4146,
    SFC_GET_FORMAT_SUBTYPE___41 = 4147,
    SFC_CALC_SIGNAL_MAX___41 = 4160,
    SFC_CALC_NORM_SIGNAL_MAX___41 = 4161,
    SFC_CALC_MAX_ALL_CHANNELS___41 = 4162,
    SFC_CALC_NORM_MAX_ALL_CHANNELS___41 = 4163,
    SFC_GET_SIGNAL_MAX___41 = 4164,
    SFC_GET_MAX_ALL_CHANNELS___41 = 4165,
    SFC_SET_ADD_PEAK_CHUNK___41 = 4176,
    SFC_SET_ADD_HEADER_PAD_CHUNK___41 = 4177,
    SFC_UPDATE_HEADER_NOW___41 = 4192,
    SFC_SET_UPDATE_HEADER_AUTO___41 = 4193,
    SFC_FILE_TRUNCATE___41 = 4224,
    SFC_SET_RAW_START_OFFSET___41 = 4240,
    SFC_SET_DITHER_ON_WRITE___41 = 4256,
    SFC_SET_DITHER_ON_READ___41 = 4257,
    SFC_GET_DITHER_INFO_COUNT___41 = 4258,
    SFC_GET_DITHER_INFO___41 = 4259,
    SFC_GET_EMBED_FILE_INFO___41 = 4272,
    SFC_SET_CLIPPING___41 = 4288,
    SFC_GET_CLIPPING___41 = 4289,
    SFC_GET_INSTRUMENT___41 = 4304,
    SFC_SET_INSTRUMENT___41 = 4305,
    SFC_GET_LOOP_INFO___41 = 4320,
    SFC_GET_BROADCAST_INFO___41 = 4336,
    SFC_SET_BROADCAST_INFO___41 = 4337,
    SFC_GET_CHANNEL_MAP_INFO___41 = 4352,
    SFC_SET_CHANNEL_MAP_INFO___41 = 4353,
    SFC_RAW_DATA_NEEDS_ENDSWAP___41 = 4368,
    SFC_WAVEX_SET_AMBISONIC___41 = 4608,
    SFC_WAVEX_GET_AMBISONIC___41 = 4609,
    SFC_SET_VBR_ENCODING_QUALITY___41 = 4864,
    SFC_TEST_IEEE_FLOAT_REPLACE___41 = 24577,
    SFC_SET_ADD_DITHER_ON_WRITE___41 = 4208,
    SFC_SET_ADD_DITHER_ON_READ___41 = 4209
} ;
#line 216
enum __anonenum__526___5 {
    SF_STR_TITLE___41 = 1,
    SF_STR_COPYRIGHT___41 = 2,
    SF_STR_SOFTWARE___41 = 3,
    SF_STR_ARTIST___41 = 4,
    SF_STR_COMMENT___41 = 5,
    SF_STR_DATE___41 = 6,
    SF_STR_ALBUM___41 = 7,
    SF_STR_LICENSE___41 = 8
} ;
#line 235
enum __anonenum__527___5 {
    SF_FALSE___41 = 0,
    SF_TRUE___41 = 1,
    SFM_READ___41 = 16,
    SFM_WRITE___41 = 32,
    SFM_RDWR___41 = 48,
    SF_AMBISONIC_NONE___41 = 64,
    SF_AMBISONIC_B_FORMAT___41 = 65
} ;
#line 255
enum __anonenum__528___5 {
    SF_ERR_NO_ERROR___41 = 0,
    SF_ERR_UNRECOGNISED_FORMAT___41 = 1,
    SF_ERR_SYSTEM___41 = 2,
    SF_ERR_MALFORMED_FILE___41 = 3,
    SF_ERR_UNSUPPORTED_ENCODING___41 = 4
} ;
#line 267
enum __anonenum__529___5 {
    SF_CHANNEL_MAP_INVALID___41 = 0,
    SF_CHANNEL_MAP_MONO___41 = 1,
    SF_CHANNEL_MAP_LEFT___41 = 2,
    SF_CHANNEL_MAP_RIGHT___41 = 3,
    SF_CHANNEL_MAP_CENTER___41 = 4,
    SF_CHANNEL_MAP_FRONT_LEFT___41 = 5,
    SF_CHANNEL_MAP_FRONT_RIGHT___41 = 6,
    SF_CHANNEL_MAP_FRONT_CENTER___41 = 7,
    SF_CHANNEL_MAP_REAR_CENTER___41 = 8,
    SF_CHANNEL_MAP_REAR_LEFT___41 = 9,
    SF_CHANNEL_MAP_REAR_RIGHT___41 = 10,
    SF_CHANNEL_MAP_LFE___41 = 11,
    SF_CHANNEL_MAP_FRONT_LEFT_OF_CENTER___41 = 12,
    SF_CHANNEL_MAP_FRONT_RIGHT_OF_CENTER___41 = 13,
    SF_CHANNEL_MAP_SIDE_LEFT___41 = 14,
    SF_CHANNEL_MAP_SIDE_RIGHT___41 = 15,
    SF_CHANNEL_MAP_TOP_CENTER___41 = 16,
    SF_CHANNEL_MAP_TOP_FRONT_LEFT___41 = 17,
    SF_CHANNEL_MAP_TOP_FRONT_RIGHT___41 = 18,
    SF_CHANNEL_MAP_TOP_FRONT_CENTER___41 = 19,
    SF_CHANNEL_MAP_TOP_REAR_LEFT___41 = 20,
    SF_CHANNEL_MAP_TOP_REAR_RIGHT___41 = 21,
    SF_CHANNEL_MAP_TOP_REAR_CENTER___41 = 22
} ;
#line 352
enum __anonenum__531___5 {
    SFD_DEFAULT_LEVEL___41 = 0,
    SFD_CUSTOM_LEVEL___41 = 1073741824,
    SFD_NO_DITHER___41 = 500,
    SFD_WHITE___41 = 501,
    SFD_TRIANGULAR_PDF___41 = 502
} ;
#line 380
enum __anonenum__534___5 {
    SF_LOOP_NONE___41 = 800,
    SF_LOOP_FORWARD___41 = 801,
    SF_LOOP_BACKWARD___41 = 802,
    SF_LOOP_ALTERNATING___41 = 803
} ;
#line 121 "/root/libsndfile/src/common.h"
enum __anonenum__543___5 {
    SF_PEAK_START___41 = 42,
    SF_PEAK_END___41 = 43,
    SF_SCALE_MAX___41 = 52,
    SF_SCALE_MIN___41 = 53,
    SF_STR_ALLOW_START___41 = 256,
    SF_STR_ALLOW_END___41 = 512,
    SF_STR_LOCATE_START___41 = 1024,
    SF_STR_LOCATE_END___41 = 2048,
    SFD_TYPEMASK___41 = 268435455
} ;
#line 149
enum __anonenum__544___5 {
    SF_FORMAT_TXW___41 = 67305472,
    SF_FORMAT_DWD___41 = 67371008,
    SF_FORMAT_REX___41 = 67764224,
    SF_FORMAT_REX2___41 = 67960832,
    SF_FORMAT_KRZ___41 = 68026368,
    SF_FORMAT_WMA___41 = 68157440,
    SF_FORMAT_SHN___41 = 68222976,
    SF_FORMAT_SVX_FIB___41 = 4128,
    SF_FORMAT_SVX_EXP___41 = 4129,
    SF_FORMAT_PCM_N___41 = 4144
} ;
#line 405
enum __anonenum__550___5 {
    SFE_NO_ERROR___41 = 0,
    SFE_BAD_OPEN_FORMAT___41 = 1,
    SFE_SYSTEM___41 = 2,
    SFE_MALFORMED_FILE___41 = 3,
    SFE_UNSUPPORTED_ENCODING___41 = 4,
    SFE_ZERO_MAJOR_FORMAT___41 = 5,
    SFE_ZERO_MINOR_FORMAT___41 = 6,
    SFE_BAD_FILE___41 = 7,
    SFE_BAD_FILE_READ___41 = 8,
    SFE_OPEN_FAILED___41 = 9,
    SFE_BAD_SNDFILE_PTR___41 = 10,
    SFE_BAD_SF_INFO_PTR___41 = 11,
    SFE_BAD_SF_INCOMPLETE___41 = 12,
    SFE_BAD_FILE_PTR___41 = 13,
    SFE_BAD_INT_PTR___41 = 14,
    SFE_BAD_STAT_SIZE___41 = 15,
    SFE_MALLOC_FAILED___41 = 16,
    SFE_UNIMPLEMENTED___41 = 17,
    SFE_BAD_READ_ALIGN___41 = 18,
    SFE_BAD_WRITE_ALIGN___41 = 19,
    SFE_UNKNOWN_FORMAT___41 = 20,
    SFE_NOT_READMODE___41 = 21,
    SFE_NOT_WRITEMODE___41 = 22,
    SFE_BAD_MODE_RW___41 = 23,
    SFE_BAD_SF_INFO___41 = 24,
    SFE_BAD_OFFSET___41 = 25,
    SFE_NO_EMBED_SUPPORT___41 = 26,
    SFE_NO_EMBEDDED_RDWR___41 = 27,
    SFE_NO_PIPE_WRITE___41 = 28,
    SFE_INTERNAL___41 = 29,
    SFE_BAD_COMMAND_PARAM___41 = 30,
    SFE_BAD_ENDIAN___41 = 31,
    SFE_CHANNEL_COUNT_ZERO___41 = 32,
    SFE_CHANNEL_COUNT___41 = 33,
    SFE_BAD_VIRTUAL_IO___41 = 34,
    SFE_INTERLEAVE_MODE___41 = 35,
    SFE_INTERLEAVE_SEEK___41 = 36,
    SFE_INTERLEAVE_READ___41 = 37,
    SFE_BAD_SEEK___41 = 38,
    SFE_NOT_SEEKABLE___41 = 39,
    SFE_AMBIGUOUS_SEEK___41 = 40,
    SFE_WRONG_SEEK___41 = 41,
    SFE_SEEK_FAILED___41 = 42,
    SFE_BAD_OPEN_MODE___41 = 43,
    SFE_OPEN_PIPE_RDWR___41 = 44,
    SFE_RDWR_POSITION___41 = 45,
    SFE_RDWR_BAD_HEADER___41 = 46,
    SFE_CMD_HAS_DATA___41 = 47,
    SFE_BAD_BROADCAST_INFO_SIZE___41 = 48,
    SFE_STR_NO_SUPPORT___41 = 49,
    SFE_STR_NOT_WRITE___41 = 50,
    SFE_STR_MAX_DATA___41 = 51,
    SFE_STR_MAX_COUNT___41 = 52,
    SFE_STR_BAD_TYPE___41 = 53,
    SFE_STR_NO_ADD_END___41 = 54,
    SFE_STR_BAD_STRING___41 = 55,
    SFE_STR_WEIRD___41 = 56,
    SFE_WAV_NO_RIFF___41 = 57,
    SFE_WAV_NO_WAVE___41 = 58,
    SFE_WAV_NO_FMT___41 = 59,
    SFE_WAV_BAD_FMT___41 = 60,
    SFE_WAV_FMT_SHORT___41 = 61,
    SFE_WAV_BAD_FACT___41 = 62,
    SFE_WAV_BAD_PEAK___41 = 63,
    SFE_WAV_PEAK_B4_FMT___41 = 64,
    SFE_WAV_BAD_FORMAT___41 = 65,
    SFE_WAV_BAD_BLOCKALIGN___41 = 66,
    SFE_WAV_NO_DATA___41 = 67,
    SFE_WAV_BAD_LIST___41 = 68,
    SFE_WAV_ADPCM_NOT4BIT___41 = 69,
    SFE_WAV_ADPCM_CHANNELS___41 = 70,
    SFE_WAV_GSM610_FORMAT___41 = 71,
    SFE_WAV_UNKNOWN_CHUNK___41 = 72,
    SFE_WAV_WVPK_DATA___41 = 73,
    SFE_AIFF_NO_FORM___41 = 74,
    SFE_AIFF_AIFF_NO_FORM___41 = 75,
    SFE_AIFF_COMM_NO_FORM___41 = 76,
    SFE_AIFF_SSND_NO_COMM___41 = 77,
    SFE_AIFF_UNKNOWN_CHUNK___41 = 78,
    SFE_AIFF_COMM_CHUNK_SIZE___41 = 79,
    SFE_AIFF_BAD_COMM_CHUNK___41 = 80,
    SFE_AIFF_PEAK_B4_COMM___41 = 81,
    SFE_AIFF_BAD_PEAK___41 = 82,
    SFE_AIFF_NO_SSND___41 = 83,
    SFE_AIFF_NO_DATA___41 = 84,
    SFE_AIFF_RW_SSND_NOT_LAST___41 = 85,
    SFE_AU_UNKNOWN_FORMAT___41 = 86,
    SFE_AU_NO_DOTSND___41 = 87,
    SFE_AU_EMBED_BAD_LEN___41 = 88,
    SFE_RAW_READ_BAD_SPEC___41 = 89,
    SFE_RAW_BAD_BITWIDTH___41 = 90,
    SFE_RAW_BAD_FORMAT___41 = 91,
    SFE_PAF_NO_MARKER___41 = 92,
    SFE_PAF_VERSION___41 = 93,
    SFE_PAF_UNKNOWN_FORMAT___41 = 94,
    SFE_PAF_SHORT_HEADER___41 = 95,
    SFE_SVX_NO_FORM___41 = 96,
    SFE_SVX_NO_BODY___41 = 97,
    SFE_SVX_NO_DATA___41 = 98,
    SFE_SVX_BAD_COMP___41 = 99,
    SFE_SVX_BAD_NAME_LENGTH___41 = 100,
    SFE_NIST_BAD_HEADER___41 = 101,
    SFE_NIST_CRLF_CONVERISON___41 = 102,
    SFE_NIST_BAD_ENCODING___41 = 103,
    SFE_VOC_NO_CREATIVE___41 = 104,
    SFE_VOC_BAD_FORMAT___41 = 105,
    SFE_VOC_BAD_VERSION___41 = 106,
    SFE_VOC_BAD_MARKER___41 = 107,
    SFE_VOC_BAD_SECTIONS___41 = 108,
    SFE_VOC_MULTI_SAMPLERATE___41 = 109,
    SFE_VOC_MULTI_SECTION___41 = 110,
    SFE_VOC_MULTI_PARAM___41 = 111,
    SFE_VOC_SECTION_COUNT___41 = 112,
    SFE_VOC_NO_PIPE___41 = 113,
    SFE_IRCAM_NO_MARKER___41 = 114,
    SFE_IRCAM_BAD_CHANNELS___41 = 115,
    SFE_IRCAM_UNKNOWN_FORMAT___41 = 116,
    SFE_W64_64_BIT___41 = 117,
    SFE_W64_NO_RIFF___41 = 118,
    SFE_W64_NO_WAVE___41 = 119,
    SFE_W64_NO_DATA___41 = 120,
    SFE_W64_ADPCM_NOT4BIT___41 = 121,
    SFE_W64_ADPCM_CHANNELS___41 = 122,
    SFE_W64_GSM610_FORMAT___41 = 123,
    SFE_MAT4_BAD_NAME___41 = 124,
    SFE_MAT4_NO_SAMPLERATE___41 = 125,
    SFE_MAT5_BAD_ENDIAN___41 = 126,
    SFE_MAT5_NO_BLOCK___41 = 127,
    SFE_MAT5_SAMPLE_RATE___41 = 128,
    SFE_PVF_NO_PVF1___41 = 129,
    SFE_PVF_BAD_HEADER___41 = 130,
    SFE_PVF_BAD_BITWIDTH___41 = 131,
    SFE_DWVW_BAD_BITWIDTH___41 = 132,
    SFE_G72X_NOT_MONO___41 = 133,
    SFE_XI_BAD_HEADER___41 = 134,
    SFE_XI_EXCESS_SAMPLES___41 = 135,
    SFE_XI_NO_PIPE___41 = 136,
    SFE_HTK_NO_PIPE___41 = 137,
    SFE_SDS_NOT_SDS___41 = 138,
    SFE_SDS_BAD_BIT_WIDTH___41 = 139,
    SFE_SD2_FD_DISALLOWED___41 = 140,
    SFE_SD2_BAD_DATA_OFFSET___41 = 141,
    SFE_SD2_BAD_MAP_OFFSET___41 = 142,
    SFE_SD2_BAD_DATA_LENGTH___41 = 143,
    SFE_SD2_BAD_MAP_LENGTH___41 = 144,
    SFE_SD2_BAD_RSRC___41 = 145,
    SFE_SD2_BAD_SAMPLE_SIZE___41 = 146,
    SFE_FLAC_BAD_HEADER___41 = 147,
    SFE_FLAC_NEW_DECODER___41 = 148,
    SFE_FLAC_INIT_DECODER___41 = 149,
    SFE_FLAC_LOST_SYNC___41 = 150,
    SFE_FLAC_BAD_SAMPLE_RATE___41 = 151,
    SFE_FLAC_UNKOWN_ERROR___41 = 152,
    SFE_WVE_NOT_WVE___41 = 153,
    SFE_WVE_NO_PIPE___41 = 154,
    SFE_VORBIS_ENCODER_BUG___41 = 155,
    SFE_RF64_NOT_RF64___41 = 156,
    SFE_MAX_ERROR___41 = 157
} ;
#line 823
enum __anonenum__554___5 {
    SFC_TEST_AIFF_ADD_INST_CHUNK___41 = 8192,
    SFC_TEST_WAV_ADD_INFO_CHUNK___41 = 8208
} ;
#line 53 "/root/libsndfile/src/ircam.c"
enum __anonenum__555___0 {
    IRCAM_PCM_16 = 2,
    IRCAM_FLOAT = 4,
    IRCAM_ALAW = 65537,
    IRCAM_ULAW = 131073,
    IRCAM_PCM_32 = 262148
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__510___9 {
    _ISupper___19 = 256,
    _ISlower___19 = 512,
    _ISalpha___19 = 1024,
    _ISdigit___19 = 2048,
    _ISxdigit___19 = 4096,
    _ISspace___19 = 8192,
    _ISprint___19 = 16384,
    _ISgraph___19 = 32768,
    _ISblank___19 = 1,
    _IScntrl___19 = 2,
    _ISpunct___19 = 4,
    _ISalnum___19 = 8
} ;
#line 46 "/root/libsndfile/src/sndfile.h"
enum __anonenum__524___6 {
    SF_FORMAT_WAV___42 = 65536,
    SF_FORMAT_AIFF___42 = 131072,
    SF_FORMAT_AU___42 = 196608,
    SF_FORMAT_RAW___42 = 262144,
    SF_FORMAT_PAF___42 = 327680,
    SF_FORMAT_SVX___42 = 393216,
    SF_FORMAT_NIST___42 = 458752,
    SF_FORMAT_VOC___42 = 524288,
    SF_FORMAT_IRCAM___42 = 655360,
    SF_FORMAT_W64___42 = 720896,
    SF_FORMAT_MAT4___42 = 786432,
    SF_FORMAT_MAT5___42 = 851968,
    SF_FORMAT_PVF___42 = 917504,
    SF_FORMAT_XI___42 = 983040,
    SF_FORMAT_HTK___42 = 1048576,
    SF_FORMAT_SDS___42 = 1114112,
    SF_FORMAT_AVR___42 = 1179648,
    SF_FORMAT_WAVEX___42 = 1245184,
    SF_FORMAT_SD2___42 = 1441792,
    SF_FORMAT_FLAC___42 = 1507328,
    SF_FORMAT_CAF___42 = 1572864,
    SF_FORMAT_WVE___42 = 1638400,
    SF_FORMAT_OGG___42 = 2097152,
    SF_FORMAT_MPC2K___42 = 2162688,
    SF_FORMAT_RF64___42 = 2228224,
    SF_FORMAT_PCM_S8___42 = 1,
    SF_FORMAT_PCM_16___42 = 2,
    SF_FORMAT_PCM_24___42 = 3,
    SF_FORMAT_PCM_32___42 = 4,
    SF_FORMAT_PCM_U8___42 = 5,
    SF_FORMAT_FLOAT___42 = 6,
    SF_FORMAT_DOUBLE___42 = 7,
    SF_FORMAT_ULAW___42 = 16,
    SF_FORMAT_ALAW___42 = 17,
    SF_FORMAT_IMA_ADPCM___42 = 18,
    SF_FORMAT_MS_ADPCM___42 = 19,
    SF_FORMAT_GSM610___42 = 32,
    SF_FORMAT_VOX_ADPCM___42 = 33,
    SF_FORMAT_G721_32___42 = 48,
    SF_FORMAT_G723_24___42 = 49,
    SF_FORMAT_G723_40___42 = 50,
    SF_FORMAT_DWVW_12___42 = 64,
    SF_FORMAT_DWVW_16___42 = 65,
    SF_FORMAT_DWVW_24___42 = 66,
    SF_FORMAT_DWVW_N___42 = 67,
    SF_FORMAT_DPCM_8___42 = 80,
    SF_FORMAT_DPCM_16___42 = 81,
    SF_FORMAT_VORBIS___42 = 96,
    SF_ENDIAN_FILE___42 = 0,
    SF_ENDIAN_LITTLE___42 = 268435456,
    SF_ENDIAN_BIG___42 = 536870912,
    SF_ENDIAN_CPU___42 = 805306368,
    SF_FORMAT_SUBMASK___42 = 65535,
    SF_FORMAT_TYPEMASK___42 = 268369920,
    SF_FORMAT_ENDMASK___42 = 805306368
} ;
#line 126
enum __anonenum__525___6 {
    SFC_GET_LIB_VERSION___42 = 4096,
    SFC_GET_LOG_INFO___42 = 4097,
    SFC_GET_CURRENT_SF_INFO___42 = 4098,
    SFC_GET_NORM_DOUBLE___42 = 4112,
    SFC_GET_NORM_FLOAT___42 = 4113,
    SFC_SET_NORM_DOUBLE___42 = 4114,
    SFC_SET_NORM_FLOAT___42 = 4115,
    SFC_SET_SCALE_FLOAT_INT_READ___42 = 4116,
    SFC_SET_SCALE_INT_FLOAT_WRITE___42 = 4117,
    SFC_GET_SIMPLE_FORMAT_COUNT___42 = 4128,
    SFC_GET_SIMPLE_FORMAT___42 = 4129,
    SFC_GET_FORMAT_INFO___42 = 4136,
    SFC_GET_FORMAT_MAJOR_COUNT___42 = 4144,
    SFC_GET_FORMAT_MAJOR___42 = 4145,
    SFC_GET_FORMAT_SUBTYPE_COUNT___42 = 4146,
    SFC_GET_FORMAT_SUBTYPE___42 = 4147,
    SFC_CALC_SIGNAL_MAX___42 = 4160,
    SFC_CALC_NORM_SIGNAL_MAX___42 = 4161,
    SFC_CALC_MAX_ALL_CHANNELS___42 = 4162,
    SFC_CALC_NORM_MAX_ALL_CHANNELS___42 = 4163,
    SFC_GET_SIGNAL_MAX___42 = 4164,
    SFC_GET_MAX_ALL_CHANNELS___42 = 4165,
    SFC_SET_ADD_PEAK_CHUNK___42 = 4176,
    SFC_SET_ADD_HEADER_PAD_CHUNK___42 = 4177,
    SFC_UPDATE_HEADER_NOW___42 = 4192,
    SFC_SET_UPDATE_HEADER_AUTO___42 = 4193,
    SFC_FILE_TRUNCATE___42 = 4224,
    SFC_SET_RAW_START_OFFSET___42 = 4240,
    SFC_SET_DITHER_ON_WRITE___42 = 4256,
    SFC_SET_DITHER_ON_READ___42 = 4257,
    SFC_GET_DITHER_INFO_COUNT___42 = 4258,
    SFC_GET_DITHER_INFO___42 = 4259,
    SFC_GET_EMBED_FILE_INFO___42 = 4272,
    SFC_SET_CLIPPING___42 = 4288,
    SFC_GET_CLIPPING___42 = 4289,
    SFC_GET_INSTRUMENT___42 = 4304,
    SFC_SET_INSTRUMENT___42 = 4305,
    SFC_GET_LOOP_INFO___42 = 4320,
    SFC_GET_BROADCAST_INFO___42 = 4336,
    SFC_SET_BROADCAST_INFO___42 = 4337,
    SFC_GET_CHANNEL_MAP_INFO___42 = 4352,
    SFC_SET_CHANNEL_MAP_INFO___42 = 4353,
    SFC_RAW_DATA_NEEDS_ENDSWAP___42 = 4368,
    SFC_WAVEX_SET_AMBISONIC___42 = 4608,
    SFC_WAVEX_GET_AMBISONIC___42 = 4609,
    SFC_SET_VBR_ENCODING_QUALITY___42 = 4864,
    SFC_TEST_IEEE_FLOAT_REPLACE___42 = 24577,
    SFC_SET_ADD_DITHER_ON_WRITE___42 = 4208,
    SFC_SET_ADD_DITHER_ON_READ___42 = 4209
} ;
#line 216
enum __anonenum__526___6 {
    SF_STR_TITLE___42 = 1,
    SF_STR_COPYRIGHT___42 = 2,
    SF_STR_SOFTWARE___42 = 3,
    SF_STR_ARTIST___42 = 4,
    SF_STR_COMMENT___42 = 5,
    SF_STR_DATE___42 = 6,
    SF_STR_ALBUM___42 = 7,
    SF_STR_LICENSE___42 = 8
} ;
#line 235
enum __anonenum__527___6 {
    SF_FALSE___42 = 0,
    SF_TRUE___42 = 1,
    SFM_READ___42 = 16,
    SFM_WRITE___42 = 32,
    SFM_RDWR___42 = 48,
    SF_AMBISONIC_NONE___42 = 64,
    SF_AMBISONIC_B_FORMAT___42 = 65
} ;
#line 255
enum __anonenum__528___6 {
    SF_ERR_NO_ERROR___42 = 0,
    SF_ERR_UNRECOGNISED_FORMAT___42 = 1,
    SF_ERR_SYSTEM___42 = 2,
    SF_ERR_MALFORMED_FILE___42 = 3,
    SF_ERR_UNSUPPORTED_ENCODING___42 = 4
} ;
#line 267
enum __anonenum__529___6 {
    SF_CHANNEL_MAP_INVALID___42 = 0,
    SF_CHANNEL_MAP_MONO___42 = 1,
    SF_CHANNEL_MAP_LEFT___42 = 2,
    SF_CHANNEL_MAP_RIGHT___42 = 3,
    SF_CHANNEL_MAP_CENTER___42 = 4,
    SF_CHANNEL_MAP_FRONT_LEFT___42 = 5,
    SF_CHANNEL_MAP_FRONT_RIGHT___42 = 6,
    SF_CHANNEL_MAP_FRONT_CENTER___42 = 7,
    SF_CHANNEL_MAP_REAR_CENTER___42 = 8,
    SF_CHANNEL_MAP_REAR_LEFT___42 = 9,
    SF_CHANNEL_MAP_REAR_RIGHT___42 = 10,
    SF_CHANNEL_MAP_LFE___42 = 11,
    SF_CHANNEL_MAP_FRONT_LEFT_OF_CENTER___42 = 12,
    SF_CHANNEL_MAP_FRONT_RIGHT_OF_CENTER___42 = 13,
    SF_CHANNEL_MAP_SIDE_LEFT___42 = 14,
    SF_CHANNEL_MAP_SIDE_RIGHT___42 = 15,
    SF_CHANNEL_MAP_TOP_CENTER___42 = 16,
    SF_CHANNEL_MAP_TOP_FRONT_LEFT___42 = 17,
    SF_CHANNEL_MAP_TOP_FRONT_RIGHT___42 = 18,
    SF_CHANNEL_MAP_TOP_FRONT_CENTER___42 = 19,
    SF_CHANNEL_MAP_TOP_REAR_LEFT___42 = 20,
    SF_CHANNEL_MAP_TOP_REAR_RIGHT___42 = 21,
    SF_CHANNEL_MAP_TOP_REAR_CENTER___42 = 22
} ;
#line 352
enum __anonenum__531___6 {
    SFD_DEFAULT_LEVEL___42 = 0,
    SFD_CUSTOM_LEVEL___42 = 1073741824,
    SFD_NO_DITHER___42 = 500,
    SFD_WHITE___42 = 501,
    SFD_TRIANGULAR_PDF___42 = 502
} ;
#line 380
enum __anonenum__534___6 {
    SF_LOOP_NONE___42 = 800,
    SF_LOOP_FORWARD___42 = 801,
    SF_LOOP_BACKWARD___42 = 802,
    SF_LOOP_ALTERNATING___42 = 803
} ;
#line 121 "/root/libsndfile/src/common.h"
enum __anonenum__543___6 {
    SF_PEAK_START___42 = 42,
    SF_PEAK_END___42 = 43,
    SF_SCALE_MAX___42 = 52,
    SF_SCALE_MIN___42 = 53,
    SF_STR_ALLOW_START___42 = 256,
    SF_STR_ALLOW_END___42 = 512,
    SF_STR_LOCATE_START___42 = 1024,
    SF_STR_LOCATE_END___42 = 2048,
    SFD_TYPEMASK___42 = 268435455
} ;
#line 149
enum __anonenum__544___6 {
    SF_FORMAT_TXW___42 = 67305472,
    SF_FORMAT_DWD___42 = 67371008,
    SF_FORMAT_REX___42 = 67764224,
    SF_FORMAT_REX2___42 = 67960832,
    SF_FORMAT_KRZ___42 = 68026368,
    SF_FORMAT_WMA___42 = 68157440,
    SF_FORMAT_SHN___42 = 68222976,
    SF_FORMAT_SVX_FIB___42 = 4128,
    SF_FORMAT_SVX_EXP___42 = 4129,
    SF_FORMAT_PCM_N___42 = 4144
} ;
#line 405
enum __anonenum__550___6 {
    SFE_NO_ERROR___42 = 0,
    SFE_BAD_OPEN_FORMAT___42 = 1,
    SFE_SYSTEM___42 = 2,
    SFE_MALFORMED_FILE___42 = 3,
    SFE_UNSUPPORTED_ENCODING___42 = 4,
    SFE_ZERO_MAJOR_FORMAT___42 = 5,
    SFE_ZERO_MINOR_FORMAT___42 = 6,
    SFE_BAD_FILE___42 = 7,
    SFE_BAD_FILE_READ___42 = 8,
    SFE_OPEN_FAILED___42 = 9,
    SFE_BAD_SNDFILE_PTR___42 = 10,
    SFE_BAD_SF_INFO_PTR___42 = 11,
    SFE_BAD_SF_INCOMPLETE___42 = 12,
    SFE_BAD_FILE_PTR___42 = 13,
    SFE_BAD_INT_PTR___42 = 14,
    SFE_BAD_STAT_SIZE___42 = 15,
    SFE_MALLOC_FAILED___42 = 16,
    SFE_UNIMPLEMENTED___42 = 17,
    SFE_BAD_READ_ALIGN___42 = 18,
    SFE_BAD_WRITE_ALIGN___42 = 19,
    SFE_UNKNOWN_FORMAT___42 = 20,
    SFE_NOT_READMODE___42 = 21,
    SFE_NOT_WRITEMODE___42 = 22,
    SFE_BAD_MODE_RW___42 = 23,
    SFE_BAD_SF_INFO___42 = 24,
    SFE_BAD_OFFSET___42 = 25,
    SFE_NO_EMBED_SUPPORT___42 = 26,
    SFE_NO_EMBEDDED_RDWR___42 = 27,
    SFE_NO_PIPE_WRITE___42 = 28,
    SFE_INTERNAL___42 = 29,
    SFE_BAD_COMMAND_PARAM___42 = 30,
    SFE_BAD_ENDIAN___42 = 31,
    SFE_CHANNEL_COUNT_ZERO___42 = 32,
    SFE_CHANNEL_COUNT___42 = 33,
    SFE_BAD_VIRTUAL_IO___42 = 34,
    SFE_INTERLEAVE_MODE___42 = 35,
    SFE_INTERLEAVE_SEEK___42 = 36,
    SFE_INTERLEAVE_READ___42 = 37,
    SFE_BAD_SEEK___42 = 38,
    SFE_NOT_SEEKABLE___42 = 39,
    SFE_AMBIGUOUS_SEEK___42 = 40,
    SFE_WRONG_SEEK___42 = 41,
    SFE_SEEK_FAILED___42 = 42,
    SFE_BAD_OPEN_MODE___42 = 43,
    SFE_OPEN_PIPE_RDWR___42 = 44,
    SFE_RDWR_POSITION___42 = 45,
    SFE_RDWR_BAD_HEADER___42 = 46,
    SFE_CMD_HAS_DATA___42 = 47,
    SFE_BAD_BROADCAST_INFO_SIZE___42 = 48,
    SFE_STR_NO_SUPPORT___42 = 49,
    SFE_STR_NOT_WRITE___42 = 50,
    SFE_STR_MAX_DATA___42 = 51,
    SFE_STR_MAX_COUNT___42 = 52,
    SFE_STR_BAD_TYPE___42 = 53,
    SFE_STR_NO_ADD_END___42 = 54,
    SFE_STR_BAD_STRING___42 = 55,
    SFE_STR_WEIRD___42 = 56,
    SFE_WAV_NO_RIFF___42 = 57,
    SFE_WAV_NO_WAVE___42 = 58,
    SFE_WAV_NO_FMT___42 = 59,
    SFE_WAV_BAD_FMT___42 = 60,
    SFE_WAV_FMT_SHORT___42 = 61,
    SFE_WAV_BAD_FACT___42 = 62,
    SFE_WAV_BAD_PEAK___42 = 63,
    SFE_WAV_PEAK_B4_FMT___42 = 64,
    SFE_WAV_BAD_FORMAT___42 = 65,
    SFE_WAV_BAD_BLOCKALIGN___42 = 66,
    SFE_WAV_NO_DATA___42 = 67,
    SFE_WAV_BAD_LIST___42 = 68,
    SFE_WAV_ADPCM_NOT4BIT___42 = 69,
    SFE_WAV_ADPCM_CHANNELS___42 = 70,
    SFE_WAV_GSM610_FORMAT___42 = 71,
    SFE_WAV_UNKNOWN_CHUNK___42 = 72,
    SFE_WAV_WVPK_DATA___42 = 73,
    SFE_AIFF_NO_FORM___42 = 74,
    SFE_AIFF_AIFF_NO_FORM___42 = 75,
    SFE_AIFF_COMM_NO_FORM___42 = 76,
    SFE_AIFF_SSND_NO_COMM___42 = 77,
    SFE_AIFF_UNKNOWN_CHUNK___42 = 78,
    SFE_AIFF_COMM_CHUNK_SIZE___42 = 79,
    SFE_AIFF_BAD_COMM_CHUNK___42 = 80,
    SFE_AIFF_PEAK_B4_COMM___42 = 81,
    SFE_AIFF_BAD_PEAK___42 = 82,
    SFE_AIFF_NO_SSND___42 = 83,
    SFE_AIFF_NO_DATA___42 = 84,
    SFE_AIFF_RW_SSND_NOT_LAST___42 = 85,
    SFE_AU_UNKNOWN_FORMAT___42 = 86,
    SFE_AU_NO_DOTSND___42 = 87,
    SFE_AU_EMBED_BAD_LEN___42 = 88,
    SFE_RAW_READ_BAD_SPEC___42 = 89,
    SFE_RAW_BAD_BITWIDTH___42 = 90,
    SFE_RAW_BAD_FORMAT___42 = 91,
    SFE_PAF_NO_MARKER___42 = 92,
    SFE_PAF_VERSION___42 = 93,
    SFE_PAF_UNKNOWN_FORMAT___42 = 94,
    SFE_PAF_SHORT_HEADER___42 = 95,
    SFE_SVX_NO_FORM___42 = 96,
    SFE_SVX_NO_BODY___42 = 97,
    SFE_SVX_NO_DATA___42 = 98,
    SFE_SVX_BAD_COMP___42 = 99,
    SFE_SVX_BAD_NAME_LENGTH___42 = 100,
    SFE_NIST_BAD_HEADER___42 = 101,
    SFE_NIST_CRLF_CONVERISON___42 = 102,
    SFE_NIST_BAD_ENCODING___42 = 103,
    SFE_VOC_NO_CREATIVE___42 = 104,
    SFE_VOC_BAD_FORMAT___42 = 105,
    SFE_VOC_BAD_VERSION___42 = 106,
    SFE_VOC_BAD_MARKER___42 = 107,
    SFE_VOC_BAD_SECTIONS___42 = 108,
    SFE_VOC_MULTI_SAMPLERATE___42 = 109,
    SFE_VOC_MULTI_SECTION___42 = 110,
    SFE_VOC_MULTI_PARAM___42 = 111,
    SFE_VOC_SECTION_COUNT___42 = 112,
    SFE_VOC_NO_PIPE___42 = 113,
    SFE_IRCAM_NO_MARKER___42 = 114,
    SFE_IRCAM_BAD_CHANNELS___42 = 115,
    SFE_IRCAM_UNKNOWN_FORMAT___42 = 116,
    SFE_W64_64_BIT___42 = 117,
    SFE_W64_NO_RIFF___42 = 118,
    SFE_W64_NO_WAVE___42 = 119,
    SFE_W64_NO_DATA___42 = 120,
    SFE_W64_ADPCM_NOT4BIT___42 = 121,
    SFE_W64_ADPCM_CHANNELS___42 = 122,
    SFE_W64_GSM610_FORMAT___42 = 123,
    SFE_MAT4_BAD_NAME___42 = 124,
    SFE_MAT4_NO_SAMPLERATE___42 = 125,
    SFE_MAT5_BAD_ENDIAN___42 = 126,
    SFE_MAT5_NO_BLOCK___42 = 127,
    SFE_MAT5_SAMPLE_RATE___42 = 128,
    SFE_PVF_NO_PVF1___42 = 129,
    SFE_PVF_BAD_HEADER___42 = 130,
    SFE_PVF_BAD_BITWIDTH___42 = 131,
    SFE_DWVW_BAD_BITWIDTH___42 = 132,
    SFE_G72X_NOT_MONO___42 = 133,
    SFE_XI_BAD_HEADER___42 = 134,
    SFE_XI_EXCESS_SAMPLES___42 = 135,
    SFE_XI_NO_PIPE___42 = 136,
    SFE_HTK_NO_PIPE___42 = 137,
    SFE_SDS_NOT_SDS___42 = 138,
    SFE_SDS_BAD_BIT_WIDTH___42 = 139,
    SFE_SD2_FD_DISALLOWED___42 = 140,
    SFE_SD2_BAD_DATA_OFFSET___42 = 141,
    SFE_SD2_BAD_MAP_OFFSET___42 = 142,
    SFE_SD2_BAD_DATA_LENGTH___42 = 143,
    SFE_SD2_BAD_MAP_LENGTH___42 = 144,
    SFE_SD2_BAD_RSRC___42 = 145,
    SFE_SD2_BAD_SAMPLE_SIZE___42 = 146,
    SFE_FLAC_BAD_HEADER___42 = 147,
    SFE_FLAC_NEW_DECODER___42 = 148,
    SFE_FLAC_INIT_DECODER___42 = 149,
    SFE_FLAC_LOST_SYNC___42 = 150,
    SFE_FLAC_BAD_SAMPLE_RATE___42 = 151,
    SFE_FLAC_UNKOWN_ERROR___42 = 152,
    SFE_WVE_NOT_WVE___42 = 153,
    SFE_WVE_NO_PIPE___42 = 154,
    SFE_VORBIS_ENCODER_BUG___42 = 155,
    SFE_RF64_NOT_RF64___42 = 156,
    SFE_MAX_ERROR___42 = 157
} ;
#line 823
enum __anonenum__554___6 {
    SFC_TEST_AIFF_ADD_INST_CHUNK___42 = 8192,
    SFC_TEST_WAV_ADD_INFO_CHUNK___42 = 8208
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__43___6 {
    FP_NAN___18 = 0,
    FP_INFINITE___18 = 1,
    FP_ZERO___18 = 2,
    FP_SUBNORMAL___18 = 3,
    FP_NORMAL___18 = 4
} ;
#line 46 "/root/libsndfile/src/sndfile.h"
enum __anonenum__44___6 {
    SF_FORMAT_WAV___43 = 65536,
    SF_FORMAT_AIFF___43 = 131072,
    SF_FORMAT_AU___43 = 196608,
    SF_FORMAT_RAW___43 = 262144,
    SF_FORMAT_PAF___43 = 327680,
    SF_FORMAT_SVX___43 = 393216,
    SF_FORMAT_NIST___43 = 458752,
    SF_FORMAT_VOC___43 = 524288,
    SF_FORMAT_IRCAM___43 = 655360,
    SF_FORMAT_W64___43 = 720896,
    SF_FORMAT_MAT4___43 = 786432,
    SF_FORMAT_MAT5___43 = 851968,
    SF_FORMAT_PVF___43 = 917504,
    SF_FORMAT_XI___43 = 983040,
    SF_FORMAT_HTK___43 = 1048576,
    SF_FORMAT_SDS___43 = 1114112,
    SF_FORMAT_AVR___43 = 1179648,
    SF_FORMAT_WAVEX___43 = 1245184,
    SF_FORMAT_SD2___43 = 1441792,
    SF_FORMAT_FLAC___43 = 1507328,
    SF_FORMAT_CAF___43 = 1572864,
    SF_FORMAT_WVE___43 = 1638400,
    SF_FORMAT_OGG___43 = 2097152,
    SF_FORMAT_MPC2K___43 = 2162688,
    SF_FORMAT_RF64___43 = 2228224,
    SF_FORMAT_PCM_S8___43 = 1,
    SF_FORMAT_PCM_16___43 = 2,
    SF_FORMAT_PCM_24___43 = 3,
    SF_FORMAT_PCM_32___43 = 4,
    SF_FORMAT_PCM_U8___43 = 5,
    SF_FORMAT_FLOAT___43 = 6,
    SF_FORMAT_DOUBLE___43 = 7,
    SF_FORMAT_ULAW___43 = 16,
    SF_FORMAT_ALAW___43 = 17,
    SF_FORMAT_IMA_ADPCM___43 = 18,
    SF_FORMAT_MS_ADPCM___43 = 19,
    SF_FORMAT_GSM610___43 = 32,
    SF_FORMAT_VOX_ADPCM___43 = 33,
    SF_FORMAT_G721_32___43 = 48,
    SF_FORMAT_G723_24___43 = 49,
    SF_FORMAT_G723_40___43 = 50,
    SF_FORMAT_DWVW_12___43 = 64,
    SF_FORMAT_DWVW_16___43 = 65,
    SF_FORMAT_DWVW_24___43 = 66,
    SF_FORMAT_DWVW_N___43 = 67,
    SF_FORMAT_DPCM_8___43 = 80,
    SF_FORMAT_DPCM_16___43 = 81,
    SF_FORMAT_VORBIS___43 = 96,
    SF_ENDIAN_FILE___43 = 0,
    SF_ENDIAN_LITTLE___43 = 268435456,
    SF_ENDIAN_BIG___43 = 536870912,
    SF_ENDIAN_CPU___43 = 805306368,
    SF_FORMAT_SUBMASK___43 = 65535,
    SF_FORMAT_TYPEMASK___43 = 268369920,
    SF_FORMAT_ENDMASK___43 = 805306368
} ;
#line 126
enum __anonenum__45___6 {
    SFC_GET_LIB_VERSION___43 = 4096,
    SFC_GET_LOG_INFO___43 = 4097,
    SFC_GET_CURRENT_SF_INFO___43 = 4098,
    SFC_GET_NORM_DOUBLE___43 = 4112,
    SFC_GET_NORM_FLOAT___43 = 4113,
    SFC_SET_NORM_DOUBLE___43 = 4114,
    SFC_SET_NORM_FLOAT___43 = 4115,
    SFC_SET_SCALE_FLOAT_INT_READ___43 = 4116,
    SFC_SET_SCALE_INT_FLOAT_WRITE___43 = 4117,
    SFC_GET_SIMPLE_FORMAT_COUNT___43 = 4128,
    SFC_GET_SIMPLE_FORMAT___43 = 4129,
    SFC_GET_FORMAT_INFO___43 = 4136,
    SFC_GET_FORMAT_MAJOR_COUNT___43 = 4144,
    SFC_GET_FORMAT_MAJOR___43 = 4145,
    SFC_GET_FORMAT_SUBTYPE_COUNT___43 = 4146,
    SFC_GET_FORMAT_SUBTYPE___43 = 4147,
    SFC_CALC_SIGNAL_MAX___43 = 4160,
    SFC_CALC_NORM_SIGNAL_MAX___43 = 4161,
    SFC_CALC_MAX_ALL_CHANNELS___43 = 4162,
    SFC_CALC_NORM_MAX_ALL_CHANNELS___43 = 4163,
    SFC_GET_SIGNAL_MAX___43 = 4164,
    SFC_GET_MAX_ALL_CHANNELS___43 = 4165,
    SFC_SET_ADD_PEAK_CHUNK___43 = 4176,
    SFC_SET_ADD_HEADER_PAD_CHUNK___43 = 4177,
    SFC_UPDATE_HEADER_NOW___43 = 4192,
    SFC_SET_UPDATE_HEADER_AUTO___43 = 4193,
    SFC_FILE_TRUNCATE___43 = 4224,
    SFC_SET_RAW_START_OFFSET___43 = 4240,
    SFC_SET_DITHER_ON_WRITE___43 = 4256,
    SFC_SET_DITHER_ON_READ___43 = 4257,
    SFC_GET_DITHER_INFO_COUNT___43 = 4258,
    SFC_GET_DITHER_INFO___43 = 4259,
    SFC_GET_EMBED_FILE_INFO___43 = 4272,
    SFC_SET_CLIPPING___43 = 4288,
    SFC_GET_CLIPPING___43 = 4289,
    SFC_GET_INSTRUMENT___43 = 4304,
    SFC_SET_INSTRUMENT___43 = 4305,
    SFC_GET_LOOP_INFO___43 = 4320,
    SFC_GET_BROADCAST_INFO___43 = 4336,
    SFC_SET_BROADCAST_INFO___43 = 4337,
    SFC_GET_CHANNEL_MAP_INFO___43 = 4352,
    SFC_SET_CHANNEL_MAP_INFO___43 = 4353,
    SFC_RAW_DATA_NEEDS_ENDSWAP___43 = 4368,
    SFC_WAVEX_SET_AMBISONIC___43 = 4608,
    SFC_WAVEX_GET_AMBISONIC___43 = 4609,
    SFC_SET_VBR_ENCODING_QUALITY___43 = 4864,
    SFC_TEST_IEEE_FLOAT_REPLACE___43 = 24577,
    SFC_SET_ADD_DITHER_ON_WRITE___43 = 4208,
    SFC_SET_ADD_DITHER_ON_READ___43 = 4209
} ;
#line 216
enum __anonenum__46___6 {
    SF_STR_TITLE___43 = 1,
    SF_STR_COPYRIGHT___43 = 2,
    SF_STR_SOFTWARE___43 = 3,
    SF_STR_ARTIST___43 = 4,
    SF_STR_COMMENT___43 = 5,
    SF_STR_DATE___43 = 6,
    SF_STR_ALBUM___43 = 7,
    SF_STR_LICENSE___43 = 8
} ;
#line 235
enum __anonenum__47___6 {
    SF_FALSE___43 = 0,
    SF_TRUE___43 = 1,
    SFM_READ___43 = 16,
    SFM_WRITE___43 = 32,
    SFM_RDWR___43 = 48,
    SF_AMBISONIC_NONE___43 = 64,
    SF_AMBISONIC_B_FORMAT___43 = 65
} ;
#line 255
enum __anonenum__48___6 {
    SF_ERR_NO_ERROR___43 = 0,
    SF_ERR_UNRECOGNISED_FORMAT___43 = 1,
    SF_ERR_SYSTEM___43 = 2,
    SF_ERR_MALFORMED_FILE___43 = 3,
    SF_ERR_UNSUPPORTED_ENCODING___43 = 4
} ;
#line 267
enum __anonenum__49___6 {
    SF_CHANNEL_MAP_INVALID___43 = 0,
    SF_CHANNEL_MAP_MONO___43 = 1,
    SF_CHANNEL_MAP_LEFT___43 = 2,
    SF_CHANNEL_MAP_RIGHT___43 = 3,
    SF_CHANNEL_MAP_CENTER___43 = 4,
    SF_CHANNEL_MAP_FRONT_LEFT___43 = 5,
    SF_CHANNEL_MAP_FRONT_RIGHT___43 = 6,
    SF_CHANNEL_MAP_FRONT_CENTER___43 = 7,
    SF_CHANNEL_MAP_REAR_CENTER___43 = 8,
    SF_CHANNEL_MAP_REAR_LEFT___43 = 9,
    SF_CHANNEL_MAP_REAR_RIGHT___43 = 10,
    SF_CHANNEL_MAP_LFE___43 = 11,
    SF_CHANNEL_MAP_FRONT_LEFT_OF_CENTER___43 = 12,
    SF_CHANNEL_MAP_FRONT_RIGHT_OF_CENTER___43 = 13,
    SF_CHANNEL_MAP_SIDE_LEFT___43 = 14,
    SF_CHANNEL_MAP_SIDE_RIGHT___43 = 15,
    SF_CHANNEL_MAP_TOP_CENTER___43 = 16,
    SF_CHANNEL_MAP_TOP_FRONT_LEFT___43 = 17,
    SF_CHANNEL_MAP_TOP_FRONT_RIGHT___43 = 18,
    SF_CHANNEL_MAP_TOP_FRONT_CENTER___43 = 19,
    SF_CHANNEL_MAP_TOP_REAR_LEFT___43 = 20,
    SF_CHANNEL_MAP_TOP_REAR_RIGHT___43 = 21,
    SF_CHANNEL_MAP_TOP_REAR_CENTER___43 = 22
} ;
#line 352
enum __anonenum__51___6 {
    SFD_DEFAULT_LEVEL___43 = 0,
    SFD_CUSTOM_LEVEL___43 = 1073741824,
    SFD_NO_DITHER___43 = 500,
    SFD_WHITE___43 = 501,
    SFD_TRIANGULAR_PDF___43 = 502
} ;
#line 380
enum __anonenum__54___6 {
    SF_LOOP_NONE___43 = 800,
    SF_LOOP_FORWARD___43 = 801,
    SF_LOOP_BACKWARD___43 = 802,
    SF_LOOP_ALTERNATING___43 = 803
} ;
#line 121 "/root/libsndfile/src/common.h"
enum __anonenum__59___6 {
    SF_PEAK_START___43 = 42,
    SF_PEAK_END___43 = 43,
    SF_SCALE_MAX___43 = 52,
    SF_SCALE_MIN___43 = 53,
    SF_STR_ALLOW_START___43 = 256,
    SF_STR_ALLOW_END___43 = 512,
    SF_STR_LOCATE_START___43 = 1024,
    SF_STR_LOCATE_END___43 = 2048,
    SFD_TYPEMASK___43 = 268435455
} ;
#line 149
enum __anonenum__60___6 {
    SF_FORMAT_TXW___43 = 67305472,
    SF_FORMAT_DWD___43 = 67371008,
    SF_FORMAT_REX___43 = 67764224,
    SF_FORMAT_REX2___43 = 67960832,
    SF_FORMAT_KRZ___43 = 68026368,
    SF_FORMAT_WMA___43 = 68157440,
    SF_FORMAT_SHN___43 = 68222976,
    SF_FORMAT_SVX_FIB___43 = 4128,
    SF_FORMAT_SVX_EXP___43 = 4129,
    SF_FORMAT_PCM_N___43 = 4144
} ;
#line 405
enum __anonenum__66___6 {
    SFE_NO_ERROR___43 = 0,
    SFE_BAD_OPEN_FORMAT___43 = 1,
    SFE_SYSTEM___43 = 2,
    SFE_MALFORMED_FILE___43 = 3,
    SFE_UNSUPPORTED_ENCODING___43 = 4,
    SFE_ZERO_MAJOR_FORMAT___43 = 5,
    SFE_ZERO_MINOR_FORMAT___43 = 6,
    SFE_BAD_FILE___43 = 7,
    SFE_BAD_FILE_READ___43 = 8,
    SFE_OPEN_FAILED___43 = 9,
    SFE_BAD_SNDFILE_PTR___43 = 10,
    SFE_BAD_SF_INFO_PTR___43 = 11,
    SFE_BAD_SF_INCOMPLETE___43 = 12,
    SFE_BAD_FILE_PTR___43 = 13,
    SFE_BAD_INT_PTR___43 = 14,
    SFE_BAD_STAT_SIZE___43 = 15,
    SFE_MALLOC_FAILED___43 = 16,
    SFE_UNIMPLEMENTED___43 = 17,
    SFE_BAD_READ_ALIGN___43 = 18,
    SFE_BAD_WRITE_ALIGN___43 = 19,
    SFE_UNKNOWN_FORMAT___43 = 20,
    SFE_NOT_READMODE___43 = 21,
    SFE_NOT_WRITEMODE___43 = 22,
    SFE_BAD_MODE_RW___43 = 23,
    SFE_BAD_SF_INFO___43 = 24,
    SFE_BAD_OFFSET___43 = 25,
    SFE_NO_EMBED_SUPPORT___43 = 26,
    SFE_NO_EMBEDDED_RDWR___43 = 27,
    SFE_NO_PIPE_WRITE___43 = 28,
    SFE_INTERNAL___43 = 29,
    SFE_BAD_COMMAND_PARAM___43 = 30,
    SFE_BAD_ENDIAN___43 = 31,
    SFE_CHANNEL_COUNT_ZERO___43 = 32,
    SFE_CHANNEL_COUNT___43 = 33,
    SFE_BAD_VIRTUAL_IO___43 = 34,
    SFE_INTERLEAVE_MODE___43 = 35,
    SFE_INTERLEAVE_SEEK___43 = 36,
    SFE_INTERLEAVE_READ___43 = 37,
    SFE_BAD_SEEK___43 = 38,
    SFE_NOT_SEEKABLE___43 = 39,
    SFE_AMBIGUOUS_SEEK___43 = 40,
    SFE_WRONG_SEEK___43 = 41,
    SFE_SEEK_FAILED___43 = 42,
    SFE_BAD_OPEN_MODE___43 = 43,
    SFE_OPEN_PIPE_RDWR___43 = 44,
    SFE_RDWR_POSITION___43 = 45,
    SFE_RDWR_BAD_HEADER___43 = 46,
    SFE_CMD_HAS_DATA___43 = 47,
    SFE_BAD_BROADCAST_INFO_SIZE___43 = 48,
    SFE_STR_NO_SUPPORT___43 = 49,
    SFE_STR_NOT_WRITE___43 = 50,
    SFE_STR_MAX_DATA___43 = 51,
    SFE_STR_MAX_COUNT___43 = 52,
    SFE_STR_BAD_TYPE___43 = 53,
    SFE_STR_NO_ADD_END___43 = 54,
    SFE_STR_BAD_STRING___43 = 55,
    SFE_STR_WEIRD___43 = 56,
    SFE_WAV_NO_RIFF___43 = 57,
    SFE_WAV_NO_WAVE___43 = 58,
    SFE_WAV_NO_FMT___43 = 59,
    SFE_WAV_BAD_FMT___43 = 60,
    SFE_WAV_FMT_SHORT___43 = 61,
    SFE_WAV_BAD_FACT___43 = 62,
    SFE_WAV_BAD_PEAK___43 = 63,
    SFE_WAV_PEAK_B4_FMT___43 = 64,
    SFE_WAV_BAD_FORMAT___43 = 65,
    SFE_WAV_BAD_BLOCKALIGN___43 = 66,
    SFE_WAV_NO_DATA___43 = 67,
    SFE_WAV_BAD_LIST___43 = 68,
    SFE_WAV_ADPCM_NOT4BIT___43 = 69,
    SFE_WAV_ADPCM_CHANNELS___43 = 70,
    SFE_WAV_GSM610_FORMAT___43 = 71,
    SFE_WAV_UNKNOWN_CHUNK___43 = 72,
    SFE_WAV_WVPK_DATA___43 = 73,
    SFE_AIFF_NO_FORM___43 = 74,
    SFE_AIFF_AIFF_NO_FORM___43 = 75,
    SFE_AIFF_COMM_NO_FORM___43 = 76,
    SFE_AIFF_SSND_NO_COMM___43 = 77,
    SFE_AIFF_UNKNOWN_CHUNK___43 = 78,
    SFE_AIFF_COMM_CHUNK_SIZE___43 = 79,
    SFE_AIFF_BAD_COMM_CHUNK___43 = 80,
    SFE_AIFF_PEAK_B4_COMM___43 = 81,
    SFE_AIFF_BAD_PEAK___43 = 82,
    SFE_AIFF_NO_SSND___43 = 83,
    SFE_AIFF_NO_DATA___43 = 84,
    SFE_AIFF_RW_SSND_NOT_LAST___43 = 85,
    SFE_AU_UNKNOWN_FORMAT___43 = 86,
    SFE_AU_NO_DOTSND___43 = 87,
    SFE_AU_EMBED_BAD_LEN___43 = 88,
    SFE_RAW_READ_BAD_SPEC___43 = 89,
    SFE_RAW_BAD_BITWIDTH___43 = 90,
    SFE_RAW_BAD_FORMAT___43 = 91,
    SFE_PAF_NO_MARKER___43 = 92,
    SFE_PAF_VERSION___43 = 93,
    SFE_PAF_UNKNOWN_FORMAT___43 = 94,
    SFE_PAF_SHORT_HEADER___43 = 95,
    SFE_SVX_NO_FORM___43 = 96,
    SFE_SVX_NO_BODY___43 = 97,
    SFE_SVX_NO_DATA___43 = 98,
    SFE_SVX_BAD_COMP___43 = 99,
    SFE_SVX_BAD_NAME_LENGTH___43 = 100,
    SFE_NIST_BAD_HEADER___43 = 101,
    SFE_NIST_CRLF_CONVERISON___43 = 102,
    SFE_NIST_BAD_ENCODING___43 = 103,
    SFE_VOC_NO_CREATIVE___43 = 104,
    SFE_VOC_BAD_FORMAT___43 = 105,
    SFE_VOC_BAD_VERSION___43 = 106,
    SFE_VOC_BAD_MARKER___43 = 107,
    SFE_VOC_BAD_SECTIONS___43 = 108,
    SFE_VOC_MULTI_SAMPLERATE___43 = 109,
    SFE_VOC_MULTI_SECTION___43 = 110,
    SFE_VOC_MULTI_PARAM___43 = 111,
    SFE_VOC_SECTION_COUNT___43 = 112,
    SFE_VOC_NO_PIPE___43 = 113,
    SFE_IRCAM_NO_MARKER___43 = 114,
    SFE_IRCAM_BAD_CHANNELS___43 = 115,
    SFE_IRCAM_UNKNOWN_FORMAT___43 = 116,
    SFE_W64_64_BIT___43 = 117,
    SFE_W64_NO_RIFF___43 = 118,
    SFE_W64_NO_WAVE___43 = 119,
    SFE_W64_NO_DATA___43 = 120,
    SFE_W64_ADPCM_NOT4BIT___43 = 121,
    SFE_W64_ADPCM_CHANNELS___43 = 122,
    SFE_W64_GSM610_FORMAT___43 = 123,
    SFE_MAT4_BAD_NAME___43 = 124,
    SFE_MAT4_NO_SAMPLERATE___43 = 125,
    SFE_MAT5_BAD_ENDIAN___43 = 126,
    SFE_MAT5_NO_BLOCK___43 = 127,
    SFE_MAT5_SAMPLE_RATE___43 = 128,
    SFE_PVF_NO_PVF1___43 = 129,
    SFE_PVF_BAD_HEADER___43 = 130,
    SFE_PVF_BAD_BITWIDTH___43 = 131,
    SFE_DWVW_BAD_BITWIDTH___43 = 132,
    SFE_G72X_NOT_MONO___43 = 133,
    SFE_XI_BAD_HEADER___43 = 134,
    SFE_XI_EXCESS_SAMPLES___43 = 135,
    SFE_XI_NO_PIPE___43 = 136,
    SFE_HTK_NO_PIPE___43 = 137,
    SFE_SDS_NOT_SDS___43 = 138,
    SFE_SDS_BAD_BIT_WIDTH___43 = 139,
    SFE_SD2_FD_DISALLOWED___43 = 140,
    SFE_SD2_BAD_DATA_OFFSET___43 = 141,
    SFE_SD2_BAD_MAP_OFFSET___43 = 142,
    SFE_SD2_BAD_DATA_LENGTH___43 = 143,
    SFE_SD2_BAD_MAP_LENGTH___43 = 144,
    SFE_SD2_BAD_RSRC___43 = 145,
    SFE_SD2_BAD_SAMPLE_SIZE___43 = 146,
    SFE_FLAC_BAD_HEADER___43 = 147,
    SFE_FLAC_NEW_DECODER___43 = 148,
    SFE_FLAC_INIT_DECODER___43 = 149,
    SFE_FLAC_LOST_SYNC___43 = 150,
    SFE_FLAC_BAD_SAMPLE_RATE___43 = 151,
    SFE_FLAC_UNKOWN_ERROR___43 = 152,
    SFE_WVE_NOT_WVE___43 = 153,
    SFE_WVE_NO_PIPE___43 = 154,
    SFE_VORBIS_ENCODER_BUG___43 = 155,
    SFE_RF64_NOT_RF64___43 = 156,
    SFE_MAX_ERROR___43 = 157
} ;
#line 823
enum __anonenum__70___6 {
    SFC_TEST_AIFF_ADD_INST_CHUNK___43 = 8192,
    SFC_TEST_WAV_ADD_INFO_CHUNK___43 = 8208
} ;
#line 39 "/root/libsndfile/src/G72x/g72x.h"
enum __anonstruct_71___3 {
    G723_16_BITS_PER_SAMPLE = 2,
    G723_24_BITS_PER_SAMPLE = 3,
    G723_40_BITS_PER_SAMPLE = 5,
    G721_32_BITS_PER_SAMPLE = 4,
    G721_40_BITS_PER_SAMPLE = 5,
    G723_16_SAMPLES_PER_BLOCK = 120,
    G723_24_SAMPLES_PER_BLOCK = 120,
    G723_40_SAMPLES_PER_BLOCK = 120,
    G721_32_SAMPLES_PER_BLOCK = 120,
    G721_40_SAMPLES_PER_BLOCK = 120,
    G723_16_BYTES_PER_BLOCK = 30,
    G723_24_BYTES_PER_BLOCK = 45,
    G723_40_BYTES_PER_BLOCK = 75,
    G721_32_BYTES_PER_BLOCK = 60,
    G721_40_BYTES_PER_BLOCK = 75
} ;
#line 64
struct g72x_state ;
#line 33 "/root/libsndfile/src/g72x.c"
typedef struct g72x_state G72x_STATE;
#line 35 "/root/libsndfile/src/g72x.c"
struct __anonstruct_989 {
   struct g72x_state *private ;
   int blocksize ;
   int samplesperblock ;
   int bytesperblock ;
   int blocks_total ;
   int block_curr ;
   int sample_curr ;
   unsigned char block[120] ;
   short samples[120] ;
};
#line 46 "/root/libsndfile/src/g72x.c"
typedef struct __anonstruct_989 G72x_PRIVATE;
#line 46 "/usr/include/ctype.h"
enum __anonenum__568___2 {
    _ISupper___20 = 256,
    _ISlower___20 = 512,
    _ISalpha___20 = 1024,
    _ISdigit___20 = 2048,
    _ISxdigit___20 = 4096,
    _ISspace___20 = 8192,
    _ISprint___20 = 16384,
    _ISgraph___20 = 32768,
    _ISblank___20 = 1,
    _IScntrl___20 = 2,
    _ISpunct___20 = 4,
    _ISalnum___20 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__569___2 {
    FP_NAN___19 = 0,
    FP_INFINITE___19 = 1,
    FP_ZERO___19 = 2,
    FP_SUBNORMAL___19 = 3,
    FP_NORMAL___19 = 4
} ;
#line 46 "/root/libsndfile/src/sndfile.h"
enum __anonenum__570___2 {
    SF_FORMAT_WAV___44 = 65536,
    SF_FORMAT_AIFF___44 = 131072,
    SF_FORMAT_AU___44 = 196608,
    SF_FORMAT_RAW___44 = 262144,
    SF_FORMAT_PAF___44 = 327680,
    SF_FORMAT_SVX___44 = 393216,
    SF_FORMAT_NIST___44 = 458752,
    SF_FORMAT_VOC___44 = 524288,
    SF_FORMAT_IRCAM___44 = 655360,
    SF_FORMAT_W64___44 = 720896,
    SF_FORMAT_MAT4___44 = 786432,
    SF_FORMAT_MAT5___44 = 851968,
    SF_FORMAT_PVF___44 = 917504,
    SF_FORMAT_XI___44 = 983040,
    SF_FORMAT_HTK___44 = 1048576,
    SF_FORMAT_SDS___44 = 1114112,
    SF_FORMAT_AVR___44 = 1179648,
    SF_FORMAT_WAVEX___44 = 1245184,
    SF_FORMAT_SD2___44 = 1441792,
    SF_FORMAT_FLAC___44 = 1507328,
    SF_FORMAT_CAF___44 = 1572864,
    SF_FORMAT_WVE___44 = 1638400,
    SF_FORMAT_OGG___44 = 2097152,
    SF_FORMAT_MPC2K___44 = 2162688,
    SF_FORMAT_RF64___44 = 2228224,
    SF_FORMAT_PCM_S8___44 = 1,
    SF_FORMAT_PCM_16___44 = 2,
    SF_FORMAT_PCM_24___44 = 3,
    SF_FORMAT_PCM_32___44 = 4,
    SF_FORMAT_PCM_U8___44 = 5,
    SF_FORMAT_FLOAT___44 = 6,
    SF_FORMAT_DOUBLE___44 = 7,
    SF_FORMAT_ULAW___44 = 16,
    SF_FORMAT_ALAW___44 = 17,
    SF_FORMAT_IMA_ADPCM___44 = 18,
    SF_FORMAT_MS_ADPCM___44 = 19,
    SF_FORMAT_GSM610___44 = 32,
    SF_FORMAT_VOX_ADPCM___44 = 33,
    SF_FORMAT_G721_32___44 = 48,
    SF_FORMAT_G723_24___44 = 49,
    SF_FORMAT_G723_40___44 = 50,
    SF_FORMAT_DWVW_12___44 = 64,
    SF_FORMAT_DWVW_16___44 = 65,
    SF_FORMAT_DWVW_24___44 = 66,
    SF_FORMAT_DWVW_N___44 = 67,
    SF_FORMAT_DPCM_8___44 = 80,
    SF_FORMAT_DPCM_16___44 = 81,
    SF_FORMAT_VORBIS___44 = 96,
    SF_ENDIAN_FILE___44 = 0,
    SF_ENDIAN_LITTLE___44 = 268435456,
    SF_ENDIAN_BIG___44 = 536870912,
    SF_ENDIAN_CPU___44 = 805306368,
    SF_FORMAT_SUBMASK___44 = 65535,
    SF_FORMAT_TYPEMASK___44 = 268369920,
    SF_FORMAT_ENDMASK___44 = 805306368
} ;
#line 126
enum __anonenum__571___2 {
    SFC_GET_LIB_VERSION___44 = 4096,
    SFC_GET_LOG_INFO___44 = 4097,
    SFC_GET_CURRENT_SF_INFO___44 = 4098,
    SFC_GET_NORM_DOUBLE___44 = 4112,
    SFC_GET_NORM_FLOAT___44 = 4113,
    SFC_SET_NORM_DOUBLE___44 = 4114,
    SFC_SET_NORM_FLOAT___44 = 4115,
    SFC_SET_SCALE_FLOAT_INT_READ___44 = 4116,
    SFC_SET_SCALE_INT_FLOAT_WRITE___44 = 4117,
    SFC_GET_SIMPLE_FORMAT_COUNT___44 = 4128,
    SFC_GET_SIMPLE_FORMAT___44 = 4129,
    SFC_GET_FORMAT_INFO___44 = 4136,
    SFC_GET_FORMAT_MAJOR_COUNT___44 = 4144,
    SFC_GET_FORMAT_MAJOR___44 = 4145,
    SFC_GET_FORMAT_SUBTYPE_COUNT___44 = 4146,
    SFC_GET_FORMAT_SUBTYPE___44 = 4147,
    SFC_CALC_SIGNAL_MAX___44 = 4160,
    SFC_CALC_NORM_SIGNAL_MAX___44 = 4161,
    SFC_CALC_MAX_ALL_CHANNELS___44 = 4162,
    SFC_CALC_NORM_MAX_ALL_CHANNELS___44 = 4163,
    SFC_GET_SIGNAL_MAX___44 = 4164,
    SFC_GET_MAX_ALL_CHANNELS___44 = 4165,
    SFC_SET_ADD_PEAK_CHUNK___44 = 4176,
    SFC_SET_ADD_HEADER_PAD_CHUNK___44 = 4177,
    SFC_UPDATE_HEADER_NOW___44 = 4192,
    SFC_SET_UPDATE_HEADER_AUTO___44 = 4193,
    SFC_FILE_TRUNCATE___44 = 4224,
    SFC_SET_RAW_START_OFFSET___44 = 4240,
    SFC_SET_DITHER_ON_WRITE___44 = 4256,
    SFC_SET_DITHER_ON_READ___44 = 4257,
    SFC_GET_DITHER_INFO_COUNT___44 = 4258,
    SFC_GET_DITHER_INFO___44 = 4259,
    SFC_GET_EMBED_FILE_INFO___44 = 4272,
    SFC_SET_CLIPPING___44 = 4288,
    SFC_GET_CLIPPING___44 = 4289,
    SFC_GET_INSTRUMENT___44 = 4304,
    SFC_SET_INSTRUMENT___44 = 4305,
    SFC_GET_LOOP_INFO___44 = 4320,
    SFC_GET_BROADCAST_INFO___44 = 4336,
    SFC_SET_BROADCAST_INFO___44 = 4337,
    SFC_GET_CHANNEL_MAP_INFO___44 = 4352,
    SFC_SET_CHANNEL_MAP_INFO___44 = 4353,
    SFC_RAW_DATA_NEEDS_ENDSWAP___44 = 4368,
    SFC_WAVEX_SET_AMBISONIC___44 = 4608,
    SFC_WAVEX_GET_AMBISONIC___44 = 4609,
    SFC_SET_VBR_ENCODING_QUALITY___44 = 4864,
    SFC_TEST_IEEE_FLOAT_REPLACE___44 = 24577,
    SFC_SET_ADD_DITHER_ON_WRITE___44 = 4208,
    SFC_SET_ADD_DITHER_ON_READ___44 = 4209
} ;
#line 216
enum __anonenum__572___2 {
    SF_STR_TITLE___44 = 1,
    SF_STR_COPYRIGHT___44 = 2,
    SF_STR_SOFTWARE___44 = 3,
    SF_STR_ARTIST___44 = 4,
    SF_STR_COMMENT___44 = 5,
    SF_STR_DATE___44 = 6,
    SF_STR_ALBUM___44 = 7,
    SF_STR_LICENSE___44 = 8
} ;
#line 235
enum __anonenum__573___2 {
    SF_FALSE___44 = 0,
    SF_TRUE___44 = 1,
    SFM_READ___44 = 16,
    SFM_WRITE___44 = 32,
    SFM_RDWR___44 = 48,
    SF_AMBISONIC_NONE___44 = 64,
    SF_AMBISONIC_B_FORMAT___44 = 65
} ;
#line 255
enum __anonenum__574___2 {
    SF_ERR_NO_ERROR___44 = 0,
    SF_ERR_UNRECOGNISED_FORMAT___44 = 1,
    SF_ERR_SYSTEM___44 = 2,
    SF_ERR_MALFORMED_FILE___44 = 3,
    SF_ERR_UNSUPPORTED_ENCODING___44 = 4
} ;
#line 267
enum __anonenum__575___2 {
    SF_CHANNEL_MAP_INVALID___44 = 0,
    SF_CHANNEL_MAP_MONO___44 = 1,
    SF_CHANNEL_MAP_LEFT___44 = 2,
    SF_CHANNEL_MAP_RIGHT___44 = 3,
    SF_CHANNEL_MAP_CENTER___44 = 4,
    SF_CHANNEL_MAP_FRONT_LEFT___44 = 5,
    SF_CHANNEL_MAP_FRONT_RIGHT___44 = 6,
    SF_CHANNEL_MAP_FRONT_CENTER___44 = 7,
    SF_CHANNEL_MAP_REAR_CENTER___44 = 8,
    SF_CHANNEL_MAP_REAR_LEFT___44 = 9,
    SF_CHANNEL_MAP_REAR_RIGHT___44 = 10,
    SF_CHANNEL_MAP_LFE___44 = 11,
    SF_CHANNEL_MAP_FRONT_LEFT_OF_CENTER___44 = 12,
    SF_CHANNEL_MAP_FRONT_RIGHT_OF_CENTER___44 = 13,
    SF_CHANNEL_MAP_SIDE_LEFT___44 = 14,
    SF_CHANNEL_MAP_SIDE_RIGHT___44 = 15,
    SF_CHANNEL_MAP_TOP_CENTER___44 = 16,
    SF_CHANNEL_MAP_TOP_FRONT_LEFT___44 = 17,
    SF_CHANNEL_MAP_TOP_FRONT_RIGHT___44 = 18,
    SF_CHANNEL_MAP_TOP_FRONT_CENTER___44 = 19,
    SF_CHANNEL_MAP_TOP_REAR_LEFT___44 = 20,
    SF_CHANNEL_MAP_TOP_REAR_RIGHT___44 = 21,
    SF_CHANNEL_MAP_TOP_REAR_CENTER___44 = 22
} ;
#line 352
enum __anonenum__577___2 {
    SFD_DEFAULT_LEVEL___44 = 0,
    SFD_CUSTOM_LEVEL___44 = 1073741824,
    SFD_NO_DITHER___44 = 500,
    SFD_WHITE___44 = 501,
    SFD_TRIANGULAR_PDF___44 = 502
} ;
#line 380
enum __anonenum__580___2 {
    SF_LOOP_NONE___44 = 800,
    SF_LOOP_FORWARD___44 = 801,
    SF_LOOP_BACKWARD___44 = 802,
    SF_LOOP_ALTERNATING___44 = 803
} ;
#line 121 "/root/libsndfile/src/common.h"
enum __anonenum__990 {
    SF_PEAK_START___44 = 42,
    SF_PEAK_END___44 = 43,
    SF_SCALE_MAX___44 = 52,
    SF_SCALE_MIN___44 = 53,
    SF_STR_ALLOW_START___44 = 256,
    SF_STR_ALLOW_END___44 = 512,
    SF_STR_LOCATE_START___44 = 1024,
    SF_STR_LOCATE_END___44 = 2048,
    SFD_TYPEMASK___44 = 268435455
} ;
#line 149
enum __anonenum__991 {
    SF_FORMAT_TXW___44 = 67305472,
    SF_FORMAT_DWD___44 = 67371008,
    SF_FORMAT_REX___44 = 67764224,
    SF_FORMAT_REX2___44 = 67960832,
    SF_FORMAT_KRZ___44 = 68026368,
    SF_FORMAT_WMA___44 = 68157440,
    SF_FORMAT_SHN___44 = 68222976,
    SF_FORMAT_SVX_FIB___44 = 4128,
    SF_FORMAT_SVX_EXP___44 = 4129,
    SF_FORMAT_PCM_N___44 = 4144
} ;
#line 405
enum __anonenum__997 {
    SFE_NO_ERROR___44 = 0,
    SFE_BAD_OPEN_FORMAT___44 = 1,
    SFE_SYSTEM___44 = 2,
    SFE_MALFORMED_FILE___44 = 3,
    SFE_UNSUPPORTED_ENCODING___44 = 4,
    SFE_ZERO_MAJOR_FORMAT___44 = 5,
    SFE_ZERO_MINOR_FORMAT___44 = 6,
    SFE_BAD_FILE___44 = 7,
    SFE_BAD_FILE_READ___44 = 8,
    SFE_OPEN_FAILED___44 = 9,
    SFE_BAD_SNDFILE_PTR___44 = 10,
    SFE_BAD_SF_INFO_PTR___44 = 11,
    SFE_BAD_SF_INCOMPLETE___44 = 12,
    SFE_BAD_FILE_PTR___44 = 13,
    SFE_BAD_INT_PTR___44 = 14,
    SFE_BAD_STAT_SIZE___44 = 15,
    SFE_MALLOC_FAILED___44 = 16,
    SFE_UNIMPLEMENTED___44 = 17,
    SFE_BAD_READ_ALIGN___44 = 18,
    SFE_BAD_WRITE_ALIGN___44 = 19,
    SFE_UNKNOWN_FORMAT___44 = 20,
    SFE_NOT_READMODE___44 = 21,
    SFE_NOT_WRITEMODE___44 = 22,
    SFE_BAD_MODE_RW___44 = 23,
    SFE_BAD_SF_INFO___44 = 24,
    SFE_BAD_OFFSET___44 = 25,
    SFE_NO_EMBED_SUPPORT___44 = 26,
    SFE_NO_EMBEDDED_RDWR___44 = 27,
    SFE_NO_PIPE_WRITE___44 = 28,
    SFE_INTERNAL___44 = 29,
    SFE_BAD_COMMAND_PARAM___44 = 30,
    SFE_BAD_ENDIAN___44 = 31,
    SFE_CHANNEL_COUNT_ZERO___44 = 32,
    SFE_CHANNEL_COUNT___44 = 33,
    SFE_BAD_VIRTUAL_IO___44 = 34,
    SFE_INTERLEAVE_MODE___44 = 35,
    SFE_INTERLEAVE_SEEK___44 = 36,
    SFE_INTERLEAVE_READ___44 = 37,
    SFE_BAD_SEEK___44 = 38,
    SFE_NOT_SEEKABLE___44 = 39,
    SFE_AMBIGUOUS_SEEK___44 = 40,
    SFE_WRONG_SEEK___44 = 41,
    SFE_SEEK_FAILED___44 = 42,
    SFE_BAD_OPEN_MODE___44 = 43,
    SFE_OPEN_PIPE_RDWR___44 = 44,
    SFE_RDWR_POSITION___44 = 45,
    SFE_RDWR_BAD_HEADER___44 = 46,
    SFE_CMD_HAS_DATA___44 = 47,
    SFE_BAD_BROADCAST_INFO_SIZE___44 = 48,
    SFE_STR_NO_SUPPORT___44 = 49,
    SFE_STR_NOT_WRITE___44 = 50,
    SFE_STR_MAX_DATA___44 = 51,
    SFE_STR_MAX_COUNT___44 = 52,
    SFE_STR_BAD_TYPE___44 = 53,
    SFE_STR_NO_ADD_END___44 = 54,
    SFE_STR_BAD_STRING___44 = 55,
    SFE_STR_WEIRD___44 = 56,
    SFE_WAV_NO_RIFF___44 = 57,
    SFE_WAV_NO_WAVE___44 = 58,
    SFE_WAV_NO_FMT___44 = 59,
    SFE_WAV_BAD_FMT___44 = 60,
    SFE_WAV_FMT_SHORT___44 = 61,
    SFE_WAV_BAD_FACT___44 = 62,
    SFE_WAV_BAD_PEAK___44 = 63,
    SFE_WAV_PEAK_B4_FMT___44 = 64,
    SFE_WAV_BAD_FORMAT___44 = 65,
    SFE_WAV_BAD_BLOCKALIGN___44 = 66,
    SFE_WAV_NO_DATA___44 = 67,
    SFE_WAV_BAD_LIST___44 = 68,
    SFE_WAV_ADPCM_NOT4BIT___44 = 69,
    SFE_WAV_ADPCM_CHANNELS___44 = 70,
    SFE_WAV_GSM610_FORMAT___44 = 71,
    SFE_WAV_UNKNOWN_CHUNK___44 = 72,
    SFE_WAV_WVPK_DATA___44 = 73,
    SFE_AIFF_NO_FORM___44 = 74,
    SFE_AIFF_AIFF_NO_FORM___44 = 75,
    SFE_AIFF_COMM_NO_FORM___44 = 76,
    SFE_AIFF_SSND_NO_COMM___44 = 77,
    SFE_AIFF_UNKNOWN_CHUNK___44 = 78,
    SFE_AIFF_COMM_CHUNK_SIZE___44 = 79,
    SFE_AIFF_BAD_COMM_CHUNK___44 = 80,
    SFE_AIFF_PEAK_B4_COMM___44 = 81,
    SFE_AIFF_BAD_PEAK___44 = 82,
    SFE_AIFF_NO_SSND___44 = 83,
    SFE_AIFF_NO_DATA___44 = 84,
    SFE_AIFF_RW_SSND_NOT_LAST___44 = 85,
    SFE_AU_UNKNOWN_FORMAT___44 = 86,
    SFE_AU_NO_DOTSND___44 = 87,
    SFE_AU_EMBED_BAD_LEN___44 = 88,
    SFE_RAW_READ_BAD_SPEC___44 = 89,
    SFE_RAW_BAD_BITWIDTH___44 = 90,
    SFE_RAW_BAD_FORMAT___44 = 91,
    SFE_PAF_NO_MARKER___44 = 92,
    SFE_PAF_VERSION___44 = 93,
    SFE_PAF_UNKNOWN_FORMAT___44 = 94,
    SFE_PAF_SHORT_HEADER___44 = 95,
    SFE_SVX_NO_FORM___44 = 96,
    SFE_SVX_NO_BODY___44 = 97,
    SFE_SVX_NO_DATA___44 = 98,
    SFE_SVX_BAD_COMP___44 = 99,
    SFE_SVX_BAD_NAME_LENGTH___44 = 100,
    SFE_NIST_BAD_HEADER___44 = 101,
    SFE_NIST_CRLF_CONVERISON___44 = 102,
    SFE_NIST_BAD_ENCODING___44 = 103,
    SFE_VOC_NO_CREATIVE___44 = 104,
    SFE_VOC_BAD_FORMAT___44 = 105,
    SFE_VOC_BAD_VERSION___44 = 106,
    SFE_VOC_BAD_MARKER___44 = 107,
    SFE_VOC_BAD_SECTIONS___44 = 108,
    SFE_VOC_MULTI_SAMPLERATE___44 = 109,
    SFE_VOC_MULTI_SECTION___44 = 110,
    SFE_VOC_MULTI_PARAM___44 = 111,
    SFE_VOC_SECTION_COUNT___44 = 112,
    SFE_VOC_NO_PIPE___44 = 113,
    SFE_IRCAM_NO_MARKER___44 = 114,
    SFE_IRCAM_BAD_CHANNELS___44 = 115,
    SFE_IRCAM_UNKNOWN_FORMAT___44 = 116,
    SFE_W64_64_BIT___44 = 117,
    SFE_W64_NO_RIFF___44 = 118,
    SFE_W64_NO_WAVE___44 = 119,
    SFE_W64_NO_DATA___44 = 120,
    SFE_W64_ADPCM_NOT4BIT___44 = 121,
    SFE_W64_ADPCM_CHANNELS___44 = 122,
    SFE_W64_GSM610_FORMAT___44 = 123,
    SFE_MAT4_BAD_NAME___44 = 124,
    SFE_MAT4_NO_SAMPLERATE___44 = 125,
    SFE_MAT5_BAD_ENDIAN___44 = 126,
    SFE_MAT5_NO_BLOCK___44 = 127,
    SFE_MAT5_SAMPLE_RATE___44 = 128,
    SFE_PVF_NO_PVF1___44 = 129,
    SFE_PVF_BAD_HEADER___44 = 130,
    SFE_PVF_BAD_BITWIDTH___44 = 131,
    SFE_DWVW_BAD_BITWIDTH___44 = 132,
    SFE_G72X_NOT_MONO___44 = 133,
    SFE_XI_BAD_HEADER___44 = 134,
    SFE_XI_EXCESS_SAMPLES___44 = 135,
    SFE_XI_NO_PIPE___44 = 136,
    SFE_HTK_NO_PIPE___44 = 137,
    SFE_SDS_NOT_SDS___44 = 138,
    SFE_SDS_BAD_BIT_WIDTH___44 = 139,
    SFE_SD2_FD_DISALLOWED___44 = 140,
    SFE_SD2_BAD_DATA_OFFSET___44 = 141,
    SFE_SD2_BAD_MAP_OFFSET___44 = 142,
    SFE_SD2_BAD_DATA_LENGTH___44 = 143,
    SFE_SD2_BAD_MAP_LENGTH___44 = 144,
    SFE_SD2_BAD_RSRC___44 = 145,
    SFE_SD2_BAD_SAMPLE_SIZE___44 = 146,
    SFE_FLAC_BAD_HEADER___44 = 147,
    SFE_FLAC_NEW_DECODER___44 = 148,
    SFE_FLAC_INIT_DECODER___44 = 149,
    SFE_FLAC_LOST_SYNC___44 = 150,
    SFE_FLAC_BAD_SAMPLE_RATE___44 = 151,
    SFE_FLAC_UNKOWN_ERROR___44 = 152,
    SFE_WVE_NOT_WVE___44 = 153,
    SFE_WVE_NO_PIPE___44 = 154,
    SFE_VORBIS_ENCODER_BUG___44 = 155,
    SFE_RF64_NOT_RF64___44 = 156,
    SFE_MAX_ERROR___44 = 157
} ;
#line 823
enum __anonenum__1001 {
    SFC_TEST_AIFF_ADD_INST_CHUNK___44 = 8192,
    SFC_TEST_WAV_ADD_INFO_CHUNK___44 = 8208
} ;
#line 57 "/usr/include/FLAC/ordinals.h"
typedef int8_t FLAC__int8;
#line 58 "/usr/include/FLAC/ordinals.h"
typedef uint8_t FLAC__uint8;
#line 60 "/usr/include/FLAC/ordinals.h"
typedef int16_t FLAC__int16;
#line 61 "/usr/include/FLAC/ordinals.h"
typedef int32_t FLAC__int32;
#line 62 "/usr/include/FLAC/ordinals.h"
typedef int64_t FLAC__int64;
#line 63 "/usr/include/FLAC/ordinals.h"
typedef uint16_t FLAC__uint16;
#line 64 "/usr/include/FLAC/ordinals.h"
typedef uint32_t FLAC__uint32;
#line 65 "/usr/include/FLAC/ordinals.h"
typedef uint64_t FLAC__uint64;
#line 69 "/usr/include/FLAC/ordinals.h"
typedef int FLAC__bool;
#line 71 "/usr/include/FLAC/ordinals.h"
typedef FLAC__uint8 FLAC__byte;
#line 194 "/usr/include/FLAC/format.h"
enum __anonenum__1002 {
    FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE = 0,
    FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2 = 1
} ;
#line 202 "/usr/include/FLAC/format.h"
typedef enum __anonenum__1002 FLAC__EntropyCodingMethodType;
#line 214 "/usr/include/FLAC/format.h"
struct __anonstruct_1003 {
   uint32_t *parameters ;
   uint32_t *raw_bits ;
   uint32_t capacity_by_order ;
};
#line 229 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1003 FLAC__EntropyCodingMethod_PartitionedRiceContents;
#line 233 "/usr/include/FLAC/format.h"
struct __anonstruct_1004 {
   uint32_t order ;
   FLAC__EntropyCodingMethod_PartitionedRiceContents *contents ;
};
#line 241 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1004 FLAC__EntropyCodingMethod_PartitionedRice;
#line 257 "/usr/include/FLAC/format.h"
union __anonunion_1006 {
   FLAC__EntropyCodingMethod_PartitionedRice partitioned_rice ;
};
#line 255 "/usr/include/FLAC/format.h"
struct __anonstruct_1005 {
   FLAC__EntropyCodingMethodType type ;
   union __anonunion_1006 data ;
};
#line 260 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1005 FLAC__EntropyCodingMethod;
#line 267
enum __anonenum__1007 {
    FLAC__SUBFRAME_TYPE_CONSTANT = 0,
    FLAC__SUBFRAME_TYPE_VERBATIM = 1,
    FLAC__SUBFRAME_TYPE_FIXED = 2,
    FLAC__SUBFRAME_TYPE_LPC = 3
} ;
#line 272 "/usr/include/FLAC/format.h"
typedef enum __anonenum__1007 FLAC__SubframeType;
#line 284 "/usr/include/FLAC/format.h"
struct __anonstruct_1008 {
   FLAC__int32 value ;
};
#line 286 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1008 FLAC__Subframe_Constant;
#line 291 "/usr/include/FLAC/format.h"
struct __anonstruct_1009 {
   FLAC__int32 *data ;
};
#line 293 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1009 FLAC__Subframe_Verbatim;
#line 298 "/usr/include/FLAC/format.h"
struct __anonstruct_1010 {
   FLAC__EntropyCodingMethod entropy_coding_method ;
   uint32_t order ;
   FLAC__int32 warmup[4] ;
   FLAC__int32 *residual ;
};
#line 310 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1010 FLAC__Subframe_Fixed;
#line 315 "/usr/include/FLAC/format.h"
struct __anonstruct_1011 {
   FLAC__EntropyCodingMethod entropy_coding_method ;
   uint32_t order ;
   uint32_t qlp_coeff_precision ;
   int quantization_level ;
   FLAC__int32 qlp_coeff[32] ;
   FLAC__int32 warmup[32] ;
   FLAC__int32 *residual ;
};
#line 336 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1011 FLAC__Subframe_LPC;
#line 346 "/usr/include/FLAC/format.h"
union __anonunion_1013 {
   FLAC__Subframe_Constant constant ;
   FLAC__Subframe_Fixed fixed ;
   FLAC__Subframe_LPC lpc ;
   FLAC__Subframe_Verbatim verbatim ;
};
#line 344 "/usr/include/FLAC/format.h"
struct __anonstruct_1012 {
   FLAC__SubframeType type ;
   union __anonunion_1013 data ;
   uint32_t wasted_bits ;
};
#line 353 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1012 FLAC__Subframe;
#line 381
enum __anonenum__1014 {
    FLAC__CHANNEL_ASSIGNMENT_INDEPENDENT = 0,
    FLAC__CHANNEL_ASSIGNMENT_LEFT_SIDE = 1,
    FLAC__CHANNEL_ASSIGNMENT_RIGHT_SIDE = 2,
    FLAC__CHANNEL_ASSIGNMENT_MID_SIDE = 3
} ;
#line 386 "/usr/include/FLAC/format.h"
typedef enum __anonenum__1014 FLAC__ChannelAssignment;
#line 396
enum __anonenum__1015 {
    FLAC__FRAME_NUMBER_TYPE_FRAME_NUMBER = 0,
    FLAC__FRAME_NUMBER_TYPE_SAMPLE_NUMBER = 1
} ;
#line 399 "/usr/include/FLAC/format.h"
typedef enum __anonenum__1015 FLAC__FrameNumberType;
#line 432 "/usr/include/FLAC/format.h"
union __anonunion_1017 {
   FLAC__uint32 frame_number ;
   FLAC__uint64 sample_number ;
};
#line 411 "/usr/include/FLAC/format.h"
struct __anonstruct_1016 {
   uint32_t blocksize ;
   uint32_t sample_rate ;
   uint32_t channels ;
   FLAC__ChannelAssignment channel_assignment ;
   uint32_t bits_per_sample ;
   FLAC__FrameNumberType number_type ;
   union __anonunion_1017 number ;
   FLAC__uint8 crc ;
};
#line 444 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1016 FLAC__FrameHeader;
#line 460 "/usr/include/FLAC/format.h"
struct __anonstruct_1018 {
   FLAC__uint16 crc ;
};
#line 466 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1018 FLAC__FrameFooter;
#line 473 "/usr/include/FLAC/format.h"
struct __anonstruct_1019 {
   FLAC__FrameHeader header ;
   FLAC__Subframe subframes[8] ;
   FLAC__FrameFooter footer ;
};
#line 477 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1019 FLAC__Frame;
#line 489
enum __anonenum__1020 {
    FLAC__METADATA_TYPE_STREAMINFO = 0,
    FLAC__METADATA_TYPE_PADDING = 1,
    FLAC__METADATA_TYPE_APPLICATION = 2,
    FLAC__METADATA_TYPE_SEEKTABLE = 3,
    FLAC__METADATA_TYPE_VORBIS_COMMENT = 4,
    FLAC__METADATA_TYPE_CUESHEET = 5,
    FLAC__METADATA_TYPE_PICTURE = 6,
    FLAC__METADATA_TYPE_UNDEFINED = 7,
    FLAC__MAX_METADATA_TYPE = 126
} ;
#line 517 "/usr/include/FLAC/format.h"
typedef enum __anonenum__1020 FLAC__MetadataType;
#line 529 "/usr/include/FLAC/format.h"
struct __anonstruct_1021 {
   uint32_t min_blocksize ;
   uint32_t max_blocksize ;
   uint32_t min_framesize ;
   uint32_t max_framesize ;
   uint32_t sample_rate ;
   uint32_t channels ;
   uint32_t bits_per_sample ;
   FLAC__uint64 total_samples ;
   FLAC__byte md5sum[16] ;
};
#line 537 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1021 FLAC__StreamMetadata_StreamInfo;
#line 554 "/usr/include/FLAC/format.h"
struct __anonstruct_1022 {
   int dummy ;
};
#line 560 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1022 FLAC__StreamMetadata_Padding;
#line 565 "/usr/include/FLAC/format.h"
struct __anonstruct_1023 {
   FLAC__byte id[4] ;
   FLAC__byte *data ;
};
#line 568 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1023 FLAC__StreamMetadata_Application;
#line 574 "/usr/include/FLAC/format.h"
struct __anonstruct_1024 {
   FLAC__uint64 sample_number ;
   FLAC__uint64 stream_offset ;
   uint32_t frame_samples ;
};
#line 584 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1024 FLAC__StreamMetadata_SeekPoint;
#line 612 "/usr/include/FLAC/format.h"
struct __anonstruct_1025 {
   uint32_t num_points ;
   FLAC__StreamMetadata_SeekPoint *points ;
};
#line 615 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1025 FLAC__StreamMetadata_SeekTable;
#line 624 "/usr/include/FLAC/format.h"
struct __anonstruct_1026 {
   FLAC__uint32 length ;
   FLAC__byte *entry ;
};
#line 627 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1026 FLAC__StreamMetadata_VorbisComment_Entry;
#line 634 "/usr/include/FLAC/format.h"
struct __anonstruct_1027 {
   FLAC__StreamMetadata_VorbisComment_Entry vendor_string ;
   FLAC__uint32 num_comments ;
   FLAC__StreamMetadata_VorbisComment_Entry *comments ;
};
#line 638 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1027 FLAC__StreamMetadata_VorbisComment;
#line 647 "/usr/include/FLAC/format.h"
struct __anonstruct_1028 {
   FLAC__uint64 offset ;
   FLAC__byte number ;
};
#line 655 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1028 FLAC__StreamMetadata_CueSheet_Index;
#line 666 "/usr/include/FLAC/format.h"
struct __anonstruct_1029 {
   FLAC__uint64 offset ;
   FLAC__byte number ;
   char isrc[13] ;
   uint32_t type ;
   uint32_t pre_emphasis ;
   FLAC__byte num_indices ;
   FLAC__StreamMetadata_CueSheet_Index *indices ;
};
#line 688 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1029 FLAC__StreamMetadata_CueSheet_Track;
#line 703 "/usr/include/FLAC/format.h"
struct __anonstruct_1030 {
   char media_catalog_number[129] ;
   FLAC__uint64 lead_in ;
   FLAC__bool is_cd ;
   uint32_t num_tracks ;
   FLAC__StreamMetadata_CueSheet_Track *tracks ;
};
#line 722 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1030 FLAC__StreamMetadata_CueSheet;
#line 732
enum __anonenum__1031 {
    FLAC__STREAM_METADATA_PICTURE_TYPE_OTHER = 0,
    FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON_STANDARD = 1,
    FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON = 2,
    FLAC__STREAM_METADATA_PICTURE_TYPE_FRONT_COVER = 3,
    FLAC__STREAM_METADATA_PICTURE_TYPE_BACK_COVER = 4,
    FLAC__STREAM_METADATA_PICTURE_TYPE_LEAFLET_PAGE = 5,
    FLAC__STREAM_METADATA_PICTURE_TYPE_MEDIA = 6,
    FLAC__STREAM_METADATA_PICTURE_TYPE_LEAD_ARTIST = 7,
    FLAC__STREAM_METADATA_PICTURE_TYPE_ARTIST = 8,
    FLAC__STREAM_METADATA_PICTURE_TYPE_CONDUCTOR = 9,
    FLAC__STREAM_METADATA_PICTURE_TYPE_BAND = 10,
    FLAC__STREAM_METADATA_PICTURE_TYPE_COMPOSER = 11,
    FLAC__STREAM_METADATA_PICTURE_TYPE_LYRICIST = 12,
    FLAC__STREAM_METADATA_PICTURE_TYPE_RECORDING_LOCATION = 13,
    FLAC__STREAM_METADATA_PICTURE_TYPE_DURING_RECORDING = 14,
    FLAC__STREAM_METADATA_PICTURE_TYPE_DURING_PERFORMANCE = 15,
    FLAC__STREAM_METADATA_PICTURE_TYPE_VIDEO_SCREEN_CAPTURE = 16,
    FLAC__STREAM_METADATA_PICTURE_TYPE_FISH = 17,
    FLAC__STREAM_METADATA_PICTURE_TYPE_ILLUSTRATION = 18,
    FLAC__STREAM_METADATA_PICTURE_TYPE_BAND_LOGOTYPE = 19,
    FLAC__STREAM_METADATA_PICTURE_TYPE_PUBLISHER_LOGOTYPE = 20,
    FLAC__STREAM_METADATA_PICTURE_TYPE_UNDEFINED = 21
} ;
#line 755 "/usr/include/FLAC/format.h"
typedef enum __anonenum__1031 FLAC__StreamMetadata_Picture_Type;
#line 769 "/usr/include/FLAC/format.h"
struct __anonstruct_1032 {
   FLAC__StreamMetadata_Picture_Type type ;
   char *mime_type ;
   FLAC__byte *description ;
   FLAC__uint32 width ;
   FLAC__uint32 height ;
   FLAC__uint32 depth ;
   FLAC__uint32 colors ;
   FLAC__uint32 data_length ;
   FLAC__byte *data ;
};
#line 811 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1032 FLAC__StreamMetadata_Picture;
#line 827 "/usr/include/FLAC/format.h"
struct __anonstruct_1033 {
   FLAC__byte *data ;
};
#line 829 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1033 FLAC__StreamMetadata_Unknown;
#line 846 "/usr/include/FLAC/format.h"
union __anonunion_1035 {
   FLAC__StreamMetadata_StreamInfo stream_info ;
   FLAC__StreamMetadata_Padding padding ;
   FLAC__StreamMetadata_Application application ;
   FLAC__StreamMetadata_SeekTable seek_table ;
   FLAC__StreamMetadata_VorbisComment vorbis_comment ;
   FLAC__StreamMetadata_CueSheet cue_sheet ;
   FLAC__StreamMetadata_Picture picture ;
   FLAC__StreamMetadata_Unknown unknown ;
};
#line 834 "/usr/include/FLAC/format.h"
struct __anonstruct_1034 {
   FLAC__MetadataType type ;
   FLAC__bool is_last ;
   uint32_t length ;
   union __anonunion_1035 data ;
};
#line 858 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_1034 FLAC__StreamMetadata;
#line 202 "/usr/include/FLAC/stream_decoder.h"
enum __anonenum__1036 {
    FLAC__STREAM_DECODER_SEARCH_FOR_METADATA = 0,
    FLAC__STREAM_DECODER_READ_METADATA = 1,
    FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC = 2,
    FLAC__STREAM_DECODER_READ_FRAME = 3,
    FLAC__STREAM_DECODER_END_OF_STREAM = 4,
    FLAC__STREAM_DECODER_OGG_ERROR = 5,
    FLAC__STREAM_DECODER_SEEK_ERROR = 6,
    FLAC__STREAM_DECODER_ABORTED = 7,
    FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR = 8,
    FLAC__STREAM_DECODER_UNINITIALIZED = 9
} ;
#line 244 "/usr/include/FLAC/stream_decoder.h"
typedef enum __anonenum__1036 FLAC__StreamDecoderState;
#line 256
enum __anonenum__1037 {
    FLAC__STREAM_DECODER_INIT_STATUS_OK = 0,
    FLAC__STREAM_DECODER_INIT_STATUS_UNSUPPORTED_CONTAINER = 1,
    FLAC__STREAM_DECODER_INIT_STATUS_INVALID_CALLBACKS = 2,
    FLAC__STREAM_DECODER_INIT_STATUS_MEMORY_ALLOCATION_ERROR = 3,
    FLAC__STREAM_DECODER_INIT_STATUS_ERROR_OPENING_FILE = 4,
    FLAC__STREAM_DECODER_INIT_STATUS_ALREADY_INITIALIZED = 5
} ;
#line 282 "/usr/include/FLAC/stream_decoder.h"
typedef enum __anonenum__1037 FLAC__StreamDecoderInitStatus;
#line 294
enum __anonenum__1038 {
    FLAC__STREAM_DECODER_READ_STATUS_CONTINUE = 0,
    FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM = 1,
    FLAC__STREAM_DECODER_READ_STATUS_ABORT = 2
} ;
#line 313 "/usr/include/FLAC/stream_decoder.h"
typedef enum __anonenum__1038 FLAC__StreamDecoderReadStatus;
#line 325
enum __anonenum__1039 {
    FLAC__STREAM_DECODER_SEEK_STATUS_OK = 0,
    FLAC__STREAM_DECODER_SEEK_STATUS_ERROR = 1,
    FLAC__STREAM_DECODER_SEEK_STATUS_UNSUPPORTED = 2
} ;
#line 336 "/usr/include/FLAC/stream_decoder.h"
typedef enum __anonenum__1039 FLAC__StreamDecoderSeekStatus;
#line 348
enum __anonenum__1040 {
    FLAC__STREAM_DECODER_TELL_STATUS_OK = 0,
    FLAC__STREAM_DECODER_TELL_STATUS_ERROR = 1,
    FLAC__STREAM_DECODER_TELL_STATUS_UNSUPPORTED = 2
} ;
#line 359 "/usr/include/FLAC/stream_decoder.h"
typedef enum __anonenum__1040 FLAC__StreamDecoderTellStatus;
#line 371
enum __anonenum__1041 {
    FLAC__STREAM_DECODER_LENGTH_STATUS_OK = 0,
    FLAC__STREAM_DECODER_LENGTH_STATUS_ERROR = 1,
    FLAC__STREAM_DECODER_LENGTH_STATUS_UNSUPPORTED = 2
} ;
#line 382 "/usr/include/FLAC/stream_decoder.h"
typedef enum __anonenum__1041 FLAC__StreamDecoderLengthStatus;
#line 394
enum __anonenum__1042 {
    FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE = 0,
    FLAC__STREAM_DECODER_WRITE_STATUS_ABORT = 1
} ;
#line 402 "/usr/include/FLAC/stream_decoder.h"
typedef enum __anonenum__1042 FLAC__StreamDecoderWriteStatus;
#line 427
enum __anonenum__1043 {
    FLAC__STREAM_DECODER_ERROR_STATUS_LOST_SYNC = 0,
    FLAC__STREAM_DECODER_ERROR_STATUS_BAD_HEADER = 1,
    FLAC__STREAM_DECODER_ERROR_STATUS_FRAME_CRC_MISMATCH = 2,
    FLAC__STREAM_DECODER_ERROR_STATUS_UNPARSEABLE_STREAM = 3
} ;
#line 441 "/usr/include/FLAC/stream_decoder.h"
typedef enum __anonenum__1043 FLAC__StreamDecoderErrorStatus;
#line 457
struct FLAC__StreamDecoderProtected ;
#line 458
struct FLAC__StreamDecoderPrivate ;
#line 463 "/usr/include/FLAC/stream_decoder.h"
struct __anonstruct_1044 {
   struct FLAC__StreamDecoderProtected *protected_ ;
   struct FLAC__StreamDecoderPrivate *private_ ;
};
#line 466 "/usr/include/FLAC/stream_decoder.h"
typedef struct __anonstruct_1044 FLAC__StreamDecoder;
#line 517 "/usr/include/FLAC/stream_decoder.h"
typedef FLAC__StreamDecoderReadStatus (*FLAC__StreamDecoderReadCallback)(FLAC__StreamDecoder * ,
                                                                         FLAC__byte [] ,
                                                                         size_t * ,
                                                                         void * );
#line 552 "/usr/include/FLAC/stream_decoder.h"
typedef FLAC__StreamDecoderSeekStatus (*FLAC__StreamDecoderSeekCallback)(FLAC__StreamDecoder * ,
                                                                         FLAC__uint64  ,
                                                                         void * );
#line 590 "/usr/include/FLAC/stream_decoder.h"
typedef FLAC__StreamDecoderTellStatus (*FLAC__StreamDecoderTellCallback)(FLAC__StreamDecoder * ,
                                                                         FLAC__uint64 * ,
                                                                         void * );
#line 628 "/usr/include/FLAC/stream_decoder.h"
typedef FLAC__StreamDecoderLengthStatus (*FLAC__StreamDecoderLengthCallback)(FLAC__StreamDecoder * ,
                                                                             FLAC__uint64 * ,
                                                                             void * );
#line 655 "/usr/include/FLAC/stream_decoder.h"
typedef FLAC__bool (*FLAC__StreamDecoderEofCallback)(FLAC__StreamDecoder * , void * );
#line 683 "/usr/include/FLAC/stream_decoder.h"
typedef FLAC__StreamDecoderWriteStatus (*FLAC__StreamDecoderWriteCallback)(FLAC__StreamDecoder * ,
                                                                           FLAC__Frame * ,
                                                                           FLAC__int32 * const  [] ,
                                                                           void * );
#line 710 "/usr/include/FLAC/stream_decoder.h"
typedef void (*FLAC__StreamDecoderMetadataCallback)(FLAC__StreamDecoder * , FLAC__StreamMetadata * ,
                                                    void * );
#line 727 "/usr/include/FLAC/stream_decoder.h"
typedef void (*FLAC__StreamDecoderErrorCallback)(FLAC__StreamDecoder * , FLAC__StreamDecoderErrorStatus  ,
                                                 void * );
#line 241 "/usr/include/FLAC/stream_encoder.h"
enum __anonenum__1045 {
    FLAC__STREAM_ENCODER_OK = 0,
    FLAC__STREAM_ENCODER_UNINITIALIZED = 1,
    FLAC__STREAM_ENCODER_OGG_ERROR = 2,
    FLAC__STREAM_ENCODER_VERIFY_DECODER_ERROR = 3,
    FLAC__STREAM_ENCODER_VERIFY_MISMATCH_IN_AUDIO_DATA = 4,
    FLAC__STREAM_ENCODER_CLIENT_ERROR = 5,
    FLAC__STREAM_ENCODER_IO_ERROR = 6,
    FLAC__STREAM_ENCODER_FRAMING_ERROR = 7,
    FLAC__STREAM_ENCODER_MEMORY_ALLOCATION_ERROR = 8
} ;
#line 281 "/usr/include/FLAC/stream_encoder.h"
typedef enum __anonenum__1045 FLAC__StreamEncoderState;
#line 293
enum __anonenum__1046 {
    FLAC__STREAM_ENCODER_INIT_STATUS_OK = 0,
    FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR = 1,
    FLAC__STREAM_ENCODER_INIT_STATUS_UNSUPPORTED_CONTAINER = 2,
    FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_CALLBACKS = 3,
    FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_NUMBER_OF_CHANNELS = 4,
    FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_BITS_PER_SAMPLE = 5,
    FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_SAMPLE_RATE = 6,
    FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_BLOCK_SIZE = 7,
    FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_MAX_LPC_ORDER = 8,
    FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_QLP_COEFF_PRECISION = 9,
    FLAC__STREAM_ENCODER_INIT_STATUS_BLOCK_SIZE_TOO_SMALL_FOR_LPC_ORDER = 10,
    FLAC__STREAM_ENCODER_INIT_STATUS_NOT_STREAMABLE = 11,
    FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_METADATA = 12,
    FLAC__STREAM_ENCODER_INIT_STATUS_ALREADY_INITIALIZED = 13
} ;
#line 351 "/usr/include/FLAC/stream_encoder.h"
typedef enum __anonenum__1046 FLAC__StreamEncoderInitStatus;
#line 363
enum __anonenum__1047 {
    FLAC__STREAM_ENCODER_READ_STATUS_CONTINUE = 0,
    FLAC__STREAM_ENCODER_READ_STATUS_END_OF_STREAM = 1,
    FLAC__STREAM_ENCODER_READ_STATUS_ABORT = 2,
    FLAC__STREAM_ENCODER_READ_STATUS_UNSUPPORTED = 3
} ;
#line 377 "/usr/include/FLAC/stream_encoder.h"
typedef enum __anonenum__1047 FLAC__StreamEncoderReadStatus;
#line 389
enum __anonenum__1048 {
    FLAC__STREAM_ENCODER_WRITE_STATUS_OK = 0,
    FLAC__STREAM_ENCODER_WRITE_STATUS_FATAL_ERROR = 1
} ;
#line 397 "/usr/include/FLAC/stream_encoder.h"
typedef enum __anonenum__1048 FLAC__StreamEncoderWriteStatus;
#line 409
enum __anonenum__1049 {
    FLAC__STREAM_ENCODER_SEEK_STATUS_OK = 0,
    FLAC__STREAM_ENCODER_SEEK_STATUS_ERROR = 1,
    FLAC__STREAM_ENCODER_SEEK_STATUS_UNSUPPORTED = 2
} ;
#line 420 "/usr/include/FLAC/stream_encoder.h"
typedef enum __anonenum__1049 FLAC__StreamEncoderSeekStatus;
#line 432
enum __anonenum__1050 {
    FLAC__STREAM_ENCODER_TELL_STATUS_OK = 0,
    FLAC__STREAM_ENCODER_TELL_STATUS_ERROR = 1,
    FLAC__STREAM_ENCODER_TELL_STATUS_UNSUPPORTED = 2
} ;
#line 443 "/usr/include/FLAC/stream_encoder.h"
typedef enum __anonenum__1050 FLAC__StreamEncoderTellStatus;
#line 459
struct FLAC__StreamEncoderProtected ;
#line 460
struct FLAC__StreamEncoderPrivate ;
#line 465 "/usr/include/FLAC/stream_encoder.h"
struct __anonstruct_1051 {
   struct FLAC__StreamEncoderProtected *protected_ ;
   struct FLAC__StreamEncoderPrivate *private_ ;
};
#line 468 "/usr/include/FLAC/stream_encoder.h"
typedef struct __anonstruct_1051 FLAC__StreamEncoder;
#line 519 "/usr/include/FLAC/stream_encoder.h"
typedef FLAC__StreamEncoderReadStatus (*FLAC__StreamEncoderReadCallback)(FLAC__StreamEncoder * ,
                                                                         FLAC__byte [] ,
                                                                         size_t * ,
                                                                         void * );
#line 557 "/usr/include/FLAC/stream_encoder.h"
typedef FLAC__StreamEncoderWriteStatus (*FLAC__StreamEncoderWriteCallback)(FLAC__StreamEncoder * ,
                                                                           FLAC__byte [] ,
                                                                           size_t  ,
                                                                           uint32_t  ,
                                                                           uint32_t  ,
                                                                           void * );
#line 591 "/usr/include/FLAC/stream_encoder.h"
typedef FLAC__StreamEncoderSeekStatus (*FLAC__StreamEncoderSeekCallback)(FLAC__StreamEncoder * ,
                                                                         FLAC__uint64  ,
                                                                         void * );
#line 636 "/usr/include/FLAC/stream_encoder.h"
typedef FLAC__StreamEncoderTellStatus (*FLAC__StreamEncoderTellCallback)(FLAC__StreamEncoder * ,
                                                                         FLAC__uint64 * ,
                                                                         void * );
#line 655 "/usr/include/FLAC/stream_encoder.h"
typedef void (*FLAC__StreamEncoderMetadataCallback)(FLAC__StreamEncoder * , FLAC__StreamMetadata * ,
                                                    void * );
#line 678 "/usr/include/FLAC/stream_encoder.h"
typedef void (*FLAC__StreamEncoderProgressCallback)(FLAC__StreamEncoder * , FLAC__uint64  ,
                                                    FLAC__uint64  , uint32_t  , uint32_t  ,
                                                    void * );
#line 89 "/usr/include/FLAC/callback.h"
typedef void *FLAC__IOHandle;
#line 102 "/usr/include/FLAC/callback.h"
typedef size_t (*FLAC__IOCallback_Read)(void * , size_t  , size_t  , FLAC__IOHandle  );
#line 115 "/usr/include/FLAC/callback.h"
typedef size_t (*FLAC__IOCallback_Write)(void const   * , size_t  , size_t  , FLAC__IOHandle  );
#line 128 "/usr/include/FLAC/callback.h"
typedef int (*FLAC__IOCallback_Seek)(FLAC__IOHandle  , FLAC__int64  , int  );
#line 139 "/usr/include/FLAC/callback.h"
typedef FLAC__int64 (*FLAC__IOCallback_Tell)(FLAC__IOHandle  );
#line 150 "/usr/include/FLAC/callback.h"
typedef int (*FLAC__IOCallback_Eof)(FLAC__IOHandle  );
#line 160 "/usr/include/FLAC/callback.h"
typedef int (*FLAC__IOCallback_Close)(FLAC__IOHandle  );
#line 170 "/usr/include/FLAC/callback.h"
struct __anonstruct_1052 {
   FLAC__IOCallback_Read read ;
   FLAC__IOCallback_Write write ;
   FLAC__IOCallback_Seek seek ;
   FLAC__IOCallback_Tell tell ;
   FLAC__IOCallback_Eof eof ;
   FLAC__IOCallback_Close close ;
};
#line 177 "/usr/include/FLAC/callback.h"
typedef struct __anonstruct_1052 FLAC__IOCallbacks;
#line 297 "/usr/include/FLAC/metadata.h"
struct FLAC__Metadata_SimpleIterator ;
#line 303 "/usr/include/FLAC/metadata.h"
typedef struct FLAC__Metadata_SimpleIterator FLAC__Metadata_SimpleIterator;
#line 309
enum __anonenum__1053 {
    FLAC__METADATA_SIMPLE_ITERATOR_STATUS_OK = 0,
    FLAC__METADATA_SIMPLE_ITERATOR_STATUS_ILLEGAL_INPUT = 1,
    FLAC__METADATA_SIMPLE_ITERATOR_STATUS_ERROR_OPENING_FILE = 2,
    FLAC__METADATA_SIMPLE_ITERATOR_STATUS_NOT_A_FLAC_FILE = 3,
    FLAC__METADATA_SIMPLE_ITERATOR_STATUS_NOT_WRITABLE = 4,
    FLAC__METADATA_SIMPLE_ITERATOR_STATUS_BAD_METADATA = 5,
    FLAC__METADATA_SIMPLE_ITERATOR_STATUS_READ_ERROR = 6,
    FLAC__METADATA_SIMPLE_ITERATOR_STATUS_SEEK_ERROR = 7,
    FLAC__METADATA_SIMPLE_ITERATOR_STATUS_WRITE_ERROR = 8,
    FLAC__METADATA_SIMPLE_ITERATOR_STATUS_RENAME_ERROR = 9,
    FLAC__METADATA_SIMPLE_ITERATOR_STATUS_UNLINK_ERROR = 10,
    FLAC__METADATA_SIMPLE_ITERATOR_STATUS_MEMORY_ALLOCATION_ERROR = 11,
    FLAC__METADATA_SIMPLE_ITERATOR_STATUS_INTERNAL_ERROR = 12
} ;
#line 350 "/usr/include/FLAC/metadata.h"
typedef enum __anonenum__1053 FLAC__Metadata_SimpleIteratorStatus;
#line 711
struct FLAC__Metadata_Chain ;
#line 714 "/usr/include/FLAC/metadata.h"
typedef struct FLAC__Metadata_Chain FLAC__Metadata_Chain;
#line 716
struct FLAC__Metadata_Iterator ;
#line 719 "/usr/include/FLAC/metadata.h"
typedef struct FLAC__Metadata_Iterator FLAC__Metadata_Iterator;
#line 721
enum __anonenum__1054 {
    FLAC__METADATA_CHAIN_STATUS_OK = 0,
    FLAC__METADATA_CHAIN_STATUS_ILLEGAL_INPUT = 1,
    FLAC__METADATA_CHAIN_STATUS_ERROR_OPENING_FILE = 2,
    FLAC__METADATA_CHAIN_STATUS_NOT_A_FLAC_FILE = 3,
    FLAC__METADATA_CHAIN_STATUS_NOT_WRITABLE = 4,
    FLAC__METADATA_CHAIN_STATUS_BAD_METADATA = 5,
    FLAC__METADATA_CHAIN_STATUS_READ_ERROR = 6,
    FLAC__METADATA_CHAIN_STATUS_SEEK_ERROR = 7,
    FLAC__METADATA_CHAIN_STATUS_WRITE_ERROR = 8,
    FLAC__METADATA_CHAIN_STATUS_RENAME_ERROR = 9,
    FLAC__METADATA_CHAIN_STATUS_UNLINK_ERROR = 10,
    FLAC__METADATA_CHAIN_STATUS_MEMORY_ALLOCATION_ERROR = 11,
    FLAC__METADATA_CHAIN_STATUS_INTERNAL_ERROR = 12,
    FLAC__METADATA_CHAIN_STATUS_INVALID_CALLBACKS = 13,
    FLAC__METADATA_CHAIN_STATUS_READ_WRITE_MISMATCH = 14,
    FLAC__METADATA_CHAIN_STATUS_WRONG_WRITE_CALL = 15
} ;
#line 783 "/usr/include/FLAC/metadata.h"
typedef enum __anonenum__1054 FLAC__Metadata_ChainStatus;
#line 44 "/root/libsndfile/src/flac.c"
enum __anonenum__1055 {
    PFLAC_PCM_SHORT = 50,
    PFLAC_PCM_INT = 51,
    PFLAC_PCM_FLOAT = 52,
    PFLAC_PCM_DOUBLE = 53
} ;
#line 49 "/root/libsndfile/src/flac.c"
typedef enum __anonenum__1055 PFLAC_PCM;
#line 51 "/root/libsndfile/src/flac.c"
struct __anonstruct_1056 {
   FLAC__StreamDecoder *fsd ;
   FLAC__StreamEncoder *fse ;
   PFLAC_PCM pcmtype ;
   void *ptr ;
   unsigned int pos ;
   unsigned int len ;
   unsigned int remain ;
   FLAC__StreamMetadata *metadata ;
   FLAC__int32 * const  *wbuffer ;
   FLAC__int32 *rbuffer[8] ;
   FLAC__int32 *encbuffer ;
   unsigned int bufferpos ;
   FLAC__Frame *frame ;
   FLAC__bool bufferbackup ;
};
#line 70 "/root/libsndfile/src/flac.c"
typedef struct __anonstruct_1056 FLAC_PRIVATE;
#line 72 "/root/libsndfile/src/flac.c"
struct __anonstruct_1057 {
   char const   *tag ;
   int type ;
};
#line 75 "/root/libsndfile/src/flac.c"
typedef struct __anonstruct_1057 FLAC_TAG;
#line 46 "/usr/include/ctype.h"
enum __anonenum__510___10 {
    _ISupper___21 = 256,
    _ISlower___21 = 512,
    _ISalpha___21 = 1024,
    _ISdigit___21 = 2048,
    _ISxdigit___21 = 4096,
    _ISspace___21 = 8192,
    _ISprint___21 = 16384,
    _ISgraph___21 = 32768,
    _ISblank___21 = 1,
    _IScntrl___21 = 2,
    _ISpunct___21 = 4,
    _ISalnum___21 = 8
} ;
#line 46 "/root/libsndfile/src/sndfile.h"
enum __anonenum__524___7 {
    SF_FORMAT_WAV___45 = 65536,
    SF_FORMAT_AIFF___45 = 131072,
    SF_FORMAT_AU___45 = 196608,
    SF_FORMAT_RAW___45 = 262144,
    SF_FORMAT_PAF___45 = 327680,
    SF_FORMAT_SVX___45 = 393216,
    SF_FORMAT_NIST___45 = 458752,
    SF_FORMAT_VOC___45 = 524288,
    SF_FORMAT_IRCAM___45 = 655360,
    SF_FORMAT_W64___45 = 720896,
    SF_FORMAT_MAT4___45 = 786432,
    SF_FORMAT_MAT5___45 = 851968,
    SF_FORMAT_PVF___45 = 917504,
    SF_FORMAT_XI___45 = 983040,
    SF_FORMAT_HTK___45 = 1048576,
    SF_FORMAT_SDS___45 = 1114112,
    SF_FORMAT_AVR___45 = 1179648,
    SF_FORMAT_WAVEX___45 = 1245184,
    SF_FORMAT_SD2___45 = 1441792,
    SF_FORMAT_FLAC___45 = 1507328,
    SF_FORMAT_CAF___45 = 1572864,
    SF_FORMAT_WVE___45 = 1638400,
    SF_FORMAT_OGG___45 = 2097152,
    SF_FORMAT_MPC2K___45 = 2162688,
    SF_FORMAT_RF64___45 = 2228224,
    SF_FORMAT_PCM_S8___45 = 1,
    SF_FORMAT_PCM_16___45 = 2,
    SF_FORMAT_PCM_24___45 = 3,
    SF_FORMAT_PCM_32___45 = 4,
    SF_FORMAT_PCM_U8___45 = 5,
    SF_FORMAT_FLOAT___45 = 6,
    SF_FORMAT_DOUBLE___45 = 7,
    SF_FORMAT_ULAW___45 = 16,
    SF_FORMAT_ALAW___45 = 17,
    SF_FORMAT_IMA_ADPCM___45 = 18,
    SF_FORMAT_MS_ADPCM___45 = 19,
    SF_FORMAT_GSM610___45 = 32,
    SF_FORMAT_VOX_ADPCM___45 = 33,
    SF_FORMAT_G721_32___45 = 48,
    SF_FORMAT_G723_24___45 = 49,
    SF_FORMAT_G723_40___45 = 50,
    SF_FORMAT_DWVW_12___45 = 64,
    SF_FORMAT_DWVW_16___45 = 65,
    SF_FORMAT_DWVW_24___45 = 66,
    SF_FORMAT_DWVW_N___45 = 67,
    SF_FORMAT_DPCM_8___45 = 80,
    SF_FORMAT_DPCM_16___45 = 81,
    SF_FORMAT_VORBIS___45 = 96,
    SF_ENDIAN_FILE___45 = 0,
    SF_ENDIAN_LITTLE___45 = 268435456,
    SF_ENDIAN_BIG___45 = 536870912,
    SF_ENDIAN_CPU___45 = 805306368,
    SF_FORMAT_SUBMASK___45 = 65535,
    SF_FORMAT_TYPEMASK___45 = 268369920,
    SF_FORMAT_ENDMASK___45 = 805306368
} ;
#line 126
enum __anonenum__525___7 {
    SFC_GET_LIB_VERSION___45 = 4096,
    SFC_GET_LOG_INFO___45 = 4097,
    SFC_GET_CURRENT_SF_INFO___45 = 4098,
    SFC_GET_NORM_DOUBLE___45 = 4112,
    SFC_GET_NORM_FLOAT___45 = 4113,
    SFC_SET_NORM_DOUBLE___45 = 4114,
    SFC_SET_NORM_FLOAT___45 = 4115,
    SFC_SET_SCALE_FLOAT_INT_READ___45 = 4116,
    SFC_SET_SCALE_INT_FLOAT_WRITE___45 = 4117,
    SFC_GET_SIMPLE_FORMAT_COUNT___45 = 4128,
    SFC_GET_SIMPLE_FORMAT___45 = 4129,
    SFC_GET_FORMAT_INFO___45 = 4136,
    SFC_GET_FORMAT_MAJOR_COUNT___45 = 4144,
    SFC_GET_FORMAT_MAJOR___45 = 4145,
    SFC_GET_FORMAT_SUBTYPE_COUNT___45 = 4146,
    SFC_GET_FORMAT_SUBTYPE___45 = 4147,
    SFC_CALC_SIGNAL_MAX___45 = 4160,
    SFC_CALC_NORM_SIGNAL_MAX___45 = 4161,
    SFC_CALC_MAX_ALL_CHANNELS___45 = 4162,
    SFC_CALC_NORM_MAX_ALL_CHANNELS___45 = 4163,
    SFC_GET_SIGNAL_MAX___45 = 4164,
    SFC_GET_MAX_ALL_CHANNELS___45 = 4165,
    SFC_SET_ADD_PEAK_CHUNK___45 = 4176,
    SFC_SET_ADD_HEADER_PAD_CHUNK___45 = 4177,
    SFC_UPDATE_HEADER_NOW___45 = 4192,
    SFC_SET_UPDATE_HEADER_AUTO___45 = 4193,
    SFC_FILE_TRUNCATE___45 = 4224,
    SFC_SET_RAW_START_OFFSET___45 = 4240,
    SFC_SET_DITHER_ON_WRITE___45 = 4256,
    SFC_SET_DITHER_ON_READ___45 = 4257,
    SFC_GET_DITHER_INFO_COUNT___45 = 4258,
    SFC_GET_DITHER_INFO___45 = 4259,
    SFC_GET_EMBED_FILE_INFO___45 = 4272,
    SFC_SET_CLIPPING___45 = 4288,
    SFC_GET_CLIPPING___45 = 4289,
    SFC_GET_INSTRUMENT___45 = 4304,
    SFC_SET_INSTRUMENT___45 = 4305,
    SFC_GET_LOOP_INFO___45 = 4320,
    SFC_GET_BROADCAST_INFO___45 = 4336,
    SFC_SET_BROADCAST_INFO___45 = 4337,
    SFC_GET_CHANNEL_MAP_INFO___45 = 4352,
    SFC_SET_CHANNEL_MAP_INFO___45 = 4353,
    SFC_RAW_DATA_NEEDS_ENDSWAP___45 = 4368,
    SFC_WAVEX_SET_AMBISONIC___45 = 4608,
    SFC_WAVEX_GET_AMBISONIC___45 = 4609,
    SFC_SET_VBR_ENCODING_QUALITY___45 = 4864,
    SFC_TEST_IEEE_FLOAT_REPLACE___45 = 24577,
    SFC_SET_ADD_DITHER_ON_WRITE___45 = 4208,
    SFC_SET_ADD_DITHER_ON_READ___45 = 4209
} ;
#line 216
enum __anonenum__526___7 {
    SF_STR_TITLE___45 = 1,
    SF_STR_COPYRIGHT___45 = 2,
    SF_STR_SOFTWARE___45 = 3,
    SF_STR_ARTIST___45 = 4,
    SF_STR_COMMENT___45 = 5,
    SF_STR_DATE___45 = 6,
    SF_STR_ALBUM___45 = 7,
    SF_STR_LICENSE___45 = 8
} ;
#line 235
enum __anonenum__527___7 {
    SF_FALSE___45 = 0,
    SF_TRUE___45 = 1,
    SFM_READ___45 = 16,
    SFM_WRITE___45 = 32,
    SFM_RDWR___45 = 48,
    SF_AMBISONIC_NONE___45 = 64,
    SF_AMBISONIC_B_FORMAT___45 = 65
} ;
#line 255
enum __anonenum__528___7 {
    SF_ERR_NO_ERROR___45 = 0,
    SF_ERR_UNRECOGNISED_FORMAT___45 = 1,
    SF_ERR_SYSTEM___45 = 2,
    SF_ERR_MALFORMED_FILE___45 = 3,
    SF_ERR_UNSUPPORTED_ENCODING___45 = 4
} ;
#line 267
enum __anonenum__529___7 {
    SF_CHANNEL_MAP_INVALID___45 = 0,
    SF_CHANNEL_MAP_MONO___45 = 1,
    SF_CHANNEL_MAP_LEFT___45 = 2,
    SF_CHANNEL_MAP_RIGHT___45 = 3,
    SF_CHANNEL_MAP_CENTER___45 = 4,
    SF_CHANNEL_MAP_FRONT_LEFT___45 = 5,
    SF_CHANNEL_MAP_FRONT_RIGHT___45 = 6,
    SF_CHANNEL_MAP_FRONT_CENTER___45 = 7,
    SF_CHANNEL_MAP_REAR_CENTER___45 = 8,
    SF_CHANNEL_MAP_REAR_LEFT___45 = 9,
    SF_CHANNEL_MAP_REAR_RIGHT___45 = 10,
    SF_CHANNEL_MAP_LFE___45 = 11,
    SF_CHANNEL_MAP_FRONT_LEFT_OF_CENTER___45 = 12,
    SF_CHANNEL_MAP_FRONT_RIGHT_OF_CENTER___45 = 13,
    SF_CHANNEL_MAP_SIDE_LEFT___45 = 14,
    SF_CHANNEL_MAP_SIDE_RIGHT___45 = 15,
    SF_CHANNEL_MAP_TOP_CENTER___45 = 16,
    SF_CHANNEL_MAP_TOP_FRONT_LEFT___45 = 17,
    SF_CHANNEL_MAP_TOP_FRONT_RIGHT___45 = 18,
    SF_CHANNEL_MAP_TOP_FRONT_CENTER___45 = 19,
    SF_CHANNEL_MAP_TOP_REAR_LEFT___45 = 20,
    SF_CHANNEL_MAP_TOP_REAR_RIGHT___45 = 21,
    SF_CHANNEL_MAP_TOP_REAR_CENTER___45 = 22
} ;
#line 352
enum __anonenum__531___7 {
    SFD_DEFAULT_LEVEL___45 = 0,
    SFD_CUSTOM_LEVEL___45 = 1073741824,
    SFD_NO_DITHER___45 = 500,
    SFD_WHITE___45 = 501,
    SFD_TRIANGULAR_PDF___45 = 502
} ;
#line 380
enum __anonenum__534___7 {
    SF_LOOP_NONE___45 = 800,
    SF_LOOP_FORWARD___45 = 801,
    SF_LOOP_BACKWARD___45 = 802,
    SF_LOOP_ALTERNATING___45 = 803
} ;
#line 121 "/root/libsndfile/src/common.h"
enum __anonenum__543___7 {
    SF_PEAK_START___45 = 42,
    SF_PEAK_END___45 = 43,
    SF_SCALE_MAX___45 = 52,
    SF_SCALE_MIN___45 = 53,
    SF_STR_ALLOW_START___45 = 256,
    SF_STR_ALLOW_END___45 = 512,
    SF_STR_LOCATE_START___45 = 1024,
    SF_STR_LOCATE_END___45 = 2048,
    SFD_TYPEMASK___45 = 268435455
} ;
#line 149
enum __anonenum__544___7 {
    SF_FORMAT_TXW___45 = 67305472,
    SF_FORMAT_DWD___45 = 67371008,
    SF_FORMAT_REX___45 = 67764224,
    SF_FORMAT_REX2___45 = 67960832,
    SF_FORMAT_KRZ___45 = 68026368,
    SF_FORMAT_WMA___45 = 68157440,
    SF_FORMAT_SHN___45 = 68222976,
    SF_FORMAT_SVX_FIB___45 = 4128,
    SF_FORMAT_SVX_EXP___45 = 4129,
    SF_FORMAT_PCM_N___45 = 4144
} ;
#line 405
enum __anonenum__550___7 {
    SFE_NO_ERROR___45 = 0,
    SFE_BAD_OPEN_FORMAT___45 = 1,
    SFE_SYSTEM___45 = 2,
    SFE_MALFORMED_FILE___45 = 3,
    SFE_UNSUPPORTED_ENCODING___45 = 4,
    SFE_ZERO_MAJOR_FORMAT___45 = 5,
    SFE_ZERO_MINOR_FORMAT___45 = 6,
    SFE_BAD_FILE___45 = 7,
    SFE_BAD_FILE_READ___45 = 8,
    SFE_OPEN_FAILED___45 = 9,
    SFE_BAD_SNDFILE_PTR___45 = 10,
    SFE_BAD_SF_INFO_PTR___45 = 11,
    SFE_BAD_SF_INCOMPLETE___45 = 12,
    SFE_BAD_FILE_PTR___45 = 13,
    SFE_BAD_INT_PTR___45 = 14,
    SFE_BAD_STAT_SIZE___45 = 15,
    SFE_MALLOC_FAILED___45 = 16,
    SFE_UNIMPLEMENTED___45 = 17,
    SFE_BAD_READ_ALIGN___45 = 18,
    SFE_BAD_WRITE_ALIGN___45 = 19,
    SFE_UNKNOWN_FORMAT___45 = 20,
    SFE_NOT_READMODE___45 = 21,
    SFE_NOT_WRITEMODE___45 = 22,
    SFE_BAD_MODE_RW___45 = 23,
    SFE_BAD_SF_INFO___45 = 24,
    SFE_BAD_OFFSET___45 = 25,
    SFE_NO_EMBED_SUPPORT___45 = 26,
    SFE_NO_EMBEDDED_RDWR___45 = 27,
    SFE_NO_PIPE_WRITE___45 = 28,
    SFE_INTERNAL___45 = 29,
    SFE_BAD_COMMAND_PARAM___45 = 30,
    SFE_BAD_ENDIAN___45 = 31,
    SFE_CHANNEL_COUNT_ZERO___45 = 32,
    SFE_CHANNEL_COUNT___45 = 33,
    SFE_BAD_VIRTUAL_IO___45 = 34,
    SFE_INTERLEAVE_MODE___45 = 35,
    SFE_INTERLEAVE_SEEK___45 = 36,
    SFE_INTERLEAVE_READ___45 = 37,
    SFE_BAD_SEEK___45 = 38,
    SFE_NOT_SEEKABLE___45 = 39,
    SFE_AMBIGUOUS_SEEK___45 = 40,
    SFE_WRONG_SEEK___45 = 41,
    SFE_SEEK_FAILED___45 = 42,
    SFE_BAD_OPEN_MODE___45 = 43,
    SFE_OPEN_PIPE_RDWR___45 = 44,
    SFE_RDWR_POSITION___45 = 45,
    SFE_RDWR_BAD_HEADER___45 = 46,
    SFE_CMD_HAS_DATA___45 = 47,
    SFE_BAD_BROADCAST_INFO_SIZE___45 = 48,
    SFE_STR_NO_SUPPORT___45 = 49,
    SFE_STR_NOT_WRITE___45 = 50,
    SFE_STR_MAX_DATA___45 = 51,
    SFE_STR_MAX_COUNT___45 = 52,
    SFE_STR_BAD_TYPE___45 = 53,
    SFE_STR_NO_ADD_END___45 = 54,
    SFE_STR_BAD_STRING___45 = 55,
    SFE_STR_WEIRD___45 = 56,
    SFE_WAV_NO_RIFF___45 = 57,
    SFE_WAV_NO_WAVE___45 = 58,
    SFE_WAV_NO_FMT___45 = 59,
    SFE_WAV_BAD_FMT___45 = 60,
    SFE_WAV_FMT_SHORT___45 = 61,
    SFE_WAV_BAD_FACT___45 = 62,
    SFE_WAV_BAD_PEAK___45 = 63,
    SFE_WAV_PEAK_B4_FMT___45 = 64,
    SFE_WAV_BAD_FORMAT___45 = 65,
    SFE_WAV_BAD_BLOCKALIGN___45 = 66,
    SFE_WAV_NO_DATA___45 = 67,
    SFE_WAV_BAD_LIST___45 = 68,
    SFE_WAV_ADPCM_NOT4BIT___45 = 69,
    SFE_WAV_ADPCM_CHANNELS___45 = 70,
    SFE_WAV_GSM610_FORMAT___45 = 71,
    SFE_WAV_UNKNOWN_CHUNK___45 = 72,
    SFE_WAV_WVPK_DATA___45 = 73,
    SFE_AIFF_NO_FORM___45 = 74,
    SFE_AIFF_AIFF_NO_FORM___45 = 75,
    SFE_AIFF_COMM_NO_FORM___45 = 76,
    SFE_AIFF_SSND_NO_COMM___45 = 77,
    SFE_AIFF_UNKNOWN_CHUNK___45 = 78,
    SFE_AIFF_COMM_CHUNK_SIZE___45 = 79,
    SFE_AIFF_BAD_COMM_CHUNK___45 = 80,
    SFE_AIFF_PEAK_B4_COMM___45 = 81,
    SFE_AIFF_BAD_PEAK___45 = 82,
    SFE_AIFF_NO_SSND___45 = 83,
    SFE_AIFF_NO_DATA___45 = 84,
    SFE_AIFF_RW_SSND_NOT_LAST___45 = 85,
    SFE_AU_UNKNOWN_FORMAT___45 = 86,
    SFE_AU_NO_DOTSND___45 = 87,
    SFE_AU_EMBED_BAD_LEN___45 = 88,
    SFE_RAW_READ_BAD_SPEC___45 = 89,
    SFE_RAW_BAD_BITWIDTH___45 = 90,
    SFE_RAW_BAD_FORMAT___45 = 91,
    SFE_PAF_NO_MARKER___45 = 92,
    SFE_PAF_VERSION___45 = 93,
    SFE_PAF_UNKNOWN_FORMAT___45 = 94,
    SFE_PAF_SHORT_HEADER___45 = 95,
    SFE_SVX_NO_FORM___45 = 96,
    SFE_SVX_NO_BODY___45 = 97,
    SFE_SVX_NO_DATA___45 = 98,
    SFE_SVX_BAD_COMP___45 = 99,
    SFE_SVX_BAD_NAME_LENGTH___45 = 100,
    SFE_NIST_BAD_HEADER___45 = 101,
    SFE_NIST_CRLF_CONVERISON___45 = 102,
    SFE_NIST_BAD_ENCODING___45 = 103,
    SFE_VOC_NO_CREATIVE___45 = 104,
    SFE_VOC_BAD_FORMAT___45 = 105,
    SFE_VOC_BAD_VERSION___45 = 106,
    SFE_VOC_BAD_MARKER___45 = 107,
    SFE_VOC_BAD_SECTIONS___45 = 108,
    SFE_VOC_MULTI_SAMPLERATE___45 = 109,
    SFE_VOC_MULTI_SECTION___45 = 110,
    SFE_VOC_MULTI_PARAM___45 = 111,
    SFE_VOC_SECTION_COUNT___45 = 112,
    SFE_VOC_NO_PIPE___45 = 113,
    SFE_IRCAM_NO_MARKER___45 = 114,
    SFE_IRCAM_BAD_CHANNELS___45 = 115,
    SFE_IRCAM_UNKNOWN_FORMAT___45 = 116,
    SFE_W64_64_BIT___45 = 117,
    SFE_W64_NO_RIFF___45 = 118,
    SFE_W64_NO_WAVE___45 = 119,
    SFE_W64_NO_DATA___45 = 120,
    SFE_W64_ADPCM_NOT4BIT___45 = 121,
    SFE_W64_ADPCM_CHANNELS___45 = 122,
    SFE_W64_GSM610_FORMAT___45 = 123,
    SFE_MAT4_BAD_NAME___45 = 124,
    SFE_MAT4_NO_SAMPLERATE___45 = 125,
    SFE_MAT5_BAD_ENDIAN___45 = 126,
    SFE_MAT5_NO_BLOCK___45 = 127,
    SFE_MAT5_SAMPLE_RATE___45 = 128,
    SFE_PVF_NO_PVF1___45 = 129,
    SFE_PVF_BAD_HEADER___45 = 130,
    SFE_PVF_BAD_BITWIDTH___45 = 131,
    SFE_DWVW_BAD_BITWIDTH___45 = 132,
    SFE_G72X_NOT_MONO___45 = 133,
    SFE_XI_BAD_HEADER___45 = 134,
    SFE_XI_EXCESS_SAMPLES___45 = 135,
    SFE_XI_NO_PIPE___45 = 136,
    SFE_HTK_NO_PIPE___45 = 137,
    SFE_SDS_NOT_SDS___45 = 138,
    SFE_SDS_BAD_BIT_WIDTH___45 = 139,
    SFE_SD2_FD_DISALLOWED___45 = 140,
    SFE_SD2_BAD_DATA_OFFSET___45 = 141,
    SFE_SD2_BAD_MAP_OFFSET___45 = 142,
    SFE_SD2_BAD_DATA_LENGTH___45 = 143,
    SFE_SD2_BAD_MAP_LENGTH___45 = 144,
    SFE_SD2_BAD_RSRC___45 = 145,
    SFE_SD2_BAD_SAMPLE_SIZE___45 = 146,
    SFE_FLAC_BAD_HEADER___45 = 147,
    SFE_FLAC_NEW_DECODER___45 = 148,
    SFE_FLAC_INIT_DECODER___45 = 149,
    SFE_FLAC_LOST_SYNC___45 = 150,
    SFE_FLAC_BAD_SAMPLE_RATE___45 = 151,
    SFE_FLAC_UNKOWN_ERROR___45 = 152,
    SFE_WVE_NOT_WVE___45 = 153,
    SFE_WVE_NO_PIPE___45 = 154,
    SFE_VORBIS_ENCODER_BUG___45 = 155,
    SFE_RF64_NOT_RF64___45 = 156,
    SFE_MAX_ERROR___45 = 157
} ;
#line 823
enum __anonenum__554___7 {
    SFC_TEST_AIFF_ADD_INST_CHUNK___45 = 8192,
    SFC_TEST_WAV_ADD_INFO_CHUNK___45 = 8208
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__598___2 {
    _ISupper___22 = 256,
    _ISlower___22 = 512,
    _ISalpha___22 = 1024,
    _ISdigit___22 = 2048,
    _ISxdigit___22 = 4096,
    _ISspace___22 = 8192,
    _ISprint___22 = 16384,
    _ISgraph___22 = 32768,
    _ISblank___22 = 1,
    _IScntrl___22 = 2,
    _ISpunct___22 = 4,
    _ISalnum___22 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__1058 {
    FP_NAN___20 = 0,
    FP_INFINITE___20 = 1,
    FP_ZERO___20 = 2,
    FP_SUBNORMAL___20 = 3,
    FP_NORMAL___20 = 4
} ;
#line 46 "/root/libsndfile/src/sndfile.h"
enum __anonenum__1059 {
    SF_FORMAT_WAV___46 = 65536,
    SF_FORMAT_AIFF___46 = 131072,
    SF_FORMAT_AU___46 = 196608,
    SF_FORMAT_RAW___46 = 262144,
    SF_FORMAT_PAF___46 = 327680,
    SF_FORMAT_SVX___46 = 393216,
    SF_FORMAT_NIST___46 = 458752,
    SF_FORMAT_VOC___46 = 524288,
    SF_FORMAT_IRCAM___46 = 655360,
    SF_FORMAT_W64___46 = 720896,
    SF_FORMAT_MAT4___46 = 786432,
    SF_FORMAT_MAT5___46 = 851968,
    SF_FORMAT_PVF___46 = 917504,
    SF_FORMAT_XI___46 = 983040,
    SF_FORMAT_HTK___46 = 1048576,
    SF_FORMAT_SDS___46 = 1114112,
    SF_FORMAT_AVR___46 = 1179648,
    SF_FORMAT_WAVEX___46 = 1245184,
    SF_FORMAT_SD2___46 = 1441792,
    SF_FORMAT_FLAC___46 = 1507328,
    SF_FORMAT_CAF___46 = 1572864,
    SF_FORMAT_WVE___46 = 1638400,
    SF_FORMAT_OGG___46 = 2097152,
    SF_FORMAT_MPC2K___46 = 2162688,
    SF_FORMAT_RF64___46 = 2228224,
    SF_FORMAT_PCM_S8___46 = 1,
    SF_FORMAT_PCM_16___46 = 2,
    SF_FORMAT_PCM_24___46 = 3,
    SF_FORMAT_PCM_32___46 = 4,
    SF_FORMAT_PCM_U8___46 = 5,
    SF_FORMAT_FLOAT___46 = 6,
    SF_FORMAT_DOUBLE___46 = 7,
    SF_FORMAT_ULAW___46 = 16,
    SF_FORMAT_ALAW___46 = 17,
    SF_FORMAT_IMA_ADPCM___46 = 18,
    SF_FORMAT_MS_ADPCM___46 = 19,
    SF_FORMAT_GSM610___46 = 32,
    SF_FORMAT_VOX_ADPCM___46 = 33,
    SF_FORMAT_G721_32___46 = 48,
    SF_FORMAT_G723_24___46 = 49,
    SF_FORMAT_G723_40___46 = 50,
    SF_FORMAT_DWVW_12___46 = 64,
    SF_FORMAT_DWVW_16___46 = 65,
    SF_FORMAT_DWVW_24___46 = 66,
    SF_FORMAT_DWVW_N___46 = 67,
    SF_FORMAT_DPCM_8___46 = 80,
    SF_FORMAT_DPCM_16___46 = 81,
    SF_FORMAT_VORBIS___46 = 96,
    SF_ENDIAN_FILE___46 = 0,
    SF_ENDIAN_LITTLE___46 = 268435456,
    SF_ENDIAN_BIG___46 = 536870912,
    SF_ENDIAN_CPU___46 = 805306368,
    SF_FORMAT_SUBMASK___46 = 65535,
    SF_FORMAT_TYPEMASK___46 = 268369920,
    SF_FORMAT_ENDMASK___46 = 805306368
} ;
#line 126
enum __anonenum__1060 {
    SFC_GET_LIB_VERSION___46 = 4096,
    SFC_GET_LOG_INFO___46 = 4097,
    SFC_GET_CURRENT_SF_INFO___46 = 4098,
    SFC_GET_NORM_DOUBLE___46 = 4112,
    SFC_GET_NORM_FLOAT___46 = 4113,
    SFC_SET_NORM_DOUBLE___46 = 4114,
    SFC_SET_NORM_FLOAT___46 = 4115,
    SFC_SET_SCALE_FLOAT_INT_READ___46 = 4116,
    SFC_SET_SCALE_INT_FLOAT_WRITE___46 = 4117,
    SFC_GET_SIMPLE_FORMAT_COUNT___46 = 4128,
    SFC_GET_SIMPLE_FORMAT___46 = 4129,
    SFC_GET_FORMAT_INFO___46 = 4136,
    SFC_GET_FORMAT_MAJOR_COUNT___46 = 4144,
    SFC_GET_FORMAT_MAJOR___46 = 4145,
    SFC_GET_FORMAT_SUBTYPE_COUNT___46 = 4146,
    SFC_GET_FORMAT_SUBTYPE___46 = 4147,
    SFC_CALC_SIGNAL_MAX___46 = 4160,
    SFC_CALC_NORM_SIGNAL_MAX___46 = 4161,
    SFC_CALC_MAX_ALL_CHANNELS___46 = 4162,
    SFC_CALC_NORM_MAX_ALL_CHANNELS___46 = 4163,
    SFC_GET_SIGNAL_MAX___46 = 4164,
    SFC_GET_MAX_ALL_CHANNELS___46 = 4165,
    SFC_SET_ADD_PEAK_CHUNK___46 = 4176,
    SFC_SET_ADD_HEADER_PAD_CHUNK___46 = 4177,
    SFC_UPDATE_HEADER_NOW___46 = 4192,
    SFC_SET_UPDATE_HEADER_AUTO___46 = 4193,
    SFC_FILE_TRUNCATE___46 = 4224,
    SFC_SET_RAW_START_OFFSET___46 = 4240,
    SFC_SET_DITHER_ON_WRITE___46 = 4256,
    SFC_SET_DITHER_ON_READ___46 = 4257,
    SFC_GET_DITHER_INFO_COUNT___46 = 4258,
    SFC_GET_DITHER_INFO___46 = 4259,
    SFC_GET_EMBED_FILE_INFO___46 = 4272,
    SFC_SET_CLIPPING___46 = 4288,
    SFC_GET_CLIPPING___46 = 4289,
    SFC_GET_INSTRUMENT___46 = 4304,
    SFC_SET_INSTRUMENT___46 = 4305,
    SFC_GET_LOOP_INFO___46 = 4320,
    SFC_GET_BROADCAST_INFO___46 = 4336,
    SFC_SET_BROADCAST_INFO___46 = 4337,
    SFC_GET_CHANNEL_MAP_INFO___46 = 4352,
    SFC_SET_CHANNEL_MAP_INFO___46 = 4353,
    SFC_RAW_DATA_NEEDS_ENDSWAP___46 = 4368,
    SFC_WAVEX_SET_AMBISONIC___46 = 4608,
    SFC_WAVEX_GET_AMBISONIC___46 = 4609,
    SFC_SET_VBR_ENCODING_QUALITY___46 = 4864,
    SFC_TEST_IEEE_FLOAT_REPLACE___46 = 24577,
    SFC_SET_ADD_DITHER_ON_WRITE___46 = 4208,
    SFC_SET_ADD_DITHER_ON_READ___46 = 4209
} ;
#line 216
enum __anonenum__1061 {
    SF_STR_TITLE___46 = 1,
    SF_STR_COPYRIGHT___46 = 2,
    SF_STR_SOFTWARE___46 = 3,
    SF_STR_ARTIST___46 = 4,
    SF_STR_COMMENT___46 = 5,
    SF_STR_DATE___46 = 6,
    SF_STR_ALBUM___46 = 7,
    SF_STR_LICENSE___46 = 8
} ;
#line 235
enum __anonenum__1062 {
    SF_FALSE___46 = 0,
    SF_TRUE___46 = 1,
    SFM_READ___46 = 16,
    SFM_WRITE___46 = 32,
    SFM_RDWR___46 = 48,
    SF_AMBISONIC_NONE___46 = 64,
    SF_AMBISONIC_B_FORMAT___46 = 65
} ;
#line 255
enum __anonenum__1063 {
    SF_ERR_NO_ERROR___46 = 0,
    SF_ERR_UNRECOGNISED_FORMAT___46 = 1,
    SF_ERR_SYSTEM___46 = 2,
    SF_ERR_MALFORMED_FILE___46 = 3,
    SF_ERR_UNSUPPORTED_ENCODING___46 = 4
} ;
#line 267
enum __anonenum__1064 {
    SF_CHANNEL_MAP_INVALID___46 = 0,
    SF_CHANNEL_MAP_MONO___46 = 1,
    SF_CHANNEL_MAP_LEFT___46 = 2,
    SF_CHANNEL_MAP_RIGHT___46 = 3,
    SF_CHANNEL_MAP_CENTER___46 = 4,
    SF_CHANNEL_MAP_FRONT_LEFT___46 = 5,
    SF_CHANNEL_MAP_FRONT_RIGHT___46 = 6,
    SF_CHANNEL_MAP_FRONT_CENTER___46 = 7,
    SF_CHANNEL_MAP_REAR_CENTER___46 = 8,
    SF_CHANNEL_MAP_REAR_LEFT___46 = 9,
    SF_CHANNEL_MAP_REAR_RIGHT___46 = 10,
    SF_CHANNEL_MAP_LFE___46 = 11,
    SF_CHANNEL_MAP_FRONT_LEFT_OF_CENTER___46 = 12,
    SF_CHANNEL_MAP_FRONT_RIGHT_OF_CENTER___46 = 13,
    SF_CHANNEL_MAP_SIDE_LEFT___46 = 14,
    SF_CHANNEL_MAP_SIDE_RIGHT___46 = 15,
    SF_CHANNEL_MAP_TOP_CENTER___46 = 16,
    SF_CHANNEL_MAP_TOP_FRONT_LEFT___46 = 17,
    SF_CHANNEL_MAP_TOP_FRONT_RIGHT___46 = 18,
    SF_CHANNEL_MAP_TOP_FRONT_CENTER___46 = 19,
    SF_CHANNEL_MAP_TOP_REAR_LEFT___46 = 20,
    SF_CHANNEL_MAP_TOP_REAR_RIGHT___46 = 21,
    SF_CHANNEL_MAP_TOP_REAR_CENTER___46 = 22
} ;
#line 352
enum __anonenum__1066 {
    SFD_DEFAULT_LEVEL___46 = 0,
    SFD_CUSTOM_LEVEL___46 = 1073741824,
    SFD_NO_DITHER___46 = 500,
    SFD_WHITE___46 = 501,
    SFD_TRIANGULAR_PDF___46 = 502
} ;
#line 380
enum __anonstruct_159 {
    SF_LOOP_NONE___46 = 800,
    SF_LOOP_FORWARD___46 = 801,
    SF_LOOP_BACKWARD___46 = 802,
    SF_LOOP_ALTERNATING___46 = 803
} ;
#line 121 "/root/libsndfile/src/common.h"
enum __anonenum__1073 {
    SF_PEAK_START___46 = 42,
    SF_PEAK_END___46 = 43,
    SF_SCALE_MAX___46 = 52,
    SF_SCALE_MIN___46 = 53,
    SF_STR_ALLOW_START___46 = 256,
    SF_STR_ALLOW_END___46 = 512,
    SF_STR_LOCATE_START___46 = 1024,
    SF_STR_LOCATE_END___46 = 2048,
    SFD_TYPEMASK___46 = 268435455
} ;
#line 149
enum __anonenum__1074 {
    SF_FORMAT_TXW___46 = 67305472,
    SF_FORMAT_DWD___46 = 67371008,
    SF_FORMAT_REX___46 = 67764224,
    SF_FORMAT_REX2___46 = 67960832,
    SF_FORMAT_KRZ___46 = 68026368,
    SF_FORMAT_WMA___46 = 68157440,
    SF_FORMAT_SHN___46 = 68222976,
    SF_FORMAT_SVX_FIB___46 = 4128,
    SF_FORMAT_SVX_EXP___46 = 4129,
    SF_FORMAT_PCM_N___46 = 4144
} ;
#line 405
enum __anonenum__1079 {
    SFE_NO_ERROR___46 = 0,
    SFE_BAD_OPEN_FORMAT___46 = 1,
    SFE_SYSTEM___46 = 2,
    SFE_MALFORMED_FILE___46 = 3,
    SFE_UNSUPPORTED_ENCODING___46 = 4,
    SFE_ZERO_MAJOR_FORMAT___46 = 5,
    SFE_ZERO_MINOR_FORMAT___46 = 6,
    SFE_BAD_FILE___46 = 7,
    SFE_BAD_FILE_READ___46 = 8,
    SFE_OPEN_FAILED___46 = 9,
    SFE_BAD_SNDFILE_PTR___46 = 10,
    SFE_BAD_SF_INFO_PTR___46 = 11,
    SFE_BAD_SF_INCOMPLETE___46 = 12,
    SFE_BAD_FILE_PTR___46 = 13,
    SFE_BAD_INT_PTR___46 = 14,
    SFE_BAD_STAT_SIZE___46 = 15,
    SFE_MALLOC_FAILED___46 = 16,
    SFE_UNIMPLEMENTED___46 = 17,
    SFE_BAD_READ_ALIGN___46 = 18,
    SFE_BAD_WRITE_ALIGN___46 = 19,
    SFE_UNKNOWN_FORMAT___46 = 20,
    SFE_NOT_READMODE___46 = 21,
    SFE_NOT_WRITEMODE___46 = 22,
    SFE_BAD_MODE_RW___46 = 23,
    SFE_BAD_SF_INFO___46 = 24,
    SFE_BAD_OFFSET___46 = 25,
    SFE_NO_EMBED_SUPPORT___46 = 26,
    SFE_NO_EMBEDDED_RDWR___46 = 27,
    SFE_NO_PIPE_WRITE___46 = 28,
    SFE_INTERNAL___46 = 29,
    SFE_BAD_COMMAND_PARAM___46 = 30,
    SFE_BAD_ENDIAN___46 = 31,
    SFE_CHANNEL_COUNT_ZERO___46 = 32,
    SFE_CHANNEL_COUNT___46 = 33,
    SFE_BAD_VIRTUAL_IO___46 = 34,
    SFE_INTERLEAVE_MODE___46 = 35,
    SFE_INTERLEAVE_SEEK___46 = 36,
    SFE_INTERLEAVE_READ___46 = 37,
    SFE_BAD_SEEK___46 = 38,
    SFE_NOT_SEEKABLE___46 = 39,
    SFE_AMBIGUOUS_SEEK___46 = 40,
    SFE_WRONG_SEEK___46 = 41,
    SFE_SEEK_FAILED___46 = 42,
    SFE_BAD_OPEN_MODE___46 = 43,
    SFE_OPEN_PIPE_RDWR___46 = 44,
    SFE_RDWR_POSITION___46 = 45,
    SFE_RDWR_BAD_HEADER___46 = 46,
    SFE_CMD_HAS_DATA___46 = 47,
    SFE_BAD_BROADCAST_INFO_SIZE___46 = 48,
    SFE_STR_NO_SUPPORT___46 = 49,
    SFE_STR_NOT_WRITE___46 = 50,
    SFE_STR_MAX_DATA___46 = 51,
    SFE_STR_MAX_COUNT___46 = 52,
    SFE_STR_BAD_TYPE___46 = 53,
    SFE_STR_NO_ADD_END___46 = 54,
    SFE_STR_BAD_STRING___46 = 55,
    SFE_STR_WEIRD___46 = 56,
    SFE_WAV_NO_RIFF___46 = 57,
    SFE_WAV_NO_WAVE___46 = 58,
    SFE_WAV_NO_FMT___46 = 59,
    SFE_WAV_BAD_FMT___46 = 60,
    SFE_WAV_FMT_SHORT___46 = 61,
    SFE_WAV_BAD_FACT___46 = 62,
    SFE_WAV_BAD_PEAK___46 = 63,
    SFE_WAV_PEAK_B4_FMT___46 = 64,
    SFE_WAV_BAD_FORMAT___46 = 65,
    SFE_WAV_BAD_BLOCKALIGN___46 = 66,
    SFE_WAV_NO_DATA___46 = 67,
    SFE_WAV_BAD_LIST___46 = 68,
    SFE_WAV_ADPCM_NOT4BIT___46 = 69,
    SFE_WAV_ADPCM_CHANNELS___46 = 70,
    SFE_WAV_GSM610_FORMAT___46 = 71,
    SFE_WAV_UNKNOWN_CHUNK___46 = 72,
    SFE_WAV_WVPK_DATA___46 = 73,
    SFE_AIFF_NO_FORM___46 = 74,
    SFE_AIFF_AIFF_NO_FORM___46 = 75,
    SFE_AIFF_COMM_NO_FORM___46 = 76,
    SFE_AIFF_SSND_NO_COMM___46 = 77,
    SFE_AIFF_UNKNOWN_CHUNK___46 = 78,
    SFE_AIFF_COMM_CHUNK_SIZE___46 = 79,
    SFE_AIFF_BAD_COMM_CHUNK___46 = 80,
    SFE_AIFF_PEAK_B4_COMM___46 = 81,
    SFE_AIFF_BAD_PEAK___46 = 82,
    SFE_AIFF_NO_SSND___46 = 83,
    SFE_AIFF_NO_DATA___46 = 84,
    SFE_AIFF_RW_SSND_NOT_LAST___46 = 85,
    SFE_AU_UNKNOWN_FORMAT___46 = 86,
    SFE_AU_NO_DOTSND___46 = 87,
    SFE_AU_EMBED_BAD_LEN___46 = 88,
    SFE_RAW_READ_BAD_SPEC___46 = 89,
    SFE_RAW_BAD_BITWIDTH___46 = 90,
    SFE_RAW_BAD_FORMAT___46 = 91,
    SFE_PAF_NO_MARKER___46 = 92,
    SFE_PAF_VERSION___46 = 93,
    SFE_PAF_UNKNOWN_FORMAT___46 = 94,
    SFE_PAF_SHORT_HEADER___46 = 95,
    SFE_SVX_NO_FORM___46 = 96,
    SFE_SVX_NO_BODY___46 = 97,
    SFE_SVX_NO_DATA___46 = 98,
    SFE_SVX_BAD_COMP___46 = 99,
    SFE_SVX_BAD_NAME_LENGTH___46 = 100,
    SFE_NIST_BAD_HEADER___46 = 101,
    SFE_NIST_CRLF_CONVERISON___46 = 102,
    SFE_NIST_BAD_ENCODING___46 = 103,
    SFE_VOC_NO_CREATIVE___46 = 104,
    SFE_VOC_BAD_FORMAT___46 = 105,
    SFE_VOC_BAD_VERSION___46 = 106,
    SFE_VOC_BAD_MARKER___46 = 107,
    SFE_VOC_BAD_SECTIONS___46 = 108,
    SFE_VOC_MULTI_SAMPLERATE___46 = 109,
    SFE_VOC_MULTI_SECTION___46 = 110,
    SFE_VOC_MULTI_PARAM___46 = 111,
    SFE_VOC_SECTION_COUNT___46 = 112,
    SFE_VOC_NO_PIPE___46 = 113,
    SFE_IRCAM_NO_MARKER___46 = 114,
    SFE_IRCAM_BAD_CHANNELS___46 = 115,
    SFE_IRCAM_UNKNOWN_FORMAT___46 = 116,
    SFE_W64_64_BIT___46 = 117,
    SFE_W64_NO_RIFF___46 = 118,
    SFE_W64_NO_WAVE___46 = 119,
    SFE_W64_NO_DATA___46 = 120,
    SFE_W64_ADPCM_NOT4BIT___46 = 121,
    SFE_W64_ADPCM_CHANNELS___46 = 122,
    SFE_W64_GSM610_FORMAT___46 = 123,
    SFE_MAT4_BAD_NAME___46 = 124,
    SFE_MAT4_NO_SAMPLERATE___46 = 125,
    SFE_MAT5_BAD_ENDIAN___46 = 126,
    SFE_MAT5_NO_BLOCK___46 = 127,
    SFE_MAT5_SAMPLE_RATE___46 = 128,
    SFE_PVF_NO_PVF1___46 = 129,
    SFE_PVF_BAD_HEADER___46 = 130,
    SFE_PVF_BAD_BITWIDTH___46 = 131,
    SFE_DWVW_BAD_BITWIDTH___46 = 132,
    SFE_G72X_NOT_MONO___46 = 133,
    SFE_XI_BAD_HEADER___46 = 134,
    SFE_XI_EXCESS_SAMPLES___46 = 135,
    SFE_XI_NO_PIPE___46 = 136,
    SFE_HTK_NO_PIPE___46 = 137,
    SFE_SDS_NOT_SDS___46 = 138,
    SFE_SDS_BAD_BIT_WIDTH___46 = 139,
    SFE_SD2_FD_DISALLOWED___46 = 140,
    SFE_SD2_BAD_DATA_OFFSET___46 = 141,
    SFE_SD2_BAD_MAP_OFFSET___46 = 142,
    SFE_SD2_BAD_DATA_LENGTH___46 = 143,
    SFE_SD2_BAD_MAP_LENGTH___46 = 144,
    SFE_SD2_BAD_RSRC___46 = 145,
    SFE_SD2_BAD_SAMPLE_SIZE___46 = 146,
    SFE_FLAC_BAD_HEADER___46 = 147,
    SFE_FLAC_NEW_DECODER___46 = 148,
    SFE_FLAC_INIT_DECODER___46 = 149,
    SFE_FLAC_LOST_SYNC___46 = 150,
    SFE_FLAC_BAD_SAMPLE_RATE___46 = 151,
    SFE_FLAC_UNKOWN_ERROR___46 = 152,
    SFE_WVE_NOT_WVE___46 = 153,
    SFE_WVE_NO_PIPE___46 = 154,
    SFE_VORBIS_ENCODER_BUG___46 = 155,
    SFE_RF64_NOT_RF64___46 = 156,
    SFE_MAX_ERROR___46 = 157
} ;
#line 823
enum __anonenum__1083 {
    SFC_TEST_AIFF_ADD_INST_CHUNK___46 = 8192,
    SFC_TEST_WAV_ADD_INFO_CHUNK___46 = 8208
} ;
#line 75 "/root/libsndfile/src/caf.c"
struct __anonstruct_1084 {
   unsigned char srate[8] ;
   unsigned int fmt_id ;
   unsigned int fmt_flags ;
   unsigned int pkt_bytes ;
   unsigned int pkt_frames ;
   unsigned int channels_per_frame ;
   unsigned int bits_per_chan ;
};
#line 83 "/root/libsndfile/src/caf.c"
typedef struct __anonstruct_1084 DESC_CHUNK;
#line 46 "/root/libsndfile/src/sndfile.h"
enum __anonenum__1099 {
    SF_FORMAT_WAV___47 = 65536,
    SF_FORMAT_AIFF___47 = 131072,
    SF_FORMAT_AU___47 = 196608,
    SF_FORMAT_RAW___47 = 262144,
    SF_FORMAT_PAF___47 = 327680,
    SF_FORMAT_SVX___47 = 393216,
    SF_FORMAT_NIST___47 = 458752,
    SF_FORMAT_VOC___47 = 524288,
    SF_FORMAT_IRCAM___47 = 655360,
    SF_FORMAT_W64___47 = 720896,
    SF_FORMAT_MAT4___47 = 786432,
    SF_FORMAT_MAT5___47 = 851968,
    SF_FORMAT_PVF___47 = 917504,
    SF_FORMAT_XI___47 = 983040,
    SF_FORMAT_HTK___47 = 1048576,
    SF_FORMAT_SDS___47 = 1114112,
    SF_FORMAT_AVR___47 = 1179648,
    SF_FORMAT_WAVEX___47 = 1245184,
    SF_FORMAT_SD2___47 = 1441792,
    SF_FORMAT_FLAC___47 = 1507328,
    SF_FORMAT_CAF___47 = 1572864,
    SF_FORMAT_WVE___47 = 1638400,
    SF_FORMAT_OGG___47 = 2097152,
    SF_FORMAT_MPC2K___47 = 2162688,
    SF_FORMAT_RF64___47 = 2228224,
    SF_FORMAT_PCM_S8___47 = 1,
    SF_FORMAT_PCM_16___47 = 2,
    SF_FORMAT_PCM_24___47 = 3,
    SF_FORMAT_PCM_32___47 = 4,
    SF_FORMAT_PCM_U8___47 = 5,
    SF_FORMAT_FLOAT___47 = 6,
    SF_FORMAT_DOUBLE___47 = 7,
    SF_FORMAT_ULAW___47 = 16,
    SF_FORMAT_ALAW___47 = 17,
    SF_FORMAT_IMA_ADPCM___47 = 18,
    SF_FORMAT_MS_ADPCM___47 = 19,
    SF_FORMAT_GSM610___47 = 32,
    SF_FORMAT_VOX_ADPCM___47 = 33,
    SF_FORMAT_G721_32___47 = 48,
    SF_FORMAT_G723_24___47 = 49,
    SF_FORMAT_G723_40___47 = 50,
    SF_FORMAT_DWVW_12___47 = 64,
    SF_FORMAT_DWVW_16___47 = 65,
    SF_FORMAT_DWVW_24___47 = 66,
    SF_FORMAT_DWVW_N___47 = 67,
    SF_FORMAT_DPCM_8___47 = 80,
    SF_FORMAT_DPCM_16___47 = 81,
    SF_FORMAT_VORBIS___47 = 96,
    SF_ENDIAN_FILE___47 = 0,
    SF_ENDIAN_LITTLE___47 = 268435456,
    SF_ENDIAN_BIG___47 = 536870912,
    SF_ENDIAN_CPU___47 = 805306368,
    SF_FORMAT_SUBMASK___47 = 65535,
    SF_FORMAT_TYPEMASK___47 = 268369920,
    SF_FORMAT_ENDMASK___47 = 805306368
} ;
#line 126
enum __anonenum__1100 {
    SFC_GET_LIB_VERSION___47 = 4096,
    SFC_GET_LOG_INFO___47 = 4097,
    SFC_GET_CURRENT_SF_INFO___47 = 4098,
    SFC_GET_NORM_DOUBLE___47 = 4112,
    SFC_GET_NORM_FLOAT___47 = 4113,
    SFC_SET_NORM_DOUBLE___47 = 4114,
    SFC_SET_NORM_FLOAT___47 = 4115,
    SFC_SET_SCALE_FLOAT_INT_READ___47 = 4116,
    SFC_SET_SCALE_INT_FLOAT_WRITE___47 = 4117,
    SFC_GET_SIMPLE_FORMAT_COUNT___47 = 4128,
    SFC_GET_SIMPLE_FORMAT___47 = 4129,
    SFC_GET_FORMAT_INFO___47 = 4136,
    SFC_GET_FORMAT_MAJOR_COUNT___47 = 4144,
    SFC_GET_FORMAT_MAJOR___47 = 4145,
    SFC_GET_FORMAT_SUBTYPE_COUNT___47 = 4146,
    SFC_GET_FORMAT_SUBTYPE___47 = 4147,
    SFC_CALC_SIGNAL_MAX___47 = 4160,
    SFC_CALC_NORM_SIGNAL_MAX___47 = 4161,
    SFC_CALC_MAX_ALL_CHANNELS___47 = 4162,
    SFC_CALC_NORM_MAX_ALL_CHANNELS___47 = 4163,
    SFC_GET_SIGNAL_MAX___47 = 4164,
    SFC_GET_MAX_ALL_CHANNELS___47 = 4165,
    SFC_SET_ADD_PEAK_CHUNK___47 = 4176,
    SFC_SET_ADD_HEADER_PAD_CHUNK___47 = 4177,
    SFC_UPDATE_HEADER_NOW___47 = 4192,
    SFC_SET_UPDATE_HEADER_AUTO___47 = 4193,
    SFC_FILE_TRUNCATE___47 = 4224,
    SFC_SET_RAW_START_OFFSET___47 = 4240,
    SFC_SET_DITHER_ON_WRITE___47 = 4256,
    SFC_SET_DITHER_ON_READ___47 = 4257,
    SFC_GET_DITHER_INFO_COUNT___47 = 4258,
    SFC_GET_DITHER_INFO___47 = 4259,
    SFC_GET_EMBED_FILE_INFO___47 = 4272,
    SFC_SET_CLIPPING___47 = 4288,
    SFC_GET_CLIPPING___47 = 4289,
    SFC_GET_INSTRUMENT___47 = 4304,
    SFC_SET_INSTRUMENT___47 = 4305,
    SFC_GET_LOOP_INFO___47 = 4320,
    SFC_GET_BROADCAST_INFO___47 = 4336,
    SFC_SET_BROADCAST_INFO___47 = 4337,
    SFC_GET_CHANNEL_MAP_INFO___47 = 4352,
    SFC_SET_CHANNEL_MAP_INFO___47 = 4353,
    SFC_RAW_DATA_NEEDS_ENDSWAP___47 = 4368,
    SFC_WAVEX_SET_AMBISONIC___47 = 4608,
    SFC_WAVEX_GET_AMBISONIC___47 = 4609,
    SFC_SET_VBR_ENCODING_QUALITY___47 = 4864,
    SFC_TEST_IEEE_FLOAT_REPLACE___47 = 24577,
    SFC_SET_ADD_DITHER_ON_WRITE___47 = 4208,
    SFC_SET_ADD_DITHER_ON_READ___47 = 4209
} ;
#line 216
enum __anonenum__1101 {
    SF_STR_TITLE___47 = 1,
    SF_STR_COPYRIGHT___47 = 2,
    SF_STR_SOFTWARE___47 = 3,
    SF_STR_ARTIST___47 = 4,
    SF_STR_COMMENT___47 = 5,
    SF_STR_DATE___47 = 6,
    SF_STR_ALBUM___47 = 7,
    SF_STR_LICENSE___47 = 8
} ;
#line 235
enum __anonenum__1102 {
    SF_FALSE___47 = 0,
    SF_TRUE___47 = 1,
    SFM_READ___47 = 16,
    SFM_WRITE___47 = 32,
    SFM_RDWR___47 = 48,
    SF_AMBISONIC_NONE___47 = 64,
    SF_AMBISONIC_B_FORMAT___47 = 65
} ;
#line 255
enum __anonstruct_728 {
    SF_ERR_NO_ERROR___47 = 0,
    SF_ERR_UNRECOGNISED_FORMAT___47 = 1,
    SF_ERR_SYSTEM___47 = 2,
    SF_ERR_MALFORMED_FILE___47 = 3,
    SF_ERR_UNSUPPORTED_ENCODING___47 = 4
} ;
#line 267
enum __anonenum__1103 {
    SF_CHANNEL_MAP_INVALID___47 = 0,
    SF_CHANNEL_MAP_MONO___47 = 1,
    SF_CHANNEL_MAP_LEFT___47 = 2,
    SF_CHANNEL_MAP_RIGHT___47 = 3,
    SF_CHANNEL_MAP_CENTER___47 = 4,
    SF_CHANNEL_MAP_FRONT_LEFT___47 = 5,
    SF_CHANNEL_MAP_FRONT_RIGHT___47 = 6,
    SF_CHANNEL_MAP_FRONT_CENTER___47 = 7,
    SF_CHANNEL_MAP_REAR_CENTER___47 = 8,
    SF_CHANNEL_MAP_REAR_LEFT___47 = 9,
    SF_CHANNEL_MAP_REAR_RIGHT___47 = 10,
    SF_CHANNEL_MAP_LFE___47 = 11,
    SF_CHANNEL_MAP_FRONT_LEFT_OF_CENTER___47 = 12,
    SF_CHANNEL_MAP_FRONT_RIGHT_OF_CENTER___47 = 13,
    SF_CHANNEL_MAP_SIDE_LEFT___47 = 14,
    SF_CHANNEL_MAP_SIDE_RIGHT___47 = 15,
    SF_CHANNEL_MAP_TOP_CENTER___47 = 16,
    SF_CHANNEL_MAP_TOP_FRONT_LEFT___47 = 17,
    SF_CHANNEL_MAP_TOP_FRONT_RIGHT___47 = 18,
    SF_CHANNEL_MAP_TOP_FRONT_CENTER___47 = 19,
    SF_CHANNEL_MAP_TOP_REAR_LEFT___47 = 20,
    SF_CHANNEL_MAP_TOP_REAR_RIGHT___47 = 21,
    SF_CHANNEL_MAP_TOP_REAR_CENTER___47 = 22
} ;
#line 352
enum __anonenum__1105 {
    SFD_DEFAULT_LEVEL___47 = 0,
    SFD_CUSTOM_LEVEL___47 = 1073741824,
    SFD_NO_DITHER___47 = 500,
    SFD_WHITE___47 = 501,
    SFD_TRIANGULAR_PDF___47 = 502
} ;
#line 380
enum __anonenum__1108 {
    SF_LOOP_NONE___47 = 800,
    SF_LOOP_FORWARD___47 = 801,
    SF_LOOP_BACKWARD___47 = 802,
    SF_LOOP_ALTERNATING___47 = 803
} ;
#line 121 "/root/libsndfile/src/common.h"
enum __anonenum__1117 {
    SF_PEAK_START___47 = 42,
    SF_PEAK_END___47 = 43,
    SF_SCALE_MAX___47 = 52,
    SF_SCALE_MIN___47 = 53,
    SF_STR_ALLOW_START___47 = 256,
    SF_STR_ALLOW_END___47 = 512,
    SF_STR_LOCATE_START___47 = 1024,
    SF_STR_LOCATE_END___47 = 2048,
    SFD_TYPEMASK___47 = 268435455
} ;
#line 149
enum __anonenum__1118 {
    SF_FORMAT_TXW___47 = 67305472,
    SF_FORMAT_DWD___47 = 67371008,
    SF_FORMAT_REX___47 = 67764224,
    SF_FORMAT_REX2___47 = 67960832,
    SF_FORMAT_KRZ___47 = 68026368,
    SF_FORMAT_WMA___47 = 68157440,
    SF_FORMAT_SHN___47 = 68222976,
    SF_FORMAT_SVX_FIB___47 = 4128,
    SF_FORMAT_SVX_EXP___47 = 4129,
    SF_FORMAT_PCM_N___47 = 4144
} ;
#line 405
enum __anonenum__1124 {
    SFE_NO_ERROR___47 = 0,
    SFE_BAD_OPEN_FORMAT___47 = 1,
    SFE_SYSTEM___47 = 2,
    SFE_MALFORMED_FILE___47 = 3,
    SFE_UNSUPPORTED_ENCODING___47 = 4,
    SFE_ZERO_MAJOR_FORMAT___47 = 5,
    SFE_ZERO_MINOR_FORMAT___47 = 6,
    SFE_BAD_FILE___47 = 7,
    SFE_BAD_FILE_READ___47 = 8,
    SFE_OPEN_FAILED___47 = 9,
    SFE_BAD_SNDFILE_PTR___47 = 10,
    SFE_BAD_SF_INFO_PTR___47 = 11,
    SFE_BAD_SF_INCOMPLETE___47 = 12,
    SFE_BAD_FILE_PTR___47 = 13,
    SFE_BAD_INT_PTR___47 = 14,
    SFE_BAD_STAT_SIZE___47 = 15,
    SFE_MALLOC_FAILED___47 = 16,
    SFE_UNIMPLEMENTED___47 = 17,
    SFE_BAD_READ_ALIGN___47 = 18,
    SFE_BAD_WRITE_ALIGN___47 = 19,
    SFE_UNKNOWN_FORMAT___47 = 20,
    SFE_NOT_READMODE___47 = 21,
    SFE_NOT_WRITEMODE___47 = 22,
    SFE_BAD_MODE_RW___47 = 23,
    SFE_BAD_SF_INFO___47 = 24,
    SFE_BAD_OFFSET___47 = 25,
    SFE_NO_EMBED_SUPPORT___47 = 26,
    SFE_NO_EMBEDDED_RDWR___47 = 27,
    SFE_NO_PIPE_WRITE___47 = 28,
    SFE_INTERNAL___47 = 29,
    SFE_BAD_COMMAND_PARAM___47 = 30,
    SFE_BAD_ENDIAN___47 = 31,
    SFE_CHANNEL_COUNT_ZERO___47 = 32,
    SFE_CHANNEL_COUNT___47 = 33,
    SFE_BAD_VIRTUAL_IO___47 = 34,
    SFE_INTERLEAVE_MODE___47 = 35,
    SFE_INTERLEAVE_SEEK___47 = 36,
    SFE_INTERLEAVE_READ___47 = 37,
    SFE_BAD_SEEK___47 = 38,
    SFE_NOT_SEEKABLE___47 = 39,
    SFE_AMBIGUOUS_SEEK___47 = 40,
    SFE_WRONG_SEEK___47 = 41,
    SFE_SEEK_FAILED___47 = 42,
    SFE_BAD_OPEN_MODE___47 = 43,
    SFE_OPEN_PIPE_RDWR___47 = 44,
    SFE_RDWR_POSITION___47 = 45,
    SFE_RDWR_BAD_HEADER___47 = 46,
    SFE_CMD_HAS_DATA___47 = 47,
    SFE_BAD_BROADCAST_INFO_SIZE___47 = 48,
    SFE_STR_NO_SUPPORT___47 = 49,
    SFE_STR_NOT_WRITE___47 = 50,
    SFE_STR_MAX_DATA___47 = 51,
    SFE_STR_MAX_COUNT___47 = 52,
    SFE_STR_BAD_TYPE___47 = 53,
    SFE_STR_NO_ADD_END___47 = 54,
    SFE_STR_BAD_STRING___47 = 55,
    SFE_STR_WEIRD___47 = 56,
    SFE_WAV_NO_RIFF___47 = 57,
    SFE_WAV_NO_WAVE___47 = 58,
    SFE_WAV_NO_FMT___47 = 59,
    SFE_WAV_BAD_FMT___47 = 60,
    SFE_WAV_FMT_SHORT___47 = 61,
    SFE_WAV_BAD_FACT___47 = 62,
    SFE_WAV_BAD_PEAK___47 = 63,
    SFE_WAV_PEAK_B4_FMT___47 = 64,
    SFE_WAV_BAD_FORMAT___47 = 65,
    SFE_WAV_BAD_BLOCKALIGN___47 = 66,
    SFE_WAV_NO_DATA___47 = 67,
    SFE_WAV_BAD_LIST___47 = 68,
    SFE_WAV_ADPCM_NOT4BIT___47 = 69,
    SFE_WAV_ADPCM_CHANNELS___47 = 70,
    SFE_WAV_GSM610_FORMAT___47 = 71,
    SFE_WAV_UNKNOWN_CHUNK___47 = 72,
    SFE_WAV_WVPK_DATA___47 = 73,
    SFE_AIFF_NO_FORM___47 = 74,
    SFE_AIFF_AIFF_NO_FORM___47 = 75,
    SFE_AIFF_COMM_NO_FORM___47 = 76,
    SFE_AIFF_SSND_NO_COMM___47 = 77,
    SFE_AIFF_UNKNOWN_CHUNK___47 = 78,
    SFE_AIFF_COMM_CHUNK_SIZE___47 = 79,
    SFE_AIFF_BAD_COMM_CHUNK___47 = 80,
    SFE_AIFF_PEAK_B4_COMM___47 = 81,
    SFE_AIFF_BAD_PEAK___47 = 82,
    SFE_AIFF_NO_SSND___47 = 83,
    SFE_AIFF_NO_DATA___47 = 84,
    SFE_AIFF_RW_SSND_NOT_LAST___47 = 85,
    SFE_AU_UNKNOWN_FORMAT___47 = 86,
    SFE_AU_NO_DOTSND___47 = 87,
    SFE_AU_EMBED_BAD_LEN___47 = 88,
    SFE_RAW_READ_BAD_SPEC___47 = 89,
    SFE_RAW_BAD_BITWIDTH___47 = 90,
    SFE_RAW_BAD_FORMAT___47 = 91,
    SFE_PAF_NO_MARKER___47 = 92,
    SFE_PAF_VERSION___47 = 93,
    SFE_PAF_UNKNOWN_FORMAT___47 = 94,
    SFE_PAF_SHORT_HEADER___47 = 95,
    SFE_SVX_NO_FORM___47 = 96,
    SFE_SVX_NO_BODY___47 = 97,
    SFE_SVX_NO_DATA___47 = 98,
    SFE_SVX_BAD_COMP___47 = 99,
    SFE_SVX_BAD_NAME_LENGTH___47 = 100,
    SFE_NIST_BAD_HEADER___47 = 101,
    SFE_NIST_CRLF_CONVERISON___47 = 102,
    SFE_NIST_BAD_ENCODING___47 = 103,
    SFE_VOC_NO_CREATIVE___47 = 104,
    SFE_VOC_BAD_FORMAT___47 = 105,
    SFE_VOC_BAD_VERSION___47 = 106,
    SFE_VOC_BAD_MARKER___47 = 107,
    SFE_VOC_BAD_SECTIONS___47 = 108,
    SFE_VOC_MULTI_SAMPLERATE___47 = 109,
    SFE_VOC_MULTI_SECTION___47 = 110,
    SFE_VOC_MULTI_PARAM___47 = 111,
    SFE_VOC_SECTION_COUNT___47 = 112,
    SFE_VOC_NO_PIPE___47 = 113,
    SFE_IRCAM_NO_MARKER___47 = 114,
    SFE_IRCAM_BAD_CHANNELS___47 = 115,
    SFE_IRCAM_UNKNOWN_FORMAT___47 = 116,
    SFE_W64_64_BIT___47 = 117,
    SFE_W64_NO_RIFF___47 = 118,
    SFE_W64_NO_WAVE___47 = 119,
    SFE_W64_NO_DATA___47 = 120,
    SFE_W64_ADPCM_NOT4BIT___47 = 121,
    SFE_W64_ADPCM_CHANNELS___47 = 122,
    SFE_W64_GSM610_FORMAT___47 = 123,
    SFE_MAT4_BAD_NAME___47 = 124,
    SFE_MAT4_NO_SAMPLERATE___47 = 125,
    SFE_MAT5_BAD_ENDIAN___47 = 126,
    SFE_MAT5_NO_BLOCK___47 = 127,
    SFE_MAT5_SAMPLE_RATE___47 = 128,
    SFE_PVF_NO_PVF1___47 = 129,
    SFE_PVF_BAD_HEADER___47 = 130,
    SFE_PVF_BAD_BITWIDTH___47 = 131,
    SFE_DWVW_BAD_BITWIDTH___47 = 132,
    SFE_G72X_NOT_MONO___47 = 133,
    SFE_XI_BAD_HEADER___47 = 134,
    SFE_XI_EXCESS_SAMPLES___47 = 135,
    SFE_XI_NO_PIPE___47 = 136,
    SFE_HTK_NO_PIPE___47 = 137,
    SFE_SDS_NOT_SDS___47 = 138,
    SFE_SDS_BAD_BIT_WIDTH___47 = 139,
    SFE_SD2_FD_DISALLOWED___47 = 140,
    SFE_SD2_BAD_DATA_OFFSET___47 = 141,
    SFE_SD2_BAD_MAP_OFFSET___47 = 142,
    SFE_SD2_BAD_DATA_LENGTH___47 = 143,
    SFE_SD2_BAD_MAP_LENGTH___47 = 144,
    SFE_SD2_BAD_RSRC___47 = 145,
    SFE_SD2_BAD_SAMPLE_SIZE___47 = 146,
    SFE_FLAC_BAD_HEADER___47 = 147,
    SFE_FLAC_NEW_DECODER___47 = 148,
    SFE_FLAC_INIT_DECODER___47 = 149,
    SFE_FLAC_LOST_SYNC___47 = 150,
    SFE_FLAC_BAD_SAMPLE_RATE___47 = 151,
    SFE_FLAC_UNKOWN_ERROR___47 = 152,
    SFE_WVE_NOT_WVE___47 = 153,
    SFE_WVE_NO_PIPE___47 = 154,
    SFE_VORBIS_ENCODER_BUG___47 = 155,
    SFE_RF64_NOT_RF64___47 = 156,
    SFE_MAX_ERROR___47 = 157
} ;
#line 823
enum __anonenum__436___1 {
    SFC_TEST_AIFF_ADD_INST_CHUNK___47 = 8192,
    SFC_TEST_WAV_ADD_INFO_CHUNK___47 = 8208
} ;
#line 42 "/root/libsndfile/src/avr.c"
struct __anonstruct_1125 {
   int marker ;
   char name[8] ;
   short mono ;
   short rez ;
   short sign ;
   short loop ;
   short midi ;
   int srate ;
   int frames ;
   int lbeg ;
   int lend ;
   short res1 ;
   short res2 ;
   short res3 ;
   char ext[20] ;
   char user[64] ;
};
#line 64 "/root/libsndfile/src/avr.c"
typedef struct __anonstruct_1125 AVR_HEADER;
#line 46 "/usr/include/ctype.h"
enum __anonenum__510___11 {
    _ISupper___23 = 256,
    _ISlower___23 = 512,
    _ISalpha___23 = 1024,
    _ISdigit___23 = 2048,
    _ISxdigit___23 = 4096,
    _ISspace___23 = 8192,
    _ISprint___23 = 16384,
    _ISgraph___23 = 32768,
    _ISblank___23 = 1,
    _IScntrl___23 = 2,
    _ISpunct___23 = 4,
    _ISalnum___23 = 8
} ;
#line 46 "/root/libsndfile/src/sndfile.h"
enum __anonenum__524___8 {
    SF_FORMAT_WAV___48 = 65536,
    SF_FORMAT_AIFF___48 = 131072,
    SF_FORMAT_AU___48 = 196608,
    SF_FORMAT_RAW___48 = 262144,
    SF_FORMAT_PAF___48 = 327680,
    SF_FORMAT_SVX___48 = 393216,
    SF_FORMAT_NIST___48 = 458752,
    SF_FORMAT_VOC___48 = 524288,
    SF_FORMAT_IRCAM___48 = 655360,
    SF_FORMAT_W64___48 = 720896,
    SF_FORMAT_MAT4___48 = 786432,
    SF_FORMAT_MAT5___48 = 851968,
    SF_FORMAT_PVF___48 = 917504,
    SF_FORMAT_XI___48 = 983040,
    SF_FORMAT_HTK___48 = 1048576,
    SF_FORMAT_SDS___48 = 1114112,
    SF_FORMAT_AVR___48 = 1179648,
    SF_FORMAT_WAVEX___48 = 1245184,
    SF_FORMAT_SD2___48 = 1441792,
    SF_FORMAT_FLAC___48 = 1507328,
    SF_FORMAT_CAF___48 = 1572864,
    SF_FORMAT_WVE___48 = 1638400,
    SF_FORMAT_OGG___48 = 2097152,
    SF_FORMAT_MPC2K___48 = 2162688,
    SF_FORMAT_RF64___48 = 2228224,
    SF_FORMAT_PCM_S8___48 = 1,
    SF_FORMAT_PCM_16___48 = 2,
    SF_FORMAT_PCM_24___48 = 3,
    SF_FORMAT_PCM_32___48 = 4,
    SF_FORMAT_PCM_U8___48 = 5,
    SF_FORMAT_FLOAT___48 = 6,
    SF_FORMAT_DOUBLE___48 = 7,
    SF_FORMAT_ULAW___48 = 16,
    SF_FORMAT_ALAW___48 = 17,
    SF_FORMAT_IMA_ADPCM___48 = 18,
    SF_FORMAT_MS_ADPCM___48 = 19,
    SF_FORMAT_GSM610___48 = 32,
    SF_FORMAT_VOX_ADPCM___48 = 33,
    SF_FORMAT_G721_32___48 = 48,
    SF_FORMAT_G723_24___48 = 49,
    SF_FORMAT_G723_40___48 = 50,
    SF_FORMAT_DWVW_12___48 = 64,
    SF_FORMAT_DWVW_16___48 = 65,
    SF_FORMAT_DWVW_24___48 = 66,
    SF_FORMAT_DWVW_N___48 = 67,
    SF_FORMAT_DPCM_8___48 = 80,
    SF_FORMAT_DPCM_16___48 = 81,
    SF_FORMAT_VORBIS___48 = 96,
    SF_ENDIAN_FILE___48 = 0,
    SF_ENDIAN_LITTLE___48 = 268435456,
    SF_ENDIAN_BIG___48 = 536870912,
    SF_ENDIAN_CPU___48 = 805306368,
    SF_FORMAT_SUBMASK___48 = 65535,
    SF_FORMAT_TYPEMASK___48 = 268369920,
    SF_FORMAT_ENDMASK___48 = 805306368
} ;
#line 126
enum __anonenum__525___8 {
    SFC_GET_LIB_VERSION___48 = 4096,
    SFC_GET_LOG_INFO___48 = 4097,
    SFC_GET_CURRENT_SF_INFO___48 = 4098,
    SFC_GET_NORM_DOUBLE___48 = 4112,
    SFC_GET_NORM_FLOAT___48 = 4113,
    SFC_SET_NORM_DOUBLE___48 = 4114,
    SFC_SET_NORM_FLOAT___48 = 4115,
    SFC_SET_SCALE_FLOAT_INT_READ___48 = 4116,
    SFC_SET_SCALE_INT_FLOAT_WRITE___48 = 4117,
    SFC_GET_SIMPLE_FORMAT_COUNT___48 = 4128,
    SFC_GET_SIMPLE_FORMAT___48 = 4129,
    SFC_GET_FORMAT_INFO___48 = 4136,
    SFC_GET_FORMAT_MAJOR_COUNT___48 = 4144,
    SFC_GET_FORMAT_MAJOR___48 = 4145,
    SFC_GET_FORMAT_SUBTYPE_COUNT___48 = 4146,
    SFC_GET_FORMAT_SUBTYPE___48 = 4147,
    SFC_CALC_SIGNAL_MAX___48 = 4160,
    SFC_CALC_NORM_SIGNAL_MAX___48 = 4161,
    SFC_CALC_MAX_ALL_CHANNELS___48 = 4162,
    SFC_CALC_NORM_MAX_ALL_CHANNELS___48 = 4163,
    SFC_GET_SIGNAL_MAX___48 = 4164,
    SFC_GET_MAX_ALL_CHANNELS___48 = 4165,
    SFC_SET_ADD_PEAK_CHUNK___48 = 4176,
    SFC_SET_ADD_HEADER_PAD_CHUNK___48 = 4177,
    SFC_UPDATE_HEADER_NOW___48 = 4192,
    SFC_SET_UPDATE_HEADER_AUTO___48 = 4193,
    SFC_FILE_TRUNCATE___48 = 4224,
    SFC_SET_RAW_START_OFFSET___48 = 4240,
    SFC_SET_DITHER_ON_WRITE___48 = 4256,
    SFC_SET_DITHER_ON_READ___48 = 4257,
    SFC_GET_DITHER_INFO_COUNT___48 = 4258,
    SFC_GET_DITHER_INFO___48 = 4259,
    SFC_GET_EMBED_FILE_INFO___48 = 4272,
    SFC_SET_CLIPPING___48 = 4288,
    SFC_GET_CLIPPING___48 = 4289,
    SFC_GET_INSTRUMENT___48 = 4304,
    SFC_SET_INSTRUMENT___48 = 4305,
    SFC_GET_LOOP_INFO___48 = 4320,
    SFC_GET_BROADCAST_INFO___48 = 4336,
    SFC_SET_BROADCAST_INFO___48 = 4337,
    SFC_GET_CHANNEL_MAP_INFO___48 = 4352,
    SFC_SET_CHANNEL_MAP_INFO___48 = 4353,
    SFC_RAW_DATA_NEEDS_ENDSWAP___48 = 4368,
    SFC_WAVEX_SET_AMBISONIC___48 = 4608,
    SFC_WAVEX_GET_AMBISONIC___48 = 4609,
    SFC_SET_VBR_ENCODING_QUALITY___48 = 4864,
    SFC_TEST_IEEE_FLOAT_REPLACE___48 = 24577,
    SFC_SET_ADD_DITHER_ON_WRITE___48 = 4208,
    SFC_SET_ADD_DITHER_ON_READ___48 = 4209
} ;
#line 216
enum __anonenum__526___8 {
    SF_STR_TITLE___48 = 1,
    SF_STR_COPYRIGHT___48 = 2,
    SF_STR_SOFTWARE___48 = 3,
    SF_STR_ARTIST___48 = 4,
    SF_STR_COMMENT___48 = 5,
    SF_STR_DATE___48 = 6,
    SF_STR_ALBUM___48 = 7,
    SF_STR_LICENSE___48 = 8
} ;
#line 235
enum __anonenum__527___8 {
    SF_FALSE___48 = 0,
    SF_TRUE___48 = 1,
    SFM_READ___48 = 16,
    SFM_WRITE___48 = 32,
    SFM_RDWR___48 = 48,
    SF_AMBISONIC_NONE___48 = 64,
    SF_AMBISONIC_B_FORMAT___48 = 65
} ;
#line 255
enum __anonenum__528___8 {
    SF_ERR_NO_ERROR___48 = 0,
    SF_ERR_UNRECOGNISED_FORMAT___48 = 1,
    SF_ERR_SYSTEM___48 = 2,
    SF_ERR_MALFORMED_FILE___48 = 3,
    SF_ERR_UNSUPPORTED_ENCODING___48 = 4
} ;
#line 267
enum __anonenum__529___8 {
    SF_CHANNEL_MAP_INVALID___48 = 0,
    SF_CHANNEL_MAP_MONO___48 = 1,
    SF_CHANNEL_MAP_LEFT___48 = 2,
    SF_CHANNEL_MAP_RIGHT___48 = 3,
    SF_CHANNEL_MAP_CENTER___48 = 4,
    SF_CHANNEL_MAP_FRONT_LEFT___48 = 5,
    SF_CHANNEL_MAP_FRONT_RIGHT___48 = 6,
    SF_CHANNEL_MAP_FRONT_CENTER___48 = 7,
    SF_CHANNEL_MAP_REAR_CENTER___48 = 8,
    SF_CHANNEL_MAP_REAR_LEFT___48 = 9,
    SF_CHANNEL_MAP_REAR_RIGHT___48 = 10,
    SF_CHANNEL_MAP_LFE___48 = 11,
    SF_CHANNEL_MAP_FRONT_LEFT_OF_CENTER___48 = 12,
    SF_CHANNEL_MAP_FRONT_RIGHT_OF_CENTER___48 = 13,
    SF_CHANNEL_MAP_SIDE_LEFT___48 = 14,
    SF_CHANNEL_MAP_SIDE_RIGHT___48 = 15,
    SF_CHANNEL_MAP_TOP_CENTER___48 = 16,
    SF_CHANNEL_MAP_TOP_FRONT_LEFT___48 = 17,
    SF_CHANNEL_MAP_TOP_FRONT_RIGHT___48 = 18,
    SF_CHANNEL_MAP_TOP_FRONT_CENTER___48 = 19,
    SF_CHANNEL_MAP_TOP_REAR_LEFT___48 = 20,
    SF_CHANNEL_MAP_TOP_REAR_RIGHT___48 = 21,
    SF_CHANNEL_MAP_TOP_REAR_CENTER___48 = 22
} ;
#line 352
enum __anonenum__531___8 {
    SFD_DEFAULT_LEVEL___48 = 0,
    SFD_CUSTOM_LEVEL___48 = 1073741824,
    SFD_NO_DITHER___48 = 500,
    SFD_WHITE___48 = 501,
    SFD_TRIANGULAR_PDF___48 = 502
} ;
#line 380
enum __anonenum__534___8 {
    SF_LOOP_NONE___48 = 800,
    SF_LOOP_FORWARD___48 = 801,
    SF_LOOP_BACKWARD___48 = 802,
    SF_LOOP_ALTERNATING___48 = 803
} ;
#line 121 "/root/libsndfile/src/common.h"
enum __anonenum__543___8 {
    SF_PEAK_START___48 = 42,
    SF_PEAK_END___48 = 43,
    SF_SCALE_MAX___48 = 52,
    SF_SCALE_MIN___48 = 53,
    SF_STR_ALLOW_START___48 = 256,
    SF_STR_ALLOW_END___48 = 512,
    SF_STR_LOCATE_START___48 = 1024,
    SF_STR_LOCATE_END___48 = 2048,
    SFD_TYPEMASK___48 = 268435455
} ;
#line 149
enum __anonenum__544___8 {
    SF_FORMAT_TXW___48 = 67305472,
    SF_FORMAT_DWD___48 = 67371008,
    SF_FORMAT_REX___48 = 67764224,
    SF_FORMAT_REX2___48 = 67960832,
    SF_FORMAT_KRZ___48 = 68026368,
    SF_FORMAT_WMA___48 = 68157440,
    SF_FORMAT_SHN___48 = 68222976,
    SF_FORMAT_SVX_FIB___48 = 4128,
    SF_FORMAT_SVX_EXP___48 = 4129,
    SF_FORMAT_PCM_N___48 = 4144
} ;
#line 405
enum __anonenum__550___8 {
    SFE_NO_ERROR___48 = 0,
    SFE_BAD_OPEN_FORMAT___48 = 1,
    SFE_SYSTEM___48 = 2,
    SFE_MALFORMED_FILE___48 = 3,
    SFE_UNSUPPORTED_ENCODING___48 = 4,
    SFE_ZERO_MAJOR_FORMAT___48 = 5,
    SFE_ZERO_MINOR_FORMAT___48 = 6,
    SFE_BAD_FILE___48 = 7,
    SFE_BAD_FILE_READ___48 = 8,
    SFE_OPEN_FAILED___48 = 9,
    SFE_BAD_SNDFILE_PTR___48 = 10,
    SFE_BAD_SF_INFO_PTR___48 = 11,
    SFE_BAD_SF_INCOMPLETE___48 = 12,
    SFE_BAD_FILE_PTR___48 = 13,
    SFE_BAD_INT_PTR___48 = 14,
    SFE_BAD_STAT_SIZE___48 = 15,
    SFE_MALLOC_FAILED___48 = 16,
    SFE_UNIMPLEMENTED___48 = 17,
    SFE_BAD_READ_ALIGN___48 = 18,
    SFE_BAD_WRITE_ALIGN___48 = 19,
    SFE_UNKNOWN_FORMAT___48 = 20,
    SFE_NOT_READMODE___48 = 21,
    SFE_NOT_WRITEMODE___48 = 22,
    SFE_BAD_MODE_RW___48 = 23,
    SFE_BAD_SF_INFO___48 = 24,
    SFE_BAD_OFFSET___48 = 25,
    SFE_NO_EMBED_SUPPORT___48 = 26,
    SFE_NO_EMBEDDED_RDWR___48 = 27,
    SFE_NO_PIPE_WRITE___48 = 28,
    SFE_INTERNAL___48 = 29,
    SFE_BAD_COMMAND_PARAM___48 = 30,
    SFE_BAD_ENDIAN___48 = 31,
    SFE_CHANNEL_COUNT_ZERO___48 = 32,
    SFE_CHANNEL_COUNT___48 = 33,
    SFE_BAD_VIRTUAL_IO___48 = 34,
    SFE_INTERLEAVE_MODE___48 = 35,
    SFE_INTERLEAVE_SEEK___48 = 36,
    SFE_INTERLEAVE_READ___48 = 37,
    SFE_BAD_SEEK___48 = 38,
    SFE_NOT_SEEKABLE___48 = 39,
    SFE_AMBIGUOUS_SEEK___48 = 40,
    SFE_WRONG_SEEK___48 = 41,
    SFE_SEEK_FAILED___48 = 42,
    SFE_BAD_OPEN_MODE___48 = 43,
    SFE_OPEN_PIPE_RDWR___48 = 44,
    SFE_RDWR_POSITION___48 = 45,
    SFE_RDWR_BAD_HEADER___48 = 46,
    SFE_CMD_HAS_DATA___48 = 47,
    SFE_BAD_BROADCAST_INFO_SIZE___48 = 48,
    SFE_STR_NO_SUPPORT___48 = 49,
    SFE_STR_NOT_WRITE___48 = 50,
    SFE_STR_MAX_DATA___48 = 51,
    SFE_STR_MAX_COUNT___48 = 52,
    SFE_STR_BAD_TYPE___48 = 53,
    SFE_STR_NO_ADD_END___48 = 54,
    SFE_STR_BAD_STRING___48 = 55,
    SFE_STR_WEIRD___48 = 56,
    SFE_WAV_NO_RIFF___48 = 57,
    SFE_WAV_NO_WAVE___48 = 58,
    SFE_WAV_NO_FMT___48 = 59,
    SFE_WAV_BAD_FMT___48 = 60,
    SFE_WAV_FMT_SHORT___48 = 61,
    SFE_WAV_BAD_FACT___48 = 62,
    SFE_WAV_BAD_PEAK___48 = 63,
    SFE_WAV_PEAK_B4_FMT___48 = 64,
    SFE_WAV_BAD_FORMAT___48 = 65,
    SFE_WAV_BAD_BLOCKALIGN___48 = 66,
    SFE_WAV_NO_DATA___48 = 67,
    SFE_WAV_BAD_LIST___48 = 68,
    SFE_WAV_ADPCM_NOT4BIT___48 = 69,
    SFE_WAV_ADPCM_CHANNELS___48 = 70,
    SFE_WAV_GSM610_FORMAT___48 = 71,
    SFE_WAV_UNKNOWN_CHUNK___48 = 72,
    SFE_WAV_WVPK_DATA___48 = 73,
    SFE_AIFF_NO_FORM___48 = 74,
    SFE_AIFF_AIFF_NO_FORM___48 = 75,
    SFE_AIFF_COMM_NO_FORM___48 = 76,
    SFE_AIFF_SSND_NO_COMM___48 = 77,
    SFE_AIFF_UNKNOWN_CHUNK___48 = 78,
    SFE_AIFF_COMM_CHUNK_SIZE___48 = 79,
    SFE_AIFF_BAD_COMM_CHUNK___48 = 80,
    SFE_AIFF_PEAK_B4_COMM___48 = 81,
    SFE_AIFF_BAD_PEAK___48 = 82,
    SFE_AIFF_NO_SSND___48 = 83,
    SFE_AIFF_NO_DATA___48 = 84,
    SFE_AIFF_RW_SSND_NOT_LAST___48 = 85,
    SFE_AU_UNKNOWN_FORMAT___48 = 86,
    SFE_AU_NO_DOTSND___48 = 87,
    SFE_AU_EMBED_BAD_LEN___48 = 88,
    SFE_RAW_READ_BAD_SPEC___48 = 89,
    SFE_RAW_BAD_BITWIDTH___48 = 90,
    SFE_RAW_BAD_FORMAT___48 = 91,
    SFE_PAF_NO_MARKER___48 = 92,
    SFE_PAF_VERSION___48 = 93,
    SFE_PAF_UNKNOWN_FORMAT___48 = 94,
    SFE_PAF_SHORT_HEADER___48 = 95,
    SFE_SVX_NO_FORM___48 = 96,
    SFE_SVX_NO_BODY___48 = 97,
    SFE_SVX_NO_DATA___48 = 98,
    SFE_SVX_BAD_COMP___48 = 99,
    SFE_SVX_BAD_NAME_LENGTH___48 = 100,
    SFE_NIST_BAD_HEADER___48 = 101,
    SFE_NIST_CRLF_CONVERISON___48 = 102,
    SFE_NIST_BAD_ENCODING___48 = 103,
    SFE_VOC_NO_CREATIVE___48 = 104,
    SFE_VOC_BAD_FORMAT___48 = 105,
    SFE_VOC_BAD_VERSION___48 = 106,
    SFE_VOC_BAD_MARKER___48 = 107,
    SFE_VOC_BAD_SECTIONS___48 = 108,
    SFE_VOC_MULTI_SAMPLERATE___48 = 109,
    SFE_VOC_MULTI_SECTION___48 = 110,
    SFE_VOC_MULTI_PARAM___48 = 111,
    SFE_VOC_SECTION_COUNT___48 = 112,
    SFE_VOC_NO_PIPE___48 = 113,
    SFE_IRCAM_NO_MARKER___48 = 114,
    SFE_IRCAM_BAD_CHANNELS___48 = 115,
    SFE_IRCAM_UNKNOWN_FORMAT___48 = 116,
    SFE_W64_64_BIT___48 = 117,
    SFE_W64_NO_RIFF___48 = 118,
    SFE_W64_NO_WAVE___48 = 119,
    SFE_W64_NO_DATA___48 = 120,
    SFE_W64_ADPCM_NOT4BIT___48 = 121,
    SFE_W64_ADPCM_CHANNELS___48 = 122,
    SFE_W64_GSM610_FORMAT___48 = 123,
    SFE_MAT4_BAD_NAME___48 = 124,
    SFE_MAT4_NO_SAMPLERATE___48 = 125,
    SFE_MAT5_BAD_ENDIAN___48 = 126,
    SFE_MAT5_NO_BLOCK___48 = 127,
    SFE_MAT5_SAMPLE_RATE___48 = 128,
    SFE_PVF_NO_PVF1___48 = 129,
    SFE_PVF_BAD_HEADER___48 = 130,
    SFE_PVF_BAD_BITWIDTH___48 = 131,
    SFE_DWVW_BAD_BITWIDTH___48 = 132,
    SFE_G72X_NOT_MONO___48 = 133,
    SFE_XI_BAD_HEADER___48 = 134,
    SFE_XI_EXCESS_SAMPLES___48 = 135,
    SFE_XI_NO_PIPE___48 = 136,
    SFE_HTK_NO_PIPE___48 = 137,
    SFE_SDS_NOT_SDS___48 = 138,
    SFE_SDS_BAD_BIT_WIDTH___48 = 139,
    SFE_SD2_FD_DISALLOWED___48 = 140,
    SFE_SD2_BAD_DATA_OFFSET___48 = 141,
    SFE_SD2_BAD_MAP_OFFSET___48 = 142,
    SFE_SD2_BAD_DATA_LENGTH___48 = 143,
    SFE_SD2_BAD_MAP_LENGTH___48 = 144,
    SFE_SD2_BAD_RSRC___48 = 145,
    SFE_SD2_BAD_SAMPLE_SIZE___48 = 146,
    SFE_FLAC_BAD_HEADER___48 = 147,
    SFE_FLAC_NEW_DECODER___48 = 148,
    SFE_FLAC_INIT_DECODER___48 = 149,
    SFE_FLAC_LOST_SYNC___48 = 150,
    SFE_FLAC_BAD_SAMPLE_RATE___48 = 151,
    SFE_FLAC_UNKOWN_ERROR___48 = 152,
    SFE_WVE_NOT_WVE___48 = 153,
    SFE_WVE_NO_PIPE___48 = 154,
    SFE_VORBIS_ENCODER_BUG___48 = 155,
    SFE_RF64_NOT_RF64___48 = 156,
    SFE_MAX_ERROR___48 = 157
} ;
#line 823
enum __anonenum__554___8 {
    SFC_TEST_AIFF_ADD_INST_CHUNK___48 = 8192,
    SFC_TEST_WAV_ADD_INFO_CHUNK___48 = 8208
} ;
#line 43 "/root/libsndfile/src/au.c"
enum __anonenum__555___1 {
    AU_ENCODING_ULAW_8 = 1,
    AU_ENCODING_PCM_8 = 2,
    AU_ENCODING_PCM_16 = 3,
    AU_ENCODING_PCM_24 = 4,
    AU_ENCODING_PCM_32 = 5,
    AU_ENCODING_FLOAT = 6,
    AU_ENCODING_DOUBLE = 7,
    AU_ENCODING_INDIRECT = 8,
    AU_ENCODING_NESTED = 9,
    AU_ENCODING_DSP_CORE = 10,
    AU_ENCODING_DSP_DATA_8 = 11,
    AU_ENCODING_DSP_DATA_16 = 12,
    AU_ENCODING_DSP_DATA_24 = 13,
    AU_ENCODING_DSP_DATA_32 = 14,
    AU_ENCODING_DISPLAY = 16,
    AU_ENCODING_MULAW_SQUELCH = 17,
    AU_ENCODING_EMPHASIZED = 18,
    AU_ENCODING_NEXT = 19,
    AU_ENCODING_COMPRESSED_EMPHASIZED = 20,
    AU_ENCODING_DSP_COMMANDS = 21,
    AU_ENCODING_DSP_COMMANDS_SAMPLES = 22,
    AU_ENCODING_ADPCM_G721_32 = 23,
    AU_ENCODING_ADPCM_G722 = 24,
    AU_ENCODING_ADPCM_G723_24 = 25,
    AU_ENCODING_ADPCM_G723_40 = 26,
    AU_ENCODING_ALAW_8 = 27
} ;
#line 80 "/root/libsndfile/src/au.c"
struct __anonstruct_1126 {
   int dataoffset ;
   int datasize ;
   int encoding ;
   int samplerate ;
   int channels ;
};
#line 86 "/root/libsndfile/src/au.c"
typedef struct __anonstruct_1126 AU_FMT;
#line 46 "/usr/include/ctype.h"
enum __anonenum__1127 {
    _ISupper___24 = 256,
    _ISlower___24 = 512,
    _ISalpha___24 = 1024,
    _ISdigit___24 = 2048,
    _ISxdigit___24 = 4096,
    _ISspace___24 = 8192,
    _ISprint___24 = 16384,
    _ISgraph___24 = 32768,
    _ISblank___24 = 1,
    _IScntrl___24 = 2,
    _ISpunct___24 = 4,
    _ISalnum___24 = 8
} ;
#line 46 "/root/libsndfile/src/sndfile.h"
enum __anonenum__1128 {
    SF_FORMAT_WAV___49 = 65536,
    SF_FORMAT_AIFF___49 = 131072,
    SF_FORMAT_AU___49 = 196608,
    SF_FORMAT_RAW___49 = 262144,
    SF_FORMAT_PAF___49 = 327680,
    SF_FORMAT_SVX___49 = 393216,
    SF_FORMAT_NIST___49 = 458752,
    SF_FORMAT_VOC___49 = 524288,
    SF_FORMAT_IRCAM___49 = 655360,
    SF_FORMAT_W64___49 = 720896,
    SF_FORMAT_MAT4___49 = 786432,
    SF_FORMAT_MAT5___49 = 851968,
    SF_FORMAT_PVF___49 = 917504,
    SF_FORMAT_XI___49 = 983040,
    SF_FORMAT_HTK___49 = 1048576,
    SF_FORMAT_SDS___49 = 1114112,
    SF_FORMAT_AVR___49 = 1179648,
    SF_FORMAT_WAVEX___49 = 1245184,
    SF_FORMAT_SD2___49 = 1441792,
    SF_FORMAT_FLAC___49 = 1507328,
    SF_FORMAT_CAF___49 = 1572864,
    SF_FORMAT_WVE___49 = 1638400,
    SF_FORMAT_OGG___49 = 2097152,
    SF_FORMAT_MPC2K___49 = 2162688,
    SF_FORMAT_RF64___49 = 2228224,
    SF_FORMAT_PCM_S8___49 = 1,
    SF_FORMAT_PCM_16___49 = 2,
    SF_FORMAT_PCM_24___49 = 3,
    SF_FORMAT_PCM_32___49 = 4,
    SF_FORMAT_PCM_U8___49 = 5,
    SF_FORMAT_FLOAT___49 = 6,
    SF_FORMAT_DOUBLE___49 = 7,
    SF_FORMAT_ULAW___49 = 16,
    SF_FORMAT_ALAW___49 = 17,
    SF_FORMAT_IMA_ADPCM___49 = 18,
    SF_FORMAT_MS_ADPCM___49 = 19,
    SF_FORMAT_GSM610___49 = 32,
    SF_FORMAT_VOX_ADPCM___49 = 33,
    SF_FORMAT_G721_32___49 = 48,
    SF_FORMAT_G723_24___49 = 49,
    SF_FORMAT_G723_40___49 = 50,
    SF_FORMAT_DWVW_12___49 = 64,
    SF_FORMAT_DWVW_16___49 = 65,
    SF_FORMAT_DWVW_24___49 = 66,
    SF_FORMAT_DWVW_N___49 = 67,
    SF_FORMAT_DPCM_8___49 = 80,
    SF_FORMAT_DPCM_16___49 = 81,
    SF_FORMAT_VORBIS___49 = 96,
    SF_ENDIAN_FILE___49 = 0,
    SF_ENDIAN_LITTLE___49 = 268435456,
    SF_ENDIAN_BIG___49 = 536870912,
    SF_ENDIAN_CPU___49 = 805306368,
    SF_FORMAT_SUBMASK___49 = 65535,
    SF_FORMAT_TYPEMASK___49 = 268369920,
    SF_FORMAT_ENDMASK___49 = 805306368
} ;
#line 126
enum __anonenum__1129 {
    SFC_GET_LIB_VERSION___49 = 4096,
    SFC_GET_LOG_INFO___49 = 4097,
    SFC_GET_CURRENT_SF_INFO___49 = 4098,
    SFC_GET_NORM_DOUBLE___49 = 4112,
    SFC_GET_NORM_FLOAT___49 = 4113,
    SFC_SET_NORM_DOUBLE___49 = 4114,
    SFC_SET_NORM_FLOAT___49 = 4115,
    SFC_SET_SCALE_FLOAT_INT_READ___49 = 4116,
    SFC_SET_SCALE_INT_FLOAT_WRITE___49 = 4117,
    SFC_GET_SIMPLE_FORMAT_COUNT___49 = 4128,
    SFC_GET_SIMPLE_FORMAT___49 = 4129,
    SFC_GET_FORMAT_INFO___49 = 4136,
    SFC_GET_FORMAT_MAJOR_COUNT___49 = 4144,
    SFC_GET_FORMAT_MAJOR___49 = 4145,
    SFC_GET_FORMAT_SUBTYPE_COUNT___49 = 4146,
    SFC_GET_FORMAT_SUBTYPE___49 = 4147,
    SFC_CALC_SIGNAL_MAX___49 = 4160,
    SFC_CALC_NORM_SIGNAL_MAX___49 = 4161,
    SFC_CALC_MAX_ALL_CHANNELS___49 = 4162,
    SFC_CALC_NORM_MAX_ALL_CHANNELS___49 = 4163,
    SFC_GET_SIGNAL_MAX___49 = 4164,
    SFC_GET_MAX_ALL_CHANNELS___49 = 4165,
    SFC_SET_ADD_PEAK_CHUNK___49 = 4176,
    SFC_SET_ADD_HEADER_PAD_CHUNK___49 = 4177,
    SFC_UPDATE_HEADER_NOW___49 = 4192,
    SFC_SET_UPDATE_HEADER_AUTO___49 = 4193,
    SFC_FILE_TRUNCATE___49 = 4224,
    SFC_SET_RAW_START_OFFSET___49 = 4240,
    SFC_SET_DITHER_ON_WRITE___49 = 4256,
    SFC_SET_DITHER_ON_READ___49 = 4257,
    SFC_GET_DITHER_INFO_COUNT___49 = 4258,
    SFC_GET_DITHER_INFO___49 = 4259,
    SFC_GET_EMBED_FILE_INFO___49 = 4272,
    SFC_SET_CLIPPING___49 = 4288,
    SFC_GET_CLIPPING___49 = 4289,
    SFC_GET_INSTRUMENT___49 = 4304,
    SFC_SET_INSTRUMENT___49 = 4305,
    SFC_GET_LOOP_INFO___49 = 4320,
    SFC_GET_BROADCAST_INFO___49 = 4336,
    SFC_SET_BROADCAST_INFO___49 = 4337,
    SFC_GET_CHANNEL_MAP_INFO___49 = 4352,
    SFC_SET_CHANNEL_MAP_INFO___49 = 4353,
    SFC_RAW_DATA_NEEDS_ENDSWAP___49 = 4368,
    SFC_WAVEX_SET_AMBISONIC___49 = 4608,
    SFC_WAVEX_GET_AMBISONIC___49 = 4609,
    SFC_SET_VBR_ENCODING_QUALITY___49 = 4864,
    SFC_TEST_IEEE_FLOAT_REPLACE___49 = 24577,
    SFC_SET_ADD_DITHER_ON_WRITE___49 = 4208,
    SFC_SET_ADD_DITHER_ON_READ___49 = 4209
} ;
#line 216
enum __anonenum__1130 {
    SF_STR_TITLE___49 = 1,
    SF_STR_COPYRIGHT___49 = 2,
    SF_STR_SOFTWARE___49 = 3,
    SF_STR_ARTIST___49 = 4,
    SF_STR_COMMENT___49 = 5,
    SF_STR_DATE___49 = 6,
    SF_STR_ALBUM___49 = 7,
    SF_STR_LICENSE___49 = 8
} ;
#line 235
enum __anonenum__1131 {
    SF_FALSE___49 = 0,
    SF_TRUE___49 = 1,
    SFM_READ___49 = 16,
    SFM_WRITE___49 = 32,
    SFM_RDWR___49 = 48,
    SF_AMBISONIC_NONE___49 = 64,
    SF_AMBISONIC_B_FORMAT___49 = 65
} ;
#line 255
enum __anonenum__1132 {
    SF_ERR_NO_ERROR___49 = 0,
    SF_ERR_UNRECOGNISED_FORMAT___49 = 1,
    SF_ERR_SYSTEM___49 = 2,
    SF_ERR_MALFORMED_FILE___49 = 3,
    SF_ERR_UNSUPPORTED_ENCODING___49 = 4
} ;
#line 267
enum __anonenum__1133 {
    SF_CHANNEL_MAP_INVALID___49 = 0,
    SF_CHANNEL_MAP_MONO___49 = 1,
    SF_CHANNEL_MAP_LEFT___49 = 2,
    SF_CHANNEL_MAP_RIGHT___49 = 3,
    SF_CHANNEL_MAP_CENTER___49 = 4,
    SF_CHANNEL_MAP_FRONT_LEFT___49 = 5,
    SF_CHANNEL_MAP_FRONT_RIGHT___49 = 6,
    SF_CHANNEL_MAP_FRONT_CENTER___49 = 7,
    SF_CHANNEL_MAP_REAR_CENTER___49 = 8,
    SF_CHANNEL_MAP_REAR_LEFT___49 = 9,
    SF_CHANNEL_MAP_REAR_RIGHT___49 = 10,
    SF_CHANNEL_MAP_LFE___49 = 11,
    SF_CHANNEL_MAP_FRONT_LEFT_OF_CENTER___49 = 12,
    SF_CHANNEL_MAP_FRONT_RIGHT_OF_CENTER___49 = 13,
    SF_CHANNEL_MAP_SIDE_LEFT___49 = 14,
    SF_CHANNEL_MAP_SIDE_RIGHT___49 = 15,
    SF_CHANNEL_MAP_TOP_CENTER___49 = 16,
    SF_CHANNEL_MAP_TOP_FRONT_LEFT___49 = 17,
    SF_CHANNEL_MAP_TOP_FRONT_RIGHT___49 = 18,
    SF_CHANNEL_MAP_TOP_FRONT_CENTER___49 = 19,
    SF_CHANNEL_MAP_TOP_REAR_LEFT___49 = 20,
    SF_CHANNEL_MAP_TOP_REAR_RIGHT___49 = 21,
    SF_CHANNEL_MAP_TOP_REAR_CENTER___49 = 22
} ;
#line 352
enum __anonenum__1135 {
    SFD_DEFAULT_LEVEL___49 = 0,
    SFD_CUSTOM_LEVEL___49 = 1073741824,
    SFD_NO_DITHER___49 = 500,
    SFD_WHITE___49 = 501,
    SFD_TRIANGULAR_PDF___49 = 502
} ;
#line 380
enum __anonenum__1138 {
    SF_LOOP_NONE___49 = 800,
    SF_LOOP_FORWARD___49 = 801,
    SF_LOOP_BACKWARD___49 = 802,
    SF_LOOP_ALTERNATING___49 = 803
} ;
#line 121 "/root/libsndfile/src/common.h"
enum __anonenum__614___0 {
    SF_PEAK_START___49 = 42,
    SF_PEAK_END___49 = 43,
    SF_SCALE_MAX___49 = 52,
    SF_SCALE_MIN___49 = 53,
    SF_STR_ALLOW_START___49 = 256,
    SF_STR_ALLOW_END___49 = 512,
    SF_STR_LOCATE_START___49 = 1024,
    SF_STR_LOCATE_END___49 = 2048,
    SFD_TYPEMASK___49 = 268435455
} ;
#line 149
enum __anonenum__615___0 {
    SF_FORMAT_TXW___49 = 67305472,
    SF_FORMAT_DWD___49 = 67371008,
    SF_FORMAT_REX___49 = 67764224,
    SF_FORMAT_REX2___49 = 67960832,
    SF_FORMAT_KRZ___49 = 68026368,
    SF_FORMAT_WMA___49 = 68157440,
    SF_FORMAT_SHN___49 = 68222976,
    SF_FORMAT_SVX_FIB___49 = 4128,
    SF_FORMAT_SVX_EXP___49 = 4129,
    SF_FORMAT_PCM_N___49 = 4144
} ;
#line 405
enum __anonenum__621___0 {
    SFE_NO_ERROR___49 = 0,
    SFE_BAD_OPEN_FORMAT___49 = 1,
    SFE_SYSTEM___49 = 2,
    SFE_MALFORMED_FILE___49 = 3,
    SFE_UNSUPPORTED_ENCODING___49 = 4,
    SFE_ZERO_MAJOR_FORMAT___49 = 5,
    SFE_ZERO_MINOR_FORMAT___49 = 6,
    SFE_BAD_FILE___49 = 7,
    SFE_BAD_FILE_READ___49 = 8,
    SFE_OPEN_FAILED___49 = 9,
    SFE_BAD_SNDFILE_PTR___49 = 10,
    SFE_BAD_SF_INFO_PTR___49 = 11,
    SFE_BAD_SF_INCOMPLETE___49 = 12,
    SFE_BAD_FILE_PTR___49 = 13,
    SFE_BAD_INT_PTR___49 = 14,
    SFE_BAD_STAT_SIZE___49 = 15,
    SFE_MALLOC_FAILED___49 = 16,
    SFE_UNIMPLEMENTED___49 = 17,
    SFE_BAD_READ_ALIGN___49 = 18,
    SFE_BAD_WRITE_ALIGN___49 = 19,
    SFE_UNKNOWN_FORMAT___49 = 20,
    SFE_NOT_READMODE___49 = 21,
    SFE_NOT_WRITEMODE___49 = 22,
    SFE_BAD_MODE_RW___49 = 23,
    SFE_BAD_SF_INFO___49 = 24,
    SFE_BAD_OFFSET___49 = 25,
    SFE_NO_EMBED_SUPPORT___49 = 26,
    SFE_NO_EMBEDDED_RDWR___49 = 27,
    SFE_NO_PIPE_WRITE___49 = 28,
    SFE_INTERNAL___49 = 29,
    SFE_BAD_COMMAND_PARAM___49 = 30,
    SFE_BAD_ENDIAN___49 = 31,
    SFE_CHANNEL_COUNT_ZERO___49 = 32,
    SFE_CHANNEL_COUNT___49 = 33,
    SFE_BAD_VIRTUAL_IO___49 = 34,
    SFE_INTERLEAVE_MODE___49 = 35,
    SFE_INTERLEAVE_SEEK___49 = 36,
    SFE_INTERLEAVE_READ___49 = 37,
    SFE_BAD_SEEK___49 = 38,
    SFE_NOT_SEEKABLE___49 = 39,
    SFE_AMBIGUOUS_SEEK___49 = 40,
    SFE_WRONG_SEEK___49 = 41,
    SFE_SEEK_FAILED___49 = 42,
    SFE_BAD_OPEN_MODE___49 = 43,
    SFE_OPEN_PIPE_RDWR___49 = 44,
    SFE_RDWR_POSITION___49 = 45,
    SFE_RDWR_BAD_HEADER___49 = 46,
    SFE_CMD_HAS_DATA___49 = 47,
    SFE_BAD_BROADCAST_INFO_SIZE___49 = 48,
    SFE_STR_NO_SUPPORT___49 = 49,
    SFE_STR_NOT_WRITE___49 = 50,
    SFE_STR_MAX_DATA___49 = 51,
    SFE_STR_MAX_COUNT___49 = 52,
    SFE_STR_BAD_TYPE___49 = 53,
    SFE_STR_NO_ADD_END___49 = 54,
    SFE_STR_BAD_STRING___49 = 55,
    SFE_STR_WEIRD___49 = 56,
    SFE_WAV_NO_RIFF___49 = 57,
    SFE_WAV_NO_WAVE___49 = 58,
    SFE_WAV_NO_FMT___49 = 59,
    SFE_WAV_BAD_FMT___49 = 60,
    SFE_WAV_FMT_SHORT___49 = 61,
    SFE_WAV_BAD_FACT___49 = 62,
    SFE_WAV_BAD_PEAK___49 = 63,
    SFE_WAV_PEAK_B4_FMT___49 = 64,
    SFE_WAV_BAD_FORMAT___49 = 65,
    SFE_WAV_BAD_BLOCKALIGN___49 = 66,
    SFE_WAV_NO_DATA___49 = 67,
    SFE_WAV_BAD_LIST___49 = 68,
    SFE_WAV_ADPCM_NOT4BIT___49 = 69,
    SFE_WAV_ADPCM_CHANNELS___49 = 70,
    SFE_WAV_GSM610_FORMAT___49 = 71,
    SFE_WAV_UNKNOWN_CHUNK___49 = 72,
    SFE_WAV_WVPK_DATA___49 = 73,
    SFE_AIFF_NO_FORM___49 = 74,
    SFE_AIFF_AIFF_NO_FORM___49 = 75,
    SFE_AIFF_COMM_NO_FORM___49 = 76,
    SFE_AIFF_SSND_NO_COMM___49 = 77,
    SFE_AIFF_UNKNOWN_CHUNK___49 = 78,
    SFE_AIFF_COMM_CHUNK_SIZE___49 = 79,
    SFE_AIFF_BAD_COMM_CHUNK___49 = 80,
    SFE_AIFF_PEAK_B4_COMM___49 = 81,
    SFE_AIFF_BAD_PEAK___49 = 82,
    SFE_AIFF_NO_SSND___49 = 83,
    SFE_AIFF_NO_DATA___49 = 84,
    SFE_AIFF_RW_SSND_NOT_LAST___49 = 85,
    SFE_AU_UNKNOWN_FORMAT___49 = 86,
    SFE_AU_NO_DOTSND___49 = 87,
    SFE_AU_EMBED_BAD_LEN___49 = 88,
    SFE_RAW_READ_BAD_SPEC___49 = 89,
    SFE_RAW_BAD_BITWIDTH___49 = 90,
    SFE_RAW_BAD_FORMAT___49 = 91,
    SFE_PAF_NO_MARKER___49 = 92,
    SFE_PAF_VERSION___49 = 93,
    SFE_PAF_UNKNOWN_FORMAT___49 = 94,
    SFE_PAF_SHORT_HEADER___49 = 95,
    SFE_SVX_NO_FORM___49 = 96,
    SFE_SVX_NO_BODY___49 = 97,
    SFE_SVX_NO_DATA___49 = 98,
    SFE_SVX_BAD_COMP___49 = 99,
    SFE_SVX_BAD_NAME_LENGTH___49 = 100,
    SFE_NIST_BAD_HEADER___49 = 101,
    SFE_NIST_CRLF_CONVERISON___49 = 102,
    SFE_NIST_BAD_ENCODING___49 = 103,
    SFE_VOC_NO_CREATIVE___49 = 104,
    SFE_VOC_BAD_FORMAT___49 = 105,
    SFE_VOC_BAD_VERSION___49 = 106,
    SFE_VOC_BAD_MARKER___49 = 107,
    SFE_VOC_BAD_SECTIONS___49 = 108,
    SFE_VOC_MULTI_SAMPLERATE___49 = 109,
    SFE_VOC_MULTI_SECTION___49 = 110,
    SFE_VOC_MULTI_PARAM___49 = 111,
    SFE_VOC_SECTION_COUNT___49 = 112,
    SFE_VOC_NO_PIPE___49 = 113,
    SFE_IRCAM_NO_MARKER___49 = 114,
    SFE_IRCAM_BAD_CHANNELS___49 = 115,
    SFE_IRCAM_UNKNOWN_FORMAT___49 = 116,
    SFE_W64_64_BIT___49 = 117,
    SFE_W64_NO_RIFF___49 = 118,
    SFE_W64_NO_WAVE___49 = 119,
    SFE_W64_NO_DATA___49 = 120,
    SFE_W64_ADPCM_NOT4BIT___49 = 121,
    SFE_W64_ADPCM_CHANNELS___49 = 122,
    SFE_W64_GSM610_FORMAT___49 = 123,
    SFE_MAT4_BAD_NAME___49 = 124,
    SFE_MAT4_NO_SAMPLERATE___49 = 125,
    SFE_MAT5_BAD_ENDIAN___49 = 126,
    SFE_MAT5_NO_BLOCK___49 = 127,
    SFE_MAT5_SAMPLE_RATE___49 = 128,
    SFE_PVF_NO_PVF1___49 = 129,
    SFE_PVF_BAD_HEADER___49 = 130,
    SFE_PVF_BAD_BITWIDTH___49 = 131,
    SFE_DWVW_BAD_BITWIDTH___49 = 132,
    SFE_G72X_NOT_MONO___49 = 133,
    SFE_XI_BAD_HEADER___49 = 134,
    SFE_XI_EXCESS_SAMPLES___49 = 135,
    SFE_XI_NO_PIPE___49 = 136,
    SFE_HTK_NO_PIPE___49 = 137,
    SFE_SDS_NOT_SDS___49 = 138,
    SFE_SDS_BAD_BIT_WIDTH___49 = 139,
    SFE_SD2_FD_DISALLOWED___49 = 140,
    SFE_SD2_BAD_DATA_OFFSET___49 = 141,
    SFE_SD2_BAD_MAP_OFFSET___49 = 142,
    SFE_SD2_BAD_DATA_LENGTH___49 = 143,
    SFE_SD2_BAD_MAP_LENGTH___49 = 144,
    SFE_SD2_BAD_RSRC___49 = 145,
    SFE_SD2_BAD_SAMPLE_SIZE___49 = 146,
    SFE_FLAC_BAD_HEADER___49 = 147,
    SFE_FLAC_NEW_DECODER___49 = 148,
    SFE_FLAC_INIT_DECODER___49 = 149,
    SFE_FLAC_LOST_SYNC___49 = 150,
    SFE_FLAC_BAD_SAMPLE_RATE___49 = 151,
    SFE_FLAC_UNKOWN_ERROR___49 = 152,
    SFE_WVE_NOT_WVE___49 = 153,
    SFE_WVE_NO_PIPE___49 = 154,
    SFE_VORBIS_ENCODER_BUG___49 = 155,
    SFE_RF64_NOT_RF64___49 = 156,
    SFE_MAX_ERROR___49 = 157
} ;
#line 823
enum __anonenum__625___0 {
    SFC_TEST_AIFF_ADD_INST_CHUNK___49 = 8192,
    SFC_TEST_WAV_ADD_INFO_CHUNK___49 = 8208
} ;
#line 113 "/root/libsndfile/src/aiff.c"
enum __anonenum__626___0 {
    HAVE_FORM___0 = 1,
    HAVE_AIFF = 2,
    HAVE_AIFC = 4,
    HAVE_FVER = 8,
    HAVE_COMM = 16,
    HAVE_SSND = 32
} ;
#line 122 "/root/libsndfile/src/aiff.c"
struct __anonstruct_1143 {
   unsigned int size ;
   short numChannels ;
   unsigned int numSampleFrames ;
   short sampleSize ;
   unsigned char sampleRate[10] ;
   unsigned int encoding ;
   char zero_bytes[2] ;
};
#line 130 "/root/libsndfile/src/aiff.c"
typedef struct __anonstruct_1143 COMM_CHUNK;
#line 132 "/root/libsndfile/src/aiff.c"
struct __anonstruct_1144 {
   unsigned int offset ;
   unsigned int blocksize ;
};
#line 135 "/root/libsndfile/src/aiff.c"
typedef struct __anonstruct_1144 SSND_CHUNK;
#line 137 "/root/libsndfile/src/aiff.c"
struct __anonstruct_1145 {
   short playMode ;
   unsigned short beginLoop ;
   unsigned short endLoop ;
};
#line 141 "/root/libsndfile/src/aiff.c"
typedef struct __anonstruct_1145 INST_LOOP;
#line 143 "/root/libsndfile/src/aiff.c"
struct __anonstruct_1146 {
   char baseNote ;
   char detune ;
   char lowNote ;
   char highNote ;
   char lowVelocity ;
   char highVelocity ;
   short gain ;
   INST_LOOP sustain_loop ;
   INST_LOOP release_loop ;
};
#line 153 "/root/libsndfile/src/aiff.c"
typedef struct __anonstruct_1146 INST_CHUNK;
#line 156
enum __anonenum__1147 {
    basc_SCALE_MINOR = 1,
    basc_SCALE_MAJOR = 2,
    basc_SCALE_NEITHER = 3,
    basc_SCALE_BOTH = 4
} ;
#line 163
enum __anonenum__1148 {
    basc_TYPE_LOOP = 0,
    basc_TYPE_ONE_SHOT = 1
} ;
#line 169 "/root/libsndfile/src/aiff.c"
struct __anonstruct_1149 {
   unsigned int version ;
   unsigned int numBeats ;
   unsigned short rootNote ;
   unsigned short scaleType ;
   unsigned short sigNumerator ;
   unsigned short sigDenominator ;
   unsigned short loopType ;
};
#line 177 "/root/libsndfile/src/aiff.c"
typedef struct __anonstruct_1149 basc_CHUNK;
#line 179 "/root/libsndfile/src/aiff.c"
struct __anonstruct_1150 {
   unsigned short markerID ;
   unsigned int position ;
};
#line 182 "/root/libsndfile/src/aiff.c"
typedef struct __anonstruct_1150 MARK_ID_POS;
#line 184 "/root/libsndfile/src/aiff.c"
struct __anonstruct_1151 {
   PRIV_CHUNK4 chunk4 ;
   sf_count_t comm_offset ;
   sf_count_t ssnd_offset ;
   MARK_ID_POS *markstr ;
};
#line 191 "/root/libsndfile/src/aiff.c"
typedef struct __anonstruct_1151 AIFF_PRIVATE;
#line 46 "/usr/include/ctype.h"
enum __anonenum__1152 {
    _ISupper___25 = 256,
    _ISlower___25 = 512,
    _ISalpha___25 = 1024,
    _ISdigit___25 = 2048,
    _ISxdigit___25 = 4096,
    _ISspace___25 = 8192,
    _ISprint___25 = 16384,
    _ISgraph___25 = 32768,
    _ISblank___25 = 1,
    _IScntrl___25 = 2,
    _ISpunct___25 = 4,
    _ISalnum___25 = 8
} ;
#line 46 "/root/libsndfile/src/sndfile.h"
enum __anonenum__1155 {
    SF_FORMAT_WAV___50 = 65536,
    SF_FORMAT_AIFF___50 = 131072,
    SF_FORMAT_AU___50 = 196608,
    SF_FORMAT_RAW___50 = 262144,
    SF_FORMAT_PAF___50 = 327680,
    SF_FORMAT_SVX___50 = 393216,
    SF_FORMAT_NIST___50 = 458752,
    SF_FORMAT_VOC___50 = 524288,
    SF_FORMAT_IRCAM___50 = 655360,
    SF_FORMAT_W64___50 = 720896,
    SF_FORMAT_MAT4___50 = 786432,
    SF_FORMAT_MAT5___50 = 851968,
    SF_FORMAT_PVF___50 = 917504,
    SF_FORMAT_XI___50 = 983040,
    SF_FORMAT_HTK___50 = 1048576,
    SF_FORMAT_SDS___50 = 1114112,
    SF_FORMAT_AVR___50 = 1179648,
    SF_FORMAT_WAVEX___50 = 1245184,
    SF_FORMAT_SD2___50 = 1441792,
    SF_FORMAT_FLAC___50 = 1507328,
    SF_FORMAT_CAF___50 = 1572864,
    SF_FORMAT_WVE___50 = 1638400,
    SF_FORMAT_OGG___50 = 2097152,
    SF_FORMAT_MPC2K___50 = 2162688,
    SF_FORMAT_RF64___50 = 2228224,
    SF_FORMAT_PCM_S8___50 = 1,
    SF_FORMAT_PCM_16___50 = 2,
    SF_FORMAT_PCM_24___50 = 3,
    SF_FORMAT_PCM_32___50 = 4,
    SF_FORMAT_PCM_U8___50 = 5,
    SF_FORMAT_FLOAT___50 = 6,
    SF_FORMAT_DOUBLE___50 = 7,
    SF_FORMAT_ULAW___50 = 16,
    SF_FORMAT_ALAW___50 = 17,
    SF_FORMAT_IMA_ADPCM___50 = 18,
    SF_FORMAT_MS_ADPCM___50 = 19,
    SF_FORMAT_GSM610___50 = 32,
    SF_FORMAT_VOX_ADPCM___50 = 33,
    SF_FORMAT_G721_32___50 = 48,
    SF_FORMAT_G723_24___50 = 49,
    SF_FORMAT_G723_40___50 = 50,
    SF_FORMAT_DWVW_12___50 = 64,
    SF_FORMAT_DWVW_16___50 = 65,
    SF_FORMAT_DWVW_24___50 = 66,
    SF_FORMAT_DWVW_N___50 = 67,
    SF_FORMAT_DPCM_8___50 = 80,
    SF_FORMAT_DPCM_16___50 = 81,
    SF_FORMAT_VORBIS___50 = 96,
    SF_ENDIAN_FILE___50 = 0,
    SF_ENDIAN_LITTLE___50 = 268435456,
    SF_ENDIAN_BIG___50 = 536870912,
    SF_ENDIAN_CPU___50 = 805306368,
    SF_FORMAT_SUBMASK___50 = 65535,
    SF_FORMAT_TYPEMASK___50 = 268369920,
    SF_FORMAT_ENDMASK___50 = 805306368
} ;
#line 126
enum __anonenum__1156 {
    SFC_GET_LIB_VERSION___50 = 4096,
    SFC_GET_LOG_INFO___50 = 4097,
    SFC_GET_CURRENT_SF_INFO___50 = 4098,
    SFC_GET_NORM_DOUBLE___50 = 4112,
    SFC_GET_NORM_FLOAT___50 = 4113,
    SFC_SET_NORM_DOUBLE___50 = 4114,
    SFC_SET_NORM_FLOAT___50 = 4115,
    SFC_SET_SCALE_FLOAT_INT_READ___50 = 4116,
    SFC_SET_SCALE_INT_FLOAT_WRITE___50 = 4117,
    SFC_GET_SIMPLE_FORMAT_COUNT___50 = 4128,
    SFC_GET_SIMPLE_FORMAT___50 = 4129,
    SFC_GET_FORMAT_INFO___50 = 4136,
    SFC_GET_FORMAT_MAJOR_COUNT___50 = 4144,
    SFC_GET_FORMAT_MAJOR___50 = 4145,
    SFC_GET_FORMAT_SUBTYPE_COUNT___50 = 4146,
    SFC_GET_FORMAT_SUBTYPE___50 = 4147,
    SFC_CALC_SIGNAL_MAX___50 = 4160,
    SFC_CALC_NORM_SIGNAL_MAX___50 = 4161,
    SFC_CALC_MAX_ALL_CHANNELS___50 = 4162,
    SFC_CALC_NORM_MAX_ALL_CHANNELS___50 = 4163,
    SFC_GET_SIGNAL_MAX___50 = 4164,
    SFC_GET_MAX_ALL_CHANNELS___50 = 4165,
    SFC_SET_ADD_PEAK_CHUNK___50 = 4176,
    SFC_SET_ADD_HEADER_PAD_CHUNK___50 = 4177,
    SFC_UPDATE_HEADER_NOW___50 = 4192,
    SFC_SET_UPDATE_HEADER_AUTO___50 = 4193,
    SFC_FILE_TRUNCATE___50 = 4224,
    SFC_SET_RAW_START_OFFSET___50 = 4240,
    SFC_SET_DITHER_ON_WRITE___50 = 4256,
    SFC_SET_DITHER_ON_READ___50 = 4257,
    SFC_GET_DITHER_INFO_COUNT___50 = 4258,
    SFC_GET_DITHER_INFO___50 = 4259,
    SFC_GET_EMBED_FILE_INFO___50 = 4272,
    SFC_SET_CLIPPING___50 = 4288,
    SFC_GET_CLIPPING___50 = 4289,
    SFC_GET_INSTRUMENT___50 = 4304,
    SFC_SET_INSTRUMENT___50 = 4305,
    SFC_GET_LOOP_INFO___50 = 4320,
    SFC_GET_BROADCAST_INFO___50 = 4336,
    SFC_SET_BROADCAST_INFO___50 = 4337,
    SFC_GET_CHANNEL_MAP_INFO___50 = 4352,
    SFC_SET_CHANNEL_MAP_INFO___50 = 4353,
    SFC_RAW_DATA_NEEDS_ENDSWAP___50 = 4368,
    SFC_WAVEX_SET_AMBISONIC___50 = 4608,
    SFC_WAVEX_GET_AMBISONIC___50 = 4609,
    SFC_SET_VBR_ENCODING_QUALITY___50 = 4864,
    SFC_TEST_IEEE_FLOAT_REPLACE___50 = 24577,
    SFC_SET_ADD_DITHER_ON_WRITE___50 = 4208,
    SFC_SET_ADD_DITHER_ON_READ___50 = 4209
} ;
#line 216
enum __anonenum__1157 {
    SF_STR_TITLE___50 = 1,
    SF_STR_COPYRIGHT___50 = 2,
    SF_STR_SOFTWARE___50 = 3,
    SF_STR_ARTIST___50 = 4,
    SF_STR_COMMENT___50 = 5,
    SF_STR_DATE___50 = 6,
    SF_STR_ALBUM___50 = 7,
    SF_STR_LICENSE___50 = 8
} ;
#line 235
enum __anonenum__1158 {
    SF_FALSE___50 = 0,
    SF_TRUE___50 = 1,
    SFM_READ___50 = 16,
    SFM_WRITE___50 = 32,
    SFM_RDWR___50 = 48,
    SF_AMBISONIC_NONE___50 = 64,
    SF_AMBISONIC_B_FORMAT___50 = 65
} ;
#line 255
enum __anonenum__1159 {
    SF_ERR_NO_ERROR___50 = 0,
    SF_ERR_UNRECOGNISED_FORMAT___50 = 1,
    SF_ERR_SYSTEM___50 = 2,
    SF_ERR_MALFORMED_FILE___50 = 3,
    SF_ERR_UNSUPPORTED_ENCODING___50 = 4
} ;
#line 267
enum __anonenum__1160 {
    SF_CHANNEL_MAP_INVALID___50 = 0,
    SF_CHANNEL_MAP_MONO___50 = 1,
    SF_CHANNEL_MAP_LEFT___50 = 2,
    SF_CHANNEL_MAP_RIGHT___50 = 3,
    SF_CHANNEL_MAP_CENTER___50 = 4,
    SF_CHANNEL_MAP_FRONT_LEFT___50 = 5,
    SF_CHANNEL_MAP_FRONT_RIGHT___50 = 6,
    SF_CHANNEL_MAP_FRONT_CENTER___50 = 7,
    SF_CHANNEL_MAP_REAR_CENTER___50 = 8,
    SF_CHANNEL_MAP_REAR_LEFT___50 = 9,
    SF_CHANNEL_MAP_REAR_RIGHT___50 = 10,
    SF_CHANNEL_MAP_LFE___50 = 11,
    SF_CHANNEL_MAP_FRONT_LEFT_OF_CENTER___50 = 12,
    SF_CHANNEL_MAP_FRONT_RIGHT_OF_CENTER___50 = 13,
    SF_CHANNEL_MAP_SIDE_LEFT___50 = 14,
    SF_CHANNEL_MAP_SIDE_RIGHT___50 = 15,
    SF_CHANNEL_MAP_TOP_CENTER___50 = 16,
    SF_CHANNEL_MAP_TOP_FRONT_LEFT___50 = 17,
    SF_CHANNEL_MAP_TOP_FRONT_RIGHT___50 = 18,
    SF_CHANNEL_MAP_TOP_FRONT_CENTER___50 = 19,
    SF_CHANNEL_MAP_TOP_REAR_LEFT___50 = 20,
    SF_CHANNEL_MAP_TOP_REAR_RIGHT___50 = 21,
    SF_CHANNEL_MAP_TOP_REAR_CENTER___50 = 22
} ;
#line 352
enum __anonenum__1162 {
    SFD_DEFAULT_LEVEL___50 = 0,
    SFD_CUSTOM_LEVEL___50 = 1073741824,
    SFD_NO_DITHER___50 = 500,
    SFD_WHITE___50 = 501,
    SFD_TRIANGULAR_PDF___50 = 502
} ;
#line 380
enum __anonenum__1165 {
    SF_LOOP_NONE___50 = 800,
    SF_LOOP_FORWARD___50 = 801,
    SF_LOOP_BACKWARD___50 = 802,
    SF_LOOP_ALTERNATING___50 = 803
} ;
#line 121 "/root/libsndfile/src/common.h"
enum __anonenum__790___0 {
    SF_PEAK_START___50 = 42,
    SF_PEAK_END___50 = 43,
    SF_SCALE_MAX___50 = 52,
    SF_SCALE_MIN___50 = 53,
    SF_STR_ALLOW_START___50 = 256,
    SF_STR_ALLOW_END___50 = 512,
    SF_STR_LOCATE_START___50 = 1024,
    SF_STR_LOCATE_END___50 = 2048,
    SFD_TYPEMASK___50 = 268435455
} ;
#line 149
enum __anonenum__791___0 {
    SF_FORMAT_TXW___50 = 67305472,
    SF_FORMAT_DWD___50 = 67371008,
    SF_FORMAT_REX___50 = 67764224,
    SF_FORMAT_REX2___50 = 67960832,
    SF_FORMAT_KRZ___50 = 68026368,
    SF_FORMAT_WMA___50 = 68157440,
    SF_FORMAT_SHN___50 = 68222976,
    SF_FORMAT_SVX_FIB___50 = 4128,
    SF_FORMAT_SVX_EXP___50 = 4129,
    SF_FORMAT_PCM_N___50 = 4144
} ;
#line 405
enum __anonenum__797___0 {
    SFE_NO_ERROR___50 = 0,
    SFE_BAD_OPEN_FORMAT___50 = 1,
    SFE_SYSTEM___50 = 2,
    SFE_MALFORMED_FILE___50 = 3,
    SFE_UNSUPPORTED_ENCODING___50 = 4,
    SFE_ZERO_MAJOR_FORMAT___50 = 5,
    SFE_ZERO_MINOR_FORMAT___50 = 6,
    SFE_BAD_FILE___50 = 7,
    SFE_BAD_FILE_READ___50 = 8,
    SFE_OPEN_FAILED___50 = 9,
    SFE_BAD_SNDFILE_PTR___50 = 10,
    SFE_BAD_SF_INFO_PTR___50 = 11,
    SFE_BAD_SF_INCOMPLETE___50 = 12,
    SFE_BAD_FILE_PTR___50 = 13,
    SFE_BAD_INT_PTR___50 = 14,
    SFE_BAD_STAT_SIZE___50 = 15,
    SFE_MALLOC_FAILED___50 = 16,
    SFE_UNIMPLEMENTED___50 = 17,
    SFE_BAD_READ_ALIGN___50 = 18,
    SFE_BAD_WRITE_ALIGN___50 = 19,
    SFE_UNKNOWN_FORMAT___50 = 20,
    SFE_NOT_READMODE___50 = 21,
    SFE_NOT_WRITEMODE___50 = 22,
    SFE_BAD_MODE_RW___50 = 23,
    SFE_BAD_SF_INFO___50 = 24,
    SFE_BAD_OFFSET___50 = 25,
    SFE_NO_EMBED_SUPPORT___50 = 26,
    SFE_NO_EMBEDDED_RDWR___50 = 27,
    SFE_NO_PIPE_WRITE___50 = 28,
    SFE_INTERNAL___50 = 29,
    SFE_BAD_COMMAND_PARAM___50 = 30,
    SFE_BAD_ENDIAN___50 = 31,
    SFE_CHANNEL_COUNT_ZERO___50 = 32,
    SFE_CHANNEL_COUNT___50 = 33,
    SFE_BAD_VIRTUAL_IO___50 = 34,
    SFE_INTERLEAVE_MODE___50 = 35,
    SFE_INTERLEAVE_SEEK___50 = 36,
    SFE_INTERLEAVE_READ___50 = 37,
    SFE_BAD_SEEK___50 = 38,
    SFE_NOT_SEEKABLE___50 = 39,
    SFE_AMBIGUOUS_SEEK___50 = 40,
    SFE_WRONG_SEEK___50 = 41,
    SFE_SEEK_FAILED___50 = 42,
    SFE_BAD_OPEN_MODE___50 = 43,
    SFE_OPEN_PIPE_RDWR___50 = 44,
    SFE_RDWR_POSITION___50 = 45,
    SFE_RDWR_BAD_HEADER___50 = 46,
    SFE_CMD_HAS_DATA___50 = 47,
    SFE_BAD_BROADCAST_INFO_SIZE___50 = 48,
    SFE_STR_NO_SUPPORT___50 = 49,
    SFE_STR_NOT_WRITE___50 = 50,
    SFE_STR_MAX_DATA___50 = 51,
    SFE_STR_MAX_COUNT___50 = 52,
    SFE_STR_BAD_TYPE___50 = 53,
    SFE_STR_NO_ADD_END___50 = 54,
    SFE_STR_BAD_STRING___50 = 55,
    SFE_STR_WEIRD___50 = 56,
    SFE_WAV_NO_RIFF___50 = 57,
    SFE_WAV_NO_WAVE___50 = 58,
    SFE_WAV_NO_FMT___50 = 59,
    SFE_WAV_BAD_FMT___50 = 60,
    SFE_WAV_FMT_SHORT___50 = 61,
    SFE_WAV_BAD_FACT___50 = 62,
    SFE_WAV_BAD_PEAK___50 = 63,
    SFE_WAV_PEAK_B4_FMT___50 = 64,
    SFE_WAV_BAD_FORMAT___50 = 65,
    SFE_WAV_BAD_BLOCKALIGN___50 = 66,
    SFE_WAV_NO_DATA___50 = 67,
    SFE_WAV_BAD_LIST___50 = 68,
    SFE_WAV_ADPCM_NOT4BIT___50 = 69,
    SFE_WAV_ADPCM_CHANNELS___50 = 70,
    SFE_WAV_GSM610_FORMAT___50 = 71,
    SFE_WAV_UNKNOWN_CHUNK___50 = 72,
    SFE_WAV_WVPK_DATA___50 = 73,
    SFE_AIFF_NO_FORM___50 = 74,
    SFE_AIFF_AIFF_NO_FORM___50 = 75,
    SFE_AIFF_COMM_NO_FORM___50 = 76,
    SFE_AIFF_SSND_NO_COMM___50 = 77,
    SFE_AIFF_UNKNOWN_CHUNK___50 = 78,
    SFE_AIFF_COMM_CHUNK_SIZE___50 = 79,
    SFE_AIFF_BAD_COMM_CHUNK___50 = 80,
    SFE_AIFF_PEAK_B4_COMM___50 = 81,
    SFE_AIFF_BAD_PEAK___50 = 82,
    SFE_AIFF_NO_SSND___50 = 83,
    SFE_AIFF_NO_DATA___50 = 84,
    SFE_AIFF_RW_SSND_NOT_LAST___50 = 85,
    SFE_AU_UNKNOWN_FORMAT___50 = 86,
    SFE_AU_NO_DOTSND___50 = 87,
    SFE_AU_EMBED_BAD_LEN___50 = 88,
    SFE_RAW_READ_BAD_SPEC___50 = 89,
    SFE_RAW_BAD_BITWIDTH___50 = 90,
    SFE_RAW_BAD_FORMAT___50 = 91,
    SFE_PAF_NO_MARKER___50 = 92,
    SFE_PAF_VERSION___50 = 93,
    SFE_PAF_UNKNOWN_FORMAT___50 = 94,
    SFE_PAF_SHORT_HEADER___50 = 95,
    SFE_SVX_NO_FORM___50 = 96,
    SFE_SVX_NO_BODY___50 = 97,
    SFE_SVX_NO_DATA___50 = 98,
    SFE_SVX_BAD_COMP___50 = 99,
    SFE_SVX_BAD_NAME_LENGTH___50 = 100,
    SFE_NIST_BAD_HEADER___50 = 101,
    SFE_NIST_CRLF_CONVERISON___50 = 102,
    SFE_NIST_BAD_ENCODING___50 = 103,
    SFE_VOC_NO_CREATIVE___50 = 104,
    SFE_VOC_BAD_FORMAT___50 = 105,
    SFE_VOC_BAD_VERSION___50 = 106,
    SFE_VOC_BAD_MARKER___50 = 107,
    SFE_VOC_BAD_SECTIONS___50 = 108,
    SFE_VOC_MULTI_SAMPLERATE___50 = 109,
    SFE_VOC_MULTI_SECTION___50 = 110,
    SFE_VOC_MULTI_PARAM___50 = 111,
    SFE_VOC_SECTION_COUNT___50 = 112,
    SFE_VOC_NO_PIPE___50 = 113,
    SFE_IRCAM_NO_MARKER___50 = 114,
    SFE_IRCAM_BAD_CHANNELS___50 = 115,
    SFE_IRCAM_UNKNOWN_FORMAT___50 = 116,
    SFE_W64_64_BIT___50 = 117,
    SFE_W64_NO_RIFF___50 = 118,
    SFE_W64_NO_WAVE___50 = 119,
    SFE_W64_NO_DATA___50 = 120,
    SFE_W64_ADPCM_NOT4BIT___50 = 121,
    SFE_W64_ADPCM_CHANNELS___50 = 122,
    SFE_W64_GSM610_FORMAT___50 = 123,
    SFE_MAT4_BAD_NAME___50 = 124,
    SFE_MAT4_NO_SAMPLERATE___50 = 125,
    SFE_MAT5_BAD_ENDIAN___50 = 126,
    SFE_MAT5_NO_BLOCK___50 = 127,
    SFE_MAT5_SAMPLE_RATE___50 = 128,
    SFE_PVF_NO_PVF1___50 = 129,
    SFE_PVF_BAD_HEADER___50 = 130,
    SFE_PVF_BAD_BITWIDTH___50 = 131,
    SFE_DWVW_BAD_BITWIDTH___50 = 132,
    SFE_G72X_NOT_MONO___50 = 133,
    SFE_XI_BAD_HEADER___50 = 134,
    SFE_XI_EXCESS_SAMPLES___50 = 135,
    SFE_XI_NO_PIPE___50 = 136,
    SFE_HTK_NO_PIPE___50 = 137,
    SFE_SDS_NOT_SDS___50 = 138,
    SFE_SDS_BAD_BIT_WIDTH___50 = 139,
    SFE_SD2_FD_DISALLOWED___50 = 140,
    SFE_SD2_BAD_DATA_OFFSET___50 = 141,
    SFE_SD2_BAD_MAP_OFFSET___50 = 142,
    SFE_SD2_BAD_DATA_LENGTH___50 = 143,
    SFE_SD2_BAD_MAP_LENGTH___50 = 144,
    SFE_SD2_BAD_RSRC___50 = 145,
    SFE_SD2_BAD_SAMPLE_SIZE___50 = 146,
    SFE_FLAC_BAD_HEADER___50 = 147,
    SFE_FLAC_NEW_DECODER___50 = 148,
    SFE_FLAC_INIT_DECODER___50 = 149,
    SFE_FLAC_LOST_SYNC___50 = 150,
    SFE_FLAC_BAD_SAMPLE_RATE___50 = 151,
    SFE_FLAC_UNKOWN_ERROR___50 = 152,
    SFE_WVE_NOT_WVE___50 = 153,
    SFE_WVE_NO_PIPE___50 = 154,
    SFE_VORBIS_ENCODER_BUG___50 = 155,
    SFE_RF64_NOT_RF64___50 = 156,
    SFE_MAX_ERROR___50 = 157
} ;
#line 823
enum __anonenum__801___0 {
    SFC_TEST_AIFF_ADD_INST_CHUNK___50 = 8192,
    SFC_TEST_WAV_ADD_INFO_CHUNK___50 = 8208
} ;
#line 50 "/root/libsndfile/src/sndfile.c"
struct __anonstruct_1170 {
   int error ;
   char const   *str ;
};
#line 53 "/root/libsndfile/src/sndfile.c"
typedef struct __anonstruct_1170 ErrorStruct;
#line 46 "/usr/include/ctype.h"
enum __anonenum__1172 {
    _ISupper___26 = 256,
    _ISlower___26 = 512,
    _ISalpha___26 = 1024,
    _ISdigit___26 = 2048,
    _ISxdigit___26 = 4096,
    _ISspace___26 = 8192,
    _ISprint___26 = 16384,
    _ISgraph___26 = 32768,
    _ISblank___26 = 1,
    _IScntrl___26 = 2,
    _ISpunct___26 = 4,
    _ISalnum___26 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__1173 {
    FP_NAN___21 = 0,
    FP_INFINITE___21 = 1,
    FP_ZERO___21 = 2,
    FP_SUBNORMAL___21 = 3,
    FP_NORMAL___21 = 4
} ;
#line 46 "../src/sndfile.h"
enum __anonenum__1174 {
    SF_FORMAT_WAV___51 = 65536,
    SF_FORMAT_AIFF___51 = 131072,
    SF_FORMAT_AU___51 = 196608,
    SF_FORMAT_RAW___51 = 262144,
    SF_FORMAT_PAF___51 = 327680,
    SF_FORMAT_SVX___51 = 393216,
    SF_FORMAT_NIST___51 = 458752,
    SF_FORMAT_VOC___51 = 524288,
    SF_FORMAT_IRCAM___51 = 655360,
    SF_FORMAT_W64___51 = 720896,
    SF_FORMAT_MAT4___51 = 786432,
    SF_FORMAT_MAT5___51 = 851968,
    SF_FORMAT_PVF___51 = 917504,
    SF_FORMAT_XI___51 = 983040,
    SF_FORMAT_HTK___51 = 1048576,
    SF_FORMAT_SDS___51 = 1114112,
    SF_FORMAT_AVR___51 = 1179648,
    SF_FORMAT_WAVEX___51 = 1245184,
    SF_FORMAT_SD2___51 = 1441792,
    SF_FORMAT_FLAC___51 = 1507328,
    SF_FORMAT_CAF___51 = 1572864,
    SF_FORMAT_WVE___51 = 1638400,
    SF_FORMAT_OGG___51 = 2097152,
    SF_FORMAT_MPC2K___51 = 2162688,
    SF_FORMAT_RF64___51 = 2228224,
    SF_FORMAT_PCM_S8___51 = 1,
    SF_FORMAT_PCM_16___51 = 2,
    SF_FORMAT_PCM_24___51 = 3,
    SF_FORMAT_PCM_32___51 = 4,
    SF_FORMAT_PCM_U8___51 = 5,
    SF_FORMAT_FLOAT___51 = 6,
    SF_FORMAT_DOUBLE___51 = 7,
    SF_FORMAT_ULAW___51 = 16,
    SF_FORMAT_ALAW___51 = 17,
    SF_FORMAT_IMA_ADPCM___51 = 18,
    SF_FORMAT_MS_ADPCM___51 = 19,
    SF_FORMAT_GSM610___51 = 32,
    SF_FORMAT_VOX_ADPCM___51 = 33,
    SF_FORMAT_G721_32___51 = 48,
    SF_FORMAT_G723_24___51 = 49,
    SF_FORMAT_G723_40___51 = 50,
    SF_FORMAT_DWVW_12___51 = 64,
    SF_FORMAT_DWVW_16___51 = 65,
    SF_FORMAT_DWVW_24___51 = 66,
    SF_FORMAT_DWVW_N___51 = 67,
    SF_FORMAT_DPCM_8___51 = 80,
    SF_FORMAT_DPCM_16___51 = 81,
    SF_FORMAT_VORBIS___51 = 96,
    SF_ENDIAN_FILE___51 = 0,
    SF_ENDIAN_LITTLE___51 = 268435456,
    SF_ENDIAN_BIG___51 = 536870912,
    SF_ENDIAN_CPU___51 = 805306368,
    SF_FORMAT_SUBMASK___51 = 65535,
    SF_FORMAT_TYPEMASK___51 = 268369920,
    SF_FORMAT_ENDMASK___51 = 805306368
} ;
#line 126
enum __anonenum__1175 {
    SFC_GET_LIB_VERSION___51 = 4096,
    SFC_GET_LOG_INFO___51 = 4097,
    SFC_GET_CURRENT_SF_INFO___51 = 4098,
    SFC_GET_NORM_DOUBLE___51 = 4112,
    SFC_GET_NORM_FLOAT___51 = 4113,
    SFC_SET_NORM_DOUBLE___51 = 4114,
    SFC_SET_NORM_FLOAT___51 = 4115,
    SFC_SET_SCALE_FLOAT_INT_READ___51 = 4116,
    SFC_SET_SCALE_INT_FLOAT_WRITE___51 = 4117,
    SFC_GET_SIMPLE_FORMAT_COUNT___51 = 4128,
    SFC_GET_SIMPLE_FORMAT___51 = 4129,
    SFC_GET_FORMAT_INFO___51 = 4136,
    SFC_GET_FORMAT_MAJOR_COUNT___51 = 4144,
    SFC_GET_FORMAT_MAJOR___51 = 4145,
    SFC_GET_FORMAT_SUBTYPE_COUNT___51 = 4146,
    SFC_GET_FORMAT_SUBTYPE___51 = 4147,
    SFC_CALC_SIGNAL_MAX___51 = 4160,
    SFC_CALC_NORM_SIGNAL_MAX___51 = 4161,
    SFC_CALC_MAX_ALL_CHANNELS___51 = 4162,
    SFC_CALC_NORM_MAX_ALL_CHANNELS___51 = 4163,
    SFC_GET_SIGNAL_MAX___51 = 4164,
    SFC_GET_MAX_ALL_CHANNELS___51 = 4165,
    SFC_SET_ADD_PEAK_CHUNK___51 = 4176,
    SFC_SET_ADD_HEADER_PAD_CHUNK___51 = 4177,
    SFC_UPDATE_HEADER_NOW___51 = 4192,
    SFC_SET_UPDATE_HEADER_AUTO___51 = 4193,
    SFC_FILE_TRUNCATE___51 = 4224,
    SFC_SET_RAW_START_OFFSET___51 = 4240,
    SFC_SET_DITHER_ON_WRITE___51 = 4256,
    SFC_SET_DITHER_ON_READ___51 = 4257,
    SFC_GET_DITHER_INFO_COUNT___51 = 4258,
    SFC_GET_DITHER_INFO___51 = 4259,
    SFC_GET_EMBED_FILE_INFO___51 = 4272,
    SFC_SET_CLIPPING___51 = 4288,
    SFC_GET_CLIPPING___51 = 4289,
    SFC_GET_INSTRUMENT___51 = 4304,
    SFC_SET_INSTRUMENT___51 = 4305,
    SFC_GET_LOOP_INFO___51 = 4320,
    SFC_GET_BROADCAST_INFO___51 = 4336,
    SFC_SET_BROADCAST_INFO___51 = 4337,
    SFC_GET_CHANNEL_MAP_INFO___51 = 4352,
    SFC_SET_CHANNEL_MAP_INFO___51 = 4353,
    SFC_RAW_DATA_NEEDS_ENDSWAP___51 = 4368,
    SFC_WAVEX_SET_AMBISONIC___51 = 4608,
    SFC_WAVEX_GET_AMBISONIC___51 = 4609,
    SFC_SET_VBR_ENCODING_QUALITY___51 = 4864,
    SFC_TEST_IEEE_FLOAT_REPLACE___51 = 24577,
    SFC_SET_ADD_DITHER_ON_WRITE___51 = 4208,
    SFC_SET_ADD_DITHER_ON_READ___51 = 4209
} ;
#line 216
enum __anonenum__1176 {
    SF_STR_TITLE___51 = 1,
    SF_STR_COPYRIGHT___51 = 2,
    SF_STR_SOFTWARE___51 = 3,
    SF_STR_ARTIST___51 = 4,
    SF_STR_COMMENT___51 = 5,
    SF_STR_DATE___51 = 6,
    SF_STR_ALBUM___51 = 7,
    SF_STR_LICENSE___51 = 8
} ;
#line 235
enum __anonenum__1177 {
    SF_FALSE___51 = 0,
    SF_TRUE___51 = 1,
    SFM_READ___51 = 16,
    SFM_WRITE___51 = 32,
    SFM_RDWR___51 = 48,
    SF_AMBISONIC_NONE___51 = 64,
    SF_AMBISONIC_B_FORMAT___51 = 65
} ;
#line 255
enum __anonenum__1178 {
    SF_ERR_NO_ERROR___51 = 0,
    SF_ERR_UNRECOGNISED_FORMAT___51 = 1,
    SF_ERR_SYSTEM___51 = 2,
    SF_ERR_MALFORMED_FILE___51 = 3,
    SF_ERR_UNSUPPORTED_ENCODING___51 = 4
} ;
#line 267
enum __anonenum__1179 {
    SF_CHANNEL_MAP_INVALID___51 = 0,
    SF_CHANNEL_MAP_MONO___51 = 1,
    SF_CHANNEL_MAP_LEFT___51 = 2,
    SF_CHANNEL_MAP_RIGHT___51 = 3,
    SF_CHANNEL_MAP_CENTER___51 = 4,
    SF_CHANNEL_MAP_FRONT_LEFT___51 = 5,
    SF_CHANNEL_MAP_FRONT_RIGHT___51 = 6,
    SF_CHANNEL_MAP_FRONT_CENTER___51 = 7,
    SF_CHANNEL_MAP_REAR_CENTER___51 = 8,
    SF_CHANNEL_MAP_REAR_LEFT___51 = 9,
    SF_CHANNEL_MAP_REAR_RIGHT___51 = 10,
    SF_CHANNEL_MAP_LFE___51 = 11,
    SF_CHANNEL_MAP_FRONT_LEFT_OF_CENTER___51 = 12,
    SF_CHANNEL_MAP_FRONT_RIGHT_OF_CENTER___51 = 13,
    SF_CHANNEL_MAP_SIDE_LEFT___51 = 14,
    SF_CHANNEL_MAP_SIDE_RIGHT___51 = 15,
    SF_CHANNEL_MAP_TOP_CENTER___51 = 16,
    SF_CHANNEL_MAP_TOP_FRONT_LEFT___51 = 17,
    SF_CHANNEL_MAP_TOP_FRONT_RIGHT___51 = 18,
    SF_CHANNEL_MAP_TOP_FRONT_CENTER___51 = 19,
    SF_CHANNEL_MAP_TOP_REAR_LEFT___51 = 20,
    SF_CHANNEL_MAP_TOP_REAR_RIGHT___51 = 21,
    SF_CHANNEL_MAP_TOP_REAR_CENTER___51 = 22
} ;
#line 352
enum __anonenum__1181 {
    SFD_DEFAULT_LEVEL___51 = 0,
    SFD_CUSTOM_LEVEL___51 = 1073741824,
    SFD_NO_DITHER___51 = 500,
    SFD_WHITE___51 = 501,
    SFD_TRIANGULAR_PDF___51 = 502
} ;
#line 380
enum __anonenum__1184 {
    SF_LOOP_NONE___51 = 800,
    SF_LOOP_FORWARD___51 = 801,
    SF_LOOP_BACKWARD___51 = 802,
    SF_LOOP_ALTERNATING___51 = 803
} ;
#line 35 "/root/libsndfile/programs/common.h"
struct __anonstruct_1189 {
   char const   *title ;
   char const   *copyright ;
   char const   *artist ;
   char const   *comment ;
   char const   *date ;
   char const   *album ;
   char const   *license ;
   int has_bext_fields ;
   int coding_hist_append ;
   char const   *description ;
   char const   *originator ;
   char const   *originator_reference ;
   char const   *origination_date ;
   char const   *origination_time ;
   char const   *umid ;
   char const   *coding_history ;
};
#line 56 "/root/libsndfile/programs/common.h"
typedef struct __anonstruct_1189 METADATA_INFO;
#line 58 "/root/libsndfile/programs/common.h"
struct __anonstruct_1190 {
   char description[256] ;
   char originator[32] ;
   char originator_reference[32] ;
   char origination_date[10] ;
   char origination_time[8] ;
   unsigned int time_reference_low ;
   unsigned int time_reference_high ;
   short version ;
   char umid[64] ;
   char reserved[190] ;
   unsigned int coding_history_size ;
   char coding_history[2048] ;
};
#line 58 "/root/libsndfile/programs/common.h"
typedef struct __anonstruct_1190 SF_BROADCAST_INFO_2K;
#line 65 "/root/libsndfile/src/GSM610/gsm610_priv.h"
__inline static word SASR_W(word x , word by ) 
{ 


  {
#line 66
  return ((word )((int )x >> (int )by));
}
}
#line 70 "/root/libsndfile/src/GSM610/gsm610_priv.h"
__inline static longword SASR_L(longword x , word by ) 
{ 


  {
#line 71
  return (x >> (int )by);
}
}
#line 77
word gsm_mult(word a , word b ) ;
#line 78
longword gsm_L_mult(word a , word b ) ;
#line 79
word gsm_mult_r(word a , word b ) ;
#line 81
word gsm_div(word num , word denum ) ;
#line 83
word gsm_add(word a , word b ) ;
#line 84
longword gsm_L_add(longword a , longword b ) ;
#line 86
word gsm_sub(word a , word b ) ;
#line 87
longword gsm_L_sub(longword a , longword b ) ;
#line 89
word gsm_abs(word a ) ;
#line 91
word gsm_norm(longword a ) ;
#line 93
longword gsm_L_asl(longword a , int n ) ;
#line 94
word gsm_asl(word a , int n ) ;
#line 96
longword gsm_L_asr(longword a , int n ) ;
#line 97
word gsm_asr(word a , int n ) ;
#line 104 "/root/libsndfile/src/GSM610/gsm610_priv.h"
__inline static longword GSM_MULT_R(word a , word b ) 
{ 


  {
#line 105
  return (((longword )a * (longword )b + 16384) >> 15);
}
}
#line 109 "/root/libsndfile/src/GSM610/gsm610_priv.h"
__inline static longword GSM_MULT(word a , word b ) 
{ 


  {
#line 110
  return ((longword )a * (longword )b >> 15);
}
}
#line 114 "/root/libsndfile/src/GSM610/gsm610_priv.h"
__inline static longword GSM_L_MULT(word a , word b ) 
{ 


  {
#line 115
  return ((longword )a * (longword )b << 1);
}
}
#line 119 "/root/libsndfile/src/GSM610/gsm610_priv.h"
__inline static longword GSM_L_ADD(longword a , longword b ) 
{ 
  ulongword utmp ;
  int tmp ;
  unsigned int tmp___0 ;

  {
#line 122
  if (a < 0) {
#line 122
    if (b < 0) {
#line 123
      utmp = (ulongword )(- (a + 1)) + (ulongword )(- (b + 1));
#line 124
      if (utmp >= 2147483647U) {
#line 124
        tmp = (-0x7FFFFFFF-1);
      } else {
#line 124
        tmp = - ((longword )utmp) - 2;
      }
#line 124
      return (tmp);
    }
  }

#line 127
  if (a > 0) {
#line 127
    if (b > 0) {
#line 128
      utmp = (ulongword )a + (ulongword )b;
#line 129
      if (utmp >= 2147483647U) {
#line 129
        tmp___0 = (unsigned int )2147483647;
      } else {
#line 129
        tmp___0 = utmp;
      }
#line 129
      return ((longword )tmp___0);
    }
  }

#line 132
  return (a + b);
}
}
#line 136 "/root/libsndfile/src/GSM610/gsm610_priv.h"
__inline static longword GSM_ADD(word a , word b ) 
{ 
  longword ltmp ;

  {
#line 139
  ltmp = (longword )a + (longword )b;
#line 141
  if (ltmp >= 32767) {
#line 142
    return (32767);
  }
#line 143
  if (ltmp <= -32768) {
#line 144
    return (-32768);
  }
#line 146
  return (ltmp);
}
}
#line 150 "/root/libsndfile/src/GSM610/gsm610_priv.h"
__inline static longword GSM_SUB(word a , word b ) 
{ 
  longword ltmp ;

  {
#line 153
  ltmp = (longword )a - (longword )b;
#line 155
  if (ltmp >= 32767) {
#line 156
    ltmp = 32767;
  } else
#line 157
  if (ltmp <= -32768) {
#line 158
    ltmp = -32768;
  }
#line 160
  return (ltmp);
}
}
#line 164 "/root/libsndfile/src/GSM610/gsm610_priv.h"
__inline static word GSM_ABS(word a ) 
{ 


  {
#line 166
  if ((int )a > 0) {
#line 167
    return (a);
  }
#line 168
  if ((int )a == -32768) {
#line 169
    return ((word )32767);
  }
#line 170
  return ((word )(- ((int )a)));
}
}
#line 177
void Gsm_Coder(struct gsm_state *State , word *s , word *LARc , word *Nc , word *bc ,
               word *Mc , word *xmaxc , word *xMc ) ;
#line 187
void Gsm_Long_Term_Predictor(struct gsm_state *S , word *d , word *dp , word *e ,
                             word *dpp , word *Nc , word *bc ) ;
#line 196
void Gsm_LPC_Analysis(struct gsm_state *S , word *s , word *LARc ) ;
#line 201
void Gsm_Preprocess(struct gsm_state *S , word *s , word *so ) ;
#line 205
void Gsm_Encoding(struct gsm_state *S , word *e , word *ep , word *xmaxc , word *Mc ,
                  word *xMc ) ;
#line 213
void Gsm_Short_Term_Analysis_Filter(struct gsm_state *S , word *LARc , word *s ) ;
#line 218
void Gsm_Decoder(struct gsm_state *S , word *LARcr , word *Ncr , word *bcr , word *Mcr ,
                 word *xmaxcr , word *xMcr , word *s ) ;
#line 228
void Gsm_Decoding(struct gsm_state *S , word xmaxcr , word Mcr , word *xMcr , word *erp ) ;
#line 235
void Gsm_Long_Term_Synthesis_Filtering(struct gsm_state *S , word Ncr , word bcr ,
                                       word *erp , word *drp ) ;
#line 242
void Gsm_RPE_Decoding(word xmaxcr , word Mcr , word *xMcr , word *erp ) ;
#line 249
void Gsm_RPE_Encoding(word *e , word *xmaxc , word *Mc , word *xMc ) ;
#line 256
void Gsm_Short_Term_Synthesis_Filter(struct gsm_state *S , word *LARcr , word *wt ,
                                     word *s ) ;
#line 262
void Gsm_Update_of_reconstructed_short_time_residual_signal(word *dpp , word *ep ,
                                                            word *dp ) ;
#line 293
void gsm_debug_words(char *name , int  , int  , word * ) ;
#line 294
void gsm_debug_longwords(char *name , int  , int  , longword * ) ;
#line 295
void gsm_debug_longword(char *name , longword  ) ;
#line 296
void gsm_debug_word(char *name , word  ) ;
#line 22 "/root/libsndfile/src/GSM610/table.c"
word gsm_A[8]  = 
#line 22 "/root/libsndfile/src/GSM610/table.c"
  {      (word )20480,      (word )20480,      (word )20480,      (word )20480, 
        (word )13964,      (word )15360,      (word )8534,      (word )9036};
#line 23 "/root/libsndfile/src/GSM610/table.c"
word gsm_B[8]  = 
#line 23
  {      (word )0,      (word )0,      (word )2048,      (word )(- 2560), 
        (word )94,      (word )(- 1792),      (word )(- 341),      (word )(- 1144)};
#line 24 "/root/libsndfile/src/GSM610/table.c"
word gsm_MIC[8]  = 
#line 24
  {      (word )(- 32),      (word )(- 32),      (word )(- 16),      (word )(- 16), 
        (word )(- 8),      (word )(- 8),      (word )(- 4),      (word )(- 4)};
#line 25 "/root/libsndfile/src/GSM610/table.c"
word gsm_MAC[8]  = 
#line 25
  {      (word )31,      (word )31,      (word )15,      (word )15, 
        (word )7,      (word )7,      (word )3,      (word )3};
#line 30 "/root/libsndfile/src/GSM610/table.c"
word gsm_INVA[8]  = 
#line 30
  {      (word )13107,      (word )13107,      (word )13107,      (word )13107, 
        (word )19223,      (word )17476,      (word )31454,      (word )29708};
#line 36 "/root/libsndfile/src/GSM610/table.c"
word gsm_DLB[4]  = {      (word )6554,      (word )16384,      (word )26214,      (word )32767};
#line 42 "/root/libsndfile/src/GSM610/table.c"
word gsm_QLB[4]  = {      (word )3277,      (word )11469,      (word )21299,      (word )32767};
#line 48 "/root/libsndfile/src/GSM610/table.c"
word gsm_H[11]  = 
#line 48
  {      (word )(- 134),      (word )(- 374),      (word )0,      (word )2054, 
        (word )5741,      (word )8192,      (word )5741,      (word )2054, 
        (word )0,      (word )(- 374),      (word )(- 134)};
#line 54 "/root/libsndfile/src/GSM610/table.c"
word gsm_NRFAC[8]  = 
#line 54
  {      (word )29128,      (word )26215,      (word )23832,      (word )21846, 
        (word )20165,      (word )18725,      (word )17476,      (word )16384};
#line 60 "/root/libsndfile/src/GSM610/table.c"
word gsm_FAC[8]  = 
#line 60
  {      (word )18431,      (word )20479,      (word )22527,      (word )24575, 
        (word )26623,      (word )28671,      (word )30719,      (word )32767};
#line 137 "/usr/include/stdio.h"
extern FILE *stdin ;
#line 138
extern FILE *stdout ;
#line 139
extern FILE *stderr ;
#line 146
extern  __attribute__((__nothrow__)) int remove(char const   *__filename ) ;
#line 148
extern  __attribute__((__nothrow__)) int rename(char const   *__old , char const   *__new ) ;
#line 152
extern  __attribute__((__nothrow__)) int renameat(int __oldfd , char const   *__old ,
                                                  int __newfd , char const   *__new ) ;
#line 173
extern FILE *tmpfile(void) ;
#line 187
extern  __attribute__((__nothrow__)) char *tmpnam(char *__s ) ;
#line 192
extern  __attribute__((__nothrow__)) char *tmpnam_r(char *__s ) ;
#line 204
extern  __attribute__((__nothrow__)) char *tempnam(char const   *__dir , char const   *__pfx ) ;
#line 213
extern int fclose(FILE *__stream ) ;
#line 218
extern int fflush(FILE *__stream ) ;
#line 227
extern int fflush_unlocked(FILE *__stream ) ;
#line 246
extern FILE *fopen(char const   *__filename , char const   *__modes ) ;
#line 252
extern FILE *freopen(char const   *__filename , char const   *__modes , FILE *__stream ) ;
#line 279
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
#line 292
extern  __attribute__((__nothrow__)) FILE *fmemopen(void *__s , size_t __len , char const   *__modes ) ;
#line 298
extern  __attribute__((__nothrow__)) FILE *open_memstream(char **__bufloc , size_t *__sizeloc ) ;
#line 304
extern  __attribute__((__nothrow__)) void setbuf(FILE *__stream , char *__buf ) ;
#line 308
extern  __attribute__((__nothrow__)) int setvbuf(FILE *__stream , char *__buf , int __modes ,
                                                 size_t __n ) ;
#line 314
extern  __attribute__((__nothrow__)) void setbuffer(FILE *__stream , char *__buf ,
                                                    size_t __size ) ;
#line 318
extern  __attribute__((__nothrow__)) void setlinebuf(FILE *__stream ) ;
#line 326
__inline extern int fprintf(FILE *__stream , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 332
__inline extern int printf(char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 334
__inline extern  __attribute__((__nothrow__)) int sprintf(char *__s , char const   *__fmt 
                                                          , ...)  __attribute__((__gnu_inline__)) ;
#line 341
__inline extern int vfprintf(FILE *__stream , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 347
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 349
__inline extern  __attribute__((__nothrow__)) int vsprintf(char *__s , char const   *__fmt ,
                                                           __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 354
__inline extern  __attribute__((__nothrow__)) int snprintf(char *__s , size_t __n ,
                                                           char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 358
__inline extern  __attribute__((__nothrow__)) int vsnprintf(char *__s , size_t __n ,
                                                            char const   *__fmt ,
                                                            __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 379
__inline extern int vdprintf(int __fd , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 382
__inline extern int dprintf(int __fd , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 391
extern int fscanf(FILE *__stream , char const   *__format  , ...) ;
#line 397
extern int scanf(char const   *__format  , ...) ;
#line 399
extern  __attribute__((__nothrow__)) int sscanf(char const   *__s , char const   *__format 
                                                , ...) ;
#line 432
extern int vfscanf(FILE *__s , char const   *__format , __gnuc_va_list __arg ) ;
#line 440
extern int vscanf(char const   *__format , __gnuc_va_list __arg ) ;
#line 444
extern  __attribute__((__nothrow__)) int vsscanf(char const   *__s , char const   *__format ,
                                                 __gnuc_va_list __arg ) ;
#line 485
extern int fgetc(FILE *__stream ) ;
#line 486
extern int getc(FILE *__stream ) ;
#line 492
__inline extern int getchar(void)  __attribute__((__gnu_inline__)) ;
#line 499
__inline extern int getc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 500
__inline extern int getchar_unlocked(void)  __attribute__((__gnu_inline__)) ;
#line 510
__inline extern int fgetc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 521
extern int fputc(int __c , FILE *__stream ) ;
#line 522
extern int putc(int __c , FILE *__stream ) ;
#line 528
__inline extern int putchar(int __c )  __attribute__((__gnu_inline__)) ;
#line 537
__inline extern int fputc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 545
__inline extern int putc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 546
__inline extern int putchar_unlocked(int __c )  __attribute__((__gnu_inline__)) ;
#line 553
extern int getw(FILE *__stream ) ;
#line 556
extern int putw(int __w , FILE *__stream ) ;
#line 564
__inline extern char *fgets(char *__s , int __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 577
__inline extern char *gets(char *__str )  __attribute__((__gnu_inline__)) ;
#line 603
extern __ssize_t __getdelim(char **__lineptr , size_t *__n , int __delimiter , FILE *__stream ) ;
#line 606
extern __ssize_t getdelim(char **__lineptr , size_t *__n , int __delimiter , FILE *__stream ) ;
#line 616
extern __ssize_t getline(char **__lineptr , size_t *__n , FILE *__stream ) ;
#line 626
extern int fputs(char const   *__s , FILE *__stream ) ;
#line 632
extern int puts(char const   *__s ) ;
#line 639
extern int ungetc(int __c , FILE *__stream ) ;
#line 646
__inline extern unsigned long fread(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 652
extern unsigned long fwrite(void const   *__ptr , size_t __size , size_t __n , FILE *__s ) ;
#line 673
__inline extern size_t fread_unlocked(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 675
extern size_t fwrite_unlocked(void const   *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 684
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 689
extern long ftell(FILE *__stream ) ;
#line 694
extern void rewind(FILE *__stream ) ;
#line 707
extern int fseeko(FILE *__stream , __off_t __off , int __whence ) ;
#line 712
extern __off_t ftello(FILE *__stream ) ;
#line 731
extern int fgetpos(FILE *__stream , fpos_t *__pos ) ;
#line 736
extern int fsetpos(FILE *__stream , fpos_t *__pos ) ;
#line 757
extern  __attribute__((__nothrow__)) void clearerr(FILE *__stream ) ;
#line 759
extern  __attribute__((__nothrow__)) int feof(FILE *__stream ) ;
#line 761
extern  __attribute__((__nothrow__)) int ferror(FILE *__stream ) ;
#line 765
extern  __attribute__((__nothrow__)) void clearerr_unlocked(FILE *__stream ) ;
#line 766
__inline extern  __attribute__((__nothrow__)) int feof_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 767
__inline extern  __attribute__((__nothrow__)) int ferror_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 775
extern void perror(char const   *__s ) ;
#line 26 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h"
extern int sys_nerr ;
#line 27
extern char const   * const  sys_errlist[] ;
#line 786 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 791
extern  __attribute__((__nothrow__)) int fileno_unlocked(FILE *__stream ) ;
#line 800
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 806
extern int pclose(FILE *__stream ) ;
#line 812
extern  __attribute__((__nothrow__)) char *ctermid(char *__s ) ;
#line 840
extern  __attribute__((__nothrow__)) void flockfile(FILE *__stream ) ;
#line 844
extern  __attribute__((__nothrow__)) int ftrylockfile(FILE *__stream ) ;
#line 847
extern  __attribute__((__nothrow__)) void funlockfile(FILE *__stream ) ;
#line 858
extern int __uflow(FILE * ) ;
#line 859
extern int __overflow(FILE * , int  ) ;
#line 47 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar(void)  __attribute__((__gnu_inline__)) ;
#line 47 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar(void) 
{ 
  int __cil_tmp1 ;

  {
  {
#line 49
  __cil_tmp1 = getc(stdin);
  }
#line 49
  return (__cil_tmp1);
}
}
#line 56
__inline extern int fgetc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 56 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int fgetc_unlocked(FILE *__fp ) 
{ 
  long __cil_tmp2 ;
  int __cil_tmp3 ;
  char *__cil_tmp4 ;
  int tmp ;

  {
  {
#line 58
  __cil_tmp2 = __builtin_expect((long )(__fp->_IO_read_ptr >= __fp->_IO_read_end),
                                (long )0);
  }
#line 58
  if (__cil_tmp2) {
    {
#line 58
    __cil_tmp3 = __uflow(__fp);
#line 58
    tmp = __cil_tmp3;
    }
  } else {
#line 58
    (__fp->_IO_read_ptr) ++;
#line 58
    tmp = (int )*((unsigned char *)__fp->_IO_read_ptr);
  }
#line 58
  return (tmp);
}
}
#line 73
__inline extern int getchar_unlocked(void)  __attribute__((__gnu_inline__)) ;
#line 73 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar_unlocked(void) 
{ 
  long __cil_tmp1 ;
  int __cil_tmp2 ;
  char *__cil_tmp3 ;
  int tmp ;

  {
  {
#line 75
  __cil_tmp1 = __builtin_expect((long )(stdin->_IO_read_ptr >= stdin->_IO_read_end),
                                (long )0);
  }
#line 75
  if (__cil_tmp1) {
    {
#line 75
    __cil_tmp2 = __uflow(stdin);
#line 75
    tmp = __cil_tmp2;
    }
  } else {
#line 75
    (stdin->_IO_read_ptr) ++;
#line 75
    tmp = (int )*((unsigned char *)stdin->_IO_read_ptr);
  }
#line 75
  return (tmp);
}
}
#line 82
__inline extern int putchar(int __c )  __attribute__((__gnu_inline__)) ;
#line 82 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int putchar(int __c ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 84
  __cil_tmp2 = putc(__c, stdout);
  }
#line 84
  return (__cil_tmp2);
}
}
#line 91
__inline extern int fputc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 91 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int fputc_unlocked(int __c , FILE *__stream ) 
{ 
  long __cil_tmp3 ;
  int __cil_tmp4 ;
  char *__cil_tmp5 ;
  int tmp ;

  {
  {
#line 93
  __cil_tmp3 = __builtin_expect((long )(__stream->_IO_write_ptr >= __stream->_IO_write_end),
                                (long )0);
  }
#line 93
  if (__cil_tmp3) {
    {
#line 93
    __cil_tmp4 = __overflow(__stream, (int )((unsigned char )__c));
#line 93
    tmp = __cil_tmp4;
    }
  } else {
#line 93
    __cil_tmp5 = __stream->_IO_write_ptr;
#line 93
    (__stream->_IO_write_ptr) ++;
#line 93
    *__cil_tmp5 = (char )__c;
#line 93
    tmp = (int )((unsigned char )*__cil_tmp5);
  }
#line 93
  return (tmp);
}
}
#line 108
__inline extern int putchar_unlocked(int __c )  __attribute__((__gnu_inline__)) ;
#line 108 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int putchar_unlocked(int __c ) 
{ 
  long __cil_tmp2 ;
  int __cil_tmp3 ;
  char *__cil_tmp4 ;
  int tmp ;

  {
  {
#line 110
  __cil_tmp2 = __builtin_expect((long )(stdout->_IO_write_ptr >= stdout->_IO_write_end),
                                (long )0);
  }
#line 110
  if (__cil_tmp2) {
    {
#line 110
    __cil_tmp3 = __overflow(stdout, (int )((unsigned char )__c));
#line 110
    tmp = __cil_tmp3;
    }
  } else {
#line 110
    __cil_tmp4 = stdout->_IO_write_ptr;
#line 110
    (stdout->_IO_write_ptr) ++;
#line 110
    *__cil_tmp4 = (char )__c;
#line 110
    tmp = (int )((unsigned char )*__cil_tmp4);
  }
#line 110
  return (tmp);
}
}
#line 128
__inline extern  __attribute__((__nothrow__)) int feof_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 128 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int feof_unlocked(FILE *__stream ) 
{ 


  {
#line 130
  return ((__stream->_flags & 16) != 0);
}
}
#line 135
__inline extern  __attribute__((__nothrow__)) int ferror_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 135 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ferror_unlocked(FILE *__stream ) 
{ 


  {
#line 137
  return ((__stream->_flags & 32) != 0);
}
}
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
extern  __attribute__((__nothrow__)) int __sprintf_chk(char *__s , int __flag , size_t __slen ,
                                                       char const   *__format  , ...) ;
#line 28
extern  __attribute__((__nothrow__)) int __vsprintf_chk(char *__s , int __flag , size_t __slen ,
                                                        char const   *__format , __gnuc_va_list __ap ) ;
#line 34
__inline extern  __attribute__((__nothrow__)) int sprintf(char *__s , char const   *__fmt 
                                                          , ...)  __attribute__((__gnu_inline__)) ;
#line 34 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int sprintf(char *__s , char const   *__fmt  , ...) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 36
  __cil_tmp3 = __builtin_object_size(__s, 1);
  }
  {
#line 36
  __cil_tmp4 = __builtin_va_arg_pack();
#line 36
  __cil_tmp5 = __builtin___sprintf_chk(__s, 1, __cil_tmp3, __fmt, __cil_tmp4);
  }
#line 36
  return (__cil_tmp5);
}
}
#line 46
__inline extern  __attribute__((__nothrow__)) int vsprintf(char *__s , char const   *__fmt ,
                                                           __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vsprintf(char *__s , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 49
  __cil_tmp4 = __builtin_object_size(__s, 1);
#line 49
  __cil_tmp5 = __builtin___vsprintf_chk(__s, 1, __cil_tmp4, __fmt, __ap);
  }
#line 49
  return (__cil_tmp5);
}
}
#line 55
extern  __attribute__((__nothrow__)) int __snprintf_chk(char *__s , size_t __n , int __flag ,
                                                        size_t __slen , char const   *__format 
                                                        , ...) ;
#line 58
extern  __attribute__((__nothrow__)) int __vsnprintf_chk(char *__s , size_t __n ,
                                                         int __flag , size_t __slen ,
                                                         char const   *__format ,
                                                         __gnuc_va_list __ap ) ;
#line 64
__inline extern  __attribute__((__nothrow__)) int snprintf(char *__s , size_t __n ,
                                                           char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 64 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int snprintf(char *__s , size_t __n , char const   *__fmt  , ...) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 67
  __cil_tmp4 = __builtin_object_size(__s, 1);
  }
  {
#line 67
  __cil_tmp5 = __builtin_va_arg_pack();
#line 67
  __cil_tmp6 = __builtin___snprintf_chk(__s, __n, 1, __cil_tmp4, __fmt, __cil_tmp5);
  }
#line 67
  return (__cil_tmp6);
}
}
#line 77
__inline extern  __attribute__((__nothrow__)) int vsnprintf(char *__s , size_t __n ,
                                                            char const   *__fmt ,
                                                            __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 77 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vsnprintf(char *__s , size_t __n , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 80
  __cil_tmp5 = __builtin_object_size(__s, 1);
#line 80
  __cil_tmp6 = __builtin___vsnprintf_chk(__s, __n, 1, __cil_tmp5, __fmt, __ap);
  }
#line 80
  return (__cil_tmp6);
}
}
#line 88
extern int __fprintf_chk(FILE *__stream , int __flag , char const   *__format  , ...) ;
#line 90
extern int __printf_chk(int __flag , char const   *__format  , ...) ;
#line 91
extern int __vfprintf_chk(FILE *__stream , int __flag , char const   *__format , __gnuc_va_list __ap ) ;
#line 93
extern int __vprintf_chk(int __flag , char const   *__format , __gnuc_va_list __ap ) ;
#line 98
__inline extern int fprintf(FILE *__stream , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 98 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int fprintf(FILE *__stream , char const   *__fmt  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 100
  __cil_tmp3 = __builtin_va_arg_pack();
#line 100
  __cil_tmp4 = __fprintf_chk(__stream, 1, __fmt, __cil_tmp3);
  }
#line 100
  return (__cil_tmp4);
}
}
#line 105
__inline extern int printf(char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 105 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int printf(char const   *__fmt  , ...) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;

  {
  {
#line 107
  __cil_tmp2 = __builtin_va_arg_pack();
#line 107
  __cil_tmp3 = __printf_chk(1, __fmt, __cil_tmp2);
  }
#line 107
  return (__cil_tmp3);
}
}
#line 117
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 117 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 120
  __cil_tmp3 = __vfprintf_chk(stdout, 1, __fmt, __ap);
  }
#line 120
  return (__cil_tmp3);
}
}
#line 127
__inline extern int vfprintf(FILE *__stream , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 127 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vfprintf(FILE *__stream , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 130
  __cil_tmp4 = __vfprintf_chk(__stream, 1, __fmt, __ap);
  }
#line 130
  return (__cil_tmp4);
}
}
#line 134
extern int __dprintf_chk(int __fd , int __flag , char const   *__fmt  , ...) ;
#line 136
extern int __vdprintf_chk(int __fd , int __flag , char const   *__fmt , __gnuc_va_list __arg ) ;
#line 142
__inline extern int dprintf(int __fd , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 142 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int dprintf(int __fd , char const   *__fmt  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 144
  __cil_tmp3 = __builtin_va_arg_pack();
#line 144
  __cil_tmp4 = __dprintf_chk(__fd, 1, __fmt, __cil_tmp3);
  }
#line 144
  return (__cil_tmp4);
}
}
#line 153
__inline extern int vdprintf(int __fd , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 153 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vdprintf(int __fd , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 155
  __cil_tmp4 = __vdprintf_chk(__fd, 1, __fmt, __ap);
  }
#line 155
  return (__cil_tmp4);
}
}
#line 229
extern char *__gets_chk(char *__str , size_t  ) ;
#line 230
extern char *__gets_warn(char *__str ) ;
#line 235
__inline extern char *gets(char *__str )  __attribute__((__gnu_inline__)) ;
#line 235 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern char *gets(char *__str ) 
{ 
  unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 237
  __cil_tmp2 = __builtin_object_size(__str, 1);
  }
#line 237
  if (__cil_tmp2 != 0xffffffffffffffffUL) {
    {
#line 238
    __cil_tmp3 = __builtin_object_size(__str, 1);
#line 238
    __cil_tmp4 = __gets_chk(__str, __cil_tmp3);
    }
#line 238
    return (__cil_tmp4);
  }
  {
#line 239
  __cil_tmp5 = __gets_warn(__str);
  }
#line 239
  return (__cil_tmp5);
}
}
#line 243
extern char *__fgets_chk(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 245
extern char *__fgets_alias(char *__s , int __n , FILE *__stream ) ;
#line 248
extern char *__fgets_chk_warn(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 255
__inline extern char *fgets(char *__s , int __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 255 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern char *fgets(char *__s , int __n , FILE *__stream ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  char *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 257
  __cil_tmp4 = __builtin_object_size(__s, 1);
  }
#line 257
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 259
    __cil_tmp5 = __builtin_constant_p(__n);
    }
#line 259
    if (! __cil_tmp5) {
      {
      {
#line 260
      __cil_tmp6 = __builtin_object_size(__s, 1);
      }
      {
#line 260
      __cil_tmp7 = __fgets_chk(__s, __cil_tmp6, __n, __stream);
      }
      }
#line 260
      return (__cil_tmp7);
    } else
#line 259
    if (__n <= 0) {
      {
      {
#line 260
      __cil_tmp6 = __builtin_object_size(__s, 1);
      }
      {
#line 260
      __cil_tmp7 = __fgets_chk(__s, __cil_tmp6, __n, __stream);
      }
      }
#line 260
      return (__cil_tmp7);
    }
    {
#line 262
    __cil_tmp8 = __builtin_object_size(__s, 1);
    }
#line 262
    if ((size_t )__n > __cil_tmp8) {
      {
#line 263
      __cil_tmp9 = __builtin_object_size(__s, 1);
#line 263
      __cil_tmp10 = __fgets_chk_warn(__s, __cil_tmp9, __n, __stream);
      }
#line 263
      return (__cil_tmp10);
    }
  }
  {
#line 265
  __cil_tmp11 = __fgets_alias(__s, __n, __stream);
  }
#line 265
  return (__cil_tmp11);
}
}
#line 268
extern size_t __fread_chk(void *__ptr , size_t __ptrlen , size_t __size , size_t __n ,
                          FILE *__stream ) ;
#line 271
extern size_t __fread_alias(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 275
extern size_t __fread_chk_warn(void *__ptr , size_t __ptrlen , size_t __size , size_t __n ,
                               FILE *__stream ) ;
#line 284
__inline extern unsigned long fread(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 284 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern unsigned long fread(void *__ptr , size_t __size , size_t __n , FILE *__stream ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  size_t __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  size_t __cil_tmp12 ;
  size_t __cil_tmp13 ;

  {
  {
#line 287
  __cil_tmp5 = __builtin_object_size(__ptr, 0);
  }
#line 287
  if (__cil_tmp5 != 0xffffffffffffffffUL) {
    {
#line 289
    __cil_tmp7 = __builtin_constant_p(__n);
    }
    {
#line 289
    __cil_tmp6 = __builtin_constant_p(__size);
    }
#line 289
    if (! __cil_tmp6) {
      {
      {
      {
#line 292
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 292
      __cil_tmp9 = __fread_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 292
      return (__cil_tmp9);
    } else
#line 289
    if (! __cil_tmp7) {
      {
      {
      {
#line 292
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 292
      __cil_tmp9 = __fread_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 292
      return (__cil_tmp9);
    } else
#line 289
    if ((__size | __n) >= 1UL << (8UL * sizeof(size_t )) / 2UL) {
      {
      {
      {
#line 292
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 292
      __cil_tmp9 = __fread_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 292
      return (__cil_tmp9);
    }
    {
#line 294
    __cil_tmp10 = __builtin_object_size(__ptr, 0);
    }
#line 294
    if (__size * __n > __cil_tmp10) {
      {
#line 295
      __cil_tmp11 = __builtin_object_size(__ptr, 0);
#line 295
      __cil_tmp12 = __fread_chk_warn(__ptr, __cil_tmp11, __size, __n, __stream);
      }
#line 295
      return (__cil_tmp12);
    }
  }
  {
#line 297
  __cil_tmp13 = __fread_alias(__ptr, __size, __n, __stream);
  }
#line 297
  return (__cil_tmp13);
}
}
#line 329
extern size_t __fread_unlocked_chk(void *__ptr , size_t __ptrlen , size_t __size ,
                                   size_t __n , FILE *__stream ) ;
#line 332
extern size_t __fread_unlocked_alias(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 336
extern size_t __fread_unlocked_chk_warn(void *__ptr , size_t __ptrlen , size_t __size ,
                                        size_t __n , FILE *__stream ) ;
#line 345
__inline extern size_t fread_unlocked(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 345 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern size_t fread_unlocked(void *__ptr , size_t __size , size_t __n , FILE *__stream ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  size_t __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  size_t __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  size_t __cnt ;
  char *__cptr ;
  int __c ;
  int __cil_tmp18 ;
  char *__cil_tmp19 ;
  size_t __cil_tmp20 ;

  {
  {
#line 348
  __cil_tmp5 = __builtin_object_size(__ptr, 0);
  }
#line 348
  if (__cil_tmp5 != 0xffffffffffffffffUL) {
    {
#line 350
    __cil_tmp7 = __builtin_constant_p(__n);
    }
    {
#line 350
    __cil_tmp6 = __builtin_constant_p(__size);
    }
#line 350
    if (! __cil_tmp6) {
      {
      {
      {
#line 353
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 353
      __cil_tmp9 = __fread_unlocked_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 353
      return (__cil_tmp9);
    } else
#line 350
    if (! __cil_tmp7) {
      {
      {
      {
#line 353
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 353
      __cil_tmp9 = __fread_unlocked_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 353
      return (__cil_tmp9);
    } else
#line 350
    if ((__size | __n) >= 1UL << (8UL * sizeof(size_t )) / 2UL) {
      {
      {
      {
#line 353
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 353
      __cil_tmp9 = __fread_unlocked_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 353
      return (__cil_tmp9);
    }
    {
#line 356
    __cil_tmp10 = __builtin_object_size(__ptr, 0);
    }
#line 356
    if (__size * __n > __cil_tmp10) {
      {
#line 357
      __cil_tmp11 = __builtin_object_size(__ptr, 0);
#line 357
      __cil_tmp12 = __fread_unlocked_chk_warn(__ptr, __cil_tmp11, __size, __n, __stream);
      }
#line 357
      return (__cil_tmp12);
    }
  }
  {
#line 362
  __cil_tmp14 = __builtin_constant_p(__n);
  }
  {
#line 362
  __cil_tmp13 = __builtin_constant_p(__size);
  }
#line 362
  if (__cil_tmp13) {
#line 362
    if (__cil_tmp14) {
#line 362
      if ((__size | __n) < 1UL << (8UL * sizeof(size_t )) / 2UL) {
#line 362
        if (__size * __n <= 8UL) {
#line 367
          __cnt = __size * __n;
#line 368
          __cptr = (char *)__ptr;
#line 369
          if (__cnt == 0UL) {
#line 370
            return ((size_t )0);
          }
          {
#line 372
          while (1) {
            while_continue: /* CIL Label */ ;
#line 372
            if (! (__cnt > 0UL)) {
#line 372
              goto while_break;
            }
            {
#line 374
            __cil_tmp18 = getc_unlocked(__stream);
#line 374
            __c = __cil_tmp18;
            }
#line 375
            if (__c == -1) {
#line 376
              goto while_break;
            }
#line 377
            __cil_tmp19 = __cptr;
#line 377
            __cptr ++;
#line 377
            *__cil_tmp19 = (char )__c;
#line 372
            __cnt --;
          }
          while_break: /* CIL Label */ ;
          }
#line 379
          return ((unsigned long )(__cptr - (char *)__ptr) / __size);
        }
      }
    }
  }
  {
#line 382
  __cil_tmp20 = __fread_unlocked_alias(__ptr, __size, __n, __stream);
  }
#line 382
  return (__cil_tmp20);
}
}
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__)) void __assert_fail(char const   *__assertion ,
                                                        char const   *__file , unsigned int __line ,
                                                        char const   *__function ) ;
#line 74
extern  __attribute__((__nothrow__)) void __assert_perror_fail(int __errnum , char const   *__file ,
                                                               unsigned int __line ,
                                                               char const   *__function ) ;
#line 81
extern  __attribute__((__nothrow__)) void __assert(char const   *__assertion , char const   *__file ,
                                                   int __line ) ;
#line 18 "/root/libsndfile/src/GSM610/short_term.c"
static void Decoding_of_the_coded_Log_Area_Ratios(word *LARc , word *LARpp ) 
{ 
  register word temp1 ;
  word *__cil_tmp4 ;
  longword __cil_tmp5 ;
  longword __cil_tmp6 ;
  longword __cil_tmp7 ;
  word *__cil_tmp8 ;
  longword __cil_tmp9 ;
  word *__cil_tmp10 ;
  longword __cil_tmp11 ;
  longword __cil_tmp12 ;
  longword __cil_tmp13 ;
  word *__cil_tmp14 ;
  longword __cil_tmp15 ;
  word *__cil_tmp16 ;
  longword __cil_tmp17 ;
  longword __cil_tmp18 ;
  longword __cil_tmp19 ;
  word *__cil_tmp20 ;
  longword __cil_tmp21 ;
  word *__cil_tmp22 ;
  longword __cil_tmp23 ;
  longword __cil_tmp24 ;
  longword __cil_tmp25 ;
  word *__cil_tmp26 ;
  longword __cil_tmp27 ;
  word *__cil_tmp28 ;
  longword __cil_tmp29 ;
  longword __cil_tmp30 ;
  longword __cil_tmp31 ;
  word *__cil_tmp32 ;
  longword __cil_tmp33 ;
  word *__cil_tmp34 ;
  longword __cil_tmp35 ;
  longword __cil_tmp36 ;
  longword __cil_tmp37 ;
  word *__cil_tmp38 ;
  longword __cil_tmp39 ;
  word *__cil_tmp40 ;
  longword __cil_tmp41 ;
  longword __cil_tmp42 ;
  longword __cil_tmp43 ;
  word *__cil_tmp44 ;
  longword __cil_tmp45 ;
  word *__cil_tmp46 ;
  longword __cil_tmp47 ;
  longword __cil_tmp48 ;
  longword __cil_tmp49 ;
  word *__cil_tmp50 ;
  longword __cil_tmp51 ;

  {
  {
#line 54
  __cil_tmp4 = LARc;
#line 54
  LARc ++;
#line 54
  __cil_tmp5 = GSM_ADD(*__cil_tmp4, (word )(- 32));
#line 54
  temp1 = (word )(__cil_tmp5 << 10);
#line 54
  __cil_tmp6 = GSM_SUB(temp1, (word )0);
#line 54
  temp1 = (word )__cil_tmp6;
#line 54
  __cil_tmp7 = GSM_MULT_R((word )13107, temp1);
#line 54
  temp1 = (word )__cil_tmp7;
#line 54
  __cil_tmp9 = GSM_ADD(temp1, temp1);
  }
  {
#line 54
  __cil_tmp8 = LARpp;
#line 54
  LARpp ++;
#line 54
  *__cil_tmp8 = (word )__cil_tmp9;
#line 55
  __cil_tmp10 = LARc;
#line 55
  LARc ++;
#line 55
  __cil_tmp11 = GSM_ADD(*__cil_tmp10, (word )(- 32));
#line 55
  temp1 = (word )(__cil_tmp11 << 10);
#line 55
  __cil_tmp12 = GSM_SUB(temp1, (word )0);
#line 55
  temp1 = (word )__cil_tmp12;
#line 55
  __cil_tmp13 = GSM_MULT_R((word )13107, temp1);
#line 55
  temp1 = (word )__cil_tmp13;
#line 55
  __cil_tmp15 = GSM_ADD(temp1, temp1);
  }
  {
#line 55
  __cil_tmp14 = LARpp;
#line 55
  LARpp ++;
#line 55
  *__cil_tmp14 = (word )__cil_tmp15;
#line 56
  __cil_tmp16 = LARc;
#line 56
  LARc ++;
#line 56
  __cil_tmp17 = GSM_ADD(*__cil_tmp16, (word )(- 16));
#line 56
  temp1 = (word )(__cil_tmp17 << 10);
#line 56
  __cil_tmp18 = GSM_SUB(temp1, (word )(2048 << 1));
#line 56
  temp1 = (word )__cil_tmp18;
#line 56
  __cil_tmp19 = GSM_MULT_R((word )13107, temp1);
#line 56
  temp1 = (word )__cil_tmp19;
#line 56
  __cil_tmp21 = GSM_ADD(temp1, temp1);
  }
  {
#line 56
  __cil_tmp20 = LARpp;
#line 56
  LARpp ++;
#line 56
  *__cil_tmp20 = (word )__cil_tmp21;
#line 57
  __cil_tmp22 = LARc;
#line 57
  LARc ++;
#line 57
  __cil_tmp23 = GSM_ADD(*__cil_tmp22, (word )(- 16));
#line 57
  temp1 = (word )(__cil_tmp23 << 10);
#line 57
  __cil_tmp24 = GSM_SUB(temp1, (word )(-2560 << 1));
#line 57
  temp1 = (word )__cil_tmp24;
#line 57
  __cil_tmp25 = GSM_MULT_R((word )13107, temp1);
#line 57
  temp1 = (word )__cil_tmp25;
#line 57
  __cil_tmp27 = GSM_ADD(temp1, temp1);
  }
  {
#line 57
  __cil_tmp26 = LARpp;
#line 57
  LARpp ++;
#line 57
  *__cil_tmp26 = (word )__cil_tmp27;
#line 59
  __cil_tmp28 = LARc;
#line 59
  LARc ++;
#line 59
  __cil_tmp29 = GSM_ADD(*__cil_tmp28, (word )(- 8));
#line 59
  temp1 = (word )(__cil_tmp29 << 10);
#line 59
  __cil_tmp30 = GSM_SUB(temp1, (word )(94 << 1));
#line 59
  temp1 = (word )__cil_tmp30;
#line 59
  __cil_tmp31 = GSM_MULT_R((word )19223, temp1);
#line 59
  temp1 = (word )__cil_tmp31;
#line 59
  __cil_tmp33 = GSM_ADD(temp1, temp1);
  }
  {
#line 59
  __cil_tmp32 = LARpp;
#line 59
  LARpp ++;
#line 59
  *__cil_tmp32 = (word )__cil_tmp33;
#line 60
  __cil_tmp34 = LARc;
#line 60
  LARc ++;
#line 60
  __cil_tmp35 = GSM_ADD(*__cil_tmp34, (word )(- 8));
#line 60
  temp1 = (word )(__cil_tmp35 << 10);
#line 60
  __cil_tmp36 = GSM_SUB(temp1, (word )(-1792 << 1));
#line 60
  temp1 = (word )__cil_tmp36;
#line 60
  __cil_tmp37 = GSM_MULT_R((word )17476, temp1);
#line 60
  temp1 = (word )__cil_tmp37;
#line 60
  __cil_tmp39 = GSM_ADD(temp1, temp1);
  }
  {
#line 60
  __cil_tmp38 = LARpp;
#line 60
  LARpp ++;
#line 60
  *__cil_tmp38 = (word )__cil_tmp39;
#line 61
  __cil_tmp40 = LARc;
#line 61
  LARc ++;
#line 61
  __cil_tmp41 = GSM_ADD(*__cil_tmp40, (word )(- 4));
#line 61
  temp1 = (word )(__cil_tmp41 << 10);
#line 61
  __cil_tmp42 = GSM_SUB(temp1, (word )(-341 << 1));
#line 61
  temp1 = (word )__cil_tmp42;
#line 61
  __cil_tmp43 = GSM_MULT_R((word )31454, temp1);
#line 61
  temp1 = (word )__cil_tmp43;
#line 61
  __cil_tmp45 = GSM_ADD(temp1, temp1);
  }
  {
#line 61
  __cil_tmp44 = LARpp;
#line 61
  LARpp ++;
#line 61
  *__cil_tmp44 = (word )__cil_tmp45;
#line 62
  __cil_tmp46 = LARc;
#line 62
  LARc ++;
#line 62
  __cil_tmp47 = GSM_ADD(*__cil_tmp46, (word )(- 4));
#line 62
  temp1 = (word )(__cil_tmp47 << 10);
#line 62
  __cil_tmp48 = GSM_SUB(temp1, (word )(-1144 << 1));
#line 62
  temp1 = (word )__cil_tmp48;
#line 62
  __cil_tmp49 = GSM_MULT_R((word )29708, temp1);
#line 62
  temp1 = (word )__cil_tmp49;
#line 62
  __cil_tmp51 = GSM_ADD(temp1, temp1);
  }
#line 62
  __cil_tmp50 = LARpp;
#line 62
  LARpp ++;
#line 62
  *__cil_tmp50 = (word )__cil_tmp51;
  return;
}
}
#line 85 "/root/libsndfile/src/GSM610/short_term.c"
static void Coefficients_0_12(word *LARpp_j_1 , word *LARpp_j , word *LARp ) 
{ 
  register int i ;
  word __cil_tmp5 ;
  word __cil_tmp6 ;
  longword __cil_tmp7 ;
  word __cil_tmp8 ;
  longword __cil_tmp9 ;
  int __cil_tmp10 ;
  word *__cil_tmp11 ;
  word *__cil_tmp12 ;
  word *__cil_tmp13 ;

  {
#line 92
  i = 1;
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    if (! (i <= 8)) {
#line 92
      goto while_break;
    }
    {
#line 93
    __cil_tmp5 = SASR_W(*LARpp_j_1, (word )2);
    }
    {
#line 93
    __cil_tmp6 = SASR_W(*LARpp_j, (word )2);
#line 93
    __cil_tmp7 = GSM_ADD(__cil_tmp5, __cil_tmp6);
#line 93
    *LARp = (word )__cil_tmp7;
#line 94
    __cil_tmp8 = SASR_W(*LARpp_j_1, (word )1);
#line 94
    __cil_tmp9 = GSM_ADD(*LARp, __cil_tmp8);
#line 94
    *LARp = (word )__cil_tmp9;
    }
#line 92
    __cil_tmp13 = LARpp_j;
#line 92
    LARpp_j ++;
#line 92
    __cil_tmp12 = LARpp_j_1;
#line 92
    LARpp_j_1 ++;
#line 92
    __cil_tmp11 = LARp;
#line 92
    LARp ++;
#line 92
    __cil_tmp10 = i;
#line 92
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 98 "/root/libsndfile/src/GSM610/short_term.c"
static void Coefficients_13_26(word *LARpp_j_1 , word *LARpp_j , word *LARp ) 
{ 
  register int i ;
  word __cil_tmp5 ;
  word __cil_tmp6 ;
  longword __cil_tmp7 ;
  int __cil_tmp8 ;
  word *__cil_tmp9 ;
  word *__cil_tmp10 ;
  word *__cil_tmp11 ;

  {
#line 104
  i = 1;
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 104
    if (! (i <= 8)) {
#line 104
      goto while_break;
    }
    {
#line 105
    __cil_tmp5 = SASR_W(*LARpp_j_1, (word )1);
    }
    {
#line 105
    __cil_tmp6 = SASR_W(*LARpp_j, (word )1);
#line 105
    __cil_tmp7 = GSM_ADD(__cil_tmp5, __cil_tmp6);
#line 105
    *LARp = (word )__cil_tmp7;
    }
#line 104
    __cil_tmp11 = LARp;
#line 104
    LARp ++;
#line 104
    __cil_tmp10 = LARpp_j;
#line 104
    LARpp_j ++;
#line 104
    __cil_tmp9 = LARpp_j_1;
#line 104
    LARpp_j_1 ++;
#line 104
    __cil_tmp8 = i;
#line 104
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 109 "/root/libsndfile/src/GSM610/short_term.c"
static void Coefficients_27_39(word *LARpp_j_1 , word *LARpp_j , word *LARp ) 
{ 
  register int i ;
  word __cil_tmp5 ;
  word __cil_tmp6 ;
  longword __cil_tmp7 ;
  word __cil_tmp8 ;
  longword __cil_tmp9 ;
  int __cil_tmp10 ;
  word *__cil_tmp11 ;
  word *__cil_tmp12 ;
  word *__cil_tmp13 ;

  {
#line 116
  i = 1;
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    if (! (i <= 8)) {
#line 116
      goto while_break;
    }
    {
#line 117
    __cil_tmp5 = SASR_W(*LARpp_j_1, (word )2);
    }
    {
#line 117
    __cil_tmp6 = SASR_W(*LARpp_j, (word )2);
#line 117
    __cil_tmp7 = GSM_ADD(__cil_tmp5, __cil_tmp6);
#line 117
    *LARp = (word )__cil_tmp7;
#line 118
    __cil_tmp8 = SASR_W(*LARpp_j, (word )1);
#line 118
    __cil_tmp9 = GSM_ADD(*LARp, __cil_tmp8);
#line 118
    *LARp = (word )__cil_tmp9;
    }
#line 116
    __cil_tmp13 = LARp;
#line 116
    LARp ++;
#line 116
    __cil_tmp12 = LARpp_j;
#line 116
    LARpp_j ++;
#line 116
    __cil_tmp11 = LARpp_j_1;
#line 116
    LARpp_j_1 ++;
#line 116
    __cil_tmp10 = i;
#line 116
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 123 "/root/libsndfile/src/GSM610/short_term.c"
static void Coefficients_40_159(word *LARpp_j , word *LARp ) 
{ 
  register int i ;
  int __cil_tmp4 ;
  word *__cil_tmp5 ;
  word *__cil_tmp6 ;

  {
#line 129
  i = 1;
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
#line 129
    if (! (i <= 8)) {
#line 129
      goto while_break;
    }
#line 130
    *LARp = *LARpp_j;
#line 129
    __cil_tmp6 = LARpp_j;
#line 129
    LARpp_j ++;
#line 129
    __cil_tmp5 = LARp;
#line 129
    LARp ++;
#line 129
    __cil_tmp4 = i;
#line 129
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 135 "/root/libsndfile/src/GSM610/short_term.c"
static void LARp_to_rp(word *LARp ) 
{ 
  register int i ;
  register word temp ;
  int tmp ;
  longword __cil_tmp5 ;
  int tmp___0 ;
  int tmp___1 ;
  longword __cil_tmp8 ;
  int tmp___2 ;
  int tmp___3 ;
  int __cil_tmp11 ;
  word *__cil_tmp12 ;

  {
#line 146
  i = 1;
  {
#line 146
  while (1) {
    while_continue: /* CIL Label */ ;
#line 146
    if (! (i <= 8)) {
#line 146
      goto while_break;
    }
#line 157
    if ((int )*LARp < 0) {
#line 158
      if ((int )*LARp == -32768) {
#line 158
        tmp = 32767;
      } else {
#line 158
        tmp = - ((int )*LARp);
      }
#line 158
      temp = (word )tmp;
#line 159
      if ((int )temp < 11059) {
#line 159
        tmp___1 = (int )temp << 1;
      } else {
#line 159
        if ((int )temp < 20070) {
#line 159
          tmp___0 = (int )temp + 11059;
        } else {
          {
#line 159
          __cil_tmp5 = GSM_ADD((word )((int )temp >> 2), (word )26112);
#line 159
          tmp___0 = __cil_tmp5;
          }
        }
#line 159
        tmp___1 = tmp___0;
      }
#line 159
      *LARp = (word )(- tmp___1);
    } else {
#line 163
      temp = *LARp;
#line 164
      if ((int )temp < 11059) {
#line 164
        tmp___3 = (int )temp << 1;
      } else {
#line 164
        if ((int )temp < 20070) {
#line 164
          tmp___2 = (int )temp + 11059;
        } else {
          {
#line 164
          __cil_tmp8 = GSM_ADD((word )((int )temp >> 2), (word )26112);
#line 164
          tmp___2 = __cil_tmp8;
          }
        }
#line 164
        tmp___3 = tmp___2;
      }
#line 164
      *LARp = (word )tmp___3;
    }
#line 146
    __cil_tmp12 = LARp;
#line 146
    LARp ++;
#line 146
    __cil_tmp11 = i;
#line 146
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 173 "/root/libsndfile/src/GSM610/short_term.c"
static void Short_term_analysis_filtering(struct gsm_state *S , word *rp , int k_n ,
                                          word *s ) 
{ 
  register word *u ;
  register int i ;
  register word di ;
  register word zzz ;
  register word ui ;
  register word sav ;
  register word rpi ;
  int __cil_tmp12 ;
  longword __cil_tmp13 ;
  longword __cil_tmp14 ;
  longword __cil_tmp15 ;
  longword __cil_tmp16 ;
  int __cil_tmp17 ;
  word *__cil_tmp18 ;

  {
#line 190
  u = (word *)S->u;
  {
#line 194
  while (1) {
    while_continue: /* CIL Label */ ;
#line 194
    if (! __cil_tmp12) {
#line 194
      goto while_break;
    }
#line 196
    sav = *s;
#line 196
    di = sav;
#line 198
    i = 0;
    {
#line 198
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 198
      if (! (i < 8)) {
#line 198
        goto while_break___0;
      }
      {
#line 200
      ui = *(u + i);
#line 201
      rpi = *(rp + i);
#line 202
      *(u + i) = sav;
#line 204
      __cil_tmp13 = GSM_MULT_R(rpi, di);
#line 204
      zzz = (word )__cil_tmp13;
#line 205
      __cil_tmp14 = GSM_ADD(ui, zzz);
#line 205
      sav = (word )__cil_tmp14;
#line 207
      __cil_tmp15 = GSM_MULT_R(rpi, ui);
#line 207
      zzz = (word )__cil_tmp15;
#line 208
      __cil_tmp16 = GSM_ADD(di, zzz);
#line 208
      di = (word )__cil_tmp16;
      }
#line 198
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 211
    *s = di;
#line 194
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 217 "/root/libsndfile/src/GSM610/short_term.c"
static void Fast_Short_term_analysis_filtering(struct gsm_state *S , word *rp , int k_n ,
                                               word *s ) 
{ 
  register word *u ;
  register int i ;
  float uf[8] ;
  float rpf[8] ;
  register float scalef ;
  register float sav ;
  register float di ;
  register float temp ;
  int __cil_tmp13 ;
  register float rpfi ;
  register float ufi ;
  word *__cil_tmp16 ;

  {
#line 224
  u = (word *)S->u;
#line 230
  scalef = (float )3.0517578125e-05;
#line 233
  i = 0;
  {
#line 233
  while (1) {
    while_continue: /* CIL Label */ ;
#line 233
    if (! (i < 8)) {
#line 233
      goto while_break;
    }
#line 234
    uf[i] = (float )*(u + i);
#line 235
    rpf[i] = (float )((int )*(rp + i)) * scalef;
#line 233
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 237
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 237
    if (! __cil_tmp13) {
#line 237
      goto while_break___0;
    }
#line 238
    di = (float )*s;
#line 238
    sav = di;
#line 239
    i = 0;
    {
#line 239
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 239
      if (! (i < 8)) {
#line 239
        goto while_break___1;
      }
#line 240
      rpfi = rpf[i];
#line 241
      ufi = uf[i];
#line 243
      uf[i] = sav;
#line 244
      temp = rpfi * di + ufi;
#line 245
      di += rpfi * ufi;
#line 246
      sav = temp;
#line 239
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 248
    *s = (word )di;
#line 237
    s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 250
  i = 0;
  {
#line 250
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 250
    if (! (i < 8)) {
#line 250
      goto while_break___2;
    }
#line 250
    *(u + i) = (word )uf[i];
#line 250
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  return;
}
}
#line 254 "/root/libsndfile/src/GSM610/short_term.c"
static void Short_term_synthesis_filtering(struct gsm_state *S , word *rrp , int k ,
                                           word *wt , word *sr ) 
{ 
  register word *v ;
  register int i ;
  register word sri ;
  register word tmp1 ;
  register word tmp2 ;
  int __cil_tmp11 ;
  word *__cil_tmp12 ;
  int __cil_tmp13 ;
  int tmp ;
  longword __cil_tmp15 ;
  int tmp___0 ;
  longword __cil_tmp17 ;
  word *__cil_tmp18 ;

  {
#line 262
  v = (word *)S->v;
  {
#line 266
  while (1) {
    while_continue: /* CIL Label */ ;
#line 266
    __cil_tmp11 = k;
#line 266
    k --;
#line 266
    if (! __cil_tmp11) {
#line 266
      goto while_break;
    }
#line 267
    __cil_tmp12 = wt;
#line 267
    wt ++;
#line 267
    sri = *__cil_tmp12;
#line 268
    i = 8;
    {
#line 268
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 268
      if (! __cil_tmp13) {
#line 268
        goto while_break___0;
      }
#line 272
      tmp1 = *(rrp + i);
#line 273
      tmp2 = *(v + i);
#line 274
      if ((int )tmp1 == -32768 && (int )tmp2 == -32768) {
#line 274
        tmp = 32767;
      } else {
#line 274
        tmp = 65535 & (((longword )tmp1 * (longword )tmp2 + 16384) >> 15);
      }
      {
#line 274
      tmp2 = (word )tmp;
#line 279
      __cil_tmp15 = GSM_SUB(sri, tmp2);
#line 279
      sri = (word )__cil_tmp15;
      }
#line 283
      if ((int )tmp1 == -32768 && (int )sri == -32768) {
#line 283
        tmp___0 = 32767;
      } else {
#line 283
        tmp___0 = 65535 & (((longword )tmp1 * (longword )sri + 16384) >> 15);
      }
      {
#line 283
      tmp1 = (word )tmp___0;
#line 288
      __cil_tmp17 = GSM_ADD(*(v + i), tmp1);
#line 288
      *(v + (i + 1)) = (word )__cil_tmp17;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 290
    *(v + 0) = sri;
#line 290
    __cil_tmp18 = sr;
#line 290
    sr ++;
#line 290
    *__cil_tmp18 = *(v + 0);
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 297 "/root/libsndfile/src/GSM610/short_term.c"
static void Fast_Short_term_synthesis_filtering(struct gsm_state *S , word *rrp ,
                                                int k , word *wt , word *sr ) 
{ 
  register word *v ;
  register int i ;
  float va[9] ;
  float rrpa[8] ;
  register float scalef ;
  register float temp ;
  int __cil_tmp12 ;
  register float sri ;
  word *__cil_tmp14 ;
  int __cil_tmp15 ;
  word *__cil_tmp16 ;

  {
#line 305
  v = (word *)S->v;
#line 309
  scalef = (float )3.0517578125e-05;
#line 311
  i = 0;
  {
#line 311
  while (1) {
    while_continue: /* CIL Label */ ;
#line 311
    if (! (i < 8)) {
#line 311
      goto while_break;
    }
#line 312
    va[i] = (float )*(v + i);
#line 313
    rrpa[i] = (float )*(rrp + i) * scalef;
#line 311
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 315
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 315
    __cil_tmp12 = k;
#line 315
    k --;
#line 315
    if (! __cil_tmp12) {
#line 315
      goto while_break___0;
    }
#line 316
    __cil_tmp14 = wt;
#line 316
    wt ++;
#line 316
    sri = (float )*__cil_tmp14;
#line 317
    i = 8;
    {
#line 317
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 317
      if (! __cil_tmp15) {
#line 317
        goto while_break___1;
      }
#line 318
      sri -= rrpa[i] * va[i];
#line 319
      if ((double )sri < - 32768.) {
#line 319
        sri = (float )(- 32768.);
      } else
#line 320
      if ((double )sri > 32767.) {
#line 320
        sri = (float )32767.;
      }
#line 322
      temp = va[i] + rrpa[i] * sri;
#line 323
      if ((double )temp < - 32768.) {
#line 323
        temp = (float )(- 32768.);
      } else
#line 324
      if ((double )temp > 32767.) {
#line 324
        temp = (float )32767.;
      }
#line 325
      va[i + 1] = temp;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 327
    va[0] = sri;
#line 327
    __cil_tmp16 = sr;
#line 327
    sr ++;
#line 327
    *__cil_tmp16 = (word )va[0];
  }
  while_break___0: /* CIL Label */ ;
  }
#line 329
  i = 0;
  {
#line 329
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 329
    if (! (i < 9)) {
#line 329
      goto while_break___2;
    }
#line 329
    *(v + i) = (word )va[i];
#line 329
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  return;
}
}
#line 334 "/root/libsndfile/src/GSM610/short_term.c"
void Gsm_Short_Term_Analysis_Filter(struct gsm_state *S , word *LARc , word *s ) 
{ 
  word *LARpp_j ;
  word *LARpp_j_1 ;
  word LARp[8] ;
  void (*tmp)(struct gsm_state *S , word *rp , int k_n , word *s ) ;
  void (*tmp___0)(struct gsm_state *S , word *rp , int k_n , word *s ) ;
  void (*tmp___1)(struct gsm_state *S , word *rp , int k_n , word *s ) ;
  void (*tmp___2)(struct gsm_state *S , word *rp , int k_n , word *s ) ;

  {
  {
#line 342
  LARpp_j = (word *)S->LARpp[S->j];
#line 343
  S->j ^= 1;
#line 343
  LARpp_j_1 = (word *)S->LARpp[S->j];
#line 357
  Decoding_of_the_coded_Log_Area_Ratios(LARc, LARpp_j);
#line 359
  Coefficients_0_12(LARpp_j_1, LARpp_j, (word *)LARp);
#line 360
  LARp_to_rp((word *)LARp);
  }
#line 361
  if ((int )S->fast) {
#line 361
    tmp = & Fast_Short_term_analysis_filtering;
  } else {
#line 361
    tmp = & Short_term_analysis_filtering;
  }
  {
#line 361
  (*tmp)(S, (word *)LARp, 13, s);
#line 363
  Coefficients_13_26(LARpp_j_1, LARpp_j, (word *)LARp);
#line 364
  LARp_to_rp((word *)LARp);
  }
#line 365
  if ((int )S->fast) {
#line 365
    tmp___0 = & Fast_Short_term_analysis_filtering;
  } else {
#line 365
    tmp___0 = & Short_term_analysis_filtering;
  }
  {
#line 365
  (*tmp___0)(S, (word *)LARp, 14, s + 13);
#line 367
  Coefficients_27_39(LARpp_j_1, LARpp_j, (word *)LARp);
#line 368
  LARp_to_rp((word *)LARp);
  }
#line 369
  if ((int )S->fast) {
#line 369
    tmp___1 = & Fast_Short_term_analysis_filtering;
  } else {
#line 369
    tmp___1 = & Short_term_analysis_filtering;
  }
  {
#line 369
  (*tmp___1)(S, (word *)LARp, 13, s + 27);
#line 371
  Coefficients_40_159(LARpp_j, (word *)LARp);
#line 372
  LARp_to_rp((word *)LARp);
  }
#line 373
  if ((int )S->fast) {
#line 373
    tmp___2 = & Fast_Short_term_analysis_filtering;
  } else {
#line 373
    tmp___2 = & Short_term_analysis_filtering;
  }
  {
#line 373
  (*tmp___2)(S, (word *)LARp, 120, s + 40);
  }
  return;
}
}
#line 376 "/root/libsndfile/src/GSM610/short_term.c"
void Gsm_Short_Term_Synthesis_Filter(struct gsm_state *S , word *LARcr , word *wt ,
                                     word *s ) 
{ 
  word *LARpp_j ;
  word *LARpp_j_1 ;
  word LARp[8] ;
  void (*tmp)(struct gsm_state *S , word *rrp , int k , word *wt , word *sr ) ;
  void (*tmp___0)(struct gsm_state *S , word *rrp , int k , word *wt , word *sr ) ;
  void (*tmp___1)(struct gsm_state *S , word *rrp , int k , word *wt , word *sr ) ;
  void (*tmp___2)(struct gsm_state *S , word *rrp , int k , word *wt , word *sr ) ;

  {
  {
#line 385
  LARpp_j = (word *)S->LARpp[S->j];
#line 386
  S->j ^= 1;
#line 386
  LARpp_j_1 = (word *)S->LARpp[S->j];
#line 400
  Decoding_of_the_coded_Log_Area_Ratios(LARcr, LARpp_j);
#line 402
  Coefficients_0_12(LARpp_j_1, LARpp_j, (word *)LARp);
#line 403
  LARp_to_rp((word *)LARp);
  }
#line 404
  if ((int )S->fast) {
#line 404
    tmp = & Fast_Short_term_synthesis_filtering;
  } else {
#line 404
    tmp = & Short_term_synthesis_filtering;
  }
  {
#line 404
  (*tmp)(S, (word *)LARp, 13, wt, s);
#line 406
  Coefficients_13_26(LARpp_j_1, LARpp_j, (word *)LARp);
#line 407
  LARp_to_rp((word *)LARp);
  }
#line 408
  if ((int )S->fast) {
#line 408
    tmp___0 = & Fast_Short_term_synthesis_filtering;
  } else {
#line 408
    tmp___0 = & Short_term_synthesis_filtering;
  }
  {
#line 408
  (*tmp___0)(S, (word *)LARp, 14, wt + 13, s + 13);
#line 410
  Coefficients_27_39(LARpp_j_1, LARpp_j, (word *)LARp);
#line 411
  LARp_to_rp((word *)LARp);
  }
#line 412
  if ((int )S->fast) {
#line 412
    tmp___1 = & Fast_Short_term_synthesis_filtering;
  } else {
#line 412
    tmp___1 = & Short_term_synthesis_filtering;
  }
  {
#line 412
  (*tmp___1)(S, (word *)LARp, 13, wt + 27, s + 27);
#line 414
  Coefficients_40_159(LARpp_j, (word *)LARp);
#line 415
  LARp_to_rp((word *)LARp);
  }
#line 416
  if ((int )S->fast) {
#line 416
    tmp___2 = & Fast_Short_term_synthesis_filtering;
  } else {
#line 416
    tmp___2 = & Short_term_synthesis_filtering;
  }
  {
#line 416
  (*tmp___2)(S, (word *)LARp, 120, wt + 40, s + 40);
  }
  return;
}
}
#line 17 "/root/libsndfile/src/GSM610/rpe.c"
static void Weighting_filter(word *e , word *x ) 
{ 
  register longword L_result ;
  register int k ;
  longword __cil_tmp5 ;
  int tmp ;
  int tmp___0 ;
  int __cil_tmp8 ;

  {
#line 43
  e -= 5;
#line 47
  k = 0;
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
#line 47
    if (! (k <= 39)) {
#line 47
      goto while_break;
    }
    {
#line 49
    L_result = 8192 >> 1;
#line 78
    L_result += ((((((((int )*(e + k) * -134 + (int )*(e + (k + 1)) * -374) + (int )*(e + (k + 3)) * 2054) + (int )*(e + (k + 4)) * 5741) + (int )*(e + (k + 5)) * 8192) + (int )*(e + (k + 6)) * 5741) + (int )*(e + (k + 7)) * 2054) + (int )*(e + (k + 9)) * -374) + (int )*(e + (k + 10)) * -134;
#line 103
    L_result = SASR_L(L_result, (word )13);
    }
#line 104
    if (L_result < -32768) {
#line 104
      tmp___0 = -32768;
    } else {
#line 104
      if (L_result > 32767) {
#line 104
        tmp = 32767;
      } else {
#line 104
        tmp = L_result;
      }
#line 104
      tmp___0 = tmp;
    }
#line 104
    *(x + k) = (word )tmp___0;
#line 47
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 111 "/root/libsndfile/src/GSM610/rpe.c"
static void RPE_grid_selection(word *x , word *xM , word *Mc_out ) 
{ 
  register int i ;
  register longword L_result ;
  register longword L_temp ;
  longword EM ;
  word Mc ;
  longword L_common_0_3 ;
  word __cil_tmp10 ;
  word __cil_tmp11 ;
  word __cil_tmp12 ;
  word __cil_tmp13 ;
  word __cil_tmp14 ;
  word __cil_tmp15 ;
  word __cil_tmp16 ;
  word __cil_tmp17 ;
  word __cil_tmp18 ;
  word __cil_tmp19 ;
  word __cil_tmp20 ;
  word __cil_tmp21 ;
  word __cil_tmp22 ;
  word __cil_tmp23 ;
  word __cil_tmp24 ;
  word __cil_tmp25 ;
  word __cil_tmp26 ;
  word __cil_tmp27 ;
  word __cil_tmp28 ;
  word __cil_tmp29 ;
  word __cil_tmp30 ;
  word __cil_tmp31 ;
  word __cil_tmp32 ;
  word __cil_tmp33 ;
  word __cil_tmp34 ;
  word __cil_tmp35 ;
  word __cil_tmp36 ;
  word __cil_tmp37 ;
  word __cil_tmp38 ;
  word __cil_tmp39 ;
  word __cil_tmp40 ;
  word __cil_tmp41 ;
  word __cil_tmp42 ;
  word __cil_tmp43 ;
  word __cil_tmp44 ;
  word __cil_tmp45 ;
  word __cil_tmp46 ;
  word __cil_tmp47 ;
  word __cil_tmp48 ;
  word __cil_tmp49 ;
  int __cil_tmp50 ;

  {
  {
#line 129
  EM = 0;
#line 130
  Mc = (word )0;
#line 159
  L_result = 0;
#line 160
  __cil_tmp10 = SASR_W(*(x + 3), (word )2);
#line 160
  L_temp = (longword )__cil_tmp10;
#line 160
  L_result += L_temp * L_temp;
#line 160
  __cil_tmp11 = SASR_W(*(x + 6), (word )2);
#line 160
  L_temp = (longword )__cil_tmp11;
#line 160
  L_result += L_temp * L_temp;
#line 160
  __cil_tmp12 = SASR_W(*(x + 9), (word )2);
#line 160
  L_temp = (longword )__cil_tmp12;
#line 160
  L_result += L_temp * L_temp;
#line 160
  __cil_tmp13 = SASR_W(*(x + 12), (word )2);
#line 160
  L_temp = (longword )__cil_tmp13;
#line 160
  L_result += L_temp * L_temp;
#line 161
  __cil_tmp14 = SASR_W(*(x + 15), (word )2);
#line 161
  L_temp = (longword )__cil_tmp14;
#line 161
  L_result += L_temp * L_temp;
#line 161
  __cil_tmp15 = SASR_W(*(x + 18), (word )2);
#line 161
  L_temp = (longword )__cil_tmp15;
#line 161
  L_result += L_temp * L_temp;
#line 161
  __cil_tmp16 = SASR_W(*(x + 21), (word )2);
#line 161
  L_temp = (longword )__cil_tmp16;
#line 161
  L_result += L_temp * L_temp;
#line 161
  __cil_tmp17 = SASR_W(*(x + 24), (word )2);
#line 161
  L_temp = (longword )__cil_tmp17;
#line 161
  L_result += L_temp * L_temp;
#line 162
  __cil_tmp18 = SASR_W(*(x + 27), (word )2);
#line 162
  L_temp = (longword )__cil_tmp18;
#line 162
  L_result += L_temp * L_temp;
#line 162
  __cil_tmp19 = SASR_W(*(x + 30), (word )2);
#line 162
  L_temp = (longword )__cil_tmp19;
#line 162
  L_result += L_temp * L_temp;
#line 162
  __cil_tmp20 = SASR_W(*(x + 33), (word )2);
#line 162
  L_temp = (longword )__cil_tmp20;
#line 162
  L_result += L_temp * L_temp;
#line 162
  __cil_tmp21 = SASR_W(*(x + 36), (word )2);
#line 162
  L_temp = (longword )__cil_tmp21;
#line 162
  L_result += L_temp * L_temp;
#line 163
  L_common_0_3 = L_result;
#line 167
  __cil_tmp22 = SASR_W(*(x + 0), (word )2);
#line 167
  L_temp = (longword )__cil_tmp22;
#line 167
  L_result += L_temp * L_temp;
#line 168
  L_result <<= 1;
#line 169
  EM = L_result;
#line 173
  L_result = 0;
#line 174
  __cil_tmp23 = SASR_W(*(x + 1), (word )2);
#line 174
  L_temp = (longword )__cil_tmp23;
#line 174
  L_result += L_temp * L_temp;
#line 175
  __cil_tmp24 = SASR_W(*(x + 4), (word )2);
#line 175
  L_temp = (longword )__cil_tmp24;
#line 175
  L_result += L_temp * L_temp;
#line 175
  __cil_tmp25 = SASR_W(*(x + 7), (word )2);
#line 175
  L_temp = (longword )__cil_tmp25;
#line 175
  L_result += L_temp * L_temp;
#line 175
  __cil_tmp26 = SASR_W(*(x + 10), (word )2);
#line 175
  L_temp = (longword )__cil_tmp26;
#line 175
  L_result += L_temp * L_temp;
#line 175
  __cil_tmp27 = SASR_W(*(x + 13), (word )2);
#line 175
  L_temp = (longword )__cil_tmp27;
#line 175
  L_result += L_temp * L_temp;
#line 176
  __cil_tmp28 = SASR_W(*(x + 16), (word )2);
#line 176
  L_temp = (longword )__cil_tmp28;
#line 176
  L_result += L_temp * L_temp;
#line 176
  __cil_tmp29 = SASR_W(*(x + 19), (word )2);
#line 176
  L_temp = (longword )__cil_tmp29;
#line 176
  L_result += L_temp * L_temp;
#line 176
  __cil_tmp30 = SASR_W(*(x + 22), (word )2);
#line 176
  L_temp = (longword )__cil_tmp30;
#line 176
  L_result += L_temp * L_temp;
#line 176
  __cil_tmp31 = SASR_W(*(x + 25), (word )2);
#line 176
  L_temp = (longword )__cil_tmp31;
#line 176
  L_result += L_temp * L_temp;
#line 177
  __cil_tmp32 = SASR_W(*(x + 28), (word )2);
#line 177
  L_temp = (longword )__cil_tmp32;
#line 177
  L_result += L_temp * L_temp;
#line 177
  __cil_tmp33 = SASR_W(*(x + 31), (word )2);
#line 177
  L_temp = (longword )__cil_tmp33;
#line 177
  L_result += L_temp * L_temp;
#line 177
  __cil_tmp34 = SASR_W(*(x + 34), (word )2);
#line 177
  L_temp = (longword )__cil_tmp34;
#line 177
  L_result += L_temp * L_temp;
#line 177
  __cil_tmp35 = SASR_W(*(x + 37), (word )2);
#line 177
  L_temp = (longword )__cil_tmp35;
#line 177
  L_result += L_temp * L_temp;
#line 178
  L_result <<= 1;
  }
#line 179
  if (L_result > EM) {
#line 180
    Mc = (word )1;
#line 181
    EM = L_result;
  }
  {
#line 186
  L_result = 0;
#line 187
  __cil_tmp36 = SASR_W(*(x + 2), (word )2);
#line 187
  L_temp = (longword )__cil_tmp36;
#line 187
  L_result += L_temp * L_temp;
#line 188
  __cil_tmp37 = SASR_W(*(x + 5), (word )2);
#line 188
  L_temp = (longword )__cil_tmp37;
#line 188
  L_result += L_temp * L_temp;
#line 188
  __cil_tmp38 = SASR_W(*(x + 8), (word )2);
#line 188
  L_temp = (longword )__cil_tmp38;
#line 188
  L_result += L_temp * L_temp;
#line 188
  __cil_tmp39 = SASR_W(*(x + 11), (word )2);
#line 188
  L_temp = (longword )__cil_tmp39;
#line 188
  L_result += L_temp * L_temp;
#line 188
  __cil_tmp40 = SASR_W(*(x + 14), (word )2);
#line 188
  L_temp = (longword )__cil_tmp40;
#line 188
  L_result += L_temp * L_temp;
#line 189
  __cil_tmp41 = SASR_W(*(x + 17), (word )2);
#line 189
  L_temp = (longword )__cil_tmp41;
#line 189
  L_result += L_temp * L_temp;
#line 189
  __cil_tmp42 = SASR_W(*(x + 20), (word )2);
#line 189
  L_temp = (longword )__cil_tmp42;
#line 189
  L_result += L_temp * L_temp;
#line 189
  __cil_tmp43 = SASR_W(*(x + 23), (word )2);
#line 189
  L_temp = (longword )__cil_tmp43;
#line 189
  L_result += L_temp * L_temp;
#line 189
  __cil_tmp44 = SASR_W(*(x + 26), (word )2);
#line 189
  L_temp = (longword )__cil_tmp44;
#line 189
  L_result += L_temp * L_temp;
#line 190
  __cil_tmp45 = SASR_W(*(x + 29), (word )2);
#line 190
  L_temp = (longword )__cil_tmp45;
#line 190
  L_result += L_temp * L_temp;
#line 190
  __cil_tmp46 = SASR_W(*(x + 32), (word )2);
#line 190
  L_temp = (longword )__cil_tmp46;
#line 190
  L_result += L_temp * L_temp;
#line 190
  __cil_tmp47 = SASR_W(*(x + 35), (word )2);
#line 190
  L_temp = (longword )__cil_tmp47;
#line 190
  L_result += L_temp * L_temp;
#line 190
  __cil_tmp48 = SASR_W(*(x + 38), (word )2);
#line 190
  L_temp = (longword )__cil_tmp48;
#line 190
  L_result += L_temp * L_temp;
#line 191
  L_result <<= 1;
  }
#line 192
  if (L_result > EM) {
#line 193
    Mc = (word )2;
#line 194
    EM = L_result;
  }
  {
#line 199
  L_result = L_common_0_3;
#line 200
  __cil_tmp49 = SASR_W(*(x + 39), (word )2);
#line 200
  L_temp = (longword )__cil_tmp49;
#line 200
  L_result += L_temp * L_temp;
#line 201
  L_result <<= 1;
  }
#line 202
  if (L_result > EM) {
#line 203
    Mc = (word )3;
#line 204
    EM = L_result;
  }
#line 212
  i = 0;
  {
#line 212
  while (1) {
    while_continue: /* CIL Label */ ;
#line 212
    if (! (i <= 12)) {
#line 212
      goto while_break;
    }
#line 212
    *(xM + i) = *(x + ((int )Mc + 3 * i));
#line 212
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 213
  *Mc_out = Mc;
  return;
}
}
#line 218 "/root/libsndfile/src/GSM610/rpe.c"
static void APCM_quantization_xmaxc_to_exp_mant(word xmaxc , word *expon_out , word *mant_out ) 
{ 
  word expon ;
  word mant ;
  word __cil_tmp6 ;
  word __cil_tmp7 ;
  int tmp ;
  int tmp___0 ;

  {
#line 228
  expon = (word )0;
#line 229
  if ((int )xmaxc > 15) {
    {
#line 229
    __cil_tmp6 = SASR_W(xmaxc, (word )3);
#line 229
    expon = (word )((int )__cil_tmp6 - 1);
    }
  }
#line 230
  mant = (word )((int )xmaxc - ((int )expon << 3));
#line 232
  if ((int )mant == 0) {
#line 233
    expon = (word )(- 4);
#line 234
    mant = (word )7;
  } else {
    {
#line 237
    while (1) {
      while_continue: /* CIL Label */ ;
#line 237
      if (! ((int )mant <= 7)) {
#line 237
        goto while_break;
      }
#line 238
      mant = (word )(((int )mant << 1) | 1);
#line 239
      __cil_tmp7 = expon;
#line 239
      expon --;
    }
    while_break: /* CIL Label */ ;
    }
#line 241
    mant -= 8;
  }
#line 247
  *expon_out = expon;
#line 248
  *mant_out = mant;
  return;
}
}
#line 251 "/root/libsndfile/src/GSM610/rpe.c"
static void APCM_quantization(word *xM , word *xMc , word *mant_out , word *expon_out ,
                              word *xmaxc_out ) 
{ 
  int i ;
  int itest ;
  word xmax ;
  word xmaxc ;
  word temp ;
  word temp1 ;
  word temp2 ;
  word expon ;
  word mant ;
  word __cil_tmp15 ;
  int __cil_tmp16 ;
  word __cil_tmp17 ;
  word __cil_tmp18 ;
  int tmp ;
  word __cil_tmp20 ;
  int __cil_tmp21 ;
  int tmp___0 ;
  int tmp___1 ;
  word __cil_tmp24 ;
  word __cil_tmp25 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  longword __cil_tmp29 ;
  word __cil_tmp30 ;
  int __cil_tmp31 ;

  {
#line 268
  xmax = (word )0;
#line 269
  i = 0;
  {
#line 269
  while (1) {
    while_continue: /* CIL Label */ ;
#line 269
    if (! (i <= 12)) {
#line 269
      goto while_break;
    }
    {
#line 270
    temp = *(xM + i);
#line 271
    temp = GSM_ABS(temp);
    }
#line 272
    if ((int )temp > (int )xmax) {
#line 272
      xmax = temp;
    }
#line 269
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 278
  expon = (word )0;
#line 279
  temp = SASR_W(xmax, (word )9);
#line 280
  itest = 0;
#line 282
  i = 0;
  }
  {
#line 282
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 282
    if (! (i <= 5)) {
#line 282
      goto while_break___0;
    }
    {
#line 284
    itest |= (int )temp <= 0;
#line 285
    temp = SASR_W(temp, (word )1);
    }
#line 288
    if (itest == 0) {
#line 288
      expon ++;
    }
#line 282
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 292
  temp = (word )((int )expon + 5);
#line 295
  __cil_tmp24 = SASR_W(xmax, temp);
#line 295
  __cil_tmp25 = gsm_add(__cil_tmp24, (word )((int )expon << 3));
#line 295
  xmaxc = __cil_tmp25;
#line 301
  APCM_quantization_xmaxc_to_exp_mant(xmaxc, & expon, & mant);
#line 320
  temp1 = (word )(6 - (int )expon);
#line 321
  temp2 = gsm_NRFAC[mant];
#line 323
  i = 0;
  }
  {
#line 323
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 323
    if (! (i <= 12)) {
#line 323
      goto while_break___1;
    }
    {
#line 327
    temp = (word )((int )*(xM + i) << (int )temp1);
#line 328
    __cil_tmp29 = GSM_MULT(temp, temp2);
#line 328
    temp = (word )__cil_tmp29;
#line 329
    temp = SASR_W(temp, (word )12);
#line 330
    *(xMc + i) = (word )((int )temp + 4);
    }
#line 323
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 336
  *mant_out = mant;
#line 337
  *expon_out = expon;
#line 338
  *xmaxc_out = xmaxc;
  return;
}
}
#line 343 "/root/libsndfile/src/GSM610/rpe.c"
static void APCM_inverse_quantization(word *xMc , word mant , word expon , word *xMp ) 
{ 
  int i ;
  word temp ;
  word temp1 ;
  word temp2 ;
  word temp3 ;
  int tmp ;
  word __cil_tmp11 ;
  word __cil_tmp12 ;
  word __cil_tmp13 ;
  int __cil_tmp14 ;
  int tmp___0 ;
  word *__cil_tmp16 ;
  int tmp___1 ;
  longword __cil_tmp18 ;
  longword __cil_tmp19 ;
  word *__cil_tmp20 ;
  word __cil_tmp21 ;

  {
  {
#line 359
  temp1 = gsm_FAC[mant];
#line 360
  temp2 = gsm_sub((word )6, expon);
#line 361
  __cil_tmp12 = gsm_sub(temp2, (word )1);
#line 361
  __cil_tmp13 = gsm_asl((word )1, (int )__cil_tmp12);
#line 361
  temp3 = __cil_tmp13;
#line 363
  i = 13;
  }
  {
#line 363
  while (1) {
    while_continue: /* CIL Label */ ;
#line 363
    if (! __cil_tmp14) {
#line 363
      goto while_break;
    }
    {
#line 368
    __cil_tmp16 = xMc;
#line 368
    xMc ++;
#line 368
    temp = (word )(((int )*__cil_tmp16 << 1) - 7);
#line 371
    temp <<= 12;
#line 372
    __cil_tmp18 = GSM_MULT_R(temp1, temp);
#line 372
    temp = (word )__cil_tmp18;
#line 373
    __cil_tmp19 = GSM_ADD(temp, temp3);
#line 373
    temp = (word )__cil_tmp19;
#line 374
    __cil_tmp20 = xMp;
#line 374
    xMp ++;
#line 374
    *__cil_tmp20 = gsm_asr(temp, (int )temp2);
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 380 "/root/libsndfile/src/GSM610/rpe.c"
static void RPE_grid_positioning(word Mc , word *xMp , word *ep ) 
{ 
  int i ;
  int tmp ;
  word *__cil_tmp6 ;
  word *__cil_tmp7 ;
  word *__cil_tmp8 ;
  word *__cil_tmp9 ;
  word *__cil_tmp10 ;
  word *__cil_tmp11 ;

  {
#line 393
  i = 13;
  {
#line 398
  if ((int )Mc == 3) {
#line 398
    goto case_3;
  }
#line 399
  if ((int )Mc == 2) {
#line 399
    goto case_2;
  }
#line 401
  if ((int )Mc == 1) {
#line 401
    goto case_1;
  }
#line 402
  if ((int )Mc == 0) {
#line 402
    goto case_0;
  }
#line 397
  goto switch_break;
  case_3: /* CIL Label */ 
#line 398
  __cil_tmp6 = ep;
#line 398
  ep ++;
#line 398
  *__cil_tmp6 = (word )0;
  case_2: /* CIL Label */ 
  {
#line 399
  while (1) {
    while_continue: /* CIL Label */ ;
#line 400
    __cil_tmp7 = ep;
#line 400
    ep ++;
#line 400
    *__cil_tmp7 = (word )0;
    case_1: /* CIL Label */ 
#line 401
    __cil_tmp8 = ep;
#line 401
    ep ++;
#line 401
    *__cil_tmp8 = (word )0;
    case_0: /* CIL Label */ 
#line 402
    __cil_tmp10 = xMp;
#line 402
    xMp ++;
#line 402
    __cil_tmp9 = ep;
#line 402
    ep ++;
#line 402
    *__cil_tmp9 = *__cil_tmp10;
#line 399
    if (! i) {
#line 399
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 405
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 405
    Mc ++;
#line 405
    if (! ((int )Mc < 4)) {
#line 405
      goto while_break___0;
    }
#line 405
    __cil_tmp11 = ep;
#line 405
    ep ++;
#line 405
    *__cil_tmp11 = (word )0;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 442 "/root/libsndfile/src/GSM610/rpe.c"
void Gsm_RPE_Encoding(word *e , word *xmaxc , word *Mc , word *xMc ) 
{ 
  word x[40] ;
  word xM[13] ;
  word xMp[13] ;
  word mant ;
  word expon ;

  {
  {
#line 454
  Weighting_filter(e, (word *)x);
#line 455
  RPE_grid_selection((word *)x, (word *)xM, Mc);
#line 457
  APCM_quantization((word *)xM, xMc, & mant, & expon, xmaxc);
#line 458
  APCM_inverse_quantization(xMc, mant, expon, (word *)xMp);
#line 460
  RPE_grid_positioning(*Mc, (word *)xMp, e);
  }
  return;
}
}
#line 464 "/root/libsndfile/src/GSM610/rpe.c"
void Gsm_RPE_Decoding(word xmaxcr , word Mcr , word *xMcr , word *erp ) 
{ 
  word expon ;
  word mant ;
  word xMp[13] ;

  {
  {
#line 476
  APCM_quantization_xmaxc_to_exp_mant(xmaxcr, & expon, & mant);
#line 477
  APCM_inverse_quantization(xMcr, mant, expon, (word *)xMp);
#line 478
  RPE_grid_positioning(Mcr, (word *)xMp, erp);
  }
  return;
}
}
#line 29 "/root/libsndfile/src/GSM610/preprocess.c"
void Gsm_Preprocess(struct gsm_state *S , word *s , word *so ) 
{ 
  word z1 ;
  longword L_z2 ;
  word mp ;
  word s1 ;
  longword L_s2 ;
  longword L_temp ;
  word msp ;
  word lsp ;
  word SO ;
  register int k ;
  int __cil_tmp14 ;
  word __cil_tmp15 ;
  word *__cil_tmp16 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  longword __cil_tmp20 ;
  longword __cil_tmp21 ;
  longword __cil_tmp22 ;
  longword __cil_tmp23 ;
  longword __cil_tmp24 ;
  longword __cil_tmp25 ;
  word *__cil_tmp26 ;
  longword __cil_tmp27 ;

  {
#line 35
  z1 = S->z1;
#line 36
  L_z2 = S->L_z2;
#line 37
  mp = (word )S->mp;
#line 47
  k = 160;
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
#line 49
    __cil_tmp14 = k;
#line 49
    k --;
#line 49
    if (! __cil_tmp14) {
#line 49
      goto while_break;
    }
    {
#line 53
    __cil_tmp15 = SASR_W(*s, (word )3);
#line 53
    SO = (word )((int )__cil_tmp15 << 2);
#line 54
    s ++;
#line 70
    s1 = (word )((int )SO - (int )z1);
#line 71
    z1 = SO;
#line 77
    L_s2 = (longword )s1;
#line 78
    L_s2 <<= 15;
#line 83
    __cil_tmp20 = SASR_L(L_z2, (word )15);
#line 83
    msp = (word )__cil_tmp20;
#line 84
    lsp = (word )(L_z2 - ((longword )msp << 15));
#line 86
    __cil_tmp21 = GSM_MULT_R(lsp, (word )32735);
    }
    {
#line 86
    L_s2 += __cil_tmp21;
#line 87
    L_temp = (longword )msp * 32735;
#line 88
    L_z2 = GSM_L_ADD(L_temp, L_s2);
#line 92
    L_temp = GSM_L_ADD(L_z2, 16384);
#line 97
    __cil_tmp24 = GSM_MULT_R(mp, (word )(- 28180));
#line 97
    msp = (word )__cil_tmp24;
#line 98
    __cil_tmp25 = SASR_L(L_temp, (word )15);
#line 98
    mp = (word )__cil_tmp25;
#line 99
    __cil_tmp27 = GSM_ADD(mp, msp);
    }
#line 99
    __cil_tmp26 = so;
#line 99
    so ++;
#line 99
    *__cil_tmp26 = (word )__cil_tmp27;
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  S->z1 = z1;
#line 103
  S->L_z2 = L_z2;
#line 104
  S->mp = (int )mp;
  return;
}
}
#line 19 "/root/libsndfile/src/GSM610/lpc.c"
static void Autocorrelation(word *s , longword *L_ACF ) 
{ 
  register int k ;
  register int i ;
  word temp ;
  word smax ;
  word scalauto ;
  float float_s[160] ;
  word __cil_tmp9 ;
  int __cil_tmp10 ;
  int tmp ;
  word __cil_tmp12 ;
  longword __cil_tmp13 ;
  int __cil_tmp14 ;
  longword __cil_tmp15 ;
  int __cil_tmp16 ;
  longword __cil_tmp17 ;
  int __cil_tmp18 ;
  longword __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  register float *sp ;
  register float sl ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int tmp___0 ;
  int __cil_tmp28 ;
  word *__cil_tmp29 ;

  {
#line 40
  smax = (word )0;
#line 41
  k = 0;
  {
#line 41
  while (1) {
    while_continue: /* CIL Label */ ;
#line 41
    if (! (k <= 159)) {
#line 41
      goto while_break;
    }
    {
#line 42
    temp = GSM_ABS(*(s + k));
    }
#line 43
    if ((int )temp > (int )smax) {
#line 43
      smax = temp;
    }
#line 41
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 48
  if ((int )smax == 0) {
#line 48
    scalauto = (word )0;
  } else {
    {
#line 51
    __cil_tmp12 = gsm_norm((longword )smax << 16);
#line 51
    scalauto = (word )(4 - (int )__cil_tmp12);
    }
  }
#line 57
  if ((int )scalauto > 0) {
    {
#line 73
    if ((int )scalauto == 1) {
#line 73
      goto case_1;
    }
#line 74
    if ((int )scalauto == 2) {
#line 74
      goto case_2;
    }
#line 75
    if ((int )scalauto == 3) {
#line 75
      goto case_3;
    }
#line 76
    if ((int )scalauto == 4) {
#line 76
      goto case_4;
    }
#line 72
    goto switch_break;
    case_1: /* CIL Label */ 
#line 73
    k = 0;
    {
#line 73
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 73
      if (! (k <= 159)) {
#line 73
        goto while_break___0;
      }
      {
#line 73
      __cil_tmp13 = GSM_MULT_R(*(s + k), (word )16384);
#line 73
      *(s + k) = (word )__cil_tmp13;
#line 73
      float_s[k] = (float )*(s + k);
      }
#line 73
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 73
    goto switch_break;
    case_2: /* CIL Label */ 
#line 74
    k = 0;
    {
#line 74
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 74
      if (! (k <= 159)) {
#line 74
        goto while_break___1;
      }
      {
#line 74
      __cil_tmp15 = GSM_MULT_R(*(s + k), (word )(16384 >> 1));
#line 74
      *(s + k) = (word )__cil_tmp15;
#line 74
      float_s[k] = (float )*(s + k);
      }
#line 74
      k ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 74
    goto switch_break;
    case_3: /* CIL Label */ 
#line 75
    k = 0;
    {
#line 75
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 75
      if (! (k <= 159)) {
#line 75
        goto while_break___2;
      }
      {
#line 75
      __cil_tmp17 = GSM_MULT_R(*(s + k), (word )(16384 >> 2));
#line 75
      *(s + k) = (word )__cil_tmp17;
#line 75
      float_s[k] = (float )*(s + k);
      }
#line 75
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 75
    goto switch_break;
    case_4: /* CIL Label */ 
#line 76
    k = 0;
    {
#line 76
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 76
      if (! (k <= 159)) {
#line 76
        goto while_break___3;
      }
      {
#line 76
      __cil_tmp19 = GSM_MULT_R(*(s + k), (word )(16384 >> 3));
#line 76
      *(s + k) = (word )__cil_tmp19;
#line 76
      float_s[k] = (float )*(s + k);
      }
#line 76
      k ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 76
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else {
#line 81
    k = 0;
    {
#line 81
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 81
      if (! (k <= 159)) {
#line 81
        goto while_break___4;
      }
#line 81
      float_s[k] = (float )*(s + k);
#line 81
      k ++;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 88
  sp = (float *)float_s;
#line 89
  sl = *sp;
#line 102
  k = 9;
  {
#line 102
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 102
    if (! __cil_tmp24) {
#line 102
      goto while_break___5;
    }

#line 102
    *(L_ACF + k) = 0;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 104
  *(L_ACF + 0) += (longword )(sl * *(sp + 0));
#line 105
  sp ++;
#line 105
  sl = *sp;
#line 106
  *(L_ACF + 0) += (longword )(sl * *(sp + 0));
#line 106
  *(L_ACF + 1) += (longword )(sl * *(sp + -1));
#line 107
  sp ++;
#line 107
  sl = *sp;
#line 108
  *(L_ACF + 0) += (longword )(sl * *(sp + 0));
#line 108
  *(L_ACF + 1) += (longword )(sl * *(sp + -1));
#line 108
  *(L_ACF + 2) += (longword )(sl * *(sp + -2));
#line 109
  sp ++;
#line 109
  sl = *sp;
#line 110
  *(L_ACF + 0) += (longword )(sl * *(sp + 0));
#line 110
  *(L_ACF + 1) += (longword )(sl * *(sp + -1));
#line 110
  *(L_ACF + 2) += (longword )(sl * *(sp + -2));
#line 110
  *(L_ACF + 3) += (longword )(sl * *(sp + -3));
#line 111
  sp ++;
#line 111
  sl = *sp;
#line 112
  *(L_ACF + 0) += (longword )(sl * *(sp + 0));
#line 112
  *(L_ACF + 1) += (longword )(sl * *(sp + -1));
#line 112
  *(L_ACF + 2) += (longword )(sl * *(sp + -2));
#line 112
  *(L_ACF + 3) += (longword )(sl * *(sp + -3));
#line 112
  *(L_ACF + 4) += (longword )(sl * *(sp + -4));
#line 113
  sp ++;
#line 113
  sl = *sp;
#line 114
  *(L_ACF + 0) += (longword )(sl * *(sp + 0));
#line 114
  *(L_ACF + 1) += (longword )(sl * *(sp + -1));
#line 114
  *(L_ACF + 2) += (longword )(sl * *(sp + -2));
#line 114
  *(L_ACF + 3) += (longword )(sl * *(sp + -3));
#line 114
  *(L_ACF + 4) += (longword )(sl * *(sp + -4));
#line 114
  *(L_ACF + 5) += (longword )(sl * *(sp + -5));
#line 115
  sp ++;
#line 115
  sl = *sp;
#line 116
  *(L_ACF + 0) += (longword )(sl * *(sp + 0));
#line 116
  *(L_ACF + 1) += (longword )(sl * *(sp + -1));
#line 116
  *(L_ACF + 2) += (longword )(sl * *(sp + -2));
#line 116
  *(L_ACF + 3) += (longword )(sl * *(sp + -3));
#line 116
  *(L_ACF + 4) += (longword )(sl * *(sp + -4));
#line 116
  *(L_ACF + 5) += (longword )(sl * *(sp + -5));
#line 116
  *(L_ACF + 6) += (longword )(sl * *(sp + -6));
#line 117
  sp ++;
#line 117
  sl = *sp;
#line 118
  *(L_ACF + 0) += (longword )(sl * *(sp + 0));
#line 118
  *(L_ACF + 1) += (longword )(sl * *(sp + -1));
#line 118
  *(L_ACF + 2) += (longword )(sl * *(sp + -2));
#line 118
  *(L_ACF + 3) += (longword )(sl * *(sp + -3));
#line 118
  *(L_ACF + 4) += (longword )(sl * *(sp + -4));
#line 118
  *(L_ACF + 5) += (longword )(sl * *(sp + -5));
#line 118
  *(L_ACF + 6) += (longword )(sl * *(sp + -6));
#line 118
  *(L_ACF + 7) += (longword )(sl * *(sp + -7));
#line 120
  i = 8;
  {
#line 120
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 120
    if (! (i <= 159)) {
#line 120
      goto while_break___6;
    }
#line 122
    sp ++;
#line 122
    sl = *sp;
#line 124
    *(L_ACF + 0) += (longword )(sl * *(sp + 0));
#line 125
    *(L_ACF + 1) += (longword )(sl * *(sp + -1));
#line 125
    *(L_ACF + 2) += (longword )(sl * *(sp + -2));
#line 125
    *(L_ACF + 3) += (longword )(sl * *(sp + -3));
#line 125
    *(L_ACF + 4) += (longword )(sl * *(sp + -4));
#line 126
    *(L_ACF + 5) += (longword )(sl * *(sp + -5));
#line 126
    *(L_ACF + 6) += (longword )(sl * *(sp + -6));
#line 126
    *(L_ACF + 7) += (longword )(sl * *(sp + -7));
#line 126
    *(L_ACF + 8) += (longword )(sl * *(sp + -8));
#line 120
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 129
  k = 9;
  {
#line 129
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 129
    if (! __cil_tmp26) {
#line 129
      goto while_break___7;
    }

#line 129
    *(L_ACF + k) <<= 1;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 134
  if ((int )scalauto > 0) {
#line 136
    k = 160;
    {
#line 136
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 136
      if (! __cil_tmp28) {
#line 136
        goto while_break___8;
      }

#line 136
      __cil_tmp29 = s;
#line 136
      s ++;
#line 136
      *__cil_tmp29 <<= (int )scalauto;
    }
    while_break___8: /* CIL Label */ ;
    }
  }
  return;
}
}
#line 142 "/root/libsndfile/src/GSM610/lpc.c"
static void Fast_Autocorrelation(word *s , longword *L_ACF ) 
{ 
  register int k ;
  register int i ;
  float f_L_ACF[9] ;
  float scale ;
  float s_f[160] ;
  register float *sf ;
  register float L_temp2 ;
  register float *sfl ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;

  {
#line 151
  sf = (float *)s_f;
#line 153
  i = 0;
  {
#line 153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 153
    if (! (i < 160)) {
#line 153
      goto while_break;
    }
#line 153
    *(sf + i) = (float )*(s + i);
#line 153
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 154
  k = 0;
  {
#line 154
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 154
    if (! (k <= 8)) {
#line 154
      goto while_break___0;
    }
#line 155
    L_temp2 = (float )0;
#line 156
    sfl = sf - k;
#line 157
    i = k;
    {
#line 157
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 157
      if (! (i < 160)) {
#line 157
        goto while_break___1;
      }
#line 157
      L_temp2 += *(sf + i) * *(sfl + i);
#line 157
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 158
    f_L_ACF[k] = L_temp2;
#line 154
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 160
  scale = (float )2147483647 / f_L_ACF[0];
#line 162
  k = 0;
  {
#line 162
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 162
    if (! (k <= 8)) {
#line 162
      goto while_break___2;
    }
#line 163
    *(L_ACF + k) = (longword )(f_L_ACF[k] * scale);
#line 162
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  return;
}
}
#line 170 "/root/libsndfile/src/GSM610/lpc.c"
static void Reflection_coefficients(longword *L_ACF , word *r ) 
{ 
  register int i ;
  register int m ;
  register int n ;
  register word temp ;
  word ACF[9] ;
  word P[9] ;
  word K[9] ;
  int __cil_tmp10 ;
  word *__cil_tmp11 ;
  int tmp ;
  word __cil_tmp13 ;
  int tmp___0 ;
  longword __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  word __cil_tmp19 ;
  word *__cil_tmp20 ;
  int __cil_tmp21 ;
  word __cil_tmp22 ;
  int tmp___1 ;
  int tmp___2 ;
  longword __cil_tmp25 ;
  longword __cil_tmp26 ;
  longword __cil_tmp27 ;
  longword __cil_tmp28 ;
  longword __cil_tmp29 ;
  longword __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  word *__cil_tmp33 ;

  {
#line 184
  if (*(L_ACF + 0) == 0) {
#line 185
    i = 8;
    {
#line 185
    while (1) {
      while_continue: /* CIL Label */ ;
#line 185
      if (! __cil_tmp10) {
#line 185
        goto while_break;
      }

#line 185
      __cil_tmp11 = r;
#line 185
      r ++;
#line 185
      *__cil_tmp11 = (word )0;
    }
    while_break: /* CIL Label */ ;
    }
#line 186
    return;
  }
  {
#line 190
  temp = gsm_norm(*(L_ACF + 0));
#line 195
  i = 0;
  }
  {
#line 195
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 195
    if (! (i <= 8)) {
#line 195
      goto while_break___0;
    }
    {
#line 195
    __cil_tmp15 = SASR_L(*(L_ACF + i) << (int )temp, (word )16);
#line 195
    ACF[i] = (word )__cil_tmp15;
    }
#line 195
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 200
  i = 1;
  {
#line 200
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 200
    if (! (i <= 7)) {
#line 200
      goto while_break___1;
    }
#line 200
    K[i] = ACF[i];
#line 200
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 201
  i = 0;
  {
#line 201
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 201
    if (! (i <= 8)) {
#line 201
      goto while_break___2;
    }
#line 201
    P[i] = ACF[i];
#line 201
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 205
  n = 1;
  {
#line 205
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 205
    if (! (n <= 8)) {
#line 205
      goto while_break___3;
    }
    {
#line 207
    temp = P[1];
#line 208
    temp = GSM_ABS(temp);
    }
#line 209
    if ((int )P[0] < (int )temp) {
#line 210
      i = n;
      {
#line 210
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 210
        if (! (i <= 8)) {
#line 210
          goto while_break___4;
        }
#line 210
        __cil_tmp20 = r;
#line 210
        r ++;
#line 210
        *__cil_tmp20 = (word )0;
#line 210
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 211
      return;
    }
    {
#line 214
    *r = gsm_div(temp, P[0]);
    }
#line 217
    if ((int )P[1] > 0) {
#line 217
      *r = (word )(- ((int )*r));
    }
#line 219
    if (n == 8) {
#line 219
      return;
    }
    {
#line 223
    __cil_tmp25 = GSM_MULT_R(P[1], *r);
#line 223
    temp = (word )__cil_tmp25;
#line 224
    __cil_tmp26 = GSM_ADD(P[0], temp);
#line 224
    P[0] = (word )__cil_tmp26;
#line 226
    m = 1;
    }
    {
#line 226
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 226
      if (! (m <= 8 - n)) {
#line 226
        goto while_break___5;
      }
      {
#line 227
      __cil_tmp27 = GSM_MULT_R(K[m], *r);
#line 227
      temp = (word )__cil_tmp27;
#line 228
      __cil_tmp28 = GSM_ADD(P[m + 1], temp);
#line 228
      P[m] = (word )__cil_tmp28;
#line 230
      __cil_tmp29 = GSM_MULT_R(P[m + 1], *r);
#line 230
      temp = (word )__cil_tmp29;
#line 231
      __cil_tmp30 = GSM_ADD(K[m], temp);
#line 231
      K[m] = (word )__cil_tmp30;
      }
#line 226
      m ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 205
    __cil_tmp33 = r;
#line 205
    r ++;
#line 205
    __cil_tmp32 = n;
#line 205
    n ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  return;
}
}
#line 238 "/root/libsndfile/src/GSM610/lpc.c"
static void Transformation_to_Log_Area_Ratios(word *r ) 
{ 
  register word temp ;
  register int i ;
  word __cil_tmp4 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int __cil_tmp10 ;
  word *__cil_tmp11 ;

  {
#line 255
  i = 1;
  {
#line 255
  while (1) {
    while_continue: /* CIL Label */ ;
#line 255
    if (! (i <= 8)) {
#line 255
      goto while_break;
    }
    {
#line 257
    temp = *r;
#line 258
    temp = GSM_ABS(temp);
    }
#line 261
    if ((int )temp < 22118) {
#line 262
      temp >>= 1;
    } else
#line 263
    if ((int )temp < 31130) {
#line 265
      temp -= 11059;
    } else {
#line 268
      temp -= 26112;
#line 269
      temp <<= 2;
    }
#line 272
    if ((int )*r < 0) {
#line 272
      tmp___2 = - ((int )temp);
    } else {
#line 272
      tmp___2 = (int )temp;
    }
#line 272
    *r = (word )tmp___2;
#line 255
    __cil_tmp11 = r;
#line 255
    r ++;
#line 255
    __cil_tmp10 = i;
#line 255
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 279 "/root/libsndfile/src/GSM610/lpc.c"
static void Quantization_and_coding(word *LAR ) 
{ 
  register word temp ;
  longword __cil_tmp3 ;
  longword __cil_tmp4 ;
  longword __cil_tmp5 ;
  word __cil_tmp6 ;
  int tmp ;
  int tmp___0 ;
  word *__cil_tmp9 ;
  longword __cil_tmp10 ;
  longword __cil_tmp11 ;
  longword __cil_tmp12 ;
  word __cil_tmp13 ;
  int tmp___1 ;
  int tmp___2 ;
  word *__cil_tmp16 ;
  longword __cil_tmp17 ;
  longword __cil_tmp18 ;
  longword __cil_tmp19 ;
  word __cil_tmp20 ;
  int tmp___3 ;
  int tmp___4 ;
  word *__cil_tmp23 ;
  longword __cil_tmp24 ;
  longword __cil_tmp25 ;
  longword __cil_tmp26 ;
  word __cil_tmp27 ;
  int tmp___5 ;
  int tmp___6 ;
  word *__cil_tmp30 ;
  longword __cil_tmp31 ;
  longword __cil_tmp32 ;
  longword __cil_tmp33 ;
  word __cil_tmp34 ;
  int tmp___7 ;
  int tmp___8 ;
  word *__cil_tmp37 ;
  longword __cil_tmp38 ;
  longword __cil_tmp39 ;
  longword __cil_tmp40 ;
  word __cil_tmp41 ;
  int tmp___9 ;
  int tmp___10 ;
  word *__cil_tmp44 ;
  longword __cil_tmp45 ;
  longword __cil_tmp46 ;
  longword __cil_tmp47 ;
  word __cil_tmp48 ;
  int tmp___11 ;
  int tmp___12 ;
  word *__cil_tmp51 ;
  longword __cil_tmp52 ;
  longword __cil_tmp53 ;
  longword __cil_tmp54 ;
  word __cil_tmp55 ;
  int tmp___13 ;
  int tmp___14 ;
  word *__cil_tmp58 ;

  {
  {
#line 303
  __cil_tmp3 = GSM_MULT((word )20480, *LAR);
#line 303
  temp = (word )__cil_tmp3;
#line 303
  __cil_tmp4 = GSM_ADD(temp, (word )0);
#line 303
  temp = (word )__cil_tmp4;
#line 303
  __cil_tmp5 = GSM_ADD(temp, (word )256);
#line 303
  temp = (word )__cil_tmp5;
#line 303
  temp = SASR_W(temp, (word )9);
  }
#line 303
  if ((int )temp > 31) {
#line 303
    tmp___0 = 63;
  } else {
#line 303
    if ((int )temp < -32) {
#line 303
      tmp = 0;
    } else {
#line 303
      tmp = (int )temp - -32;
    }
#line 303
    tmp___0 = tmp;
  }
  {
#line 303
  *LAR = (word )tmp___0;
#line 303
  LAR ++;
#line 304
  __cil_tmp10 = GSM_MULT((word )20480, *LAR);
#line 304
  temp = (word )__cil_tmp10;
#line 304
  __cil_tmp11 = GSM_ADD(temp, (word )0);
#line 304
  temp = (word )__cil_tmp11;
#line 304
  __cil_tmp12 = GSM_ADD(temp, (word )256);
#line 304
  temp = (word )__cil_tmp12;
#line 304
  temp = SASR_W(temp, (word )9);
  }
#line 304
  if ((int )temp > 31) {
#line 304
    tmp___2 = 63;
  } else {
#line 304
    if ((int )temp < -32) {
#line 304
      tmp___1 = 0;
    } else {
#line 304
      tmp___1 = (int )temp - -32;
    }
#line 304
    tmp___2 = tmp___1;
  }
  {
#line 304
  *LAR = (word )tmp___2;
#line 304
  LAR ++;
#line 305
  __cil_tmp17 = GSM_MULT((word )20480, *LAR);
#line 305
  temp = (word )__cil_tmp17;
#line 305
  __cil_tmp18 = GSM_ADD(temp, (word )2048);
#line 305
  temp = (word )__cil_tmp18;
#line 305
  __cil_tmp19 = GSM_ADD(temp, (word )256);
#line 305
  temp = (word )__cil_tmp19;
#line 305
  temp = SASR_W(temp, (word )9);
  }
#line 305
  if ((int )temp > 15) {
#line 305
    tmp___4 = 31;
  } else {
#line 305
    if ((int )temp < -16) {
#line 305
      tmp___3 = 0;
    } else {
#line 305
      tmp___3 = (int )temp - -16;
    }
#line 305
    tmp___4 = tmp___3;
  }
  {
#line 305
  *LAR = (word )tmp___4;
#line 305
  LAR ++;
#line 306
  __cil_tmp24 = GSM_MULT((word )20480, *LAR);
#line 306
  temp = (word )__cil_tmp24;
#line 306
  __cil_tmp25 = GSM_ADD(temp, (word )(- 2560));
#line 306
  temp = (word )__cil_tmp25;
#line 306
  __cil_tmp26 = GSM_ADD(temp, (word )256);
#line 306
  temp = (word )__cil_tmp26;
#line 306
  temp = SASR_W(temp, (word )9);
  }
#line 306
  if ((int )temp > 15) {
#line 306
    tmp___6 = 31;
  } else {
#line 306
    if ((int )temp < -16) {
#line 306
      tmp___5 = 0;
    } else {
#line 306
      tmp___5 = (int )temp - -16;
    }
#line 306
    tmp___6 = tmp___5;
  }
  {
#line 306
  *LAR = (word )tmp___6;
#line 306
  LAR ++;
#line 308
  __cil_tmp31 = GSM_MULT((word )13964, *LAR);
#line 308
  temp = (word )__cil_tmp31;
#line 308
  __cil_tmp32 = GSM_ADD(temp, (word )94);
#line 308
  temp = (word )__cil_tmp32;
#line 308
  __cil_tmp33 = GSM_ADD(temp, (word )256);
#line 308
  temp = (word )__cil_tmp33;
#line 308
  temp = SASR_W(temp, (word )9);
  }
#line 308
  if ((int )temp > 7) {
#line 308
    tmp___8 = 15;
  } else {
#line 308
    if ((int )temp < -8) {
#line 308
      tmp___7 = 0;
    } else {
#line 308
      tmp___7 = (int )temp - -8;
    }
#line 308
    tmp___8 = tmp___7;
  }
  {
#line 308
  *LAR = (word )tmp___8;
#line 308
  LAR ++;
#line 309
  __cil_tmp38 = GSM_MULT((word )15360, *LAR);
#line 309
  temp = (word )__cil_tmp38;
#line 309
  __cil_tmp39 = GSM_ADD(temp, (word )(- 1792));
#line 309
  temp = (word )__cil_tmp39;
#line 309
  __cil_tmp40 = GSM_ADD(temp, (word )256);
#line 309
  temp = (word )__cil_tmp40;
#line 309
  temp = SASR_W(temp, (word )9);
  }
#line 309
  if ((int )temp > 7) {
#line 309
    tmp___10 = 15;
  } else {
#line 309
    if ((int )temp < -8) {
#line 309
      tmp___9 = 0;
    } else {
#line 309
      tmp___9 = (int )temp - -8;
    }
#line 309
    tmp___10 = tmp___9;
  }
  {
#line 309
  *LAR = (word )tmp___10;
#line 309
  LAR ++;
#line 310
  __cil_tmp45 = GSM_MULT((word )8534, *LAR);
#line 310
  temp = (word )__cil_tmp45;
#line 310
  __cil_tmp46 = GSM_ADD(temp, (word )(- 341));
#line 310
  temp = (word )__cil_tmp46;
#line 310
  __cil_tmp47 = GSM_ADD(temp, (word )256);
#line 310
  temp = (word )__cil_tmp47;
#line 310
  temp = SASR_W(temp, (word )9);
  }
#line 310
  if ((int )temp > 3) {
#line 310
    tmp___12 = 7;
  } else {
#line 310
    if ((int )temp < -4) {
#line 310
      tmp___11 = 0;
    } else {
#line 310
      tmp___11 = (int )temp - -4;
    }
#line 310
    tmp___12 = tmp___11;
  }
  {
#line 310
  *LAR = (word )tmp___12;
#line 310
  LAR ++;
#line 311
  __cil_tmp52 = GSM_MULT((word )9036, *LAR);
#line 311
  temp = (word )__cil_tmp52;
#line 311
  __cil_tmp53 = GSM_ADD(temp, (word )(- 1144));
#line 311
  temp = (word )__cil_tmp53;
#line 311
  __cil_tmp54 = GSM_ADD(temp, (word )256);
#line 311
  temp = (word )__cil_tmp54;
#line 311
  temp = SASR_W(temp, (word )9);
  }
#line 311
  if ((int )temp > 3) {
#line 311
    tmp___14 = 7;
  } else {
#line 311
    if ((int )temp < -4) {
#line 311
      tmp___13 = 0;
    } else {
#line 311
      tmp___13 = (int )temp - -4;
    }
#line 311
    tmp___14 = tmp___13;
  }
#line 311
  *LAR = (word )tmp___14;
#line 311
  LAR ++;
  return;
}
}
#line 316 "/root/libsndfile/src/GSM610/lpc.c"
void Gsm_LPC_Analysis(struct gsm_state *S , word *s , word *LARc ) 
{ 
  longword L_ACF[9] ;

  {
#line 324
  if (S->fast) {
    {
#line 324
    Fast_Autocorrelation(s, (longword *)L_ACF);
    }
  } else {
    {
#line 327
    Autocorrelation(s, (longword *)L_ACF);
    }
  }
  {
#line 328
  Reflection_coefficients((longword *)L_ACF, LARc);
#line 329
  Transformation_to_Log_Area_Ratios(LARc);
#line 330
  Quantization_and_coding(LARc);
  }
  return;
}
}
#line 34 "/root/libsndfile/src/GSM610/gsm.h"
gsm gsm_create(void) ;
#line 37
void gsm_init(gsm state ) ;
#line 39
void gsm_destroy(gsm  ) ;
#line 41
int gsm_print(FILE * , gsm  , gsm_byte * ) ;
#line 42
int gsm_option(gsm  , int  , int * ) ;
#line 44
void gsm_encode(gsm  , gsm_signal * , gsm_byte * ) ;
#line 45
int gsm_decode(gsm s , gsm_byte *c , gsm_signal *target ) ;
#line 47
int gsm_explode(gsm  , gsm_byte * , gsm_signal * ) ;
#line 48
void gsm_implode(gsm  , gsm_signal * , gsm_byte * ) ;
#line 11 "/root/libsndfile/src/GSM610/gsm_decode.c"
int gsm_decode(gsm s , gsm_byte *c , gsm_signal *target ) 
{ 
  word LARc[8] ;
  word Nc[4] ;
  word Mc[4] ;
  word bc[4] ;
  word xmaxc[4] ;
  word xmc[52] ;
  uword sr ;
  gsm_byte *__cil_tmp11 ;
  gsm_byte *__cil_tmp12 ;
  gsm_byte *__cil_tmp13 ;
  gsm_byte *__cil_tmp14 ;
  gsm_byte *__cil_tmp15 ;
  gsm_byte *__cil_tmp16 ;
  gsm_byte *__cil_tmp17 ;
  gsm_byte *__cil_tmp18 ;
  gsm_byte *__cil_tmp19 ;
  gsm_byte *__cil_tmp20 ;
  gsm_byte *__cil_tmp21 ;
  gsm_byte *__cil_tmp22 ;
  gsm_byte *__cil_tmp23 ;
  gsm_byte *__cil_tmp24 ;
  gsm_byte *__cil_tmp25 ;
  gsm_byte *__cil_tmp26 ;
  gsm_byte *__cil_tmp27 ;
  gsm_byte *__cil_tmp28 ;
  gsm_byte *__cil_tmp29 ;
  gsm_byte *__cil_tmp30 ;
  gsm_byte *__cil_tmp31 ;
  gsm_byte *__cil_tmp32 ;
  gsm_byte *__cil_tmp33 ;
  gsm_byte *__cil_tmp34 ;
  gsm_byte *__cil_tmp35 ;
  gsm_byte *__cil_tmp36 ;
  gsm_byte *__cil_tmp37 ;
  gsm_byte *__cil_tmp38 ;
  gsm_byte *__cil_tmp39 ;
  gsm_byte *__cil_tmp40 ;
  gsm_byte *__cil_tmp41 ;
  gsm_byte *__cil_tmp42 ;
  gsm_byte *__cil_tmp43 ;
  gsm_byte *__cil_tmp44 ;
  gsm_byte *__cil_tmp45 ;
  gsm_byte *__cil_tmp46 ;
  gsm_byte *__cil_tmp47 ;
  gsm_byte *__cil_tmp48 ;
  gsm_byte *__cil_tmp49 ;
  gsm_byte *__cil_tmp50 ;
  gsm_byte *__cil_tmp51 ;
  gsm_byte *__cil_tmp52 ;
  gsm_byte *__cil_tmp53 ;
  gsm_byte *__cil_tmp54 ;
  gsm_byte *__cil_tmp55 ;
  gsm_byte *__cil_tmp56 ;
  gsm_byte *__cil_tmp57 ;
  gsm_byte *__cil_tmp58 ;
  gsm_byte *__cil_tmp59 ;
  gsm_byte *__cil_tmp60 ;
  gsm_byte *__cil_tmp61 ;
  gsm_byte *__cil_tmp62 ;
  gsm_byte *__cil_tmp63 ;
  gsm_byte *__cil_tmp64 ;
  gsm_byte *__cil_tmp65 ;
  gsm_byte *__cil_tmp66 ;
  gsm_byte *__cil_tmp67 ;
  gsm_byte *__cil_tmp68 ;
  gsm_byte *__cil_tmp69 ;
  gsm_byte *__cil_tmp70 ;
  gsm_byte *__cil_tmp71 ;
  gsm_byte *__cil_tmp72 ;
  gsm_byte *__cil_tmp73 ;
  gsm_byte *__cil_tmp74 ;
  gsm_byte *__cil_tmp75 ;
  gsm_byte *__cil_tmp76 ;
  gsm_byte *__cil_tmp77 ;
  gsm_byte *__cil_tmp78 ;
  gsm_byte *__cil_tmp79 ;
  gsm_byte *__cil_tmp80 ;
  gsm_byte *__cil_tmp81 ;
  gsm_byte *__cil_tmp82 ;
  gsm_byte *__cil_tmp83 ;
  gsm_byte *__cil_tmp84 ;
  gsm_byte *__cil_tmp85 ;
  gsm_byte *__cil_tmp86 ;
  gsm_byte *__cil_tmp87 ;
  gsm_byte *__cil_tmp88 ;
  gsm_byte *__cil_tmp89 ;
  gsm_byte *__cil_tmp90 ;
  gsm_byte *__cil_tmp91 ;
  gsm_byte *__cil_tmp92 ;
  gsm_byte *__cil_tmp93 ;
  gsm_byte *__cil_tmp94 ;
  gsm_byte *__cil_tmp95 ;
  gsm_byte *__cil_tmp96 ;
  gsm_byte *__cil_tmp97 ;
  gsm_byte *__cil_tmp98 ;
  gsm_byte *__cil_tmp99 ;
  gsm_byte *__cil_tmp100 ;
  gsm_byte *__cil_tmp101 ;
  gsm_byte *__cil_tmp102 ;
  gsm_byte *__cil_tmp103 ;
  gsm_byte *__cil_tmp104 ;
  gsm_byte *__cil_tmp105 ;
  gsm_byte *__cil_tmp106 ;
  gsm_byte *__cil_tmp107 ;

  {
#line 16
  if (s->wav_fmt) {
#line 18
    sr = (uword )0;
#line 20
    s->frame_index = ! s->frame_index;
#line 21
    if (s->frame_index) {
#line 23
      __cil_tmp11 = c;
#line 23
      c ++;
#line 23
      sr = (uword )*__cil_tmp11;
#line 24
      LARc[0] = (word )((int )sr & 63);
#line 24
      sr >>= 6;
#line 25
      __cil_tmp12 = c;
#line 25
      c ++;
#line 25
      sr |= (int )((uword )*__cil_tmp12) << 2;
#line 26
      LARc[1] = (word )((int )sr & 63);
#line 26
      sr >>= 6;
#line 27
      __cil_tmp13 = c;
#line 27
      c ++;
#line 27
      sr |= (int )((uword )*__cil_tmp13) << 4;
#line 28
      LARc[2] = (word )((int )sr & 31);
#line 28
      sr >>= 5;
#line 29
      LARc[3] = (word )((int )sr & 31);
#line 29
      sr >>= 5;
#line 30
      __cil_tmp14 = c;
#line 30
      c ++;
#line 30
      sr |= (int )((uword )*__cil_tmp14) << 2;
#line 31
      LARc[4] = (word )((int )sr & 15);
#line 31
      sr >>= 4;
#line 32
      LARc[5] = (word )((int )sr & 15);
#line 32
      sr >>= 4;
#line 33
      __cil_tmp15 = c;
#line 33
      c ++;
#line 33
      sr |= (int )((uword )*__cil_tmp15) << 2;
#line 34
      LARc[6] = (word )((int )sr & 7);
#line 34
      sr >>= 3;
#line 35
      LARc[7] = (word )((int )sr & 7);
#line 35
      sr >>= 3;
#line 36
      __cil_tmp16 = c;
#line 36
      c ++;
#line 36
      sr |= (int )((uword )*__cil_tmp16) << 4;
#line 37
      Nc[0] = (word )((int )sr & 127);
#line 37
      sr >>= 7;
#line 38
      bc[0] = (word )((int )sr & 3);
#line 38
      sr >>= 2;
#line 39
      Mc[0] = (word )((int )sr & 3);
#line 39
      sr >>= 2;
#line 40
      __cil_tmp17 = c;
#line 40
      c ++;
#line 40
      sr |= (int )((uword )*__cil_tmp17) << 1;
#line 41
      xmaxc[0] = (word )((int )sr & 63);
#line 41
      sr >>= 6;
#line 42
      xmc[0] = (word )((int )sr & 7);
#line 42
      sr >>= 3;
#line 43
      __cil_tmp18 = c;
#line 43
      c ++;
#line 43
      sr = (uword )*__cil_tmp18;
#line 44
      xmc[1] = (word )((int )sr & 7);
#line 44
      sr >>= 3;
#line 45
      xmc[2] = (word )((int )sr & 7);
#line 45
      sr >>= 3;
#line 46
      __cil_tmp19 = c;
#line 46
      c ++;
#line 46
      sr |= (int )((uword )*__cil_tmp19) << 2;
#line 47
      xmc[3] = (word )((int )sr & 7);
#line 47
      sr >>= 3;
#line 48
      xmc[4] = (word )((int )sr & 7);
#line 48
      sr >>= 3;
#line 49
      xmc[5] = (word )((int )sr & 7);
#line 49
      sr >>= 3;
#line 50
      __cil_tmp20 = c;
#line 50
      c ++;
#line 50
      sr |= (int )((uword )*__cil_tmp20) << 1;
#line 51
      xmc[6] = (word )((int )sr & 7);
#line 51
      sr >>= 3;
#line 52
      xmc[7] = (word )((int )sr & 7);
#line 52
      sr >>= 3;
#line 53
      xmc[8] = (word )((int )sr & 7);
#line 53
      sr >>= 3;
#line 54
      __cil_tmp21 = c;
#line 54
      c ++;
#line 54
      sr = (uword )*__cil_tmp21;
#line 55
      xmc[9] = (word )((int )sr & 7);
#line 55
      sr >>= 3;
#line 56
      xmc[10] = (word )((int )sr & 7);
#line 56
      sr >>= 3;
#line 57
      __cil_tmp22 = c;
#line 57
      c ++;
#line 57
      sr |= (int )((uword )*__cil_tmp22) << 2;
#line 58
      xmc[11] = (word )((int )sr & 7);
#line 58
      sr >>= 3;
#line 59
      xmc[12] = (word )((int )sr & 7);
#line 59
      sr >>= 3;
#line 60
      __cil_tmp23 = c;
#line 60
      c ++;
#line 60
      sr |= (int )((uword )*__cil_tmp23) << 4;
#line 61
      Nc[1] = (word )((int )sr & 127);
#line 61
      sr >>= 7;
#line 62
      bc[1] = (word )((int )sr & 3);
#line 62
      sr >>= 2;
#line 63
      Mc[1] = (word )((int )sr & 3);
#line 63
      sr >>= 2;
#line 64
      __cil_tmp24 = c;
#line 64
      c ++;
#line 64
      sr |= (int )((uword )*__cil_tmp24) << 1;
#line 65
      xmaxc[1] = (word )((int )sr & 63);
#line 65
      sr >>= 6;
#line 66
      xmc[13] = (word )((int )sr & 7);
#line 66
      sr >>= 3;
#line 67
      __cil_tmp25 = c;
#line 67
      c ++;
#line 67
      sr = (uword )*__cil_tmp25;
#line 68
      xmc[14] = (word )((int )sr & 7);
#line 68
      sr >>= 3;
#line 69
      xmc[15] = (word )((int )sr & 7);
#line 69
      sr >>= 3;
#line 70
      __cil_tmp26 = c;
#line 70
      c ++;
#line 70
      sr |= (int )((uword )*__cil_tmp26) << 2;
#line 71
      xmc[16] = (word )((int )sr & 7);
#line 71
      sr >>= 3;
#line 72
      xmc[17] = (word )((int )sr & 7);
#line 72
      sr >>= 3;
#line 73
      xmc[18] = (word )((int )sr & 7);
#line 73
      sr >>= 3;
#line 74
      __cil_tmp27 = c;
#line 74
      c ++;
#line 74
      sr |= (int )((uword )*__cil_tmp27) << 1;
#line 75
      xmc[19] = (word )((int )sr & 7);
#line 75
      sr >>= 3;
#line 76
      xmc[20] = (word )((int )sr & 7);
#line 76
      sr >>= 3;
#line 77
      xmc[21] = (word )((int )sr & 7);
#line 77
      sr >>= 3;
#line 78
      __cil_tmp28 = c;
#line 78
      c ++;
#line 78
      sr = (uword )*__cil_tmp28;
#line 79
      xmc[22] = (word )((int )sr & 7);
#line 79
      sr >>= 3;
#line 80
      xmc[23] = (word )((int )sr & 7);
#line 80
      sr >>= 3;
#line 81
      __cil_tmp29 = c;
#line 81
      c ++;
#line 81
      sr |= (int )((uword )*__cil_tmp29) << 2;
#line 82
      xmc[24] = (word )((int )sr & 7);
#line 82
      sr >>= 3;
#line 83
      xmc[25] = (word )((int )sr & 7);
#line 83
      sr >>= 3;
#line 84
      __cil_tmp30 = c;
#line 84
      c ++;
#line 84
      sr |= (int )((uword )*__cil_tmp30) << 4;
#line 85
      Nc[2] = (word )((int )sr & 127);
#line 85
      sr >>= 7;
#line 86
      bc[2] = (word )((int )sr & 3);
#line 86
      sr >>= 2;
#line 87
      Mc[2] = (word )((int )sr & 3);
#line 87
      sr >>= 2;
#line 88
      __cil_tmp31 = c;
#line 88
      c ++;
#line 88
      sr |= (int )((uword )*__cil_tmp31) << 1;
#line 89
      xmaxc[2] = (word )((int )sr & 63);
#line 89
      sr >>= 6;
#line 90
      xmc[26] = (word )((int )sr & 7);
#line 90
      sr >>= 3;
#line 91
      __cil_tmp32 = c;
#line 91
      c ++;
#line 91
      sr = (uword )*__cil_tmp32;
#line 92
      xmc[27] = (word )((int )sr & 7);
#line 92
      sr >>= 3;
#line 93
      xmc[28] = (word )((int )sr & 7);
#line 93
      sr >>= 3;
#line 94
      __cil_tmp33 = c;
#line 94
      c ++;
#line 94
      sr |= (int )((uword )*__cil_tmp33) << 2;
#line 95
      xmc[29] = (word )((int )sr & 7);
#line 95
      sr >>= 3;
#line 96
      xmc[30] = (word )((int )sr & 7);
#line 96
      sr >>= 3;
#line 97
      xmc[31] = (word )((int )sr & 7);
#line 97
      sr >>= 3;
#line 98
      __cil_tmp34 = c;
#line 98
      c ++;
#line 98
      sr |= (int )((uword )*__cil_tmp34) << 1;
#line 99
      xmc[32] = (word )((int )sr & 7);
#line 99
      sr >>= 3;
#line 100
      xmc[33] = (word )((int )sr & 7);
#line 100
      sr >>= 3;
#line 101
      xmc[34] = (word )((int )sr & 7);
#line 101
      sr >>= 3;
#line 102
      __cil_tmp35 = c;
#line 102
      c ++;
#line 102
      sr = (uword )*__cil_tmp35;
#line 103
      xmc[35] = (word )((int )sr & 7);
#line 103
      sr >>= 3;
#line 104
      xmc[36] = (word )((int )sr & 7);
#line 104
      sr >>= 3;
#line 105
      __cil_tmp36 = c;
#line 105
      c ++;
#line 105
      sr |= (int )((uword )*__cil_tmp36) << 2;
#line 106
      xmc[37] = (word )((int )sr & 7);
#line 106
      sr >>= 3;
#line 107
      xmc[38] = (word )((int )sr & 7);
#line 107
      sr >>= 3;
#line 108
      __cil_tmp37 = c;
#line 108
      c ++;
#line 108
      sr |= (int )((uword )*__cil_tmp37) << 4;
#line 109
      Nc[3] = (word )((int )sr & 127);
#line 109
      sr >>= 7;
#line 110
      bc[3] = (word )((int )sr & 3);
#line 110
      sr >>= 2;
#line 111
      Mc[3] = (word )((int )sr & 3);
#line 111
      sr >>= 2;
#line 112
      __cil_tmp38 = c;
#line 112
      c ++;
#line 112
      sr |= (int )((uword )*__cil_tmp38) << 1;
#line 113
      xmaxc[3] = (word )((int )sr & 63);
#line 113
      sr >>= 6;
#line 114
      xmc[39] = (word )((int )sr & 7);
#line 114
      sr >>= 3;
#line 115
      __cil_tmp39 = c;
#line 115
      c ++;
#line 115
      sr = (uword )*__cil_tmp39;
#line 116
      xmc[40] = (word )((int )sr & 7);
#line 116
      sr >>= 3;
#line 117
      xmc[41] = (word )((int )sr & 7);
#line 117
      sr >>= 3;
#line 118
      __cil_tmp40 = c;
#line 118
      c ++;
#line 118
      sr |= (int )((uword )*__cil_tmp40) << 2;
#line 119
      xmc[42] = (word )((int )sr & 7);
#line 119
      sr >>= 3;
#line 120
      xmc[43] = (word )((int )sr & 7);
#line 120
      sr >>= 3;
#line 121
      xmc[44] = (word )((int )sr & 7);
#line 121
      sr >>= 3;
#line 122
      __cil_tmp41 = c;
#line 122
      c ++;
#line 122
      sr |= (int )((uword )*__cil_tmp41) << 1;
#line 123
      xmc[45] = (word )((int )sr & 7);
#line 123
      sr >>= 3;
#line 124
      xmc[46] = (word )((int )sr & 7);
#line 124
      sr >>= 3;
#line 125
      xmc[47] = (word )((int )sr & 7);
#line 125
      sr >>= 3;
#line 126
      __cil_tmp42 = c;
#line 126
      c ++;
#line 126
      sr = (uword )*__cil_tmp42;
#line 127
      xmc[48] = (word )((int )sr & 7);
#line 127
      sr >>= 3;
#line 128
      xmc[49] = (word )((int )sr & 7);
#line 128
      sr >>= 3;
#line 129
      __cil_tmp43 = c;
#line 129
      c ++;
#line 129
      sr |= (int )((uword )*__cil_tmp43) << 2;
#line 130
      xmc[50] = (word )((int )sr & 7);
#line 130
      sr >>= 3;
#line 131
      xmc[51] = (word )((int )sr & 7);
#line 131
      sr >>= 3;
#line 133
      s->frame_chain = (unsigned char )((int )sr & 15);
    } else {
#line 136
      sr = (uword )s->frame_chain;
#line 137
      __cil_tmp44 = c;
#line 137
      c ++;
#line 137
      sr |= (int )((uword )*__cil_tmp44) << 4;
#line 138
      LARc[0] = (word )((int )sr & 63);
#line 138
      sr >>= 6;
#line 139
      LARc[1] = (word )((int )sr & 63);
#line 139
      sr >>= 6;
#line 140
      __cil_tmp45 = c;
#line 140
      c ++;
#line 140
      sr = (uword )*__cil_tmp45;
#line 141
      LARc[2] = (word )((int )sr & 31);
#line 141
      sr >>= 5;
#line 142
      __cil_tmp46 = c;
#line 142
      c ++;
#line 142
      sr |= (int )((uword )*__cil_tmp46) << 3;
#line 143
      LARc[3] = (word )((int )sr & 31);
#line 143
      sr >>= 5;
#line 144
      LARc[4] = (word )((int )sr & 15);
#line 144
      sr >>= 4;
#line 145
      __cil_tmp47 = c;
#line 145
      c ++;
#line 145
      sr |= (int )((uword )*__cil_tmp47) << 2;
#line 146
      LARc[5] = (word )((int )sr & 15);
#line 146
      sr >>= 4;
#line 147
      LARc[6] = (word )((int )sr & 7);
#line 147
      sr >>= 3;
#line 148
      LARc[7] = (word )((int )sr & 7);
#line 148
      sr >>= 3;
#line 149
      __cil_tmp48 = c;
#line 149
      c ++;
#line 149
      sr = (uword )*__cil_tmp48;
#line 150
      Nc[0] = (word )((int )sr & 127);
#line 150
      sr >>= 7;
#line 151
      __cil_tmp49 = c;
#line 151
      c ++;
#line 151
      sr |= (int )((uword )*__cil_tmp49) << 1;
#line 152
      bc[0] = (word )((int )sr & 3);
#line 152
      sr >>= 2;
#line 153
      Mc[0] = (word )((int )sr & 3);
#line 153
      sr >>= 2;
#line 154
      __cil_tmp50 = c;
#line 154
      c ++;
#line 154
      sr |= (int )((uword )*__cil_tmp50) << 5;
#line 155
      xmaxc[0] = (word )((int )sr & 63);
#line 155
      sr >>= 6;
#line 156
      xmc[0] = (word )((int )sr & 7);
#line 156
      sr >>= 3;
#line 157
      xmc[1] = (word )((int )sr & 7);
#line 157
      sr >>= 3;
#line 158
      __cil_tmp51 = c;
#line 158
      c ++;
#line 158
      sr |= (int )((uword )*__cil_tmp51) << 1;
#line 159
      xmc[2] = (word )((int )sr & 7);
#line 159
      sr >>= 3;
#line 160
      xmc[3] = (word )((int )sr & 7);
#line 160
      sr >>= 3;
#line 161
      xmc[4] = (word )((int )sr & 7);
#line 161
      sr >>= 3;
#line 162
      __cil_tmp52 = c;
#line 162
      c ++;
#line 162
      sr = (uword )*__cil_tmp52;
#line 163
      xmc[5] = (word )((int )sr & 7);
#line 163
      sr >>= 3;
#line 164
      xmc[6] = (word )((int )sr & 7);
#line 164
      sr >>= 3;
#line 165
      __cil_tmp53 = c;
#line 165
      c ++;
#line 165
      sr |= (int )((uword )*__cil_tmp53) << 2;
#line 166
      xmc[7] = (word )((int )sr & 7);
#line 166
      sr >>= 3;
#line 167
      xmc[8] = (word )((int )sr & 7);
#line 167
      sr >>= 3;
#line 168
      xmc[9] = (word )((int )sr & 7);
#line 168
      sr >>= 3;
#line 169
      __cil_tmp54 = c;
#line 169
      c ++;
#line 169
      sr |= (int )((uword )*__cil_tmp54) << 1;
#line 170
      xmc[10] = (word )((int )sr & 7);
#line 170
      sr >>= 3;
#line 171
      xmc[11] = (word )((int )sr & 7);
#line 171
      sr >>= 3;
#line 172
      xmc[12] = (word )((int )sr & 7);
#line 172
      sr >>= 3;
#line 173
      __cil_tmp55 = c;
#line 173
      c ++;
#line 173
      sr = (uword )*__cil_tmp55;
#line 174
      Nc[1] = (word )((int )sr & 127);
#line 174
      sr >>= 7;
#line 175
      __cil_tmp56 = c;
#line 175
      c ++;
#line 175
      sr |= (int )((uword )*__cil_tmp56) << 1;
#line 176
      bc[1] = (word )((int )sr & 3);
#line 176
      sr >>= 2;
#line 177
      Mc[1] = (word )((int )sr & 3);
#line 177
      sr >>= 2;
#line 178
      __cil_tmp57 = c;
#line 178
      c ++;
#line 178
      sr |= (int )((uword )*__cil_tmp57) << 5;
#line 179
      xmaxc[1] = (word )((int )sr & 63);
#line 179
      sr >>= 6;
#line 180
      xmc[13] = (word )((int )sr & 7);
#line 180
      sr >>= 3;
#line 181
      xmc[14] = (word )((int )sr & 7);
#line 181
      sr >>= 3;
#line 182
      __cil_tmp58 = c;
#line 182
      c ++;
#line 182
      sr |= (int )((uword )*__cil_tmp58) << 1;
#line 183
      xmc[15] = (word )((int )sr & 7);
#line 183
      sr >>= 3;
#line 184
      xmc[16] = (word )((int )sr & 7);
#line 184
      sr >>= 3;
#line 185
      xmc[17] = (word )((int )sr & 7);
#line 185
      sr >>= 3;
#line 186
      __cil_tmp59 = c;
#line 186
      c ++;
#line 186
      sr = (uword )*__cil_tmp59;
#line 187
      xmc[18] = (word )((int )sr & 7);
#line 187
      sr >>= 3;
#line 188
      xmc[19] = (word )((int )sr & 7);
#line 188
      sr >>= 3;
#line 189
      __cil_tmp60 = c;
#line 189
      c ++;
#line 189
      sr |= (int )((uword )*__cil_tmp60) << 2;
#line 190
      xmc[20] = (word )((int )sr & 7);
#line 190
      sr >>= 3;
#line 191
      xmc[21] = (word )((int )sr & 7);
#line 191
      sr >>= 3;
#line 192
      xmc[22] = (word )((int )sr & 7);
#line 192
      sr >>= 3;
#line 193
      __cil_tmp61 = c;
#line 193
      c ++;
#line 193
      sr |= (int )((uword )*__cil_tmp61) << 1;
#line 194
      xmc[23] = (word )((int )sr & 7);
#line 194
      sr >>= 3;
#line 195
      xmc[24] = (word )((int )sr & 7);
#line 195
      sr >>= 3;
#line 196
      xmc[25] = (word )((int )sr & 7);
#line 196
      sr >>= 3;
#line 197
      __cil_tmp62 = c;
#line 197
      c ++;
#line 197
      sr = (uword )*__cil_tmp62;
#line 198
      Nc[2] = (word )((int )sr & 127);
#line 198
      sr >>= 7;
#line 199
      __cil_tmp63 = c;
#line 199
      c ++;
#line 199
      sr |= (int )((uword )*__cil_tmp63) << 1;
#line 200
      bc[2] = (word )((int )sr & 3);
#line 200
      sr >>= 2;
#line 201
      Mc[2] = (word )((int )sr & 3);
#line 201
      sr >>= 2;
#line 202
      __cil_tmp64 = c;
#line 202
      c ++;
#line 202
      sr |= (int )((uword )*__cil_tmp64) << 5;
#line 203
      xmaxc[2] = (word )((int )sr & 63);
#line 203
      sr >>= 6;
#line 204
      xmc[26] = (word )((int )sr & 7);
#line 204
      sr >>= 3;
#line 205
      xmc[27] = (word )((int )sr & 7);
#line 205
      sr >>= 3;
#line 206
      __cil_tmp65 = c;
#line 206
      c ++;
#line 206
      sr |= (int )((uword )*__cil_tmp65) << 1;
#line 207
      xmc[28] = (word )((int )sr & 7);
#line 207
      sr >>= 3;
#line 208
      xmc[29] = (word )((int )sr & 7);
#line 208
      sr >>= 3;
#line 209
      xmc[30] = (word )((int )sr & 7);
#line 209
      sr >>= 3;
#line 210
      __cil_tmp66 = c;
#line 210
      c ++;
#line 210
      sr = (uword )*__cil_tmp66;
#line 211
      xmc[31] = (word )((int )sr & 7);
#line 211
      sr >>= 3;
#line 212
      xmc[32] = (word )((int )sr & 7);
#line 212
      sr >>= 3;
#line 213
      __cil_tmp67 = c;
#line 213
      c ++;
#line 213
      sr |= (int )((uword )*__cil_tmp67) << 2;
#line 214
      xmc[33] = (word )((int )sr & 7);
#line 214
      sr >>= 3;
#line 215
      xmc[34] = (word )((int )sr & 7);
#line 215
      sr >>= 3;
#line 216
      xmc[35] = (word )((int )sr & 7);
#line 216
      sr >>= 3;
#line 217
      __cil_tmp68 = c;
#line 217
      c ++;
#line 217
      sr |= (int )((uword )*__cil_tmp68) << 1;
#line 218
      xmc[36] = (word )((int )sr & 7);
#line 218
      sr >>= 3;
#line 219
      xmc[37] = (word )((int )sr & 7);
#line 219
      sr >>= 3;
#line 220
      xmc[38] = (word )((int )sr & 7);
#line 220
      sr >>= 3;
#line 221
      __cil_tmp69 = c;
#line 221
      c ++;
#line 221
      sr = (uword )*__cil_tmp69;
#line 222
      Nc[3] = (word )((int )sr & 127);
#line 222
      sr >>= 7;
#line 223
      __cil_tmp70 = c;
#line 223
      c ++;
#line 223
      sr |= (int )((uword )*__cil_tmp70) << 1;
#line 224
      bc[3] = (word )((int )sr & 3);
#line 224
      sr >>= 2;
#line 225
      Mc[3] = (word )((int )sr & 3);
#line 225
      sr >>= 2;
#line 226
      __cil_tmp71 = c;
#line 226
      c ++;
#line 226
      sr |= (int )((uword )*__cil_tmp71) << 5;
#line 227
      xmaxc[3] = (word )((int )sr & 63);
#line 227
      sr >>= 6;
#line 228
      xmc[39] = (word )((int )sr & 7);
#line 228
      sr >>= 3;
#line 229
      xmc[40] = (word )((int )sr & 7);
#line 229
      sr >>= 3;
#line 230
      __cil_tmp72 = c;
#line 230
      c ++;
#line 230
      sr |= (int )((uword )*__cil_tmp72) << 1;
#line 231
      xmc[41] = (word )((int )sr & 7);
#line 231
      sr >>= 3;
#line 232
      xmc[42] = (word )((int )sr & 7);
#line 232
      sr >>= 3;
#line 233
      xmc[43] = (word )((int )sr & 7);
#line 233
      sr >>= 3;
#line 234
      __cil_tmp73 = c;
#line 234
      c ++;
#line 234
      sr = (uword )*__cil_tmp73;
#line 235
      xmc[44] = (word )((int )sr & 7);
#line 235
      sr >>= 3;
#line 236
      xmc[45] = (word )((int )sr & 7);
#line 236
      sr >>= 3;
#line 237
      __cil_tmp74 = c;
#line 237
      c ++;
#line 237
      sr |= (int )((uword )*__cil_tmp74) << 2;
#line 238
      xmc[46] = (word )((int )sr & 7);
#line 238
      sr >>= 3;
#line 239
      xmc[47] = (word )((int )sr & 7);
#line 239
      sr >>= 3;
#line 240
      xmc[48] = (word )((int )sr & 7);
#line 240
      sr >>= 3;
#line 241
      __cil_tmp75 = c;
#line 241
      c ++;
#line 241
      sr |= (int )((uword )*__cil_tmp75) << 1;
#line 242
      xmc[49] = (word )((int )sr & 7);
#line 242
      sr >>= 3;
#line 243
      xmc[50] = (word )((int )sr & 7);
#line 243
      sr >>= 3;
#line 244
      xmc[51] = (word )((int )sr & 7);
#line 244
      sr >>= 3;
    }
  } else {
#line 252
    if ((((int )*c >> 4) & 15) != 13) {
#line 252
      return (- 1);
    }
#line 254
    __cil_tmp76 = c;
#line 254
    c ++;
#line 254
    LARc[0] = (word )(((int )*__cil_tmp76 & 15) << 2);
#line 255
    LARc[0] |= ((int )*c >> 6) & 3;
#line 256
    __cil_tmp77 = c;
#line 256
    c ++;
#line 256
    LARc[1] = (word )((int )*__cil_tmp77 & 63);
#line 257
    LARc[2] = (word )(((int )*c >> 3) & 31);
#line 258
    __cil_tmp78 = c;
#line 258
    c ++;
#line 258
    LARc[3] = (word )(((int )*__cil_tmp78 & 7) << 2);
#line 259
    LARc[3] |= ((int )*c >> 6) & 3;
#line 260
    LARc[4] = (word )(((int )*c >> 2) & 15);
#line 261
    __cil_tmp79 = c;
#line 261
    c ++;
#line 261
    LARc[5] = (word )(((int )*__cil_tmp79 & 3) << 2);
#line 262
    LARc[5] |= ((int )*c >> 6) & 3;
#line 263
    LARc[6] = (word )(((int )*c >> 3) & 7);
#line 264
    __cil_tmp80 = c;
#line 264
    c ++;
#line 264
    LARc[7] = (word )((int )*__cil_tmp80 & 7);
#line 265
    Nc[0] = (word )(((int )*c >> 1) & 127);
#line 266
    __cil_tmp81 = c;
#line 266
    c ++;
#line 266
    bc[0] = (word )(((int )*__cil_tmp81 & 1) << 1);
#line 267
    bc[0] |= ((int )*c >> 7) & 1;
#line 268
    Mc[0] = (word )(((int )*c >> 5) & 3);
#line 269
    __cil_tmp82 = c;
#line 269
    c ++;
#line 269
    xmaxc[0] = (word )(((int )*__cil_tmp82 & 31) << 1);
#line 270
    xmaxc[0] |= ((int )*c >> 7) & 1;
#line 271
    xmc[0] = (word )(((int )*c >> 4) & 7);
#line 272
    xmc[1] = (word )(((int )*c >> 1) & 7);
#line 273
    __cil_tmp83 = c;
#line 273
    c ++;
#line 273
    xmc[2] = (word )(((int )*__cil_tmp83 & 1) << 2);
#line 274
    xmc[2] |= ((int )*c >> 6) & 3;
#line 275
    xmc[3] = (word )(((int )*c >> 3) & 7);
#line 276
    __cil_tmp84 = c;
#line 276
    c ++;
#line 276
    xmc[4] = (word )((int )*__cil_tmp84 & 7);
#line 277
    xmc[5] = (word )(((int )*c >> 5) & 7);
#line 278
    xmc[6] = (word )(((int )*c >> 2) & 7);
#line 279
    __cil_tmp85 = c;
#line 279
    c ++;
#line 279
    xmc[7] = (word )(((int )*__cil_tmp85 & 3) << 1);
#line 280
    xmc[7] |= ((int )*c >> 7) & 1;
#line 281
    xmc[8] = (word )(((int )*c >> 4) & 7);
#line 282
    xmc[9] = (word )(((int )*c >> 1) & 7);
#line 283
    __cil_tmp86 = c;
#line 283
    c ++;
#line 283
    xmc[10] = (word )(((int )*__cil_tmp86 & 1) << 2);
#line 284
    xmc[10] |= ((int )*c >> 6) & 3;
#line 285
    xmc[11] = (word )(((int )*c >> 3) & 7);
#line 286
    __cil_tmp87 = c;
#line 286
    c ++;
#line 286
    xmc[12] = (word )((int )*__cil_tmp87 & 7);
#line 287
    Nc[1] = (word )(((int )*c >> 1) & 127);
#line 288
    __cil_tmp88 = c;
#line 288
    c ++;
#line 288
    bc[1] = (word )(((int )*__cil_tmp88 & 1) << 1);
#line 289
    bc[1] |= ((int )*c >> 7) & 1;
#line 290
    Mc[1] = (word )(((int )*c >> 5) & 3);
#line 291
    __cil_tmp89 = c;
#line 291
    c ++;
#line 291
    xmaxc[1] = (word )(((int )*__cil_tmp89 & 31) << 1);
#line 292
    xmaxc[1] |= ((int )*c >> 7) & 1;
#line 293
    xmc[13] = (word )(((int )*c >> 4) & 7);
#line 294
    xmc[14] = (word )(((int )*c >> 1) & 7);
#line 295
    __cil_tmp90 = c;
#line 295
    c ++;
#line 295
    xmc[15] = (word )(((int )*__cil_tmp90 & 1) << 2);
#line 296
    xmc[15] |= ((int )*c >> 6) & 3;
#line 297
    xmc[16] = (word )(((int )*c >> 3) & 7);
#line 298
    __cil_tmp91 = c;
#line 298
    c ++;
#line 298
    xmc[17] = (word )((int )*__cil_tmp91 & 7);
#line 299
    xmc[18] = (word )(((int )*c >> 5) & 7);
#line 300
    xmc[19] = (word )(((int )*c >> 2) & 7);
#line 301
    __cil_tmp92 = c;
#line 301
    c ++;
#line 301
    xmc[20] = (word )(((int )*__cil_tmp92 & 3) << 1);
#line 302
    xmc[20] |= ((int )*c >> 7) & 1;
#line 303
    xmc[21] = (word )(((int )*c >> 4) & 7);
#line 304
    xmc[22] = (word )(((int )*c >> 1) & 7);
#line 305
    __cil_tmp93 = c;
#line 305
    c ++;
#line 305
    xmc[23] = (word )(((int )*__cil_tmp93 & 1) << 2);
#line 306
    xmc[23] |= ((int )*c >> 6) & 3;
#line 307
    xmc[24] = (word )(((int )*c >> 3) & 7);
#line 308
    __cil_tmp94 = c;
#line 308
    c ++;
#line 308
    xmc[25] = (word )((int )*__cil_tmp94 & 7);
#line 309
    Nc[2] = (word )(((int )*c >> 1) & 127);
#line 310
    __cil_tmp95 = c;
#line 310
    c ++;
#line 310
    bc[2] = (word )(((int )*__cil_tmp95 & 1) << 1);
#line 311
    bc[2] |= ((int )*c >> 7) & 1;
#line 312
    Mc[2] = (word )(((int )*c >> 5) & 3);
#line 313
    __cil_tmp96 = c;
#line 313
    c ++;
#line 313
    xmaxc[2] = (word )(((int )*__cil_tmp96 & 31) << 1);
#line 314
    xmaxc[2] |= ((int )*c >> 7) & 1;
#line 315
    xmc[26] = (word )(((int )*c >> 4) & 7);
#line 316
    xmc[27] = (word )(((int )*c >> 1) & 7);
#line 317
    __cil_tmp97 = c;
#line 317
    c ++;
#line 317
    xmc[28] = (word )(((int )*__cil_tmp97 & 1) << 2);
#line 318
    xmc[28] |= ((int )*c >> 6) & 3;
#line 319
    xmc[29] = (word )(((int )*c >> 3) & 7);
#line 320
    __cil_tmp98 = c;
#line 320
    c ++;
#line 320
    xmc[30] = (word )((int )*__cil_tmp98 & 7);
#line 321
    xmc[31] = (word )(((int )*c >> 5) & 7);
#line 322
    xmc[32] = (word )(((int )*c >> 2) & 7);
#line 323
    __cil_tmp99 = c;
#line 323
    c ++;
#line 323
    xmc[33] = (word )(((int )*__cil_tmp99 & 3) << 1);
#line 324
    xmc[33] |= ((int )*c >> 7) & 1;
#line 325
    xmc[34] = (word )(((int )*c >> 4) & 7);
#line 326
    xmc[35] = (word )(((int )*c >> 1) & 7);
#line 327
    __cil_tmp100 = c;
#line 327
    c ++;
#line 327
    xmc[36] = (word )(((int )*__cil_tmp100 & 1) << 2);
#line 328
    xmc[36] |= ((int )*c >> 6) & 3;
#line 329
    xmc[37] = (word )(((int )*c >> 3) & 7);
#line 330
    __cil_tmp101 = c;
#line 330
    c ++;
#line 330
    xmc[38] = (word )((int )*__cil_tmp101 & 7);
#line 331
    Nc[3] = (word )(((int )*c >> 1) & 127);
#line 332
    __cil_tmp102 = c;
#line 332
    c ++;
#line 332
    bc[3] = (word )(((int )*__cil_tmp102 & 1) << 1);
#line 333
    bc[3] |= ((int )*c >> 7) & 1;
#line 334
    Mc[3] = (word )(((int )*c >> 5) & 3);
#line 335
    __cil_tmp103 = c;
#line 335
    c ++;
#line 335
    xmaxc[3] = (word )(((int )*__cil_tmp103 & 31) << 1);
#line 336
    xmaxc[3] |= ((int )*c >> 7) & 1;
#line 337
    xmc[39] = (word )(((int )*c >> 4) & 7);
#line 338
    xmc[40] = (word )(((int )*c >> 1) & 7);
#line 339
    __cil_tmp104 = c;
#line 339
    c ++;
#line 339
    xmc[41] = (word )(((int )*__cil_tmp104 & 1) << 2);
#line 340
    xmc[41] |= ((int )*c >> 6) & 3;
#line 341
    xmc[42] = (word )(((int )*c >> 3) & 7);
#line 342
    __cil_tmp105 = c;
#line 342
    c ++;
#line 342
    xmc[43] = (word )((int )*__cil_tmp105 & 7);
#line 343
    xmc[44] = (word )(((int )*c >> 5) & 7);
#line 344
    xmc[45] = (word )(((int )*c >> 2) & 7);
#line 345
    __cil_tmp106 = c;
#line 345
    c ++;
#line 345
    xmc[46] = (word )(((int )*__cil_tmp106 & 3) << 1);
#line 346
    xmc[46] |= ((int )*c >> 7) & 1;
#line 347
    xmc[47] = (word )(((int )*c >> 4) & 7);
#line 348
    xmc[48] = (word )(((int )*c >> 1) & 7);
#line 349
    __cil_tmp107 = c;
#line 349
    c ++;
#line 349
    xmc[49] = (word )(((int )*__cil_tmp107 & 1) << 2);
#line 350
    xmc[49] |= ((int )*c >> 6) & 3;
#line 351
    xmc[50] = (word )(((int )*c >> 3) & 7);
#line 352
    xmc[51] = (word )((int )*c & 7);
  }
  {
#line 355
  Gsm_Decoder(s, (word *)LARc, (word *)Nc, (word *)bc, (word *)Mc, (word *)xmaxc,
              (word *)xmc, target);
  }
#line 357
  return (0);
}
}
#line 97 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) size_t __ctype_get_mb_cur_max(void) ;
#line 101
__inline extern  __attribute__((__nothrow__)) double atof(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 104
__inline extern  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 107
__inline extern  __attribute__((__nothrow__)) long atol(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 112
__inline extern  __attribute__((__nothrow__)) long long atoll(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 117
extern  __attribute__((__nothrow__)) double strtod(char const   *__nptr , char **__endptr ) ;
#line 123
extern  __attribute__((__nothrow__)) float strtof(char const   *__nptr , char **__endptr ) ;
#line 126
extern  __attribute__((__nothrow__)) long double strtold(char const   *__nptr , char **__endptr ) ;
#line 176
extern  __attribute__((__nothrow__)) long strtol(char const   *__nptr , char **__endptr ,
                                                 int __base ) ;
#line 180
extern  __attribute__((__nothrow__)) unsigned long strtoul(char const   *__nptr ,
                                                           char **__endptr , int __base ) ;
#line 187
extern  __attribute__((__nothrow__)) long long strtoq(char const   *__nptr , char **__endptr ,
                                                      int __base ) ;
#line 192
extern  __attribute__((__nothrow__)) unsigned long long strtouq(char const   *__nptr ,
                                                                char **__endptr ,
                                                                int __base ) ;
#line 200
extern  __attribute__((__nothrow__)) long long strtoll(char const   *__nptr , char **__endptr ,
                                                       int __base ) ;
#line 205
extern  __attribute__((__nothrow__)) unsigned long long strtoull(char const   *__nptr ,
                                                                 char **__endptr ,
                                                                 int __base ) ;
#line 361
__inline extern  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 361 "/usr/include/stdlib.h"
__inline extern int atoi(char const   *__nptr ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 363
  __cil_tmp2 = strtol(__nptr, (char **)((void *)0), 10);
  }
#line 363
  return ((int )__cil_tmp2);
}
}
#line 366
__inline extern  __attribute__((__nothrow__)) long atol(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 366 "/usr/include/stdlib.h"
__inline extern long atol(char const   *__nptr ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 368
  __cil_tmp2 = strtol(__nptr, (char **)((void *)0), 10);
  }
#line 368
  return (__cil_tmp2);
}
}
#line 373
__inline extern  __attribute__((__nothrow__)) long long atoll(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 373 "/usr/include/stdlib.h"
__inline extern long long atoll(char const   *__nptr ) 
{ 
  long long __cil_tmp2 ;

  {
  {
#line 375
  __cil_tmp2 = strtoll(__nptr, (char **)((void *)0), 10);
  }
#line 375
  return (__cil_tmp2);
}
}
#line 385
extern  __attribute__((__nothrow__)) char *l64a(long __n ) ;
#line 388
extern  __attribute__((__nothrow__)) long a64l(char const   *__s ) ;
#line 34 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint16_t __bswap_16(__uint16_t __bsx ) 
{ 
  short __cil_tmp2 ;

  {
  {
#line 37
  __cil_tmp2 = __builtin_bswap16(__bsx);
  }
#line 37
  return (__cil_tmp2);
}
}
#line 49 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint32_t __bswap_32(__uint32_t __bsx ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 52
  __cil_tmp2 = __builtin_bswap32(__bsx);
  }
#line 52
  return (__cil_tmp2);
}
}
#line 70 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint64_t __bswap_64(__uint64_t __bsx ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 73
  __cil_tmp2 = __builtin_bswap64(__bsx);
  }
#line 73
  return (__cil_tmp2);
}
}
#line 33 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__inline static __uint16_t __uint16_identity(__uint16_t __x ) 
{ 


  {
#line 35
  return (__x);
}
}
#line 39 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__inline static __uint32_t __uint32_identity(__uint32_t __x ) 
{ 


  {
#line 41
  return (__x);
}
}
#line 45 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__inline static __uint64_t __uint64_identity(__uint64_t __x ) 
{ 


  {
#line 47
  return (__x);
}
}
#line 101 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set *__readfds , fd_set *__writefds , fd_set *__exceptfds ,
                  struct timeval *__timeout ) ;
#line 113
extern int pselect(int __nfds , fd_set *__readfds , fd_set *__writefds , fd_set *__exceptfds ,
                   struct timespec *__timeout , __sigset_t *__sigmask ) ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/select2.h"
extern long __fdelt_chk(long __d ) ;
#line 25
extern long __fdelt_warn(long __d ) ;
#line 401 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long random(void) ;
#line 404
extern  __attribute__((__nothrow__)) void srandom(unsigned int __seed ) ;
#line 410
extern  __attribute__((__nothrow__)) char *initstate(unsigned int __seed , char *__statebuf ,
                                                     size_t __statelen ) ;
#line 415
extern  __attribute__((__nothrow__)) char *setstate(char *__statebuf ) ;
#line 434
extern  __attribute__((__nothrow__)) int random_r(struct random_data *__buf , int32_t *__result ) ;
#line 437
extern  __attribute__((__nothrow__)) int srandom_r(unsigned int __seed , struct random_data *__buf ) ;
#line 440
extern  __attribute__((__nothrow__)) int initstate_r(unsigned int __seed , char *__statebuf ,
                                                     size_t __statelen , struct random_data *__buf ) ;
#line 445
extern  __attribute__((__nothrow__)) int setstate_r(char *__statebuf , struct random_data *__buf ) ;
#line 453
extern  __attribute__((__nothrow__)) int rand(void) ;
#line 455
extern  __attribute__((__nothrow__)) void srand(unsigned int __seed ) ;
#line 459
extern  __attribute__((__nothrow__)) int rand_r(unsigned int *__seed ) ;
#line 467
extern  __attribute__((__nothrow__)) double drand48(void) ;
#line 468
extern  __attribute__((__nothrow__)) double erand48(unsigned short __xsubi[3] ) ;
#line 471
extern  __attribute__((__nothrow__)) long lrand48(void) ;
#line 472
extern  __attribute__((__nothrow__)) long nrand48(unsigned short __xsubi[3] ) ;
#line 476
extern  __attribute__((__nothrow__)) long mrand48(void) ;
#line 477
extern  __attribute__((__nothrow__)) long jrand48(unsigned short __xsubi[3] ) ;
#line 481
extern  __attribute__((__nothrow__)) void srand48(long __seedval ) ;
#line 482
extern  __attribute__((__nothrow__)) unsigned short *seed48(unsigned short __seed16v[3] ) ;
#line 484
extern  __attribute__((__nothrow__)) void lcong48(unsigned short __param[7] ) ;
#line 501
extern  __attribute__((__nothrow__)) int drand48_r(struct drand48_data *__buffer ,
                                                   double *__result ) ;
#line 503
extern  __attribute__((__nothrow__)) int erand48_r(unsigned short __xsubi[3] , struct drand48_data *__buffer ,
                                                   double *__result ) ;
#line 508
extern  __attribute__((__nothrow__)) int lrand48_r(struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 511
extern  __attribute__((__nothrow__)) int nrand48_r(unsigned short __xsubi[3] , struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 517
extern  __attribute__((__nothrow__)) int mrand48_r(struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 520
extern  __attribute__((__nothrow__)) int jrand48_r(unsigned short __xsubi[3] , struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 526
extern  __attribute__((__nothrow__)) int srand48_r(long __seedval , struct drand48_data *__buffer ) ;
#line 529
extern  __attribute__((__nothrow__)) int seed48_r(unsigned short __seed16v[3] , struct drand48_data *__buffer ) ;
#line 532
extern  __attribute__((__nothrow__)) int lcong48_r(unsigned short __param[7] , struct drand48_data *__buffer ) ;
#line 539
extern  __attribute__((__nothrow__)) void *malloc(size_t __size ) ;
#line 542
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size ) ;
#line 550
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size ) ;
#line 559
extern  __attribute__((__nothrow__)) void *reallocarray(void *__ptr , size_t __nmemb ,
                                                        size_t __size ) ;
#line 565
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 32 "/usr/include/alloca.h"
extern  __attribute__((__nothrow__)) void *alloca(size_t __size ) ;
#line 574 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *valloc(size_t __size ) ;
#line 580
extern  __attribute__((__nothrow__)) int posix_memalign(void **__memptr , size_t __alignment ,
                                                        size_t __size ) ;
#line 591
extern  __attribute__((__nothrow__)) void abort(void) ;
#line 595
extern  __attribute__((__nothrow__)) int atexit(void (*__func)(void) ) ;
#line 610
extern  __attribute__((__nothrow__)) int on_exit(void (*__func)(int  , void * ) ,
                                                 void *__arg ) ;
#line 617
extern  __attribute__((__nothrow__)) void exit(int __status ) ;
#line 629
extern  __attribute__((__nothrow__)) void _Exit(int __status ) ;
#line 634
extern  __attribute__((__nothrow__)) char *getenv(char const   *__name ) ;
#line 647
extern  __attribute__((__nothrow__)) int putenv(char *__string ) ;
#line 653
extern  __attribute__((__nothrow__)) int setenv(char const   *__name , char const   *__value ,
                                                int __replace ) ;
#line 657
extern  __attribute__((__nothrow__)) int unsetenv(char const   *__name ) ;
#line 664
extern  __attribute__((__nothrow__)) int clearenv(void) ;
#line 675
extern  __attribute__((__nothrow__)) char *mktemp(char *__template ) ;
#line 688
extern int mkstemp(char *__template ) ;
#line 710
extern int mkstemps(char *__template , int __suffixlen ) ;
#line 731
extern  __attribute__((__nothrow__)) char *mkdtemp(char *__template ) ;
#line 784
extern int system(char const   *__command ) ;
#line 800
__inline extern  __attribute__((__nothrow__)) char *realpath(char const   *__name ,
                                                             char *__resolved )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 820
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar )  __attribute__((__gnu_inline__)) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h"
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar )  __attribute__((__gnu_inline__)) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h"
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar ) 
{ 
  size_t __l ;
  size_t __u ;
  size_t __idx ;
  void const   *__p ;
  int __comparison ;
  int __cil_tmp11 ;

  {
#line 27
  __l = (size_t )0;
#line 28
  __u = __nmemb;
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;
#line 29
    if (! (__l < __u)) {
#line 29
      goto while_break;
    }
    {
#line 31
    __idx = (__l + __u) / 2UL;
#line 32
    __p = (void *)((char const   *)__base + __idx * __size);
#line 33
    __comparison = (*__compar)(__key, __p);
    }
#line 34
    if (__comparison < 0) {
#line 35
      __u = __idx;
    } else
#line 36
    if (__comparison > 0) {
#line 37
      __l = __idx + 1UL;
    } else {
#line 39
      return ((void *)__p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 42
  return ((void *)0);
}
}
#line 830 "/usr/include/stdlib.h"
extern void qsort(void *__base , size_t __nmemb , size_t __size , __compar_fn_t __compar ) ;
#line 840
extern  __attribute__((__nothrow__)) int abs(int __x ) ;
#line 841
extern  __attribute__((__nothrow__)) long labs(long __x ) ;
#line 844
extern  __attribute__((__nothrow__)) long long llabs(long long __x ) ;
#line 852
extern  __attribute__((__nothrow__)) div_t div(int __numer , int __denom ) ;
#line 854
extern  __attribute__((__nothrow__)) ldiv_t ldiv(long __numer , long __denom ) ;
#line 858
extern  __attribute__((__nothrow__)) lldiv_t lldiv(long long __numer , long long __denom ) ;
#line 872
extern  __attribute__((__nothrow__)) char *ecvt(double __value , int __ndigit , int *__decpt ,
                                                int *__sign ) ;
#line 878
extern  __attribute__((__nothrow__)) char *fcvt(double __value , int __ndigit , int *__decpt ,
                                                int *__sign ) ;
#line 884
extern  __attribute__((__nothrow__)) char *gcvt(double __value , int __ndigit , char *__buf ) ;
#line 890
extern  __attribute__((__nothrow__)) char *qecvt(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign ) ;
#line 893
extern  __attribute__((__nothrow__)) char *qfcvt(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign ) ;
#line 896
extern  __attribute__((__nothrow__)) char *qgcvt(long double __value , int __ndigit ,
                                                 char *__buf ) ;
#line 902
extern  __attribute__((__nothrow__)) int ecvt_r(double __value , int __ndigit , int *__decpt ,
                                                int *__sign , char *__buf , size_t __len ) ;
#line 905
extern  __attribute__((__nothrow__)) int fcvt_r(double __value , int __ndigit , int *__decpt ,
                                                int *__sign , char *__buf , size_t __len ) ;
#line 909
extern  __attribute__((__nothrow__)) int qecvt_r(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign , char *__buf ,
                                                 size_t __len ) ;
#line 913
extern  __attribute__((__nothrow__)) int qfcvt_r(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign , char *__buf ,
                                                 size_t __len ) ;
#line 922
extern  __attribute__((__nothrow__)) int mblen(char const   *__s , size_t __n ) ;
#line 925
extern  __attribute__((__nothrow__)) int mbtowc(wchar_t *__pwc , char const   *__s ,
                                                size_t __n ) ;
#line 929
__inline extern  __attribute__((__nothrow__)) int wctomb(char *__s , wchar_t __wchar )  __attribute__((__gnu_inline__)) ;
#line 933
__inline extern  __attribute__((__nothrow__)) size_t mbstowcs(wchar_t *__dst , char const   *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 936
__inline extern  __attribute__((__nothrow__)) size_t wcstombs(char *__dst , wchar_t *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 946
extern  __attribute__((__nothrow__)) int rpmatch(char const   *__response ) ;
#line 957
extern  __attribute__((__nothrow__)) int getsubopt(char **__optionp , char * const  *__tokens ,
                                                   char **__valuep ) ;
#line 1003
extern  __attribute__((__nothrow__)) int getloadavg(double __loadavg[] , int __nelem ) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern  __attribute__((__nothrow__)) double atof(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern double atof(char const   *__nptr ) 
{ 
  double __cil_tmp2 ;

  {
  {
#line 27
  __cil_tmp2 = strtod(__nptr, (char **)((void *)0));
  }
#line 27
  return (__cil_tmp2);
}
}
#line 23 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
extern  __attribute__((__nothrow__)) char *__realpath_chk(char const   *__name , char *__resolved ,
                                                          size_t __resolvedlen ) ;
#line 26
extern  __attribute__((__nothrow__)) char *__realpath_alias(char const   *__name ,
                                                            char *__resolved ) ;
#line 29
extern  __attribute__((__nothrow__)) char *__realpath_chk_warn(char const   *__name ,
                                                               char *__resolved ,
                                                               size_t __resolvedlen ) ;
#line 37
__inline extern  __attribute__((__nothrow__)) char *realpath(char const   *__name ,
                                                             char *__resolved )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 37 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern char *realpath(char const   *__name , char *__resolved ) 
{ 
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 39
  __cil_tmp3 = __builtin_object_size(__resolved, 1);
  }
#line 39
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
    {
#line 45
    __cil_tmp4 = __builtin_object_size(__resolved, 1);
#line 45
    __cil_tmp5 = __realpath_chk(__name, __resolved, __cil_tmp4);
    }
#line 45
    return (__cil_tmp5);
  }
  {
#line 48
  __cil_tmp6 = __realpath_alias(__name, __resolved);
  }
#line 48
  return (__cil_tmp6);
}
}
#line 52
extern  __attribute__((__nothrow__)) int __ptsname_r_chk(int __fd , char *__buf ,
                                                         size_t __buflen , size_t __nreal ) ;
#line 54
extern  __attribute__((__nothrow__)) int __ptsname_r_alias(int __fd , char *__buf ,
                                                           size_t __buflen ) ;
#line 57
extern  __attribute__((__nothrow__)) int __ptsname_r_chk_warn(int __fd , char *__buf ,
                                                              size_t __buflen , size_t __nreal ) ;
#line 64
__inline extern  __attribute__((__nothrow__)) int ptsname_r(int __fd , char *__buf ,
                                                            size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 64 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int ptsname_r(int __fd , char *__buf , size_t __buflen ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 66
  __cil_tmp4 = __builtin_object_size(__buf, 1);
  }
#line 66
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 68
    __cil_tmp5 = __builtin_constant_p(__buflen);
    }
#line 68
    if (! __cil_tmp5) {
      {
#line 69
      __cil_tmp6 = __builtin_object_size(__buf, 1);
#line 69
      __cil_tmp7 = __ptsname_r_chk(__fd, __buf, __buflen, __cil_tmp6);
      }
#line 69
      return (__cil_tmp7);
    }
    {
#line 70
    __cil_tmp8 = __builtin_object_size(__buf, 1);
    }
#line 70
    if (__buflen > __cil_tmp8) {
      {
#line 71
      __cil_tmp9 = __builtin_object_size(__buf, 1);
#line 71
      __cil_tmp10 = __ptsname_r_chk_warn(__fd, __buf, __buflen, __cil_tmp9);
      }
#line 71
      return (__cil_tmp10);
    }
  }
  {
#line 73
  __cil_tmp11 = __ptsname_r_alias(__fd, __buf, __buflen);
  }
#line 73
  return (__cil_tmp11);
}
}
#line 77
extern  __attribute__((__nothrow__)) int __wctomb_chk(char *__s , wchar_t __wchar ,
                                                      size_t __buflen ) ;
#line 79
extern  __attribute__((__nothrow__)) int __wctomb_alias(char *__s , wchar_t __wchar ) ;
#line 83
__inline extern  __attribute__((__nothrow__)) int wctomb(char *__s , wchar_t __wchar )  __attribute__((__gnu_inline__)) ;
#line 83 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int wctomb(char *__s , wchar_t __wchar ) 
{ 
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 92
  __cil_tmp4 = __builtin_object_size(__s, 1);
  }
  {
#line 92
  __cil_tmp3 = __builtin_object_size(__s, 1);
  }
#line 92
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
#line 92
    if (16UL > __cil_tmp4) {
      {
#line 93
      __cil_tmp5 = __builtin_object_size(__s, 1);
#line 93
      __cil_tmp6 = __wctomb_chk(__s, __wchar, __cil_tmp5);
      }
#line 93
      return (__cil_tmp6);
    }
  }
  {
#line 94
  __cil_tmp7 = __wctomb_alias(__s, __wchar);
  }
#line 94
  return (__cil_tmp7);
}
}
#line 98
extern  __attribute__((__nothrow__)) size_t __mbstowcs_chk(wchar_t *__dst , char const   *__src ,
                                                           size_t __len , size_t __dstlen ) ;
#line 101
extern  __attribute__((__nothrow__)) size_t __mbstowcs_alias(wchar_t *__dst , char const   *__src ,
                                                             size_t __len ) ;
#line 105
extern  __attribute__((__nothrow__)) size_t __mbstowcs_chk_warn(wchar_t *__dst , char const   *__src ,
                                                                size_t __len , size_t __dstlen ) ;
#line 113
__inline extern  __attribute__((__nothrow__)) size_t mbstowcs(wchar_t *__dst , char const   *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 113 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t mbstowcs(wchar_t *__dst , char const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  size_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;

  {
  {
#line 116
  __cil_tmp4 = __builtin_object_size(__dst, 1);
  }
#line 116
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 118
    __cil_tmp5 = __builtin_constant_p(__len);
    }
#line 118
    if (! __cil_tmp5) {
      {
#line 119
      __cil_tmp6 = __builtin_object_size(__dst, 1);
#line 119
      __cil_tmp7 = __mbstowcs_chk(__dst, __src, __len, __cil_tmp6 / sizeof(wchar_t ));
      }
#line 119
      return (__cil_tmp7);
    }
    {
#line 122
    __cil_tmp8 = __builtin_object_size(__dst, 1);
    }
#line 122
    if (__len > __cil_tmp8 / sizeof(wchar_t )) {
      {
#line 123
      __cil_tmp9 = __builtin_object_size(__dst, 1);
#line 123
      __cil_tmp10 = __mbstowcs_chk_warn(__dst, __src, __len, __cil_tmp9 / sizeof(wchar_t ));
      }
#line 123
      return (__cil_tmp10);
    }
  }
  {
#line 126
  __cil_tmp11 = __mbstowcs_alias(__dst, __src, __len);
  }
#line 126
  return (__cil_tmp11);
}
}
#line 130
extern  __attribute__((__nothrow__)) size_t __wcstombs_chk(char *__dst , wchar_t *__src ,
                                                           size_t __len , size_t __dstlen ) ;
#line 133
extern  __attribute__((__nothrow__)) size_t __wcstombs_alias(char *__dst , wchar_t *__src ,
                                                             size_t __len ) ;
#line 137
extern  __attribute__((__nothrow__)) size_t __wcstombs_chk_warn(char *__dst , wchar_t *__src ,
                                                                size_t __len , size_t __dstlen ) ;
#line 144
__inline extern  __attribute__((__nothrow__)) size_t wcstombs(char *__dst , wchar_t *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 144 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t wcstombs(char *__dst , wchar_t *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  size_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;

  {
  {
#line 147
  __cil_tmp4 = __builtin_object_size(__dst, 1);
  }
#line 147
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 149
    __cil_tmp5 = __builtin_constant_p(__len);
    }
#line 149
    if (! __cil_tmp5) {
      {
#line 150
      __cil_tmp6 = __builtin_object_size(__dst, 1);
#line 150
      __cil_tmp7 = __wcstombs_chk(__dst, __src, __len, __cil_tmp6);
      }
#line 150
      return (__cil_tmp7);
    }
    {
#line 151
    __cil_tmp8 = __builtin_object_size(__dst, 1);
    }
#line 151
    if (__len > __cil_tmp8) {
      {
#line 152
      __cil_tmp9 = __builtin_object_size(__dst, 1);
#line 152
      __cil_tmp10 = __wcstombs_chk_warn(__dst, __src, __len, __cil_tmp9);
      }
#line 152
      return (__cil_tmp10);
    }
  }
  {
#line 154
  __cil_tmp11 = __wcstombs_alias(__dst, __src, __len);
  }
#line 154
  return (__cil_tmp11);
}
}
#line 43 "/usr/include/string.h"
__inline extern  __attribute__((__nothrow__)) void *memcpy(void *__dest , void const   *__src ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 47
__inline extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 54
extern  __attribute__((__nothrow__)) void *memccpy(void *__dest , void const   *__src ,
                                                   int __c , size_t __n ) ;
#line 61
__inline extern  __attribute__((__nothrow__)) void *memset(void *__dest , int __ch ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 64
extern  __attribute__((__nothrow__)) int memcmp(void const   *__s1 , void const   *__s2 ,
                                                size_t __n ) ;
#line 91
extern  __attribute__((__nothrow__)) void *memchr(void const   *__s , int __c , size_t __n ) ;
#line 122
__inline extern  __attribute__((__nothrow__)) char *strcpy(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 125
__inline extern  __attribute__((__nothrow__)) char *strncpy(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 130
__inline extern  __attribute__((__nothrow__)) char *strcat(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 133
__inline extern  __attribute__((__nothrow__)) char *strncat(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 137
extern  __attribute__((__nothrow__)) int strcmp(char const   *__s1 , char const   *__s2 ) ;
#line 140
extern  __attribute__((__nothrow__)) int strncmp(char const   *__s1 , char const   *__s2 ,
                                                 size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int strcoll(char const   *__s1 , char const   *__s2 ) ;
#line 147
extern  __attribute__((__nothrow__)) unsigned long strxfrm(char *__dest , char const   *__src ,
                                                           size_t __n ) ;
#line 156
extern  __attribute__((__nothrow__)) int strcoll_l(char const   *__s1 , char const   *__s2 ,
                                                   locale_t __l ) ;
#line 160
extern  __attribute__((__nothrow__)) size_t strxfrm_l(char *__dest , char const   *__src ,
                                                      size_t __n , locale_t __l ) ;
#line 167
extern  __attribute__((__nothrow__)) char *strdup(char const   *__s ) ;
#line 175
extern  __attribute__((__nothrow__)) char *strndup(char const   *__string , size_t __n ) ;
#line 226
extern  __attribute__((__nothrow__)) char *strchr(char const   *__s , int __c ) ;
#line 253
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c ) ;
#line 273
extern  __attribute__((__nothrow__)) unsigned long strcspn(char const   *__s , char const   *__reject ) ;
#line 277
extern  __attribute__((__nothrow__)) unsigned long strspn(char const   *__s , char const   *__accept ) ;
#line 303
extern  __attribute__((__nothrow__)) char *strpbrk(char const   *__s , char const   *__accept ) ;
#line 330
extern  __attribute__((__nothrow__)) char *strstr(char const   *__haystack , char const   *__needle ) ;
#line 336
extern  __attribute__((__nothrow__)) char *strtok(char *__s , char const   *__delim ) ;
#line 341
extern  __attribute__((__nothrow__)) char *__strtok_r(char *__s , char const   *__delim ,
                                                      char **__save_ptr ) ;
#line 346
extern  __attribute__((__nothrow__)) char *strtok_r(char *__s , char const   *__delim ,
                                                    char **__save_ptr ) ;
#line 385
extern  __attribute__((__nothrow__)) unsigned long strlen(char const   *__s ) ;
#line 391
extern  __attribute__((__nothrow__)) size_t strnlen(char const   *__string , size_t __maxlen ) ;
#line 397
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 410
extern  __attribute__((__nothrow__)) int strerror_r(int __errnum , char *__buf , size_t __buflen ) ;
#line 428
extern  __attribute__((__nothrow__)) char *strerror_l(int __errnum , locale_t __l ) ;
#line 34 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) int bcmp(void const   *__s1 , void const   *__s2 ,
                                              size_t __n ) ;
#line 38
__inline extern  __attribute__((__nothrow__)) void bcopy(void const   *__src , void *__dest ,
                                                         size_t __len )  __attribute__((__gnu_inline__)) ;
#line 42
__inline extern  __attribute__((__nothrow__)) void bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 68
extern  __attribute__((__nothrow__)) char *index(char const   *__s , int __c ) ;
#line 96
extern  __attribute__((__nothrow__)) char *rindex(char const   *__s , int __c ) ;
#line 104
extern  __attribute__((__nothrow__)) int ffs(int __i ) ;
#line 110
extern  __attribute__((__nothrow__)) int ffsl(long __l ) ;
#line 111
extern  __attribute__((__nothrow__)) int ffsll(long long __ll ) ;
#line 116
extern  __attribute__((__nothrow__)) int strcasecmp(char const   *__s1 , char const   *__s2 ) ;
#line 120
extern  __attribute__((__nothrow__)) int strncasecmp(char const   *__s1 , char const   *__s2 ,
                                                     size_t __n ) ;
#line 128
extern  __attribute__((__nothrow__)) int strcasecmp_l(char const   *__s1 , char const   *__s2 ,
                                                      locale_t __loc ) ;
#line 133
extern  __attribute__((__nothrow__)) int strncasecmp_l(char const   *__s1 , char const   *__s2 ,
                                                       size_t __n , locale_t __loc ) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern  __attribute__((__nothrow__)) void bcopy(void const   *__src , void *__dest ,
                                                         size_t __len )  __attribute__((__gnu_inline__)) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern void bcopy(void const   *__src , void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;

  {
  {
#line 25
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 25
  __builtin___memmove_chk(__dest, __src, __len, __cil_tmp4);
  }
  return;
}
}
#line 29
__inline extern  __attribute__((__nothrow__)) void bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 29 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern void bzero(void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp3 ;

  {
  {
#line 31
  __cil_tmp3 = __builtin_object_size(__dest, 0);
#line 31
  __builtin___memset_chk(__dest, '\000', __len, __cil_tmp3);
  }
  return;
}
}
#line 436 "/usr/include/string.h"
__inline extern  __attribute__((__nothrow__)) void explicit_bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 440
extern  __attribute__((__nothrow__)) char *strsep(char **__stringp , char const   *__delim ) ;
#line 447
extern  __attribute__((__nothrow__)) char *strsignal(int __sig ) ;
#line 450
extern  __attribute__((__nothrow__)) char *__stpcpy(char *__dest , char const   *__src ) ;
#line 452
extern  __attribute__((__nothrow__)) char *stpcpy(char *__dest , char const   *__src ) ;
#line 457
extern  __attribute__((__nothrow__)) char *__stpncpy(char *__dest , char const   *__src ,
                                                     size_t __n ) ;
#line 460
__inline extern  __attribute__((__nothrow__)) char *stpncpy(char *__dest , char const   *__src ,
                                                            size_t __n )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 31 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern  __attribute__((__nothrow__)) void *memcpy(void *__dest , void const   *__src ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 31 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *memcpy(void *__dest , void const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 34
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 34
  __cil_tmp5 = __builtin___memcpy_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 34
  return (__cil_tmp5);
}
}
#line 38
__inline extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 38 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *memmove(void *__dest , void const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 40
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 40
  __cil_tmp5 = __builtin___memmove_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 40
  return (__cil_tmp5);
}
}
#line 59
__inline extern  __attribute__((__nothrow__)) void *memset(void *__dest , int __ch ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 59 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *memset(void *__dest , int __ch , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 71
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 71
  __cil_tmp5 = __builtin___memset_chk(__dest, __ch, __len, __cil_tmp4);
  }
#line 71
  return (__cil_tmp5);
}
}
#line 77
 __attribute__((__nothrow__)) void __explicit_bzero_chk(void *__dest , size_t __len ,
                                                        size_t __destlen ) ;
#line 81
__inline extern  __attribute__((__nothrow__)) void explicit_bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 81 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void explicit_bzero(void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp3 ;

  {
  {
#line 83
  __cil_tmp3 = __builtin_object_size(__dest, 0);
#line 83
  __explicit_bzero_chk(__dest, __len, __cil_tmp3);
  }
  return;
}
}
#line 88
__inline extern  __attribute__((__nothrow__)) char *strcpy(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 88 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strcpy(char *__dest , char const   *__src ) 
{ 
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 90
  __cil_tmp3 = __builtin_object_size(__dest, 1);
#line 90
  __cil_tmp4 = __builtin___strcpy_chk(__dest, __src, __cil_tmp3);
  }
#line 90
  return (__cil_tmp4);
}
}
#line 103
__inline extern  __attribute__((__nothrow__)) char *strncpy(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 103 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strncpy(char *__dest , char const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 106
  __cil_tmp4 = __builtin_object_size(__dest, 1);
#line 106
  __cil_tmp5 = __builtin___strncpy_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 106
  return (__cil_tmp5);
}
}
#line 110
extern  __attribute__((__nothrow__)) char *__stpncpy_chk(char *__dest , char const   *__src ,
                                                         size_t __n , size_t __destlen ) ;
#line 112
extern  __attribute__((__nothrow__)) char *__stpncpy_alias(char *__dest , char const   *__src ,
                                                           size_t __n ) ;
#line 116
__inline extern  __attribute__((__nothrow__)) char *stpncpy(char *__dest , char const   *__src ,
                                                            size_t __n )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 116 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *stpncpy(char *__dest , char const   *__src , size_t __n ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 118
  __cil_tmp6 = __builtin_object_size(__dest, 1);
  }
  {
#line 118
  __cil_tmp5 = __builtin_constant_p(__n);
  }
  {
#line 118
  __cil_tmp4 = __builtin_object_size(__dest, 1);
  }
#line 118
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 118
    if (! __cil_tmp5) {
      {
      {
#line 120
      __cil_tmp7 = __builtin_object_size(__dest, 1);
      }
      {
#line 120
      __cil_tmp8 = __stpncpy_chk(__dest, __src, __n, __cil_tmp7);
      }
      }
#line 120
      return (__cil_tmp8);
    } else
#line 118
    if (__n > __cil_tmp6) {
      {
      {
#line 120
      __cil_tmp7 = __builtin_object_size(__dest, 1);
      }
      {
#line 120
      __cil_tmp8 = __stpncpy_chk(__dest, __src, __n, __cil_tmp7);
      }
      }
#line 120
      return (__cil_tmp8);
    }
  }
  {
#line 121
  __cil_tmp9 = __stpncpy_alias(__dest, __src, __n);
  }
#line 121
  return (__cil_tmp9);
}
}
#line 126
__inline extern  __attribute__((__nothrow__)) char *strcat(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 126 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strcat(char *__dest , char const   *__src ) 
{ 
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 128
  __cil_tmp3 = __builtin_object_size(__dest, 1);
#line 128
  __cil_tmp4 = __builtin___strcat_chk(__dest, __src, __cil_tmp3);
  }
#line 128
  return (__cil_tmp4);
}
}
#line 133
__inline extern  __attribute__((__nothrow__)) char *strncat(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 133 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strncat(char *__dest , char const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 136
  __cil_tmp4 = __builtin_object_size(__dest, 1);
#line 136
  __cil_tmp5 = __builtin___strncat_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 136
  return (__cil_tmp5);
}
}
#line 18 "/root/libsndfile/src/GSM610/gsm_create.c"
gsm gsm_create(void) 
{ 
  gsm r ;
  void *__cil_tmp2 ;

  {
  {
#line 22
  r = (gsm )malloc(sizeof(struct gsm_state ));
  }
#line 23
  if (! r) {
#line 23
    return (r);
  }
  {
#line 25
  memset((char *)r, 0, sizeof(struct gsm_state ));
#line 26
  r->nrp = (word )40;
  }
#line 28
  return (r);
}
}
#line 32 "/root/libsndfile/src/GSM610/gsm_create.c"
void gsm_init(gsm state ) 
{ 


  {
  {
#line 34
  memset(state, 0, sizeof(struct gsm_state ));
#line 35
  state->nrp = (word )40;
  }
  return;
}
}
#line 15 "/root/libsndfile/src/GSM610/decode.c"
static void Postprocessing(struct gsm_state *S , word *s ) 
{ 
  register int k ;
  register word msr ;
  register word tmp ;
  int __cil_tmp6 ;
  longword __cil_tmp7 ;
  longword __cil_tmp8 ;
  longword __cil_tmp9 ;
  word *__cil_tmp10 ;

  {
#line 20
  msr = S->msr;
#line 23
  k = 160;
  {
#line 23
  while (1) {
    while_continue: /* CIL Label */ ;
#line 23
    if (! __cil_tmp6) {
#line 23
      goto while_break;
    }
    {
#line 24
    __cil_tmp7 = GSM_MULT_R(msr, (word )28180);
#line 24
    tmp = (word )__cil_tmp7;
#line 25
    __cil_tmp8 = GSM_ADD(*s, tmp);
#line 25
    msr = (word )__cil_tmp8;
#line 26
    __cil_tmp9 = GSM_ADD(msr, msr);
#line 26
    *s = (word )(__cil_tmp9 & 65528);
    }
#line 23
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 28
  S->msr = msr;
  return;
}
}
#line 31 "/root/libsndfile/src/GSM610/decode.c"
void Gsm_Decoder(struct gsm_state *S , word *LARcr , word *Ncr , word *bcr , word *Mcr ,
                 word *xmaxcr , word *xMcr , word *s ) 
{ 
  int j ;
  int k ;
  word erp[40] ;
  word wt[160] ;
  word *drp ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  word *__cil_tmp16 ;
  word *__cil_tmp17 ;
  word *__cil_tmp18 ;
  word *__cil_tmp19 ;

  {
#line 46
  drp = (word *)S->dp0 + 120;
#line 48
  j = 0;
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! (j <= 3)) {
#line 48
      goto while_break;
    }
    {
#line 50
    Gsm_RPE_Decoding(*xmaxcr, *Mcr, xMcr, (word *)erp);
#line 51
    Gsm_Long_Term_Synthesis_Filtering(S, *Ncr, *bcr, (word *)erp, drp);
#line 53
    k = 0;
    }
    {
#line 53
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 53
      if (! (k <= 39)) {
#line 53
        goto while_break___0;
      }
#line 53
      wt[j * 40 + k] = *(drp + k);
#line 53
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 48
    xMcr += 13;
#line 48
    __cil_tmp19 = Mcr;
#line 48
    Mcr ++;
#line 48
    __cil_tmp18 = Ncr;
#line 48
    Ncr ++;
#line 48
    __cil_tmp17 = bcr;
#line 48
    bcr ++;
#line 48
    __cil_tmp16 = xmaxcr;
#line 48
    xmaxcr ++;
#line 48
    __cil_tmp15 = j;
#line 48
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 56
  Gsm_Short_Term_Synthesis_Filter(S, LARcr, (word *)wt, s);
#line 57
  Postprocessing(S, s);
  }
  return;
}
}
#line 17 "/root/libsndfile/src/GSM610/code.c"
void Gsm_Coder(struct gsm_state *State , word *s , word *LARc , word *Nc , word *bc ,
               word *Mc , word *xmaxc , word *xMc ) 
{ 
  int k ;
  word *dp ;
  word *dpp ;
  word so[160] ;
  word *__cil_tmp13 ;
  word *__cil_tmp14 ;
  word *__cil_tmp15 ;
  word *__cil_tmp16 ;
  register int i ;
  longword __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;

  {
  {
#line 49
  dp = (word *)State->dp0 + 120;
#line 50
  dpp = dp;
#line 54
  Gsm_Preprocess(State, s, (word *)so);
#line 55
  Gsm_LPC_Analysis(State, (word *)so, LARc);
#line 56
  Gsm_Short_Term_Analysis_Filter(State, LARc, (word *)so);
#line 58
  k = 0;
  }
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
#line 58
    if (! (k <= 3)) {
#line 58
      goto while_break;
    }
#line 60
    __cil_tmp13 = Nc;
#line 60
    Nc ++;
    {
#line 60
    __cil_tmp14 = bc;
#line 60
    bc ++;
#line 60
    Gsm_Long_Term_Predictor(State, (word *)so + k * 40, dp, (word *)State->e + 5,
                            dpp, __cil_tmp13, __cil_tmp14);
#line 68
    __cil_tmp15 = xmaxc;
#line 68
    xmaxc ++;
    }
    {
#line 68
    __cil_tmp16 = Mc;
#line 68
    Mc ++;
#line 68
    Gsm_RPE_Encoding((word *)State->e + 5, __cil_tmp15, __cil_tmp16, xMc);
#line 77
    i = 0;
    }
    {
#line 77
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 77
      if (! (i <= 39)) {
#line 77
        goto while_break___0;
      }
      {
#line 78
      __cil_tmp18 = GSM_ADD(State->e[5 + i], *(dpp + i));
#line 78
      *(dp + i) = (word )__cil_tmp18;
      }
#line 77
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 80
    dp += 40;
#line 81
    dpp += 40;
#line 58
    xMc += 13;
#line 58
    __cil_tmp20 = k;
#line 58
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 84
  memcpy((char *)((word *)State->dp0), (char *)((word *)State->dp0 + 160), 120UL * sizeof(*((word *)State->dp0)));
  }
  return;
}
}
#line 19 "/root/libsndfile/src/GSM610/add.c"
word gsm_add(word a , word b ) 
{ 
  longword sum ;
  int tmp ;
  int tmp___0 ;

  {
#line 21
  sum = (longword )a + (longword )b;
#line 22
  if (sum < -32768) {
#line 22
    tmp___0 = -32768;
  } else {
#line 22
    if (sum > 32767) {
#line 22
      tmp = 32767;
    } else {
#line 22
      tmp = sum;
    }
#line 22
    tmp___0 = tmp;
  }
#line 22
  return ((word )tmp___0);
}
}
#line 25 "/root/libsndfile/src/GSM610/add.c"
word gsm_sub(word a , word b ) 
{ 
  longword diff ;
  int tmp ;
  int tmp___0 ;

  {
#line 27
  diff = (longword )a - (longword )b;
#line 28
  if (diff < -32768) {
#line 28
    tmp___0 = -32768;
  } else {
#line 28
    if (diff > 32767) {
#line 28
      tmp = 32767;
    } else {
#line 28
      tmp = diff;
    }
#line 28
    tmp___0 = tmp;
  }
#line 28
  return ((word )tmp___0);
}
}
#line 31 "/root/libsndfile/src/GSM610/add.c"
word gsm_mult(word a , word b ) 
{ 
  longword __cil_tmp3 ;

  {
#line 33
  if ((int )a == -32768) {
#line 33
    if ((int )b == -32768) {
#line 34
      return ((word )32767);
    }
  }
  {
#line 36
  __cil_tmp3 = SASR_L((longword )a * (longword )b, (word )15);
  }
#line 36
  return ((word )__cil_tmp3);
}
}
#line 39 "/root/libsndfile/src/GSM610/add.c"
word gsm_mult_r(word a , word b ) 
{ 
  longword prod ;

  {
#line 41
  if ((int )b == -32768) {
#line 41
    if ((int )a == -32768) {
#line 41
      return ((word )32767);
    } else {
#line 43
      prod = (longword )a * (longword )b + 16384;
#line 44
      prod >>= 15;
#line 45
      return ((word )(prod & 65535));
    }
  } else {
#line 43
    prod = (longword )a * (longword )b + 16384;
#line 44
    prod >>= 15;
#line 45
    return ((word )(prod & 65535));
  }
}
}
#line 49 "/root/libsndfile/src/GSM610/add.c"
word gsm_abs(word a ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 51
  if ((int )a < 0) {
#line 51
    if ((int )a == -32768) {
#line 51
      tmp = 32767;
    } else {
#line 51
      tmp = - ((int )a);
    }
#line 51
    tmp___0 = tmp;
  } else {
#line 51
    tmp___0 = (int )a;
  }
#line 51
  return ((word )tmp___0);
}
}
#line 54 "/root/libsndfile/src/GSM610/add.c"
longword gsm_L_mult(word a , word b ) 
{ 
  int tmp ;

  {
#line 57
  return ((longword )a * (longword )b << 1);
}
}
#line 60 "/root/libsndfile/src/GSM610/add.c"
longword gsm_L_add(longword a , longword b ) 
{ 
  ulongword A ;
  int tmp ;
  ulongword A___0 ;
  unsigned int tmp___0 ;

  {
#line 62
  if (a < 0) {
#line 63
    if (b >= 0) {
#line 63
      return (a + b);
    } else {
#line 65
      A = (ulongword )(- (a + 1)) + (ulongword )(- (b + 1));
#line 66
      if (A >= 2147483647U) {
#line 66
        tmp = (-0x7FFFFFFF-1);
      } else {
#line 66
        tmp = - ((longword )A) - 2;
      }
#line 66
      return (tmp);
    }
  } else
#line 69
  if (b <= 0) {
#line 69
    return (a + b);
  } else {
#line 71
    A___0 = (ulongword )a + (ulongword )b;
#line 72
    if (A___0 > 2147483647U) {
#line 72
      tmp___0 = (unsigned int )2147483647;
    } else {
#line 72
      tmp___0 = A___0;
    }
#line 72
    return ((longword )tmp___0);
  }
}
}
#line 76 "/root/libsndfile/src/GSM610/add.c"
longword gsm_L_sub(longword a , longword b ) 
{ 
  ulongword A ;
  unsigned int tmp ;
  ulongword A___0 ;
  int tmp___0 ;

  {
#line 78
  if (a >= 0) {
#line 79
    if (b >= 0) {
#line 79
      return (a - b);
    } else {
#line 83
      A = (ulongword )a + (unsigned int )(- (b + 1));
#line 84
      if (A >= 2147483647U) {
#line 84
        tmp = (unsigned int )2147483647;
      } else {
#line 84
        tmp = A + 1U;
      }
#line 84
      return ((longword )tmp);
    }
  } else
#line 87
  if (b <= 0) {
#line 87
    return (a - b);
  } else {
#line 91
    A___0 = (ulongword )(- (a + 1)) + (unsigned int )b;
#line 92
    if (A___0 >= 2147483647U) {
#line 92
      tmp___0 = (-0x7FFFFFFF-1);
    } else {
#line 92
      tmp___0 = - ((longword )A___0) - 1;
    }
#line 92
    return (tmp___0);
  }
}
}
#line 96 "/root/libsndfile/src/GSM610/add.c"
static unsigned char const   bitoff[256]  = 
#line 96
  {      (unsigned char )8,      (unsigned char )7,      (unsigned char )6,      (unsigned char )6, 
        (unsigned char )5,      (unsigned char )5,      (unsigned char )5,      (unsigned char )5, 
        (unsigned char )4,      (unsigned char )4,      (unsigned char )4,      (unsigned char )4, 
        (unsigned char )4,      (unsigned char )4,      (unsigned char )4,      (unsigned char )4, 
        (unsigned char )3,      (unsigned char )3,      (unsigned char )3,      (unsigned char )3, 
        (unsigned char )3,      (unsigned char )3,      (unsigned char )3,      (unsigned char )3, 
        (unsigned char )3,      (unsigned char )3,      (unsigned char )3,      (unsigned char )3, 
        (unsigned char )3,      (unsigned char )3,      (unsigned char )3,      (unsigned char )3, 
        (unsigned char )2,      (unsigned char )2,      (unsigned char )2,      (unsigned char )2, 
        (unsigned char )2,      (unsigned char )2,      (unsigned char )2,      (unsigned char )2, 
        (unsigned char )2,      (unsigned char )2,      (unsigned char )2,      (unsigned char )2, 
        (unsigned char )2,      (unsigned char )2,      (unsigned char )2,      (unsigned char )2, 
        (unsigned char )2,      (unsigned char )2,      (unsigned char )2,      (unsigned char )2, 
        (unsigned char )2,      (unsigned char )2,      (unsigned char )2,      (unsigned char )2, 
        (unsigned char )2,      (unsigned char )2,      (unsigned char )2,      (unsigned char )2, 
        (unsigned char )2,      (unsigned char )2,      (unsigned char )2,      (unsigned char )2, 
        (unsigned char )1,      (unsigned char )1,      (unsigned char )1,      (unsigned char )1, 
        (unsigned char )1,      (unsigned char )1,      (unsigned char )1,      (unsigned char )1, 
        (unsigned char )1,      (unsigned char )1,      (unsigned char )1,      (unsigned char )1, 
        (unsigned char )1,      (unsigned char )1,      (unsigned char )1,      (unsigned char )1, 
        (unsigned char )1,      (unsigned char )1,      (unsigned char )1,      (unsigned char )1, 
        (unsigned char )1,      (unsigned char )1,      (unsigned char )1,      (unsigned char )1, 
        (unsigned char )1,      (unsigned char )1,      (unsigned char )1,      (unsigned char )1, 
        (unsigned char )1,      (unsigned char )1,      (unsigned char )1,      (unsigned char )1, 
        (unsigned char )1,      (unsigned char )1,      (unsigned char )1,      (unsigned char )1, 
        (unsigned char )1,      (unsigned char )1,      (unsigned char )1,      (unsigned char )1, 
        (unsigned char )1,      (unsigned char )1,      (unsigned char )1,      (unsigned char )1, 
        (unsigned char )1,      (unsigned char )1,      (unsigned char )1,      (unsigned char )1, 
        (unsigned char )1,      (unsigned char )1,      (unsigned char )1,      (unsigned char )1, 
        (unsigned char )1,      (unsigned char )1,      (unsigned char )1,      (unsigned char )1, 
        (unsigned char )1,      (unsigned char )1,      (unsigned char )1,      (unsigned char )1, 
        (unsigned char )1,      (unsigned char )1,      (unsigned char )1,      (unsigned char )1, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0};
#line 115 "/root/libsndfile/src/GSM610/add.c"
word gsm_norm(longword a ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 137
  if (a < 0) {
#line 138
    if (a <= -1073741824) {
#line 138
      return ((word )0);
    }
#line 139
    a = ~ a;
  }
#line 142
  if ((unsigned int )a & 4294901760U) {
#line 142
    if ((unsigned int )a & 4278190080U) {
#line 142
      tmp___0 = -1 + (int )bitoff[255 & (a >> 24)];
    } else {
#line 142
      tmp___0 = 7 + (int )bitoff[255 & (a >> 16)];
    }
#line 142
    tmp___2 = tmp___0;
  } else {
#line 142
    if (a & 65280) {
#line 142
      tmp___1 = 15 + (int )bitoff[255 & (a >> 8)];
    } else {
#line 142
      tmp___1 = 23 + (int )bitoff[255 & a];
    }
#line 142
    tmp___2 = tmp___1;
  }
#line 142
  return ((word )tmp___2);
}
}
#line 151 "/root/libsndfile/src/GSM610/add.c"
longword gsm_L_asl(longword a , int n ) 
{ 
  longword __cil_tmp3 ;

  {
#line 153
  if (n >= 32) {
#line 153
    return (0);
  }
#line 154
  if (n <= -32) {
#line 154
    return (- (a < 0));
  }
#line 155
  if (n < 0) {
    {
#line 155
    __cil_tmp3 = gsm_L_asr(a, - n);
    }
#line 155
    return (__cil_tmp3);
  }
#line 156
  return (a << n);
}
}
#line 159 "/root/libsndfile/src/GSM610/add.c"
word gsm_asr(word a , int n ) 
{ 
  word __cil_tmp3 ;

  {
#line 161
  if (n >= 16) {
#line 161
    return ((word )(- ((int )a < 0)));
  }
#line 162
  if (n <= -16) {
#line 162
    return ((word )0);
  }
#line 163
  if (n < 0) {
#line 163
    return ((word )((int )a << - n));
  }
  {
#line 165
  __cil_tmp3 = SASR_W(a, (word )n);
  }
#line 165
  return (__cil_tmp3);
}
}
#line 168 "/root/libsndfile/src/GSM610/add.c"
word gsm_asl(word a , int n ) 
{ 
  word __cil_tmp3 ;

  {
#line 170
  if (n >= 16) {
#line 170
    return ((word )0);
  }
#line 171
  if (n <= -16) {
#line 171
    return ((word )(- ((int )a < 0)));
  }
#line 172
  if (n < 0) {
    {
#line 172
    __cil_tmp3 = gsm_asr(a, - n);
    }
#line 172
    return (__cil_tmp3);
  }
#line 173
  return ((word )((int )a << n));
}
}
#line 176 "/root/libsndfile/src/GSM610/add.c"
longword gsm_L_asr(longword a , int n ) 
{ 
  longword __cil_tmp3 ;

  {
#line 178
  if (n >= 32) {
#line 178
    return (- (a < 0));
  }
#line 179
  if (n <= -32) {
#line 179
    return (0);
  }
#line 180
  if (n < 0) {
#line 180
    return (a << - n);
  }
  {
#line 182
  __cil_tmp3 = SASR_L(a, (word )n);
  }
#line 182
  return (__cil_tmp3);
}
}
#line 210 "/root/libsndfile/src/GSM610/add.c"
word gsm_div(word num , word denum ) 
{ 
  longword L_num ;
  longword L_denum ;
  word div___0 ;
  int k ;
  int tmp ;
  int __cil_tmp8 ;
  word __cil_tmp9 ;

  {
#line 212
  L_num = (longword )num;
#line 213
  L_denum = (longword )denum;
#line 214
  div___0 = (word )0;
#line 215
  k = 15;
#line 225
  if ((int )num == 0) {
#line 226
    return ((word )0);
  }
  {
#line 228
  while (1) {
    while_continue: /* CIL Label */ ;
#line 228
    __cil_tmp8 = k;
#line 228
    k --;
#line 228
    if (! __cil_tmp8) {
#line 228
      goto while_break;
    }
#line 229
    div___0 <<= 1;
#line 230
    L_num <<= 1;
#line 232
    if (L_num >= L_denum) {
#line 233
      L_num -= L_denum;
#line 234
      div___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 238
  return (div___0);
}
}
#line 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassify(double __value ) ;
#line 25
extern  __attribute__((__nothrow__)) int __signbit(double __value ) ;
#line 30
extern  __attribute__((__nothrow__)) int __isinf(double __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finite(double __value ) ;
#line 36
extern  __attribute__((__nothrow__)) int __isnan(double __value ) ;
#line 39
extern  __attribute__((__nothrow__)) int __iseqsig(double __x , double __y ) ;
#line 42
extern  __attribute__((__nothrow__)) int __issignaling(double __value ) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double acos(double __x ) ;
#line 53
extern  __attribute__((__nothrow__)) double __acos(double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) double asin(double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) double __asin(double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) double atan(double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) double __atan(double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) double atan2(double __y , double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) double __atan2(double __y , double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) double cos(double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) double __cos(double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) double sin(double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) double __sin(double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) double tan(double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) double __tan(double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) double cosh(double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) double __cosh(double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) double sinh(double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) double __sinh(double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) double tanh(double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) double __tanh(double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) double acosh(double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) double __acosh(double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) double asinh(double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) double __asinh(double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) double atanh(double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) double __atanh(double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) double exp(double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) double __exp(double __x ) ;
#line 98
extern  __attribute__((__nothrow__)) double frexp(double __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) double __frexp(double __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) double ldexp(double __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) double __ldexp(double __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) double log(double __x ) ;
#line 104
extern  __attribute__((__nothrow__)) double __log(double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) double log10(double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) double __log10(double __x ) ;
#line 110
extern  __attribute__((__nothrow__)) double modf(double __x , double *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) double __modf(double __x , double *__iptr ) ;
#line 119
extern  __attribute__((__nothrow__)) double expm1(double __x ) ;
#line 119
extern  __attribute__((__nothrow__)) double __expm1(double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) double log1p(double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) double __log1p(double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) double logb(double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) double __logb(double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) double exp2(double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) double __exp2(double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) double log2(double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) double __log2(double __x ) ;
#line 140
extern  __attribute__((__nothrow__)) double pow(double __x , double __y ) ;
#line 140
extern  __attribute__((__nothrow__)) double __pow(double __x , double __y ) ;
#line 143
extern  __attribute__((__nothrow__)) double sqrt(double __x ) ;
#line 143
extern  __attribute__((__nothrow__)) double __sqrt(double __x ) ;
#line 147
extern  __attribute__((__nothrow__)) double hypot(double __x , double __y ) ;
#line 147
extern  __attribute__((__nothrow__)) double __hypot(double __x , double __y ) ;
#line 152
extern  __attribute__((__nothrow__)) double cbrt(double __x ) ;
#line 152
extern  __attribute__((__nothrow__)) double __cbrt(double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) double ceil(double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) double __ceil(double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) double fabs(double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) double __fabs(double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) double floor(double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) double __floor(double __x ) ;
#line 168
extern  __attribute__((__nothrow__)) double fmod(double __x , double __y ) ;
#line 168
extern  __attribute__((__nothrow__)) double __fmod(double __x , double __y ) ;
#line 177
extern  __attribute__((__nothrow__)) int isinf(double __value ) ;
#line 182
extern  __attribute__((__nothrow__)) int finite(double __value ) ;
#line 185
extern  __attribute__((__nothrow__)) double drem(double __x , double __y ) ;
#line 185
extern  __attribute__((__nothrow__)) double __drem(double __x , double __y ) ;
#line 189
extern  __attribute__((__nothrow__)) double significand(double __x ) ;
#line 189
extern  __attribute__((__nothrow__)) double __significand(double __x ) ;
#line 196
extern  __attribute__((__nothrow__)) double copysign(double __x , double __y ) ;
#line 196
extern  __attribute__((__nothrow__)) double __copysign(double __x , double __y ) ;
#line 201
extern  __attribute__((__nothrow__)) double nan(char const   *__tagb ) ;
#line 201
extern  __attribute__((__nothrow__)) double __nan(char const   *__tagb ) ;
#line 211
extern  __attribute__((__nothrow__)) int isnan(double __value ) ;
#line 217
extern  __attribute__((__nothrow__)) double j0(double  ) ;
#line 217
extern  __attribute__((__nothrow__)) double __j0(double  ) ;
#line 218
extern  __attribute__((__nothrow__)) double j1(double  ) ;
#line 218
extern  __attribute__((__nothrow__)) double __j1(double  ) ;
#line 219
extern  __attribute__((__nothrow__)) double jn(int  , double  ) ;
#line 219
extern  __attribute__((__nothrow__)) double __jn(int  , double  ) ;
#line 220
extern  __attribute__((__nothrow__)) double y0(double  ) ;
#line 220
extern  __attribute__((__nothrow__)) double __y0(double  ) ;
#line 221
extern  __attribute__((__nothrow__)) double y1(double  ) ;
#line 221
extern  __attribute__((__nothrow__)) double __y1(double  ) ;
#line 222
extern  __attribute__((__nothrow__)) double yn(int  , double  ) ;
#line 222
extern  __attribute__((__nothrow__)) double __yn(int  , double  ) ;
#line 228
extern  __attribute__((__nothrow__)) double erf(double  ) ;
#line 228
extern  __attribute__((__nothrow__)) double __erf(double  ) ;
#line 229
extern  __attribute__((__nothrow__)) double erfc(double  ) ;
#line 229
extern  __attribute__((__nothrow__)) double __erfc(double  ) ;
#line 230
extern  __attribute__((__nothrow__)) double lgamma(double  ) ;
#line 230
extern  __attribute__((__nothrow__)) double __lgamma(double  ) ;
#line 235
extern  __attribute__((__nothrow__)) double tgamma(double  ) ;
#line 235
extern  __attribute__((__nothrow__)) double __tgamma(double  ) ;
#line 241
extern  __attribute__((__nothrow__)) double gamma(double  ) ;
#line 241
extern  __attribute__((__nothrow__)) double __gamma(double  ) ;
#line 249
extern  __attribute__((__nothrow__)) double lgamma_r(double  , int *__signgamp ) ;
#line 249
extern  __attribute__((__nothrow__)) double __lgamma_r(double  , int *__signgamp ) ;
#line 256
extern  __attribute__((__nothrow__)) double rint(double __x ) ;
#line 256
extern  __attribute__((__nothrow__)) double __rint(double __x ) ;
#line 259
extern  __attribute__((__nothrow__)) double nextafter(double __x , double __y ) ;
#line 259
extern  __attribute__((__nothrow__)) double __nextafter(double __x , double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) double nexttoward(double __x , long double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) double __nexttoward(double __x , long double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) double remainder(double __x , double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) double __remainder(double __x , double __y ) ;
#line 276
extern  __attribute__((__nothrow__)) double scalbn(double __x , int __n ) ;
#line 276
extern  __attribute__((__nothrow__)) double __scalbn(double __x , int __n ) ;
#line 280
extern  __attribute__((__nothrow__)) int ilogb(double __x ) ;
#line 280
extern  __attribute__((__nothrow__)) int __ilogb(double __x ) ;
#line 290
extern  __attribute__((__nothrow__)) double scalbln(double __x , long __n ) ;
#line 290
extern  __attribute__((__nothrow__)) double __scalbln(double __x , long __n ) ;
#line 294
extern  __attribute__((__nothrow__)) double nearbyint(double __x ) ;
#line 294
extern  __attribute__((__nothrow__)) double __nearbyint(double __x ) ;
#line 298
extern  __attribute__((__nothrow__)) double round(double __x ) ;
#line 298
extern  __attribute__((__nothrow__)) double __round(double __x ) ;
#line 302
extern  __attribute__((__nothrow__)) double trunc(double __x ) ;
#line 302
extern  __attribute__((__nothrow__)) double __trunc(double __x ) ;
#line 307
extern  __attribute__((__nothrow__)) double remquo(double __x , double __y , int *__quo ) ;
#line 307
extern  __attribute__((__nothrow__)) double __remquo(double __x , double __y , int *__quo ) ;
#line 314
extern  __attribute__((__nothrow__)) long lrint(double __x ) ;
#line 314
extern  __attribute__((__nothrow__)) long __lrint(double __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long llrint(double __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long __llrint(double __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long lround(double __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long __lround(double __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long llround(double __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long __llround(double __x ) ;
#line 326
extern  __attribute__((__nothrow__)) double fdim(double __x , double __y ) ;
#line 326
extern  __attribute__((__nothrow__)) double __fdim(double __x , double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) double fmax(double __x , double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) double __fmax(double __x , double __y ) ;
#line 332
extern  __attribute__((__nothrow__)) double fmin(double __x , double __y ) ;
#line 332
extern  __attribute__((__nothrow__)) double __fmin(double __x , double __y ) ;
#line 335
extern  __attribute__((__nothrow__)) double fma(double __x , double __y , double __z ) ;
#line 335
extern  __attribute__((__nothrow__)) double __fma(double __x , double __y , double __z ) ;
#line 400
extern  __attribute__((__nothrow__)) double scalb(double __x , double __n ) ;
#line 400
extern  __attribute__((__nothrow__)) double __scalb(double __x , double __n ) ;
#line 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassifyf(float __value ) ;
#line 25
extern  __attribute__((__nothrow__)) int __signbitf(float __value ) ;
#line 30
extern  __attribute__((__nothrow__)) int __isinff(float __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finitef(float __value ) ;
#line 36
extern  __attribute__((__nothrow__)) int __isnanf(float __value ) ;
#line 39
extern  __attribute__((__nothrow__)) int __iseqsigf(float __x , float __y ) ;
#line 42
extern  __attribute__((__nothrow__)) int __issignalingf(float __value ) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) float acosf(float __x ) ;
#line 53
extern  __attribute__((__nothrow__)) float __acosf(float __x ) ;
#line 55
extern  __attribute__((__nothrow__)) float asinf(float __x ) ;
#line 55
extern  __attribute__((__nothrow__)) float __asinf(float __x ) ;
#line 57
extern  __attribute__((__nothrow__)) float atanf(float __x ) ;
#line 57
extern  __attribute__((__nothrow__)) float __atanf(float __x ) ;
#line 59
extern  __attribute__((__nothrow__)) float atan2f(float __y , float __x ) ;
#line 59
extern  __attribute__((__nothrow__)) float __atan2f(float __y , float __x ) ;
#line 62
extern  __attribute__((__nothrow__)) float cosf(float __x ) ;
#line 62
extern  __attribute__((__nothrow__)) float __cosf(float __x ) ;
#line 64
extern  __attribute__((__nothrow__)) float sinf(float __x ) ;
#line 64
extern  __attribute__((__nothrow__)) float __sinf(float __x ) ;
#line 66
extern  __attribute__((__nothrow__)) float tanf(float __x ) ;
#line 66
extern  __attribute__((__nothrow__)) float __tanf(float __x ) ;
#line 71
extern  __attribute__((__nothrow__)) float coshf(float __x ) ;
#line 71
extern  __attribute__((__nothrow__)) float __coshf(float __x ) ;
#line 73
extern  __attribute__((__nothrow__)) float sinhf(float __x ) ;
#line 73
extern  __attribute__((__nothrow__)) float __sinhf(float __x ) ;
#line 75
extern  __attribute__((__nothrow__)) float tanhf(float __x ) ;
#line 75
extern  __attribute__((__nothrow__)) float __tanhf(float __x ) ;
#line 85
extern  __attribute__((__nothrow__)) float acoshf(float __x ) ;
#line 85
extern  __attribute__((__nothrow__)) float __acoshf(float __x ) ;
#line 87
extern  __attribute__((__nothrow__)) float asinhf(float __x ) ;
#line 87
extern  __attribute__((__nothrow__)) float __asinhf(float __x ) ;
#line 89
extern  __attribute__((__nothrow__)) float atanhf(float __x ) ;
#line 89
extern  __attribute__((__nothrow__)) float __atanhf(float __x ) ;
#line 95
extern  __attribute__((__nothrow__)) float expf(float __x ) ;
#line 95
extern  __attribute__((__nothrow__)) float __expf(float __x ) ;
#line 98
extern  __attribute__((__nothrow__)) float frexpf(float __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) float __frexpf(float __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) float ldexpf(float __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) float __ldexpf(float __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) float logf(float __x ) ;
#line 104
extern  __attribute__((__nothrow__)) float __logf(float __x ) ;
#line 107
extern  __attribute__((__nothrow__)) float log10f(float __x ) ;
#line 107
extern  __attribute__((__nothrow__)) float __log10f(float __x ) ;
#line 110
extern  __attribute__((__nothrow__)) float modff(float __x , float *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) float __modff(float __x , float *__iptr ) ;
#line 119
extern  __attribute__((__nothrow__)) float expm1f(float __x ) ;
#line 119
extern  __attribute__((__nothrow__)) float __expm1f(float __x ) ;
#line 122
extern  __attribute__((__nothrow__)) float log1pf(float __x ) ;
#line 122
extern  __attribute__((__nothrow__)) float __log1pf(float __x ) ;
#line 125
extern  __attribute__((__nothrow__)) float logbf(float __x ) ;
#line 125
extern  __attribute__((__nothrow__)) float __logbf(float __x ) ;
#line 130
extern  __attribute__((__nothrow__)) float exp2f(float __x ) ;
#line 130
extern  __attribute__((__nothrow__)) float __exp2f(float __x ) ;
#line 133
extern  __attribute__((__nothrow__)) float log2f(float __x ) ;
#line 133
extern  __attribute__((__nothrow__)) float __log2f(float __x ) ;
#line 140
extern  __attribute__((__nothrow__)) float powf(float __x , float __y ) ;
#line 140
extern  __attribute__((__nothrow__)) float __powf(float __x , float __y ) ;
#line 143
extern  __attribute__((__nothrow__)) float sqrtf(float __x ) ;
#line 143
extern  __attribute__((__nothrow__)) float __sqrtf(float __x ) ;
#line 147
extern  __attribute__((__nothrow__)) float hypotf(float __x , float __y ) ;
#line 147
extern  __attribute__((__nothrow__)) float __hypotf(float __x , float __y ) ;
#line 152
extern  __attribute__((__nothrow__)) float cbrtf(float __x ) ;
#line 152
extern  __attribute__((__nothrow__)) float __cbrtf(float __x ) ;
#line 159
extern  __attribute__((__nothrow__)) float ceilf(float __x ) ;
#line 159
extern  __attribute__((__nothrow__)) float __ceilf(float __x ) ;
#line 162
extern  __attribute__((__nothrow__)) float fabsf(float __x ) ;
#line 162
extern  __attribute__((__nothrow__)) float __fabsf(float __x ) ;
#line 165
extern  __attribute__((__nothrow__)) float floorf(float __x ) ;
#line 165
extern  __attribute__((__nothrow__)) float __floorf(float __x ) ;
#line 168
extern  __attribute__((__nothrow__)) float fmodf(float __x , float __y ) ;
#line 168
extern  __attribute__((__nothrow__)) float __fmodf(float __x , float __y ) ;
#line 177
extern  __attribute__((__nothrow__)) int isinff(float __value ) ;
#line 182
extern  __attribute__((__nothrow__)) int finitef(float __value ) ;
#line 185
extern  __attribute__((__nothrow__)) float dremf(float __x , float __y ) ;
#line 185
extern  __attribute__((__nothrow__)) float __dremf(float __x , float __y ) ;
#line 189
extern  __attribute__((__nothrow__)) float significandf(float __x ) ;
#line 189
extern  __attribute__((__nothrow__)) float __significandf(float __x ) ;
#line 196
extern  __attribute__((__nothrow__)) float copysignf(float __x , float __y ) ;
#line 196
extern  __attribute__((__nothrow__)) float __copysignf(float __x , float __y ) ;
#line 201
extern  __attribute__((__nothrow__)) float nanf(char const   *__tagb ) ;
#line 201
extern  __attribute__((__nothrow__)) float __nanf(char const   *__tagb ) ;
#line 211
extern  __attribute__((__nothrow__)) int isnanf(float __value ) ;
#line 217
extern  __attribute__((__nothrow__)) float j0f(float  ) ;
#line 217
extern  __attribute__((__nothrow__)) float __j0f(float  ) ;
#line 218
extern  __attribute__((__nothrow__)) float j1f(float  ) ;
#line 218
extern  __attribute__((__nothrow__)) float __j1f(float  ) ;
#line 219
extern  __attribute__((__nothrow__)) float jnf(int  , float  ) ;
#line 219
extern  __attribute__((__nothrow__)) float __jnf(int  , float  ) ;
#line 220
extern  __attribute__((__nothrow__)) float y0f(float  ) ;
#line 220
extern  __attribute__((__nothrow__)) float __y0f(float  ) ;
#line 221
extern  __attribute__((__nothrow__)) float y1f(float  ) ;
#line 221
extern  __attribute__((__nothrow__)) float __y1f(float  ) ;
#line 222
extern  __attribute__((__nothrow__)) float ynf(int  , float  ) ;
#line 222
extern  __attribute__((__nothrow__)) float __ynf(int  , float  ) ;
#line 228
extern  __attribute__((__nothrow__)) float erff(float  ) ;
#line 228
extern  __attribute__((__nothrow__)) float __erff(float  ) ;
#line 229
extern  __attribute__((__nothrow__)) float erfcf(float  ) ;
#line 229
extern  __attribute__((__nothrow__)) float __erfcf(float  ) ;
#line 230
extern  __attribute__((__nothrow__)) float lgammaf(float  ) ;
#line 230
extern  __attribute__((__nothrow__)) float __lgammaf(float  ) ;
#line 235
extern  __attribute__((__nothrow__)) float tgammaf(float  ) ;
#line 235
extern  __attribute__((__nothrow__)) float __tgammaf(float  ) ;
#line 241
extern  __attribute__((__nothrow__)) float gammaf(float  ) ;
#line 241
extern  __attribute__((__nothrow__)) float __gammaf(float  ) ;
#line 249
extern  __attribute__((__nothrow__)) float lgammaf_r(float  , int *__signgamp ) ;
#line 249
extern  __attribute__((__nothrow__)) float __lgammaf_r(float  , int *__signgamp ) ;
#line 256
extern  __attribute__((__nothrow__)) float rintf(float __x ) ;
#line 256
extern  __attribute__((__nothrow__)) float __rintf(float __x ) ;
#line 259
extern  __attribute__((__nothrow__)) float nextafterf(float __x , float __y ) ;
#line 259
extern  __attribute__((__nothrow__)) float __nextafterf(float __x , float __y ) ;
#line 261
extern  __attribute__((__nothrow__)) float nexttowardf(float __x , long double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) float __nexttowardf(float __x , long double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) float remainderf(float __x , float __y ) ;
#line 272
extern  __attribute__((__nothrow__)) float __remainderf(float __x , float __y ) ;
#line 276
extern  __attribute__((__nothrow__)) float scalbnf(float __x , int __n ) ;
#line 276
extern  __attribute__((__nothrow__)) float __scalbnf(float __x , int __n ) ;
#line 280
extern  __attribute__((__nothrow__)) int ilogbf(float __x ) ;
#line 280
extern  __attribute__((__nothrow__)) int __ilogbf(float __x ) ;
#line 290
extern  __attribute__((__nothrow__)) float scalblnf(float __x , long __n ) ;
#line 290
extern  __attribute__((__nothrow__)) float __scalblnf(float __x , long __n ) ;
#line 294
extern  __attribute__((__nothrow__)) float nearbyintf(float __x ) ;
#line 294
extern  __attribute__((__nothrow__)) float __nearbyintf(float __x ) ;
#line 298
extern  __attribute__((__nothrow__)) float roundf(float __x ) ;
#line 298
extern  __attribute__((__nothrow__)) float __roundf(float __x ) ;
#line 302
extern  __attribute__((__nothrow__)) float truncf(float __x ) ;
#line 302
extern  __attribute__((__nothrow__)) float __truncf(float __x ) ;
#line 307
extern  __attribute__((__nothrow__)) float remquof(float __x , float __y , int *__quo ) ;
#line 307
extern  __attribute__((__nothrow__)) float __remquof(float __x , float __y , int *__quo ) ;
#line 314
extern  __attribute__((__nothrow__)) long lrintf(float __x ) ;
#line 314
extern  __attribute__((__nothrow__)) long __lrintf(float __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long llrintf(float __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long __llrintf(float __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long lroundf(float __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long __lroundf(float __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long llroundf(float __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long __llroundf(float __x ) ;
#line 326
extern  __attribute__((__nothrow__)) float fdimf(float __x , float __y ) ;
#line 326
extern  __attribute__((__nothrow__)) float __fdimf(float __x , float __y ) ;
#line 329
extern  __attribute__((__nothrow__)) float fmaxf(float __x , float __y ) ;
#line 329
extern  __attribute__((__nothrow__)) float __fmaxf(float __x , float __y ) ;
#line 332
extern  __attribute__((__nothrow__)) float fminf(float __x , float __y ) ;
#line 332
extern  __attribute__((__nothrow__)) float __fminf(float __x , float __y ) ;
#line 335
extern  __attribute__((__nothrow__)) float fmaf(float __x , float __y , float __z ) ;
#line 335
extern  __attribute__((__nothrow__)) float __fmaf(float __x , float __y , float __z ) ;
#line 400
extern  __attribute__((__nothrow__)) float scalbf(float __x , float __n ) ;
#line 400
extern  __attribute__((__nothrow__)) float __scalbf(float __x , float __n ) ;
#line 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassifyl(long double __value ) ;
#line 25
extern  __attribute__((__nothrow__)) int __signbitl(long double __value ) ;
#line 30
extern  __attribute__((__nothrow__)) int __isinfl(long double __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finitel(long double __value ) ;
#line 36
extern  __attribute__((__nothrow__)) int __isnanl(long double __value ) ;
#line 39
extern  __attribute__((__nothrow__)) int __iseqsigl(long double __x , long double __y ) ;
#line 42
extern  __attribute__((__nothrow__)) int __issignalingl(long double __value ) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) long double acosl(long double __x ) ;
#line 53
extern  __attribute__((__nothrow__)) long double __acosl(long double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) long double asinl(long double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) long double __asinl(long double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) long double atanl(long double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) long double __atanl(long double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) long double atan2l(long double __y , long double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) long double __atan2l(long double __y , long double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) long double cosl(long double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) long double __cosl(long double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) long double sinl(long double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) long double __sinl(long double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) long double tanl(long double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) long double __tanl(long double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) long double coshl(long double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) long double __coshl(long double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) long double sinhl(long double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) long double __sinhl(long double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) long double tanhl(long double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) long double __tanhl(long double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) long double acoshl(long double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) long double __acoshl(long double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) long double asinhl(long double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) long double __asinhl(long double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) long double atanhl(long double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) long double __atanhl(long double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) long double expl(long double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) long double __expl(long double __x ) ;
#line 98
extern  __attribute__((__nothrow__)) long double frexpl(long double __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) long double __frexpl(long double __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) long double ldexpl(long double __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) long double __ldexpl(long double __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) long double logl(long double __x ) ;
#line 104
extern  __attribute__((__nothrow__)) long double __logl(long double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) long double log10l(long double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) long double __log10l(long double __x ) ;
#line 110
extern  __attribute__((__nothrow__)) long double modfl(long double __x , long double *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) long double __modfl(long double __x , long double *__iptr ) ;
#line 119
extern  __attribute__((__nothrow__)) long double expm1l(long double __x ) ;
#line 119
extern  __attribute__((__nothrow__)) long double __expm1l(long double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) long double log1pl(long double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) long double __log1pl(long double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) long double logbl(long double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) long double __logbl(long double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) long double exp2l(long double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) long double __exp2l(long double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) long double log2l(long double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) long double __log2l(long double __x ) ;
#line 140
extern  __attribute__((__nothrow__)) long double powl(long double __x , long double __y ) ;
#line 140
extern  __attribute__((__nothrow__)) long double __powl(long double __x , long double __y ) ;
#line 143
extern  __attribute__((__nothrow__)) long double sqrtl(long double __x ) ;
#line 143
extern  __attribute__((__nothrow__)) long double __sqrtl(long double __x ) ;
#line 147
extern  __attribute__((__nothrow__)) long double hypotl(long double __x , long double __y ) ;
#line 147
extern  __attribute__((__nothrow__)) long double __hypotl(long double __x , long double __y ) ;
#line 152
extern  __attribute__((__nothrow__)) long double cbrtl(long double __x ) ;
#line 152
extern  __attribute__((__nothrow__)) long double __cbrtl(long double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) long double ceill(long double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) long double __ceill(long double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) long double fabsl(long double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) long double __fabsl(long double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) long double floorl(long double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) long double __floorl(long double __x ) ;
#line 168
extern  __attribute__((__nothrow__)) long double fmodl(long double __x , long double __y ) ;
#line 168
extern  __attribute__((__nothrow__)) long double __fmodl(long double __x , long double __y ) ;
#line 177
extern  __attribute__((__nothrow__)) int isinfl(long double __value ) ;
#line 182
extern  __attribute__((__nothrow__)) int finitel(long double __value ) ;
#line 185
extern  __attribute__((__nothrow__)) long double dreml(long double __x , long double __y ) ;
#line 185
extern  __attribute__((__nothrow__)) long double __dreml(long double __x , long double __y ) ;
#line 189
extern  __attribute__((__nothrow__)) long double significandl(long double __x ) ;
#line 189
extern  __attribute__((__nothrow__)) long double __significandl(long double __x ) ;
#line 196
extern  __attribute__((__nothrow__)) long double copysignl(long double __x , long double __y ) ;
#line 196
extern  __attribute__((__nothrow__)) long double __copysignl(long double __x , long double __y ) ;
#line 201
extern  __attribute__((__nothrow__)) long double nanl(char const   *__tagb ) ;
#line 201
extern  __attribute__((__nothrow__)) long double __nanl(char const   *__tagb ) ;
#line 211
extern  __attribute__((__nothrow__)) int isnanl(long double __value ) ;
#line 217
extern  __attribute__((__nothrow__)) long double j0l(long double  ) ;
#line 217
extern  __attribute__((__nothrow__)) long double __j0l(long double  ) ;
#line 218
extern  __attribute__((__nothrow__)) long double j1l(long double  ) ;
#line 218
extern  __attribute__((__nothrow__)) long double __j1l(long double  ) ;
#line 219
extern  __attribute__((__nothrow__)) long double jnl(int  , long double  ) ;
#line 219
extern  __attribute__((__nothrow__)) long double __jnl(int  , long double  ) ;
#line 220
extern  __attribute__((__nothrow__)) long double y0l(long double  ) ;
#line 220
extern  __attribute__((__nothrow__)) long double __y0l(long double  ) ;
#line 221
extern  __attribute__((__nothrow__)) long double y1l(long double  ) ;
#line 221
extern  __attribute__((__nothrow__)) long double __y1l(long double  ) ;
#line 222
extern  __attribute__((__nothrow__)) long double ynl(int  , long double  ) ;
#line 222
extern  __attribute__((__nothrow__)) long double __ynl(int  , long double  ) ;
#line 228
extern  __attribute__((__nothrow__)) long double erfl(long double  ) ;
#line 228
extern  __attribute__((__nothrow__)) long double __erfl(long double  ) ;
#line 229
extern  __attribute__((__nothrow__)) long double erfcl(long double  ) ;
#line 229
extern  __attribute__((__nothrow__)) long double __erfcl(long double  ) ;
#line 230
extern  __attribute__((__nothrow__)) long double lgammal(long double  ) ;
#line 230
extern  __attribute__((__nothrow__)) long double __lgammal(long double  ) ;
#line 235
extern  __attribute__((__nothrow__)) long double tgammal(long double  ) ;
#line 235
extern  __attribute__((__nothrow__)) long double __tgammal(long double  ) ;
#line 241
extern  __attribute__((__nothrow__)) long double gammal(long double  ) ;
#line 241
extern  __attribute__((__nothrow__)) long double __gammal(long double  ) ;
#line 249
extern  __attribute__((__nothrow__)) long double lgammal_r(long double  , int *__signgamp ) ;
#line 249
extern  __attribute__((__nothrow__)) long double __lgammal_r(long double  , int *__signgamp ) ;
#line 256
extern  __attribute__((__nothrow__)) long double rintl(long double __x ) ;
#line 256
extern  __attribute__((__nothrow__)) long double __rintl(long double __x ) ;
#line 259
extern  __attribute__((__nothrow__)) long double nextafterl(long double __x , long double __y ) ;
#line 259
extern  __attribute__((__nothrow__)) long double __nextafterl(long double __x , long double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) long double nexttowardl(long double __x , long double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) long double __nexttowardl(long double __x , long double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) long double remainderl(long double __x , long double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) long double __remainderl(long double __x , long double __y ) ;
#line 276
extern  __attribute__((__nothrow__)) long double scalbnl(long double __x , int __n ) ;
#line 276
extern  __attribute__((__nothrow__)) long double __scalbnl(long double __x , int __n ) ;
#line 280
extern  __attribute__((__nothrow__)) int ilogbl(long double __x ) ;
#line 280
extern  __attribute__((__nothrow__)) int __ilogbl(long double __x ) ;
#line 290
extern  __attribute__((__nothrow__)) long double scalblnl(long double __x , long __n ) ;
#line 290
extern  __attribute__((__nothrow__)) long double __scalblnl(long double __x , long __n ) ;
#line 294
extern  __attribute__((__nothrow__)) long double nearbyintl(long double __x ) ;
#line 294
extern  __attribute__((__nothrow__)) long double __nearbyintl(long double __x ) ;
#line 298
extern  __attribute__((__nothrow__)) long double roundl(long double __x ) ;
#line 298
extern  __attribute__((__nothrow__)) long double __roundl(long double __x ) ;
#line 302
extern  __attribute__((__nothrow__)) long double truncl(long double __x ) ;
#line 302
extern  __attribute__((__nothrow__)) long double __truncl(long double __x ) ;
#line 307
extern  __attribute__((__nothrow__)) long double remquol(long double __x , long double __y ,
                                                         int *__quo ) ;
#line 307
extern  __attribute__((__nothrow__)) long double __remquol(long double __x , long double __y ,
                                                           int *__quo ) ;
#line 314
extern  __attribute__((__nothrow__)) long lrintl(long double __x ) ;
#line 314
extern  __attribute__((__nothrow__)) long __lrintl(long double __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long llrintl(long double __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long __llrintl(long double __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long lroundl(long double __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long __lroundl(long double __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long llroundl(long double __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long __llroundl(long double __x ) ;
#line 326
extern  __attribute__((__nothrow__)) long double fdiml(long double __x , long double __y ) ;
#line 326
extern  __attribute__((__nothrow__)) long double __fdiml(long double __x , long double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) long double fmaxl(long double __x , long double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) long double __fmaxl(long double __x , long double __y ) ;
#line 332
extern  __attribute__((__nothrow__)) long double fminl(long double __x , long double __y ) ;
#line 332
extern  __attribute__((__nothrow__)) long double __fminl(long double __x , long double __y ) ;
#line 335
extern  __attribute__((__nothrow__)) long double fmal(long double __x , long double __y ,
                                                      long double __z ) ;
#line 335
extern  __attribute__((__nothrow__)) long double __fmal(long double __x , long double __y ,
                                                        long double __z ) ;
#line 400
extern  __attribute__((__nothrow__)) long double scalbl(long double __x , long double __n ) ;
#line 400
extern  __attribute__((__nothrow__)) long double __scalbl(long double __x , long double __n ) ;
#line 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassifyf128(int __value ) ;
#line 25
extern  __attribute__((__nothrow__)) int __signbitf128(int __value ) ;
#line 30
extern  __attribute__((__nothrow__)) int __isinff128(int __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finitef128(int __value ) ;
#line 36
extern  __attribute__((__nothrow__)) int __isnanf128(int __value ) ;
#line 39
extern  __attribute__((__nothrow__)) int __iseqsigf128(int __x , int __y ) ;
#line 42
extern  __attribute__((__nothrow__)) int __issignalingf128(int __value ) ;
#line 773 "/usr/include/math.h"
extern int signgam ;
#line 474 "/root/libsndfile/src/sndfile.h"
SNDFILE *sf_open(char const   *path , int mode , SF_INFO *sfinfo ) ;
#line 488
SNDFILE *sf_open_fd(int fd , int mode , SF_INFO *sfinfo , int close_desc ) ;
#line 490
SNDFILE *sf_open_virtual(SF_VIRTUAL_IO *sfvirtual , int mode , SF_INFO *sfinfo , void *user_data ) ;
#line 496
int sf_error(SNDFILE *sndfile ) ;
#line 502
char const   *sf_strerror(SNDFILE *sndfile ) ;
#line 509
char const   *sf_error_number(int errnum ) ;
#line 516
int sf_perror(SNDFILE *sndfile ) ;
#line 517
int sf_error_str(SNDFILE *sndfile , char *str , size_t maxlen ) ;
#line 522
int sf_command(SNDFILE *sndfile , int command , void *data___0 , int datasize ) ;
#line 526
int sf_format_check(SF_INFO *info ) ;
#line 540
sf_count_t sf_seek(SNDFILE *sndfile , sf_count_t offset , int whence ) ;
#line 550
int sf_set_string(SNDFILE *sndfile , int str_type , char const   *str ) ;
#line 552
char const   *sf_get_string(SNDFILE *sndfile , int str_type ) ;
#line 556
char const   *sf_version_string(void) ;
#line 561
sf_count_t sf_read_raw(SNDFILE *sndfile , void *ptr , sf_count_t bytes ) ;
#line 562
sf_count_t sf_write_raw(SNDFILE *sndfile , void const   *ptr , sf_count_t len ) ;
#line 574
sf_count_t sf_readf_short(SNDFILE *sndfile , short *ptr , sf_count_t frames ) ;
#line 575
sf_count_t sf_writef_short(SNDFILE *sndfile , short const   *ptr , sf_count_t frames ) ;
#line 577
sf_count_t sf_readf_int(SNDFILE *sndfile , int *ptr , sf_count_t frames ) ;
#line 578
sf_count_t sf_writef_int(SNDFILE *sndfile , int const   *ptr , sf_count_t frames ) ;
#line 580
sf_count_t sf_readf_float(SNDFILE *sndfile , float *ptr , sf_count_t frames ) ;
#line 581
sf_count_t sf_writef_float(SNDFILE *sndfile , float const   *ptr , sf_count_t frames ) ;
#line 583
sf_count_t sf_readf_double(SNDFILE *sndfile , double *ptr , sf_count_t frames ) ;
#line 584
sf_count_t sf_writef_double(SNDFILE *sndfile , double const   *ptr , sf_count_t frames ) ;
#line 591
sf_count_t sf_read_short(SNDFILE *sndfile , short *ptr , sf_count_t len ) ;
#line 592
sf_count_t sf_write_short(SNDFILE *sndfile , short const   *ptr , sf_count_t len ) ;
#line 594
sf_count_t sf_read_int(SNDFILE *sndfile , int *ptr , sf_count_t len ) ;
#line 595
sf_count_t sf_write_int(SNDFILE *sndfile , int const   *ptr , sf_count_t len ) ;
#line 597
sf_count_t sf_read_float(SNDFILE *sndfile , float *ptr , sf_count_t len ) ;
#line 598
sf_count_t sf_write_float(SNDFILE *sndfile , float const   *ptr , sf_count_t len ) ;
#line 600
sf_count_t sf_read_double(SNDFILE *sndfile , double *ptr , sf_count_t len ) ;
#line 601
sf_count_t sf_write_double(SNDFILE *sndfile , double const   *ptr , sf_count_t len ) ;
#line 608
int sf_close(SNDFILE *sndfile ) ;
#line 615
void sf_write_sync(SNDFILE *sndfile ) ;
#line 113 "/root/libsndfile/src/sfendian.h"
__inline static void endswap_short_array(short *ptr , int len ) 
{ 
  short temp ;
  __uint16_t __cil_tmp4 ;

  {
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    len --;
#line 116
    if (! (len >= 0)) {
#line 116
      goto while_break;
    }
    {
#line 117
    temp = *(ptr + len);
#line 118
    __cil_tmp4 = __bswap_16((__uint16_t )temp);
#line 118
    *(ptr + len) = (short )__cil_tmp4;
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 123 "/root/libsndfile/src/sfendian.h"
__inline static void endswap_short_copy(short *dest , short const   *src , int len ) 
{ 
  __uint16_t __cil_tmp4 ;

  {
  {
#line 125
  while (1) {
    while_continue: /* CIL Label */ ;
#line 125
    len --;
#line 125
    if (! (len >= 0)) {
#line 125
      goto while_break;
    }
    {
#line 126
    __cil_tmp4 = __bswap_16((__uint16_t )*(src + len));
#line 126
    *(dest + len) = (short )__cil_tmp4;
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 131 "/root/libsndfile/src/sfendian.h"
__inline static void endswap_int_array(int *ptr , int len ) 
{ 
  int temp ;
  __uint32_t __cil_tmp4 ;

  {
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;
#line 134
    len --;
#line 134
    if (! (len >= 0)) {
#line 134
      goto while_break;
    }
    {
#line 135
    temp = *(ptr + len);
#line 136
    __cil_tmp4 = __bswap_32((__uint32_t )temp);
#line 136
    *(ptr + len) = (int )__cil_tmp4;
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 141 "/root/libsndfile/src/sfendian.h"
__inline static void endswap_int_copy(int *dest , int const   *src , int len ) 
{ 
  __uint32_t __cil_tmp4 ;

  {
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    len --;
#line 143
    if (! (len >= 0)) {
#line 143
      goto while_break;
    }
    {
#line 144
    __cil_tmp4 = __bswap_32((__uint32_t )*(src + len));
#line 144
    *(dest + len) = (int )__cil_tmp4;
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 154 "/root/libsndfile/src/sfendian.h"
__inline static void endswap_int64_t_array(int64_t *ptr , int len ) 
{ 
  int64_t value ;
  __uint64_t __cil_tmp4 ;

  {
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;
#line 157
    len --;
#line 157
    if (! (len >= 0)) {
#line 157
      goto while_break;
    }
    {
#line 158
    value = *(ptr + len);
#line 159
    __cil_tmp4 = __bswap_64((__uint64_t )value);
#line 159
    *(ptr + len) = (int64_t )__cil_tmp4;
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 164 "/root/libsndfile/src/sfendian.h"
__inline static void endswap_int64_t_copy(int64_t *dest , int64_t *src , int len ) 
{ 
  int64_t value ;
  __uint64_t __cil_tmp5 ;

  {
  {
#line 167
  while (1) {
    while_continue: /* CIL Label */ ;
#line 167
    len --;
#line 167
    if (! (len >= 0)) {
#line 167
      goto while_break;
    }
    {
#line 168
    value = *(src + len);
#line 169
    __cil_tmp5 = __bswap_64((__uint64_t )value);
#line 169
    *(dest + len) = (int64_t )__cil_tmp5;
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 234 "/root/libsndfile/src/sfendian.h"
__inline static void endswap_float_array(float *ptr , int len ) 
{ 


  {
  {
#line 235
  endswap_int_array((void *)ptr, len);
  }
  return;
}
}
#line 239 "/root/libsndfile/src/sfendian.h"
__inline static void endswap_double_array(double *ptr , int len ) 
{ 


  {
  {
#line 240
  endswap_int64_t_array((void *)ptr, len);
  }
  return;
}
}
#line 244 "/root/libsndfile/src/sfendian.h"
__inline static void endswap_float_copy(float *dest , float const   *src , int len ) 
{ 


  {
  {
#line 245
  endswap_int_copy((int *)dest, (int const   *)src, len);
  }
  return;
}
}
#line 249 "/root/libsndfile/src/sfendian.h"
__inline static void endswap_double_copy(double *dest , double const   *src , int len ) 
{ 


  {
  {
#line 250
  endswap_int64_t_copy((int64_t *)dest, (int64_t *)src, len);
  }
  return;
}
}
#line 207 "/root/libsndfile/src/common.h"
__inline static PEAK_INFO *peak_info_calloc(int channels ) 
{ 
  void *__cil_tmp2 ;

  {
  {
#line 208
  __cil_tmp2 = calloc((unsigned long )1, sizeof(PEAK_INFO ) + (unsigned long )channels * sizeof(PEAK_POS ));
  }
#line 208
  return (__cil_tmp2);
}
}
#line 218 "/root/libsndfile/src/common.h"
__inline static size_t make_size_t(int x ) 
{ 


  {
#line 219
  return ((size_t )x);
}
}
#line 596
int subformat_to_bytewidth(int format ) ;
#line 597
int s_bitwidth_to_subformat(int bits ) ;
#line 598
int u_bitwidth_to_subformat(int bits ) ;
#line 603
float float32_be_read(unsigned char *cptr ) ;
#line 604
float float32_le_read(unsigned char *cptr ) ;
#line 605
void float32_be_write(float in , unsigned char *out ) ;
#line 606
void float32_le_write(float in , unsigned char *out ) ;
#line 608
double double64_be_read(unsigned char *cptr ) ;
#line 609
double double64_le_read(unsigned char *cptr ) ;
#line 610
void double64_be_write(double in , unsigned char *out ) ;
#line 611
void double64_le_write(double in , unsigned char *out ) ;
#line 615
void psf_log_printf(SF_PRIVATE *psf , char const   *format  , ...) ;
#line 616
void psf_log_SF_INFO(SF_PRIVATE *psf ) ;
#line 618
int32_t psf_rand_int32(void) ;
#line 622
int psf_binheader_writef(SF_PRIVATE *psf , char const   *format  , ...) ;
#line 623
void psf_asciiheader_printf(SF_PRIVATE *psf , char const   *format  , ...) ;
#line 627
int psf_binheader_readf(SF_PRIVATE *psf , char const   *format  , ...) ;
#line 631
void peak_update_short(SF_PRIVATE *psf , short *ptr , size_t items ) ;
#line 632
void peak_update_int(SF_PRIVATE *psf , int *ptr , size_t items ) ;
#line 633
void peak_update_double(SF_PRIVATE *psf , double *ptr , size_t items ) ;
#line 637
int psf_get_format_simple_count(void) ;
#line 638
int psf_get_format_simple(SF_FORMAT_INFO *data___0 ) ;
#line 640
int psf_get_format_info(SF_FORMAT_INFO *data___0 ) ;
#line 642
int psf_get_format_major_count(void) ;
#line 643
int psf_get_format_major(SF_FORMAT_INFO *data___0 ) ;
#line 645
int psf_get_format_subtype_count(void) ;
#line 646
int psf_get_format_subtype(SF_FORMAT_INFO *data___0 ) ;
#line 648
void psf_generate_format_desc(SF_PRIVATE *psf ) ;
#line 650
double psf_calc_signal_max(SF_PRIVATE *psf , int normalize ) ;
#line 651
int psf_calc_max_all_channels(SF_PRIVATE *psf , double *peaks , int normalize ) ;
#line 653
int psf_get_signal_max(SF_PRIVATE *psf , double *peak ) ;
#line 654
int psf_get_max_all_channels(SF_PRIVATE *psf , double *peaks ) ;
#line 658
char const   *psf_get_string(SF_PRIVATE *psf , int str_type ) ;
#line 659
int psf_set_string(SF_PRIVATE *psf , int str_type , char const   *str ) ;
#line 660
int psf_store_string(SF_PRIVATE *psf , int str_type , char const   *str ) ;
#line 661
int psf_location_string_count(SF_PRIVATE *psf , int location ) ;
#line 664
sf_count_t psf_default_seek(SF_PRIVATE *psf , int UNUSED_mode , sf_count_t samples_from_start ) ;
#line 666
int macos_guess_file_type(SF_PRIVATE *psf , char const   *filename ) ;
#line 673
int psf_fopen(SF_PRIVATE *psf , char const   *pathname , int open_mode ) ;
#line 674
int psf_set_stdio(SF_PRIVATE *psf , int mode ) ;
#line 675
int psf_file_valid(SF_PRIVATE *psf ) ;
#line 676
void psf_set_file(SF_PRIVATE *psf , int fd ) ;
#line 677
void psf_init_files(SF_PRIVATE *psf ) ;
#line 678
void psf_use_rsrc(SF_PRIVATE *psf , int on_off ) ;
#line 680
sf_count_t psf_fseek(SF_PRIVATE *psf , sf_count_t offset , int whence ) ;
#line 681
sf_count_t psf_fread(void *ptr , sf_count_t bytes , sf_count_t items , SF_PRIVATE *psf ) ;
#line 682
sf_count_t psf_fwrite(void const   *ptr , sf_count_t bytes , sf_count_t items , SF_PRIVATE *psf ) ;
#line 683
sf_count_t psf_fgets(char *buffer , sf_count_t bufsize , SF_PRIVATE *psf ) ;
#line 684
sf_count_t psf_ftell(SF_PRIVATE *psf ) ;
#line 685
sf_count_t psf_get_filelen(SF_PRIVATE *psf ) ;
#line 687
void psf_fsync(SF_PRIVATE *psf ) ;
#line 689
int psf_is_pipe(SF_PRIVATE *psf ) ;
#line 691
int psf_ftruncate(SF_PRIVATE *psf , sf_count_t len ) ;
#line 692
int psf_fclose(SF_PRIVATE *psf ) ;
#line 695
int psf_open_rsrc(SF_PRIVATE *psf , int open_mode ) ;
#line 696
int psf_close_rsrc(SF_PRIVATE *psf ) ;
#line 707
int aiff_open(SF_PRIVATE *psf ) ;
#line 708
int au_open(SF_PRIVATE *psf ) ;
#line 709
int avr_open(SF_PRIVATE *psf ) ;
#line 710
int htk_open(SF_PRIVATE *psf ) ;
#line 711
int ircam_open(SF_PRIVATE *psf ) ;
#line 712
int mat4_open(SF_PRIVATE *psf ) ;
#line 713
int mat5_open(SF_PRIVATE *psf ) ;
#line 714
int nist_open(SF_PRIVATE *psf ) ;
#line 715
int paf_open(SF_PRIVATE *psf ) ;
#line 716
int pvf_open(SF_PRIVATE *psf ) ;
#line 717
int raw_open(SF_PRIVATE *psf ) ;
#line 718
int sd2_open(SF_PRIVATE *psf ) ;
#line 719
int sds_open(SF_PRIVATE *psf ) ;
#line 720
int svx_open(SF_PRIVATE *psf ) ;
#line 721
int voc_open(SF_PRIVATE *psf ) ;
#line 722
int w64_open(SF_PRIVATE *psf ) ;
#line 723
int wav_open(SF_PRIVATE *psf ) ;
#line 724
int xi_open(SF_PRIVATE *psf ) ;
#line 725
int flac_open(SF_PRIVATE *psf ) ;
#line 726
int caf_open(SF_PRIVATE *psf ) ;
#line 727
int mpc2k_open(SF_PRIVATE *psf ) ;
#line 728
int rf64_open(SF_PRIVATE *psf ) ;
#line 732
int mpeg_open(SF_PRIVATE *psf ) ;
#line 733
int ogg_open(SF_PRIVATE *psf ) ;
#line 734
int rx2_open(SF_PRIVATE *psf ) ;
#line 735
int txw_open(SF_PRIVATE *psf ) ;
#line 736
int wve_open(SF_PRIVATE *psf ) ;
#line 737
int dwd_open(SF_PRIVATE *psf ) ;
#line 739
int macbinary3_open(SF_PRIVATE *UNUSED_psf ) ;
#line 745
int pcm_init(SF_PRIVATE *psf ) ;
#line 746
int ulaw_init(SF_PRIVATE *psf ) ;
#line 747
int alaw_init(SF_PRIVATE *psf ) ;
#line 748
int float32_init(SF_PRIVATE *psf ) ;
#line 749
int double64_init(SF_PRIVATE *psf ) ;
#line 750
int dwvw_init(SF_PRIVATE *psf , int bitwidth ) ;
#line 751
int gsm610_init(SF_PRIVATE *psf ) ;
#line 752
int vox_adpcm_init(SF_PRIVATE *psf ) ;
#line 753
int flac_init(SF_PRIVATE *psf ) ;
#line 754
int g72x_init(SF_PRIVATE *psf ) ;
#line 756
int dither_init(SF_PRIVATE *psf , int mode ) ;
#line 758
int wav_w64_ima_init(SF_PRIVATE *psf , int blockalign , int samplesperblock ) ;
#line 759
int wav_w64_msadpcm_init(SF_PRIVATE *psf , int blockalign , int samplesperblock ) ;
#line 761
int aiff_ima_init(SF_PRIVATE *psf , int blockalign , int samplesperblock ) ;
#line 763
int interleave_init(SF_PRIVATE *psf ) ;
#line 779
void pchk4_store(PRIV_CHUNK4 *pchk , int marker , sf_count_t offset , sf_count_t len ) ;
#line 780
int pchk4_find(PRIV_CHUNK4 *pchk , int marker ) ;
#line 786
void *psf_memset(void *s , int c , sf_count_t len ) ;
#line 788
SF_INSTRUMENT *psf_instrument_alloc(void) ;
#line 790
void psf_sanitize_string(char *cptr , int len ) ;
#line 793
void psf_get_date_str(char *str , int maxlen ) ;
#line 795
SF_BROADCAST_VAR *broadcast_var_alloc(size_t datasize ) ;
#line 796
int broadcast_var_set(SF_PRIVATE *psf , SF_BROADCAST_INFO *info , size_t datasize ) ;
#line 797
int broadcast_var_get(SF_PRIVATE *psf , SF_BROADCAST_INFO *data___0 , size_t datasize ) ;
#line 805
int audio_detect(SF_PRIVATE *psf , AUDIO_DETECT *ad , unsigned char const   *data___0 ,
                 int datalen ) ;
#line 812
void psf_hexdump(void const   *ptr , int len ) ;
#line 814
char const   *str_of_major_format(int format ) ;
#line 815
char const   *str_of_minor_format(int format ) ;
#line 816
char const   *str_of_open_mode(int mode ) ;
#line 817
char const   *str_of_endianness(int end ) ;
#line 48 "/root/libsndfile/src/ima_oki_adpcm.h"
void ima_oki_adpcm_init(IMA_OKI_ADPCM *state , IMA_OKI_ADPCM_TYPE type ) ;
#line 50
int adpcm_decode(IMA_OKI_ADPCM *state , int code ) ;
#line 51
int adpcm_encode(IMA_OKI_ADPCM *state , int sample ) ;
#line 53
void ima_oki_adpcm_decode_block(IMA_OKI_ADPCM *state ) ;
#line 54
void ima_oki_adpcm_encode_block(IMA_OKI_ADPCM *state ) ;
#line 45 "/root/libsndfile/src/vox_adpcm.c"
static sf_count_t vox_read_s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 46
static sf_count_t vox_read_i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 47
static sf_count_t vox_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 48
static sf_count_t vox_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 50
static sf_count_t vox_write_s(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 51
static sf_count_t vox_write_i(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 52
static sf_count_t vox_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 53
static sf_count_t vox_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 55
static int vox_read_block(SF_PRIVATE *psf , IMA_OKI_ADPCM *pvox , short *ptr , int len ) ;
#line 61 "/root/libsndfile/src/vox_adpcm.c"
static int codec_close(SF_PRIVATE *psf ) 
{ 
  IMA_OKI_ADPCM *p ;

  {
#line 63
  p = (IMA_OKI_ADPCM *)psf->codec_data;
#line 65
  if (p->errors) {
    {
#line 66
    psf_log_printf(psf, "*** Warning : ADPCM state errors: %d\n", p->errors);
    }
  }
#line 67
  return (p->errors);
}
}
#line 71 "/root/libsndfile/src/vox_adpcm.c"
int vox_adpcm_init(SF_PRIVATE *psf ) 
{ 
  IMA_OKI_ADPCM *pvox ;
  void *__cil_tmp3 ;
  sf_count_t __cil_tmp4 ;

  {
#line 72
  pvox = (IMA_OKI_ADPCM *)((void *)0);
#line 74
  if (psf->mode == 48) {
#line 75
    return (23);
  }
#line 77
  if (psf->mode == 32) {
#line 77
    if (psf->sf.channels != 1) {
#line 78
      return (33);
    }
  }
  {
#line 80
  pvox = (IMA_OKI_ADPCM *)malloc(sizeof(IMA_OKI_ADPCM ));
  }
#line 80
  if (pvox == (void *)0) {
#line 81
    return (16);
  }
  {
#line 83
  psf->codec_data = (void *)pvox;
#line 84
  memset(pvox, 0, sizeof(IMA_OKI_ADPCM ));
  }
#line 86
  if (psf->mode == 32) {
#line 87
    psf->write_short = & vox_write_s;
#line 88
    psf->write_int = & vox_write_i;
#line 89
    psf->write_float = & vox_write_f;
#line 90
    psf->write_double = & vox_write_d;
  } else {
    {
#line 93
    psf_log_printf(psf, "Header-less OKI Dialogic ADPCM encoded file.\n");
#line 94
    psf_log_printf(psf, "Setting up for 8kHz, mono, Vox ADPCM.\n");
#line 96
    psf->read_short = & vox_read_s;
#line 97
    psf->read_int = & vox_read_i;
#line 98
    psf->read_float = & vox_read_f;
#line 99
    psf->read_double = & vox_read_d;
    }
  }

#line 103
  if (psf->sf.samplerate < 1) {
#line 104
    psf->sf.samplerate = 8000;
  }
  {
#line 105
  psf->sf.channels = 1;
#line 107
  psf->sf.frames = psf->filelength * 2L;
#line 109
  psf->sf.seekable = 0;
#line 110
  psf->codec_close = & codec_close;
#line 113
  __cil_tmp4 = psf_fseek(psf, (sf_count_t )0, 0);
  }
#line 113
  if (__cil_tmp4 == -1L) {
#line 114
    return (38);
  }
  {
#line 116
  ima_oki_adpcm_init(pvox, (IMA_OKI_ADPCM_TYPE )1);
  }
#line 118
  return (0);
}
}
#line 125 "/root/libsndfile/src/vox_adpcm.c"
static int vox_read_block(SF_PRIVATE *psf , IMA_OKI_ADPCM *pvox , short *ptr , int len ) 
{ 
  int indx ;
  int k ;
  int tmp ;
  sf_count_t __cil_tmp8 ;
  sf_count_t __cil_tmp9 ;

  {
#line 126
  indx = 0;
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;
#line 128
    if (! (indx < len)) {
#line 128
      goto while_break;
    }
#line 129
    if (len - indx > 512) {
#line 129
      tmp = 256;
    } else {
#line 129
      tmp = ((len - indx) + 1) / 2;
    }
    {
#line 129
    pvox->code_count = tmp;
#line 131
    __cil_tmp8 = psf_fread((unsigned char *)pvox->codes, (sf_count_t )1, (sf_count_t )pvox->code_count,
                           psf);
#line 131
    k = (int )__cil_tmp8;
    }
#line 131
    if (k != pvox->code_count) {
      {
#line 132
      __cil_tmp9 = psf_ftell(psf);
      }
#line 132
      if (__cil_tmp9 != psf->filelength) {
        {
#line 133
        psf_log_printf(psf, "*** Warning : short read (%d != %d).\nV", k, pvox->code_count);
        }
      }
#line 134
      if (k == 0) {
#line 135
        goto while_break;
      }
    }
    {
#line 138
    pvox->code_count = k;
#line 140
    ima_oki_adpcm_decode_block(pvox);
#line 142
    memcpy(ptr + indx, (short *)pvox->pcm, (unsigned long )pvox->pcm_count * sizeof(short ));
#line 143
    indx += pvox->pcm_count;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 146
  return (indx);
}
}
#line 151 "/root/libsndfile/src/vox_adpcm.c"
static sf_count_t vox_read_s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  IMA_OKI_ADPCM *pvox ;
  int readcount ;
  int count ;
  sf_count_t total ;
  int tmp ;
  int __cil_tmp9 ;

  {
#line 154
  total = (sf_count_t )0;
#line 156
  if (! psf->codec_data) {
#line 157
    return ((sf_count_t )0);
  }
#line 158
  pvox = (IMA_OKI_ADPCM *)psf->codec_data;
  {
#line 160
  while (1) {
    while_continue: /* CIL Label */ ;
#line 160
    if (! (len > 0L)) {
#line 160
      goto while_break;
    }
#line 161
    if (len > 268435456L) {
#line 161
      tmp = 268435456;
    } else {
#line 161
      tmp = (int )len;
    }
    {
#line 161
    readcount = tmp;
#line 163
    count = vox_read_block(psf, pvox, ptr, readcount);
#line 165
    total += (long )count;
#line 166
    len -= (long )count;
    }
#line 167
    if (count != readcount) {
#line 168
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 171
  return (total);
}
}
#line 175 "/root/libsndfile/src/vox_adpcm.c"
static sf_count_t vox_read_i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  IMA_OKI_ADPCM *pvox ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count ;
  sf_count_t total ;
  int tmp ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;

  {
#line 179
  total = (sf_count_t )0;
#line 181
  if (! psf->codec_data) {
#line 182
    return ((sf_count_t )0);
  }
#line 183
  pvox = (IMA_OKI_ADPCM *)psf->codec_data;
#line 185
  sptr = (short *)psf->u.sbuf;
#line 186
  bufferlen = (int )(sizeof(psf->u.sbuf) / sizeof(psf->u.sbuf[0]));
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! (len > 0L)) {
#line 187
      goto while_break;
    }
#line 188
    if (len >= (long )bufferlen) {
#line 188
      tmp = bufferlen;
    } else {
#line 188
      tmp = (int )len;
    }
    {
#line 188
    readcount = tmp;
#line 189
    count = vox_read_block(psf, pvox, sptr, readcount);
#line 190
    k = 0;
    }
    {
#line 190
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 190
      if (! (k < readcount)) {
#line 190
        goto while_break___0;
      }
#line 191
      *(ptr + (total + (long )k)) = (int )*(sptr + k) << 16;
#line 190
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 192
    total += (long )count;
#line 193
    len -= (long )readcount;
#line 194
    if (count != readcount) {
#line 195
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 198
  return (total);
}
}
#line 202 "/root/libsndfile/src/vox_adpcm.c"
static sf_count_t vox_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  IMA_OKI_ADPCM *pvox ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  int tmp___0 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;

  {
#line 206
  total = (sf_count_t )0;
#line 209
  if (! psf->codec_data) {
#line 210
    return ((sf_count_t )0);
  }
#line 211
  pvox = (IMA_OKI_ADPCM *)psf->codec_data;
#line 213
  if (psf->norm_float == 1) {
#line 213
    tmp = 1. / (double )((float )32768);
  } else {
#line 213
    tmp = 1.;
  }
#line 213
  normfact = (float )tmp;
#line 215
  sptr = (short *)psf->u.sbuf;
#line 216
  bufferlen = (int )(sizeof(psf->u.sbuf) / sizeof(psf->u.sbuf[0]));
  {
#line 217
  while (1) {
    while_continue: /* CIL Label */ ;
#line 217
    if (! (len > 0L)) {
#line 217
      goto while_break;
    }
#line 218
    if (len >= (long )bufferlen) {
#line 218
      tmp___0 = bufferlen;
    } else {
#line 218
      tmp___0 = (int )len;
    }
    {
#line 218
    readcount = tmp___0;
#line 219
    count = vox_read_block(psf, pvox, sptr, readcount);
#line 220
    k = 0;
    }
    {
#line 220
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 220
      if (! (k < readcount)) {
#line 220
        goto while_break___0;
      }
#line 221
      *(ptr + (total + (long )k)) = normfact * (float )*(sptr + k);
#line 220
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 222
    total += (long )count;
#line 223
    len -= (long )readcount;
#line 224
    if (count != readcount) {
#line 225
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 228
  return (total);
}
}
#line 232 "/root/libsndfile/src/vox_adpcm.c"
static sf_count_t vox_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  IMA_OKI_ADPCM *pvox ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  int tmp___0 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;

  {
#line 236
  total = (sf_count_t )0;
#line 239
  if (! psf->codec_data) {
#line 240
    return ((sf_count_t )0);
  }
#line 241
  pvox = (IMA_OKI_ADPCM *)psf->codec_data;
#line 243
  if (psf->norm_double == 1) {
#line 243
    tmp = 1. / (double )32768;
  } else {
#line 243
    tmp = 1.;
  }
#line 243
  normfact = tmp;
#line 245
  sptr = (short *)psf->u.sbuf;
#line 246
  bufferlen = (int )(sizeof(psf->u.sbuf) / sizeof(psf->u.sbuf[0]));
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    if (! (len > 0L)) {
#line 247
      goto while_break;
    }
#line 248
    if (len >= (long )bufferlen) {
#line 248
      tmp___0 = bufferlen;
    } else {
#line 248
      tmp___0 = (int )len;
    }
    {
#line 248
    readcount = tmp___0;
#line 249
    count = vox_read_block(psf, pvox, sptr, readcount);
#line 250
    k = 0;
    }
    {
#line 250
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 250
      if (! (k < readcount)) {
#line 250
        goto while_break___0;
      }
#line 251
      *(ptr + (total + (long )k)) = normfact * (double )*(sptr + k);
#line 250
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 252
    total += (long )count;
#line 253
    len -= (long )readcount;
#line 254
    if (count != readcount) {
#line 255
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 258
  return (total);
}
}
#line 265 "/root/libsndfile/src/vox_adpcm.c"
static int vox_write_block(SF_PRIVATE *psf , IMA_OKI_ADPCM *pvox , short const   *ptr ,
                           int len ) 
{ 
  int indx ;
  int k ;
  int tmp ;
  sf_count_t __cil_tmp8 ;

  {
#line 266
  indx = 0;
  {
#line 268
  while (1) {
    while_continue: /* CIL Label */ ;
#line 268
    if (! (indx < len)) {
#line 268
      goto while_break;
    }
#line 269
    if (len - indx > 512) {
#line 269
      tmp = 512;
    } else {
#line 269
      tmp = len - indx;
    }
    {
#line 269
    pvox->pcm_count = tmp;
#line 271
    memcpy((short *)pvox->pcm, ptr + indx, (unsigned long )pvox->pcm_count * sizeof(short ));
#line 273
    ima_oki_adpcm_encode_block(pvox);
#line 275
    __cil_tmp8 = psf_fwrite((unsigned char *)pvox->codes, (sf_count_t )1, (sf_count_t )pvox->code_count,
                            psf);
#line 275
    k = (int )__cil_tmp8;
    }
#line 275
    if (k != pvox->code_count) {
      {
#line 276
      psf_log_printf(psf, "*** Warning : short write (%d != %d).\n", k, pvox->code_count);
      }
    }
#line 278
    indx += pvox->pcm_count;
  }
  while_break: /* CIL Label */ ;
  }

#line 281
  return (indx);
}
}
#line 285 "/root/libsndfile/src/vox_adpcm.c"
static sf_count_t vox_write_s(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  IMA_OKI_ADPCM *pvox ;
  int writecount ;
  int count ;
  sf_count_t total ;
  int tmp ;
  int __cil_tmp9 ;

  {
#line 288
  total = (sf_count_t )0;
#line 290
  if (! psf->codec_data) {
#line 291
    return ((sf_count_t )0);
  }
#line 292
  pvox = (IMA_OKI_ADPCM *)psf->codec_data;
  {
#line 294
  while (1) {
    while_continue: /* CIL Label */ ;
#line 294
    if (! len) {
#line 294
      goto while_break;
    }
#line 295
    if (len > 268435456L) {
#line 295
      tmp = 268435456;
    } else {
#line 295
      tmp = (int )len;
    }
    {
#line 295
    writecount = tmp;
#line 297
    count = vox_write_block(psf, pvox, ptr, writecount);
#line 299
    total += (long )count;
#line 300
    len -= (long )count;
    }
#line 301
    if (count != writecount) {
#line 302
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 305
  return (total);
}
}
#line 309 "/root/libsndfile/src/vox_adpcm.c"
static sf_count_t vox_write_i(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  IMA_OKI_ADPCM *pvox ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count ;
  sf_count_t total ;
  int tmp ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;

  {
#line 313
  total = (sf_count_t )0;
#line 315
  if (! psf->codec_data) {
#line 316
    return ((sf_count_t )0);
  }
#line 317
  pvox = (IMA_OKI_ADPCM *)psf->codec_data;
#line 319
  sptr = (short *)psf->u.sbuf;
#line 320
  bufferlen = (int )(sizeof(psf->u.sbuf) / sizeof(psf->u.sbuf[0]));
  {
#line 321
  while (1) {
    while_continue: /* CIL Label */ ;
#line 321
    if (! (len > 0L)) {
#line 321
      goto while_break;
    }
#line 322
    if (len >= (long )bufferlen) {
#line 322
      tmp = bufferlen;
    } else {
#line 322
      tmp = (int )len;
    }
#line 322
    writecount = tmp;
#line 323
    k = 0;
    {
#line 323
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 323
      if (! (k < writecount)) {
#line 323
        goto while_break___0;
      }
#line 324
      *(sptr + k) = (short )(*(ptr + (total + (long )k)) >> 16);
#line 323
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 325
    count = vox_write_block(psf, pvox, (short const   *)sptr, writecount);
#line 326
    total += (long )count;
#line 327
    len -= (long )writecount;
    }
#line 328
    if (count != writecount) {
#line 329
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 332
  return (total);
}
}
#line 336 "/root/libsndfile/src/vox_adpcm.c"
static sf_count_t vox_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  IMA_OKI_ADPCM *pvox ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  int tmp___0 ;
  long __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;

  {
#line 340
  total = (sf_count_t )0;
#line 343
  if (! psf->codec_data) {
#line 344
    return ((sf_count_t )0);
  }
#line 345
  pvox = (IMA_OKI_ADPCM *)psf->codec_data;
#line 347
  if (psf->norm_float == 1) {
#line 347
    tmp = 1. * (double )32767;
  } else {
#line 347
    tmp = 1.;
  }
#line 347
  normfact = (float )tmp;
#line 349
  sptr = (short *)psf->u.sbuf;
#line 350
  bufferlen = (int )(sizeof(psf->u.sbuf) / sizeof(psf->u.sbuf[0]));
  {
#line 351
  while (1) {
    while_continue: /* CIL Label */ ;
#line 351
    if (! (len > 0L)) {
#line 351
      goto while_break;
    }
#line 352
    if (len >= (long )bufferlen) {
#line 352
      tmp___0 = bufferlen;
    } else {
#line 352
      tmp___0 = (int )len;
    }
#line 352
    writecount = tmp___0;
#line 353
    k = 0;
    {
#line 353
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 353
      if (! (k < writecount)) {
#line 353
        goto while_break___0;
      }
      {
#line 354
      __cil_tmp14 = lrintf(normfact * *(ptr + (total + (long )k)));
#line 354
      *(sptr + k) = (short )__cil_tmp14;
      }
#line 353
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 355
    count = vox_write_block(psf, pvox, (short const   *)sptr, writecount);
#line 356
    total += (long )count;
#line 357
    len -= (long )writecount;
    }
#line 358
    if (count != writecount) {
#line 359
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 362
  return (total);
}
}
#line 366 "/root/libsndfile/src/vox_adpcm.c"
static sf_count_t vox_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  IMA_OKI_ADPCM *pvox ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  int tmp___0 ;
  long __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;

  {
#line 370
  total = (sf_count_t )0;
#line 373
  if (! psf->codec_data) {
#line 374
    return ((sf_count_t )0);
  }
#line 375
  pvox = (IMA_OKI_ADPCM *)psf->codec_data;
#line 377
  if (psf->norm_double == 1) {
#line 377
    tmp = 1. * (double )32767;
  } else {
#line 377
    tmp = 1.;
  }
#line 377
  normfact = tmp;
#line 379
  sptr = (short *)psf->u.sbuf;
#line 380
  bufferlen = (int )(sizeof(psf->u.sbuf) / sizeof(psf->u.sbuf[0]));
  {
#line 381
  while (1) {
    while_continue: /* CIL Label */ ;
#line 381
    if (! (len > 0L)) {
#line 381
      goto while_break;
    }
#line 382
    if (len >= (long )bufferlen) {
#line 382
      tmp___0 = bufferlen;
    } else {
#line 382
      tmp___0 = (int )len;
    }
#line 382
    writecount = tmp___0;
#line 383
    k = 0;
    {
#line 383
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 383
      if (! (k < writecount)) {
#line 383
        goto while_break___0;
      }
      {
#line 384
      __cil_tmp14 = lrint(normfact * *(ptr + (total + (long )k)));
#line 384
      *(sptr + k) = (short )__cil_tmp14;
      }
#line 383
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 385
    count = vox_write_block(psf, pvox, (short const   *)sptr, writecount);
#line 386
    total += (long )count;
#line 387
    len -= (long )writecount;
    }
#line 388
    if (count != writecount) {
#line 389
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 392
  return (total);
}
}
#line 26 "/root/libsndfile/src/ulaw.c"
static sf_count_t ulaw_read_ulaw2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 27
static sf_count_t ulaw_read_ulaw2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 28
static sf_count_t ulaw_read_ulaw2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 29
static sf_count_t ulaw_read_ulaw2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 31
static sf_count_t ulaw_write_s2ulaw(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 32
static sf_count_t ulaw_write_i2ulaw(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 33
static sf_count_t ulaw_write_f2ulaw(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 34
static sf_count_t ulaw_write_d2ulaw(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 37 "/root/libsndfile/src/ulaw.c"
int ulaw_init(SF_PRIVATE *psf ) 
{ 
  sf_count_t tmp ;

  {
#line 39
  if (psf->mode == 16) {
#line 40
    psf->read_short = & ulaw_read_ulaw2s;
#line 41
    psf->read_int = & ulaw_read_ulaw2i;
#line 42
    psf->read_float = & ulaw_read_ulaw2f;
#line 43
    psf->read_double = & ulaw_read_ulaw2d;
  } else
#line 39
  if (psf->mode == 48) {
#line 40
    psf->read_short = & ulaw_read_ulaw2s;
#line 41
    psf->read_int = & ulaw_read_ulaw2i;
#line 42
    psf->read_float = & ulaw_read_ulaw2f;
#line 43
    psf->read_double = & ulaw_read_ulaw2d;
  }

#line 46
  if (psf->mode == 32) {
#line 47
    psf->write_short = & ulaw_write_s2ulaw;
#line 48
    psf->write_int = & ulaw_write_i2ulaw;
#line 49
    psf->write_float = & ulaw_write_f2ulaw;
#line 50
    psf->write_double = & ulaw_write_d2ulaw;
  } else
#line 46
  if (psf->mode == 48) {
#line 47
    psf->write_short = & ulaw_write_s2ulaw;
#line 48
    psf->write_int = & ulaw_write_i2ulaw;
#line 49
    psf->write_float = & ulaw_write_f2ulaw;
#line 50
    psf->write_double = & ulaw_write_d2ulaw;
  }
#line 53
  psf->bytewidth = 1;
#line 54
  psf->blockwidth = psf->sf.channels;
#line 56
  if (psf->filelength > psf->dataoffset) {
#line 57
    if (psf->dataend) {
#line 57
      tmp = psf->dataend - psf->dataoffset;
    } else {
#line 57
      tmp = psf->filelength - psf->dataoffset;
    }
#line 57
    psf->datalength = tmp;
  } else {
#line 60
    psf->datalength = (sf_count_t )0;
  }
#line 62
  if (psf->blockwidth > 0) {
#line 62
    psf->sf.frames = psf->datalength / (long )psf->blockwidth;;
  } else {
#line 62
    psf->sf.frames = 1;
  }
#line 64
  return (0);
}
}
#line 70 "/root/libsndfile/src/ulaw.c"
static short ulaw_decode[256]  = 
#line 70
  {      (short )(- 32124),      (short )(- 31100),      (short )(- 30076),      (short )(- 29052), 
        (short )(- 28028),      (short )(- 27004),      (short )(- 25980),      (short )(- 24956), 
        (short )(- 23932),      (short )(- 22908),      (short )(- 21884),      (short )(- 20860), 
        (short )(- 19836),      (short )(- 18812),      (short )(- 17788),      (short )(- 16764), 
        (short )(- 15996),      (short )(- 15484),      (short )(- 14972),      (short )(- 14460), 
        (short )(- 13948),      (short )(- 13436),      (short )(- 12924),      (short )(- 12412), 
        (short )(- 11900),      (short )(- 11388),      (short )(- 10876),      (short )(- 10364), 
        (short )(- 9852),      (short )(- 9340),      (short )(- 8828),      (short )(- 8316), 
        (short )(- 7932),      (short )(- 7676),      (short )(- 7420),      (short )(- 7164), 
        (short )(- 6908),      (short )(- 6652),      (short )(- 6396),      (short )(- 6140), 
        (short )(- 5884),      (short )(- 5628),      (short )(- 5372),      (short )(- 5116), 
        (short )(- 4860),      (short )(- 4604),      (short )(- 4348),      (short )(- 4092), 
        (short )(- 3900),      (short )(- 3772),      (short )(- 3644),      (short )(- 3516), 
        (short )(- 3388),      (short )(- 3260),      (short )(- 3132),      (short )(- 3004), 
        (short )(- 2876),      (short )(- 2748),      (short )(- 2620),      (short )(- 2492), 
        (short )(- 2364),      (short )(- 2236),      (short )(- 2108),      (short )(- 1980), 
        (short )(- 1884),      (short )(- 1820),      (short )(- 1756),      (short )(- 1692), 
        (short )(- 1628),      (short )(- 1564),      (short )(- 1500),      (short )(- 1436), 
        (short )(- 1372),      (short )(- 1308),      (short )(- 1244),      (short )(- 1180), 
        (short )(- 1116),      (short )(- 1052),      (short )(- 988),      (short )(- 924), 
        (short )(- 876),      (short )(- 844),      (short )(- 812),      (short )(- 780), 
        (short )(- 748),      (short )(- 716),      (short )(- 684),      (short )(- 652), 
        (short )(- 620),      (short )(- 588),      (short )(- 556),      (short )(- 524), 
        (short )(- 492),      (short )(- 460),      (short )(- 428),      (short )(- 396), 
        (short )(- 372),      (short )(- 356),      (short )(- 340),      (short )(- 324), 
        (short )(- 308),      (short )(- 292),      (short )(- 276),      (short )(- 260), 
        (short )(- 244),      (short )(- 228),      (short )(- 212),      (short )(- 196), 
        (short )(- 180),      (short )(- 164),      (short )(- 148),      (short )(- 132), 
        (short )(- 120),      (short )(- 112),      (short )(- 104),      (short )(- 96), 
        (short )(- 88),      (short )(- 80),      (short )(- 72),      (short )(- 64), 
        (short )(- 56),      (short )(- 48),      (short )(- 40),      (short )(- 32), 
        (short )(- 24),      (short )(- 16),      (short )(- 8),      (short )0, 
        (short )32124,      (short )31100,      (short )30076,      (short )29052, 
        (short )28028,      (short )27004,      (short )25980,      (short )24956, 
        (short )23932,      (short )22908,      (short )21884,      (short )20860, 
        (short )19836,      (short )18812,      (short )17788,      (short )16764, 
        (short )15996,      (short )15484,      (short )14972,      (short )14460, 
        (short )13948,      (short )13436,      (short )12924,      (short )12412, 
        (short )11900,      (short )11388,      (short )10876,      (short )10364, 
        (short )9852,      (short )9340,      (short )8828,      (short )8316, 
        (short )7932,      (short )7676,      (short )7420,      (short )7164, 
        (short )6908,      (short )6652,      (short )6396,      (short )6140, 
        (short )5884,      (short )5628,      (short )5372,      (short )5116, 
        (short )4860,      (short )4604,      (short )4348,      (short )4092, 
        (short )3900,      (short )3772,      (short )3644,      (short )3516, 
        (short )3388,      (short )3260,      (short )3132,      (short )3004, 
        (short )2876,      (short )2748,      (short )2620,      (short )2492, 
        (short )2364,      (short )2236,      (short )2108,      (short )1980, 
        (short )1884,      (short )1820,      (short )1756,      (short )1692, 
        (short )1628,      (short )1564,      (short )1500,      (short )1436, 
        (short )1372,      (short )1308,      (short )1244,      (short )1180, 
        (short )1116,      (short )1052,      (short )988,      (short )924, 
        (short )876,      (short )844,      (short )812,      (short )780, 
        (short )748,      (short )716,      (short )684,      (short )652, 
        (short )620,      (short )588,      (short )556,      (short )524, 
        (short )492,      (short )460,      (short )428,      (short )396, 
        (short )372,      (short )356,      (short )340,      (short )324, 
        (short )308,      (short )292,      (short )276,      (short )260, 
        (short )244,      (short )228,      (short )212,      (short )196, 
        (short )180,      (short )164,      (short )148,      (short )132, 
        (short )120,      (short )112,      (short )104,      (short )96, 
        (short )88,      (short )80,      (short )72,      (short )64, 
        (short )56,      (short )48,      (short )40,      (short )32, 
        (short )24,      (short )16,      (short )8,      (short )0};
#line 107 "/root/libsndfile/src/ulaw.c"
static unsigned char ulaw_encode[8193]  = 
#line 107
  {      (unsigned char )255,      (unsigned char )254,      (unsigned char )254,      (unsigned char )253, 
        (unsigned char )253,      (unsigned char )252,      (unsigned char )252,      (unsigned char )251, 
        (unsigned char )251,      (unsigned char )250,      (unsigned char )250,      (unsigned char )249, 
        (unsigned char )249,      (unsigned char )248,      (unsigned char )248,      (unsigned char )247, 
        (unsigned char )247,      (unsigned char )246,      (unsigned char )246,      (unsigned char )245, 
        (unsigned char )245,      (unsigned char )244,      (unsigned char )244,      (unsigned char )243, 
        (unsigned char )243,      (unsigned char )242,      (unsigned char )242,      (unsigned char )241, 
        (unsigned char )241,      (unsigned char )240,      (unsigned char )240,      (unsigned char )239, 
        (unsigned char )239,      (unsigned char )239,      (unsigned char )239,      (unsigned char )238, 
        (unsigned char )238,      (unsigned char )238,      (unsigned char )238,      (unsigned char )237, 
        (unsigned char )237,      (unsigned char )237,      (unsigned char )237,      (unsigned char )236, 
        (unsigned char )236,      (unsigned char )236,      (unsigned char )236,      (unsigned char )235, 
        (unsigned char )235,      (unsigned char )235,      (unsigned char )235,      (unsigned char )234, 
        (unsigned char )234,      (unsigned char )234,      (unsigned char )234,      (unsigned char )233, 
        (unsigned char )233,      (unsigned char )233,      (unsigned char )233,      (unsigned char )232, 
        (unsigned char )232,      (unsigned char )232,      (unsigned char )232,      (unsigned char )231, 
        (unsigned char )231,      (unsigned char )231,      (unsigned char )231,      (unsigned char )230, 
        (unsigned char )230,      (unsigned char )230,      (unsigned char )230,      (unsigned char )229, 
        (unsigned char )229,      (unsigned char )229,      (unsigned char )229,      (unsigned char )228, 
        (unsigned char )228,      (unsigned char )228,      (unsigned char )228,      (unsigned char )227, 
        (unsigned char )227,      (unsigned char )227,      (unsigned char )227,      (unsigned char )226, 
        (unsigned char )226,      (unsigned char )226,      (unsigned char )226,      (unsigned char )225, 
        (unsigned char )225,      (unsigned char )225,      (unsigned char )225,      (unsigned char )224, 
        (unsigned char )224,      (unsigned char )224,      (unsigned char )224,      (unsigned char )223, 
        (unsigned char )223,      (unsigned char )223,      (unsigned char )223,      (unsigned char )223, 
        (unsigned char )223,      (unsigned char )223,      (unsigned char )223,      (unsigned char )222, 
        (unsigned char )222,      (unsigned char )222,      (unsigned char )222,      (unsigned char )222, 
        (unsigned char )222,      (unsigned char )222,      (unsigned char )222,      (unsigned char )221, 
        (unsigned char )221,      (unsigned char )221,      (unsigned char )221,      (unsigned char )221, 
        (unsigned char )221,      (unsigned char )221,      (unsigned char )221,      (unsigned char )220, 
        (unsigned char )220,      (unsigned char )220,      (unsigned char )220,      (unsigned char )220, 
        (unsigned char )220,      (unsigned char )220,      (unsigned char )220,      (unsigned char )219, 
        (unsigned char )219,      (unsigned char )219,      (unsigned char )219,      (unsigned char )219, 
        (unsigned char )219,      (unsigned char )219,      (unsigned char )219,      (unsigned char )218, 
        (unsigned char )218,      (unsigned char )218,      (unsigned char )218,      (unsigned char )218, 
        (unsigned char )218,      (unsigned char )218,      (unsigned char )218,      (unsigned char )217, 
        (unsigned char )217,      (unsigned char )217,      (unsigned char )217,      (unsigned char )217, 
        (unsigned char )217,      (unsigned char )217,      (unsigned char )217,      (unsigned char )216, 
        (unsigned char )216,      (unsigned char )216,      (unsigned char )216,      (unsigned char )216, 
        (unsigned char )216,      (unsigned char )216,      (unsigned char )216,      (unsigned char )215, 
        (unsigned char )215,      (unsigned char )215,      (unsigned char )215,      (unsigned char )215, 
        (unsigned char )215,      (unsigned char )215,      (unsigned char )215,      (unsigned char )214, 
        (unsigned char )214,      (unsigned char )214,      (unsigned char )214,      (unsigned char )214, 
        (unsigned char )214,      (unsigned char )214,      (unsigned char )214,      (unsigned char )213, 
        (unsigned char )213,      (unsigned char )213,      (unsigned char )213,      (unsigned char )213, 
        (unsigned char )213,      (unsigned char )213,      (unsigned char )213,      (unsigned char )212, 
        (unsigned char )212,      (unsigned char )212,      (unsigned char )212,      (unsigned char )212, 
        (unsigned char )212,      (unsigned char )212,      (unsigned char )212,      (unsigned char )211, 
        (unsigned char )211,      (unsigned char )211,      (unsigned char )211,      (unsigned char )211, 
        (unsigned char )211,      (unsigned char )211,      (unsigned char )211,      (unsigned char )210, 
        (unsigned char )210,      (unsigned char )210,      (unsigned char )210,      (unsigned char )210, 
        (unsigned char )210,      (unsigned char )210,      (unsigned char )210,      (unsigned char )209, 
        (unsigned char )209,      (unsigned char )209,      (unsigned char )209,      (unsigned char )209, 
        (unsigned char )209,      (unsigned char )209,      (unsigned char )209,      (unsigned char )208, 
        (unsigned char )208,      (unsigned char )208,      (unsigned char )208,      (unsigned char )208, 
        (unsigned char )208,      (unsigned char )208,      (unsigned char )208,      (unsigned char )207, 
        (unsigned char )207,      (unsigned char )207,      (unsigned char )207,      (unsigned char )207, 
        (unsigned char )207,      (unsigned char )207,      (unsigned char )207,      (unsigned char )207, 
        (unsigned char )207,      (unsigned char )207,      (unsigned char )207,      (unsigned char )207, 
        (unsigned char )207,      (unsigned char )207,      (unsigned char )207,      (unsigned char )206, 
        (unsigned char )206,      (unsigned char )206,      (unsigned char )206,      (unsigned char )206, 
        (unsigned char )206,      (unsigned char )206,      (unsigned char )206,      (unsigned char )206, 
        (unsigned char )206,      (unsigned char )206,      (unsigned char )206,      (unsigned char )206, 
        (unsigned char )206,      (unsigned char )206,      (unsigned char )206,      (unsigned char )205, 
        (unsigned char )205,      (unsigned char )205,      (unsigned char )205,      (unsigned char )205, 
        (unsigned char )205,      (unsigned char )205,      (unsigned char )205,      (unsigned char )205, 
        (unsigned char )205,      (unsigned char )205,      (unsigned char )205,      (unsigned char )205, 
        (unsigned char )205,      (unsigned char )205,      (unsigned char )205,      (unsigned char )204, 
        (unsigned char )204,      (unsigned char )204,      (unsigned char )204,      (unsigned char )204, 
        (unsigned char )204,      (unsigned char )204,      (unsigned char )204,      (unsigned char )204, 
        (unsigned char )204,      (unsigned char )204,      (unsigned char )204,      (unsigned char )204, 
        (unsigned char )204,      (unsigned char )204,      (unsigned char )204,      (unsigned char )203, 
        (unsigned char )203,      (unsigned char )203,      (unsigned char )203,      (unsigned char )203, 
        (unsigned char )203,      (unsigned char )203,      (unsigned char )203,      (unsigned char )203, 
        (unsigned char )203,      (unsigned char )203,      (unsigned char )203,      (unsigned char )203, 
        (unsigned char )203,      (unsigned char )203,      (unsigned char )203,      (unsigned char )202, 
        (unsigned char )202,      (unsigned char )202,      (unsigned char )202,      (unsigned char )202, 
        (unsigned char )202,      (unsigned char )202,      (unsigned char )202,      (unsigned char )202, 
        (unsigned char )202,      (unsigned char )202,      (unsigned char )202,      (unsigned char )202, 
        (unsigned char )202,      (unsigned char )202,      (unsigned char )202,      (unsigned char )201, 
        (unsigned char )201,      (unsigned char )201,      (unsigned char )201,      (unsigned char )201, 
        (unsigned char )201,      (unsigned char )201,      (unsigned char )201,      (unsigned char )201, 
        (unsigned char )201,      (unsigned char )201,      (unsigned char )201,      (unsigned char )201, 
        (unsigned char )201,      (unsigned char )201,      (unsigned char )201,      (unsigned char )200, 
        (unsigned char )200,      (unsigned char )200,      (unsigned char )200,      (unsigned char )200, 
        (unsigned char )200,      (unsigned char )200,      (unsigned char )200,      (unsigned char )200, 
        (unsigned char )200,      (unsigned char )200,      (unsigned char )200,      (unsigned char )200, 
        (unsigned char )200,      (unsigned char )200,      (unsigned char )200,      (unsigned char )199, 
        (unsigned char )199,      (unsigned char )199,      (unsigned char )199,      (unsigned char )199, 
        (unsigned char )199,      (unsigned char )199,      (unsigned char )199,      (unsigned char )199, 
        (unsigned char )199,      (unsigned char )199,      (unsigned char )199,      (unsigned char )199, 
        (unsigned char )199,      (unsigned char )199,      (unsigned char )199,      (unsigned char )198, 
        (unsigned char )198,      (unsigned char )198,      (unsigned char )198,      (unsigned char )198, 
        (unsigned char )198,      (unsigned char )198,      (unsigned char )198,      (unsigned char )198, 
        (unsigned char )198,      (unsigned char )198,      (unsigned char )198,      (unsigned char )198, 
        (unsigned char )198,      (unsigned char )198,      (unsigned char )198,      (unsigned char )197, 
        (unsigned char )197,      (unsigned char )197,      (unsigned char )197,      (unsigned char )197, 
        (unsigned char )197,      (unsigned char )197,      (unsigned char )197,      (unsigned char )197, 
        (unsigned char )197,      (unsigned char )197,      (unsigned char )197,      (unsigned char )197, 
        (unsigned char )197,      (unsigned char )197,      (unsigned char )197,      (unsigned char )196, 
        (unsigned char )196,      (unsigned char )196,      (unsigned char )196,      (unsigned char )196, 
        (unsigned char )196,      (unsigned char )196,      (unsigned char )196,      (unsigned char )196, 
        (unsigned char )196,      (unsigned char )196,      (unsigned char )196,      (unsigned char )196, 
        (unsigned char )196,      (unsigned char )196,      (unsigned char )196,      (unsigned char )195, 
        (unsigned char )195,      (unsigned char )195,      (unsigned char )195,      (unsigned char )195, 
        (unsigned char )195,      (unsigned char )195,      (unsigned char )195,      (unsigned char )195, 
        (unsigned char )195,      (unsigned char )195,      (unsigned char )195,      (unsigned char )195, 
        (unsigned char )195,      (unsigned char )195,      (unsigned char )195,      (unsigned char )194, 
        (unsigned char )194,      (unsigned char )194,      (unsigned char )194,      (unsigned char )194, 
        (unsigned char )194,      (unsigned char )194,      (unsigned char )194,      (unsigned char )194, 
        (unsigned char )194,      (unsigned char )194,      (unsigned char )194,      (unsigned char )194, 
        (unsigned char )194,      (unsigned char )194,      (unsigned char )194,      (unsigned char )193, 
        (unsigned char )193,      (unsigned char )193,      (unsigned char )193,      (unsigned char )193, 
        (unsigned char )193,      (unsigned char )193,      (unsigned char )193,      (unsigned char )193, 
        (unsigned char )193,      (unsigned char )193,      (unsigned char )193,      (unsigned char )193, 
        (unsigned char )193,      (unsigned char )193,      (unsigned char )193,      (unsigned char )192, 
        (unsigned char )192,      (unsigned char )192,      (unsigned char )192,      (unsigned char )192, 
        (unsigned char )192,      (unsigned char )192,      (unsigned char )192,      (unsigned char )192, 
        (unsigned char )192,      (unsigned char )192,      (unsigned char )192,      (unsigned char )192, 
        (unsigned char )192,      (unsigned char )192,      (unsigned char )192,      (unsigned char )191, 
        (unsigned char )191,      (unsigned char )191,      (unsigned char )191,      (unsigned char )191, 
        (unsigned char )191,      (unsigned char )191,      (unsigned char )191,      (unsigned char )191, 
        (unsigned char )191,      (unsigned char )191,      (unsigned char )191,      (unsigned char )191, 
        (unsigned char )191,      (unsigned char )191,      (unsigned char )191,      (unsigned char )191, 
        (unsigned char )191,      (unsigned char )191,      (unsigned char )191,      (unsigned char )191, 
        (unsigned char )191,      (unsigned char )191,      (unsigned char )191,      (unsigned char )191, 
        (unsigned char )191,      (unsigned char )191,      (unsigned char )191,      (unsigned char )191, 
        (unsigned char )191,      (unsigned char )191,      (unsigned char )191,      (unsigned char )190, 
        (unsigned char )190,      (unsigned char )190,      (unsigned char )190,      (unsigned char )190, 
        (unsigned char )190,      (unsigned char )190,      (unsigned char )190,      (unsigned char )190, 
        (unsigned char )190,      (unsigned char )190,      (unsigned char )190,      (unsigned char )190, 
        (unsigned char )190,      (unsigned char )190,      (unsigned char )190,      (unsigned char )190, 
        (unsigned char )190,      (unsigned char )190,      (unsigned char )190,      (unsigned char )190, 
        (unsigned char )190,      (unsigned char )190,      (unsigned char )190,      (unsigned char )190, 
        (unsigned char )190,      (unsigned char )190,      (unsigned char )190,      (unsigned char )190, 
        (unsigned char )190,      (unsigned char )190,      (unsigned char )190,      (unsigned char )189, 
        (unsigned char )189,      (unsigned char )189,      (unsigned char )189,      (unsigned char )189, 
        (unsigned char )189,      (unsigned char )189,      (unsigned char )189,      (unsigned char )189, 
        (unsigned char )189,      (unsigned char )189,      (unsigned char )189,      (unsigned char )189, 
        (unsigned char )189,      (unsigned char )189,      (unsigned char )189,      (unsigned char )189, 
        (unsigned char )189,      (unsigned char )189,      (unsigned char )189,      (unsigned char )189, 
        (unsigned char )189,      (unsigned char )189,      (unsigned char )189,      (unsigned char )189, 
        (unsigned char )189,      (unsigned char )189,      (unsigned char )189,      (unsigned char )189, 
        (unsigned char )189,      (unsigned char )189,      (unsigned char )189,      (unsigned char )188, 
        (unsigned char )188,      (unsigned char )188,      (unsigned char )188,      (unsigned char )188, 
        (unsigned char )188,      (unsigned char )188,      (unsigned char )188,      (unsigned char )188, 
        (unsigned char )188,      (unsigned char )188,      (unsigned char )188,      (unsigned char )188, 
        (unsigned char )188,      (unsigned char )188,      (unsigned char )188,      (unsigned char )188, 
        (unsigned char )188,      (unsigned char )188,      (unsigned char )188,      (unsigned char )188, 
        (unsigned char )188,      (unsigned char )188,      (unsigned char )188,      (unsigned char )188, 
        (unsigned char )188,      (unsigned char )188,      (unsigned char )188,      (unsigned char )188, 
        (unsigned char )188,      (unsigned char )188,      (unsigned char )188,      (unsigned char )187, 
        (unsigned char )187,      (unsigned char )187,      (unsigned char )187,      (unsigned char )187, 
        (unsigned char )187,      (unsigned char )187,      (unsigned char )187,      (unsigned char )187, 
        (unsigned char )187,      (unsigned char )187,      (unsigned char )187,      (unsigned char )187, 
        (unsigned char )187,      (unsigned char )187,      (unsigned char )187,      (unsigned char )187, 
        (unsigned char )187,      (unsigned char )187,      (unsigned char )187,      (unsigned char )187, 
        (unsigned char )187,      (unsigned char )187,      (unsigned char )187,      (unsigned char )187, 
        (unsigned char )187,      (unsigned char )187,      (unsigned char )187,      (unsigned char )187, 
        (unsigned char )187,      (unsigned char )187,      (unsigned char )187,      (unsigned char )186, 
        (unsigned char )186,      (unsigned char )186,      (unsigned char )186,      (unsigned char )186, 
        (unsigned char )186,      (unsigned char )186,      (unsigned char )186,      (unsigned char )186, 
        (unsigned char )186,      (unsigned char )186,      (unsigned char )186,      (unsigned char )186, 
        (unsigned char )186,      (unsigned char )186,      (unsigned char )186,      (unsigned char )186, 
        (unsigned char )186,      (unsigned char )186,      (unsigned char )186,      (unsigned char )186, 
        (unsigned char )186,      (unsigned char )186,      (unsigned char )186,      (unsigned char )186, 
        (unsigned char )186,      (unsigned char )186,      (unsigned char )186,      (unsigned char )186, 
        (unsigned char )186,      (unsigned char )186,      (unsigned char )186,      (unsigned char )185, 
        (unsigned char )185,      (unsigned char )185,      (unsigned char )185,      (unsigned char )185, 
        (unsigned char )185,      (unsigned char )185,      (unsigned char )185,      (unsigned char )185, 
        (unsigned char )185,      (unsigned char )185,      (unsigned char )185,      (unsigned char )185, 
        (unsigned char )185,      (unsigned char )185,      (unsigned char )185,      (unsigned char )185, 
        (unsigned char )185,      (unsigned char )185,      (unsigned char )185,      (unsigned char )185, 
        (unsigned char )185,      (unsigned char )185,      (unsigned char )185,      (unsigned char )185, 
        (unsigned char )185,      (unsigned char )185,      (unsigned char )185,      (unsigned char )185, 
        (unsigned char )185,      (unsigned char )185,      (unsigned char )185,      (unsigned char )184, 
        (unsigned char )184,      (unsigned char )184,      (unsigned char )184,      (unsigned char )184, 
        (unsigned char )184,      (unsigned char )184,      (unsigned char )184,      (unsigned char )184, 
        (unsigned char )184,      (unsigned char )184,      (unsigned char )184,      (unsigned char )184, 
        (unsigned char )184,      (unsigned char )184,      (unsigned char )184,      (unsigned char )184, 
        (unsigned char )184,      (unsigned char )184,      (unsigned char )184,      (unsigned char )184, 
        (unsigned char )184,      (unsigned char )184,      (unsigned char )184,      (unsigned char )184, 
        (unsigned char )184,      (unsigned char )184,      (unsigned char )184,      (unsigned char )184, 
        (unsigned char )184,      (unsigned char )184,      (unsigned char )184,      (unsigned char )183, 
        (unsigned char )183,      (unsigned char )183,      (unsigned char )183,      (unsigned char )183, 
        (unsigned char )183,      (unsigned char )183,      (unsigned char )183,      (unsigned char )183, 
        (unsigned char )183,      (unsigned char )183,      (unsigned char )183,      (unsigned char )183, 
        (unsigned char )183,      (unsigned char )183,      (unsigned char )183,      (unsigned char )183, 
        (unsigned char )183,      (unsigned char )183,      (unsigned char )183,      (unsigned char )183, 
        (unsigned char )183,      (unsigned char )183,      (unsigned char )183,      (unsigned char )183, 
        (unsigned char )183,      (unsigned char )183,      (unsigned char )183,      (unsigned char )183, 
        (unsigned char )183,      (unsigned char )183,      (unsigned char )183,      (unsigned char )182, 
        (unsigned char )182,      (unsigned char )182,      (unsigned char )182,      (unsigned char )182, 
        (unsigned char )182,      (unsigned char )182,      (unsigned char )182,      (unsigned char )182, 
        (unsigned char )182,      (unsigned char )182,      (unsigned char )182,      (unsigned char )182, 
        (unsigned char )182,      (unsigned char )182,      (unsigned char )182,      (unsigned char )182, 
        (unsigned char )182,      (unsigned char )182,      (unsigned char )182,      (unsigned char )182, 
        (unsigned char )182,      (unsigned char )182,      (unsigned char )182,      (unsigned char )182, 
        (unsigned char )182,      (unsigned char )182,      (unsigned char )182,      (unsigned char )182, 
        (unsigned char )182,      (unsigned char )182,      (unsigned char )182,      (unsigned char )181, 
        (unsigned char )181,      (unsigned char )181,      (unsigned char )181,      (unsigned char )181, 
        (unsigned char )181,      (unsigned char )181,      (unsigned char )181,      (unsigned char )181, 
        (unsigned char )181,      (unsigned char )181,      (unsigned char )181,      (unsigned char )181, 
        (unsigned char )181,      (unsigned char )181,      (unsigned char )181,      (unsigned char )181, 
        (unsigned char )181,      (unsigned char )181,      (unsigned char )181,      (unsigned char )181, 
        (unsigned char )181,      (unsigned char )181,      (unsigned char )181,      (unsigned char )181, 
        (unsigned char )181,      (unsigned char )181,      (unsigned char )181,      (unsigned char )181, 
        (unsigned char )181,      (unsigned char )181,      (unsigned char )181,      (unsigned char )180, 
        (unsigned char )180,      (unsigned char )180,      (unsigned char )180,      (unsigned char )180, 
        (unsigned char )180,      (unsigned char )180,      (unsigned char )180,      (unsigned char )180, 
        (unsigned char )180,      (unsigned char )180,      (unsigned char )180,      (unsigned char )180, 
        (unsigned char )180,      (unsigned char )180,      (unsigned char )180,      (unsigned char )180, 
        (unsigned char )180,      (unsigned char )180,      (unsigned char )180,      (unsigned char )180, 
        (unsigned char )180,      (unsigned char )180,      (unsigned char )180,      (unsigned char )180, 
        (unsigned char )180,      (unsigned char )180,      (unsigned char )180,      (unsigned char )180, 
        (unsigned char )180,      (unsigned char )180,      (unsigned char )180,      (unsigned char )179, 
        (unsigned char )179,      (unsigned char )179,      (unsigned char )179,      (unsigned char )179, 
        (unsigned char )179,      (unsigned char )179,      (unsigned char )179,      (unsigned char )179, 
        (unsigned char )179,      (unsigned char )179,      (unsigned char )179,      (unsigned char )179, 
        (unsigned char )179,      (unsigned char )179,      (unsigned char )179,      (unsigned char )179, 
        (unsigned char )179,      (unsigned char )179,      (unsigned char )179,      (unsigned char )179, 
        (unsigned char )179,      (unsigned char )179,      (unsigned char )179,      (unsigned char )179, 
        (unsigned char )179,      (unsigned char )179,      (unsigned char )179,      (unsigned char )179, 
        (unsigned char )179,      (unsigned char )179,      (unsigned char )179,      (unsigned char )178, 
        (unsigned char )178,      (unsigned char )178,      (unsigned char )178,      (unsigned char )178, 
        (unsigned char )178,      (unsigned char )178,      (unsigned char )178,      (unsigned char )178, 
        (unsigned char )178,      (unsigned char )178,      (unsigned char )178,      (unsigned char )178, 
        (unsigned char )178,      (unsigned char )178,      (unsigned char )178,      (unsigned char )178, 
        (unsigned char )178,      (unsigned char )178,      (unsigned char )178,      (unsigned char )178, 
        (unsigned char )178,      (unsigned char )178,      (unsigned char )178,      (unsigned char )178, 
        (unsigned char )178,      (unsigned char )178,      (unsigned char )178,      (unsigned char )178, 
        (unsigned char )178,      (unsigned char )178,      (unsigned char )178,      (unsigned char )177, 
        (unsigned char )177,      (unsigned char )177,      (unsigned char )177,      (unsigned char )177, 
        (unsigned char )177,      (unsigned char )177,      (unsigned char )177,      (unsigned char )177, 
        (unsigned char )177,      (unsigned char )177,      (unsigned char )177,      (unsigned char )177, 
        (unsigned char )177,      (unsigned char )177,      (unsigned char )177,      (unsigned char )177, 
        (unsigned char )177,      (unsigned char )177,      (unsigned char )177,      (unsigned char )177, 
        (unsigned char )177,      (unsigned char )177,      (unsigned char )177,      (unsigned char )177, 
        (unsigned char )177,      (unsigned char )177,      (unsigned char )177,      (unsigned char )177, 
        (unsigned char )177,      (unsigned char )177,      (unsigned char )177,      (unsigned char )176, 
        (unsigned char )176,      (unsigned char )176,      (unsigned char )176,      (unsigned char )176, 
        (unsigned char )176,      (unsigned char )176,      (unsigned char )176,      (unsigned char )176, 
        (unsigned char )176,      (unsigned char )176,      (unsigned char )176,      (unsigned char )176, 
        (unsigned char )176,      (unsigned char )176,      (unsigned char )176,      (unsigned char )176, 
        (unsigned char )176,      (unsigned char )176,      (unsigned char )176,      (unsigned char )176, 
        (unsigned char )176,      (unsigned char )176,      (unsigned char )176,      (unsigned char )176, 
        (unsigned char )176,      (unsigned char )176,      (unsigned char )176,      (unsigned char )176, 
        (unsigned char )176,      (unsigned char )176,      (unsigned char )176,      (unsigned char )175, 
        (unsigned char )175,      (unsigned char )175,      (unsigned char )175,      (unsigned char )175, 
        (unsigned char )175,      (unsigned char )175,      (unsigned char )175,      (unsigned char )175, 
        (unsigned char )175,      (unsigned char )175,      (unsigned char )175,      (unsigned char )175, 
        (unsigned char )175,      (unsigned char )175,      (unsigned char )175,      (unsigned char )175, 
        (unsigned char )175,      (unsigned char )175,      (unsigned char )175,      (unsigned char )175, 
        (unsigned char )175,      (unsigned char )175,      (unsigned char )175,      (unsigned char )175, 
        (unsigned char )175,      (unsigned char )175,      (unsigned char )175,      (unsigned char )175, 
        (unsigned char )175,      (unsigned char )175,      (unsigned char )175,      (unsigned char )175, 
        (unsigned char )175,      (unsigned char )175,      (unsigned char )175,      (unsigned char )175, 
        (unsigned char )175,      (unsigned char )175,      (unsigned char )175,      (unsigned char )175, 
        (unsigned char )175,      (unsigned char )175,      (unsigned char )175,      (unsigned char )175, 
        (unsigned char )175,      (unsigned char )175,      (unsigned char )175,      (unsigned char )175, 
        (unsigned char )175,      (unsigned char )175,      (unsigned char )175,      (unsigned char )175, 
        (unsigned char )175,      (unsigned char )175,      (unsigned char )175,      (unsigned char )175, 
        (unsigned char )175,      (unsigned char )175,      (unsigned char )175,      (unsigned char )175, 
        (unsigned char )175,      (unsigned char )175,      (unsigned char )175,      (unsigned char )174, 
        (unsigned char )174,      (unsigned char )174,      (unsigned char )174,      (unsigned char )174, 
        (unsigned char )174,      (unsigned char )174,      (unsigned char )174,      (unsigned char )174, 
        (unsigned char )174,      (unsigned char )174,      (unsigned char )174,      (unsigned char )174, 
        (unsigned char )174,      (unsigned char )174,      (unsigned char )174,      (unsigned char )174, 
        (unsigned char )174,      (unsigned char )174,      (unsigned char )174,      (unsigned char )174, 
        (unsigned char )174,      (unsigned char )174,      (unsigned char )174,      (unsigned char )174, 
        (unsigned char )174,      (unsigned char )174,      (unsigned char )174,      (unsigned char )174, 
        (unsigned char )174,      (unsigned char )174,      (unsigned char )174,      (unsigned char )174, 
        (unsigned char )174,      (unsigned char )174,      (unsigned char )174,      (unsigned char )174, 
        (unsigned char )174,      (unsigned char )174,      (unsigned char )174,      (unsigned char )174, 
        (unsigned char )174,      (unsigned char )174,      (unsigned char )174,      (unsigned char )174, 
        (unsigned char )174,      (unsigned char )174,      (unsigned char )174,      (unsigned char )174, 
        (unsigned char )174,      (unsigned char )174,      (unsigned char )174,      (unsigned char )174, 
        (unsigned char )174,      (unsigned char )174,      (unsigned char )174,      (unsigned char )174, 
        (unsigned char )174,      (unsigned char )174,      (unsigned char )174,      (unsigned char )174, 
        (unsigned char )174,      (unsigned char )174,      (unsigned char )174,      (unsigned char )173, 
        (unsigned char )173,      (unsigned char )173,      (unsigned char )173,      (unsigned char )173, 
        (unsigned char )173,      (unsigned char )173,      (unsigned char )173,      (unsigned char )173, 
        (unsigned char )173,      (unsigned char )173,      (unsigned char )173,      (unsigned char )173, 
        (unsigned char )173,      (unsigned char )173,      (unsigned char )173,      (unsigned char )173, 
        (unsigned char )173,      (unsigned char )173,      (unsigned char )173,      (unsigned char )173, 
        (unsigned char )173,      (unsigned char )173,      (unsigned char )173,      (unsigned char )173, 
        (unsigned char )173,      (unsigned char )173,      (unsigned char )173,      (unsigned char )173, 
        (unsigned char )173,      (unsigned char )173,      (unsigned char )173,      (unsigned char )173, 
        (unsigned char )173,      (unsigned char )173,      (unsigned char )173,      (unsigned char )173, 
        (unsigned char )173,      (unsigned char )173,      (unsigned char )173,      (unsigned char )173, 
        (unsigned char )173,      (unsigned char )173,      (unsigned char )173,      (unsigned char )173, 
        (unsigned char )173,      (unsigned char )173,      (unsigned char )173,      (unsigned char )173, 
        (unsigned char )173,      (unsigned char )173,      (unsigned char )173,      (unsigned char )173, 
        (unsigned char )173,      (unsigned char )173,      (unsigned char )173,      (unsigned char )173, 
        (unsigned char )173,      (unsigned char )173,      (unsigned char )173,      (unsigned char )173, 
        (unsigned char )173,      (unsigned char )173,      (unsigned char )173,      (unsigned char )172, 
        (unsigned char )172,      (unsigned char )172,      (unsigned char )172,      (unsigned char )172, 
        (unsigned char )172,      (unsigned char )172,      (unsigned char )172,      (unsigned char )172, 
        (unsigned char )172,      (unsigned char )172,      (unsigned char )172,      (unsigned char )172, 
        (unsigned char )172,      (unsigned char )172,      (unsigned char )172,      (unsigned char )172, 
        (unsigned char )172,      (unsigned char )172,      (unsigned char )172,      (unsigned char )172, 
        (unsigned char )172,      (unsigned char )172,      (unsigned char )172,      (unsigned char )172, 
        (unsigned char )172,      (unsigned char )172,      (unsigned char )172,      (unsigned char )172, 
        (unsigned char )172,      (unsigned char )172,      (unsigned char )172,      (unsigned char )172, 
        (unsigned char )172,      (unsigned char )172,      (unsigned char )172,      (unsigned char )172, 
        (unsigned char )172,      (unsigned char )172,      (unsigned char )172,      (unsigned char )172, 
        (unsigned char )172,      (unsigned char )172,      (unsigned char )172,      (unsigned char )172, 
        (unsigned char )172,      (unsigned char )172,      (unsigned char )172,      (unsigned char )172, 
        (unsigned char )172,      (unsigned char )172,      (unsigned char )172,      (unsigned char )172, 
        (unsigned char )172,      (unsigned char )172,      (unsigned char )172,      (unsigned char )172, 
        (unsigned char )172,      (unsigned char )172,      (unsigned char )172,      (unsigned char )172, 
        (unsigned char )172,      (unsigned char )172,      (unsigned char )172,      (unsigned char )171, 
        (unsigned char )171,      (unsigned char )171,      (unsigned char )171,      (unsigned char )171, 
        (unsigned char )171,      (unsigned char )171,      (unsigned char )171,      (unsigned char )171, 
        (unsigned char )171,      (unsigned char )171,      (unsigned char )171,      (unsigned char )171, 
        (unsigned char )171,      (unsigned char )171,      (unsigned char )171,      (unsigned char )171, 
        (unsigned char )171,      (unsigned char )171,      (unsigned char )171,      (unsigned char )171, 
        (unsigned char )171,      (unsigned char )171,      (unsigned char )171,      (unsigned char )171, 
        (unsigned char )171,      (unsigned char )171,      (unsigned char )171,      (unsigned char )171, 
        (unsigned char )171,      (unsigned char )171,      (unsigned char )171,      (unsigned char )171, 
        (unsigned char )171,      (unsigned char )171,      (unsigned char )171,      (unsigned char )171, 
        (unsigned char )171,      (unsigned char )171,      (unsigned char )171,      (unsigned char )171, 
        (unsigned char )171,      (unsigned char )171,      (unsigned char )171,      (unsigned char )171, 
        (unsigned char )171,      (unsigned char )171,      (unsigned char )171,      (unsigned char )171, 
        (unsigned char )171,      (unsigned char )171,      (unsigned char )171,      (unsigned char )171, 
        (unsigned char )171,      (unsigned char )171,      (unsigned char )171,      (unsigned char )171, 
        (unsigned char )171,      (unsigned char )171,      (unsigned char )171,      (unsigned char )171, 
        (unsigned char )171,      (unsigned char )171,      (unsigned char )171,      (unsigned char )170, 
        (unsigned char )170,      (unsigned char )170,      (unsigned char )170,      (unsigned char )170, 
        (unsigned char )170,      (unsigned char )170,      (unsigned char )170,      (unsigned char )170, 
        (unsigned char )170,      (unsigned char )170,      (unsigned char )170,      (unsigned char )170, 
        (unsigned char )170,      (unsigned char )170,      (unsigned char )170,      (unsigned char )170, 
        (unsigned char )170,      (unsigned char )170,      (unsigned char )170,      (unsigned char )170, 
        (unsigned char )170,      (unsigned char )170,      (unsigned char )170,      (unsigned char )170, 
        (unsigned char )170,      (unsigned char )170,      (unsigned char )170,      (unsigned char )170, 
        (unsigned char )170,      (unsigned char )170,      (unsigned char )170,      (unsigned char )170, 
        (unsigned char )170,      (unsigned char )170,      (unsigned char )170,      (unsigned char )170, 
        (unsigned char )170,      (unsigned char )170,      (unsigned char )170,      (unsigned char )170, 
        (unsigned char )170,      (unsigned char )170,      (unsigned char )170,      (unsigned char )170, 
        (unsigned char )170,      (unsigned char )170,      (unsigned char )170,      (unsigned char )170, 
        (unsigned char )170,      (unsigned char )170,      (unsigned char )170,      (unsigned char )170, 
        (unsigned char )170,      (unsigned char )170,      (unsigned char )170,      (unsigned char )170, 
        (unsigned char )170,      (unsigned char )170,      (unsigned char )170,      (unsigned char )170, 
        (unsigned char )170,      (unsigned char )170,      (unsigned char )170,      (unsigned char )169, 
        (unsigned char )169,      (unsigned char )169,      (unsigned char )169,      (unsigned char )169, 
        (unsigned char )169,      (unsigned char )169,      (unsigned char )169,      (unsigned char )169, 
        (unsigned char )169,      (unsigned char )169,      (unsigned char )169,      (unsigned char )169, 
        (unsigned char )169,      (unsigned char )169,      (unsigned char )169,      (unsigned char )169, 
        (unsigned char )169,      (unsigned char )169,      (unsigned char )169,      (unsigned char )169, 
        (unsigned char )169,      (unsigned char )169,      (unsigned char )169,      (unsigned char )169, 
        (unsigned char )169,      (unsigned char )169,      (unsigned char )169,      (unsigned char )169, 
        (unsigned char )169,      (unsigned char )169,      (unsigned char )169,      (unsigned char )169, 
        (unsigned char )169,      (unsigned char )169,      (unsigned char )169,      (unsigned char )169, 
        (unsigned char )169,      (unsigned char )169,      (unsigned char )169,      (unsigned char )169, 
        (unsigned char )169,      (unsigned char )169,      (unsigned char )169,      (unsigned char )169, 
        (unsigned char )169,      (unsigned char )169,      (unsigned char )169,      (unsigned char )169, 
        (unsigned char )169,      (unsigned char )169,      (unsigned char )169,      (unsigned char )169, 
        (unsigned char )169,      (unsigned char )169,      (unsigned char )169,      (unsigned char )169, 
        (unsigned char )169,      (unsigned char )169,      (unsigned char )169,      (unsigned char )169, 
        (unsigned char )169,      (unsigned char )169,      (unsigned char )169,      (unsigned char )168, 
        (unsigned char )168,      (unsigned char )168,      (unsigned char )168,      (unsigned char )168, 
        (unsigned char )168,      (unsigned char )168,      (unsigned char )168,      (unsigned char )168, 
        (unsigned char )168,      (unsigned char )168,      (unsigned char )168,      (unsigned char )168, 
        (unsigned char )168,      (unsigned char )168,      (unsigned char )168,      (unsigned char )168, 
        (unsigned char )168,      (unsigned char )168,      (unsigned char )168,      (unsigned char )168, 
        (unsigned char )168,      (unsigned char )168,      (unsigned char )168,      (unsigned char )168, 
        (unsigned char )168,      (unsigned char )168,      (unsigned char )168,      (unsigned char )168, 
        (unsigned char )168,      (unsigned char )168,      (unsigned char )168,      (unsigned char )168, 
        (unsigned char )168,      (unsigned char )168,      (unsigned char )168,      (unsigned char )168, 
        (unsigned char )168,      (unsigned char )168,      (unsigned char )168,      (unsigned char )168, 
        (unsigned char )168,      (unsigned char )168,      (unsigned char )168,      (unsigned char )168, 
        (unsigned char )168,      (unsigned char )168,      (unsigned char )168,      (unsigned char )168, 
        (unsigned char )168,      (unsigned char )168,      (unsigned char )168,      (unsigned char )168, 
        (unsigned char )168,      (unsigned char )168,      (unsigned char )168,      (unsigned char )168, 
        (unsigned char )168,      (unsigned char )168,      (unsigned char )168,      (unsigned char )168, 
        (unsigned char )168,      (unsigned char )168,      (unsigned char )168,      (unsigned char )167, 
        (unsigned char )167,      (unsigned char )167,      (unsigned char )167,      (unsigned char )167, 
        (unsigned char )167,      (unsigned char )167,      (unsigned char )167,      (unsigned char )167, 
        (unsigned char )167,      (unsigned char )167,      (unsigned char )167,      (unsigned char )167, 
        (unsigned char )167,      (unsigned char )167,      (unsigned char )167,      (unsigned char )167, 
        (unsigned char )167,      (unsigned char )167,      (unsigned char )167,      (unsigned char )167, 
        (unsigned char )167,      (unsigned char )167,      (unsigned char )167,      (unsigned char )167, 
        (unsigned char )167,      (unsigned char )167,      (unsigned char )167,      (unsigned char )167, 
        (unsigned char )167,      (unsigned char )167,      (unsigned char )167,      (unsigned char )167, 
        (unsigned char )167,      (unsigned char )167,      (unsigned char )167,      (unsigned char )167, 
        (unsigned char )167,      (unsigned char )167,      (unsigned char )167,      (unsigned char )167, 
        (unsigned char )167,      (unsigned char )167,      (unsigned char )167,      (unsigned char )167, 
        (unsigned char )167,      (unsigned char )167,      (unsigned char )167,      (unsigned char )167, 
        (unsigned char )167,      (unsigned char )167,      (unsigned char )167,      (unsigned char )167, 
        (unsigned char )167,      (unsigned char )167,      (unsigned char )167,      (unsigned char )167, 
        (unsigned char )167,      (unsigned char )167,      (unsigned char )167,      (unsigned char )167, 
        (unsigned char )167,      (unsigned char )167,      (unsigned char )167,      (unsigned char )166, 
        (unsigned char )166,      (unsigned char )166,      (unsigned char )166,      (unsigned char )166, 
        (unsigned char )166,      (unsigned char )166,      (unsigned char )166,      (unsigned char )166, 
        (unsigned char )166,      (unsigned char )166,      (unsigned char )166,      (unsigned char )166, 
        (unsigned char )166,      (unsigned char )166,      (unsigned char )166,      (unsigned char )166, 
        (unsigned char )166,      (unsigned char )166,      (unsigned char )166,      (unsigned char )166, 
        (unsigned char )166,      (unsigned char )166,      (unsigned char )166,      (unsigned char )166, 
        (unsigned char )166,      (unsigned char )166,      (unsigned char )166,      (unsigned char )166, 
        (unsigned char )166,      (unsigned char )166,      (unsigned char )166,      (unsigned char )166, 
        (unsigned char )166,      (unsigned char )166,      (unsigned char )166,      (unsigned char )166, 
        (unsigned char )166,      (unsigned char )166,      (unsigned char )166,      (unsigned char )166, 
        (unsigned char )166,      (unsigned char )166,      (unsigned char )166,      (unsigned char )166, 
        (unsigned char )166,      (unsigned char )166,      (unsigned char )166,      (unsigned char )166, 
        (unsigned char )166,      (unsigned char )166,      (unsigned char )166,      (unsigned char )166, 
        (unsigned char )166,      (unsigned char )166,      (unsigned char )166,      (unsigned char )166, 
        (unsigned char )166,      (unsigned char )166,      (unsigned char )166,      (unsigned char )166, 
        (unsigned char )166,      (unsigned char )166,      (unsigned char )166,      (unsigned char )165, 
        (unsigned char )165,      (unsigned char )165,      (unsigned char )165,      (unsigned char )165, 
        (unsigned char )165,      (unsigned char )165,      (unsigned char )165,      (unsigned char )165, 
        (unsigned char )165,      (unsigned char )165,      (unsigned char )165,      (unsigned char )165, 
        (unsigned char )165,      (unsigned char )165,      (unsigned char )165,      (unsigned char )165, 
        (unsigned char )165,      (unsigned char )165,      (unsigned char )165,      (unsigned char )165, 
        (unsigned char )165,      (unsigned char )165,      (unsigned char )165,      (unsigned char )165, 
        (unsigned char )165,      (unsigned char )165,      (unsigned char )165,      (unsigned char )165, 
        (unsigned char )165,      (unsigned char )165,      (unsigned char )165,      (unsigned char )165, 
        (unsigned char )165,      (unsigned char )165,      (unsigned char )165,      (unsigned char )165, 
        (unsigned char )165,      (unsigned char )165,      (unsigned char )165,      (unsigned char )165, 
        (unsigned char )165,      (unsigned char )165,      (unsigned char )165,      (unsigned char )165, 
        (unsigned char )165,      (unsigned char )165,      (unsigned char )165,      (unsigned char )165, 
        (unsigned char )165,      (unsigned char )165,      (unsigned char )165,      (unsigned char )165, 
        (unsigned char )165,      (unsigned char )165,      (unsigned char )165,      (unsigned char )165, 
        (unsigned char )165,      (unsigned char )165,      (unsigned char )165,      (unsigned char )165, 
        (unsigned char )165,      (unsigned char )165,      (unsigned char )165,      (unsigned char )164, 
        (unsigned char )164,      (unsigned char )164,      (unsigned char )164,      (unsigned char )164, 
        (unsigned char )164,      (unsigned char )164,      (unsigned char )164,      (unsigned char )164, 
        (unsigned char )164,      (unsigned char )164,      (unsigned char )164,      (unsigned char )164, 
        (unsigned char )164,      (unsigned char )164,      (unsigned char )164,      (unsigned char )164, 
        (unsigned char )164,      (unsigned char )164,      (unsigned char )164,      (unsigned char )164, 
        (unsigned char )164,      (unsigned char )164,      (unsigned char )164,      (unsigned char )164, 
        (unsigned char )164,      (unsigned char )164,      (unsigned char )164,      (unsigned char )164, 
        (unsigned char )164,      (unsigned char )164,      (unsigned char )164,      (unsigned char )164, 
        (unsigned char )164,      (unsigned char )164,      (unsigned char )164,      (unsigned char )164, 
        (unsigned char )164,      (unsigned char )164,      (unsigned char )164,      (unsigned char )164, 
        (unsigned char )164,      (unsigned char )164,      (unsigned char )164,      (unsigned char )164, 
        (unsigned char )164,      (unsigned char )164,      (unsigned char )164,      (unsigned char )164, 
        (unsigned char )164,      (unsigned char )164,      (unsigned char )164,      (unsigned char )164, 
        (unsigned char )164,      (unsigned char )164,      (unsigned char )164,      (unsigned char )164, 
        (unsigned char )164,      (unsigned char )164,      (unsigned char )164,      (unsigned char )164, 
        (unsigned char )164,      (unsigned char )164,      (unsigned char )164,      (unsigned char )163, 
        (unsigned char )163,      (unsigned char )163,      (unsigned char )163,      (unsigned char )163, 
        (unsigned char )163,      (unsigned char )163,      (unsigned char )163,      (unsigned char )163, 
        (unsigned char )163,      (unsigned char )163,      (unsigned char )163,      (unsigned char )163, 
        (unsigned char )163,      (unsigned char )163,      (unsigned char )163,      (unsigned char )163, 
        (unsigned char )163,      (unsigned char )163,      (unsigned char )163,      (unsigned char )163, 
        (unsigned char )163,      (unsigned char )163,      (unsigned char )163,      (unsigned char )163, 
        (unsigned char )163,      (unsigned char )163,      (unsigned char )163,      (unsigned char )163, 
        (unsigned char )163,      (unsigned char )163,      (unsigned char )163,      (unsigned char )163, 
        (unsigned char )163,      (unsigned char )163,      (unsigned char )163,      (unsigned char )163, 
        (unsigned char )163,      (unsigned char )163,      (unsigned char )163,      (unsigned char )163, 
        (unsigned char )163,      (unsigned char )163,      (unsigned char )163,      (unsigned char )163, 
        (unsigned char )163,      (unsigned char )163,      (unsigned char )163,      (unsigned char )163, 
        (unsigned char )163,      (unsigned char )163,      (unsigned char )163,      (unsigned char )163, 
        (unsigned char )163,      (unsigned char )163,      (unsigned char )163,      (unsigned char )163, 
        (unsigned char )163,      (unsigned char )163,      (unsigned char )163,      (unsigned char )163, 
        (unsigned char )163,      (unsigned char )163,      (unsigned char )163,      (unsigned char )162, 
        (unsigned char )162,      (unsigned char )162,      (unsigned char )162,      (unsigned char )162, 
        (unsigned char )162,      (unsigned char )162,      (unsigned char )162,      (unsigned char )162, 
        (unsigned char )162,      (unsigned char )162,      (unsigned char )162,      (unsigned char )162, 
        (unsigned char )162,      (unsigned char )162,      (unsigned char )162,      (unsigned char )162, 
        (unsigned char )162,      (unsigned char )162,      (unsigned char )162,      (unsigned char )162, 
        (unsigned char )162,      (unsigned char )162,      (unsigned char )162,      (unsigned char )162, 
        (unsigned char )162,      (unsigned char )162,      (unsigned char )162,      (unsigned char )162, 
        (unsigned char )162,      (unsigned char )162,      (unsigned char )162,      (unsigned char )162, 
        (unsigned char )162,      (unsigned char )162,      (unsigned char )162,      (unsigned char )162, 
        (unsigned char )162,      (unsigned char )162,      (unsigned char )162,      (unsigned char )162, 
        (unsigned char )162,      (unsigned char )162,      (unsigned char )162,      (unsigned char )162, 
        (unsigned char )162,      (unsigned char )162,      (unsigned char )162,      (unsigned char )162, 
        (unsigned char )162,      (unsigned char )162,      (unsigned char )162,      (unsigned char )162, 
        (unsigned char )162,      (unsigned char )162,      (unsigned char )162,      (unsigned char )162, 
        (unsigned char )162,      (unsigned char )162,      (unsigned char )162,      (unsigned char )162, 
        (unsigned char )162,      (unsigned char )162,      (unsigned char )162,      (unsigned char )161, 
        (unsigned char )161,      (unsigned char )161,      (unsigned char )161,      (unsigned char )161, 
        (unsigned char )161,      (unsigned char )161,      (unsigned char )161,      (unsigned char )161, 
        (unsigned char )161,      (unsigned char )161,      (unsigned char )161,      (unsigned char )161, 
        (unsigned char )161,      (unsigned char )161,      (unsigned char )161,      (unsigned char )161, 
        (unsigned char )161,      (unsigned char )161,      (unsigned char )161,      (unsigned char )161, 
        (unsigned char )161,      (unsigned char )161,      (unsigned char )161,      (unsigned char )161, 
        (unsigned char )161,      (unsigned char )161,      (unsigned char )161,      (unsigned char )161, 
        (unsigned char )161,      (unsigned char )161,      (unsigned char )161,      (unsigned char )161, 
        (unsigned char )161,      (unsigned char )161,      (unsigned char )161,      (unsigned char )161, 
        (unsigned char )161,      (unsigned char )161,      (unsigned char )161,      (unsigned char )161, 
        (unsigned char )161,      (unsigned char )161,      (unsigned char )161,      (unsigned char )161, 
        (unsigned char )161,      (unsigned char )161,      (unsigned char )161,      (unsigned char )161, 
        (unsigned char )161,      (unsigned char )161,      (unsigned char )161,      (unsigned char )161, 
        (unsigned char )161,      (unsigned char )161,      (unsigned char )161,      (unsigned char )161, 
        (unsigned char )161,      (unsigned char )161,      (unsigned char )161,      (unsigned char )161, 
        (unsigned char )161,      (unsigned char )161,      (unsigned char )161,      (unsigned char )160, 
        (unsigned char )160,      (unsigned char )160,      (unsigned char )160,      (unsigned char )160, 
        (unsigned char )160,      (unsigned char )160,      (unsigned char )160,      (unsigned char )160, 
        (unsigned char )160,      (unsigned char )160,      (unsigned char )160,      (unsigned char )160, 
        (unsigned char )160,      (unsigned char )160,      (unsigned char )160,      (unsigned char )160, 
        (unsigned char )160,      (unsigned char )160,      (unsigned char )160,      (unsigned char )160, 
        (unsigned char )160,      (unsigned char )160,      (unsigned char )160,      (unsigned char )160, 
        (unsigned char )160,      (unsigned char )160,      (unsigned char )160,      (unsigned char )160, 
        (unsigned char )160,      (unsigned char )160,      (unsigned char )160,      (unsigned char )160, 
        (unsigned char )160,      (unsigned char )160,      (unsigned char )160,      (unsigned char )160, 
        (unsigned char )160,      (unsigned char )160,      (unsigned char )160,      (unsigned char )160, 
        (unsigned char )160,      (unsigned char )160,      (unsigned char )160,      (unsigned char )160, 
        (unsigned char )160,      (unsigned char )160,      (unsigned char )160,      (unsigned char )160, 
        (unsigned char )160,      (unsigned char )160,      (unsigned char )160,      (unsigned char )160, 
        (unsigned char )160,      (unsigned char )160,      (unsigned char )160,      (unsigned char )160, 
        (unsigned char )160,      (unsigned char )160,      (unsigned char )160,      (unsigned char )160, 
        (unsigned char )160,      (unsigned char )160,      (unsigned char )160,      (unsigned char )159, 
        (unsigned char )159,      (unsigned char )159,      (unsigned char )159,      (unsigned char )159, 
        (unsigned char )159,      (unsigned char )159,      (unsigned char )159,      (unsigned char )159, 
        (unsigned char )159,      (unsigned char )159,      (unsigned char )159,      (unsigned char )159, 
        (unsigned char )159,      (unsigned char )159,      (unsigned char )159,      (unsigned char )159, 
        (unsigned char )159,      (unsigned char )159,      (unsigned char )159,      (unsigned char )159, 
        (unsigned char )159,      (unsigned char )159,      (unsigned char )159,      (unsigned char )159, 
        (unsigned char )159,      (unsigned char )159,      (unsigned char )159,      (unsigned char )159, 
        (unsigned char )159,      (unsigned char )159,      (unsigned char )159,      (unsigned char )159, 
        (unsigned char )159,      (unsigned char )159,      (unsigned char )159,      (unsigned char )159, 
        (unsigned char )159,      (unsigned char )159,      (unsigned char )159,      (unsigned char )159, 
        (unsigned char )159,      (unsigned char )159,      (unsigned char )159,      (unsigned char )159, 
        (unsigned char )159,      (unsigned char )159,      (unsigned char )159,      (unsigned char )159, 
        (unsigned char )159,      (unsigned char )159,      (unsigned char )159,      (unsigned char )159, 
        (unsigned char )159,      (unsigned char )159,      (unsigned char )159,      (unsigned char )159, 
        (unsigned char )159,      (unsigned char )159,      (unsigned char )159,      (unsigned char )159, 
        (unsigned char )159,      (unsigned char )159,      (unsigned char )159,      (unsigned char )159, 
        (unsigned char )159,      (unsigned char )159,      (unsigned char )159,      (unsigned char )159, 
        (unsigned char )159,      (unsigned char )159,      (unsigned char )159,      (unsigned char )159, 
        (unsigned char )159,      (unsigned char )159,      (unsigned char )159,      (unsigned char )159, 
        (unsigned char )159,      (unsigned char )159,      (unsigned char )159,      (unsigned char )159, 
        (unsigned char )159,      (unsigned char )159,      (unsigned char )159,      (unsigned char )159, 
        (unsigned char )159,      (unsigned char )159,      (unsigned char )159,      (unsigned char )159, 
        (unsigned char )159,      (unsigned char )159,      (unsigned char )159,      (unsigned char )159, 
        (unsigned char )159,      (unsigned char )159,      (unsigned char )159,      (unsigned char )159, 
        (unsigned char )159,      (unsigned char )159,      (unsigned char )159,      (unsigned char )159, 
        (unsigned char )159,      (unsigned char )159,      (unsigned char )159,      (unsigned char )159, 
        (unsigned char )159,      (unsigned char )159,      (unsigned char )159,      (unsigned char )159, 
        (unsigned char )159,      (unsigned char )159,      (unsigned char )159,      (unsigned char )159, 
        (unsigned char )159,      (unsigned char )159,      (unsigned char )159,      (unsigned char )159, 
        (unsigned char )159,      (unsigned char )159,      (unsigned char )159,      (unsigned char )159, 
        (unsigned char )159,      (unsigned char )159,      (unsigned char )159,      (unsigned char )159, 
        (unsigned char )159,      (unsigned char )159,      (unsigned char )159,      (unsigned char )158, 
        (unsigned char )158,      (unsigned char )158,      (unsigned char )158,      (unsigned char )158, 
        (unsigned char )158,      (unsigned char )158,      (unsigned char )158,      (unsigned char )158, 
        (unsigned char )158,      (unsigned char )158,      (unsigned char )158,      (unsigned char )158, 
        (unsigned char )158,      (unsigned char )158,      (unsigned char )158,      (unsigned char )158, 
        (unsigned char )158,      (unsigned char )158,      (unsigned char )158,      (unsigned char )158, 
        (unsigned char )158,      (unsigned char )158,      (unsigned char )158,      (unsigned char )158, 
        (unsigned char )158,      (unsigned char )158,      (unsigned char )158,      (unsigned char )158, 
        (unsigned char )158,      (unsigned char )158,      (unsigned char )158,      (unsigned char )158, 
        (unsigned char )158,      (unsigned char )158,      (unsigned char )158,      (unsigned char )158, 
        (unsigned char )158,      (unsigned char )158,      (unsigned char )158,      (unsigned char )158, 
        (unsigned char )158,      (unsigned char )158,      (unsigned char )158,      (unsigned char )158, 
        (unsigned char )158,      (unsigned char )158,      (unsigned char )158,      (unsigned char )158, 
        (unsigned char )158,      (unsigned char )158,      (unsigned char )158,      (unsigned char )158, 
        (unsigned char )158,      (unsigned char )158,      (unsigned char )158,      (unsigned char )158, 
        (unsigned char )158,      (unsigned char )158,      (unsigned char )158,      (unsigned char )158, 
        (unsigned char )158,      (unsigned char )158,      (unsigned char )158,      (unsigned char )158, 
        (unsigned char )158,      (unsigned char )158,      (unsigned char )158,      (unsigned char )158, 
        (unsigned char )158,      (unsigned char )158,      (unsigned char )158,      (unsigned char )158, 
        (unsigned char )158,      (unsigned char )158,      (unsigned char )158,      (unsigned char )158, 
        (unsigned char )158,      (unsigned char )158,      (unsigned char )158,      (unsigned char )158, 
        (unsigned char )158,      (unsigned char )158,      (unsigned char )158,      (unsigned char )158, 
        (unsigned char )158,      (unsigned char )158,      (unsigned char )158,      (unsigned char )158, 
        (unsigned char )158,      (unsigned char )158,      (unsigned char )158,      (unsigned char )158, 
        (unsigned char )158,      (unsigned char )158,      (unsigned char )158,      (unsigned char )158, 
        (unsigned char )158,      (unsigned char )158,      (unsigned char )158,      (unsigned char )158, 
        (unsigned char )158,      (unsigned char )158,      (unsigned char )158,      (unsigned char )158, 
        (unsigned char )158,      (unsigned char )158,      (unsigned char )158,      (unsigned char )158, 
        (unsigned char )158,      (unsigned char )158,      (unsigned char )158,      (unsigned char )158, 
        (unsigned char )158,      (unsigned char )158,      (unsigned char )158,      (unsigned char )158, 
        (unsigned char )158,      (unsigned char )158,      (unsigned char )158,      (unsigned char )158, 
        (unsigned char )158,      (unsigned char )158,      (unsigned char )158,      (unsigned char )158, 
        (unsigned char )158,      (unsigned char )158,      (unsigned char )158,      (unsigned char )157, 
        (unsigned char )157,      (unsigned char )157,      (unsigned char )157,      (unsigned char )157, 
        (unsigned char )157,      (unsigned char )157,      (unsigned char )157,      (unsigned char )157, 
        (unsigned char )157,      (unsigned char )157,      (unsigned char )157,      (unsigned char )157, 
        (unsigned char )157,      (unsigned char )157,      (unsigned char )157,      (unsigned char )157, 
        (unsigned char )157,      (unsigned char )157,      (unsigned char )157,      (unsigned char )157, 
        (unsigned char )157,      (unsigned char )157,      (unsigned char )157,      (unsigned char )157, 
        (unsigned char )157,      (unsigned char )157,      (unsigned char )157,      (unsigned char )157, 
        (unsigned char )157,      (unsigned char )157,      (unsigned char )157,      (unsigned char )157, 
        (unsigned char )157,      (unsigned char )157,      (unsigned char )157,      (unsigned char )157, 
        (unsigned char )157,      (unsigned char )157,      (unsigned char )157,      (unsigned char )157, 
        (unsigned char )157,      (unsigned char )157,      (unsigned char )157,      (unsigned char )157, 
        (unsigned char )157,      (unsigned char )157,      (unsigned char )157,      (unsigned char )157, 
        (unsigned char )157,      (unsigned char )157,      (unsigned char )157,      (unsigned char )157, 
        (unsigned char )157,      (unsigned char )157,      (unsigned char )157,      (unsigned char )157, 
        (unsigned char )157,      (unsigned char )157,      (unsigned char )157,      (unsigned char )157, 
        (unsigned char )157,      (unsigned char )157,      (unsigned char )157,      (unsigned char )157, 
        (unsigned char )157,      (unsigned char )157,      (unsigned char )157,      (unsigned char )157, 
        (unsigned char )157,      (unsigned char )157,      (unsigned char )157,      (unsigned char )157, 
        (unsigned char )157,      (unsigned char )157,      (unsigned char )157,      (unsigned char )157, 
        (unsigned char )157,      (unsigned char )157,      (unsigned char )157,      (unsigned char )157, 
        (unsigned char )157,      (unsigned char )157,      (unsigned char )157,      (unsigned char )157, 
        (unsigned char )157,      (unsigned char )157,      (unsigned char )157,      (unsigned char )157, 
        (unsigned char )157,      (unsigned char )157,      (unsigned char )157,      (unsigned char )157, 
        (unsigned char )157,      (unsigned char )157,      (unsigned char )157,      (unsigned char )157, 
        (unsigned char )157,      (unsigned char )157,      (unsigned char )157,      (unsigned char )157, 
        (unsigned char )157,      (unsigned char )157,      (unsigned char )157,      (unsigned char )157, 
        (unsigned char )157,      (unsigned char )157,      (unsigned char )157,      (unsigned char )157, 
        (unsigned char )157,      (unsigned char )157,      (unsigned char )157,      (unsigned char )157, 
        (unsigned char )157,      (unsigned char )157,      (unsigned char )157,      (unsigned char )157, 
        (unsigned char )157,      (unsigned char )157,      (unsigned char )157,      (unsigned char )157, 
        (unsigned char )157,      (unsigned char )157,      (unsigned char )157,      (unsigned char )157, 
        (unsigned char )157,      (unsigned char )157,      (unsigned char )157,      (unsigned char )156, 
        (unsigned char )156,      (unsigned char )156,      (unsigned char )156,      (unsigned char )156, 
        (unsigned char )156,      (unsigned char )156,      (unsigned char )156,      (unsigned char )156, 
        (unsigned char )156,      (unsigned char )156,      (unsigned char )156,      (unsigned char )156, 
        (unsigned char )156,      (unsigned char )156,      (unsigned char )156,      (unsigned char )156, 
        (unsigned char )156,      (unsigned char )156,      (unsigned char )156,      (unsigned char )156, 
        (unsigned char )156,      (unsigned char )156,      (unsigned char )156,      (unsigned char )156, 
        (unsigned char )156,      (unsigned char )156,      (unsigned char )156,      (unsigned char )156, 
        (unsigned char )156,      (unsigned char )156,      (unsigned char )156,      (unsigned char )156, 
        (unsigned char )156,      (unsigned char )156,      (unsigned char )156,      (unsigned char )156, 
        (unsigned char )156,      (unsigned char )156,      (unsigned char )156,      (unsigned char )156, 
        (unsigned char )156,      (unsigned char )156,      (unsigned char )156,      (unsigned char )156, 
        (unsigned char )156,      (unsigned char )156,      (unsigned char )156,      (unsigned char )156, 
        (unsigned char )156,      (unsigned char )156,      (unsigned char )156,      (unsigned char )156, 
        (unsigned char )156,      (unsigned char )156,      (unsigned char )156,      (unsigned char )156, 
        (unsigned char )156,      (unsigned char )156,      (unsigned char )156,      (unsigned char )156, 
        (unsigned char )156,      (unsigned char )156,      (unsigned char )156,      (unsigned char )156, 
        (unsigned char )156,      (unsigned char )156,      (unsigned char )156,      (unsigned char )156, 
        (unsigned char )156,      (unsigned char )156,      (unsigned char )156,      (unsigned char )156, 
        (unsigned char )156,      (unsigned char )156,      (unsigned char )156,      (unsigned char )156, 
        (unsigned char )156,      (unsigned char )156,      (unsigned char )156,      (unsigned char )156, 
        (unsigned char )156,      (unsigned char )156,      (unsigned char )156,      (unsigned char )156, 
        (unsigned char )156,      (unsigned char )156,      (unsigned char )156,      (unsigned char )156, 
        (unsigned char )156,      (unsigned char )156,      (unsigned char )156,      (unsigned char )156, 
        (unsigned char )156,      (unsigned char )156,      (unsigned char )156,      (unsigned char )156, 
        (unsigned char )156,      (unsigned char )156,      (unsigned char )156,      (unsigned char )156, 
        (unsigned char )156,      (unsigned char )156,      (unsigned char )156,      (unsigned char )156, 
        (unsigned char )156,      (unsigned char )156,      (unsigned char )156,      (unsigned char )156, 
        (unsigned char )156,      (unsigned char )156,      (unsigned char )156,      (unsigned char )156, 
        (unsigned char )156,      (unsigned char )156,      (unsigned char )156,      (unsigned char )156, 
        (unsigned char )156,      (unsigned char )156,      (unsigned char )156,      (unsigned char )156, 
        (unsigned char )156,      (unsigned char )156,      (unsigned char )156,      (unsigned char )156, 
        (unsigned char )156,      (unsigned char )156,      (unsigned char )156,      (unsigned char )155, 
        (unsigned char )155,      (unsigned char )155,      (unsigned char )155,      (unsigned char )155, 
        (unsigned char )155,      (unsigned char )155,      (unsigned char )155,      (unsigned char )155, 
        (unsigned char )155,      (unsigned char )155,      (unsigned char )155,      (unsigned char )155, 
        (unsigned char )155,      (unsigned char )155,      (unsigned char )155,      (unsigned char )155, 
        (unsigned char )155,      (unsigned char )155,      (unsigned char )155,      (unsigned char )155, 
        (unsigned char )155,      (unsigned char )155,      (unsigned char )155,      (unsigned char )155, 
        (unsigned char )155,      (unsigned char )155,      (unsigned char )155,      (unsigned char )155, 
        (unsigned char )155,      (unsigned char )155,      (unsigned char )155,      (unsigned char )155, 
        (unsigned char )155,      (unsigned char )155,      (unsigned char )155,      (unsigned char )155, 
        (unsigned char )155,      (unsigned char )155,      (unsigned char )155,      (unsigned char )155, 
        (unsigned char )155,      (unsigned char )155,      (unsigned char )155,      (unsigned char )155, 
        (unsigned char )155,      (unsigned char )155,      (unsigned char )155,      (unsigned char )155, 
        (unsigned char )155,      (unsigned char )155,      (unsigned char )155,      (unsigned char )155, 
        (unsigned char )155,      (unsigned char )155,      (unsigned char )155,      (unsigned char )155, 
        (unsigned char )155,      (unsigned char )155,      (unsigned char )155,      (unsigned char )155, 
        (unsigned char )155,      (unsigned char )155,      (unsigned char )155,      (unsigned char )155, 
        (unsigned char )155,      (unsigned char )155,      (unsigned char )155,      (unsigned char )155, 
        (unsigned char )155,      (unsigned char )155,      (unsigned char )155,      (unsigned char )155, 
        (unsigned char )155,      (unsigned char )155,      (unsigned char )155,      (unsigned char )155, 
        (unsigned char )155,      (unsigned char )155,      (unsigned char )155,      (unsigned char )155, 
        (unsigned char )155,      (unsigned char )155,      (unsigned char )155,      (unsigned char )155, 
        (unsigned char )155,      (unsigned char )155,      (unsigned char )155,      (unsigned char )155, 
        (unsigned char )155,      (unsigned char )155,      (unsigned char )155,      (unsigned char )155, 
        (unsigned char )155,      (unsigned char )155,      (unsigned char )155,      (unsigned char )155, 
        (unsigned char )155,      (unsigned char )155,      (unsigned char )155,      (unsigned char )155, 
        (unsigned char )155,      (unsigned char )155,      (unsigned char )155,      (unsigned char )155, 
        (unsigned char )155,      (unsigned char )155,      (unsigned char )155,      (unsigned char )155, 
        (unsigned char )155,      (unsigned char )155,      (unsigned char )155,      (unsigned char )155, 
        (unsigned char )155,      (unsigned char )155,      (unsigned char )155,      (unsigned char )155, 
        (unsigned char )155,      (unsigned char )155,      (unsigned char )155,      (unsigned char )155, 
        (unsigned char )155,      (unsigned char )155,      (unsigned char )155,      (unsigned char )155, 
        (unsigned char )155,      (unsigned char )155,      (unsigned char )155,      (unsigned char )154, 
        (unsigned char )154,      (unsigned char )154,      (unsigned char )154,      (unsigned char )154, 
        (unsigned char )154,      (unsigned char )154,      (unsigned char )154,      (unsigned char )154, 
        (unsigned char )154,      (unsigned char )154,      (unsigned char )154,      (unsigned char )154, 
        (unsigned char )154,      (unsigned char )154,      (unsigned char )154,      (unsigned char )154, 
        (unsigned char )154,      (unsigned char )154,      (unsigned char )154,      (unsigned char )154, 
        (unsigned char )154,      (unsigned char )154,      (unsigned char )154,      (unsigned char )154, 
        (unsigned char )154,      (unsigned char )154,      (unsigned char )154,      (unsigned char )154, 
        (unsigned char )154,      (unsigned char )154,      (unsigned char )154,      (unsigned char )154, 
        (unsigned char )154,      (unsigned char )154,      (unsigned char )154,      (unsigned char )154, 
        (unsigned char )154,      (unsigned char )154,      (unsigned char )154,      (unsigned char )154, 
        (unsigned char )154,      (unsigned char )154,      (unsigned char )154,      (unsigned char )154, 
        (unsigned char )154,      (unsigned char )154,      (unsigned char )154,      (unsigned char )154, 
        (unsigned char )154,      (unsigned char )154,      (unsigned char )154,      (unsigned char )154, 
        (unsigned char )154,      (unsigned char )154,      (unsigned char )154,      (unsigned char )154, 
        (unsigned char )154,      (unsigned char )154,      (unsigned char )154,      (unsigned char )154, 
        (unsigned char )154,      (unsigned char )154,      (unsigned char )154,      (unsigned char )154, 
        (unsigned char )154,      (unsigned char )154,      (unsigned char )154,      (unsigned char )154, 
        (unsigned char )154,      (unsigned char )154,      (unsigned char )154,      (unsigned char )154, 
        (unsigned char )154,      (unsigned char )154,      (unsigned char )154,      (unsigned char )154, 
        (unsigned char )154,      (unsigned char )154,      (unsigned char )154,      (unsigned char )154, 
        (unsigned char )154,      (unsigned char )154,      (unsigned char )154,      (unsigned char )154, 
        (unsigned char )154,      (unsigned char )154,      (unsigned char )154,      (unsigned char )154, 
        (unsigned char )154,      (unsigned char )154,      (unsigned char )154,      (unsigned char )154, 
        (unsigned char )154,      (unsigned char )154,      (unsigned char )154,      (unsigned char )154, 
        (unsigned char )154,      (unsigned char )154,      (unsigned char )154,      (unsigned char )154, 
        (unsigned char )154,      (unsigned char )154,      (unsigned char )154,      (unsigned char )154, 
        (unsigned char )154,      (unsigned char )154,      (unsigned char )154,      (unsigned char )154, 
        (unsigned char )154,      (unsigned char )154,      (unsigned char )154,      (unsigned char )154, 
        (unsigned char )154,      (unsigned char )154,      (unsigned char )154,      (unsigned char )154, 
        (unsigned char )154,      (unsigned char )154,      (unsigned char )154,      (unsigned char )154, 
        (unsigned char )154,      (unsigned char )154,      (unsigned char )154,      (unsigned char )154, 
        (unsigned char )154,      (unsigned char )154,      (unsigned char )154,      (unsigned char )153, 
        (unsigned char )153,      (unsigned char )153,      (unsigned char )153,      (unsigned char )153, 
        (unsigned char )153,      (unsigned char )153,      (unsigned char )153,      (unsigned char )153, 
        (unsigned char )153,      (unsigned char )153,      (unsigned char )153,      (unsigned char )153, 
        (unsigned char )153,      (unsigned char )153,      (unsigned char )153,      (unsigned char )153, 
        (unsigned char )153,      (unsigned char )153,      (unsigned char )153,      (unsigned char )153, 
        (unsigned char )153,      (unsigned char )153,      (unsigned char )153,      (unsigned char )153, 
        (unsigned char )153,      (unsigned char )153,      (unsigned char )153,      (unsigned char )153, 
        (unsigned char )153,      (unsigned char )153,      (unsigned char )153,      (unsigned char )153, 
        (unsigned char )153,      (unsigned char )153,      (unsigned char )153,      (unsigned char )153, 
        (unsigned char )153,      (unsigned char )153,      (unsigned char )153,      (unsigned char )153, 
        (unsigned char )153,      (unsigned char )153,      (unsigned char )153,      (unsigned char )153, 
        (unsigned char )153,      (unsigned char )153,      (unsigned char )153,      (unsigned char )153, 
        (unsigned char )153,      (unsigned char )153,      (unsigned char )153,      (unsigned char )153, 
        (unsigned char )153,      (unsigned char )153,      (unsigned char )153,      (unsigned char )153, 
        (unsigned char )153,      (unsigned char )153,      (unsigned char )153,      (unsigned char )153, 
        (unsigned char )153,      (unsigned char )153,      (unsigned char )153,      (unsigned char )153, 
        (unsigned char )153,      (unsigned char )153,      (unsigned char )153,      (unsigned char )153, 
        (unsigned char )153,      (unsigned char )153,      (unsigned char )153,      (unsigned char )153, 
        (unsigned char )153,      (unsigned char )153,      (unsigned char )153,      (unsigned char )153, 
        (unsigned char )153,      (unsigned char )153,      (unsigned char )153,      (unsigned char )153, 
        (unsigned char )153,      (unsigned char )153,      (unsigned char )153,      (unsigned char )153, 
        (unsigned char )153,      (unsigned char )153,      (unsigned char )153,      (unsigned char )153, 
        (unsigned char )153,      (unsigned char )153,      (unsigned char )153,      (unsigned char )153, 
        (unsigned char )153,      (unsigned char )153,      (unsigned char )153,      (unsigned char )153, 
        (unsigned char )153,      (unsigned char )153,      (unsigned char )153,      (unsigned char )153, 
        (unsigned char )153,      (unsigned char )153,      (unsigned char )153,      (unsigned char )153, 
        (unsigned char )153,      (unsigned char )153,      (unsigned char )153,      (unsigned char )153, 
        (unsigned char )153,      (unsigned char )153,      (unsigned char )153,      (unsigned char )153, 
        (unsigned char )153,      (unsigned char )153,      (unsigned char )153,      (unsigned char )153, 
        (unsigned char )153,      (unsigned char )153,      (unsigned char )153,      (unsigned char )153, 
        (unsigned char )153,      (unsigned char )153,      (unsigned char )153,      (unsigned char )153, 
        (unsigned char )153,      (unsigned char )153,      (unsigned char )153,      (unsigned char )152, 
        (unsigned char )152,      (unsigned char )152,      (unsigned char )152,      (unsigned char )152, 
        (unsigned char )152,      (unsigned char )152,      (unsigned char )152,      (unsigned char )152, 
        (unsigned char )152,      (unsigned char )152,      (unsigned char )152,      (unsigned char )152, 
        (unsigned char )152,      (unsigned char )152,      (unsigned char )152,      (unsigned char )152, 
        (unsigned char )152,      (unsigned char )152,      (unsigned char )152,      (unsigned char )152, 
        (unsigned char )152,      (unsigned char )152,      (unsigned char )152,      (unsigned char )152, 
        (unsigned char )152,      (unsigned char )152,      (unsigned char )152,      (unsigned char )152, 
        (unsigned char )152,      (unsigned char )152,      (unsigned char )152,      (unsigned char )152, 
        (unsigned char )152,      (unsigned char )152,      (unsigned char )152,      (unsigned char )152, 
        (unsigned char )152,      (unsigned char )152,      (unsigned char )152,      (unsigned char )152, 
        (unsigned char )152,      (unsigned char )152,      (unsigned char )152,      (unsigned char )152, 
        (unsigned char )152,      (unsigned char )152,      (unsigned char )152,      (unsigned char )152, 
        (unsigned char )152,      (unsigned char )152,      (unsigned char )152,      (unsigned char )152, 
        (unsigned char )152,      (unsigned char )152,      (unsigned char )152,      (unsigned char )152, 
        (unsigned char )152,      (unsigned char )152,      (unsigned char )152,      (unsigned char )152, 
        (unsigned char )152,      (unsigned char )152,      (unsigned char )152,      (unsigned char )152, 
        (unsigned char )152,      (unsigned char )152,      (unsigned char )152,      (unsigned char )152, 
        (unsigned char )152,      (unsigned char )152,      (unsigned char )152,      (unsigned char )152, 
        (unsigned char )152,      (unsigned char )152,      (unsigned char )152,      (unsigned char )152, 
        (unsigned char )152,      (unsigned char )152,      (unsigned char )152,      (unsigned char )152, 
        (unsigned char )152,      (unsigned char )152,      (unsigned char )152,      (unsigned char )152, 
        (unsigned char )152,      (unsigned char )152,      (unsigned char )152,      (unsigned char )152, 
        (unsigned char )152,      (unsigned char )152,      (unsigned char )152,      (unsigned char )152, 
        (unsigned char )152,      (unsigned char )152,      (unsigned char )152,      (unsigned char )152, 
        (unsigned char )152,      (unsigned char )152,      (unsigned char )152,      (unsigned char )152, 
        (unsigned char )152,      (unsigned char )152,      (unsigned char )152,      (unsigned char )152, 
        (unsigned char )152,      (unsigned char )152,      (unsigned char )152,      (unsigned char )152, 
        (unsigned char )152,      (unsigned char )152,      (unsigned char )152,      (unsigned char )152, 
        (unsigned char )152,      (unsigned char )152,      (unsigned char )152,      (unsigned char )152, 
        (unsigned char )152,      (unsigned char )152,      (unsigned char )152,      (unsigned char )152, 
        (unsigned char )152,      (unsigned char )152,      (unsigned char )152,      (unsigned char )152, 
        (unsigned char )152,      (unsigned char )152,      (unsigned char )152,      (unsigned char )151, 
        (unsigned char )151,      (unsigned char )151,      (unsigned char )151,      (unsigned char )151, 
        (unsigned char )151,      (unsigned char )151,      (unsigned char )151,      (unsigned char )151, 
        (unsigned char )151,      (unsigned char )151,      (unsigned char )151,      (unsigned char )151, 
        (unsigned char )151,      (unsigned char )151,      (unsigned char )151,      (unsigned char )151, 
        (unsigned char )151,      (unsigned char )151,      (unsigned char )151,      (unsigned char )151, 
        (unsigned char )151,      (unsigned char )151,      (unsigned char )151,      (unsigned char )151, 
        (unsigned char )151,      (unsigned char )151,      (unsigned char )151,      (unsigned char )151, 
        (unsigned char )151,      (unsigned char )151,      (unsigned char )151,      (unsigned char )151, 
        (unsigned char )151,      (unsigned char )151,      (unsigned char )151,      (unsigned char )151, 
        (unsigned char )151,      (unsigned char )151,      (unsigned char )151,      (unsigned char )151, 
        (unsigned char )151,      (unsigned char )151,      (unsigned char )151,      (unsigned char )151, 
        (unsigned char )151,      (unsigned char )151,      (unsigned char )151,      (unsigned char )151, 
        (unsigned char )151,      (unsigned char )151,      (unsigned char )151,      (unsigned char )151, 
        (unsigned char )151,      (unsigned char )151,      (unsigned char )151,      (unsigned char )151, 
        (unsigned char )151,      (unsigned char )151,      (unsigned char )151,      (unsigned char )151, 
        (unsigned char )151,      (unsigned char )151,      (unsigned char )151,      (unsigned char )151, 
        (unsigned char )151,      (unsigned char )151,      (unsigned char )151,      (unsigned char )151, 
        (unsigned char )151,      (unsigned char )151,      (unsigned char )151,      (unsigned char )151, 
        (unsigned char )151,      (unsigned char )151,      (unsigned char )151,      (unsigned char )151, 
        (unsigned char )151,      (unsigned char )151,      (unsigned char )151,      (unsigned char )151, 
        (unsigned char )151,      (unsigned char )151,      (unsigned char )151,      (unsigned char )151, 
        (unsigned char )151,      (unsigned char )151,      (unsigned char )151,      (unsigned char )151, 
        (unsigned char )151,      (unsigned char )151,      (unsigned char )151,      (unsigned char )151, 
        (unsigned char )151,      (unsigned char )151,      (unsigned char )151,      (unsigned char )151, 
        (unsigned char )151,      (unsigned char )151,      (unsigned char )151,      (unsigned char )151, 
        (unsigned char )151,      (unsigned char )151,      (unsigned char )151,      (unsigned char )151, 
        (unsigned char )151,      (unsigned char )151,      (unsigned char )151,      (unsigned char )151, 
        (unsigned char )151,      (unsigned char )151,      (unsigned char )151,      (unsigned char )151, 
        (unsigned char )151,      (unsigned char )151,      (unsigned char )151,      (unsigned char )151, 
        (unsigned char )151,      (unsigned char )151,      (unsigned char )151,      (unsigned char )151, 
        (unsigned char )151,      (unsigned char )151,      (unsigned char )151,      (unsigned char )151, 
        (unsigned char )151,      (unsigned char )151,      (unsigned char )151,      (unsigned char )150, 
        (unsigned char )150,      (unsigned char )150,      (unsigned char )150,      (unsigned char )150, 
        (unsigned char )150,      (unsigned char )150,      (unsigned char )150,      (unsigned char )150, 
        (unsigned char )150,      (unsigned char )150,      (unsigned char )150,      (unsigned char )150, 
        (unsigned char )150,      (unsigned char )150,      (unsigned char )150,      (unsigned char )150, 
        (unsigned char )150,      (unsigned char )150,      (unsigned char )150,      (unsigned char )150, 
        (unsigned char )150,      (unsigned char )150,      (unsigned char )150,      (unsigned char )150, 
        (unsigned char )150,      (unsigned char )150,      (unsigned char )150,      (unsigned char )150, 
        (unsigned char )150,      (unsigned char )150,      (unsigned char )150,      (unsigned char )150, 
        (unsigned char )150,      (unsigned char )150,      (unsigned char )150,      (unsigned char )150, 
        (unsigned char )150,      (unsigned char )150,      (unsigned char )150,      (unsigned char )150, 
        (unsigned char )150,      (unsigned char )150,      (unsigned char )150,      (unsigned char )150, 
        (unsigned char )150,      (unsigned char )150,      (unsigned char )150,      (unsigned char )150, 
        (unsigned char )150,      (unsigned char )150,      (unsigned char )150,      (unsigned char )150, 
        (unsigned char )150,      (unsigned char )150,      (unsigned char )150,      (unsigned char )150, 
        (unsigned char )150,      (unsigned char )150,      (unsigned char )150,      (unsigned char )150, 
        (unsigned char )150,      (unsigned char )150,      (unsigned char )150,      (unsigned char )150, 
        (unsigned char )150,      (unsigned char )150,      (unsigned char )150,      (unsigned char )150, 
        (unsigned char )150,      (unsigned char )150,      (unsigned char )150,      (unsigned char )150, 
        (unsigned char )150,      (unsigned char )150,      (unsigned char )150,      (unsigned char )150, 
        (unsigned char )150,      (unsigned char )150,      (unsigned char )150,      (unsigned char )150, 
        (unsigned char )150,      (unsigned char )150,      (unsigned char )150,      (unsigned char )150, 
        (unsigned char )150,      (unsigned char )150,      (unsigned char )150,      (unsigned char )150, 
        (unsigned char )150,      (unsigned char )150,      (unsigned char )150,      (unsigned char )150, 
        (unsigned char )150,      (unsigned char )150,      (unsigned char )150,      (unsigned char )150, 
        (unsigned char )150,      (unsigned char )150,      (unsigned char )150,      (unsigned char )150, 
        (unsigned char )150,      (unsigned char )150,      (unsigned char )150,      (unsigned char )150, 
        (unsigned char )150,      (unsigned char )150,      (unsigned char )150,      (unsigned char )150, 
        (unsigned char )150,      (unsigned char )150,      (unsigned char )150,      (unsigned char )150, 
        (unsigned char )150,      (unsigned char )150,      (unsigned char )150,      (unsigned char )150, 
        (unsigned char )150,      (unsigned char )150,      (unsigned char )150,      (unsigned char )150, 
        (unsigned char )150,      (unsigned char )150,      (unsigned char )150,      (unsigned char )150, 
        (unsigned char )150,      (unsigned char )150,      (unsigned char )150,      (unsigned char )149, 
        (unsigned char )149,      (unsigned char )149,      (unsigned char )149,      (unsigned char )149, 
        (unsigned char )149,      (unsigned char )149,      (unsigned char )149,      (unsigned char )149, 
        (unsigned char )149,      (unsigned char )149,      (unsigned char )149,      (unsigned char )149, 
        (unsigned char )149,      (unsigned char )149,      (unsigned char )149,      (unsigned char )149, 
        (unsigned char )149,      (unsigned char )149,      (unsigned char )149,      (unsigned char )149, 
        (unsigned char )149,      (unsigned char )149,      (unsigned char )149,      (unsigned char )149, 
        (unsigned char )149,      (unsigned char )149,      (unsigned char )149,      (unsigned char )149, 
        (unsigned char )149,      (unsigned char )149,      (unsigned char )149,      (unsigned char )149, 
        (unsigned char )149,      (unsigned char )149,      (unsigned char )149,      (unsigned char )149, 
        (unsigned char )149,      (unsigned char )149,      (unsigned char )149,      (unsigned char )149, 
        (unsigned char )149,      (unsigned char )149,      (unsigned char )149,      (unsigned char )149, 
        (unsigned char )149,      (unsigned char )149,      (unsigned char )149,      (unsigned char )149, 
        (unsigned char )149,      (unsigned char )149,      (unsigned char )149,      (unsigned char )149, 
        (unsigned char )149,      (unsigned char )149,      (unsigned char )149,      (unsigned char )149, 
        (unsigned char )149,      (unsigned char )149,      (unsigned char )149,      (unsigned char )149, 
        (unsigned char )149,      (unsigned char )149,      (unsigned char )149,      (unsigned char )149, 
        (unsigned char )149,      (unsigned char )149,      (unsigned char )149,      (unsigned char )149, 
        (unsigned char )149,      (unsigned char )149,      (unsigned char )149,      (unsigned char )149, 
        (unsigned char )149,      (unsigned char )149,      (unsigned char )149,      (unsigned char )149, 
        (unsigned char )149,      (unsigned char )149,      (unsigned char )149,      (unsigned char )149, 
        (unsigned char )149,      (unsigned char )149,      (unsigned char )149,      (unsigned char )149, 
        (unsigned char )149,      (unsigned char )149,      (unsigned char )149,      (unsigned char )149, 
        (unsigned char )149,      (unsigned char )149,      (unsigned char )149,      (unsigned char )149, 
        (unsigned char )149,      (unsigned char )149,      (unsigned char )149,      (unsigned char )149, 
        (unsigned char )149,      (unsigned char )149,      (unsigned char )149,      (unsigned char )149, 
        (unsigned char )149,      (unsigned char )149,      (unsigned char )149,      (unsigned char )149, 
        (unsigned char )149,      (unsigned char )149,      (unsigned char )149,      (unsigned char )149, 
        (unsigned char )149,      (unsigned char )149,      (unsigned char )149,      (unsigned char )149, 
        (unsigned char )149,      (unsigned char )149,      (unsigned char )149,      (unsigned char )149, 
        (unsigned char )149,      (unsigned char )149,      (unsigned char )149,      (unsigned char )149, 
        (unsigned char )149,      (unsigned char )149,      (unsigned char )149,      (unsigned char )149, 
        (unsigned char )149,      (unsigned char )149,      (unsigned char )149,      (unsigned char )148, 
        (unsigned char )148,      (unsigned char )148,      (unsigned char )148,      (unsigned char )148, 
        (unsigned char )148,      (unsigned char )148,      (unsigned char )148,      (unsigned char )148, 
        (unsigned char )148,      (unsigned char )148,      (unsigned char )148,      (unsigned char )148, 
        (unsigned char )148,      (unsigned char )148,      (unsigned char )148,      (unsigned char )148, 
        (unsigned char )148,      (unsigned char )148,      (unsigned char )148,      (unsigned char )148, 
        (unsigned char )148,      (unsigned char )148,      (unsigned char )148,      (unsigned char )148, 
        (unsigned char )148,      (unsigned char )148,      (unsigned char )148,      (unsigned char )148, 
        (unsigned char )148,      (unsigned char )148,      (unsigned char )148,      (unsigned char )148, 
        (unsigned char )148,      (unsigned char )148,      (unsigned char )148,      (unsigned char )148, 
        (unsigned char )148,      (unsigned char )148,      (unsigned char )148,      (unsigned char )148, 
        (unsigned char )148,      (unsigned char )148,      (unsigned char )148,      (unsigned char )148, 
        (unsigned char )148,      (unsigned char )148,      (unsigned char )148,      (unsigned char )148, 
        (unsigned char )148,      (unsigned char )148,      (unsigned char )148,      (unsigned char )148, 
        (unsigned char )148,      (unsigned char )148,      (unsigned char )148,      (unsigned char )148, 
        (unsigned char )148,      (unsigned char )148,      (unsigned char )148,      (unsigned char )148, 
        (unsigned char )148,      (unsigned char )148,      (unsigned char )148,      (unsigned char )148, 
        (unsigned char )148,      (unsigned char )148,      (unsigned char )148,      (unsigned char )148, 
        (unsigned char )148,      (unsigned char )148,      (unsigned char )148,      (unsigned char )148, 
        (unsigned char )148,      (unsigned char )148,      (unsigned char )148,      (unsigned char )148, 
        (unsigned char )148,      (unsigned char )148,      (unsigned char )148,      (unsigned char )148, 
        (unsigned char )148,      (unsigned char )148,      (unsigned char )148,      (unsigned char )148, 
        (unsigned char )148,      (unsigned char )148,      (unsigned char )148,      (unsigned char )148, 
        (unsigned char )148,      (unsigned char )148,      (unsigned char )148,      (unsigned char )148, 
        (unsigned char )148,      (unsigned char )148,      (unsigned char )148,      (unsigned char )148, 
        (unsigned char )148,      (unsigned char )148,      (unsigned char )148,      (unsigned char )148, 
        (unsigned char )148,      (unsigned char )148,      (unsigned char )148,      (unsigned char )148, 
        (unsigned char )148,      (unsigned char )148,      (unsigned char )148,      (unsigned char )148, 
        (unsigned char )148,      (unsigned char )148,      (unsigned char )148,      (unsigned char )148, 
        (unsigned char )148,      (unsigned char )148,      (unsigned char )148,      (unsigned char )148, 
        (unsigned char )148,      (unsigned char )148,      (unsigned char )148,      (unsigned char )148, 
        (unsigned char )148,      (unsigned char )148,      (unsigned char )148,      (unsigned char )148, 
        (unsigned char )148,      (unsigned char )148,      (unsigned char )148,      (unsigned char )147, 
        (unsigned char )147,      (unsigned char )147,      (unsigned char )147,      (unsigned char )147, 
        (unsigned char )147,      (unsigned char )147,      (unsigned char )147,      (unsigned char )147, 
        (unsigned char )147,      (unsigned char )147,      (unsigned char )147,      (unsigned char )147, 
        (unsigned char )147,      (unsigned char )147,      (unsigned char )147,      (unsigned char )147, 
        (unsigned char )147,      (unsigned char )147,      (unsigned char )147,      (unsigned char )147, 
        (unsigned char )147,      (unsigned char )147,      (unsigned char )147,      (unsigned char )147, 
        (unsigned char )147,      (unsigned char )147,      (unsigned char )147,      (unsigned char )147, 
        (unsigned char )147,      (unsigned char )147,      (unsigned char )147,      (unsigned char )147, 
        (unsigned char )147,      (unsigned char )147,      (unsigned char )147,      (unsigned char )147, 
        (unsigned char )147,      (unsigned char )147,      (unsigned char )147,      (unsigned char )147, 
        (unsigned char )147,      (unsigned char )147,      (unsigned char )147,      (unsigned char )147, 
        (unsigned char )147,      (unsigned char )147,      (unsigned char )147,      (unsigned char )147, 
        (unsigned char )147,      (unsigned char )147,      (unsigned char )147,      (unsigned char )147, 
        (unsigned char )147,      (unsigned char )147,      (unsigned char )147,      (unsigned char )147, 
        (unsigned char )147,      (unsigned char )147,      (unsigned char )147,      (unsigned char )147, 
        (unsigned char )147,      (unsigned char )147,      (unsigned char )147,      (unsigned char )147, 
        (unsigned char )147,      (unsigned char )147,      (unsigned char )147,      (unsigned char )147, 
        (unsigned char )147,      (unsigned char )147,      (unsigned char )147,      (unsigned char )147, 
        (unsigned char )147,      (unsigned char )147,      (unsigned char )147,      (unsigned char )147, 
        (unsigned char )147,      (unsigned char )147,      (unsigned char )147,      (unsigned char )147, 
        (unsigned char )147,      (unsigned char )147,      (unsigned char )147,      (unsigned char )147, 
        (unsigned char )147,      (unsigned char )147,      (unsigned char )147,      (unsigned char )147, 
        (unsigned char )147,      (unsigned char )147,      (unsigned char )147,      (unsigned char )147, 
        (unsigned char )147,      (unsigned char )147,      (unsigned char )147,      (unsigned char )147, 
        (unsigned char )147,      (unsigned char )147,      (unsigned char )147,      (unsigned char )147, 
        (unsigned char )147,      (unsigned char )147,      (unsigned char )147,      (unsigned char )147, 
        (unsigned char )147,      (unsigned char )147,      (unsigned char )147,      (unsigned char )147, 
        (unsigned char )147,      (unsigned char )147,      (unsigned char )147,      (unsigned char )147, 
        (unsigned char )147,      (unsigned char )147,      (unsigned char )147,      (unsigned char )147, 
        (unsigned char )147,      (unsigned char )147,      (unsigned char )147,      (unsigned char )147, 
        (unsigned char )147,      (unsigned char )147,      (unsigned char )147,      (unsigned char )147, 
        (unsigned char )147,      (unsigned char )147,      (unsigned char )147,      (unsigned char )146, 
        (unsigned char )146,      (unsigned char )146,      (unsigned char )146,      (unsigned char )146, 
        (unsigned char )146,      (unsigned char )146,      (unsigned char )146,      (unsigned char )146, 
        (unsigned char )146,      (unsigned char )146,      (unsigned char )146,      (unsigned char )146, 
        (unsigned char )146,      (unsigned char )146,      (unsigned char )146,      (unsigned char )146, 
        (unsigned char )146,      (unsigned char )146,      (unsigned char )146,      (unsigned char )146, 
        (unsigned char )146,      (unsigned char )146,      (unsigned char )146,      (unsigned char )146, 
        (unsigned char )146,      (unsigned char )146,      (unsigned char )146,      (unsigned char )146, 
        (unsigned char )146,      (unsigned char )146,      (unsigned char )146,      (unsigned char )146, 
        (unsigned char )146,      (unsigned char )146,      (unsigned char )146,      (unsigned char )146, 
        (unsigned char )146,      (unsigned char )146,      (unsigned char )146,      (unsigned char )146, 
        (unsigned char )146,      (unsigned char )146,      (unsigned char )146,      (unsigned char )146, 
        (unsigned char )146,      (unsigned char )146,      (unsigned char )146,      (unsigned char )146, 
        (unsigned char )146,      (unsigned char )146,      (unsigned char )146,      (unsigned char )146, 
        (unsigned char )146,      (unsigned char )146,      (unsigned char )146,      (unsigned char )146, 
        (unsigned char )146,      (unsigned char )146,      (unsigned char )146,      (unsigned char )146, 
        (unsigned char )146,      (unsigned char )146,      (unsigned char )146,      (unsigned char )146, 
        (unsigned char )146,      (unsigned char )146,      (unsigned char )146,      (unsigned char )146, 
        (unsigned char )146,      (unsigned char )146,      (unsigned char )146,      (unsigned char )146, 
        (unsigned char )146,      (unsigned char )146,      (unsigned char )146,      (unsigned char )146, 
        (unsigned char )146,      (unsigned char )146,      (unsigned char )146,      (unsigned char )146, 
        (unsigned char )146,      (unsigned char )146,      (unsigned char )146,      (unsigned char )146, 
        (unsigned char )146,      (unsigned char )146,      (unsigned char )146,      (unsigned char )146, 
        (unsigned char )146,      (unsigned char )146,      (unsigned char )146,      (unsigned char )146, 
        (unsigned char )146,      (unsigned char )146,      (unsigned char )146,      (unsigned char )146, 
        (unsigned char )146,      (unsigned char )146,      (unsigned char )146,      (unsigned char )146, 
        (unsigned char )146,      (unsigned char )146,      (unsigned char )146,      (unsigned char )146, 
        (unsigned char )146,      (unsigned char )146,      (unsigned char )146,      (unsigned char )146, 
        (unsigned char )146,      (unsigned char )146,      (unsigned char )146,      (unsigned char )146, 
        (unsigned char )146,      (unsigned char )146,      (unsigned char )146,      (unsigned char )146, 
        (unsigned char )146,      (unsigned char )146,      (unsigned char )146,      (unsigned char )146, 
        (unsigned char )146,      (unsigned char )146,      (unsigned char )146,      (unsigned char )146, 
        (unsigned char )146,      (unsigned char )146,      (unsigned char )146,      (unsigned char )145, 
        (unsigned char )145,      (unsigned char )145,      (unsigned char )145,      (unsigned char )145, 
        (unsigned char )145,      (unsigned char )145,      (unsigned char )145,      (unsigned char )145, 
        (unsigned char )145,      (unsigned char )145,      (unsigned char )145,      (unsigned char )145, 
        (unsigned char )145,      (unsigned char )145,      (unsigned char )145,      (unsigned char )145, 
        (unsigned char )145,      (unsigned char )145,      (unsigned char )145,      (unsigned char )145, 
        (unsigned char )145,      (unsigned char )145,      (unsigned char )145,      (unsigned char )145, 
        (unsigned char )145,      (unsigned char )145,      (unsigned char )145,      (unsigned char )145, 
        (unsigned char )145,      (unsigned char )145,      (unsigned char )145,      (unsigned char )145, 
        (unsigned char )145,      (unsigned char )145,      (unsigned char )145,      (unsigned char )145, 
        (unsigned char )145,      (unsigned char )145,      (unsigned char )145,      (unsigned char )145, 
        (unsigned char )145,      (unsigned char )145,      (unsigned char )145,      (unsigned char )145, 
        (unsigned char )145,      (unsigned char )145,      (unsigned char )145,      (unsigned char )145, 
        (unsigned char )145,      (unsigned char )145,      (unsigned char )145,      (unsigned char )145, 
        (unsigned char )145,      (unsigned char )145,      (unsigned char )145,      (unsigned char )145, 
        (unsigned char )145,      (unsigned char )145,      (unsigned char )145,      (unsigned char )145, 
        (unsigned char )145,      (unsigned char )145,      (unsigned char )145,      (unsigned char )145, 
        (unsigned char )145,      (unsigned char )145,      (unsigned char )145,      (unsigned char )145, 
        (unsigned char )145,      (unsigned char )145,      (unsigned char )145,      (unsigned char )145, 
        (unsigned char )145,      (unsigned char )145,      (unsigned char )145,      (unsigned char )145, 
        (unsigned char )145,      (unsigned char )145,      (unsigned char )145,      (unsigned char )145, 
        (unsigned char )145,      (unsigned char )145,      (unsigned char )145,      (unsigned char )145, 
        (unsigned char )145,      (unsigned char )145,      (unsigned char )145,      (unsigned char )145, 
        (unsigned char )145,      (unsigned char )145,      (unsigned char )145,      (unsigned char )145, 
        (unsigned char )145,      (unsigned char )145,      (unsigned char )145,      (unsigned char )145, 
        (unsigned char )145,      (unsigned char )145,      (unsigned char )145,      (unsigned char )145, 
        (unsigned char )145,      (unsigned char )145,      (unsigned char )145,      (unsigned char )145, 
        (unsigned char )145,      (unsigned char )145,      (unsigned char )145,      (unsigned char )145, 
        (unsigned char )145,      (unsigned char )145,      (unsigned char )145,      (unsigned char )145, 
        (unsigned char )145,      (unsigned char )145,      (unsigned char )145,      (unsigned char )145, 
        (unsigned char )145,      (unsigned char )145,      (unsigned char )145,      (unsigned char )145, 
        (unsigned char )145,      (unsigned char )145,      (unsigned char )145,      (unsigned char )145, 
        (unsigned char )145,      (unsigned char )145,      (unsigned char )145,      (unsigned char )144, 
        (unsigned char )144,      (unsigned char )144,      (unsigned char )144,      (unsigned char )144, 
        (unsigned char )144,      (unsigned char )144,      (unsigned char )144,      (unsigned char )144, 
        (unsigned char )144,      (unsigned char )144,      (unsigned char )144,      (unsigned char )144, 
        (unsigned char )144,      (unsigned char )144,      (unsigned char )144,      (unsigned char )144, 
        (unsigned char )144,      (unsigned char )144,      (unsigned char )144,      (unsigned char )144, 
        (unsigned char )144,      (unsigned char )144,      (unsigned char )144,      (unsigned char )144, 
        (unsigned char )144,      (unsigned char )144,      (unsigned char )144,      (unsigned char )144, 
        (unsigned char )144,      (unsigned char )144,      (unsigned char )144,      (unsigned char )144, 
        (unsigned char )144,      (unsigned char )144,      (unsigned char )144,      (unsigned char )144, 
        (unsigned char )144,      (unsigned char )144,      (unsigned char )144,      (unsigned char )144, 
        (unsigned char )144,      (unsigned char )144,      (unsigned char )144,      (unsigned char )144, 
        (unsigned char )144,      (unsigned char )144,      (unsigned char )144,      (unsigned char )144, 
        (unsigned char )144,      (unsigned char )144,      (unsigned char )144,      (unsigned char )144, 
        (unsigned char )144,      (unsigned char )144,      (unsigned char )144,      (unsigned char )144, 
        (unsigned char )144,      (unsigned char )144,      (unsigned char )144,      (unsigned char )144, 
        (unsigned char )144,      (unsigned char )144,      (unsigned char )144,      (unsigned char )144, 
        (unsigned char )144,      (unsigned char )144,      (unsigned char )144,      (unsigned char )144, 
        (unsigned char )144,      (unsigned char )144,      (unsigned char )144,      (unsigned char )144, 
        (unsigned char )144,      (unsigned char )144,      (unsigned char )144,      (unsigned char )144, 
        (unsigned char )144,      (unsigned char )144,      (unsigned char )144,      (unsigned char )144, 
        (unsigned char )144,      (unsigned char )144,      (unsigned char )144,      (unsigned char )144, 
        (unsigned char )144,      (unsigned char )144,      (unsigned char )144,      (unsigned char )144, 
        (unsigned char )144,      (unsigned char )144,      (unsigned char )144,      (unsigned char )144, 
        (unsigned char )144,      (unsigned char )144,      (unsigned char )144,      (unsigned char )144, 
        (unsigned char )144,      (unsigned char )144,      (unsigned char )144,      (unsigned char )144, 
        (unsigned char )144,      (unsigned char )144,      (unsigned char )144,      (unsigned char )144, 
        (unsigned char )144,      (unsigned char )144,      (unsigned char )144,      (unsigned char )144, 
        (unsigned char )144,      (unsigned char )144,      (unsigned char )144,      (unsigned char )144, 
        (unsigned char )144,      (unsigned char )144,      (unsigned char )144,      (unsigned char )144, 
        (unsigned char )144,      (unsigned char )144,      (unsigned char )144,      (unsigned char )144, 
        (unsigned char )144,      (unsigned char )144,      (unsigned char )144,      (unsigned char )144, 
        (unsigned char )144,      (unsigned char )144,      (unsigned char )144,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )0};
#line 794 "/root/libsndfile/src/ulaw.c"
__inline static void ulaw2s_array(unsigned char *buffer , int count , short *ptr ) 
{ 


  {
  {
#line 795
  while (1) {
    while_continue: /* CIL Label */ ;
#line 795
    count --;
#line 795
    if (! (count >= 0)) {
#line 795
      goto while_break;
    }
#line 796
    *(ptr + count) = ulaw_decode[(int )*(buffer + count)];
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 800 "/root/libsndfile/src/ulaw.c"
__inline static void ulaw2i_array(unsigned char *buffer , int count , int *ptr ) 
{ 


  {
  {
#line 801
  while (1) {
    while_continue: /* CIL Label */ ;
#line 801
    count --;
#line 801
    if (! (count >= 0)) {
#line 801
      goto while_break;
    }
#line 802
    *(ptr + count) = (int )ulaw_decode[*(buffer + count)] << 16;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 806 "/root/libsndfile/src/ulaw.c"
__inline static void ulaw2f_array(unsigned char *buffer , int count , float *ptr ,
                                  float normfact ) 
{ 


  {
  {
#line 807
  while (1) {
    while_continue: /* CIL Label */ ;
#line 807
    count --;
#line 807
    if (! (count >= 0)) {
#line 807
      goto while_break;
    }
#line 808
    *(ptr + count) = normfact * (float )((int )ulaw_decode[(int )*(buffer + count)]);
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 812 "/root/libsndfile/src/ulaw.c"
__inline static void ulaw2d_array(unsigned char const   *buffer , int count , double *ptr ,
                                  double normfact ) 
{ 


  {
  {
#line 813
  while (1) {
    while_continue: /* CIL Label */ ;
#line 813
    count --;
#line 813
    if (! (count >= 0)) {
#line 813
      goto while_break;
    }
#line 814
    *(ptr + count) = normfact * (double )((int )ulaw_decode[(int )*(buffer + count)]);
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 818 "/root/libsndfile/src/ulaw.c"
__inline static void s2ulaw_array(short const   *ptr , int count , unsigned char *buffer ) 
{ 


  {
  {
#line 819
  while (1) {
    while_continue: /* CIL Label */ ;
#line 819
    count --;
#line 819
    if (! (count >= 0)) {
#line 819
      goto while_break;
    }
#line 820
    if ((int )*(ptr + count) >= 0) {
#line 821
      *(buffer + count) = ulaw_encode[(int )*(ptr + count) / 4];
    } else {
#line 823
      *(buffer + count) = (unsigned char )(127 & (int )ulaw_encode[(int )*(ptr + count) / -4]);
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 828 "/root/libsndfile/src/ulaw.c"
__inline static void i2ulaw_array(int const   *ptr , int count , unsigned char *buffer ) 
{ 


  {
  {
#line 829
  while (1) {
    while_continue: /* CIL Label */ ;
#line 829
    count --;
#line 829
    if (! (count >= 0)) {
#line 829
      goto while_break;
    }
#line 830
    if (*(ptr + count) >= 0) {
#line 831
      *(buffer + count) = ulaw_encode[*(ptr + count) >> 18];
    } else {
#line 833
      *(buffer + count) = (unsigned char )(127 & (int )ulaw_encode[- *(ptr + count) >> 18]);
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 838 "/root/libsndfile/src/ulaw.c"
__inline static void f2ulaw_array(float const   *ptr , int count , unsigned char *buffer ,
                                  float normfact ) 
{ 
  long __cil_tmp5 ;
  long __cil_tmp6 ;

  {
  {
#line 839
  while (1) {
    while_continue: /* CIL Label */ ;
#line 839
    count --;
#line 839
    if (! (count >= 0)) {
#line 839
      goto while_break;
    }
#line 840
    if (*(ptr + count) >= (float )0) {
      {
#line 841
      *(buffer + count) = (unsigned char )lrintf(normfact * *(ptr + count));
      }
    } else {
      {
#line 843
      __cil_tmp6 = lrintf(normfact * *(ptr + count));
#line 843
      *(buffer + count) = (unsigned char )(127 & (int )ulaw_encode[- __cil_tmp6]);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 848 "/root/libsndfile/src/ulaw.c"
__inline static void d2ulaw_array(double const   *ptr , int count , unsigned char *buffer ,
                                  double normfact ) 
{ 
  long __cil_tmp5 ;
  long __cil_tmp6 ;

  {
  {
#line 849
  while (1) {
    while_continue: /* CIL Label */ ;
#line 849
    count --;
#line 849
    if (! (count >= 0)) {
#line 849
      goto while_break;
    }
#line 850
    if (*(ptr + count) >= (double )0) {
      {
#line 851
      *(buffer + count) = (unsigned char )lrint(normfact * *(ptr + count));
      }
    } else {
      {
#line 853
      __cil_tmp6 = lrint(normfact * *(ptr + count));
#line 853
      *(buffer + count) = (unsigned char )(127 & (int )ulaw_encode[- __cil_tmp6]);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 861 "/root/libsndfile/src/ulaw.c"
static sf_count_t ulaw_read_ulaw2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp7 ;

  {
#line 863
  total = (sf_count_t )0;
#line 865
  bufferlen = (int )(sizeof(psf->u.ucbuf) / sizeof(psf->u.ucbuf[0]));
  {
#line 867
  while (1) {
    while_continue: /* CIL Label */ ;
#line 867
    if (! (len > 0L)) {
#line 867
      goto while_break;
    }
#line 868
    if (len < (long )bufferlen) {
#line 869
      bufferlen = (int )len;
    }
    {
#line 870
    __cil_tmp7 = psf_fread((unsigned char *)psf->u.ucbuf, (sf_count_t )1, (sf_count_t )bufferlen,
                           psf);
#line 870
    readcount = (int )__cil_tmp7;
#line 871
    ulaw2s_array((unsigned char *)psf->u.ucbuf, readcount, ptr + total);
#line 872
    total += (long )readcount;
    }
#line 873
    if (readcount < bufferlen) {
#line 874
      goto while_break;
    }
#line 875
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 878
  return (total);
}
}
#line 882 "/root/libsndfile/src/ulaw.c"
static sf_count_t ulaw_read_ulaw2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp7 ;

  {
#line 884
  total = (sf_count_t )0;
#line 886
  bufferlen = (int )(sizeof(psf->u.ucbuf) / sizeof(psf->u.ucbuf[0]));
  {
#line 888
  while (1) {
    while_continue: /* CIL Label */ ;
#line 888
    if (! (len > 0L)) {
#line 888
      goto while_break;
    }
#line 889
    if (len < (long )bufferlen) {
#line 890
      bufferlen = (int )len;
    }
    {
#line 891
    __cil_tmp7 = psf_fread((unsigned char *)psf->u.ucbuf, (sf_count_t )1, (sf_count_t )bufferlen,
                           psf);
#line 891
    readcount = (int )__cil_tmp7;
#line 892
    ulaw2i_array((unsigned char *)psf->u.ucbuf, readcount, ptr + total);
#line 893
    total += (long )readcount;
    }
#line 894
    if (readcount < bufferlen) {
#line 895
      goto while_break;
    }
#line 896
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 899
  return (total);
}
}
#line 903 "/root/libsndfile/src/ulaw.c"
static sf_count_t ulaw_read_ulaw2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  sf_count_t __cil_tmp9 ;

  {
#line 905
  total = (sf_count_t )0;
#line 908
  if (psf->norm_float == 1) {
#line 908
    tmp = 1. / (double )((float )32768);
  } else {
#line 908
    tmp = 1.;
  }
#line 908
  normfact = (float )tmp;
#line 910
  bufferlen = (int )(sizeof(psf->u.ucbuf) / sizeof(psf->u.ucbuf[0]));
  {
#line 912
  while (1) {
    while_continue: /* CIL Label */ ;
#line 912
    if (! (len > 0L)) {
#line 912
      goto while_break;
    }
#line 913
    if (len < (long )bufferlen) {
#line 914
      bufferlen = (int )len;
    }
    {
#line 915
    __cil_tmp9 = psf_fread((unsigned char *)psf->u.ucbuf, (sf_count_t )1, (sf_count_t )bufferlen,
                           psf);
#line 915
    readcount = (int )__cil_tmp9;
#line 916
    ulaw2f_array((unsigned char *)psf->u.ucbuf, readcount, ptr + total, normfact);
#line 917
    total += (long )readcount;
    }
#line 918
    if (readcount < bufferlen) {
#line 919
      goto while_break;
    }
#line 920
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 923
  return (total);
}
}
#line 927 "/root/libsndfile/src/ulaw.c"
static sf_count_t ulaw_read_ulaw2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  sf_count_t __cil_tmp9 ;

  {
#line 929
  total = (sf_count_t )0;
#line 932
  if (psf->norm_double) {
#line 932
    tmp = 1. / (double )32768;
  } else {
#line 932
    tmp = 1.;
  }
#line 932
  normfact = tmp;
#line 933
  bufferlen = (int )(sizeof(psf->u.ucbuf) / sizeof(psf->u.ucbuf[0]));
  {
#line 935
  while (1) {
    while_continue: /* CIL Label */ ;
#line 935
    if (! (len > 0L)) {
#line 935
      goto while_break;
    }
#line 936
    if (len < (long )bufferlen) {
#line 937
      bufferlen = (int )len;
    }
    {
#line 938
    __cil_tmp9 = psf_fread((unsigned char *)psf->u.ucbuf, (sf_count_t )1, (sf_count_t )bufferlen,
                           psf);
#line 938
    readcount = (int )__cil_tmp9;
#line 939
    ulaw2d_array((unsigned char const   *)((unsigned char *)psf->u.ucbuf), readcount,
                 ptr + total, normfact);
#line 940
    total += (long )readcount;
    }
#line 941
    if (readcount < bufferlen) {
#line 942
      goto while_break;
    }
#line 943
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 946
  return (total);
}
}
#line 953 "/root/libsndfile/src/ulaw.c"
static sf_count_t ulaw_write_s2ulaw(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp7 ;

  {
#line 955
  total = (sf_count_t )0;
#line 957
  bufferlen = (int )(sizeof(psf->u.ucbuf) / sizeof(psf->u.ucbuf[0]));
  {
#line 959
  while (1) {
    while_continue: /* CIL Label */ ;
#line 959
    if (! (len > 0L)) {
#line 959
      goto while_break;
    }
#line 960
    if (len < (long )bufferlen) {
#line 961
      bufferlen = (int )len;
    }
    {
#line 962
    s2ulaw_array(ptr + total, bufferlen, (unsigned char *)psf->u.ucbuf);
#line 963
    __cil_tmp7 = psf_fwrite((unsigned char *)psf->u.ucbuf, (sf_count_t )1, (sf_count_t )bufferlen,
                            psf);
#line 963
    writecount = (int )__cil_tmp7;
#line 964
    total += (long )writecount;
    }
#line 965
    if (writecount < bufferlen) {
#line 966
      goto while_break;
    }
#line 967
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 970
  return (total);
}
}
#line 974 "/root/libsndfile/src/ulaw.c"
static sf_count_t ulaw_write_i2ulaw(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp7 ;

  {
#line 976
  total = (sf_count_t )0;
#line 978
  bufferlen = (int )(sizeof(psf->u.ucbuf) / sizeof(psf->u.ucbuf[0]));
  {
#line 980
  while (1) {
    while_continue: /* CIL Label */ ;
#line 980
    if (! (len > 0L)) {
#line 980
      goto while_break;
    }
#line 981
    if (len < (long )bufferlen) {
#line 982
      bufferlen = (int )len;
    }
    {
#line 983
    i2ulaw_array(ptr + total, bufferlen, (unsigned char *)psf->u.ucbuf);
#line 984
    __cil_tmp7 = psf_fwrite((unsigned char *)psf->u.ucbuf, (sf_count_t )1, (sf_count_t )bufferlen,
                            psf);
#line 984
    writecount = (int )__cil_tmp7;
#line 985
    total += (long )writecount;
    }
#line 986
    if (writecount < bufferlen) {
#line 987
      goto while_break;
    }
#line 988
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 991
  return (total);
}
}
#line 995 "/root/libsndfile/src/ulaw.c"
static sf_count_t ulaw_write_f2ulaw(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  sf_count_t __cil_tmp9 ;

  {
#line 997
  total = (sf_count_t )0;
#line 1001
  if (psf->norm_float == 1) {
#line 1001
    tmp = 0.25 * (double )32767;
  } else {
#line 1001
    tmp = 0.25;
  }
#line 1001
  normfact = (float )tmp;
#line 1003
  bufferlen = (int )(sizeof(psf->u.ucbuf) / sizeof(psf->u.ucbuf[0]));
  {
#line 1005
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1005
    if (! (len > 0L)) {
#line 1005
      goto while_break;
    }
#line 1006
    if (len < (long )bufferlen) {
#line 1007
      bufferlen = (int )len;
    }
    {
#line 1008
    f2ulaw_array(ptr + total, bufferlen, (unsigned char *)psf->u.ucbuf, normfact);
#line 1009
    __cil_tmp9 = psf_fwrite((unsigned char *)psf->u.ucbuf, (sf_count_t )1, (sf_count_t )bufferlen,
                            psf);
#line 1009
    writecount = (int )__cil_tmp9;
#line 1010
    total += (long )writecount;
    }
#line 1011
    if (writecount < bufferlen) {
#line 1012
      goto while_break;
    }
#line 1013
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 1016
  return (total);
}
}
#line 1020 "/root/libsndfile/src/ulaw.c"
static sf_count_t ulaw_write_d2ulaw(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  sf_count_t __cil_tmp9 ;

  {
#line 1022
  total = (sf_count_t )0;
#line 1026
  if (psf->norm_double) {
#line 1026
    tmp = 0.25 * (double )32767;
  } else {
#line 1026
    tmp = 0.25;
  }
#line 1026
  normfact = tmp;
#line 1028
  bufferlen = (int )(sizeof(psf->u.ucbuf) / sizeof(psf->u.ucbuf[0]));
  {
#line 1030
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1030
    if (! (len > 0L)) {
#line 1030
      goto while_break;
    }
#line 1031
    if (len < (long )bufferlen) {
#line 1032
      bufferlen = (int )len;
    }
    {
#line 1033
    d2ulaw_array(ptr + total, bufferlen, (unsigned char *)psf->u.ucbuf, normfact);
#line 1034
    __cil_tmp9 = psf_fwrite((unsigned char *)psf->u.ucbuf, (sf_count_t )1, (sf_count_t )bufferlen,
                            psf);
#line 1034
    writecount = (int )__cil_tmp9;
#line 1035
    total += (long )writecount;
    }
#line 1036
    if (writecount < bufferlen) {
#line 1037
      goto while_break;
    }
#line 1038
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 1041
  return (total);
}
}
#line 34 "/root/libsndfile/src/strings.c"
int psf_store_string(SF_PRIVATE *psf , int str_type , char const   *str ) 
{ 
  static char lsf_name[22] ;
  static char bracket_name[25] ;
  int k ;
  int str_len ;
  int len_remaining ;
  int str_flags ;
  int str_type_replace ;
  unsigned long __cil_tmp11 ;
  int __cil_tmp12 ;
  char *__cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;

  {
#line 35
  lsf_name = "libsndfile-1.0.21pre1";
#line 36
  bracket_name = " (libsndfile-1.0.21pre1)\f";
#line 37
  str_type_replace = 0;
#line 39
  if (str == (void *)0) {
#line 40
    return (55);
  }
  {
#line 42
  __cil_tmp11 = strlen(str);
#line 42
  str_len = (int )__cil_tmp11;
  }
#line 45
  if (psf->mode == 32) {
    _L: /* CIL Label */ 
#line 46
    if ((psf->str_flags & 256) == 0) {
#line 47
      return (49);
    }
#line 48
    if (psf->have_written) {
#line 48
      if ((psf->str_flags & 512) == 0) {
#line 49
        return (49);
      }
    }
#line 51
    if (str_type != 3) {
#line 51
      if (str_len == 0) {
#line 52
        return (55);
      }
    }
  } else
#line 45
  if (psf->mode == 48) {
#line 45
    goto _L;
  }
#line 56
  k = 0;
  {
#line 56
  while (1) {
    while_continue: /* CIL Label */ ;
#line 56
    if (! (k < 32)) {
#line 56
      goto while_break;
    }
#line 58
    if (psf->strings[k].type == str_type) {
#line 59
      psf->strings[k].type = - 1;
    }
#line 61
    if (psf->strings[k].type == 0) {
#line 62
      goto while_break;
    }
#line 56
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 66
  str_flags = 1024;
#line 67
  if (psf->mode == 48) {
    _L___0: /* CIL Label */ 
    _L___1: /* CIL Label */ 
#line 68
    if ((psf->str_flags & 512) == 0) {
#line 69
      return (54);
    }
#line 70
    str_flags = 2048;
  } else
#line 67
  if (psf->have_written) {
#line 67
    goto _L___0;
  } else
#line 67
  if (str_type_replace) {
#line 67
    goto _L___0;
  }

#line 74
  if (k >= 32) {
#line 75
    return (52);
  }
#line 77
  if (psf->str_end != (void *)0) {
#line 77
    if (k == 0) {
      {
#line 78
      psf_log_printf(psf, "SFE_STR_WEIRD : k == 0 && psf->str_end != NULL\n");
      }
#line 79
      return (56);
    }
  }

#line 82
  if (psf->str_end == (void *)0) {
#line 82
    if (k != 0) {
      {
#line 83
      psf_log_printf(psf, "SFE_STR_WEIRD : k != 0 && psf->str_end == NULL\n");
      }
#line 84
      return (56);
    }
  }

#line 88
  if (k == 0) {
#line 89
    psf->str_end = (char *)psf->str_storage;
  }
#line 91
  len_remaining = (int )((psf->str_end - (char *)psf->str_storage) - (long )((int )sizeof(psf->str_storage)));
#line 93
  if (len_remaining < str_len + 2) {
#line 94
    return (51);
  }
  {
#line 97
  if (str_type == 3) {
#line 97
    goto case_3;
  }
#line 132
  if (str_type == 8) {
#line 132
    goto case_8;
  }
#line 132
  if (str_type == 7) {
#line 132
    goto case_8;
  }
#line 132
  if (str_type == 6) {
#line 132
    goto case_8;
  }
#line 132
  if (str_type == 5) {
#line 132
    goto case_8;
  }
#line 132
  if (str_type == 4) {
#line 132
    goto case_8;
  }
#line 132
  if (str_type == 2) {
#line 132
    goto case_8;
  }
#line 132
  if (str_type == 1) {
#line 132
    goto case_8;
  }
#line 142
  goto switch_default;
  case_3: /* CIL Label */ 
#line 99
  if (psf->mode == 32) {
    _L___2: /* CIL Label */ 
    {
#line 100
    psf->strings[k].type = str_type;
#line 101
    psf->strings[k].str = psf->str_end;
#line 102
    psf->strings[k].flags = str_flags;
#line 104
    memcpy(psf->str_end, str, (unsigned long )(str_len + 1));
#line 105
    psf->str_end += str_len;
#line 111
    __cil_tmp14 = strlen((char const   *)((char *)bracket_name));
    }
    {
#line 111
    __cil_tmp13 = strstr(str, "libsndfile");
    }
#line 111
    if (__cil_tmp13 == (void *)0) {
#line 111
      if (len_remaining > (int )((__cil_tmp14 + (unsigned long )str_len) + 2UL)) {
        {
#line 112
        __cil_tmp15 = strlen(str);
        }
#line 112
        if (__cil_tmp15 == 0UL) {
          {
#line 113
          strncat(psf->str_end, (char const   *)((char *)lsf_name), (unsigned long )len_remaining);
          }
        } else {
          {
#line 115
          strncat(psf->str_end, (char const   *)((char *)bracket_name), (unsigned long )len_remaining);
          }
        }
        {
#line 116
        __cil_tmp16 = strlen((char const   *)psf->str_end);
        }
#line 116
        psf->str_end += __cil_tmp16;
      }
    }
#line 120
    (psf->str_end) ++;
#line 121
    goto switch_break;
  } else
#line 99
  if (psf->mode == 48) {
#line 99
    goto _L___2;
  }

  case_8: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 133
  psf->strings[k].type = str_type;
  {
#line 134
  psf->strings[k].str = psf->str_end;
#line 135
  psf->strings[k].flags = str_flags;
#line 138
  memcpy(psf->str_end, str, (unsigned long )(str_len + 1));
#line 139
  psf->str_end += str_len + 1;
  }
#line 140
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 143
  psf_log_printf(psf, "%s : SFE_STR_BAD_TYPE\n", "psf_store_string\312\001@");
  }
#line 144
  return (53);
  switch_break: /* CIL Label */ ;
  }
#line 147
  psf->str_flags |= str_flags;
#line 159
  return (0);
}
}
#line 163 "/root/libsndfile/src/strings.c"
int psf_set_string(SF_PRIVATE *psf , int str_type , char const   *str ) 
{ 
  int __cil_tmp4 ;

  {
#line 164
  if (psf->mode == 16) {
#line 165
    return (50);
  }
  {
#line 167
  __cil_tmp4 = psf_store_string(psf, str_type, str);
  }
#line 167
  return (__cil_tmp4);
}
}
#line 171 "/root/libsndfile/src/strings.c"
char const   *psf_get_string(SF_PRIVATE *psf , int str_type ) 
{ 
  int k ;
  int __cil_tmp4 ;

  {
#line 174
  k = 0;
  {
#line 174
  while (1) {
    while_continue: /* CIL Label */ ;
#line 174
    if (! (k < 32)) {
#line 174
      goto while_break;
    }
#line 175
    if (str_type == psf->strings[k].type) {
#line 176
      return ((char const   *)psf->strings[k].str);
    }
#line 174
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 178
  return ((char const   *)((void *)0));
}
}
#line 182 "/root/libsndfile/src/strings.c"
int psf_location_string_count(SF_PRIVATE *psf , int location ) 
{ 
  int k ;
  int count ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 183
  count = 0;
#line 185
  k = 0;
  {
#line 185
  while (1) {
    while_continue: /* CIL Label */ ;
#line 185
    if (! (k < 32)) {
#line 185
      goto while_break;
    }
#line 186
    if (psf->strings[k].type > 0) {
#line 186
      if (psf->strings[k].flags & location) {
#line 187
        count ++;
      }
    }
#line 185
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 189
  return (count);
}
}
#line 35 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_read_sc2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 36
static sf_count_t pcm_read_uc2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 37
static sf_count_t pcm_read_bes2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 38
static sf_count_t pcm_read_les2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 39
static sf_count_t pcm_read_bet2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 40
static sf_count_t pcm_read_let2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 41
static sf_count_t pcm_read_bei2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 42
static sf_count_t pcm_read_lei2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 44
static sf_count_t pcm_read_sc2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 45
static sf_count_t pcm_read_uc2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 46
static sf_count_t pcm_read_bes2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 47
static sf_count_t pcm_read_les2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 48
static sf_count_t pcm_read_bet2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 49
static sf_count_t pcm_read_let2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 50
static sf_count_t pcm_read_bei2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 51
static sf_count_t pcm_read_lei2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 53
static sf_count_t pcm_read_sc2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 54
static sf_count_t pcm_read_uc2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 55
static sf_count_t pcm_read_bes2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 56
static sf_count_t pcm_read_les2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 57
static sf_count_t pcm_read_bet2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 58
static sf_count_t pcm_read_let2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 59
static sf_count_t pcm_read_bei2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 60
static sf_count_t pcm_read_lei2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 62
static sf_count_t pcm_read_sc2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 63
static sf_count_t pcm_read_uc2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 64
static sf_count_t pcm_read_bes2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 65
static sf_count_t pcm_read_les2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 66
static sf_count_t pcm_read_bet2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 67
static sf_count_t pcm_read_let2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 68
static sf_count_t pcm_read_bei2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 69
static sf_count_t pcm_read_lei2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 71
static sf_count_t pcm_write_s2sc(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 72
static sf_count_t pcm_write_s2uc(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 73
static sf_count_t pcm_write_s2bes(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 74
static sf_count_t pcm_write_s2les(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 75
static sf_count_t pcm_write_s2bet(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 76
static sf_count_t pcm_write_s2let(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 77
static sf_count_t pcm_write_s2bei(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 78
static sf_count_t pcm_write_s2lei(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 80
static sf_count_t pcm_write_i2sc(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 81
static sf_count_t pcm_write_i2uc(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 82
static sf_count_t pcm_write_i2bes(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 83
static sf_count_t pcm_write_i2les(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 84
static sf_count_t pcm_write_i2bet(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 85
static sf_count_t pcm_write_i2let(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 86
static sf_count_t pcm_write_i2bei(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 87
static sf_count_t pcm_write_i2lei(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 89
static sf_count_t pcm_write_f2sc(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 90
static sf_count_t pcm_write_f2uc(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 91
static sf_count_t pcm_write_f2bes(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 92
static sf_count_t pcm_write_f2les(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 93
static sf_count_t pcm_write_f2bet(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 94
static sf_count_t pcm_write_f2let(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 95
static sf_count_t pcm_write_f2bei(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 96
static sf_count_t pcm_write_f2lei(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 98
static sf_count_t pcm_write_d2sc(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 99
static sf_count_t pcm_write_d2uc(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 100
static sf_count_t pcm_write_d2bes(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 101
static sf_count_t pcm_write_d2les(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 102
static sf_count_t pcm_write_d2bet(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 103
static sf_count_t pcm_write_d2let(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 104
static sf_count_t pcm_write_d2bei(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 105
static sf_count_t pcm_write_d2lei(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 120 "/root/libsndfile/src/pcm.c"
int pcm_init(SF_PRIVATE *psf ) 
{ 
  int chars ;
  int tmp ;
  int tmp___0 ;
  sf_count_t tmp___1 ;

  {
#line 121
  chars = 0;
#line 123
  if (psf->bytewidth == 0) {
    {
    {
#line 124
    psf_log_printf(psf, "pcm_init : internal error : bytewitdh = %d, channels = %d\n",
                   psf->bytewidth, psf->sf.channels);
    }
    }
#line 125
    return (29);
  } else
#line 123
  if (psf->sf.channels == 0) {
    {
    {
#line 124
    psf_log_printf(psf, "pcm_init : internal error : bytewitdh = %d, channels = %d\n",
                   psf->bytewidth, psf->sf.channels);
    }
    }
#line 125
    return (29);
  }
#line 128
  psf->blockwidth = psf->bytewidth * psf->sf.channels;
#line 130
  if ((psf->sf.format & 65535) == 1) {
#line 131
    chars = 200;
  } else
#line 132
  if ((psf->sf.format & 65535) == 5) {
#line 133
    chars = 201;
  }
#line 135
  if (0) {
#line 136
    if (psf->endian == 536870912) {
#line 136
      tmp = 0;
    } else {
#line 136
      tmp = 1;
    }
#line 136
    psf->data_endswap = tmp;
  } else {
#line 138
    if (psf->endian == 268435456) {
#line 138
      tmp___0 = 0;
    } else {
#line 138
      tmp___0 = 1;
    }
#line 138
    psf->data_endswap = tmp___0;
  }
#line 140
  if (psf->mode == 16) {
    _L: /* CIL Label */ 
    {
#line 143
    if ((psf->bytewidth * 65536 + psf->endian) + chars == 268501192) {
#line 143
      goto case_268501192;
    }
#line 143
    if ((psf->bytewidth * 65536 + psf->endian) + chars == 536936648) {
#line 143
      goto case_268501192;
    }
#line 150
    if ((psf->bytewidth * 65536 + psf->endian) + chars == 268501193) {
#line 150
      goto case_268501193;
    }
#line 150
    if ((psf->bytewidth * 65536 + psf->endian) + chars == 536936649) {
#line 150
      goto case_268501193;
    }
#line 157
    if ((psf->bytewidth * 65536 + psf->endian) + chars == 537001984) {
#line 157
      goto case_537001984;
    }
#line 163
    if ((psf->bytewidth * 65536 + psf->endian) + chars == 537067520) {
#line 163
      goto case_537067520;
    }
#line 169
    if ((psf->bytewidth * 65536 + psf->endian) + chars == 537133056) {
#line 169
      goto case_537133056;
    }
#line 177
    if ((psf->bytewidth * 65536 + psf->endian) + chars == 268566528) {
#line 177
      goto case_268566528;
    }
#line 183
    if ((psf->bytewidth * 65536 + psf->endian) + chars == 268632064) {
#line 183
      goto case_268632064;
    }
#line 189
    if ((psf->bytewidth * 65536 + psf->endian) + chars == 268697600) {
#line 189
      goto case_268697600;
    }
#line 195
    goto switch_default;
    case_268501192: /* CIL Label */ 
    case_536936648: /* CIL Label */ 
#line 144
    psf->read_short = & pcm_read_sc2s;
#line 145
    psf->read_int = & pcm_read_sc2i;
#line 146
    psf->read_float = & pcm_read_sc2f;
#line 147
    psf->read_double = & pcm_read_sc2d;
#line 148
    goto switch_break;
    case_268501193: /* CIL Label */ 
    case_536936649: /* CIL Label */ 
#line 151
    psf->read_short = & pcm_read_uc2s;
#line 152
    psf->read_int = & pcm_read_uc2i;
#line 153
    psf->read_float = & pcm_read_uc2f;
#line 154
    psf->read_double = & pcm_read_uc2d;
#line 155
    goto switch_break;
    case_537001984: /* CIL Label */ 
#line 158
    psf->read_short = & pcm_read_bes2s;
#line 159
    psf->read_int = & pcm_read_bes2i;
#line 160
    psf->read_float = & pcm_read_bes2f;
#line 161
    psf->read_double = & pcm_read_bes2d;
#line 162
    goto switch_break;
    case_537067520: /* CIL Label */ 
#line 164
    psf->read_short = & pcm_read_bet2s;
#line 165
    psf->read_int = & pcm_read_bet2i;
#line 166
    psf->read_float = & pcm_read_bet2f;
#line 167
    psf->read_double = & pcm_read_bet2d;
#line 168
    goto switch_break;
    case_537133056: /* CIL Label */ 
#line 171
    psf->read_short = & pcm_read_bei2s;
#line 172
    psf->read_int = & pcm_read_bei2i;
#line 173
    psf->read_float = & pcm_read_bei2f;
#line 174
    psf->read_double = & pcm_read_bei2d;
#line 175
    goto switch_break;
    case_268566528: /* CIL Label */ 
#line 178
    psf->read_short = & pcm_read_les2s;
#line 179
    psf->read_int = & pcm_read_les2i;
#line 180
    psf->read_float = & pcm_read_les2f;
#line 181
    psf->read_double = & pcm_read_les2d;
#line 182
    goto switch_break;
    case_268632064: /* CIL Label */ 
#line 184
    psf->read_short = & pcm_read_let2s;
#line 185
    psf->read_int = & pcm_read_let2i;
#line 186
    psf->read_float = & pcm_read_let2f;
#line 187
    psf->read_double = & pcm_read_let2d;
#line 188
    goto switch_break;
    case_268697600: /* CIL Label */ 
#line 190
    psf->read_short = & pcm_read_lei2s;
#line 191
    psf->read_int = & pcm_read_lei2i;
#line 192
    psf->read_float = & pcm_read_lei2f;
#line 193
    psf->read_double = & pcm_read_lei2d;
#line 194
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 196
    psf_log_printf(psf, "pcm.c returning SFE_UNIMPLEMENTED\nbytewidth %d    endian %d\n",
                   psf->bytewidth, psf->endian);
    }
#line 197
    return (17);
    switch_break: /* CIL Label */ ;
    }

  } else
#line 140
  if (psf->mode == 48) {
#line 140
    goto _L;
  }

#line 201
  if (psf->mode == 32) {
    _L___3: /* CIL Label */ 
    {
#line 204
    if ((psf->bytewidth * 65536 + psf->endian) + chars == 268501192) {
#line 204
      goto case_268501192___0;
    }
#line 204
    if ((psf->bytewidth * 65536 + psf->endian) + chars == 536936648) {
#line 204
      goto case_268501192___0;
    }
#line 211
    if ((psf->bytewidth * 65536 + psf->endian) + chars == 268501193) {
#line 211
      goto case_268501193___0;
    }
#line 211
    if ((psf->bytewidth * 65536 + psf->endian) + chars == 536936649) {
#line 211
      goto case_268501193___0;
    }
#line 218
    if ((psf->bytewidth * 65536 + psf->endian) + chars == 537001984) {
#line 218
      goto case_537001984___0;
    }
#line 225
    if ((psf->bytewidth * 65536 + psf->endian) + chars == 537067520) {
#line 225
      goto case_537067520___0;
    }
#line 232
    if ((psf->bytewidth * 65536 + psf->endian) + chars == 537133056) {
#line 232
      goto case_537133056___0;
    }
#line 239
    if ((psf->bytewidth * 65536 + psf->endian) + chars == 268566528) {
#line 239
      goto case_268566528___0;
    }
#line 246
    if ((psf->bytewidth * 65536 + psf->endian) + chars == 268632064) {
#line 246
      goto case_268632064___0;
    }
#line 253
    if ((psf->bytewidth * 65536 + psf->endian) + chars == 268697600) {
#line 253
      goto case_268697600___0;
    }
#line 260
    goto switch_default___0;
    case_268501192___0: /* CIL Label */ 
    case_536936648___0: /* CIL Label */ 
#line 205
    psf->write_short = & pcm_write_s2sc;
#line 206
    psf->write_int = & pcm_write_i2sc;
#line 207
    psf->write_float = & pcm_write_f2sc;
#line 208
    psf->write_double = & pcm_write_d2sc;
#line 209
    goto switch_break___0;
    case_268501193___0: /* CIL Label */ 
    case_536936649___0: /* CIL Label */ 
#line 212
    psf->write_short = & pcm_write_s2uc;
#line 213
    psf->write_int = & pcm_write_i2uc;
#line 214
    psf->write_float = & pcm_write_f2uc;
#line 215
    psf->write_double = & pcm_write_d2uc;
#line 216
    goto switch_break___0;
    case_537001984___0: /* CIL Label */ 
#line 219
    psf->write_short = & pcm_write_s2bes;
#line 220
    psf->write_int = & pcm_write_i2bes;
#line 221
    psf->write_float = & pcm_write_f2bes;
#line 222
    psf->write_double = & pcm_write_d2bes;
#line 223
    goto switch_break___0;
    case_537067520___0: /* CIL Label */ 
#line 226
    psf->write_short = & pcm_write_s2bet;
#line 227
    psf->write_int = & pcm_write_i2bet;
#line 228
    psf->write_float = & pcm_write_f2bet;
#line 229
    psf->write_double = & pcm_write_d2bet;
#line 230
    goto switch_break___0;
    case_537133056___0: /* CIL Label */ 
#line 233
    psf->write_short = & pcm_write_s2bei;
#line 234
    psf->write_int = & pcm_write_i2bei;
#line 235
    psf->write_float = & pcm_write_f2bei;
#line 236
    psf->write_double = & pcm_write_d2bei;
#line 237
    goto switch_break___0;
    case_268566528___0: /* CIL Label */ 
#line 240
    psf->write_short = & pcm_write_s2les;
#line 241
    psf->write_int = & pcm_write_i2les;
#line 242
    psf->write_float = & pcm_write_f2les;
#line 243
    psf->write_double = & pcm_write_d2les;
#line 244
    goto switch_break___0;
    case_268632064___0: /* CIL Label */ 
#line 247
    psf->write_short = & pcm_write_s2let;
#line 248
    psf->write_int = & pcm_write_i2let;
#line 249
    psf->write_float = & pcm_write_f2let;
#line 250
    psf->write_double = & pcm_write_d2let;
#line 251
    goto switch_break___0;
    case_268697600___0: /* CIL Label */ 
#line 254
    psf->write_short = & pcm_write_s2lei;
#line 255
    psf->write_int = & pcm_write_i2lei;
#line 256
    psf->write_float = & pcm_write_f2lei;
#line 257
    psf->write_double = & pcm_write_d2lei;
#line 258
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 261
    psf_log_printf(psf, "pcm.c returning SFE_UNIMPLEMENTED\nbytewidth %s    endian %d\n",
                   psf->bytewidth, psf->endian);
    }
#line 262
    return (17);
    switch_break___0: /* CIL Label */ ;
    }

  } else
#line 201
  if (psf->mode == 48) {
#line 201
    goto _L___3;
  }

#line 267
  if (psf->filelength > psf->dataoffset) {
#line 268
    if (psf->dataend > 0L) {
#line 268
      tmp___1 = psf->dataend - psf->dataoffset;
    } else {
#line 268
      tmp___1 = psf->filelength - psf->dataoffset;
    }
#line 268
    psf->datalength = tmp___1;
  } else {
#line 272
    psf->datalength = (sf_count_t )0;
  }
#line 274
  if (psf->blockwidth > 0) {
#line 274
    psf->sf.frames = psf->datalength / (long )psf->blockwidth;
  } else {
#line 274
    psf->sf.frames = 1;
  }
#line 276
  return (0);
}
}
#line 283 "/root/libsndfile/src/pcm.c"
__inline static void sc2s_array(signed char *src , int count , short *dest ) 
{ 


  {
  {
#line 284
  while (1) {
    while_continue: /* CIL Label */ ;
#line 284
    count --;
#line 284
    if (! (count >= 0)) {
#line 284
      goto while_break;
    }
#line 285
    *(dest + count) = (short )((int )*(src + count) << 8);
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 290 "/root/libsndfile/src/pcm.c"
__inline static void uc2s_array(unsigned char *src , int count , short *dest ) 
{ 


  {
  {
#line 291
  while (1) {
    while_continue: /* CIL Label */ ;
#line 291
    count --;
#line 291
    if (! (count >= 0)) {
#line 291
      goto while_break;
    }
#line 292
    *(dest + count) = (short )(((int )((short )*(src + count)) - 128) << 8);
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 297 "/root/libsndfile/src/pcm.c"
__inline static void let2s_array(tribyte *src , int count , short *dest ) 
{ 
  unsigned char *ucptr ;

  {
#line 300
  ucptr = (unsigned char *)src + 3 * count;
  {
#line 301
  while (1) {
    while_continue: /* CIL Label */ ;
#line 301
    count --;
#line 301
    if (! (count >= 0)) {
#line 301
      goto while_break;
    }
#line 302
    ucptr -= 3;
#line 303
    *(dest + count) = (short )((int )*(ucptr + 1) + ((int )*(ucptr + 2) << 8));
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 308 "/root/libsndfile/src/pcm.c"
__inline static void bet2s_array(tribyte *src , int count , short *dest ) 
{ 
  unsigned char *ucptr ;

  {
#line 311
  ucptr = (unsigned char *)src + 3 * count;
  {
#line 312
  while (1) {
    while_continue: /* CIL Label */ ;
#line 312
    count --;
#line 312
    if (! (count >= 0)) {
#line 312
      goto while_break;
    }
#line 313
    ucptr -= 3;
#line 314
    *(dest + count) = (short )(((int )*(ucptr + 0) << 8) + (int )*(ucptr + 1));
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 319 "/root/libsndfile/src/pcm.c"
__inline static void lei2s_array(int *src , int count , short *dest ) 
{ 
  int value ;

  {
  {
#line 322
  while (1) {
    while_continue: /* CIL Label */ ;
#line 322
    count --;
#line 322
    if (! (count >= 0)) {
#line 322
      goto while_break;
    }
#line 323
    value = *(src + count);
#line 324
    *(dest + count) = (short )(value >> 16);
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 329 "/root/libsndfile/src/pcm.c"
__inline static void bei2s_array(int *src , int count , short *dest ) 
{ 
  int value ;
  __uint32_t __cil_tmp5 ;

  {
  {
#line 332
  while (1) {
    while_continue: /* CIL Label */ ;
#line 332
    count --;
#line 332
    if (! (count >= 0)) {
#line 332
      goto while_break;
    }
    {
#line 333
    __cil_tmp5 = __bswap_32((__uint32_t )*(src + count));
#line 333
    value = (int )__cil_tmp5;
#line 334
    *(dest + count) = (short )(value >> 16);
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 342 "/root/libsndfile/src/pcm.c"
__inline static void sc2i_array(signed char *src , int count , int *dest ) 
{ 


  {
  {
#line 343
  while (1) {
    while_continue: /* CIL Label */ ;
#line 343
    count --;
#line 343
    if (! (count >= 0)) {
#line 343
      goto while_break;
    }
#line 344
    *(dest + count) = (int )*(src + count) << 24;
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 349 "/root/libsndfile/src/pcm.c"
__inline static void uc2i_array(unsigned char *src , int count , int *dest ) 
{ 


  {
  {
#line 350
  while (1) {
    while_continue: /* CIL Label */ ;
#line 350
    count --;
#line 350
    if (! (count >= 0)) {
#line 350
      goto while_break;
    }
#line 351
    *(dest + count) = ((int )*(src + count) - 128) << 24;
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 356 "/root/libsndfile/src/pcm.c"
__inline static void bes2i_array(short *src , int count , int *dest ) 
{ 
  short value ;
  __uint16_t __cil_tmp5 ;

  {
  {
#line 359
  while (1) {
    while_continue: /* CIL Label */ ;
#line 359
    count --;
#line 359
    if (! (count >= 0)) {
#line 359
      goto while_break;
    }
    {
#line 360
    __cil_tmp5 = __bswap_16((__uint16_t )*(src + count));
#line 360
    value = (short )__cil_tmp5;
#line 361
    *(dest + count) = (int )value << 16;
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 366 "/root/libsndfile/src/pcm.c"
__inline static void les2i_array(short *src , int count , int *dest ) 
{ 
  short value ;

  {
  {
#line 369
  while (1) {
    while_continue: /* CIL Label */ ;
#line 369
    count --;
#line 369
    if (! (count >= 0)) {
#line 369
      goto while_break;
    }
#line 370
    value = *(src + count);
#line 371
    *(dest + count) = (int )value << 16;
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 376 "/root/libsndfile/src/pcm.c"
__inline static void bet2i_array(tribyte *src , int count , int *dest ) 
{ 
  unsigned char *ucptr ;

  {
#line 379
  ucptr = (unsigned char *)src + 3 * count;
  {
#line 380
  while (1) {
    while_continue: /* CIL Label */ ;
#line 380
    count --;
#line 380
    if (! (count >= 0)) {
#line 380
      goto while_break;
    }
#line 381
    ucptr -= 3;
#line 382
    *(dest + count) = (((int )*(ucptr + 0) << 24) + ((int )*(ucptr + 1) << 16)) + ((int )*(ucptr + 2) << 8);
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 387 "/root/libsndfile/src/pcm.c"
__inline static void let2i_array(tribyte *src , int count , int *dest ) 
{ 
  unsigned char *ucptr ;

  {
#line 390
  ucptr = (unsigned char *)src + 3 * count;
  {
#line 391
  while (1) {
    while_continue: /* CIL Label */ ;
#line 391
    count --;
#line 391
    if (! (count >= 0)) {
#line 391
      goto while_break;
    }
#line 392
    ucptr -= 3;
#line 393
    *(dest + count) = (((int )*(ucptr + 0) << 8) + ((int )*(ucptr + 1) << 16)) + ((int )*(ucptr + 2) << 24);
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 401 "/root/libsndfile/src/pcm.c"
__inline static void sc2f_array(signed char *src , int count , float *dest , float normfact ) 
{ 


  {
  {
#line 402
  while (1) {
    while_continue: /* CIL Label */ ;
#line 402
    count --;
#line 402
    if (! (count >= 0)) {
#line 402
      goto while_break;
    }
#line 403
    *(dest + count) = (float )*(src + count) * normfact;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 407 "/root/libsndfile/src/pcm.c"
__inline static void uc2f_array(unsigned char *src , int count , float *dest , float normfact ) 
{ 


  {
  {
#line 408
  while (1) {
    while_continue: /* CIL Label */ ;
#line 408
    count --;
#line 408
    if (! (count >= 0)) {
#line 408
      goto while_break;
    }
#line 409
    *(dest + count) = (float )((int )*(src + count) - 128) * normfact;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 413 "/root/libsndfile/src/pcm.c"
__inline static void les2f_array(short *src , int count , float *dest , float normfact ) 
{ 
  short value ;

  {
  {
#line 416
  while (1) {
    while_continue: /* CIL Label */ ;
#line 416
    count --;
#line 416
    if (! (count >= 0)) {
#line 416
      goto while_break;
    }
#line 417
    value = *(src + count);
#line 418
    value = value;
#line 419
    *(dest + count) = (float )value * normfact;
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 424 "/root/libsndfile/src/pcm.c"
__inline static void bes2f_array(short *src , int count , float *dest , float normfact ) 
{ 
  short value ;
  __uint16_t __cil_tmp6 ;

  {
  {
#line 427
  while (1) {
    while_continue: /* CIL Label */ ;
#line 427
    count --;
#line 427
    if (! (count >= 0)) {
#line 427
      goto while_break;
    }
    {
#line 428
    value = *(src + count);
#line 429
    __cil_tmp6 = __bswap_16((__uint16_t )value);
#line 429
    value = (short )__cil_tmp6;
#line 430
    *(dest + count) = (float )value * normfact;
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 435 "/root/libsndfile/src/pcm.c"
__inline static void let2f_array(tribyte *src , int count , float *dest , float normfact ) 
{ 
  unsigned char *ucptr ;
  int value ;

  {
#line 439
  ucptr = (unsigned char *)src + 3 * count;
  {
#line 440
  while (1) {
    while_continue: /* CIL Label */ ;
#line 440
    count --;
#line 440
    if (! (count >= 0)) {
#line 440
      goto while_break;
    }
#line 441
    ucptr -= 3;
#line 442
    value = (((int )*(ucptr + 0) << 8) + ((int )*(ucptr + 1) << 16)) + ((int )*(ucptr + 2) << 24);
#line 443
    *(dest + count) = (float )value * normfact;
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 448 "/root/libsndfile/src/pcm.c"
__inline static void bet2f_array(tribyte *src , int count , float *dest , float normfact ) 
{ 
  unsigned char *ucptr ;
  int value ;

  {
#line 452
  ucptr = (unsigned char *)src + 3 * count;
  {
#line 453
  while (1) {
    while_continue: /* CIL Label */ ;
#line 453
    count --;
#line 453
    if (! (count >= 0)) {
#line 453
      goto while_break;
    }
#line 454
    ucptr -= 3;
#line 455
    value = (((int )*(ucptr + 0) << 24) + ((int )*(ucptr + 1) << 16)) + ((int )*(ucptr + 2) << 8);
#line 456
    *(dest + count) = (float )value * normfact;
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 461 "/root/libsndfile/src/pcm.c"
__inline static void lei2f_array(int *src , int count , float *dest , float normfact ) 
{ 
  int value ;

  {
  {
#line 464
  while (1) {
    while_continue: /* CIL Label */ ;
#line 464
    count --;
#line 464
    if (! (count >= 0)) {
#line 464
      goto while_break;
    }
#line 465
    value = *(src + count);
#line 466
    value = value;
#line 467
    *(dest + count) = (float )value * normfact;
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 472 "/root/libsndfile/src/pcm.c"
__inline static void bei2f_array(int *src , int count , float *dest , float normfact ) 
{ 
  int value ;
  __uint32_t __cil_tmp6 ;

  {
  {
#line 475
  while (1) {
    while_continue: /* CIL Label */ ;
#line 475
    count --;
#line 475
    if (! (count >= 0)) {
#line 475
      goto while_break;
    }
    {
#line 476
    value = *(src + count);
#line 477
    __cil_tmp6 = __bswap_32((__uint32_t )value);
#line 477
    value = (int )__cil_tmp6;
#line 478
    *(dest + count) = (float )value * normfact;
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 486 "/root/libsndfile/src/pcm.c"
__inline static void sc2d_array(signed char *src , int count , double *dest , double normfact ) 
{ 


  {
  {
#line 487
  while (1) {
    while_continue: /* CIL Label */ ;
#line 487
    count --;
#line 487
    if (! (count >= 0)) {
#line 487
      goto while_break;
    }
#line 488
    *(dest + count) = (double )*(src + count) * normfact;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 492 "/root/libsndfile/src/pcm.c"
__inline static void uc2d_array(unsigned char *src , int count , double *dest , double normfact ) 
{ 


  {
  {
#line 493
  while (1) {
    while_continue: /* CIL Label */ ;
#line 493
    count --;
#line 493
    if (! (count >= 0)) {
#line 493
      goto while_break;
    }
#line 494
    *(dest + count) = (double )((int )*(src + count) - 128) * normfact;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 498 "/root/libsndfile/src/pcm.c"
__inline static void les2d_array(short *src , int count , double *dest , double normfact ) 
{ 
  short value ;

  {
  {
#line 501
  while (1) {
    while_continue: /* CIL Label */ ;
#line 501
    count --;
#line 501
    if (! (count >= 0)) {
#line 501
      goto while_break;
    }
#line 502
    value = *(src + count);
#line 503
    value = value;
#line 504
    *(dest + count) = (double )value * normfact;
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 509 "/root/libsndfile/src/pcm.c"
__inline static void bes2d_array(short *src , int count , double *dest , double normfact ) 
{ 
  short value ;
  __uint16_t __cil_tmp6 ;

  {
  {
#line 512
  while (1) {
    while_continue: /* CIL Label */ ;
#line 512
    count --;
#line 512
    if (! (count >= 0)) {
#line 512
      goto while_break;
    }
    {
#line 513
    value = *(src + count);
#line 514
    __cil_tmp6 = __bswap_16((__uint16_t )value);
#line 514
    value = (short )__cil_tmp6;
#line 515
    *(dest + count) = (double )value * normfact;
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 520 "/root/libsndfile/src/pcm.c"
__inline static void let2d_array(tribyte *src , int count , double *dest , double normfact ) 
{ 
  unsigned char *ucptr ;
  int value ;

  {
#line 524
  ucptr = (unsigned char *)src + 3 * count;
  {
#line 525
  while (1) {
    while_continue: /* CIL Label */ ;
#line 525
    count --;
#line 525
    if (! (count >= 0)) {
#line 525
      goto while_break;
    }
#line 526
    ucptr -= 3;
#line 527
    value = (((int )*(ucptr + 0) << 8) + ((int )*(ucptr + 1) << 16)) + ((int )*(ucptr + 2) << 24);
#line 528
    *(dest + count) = (double )value * normfact;
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 533 "/root/libsndfile/src/pcm.c"
__inline static void bet2d_array(tribyte *src , int count , double *dest , double normfact ) 
{ 
  unsigned char *ucptr ;
  int value ;

  {
#line 537
  ucptr = (unsigned char *)src + 3 * count;
  {
#line 538
  while (1) {
    while_continue: /* CIL Label */ ;
#line 538
    count --;
#line 538
    if (! (count >= 0)) {
#line 538
      goto while_break;
    }
#line 539
    ucptr -= 3;
#line 540
    value = (((int )*(ucptr + 0) << 24) | ((int )*(ucptr + 1) << 16)) | ((int )*(ucptr + 2) << 8);
#line 541
    *(dest + count) = (double )value * normfact;
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 546 "/root/libsndfile/src/pcm.c"
__inline static void lei2d_array(int *src , int count , double *dest , double normfact ) 
{ 
  int value ;

  {
  {
#line 549
  while (1) {
    while_continue: /* CIL Label */ ;
#line 549
    count --;
#line 549
    if (! (count >= 0)) {
#line 549
      goto while_break;
    }
#line 550
    value = *(src + count);
#line 551
    value = value;
#line 552
    *(dest + count) = (double )value * normfact;
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 557 "/root/libsndfile/src/pcm.c"
__inline static void bei2d_array(int *src , int count , double *dest , double normfact ) 
{ 
  int value ;
  __uint32_t __cil_tmp6 ;

  {
  {
#line 560
  while (1) {
    while_continue: /* CIL Label */ ;
#line 560
    count --;
#line 560
    if (! (count >= 0)) {
#line 560
      goto while_break;
    }
    {
#line 561
    value = *(src + count);
#line 562
    __cil_tmp6 = __bswap_32((__uint32_t )value);
#line 562
    value = (int )__cil_tmp6;
#line 563
    *(dest + count) = (double )value * normfact;
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 571 "/root/libsndfile/src/pcm.c"
__inline static void s2sc_array(short const   *src , signed char *dest , int count ) 
{ 


  {
  {
#line 572
  while (1) {
    while_continue: /* CIL Label */ ;
#line 572
    count --;
#line 572
    if (! (count >= 0)) {
#line 572
      goto while_break;
    }
#line 573
    *(dest + count) = (signed char )((int )*(src + count) >> 8);
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 577 "/root/libsndfile/src/pcm.c"
__inline static void s2uc_array(short const   *src , unsigned char *dest , int count ) 
{ 


  {
  {
#line 578
  while (1) {
    while_continue: /* CIL Label */ ;
#line 578
    count --;
#line 578
    if (! (count >= 0)) {
#line 578
      goto while_break;
    }
#line 579
    *(dest + count) = (unsigned char )(((int )*(src + count) >> 8) + 128);
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 583 "/root/libsndfile/src/pcm.c"
__inline static void s2let_array(short const   *src , tribyte *dest , int count ) 
{ 
  unsigned char *ucptr ;

  {
#line 586
  ucptr = (unsigned char *)dest + 3 * count;
  {
#line 587
  while (1) {
    while_continue: /* CIL Label */ ;
#line 587
    count --;
#line 587
    if (! (count >= 0)) {
#line 587
      goto while_break;
    }
#line 588
    ucptr -= 3;
#line 589
    *(ucptr + 0) = (unsigned char )0;
#line 590
    *(ucptr + 1) = (unsigned char )*(src + count);
#line 591
    *(ucptr + 2) = (unsigned char )((int )*(src + count) >> 8);
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 596 "/root/libsndfile/src/pcm.c"
__inline static void s2bet_array(short const   *src , tribyte *dest , int count ) 
{ 
  unsigned char *ucptr ;

  {
#line 599
  ucptr = (unsigned char *)dest + 3 * count;
  {
#line 600
  while (1) {
    while_continue: /* CIL Label */ ;
#line 600
    count --;
#line 600
    if (! (count >= 0)) {
#line 600
      goto while_break;
    }
#line 601
    ucptr -= 3;
#line 602
    *(ucptr + 2) = (unsigned char )0;
#line 603
    *(ucptr + 1) = (unsigned char )*(src + count);
#line 604
    *(ucptr + 0) = (unsigned char )((int )*(src + count) >> 8);
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 609 "/root/libsndfile/src/pcm.c"
__inline static void s2lei_array(short const   *src , int *dest , int count ) 
{ 
  unsigned char *ucptr ;

  {
#line 612
  ucptr = (unsigned char *)dest + 4 * count;
  {
#line 613
  while (1) {
    while_continue: /* CIL Label */ ;
#line 613
    count --;
#line 613
    if (! (count >= 0)) {
#line 613
      goto while_break;
    }
#line 614
    ucptr -= 4;
#line 615
    *(ucptr + 0) = (unsigned char )0;
#line 616
    *(ucptr + 1) = (unsigned char )0;
#line 617
    *(ucptr + 2) = (unsigned char )*(src + count);
#line 618
    *(ucptr + 3) = (unsigned char )((int )*(src + count) >> 8);
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 623 "/root/libsndfile/src/pcm.c"
__inline static void s2bei_array(short const   *src , int *dest , int count ) 
{ 
  unsigned char *ucptr ;

  {
#line 626
  ucptr = (unsigned char *)dest + 4 * count;
  {
#line 627
  while (1) {
    while_continue: /* CIL Label */ ;
#line 627
    count --;
#line 627
    if (! (count >= 0)) {
#line 627
      goto while_break;
    }
#line 628
    ucptr -= 4;
#line 629
    *(ucptr + 0) = (unsigned char )((int )*(src + count) >> 8);
#line 630
    *(ucptr + 1) = (unsigned char )*(src + count);
#line 631
    *(ucptr + 2) = (unsigned char )0;
#line 632
    *(ucptr + 3) = (unsigned char )0;
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 640 "/root/libsndfile/src/pcm.c"
__inline static void i2sc_array(int const   *src , signed char *dest , int count ) 
{ 


  {
  {
#line 641
  while (1) {
    while_continue: /* CIL Label */ ;
#line 641
    count --;
#line 641
    if (! (count >= 0)) {
#line 641
      goto while_break;
    }
#line 642
    *(dest + count) = (signed char )(*(src + count) >> 24);
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 646 "/root/libsndfile/src/pcm.c"
__inline static void i2uc_array(int const   *src , unsigned char *dest , int count ) 
{ 


  {
  {
#line 647
  while (1) {
    while_continue: /* CIL Label */ ;
#line 647
    count --;
#line 647
    if (! (count >= 0)) {
#line 647
      goto while_break;
    }
#line 648
    *(dest + count) = (unsigned char )((*(src + count) >> 24) + 128);
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 652 "/root/libsndfile/src/pcm.c"
__inline static void i2bes_array(int const   *src , short *dest , int count ) 
{ 
  unsigned char *ucptr ;

  {
#line 655
  ucptr = (unsigned char *)dest + 2 * count;
  {
#line 656
  while (1) {
    while_continue: /* CIL Label */ ;
#line 656
    count --;
#line 656
    if (! (count >= 0)) {
#line 656
      goto while_break;
    }
#line 657
    ucptr -= 2;
#line 658
    *(ucptr + 0) = (unsigned char )(*(src + count) >> 24);
#line 659
    *(ucptr + 1) = (unsigned char )(*(src + count) >> 16);
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 664 "/root/libsndfile/src/pcm.c"
__inline static void i2les_array(int const   *src , short *dest , int count ) 
{ 
  unsigned char *ucptr ;

  {
#line 667
  ucptr = (unsigned char *)dest + 2 * count;
  {
#line 668
  while (1) {
    while_continue: /* CIL Label */ ;
#line 668
    count --;
#line 668
    if (! (count >= 0)) {
#line 668
      goto while_break;
    }
#line 669
    ucptr -= 2;
#line 670
    *(ucptr + 0) = (unsigned char )(*(src + count) >> 16);
#line 671
    *(ucptr + 1) = (unsigned char )(*(src + count) >> 24);
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 676 "/root/libsndfile/src/pcm.c"
__inline static void i2let_array(int const   *src , tribyte *dest , int count ) 
{ 
  unsigned char *ucptr ;
  int value ;

  {
#line 680
  ucptr = (unsigned char *)dest + 3 * count;
  {
#line 681
  while (1) {
    while_continue: /* CIL Label */ ;
#line 681
    count --;
#line 681
    if (! (count >= 0)) {
#line 681
      goto while_break;
    }
#line 682
    ucptr -= 3;
#line 683
    value = *(src + count) >> 8;
#line 684
    *(ucptr + 0) = (unsigned char )value;
#line 685
    *(ucptr + 1) = (unsigned char )(value >> 8);
#line 686
    *(ucptr + 2) = (unsigned char )(value >> 16);
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 691 "/root/libsndfile/src/pcm.c"
__inline static void i2bet_array(int const   *src , tribyte *dest , int count ) 
{ 
  unsigned char *ucptr ;
  int value ;

  {
#line 695
  ucptr = (unsigned char *)dest + 3 * count;
  {
#line 696
  while (1) {
    while_continue: /* CIL Label */ ;
#line 696
    count --;
#line 696
    if (! (count >= 0)) {
#line 696
      goto while_break;
    }
#line 697
    ucptr -= 3;
#line 698
    value = *(src + count) >> 8;
#line 699
    *(ucptr + 2) = (unsigned char )value;
#line 700
    *(ucptr + 1) = (unsigned char )(value >> 8);
#line 701
    *(ucptr + 0) = (unsigned char )(value >> 16);
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 709 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_read_sc2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp7 ;

  {
#line 711
  total = (sf_count_t )0;
#line 713
  bufferlen = (int )(sizeof(psf->u.scbuf) / sizeof(psf->u.scbuf[0]));
  {
#line 715
  while (1) {
    while_continue: /* CIL Label */ ;
#line 715
    if (! (len > 0L)) {
#line 715
      goto while_break;
    }
#line 716
    if (len < (long )bufferlen) {
#line 717
      bufferlen = (int )len;
    }
    {
#line 718
    __cil_tmp7 = psf_fread((signed char *)psf->u.scbuf, (sf_count_t )sizeof(signed char ),
                           (sf_count_t )bufferlen, psf);
#line 718
    readcount = (int )__cil_tmp7;
#line 719
    sc2s_array((signed char *)psf->u.scbuf, readcount, ptr + total);
#line 720
    total += (long )readcount;
    }
#line 721
    if (readcount < bufferlen) {
#line 722
      goto while_break;
    }
#line 723
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 726
  return (total);
}
}
#line 730 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_read_uc2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp7 ;

  {
#line 732
  total = (sf_count_t )0;
#line 734
  bufferlen = (int )(sizeof(psf->u.ucbuf) / sizeof(psf->u.ucbuf[0]));
  {
#line 736
  while (1) {
    while_continue: /* CIL Label */ ;
#line 736
    if (! (len > 0L)) {
#line 736
      goto while_break;
    }
#line 737
    if (len < (long )bufferlen) {
#line 738
      bufferlen = (int )len;
    }
    {
#line 739
    __cil_tmp7 = psf_fread((unsigned char *)psf->u.ucbuf, (sf_count_t )sizeof(unsigned char ),
                           (sf_count_t )bufferlen, psf);
#line 739
    readcount = (int )__cil_tmp7;
#line 740
    uc2s_array((unsigned char *)psf->u.ucbuf, readcount, ptr + total);
#line 741
    total += (long )readcount;
    }
#line 742
    if (readcount < bufferlen) {
#line 743
      goto while_break;
    }
#line 744
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 747
  return (total);
}
}
#line 751 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_read_bes2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  int total ;
  sf_count_t __cil_tmp5 ;

  {
  {
#line 754
  __cil_tmp5 = psf_fread(ptr, (sf_count_t )sizeof(short ), len, psf);
#line 754
  total = (int )__cil_tmp5;
  }
#line 755
  if (1) {
    {
#line 756
    endswap_short_array(ptr, (int )len);
    }
  }
#line 758
  return ((sf_count_t )total);
}
}
#line 762 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_read_les2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  int total ;
  sf_count_t __cil_tmp5 ;

  {
  {
#line 765
  __cil_tmp5 = psf_fread(ptr, (sf_count_t )sizeof(short ), len, psf);
#line 765
  total = (int )__cil_tmp5;
  }
#line 766
  if (0) {
    {
#line 767
    endswap_short_array(ptr, (int )len);
    }
  }
#line 769
  return ((sf_count_t )total);
}
}
#line 773 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_read_bet2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp7 ;

  {
#line 775
  total = (sf_count_t )0;
#line 777
  bufferlen = (int )(sizeof(psf->u.ucbuf) / 3UL);
  {
#line 779
  while (1) {
    while_continue: /* CIL Label */ ;
#line 779
    if (! (len > 0L)) {
#line 779
      goto while_break;
    }
#line 780
    if (len < (long )bufferlen) {
#line 781
      bufferlen = (int )len;
    }
    {
#line 782
    __cil_tmp7 = psf_fread((unsigned char *)psf->u.ucbuf, (sf_count_t )3, (sf_count_t )bufferlen,
                           psf);
#line 782
    readcount = (int )__cil_tmp7;
#line 783
    bet2s_array((tribyte *)((unsigned char *)psf->u.ucbuf), readcount, ptr + total);
#line 784
    total += (long )readcount;
    }
#line 785
    if (readcount < bufferlen) {
#line 786
      goto while_break;
    }
#line 787
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 790
  return (total);
}
}
#line 794 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_read_let2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp7 ;

  {
#line 796
  total = (sf_count_t )0;
#line 798
  bufferlen = (int )(sizeof(psf->u.ucbuf) / 3UL);
  {
#line 800
  while (1) {
    while_continue: /* CIL Label */ ;
#line 800
    if (! (len > 0L)) {
#line 800
      goto while_break;
    }
#line 801
    if (len < (long )bufferlen) {
#line 802
      bufferlen = (int )len;
    }
    {
#line 803
    __cil_tmp7 = psf_fread((unsigned char *)psf->u.ucbuf, (sf_count_t )3, (sf_count_t )bufferlen,
                           psf);
#line 803
    readcount = (int )__cil_tmp7;
#line 804
    let2s_array((tribyte *)((unsigned char *)psf->u.ucbuf), readcount, ptr + total);
#line 805
    total += (long )readcount;
    }
#line 806
    if (readcount < bufferlen) {
#line 807
      goto while_break;
    }
#line 808
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 811
  return (total);
}
}
#line 815 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_read_bei2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp7 ;

  {
#line 817
  total = (sf_count_t )0;
#line 819
  bufferlen = (int )(sizeof(psf->u.ibuf) / sizeof(psf->u.ibuf[0]));
  {
#line 821
  while (1) {
    while_continue: /* CIL Label */ ;
#line 821
    if (! (len > 0L)) {
#line 821
      goto while_break;
    }
#line 822
    if (len < (long )bufferlen) {
#line 823
      bufferlen = (int )len;
    }
    {
#line 824
    __cil_tmp7 = psf_fread((int *)psf->u.ibuf, (sf_count_t )sizeof(int ), (sf_count_t )bufferlen,
                           psf);
#line 824
    readcount = (int )__cil_tmp7;
#line 825
    bei2s_array((int *)psf->u.ibuf, readcount, ptr + total);
#line 826
    total += (long )readcount;
    }
#line 827
    if (readcount < bufferlen) {
#line 828
      goto while_break;
    }
#line 829
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 832
  return (total);
}
}
#line 836 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_read_lei2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp7 ;

  {
#line 838
  total = (sf_count_t )0;
#line 840
  bufferlen = (int )(sizeof(psf->u.ibuf) / sizeof(psf->u.ibuf[0]));
  {
#line 842
  while (1) {
    while_continue: /* CIL Label */ ;
#line 842
    if (! (len > 0L)) {
#line 842
      goto while_break;
    }
#line 843
    if (len < (long )bufferlen) {
#line 844
      bufferlen = (int )len;
    }
    {
#line 845
    __cil_tmp7 = psf_fread((int *)psf->u.ibuf, (sf_count_t )sizeof(int ), (sf_count_t )bufferlen,
                           psf);
#line 845
    readcount = (int )__cil_tmp7;
#line 846
    lei2s_array((int *)psf->u.ibuf, readcount, ptr + total);
#line 847
    total += (long )readcount;
    }
#line 848
    if (readcount < bufferlen) {
#line 849
      goto while_break;
    }
#line 850
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 853
  return (total);
}
}
#line 860 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_read_sc2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp7 ;

  {
#line 862
  total = (sf_count_t )0;
#line 864
  bufferlen = (int )(sizeof(psf->u.scbuf) / sizeof(psf->u.scbuf[0]));
  {
#line 866
  while (1) {
    while_continue: /* CIL Label */ ;
#line 866
    if (! (len > 0L)) {
#line 866
      goto while_break;
    }
#line 867
    if (len < (long )bufferlen) {
#line 868
      bufferlen = (int )len;
    }
    {
#line 869
    __cil_tmp7 = psf_fread((signed char *)psf->u.scbuf, (sf_count_t )sizeof(signed char ),
                           (sf_count_t )bufferlen, psf);
#line 869
    readcount = (int )__cil_tmp7;
#line 870
    sc2i_array((signed char *)psf->u.scbuf, readcount, ptr + total);
#line 871
    total += (long )readcount;
    }
#line 872
    if (readcount < bufferlen) {
#line 873
      goto while_break;
    }
#line 874
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 877
  return (total);
}
}
#line 881 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_read_uc2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp7 ;

  {
#line 883
  total = (sf_count_t )0;
#line 885
  bufferlen = (int )(sizeof(psf->u.ucbuf) / sizeof(psf->u.ucbuf[0]));
  {
#line 887
  while (1) {
    while_continue: /* CIL Label */ ;
#line 887
    if (! (len > 0L)) {
#line 887
      goto while_break;
    }
#line 888
    if (len < (long )bufferlen) {
#line 889
      bufferlen = (int )len;
    }
    {
#line 890
    __cil_tmp7 = psf_fread((unsigned char *)psf->u.ucbuf, (sf_count_t )sizeof(unsigned char ),
                           (sf_count_t )bufferlen, psf);
#line 890
    readcount = (int )__cil_tmp7;
#line 891
    uc2i_array((unsigned char *)psf->u.ucbuf, readcount, ptr + total);
#line 892
    total += (long )readcount;
    }
#line 893
    if (readcount < bufferlen) {
#line 894
      goto while_break;
    }
#line 895
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 898
  return (total);
}
}
#line 902 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_read_bes2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp7 ;

  {
#line 904
  total = (sf_count_t )0;
#line 906
  bufferlen = (int )(sizeof(psf->u.sbuf) / sizeof(psf->u.sbuf[0]));
  {
#line 908
  while (1) {
    while_continue: /* CIL Label */ ;
#line 908
    if (! (len > 0L)) {
#line 908
      goto while_break;
    }
#line 909
    if (len < (long )bufferlen) {
#line 910
      bufferlen = (int )len;
    }
    {
#line 911
    __cil_tmp7 = psf_fread((short *)psf->u.sbuf, (sf_count_t )sizeof(short ), (sf_count_t )bufferlen,
                           psf);
#line 911
    readcount = (int )__cil_tmp7;
#line 912
    bes2i_array((short *)psf->u.sbuf, readcount, ptr + total);
#line 913
    total += (long )readcount;
    }
#line 914
    if (readcount < bufferlen) {
#line 915
      goto while_break;
    }
#line 916
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 919
  return (total);
}
}
#line 923 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_read_les2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp7 ;

  {
#line 925
  total = (sf_count_t )0;
#line 927
  bufferlen = (int )(sizeof(psf->u.sbuf) / sizeof(psf->u.sbuf[0]));
  {
#line 929
  while (1) {
    while_continue: /* CIL Label */ ;
#line 929
    if (! (len > 0L)) {
#line 929
      goto while_break;
    }
#line 930
    if (len < (long )bufferlen) {
#line 931
      bufferlen = (int )len;
    }
    {
#line 932
    __cil_tmp7 = psf_fread((short *)psf->u.sbuf, (sf_count_t )sizeof(short ), (sf_count_t )bufferlen,
                           psf);
#line 932
    readcount = (int )__cil_tmp7;
#line 933
    les2i_array((short *)psf->u.sbuf, readcount, ptr + total);
#line 934
    total += (long )readcount;
    }
#line 935
    if (readcount < bufferlen) {
#line 936
      goto while_break;
    }
#line 937
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 940
  return (total);
}
}
#line 944 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_read_bet2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp7 ;

  {
#line 946
  total = (sf_count_t )0;
#line 948
  bufferlen = (int )(sizeof(psf->u.ucbuf) / 3UL);
  {
#line 950
  while (1) {
    while_continue: /* CIL Label */ ;
#line 950
    if (! (len > 0L)) {
#line 950
      goto while_break;
    }
#line 951
    if (len < (long )bufferlen) {
#line 952
      bufferlen = (int )len;
    }
    {
#line 953
    __cil_tmp7 = psf_fread((unsigned char *)psf->u.ucbuf, (sf_count_t )3, (sf_count_t )bufferlen,
                           psf);
#line 953
    readcount = (int )__cil_tmp7;
#line 954
    bet2i_array((tribyte *)((unsigned char *)psf->u.ucbuf), readcount, ptr + total);
#line 955
    total += (long )readcount;
    }
#line 956
    if (readcount < bufferlen) {
#line 957
      goto while_break;
    }
#line 958
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 961
  return (total);
}
}
#line 965 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_read_let2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp7 ;

  {
#line 967
  total = (sf_count_t )0;
#line 969
  bufferlen = (int )(sizeof(psf->u.ucbuf) / 3UL);
  {
#line 971
  while (1) {
    while_continue: /* CIL Label */ ;
#line 971
    if (! (len > 0L)) {
#line 971
      goto while_break;
    }
#line 972
    if (len < (long )bufferlen) {
#line 973
      bufferlen = (int )len;
    }
    {
#line 974
    __cil_tmp7 = psf_fread((unsigned char *)psf->u.ucbuf, (sf_count_t )3, (sf_count_t )bufferlen,
                           psf);
#line 974
    readcount = (int )__cil_tmp7;
#line 975
    let2i_array((tribyte *)((unsigned char *)psf->u.ucbuf), readcount, ptr + total);
#line 976
    total += (long )readcount;
    }
#line 977
    if (readcount < bufferlen) {
#line 978
      goto while_break;
    }
#line 979
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 982
  return (total);
}
}
#line 986 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_read_bei2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  int total ;
  sf_count_t __cil_tmp5 ;

  {
  {
#line 989
  __cil_tmp5 = psf_fread(ptr, (sf_count_t )sizeof(int ), len, psf);
#line 989
  total = (int )__cil_tmp5;
  }
#line 990
  if (1) {
    {
#line 991
    endswap_int_array(ptr, (int )len);
    }
  }
#line 993
  return ((sf_count_t )total);
}
}
#line 997 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_read_lei2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  int total ;
  sf_count_t __cil_tmp5 ;

  {
  {
#line 1000
  __cil_tmp5 = psf_fread(ptr, (sf_count_t )sizeof(int ), len, psf);
#line 1000
  total = (int )__cil_tmp5;
  }
#line 1001
  if (0) {
    {
#line 1002
    endswap_int_array(ptr, (int )len);
    }
  }
#line 1004
  return ((sf_count_t )total);
}
}
#line 1011 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_read_sc2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  sf_count_t __cil_tmp9 ;

  {
#line 1013
  total = (sf_count_t )0;
#line 1016
  if (psf->norm_float == 1) {
#line 1016
    tmp = 1. / (double )((float )128);
  } else {
#line 1016
    tmp = 1.;
  }
#line 1016
  normfact = (float )tmp;
#line 1018
  bufferlen = (int )(sizeof(psf->u.scbuf) / sizeof(psf->u.scbuf[0]));
  {
#line 1020
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1020
    if (! (len > 0L)) {
#line 1020
      goto while_break;
    }
#line 1021
    if (len < (long )bufferlen) {
#line 1022
      bufferlen = (int )len;
    }
    {
#line 1023
    __cil_tmp9 = psf_fread((signed char *)psf->u.scbuf, (sf_count_t )sizeof(signed char ),
                           (sf_count_t )bufferlen, psf);
#line 1023
    readcount = (int )__cil_tmp9;
#line 1024
    sc2f_array((signed char *)psf->u.scbuf, readcount, ptr + total, normfact);
#line 1025
    total += (long )readcount;
    }
#line 1026
    if (readcount < bufferlen) {
#line 1027
      goto while_break;
    }
#line 1028
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 1031
  return (total);
}
}
#line 1035 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_read_uc2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  sf_count_t __cil_tmp9 ;

  {
#line 1037
  total = (sf_count_t )0;
#line 1040
  if (psf->norm_float == 1) {
#line 1040
    tmp = 1. / (double )((float )128);
  } else {
#line 1040
    tmp = 1.;
  }
#line 1040
  normfact = (float )tmp;
#line 1042
  bufferlen = (int )(sizeof(psf->u.ucbuf) / sizeof(psf->u.ucbuf[0]));
  {
#line 1044
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1044
    if (! (len > 0L)) {
#line 1044
      goto while_break;
    }
#line 1045
    if (len < (long )bufferlen) {
#line 1046
      bufferlen = (int )len;
    }
    {
#line 1047
    __cil_tmp9 = psf_fread((unsigned char *)psf->u.ucbuf, (sf_count_t )sizeof(unsigned char ),
                           (sf_count_t )bufferlen, psf);
#line 1047
    readcount = (int )__cil_tmp9;
#line 1048
    uc2f_array((unsigned char *)psf->u.ucbuf, readcount, ptr + total, normfact);
#line 1049
    total += (long )readcount;
    }
#line 1050
    if (readcount < bufferlen) {
#line 1051
      goto while_break;
    }
#line 1052
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 1055
  return (total);
}
}
#line 1059 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_read_bes2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  sf_count_t __cil_tmp9 ;

  {
#line 1061
  total = (sf_count_t )0;
#line 1064
  if (psf->norm_float == 1) {
#line 1064
    tmp = 1. / (double )((float )32768);
  } else {
#line 1064
    tmp = 1.;
  }
#line 1064
  normfact = (float )tmp;
#line 1066
  bufferlen = (int )(sizeof(psf->u.sbuf) / sizeof(psf->u.sbuf[0]));
  {
#line 1068
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1068
    if (! (len > 0L)) {
#line 1068
      goto while_break;
    }
#line 1069
    if (len < (long )bufferlen) {
#line 1070
      bufferlen = (int )len;
    }
    {
#line 1071
    __cil_tmp9 = psf_fread((short *)psf->u.sbuf, (sf_count_t )sizeof(short ), (sf_count_t )bufferlen,
                           psf);
#line 1071
    readcount = (int )__cil_tmp9;
#line 1072
    bes2f_array((short *)psf->u.sbuf, readcount, ptr + total, normfact);
#line 1073
    total += (long )readcount;
    }
#line 1074
    if (readcount < bufferlen) {
#line 1075
      goto while_break;
    }
#line 1076
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 1079
  return (total);
}
}
#line 1083 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_read_les2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  sf_count_t __cil_tmp9 ;

  {
#line 1085
  total = (sf_count_t )0;
#line 1088
  if (psf->norm_float == 1) {
#line 1088
    tmp = 1. / (double )((float )32768);
  } else {
#line 1088
    tmp = 1.;
  }
#line 1088
  normfact = (float )tmp;
#line 1090
  bufferlen = (int )(sizeof(psf->u.sbuf) / sizeof(psf->u.sbuf[0]));
  {
#line 1092
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1092
    if (! (len > 0L)) {
#line 1092
      goto while_break;
    }
#line 1093
    if (len < (long )bufferlen) {
#line 1094
      bufferlen = (int )len;
    }
    {
#line 1095
    __cil_tmp9 = psf_fread((short *)psf->u.sbuf, (sf_count_t )sizeof(short ), (sf_count_t )bufferlen,
                           psf);
#line 1095
    readcount = (int )__cil_tmp9;
#line 1096
    les2f_array((short *)psf->u.sbuf, readcount, ptr + total, normfact);
#line 1097
    total += (long )readcount;
    }
#line 1098
    if (readcount < bufferlen) {
#line 1099
      goto while_break;
    }
#line 1100
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 1103
  return (total);
}
}
#line 1107 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_read_bet2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  sf_count_t __cil_tmp9 ;

  {
#line 1109
  total = (sf_count_t )0;
#line 1113
  if (psf->norm_float == 1) {
#line 1113
    tmp = 1. / (double )((float )2147483648U);
  } else {
#line 1113
    tmp = 1. / 256.;
  }
#line 1113
  normfact = (float )tmp;
#line 1115
  bufferlen = (int )(sizeof(psf->u.ucbuf) / 3UL);
  {
#line 1117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1117
    if (! (len > 0L)) {
#line 1117
      goto while_break;
    }
#line 1118
    if (len < (long )bufferlen) {
#line 1119
      bufferlen = (int )len;
    }
    {
#line 1120
    __cil_tmp9 = psf_fread((unsigned char *)psf->u.ucbuf, (sf_count_t )3, (sf_count_t )bufferlen,
                           psf);
#line 1120
    readcount = (int )__cil_tmp9;
#line 1121
    bet2f_array((tribyte *)((unsigned char *)psf->u.ucbuf), readcount, ptr + total,
                normfact);
#line 1122
    total += (long )readcount;
    }
#line 1123
    if (readcount < bufferlen) {
#line 1124
      goto while_break;
    }
#line 1125
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 1128
  return (total);
}
}
#line 1132 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_read_let2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  sf_count_t __cil_tmp9 ;

  {
#line 1134
  total = (sf_count_t )0;
#line 1138
  if (psf->norm_float == 1) {
#line 1138
    tmp = 1. / (double )((float )2147483648U);
  } else {
#line 1138
    tmp = 1. / 256.;
  }
#line 1138
  normfact = (float )tmp;
#line 1140
  bufferlen = (int )(sizeof(psf->u.ucbuf) / 3UL);
  {
#line 1142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1142
    if (! (len > 0L)) {
#line 1142
      goto while_break;
    }
#line 1143
    if (len < (long )bufferlen) {
#line 1144
      bufferlen = (int )len;
    }
    {
#line 1145
    __cil_tmp9 = psf_fread((unsigned char *)psf->u.ucbuf, (sf_count_t )3, (sf_count_t )bufferlen,
                           psf);
#line 1145
    readcount = (int )__cil_tmp9;
#line 1146
    let2f_array((tribyte *)((unsigned char *)psf->u.ucbuf), readcount, ptr + total,
                normfact);
#line 1147
    total += (long )readcount;
    }
#line 1148
    if (readcount < bufferlen) {
#line 1149
      goto while_break;
    }
#line 1150
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 1153
  return (total);
}
}
#line 1157 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_read_bei2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  sf_count_t __cil_tmp9 ;

  {
#line 1159
  total = (sf_count_t )0;
#line 1162
  if (psf->norm_float == 1) {
#line 1162
    tmp = 1. / (double )((float )2147483648U);
  } else {
#line 1162
    tmp = 1.;
  }
#line 1162
  normfact = (float )tmp;
#line 1164
  bufferlen = (int )(sizeof(psf->u.ibuf) / sizeof(psf->u.ibuf[0]));
  {
#line 1166
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1166
    if (! (len > 0L)) {
#line 1166
      goto while_break;
    }
#line 1167
    if (len < (long )bufferlen) {
#line 1168
      bufferlen = (int )len;
    }
    {
#line 1169
    __cil_tmp9 = psf_fread((int *)psf->u.ibuf, (sf_count_t )sizeof(int ), (sf_count_t )bufferlen,
                           psf);
#line 1169
    readcount = (int )__cil_tmp9;
#line 1170
    bei2f_array((int *)psf->u.ibuf, readcount, ptr + total, normfact);
#line 1171
    total += (long )readcount;
    }
#line 1172
    if (readcount < bufferlen) {
#line 1173
      goto while_break;
    }
#line 1174
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 1177
  return (total);
}
}
#line 1181 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_read_lei2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  sf_count_t __cil_tmp9 ;

  {
#line 1183
  total = (sf_count_t )0;
#line 1186
  if (psf->norm_float == 1) {
#line 1186
    tmp = 1. / (double )((float )2147483648U);
  } else {
#line 1186
    tmp = 1.;
  }
#line 1186
  normfact = (float )tmp;
#line 1188
  bufferlen = (int )(sizeof(psf->u.ibuf) / sizeof(psf->u.ibuf[0]));
  {
#line 1190
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1190
    if (! (len > 0L)) {
#line 1190
      goto while_break;
    }
#line 1191
    if (len < (long )bufferlen) {
#line 1192
      bufferlen = (int )len;
    }
    {
#line 1193
    __cil_tmp9 = psf_fread((int *)psf->u.ibuf, (sf_count_t )sizeof(int ), (sf_count_t )bufferlen,
                           psf);
#line 1193
    readcount = (int )__cil_tmp9;
#line 1194
    lei2f_array((int *)psf->u.ibuf, readcount, ptr + total, normfact);
#line 1195
    total += (long )readcount;
    }
#line 1196
    if (readcount < bufferlen) {
#line 1197
      goto while_break;
    }
#line 1198
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 1201
  return (total);
}
}
#line 1208 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_read_sc2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  sf_count_t __cil_tmp9 ;

  {
#line 1210
  total = (sf_count_t )0;
#line 1213
  if (psf->norm_double == 1) {
#line 1213
    tmp = 1. / (double )128;
  } else {
#line 1213
    tmp = 1.;
  }
#line 1213
  normfact = tmp;
#line 1215
  bufferlen = (int )(sizeof(psf->u.scbuf) / sizeof(psf->u.scbuf[0]));
  {
#line 1217
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1217
    if (! (len > 0L)) {
#line 1217
      goto while_break;
    }
#line 1218
    if (len < (long )bufferlen) {
#line 1219
      bufferlen = (int )len;
    }
    {
#line 1220
    __cil_tmp9 = psf_fread((signed char *)psf->u.scbuf, (sf_count_t )sizeof(signed char ),
                           (sf_count_t )bufferlen, psf);
#line 1220
    readcount = (int )__cil_tmp9;
#line 1221
    sc2d_array((signed char *)psf->u.scbuf, readcount, ptr + total, normfact);
#line 1222
    total += (long )readcount;
    }
#line 1223
    if (readcount < bufferlen) {
#line 1224
      goto while_break;
    }
#line 1225
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 1228
  return (total);
}
}
#line 1232 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_read_uc2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  sf_count_t __cil_tmp9 ;

  {
#line 1234
  total = (sf_count_t )0;
#line 1237
  if (psf->norm_double == 1) {
#line 1237
    tmp = 1. / (double )128;
  } else {
#line 1237
    tmp = 1.;
  }
#line 1237
  normfact = tmp;
#line 1239
  bufferlen = (int )(sizeof(psf->u.ucbuf) / sizeof(psf->u.ucbuf[0]));
  {
#line 1241
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1241
    if (! (len > 0L)) {
#line 1241
      goto while_break;
    }
#line 1242
    if (len < (long )bufferlen) {
#line 1243
      bufferlen = (int )len;
    }
    {
#line 1244
    __cil_tmp9 = psf_fread((unsigned char *)psf->u.ucbuf, (sf_count_t )sizeof(unsigned char ),
                           (sf_count_t )bufferlen, psf);
#line 1244
    readcount = (int )__cil_tmp9;
#line 1245
    uc2d_array((unsigned char *)psf->u.ucbuf, readcount, ptr + total, normfact);
#line 1246
    total += (long )readcount;
    }
#line 1247
    if (readcount < bufferlen) {
#line 1248
      goto while_break;
    }
#line 1249
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 1252
  return (total);
}
}
#line 1256 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_read_bes2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  sf_count_t __cil_tmp9 ;

  {
#line 1258
  total = (sf_count_t )0;
#line 1261
  if (psf->norm_double == 1) {
#line 1261
    tmp = 1. / (double )32768;
  } else {
#line 1261
    tmp = 1.;
  }
#line 1261
  normfact = tmp;
#line 1263
  bufferlen = (int )(sizeof(psf->u.sbuf) / sizeof(psf->u.sbuf[0]));
  {
#line 1265
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1265
    if (! (len > 0L)) {
#line 1265
      goto while_break;
    }
#line 1266
    if (len < (long )bufferlen) {
#line 1267
      bufferlen = (int )len;
    }
    {
#line 1268
    __cil_tmp9 = psf_fread((short *)psf->u.sbuf, (sf_count_t )sizeof(short ), (sf_count_t )bufferlen,
                           psf);
#line 1268
    readcount = (int )__cil_tmp9;
#line 1269
    bes2d_array((short *)psf->u.sbuf, readcount, ptr + total, normfact);
#line 1270
    total += (long )readcount;
    }
#line 1271
    if (readcount < bufferlen) {
#line 1272
      goto while_break;
    }
#line 1273
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 1276
  return (total);
}
}
#line 1280 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_read_les2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  sf_count_t __cil_tmp9 ;

  {
#line 1282
  total = (sf_count_t )0;
#line 1285
  if (psf->norm_double == 1) {
#line 1285
    tmp = 1. / (double )32768;
  } else {
#line 1285
    tmp = 1.;
  }
#line 1285
  normfact = tmp;
#line 1287
  bufferlen = (int )(sizeof(psf->u.sbuf) / sizeof(psf->u.sbuf[0]));
  {
#line 1289
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1289
    if (! (len > 0L)) {
#line 1289
      goto while_break;
    }
#line 1290
    if (len < (long )bufferlen) {
#line 1291
      bufferlen = (int )len;
    }
    {
#line 1292
    __cil_tmp9 = psf_fread((short *)psf->u.sbuf, (sf_count_t )sizeof(short ), (sf_count_t )bufferlen,
                           psf);
#line 1292
    readcount = (int )__cil_tmp9;
#line 1293
    les2d_array((short *)psf->u.sbuf, readcount, ptr + total, normfact);
#line 1294
    total += (long )readcount;
    }
#line 1295
    if (readcount < bufferlen) {
#line 1296
      goto while_break;
    }
#line 1297
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 1300
  return (total);
}
}
#line 1304 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_read_bet2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  sf_count_t __cil_tmp9 ;

  {
#line 1306
  total = (sf_count_t )0;
#line 1309
  if (psf->norm_double == 1) {
#line 1309
    tmp = 1. / (double )2147483648U;
  } else {
#line 1309
    tmp = 1. / 256.;
  }
#line 1309
  normfact = tmp;
#line 1311
  bufferlen = (int )(sizeof(psf->u.ucbuf) / 3UL);
  {
#line 1313
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1313
    if (! (len > 0L)) {
#line 1313
      goto while_break;
    }
#line 1314
    if (len < (long )bufferlen) {
#line 1315
      bufferlen = (int )len;
    }
    {
#line 1316
    __cil_tmp9 = psf_fread((unsigned char *)psf->u.ucbuf, (sf_count_t )3, (sf_count_t )bufferlen,
                           psf);
#line 1316
    readcount = (int )__cil_tmp9;
#line 1317
    bet2d_array((tribyte *)((unsigned char *)psf->u.ucbuf), readcount, ptr + total,
                normfact);
#line 1318
    total += (long )readcount;
    }
#line 1319
    if (readcount < bufferlen) {
#line 1320
      goto while_break;
    }
#line 1321
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 1324
  return (total);
}
}
#line 1328 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_read_let2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  sf_count_t __cil_tmp9 ;

  {
#line 1330
  total = (sf_count_t )0;
#line 1334
  if (psf->norm_double == 1) {
#line 1334
    tmp = 1. / (double )2147483648U;
  } else {
#line 1334
    tmp = 1. / 256.;
  }
#line 1334
  normfact = tmp;
#line 1336
  bufferlen = (int )(sizeof(psf->u.ucbuf) / 3UL);
  {
#line 1338
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1338
    if (! (len > 0L)) {
#line 1338
      goto while_break;
    }
#line 1339
    if (len < (long )bufferlen) {
#line 1340
      bufferlen = (int )len;
    }
    {
#line 1341
    __cil_tmp9 = psf_fread((unsigned char *)psf->u.ucbuf, (sf_count_t )3, (sf_count_t )bufferlen,
                           psf);
#line 1341
    readcount = (int )__cil_tmp9;
#line 1342
    let2d_array((tribyte *)((unsigned char *)psf->u.ucbuf), readcount, ptr + total,
                normfact);
#line 1343
    total += (long )readcount;
    }
#line 1344
    if (readcount < bufferlen) {
#line 1345
      goto while_break;
    }
#line 1346
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 1349
  return (total);
}
}
#line 1353 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_read_bei2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  sf_count_t __cil_tmp9 ;

  {
#line 1355
  total = (sf_count_t )0;
#line 1358
  if (psf->norm_double == 1) {
#line 1358
    tmp = 1. / (double )2147483648U;
  } else {
#line 1358
    tmp = 1.;
  }
#line 1358
  normfact = tmp;
#line 1360
  bufferlen = (int )(sizeof(psf->u.ibuf) / sizeof(psf->u.ibuf[0]));
  {
#line 1362
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1362
    if (! (len > 0L)) {
#line 1362
      goto while_break;
    }
#line 1363
    if (len < (long )bufferlen) {
#line 1364
      bufferlen = (int )len;
    }
    {
#line 1365
    __cil_tmp9 = psf_fread((int *)psf->u.ibuf, (sf_count_t )sizeof(int ), (sf_count_t )bufferlen,
                           psf);
#line 1365
    readcount = (int )__cil_tmp9;
#line 1366
    bei2d_array((int *)psf->u.ibuf, readcount, ptr + total, normfact);
#line 1367
    total += (long )readcount;
    }
#line 1368
    if (readcount < bufferlen) {
#line 1369
      goto while_break;
    }
#line 1370
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 1373
  return (total);
}
}
#line 1377 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_read_lei2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  sf_count_t __cil_tmp9 ;

  {
#line 1379
  total = (sf_count_t )0;
#line 1382
  if (psf->norm_double == 1) {
#line 1382
    tmp = 1. / (double )2147483648U;
  } else {
#line 1382
    tmp = 1.;
  }
#line 1382
  normfact = tmp;
#line 1384
  bufferlen = (int )(sizeof(psf->u.ibuf) / sizeof(psf->u.ibuf[0]));
  {
#line 1386
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1386
    if (! (len > 0L)) {
#line 1386
      goto while_break;
    }
#line 1387
    if (len < (long )bufferlen) {
#line 1388
      bufferlen = (int )len;
    }
    {
#line 1389
    __cil_tmp9 = psf_fread((int *)psf->u.ibuf, (sf_count_t )sizeof(int ), (sf_count_t )bufferlen,
                           psf);
#line 1389
    readcount = (int )__cil_tmp9;
#line 1390
    lei2d_array((int *)psf->u.ibuf, readcount, ptr + total, normfact);
#line 1391
    total += (long )readcount;
    }
#line 1392
    if (readcount < bufferlen) {
#line 1393
      goto while_break;
    }
#line 1394
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 1397
  return (total);
}
}
#line 1406 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_write_s2sc(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp7 ;

  {
#line 1408
  total = (sf_count_t )0;
#line 1410
  bufferlen = (int )(sizeof(psf->u.scbuf) / sizeof(psf->u.scbuf[0]));
  {
#line 1412
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1412
    if (! (len > 0L)) {
#line 1412
      goto while_break;
    }
#line 1413
    if (len < (long )bufferlen) {
#line 1414
      bufferlen = (int )len;
    }
    {
#line 1415
    s2sc_array(ptr + total, (signed char *)psf->u.scbuf, bufferlen);
#line 1416
    __cil_tmp7 = psf_fwrite((signed char *)psf->u.scbuf, (sf_count_t )sizeof(signed char ),
                            (sf_count_t )bufferlen, psf);
#line 1416
    writecount = (int )__cil_tmp7;
#line 1417
    total += (long )writecount;
    }
#line 1418
    if (writecount < bufferlen) {
#line 1419
      goto while_break;
    }
#line 1420
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 1423
  return (total);
}
}
#line 1427 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_write_s2uc(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp7 ;

  {
#line 1429
  total = (sf_count_t )0;
#line 1431
  bufferlen = (int )(sizeof(psf->u.ucbuf) / sizeof(psf->u.ucbuf[0]));
  {
#line 1433
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1433
    if (! (len > 0L)) {
#line 1433
      goto while_break;
    }
#line 1434
    if (len < (long )bufferlen) {
#line 1435
      bufferlen = (int )len;
    }
    {
#line 1436
    s2uc_array(ptr + total, (unsigned char *)psf->u.ucbuf, bufferlen);
#line 1437
    __cil_tmp7 = psf_fwrite((unsigned char *)psf->u.ucbuf, (sf_count_t )sizeof(unsigned char ),
                            (sf_count_t )bufferlen, psf);
#line 1437
    writecount = (int )__cil_tmp7;
#line 1438
    total += (long )writecount;
    }
#line 1439
    if (writecount < bufferlen) {
#line 1440
      goto while_break;
    }
#line 1441
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 1444
  return (total);
}
}
#line 1448 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_write_s2bes(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp7 ;
  sf_count_t __cil_tmp8 ;

  {
#line 1450
  total = (sf_count_t )0;
#line 1452
  if (0) {
    {
#line 1453
    __cil_tmp7 = psf_fwrite(ptr, (sf_count_t )sizeof(short ), len, psf);
    }
#line 1453
    return (__cil_tmp7);
  } else {
#line 1456
    bufferlen = (int )(sizeof(psf->u.sbuf) / sizeof(psf->u.sbuf[0]));
  }
  {
#line 1458
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1458
    if (! (len > 0L)) {
#line 1458
      goto while_break;
    }
#line 1459
    if (len < (long )bufferlen) {
#line 1460
      bufferlen = (int )len;
    }
    {
#line 1461
    endswap_short_copy((short *)psf->u.sbuf, ptr + total, bufferlen);
#line 1462
    __cil_tmp8 = psf_fwrite((short *)psf->u.sbuf, (sf_count_t )sizeof(short ), (sf_count_t )bufferlen,
                            psf);
#line 1462
    writecount = (int )__cil_tmp8;
#line 1463
    total += (long )writecount;
    }
#line 1464
    if (writecount < bufferlen) {
#line 1465
      goto while_break;
    }
#line 1466
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 1469
  return (total);
}
}
#line 1473 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_write_s2les(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp7 ;
  sf_count_t __cil_tmp8 ;

  {
#line 1475
  total = (sf_count_t )0;
#line 1477
  if (1) {
    {
#line 1478
    __cil_tmp7 = psf_fwrite(ptr, (sf_count_t )sizeof(short ), len, psf);
    }
#line 1478
    return (__cil_tmp7);
  }
#line 1480
  bufferlen = (int )(sizeof(psf->u.sbuf) / sizeof(psf->u.sbuf[0]));
  {
#line 1482
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1482
    if (! (len > 0L)) {
#line 1482
      goto while_break;
    }
#line 1483
    if (len < (long )bufferlen) {
#line 1484
      bufferlen = (int )len;
    }
    {
#line 1485
    endswap_short_copy((short *)psf->u.sbuf, ptr + total, bufferlen);
#line 1486
    __cil_tmp8 = psf_fwrite((short *)psf->u.sbuf, (sf_count_t )sizeof(short ), (sf_count_t )bufferlen,
                            psf);
#line 1486
    writecount = (int )__cil_tmp8;
#line 1487
    total += (long )writecount;
    }
#line 1488
    if (writecount < bufferlen) {
#line 1489
      goto while_break;
    }
#line 1490
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 1493
  return (total);
}
}
#line 1497 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_write_s2bet(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp7 ;

  {
#line 1499
  total = (sf_count_t )0;
#line 1501
  bufferlen = (int )(sizeof(psf->u.ucbuf) / 3UL);
  {
#line 1503
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1503
    if (! (len > 0L)) {
#line 1503
      goto while_break;
    }
#line 1504
    if (len < (long )bufferlen) {
#line 1505
      bufferlen = (int )len;
    }
    {
#line 1506
    s2bet_array(ptr + total, (tribyte *)((unsigned char *)psf->u.ucbuf), bufferlen);
#line 1507
    __cil_tmp7 = psf_fwrite((unsigned char *)psf->u.ucbuf, (sf_count_t )3, (sf_count_t )bufferlen,
                            psf);
#line 1507
    writecount = (int )__cil_tmp7;
#line 1508
    total += (long )writecount;
    }
#line 1509
    if (writecount < bufferlen) {
#line 1510
      goto while_break;
    }
#line 1511
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 1514
  return (total);
}
}
#line 1518 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_write_s2let(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp7 ;

  {
#line 1520
  total = (sf_count_t )0;
#line 1522
  bufferlen = (int )(sizeof(psf->u.ucbuf) / 3UL);
  {
#line 1524
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1524
    if (! (len > 0L)) {
#line 1524
      goto while_break;
    }
#line 1525
    if (len < (long )bufferlen) {
#line 1526
      bufferlen = (int )len;
    }
    {
#line 1527
    s2let_array(ptr + total, (tribyte *)((unsigned char *)psf->u.ucbuf), bufferlen);
#line 1528
    __cil_tmp7 = psf_fwrite((unsigned char *)psf->u.ucbuf, (sf_count_t )3, (sf_count_t )bufferlen,
                            psf);
#line 1528
    writecount = (int )__cil_tmp7;
#line 1529
    total += (long )writecount;
    }
#line 1530
    if (writecount < bufferlen) {
#line 1531
      goto while_break;
    }
#line 1532
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 1535
  return (total);
}
}
#line 1539 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_write_s2bei(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp7 ;

  {
#line 1541
  total = (sf_count_t )0;
#line 1543
  bufferlen = (int )(sizeof(psf->u.ibuf) / sizeof(psf->u.ibuf[0]));
  {
#line 1545
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1545
    if (! (len > 0L)) {
#line 1545
      goto while_break;
    }
#line 1546
    if (len < (long )bufferlen) {
#line 1547
      bufferlen = (int )len;
    }
    {
#line 1548
    s2bei_array(ptr + total, (int *)psf->u.ibuf, bufferlen);
#line 1549
    __cil_tmp7 = psf_fwrite((int *)psf->u.ibuf, (sf_count_t )sizeof(int ), (sf_count_t )bufferlen,
                            psf);
#line 1549
    writecount = (int )__cil_tmp7;
#line 1550
    total += (long )writecount;
    }
#line 1551
    if (writecount < bufferlen) {
#line 1552
      goto while_break;
    }
#line 1553
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 1556
  return (total);
}
}
#line 1560 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_write_s2lei(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp7 ;

  {
#line 1562
  total = (sf_count_t )0;
#line 1564
  bufferlen = (int )(sizeof(psf->u.ibuf) / sizeof(psf->u.ibuf[0]));
  {
#line 1566
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1566
    if (! (len > 0L)) {
#line 1566
      goto while_break;
    }
#line 1567
    if (len < (long )bufferlen) {
#line 1568
      bufferlen = (int )len;
    }
    {
#line 1569
    s2lei_array(ptr + total, (int *)psf->u.ibuf, bufferlen);
#line 1570
    __cil_tmp7 = psf_fwrite((int *)psf->u.ibuf, (sf_count_t )sizeof(int ), (sf_count_t )bufferlen,
                            psf);
#line 1570
    writecount = (int )__cil_tmp7;
#line 1571
    total += (long )writecount;
    }
#line 1572
    if (writecount < bufferlen) {
#line 1573
      goto while_break;
    }
#line 1574
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 1577
  return (total);
}
}
#line 1584 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_write_i2sc(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp7 ;

  {
#line 1586
  total = (sf_count_t )0;
#line 1588
  bufferlen = (int )(sizeof(psf->u.scbuf) / sizeof(psf->u.scbuf[0]));
  {
#line 1590
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1590
    if (! (len > 0L)) {
#line 1590
      goto while_break;
    }
#line 1591
    if (len < (long )bufferlen) {
#line 1592
      bufferlen = (int )len;
    }
    {
#line 1593
    i2sc_array(ptr + total, (signed char *)psf->u.scbuf, bufferlen);
#line 1594
    __cil_tmp7 = psf_fwrite((signed char *)psf->u.scbuf, (sf_count_t )sizeof(signed char ),
                            (sf_count_t )bufferlen, psf);
#line 1594
    writecount = (int )__cil_tmp7;
#line 1595
    total += (long )writecount;
    }
#line 1596
    if (writecount < bufferlen) {
#line 1597
      goto while_break;
    }
#line 1598
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 1601
  return (total);
}
}
#line 1605 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_write_i2uc(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp7 ;

  {
#line 1607
  total = (sf_count_t )0;
#line 1609
  bufferlen = (int )(sizeof(psf->u.ucbuf) / sizeof(psf->u.ucbuf[0]));
  {
#line 1611
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1611
    if (! (len > 0L)) {
#line 1611
      goto while_break;
    }
#line 1612
    if (len < (long )bufferlen) {
#line 1613
      bufferlen = (int )len;
    }
    {
#line 1614
    i2uc_array(ptr + total, (unsigned char *)psf->u.ucbuf, bufferlen);
#line 1615
    __cil_tmp7 = psf_fwrite((unsigned char *)psf->u.ucbuf, (sf_count_t )sizeof(signed char ),
                            (sf_count_t )bufferlen, psf);
#line 1615
    writecount = (int )__cil_tmp7;
#line 1616
    total += (long )writecount;
    }
#line 1617
    if (writecount < bufferlen) {
#line 1618
      goto while_break;
    }
#line 1619
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 1622
  return (total);
}
}
#line 1626 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_write_i2bes(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp7 ;

  {
#line 1628
  total = (sf_count_t )0;
#line 1630
  bufferlen = (int )(sizeof(psf->u.sbuf) / sizeof(psf->u.sbuf[0]));
  {
#line 1632
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1632
    if (! (len > 0L)) {
#line 1632
      goto while_break;
    }
#line 1633
    if (len < (long )bufferlen) {
#line 1634
      bufferlen = (int )len;
    }
    {
#line 1635
    i2bes_array(ptr + total, (short *)psf->u.sbuf, bufferlen);
#line 1636
    __cil_tmp7 = psf_fwrite((short *)psf->u.sbuf, (sf_count_t )sizeof(short ), (sf_count_t )bufferlen,
                            psf);
#line 1636
    writecount = (int )__cil_tmp7;
#line 1637
    total += (long )writecount;
    }
#line 1638
    if (writecount < bufferlen) {
#line 1639
      goto while_break;
    }
#line 1640
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 1643
  return (total);
}
}
#line 1647 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_write_i2les(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp7 ;

  {
#line 1649
  total = (sf_count_t )0;
#line 1651
  bufferlen = (int )(sizeof(psf->u.sbuf) / sizeof(psf->u.sbuf[0]));
  {
#line 1653
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1653
    if (! (len > 0L)) {
#line 1653
      goto while_break;
    }
#line 1654
    if (len < (long )bufferlen) {
#line 1655
      bufferlen = (int )len;
    }
    {
#line 1656
    i2les_array(ptr + total, (short *)psf->u.sbuf, bufferlen);
#line 1657
    __cil_tmp7 = psf_fwrite((short *)psf->u.sbuf, (sf_count_t )sizeof(short ), (sf_count_t )bufferlen,
                            psf);
#line 1657
    writecount = (int )__cil_tmp7;
#line 1658
    total += (long )writecount;
    }
#line 1659
    if (writecount < bufferlen) {
#line 1660
      goto while_break;
    }
#line 1661
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 1664
  return (total);
}
}
#line 1668 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_write_i2bet(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp7 ;

  {
#line 1670
  total = (sf_count_t )0;
#line 1672
  bufferlen = (int )(sizeof(psf->u.ucbuf) / 3UL);
  {
#line 1674
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1674
    if (! (len > 0L)) {
#line 1674
      goto while_break;
    }
#line 1675
    if (len < (long )bufferlen) {
#line 1676
      bufferlen = (int )len;
    }
    {
#line 1677
    i2bet_array(ptr + total, (tribyte *)((unsigned char *)psf->u.ucbuf), bufferlen);
#line 1678
    __cil_tmp7 = psf_fwrite((unsigned char *)psf->u.ucbuf, (sf_count_t )3, (sf_count_t )bufferlen,
                            psf);
#line 1678
    writecount = (int )__cil_tmp7;
#line 1679
    total += (long )writecount;
    }
#line 1680
    if (writecount < bufferlen) {
#line 1681
      goto while_break;
    }
#line 1682
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 1685
  return (total);
}
}
#line 1689 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_write_i2let(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp7 ;

  {
#line 1691
  total = (sf_count_t )0;
#line 1693
  bufferlen = (int )(sizeof(psf->u.ucbuf) / 3UL);
  {
#line 1695
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1695
    if (! (len > 0L)) {
#line 1695
      goto while_break;
    }
#line 1696
    if (len < (long )bufferlen) {
#line 1697
      bufferlen = (int )len;
    }
    {
#line 1698
    i2let_array(ptr + total, (tribyte *)((unsigned char *)psf->u.ucbuf), bufferlen);
#line 1699
    __cil_tmp7 = psf_fwrite((unsigned char *)psf->u.ucbuf, (sf_count_t )3, (sf_count_t )bufferlen,
                            psf);
#line 1699
    writecount = (int )__cil_tmp7;
#line 1700
    total += (long )writecount;
    }
#line 1701
    if (writecount < bufferlen) {
#line 1702
      goto while_break;
    }
#line 1703
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 1706
  return (total);
}
}
#line 1710 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_write_i2bei(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp7 ;
  sf_count_t __cil_tmp8 ;

  {
#line 1712
  total = (sf_count_t )0;
#line 1714
  if (0) {
    {
#line 1715
    __cil_tmp7 = psf_fwrite(ptr, (sf_count_t )sizeof(int ), len, psf);
    }
#line 1715
    return (__cil_tmp7);
  }
#line 1717
  bufferlen = (int )(sizeof(psf->u.ibuf) / sizeof(psf->u.ibuf[0]));
  {
#line 1719
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1719
    if (! (len > 0L)) {
#line 1719
      goto while_break;
    }
#line 1720
    if (len < (long )bufferlen) {
#line 1721
      bufferlen = (int )len;
    }
    {
#line 1722
    endswap_int_copy((int *)psf->u.ibuf, ptr + total, bufferlen);
#line 1723
    __cil_tmp8 = psf_fwrite((int *)psf->u.ibuf, (sf_count_t )sizeof(int ), (sf_count_t )bufferlen,
                            psf);
#line 1723
    writecount = (int )__cil_tmp8;
#line 1724
    total += (long )writecount;
    }
#line 1725
    if (writecount < bufferlen) {
#line 1726
      goto while_break;
    }
#line 1727
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 1730
  return (total);
}
}
#line 1734 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_write_i2lei(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp7 ;
  sf_count_t __cil_tmp8 ;

  {
#line 1736
  total = (sf_count_t )0;
#line 1738
  if (1) {
    {
#line 1739
    __cil_tmp7 = psf_fwrite(ptr, (sf_count_t )sizeof(int ), len, psf);
    }
#line 1739
    return (__cil_tmp7);
  }
#line 1741
  bufferlen = (int )(sizeof(psf->u.ibuf) / sizeof(psf->u.ibuf[0]));
  {
#line 1743
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1743
    if (! (len > 0L)) {
#line 1743
      goto while_break;
    }
#line 1744
    if (len < (long )bufferlen) {
#line 1745
      bufferlen = (int )len;
    }
    {
#line 1746
    endswap_int_copy((int *)psf->u.ibuf, ptr + total, bufferlen);
#line 1747
    __cil_tmp8 = psf_fwrite((int *)psf->u.ibuf, (sf_count_t )sizeof(int ), (sf_count_t )bufferlen,
                            psf);
#line 1747
    writecount = (int )__cil_tmp8;
#line 1748
    total += (long )writecount;
    }
#line 1749
    if (writecount < bufferlen) {
#line 1750
      goto while_break;
    }
#line 1751
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 1754
  return (total);
}
}
#line 1763 "/root/libsndfile/src/pcm.c"
static void f2sc_array(float const   *src , signed char *dest , int count , int normalize ) 
{ 
  float normfact ;
  double tmp ;
  long __cil_tmp7 ;

  {
#line 1766
  if (normalize) {
#line 1766
    tmp = 1. * (double )127;
  } else {
#line 1766
    tmp = 1.;
  }
#line 1766
  normfact = (float )tmp;
  {
#line 1768
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1768
    count --;
#line 1768
    if (! (count >= 0)) {
#line 1768
      goto while_break;
    }
    {
#line 1769
    __cil_tmp7 = lrintf(*(src + count) * normfact);
#line 1769
    *(dest + count) = (signed char )__cil_tmp7;
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 1774 "/root/libsndfile/src/pcm.c"
static void f2sc_clip_array(float const   *src , signed char *dest , int count , int normalize ) 
{ 
  float normfact ;
  float scaled_value ;
  double tmp ;
  long __cil_tmp8 ;

  {
#line 1777
  if (normalize) {
#line 1777
    tmp = 8. * (double )268435456;
  } else {
#line 1777
    tmp = 1. * (double )16777216;
  }
#line 1777
  normfact = (float )tmp;
  {
#line 1779
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1779
    count --;
#line 1779
    if (! (count >= 0)) {
#line 1779
      goto while_break;
    }
#line 1780
    scaled_value = *(src + count) * normfact;
#line 1781
    if ((double )scaled_value >= 1. * (double )2147483647) {
#line 1782
      *(dest + count) = (signed char )127;
#line 1783
      goto while_continue;
    }

#line 1785
    if ((double )scaled_value <= - 8. * (double )268435456) {
#line 1786
      *(dest + count) = (signed char )(- 128);
#line 1787
      goto while_continue;
    }
    {
#line 1790
    __cil_tmp8 = lrintf(scaled_value);
#line 1790
    *(dest + count) = (signed char )(__cil_tmp8 >> 24);
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 1795 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_write_f2sc(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  void (*convert)(float const   * , signed char * , int  , int  ) ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  void (*tmp)(float const   *src , signed char *dest , int count , int normalize ) ;
  sf_count_t __cil_tmp9 ;

  {
#line 1798
  total = (sf_count_t )0;
#line 1800
  if (psf->add_clipping) {
#line 1800
    tmp = & f2sc_clip_array;
  } else {
#line 1800
    tmp = & f2sc_array;
  }
#line 1800
  convert = tmp;
#line 1801
  bufferlen = (int )(sizeof(psf->u.scbuf) / sizeof(psf->u.scbuf[0]));
  {
#line 1803
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1803
    if (! (len > 0L)) {
#line 1803
      goto while_break;
    }
#line 1804
    if (len < (long )bufferlen) {
#line 1805
      bufferlen = (int )len;
    }
    {
#line 1806
    (*convert)(ptr + total, (signed char *)psf->u.scbuf, bufferlen, psf->norm_float);
#line 1807
    __cil_tmp9 = psf_fwrite((signed char *)psf->u.scbuf, (sf_count_t )sizeof(signed char ),
                            (sf_count_t )bufferlen, psf);
#line 1807
    writecount = (int )__cil_tmp9;
#line 1808
    total += (long )writecount;
    }
#line 1809
    if (writecount < bufferlen) {
#line 1810
      goto while_break;
    }
#line 1811
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 1814
  return (total);
}
}
#line 1821 "/root/libsndfile/src/pcm.c"
static void f2uc_array(float const   *src , unsigned char *dest , int count , int normalize ) 
{ 
  float normfact ;
  double tmp ;
  long __cil_tmp7 ;

  {
#line 1824
  if (normalize) {
#line 1824
    tmp = 1. * (double )127;
  } else {
#line 1824
    tmp = 1.;
  }
#line 1824
  normfact = (float )tmp;
  {
#line 1826
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1826
    count --;
#line 1826
    if (! (count >= 0)) {
#line 1826
      goto while_break;
    }
    {
#line 1827
    __cil_tmp7 = lrintf(*(src + count) * normfact);
#line 1827
    *(dest + count) = (unsigned char )(__cil_tmp7 + 128L);
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 1832 "/root/libsndfile/src/pcm.c"
static void f2uc_clip_array(float const   *src , unsigned char *dest , int count ,
                            int normalize ) 
{ 
  float normfact ;
  float scaled_value ;
  double tmp ;
  long __cil_tmp8 ;

  {
#line 1835
  if (normalize) {
#line 1835
    tmp = 8. * (double )268435456;
  } else {
#line 1835
    tmp = 1. * (double )16777216;
  }
#line 1835
  normfact = (float )tmp;
  {
#line 1837
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1837
    count --;
#line 1837
    if (! (count >= 0)) {
#line 1837
      goto while_break;
    }
#line 1838
    scaled_value = *(src + count) * normfact;
#line 1839
    if ((double )scaled_value >= 1. * (double )2147483647) {
#line 1840
      *(dest + count) = (unsigned char )255;
#line 1841
      goto while_continue;
    }

#line 1843
    if ((double )scaled_value <= - 8. * (double )268435456) {
#line 1844
      *(dest + count) = (unsigned char )0;
#line 1845
      goto while_continue;
    }
    {
#line 1848
    __cil_tmp8 = lrintf(scaled_value);
#line 1848
    *(dest + count) = (unsigned char )((__cil_tmp8 >> 24) + 128L);
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 1853 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_write_f2uc(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  void (*convert)(float const   * , unsigned char * , int  , int  ) ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  void (*tmp)(float const   *src , unsigned char *dest , int count , int normalize ) ;
  sf_count_t __cil_tmp9 ;

  {
#line 1856
  total = (sf_count_t )0;
#line 1858
  if (psf->add_clipping) {
#line 1858
    tmp = & f2uc_clip_array;
  } else {
#line 1858
    tmp = & f2uc_array;
  }
#line 1858
  convert = tmp;
#line 1859
  bufferlen = (int )(sizeof(psf->u.ucbuf) / sizeof(psf->u.ucbuf[0]));
  {
#line 1861
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1861
    if (! (len > 0L)) {
#line 1861
      goto while_break;
    }
#line 1862
    if (len < (long )bufferlen) {
#line 1863
      bufferlen = (int )len;
    }
    {
#line 1864
    (*convert)(ptr + total, (unsigned char *)psf->u.ucbuf, bufferlen, psf->norm_float);
#line 1865
    __cil_tmp9 = psf_fwrite((unsigned char *)psf->u.ucbuf, (sf_count_t )sizeof(unsigned char ),
                            (sf_count_t )bufferlen, psf);
#line 1865
    writecount = (int )__cil_tmp9;
#line 1866
    total += (long )writecount;
    }
#line 1867
    if (writecount < bufferlen) {
#line 1868
      goto while_break;
    }
#line 1869
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 1872
  return (total);
}
}
#line 1879 "/root/libsndfile/src/pcm.c"
static void f2bes_array(float const   *src , short *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  float normfact ;
  short value ;
  double tmp ;
  long __cil_tmp9 ;

  {
#line 1884
  if (normalize) {
#line 1884
    tmp = 1. * (double )32767;
  } else {
#line 1884
    tmp = 1.;
  }
#line 1884
  normfact = (float )tmp;
#line 1885
  ucptr = (unsigned char *)dest + 2 * count;
  {
#line 1887
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1887
    count --;
#line 1887
    if (! (count >= 0)) {
#line 1887
      goto while_break;
    }
    {
#line 1888
    ucptr -= 2;
#line 1889
    __cil_tmp9 = lrintf(*(src + count) * normfact);
#line 1889
    value = (short )__cil_tmp9;
#line 1890
    *(ucptr + 1) = (unsigned char )value;
#line 1891
    *(ucptr + 0) = (unsigned char )((int )value >> 8);
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 1896 "/root/libsndfile/src/pcm.c"
static void f2bes_clip_array(float const   *src , short *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  float normfact ;
  float scaled_value ;
  int value ;
  double tmp ;
  long __cil_tmp10 ;

  {
#line 1901
  if (normalize) {
#line 1901
    tmp = 8. * (double )268435456;
  } else {
#line 1901
    tmp = 1. * (double )65536;
  }
#line 1901
  normfact = (float )tmp;
#line 1902
  ucptr = (unsigned char *)dest + 2 * count;
  {
#line 1904
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1904
    count --;
#line 1904
    if (! (count >= 0)) {
#line 1904
      goto while_break;
    }
#line 1905
    ucptr -= 2;
#line 1906
    scaled_value = *(src + count) * normfact;
#line 1907
    if ((double )scaled_value >= 1. * (double )2147483647) {
#line 1908
      *(ucptr + 1) = (unsigned char )255;
#line 1909
      *(ucptr + 0) = (unsigned char )127;
#line 1910
      goto while_continue;
    }

#line 1912
    if ((double )scaled_value <= - 8. * (double )268435456) {
#line 1913
      *(ucptr + 1) = (unsigned char )0;
#line 1914
      *(ucptr + 0) = (unsigned char )128;
#line 1915
      goto while_continue;
    }
    {
#line 1918
    __cil_tmp10 = lrintf(scaled_value);
#line 1918
    value = (int )__cil_tmp10;
#line 1919
    *(ucptr + 1) = (unsigned char )(value >> 16);
#line 1920
    *(ucptr + 0) = (unsigned char )(value >> 24);
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 1925 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_write_f2bes(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  void (*convert)(float const   * , short * , int  , int  ) ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  void (*tmp)(float const   *src , short *dest , int count , int normalize ) ;
  sf_count_t __cil_tmp9 ;

  {
#line 1928
  total = (sf_count_t )0;
#line 1930
  if (psf->add_clipping) {
#line 1930
    tmp = & f2bes_clip_array;
  } else {
#line 1930
    tmp = & f2bes_array;
  }
#line 1930
  convert = tmp;
#line 1931
  bufferlen = (int )(sizeof(psf->u.sbuf) / sizeof(psf->u.sbuf[0]));
  {
#line 1933
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1933
    if (! (len > 0L)) {
#line 1933
      goto while_break;
    }
#line 1934
    if (len < (long )bufferlen) {
#line 1935
      bufferlen = (int )len;
    }
    {
#line 1936
    (*convert)(ptr + total, (short *)psf->u.sbuf, bufferlen, psf->norm_float);
#line 1937
    __cil_tmp9 = psf_fwrite((short *)psf->u.sbuf, (sf_count_t )sizeof(short ), (sf_count_t )bufferlen,
                            psf);
#line 1937
    writecount = (int )__cil_tmp9;
#line 1938
    total += (long )writecount;
    }
#line 1939
    if (writecount < bufferlen) {
#line 1940
      goto while_break;
    }
#line 1941
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 1944
  return (total);
}
}
#line 1951 "/root/libsndfile/src/pcm.c"
static void f2les_array(float const   *src , short *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  float normfact ;
  int value ;
  double tmp ;
  long __cil_tmp9 ;

  {
#line 1956
  if (normalize) {
#line 1956
    tmp = 1. * (double )32767;
  } else {
#line 1956
    tmp = 1.;
  }
#line 1956
  normfact = (float )tmp;
#line 1957
  ucptr = (unsigned char *)dest + 2 * count;
  {
#line 1959
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1959
    count --;
#line 1959
    if (! (count >= 0)) {
#line 1959
      goto while_break;
    }
    {
#line 1960
    ucptr -= 2;
#line 1961
    __cil_tmp9 = lrintf(*(src + count) * normfact);
#line 1961
    value = (int )__cil_tmp9;
#line 1962
    *(ucptr + 0) = (unsigned char )value;
#line 1963
    *(ucptr + 1) = (unsigned char )(value >> 8);
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 1968 "/root/libsndfile/src/pcm.c"
static void f2les_clip_array(float const   *src , short *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  float normfact ;
  float scaled_value ;
  int value ;
  double tmp ;
  long __cil_tmp10 ;

  {
#line 1973
  if (normalize) {
#line 1973
    tmp = 8. * (double )268435456;
  } else {
#line 1973
    tmp = 1. * (double )65536;
  }
#line 1973
  normfact = (float )tmp;
#line 1974
  ucptr = (unsigned char *)dest + 2 * count;
  {
#line 1976
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1976
    count --;
#line 1976
    if (! (count >= 0)) {
#line 1976
      goto while_break;
    }
#line 1977
    ucptr -= 2;
#line 1978
    scaled_value = *(src + count) * normfact;
#line 1979
    if ((double )scaled_value >= 1. * (double )2147483647) {
#line 1980
      *(ucptr + 0) = (unsigned char )255;
#line 1981
      *(ucptr + 1) = (unsigned char )127;
#line 1982
      goto while_continue;
    }

#line 1984
    if ((double )scaled_value <= - 8. * (double )268435456) {
#line 1985
      *(ucptr + 0) = (unsigned char )0;
#line 1986
      *(ucptr + 1) = (unsigned char )128;
#line 1987
      goto while_continue;
    }
    {
#line 1990
    __cil_tmp10 = lrintf(scaled_value);
#line 1990
    value = (int )__cil_tmp10;
#line 1991
    *(ucptr + 0) = (unsigned char )(value >> 16);
#line 1992
    *(ucptr + 1) = (unsigned char )(value >> 24);
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 1997 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_write_f2les(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  void (*convert)(float const   * , short * , int  , int  ) ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  void (*tmp)(float const   *src , short *dest , int count , int normalize ) ;
  sf_count_t __cil_tmp9 ;

  {
#line 2000
  total = (sf_count_t )0;
#line 2002
  if (psf->add_clipping) {
#line 2002
    tmp = & f2les_clip_array;
  } else {
#line 2002
    tmp = & f2les_array;
  }
#line 2002
  convert = tmp;
#line 2003
  bufferlen = (int )(sizeof(psf->u.sbuf) / sizeof(psf->u.sbuf[0]));
  {
#line 2005
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2005
    if (! (len > 0L)) {
#line 2005
      goto while_break;
    }
#line 2006
    if (len < (long )bufferlen) {
#line 2007
      bufferlen = (int )len;
    }
    {
#line 2008
    (*convert)(ptr + total, (short *)psf->u.sbuf, bufferlen, psf->norm_float);
#line 2009
    __cil_tmp9 = psf_fwrite((short *)psf->u.sbuf, (sf_count_t )sizeof(short ), (sf_count_t )bufferlen,
                            psf);
#line 2009
    writecount = (int )__cil_tmp9;
#line 2010
    total += (long )writecount;
    }
#line 2011
    if (writecount < bufferlen) {
#line 2012
      goto while_break;
    }
#line 2013
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 2016
  return (total);
}
}
#line 2023 "/root/libsndfile/src/pcm.c"
static void f2let_array(float const   *src , tribyte *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  float normfact ;
  int value ;
  double tmp ;
  long __cil_tmp9 ;

  {
#line 2028
  if (normalize) {
#line 2028
    tmp = 1. * (double )8388607;
  } else {
#line 2028
    tmp = 1.;
  }
#line 2028
  normfact = (float )tmp;
#line 2029
  ucptr = (unsigned char *)dest + 3 * count;
  {
#line 2031
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2031
    count --;
#line 2031
    if (! (count >= 0)) {
#line 2031
      goto while_break;
    }
    {
#line 2032
    ucptr -= 3;
#line 2033
    __cil_tmp9 = lrintf(*(src + count) * normfact);
#line 2033
    value = (int )__cil_tmp9;
#line 2034
    *(ucptr + 0) = (unsigned char )value;
#line 2035
    *(ucptr + 1) = (unsigned char )(value >> 8);
#line 2036
    *(ucptr + 2) = (unsigned char )(value >> 16);
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 2041 "/root/libsndfile/src/pcm.c"
static void f2let_clip_array(float const   *src , tribyte *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  float normfact ;
  float scaled_value ;
  int value ;
  double tmp ;
  long __cil_tmp10 ;

  {
#line 2046
  if (normalize) {
#line 2046
    tmp = 8. * (double )268435456;
  } else {
#line 2046
    tmp = 1. * (double )256;
  }
#line 2046
  normfact = (float )tmp;
#line 2047
  ucptr = (unsigned char *)dest + 3 * count;
  {
#line 2049
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2049
    count --;
#line 2049
    if (! (count >= 0)) {
#line 2049
      goto while_break;
    }
#line 2050
    ucptr -= 3;
#line 2051
    scaled_value = *(src + count) * normfact;
#line 2052
    if ((double )scaled_value >= 1. * (double )2147483647) {
#line 2053
      *(ucptr + 0) = (unsigned char )255;
#line 2054
      *(ucptr + 1) = (unsigned char )255;
#line 2055
      *(ucptr + 2) = (unsigned char )127;
#line 2056
      goto while_continue;
    }

#line 2058
    if ((double )scaled_value <= - 8. * (double )268435456) {
#line 2059
      *(ucptr + 0) = (unsigned char )0;
#line 2060
      *(ucptr + 1) = (unsigned char )0;
#line 2061
      *(ucptr + 2) = (unsigned char )128;
#line 2062
      goto while_continue;
    }
    {
#line 2065
    __cil_tmp10 = lrintf(scaled_value);
#line 2065
    value = (int )__cil_tmp10;
#line 2066
    *(ucptr + 0) = (unsigned char )(value >> 8);
#line 2067
    *(ucptr + 1) = (unsigned char )(value >> 16);
#line 2068
    *(ucptr + 2) = (unsigned char )(value >> 24);
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 2073 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_write_f2let(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  void (*convert)(float const   * , tribyte * , int  , int  ) ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  void (*tmp)(float const   *src , tribyte *dest , int count , int normalize ) ;
  sf_count_t __cil_tmp9 ;

  {
#line 2076
  total = (sf_count_t )0;
#line 2078
  if (psf->add_clipping) {
#line 2078
    tmp = & f2let_clip_array;
  } else {
#line 2078
    tmp = & f2let_array;
  }
#line 2078
  convert = tmp;
#line 2079
  bufferlen = (int )(sizeof(psf->u.ucbuf) / 3UL);
  {
#line 2081
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2081
    if (! (len > 0L)) {
#line 2081
      goto while_break;
    }
#line 2082
    if (len < (long )bufferlen) {
#line 2083
      bufferlen = (int )len;
    }
    {
#line 2084
    (*convert)(ptr + total, (tribyte *)((unsigned char *)psf->u.ucbuf), bufferlen,
               psf->norm_float);
#line 2085
    __cil_tmp9 = psf_fwrite((unsigned char *)psf->u.ucbuf, (sf_count_t )3, (sf_count_t )bufferlen,
                            psf);
#line 2085
    writecount = (int )__cil_tmp9;
#line 2086
    total += (long )writecount;
    }
#line 2087
    if (writecount < bufferlen) {
#line 2088
      goto while_break;
    }
#line 2089
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 2092
  return (total);
}
}
#line 2099 "/root/libsndfile/src/pcm.c"
static void f2bet_array(float const   *src , tribyte *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  float normfact ;
  int value ;
  double tmp ;
  long __cil_tmp9 ;

  {
#line 2104
  if (normalize) {
#line 2104
    tmp = 1. * (double )8388607;
  } else {
#line 2104
    tmp = 1.;
  }
#line 2104
  normfact = (float )tmp;
#line 2105
  ucptr = (unsigned char *)dest + 3 * count;
  {
#line 2107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2107
    count --;
#line 2107
    if (! (count >= 0)) {
#line 2107
      goto while_break;
    }
    {
#line 2108
    ucptr -= 3;
#line 2109
    __cil_tmp9 = lrintf(*(src + count) * normfact);
#line 2109
    value = (int )__cil_tmp9;
#line 2110
    *(ucptr + 0) = (unsigned char )(value >> 16);
#line 2111
    *(ucptr + 1) = (unsigned char )(value >> 8);
#line 2112
    *(ucptr + 2) = (unsigned char )value;
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 2117 "/root/libsndfile/src/pcm.c"
static void f2bet_clip_array(float const   *src , tribyte *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  float normfact ;
  float scaled_value ;
  int value ;
  double tmp ;
  long __cil_tmp10 ;

  {
#line 2122
  if (normalize) {
#line 2122
    tmp = 8. * (double )268435456;
  } else {
#line 2122
    tmp = 1. * (double )256;
  }
#line 2122
  normfact = (float )tmp;
#line 2123
  ucptr = (unsigned char *)dest + 3 * count;
  {
#line 2125
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2125
    count --;
#line 2125
    if (! (count >= 0)) {
#line 2125
      goto while_break;
    }
#line 2126
    ucptr -= 3;
#line 2127
    scaled_value = *(src + count) * normfact;
#line 2128
    if ((double )scaled_value >= 1. * (double )2147483647) {
#line 2129
      *(ucptr + 0) = (unsigned char )127;
#line 2130
      *(ucptr + 1) = (unsigned char )255;
#line 2131
      *(ucptr + 2) = (unsigned char )255;
#line 2132
      goto while_continue;
    }

#line 2134
    if ((double )scaled_value <= - 8. * (double )268435456) {
#line 2135
      *(ucptr + 0) = (unsigned char )128;
#line 2136
      *(ucptr + 1) = (unsigned char )0;
#line 2137
      *(ucptr + 2) = (unsigned char )0;
#line 2138
      goto while_continue;
    }
    {
#line 2141
    __cil_tmp10 = lrint((double )scaled_value);
#line 2141
    value = (int )__cil_tmp10;
#line 2142
    *(ucptr + 0) = (unsigned char )(value >> 24);
#line 2143
    *(ucptr + 1) = (unsigned char )(value >> 16);
#line 2144
    *(ucptr + 2) = (unsigned char )(value >> 8);
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 2149 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_write_f2bet(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  void (*convert)(float const   * , tribyte * , int  , int  ) ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  void (*tmp)(float const   *src , tribyte *dest , int count , int normalize ) ;
  sf_count_t __cil_tmp9 ;

  {
#line 2152
  total = (sf_count_t )0;
#line 2154
  if (psf->add_clipping) {
#line 2154
    tmp = & f2bet_clip_array;
  } else {
#line 2154
    tmp = & f2bet_array;
  }
#line 2154
  convert = tmp;
#line 2155
  bufferlen = (int )(sizeof(psf->u.ucbuf) / 3UL);
  {
#line 2157
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2157
    if (! (len > 0L)) {
#line 2157
      goto while_break;
    }
#line 2158
    if (len < (long )bufferlen) {
#line 2159
      bufferlen = (int )len;
    }
    {
#line 2160
    (*convert)(ptr + total, (tribyte *)((unsigned char *)psf->u.ucbuf), bufferlen,
               psf->norm_float);
#line 2161
    __cil_tmp9 = psf_fwrite((unsigned char *)psf->u.ucbuf, (sf_count_t )3, (sf_count_t )bufferlen,
                            psf);
#line 2161
    writecount = (int )__cil_tmp9;
#line 2162
    total += (long )writecount;
    }
#line 2163
    if (writecount < bufferlen) {
#line 2164
      goto while_break;
    }
#line 2165
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 2168
  return (total);
}
}
#line 2175 "/root/libsndfile/src/pcm.c"
static void f2bei_array(float const   *src , int *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  float normfact ;
  int value ;
  double tmp ;
  long __cil_tmp9 ;

  {
#line 2180
  if (normalize) {
#line 2180
    tmp = 1. * (double )2147483647;
  } else {
#line 2180
    tmp = 1.;
  }
#line 2180
  normfact = (float )tmp;
#line 2181
  ucptr = (unsigned char *)dest + 4 * count;
  {
#line 2182
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2182
    count --;
#line 2182
    if (! (count >= 0)) {
#line 2182
      goto while_break;
    }
    {
#line 2183
    ucptr -= 4;
#line 2184
    __cil_tmp9 = lrintf(*(src + count) * normfact);
#line 2184
    value = (int )__cil_tmp9;
#line 2185
    *(ucptr + 0) = (unsigned char )(value >> 24);
#line 2186
    *(ucptr + 1) = (unsigned char )(value >> 16);
#line 2187
    *(ucptr + 2) = (unsigned char )(value >> 8);
#line 2188
    *(ucptr + 3) = (unsigned char )value;
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 2193 "/root/libsndfile/src/pcm.c"
static void f2bei_clip_array(float const   *src , int *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  float normfact ;
  float scaled_value ;
  int value ;
  double tmp ;
  long __cil_tmp10 ;

  {
#line 2198
  if (normalize) {
#line 2198
    tmp = 8. * (double )268435456;
  } else {
#line 2198
    tmp = 1.;
  }
#line 2198
  normfact = (float )tmp;
#line 2199
  ucptr = (unsigned char *)dest + 4 * count;
  {
#line 2201
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2201
    count --;
#line 2201
    if (! (count >= 0)) {
#line 2201
      goto while_break;
    }
#line 2202
    ucptr -= 4;
#line 2203
    scaled_value = *(src + count) * normfact;
#line 2204
    if ((double )scaled_value >= 1. * (double )2147483647) {
#line 2205
      *(ucptr + 0) = (unsigned char )127;
#line 2206
      *(ucptr + 1) = (unsigned char )255;
#line 2207
      *(ucptr + 2) = (unsigned char )255;
#line 2208
      *(ucptr + 3) = (unsigned char )255;
#line 2209
      goto while_continue;
    }

#line 2211
    if ((double )scaled_value <= - 8. * (double )268435456) {
#line 2212
      *(ucptr + 0) = (unsigned char )128;
#line 2213
      *(ucptr + 1) = (unsigned char )0;
#line 2214
      *(ucptr + 2) = (unsigned char )0;
#line 2215
      *(ucptr + 3) = (unsigned char )0;
#line 2216
      goto while_continue;
    }
    {
#line 2219
    __cil_tmp10 = lrintf(scaled_value);
#line 2219
    value = (int )__cil_tmp10;
#line 2220
    *(ucptr + 0) = (unsigned char )(value >> 24);
#line 2221
    *(ucptr + 1) = (unsigned char )(value >> 16);
#line 2222
    *(ucptr + 2) = (unsigned char )(value >> 8);
#line 2223
    *(ucptr + 3) = (unsigned char )value;
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 2228 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_write_f2bei(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  void (*convert)(float const   * , int * , int  , int  ) ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  void (*tmp)(float const   *src , int *dest , int count , int normalize ) ;
  sf_count_t __cil_tmp9 ;

  {
#line 2231
  total = (sf_count_t )0;
#line 2233
  if (psf->add_clipping) {
#line 2233
    tmp = & f2bei_clip_array;
  } else {
#line 2233
    tmp = & f2bei_array;
  }
#line 2233
  convert = tmp;
#line 2234
  bufferlen = (int )(sizeof(psf->u.ibuf) / sizeof(psf->u.ibuf[0]));
  {
#line 2236
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2236
    if (! (len > 0L)) {
#line 2236
      goto while_break;
    }
#line 2237
    if (len < (long )bufferlen) {
#line 2238
      bufferlen = (int )len;
    }
    {
#line 2239
    (*convert)(ptr + total, (int *)psf->u.ibuf, bufferlen, psf->norm_float);
#line 2240
    __cil_tmp9 = psf_fwrite((int *)psf->u.ibuf, (sf_count_t )sizeof(int ), (sf_count_t )bufferlen,
                            psf);
#line 2240
    writecount = (int )__cil_tmp9;
#line 2241
    total += (long )writecount;
    }
#line 2242
    if (writecount < bufferlen) {
#line 2243
      goto while_break;
    }
#line 2244
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 2247
  return (total);
}
}
#line 2254 "/root/libsndfile/src/pcm.c"
static void f2lei_array(float const   *src , int *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  float normfact ;
  int value ;
  double tmp ;
  long __cil_tmp9 ;

  {
#line 2259
  if (normalize) {
#line 2259
    tmp = 1. * (double )2147483647;
  } else {
#line 2259
    tmp = 1.;
  }
#line 2259
  normfact = (float )tmp;
#line 2260
  ucptr = (unsigned char *)dest + 4 * count;
  {
#line 2262
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2262
    count --;
#line 2262
    if (! (count >= 0)) {
#line 2262
      goto while_break;
    }
    {
#line 2263
    ucptr -= 4;
#line 2264
    __cil_tmp9 = lrintf(*(src + count) * normfact);
#line 2264
    value = (int )__cil_tmp9;
#line 2265
    *(ucptr + 0) = (unsigned char )value;
#line 2266
    *(ucptr + 1) = (unsigned char )(value >> 8);
#line 2267
    *(ucptr + 2) = (unsigned char )(value >> 16);
#line 2268
    *(ucptr + 3) = (unsigned char )(value >> 24);
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 2273 "/root/libsndfile/src/pcm.c"
static void f2lei_clip_array(float const   *src , int *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  float normfact ;
  float scaled_value ;
  int value ;
  double tmp ;
  long __cil_tmp10 ;

  {
#line 2278
  if (normalize) {
#line 2278
    tmp = 8. * (double )268435456;
  } else {
#line 2278
    tmp = 1.;
  }
#line 2278
  normfact = (float )tmp;
#line 2279
  ucptr = (unsigned char *)dest + 4 * count;
  {
#line 2281
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2281
    count --;
#line 2281
    if (! (count >= 0)) {
#line 2281
      goto while_break;
    }
#line 2282
    ucptr -= 4;
#line 2283
    scaled_value = *(src + count) * normfact;
#line 2284
    if ((double )scaled_value >= 1. * (double )2147483647) {
#line 2285
      *(ucptr + 0) = (unsigned char )255;
#line 2286
      *(ucptr + 1) = (unsigned char )255;
#line 2287
      *(ucptr + 2) = (unsigned char )255;
#line 2288
      *(ucptr + 3) = (unsigned char )127;
#line 2289
      goto while_continue;
    }

#line 2291
    if ((double )scaled_value <= - 8. * (double )268435456) {
#line 2292
      *(ucptr + 0) = (unsigned char )0;
#line 2293
      *(ucptr + 1) = (unsigned char )0;
#line 2294
      *(ucptr + 2) = (unsigned char )0;
#line 2295
      *(ucptr + 3) = (unsigned char )128;
#line 2296
      goto while_continue;
    }
    {
#line 2299
    __cil_tmp10 = lrintf(scaled_value);
#line 2299
    value = (int )__cil_tmp10;
#line 2300
    *(ucptr + 0) = (unsigned char )value;
#line 2301
    *(ucptr + 1) = (unsigned char )(value >> 8);
#line 2302
    *(ucptr + 2) = (unsigned char )(value >> 16);
#line 2303
    *(ucptr + 3) = (unsigned char )(value >> 24);
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 2308 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_write_f2lei(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  void (*convert)(float const   * , int * , int  , int  ) ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  void (*tmp)(float const   *src , int *dest , int count , int normalize ) ;
  sf_count_t __cil_tmp9 ;

  {
#line 2311
  total = (sf_count_t )0;
#line 2313
  if (psf->add_clipping) {
#line 2313
    tmp = & f2lei_clip_array;
  } else {
#line 2313
    tmp = & f2lei_array;
  }
#line 2313
  convert = tmp;
#line 2314
  bufferlen = (int )(sizeof(psf->u.ibuf) / sizeof(psf->u.ibuf[0]));
  {
#line 2316
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2316
    if (! (len > 0L)) {
#line 2316
      goto while_break;
    }
#line 2317
    if (len < (long )bufferlen) {
#line 2318
      bufferlen = (int )len;
    }
    {
#line 2319
    (*convert)(ptr + total, (int *)psf->u.ibuf, bufferlen, psf->norm_float);
#line 2320
    __cil_tmp9 = psf_fwrite((int *)psf->u.ibuf, (sf_count_t )sizeof(int ), (sf_count_t )bufferlen,
                            psf);
#line 2320
    writecount = (int )__cil_tmp9;
#line 2321
    total += (long )writecount;
    }
#line 2322
    if (writecount < bufferlen) {
#line 2323
      goto while_break;
    }
#line 2324
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 2327
  return (total);
}
}
#line 2334 "/root/libsndfile/src/pcm.c"
static void d2sc_array(double const   *src , signed char *dest , int count , int normalize ) 
{ 
  double normfact ;
  double tmp ;
  long __cil_tmp7 ;

  {
#line 2337
  if (normalize) {
#line 2337
    tmp = 1. * (double )127;
  } else {
#line 2337
    tmp = 1.;
  }
#line 2337
  normfact = tmp;
  {
#line 2339
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2339
    count --;
#line 2339
    if (! (count >= 0)) {
#line 2339
      goto while_break;
    }
    {
#line 2340
    __cil_tmp7 = lrint(*(src + count) * normfact);
#line 2340
    *(dest + count) = (signed char )__cil_tmp7;
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 2345 "/root/libsndfile/src/pcm.c"
static void d2sc_clip_array(double const   *src , signed char *dest , int count ,
                            int normalize ) 
{ 
  double normfact ;
  double scaled_value ;
  double tmp ;
  long __cil_tmp8 ;

  {
#line 2348
  if (normalize) {
#line 2348
    tmp = 8. * (double )268435456;
  } else {
#line 2348
    tmp = 1. * (double )16777216;
  }
#line 2348
  normfact = tmp;
  {
#line 2350
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2350
    count --;
#line 2350
    if (! (count >= 0)) {
#line 2350
      goto while_break;
    }
#line 2351
    scaled_value = *(src + count) * normfact;
#line 2352
    if (scaled_value >= 1. * (double )2147483647) {
#line 2353
      *(dest + count) = (signed char )127;
#line 2354
      goto while_continue;
    }

#line 2356
    if (scaled_value <= - 8. * (double )268435456) {
#line 2357
      *(dest + count) = (signed char )(- 128);
#line 2358
      goto while_continue;
    }
    {
#line 2361
    __cil_tmp8 = lrintf((float )scaled_value);
#line 2361
    *(dest + count) = (signed char )(__cil_tmp8 >> 24);
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 2366 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_write_d2sc(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  void (*convert)(double const   * , signed char * , int  , int  ) ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  void (*tmp)(double const   *src , signed char *dest , int count , int normalize ) ;
  sf_count_t __cil_tmp9 ;

  {
#line 2369
  total = (sf_count_t )0;
#line 2371
  if (psf->add_clipping) {
#line 2371
    tmp = & d2sc_clip_array;
  } else {
#line 2371
    tmp = & d2sc_array;
  }
#line 2371
  convert = tmp;
#line 2372
  bufferlen = (int )(sizeof(psf->u.scbuf) / sizeof(psf->u.scbuf[0]));
  {
#line 2374
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2374
    if (! (len > 0L)) {
#line 2374
      goto while_break;
    }
#line 2375
    if (len < (long )bufferlen) {
#line 2376
      bufferlen = (int )len;
    }
    {
#line 2377
    (*convert)(ptr + total, (signed char *)psf->u.scbuf, bufferlen, psf->norm_double);
#line 2378
    __cil_tmp9 = psf_fwrite((signed char *)psf->u.scbuf, (sf_count_t )sizeof(signed char ),
                            (sf_count_t )bufferlen, psf);
#line 2378
    writecount = (int )__cil_tmp9;
#line 2379
    total += (long )writecount;
    }
#line 2380
    if (writecount < bufferlen) {
#line 2381
      goto while_break;
    }
#line 2382
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 2385
  return (total);
}
}
#line 2392 "/root/libsndfile/src/pcm.c"
static void d2uc_array(double const   *src , unsigned char *dest , int count , int normalize ) 
{ 
  double normfact ;
  double tmp ;
  long __cil_tmp7 ;

  {
#line 2395
  if (normalize) {
#line 2395
    tmp = 1. * (double )127;
  } else {
#line 2395
    tmp = 1.;
  }
#line 2395
  normfact = tmp;
  {
#line 2397
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2397
    count --;
#line 2397
    if (! (count >= 0)) {
#line 2397
      goto while_break;
    }
    {
#line 2398
    __cil_tmp7 = lrint(*(src + count) * normfact);
#line 2398
    *(dest + count) = (unsigned char )(__cil_tmp7 + 128L);
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 2403 "/root/libsndfile/src/pcm.c"
static void d2uc_clip_array(double const   *src , unsigned char *dest , int count ,
                            int normalize ) 
{ 
  double normfact ;
  double scaled_value ;
  double tmp ;
  long __cil_tmp8 ;

  {
#line 2406
  if (normalize) {
#line 2406
    tmp = 8. * (double )268435456;
  } else {
#line 2406
    tmp = 1. * (double )16777216;
  }
#line 2406
  normfact = tmp;
  {
#line 2408
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2408
    count --;
#line 2408
    if (! (count >= 0)) {
#line 2408
      goto while_break;
    }
#line 2409
    scaled_value = *(src + count) * normfact;
#line 2410
    if (scaled_value >= 1. * (double )2147483647) {
#line 2411
      *(dest + count) = (unsigned char )255;
#line 2412
      goto while_continue;
    }

#line 2414
    if (scaled_value <= - 8. * (double )268435456) {
#line 2415
      *(dest + count) = (unsigned char )0;
#line 2416
      goto while_continue;
    }
    {
#line 2419
    __cil_tmp8 = lrint(*(src + count) * normfact);
#line 2419
    *(dest + count) = (unsigned char )((__cil_tmp8 >> 24) + 128L);
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 2424 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_write_d2uc(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  void (*convert)(double const   * , unsigned char * , int  , int  ) ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  void (*tmp)(double const   *src , unsigned char *dest , int count , int normalize ) ;
  sf_count_t __cil_tmp9 ;

  {
#line 2427
  total = (sf_count_t )0;
#line 2429
  if (psf->add_clipping) {
#line 2429
    tmp = & d2uc_clip_array;
  } else {
#line 2429
    tmp = & d2uc_array;
  }
#line 2429
  convert = tmp;
#line 2430
  bufferlen = (int )(sizeof(psf->u.ucbuf) / sizeof(psf->u.ucbuf[0]));
  {
#line 2432
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2432
    if (! (len > 0L)) {
#line 2432
      goto while_break;
    }
#line 2433
    if (len < (long )bufferlen) {
#line 2434
      bufferlen = (int )len;
    }
    {
#line 2435
    (*convert)(ptr + total, (unsigned char *)psf->u.ucbuf, bufferlen, psf->norm_double);
#line 2436
    __cil_tmp9 = psf_fwrite((unsigned char *)psf->u.ucbuf, (sf_count_t )sizeof(unsigned char ),
                            (sf_count_t )bufferlen, psf);
#line 2436
    writecount = (int )__cil_tmp9;
#line 2437
    total += (long )writecount;
    }
#line 2438
    if (writecount < bufferlen) {
#line 2439
      goto while_break;
    }
#line 2440
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 2443
  return (total);
}
}
#line 2450 "/root/libsndfile/src/pcm.c"
static void d2bes_array(double const   *src , short *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  short value ;
  double normfact ;
  double tmp ;
  long __cil_tmp9 ;

  {
#line 2455
  if (normalize) {
#line 2455
    tmp = 1. * (double )32767;
  } else {
#line 2455
    tmp = 1.;
  }
#line 2455
  normfact = tmp;
#line 2456
  ucptr = (unsigned char *)dest + 2 * count;
  {
#line 2458
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2458
    count --;
#line 2458
    if (! (count >= 0)) {
#line 2458
      goto while_break;
    }
    {
#line 2459
    ucptr -= 2;
#line 2460
    __cil_tmp9 = lrint(*(src + count) * normfact);
#line 2460
    value = (short )__cil_tmp9;
#line 2461
    *(ucptr + 1) = (unsigned char )value;
#line 2462
    *(ucptr + 0) = (unsigned char )((int )value >> 8);
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 2467 "/root/libsndfile/src/pcm.c"
static void d2bes_clip_array(double const   *src , short *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  double normfact ;
  double scaled_value ;
  int value ;
  double tmp ;
  long __cil_tmp10 ;

  {
#line 2472
  if (normalize) {
#line 2472
    tmp = 8. * (double )268435456;
  } else {
#line 2472
    tmp = 1. * (double )65536;
  }
#line 2472
  normfact = tmp;
#line 2473
  ucptr = (unsigned char *)dest + 2 * count;
  {
#line 2475
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2475
    count --;
#line 2475
    if (! (count >= 0)) {
#line 2475
      goto while_break;
    }
#line 2476
    ucptr -= 2;
#line 2477
    scaled_value = *(src + count) * normfact;
#line 2478
    if (scaled_value >= 1. * (double )2147483647) {
#line 2479
      *(ucptr + 1) = (unsigned char )255;
#line 2480
      *(ucptr + 0) = (unsigned char )127;
#line 2481
      goto while_continue;
    }

#line 2483
    if (scaled_value <= - 8. * (double )268435456) {
#line 2484
      *(ucptr + 1) = (unsigned char )0;
#line 2485
      *(ucptr + 0) = (unsigned char )128;
#line 2486
      goto while_continue;
    }
    {
#line 2489
    __cil_tmp10 = lrint(scaled_value);
#line 2489
    value = (int )__cil_tmp10;
#line 2490
    *(ucptr + 1) = (unsigned char )(value >> 16);
#line 2491
    *(ucptr + 0) = (unsigned char )(value >> 24);
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 2496 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_write_d2bes(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  void (*convert)(double const   * , short * , int  , int  ) ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  void (*tmp)(double const   *src , short *dest , int count , int normalize ) ;
  sf_count_t __cil_tmp9 ;

  {
#line 2499
  total = (sf_count_t )0;
#line 2501
  if (psf->add_clipping) {
#line 2501
    tmp = & d2bes_clip_array;
  } else {
#line 2501
    tmp = & d2bes_array;
  }
#line 2501
  convert = tmp;
#line 2502
  bufferlen = (int )(sizeof(psf->u.sbuf) / sizeof(psf->u.sbuf[0]));
  {
#line 2504
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2504
    if (! (len > 0L)) {
#line 2504
      goto while_break;
    }
#line 2505
    if (len < (long )bufferlen) {
#line 2506
      bufferlen = (int )len;
    }
    {
#line 2507
    (*convert)(ptr + total, (short *)psf->u.sbuf, bufferlen, psf->norm_double);
#line 2508
    __cil_tmp9 = psf_fwrite((short *)psf->u.sbuf, (sf_count_t )sizeof(short ), (sf_count_t )bufferlen,
                            psf);
#line 2508
    writecount = (int )__cil_tmp9;
#line 2509
    total += (long )writecount;
    }
#line 2510
    if (writecount < bufferlen) {
#line 2511
      goto while_break;
    }
#line 2512
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 2515
  return (total);
}
}
#line 2522 "/root/libsndfile/src/pcm.c"
static void d2les_array(double const   *src , short *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  short value ;
  double normfact ;
  double tmp ;
  long __cil_tmp9 ;

  {
#line 2527
  if (normalize) {
#line 2527
    tmp = 1. * (double )32767;
  } else {
#line 2527
    tmp = 1.;
  }
#line 2527
  normfact = tmp;
#line 2528
  ucptr = (unsigned char *)dest + 2 * count;
  {
#line 2530
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2530
    count --;
#line 2530
    if (! (count >= 0)) {
#line 2530
      goto while_break;
    }
    {
#line 2531
    ucptr -= 2;
#line 2532
    __cil_tmp9 = lrint(*(src + count) * normfact);
#line 2532
    value = (short )__cil_tmp9;
#line 2533
    *(ucptr + 0) = (unsigned char )value;
#line 2534
    *(ucptr + 1) = (unsigned char )((int )value >> 8);
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 2539 "/root/libsndfile/src/pcm.c"
static void d2les_clip_array(double const   *src , short *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  int value ;
  double normfact ;
  double scaled_value ;
  double tmp ;
  long __cil_tmp10 ;

  {
#line 2544
  if (normalize) {
#line 2544
    tmp = 8. * (double )268435456;
  } else {
#line 2544
    tmp = 1. * (double )65536;
  }
#line 2544
  normfact = tmp;
#line 2545
  ucptr = (unsigned char *)dest + 2 * count;
  {
#line 2547
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2547
    count --;
#line 2547
    if (! (count >= 0)) {
#line 2547
      goto while_break;
    }
#line 2548
    ucptr -= 2;
#line 2549
    scaled_value = *(src + count) * normfact;
#line 2550
    if (scaled_value >= 1. * (double )2147483647) {
#line 2551
      *(ucptr + 0) = (unsigned char )255;
#line 2552
      *(ucptr + 1) = (unsigned char )127;
#line 2553
      goto while_continue;
    }

#line 2555
    if (scaled_value <= - 8. * (double )268435456) {
#line 2556
      *(ucptr + 0) = (unsigned char )0;
#line 2557
      *(ucptr + 1) = (unsigned char )128;
#line 2558
      goto while_continue;
    }
    {
#line 2561
    __cil_tmp10 = lrint(scaled_value);
#line 2561
    value = (int )__cil_tmp10;
#line 2562
    *(ucptr + 0) = (unsigned char )(value >> 16);
#line 2563
    *(ucptr + 1) = (unsigned char )(value >> 24);
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 2568 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_write_d2les(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  void (*convert)(double const   * , short * , int  , int  ) ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  void (*tmp)(double const   *src , short *dest , int count , int normalize ) ;
  sf_count_t __cil_tmp9 ;

  {
#line 2571
  total = (sf_count_t )0;
#line 2573
  if (psf->add_clipping) {
#line 2573
    tmp = & d2les_clip_array;
  } else {
#line 2573
    tmp = & d2les_array;
  }
#line 2573
  convert = tmp;
#line 2574
  bufferlen = (int )(sizeof(psf->u.sbuf) / sizeof(psf->u.sbuf[0]));
  {
#line 2576
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2576
    if (! (len > 0L)) {
#line 2576
      goto while_break;
    }
#line 2577
    if (len < (long )bufferlen) {
#line 2578
      bufferlen = (int )len;
    }
    {
#line 2579
    (*convert)(ptr + total, (short *)psf->u.sbuf, bufferlen, psf->norm_double);
#line 2580
    __cil_tmp9 = psf_fwrite((short *)psf->u.sbuf, (sf_count_t )sizeof(short ), (sf_count_t )bufferlen,
                            psf);
#line 2580
    writecount = (int )__cil_tmp9;
#line 2581
    total += (long )writecount;
    }
#line 2582
    if (writecount < bufferlen) {
#line 2583
      goto while_break;
    }
#line 2584
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 2587
  return (total);
}
}
#line 2594 "/root/libsndfile/src/pcm.c"
static void d2let_array(double const   *src , tribyte *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  int value ;
  double normfact ;
  double tmp ;
  long __cil_tmp9 ;

  {
#line 2599
  if (normalize) {
#line 2599
    tmp = 1. * (double )8388607;
  } else {
#line 2599
    tmp = 1.;
  }
#line 2599
  normfact = tmp;
#line 2600
  ucptr = (unsigned char *)dest + 3 * count;
  {
#line 2602
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2602
    count --;
#line 2602
    if (! (count >= 0)) {
#line 2602
      goto while_break;
    }
    {
#line 2603
    ucptr -= 3;
#line 2604
    __cil_tmp9 = lrint(*(src + count) * normfact);
#line 2604
    value = (int )__cil_tmp9;
#line 2605
    *(ucptr + 0) = (unsigned char )value;
#line 2606
    *(ucptr + 1) = (unsigned char )(value >> 8);
#line 2607
    *(ucptr + 2) = (unsigned char )(value >> 16);
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 2612 "/root/libsndfile/src/pcm.c"
static void d2let_clip_array(double const   *src , tribyte *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  int value ;
  double normfact ;
  double scaled_value ;
  double tmp ;
  long __cil_tmp10 ;

  {
#line 2617
  if (normalize) {
#line 2617
    tmp = 8. * (double )268435456;
  } else {
#line 2617
    tmp = 1. * (double )256;
  }
#line 2617
  normfact = tmp;
#line 2618
  ucptr = (unsigned char *)dest + 3 * count;
  {
#line 2620
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2620
    count --;
#line 2620
    if (! (count >= 0)) {
#line 2620
      goto while_break;
    }
#line 2621
    ucptr -= 3;
#line 2622
    scaled_value = *(src + count) * normfact;
#line 2623
    if (scaled_value >= 1. * (double )2147483647) {
#line 2624
      *(ucptr + 0) = (unsigned char )255;
#line 2625
      *(ucptr + 1) = (unsigned char )255;
#line 2626
      *(ucptr + 2) = (unsigned char )127;
#line 2627
      goto while_continue;
    }

#line 2629
    if (scaled_value <= - 8. * (double )268435456) {
#line 2630
      *(ucptr + 0) = (unsigned char )0;
#line 2631
      *(ucptr + 1) = (unsigned char )0;
#line 2632
      *(ucptr + 2) = (unsigned char )128;
#line 2633
      goto while_continue;
    }
    {
#line 2636
    __cil_tmp10 = lrint(scaled_value);
#line 2636
    value = (int )__cil_tmp10;
#line 2637
    *(ucptr + 0) = (unsigned char )(value >> 8);
#line 2638
    *(ucptr + 1) = (unsigned char )(value >> 16);
#line 2639
    *(ucptr + 2) = (unsigned char )(value >> 24);
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 2644 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_write_d2let(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  void (*convert)(double const   * , tribyte * , int  , int  ) ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  void (*tmp)(double const   *src , tribyte *dest , int count , int normalize ) ;
  sf_count_t __cil_tmp9 ;

  {
#line 2647
  total = (sf_count_t )0;
#line 2649
  if (psf->add_clipping) {
#line 2649
    tmp = & d2let_clip_array;
  } else {
#line 2649
    tmp = & d2let_array;
  }
#line 2649
  convert = tmp;
#line 2650
  bufferlen = (int )(sizeof(psf->u.ucbuf) / 3UL);
  {
#line 2652
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2652
    if (! (len > 0L)) {
#line 2652
      goto while_break;
    }
#line 2653
    if (len < (long )bufferlen) {
#line 2654
      bufferlen = (int )len;
    }
    {
#line 2655
    (*convert)(ptr + total, (tribyte *)((unsigned char *)psf->u.ucbuf), bufferlen,
               psf->norm_double);
#line 2656
    __cil_tmp9 = psf_fwrite((unsigned char *)psf->u.ucbuf, (sf_count_t )3, (sf_count_t )bufferlen,
                            psf);
#line 2656
    writecount = (int )__cil_tmp9;
#line 2657
    total += (long )writecount;
    }
#line 2658
    if (writecount < bufferlen) {
#line 2659
      goto while_break;
    }
#line 2660
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 2663
  return (total);
}
}
#line 2670 "/root/libsndfile/src/pcm.c"
static void d2bet_array(double const   *src , tribyte *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  int value ;
  double normfact ;
  double tmp ;
  long __cil_tmp9 ;

  {
#line 2675
  if (normalize) {
#line 2675
    tmp = 1. * (double )8388607;
  } else {
#line 2675
    tmp = 1.;
  }
#line 2675
  normfact = tmp;
#line 2676
  ucptr = (unsigned char *)dest + 3 * count;
  {
#line 2678
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2678
    count --;
#line 2678
    if (! (count >= 0)) {
#line 2678
      goto while_break;
    }
    {
#line 2679
    ucptr -= 3;
#line 2680
    __cil_tmp9 = lrint(*(src + count) * normfact);
#line 2680
    value = (int )__cil_tmp9;
#line 2681
    *(ucptr + 2) = (unsigned char )value;
#line 2682
    *(ucptr + 1) = (unsigned char )(value >> 8);
#line 2683
    *(ucptr + 0) = (unsigned char )(value >> 16);
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 2688 "/root/libsndfile/src/pcm.c"
static void d2bet_clip_array(double const   *src , tribyte *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  int value ;
  double normfact ;
  double scaled_value ;
  double tmp ;
  long __cil_tmp10 ;

  {
#line 2693
  if (normalize) {
#line 2693
    tmp = 8. * (double )268435456;
  } else {
#line 2693
    tmp = 1. * (double )256;
  }
#line 2693
  normfact = tmp;
#line 2694
  ucptr = (unsigned char *)dest + 3 * count;
  {
#line 2696
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2696
    count --;
#line 2696
    if (! (count >= 0)) {
#line 2696
      goto while_break;
    }
#line 2697
    ucptr -= 3;
#line 2698
    scaled_value = *(src + count) * normfact;
#line 2699
    if (scaled_value >= 1. * (double )2147483647) {
#line 2700
      *(ucptr + 2) = (unsigned char )255;
#line 2701
      *(ucptr + 1) = (unsigned char )255;
#line 2702
      *(ucptr + 0) = (unsigned char )127;
#line 2703
      goto while_continue;
    }

#line 2705
    if (scaled_value <= - 8. * (double )268435456) {
#line 2706
      *(ucptr + 2) = (unsigned char )0;
#line 2707
      *(ucptr + 1) = (unsigned char )0;
#line 2708
      *(ucptr + 0) = (unsigned char )128;
#line 2709
      goto while_continue;
    }
    {
#line 2712
    __cil_tmp10 = lrint(scaled_value);
#line 2712
    value = (int )__cil_tmp10;
#line 2713
    *(ucptr + 2) = (unsigned char )(value >> 8);
#line 2714
    *(ucptr + 1) = (unsigned char )(value >> 16);
#line 2715
    *(ucptr + 0) = (unsigned char )(value >> 24);
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 2720 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_write_d2bet(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  void (*convert)(double const   * , tribyte * , int  , int  ) ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  void (*tmp)(double const   *src , tribyte *dest , int count , int normalize ) ;
  sf_count_t __cil_tmp9 ;

  {
#line 2723
  total = (sf_count_t )0;
#line 2725
  if (psf->add_clipping) {
#line 2725
    tmp = & d2bet_clip_array;
  } else {
#line 2725
    tmp = & d2bet_array;
  }
#line 2725
  convert = tmp;
#line 2726
  bufferlen = (int )(sizeof(psf->u.ucbuf) / 3UL);
  {
#line 2728
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2728
    if (! (len > 0L)) {
#line 2728
      goto while_break;
    }
#line 2729
    if (len < (long )bufferlen) {
#line 2730
      bufferlen = (int )len;
    }
    {
#line 2731
    (*convert)(ptr + total, (tribyte *)((unsigned char *)psf->u.ucbuf), bufferlen,
               psf->norm_double);
#line 2732
    __cil_tmp9 = psf_fwrite((unsigned char *)psf->u.ucbuf, (sf_count_t )3, (sf_count_t )bufferlen,
                            psf);
#line 2732
    writecount = (int )__cil_tmp9;
#line 2733
    total += (long )writecount;
    }
#line 2734
    if (writecount < bufferlen) {
#line 2735
      goto while_break;
    }
#line 2736
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 2739
  return (total);
}
}
#line 2746 "/root/libsndfile/src/pcm.c"
static void d2bei_array(double const   *src , int *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  int value ;
  double normfact ;
  double tmp ;
  long __cil_tmp9 ;

  {
#line 2751
  if (normalize) {
#line 2751
    tmp = 1. * (double )2147483647;
  } else {
#line 2751
    tmp = 1.;
  }
#line 2751
  normfact = tmp;
#line 2752
  ucptr = (unsigned char *)dest + 4 * count;
  {
#line 2754
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2754
    count --;
#line 2754
    if (! (count >= 0)) {
#line 2754
      goto while_break;
    }
    {
#line 2755
    ucptr -= 4;
#line 2756
    __cil_tmp9 = lrint(*(src + count) * normfact);
#line 2756
    value = (int )__cil_tmp9;
#line 2757
    *(ucptr + 0) = (unsigned char )(value >> 24);
#line 2758
    *(ucptr + 1) = (unsigned char )(value >> 16);
#line 2759
    *(ucptr + 2) = (unsigned char )(value >> 8);
#line 2760
    *(ucptr + 3) = (unsigned char )value;
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 2765 "/root/libsndfile/src/pcm.c"
static void d2bei_clip_array(double const   *src , int *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  int value ;
  double normfact ;
  double scaled_value ;
  double tmp ;
  long __cil_tmp10 ;

  {
#line 2770
  if (normalize) {
#line 2770
    tmp = 8. * (double )268435456;
  } else {
#line 2770
    tmp = 1.;
  }
#line 2770
  normfact = tmp;
#line 2771
  ucptr = (unsigned char *)dest + 4 * count;
  {
#line 2773
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2773
    count --;
#line 2773
    if (! (count >= 0)) {
#line 2773
      goto while_break;
    }
#line 2774
    ucptr -= 4;
#line 2775
    scaled_value = *(src + count) * normfact;
#line 2776
    if (scaled_value >= 1. * (double )2147483647) {
#line 2777
      *(ucptr + 3) = (unsigned char )255;
#line 2778
      *(ucptr + 2) = (unsigned char )255;
#line 2779
      *(ucptr + 1) = (unsigned char )255;
#line 2780
      *(ucptr + 0) = (unsigned char )127;
#line 2781
      goto while_continue;
    }

#line 2783
    if (scaled_value <= - 8. * (double )268435456) {
#line 2784
      *(ucptr + 3) = (unsigned char )0;
#line 2785
      *(ucptr + 2) = (unsigned char )0;
#line 2786
      *(ucptr + 1) = (unsigned char )0;
#line 2787
      *(ucptr + 0) = (unsigned char )128;
#line 2788
      goto while_continue;
    }
    {
#line 2791
    __cil_tmp10 = lrint(scaled_value);
#line 2791
    value = (int )__cil_tmp10;
#line 2792
    *(ucptr + 0) = (unsigned char )(value >> 24);
#line 2793
    *(ucptr + 1) = (unsigned char )(value >> 16);
#line 2794
    *(ucptr + 2) = (unsigned char )(value >> 8);
#line 2795
    *(ucptr + 3) = (unsigned char )value;
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 2800 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_write_d2bei(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  void (*convert)(double const   * , int * , int  , int  ) ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  void (*tmp)(double const   *src , int *dest , int count , int normalize ) ;
  sf_count_t __cil_tmp9 ;

  {
#line 2803
  total = (sf_count_t )0;
#line 2805
  if (psf->add_clipping) {
#line 2805
    tmp = & d2bei_clip_array;
  } else {
#line 2805
    tmp = & d2bei_array;
  }
#line 2805
  convert = tmp;
#line 2806
  bufferlen = (int )(sizeof(psf->u.ibuf) / sizeof(psf->u.ibuf[0]));
  {
#line 2808
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2808
    if (! (len > 0L)) {
#line 2808
      goto while_break;
    }
#line 2809
    if (len < (long )bufferlen) {
#line 2810
      bufferlen = (int )len;
    }
    {
#line 2811
    (*convert)(ptr + total, (int *)psf->u.ibuf, bufferlen, psf->norm_double);
#line 2812
    __cil_tmp9 = psf_fwrite((int *)psf->u.ibuf, (sf_count_t )sizeof(int ), (sf_count_t )bufferlen,
                            psf);
#line 2812
    writecount = (int )__cil_tmp9;
#line 2813
    total += (long )writecount;
    }
#line 2814
    if (writecount < bufferlen) {
#line 2815
      goto while_break;
    }
#line 2816
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 2819
  return (total);
}
}
#line 2826 "/root/libsndfile/src/pcm.c"
static void d2lei_array(double const   *src , int *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  int value ;
  double normfact ;
  double tmp ;
  long __cil_tmp9 ;

  {
#line 2831
  if (normalize) {
#line 2831
    tmp = 1. * (double )2147483647;
  } else {
#line 2831
    tmp = 1.;
  }
#line 2831
  normfact = tmp;
#line 2832
  ucptr = (unsigned char *)dest + 4 * count;
  {
#line 2834
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2834
    count --;
#line 2834
    if (! (count >= 0)) {
#line 2834
      goto while_break;
    }
    {
#line 2835
    ucptr -= 4;
#line 2836
    __cil_tmp9 = lrint(*(src + count) * normfact);
#line 2836
    value = (int )__cil_tmp9;
#line 2837
    *(ucptr + 0) = (unsigned char )value;
#line 2838
    *(ucptr + 1) = (unsigned char )(value >> 8);
#line 2839
    *(ucptr + 2) = (unsigned char )(value >> 16);
#line 2840
    *(ucptr + 3) = (unsigned char )(value >> 24);
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 2845 "/root/libsndfile/src/pcm.c"
static void d2lei_clip_array(double const   *src , int *dest , int count , int normalize ) 
{ 
  unsigned char *ucptr ;
  int value ;
  double normfact ;
  double scaled_value ;
  double tmp ;
  long __cil_tmp10 ;

  {
#line 2850
  if (normalize) {
#line 2850
    tmp = 8. * (double )268435456;
  } else {
#line 2850
    tmp = 1.;
  }
#line 2850
  normfact = tmp;
#line 2851
  ucptr = (unsigned char *)dest + 4 * count;
  {
#line 2853
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2853
    count --;
#line 2853
    if (! (count >= 0)) {
#line 2853
      goto while_break;
    }
#line 2854
    ucptr -= 4;
#line 2855
    scaled_value = *(src + count) * normfact;
#line 2856
    if (scaled_value >= 1. * (double )2147483647) {
#line 2857
      *(ucptr + 0) = (unsigned char )255;
#line 2858
      *(ucptr + 1) = (unsigned char )255;
#line 2859
      *(ucptr + 2) = (unsigned char )255;
#line 2860
      *(ucptr + 3) = (unsigned char )127;
#line 2861
      goto while_continue;
    }

#line 2863
    if (scaled_value <= - 8. * (double )268435456) {
#line 2864
      *(ucptr + 0) = (unsigned char )0;
#line 2865
      *(ucptr + 1) = (unsigned char )0;
#line 2866
      *(ucptr + 2) = (unsigned char )0;
#line 2867
      *(ucptr + 3) = (unsigned char )128;
#line 2868
      goto while_continue;
    }
    {
#line 2871
    __cil_tmp10 = lrint(scaled_value);
#line 2871
    value = (int )__cil_tmp10;
#line 2872
    *(ucptr + 0) = (unsigned char )value;
#line 2873
    *(ucptr + 1) = (unsigned char )(value >> 8);
#line 2874
    *(ucptr + 2) = (unsigned char )(value >> 16);
#line 2875
    *(ucptr + 3) = (unsigned char )(value >> 24);
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 2880 "/root/libsndfile/src/pcm.c"
static sf_count_t pcm_write_d2lei(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  void (*convert)(double const   * , int * , int  , int  ) ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  void (*tmp)(double const   *src , int *dest , int count , int normalize ) ;
  sf_count_t __cil_tmp9 ;

  {
#line 2883
  total = (sf_count_t )0;
#line 2885
  if (psf->add_clipping) {
#line 2885
    tmp = & d2lei_clip_array;
  } else {
#line 2885
    tmp = & d2lei_array;
  }
#line 2885
  convert = tmp;
#line 2886
  bufferlen = (int )(sizeof(psf->u.ibuf) / sizeof(psf->u.ibuf[0]));
  {
#line 2888
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2888
    if (! (len > 0L)) {
#line 2888
      goto while_break;
    }
#line 2889
    if (len < (long )bufferlen) {
#line 2890
      bufferlen = (int )len;
    }
    {
#line 2891
    (*convert)(ptr + total, (int *)psf->u.ibuf, bufferlen, psf->norm_double);
#line 2892
    __cil_tmp9 = psf_fwrite((int *)psf->u.ibuf, (sf_count_t )sizeof(int ), (sf_count_t )bufferlen,
                            psf);
#line 2892
    writecount = (int )__cil_tmp9;
#line 2893
    total += (long )writecount;
    }
#line 2894
    if (writecount < bufferlen) {
#line 2895
      goto while_break;
    }
#line 2896
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 2899
  return (total);
}
}
#line 277 "/root/libsndfile/src/wav_w64.h"
void msadpcm_write_adapt_coeffs(SF_PRIVATE *psf ) ;
#line 283
int wav_w64_srate2blocksize(int srate_chan_product ) ;
#line 284
char const   *wav_w64_format_str(int k ) ;
#line 285
int wav_w64_read_fmt_chunk(SF_PRIVATE *psf , int fmtsize ) ;
#line 286
void wavex_write_guid(SF_PRIVATE *psf , EXT_SUBFORMAT *subformat ) ;
#line 287
void wav_w64_analyze(SF_PRIVATE *psf ) ;
#line 58 "/root/libsndfile/src/ms_adpcm.c"
static int AdaptationTable[16]  = 
#line 58 "/root/libsndfile/src/ms_adpcm.c"
  {      230,      230,      230,      230, 
        307,      409,      512,      614, 
        768,      614,      512,      409, 
        307,      230,      230,      230};
#line 67 "/root/libsndfile/src/ms_adpcm.c"
static int AdaptCoeff1[7]  = {      256,      512,      0,      192, 
        240,      460,      392};
#line 71 "/root/libsndfile/src/ms_adpcm.c"
static int AdaptCoeff2[7]  = {      0,      - 256,      0,      64, 
        0,      - 208,      - 232};
#line 104
static int msadpcm_decode_block(SF_PRIVATE *psf , MSADPCM_PRIVATE *pms ) ;
#line 105
static sf_count_t msadpcm_read_block(SF_PRIVATE *psf , MSADPCM_PRIVATE *pms , short *ptr ,
                                     int len ) ;
#line 107
static int msadpcm_encode_block(SF_PRIVATE *psf , MSADPCM_PRIVATE *pms ) ;
#line 108
static sf_count_t msadpcm_write_block(SF_PRIVATE *psf , MSADPCM_PRIVATE *pms , short const   *ptr ,
                                      int len ) ;
#line 110
static sf_count_t msadpcm_read_s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 111
static sf_count_t msadpcm_read_i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 112
static sf_count_t msadpcm_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 113
static sf_count_t msadpcm_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 115
static sf_count_t msadpcm_write_s(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 116
static sf_count_t msadpcm_write_i(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 117
static sf_count_t msadpcm_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 118
static sf_count_t msadpcm_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 120
static sf_count_t msadpcm_seek(SF_PRIVATE *psf , int mode , sf_count_t offset ) ;
#line 121
static int msadpcm_close(SF_PRIVATE *psf ) ;
#line 123
static void choose_predictor(unsigned int channels , short *data___0 , int *block_pred ,
                             int *idelta ) ;
#line 130 "/root/libsndfile/src/ms_adpcm.c"
int wav_w64_msadpcm_init(SF_PRIVATE *psf , int blockalign , int samplesperblock ) 
{ 
  MSADPCM_PRIVATE *pms ;
  unsigned int pmssize ;
  int count ;
  void *__cil_tmp7 ;

  {
#line 135
  if (psf->codec_data != (void *)0) {
    {
#line 136
    psf_log_printf(psf, "*** psf->codec_data is not NULL.\n");
    }
#line 137
    return (29);
  }

#line 140
  if (psf->mode == 32) {
#line 141
    samplesperblock = 2 + (2 * (blockalign - 7 * psf->sf.channels)) / psf->sf.channels;
  }
  {
#line 143
  pmssize = (unsigned int )((sizeof(MSADPCM_PRIVATE ) + (unsigned long )blockalign) + (unsigned long )((3 * psf->sf.channels) * samplesperblock));
#line 145
  psf->codec_data = malloc((unsigned long )pmssize);
  }
#line 145
  if (! psf->codec_data) {
#line 146
    return (16);
  }
  {
#line 147
  pms = (MSADPCM_PRIVATE *)psf->codec_data;
#line 148
  memset(pms, 0, (unsigned long )pmssize);
#line 150
  pms->samples = (short *)pms->dummydata;
#line 151
  pms->block = (unsigned char *)((short *)pms->dummydata + psf->sf.channels * samplesperblock);
#line 153
  pms->channels = psf->sf.channels;
#line 154
  pms->blocksize = blockalign;
#line 155
  pms->samplesperblock = samplesperblock;
  }
#line 157
  if (pms->blocksize == 0) {
    {
#line 158
    psf_log_printf(psf, "*** Error : pms->blocksize should not be zero.\n");
    }
#line 159
    return (29);
  }

#line 162
  if (psf->mode == 16) {
#line 163
    pms->dataremaining = (int )psf->datalength;
#line 165
    if (psf->datalength % (long )pms->blocksize) {
#line 166
      pms->blocks = (int )(psf->datalength / (long )pms->blocksize + 1L);
    } else {
#line 168
      pms->blocks = (int )(psf->datalength / (long )pms->blocksize);
    }
#line 170
    count = (2 * (pms->blocksize - 6 * pms->channels)) / pms->channels;
#line 171
    if (pms->samplesperblock != count) {
      {
#line 172
      psf_log_printf(psf, "*** Error : samplesperblock should be %d.\n", count);
      }
#line 173
      return (29);
    }
    {
#line 176
    psf->sf.frames = (psf->datalength / (long )pms->blocksize) * (long )pms->samplesperblock;
#line 178
    psf_log_printf(psf, " bpred   idelta\n\220");
#line 180
    msadpcm_decode_block(psf, pms);
#line 182
    psf->read_short = & msadpcm_read_s;
#line 183
    psf->read_int = & msadpcm_read_i;
#line 184
    psf->read_float = & msadpcm_read_f;
#line 185
    psf->read_double = & msadpcm_read_d;
    }
  }

#line 188
  if (psf->mode == 32) {
#line 189
    pms->samples = (short *)pms->dummydata;
#line 191
    pms->samplecount = (sf_count_t )0;
#line 193
    psf->write_short = & msadpcm_write_s;
#line 194
    psf->write_int = & msadpcm_write_i;
#line 195
    psf->write_float = & msadpcm_write_f;
#line 196
    psf->write_double = & msadpcm_write_d;
  }
#line 199
  psf->codec_close = & msadpcm_close;
#line 200
  psf->seek = & msadpcm_seek;
#line 202
  return (0);
}
}
#line 206 "/root/libsndfile/src/ms_adpcm.c"
static int msadpcm_decode_block(SF_PRIVATE *psf , MSADPCM_PRIVATE *pms ) 
{ 
  int chan ;
  int k ;
  int blockindx ;
  int sampleindx ;
  short bytecode ;
  short bpred[2] ;
  short chan_idelta[2] ;
  int predict ;
  int current ;
  int idelta ;
  int __cil_tmp13 ;
  sf_count_t __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int tmp ;
  int __cil_tmp19 ;

  {
#line 214
  (pms->blockcount) ++;
#line 215
  pms->samplecount = (sf_count_t )0;
#line 217
  if (pms->blockcount > pms->blocks) {
    {
#line 218
    memset(pms->samples, 0, (unsigned long )(pms->samplesperblock * pms->channels));
    }
#line 219
    return (1);
  }
  {
#line 222
  __cil_tmp14 = psf_fread(pms->block, (sf_count_t )1, (sf_count_t )pms->blocksize,
                          psf);
#line 222
  k = (int )__cil_tmp14;
  }
#line 222
  if (k != pms->blocksize) {
    {
#line 223
    psf_log_printf(psf, "*** Warning : short read (%d != %d).\nV", k, pms->blocksize);
    }
  }
#line 227
  if (pms->channels == 1) {
#line 228
    bpred[0] = (short )*(pms->block + 0);
#line 230
    if ((int )bpred[0] >= 7) {
      {
#line 231
      psf_log_printf(psf, "MS ADPCM synchronisation error (%d).\n", (int )bpred[0]);
      }
    }
    {
#line 233
    chan_idelta[0] = (short )((int )*(pms->block + 1) | ((int )*(pms->block + 2) << 8));
#line 234
    chan_idelta[1] = (short )0;
#line 236
    psf_log_printf(psf, "(%d) (%d)\n", (int )bpred[0], (int )chan_idelta[0]);
#line 238
    *(pms->samples + 1) = (short )((int )*(pms->block + 3) | ((int )*(pms->block + 4) << 8));
#line 239
    *(pms->samples + 0) = (short )((int )*(pms->block + 5) | ((int )*(pms->block + 6) << 8));
#line 240
    blockindx = 7;
    }
  } else {
#line 243
    bpred[0] = (short )*(pms->block + 0);
#line 244
    bpred[1] = (short )*(pms->block + 1);
#line 246
    if ((int )bpred[0] >= 7) {
      {
      {
#line 247
      psf_log_printf(psf, "MS ADPCM synchronisation error (%d %d).\n\230\001", (int )bpred[0],
                     (int )bpred[1]);
      }
      }
    } else
#line 246
    if ((int )bpred[1] >= 7) {
      {
      {
#line 247
      psf_log_printf(psf, "MS ADPCM synchronisation error (%d %d).\n\230\001", (int )bpred[0],
                     (int )bpred[1]);
      }
      }
    }
    {
#line 249
    chan_idelta[0] = (short )((int )*(pms->block + 2) | ((int )*(pms->block + 3) << 8));
#line 250
    chan_idelta[1] = (short )((int )*(pms->block + 4) | ((int )*(pms->block + 5) << 8));
#line 252
    psf_log_printf(psf, "(%d, %d) (%d, %d)\n", (int )bpred[0], (int )bpred[1], (int )chan_idelta[0],
                   (int )chan_idelta[1]);
#line 254
    *(pms->samples + 2) = (short )((int )*(pms->block + 6) | ((int )*(pms->block + 7) << 8));
#line 255
    *(pms->samples + 3) = (short )((int )*(pms->block + 8) | ((int )*(pms->block + 9) << 8));
#line 257
    *(pms->samples + 0) = (short )((int )*(pms->block + 10) | ((int )*(pms->block + 11) << 8));
#line 258
    *(pms->samples + 1) = (short )((int )*(pms->block + 12) | ((int )*(pms->block + 13) << 8));
#line 260
    blockindx = 14;
    }
  }
#line 278
  sampleindx = 2 * pms->channels;
  {
#line 279
  while (1) {
    while_continue: /* CIL Label */ ;
#line 279
    if (! (blockindx < pms->blocksize)) {
#line 279
      goto while_break;
    }
#line 280
    __cil_tmp15 = blockindx;
#line 280
    blockindx ++;
#line 280
    bytecode = (short )*(pms->block + __cil_tmp15);
#line 281
    __cil_tmp16 = sampleindx;
#line 281
    sampleindx ++;
#line 281
    *(pms->samples + __cil_tmp16) = (short )(((int )bytecode >> 4) & 15);
#line 282
    __cil_tmp17 = sampleindx;
#line 282
    sampleindx ++;
#line 282
    *(pms->samples + __cil_tmp17) = (short )((int )bytecode & 15);
  }
  while_break: /* CIL Label */ ;
  }
#line 287
  k = 2 * pms->channels;
  {
#line 287
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 287
    if (! (k < pms->samplesperblock * pms->channels)) {
#line 287
      goto while_break___0;
    }
#line 288
    if (pms->channels > 1) {
#line 288
      tmp = k % 2;
    } else {
#line 288
      tmp = 0;
    }
#line 288
    chan = tmp;
#line 290
    bytecode = (short )((int )*(pms->samples + k) & 15);
#line 293
    idelta = (int )chan_idelta[chan];
#line 294
    chan_idelta[chan] = (short )(AdaptationTable[bytecode] * idelta >> 8);
#line 295
    if ((int )chan_idelta[chan] < 16) {
#line 296
      chan_idelta[chan] = (short )16;
    }
#line 297
    if ((int )bytecode & 8) {
#line 298
      bytecode -= 16;
    }
#line 300
    predict = ((int )*(pms->samples + (k - pms->channels)) * AdaptCoeff1[bpred[chan]] + (int )*(pms->samples + (k - 2 * pms->channels)) * AdaptCoeff2[bpred[chan]]) >> 8;
#line 302
    current = (int )bytecode * idelta + predict;
#line 304
    if (current > 32767) {
#line 305
      current = 32767;
    } else
#line 306
    if (current < -32768) {
#line 307
      current = - 32768;
    }
#line 309
    *(pms->samples + k) = (short )current;
#line 287
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }

#line 312
  return (1);
}
}
#line 316 "/root/libsndfile/src/ms_adpcm.c"
static sf_count_t msadpcm_read_block(SF_PRIVATE *psf , MSADPCM_PRIVATE *pms , short *ptr ,
                                     int len ) 
{ 
  int count ;
  int total ;
  int indx ;
  int tmp ;

  {
#line 317
  total = 0;
#line 317
  indx = 0;
  {
#line 319
  while (1) {
    while_continue: /* CIL Label */ ;
#line 319
    if (! (indx < len)) {
#line 319
      goto while_break;
    }
#line 320
    if (pms->blockcount >= pms->blocks) {
#line 320
      if (pms->samplecount >= (long )pms->samplesperblock) {
        {
#line 321
        memset(ptr + indx, 0, (size_t )((unsigned long )(len - indx) * sizeof(short )));
        }
#line 322
        return ((sf_count_t )total);
      }
    }

#line 325
    if (pms->samplecount >= (long )pms->samplesperblock) {
      {
#line 326
      msadpcm_decode_block(psf, pms);
      }
    }
#line 328
    count = (int )(((long )pms->samplesperblock - pms->samplecount) * (long )pms->channels);
#line 329
    if (len - indx > count) {
#line 329
      tmp = count;
    } else {
#line 329
      tmp = len - indx;
    }
    {
#line 329
    count = tmp;
#line 331
    memcpy(ptr + indx, pms->samples + pms->samplecount * (long )pms->channels, (unsigned long )count * sizeof(short ));
#line 332
    indx += count;
#line 333
    pms->samplecount += (long )(count / pms->channels);
#line 334
    total = indx;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 337
  return ((sf_count_t )total);
}
}
#line 341 "/root/libsndfile/src/ms_adpcm.c"
static sf_count_t msadpcm_read_s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  MSADPCM_PRIVATE *pms ;
  int readcount ;
  int count ;
  sf_count_t total ;
  int tmp ;
  sf_count_t __cil_tmp9 ;

  {
#line 344
  total = (sf_count_t )0;
#line 346
  if (! psf->codec_data) {
#line 347
    return ((sf_count_t )0);
  }
#line 348
  pms = (MSADPCM_PRIVATE *)psf->codec_data;
  {
#line 350
  while (1) {
    while_continue: /* CIL Label */ ;
#line 350
    if (! (len > 0L)) {
#line 350
      goto while_break;
    }
#line 351
    if (len > 268435456L) {
#line 351
      tmp = 268435456;
    } else {
#line 351
      tmp = (int )len;
    }
    {
#line 351
    readcount = tmp;
#line 353
    __cil_tmp9 = msadpcm_read_block(psf, pms, ptr, readcount);
#line 353
    count = (int )__cil_tmp9;
#line 355
    total += (long )count;
#line 356
    len -= (long )count;
    }
#line 357
    if (count != readcount) {
#line 358
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 361
  return (total);
}
}
#line 365 "/root/libsndfile/src/ms_adpcm.c"
static sf_count_t msadpcm_read_i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  MSADPCM_PRIVATE *pms ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count ;
  sf_count_t total ;
  long tmp ;
  sf_count_t __cil_tmp12 ;
  int __cil_tmp13 ;

  {
#line 368
  readcount = 0;
#line 369
  total = (sf_count_t )0;
#line 371
  if (! psf->codec_data) {
#line 372
    return ((sf_count_t )0);
  }
#line 373
  pms = (MSADPCM_PRIVATE *)psf->codec_data;
#line 375
  sptr = (short *)psf->u.sbuf;
#line 376
  bufferlen = (int )(sizeof(psf->u.sbuf) / sizeof(psf->u.sbuf[0]));
  {
#line 377
  while (1) {
    while_continue: /* CIL Label */ ;
#line 377
    if (! (len > 0L)) {
#line 377
      goto while_break;
    }
#line 378
    if (len >= (long )bufferlen) {
#line 378
      tmp = (long )bufferlen;
    } else {
#line 378
      tmp = len;
    }
    {
#line 378
    readcount = (int )tmp;
#line 379
    __cil_tmp12 = msadpcm_read_block(psf, pms, sptr, readcount);
#line 379
    count = (int )__cil_tmp12;
#line 380
    k = 0;
    }
    {
#line 380
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 380
      if (! (k < readcount)) {
#line 380
        goto while_break___0;
      }
#line 381
      *(ptr + (total + (long )k)) = (int )*(sptr + k) << 16;
#line 380
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 382
    total += (long )count;
#line 383
    len -= (long )readcount;
#line 384
    if (count != readcount) {
#line 385
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 387
  return (total);
}
}
#line 391 "/root/libsndfile/src/ms_adpcm.c"
static sf_count_t msadpcm_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  MSADPCM_PRIVATE *pms ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  long tmp___0 ;
  sf_count_t __cil_tmp14 ;
  int __cil_tmp15 ;

  {
#line 394
  readcount = 0;
#line 395
  total = (sf_count_t )0;
#line 398
  if (! psf->codec_data) {
#line 399
    return ((sf_count_t )0);
  }
#line 400
  pms = (MSADPCM_PRIVATE *)psf->codec_data;
#line 402
  if (psf->norm_float == 1) {
#line 402
    tmp = 1. / (double )((float )32768);
  } else {
#line 402
    tmp = 1.;
  }
#line 402
  normfact = (float )tmp;
#line 403
  sptr = (short *)psf->u.sbuf;
#line 404
  bufferlen = (int )(sizeof(psf->u.sbuf) / sizeof(psf->u.sbuf[0]));
  {
#line 405
  while (1) {
    while_continue: /* CIL Label */ ;
#line 405
    if (! (len > 0L)) {
#line 405
      goto while_break;
    }
#line 406
    if (len >= (long )bufferlen) {
#line 406
      tmp___0 = (long )bufferlen;
    } else {
#line 406
      tmp___0 = len;
    }
    {
#line 406
    readcount = (int )tmp___0;
#line 407
    __cil_tmp14 = msadpcm_read_block(psf, pms, sptr, readcount);
#line 407
    count = (int )__cil_tmp14;
#line 408
    k = 0;
    }
    {
#line 408
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 408
      if (! (k < readcount)) {
#line 408
        goto while_break___0;
      }
#line 409
      *(ptr + (total + (long )k)) = normfact * (float )*(sptr + k);
#line 408
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 410
    total += (long )count;
#line 411
    len -= (long )readcount;
#line 412
    if (count != readcount) {
#line 413
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 415
  return (total);
}
}
#line 419 "/root/libsndfile/src/ms_adpcm.c"
static sf_count_t msadpcm_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  MSADPCM_PRIVATE *pms ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  long tmp___0 ;
  sf_count_t __cil_tmp14 ;
  int __cil_tmp15 ;

  {
#line 422
  readcount = 0;
#line 423
  total = (sf_count_t )0;
#line 426
  if (psf->norm_double == 1) {
#line 426
    tmp = 1. / (double )32768;
  } else {
#line 426
    tmp = 1.;
  }
#line 426
  normfact = tmp;
#line 428
  if (! psf->codec_data) {
#line 429
    return ((sf_count_t )0);
  }
#line 430
  pms = (MSADPCM_PRIVATE *)psf->codec_data;
#line 432
  sptr = (short *)psf->u.sbuf;
#line 433
  bufferlen = (int )(sizeof(psf->u.sbuf) / sizeof(psf->u.sbuf[0]));
  {
#line 434
  while (1) {
    while_continue: /* CIL Label */ ;
#line 434
    if (! (len > 0L)) {
#line 434
      goto while_break;
    }
#line 435
    if (len >= (long )bufferlen) {
#line 435
      tmp___0 = (long )bufferlen;
    } else {
#line 435
      tmp___0 = len;
    }
    {
#line 435
    readcount = (int )tmp___0;
#line 436
    __cil_tmp14 = msadpcm_read_block(psf, pms, sptr, readcount);
#line 436
    count = (int )__cil_tmp14;
#line 437
    k = 0;
    }
    {
#line 437
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 437
      if (! (k < readcount)) {
#line 437
        goto while_break___0;
      }
#line 438
      *(ptr + (total + (long )k)) = normfact * (double )*(sptr + k);
#line 437
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 439
    total += (long )count;
#line 440
    len -= (long )readcount;
#line 441
    if (count != readcount) {
#line 442
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 444
  return (total);
}
}
#line 448 "/root/libsndfile/src/ms_adpcm.c"
static sf_count_t msadpcm_seek(SF_PRIVATE *psf , int mode , sf_count_t offset ) 
{ 
  MSADPCM_PRIVATE *pms ;
  int newblock ;
  int newsample ;

  {
#line 452
  if (! psf->codec_data) {
#line 453
    return ((sf_count_t )0);
  }
#line 454
  pms = (MSADPCM_PRIVATE *)psf->codec_data;
#line 456
  if (psf->datalength < 0L) {
#line 457
    psf->error = 38;
#line 458
    return ((sf_count_t )(- 1));
  } else
#line 456
  if (psf->dataoffset < 0L) {
#line 457
    psf->error = 38;
#line 458
    return ((sf_count_t )(- 1));
  }

#line 461
  if (offset == 0L) {
    {
#line 462
    psf_fseek(psf, psf->dataoffset, 0);
#line 463
    pms->blockcount = 0;
#line 464
    msadpcm_decode_block(psf, pms);
#line 465
    pms->samplecount = (sf_count_t )0;
    }
#line 466
    return ((sf_count_t )0);
  }

#line 469
  if (offset < 0L) {
#line 470
    psf->error = 38;
#line 471
    return ((sf_count_t )(- 1));
  } else
#line 469
  if (offset > (long )(pms->blocks * pms->samplesperblock)) {
#line 470
    psf->error = 38;
#line 471
    return ((sf_count_t )(- 1));
  }
#line 474
  newblock = (int )(offset / (long )pms->samplesperblock);
#line 475
  newsample = (int )(offset % (long )pms->samplesperblock);
#line 477
  if (mode == 16) {
    {
#line 478
    psf_fseek(psf, psf->dataoffset + (long )(newblock * pms->blocksize), 0);
#line 479
    pms->blockcount = newblock;
#line 480
    msadpcm_decode_block(psf, pms);
#line 481
    pms->samplecount = (sf_count_t )newsample;
    }
  } else {
#line 485
    psf->error = 38;
#line 486
    return ((sf_count_t )(- 1));
  }

#line 489
  return ((sf_count_t )(newblock * pms->samplesperblock + newsample));
}
}
#line 497 "/root/libsndfile/src/ms_adpcm.c"
void msadpcm_write_adapt_coeffs(SF_PRIVATE *psf ) 
{ 
  int k ;
  int __cil_tmp3 ;

  {
#line 500
  k = 0;
  {
#line 500
  while (1) {
    while_continue: /* CIL Label */ ;
#line 500
    if (! (k < 7)) {
#line 500
      goto while_break;
    }
    {
#line 501
    psf_binheader_writef(psf, "22", AdaptCoeff1[k], AdaptCoeff2[k]);
    }
#line 500
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 508 "/root/libsndfile/src/ms_adpcm.c"
static int msadpcm_encode_block(SF_PRIVATE *psf , MSADPCM_PRIVATE *pms ) 
{ 
  unsigned int blockindx ;
  unsigned char byte ;
  int chan ;
  int k ;
  int predict ;
  int bpred[2] ;
  int idelta[2] ;
  int errordelta ;
  int newsamp ;
  unsigned int __cil_tmp12 ;
  int __cil_tmp13 ;
  unsigned int __cil_tmp14 ;
  int __cil_tmp15 ;
  sf_count_t __cil_tmp16 ;
  int __cil_tmp17 ;

  {
  {
#line 513
  choose_predictor((unsigned int )pms->channels, pms->samples, (int *)bpred, (int *)idelta);
  }
#line 517
  if (pms->channels == 1) {
#line 518
    *(pms->block + 0) = (unsigned char )bpred[0];
#line 519
    *(pms->block + 1) = (unsigned char )(idelta[0] & 255);
#line 520
    *(pms->block + 2) = (unsigned char )(idelta[0] >> 8);
#line 521
    *(pms->block + 3) = (unsigned char )((int )*(pms->samples + 1) & 255);
#line 522
    *(pms->block + 4) = (unsigned char )((int )*(pms->samples + 1) >> 8);
#line 523
    *(pms->block + 5) = (unsigned char )((int )*(pms->samples + 0) & 255);
#line 524
    *(pms->block + 6) = (unsigned char )((int )*(pms->samples + 0) >> 8);
#line 526
    blockindx = (unsigned int )7;
#line 527
    byte = (unsigned char )0;
#line 531
    k = 2;
    {
#line 531
    while (1) {
      while_continue: /* CIL Label */ ;
#line 531
      if (! (k < pms->samplesperblock)) {
#line 531
        goto while_break;
      }
#line 532
      predict = ((int )*(pms->samples + (k - 1)) * AdaptCoeff1[bpred[0]] + (int )*(pms->samples + (k - 2)) * AdaptCoeff2[bpred[0]]) >> 8;
#line 533
      errordelta = ((int )*(pms->samples + k) - predict) / idelta[0];
#line 534
      if (errordelta < -8) {
#line 535
        errordelta = - 8;
      } else
#line 536
      if (errordelta > 7) {
#line 537
        errordelta = 7;
      }
#line 538
      newsamp = predict + idelta[0] * errordelta;
#line 539
      if (newsamp > 32767) {
#line 540
        newsamp = 32767;
      } else
#line 541
      if (newsamp < -32768) {
#line 542
        newsamp = - 32768;
      }
#line 543
      if (errordelta < 0) {
#line 544
        errordelta += 16;
      }
#line 546
      byte = (unsigned char )(((int )byte << 4) | (errordelta & 15));
#line 547
      if (k % 2) {
#line 548
        __cil_tmp12 = blockindx;
#line 548
        blockindx ++;
#line 548
        *(pms->block + __cil_tmp12) = byte;
#line 549
        byte = (unsigned char )0;
      }
#line 552
      idelta[0] = idelta[0] * AdaptationTable[errordelta] >> 8;
#line 553
      if (idelta[0] < 16) {
#line 554
        idelta[0] = 16;
      }
#line 555
      *(pms->samples + k) = (short )newsamp;
#line 531
      k ++;
    }
    while_break: /* CIL Label */ ;
    }

  } else {
#line 560
    *(pms->block + 0) = (unsigned char )bpred[0];
#line 561
    *(pms->block + 1) = (unsigned char )bpred[1];
#line 563
    *(pms->block + 2) = (unsigned char )(idelta[0] & 255);
#line 564
    *(pms->block + 3) = (unsigned char )(idelta[0] >> 8);
#line 565
    *(pms->block + 4) = (unsigned char )(idelta[1] & 255);
#line 566
    *(pms->block + 5) = (unsigned char )(idelta[1] >> 8);
#line 568
    *(pms->block + 6) = (unsigned char )((int )*(pms->samples + 2) & 255);
#line 569
    *(pms->block + 7) = (unsigned char )((int )*(pms->samples + 2) >> 8);
#line 570
    *(pms->block + 8) = (unsigned char )((int )*(pms->samples + 3) & 255);
#line 571
    *(pms->block + 9) = (unsigned char )((int )*(pms->samples + 3) >> 8);
#line 573
    *(pms->block + 10) = (unsigned char )((int )*(pms->samples + 0) & 255);
#line 574
    *(pms->block + 11) = (unsigned char )((int )*(pms->samples + 0) >> 8);
#line 575
    *(pms->block + 12) = (unsigned char )((int )*(pms->samples + 1) & 255);
#line 576
    *(pms->block + 13) = (unsigned char )((int )*(pms->samples + 1) >> 8);
#line 578
    blockindx = (unsigned int )14;
#line 579
    byte = (unsigned char )0;
#line 580
    chan = 1;
#line 582
    k = 4;
    {
#line 582
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 582
      if (! (k < 2 * pms->samplesperblock)) {
#line 582
        goto while_break___0;
      }
#line 583
      chan = k & 1;
#line 585
      predict = ((int )*(pms->samples + (k - 2)) * AdaptCoeff1[bpred[chan]] + (int )*(pms->samples + (k - 4)) * AdaptCoeff2[bpred[chan]]) >> 8;
#line 586
      errordelta = ((int )*(pms->samples + k) - predict) / idelta[chan];
#line 589
      if (errordelta < -8) {
#line 590
        errordelta = - 8;
      } else
#line 591
      if (errordelta > 7) {
#line 592
        errordelta = 7;
      }
#line 593
      newsamp = predict + idelta[chan] * errordelta;
#line 594
      if (newsamp > 32767) {
#line 595
        newsamp = 32767;
      } else
#line 596
      if (newsamp < -32768) {
#line 597
        newsamp = - 32768;
      }
#line 598
      if (errordelta < 0) {
#line 599
        errordelta += 16;
      }
#line 601
      byte = (unsigned char )(((int )byte << 4) | (errordelta & 15));
#line 603
      if (chan) {
#line 604
        __cil_tmp14 = blockindx;
#line 604
        blockindx ++;
#line 604
        *(pms->block + __cil_tmp14) = byte;
#line 605
        byte = (unsigned char )0;
      }
#line 608
      idelta[chan] = idelta[chan] * AdaptationTable[errordelta] >> 8;
#line 609
      if (idelta[chan] < 16) {
#line 610
        idelta[chan] = 16;
      }
#line 611
      *(pms->samples + k) = (short )newsamp;
#line 582
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }

  }
  {
#line 617
  __cil_tmp16 = psf_fwrite(pms->block, (sf_count_t )1, (sf_count_t )pms->blocksize,
                           psf);
#line 617
  k = (int )__cil_tmp16;
  }
#line 617
  if (k != pms->blocksize) {
    {
#line 618
    psf_log_printf(psf, "*** Warning : short write (%d != %d).\n", k, pms->blocksize);
    }
  }
  {
#line 620
  memset(pms->samples, 0, (unsigned long )pms->samplesperblock * sizeof(short ));
#line 622
  (pms->blockcount) ++;
#line 623
  pms->samplecount = (sf_count_t )0;
  }
#line 625
  return (1);
}
}
#line 629 "/root/libsndfile/src/ms_adpcm.c"
static sf_count_t msadpcm_write_block(SF_PRIVATE *psf , MSADPCM_PRIVATE *pms , short const   *ptr ,
                                      int len ) 
{ 
  int count ;
  int total ;
  int indx ;

  {
#line 630
  total = 0;
#line 630
  indx = 0;
  {
#line 632
  while (1) {
    while_continue: /* CIL Label */ ;
#line 632
    if (! (indx < len)) {
#line 632
      goto while_break;
    }
#line 633
    count = (int )(((long )pms->samplesperblock - pms->samplecount) * (long )pms->channels);
#line 635
    if (count > len - indx) {
#line 636
      count = len - indx;
    }
    {
#line 638
    memcpy(pms->samples + pms->samplecount * (long )pms->channels, ptr + total, (unsigned long )count * sizeof(short ));
#line 639
    indx += count;
#line 640
    pms->samplecount += (long )(count / pms->channels);
#line 641
    total = indx;
    }
#line 643
    if (pms->samplecount >= (long )pms->samplesperblock) {
      {
#line 644
      msadpcm_encode_block(psf, pms);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 647
  return ((sf_count_t )total);
}
}
#line 651 "/root/libsndfile/src/ms_adpcm.c"
static sf_count_t msadpcm_write_s(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  MSADPCM_PRIVATE *pms ;
  int writecount ;
  int count ;
  sf_count_t total ;
  int tmp ;
  sf_count_t __cil_tmp9 ;

  {
#line 654
  total = (sf_count_t )0;
#line 656
  if (! psf->codec_data) {
#line 657
    return ((sf_count_t )0);
  }
#line 658
  pms = (MSADPCM_PRIVATE *)psf->codec_data;
  {
#line 660
  while (1) {
    while_continue: /* CIL Label */ ;
#line 660
    if (! (len > 0L)) {
#line 660
      goto while_break;
    }
#line 661
    if (len > 268435456L) {
#line 661
      tmp = 268435456;
    } else {
#line 661
      tmp = (int )len;
    }
    {
#line 661
    writecount = tmp;
#line 663
    __cil_tmp9 = msadpcm_write_block(psf, pms, ptr, writecount);
#line 663
    count = (int )__cil_tmp9;
#line 665
    total += (long )count;
#line 666
    len -= (long )count;
    }
#line 667
    if (count != writecount) {
#line 668
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 671
  return (total);
}
}
#line 675 "/root/libsndfile/src/ms_adpcm.c"
static sf_count_t msadpcm_write_i(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  MSADPCM_PRIVATE *pms ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count ;
  sf_count_t total ;
  long tmp ;
  int __cil_tmp12 ;
  sf_count_t __cil_tmp13 ;

  {
#line 679
  total = (sf_count_t )0;
#line 681
  if (! psf->codec_data) {
#line 682
    return ((sf_count_t )0);
  }
#line 683
  pms = (MSADPCM_PRIVATE *)psf->codec_data;
#line 685
  sptr = (short *)psf->u.sbuf;
#line 686
  bufferlen = (int )(sizeof(psf->u.sbuf) / sizeof(psf->u.sbuf[0]));
  {
#line 687
  while (1) {
    while_continue: /* CIL Label */ ;
#line 687
    if (! (len > 0L)) {
#line 687
      goto while_break;
    }
#line 688
    if (len >= (long )bufferlen) {
#line 688
      tmp = (long )bufferlen;
    } else {
#line 688
      tmp = len;
    }
#line 688
    writecount = (int )tmp;
#line 689
    k = 0;
    {
#line 689
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 689
      if (! (k < writecount)) {
#line 689
        goto while_break___0;
      }
#line 690
      *(sptr + k) = (short )(*(ptr + (total + (long )k)) >> 16);
#line 689
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 691
    __cil_tmp13 = msadpcm_write_block(psf, pms, (short const   *)sptr, writecount);
#line 691
    count = (int )__cil_tmp13;
#line 692
    total += (long )count;
#line 693
    len -= (long )writecount;
    }
#line 694
    if (count != writecount) {
#line 695
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 697
  return (total);
}
}
#line 701 "/root/libsndfile/src/ms_adpcm.c"
static sf_count_t msadpcm_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  MSADPCM_PRIVATE *pms ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  long tmp___0 ;
  long __cil_tmp14 ;
  int __cil_tmp15 ;
  sf_count_t __cil_tmp16 ;

  {
#line 705
  total = (sf_count_t )0;
#line 708
  if (! psf->codec_data) {
#line 709
    return ((sf_count_t )0);
  }
#line 710
  pms = (MSADPCM_PRIVATE *)psf->codec_data;
#line 712
  if (psf->norm_float == 1) {
#line 712
    tmp = 1. * (double )32767;
  } else {
#line 712
    tmp = 1.;
  }
#line 712
  normfact = (float )tmp;
#line 714
  sptr = (short *)psf->u.sbuf;
#line 715
  bufferlen = (int )(sizeof(psf->u.sbuf) / sizeof(psf->u.sbuf[0]));
  {
#line 716
  while (1) {
    while_continue: /* CIL Label */ ;
#line 716
    if (! (len > 0L)) {
#line 716
      goto while_break;
    }
#line 717
    if (len >= (long )bufferlen) {
#line 717
      tmp___0 = (long )bufferlen;
    } else {
#line 717
      tmp___0 = len;
    }
#line 717
    writecount = (int )tmp___0;
#line 718
    k = 0;
    {
#line 718
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 718
      if (! (k < writecount)) {
#line 718
        goto while_break___0;
      }
      {
#line 719
      __cil_tmp14 = lrintf(normfact * *(ptr + (total + (long )k)));
#line 719
      *(sptr + k) = (short )__cil_tmp14;
      }
#line 718
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 720
    __cil_tmp16 = msadpcm_write_block(psf, pms, (short const   *)sptr, writecount);
#line 720
    count = (int )__cil_tmp16;
#line 721
    total += (long )count;
#line 722
    len -= (long )writecount;
    }
#line 723
    if (count != writecount) {
#line 724
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 726
  return (total);
}
}
#line 730 "/root/libsndfile/src/ms_adpcm.c"
static sf_count_t msadpcm_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  MSADPCM_PRIVATE *pms ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  long tmp___0 ;
  long __cil_tmp14 ;
  int __cil_tmp15 ;
  sf_count_t __cil_tmp16 ;

  {
#line 734
  total = (sf_count_t )0;
#line 737
  if (psf->norm_double == 1) {
#line 737
    tmp = 1. * (double )32767;
  } else {
#line 737
    tmp = 1.;
  }
#line 737
  normfact = tmp;
#line 739
  if (! psf->codec_data) {
#line 740
    return ((sf_count_t )0);
  }
#line 741
  pms = (MSADPCM_PRIVATE *)psf->codec_data;
#line 743
  sptr = (short *)psf->u.sbuf;
#line 744
  bufferlen = (int )(sizeof(psf->u.sbuf) / sizeof(psf->u.sbuf[0]));
  {
#line 745
  while (1) {
    while_continue: /* CIL Label */ ;
#line 745
    if (! (len > 0L)) {
#line 745
      goto while_break;
    }
#line 746
    if (len >= (long )bufferlen) {
#line 746
      tmp___0 = (long )bufferlen;
    } else {
#line 746
      tmp___0 = len;
    }
#line 746
    writecount = (int )tmp___0;
#line 747
    k = 0;
    {
#line 747
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 747
      if (! (k < writecount)) {
#line 747
        goto while_break___0;
      }
      {
#line 748
      __cil_tmp14 = lrint(normfact * *(ptr + (total + (long )k)));
#line 748
      *(sptr + k) = (short )__cil_tmp14;
      }
#line 747
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 749
    __cil_tmp16 = msadpcm_write_block(psf, pms, (short const   *)sptr, writecount);
#line 749
    count = (int )__cil_tmp16;
#line 750
    total += (long )count;
#line 751
    len -= (long )writecount;
    }
#line 752
    if (count != writecount) {
#line 753
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 755
  return (total);
}
}
#line 762 "/root/libsndfile/src/ms_adpcm.c"
static int msadpcm_close(SF_PRIVATE *psf ) 
{ 
  MSADPCM_PRIVATE *pms ;

  {
#line 765
  pms = (MSADPCM_PRIVATE *)psf->codec_data;
#line 767
  if (psf->mode == 32) {
#line 772
    if (pms->samplecount) {
#line 772
      if (pms->samplecount < (long )pms->samplesperblock) {
        {
#line 773
        msadpcm_encode_block(psf, pms);
        }
      }
    }
  }

#line 776
  return (0);
}
}
#line 802 "/root/libsndfile/src/ms_adpcm.c"
static void choose_predictor(unsigned int channels , short *data___0 , int *block_pred ,
                             int *idelta ) 
{ 
  unsigned int chan ;
  unsigned int k ;
  unsigned int bpred ;
  unsigned int idelta_sum ;
  unsigned int best_bpred ;
  unsigned int best_idelta ;
  int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  unsigned int __cil_tmp14 ;

  {
#line 805
  chan = (unsigned int )0;
  {
#line 805
  while (1) {
    while_continue: /* CIL Label */ ;
#line 805
    if (! (chan < channels)) {
#line 805
      goto while_break;
    }
#line 806
    best_idelta = (unsigned int )0;
#line 806
    best_bpred = best_idelta;
#line 808
    bpred = (unsigned int )0;
    {
#line 808
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 808
      if (! (bpred < 7U)) {
#line 808
        goto while_break___0;
      }
#line 809
      idelta_sum = (unsigned int )0;
#line 810
      k = (unsigned int )2;
      {
#line 810
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 810
        if (! (k < 5U)) {
#line 810
          goto while_break___1;
        }
        {
#line 811
        __cil_tmp11 = abs((int )*(data___0 + k * channels) - (((int )*(data___0 + (k - 1U) * channels) * AdaptCoeff1[bpred] + (int )*(data___0 + (k - 2U) * channels) * AdaptCoeff2[bpred]) >> 8));
        }
#line 811
        idelta_sum += (unsigned int )__cil_tmp11;
#line 810
        k ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 812
      idelta_sum /= (unsigned int )12;
#line 814
      if (bpred == 0U) {
#line 815
        best_bpred = bpred;
#line 816
        best_idelta = idelta_sum;
      } else
#line 814
      if (idelta_sum < best_idelta) {
#line 815
        best_bpred = bpred;
#line 816
        best_idelta = idelta_sum;
      }

#line 819
      if (! idelta_sum) {
#line 820
        best_bpred = bpred;
#line 821
        best_idelta = (unsigned int )16;
#line 822
        goto while_break___0;
      }

#line 808
      bpred ++;
    }
    while_break___0: /* CIL Label */ ;
    }

#line 826
    if (best_idelta < 16U) {
#line 827
      best_idelta = (unsigned int )16;
    }
#line 829
    *(block_pred + chan) = (int )best_bpred;
#line 830
    *(idelta + chan) = (int )best_idelta;
#line 805
    chan ++;
  }
  while_break: /* CIL Label */ ;
  }

#line 833
  return;
}
}
#line 42 "/root/libsndfile/src/interleave.c"
static sf_count_t interleave_read_short(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 43
static sf_count_t interleave_read_int(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 44
static sf_count_t interleave_read_float(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 45
static sf_count_t interleave_read_double(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 47
static sf_count_t interleave_seek(SF_PRIVATE *psf , int mode , sf_count_t samples_from_start ) ;
#line 53 "/root/libsndfile/src/interleave.c"
int interleave_init(SF_PRIVATE *psf ) 
{ 
  INTERLEAVE_DATA *pdata ;
  void *__cil_tmp3 ;

  {
#line 56
  if (psf->mode != 16) {
#line 57
    return (35);
  }
#line 59
  if (psf->interleave) {
    {
#line 60
    psf_log_printf(psf, "*** Weird, already have interleave.\n");
    }
#line 61
    return (666);
  }
  {
#line 65
  pdata = (INTERLEAVE_DATA *)malloc(sizeof(INTERLEAVE_DATA ));
  }
#line 65
  if (! pdata) {
#line 66
    return (16);
  }
  {
#line 68
  puts("interleave_init");
#line 70
  psf->interleave = pdata;
#line 73
  pdata->read_short = psf->read_short;
#line 74
  pdata->read_int = psf->read_int;
#line 75
  pdata->read_float = psf->read_float;
#line 76
  pdata->read_double = psf->read_double;
#line 78
  pdata->channel_len = psf->sf.frames * (long )psf->bytewidth;
#line 81
  psf->read_short = & interleave_read_short;
#line 82
  psf->read_int = & interleave_read_int;
#line 83
  psf->read_float = & interleave_read_float;
#line 84
  psf->read_double = & interleave_read_double;
#line 86
  psf->seek = & interleave_seek;
  }
#line 88
  return (0);
}
}
#line 95 "/root/libsndfile/src/interleave.c"
static sf_count_t interleave_read_short(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  INTERLEAVE_DATA *pdata ;
  sf_count_t offset ;
  sf_count_t templen ;
  int chan ;
  int count ;
  int k ;
  short *inptr ;
  short *outptr ;
  sf_count_t __cil_tmp12 ;
  sf_count_t __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;

  {
#line 101
  pdata = psf->interleave;
#line 101
  if (! pdata) {
#line 102
    return ((sf_count_t )0);
  }
#line 104
  inptr = (short *)((double *)pdata->buffer);
#line 106
  chan = 0;
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 106
    if (! (chan < psf->sf.channels)) {
#line 106
      goto while_break;
    }
    {
#line 107
    outptr = ptr + chan;
#line 109
    offset = psf->dataoffset + (long )(chan * psf->bytewidth) * psf->read_current;
#line 111
    __cil_tmp12 = psf_fseek(psf, offset, 0);
    }
#line 111
    if (__cil_tmp12 != offset) {
#line 112
      psf->error = 36;
#line 113
      return ((sf_count_t )0);
    }
#line 116
    templen = len / (long )psf->sf.channels;
    {
#line 118
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 118
      if (! (templen > 0L)) {
#line 118
        goto while_break___0;
      }
#line 119
      if (templen > (long )((int )sizeof(pdata->buffer) / (int )sizeof(short ))) {
#line 120
        count = (int )sizeof(pdata->buffer) / (int )sizeof(short );
      } else {
#line 122
        count = (int )templen;
      }
      {
#line 124
      __cil_tmp13 = (*(pdata->read_short))(psf, inptr, (sf_count_t )count);
      }
#line 124
      if (__cil_tmp13 != (long )count) {
#line 125
        psf->error = 37;
#line 126
        return ((sf_count_t )0);
      }
#line 129
      k = 0;
      {
#line 129
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 129
        if (! (k < count)) {
#line 129
          goto while_break___1;
        }
#line 130
        *outptr = *(inptr + k);
#line 131
        outptr += psf->sf.channels;
#line 129
        k ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 134
      templen -= (long )count;
    }
    while_break___0: /* CIL Label */ ;
    }

#line 106
    chan ++;
  }
  while_break: /* CIL Label */ ;
  }

#line 138
  return (len);
}
}
#line 142 "/root/libsndfile/src/interleave.c"
static sf_count_t interleave_read_int(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  INTERLEAVE_DATA *pdata ;
  sf_count_t offset ;
  sf_count_t templen ;
  int chan ;
  int count ;
  int k ;
  int *inptr ;
  int *outptr ;
  sf_count_t __cil_tmp12 ;
  sf_count_t __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;

  {
#line 148
  pdata = psf->interleave;
#line 148
  if (! pdata) {
#line 149
    return ((sf_count_t )0);
  }
#line 151
  inptr = (int *)((double *)pdata->buffer);
#line 153
  chan = 0;
  {
#line 153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 153
    if (! (chan < psf->sf.channels)) {
#line 153
      goto while_break;
    }
    {
#line 154
    outptr = ptr + chan;
#line 156
    offset = psf->dataoffset + (long )(chan * psf->bytewidth) * psf->read_current;
#line 158
    __cil_tmp12 = psf_fseek(psf, offset, 0);
    }
#line 158
    if (__cil_tmp12 != offset) {
#line 159
      psf->error = 36;
#line 160
      return ((sf_count_t )0);
    }
#line 163
    templen = len / (long )psf->sf.channels;
    {
#line 165
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 165
      if (! (templen > 0L)) {
#line 165
        goto while_break___0;
      }
#line 166
      if (templen > (long )((int )sizeof(pdata->buffer) / (int )sizeof(int ))) {
#line 167
        count = (int )sizeof(pdata->buffer) / (int )sizeof(int );
      } else {
#line 169
        count = (int )templen;
      }
      {
#line 171
      __cil_tmp13 = (*(pdata->read_int))(psf, inptr, (sf_count_t )count);
      }
#line 171
      if (__cil_tmp13 != (long )count) {
#line 172
        psf->error = 37;
#line 173
        return ((sf_count_t )0);
      }
#line 176
      k = 0;
      {
#line 176
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 176
        if (! (k < count)) {
#line 176
          goto while_break___1;
        }
#line 177
        *outptr = *(inptr + k);
#line 178
        outptr += psf->sf.channels;
#line 176
        k ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 181
      templen -= (long )count;
    }
    while_break___0: /* CIL Label */ ;
    }

#line 153
    chan ++;
  }
  while_break: /* CIL Label */ ;
  }

#line 185
  return (len);
}
}
#line 189 "/root/libsndfile/src/interleave.c"
static sf_count_t interleave_read_float(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  INTERLEAVE_DATA *pdata ;
  sf_count_t offset ;
  sf_count_t templen ;
  int chan ;
  int count ;
  int k ;
  float *inptr ;
  float *outptr ;
  sf_count_t __cil_tmp12 ;
  sf_count_t __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;

  {
#line 195
  pdata = psf->interleave;
#line 195
  if (! pdata) {
#line 196
    return ((sf_count_t )0);
  }
#line 198
  inptr = (float *)((double *)pdata->buffer);
#line 200
  chan = 0;
  {
#line 200
  while (1) {
    while_continue: /* CIL Label */ ;
#line 200
    if (! (chan < psf->sf.channels)) {
#line 200
      goto while_break;
    }
    {
#line 201
    outptr = ptr + chan;
#line 203
    offset = (psf->dataoffset + pdata->channel_len * (long )chan) + psf->read_current * (long )psf->bytewidth;
#line 207
    __cil_tmp12 = psf_fseek(psf, offset, 0);
    }
#line 207
    if (__cil_tmp12 != offset) {
#line 208
      psf->error = 36;
#line 210
      return ((sf_count_t )0);
    }
#line 213
    templen = len / (long )psf->sf.channels;
    {
#line 215
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 215
      if (! (templen > 0L)) {
#line 215
        goto while_break___0;
      }
#line 216
      if (templen > (long )((int )sizeof(pdata->buffer) / (int )sizeof(float ))) {
#line 217
        count = (int )sizeof(pdata->buffer) / (int )sizeof(float );
      } else {
#line 219
        count = (int )templen;
      }
      {
#line 221
      __cil_tmp13 = (*(pdata->read_float))(psf, inptr, (sf_count_t )count);
      }
#line 221
      if (__cil_tmp13 != (long )count) {
#line 222
        psf->error = 37;
#line 224
        return ((sf_count_t )0);
      }
#line 227
      k = 0;
      {
#line 227
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 227
        if (! (k < count)) {
#line 227
          goto while_break___1;
        }
#line 228
        *outptr = *(inptr + k);
#line 229
        outptr += psf->sf.channels;
#line 227
        k ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 232
      templen -= (long )count;
    }
    while_break___0: /* CIL Label */ ;
    }

#line 200
    chan ++;
  }
  while_break: /* CIL Label */ ;
  }

#line 236
  return (len);
}
}
#line 240 "/root/libsndfile/src/interleave.c"
static sf_count_t interleave_read_double(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  INTERLEAVE_DATA *pdata ;
  sf_count_t offset ;
  sf_count_t templen ;
  int chan ;
  int count ;
  int k ;
  double *inptr ;
  double *outptr ;
  sf_count_t __cil_tmp12 ;
  sf_count_t __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;

  {
#line 246
  pdata = psf->interleave;
#line 246
  if (! pdata) {
#line 247
    return ((sf_count_t )0);
  }
#line 249
  inptr = (double *)((double *)pdata->buffer);
#line 251
  chan = 0;
  {
#line 251
  while (1) {
    while_continue: /* CIL Label */ ;
#line 251
    if (! (chan < psf->sf.channels)) {
#line 251
      goto while_break;
    }
    {
#line 252
    outptr = ptr + chan;
#line 254
    offset = psf->dataoffset + (long )(chan * psf->bytewidth) * psf->read_current;
#line 256
    __cil_tmp12 = psf_fseek(psf, offset, 0);
    }
#line 256
    if (__cil_tmp12 != offset) {
#line 257
      psf->error = 36;
#line 258
      return ((sf_count_t )0);
    }
#line 261
    templen = len / (long )psf->sf.channels;
    {
#line 263
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 263
      if (! (templen > 0L)) {
#line 263
        goto while_break___0;
      }
#line 264
      if (templen > (long )((int )sizeof(pdata->buffer) / (int )sizeof(double ))) {
#line 265
        count = (int )sizeof(pdata->buffer) / (int )sizeof(double );
      } else {
#line 267
        count = (int )templen;
      }
      {
#line 269
      __cil_tmp13 = (*(pdata->read_double))(psf, inptr, (sf_count_t )count);
      }
#line 269
      if (__cil_tmp13 != (long )count) {
#line 270
        psf->error = 37;
#line 271
        return ((sf_count_t )0);
      }
#line 274
      k = 0;
      {
#line 274
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 274
        if (! (k < count)) {
#line 274
          goto while_break___1;
        }
#line 275
        *outptr = *(inptr + k);
#line 276
        outptr += psf->sf.channels;
#line 274
        k ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 279
      templen -= (long )count;
    }
    while_break___0: /* CIL Label */ ;
    }

#line 251
    chan ++;
  }
  while_break: /* CIL Label */ ;
  }

#line 283
  return (len);
}
}
#line 290 "/root/libsndfile/src/interleave.c"
static sf_count_t interleave_seek(SF_PRIVATE *psf , int mode , sf_count_t samples_from_start ) 
{ 


  {
#line 291
  psf = psf;
#line 291
  mode = mode;
#line 298
  return (samples_from_start);
}
}
#line 32 "/root/libsndfile/src/ima_oki_adpcm.c"
static int const   ima_steps[89]  = 
#line 32 "/root/libsndfile/src/ima_oki_adpcm.c"
  {      7,      8,      9,      10, 
        11,      12,      13,      14, 
        16,      17,      19,      21, 
        23,      25,      28,      31, 
        34,      37,      41,      45, 
        50,      55,      60,      66, 
        73,      80,      88,      97, 
        107,      118,      130,      143, 
        157,      173,      190,      209, 
        230,      253,      279,      307, 
        337,      371,      408,      449, 
        494,      544,      598,      658, 
        724,      796,      876,      963, 
        1060,      1166,      1282,      1411, 
        1552,      1707,      1878,      2066, 
        2272,      2499,      2749,      3024, 
        3327,      3660,      4026,      4428, 
        4871,      5358,      5894,      6484, 
        7132,      7845,      8630,      9493, 
        10442,      11487,      12635,      13899, 
        15289,      16818,      18500,      20350, 
        22385,      24623,      27086,      29794, 
        32767};
#line 42 "/root/libsndfile/src/ima_oki_adpcm.c"
static int const   oki_steps[49]  = 
#line 42
  {      256,      272,      304,      336, 
        368,      400,      448,      496, 
        544,      592,      656,      720, 
        800,      880,      960,      1056, 
        1168,      1280,      1408,      1552, 
        1712,      1888,      2080,      2288, 
        2512,      2768,      3040,      3344, 
        3680,      4048,      4464,      4912, 
        5392,      5936,      6528,      7184, 
        7904,      8704,      9568,      10528, 
        11584,      12736,      14016,      15408, 
        16960,      18656,      20512,      22576, 
        24832};
#line 49 "/root/libsndfile/src/ima_oki_adpcm.c"
static int const   step_changes[8]  = 
#line 49
  {      - 1,      - 1,      - 1,      - 1, 
        2,      4,      6,      8};
#line 52 "/root/libsndfile/src/ima_oki_adpcm.c"
void ima_oki_adpcm_init(IMA_OKI_ADPCM *state , IMA_OKI_ADPCM_TYPE type ) 
{ 


  {
  {
#line 54
  memset(state, 0, sizeof(*state));
  }
#line 56
  if ((unsigned int )type == 0U) {
#line 57
    state->max_step_index = (int )(sizeof(ima_steps) / sizeof(ima_steps[0])) - 1;
#line 58
    state->steps = (int const   *)ima_steps;
#line 59
    state->mask = ~ 0;
  } else {
#line 62
    state->max_step_index = (int )(sizeof(oki_steps) / sizeof(oki_steps[0])) - 1;
#line 63
    state->steps = (int const   *)oki_steps;
#line 64
    state->mask = -1 << 4;
  }

  return;
}
}
#line 71 "/root/libsndfile/src/ima_oki_adpcm.c"
int adpcm_decode(IMA_OKI_ADPCM *state , int code ) 
{ 
  int s ;
  int grace ;
  int __cil_tmp5 ;
  int tmp ;

  {
#line 74
  s = ((code & 7) << 1) | 1;
#line 75
  s = (*(state->steps + state->step_index) * s >> 3) & state->mask;
#line 77
  if (code & 8) {
#line 78
    s = - s;
  }
#line 79
  s += state->last_output;
#line 81
  if (s < -32768) {
    _L: /* CIL Label */ 
#line 84
    grace = (*(state->steps + state->step_index) >> 3) & state->mask;
#line 86
    if (s < -32768 - grace) {
#line 87
      (state->errors) ++;
    } else
#line 86
    if (s > 32767 + grace) {
#line 87
      (state->errors) ++;
    }
#line 89
    if (s < -32768) {
#line 89
      tmp = - 32768;
    } else {
#line 89
      tmp = 32767;
    }
#line 89
    s = tmp;
  } else
#line 81
  if (s > 32767) {
#line 81
    goto _L;
  }
#line 92
  state->step_index += step_changes[code & 7];
#line 93
  state->step_index = 0;
#line 94
  state->last_output = s;
#line 96
  return (s);
}
}
#line 100 "/root/libsndfile/src/ima_oki_adpcm.c"
int adpcm_encode(IMA_OKI_ADPCM *state , int sample ) 
{ 
  int delta ;
  int sign ;
  int code ;

  {
#line 101
  sign = 0;
#line 103
  delta = sample - state->last_output;
#line 105
  if (delta < 0) {
#line 106
    sign = 8;
#line 107
    delta = - delta;
  }
  {
#line 110
  code = (4 * delta) / *(state->steps + state->step_index);
#line 111
  code = sign;
#line 112
  adpcm_decode(state, code);
  }
#line 114
  return (code);
}
}
#line 119 "/root/libsndfile/src/ima_oki_adpcm.c"
void ima_oki_adpcm_decode_block(IMA_OKI_ADPCM *state ) 
{ 
  unsigned char code ;
  int k ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 123
  k = 0;
  {
#line 123
  while (1) {
    while_continue: /* CIL Label */ ;
#line 123
    if (! (k < state->code_count)) {
#line 123
      goto while_break;
    }
    {
#line 124
    code = state->codes[k];
#line 125
    __cil_tmp4 = adpcm_decode(state, (int )code >> 4);
#line 125
    state->pcm[2 * k] = (short )__cil_tmp4;
#line 126
    __cil_tmp5 = adpcm_decode(state, (int )code);
#line 126
    state->pcm[2 * k + 1] = (short )__cil_tmp5;
    }
#line 123
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 129
  state->pcm_count = 2 * k;
  return;
}
}
#line 134 "/root/libsndfile/src/ima_oki_adpcm.c"
void ima_oki_adpcm_encode_block(IMA_OKI_ADPCM *state ) 
{ 
  unsigned char code ;
  int k ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 144
  if (state->pcm_count % 2 == 1) {
#line 145
    __cil_tmp4 = state->pcm_count;
#line 145
    (state->pcm_count) ++;
#line 145
    state->pcm[__cil_tmp4] = (short )0;
  }
#line 147
  k = 0;
  {
#line 147
  while (1) {
    while_continue: /* CIL Label */ ;
#line 147
    if (! (k < state->pcm_count / 2)) {
#line 147
      goto while_break;
    }
    {
#line 148
    __cil_tmp5 = adpcm_encode(state, (int )state->pcm[2 * k]);
#line 148
    code = (unsigned char )(__cil_tmp5 << 4);
#line 149
    __cil_tmp6 = adpcm_encode(state, (int )state->pcm[2 * k + 1]);
    }
#line 149
    code |= __cil_tmp6;
#line 150
    state->codes[k] = code;
#line 147
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 153
  state->code_count = k;
  return;
}
}
#line 51 "/root/libsndfile/src/ima_adpcm.c"
static int ima_indx_adjust[16]  = 
#line 51 "/root/libsndfile/src/ima_adpcm.c"
  {      - 1,      - 1,      - 1,      - 1, 
        2,      4,      6,      8, 
        - 1,      - 1,      - 1,      - 1, 
        2,      4,      6,      8};
#line 58 "/root/libsndfile/src/ima_adpcm.c"
static int ima_step_size[89]  = 
#line 58
  {      7,      8,      9,      10, 
        11,      12,      13,      14, 
        16,      17,      19,      21, 
        23,      25,      28,      31, 
        34,      37,      41,      45, 
        50,      55,      60,      66, 
        73,      80,      88,      97, 
        107,      118,      130,      143, 
        157,      173,      190,      209, 
        230,      253,      279,      307, 
        337,      371,      408,      449, 
        494,      544,      598,      658, 
        724,      796,      876,      963, 
        1060,      1166,      1282,      1411, 
        1552,      1707,      1878,      2066, 
        2272,      2499,      2749,      3024, 
        3327,      3660,      4026,      4428, 
        4871,      5358,      5894,      6484, 
        7132,      7845,      8630,      9493, 
        10442,      11487,      12635,      13899, 
        15289,      16818,      18500,      20350, 
        22385,      24623,      27086,      29794, 
        32767};
#line 68
static int ima_reader_init(SF_PRIVATE *psf , int blockalign , int samplesperblock ) ;
#line 69
static int ima_writer_init(SF_PRIVATE *psf , int blockalign ) ;
#line 71
static int ima_read_block(SF_PRIVATE *psf , IMA_ADPCM_PRIVATE *pima , short *ptr ,
                          int len ) ;
#line 72
static int ima_write_block(SF_PRIVATE *psf , IMA_ADPCM_PRIVATE *pima , short const   *ptr ,
                           int len ) ;
#line 74
static sf_count_t ima_read_s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 75
static sf_count_t ima_read_i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 76
static sf_count_t ima_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 77
static sf_count_t ima_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 79
static sf_count_t ima_write_s(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 80
static sf_count_t ima_write_i(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 81
static sf_count_t ima_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 82
static sf_count_t ima_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 84
static sf_count_t ima_seek(SF_PRIVATE *psf , int mode , sf_count_t offset ) ;
#line 86
static int ima_close(SF_PRIVATE *psf ) ;
#line 88
static int wav_w64_ima_decode_block(SF_PRIVATE *psf , IMA_ADPCM_PRIVATE *pima ) ;
#line 89
static int wav_w64_ima_encode_block(SF_PRIVATE *psf , IMA_ADPCM_PRIVATE *pima ) ;
#line 92
static int aiff_ima_decode_block(SF_PRIVATE *psf , IMA_ADPCM_PRIVATE *pima ) ;
#line 93
static int aiff_ima_encode_block(SF_PRIVATE *psf , IMA_ADPCM_PRIVATE *pima ) ;
#line 97 "/root/libsndfile/src/ima_adpcm.c"
__inline static int clamp_ima_step_index(int indx ) 
{ 


  {
#line 98
  if (indx < 0) {
#line 99
    return (0);
  }
#line 100
  if (indx >= (int )(sizeof(ima_step_size) / sizeof(ima_step_size[0]))) {
#line 101
    return ((int )(sizeof(ima_step_size) / sizeof(ima_step_size[0])) - 1);
  }
#line 103
  return (indx);
}
}
#line 111 "/root/libsndfile/src/ima_adpcm.c"
int wav_w64_ima_init(SF_PRIVATE *psf , int blockalign , int samplesperblock ) 
{ 
  int error ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 114
  if (psf->codec_data != (void *)0) {
    {
#line 115
    psf_log_printf(psf, "*** psf->codec_data is not NULL.\n\302]\371\036V");
    }
#line 116
    return (29);
  }

#line 119
  if (psf->mode == 48) {
#line 120
    return (23);
  }
#line 122
  if (psf->mode == 16) {
    {
#line 123
    error = ima_reader_init(psf, blockalign, samplesperblock);
    }
#line 123
    if (error) {
#line 124
      return (error);
    }
  }
#line 126
  if (psf->mode == 32) {
    {
#line 127
    error = ima_writer_init(psf, blockalign);
    }
#line 127
    if (error) {
#line 128
      return (error);
    }
  }
#line 130
  psf->codec_close = & ima_close;
#line 131
  psf->seek = & ima_seek;
#line 133
  return (0);
}
}
#line 137 "/root/libsndfile/src/ima_adpcm.c"
int aiff_ima_init(SF_PRIVATE *psf , int blockalign , int samplesperblock ) 
{ 
  int error ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 140
  if (psf->mode == 48) {
#line 141
    return (23);
  }
#line 143
  if (psf->mode == 16) {
    {
#line 144
    error = ima_reader_init(psf, blockalign, samplesperblock);
    }
#line 144
    if (error) {
#line 145
      return (error);
    }
  }
#line 147
  if (psf->mode == 32) {
    {
#line 148
    error = ima_writer_init(psf, blockalign);
    }
#line 148
    if (error) {
#line 149
      return (error);
    }
  }
#line 151
  psf->codec_close = & ima_close;
#line 153
  return (0);
}
}
#line 157 "/root/libsndfile/src/ima_adpcm.c"
static int ima_close(SF_PRIVATE *psf ) 
{ 
  IMA_ADPCM_PRIVATE *pima ;

  {
#line 160
  pima = (IMA_ADPCM_PRIVATE *)psf->codec_data;
#line 162
  if (psf->mode == 32) {
#line 166
    if (pima->samplecount) {
#line 166
      if (pima->samplecount < pima->samplesperblock) {
        {
#line 167
        (*(pima->encode_block))(psf, pima);
        }
      }
    }
#line 169
    psf->sf.frames = (sf_count_t )((pima->samplesperblock * pima->blockcount) / psf->sf.channels);
  }

#line 172
  return (0);
}
}
#line 180 "/root/libsndfile/src/ima_adpcm.c"
static int ima_reader_init(SF_PRIVATE *psf , int blockalign , int samplesperblock ) 
{ 
  IMA_ADPCM_PRIVATE *pima ;
  int pimasize ;
  int count ;
  void *__cil_tmp7 ;
  sf_count_t __cil_tmp8 ;
  sf_count_t tmp ;

  {
#line 184
  if (psf->mode != 16) {
#line 185
    return (23);
  }
  {
#line 187
  pimasize = (int )((sizeof(IMA_ADPCM_PRIVATE ) + (unsigned long )(blockalign * psf->sf.channels)) + (unsigned long )((3 * psf->sf.channels) * samplesperblock));
#line 189
  pima = (IMA_ADPCM_PRIVATE *)malloc((unsigned long )pimasize);
  }
#line 189
  if (! pima) {
#line 190
    return (16);
  }
  {
#line 192
  psf->codec_data = (void *)pima;
#line 194
  memset(pima, 0, (unsigned long )pimasize);
#line 196
  pima->samples = (short *)pima->data;
#line 197
  pima->block = (unsigned char *)((short *)pima->data + samplesperblock * psf->sf.channels);
#line 199
  pima->channels = psf->sf.channels;
#line 200
  pima->blocksize = blockalign;
#line 201
  pima->samplesperblock = samplesperblock;
#line 203
  psf->filelength = psf_get_filelen(psf);
  }
#line 204
  if (psf->dataend) {
#line 204
    tmp = psf->dataend - psf->dataoffset;
  } else {
#line 204
    tmp = psf->filelength - psf->dataoffset;
  }
#line 204
  psf->datalength = tmp;
#line 207
  if (pima->blocksize == 0) {
    {
#line 208
    psf_log_printf(psf, "*** Error : pima->blocksize should not be zero.\n\220");
    }
#line 209
    return (29);
  }

#line 212
  if (psf->datalength % (long )pima->blocksize) {
#line 213
    pima->blocks = (int )(psf->datalength / (long )pima->blocksize + 1L);
  } else {
#line 215
    pima->blocks = (int )(psf->datalength / (long )pima->blocksize);
  }
  {
#line 219
  if ((psf->sf.format & 268369920) == 720896) {
#line 219
    goto case_720896;
  }
#line 219
  if ((psf->sf.format & 268369920) == 65536) {
#line 219
    goto case_720896;
  }
#line 232
  if ((psf->sf.format & 268369920) == 131072) {
#line 232
    goto case_131072;
  }
#line 238
  goto switch_default;
  case_720896: /* CIL Label */ 
  case_65536: /* CIL Label */ 
#line 220
  count = (2 * (pima->blocksize - 4 * pima->channels)) / pima->channels + 1;
#line 222
  if (pima->samplesperblock != count) {
    {
#line 223
    psf_log_printf(psf, "*** Error : samplesperblock should be %d.\n", count);
    }
#line 224
    return (29);
  }
#line 227
  pima->decode_block = & wav_w64_ima_decode_block;
#line 229
  psf->sf.frames = (sf_count_t )(pima->samplesperblock * pima->blocks);
#line 230
  goto switch_break;
  case_131072: /* CIL Label */ 
  {
#line 233
  psf_log_printf(psf, "still need to check block count\n\220");
  }
#line 234
  pima->decode_block = & aiff_ima_decode_block;
#line 235
  psf->sf.frames = (sf_count_t )((pima->samplesperblock * pima->blocks) / pima->channels);
#line 236
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 239
  psf_log_printf(psf, "ima_reader_init: bad psf->sf.format\n");
  }
#line 240
  return (29);
  switch_break: /* CIL Label */ ;
  }
  {
#line 243
  (*(pima->decode_block))(psf, pima);
#line 245
  psf->read_short = & ima_read_s;
#line 246
  psf->read_int = & ima_read_i;
#line 247
  psf->read_float = & ima_read_f;
#line 248
  psf->read_double = & ima_read_d;
  }
#line 250
  return (0);
}
}
#line 254 "/root/libsndfile/src/ima_adpcm.c"
static int aiff_ima_decode_block(SF_PRIVATE *psf , IMA_ADPCM_PRIVATE *pima ) 
{ 
  unsigned char *blockdata ;
  int chan ;
  int k ;
  int diff ;
  int bytecode ;
  short step ;
  short stepindx ;
  short predictor ;
  short *sampledata ;
  static int count ;
  int __cil_tmp13 ;
  sf_count_t __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;

  {
#line 259
  count = 0;
#line 260
  count ++;
#line 262
  pima->blockcount += pima->channels;
#line 263
  pima->samplecount = 0;
#line 265
  if (pima->blockcount > pima->blocks) {
    {
#line 266
    memset(pima->samples, 0, (unsigned long )(pima->samplesperblock * pima->channels) * sizeof(short ));
    }
#line 267
    return (1);
  }
  {
#line 270
  __cil_tmp14 = psf_fread(pima->block, (sf_count_t )1, (sf_count_t )(pima->blocksize * pima->channels),
                          psf);
#line 270
  k = (int )__cil_tmp14;
  }
#line 270
  if (k != pima->blocksize * pima->channels) {
    {
#line 271
    psf_log_printf(psf, "*** Warning : short read (%d != %d).\nV", k, pima->blocksize);
    }
  }
#line 274
  chan = 0;
  {
#line 274
  while (1) {
    while_continue: /* CIL Label */ ;
#line 274
    if (! (chan < pima->channels)) {
#line 274
      goto while_break;
    }
    {
#line 275
    blockdata = pima->block + chan * 34;
#line 276
    sampledata = pima->samples + chan;
#line 278
    predictor = (short )(((int )*(blockdata + 0) << 8) | ((int )*(blockdata + 1) & 128));
#line 280
    stepindx = (short )((int )*(blockdata + 1) & 127);
#line 281
    __cil_tmp15 = clamp_ima_step_index((int )stepindx);
#line 281
    stepindx = (short )__cil_tmp15;
#line 287
    k = 0;
    }
    {
#line 287
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 287
      if (! (k < pima->blocksize - 2)) {
#line 287
        goto while_break___0;
      }
#line 288
      bytecode = (int )*(blockdata + (k + 2));
#line 289
      *(sampledata + pima->channels * (2 * k)) = (short )(bytecode & 15);
#line 290
      *(sampledata + pima->channels * (2 * k + 1)) = (short )((bytecode >> 4) & 15);
#line 287
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 294
    k = 0;
    {
#line 294
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 294
      if (! (k < pima->samplesperblock)) {
#line 294
        goto while_break___1;
      }
      {
#line 295
      step = (short )ima_step_size[stepindx];
#line 297
      bytecode = (int )*(pima->samples + (pima->channels * k + chan));
#line 299
      stepindx += ima_indx_adjust[bytecode];
#line 300
      __cil_tmp17 = clamp_ima_step_index((int )stepindx);
#line 300
      stepindx = (short )__cil_tmp17;
#line 302
      diff = (int )step >> 3;
      }
#line 303
      if (bytecode & 1) {
#line 303
        diff += (int )step >> 2;
      }
#line 304
      if (bytecode & 2) {
#line 304
        diff += (int )step >> 1;
      }
#line 305
      if (bytecode & 4) {
#line 305
        diff += (int )step;
      }
#line 306
      if (bytecode & 8) {
#line 306
        diff = - diff;
      }
#line 308
      predictor += diff;
#line 309
      *(pima->samples + (pima->channels * k + chan)) = predictor;
#line 294
      k ++;
    }
    while_break___1: /* CIL Label */ ;
    }

#line 274
    chan ++;
  }
  while_break: /* CIL Label */ ;
  }

#line 313
  return (1);
}
}
#line 317 "/root/libsndfile/src/ima_adpcm.c"
static int aiff_ima_encode_block(SF_PRIVATE *psf , IMA_ADPCM_PRIVATE *pima ) 
{ 
  int chan ;
  int k ;
  int step ;
  int diff ;
  int vpdiff ;
  int blockindx ;
  int indx ;
  short bytecode ;
  short mask ;
  int __cil_tmp12 ;
  int tmp ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  sf_count_t __cil_tmp17 ;
  int __cil_tmp18 ;

  {
#line 322
  chan = 0;
  {
#line 322
  while (1) {
    while_continue: /* CIL Label */ ;
#line 322
    if (! (chan < pima->channels)) {
#line 322
      goto while_break;
    }
#line 323
    blockindx = chan * pima->blocksize;
#line 325
    *(pima->block + blockindx) = (unsigned char )(((int )*(pima->samples + chan) >> 8) & 255);
#line 326
    *(pima->block + (blockindx + 1)) = (unsigned char )(((int )*(pima->samples + chan) & 128) + (pima->stepindx[chan] & 127));
#line 328
    pima->previous[chan] = (int )*(pima->samples + chan);
#line 322
    chan ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 332
  k = pima->channels;
  {
#line 332
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 332
    if (! (k < pima->samplesperblock * pima->channels)) {
#line 332
      goto while_break___0;
    }
#line 333
    if (pima->channels > 1) {
#line 333
      tmp = k % 2;
    } else {
#line 333
      tmp = 0;
    }
#line 333
    chan = tmp;
#line 335
    diff = (int )*(pima->samples + k) - pima->previous[chan];
#line 337
    bytecode = (short )0;
#line 338
    step = ima_step_size[pima->stepindx[chan]];
#line 339
    vpdiff = step >> 3;
#line 340
    if (diff < 0) {
#line 341
      bytecode = (short )8;
#line 342
      diff = - diff;
    }
#line 344
    mask = (short )4;
    {
#line 345
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 345
      if (! mask) {
#line 345
        goto while_break___1;
      }
#line 346
      if (diff >= step) {
#line 347
        bytecode |= (int )mask;
#line 348
        diff -= step;
#line 349
        vpdiff += step;
      }
#line 351
      step >>= 1;
#line 352
      mask >>= 1;
    }
    while_break___1: /* CIL Label */ ;
    }

#line 355
    if ((int )bytecode & 8) {
#line 356
      pima->previous[chan] -= vpdiff;
    } else {
#line 358
      pima->previous[chan] += vpdiff;
    }
#line 360
    if (pima->previous[chan] > 32767) {
#line 361
      pima->previous[chan] = 32767;
    } else
#line 362
    if (pima->previous[chan] < -32768) {
#line 363
      pima->previous[chan] = - 32768;
    }
    {
#line 365
    pima->stepindx[chan] += ima_indx_adjust[bytecode];
#line 367
    pima->stepindx[chan] = clamp_ima_step_index(pima->stepindx[chan]);
#line 368
    *(pima->samples + k) = bytecode;
    }
#line 332
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 373
  chan = 0;
  {
#line 373
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 373
    if (! (chan < pima->channels)) {
#line 373
      goto while_break___2;
    }
#line 374
    indx = pima->channels;
    {
#line 374
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 374
      if (! (indx < pima->channels * pima->samplesperblock)) {
#line 374
        goto while_break___3;
      }
#line 375
      blockindx = (chan * pima->blocksize + 2) + indx / 2;
#line 377
      *(pima->block + blockindx) = (unsigned char )((int )*(pima->samples + indx) & 15);
#line 378
      *(pima->block + blockindx) |= ((int )*(pima->samples + (indx + pima->channels)) << 4) & 240;
#line 374
      indx += 2 * pima->channels;
    }
    while_break___3: /* CIL Label */ ;
    }

#line 373
    chan ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 384
  __cil_tmp17 = psf_fwrite(pima->block, (sf_count_t )1, (sf_count_t )(pima->channels * pima->blocksize),
                           psf);
#line 384
  k = (int )__cil_tmp17;
  }
#line 384
  if (k != pima->channels * pima->blocksize) {
    {
#line 385
    psf_log_printf(psf, "*** Warning : short write (%d != %d).\n", k, pima->channels * pima->blocksize);
    }
  }
  {
#line 387
  memset(pima->samples, 0, (unsigned long )(pima->channels * pima->samplesperblock) * sizeof(short ));
#line 388
  pima->samplecount = 0;
#line 389
  (pima->blockcount) ++;
  }
#line 391
  return (1);
}
}
#line 395 "/root/libsndfile/src/ima_adpcm.c"
static int wav_w64_ima_decode_block(SF_PRIVATE *psf , IMA_ADPCM_PRIVATE *pima ) 
{ 
  int chan ;
  int k ;
  int current ;
  int blockindx ;
  int indx ;
  int indxstart ;
  int diff ;
  short step ;
  short bytecode ;
  short stepindx[2] ;
  int __cil_tmp13 ;
  sf_count_t __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int tmp ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;

  {
#line 399
  (pima->blockcount) ++;
#line 400
  pima->samplecount = 0;
#line 402
  if (pima->blockcount > pima->blocks) {
    {
#line 403
    memset(pima->samples, 0, (unsigned long )(pima->samplesperblock * pima->channels) * sizeof(short ));
    }
#line 404
    return (1);
  }
  {
#line 407
  __cil_tmp14 = psf_fread(pima->block, (sf_count_t )1, (sf_count_t )pima->blocksize,
                          psf);
#line 407
  k = (int )__cil_tmp14;
  }
#line 407
  if (k != pima->blocksize) {
    {
#line 408
    psf_log_printf(psf, "*** Warning : short read (%d != %d).\n", k, pima->blocksize);
    }
  }
#line 412
  chan = 0;
  {
#line 412
  while (1) {
    while_continue: /* CIL Label */ ;
#line 412
    if (! (chan < pima->channels)) {
#line 412
      goto while_break;
    }
#line 413
    current = (int )*(pima->block + chan * 4) | ((int )*(pima->block + (chan * 4 + 1)) << 8);
#line 414
    if (current & 32768) {
#line 415
      current -= 65536;
    }
    {
#line 417
    stepindx[chan] = (short )*(pima->block + (chan * 4 + 2));
#line 418
    __cil_tmp15 = clamp_ima_step_index((int )stepindx[chan]);
#line 418
    stepindx[chan] = (short )__cil_tmp15;
    }
#line 421
    if ((int )*(pima->block + (chan * 4 + 3)) != 0) {
      {
#line 422
      psf_log_printf(psf, "IMA ADPCM synchronisation error.\n");
      }
    }
#line 424
    *(pima->samples + chan) = (short )current;
#line 412
    chan ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 432
  blockindx = 4 * pima->channels;
#line 434
  indxstart = pima->channels;
  {
#line 435
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 435
    if (! (blockindx < pima->blocksize)) {
#line 435
      goto while_break___0;
    }
#line 436
    chan = 0;
    {
#line 436
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 436
      if (! (chan < pima->channels)) {
#line 436
        goto while_break___1;
      }
#line 437
      indx = indxstart + chan;
#line 438
      k = 0;
      {
#line 438
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 438
        if (! (k < 4)) {
#line 438
          goto while_break___2;
        }
#line 439
        __cil_tmp17 = blockindx;
#line 439
        blockindx ++;
#line 439
        bytecode = (short )*(pima->block + __cil_tmp17);
#line 440
        *(pima->samples + indx) = (short )((int )bytecode & 15);
#line 441
        indx += pima->channels;
#line 442
        *(pima->samples + indx) = (short )(((int )bytecode >> 4) & 15);
#line 443
        indx += pima->channels;
#line 438
        k ++;
      }
      while_break___2: /* CIL Label */ ;
      }

#line 436
      chan ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 446
    indxstart += 8 * pima->channels;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 451
  k = pima->channels;
  {
#line 451
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 451
    if (! (k < pima->samplesperblock * pima->channels)) {
#line 451
      goto while_break___3;
    }
#line 452
    if (pima->channels > 1) {
#line 452
      tmp = k % 2;
    } else {
#line 452
      tmp = 0;
    }
#line 452
    chan = tmp;
#line 454
    bytecode = (short )((int )*(pima->samples + k) & 15);
#line 456
    step = (short )ima_step_size[stepindx[chan]];
#line 457
    current = (int )*(pima->samples + (k - pima->channels));
#line 459
    diff = (int )step >> 3;
#line 460
    if ((int )bytecode & 1) {
#line 461
      diff += (int )step >> 2;
    }
#line 462
    if ((int )bytecode & 2) {
#line 463
      diff += (int )step >> 1;
    }
#line 464
    if ((int )bytecode & 4) {
#line 465
      diff += (int )step;
    }
#line 466
    if ((int )bytecode & 8) {
#line 467
      diff = - diff;
    }
#line 469
    current += diff;
#line 471
    if (current > 32767) {
#line 472
      current = 32767;
    } else
#line 473
    if (current < -32768) {
#line 474
      current = - 32768;
    }
    {
#line 476
    stepindx[chan] += ima_indx_adjust[bytecode];
#line 477
    __cil_tmp21 = clamp_ima_step_index((int )stepindx[chan]);
#line 477
    stepindx[chan] = (short )__cil_tmp21;
#line 479
    *(pima->samples + k) = (short )current;
    }
#line 451
    k ++;
  }
  while_break___3: /* CIL Label */ ;
  }

#line 482
  return (1);
}
}
#line 486 "/root/libsndfile/src/ima_adpcm.c"
static int wav_w64_ima_encode_block(SF_PRIVATE *psf , IMA_ADPCM_PRIVATE *pima ) 
{ 
  int chan ;
  int k ;
  int step ;
  int diff ;
  int vpdiff ;
  int blockindx ;
  int indx ;
  int indxstart ;
  short bytecode ;
  short mask ;
  int __cil_tmp13 ;
  int tmp ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  sf_count_t __cil_tmp20 ;
  int __cil_tmp21 ;

  {
#line 491
  chan = 0;
  {
#line 491
  while (1) {
    while_continue: /* CIL Label */ ;
#line 491
    if (! (chan < pima->channels)) {
#line 491
      goto while_break;
    }
#line 492
    *(pima->block + chan * 4) = (unsigned char )((int )*(pima->samples + chan) & 255);
#line 493
    *(pima->block + (chan * 4 + 1)) = (unsigned char )(((int )*(pima->samples + chan) >> 8) & 255);
#line 495
    *(pima->block + (chan * 4 + 2)) = (unsigned char )pima->stepindx[chan];
#line 496
    *(pima->block + (chan * 4 + 3)) = (unsigned char )0;
#line 498
    pima->previous[chan] = (int )*(pima->samples + chan);
#line 491
    chan ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 503
  k = pima->channels;
  {
#line 503
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 503
    if (! (k < pima->samplesperblock * pima->channels)) {
#line 503
      goto while_break___0;
    }
#line 504
    if (pima->channels > 1) {
#line 504
      tmp = k % 2;
    } else {
#line 504
      tmp = 0;
    }
#line 504
    chan = tmp;
#line 506
    diff = (int )*(pima->samples + k) - pima->previous[chan];
#line 508
    bytecode = (short )0;
#line 509
    step = ima_step_size[pima->stepindx[chan]];
#line 510
    vpdiff = step >> 3;
#line 511
    if (diff < 0) {
#line 512
      bytecode = (short )8;
#line 513
      diff = - diff;
    }
#line 515
    mask = (short )4;
    {
#line 516
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 516
      if (! mask) {
#line 516
        goto while_break___1;
      }
#line 517
      if (diff >= step) {
#line 518
        bytecode |= (int )mask;
#line 519
        diff -= step;
#line 520
        vpdiff += step;
      }
#line 522
      step >>= 1;
#line 523
      mask >>= 1;
    }
    while_break___1: /* CIL Label */ ;
    }

#line 526
    if ((int )bytecode & 8) {
#line 527
      pima->previous[chan] -= vpdiff;
    } else {
#line 529
      pima->previous[chan] += vpdiff;
    }
#line 531
    if (pima->previous[chan] > 32767) {
#line 532
      pima->previous[chan] = 32767;
    } else
#line 533
    if (pima->previous[chan] < -32768) {
#line 534
      pima->previous[chan] = - 32768;
    }
    {
#line 536
    pima->stepindx[chan] += ima_indx_adjust[bytecode];
#line 537
    pima->stepindx[chan] = clamp_ima_step_index(pima->stepindx[chan]);
#line 539
    *(pima->samples + k) = bytecode;
    }
#line 503
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 544
  blockindx = 4 * pima->channels;
#line 546
  indxstart = pima->channels;
  {
#line 547
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 547
    if (! (blockindx < pima->blocksize)) {
#line 547
      goto while_break___2;
    }
#line 548
    chan = 0;
    {
#line 548
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 548
      if (! (chan < pima->channels)) {
#line 548
        goto while_break___3;
      }
#line 549
      indx = indxstart + chan;
#line 550
      k = 0;
      {
#line 550
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 550
        if (! (k < 4)) {
#line 550
          goto while_break___4;
        }
#line 551
        *(pima->block + blockindx) = (unsigned char )((int )*(pima->samples + indx) & 15);
#line 552
        indx += pima->channels;
#line 553
        *(pima->block + blockindx) |= ((int )*(pima->samples + indx) << 4) & 240;
#line 554
        indx += pima->channels;
#line 555
        blockindx ++;
#line 550
        k ++;
      }
      while_break___4: /* CIL Label */ ;
      }

#line 548
      chan ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 558
    indxstart += 8 * pima->channels;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 563
  __cil_tmp20 = psf_fwrite(pima->block, (sf_count_t )1, (sf_count_t )pima->blocksize,
                           psf);
#line 563
  k = (int )__cil_tmp20;
  }
#line 563
  if (k != pima->blocksize) {
    {
#line 564
    psf_log_printf(psf, "*** Warning : short write (%d != %d).\n", k, pima->blocksize);
    }
  }
  {
#line 566
  memset(pima->samples, 0, (unsigned long )pima->samplesperblock * sizeof(short ));
#line 567
  pima->samplecount = 0;
#line 568
  (pima->blockcount) ++;
  }
#line 570
  return (1);
}
}
#line 574 "/root/libsndfile/src/ima_adpcm.c"
static int ima_read_block(SF_PRIVATE *psf , IMA_ADPCM_PRIVATE *pima , short *ptr ,
                          int len ) 
{ 
  int count ;
  int total ;
  int indx ;
  int tmp ;

  {
#line 575
  total = 0;
#line 575
  indx = 0;
  {
#line 577
  while (1) {
    while_continue: /* CIL Label */ ;
#line 577
    if (! (indx < len)) {
#line 577
      goto while_break;
    }
#line 578
    if (pima->blockcount >= pima->blocks) {
#line 578
      if (pima->samplecount >= pima->samplesperblock) {
        {
#line 579
        memset(ptr + indx, 0, (size_t )((unsigned long )(len - indx) * sizeof(short )));
        }
#line 580
        return (total);
      }
    }

#line 583
    if (pima->samplecount >= pima->samplesperblock) {
      {
#line 584
      (*(pima->decode_block))(psf, pima);
      }
    }
#line 586
    count = (pima->samplesperblock - pima->samplecount) * pima->channels;
#line 587
    if (len - indx > count) {
#line 587
      tmp = count;
    } else {
#line 587
      tmp = len - indx;
    }
    {
#line 587
    count = tmp;
#line 589
    memcpy(ptr + indx, pima->samples + pima->samplecount * pima->channels, (unsigned long )count * sizeof(short ));
#line 590
    indx += count;
#line 591
    pima->samplecount += count / pima->channels;
#line 592
    total = indx;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 595
  return (total);
}
}
#line 599 "/root/libsndfile/src/ima_adpcm.c"
static sf_count_t ima_read_s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  IMA_ADPCM_PRIVATE *pima ;
  int readcount ;
  int count ;
  sf_count_t total ;
  int tmp ;
  int __cil_tmp9 ;

  {
#line 602
  total = (sf_count_t )0;
#line 604
  if (! psf->codec_data) {
#line 605
    return ((sf_count_t )0);
  }
#line 606
  pima = (IMA_ADPCM_PRIVATE *)psf->codec_data;
  {
#line 608
  while (1) {
    while_continue: /* CIL Label */ ;
#line 608
    if (! (len > 0L)) {
#line 608
      goto while_break;
    }
#line 609
    if (len > 268435456L) {
#line 609
      tmp = 268435456;
    } else {
#line 609
      tmp = (int )len;
    }
    {
#line 609
    readcount = tmp;
#line 611
    count = ima_read_block(psf, pima, ptr, readcount);
#line 613
    total += (long )count;
#line 614
    len -= (long )count;
    }
#line 615
    if (count != readcount) {
#line 616
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 619
  return (total);
}
}
#line 623 "/root/libsndfile/src/ima_adpcm.c"
static sf_count_t ima_read_i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  IMA_ADPCM_PRIVATE *pima ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count ;
  sf_count_t total ;
  int tmp ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;

  {
#line 627
  total = (sf_count_t )0;
#line 629
  if (! psf->codec_data) {
#line 630
    return ((sf_count_t )0);
  }
#line 631
  pima = (IMA_ADPCM_PRIVATE *)psf->codec_data;
#line 633
  sptr = (short *)psf->u.sbuf;
#line 634
  bufferlen = (int )(sizeof(psf->u.sbuf) / sizeof(psf->u.sbuf[0]));
  {
#line 635
  while (1) {
    while_continue: /* CIL Label */ ;
#line 635
    if (! (len > 0L)) {
#line 635
      goto while_break;
    }
#line 636
    if (len >= (long )bufferlen) {
#line 636
      tmp = bufferlen;
    } else {
#line 636
      tmp = (int )len;
    }
    {
#line 636
    readcount = tmp;
#line 637
    count = ima_read_block(psf, pima, sptr, readcount);
#line 638
    k = 0;
    }
    {
#line 638
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 638
      if (! (k < readcount)) {
#line 638
        goto while_break___0;
      }
#line 639
      *(ptr + (total + (long )k)) = (int )*(sptr + k) << 16;
#line 638
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 640
    total += (long )count;
#line 641
    len -= (long )readcount;
#line 642
    if (count != readcount) {
#line 643
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 646
  return (total);
}
}
#line 650 "/root/libsndfile/src/ima_adpcm.c"
static sf_count_t ima_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  IMA_ADPCM_PRIVATE *pima ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  int tmp___0 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;

  {
#line 654
  total = (sf_count_t )0;
#line 657
  if (! psf->codec_data) {
#line 658
    return ((sf_count_t )0);
  }
#line 659
  pima = (IMA_ADPCM_PRIVATE *)psf->codec_data;
#line 661
  if (psf->norm_float == 1) {
#line 661
    tmp = 1. / (double )((float )32768);
  } else {
#line 661
    tmp = 1.;
  }
#line 661
  normfact = (float )tmp;
#line 663
  sptr = (short *)psf->u.sbuf;
#line 664
  bufferlen = (int )(sizeof(psf->u.sbuf) / sizeof(psf->u.sbuf[0]));
  {
#line 665
  while (1) {
    while_continue: /* CIL Label */ ;
#line 665
    if (! (len > 0L)) {
#line 665
      goto while_break;
    }
#line 666
    if (len >= (long )bufferlen) {
#line 666
      tmp___0 = bufferlen;
    } else {
#line 666
      tmp___0 = (int )len;
    }
    {
#line 666
    readcount = tmp___0;
#line 667
    count = ima_read_block(psf, pima, sptr, readcount);
#line 668
    k = 0;
    }
    {
#line 668
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 668
      if (! (k < readcount)) {
#line 668
        goto while_break___0;
      }
#line 669
      *(ptr + (total + (long )k)) = normfact * (float )*(sptr + k);
#line 668
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 670
    total += (long )count;
#line 671
    len -= (long )readcount;
#line 672
    if (count != readcount) {
#line 673
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 676
  return (total);
}
}
#line 680 "/root/libsndfile/src/ima_adpcm.c"
static sf_count_t ima_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  IMA_ADPCM_PRIVATE *pima ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  int tmp___0 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;

  {
#line 684
  total = (sf_count_t )0;
#line 687
  if (! psf->codec_data) {
#line 688
    return ((sf_count_t )0);
  }
#line 689
  pima = (IMA_ADPCM_PRIVATE *)psf->codec_data;
#line 691
  if (psf->norm_double == 1) {
#line 691
    tmp = 1. / (double )32768;
  } else {
#line 691
    tmp = 1.;
  }
#line 691
  normfact = tmp;
#line 693
  sptr = (short *)psf->u.sbuf;
#line 694
  bufferlen = (int )(sizeof(psf->u.sbuf) / sizeof(psf->u.sbuf[0]));
  {
#line 695
  while (1) {
    while_continue: /* CIL Label */ ;
#line 695
    if (! (len > 0L)) {
#line 695
      goto while_break;
    }
#line 696
    if (len >= (long )bufferlen) {
#line 696
      tmp___0 = bufferlen;
    } else {
#line 696
      tmp___0 = (int )len;
    }
    {
#line 696
    readcount = tmp___0;
#line 697
    count = ima_read_block(psf, pima, sptr, readcount);
#line 698
    k = 0;
    }
    {
#line 698
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 698
      if (! (k < readcount)) {
#line 698
        goto while_break___0;
      }
#line 699
      *(ptr + (total + (long )k)) = normfact * (double )*(sptr + k);
#line 698
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 700
    total += (long )count;
#line 701
    len -= (long )readcount;
#line 702
    if (count != readcount) {
#line 703
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 706
  return (total);
}
}
#line 710 "/root/libsndfile/src/ima_adpcm.c"
static sf_count_t ima_seek(SF_PRIVATE *psf , int mode , sf_count_t offset ) 
{ 
  IMA_ADPCM_PRIVATE *pima ;
  int newblock ;
  int newsample ;

  {
#line 714
  if (! psf->codec_data) {
#line 715
    return ((sf_count_t )0);
  }
#line 716
  pima = (IMA_ADPCM_PRIVATE *)psf->codec_data;
#line 718
  if (psf->datalength < 0L) {
#line 719
    psf->error = 38;
#line 720
    return ((sf_count_t )(- 1));
  } else
#line 718
  if (psf->dataoffset < 0L) {
#line 719
    psf->error = 38;
#line 720
    return ((sf_count_t )(- 1));
  }

#line 723
  if (offset == 0L) {
    {
#line 724
    psf_fseek(psf, psf->dataoffset, 0);
#line 725
    pima->blockcount = 0;
#line 726
    (*(pima->decode_block))(psf, pima);
#line 727
    pima->samplecount = 0;
    }
#line 728
    return ((sf_count_t )0);
  }

#line 731
  if (offset < 0L) {
#line 732
    psf->error = 38;
#line 733
    return ((sf_count_t )(- 1));
  } else
#line 731
  if (offset > (long )(pima->blocks * pima->samplesperblock)) {
#line 732
    psf->error = 38;
#line 733
    return ((sf_count_t )(- 1));
  }
#line 736
  newblock = (int )(offset / (long )pima->samplesperblock);
#line 737
  newsample = (int )(offset % (long )pima->samplesperblock);
#line 739
  if (mode == 16) {
    {
#line 740
    psf_fseek(psf, psf->dataoffset + (long )(newblock * pima->blocksize), 0);
#line 741
    pima->blockcount = newblock;
#line 742
    (*(pima->decode_block))(psf, pima);
#line 743
    pima->samplecount = newsample;
    }
  } else {
#line 747
    psf->error = 38;
#line 748
    return ((sf_count_t )(- 1));
  }

#line 751
  return ((sf_count_t )(newblock * pima->samplesperblock + newsample));
}
}
#line 759 "/root/libsndfile/src/ima_adpcm.c"
static int ima_writer_init(SF_PRIVATE *psf , int blockalign ) 
{ 
  IMA_ADPCM_PRIVATE *pima ;
  int samplesperblock ;
  unsigned int pimasize ;
  void *__cil_tmp6 ;

  {
#line 764
  if (psf->mode != 32) {
#line 765
    return (23);
  }
  {
#line 767
  samplesperblock = (2 * (blockalign - 4 * psf->sf.channels)) / psf->sf.channels + 1;
#line 769
  pimasize = (unsigned int )((sizeof(IMA_ADPCM_PRIVATE ) + (unsigned long )blockalign) + (unsigned long )((3 * psf->sf.channels) * samplesperblock));
#line 771
  pima = (IMA_ADPCM_PRIVATE *)calloc((unsigned long )1, (unsigned long )pimasize);
  }
#line 771
  if (pima == (void *)0) {
#line 772
    return (16);
  }
#line 774
  psf->codec_data = (void *)pima;
#line 776
  pima->channels = psf->sf.channels;
#line 777
  pima->blocksize = blockalign;
#line 778
  pima->samplesperblock = samplesperblock;
#line 780
  pima->block = (unsigned char *)((short *)pima->data);
#line 781
  pima->samples = (short *)((short *)pima->data + blockalign);
#line 783
  pima->samplecount = 0;
  {
#line 787
  if ((psf->sf.format & 268369920) == 720896) {
#line 787
    goto case_720896;
  }
#line 787
  if ((psf->sf.format & 268369920) == 65536) {
#line 787
    goto case_720896;
  }
#line 791
  if ((psf->sf.format & 268369920) == 131072) {
#line 791
    goto case_131072;
  }
#line 795
  goto switch_default;
  case_720896: /* CIL Label */ 
  case_65536: /* CIL Label */ 
#line 788
  pima->encode_block = & wav_w64_ima_encode_block;
#line 789
  goto switch_break;
  case_131072: /* CIL Label */ 
#line 792
  pima->encode_block = & aiff_ima_encode_block;
#line 793
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 796
  psf_log_printf(psf, "ima_reader_init: bad psf->sf.format\n\036V");
  }
#line 797
  return (29);
  switch_break: /* CIL Label */ ;
  }
#line 800
  psf->write_short = & ima_write_s;
#line 801
  psf->write_int = & ima_write_i;
#line 802
  psf->write_float = & ima_write_f;
#line 803
  psf->write_double = & ima_write_d;
#line 805
  return (0);
}
}
#line 812 "/root/libsndfile/src/ima_adpcm.c"
static int ima_write_block(SF_PRIVATE *psf , IMA_ADPCM_PRIVATE *pima , short const   *ptr ,
                           int len ) 
{ 
  int count ;
  int total ;
  int indx ;

  {
#line 813
  total = 0;
#line 813
  indx = 0;
  {
#line 815
  while (1) {
    while_continue: /* CIL Label */ ;
#line 815
    if (! (indx < len)) {
#line 815
      goto while_break;
    }
#line 816
    count = (pima->samplesperblock - pima->samplecount) * pima->channels;
#line 818
    if (count > len - indx) {
#line 819
      count = len - indx;
    }
    {
#line 821
    memcpy(pima->samples + pima->samplecount * pima->channels, ptr + total, (unsigned long )count * sizeof(short ));
#line 822
    indx += count;
#line 823
    pima->samplecount += count / pima->channels;
#line 824
    total = indx;
    }
#line 826
    if (pima->samplecount >= pima->samplesperblock) {
      {
#line 827
      (*(pima->encode_block))(psf, pima);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 830
  return (total);
}
}
#line 834 "/root/libsndfile/src/ima_adpcm.c"
static sf_count_t ima_write_s(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  IMA_ADPCM_PRIVATE *pima ;
  int writecount ;
  int count ;
  sf_count_t total ;
  int tmp ;
  int __cil_tmp9 ;

  {
#line 837
  total = (sf_count_t )0;
#line 839
  if (! psf->codec_data) {
#line 840
    return ((sf_count_t )0);
  }
#line 841
  pima = (IMA_ADPCM_PRIVATE *)psf->codec_data;
  {
#line 843
  while (1) {
    while_continue: /* CIL Label */ ;
#line 843
    if (! len) {
#line 843
      goto while_break;
    }
#line 844
    if (len > 268435456L) {
#line 844
      tmp = 268435456;
    } else {
#line 844
      tmp = (int )len;
    }
    {
#line 844
    writecount = tmp;
#line 846
    count = ima_write_block(psf, pima, ptr, writecount);
#line 848
    total += (long )count;
#line 849
    len -= (long )count;
    }
#line 850
    if (count != writecount) {
#line 851
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 854
  return (total);
}
}
#line 858 "/root/libsndfile/src/ima_adpcm.c"
static sf_count_t ima_write_i(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  IMA_ADPCM_PRIVATE *pima ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count ;
  sf_count_t total ;
  int tmp ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;

  {
#line 862
  total = (sf_count_t )0;
#line 864
  if (! psf->codec_data) {
#line 865
    return ((sf_count_t )0);
  }
#line 866
  pima = (IMA_ADPCM_PRIVATE *)psf->codec_data;
#line 868
  sptr = (short *)psf->u.sbuf;
#line 869
  bufferlen = (int )(sizeof(psf->u.sbuf) / sizeof(psf->u.sbuf[0]));
  {
#line 870
  while (1) {
    while_continue: /* CIL Label */ ;
#line 870
    if (! (len > 0L)) {
#line 870
      goto while_break;
    }
#line 871
    if (len >= (long )bufferlen) {
#line 871
      tmp = bufferlen;
    } else {
#line 871
      tmp = (int )len;
    }
#line 871
    writecount = tmp;
#line 872
    k = 0;
    {
#line 872
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 872
      if (! (k < writecount)) {
#line 872
        goto while_break___0;
      }
#line 873
      *(sptr + k) = (short )(*(ptr + (total + (long )k)) >> 16);
#line 872
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 874
    count = ima_write_block(psf, pima, (short const   *)sptr, writecount);
#line 875
    total += (long )count;
#line 876
    len -= (long )writecount;
    }
#line 877
    if (count != writecount) {
#line 878
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 881
  return (total);
}
}
#line 885 "/root/libsndfile/src/ima_adpcm.c"
static sf_count_t ima_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  IMA_ADPCM_PRIVATE *pima ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  int tmp___0 ;
  long __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;

  {
#line 889
  total = (sf_count_t )0;
#line 892
  if (! psf->codec_data) {
#line 893
    return ((sf_count_t )0);
  }
#line 894
  pima = (IMA_ADPCM_PRIVATE *)psf->codec_data;
#line 896
  if (psf->norm_float == 1) {
#line 896
    tmp = 1. * (double )32767;
  } else {
#line 896
    tmp = 1.;
  }
#line 896
  normfact = (float )tmp;
#line 898
  sptr = (short *)psf->u.sbuf;
#line 899
  bufferlen = (int )(sizeof(psf->u.sbuf) / sizeof(psf->u.sbuf[0]));
  {
#line 900
  while (1) {
    while_continue: /* CIL Label */ ;
#line 900
    if (! (len > 0L)) {
#line 900
      goto while_break;
    }
#line 901
    if (len >= (long )bufferlen) {
#line 901
      tmp___0 = bufferlen;
    } else {
#line 901
      tmp___0 = (int )len;
    }
#line 901
    writecount = tmp___0;
#line 902
    k = 0;
    {
#line 902
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 902
      if (! (k < writecount)) {
#line 902
        goto while_break___0;
      }
      {
#line 903
      __cil_tmp14 = lrintf(normfact * *(ptr + (total + (long )k)));
#line 903
      *(sptr + k) = (short )__cil_tmp14;
      }
#line 902
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 904
    count = ima_write_block(psf, pima, (short const   *)sptr, writecount);
#line 905
    total += (long )count;
#line 906
    len -= (long )writecount;
    }
#line 907
    if (count != writecount) {
#line 908
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 911
  return (total);
}
}
#line 915 "/root/libsndfile/src/ima_adpcm.c"
static sf_count_t ima_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  IMA_ADPCM_PRIVATE *pima ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  int tmp___0 ;
  long __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;

  {
#line 919
  total = (sf_count_t )0;
#line 922
  if (! psf->codec_data) {
#line 923
    return ((sf_count_t )0);
  }
#line 924
  pima = (IMA_ADPCM_PRIVATE *)psf->codec_data;
#line 926
  if (psf->norm_double == 1) {
#line 926
    tmp = 1. * (double )32767;
  } else {
#line 926
    tmp = 1.;
  }
#line 926
  normfact = tmp;
#line 928
  sptr = (short *)psf->u.sbuf;
#line 929
  bufferlen = (int )(sizeof(psf->u.sbuf) / sizeof(psf->u.sbuf[0]));
  {
#line 930
  while (1) {
    while_continue: /* CIL Label */ ;
#line 930
    if (! (len > 0L)) {
#line 930
      goto while_break;
    }
#line 931
    if (len >= (long )bufferlen) {
#line 931
      tmp___0 = bufferlen;
    } else {
#line 931
      tmp___0 = (int )len;
    }
#line 931
    writecount = tmp___0;
#line 932
    k = 0;
    {
#line 932
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 932
      if (! (k < writecount)) {
#line 932
        goto while_break___0;
      }
      {
#line 933
      __cil_tmp14 = lrint(normfact * *(ptr + (total + (long )k)));
#line 933
      *(sptr + k) = (short )__cil_tmp14;
      }
#line 932
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 934
    count = ima_write_block(psf, pima, (short const   *)sptr, writecount);
#line 935
    total += (long )count;
#line 936
    len -= (long )writecount;
    }
#line 937
    if (count != writecount) {
#line 938
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 941
  return (total);
}
}
#line 50 "/root/libsndfile/src/gsm610.c"
static sf_count_t gsm610_read_s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 51
static sf_count_t gsm610_read_i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 52
static sf_count_t gsm610_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 53
static sf_count_t gsm610_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 55
static sf_count_t gsm610_write_s(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 56
static sf_count_t gsm610_write_i(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 57
static sf_count_t gsm610_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 58
static sf_count_t gsm610_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 60
static int gsm610_read_block(SF_PRIVATE *psf , GSM610_PRIVATE *pgsm610 , short *ptr ,
                             int len ) ;
#line 61
static int gsm610_write_block(SF_PRIVATE *psf , GSM610_PRIVATE *pgsm610 , short const   *ptr ,
                              int len ) ;
#line 63
static int gsm610_decode_block(SF_PRIVATE *psf , GSM610_PRIVATE *pgsm610 ) ;
#line 64
static int gsm610_encode_block(SF_PRIVATE *psf , GSM610_PRIVATE *pgsm610 ) ;
#line 66
static int gsm610_wav_decode_block(SF_PRIVATE *psf , GSM610_PRIVATE *pgsm610 ) ;
#line 67
static int gsm610_wav_encode_block(SF_PRIVATE *psf , GSM610_PRIVATE *pgsm610 ) ;
#line 69
static sf_count_t gsm610_seek(SF_PRIVATE *psf , int UNUSED_mode , sf_count_t offset ) ;
#line 71
static int gsm610_close(SF_PRIVATE *psf ) ;
#line 78 "/root/libsndfile/src/gsm610.c"
int gsm610_init(SF_PRIVATE *psf ) 
{ 
  GSM610_PRIVATE *pgsm610 ;
  int true_flag ;
  void *__cil_tmp4 ;
  gsm __cil_tmp5 ;
  sf_count_t __cil_tmp6 ;

  {
#line 80
  true_flag = 1;
#line 82
  if (psf->codec_data != (void *)0) {
    {
#line 83
    psf_log_printf(psf, "*** psf->codec_data is not NULL.\n");
    }
#line 84
    return (29);
  }

#line 87
  if (psf->mode == 48) {
#line 88
    return (23);
  }
  {
#line 90
  psf->sf.seekable = 0;
#line 92
  pgsm610 = (GSM610_PRIVATE *)calloc((unsigned long )1, sizeof(GSM610_PRIVATE ));
  }
#line 92
  if (pgsm610 == (void *)0) {
#line 93
    return (16);
  }
  {
#line 95
  psf->codec_data = pgsm610;
#line 97
  memset(pgsm610, 0, sizeof(GSM610_PRIVATE ));
#line 105
  pgsm610->gsm_data = gsm_create();
  }
#line 105
  if (pgsm610->gsm_data == (void *)0) {
#line 106
    return (16);
  }
  {
#line 111
  if ((psf->sf.format & 268369920) == 720896) {
#line 111
    goto case_720896;
  }
#line 111
  if ((psf->sf.format & 268369920) == 1245184) {
#line 111
    goto case_720896;
  }
#line 111
  if ((psf->sf.format & 268369920) == 65536) {
#line 111
    goto case_720896;
  }
#line 122
  if ((psf->sf.format & 268369920) == 262144) {
#line 122
    goto case_262144;
  }
#line 122
  if ((psf->sf.format & 268369920) == 131072) {
#line 122
    goto case_262144;
  }
#line 130
  goto switch_default;
  case_720896: /* CIL Label */ 
  case_1245184: /* CIL Label */ 
  case_65536: /* CIL Label */ 
  {
#line 112
  gsm_option(pgsm610->gsm_data, 4, & true_flag);
  }
#line 114
  pgsm610->encode_block = & gsm610_wav_encode_block;
#line 115
  pgsm610->decode_block = & gsm610_wav_decode_block;
#line 117
  pgsm610->samplesperblock = 320;
#line 118
  pgsm610->blocksize = 65;
#line 119
  goto switch_break;
  case_262144: /* CIL Label */ 
  case_131072: /* CIL Label */ 
#line 123
  pgsm610->encode_block = & gsm610_encode_block;
#line 124
  pgsm610->decode_block = & gsm610_decode_block;
#line 126
  pgsm610->samplesperblock = 160;
#line 127
  pgsm610->blocksize = 33;
#line 128
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 131
  return (29);
#line 132
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }

#line 135
  if (psf->mode == 16) {
#line 136
    if (psf->datalength % (long )pgsm610->blocksize == 0L) {
#line 137
      pgsm610->blocks = (int )(psf->datalength / (long )pgsm610->blocksize);
    } else
#line 138
    if (psf->datalength % (long )pgsm610->blocksize == 1L) {
#line 138
      if (pgsm610->blocksize == 33) {
#line 146
        pgsm610->blocks = (int )(psf->datalength / (long )pgsm610->blocksize);
      } else {
        {
        {
#line 149
        psf_log_printf(psf, "*** Warning : data chunk seems to be truncated.\n\220");
        }
#line 150
        pgsm610->blocks = (int )(psf->datalength / (long )pgsm610->blocksize + 1L);
        }
      }
    } else {
      {
      {
#line 149
      psf_log_printf(psf, "*** Warning : data chunk seems to be truncated.\n\220");
      }
#line 150
      pgsm610->blocks = (int )(psf->datalength / (long )pgsm610->blocksize + 1L);
      }
    }
    {
#line 153
    psf->sf.frames = (sf_count_t )(pgsm610->samplesperblock * pgsm610->blocks);
#line 155
    psf_fseek(psf, psf->dataoffset, 0);
#line 157
    (*(pgsm610->decode_block))(psf, pgsm610);
#line 159
    psf->read_short = & gsm610_read_s;
#line 160
    psf->read_int = & gsm610_read_i;
#line 161
    psf->read_float = & gsm610_read_f;
#line 162
    psf->read_double = & gsm610_read_d;
    }
  }

#line 165
  if (psf->mode == 32) {
#line 166
    pgsm610->blockcount = 0;
#line 167
    pgsm610->samplecount = 0;
#line 169
    psf->write_short = & gsm610_write_s;
#line 170
    psf->write_int = & gsm610_write_i;
#line 171
    psf->write_float = & gsm610_write_f;
#line 172
    psf->write_double = & gsm610_write_d;
  }
  {
#line 175
  psf->codec_close = & gsm610_close;
#line 177
  psf->seek = & gsm610_seek;
#line 179
  psf->filelength = psf_get_filelen(psf);
#line 180
  psf->datalength = psf->filelength - psf->dataoffset;
  }
#line 182
  return (0);
}
}
#line 190 "/root/libsndfile/src/gsm610.c"
static int gsm610_wav_decode_block(SF_PRIVATE *psf , GSM610_PRIVATE *pgsm610 ) 
{ 
  int k ;
  int __cil_tmp4 ;
  sf_count_t __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 193
  (pgsm610->blockcount) ++;
#line 194
  pgsm610->samplecount = 0;
#line 196
  if (pgsm610->blockcount > pgsm610->blocks) {
    {
#line 197
    memset((short *)pgsm610->samples, 0, 320UL * sizeof(short ));
    }
#line 198
    return (1);
  }
  {
#line 201
  __cil_tmp5 = psf_fread((unsigned char *)pgsm610->block, (sf_count_t )1, (sf_count_t )65,
                         psf);
#line 201
  k = (int )__cil_tmp5;
  }
#line 201
  if (k != 65) {
    {
#line 202
    psf_log_printf(psf, "*** Warning : short read (%d != %d).\nV", k, 65);
    }
  }
  {
#line 204
  __cil_tmp6 = gsm_decode(pgsm610->gsm_data, (unsigned char *)pgsm610->block, (short *)pgsm610->samples);
  }
#line 204
  if (__cil_tmp6 < 0) {
    {
#line 205
    psf_log_printf(psf, "Error from WAV gsm_decode() on frame : %d\n", pgsm610->blockcount);
    }
#line 206
    return (0);
  }
  {
#line 209
  __cil_tmp7 = gsm_decode(pgsm610->gsm_data, (unsigned char *)pgsm610->block + 33,
                          (short *)pgsm610->samples + 160);
  }
#line 209
  if (__cil_tmp7 < 0) {
    {
#line 210
    psf_log_printf(psf, "Error from WAV gsm_decode() on frame : %d.5\n", pgsm610->blockcount);
    }
#line 211
    return (0);
  }

#line 214
  return (1);
}
}
#line 218 "/root/libsndfile/src/gsm610.c"
static int gsm610_decode_block(SF_PRIVATE *psf , GSM610_PRIVATE *pgsm610 ) 
{ 
  int k ;
  int __cil_tmp4 ;
  sf_count_t __cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 221
  (pgsm610->blockcount) ++;
#line 222
  pgsm610->samplecount = 0;
#line 224
  if (pgsm610->blockcount > pgsm610->blocks) {
    {
#line 225
    memset((short *)pgsm610->samples, 0, 160UL * sizeof(short ));
    }
#line 226
    return (1);
  }
  {
#line 229
  __cil_tmp5 = psf_fread((unsigned char *)pgsm610->block, (sf_count_t )1, (sf_count_t )33,
                         psf);
#line 229
  k = (int )__cil_tmp5;
  }
#line 229
  if (k != 33) {
    {
#line 230
    psf_log_printf(psf, "*** Warning : short read (%d != %d).\nV", k, 33);
    }
  }
  {
#line 232
  __cil_tmp6 = gsm_decode(pgsm610->gsm_data, (unsigned char *)pgsm610->block, (short *)pgsm610->samples);
  }
#line 232
  if (__cil_tmp6 < 0) {
    {
#line 233
    psf_log_printf(psf, "Error from standard gsm_decode() on frame : %d\n", pgsm610->blockcount);
    }
#line 234
    return (0);
  }

#line 237
  return (1);
}
}
#line 241 "/root/libsndfile/src/gsm610.c"
static int gsm610_read_block(SF_PRIVATE *psf , GSM610_PRIVATE *pgsm610 , short *ptr ,
                             int len ) 
{ 
  int count ;
  int total ;
  int indx ;
  int tmp ;

  {
#line 242
  total = 0;
#line 242
  indx = 0;
  {
#line 244
  while (1) {
    while_continue: /* CIL Label */ ;
#line 244
    if (! (indx < len)) {
#line 244
      goto while_break;
    }
#line 245
    if (pgsm610->blockcount >= pgsm610->blocks) {
#line 245
      if (pgsm610->samplecount >= pgsm610->samplesperblock) {
        {
#line 246
        memset(ptr + indx, 0, (unsigned long )(len - indx) * sizeof(short ));
        }
#line 247
        return (total);
      }
    }

#line 250
    if (pgsm610->samplecount >= pgsm610->samplesperblock) {
      {
#line 251
      (*(pgsm610->decode_block))(psf, pgsm610);
      }
    }
#line 253
    count = pgsm610->samplesperblock - pgsm610->samplecount;
#line 254
    if (len - indx > count) {
#line 254
      tmp = count;
    } else {
#line 254
      tmp = len - indx;
    }
    {
#line 254
    count = tmp;
#line 256
    memcpy(ptr + indx, & pgsm610->samples[pgsm610->samplecount], (unsigned long )count * sizeof(short ));
#line 257
    indx += count;
#line 258
    pgsm610->samplecount += count;
#line 259
    total = indx;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 262
  return (total);
}
}
#line 266 "/root/libsndfile/src/gsm610.c"
static sf_count_t gsm610_read_s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  GSM610_PRIVATE *pgsm610 ;
  int readcount ;
  int count ;
  sf_count_t total ;
  int tmp ;
  int __cil_tmp9 ;

  {
#line 269
  total = (sf_count_t )0;
#line 271
  if (psf->codec_data == (void *)0) {
#line 272
    return ((sf_count_t )0);
  }
#line 273
  pgsm610 = (GSM610_PRIVATE *)psf->codec_data;
  {
#line 275
  while (1) {
    while_continue: /* CIL Label */ ;
#line 275
    if (! (len > 0L)) {
#line 275
      goto while_break;
    }
#line 276
    if (len > 268435456L) {
#line 276
      tmp = 16777216;
    } else {
#line 276
      tmp = (int )len;
    }
    {
#line 276
    readcount = tmp;
#line 278
    count = gsm610_read_block(psf, pgsm610, ptr, readcount);
#line 280
    total += (long )count;
#line 281
    len -= (long )count;
    }
#line 283
    if (count != readcount) {
#line 284
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 287
  return (total);
}
}
#line 291 "/root/libsndfile/src/gsm610.c"
static sf_count_t gsm610_read_i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  GSM610_PRIVATE *pgsm610 ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count ;
  sf_count_t total ;
  long tmp ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;

  {
#line 294
  readcount = 0;
#line 295
  total = (sf_count_t )0;
#line 297
  if (psf->codec_data == (void *)0) {
#line 298
    return ((sf_count_t )0);
  }
#line 299
  pgsm610 = (GSM610_PRIVATE *)psf->codec_data;
#line 301
  sptr = (short *)psf->u.sbuf;
#line 302
  bufferlen = (int )(sizeof(psf->u.sbuf) / sizeof(psf->u.sbuf[0]));
  {
#line 303
  while (1) {
    while_continue: /* CIL Label */ ;
#line 303
    if (! (len > 0L)) {
#line 303
      goto while_break;
    }
#line 304
    if (len >= (long )bufferlen) {
#line 304
      tmp = (long )bufferlen;
    } else {
#line 304
      tmp = len;
    }
    {
#line 304
    readcount = (int )tmp;
#line 305
    count = gsm610_read_block(psf, pgsm610, sptr, readcount);
#line 306
    k = 0;
    }
    {
#line 306
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 306
      if (! (k < readcount)) {
#line 306
        goto while_break___0;
      }
#line 307
      *(ptr + (total + (long )k)) = (int )*(sptr + k) << 16;
#line 306
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 309
    total += (long )count;
#line 310
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 312
  return (total);
}
}
#line 316 "/root/libsndfile/src/gsm610.c"
static sf_count_t gsm610_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  GSM610_PRIVATE *pgsm610 ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  long tmp___0 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;

  {
#line 319
  readcount = 0;
#line 320
  total = (sf_count_t )0;
#line 323
  if (psf->codec_data == (void *)0) {
#line 324
    return ((sf_count_t )0);
  }
#line 325
  pgsm610 = (GSM610_PRIVATE *)psf->codec_data;
#line 327
  if (psf->norm_float == 1) {
#line 327
    tmp = 1. / (double )((float )32768);
  } else {
#line 327
    tmp = 1.;
  }
#line 327
  normfact = (float )tmp;
#line 329
  sptr = (short *)psf->u.sbuf;
#line 330
  bufferlen = (int )(sizeof(psf->u.sbuf) / sizeof(psf->u.sbuf[0]));
  {
#line 331
  while (1) {
    while_continue: /* CIL Label */ ;
#line 331
    if (! (len > 0L)) {
#line 331
      goto while_break;
    }
#line 332
    if (len >= (long )bufferlen) {
#line 332
      tmp___0 = (long )bufferlen;
    } else {
#line 332
      tmp___0 = len;
    }
    {
#line 332
    readcount = (int )tmp___0;
#line 333
    count = gsm610_read_block(psf, pgsm610, sptr, readcount);
#line 334
    k = 0;
    }
    {
#line 334
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 334
      if (! (k < readcount)) {
#line 334
        goto while_break___0;
      }
#line 335
      *(ptr + (total + (long )k)) = normfact * (float )((int )*(sptr + k));
#line 334
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 337
    total += (long )count;
#line 338
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 340
  return (total);
}
}
#line 344 "/root/libsndfile/src/gsm610.c"
static sf_count_t gsm610_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  GSM610_PRIVATE *pgsm610 ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  long tmp___0 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;

  {
#line 347
  readcount = 0;
#line 348
  total = (sf_count_t )0;
#line 351
  if (psf->norm_double == 1) {
#line 351
    tmp = 1. / (double )32768;
  } else {
#line 351
    tmp = 1.;
  }
#line 351
  normfact = tmp;
#line 353
  if (psf->codec_data == (void *)0) {
#line 354
    return ((sf_count_t )0);
  }
#line 355
  pgsm610 = (GSM610_PRIVATE *)psf->codec_data;
#line 357
  sptr = (short *)psf->u.sbuf;
#line 358
  bufferlen = (int )(sizeof(psf->u.sbuf) / sizeof(psf->u.sbuf[0]));
  {
#line 359
  while (1) {
    while_continue: /* CIL Label */ ;
#line 359
    if (! (len > 0L)) {
#line 359
      goto while_break;
    }
#line 360
    if (len >= (long )bufferlen) {
#line 360
      tmp___0 = (long )bufferlen;
    } else {
#line 360
      tmp___0 = len;
    }
    {
#line 360
    readcount = (int )tmp___0;
#line 361
    count = gsm610_read_block(psf, pgsm610, sptr, readcount);
#line 362
    k = 0;
    }
    {
#line 362
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 362
      if (! (k < readcount)) {
#line 362
        goto while_break___0;
      }
#line 363
      *(ptr + (total + (long )k)) = normfact * (double )((int )*(sptr + k));
#line 362
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 365
    total += (long )count;
#line 366
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 368
  return (total);
}
}
#line 372 "/root/libsndfile/src/gsm610.c"
static sf_count_t gsm610_seek(SF_PRIVATE *psf , int UNUSED_mode , sf_count_t offset ) 
{ 
  GSM610_PRIVATE *pgsm610 ;
  int newblock ;
  int newsample ;
  int true_flag ;

  {
#line 376
  if (psf->codec_data == (void *)0) {
#line 377
    return ((sf_count_t )0);
  }
#line 378
  pgsm610 = (GSM610_PRIVATE *)psf->codec_data;
#line 380
  if (psf->dataoffset < 0L) {
#line 381
    psf->error = 38;
#line 382
    return ((sf_count_t )(- 1));
  }

#line 385
  if (offset == 0L) {
    {
#line 386
    true_flag = 1;
#line 388
    psf_fseek(psf, psf->dataoffset, 0);
#line 389
    pgsm610->blockcount = 0;
#line 391
    gsm_init(pgsm610->gsm_data);
    }
#line 392
    if ((psf->sf.format & 268369920) == 65536) {
      {
      {
#line 394
      gsm_option(pgsm610->gsm_data, 4, & true_flag);
      }
      }
    } else
#line 392
    if ((psf->sf.format & 268369920) == 720896) {
      {
      {
#line 394
      gsm_option(pgsm610->gsm_data, 4, & true_flag);
      }
      }
    }
    {
#line 396
    (*(pgsm610->decode_block))(psf, pgsm610);
#line 397
    pgsm610->samplecount = 0;
    }
#line 398
    return ((sf_count_t )0);
  }

#line 401
  if (offset < 0L) {
#line 402
    psf->error = 38;
#line 403
    return ((sf_count_t )(- 1));
  } else
#line 401
  if (offset > (long )(pgsm610->blocks * pgsm610->samplesperblock)) {
#line 402
    psf->error = 38;
#line 403
    return ((sf_count_t )(- 1));
  }
#line 406
  newblock = (int )(offset / (long )pgsm610->samplesperblock);
#line 407
  newsample = (int )(offset % (long )pgsm610->samplesperblock);
#line 409
  if (psf->mode == 16) {
#line 410
    if (psf->read_current != (long )(newblock * pgsm610->samplesperblock + newsample)) {
      {
#line 411
      psf_fseek(psf, psf->dataoffset + (long )(newblock * pgsm610->samplesperblock),
                0);
#line 412
      pgsm610->blockcount = newblock;
#line 413
      (*(pgsm610->decode_block))(psf, pgsm610);
#line 414
      pgsm610->samplecount = newsample;
      }
    }

#line 417
    return ((sf_count_t )(newblock * pgsm610->samplesperblock + newsample));
  }
#line 421
  psf->error = 38;
#line 422
  return ((sf_count_t )(- 1));
}
}
#line 430 "/root/libsndfile/src/gsm610.c"
static int gsm610_encode_block(SF_PRIVATE *psf , GSM610_PRIVATE *pgsm610 ) 
{ 
  int k ;
  sf_count_t __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 434
  gsm_encode(pgsm610->gsm_data, (short *)pgsm610->samples, (unsigned char *)pgsm610->block);
#line 437
  __cil_tmp4 = psf_fwrite((unsigned char *)pgsm610->block, (sf_count_t )1, (sf_count_t )33,
                          psf);
#line 437
  k = (int )__cil_tmp4;
  }
#line 437
  if (k != 33) {
    {
#line 438
    psf_log_printf(psf, "*** Warning : short write (%d != %d).\n", k, 33);
    }
  }
  {
#line 440
  pgsm610->samplecount = 0;
#line 441
  (pgsm610->blockcount) ++;
#line 444
  memset((short *)pgsm610->samples, 0, 320UL * sizeof(short ));
  }
#line 446
  return (1);
}
}
#line 450 "/root/libsndfile/src/gsm610.c"
static int gsm610_wav_encode_block(SF_PRIVATE *psf , GSM610_PRIVATE *pgsm610 ) 
{ 
  int k ;
  sf_count_t __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 454
  gsm_encode(pgsm610->gsm_data, (short *)pgsm610->samples, (unsigned char *)pgsm610->block);
#line 455
  gsm_encode(pgsm610->gsm_data, (short *)pgsm610->samples + 160, (unsigned char *)pgsm610->block + 32);
#line 458
  __cil_tmp4 = psf_fwrite((unsigned char *)pgsm610->block, (sf_count_t )1, (sf_count_t )65,
                          psf);
#line 458
  k = (int )__cil_tmp4;
  }
#line 458
  if (k != 65) {
    {
#line 459
    psf_log_printf(psf, "*** Warning : short write (%d != %d).\n", k, 65);
    }
  }
  {
#line 461
  pgsm610->samplecount = 0;
#line 462
  (pgsm610->blockcount) ++;
#line 465
  memset((short *)pgsm610->samples, 0, 320UL * sizeof(short ));
  }
#line 467
  return (1);
}
}
#line 471 "/root/libsndfile/src/gsm610.c"
static int gsm610_write_block(SF_PRIVATE *psf , GSM610_PRIVATE *pgsm610 , short const   *ptr ,
                              int len ) 
{ 
  int count ;
  int total ;
  int indx ;

  {
#line 472
  total = 0;
#line 472
  indx = 0;
  {
#line 474
  while (1) {
    while_continue: /* CIL Label */ ;
#line 474
    if (! (indx < len)) {
#line 474
      goto while_break;
    }
#line 475
    count = pgsm610->samplesperblock - pgsm610->samplecount;
#line 477
    if (count > len - indx) {
#line 478
      count = len - indx;
    }
    {
#line 480
    memcpy(& pgsm610->samples[pgsm610->samplecount], ptr + indx, (unsigned long )count * sizeof(short ));
#line 481
    indx += count;
#line 482
    pgsm610->samplecount += count;
#line 483
    total = indx;
    }
#line 485
    if (pgsm610->samplecount >= pgsm610->samplesperblock) {
      {
#line 486
      (*(pgsm610->encode_block))(psf, pgsm610);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 489
  return (total);
}
}
#line 493 "/root/libsndfile/src/gsm610.c"
static sf_count_t gsm610_write_s(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  GSM610_PRIVATE *pgsm610 ;
  int writecount ;
  int count ;
  sf_count_t total ;
  int tmp ;
  int __cil_tmp9 ;

  {
#line 496
  total = (sf_count_t )0;
#line 498
  if (psf->codec_data == (void *)0) {
#line 499
    return ((sf_count_t )0);
  }
#line 500
  pgsm610 = (GSM610_PRIVATE *)psf->codec_data;
  {
#line 502
  while (1) {
    while_continue: /* CIL Label */ ;
#line 502
    if (! (len > 0L)) {
#line 502
      goto while_break;
    }
#line 503
    if (len > 268435456L) {
#line 503
      tmp = 268435456;
    } else {
#line 503
      tmp = (int )len;
    }
    {
#line 503
    writecount = tmp;
#line 505
    count = gsm610_write_block(psf, pgsm610, ptr, writecount);
#line 507
    total += (long )count;
#line 508
    len -= (long )count;
    }
#line 510
    if (count != writecount) {
#line 511
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 514
  return (total);
}
}
#line 518 "/root/libsndfile/src/gsm610.c"
static sf_count_t gsm610_write_i(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  GSM610_PRIVATE *pgsm610 ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count ;
  sf_count_t total ;
  long tmp ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;

  {
#line 521
  writecount = 0;
#line 522
  total = (sf_count_t )0;
#line 524
  if (psf->codec_data == (void *)0) {
#line 525
    return ((sf_count_t )0);
  }
#line 526
  pgsm610 = (GSM610_PRIVATE *)psf->codec_data;
#line 528
  sptr = (short *)psf->u.sbuf;
#line 529
  bufferlen = (int )(sizeof(psf->u.sbuf) / sizeof(psf->u.sbuf[0]));
  {
#line 530
  while (1) {
    while_continue: /* CIL Label */ ;
#line 530
    if (! (len > 0L)) {
#line 530
      goto while_break;
    }
#line 531
    if (len >= (long )bufferlen) {
#line 531
      tmp = (long )bufferlen;
    } else {
#line 531
      tmp = len;
    }
#line 531
    writecount = (int )tmp;
#line 532
    k = 0;
    {
#line 532
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 532
      if (! (k < writecount)) {
#line 532
        goto while_break___0;
      }
#line 533
      *(sptr + k) = (short )(*(ptr + (total + (long )k)) >> 16);
#line 532
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 534
    count = gsm610_write_block(psf, pgsm610, (short const   *)sptr, writecount);
#line 536
    total += (long )count;
#line 537
    len -= (long )writecount;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 539
  return (total);
}
}
#line 543 "/root/libsndfile/src/gsm610.c"
static sf_count_t gsm610_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  GSM610_PRIVATE *pgsm610 ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  long tmp___0 ;
  long __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;

  {
#line 546
  writecount = 0;
#line 547
  total = (sf_count_t )0;
#line 550
  if (psf->codec_data == (void *)0) {
#line 551
    return ((sf_count_t )0);
  }
#line 552
  pgsm610 = (GSM610_PRIVATE *)psf->codec_data;
#line 554
  if (psf->norm_float == 1) {
#line 554
    tmp = 1. * (double )32767;
  } else {
#line 554
    tmp = 1.;
  }
#line 554
  normfact = (float )tmp;
#line 556
  sptr = (short *)psf->u.sbuf;
#line 557
  bufferlen = (int )(sizeof(psf->u.sbuf) / sizeof(psf->u.sbuf[0]));
  {
#line 558
  while (1) {
    while_continue: /* CIL Label */ ;
#line 558
    if (! (len > 0L)) {
#line 558
      goto while_break;
    }
#line 559
    if (len >= (long )bufferlen) {
#line 559
      tmp___0 = (long )bufferlen;
    } else {
#line 559
      tmp___0 = len;
    }
#line 559
    writecount = (int )tmp___0;
#line 560
    k = 0;
    {
#line 560
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 560
      if (! (k < writecount)) {
#line 560
        goto while_break___0;
      }
      {
#line 561
      __cil_tmp14 = lrintf(normfact * *(ptr + (total + (long )k)));
#line 561
      *(sptr + k) = (short )__cil_tmp14;
      }
#line 560
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 562
    count = gsm610_write_block(psf, pgsm610, (short const   *)sptr, writecount);
#line 564
    total += (long )count;
#line 565
    len -= (long )writecount;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 567
  return (total);
}
}
#line 571 "/root/libsndfile/src/gsm610.c"
static sf_count_t gsm610_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  GSM610_PRIVATE *pgsm610 ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  long tmp___0 ;
  long __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;

  {
#line 574
  writecount = 0;
#line 575
  total = (sf_count_t )0;
#line 578
  if (psf->codec_data == (void *)0) {
#line 579
    return ((sf_count_t )0);
  }
#line 580
  pgsm610 = (GSM610_PRIVATE *)psf->codec_data;
#line 582
  if (psf->norm_double == 1) {
#line 582
    tmp = 1. * (double )32767;
  } else {
#line 582
    tmp = 1.;
  }
#line 582
  normfact = tmp;
#line 584
  sptr = (short *)psf->u.sbuf;
#line 585
  bufferlen = (int )(sizeof(psf->u.sbuf) / sizeof(psf->u.sbuf[0]));
  {
#line 586
  while (1) {
    while_continue: /* CIL Label */ ;
#line 586
    if (! (len > 0L)) {
#line 586
      goto while_break;
    }
#line 587
    if (len >= (long )bufferlen) {
#line 587
      tmp___0 = (long )bufferlen;
    } else {
#line 587
      tmp___0 = len;
    }
#line 587
    writecount = (int )tmp___0;
#line 588
    k = 0;
    {
#line 588
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 588
      if (! (k < writecount)) {
#line 588
        goto while_break___0;
      }
      {
#line 589
      __cil_tmp14 = lrint(normfact * *(ptr + (total + (long )k)));
#line 589
      *(sptr + k) = (short )__cil_tmp14;
      }
#line 588
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 590
    count = gsm610_write_block(psf, pgsm610, (short const   *)sptr, writecount);
#line 592
    total += (long )count;
#line 593
    len -= (long )writecount;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 595
  return (total);
}
}
#line 599 "/root/libsndfile/src/gsm610.c"
static int gsm610_close(SF_PRIVATE *psf ) 
{ 
  GSM610_PRIVATE *pgsm610 ;

  {
#line 602
  if (psf->codec_data == (void *)0) {
#line 603
    return (0);
  }
#line 605
  pgsm610 = (GSM610_PRIVATE *)psf->codec_data;
#line 607
  if (psf->mode == 32) {
#line 612
    if (pgsm610->samplecount) {
#line 612
      if (pgsm610->samplecount < pgsm610->samplesperblock) {
        {
#line 613
        (*(pgsm610->encode_block))(psf, pgsm610);
        }
      }
    }
  }

#line 616
  if (pgsm610->gsm_data) {
    {
#line 617
    gsm_destroy(pgsm610->gsm_data);
    }
  }
#line 619
  return (0);
}
}
#line 56 "/root/libsndfile/src/float32.c"
static sf_count_t host_read_f2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 57
static sf_count_t host_read_f2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 58
static sf_count_t host_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 59
static sf_count_t host_read_f2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 61
static sf_count_t host_write_s2f(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 62
static sf_count_t host_write_i2f(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 63
static sf_count_t host_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 64
static sf_count_t host_write_d2f(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 66
static void float32_peak_update(SF_PRIVATE *psf , float const   *buffer , int count ,
                                sf_count_t indx ) ;
#line 68
static sf_count_t replace_read_f2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 69
static sf_count_t replace_read_f2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 70
static sf_count_t replace_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 71
static sf_count_t replace_read_f2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 73
static sf_count_t replace_write_s2f(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 74
static sf_count_t replace_write_i2f(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 75
static sf_count_t replace_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 76
static sf_count_t replace_write_d2f(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 78
static void bf2f_array(float *buffer , int count ) ;
#line 79
static void f2bf_array(float *buffer , int count ) ;
#line 81
static int float32_get_capability(SF_PRIVATE *psf ) ;
#line 88 "/root/libsndfile/src/float32.c"
int float32_init(SF_PRIVATE *psf ) 
{ 
  static int float_caps ;
  int __cil_tmp3 ;
  sf_count_t tmp ;

  {
  {
#line 91
  float_caps = float32_get_capability(psf);
#line 93
  psf->blockwidth = (int )(sizeof(float ) * (unsigned long )psf->sf.channels);
  }
#line 95
  if (psf->mode == 16) {
    _L: /* CIL Label */ 
    {
#line 97
    if (psf->endian + float_caps == 536870947) {
#line 97
      goto case_536870947;
    }
#line 105
    if (psf->endian + float_caps == 268435474) {
#line 105
      goto case_268435474;
    }
#line 113
    if (psf->endian + float_caps == 536870930) {
#line 113
      goto case_536870930;
    }
#line 121
    if (psf->endian + float_caps == 268435491) {
#line 121
      goto case_268435491;
    }
#line 130
    if (psf->endian + float_caps == 536870964) {
#line 130
      goto case_536870964;
    }
#line 138
    if (psf->endian + float_caps == 268435508) {
#line 138
      goto case_268435508;
    }
#line 146
    if (psf->endian + float_caps == 536870981) {
#line 146
      goto case_536870981;
    }
#line 154
    if (psf->endian + float_caps == 268435525) {
#line 154
      goto case_268435525;
    }
#line 162
    goto switch_default;
    case_536870947: /* CIL Label */ 
#line 98
    psf->data_endswap = 0;
#line 99
    psf->read_short = & host_read_f2s;
#line 100
    psf->read_int = & host_read_f2i;
#line 101
    psf->read_float = & host_read_f;
#line 102
    psf->read_double = & host_read_f2d;
#line 103
    goto switch_break;
    case_268435474: /* CIL Label */ 
#line 106
    psf->data_endswap = 0;
#line 107
    psf->read_short = & host_read_f2s;
#line 108
    psf->read_int = & host_read_f2i;
#line 109
    psf->read_float = & host_read_f;
#line 110
    psf->read_double = & host_read_f2d;
#line 111
    goto switch_break;
    case_536870930: /* CIL Label */ 
#line 114
    psf->data_endswap = 1;
#line 115
    psf->read_short = & host_read_f2s;
#line 116
    psf->read_int = & host_read_f2i;
#line 117
    psf->read_float = & host_read_f;
#line 118
    psf->read_double = & host_read_f2d;
#line 119
    goto switch_break;
    case_268435491: /* CIL Label */ 
#line 122
    psf->data_endswap = 1;
#line 123
    psf->read_short = & host_read_f2s;
#line 124
    psf->read_int = & host_read_f2i;
#line 125
    psf->read_float = & host_read_f;
#line 126
    psf->read_double = & host_read_f2d;
#line 127
    goto switch_break;
    case_536870964: /* CIL Label */ 
#line 131
    psf->data_endswap = 1;
#line 132
    psf->read_short = & replace_read_f2s;
#line 133
    psf->read_int = & replace_read_f2i;
#line 134
    psf->read_float = & replace_read_f;
#line 135
    psf->read_double = & replace_read_f2d;
#line 136
    goto switch_break;
    case_268435508: /* CIL Label */ 
#line 139
    psf->data_endswap = 0;
#line 140
    psf->read_short = & replace_read_f2s;
#line 141
    psf->read_int = & replace_read_f2i;
#line 142
    psf->read_float = & replace_read_f;
#line 143
    psf->read_double = & replace_read_f2d;
#line 144
    goto switch_break;
    case_536870981: /* CIL Label */ 
#line 147
    psf->data_endswap = 0;
#line 148
    psf->read_short = & replace_read_f2s;
#line 149
    psf->read_int = & replace_read_f2i;
#line 150
    psf->read_float = & replace_read_f;
#line 151
    psf->read_double = & replace_read_f2d;
#line 152
    goto switch_break;
    case_268435525: /* CIL Label */ 
#line 155
    psf->data_endswap = 1;
#line 156
    psf->read_short = & replace_read_f2s;
#line 157
    psf->read_int = & replace_read_f2i;
#line 158
    psf->read_float = & replace_read_f;
#line 159
    psf->read_double = & replace_read_f2d;
#line 160
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 162
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }

  } else
#line 95
  if (psf->mode == 48) {
#line 95
    goto _L;
  }

#line 166
  if (psf->mode == 32) {
    _L___4: /* CIL Label */ 
    {
#line 168
    if (psf->endian + float_caps == 268435474) {
#line 168
      goto case_268435474___0;
    }
#line 176
    if (psf->endian + float_caps == 536870947) {
#line 176
      goto case_536870947___0;
    }
#line 184
    if (psf->endian + float_caps == 536870930) {
#line 184
      goto case_536870930___0;
    }
#line 192
    if (psf->endian + float_caps == 268435491) {
#line 192
      goto case_268435491___0;
    }
#line 201
    if (psf->endian + float_caps == 536870964) {
#line 201
      goto case_536870964___0;
    }
#line 209
    if (psf->endian + float_caps == 268435508) {
#line 209
      goto case_268435508___0;
    }
#line 217
    if (psf->endian + float_caps == 536870981) {
#line 217
      goto case_536870981___0;
    }
#line 225
    if (psf->endian + float_caps == 268435525) {
#line 225
      goto case_268435525___0;
    }
#line 233
    goto switch_default___0;
    case_268435474___0: /* CIL Label */ 
#line 169
    psf->data_endswap = 0;
#line 170
    psf->write_short = & host_write_s2f;
#line 171
    psf->write_int = & host_write_i2f;
#line 172
    psf->write_float = & host_write_f;
#line 173
    psf->write_double = & host_write_d2f;
#line 174
    goto switch_break___0;
    case_536870947___0: /* CIL Label */ 
#line 177
    psf->data_endswap = 0;
#line 178
    psf->write_short = & host_write_s2f;
#line 179
    psf->write_int = & host_write_i2f;
#line 180
    psf->write_float = & host_write_f;
#line 181
    psf->write_double = & host_write_d2f;
#line 182
    goto switch_break___0;
    case_536870930___0: /* CIL Label */ 
#line 185
    psf->data_endswap = 1;
#line 186
    psf->write_short = & host_write_s2f;
#line 187
    psf->write_int = & host_write_i2f;
#line 188
    psf->write_float = & host_write_f;
#line 189
    psf->write_double = & host_write_d2f;
#line 190
    goto switch_break___0;
    case_268435491___0: /* CIL Label */ 
#line 193
    psf->data_endswap = 1;
#line 194
    psf->write_short = & host_write_s2f;
#line 195
    psf->write_int = & host_write_i2f;
#line 196
    psf->write_float = & host_write_f;
#line 197
    psf->write_double = & host_write_d2f;
#line 198
    goto switch_break___0;
    case_536870964___0: /* CIL Label */ 
#line 202
    psf->data_endswap = 1;
#line 203
    psf->write_short = & replace_write_s2f;
#line 204
    psf->write_int = & replace_write_i2f;
#line 205
    psf->write_float = & replace_write_f;
#line 206
    psf->write_double = & replace_write_d2f;
#line 207
    goto switch_break___0;
    case_268435508___0: /* CIL Label */ 
#line 210
    psf->data_endswap = 0;
#line 211
    psf->write_short = & replace_write_s2f;
#line 212
    psf->write_int = & replace_write_i2f;
#line 213
    psf->write_float = & replace_write_f;
#line 214
    psf->write_double = & replace_write_d2f;
#line 215
    goto switch_break___0;
    case_536870981___0: /* CIL Label */ 
#line 218
    psf->data_endswap = 0;
#line 219
    psf->write_short = & replace_write_s2f;
#line 220
    psf->write_int = & replace_write_i2f;
#line 221
    psf->write_float = & replace_write_f;
#line 222
    psf->write_double = & replace_write_d2f;
#line 223
    goto switch_break___0;
    case_268435525___0: /* CIL Label */ 
#line 226
    psf->data_endswap = 1;
#line 227
    psf->write_short = & replace_write_s2f;
#line 228
    psf->write_int = & replace_write_i2f;
#line 229
    psf->write_float = & replace_write_f;
#line 230
    psf->write_double = & replace_write_d2f;
#line 231
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 233
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }

  } else
#line 166
  if (psf->mode == 48) {
#line 166
    goto _L___4;
  }

#line 237
  if (psf->filelength > psf->dataoffset) {
#line 238
    if (psf->dataend > 0L) {
#line 238
      tmp = psf->dataend - psf->dataoffset;
    } else {
#line 238
      tmp = psf->filelength - psf->dataoffset;
    }
#line 238
    psf->datalength = tmp;
  } else {
#line 242
    psf->datalength = (sf_count_t )0;
  }
#line 244
  if (psf->blockwidth > 0) {
#line 244
    psf->sf.frames = psf->datalength / (long )psf->blockwidth;
  } else {
#line 244
    psf->sf.frames = 1;
  }
#line 246
  return (0);
}
}
#line 250 "/root/libsndfile/src/float32.c"
float float32_be_read(unsigned char *cptr ) 
{ 
  int exponent ;
  int mantissa ;
  int negative ;
  float fvalue ;
  int tmp ;
  int tmp___0 ;
  double tmp___1 ;
  double __cil_tmp9 ;
  int __cil_tmp10 ;
  double __cil_tmp11 ;

  {
#line 254
  negative = (int )*(cptr + 0) & 128;
#line 255
  if ((int )*(cptr + 1) & 128) {
#line 255
    tmp = 1;
  } else {
#line 255
    tmp = 0;
  }
#line 255
  exponent = (((int )*(cptr + 0) & 127) << 1) | tmp;
#line 256
  mantissa = ((((int )*(cptr + 1) & 127) << 16) | ((int )*(cptr + 2) << 8)) | (int )*(cptr + 3);
#line 258
  if (! (exponent || mantissa)) {
#line 259
    return ((float )0.);
  }
#line 261
  mantissa |= 8388608;
#line 262
  if (exponent) {
#line 262
    tmp___0 = exponent - 127;
  } else {
#line 262
    tmp___0 = 0;
  }
#line 262
  exponent = tmp___0;
#line 264
  if (mantissa) {
#line 264
    tmp___1 = (double )((float )mantissa / (float )8388608);
  } else {
#line 264
    tmp___1 = 0.;
  }
#line 264
  fvalue = (float )tmp___1;
#line 266
  if (negative) {
#line 267
    fvalue *= (float )(- 1);
  }
#line 269
  if (exponent > 0) {
    {
#line 270
    __cil_tmp9 = pow(2., (double )exponent);
    }
#line 270
    fvalue *= __cil_tmp9;
  } else
#line 271
  if (exponent < 0) {
    {
#line 272
    __cil_tmp10 = abs(exponent);
#line 272
    __cil_tmp11 = pow(2., (double )__cil_tmp10);
    }
#line 272
    fvalue /= __cil_tmp11;
  }
#line 274
  return (fvalue);
}
}
#line 278 "/root/libsndfile/src/float32.c"
float float32_le_read(unsigned char *cptr ) 
{ 
  int exponent ;
  int mantissa ;
  int negative ;
  float fvalue ;
  int tmp ;
  int tmp___0 ;
  double tmp___1 ;
  double __cil_tmp9 ;
  int __cil_tmp10 ;
  double __cil_tmp11 ;

  {
#line 282
  negative = (int )*(cptr + 3) & 128;
#line 283
  if ((int )*(cptr + 2) & 128) {
#line 283
    tmp = 1;
  } else {
#line 283
    tmp = 0;
  }
#line 283
  exponent = (((int )*(cptr + 3) & 127) << 1) | tmp;
#line 284
  mantissa = ((((int )*(cptr + 2) & 127) << 16) | ((int )*(cptr + 1) << 8)) | (int )*(cptr + 0);
#line 286
  if (! (exponent || mantissa)) {
#line 287
    return ((float )0.);
  }
#line 289
  mantissa |= 8388608;
#line 290
  if (exponent) {
#line 290
    tmp___0 = exponent - 127;
  } else {
#line 290
    tmp___0 = 0;
  }
#line 290
  exponent = tmp___0;
#line 292
  if (mantissa) {
#line 292
    tmp___1 = (double )((float )mantissa / (float )8388608);
  } else {
#line 292
    tmp___1 = 0.;
  }
#line 292
  fvalue = (float )tmp___1;
#line 294
  if (negative) {
#line 295
    fvalue *= (float )(- 1);
  }
#line 297
  if (exponent > 0) {
    {
#line 298
    __cil_tmp9 = pow(2., (double )exponent);
    }
#line 298
    fvalue *= __cil_tmp9;
  } else
#line 299
  if (exponent < 0) {
    {
#line 300
    __cil_tmp10 = abs(exponent);
#line 300
    __cil_tmp11 = pow(2., (double )__cil_tmp10);
    }
#line 300
    fvalue /= __cil_tmp11;
  }
#line 302
  return (fvalue);
}
}
#line 306 "/root/libsndfile/src/float32.c"
void float32_le_write(float in , unsigned char *out ) 
{ 
  int exponent ;
  int mantissa ;
  int negative ;
  double __cil_tmp6 ;
  double __cil_tmp7 ;

  {
  {
#line 307
  negative = 0;
#line 309
  memset(out, 0, sizeof(int ));
#line 311
  __cil_tmp6 = fabs((double )in);
  }
#line 311
  if (__cil_tmp6 < 1.00000000001e-30) {
#line 312
    return;
  }
#line 314
  if ((double )in < 0.) {
#line 315
    in *= - 1.;
#line 316
    negative = 1;
  }
  {
#line 319
  __cil_tmp7 = frexp((double )in, & exponent);
#line 319
  in = (float )__cil_tmp7;
#line 321
  exponent += 126;
#line 323
  in *= (float )16777216;
#line 324
  mantissa = (int )in & 8388607;
  }
#line 326
  if (negative) {
#line 327
    *(out + 3) |= 128;
  }
#line 329
  if (exponent & 1) {
#line 330
    *(out + 2) |= 128;
  }
#line 332
  *(out + 0) = (unsigned char )(mantissa & 255);
#line 333
  *(out + 1) = (unsigned char )((mantissa >> 8) & 255);
#line 334
  *(out + 2) |= (mantissa >> 16) & 127;
#line 335
  *(out + 3) |= (exponent >> 1) & 127;
#line 337
  return;
}
}
#line 341 "/root/libsndfile/src/float32.c"
void float32_be_write(float in , unsigned char *out ) 
{ 
  int exponent ;
  int mantissa ;
  int negative ;
  double __cil_tmp6 ;
  double __cil_tmp7 ;

  {
  {
#line 342
  negative = 0;
#line 344
  memset(out, 0, sizeof(int ));
#line 346
  __cil_tmp6 = fabs((double )in);
  }
#line 346
  if (__cil_tmp6 < 1.00000000001e-30) {
#line 347
    return;
  }
#line 349
  if ((double )in < 0.) {
#line 350
    in *= - 1.;
#line 351
    negative = 1;
  }
  {
#line 354
  __cil_tmp7 = frexp((double )in, & exponent);
#line 354
  in = (float )__cil_tmp7;
#line 356
  exponent += 126;
#line 358
  in *= (float )16777216;
#line 359
  mantissa = (int )in & 8388607;
  }
#line 361
  if (negative) {
#line 362
    *(out + 0) |= 128;
  }
#line 364
  if (exponent & 1) {
#line 365
    *(out + 1) |= 128;
  }
#line 367
  *(out + 3) = (unsigned char )(mantissa & 255);
#line 368
  *(out + 2) = (unsigned char )((mantissa >> 8) & 255);
#line 369
  *(out + 1) |= (mantissa >> 16) & 127;
#line 370
  *(out + 0) |= (exponent >> 1) & 127;
#line 372
  return;
}
}
#line 380 "/root/libsndfile/src/float32.c"
static void float32_peak_update(SF_PRIVATE *psf , float const   *buffer , int count ,
                                sf_count_t indx ) 
{ 
  int chan ;
  int k ;
  int position ;
  float fmaxval ;
  double __cil_tmp9 ;
  double __cil_tmp10 ;
  double __cil_tmp11 ;
  int __cil_tmp12 ;

  {
#line 385
  chan = 0;
  {
#line 385
  while (1) {
    while_continue: /* CIL Label */ ;
#line 385
    if (! (chan < psf->sf.channels)) {
#line 385
      goto while_break;
    }
    {
#line 386
    __cil_tmp9 = fabs((double )*(buffer + chan));
#line 386
    fmaxval = (float )__cil_tmp9;
#line 387
    position = 0;
#line 388
    k = chan;
    }
    {
#line 388
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 388
      if (! (k < count)) {
#line 388
        goto while_break___0;
      }
      {
#line 389
      __cil_tmp10 = fabs((double )*(buffer + k));
      }
#line 389
      if ((double )fmaxval < __cil_tmp10) {
        {
#line 390
        __cil_tmp11 = fabs((double )*(buffer + k));
#line 390
        fmaxval = (float )__cil_tmp11;
#line 391
        position = k;
        }
      }
#line 388
      k += psf->sf.channels;
    }
    while_break___0: /* CIL Label */ ;
    }

#line 394
    if ((double )fmaxval > (psf->peak_info)->peaks[chan].value) {
#line 395
      (psf->peak_info)->peaks[chan].value = (double )fmaxval;
#line 396
      (psf->peak_info)->peaks[chan].position = (psf->write_current + indx) + (long )(position / psf->sf.channels);
    }

#line 385
    chan ++;
  }
  while_break: /* CIL Label */ ;
  }

#line 400
  return;
}
}
#line 404 "/root/libsndfile/src/float32.c"
static int float32_get_capability(SF_PRIVATE *psf ) 
{ 
  union __anonunion_296 data___0 ;
  int tmp ;

  {
#line 411
  data___0.f = (float )1.23456789;
#line 413
  if (! psf->ieee_replace) {
#line 415
    if ((int )data___0.c[0] == 82) {
#line 415
      if ((int )data___0.c[1] == 6) {
#line 415
        if ((int )data___0.c[2] == 158) {
#line 415
          if ((int )data___0.c[3] == 63) {
#line 416
            return (18);
          }
        }
      }
    }
#line 419
    if ((int )data___0.c[3] == 82) {
#line 419
      if ((int )data___0.c[2] == 6) {
#line 419
        if ((int )data___0.c[1] == 158) {
#line 419
          if ((int )data___0.c[0] == 63) {
#line 420
            return (35);
          }
        }
      }
    }
  }
  {
#line 424
  psf_log_printf(psf, "Using IEEE replacement code for float.\n");
#line 426
  tmp = 52;
  }
#line 426
  return (tmp);
}
}
#line 433 "/root/libsndfile/src/float32.c"
static void f2s_array(float const   *src , int count , short *dest , float scale ) 
{ 
  long __cil_tmp5 ;

  {
  {
#line 435
  while (1) {
    while_continue: /* CIL Label */ ;
#line 435
    count --;
#line 435
    if (! (count >= 0)) {
#line 435
      goto while_break;
    }
    {
#line 436
    __cil_tmp5 = lrintf(scale * *(src + count));
#line 436
    *(dest + count) = (short )__cil_tmp5;
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 441 "/root/libsndfile/src/float32.c"
static void f2s_clip_array(float const   *src , int count , short *dest , float scale ) 
{ 
  float tmp ;
  long __cil_tmp6 ;

  {
  {
#line 442
  while (1) {
    while_continue: /* CIL Label */ ;
#line 442
    count --;
#line 442
    if (! (count >= 0)) {
#line 442
      goto while_break;
    }
#line 443
    tmp = scale * *(src + count);
#line 445
    if ((double )tmp > 32767.) {
#line 446
      *(dest + count) = (short )32767;
    } else
#line 447
    if ((double )tmp < - 32768.) {
#line 448
      *(dest + count) = (short )-32768;
    } else {
      {
#line 450
      __cil_tmp6 = lrintf(tmp);
#line 450
      *(dest + count) = (short )__cil_tmp6;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 455 "/root/libsndfile/src/float32.c"
__inline static void f2i_array(float const   *src , int count , int *dest , float scale ) 
{ 
  long __cil_tmp5 ;

  {
  {
#line 456
  while (1) {
    while_continue: /* CIL Label */ ;
#line 456
    count --;
#line 456
    if (! (count >= 0)) {
#line 456
      goto while_break;
    }
    {
#line 457
    __cil_tmp5 = lrintf(scale * *(src + count));
#line 457
    *(dest + count) = (int )__cil_tmp5;
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 462 "/root/libsndfile/src/float32.c"
__inline static void f2i_clip_array(float const   *src , int count , int *dest , float scale ) 
{ 
  float tmp ;
  long __cil_tmp6 ;

  {
  {
#line 463
  while (1) {
    while_continue: /* CIL Label */ ;
#line 463
    count --;
#line 463
    if (! (count >= 0)) {
#line 463
      goto while_break;
    }
#line 464
    tmp = scale * *(src + count);
#line 466
    if ((double )tmp > 1. * (double )2147483647) {
#line 467
      *(dest + count) = 2147483647;
    } else
#line 468
    if ((double )tmp < - 1. * (double )2147483647) {
#line 469
      *(dest + count) = (-0x7FFFFFFF-1);
    } else {
      {
#line 471
      __cil_tmp6 = lrintf(tmp);
#line 471
      *(dest + count) = (int )__cil_tmp6;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 476 "/root/libsndfile/src/float32.c"
__inline static void f2d_array(float const   *src , int count , double *dest ) 
{ 


  {
  {
#line 477
  while (1) {
    while_continue: /* CIL Label */ ;
#line 477
    count --;
#line 477
    if (! (count >= 0)) {
#line 477
      goto while_break;
    }
#line 478
    *(dest + count) = (double )*(src + count);
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 483 "/root/libsndfile/src/float32.c"
__inline static void s2f_array(short const   *src , float *dest , int count , float scale ) 
{ 


  {
  {
#line 484
  while (1) {
    while_continue: /* CIL Label */ ;
#line 484
    count --;
#line 484
    if (! (count >= 0)) {
#line 484
      goto while_break;
    }
#line 485
    *(dest + count) = scale * (float )((int )*(src + count));
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 490 "/root/libsndfile/src/float32.c"
__inline static void i2f_array(int const   *src , float *dest , int count , float scale ) 
{ 


  {
  {
#line 491
  while (1) {
    while_continue: /* CIL Label */ ;
#line 491
    count --;
#line 491
    if (! (count >= 0)) {
#line 491
      goto while_break;
    }
#line 492
    *(dest + count) = scale * (float )*(src + count);
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 497 "/root/libsndfile/src/float32.c"
__inline static void d2f_array(double const   *src , float *dest , int count ) 
{ 


  {
  {
#line 498
  while (1) {
    while_continue: /* CIL Label */ ;
#line 498
    count --;
#line 498
    if (! (count >= 0)) {
#line 498
      goto while_break;
    }
#line 499
    *(dest + count) = (float )*(src + count);
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 507 "/root/libsndfile/src/float32.c"
static sf_count_t host_read_f2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  void (*convert)(float const   * , int  , short * , float  ) ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  float scale ;
  void (*tmp)(float const   *src , int count , short *dest , float scale ) ;
  double tmp___0 ;
  sf_count_t __cil_tmp11 ;

  {
#line 510
  total = (sf_count_t )0;
#line 513
  if (psf->add_clipping) {
#line 513
    tmp = & f2s_clip_array;
  } else {
#line 513
    tmp = & f2s_array;
  }
#line 513
  convert = tmp;
#line 514
  bufferlen = (int )(sizeof(psf->u.fbuf) / sizeof(psf->u.fbuf[0]));
#line 515
  if (psf->float_int_mult == 0) {
#line 515
    tmp___0 = 1.;
  } else {
#line 515
    tmp___0 = (double )((float )32767 / psf->float_max);
  }
#line 515
  scale = (float )tmp___0;
  {
#line 517
  while (1) {
    while_continue: /* CIL Label */ ;
#line 517
    if (! (len > 0L)) {
#line 517
      goto while_break;
    }
#line 518
    if (len < (long )bufferlen) {
#line 519
      bufferlen = (int )len;
    }
    {
#line 520
    __cil_tmp11 = psf_fread((float *)psf->u.fbuf, (sf_count_t )sizeof(float ), (sf_count_t )bufferlen,
                            psf);
#line 520
    readcount = (int )__cil_tmp11;
    }
#line 523
    if (psf->data_endswap == 1) {
      {
#line 524
      endswap_int_array((int *)psf->u.ibuf, bufferlen);
      }
    }
    {
#line 526
    (*convert)((float const   *)((float *)psf->u.fbuf), readcount, ptr + total, scale);
#line 527
    total += (long )readcount;
    }
#line 528
    if (readcount < bufferlen) {
#line 529
      goto while_break;
    }
#line 530
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 533
  return (total);
}
}
#line 537 "/root/libsndfile/src/float32.c"
static sf_count_t host_read_f2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  void (*convert)(float const   * , int  , int * , float  ) ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  float scale ;
  void (*tmp)(float const   *src , int count , int *dest , float scale ) ;
  double tmp___0 ;
  sf_count_t __cil_tmp11 ;

  {
#line 540
  total = (sf_count_t )0;
#line 543
  if (psf->add_clipping) {
#line 543
    tmp = & f2i_clip_array;
  } else {
#line 543
    tmp = & f2i_array;
  }
#line 543
  convert = tmp;
#line 544
  bufferlen = (int )(sizeof(psf->u.fbuf) / sizeof(psf->u.fbuf[0]));
#line 545
  if (psf->float_int_mult == 0) {
#line 545
    tmp___0 = 1.;
  } else {
#line 545
    tmp___0 = (double )((float )2147483647 / psf->float_max);
  }
#line 545
  scale = (float )tmp___0;
  {
#line 547
  while (1) {
    while_continue: /* CIL Label */ ;
#line 547
    if (! (len > 0L)) {
#line 547
      goto while_break;
    }
#line 548
    if (len < (long )bufferlen) {
#line 549
      bufferlen = (int )len;
    }
    {
#line 550
    __cil_tmp11 = psf_fread((float *)psf->u.fbuf, (sf_count_t )sizeof(float ), (sf_count_t )bufferlen,
                            psf);
#line 550
    readcount = (int )__cil_tmp11;
    }
#line 552
    if (psf->data_endswap == 1) {
      {
#line 553
      endswap_int_array((int *)psf->u.ibuf, bufferlen);
      }
    }
    {
#line 555
    (*convert)((float const   *)((float *)psf->u.fbuf), readcount, ptr + total, scale);
#line 556
    total += (long )readcount;
    }
#line 557
    if (readcount < bufferlen) {
#line 558
      goto while_break;
    }
#line 559
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 562
  return (total);
}
}
#line 566 "/root/libsndfile/src/float32.c"
static sf_count_t host_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp7 ;
  sf_count_t __cil_tmp8 ;

  {
#line 568
  total = (sf_count_t )0;
#line 570
  if (psf->data_endswap != 1) {
    {
#line 571
    __cil_tmp7 = psf_fread(ptr, (sf_count_t )sizeof(float ), len, psf);
    }
#line 571
    return (__cil_tmp7);
  }
#line 573
  bufferlen = (int )(sizeof(psf->u.fbuf) / sizeof(psf->u.fbuf[0]));
  {
#line 575
  while (1) {
    while_continue: /* CIL Label */ ;
#line 575
    if (! (len > 0L)) {
#line 575
      goto while_break;
    }
#line 576
    if (len < (long )bufferlen) {
#line 577
      bufferlen = (int )len;
    }
    {
#line 578
    __cil_tmp8 = psf_fread((float *)psf->u.fbuf, (sf_count_t )sizeof(float ), (sf_count_t )bufferlen,
                           psf);
#line 578
    readcount = (int )__cil_tmp8;
#line 580
    endswap_int_copy((int *)(ptr + total), (int const   *)((int *)psf->u.ibuf), readcount);
#line 582
    total += (long )readcount;
    }
#line 583
    if (readcount < bufferlen) {
#line 584
      goto while_break;
    }
#line 585
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 588
  return (total);
}
}
#line 592 "/root/libsndfile/src/float32.c"
static sf_count_t host_read_f2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp7 ;

  {
#line 594
  total = (sf_count_t )0;
#line 596
  bufferlen = (int )(sizeof(psf->u.fbuf) / sizeof(psf->u.fbuf[0]));
  {
#line 598
  while (1) {
    while_continue: /* CIL Label */ ;
#line 598
    if (! (len > 0L)) {
#line 598
      goto while_break;
    }
#line 599
    if (len < (long )bufferlen) {
#line 600
      bufferlen = (int )len;
    }
    {
#line 601
    __cil_tmp7 = psf_fread((float *)psf->u.fbuf, (sf_count_t )sizeof(float ), (sf_count_t )bufferlen,
                           psf);
#line 601
    readcount = (int )__cil_tmp7;
    }
#line 603
    if (psf->data_endswap == 1) {
      {
#line 604
      endswap_int_array((int *)psf->u.ibuf, bufferlen);
      }
    }
    {
#line 607
    f2d_array((float const   *)((float *)psf->u.fbuf), readcount, ptr + total);
#line 608
    total += (long )readcount;
    }
#line 609
    if (readcount < bufferlen) {
#line 610
      goto while_break;
    }
#line 611
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 614
  return (total);
}
}
#line 618 "/root/libsndfile/src/float32.c"
static sf_count_t host_write_s2f(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  float scale ;
  double tmp ;
  sf_count_t __cil_tmp9 ;

  {
#line 620
  total = (sf_count_t )0;
#line 624
  if (psf->scale_int_float == 0) {
#line 624
    tmp = 1.;
  } else {
#line 624
    tmp = 1. / (double )32768;
  }
#line 624
  scale = (float )tmp;
#line 625
  bufferlen = (int )(sizeof(psf->u.fbuf) / sizeof(psf->u.fbuf[0]));
  {
#line 627
  while (1) {
    while_continue: /* CIL Label */ ;
#line 627
    if (! (len > 0L)) {
#line 627
      goto while_break;
    }
#line 628
    if (len < (long )bufferlen) {
#line 629
      bufferlen = (int )len;
    }
    {
#line 630
    s2f_array(ptr + total, (float *)psf->u.fbuf, bufferlen, scale);
    }
#line 632
    if (psf->peak_info) {
      {
#line 633
      float32_peak_update(psf, (float const   *)((float *)psf->u.fbuf), bufferlen,
                          total / (long )psf->sf.channels);
      }
    }
#line 635
    if (psf->data_endswap == 1) {
      {
#line 636
      endswap_int_array((int *)psf->u.ibuf, bufferlen);
      }
    }
    {
#line 638
    __cil_tmp9 = psf_fwrite((float *)psf->u.fbuf, (sf_count_t )sizeof(float ), (sf_count_t )bufferlen,
                            psf);
#line 638
    writecount = (int )__cil_tmp9;
#line 639
    total += (long )writecount;
    }
#line 640
    if (writecount < bufferlen) {
#line 641
      goto while_break;
    }
#line 642
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 645
  return (total);
}
}
#line 649 "/root/libsndfile/src/float32.c"
static sf_count_t host_write_i2f(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  float scale ;
  double tmp ;
  sf_count_t __cil_tmp9 ;

  {
#line 651
  total = (sf_count_t )0;
#line 654
  if (psf->scale_int_float == 0) {
#line 654
    tmp = 1.;
  } else {
#line 654
    tmp = 1. / (8. * (double )268435456);
  }
#line 654
  scale = (float )tmp;
#line 655
  bufferlen = (int )(sizeof(psf->u.fbuf) / sizeof(psf->u.fbuf[0]));
  {
#line 657
  while (1) {
    while_continue: /* CIL Label */ ;
#line 657
    if (! (len > 0L)) {
#line 657
      goto while_break;
    }
#line 658
    if (len < (long )bufferlen) {
#line 659
      bufferlen = (int )len;
    }
    {
#line 660
    i2f_array(ptr + total, (float *)psf->u.fbuf, bufferlen, scale);
    }
#line 662
    if (psf->peak_info) {
      {
#line 663
      float32_peak_update(psf, (float const   *)((float *)psf->u.fbuf), bufferlen,
                          total / (long )psf->sf.channels);
      }
    }
#line 665
    if (psf->data_endswap == 1) {
      {
#line 666
      endswap_int_array((int *)psf->u.ibuf, bufferlen);
      }
    }
    {
#line 668
    __cil_tmp9 = psf_fwrite((float *)psf->u.fbuf, (sf_count_t )sizeof(float ), (sf_count_t )bufferlen,
                            psf);
#line 668
    writecount = (int )__cil_tmp9;
#line 669
    total += (long )writecount;
    }
#line 670
    if (writecount < bufferlen) {
#line 671
      goto while_break;
    }
#line 672
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 675
  return (total);
}
}
#line 679 "/root/libsndfile/src/float32.c"
static sf_count_t host_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp7 ;
  sf_count_t __cil_tmp8 ;

  {
#line 681
  total = (sf_count_t )0;
#line 683
  if (psf->peak_info) {
    {
#line 684
    float32_peak_update(psf, ptr, (int )len, (sf_count_t )0);
    }
  }
#line 686
  if (psf->data_endswap != 1) {
    {
#line 687
    __cil_tmp7 = psf_fwrite(ptr, (sf_count_t )sizeof(float ), len, psf);
    }
#line 687
    return (__cil_tmp7);
  }
#line 689
  bufferlen = (int )(sizeof(psf->u.fbuf) / sizeof(psf->u.fbuf[0]));
  {
#line 691
  while (1) {
    while_continue: /* CIL Label */ ;
#line 691
    if (! (len > 0L)) {
#line 691
      goto while_break;
    }
#line 692
    if (len < (long )bufferlen) {
#line 693
      bufferlen = (int )len;
    }
    {
#line 695
    endswap_int_copy((int *)psf->u.ibuf, (int const   *)(ptr + total), bufferlen);
#line 697
    __cil_tmp8 = psf_fwrite((float *)psf->u.fbuf, (sf_count_t )sizeof(float ), (sf_count_t )bufferlen,
                            psf);
#line 697
    writecount = (int )__cil_tmp8;
#line 698
    total += (long )writecount;
    }
#line 699
    if (writecount < bufferlen) {
#line 700
      goto while_break;
    }
#line 701
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 704
  return (total);
}
}
#line 708 "/root/libsndfile/src/float32.c"
static sf_count_t host_write_d2f(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp7 ;

  {
#line 710
  total = (sf_count_t )0;
#line 712
  bufferlen = (int )(sizeof(psf->u.fbuf) / sizeof(psf->u.fbuf[0]));
  {
#line 714
  while (1) {
    while_continue: /* CIL Label */ ;
#line 714
    if (! (len > 0L)) {
#line 714
      goto while_break;
    }
#line 715
    if (len < (long )bufferlen) {
#line 716
      bufferlen = (int )len;
    }
    {
#line 718
    d2f_array(ptr + total, (float *)psf->u.fbuf, bufferlen);
    }
#line 720
    if (psf->peak_info) {
      {
#line 721
      float32_peak_update(psf, (float const   *)((float *)psf->u.fbuf), bufferlen,
                          total / (long )psf->sf.channels);
      }
    }
#line 723
    if (psf->data_endswap == 1) {
      {
#line 724
      endswap_int_array((int *)psf->u.ibuf, bufferlen);
      }
    }
    {
#line 726
    __cil_tmp7 = psf_fwrite((float *)psf->u.fbuf, (sf_count_t )sizeof(float ), (sf_count_t )bufferlen,
                            psf);
#line 726
    writecount = (int )__cil_tmp7;
#line 727
    total += (long )writecount;
    }
#line 728
    if (writecount < bufferlen) {
#line 729
      goto while_break;
    }
#line 730
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 733
  return (total);
}
}
#line 740 "/root/libsndfile/src/float32.c"
static sf_count_t replace_read_f2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  float scale ;
  double tmp ;
  sf_count_t __cil_tmp9 ;

  {
#line 742
  total = (sf_count_t )0;
#line 745
  bufferlen = (int )(sizeof(psf->u.fbuf) / sizeof(psf->u.fbuf[0]));
#line 746
  if (psf->float_int_mult == 0) {
#line 746
    tmp = 1.;
  } else {
#line 746
    tmp = (double )((float )32767 / psf->float_max);
  }
#line 746
  scale = (float )tmp;
  {
#line 748
  while (1) {
    while_continue: /* CIL Label */ ;
#line 748
    if (! (len > 0L)) {
#line 748
      goto while_break;
    }
#line 749
    if (len < (long )bufferlen) {
#line 750
      bufferlen = (int )len;
    }
    {
#line 751
    __cil_tmp9 = psf_fread((float *)psf->u.fbuf, (sf_count_t )sizeof(float ), (sf_count_t )bufferlen,
                           psf);
#line 751
    readcount = (int )__cil_tmp9;
    }
#line 753
    if (psf->data_endswap == 1) {
      {
#line 754
      endswap_int_array((int *)psf->u.ibuf, bufferlen);
      }
    }
    {
#line 756
    bf2f_array((float *)psf->u.fbuf, bufferlen);
#line 758
    f2s_array((float const   *)((float *)psf->u.fbuf), readcount, ptr + total, scale);
#line 759
    total += (long )readcount;
    }
#line 760
    if (readcount < bufferlen) {
#line 761
      goto while_break;
    }
#line 762
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 765
  return (total);
}
}
#line 769 "/root/libsndfile/src/float32.c"
static sf_count_t replace_read_f2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  float scale ;
  double tmp ;
  sf_count_t __cil_tmp9 ;

  {
#line 771
  total = (sf_count_t )0;
#line 774
  bufferlen = (int )(sizeof(psf->u.fbuf) / sizeof(psf->u.fbuf[0]));
#line 775
  if (psf->float_int_mult == 0) {
#line 775
    tmp = 1.;
  } else {
#line 775
    tmp = (double )((float )32767 / psf->float_max);
  }
#line 775
  scale = (float )tmp;
  {
#line 777
  while (1) {
    while_continue: /* CIL Label */ ;
#line 777
    if (! (len > 0L)) {
#line 777
      goto while_break;
    }
#line 778
    if (len < (long )bufferlen) {
#line 779
      bufferlen = (int )len;
    }
    {
#line 780
    __cil_tmp9 = psf_fread((float *)psf->u.fbuf, (sf_count_t )sizeof(float ), (sf_count_t )bufferlen,
                           psf);
#line 780
    readcount = (int )__cil_tmp9;
    }
#line 782
    if (psf->data_endswap == 1) {
      {
#line 783
      endswap_int_array((int *)psf->u.ibuf, bufferlen);
      }
    }
    {
#line 785
    bf2f_array((float *)psf->u.fbuf, bufferlen);
#line 787
    f2i_array((float const   *)((float *)psf->u.fbuf), readcount, ptr + total, scale);
#line 788
    total += (long )readcount;
    }
#line 789
    if (readcount < bufferlen) {
#line 790
      goto while_break;
    }
#line 791
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 794
  return (total);
}
}
#line 798 "/root/libsndfile/src/float32.c"
static sf_count_t replace_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp7 ;

  {
#line 800
  total = (sf_count_t )0;
#line 804
  bufferlen = (int )(sizeof(psf->u.fbuf) / sizeof(psf->u.fbuf[0]));
  {
#line 806
  while (1) {
    while_continue: /* CIL Label */ ;
#line 806
    if (! (len > 0L)) {
#line 806
      goto while_break;
    }
#line 807
    if (len < (long )bufferlen) {
#line 808
      bufferlen = (int )len;
    }
    {
#line 809
    __cil_tmp7 = psf_fread((float *)psf->u.fbuf, (sf_count_t )sizeof(float ), (sf_count_t )bufferlen,
                           psf);
#line 809
    readcount = (int )__cil_tmp7;
    }
#line 811
    if (psf->data_endswap == 1) {
      {
#line 812
      endswap_int_array((int *)psf->u.ibuf, bufferlen);
      }
    }
    {
#line 814
    bf2f_array((float *)psf->u.fbuf, bufferlen);
#line 816
    memcpy(ptr + total, (float *)psf->u.fbuf, (unsigned long )bufferlen * sizeof(float ));
#line 818
    total += (long )readcount;
    }
#line 819
    if (readcount < bufferlen) {
#line 820
      goto while_break;
    }
#line 821
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 824
  return (total);
}
}
#line 828 "/root/libsndfile/src/float32.c"
static sf_count_t replace_read_f2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp7 ;

  {
#line 830
  total = (sf_count_t )0;
#line 832
  bufferlen = (int )(sizeof(psf->u.fbuf) / sizeof(psf->u.fbuf[0]));
  {
#line 834
  while (1) {
    while_continue: /* CIL Label */ ;
#line 834
    if (! (len > 0L)) {
#line 834
      goto while_break;
    }
#line 835
    if (len < (long )bufferlen) {
#line 836
      bufferlen = (int )len;
    }
    {
#line 837
    __cil_tmp7 = psf_fread((float *)psf->u.fbuf, (sf_count_t )sizeof(float ), (sf_count_t )bufferlen,
                           psf);
#line 837
    readcount = (int )__cil_tmp7;
    }
#line 839
    if (psf->data_endswap == 1) {
      {
#line 840
      endswap_int_array((int *)psf->u.ibuf, bufferlen);
      }
    }
    {
#line 842
    bf2f_array((float *)psf->u.fbuf, bufferlen);
#line 844
    f2d_array((float const   *)((float *)psf->u.fbuf), readcount, ptr + total);
#line 845
    total += (long )readcount;
    }
#line 846
    if (readcount < bufferlen) {
#line 847
      goto while_break;
    }
#line 848
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 851
  return (total);
}
}
#line 855 "/root/libsndfile/src/float32.c"
static sf_count_t replace_write_s2f(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  float scale ;
  double tmp ;
  sf_count_t __cil_tmp9 ;

  {
#line 857
  total = (sf_count_t )0;
#line 860
  if (psf->scale_int_float == 0) {
#line 860
    tmp = 1.;
  } else {
#line 860
    tmp = 1. / (double )32768;
  }
#line 860
  scale = (float )tmp;
#line 861
  bufferlen = (int )(sizeof(psf->u.fbuf) / sizeof(psf->u.fbuf[0]));
  {
#line 863
  while (1) {
    while_continue: /* CIL Label */ ;
#line 863
    if (! (len > 0L)) {
#line 863
      goto while_break;
    }
#line 864
    if (len < (long )bufferlen) {
#line 865
      bufferlen = (int )len;
    }
    {
#line 866
    s2f_array(ptr + total, (float *)psf->u.fbuf, bufferlen, scale);
    }
#line 868
    if (psf->peak_info) {
      {
#line 869
      float32_peak_update(psf, (float const   *)((float *)psf->u.fbuf), bufferlen,
                          total / (long )psf->sf.channels);
      }
    }
    {
#line 871
    f2bf_array((float *)psf->u.fbuf, bufferlen);
    }
#line 873
    if (psf->data_endswap == 1) {
      {
#line 874
      endswap_int_array((int *)psf->u.ibuf, bufferlen);
      }
    }
    {
#line 876
    __cil_tmp9 = psf_fwrite((float *)psf->u.fbuf, (sf_count_t )sizeof(float ), (sf_count_t )bufferlen,
                            psf);
#line 876
    writecount = (int )__cil_tmp9;
#line 877
    total += (long )writecount;
    }
#line 878
    if (writecount < bufferlen) {
#line 879
      goto while_break;
    }
#line 880
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 883
  return (total);
}
}
#line 887 "/root/libsndfile/src/float32.c"
static sf_count_t replace_write_i2f(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  float scale ;
  double tmp ;
  sf_count_t __cil_tmp9 ;

  {
#line 889
  total = (sf_count_t )0;
#line 892
  if (psf->scale_int_float == 0) {
#line 892
    tmp = 1.;
  } else {
#line 892
    tmp = 1. / (8. * (double )268435456);
  }
#line 892
  scale = (float )tmp;
#line 893
  bufferlen = (int )(sizeof(psf->u.fbuf) / sizeof(psf->u.fbuf[0]));
  {
#line 895
  while (1) {
    while_continue: /* CIL Label */ ;
#line 895
    if (! (len > 0L)) {
#line 895
      goto while_break;
    }
#line 896
    if (len < (long )bufferlen) {
#line 897
      bufferlen = (int )len;
    }
    {
#line 898
    i2f_array(ptr + total, (float *)psf->u.fbuf, bufferlen, scale);
    }
#line 900
    if (psf->peak_info) {
      {
#line 901
      float32_peak_update(psf, (float const   *)((float *)psf->u.fbuf), bufferlen,
                          total / (long )psf->sf.channels);
      }
    }
    {
#line 903
    f2bf_array((float *)psf->u.fbuf, bufferlen);
    }
#line 905
    if (psf->data_endswap == 1) {
      {
#line 906
      endswap_int_array((int *)psf->u.ibuf, bufferlen);
      }
    }
    {
#line 908
    __cil_tmp9 = psf_fwrite((float *)psf->u.fbuf, (sf_count_t )sizeof(float ), (sf_count_t )bufferlen,
                            psf);
#line 908
    writecount = (int )__cil_tmp9;
#line 909
    total += (long )writecount;
    }
#line 910
    if (writecount < bufferlen) {
#line 911
      goto while_break;
    }
#line 912
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 915
  return (total);
}
}
#line 919 "/root/libsndfile/src/float32.c"
static sf_count_t replace_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp7 ;

  {
#line 921
  total = (sf_count_t )0;
#line 924
  if (psf->peak_info) {
    {
#line 925
    float32_peak_update(psf, ptr, (int )len, (sf_count_t )0);
    }
  }
#line 927
  bufferlen = (int )(sizeof(psf->u.fbuf) / sizeof(psf->u.fbuf[0]));
  {
#line 929
  while (1) {
    while_continue: /* CIL Label */ ;
#line 929
    if (! (len > 0L)) {
#line 929
      goto while_break;
    }
#line 930
    if (len < (long )bufferlen) {
#line 931
      bufferlen = (int )len;
    }
    {
#line 933
    memcpy((float *)psf->u.fbuf, ptr + total, (unsigned long )bufferlen * sizeof(float ));
#line 935
    f2bf_array((float *)psf->u.fbuf, bufferlen);
    }
#line 937
    if (psf->data_endswap == 1) {
      {
#line 938
      endswap_int_array((int *)psf->u.ibuf, bufferlen);
      }
    }
    {
#line 940
    __cil_tmp7 = psf_fwrite((float *)psf->u.fbuf, (sf_count_t )sizeof(float ), (sf_count_t )bufferlen,
                            psf);
#line 940
    writecount = (int )__cil_tmp7;
#line 941
    total += (long )writecount;
    }
#line 942
    if (writecount < bufferlen) {
#line 943
      goto while_break;
    }
#line 944
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 947
  return (total);
}
}
#line 951 "/root/libsndfile/src/float32.c"
static sf_count_t replace_write_d2f(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp7 ;

  {
#line 953
  total = (sf_count_t )0;
#line 955
  bufferlen = (int )(sizeof(psf->u.fbuf) / sizeof(psf->u.fbuf[0]));
  {
#line 957
  while (1) {
    while_continue: /* CIL Label */ ;
#line 957
    if (! (len > 0L)) {
#line 957
      goto while_break;
    }
#line 958
    if (len < (long )bufferlen) {
#line 959
      bufferlen = (int )len;
    }
    {
#line 960
    d2f_array(ptr + total, (float *)psf->u.fbuf, bufferlen);
    }
#line 962
    if (psf->peak_info) {
      {
#line 963
      float32_peak_update(psf, (float const   *)((float *)psf->u.fbuf), bufferlen,
                          total / (long )psf->sf.channels);
      }
    }
    {
#line 965
    f2bf_array((float *)psf->u.fbuf, bufferlen);
    }
#line 967
    if (psf->data_endswap == 1) {
      {
#line 968
      endswap_int_array((int *)psf->u.ibuf, bufferlen);
      }
    }
    {
#line 970
    __cil_tmp7 = psf_fwrite((float *)psf->u.fbuf, (sf_count_t )sizeof(float ), (sf_count_t )bufferlen,
                            psf);
#line 970
    writecount = (int )__cil_tmp7;
#line 971
    total += (long )writecount;
    }
#line 972
    if (writecount < bufferlen) {
#line 973
      goto while_break;
    }
#line 974
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 977
  return (total);
}
}
#line 984 "/root/libsndfile/src/float32.c"
static void bf2f_array(float *buffer , int count ) 
{ 
  float __cil_tmp3 ;

  {
  {
#line 985
  while (1) {
    while_continue: /* CIL Label */ ;
#line 985
    count --;
#line 985
    if (! (count >= 0)) {
#line 985
      goto while_break;
    }
    {
#line 986
    *(buffer + count) = float32_le_read((unsigned char *)(buffer + count));
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 991 "/root/libsndfile/src/float32.c"
static void f2bf_array(float *buffer , int count ) 
{ 


  {
  {
#line 992
  while (1) {
    while_continue: /* CIL Label */ ;
#line 992
    count --;
#line 992
    if (! (count >= 0)) {
#line 992
      goto while_break;
    }
    {
#line 993
    float32_le_write(*(buffer + count), (unsigned char *)(buffer + count));
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int access(char const   *__name , int __type ) ;
#line 304
extern  __attribute__((__nothrow__)) int faccessat(int __fd , char const   *__file ,
                                                   int __type , int __flag ) ;
#line 334
extern  __attribute__((__nothrow__)) __off_t lseek(int __fd , __off_t __offset , int __whence ) ;
#line 353
extern int close(int __fd ) ;
#line 360
__inline extern ssize_t read(int __fd , void *__buf , size_t __nbytes )  __attribute__((__gnu_inline__)) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 376
extern ssize_t pread(int __fd , void *__buf , size_t __nbytes , __off_t __offset ) ;
#line 384
extern ssize_t pwrite(int __fd , void const   *__buf , size_t __n , __off_t __offset ) ;
#line 417
extern  __attribute__((__nothrow__)) int pipe(int __pipedes[2] ) ;
#line 432
extern  __attribute__((__nothrow__)) unsigned int alarm(unsigned int __seconds ) ;
#line 444
extern unsigned int sleep(unsigned int __seconds ) ;
#line 452
extern  __attribute__((__nothrow__)) __useconds_t ualarm(__useconds_t __value , __useconds_t __interval ) ;
#line 460
extern int usleep(__useconds_t __useconds ) ;
#line 469
extern int pause(void) ;
#line 473
extern  __attribute__((__nothrow__)) int chown(char const   *__file , __uid_t __owner ,
                                               __gid_t __group ) ;
#line 478
extern  __attribute__((__nothrow__)) int fchown(int __fd , __uid_t __owner , __gid_t __group ) ;
#line 483
extern  __attribute__((__nothrow__)) int lchown(char const   *__file , __uid_t __owner ,
                                                __gid_t __group ) ;
#line 491
extern  __attribute__((__nothrow__)) int fchownat(int __fd , char const   *__file ,
                                                  __uid_t __owner , __gid_t __group ,
                                                  int __flag ) ;
#line 497
extern  __attribute__((__nothrow__)) int chdir(char const   *__path ) ;
#line 501
extern  __attribute__((__nothrow__)) int fchdir(int __fd ) ;
#line 511
__inline extern  __attribute__((__nothrow__)) char *getcwd(char *__buf , size_t __size )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 525
__inline extern  __attribute__((__nothrow__)) char *getwd(char *__buf )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 531
extern  __attribute__((__nothrow__)) int dup(int __fd ) ;
#line 534
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
#line 543
extern char **__environ ;
#line 551
extern  __attribute__((__nothrow__)) int execve(char const   *__path , char * const  __argv[] ,
                                                char * const  __envp[] ) ;
#line 557
extern  __attribute__((__nothrow__)) int fexecve(int __fd , char * const  __argv[] ,
                                                 char * const  __envp[] ) ;
#line 563
extern  __attribute__((__nothrow__)) int execv(char const   *__path , char * const  __argv[] ) ;
#line 568
extern  __attribute__((__nothrow__)) int execle(char const   *__path , char const   *__arg 
                                                , ...) ;
#line 573
extern  __attribute__((__nothrow__)) int execl(char const   *__path , char const   *__arg 
                                               , ...) ;
#line 578
extern  __attribute__((__nothrow__)) int execvp(char const   *__file , char * const  __argv[] ) ;
#line 584
extern  __attribute__((__nothrow__)) int execlp(char const   *__file , char const   *__arg 
                                                , ...) ;
#line 598
extern  __attribute__((__nothrow__)) int nice(int __inc ) ;
#line 603
extern void _exit(int __status ) ;
#line 612
extern  __attribute__((__nothrow__)) long pathconf(char const   *__path , int __name ) ;
#line 616
extern  __attribute__((__nothrow__)) long fpathconf(int __fd , int __name ) ;
#line 619
extern  __attribute__((__nothrow__)) long sysconf(int __name ) ;
#line 623
__inline extern  __attribute__((__nothrow__)) size_t confstr(int __name , char *__buf ,
                                                             size_t __len )  __attribute__((__gnu_inline__)) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 631
extern  __attribute__((__nothrow__)) __pid_t getppid(void) ;
#line 634
extern  __attribute__((__nothrow__)) __pid_t getpgrp(void) ;
#line 637
extern  __attribute__((__nothrow__)) __pid_t __getpgid(__pid_t __pid ) ;
#line 639
extern  __attribute__((__nothrow__)) __pid_t getpgid(__pid_t __pid ) ;
#line 646
extern  __attribute__((__nothrow__)) int setpgid(__pid_t __pid , __pid_t __pgid ) ;
#line 660
extern  __attribute__((__nothrow__)) int setpgrp(void) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t setsid(void) ;
#line 671
extern  __attribute__((__nothrow__)) __pid_t getsid(__pid_t __pid ) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
#line 678
extern  __attribute__((__nothrow__)) __uid_t geteuid(void) ;
#line 681
extern  __attribute__((__nothrow__)) __gid_t getgid(void) ;
#line 684
extern  __attribute__((__nothrow__)) __gid_t getegid(void) ;
#line 689
__inline extern  __attribute__((__nothrow__)) int getgroups(int __size , __gid_t __list[] )  __attribute__((__gnu_inline__)) ;
#line 700
extern  __attribute__((__nothrow__)) int setuid(__uid_t __uid ) ;
#line 705
extern  __attribute__((__nothrow__)) int setreuid(__uid_t __ruid , __uid_t __euid ) ;
#line 710
extern  __attribute__((__nothrow__)) int seteuid(__uid_t __uid ) ;
#line 717
extern  __attribute__((__nothrow__)) int setgid(__gid_t __gid ) ;
#line 722
extern  __attribute__((__nothrow__)) int setregid(__gid_t __rgid , __gid_t __egid ) ;
#line 727
extern  __attribute__((__nothrow__)) int setegid(__gid_t __gid ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 764
extern  __attribute__((__nothrow__)) int vfork(void) ;
#line 770
extern  __attribute__((__nothrow__)) char *ttyname(int __fd ) ;
#line 774
__inline extern  __attribute__((__nothrow__)) int ttyname_r(int __fd , char *__buf ,
                                                            size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 779
extern  __attribute__((__nothrow__)) int isatty(int __fd ) ;
#line 784
extern  __attribute__((__nothrow__)) int ttyslot(void) ;
#line 789
extern  __attribute__((__nothrow__)) int link(char const   *__from , char const   *__to ) ;
#line 795
extern  __attribute__((__nothrow__)) int linkat(int __fromfd , char const   *__from ,
                                                int __tofd , char const   *__to ,
                                                int __flags ) ;
#line 802
extern  __attribute__((__nothrow__)) int symlink(char const   *__from , char const   *__to ) ;
#line 808
__inline extern  __attribute__((__nothrow__)) ssize_t readlink(char const   *__path ,
                                                               char *__buf , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 815
extern  __attribute__((__nothrow__)) int symlinkat(char const   *__from , int __tofd ,
                                                   char const   *__to ) ;
#line 819
__inline extern  __attribute__((__nothrow__)) ssize_t readlinkat(int __fd , char const   *__path ,
                                                                 char *__buf , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 825
extern  __attribute__((__nothrow__)) int unlink(char const   *__name ) ;
#line 829
extern  __attribute__((__nothrow__)) int unlinkat(int __fd , char const   *__name ,
                                                  int __flag ) ;
#line 834
extern  __attribute__((__nothrow__)) int rmdir(char const   *__path ) ;
#line 838
extern  __attribute__((__nothrow__)) __pid_t tcgetpgrp(int __fd ) ;
#line 841
extern  __attribute__((__nothrow__)) int tcsetpgrp(int __fd , __pid_t __pgrp_id ) ;
#line 848
extern char *getlogin(void) ;
#line 856
__inline extern int getlogin_r(char *__buf , size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 861
extern  __attribute__((__nothrow__)) int setlogin(char const   *__name ) ;
#line 36 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h"
extern char *optarg ;
#line 50
extern int optind ;
#line 55
extern int opterr ;
#line 59
extern int optopt ;
#line 91
extern  __attribute__((__nothrow__)) int getopt(int ___argc , char * const  *___argv ,
                                                char const   *__shortopts ) ;
#line 877 "/usr/include/unistd.h"
__inline extern  __attribute__((__nothrow__)) int gethostname(char *__buf , size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 884
extern  __attribute__((__nothrow__)) int sethostname(char const   *__name , size_t __len ) ;
#line 889
extern  __attribute__((__nothrow__)) int sethostid(long __id ) ;
#line 895
__inline extern  __attribute__((__nothrow__)) int getdomainname(char *__buf , size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 897
extern  __attribute__((__nothrow__)) int setdomainname(char const   *__name , size_t __len ) ;
#line 904
extern  __attribute__((__nothrow__)) int vhangup(void) ;
#line 907
extern  __attribute__((__nothrow__)) int revoke(char const   *__file ) ;
#line 915
extern  __attribute__((__nothrow__)) int profil(unsigned short *__sample_buffer ,
                                                size_t __size , size_t __offset ,
                                                unsigned int __scale ) ;
#line 923
extern  __attribute__((__nothrow__)) int acct(char const   *__name ) ;
#line 927
extern  __attribute__((__nothrow__)) char *getusershell(void) ;
#line 928
extern  __attribute__((__nothrow__)) void endusershell(void) ;
#line 929
extern  __attribute__((__nothrow__)) void setusershell(void) ;
#line 935
extern  __attribute__((__nothrow__)) int daemon(int __nochdir , int __noclose ) ;
#line 942
extern  __attribute__((__nothrow__)) int chroot(char const   *__path ) ;
#line 946
extern char *getpass(char const   *__prompt ) ;
#line 954
extern int fsync(int __fd ) ;
#line 967
extern long gethostid(void) ;
#line 970
extern  __attribute__((__nothrow__)) void sync(void) ;
#line 976
extern  __attribute__((__nothrow__)) int getpagesize(void) ;
#line 981
extern  __attribute__((__nothrow__)) int getdtablesize(void) ;
#line 991
extern  __attribute__((__nothrow__)) int truncate(char const   *__file , __off_t __length ) ;
#line 1014
extern  __attribute__((__nothrow__)) int ftruncate(int __fd , __off_t __length ) ;
#line 1035
extern  __attribute__((__nothrow__)) int brk(void *__addr ) ;
#line 1041
extern  __attribute__((__nothrow__)) void *sbrk(intptr_t __delta ) ;
#line 1056
extern  __attribute__((__nothrow__)) long syscall(long __sysno  , ...) ;
#line 1079
extern int lockf(int __fd , int __cmd , __off_t __len ) ;
#line 1115
extern int fdatasync(int __fildes ) ;
#line 1124
extern  __attribute__((__nothrow__)) char *crypt(char const   *__key , char const   *__salt ) ;
#line 1161
int getentropy(void *__buffer , size_t __length ) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
extern ssize_t __read_chk(int __fd , void *__buf , size_t __nbytes , size_t __buflen ) ;
#line 25
extern ssize_t __read_alias(int __fd , void *__buf , size_t __nbytes ) ;
#line 27
extern ssize_t __read_chk_warn(int __fd , void *__buf , size_t __nbytes , size_t __buflen ) ;
#line 34
__inline extern ssize_t read(int __fd , void *__buf , size_t __nbytes )  __attribute__((__gnu_inline__)) ;
#line 34 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  ssize_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  ssize_t __cil_tmp10 ;
  ssize_t __cil_tmp11 ;

  {
  {
#line 36
  __cil_tmp4 = __builtin_object_size(__buf, 0);
  }
#line 36
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 38
    __cil_tmp5 = __builtin_constant_p(__nbytes);
    }
#line 38
    if (! __cil_tmp5) {
      {
#line 39
      __cil_tmp6 = __builtin_object_size(__buf, 0);
#line 39
      __cil_tmp7 = __read_chk(__fd, __buf, __nbytes, __cil_tmp6);
      }
#line 39
      return (__cil_tmp7);
    }
    {
#line 41
    __cil_tmp8 = __builtin_object_size(__buf, 0);
    }
#line 41
    if (__nbytes > __cil_tmp8) {
      {
#line 42
      __cil_tmp9 = __builtin_object_size(__buf, 0);
#line 42
      __cil_tmp10 = __read_chk_warn(__fd, __buf, __nbytes, __cil_tmp9);
      }
#line 42
      return (__cil_tmp10);
    }
  }
  {
#line 44
  __cil_tmp11 = __read_alias(__fd, __buf, __nbytes);
  }
#line 44
  return (__cil_tmp11);
}
}
#line 123
extern  __attribute__((__nothrow__)) ssize_t __readlink_chk(char const   *__path ,
                                                            char *__buf , size_t __len ,
                                                            size_t __buflen ) ;
#line 127
extern  __attribute__((__nothrow__)) ssize_t __readlink_alias(char const   *__path ,
                                                              char *__buf , size_t __len ) ;
#line 131
extern  __attribute__((__nothrow__)) ssize_t __readlink_chk_warn(char const   *__path ,
                                                                 char *__buf , size_t __len ,
                                                                 size_t __buflen ) ;
#line 139
__inline extern  __attribute__((__nothrow__)) ssize_t readlink(char const   *__path ,
                                                               char *__buf , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 139 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t readlink(char const   *__path , char *__buf , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  ssize_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  ssize_t __cil_tmp10 ;
  ssize_t __cil_tmp11 ;

  {
  {
#line 142
  __cil_tmp4 = __builtin_object_size(__buf, 1);
  }
#line 142
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 144
    __cil_tmp5 = __builtin_constant_p(__len);
    }
#line 144
    if (! __cil_tmp5) {
      {
#line 145
      __cil_tmp6 = __builtin_object_size(__buf, 1);
#line 145
      __cil_tmp7 = __readlink_chk(__path, __buf, __len, __cil_tmp6);
      }
#line 145
      return (__cil_tmp7);
    }
    {
#line 147
    __cil_tmp8 = __builtin_object_size(__buf, 1);
    }
#line 147
    if (__len > __cil_tmp8) {
      {
#line 148
      __cil_tmp9 = __builtin_object_size(__buf, 1);
#line 148
      __cil_tmp10 = __readlink_chk_warn(__path, __buf, __len, __cil_tmp9);
      }
#line 148
      return (__cil_tmp10);
    }
  }
  {
#line 150
  __cil_tmp11 = __readlink_alias(__path, __buf, __len);
  }
#line 150
  return (__cil_tmp11);
}
}
#line 155
extern  __attribute__((__nothrow__)) ssize_t __readlinkat_chk(int __fd , char const   *__path ,
                                                              char *__buf , size_t __len ,
                                                              size_t __buflen ) ;
#line 159
extern  __attribute__((__nothrow__)) ssize_t __readlinkat_alias(int __fd , char const   *__path ,
                                                                char *__buf , size_t __len ) ;
#line 164
extern  __attribute__((__nothrow__)) ssize_t __readlinkat_chk_warn(int __fd , char const   *__path ,
                                                                   char *__buf , size_t __len ,
                                                                   size_t __buflen ) ;
#line 173
__inline extern  __attribute__((__nothrow__)) ssize_t readlinkat(int __fd , char const   *__path ,
                                                                 char *__buf , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 173 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t readlinkat(int __fd , char const   *__path , char *__buf ,
                                   size_t __len ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  ssize_t __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  ssize_t __cil_tmp11 ;
  ssize_t __cil_tmp12 ;

  {
  {
#line 176
  __cil_tmp5 = __builtin_object_size(__buf, 1);
  }
#line 176
  if (__cil_tmp5 != 0xffffffffffffffffUL) {
    {
#line 178
    __cil_tmp6 = __builtin_constant_p(__len);
    }
#line 178
    if (! __cil_tmp6) {
      {
#line 179
      __cil_tmp7 = __builtin_object_size(__buf, 1);
#line 179
      __cil_tmp8 = __readlinkat_chk(__fd, __path, __buf, __len, __cil_tmp7);
      }
#line 179
      return (__cil_tmp8);
    }
    {
#line 181
    __cil_tmp9 = __builtin_object_size(__buf, 1);
    }
#line 181
    if (__len > __cil_tmp9) {
      {
#line 182
      __cil_tmp10 = __builtin_object_size(__buf, 1);
#line 182
      __cil_tmp11 = __readlinkat_chk_warn(__fd, __path, __buf, __len, __cil_tmp10);
      }
#line 182
      return (__cil_tmp11);
    }
  }
  {
#line 185
  __cil_tmp12 = __readlinkat_alias(__fd, __path, __buf, __len);
  }
#line 185
  return (__cil_tmp12);
}
}
#line 189
extern  __attribute__((__nothrow__)) char *__getcwd_chk(char *__buf , size_t __size ,
                                                        size_t __buflen ) ;
#line 191
extern  __attribute__((__nothrow__)) char *__getcwd_alias(char *__buf , size_t __size ) ;
#line 193
extern  __attribute__((__nothrow__)) char *__getcwd_chk_warn(char *__buf , size_t __size ,
                                                             size_t __buflen ) ;
#line 200
__inline extern  __attribute__((__nothrow__)) char *getcwd(char *__buf , size_t __size )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 200 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern char *getcwd(char *__buf , size_t __size ) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  char *__cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 202
  __cil_tmp3 = __builtin_object_size(__buf, 1);
  }
#line 202
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
    {
#line 204
    __cil_tmp4 = __builtin_constant_p(__size);
    }
#line 204
    if (! __cil_tmp4) {
      {
#line 205
      __cil_tmp5 = __builtin_object_size(__buf, 1);
#line 205
      __cil_tmp6 = __getcwd_chk(__buf, __size, __cil_tmp5);
      }
#line 205
      return (__cil_tmp6);
    }
    {
#line 207
    __cil_tmp7 = __builtin_object_size(__buf, 1);
    }
#line 207
    if (__size > __cil_tmp7) {
      {
#line 208
      __cil_tmp8 = __builtin_object_size(__buf, 1);
#line 208
      __cil_tmp9 = __getcwd_chk_warn(__buf, __size, __cil_tmp8);
      }
#line 208
      return (__cil_tmp9);
    }
  }
  {
#line 210
  __cil_tmp10 = __getcwd_alias(__buf, __size);
  }
#line 210
  return (__cil_tmp10);
}
}
#line 214
extern  __attribute__((__nothrow__)) char *__getwd_chk(char *__buf , size_t buflen ) ;
#line 216
extern  __attribute__((__nothrow__)) char *__getwd_warn(char *__buf ) ;
#line 221
__inline extern  __attribute__((__nothrow__)) char *getwd(char *__buf )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 221 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern char *getwd(char *__buf ) 
{ 
  unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 223
  __cil_tmp2 = __builtin_object_size(__buf, 1);
  }
#line 223
  if (__cil_tmp2 != 0xffffffffffffffffUL) {
    {
#line 224
    __cil_tmp3 = __builtin_object_size(__buf, 1);
#line 224
    __cil_tmp4 = __getwd_chk(__buf, __cil_tmp3);
    }
#line 224
    return (__cil_tmp4);
  }
  {
#line 225
  __cil_tmp5 = __getwd_warn(__buf);
  }
#line 225
  return (__cil_tmp5);
}
}
#line 229
extern  __attribute__((__nothrow__)) size_t __confstr_chk(int __name , char *__buf ,
                                                          size_t __len , size_t __buflen ) ;
#line 231
extern  __attribute__((__nothrow__)) size_t __confstr_alias(int __name , char *__buf ,
                                                            size_t __len ) ;
#line 233
extern  __attribute__((__nothrow__)) size_t __confstr_chk_warn(int __name , char *__buf ,
                                                               size_t __len , size_t __buflen ) ;
#line 240
__inline extern  __attribute__((__nothrow__)) size_t confstr(int __name , char *__buf ,
                                                             size_t __len )  __attribute__((__gnu_inline__)) ;
#line 240 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern size_t confstr(int __name , char *__buf , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  size_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;

  {
  {
#line 242
  __cil_tmp4 = __builtin_object_size(__buf, 1);
  }
#line 242
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 244
    __cil_tmp5 = __builtin_constant_p(__len);
    }
#line 244
    if (! __cil_tmp5) {
      {
#line 245
      __cil_tmp6 = __builtin_object_size(__buf, 1);
#line 245
      __cil_tmp7 = __confstr_chk(__name, __buf, __len, __cil_tmp6);
      }
#line 245
      return (__cil_tmp7);
    }
    {
#line 247
    __cil_tmp8 = __builtin_object_size(__buf, 1);
    }
#line 247
    if (__cil_tmp8 < __len) {
      {
#line 248
      __cil_tmp9 = __builtin_object_size(__buf, 1);
#line 248
      __cil_tmp10 = __confstr_chk_warn(__name, __buf, __len, __cil_tmp9);
      }
#line 248
      return (__cil_tmp10);
    }
  }
  {
#line 250
  __cil_tmp11 = __confstr_alias(__name, __buf, __len);
  }
#line 250
  return (__cil_tmp11);
}
}
#line 254
extern  __attribute__((__nothrow__)) int __getgroups_chk(int __size , __gid_t __list[] ,
                                                         size_t __listlen ) ;
#line 256
extern  __attribute__((__nothrow__)) int __getgroups_alias(int __size , __gid_t __list[] ) ;
#line 258
extern  __attribute__((__nothrow__)) int __getgroups_chk_warn(int __size , __gid_t __list[] ,
                                                              size_t __listlen ) ;
#line 265
__inline extern  __attribute__((__nothrow__)) int getgroups(int __size , __gid_t __list[] )  __attribute__((__gnu_inline__)) ;
#line 265 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int getgroups(int __size , __gid_t __list[] ) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 267
  __cil_tmp3 = __builtin_object_size(__list, 1);
  }
#line 267
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
    {
#line 269
    __cil_tmp4 = __builtin_constant_p(__size);
    }
#line 269
    if (! __cil_tmp4) {
      {
      {
#line 270
      __cil_tmp5 = __builtin_object_size(__list, 1);
      }
      {
#line 270
      __cil_tmp6 = __getgroups_chk(__size, __list, __cil_tmp5);
      }
      }
#line 270
      return (__cil_tmp6);
    } else
#line 269
    if (__size < 0) {
      {
      {
#line 270
      __cil_tmp5 = __builtin_object_size(__list, 1);
      }
      {
#line 270
      __cil_tmp6 = __getgroups_chk(__size, __list, __cil_tmp5);
      }
      }
#line 270
      return (__cil_tmp6);
    }
    {
#line 272
    __cil_tmp7 = __builtin_object_size(__list, 1);
    }
#line 272
    if ((unsigned long )__size * sizeof(__gid_t ) > __cil_tmp7) {
      {
#line 273
      __cil_tmp8 = __builtin_object_size(__list, 1);
#line 273
      __cil_tmp9 = __getgroups_chk_warn(__size, __list, __cil_tmp8);
      }
#line 273
      return (__cil_tmp9);
    }
  }
  {
#line 275
  __cil_tmp10 = __getgroups_alias(__size, __list);
  }
#line 275
  return (__cil_tmp10);
}
}
#line 279
extern  __attribute__((__nothrow__)) int __ttyname_r_chk(int __fd , char *__buf ,
                                                         size_t __buflen , size_t __nreal ) ;
#line 281
extern  __attribute__((__nothrow__)) int __ttyname_r_alias(int __fd , char *__buf ,
                                                           size_t __buflen ) ;
#line 284
extern  __attribute__((__nothrow__)) int __ttyname_r_chk_warn(int __fd , char *__buf ,
                                                              size_t __buflen , size_t __nreal ) ;
#line 291
__inline extern  __attribute__((__nothrow__)) int ttyname_r(int __fd , char *__buf ,
                                                            size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 291 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ttyname_r(int __fd , char *__buf , size_t __buflen ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 293
  __cil_tmp4 = __builtin_object_size(__buf, 1);
  }
#line 293
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 295
    __cil_tmp5 = __builtin_constant_p(__buflen);
    }
#line 295
    if (! __cil_tmp5) {
      {
#line 296
      __cil_tmp6 = __builtin_object_size(__buf, 1);
#line 296
      __cil_tmp7 = __ttyname_r_chk(__fd, __buf, __buflen, __cil_tmp6);
      }
#line 296
      return (__cil_tmp7);
    }
    {
#line 298
    __cil_tmp8 = __builtin_object_size(__buf, 1);
    }
#line 298
    if (__buflen > __cil_tmp8) {
      {
#line 299
      __cil_tmp9 = __builtin_object_size(__buf, 1);
#line 299
      __cil_tmp10 = __ttyname_r_chk_warn(__fd, __buf, __buflen, __cil_tmp9);
      }
#line 299
      return (__cil_tmp10);
    }
  }
  {
#line 301
  __cil_tmp11 = __ttyname_r_alias(__fd, __buf, __buflen);
  }
#line 301
  return (__cil_tmp11);
}
}
#line 306
extern int __getlogin_r_chk(char *__buf , size_t __buflen , size_t __nreal ) ;
#line 308
extern int __getlogin_r_alias(char *__buf , size_t __buflen ) ;
#line 310
extern int __getlogin_r_chk_warn(char *__buf , size_t __buflen , size_t __nreal ) ;
#line 317
__inline extern int getlogin_r(char *__buf , size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 317 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int getlogin_r(char *__buf , size_t __buflen ) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 319
  __cil_tmp3 = __builtin_object_size(__buf, 1);
  }
#line 319
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
    {
#line 321
    __cil_tmp4 = __builtin_constant_p(__buflen);
    }
#line 321
    if (! __cil_tmp4) {
      {
#line 322
      __cil_tmp5 = __builtin_object_size(__buf, 1);
#line 322
      __cil_tmp6 = __getlogin_r_chk(__buf, __buflen, __cil_tmp5);
      }
#line 322
      return (__cil_tmp6);
    }
    {
#line 324
    __cil_tmp7 = __builtin_object_size(__buf, 1);
    }
#line 324
    if (__buflen > __cil_tmp7) {
      {
#line 325
      __cil_tmp8 = __builtin_object_size(__buf, 1);
#line 325
      __cil_tmp9 = __getlogin_r_chk_warn(__buf, __buflen, __cil_tmp8);
      }
#line 325
      return (__cil_tmp9);
    }
  }
  {
#line 327
  __cil_tmp10 = __getlogin_r_alias(__buf, __buflen);
  }
#line 327
  return (__cil_tmp10);
}
}
#line 333
extern  __attribute__((__nothrow__)) int __gethostname_chk(char *__buf , size_t __buflen ,
                                                           size_t __nreal ) ;
#line 335
extern  __attribute__((__nothrow__)) int __gethostname_alias(char *__buf , size_t __buflen ) ;
#line 337
extern  __attribute__((__nothrow__)) int __gethostname_chk_warn(char *__buf , size_t __buflen ,
                                                                size_t __nreal ) ;
#line 344
__inline extern  __attribute__((__nothrow__)) int gethostname(char *__buf , size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 344 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int gethostname(char *__buf , size_t __buflen ) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 346
  __cil_tmp3 = __builtin_object_size(__buf, 1);
  }
#line 346
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
    {
#line 348
    __cil_tmp4 = __builtin_constant_p(__buflen);
    }
#line 348
    if (! __cil_tmp4) {
      {
#line 349
      __cil_tmp5 = __builtin_object_size(__buf, 1);
#line 349
      __cil_tmp6 = __gethostname_chk(__buf, __buflen, __cil_tmp5);
      }
#line 349
      return (__cil_tmp6);
    }
    {
#line 351
    __cil_tmp7 = __builtin_object_size(__buf, 1);
    }
#line 351
    if (__buflen > __cil_tmp7) {
      {
#line 352
      __cil_tmp8 = __builtin_object_size(__buf, 1);
#line 352
      __cil_tmp9 = __gethostname_chk_warn(__buf, __buflen, __cil_tmp8);
      }
#line 352
      return (__cil_tmp9);
    }
  }
  {
#line 354
  __cil_tmp10 = __gethostname_alias(__buf, __buflen);
  }
#line 354
  return (__cil_tmp10);
}
}
#line 360
extern  __attribute__((__nothrow__)) int __getdomainname_chk(char *__buf , size_t __buflen ,
                                                             size_t __nreal ) ;
#line 362
extern  __attribute__((__nothrow__)) int __getdomainname_alias(char *__buf , size_t __buflen ) ;
#line 365
extern  __attribute__((__nothrow__)) int __getdomainname_chk_warn(char *__buf , size_t __buflen ,
                                                                  size_t __nreal ) ;
#line 373
__inline extern  __attribute__((__nothrow__)) int getdomainname(char *__buf , size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 373 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int getdomainname(char *__buf , size_t __buflen ) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 375
  __cil_tmp3 = __builtin_object_size(__buf, 1);
  }
#line 375
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
    {
#line 377
    __cil_tmp4 = __builtin_constant_p(__buflen);
    }
#line 377
    if (! __cil_tmp4) {
      {
#line 378
      __cil_tmp5 = __builtin_object_size(__buf, 1);
#line 378
      __cil_tmp6 = __getdomainname_chk(__buf, __buflen, __cil_tmp5);
      }
#line 378
      return (__cil_tmp6);
    }
    {
#line 380
    __cil_tmp7 = __builtin_object_size(__buf, 1);
    }
#line 380
    if (__buflen > __cil_tmp7) {
      {
#line 381
      __cil_tmp8 = __builtin_object_size(__buf, 1);
#line 381
      __cil_tmp9 = __getdomainname_chk_warn(__buf, __buflen, __cil_tmp8);
      }
#line 381
      return (__cil_tmp9);
    }
  }
  {
#line 383
  __cil_tmp10 = __getdomainname_alias(__buf, __buflen);
  }
#line 383
  return (__cil_tmp10);
}
}
#line 148 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 168
__inline extern int open(char const   *__path , int __oflag  , ...)  __attribute__((__gnu_inline__)) ;
#line 192
__inline extern int openat(int __fd , char const   *__path , int __oflag  , ...)  __attribute__((__gnu_inline__)) ;
#line 214
extern int creat(char const   *__file , mode_t __mode ) ;
#line 260
extern  __attribute__((__nothrow__)) int posix_fadvise(int __fd , __off_t __offset ,
                                                       __off_t __len , int __advise ) ;
#line 282
extern int posix_fallocate(int __fd , __off_t __offset , __off_t __len ) ;
#line 26 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
extern int __open_2(char const   *__path , int __oflag ) ;
#line 27
extern int __open_alias(char const   *__path , int __oflag  , ...) ;
#line 35
extern void __open_too_many_args(void) ;
#line 37
extern void __open_missing_mode(void) ;
#line 41
__inline extern int open(char const   *__path , int __oflag  , ...)  __attribute__((__gnu_inline__)) ;
#line 41 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
__inline extern int open(char const   *__path , int __oflag  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;

  {
  {
#line 43
  __cil_tmp3 = __builtin_va_arg_pack_len();
  }
#line 43
  if (__cil_tmp3 > 1) {
    {
#line 44
    __open_too_many_args();
    }
  }
  {
#line 46
  __cil_tmp4 = __builtin_constant_p(__oflag);
  }
#line 46
  if (__cil_tmp4) {
    {
#line 48
    __cil_tmp5 = __builtin_va_arg_pack_len();
    }
#line 48
    if ((__oflag & 64) != 0) {
      _L: /* CIL Label */ 
#line 48
      if (__cil_tmp5 < 1) {
        {
#line 50
        __open_missing_mode();
#line 51
        __cil_tmp6 = __open_2(__path, __oflag);
        }
#line 51
        return (__cil_tmp6);
      }
    } else
#line 48
    if ((__oflag & 4259840) == 4259840) {
#line 48
      goto _L;
    }
    {
#line 53
    __cil_tmp7 = __builtin_va_arg_pack();
#line 53
    __cil_tmp8 = __open_alias(__path, __oflag, __cil_tmp7);
    }
#line 53
    return (__cil_tmp8);
  }
  {
#line 56
  __cil_tmp9 = __builtin_va_arg_pack_len();
  }
#line 56
  if (__cil_tmp9 < 1) {
    {
#line 57
    __cil_tmp10 = __open_2(__path, __oflag);
    }
#line 57
    return (__cil_tmp10);
  }
  {
#line 59
  __cil_tmp11 = __builtin_va_arg_pack();
#line 59
  __cil_tmp12 = __open_alias(__path, __oflag, __cil_tmp11);
  }
#line 59
  return (__cil_tmp12);
}
}
#line 98
extern int __openat_2(int __fd , char const   *__path , int __oflag ) ;
#line 100
extern int __openat_alias(int __fd , char const   *__path , int __oflag  , ...) ;
#line 111
extern void __openat_too_many_args(void) ;
#line 113
extern void __openat_missing_mode(void) ;
#line 117
__inline extern int openat(int __fd , char const   *__path , int __oflag  , ...)  __attribute__((__gnu_inline__)) ;
#line 117 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
__inline extern int openat(int __fd , char const   *__path , int __oflag  , ...) 
{ 
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;

  {
  {
#line 119
  __cil_tmp4 = __builtin_va_arg_pack_len();
  }
#line 119
  if (__cil_tmp4 > 1) {
    {
#line 120
    __openat_too_many_args();
    }
  }
  {
#line 122
  __cil_tmp5 = __builtin_constant_p(__oflag);
  }
#line 122
  if (__cil_tmp5) {
    {
#line 124
    __cil_tmp6 = __builtin_va_arg_pack_len();
    }
#line 124
    if ((__oflag & 64) != 0) {
      _L: /* CIL Label */ 
#line 124
      if (__cil_tmp6 < 1) {
        {
#line 126
        __openat_missing_mode();
#line 127
        __cil_tmp7 = __openat_2(__fd, __path, __oflag);
        }
#line 127
        return (__cil_tmp7);
      }
    } else
#line 124
    if ((__oflag & 4259840) == 4259840) {
#line 124
      goto _L;
    }
    {
#line 129
    __cil_tmp8 = __builtin_va_arg_pack();
#line 129
    __cil_tmp9 = __openat_alias(__fd, __path, __oflag, __cil_tmp8);
    }
#line 129
    return (__cil_tmp9);
  }
  {
#line 132
  __cil_tmp10 = __builtin_va_arg_pack_len();
  }
#line 132
  if (__cil_tmp10 < 1) {
    {
#line 133
    __cil_tmp11 = __openat_2(__fd, __path, __oflag);
    }
#line 133
    return (__cil_tmp11);
  }
  {
#line 135
  __cil_tmp12 = __builtin_va_arg_pack();
#line 135
  __cil_tmp13 = __openat_alias(__fd, __path, __oflag, __cil_tmp12);
  }
#line 135
  return (__cil_tmp13);
}
}
#line 37 "/usr/include/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void) ;
#line 205 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern  __attribute__((__nothrow__)) int stat(char const   *__path , struct stat *__statbuf )  __attribute__((__gnu_inline__)) ;
#line 210
__inline extern  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__gnu_inline__)) ;
#line 234
__inline extern  __attribute__((__nothrow__)) int fstatat(int __fd , char const   *__filename ,
                                                          struct stat *__statbuf ,
                                                          int __flag )  __attribute__((__gnu_inline__)) ;
#line 259
__inline extern  __attribute__((__nothrow__)) int lstat(char const   *__path , struct stat *__statbuf )  __attribute__((__gnu_inline__)) ;
#line 280
extern  __attribute__((__nothrow__)) int chmod(char const   *__file , __mode_t __mode ) ;
#line 287
extern  __attribute__((__nothrow__)) int lchmod(char const   *__file , __mode_t __mode ) ;
#line 293
extern  __attribute__((__nothrow__)) int fchmod(int __fd , __mode_t __mode ) ;
#line 299
extern  __attribute__((__nothrow__)) int fchmodat(int __fd , char const   *__file ,
                                                  __mode_t __mode , int __flag ) ;
#line 308
extern  __attribute__((__nothrow__)) __mode_t umask(__mode_t __mask ) ;
#line 317
extern  __attribute__((__nothrow__)) int mkdir(char const   *__path , __mode_t __mode ) ;
#line 324
extern  __attribute__((__nothrow__)) int mkdirat(int __fd , char const   *__path ,
                                                 __mode_t __mode ) ;
#line 332
__inline extern  __attribute__((__nothrow__)) int mknod(char const   *__path , __mode_t __mode ,
                                                        __dev_t __dev )  __attribute__((__gnu_inline__)) ;
#line 339
__inline extern  __attribute__((__nothrow__)) int mknodat(int __fd , char const   *__path ,
                                                          __mode_t __mode , __dev_t __dev )  __attribute__((__gnu_inline__)) ;
#line 346
extern  __attribute__((__nothrow__)) int mkfifo(char const   *__path , __mode_t __mode ) ;
#line 353
extern  __attribute__((__nothrow__)) int mkfifoat(int __fd , char const   *__path ,
                                                  __mode_t __mode ) ;
#line 360
extern  __attribute__((__nothrow__)) int utimensat(int __fd , char const   *__path ,
                                                   struct timespec __times[2] , int __flags ) ;
#line 368
extern  __attribute__((__nothrow__)) int futimens(int __fd , struct timespec __times[2] ) ;
#line 395
extern  __attribute__((__nothrow__)) int __fxstat(int __ver , int __fildes , struct stat *__stat_buf ) ;
#line 397
extern  __attribute__((__nothrow__)) int __xstat(int __ver , char const   *__filename ,
                                                 struct stat *__stat_buf ) ;
#line 399
extern  __attribute__((__nothrow__)) int __lxstat(int __ver , char const   *__filename ,
                                                  struct stat *__stat_buf ) ;
#line 401
extern  __attribute__((__nothrow__)) int __fxstatat(int __ver , int __fildes , char const   *__filename ,
                                                    struct stat *__stat_buf , int __flag ) ;
#line 438
extern  __attribute__((__nothrow__)) int __xmknod(int __ver , char const   *__path ,
                                                  __mode_t __mode , __dev_t *__dev ) ;
#line 441
extern  __attribute__((__nothrow__)) int __xmknodat(int __ver , int __fd , char const   *__path ,
                                                    __mode_t __mode , __dev_t *__dev ) ;
#line 453
__inline extern  __attribute__((__nothrow__)) int stat(char const   *__path , struct stat *__statbuf )  __attribute__((__gnu_inline__)) ;
#line 453 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int stat(char const   *__path , struct stat *__statbuf ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 455
  __cil_tmp3 = __xstat(1, __path, __statbuf);
  }
#line 455
  return (__cil_tmp3);
}
}
#line 460
__inline extern  __attribute__((__nothrow__)) int lstat(char const   *__path , struct stat *__statbuf )  __attribute__((__gnu_inline__)) ;
#line 460 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int lstat(char const   *__path , struct stat *__statbuf ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 462
  __cil_tmp3 = __lxstat(1, __path, __statbuf);
  }
#line 462
  return (__cil_tmp3);
}
}
#line 467
__inline extern  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__gnu_inline__)) ;
#line 467 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int fstat(int __fd , struct stat *__statbuf ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 469
  __cil_tmp3 = __fxstat(1, __fd, __statbuf);
  }
#line 469
  return (__cil_tmp3);
}
}
#line 474
__inline extern  __attribute__((__nothrow__)) int fstatat(int __fd , char const   *__filename ,
                                                          struct stat *__statbuf ,
                                                          int __flag )  __attribute__((__gnu_inline__)) ;
#line 474 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int fstatat(int __fd , char const   *__filename , struct stat *__statbuf ,
                            int __flag ) 
{ 
  int __cil_tmp5 ;

  {
  {
#line 477
  __cil_tmp5 = __fxstatat(1, __fd, __filename, __statbuf, __flag);
  }
#line 477
  return (__cil_tmp5);
}
}
#line 483
__inline extern  __attribute__((__nothrow__)) int mknod(char const   *__path , __mode_t __mode ,
                                                        __dev_t __dev )  __attribute__((__gnu_inline__)) ;
#line 483 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int mknod(char const   *__path , __mode_t __mode , __dev_t __dev ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 485
  __cil_tmp4 = __xmknod(0, __path, __mode, & __dev);
  }
#line 485
  return (__cil_tmp4);
}
}
#line 491
__inline extern  __attribute__((__nothrow__)) int mknodat(int __fd , char const   *__path ,
                                                          __mode_t __mode , __dev_t __dev )  __attribute__((__gnu_inline__)) ;
#line 491 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int mknodat(int __fd , char const   *__path , __mode_t __mode , __dev_t __dev ) 
{ 
  int __cil_tmp5 ;

  {
  {
#line 494
  __cil_tmp5 = __xmknodat(0, __fd, __path, __mode, & __dev);
  }
#line 494
  return (__cil_tmp5);
}
}
#line 67 "/root/libsndfile/src/file_io.c"
static void psf_log_syserr(SF_PRIVATE *psf , int error ) ;
#line 75
static int psf_close_fd(int fd ) ;
#line 76
static int psf_open_fd(char const   *pathname , int open_mode ) ;
#line 77
static sf_count_t psf_get_filelen_fd(int fd ) ;
#line 80 "/root/libsndfile/src/file_io.c"
int psf_fopen(SF_PRIVATE *psf , char const   *pathname , int open_mode ) 
{ 
  int __cil_tmp4 ;
  int *__cil_tmp5 ;

  {
  {
#line 82
  psf->error = 0;
#line 83
  psf->filedes = psf_open_fd(pathname, open_mode);
  }
#line 85
  if (psf->filedes == -43) {
#line 86
    psf->error = 43;
#line 87
    psf->filedes = - 1;
#line 88
    return (psf->error);
  }

#line 91
  if (psf->filedes == -1) {
    {
#line 92
    __cil_tmp5 = __errno_location();
#line 92
    psf_log_syserr(psf, *__cil_tmp5);
    }
  }
#line 94
  psf->mode = open_mode;
#line 96
  return (psf->error);
}
}
#line 100 "/root/libsndfile/src/file_io.c"
int psf_fclose(SF_PRIVATE *psf ) 
{ 
  int retval ;
  int __cil_tmp3 ;
  int *__cil_tmp4 ;

  {
#line 103
  if (psf->virtual_io) {
#line 104
    return (0);
  }
#line 106
  if (psf->do_not_close_descriptor) {
#line 107
    psf->filedes = - 1;
#line 108
    return (0);
  }
  {
#line 111
  retval = psf_close_fd(psf->filedes);
  }
#line 111
  if (retval == -1) {
    {
#line 112
    __cil_tmp4 = __errno_location();
#line 112
    psf_log_syserr(psf, *__cil_tmp4);
    }
  }
#line 114
  psf->filedes = - 1;
#line 116
  return (retval);
}
}
#line 120 "/root/libsndfile/src/file_io.c"
int psf_open_rsrc(SF_PRIVATE *psf , int open_mode ) 
{ 
  int __cil_tmp3 ;
  sf_count_t __cil_tmp4 ;
  int __cil_tmp5 ;
  sf_count_t __cil_tmp6 ;
  int __cil_tmp7 ;
  sf_count_t __cil_tmp8 ;
  int *__cil_tmp9 ;

  {
#line 122
  if (psf->rsrcdes > 0) {
#line 123
    return (0);
  }
  {
#line 126
  snprintf((char *)psf->rsrcpath, sizeof(psf->rsrcpath), "%s/rsrc", (char *)psf->filepath);
#line 127
  psf->error = 0;
#line 128
  psf->rsrcdes = psf_open_fd((char const   *)((char *)psf->rsrcpath), open_mode);
  }
#line 128
  if (psf->rsrcdes >= 0) {
    {
#line 129
    psf->rsrclength = psf_get_filelen_fd(psf->rsrcdes);
    }
#line 130
    if (psf->rsrclength > 0L) {
#line 131
      return (0);
    } else
#line 130
    if (open_mode & 32) {
#line 131
      return (0);
    }
    {
#line 132
    psf_close_fd(psf->rsrcdes);
#line 133
    psf->rsrcdes = - 1;
    }
  }

#line 136
  if (psf->rsrcdes == -43) {
#line 137
    psf->error = 43;
#line 138
    return (psf->error);
  }
  {
#line 145
  snprintf((char *)psf->rsrcpath, sizeof(psf->rsrcpath), "%s._%s", (char *)psf->directory,
           (char *)psf->filename);
#line 146
  psf->error = 0;
#line 147
  psf->rsrcdes = psf_open_fd((char const   *)((char *)psf->rsrcpath), open_mode);
  }
#line 147
  if (psf->rsrcdes >= 0) {
    {
#line 148
    psf->rsrclength = psf_get_filelen_fd(psf->rsrcdes);
    }
#line 149
    return (0);
  }
  {
#line 156
  snprintf((char *)psf->rsrcpath, sizeof(psf->rsrcpath), "%s.AppleDouble/%s", (char *)psf->directory,
           (char *)psf->filename);
#line 157
  psf->error = 0;
#line 158
  psf->rsrcdes = psf_open_fd((char const   *)((char *)psf->rsrcpath), open_mode);
  }
#line 158
  if (psf->rsrcdes >= 0) {
    {
#line 159
    psf->rsrclength = psf_get_filelen_fd(psf->rsrcdes);
    }
#line 160
    return (0);
  }

#line 164
  if (psf->rsrcdes == -1) {
    {
#line 165
    __cil_tmp9 = __errno_location();
#line 165
    psf_log_syserr(psf, *__cil_tmp9);
    }
  }
#line 167
  psf->rsrcdes = - 1;
#line 169
  return (psf->error);
}
}
#line 173 "/root/libsndfile/src/file_io.c"
sf_count_t psf_get_filelen(SF_PRIVATE *psf ) 
{ 
  sf_count_t filelen ;
  sf_count_t __cil_tmp3 ;
  sf_count_t __cil_tmp4 ;
  int *__cil_tmp5 ;

  {
#line 176
  if (psf->virtual_io) {
    {
#line 177
    __cil_tmp3 = (*(psf->vio.get_filelen))(psf->vio_user_data);
    }
#line 177
    return (__cil_tmp3);
  }
  {
#line 179
  filelen = psf_get_filelen_fd(psf->filedes);
  }
#line 181
  if (filelen == -1L) {
    {
#line 182
    __cil_tmp5 = __errno_location();
#line 182
    psf_log_syserr(psf, *__cil_tmp5);
    }
#line 183
    return ((sf_count_t )(- 1));
  }

#line 186
  if (filelen == -15L) {
#line 187
    psf->error = 15;
#line 188
    return ((sf_count_t )(- 1));
  }

  {
#line 192
  if (psf->mode == 32) {
#line 192
    goto case_32;
  }
#line 196
  if (psf->mode == 16) {
#line 196
    goto case_16;
  }
#line 201
  if (psf->mode == 48) {
#line 201
    goto case_48;
  }
#line 209
  goto switch_default;
  case_32: /* CIL Label */ 
#line 193
  filelen -= psf->fileoffset;
#line 194
  goto switch_break;
  case_16: /* CIL Label */ 
#line 197
  if (psf->fileoffset > 0L) {
#line 197
    if (psf->filelength > 0L) {
#line 198
      filelen = psf->filelength;
    }
  }
#line 199
  goto switch_break;
  case_48: /* CIL Label */ 
#line 207
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 211
  filelen = (sf_count_t )(- 1);
  switch_break: /* CIL Label */ ;
  }

#line 214
  return (filelen);
}
}
#line 218 "/root/libsndfile/src/file_io.c"
int psf_close_rsrc(SF_PRIVATE *psf ) 
{ 


  {
#line 220
  if (psf->rsrcdes >= 0) {
    {
#line 221
    psf_close_fd(psf->rsrcdes);
    }
  }
#line 222
  psf->rsrcdes = - 1;
#line 223
  return (0);
}
}
#line 227 "/root/libsndfile/src/file_io.c"
int psf_set_stdio(SF_PRIVATE *psf , int mode ) 
{ 
  int error ;

  {
#line 228
  error = 0;
  {
#line 231
  if (mode == 48) {
#line 231
    goto case_48;
  }
#line 235
  if (mode == 16) {
#line 235
    goto case_16;
  }
#line 239
  if (mode == 32) {
#line 239
    goto case_32;
  }
#line 243
  goto switch_default;
  case_48: /* CIL Label */ 
#line 232
  error = 44;
#line 233
  goto switch_break;
  case_16: /* CIL Label */ 
#line 236
  psf->filedes = 0;
#line 237
  goto switch_break;
  case_32: /* CIL Label */ 
#line 240
  psf->filedes = 1;
#line 241
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 244
  error = 43;
#line 245
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 247
  psf->filelength = (sf_count_t )0;
#line 249
  return (error);
}
}
#line 253 "/root/libsndfile/src/file_io.c"
void psf_set_file(SF_PRIVATE *psf , int fd ) 
{ 


  {
#line 254
  psf->filedes = fd;
  return;
}
}
#line 258 "/root/libsndfile/src/file_io.c"
int psf_file_valid(SF_PRIVATE *psf ) 
{ 
  int tmp ;

  {
#line 259
  if (psf->filedes >= 0) {
#line 259
    tmp = 1;
  } else {
#line 259
    tmp = 0;
  }
#line 259
  return (tmp);
}
}
#line 263 "/root/libsndfile/src/file_io.c"
sf_count_t psf_fseek(SF_PRIVATE *psf , sf_count_t offset , int whence ) 
{ 
  sf_count_t current_pos ;
  sf_count_t new_position ;
  sf_count_t __cil_tmp6 ;
  sf_count_t __cil_tmp7 ;
  __off_t __cil_tmp8 ;
  int *__cil_tmp9 ;
  __off_t __cil_tmp10 ;
  __off_t __cil_tmp11 ;
  int *__cil_tmp12 ;

  {
#line 266
  if (psf->virtual_io) {
    {
#line 267
    __cil_tmp6 = (*(psf->vio.seek))(offset, whence, psf->vio_user_data);
    }
#line 267
    return (__cil_tmp6);
  }
  {
#line 269
  current_pos = psf_ftell(psf);
  }
  {
#line 272
  if (whence == 0) {
#line 272
    goto case_0;
  }
#line 276
  if (whence == 2) {
#line 276
    goto case_2;
  }
#line 294
  if (whence == 1) {
#line 294
    goto case_1;
  }
#line 300
  goto switch_default;
  case_0: /* CIL Label */ 
#line 273
  offset += psf->fileoffset;
#line 274
  goto switch_break;
  case_2: /* CIL Label */ 
#line 277
  if (psf->mode == 32) {
    {
#line 278
    new_position = lseek(psf->filedes, offset, whence);
    }
#line 280
    if (new_position < 0L) {
      {
#line 281
      __cil_tmp9 = __errno_location();
#line 281
      psf_log_syserr(psf, *__cil_tmp9);
      }
    }
#line 283
    return (new_position - psf->fileoffset);
  }
  {
#line 290
  whence = 0;
#line 291
  __cil_tmp10 = lseek(psf->filedes, (__off_t )0, 2);
#line 291
  offset = __cil_tmp10 + offset;
  }
#line 292
  goto switch_break;
  case_1: /* CIL Label */ 
#line 296
  offset += current_pos;
#line 297
  whence = 0;
#line 298
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 302
  psf_log_printf(psf, "psf_fseek : whence is %d *****.\n\230\001", whence);
  }
#line 303
  return ((sf_count_t )0);
  switch_break: /* CIL Label */ ;
  }

#line 306
  if (current_pos != offset) {
    {
#line 307
    new_position = lseek(psf->filedes, offset, whence);
    }
  } else {
#line 309
    new_position = offset;
  }
#line 311
  if (new_position < 0L) {
    {
#line 312
    __cil_tmp12 = __errno_location();
#line 312
    psf_log_syserr(psf, *__cil_tmp12);
    }
  }
#line 314
  new_position -= psf->fileoffset;
#line 316
  return (new_position);
}
}
#line 320 "/root/libsndfile/src/file_io.c"
sf_count_t psf_fread(void *ptr , sf_count_t bytes , sf_count_t items , SF_PRIVATE *psf ) 
{ 
  sf_count_t total ;
  ssize_t count ;
  sf_count_t __cil_tmp7 ;
  long tmp ;
  ssize_t __cil_tmp9 ;
  int *__cil_tmp10 ;
  int *__cil_tmp11 ;

  {
#line 321
  total = (sf_count_t )0;
#line 324
  if (psf->virtual_io) {
    {
#line 325
    __cil_tmp7 = (*(psf->vio.read))(ptr, bytes * items, psf->vio_user_data);
    }
#line 325
    return (__cil_tmp7 / bytes);
  }
#line 327
  items *= bytes;
#line 330
  if (items <= 0L) {
#line 331
    return ((sf_count_t )0);
  }
  {
#line 333
  while (1) {
    while_continue: /* CIL Label */ ;
#line 333
    if (! (items > 0L)) {
#line 333
      goto while_break;
    }
#line 335
    if (items > 1073741824L) {
#line 335
      tmp = (long )1073741824;
    } else {
#line 335
      tmp = (ssize_t )items;
    }
    {
#line 335
    count = tmp;
#line 337
    count = read(psf->filedes, (char *)ptr + total, (size_t )count);
    }
#line 339
    if (count == -1L) {
      {
#line 340
      __cil_tmp10 = __errno_location();
      }
#line 340
      if (*__cil_tmp10 == 4) {
#line 341
        goto while_continue;
      }
      {
#line 343
      __cil_tmp11 = __errno_location();
#line 343
      psf_log_syserr(psf, *__cil_tmp11);
      }
#line 344
      goto while_break;
    }

#line 347
    if (count == 0L) {
#line 348
      goto while_break;
    }
#line 350
    total += count;
#line 351
    items -= count;
  }
  while_break: /* CIL Label */ ;
  }

#line 354
  if (psf->is_pipe) {
#line 355
    psf->pipeoffset += total;
  }
#line 357
  return (total / bytes);
}
}
#line 361 "/root/libsndfile/src/file_io.c"
sf_count_t psf_fwrite(void const   *ptr , sf_count_t bytes , sf_count_t items , SF_PRIVATE *psf ) 
{ 
  sf_count_t total ;
  ssize_t count ;
  sf_count_t __cil_tmp7 ;
  long tmp ;
  ssize_t __cil_tmp9 ;
  int *__cil_tmp10 ;
  int *__cil_tmp11 ;

  {
#line 362
  total = (sf_count_t )0;
#line 365
  if (psf->virtual_io) {
    {
#line 366
    __cil_tmp7 = (*(psf->vio.write))(ptr, bytes * items, psf->vio_user_data);
    }
#line 366
    return (__cil_tmp7 / bytes);
  }
#line 368
  items *= bytes;
#line 371
  if (items <= 0L) {
#line 372
    return ((sf_count_t )0);
  }
  {
#line 374
  while (1) {
    while_continue: /* CIL Label */ ;
#line 374
    if (! (items > 0L)) {
#line 374
      goto while_break;
    }
#line 376
    if (items > 1073741824L) {
#line 376
      tmp = (long )1073741824;
    } else {
#line 376
      tmp = items;
    }
    {
#line 376
    count = tmp;
#line 378
    count = write(psf->filedes, (char const   *)ptr + total, (size_t )count);
    }
#line 380
    if (count == -1L) {
      {
#line 381
      __cil_tmp10 = __errno_location();
      }
#line 381
      if (*__cil_tmp10 == 4) {
#line 382
        goto while_continue;
      }
      {
#line 384
      __cil_tmp11 = __errno_location();
#line 384
      psf_log_syserr(psf, *__cil_tmp11);
      }
#line 385
      goto while_break;
    }

#line 388
    if (count == 0L) {
#line 389
      goto while_break;
    }
#line 391
    total += count;
#line 392
    items -= count;
  }
  while_break: /* CIL Label */ ;
  }

#line 395
  if (psf->is_pipe) {
#line 396
    psf->pipeoffset += total;
  }
#line 398
  return (total / bytes);
}
}
#line 402 "/root/libsndfile/src/file_io.c"
sf_count_t psf_ftell(SF_PRIVATE *psf ) 
{ 
  sf_count_t pos ;
  sf_count_t __cil_tmp3 ;
  __off_t __cil_tmp4 ;
  int *__cil_tmp5 ;

  {
#line 405
  if (psf->virtual_io) {
    {
#line 406
    __cil_tmp3 = (*(psf->vio.tell))(psf->vio_user_data);
    }
#line 406
    return (__cil_tmp3);
  }
#line 408
  if (psf->is_pipe) {
#line 409
    return (psf->pipeoffset);
  }
  {
#line 411
  pos = lseek(psf->filedes, (__off_t )0, 1);
  }
#line 413
  if (pos == -1L) {
    {
#line 414
    __cil_tmp5 = __errno_location();
#line 414
    psf_log_syserr(psf, *__cil_tmp5);
    }
#line 415
    return ((sf_count_t )(- 1));
  }

#line 418
  return (pos - psf->fileoffset);
}
}
#line 422 "/root/libsndfile/src/file_io.c"
static int psf_close_fd(int fd ) 
{ 
  int retval ;
  int __cil_tmp3 ;
  int *__cil_tmp4 ;

  {
  {
#line 425
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 425
    __cil_tmp4 = __errno_location();
    }
    {
#line 425
    retval = close(fd);
    }
#line 425
    if (! (retval == -1 && *__cil_tmp4 == 4)) {
#line 425
      goto while_break;
    }

  }
  while_break: /* CIL Label */ ;
  }
#line 428
  return (retval);
}
}
#line 432 "/root/libsndfile/src/file_io.c"
sf_count_t psf_fgets(char *buffer , sf_count_t bufsize , SF_PRIVATE *psf ) 
{ 
  sf_count_t k ;
  sf_count_t count ;
  ssize_t __cil_tmp6 ;
  int *__cil_tmp7 ;
  int *__cil_tmp8 ;
  sf_count_t __cil_tmp9 ;

  {
#line 433
  k = (sf_count_t )0;
  {
#line 436
  while (1) {
    while_continue: /* CIL Label */ ;
#line 436
    if (! (k < bufsize - 1L)) {
#line 436
      goto while_break;
    }
    {
#line 437
    count = read(psf->filedes, buffer + k, (size_t )1);
    }
#line 439
    if (count == -1L) {
      {
#line 440
      __cil_tmp7 = __errno_location();
      }
#line 440
      if (*__cil_tmp7 == 4) {
#line 441
        goto while_continue;
      }
      {
#line 443
      __cil_tmp8 = __errno_location();
#line 443
      psf_log_syserr(psf, *__cil_tmp8);
      }
#line 444
      goto while_break;
    }
#line 447
    __cil_tmp9 = k;
#line 447
    k ++;
#line 447
    if (count == 0L) {
#line 448
      goto while_break;
    } else
#line 447
    if ((int )*(buffer + __cil_tmp9) == 10) {
#line 448
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 451
  *(buffer + k) = (char )0;
#line 453
  return (k);
}
}
#line 457 "/root/libsndfile/src/file_io.c"
int psf_is_pipe(SF_PRIVATE *psf ) 
{ 
  struct stat statbuf ;
  int __cil_tmp3 ;
  int *__cil_tmp4 ;

  {
#line 460
  if (psf->virtual_io) {
#line 461
    return (0);
  }
  {
#line 463
  __cil_tmp3 = fstat(psf->filedes, & statbuf);
  }
#line 463
  if (__cil_tmp3 == -1) {
    {
#line 464
    __cil_tmp4 = __errno_location();
#line 464
    psf_log_syserr(psf, *__cil_tmp4);
    }
#line 466
    return (1);
  }

#line 469
  if ((statbuf.st_mode & 61440U) == 4096U) {
#line 470
    return (1);
  } else
#line 469
  if ((statbuf.st_mode & 61440U) == 49152U) {
#line 470
    return (1);
  }
#line 472
  return (0);
}
}
#line 476 "/root/libsndfile/src/file_io.c"
static sf_count_t psf_get_filelen_fd(int fd ) 
{ 
  struct stat statbuf ;
  int __cil_tmp3 ;

  {
#line 483
  if (sizeof(statbuf.st_size) == 4UL) {
#line 483
    if (sizeof(sf_count_t ) == 8UL) {
#line 484
      return ((sf_count_t )(- 15));
    }
  }
  {
#line 486
  __cil_tmp3 = fstat(fd, & statbuf);
  }
#line 486
  if (__cil_tmp3 == -1) {
#line 487
    return ((sf_count_t )(- 1));
  }
#line 489
  return (statbuf.st_size);
}
}
#line 493 "/root/libsndfile/src/file_io.c"
int psf_ftruncate(SF_PRIVATE *psf , sf_count_t len ) 
{ 
  int retval ;
  int __cil_tmp4 ;
  int *__cil_tmp5 ;

  {
#line 497
  if (len < 0L) {
#line 498
    return (- 1);
  }
#line 500
  if (sizeof(__off_t ) < sizeof(sf_count_t )) {
#line 500
    if (len > 2147483647L) {
#line 501
      return (- 1);
    }
  }
  {
#line 503
  retval = ftruncate(psf->filedes, len);
  }
#line 505
  if (retval == -1) {
    {
#line 506
    __cil_tmp5 = __errno_location();
#line 506
    psf_log_syserr(psf, *__cil_tmp5);
    }
  }
#line 508
  return (retval);
}
}
#line 512 "/root/libsndfile/src/file_io.c"
void psf_init_files(SF_PRIVATE *psf ) 
{ 


  {
#line 513
  psf->filedes = - 1;
#line 514
  psf->rsrcdes = - 1;
#line 515
  psf->savedes = - 1;
  return;
}
}
#line 519 "/root/libsndfile/src/file_io.c"
void psf_use_rsrc(SF_PRIVATE *psf , int on_off ) 
{ 


  {
#line 521
  if (on_off) {
#line 522
    if (psf->filedes != psf->rsrcdes) {
#line 523
      psf->savedes = psf->filedes;
#line 524
      psf->filedes = psf->rsrcdes;
    }

  } else
#line 527
  if (psf->filedes == psf->rsrcdes) {
#line 528
    psf->filedes = psf->savedes;
  }
#line 530
  return;
}
}
#line 534 "/root/libsndfile/src/file_io.c"
static int psf_open_fd(char const   *pathname , int open_mode ) 
{ 
  int fd ;
  int oflag ;
  int mode ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 542
  if (sizeof(__off_t ) != sizeof(sf_count_t )) {
    {
#line 543
    puts("\n\n*** Fatal error : sizeof (off_t) != sizeof (sf_count_t)");
#line 544
    puts("*** This means that libsndfile was not configured correctly.\n");
#line 545
    exit(1);
    }
  }

  {
#line 549
  if (open_mode == 16) {
#line 549
    goto case_16;
  }
#line 554
  if (open_mode == 32) {
#line 554
    goto case_32;
  }
#line 559
  if (open_mode == 48) {
#line 559
    goto case_48;
  }
#line 564
  goto switch_default;
  case_16: /* CIL Label */ 
#line 550
  oflag = 0;
#line 551
  mode = 0;
#line 552
  goto switch_break;
  case_32: /* CIL Label */ 
#line 555
  oflag = 577;
#line 556
  mode = (384 | (256 >> 3)) | ((256 >> 3) >> 3);
#line 557
  goto switch_break;
  case_48: /* CIL Label */ 
#line 560
  oflag = 66;
#line 561
  mode = (384 | (256 >> 3)) | ((256 >> 3) >> 3);
#line 562
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 565
  return (- 43);
#line 566
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }

#line 569
  if (mode == 0) {
    {
#line 570
    fd = open(pathname, oflag);
    }
  } else {
    {
#line 572
    fd = open(pathname, oflag, mode);
    }
  }
#line 574
  return (fd);
}
}
#line 578 "/root/libsndfile/src/file_io.c"
static void psf_log_syserr(SF_PRIVATE *psf , int error ) 
{ 
  char *__cil_tmp3 ;

  {
#line 581
  if (psf->error == 0) {
    {
#line 582
    psf->error = 2;
#line 583
    __cil_tmp3 = strerror(error);
#line 583
    snprintf((char *)psf->syserr, sizeof(psf->syserr), "System error : %s.\001", __cil_tmp3);
    }
  }

#line 586
  return;
}
}
#line 590 "/root/libsndfile/src/file_io.c"
void psf_fsync(SF_PRIVATE *psf ) 
{ 


  {
#line 593
  if (psf->mode == 32) {
    {
    {
#line 594
    fsync(psf->filedes);
    }
    }
  } else
#line 593
  if (psf->mode == 48) {
    {
    {
#line 594
    fsync(psf->filedes);
    }
    }
  }
  return;
}
}
#line 53 "/root/libsndfile/src/dwvw.c"
static sf_count_t dwvw_read_s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 54
static sf_count_t dwvw_read_i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 55
static sf_count_t dwvw_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 56
static sf_count_t dwvw_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 58
static sf_count_t dwvw_write_s(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 59
static sf_count_t dwvw_write_i(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 60
static sf_count_t dwvw_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 61
static sf_count_t dwvw_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 63
static sf_count_t dwvw_seek(SF_PRIVATE *psf , int UNUSED_mode , sf_count_t offset ) ;
#line 64
static int dwvw_close(SF_PRIVATE *psf ) ;
#line 66
static int dwvw_decode_data(SF_PRIVATE *psf , DWVW_PRIVATE *pdwvw , int *ptr , int len ) ;
#line 67
static int dwvw_decode_load_bits(SF_PRIVATE *psf , DWVW_PRIVATE *pdwvw , int bit_count ) ;
#line 69
static int dwvw_encode_data(SF_PRIVATE *psf , DWVW_PRIVATE *pdwvw , int const   *ptr ,
                            int len ) ;
#line 70
static void dwvw_encode_store_bits(SF_PRIVATE *psf , DWVW_PRIVATE *pdwvw , int data___0 ,
                                   int new_bits ) ;
#line 71
static void dwvw_read_reset(DWVW_PRIVATE *pdwvw ) ;
#line 78 "/root/libsndfile/src/dwvw.c"
int dwvw_init(SF_PRIVATE *psf , int bitwidth ) 
{ 
  DWVW_PRIVATE *pdwvw ;
  void *__cil_tmp4 ;

  {
#line 81
  if (psf->codec_data != (void *)0) {
    {
#line 82
    psf_log_printf(psf, "*** psf->codec_data is not NULL.\n");
    }
#line 83
    return (29);
  }

#line 86
  if (bitwidth > 24) {
#line 87
    return (132);
  }
#line 89
  if (psf->mode == 48) {
#line 90
    return (23);
  }
  {
#line 92
  pdwvw = (DWVW_PRIVATE *)calloc((unsigned long )1, sizeof(DWVW_PRIVATE ));
  }
#line 92
  if (pdwvw == (void *)0) {
#line 93
    return (16);
  }
  {
#line 95
  psf->codec_data = (void *)pdwvw;
#line 97
  pdwvw->bit_width = bitwidth;
#line 98
  pdwvw->dwm_maxsize = bitwidth / 2;
#line 99
  pdwvw->max_delta = 1 << (bitwidth - 1);
#line 100
  pdwvw->span = 1 << bitwidth;
#line 102
  dwvw_read_reset(pdwvw);
  }
#line 104
  if (psf->mode == 16) {
#line 105
    psf->read_short = & dwvw_read_s;
#line 106
    psf->read_int = & dwvw_read_i;
#line 107
    psf->read_float = & dwvw_read_f;
#line 108
    psf->read_double = & dwvw_read_d;
  }

#line 111
  if (psf->mode == 32) {
#line 112
    psf->write_short = & dwvw_write_s;
#line 113
    psf->write_int = & dwvw_write_i;
#line 114
    psf->write_float = & dwvw_write_f;
#line 115
    psf->write_double = & dwvw_write_d;
  }
#line 118
  psf->codec_close = & dwvw_close;
#line 119
  psf->seek = & dwvw_seek;
#line 122
  psf->sf.frames = (sf_count_t )-1LL;
#line 123
  psf->datalength = psf->sf.frames;
#line 126
  return (0);
}
}
#line 133 "/root/libsndfile/src/dwvw.c"
static int dwvw_close(SF_PRIVATE *psf ) 
{ 
  DWVW_PRIVATE *pdwvw ;
  static int last_values[12] ;

  {
#line 136
  if (psf->codec_data == (void *)0) {
#line 137
    return (0);
  }
#line 138
  pdwvw = (DWVW_PRIVATE *)psf->codec_data;
#line 140
  if (psf->mode == 32) {
    {
#line 141
    last_values[0] = 0;
#line 141
    last_values[1] = 0;
#line 141
    last_values[2] = 0;
#line 141
    last_values[3] = 0;
#line 141
    last_values[4] = 0;
#line 141
    last_values[5] = 0;
#line 141
    last_values[6] = 0;
#line 141
    last_values[7] = 0;
#line 141
    last_values[8] = 0;
#line 141
    last_values[9] = 0;
#line 141
    last_values[10] = 0;
#line 141
    last_values[11] = 0;
#line 144
    dwvw_encode_data(psf, pdwvw, (int const   *)((int *)last_values), 12);
#line 147
    psf_fwrite((unsigned char *)pdwvw->b.buffer, (sf_count_t )1, (sf_count_t )pdwvw->b.index,
               psf);
    }
#line 149
    if (psf->write_header) {
      {
#line 150
      (*(psf->write_header))(psf, 1);
      }
    }
  }

#line 153
  return (0);
}
}
#line 157 "/root/libsndfile/src/dwvw.c"
static sf_count_t dwvw_seek(SF_PRIVATE *psf , int UNUSED_mode , sf_count_t offset ) 
{ 
  DWVW_PRIVATE *pdwvw ;

  {
#line 160
  if (! psf->codec_data) {
#line 161
    psf->error = 29;
#line 162
    return ((sf_count_t )(- 1));
  }
#line 165
  pdwvw = (DWVW_PRIVATE *)psf->codec_data;
#line 167
  if (offset == 0L) {
    {
#line 168
    psf_fseek(psf, psf->dataoffset, 0);
#line 169
    dwvw_read_reset(pdwvw);
    }
#line 170
    return ((sf_count_t )0);
  }
#line 173
  psf->error = 38;
#line 174
  return ((sf_count_t )(- 1));
}
}
#line 182 "/root/libsndfile/src/dwvw.c"
static sf_count_t dwvw_read_s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  DWVW_PRIVATE *pdwvw ;
  int *iptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count ;
  sf_count_t total ;
  long tmp ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;

  {
#line 185
  readcount = 0;
#line 186
  total = (sf_count_t )0;
#line 188
  if (! psf->codec_data) {
#line 189
    return ((sf_count_t )0);
  }
#line 190
  pdwvw = (DWVW_PRIVATE *)psf->codec_data;
#line 192
  iptr = (int *)psf->u.ibuf;
#line 193
  bufferlen = (int )(sizeof(psf->u.ibuf) / sizeof(psf->u.ibuf[0]));
  {
#line 194
  while (1) {
    while_continue: /* CIL Label */ ;
#line 194
    if (! (len > 0L)) {
#line 194
      goto while_break;
    }
#line 195
    if (len >= (long )bufferlen) {
#line 195
      tmp = (long )bufferlen;
    } else {
#line 195
      tmp = len;
    }
    {
#line 195
    readcount = (int )tmp;
#line 196
    count = dwvw_decode_data(psf, pdwvw, iptr, readcount);
#line 197
    k = 0;
    }
    {
#line 197
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 197
      if (! (k < readcount)) {
#line 197
        goto while_break___0;
      }
#line 198
      *(ptr + (total + (long )k)) = (short )(*(iptr + k) >> 16);
#line 197
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 200
    total += (long )count;
#line 201
    len -= (long )readcount;
#line 202
    if (count != readcount) {
#line 203
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 206
  return (total);
}
}
#line 210 "/root/libsndfile/src/dwvw.c"
static sf_count_t dwvw_read_i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  DWVW_PRIVATE *pdwvw ;
  int readcount ;
  int count ;
  sf_count_t total ;
  int tmp ;
  int __cil_tmp9 ;

  {
#line 213
  total = (sf_count_t )0;
#line 215
  if (! psf->codec_data) {
#line 216
    return ((sf_count_t )0);
  }
#line 217
  pdwvw = (DWVW_PRIVATE *)psf->codec_data;
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
#line 219
    if (! (len > 0L)) {
#line 219
      goto while_break;
    }
#line 220
    if (len > 268435456L) {
#line 220
      tmp = 268435456;
    } else {
#line 220
      tmp = (int )len;
    }
    {
#line 220
    readcount = tmp;
#line 222
    count = dwvw_decode_data(psf, pdwvw, ptr, readcount);
#line 224
    total += (long )count;
#line 225
    len -= (long )count;
    }
#line 227
    if (count != readcount) {
#line 228
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 231
  return (total);
}
}
#line 235 "/root/libsndfile/src/dwvw.c"
static sf_count_t dwvw_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  DWVW_PRIVATE *pdwvw ;
  int *iptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  long tmp___0 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;

  {
#line 238
  readcount = 0;
#line 239
  total = (sf_count_t )0;
#line 242
  if (! psf->codec_data) {
#line 243
    return ((sf_count_t )0);
  }
#line 244
  pdwvw = (DWVW_PRIVATE *)psf->codec_data;
#line 246
  if (psf->norm_float == 1) {
#line 246
    tmp = 1. / (double )((float )2147483648U);
  } else {
#line 246
    tmp = 1.;
  }
#line 246
  normfact = (float )tmp;
#line 248
  iptr = (int *)psf->u.ibuf;
#line 249
  bufferlen = (int )(sizeof(psf->u.ibuf) / sizeof(psf->u.ibuf[0]));
  {
#line 250
  while (1) {
    while_continue: /* CIL Label */ ;
#line 250
    if (! (len > 0L)) {
#line 250
      goto while_break;
    }
#line 251
    if (len >= (long )bufferlen) {
#line 251
      tmp___0 = (long )bufferlen;
    } else {
#line 251
      tmp___0 = len;
    }
    {
#line 251
    readcount = (int )tmp___0;
#line 252
    count = dwvw_decode_data(psf, pdwvw, iptr, readcount);
#line 253
    k = 0;
    }
    {
#line 253
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 253
      if (! (k < readcount)) {
#line 253
        goto while_break___0;
      }
#line 254
      *(ptr + (total + (long )k)) = normfact * (float )*(iptr + k);
#line 253
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 256
    total += (long )count;
#line 257
    len -= (long )readcount;
#line 258
    if (count != readcount) {
#line 259
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 262
  return (total);
}
}
#line 266 "/root/libsndfile/src/dwvw.c"
static sf_count_t dwvw_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  DWVW_PRIVATE *pdwvw ;
  int *iptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  long tmp___0 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;

  {
#line 269
  readcount = 0;
#line 270
  total = (sf_count_t )0;
#line 273
  if (! psf->codec_data) {
#line 274
    return ((sf_count_t )0);
  }
#line 275
  pdwvw = (DWVW_PRIVATE *)psf->codec_data;
#line 277
  if (psf->norm_double == 1) {
#line 277
    tmp = 1. / (double )2147483648U;
  } else {
#line 277
    tmp = 1.;
  }
#line 277
  normfact = tmp;
#line 279
  iptr = (int *)psf->u.ibuf;
#line 280
  bufferlen = (int )(sizeof(psf->u.ibuf) / sizeof(psf->u.ibuf[0]));
  {
#line 281
  while (1) {
    while_continue: /* CIL Label */ ;
#line 281
    if (! (len > 0L)) {
#line 281
      goto while_break;
    }
#line 282
    if (len >= (long )bufferlen) {
#line 282
      tmp___0 = (long )bufferlen;
    } else {
#line 282
      tmp___0 = len;
    }
    {
#line 282
    readcount = (int )tmp___0;
#line 283
    count = dwvw_decode_data(psf, pdwvw, iptr, readcount);
#line 284
    k = 0;
    }
    {
#line 284
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 284
      if (! (k < readcount)) {
#line 284
        goto while_break___0;
      }
#line 285
      *(ptr + (total + (long )k)) = normfact * (double )*(iptr + k);
#line 284
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 287
    total += (long )count;
#line 288
    len -= (long )readcount;
#line 289
    if (count != readcount) {
#line 290
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 293
  return (total);
}
}
#line 297 "/root/libsndfile/src/dwvw.c"
static int dwvw_decode_data(SF_PRIVATE *psf , DWVW_PRIVATE *pdwvw , int *ptr , int len ) 
{ 
  int count ;
  int delta_width_modifier ;
  int delta_width ;
  int delta_negative ;
  int delta ;
  int sample ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;

  {
#line 302
  delta_width = pdwvw->last_delta_width;
#line 303
  sample = pdwvw->last_sample;
#line 305
  count = 0;
  {
#line 305
  while (1) {
    while_continue: /* CIL Label */ ;
#line 305
    if (! (count < len)) {
#line 305
      goto while_break;
    }
    {
#line 307
    delta_width_modifier = dwvw_decode_load_bits(psf, pdwvw, - 1);
    }
#line 310
    if (delta_width_modifier < 0) {
#line 311
      goto while_break;
    }
    {
#line 313
    __cil_tmp12 = dwvw_decode_load_bits(psf, pdwvw, 1);
    }
#line 313
    if (delta_width_modifier) {
#line 313
      if (__cil_tmp12) {
#line 314
        delta_width_modifier = - delta_width_modifier;
      }
    }
#line 317
    delta_width = ((delta_width + delta_width_modifier) + pdwvw->bit_width) % pdwvw->bit_width;
#line 320
    delta = 0;
#line 321
    if (delta_width) {
      {
#line 322
      __cil_tmp13 = dwvw_decode_load_bits(psf, pdwvw, delta_width - 1);
#line 322
      delta = __cil_tmp13 | (1 << (delta_width - 1));
#line 323
      delta_negative = dwvw_decode_load_bits(psf, pdwvw, 1);
      }
#line 324
      if (delta == pdwvw->max_delta - 1) {
        {
#line 325
        __cil_tmp15 = dwvw_decode_load_bits(psf, pdwvw, 1);
        }
#line 325
        delta += __cil_tmp15;
      }
#line 326
      if (delta_negative) {
#line 327
        delta = - delta;
      }
    }
#line 331
    sample += delta;
#line 333
    if (sample >= pdwvw->max_delta) {
#line 334
      sample -= pdwvw->span;
    } else
#line 335
    if (sample < - pdwvw->max_delta) {
#line 336
      sample += pdwvw->span;
    }
#line 339
    *(ptr + count) = sample << (32 - pdwvw->bit_width);
#line 341
    if (pdwvw->b.end == 0) {
#line 341
      if (pdwvw->bit_count == 0) {
#line 342
        goto while_break;
      }
    }
#line 305
    count ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 345
  pdwvw->last_delta_width = delta_width;
#line 346
  pdwvw->last_sample = sample;
#line 348
  pdwvw->samplecount += count;
#line 350
  return (count);
}
}
#line 354 "/root/libsndfile/src/dwvw.c"
static int dwvw_decode_load_bits(SF_PRIVATE *psf , DWVW_PRIVATE *pdwvw , int bit_count ) 
{ 
  int output ;
  int get_dwm ;
  sf_count_t __cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 355
  output = 0;
#line 355
  get_dwm = 0;
#line 363
  if (bit_count < 0) {
#line 364
    get_dwm = 1;
#line 366
    bit_count = pdwvw->dwm_maxsize;
  }

  {
#line 370
  while (1) {
    while_continue: /* CIL Label */ ;
#line 370
    if (! (pdwvw->bit_count < bit_count)) {
#line 370
      goto while_break;
    }
#line 371
    if (pdwvw->b.index >= pdwvw->b.end) {
      {
#line 372
      __cil_tmp6 = psf_fread((unsigned char *)pdwvw->b.buffer, (sf_count_t )1, (sf_count_t )sizeof(pdwvw->b.buffer),
                             psf);
#line 372
      pdwvw->b.end = (int )__cil_tmp6;
#line 373
      pdwvw->b.index = 0;
      }
    }

#line 377
    if (bit_count < 8) {
#line 377
      if (pdwvw->b.end == 0) {
#line 378
        return (- 1);
      }
    }
#line 380
    pdwvw->bits <<= 8;
#line 382
    if (pdwvw->b.index < pdwvw->b.end) {
#line 383
      pdwvw->bits |= (int )pdwvw->b.buffer[pdwvw->b.index];
#line 384
      (pdwvw->b.index) ++;
    }
#line 386
    pdwvw->bit_count += 8;
  }
  while_break: /* CIL Label */ ;
  }

#line 390
  if (! get_dwm) {
#line 391
    output = (pdwvw->bits >> (pdwvw->bit_count - bit_count)) & ((1 << bit_count) - 1);
#line 392
    pdwvw->bit_count -= bit_count;
#line 393
    return (output);
  }

  {
#line 397
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 397
    if (! (output < pdwvw->dwm_maxsize)) {
#line 397
      goto while_break___0;
    }
#line 398
    (pdwvw->bit_count) --;
#line 399
    if (pdwvw->bits & (1 << pdwvw->bit_count)) {
#line 400
      goto while_break___0;
    }
#line 401
    output ++;
  }
  while_break___0: /* CIL Label */ ;
  }

#line 404
  return (output);
}
}
#line 408 "/root/libsndfile/src/dwvw.c"
static void dwvw_read_reset(DWVW_PRIVATE *pdwvw ) 
{ 


  {
#line 409
  pdwvw->samplecount = 0;
#line 410
  pdwvw->b.index = 0;
#line 411
  pdwvw->b.end = 0;
#line 412
  pdwvw->bit_count = 0;
#line 413
  pdwvw->bits = 0;
#line 414
  pdwvw->last_delta_width = 0;
#line 415
  pdwvw->last_sample = 0;
  return;
}
}
#line 419 "/root/libsndfile/src/dwvw.c"
static void dwvw_encode_store_bits(SF_PRIVATE *psf , DWVW_PRIVATE *pdwvw , int data___0 ,
                                   int new_bits ) 
{ 
  int byte ;
  int __cil_tmp6 ;

  {
#line 423
  pdwvw->bits = (pdwvw->bits << new_bits) | (data___0 & ((1 << new_bits) - 1));
#line 424
  pdwvw->bit_count += new_bits;
  {
#line 427
  while (1) {
    while_continue: /* CIL Label */ ;
#line 427
    if (! (pdwvw->bit_count >= 8)) {
#line 427
      goto while_break;
    }
#line 428
    byte = pdwvw->bits >> (pdwvw->bit_count - 8);
#line 429
    pdwvw->bit_count -= 8;
#line 430
    pdwvw->b.buffer[pdwvw->b.index] = (unsigned char )(byte & 255);
#line 431
    (pdwvw->b.index) ++;
  }
  while_break: /* CIL Label */ ;
  }

#line 434
  if (pdwvw->b.index > (int )sizeof(pdwvw->b.buffer) - 4) {
    {
#line 435
    psf_fwrite((unsigned char *)pdwvw->b.buffer, (sf_count_t )1, (sf_count_t )pdwvw->b.index,
               psf);
#line 436
    pdwvw->b.index = 0;
    }
  }

#line 439
  return;
}
}
#line 474 "/root/libsndfile/src/dwvw.c"
static int dwvw_encode_data(SF_PRIVATE *psf , DWVW_PRIVATE *pdwvw , int const   *ptr ,
                            int len ) 
{ 
  int count ;
  int delta_width_modifier ;
  int delta ;
  int delta_negative ;
  int delta_width ;
  int extra_bit ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int y ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int tmp ;
  int __cil_tmp19 ;

  {
#line 478
  count = 0;
  {
#line 478
  while (1) {
    while_continue: /* CIL Label */ ;
#line 478
    if (! (count < len)) {
#line 478
      goto while_break;
    }
#line 479
    delta = (*(ptr + count) >> (32 - pdwvw->bit_width)) - pdwvw->last_sample;
#line 482
    extra_bit = - 1;
#line 483
    delta_negative = 0;
#line 484
    if (delta < - pdwvw->max_delta) {
#line 485
      delta = pdwvw->max_delta + delta % pdwvw->max_delta;
    } else
#line 486
    if (delta == - pdwvw->max_delta) {
#line 487
      extra_bit = 1;
#line 488
      delta_negative = 1;
#line 489
      delta = pdwvw->max_delta - 1;
    } else
#line 491
    if (delta > pdwvw->max_delta) {
      {
#line 492
      delta_negative = 1;
#line 493
      delta = pdwvw->span - delta;
#line 494
      delta = abs(delta);
      }
    } else
#line 496
    if (delta == pdwvw->max_delta) {
#line 497
      extra_bit = 1;
#line 498
      delta = pdwvw->max_delta - 1;
    } else
#line 500
    if (delta < 0) {
      {
#line 501
      delta_negative = 1;
#line 502
      delta = abs(delta);
      }
    }

#line 505
    if (delta == pdwvw->max_delta - 1) {
#line 505
      if (extra_bit == -1) {
#line 506
        extra_bit = 0;
      }
    }
#line 509
    y = delta;
#line 509
    delta_width = 0;
    {
#line 509
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 509
      if (! y) {
#line 509
        goto while_break___0;
      }
#line 509
      delta_width ++;
#line 509
      y >>= 1;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 512
    delta_width_modifier = (delta_width - pdwvw->last_delta_width) % pdwvw->bit_width;
#line 513
    if (delta_width_modifier > pdwvw->dwm_maxsize) {
#line 514
      delta_width_modifier -= pdwvw->bit_width;
    }
#line 515
    if (delta_width_modifier < - pdwvw->dwm_maxsize) {
#line 516
      delta_width_modifier += pdwvw->bit_width;
    }
    {
#line 519
    __cil_tmp15 = abs(delta_width_modifier);
#line 519
    dwvw_encode_store_bits(psf, pdwvw, 0, __cil_tmp15);
#line 520
    __cil_tmp16 = abs(delta_width_modifier);
    }
#line 520
    if (__cil_tmp16 != pdwvw->dwm_maxsize) {
      {
#line 521
      dwvw_encode_store_bits(psf, pdwvw, 1, 1);
      }
    }
#line 524
    if (delta_width_modifier < 0) {
      {
#line 525
      dwvw_encode_store_bits(psf, pdwvw, 1, 1);
      }
    }
#line 526
    if (delta_width_modifier > 0) {
      {
#line 527
      dwvw_encode_store_bits(psf, pdwvw, 0, 1);
      }
    }
#line 530
    if (delta_width) {
      {
#line 531
      __cil_tmp17 = abs(delta_width);
#line 531
      dwvw_encode_store_bits(psf, pdwvw, delta, __cil_tmp17 - 1);
      }
#line 532
      if (delta_negative) {
#line 532
        tmp = 1;
      } else {
#line 532
        tmp = 0;
      }
      {
#line 532
      dwvw_encode_store_bits(psf, pdwvw, tmp, 1);
      }
    }

#line 536
    if (extra_bit >= 0) {
      {
#line 537
      dwvw_encode_store_bits(psf, pdwvw, extra_bit, 1);
      }
    }
#line 539
    pdwvw->last_sample = *(ptr + count) >> (32 - pdwvw->bit_width);
#line 540
    pdwvw->last_delta_width = delta_width;
#line 478
    count ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 543
  pdwvw->samplecount += count;
#line 545
  return (count);
}
}
#line 549 "/root/libsndfile/src/dwvw.c"
static sf_count_t dwvw_write_s(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  DWVW_PRIVATE *pdwvw ;
  int *iptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count ;
  sf_count_t total ;
  long tmp ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;

  {
#line 552
  writecount = 0;
#line 553
  total = (sf_count_t )0;
#line 555
  if (! psf->codec_data) {
#line 556
    return ((sf_count_t )0);
  }
#line 557
  pdwvw = (DWVW_PRIVATE *)psf->codec_data;
#line 559
  iptr = (int *)psf->u.ibuf;
#line 560
  bufferlen = (int )(sizeof(psf->u.ibuf) / sizeof(psf->u.ibuf[0]));
  {
#line 561
  while (1) {
    while_continue: /* CIL Label */ ;
#line 561
    if (! (len > 0L)) {
#line 561
      goto while_break;
    }
#line 562
    if (len >= (long )bufferlen) {
#line 562
      tmp = (long )bufferlen;
    } else {
#line 562
      tmp = len;
    }
#line 562
    writecount = (int )tmp;
#line 563
    k = 0;
    {
#line 563
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 563
      if (! (k < writecount)) {
#line 563
        goto while_break___0;
      }
#line 564
      *(iptr + k) = (int )*(ptr + (total + (long )k)) << 16;
#line 563
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 565
    count = dwvw_encode_data(psf, pdwvw, (int const   *)iptr, writecount);
#line 567
    total += (long )count;
#line 568
    len -= (long )writecount;
    }
#line 569
    if (count != writecount) {
#line 570
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 573
  return (total);
}
}
#line 577 "/root/libsndfile/src/dwvw.c"
static sf_count_t dwvw_write_i(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  DWVW_PRIVATE *pdwvw ;
  int writecount ;
  int count ;
  sf_count_t total ;
  int tmp ;
  int __cil_tmp9 ;

  {
#line 580
  total = (sf_count_t )0;
#line 582
  if (! psf->codec_data) {
#line 583
    return ((sf_count_t )0);
  }
#line 584
  pdwvw = (DWVW_PRIVATE *)psf->codec_data;
  {
#line 586
  while (1) {
    while_continue: /* CIL Label */ ;
#line 586
    if (! (len > 0L)) {
#line 586
      goto while_break;
    }
#line 587
    if (len > 268435456L) {
#line 587
      tmp = 268435456;
    } else {
#line 587
      tmp = (int )len;
    }
    {
#line 587
    writecount = tmp;
#line 589
    count = dwvw_encode_data(psf, pdwvw, ptr, writecount);
#line 591
    total += (long )count;
#line 592
    len -= (long )count;
    }
#line 594
    if (count != writecount) {
#line 595
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 598
  return (total);
}
}
#line 602 "/root/libsndfile/src/dwvw.c"
static sf_count_t dwvw_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  DWVW_PRIVATE *pdwvw ;
  int *iptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  long tmp___0 ;
  long __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;

  {
#line 605
  writecount = 0;
#line 606
  total = (sf_count_t )0;
#line 609
  if (! psf->codec_data) {
#line 610
    return ((sf_count_t )0);
  }
#line 611
  pdwvw = (DWVW_PRIVATE *)psf->codec_data;
#line 613
  if (psf->norm_float == 1) {
#line 613
    tmp = 1. * (double )2147483647;
  } else {
#line 613
    tmp = 1.;
  }
#line 613
  normfact = (float )tmp;
#line 615
  iptr = (int *)psf->u.ibuf;
#line 616
  bufferlen = (int )(sizeof(psf->u.ibuf) / sizeof(psf->u.ibuf[0]));
  {
#line 617
  while (1) {
    while_continue: /* CIL Label */ ;
#line 617
    if (! (len > 0L)) {
#line 617
      goto while_break;
    }
#line 618
    if (len >= (long )bufferlen) {
#line 618
      tmp___0 = (long )bufferlen;
    } else {
#line 618
      tmp___0 = len;
    }
#line 618
    writecount = (int )tmp___0;
#line 619
    k = 0;
    {
#line 619
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 619
      if (! (k < writecount)) {
#line 619
        goto while_break___0;
      }
      {
#line 620
      __cil_tmp14 = lrintf(normfact * *(ptr + (total + (long )k)));
#line 620
      *(iptr + k) = (int )__cil_tmp14;
      }
#line 619
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 621
    count = dwvw_encode_data(psf, pdwvw, (int const   *)iptr, writecount);
#line 623
    total += (long )count;
#line 624
    len -= (long )writecount;
    }
#line 625
    if (count != writecount) {
#line 626
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 629
  return (total);
}
}
#line 633 "/root/libsndfile/src/dwvw.c"
static sf_count_t dwvw_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  DWVW_PRIVATE *pdwvw ;
  int *iptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  long tmp___0 ;
  long __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;

  {
#line 636
  writecount = 0;
#line 637
  total = (sf_count_t )0;
#line 640
  if (! psf->codec_data) {
#line 641
    return ((sf_count_t )0);
  }
#line 642
  pdwvw = (DWVW_PRIVATE *)psf->codec_data;
#line 644
  if (psf->norm_double == 1) {
#line 644
    tmp = 1. * (double )2147483647;
  } else {
#line 644
    tmp = 1.;
  }
#line 644
  normfact = tmp;
#line 646
  iptr = (int *)psf->u.ibuf;
#line 647
  bufferlen = (int )(sizeof(psf->u.ibuf) / sizeof(psf->u.ibuf[0]));
  {
#line 648
  while (1) {
    while_continue: /* CIL Label */ ;
#line 648
    if (! (len > 0L)) {
#line 648
      goto while_break;
    }
#line 649
    if (len >= (long )bufferlen) {
#line 649
      tmp___0 = (long )bufferlen;
    } else {
#line 649
      tmp___0 = len;
    }
#line 649
    writecount = (int )tmp___0;
#line 650
    k = 0;
    {
#line 650
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 650
      if (! (k < writecount)) {
#line 650
        goto while_break___0;
      }
      {
#line 651
      __cil_tmp14 = lrint(normfact * *(ptr + (total + (long )k)));
#line 651
      *(iptr + k) = (int )__cil_tmp14;
      }
#line 650
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 652
    count = dwvw_encode_data(psf, pdwvw, (int const   *)iptr, writecount);
#line 654
    total += (long )count;
#line 655
    len -= (long )writecount;
    }
#line 656
    if (count != writecount) {
#line 657
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 660
  return (total);
}
}
#line 59 "/root/libsndfile/src/double64.c"
static sf_count_t host_read_d2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 60
static sf_count_t host_read_d2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 61
static sf_count_t host_read_d2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 62
static sf_count_t host_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 64
static sf_count_t host_write_s2d(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 65
static sf_count_t host_write_i2d(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 66
static sf_count_t host_write_f2d(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 67
static sf_count_t host_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 69
static void double64_peak_update(SF_PRIVATE *psf , double const   *buffer , int count ,
                                 sf_count_t indx ) ;
#line 71
static int double64_get_capability(SF_PRIVATE *psf ) ;
#line 73
static sf_count_t replace_read_d2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 74
static sf_count_t replace_read_d2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 75
static sf_count_t replace_read_d2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 76
static sf_count_t replace_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 78
static sf_count_t replace_write_s2d(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 79
static sf_count_t replace_write_i2d(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 80
static sf_count_t replace_write_f2d(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 81
static sf_count_t replace_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 83
static void d2bd_read(double *buffer , int count ) ;
#line 84
static void bd2d_write(double *buffer , int count ) ;
#line 91 "/root/libsndfile/src/double64.c"
int double64_init(SF_PRIVATE *psf ) 
{ 
  static int double64_caps ;
  int __cil_tmp3 ;
  sf_count_t tmp ;

  {
  {
#line 94
  double64_caps = double64_get_capability(psf);
#line 96
  psf->blockwidth = (int )(sizeof(double ) * (unsigned long )psf->sf.channels);
  }
#line 98
  if (psf->mode == 16) {
    _L: /* CIL Label */ 
    {
#line 100
    if (psf->endian + double64_caps == 536870964) {
#line 100
      goto case_536870964;
    }
#line 108
    if (psf->endian + double64_caps == 268435491) {
#line 108
      goto case_268435491;
    }
#line 116
    if (psf->endian + double64_caps == 536870947) {
#line 116
      goto case_536870947;
    }
#line 124
    if (psf->endian + double64_caps == 268435508) {
#line 124
      goto case_268435508;
    }
#line 133
    if (psf->endian + double64_caps == 536870998) {
#line 133
      goto case_536870998;
    }
#line 141
    if (psf->endian + double64_caps == 268435525) {
#line 141
      goto case_268435525;
    }
#line 149
    if (psf->endian + double64_caps == 536870981) {
#line 149
      goto case_536870981;
    }
#line 157
    if (psf->endian + double64_caps == 268435542) {
#line 157
      goto case_268435542;
    }
#line 165
    goto switch_default;
    case_536870964: /* CIL Label */ 
#line 101
    psf->data_endswap = 0;
#line 102
    psf->read_short = & host_read_d2s;
#line 103
    psf->read_int = & host_read_d2i;
#line 104
    psf->read_float = & host_read_d2f;
#line 105
    psf->read_double = & host_read_d;
#line 106
    goto switch_break;
    case_268435491: /* CIL Label */ 
#line 109
    psf->data_endswap = 0;
#line 110
    psf->read_short = & host_read_d2s;
#line 111
    psf->read_int = & host_read_d2i;
#line 112
    psf->read_float = & host_read_d2f;
#line 113
    psf->read_double = & host_read_d;
#line 114
    goto switch_break;
    case_536870947: /* CIL Label */ 
#line 117
    psf->data_endswap = 1;
#line 118
    psf->read_short = & host_read_d2s;
#line 119
    psf->read_int = & host_read_d2i;
#line 120
    psf->read_float = & host_read_d2f;
#line 121
    psf->read_double = & host_read_d;
#line 122
    goto switch_break;
    case_268435508: /* CIL Label */ 
#line 125
    psf->data_endswap = 1;
#line 126
    psf->read_short = & host_read_d2s;
#line 127
    psf->read_int = & host_read_d2i;
#line 128
    psf->read_float = & host_read_d2f;
#line 129
    psf->read_double = & host_read_d;
#line 130
    goto switch_break;
    case_536870998: /* CIL Label */ 
#line 134
    psf->data_endswap = 0;
#line 135
    psf->read_short = & replace_read_d2s;
#line 136
    psf->read_int = & replace_read_d2i;
#line 137
    psf->read_float = & replace_read_d2f;
#line 138
    psf->read_double = & replace_read_d;
#line 139
    goto switch_break;
    case_268435525: /* CIL Label */ 
#line 142
    psf->data_endswap = 0;
#line 143
    psf->read_short = & replace_read_d2s;
#line 144
    psf->read_int = & replace_read_d2i;
#line 145
    psf->read_float = & replace_read_d2f;
#line 146
    psf->read_double = & replace_read_d;
#line 147
    goto switch_break;
    case_536870981: /* CIL Label */ 
#line 150
    psf->data_endswap = 1;
#line 151
    psf->read_short = & replace_read_d2s;
#line 152
    psf->read_int = & replace_read_d2i;
#line 153
    psf->read_float = & replace_read_d2f;
#line 154
    psf->read_double = & replace_read_d;
#line 155
    goto switch_break;
    case_268435542: /* CIL Label */ 
#line 158
    psf->data_endswap = 1;
#line 159
    psf->read_short = & replace_read_d2s;
#line 160
    psf->read_int = & replace_read_d2i;
#line 161
    psf->read_float = & replace_read_d2f;
#line 162
    psf->read_double = & replace_read_d;
#line 163
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 165
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }

  } else
#line 98
  if (psf->mode == 48) {
#line 98
    goto _L;
  }

#line 169
  if (psf->mode == 32) {
    _L___5: /* CIL Label */ 
    {
#line 171
    if (psf->endian + double64_caps == 268435491) {
#line 171
      goto case_268435491___0;
    }
#line 179
    if (psf->endian + double64_caps == 536870964) {
#line 179
      goto case_536870964___0;
    }
#line 187
    if (psf->endian + double64_caps == 536870947) {
#line 187
      goto case_536870947___0;
    }
#line 195
    if (psf->endian + double64_caps == 268435508) {
#line 195
      goto case_268435508___0;
    }
#line 204
    if (psf->endian + double64_caps == 268435525) {
#line 204
      goto case_268435525___0;
    }
#line 212
    if (psf->endian + double64_caps == 536870998) {
#line 212
      goto case_536870998___0;
    }
#line 220
    if (psf->endian + double64_caps == 536870981) {
#line 220
      goto case_536870981___0;
    }
#line 228
    if (psf->endian + double64_caps == 268435542) {
#line 228
      goto case_268435542___0;
    }
#line 236
    goto switch_default___0;
    case_268435491___0: /* CIL Label */ 
#line 172
    psf->data_endswap = 0;
#line 173
    psf->write_short = & host_write_s2d;
#line 174
    psf->write_int = & host_write_i2d;
#line 175
    psf->write_float = & host_write_f2d;
#line 176
    psf->write_double = & host_write_d;
#line 177
    goto switch_break___0;
    case_536870964___0: /* CIL Label */ 
#line 180
    psf->data_endswap = 0;
#line 181
    psf->write_short = & host_write_s2d;
#line 182
    psf->write_int = & host_write_i2d;
#line 183
    psf->write_float = & host_write_f2d;
#line 184
    psf->write_double = & host_write_d;
#line 185
    goto switch_break___0;
    case_536870947___0: /* CIL Label */ 
#line 188
    psf->data_endswap = 1;
#line 189
    psf->write_short = & host_write_s2d;
#line 190
    psf->write_int = & host_write_i2d;
#line 191
    psf->write_float = & host_write_f2d;
#line 192
    psf->write_double = & host_write_d;
#line 193
    goto switch_break___0;
    case_268435508___0: /* CIL Label */ 
#line 196
    psf->data_endswap = 1;
#line 197
    psf->write_short = & host_write_s2d;
#line 198
    psf->write_int = & host_write_i2d;
#line 199
    psf->write_float = & host_write_f2d;
#line 200
    psf->write_double = & host_write_d;
#line 201
    goto switch_break___0;
    case_268435525___0: /* CIL Label */ 
#line 205
    psf->data_endswap = 0;
#line 206
    psf->write_short = & replace_write_s2d;
#line 207
    psf->write_int = & replace_write_i2d;
#line 208
    psf->write_float = & replace_write_f2d;
#line 209
    psf->write_double = & replace_write_d;
#line 210
    goto switch_break___0;
    case_536870998___0: /* CIL Label */ 
#line 213
    psf->data_endswap = 0;
#line 214
    psf->write_short = & replace_write_s2d;
#line 215
    psf->write_int = & replace_write_i2d;
#line 216
    psf->write_float = & replace_write_f2d;
#line 217
    psf->write_double = & replace_write_d;
#line 218
    goto switch_break___0;
    case_536870981___0: /* CIL Label */ 
#line 221
    psf->data_endswap = 1;
#line 222
    psf->write_short = & replace_write_s2d;
#line 223
    psf->write_int = & replace_write_i2d;
#line 224
    psf->write_float = & replace_write_f2d;
#line 225
    psf->write_double = & replace_write_d;
#line 226
    goto switch_break___0;
    case_268435542___0: /* CIL Label */ 
#line 229
    psf->data_endswap = 1;
#line 230
    psf->write_short = & replace_write_s2d;
#line 231
    psf->write_int = & replace_write_i2d;
#line 232
    psf->write_float = & replace_write_f2d;
#line 233
    psf->write_double = & replace_write_d;
#line 234
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 236
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }

  } else
#line 169
  if (psf->mode == 48) {
#line 169
    goto _L___5;
  }

#line 240
  if (psf->filelength > psf->dataoffset) {
#line 241
    if (psf->dataend > 0L) {
#line 241
      tmp = psf->dataend - psf->dataoffset;
    } else {
#line 241
      tmp = psf->filelength - psf->dataoffset;
    }
#line 241
    psf->datalength = tmp;
  } else {
#line 245
    psf->datalength = (sf_count_t )0;
  }
#line 247
  psf->sf.frames = psf->datalength / (long )psf->blockwidth;
#line 249
  return (0);
}
}
#line 279 "/root/libsndfile/src/double64.c"
double double64_be_read(unsigned char *cptr ) 
{ 
  int exponent ;
  int negative ;
  int upper ;
  int lower ;
  double dvalue ;
  int tmp ;
  double __cil_tmp8 ;
  int __cil_tmp9 ;
  double __cil_tmp10 ;

  {
#line 283
  if ((int )*(cptr + 0) & 128) {
#line 283
    tmp = 1;
  } else {
#line 283
    tmp = 0;
  }
#line 283
  negative = tmp;
#line 284
  exponent = (((int )*(cptr + 0) & 127) << 4) | (((int )*(cptr + 1) >> 4) & 15);
#line 287
  upper = (((((int )*(cptr + 1) & 15) << 24) | ((int )*(cptr + 2) << 16)) | ((int )*(cptr + 3) << 8)) | (int )*(cptr + 4);
#line 288
  lower = (((int )*(cptr + 5) << 16) | ((int )*(cptr + 6) << 8)) | (int )*(cptr + 7);
#line 290
  if (exponent == 0) {
#line 290
    if (upper == 0) {
#line 290
      if (lower == 0) {
#line 291
        return (0.);
      }
    }
  }
#line 293
  dvalue = (double )upper + (double )lower / (double )16777216;
#line 294
  dvalue += (double )268435456;
#line 296
  exponent -= 1023;
#line 298
  dvalue /= (double )268435456;
#line 300
  if (negative) {
#line 301
    dvalue *= (double )(- 1);
  }
#line 303
  if (exponent > 0) {
    {
#line 304
    __cil_tmp8 = pow(2., (double )exponent);
    }
#line 304
    dvalue *= __cil_tmp8;
  } else
#line 305
  if (exponent < 0) {
    {
#line 306
    __cil_tmp9 = abs(exponent);
#line 306
    __cil_tmp10 = pow(2., (double )__cil_tmp9);
    }
#line 306
    dvalue /= __cil_tmp10;
  }
#line 308
  return (dvalue);
}
}
#line 312 "/root/libsndfile/src/double64.c"
double double64_le_read(unsigned char *cptr ) 
{ 
  int exponent ;
  int negative ;
  int upper ;
  int lower ;
  double dvalue ;
  int tmp ;
  double __cil_tmp8 ;
  int __cil_tmp9 ;
  double __cil_tmp10 ;

  {
#line 316
  if ((int )*(cptr + 7) & 128) {
#line 316
    tmp = 1;
  } else {
#line 316
    tmp = 0;
  }
#line 316
  negative = tmp;
#line 317
  exponent = (((int )*(cptr + 7) & 127) << 4) | (((int )*(cptr + 6) >> 4) & 15);
#line 320
  upper = (((((int )*(cptr + 6) & 15) << 24) | ((int )*(cptr + 5) << 16)) | ((int )*(cptr + 4) << 8)) | (int )*(cptr + 3);
#line 321
  lower = (((int )*(cptr + 2) << 16) | ((int )*(cptr + 1) << 8)) | (int )*(cptr + 0);
#line 323
  if (exponent == 0) {
#line 323
    if (upper == 0) {
#line 323
      if (lower == 0) {
#line 324
        return (0.);
      }
    }
  }
#line 326
  dvalue = (double )upper + (double )lower / (double )16777216;
#line 327
  dvalue += (double )268435456;
#line 329
  exponent -= 1023;
#line 331
  dvalue /= (double )268435456;
#line 333
  if (negative) {
#line 334
    dvalue *= (double )(- 1);
  }
#line 336
  if (exponent > 0) {
    {
#line 337
    __cil_tmp8 = pow(2., (double )exponent);
    }
#line 337
    dvalue *= __cil_tmp8;
  } else
#line 338
  if (exponent < 0) {
    {
#line 339
    __cil_tmp9 = abs(exponent);
#line 339
    __cil_tmp10 = pow(2., (double )__cil_tmp9);
    }
#line 339
    dvalue /= __cil_tmp10;
  }
#line 341
  return (dvalue);
}
}
#line 345 "/root/libsndfile/src/double64.c"
void double64_be_write(double in , unsigned char *out ) 
{ 
  int exponent ;
  int mantissa ;
  double __cil_tmp5 ;
  double __cil_tmp6 ;
  double __cil_tmp7 ;
  long __cil_tmp8 ;
  double __cil_tmp9 ;
  double __cil_tmp10 ;
  long __cil_tmp11 ;

  {
  {
#line 348
  memset(out, 0, sizeof(double ));
#line 350
  __cil_tmp5 = fabs(in);
  }
#line 350
  if (__cil_tmp5 < 1.00000000001e-30) {
#line 351
    return;
  }
#line 353
  if (in < 0.) {
#line 354
    in *= - 1.;
#line 355
    *(out + 0) |= 128;
  }
  {
#line 358
  in = frexp(in, & exponent);
#line 360
  exponent += 1022;
#line 362
  *(out + 0) |= (exponent >> 4) & 127;
#line 363
  *(out + 1) |= (exponent << 4) & 240;
#line 365
  in *= (double )536870912;
#line 366
  __cil_tmp7 = floor(in);
#line 366
  __cil_tmp8 = lrint(__cil_tmp7);
#line 366
  mantissa = (int )__cil_tmp8;
#line 368
  *(out + 1) |= (mantissa >> 24) & 15;
#line 369
  *(out + 2) = (unsigned char )((mantissa >> 16) & 255);
#line 370
  *(out + 3) = (unsigned char )((mantissa >> 8) & 255);
#line 371
  *(out + 4) = (unsigned char )(mantissa & 255);
#line 373
  in = fmod(in, 1.);
#line 374
  in *= (double )16777216;
#line 375
  __cil_tmp10 = floor(in);
#line 375
  __cil_tmp11 = lrint(__cil_tmp10);
#line 375
  mantissa = (int )__cil_tmp11;
#line 377
  *(out + 5) = (unsigned char )((mantissa >> 16) & 255);
#line 378
  *(out + 6) = (unsigned char )((mantissa >> 8) & 255);
#line 379
  *(out + 7) = (unsigned char )(mantissa & 255);
  }
#line 381
  return;
}
}
#line 385 "/root/libsndfile/src/double64.c"
void double64_le_write(double in , unsigned char *out ) 
{ 
  int exponent ;
  int mantissa ;
  double __cil_tmp5 ;
  double __cil_tmp6 ;
  double __cil_tmp7 ;
  long __cil_tmp8 ;
  double __cil_tmp9 ;
  double __cil_tmp10 ;
  long __cil_tmp11 ;

  {
  {
#line 388
  memset(out, 0, sizeof(double ));
#line 390
  __cil_tmp5 = fabs(in);
  }
#line 390
  if (__cil_tmp5 < 1.00000000001e-30) {
#line 391
    return;
  }
#line 393
  if (in < 0.) {
#line 394
    in *= - 1.;
#line 395
    *(out + 7) |= 128;
  }
  {
#line 398
  in = frexp(in, & exponent);
#line 400
  exponent += 1022;
#line 402
  *(out + 7) |= (exponent >> 4) & 127;
#line 403
  *(out + 6) |= (exponent << 4) & 240;
#line 405
  in *= (double )536870912;
#line 406
  __cil_tmp7 = floor(in);
#line 406
  __cil_tmp8 = lrint(__cil_tmp7);
#line 406
  mantissa = (int )__cil_tmp8;
#line 408
  *(out + 6) |= (mantissa >> 24) & 15;
#line 409
  *(out + 5) = (unsigned char )((mantissa >> 16) & 255);
#line 410
  *(out + 4) = (unsigned char )((mantissa >> 8) & 255);
#line 411
  *(out + 3) = (unsigned char )(mantissa & 255);
#line 413
  in = fmod(in, 1.);
#line 414
  in *= (double )16777216;
#line 415
  __cil_tmp10 = floor(in);
#line 415
  __cil_tmp11 = lrint(__cil_tmp10);
#line 415
  mantissa = (int )__cil_tmp11;
#line 417
  *(out + 2) = (unsigned char )((mantissa >> 16) & 255);
#line 418
  *(out + 1) = (unsigned char )((mantissa >> 8) & 255);
#line 419
  *(out + 0) = (unsigned char )(mantissa & 255);
  }
#line 421
  return;
}
}
#line 429 "/root/libsndfile/src/double64.c"
static void double64_peak_update(SF_PRIVATE *psf , double const   *buffer , int count ,
                                 sf_count_t indx ) 
{ 
  int chan ;
  int k ;
  int position ;
  float fmaxval ;
  double __cil_tmp9 ;
  double __cil_tmp10 ;
  double __cil_tmp11 ;
  int __cil_tmp12 ;

  {
#line 434
  chan = 0;
  {
#line 434
  while (1) {
    while_continue: /* CIL Label */ ;
#line 434
    if (! (chan < psf->sf.channels)) {
#line 434
      goto while_break;
    }
    {
#line 435
    __cil_tmp9 = fabs(*(buffer + chan));
#line 435
    fmaxval = (float )__cil_tmp9;
#line 436
    position = 0;
#line 437
    k = chan;
    }
    {
#line 437
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 437
      if (! (k < count)) {
#line 437
        goto while_break___0;
      }
      {
#line 438
      __cil_tmp10 = fabs(*(buffer + k));
      }
#line 438
      if ((double )fmaxval < __cil_tmp10) {
        {
#line 439
        __cil_tmp11 = fabs(*(buffer + k));
#line 439
        fmaxval = (float )__cil_tmp11;
#line 440
        position = k;
        }
      }
#line 437
      k += psf->sf.channels;
    }
    while_break___0: /* CIL Label */ ;
    }

#line 443
    if ((double )fmaxval > (psf->peak_info)->peaks[chan].value) {
#line 444
      (psf->peak_info)->peaks[chan].value = (double )fmaxval;
#line 445
      (psf->peak_info)->peaks[chan].position = (psf->write_current + indx) + (long )(position / psf->sf.channels);
    }

#line 434
    chan ++;
  }
  while_break: /* CIL Label */ ;
  }

#line 449
  return;
}
}
#line 453 "/root/libsndfile/src/double64.c"
static int double64_get_capability(SF_PRIVATE *psf ) 
{ 
  union __anonunion_328 data___0 ;
  int tmp ;

  {
#line 459
  data___0.d = 1.23456789013;
#line 461
  if (! psf->ieee_replace) {
#line 463
    if ((int )data___0.c[0] == 251) {
#line 463
      if ((int )data___0.c[1] == 89) {
#line 463
        if ((int )data___0.c[2] == 140) {
#line 463
          if ((int )data___0.c[3] == 66) {
#line 463
            if ((int )data___0.c[4] == 202) {
#line 463
              if ((int )data___0.c[5] == 192) {
#line 463
                if ((int )data___0.c[6] == 243) {
#line 463
                  if ((int )data___0.c[7] == 63) {
#line 465
                    return (35);
                  }
                }
              }
            }
          }
        }
      }
    }
#line 468
    if ((int )data___0.c[0] == 63) {
#line 468
      if ((int )data___0.c[1] == 243) {
#line 468
        if ((int )data___0.c[2] == 192) {
#line 468
          if ((int )data___0.c[3] == 202) {
#line 468
            if ((int )data___0.c[4] == 66) {
#line 468
              if ((int )data___0.c[5] == 140) {
#line 468
                if ((int )data___0.c[6] == 89) {
#line 468
                  if ((int )data___0.c[7] == 251) {
#line 470
                    return (52);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  {
#line 474
  psf_log_printf(psf, "Using IEEE replacement code for double.\n");
#line 476
  tmp = 69;
  }
#line 476
  return (tmp);
}
}
#line 483 "/root/libsndfile/src/double64.c"
static void d2s_array(double const   *src , int count , short *dest , double scale ) 
{ 
  long __cil_tmp5 ;

  {
  {
#line 484
  while (1) {
    while_continue: /* CIL Label */ ;
#line 484
    count --;
#line 484
    if (! (count >= 0)) {
#line 484
      goto while_break;
    }
    {
#line 485
    __cil_tmp5 = lrint(scale * *(src + count));
#line 485
    *(dest + count) = (short )__cil_tmp5;
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 490 "/root/libsndfile/src/double64.c"
static void d2s_clip_array(double const   *src , int count , short *dest , double scale ) 
{ 
  double tmp ;
  long __cil_tmp6 ;

  {
  {
#line 491
  while (1) {
    while_continue: /* CIL Label */ ;
#line 491
    count --;
#line 491
    if (! (count >= 0)) {
#line 491
      goto while_break;
    }
#line 492
    tmp = scale * *(src + count);
#line 494
    if (tmp > 32767.) {
#line 495
      *(dest + count) = (short )32767;
    } else
#line 496
    if (tmp < - 32768.) {
#line 497
      *(dest + count) = (short )-32768;
    } else {
      {
#line 499
      __cil_tmp6 = lrint(tmp);
#line 499
      *(dest + count) = (short )__cil_tmp6;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 504 "/root/libsndfile/src/double64.c"
static void d2i_array(double const   *src , int count , int *dest , double scale ) 
{ 
  long __cil_tmp5 ;

  {
  {
#line 505
  while (1) {
    while_continue: /* CIL Label */ ;
#line 505
    count --;
#line 505
    if (! (count >= 0)) {
#line 505
      goto while_break;
    }
    {
#line 506
    __cil_tmp5 = lrint(scale * *(src + count));
#line 506
    *(dest + count) = (int )__cil_tmp5;
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 511 "/root/libsndfile/src/double64.c"
static void d2i_clip_array(double const   *src , int count , int *dest , double scale ) 
{ 
  float tmp ;
  long __cil_tmp6 ;

  {
  {
#line 512
  while (1) {
    while_continue: /* CIL Label */ ;
#line 512
    count --;
#line 512
    if (! (count >= 0)) {
#line 512
      goto while_break;
    }
#line 513
    tmp = (float )(scale * *(src + count));
#line 515
    if ((double )tmp > 1. * (double )2147483647) {
#line 516
      *(dest + count) = 2147483647;
    } else
#line 517
    if ((double )tmp < - 1. * (double )2147483647) {
#line 518
      *(dest + count) = (-0x7FFFFFFF-1);
    } else {
      {
#line 520
      __cil_tmp6 = lrint((double )tmp);
#line 520
      *(dest + count) = (int )__cil_tmp6;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 525 "/root/libsndfile/src/double64.c"
__inline static void d2f_array___0(double const   *src , int count , float *dest ) 
{ 


  {
  {
#line 526
  while (1) {
    while_continue: /* CIL Label */ ;
#line 526
    count --;
#line 526
    if (! (count >= 0)) {
#line 526
      goto while_break;
    }
#line 527
    *(dest + count) = (float )*(src + count);
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 532 "/root/libsndfile/src/double64.c"
__inline static void s2d_array(short const   *src , double *dest , int count , double scale ) 
{ 


  {
  {
#line 533
  while (1) {
    while_continue: /* CIL Label */ ;
#line 533
    count --;
#line 533
    if (! (count >= 0)) {
#line 533
      goto while_break;
    }
#line 534
    *(dest + count) = scale * (double )((int )*(src + count));
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 539 "/root/libsndfile/src/double64.c"
__inline static void i2d_array(int const   *src , double *dest , int count , double scale ) 
{ 


  {
  {
#line 540
  while (1) {
    while_continue: /* CIL Label */ ;
#line 540
    count --;
#line 540
    if (! (count >= 0)) {
#line 540
      goto while_break;
    }
#line 541
    *(dest + count) = scale * (double )*(src + count);
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 546 "/root/libsndfile/src/double64.c"
__inline static void f2d_array___0(float const   *src , double *dest , int count ) 
{ 


  {
  {
#line 547
  while (1) {
    while_continue: /* CIL Label */ ;
#line 547
    count --;
#line 547
    if (! (count >= 0)) {
#line 547
      goto while_break;
    }
#line 548
    *(dest + count) = (double )*(src + count);
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 556 "/root/libsndfile/src/double64.c"
static sf_count_t host_read_d2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  void (*convert)(double const   * , int  , short * , double  ) ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  double scale ;
  void (*tmp)(double const   *src , int count , short *dest , double scale ) ;
  double tmp___0 ;
  sf_count_t __cil_tmp11 ;

  {
#line 559
  total = (sf_count_t )0;
#line 562
  if (psf->add_clipping) {
#line 562
    tmp = & d2s_clip_array;
  } else {
#line 562
    tmp = & d2s_array;
  }
#line 562
  convert = tmp;
#line 563
  bufferlen = (int )(sizeof(psf->u.dbuf) / sizeof(psf->u.dbuf[0]));
#line 564
  if (psf->float_int_mult == 0) {
#line 564
    tmp___0 = 1.;
  } else {
#line 564
    tmp___0 = (double )((float )32767 / psf->float_max);
  }
#line 564
  scale = tmp___0;
  {
#line 566
  while (1) {
    while_continue: /* CIL Label */ ;
#line 566
    if (! (len > 0L)) {
#line 566
      goto while_break;
    }
#line 567
    if (len < (long )bufferlen) {
#line 568
      bufferlen = (int )len;
    }
    {
#line 569
    __cil_tmp11 = psf_fread((double *)psf->u.dbuf, (sf_count_t )sizeof(double ), (sf_count_t )bufferlen,
                            psf);
#line 569
    readcount = (int )__cil_tmp11;
    }
#line 571
    if (psf->data_endswap == 1) {
      {
#line 572
      endswap_double_array((double *)psf->u.dbuf, readcount);
      }
    }
    {
#line 574
    (*convert)((double const   *)((double *)psf->u.dbuf), readcount, ptr + total,
               scale);
#line 575
    total += (long )readcount;
#line 576
    len -= (long )readcount;
    }
#line 577
    if (readcount < bufferlen) {
#line 578
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 581
  return (total);
}
}
#line 585 "/root/libsndfile/src/double64.c"
static sf_count_t host_read_d2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  void (*convert)(double const   * , int  , int * , double  ) ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  double scale ;
  void (*tmp)(double const   *src , int count , int *dest , double scale ) ;
  double tmp___0 ;
  sf_count_t __cil_tmp11 ;

  {
#line 588
  total = (sf_count_t )0;
#line 591
  if (psf->add_clipping) {
#line 591
    tmp = & d2i_clip_array;
  } else {
#line 591
    tmp = & d2i_array;
  }
#line 591
  convert = tmp;
#line 592
  bufferlen = (int )(sizeof(psf->u.dbuf) / sizeof(psf->u.dbuf[0]));
#line 593
  if (psf->float_int_mult == 0) {
#line 593
    tmp___0 = 1.;
  } else {
#line 593
    tmp___0 = (double )((float )2147483647 / psf->float_max);
  }
#line 593
  scale = tmp___0;
  {
#line 595
  while (1) {
    while_continue: /* CIL Label */ ;
#line 595
    if (! (len > 0L)) {
#line 595
      goto while_break;
    }
#line 596
    if (len < (long )bufferlen) {
#line 597
      bufferlen = (int )len;
    }
    {
#line 598
    __cil_tmp11 = psf_fread((double *)psf->u.dbuf, (sf_count_t )sizeof(double ), (sf_count_t )bufferlen,
                            psf);
#line 598
    readcount = (int )__cil_tmp11;
    }
#line 600
    if (psf->data_endswap == 1) {
      {
#line 601
      endswap_double_array((double *)psf->u.dbuf, bufferlen);
      }
    }
    {
#line 603
    (*convert)((double const   *)((double *)psf->u.dbuf), readcount, ptr + total,
               scale);
#line 604
    total += (long )readcount;
#line 605
    len -= (long )readcount;
    }
#line 606
    if (readcount < bufferlen) {
#line 607
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 610
  return (total);
}
}
#line 614 "/root/libsndfile/src/double64.c"
static sf_count_t host_read_d2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp7 ;

  {
#line 616
  total = (sf_count_t )0;
#line 618
  bufferlen = (int )(sizeof(psf->u.dbuf) / sizeof(psf->u.dbuf[0]));
  {
#line 620
  while (1) {
    while_continue: /* CIL Label */ ;
#line 620
    if (! (len > 0L)) {
#line 620
      goto while_break;
    }
#line 621
    if (len < (long )bufferlen) {
#line 622
      bufferlen = (int )len;
    }
    {
#line 623
    __cil_tmp7 = psf_fread((double *)psf->u.dbuf, (sf_count_t )sizeof(double ), (sf_count_t )bufferlen,
                           psf);
#line 623
    readcount = (int )__cil_tmp7;
    }
#line 625
    if (psf->data_endswap == 1) {
      {
#line 626
      endswap_double_array((double *)psf->u.dbuf, bufferlen);
      }
    }
    {
#line 628
    d2f_array___0((double const   *)((double *)psf->u.dbuf), readcount, ptr + total);
#line 629
    total += (long )readcount;
#line 630
    len -= (long )readcount;
    }
#line 631
    if (readcount < bufferlen) {
#line 632
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 635
  return (total);
}
}
#line 639 "/root/libsndfile/src/double64.c"
static sf_count_t host_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  sf_count_t readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp7 ;

  {
  {
#line 641
  total = (sf_count_t )0;
#line 643
  readcount = psf_fread(ptr, (sf_count_t )sizeof(double ), len, psf);
  }
#line 645
  if (psf->data_endswap != 1) {
#line 646
    return (readcount);
  }
#line 649
  if (readcount < 134217728L) {
    {
#line 650
    endswap_double_array(ptr, (int )readcount);
    }
#line 651
    return (readcount);
  }
#line 654
  bufferlen = 134217728;
  {
#line 655
  while (1) {
    while_continue: /* CIL Label */ ;
#line 655
    if (! (len > 0L)) {
#line 655
      goto while_break;
    }
#line 656
    if (len < (long )bufferlen) {
#line 657
      bufferlen = (int )len;
    }
    {
#line 659
    endswap_double_array(ptr + total, bufferlen);
#line 661
    total += (long )bufferlen;
#line 662
    len -= (long )bufferlen;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 665
  return (total);
}
}
#line 669 "/root/libsndfile/src/double64.c"
static sf_count_t host_write_s2d(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  double scale ;
  double tmp ;
  sf_count_t __cil_tmp9 ;

  {
#line 671
  total = (sf_count_t )0;
#line 674
  if (psf->scale_int_float == 0) {
#line 674
    tmp = 1.;
  } else {
#line 674
    tmp = 1. / (double )32768;
  }
#line 674
  scale = tmp;
#line 675
  bufferlen = (int )(sizeof(psf->u.dbuf) / sizeof(psf->u.dbuf[0]));
  {
#line 677
  while (1) {
    while_continue: /* CIL Label */ ;
#line 677
    if (! (len > 0L)) {
#line 677
      goto while_break;
    }
#line 678
    if (len < (long )bufferlen) {
#line 679
      bufferlen = (int )len;
    }
    {
#line 681
    s2d_array(ptr + total, (double *)psf->u.dbuf, bufferlen, scale);
    }
#line 683
    if (psf->peak_info) {
      {
#line 684
      double64_peak_update(psf, (double const   *)((double *)psf->u.dbuf), bufferlen,
                           total / (long )psf->sf.channels);
      }
    }
#line 686
    if (psf->data_endswap == 1) {
      {
#line 687
      endswap_double_array((double *)psf->u.dbuf, bufferlen);
      }
    }
    {
#line 689
    __cil_tmp9 = psf_fwrite((double *)psf->u.dbuf, (sf_count_t )sizeof(double ), (sf_count_t )bufferlen,
                            psf);
#line 689
    writecount = (int )__cil_tmp9;
#line 690
    total += (long )writecount;
    }
#line 691
    if (writecount < bufferlen) {
#line 692
      goto while_break;
    }
#line 693
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 696
  return (total);
}
}
#line 700 "/root/libsndfile/src/double64.c"
static sf_count_t host_write_i2d(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  double scale ;
  double tmp ;
  sf_count_t __cil_tmp9 ;

  {
#line 702
  total = (sf_count_t )0;
#line 705
  if (psf->scale_int_float == 0) {
#line 705
    tmp = 1.;
  } else {
#line 705
    tmp = 1. / (8. * (double )268435456);
  }
#line 705
  scale = tmp;
#line 706
  bufferlen = (int )(sizeof(psf->u.dbuf) / sizeof(psf->u.dbuf[0]));
  {
#line 708
  while (1) {
    while_continue: /* CIL Label */ ;
#line 708
    if (! (len > 0L)) {
#line 708
      goto while_break;
    }
#line 709
    if (len < (long )bufferlen) {
#line 710
      bufferlen = (int )len;
    }
    {
#line 711
    i2d_array(ptr + total, (double *)psf->u.dbuf, bufferlen, scale);
    }
#line 713
    if (psf->peak_info) {
      {
#line 714
      double64_peak_update(psf, (double const   *)((double *)psf->u.dbuf), bufferlen,
                           total / (long )psf->sf.channels);
      }
    }
#line 716
    if (psf->data_endswap == 1) {
      {
#line 717
      endswap_double_array((double *)psf->u.dbuf, bufferlen);
      }
    }
    {
#line 719
    __cil_tmp9 = psf_fwrite((double *)psf->u.dbuf, (sf_count_t )sizeof(double ), (sf_count_t )bufferlen,
                            psf);
#line 719
    writecount = (int )__cil_tmp9;
#line 720
    total += (long )writecount;
    }
#line 721
    if (writecount < bufferlen) {
#line 722
      goto while_break;
    }
#line 723
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 726
  return (total);
}
}
#line 730 "/root/libsndfile/src/double64.c"
static sf_count_t host_write_f2d(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp7 ;

  {
#line 732
  total = (sf_count_t )0;
#line 734
  bufferlen = (int )(sizeof(psf->u.dbuf) / sizeof(psf->u.dbuf[0]));
  {
#line 736
  while (1) {
    while_continue: /* CIL Label */ ;
#line 736
    if (! (len > 0L)) {
#line 736
      goto while_break;
    }
#line 737
    if (len < (long )bufferlen) {
#line 738
      bufferlen = (int )len;
    }
    {
#line 739
    f2d_array___0(ptr + total, (double *)psf->u.dbuf, bufferlen);
    }
#line 741
    if (psf->peak_info) {
      {
#line 742
      double64_peak_update(psf, (double const   *)((double *)psf->u.dbuf), bufferlen,
                           total / (long )psf->sf.channels);
      }
    }
#line 744
    if (psf->data_endswap == 1) {
      {
#line 745
      endswap_double_array((double *)psf->u.dbuf, bufferlen);
      }
    }
    {
#line 747
    __cil_tmp7 = psf_fwrite((double *)psf->u.dbuf, (sf_count_t )sizeof(double ), (sf_count_t )bufferlen,
                            psf);
#line 747
    writecount = (int )__cil_tmp7;
#line 748
    total += (long )writecount;
    }
#line 749
    if (writecount < bufferlen) {
#line 750
      goto while_break;
    }
#line 751
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 754
  return (total);
}
}
#line 758 "/root/libsndfile/src/double64.c"
static sf_count_t host_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp7 ;
  sf_count_t __cil_tmp8 ;

  {
#line 760
  total = (sf_count_t )0;
#line 762
  if (psf->peak_info) {
    {
#line 763
    double64_peak_update(psf, ptr, (int )len, (sf_count_t )0);
    }
  }
#line 765
  if (psf->data_endswap != 1) {
    {
#line 766
    __cil_tmp7 = psf_fwrite(ptr, (sf_count_t )sizeof(double ), len, psf);
    }
#line 766
    return (__cil_tmp7);
  }
#line 768
  bufferlen = (int )(sizeof(psf->u.dbuf) / sizeof(psf->u.dbuf[0]));
  {
#line 770
  while (1) {
    while_continue: /* CIL Label */ ;
#line 770
    if (! (len > 0L)) {
#line 770
      goto while_break;
    }
#line 771
    if (len < (long )bufferlen) {
#line 772
      bufferlen = (int )len;
    }
    {
#line 774
    endswap_double_copy((double *)psf->u.dbuf, ptr + total, bufferlen);
#line 776
    __cil_tmp8 = psf_fwrite((double *)psf->u.dbuf, (sf_count_t )sizeof(double ), (sf_count_t )bufferlen,
                            psf);
#line 776
    writecount = (int )__cil_tmp8;
#line 777
    total += (long )writecount;
    }
#line 778
    if (writecount < bufferlen) {
#line 779
      goto while_break;
    }
#line 780
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 783
  return (total);
}
}
#line 790 "/root/libsndfile/src/double64.c"
static sf_count_t replace_read_d2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  double scale ;
  double tmp ;
  sf_count_t __cil_tmp9 ;

  {
#line 792
  total = (sf_count_t )0;
#line 795
  bufferlen = (int )(sizeof(psf->u.dbuf) / sizeof(psf->u.dbuf[0]));
#line 796
  if (psf->float_int_mult == 0) {
#line 796
    tmp = 1.;
  } else {
#line 796
    tmp = (double )((float )32767 / psf->float_max);
  }
#line 796
  scale = tmp;
  {
#line 798
  while (1) {
    while_continue: /* CIL Label */ ;
#line 798
    if (! (len > 0L)) {
#line 798
      goto while_break;
    }
#line 799
    if (len < (long )bufferlen) {
#line 800
      bufferlen = (int )len;
    }
    {
#line 801
    __cil_tmp9 = psf_fread((double *)psf->u.dbuf, (sf_count_t )sizeof(double ), (sf_count_t )bufferlen,
                           psf);
#line 801
    readcount = (int )__cil_tmp9;
    }
#line 803
    if (psf->data_endswap == 1) {
      {
#line 804
      endswap_double_array((double *)psf->u.dbuf, bufferlen);
      }
    }
    {
#line 806
    d2bd_read((double *)psf->u.dbuf, bufferlen);
#line 808
    d2s_array((double const   *)((double *)psf->u.dbuf), readcount, ptr + total, scale);
#line 809
    total += (long )readcount;
    }
#line 810
    if (readcount < bufferlen) {
#line 811
      goto while_break;
    }
#line 812
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 815
  return (total);
}
}
#line 819 "/root/libsndfile/src/double64.c"
static sf_count_t replace_read_d2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  double scale ;
  double tmp ;
  sf_count_t __cil_tmp9 ;

  {
#line 821
  total = (sf_count_t )0;
#line 824
  bufferlen = (int )(sizeof(psf->u.dbuf) / sizeof(psf->u.dbuf[0]));
#line 825
  if (psf->float_int_mult == 0) {
#line 825
    tmp = 1.;
  } else {
#line 825
    tmp = (double )((float )2147483647 / psf->float_max);
  }
#line 825
  scale = tmp;
  {
#line 827
  while (1) {
    while_continue: /* CIL Label */ ;
#line 827
    if (! (len > 0L)) {
#line 827
      goto while_break;
    }
#line 828
    if (len < (long )bufferlen) {
#line 829
      bufferlen = (int )len;
    }
    {
#line 830
    __cil_tmp9 = psf_fread((double *)psf->u.dbuf, (sf_count_t )sizeof(double ), (sf_count_t )bufferlen,
                           psf);
#line 830
    readcount = (int )__cil_tmp9;
    }
#line 832
    if (psf->data_endswap == 1) {
      {
#line 833
      endswap_double_array((double *)psf->u.dbuf, bufferlen);
      }
    }
    {
#line 835
    d2bd_read((double *)psf->u.dbuf, bufferlen);
#line 837
    d2i_array((double const   *)((double *)psf->u.dbuf), readcount, ptr + total, scale);
#line 838
    total += (long )readcount;
    }
#line 839
    if (readcount < bufferlen) {
#line 840
      goto while_break;
    }
#line 841
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 844
  return (total);
}
}
#line 848 "/root/libsndfile/src/double64.c"
static sf_count_t replace_read_d2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp7 ;

  {
#line 850
  total = (sf_count_t )0;
#line 852
  bufferlen = (int )(sizeof(psf->u.dbuf) / sizeof(psf->u.dbuf[0]));
  {
#line 854
  while (1) {
    while_continue: /* CIL Label */ ;
#line 854
    if (! (len > 0L)) {
#line 854
      goto while_break;
    }
#line 855
    if (len < (long )bufferlen) {
#line 856
      bufferlen = (int )len;
    }
    {
#line 857
    __cil_tmp7 = psf_fread((double *)psf->u.dbuf, (sf_count_t )sizeof(double ), (sf_count_t )bufferlen,
                           psf);
#line 857
    readcount = (int )__cil_tmp7;
    }
#line 859
    if (psf->data_endswap == 1) {
      {
#line 860
      endswap_double_array((double *)psf->u.dbuf, bufferlen);
      }
    }
    {
#line 862
    d2bd_read((double *)psf->u.dbuf, bufferlen);
#line 864
    memcpy(ptr + total, (double *)psf->u.dbuf, (unsigned long )bufferlen * sizeof(double ));
#line 866
    total += (long )readcount;
    }
#line 867
    if (readcount < bufferlen) {
#line 868
      goto while_break;
    }
#line 869
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 872
  return (total);
}
}
#line 876 "/root/libsndfile/src/double64.c"
static sf_count_t replace_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp7 ;

  {
#line 878
  total = (sf_count_t )0;
#line 881
  bufferlen = (int )(sizeof(psf->u.dbuf) / sizeof(psf->u.dbuf[0]));
  {
#line 883
  while (1) {
    while_continue: /* CIL Label */ ;
#line 883
    if (! (len > 0L)) {
#line 883
      goto while_break;
    }
#line 884
    if (len < (long )bufferlen) {
#line 885
      bufferlen = (int )len;
    }
    {
#line 886
    __cil_tmp7 = psf_fread((double *)psf->u.dbuf, (sf_count_t )sizeof(double ), (sf_count_t )bufferlen,
                           psf);
#line 886
    readcount = (int )__cil_tmp7;
    }
#line 888
    if (psf->data_endswap == 1) {
      {
#line 889
      endswap_double_array((double *)psf->u.dbuf, readcount);
      }
    }
    {
#line 891
    d2bd_read((double *)psf->u.dbuf, readcount);
#line 893
    memcpy(ptr + total, (double *)psf->u.dbuf, (unsigned long )readcount * sizeof(double ));
#line 895
    total += (long )readcount;
    }
#line 896
    if (readcount < bufferlen) {
#line 897
      goto while_break;
    }
#line 898
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 901
  return (total);
}
}
#line 905 "/root/libsndfile/src/double64.c"
static sf_count_t replace_write_s2d(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  double scale ;
  double tmp ;
  sf_count_t __cil_tmp9 ;

  {
#line 907
  total = (sf_count_t )0;
#line 910
  if (psf->scale_int_float == 0) {
#line 910
    tmp = 1.;
  } else {
#line 910
    tmp = 1. / (double )32768;
  }
#line 910
  scale = tmp;
#line 911
  bufferlen = (int )(sizeof(psf->u.dbuf) / sizeof(psf->u.dbuf[0]));
  {
#line 913
  while (1) {
    while_continue: /* CIL Label */ ;
#line 913
    if (! (len > 0L)) {
#line 913
      goto while_break;
    }
#line 914
    if (len < (long )bufferlen) {
#line 915
      bufferlen = (int )len;
    }
    {
#line 916
    s2d_array(ptr + total, (double *)psf->u.dbuf, bufferlen, scale);
    }
#line 918
    if (psf->peak_info) {
      {
#line 919
      double64_peak_update(psf, (double const   *)((double *)psf->u.dbuf), bufferlen,
                           total / (long )psf->sf.channels);
      }
    }
    {
#line 921
    bd2d_write((double *)psf->u.dbuf, bufferlen);
    }
#line 923
    if (psf->data_endswap == 1) {
      {
#line 924
      endswap_double_array((double *)psf->u.dbuf, bufferlen);
      }
    }
    {
#line 926
    __cil_tmp9 = psf_fwrite((double *)psf->u.dbuf, (sf_count_t )sizeof(double ), (sf_count_t )bufferlen,
                            psf);
#line 926
    writecount = (int )__cil_tmp9;
#line 927
    total += (long )writecount;
    }
#line 928
    if (writecount < bufferlen) {
#line 929
      goto while_break;
    }
#line 930
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 933
  return (total);
}
}
#line 937 "/root/libsndfile/src/double64.c"
static sf_count_t replace_write_i2d(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  double scale ;
  double tmp ;
  sf_count_t __cil_tmp9 ;

  {
#line 939
  total = (sf_count_t )0;
#line 942
  if (psf->scale_int_float == 0) {
#line 942
    tmp = 1.;
  } else {
#line 942
    tmp = 1. / (8. * (double )268435456);
  }
#line 942
  scale = tmp;
#line 943
  bufferlen = (int )(sizeof(psf->u.dbuf) / sizeof(psf->u.dbuf[0]));
  {
#line 945
  while (1) {
    while_continue: /* CIL Label */ ;
#line 945
    if (! (len > 0L)) {
#line 945
      goto while_break;
    }
#line 946
    if (len < (long )bufferlen) {
#line 947
      bufferlen = (int )len;
    }
    {
#line 948
    i2d_array(ptr + total, (double *)psf->u.dbuf, bufferlen, scale);
    }
#line 950
    if (psf->peak_info) {
      {
#line 951
      double64_peak_update(psf, (double const   *)((double *)psf->u.dbuf), bufferlen,
                           total / (long )psf->sf.channels);
      }
    }
    {
#line 953
    bd2d_write((double *)psf->u.dbuf, bufferlen);
    }
#line 955
    if (psf->data_endswap == 1) {
      {
#line 956
      endswap_double_array((double *)psf->u.dbuf, bufferlen);
      }
    }
    {
#line 958
    __cil_tmp9 = psf_fwrite((double *)psf->u.dbuf, (sf_count_t )sizeof(double ), (sf_count_t )bufferlen,
                            psf);
#line 958
    writecount = (int )__cil_tmp9;
#line 959
    total += (long )writecount;
    }
#line 960
    if (writecount < bufferlen) {
#line 961
      goto while_break;
    }
#line 962
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 965
  return (total);
}
}
#line 969 "/root/libsndfile/src/double64.c"
static sf_count_t replace_write_f2d(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp7 ;

  {
#line 971
  total = (sf_count_t )0;
#line 973
  bufferlen = (int )(sizeof(psf->u.dbuf) / sizeof(psf->u.dbuf[0]));
  {
#line 975
  while (1) {
    while_continue: /* CIL Label */ ;
#line 975
    if (! (len > 0L)) {
#line 975
      goto while_break;
    }
#line 976
    if (len < (long )bufferlen) {
#line 977
      bufferlen = (int )len;
    }
    {
#line 978
    f2d_array___0(ptr + total, (double *)psf->u.dbuf, bufferlen);
#line 980
    bd2d_write((double *)psf->u.dbuf, bufferlen);
    }
#line 982
    if (psf->data_endswap == 1) {
      {
#line 983
      endswap_double_array((double *)psf->u.dbuf, bufferlen);
      }
    }
    {
#line 985
    __cil_tmp7 = psf_fwrite((double *)psf->u.dbuf, (sf_count_t )sizeof(double ), (sf_count_t )bufferlen,
                            psf);
#line 985
    writecount = (int )__cil_tmp7;
#line 986
    total += (long )writecount;
    }
#line 987
    if (writecount < bufferlen) {
#line 988
      goto while_break;
    }
#line 989
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 992
  return (total);
}
}
#line 996 "/root/libsndfile/src/double64.c"
static sf_count_t replace_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp7 ;

  {
#line 998
  total = (sf_count_t )0;
#line 1001
  if (psf->peak_info) {
    {
#line 1002
    double64_peak_update(psf, ptr, (int )len, (sf_count_t )0);
    }
  }
#line 1004
  bufferlen = (int )(sizeof(psf->u.dbuf) / sizeof(psf->u.dbuf[0]));
  {
#line 1006
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1006
    if (! (len > 0L)) {
#line 1006
      goto while_break;
    }
#line 1007
    if (len < (long )bufferlen) {
#line 1008
      bufferlen = (int )len;
    }
    {
#line 1010
    memcpy((double *)psf->u.dbuf, ptr + total, (unsigned long )bufferlen * sizeof(double ));
#line 1012
    bd2d_write((double *)psf->u.dbuf, bufferlen);
    }
#line 1014
    if (psf->data_endswap == 1) {
      {
#line 1015
      endswap_double_array((double *)psf->u.dbuf, bufferlen);
      }
    }
    {
#line 1017
    __cil_tmp7 = psf_fwrite((double *)psf->u.dbuf, (sf_count_t )sizeof(double ), (sf_count_t )bufferlen,
                            psf);
#line 1017
    writecount = (int )__cil_tmp7;
#line 1018
    total += (long )writecount;
    }
#line 1019
    if (writecount < bufferlen) {
#line 1020
      goto while_break;
    }
#line 1021
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 1024
  return (total);
}
}
#line 1031 "/root/libsndfile/src/double64.c"
static void d2bd_read(double *buffer , int count ) 
{ 
  double __cil_tmp3 ;

  {
  {
#line 1032
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1032
    count --;
#line 1032
    if (! (count >= 0)) {
#line 1032
      goto while_break;
    }
    {
#line 1033
    *(buffer + count) = double64_le_read((unsigned char *)(buffer + count));
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 1038 "/root/libsndfile/src/double64.c"
static void bd2d_write(double *buffer , int count ) 
{ 


  {
  {
#line 1039
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1039
    count --;
#line 1039
    if (! (count >= 0)) {
#line 1039
      goto while_break;
    }
    {
#line 1040
    double64_le_write(*(buffer + count), (unsigned char *)(buffer + count));
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 78 "/root/libsndfile/src/dither.c"
static sf_count_t dither_read_short(SF_PRIVATE *UNUSED_psf , short *UNUSED_ptr , sf_count_t len ) ;
#line 79
static sf_count_t dither_read_int(SF_PRIVATE *UNUSED_psf , int *UNUSED_ptr , sf_count_t len ) ;
#line 81
static sf_count_t dither_write_short(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 82
static sf_count_t dither_write_int(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 83
static sf_count_t dither_write_float(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 84
static sf_count_t dither_write_double(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 87 "/root/libsndfile/src/dither.c"
int dither_init(SF_PRIVATE *psf , int mode ) 
{ 
  DITHER_DATA *pdither ;
  void *__cil_tmp4 ;
  void *__cil_tmp5 ;

  {
#line 90
  pdither = psf->dither;
#line 93
  if (mode == 16) {
#line 93
    if (psf->read_dither.type == 500) {
#line 94
      if (pdither == (void *)0) {
#line 95
        return (0);
      }
#line 97
      if (pdither->read_short) {
#line 98
        psf->read_short = pdither->read_short;
      }
#line 99
      if (pdither->read_int) {
#line 100
        psf->read_int = pdither->read_int;
      }
#line 101
      if (pdither->read_float) {
#line 102
        psf->read_float = pdither->read_float;
      }
#line 103
      if (pdither->read_double) {
#line 104
        psf->read_double = pdither->read_double;
      }
#line 105
      return (0);
    }
  }

#line 109
  if (mode == 32) {
#line 109
    if (psf->write_dither.type == 500) {
#line 110
      if (pdither == (void *)0) {
#line 111
        return (0);
      }
#line 113
      if (pdither->write_short) {
#line 114
        psf->write_short = pdither->write_short;
      }
#line 115
      if (pdither->write_int) {
#line 116
        psf->write_int = pdither->write_int;
      }
#line 117
      if (pdither->write_float) {
#line 118
        psf->write_float = pdither->write_float;
      }
#line 119
      if (pdither->write_double) {
#line 120
        psf->write_double = pdither->write_double;
      }
#line 121
      return (0);
    }
  }

#line 125
  if (mode == 16) {
#line 125
    if (psf->read_dither.type != 0) {
#line 126
      if (pdither == (void *)0) {
        {
#line 127
        pdither = (DITHER_DATA *)calloc((unsigned long )1, sizeof(DITHER_DATA ));
        }
      }
#line 128
      if (pdither == (void *)0) {
#line 129
        return (16);
      }
      {
#line 133
      if ((psf->sf.format & 65535) == 6) {
#line 133
        goto case_6;
      }
#line 133
      if ((psf->sf.format & 65535) == 7) {
#line 133
        goto case_6;
      }
#line 142
      if ((psf->sf.format & 65535) == 5) {
#line 142
        goto case_5;
      }
#line 142
      if ((psf->sf.format & 65535) == 1) {
#line 142
        goto case_5;
      }
#line 142
      if ((psf->sf.format & 65535) == 2) {
#line 142
        goto case_5;
      }
#line 142
      if ((psf->sf.format & 65535) == 3) {
#line 142
        goto case_5;
      }
#line 142
      if ((psf->sf.format & 65535) == 4) {
#line 142
        goto case_5;
      }
#line 147
      goto switch_default;
      case_6: /* CIL Label */ 
      case_7: /* CIL Label */ 
#line 134
      pdither->read_int = psf->read_int;
#line 135
      psf->read_int = & dither_read_int;
#line 136
      goto switch_break;
      case_5: /* CIL Label */ 
      case_1: /* CIL Label */ 
      case_2: /* CIL Label */ 
      case_3: /* CIL Label */ 
      case_4: /* CIL Label */ 
#line 143
      pdither->read_short = psf->read_short;
#line 144
      psf->read_short = & dither_read_short;
#line 145
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 147
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }

    }
  }

#line 152
  if (mode == 32) {
#line 152
    if (psf->write_dither.type != 0) {
#line 153
      if (pdither == (void *)0) {
        {
#line 154
        pdither = (DITHER_DATA *)calloc((unsigned long )1, sizeof(DITHER_DATA ));
        }
      }
#line 155
      if (pdither == (void *)0) {
#line 156
        return (16);
      }
      {
#line 160
      if ((psf->sf.format & 65535) == 6) {
#line 160
        goto case_6___0;
      }
#line 160
      if ((psf->sf.format & 65535) == 7) {
#line 160
        goto case_6___0;
      }
#line 169
      if ((psf->sf.format & 65535) == 5) {
#line 169
        goto case_5___0;
      }
#line 169
      if ((psf->sf.format & 65535) == 1) {
#line 169
        goto case_5___0;
      }
#line 169
      if ((psf->sf.format & 65535) == 2) {
#line 169
        goto case_5___0;
      }
#line 169
      if ((psf->sf.format & 65535) == 3) {
#line 169
        goto case_5___0;
      }
#line 169
      if ((psf->sf.format & 65535) == 4) {
#line 169
        goto case_5___0;
      }
#line 172
      goto switch_default___0;
      case_6___0: /* CIL Label */ 
      case_7___0: /* CIL Label */ 
#line 161
      pdither->write_int = psf->write_int;
#line 162
      psf->write_int = & dither_write_int;
#line 163
      goto switch_break___0;
      case_5___0: /* CIL Label */ 
      case_1___0: /* CIL Label */ 
      case_2___0: /* CIL Label */ 
      case_3___0: /* CIL Label */ 
      case_4___0: /* CIL Label */ 
#line 170
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
#line 172
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 175
      pdither->write_short = psf->write_short;
#line 176
      psf->write_short = & dither_write_short;
#line 178
      pdither->write_int = psf->write_int;
#line 179
      psf->write_int = & dither_write_int;
#line 181
      pdither->write_float = psf->write_float;
#line 182
      psf->write_float = & dither_write_float;
#line 184
      pdither->write_double = psf->write_double;
#line 185
      psf->write_double = & dither_write_double;
    }
  }

#line 188
  return (0);
}
}
#line 194
static void dither_short(short const   *in , short *out , int frames , int channels ) ;
#line 195
static void dither_int(int const   *in , int *out , int frames , int channels ) ;
#line 197
static void dither_float(float const   *in , float *out , int frames , int channels ) ;
#line 198
static void dither_double(double const   *in , double *out , int frames , int channels ) ;
#line 201 "/root/libsndfile/src/dither.c"
static sf_count_t dither_read_short(SF_PRIVATE *UNUSED_psf , short *UNUSED_ptr , sf_count_t len ) 
{ 


  {
#line 203
  return (len);
}
}
#line 207 "/root/libsndfile/src/dither.c"
static sf_count_t dither_read_int(SF_PRIVATE *UNUSED_psf , int *UNUSED_ptr , sf_count_t len ) 
{ 


  {
#line 209
  return (len);
}
}
#line 216 "/root/libsndfile/src/dither.c"
static sf_count_t dither_write_short(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  DITHER_DATA *pdither ;
  int bufferlen ;
  int writecount ;
  int thiswrite ;
  sf_count_t total ;
  sf_count_t __cil_tmp9 ;
  int tmp ;
  sf_count_t __cil_tmp11 ;

  {
#line 219
  total = (sf_count_t )0;
#line 221
  pdither = psf->dither;
#line 221
  if (pdither == (void *)0) {
#line 222
    psf->error = 666;
#line 223
    return ((sf_count_t )0);
  }

  {
#line 229
  if ((psf->sf.format & 65535) == 80) {
#line 229
    goto case_80;
  }
#line 229
  if ((psf->sf.format & 65535) == 5) {
#line 229
    goto case_80;
  }
#line 229
  if ((psf->sf.format & 65535) == 1) {
#line 229
    goto case_80;
  }
#line 232
  goto switch_default;
  case_80: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 230
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 233
  __cil_tmp9 = (*(pdither->write_short))(psf, ptr, len);
  }
#line 233
  return (__cil_tmp9);
  switch_break: /* CIL Label */ ;
  }
#line 236
  bufferlen = (int )(sizeof(pdither->buffer) / sizeof(short ));
  {
#line 238
  while (1) {
    while_continue: /* CIL Label */ ;
#line 238
    if (! (len > 0L)) {
#line 238
      goto while_break;
    }
#line 239
    if (len >= (long )bufferlen) {
#line 239
      tmp = bufferlen;
    } else {
#line 239
      tmp = (int )len;
    }
    {
#line 239
    writecount = tmp;
#line 240
    writecount /= psf->sf.channels;
#line 241
    writecount *= psf->sf.channels;
#line 243
    dither_short(ptr, (short *)((double *)pdither->buffer), writecount / psf->sf.channels,
                 psf->sf.channels);
#line 245
    __cil_tmp11 = (*(pdither->write_short))(psf, (short const   *)((short *)((double *)pdither->buffer)),
                                            (sf_count_t )writecount);
#line 245
    thiswrite = (int )__cil_tmp11;
#line 246
    total += (long )thiswrite;
#line 247
    len -= (long )thiswrite;
    }
#line 248
    if (thiswrite < writecount) {
#line 249
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 252
  return (total);
}
}
#line 256 "/root/libsndfile/src/dither.c"
static sf_count_t dither_write_int(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  DITHER_DATA *pdither ;
  int bufferlen ;
  int writecount ;
  int thiswrite ;
  sf_count_t total ;
  sf_count_t __cil_tmp9 ;
  int tmp ;
  sf_count_t __cil_tmp11 ;

  {
#line 259
  total = (sf_count_t )0;
#line 261
  pdither = psf->dither;
#line 261
  if (pdither == (void *)0) {
#line 262
    psf->error = 666;
#line 263
    return ((sf_count_t )0);
  }

  {
#line 270
  if ((psf->sf.format & 65535) == 3) {
#line 270
    goto case_3;
  }
#line 270
  if ((psf->sf.format & 65535) == 2) {
#line 270
    goto case_3;
  }
#line 270
  if ((psf->sf.format & 65535) == 5) {
#line 270
    goto case_3;
  }
#line 270
  if ((psf->sf.format & 65535) == 1) {
#line 270
    goto case_3;
  }
#line 274
  if ((psf->sf.format & 65535) == 81) {
#line 274
    goto case_81;
  }
#line 274
  if ((psf->sf.format & 65535) == 80) {
#line 274
    goto case_81;
  }
#line 277
  goto switch_default;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 271
  goto switch_break;
  case_81: /* CIL Label */ 
  case_80: /* CIL Label */ 
#line 275
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 278
  __cil_tmp9 = (*(pdither->write_int))(psf, ptr, len);
  }
#line 278
  return (__cil_tmp9);
  switch_break: /* CIL Label */ ;
  }
#line 282
  bufferlen = (int )(sizeof(pdither->buffer) / sizeof(int ));
  {
#line 284
  while (1) {
    while_continue: /* CIL Label */ ;
#line 284
    if (! (len > 0L)) {
#line 284
      goto while_break;
    }
#line 285
    if (len >= (long )bufferlen) {
#line 285
      tmp = bufferlen;
    } else {
#line 285
      tmp = (int )len;
    }
    {
#line 285
    writecount = tmp;
#line 286
    writecount /= psf->sf.channels;
#line 287
    writecount *= psf->sf.channels;
#line 289
    dither_int(ptr, (int *)((double *)pdither->buffer), writecount / psf->sf.channels,
               psf->sf.channels);
#line 291
    __cil_tmp11 = (*(pdither->write_int))(psf, (int const   *)((int *)((double *)pdither->buffer)),
                                          (sf_count_t )writecount);
#line 291
    thiswrite = (int )__cil_tmp11;
#line 292
    total += (long )thiswrite;
#line 293
    len -= (long )thiswrite;
    }
#line 294
    if (thiswrite < writecount) {
#line 295
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 298
  return (total);
}
}
#line 302 "/root/libsndfile/src/dither.c"
static sf_count_t dither_write_float(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  DITHER_DATA *pdither ;
  int bufferlen ;
  int writecount ;
  int thiswrite ;
  sf_count_t total ;
  sf_count_t __cil_tmp9 ;
  float tmp ;
  sf_count_t __cil_tmp11 ;

  {
#line 305
  total = (sf_count_t )0;
#line 307
  pdither = psf->dither;
#line 307
  if (pdither == (void *)0) {
#line 308
    psf->error = 666;
#line 309
    return ((sf_count_t )0);
  }

  {
#line 316
  if ((psf->sf.format & 65535) == 3) {
#line 316
    goto case_3;
  }
#line 316
  if ((psf->sf.format & 65535) == 2) {
#line 316
    goto case_3;
  }
#line 316
  if ((psf->sf.format & 65535) == 5) {
#line 316
    goto case_3;
  }
#line 316
  if ((psf->sf.format & 65535) == 1) {
#line 316
    goto case_3;
  }
#line 320
  if ((psf->sf.format & 65535) == 81) {
#line 320
    goto case_81;
  }
#line 320
  if ((psf->sf.format & 65535) == 80) {
#line 320
    goto case_81;
  }
#line 323
  goto switch_default;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 317
  goto switch_break;
  case_81: /* CIL Label */ 
  case_80: /* CIL Label */ 
#line 321
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 324
  __cil_tmp9 = (*(pdither->write_float))(psf, ptr, len);
  }
#line 324
  return (__cil_tmp9);
  switch_break: /* CIL Label */ ;
  }
#line 327
  bufferlen = (int )(sizeof(pdither->buffer) / sizeof(float ));
  {
#line 329
  while (1) {
    while_continue: /* CIL Label */ ;
#line 329
    if (! (len > 0L)) {
#line 329
      goto while_break;
    }
#line 330
    if (len >= (long )bufferlen) {
#line 330
      tmp = (float )bufferlen;
    } else {
#line 330
      tmp = (float )len;
    }
    {
#line 330
    writecount = (int )tmp;
#line 331
    writecount /= psf->sf.channels;
#line 332
    writecount *= psf->sf.channels;
#line 334
    dither_float(ptr, (float *)((double *)pdither->buffer), writecount / psf->sf.channels,
                 psf->sf.channels);
#line 336
    __cil_tmp11 = (*(pdither->write_float))(psf, (float const   *)((float *)((double *)pdither->buffer)),
                                            (sf_count_t )writecount);
#line 336
    thiswrite = (int )__cil_tmp11;
#line 337
    total += (long )thiswrite;
#line 338
    len -= (long )thiswrite;
    }
#line 339
    if (thiswrite < writecount) {
#line 340
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 343
  return (total);
}
}
#line 347 "/root/libsndfile/src/dither.c"
static sf_count_t dither_write_double(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  DITHER_DATA *pdither ;
  int bufferlen ;
  int writecount ;
  int thiswrite ;
  sf_count_t total ;
  sf_count_t __cil_tmp9 ;
  double tmp ;
  sf_count_t __cil_tmp11 ;

  {
#line 350
  total = (sf_count_t )0;
#line 352
  pdither = psf->dither;
#line 352
  if (pdither == (void *)0) {
#line 353
    psf->error = 666;
#line 354
    return ((sf_count_t )0);
  }

  {
#line 361
  if ((psf->sf.format & 65535) == 3) {
#line 361
    goto case_3;
  }
#line 361
  if ((psf->sf.format & 65535) == 2) {
#line 361
    goto case_3;
  }
#line 361
  if ((psf->sf.format & 65535) == 5) {
#line 361
    goto case_3;
  }
#line 361
  if ((psf->sf.format & 65535) == 1) {
#line 361
    goto case_3;
  }
#line 365
  if ((psf->sf.format & 65535) == 81) {
#line 365
    goto case_81;
  }
#line 365
  if ((psf->sf.format & 65535) == 80) {
#line 365
    goto case_81;
  }
#line 368
  goto switch_default;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 362
  goto switch_break;
  case_81: /* CIL Label */ 
  case_80: /* CIL Label */ 
#line 366
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 369
  __cil_tmp9 = (*(pdither->write_double))(psf, ptr, len);
  }
#line 369
  return (__cil_tmp9);
  switch_break: /* CIL Label */ ;
  }
#line 373
  bufferlen = (int )(sizeof(pdither->buffer) / sizeof(double ));
  {
#line 375
  while (1) {
    while_continue: /* CIL Label */ ;
#line 375
    if (! (len > 0L)) {
#line 375
      goto while_break;
    }
#line 376
    if (len >= (long )bufferlen) {
#line 376
      tmp = (double )bufferlen;
    } else {
#line 376
      tmp = (double )len;
    }
    {
#line 376
    writecount = (int )tmp;
#line 377
    writecount /= psf->sf.channels;
#line 378
    writecount *= psf->sf.channels;
#line 380
    dither_double(ptr, (double *)((double *)pdither->buffer), writecount / psf->sf.channels,
                  psf->sf.channels);
#line 382
    __cil_tmp11 = (*(pdither->write_double))(psf, (double const   *)((double *)((double *)pdither->buffer)),
                                             (sf_count_t )writecount);
#line 382
    thiswrite = (int )__cil_tmp11;
#line 383
    total += (long )thiswrite;
#line 384
    len -= (long )thiswrite;
    }
#line 385
    if (thiswrite < writecount) {
#line 386
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 389
  return (total);
}
}
#line 396 "/root/libsndfile/src/dither.c"
static void dither_short(short const   *in , short *out , int frames , int channels ) 
{ 
  int ch ;
  int k ;
  int __cil_tmp7 ;

  {
#line 399
  ch = 0;
  {
#line 399
  while (1) {
    while_continue: /* CIL Label */ ;
#line 399
    if (! (ch < channels)) {
#line 399
      goto while_break;
    }
#line 400
    k = ch;
    {
#line 400
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 400
      if (! (k < channels * frames)) {
#line 400
        goto while_break___0;
      }
#line 401
      *(out + k) = *(in + k);
#line 400
      k += channels;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 399
    ch ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 406 "/root/libsndfile/src/dither.c"
static void dither_int(int const   *in , int *out , int frames , int channels ) 
{ 
  int ch ;
  int k ;
  int __cil_tmp7 ;

  {
#line 409
  ch = 0;
  {
#line 409
  while (1) {
    while_continue: /* CIL Label */ ;
#line 409
    if (! (ch < channels)) {
#line 409
      goto while_break;
    }
#line 410
    k = ch;
    {
#line 410
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 410
      if (! (k < channels * frames)) {
#line 410
        goto while_break___0;
      }
#line 411
      *(out + k) = *(in + k);
#line 410
      k += channels;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 409
    ch ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 416 "/root/libsndfile/src/dither.c"
static void dither_float(float const   *in , float *out , int frames , int channels ) 
{ 
  int ch ;
  int k ;
  int __cil_tmp7 ;

  {
#line 419
  ch = 0;
  {
#line 419
  while (1) {
    while_continue: /* CIL Label */ ;
#line 419
    if (! (ch < channels)) {
#line 419
      goto while_break;
    }
#line 420
    k = ch;
    {
#line 420
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 420
      if (! (k < channels * frames)) {
#line 420
        goto while_break___0;
      }
#line 421
      *(out + k) = *(in + k);
#line 420
      k += channels;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 419
    ch ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 426 "/root/libsndfile/src/dither.c"
static void dither_double(double const   *in , double *out , int frames , int channels ) 
{ 
  int ch ;
  int k ;
  int __cil_tmp7 ;

  {
#line 429
  ch = 0;
  {
#line 429
  while (1) {
    while_continue: /* CIL Label */ ;
#line 429
    if (! (ch < channels)) {
#line 429
      goto while_break;
    }
#line 430
    k = ch;
    {
#line 430
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 430
      if (! (k < channels * frames)) {
#line 430
        goto while_break___0;
      }
#line 431
      *(out + k) = *(in + k);
#line 430
      k += channels;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 429
    ch ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void) ;
#line 81
extern  __attribute__((__nothrow__)) __int32_t **__ctype_tolower_loc(void) ;
#line 83
extern  __attribute__((__nothrow__)) __int32_t **__ctype_toupper_loc(void) ;
#line 108
extern  __attribute__((__nothrow__)) int isalnum(int  ) ;
#line 109
extern  __attribute__((__nothrow__)) int isalpha(int  ) ;
#line 110
extern  __attribute__((__nothrow__)) int iscntrl(int  ) ;
#line 111
extern  __attribute__((__nothrow__)) int isdigit(int  ) ;
#line 112
extern  __attribute__((__nothrow__)) int islower(int  ) ;
#line 113
extern  __attribute__((__nothrow__)) int isgraph(int  ) ;
#line 114
extern  __attribute__((__nothrow__)) int isprint(int  ) ;
#line 115
extern  __attribute__((__nothrow__)) int ispunct(int  ) ;
#line 116
extern  __attribute__((__nothrow__)) int isspace(int  ) ;
#line 117
extern  __attribute__((__nothrow__)) int isupper(int  ) ;
#line 118
extern  __attribute__((__nothrow__)) int isxdigit(int  ) ;
#line 122
__inline extern  __attribute__((__nothrow__)) int tolower(int __c )  __attribute__((__gnu_inline__)) ;
#line 125
__inline extern  __attribute__((__nothrow__)) int toupper(int __c )  __attribute__((__gnu_inline__)) ;
#line 130
extern  __attribute__((__nothrow__)) int isblank(int  ) ;
#line 142
extern  __attribute__((__nothrow__)) int isascii(int __c ) ;
#line 146
extern  __attribute__((__nothrow__)) int toascii(int __c ) ;
#line 150
extern  __attribute__((__nothrow__)) int _toupper(int  ) ;
#line 151
extern  __attribute__((__nothrow__)) int _tolower(int  ) ;
#line 207
__inline extern  __attribute__((__nothrow__)) int tolower(int __c )  __attribute__((__gnu_inline__)) ;
#line 207 "/usr/include/ctype.h"
__inline extern int tolower(int __c ) 
{ 
  __int32_t **__cil_tmp2 ;
  __int32_t tmp ;

  {
#line 209
  if (__c >= -128 && __c < 256) {
    {
#line 209
    __cil_tmp2 = __ctype_tolower_loc();
#line 209
    tmp = *(*__cil_tmp2 + __c);
    }
  } else {
#line 209
    tmp = __c;
  }
#line 209
  return (tmp);
}
}
#line 213
__inline extern  __attribute__((__nothrow__)) int toupper(int __c )  __attribute__((__gnu_inline__)) ;
#line 213 "/usr/include/ctype.h"
__inline extern int toupper(int __c ) 
{ 
  __int32_t **__cil_tmp2 ;
  __int32_t tmp ;

  {
#line 215
  if (__c >= -128 && __c < 256) {
    {
#line 215
    __cil_tmp2 = __ctype_toupper_loc();
#line 215
    tmp = *(*__cil_tmp2 + __c);
    }
  } else {
#line 215
    tmp = __c;
  }
#line 215
  return (tmp);
}
}
#line 251
extern  __attribute__((__nothrow__)) int isalnum_l(int  , locale_t  ) ;
#line 252
extern  __attribute__((__nothrow__)) int isalpha_l(int  , locale_t  ) ;
#line 253
extern  __attribute__((__nothrow__)) int iscntrl_l(int  , locale_t  ) ;
#line 254
extern  __attribute__((__nothrow__)) int isdigit_l(int  , locale_t  ) ;
#line 255
extern  __attribute__((__nothrow__)) int islower_l(int  , locale_t  ) ;
#line 256
extern  __attribute__((__nothrow__)) int isgraph_l(int  , locale_t  ) ;
#line 257
extern  __attribute__((__nothrow__)) int isprint_l(int  , locale_t  ) ;
#line 258
extern  __attribute__((__nothrow__)) int ispunct_l(int  , locale_t  ) ;
#line 259
extern  __attribute__((__nothrow__)) int isspace_l(int  , locale_t  ) ;
#line 260
extern  __attribute__((__nothrow__)) int isupper_l(int  , locale_t  ) ;
#line 261
extern  __attribute__((__nothrow__)) int isxdigit_l(int  , locale_t  ) ;
#line 263
extern  __attribute__((__nothrow__)) int isblank_l(int  , locale_t  ) ;
#line 267
extern  __attribute__((__nothrow__)) int __tolower_l(int __c , locale_t __l ) ;
#line 268
extern  __attribute__((__nothrow__)) int tolower_l(int __c , locale_t __l ) ;
#line 271
extern  __attribute__((__nothrow__)) int __toupper_l(int __c , locale_t __l ) ;
#line 272
extern  __attribute__((__nothrow__)) int toupper_l(int __c , locale_t __l ) ;
#line 72 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) clock_t clock(void) ;
#line 75
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 78
extern  __attribute__((__nothrow__)) double difftime(time_t __time1 , time_t __time0 ) ;
#line 82
extern  __attribute__((__nothrow__)) time_t mktime(struct tm *__tp ) ;
#line 88
extern  __attribute__((__nothrow__)) size_t strftime(char *__s , size_t __maxsize ,
                                                     char const   *__format , struct tm *__tp ) ;
#line 104
extern  __attribute__((__nothrow__)) size_t strftime_l(char *__s , size_t __maxsize ,
                                                       char const   *__format , struct tm *__tp ,
                                                       locale_t __loc ) ;
#line 119
extern  __attribute__((__nothrow__)) struct tm *gmtime(time_t *__timer ) ;
#line 123
extern  __attribute__((__nothrow__)) struct tm *localtime(time_t *__timer ) ;
#line 128
extern  __attribute__((__nothrow__)) struct tm *gmtime_r(time_t *__timer , struct tm *__tp ) ;
#line 133
extern  __attribute__((__nothrow__)) struct tm *localtime_r(time_t *__timer , struct tm *__tp ) ;
#line 139
extern  __attribute__((__nothrow__)) char *asctime(struct tm *__tp ) ;
#line 142
extern  __attribute__((__nothrow__)) char *ctime(time_t *__timer ) ;
#line 149
extern  __attribute__((__nothrow__)) char *asctime_r(struct tm *__tp , char *__buf ) ;
#line 153
extern  __attribute__((__nothrow__)) char *ctime_r(time_t *__timer , char *__buf ) ;
#line 159
extern char *__tzname[2] ;
#line 160
extern int __daylight ;
#line 161
extern long __timezone ;
#line 166
extern char *tzname[2] ;
#line 170
extern  __attribute__((__nothrow__)) void tzset(void) ;
#line 174
extern int daylight ;
#line 175
extern long timezone ;
#line 190
extern  __attribute__((__nothrow__)) time_t timegm(struct tm *__tp ) ;
#line 193
extern  __attribute__((__nothrow__)) time_t timelocal(struct tm *__tp ) ;
#line 196
extern  __attribute__((__nothrow__)) int dysize(int __year ) ;
#line 205
extern int nanosleep(struct timespec *__requested_time , struct timespec *__remaining ) ;
#line 210
extern  __attribute__((__nothrow__)) int clock_getres(clockid_t __clock_id , struct timespec *__res ) ;
#line 213
extern  __attribute__((__nothrow__)) int clock_gettime(clockid_t __clock_id , struct timespec *__tp ) ;
#line 216
extern  __attribute__((__nothrow__)) int clock_settime(clockid_t __clock_id , struct timespec *__tp ) ;
#line 224
extern int clock_nanosleep(clockid_t __clock_id , int __flags , struct timespec *__req ,
                           struct timespec *__rem ) ;
#line 229
extern  __attribute__((__nothrow__)) int clock_getcpuclockid(pid_t __pid , clockid_t *__clock_id ) ;
#line 234
extern  __attribute__((__nothrow__)) int timer_create(clockid_t __clock_id , struct sigevent *__evp ,
                                                      timer_t *__timerid ) ;
#line 239
extern  __attribute__((__nothrow__)) int timer_delete(timer_t __timerid ) ;
#line 242
extern  __attribute__((__nothrow__)) int timer_settime(timer_t __timerid , int __flags ,
                                                       struct itimerspec *__value ,
                                                       struct itimerspec *__ovalue ) ;
#line 247
extern  __attribute__((__nothrow__)) int timer_gettime(timer_t __timerid , struct itimerspec *__value ) ;
#line 251
extern  __attribute__((__nothrow__)) int timer_getoverrun(timer_t __timerid ) ;
#line 66 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int gettimeofday(struct timeval *__tv , void *__tz ) ;
#line 75
extern  __attribute__((__nothrow__)) int settimeofday(struct timeval *__tv , struct timezone *__tz ) ;
#line 83
extern  __attribute__((__nothrow__)) int adjtime(struct timeval *__delta , struct timeval *__olddelta ) ;
#line 123
extern  __attribute__((__nothrow__)) int getitimer(__itimer_which_t __which , struct itimerval *__value ) ;
#line 129
extern  __attribute__((__nothrow__)) int setitimer(__itimer_which_t __which , struct itimerval *__new ,
                                                   struct itimerval *__old ) ;
#line 136
extern  __attribute__((__nothrow__)) int utimes(char const   *__file , struct timeval __tvp[2] ) ;
#line 141
extern  __attribute__((__nothrow__)) int lutimes(char const   *__file , struct timeval __tvp[2] ) ;
#line 145
extern  __attribute__((__nothrow__)) int futimes(int __fd , struct timeval __tvp[2] ) ;
#line 42 "/root/libsndfile/src/common.c"
__inline static void log_putchar(SF_PRIVATE *psf , char ch ) 
{ 
  int __cil_tmp3 ;

  {
#line 43
  if (psf->logindex < (int )sizeof(psf->logbuffer) - 1) {
#line 44
    __cil_tmp3 = psf->logindex;
#line 44
    (psf->logindex) ++;
#line 44
    psf->logbuffer[__cil_tmp3] = ch;
#line 45
    psf->logbuffer[psf->logindex] = (char )0;
  }

#line 47
  return;
}
}
#line 51 "/root/libsndfile/src/common.c"
void psf_log_printf(SF_PRIVATE *psf , char const   *format  , ...) 
{ 
  va_list ap ;
  unsigned int u ;
  int d ;
  int tens ;
  int shift ;
  int width ;
  int width_specifier ;
  int left_align ;
  char c ;
  char *strptr ;
  char istr[5] ;
  char lead_char ;
  char sign_char ;
  char const   *__cil_tmp16 ;
  char const   *__cil_tmp17 ;
  char const   *__cil_tmp18 ;
  char const   *__cil_tmp19 ;
  char const   *__cil_tmp20 ;
  unsigned short const   **__cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  int __cil_tmp23 ;
  char *__cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  sf_count_t D ;
  sf_count_t Tens ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  int tmp ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  int tmp___0 ;
  char *__cil_tmp49 ;

  {
  {
#line 57
  __builtin_va_start((void *)ap, format);
  }
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    __cil_tmp16 = format;
#line 59
    format ++;
#line 59
    c = *__cil_tmp16;
#line 59
    if (! c) {
#line 59
      goto while_break;
    }
#line 60
    if ((int )c != 37) {
      {
#line 61
      log_putchar(psf, c);
      }
#line 62
      goto while_continue;
    }

#line 65
    if ((int )*(format + 0) == 37) {
      {
#line 66
      log_putchar(psf, (char )'%');
#line 67
      format ++;
      }
#line 68
      goto while_continue;
    }
#line 71
    sign_char = (char )0;
#line 72
    left_align = 0;
    {
#line 73
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 76
      if ((int )*(format + 0) == '+') {
#line 76
        goto case_43;
      }
#line 76
      if ((int )*(format + 0) == ' ') {
#line 76
        goto case_43;
      }
#line 81
      if ((int )*(format + 0) == '-') {
#line 81
        goto case_45;
      }
#line 86
      goto switch_default;
      case_43: /* CIL Label */ 
      case_32: /* CIL Label */ 
#line 77
      sign_char = *(format + 0);
#line 78
      format ++;
#line 79
      goto while_continue___0;
      case_45: /* CIL Label */ 
#line 82
      left_align = 1;
#line 83
      format ++;
#line 84
      goto while_continue___0;
      switch_default: /* CIL Label */ 
#line 86
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }

#line 89
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }

#line 92
    if ((int )*(format + 0) == 0) {
#line 93
      goto while_break;
    }
#line 95
    lead_char = (char )' ';
#line 96
    if ((int )*(format + 0) == 48) {
#line 97
      lead_char = (char )'0';
    }
#line 99
    width_specifier = 0;
    {
#line 100
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 100
      __cil_tmp21 = __ctype_b_loc();
      }
#line 100
      __cil_tmp20 = format;
#line 100
      format ++;
#line 100
      c = *__cil_tmp20;
#line 100
      if (! ((int )c && (int )*(*__cil_tmp21 + (int )c) & 2048)) {
#line 100
        goto while_break___1;
      }
#line 101
      width_specifier = width_specifier * 10 + ((int )c - 48);
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 104
    if ((int )c == 0) {
#line 104
      goto case_0;
    }
#line 108
    if ((int )c == 's') {
#line 108
      goto case_115;
    }
#line 122
    if ((int )c == 'd') {
#line 122
      goto case_100;
    }
#line 173
    if ((int )c == 'D') {
#line 173
      goto case_68;
    }
#line 208
    if ((int )c == 'u') {
#line 208
      goto case_117;
    }
#line 252
    if ((int )c == 'c') {
#line 252
      goto case_99;
    }
#line 258
    if ((int )c == 'X') {
#line 258
      goto case_88;
    }
#line 258
    if ((int )c == 'x') {
#line 258
      goto case_88;
    }
#line 286
    if ((int )c == 'M') {
#line 286
      goto case_77;
    }
#line 308
    goto switch_default___0;
    case_0: /* CIL Label */ 
    {
#line 105
    __builtin_va_end((void *)ap);
    }
#line 106
    return;
    case_115: /* CIL Label */ 
#line 109
    strptr = 0;
#line 110
    if (strptr == (void *)0) {
#line 111
      goto switch_break___0;
    }
    {
#line 112
    __cil_tmp22 = strlen((char const   *)strptr);
    }
#line 112
    width_specifier -= __cil_tmp22;
#line 113
    if (left_align == 0) {
      {
#line 114
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 114
        __cil_tmp23 = width_specifier;
#line 114
        width_specifier --;
#line 114
        if (! (__cil_tmp23 > 0)) {
#line 114
          goto while_break___2;
        }
        {
#line 115
        log_putchar(psf, (char )' ');
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    {
#line 116
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 116
      if (! *strptr) {
#line 116
        goto while_break___3;
      }
      {
#line 117
      __cil_tmp24 = strptr;
#line 117
      strptr ++;
#line 117
      log_putchar(psf, *__cil_tmp24);
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 118
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 118
      __cil_tmp25 = width_specifier;
#line 118
      width_specifier --;
#line 118
      if (! (__cil_tmp25 > 0)) {
#line 118
        goto while_break___4;
      }
      {
#line 119
      log_putchar(psf, (char )' ');
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 120
    goto switch_break___0;
    case_100: /* CIL Label */ 
#line 123
    d = 0;
#line 125
    if (d < 0) {
#line 126
      d = - d;
#line 127
      sign_char = (char )'-';
#line 128
      if ((int )lead_char != 48) {
#line 128
        if (left_align == 0) {
#line 129
          __cil_tmp26 = width_specifier;
#line 129
          width_specifier --;
        }
      }
    }
#line 132
    tens = 1;
#line 133
    width = 1;
    {
#line 134
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 134
      if (! (d / tens >= 10)) {
#line 134
        goto while_break___5;
      }
#line 135
      tens *= 10;
#line 136
      width ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 139
    width_specifier -= width;
#line 141
    if ((int )sign_char == 32) {
      {
#line 142
      log_putchar(psf, (char )' ');
#line 143
      __cil_tmp28 = width_specifier;
#line 143
      width_specifier --;
      }
    }

#line 146
    if (left_align == 0) {
#line 146
      if ((int )lead_char != 48) {
#line 147
        if ((int )sign_char == 43) {
#line 148
          __cil_tmp29 = width_specifier;
#line 148
          width_specifier --;
        }
        {
#line 150
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 150
          __cil_tmp30 = width_specifier;
#line 150
          width_specifier --;
#line 150
          if (! (__cil_tmp30 > 0)) {
#line 150
            goto while_break___6;
          }
          {
#line 151
          log_putchar(psf, lead_char);
          }
        }
        while_break___6: /* CIL Label */ ;
        }
      }
    }

#line 154
    if ((int )sign_char == 43) {
      {
      {
#line 155
      log_putchar(psf, sign_char);
      }
#line 156
      __cil_tmp31 = width_specifier;
#line 156
      width_specifier --;
      }
    } else
#line 154
    if ((int )sign_char == 45) {
      {
      {
#line 155
      log_putchar(psf, sign_char);
      }
#line 156
      __cil_tmp31 = width_specifier;
#line 156
      width_specifier --;
      }
    }

#line 159
    if (left_align == 0) {
      {
#line 160
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 160
        __cil_tmp32 = width_specifier;
#line 160
        width_specifier --;
#line 160
        if (! (__cil_tmp32 > 0)) {
#line 160
          goto while_break___7;
        }
        {
#line 161
        log_putchar(psf, lead_char);
        }
      }
      while_break___7: /* CIL Label */ ;
      }
    }
    {
#line 163
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 163
      if (! (tens > 0)) {
#line 163
        goto while_break___8;
      }
      {
#line 164
      log_putchar(psf, (char )(48 + d / tens));
#line 165
      d %= tens;
#line 166
      tens /= 10;
      }
    }
    while_break___8: /* CIL Label */ ;
    }

    {
#line 169
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 169
      __cil_tmp33 = width_specifier;
#line 169
      width_specifier --;
#line 169
      if (! (__cil_tmp33 > 0)) {
#line 169
        goto while_break___9;
      }
      {
#line 170
      log_putchar(psf, lead_char);
      }
    }
    while_break___9: /* CIL Label */ ;
    }
#line 171
    goto switch_break___0;
    case_68: /* CIL Label */ 
#line 176
    D = 0;
#line 178
    if (D == 0L) {
      {
#line 179
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 179
        width_specifier --;
#line 179
        if (! (width_specifier > 0)) {
#line 179
          goto while_break___10;
        }
        {
#line 180
        log_putchar(psf, lead_char);
        }
      }
      while_break___10: /* CIL Label */ ;
      }
      {
#line 181
      log_putchar(psf, (char )'0');
      }
#line 182
      goto switch_break___0;
    }
#line 184
    if (D < 0L) {
      {
#line 185
      log_putchar(psf, (char )'-');
#line 186
      D = - D;
      }
    }
#line 188
    Tens = (sf_count_t )1;
#line 189
    width = 1;
    {
#line 190
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 190
      if (! (D / Tens >= 10L)) {
#line 190
        goto while_break___11;
      }
#line 191
      Tens *= (long )10;
#line 192
      width ++;
    }
    while_break___11: /* CIL Label */ ;
    }

    {
#line 195
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 195
      if (! (width_specifier > width)) {
#line 195
        goto while_break___12;
      }
      {
#line 196
      log_putchar(psf, lead_char);
#line 197
      __cil_tmp37 = width_specifier;
#line 197
      width_specifier --;
      }
    }
    while_break___12: /* CIL Label */ ;
    }

    {
#line 200
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 200
      if (! (Tens > 0L)) {
#line 200
        goto while_break___13;
      }
      {
#line 201
      log_putchar(psf, (char )(48L + D / Tens));
#line 202
      D %= Tens;
#line 203
      Tens /= (long )10;
      }
    }
    while_break___13: /* CIL Label */ ;
    }

#line 206
    goto switch_break___0;
    case_117: /* CIL Label */ 
#line 209
    u = 0;
#line 211
    tens = 1;
#line 212
    width = 1;
    {
#line 213
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 213
      if (! (u / (unsigned int )tens >= 10U)) {
#line 213
        goto while_break___14;
      }
#line 214
      tens *= 10;
#line 215
      width ++;
    }
    while_break___14: /* CIL Label */ ;
    }
#line 218
    width_specifier -= width;
#line 220
    if ((int )sign_char == 32) {
      {
#line 221
      log_putchar(psf, (char )' ');
#line 222
      __cil_tmp39 = width_specifier;
#line 222
      width_specifier --;
      }
    }

#line 225
    if (left_align == 0) {
#line 225
      if ((int )lead_char != 48) {
#line 226
        if ((int )sign_char == 43) {
#line 227
          __cil_tmp40 = width_specifier;
#line 227
          width_specifier --;
        }
        {
#line 229
        while (1) {
          while_continue___15: /* CIL Label */ ;
#line 229
          __cil_tmp41 = width_specifier;
#line 229
          width_specifier --;
#line 229
          if (! (__cil_tmp41 > 0)) {
#line 229
            goto while_break___15;
          }
          {
#line 230
          log_putchar(psf, lead_char);
          }
        }
        while_break___15: /* CIL Label */ ;
        }
      }
    }

#line 233
    if ((int )sign_char == 43) {
      {
      {
#line 234
      log_putchar(psf, sign_char);
      }
#line 235
      __cil_tmp42 = width_specifier;
#line 235
      width_specifier --;
      }
    } else
#line 233
    if ((int )sign_char == 45) {
      {
      {
#line 234
      log_putchar(psf, sign_char);
      }
#line 235
      __cil_tmp42 = width_specifier;
#line 235
      width_specifier --;
      }
    }

#line 238
    if (left_align == 0) {
      {
#line 239
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 239
        __cil_tmp43 = width_specifier;
#line 239
        width_specifier --;
#line 239
        if (! (__cil_tmp43 > 0)) {
#line 239
          goto while_break___16;
        }
        {
#line 240
        log_putchar(psf, lead_char);
        }
      }
      while_break___16: /* CIL Label */ ;
      }
    }
    {
#line 242
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 242
      if (! (tens > 0)) {
#line 242
        goto while_break___17;
      }
      {
#line 243
      log_putchar(psf, (char )(48U + u / (unsigned int )tens));
#line 244
      u %= (unsigned int )tens;
#line 245
      tens /= 10;
      }
    }
    while_break___17: /* CIL Label */ ;
    }

    {
#line 248
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 248
      __cil_tmp44 = width_specifier;
#line 248
      width_specifier --;
#line 248
      if (! (__cil_tmp44 > 0)) {
#line 248
        goto while_break___18;
      }
      {
#line 249
      log_putchar(psf, lead_char);
      }
    }
    while_break___18: /* CIL Label */ ;
    }
#line 250
    goto switch_break___0;
    case_99: /* CIL Label */ 
#line 253
    c = (char )0;
    {
#line 254
    log_putchar(psf, c);
    }
#line 255
    goto switch_break___0;
    case_88: /* CIL Label */ 
    case_120: /* CIL Label */ 
#line 259
    d = 0;
#line 261
    if (d == 0) {
      {
#line 262
      while (1) {
        while_continue___19: /* CIL Label */ ;
#line 262
        width_specifier --;
#line 262
        if (! (width_specifier > 0)) {
#line 262
          goto while_break___19;
        }
        {
#line 263
        log_putchar(psf, lead_char);
        }
      }
      while_break___19: /* CIL Label */ ;
      }
      {
#line 264
      log_putchar(psf, (char )'0');
      }
#line 265
      goto switch_break___0;
    }
#line 267
    shift = 28;
#line 268
    if (width_specifier < 8) {
#line 268
      tmp = 8;
    } else {
#line 268
      tmp = width_specifier;
    }
#line 268
    width = tmp;
    {
#line 269
    while (1) {
      while_continue___20: /* CIL Label */ ;
#line 269
      if (! (! ((15 << shift) & d))) {
#line 269
        goto while_break___20;
      }
#line 270
      shift -= 4;
#line 271
      __cil_tmp46 = width;
#line 271
      width --;
    }
    while_break___20: /* CIL Label */ ;
    }

    {
#line 274
    while (1) {
      while_continue___21: /* CIL Label */ ;
#line 274
      if (! (width > 0 && width_specifier > width)) {
#line 274
        goto while_break___21;
      }
      {
#line 275
      log_putchar(psf, lead_char);
#line 276
      __cil_tmp47 = width_specifier;
#line 276
      width_specifier --;
      }
    }
    while_break___21: /* CIL Label */ ;
    }

    {
#line 279
    while (1) {
      while_continue___22: /* CIL Label */ ;
#line 279
      if (! (shift >= 0)) {
#line 279
        goto while_break___22;
      }
#line 280
      c = (char )((d >> shift) & 15);
#line 281
      if ((int )c > 9) {
#line 281
        tmp___0 = ((int )c + 65) - 10;
      } else {
#line 281
        tmp___0 = (int )c + 48;
      }
      {
#line 281
      log_putchar(psf, (char )tmp___0);
#line 282
      shift -= 4;
      }
    }
    while_break___22: /* CIL Label */ ;
    }

#line 284
    goto switch_break___0;
    case_77: /* CIL Label */ 
#line 287
    d = 0;
#line 288
    if (1) {
#line 289
      istr[0] = (char )(d & 255);
#line 290
      istr[1] = (char )((d >> 8) & 255);
#line 291
      istr[2] = (char )((d >> 16) & 255);
#line 292
      istr[3] = (char )((d >> 24) & 255);
    } else {
#line 295
      istr[3] = (char )(d & 255);
#line 296
      istr[2] = (char )((d >> 8) & 255);
#line 297
      istr[1] = (char )((d >> 16) & 255);
#line 298
      istr[0] = (char )((d >> 24) & 255);
    }
#line 300
    istr[4] = (char )0;
#line 301
    strptr = (char *)istr;
    {
#line 302
    while (1) {
      while_continue___23: /* CIL Label */ ;
#line 302
      if (! *strptr) {
#line 302
        goto while_break___23;
      }
      {
#line 303
      __cil_tmp49 = strptr;
#line 303
      strptr ++;
#line 303
      c = *__cil_tmp49;
#line 304
      log_putchar(psf, c);
      }
    }
    while_break___23: /* CIL Label */ ;
    }

#line 306
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 309
    log_putchar(psf, (char )'*');
    }
    {
#line 310
    log_putchar(psf, c);
#line 311
    log_putchar(psf, (char )'*');
    }
#line 312
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 316
  __builtin_va_end((void *)ap);
  }
#line 317
  return;
}
}
#line 329 "/root/libsndfile/src/common.c"
void psf_asciiheader_printf(SF_PRIVATE *psf , char const   *format  , ...) 
{ 
  va_list argptr ;
  int maxlen ;
  char *start ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;

  {
  {
#line 334
  __cil_tmp6 = strlen((char const   *)((char *)((unsigned char *)psf->header)));
#line 334
  maxlen = (int )__cil_tmp6;
#line 335
  start = (char *)((unsigned char *)psf->header) + maxlen;
#line 336
  maxlen = (int )(sizeof(psf->header) - (unsigned long )maxlen);
#line 338
  __builtin_va_start((void *)argptr, format);
#line 339
  vsnprintf(start, (unsigned long )maxlen, format, (void *)argptr);
#line 340
  __builtin_va_end((void *)argptr);
#line 343
  *(start + (maxlen - 1)) = (char )0;
#line 345
  __cil_tmp7 = strlen((char const   *)((char *)((unsigned char *)psf->header)));
#line 345
  psf->headindex = (int )__cil_tmp7;
  }
#line 347
  return;
}
}
#line 395 "/root/libsndfile/src/common.c"
__inline static void header_put_byte(SF_PRIVATE *psf , char x ) 
{ 
  int __cil_tmp3 ;

  {
#line 396
  if (psf->headindex < (int )sizeof(psf->header) - 1) {
#line 397
    __cil_tmp3 = psf->headindex;
#line 397
    (psf->headindex) ++;
#line 397
    psf->header[__cil_tmp3] = (unsigned char )x;
  }
  return;
}
}
#line 413 "/root/libsndfile/src/common.c"
__inline static void header_put_marker(SF_PRIVATE *psf , int x ) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 414
  if (psf->headindex < (int )sizeof(psf->header) - 4) {
#line 415
    __cil_tmp3 = psf->headindex;
#line 415
    (psf->headindex) ++;
#line 415
    psf->header[__cil_tmp3] = (unsigned char )x;
#line 416
    __cil_tmp4 = psf->headindex;
#line 416
    (psf->headindex) ++;
#line 416
    psf->header[__cil_tmp4] = (unsigned char )(x >> 8);
#line 417
    __cil_tmp5 = psf->headindex;
#line 417
    (psf->headindex) ++;
#line 417
    psf->header[__cil_tmp5] = (unsigned char )(x >> 16);
#line 418
    __cil_tmp6 = psf->headindex;
#line 418
    (psf->headindex) ++;
#line 418
    psf->header[__cil_tmp6] = (unsigned char )(x >> 24);
  }

  return;
}
}
#line 428 "/root/libsndfile/src/common.c"
__inline static void header_put_be_short(SF_PRIVATE *psf , int x ) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
#line 429
  if (psf->headindex < (int )sizeof(psf->header) - 2) {
#line 430
    __cil_tmp3 = psf->headindex;
#line 430
    (psf->headindex) ++;
#line 430
    psf->header[__cil_tmp3] = (unsigned char )(x >> 8);
#line 431
    __cil_tmp4 = psf->headindex;
#line 431
    (psf->headindex) ++;
#line 431
    psf->header[__cil_tmp4] = (unsigned char )x;
  }

  return;
}
}
#line 436 "/root/libsndfile/src/common.c"
__inline static void header_put_le_short(SF_PRIVATE *psf , int x ) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
#line 437
  if (psf->headindex < (int )sizeof(psf->header) - 2) {
#line 438
    __cil_tmp3 = psf->headindex;
#line 438
    (psf->headindex) ++;
#line 438
    psf->header[__cil_tmp3] = (unsigned char )x;
#line 439
    __cil_tmp4 = psf->headindex;
#line 439
    (psf->headindex) ++;
#line 439
    psf->header[__cil_tmp4] = (unsigned char )(x >> 8);
  }

  return;
}
}
#line 444 "/root/libsndfile/src/common.c"
__inline static void header_put_be_3byte(SF_PRIVATE *psf , int x ) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
#line 445
  if (psf->headindex < (int )sizeof(psf->header) - 3) {
#line 446
    __cil_tmp3 = psf->headindex;
#line 446
    (psf->headindex) ++;
#line 446
    psf->header[__cil_tmp3] = (unsigned char )(x >> 16);
#line 447
    __cil_tmp4 = psf->headindex;
#line 447
    (psf->headindex) ++;
#line 447
    psf->header[__cil_tmp4] = (unsigned char )(x >> 8);
#line 448
    __cil_tmp5 = psf->headindex;
#line 448
    (psf->headindex) ++;
#line 448
    psf->header[__cil_tmp5] = (unsigned char )x;
  }

  return;
}
}
#line 453 "/root/libsndfile/src/common.c"
__inline static void header_put_le_3byte(SF_PRIVATE *psf , int x ) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
#line 454
  if (psf->headindex < (int )sizeof(psf->header) - 3) {
#line 455
    __cil_tmp3 = psf->headindex;
#line 455
    (psf->headindex) ++;
#line 455
    psf->header[__cil_tmp3] = (unsigned char )x;
#line 456
    __cil_tmp4 = psf->headindex;
#line 456
    (psf->headindex) ++;
#line 456
    psf->header[__cil_tmp4] = (unsigned char )(x >> 8);
#line 457
    __cil_tmp5 = psf->headindex;
#line 457
    (psf->headindex) ++;
#line 457
    psf->header[__cil_tmp5] = (unsigned char )(x >> 16);
  }

  return;
}
}
#line 462 "/root/libsndfile/src/common.c"
__inline static void header_put_be_int(SF_PRIVATE *psf , int x ) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 463
  if (psf->headindex < (int )sizeof(psf->header) - 4) {
#line 464
    __cil_tmp3 = psf->headindex;
#line 464
    (psf->headindex) ++;
#line 464
    psf->header[__cil_tmp3] = (unsigned char )(x >> 24);
#line 465
    __cil_tmp4 = psf->headindex;
#line 465
    (psf->headindex) ++;
#line 465
    psf->header[__cil_tmp4] = (unsigned char )(x >> 16);
#line 466
    __cil_tmp5 = psf->headindex;
#line 466
    (psf->headindex) ++;
#line 466
    psf->header[__cil_tmp5] = (unsigned char )(x >> 8);
#line 467
    __cil_tmp6 = psf->headindex;
#line 467
    (psf->headindex) ++;
#line 467
    psf->header[__cil_tmp6] = (unsigned char )x;
  }

  return;
}
}
#line 514 "/root/libsndfile/src/common.c"
__inline static void header_put_be_8byte(SF_PRIVATE *psf , sf_count_t x ) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
#line 515
  if (psf->headindex < (int )sizeof(psf->header) - 8) {
#line 516
    __cil_tmp3 = psf->headindex;
#line 516
    (psf->headindex) ++;
#line 516
    psf->header[__cil_tmp3] = (unsigned char )(x >> 56);
#line 517
    __cil_tmp4 = psf->headindex;
#line 517
    (psf->headindex) ++;
#line 517
    psf->header[__cil_tmp4] = (unsigned char )(x >> 48);
#line 518
    __cil_tmp5 = psf->headindex;
#line 518
    (psf->headindex) ++;
#line 518
    psf->header[__cil_tmp5] = (unsigned char )(x >> 40);
#line 519
    __cil_tmp6 = psf->headindex;
#line 519
    (psf->headindex) ++;
#line 519
    psf->header[__cil_tmp6] = (unsigned char )(x >> 32);
#line 520
    __cil_tmp7 = psf->headindex;
#line 520
    (psf->headindex) ++;
#line 520
    psf->header[__cil_tmp7] = (unsigned char )(x >> 24);
#line 521
    __cil_tmp8 = psf->headindex;
#line 521
    (psf->headindex) ++;
#line 521
    psf->header[__cil_tmp8] = (unsigned char )(x >> 16);
#line 522
    __cil_tmp9 = psf->headindex;
#line 522
    (psf->headindex) ++;
#line 522
    psf->header[__cil_tmp9] = (unsigned char )(x >> 8);
#line 523
    __cil_tmp10 = psf->headindex;
#line 523
    (psf->headindex) ++;
#line 523
    psf->header[__cil_tmp10] = (unsigned char )x;
  }

  return;
}
}
#line 528 "/root/libsndfile/src/common.c"
__inline static void header_put_le_8byte(SF_PRIVATE *psf , sf_count_t x ) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
#line 529
  if (psf->headindex < (int )sizeof(psf->header) - 8) {
#line 530
    __cil_tmp3 = psf->headindex;
#line 530
    (psf->headindex) ++;
#line 530
    psf->header[__cil_tmp3] = (unsigned char )x;
#line 531
    __cil_tmp4 = psf->headindex;
#line 531
    (psf->headindex) ++;
#line 531
    psf->header[__cil_tmp4] = (unsigned char )(x >> 8);
#line 532
    __cil_tmp5 = psf->headindex;
#line 532
    (psf->headindex) ++;
#line 532
    psf->header[__cil_tmp5] = (unsigned char )(x >> 16);
#line 533
    __cil_tmp6 = psf->headindex;
#line 533
    (psf->headindex) ++;
#line 533
    psf->header[__cil_tmp6] = (unsigned char )(x >> 24);
#line 534
    __cil_tmp7 = psf->headindex;
#line 534
    (psf->headindex) ++;
#line 534
    psf->header[__cil_tmp7] = (unsigned char )(x >> 32);
#line 535
    __cil_tmp8 = psf->headindex;
#line 535
    (psf->headindex) ++;
#line 535
    psf->header[__cil_tmp8] = (unsigned char )(x >> 40);
#line 536
    __cil_tmp9 = psf->headindex;
#line 536
    (psf->headindex) ++;
#line 536
    psf->header[__cil_tmp9] = (unsigned char )(x >> 48);
#line 537
    __cil_tmp10 = psf->headindex;
#line 537
    (psf->headindex) ++;
#line 537
    psf->header[__cil_tmp10] = (unsigned char )(x >> 56);
  }

  return;
}
}
#line 546 "/root/libsndfile/src/common.c"
int psf_binheader_writef(SF_PRIVATE *psf , char const   *format  , ...) 
{ 
  va_list argptr ;
  sf_count_t countdata ;
  unsigned long longdata ;
  unsigned int data___0 ;
  float floatdata ;
  double doubledata ;
  void *bindata ;
  size_t size ;
  char c ;
  char *strptr ;
  int count ;
  int trunc_8to4 ;
  char const   *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  int __cil_tmp18 ;
  size_t __cil_tmp19 ;

  {
  {
#line 556
  count = 0;
#line 558
  trunc_8to4 = 0;
#line 560
  __builtin_va_start((void *)argptr, format);
  }
  {
#line 562
  while (1) {
    while_continue: /* CIL Label */ ;
#line 562
    __cil_tmp15 = format;
#line 562
    format ++;
#line 562
    c = *__cil_tmp15;
#line 562
    if (! c) {
#line 562
      goto while_break;
    }
    {
#line 564
    if ((int )c == ' ') {
#line 564
      goto case_32;
    }
#line 567
    if ((int )c == 'e') {
#line 567
      goto case_101;
    }
#line 571
    if ((int )c == 'E') {
#line 571
      goto case_69;
    }
#line 575
    if ((int )c == 't') {
#line 575
      goto case_116;
    }
#line 579
    if ((int )c == 'T') {
#line 579
      goto case_84;
    }
#line 583
    if ((int )c == 'm') {
#line 583
      goto case_109;
    }
#line 589
    if ((int )c == '1') {
#line 589
      goto case_49;
    }
#line 595
    if ((int )c == '2') {
#line 595
      goto case_50;
    }
#line 606
    if ((int )c == '3') {
#line 606
      goto case_51;
    }
#line 617
    if ((int )c == '4') {
#line 617
      goto case_52;
    }
#line 628
    if ((int )c == '8') {
#line 628
      goto case_56;
    }
#line 650
    if ((int )c == 'f') {
#line 650
      goto case_102;
    }
#line 661
    if ((int )c == 'd') {
#line 661
      goto case_100;
    }
#line 671
    if ((int )c == 's') {
#line 671
      goto case_115;
    }
#line 686
    if ((int )c == 'S') {
#line 686
      goto case_83;
    }
#line 704
    if ((int )c == 'b') {
#line 704
      goto case_98;
    }
#line 712
    if ((int )c == 'z') {
#line 712
      goto case_122;
    }
#line 722
    if ((int )c == 'h') {
#line 722
      goto case_104;
    }
#line 729
    if ((int )c == 'j') {
#line 729
      goto case_106;
    }
#line 735
    goto switch_default;
    case_32: /* CIL Label */ 
#line 565
    goto switch_break;
    case_101: /* CIL Label */ 
#line 568
    psf->rwf_endian = 268435456;
#line 569
    goto switch_break;
    case_69: /* CIL Label */ 
#line 572
    psf->rwf_endian = 536870912;
#line 573
    goto switch_break;
    case_116: /* CIL Label */ 
#line 576
    trunc_8to4 = 1;
#line 577
    goto switch_break;
    case_84: /* CIL Label */ 
#line 580
    trunc_8to4 = 0;
#line 581
    goto switch_break;
    case_109: /* CIL Label */ 
#line 584
    data___0 = 0;
    {
#line 585
    header_put_marker(psf, (int )data___0);
#line 586
    count += 4;
    }
#line 587
    goto switch_break;
    case_49: /* CIL Label */ 
#line 590
    data___0 = 0;
    {
#line 591
    header_put_byte(psf, (char )data___0);
#line 592
    count ++;
    }
#line 593
    goto switch_break;
    case_50: /* CIL Label */ 
#line 596
    data___0 = 0;
#line 597
    if (psf->rwf_endian == 536870912) {
      {
#line 598
      header_put_be_short(psf, (int )data___0);
      }
    } else {
      {
#line 601
      header_put_le_short(psf, (int )data___0);
      }
    }
#line 603
    count += 2;
#line 604
    goto switch_break;
    case_51: /* CIL Label */ 
#line 607
    data___0 = 0;
#line 608
    if (psf->rwf_endian == 536870912) {
      {
#line 609
      header_put_be_3byte(psf, (int )data___0);
      }
    } else {
      {
#line 612
      header_put_le_3byte(psf, (int )data___0);
      }
    }
#line 614
    count += 3;
#line 615
    goto switch_break;
    case_52: /* CIL Label */ 
#line 618
    data___0 = 0;
#line 619
    if (psf->rwf_endian == 536870912) {
      {
#line 620
      header_put_be_int(psf, (int )data___0);
      }
    } else {
      {
#line 623
      header_put_marker(psf, (int )data___0);
      }
    }
#line 625
    count += 4;
#line 626
    goto switch_break;
    case_56: /* CIL Label */ 
#line 629
    countdata = 0;
#line 630
    if (psf->rwf_endian == 536870912) {
#line 630
      if (trunc_8to4 == 0) {
        {
#line 631
        header_put_be_8byte(psf, countdata);
#line 632
        count += 8;
        }
      } else {
#line 630
        goto _L___7;
      }
    } else
    _L___7: /* CIL Label */ 
#line 634
    if (psf->rwf_endian == 268435456) {
#line 634
      if (trunc_8to4 == 0) {
        {
#line 635
        header_put_le_8byte(psf, countdata);
#line 636
        count += 8;
        }
      } else {
#line 634
        goto _L___6;
      }
    } else
    _L___6: /* CIL Label */ 
#line 638
    if (psf->rwf_endian == 536870912) {
#line 638
      if (trunc_8to4 == 1) {
        {
#line 639
        longdata = (unsigned long )(countdata & 4294967295L);
#line 640
        header_put_be_int(psf, (int )longdata);
#line 641
        count += 4;
        }
      } else {
#line 638
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 643
    if (psf->rwf_endian == 268435456) {
#line 643
      if (trunc_8to4 == 1) {
        {
#line 644
        longdata = (unsigned long )(countdata & 4294967295L);
#line 645
        header_put_marker(psf, (int )longdata);
#line 646
        count += 4;
        }
      }
    }
#line 648
    goto switch_break;
    case_102: /* CIL Label */ 
#line 652
    floatdata = (float )0;
#line 653
    if (psf->rwf_endian == 536870912) {
      {
#line 654
      float32_be_write(floatdata, (unsigned char *)psf->header + psf->headindex);
      }
    } else {
      {
#line 656
      float32_le_write(floatdata, (unsigned char *)psf->header + psf->headindex);
      }
    }
#line 657
    psf->headindex += 4;
#line 658
    count += 4;
#line 659
    goto switch_break;
    case_100: /* CIL Label */ 
#line 662
    doubledata = 0;
#line 663
    if (psf->rwf_endian == 536870912) {
      {
#line 664
      double64_be_write(doubledata, (unsigned char *)psf->header + psf->headindex);
      }
    } else {
      {
#line 666
      double64_le_write(doubledata, (unsigned char *)psf->header + psf->headindex);
      }
    }
#line 667
    psf->headindex += 8;
#line 668
    count += 8;
#line 669
    goto switch_break;
    case_115: /* CIL Label */ 
#line 673
    strptr = 0;
    {
#line 674
    __cil_tmp16 = strlen((char const   *)strptr);
#line 674
    size = __cil_tmp16 + 1UL;
#line 675
    size += size & 1UL;
    }
#line 676
    if (psf->rwf_endian == 536870912) {
      {
#line 677
      header_put_be_int(psf, (int )size);
      }
    } else {
      {
#line 679
      header_put_marker(psf, (int )size);
      }
    }
    {
#line 680
    memcpy(& psf->header[psf->headindex], strptr, size);
#line 681
    psf->headindex += size;
#line 682
    psf->header[psf->headindex - 1] = (unsigned char )0;
#line 683
    count += 4UL + size;
    }
#line 684
    goto switch_break;
    case_83: /* CIL Label */ 
#line 691
    strptr = 0;
    {
#line 692
    size = strlen((char const   *)strptr);
    }
#line 693
    if (psf->rwf_endian == 536870912) {
      {
#line 694
      header_put_be_int(psf, (int )size);
      }
    } else {
      {
#line 696
      header_put_marker(psf, (int )size);
      }
    }
    {
#line 697
    memcpy(& psf->header[psf->headindex], strptr, size + 1UL);
#line 698
    size += size & 1UL;
#line 699
    psf->headindex += size;
#line 700
    psf->header[psf->headindex] = (unsigned char )0;
#line 701
    count += 4UL + size;
    }
#line 702
    goto switch_break;
    case_98: /* CIL Label */ 
#line 705
    bindata = 0;
    {
#line 706
    size = 0;
#line 707
    memcpy(& psf->header[psf->headindex], bindata, size);
#line 708
    psf->headindex += size;
#line 709
    count += size;
    }
#line 710
    goto switch_break;
    case_122: /* CIL Label */ 
#line 713
    size = 0;
#line 714
    count += size;
    {
#line 715
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 715
      if (! size) {
#line 715
        goto while_break___0;
      }
#line 716
      psf->header[psf->headindex] = (unsigned char )0;
#line 717
      (psf->headindex) ++;
#line 718
      __cil_tmp19 = size;
#line 718
      size --;
    }
    while_break___0: /* CIL Label */ ;
    }

#line 720
    goto switch_break;
    case_104: /* CIL Label */ 
#line 723
    bindata = 0;
    {
#line 724
    memcpy(& psf->header[psf->headindex], bindata, (unsigned long )16);
#line 725
    psf->headindex += 16;
#line 726
    count += 16;
    }
#line 727
    goto switch_break;
    case_106: /* CIL Label */ 
#line 730
    size = 0;
#line 731
    psf->headindex += size;
#line 732
    count = (int )size;
#line 733
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 736
    psf_log_printf(psf, "*** Invalid format specifier `%c\'\n", (int )c);
    }
#line 737
    psf->error = 29;
#line 738
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }

  }
  while_break: /* CIL Label */ ;
  }
  {
#line 742
  __builtin_va_end((void *)argptr);
  }
#line 743
  return (count);
}
}
#line 794 "/root/libsndfile/src/common.c"
static int header_read(SF_PRIVATE *psf , void *ptr , int bytes ) 
{ 
  int count ;
  int most ;
  sf_count_t __cil_tmp6 ;

  {
#line 795
  count = 0;
#line 797
  if (psf->headindex >= (int )sizeof(psf->header)) {
    {
#line 798
    memset(ptr, 0, (unsigned long )((int )sizeof(psf->header) - psf->headindex));
#line 801
    psf_fseek(psf, (sf_count_t )bytes, 1);
    }
#line 802
    return (bytes);
  }

#line 805
  if (psf->headindex + bytes > (int )sizeof(psf->header)) {
    {
#line 808
    most = (int )sizeof(psf->header) - psf->headindex;
#line 809
    psf_fread((unsigned char *)psf->header + psf->headend, (sf_count_t )1, (sf_count_t )most,
              psf);
#line 810
    memset((char *)ptr + most, 0, (unsigned long )(bytes - most));
#line 812
    psf_fseek(psf, (sf_count_t )(bytes - most), 1);
    }
#line 813
    return (bytes);
  }

#line 816
  if (psf->headindex + bytes > psf->headend) {
    {
#line 817
    __cil_tmp6 = psf_fread((unsigned char *)psf->header + psf->headend, (sf_count_t )1,
                           (sf_count_t )(bytes - (psf->headend - psf->headindex)),
                           psf);
#line 817
    count = (int )__cil_tmp6;
    }
#line 818
    if (count != bytes - (int )(psf->headend - psf->headindex)) {
      {
#line 819
      psf_log_printf(psf, "Error : psf_fread returned short count.\n\220");
      }
#line 820
      return (0);
    }
#line 822
    psf->headend += count;
  }
  {
#line 825
  memcpy(ptr, (unsigned char *)psf->header + psf->headindex, (unsigned long )bytes);
#line 826
  psf->headindex += bytes;
  }
#line 828
  return (bytes);
}
}
#line 832 "/root/libsndfile/src/common.c"
static void header_seek(SF_PRIVATE *psf , sf_count_t position , int whence ) 
{ 
  sf_count_t __cil_tmp4 ;
  sf_count_t __cil_tmp5 ;

  {
  {
#line 836
  if (whence == 0) {
#line 836
    goto case_0;
  }
#line 847
  if (whence == 1) {
#line 847
    goto case_1;
  }
#line 873
  goto switch_default;
  case_0: /* CIL Label */ 
#line 837
  if (position > (long )((int )sizeof(psf->header))) {
    {
#line 839
    psf_fseek(psf, position, whence);
    }
#line 840
    return;
  }

#line 842
  if (position > (long )psf->headend) {
    {
#line 843
    __cil_tmp4 = psf_fread((unsigned char *)psf->header + psf->headend, (sf_count_t )1,
                           position - (long )psf->headend, psf);
    }
#line 843
    psf->headend += __cil_tmp4;
  }
#line 844
  psf->headindex = (int )position;
#line 845
  goto switch_break;
  case_1: /* CIL Label */ 
#line 848
  if ((long )psf->headindex + position < 0L) {
#line 849
    goto switch_break;
  }
#line 851
  if (psf->headindex >= (int )sizeof(psf->header)) {
    {
#line 852
    psf_fseek(psf, position, whence);
    }
#line 853
    return;
  }

#line 856
  if ((long )psf->headindex + position <= (long )psf->headend) {
#line 857
    psf->headindex += position;
#line 858
    goto switch_break;
  }

#line 861
  if ((long )psf->headindex + position > (long )((int )sizeof(psf->header))) {
    {
#line 863
    psf->headindex = psf->headend;
#line 864
    psf_fseek(psf, position, 1);
    }
#line 865
    goto switch_break;
  }
  {
#line 868
  __cil_tmp5 = psf_fread((unsigned char *)psf->header + psf->headend, (sf_count_t )1,
                         position - (long )(psf->headend - psf->headindex), psf);
  }
#line 868
  psf->headend += __cil_tmp5;
#line 869
  psf->headindex = psf->headend;
#line 870
  goto switch_break;
  switch_default: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 874
  psf_log_printf(psf, "Bad whence param in header_seek().\n");
  }
#line 875
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }

#line 878
  return;
}
}
#line 882 "/root/libsndfile/src/common.c"
static int header_gets(SF_PRIVATE *psf , char *ptr , int bufsize ) 
{ 
  int k ;
  int __cil_tmp5 ;
  sf_count_t __cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 886
  k = 0;
  {
#line 886
  while (1) {
    while_continue: /* CIL Label */ ;
#line 886
    if (! (k < bufsize - 1)) {
#line 886
      goto while_break;
    }
#line 887
    if (psf->headindex < psf->headend) {
#line 888
      *(ptr + k) = (char )psf->header[psf->headindex];
#line 889
      (psf->headindex) ++;
    } else {
      {
#line 892
      __cil_tmp6 = psf_fread((unsigned char *)psf->header + psf->headend, (sf_count_t )1,
                             (sf_count_t )1, psf);
      }
#line 892
      psf->headend += __cil_tmp6;
#line 893
      *(ptr + k) = (char )psf->header[psf->headindex];
#line 894
      psf->headindex = psf->headend;
    }

#line 897
    if ((int )*(ptr + k) == 10) {
#line 898
      goto while_break;
    }
#line 886
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 901
  *(ptr + k) = (char )0;
#line 903
  return (k);
}
}
#line 907 "/root/libsndfile/src/common.c"
int psf_binheader_readf(SF_PRIVATE *psf , char const   *format  , ...) 
{ 
  va_list argptr ;
  sf_count_t *countptr ;
  sf_count_t countdata ;
  unsigned char *ucptr ;
  unsigned char sixteen_bytes[16] ;
  unsigned int *intptr ;
  unsigned int intdata ;
  unsigned short *shortptr ;
  char *charptr ;
  float *floatptr ;
  double *doubleptr ;
  char c ;
  int byte_count ;
  int count ;
  sf_count_t __cil_tmp17 ;
  char const   *__cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int k ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  float __cil_tmp29 ;
  float __cil_tmp30 ;
  int __cil_tmp31 ;
  double __cil_tmp32 ;
  double __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;

  {
#line 917
  byte_count = 0;
#line 919
  if (! format) {
    {
#line 920
    __cil_tmp17 = psf_ftell(psf);
    }
#line 920
    return ((int )__cil_tmp17);
  }
  {
#line 922
  __builtin_va_start((void *)argptr, format);
  }
  {
#line 924
  while (1) {
    while_continue: /* CIL Label */ ;
#line 924
    __cil_tmp18 = format;
#line 924
    format ++;
#line 924
    c = *__cil_tmp18;
#line 924
    if (! c) {
#line 924
      goto while_break;
    }
    {
#line 926
    if ((int )c == 'e') {
#line 926
      goto case_101;
    }
#line 930
    if ((int )c == 'E') {
#line 930
      goto case_69;
    }
#line 934
    if ((int )c == 'm') {
#line 934
      goto case_109;
    }
#line 941
    if ((int )c == 'h') {
#line 941
      goto case_104;
    }
#line 953
    if ((int )c == '1') {
#line 953
      goto case_49;
    }
#line 959
    if ((int )c == '2') {
#line 959
      goto case_50;
    }
#line 970
    if ((int )c == '3') {
#line 970
      goto case_51;
    }
#line 980
    if ((int )c == '4') {
#line 980
      goto case_52;
    }
#line 991
    if ((int )c == '8') {
#line 991
      goto case_56;
    }
#line 1002
    if ((int )c == 'f') {
#line 1002
      goto case_102;
    }
#line 1012
    if ((int )c == 'd') {
#line 1012
      goto case_100;
    }
#line 1022
    if ((int )c == 's') {
#line 1022
      goto case_115;
    }
#line 1035
    if ((int )c == 'b') {
#line 1035
      goto case_98;
    }
#line 1042
    if ((int )c == 'G') {
#line 1042
      goto case_71;
    }
#line 1049
    if ((int )c == 'z') {
#line 1049
      goto case_122;
    }
#line 1061
    if ((int )c == 'p') {
#line 1061
      goto case_112;
    }
#line 1068
    if ((int )c == 'j') {
#line 1068
      goto case_106;
    }
#line 1075
    goto switch_default;
    case_101: /* CIL Label */ 
#line 927
    psf->rwf_endian = 268435456;
#line 928
    goto switch_break;
    case_69: /* CIL Label */ 
#line 931
    psf->rwf_endian = 536870912;
#line 932
    goto switch_break;
    case_109: /* CIL Label */ 
#line 935
    intptr = 0;
    {
#line 936
    ucptr = (unsigned char *)intptr;
#line 937
    __cil_tmp19 = header_read(psf, ucptr, (int )sizeof(int ));
    }
#line 937
    byte_count += __cil_tmp19;
#line 938
    *intptr = (unsigned int )((((int )*(ucptr + 0) | ((int )*(ucptr + 1) << 8)) | ((int )*(ucptr + 2) << 16)) | ((int )*(ucptr + 3) << 24));
#line 939
    goto switch_break;
    case_104: /* CIL Label */ 
#line 942
    intptr = 0;
    {
#line 943
    ucptr = (unsigned char *)intptr;
#line 944
    __cil_tmp20 = header_read(psf, (unsigned char *)sixteen_bytes, (int )sizeof(sixteen_bytes));
    }
#line 944
    byte_count += __cil_tmp20;
#line 946
    intdata = (unsigned int )0;
#line 947
    k = 0;
    {
#line 947
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 947
      if (! (k < 16)) {
#line 947
        goto while_break___0;
      }
#line 948
      intdata ^= (unsigned int )((int )sixteen_bytes[k] << k);
#line 947
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 950
    *intptr = intdata;
#line 951
    goto switch_break;
    case_49: /* CIL Label */ 
#line 954
    charptr = 0;
    {
#line 955
    *charptr = (char )0;
#line 956
    __cil_tmp23 = header_read(psf, charptr, (int )sizeof(char ));
    }
#line 956
    byte_count += __cil_tmp23;
#line 957
    goto switch_break;
    case_50: /* CIL Label */ 
#line 960
    shortptr = 0;
    {
#line 961
    *shortptr = (unsigned short )0;
#line 962
    ucptr = (unsigned char *)shortptr;
#line 963
    __cil_tmp24 = header_read(psf, ucptr, (int )sizeof(short ));
    }
#line 963
    byte_count += __cil_tmp24;
#line 964
    if (psf->rwf_endian == 536870912) {
#line 965
      *shortptr = (unsigned short )(((int )*(ucptr + 0) << 8) | (int )*(ucptr + 1));
    } else {
#line 967
      *shortptr = (unsigned short )(((int )*(ucptr + 1) << 8) | (int )*(ucptr + 0));
    }
#line 968
    goto switch_break;
    case_51: /* CIL Label */ 
#line 971
    intptr = 0;
    {
#line 972
    *intptr = (unsigned int )0;
#line 973
    __cil_tmp25 = header_read(psf, (unsigned char *)sixteen_bytes, 3);
    }
#line 973
    byte_count += __cil_tmp25;
#line 974
    if (psf->rwf_endian == 536870912) {
#line 975
      *intptr = (unsigned int )((((int )sixteen_bytes[0] << 16) | ((int )sixteen_bytes[1] << 8)) | (int )sixteen_bytes[2]);
    } else {
#line 977
      *intptr = (unsigned int )((((int )sixteen_bytes[2] << 16) | ((int )sixteen_bytes[1] << 8)) | (int )sixteen_bytes[0]);
    }
#line 978
    goto switch_break;
    case_52: /* CIL Label */ 
#line 981
    intptr = 0;
    {
#line 982
    *intptr = (unsigned int )0;
#line 983
    ucptr = (unsigned char *)intptr;
#line 984
    __cil_tmp26 = header_read(psf, ucptr, (int )sizeof(int ));
    }
#line 984
    byte_count += __cil_tmp26;
#line 985
    if (psf->rwf_endian == 536870912) {
#line 986
      *intptr = (unsigned int )(((((int )*(ucptr + 0) << 24) | ((int )*(ucptr + 1) << 16)) | ((int )*(ucptr + 2) << 8)) | (int )*(ucptr + 3));
    } else {
#line 988
      *intptr = (unsigned int )(((((int )*(ucptr + 3) << 24) | ((int )*(ucptr + 2) << 16)) | ((int )*(ucptr + 1) << 8)) | (int )*(ucptr + 0));
    }
#line 989
    goto switch_break;
    case_56: /* CIL Label */ 
#line 992
    countptr = 0;
    {
#line 993
    *countptr = (sf_count_t )0;
#line 994
    __cil_tmp27 = header_read(psf, (unsigned char *)sixteen_bytes, 8);
    }
#line 994
    byte_count += __cil_tmp27;
#line 995
    if (psf->rwf_endian == 536870912) {
#line 996
      countdata = ((((((((sf_count_t )sixteen_bytes[0] << 56) | ((sf_count_t )sixteen_bytes[1] << 48)) | ((sf_count_t )sixteen_bytes[2] << 40)) | ((sf_count_t )sixteen_bytes[3] << 32)) | ((sf_count_t )sixteen_bytes[4] << 24)) | ((sf_count_t )sixteen_bytes[5] << 16)) | ((sf_count_t )sixteen_bytes[6] << 8)) | (long )sixteen_bytes[7];
    } else {
#line 998
      countdata = ((((((((sf_count_t )sixteen_bytes[7] << 56) | ((sf_count_t )sixteen_bytes[6] << 48)) | ((sf_count_t )sixteen_bytes[5] << 40)) | ((sf_count_t )sixteen_bytes[4] << 32)) | ((sf_count_t )sixteen_bytes[3] << 24)) | ((sf_count_t )sixteen_bytes[2] << 16)) | ((sf_count_t )sixteen_bytes[1] << 8)) | (long )sixteen_bytes[0];
    }
#line 999
    *countptr = countdata;
#line 1000
    goto switch_break;
    case_102: /* CIL Label */ 
#line 1003
    floatptr = 0;
    {
#line 1004
    *floatptr = (float )0.;
#line 1005
    __cil_tmp28 = header_read(psf, floatptr, (int )sizeof(float ));
    }
#line 1005
    byte_count += __cil_tmp28;
#line 1006
    if (psf->rwf_endian == 536870912) {
      {
#line 1007
      *floatptr = float32_be_read((unsigned char *)floatptr);
      }
    } else {
      {
#line 1009
      *floatptr = float32_le_read((unsigned char *)floatptr);
      }
    }
#line 1010
    goto switch_break;
    case_100: /* CIL Label */ 
#line 1013
    doubleptr = 0;
    {
#line 1014
    *doubleptr = 0.;
#line 1015
    __cil_tmp31 = header_read(psf, doubleptr, (int )sizeof(double ));
    }
#line 1015
    byte_count += __cil_tmp31;
#line 1016
    if (psf->rwf_endian == 536870912) {
      {
#line 1017
      *doubleptr = double64_be_read((unsigned char *)doubleptr);
      }
    } else {
      {
#line 1019
      *doubleptr = double64_le_read((unsigned char *)doubleptr);
      }
    }
#line 1020
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 1023
    psf_log_printf(psf, "Format conversion \'s\' not implemented yet.\n");
    }
#line 1033
    goto switch_break;
    case_98: /* CIL Label */ 
#line 1036
    charptr = 0;
#line 1037
    count = 0;
#line 1038
    if (count > 0) {
      {
#line 1039
      __cil_tmp34 = header_read(psf, charptr, count);
      }
#line 1039
      byte_count += __cil_tmp34;
    }
#line 1040
    goto switch_break;
    case_71: /* CIL Label */ 
#line 1043
    charptr = 0;
#line 1044
    count = 0;
#line 1045
    if (count > 0) {
      {
#line 1046
      __cil_tmp35 = header_gets(psf, charptr, count);
      }
#line 1046
      byte_count += __cil_tmp35;
    }
#line 1047
    goto switch_break;
    case_122: /* CIL Label */ 
    {
#line 1050
    psf_log_printf(psf, "Format conversion \'z\' not implemented yet.\n");
    }
#line 1059
    goto switch_break;
    case_112: /* CIL Label */ 
#line 1063
    count = 0;
    {
#line 1064
    header_seek(psf, (sf_count_t )count, 0);
#line 1065
    byte_count = count;
    }
#line 1066
    goto switch_break;
    case_106: /* CIL Label */ 
#line 1070
    count = 0;
    {
#line 1071
    header_seek(psf, (sf_count_t )count, 1);
#line 1072
    byte_count += count;
    }
#line 1073
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1076
    psf_log_printf(psf, "*** Invalid format specifier `%c\'\n", (int )c);
    }
#line 1077
    psf->error = 29;
#line 1078
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }

  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1082
  __builtin_va_end((void *)argptr);
  }
#line 1084
  return (byte_count);
}
}
#line 1091 "/root/libsndfile/src/common.c"
sf_count_t psf_default_seek(SF_PRIVATE *psf , int UNUSED_mode , sf_count_t samples_from_start ) 
{ 
  sf_count_t position ;
  sf_count_t retval ;
  sf_count_t __cil_tmp6 ;

  {
#line 1094
  if (! (psf->blockwidth && psf->dataoffset >= 0L)) {
#line 1095
    psf->error = 38;
#line 1096
    return ((sf_count_t )(- 1));
  }

#line 1099
  if (! psf->sf.seekable) {
#line 1100
    psf->error = 39;
#line 1101
    return ((sf_count_t )(- 1));
  }
  {
#line 1104
  position = psf->dataoffset + (long )psf->blockwidth * samples_from_start;
#line 1106
  retval = psf_fseek(psf, position, 0);
  }
#line 1106
  if (retval != position) {
#line 1107
    psf->error = 42;
#line 1108
    return ((sf_count_t )(- 1));
  }

#line 1111
  return (samples_from_start);
}
}
#line 1118 "/root/libsndfile/src/common.c"
void psf_hexdump(void const   *ptr , int len ) 
{ 
  char const   *data___0 ;
  char ascii[17] ;
  int k ;
  int m ;
  char const   *tmp ;
  unsigned short const   **__cil_tmp8 ;
  int tmp___0 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
#line 1123
  data___0 = ptr;
#line 1123
  if (data___0 == (void *)0) {
#line 1124
    return;
  }
#line 1125
  if (len <= 0) {
#line 1126
    return;
  }
  {
#line 1128
  puts("0\220\005\372\036V");
#line 1129
  k = 0;
  }
  {
#line 1129
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1129
    if (! (k < len)) {
#line 1129
      goto while_break;
    }
    {
#line 1130
    memset((char *)ascii, ' ', sizeof(ascii));
#line 1132
    printf("%08X: ", k);
#line 1133
    m = 0;
    }
    {
#line 1133
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1133
      if (! (m < 16 && k + m < len)) {
#line 1133
        goto while_break___0;
      }
#line 1134
      if (m == 8) {
#line 1134
        tmp = " %02X ";
      } else {
#line 1134
        tmp = "%02X V";
      }
      {
#line 1134
      printf(tmp, (int )*(data___0 + (k + m)) & 255);
#line 1135
      __cil_tmp8 = __ctype_b_loc();
      }
#line 1135
      if ((int )*(*__cil_tmp8 + (int )*(data___0 + (k + m))) & 16384) {
#line 1135
        tmp___0 = (int )*(data___0 + (k + m));
      } else {
#line 1135
        tmp___0 = '.';
      }
#line 1135
      ascii[m] = (char )tmp___0;
#line 1133
      m ++;
    }
    while_break___0: /* CIL Label */ ;
    }

#line 1138
    if (m <= 8) {
      {
#line 1138
      printf(" 3$\372\036V");
      }
    }
    {
#line 1139
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1139
      if (! (m < 16)) {
#line 1139
        goto while_break___1;
      }
      {
#line 1139
      printf("   ");
      }
#line 1139
      m ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1141
    ascii[16] = (char )0;
#line 1142
    printf(" %s\n", (char *)ascii);
    }
#line 1129
    k += 16;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1145
  puts("\220");
  }
  return;
}
}
#line 1149 "/root/libsndfile/src/common.c"
void psf_log_SF_INFO(SF_PRIVATE *psf ) 
{ 
  char const   *tmp ;

  {
  {
#line 1150
  psf_log_printf(psf, "---------------------------------\n$\372\036V");
#line 1152
  psf_log_printf(psf, " Sample rate :   %d\n\036V", psf->sf.samplerate);
#line 1153
  psf_log_printf(psf, " Frames      :   %D\n", psf->sf.frames);
#line 1154
  psf_log_printf(psf, " Channels    :   %d\n", psf->sf.channels);
#line 1156
  psf_log_printf(psf, " Format      :   0x%X\n", psf->sf.format);
#line 1157
  psf_log_printf(psf, " Sections    :   %d\n", psf->sf.sections);
  }
#line 1158
  if (psf->sf.seekable) {
#line 1158
    tmp = "TRUE";
  } else {
#line 1158
    tmp = "FALSE";
  }
  {
#line 1158
  psf_log_printf(psf, " Seekable    :   %s\n\036V", tmp);
#line 1160
  psf_log_printf(psf, "---------------------------------\n");
  }
  return;
}
}
#line 1167 "/root/libsndfile/src/common.c"
void *psf_memset(void *s , int c , sf_count_t len ) 
{ 
  char *ptr ;
  int setcount ;
  int tmp ;

  {
#line 1171
  ptr = (char *)s;
  {
#line 1173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1173
    if (! (len > 0L)) {
#line 1173
      goto while_break;
    }
#line 1174
    if (len > 268435456L) {
#line 1174
      tmp = 268435456;
    } else {
#line 1174
      tmp = (int )len;
    }
    {
#line 1174
    setcount = tmp;
#line 1176
    memset(ptr, c, (unsigned long )setcount);
#line 1178
    ptr += setcount;
#line 1179
    len -= (long )setcount;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 1182
  return (s);
}
}
#line 1186 "/root/libsndfile/src/common.c"
SF_INSTRUMENT *psf_instrument_alloc(void) 
{ 
  SF_INSTRUMENT *instr ;
  void *__cil_tmp2 ;

  {
  {
#line 1189
  instr = (SF_INSTRUMENT *)calloc((unsigned long )1, sizeof(SF_INSTRUMENT ));
  }
#line 1191
  if (instr == (void *)0) {
#line 1192
    return ((SF_INSTRUMENT *)((void *)0));
  }
#line 1195
  instr->basenote = (char )(- 1);
#line 1196
  instr->velocity_lo = (char )(- 1);
#line 1197
  instr->velocity_hi = (char )(- 1);
#line 1198
  instr->key_lo = (char )(- 1);
#line 1199
  instr->key_hi = (char )(- 1);
#line 1201
  return (instr);
}
}
#line 1205 "/root/libsndfile/src/common.c"
void psf_sanitize_string(char *cptr , int len ) 
{ 
  int __cil_tmp3 ;
  unsigned short const   **__cil_tmp4 ;
  int tmp ;

  {
  {
#line 1207
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1209
    __cil_tmp3 = len;
#line 1209
    len --;
#line 1210
    __cil_tmp4 = __ctype_b_loc();
    }
#line 1210
    if ((int )*(*__cil_tmp4 + (int )*(cptr + len)) & 16384) {
#line 1210
      tmp = (int )*(cptr + len);
    } else {
#line 1210
      tmp = '.';
    }
#line 1210
    *(cptr + len) = (char )tmp;
#line 1207
    if (! (len > 0)) {
#line 1207
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1216 "/root/libsndfile/src/common.c"
void psf_get_date_str(char *str , int maxlen ) 
{ 
  time_t current ;
  struct tm timedata ;
  struct tm *tmptr ;
  struct tm *__cil_tmp6 ;

  {
  {
#line 1220
  time(& current);
#line 1224
  tmptr = gmtime_r(& current, & timedata);
  }
#line 1233
  if (tmptr) {
    {
#line 1234
    snprintf(str, (unsigned long )maxlen, "%4d-%02d-%02d %02d:%02d:%02d UTC\251",
             1900 + timedata.tm_year, timedata.tm_mon, timedata.tm_mday, timedata.tm_hour,
             timedata.tm_min, timedata.tm_sec);
    }
  } else {
    {
#line 1238
    snprintf(str, (unsigned long )maxlen, "Unknown date\036V");
    }
  }
#line 1240
  return;
}
}
#line 1244 "/root/libsndfile/src/common.c"
int subformat_to_bytewidth(int format ) 
{ 


  {
  {
#line 1248
  if (format == 1) {
#line 1248
    goto case_1;
  }
#line 1248
  if (format == 5) {
#line 1248
    goto case_1;
  }
#line 1250
  if (format == 2) {
#line 1250
    goto case_2;
  }
#line 1252
  if (format == 3) {
#line 1252
    goto case_3;
  }
#line 1255
  if (format == 6) {
#line 1255
    goto case_6;
  }
#line 1255
  if (format == 4) {
#line 1255
    goto case_6;
  }
#line 1257
  if (format == 7) {
#line 1257
    goto case_7;
  }
#line 1246
  goto switch_break;
  case_1: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 1249
  return (1);
  case_2: /* CIL Label */ 
#line 1251
  return (2);
  case_3: /* CIL Label */ 
#line 1253
  return (3);
  case_6: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 1256
  return (4);
  case_7: /* CIL Label */ 
#line 1258
  return (8);
  switch_break: /* CIL Label */ ;
  }

#line 1261
  return (0);
}
}
#line 1265 "/root/libsndfile/src/common.c"
int s_bitwidth_to_subformat(int bits ) 
{ 
  static int array[4] ;

  {
#line 1266
  array[0] = 1;
#line 1266
  array[1] = 2;
#line 1266
  array[2] = 3;
#line 1266
  array[3] = 4;
#line 1270
  if (bits < 8) {
#line 1271
    return (0);
  } else
#line 1270
  if (bits > 32) {
#line 1271
    return (0);
  }
#line 1273
  return (array[(bits + 7) / 8 - 1]);
}
}
#line 1277 "/root/libsndfile/src/common.c"
int u_bitwidth_to_subformat(int bits ) 
{ 
  static int array[4] ;

  {
#line 1278
  array[0] = 5;
#line 1278
  array[1] = 2;
#line 1278
  array[2] = 3;
#line 1278
  array[3] = 4;
#line 1282
  if (bits < 8) {
#line 1283
    return (0);
  } else
#line 1282
  if (bits > 32) {
#line 1283
    return (0);
  }
#line 1285
  return (array[(bits + 7) / 8 - 1]);
}
}
#line 1295 "/root/libsndfile/src/common.c"
int32_t psf_rand_int32(void) 
{ 
  static int32_t value ;
  int k ;
  int count ;
  struct timeval tv ;
  int __cil_tmp5 ;

  {
#line 1296
  value = - 1;
#line 1299
  if (value == -1) {
    {
#line 1303
    gettimeofday(& tv, (void *)0);
#line 1304
    value = (int32_t )(tv.tv_sec + tv.tv_usec);
    }
  }
#line 1310
  count = 4 + (value & 7);
#line 1311
  k = 0;
  {
#line 1311
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1311
    if (! (k < count)) {
#line 1311
      goto while_break;
    }
#line 1312
    value = 11117 * value + 211231;
#line 1311
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1314
  return (value);
}
}
#line 1323 "/root/libsndfile/src/common.c"
char const   *str_of_major_format(int format ) 
{ 


  {
  {
#line 1325
  if ((format & 268369920) == 65536) {
#line 1325
    goto case_65536;
  }
#line 1326
  if ((format & 268369920) == 131072) {
#line 1326
    goto case_131072;
  }
#line 1327
  if ((format & 268369920) == 196608) {
#line 1327
    goto case_196608;
  }
#line 1328
  if ((format & 268369920) == 262144) {
#line 1328
    goto case_262144;
  }
#line 1329
  if ((format & 268369920) == 327680) {
#line 1329
    goto case_327680;
  }
#line 1330
  if ((format & 268369920) == 393216) {
#line 1330
    goto case_393216;
  }
#line 1331
  if ((format & 268369920) == 458752) {
#line 1331
    goto case_458752;
  }
#line 1332
  if ((format & 268369920) == 524288) {
#line 1332
    goto case_524288;
  }
#line 1333
  if ((format & 268369920) == 655360) {
#line 1333
    goto case_655360;
  }
#line 1334
  if ((format & 268369920) == 720896) {
#line 1334
    goto case_720896;
  }
#line 1335
  if ((format & 268369920) == 786432) {
#line 1335
    goto case_786432;
  }
#line 1336
  if ((format & 268369920) == 851968) {
#line 1336
    goto case_851968;
  }
#line 1337
  if ((format & 268369920) == 917504) {
#line 1337
    goto case_917504;
  }
#line 1338
  if ((format & 268369920) == 983040) {
#line 1338
    goto case_983040;
  }
#line 1339
  if ((format & 268369920) == 1048576) {
#line 1339
    goto case_1048576;
  }
#line 1340
  if ((format & 268369920) == 1114112) {
#line 1340
    goto case_1114112;
  }
#line 1341
  if ((format & 268369920) == 1179648) {
#line 1341
    goto case_1179648;
  }
#line 1342
  if ((format & 268369920) == 1245184) {
#line 1342
    goto case_1245184;
  }
#line 1343
  if ((format & 268369920) == 1441792) {
#line 1343
    goto case_1441792;
  }
#line 1344
  if ((format & 268369920) == 1507328) {
#line 1344
    goto case_1507328;
  }
#line 1345
  if ((format & 268369920) == 1572864) {
#line 1345
    goto case_1572864;
  }
#line 1346
  if ((format & 268369920) == 1638400) {
#line 1346
    goto case_1638400;
  }
#line 1347
  if ((format & 268369920) == 2097152) {
#line 1347
    goto case_2097152;
  }
#line 1348
  goto switch_default;
  case_65536: /* CIL Label */ 
#line 1325
  return ("SF_FORMAT_WAV");
#line 1325
  goto switch_break;

  case_131072: /* CIL Label */ 
#line 1326
  return ("SF_FORMAT_AIFF");
#line 1326
  goto switch_break;

  case_196608: /* CIL Label */ 
#line 1327
  return ("SF_FORMAT_AU\036V");
#line 1327
  goto switch_break;

  case_262144: /* CIL Label */ 
#line 1328
  return ("SF_FORMAT_RAWV");
#line 1328
  goto switch_break;

  case_327680: /* CIL Label */ 
#line 1329
  return ("SF_FORMAT_PAF");
#line 1329
  goto switch_break;

  case_393216: /* CIL Label */ 
#line 1330
  return ("SF_FORMAT_SVXV");
#line 1330
  goto switch_break;

  case_458752: /* CIL Label */ 
#line 1331
  return ("SF_FORMAT_NIST");
#line 1331
  goto switch_break;

  case_524288: /* CIL Label */ 
#line 1332
  return ("SF_FORMAT_VOCV");
#line 1332
  goto switch_break;

  case_655360: /* CIL Label */ 
#line 1333
  return ("SF_FORMAT_IRCAM");
#line 1333
  goto switch_break;

  case_720896: /* CIL Label */ 
#line 1334
  return ("SF_FORMAT_W64");
#line 1334
  goto switch_break;

  case_786432: /* CIL Label */ 
#line 1335
  return ("SF_FORMAT_MAT4");
#line 1335
  goto switch_break;

  case_851968: /* CIL Label */ 
#line 1336
  return ("SF_FORMAT_MAT5");
#line 1336
  goto switch_break;

  case_917504: /* CIL Label */ 
#line 1337
  return ("SF_FORMAT_PVF");
#line 1337
  goto switch_break;

  case_983040: /* CIL Label */ 
#line 1338
  return ("SF_FORMAT_XI");
#line 1338
  goto switch_break;

  case_1048576: /* CIL Label */ 
#line 1339
  return ("SF_FORMAT_HTKV");
#line 1339
  goto switch_break;

  case_1114112: /* CIL Label */ 
#line 1340
  return ("SF_FORMAT_SDS");
#line 1340
  goto switch_break;

  case_1179648: /* CIL Label */ 
#line 1341
  return ("SF_FORMAT_AVR");
#line 1341
  goto switch_break;

  case_1245184: /* CIL Label */ 
#line 1342
  return ("SF_FORMAT_WAVEX");
#line 1342
  goto switch_break;

  case_1441792: /* CIL Label */ 
#line 1343
  return ("SF_FORMAT_SD2");
#line 1343
  goto switch_break;

  case_1507328: /* CIL Label */ 
#line 1344
  return ("SF_FORMAT_FLAC");
#line 1344
  goto switch_break;

  case_1572864: /* CIL Label */ 
#line 1345
  return ("SF_FORMAT_CAFV");
#line 1345
  goto switch_break;

  case_1638400: /* CIL Label */ 
#line 1346
  return ("SF_FORMAT_WVE");
#line 1346
  goto switch_break;

  case_2097152: /* CIL Label */ 
#line 1347
  return ("SF_FORMAT_OGG");
#line 1347
  goto switch_break;

  switch_default: /* CIL Label */ 
#line 1349
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }

#line 1352
  return ("BAD_MAJOR_FORMAT\220");
}
}
#line 1356 "/root/libsndfile/src/common.c"
char const   *str_of_minor_format(int format ) 
{ 


  {
  {
#line 1358
  if ((format & 65535) == 1) {
#line 1358
    goto case_1;
  }
#line 1359
  if ((format & 65535) == 2) {
#line 1359
    goto case_2;
  }
#line 1360
  if ((format & 65535) == 3) {
#line 1360
    goto case_3;
  }
#line 1361
  if ((format & 65535) == 4) {
#line 1361
    goto case_4;
  }
#line 1362
  if ((format & 65535) == 5) {
#line 1362
    goto case_5;
  }
#line 1363
  if ((format & 65535) == 6) {
#line 1363
    goto case_6;
  }
#line 1364
  if ((format & 65535) == 7) {
#line 1364
    goto case_7;
  }
#line 1365
  if ((format & 65535) == 16) {
#line 1365
    goto case_16;
  }
#line 1366
  if ((format & 65535) == 17) {
#line 1366
    goto case_17;
  }
#line 1367
  if ((format & 65535) == 18) {
#line 1367
    goto case_18;
  }
#line 1368
  if ((format & 65535) == 19) {
#line 1368
    goto case_19;
  }
#line 1369
  if ((format & 65535) == 32) {
#line 1369
    goto case_32;
  }
#line 1370
  if ((format & 65535) == 33) {
#line 1370
    goto case_33;
  }
#line 1371
  if ((format & 65535) == 48) {
#line 1371
    goto case_48;
  }
#line 1372
  if ((format & 65535) == 49) {
#line 1372
    goto case_49;
  }
#line 1373
  if ((format & 65535) == 50) {
#line 1373
    goto case_50;
  }
#line 1374
  if ((format & 65535) == 64) {
#line 1374
    goto case_64;
  }
#line 1375
  if ((format & 65535) == 65) {
#line 1375
    goto case_65;
  }
#line 1376
  if ((format & 65535) == 66) {
#line 1376
    goto case_66;
  }
#line 1377
  if ((format & 65535) == 67) {
#line 1377
    goto case_67;
  }
#line 1378
  if ((format & 65535) == 80) {
#line 1378
    goto case_80;
  }
#line 1379
  if ((format & 65535) == 81) {
#line 1379
    goto case_81;
  }
#line 1380
  if ((format & 65535) == 96) {
#line 1380
    goto case_96;
  }
#line 1381
  goto switch_default;
  case_1: /* CIL Label */ 
#line 1358
  return ("SF_FORMAT_PCM_S8");
#line 1358
  goto switch_break;

  case_2: /* CIL Label */ 
#line 1359
  return ("SF_FORMAT_PCM_16\220");
#line 1359
  goto switch_break;

  case_3: /* CIL Label */ 
#line 1360
  return ("SF_FORMAT_PCM_24\220");
#line 1360
  goto switch_break;

  case_4: /* CIL Label */ 
#line 1361
  return ("SF_FORMAT_PCM_32\220");
#line 1361
  goto switch_break;

  case_5: /* CIL Label */ 
#line 1362
  return ("SF_FORMAT_PCM_U8\220");
#line 1362
  goto switch_break;

  case_6: /* CIL Label */ 
#line 1363
  return ("SF_FORMAT_FLOAT");
#line 1363
  goto switch_break;

  case_7: /* CIL Label */ 
#line 1364
  return ("SF_FORMAT_DOUBLE\220");
#line 1364
  goto switch_break;

  case_16: /* CIL Label */ 
#line 1365
  return ("SF_FORMAT_ULAW");
#line 1365
  goto switch_break;

  case_17: /* CIL Label */ 
#line 1366
  return ("SF_FORMAT_ALAW");
#line 1366
  goto switch_break;

  case_18: /* CIL Label */ 
#line 1367
  return ("SF_FORMAT_IMA_ADPCM\372\036V");
#line 1367
  goto switch_break;

  case_19: /* CIL Label */ 
#line 1368
  return ("SF_FORMAT_MS_ADPCM$\372\036V");
#line 1368
  goto switch_break;

  case_32: /* CIL Label */ 
#line 1369
  return ("SF_FORMAT_GSM610\220");
#line 1369
  goto switch_break;

  case_33: /* CIL Label */ 
#line 1370
  return ("SF_FORMAT_VOX_ADPCM");
#line 1370
  goto switch_break;

  case_48: /* CIL Label */ 
#line 1371
  return ("SF_FORMAT_G721_32\327$\372\036V");
#line 1371
  goto switch_break;

  case_49: /* CIL Label */ 
#line 1372
  return ("SF_FORMAT_G723_24");
#line 1372
  goto switch_break;

  case_50: /* CIL Label */ 
#line 1373
  return ("SF_FORMAT_G723_40");
#line 1373
  goto switch_break;

  case_64: /* CIL Label */ 
#line 1374
  return ("SF_FORMAT_DWVW_12");
#line 1374
  goto switch_break;

  case_65: /* CIL Label */ 
#line 1375
  return ("SF_FORMAT_DWVW_16");
#line 1375
  goto switch_break;

  case_66: /* CIL Label */ 
#line 1376
  return ("SF_FORMAT_DWVW_24\336$\372\036V");
#line 1376
  goto switch_break;

  case_67: /* CIL Label */ 
#line 1377
  return ("SF_FORMAT_DWVW_N\220");
#line 1377
  goto switch_break;

  case_80: /* CIL Label */ 
#line 1378
  return ("SF_FORMAT_DPCM_8\220");
#line 1378
  goto switch_break;

  case_81: /* CIL Label */ 
#line 1379
  return ("SF_FORMAT_DPCM_16");
#line 1379
  goto switch_break;

  case_96: /* CIL Label */ 
#line 1380
  return ("SF_FORMAT_VORBIS\220");
#line 1380
  goto switch_break;

  switch_default: /* CIL Label */ 
#line 1382
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }

#line 1385
  return ("BAD_MINOR_FORMAT\220");
}
}
#line 1389 "/root/libsndfile/src/common.c"
char const   *str_of_open_mode(int mode ) 
{ 


  {
  {
#line 1391
  if (mode == 16) {
#line 1391
    goto case_16;
  }
#line 1392
  if (mode == 32) {
#line 1392
    goto case_32;
  }
#line 1393
  if (mode == 48) {
#line 1393
    goto case_48;
  }
#line 1395
  goto switch_default;
  case_16: /* CIL Label */ 
#line 1391
  return ("SFM_READ\220");
#line 1391
  goto switch_break;

  case_32: /* CIL Label */ 
#line 1392
  return ("SFM_WRITE");
#line 1392
  goto switch_break;

  case_48: /* CIL Label */ 
#line 1393
  return ("SFM_RDWR\220");
#line 1393
  goto switch_break;

  switch_default: /* CIL Label */ 
#line 1396
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }

#line 1399
  return ("BAD_MODE\220");
}
}
#line 1403 "/root/libsndfile/src/common.c"
char const   *str_of_endianness(int end ) 
{ 


  {
  {
#line 1405
  if (end == 536870912) {
#line 1405
    goto case_536870912;
  }
#line 1406
  if (end == 268435456) {
#line 1406
    goto case_268435456;
  }
#line 1407
  if (end == 805306368) {
#line 1407
    goto case_805306368;
  }
#line 1408
  goto switch_default;
  case_536870912: /* CIL Label */ 
#line 1405
  return ("SF_ENDIAN_BIGV");
#line 1405
  goto switch_break;

  case_268435456: /* CIL Label */ 
#line 1406
  return ("SF_ENDIAN_LITTLE\220");
#line 1406
  goto switch_break;

  case_805306368: /* CIL Label */ 
#line 1407
  return ("SF_ENDIAN_CPU");
#line 1407
  goto switch_break;

  switch_default: /* CIL Label */ 
#line 1409
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }

#line 1413
  return ("\220");
}
}
#line 28 "/root/libsndfile/src/command.c"
static SF_FORMAT_INFO simple_formats[14]  = 
#line 28 "/root/libsndfile/src/command.c"
  {      {131074, "AIFF (Apple/SGI 16 bit PCM)", "aiff"}, 
        {131078, "AIFF (Apple/SGI 32 bit float)", "aifc"}, 
        {131073, "AIFF (Apple/SGI 8 bit PCM)", "aiff"}, 
        {196610, "AU (Sun/Next 16 bit PCM)", "au"}, 
        {196624, "AU (Sun/Next 8-bit u-law)", "au"}, 
        {1572866, "CAF (Apple 16 bit PCM)", "caf"}, 
        {1507330, "FLAC 16 bit", "flac"}, 
        {262177, "OKI Dialogic VOX ADPCM", "vox"}, 
        {2097248, "Ogg Vorbis (Xiph Foundation)", "oga"}, 
        {65538, "WAV (Microsoft 16 bit PCM)", "wav"}, 
        {65542, "WAV (Microsoft 32 bit float)", "wav"}, 
        {65554, "WAV (Microsoft 4 bit IMA ADPCM)", "wav"}, 
        {65555, "WAV (Microsoft 4 bit MS ADPCM)", "wav"}, 
        {65541, "WAV (Microsoft 8 bit PCM)", "wav"}};
#line 93 "/root/libsndfile/src/command.c"
int psf_get_format_simple_count(void) 
{ 


  {
#line 94
  return ((int )(sizeof(simple_formats) / sizeof(SF_FORMAT_INFO )));
}
}
#line 98 "/root/libsndfile/src/command.c"
int psf_get_format_simple(SF_FORMAT_INFO *data___0 ) 
{ 
  int indx ;

  {
#line 101
  if (data___0->format < 0) {
#line 102
    return (30);
  } else
#line 101
  if (data___0->format >= (int )sizeof(simple_formats) / (int )sizeof(SF_FORMAT_INFO )) {
#line 102
    return (30);
  }
  {
#line 104
  indx = data___0->format;
#line 105
  memcpy(data___0, & simple_formats[indx], (unsigned long )((int )sizeof(SF_FORMAT_INFO )));
  }
#line 107
  return (0);
}
}
#line 114 "/root/libsndfile/src/command.c"
static SF_FORMAT_INFO major_formats[23]  = 
#line 114
  {      {131072, "AIFF (Apple/SGI)\323\001 ", "aiff"}, 
        {196608, "AU (Sun/NeXT)", "au"}, 
        {1179648, "AVR (Audio Visual Research)", "avr"}, 
        {1572864, "CAF (Apple Core Audio File)", "caf"}, 
        {1507328, "FLAC (FLAC Lossless Audio Codec)\323\001 ", "flac\036V"}, 
        {1048576, "HTK (HMM Tool Kit)?\372\036V", "htk"}, 
        {393216, "IFF (Amiga IFF/SVX8/SV16)", "iff"}, 
        {786432, "MAT4 (GNU Octave 2.0 / Matlab 4.2)", "mat"}, 
        {851968, "MAT5 (GNU Octave 2.1 / Matlab 5.0)?\372\036V", "mat\372\036V"}, 
        {2097152, "OGG (OGG Container format)?\372\036V", "oga\372\036V"}, 
        {327680, "PAF (Ensoniq PARIS)", "paf\372\036V"}, 
        {917504, "PVF (Portable Voice Format)\372\036V", "pvf"}, 
        {262144, "RAW (header-less)U?\372\036V", "raw\372\036V"}, 
        {1441792, "SD2 (Sound Designer II)", "sd2\372\036V"}, 
        {1114112, "SDS (Midi Sample Dump Standard)", "sds"}, 
        {655360, "SF (Berkeley/IRCAM/CARL)\323\001 ", "sf?\372\036V"}, 
        {524288, "VOC (Creative Labs)", "voc"}, 
        {720896, "W64 (SoundFoundry WAVE 64)", "w64"}, 
        {65536, "WAV (Microsoft)", "wav"}, 
        {458752, "WAV (NIST Sphere)", "wav"}, 
        {1245184, "WAVEX (Microsoft)", "wav"}, 
        {1638400, "WVE (Psion Series 3)", "wve"}, 
        {983040, "XI (FastTracker 2)", "xi"}};
#line 147 "/root/libsndfile/src/command.c"
int psf_get_format_major_count(void) 
{ 


  {
#line 148
  return ((int )(sizeof(major_formats) / sizeof(SF_FORMAT_INFO )));
}
}
#line 152 "/root/libsndfile/src/command.c"
int psf_get_format_major(SF_FORMAT_INFO *data___0 ) 
{ 
  int indx ;

  {
#line 155
  if (data___0->format < 0) {
#line 156
    return (30);
  } else
#line 155
  if (data___0->format >= (int )sizeof(major_formats) / (int )sizeof(SF_FORMAT_INFO )) {
#line 156
    return (30);
  }
  {
#line 158
  indx = data___0->format;
#line 159
  memcpy(data___0, & major_formats[indx], (unsigned long )((int )sizeof(SF_FORMAT_INFO )));
  }
#line 161
  return (0);
}
}
#line 168 "/root/libsndfile/src/command.c"
static SF_FORMAT_INFO subtype_formats[21]  = 
#line 168
  {      {1, "Signed 8 bit PCM\251", (char const   *)((void *)0)}, 
        {2, "Signed 16 bit PCM", (char const   *)((void *)0)}, 
        {3, "Signed 24 bit PCM\264\006<\377\177", (char const   *)((void *)0)}, 
        {4, "Signed 32 bit PCM", (char const   *)((void *)0)}, 
        {5, "Unsigned 8 bit PCM", (char const   *)((void *)0)}, 
        {6, "32 bit float", (char const   *)((void *)0)}, 
        {7, "64 bit float", (char const   *)((void *)0)}, 
        {16, "U-LawV", (char const   *)((void *)0)}, 
        {17, "A-Law", (char const   *)((void *)0)}, 
        {18, "IMA ADPCM", (char const   *)((void *)0)}, 
        {19, "Microsoft ADPCM", (char const   *)((void *)0)}, 
        {32, "GSM 6.10\251", (char const   *)((void *)0)}, 
        {48, "32kbs G721 ADPCM\251", (char const   *)((void *)0)}, 
        {49, "24kbs G723 ADPCM\251", (char const   *)((void *)0)}, 
        {64, "12 bit DWVW", (char const   *)((void *)0)}, 
        {65, "16 bit DWVW", (char const   *)((void *)0)}, 
        {66, "24 bit DWVW", (char const   *)((void *)0)}, 
        {33, "VOX ADPCM", "vox"}, 
        {81, "16 bit DPCM\372\036V", (char const   *)((void *)0)}, 
        {80, "8 bit DPCM?\372\036V", (char const   *)((void *)0)}, 
        {96, "Vorbis", (char const   *)((void *)0)}};
#line 204 "/root/libsndfile/src/command.c"
int psf_get_format_subtype_count(void) 
{ 


  {
#line 205
  return ((int )(sizeof(subtype_formats) / sizeof(SF_FORMAT_INFO )));
}
}
#line 209 "/root/libsndfile/src/command.c"
int psf_get_format_subtype(SF_FORMAT_INFO *data___0 ) 
{ 
  int indx ;

  {
#line 212
  if (data___0->format < 0) {
#line 213
    return (30);
  } else
#line 212
  if (data___0->format >= (int )sizeof(subtype_formats) / (int )sizeof(SF_FORMAT_INFO )) {
#line 213
    return (30);
  }
  {
#line 215
  indx = data___0->format;
#line 216
  memcpy(data___0, & subtype_formats[indx], sizeof(SF_FORMAT_INFO ));
  }
#line 218
  return (0);
}
}
#line 225 "/root/libsndfile/src/command.c"
int psf_get_format_info(SF_FORMAT_INFO *data___0 ) 
{ 
  int k ;
  int format ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
#line 228
  if (data___0->format & 268369920) {
#line 229
    format = data___0->format & 268369920;
#line 231
    k = 0;
    {
#line 231
    while (1) {
      while_continue: /* CIL Label */ ;
#line 231
      if (! (k < (int )sizeof(major_formats) / (int )sizeof(SF_FORMAT_INFO ))) {
#line 231
        goto while_break;
      }
#line 232
      if (format == major_formats[k].format) {
        {
#line 233
        memcpy(data___0, & major_formats[k], sizeof(SF_FORMAT_INFO ));
        }
#line 234
        return (0);
      }

#line 231
      k ++;
    }
    while_break: /* CIL Label */ ;
    }

  } else
#line 238
  if (data___0->format & 65535) {
#line 239
    format = data___0->format & 65535;
#line 241
    k = 0;
    {
#line 241
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 241
      if (! (k < (int )sizeof(subtype_formats) / (int )sizeof(SF_FORMAT_INFO ))) {
#line 241
        goto while_break___0;
      }
#line 242
      if (format == subtype_formats[k].format) {
        {
#line 243
        memcpy(data___0, & subtype_formats[k], sizeof(SF_FORMAT_INFO ));
        }
#line 244
        return (0);
      }

#line 241
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }

  }
  {
#line 249
  memset(data___0, 0, sizeof(SF_FORMAT_INFO ));
  }
#line 251
  return (30);
}
}
#line 258 "/root/libsndfile/src/command.c"
double psf_calc_signal_max(SF_PRIVATE *psf , int normalize ) 
{ 
  sf_count_t position ;
  double max_val ;
  double temp ;
  double *data___0 ;
  int k ;
  int len ;
  int readcount ;
  int save_state ;
  int __cil_tmp11 ;
  sf_count_t __cil_tmp12 ;
  sf_count_t __cil_tmp13 ;
  double __cil_tmp14 ;
  double tmp ;
  int __cil_tmp16 ;

  {
#line 264
  if (! psf->sf.seekable) {
#line 265
    psf->error = 39;
#line 266
    return (0.);
  }

#line 269
  if (! psf->read_double) {
#line 270
    psf->error = 17;
#line 271
    return (0.);
  }
  {
#line 274
  save_state = sf_command((SNDFILE *)psf, 4112, (void *)0, 0);
#line 275
  sf_command((SNDFILE *)psf, 4114, (void *)0, normalize);
#line 279
  position = sf_seek((SNDFILE *)psf, (sf_count_t )0, 1);
#line 281
  sf_seek((SNDFILE *)psf, (sf_count_t )0, 0);
#line 283
  data___0 = (double *)psf->u.dbuf;
#line 284
  len = (int )(sizeof(psf->u.dbuf) / sizeof(psf->u.dbuf[0]));
#line 286
  max_val = 0.;
  }
#line 286
  readcount = 1;
  {
#line 286
  while (1) {
    while_continue: /* CIL Label */ ;
#line 286
    if (! (readcount > 0)) {
#line 286
      goto while_break;
    }
    {
#line 287
    __cil_tmp13 = sf_read_double((SNDFILE *)psf, data___0, (sf_count_t )len);
#line 287
    readcount = (int )__cil_tmp13;
#line 288
    k = 0;
    }
    {
#line 288
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 288
      if (! (k < readcount)) {
#line 288
        goto while_break___0;
      }
      {
#line 289
      temp = fabs(*(data___0 + k));
      }
#line 290
      if (temp > max_val) {
#line 290
        tmp = temp;
      } else {
#line 290
        tmp = max_val;
      }
#line 290
      max_val = tmp;
#line 288
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }

  }
  while_break: /* CIL Label */ ;
  }
  {
#line 295
  sf_seek((SNDFILE *)psf, position, 0);
#line 296
  sf_command((SNDFILE *)psf, 4114, (void *)0, save_state);
  }
#line 298
  return (max_val);
}
}
#line 302 "/root/libsndfile/src/command.c"
int psf_calc_max_all_channels(SF_PRIVATE *psf , double *peaks , int normalize ) 
{ 
  sf_count_t position ;
  double temp ;
  double *data___0 ;
  int k ;
  int len ;
  int readcount ;
  int save_state ;
  int chan ;
  int __cil_tmp12 ;
  sf_count_t __cil_tmp13 ;
  sf_count_t __cil_tmp14 ;
  double __cil_tmp15 ;
  double tmp ;
  int __cil_tmp17 ;

  {
#line 309
  if (! psf->sf.seekable) {
#line 310
    psf->error = 39;
#line 310
    return (psf->error);
  }
#line 312
  if (! psf->read_double) {
#line 313
    psf->error = 17;
#line 313
    return (psf->error);
  }
  {
#line 315
  save_state = sf_command((SNDFILE *)psf, 4112, (void *)0, 0);
#line 316
  sf_command((SNDFILE *)psf, 4114, (void *)0, normalize);
#line 318
  memset(peaks, 0, sizeof(double ) * (unsigned long )psf->sf.channels);
#line 321
  position = sf_seek((SNDFILE *)psf, (sf_count_t )0, 1);
#line 322
  sf_seek((SNDFILE *)psf, (sf_count_t )0, 0);
#line 324
  len = (int )(sizeof(psf->u.dbuf) / sizeof(psf->u.dbuf[0]));
#line 326
  data___0 = (double *)psf->u.dbuf;
#line 328
  chan = 0;
#line 329
  readcount = len;
  }
  {
#line 330
  while (1) {
    while_continue: /* CIL Label */ ;
#line 330
    if (! (readcount > 0)) {
#line 330
      goto while_break;
    }
    {
#line 331
    __cil_tmp14 = sf_read_double((SNDFILE *)psf, data___0, (sf_count_t )len);
#line 331
    readcount = (int )__cil_tmp14;
#line 332
    k = 0;
    }
    {
#line 332
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 332
      if (! (k < readcount)) {
#line 332
        goto while_break___0;
      }
      {
#line 333
      temp = fabs(*(data___0 + k));
      }
#line 334
      if (temp > *(peaks + chan)) {
#line 334
        tmp = temp;
      } else {
#line 334
        tmp = *(peaks + chan);
      }
#line 334
      *(peaks + chan) = tmp;
#line 335
      chan = (chan + 1) % psf->sf.channels;
#line 332
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }

  }
  while_break: /* CIL Label */ ;
  }
  {
#line 339
  sf_seek((SNDFILE *)psf, position, 0);
#line 341
  sf_command((SNDFILE *)psf, 4114, (void *)0, save_state);
  }
#line 343
  return (0);
}
}
#line 347 "/root/libsndfile/src/command.c"
int psf_get_signal_max(SF_PRIVATE *psf , double *peak ) 
{ 
  int k ;
  int __cil_tmp4 ;

  {
#line 350
  if (psf->peak_info == (void *)0) {
#line 351
    return (0);
  }
#line 353
  *(peak + 0) = (psf->peak_info)->peaks[0].value;
#line 355
  k = 1;
  {
#line 355
  while (1) {
    while_continue: /* CIL Label */ ;
#line 355
    if (! (k < psf->sf.channels)) {
#line 355
      goto while_break;
    }
#line 356
    *(peak + 0) = 0;
#line 355
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 358
  return (1);
}
}
#line 362 "/root/libsndfile/src/command.c"
int psf_get_max_all_channels(SF_PRIVATE *psf , double *peaks ) 
{ 
  int k ;
  int __cil_tmp4 ;

  {
#line 365
  if (psf->peak_info == (void *)0) {
#line 366
    return (0);
  }
#line 368
  k = 0;
  {
#line 368
  while (1) {
    while_continue: /* CIL Label */ ;
#line 368
    if (! (k < psf->sf.channels)) {
#line 368
      goto while_break;
    }
#line 369
    *(peaks + k) = (psf->peak_info)->peaks[k].value;
#line 368
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 371
  return (1);
}
}
#line 30 "/root/libsndfile/src/chunk.c"
void pchk4_store(PRIV_CHUNK4 *pchk , int marker , sf_count_t offset , sf_count_t len ) 
{ 
  int __cil_tmp5 ;

  {
#line 32
  if (pchk->count >= (int )(sizeof(pchk->l) / sizeof(pchk->l[0]))) {
#line 33
    return;
  }
#line 35
  pchk->l[pchk->count].chunk = marker;
#line 36
  pchk->l[pchk->count].offset = offset;
#line 37
  pchk->l[pchk->count].len = len;
#line 39
  (pchk->count) ++;
#line 41
  return;
}
}
#line 45 "/root/libsndfile/src/chunk.c"
int pchk4_find(PRIV_CHUNK4 *pchk , int marker ) 
{ 
  int k ;
  int __cil_tmp4 ;

  {
#line 48
  k = 0;
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! (k < pchk->count)) {
#line 48
      goto while_break;
    }
#line 49
    if (pchk->l[k].chunk == marker) {
#line 50
      return (k);
    }
#line 48
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  return (- 1);
}
}
#line 26 "/root/libsndfile/src/broadcast.c"
static void strncpy_crlf(char *dest , char const   *src , size_t destmax , size_t srcmax ) ;
#line 27
static int gen_coding_history(char *added_history , int added_history_max , SF_INFO *psfinfo ) ;
#line 30 "/root/libsndfile/src/broadcast.c"
__inline static size_t bc_min_size(SF_BROADCAST_INFO *info ) 
{ 


  {
#line 31
  if (info == (void *)0) {
#line 32
    return ((size_t )0);
  }
#line 34
  return ((unsigned long )info->coding_history_size);
}
}
#line 39 "/root/libsndfile/src/broadcast.c"
__inline static size_t bc_var_coding_hist_size(SF_BROADCAST_VAR *var ) 
{ 


  {
#line 40
  return ((unsigned long )var->size);
}
}
#line 44 "/root/libsndfile/src/broadcast.c"
SF_BROADCAST_VAR *broadcast_var_alloc(size_t datasize ) 
{ 
  SF_BROADCAST_VAR *data___0 ;
  void *__cil_tmp3 ;

  {
  {
#line 47
  data___0 = (SF_BROADCAST_VAR *)calloc((unsigned long )1, datasize);
  }
#line 47
  if (data___0 != (void *)0) {
#line 48
    data___0->size = (int )datasize;
  }
#line 50
  return (data___0);
}
}
#line 55 "/root/libsndfile/src/broadcast.c"
int broadcast_var_set(SF_PRIVATE *psf , SF_BROADCAST_INFO *info , size_t datasize ) 
{ 
  char added_history[256] ;
  int added_history_len ;
  int len ;
  size_t __cil_tmp7 ;
  int __cil_tmp8 ;
  size_t coding_hist_offset ;
  int size ;
  void *__cil_tmp11 ;
  size_t __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  int tmp ;

  {
#line 59
  if (info == (void *)0) {
#line 60
    return (0);
  }
  {
#line 62
  __cil_tmp7 = bc_min_size(info);
  }
#line 62
  if (__cil_tmp7 > datasize) {
#line 63
    psf->error = 48;
#line 64
    return (0);
  }
  {
#line 67
  added_history_len = gen_coding_history((char *)added_history, (int )sizeof(added_history),
                                         & psf->sf);
  }
#line 69
  if (psf->broadcast_var != (void *)0) {
#line 70
    coding_hist_offset = 0;
#line 72
    if ((unsigned long )((psf->broadcast_var)->binfo.coding_history_size + (unsigned int )added_history_len) < datasize - coding_hist_offset) {
      {
#line 73
      free(psf->broadcast_var);
#line 74
      psf->broadcast_var = (SF_BROADCAST_VAR *)((void *)0);
      }
    }

  }

#line 78
  if (psf->broadcast_var == (void *)0) {
    {
#line 79
    size = (int )((datasize + (unsigned long )added_history_len) + 512UL);
#line 81
    psf->broadcast_var = (SF_BROADCAST_VAR *)calloc((unsigned long )1, (unsigned long )size);
#line 82
    (psf->broadcast_var)->size = size;
    }
  }
  {
#line 85
  memcpy(& (psf->broadcast_var)->binfo, info, 0);
#line 87
  __cil_tmp12 = bc_var_coding_hist_size(psf->broadcast_var);
#line 87
  strncpy_crlf((char *)(psf->broadcast_var)->binfo.coding_history, (char const   *)info->coding_history,
               __cil_tmp12, (size_t )info->coding_history_size);
#line 88
  __cil_tmp13 = strlen((char const   *)((char *)(psf->broadcast_var)->binfo.coding_history));
#line 88
  len = (int )__cil_tmp13;
  }
#line 90
  if (len > 0) {
#line 90
    if ((int )(psf->broadcast_var)->binfo.coding_history[len] != 10) {
      {
#line 91
      strncat((char *)(psf->broadcast_var)->binfo.coding_history, "\r\n", (unsigned long )2);
      }
    }
  }
#line 93
  if (psf->mode == 32) {
    {
#line 94
    __cil_tmp14 = strlen((char const   *)((char *)added_history));
#line 94
    strncat((char *)(psf->broadcast_var)->binfo.coding_history, (char const   *)((char *)added_history),
            __cil_tmp14);
    }
  }
  {
#line 96
  __cil_tmp15 = strlen((char const   *)((char *)(psf->broadcast_var)->binfo.coding_history));
#line 96
  (psf->broadcast_var)->binfo.coding_history_size = (unsigned int )__cil_tmp15;
  }
#line 99
  if ((psf->broadcast_var)->binfo.coding_history_size & 1U) {
#line 99
    tmp = 1;
  } else {
#line 99
    tmp = 0;
  }
#line 99
  (psf->broadcast_var)->binfo.coding_history_size += (unsigned int )tmp;
#line 102
  (psf->broadcast_var)->binfo.version = (short )1;
#line 104
  return (1);
}
}
#line 109 "/root/libsndfile/src/broadcast.c"
int broadcast_var_get(SF_PRIVATE *psf , SF_BROADCAST_INFO *data___0 , size_t datasize ) 
{ 
  size_t size ;

  {
#line 112
  if (psf->broadcast_var == (void *)0) {
#line 113
    return (0);
  }
  {
#line 115
  size = 0;
#line 117
  memcpy(data___0, & (psf->broadcast_var)->binfo, size);
  }
#line 119
  return (1);
}
}
#line 127 "/root/libsndfile/src/broadcast.c"
static void strncpy_crlf(char *dest , char const   *src , size_t destmax , size_t srcmax ) 
{ 
  char *destend ;
  char const   *srcend ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char const   *__cil_tmp14 ;

  {
#line 128
  destend = (dest + destmax) - 1;
#line 129
  srcend = src + srcmax;
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (! (dest < destend && src < srcend)) {
#line 131
      goto while_break;
    }
#line 132
    if ((int )*(src + 0) == 13) {
#line 132
      if ((int )*(src + 1) == 10) {
        _L: /* CIL Label */ 
#line 133
        __cil_tmp7 = dest;
#line 133
        dest ++;
#line 133
        *__cil_tmp7 = (char )'\r';
#line 134
        __cil_tmp8 = dest;
#line 134
        dest ++;
#line 134
        *__cil_tmp8 = (char )'\n';
#line 135
        src += 2;
#line 136
        goto while_continue;
      } else {
#line 132
        goto _L___8;
      }
    } else
    _L___8: /* CIL Label */ 
#line 132
    if ((int )*(src + 0) == 10) {
#line 132
      if ((int )*(src + 1) == 13) {
#line 132
        goto _L;
      }
    }

#line 139
    if ((int )*(src + 0) == 13) {
#line 140
      __cil_tmp9 = dest;
#line 140
      dest ++;
#line 140
      *__cil_tmp9 = (char )'\r';
#line 141
      __cil_tmp10 = dest;
#line 141
      dest ++;
#line 141
      *__cil_tmp10 = (char )'\n';
#line 142
      src ++;
#line 143
      goto while_continue;
    }

#line 146
    if ((int )*(src + 0) == 10) {
#line 147
      __cil_tmp11 = dest;
#line 147
      dest ++;
#line 147
      *__cil_tmp11 = (char )'\r';
#line 148
      __cil_tmp12 = dest;
#line 148
      dest ++;
#line 148
      *__cil_tmp12 = (char )'\n';
#line 149
      src ++;
#line 150
      goto while_continue;
    }
#line 153
    __cil_tmp14 = src;
#line 153
    src ++;
#line 153
    __cil_tmp13 = dest;
#line 153
    dest ++;
#line 153
    *__cil_tmp13 = *__cil_tmp14;
  }
  while_break: /* CIL Label */ ;
  }
#line 157
  *dest = (char )0;
  return;
}
}
#line 161 "/root/libsndfile/src/broadcast.c"
static int gen_coding_history(char *added_history , int added_history_max , SF_INFO *psfinfo ) 
{ 
  char chnstr[16] ;
  int count ;
  int width ;
  int __cil_tmp7 ;

  {
  {
#line 184
  if (psfinfo->channels == 0) {
#line 184
    goto case_0;
  }
#line 187
  if (psfinfo->channels == 1) {
#line 187
    goto case_1;
  }
#line 191
  if (psfinfo->channels == 2) {
#line 191
    goto case_2;
  }
#line 195
  goto switch_default;
  case_0: /* CIL Label */ 
#line 185
  return (0);
  case_1: /* CIL Label */ 
  {
#line 188
  strncpy((char *)chnstr, "mono", sizeof(chnstr));
  }
#line 189
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 192
  strncpy((char *)chnstr, "stereo", sizeof(chnstr));
  }
#line 193
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 196
  snprintf((char *)chnstr, sizeof(chnstr), "%uchn", psfinfo->channels);
  }
#line 197
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }

  {
#line 202
  if ((psfinfo->format & 65535) == 1) {
#line 202
    goto case_1___0;
  }
#line 202
  if ((psfinfo->format & 65535) == 5) {
#line 202
    goto case_1___0;
  }
#line 205
  if ((psfinfo->format & 65535) == 2) {
#line 205
    goto case_2___0;
  }
#line 208
  if ((psfinfo->format & 65535) == 3) {
#line 208
    goto case_3;
  }
#line 211
  if ((psfinfo->format & 65535) == 4) {
#line 211
    goto case_4;
  }
#line 214
  if ((psfinfo->format & 65535) == 6) {
#line 214
    goto case_6;
  }
#line 217
  if ((psfinfo->format & 65535) == 7) {
#line 217
    goto case_7;
  }
#line 221
  if ((psfinfo->format & 65535) == 17) {
#line 221
    goto case_17;
  }
#line 221
  if ((psfinfo->format & 65535) == 16) {
#line 221
    goto case_17;
  }
#line 224
  goto switch_default___0;
  case_1___0: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 203
  width = 8;
#line 204
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 206
  width = 16;
#line 207
  goto switch_break___0;
  case_3: /* CIL Label */ 
#line 209
  width = 24;
#line 210
  goto switch_break___0;
  case_4: /* CIL Label */ 
#line 212
  width = 32;
#line 213
  goto switch_break___0;
  case_6: /* CIL Label */ 
#line 215
  width = 24;
#line 216
  goto switch_break___0;
  case_7: /* CIL Label */ 
#line 218
  width = 53;
#line 219
  goto switch_break___0;
  case_17: /* CIL Label */ 
  case_16: /* CIL Label */ 
#line 222
  width = 12;
#line 223
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 225
  width = 42;
#line 226
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 229
  count = snprintf(added_history, (unsigned long )added_history_max, "A=PCM,F=%u,W=%hu,M=%s,T=%s-%s\r\n",
                   psfinfo->samplerate, width, (char *)chnstr, "libsndfile", "1.0.21pre1i\372\036V");
  }
#line 233
  if (count >= added_history_max) {
#line 234
    return (0);
  }
#line 236
  return (count);
}
}
#line 42 "/root/libsndfile/src/audio_detect.c"
static void vote_for_format(VOTE *vote , unsigned char const   *data___0 , int datalen ) ;
#line 45 "/root/libsndfile/src/audio_detect.c"
int audio_detect(SF_PRIVATE *psf , AUDIO_DETECT *ad , unsigned char const   *data___0 ,
                 int datalen ) 
{ 
  VOTE vote ;

  {
#line 48
  if (psf == (void *)0) {
#line 49
    return (0);
  }
#line 51
  if (ad == (void *)0) {
#line 52
    return (0);
  } else
#line 51
  if (datalen < 256) {
#line 52
    return (0);
  }
  {
#line 54
  vote_for_format(& vote, data___0, datalen);
#line 56
  psf_log_printf(psf, "audio_detect :\n    le_float     : %d\n    be_float     : %d\n    le_int_24_32 : %d\n    be_int_24_32 : %d\n",
                 vote.le_float, vote.be_float, vote.le_int_24_32, vote.be_int_24_32);
  }
#line 63
  if (0) {
    {
#line 63
    puts((char const   *)((char *)psf->logbuffer));
    }
  }
#line 65
  if (ad->endianness == 268435456) {
#line 65
    if (vote.le_float > (3 * datalen) / 4) {
#line 67
      return (6);
    }
  }

#line 70
  if (ad->endianness == 268435456) {
#line 70
    if (vote.le_int_24_32 > (3 * datalen) / 4) {
#line 72
      return (4);
    }
  }

#line 75
  return (0);
}
}
#line 79 "/root/libsndfile/src/audio_detect.c"
static void vote_for_format(VOTE *vote , unsigned char const   *data___0 , int datalen ) 
{ 
  int k ;
  int __cil_tmp5 ;

  {
  {
#line 83
  memset(vote, 0, sizeof(VOTE ));
#line 85
  datalen -= datalen % 4;
#line 87
  k = 0;
  }
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
#line 87
    if (! (k < datalen)) {
#line 87
      goto while_break;
    }
#line 88
    if (k % 4 == 0) {
#line 89
      if ((int )*(data___0 + k) == 0) {
#line 89
        if ((int )*(data___0 + (k + 1)) != 0) {
#line 90
          vote->le_int_24_32 += 4;
        }
      }
#line 92
      if ((int )*(data___0 + 2) != 0) {
#line 92
        if ((int )*(data___0 + 3) == 0) {
#line 93
          vote->le_int_24_32 += 4;
        }
      }
#line 95
      if ((int )*(data___0 + 0) != 0) {
#line 95
        if ((int )*(data___0 + 3) > 67) {
#line 95
          if ((int )*(data___0 + 3) < 75) {
#line 96
            vote->le_float += 4;
          }
        }
      }
#line 98
      if ((int )*(data___0 + 3) != 0) {
#line 98
        if ((int )*(data___0 + 0) > 67) {
#line 98
          if ((int )*(data___0 + 0) < 75) {
#line 99
            vote->be_float += 4;
          }
        }
      }
    }

#line 87
    k ++;
  }
  while_break: /* CIL Label */ ;
  }

#line 103
  return;
}
}
#line 26 "/root/libsndfile/src/alaw.c"
static sf_count_t alaw_read_alaw2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 27
static sf_count_t alaw_read_alaw2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 28
static sf_count_t alaw_read_alaw2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 29
static sf_count_t alaw_read_alaw2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 31
static sf_count_t alaw_write_s2alaw(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 32
static sf_count_t alaw_write_i2alaw(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 33
static sf_count_t alaw_write_f2alaw(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 34
static sf_count_t alaw_write_d2alaw(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 36
__inline static void alaw2s_array(unsigned char *buffer , int count , short *ptr ) ;
#line 37
__inline static void alaw2i_array(unsigned char *buffer , int count , int *ptr ) ;
#line 38
__inline static void alaw2f_array(unsigned char *buffer , int count , float *ptr ,
                                  float normfact ) ;
#line 39
__inline static void alaw2d_array(unsigned char *buffer , int count , double *ptr ,
                                  double normfact ) ;
#line 41
__inline static void s2alaw_array(short const   *ptr , int count , unsigned char *buffer ) ;
#line 42
__inline static void i2alaw_array(int const   *ptr , int count , unsigned char *buffer ) ;
#line 43
__inline static void f2alaw_array(float const   *ptr , int count , unsigned char *buffer ,
                                  float normfact ) ;
#line 44
__inline static void d2alaw_array(double const   *ptr , int count , unsigned char *buffer ,
                                  double normfact ) ;
#line 48 "/root/libsndfile/src/alaw.c"
int alaw_init(SF_PRIVATE *psf ) 
{ 
  sf_count_t tmp ;

  {
#line 50
  if (psf->mode == 16) {
#line 51
    psf->read_short = & alaw_read_alaw2s;
#line 52
    psf->read_int = & alaw_read_alaw2i;
#line 53
    psf->read_float = & alaw_read_alaw2f;
#line 54
    psf->read_double = & alaw_read_alaw2d;
  } else
#line 50
  if (psf->mode == 48) {
#line 51
    psf->read_short = & alaw_read_alaw2s;
#line 52
    psf->read_int = & alaw_read_alaw2i;
#line 53
    psf->read_float = & alaw_read_alaw2f;
#line 54
    psf->read_double = & alaw_read_alaw2d;
  }

#line 57
  if (psf->mode == 32) {
#line 58
    psf->write_short = & alaw_write_s2alaw;
#line 59
    psf->write_int = & alaw_write_i2alaw;
#line 60
    psf->write_float = & alaw_write_f2alaw;
#line 61
    psf->write_double = & alaw_write_d2alaw;
  } else
#line 57
  if (psf->mode == 48) {
#line 58
    psf->write_short = & alaw_write_s2alaw;
#line 59
    psf->write_int = & alaw_write_i2alaw;
#line 60
    psf->write_float = & alaw_write_f2alaw;
#line 61
    psf->write_double = & alaw_write_d2alaw;
  }
#line 64
  psf->bytewidth = 1;
#line 65
  psf->blockwidth = psf->sf.channels;
#line 67
  if (psf->filelength > psf->dataoffset) {
#line 68
    if (psf->dataend) {
#line 68
      tmp = psf->dataend - psf->dataoffset;
    } else {
#line 68
      tmp = psf->filelength - psf->dataoffset;
    }
#line 68
    psf->datalength = tmp;
  } else {
#line 70
    psf->datalength = (sf_count_t )0;
  }
#line 72
  psf->sf.frames = psf->datalength / (long )psf->blockwidth;
#line 74
  return (0);
}
}
#line 82 "/root/libsndfile/src/alaw.c"
static short alaw_decode[256]  = 
#line 82
  {      (short )(- 5504),      (short )(- 5248),      (short )(- 6016),      (short )(- 5760), 
        (short )(- 4480),      (short )(- 4224),      (short )(- 4992),      (short )(- 4736), 
        (short )(- 7552),      (short )(- 7296),      (short )(- 8064),      (short )(- 7808), 
        (short )(- 6528),      (short )(- 6272),      (short )(- 7040),      (short )(- 6784), 
        (short )(- 2752),      (short )(- 2624),      (short )(- 3008),      (short )(- 2880), 
        (short )(- 2240),      (short )(- 2112),      (short )(- 2496),      (short )(- 2368), 
        (short )(- 3776),      (short )(- 3648),      (short )(- 4032),      (short )(- 3904), 
        (short )(- 3264),      (short )(- 3136),      (short )(- 3520),      (short )(- 3392), 
        (short )(- 22016),      (short )(- 20992),      (short )(- 24064),      (short )(- 23040), 
        (short )(- 17920),      (short )(- 16896),      (short )(- 19968),      (short )(- 18944), 
        (short )(- 30208),      (short )(- 29184),      (short )(- 32256),      (short )(- 31232), 
        (short )(- 26112),      (short )(- 25088),      (short )(- 28160),      (short )(- 27136), 
        (short )(- 11008),      (short )(- 10496),      (short )(- 12032),      (short )(- 11520), 
        (short )(- 8960),      (short )(- 8448),      (short )(- 9984),      (short )(- 9472), 
        (short )(- 15104),      (short )(- 14592),      (short )(- 16128),      (short )(- 15616), 
        (short )(- 13056),      (short )(- 12544),      (short )(- 14080),      (short )(- 13568), 
        (short )(- 344),      (short )(- 328),      (short )(- 376),      (short )(- 360), 
        (short )(- 280),      (short )(- 264),      (short )(- 312),      (short )(- 296), 
        (short )(- 472),      (short )(- 456),      (short )(- 504),      (short )(- 488), 
        (short )(- 408),      (short )(- 392),      (short )(- 440),      (short )(- 424), 
        (short )(- 88),      (short )(- 72),      (short )(- 120),      (short )(- 104), 
        (short )(- 24),      (short )(- 8),      (short )(- 56),      (short )(- 40), 
        (short )(- 216),      (short )(- 200),      (short )(- 248),      (short )(- 232), 
        (short )(- 152),      (short )(- 136),      (short )(- 184),      (short )(- 168), 
        (short )(- 1376),      (short )(- 1312),      (short )(- 1504),      (short )(- 1440), 
        (short )(- 1120),      (short )(- 1056),      (short )(- 1248),      (short )(- 1184), 
        (short )(- 1888),      (short )(- 1824),      (short )(- 2016),      (short )(- 1952), 
        (short )(- 1632),      (short )(- 1568),      (short )(- 1760),      (short )(- 1696), 
        (short )(- 688),      (short )(- 656),      (short )(- 752),      (short )(- 720), 
        (short )(- 560),      (short )(- 528),      (short )(- 624),      (short )(- 592), 
        (short )(- 944),      (short )(- 912),      (short )(- 1008),      (short )(- 976), 
        (short )(- 816),      (short )(- 784),      (short )(- 880),      (short )(- 848), 
        (short )5504,      (short )5248,      (short )6016,      (short )5760, 
        (short )4480,      (short )4224,      (short )4992,      (short )4736, 
        (short )7552,      (short )7296,      (short )8064,      (short )7808, 
        (short )6528,      (short )6272,      (short )7040,      (short )6784, 
        (short )2752,      (short )2624,      (short )3008,      (short )2880, 
        (short )2240,      (short )2112,      (short )2496,      (short )2368, 
        (short )3776,      (short )3648,      (short )4032,      (short )3904, 
        (short )3264,      (short )3136,      (short )3520,      (short )3392, 
        (short )22016,      (short )20992,      (short )24064,      (short )23040, 
        (short )17920,      (short )16896,      (short )19968,      (short )18944, 
        (short )30208,      (short )29184,      (short )32256,      (short )31232, 
        (short )26112,      (short )25088,      (short )28160,      (short )27136, 
        (short )11008,      (short )10496,      (short )12032,      (short )11520, 
        (short )8960,      (short )8448,      (short )9984,      (short )9472, 
        (short )15104,      (short )14592,      (short )16128,      (short )15616, 
        (short )13056,      (short )12544,      (short )14080,      (short )13568, 
        (short )344,      (short )328,      (short )376,      (short )360, 
        (short )280,      (short )264,      (short )312,      (short )296, 
        (short )472,      (short )456,      (short )504,      (short )488, 
        (short )408,      (short )392,      (short )440,      (short )424, 
        (short )88,      (short )72,      (short )120,      (short )104, 
        (short )24,      (short )8,      (short )56,      (short )40, 
        (short )216,      (short )200,      (short )248,      (short )232, 
        (short )152,      (short )136,      (short )184,      (short )168, 
        (short )1376,      (short )1312,      (short )1504,      (short )1440, 
        (short )1120,      (short )1056,      (short )1248,      (short )1184, 
        (short )1888,      (short )1824,      (short )2016,      (short )1952, 
        (short )1632,      (short )1568,      (short )1760,      (short )1696, 
        (short )688,      (short )656,      (short )752,      (short )720, 
        (short )560,      (short )528,      (short )624,      (short )592, 
        (short )944,      (short )912,      (short )1008,      (short )976, 
        (short )816,      (short )784,      (short )880,      (short )848};
#line 118 "/root/libsndfile/src/alaw.c"
static unsigned char alaw_encode[2049]  = 
#line 118
  {      (unsigned char )213,      (unsigned char )212,      (unsigned char )215,      (unsigned char )214, 
        (unsigned char )209,      (unsigned char )208,      (unsigned char )211,      (unsigned char )210, 
        (unsigned char )221,      (unsigned char )220,      (unsigned char )223,      (unsigned char )222, 
        (unsigned char )217,      (unsigned char )216,      (unsigned char )219,      (unsigned char )218, 
        (unsigned char )197,      (unsigned char )196,      (unsigned char )199,      (unsigned char )198, 
        (unsigned char )193,      (unsigned char )192,      (unsigned char )195,      (unsigned char )194, 
        (unsigned char )205,      (unsigned char )204,      (unsigned char )207,      (unsigned char )206, 
        (unsigned char )201,      (unsigned char )200,      (unsigned char )203,      (unsigned char )202, 
        (unsigned char )245,      (unsigned char )245,      (unsigned char )244,      (unsigned char )244, 
        (unsigned char )247,      (unsigned char )247,      (unsigned char )246,      (unsigned char )246, 
        (unsigned char )241,      (unsigned char )241,      (unsigned char )240,      (unsigned char )240, 
        (unsigned char )243,      (unsigned char )243,      (unsigned char )242,      (unsigned char )242, 
        (unsigned char )253,      (unsigned char )253,      (unsigned char )252,      (unsigned char )252, 
        (unsigned char )255,      (unsigned char )255,      (unsigned char )254,      (unsigned char )254, 
        (unsigned char )249,      (unsigned char )249,      (unsigned char )248,      (unsigned char )248, 
        (unsigned char )251,      (unsigned char )251,      (unsigned char )250,      (unsigned char )250, 
        (unsigned char )229,      (unsigned char )229,      (unsigned char )229,      (unsigned char )229, 
        (unsigned char )228,      (unsigned char )228,      (unsigned char )228,      (unsigned char )228, 
        (unsigned char )231,      (unsigned char )231,      (unsigned char )231,      (unsigned char )231, 
        (unsigned char )230,      (unsigned char )230,      (unsigned char )230,      (unsigned char )230, 
        (unsigned char )225,      (unsigned char )225,      (unsigned char )225,      (unsigned char )225, 
        (unsigned char )224,      (unsigned char )224,      (unsigned char )224,      (unsigned char )224, 
        (unsigned char )227,      (unsigned char )227,      (unsigned char )227,      (unsigned char )227, 
        (unsigned char )226,      (unsigned char )226,      (unsigned char )226,      (unsigned char )226, 
        (unsigned char )237,      (unsigned char )237,      (unsigned char )237,      (unsigned char )237, 
        (unsigned char )236,      (unsigned char )236,      (unsigned char )236,      (unsigned char )236, 
        (unsigned char )239,      (unsigned char )239,      (unsigned char )239,      (unsigned char )239, 
        (unsigned char )238,      (unsigned char )238,      (unsigned char )238,      (unsigned char )238, 
        (unsigned char )233,      (unsigned char )233,      (unsigned char )233,      (unsigned char )233, 
        (unsigned char )232,      (unsigned char )232,      (unsigned char )232,      (unsigned char )232, 
        (unsigned char )235,      (unsigned char )235,      (unsigned char )235,      (unsigned char )235, 
        (unsigned char )234,      (unsigned char )234,      (unsigned char )234,      (unsigned char )234, 
        (unsigned char )149,      (unsigned char )149,      (unsigned char )149,      (unsigned char )149, 
        (unsigned char )149,      (unsigned char )149,      (unsigned char )149,      (unsigned char )149, 
        (unsigned char )148,      (unsigned char )148,      (unsigned char )148,      (unsigned char )148, 
        (unsigned char )148,      (unsigned char )148,      (unsigned char )148,      (unsigned char )148, 
        (unsigned char )151,      (unsigned char )151,      (unsigned char )151,      (unsigned char )151, 
        (unsigned char )151,      (unsigned char )151,      (unsigned char )151,      (unsigned char )151, 
        (unsigned char )150,      (unsigned char )150,      (unsigned char )150,      (unsigned char )150, 
        (unsigned char )150,      (unsigned char )150,      (unsigned char )150,      (unsigned char )150, 
        (unsigned char )145,      (unsigned char )145,      (unsigned char )145,      (unsigned char )145, 
        (unsigned char )145,      (unsigned char )145,      (unsigned char )145,      (unsigned char )145, 
        (unsigned char )144,      (unsigned char )144,      (unsigned char )144,      (unsigned char )144, 
        (unsigned char )144,      (unsigned char )144,      (unsigned char )144,      (unsigned char )144, 
        (unsigned char )147,      (unsigned char )147,      (unsigned char )147,      (unsigned char )147, 
        (unsigned char )147,      (unsigned char )147,      (unsigned char )147,      (unsigned char )147, 
        (unsigned char )146,      (unsigned char )146,      (unsigned char )146,      (unsigned char )146, 
        (unsigned char )146,      (unsigned char )146,      (unsigned char )146,      (unsigned char )146, 
        (unsigned char )157,      (unsigned char )157,      (unsigned char )157,      (unsigned char )157, 
        (unsigned char )157,      (unsigned char )157,      (unsigned char )157,      (unsigned char )157, 
        (unsigned char )156,      (unsigned char )156,      (unsigned char )156,      (unsigned char )156, 
        (unsigned char )156,      (unsigned char )156,      (unsigned char )156,      (unsigned char )156, 
        (unsigned char )159,      (unsigned char )159,      (unsigned char )159,      (unsigned char )159, 
        (unsigned char )159,      (unsigned char )159,      (unsigned char )159,      (unsigned char )159, 
        (unsigned char )158,      (unsigned char )158,      (unsigned char )158,      (unsigned char )158, 
        (unsigned char )158,      (unsigned char )158,      (unsigned char )158,      (unsigned char )158, 
        (unsigned char )153,      (unsigned char )153,      (unsigned char )153,      (unsigned char )153, 
        (unsigned char )153,      (unsigned char )153,      (unsigned char )153,      (unsigned char )153, 
        (unsigned char )152,      (unsigned char )152,      (unsigned char )152,      (unsigned char )152, 
        (unsigned char )152,      (unsigned char )152,      (unsigned char )152,      (unsigned char )152, 
        (unsigned char )155,      (unsigned char )155,      (unsigned char )155,      (unsigned char )155, 
        (unsigned char )155,      (unsigned char )155,      (unsigned char )155,      (unsigned char )155, 
        (unsigned char )154,      (unsigned char )154,      (unsigned char )154,      (unsigned char )154, 
        (unsigned char )154,      (unsigned char )154,      (unsigned char )154,      (unsigned char )154, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )133,      (unsigned char )133,      (unsigned char )133,      (unsigned char )133, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )132,      (unsigned char )132,      (unsigned char )132,      (unsigned char )132, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )135,      (unsigned char )135,      (unsigned char )135,      (unsigned char )135, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )134,      (unsigned char )134,      (unsigned char )134,      (unsigned char )134, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )129,      (unsigned char )129,      (unsigned char )129,      (unsigned char )129, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )128,      (unsigned char )128,      (unsigned char )128,      (unsigned char )128, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )131,      (unsigned char )131,      (unsigned char )131,      (unsigned char )131, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )130,      (unsigned char )130,      (unsigned char )130,      (unsigned char )130, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )141,      (unsigned char )141,      (unsigned char )141,      (unsigned char )141, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )140,      (unsigned char )140,      (unsigned char )140,      (unsigned char )140, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )143,      (unsigned char )143,      (unsigned char )143,      (unsigned char )143, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )142,      (unsigned char )142,      (unsigned char )142,      (unsigned char )142, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )137,      (unsigned char )137,      (unsigned char )137,      (unsigned char )137, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )136,      (unsigned char )136,      (unsigned char )136,      (unsigned char )136, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )139,      (unsigned char )139,      (unsigned char )139,      (unsigned char )139, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )138,      (unsigned char )138,      (unsigned char )138,      (unsigned char )138, 
        (unsigned char )181,      (unsigned char )181,      (unsigned char )181,      (unsigned char )181, 
        (unsigned char )181,      (unsigned char )181,      (unsigned char )181,      (unsigned char )181, 
        (unsigned char )181,      (unsigned char )181,      (unsigned char )181,      (unsigned char )181, 
        (unsigned char )181,      (unsigned char )181,      (unsigned char )181,      (unsigned char )181, 
        (unsigned char )181,      (unsigned char )181,      (unsigned char )181,      (unsigned char )181, 
        (unsigned char )181,      (unsigned char )181,      (unsigned char )181,      (unsigned char )181, 
        (unsigned char )181,      (unsigned char )181,      (unsigned char )181,      (unsigned char )181, 
        (unsigned char )181,      (unsigned char )181,      (unsigned char )181,      (unsigned char )181, 
        (unsigned char )180,      (unsigned char )180,      (unsigned char )180,      (unsigned char )180, 
        (unsigned char )180,      (unsigned char )180,      (unsigned char )180,      (unsigned char )180, 
        (unsigned char )180,      (unsigned char )180,      (unsigned char )180,      (unsigned char )180, 
        (unsigned char )180,      (unsigned char )180,      (unsigned char )180,      (unsigned char )180, 
        (unsigned char )180,      (unsigned char )180,      (unsigned char )180,      (unsigned char )180, 
        (unsigned char )180,      (unsigned char )180,      (unsigned char )180,      (unsigned char )180, 
        (unsigned char )180,      (unsigned char )180,      (unsigned char )180,      (unsigned char )180, 
        (unsigned char )180,      (unsigned char )180,      (unsigned char )180,      (unsigned char )180, 
        (unsigned char )183,      (unsigned char )183,      (unsigned char )183,      (unsigned char )183, 
        (unsigned char )183,      (unsigned char )183,      (unsigned char )183,      (unsigned char )183, 
        (unsigned char )183,      (unsigned char )183,      (unsigned char )183,      (unsigned char )183, 
        (unsigned char )183,      (unsigned char )183,      (unsigned char )183,      (unsigned char )183, 
        (unsigned char )183,      (unsigned char )183,      (unsigned char )183,      (unsigned char )183, 
        (unsigned char )183,      (unsigned char )183,      (unsigned char )183,      (unsigned char )183, 
        (unsigned char )183,      (unsigned char )183,      (unsigned char )183,      (unsigned char )183, 
        (unsigned char )183,      (unsigned char )183,      (unsigned char )183,      (unsigned char )183, 
        (unsigned char )182,      (unsigned char )182,      (unsigned char )182,      (unsigned char )182, 
        (unsigned char )182,      (unsigned char )182,      (unsigned char )182,      (unsigned char )182, 
        (unsigned char )182,      (unsigned char )182,      (unsigned char )182,      (unsigned char )182, 
        (unsigned char )182,      (unsigned char )182,      (unsigned char )182,      (unsigned char )182, 
        (unsigned char )182,      (unsigned char )182,      (unsigned char )182,      (unsigned char )182, 
        (unsigned char )182,      (unsigned char )182,      (unsigned char )182,      (unsigned char )182, 
        (unsigned char )182,      (unsigned char )182,      (unsigned char )182,      (unsigned char )182, 
        (unsigned char )182,      (unsigned char )182,      (unsigned char )182,      (unsigned char )182, 
        (unsigned char )177,      (unsigned char )177,      (unsigned char )177,      (unsigned char )177, 
        (unsigned char )177,      (unsigned char )177,      (unsigned char )177,      (unsigned char )177, 
        (unsigned char )177,      (unsigned char )177,      (unsigned char )177,      (unsigned char )177, 
        (unsigned char )177,      (unsigned char )177,      (unsigned char )177,      (unsigned char )177, 
        (unsigned char )177,      (unsigned char )177,      (unsigned char )177,      (unsigned char )177, 
        (unsigned char )177,      (unsigned char )177,      (unsigned char )177,      (unsigned char )177, 
        (unsigned char )177,      (unsigned char )177,      (unsigned char )177,      (unsigned char )177, 
        (unsigned char )177,      (unsigned char )177,      (unsigned char )177,      (unsigned char )177, 
        (unsigned char )176,      (unsigned char )176,      (unsigned char )176,      (unsigned char )176, 
        (unsigned char )176,      (unsigned char )176,      (unsigned char )176,      (unsigned char )176, 
        (unsigned char )176,      (unsigned char )176,      (unsigned char )176,      (unsigned char )176, 
        (unsigned char )176,      (unsigned char )176,      (unsigned char )176,      (unsigned char )176, 
        (unsigned char )176,      (unsigned char )176,      (unsigned char )176,      (unsigned char )176, 
        (unsigned char )176,      (unsigned char )176,      (unsigned char )176,      (unsigned char )176, 
        (unsigned char )176,      (unsigned char )176,      (unsigned char )176,      (unsigned char )176, 
        (unsigned char )176,      (unsigned char )176,      (unsigned char )176,      (unsigned char )176, 
        (unsigned char )179,      (unsigned char )179,      (unsigned char )179,      (unsigned char )179, 
        (unsigned char )179,      (unsigned char )179,      (unsigned char )179,      (unsigned char )179, 
        (unsigned char )179,      (unsigned char )179,      (unsigned char )179,      (unsigned char )179, 
        (unsigned char )179,      (unsigned char )179,      (unsigned char )179,      (unsigned char )179, 
        (unsigned char )179,      (unsigned char )179,      (unsigned char )179,      (unsigned char )179, 
        (unsigned char )179,      (unsigned char )179,      (unsigned char )179,      (unsigned char )179, 
        (unsigned char )179,      (unsigned char )179,      (unsigned char )179,      (unsigned char )179, 
        (unsigned char )179,      (unsigned char )179,      (unsigned char )179,      (unsigned char )179, 
        (unsigned char )178,      (unsigned char )178,      (unsigned char )178,      (unsigned char )178, 
        (unsigned char )178,      (unsigned char )178,      (unsigned char )178,      (unsigned char )178, 
        (unsigned char )178,      (unsigned char )178,      (unsigned char )178,      (unsigned char )178, 
        (unsigned char )178,      (unsigned char )178,      (unsigned char )178,      (unsigned char )178, 
        (unsigned char )178,      (unsigned char )178,      (unsigned char )178,      (unsigned char )178, 
        (unsigned char )178,      (unsigned char )178,      (unsigned char )178,      (unsigned char )178, 
        (unsigned char )178,      (unsigned char )178,      (unsigned char )178,      (unsigned char )178, 
        (unsigned char )178,      (unsigned char )178,      (unsigned char )178,      (unsigned char )178, 
        (unsigned char )189,      (unsigned char )189,      (unsigned char )189,      (unsigned char )189, 
        (unsigned char )189,      (unsigned char )189,      (unsigned char )189,      (unsigned char )189, 
        (unsigned char )189,      (unsigned char )189,      (unsigned char )189,      (unsigned char )189, 
        (unsigned char )189,      (unsigned char )189,      (unsigned char )189,      (unsigned char )189, 
        (unsigned char )189,      (unsigned char )189,      (unsigned char )189,      (unsigned char )189, 
        (unsigned char )189,      (unsigned char )189,      (unsigned char )189,      (unsigned char )189, 
        (unsigned char )189,      (unsigned char )189,      (unsigned char )189,      (unsigned char )189, 
        (unsigned char )189,      (unsigned char )189,      (unsigned char )189,      (unsigned char )189, 
        (unsigned char )188,      (unsigned char )188,      (unsigned char )188,      (unsigned char )188, 
        (unsigned char )188,      (unsigned char )188,      (unsigned char )188,      (unsigned char )188, 
        (unsigned char )188,      (unsigned char )188,      (unsigned char )188,      (unsigned char )188, 
        (unsigned char )188,      (unsigned char )188,      (unsigned char )188,      (unsigned char )188, 
        (unsigned char )188,      (unsigned char )188,      (unsigned char )188,      (unsigned char )188, 
        (unsigned char )188,      (unsigned char )188,      (unsigned char )188,      (unsigned char )188, 
        (unsigned char )188,      (unsigned char )188,      (unsigned char )188,      (unsigned char )188, 
        (unsigned char )188,      (unsigned char )188,      (unsigned char )188,      (unsigned char )188, 
        (unsigned char )191,      (unsigned char )191,      (unsigned char )191,      (unsigned char )191, 
        (unsigned char )191,      (unsigned char )191,      (unsigned char )191,      (unsigned char )191, 
        (unsigned char )191,      (unsigned char )191,      (unsigned char )191,      (unsigned char )191, 
        (unsigned char )191,      (unsigned char )191,      (unsigned char )191,      (unsigned char )191, 
        (unsigned char )191,      (unsigned char )191,      (unsigned char )191,      (unsigned char )191, 
        (unsigned char )191,      (unsigned char )191,      (unsigned char )191,      (unsigned char )191, 
        (unsigned char )191,      (unsigned char )191,      (unsigned char )191,      (unsigned char )191, 
        (unsigned char )191,      (unsigned char )191,      (unsigned char )191,      (unsigned char )191, 
        (unsigned char )190,      (unsigned char )190,      (unsigned char )190,      (unsigned char )190, 
        (unsigned char )190,      (unsigned char )190,      (unsigned char )190,      (unsigned char )190, 
        (unsigned char )190,      (unsigned char )190,      (unsigned char )190,      (unsigned char )190, 
        (unsigned char )190,      (unsigned char )190,      (unsigned char )190,      (unsigned char )190, 
        (unsigned char )190,      (unsigned char )190,      (unsigned char )190,      (unsigned char )190, 
        (unsigned char )190,      (unsigned char )190,      (unsigned char )190,      (unsigned char )190, 
        (unsigned char )190,      (unsigned char )190,      (unsigned char )190,      (unsigned char )190, 
        (unsigned char )190,      (unsigned char )190,      (unsigned char )190,      (unsigned char )190, 
        (unsigned char )185,      (unsigned char )185,      (unsigned char )185,      (unsigned char )185, 
        (unsigned char )185,      (unsigned char )185,      (unsigned char )185,      (unsigned char )185, 
        (unsigned char )185,      (unsigned char )185,      (unsigned char )185,      (unsigned char )185, 
        (unsigned char )185,      (unsigned char )185,      (unsigned char )185,      (unsigned char )185, 
        (unsigned char )185,      (unsigned char )185,      (unsigned char )185,      (unsigned char )185, 
        (unsigned char )185,      (unsigned char )185,      (unsigned char )185,      (unsigned char )185, 
        (unsigned char )185,      (unsigned char )185,      (unsigned char )185,      (unsigned char )185, 
        (unsigned char )185,      (unsigned char )185,      (unsigned char )185,      (unsigned char )185, 
        (unsigned char )184,      (unsigned char )184,      (unsigned char )184,      (unsigned char )184, 
        (unsigned char )184,      (unsigned char )184,      (unsigned char )184,      (unsigned char )184, 
        (unsigned char )184,      (unsigned char )184,      (unsigned char )184,      (unsigned char )184, 
        (unsigned char )184,      (unsigned char )184,      (unsigned char )184,      (unsigned char )184, 
        (unsigned char )184,      (unsigned char )184,      (unsigned char )184,      (unsigned char )184, 
        (unsigned char )184,      (unsigned char )184,      (unsigned char )184,      (unsigned char )184, 
        (unsigned char )184,      (unsigned char )184,      (unsigned char )184,      (unsigned char )184, 
        (unsigned char )184,      (unsigned char )184,      (unsigned char )184,      (unsigned char )184, 
        (unsigned char )187,      (unsigned char )187,      (unsigned char )187,      (unsigned char )187, 
        (unsigned char )187,      (unsigned char )187,      (unsigned char )187,      (unsigned char )187, 
        (unsigned char )187,      (unsigned char )187,      (unsigned char )187,      (unsigned char )187, 
        (unsigned char )187,      (unsigned char )187,      (unsigned char )187,      (unsigned char )187, 
        (unsigned char )187,      (unsigned char )187,      (unsigned char )187,      (unsigned char )187, 
        (unsigned char )187,      (unsigned char )187,      (unsigned char )187,      (unsigned char )187, 
        (unsigned char )187,      (unsigned char )187,      (unsigned char )187,      (unsigned char )187, 
        (unsigned char )187,      (unsigned char )187,      (unsigned char )187,      (unsigned char )187, 
        (unsigned char )186,      (unsigned char )186,      (unsigned char )186,      (unsigned char )186, 
        (unsigned char )186,      (unsigned char )186,      (unsigned char )186,      (unsigned char )186, 
        (unsigned char )186,      (unsigned char )186,      (unsigned char )186,      (unsigned char )186, 
        (unsigned char )186,      (unsigned char )186,      (unsigned char )186,      (unsigned char )186, 
        (unsigned char )186,      (unsigned char )186,      (unsigned char )186,      (unsigned char )186, 
        (unsigned char )186,      (unsigned char )186,      (unsigned char )186,      (unsigned char )186, 
        (unsigned char )186,      (unsigned char )186,      (unsigned char )186,      (unsigned char )186, 
        (unsigned char )186,      (unsigned char )186,      (unsigned char )186,      (unsigned char )186, 
        (unsigned char )165,      (unsigned char )165,      (unsigned char )165,      (unsigned char )165, 
        (unsigned char )165,      (unsigned char )165,      (unsigned char )165,      (unsigned char )165, 
        (unsigned char )165,      (unsigned char )165,      (unsigned char )165,      (unsigned char )165, 
        (unsigned char )165,      (unsigned char )165,      (unsigned char )165,      (unsigned char )165, 
        (unsigned char )165,      (unsigned char )165,      (unsigned char )165,      (unsigned char )165, 
        (unsigned char )165,      (unsigned char )165,      (unsigned char )165,      (unsigned char )165, 
        (unsigned char )165,      (unsigned char )165,      (unsigned char )165,      (unsigned char )165, 
        (unsigned char )165,      (unsigned char )165,      (unsigned char )165,      (unsigned char )165, 
        (unsigned char )165,      (unsigned char )165,      (unsigned char )165,      (unsigned char )165, 
        (unsigned char )165,      (unsigned char )165,      (unsigned char )165,      (unsigned char )165, 
        (unsigned char )165,      (unsigned char )165,      (unsigned char )165,      (unsigned char )165, 
        (unsigned char )165,      (unsigned char )165,      (unsigned char )165,      (unsigned char )165, 
        (unsigned char )165,      (unsigned char )165,      (unsigned char )165,      (unsigned char )165, 
        (unsigned char )165,      (unsigned char )165,      (unsigned char )165,      (unsigned char )165, 
        (unsigned char )165,      (unsigned char )165,      (unsigned char )165,      (unsigned char )165, 
        (unsigned char )165,      (unsigned char )165,      (unsigned char )165,      (unsigned char )165, 
        (unsigned char )164,      (unsigned char )164,      (unsigned char )164,      (unsigned char )164, 
        (unsigned char )164,      (unsigned char )164,      (unsigned char )164,      (unsigned char )164, 
        (unsigned char )164,      (unsigned char )164,      (unsigned char )164,      (unsigned char )164, 
        (unsigned char )164,      (unsigned char )164,      (unsigned char )164,      (unsigned char )164, 
        (unsigned char )164,      (unsigned char )164,      (unsigned char )164,      (unsigned char )164, 
        (unsigned char )164,      (unsigned char )164,      (unsigned char )164,      (unsigned char )164, 
        (unsigned char )164,      (unsigned char )164,      (unsigned char )164,      (unsigned char )164, 
        (unsigned char )164,      (unsigned char )164,      (unsigned char )164,      (unsigned char )164, 
        (unsigned char )164,      (unsigned char )164,      (unsigned char )164,      (unsigned char )164, 
        (unsigned char )164,      (unsigned char )164,      (unsigned char )164,      (unsigned char )164, 
        (unsigned char )164,      (unsigned char )164,      (unsigned char )164,      (unsigned char )164, 
        (unsigned char )164,      (unsigned char )164,      (unsigned char )164,      (unsigned char )164, 
        (unsigned char )164,      (unsigned char )164,      (unsigned char )164,      (unsigned char )164, 
        (unsigned char )164,      (unsigned char )164,      (unsigned char )164,      (unsigned char )164, 
        (unsigned char )164,      (unsigned char )164,      (unsigned char )164,      (unsigned char )164, 
        (unsigned char )164,      (unsigned char )164,      (unsigned char )164,      (unsigned char )164, 
        (unsigned char )167,      (unsigned char )167,      (unsigned char )167,      (unsigned char )167, 
        (unsigned char )167,      (unsigned char )167,      (unsigned char )167,      (unsigned char )167, 
        (unsigned char )167,      (unsigned char )167,      (unsigned char )167,      (unsigned char )167, 
        (unsigned char )167,      (unsigned char )167,      (unsigned char )167,      (unsigned char )167, 
        (unsigned char )167,      (unsigned char )167,      (unsigned char )167,      (unsigned char )167, 
        (unsigned char )167,      (unsigned char )167,      (unsigned char )167,      (unsigned char )167, 
        (unsigned char )167,      (unsigned char )167,      (unsigned char )167,      (unsigned char )167, 
        (unsigned char )167,      (unsigned char )167,      (unsigned char )167,      (unsigned char )167, 
        (unsigned char )167,      (unsigned char )167,      (unsigned char )167,      (unsigned char )167, 
        (unsigned char )167,      (unsigned char )167,      (unsigned char )167,      (unsigned char )167, 
        (unsigned char )167,      (unsigned char )167,      (unsigned char )167,      (unsigned char )167, 
        (unsigned char )167,      (unsigned char )167,      (unsigned char )167,      (unsigned char )167, 
        (unsigned char )167,      (unsigned char )167,      (unsigned char )167,      (unsigned char )167, 
        (unsigned char )167,      (unsigned char )167,      (unsigned char )167,      (unsigned char )167, 
        (unsigned char )167,      (unsigned char )167,      (unsigned char )167,      (unsigned char )167, 
        (unsigned char )167,      (unsigned char )167,      (unsigned char )167,      (unsigned char )167, 
        (unsigned char )166,      (unsigned char )166,      (unsigned char )166,      (unsigned char )166, 
        (unsigned char )166,      (unsigned char )166,      (unsigned char )166,      (unsigned char )166, 
        (unsigned char )166,      (unsigned char )166,      (unsigned char )166,      (unsigned char )166, 
        (unsigned char )166,      (unsigned char )166,      (unsigned char )166,      (unsigned char )166, 
        (unsigned char )166,      (unsigned char )166,      (unsigned char )166,      (unsigned char )166, 
        (unsigned char )166,      (unsigned char )166,      (unsigned char )166,      (unsigned char )166, 
        (unsigned char )166,      (unsigned char )166,      (unsigned char )166,      (unsigned char )166, 
        (unsigned char )166,      (unsigned char )166,      (unsigned char )166,      (unsigned char )166, 
        (unsigned char )166,      (unsigned char )166,      (unsigned char )166,      (unsigned char )166, 
        (unsigned char )166,      (unsigned char )166,      (unsigned char )166,      (unsigned char )166, 
        (unsigned char )166,      (unsigned char )166,      (unsigned char )166,      (unsigned char )166, 
        (unsigned char )166,      (unsigned char )166,      (unsigned char )166,      (unsigned char )166, 
        (unsigned char )166,      (unsigned char )166,      (unsigned char )166,      (unsigned char )166, 
        (unsigned char )166,      (unsigned char )166,      (unsigned char )166,      (unsigned char )166, 
        (unsigned char )166,      (unsigned char )166,      (unsigned char )166,      (unsigned char )166, 
        (unsigned char )166,      (unsigned char )166,      (unsigned char )166,      (unsigned char )166, 
        (unsigned char )161,      (unsigned char )161,      (unsigned char )161,      (unsigned char )161, 
        (unsigned char )161,      (unsigned char )161,      (unsigned char )161,      (unsigned char )161, 
        (unsigned char )161,      (unsigned char )161,      (unsigned char )161,      (unsigned char )161, 
        (unsigned char )161,      (unsigned char )161,      (unsigned char )161,      (unsigned char )161, 
        (unsigned char )161,      (unsigned char )161,      (unsigned char )161,      (unsigned char )161, 
        (unsigned char )161,      (unsigned char )161,      (unsigned char )161,      (unsigned char )161, 
        (unsigned char )161,      (unsigned char )161,      (unsigned char )161,      (unsigned char )161, 
        (unsigned char )161,      (unsigned char )161,      (unsigned char )161,      (unsigned char )161, 
        (unsigned char )161,      (unsigned char )161,      (unsigned char )161,      (unsigned char )161, 
        (unsigned char )161,      (unsigned char )161,      (unsigned char )161,      (unsigned char )161, 
        (unsigned char )161,      (unsigned char )161,      (unsigned char )161,      (unsigned char )161, 
        (unsigned char )161,      (unsigned char )161,      (unsigned char )161,      (unsigned char )161, 
        (unsigned char )161,      (unsigned char )161,      (unsigned char )161,      (unsigned char )161, 
        (unsigned char )161,      (unsigned char )161,      (unsigned char )161,      (unsigned char )161, 
        (unsigned char )161,      (unsigned char )161,      (unsigned char )161,      (unsigned char )161, 
        (unsigned char )161,      (unsigned char )161,      (unsigned char )161,      (unsigned char )161, 
        (unsigned char )160,      (unsigned char )160,      (unsigned char )160,      (unsigned char )160, 
        (unsigned char )160,      (unsigned char )160,      (unsigned char )160,      (unsigned char )160, 
        (unsigned char )160,      (unsigned char )160,      (unsigned char )160,      (unsigned char )160, 
        (unsigned char )160,      (unsigned char )160,      (unsigned char )160,      (unsigned char )160, 
        (unsigned char )160,      (unsigned char )160,      (unsigned char )160,      (unsigned char )160, 
        (unsigned char )160,      (unsigned char )160,      (unsigned char )160,      (unsigned char )160, 
        (unsigned char )160,      (unsigned char )160,      (unsigned char )160,      (unsigned char )160, 
        (unsigned char )160,      (unsigned char )160,      (unsigned char )160,      (unsigned char )160, 
        (unsigned char )160,      (unsigned char )160,      (unsigned char )160,      (unsigned char )160, 
        (unsigned char )160,      (unsigned char )160,      (unsigned char )160,      (unsigned char )160, 
        (unsigned char )160,      (unsigned char )160,      (unsigned char )160,      (unsigned char )160, 
        (unsigned char )160,      (unsigned char )160,      (unsigned char )160,      (unsigned char )160, 
        (unsigned char )160,      (unsigned char )160,      (unsigned char )160,      (unsigned char )160, 
        (unsigned char )160,      (unsigned char )160,      (unsigned char )160,      (unsigned char )160, 
        (unsigned char )160,      (unsigned char )160,      (unsigned char )160,      (unsigned char )160, 
        (unsigned char )160,      (unsigned char )160,      (unsigned char )160,      (unsigned char )160, 
        (unsigned char )163,      (unsigned char )163,      (unsigned char )163,      (unsigned char )163, 
        (unsigned char )163,      (unsigned char )163,      (unsigned char )163,      (unsigned char )163, 
        (unsigned char )163,      (unsigned char )163,      (unsigned char )163,      (unsigned char )163, 
        (unsigned char )163,      (unsigned char )163,      (unsigned char )163,      (unsigned char )163, 
        (unsigned char )163,      (unsigned char )163,      (unsigned char )163,      (unsigned char )163, 
        (unsigned char )163,      (unsigned char )163,      (unsigned char )163,      (unsigned char )163, 
        (unsigned char )163,      (unsigned char )163,      (unsigned char )163,      (unsigned char )163, 
        (unsigned char )163,      (unsigned char )163,      (unsigned char )163,      (unsigned char )163, 
        (unsigned char )163,      (unsigned char )163,      (unsigned char )163,      (unsigned char )163, 
        (unsigned char )163,      (unsigned char )163,      (unsigned char )163,      (unsigned char )163, 
        (unsigned char )163,      (unsigned char )163,      (unsigned char )163,      (unsigned char )163, 
        (unsigned char )163,      (unsigned char )163,      (unsigned char )163,      (unsigned char )163, 
        (unsigned char )163,      (unsigned char )163,      (unsigned char )163,      (unsigned char )163, 
        (unsigned char )163,      (unsigned char )163,      (unsigned char )163,      (unsigned char )163, 
        (unsigned char )163,      (unsigned char )163,      (unsigned char )163,      (unsigned char )163, 
        (unsigned char )163,      (unsigned char )163,      (unsigned char )163,      (unsigned char )163, 
        (unsigned char )162,      (unsigned char )162,      (unsigned char )162,      (unsigned char )162, 
        (unsigned char )162,      (unsigned char )162,      (unsigned char )162,      (unsigned char )162, 
        (unsigned char )162,      (unsigned char )162,      (unsigned char )162,      (unsigned char )162, 
        (unsigned char )162,      (unsigned char )162,      (unsigned char )162,      (unsigned char )162, 
        (unsigned char )162,      (unsigned char )162,      (unsigned char )162,      (unsigned char )162, 
        (unsigned char )162,      (unsigned char )162,      (unsigned char )162,      (unsigned char )162, 
        (unsigned char )162,      (unsigned char )162,      (unsigned char )162,      (unsigned char )162, 
        (unsigned char )162,      (unsigned char )162,      (unsigned char )162,      (unsigned char )162, 
        (unsigned char )162,      (unsigned char )162,      (unsigned char )162,      (unsigned char )162, 
        (unsigned char )162,      (unsigned char )162,      (unsigned char )162,      (unsigned char )162, 
        (unsigned char )162,      (unsigned char )162,      (unsigned char )162,      (unsigned char )162, 
        (unsigned char )162,      (unsigned char )162,      (unsigned char )162,      (unsigned char )162, 
        (unsigned char )162,      (unsigned char )162,      (unsigned char )162,      (unsigned char )162, 
        (unsigned char )162,      (unsigned char )162,      (unsigned char )162,      (unsigned char )162, 
        (unsigned char )162,      (unsigned char )162,      (unsigned char )162,      (unsigned char )162, 
        (unsigned char )162,      (unsigned char )162,      (unsigned char )162,      (unsigned char )162, 
        (unsigned char )173,      (unsigned char )173,      (unsigned char )173,      (unsigned char )173, 
        (unsigned char )173,      (unsigned char )173,      (unsigned char )173,      (unsigned char )173, 
        (unsigned char )173,      (unsigned char )173,      (unsigned char )173,      (unsigned char )173, 
        (unsigned char )173,      (unsigned char )173,      (unsigned char )173,      (unsigned char )173, 
        (unsigned char )173,      (unsigned char )173,      (unsigned char )173,      (unsigned char )173, 
        (unsigned char )173,      (unsigned char )173,      (unsigned char )173,      (unsigned char )173, 
        (unsigned char )173,      (unsigned char )173,      (unsigned char )173,      (unsigned char )173, 
        (unsigned char )173,      (unsigned char )173,      (unsigned char )173,      (unsigned char )173, 
        (unsigned char )173,      (unsigned char )173,      (unsigned char )173,      (unsigned char )173, 
        (unsigned char )173,      (unsigned char )173,      (unsigned char )173,      (unsigned char )173, 
        (unsigned char )173,      (unsigned char )173,      (unsigned char )173,      (unsigned char )173, 
        (unsigned char )173,      (unsigned char )173,      (unsigned char )173,      (unsigned char )173, 
        (unsigned char )173,      (unsigned char )173,      (unsigned char )173,      (unsigned char )173, 
        (unsigned char )173,      (unsigned char )173,      (unsigned char )173,      (unsigned char )173, 
        (unsigned char )173,      (unsigned char )173,      (unsigned char )173,      (unsigned char )173, 
        (unsigned char )173,      (unsigned char )173,      (unsigned char )173,      (unsigned char )173, 
        (unsigned char )172,      (unsigned char )172,      (unsigned char )172,      (unsigned char )172, 
        (unsigned char )172,      (unsigned char )172,      (unsigned char )172,      (unsigned char )172, 
        (unsigned char )172,      (unsigned char )172,      (unsigned char )172,      (unsigned char )172, 
        (unsigned char )172,      (unsigned char )172,      (unsigned char )172,      (unsigned char )172, 
        (unsigned char )172,      (unsigned char )172,      (unsigned char )172,      (unsigned char )172, 
        (unsigned char )172,      (unsigned char )172,      (unsigned char )172,      (unsigned char )172, 
        (unsigned char )172,      (unsigned char )172,      (unsigned char )172,      (unsigned char )172, 
        (unsigned char )172,      (unsigned char )172,      (unsigned char )172,      (unsigned char )172, 
        (unsigned char )172,      (unsigned char )172,      (unsigned char )172,      (unsigned char )172, 
        (unsigned char )172,      (unsigned char )172,      (unsigned char )172,      (unsigned char )172, 
        (unsigned char )172,      (unsigned char )172,      (unsigned char )172,      (unsigned char )172, 
        (unsigned char )172,      (unsigned char )172,      (unsigned char )172,      (unsigned char )172, 
        (unsigned char )172,      (unsigned char )172,      (unsigned char )172,      (unsigned char )172, 
        (unsigned char )172,      (unsigned char )172,      (unsigned char )172,      (unsigned char )172, 
        (unsigned char )172,      (unsigned char )172,      (unsigned char )172,      (unsigned char )172, 
        (unsigned char )172,      (unsigned char )172,      (unsigned char )172,      (unsigned char )172, 
        (unsigned char )175,      (unsigned char )175,      (unsigned char )175,      (unsigned char )175, 
        (unsigned char )175,      (unsigned char )175,      (unsigned char )175,      (unsigned char )175, 
        (unsigned char )175,      (unsigned char )175,      (unsigned char )175,      (unsigned char )175, 
        (unsigned char )175,      (unsigned char )175,      (unsigned char )175,      (unsigned char )175, 
        (unsigned char )175,      (unsigned char )175,      (unsigned char )175,      (unsigned char )175, 
        (unsigned char )175,      (unsigned char )175,      (unsigned char )175,      (unsigned char )175, 
        (unsigned char )175,      (unsigned char )175,      (unsigned char )175,      (unsigned char )175, 
        (unsigned char )175,      (unsigned char )175,      (unsigned char )175,      (unsigned char )175, 
        (unsigned char )175,      (unsigned char )175,      (unsigned char )175,      (unsigned char )175, 
        (unsigned char )175,      (unsigned char )175,      (unsigned char )175,      (unsigned char )175, 
        (unsigned char )175,      (unsigned char )175,      (unsigned char )175,      (unsigned char )175, 
        (unsigned char )175,      (unsigned char )175,      (unsigned char )175,      (unsigned char )175, 
        (unsigned char )175,      (unsigned char )175,      (unsigned char )175,      (unsigned char )175, 
        (unsigned char )175,      (unsigned char )175,      (unsigned char )175,      (unsigned char )175, 
        (unsigned char )175,      (unsigned char )175,      (unsigned char )175,      (unsigned char )175, 
        (unsigned char )175,      (unsigned char )175,      (unsigned char )175,      (unsigned char )175, 
        (unsigned char )174,      (unsigned char )174,      (unsigned char )174,      (unsigned char )174, 
        (unsigned char )174,      (unsigned char )174,      (unsigned char )174,      (unsigned char )174, 
        (unsigned char )174,      (unsigned char )174,      (unsigned char )174,      (unsigned char )174, 
        (unsigned char )174,      (unsigned char )174,      (unsigned char )174,      (unsigned char )174, 
        (unsigned char )174,      (unsigned char )174,      (unsigned char )174,      (unsigned char )174, 
        (unsigned char )174,      (unsigned char )174,      (unsigned char )174,      (unsigned char )174, 
        (unsigned char )174,      (unsigned char )174,      (unsigned char )174,      (unsigned char )174, 
        (unsigned char )174,      (unsigned char )174,      (unsigned char )174,      (unsigned char )174, 
        (unsigned char )174,      (unsigned char )174,      (unsigned char )174,      (unsigned char )174, 
        (unsigned char )174,      (unsigned char )174,      (unsigned char )174,      (unsigned char )174, 
        (unsigned char )174,      (unsigned char )174,      (unsigned char )174,      (unsigned char )174, 
        (unsigned char )174,      (unsigned char )174,      (unsigned char )174,      (unsigned char )174, 
        (unsigned char )174,      (unsigned char )174,      (unsigned char )174,      (unsigned char )174, 
        (unsigned char )174,      (unsigned char )174,      (unsigned char )174,      (unsigned char )174, 
        (unsigned char )174,      (unsigned char )174,      (unsigned char )174,      (unsigned char )174, 
        (unsigned char )174,      (unsigned char )174,      (unsigned char )174,      (unsigned char )174, 
        (unsigned char )169,      (unsigned char )169,      (unsigned char )169,      (unsigned char )169, 
        (unsigned char )169,      (unsigned char )169,      (unsigned char )169,      (unsigned char )169, 
        (unsigned char )169,      (unsigned char )169,      (unsigned char )169,      (unsigned char )169, 
        (unsigned char )169,      (unsigned char )169,      (unsigned char )169,      (unsigned char )169, 
        (unsigned char )169,      (unsigned char )169,      (unsigned char )169,      (unsigned char )169, 
        (unsigned char )169,      (unsigned char )169,      (unsigned char )169,      (unsigned char )169, 
        (unsigned char )169,      (unsigned char )169,      (unsigned char )169,      (unsigned char )169, 
        (unsigned char )169,      (unsigned char )169,      (unsigned char )169,      (unsigned char )169, 
        (unsigned char )169,      (unsigned char )169,      (unsigned char )169,      (unsigned char )169, 
        (unsigned char )169,      (unsigned char )169,      (unsigned char )169,      (unsigned char )169, 
        (unsigned char )169,      (unsigned char )169,      (unsigned char )169,      (unsigned char )169, 
        (unsigned char )169,      (unsigned char )169,      (unsigned char )169,      (unsigned char )169, 
        (unsigned char )169,      (unsigned char )169,      (unsigned char )169,      (unsigned char )169, 
        (unsigned char )169,      (unsigned char )169,      (unsigned char )169,      (unsigned char )169, 
        (unsigned char )169,      (unsigned char )169,      (unsigned char )169,      (unsigned char )169, 
        (unsigned char )169,      (unsigned char )169,      (unsigned char )169,      (unsigned char )169, 
        (unsigned char )168,      (unsigned char )168,      (unsigned char )168,      (unsigned char )168, 
        (unsigned char )168,      (unsigned char )168,      (unsigned char )168,      (unsigned char )168, 
        (unsigned char )168,      (unsigned char )168,      (unsigned char )168,      (unsigned char )168, 
        (unsigned char )168,      (unsigned char )168,      (unsigned char )168,      (unsigned char )168, 
        (unsigned char )168,      (unsigned char )168,      (unsigned char )168,      (unsigned char )168, 
        (unsigned char )168,      (unsigned char )168,      (unsigned char )168,      (unsigned char )168, 
        (unsigned char )168,      (unsigned char )168,      (unsigned char )168,      (unsigned char )168, 
        (unsigned char )168,      (unsigned char )168,      (unsigned char )168,      (unsigned char )168, 
        (unsigned char )168,      (unsigned char )168,      (unsigned char )168,      (unsigned char )168, 
        (unsigned char )168,      (unsigned char )168,      (unsigned char )168,      (unsigned char )168, 
        (unsigned char )168,      (unsigned char )168,      (unsigned char )168,      (unsigned char )168, 
        (unsigned char )168,      (unsigned char )168,      (unsigned char )168,      (unsigned char )168, 
        (unsigned char )168,      (unsigned char )168,      (unsigned char )168,      (unsigned char )168, 
        (unsigned char )168,      (unsigned char )168,      (unsigned char )168,      (unsigned char )168, 
        (unsigned char )168,      (unsigned char )168,      (unsigned char )168,      (unsigned char )168, 
        (unsigned char )168,      (unsigned char )168,      (unsigned char )168,      (unsigned char )168, 
        (unsigned char )171,      (unsigned char )171,      (unsigned char )171,      (unsigned char )171, 
        (unsigned char )171,      (unsigned char )171,      (unsigned char )171,      (unsigned char )171, 
        (unsigned char )171,      (unsigned char )171,      (unsigned char )171,      (unsigned char )171, 
        (unsigned char )171,      (unsigned char )171,      (unsigned char )171,      (unsigned char )171, 
        (unsigned char )171,      (unsigned char )171,      (unsigned char )171,      (unsigned char )171, 
        (unsigned char )171,      (unsigned char )171,      (unsigned char )171,      (unsigned char )171, 
        (unsigned char )171,      (unsigned char )171,      (unsigned char )171,      (unsigned char )171, 
        (unsigned char )171,      (unsigned char )171,      (unsigned char )171,      (unsigned char )171, 
        (unsigned char )171,      (unsigned char )171,      (unsigned char )171,      (unsigned char )171, 
        (unsigned char )171,      (unsigned char )171,      (unsigned char )171,      (unsigned char )171, 
        (unsigned char )171,      (unsigned char )171,      (unsigned char )171,      (unsigned char )171, 
        (unsigned char )171,      (unsigned char )171,      (unsigned char )171,      (unsigned char )171, 
        (unsigned char )171,      (unsigned char )171,      (unsigned char )171,      (unsigned char )171, 
        (unsigned char )171,      (unsigned char )171,      (unsigned char )171,      (unsigned char )171, 
        (unsigned char )171,      (unsigned char )171,      (unsigned char )171,      (unsigned char )171, 
        (unsigned char )171,      (unsigned char )171,      (unsigned char )171,      (unsigned char )171, 
        (unsigned char )170,      (unsigned char )170,      (unsigned char )170,      (unsigned char )170, 
        (unsigned char )170,      (unsigned char )170,      (unsigned char )170,      (unsigned char )170, 
        (unsigned char )170,      (unsigned char )170,      (unsigned char )170,      (unsigned char )170, 
        (unsigned char )170,      (unsigned char )170,      (unsigned char )170,      (unsigned char )170, 
        (unsigned char )170,      (unsigned char )170,      (unsigned char )170,      (unsigned char )170, 
        (unsigned char )170,      (unsigned char )170,      (unsigned char )170,      (unsigned char )170, 
        (unsigned char )170,      (unsigned char )170,      (unsigned char )170,      (unsigned char )170, 
        (unsigned char )170,      (unsigned char )170,      (unsigned char )170,      (unsigned char )170, 
        (unsigned char )170,      (unsigned char )170,      (unsigned char )170,      (unsigned char )170, 
        (unsigned char )170,      (unsigned char )170,      (unsigned char )170,      (unsigned char )170, 
        (unsigned char )170,      (unsigned char )170,      (unsigned char )170,      (unsigned char )170, 
        (unsigned char )170,      (unsigned char )170,      (unsigned char )170,      (unsigned char )170, 
        (unsigned char )170,      (unsigned char )170,      (unsigned char )170,      (unsigned char )170, 
        (unsigned char )170,      (unsigned char )170,      (unsigned char )170,      (unsigned char )170, 
        (unsigned char )170,      (unsigned char )170,      (unsigned char )170,      (unsigned char )170, 
        (unsigned char )170,      (unsigned char )170,      (unsigned char )170,      (unsigned char )170, 
        (unsigned char )42};
#line 293 "/root/libsndfile/src/alaw.c"
__inline static void alaw2s_array(unsigned char *buffer , int count , short *ptr ) 
{ 


  {
  {
#line 294
  while (1) {
    while_continue: /* CIL Label */ ;
#line 294
    count --;
#line 294
    if (! (count >= 0)) {
#line 294
      goto while_break;
    }
#line 295
    *(ptr + count) = alaw_decode[(int )*(buffer + count)];
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 299 "/root/libsndfile/src/alaw.c"
__inline static void alaw2i_array(unsigned char *buffer , int count , int *ptr ) 
{ 


  {
  {
#line 300
  while (1) {
    while_continue: /* CIL Label */ ;
#line 300
    count --;
#line 300
    if (! (count >= 0)) {
#line 300
      goto while_break;
    }
#line 301
    *(ptr + count) = (int )alaw_decode[(int )*(buffer + count)] << 16;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 305 "/root/libsndfile/src/alaw.c"
__inline static void alaw2f_array(unsigned char *buffer , int count , float *ptr ,
                                  float normfact ) 
{ 


  {
  {
#line 306
  while (1) {
    while_continue: /* CIL Label */ ;
#line 306
    count --;
#line 306
    if (! (count >= 0)) {
#line 306
      goto while_break;
    }
#line 307
    *(ptr + count) = normfact * (float )((int )alaw_decode[(int )*(buffer + count)]);
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 311 "/root/libsndfile/src/alaw.c"
__inline static void alaw2d_array(unsigned char *buffer , int count , double *ptr ,
                                  double normfact ) 
{ 


  {
  {
#line 312
  while (1) {
    while_continue: /* CIL Label */ ;
#line 312
    count --;
#line 312
    if (! (count >= 0)) {
#line 312
      goto while_break;
    }
#line 313
    *(ptr + count) = normfact * (double )((int )alaw_decode[(int )*(buffer + count)]);
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 317 "/root/libsndfile/src/alaw.c"
__inline static void s2alaw_array(short const   *ptr , int count , unsigned char *buffer ) 
{ 


  {
  {
#line 318
  while (1) {
    while_continue: /* CIL Label */ ;
#line 318
    count --;
#line 318
    if (! (count >= 0)) {
#line 318
      goto while_break;
    }
#line 319
    if ((int )*(ptr + count) >= 0) {
#line 320
      *(buffer + count) = alaw_encode[(int )*(ptr + count) / 16];
    } else {
#line 322
      *(buffer + count) = (unsigned char )(127 & (int )alaw_encode[(int )*(ptr + count) / -16]);
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 327 "/root/libsndfile/src/alaw.c"
__inline static void i2alaw_array(int const   *ptr , int count , unsigned char *buffer ) 
{ 


  {
  {
#line 328
  while (1) {
    while_continue: /* CIL Label */ ;
#line 328
    count --;
#line 328
    if (! (count >= 0)) {
#line 328
      goto while_break;
    }
#line 329
    if (*(ptr + count) >= 0) {
#line 330
      *(buffer + count) = alaw_encode[*(ptr + count) >> 20];
    } else {
#line 332
      *(buffer + count) = (unsigned char )(127 & (int )alaw_encode[- *(ptr + count) >> 20]);
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 337 "/root/libsndfile/src/alaw.c"
__inline static void f2alaw_array(float const   *ptr , int count , unsigned char *buffer ,
                                  float normfact ) 
{ 
  long __cil_tmp5 ;
  long __cil_tmp6 ;

  {
  {
#line 338
  while (1) {
    while_continue: /* CIL Label */ ;
#line 338
    count --;
#line 338
    if (! (count >= 0)) {
#line 338
      goto while_break;
    }
#line 339
    if (*(ptr + count) >= (float )0) {
      {
#line 340
      *(buffer + count) = (unsigned char )lrintf(normfact * *(ptr + count));
      }
    } else {
      {
#line 342
      __cil_tmp6 = lrintf(normfact * *(ptr + count));
#line 342
      *(buffer + count) = (unsigned char )(127 & (int )alaw_encode[- __cil_tmp6]);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 347 "/root/libsndfile/src/alaw.c"
__inline static void d2alaw_array(double const   *ptr , int count , unsigned char *buffer ,
                                  double normfact ) 
{ 
  long __cil_tmp5 ;
  long __cil_tmp6 ;

  {
  {
#line 348
  while (1) {
    while_continue: /* CIL Label */ ;
#line 348
    count --;
#line 348
    if (! (count >= 0)) {
#line 348
      goto while_break;
    }
#line 349
    if (*(ptr + count) >= (double )0) {
      {
#line 350
      *(buffer + count) = (unsigned char )lrint(normfact * *(ptr + count));
      }
    } else {
      {
#line 352
      __cil_tmp6 = lrint(normfact * *(ptr + count));
#line 352
      *(buffer + count) = (unsigned char )(127 & (int )alaw_encode[- __cil_tmp6]);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 360 "/root/libsndfile/src/alaw.c"
static sf_count_t alaw_read_alaw2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp7 ;

  {
#line 362
  total = (sf_count_t )0;
#line 364
  bufferlen = (int )(sizeof(psf->u.ucbuf) / sizeof(psf->u.ucbuf[0]));
  {
#line 366
  while (1) {
    while_continue: /* CIL Label */ ;
#line 366
    if (! (len > 0L)) {
#line 366
      goto while_break;
    }
#line 367
    if (len < (long )bufferlen) {
#line 368
      bufferlen = (int )len;
    }
    {
#line 369
    __cil_tmp7 = psf_fread((unsigned char *)psf->u.ucbuf, (sf_count_t )1, (sf_count_t )bufferlen,
                           psf);
#line 369
    readcount = (int )__cil_tmp7;
#line 370
    alaw2s_array((unsigned char *)psf->u.ucbuf, readcount, ptr + total);
#line 371
    total += (long )readcount;
    }
#line 372
    if (readcount < bufferlen) {
#line 373
      goto while_break;
    }
#line 374
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 377
  return (total);
}
}
#line 381 "/root/libsndfile/src/alaw.c"
static sf_count_t alaw_read_alaw2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp7 ;

  {
#line 383
  total = (sf_count_t )0;
#line 385
  bufferlen = (int )(sizeof(psf->u.ucbuf) / sizeof(psf->u.ucbuf[0]));
  {
#line 387
  while (1) {
    while_continue: /* CIL Label */ ;
#line 387
    if (! (len > 0L)) {
#line 387
      goto while_break;
    }
#line 388
    if (len < (long )bufferlen) {
#line 389
      bufferlen = (int )len;
    }
    {
#line 390
    __cil_tmp7 = psf_fread((unsigned char *)psf->u.ucbuf, (sf_count_t )1, (sf_count_t )bufferlen,
                           psf);
#line 390
    readcount = (int )__cil_tmp7;
#line 391
    alaw2i_array((unsigned char *)psf->u.ucbuf, readcount, ptr + total);
#line 392
    total += (long )readcount;
    }
#line 393
    if (readcount < bufferlen) {
#line 394
      goto while_break;
    }
#line 395
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 398
  return (total);
}
}
#line 402 "/root/libsndfile/src/alaw.c"
static sf_count_t alaw_read_alaw2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  sf_count_t __cil_tmp9 ;

  {
#line 404
  total = (sf_count_t )0;
#line 407
  if (psf->norm_float == 1) {
#line 407
    tmp = 1. / (double )((float )32768);
  } else {
#line 407
    tmp = 1.;
  }
#line 407
  normfact = (float )tmp;
#line 409
  bufferlen = (int )(sizeof(psf->u.ucbuf) / sizeof(psf->u.ucbuf[0]));
  {
#line 411
  while (1) {
    while_continue: /* CIL Label */ ;
#line 411
    if (! (len > 0L)) {
#line 411
      goto while_break;
    }
#line 412
    if (len < (long )bufferlen) {
#line 413
      bufferlen = (int )len;
    }
    {
#line 414
    __cil_tmp9 = psf_fread((unsigned char *)psf->u.ucbuf, (sf_count_t )1, (sf_count_t )bufferlen,
                           psf);
#line 414
    readcount = (int )__cil_tmp9;
#line 415
    alaw2f_array((unsigned char *)psf->u.ucbuf, readcount, ptr + total, normfact);
#line 416
    total += (long )readcount;
    }
#line 417
    if (readcount < bufferlen) {
#line 418
      goto while_break;
    }
#line 419
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 422
  return (total);
}
}
#line 426 "/root/libsndfile/src/alaw.c"
static sf_count_t alaw_read_alaw2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  sf_count_t __cil_tmp9 ;

  {
#line 428
  total = (sf_count_t )0;
#line 431
  if (psf->norm_double) {
#line 431
    tmp = 1. / (double )32768;
  } else {
#line 431
    tmp = 1.;
  }
#line 431
  normfact = tmp;
#line 432
  bufferlen = (int )(sizeof(psf->u.ucbuf) / sizeof(psf->u.ucbuf[0]));
  {
#line 434
  while (1) {
    while_continue: /* CIL Label */ ;
#line 434
    if (! (len > 0L)) {
#line 434
      goto while_break;
    }
#line 435
    if (len < (long )bufferlen) {
#line 436
      bufferlen = (int )len;
    }
    {
#line 437
    __cil_tmp9 = psf_fread((unsigned char *)psf->u.ucbuf, (sf_count_t )1, (sf_count_t )bufferlen,
                           psf);
#line 437
    readcount = (int )__cil_tmp9;
#line 438
    alaw2d_array((unsigned char *)psf->u.ucbuf, readcount, ptr + total, normfact);
#line 439
    total += (long )readcount;
    }
#line 440
    if (readcount < bufferlen) {
#line 441
      goto while_break;
    }
#line 442
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 445
  return (total);
}
}
#line 452 "/root/libsndfile/src/alaw.c"
static sf_count_t alaw_write_s2alaw(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp7 ;

  {
#line 454
  total = (sf_count_t )0;
#line 456
  bufferlen = (int )(sizeof(psf->u.ucbuf) / sizeof(psf->u.ucbuf[0]));
  {
#line 458
  while (1) {
    while_continue: /* CIL Label */ ;
#line 458
    if (! (len > 0L)) {
#line 458
      goto while_break;
    }
#line 459
    if (len < (long )bufferlen) {
#line 460
      bufferlen = (int )len;
    }
    {
#line 461
    s2alaw_array(ptr + total, bufferlen, (unsigned char *)psf->u.ucbuf);
#line 462
    __cil_tmp7 = psf_fwrite((unsigned char *)psf->u.ucbuf, (sf_count_t )1, (sf_count_t )bufferlen,
                            psf);
#line 462
    writecount = (int )__cil_tmp7;
#line 463
    total += (long )writecount;
    }
#line 464
    if (writecount < bufferlen) {
#line 465
      goto while_break;
    }
#line 466
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 469
  return (total);
}
}
#line 473 "/root/libsndfile/src/alaw.c"
static sf_count_t alaw_write_i2alaw(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp7 ;

  {
#line 475
  total = (sf_count_t )0;
#line 477
  bufferlen = (int )(sizeof(psf->u.ucbuf) / sizeof(psf->u.ucbuf[0]));
  {
#line 479
  while (1) {
    while_continue: /* CIL Label */ ;
#line 479
    if (! (len > 0L)) {
#line 479
      goto while_break;
    }
#line 480
    if (len < (long )bufferlen) {
#line 481
      bufferlen = (int )len;
    }
    {
#line 482
    i2alaw_array(ptr + total, bufferlen, (unsigned char *)psf->u.ucbuf);
#line 483
    __cil_tmp7 = psf_fwrite((unsigned char *)psf->u.ucbuf, (sf_count_t )1, (sf_count_t )bufferlen,
                            psf);
#line 483
    writecount = (int )__cil_tmp7;
#line 484
    total += (long )writecount;
    }
#line 485
    if (writecount < bufferlen) {
#line 486
      goto while_break;
    }
#line 487
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 490
  return (total);
}
}
#line 494 "/root/libsndfile/src/alaw.c"
static sf_count_t alaw_write_f2alaw(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  sf_count_t __cil_tmp9 ;

  {
#line 496
  total = (sf_count_t )0;
#line 499
  if (psf->norm_float == 1) {
#line 499
    tmp = (1. * (double )32767) / 16.;
  } else {
#line 499
    tmp = 1. / (double )16;
  }
#line 499
  normfact = (float )tmp;
#line 501
  bufferlen = (int )(sizeof(psf->u.ucbuf) / sizeof(psf->u.ucbuf[0]));
  {
#line 503
  while (1) {
    while_continue: /* CIL Label */ ;
#line 503
    if (! (len > 0L)) {
#line 503
      goto while_break;
    }
#line 504
    if (len < (long )bufferlen) {
#line 505
      bufferlen = (int )len;
    }
    {
#line 506
    f2alaw_array(ptr + total, bufferlen, (unsigned char *)psf->u.ucbuf, normfact);
#line 507
    __cil_tmp9 = psf_fwrite((unsigned char *)psf->u.ucbuf, (sf_count_t )1, (sf_count_t )bufferlen,
                            psf);
#line 507
    writecount = (int )__cil_tmp9;
#line 508
    total += (long )writecount;
    }
#line 509
    if (writecount < bufferlen) {
#line 510
      goto while_break;
    }
#line 511
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 514
  return (total);
}
}
#line 518 "/root/libsndfile/src/alaw.c"
static sf_count_t alaw_write_d2alaw(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  sf_count_t __cil_tmp9 ;

  {
#line 520
  total = (sf_count_t )0;
#line 523
  if (psf->norm_double) {
#line 523
    tmp = (1. * (double )32767) / 16.;
  } else {
#line 523
    tmp = 1. / 16.;
  }
#line 523
  normfact = tmp;
#line 525
  bufferlen = (int )(sizeof(psf->u.ucbuf) / sizeof(psf->u.ucbuf[0]));
  {
#line 527
  while (1) {
    while_continue: /* CIL Label */ ;
#line 527
    if (! (len > 0L)) {
#line 527
      goto while_break;
    }
#line 528
    if (len < (long )bufferlen) {
#line 529
      bufferlen = (int )len;
    }
    {
#line 530
    d2alaw_array(ptr + total, bufferlen, (unsigned char *)psf->u.ucbuf, normfact);
#line 531
    __cil_tmp9 = psf_fwrite((unsigned char *)psf->u.ucbuf, (sf_count_t )1, (sf_count_t )bufferlen,
                            psf);
#line 531
    writecount = (int )__cil_tmp9;
#line 532
    total += (long )writecount;
    }
#line 533
    if (writecount < bufferlen) {
#line 534
      goto while_break;
    }
#line 535
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 538
  return (total);
}
}
#line 55 "/root/libsndfile/src/rf64.c"
static int rf64_read_header(SF_PRIVATE *psf ) ;
#line 56
static int rf64_write_header(SF_PRIVATE *psf , int calc_length ) ;
#line 57
static int rf64_close(SF_PRIVATE *psf ) ;
#line 64 "/root/libsndfile/src/rf64.c"
int rf64_open(SF_PRIVATE *psf ) 
{ 
  WAV_PRIVATE *wpriv ;
  int subformat ;
  int error ;
  void *__cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;

  {
  {
#line 66
  error = 0;
#line 68
  wpriv = (WAV_PRIVATE *)calloc((unsigned long )1, sizeof(WAV_PRIVATE ));
  }
#line 68
  if (wpriv == (void *)0) {
#line 69
    return (16);
  }
#line 70
  psf->container_data = wpriv;
#line 73
  psf->endian = 268435456;
#line 76
  if (psf->mode == 16) {
    _L: /* CIL Label */ 
    {
#line 77
    error = rf64_read_header(psf);
    }
#line 77
    if (error != 0) {
#line 78
      return (error);
    }
  } else
#line 76
  if (psf->mode == 48) {
#line 76
    if (psf->filelength > 0L) {
#line 76
      goto _L;
    }
  }

#line 81
  if ((psf->sf.format & 268369920) != 2228224) {
#line 82
    return (1);
  }
#line 84
  subformat = psf->sf.format & 65535;
#line 86
  if (psf->mode == 32) {
    _L___9: /* CIL Label */ 
#line 87
    if (psf->is_pipe) {
#line 88
      return (28);
    }
    {
#line 90
    psf->blockwidth = psf->bytewidth * psf->sf.channels;
#line 92
    error = rf64_write_header(psf, 0);
    }
#line 92
    if (error) {
#line 93
      return (error);
    }
#line 95
    psf->write_header = & rf64_write_header;
  } else
#line 86
  if (psf->mode == 48) {
#line 86
    goto _L___9;
  }
#line 98
  psf->container_close = & rf64_close;
  {
#line 104
  if (subformat == 4) {
#line 104
    goto case_4;
  }
#line 104
  if (subformat == 3) {
#line 104
    goto case_4;
  }
#line 104
  if (subformat == 2) {
#line 104
    goto case_4;
  }
#line 104
  if (subformat == 5) {
#line 104
    goto case_4;
  }
#line 108
  if (subformat == 16) {
#line 108
    goto case_16;
  }
#line 112
  if (subformat == 17) {
#line 112
    goto case_17;
  }
#line 117
  if (subformat == 6) {
#line 117
    goto case_6;
  }
#line 121
  if (subformat == 7) {
#line 121
    goto case_7;
  }
#line 127
  goto switch_default;
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_5: /* CIL Label */ 
  {
#line 105
  error = pcm_init(psf);
  }
#line 106
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 109
  error = ulaw_init(psf);
  }
#line 110
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 113
  error = alaw_init(psf);
  }
#line 114
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 118
  error = float32_init(psf);
  }
#line 119
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 122
  error = double64_init(psf);
  }
#line 123
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 127
  return (17);
  switch_break: /* CIL Label */ ;
  }

#line 130
  return (error);
}
}
#line 137 "/root/libsndfile/src/rf64.c"
static int rf64_read_header(SF_PRIVATE *psf ) 
{ 
  WAV_PRIVATE *wpriv ;
  sf_count_t riff_size ;
  sf_count_t data_size ;
  unsigned int size32 ;
  int marker ;
  int marks[2] ;
  int error ;
  int done ;
  int __cil_tmp10 ;
  unsigned short const   **__cil_tmp11 ;
  unsigned short const   **__cil_tmp12 ;
  unsigned short const   **__cil_tmp13 ;
  unsigned short const   **__cil_tmp14 ;
  sf_count_t __cil_tmp15 ;
  sf_count_t __cil_tmp16 ;
  sf_count_t __cil_tmp17 ;

  {
#line 141
  done = 0;
#line 143
  wpriv = psf->container_data;
#line 143
  if (wpriv == (void *)0) {
#line 144
    return (29);
  }
  {
#line 147
  psf_binheader_readf(psf, "pmmm", 0, & marker, (int *)marks, (int *)marks + 1);
  }
#line 148
  if (marker != (((82 | (70 << 8)) | (54 << 16)) | (52 << 24))) {
#line 149
    return (156);
  } else
#line 148
  if (marks[0] != (((255 | (255 << 8)) | (255 << 16)) | (255 << 24))) {
#line 149
    return (156);
  } else
#line 148
  if (marks[1] != (((87 | (65 << 8)) | (86 << 16)) | (69 << 24))) {
#line 149
    return (156);
  }
  {
#line 151
  psf_log_printf(psf, "%M\n  %M\n\221", ((82 | (70 << 8)) | (54 << 16)) | (52 << 24),
                 ((87 | (65 << 8)) | (86 << 16)) | (69 << 24));
  }
  {
#line 153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 153
    if (! (! done)) {
#line 153
      goto while_break;
    }
    {
#line 154
    psf_binheader_readf(psf, "em4\372\036V", & marker, & size32);
    }
    {
#line 157
    if (marker == (((100 | (115 << 8)) | (54 << 16)) | (52 << 24))) {
#line 157
      goto case_exp;
    }
#line 175
    if (marker == (((100 | (97 << 8)) | (116 << 16)) | (97 << 24))) {
#line 175
      goto case_exp___0;
    }
#line 181
    goto switch_default;
    case_exp: /* CIL Label */ 
    {
#line 158
    psf_log_printf(psf, "%M : %u\n\230\001", marker, size32);
    }
    {
#line 160
    psf_binheader_readf(psf, "888\372\036V", & riff_size, & data_size, & psf->sf.frames);
#line 161
    psf_log_printf(psf, "  Riff size : %D\n  Data size : %D\n  Frames    : %D\n",
                   riff_size, data_size, psf->sf.frames);
#line 164
    psf_binheader_readf(psf, "4", & size32);
#line 165
    psf_log_printf(psf, "  Table len : %u\n", size32);
#line 167
    psf_binheader_readf(psf, "jm4\372\036V", size32 + 4U, & marker, & size32);
#line 168
    psf_log_printf(psf, "%M : %u\n\230\001", marker, size32);
#line 170
    error = wav_w64_read_fmt_chunk(psf, (int )size32);
    }
#line 170
    if (error != 0) {
#line 171
      return (error);
    }
#line 172
    psf->sf.format = 2228224 | (psf->sf.format & 65535);
#line 173
    goto switch_break;
    case_exp___0: /* CIL Label */ 
    {
#line 176
    psf_log_printf(psf, "%M : %x\n\230\001", marker, size32);
    }
#line 177
    psf->dataoffset = (sf_count_t )psf->headindex;
#line 178
    done = 1;
#line 179
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 182
    __cil_tmp14 = __ctype_b_loc();
    }
    {
#line 182
    __cil_tmp13 = __ctype_b_loc();
    }
    {
#line 182
    __cil_tmp12 = __ctype_b_loc();
    }
    {
#line 182
    __cil_tmp11 = __ctype_b_loc();
    }
#line 182
    if ((int )*(*__cil_tmp11 + (int )((marker >> 24) & 255)) & 16384) {
#line 182
      if ((int )*(*__cil_tmp12 + (int )((marker >> 16) & 255)) & 16384) {
#line 182
        if ((int )*(*__cil_tmp13 + (int )((marker >> 8) & 255)) & 16384) {
#line 182
          if ((int )*(*__cil_tmp14 + (int )(marker & 255)) & 16384) {
            {
#line 184
            psf_binheader_readf(psf, "4", & size32);
#line 185
            psf_log_printf(psf, "*** %M : %d (unknown marker)\n", marker, size32);
            }
#line 186
            if (size32 < 8U) {
#line 187
              done = 1;
            }
            {
#line 188
            psf_binheader_readf(psf, "j", size32);
            }
#line 189
            goto switch_break;
          }
        }
      }
    }
    {
#line 191
    __cil_tmp15 = psf_ftell(psf);
    }
#line 191
    if (__cil_tmp15 & 3L) {
      {
#line 192
      psf_log_printf(psf, "  Unknown chunk marker at position %d. Resynching.\n",
                     size32 - 4U);
#line 193
      psf_binheader_readf(psf, "j", - 3);
      }
#line 194
      goto switch_break;
    }
    {
#line 196
    __cil_tmp16 = psf_ftell(psf);
#line 196
    psf_log_printf(psf, "*** Unknown chunk marker (%X) at position %D. Exiting parser.\n",
                   marker, __cil_tmp16 - 4L);
#line 197
    done = 1;
    }
#line 198
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 201
    __cil_tmp17 = psf_ftell(psf);
    }
#line 201
    if (__cil_tmp17 >= psf->filelength - (long )((int )sizeof(marker))) {
      {
#line 202
      psf_log_printf(psf, "End\n");
      }
#line 203
      goto while_break;
    }

  }
  while_break: /* CIL Label */ ;
  }

#line 207
  return (0);
}
}
#line 211 "/root/libsndfile/src/rf64.c"
static EXT_SUBFORMAT MSGUID_SUBTYPE_PCM  =    {(unsigned int )1, (unsigned short )0, (unsigned short )16, {(char )128, (char )0,
                                                                (char )0, (char )170,
                                                                (char )0, (char )56,
                                                                (char )155, (char )113}};
#line 215 "/root/libsndfile/src/rf64.c"
static EXT_SUBFORMAT MSGUID_SUBTYPE_MS_ADPCM  =    {(unsigned int )2, (unsigned short )0, (unsigned short )16, {(char )128, (char )0,
                                                                (char )0, (char )170,
                                                                (char )0, (char )56,
                                                                (char )155, (char )113}};
#line 219 "/root/libsndfile/src/rf64.c"
static EXT_SUBFORMAT MSGUID_SUBTYPE_IEEE_FLOAT  =    {(unsigned int )3, (unsigned short )0, (unsigned short )16, {(char )128, (char )0,
                                                                (char )0, (char )170,
                                                                (char )0, (char )56,
                                                                (char )155, (char )113}};
#line 223 "/root/libsndfile/src/rf64.c"
static EXT_SUBFORMAT MSGUID_SUBTYPE_ALAW  =    {(unsigned int )6, (unsigned short )0, (unsigned short )16, {(char )128, (char )0,
                                                                (char )0, (char )170,
                                                                (char )0, (char )56,
                                                                (char )155, (char )113}};
#line 227 "/root/libsndfile/src/rf64.c"
static EXT_SUBFORMAT MSGUID_SUBTYPE_MULAW  =    {(unsigned int )7, (unsigned short )0, (unsigned short )16, {(char )128, (char )0,
                                                                (char )0, (char )170,
                                                                (char )0, (char )56,
                                                                (char )155, (char )113}};
#line 235 "/root/libsndfile/src/rf64.c"
static EXT_SUBFORMAT MSGUID_SUBTYPE_AMBISONIC_B_FORMAT_PCM  =    {(unsigned int )1, (unsigned short )1825, (unsigned short )4563, {(char )134, (char )68,
                                                                     (char )200, (char )193,
                                                                     (char )202, (char )0,
                                                                     (char )0, (char )0}};
#line 239 "/root/libsndfile/src/rf64.c"
static EXT_SUBFORMAT MSGUID_SUBTYPE_AMBISONIC_B_FORMAT_IEEE_FLOAT  =    {(unsigned int )3, (unsigned short )1825, (unsigned short )4563, {(char )134, (char )68,
                                                                     (char )200, (char )193,
                                                                     (char )202, (char )0,
                                                                     (char )0, (char )0}};
#line 245 "/root/libsndfile/src/rf64.c"
static int wavex_write_fmt_chunk(SF_PRIVATE *psf ) 
{ 
  WAV_PRIVATE *wpriv ;
  int subformat ;
  int fmt_size ;
  int add_fact_chunk ;
  EXT_SUBFORMAT *tmp ;
  EXT_SUBFORMAT *tmp___0 ;

  {
#line 247
  add_fact_chunk = 0;
#line 249
  wpriv = psf->container_data;
#line 249
  if (wpriv == (void *)0) {
#line 250
    return (29);
  }
#line 252
  subformat = psf->sf.format & 65535;
  {
#line 263
  if (subformat == 17) {
#line 263
    goto case_17;
  }
#line 263
  if (subformat == 16) {
#line 263
    goto case_17;
  }
#line 263
  if (subformat == 7) {
#line 263
    goto case_17;
  }
#line 263
  if (subformat == 6) {
#line 263
    goto case_17;
  }
#line 263
  if (subformat == 4) {
#line 263
    goto case_17;
  }
#line 263
  if (subformat == 3) {
#line 263
    goto case_17;
  }
#line 263
  if (subformat == 2) {
#line 263
    goto case_17;
  }
#line 263
  if (subformat == 5) {
#line 263
    goto case_17;
  }
#line 291
  if (subformat == 1) {
#line 291
    goto case_1;
  }
#line 295
  if (subformat == 2) {
#line 295
    goto case_2___0;
  }
#line 299
  if (subformat == 4) {
#line 299
    goto case_4___0;
  }
#line 303
  if (subformat == 6) {
#line 303
    goto case_6___0;
  }
#line 307
  if (subformat == 8) {
#line 307
    goto case_8;
  }
#line 319
  goto switch_default___0;
  case_17: /* CIL Label */ 
  case_16: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 264
  fmt_size = 40;
  {
#line 267
  psf_binheader_writef(psf, "4224\036V", fmt_size, 65534, psf->sf.channels, psf->sf.samplerate);
#line 269
  psf_binheader_writef(psf, "4U\270\372\036V", (psf->sf.samplerate * psf->bytewidth) * psf->sf.channels);
#line 271
  psf_binheader_writef(psf, "22", psf->bytewidth * psf->sf.channels, psf->bytewidth * 8);
#line 274
  psf_binheader_writef(psf, "2\245\270\372\036V", 22);
#line 277
  psf_binheader_writef(psf, "2K\270\372\036V", psf->bytewidth * 8);
  }
#line 282
  if (wpriv->wavex_ambisonic != 64) {
    {
#line 283
    psf_binheader_writef(psf, "4", 0);
    }
  } else {
    {
#line 291
    if (psf->sf.channels == 1) {
#line 291
      goto case_1;
    }
#line 295
    if (psf->sf.channels == 2) {
#line 295
      goto case_2___0;
    }
#line 299
    if (psf->sf.channels == 4) {
#line 299
      goto case_4___0;
    }
#line 303
    if (psf->sf.channels == 6) {
#line 303
      goto case_6___0;
    }
#line 307
    if (psf->sf.channels == 8) {
#line 307
      goto case_8;
    }
#line 311
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 292
    psf_binheader_writef(psf, "4D\270\372\036V", 4);
    }
#line 293
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
    {
#line 296
    psf_binheader_writef(psf, "4\022\242\372\036V", 3);
    }
#line 297
    goto switch_break___0;
    case_4___0: /* CIL Label */ 
    {
#line 300
    psf_binheader_writef(psf, "4C\270\372\036V", 51);
    }
#line 301
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
    {
#line 304
    psf_binheader_writef(psf, "4B\270\372\036V", 63);
    }
#line 305
    goto switch_break___0;
    case_8: /* CIL Label */ 
    {
#line 308
    psf_binheader_writef(psf, "4?\270\372\036V", 255);
    }
#line 309
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 312
    psf_binheader_writef(psf, "4B\270\372\036V", 0);
    }
#line 313
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }

  }

#line 316
  goto switch_break;
  switch_default___0: /* CIL Label */ 
  case_19: /* CIL Label */ 
#line 320
  return (17);
  switch_break: /* CIL Label */ ;
  }

  {
#line 329
  if (subformat == 4) {
#line 329
    goto case_4___1;
  }
#line 329
  if (subformat == 3) {
#line 329
    goto case_4___1;
  }
#line 329
  if (subformat == 2) {
#line 329
    goto case_4___1;
  }
#line 329
  if (subformat == 5) {
#line 329
    goto case_4___1;
  }
#line 335
  if (subformat == 7) {
#line 335
    goto case_7___0;
  }
#line 335
  if (subformat == 6) {
#line 335
    goto case_7___0;
  }
#line 340
  if (subformat == 16) {
#line 340
    goto case_16___0;
  }
#line 344
  if (subformat == 17) {
#line 344
    goto case_17___0;
  }
#line 356
  goto switch_default___1;
  case_4___1: /* CIL Label */ 
  case_3___0: /* CIL Label */ 
  case_2___1: /* CIL Label */ 
  case_5___0: /* CIL Label */ 
#line 330
  if (wpriv->wavex_ambisonic == 64) {
#line 330
    tmp = & MSGUID_SUBTYPE_PCM;
  } else {
#line 330
    tmp = & MSGUID_SUBTYPE_AMBISONIC_B_FORMAT_PCM;
  }
  {
#line 330
  wavex_write_guid(psf, tmp);
  }
#line 332
  goto switch_break___1;
  case_7___0: /* CIL Label */ 
  case_6___1: /* CIL Label */ 
#line 336
  if (wpriv->wavex_ambisonic == 64) {
#line 336
    tmp___0 = & MSGUID_SUBTYPE_IEEE_FLOAT;
  } else {
#line 336
    tmp___0 = & MSGUID_SUBTYPE_AMBISONIC_B_FORMAT_IEEE_FLOAT;
  }
  {
#line 336
  wavex_write_guid(psf, tmp___0);
  }
#line 338
  goto switch_break___1;
  case_16___0: /* CIL Label */ 
  {
#line 341
  wavex_write_guid(psf, & MSGUID_SUBTYPE_MULAW);
  }
#line 342
  goto switch_break___1;
  case_17___0: /* CIL Label */ 
  {
#line 345
  wavex_write_guid(psf, & MSGUID_SUBTYPE_ALAW);
  }
#line 346
  goto switch_break___1;
  switch_default___1: /* CIL Label */ 
#line 356
  return (17);
  switch_break___1: /* CIL Label */ ;
  }

#line 359
  if (add_fact_chunk) {
    {
#line 360
    psf_binheader_writef(psf, "tm48\036V", ((102 | (97 << 8)) | (99 << 16)) | (116 << 24),
                         4, psf->sf.frames);
    }
  }
#line 362
  return (0);
}
}
#line 367 "/root/libsndfile/src/rf64.c"
static int rf64_write_header(SF_PRIVATE *psf , int calc_length ) 
{ 
  sf_count_t current ;
  int error ;
  int has_data ;
  sf_count_t __cil_tmp6 ;
  sf_count_t __cil_tmp7 ;
  int __cil_tmp8 ;

  {
#line 369
  error = 0;
  {
#line 369
  has_data = 0;
#line 371
  current = psf_ftell(psf);
  }
#line 373
  if (psf->dataoffset > 0L) {
#line 373
    if (current > psf->dataoffset) {
#line 374
      has_data = 1;
    }
  }
#line 376
  if (calc_length) {
    {
#line 377
    psf->filelength = psf_get_filelen(psf);
#line 379
    psf->datalength = psf->filelength - psf->dataoffset;
    }
#line 381
    if (psf->dataend) {
#line 382
      psf->datalength -= psf->filelength - psf->dataend;
    }
#line 384
    if (psf->bytewidth > 0) {
#line 385
      psf->sf.frames = psf->datalength / (long )(psf->bytewidth * psf->sf.channels);
    }
  }
  {
#line 389
  psf->header[0] = (unsigned char )0;
#line 390
  psf->headindex = 0;
#line 391
  psf_fseek(psf, (sf_count_t )0, 0);
#line 393
  psf_binheader_writef(psf, "em4m", ((82 | (70 << 8)) | (54 << 16)) | (52 << 24),
                       4294967295U, ((87 | (65 << 8)) | (86 << 16)) | (69 << 24));
#line 395
  psf_binheader_writef(psf, "m488844", ((100 | (115 << 8)) | (54 << 16)) | (52 << 24),
                       32, psf->filelength, psf->datalength, psf->sf.frames, 0, 6029412);
#line 398
  psf_binheader_writef(psf, "m\352\270\372\036V", ((102 | (109 << 8)) | (116 << 16)) | (32 << 24));
  }
  {
#line 402
  if ((psf->sf.format & 268369920) == 65536) {
#line 402
    goto case_65536;
  }
#line 408
  if ((psf->sf.format & 268369920) == 2228224) {
#line 408
    goto case_2228224;
  }
#line 408
  if ((psf->sf.format & 268369920) == 1245184) {
#line 408
    goto case_2228224;
  }
#line 413
  goto switch_default;
  case_65536: /* CIL Label */ 
  {
#line 403
  psf_log_printf(psf, "ooops SF_FORMAT_WAV\n\036V");
  }
#line 404
  return (17);
#line 405
  goto switch_break;
  case_2228224: /* CIL Label */ 
  case_1245184: /* CIL Label */ 
  {
#line 409
  error = wavex_write_fmt_chunk(psf);
  }
#line 409
  if (error != 0) {
#line 410
    return (error);
  }
#line 411
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 414
  return (17);
  switch_break: /* CIL Label */ ;
  }
  {
#line 465
  psf_binheader_writef(psf, "m4\270\372\036V", ((100 | (97 << 8)) | (116 << 16)) | (97 << 24),
                       4294967295U);
#line 467
  psf_fwrite((unsigned char *)psf->header, (sf_count_t )psf->headindex, (sf_count_t )1,
             psf);
  }
#line 468
  if (psf->error) {
#line 469
    return (psf->error);
  }
#line 471
  if (has_data) {
#line 471
    if (psf->dataoffset != (long )psf->headindex) {
      {
#line 472
      printf("Oooops : has_data && psf->dataoffset != psf->headindex\n");
#line 473
      psf->error = 29;
      }
#line 473
      return (psf->error);
    }
  }
#line 476
  psf->dataoffset = (sf_count_t )psf->headindex;
#line 478
  if (! has_data) {
    {
#line 479
    psf_fseek(psf, psf->dataoffset, 0);
    }
  } else
#line 480
  if (current > 0L) {
    {
#line 481
    psf_fseek(psf, current, 0);
    }
  }
#line 483
  return (psf->error);
}
}
#line 487 "/root/libsndfile/src/rf64.c"
static int rf64_close(SF_PRIVATE *psf ) 
{ 


  {
#line 489
  if (psf->mode == 32) {
    {
    {
#line 492
    (*(psf->write_header))(psf, 1);
    }
    }
  } else
#line 489
  if (psf->mode == 48) {
    {
    {
#line 492
    (*(psf->write_header))(psf, 1);
    }
    }
  }

#line 495
  return (0);
}
}
#line 55 "/root/libsndfile/src/mpc2k.c"
static int mpc2k_close(SF_PRIVATE *psf ) ;
#line 57
static int mpc2k_write_header(SF_PRIVATE *psf , int calc_length ) ;
#line 58
static int mpc2k_read_header(SF_PRIVATE *psf ) ;
#line 65 "/root/libsndfile/src/mpc2k.c"
int mpc2k_open(SF_PRIVATE *psf ) 
{ 
  int subformat ;
  int error ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 67
  error = 0;
#line 69
  if (psf->mode == 16) {
    _L: /* CIL Label */ 
    {
#line 70
    error = mpc2k_read_header(psf);
    }
#line 70
    if (error) {
#line 71
      return (error);
    }
  } else
#line 69
  if (psf->mode == 48) {
#line 69
    if (psf->filelength > 0L) {
#line 69
      goto _L;
    }
  }

#line 74
  if ((psf->sf.format & 268369920) != 2162688) {
#line 75
    return (1);
  }
#line 77
  subformat = psf->sf.format & 65535;
#line 79
  if (psf->mode == 32) {
    _L___10: /* CIL Label */ 
    {
#line 80
    __cil_tmp5 = mpc2k_write_header(psf, 0);
    }
#line 80
    if (__cil_tmp5) {
#line 81
      return (psf->error);
    }
#line 83
    psf->write_header = & mpc2k_write_header;
  } else
#line 79
  if (psf->mode == 48) {
#line 79
    goto _L___10;
  }
  {
#line 86
  psf->container_close = & mpc2k_close;
#line 88
  psf->blockwidth = psf->bytewidth * psf->sf.channels;
#line 90
  error = pcm_init(psf);
  }
#line 92
  return (error);
}
}
#line 99 "/root/libsndfile/src/mpc2k.c"
static int mpc2k_close(SF_PRIVATE *psf ) 
{ 


  {
#line 101
  if (psf->mode == 32) {
    {
    {
#line 102
    mpc2k_write_header(psf, 1);
    }
    }
  } else
#line 101
  if (psf->mode == 48) {
    {
    {
#line 102
    mpc2k_write_header(psf, 1);
    }
    }
  }
#line 104
  return (0);
}
}
#line 108 "/root/libsndfile/src/mpc2k.c"
static int mpc2k_write_header(SF_PRIVATE *psf , int calc_length ) 
{ 
  char sample_name[18] ;
  sf_count_t current ;
  sf_count_t __cil_tmp5 ;
  sf_count_t __cil_tmp6 ;
  size_t __cil_tmp7 ;

  {
#line 112
  if (psf->pipeoffset > 0L) {
#line 113
    return (0);
  }
  {
#line 115
  current = psf_ftell(psf);
  }
#line 117
  if (calc_length) {
    {
#line 118
    psf->filelength = psf_get_filelen(psf);
#line 120
    psf->dataoffset = (sf_count_t )42;
#line 121
    psf->datalength = psf->filelength - psf->dataoffset;
#line 123
    psf->sf.frames = psf->datalength / (long )(psf->bytewidth * psf->sf.channels);
    }
  }
#line 127
  psf->header[0] = (unsigned char )0;
#line 128
  psf->headindex = 0;
#line 134
  if (psf->is_pipe == 0) {
    {
#line 135
    psf_fseek(psf, (sf_count_t )0, 0);
    }
  }
  {
#line 137
  snprintf((char *)sample_name, sizeof(sample_name), "%s                    ", (char *)psf->filename);
#line 139
  __cil_tmp7 = make_size_t(17);
#line 139
  psf_binheader_writef(psf, "e11b", 1, 4, (char *)sample_name, __cil_tmp7);
#line 140
  psf_binheader_writef(psf, "e111", 100, 0, (psf->sf.channels - 1) & 1);
#line 141
  psf_binheader_writef(psf, "et4888", 0, psf->sf.frames, psf->sf.frames, psf->sf.frames);
#line 142
  psf_binheader_writef(psf, "e112", 0, 1, (int )((uint16_t )psf->sf.samplerate));
#line 145
  psf->bytewidth = 2;
#line 146
  psf->endian = 268435456;
#line 148
  psf_fwrite((unsigned char *)psf->header, (sf_count_t )psf->headindex, (sf_count_t )1,
             psf);
  }
#line 150
  if (psf->error) {
#line 151
    return (psf->error);
  }
#line 153
  psf->dataoffset = (sf_count_t )psf->headindex;
#line 155
  if (current > 0L) {
    {
#line 156
    psf_fseek(psf, current, 0);
    }
  }
#line 158
  return (psf->error);
}
}
#line 162 "/root/libsndfile/src/mpc2k.c"
static int mpc2k_read_header(SF_PRIVATE *psf ) 
{ 
  char sample_name[18] ;
  unsigned char bytes[4] ;
  uint32_t sample_start ;
  uint32_t loop_end ;
  uint32_t sample_frames ;
  uint32_t loop_length ;
  uint16_t sample_rate ;
  size_t __cil_tmp9 ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  sf_count_t __cil_tmp13 ;

  {
  {
#line 168
  __cil_tmp9 = make_size_t(17);
#line 168
  psf_binheader_readf(psf, "pebb", 0, (unsigned char *)bytes, 2, (char *)sample_name,
                      __cil_tmp9);
  }
#line 170
  if ((int )bytes[0] != 1) {
#line 171
    return (666);
  } else
#line 170
  if ((int )bytes[1] != 4) {
#line 171
    return (666);
  }
  {
#line 173
  sample_name[17] = (char )0;
#line 175
  psf_log_printf(psf, "MPC2000\n  Name         : %s\n", (char *)sample_name);
#line 177
  psf_binheader_readf(psf, "eb4444", (unsigned char *)bytes, 3, & sample_start, & loop_end,
                      & sample_frames, & loop_length);
  }
#line 179
  if ((int )bytes[2]) {
#line 179
    tmp = 2;
  } else {
#line 179
    tmp = 1;
  }
#line 179
  psf->sf.channels = tmp;
#line 181
  if ((int )bytes[2]) {
#line 181
    tmp___0 = "Yes\372\036V";
  } else {
#line 181
    tmp___0 = "No\316\372\036V";
  }
  {
#line 181
  psf_log_printf(psf, "  Level        : %d\n  Tune         : %d\n  Stereo       : %s\n",
                 (int )bytes[0], (int )bytes[1], tmp___0);
#line 183
  psf_log_printf(psf, "  Sample start : %d\n  Loop end     : %d\n  Frames       : %d\n  Length       : %d\n\230\001",
                 sample_start, loop_end, sample_frames, loop_length);
#line 185
  psf_binheader_readf(psf, "eb2", (unsigned char *)bytes, 2, & sample_rate);
  }
#line 187
  if ((int )bytes[0]) {
#line 187
    tmp___1 = "None";
  } else {
#line 187
    tmp___1 = "Fwd";
  }
  {
#line 187
  psf_log_printf(psf, "  Loop mode    : %s\n  Beats        : %d\n  Sample rate  : %d\nEnd\n\230\001",
                 tmp___1, (int )bytes[1], (int )sample_rate);
#line 189
  psf->sf.samplerate = (int )sample_rate;
#line 191
  psf->sf.format = 2162690;
#line 193
  psf->dataoffset = psf_ftell(psf);
#line 196
  psf->bytewidth = 2;
#line 197
  psf->endian = 268435456;
#line 199
  psf->datalength = psf->filelength - psf->dataoffset;
#line 200
  psf->blockwidth = psf->sf.channels * psf->bytewidth;
#line 201
  psf->sf.frames = psf->datalength / (long )psf->blockwidth;
#line 203
  psf->sf.frames = (psf->filelength - psf->dataoffset) / (long )psf->blockwidth;
  }
#line 205
  return (0);
}
}
#line 51 "/root/libsndfile/src/xi.c"
static int xi_close(SF_PRIVATE *UNUSED_psf ) ;
#line 52
static int xi_write_header(SF_PRIVATE *psf , int UNUSED_calc_length ) ;
#line 53
static int xi_read_header(SF_PRIVATE *psf ) ;
#line 54
static int dpcm_init(SF_PRIVATE *psf ) ;
#line 57
static sf_count_t dpcm_seek(SF_PRIVATE *psf , int mode , sf_count_t offset ) ;
#line 64 "/root/libsndfile/src/xi.c"
int xi_open(SF_PRIVATE *psf ) 
{ 
  XI_PRIVATE *pxi ;
  int subformat ;
  int error ;
  void *__cil_tmp5 ;
  int __cil_tmp6 ;
  int tmp ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
#line 66
  error = 0;
#line 68
  if (psf->is_pipe) {
#line 69
    return (136);
  }
#line 71
  if (psf->codec_data) {
#line 72
    pxi = psf->codec_data;
  } else {
    {
#line 73
    pxi = (XI_PRIVATE *)calloc((unsigned long )1, sizeof(XI_PRIVATE ));
    }
#line 73
    if (pxi == (void *)0) {
#line 74
      return (16);
    }
  }
#line 76
  psf->codec_data = pxi;
#line 78
  if (psf->mode == 16) {
    _L: /* CIL Label */ 
    {
#line 79
    error = xi_read_header(psf);
    }
#line 79
    if (error) {
#line 80
      return (error);
    }
  } else
#line 78
  if (psf->mode == 48) {
#line 78
    if (psf->filelength > 0L) {
#line 78
      goto _L;
    }
  }
#line 83
  subformat = psf->sf.format & 65535;
#line 85
  if (psf->mode == 32) {
    _L___11: /* CIL Label */ 
#line 86
    if ((psf->sf.format & 268369920) != 983040) {
#line 87
      return (1);
    }
    {
#line 89
    psf->endian = 268435456;
#line 90
    psf->sf.channels = 1;
#line 91
    psf->sf.samplerate = 44100;
#line 94
    memcpy((char *)pxi->filename, "Default Name            \230\001\200\376V\204\002",
           sizeof(pxi->filename));
#line 95
    memcpy((char *)pxi->software, "libsndfile-1.0.21pre1               \230\001\200\372\272\204\002",
           sizeof(pxi->software));
#line 97
    memset((char *)pxi->sample_name, 0, sizeof(pxi->sample_name));
#line 98
    snprintf((char *)pxi->sample_name, sizeof(pxi->sample_name), "%s", "Sample #1");
    }
#line 100
    if (subformat == 81) {
#line 100
      tmp = 16;
    } else {
#line 100
      tmp = 0;
    }
    {
#line 100
    pxi->sample_flags = tmp;
#line 102
    __cil_tmp8 = xi_write_header(psf, 0);
    }
#line 102
    if (__cil_tmp8) {
#line 103
      return (psf->error);
    }
#line 105
    psf->write_header = & xi_write_header;
  } else
#line 85
  if (psf->mode == 48) {
#line 85
    goto _L___11;
  }
#line 108
  psf->container_close = & xi_close;
#line 109
  psf->seek = & dpcm_seek;
#line 111
  psf->sf.seekable = 0;
#line 113
  psf->blockwidth = psf->bytewidth * psf->sf.channels;
  {
#line 117
  if (subformat == 81) {
#line 117
    goto case_81;
  }
#line 117
  if (subformat == 80) {
#line 117
    goto case_81;
  }
#line 121
  goto switch_default;
  case_81: /* CIL Label */ 
  case_80: /* CIL Label */ 
  {
#line 118
  error = dpcm_init(psf);
  }
#line 119
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 121
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }

#line 124
  return (error);
}
}
#line 131 "/root/libsndfile/src/xi.c"
static int xi_close(SF_PRIVATE *UNUSED_psf ) 
{ 


  {
#line 133
  return (0);
}
}
#line 139
static sf_count_t dpcm_read_dsc2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 140
static sf_count_t dpcm_read_dsc2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 141
static sf_count_t dpcm_read_dsc2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 142
static sf_count_t dpcm_read_dsc2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 144
static sf_count_t dpcm_write_s2dsc(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 145
static sf_count_t dpcm_write_i2dsc(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 146
static sf_count_t dpcm_write_f2dsc(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 147
static sf_count_t dpcm_write_d2dsc(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 149
static sf_count_t dpcm_read_dles2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 150
static sf_count_t dpcm_read_dles2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 151
static sf_count_t dpcm_read_dles2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 152
static sf_count_t dpcm_read_dles2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 154
static sf_count_t dpcm_write_s2dles(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 155
static sf_count_t dpcm_write_i2dles(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 156
static sf_count_t dpcm_write_f2dles(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 157
static sf_count_t dpcm_write_d2dles(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 160 "/root/libsndfile/src/xi.c"
static int dpcm_init(SF_PRIVATE *psf ) 
{ 
  sf_count_t __cil_tmp2 ;
  sf_count_t tmp ;

  {
#line 161
  if (psf->bytewidth == 0) {
#line 162
    return (29);
  } else
#line 161
  if (psf->sf.channels == 0) {
#line 162
    return (29);
  }
#line 164
  psf->blockwidth = psf->bytewidth * psf->sf.channels;
#line 166
  if (psf->mode == 16) {
    _L: /* CIL Label */ 
    {
#line 168
    if (psf->bytewidth == 1) {
#line 168
      goto case_1;
    }
#line 174
    if (psf->bytewidth == 2) {
#line 174
      goto case_2;
    }
#line 180
    goto switch_default;
    case_1: /* CIL Label */ 
#line 169
    psf->read_short = & dpcm_read_dsc2s;
#line 170
    psf->read_int = & dpcm_read_dsc2i;
#line 171
    psf->read_float = & dpcm_read_dsc2f;
#line 172
    psf->read_double = & dpcm_read_dsc2d;
#line 173
    goto switch_break;
    case_2: /* CIL Label */ 
#line 175
    psf->read_short = & dpcm_read_dles2s;
#line 176
    psf->read_int = & dpcm_read_dles2i;
#line 177
    psf->read_float = & dpcm_read_dles2f;
#line 178
    psf->read_double = & dpcm_read_dles2d;
#line 179
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 181
    psf_log_printf(psf, "dpcm_init() returning SFE_UNIMPLEMENTED\nx\313\353\372\036V");
    }
#line 182
    return (17);
    switch_break: /* CIL Label */ ;
    }

  } else
#line 166
  if (psf->mode == 48) {
#line 166
    goto _L;
  }

#line 186
  if (psf->mode == 32) {
    _L___12: /* CIL Label */ 
    {
#line 188
    if (psf->bytewidth == 1) {
#line 188
      goto case_1___0;
    }
#line 194
    if (psf->bytewidth == 2) {
#line 194
      goto case_2___0;
    }
#line 200
    goto switch_default___0;
    case_1___0: /* CIL Label */ 
#line 189
    psf->write_short = & dpcm_write_s2dsc;
#line 190
    psf->write_int = & dpcm_write_i2dsc;
#line 191
    psf->write_float = & dpcm_write_f2dsc;
#line 192
    psf->write_double = & dpcm_write_d2dsc;
#line 193
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
#line 195
    psf->write_short = & dpcm_write_s2dles;
#line 196
    psf->write_int = & dpcm_write_i2dles;
#line 197
    psf->write_float = & dpcm_write_f2dles;
#line 198
    psf->write_double = & dpcm_write_d2dles;
#line 199
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 201
    psf_log_printf(psf, "dpcm_init() returning SFE_UNIMPLEMENTED\n\220");
    }
#line 202
    return (17);
    switch_break___0: /* CIL Label */ ;
    }

  } else
#line 186
  if (psf->mode == 48) {
#line 186
    goto _L___12;
  }
  {
#line 206
  psf->filelength = psf_get_filelen(psf);
  }
#line 207
  if (psf->dataend) {
#line 207
    tmp = psf->dataend - psf->dataoffset;
  } else {
#line 207
    tmp = psf->filelength - psf->dataoffset;
  }
#line 207
  psf->datalength = tmp;
#line 209
  psf->sf.frames = psf->datalength / (long )psf->blockwidth;
#line 211
  return (0);
}
}
#line 218 "/root/libsndfile/src/xi.c"
static sf_count_t dpcm_seek(SF_PRIVATE *psf , int mode , sf_count_t offset ) 
{ 
  XI_PRIVATE *pxi ;
  int total ;
  int bufferlen ;
  int len ;
  int tmp ;
  sf_count_t __cil_tmp9 ;
  int tmp___0 ;
  sf_count_t __cil_tmp11 ;

  {
#line 222
  pxi = psf->codec_data;
#line 222
  if (pxi == (void *)0) {
#line 223
    return ((sf_count_t )29);
  }
#line 225
  if (psf->datalength < 0L) {
#line 226
    psf->error = 38;
#line 227
    return ((sf_count_t )(- 1));
  } else
#line 225
  if (psf->dataoffset < 0L) {
#line 226
    psf->error = 38;
#line 227
    return ((sf_count_t )(- 1));
  }

#line 230
  if (offset == 0L) {
    {
#line 231
    psf_fseek(psf, psf->dataoffset, 0);
#line 232
    pxi->last_16 = (short )0;
    }
#line 233
    return ((sf_count_t )0);
  }

#line 236
  if (offset < 0L) {
#line 237
    psf->error = 38;
#line 238
    return ((sf_count_t )(- 1));
  } else
#line 236
  if (offset > psf->sf.frames) {
#line 237
    psf->error = 38;
#line 238
    return ((sf_count_t )(- 1));
  }

#line 241
  if (mode != 16) {
#line 243
    psf->error = 38;
#line 244
    return ((sf_count_t )(- 1));
  }
  {
#line 247
  psf_fseek(psf, psf->dataoffset, 0);
  }
#line 249
  if ((psf->sf.format & 65535) == 81) {
#line 250
    total = (int )offset;
#line 251
    bufferlen = (int )(sizeof(psf->u.sbuf) / sizeof(psf->u.sbuf[0]));
    {
#line 252
    while (1) {
      while_continue: /* CIL Label */ ;
#line 252
      if (! (total > 0)) {
#line 252
        goto while_break;
      }
#line 253
      if (total > bufferlen) {
#line 253
        tmp = bufferlen;
      } else {
#line 253
        tmp = total;
      }
      {
#line 253
      len = tmp;
#line 254
      __cil_tmp9 = dpcm_read_dles2s(psf, (short *)psf->u.sbuf, (sf_count_t )len);
      }
#line 254
      total -= __cil_tmp9;
    }
    while_break: /* CIL Label */ ;
    }

  } else {
#line 258
    total = (int )offset;
#line 259
    bufferlen = (int )(sizeof(psf->u.sbuf) / sizeof(psf->u.sbuf[0]));
    {
#line 260
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 260
      if (! (total > 0)) {
#line 260
        goto while_break___0;
      }
#line 261
      if (total > bufferlen) {
#line 261
        tmp___0 = bufferlen;
      } else {
#line 261
        tmp___0 = total;
      }
      {
#line 261
      len = tmp___0;
#line 262
      __cil_tmp11 = dpcm_read_dsc2s(psf, (short *)psf->u.sbuf, (sf_count_t )len);
      }
#line 262
      total -= __cil_tmp11;
    }
    while_break___0: /* CIL Label */ ;
    }

  }

#line 266
  return (offset);
}
}
#line 271 "/root/libsndfile/src/xi.c"
static int xi_write_header(SF_PRIVATE *psf , int UNUSED_calc_length ) 
{ 
  XI_PRIVATE *pxi ;
  sf_count_t current ;
  char const   *string ;
  sf_count_t __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  size_t __cil_tmp8 ;
  unsigned long __cil_tmp9 ;

  {
#line 276
  pxi = psf->codec_data;
#line 276
  if (pxi == (void *)0) {
#line 277
    return (29);
  }
  {
#line 279
  current = psf_ftell(psf);
#line 282
  psf->header[0] = (unsigned char )0;
#line 283
  psf->headindex = 0;
#line 284
  psf_fseek(psf, (sf_count_t )0, 0);
#line 286
  string = "Extended Instrument: V";
#line 287
  __cil_tmp7 = strlen(string);
#line 287
  psf_binheader_writef(psf, "b", string, __cil_tmp7);
#line 288
  psf_binheader_writef(psf, "b1", (char *)pxi->filename, sizeof(pxi->filename), 26);
#line 291
  psf_binheader_writef(psf, "eb2", (char *)pxi->software, sizeof(pxi->software), (1 << 8) + 2);
#line 297
  psf_binheader_writef(psf, "z*\354\372\036V", (size_t )194);
#line 302
  __cil_tmp8 = make_size_t(22);
#line 302
  psf_binheader_writef(psf, "ez2z2", (size_t )12, 4660, __cil_tmp8, 1);
#line 304
  pxi->loop_begin = 0;
#line 305
  pxi->loop_end = 0;
#line 307
  psf_binheader_writef(psf, "et844", psf->sf.frames, pxi->loop_begin, pxi->loop_end);
#line 310
  __cil_tmp9 = strlen((char const   *)((char *)pxi->sample_name));
#line 310
  psf_binheader_writef(psf, "111111", 128, 0, pxi->sample_flags, 128, 0, __cil_tmp9);
#line 312
  psf_binheader_writef(psf, "b", (char *)pxi->sample_name, sizeof(pxi->sample_name));
#line 319
  psf_fwrite((unsigned char *)psf->header, (sf_count_t )psf->headindex, (sf_count_t )1,
             psf);
  }
#line 321
  if (psf->error) {
#line 322
    return (psf->error);
  }
#line 324
  psf->dataoffset = (sf_count_t )psf->headindex;
#line 326
  if (current > 0L) {
    {
#line 327
    psf_fseek(psf, current, 0);
    }
  }
#line 329
  return (psf->error);
}
}
#line 333 "/root/libsndfile/src/xi.c"
static int xi_read_header(SF_PRIVATE *psf ) 
{ 
  char buffer[64] ;
  char name[32] ;
  short version ;
  short fade_out ;
  short sample_count ;
  int k ;
  int loop_begin ;
  int loop_end ;
  int sample_sizes[16] ;
  int __cil_tmp11 ;
  SF_INSTRUMENT *__cil_tmp12 ;
  char const   *tmp ;
  int __cil_tmp14 ;
  short __cil_tmp15 ;
  sf_count_t __cil_tmp16 ;
  sf_count_t __cil_tmp17 ;

  {
  {
#line 339
  psf_binheader_readf(psf, "pb", 0, (char *)buffer, 21);
#line 341
  memset((int *)sample_sizes, 0, sizeof(sample_sizes));
#line 343
  buffer[20] = (char )0;
#line 344
  __cil_tmp11 = strcmp((char const   *)((char *)buffer), "Extended Instrument:\036V");
  }
#line 344
  if (__cil_tmp11 != 0) {
#line 345
    return (134);
  }
  {
#line 347
  memset((char *)buffer, 0, sizeof(buffer));
#line 348
  psf_binheader_readf(psf, "b0\354\372\036V", (char *)buffer, 23);
  }
#line 350
  if ((int )buffer[22] != 26) {
#line 351
    return (134);
  }
  {
#line 353
  buffer[22] = (char )0;
#line 354
  psf_log_printf(psf, "Extended Instrument : %s\n-\354\372\036V", (char *)buffer);
#line 356
  psf_binheader_readf(psf, "be2", (char *)buffer, 20, & version);
#line 357
  buffer[19] = (char )0;
#line 358
  psf_log_printf(psf, "Software : %s\nVersion  : %d.%02d\n)\354\372\036V", (char *)buffer,
                 (int )version / 256, (int )version % 256);
#line 363
  psf_binheader_readf(psf, "j+\354\372\036V", 194);
#line 365
  psf_binheader_readf(psf, "b", (char *)buffer, 12);
#line 366
  psf_log_printf(psf, "Volume Loop\n  sustain : %u\n  begin   : %u\n  end     : %u\n",
                 (int )buffer[0], (int )buffer[1], (int )buffer[2]);
#line 368
  psf_log_printf(psf, "Pan Loop\n  sustain : %u\n  begin   : %u\n  end     : %u\n",
                 (int )buffer[3], (int )buffer[4], (int )buffer[5]);
#line 370
  psf_log_printf(psf, "Envelope Flags\n  volume  : 0x%X\n  pan     : 0x%X\n\027\354\372\036V",
                 (int )buffer[6] & 255, (int )buffer[7] & 255);
#line 373
  psf_log_printf(psf, "Vibrato\n  type    : %u\n  sweep   : %u\n  depth   : %u\n  rate    : %u\n\036V",
                 (int )buffer[8], (int )buffer[9], (int )buffer[10], (int )buffer[11]);
#line 380
  psf_binheader_readf(psf, "e2j2", & fade_out, 22, & sample_count);
#line 381
  psf_log_printf(psf, "Fade out  : %d\n", (int )fade_out);
  }
#line 384
  if ((int )sample_count > 16) {
#line 385
    return (135);
  }
  {
#line 387
  psf->instrument = psf_instrument_alloc();
  }
#line 387
  if (psf->instrument == (void *)0) {
#line 387
    if (psf->instrument == (void *)0) {
#line 388
      return (16);
    }
  }
#line 391
  k = 0;
  {
#line 391
  while (1) {
    while_continue: /* CIL Label */ ;
#line 391
    if (! (k < (int )sample_count)) {
#line 391
      goto while_break;
    }
    {
#line 392
    psf_binheader_readf(psf, "e444\036V", & sample_sizes[k], & loop_begin, & loop_end);
#line 395
    psf_binheader_readf(psf, "bb\354\372\036V", (char *)buffer, 6, (char *)name, 22);
#line 396
    name[21] = (char )0;
#line 398
    psf_log_printf(psf, "Sample #%d\n  name    : %s\n", k + 1, (char *)name);
#line 400
    psf_log_printf(psf, "  size    : %d\n", sample_sizes[k]);
#line 404
    psf_log_printf(psf, "  loop\n    begin : %d\n    end   : %d\n", loop_begin, loop_end);
#line 406
    psf_log_printf(psf, "  volume  : %u\n  f. tune : %d\n  flags   : 0x%02X ", (int )buffer[0] & 255,
                   (int )buffer[1] & 255, (int )buffer[2] & 255);
#line 409
    psf_log_printf(psf, " (");
    }
#line 410
    if ((int )buffer[2] & 1) {
      {
#line 411
      psf_log_printf(psf, " Loop");
      }
    }
#line 412
    if ((int )buffer[2] & 2) {
      {
#line 413
      psf_log_printf(psf, " PingPong");
      }
    }
#line 414
    if ((int )buffer[2] & 16) {
#line 414
      tmp = " 16bit";
    } else {
#line 414
      tmp = " 8bit";
    }
    {
#line 414
    psf_log_printf(psf, tmp);
#line 415
    psf_log_printf(psf, " )\n");
#line 417
    psf_log_printf(psf, "  pan     : %u\n  note    : %d\n  namelen : %d\n", (int )buffer[3] & 255,
                   (int )buffer[4], (int )buffer[5]);
    }
#line 420
    if (k != 0) {
#line 421
      goto while_continue;
    }
#line 423
    if ((int )buffer[2] & 16) {
#line 424
      psf->sf.format = 983121;
#line 425
      psf->bytewidth = 2;
    } else {
#line 428
      psf->sf.format = 983120;
#line 429
      psf->bytewidth = 1;
    }

#line 391
    k ++;
  }
  while_break: /* CIL Label */ ;
  }

  {
#line 433
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 433
    if (! ((int )sample_count > 1 && sample_sizes[(int )sample_count - 1] == 0)) {
#line 433
      goto while_break___0;
    }
#line 434
    __cil_tmp15 = sample_count;
#line 434
    sample_count --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 438
  if ((int )sample_count > 2) {
    {
#line 439
    psf_log_printf(psf, "*** Sample count is less than 16 but more than 1.\n");
#line 440
    psf_log_printf(psf, "  sample count : %d    sample_sizes [%d] : %d\n", (int )sample_count,
                   (int )sample_count - 1, sample_sizes[(int )sample_count - 1]);
    }
#line 442
    return (135);
  }
  {
#line 445
  psf->datalength = (sf_count_t )sample_sizes[0];
#line 447
  psf->dataoffset = psf_ftell(psf);
  }
#line 448
  if (psf->dataoffset < 0L) {
    {
#line 449
    psf_log_printf(psf, "*** Bad Data Offset : %D\n", psf->dataoffset);
    }
#line 450
    return (25);
  }
  {
#line 452
  psf_log_printf(psf, "Data Offset : %D\n", psf->dataoffset);
  }
#line 454
  if (psf->dataoffset + psf->datalength > psf->filelength) {
    {
#line 455
    psf_log_printf(psf, "*** File seems to be truncated. Should be at least %D bytes long.\n",
                   psf->dataoffset + (long )sample_sizes[0]);
#line 457
    psf->datalength = psf->filelength - psf->dataoffset;
    }
  }
  {
#line 460
  __cil_tmp17 = psf_fseek(psf, psf->dataoffset, 0);
  }
#line 460
  if (__cil_tmp17 != psf->dataoffset) {
#line 461
    return (38);
  }
#line 463
  psf->endian = 268435456;
#line 464
  psf->sf.channels = 1;
#line 465
  psf->sf.samplerate = 44100;
#line 467
  psf->blockwidth = psf->sf.channels * psf->bytewidth;
#line 469
  if (! psf->sf.frames) {
#line 469
    if (psf->blockwidth) {
#line 470
      psf->sf.frames = (psf->filelength - psf->dataoffset) / (long )psf->blockwidth;
    }
  }
#line 472
  (psf->instrument)->basenote = (char )0;
#line 473
  (psf->instrument)->gain = 1;
#line 474
  (psf->instrument)->key_lo = (char )0;
#line 474
  (psf->instrument)->velocity_lo = (psf->instrument)->key_lo;
#line 475
  (psf->instrument)->key_hi = (char )127;
#line 475
  (psf->instrument)->velocity_hi = (psf->instrument)->key_hi;
#line 477
  return (0);
}
}
#line 483
static void dsc2s_array(XI_PRIVATE *pxi , signed char *src , int count , short *dest ) ;
#line 484
static void dsc2i_array(XI_PRIVATE *pxi , signed char *src , int count , int *dest ) ;
#line 485
static void dsc2f_array(XI_PRIVATE *pxi , signed char *src , int count , float *dest ,
                        float normfact ) ;
#line 486
static void dsc2d_array(XI_PRIVATE *pxi , signed char *src , int count , double *dest ,
                        double normfact ) ;
#line 488
static void dles2s_array(XI_PRIVATE *pxi , short *src , int count , short *dest ) ;
#line 489
static void dles2i_array(XI_PRIVATE *pxi , short *src , int count , int *dest ) ;
#line 490
static void dles2f_array(XI_PRIVATE *pxi , short *src , int count , float *dest ,
                         float normfact ) ;
#line 491
static void dles2d_array(XI_PRIVATE *pxi , short *src , int count , double *dest ,
                         double normfact ) ;
#line 494 "/root/libsndfile/src/xi.c"
static sf_count_t dpcm_read_dsc2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  XI_PRIVATE *pxi ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 497
  total = (sf_count_t )0;
#line 499
  pxi = psf->codec_data;
#line 499
  if (pxi == (void *)0) {
#line 500
    return ((sf_count_t )0);
  }
#line 502
  bufferlen = (int )(sizeof(psf->u.ucbuf) / sizeof(psf->u.ucbuf[0]));
  {
#line 504
  while (1) {
    while_continue: /* CIL Label */ ;
#line 504
    if (! (len > 0L)) {
#line 504
      goto while_break;
    }
#line 505
    if (len < (long )bufferlen) {
#line 506
      bufferlen = (int )len;
    }
    {
#line 507
    __cil_tmp8 = psf_fread((signed char *)psf->u.scbuf, (sf_count_t )sizeof(signed char ),
                           (sf_count_t )bufferlen, psf);
#line 507
    readcount = (int )__cil_tmp8;
#line 508
    dsc2s_array(pxi, (signed char *)psf->u.scbuf, readcount, ptr + total);
#line 509
    total += (long )readcount;
    }
#line 510
    if (readcount < bufferlen) {
#line 511
      goto while_break;
    }
#line 512
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 515
  return (total);
}
}
#line 519 "/root/libsndfile/src/xi.c"
static sf_count_t dpcm_read_dsc2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  XI_PRIVATE *pxi ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 522
  total = (sf_count_t )0;
#line 524
  pxi = psf->codec_data;
#line 524
  if (pxi == (void *)0) {
#line 525
    return ((sf_count_t )0);
  }
#line 527
  bufferlen = (int )(sizeof(psf->u.ucbuf) / sizeof(psf->u.ucbuf[0]));
  {
#line 529
  while (1) {
    while_continue: /* CIL Label */ ;
#line 529
    if (! (len > 0L)) {
#line 529
      goto while_break;
    }
#line 530
    if (len < (long )bufferlen) {
#line 531
      bufferlen = (int )len;
    }
    {
#line 532
    __cil_tmp8 = psf_fread((signed char *)psf->u.scbuf, (sf_count_t )sizeof(signed char ),
                           (sf_count_t )bufferlen, psf);
#line 532
    readcount = (int )__cil_tmp8;
#line 533
    dsc2i_array(pxi, (signed char *)psf->u.scbuf, readcount, ptr + total);
#line 534
    total += (long )readcount;
    }
#line 535
    if (readcount < bufferlen) {
#line 536
      goto while_break;
    }
#line 537
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 540
  return (total);
}
}
#line 544 "/root/libsndfile/src/xi.c"
static sf_count_t dpcm_read_dsc2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  XI_PRIVATE *pxi ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 547
  total = (sf_count_t )0;
#line 550
  pxi = psf->codec_data;
#line 550
  if (pxi == (void *)0) {
#line 551
    return ((sf_count_t )0);
  }
#line 553
  if (psf->norm_float == 1) {
#line 553
    tmp = 1. / (double )((float )128);
  } else {
#line 553
    tmp = 1.;
  }
#line 553
  normfact = (float )tmp;
#line 555
  bufferlen = (int )(sizeof(psf->u.ucbuf) / sizeof(psf->u.ucbuf[0]));
  {
#line 557
  while (1) {
    while_continue: /* CIL Label */ ;
#line 557
    if (! (len > 0L)) {
#line 557
      goto while_break;
    }
#line 558
    if (len < (long )bufferlen) {
#line 559
      bufferlen = (int )len;
    }
    {
#line 560
    __cil_tmp10 = psf_fread((signed char *)psf->u.scbuf, (sf_count_t )sizeof(signed char ),
                            (sf_count_t )bufferlen, psf);
#line 560
    readcount = (int )__cil_tmp10;
#line 561
    dsc2f_array(pxi, (signed char *)psf->u.scbuf, readcount, ptr + total, normfact);
#line 562
    total += (long )readcount;
    }
#line 563
    if (readcount < bufferlen) {
#line 564
      goto while_break;
    }
#line 565
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 568
  return (total);
}
}
#line 572 "/root/libsndfile/src/xi.c"
static sf_count_t dpcm_read_dsc2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  XI_PRIVATE *pxi ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 575
  total = (sf_count_t )0;
#line 578
  pxi = psf->codec_data;
#line 578
  if (pxi == (void *)0) {
#line 579
    return ((sf_count_t )0);
  }
#line 581
  if (psf->norm_double == 1) {
#line 581
    tmp = 1. / (double )128;
  } else {
#line 581
    tmp = 1.;
  }
#line 581
  normfact = tmp;
#line 583
  bufferlen = (int )(sizeof(psf->u.ucbuf) / sizeof(psf->u.ucbuf[0]));
  {
#line 585
  while (1) {
    while_continue: /* CIL Label */ ;
#line 585
    if (! (len > 0L)) {
#line 585
      goto while_break;
    }
#line 586
    if (len < (long )bufferlen) {
#line 587
      bufferlen = (int )len;
    }
    {
#line 588
    __cil_tmp10 = psf_fread((signed char *)psf->u.scbuf, (sf_count_t )sizeof(signed char ),
                            (sf_count_t )bufferlen, psf);
#line 588
    readcount = (int )__cil_tmp10;
#line 589
    dsc2d_array(pxi, (signed char *)psf->u.scbuf, readcount, ptr + total, normfact);
#line 590
    total += (long )readcount;
    }
#line 591
    if (readcount < bufferlen) {
#line 592
      goto while_break;
    }
#line 593
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 596
  return (total);
}
}
#line 603 "/root/libsndfile/src/xi.c"
static sf_count_t dpcm_read_dles2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  XI_PRIVATE *pxi ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 606
  total = (sf_count_t )0;
#line 608
  pxi = psf->codec_data;
#line 608
  if (pxi == (void *)0) {
#line 609
    return ((sf_count_t )0);
  }
#line 611
  bufferlen = (int )(sizeof(psf->u.sbuf) / sizeof(psf->u.sbuf[0]));
  {
#line 613
  while (1) {
    while_continue: /* CIL Label */ ;
#line 613
    if (! (len > 0L)) {
#line 613
      goto while_break;
    }
#line 614
    if (len < (long )bufferlen) {
#line 615
      bufferlen = (int )len;
    }
    {
#line 616
    __cil_tmp8 = psf_fread((short *)psf->u.sbuf, (sf_count_t )sizeof(short ), (sf_count_t )bufferlen,
                           psf);
#line 616
    readcount = (int )__cil_tmp8;
#line 617
    dles2s_array(pxi, (short *)psf->u.sbuf, readcount, ptr + total);
#line 618
    total += (long )readcount;
    }
#line 619
    if (readcount < bufferlen) {
#line 620
      goto while_break;
    }
#line 621
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 624
  return (total);
}
}
#line 628 "/root/libsndfile/src/xi.c"
static sf_count_t dpcm_read_dles2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  XI_PRIVATE *pxi ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 631
  total = (sf_count_t )0;
#line 633
  pxi = psf->codec_data;
#line 633
  if (pxi == (void *)0) {
#line 634
    return ((sf_count_t )0);
  }
#line 636
  bufferlen = (int )(sizeof(psf->u.sbuf) / sizeof(psf->u.sbuf[0]));
  {
#line 638
  while (1) {
    while_continue: /* CIL Label */ ;
#line 638
    if (! (len > 0L)) {
#line 638
      goto while_break;
    }
#line 639
    if (len < (long )bufferlen) {
#line 640
      bufferlen = (int )len;
    }
    {
#line 641
    __cil_tmp8 = psf_fread((short *)psf->u.sbuf, (sf_count_t )sizeof(short ), (sf_count_t )bufferlen,
                           psf);
#line 641
    readcount = (int )__cil_tmp8;
#line 642
    dles2i_array(pxi, (short *)psf->u.sbuf, readcount, ptr + total);
#line 643
    total += (long )readcount;
    }
#line 644
    if (readcount < bufferlen) {
#line 645
      goto while_break;
    }
#line 646
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 649
  return (total);
}
}
#line 653 "/root/libsndfile/src/xi.c"
static sf_count_t dpcm_read_dles2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  XI_PRIVATE *pxi ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 656
  total = (sf_count_t )0;
#line 659
  pxi = psf->codec_data;
#line 659
  if (pxi == (void *)0) {
#line 660
    return ((sf_count_t )0);
  }
#line 662
  if (psf->norm_float == 1) {
#line 662
    tmp = 1. / (double )((float )32768);
  } else {
#line 662
    tmp = 1.;
  }
#line 662
  normfact = (float )tmp;
#line 664
  bufferlen = (int )(sizeof(psf->u.sbuf) / sizeof(psf->u.sbuf[0]));
  {
#line 666
  while (1) {
    while_continue: /* CIL Label */ ;
#line 666
    if (! (len > 0L)) {
#line 666
      goto while_break;
    }
#line 667
    if (len < (long )bufferlen) {
#line 668
      bufferlen = (int )len;
    }
    {
#line 669
    __cil_tmp10 = psf_fread((short *)psf->u.sbuf, (sf_count_t )sizeof(short ), (sf_count_t )bufferlen,
                            psf);
#line 669
    readcount = (int )__cil_tmp10;
#line 670
    dles2f_array(pxi, (short *)psf->u.sbuf, readcount, ptr + total, normfact);
#line 671
    total += (long )readcount;
    }
#line 672
    if (readcount < bufferlen) {
#line 673
      goto while_break;
    }
#line 674
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 677
  return (total);
}
}
#line 681 "/root/libsndfile/src/xi.c"
static sf_count_t dpcm_read_dles2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  XI_PRIVATE *pxi ;
  int bufferlen ;
  int readcount ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 684
  total = (sf_count_t )0;
#line 687
  pxi = psf->codec_data;
#line 687
  if (pxi == (void *)0) {
#line 688
    return ((sf_count_t )0);
  }
#line 690
  if (psf->norm_double == 1) {
#line 690
    tmp = 1. / (double )32768;
  } else {
#line 690
    tmp = 1.;
  }
#line 690
  normfact = tmp;
#line 692
  bufferlen = (int )(sizeof(psf->u.sbuf) / sizeof(psf->u.sbuf[0]));
  {
#line 694
  while (1) {
    while_continue: /* CIL Label */ ;
#line 694
    if (! (len > 0L)) {
#line 694
      goto while_break;
    }
#line 695
    if (len < (long )bufferlen) {
#line 696
      bufferlen = (int )len;
    }
    {
#line 697
    __cil_tmp10 = psf_fread((short *)psf->u.sbuf, (sf_count_t )sizeof(short ), (sf_count_t )bufferlen,
                            psf);
#line 697
    readcount = (int )__cil_tmp10;
#line 698
    dles2d_array(pxi, (short *)psf->u.sbuf, readcount, ptr + total, normfact);
#line 699
    total += (long )readcount;
    }
#line 700
    if (readcount < bufferlen) {
#line 701
      goto while_break;
    }
#line 702
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 705
  return (total);
}
}
#line 711
static void s2dsc_array(XI_PRIVATE *pxi , short const   *src , signed char *dest ,
                        int count ) ;
#line 712
static void i2dsc_array(XI_PRIVATE *pxi , int const   *src , signed char *dest , int count ) ;
#line 713
static void f2dsc_array(XI_PRIVATE *pxi , float const   *src , signed char *dest ,
                        int count , float normfact ) ;
#line 714
static void d2dsc_array(XI_PRIVATE *pxi , double const   *src , signed char *dest ,
                        int count , double normfact ) ;
#line 716
static void s2dles_array(XI_PRIVATE *pxi , short const   *src , short *dest , int count ) ;
#line 717
static void i2dles_array(XI_PRIVATE *pxi , int const   *src , short *dest , int count ) ;
#line 718
static void f2dles_array(XI_PRIVATE *pxi , float const   *src , short *dest , int count ,
                         float normfact ) ;
#line 719
static void d2dles_array(XI_PRIVATE *pxi , double const   *src , short *dest , int count ,
                         double normfact ) ;
#line 723 "/root/libsndfile/src/xi.c"
static sf_count_t dpcm_write_s2dsc(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  XI_PRIVATE *pxi ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 726
  total = (sf_count_t )0;
#line 728
  pxi = psf->codec_data;
#line 728
  if (pxi == (void *)0) {
#line 729
    return ((sf_count_t )0);
  }
#line 731
  bufferlen = (int )(sizeof(psf->u.ucbuf) / sizeof(psf->u.ucbuf[0]));
  {
#line 733
  while (1) {
    while_continue: /* CIL Label */ ;
#line 733
    if (! (len > 0L)) {
#line 733
      goto while_break;
    }
#line 734
    if (len < (long )bufferlen) {
#line 735
      bufferlen = (int )len;
    }
    {
#line 736
    s2dsc_array(pxi, ptr + total, (signed char *)psf->u.scbuf, bufferlen);
#line 737
    __cil_tmp8 = psf_fwrite((signed char *)psf->u.scbuf, (sf_count_t )sizeof(signed char ),
                            (sf_count_t )bufferlen, psf);
#line 737
    writecount = (int )__cil_tmp8;
#line 738
    total += (long )writecount;
    }
#line 739
    if (writecount < bufferlen) {
#line 740
      goto while_break;
    }
#line 741
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 744
  return (total);
}
}
#line 748 "/root/libsndfile/src/xi.c"
static sf_count_t dpcm_write_i2dsc(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  XI_PRIVATE *pxi ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 751
  total = (sf_count_t )0;
#line 753
  pxi = psf->codec_data;
#line 753
  if (pxi == (void *)0) {
#line 754
    return ((sf_count_t )0);
  }
#line 756
  bufferlen = (int )(sizeof(psf->u.ucbuf) / sizeof(psf->u.ucbuf[0]));
  {
#line 758
  while (1) {
    while_continue: /* CIL Label */ ;
#line 758
    if (! (len > 0L)) {
#line 758
      goto while_break;
    }
#line 759
    if (len < (long )bufferlen) {
#line 760
      bufferlen = (int )len;
    }
    {
#line 761
    i2dsc_array(pxi, ptr + total, (signed char *)psf->u.scbuf, bufferlen);
#line 762
    __cil_tmp8 = psf_fwrite((signed char *)psf->u.scbuf, (sf_count_t )sizeof(signed char ),
                            (sf_count_t )bufferlen, psf);
#line 762
    writecount = (int )__cil_tmp8;
#line 763
    total += (long )writecount;
    }
#line 764
    if (writecount < bufferlen) {
#line 765
      goto while_break;
    }
#line 766
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 769
  return (total);
}
}
#line 773 "/root/libsndfile/src/xi.c"
static sf_count_t dpcm_write_f2dsc(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  XI_PRIVATE *pxi ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 776
  total = (sf_count_t )0;
#line 779
  pxi = psf->codec_data;
#line 779
  if (pxi == (void *)0) {
#line 780
    return ((sf_count_t )0);
  }
#line 782
  if (psf->norm_float == 1) {
#line 782
    tmp = 1. * (double )127;
  } else {
#line 782
    tmp = 1.;
  }
#line 782
  normfact = (float )tmp;
#line 784
  bufferlen = (int )(sizeof(psf->u.ucbuf) / sizeof(psf->u.ucbuf[0]));
  {
#line 786
  while (1) {
    while_continue: /* CIL Label */ ;
#line 786
    if (! (len > 0L)) {
#line 786
      goto while_break;
    }
#line 787
    if (len < (long )bufferlen) {
#line 788
      bufferlen = (int )len;
    }
    {
#line 789
    f2dsc_array(pxi, ptr + total, (signed char *)psf->u.scbuf, bufferlen, normfact);
#line 790
    __cil_tmp10 = psf_fwrite((signed char *)psf->u.scbuf, (sf_count_t )sizeof(signed char ),
                             (sf_count_t )bufferlen, psf);
#line 790
    writecount = (int )__cil_tmp10;
#line 791
    total += (long )writecount;
    }
#line 792
    if (writecount < bufferlen) {
#line 793
      goto while_break;
    }
#line 794
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 797
  return (total);
}
}
#line 801 "/root/libsndfile/src/xi.c"
static sf_count_t dpcm_write_d2dsc(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  XI_PRIVATE *pxi ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 804
  total = (sf_count_t )0;
#line 807
  pxi = psf->codec_data;
#line 807
  if (pxi == (void *)0) {
#line 808
    return ((sf_count_t )0);
  }
#line 810
  if (psf->norm_double == 1) {
#line 810
    tmp = 1. * (double )127;
  } else {
#line 810
    tmp = 1.;
  }
#line 810
  normfact = tmp;
#line 812
  bufferlen = (int )(sizeof(psf->u.ucbuf) / sizeof(psf->u.ucbuf[0]));
  {
#line 814
  while (1) {
    while_continue: /* CIL Label */ ;
#line 814
    if (! (len > 0L)) {
#line 814
      goto while_break;
    }
#line 815
    if (len < (long )bufferlen) {
#line 816
      bufferlen = (int )len;
    }
    {
#line 817
    d2dsc_array(pxi, ptr + total, (signed char *)psf->u.scbuf, bufferlen, normfact);
#line 818
    __cil_tmp10 = psf_fwrite((signed char *)psf->u.scbuf, (sf_count_t )sizeof(signed char ),
                             (sf_count_t )bufferlen, psf);
#line 818
    writecount = (int )__cil_tmp10;
#line 819
    total += (long )writecount;
    }
#line 820
    if (writecount < bufferlen) {
#line 821
      goto while_break;
    }
#line 822
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 825
  return (total);
}
}
#line 830 "/root/libsndfile/src/xi.c"
static sf_count_t dpcm_write_s2dles(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  XI_PRIVATE *pxi ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 833
  total = (sf_count_t )0;
#line 835
  pxi = psf->codec_data;
#line 835
  if (pxi == (void *)0) {
#line 836
    return ((sf_count_t )0);
  }
#line 838
  bufferlen = (int )(sizeof(psf->u.sbuf) / sizeof(psf->u.sbuf[0]));
  {
#line 840
  while (1) {
    while_continue: /* CIL Label */ ;
#line 840
    if (! (len > 0L)) {
#line 840
      goto while_break;
    }
#line 841
    if (len < (long )bufferlen) {
#line 842
      bufferlen = (int )len;
    }
    {
#line 843
    s2dles_array(pxi, ptr + total, (short *)psf->u.sbuf, bufferlen);
#line 844
    __cil_tmp8 = psf_fwrite((short *)psf->u.sbuf, (sf_count_t )sizeof(short ), (sf_count_t )bufferlen,
                            psf);
#line 844
    writecount = (int )__cil_tmp8;
#line 845
    total += (long )writecount;
    }
#line 846
    if (writecount < bufferlen) {
#line 847
      goto while_break;
    }
#line 848
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 851
  return (total);
}
}
#line 855 "/root/libsndfile/src/xi.c"
static sf_count_t dpcm_write_i2dles(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  XI_PRIVATE *pxi ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  sf_count_t __cil_tmp8 ;

  {
#line 858
  total = (sf_count_t )0;
#line 860
  pxi = psf->codec_data;
#line 860
  if (pxi == (void *)0) {
#line 861
    return ((sf_count_t )0);
  }
#line 863
  bufferlen = (int )(sizeof(psf->u.sbuf) / sizeof(psf->u.sbuf[0]));
  {
#line 865
  while (1) {
    while_continue: /* CIL Label */ ;
#line 865
    if (! (len > 0L)) {
#line 865
      goto while_break;
    }
#line 866
    if (len < (long )bufferlen) {
#line 867
      bufferlen = (int )len;
    }
    {
#line 868
    i2dles_array(pxi, ptr + total, (short *)psf->u.sbuf, bufferlen);
#line 869
    __cil_tmp8 = psf_fwrite((short *)psf->u.sbuf, (sf_count_t )sizeof(short ), (sf_count_t )bufferlen,
                            psf);
#line 869
    writecount = (int )__cil_tmp8;
#line 870
    total += (long )writecount;
    }
#line 871
    if (writecount < bufferlen) {
#line 872
      goto while_break;
    }
#line 873
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 876
  return (total);
}
}
#line 880 "/root/libsndfile/src/xi.c"
static sf_count_t dpcm_write_f2dles(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  XI_PRIVATE *pxi ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 883
  total = (sf_count_t )0;
#line 886
  pxi = psf->codec_data;
#line 886
  if (pxi == (void *)0) {
#line 887
    return ((sf_count_t )0);
  }
#line 889
  if (psf->norm_float == 1) {
#line 889
    tmp = 1. * (double )32767;
  } else {
#line 889
    tmp = 1.;
  }
#line 889
  normfact = (float )tmp;
#line 891
  bufferlen = (int )(sizeof(psf->u.sbuf) / sizeof(psf->u.sbuf[0]));
  {
#line 893
  while (1) {
    while_continue: /* CIL Label */ ;
#line 893
    if (! (len > 0L)) {
#line 893
      goto while_break;
    }
#line 894
    if (len < (long )bufferlen) {
#line 895
      bufferlen = (int )len;
    }
    {
#line 896
    f2dles_array(pxi, ptr + total, (short *)psf->u.sbuf, bufferlen, normfact);
#line 897
    __cil_tmp10 = psf_fwrite((short *)psf->u.sbuf, (sf_count_t )sizeof(short ), (sf_count_t )bufferlen,
                             psf);
#line 897
    writecount = (int )__cil_tmp10;
#line 898
    total += (long )writecount;
    }
#line 899
    if (writecount < bufferlen) {
#line 900
      goto while_break;
    }
#line 901
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 904
  return (total);
}
}
#line 908 "/root/libsndfile/src/xi.c"
static sf_count_t dpcm_write_d2dles(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  XI_PRIVATE *pxi ;
  int bufferlen ;
  int writecount ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 911
  total = (sf_count_t )0;
#line 914
  pxi = psf->codec_data;
#line 914
  if (pxi == (void *)0) {
#line 915
    return ((sf_count_t )0);
  }
#line 917
  if (psf->norm_double == 1) {
#line 917
    tmp = 1. * (double )32767;
  } else {
#line 917
    tmp = 1.;
  }
#line 917
  normfact = tmp;
#line 919
  bufferlen = (int )(sizeof(psf->u.sbuf) / sizeof(psf->u.sbuf[0]));
  {
#line 921
  while (1) {
    while_continue: /* CIL Label */ ;
#line 921
    if (! (len > 0L)) {
#line 921
      goto while_break;
    }
#line 922
    if (len < (long )bufferlen) {
#line 923
      bufferlen = (int )len;
    }
    {
#line 924
    d2dles_array(pxi, ptr + total, (short *)psf->u.sbuf, bufferlen, normfact);
#line 925
    __cil_tmp10 = psf_fwrite((short *)psf->u.sbuf, (sf_count_t )sizeof(short ), (sf_count_t )bufferlen,
                             psf);
#line 925
    writecount = (int )__cil_tmp10;
#line 926
    total += (long )writecount;
    }
#line 927
    if (writecount < bufferlen) {
#line 928
      goto while_break;
    }
#line 929
    len -= (long )writecount;
  }
  while_break: /* CIL Label */ ;
  }

#line 932
  return (total);
}
}
#line 940 "/root/libsndfile/src/xi.c"
static void dsc2s_array(XI_PRIVATE *pxi , signed char *src , int count , short *dest ) 
{ 
  signed char last_val ;
  int k ;
  int __cil_tmp7 ;

  {
#line 944
  last_val = (signed char )((int )pxi->last_16 >> 8);
#line 946
  k = 0;
  {
#line 946
  while (1) {
    while_continue: /* CIL Label */ ;
#line 946
    if (! (k < count)) {
#line 946
      goto while_break;
    }
#line 947
    last_val += (int )*(src + k);
#line 948
    *(dest + k) = (short )((int )last_val << 8);
#line 946
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 951
  pxi->last_16 = (short )((int )last_val << 8);
  return;
}
}
#line 955 "/root/libsndfile/src/xi.c"
static void dsc2i_array(XI_PRIVATE *pxi , signed char *src , int count , int *dest ) 
{ 
  signed char last_val ;
  int k ;
  int __cil_tmp7 ;

  {
#line 959
  last_val = (signed char )((int )pxi->last_16 >> 8);
#line 961
  k = 0;
  {
#line 961
  while (1) {
    while_continue: /* CIL Label */ ;
#line 961
    if (! (k < count)) {
#line 961
      goto while_break;
    }
#line 962
    last_val += (int )*(src + k);
#line 963
    *(dest + k) = (int )last_val << 24;
#line 961
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 966
  pxi->last_16 = (short )((int )last_val << 8);
  return;
}
}
#line 970 "/root/libsndfile/src/xi.c"
static void dsc2f_array(XI_PRIVATE *pxi , signed char *src , int count , float *dest ,
                        float normfact ) 
{ 
  signed char last_val ;
  int k ;
  int __cil_tmp8 ;

  {
#line 974
  last_val = (signed char )((int )pxi->last_16 >> 8);
#line 976
  k = 0;
  {
#line 976
  while (1) {
    while_continue: /* CIL Label */ ;
#line 976
    if (! (k < count)) {
#line 976
      goto while_break;
    }
#line 977
    last_val += (int )*(src + k);
#line 978
    *(dest + k) = (float )((int )last_val) * normfact;
#line 976
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 981
  pxi->last_16 = (short )((int )last_val << 8);
  return;
}
}
#line 985 "/root/libsndfile/src/xi.c"
static void dsc2d_array(XI_PRIVATE *pxi , signed char *src , int count , double *dest ,
                        double normfact ) 
{ 
  signed char last_val ;
  int k ;
  int __cil_tmp8 ;

  {
#line 989
  last_val = (signed char )((int )pxi->last_16 >> 8);
#line 991
  k = 0;
  {
#line 991
  while (1) {
    while_continue: /* CIL Label */ ;
#line 991
    if (! (k < count)) {
#line 991
      goto while_break;
    }
#line 992
    last_val += (int )*(src + k);
#line 993
    *(dest + k) = (double )((int )last_val) * normfact;
#line 991
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 996
  pxi->last_16 = (short )((int )last_val << 8);
  return;
}
}
#line 1003 "/root/libsndfile/src/xi.c"
static void s2dsc_array(XI_PRIVATE *pxi , short const   *src , signed char *dest ,
                        int count ) 
{ 
  signed char last_val ;
  signed char current ;
  int k ;
  int __cil_tmp8 ;

  {
#line 1007
  last_val = (signed char )((int )pxi->last_16 >> 8);
#line 1009
  k = 0;
  {
#line 1009
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1009
    if (! (k < count)) {
#line 1009
      goto while_break;
    }
#line 1010
    current = (signed char )((int )*(src + k) >> 8);
#line 1011
    *(dest + k) = (signed char )((int )current - (int )last_val);
#line 1012
    last_val = current;
#line 1009
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1015
  pxi->last_16 = (short )((int )last_val << 8);
  return;
}
}
#line 1019 "/root/libsndfile/src/xi.c"
static void i2dsc_array(XI_PRIVATE *pxi , int const   *src , signed char *dest , int count ) 
{ 
  signed char last_val ;
  signed char current ;
  int k ;
  int __cil_tmp8 ;

  {
#line 1023
  last_val = (signed char )((int )pxi->last_16 >> 8);
#line 1025
  k = 0;
  {
#line 1025
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1025
    if (! (k < count)) {
#line 1025
      goto while_break;
    }
#line 1026
    current = (signed char )(*(src + k) >> 24);
#line 1027
    *(dest + k) = (signed char )((int )current - (int )last_val);
#line 1028
    last_val = current;
#line 1025
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1031
  pxi->last_16 = (short )((int )last_val << 8);
  return;
}
}
#line 1035 "/root/libsndfile/src/xi.c"
static void f2dsc_array(XI_PRIVATE *pxi , float const   *src , signed char *dest ,
                        int count , float normfact ) 
{ 
  signed char last_val ;
  signed char current ;
  int k ;
  long __cil_tmp9 ;
  int __cil_tmp10 ;

  {
#line 1039
  last_val = (signed char )((int )pxi->last_16 >> 8);
#line 1041
  k = 0;
  {
#line 1041
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1041
    if (! (k < count)) {
#line 1041
      goto while_break;
    }
    {
#line 1042
    __cil_tmp9 = lrintf(*(src + k) * normfact);
#line 1042
    current = (signed char )__cil_tmp9;
#line 1043
    *(dest + k) = (signed char )((int )current - (int )last_val);
#line 1044
    last_val = current;
    }
#line 1041
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1047
  pxi->last_16 = (short )((int )last_val << 8);
  return;
}
}
#line 1051 "/root/libsndfile/src/xi.c"
static void d2dsc_array(XI_PRIVATE *pxi , double const   *src , signed char *dest ,
                        int count , double normfact ) 
{ 
  signed char last_val ;
  signed char current ;
  int k ;
  long __cil_tmp9 ;
  int __cil_tmp10 ;

  {
#line 1055
  last_val = (signed char )((int )pxi->last_16 >> 8);
#line 1057
  k = 0;
  {
#line 1057
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1057
    if (! (k < count)) {
#line 1057
      goto while_break;
    }
    {
#line 1058
    __cil_tmp9 = lrint(*(src + k) * normfact);
#line 1058
    current = (signed char )__cil_tmp9;
#line 1059
    *(dest + k) = (signed char )((int )current - (int )last_val);
#line 1060
    last_val = current;
    }
#line 1057
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1063
  pxi->last_16 = (short )((int )last_val << 8);
  return;
}
}
#line 1070 "/root/libsndfile/src/xi.c"
static void dles2s_array(XI_PRIVATE *pxi , short *src , int count , short *dest ) 
{ 
  short last_val ;
  int k ;
  int __cil_tmp7 ;

  {
#line 1074
  last_val = pxi->last_16;
#line 1076
  k = 0;
  {
#line 1076
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1076
    if (! (k < count)) {
#line 1076
      goto while_break;
    }
#line 1077
    last_val += (int )*(src + k);
#line 1078
    *(dest + k) = last_val;
#line 1076
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1081
  pxi->last_16 = last_val;
  return;
}
}
#line 1085 "/root/libsndfile/src/xi.c"
static void dles2i_array(XI_PRIVATE *pxi , short *src , int count , int *dest ) 
{ 
  short last_val ;
  int k ;
  int __cil_tmp7 ;

  {
#line 1089
  last_val = pxi->last_16;
#line 1091
  k = 0;
  {
#line 1091
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1091
    if (! (k < count)) {
#line 1091
      goto while_break;
    }
#line 1092
    last_val += (int )*(src + k);
#line 1093
    *(dest + k) = (int )last_val << 16;
#line 1091
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1096
  pxi->last_16 = last_val;
  return;
}
}
#line 1100 "/root/libsndfile/src/xi.c"
static void dles2f_array(XI_PRIVATE *pxi , short *src , int count , float *dest ,
                         float normfact ) 
{ 
  short last_val ;
  int k ;
  int __cil_tmp8 ;

  {
#line 1104
  last_val = pxi->last_16;
#line 1106
  k = 0;
  {
#line 1106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1106
    if (! (k < count)) {
#line 1106
      goto while_break;
    }
#line 1107
    last_val += (int )*(src + k);
#line 1108
    *(dest + k) = (float )((int )last_val) * normfact;
#line 1106
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1111
  pxi->last_16 = last_val;
  return;
}
}
#line 1115 "/root/libsndfile/src/xi.c"
static void dles2d_array(XI_PRIVATE *pxi , short *src , int count , double *dest ,
                         double normfact ) 
{ 
  short last_val ;
  int k ;
  int __cil_tmp8 ;

  {
#line 1119
  last_val = pxi->last_16;
#line 1121
  k = 0;
  {
#line 1121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1121
    if (! (k < count)) {
#line 1121
      goto while_break;
    }
#line 1122
    last_val += (int )*(src + k);
#line 1123
    *(dest + k) = (double )((int )last_val) * normfact;
#line 1121
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1126
  pxi->last_16 = last_val;
  return;
}
}
#line 1133 "/root/libsndfile/src/xi.c"
static void s2dles_array(XI_PRIVATE *pxi , short const   *src , short *dest , int count ) 
{ 
  short diff ;
  short last_val ;
  int k ;
  int __cil_tmp8 ;

  {
#line 1137
  last_val = pxi->last_16;
#line 1139
  k = 0;
  {
#line 1139
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1139
    if (! (k < count)) {
#line 1139
      goto while_break;
    }
#line 1140
    diff = (short )((int )*(src + k) - (int )last_val);
#line 1141
    *(dest + k) = diff;
#line 1142
    last_val = *(src + k);
#line 1139
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1145
  pxi->last_16 = last_val;
  return;
}
}
#line 1149 "/root/libsndfile/src/xi.c"
static void i2dles_array(XI_PRIVATE *pxi , int const   *src , short *dest , int count ) 
{ 
  short diff ;
  short last_val ;
  int k ;
  int __cil_tmp8 ;

  {
#line 1153
  last_val = pxi->last_16;
#line 1155
  k = 0;
  {
#line 1155
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1155
    if (! (k < count)) {
#line 1155
      goto while_break;
    }
#line 1156
    diff = (short )((*(src + k) >> 16) - (int )last_val);
#line 1157
    *(dest + k) = diff;
#line 1158
    last_val = (short )(*(src + k) >> 16);
#line 1155
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1161
  pxi->last_16 = last_val;
  return;
}
}
#line 1165 "/root/libsndfile/src/xi.c"
static void f2dles_array(XI_PRIVATE *pxi , float const   *src , short *dest , int count ,
                         float normfact ) 
{ 
  short diff ;
  short last_val ;
  short current ;
  int k ;
  long __cil_tmp10 ;
  int __cil_tmp11 ;

  {
#line 1169
  last_val = pxi->last_16;
#line 1171
  k = 0;
  {
#line 1171
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1171
    if (! (k < count)) {
#line 1171
      goto while_break;
    }
    {
#line 1172
    __cil_tmp10 = lrintf(*(src + k) * normfact);
#line 1172
    current = (short )__cil_tmp10;
#line 1173
    diff = (short )((int )current - (int )last_val);
#line 1174
    *(dest + k) = diff;
#line 1175
    last_val = current;
    }
#line 1171
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1178
  pxi->last_16 = last_val;
  return;
}
}
#line 1182 "/root/libsndfile/src/xi.c"
static void d2dles_array(XI_PRIVATE *pxi , double const   *src , short *dest , int count ,
                         double normfact ) 
{ 
  short diff ;
  short last_val ;
  short current ;
  int k ;
  long __cil_tmp10 ;
  int __cil_tmp11 ;

  {
#line 1186
  last_val = pxi->last_16;
#line 1188
  k = 0;
  {
#line 1188
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1188
    if (! (k < count)) {
#line 1188
      goto while_break;
    }
    {
#line 1189
    __cil_tmp10 = lrint(*(src + k) * normfact);
#line 1189
    current = (short )__cil_tmp10;
#line 1190
    diff = (short )((int )current - (int )last_val);
#line 1191
    *(dest + k) = diff;
#line 1192
    last_val = current;
    }
#line 1188
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1195
  pxi->last_16 = last_val;
  return;
}
}
#line 113 "/root/libsndfile/src/wav.c"
static EXT_SUBFORMAT MSGUID_SUBTYPE_PCM___0  =    {(unsigned int )1, (unsigned short )0, (unsigned short )16, {(char )128, (char )0,
                                                                (char )0, (char )170,
                                                                (char )0, (char )56,
                                                                (char )155, (char )113}};
#line 117 "/root/libsndfile/src/wav.c"
static EXT_SUBFORMAT MSGUID_SUBTYPE_MS_ADPCM___0  =    {(unsigned int )2, (unsigned short )0, (unsigned short )16, {(char )128, (char )0,
                                                                (char )0, (char )170,
                                                                (char )0, (char )56,
                                                                (char )155, (char )113}};
#line 121 "/root/libsndfile/src/wav.c"
static EXT_SUBFORMAT MSGUID_SUBTYPE_IEEE_FLOAT___0  =    {(unsigned int )3, (unsigned short )0, (unsigned short )16, {(char )128, (char )0,
                                                                (char )0, (char )170,
                                                                (char )0, (char )56,
                                                                (char )155, (char )113}};
#line 125 "/root/libsndfile/src/wav.c"
static EXT_SUBFORMAT MSGUID_SUBTYPE_ALAW___0  =    {(unsigned int )6, (unsigned short )0, (unsigned short )16, {(char )128, (char )0,
                                                                (char )0, (char )170,
                                                                (char )0, (char )56,
                                                                (char )155, (char )113}};
#line 129 "/root/libsndfile/src/wav.c"
static EXT_SUBFORMAT MSGUID_SUBTYPE_MULAW___0  =    {(unsigned int )7, (unsigned short )0, (unsigned short )16, {(char )128, (char )0,
                                                                (char )0, (char )170,
                                                                (char )0, (char )56,
                                                                (char )155, (char )113}};
#line 137 "/root/libsndfile/src/wav.c"
static EXT_SUBFORMAT MSGUID_SUBTYPE_AMBISONIC_B_FORMAT_PCM___0  =    {(unsigned int )1, (unsigned short )1825, (unsigned short )4563, {(char )134, (char )68,
                                                                     (char )200, (char )193,
                                                                     (char )202, (char )0,
                                                                     (char )0, (char )0}};
#line 141 "/root/libsndfile/src/wav.c"
static EXT_SUBFORMAT MSGUID_SUBTYPE_AMBISONIC_B_FORMAT_IEEE_FLOAT___0  =    {(unsigned int )3, (unsigned short )1825, (unsigned short )4563, {(char )134, (char )68,
                                                                     (char )200, (char )193,
                                                                     (char )202, (char )0,
                                                                     (char )0, (char )0}};
#line 158
static int wav_read_header(SF_PRIVATE *psf , int *blockalign , int *framesperblock ) ;
#line 159
static int wav_write_header(SF_PRIVATE *psf , int calc_length ) ;
#line 161
static int wav_write_tailer(SF_PRIVATE *psf ) ;
#line 162
static void wav_write_strings(SF_PRIVATE *psf , int location ) ;
#line 163
static int wav_command(SF_PRIVATE *psf , int command , void *UNUSED_data , int datasize ) ;
#line 164
static int wav_close(SF_PRIVATE *psf ) ;
#line 166
static int wav_subchunk_parse(SF_PRIVATE *psf , int chunk ) ;
#line 167
static int exif_subchunk_parse(SF_PRIVATE *psf , unsigned int length ) ;
#line 168
static int wav_read_smpl_chunk(SF_PRIVATE *psf , unsigned int chunklen ) ;
#line 169
static int wav_read_acid_chunk(SF_PRIVATE *psf , unsigned int chunklen ) ;
#line 170
static int wav_read_bext_chunk(SF_PRIVATE *psf , unsigned int chunksize ) ;
#line 171
static int wav_write_bext_chunk(SF_PRIVATE *psf ) ;
#line 178 "/root/libsndfile/src/wav.c"
int wav_open(SF_PRIVATE *psf ) 
{ 
  WAV_PRIVATE *wpriv ;
  int format ;
  int subformat ;
  int error ;
  int blockalign ;
  int framesperblock ;
  void *__cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  PEAK_INFO *__cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;

  {
#line 180
  blockalign = 0;
  {
#line 180
  framesperblock = 0;
#line 182
  wpriv = (WAV_PRIVATE *)calloc((unsigned long )1, sizeof(WAV_PRIVATE ));
  }
#line 182
  if (wpriv == (void *)0) {
#line 183
    return (16);
  }
#line 184
  psf->container_data = wpriv;
#line 186
  wpriv->wavex_ambisonic = 64;
#line 187
  psf->str_flags = 768;
#line 189
  if (psf->mode == 16) {
    _L: /* CIL Label */ 
    {
#line 190
    error = wav_read_header(psf, & blockalign, & framesperblock);
    }
#line 190
    if (error) {
#line 191
      return (error);
    }
  } else
#line 189
  if (psf->mode == 48) {
#line 189
    if (psf->filelength > 0L) {
#line 189
      goto _L;
    }
  }
#line 194
  subformat = psf->sf.format & 65535;
#line 196
  if (psf->mode == 32) {
    _L___14: /* CIL Label */ 
#line 197
    if (psf->is_pipe) {
#line 198
      return (28);
    }
#line 200
    wpriv->wavex_ambisonic = 64;
#line 202
    format = psf->sf.format & 268369920;
#line 203
    if (format != 65536) {
#line 203
      if (format != 1245184) {
#line 204
        return (1);
      }
    }
#line 206
    psf->blockwidth = psf->bytewidth * psf->sf.channels;
#line 209
    psf->endian = psf->sf.format & 805306368;
#line 210
    if (0) {
#line 211
      psf->endian = 536870912;
    } else
#line 212
    if (psf->endian != 536870912) {
#line 213
      psf->endian = 268435456;
    }
#line 215
    if (psf->mode != 48) {
#line 216
      psf->filelength = (sf_count_t )0;
#line 217
      psf->datalength = (sf_count_t )0;
#line 218
      psf->dataoffset = (sf_count_t )0;
#line 219
      psf->sf.frames = (sf_count_t )0;
    } else
#line 215
    if (psf->filelength < 44L) {
#line 216
      psf->filelength = (sf_count_t )0;
#line 217
      psf->datalength = (sf_count_t )0;
#line 218
      psf->dataoffset = (sf_count_t )0;
#line 219
      psf->sf.frames = (sf_count_t )0;
    }

#line 222
    if (subformat == 18) {
      {
      {
#line 223
      blockalign = wav_w64_srate2blocksize(psf->sf.samplerate * psf->sf.channels);
      }
#line 224
      framesperblock = - 1;
      }
    } else
#line 222
    if (subformat == 19) {
      {
      {
#line 223
      blockalign = wav_w64_srate2blocksize(psf->sf.samplerate * psf->sf.channels);
      }
#line 224
      framesperblock = - 1;
      }
    }

#line 230
    if (psf->mode == 32) {
#line 230
      if (subformat == 6) {
        _L___13: /* CIL Label */ 
        {
#line 231
        psf->peak_info = peak_info_calloc(psf->sf.channels);
        }
#line 231
        if (psf->peak_info == (void *)0) {
#line 232
          return (16);
        }
#line 233
        (psf->peak_info)->peak_loc = 42;
      } else
#line 230
      if (subformat == 7) {
#line 230
        goto _L___13;
      }
    }
#line 236
    psf->write_header = & wav_write_header;
  } else
#line 196
  if (psf->mode == 48) {
#line 196
    goto _L___14;
  }
#line 239
  psf->container_close = & wav_close;
#line 240
  psf->command = & wav_command;
  {
#line 246
  if (subformat == 4) {
#line 246
    goto case_4;
  }
#line 246
  if (subformat == 3) {
#line 246
    goto case_4;
  }
#line 246
  if (subformat == 2) {
#line 246
    goto case_4;
  }
#line 246
  if (subformat == 5) {
#line 246
    goto case_4;
  }
#line 250
  if (subformat == 16) {
#line 250
    goto case_16;
  }
#line 254
  if (subformat == 17) {
#line 254
    goto case_17;
  }
#line 259
  if (subformat == 6) {
#line 259
    goto case_6;
  }
#line 263
  if (subformat == 7) {
#line 263
    goto case_7;
  }
#line 267
  if (subformat == 18) {
#line 267
    goto case_18;
  }
#line 271
  if (subformat == 19) {
#line 271
    goto case_19;
  }
#line 275
  if (subformat == 48) {
#line 275
    goto case_48;
  }
#line 280
  if (subformat == 32) {
#line 280
    goto case_32;
  }
#line 284
  goto switch_default;
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_5: /* CIL Label */ 
  {
#line 247
  error = pcm_init(psf);
  }
#line 248
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 251
  error = ulaw_init(psf);
  }
#line 252
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 255
  error = alaw_init(psf);
  }
#line 256
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 260
  error = float32_init(psf);
  }
#line 261
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 264
  error = double64_init(psf);
  }
#line 265
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 268
  error = wav_w64_ima_init(psf, blockalign, framesperblock);
  }
#line 269
  goto switch_break;
  case_19: /* CIL Label */ 
  {
#line 272
  error = wav_w64_msadpcm_init(psf, blockalign, framesperblock);
  }
#line 273
  goto switch_break;
  case_48: /* CIL Label */ 
  {
#line 276
  error = g72x_init(psf);
  }
#line 277
  goto switch_break;
  case_32: /* CIL Label */ 
  {
#line 281
  error = gsm610_init(psf);
  }
#line 282
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 284
  return (17);
  switch_break: /* CIL Label */ ;
  }

#line 287
  if (psf->mode == 32) {
    {
    {
#line 288
    __cil_tmp21 = (*(psf->write_header))(psf, 0);
    }
    }
#line 288
    return (__cil_tmp21);
  } else
#line 287
  if (psf->mode == 48) {
#line 287
    if (psf->filelength == 0L) {
      {
      {
#line 288
      __cil_tmp21 = (*(psf->write_header))(psf, 0);
      }
      }
#line 288
      return (__cil_tmp21);
    }
  }
#line 290
  return (error);
}
}
#line 298 "/root/libsndfile/src/wav.c"
static int wav_read_header(SF_PRIVATE *psf , int *blockalign , int *framesperblock ) 
{ 
  WAV_PRIVATE *wpriv ;
  WAV_FMT *wav_fmt ;
  FACT_CHUNK fact_chunk ;
  unsigned int dword ;
  unsigned int marker ;
  unsigned int RIFFsize ;
  unsigned int done ;
  int parsestage ;
  int error ;
  int format ;
  char *cptr ;
  int __cil_tmp15 ;
  sf_count_t __cil_tmp16 ;
  sf_count_t __cil_tmp17 ;
  sf_count_t __cil_tmp18 ;
  PEAK_INFO *__cil_tmp19 ;
  float value ;
  unsigned int position ;
  unsigned int __cil_tmp22 ;
  int tmp ;
  unsigned int bytesread ;
  unsigned int cue_count ;
  int id ;
  int position___0 ;
  int chunk_id ;
  int chunk_start ;
  int block_start ;
  int offset ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  unsigned int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  unsigned short const   **__cil_tmp39 ;
  unsigned short const   **__cil_tmp40 ;
  unsigned short const   **__cil_tmp41 ;
  unsigned short const   **__cil_tmp42 ;
  sf_count_t __cil_tmp43 ;
  sf_count_t __cil_tmp44 ;
  sf_count_t __cil_tmp45 ;
  int __cil_tmp46 ;
  int tmp___0 ;

  {
#line 302
  dword = (unsigned int )0;
#line 302
  done = (unsigned int )0;
#line 303
  parsestage = 0;
#line 303
  format = 0;
#line 306
  if (psf->filelength > 4294967295L) {
    {
#line 307
    psf_log_printf(psf, "Warning : filelength > 0xffffffff. This is bad!!!!\n");
    }
  }
#line 309
  wpriv = psf->container_data;
#line 309
  if (wpriv == (void *)0) {
#line 310
    return (29);
  }
  {
#line 311
  wav_fmt = & wpriv->wav_fmt;
#line 314
  psf_binheader_readf(psf, "pF\006\373\036V", 0);
  }
  {
#line 316
  while (1) {
    while_continue: /* CIL Label */ ;
#line 316
    if (! (! done)) {
#line 316
      goto while_break;
    }
    {
#line 317
    psf_binheader_readf(psf, "m", & marker);
    }
    {
#line 321
    if (marker == (unsigned int )(((82 | (73 << 8)) | (70 << 16)) | (88 << 24))) {
#line 321
      goto case_exp;
    }
#line 321
    if (marker == (unsigned int )(((82 | (73 << 8)) | (70 << 16)) | (70 << 24))) {
#line 321
      goto case_exp;
    }
#line 362
    if (marker == (unsigned int )(((87 | (65 << 8)) | (86 << 16)) | (69 << 24))) {
#line 362
      goto case_exp___1;
    }
#line 370
    if (marker == (unsigned int )(((102 | (109 << 8)) | (116 << 16)) | (32 << 24))) {
#line 370
      goto case_exp___2;
    }
#line 389
    if (marker == (unsigned int )(((100 | (97 << 8)) | (116 << 16)) | (97 << 24))) {
#line 389
      goto case_exp___3;
    }
#line 436
    if (marker == (unsigned int )(((102 | (97 << 8)) | (99 << 16)) | (116 << 24))) {
#line 436
      goto case_exp___4;
    }
#line 458
    if (marker == (unsigned int )(((80 | (69 << 8)) | (65 << 16)) | (75 << 24))) {
#line 458
      goto case_exp___5;
    }
#line 504
    if (marker == (unsigned int )(((99 | (117 << 8)) | (101 << 16)) | (32 << 24))) {
#line 504
      goto case_exp___6;
    }
#line 540
    if (marker == (unsigned int )(((115 | (109 << 8)) | (112 << 16)) | (108 << 24))) {
#line 540
      goto case_exp___7;
    }
#line 550
    if (marker == (unsigned int )(((97 | (99 << 8)) | (105 << 16)) | (100 << 24))) {
#line 550
      goto case_exp___8;
    }
#line 561
    if (marker == (unsigned int )(((76 | (73 << 8)) | (83 << 16)) | (84 << 24))) {
#line 561
      goto case_exp___9;
    }
#line 561
    if (marker == (unsigned int )(((73 | (78 << 8)) | (70 << 16)) | (79 << 24))) {
#line 561
      goto case_exp___9;
    }
#line 568
    if (marker == (unsigned int )(((98 | (101 << 8)) | (120 << 16)) | (116 << 24))) {
#line 568
      goto case_exp___11;
    }
#line 578
    if (marker == (unsigned int )(((80 | (65 << 8)) | (68 << 16)) | (32 << 24))) {
#line 578
      goto case_exp___12;
    }
#line 598
    if (marker == (unsigned int )(((77 | (69 << 8)) | (88 << 16)) | (84 << 24))) {
#line 598
      goto case_exp___13;
    }
#line 598
    if (marker == (unsigned int )(((68 | (73 << 8)) | (83 << 16)) | (80 << 24))) {
#line 598
      goto case_exp___13;
    }
#line 598
    if (marker == (unsigned int )(((112 | (108 << 8)) | (115 << 16)) | (116 << 24))) {
#line 598
      goto case_exp___13;
    }
#line 598
    if (marker == (unsigned int )(((108 | (101 << 8)) | (118 << 16)) | (108 << 24))) {
#line 598
      goto case_exp___13;
    }
#line 598
    if (marker == (unsigned int )(((99 | (97 << 8)) | (114 << 16)) | (116 << 24))) {
#line 598
      goto case_exp___13;
    }
#line 598
    if (marker == (unsigned int )(((101 | (108 << 8)) | (109 << 16)) | (111 << 24))) {
#line 598
      goto case_exp___13;
    }
#line 598
    if (marker == (unsigned int )(((99 | (108 << 8)) | (109 << 16)) | (32 << 24))) {
#line 598
      goto case_exp___13;
    }
#line 598
    if (marker == (unsigned int )(((97 | (102 << 8)) | (115 << 16)) | (112 << 24))) {
#line 598
      goto case_exp___13;
    }
#line 598
    if (marker == (unsigned int )(((115 | (116 << 8)) | (114 << 16)) | (99 << 24))) {
#line 598
      goto case_exp___13;
    }
#line 598
    if (marker == (unsigned int )(((105 | (88 << 8)) | (77 << 16)) | (76 << 24))) {
#line 598
      goto case_exp___13;
    }
#line 607
    goto switch_default;
    case_exp: /* CIL Label */ 
    case_exp___0: /* CIL Label */ 
#line 322
    if (parsestage) {
#line 323
      return (57);
    }
#line 325
    parsestage |= 1;
#line 331
    if (marker == (unsigned int )(((82 | (73 << 8)) | (70 << 16)) | (70 << 24))) {
#line 332
      psf->rwf_endian = 268435456;
    } else {
#line 334
      psf->rwf_endian = 536870912;
    }
    {
#line 336
    psf_binheader_readf(psf, "4", & RIFFsize);
    }
#line 338
    if (psf->fileoffset > 0L) {
#line 338
      if (psf->filelength > (long )(RIFFsize + 8U)) {
#line 340
        psf->filelength = (sf_count_t )(RIFFsize + 8U);
#line 341
        if (marker == (unsigned int )(((82 | (73 << 8)) | (70 << 16)) | (70 << 24))) {
          {
#line 342
          psf_log_printf(psf, "RIFF : %u\n", RIFFsize);
          }
        } else {
          {
#line 344
          psf_log_printf(psf, "RIFX : %u\n", RIFFsize);
          }
        }
      } else {
#line 338
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 346
    if (psf->filelength < (long )(RIFFsize + (unsigned int )(2 * (int )sizeof(dword)))) {
#line 347
      if (marker == (unsigned int )(((82 | (73 << 8)) | (70 << 16)) | (70 << 24))) {
        {
#line 348
        psf_log_printf(psf, "RIFF : %u (should be %D)\nj\006\373\036V", RIFFsize,
                       psf->filelength - (long )(2 * (int )sizeof(dword)));
        }
      } else {
        {
#line 350
        psf_log_printf(psf, "RIFX : %u (should be %D)\n", RIFFsize, psf->filelength - (long )(2 * (int )sizeof(dword)));
        }
      }
#line 352
      RIFFsize = dword;
    } else
#line 355
    if (marker == (unsigned int )(((82 | (73 << 8)) | (70 << 16)) | (70 << 24))) {
      {
#line 356
      psf_log_printf(psf, "RIFF : %u\n", RIFFsize);
      }
    } else {
      {
#line 358
      psf_log_printf(psf, "RIFX : %u\n", RIFFsize);
      }
    }

#line 360
    goto switch_break;
    case_exp___1: /* CIL Label */ 
#line 363
    if ((parsestage & 1) != 1) {
#line 364
      return (58);
    }
    {
#line 365
    parsestage |= 2;
#line 367
    psf_log_printf(psf, "WAVE\nV");
    }
#line 368
    goto switch_break;
    case_exp___2: /* CIL Label */ 
#line 371
    if ((parsestage & 3) != 3) {
#line 372
      return (59);
    }
#line 375
    if (parsestage & 4) {
#line 376
      goto switch_break;
    }
    {
#line 378
    parsestage |= 4;
#line 380
    psf_binheader_readf(psf, "4m\006\373\036V", & dword);
#line 381
    psf_log_printf(psf, "fmt  : %d\n", dword);
#line 383
    error = wav_w64_read_fmt_chunk(psf, (int )dword);
    }
#line 383
    if (error) {
#line 384
      return (error);
    }
#line 386
    format = (int )wav_fmt->format;
#line 387
    goto switch_break;
    case_exp___3: /* CIL Label */ 
#line 390
    if ((parsestage & 7) != 7) {
#line 391
      return (67);
    }
#line 393
    if (psf->mode == 48) {
#line 393
      if (((unsigned int )parsestage & (-0x7FFFFFFF-1)) != 0U) {
#line 394
        return (46);
      }
    }
    {
#line 396
    parsestage |= 32;
#line 398
    psf_binheader_readf(psf, "4", & dword);
#line 400
    psf->datalength = (sf_count_t )dword;
#line 401
    psf->dataoffset = psf_ftell(psf);
    }
#line 403
    if (psf->dataoffset > 0L) {
#line 404
      if (dword == 0U) {
#line 404
        if (RIFFsize == 8U) {
#line 404
          if (psf->filelength > 44L) {
            {
#line 405
            psf_log_printf(psf, "*** Looks like a WAV file which wasn\'t closed properly. Fixing it.\n");
#line 406
            psf->datalength = psf->filelength - psf->dataoffset;
            }
          }
        }
      }

#line 409
      if (psf->datalength > psf->filelength - psf->dataoffset) {
        {
#line 410
        psf_log_printf(psf, "data : %D (should be %D)\n", psf->datalength, psf->filelength - psf->dataoffset);
#line 411
        psf->datalength = psf->filelength - psf->dataoffset;
        }
      } else {
        {
#line 414
        psf_log_printf(psf, "data : %D\n", psf->datalength);
        }
      }
#line 417
      if (psf->datalength + psf->dataoffset < psf->filelength) {
#line 418
        psf->dataend = psf->datalength + psf->dataoffset;
      }
#line 420
      if (format == 2) {
#line 420
        if (psf->datalength % 2L) {
          {
#line 421
          (psf->datalength) ++;
#line 422
          psf_log_printf(psf, "*** Data length odd. Increasing it by 1.\n");
          }
        }
      }

    }

#line 426
    if (! psf->sf.seekable) {
#line 427
      goto switch_break;
    } else
#line 426
    if (psf->dataoffset < 0L) {
#line 427
      goto switch_break;
    }
    {
#line 430
    psf_fseek(psf, psf->datalength, 1);
#line 432
    __cil_tmp18 = psf_ftell(psf);
    }
#line 432
    if (__cil_tmp18 != psf->datalength + psf->dataoffset) {
      {
#line 433
      psf_log_printf(psf, "*** psf_fseek past end error ***\n", dword, psf->dataoffset + psf->datalength);
      }
    }
#line 434
    goto switch_break;
    case_exp___4: /* CIL Label */ 
#line 437
    if ((parsestage & 3) != 3) {
#line 438
      return (62);
    }
#line 440
    parsestage |= 8;
#line 442
    if ((parsestage & 4) != 4) {
      {
#line 443
      psf_log_printf(psf, "*** Should have \'fmt \' chunk before \'fact\'\n");
      }
    }
    {
#line 445
    psf_binheader_readf(psf, "44", & dword, & fact_chunk.frames);
    }
#line 447
    if (dword > (unsigned int )((int )sizeof(fact_chunk))) {
      {
#line 448
      psf_binheader_readf(psf, "j", (int )(dword - (unsigned int )((int )sizeof(fact_chunk))));
      }
    }
#line 450
    if (dword) {
      {
#line 451
      psf_log_printf(psf, "%M : %d\n\230\001", marker, dword);
      }
    } else {
      {
#line 453
      psf_log_printf(psf, "%M : %d (should not be zero)\n", marker, dword);
      }
    }
    {
#line 455
    psf_log_printf(psf, "  frames  : %d\n", fact_chunk.frames);
    }
#line 456
    goto switch_break;
    case_exp___5: /* CIL Label */ 
#line 459
    if ((parsestage & 7) != 7) {
#line 460
      return (64);
    }
    {
#line 462
    parsestage |= 16;
#line 464
    psf_binheader_readf(psf, "4", & dword);
#line 466
    psf_log_printf(psf, "%M : %d\n\230\001", marker, dword);
    }
#line 467
    if ((unsigned long )dword != 2UL * sizeof(int ) + (unsigned long )psf->sf.channels * (sizeof(float ) + sizeof(int ))) {
      {
#line 468
      psf_binheader_readf(psf, "j", dword);
#line 469
      psf_log_printf(psf, "*** File PEAK chunk size doesn\'t fit with number of channels (%d).\n",
                     psf->sf.channels);
      }
#line 470
      return (63);
    }
    {
#line 473
    psf->peak_info = peak_info_calloc(psf->sf.channels);
    }
#line 473
    if (psf->peak_info == (void *)0) {
#line 474
      return (16);
    }
    {
#line 477
    psf_binheader_readf(psf, "44", & (psf->peak_info)->version, & (psf->peak_info)->timestamp);
    }
#line 479
    if ((psf->peak_info)->version != 1U) {
      {
#line 480
      psf_log_printf(psf, "  version    : %d *** (should be version 1)\n", (psf->peak_info)->version);
      }
    } else {
      {
#line 482
      psf_log_printf(psf, "  version    : %d\n", (psf->peak_info)->version);
      }
    }
    {
#line 484
    psf_log_printf(psf, "  time stamp : %d\n", (psf->peak_info)->timestamp);
#line 485
    psf_log_printf(psf, "    Ch   Position       Value\n");
#line 487
    cptr = (char *)psf->u.cbuf;
#line 488
    dword = (unsigned int )0;
    }
    {
#line 488
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 488
      if (! (dword < (unsigned int )psf->sf.channels)) {
#line 488
        goto while_break___0;
      }
      {
#line 491
      psf_binheader_readf(psf, "f4", & value, & position);
#line 492
      (psf->peak_info)->peaks[dword].value = (double )value;
#line 493
      (psf->peak_info)->peaks[dword].position = (sf_count_t )position;
#line 495
      snprintf(cptr, sizeof(psf->u.cbuf), "    %2d   %-12ld   %g\n", dword, (long )(psf->peak_info)->peaks[dword].position,
               (psf->peak_info)->peaks[dword].value);
#line 497
      *(cptr + (sizeof(psf->u.cbuf) - 1UL)) = (char )0;
#line 498
      psf_log_printf(psf, (char const   *)cptr);
      }
#line 488
      dword ++;
    }
    while_break___0: /* CIL Label */ ;
    }

#line 501
    if ((parsestage & 32) == 0) {
#line 501
      tmp = 42;
    } else {
#line 501
      tmp = 43;
    }
#line 501
    (psf->peak_info)->peak_loc = tmp;
#line 502
    goto switch_break;
    case_exp___6: /* CIL Label */ 
#line 505
    parsestage |= (-0x7FFFFFFF-1);
    {
#line 510
    __cil_tmp32 = psf_binheader_readf(psf, "44", & dword, & cue_count);
#line 510
    bytesread = (unsigned int )__cil_tmp32;
#line 511
    bytesread -= (unsigned int )4;
#line 512
    psf_log_printf(psf, "%M : %u\n\230\001", marker, dword);
    }
#line 514
    if (cue_count > 10U) {
      {
#line 515
      psf_log_printf(psf, "  Count : %d (skipping)\n\230\001", cue_count);
#line 516
      psf_binheader_readf(psf, "j", cue_count * 24U);
      }
#line 517
      goto switch_break;
    }
    {
#line 520
    psf_log_printf(psf, "  Count : %d\n", cue_count);
    }
    {
#line 522
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 522
      if (! cue_count) {
#line 522
        goto while_break___1;
      }
      {
#line 523
      __cil_tmp33 = psf_binheader_readf(psf, "444444", & id, & position___0, & chunk_id,
                                        & chunk_start, & block_start, & offset);
      }
      {
#line 523
      bytesread += (unsigned int )__cil_tmp33;
#line 525
      psf_log_printf(psf, "   Cue ID : %2d  Pos : %5u  Chunk : %M  Chk Start : %d  Blk Start : %d  Offset : %5d\n",
                     id, position___0, chunk_id, chunk_start, block_start, offset);
#line 530
      __cil_tmp34 = cue_count;
#line 530
      cue_count --;
      }
    }
    while_break___1: /* CIL Label */ ;
    }

#line 533
    if (bytesread != dword) {
      {
#line 534
      psf_log_printf(psf, "**** Chunk size weirdness (%d != %d)\n", dword, bytesread);
#line 535
      psf_binheader_readf(psf, "j", dword - bytesread);
      }
    }

#line 538
    goto switch_break;
    case_exp___7: /* CIL Label */ 
#line 541
    parsestage |= (-0x7FFFFFFF-1);
    {
#line 543
    psf_binheader_readf(psf, "4", & dword);
#line 544
    psf_log_printf(psf, "smpl : %u\n", dword);
#line 546
    error = wav_read_smpl_chunk(psf, dword);
    }
#line 546
    if (error) {
#line 547
      return (error);
    }
#line 548
    goto switch_break;
    case_exp___8: /* CIL Label */ 
#line 551
    parsestage |= (-0x7FFFFFFF-1);
    {
#line 553
    psf_binheader_readf(psf, "4", & dword);
#line 554
    psf_log_printf(psf, "acid : %u\n", dword);
#line 556
    error = wav_read_acid_chunk(psf, dword);
    }
#line 556
    if (error) {
#line 557
      return (error);
    }
#line 558
    goto switch_break;
    case_exp___9: /* CIL Label */ 
    case_exp___10: /* CIL Label */ 
#line 562
    parsestage |= (-0x7FFFFFFF-1);
    {
#line 564
    error = wav_subchunk_parse(psf, (int )marker);
    }
#line 564
    if (error != 0) {
#line 565
      return (error);
    }
#line 566
    goto switch_break;
    case_exp___11: /* CIL Label */ 
    {
#line 573
    psf_binheader_readf(psf, "4", & dword);
    }
    {
#line 574
    error = wav_read_bext_chunk(psf, dword);
    }
#line 574
    if (error) {
#line 575
      return (error);
    }
#line 576
    goto switch_break;
    case_exp___12: /* CIL Label */ 
    {
#line 583
    psf_binheader_readf(psf, "4", & dword);
    }
    {
#line 584
    psf_log_printf(psf, "%M : %u\n\230\001", marker, dword);
#line 585
    dword += dword & 1U;
#line 586
    psf_binheader_readf(psf, "j", dword);
    }
#line 587
    goto switch_break;
    case_exp___13: /* CIL Label */ 
    case_exp___14: /* CIL Label */ 
    case_exp___15: /* CIL Label */ 
    case_exp___16: /* CIL Label */ 
    case_exp___17: /* CIL Label */ 
    case_exp___18: /* CIL Label */ 
    case_exp___19: /* CIL Label */ 
    case_exp___20: /* CIL Label */ 
    case_exp___21: /* CIL Label */ 
    case_exp___22: /* CIL Label */ 
#line 599
    parsestage |= (-0x7FFFFFFF-1);
    {
#line 601
    psf_binheader_readf(psf, "4", & dword);
#line 602
    psf_log_printf(psf, "%M : %u\n\230\001", marker, dword);
#line 603
    dword += dword & 1U;
#line 604
    psf_binheader_readf(psf, "j", dword);
    }
#line 605
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 608
    parsestage |= (-0x7FFFFFFF-1);
    {
#line 609
    __cil_tmp42 = __ctype_b_loc();
    }
    {
#line 609
    __cil_tmp41 = __ctype_b_loc();
    }
    {
#line 609
    __cil_tmp40 = __ctype_b_loc();
    }
    {
#line 609
    __cil_tmp39 = __ctype_b_loc();
    }
#line 609
    if ((int )*(*__cil_tmp39 + (int )((marker >> 24) & 255U)) & 16384) {
#line 609
      if ((int )*(*__cil_tmp40 + (int )((marker >> 16) & 255U)) & 16384) {
#line 609
        if ((int )*(*__cil_tmp41 + (int )((marker >> 8) & 255U)) & 16384) {
#line 609
          if ((int )*(*__cil_tmp42 + (int )(marker & 255U)) & 16384) {
            {
#line 611
            psf_binheader_readf(psf, "4", & dword);
#line 612
            psf_log_printf(psf, "*** %M : %d (unknown marker)\n", marker, dword);
#line 613
            psf_binheader_readf(psf, "j", dword);
            }
#line 614
            goto switch_break;
          }
        }
      }
    }
    {
#line 616
    __cil_tmp43 = psf_ftell(psf);
    }
#line 616
    if (__cil_tmp43 & 3L) {
      {
#line 617
      psf_log_printf(psf, "  Unknown chunk marker at position %d. Resynching.\n",
                     dword - 4U);
#line 618
      psf_binheader_readf(psf, "j", - 3);
      }
#line 619
      goto switch_break;
    }
    {
#line 621
    __cil_tmp44 = psf_ftell(psf);
#line 621
    psf_log_printf(psf, "*** Unknown chunk marker (%X) at position %D. Exiting parser.\n",
                   marker, __cil_tmp44 - 4L);
#line 622
    done = (unsigned int )1;
    }
#line 623
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }

#line 626
    if (! psf->sf.seekable) {
#line 626
      if (parsestage & 32) {
#line 627
        goto while_break;
      }
    }
    {
#line 629
    __cil_tmp45 = psf_ftell(psf);
    }
#line 629
    if (__cil_tmp45 >= psf->filelength - (long )((int )sizeof(dword))) {
      {
#line 630
      psf_log_printf(psf, "End\n");
      }
#line 631
      goto while_break;
    }

  }
  while_break: /* CIL Label */ ;
  }

#line 635
  if (psf->dataoffset <= 0L) {
#line 636
    return (67);
  }
  {
#line 639
  psf->endian = psf->rwf_endian;
#line 641
  psf_fseek(psf, psf->dataoffset, 0);
  }
#line 643
  if (psf->is_pipe == 0) {
    {
#line 648
    psf_binheader_readf(psf, "4", & marker);
    }
#line 649
    if (marker == (unsigned int )(((119 | (118 << 8)) | (112 << 16)) | (107 << 24))) {
#line 650
      return (73);
    } else
#line 649
    if (marker == (unsigned int )(((79 | (103 << 8)) | (103 << 16)) | (83 << 24))) {
#line 650
      return (73);
    }
  }
  {
#line 654
  psf_fseek(psf, psf->dataoffset, 0);
  }
#line 656
  if (psf->blockwidth) {
#line 657
    if (psf->filelength - psf->dataoffset < psf->datalength) {
#line 658
      psf->sf.frames = (psf->filelength - psf->dataoffset) / (long )psf->blockwidth;
    } else {
#line 660
      psf->sf.frames = psf->datalength / (long )psf->blockwidth;
    }
  }

  {
#line 664
  if (format == 65534) {
#line 664
    goto case_65534;
  }
#line 671
  if (format == 1) {
#line 671
    goto case_1;
  }
#line 676
  if (format == 257) {
#line 676
    goto case_257;
  }
#line 676
  if (format == 7) {
#line 676
    goto case_257;
  }
#line 681
  if (format == 258) {
#line 681
    goto case_258;
  }
#line 681
  if (format == 6) {
#line 681
    goto case_258;
  }
#line 685
  if (format == 2) {
#line 685
    goto case_2;
  }
#line 691
  if (format == 17) {
#line 691
    goto case_17;
  }
#line 697
  if (format == 49) {
#line 697
    goto case_49;
  }
#line 701
  if (format == 3) {
#line 701
    goto case_3;
  }
#line 706
  if (format == 64) {
#line 706
    goto case_64;
  }
#line 710
  goto switch_default___0;
  case_65534: /* CIL Label */ 
#line 665
  if (psf->sf.format == 1245203) {
#line 666
    *blockalign = (int )wav_fmt->msadpcm.blockalign;
#line 667
    *framesperblock = (int )wav_fmt->msadpcm.samplesperblock;
  }

#line 669
  goto switch_break___0;
  case_1: /* CIL Label */ 
  {
#line 672
  __cil_tmp46 = u_bitwidth_to_subformat(psf->bytewidth * 8);
#line 672
  psf->sf.format = 65536 | __cil_tmp46;
  }
#line 673
  goto switch_break___0;
  case_257: /* CIL Label */ 
  case_7: /* CIL Label */ 
#line 677
  psf->sf.format = 65552;
#line 678
  goto switch_break___0;
  case_258: /* CIL Label */ 
  case_6: /* CIL Label */ 
#line 682
  psf->sf.format = 65553;
#line 683
  goto switch_break___0;
  case_2: /* CIL Label */ 
#line 686
  psf->sf.format = 65555;
#line 687
  *blockalign = (int )wav_fmt->msadpcm.blockalign;
#line 688
  *framesperblock = (int )wav_fmt->msadpcm.samplesperblock;
#line 689
  goto switch_break___0;
  case_17: /* CIL Label */ 
#line 692
  psf->sf.format = 65554;
#line 693
  *blockalign = (int )wav_fmt->ima.blockalign;
#line 694
  *framesperblock = (int )wav_fmt->ima.samplesperblock;
#line 695
  goto switch_break___0;
  case_49: /* CIL Label */ 
#line 698
  psf->sf.format = 65568;
#line 699
  goto switch_break___0;
  case_3: /* CIL Label */ 
#line 702
  psf->sf.format = 65536;
#line 703
  if (psf->bytewidth == 8) {
#line 703
    tmp___0 = 7;
  } else {
#line 703
    tmp___0 = 6;
  }
#line 703
  psf->sf.format |= tmp___0;
#line 704
  goto switch_break___0;
  case_64: /* CIL Label */ 
#line 707
  psf->sf.format = 65584;
#line 708
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 710
  return (17);
  switch_break___0: /* CIL Label */ ;
  }

#line 713
  if (wpriv->fmt_is_broken) {
    {
#line 714
    wav_w64_analyze(psf);
    }
  }
#line 717
  if (psf->endian == 536870912) {
#line 718
    psf->sf.format |= 536870912;
  }
#line 720
  return (0);
}
}
#line 724 "/root/libsndfile/src/wav.c"
static int wav_write_fmt_chunk(SF_PRIVATE *psf ) 
{ 
  int subformat ;
  int fmt_size ;
  int add_fact_chunk ;
  int blockalign ;
  int framesperblock ;
  int bytespersec ;
  int __cil_tmp8 ;
  int blockalign___0 ;
  int framesperblock___0 ;
  int bytespersec___0 ;
  int extrabytes ;
  int __cil_tmp13 ;
  int blockalign___1 ;
  int framesperblock___1 ;
  int bytespersec___1 ;

  {
#line 725
  add_fact_chunk = 0;
#line 727
  subformat = psf->sf.format & 65535;
  {
#line 733
  if (subformat == 4) {
#line 733
    goto case_4;
  }
#line 733
  if (subformat == 3) {
#line 733
    goto case_4;
  }
#line 733
  if (subformat == 2) {
#line 733
    goto case_4;
  }
#line 733
  if (subformat == 5) {
#line 733
    goto case_4;
  }
#line 745
  if (subformat == 7) {
#line 745
    goto case_7;
  }
#line 745
  if (subformat == 6) {
#line 745
    goto case_7;
  }
#line 758
  if (subformat == 16) {
#line 758
    goto case_16;
  }
#line 771
  if (subformat == 17) {
#line 771
    goto case_17;
  }
#line 785
  if (subformat == 18) {
#line 785
    goto case_18;
  }
#line 806
  if (subformat == 19) {
#line 806
    goto case_19;
  }
#line 833
  if (subformat == 48) {
#line 833
    goto case_48;
  }
#line 849
  if (subformat == 32) {
#line 849
    goto case_32;
  }
#line 872
  goto switch_default;
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 734
  fmt_size = 16;
  {
#line 737
  psf_binheader_writef(psf, "4224", fmt_size, 1, psf->sf.channels, psf->sf.samplerate);
#line 739
  psf_binheader_writef(psf, "4", (psf->sf.samplerate * psf->bytewidth) * psf->sf.channels);
#line 741
  psf_binheader_writef(psf, "22\a\373\036V", psf->bytewidth * psf->sf.channels, psf->bytewidth * 8);
  }
#line 742
  goto switch_break;
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
#line 746
  fmt_size = 16;
  {
#line 749
  psf_binheader_writef(psf, "4224", fmt_size, 3, psf->sf.channels, psf->sf.samplerate);
#line 751
  psf_binheader_writef(psf, "4\301\a\373\036V", (psf->sf.samplerate * psf->bytewidth) * psf->sf.channels);
#line 753
  psf_binheader_writef(psf, "22", psf->bytewidth * psf->sf.channels, psf->bytewidth * 8);
#line 755
  add_fact_chunk = 1;
  }
#line 756
  goto switch_break;
  case_16: /* CIL Label */ 
#line 759
  fmt_size = 16;
  {
#line 762
  psf_binheader_writef(psf, "4224", fmt_size, 7, psf->sf.channels, psf->sf.samplerate);
#line 764
  psf_binheader_writef(psf, "4\240\a\373\036V", (psf->sf.samplerate * psf->bytewidth) * psf->sf.channels);
#line 766
  psf_binheader_writef(psf, "22\a\373\036V", psf->bytewidth * psf->sf.channels, 8);
#line 768
  add_fact_chunk = 1;
  }
#line 769
  goto switch_break;
  case_17: /* CIL Label */ 
#line 772
  fmt_size = 16;
  {
#line 775
  psf_binheader_writef(psf, "4224", fmt_size, 6, psf->sf.channels, psf->sf.samplerate);
#line 777
  psf_binheader_writef(psf, "4", (psf->sf.samplerate * psf->bytewidth) * psf->sf.channels);
#line 779
  psf_binheader_writef(psf, "22\a\373\036V", psf->bytewidth * psf->sf.channels, 8);
#line 781
  add_fact_chunk = 1;
  }
#line 782
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 788
  blockalign = wav_w64_srate2blocksize(psf->sf.samplerate * psf->sf.channels);
#line 789
  framesperblock = (2 * (blockalign - 4 * psf->sf.channels)) / psf->sf.channels + 1;
#line 790
  bytespersec = (psf->sf.samplerate * blockalign) / framesperblock;
#line 793
  fmt_size = 20;
#line 796
  psf_binheader_writef(psf, "42244", fmt_size, 17, psf->sf.channels, psf->sf.samplerate,
                       bytespersec);
#line 800
  psf_binheader_writef(psf, "2222\036V", blockalign, 4, 2, framesperblock);
  }
#line 803
  add_fact_chunk = 1;
#line 804
  goto switch_break;
  case_19: /* CIL Label */ 
  {
#line 809
  blockalign___0 = wav_w64_srate2blocksize(psf->sf.samplerate * psf->sf.channels);
#line 810
  framesperblock___0 = 2 + (2 * (blockalign___0 - 7 * psf->sf.channels)) / psf->sf.channels;
#line 811
  bytespersec___0 = (psf->sf.samplerate * blockalign___0) / framesperblock___0;
#line 814
  extrabytes = 32;
#line 815
  fmt_size = 18 + extrabytes;
#line 818
  psf_binheader_writef(psf, "422\373\036V", fmt_size, 2, psf->sf.channels);
#line 821
  psf_binheader_writef(psf, "44", psf->sf.samplerate, bytespersec___0);
#line 824
  psf_binheader_writef(psf, "22222", blockalign___0, 4, extrabytes, framesperblock___0,
                       7);
#line 826
  msadpcm_write_adapt_coeffs(psf);
  }
#line 829
  add_fact_chunk = 1;
#line 830
  goto switch_break;
  case_48: /* CIL Label */ 
#line 835
  fmt_size = 20;
  {
#line 838
  psf_binheader_writef(psf, "42244", fmt_size, 64, psf->sf.channels, psf->sf.samplerate,
                       (psf->sf.samplerate * psf->sf.channels) / 2);
#line 842
  psf_binheader_writef(psf, "2222", 64, 4, 2, 0);
#line 844
  add_fact_chunk = 1;
  }
#line 845
  goto switch_break;
  case_32: /* CIL Label */ 
  {
#line 852
  blockalign___1 = 65;
#line 853
  framesperblock___1 = 320;
#line 854
  bytespersec___1 = (psf->sf.samplerate * blockalign___1) / framesperblock___1;
#line 857
  fmt_size = 20;
#line 860
  psf_binheader_writef(psf, "422\373\036V", fmt_size, 49, psf->sf.channels);
#line 863
  psf_binheader_writef(psf, "44\a\373\036V", psf->sf.samplerate, bytespersec___1);
#line 866
  psf_binheader_writef(psf, "2222", blockalign___1, 0, 2, framesperblock___1);
  }
#line 869
  add_fact_chunk = 1;
#line 870
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 872
  return (17);
  switch_break: /* CIL Label */ ;
  }

#line 875
  if (add_fact_chunk) {
    {
#line 876
    psf_binheader_writef(psf, "tm48\036V", ((102 | (97 << 8)) | (99 << 16)) | (116 << 24),
                         4, psf->sf.frames);
    }
  }
#line 878
  return (0);
}
}
#line 882 "/root/libsndfile/src/wav.c"
static int wavex_write_fmt_chunk___0(SF_PRIVATE *psf ) 
{ 
  WAV_PRIVATE *wpriv ;
  int subformat ;
  int fmt_size ;
  int add_fact_chunk ;
  EXT_SUBFORMAT *tmp ;
  EXT_SUBFORMAT *tmp___0 ;

  {
#line 884
  add_fact_chunk = 0;
#line 886
  wpriv = psf->container_data;
#line 886
  if (wpriv == (void *)0) {
#line 887
    return (29);
  }
#line 889
  subformat = psf->sf.format & 65535;
  {
#line 900
  if (subformat == 17) {
#line 900
    goto case_17;
  }
#line 900
  if (subformat == 16) {
#line 900
    goto case_17;
  }
#line 900
  if (subformat == 7) {
#line 900
    goto case_17;
  }
#line 900
  if (subformat == 6) {
#line 900
    goto case_17;
  }
#line 900
  if (subformat == 4) {
#line 900
    goto case_17;
  }
#line 900
  if (subformat == 3) {
#line 900
    goto case_17;
  }
#line 900
  if (subformat == 2) {
#line 900
    goto case_17;
  }
#line 900
  if (subformat == 5) {
#line 900
    goto case_17;
  }
#line 928
  if (subformat == 1) {
#line 928
    goto case_1;
  }
#line 932
  if (subformat == 2) {
#line 932
    goto case_2___0;
  }
#line 936
  if (subformat == 4) {
#line 936
    goto case_4___0;
  }
#line 940
  if (subformat == 6) {
#line 940
    goto case_6___0;
  }
#line 944
  if (subformat == 8) {
#line 944
    goto case_8;
  }
#line 956
  goto switch_default___0;
  case_17: /* CIL Label */ 
  case_16: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 901
  fmt_size = 40;
  {
#line 904
  psf_binheader_writef(psf, "4224\036V", fmt_size, 65534, psf->sf.channels, psf->sf.samplerate);
#line 906
  psf_binheader_writef(psf, "49\b\373\036V", (psf->sf.samplerate * psf->bytewidth) * psf->sf.channels);
#line 908
  psf_binheader_writef(psf, "22\b\373\036V", psf->bytewidth * psf->sf.channels, psf->bytewidth * 8);
#line 911
  psf_binheader_writef(psf, "2A\b\373\036V", 22);
#line 914
  psf_binheader_writef(psf, "2", psf->bytewidth * 8);
  }
#line 919
  if (wpriv->wavex_ambisonic != 64) {
    {
#line 920
    psf_binheader_writef(psf, "4C\b\373\036V", 0);
    }
  } else {
    {
#line 928
    if (psf->sf.channels == 1) {
#line 928
      goto case_1;
    }
#line 932
    if (psf->sf.channels == 2) {
#line 932
      goto case_2___0;
    }
#line 936
    if (psf->sf.channels == 4) {
#line 936
      goto case_4___0;
    }
#line 940
    if (psf->sf.channels == 6) {
#line 940
      goto case_6___0;
    }
#line 944
    if (psf->sf.channels == 8) {
#line 944
      goto case_8;
    }
#line 948
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 929
    psf_binheader_writef(psf, "4", 4);
    }
#line 930
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
    {
#line 933
    psf_binheader_writef(psf, "4", 3);
    }
#line 934
    goto switch_break___0;
    case_4___0: /* CIL Label */ 
    {
#line 937
    psf_binheader_writef(psf, "4", 51);
    }
#line 938
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
    {
#line 941
    psf_binheader_writef(psf, "4", 63);
    }
#line 942
    goto switch_break___0;
    case_8: /* CIL Label */ 
    {
#line 945
    psf_binheader_writef(psf, "4\034\b\373\036V", 255);
    }
#line 946
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 949
    psf_binheader_writef(psf, "4\025\b\373\036V", 0);
    }
#line 950
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }

  }

#line 953
  goto switch_break;
  switch_default___0: /* CIL Label */ 
  case_19: /* CIL Label */ 
#line 957
  return (17);
  switch_break: /* CIL Label */ ;
  }

  {
#line 966
  if (subformat == 4) {
#line 966
    goto case_4___1;
  }
#line 966
  if (subformat == 3) {
#line 966
    goto case_4___1;
  }
#line 966
  if (subformat == 2) {
#line 966
    goto case_4___1;
  }
#line 966
  if (subformat == 5) {
#line 966
    goto case_4___1;
  }
#line 972
  if (subformat == 7) {
#line 972
    goto case_7___0;
  }
#line 972
  if (subformat == 6) {
#line 972
    goto case_7___0;
  }
#line 978
  if (subformat == 16) {
#line 978
    goto case_16___0;
  }
#line 983
  if (subformat == 17) {
#line 983
    goto case_17___0;
  }
#line 997
  goto switch_default___1;
  case_4___1: /* CIL Label */ 
  case_3___0: /* CIL Label */ 
  case_2___1: /* CIL Label */ 
  case_5___0: /* CIL Label */ 
#line 967
  if (wpriv->wavex_ambisonic == 64) {
#line 967
    tmp = & MSGUID_SUBTYPE_PCM___0;
  } else {
#line 967
    tmp = & MSGUID_SUBTYPE_AMBISONIC_B_FORMAT_PCM___0;
  }
  {
#line 967
  wavex_write_guid(psf, tmp);
  }
#line 969
  goto switch_break___1;
  case_7___0: /* CIL Label */ 
  case_6___1: /* CIL Label */ 
#line 973
  if (wpriv->wavex_ambisonic == 64) {
#line 973
    tmp___0 = & MSGUID_SUBTYPE_IEEE_FLOAT___0;
  } else {
#line 973
    tmp___0 = & MSGUID_SUBTYPE_AMBISONIC_B_FORMAT_IEEE_FLOAT___0;
  }
  {
#line 973
  wavex_write_guid(psf, tmp___0);
#line 975
  add_fact_chunk = 1;
  }
#line 976
  goto switch_break___1;
  case_16___0: /* CIL Label */ 
  {
#line 979
  wavex_write_guid(psf, & MSGUID_SUBTYPE_MULAW___0);
  }
#line 980
  add_fact_chunk = 1;
#line 981
  goto switch_break___1;
  case_17___0: /* CIL Label */ 
  {
#line 984
  wavex_write_guid(psf, & MSGUID_SUBTYPE_ALAW___0);
  }
#line 985
  add_fact_chunk = 1;
#line 986
  goto switch_break___1;
  switch_default___1: /* CIL Label */ 
#line 997
  return (17);
  switch_break___1: /* CIL Label */ ;
  }

#line 1000
  if (add_fact_chunk) {
    {
#line 1001
    psf_binheader_writef(psf, "tm48\036V", ((102 | (97 << 8)) | (99 << 16)) | (116 << 24),
                         4, psf->sf.frames);
    }
  }
#line 1003
  return (0);
}
}
#line 1008 "/root/libsndfile/src/wav.c"
static int wav_write_header(SF_PRIVATE *psf , int calc_length ) 
{ 
  sf_count_t current ;
  int k ;
  int error ;
  int has_data ;
  sf_count_t __cil_tmp7 ;
  sf_count_t __cil_tmp8 ;
  long tmp ;
  long tmp___0 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  time_t __cil_tmp13 ;
  int __cil_tmp14 ;
  int tmp___1 ;
  double dtune ;
  int type ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int __cil_tmp21 ;
  size_t __cil_tmp22 ;

  {
  {
#line 1010
  has_data = 0;
#line 1012
  current = psf_ftell(psf);
  }
#line 1014
  if (current > psf->dataoffset) {
#line 1015
    has_data = 1;
  }
#line 1017
  if (calc_length) {
    {
#line 1018
    psf->filelength = psf_get_filelen(psf);
#line 1020
    psf->datalength = psf->filelength - psf->dataoffset;
    }
#line 1022
    if (psf->dataend) {
#line 1023
      psf->datalength -= psf->filelength - psf->dataend;
    }
#line 1025
    if (psf->bytewidth > 0) {
#line 1026
      psf->sf.frames = psf->datalength / (long )(psf->bytewidth * psf->sf.channels);
    }
  }
  {
#line 1030
  psf->header[0] = (unsigned char )0;
#line 1031
  psf->headindex = 0;
#line 1032
  psf_fseek(psf, (sf_count_t )0, 0);
  }
#line 1042
  if (psf->endian == 268435456) {
#line 1043
    if (psf->filelength < 8L) {
#line 1043
      tmp = (long )8;
    } else {
#line 1043
      tmp = psf->filelength - 8L;
    }
    {
#line 1043
    psf_binheader_writef(psf, "etm8", ((82 | (73 << 8)) | (70 << 16)) | (70 << 24),
                         tmp);
    }
  } else {
#line 1045
    if (psf->filelength < 8L) {
#line 1045
      tmp___0 = (long )8;
    } else {
#line 1045
      tmp___0 = psf->filelength - 8L;
    }
    {
#line 1045
    psf_binheader_writef(psf, "Etm8", ((82 | (73 << 8)) | (70 << 16)) | (88 << 24),
                         tmp___0);
    }
  }
  {
#line 1048
  psf_binheader_writef(psf, "mm", ((87 | (65 << 8)) | (86 << 16)) | (69 << 24), ((102 | (109 << 8)) | (116 << 16)) | (32 << 24));
  }
  {
#line 1052
  if ((psf->sf.format & 268369920) == 65536) {
#line 1052
    goto case_65536;
  }
#line 1057
  if ((psf->sf.format & 268369920) == 1245184) {
#line 1057
    goto case_1245184;
  }
#line 1062
  goto switch_default;
  case_65536: /* CIL Label */ 
  {
#line 1053
  error = wav_write_fmt_chunk(psf);
  }
#line 1053
  if (error != 0) {
#line 1054
    return (error);
  }
#line 1055
  goto switch_break;
  case_1245184: /* CIL Label */ 
  {
#line 1058
  error = wavex_write_fmt_chunk___0(psf);
  }
#line 1058
  if (error != 0) {
#line 1059
    return (error);
  }
#line 1060
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1063
  return (17);
  switch_break: /* CIL Label */ ;
  }

#line 1067
  if (psf->str_flags & 1024) {
    {
#line 1068
    wav_write_strings(psf, 1024);
    }
  }
#line 1070
  if (psf->peak_info != (void *)0) {
#line 1070
    if ((psf->peak_info)->peak_loc == 42) {
      {
#line 1071
      psf_binheader_writef(psf, "m4\b\373\036V", ((80 | (69 << 8)) | (65 << 16)) | (75 << 24),
                           2UL * sizeof(int ) + (unsigned long )psf->sf.channels * (sizeof(float ) + sizeof(int )));
#line 1072
      __cil_tmp13 = time((time_t *)((void *)0));
#line 1072
      psf_binheader_writef(psf, "44\b\373\036V", 1, __cil_tmp13);
#line 1073
      k = 0;
      }
      {
#line 1073
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1073
        if (! (k < psf->sf.channels)) {
#line 1073
          goto while_break;
        }
        {
#line 1074
        psf_binheader_writef(psf, "ft8\373\036V", (double )((float )(psf->peak_info)->peaks[k].value),
                             (psf->peak_info)->peaks[k].position);
        }
#line 1073
        k ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }

#line 1077
  if (psf->broadcast_var != (void *)0) {
    {
#line 1078
    wav_write_bext_chunk(psf);
    }
  }
#line 1080
  if (psf->instrument != (void *)0) {
    {
#line 1082
    dtune = (double )1073741824 / 25.;
#line 1084
    psf_binheader_writef(psf, "m4", ((115 | (109 << 8)) | (112 << 16)) | (108 << 24),
                         36 + ((psf->instrument)->loop_count * 6) * 4);
#line 1085
    psf_binheader_writef(psf, "44\b\373\036V", 0, 0);
#line 1086
    tmp___1 = (int )(1000000000. / (double )psf->sf.samplerate);
#line 1087
    psf_binheader_writef(psf, "44\b\373\036V", tmp___1, (int )(psf->instrument)->basenote);
#line 1088
    tmp___1 = (int )((unsigned int )((double )((int )(psf->instrument)->detune) * dtune + 0.5));
#line 1089
    psf_binheader_writef(psf, "4;\b\373\036V", tmp___1);
#line 1090
    psf_binheader_writef(psf, "44\006\373\036V", 0, 0);
#line 1091
    psf_binheader_writef(psf, "44\006\373\036V", (psf->instrument)->loop_count, 0);
#line 1093
    tmp___1 = 0;
    }
    {
#line 1093
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1093
      if (! (tmp___1 < (psf->instrument)->loop_count)) {
#line 1093
        goto while_break___0;
      }
#line 1096
      type = (psf->instrument)->loops[tmp___1].mode;
#line 1097
      if (type == 801) {
#line 1097
        tmp___17 = 0;
      } else {
#line 1097
        if (type == 802) {
#line 1097
          tmp___16 = 2;
        } else {
#line 1097
          if (type == 803) {
#line 1097
            tmp___15 = 1;
          } else {
#line 1097
            tmp___15 = 32;
          }
#line 1097
          tmp___16 = tmp___15;
        }
#line 1097
        tmp___17 = tmp___16;
      }
      {
#line 1097
      type = tmp___17;
#line 1099
      psf_binheader_writef(psf, "44", tmp___1, type);
#line 1100
      psf_binheader_writef(psf, "44", (psf->instrument)->loops[tmp___1].start, (psf->instrument)->loops[tmp___1].end);
#line 1101
      psf_binheader_writef(psf, "44", 0, (psf->instrument)->loops[tmp___1].count);
      }
#line 1093
      tmp___1 ++;
    }
    while_break___0: /* CIL Label */ ;
    }

  }

#line 1105
  if ((long )(psf->headindex + 16) < psf->dataoffset) {
    {
#line 1107
    k = (int )(psf->dataoffset - (long )(psf->headindex + 16));
#line 1108
    __cil_tmp22 = make_size_t(k);
#line 1108
    psf_binheader_writef(psf, "m4z", ((80 | (65 << 8)) | (68 << 16)) | (32 << 24),
                         k, __cil_tmp22);
    }
  }
  {
#line 1111
  psf_binheader_writef(psf, "tm8", ((100 | (97 << 8)) | (116 << 16)) | (97 << 24),
                       psf->datalength);
#line 1112
  psf_fwrite((unsigned char *)psf->header, (sf_count_t )psf->headindex, (sf_count_t )1,
             psf);
  }
#line 1113
  if (psf->error) {
#line 1114
    return (psf->error);
  }
#line 1116
  if (has_data) {
#line 1116
    if (psf->dataoffset != (long )psf->headindex) {
      {
#line 1117
      psf_log_printf(psf, "Oooops : has_data && psf->dataoffset != psf->headindex\n");
#line 1118
      psf->error = 29;
      }
#line 1118
      return (psf->error);
    }
  }
#line 1121
  psf->dataoffset = (sf_count_t )psf->headindex;
#line 1123
  if (! has_data) {
    {
#line 1124
    psf_fseek(psf, psf->dataoffset, 0);
    }
  } else
#line 1125
  if (current > 0L) {
    {
#line 1126
    psf_fseek(psf, current, 0);
    }
  }
#line 1128
  return (psf->error);
}
}
#line 1133 "/root/libsndfile/src/wav.c"
static int wav_write_tailer(SF_PRIVATE *psf ) 
{ 
  int k ;
  sf_count_t __cil_tmp3 ;
  time_t __cil_tmp4 ;
  int __cil_tmp5 ;

  {
#line 1137
  psf->header[0] = (unsigned char )0;
#line 1138
  psf->headindex = 0;
#line 1140
  if (psf->dataend > 0L) {
    {
#line 1141
    psf_fseek(psf, psf->dataend, 0);
    }
  } else {
    {
#line 1143
    psf->dataend = psf_fseek(psf, (sf_count_t )0, 2);
    }
  }
#line 1146
  if (psf->peak_info != (void *)0) {
#line 1146
    if ((psf->peak_info)->peak_loc == 43) {
      {
#line 1147
      psf_binheader_writef(psf, "m4", ((80 | (69 << 8)) | (65 << 16)) | (75 << 24),
                           2UL * sizeof(int ) + (unsigned long )psf->sf.channels * (sizeof(float ) + sizeof(int )));
#line 1148
      __cil_tmp4 = time((time_t *)((void *)0));
#line 1148
      psf_binheader_writef(psf, "44\006\373\036V", 1, __cil_tmp4);
#line 1149
      k = 0;
      }
      {
#line 1149
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1149
        if (! (k < psf->sf.channels)) {
#line 1149
          goto while_break;
        }
        {
#line 1150
        psf_binheader_writef(psf, "f4\006\373\036V", (psf->peak_info)->peaks[k].value,
                             (psf->peak_info)->peaks[k].position);
        }
#line 1149
        k ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }

#line 1153
  if (psf->str_flags & 2048) {
    {
#line 1154
    wav_write_strings(psf, 2048);
    }
  }
#line 1157
  if (psf->headindex > 0) {
    {
#line 1158
    psf_fwrite((unsigned char *)psf->header, (sf_count_t )psf->headindex, (sf_count_t )1,
               psf);
    }
  }
#line 1160
  return (0);
}
}
#line 1164 "/root/libsndfile/src/wav.c"
static void wav_write_strings(SF_PRIVATE *psf , int location ) 
{ 
  int k ;
  int prev_head_index ;
  int saved_head_index ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 1167
  __cil_tmp6 = psf_location_string_count(psf, location);
  }
#line 1167
  if (__cil_tmp6 == 0) {
#line 1168
    return;
  }
  {
#line 1170
  prev_head_index = psf->headindex + 4;
#line 1172
  psf_binheader_writef(psf, "m4m\373\036V", ((76 | (73 << 8)) | (83 << 16)) | (84 << 24),
                       12245933, ((73 | (78 << 8)) | (70 << 16)) | (79 << 24));
#line 1174
  k = 0;
  }
  {
#line 1174
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1174
    if (! (k < 32)) {
#line 1174
      goto while_break;
    }
#line 1175
    if (psf->strings[k].type == 0) {
#line 1176
      goto while_break;
    }
#line 1177
    if (psf->strings[k].type < 0) {
#line 1178
      goto while_continue;
    } else
#line 1177
    if (psf->strings[k].flags != location) {
#line 1178
      goto while_continue;
    }
    {
#line 1181
    if (psf->strings[k].type == 3) {
#line 1181
      goto case_3;
    }
#line 1185
    if (psf->strings[k].type == 1) {
#line 1185
      goto case_1;
    }
#line 1189
    if (psf->strings[k].type == 2) {
#line 1189
      goto case_2;
    }
#line 1193
    if (psf->strings[k].type == 4) {
#line 1193
      goto case_4;
    }
#line 1197
    if (psf->strings[k].type == 5) {
#line 1197
      goto case_5;
    }
#line 1201
    if (psf->strings[k].type == 6) {
#line 1201
      goto case_6;
    }
#line 1205
    goto switch_default;
    case_3: /* CIL Label */ 
    {
#line 1182
    psf_binheader_writef(psf, "ms\b\373\036V", ((73 | (83 << 8)) | (70 << 16)) | (84 << 24),
                         psf->strings[k].str);
    }
#line 1183
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 1186
    psf_binheader_writef(psf, "ms", ((73 | (78 << 8)) | (65 << 16)) | (77 << 24),
                         psf->strings[k].str);
    }
#line 1187
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 1190
    psf_binheader_writef(psf, "ms", ((73 | (67 << 8)) | (79 << 16)) | (80 << 24),
                         psf->strings[k].str);
    }
#line 1191
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 1194
    psf_binheader_writef(psf, "ms\b\373\036V", ((73 | (65 << 8)) | (82 << 16)) | (84 << 24),
                         psf->strings[k].str);
    }
#line 1195
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 1198
    psf_binheader_writef(psf, "ms\t\373\036V", ((73 | (67 << 8)) | (77 << 16)) | (84 << 24),
                         psf->strings[k].str);
    }
#line 1199
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 1202
    psf_binheader_writef(psf, "ms", ((73 | (67 << 8)) | (82 << 16)) | (68 << 24),
                         psf->strings[k].str);
    }
#line 1203
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1206
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }

#line 1174
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1210
  saved_head_index = psf->headindex;
#line 1211
  psf->headindex = prev_head_index;
#line 1212
  psf_binheader_writef(psf, "49\t\373\036V", (saved_head_index - prev_head_index) - 4);
#line 1213
  psf->headindex = saved_head_index;
  }
  return;
}
}
#line 1218 "/root/libsndfile/src/wav.c"
static int wav_close(SF_PRIVATE *psf ) 
{ 
  sf_count_t current ;
  sf_count_t __cil_tmp3 ;

  {
#line 1220
  if (psf->mode == 32) {
    _L: /* CIL Label */ 
    {
#line 1221
    wav_write_tailer(psf);
    }
#line 1223
    if (psf->mode == 48) {
      {
#line 1224
      __cil_tmp3 = psf_ftell(psf);
#line 1224
      current = __cil_tmp3;
      }
#line 1231
      if (current < psf->filelength) {
        {
#line 1232
        psf_ftruncate(psf, current);
#line 1233
        psf->filelength = current;
        }
      }

    }
    {
#line 1237
    (*(psf->write_header))(psf, 1);
    }
  } else
#line 1220
  if (psf->mode == 48) {
#line 1220
    goto _L;
  }

#line 1240
  return (0);
}
}
#line 1244 "/root/libsndfile/src/wav.c"
static int wav_command(SF_PRIVATE *psf , int command , void *UNUSED_data , int datasize ) 
{ 
  WAV_PRIVATE *wpriv ;

  {
#line 1247
  wpriv = psf->container_data;
#line 1247
  if (wpriv == (void *)0) {
#line 1248
    return (29);
  }
  {
#line 1251
  if (command == 4608) {
#line 1251
    goto case_4608;
  }
#line 1262
  if (command == 4609) {
#line 1262
    goto case_4609;
  }
#line 1265
  goto switch_default;
  case_4608: /* CIL Label */ 
#line 1252
  if ((psf->sf.format & 268369920) == 1245184) {
#line 1253
    if (datasize == 64) {
#line 1254
      wpriv->wavex_ambisonic = 64;
    } else
#line 1255
    if (datasize == 65) {
#line 1256
      wpriv->wavex_ambisonic = 65;
    } else {
#line 1258
      return (0);
    }
  }

#line 1260
  return (wpriv->wavex_ambisonic);
  case_4609: /* CIL Label */ 
#line 1263
  return (wpriv->wavex_ambisonic);
  switch_default: /* CIL Label */ 
#line 1266
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }

#line 1269
  return (0);
}
}
#line 1273 "/root/libsndfile/src/wav.c"
static int wav_subchunk_parse(SF_PRIVATE *psf , int chunk ) 
{ 
  sf_count_t current_pos ;
  char *cptr ;
  unsigned int dword ;
  unsigned int bytesread ;
  unsigned int length ;
  sf_count_t __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int mark_id ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  sf_count_t __cil_tmp17 ;
  sf_count_t __cil_tmp18 ;

  {
  {
#line 1278
  current_pos = psf_fseek(psf, (sf_count_t )0, 1);
#line 1280
  __cil_tmp9 = psf_binheader_readf(psf, "4", & length);
#line 1280
  bytesread = (unsigned int )__cil_tmp9;
  }
#line 1282
  if (length <= 8U) {
    {
#line 1284
    psf_log_printf(psf, "%M : %d (weird length)\n", chunk, length);
#line 1285
    psf_binheader_readf(psf, "mj", & chunk, length - 4U);
#line 1286
    psf_log_printf(psf, "  %M\n", chunk);
    }
#line 1287
    return (0);
  }

#line 1290
  if ((unsigned int )psf->headindex + length > (unsigned int )((int )sizeof(psf->header))) {
    {
#line 1291
    psf_log_printf(psf, "%M : %d (too long)\n\373\036V", chunk, length);
#line 1292
    psf_binheader_readf(psf, "j\253\317\372\036V", length);
    }
#line 1293
    return (0);
  }

#line 1296
  if (current_pos + (long )length > psf->filelength) {
    {
#line 1297
    psf_log_printf(psf, "%M : %d (should be %d)\n", chunk, length, (int )(psf->filelength - current_pos));
#line 1298
    length = (unsigned int )(psf->filelength - current_pos);
    }
  } else {
    {
#line 1301
    psf_log_printf(psf, "%M : %d\n\230\001", chunk, length);
    }
  }
  {
#line 1303
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1303
    if (! (bytesread < length)) {
#line 1303
      goto while_break;
    }
    {
#line 1304
    __cil_tmp10 = psf_binheader_readf(psf, "mo\t\373\036V", & chunk);
    }
#line 1304
    bytesread += (unsigned int )__cil_tmp10;
    {
#line 1308
    if (chunk == (((73 | (78 << 8)) | (70 << 16)) | (79 << 24))) {
#line 1308
      goto case_exp;
    }
#line 1308
    if (chunk == (((97 | (100 << 8)) | (116 << 16)) | (108 << 24))) {
#line 1308
      goto case_exp;
    }
#line 1313
    if (chunk == (((100 | (97 << 8)) | (116 << 16)) | (97 << 24))) {
#line 1313
      goto case_exp___1;
    }
#line 1330
    if (chunk == (((73 | (83 << 8)) | (82 << 16)) | (67 << 24))) {
#line 1330
      goto case_exp___2;
    }
#line 1330
    if (chunk == (((73 | (83 << 8)) | (66 << 16)) | (74 << 24))) {
#line 1330
      goto case_exp___2;
    }
#line 1330
    if (chunk == (((73 | (80 << 8)) | (82 << 16)) | (68 << 24))) {
#line 1330
      goto case_exp___2;
    }
#line 1330
    if (chunk == (((73 | (78 << 8)) | (65 << 16)) | (77 << 24))) {
#line 1330
      goto case_exp___2;
    }
#line 1330
    if (chunk == (((73 | (69 << 8)) | (78 << 16)) | (71 << 24))) {
#line 1330
      goto case_exp___2;
    }
#line 1330
    if (chunk == (((73 | (67 << 8)) | (82 << 16)) | (68 << 24))) {
#line 1330
      goto case_exp___2;
    }
#line 1330
    if (chunk == (((73 | (67 << 8)) | (77 << 16)) | (84 << 24))) {
#line 1330
      goto case_exp___2;
    }
#line 1330
    if (chunk == (((73 | (65 << 8)) | (82 << 16)) | (84 << 24))) {
#line 1330
      goto case_exp___2;
    }
#line 1330
    if (chunk == (((73 | (65 << 8)) | (82 << 16)) | (76 << 24))) {
#line 1330
      goto case_exp___2;
    }
#line 1330
    if (chunk == (((73 | (67 << 8)) | (79 << 16)) | (80 << 24))) {
#line 1330
      goto case_exp___2;
    }
#line 1330
    if (chunk == (((73 | (83 << 8)) | (70 << 16)) | (84 << 24))) {
#line 1330
      goto case_exp___2;
    }
#line 1346
    if (chunk == (((108 | (97 << 8)) | (98 << 16)) | (108 << 24))) {
#line 1346
      goto case_exp___13;
    }
#line 1369
    if (chunk == (((110 | (111 << 8)) | (116 << 16)) | (101 << 24))) {
#line 1369
      goto case_exp___14;
    }
#line 1369
    if (chunk == (((108 | (116 << 8)) | (120 << 16)) | (116 << 24))) {
#line 1369
      goto case_exp___14;
    }
#line 1369
    if (chunk == (((68 | (73 << 8)) | (83 << 16)) | (80 << 24))) {
#line 1369
      goto case_exp___14;
    }
#line 1377
    if (chunk == (((101 | (120 << 8)) | (105 << 16)) | (102 << 24))) {
#line 1377
      goto case_exp___17;
    }
#line 1382
    if (chunk == 0) {
#line 1382
      goto case_0;
    }
#line 1393
    goto switch_default;
    case_exp: /* CIL Label */ 
    case_exp___0: /* CIL Label */ 
    {
#line 1310
    psf_log_printf(psf, "  %M\n", chunk);
    }
#line 1311
    goto switch_break;
    case_exp___1: /* CIL Label */ 
    {
#line 1314
    psf_log_printf(psf, "  %M inside a LIST block??? Backing out.\n", chunk);
    }
    {
#line 1316
    psf_binheader_readf(psf, "j|\b\373\036V", - 4);
    }
#line 1317
    return (0);
    case_exp___2: /* CIL Label */ 
    case_exp___3: /* CIL Label */ 
    case_exp___4: /* CIL Label */ 
    case_exp___5: /* CIL Label */ 
    case_exp___6: /* CIL Label */ 
    case_exp___7: /* CIL Label */ 
    case_exp___8: /* CIL Label */ 
    case_exp___9: /* CIL Label */ 
    case_exp___10: /* CIL Label */ 
    case_exp___11: /* CIL Label */ 
    case_exp___12: /* CIL Label */ 
    {
#line 1331
    __cil_tmp11 = psf_binheader_readf(psf, "4", & dword);
    }
#line 1331
    bytesread += (unsigned int )__cil_tmp11;
#line 1332
    dword += dword & 1U;
#line 1333
    if (dword >= (unsigned int )((int )sizeof(psf->u.cbuf))) {
      {
#line 1334
      psf_log_printf(psf, "  *** %M : %d (too big)\n\230\001", chunk, dword);
#line 1335
      psf_binheader_readf(psf, "j", dword);
      }
#line 1336
      goto switch_break;
    }
    {
#line 1339
    cptr = (char *)psf->u.cbuf;
#line 1340
    psf_binheader_readf(psf, "b", cptr, dword);
#line 1341
    bytesread += dword;
#line 1342
    *(cptr + dword) = (char )0;
#line 1343
    psf_log_printf(psf, "    %M : %s\n", chunk, cptr);
    }
#line 1344
    goto switch_break;
    case_exp___13: /* CIL Label */ 
    {
#line 1349
    __cil_tmp13 = psf_binheader_readf(psf, "44", & dword, & mark_id);
    }
#line 1349
    bytesread += (unsigned int )__cil_tmp13;
#line 1350
    dword -= (unsigned int )4;
#line 1351
    dword += dword & 1U;
#line 1352
    if (dword < 1U) {
      {
      {
#line 1353
      psf_log_printf(psf, "  *** %M : %d (too big)\n\230\001", chunk, dword);
      }
      {
#line 1354
      psf_binheader_readf(psf, "j", dword);
      }
      }
#line 1355
      goto switch_break;
    } else
#line 1352
    if (dword >= (unsigned int )((int )sizeof(psf->u.cbuf))) {
      {
      {
#line 1353
      psf_log_printf(psf, "  *** %M : %d (too big)\n\230\001", chunk, dword);
      }
      {
#line 1354
      psf_binheader_readf(psf, "j", dword);
      }
      }
#line 1355
      goto switch_break;
    }
    {
#line 1358
    cptr = (char *)psf->u.cbuf;
#line 1359
    psf_binheader_readf(psf, "b", cptr, dword);
#line 1360
    bytesread += dword;
#line 1361
    *(cptr + dword) = (char )0;
#line 1362
    psf_log_printf(psf, "    %M : %d : %s\n", chunk, mark_id, cptr);
    }
#line 1364
    goto switch_break;
    case_exp___14: /* CIL Label */ 
    case_exp___15: /* CIL Label */ 
    case_exp___16: /* CIL Label */ 
    {
#line 1370
    __cil_tmp14 = psf_binheader_readf(psf, "4", & dword);
    }
    {
#line 1370
    bytesread += (unsigned int )__cil_tmp14;
#line 1371
    dword += dword & 1U;
#line 1372
    psf_binheader_readf(psf, "j", dword);
#line 1373
    bytesread += dword;
#line 1374
    psf_log_printf(psf, "    %M : %d\n", chunk, dword);
    }
#line 1375
    goto switch_break;
    case_exp___17: /* CIL Label */ 
    {
#line 1378
    psf_log_printf(psf, "  %M\n", chunk);
    }
    {
#line 1379
    __cil_tmp15 = exif_subchunk_parse(psf, length - bytesread);
    }
#line 1379
    bytesread += (unsigned int )__cil_tmp15;
#line 1380
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 1387
    psf_log_printf(psf, "    *** Found weird-ass zero marker. Jumping to end of chunk.\n");
    }
#line 1388
    if (bytesread < length) {
      {
#line 1389
      __cil_tmp16 = psf_binheader_readf(psf, "j", (length - bytesread) + 4U);
      }
#line 1389
      bytesread += (unsigned int )__cil_tmp16;
    }
    {
#line 1390
    __cil_tmp17 = psf_fseek(psf, (sf_count_t )0, 1);
#line 1390
    psf_log_printf(psf, "    *** Offset is now : 0x%X\n", __cil_tmp17);
    }
#line 1391
    return (0);
    switch_default: /* CIL Label */ 
    {
#line 1394
    psf_binheader_readf(psf, "4", & dword);
    }
    {
#line 1395
    bytesread += sizeof(dword);
#line 1396
    dword += dword & 1U;
#line 1397
    psf_binheader_readf(psf, "j", dword);
#line 1398
    bytesread += dword;
#line 1399
    psf_log_printf(psf, "    *** %M : %d\n\230\001", chunk, dword);
    }
#line 1400
    if (dword > length) {
#line 1401
      return (0);
    }
#line 1402
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }

    {
#line 1406
    if (chunk == (((73 | (83 << 8)) | (70 << 16)) | (84 << 24))) {
#line 1406
      goto case_exp___18;
    }
#line 1409
    if (chunk == (((73 | (67 << 8)) | (79 << 16)) | (80 << 24))) {
#line 1409
      goto case_exp___19;
    }
#line 1412
    if (chunk == (((73 | (78 << 8)) | (65 << 16)) | (77 << 24))) {
#line 1412
      goto case_exp___20;
    }
#line 1415
    if (chunk == (((73 | (65 << 8)) | (82 << 16)) | (84 << 24))) {
#line 1415
      goto case_exp___21;
    }
#line 1418
    if (chunk == (((73 | (67 << 8)) | (77 << 16)) | (84 << 24))) {
#line 1418
      goto case_exp___22;
    }
#line 1421
    if (chunk == (((73 | (67 << 8)) | (82 << 16)) | (68 << 24))) {
#line 1421
      goto case_exp___23;
    }
#line 1405
    goto switch_break___0;
    case_exp___18: /* CIL Label */ 
    {
#line 1407
    psf_store_string(psf, 3, (char const   *)((char *)psf->u.cbuf));
    }
#line 1408
    goto switch_break___0;
    case_exp___19: /* CIL Label */ 
    {
#line 1410
    psf_store_string(psf, 2, (char const   *)((char *)psf->u.cbuf));
    }
#line 1411
    goto switch_break___0;
    case_exp___20: /* CIL Label */ 
    {
#line 1413
    psf_store_string(psf, 1, (char const   *)((char *)psf->u.cbuf));
    }
#line 1414
    goto switch_break___0;
    case_exp___21: /* CIL Label */ 
    {
#line 1416
    psf_store_string(psf, 4, (char const   *)((char *)psf->u.cbuf));
    }
#line 1417
    goto switch_break___0;
    case_exp___22: /* CIL Label */ 
    {
#line 1419
    psf_store_string(psf, 5, (char const   *)((char *)psf->u.cbuf));
    }
#line 1420
    goto switch_break___0;
    case_exp___23: /* CIL Label */ 
    {
#line 1422
    psf_store_string(psf, 6, (char const   *)((char *)psf->u.cbuf));
    }
#line 1423
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }

  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1427
  __cil_tmp18 = psf_fseek(psf, (sf_count_t )0, 1);
#line 1427
  current_pos = __cil_tmp18 - current_pos;
  }
#line 1429
  if (current_pos - 4L != (long )length) {
    {
#line 1430
    psf_log_printf(psf, "**** Bad chunk length %d sbould be %D\n", length, current_pos - 4L);
    }
  }
#line 1432
  return (0);
}
}
#line 1436 "/root/libsndfile/src/wav.c"
static int wav_read_smpl_chunk(SF_PRIVATE *psf , unsigned int chunklen ) 
{ 
  unsigned int bytesread ;
  unsigned int dword ;
  unsigned int sampler_data ;
  unsigned int loop_count ;
  unsigned int note ;
  unsigned int start ;
  unsigned int end ;
  unsigned int type ;
  unsigned int count ;
  int j ;
  int k ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  SF_INSTRUMENT *__cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  unsigned int __cil_tmp30 ;
  int __cil_tmp31 ;
  char ch ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;

  {
  {
#line 1437
  bytesread = (unsigned int )0;
#line 1438
  type = (unsigned int )(- 1);
#line 1441
  chunklen += chunklen & 1U;
#line 1443
  __cil_tmp14 = psf_binheader_readf(psf, "4", & dword);
  }
  {
#line 1443
  bytesread += (unsigned int )__cil_tmp14;
#line 1444
  psf_log_printf(psf, "  Manufacturer : %X\n", dword);
#line 1446
  __cil_tmp15 = psf_binheader_readf(psf, "4", & dword);
  }
  {
#line 1446
  bytesread += (unsigned int )__cil_tmp15;
#line 1447
  psf_log_printf(psf, "  Product      : %u\n", dword);
#line 1449
  __cil_tmp16 = psf_binheader_readf(psf, "4", & dword);
  }
  {
#line 1449
  bytesread += (unsigned int )__cil_tmp16;
#line 1450
  psf_log_printf(psf, "  Period       : %u nsec\n", dword);
#line 1452
  __cil_tmp17 = psf_binheader_readf(psf, "4", & note);
  }
  {
#line 1452
  bytesread += (unsigned int )__cil_tmp17;
#line 1453
  psf_log_printf(psf, "  Midi Note    : %u\n", note);
#line 1455
  __cil_tmp18 = psf_binheader_readf(psf, "4", & dword);
  }
#line 1455
  bytesread += (unsigned int )__cil_tmp18;
#line 1456
  if (dword != 0U) {
    {
#line 1457
    snprintf((char *)psf->u.cbuf, sizeof(psf->u.cbuf), "%f", (1. * (double )2147483648U) / (double )((unsigned int )dword));
#line 1459
    psf_log_printf(psf, "  Pitch Fract. : %s\n\036V", (char *)psf->u.cbuf);
    }
  } else {
    {
#line 1462
    psf_log_printf(psf, "  Pitch Fract. : 0\n");
    }
  }
  {
#line 1464
  __cil_tmp19 = psf_binheader_readf(psf, "4", & dword);
  }
  {
#line 1464
  bytesread += (unsigned int )__cil_tmp19;
#line 1465
  psf_log_printf(psf, "  SMPTE Format : %u\n\036V", dword);
#line 1467
  __cil_tmp20 = psf_binheader_readf(psf, "4\376\t\373\036V", & dword);
  }
  {
#line 1467
  bytesread += (unsigned int )__cil_tmp20;
#line 1468
  snprintf((char *)psf->u.cbuf, sizeof(psf->u.cbuf), "%02d:%02d:%02d %02d", (dword >> 24) & 127U,
           (dword >> 16) & 127U, (dword >> 8) & 127U, dword & 127U);
#line 1470
  psf_log_printf(psf, "  SMPTE Offset : %s\n\036V", (char *)psf->u.cbuf);
#line 1472
  __cil_tmp21 = psf_binheader_readf(psf, "4", & loop_count);
  }
  {
#line 1472
  bytesread += (unsigned int )__cil_tmp21;
#line 1473
  psf_log_printf(psf, "  Loop Count   : %u\n\036V", loop_count);
#line 1478
  __cil_tmp22 = psf_binheader_readf(psf, "4", & sampler_data);
  }
  {
#line 1478
  bytesread += (unsigned int )__cil_tmp22;
#line 1480
  psf->instrument = psf_instrument_alloc();
  }
#line 1480
  if (psf->instrument == (void *)0) {
#line 1481
    return (16);
  }
#line 1483
  (psf->instrument)->loop_count = (int )loop_count;
#line 1485
  j = 0;
  {
#line 1485
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1485
    if (! (loop_count > 0U && chunklen - bytesread >= 24U)) {
#line 1485
      goto while_break;
    }
    {
#line 1486
    __cil_tmp24 = psf_binheader_readf(psf, "47\n\373\036V", & dword);
    }
    {
#line 1486
    bytesread += (unsigned int )__cil_tmp24;
#line 1487
    psf_log_printf(psf, "    Cue ID : %2u\230\001", dword);
#line 1489
    __cil_tmp25 = psf_binheader_readf(psf, "4", & type);
    }
    {
#line 1489
    bytesread += (unsigned int )__cil_tmp25;
#line 1490
    psf_log_printf(psf, "  Type : %2u", type);
#line 1492
    __cil_tmp26 = psf_binheader_readf(psf, "4", & start);
    }
    {
#line 1492
    bytesread += (unsigned int )__cil_tmp26;
#line 1493
    psf_log_printf(psf, "  Start : %5uV", start);
#line 1495
    __cil_tmp27 = psf_binheader_readf(psf, "4\333\t\373\036V", & end);
    }
    {
#line 1495
    bytesread += (unsigned int )__cil_tmp27;
#line 1496
    psf_log_printf(psf, "  End : %5u\373\036V", end);
#line 1498
    __cil_tmp28 = psf_binheader_readf(psf, "4\332\t\373\036V", & dword);
    }
    {
#line 1498
    bytesread += (unsigned int )__cil_tmp28;
#line 1499
    psf_log_printf(psf, "  Fraction : %5u\230\001", dword);
#line 1501
    __cil_tmp29 = psf_binheader_readf(psf, "4", & count);
    }
    {
#line 1501
    bytesread += (unsigned int )__cil_tmp29;
#line 1502
    psf_log_printf(psf, "  Count : %5u\n", count);
    }
#line 1504
    if (j < (int )(sizeof((psf->instrument)->loops) / sizeof((psf->instrument)->loops[0]))) {
#line 1505
      (psf->instrument)->loops[j].start = start;
#line 1506
      (psf->instrument)->loops[j].end = end;
#line 1507
      (psf->instrument)->loops[j].count = count;
      {
#line 1510
      if (type == (unsigned int )0) {
#line 1510
        goto case_0;
      }
#line 1513
      if (type == (unsigned int )1) {
#line 1513
        goto case_1;
      }
#line 1516
      if (type == (unsigned int )2) {
#line 1516
        goto case_2;
      }
#line 1519
      goto switch_default;
      case_0: /* CIL Label */ 
#line 1511
      (psf->instrument)->loops[j].mode = 801;
#line 1512
      goto switch_break;
      case_1: /* CIL Label */ 
#line 1514
      (psf->instrument)->loops[j].mode = 803;
#line 1515
      goto switch_break;
      case_2: /* CIL Label */ 
#line 1517
      (psf->instrument)->loops[j].mode = 802;
#line 1518
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1520
      (psf->instrument)->loops[j].mode = 800;
#line 1521
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }

    }
#line 1525
    __cil_tmp30 = loop_count;
#line 1525
    loop_count --;
#line 1485
    j ++;
  }
  while_break: /* CIL Label */ ;
  }

#line 1528
  if (chunklen - bytesread == 0U) {
#line 1529
    if (sampler_data != 0U) {
      {
#line 1530
      psf_log_printf(psf, "  Sampler Data : %u (should be 0)\n", sampler_data);
      }
    } else {
      {
#line 1532
      psf_log_printf(psf, "  Sampler Data : %u\n", sampler_data);
      }
    }
  } else {
#line 1535
    if (sampler_data != chunklen - bytesread) {
      {
#line 1536
      psf_log_printf(psf, "  Sampler Data : %u (should have been %u)\n", sampler_data,
                     chunklen - bytesread);
#line 1537
      sampler_data = chunklen - bytesread;
      }
    } else {
      {
#line 1540
      psf_log_printf(psf, "  Sampler Data : %u\n", sampler_data);
      }
    }
    {
#line 1542
    psf_log_printf(psf, "      ");
#line 1543
    k = 0;
    }
    {
#line 1543
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1543
      if (! (k < (int )sampler_data)) {
#line 1543
        goto while_break___0;
      }
#line 1546
      if (k > 0) {
#line 1546
        if (k % 20 == 0) {
          {
#line 1547
          psf_log_printf(psf, "\n      ");
          }
        }
      }
      {
#line 1549
      __cil_tmp33 = psf_binheader_readf(psf, "1", & ch);
      }
      {
#line 1549
      bytesread += (unsigned int )__cil_tmp33;
#line 1550
      psf_log_printf(psf, "%02X V", (int )ch & 255);
      }
#line 1543
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1553
    psf_log_printf(psf, "\n");
    }
  }
#line 1556
  (psf->instrument)->basenote = (char )note;
#line 1557
  (psf->instrument)->gain = 1;
#line 1558
  (psf->instrument)->key_lo = (char )0;
#line 1558
  (psf->instrument)->velocity_lo = (psf->instrument)->key_lo;
#line 1559
  (psf->instrument)->key_hi = (char )127;
#line 1559
  (psf->instrument)->velocity_hi = (psf->instrument)->key_hi;
#line 1561
  return (0);
}
}
#line 1596 "/root/libsndfile/src/wav.c"
static int wav_read_acid_chunk(SF_PRIVATE *psf , unsigned int chunklen ) 
{ 
  unsigned int bytesread ;
  int beats ;
  int flags ;
  short rootnote ;
  short q1 ;
  short meter_denom ;
  short meter_numer ;
  float q2 ;
  float tempo ;
  int __cil_tmp12 ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  int __cil_tmp18 ;
  void *__cil_tmp19 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 1597
  bytesread = (unsigned int )0;
#line 1602
  chunklen += chunklen & 1U;
#line 1604
  __cil_tmp12 = psf_binheader_readf(psf, "422f", & flags, & rootnote, & q1, & q2);
  }
  {
#line 1604
  bytesread += (unsigned int )__cil_tmp12;
#line 1606
  snprintf((char *)psf->u.cbuf, sizeof(psf->u.cbuf), "%f\n\373\036V", (double )q2);
  }
#line 1608
  if (flags & 1) {
#line 1608
    tmp = "OneShot";
  } else {
#line 1608
    tmp = "Loop";
  }
#line 1608
  if (flags & 2) {
#line 1608
    tmp___0 = "RootNoteValidV";
  } else {
#line 1608
    tmp___0 = "RootNoteInvalid";
  }
#line 1608
  if (flags & 4) {
#line 1608
    tmp___1 = "StretchOn";
  } else {
#line 1608
    tmp___1 = "StretchOff\n\373\036V";
  }
#line 1608
  if (flags & 8) {
#line 1608
    tmp___2 = "DiskBased\212\n\373\036V";
  } else {
#line 1608
    tmp___2 = "RAMBased\220";
  }
#line 1608
  if (flags & 16) {
#line 1608
    tmp___3 = "??On\036V";
  } else {
#line 1608
    tmp___3 = "??OffV";
  }
  {
#line 1608
  psf_log_printf(psf, "  Flags     : 0x%04x (%s,%s,%s,%s,%s)\n", flags, tmp, tmp___0,
                 tmp___1, tmp___2, tmp___3);
#line 1615
  psf_log_printf(psf, "  Root note : 0x%x\n  ????      : 0x%04x\n  ????      : %s\n\216\n\373\036V",
                 (int )rootnote, (int )q1, (char *)psf->u.cbuf);
#line 1618
  __cil_tmp18 = psf_binheader_readf(psf, "422f\036V", & beats, & meter_denom, & meter_numer,
                                    & tempo);
  }
  {
#line 1618
  bytesread += (unsigned int )__cil_tmp18;
#line 1619
  snprintf((char *)psf->u.cbuf, sizeof(psf->u.cbuf), "%f\n\373\036V", (double )tempo);
#line 1620
  psf_log_printf(psf, "  Beats     : %d\n  Meter     : %d/%d\n  Tempo     : %s\n",
                 beats, (int )meter_numer, (int )meter_denom, (char *)psf->u.cbuf);
#line 1623
  psf_binheader_readf(psf, "j", chunklen - bytesread);
#line 1625
  psf->loop_info = (SF_LOOP_INFO *)calloc((unsigned long )1, sizeof(SF_LOOP_INFO ));
  }
#line 1625
  if (psf->loop_info == (void *)0) {
#line 1626
    return (16);
  }
#line 1628
  (psf->loop_info)->time_sig_num = meter_numer;
#line 1629
  (psf->loop_info)->time_sig_den = meter_denom;
#line 1630
  if (flags & 1) {
#line 1630
    tmp___4 = 800;
  } else {
#line 1630
    tmp___4 = 801;
  }
#line 1630
  (psf->loop_info)->loop_mode = tmp___4;
#line 1631
  (psf->loop_info)->num_beats = beats;
#line 1632
  (psf->loop_info)->bpm = tempo;
#line 1633
  if (flags & 2) {
#line 1633
    tmp___5 = (int )rootnote;
  } else {
#line 1633
    tmp___5 = - 1;
  }
#line 1633
  (psf->loop_info)->root_key = tmp___5;
#line 1635
  return (0);
}
}
#line 1639 "/root/libsndfile/src/wav.c"
static int wav_read_bext_chunk(SF_PRIVATE *psf , unsigned int chunksize ) 
{ 
  SF_BROADCAST_INFO *b ;
  unsigned int bytes ;
  SF_BROADCAST_VAR *__cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;

  {
#line 1642
  bytes = (unsigned int )0;
#line 1644
  if (chunksize < 602U) {
    {
#line 1645
    psf_log_printf(psf, "bext : %u (should be >= %d)\n", chunksize, 602);
#line 1646
    psf_binheader_readf(psf, "j\253\n\373\036V", chunksize);
    }
#line 1647
    return (0);
  }

#line 1650
  if (chunksize > 10240U) {
    {
#line 1651
    psf_log_printf(psf, "bext : %u (should be < %d)\n", chunksize, 10240);
#line 1652
    psf_binheader_readf(psf, "j", chunksize);
    }
#line 1653
    return (0);
  }
  {
#line 1656
  psf_log_printf(psf, "bext : %u\n\n\373\036V", chunksize);
#line 1658
  psf->broadcast_var = broadcast_var_alloc((size_t )(chunksize + 128U));
  }
#line 1658
  if (psf->broadcast_var == (void *)0) {
#line 1659
    psf->error = 16;
#line 1660
    return (psf->error);
  }
  {
#line 1663
  b = & (psf->broadcast_var)->binfo;
#line 1665
  __cil_tmp6 = psf_binheader_readf(psf, "bA\n\373\036V", (char *)b->description, sizeof(b->description));
  }
  {
#line 1665
  bytes += (unsigned int )__cil_tmp6;
#line 1666
  __cil_tmp7 = psf_binheader_readf(psf, "b_\t\373\036V", (char *)b->originator, sizeof(b->originator));
  }
  {
#line 1666
  bytes += (unsigned int )__cil_tmp7;
#line 1667
  __cil_tmp8 = psf_binheader_readf(psf, "b", (char *)b->originator_reference, sizeof(b->originator_reference));
  }
  {
#line 1667
  bytes += (unsigned int )__cil_tmp8;
#line 1668
  __cil_tmp9 = psf_binheader_readf(psf, "b", (char *)b->origination_date, sizeof(b->origination_date));
  }
  {
#line 1668
  bytes += (unsigned int )__cil_tmp9;
#line 1669
  __cil_tmp10 = psf_binheader_readf(psf, "b\310\n\373\036V", (char *)b->origination_time,
                                    sizeof(b->origination_time));
  }
  {
#line 1669
  bytes += (unsigned int )__cil_tmp10;
#line 1670
  __cil_tmp11 = psf_binheader_readf(psf, "442\373\036V", & b->time_reference_low,
                                    & b->time_reference_high, & b->version);
  }
  {
#line 1670
  bytes += (unsigned int )__cil_tmp11;
#line 1671
  __cil_tmp12 = psf_binheader_readf(psf, "bj\n\373\036V", & b->umid, sizeof(b->umid),
                                    190);
  }
#line 1671
  bytes += (unsigned int )__cil_tmp12;
#line 1673
  if (chunksize > 602U) {
    {
#line 1676
    b->coding_history_size = chunksize - 602U;
#line 1679
    __cil_tmp13 = psf_binheader_readf(psf, "b", (char *)b->coding_history, b->coding_history_size);
    }
#line 1679
    bytes += (unsigned int )__cil_tmp13;
  }

#line 1682
  if (bytes < chunksize) {
    {
#line 1683
    psf_binheader_readf(psf, "j", chunksize - bytes);
    }
  }
#line 1685
  return (0);
}
}
#line 1689 "/root/libsndfile/src/wav.c"
static int wav_write_bext_chunk(SF_PRIVATE *psf ) 
{ 
  SF_BROADCAST_INFO *b ;
  size_t __cil_tmp3 ;
  size_t __cil_tmp4 ;

  {
#line 1692
  if (psf->broadcast_var == (void *)0) {
#line 1693
    return (- 1);
  }
  {
#line 1695
  b = & (psf->broadcast_var)->binfo;
#line 1697
  psf_binheader_writef(psf, "m4\n\373\036V", ((98 | (101 << 8)) | (120 << 16)) | (116 << 24),
                       602U + b->coding_history_size);
#line 1704
  psf_binheader_writef(psf, "b", (char *)b->description, sizeof(b->description));
#line 1705
  psf_binheader_writef(psf, "b", (char *)b->originator, sizeof(b->originator));
#line 1706
  psf_binheader_writef(psf, "b", (char *)b->originator_reference, sizeof(b->originator_reference));
#line 1707
  psf_binheader_writef(psf, "b\320\n\373\036V", (char *)b->origination_date, sizeof(b->origination_date));
#line 1708
  psf_binheader_writef(psf, "b\346\n\373\036V", (char *)b->origination_time, sizeof(b->origination_time));
#line 1709
  psf_binheader_writef(psf, "442\373\036V", b->time_reference_low, b->time_reference_high,
                       (int )b->version);
#line 1710
  psf_binheader_writef(psf, "b\253\317\372\036V", (char *)b->umid, sizeof(b->umid));
#line 1711
  __cil_tmp3 = make_size_t(190);
#line 1711
  psf_binheader_writef(psf, "z\313\n\373\036V", __cil_tmp3);
  }
#line 1713
  if (b->coding_history_size > 0U) {
    {
#line 1714
    __cil_tmp4 = make_size_t((int )b->coding_history_size);
#line 1714
    psf_binheader_writef(psf, "b", (char *)b->coding_history, __cil_tmp4);
    }
  }
#line 1716
  return (0);
}
}
#line 1720 "/root/libsndfile/src/wav.c"
static int exif_fill_and_sink(SF_PRIVATE *psf , char *buf , size_t bufsz , size_t toread ) 
{ 
  size_t bytesread ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 1722
  bytesread = (size_t )0;
#line 1724
  *(buf + 0) = (char )0;
#line 1725
  bufsz -= (unsigned long )1;
#line 1726
  if (toread < bufsz) {
#line 1727
    bufsz = toread;
  }
  {
#line 1728
  __cil_tmp6 = psf_binheader_readf(psf, "b\272\n\373\036V", buf, bufsz);
#line 1728
  bytesread = (size_t )__cil_tmp6;
#line 1729
  *(buf + bufsz) = (char )0;
  }
#line 1731
  if (bytesread == bufsz) {
#line 1731
    if (toread > bufsz) {
      {
#line 1732
      __cil_tmp7 = psf_binheader_readf(psf, "j\265\n\373\036V", toread - bufsz);
      }
#line 1732
      bytesread += (unsigned long )__cil_tmp7;
    }
  }
#line 1734
  return ((int )bytesread);
}
}
#line 1742 "/root/libsndfile/src/wav.c"
static int exif_subchunk_parse(SF_PRIVATE *psf , unsigned int length ) 
{ 
  unsigned int marker ;
  unsigned int dword ;
  unsigned int vmajor ;
  unsigned int vminor ;
  unsigned int bytesread ;
  char buf[4096] ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  int __cil_tmp13 ;

  {
#line 1743
  vmajor = (unsigned int )(- 1);
#line 1743
  vminor = (unsigned int )(- 1);
#line 1743
  bytesread = (unsigned int )0;
  {
#line 1746
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1746
    if (! (bytesread < length)) {
#line 1746
      goto while_break;
    }
    {
#line 1748
    __cil_tmp9 = psf_binheader_readf(psf, "m", & marker);
    }
#line 1748
    bytesread += (unsigned int )__cil_tmp9;
    {
#line 1752
    if (marker == (unsigned int )0) {
#line 1752
      goto case_0;
    }
#line 1755
    if (marker == (unsigned int )(((101 | (118 << 8)) | (101 << 16)) | (114 << 24))) {
#line 1755
      goto case_exp;
    }
#line 1767
    if (marker == (unsigned int )(((101 | (117 << 8)) | (99 << 16)) | (109 << 24))) {
#line 1767
      goto case_exp___0;
    }
#line 1767
    if (marker == (unsigned int )(((101 | (114 << 8)) | (101 << 16)) | (108 << 24))) {
#line 1767
      goto case_exp___0;
    }
#line 1767
    if (marker == (unsigned int )(((101 | (116 << 8)) | (105 << 16)) | (109 << 24))) {
#line 1767
      goto case_exp___0;
    }
#line 1767
    if (marker == (unsigned int )(((101 | (99 << 8)) | (111 << 16)) | (114 << 24))) {
#line 1767
      goto case_exp___0;
    }
#line 1767
    if (marker == (unsigned int )(((101 | (109 << 8)) | (100 << 16)) | (108 << 24))) {
#line 1767
      goto case_exp___0;
    }
#line 1767
    if (marker == (unsigned int )(((101 | (109 << 8)) | (110 << 16)) | (116 << 24))) {
#line 1767
      goto case_exp___0;
    }
#line 1792
    goto switch_default;
    case_0: /* CIL Label */ 
#line 1753
    goto switch_break;
    case_exp: /* CIL Label */ 
    {
#line 1756
    __cil_tmp10 = psf_binheader_readf(psf, "j4\n\373\036V", 4, & dword);
    }
    {
#line 1756
    bytesread += (unsigned int )__cil_tmp10;
#line 1757
    vmajor = 10U * (((dword >> 24) & 255U) - 48U) + (((dword >> 16) & 255U) - 48U);
#line 1758
    vminor = 10U * (((dword >> 8) & 255U) - 48U) + ((dword & 255U) - 48U);
#line 1759
    psf_log_printf(psf, "    EXIF Version : %u.%02u\n", vmajor, vminor);
    }
#line 1760
    goto switch_break;
    case_exp___0: /* CIL Label */ 
    case_exp___1: /* CIL Label */ 
    case_exp___2: /* CIL Label */ 
    case_exp___3: /* CIL Label */ 
    case_exp___4: /* CIL Label */ 
    case_exp___5: /* CIL Label */ 
    {
#line 1768
    psf_binheader_readf(psf, "4", & dword);
    }
#line 1769
    bytesread += sizeof(dword);
#line 1770
    dword += dword & 1U;
#line 1772
    if ((unsigned long )dword >= sizeof(buf)) {
      {
#line 1773
      psf_log_printf(psf, "*** Marker \'%M\' is too big %u\n\n", marker, dword);
      }
#line 1774
      return ((int )bytesread);
    }
    {
#line 1777
    __cil_tmp11 = exif_fill_and_sink(psf, (char *)buf, sizeof(buf), (size_t )dword);
    }
    {
#line 1777
    bytesread += (unsigned int )__cil_tmp11;
#line 1782
    __cil_tmp12 = strlen((char const   *)((char *)buf));
    }
#line 1782
    if (marker == (unsigned int )(((101 | (109 << 8)) | (100 << 16)) | (108 << 24))) {
#line 1782
      if ((unsigned long )dword == __cil_tmp12) {
        {
#line 1783
        psf_log_printf(psf, "    *** field size too small for string (sinking 2 bytes)\n");
#line 1784
        __cil_tmp13 = psf_binheader_readf(psf, "j", 2);
        }
#line 1784
        bytesread += (unsigned int )__cil_tmp13;
      }
    }
    {
#line 1787
    psf_log_printf(psf, "    %M : %d (%s)\n", marker, dword, (char *)buf);
    }
#line 1788
    if (dword > length) {
#line 1789
      return ((int )bytesread);
    }
#line 1790
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1793
    psf_log_printf(psf, "    *** %M (%d): -- ignored --\n", marker, marker);
    }
#line 1794
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }

  }
  while_break: /* CIL Label */ ;
  }

#line 1798
  return ((int )bytesread);
}
}
#line 33 "/root/libsndfile/src/wav_w64.c"
static EXT_SUBFORMAT MSGUID_SUBTYPE_PCM___1  =    {(unsigned int )1, (unsigned short )0, (unsigned short )16, {(char )128, (char )0,
                                                                (char )0, (char )170,
                                                                (char )0, (char )56,
                                                                (char )155, (char )113}};
#line 37 "/root/libsndfile/src/wav_w64.c"
static EXT_SUBFORMAT MSGUID_SUBTYPE_MS_ADPCM___1  =    {(unsigned int )2, (unsigned short )0, (unsigned short )16, {(char )128, (char )0,
                                                                (char )0, (char )170,
                                                                (char )0, (char )56,
                                                                (char )155, (char )113}};
#line 41 "/root/libsndfile/src/wav_w64.c"
static EXT_SUBFORMAT MSGUID_SUBTYPE_IEEE_FLOAT___1  =    {(unsigned int )3, (unsigned short )0, (unsigned short )16, {(char )128, (char )0,
                                                                (char )0, (char )170,
                                                                (char )0, (char )56,
                                                                (char )155, (char )113}};
#line 45 "/root/libsndfile/src/wav_w64.c"
static EXT_SUBFORMAT MSGUID_SUBTYPE_ALAW___1  =    {(unsigned int )6, (unsigned short )0, (unsigned short )16, {(char )128, (char )0,
                                                                (char )0, (char )170,
                                                                (char )0, (char )56,
                                                                (char )155, (char )113}};
#line 49 "/root/libsndfile/src/wav_w64.c"
static EXT_SUBFORMAT MSGUID_SUBTYPE_MULAW___1  =    {(unsigned int )7, (unsigned short )0, (unsigned short )16, {(char )128, (char )0,
                                                                (char )0, (char )170,
                                                                (char )0, (char )56,
                                                                (char )155, (char )113}};
#line 58 "/root/libsndfile/src/wav_w64.c"
static EXT_SUBFORMAT MSGUID_SUBTYPE_AMBISONIC_B_FORMAT_PCM___1  =    {(unsigned int )1, (unsigned short )1825, (unsigned short )4563, {(char )134, (char )68,
                                                                     (char )200, (char )193,
                                                                     (char )202, (char )0,
                                                                     (char )0, (char )0}};
#line 62 "/root/libsndfile/src/wav_w64.c"
static EXT_SUBFORMAT MSGUID_SUBTYPE_AMBISONIC_B_FORMAT_IEEE_FLOAT___1  =    {(unsigned int )3, (unsigned short )1825, (unsigned short )4563, {(char )134, (char )68,
                                                                     (char )200, (char )193,
                                                                     (char )202, (char )0,
                                                                     (char )0, (char )0}};
#line 80 "/root/libsndfile/src/wav_w64.c"
static int wavex_guid_equal(EXT_SUBFORMAT *first , EXT_SUBFORMAT *second ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 81
  __cil_tmp3 = memcmp(first, second, sizeof(EXT_SUBFORMAT ));
  }
#line 81
  return (! __cil_tmp3);
}
}
#line 87 "/root/libsndfile/src/wav_w64.c"
int wav_w64_read_fmt_chunk(SF_PRIVATE *psf , int fmtsize ) 
{ 
  WAV_PRIVATE *wpriv ;
  WAV_FMT *wav_fmt ;
  int bytesread ;
  int k ;
  int bytespersec ;
  int __cil_tmp8 ;
  char const   *__cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int tmp ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int tmp___0 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  char const   *tmp___1 ;

  {
#line 90
  bytespersec = 0;
#line 92
  wpriv = psf->container_data;
#line 92
  if (wpriv == (void *)0) {
#line 93
    return (29);
  }
  {
#line 94
  wav_fmt = & wpriv->wav_fmt;
#line 96
  memset(wav_fmt, 0, sizeof(WAV_FMT ));
  }
#line 98
  if (fmtsize < 16) {
#line 99
    return (61);
  }
  {
#line 104
  bytesread = psf_binheader_readf(psf, "224422", & wav_fmt->format, & wav_fmt->min.channels,
                                  & wav_fmt->min.samplerate, & wav_fmt->min.bytespersec,
                                  & wav_fmt->min.blockalign, & wav_fmt->min.bitwidth);
#line 109
  __cil_tmp9 = wav_w64_format_str((int )wav_fmt->format);
#line 109
  psf_log_printf(psf, "  Format        : 0x%X => %s\n", (int )wav_fmt->format, __cil_tmp9);
#line 110
  psf_log_printf(psf, "  Channels      : %d\n", (int )wav_fmt->min.channels);
#line 111
  psf_log_printf(psf, "  Sample Rate   : %d\n", wav_fmt->min.samplerate);
#line 112
  psf_log_printf(psf, "  Block Align   : %d\n", (int )wav_fmt->min.blockalign);
  }
#line 114
  if ((int )wav_fmt->min.blockalign == 0) {
    {
#line 115
    psf_log_printf(psf, "*** Error : wav_fmt->min.blockalign should not be zero.\n\220");
    }
#line 116
    return (29);
  }

#line 119
  if ((int )wav_fmt->format == 1) {
#line 119
    if ((int )wav_fmt->min.bitwidth == 24) {
#line 119
      if ((int )wav_fmt->min.blockalign == 4 * (int )wav_fmt->min.channels) {
        {
#line 121
        psf_log_printf(psf, "  Bit Width     : 24\n");
#line 123
        psf_log_printf(psf, "\n  Ambiguous information in \'fmt \' chunk. Possibile file types:\n    0) Invalid IEEE float file generated by Syntrillium\'s Cooledit!\n    1) File generated by ALSA\'s arecord containing 24 bit samples in 32 bit containers.\n    2) 24 bit file with incorrect Block Align value.\n\n");
#line 130
        wpriv->fmt_is_broken = 1;
        }
      } else {
#line 119
        goto _L;
      }
    } else {
#line 119
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  _L___18: /* CIL Label */ 
#line 132
  if ((int )wav_fmt->min.bitwidth == 0) {
    {
#line 135
    if ((int )wav_fmt->format == 29232) {
#line 135
      goto case_29232;
    }
#line 135
    if ((int )wav_fmt->format == 49) {
#line 135
      goto case_29232;
    }
#line 138
    goto switch_default;
    case_29232: /* CIL Label */ 
    case_49: /* CIL Label */ 
    {
#line 136
    psf_log_printf(psf, "  Bit Width     : %d\n", (int )wav_fmt->min.bitwidth);
    }
#line 137
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 139
    psf_log_printf(psf, "  Bit Width     : %d (should not be 0)\n", (int )wav_fmt->min.bitwidth);
    }
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 145
    if ((int )wav_fmt->format == 29232) {
#line 145
      goto case_29232___0;
    }
#line 145
    if ((int )wav_fmt->format == 49) {
#line 145
      goto case_29232___0;
    }
#line 148
    goto switch_default___0;
    case_29232___0: /* CIL Label */ 
    case_49___0: /* CIL Label */ 
    {
#line 146
    psf_log_printf(psf, "  Bit Width     : %d (should be 0)\n", (int )wav_fmt->min.bitwidth);
    }
#line 147
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 149
    psf_log_printf(psf, "  Bit Width     : %d\n", (int )wav_fmt->min.bitwidth);
    }
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 153
  psf->sf.samplerate = (int )wav_fmt->min.samplerate;
#line 154
  psf->sf.frames = (sf_count_t )0;
#line 155
  psf->sf.channels = (int )wav_fmt->min.channels;
  {
#line 159
  if ((int )wav_fmt->format == 3) {
#line 159
    goto case_3;
  }
#line 159
  if ((int )wav_fmt->format == 1) {
#line 159
    goto case_3;
  }
#line 170
  if ((int )wav_fmt->format == 7) {
#line 170
    goto case_7;
  }
#line 170
  if ((int )wav_fmt->format == 6) {
#line 170
    goto case_7;
  }
#line 183
  if ((int )wav_fmt->format == 17) {
#line 183
    goto case_17;
  }
#line 203
  if ((int )wav_fmt->format == 2) {
#line 203
    goto case_2;
  }
#line 241
  if ((int )wav_fmt->format == 49) {
#line 241
    goto case_49___1;
  }
#line 262
  if ((int )wav_fmt->format == 65534) {
#line 262
    goto case_65534;
  }
#line 328
  if ((int )wav_fmt->format == 64) {
#line 328
    goto case_64;
  }
#line 346
  goto switch_default___1;
  case_3: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 160
  bytespersec = (int )(wav_fmt->min.samplerate * (unsigned int )wav_fmt->min.blockalign);
#line 161
  if (wav_fmt->min.bytespersec != (unsigned int )bytespersec) {
    {
#line 162
    psf_log_printf(psf, "  Bytes/sec     : %d (should be %d)\n", wav_fmt->min.bytespersec,
                   bytespersec);
    }
  } else {
    {
#line 164
    psf_log_printf(psf, "  Bytes/sec     : %d\n", wav_fmt->min.bytespersec);
    }
  }
#line 166
  psf->bytewidth = ((int )wav_fmt->min.bitwidth + 7) / 8;
#line 167
  goto switch_break___1;
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
#line 171
  if (wav_fmt->min.bytespersec / (unsigned int )wav_fmt->min.blockalign != wav_fmt->min.samplerate) {
    {
#line 172
    psf_log_printf(psf, "  Bytes/sec     : %d (should be %d)\n", wav_fmt->min.bytespersec,
                   wav_fmt->min.samplerate * (unsigned int )wav_fmt->min.blockalign);
    }
  } else {
    {
#line 174
    psf_log_printf(psf, "  Bytes/sec     : %d\n", wav_fmt->min.bytespersec);
    }
  }
#line 176
  psf->bytewidth = 1;
#line 177
  if (fmtsize >= 18) {
    {
#line 178
    __cil_tmp10 = psf_binheader_readf(psf, "2", & wav_fmt->size20.extrabytes);
    }
    {
#line 178
    bytesread += __cil_tmp10;
#line 179
    psf_log_printf(psf, "  Extra Bytes   : %d\n", (int )wav_fmt->size20.extrabytes);
    }
  }

#line 181
  goto switch_break___1;
  case_17: /* CIL Label */ 
#line 184
  if ((int )wav_fmt->min.bitwidth != 4) {
#line 185
    return (69);
  }
#line 186
  if ((int )wav_fmt->min.channels < 1) {
#line 187
    return (70);
  } else
#line 186
  if ((int )wav_fmt->min.channels > 2) {
#line 187
    return (70);
  }
  {
#line 189
  __cil_tmp11 = psf_binheader_readf(psf, "22", & wav_fmt->ima.extrabytes, & wav_fmt->ima.samplesperblock);
  }
#line 189
  bytesread += __cil_tmp11;
#line 192
  bytespersec = (int )((wav_fmt->ima.samplerate * (unsigned int )wav_fmt->ima.blockalign) / (unsigned int )wav_fmt->ima.samplesperblock);
#line 193
  if (wav_fmt->ima.bytespersec != (unsigned int )bytespersec) {
    {
#line 194
    psf_log_printf(psf, "  Bytes/sec     : %d (should be %d)\n", wav_fmt->ima.bytespersec,
                   bytespersec);
    }
  } else {
    {
#line 196
    psf_log_printf(psf, "  Bytes/sec     : %d\n", wav_fmt->ima.bytespersec);
    }
  }
  {
#line 198
  psf->bytewidth = 2;
#line 199
  psf_log_printf(psf, "  Extra Bytes   : %d\n", (int )wav_fmt->ima.extrabytes);
#line 200
  psf_log_printf(psf, "  Samples/Block : %d\n", (int )wav_fmt->ima.samplesperblock);
  }
#line 201
  goto switch_break___1;
  case_2: /* CIL Label */ 
#line 204
  if ((int )wav_fmt->msadpcm.bitwidth != 4) {
#line 205
    return (69);
  }
#line 206
  if ((int )wav_fmt->msadpcm.channels < 1) {
#line 207
    return (70);
  } else
#line 206
  if ((int )wav_fmt->msadpcm.channels > 2) {
#line 207
    return (70);
  }
  {
#line 209
  __cil_tmp12 = psf_binheader_readf(psf, "222", & wav_fmt->msadpcm.extrabytes, & wav_fmt->msadpcm.samplesperblock,
                                    & wav_fmt->msadpcm.numcoeffs);
  }
#line 209
  bytesread += __cil_tmp12;
#line 213
  bytespersec = (int )((wav_fmt->min.samplerate * (unsigned int )wav_fmt->min.blockalign) / (unsigned int )wav_fmt->msadpcm.samplesperblock);
#line 214
  if (wav_fmt->min.bytespersec == (unsigned int )bytespersec) {
    {
#line 215
    psf_log_printf(psf, "  Bytes/sec     : %d\n", wav_fmt->min.bytespersec);
    }
  } else
#line 216
  if (wav_fmt->min.bytespersec == (wav_fmt->min.samplerate / (unsigned int )wav_fmt->msadpcm.samplesperblock) * (unsigned int )wav_fmt->min.blockalign) {
    {
#line 217
    psf_log_printf(psf, "  Bytes/sec     : %d (should be %d (MS BUG!))\n", wav_fmt->min.bytespersec,
                   bytespersec);
    }
  } else {
    {
#line 219
    psf_log_printf(psf, "  Bytes/sec     : %d (should be %d)\n", wav_fmt->min.bytespersec,
                   bytespersec);
    }
  }
  {
#line 222
  psf->bytewidth = 2;
#line 223
  psf_log_printf(psf, "  Extra Bytes   : %d\n", (int )wav_fmt->msadpcm.extrabytes);
#line 224
  psf_log_printf(psf, "  Samples/Block : %d\n", (int )wav_fmt->msadpcm.samplesperblock);
  }
#line 225
  if ((int )wav_fmt->msadpcm.numcoeffs > (int )(sizeof(wav_fmt->msadpcm.coeffs) / sizeof(wav_fmt->msadpcm.coeffs[0]))) {
    {
#line 226
    psf_log_printf(psf, "  No. of Coeffs : %d (should be <= %d)\n", (int )wav_fmt->msadpcm.numcoeffs,
                   (int )(sizeof(wav_fmt->msadpcm.coeffs) / sizeof(wav_fmt->msadpcm.coeffs[0])));
#line 227
    wav_fmt->msadpcm.numcoeffs = (unsigned short )((int )(sizeof(wav_fmt->msadpcm.coeffs) / sizeof(wav_fmt->msadpcm.coeffs[0])));
    }
  } else {
    {
#line 230
    psf_log_printf(psf, "  No. of Coeffs : %d\n", (int )wav_fmt->msadpcm.numcoeffs);
    }
  }
  {
#line 232
  psf_log_printf(psf, "    Index   Coeffs1   Coeffs2\n");
#line 233
  k = 0;
  }
  {
#line 233
  while (1) {
    while_continue: /* CIL Label */ ;
#line 233
    if (! (k < (int )wav_fmt->msadpcm.numcoeffs)) {
#line 233
      goto while_break;
    }
    {
#line 234
    __cil_tmp13 = psf_binheader_readf(psf, "22", & wav_fmt->msadpcm.coeffs[k].coeff1,
                                      & wav_fmt->msadpcm.coeffs[k].coeff2);
    }
    {
#line 234
    bytesread += __cil_tmp13;
#line 236
    snprintf((char *)psf->u.cbuf, sizeof(psf->u.cbuf), "     %2d     %7d   %7d\n",
             k, (int )wav_fmt->msadpcm.coeffs[k].coeff1, (int )wav_fmt->msadpcm.coeffs[k].coeff2);
#line 237
    psf_log_printf(psf, (char const   *)((char *)psf->u.cbuf));
    }
#line 233
    k ++;
  }
  while_break: /* CIL Label */ ;
  }

#line 239
  goto switch_break___1;
  case_49___1: /* CIL Label */ 
#line 242
  if ((int )wav_fmt->gsm610.channels != 1) {
#line 243
    return (71);
  } else
#line 242
  if ((int )wav_fmt->gsm610.blockalign != 65) {
#line 243
    return (71);
  }
  {
#line 245
  __cil_tmp15 = psf_binheader_readf(psf, "22", & wav_fmt->gsm610.extrabytes, & wav_fmt->gsm610.samplesperblock);
  }
#line 245
  bytesread += __cil_tmp15;
#line 248
  if ((int )wav_fmt->gsm610.samplesperblock != 320) {
#line 249
    return (71);
  }
#line 251
  bytespersec = (int )((wav_fmt->gsm610.samplerate * (unsigned int )wav_fmt->gsm610.blockalign) / (unsigned int )wav_fmt->gsm610.samplesperblock);
#line 252
  if (wav_fmt->gsm610.bytespersec != (unsigned int )bytespersec) {
    {
#line 253
    psf_log_printf(psf, "  Bytes/sec     : %d (should be %d)\n", wav_fmt->gsm610.bytespersec,
                   bytespersec);
    }
  } else {
    {
#line 255
    psf_log_printf(psf, "  Bytes/sec     : %d\n", wav_fmt->gsm610.bytespersec);
    }
  }
  {
#line 257
  psf->bytewidth = 2;
#line 258
  psf_log_printf(psf, "  Extra Bytes   : %d\n", (int )wav_fmt->gsm610.extrabytes);
#line 259
  psf_log_printf(psf, "  Samples/Block : %d\n", (int )wav_fmt->gsm610.samplesperblock);
  }
#line 260
  goto switch_break___1;
  case_65534: /* CIL Label */ 
#line 263
  if (wav_fmt->ext.bytespersec / (unsigned int )wav_fmt->ext.blockalign != wav_fmt->ext.samplerate) {
    {
#line 264
    psf_log_printf(psf, "  Bytes/sec     : %d (should be %d)\n", wav_fmt->ext.bytespersec,
                   wav_fmt->ext.samplerate * (unsigned int )wav_fmt->ext.blockalign);
    }
  } else {
    {
#line 266
    psf_log_printf(psf, "  Bytes/sec     : %d\n", wav_fmt->ext.bytespersec);
    }
  }
  {
#line 268
  __cil_tmp16 = psf_binheader_readf(psf, "224", & wav_fmt->ext.extrabytes, & wav_fmt->ext.validbits,
                                    & wav_fmt->ext.channelmask);
  }
  {
#line 268
  bytesread += __cil_tmp16;
#line 272
  psf_log_printf(psf, "  Valid Bits    : %d\n", (int )wav_fmt->ext.validbits);
#line 273
  psf_log_printf(psf, "  Channel Mask  : 0x%X\n", wav_fmt->ext.channelmask);
#line 275
  __cil_tmp17 = psf_binheader_readf(psf, "422", & wav_fmt->ext.esf.esf_field1, & wav_fmt->ext.esf.esf_field2,
                                    & wav_fmt->ext.esf.esf_field3);
  }
  {
#line 275
  bytesread += __cil_tmp17;
#line 280
  psf_log_printf(psf, "  Subformat\n");
#line 281
  psf_log_printf(psf, "    esf_field1 : 0x%X\n", wav_fmt->ext.esf.esf_field1);
#line 282
  psf_log_printf(psf, "    esf_field2 : 0x%X\n", (int )wav_fmt->ext.esf.esf_field2);
#line 283
  psf_log_printf(psf, "    esf_field3 : 0x%X\n", (int )wav_fmt->ext.esf.esf_field3);
#line 284
  psf_log_printf(psf, "    esf_field4 : ");
#line 285
  k = 0;
  }
  {
#line 285
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 285
    if (! (k < 8)) {
#line 285
      goto while_break___0;
    }
    {
#line 286
    __cil_tmp18 = psf_binheader_readf(psf, "1", & wav_fmt->ext.esf.esf_field4[k]);
    }
    {
#line 286
    bytesread += __cil_tmp18;
#line 287
    psf_log_printf(psf, "0x%X ", (int )wav_fmt->ext.esf.esf_field4[k] & 255);
    }
#line 285
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 289
  psf_log_printf(psf, "\n");
#line 290
  psf->bytewidth = ((int )wav_fmt->ext.bitwidth + 7) / 8;
#line 293
  __cil_tmp20 = wavex_guid_equal(& wav_fmt->ext.esf, & MSGUID_SUBTYPE_PCM___1);
  }
#line 293
  if (__cil_tmp20) {
    {
#line 294
    __cil_tmp21 = u_bitwidth_to_subformat(psf->bytewidth * 8);
#line 294
    psf->sf.format = 1245184 | __cil_tmp21;
#line 295
    psf_log_printf(psf, "    format : pcm\n");
    }
  } else {
    {
#line 297
    __cil_tmp22 = wavex_guid_equal(& wav_fmt->ext.esf, & MSGUID_SUBTYPE_MS_ADPCM___1);
    }
#line 297
    if (__cil_tmp22) {
      {
#line 298
      psf->sf.format = 1245203;
#line 299
      psf_log_printf(psf, "    format : ms adpcm\n");
      }
    } else {
      {
#line 301
      __cil_tmp23 = wavex_guid_equal(& wav_fmt->ext.esf, & MSGUID_SUBTYPE_IEEE_FLOAT___1);
      }
#line 301
      if (__cil_tmp23) {
#line 302
        if (psf->bytewidth == 8) {
#line 302
          tmp = 7;
        } else {
#line 302
          tmp = 6;
        }
        {
#line 302
        psf->sf.format = 1245184 | tmp;
#line 303
        psf_log_printf(psf, "    format : IEEE float\n\220");
        }
      } else {
        {
#line 305
        __cil_tmp25 = wavex_guid_equal(& wav_fmt->ext.esf, & MSGUID_SUBTYPE_ALAW___1);
        }
#line 305
        if (__cil_tmp25) {
          {
#line 306
          psf->sf.format = 1245201;
#line 307
          psf_log_printf(psf, "    format : A-law\n");
          }
        } else {
          {
#line 309
          __cil_tmp26 = wavex_guid_equal(& wav_fmt->ext.esf, & MSGUID_SUBTYPE_MULAW___1);
          }
#line 309
          if (__cil_tmp26) {
            {
#line 310
            psf->sf.format = 1245200;
#line 311
            psf_log_printf(psf, "    format : u-law\n");
            }
          } else {
            {
#line 313
            __cil_tmp27 = wavex_guid_equal(& wav_fmt->ext.esf, & MSGUID_SUBTYPE_AMBISONIC_B_FORMAT_PCM___1);
            }
#line 313
            if (__cil_tmp27) {
              {
#line 314
              __cil_tmp28 = u_bitwidth_to_subformat(psf->bytewidth * 8);
#line 314
              psf->sf.format = 1245184 | __cil_tmp28;
#line 315
              psf_log_printf(psf, "    format : pcm (Ambisonic B)\n");
#line 316
              wpriv->wavex_ambisonic = 65;
              }
            } else {
              {
#line 318
              __cil_tmp29 = wavex_guid_equal(& wav_fmt->ext.esf, & MSGUID_SUBTYPE_AMBISONIC_B_FORMAT_IEEE_FLOAT___1);
              }
#line 318
              if (__cil_tmp29) {
#line 319
                if (psf->bytewidth == 8) {
#line 319
                  tmp___0 = 7;
                } else {
#line 319
                  tmp___0 = 6;
                }
                {
#line 319
                psf->sf.format = 1245184 | tmp___0;
#line 320
                psf_log_printf(psf, "    format : IEEE float (Ambisonic B)\n");
#line 321
                wpriv->wavex_ambisonic = 65;
                }
              } else {
#line 324
                return (17);
              }
            }
          }
        }
      }
    }
  }
#line 326
  goto switch_break___1;
  case_64: /* CIL Label */ 
  {
#line 329
  psf_log_printf(psf, "  Bytes/sec     : %d\n", wav_fmt->g72x.bytespersec);
  }
#line 330
  if (fmtsize >= 20) {
    {
#line 331
    __cil_tmp31 = psf_binheader_readf(psf, "22", & wav_fmt->g72x.extrabytes, & wav_fmt->g72x.auxblocksize);
    }
#line 331
    bytesread += __cil_tmp31;
#line 332
    if ((int )wav_fmt->g72x.extrabytes == 0) {
      {
#line 333
      psf_log_printf(psf, "  Extra Bytes   : %d (should be 2)\n", (int )wav_fmt->g72x.extrabytes);
      }
    } else {
      {
#line 335
      psf_log_printf(psf, "  Extra Bytes   : %d\n", (int )wav_fmt->g72x.extrabytes);
      }
    }
    {
#line 336
    psf_log_printf(psf, "  Aux Blk Size  : %d\n", (int )wav_fmt->g72x.auxblocksize);
    }
  } else
#line 338
  if (fmtsize == 18) {
    {
#line 339
    __cil_tmp32 = psf_binheader_readf(psf, "2", & wav_fmt->g72x.extrabytes);
    }
#line 339
    bytesread += __cil_tmp32;
#line 340
    if ((int )wav_fmt->g72x.extrabytes != 0) {
#line 340
      tmp___1 = " (should be 0)";
    } else {
#line 340
      tmp___1 = "\220";
    }
    {
#line 340
    psf_log_printf(psf, "  Extra Bytes   : %d%s\n", (int )wav_fmt->g72x.extrabytes,
                   tmp___1);
    }
  } else {
    {
#line 343
    psf_log_printf(psf, "*** \'fmt \' chunk should be bigger than this!\n");
    }
  }
#line 344
  goto switch_break___1;
  switch_default___1: /* CIL Label */ 
  {
#line 347
  psf_log_printf(psf, "*** No \'fmt \' chunk dumper for this format!\n");
  }
#line 348
  return (60);
  switch_break___1: /* CIL Label */ ;
  }

#line 351
  if (bytesread > fmtsize) {
    {
#line 352
    psf_log_printf(psf, "*** wav_w64_read_fmt_chunk (bytesread > fmtsize)\n");
    }
#line 353
    return (60);
  } else {
    {
#line 356
    psf_binheader_readf(psf, "j", fmtsize - bytesread);
    }
  }
#line 358
  psf->blockwidth = (int )wav_fmt->min.channels * psf->bytewidth;
#line 360
  return (0);
}
}
#line 364 "/root/libsndfile/src/wav_w64.c"
void wavex_write_guid(SF_PRIVATE *psf , EXT_SUBFORMAT *subformat ) 
{ 
  size_t __cil_tmp3 ;

  {
  {
#line 366
  __cil_tmp3 = make_size_t(8);
#line 366
  psf_binheader_writef(psf, "422b", subformat->esf_field1, (int )subformat->esf_field2,
                       (int )subformat->esf_field3, (char const   *)subformat->esf_field4,
                       __cil_tmp3);
  }
  return;
}
}
#line 372 "/root/libsndfile/src/wav_w64.c"
void wav_w64_analyze(SF_PRIVATE *psf ) 
{ 
  AUDIO_DETECT ad ;
  int format ;
  sf_count_t __cil_tmp4 ;
  int __cil_tmp5 ;

  {
#line 374
  format = 0;
#line 376
  if (psf->is_pipe) {
    {
#line 377
    psf_log_printf(psf, "*** Error : Reading from a pipe. Can\'t analyze data section to figure out real data format.\n\n");
    }
#line 378
    return;
  }
  {
#line 381
  psf_log_printf(psf, "---------------------------------------------------\nFormat is known to be broken. Using detection code.\n\036V");
#line 385
  ad.endianness = 268435456;
#line 386
  ad.channels = psf->sf.channels;
#line 388
  psf_fseek(psf, (sf_count_t )600, 0);
  }
  {
#line 390
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 390
    __cil_tmp4 = psf_fread((unsigned char *)psf->u.ucbuf, (sf_count_t )1, (sf_count_t )4096,
                           psf);
    }
#line 390
    if (! (__cil_tmp4 == 4096L)) {
#line 390
      goto while_break;
    }
    {
#line 391
    format = audio_detect(psf, & ad, (unsigned char const   *)((unsigned char *)psf->u.ucbuf),
                          4096);
    }
#line 392
    if (format != 0) {
#line 393
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 397
  psf_fseek(psf, psf->dataoffset, 0);
  }
#line 399
  if (format == 0) {
    {
#line 400
    psf_log_printf(psf, "wav_w64_analyze : detection failed.\n");
    }
#line 401
    return;
  }

  {
#line 406
  if (format == 6) {
#line 406
    goto case_6;
  }
#line 406
  if (format == 4) {
#line 406
    goto case_6;
  }
#line 413
  if (format == 3) {
#line 413
    goto case_3;
  }
#line 420
  goto switch_default;
  case_6: /* CIL Label */ 
  case_4: /* CIL Label */ 
  {
#line 407
  psf_log_printf(psf, "wav_w64_analyze : found format : 0x%X\n", format);
  }
#line 408
  psf->sf.format = (psf->sf.format & -65536) + format;
#line 409
  psf->bytewidth = 4;
#line 410
  psf->blockwidth = psf->sf.channels * psf->bytewidth;
#line 411
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 414
  psf_log_printf(psf, "wav_w64_analyze : found format : 0x%X\n", format);
  }
#line 415
  psf->sf.format = (psf->sf.format & -65536) + format;
#line 416
  psf->bytewidth = 3;
#line 417
  psf->blockwidth = psf->sf.channels * psf->bytewidth;
#line 418
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 421
  psf_log_printf(psf, "wav_w64_analyze : unhandled format : 0x%X\n", format);
  }
#line 422
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }

#line 425
  return;
}
}
#line 439 "/root/libsndfile/src/wav_w64.c"
static WAV_FORMAT_DESC wave_descs[106]  = 
#line 439
  {      {1, "WAVE_FORMAT_PCM"}, 
        {2, "WAVE_FORMAT_MS_ADPCM\036V"}, 
        {3, "WAVE_FORMAT_IEEE_FLOAT"}, 
        {4, "WAVE_FORMAT_VSELP=#\373\036V"}, 
        {5, "WAVE_FORMAT_IBM_CVSD\036V"}, 
        {6, "WAVE_FORMAT_ALAW\250"}, 
        {7, "WAVE_FORMAT_MULAW\367\v\373\036V"}, 
        {16, "WAVE_FORMAT_OKI_ADPCM"}, 
        {17, "WAVE_FORMAT_IMA_ADPCM"}, 
        {18, "WAVE_FORMAT_MEDIASPACE_ADPCM\036V"}, 
        {19, "WAVE_FORMAT_SIERRA_ADPCM\250"}, 
        {20, "WAVE_FORMAT_G723_ADPCM"}, 
        {21, "WAVE_FORMAT_DIGISTD\373\036V"}, 
        {22, "WAVE_FORMAT_DIGIFIX\373\036V"}, 
        {23, "WAVE_FORMAT_DIALOGIC_OKI_ADPCM"}, 
        {24, "WAVE_FORMAT_MEDIAVISION_ADPCM"}, 
        {25, "WAVE_FORMAT_CU_CODEC"}, 
        {32, "WAVE_FORMAT_YAMAHA_ADPCM\250"}, 
        {33, "WAVE_FORMAT_SONARC#\373\036V"}, 
        {34, "WAVE_FORMAT_DSPGROUP_TRUESPEECH"}, 
        {35, "WAVE_FORMAT_ECHOSC1\373\036V"}, 
        {36, "WAVE_FORMAT_AUDIOFILE_AF36#\373\036V"}, 
        {37, "WAVE_FORMAT_APTX\250"}, 
        {38, "WAVE_FORMAT_AUDIOFILE_AF10"}, 
        {39, "WAVE_FORMAT_PROSODY_1612\250"}, 
        {40, "WAVE_FORMAT_LRC"}, 
        {48, "WAVE_FORMAT_DOLBY_AC2V"}, 
        {49, "WAVE_FORMAT_GSM610"}, 
        {50, "WAVE_FORMAT_MSNAUDIO\036V"}, 
        {51, "WAVE_FORMAT_ANTEX_ADPCME\250"}, 
        {52, "WAVE_FORMAT_CONTROL_RES_VQLPCV"}, 
        {53, "WAVE_FORMAT_DIGIREAL"}, 
        {54, "WAVE_FORMAT_DIGIADPCM"}, 
        {55, "WAVE_FORMAT_CONTROL_RES_CR10\036V"}, 
        {56, "WAVE_FORMAT_NMS_VBXADPCM\250"}, 
        {57, "WAVE_FORMAT_ROLAND_RDAC"}, 
        {58, "WAVE_FORMAT_ECHOSC3"}, 
        {59, "WAVE_FORMAT_ROCKWELL_ADPCM#\373\036V"}, 
        {60, "WAVE_FORMAT_ROCKWELL_DIGITALK"}, 
        {61, "WAVE_FORMAT_XEBEC\253#\373\036V"}, 
        {64, "WAVE_FORMAT_G721_ADPCM"}, 
        {65, "WAVE_FORMAT_G728_CELPV"}, 
        {66, "WAVE_FORMAT_MSG723#\373\036V"}, 
        {80, "WAVE_FORMAT_MPEG\250"}, 
        {82, "WAVE_FORMAT_RT24\250"}, 
        {83, "WAVE_FORMAT_PAC"}, 
        {85, "WAVE_FORMAT_MPEGLAYER3"}, 
        {89, "WAVE_FORMAT_LUCENT_G723"}, 
        {96, "WAVE_FORMAT_CIRRUS#\373\036V"}, 
        {97, "WAVE_FORMAT_ESPCM\255#\373\036V"}, 
        {98, "WAVE_FORMAT_VOXWARE"}, 
        {99, "WAVE_FORMAT_CANOPUS_ATRAC"}, 
        {100, "WAVE_FORMAT_G726_ADPCM"}, 
        {101, "WAVE_FORMAT_G722_ADPCM"}, 
        {102, "WAVE_FORMAT_DSAT\250"}, 
        {103, "WAVE_FORMAT_DSAT_DISPLAY\250"}, 
        {105, "WAVE_FORMAT_VOXWARE_BYTE_ALIGNED\250"}, 
        {112, "WAVE_FORMAT_VOXWARE_AC8"}, 
        {113, "WAVE_FORMAT_VOXWARE_AC10\250"}, 
        {114, "WAVE_FORMAT_VOXWARE_AC16\250"}, 
        {115, "WAVE_FORMAT_VOXWARE_AC20\250"}, 
        {116, "WAVE_FORMAT_VOXWARE_RT24\250"}, 
        {117, "WAVE_FORMAT_VOXWARE_RT29\250"}, 
        {118, "WAVE_FORMAT_VOXWARE_RT29HW"}, 
        {119, "WAVE_FORMAT_VOXWARE_VR12\250"}, 
        {120, "WAVE_FORMAT_VOXWARE_VR18\250"}, 
        {121, "WAVE_FORMAT_VOXWARE_TQ40\250"}, 
        {128, "WAVE_FORMAT_SOFTSOUNDV"}, 
        {129, "WAVE_FORMAT_VOXARE_TQ60"}, 
        {130, "WAVE_FORMAT_MSRT24#\373\036V"}, 
        {131, "WAVE_FORMAT_G729A\305#\373\036V"}, 
        {132, "WAVE_FORMAT_MVI_MV12\036V"}, 
        {133, "WAVE_FORMAT_DF_G726\373\036V"}, 
        {134, "WAVE_FORMAT_DF_GSM610V"}, 
        {137, "WAVE_FORMAT_ONLIVE#\373\036V"}, 
        {145, "WAVE_FORMAT_SBC24\034#\373\036V"}, 
        {146, "WAVE_FORMAT_DOLBY_AC3_SPDIF"}, 
        {151, "WAVE_FORMAT_ZYXEL_ADPCM"}, 
        {152, "WAVE_FORMAT_PHILIPS_LPCBB"}, 
        {153, "WAVE_FORMAT_PACKED#\373\036V"}, 
        {256, "WAVE_FORMAT_RHETOREX_ADPCM"}, 
        {257, "IBM_FORMAT_MULAW\250"}, 
        {258, "IBM_FORMAT_ALAW"}, 
        {259, "IBM_FORMAT_ADPCM\250"}, 
        {273, "WAVE_FORMAT_VIVO_G723"}, 
        {274, "WAVE_FORMAT_VIVO_SIREN"}, 
        {291, "WAVE_FORMAT_DIGITAL_G723\250"}, 
        {512, "WAVE_FORMAT_CREATIVE_ADPCM"}, 
        {514, "WAVE_FORMAT_CREATIVE_FASTSPEECH8\250"}, 
        {515, "WAVE_FORMAT_CREATIVE_FASTSPEECH10\022#\373\036V"}, 
        {544, "WAVE_FORMAT_QUARTERDECK"}, 
        {768, "WAVE_FORMAT_FM_TOWNS_SND\250"}, 
        {1024, "WAVE_FORMAT_BZV_DIGITAL"}, 
        {1664, "WAVE_FORMAT_VME_VMPCMV"}, 
        {4096, "WAVE_FORMAT_OLIGSM#\373\036V"}, 
        {4097, "WAVE_FORMAT_OLIADPCM\036V"}, 
        {4098, "WAVE_FORMAT_OLICELP\373\036V"}, 
        {4099, "WAVE_FORMAT_OLISBC#\373\036V"}, 
        {4100, "WAVE_FORMAT_OLIOPR#\373\036V"}, 
        {4352, "WAVE_FORMAT_LH_CODEC\036V"}, 
        {5120, "WAVE_FORMAT_NORRIS"}, 
        {5376, "WAVE_FORMAT_SOUNDSPACE_MUSICOMPRESS"}, 
        {8192, "WAVE_FORMAT_DVM"}, 
        {29008, "WAVE_FORMAT_INTERWAV_VSC112"}, 
        {29232, "WAVE_FORMAT_IPP_ITU_G_723_1"}, 
        {65534, "WAVE_FORMAT_EXTENSIBLE"}};
#line 549 "/root/libsndfile/src/wav_w64.c"
char const   *wav_w64_format_str(int k ) 
{ 
  int lower ;
  int upper ;
  int mid ;

  {
#line 552
  lower = - 1;
#line 553
  upper = (int )(sizeof(wave_descs) / sizeof(WAV_FORMAT_DESC ));
#line 556
  if (wave_descs[0].ID <= k) {
#line 556
    if (k <= wave_descs[upper - 1].ID) {
      {
#line 558
      while (1) {
        while_continue: /* CIL Label */ ;
#line 558
        if (! (lower + 1 < upper)) {
#line 558
          goto while_break;
        }
#line 559
        mid = (upper + lower) / 2;
#line 561
        if (k == wave_descs[mid].ID) {
#line 562
          return (wave_descs[mid].name);
        }
#line 563
        if (k < wave_descs[mid].ID) {
#line 564
          upper = mid;
        } else {
#line 566
          lower = mid;
        }
      }
      while_break: /* CIL Label */ ;
      }

    }
  }

#line 570
  return ("Unknown format");
}
}
#line 574 "/root/libsndfile/src/wav_w64.c"
int wav_w64_srate2blocksize(int srate_chan_product ) 
{ 


  {
#line 575
  if (srate_chan_product < 12000) {
#line 576
    return (256);
  }
#line 577
  if (srate_chan_product < 23000) {
#line 578
    return (512);
  }
#line 579
  if (srate_chan_product < 44000) {
#line 580
    return (1024);
  }
#line 581
  return (2048);
}
}
#line 87 "/root/libsndfile/src/w64.c"
static unsigned char riff_MARKER16[16]  = 
#line 87 "/root/libsndfile/src/w64.c"
  {      (unsigned char )'r',      (unsigned char )'i',      (unsigned char )'f',      (unsigned char )'f', 
        (unsigned char )46,      (unsigned char )145,      (unsigned char )207,      (unsigned char )17, 
        (unsigned char )165,      (unsigned char )214,      (unsigned char )40,      (unsigned char )219, 
        (unsigned char )4,      (unsigned char )193,      (unsigned char )0,      (unsigned char )0};
#line 91 "/root/libsndfile/src/w64.c"
static unsigned char wave_MARKER16[16]  = 
#line 91
  {      (unsigned char )'w',      (unsigned char )'a',      (unsigned char )'v',      (unsigned char )'e', 
        (unsigned char )243,      (unsigned char )172,      (unsigned char )211,      (unsigned char )17, 
        (unsigned char )140,      (unsigned char )209,      (unsigned char )0,      (unsigned char )192, 
        (unsigned char )79,      (unsigned char )142,      (unsigned char )219,      (unsigned char )138};
#line 94 "/root/libsndfile/src/w64.c"
static unsigned char fmt_MARKER16[16]  = 
#line 94
  {      (unsigned char )'f',      (unsigned char )'m',      (unsigned char )'t',      (unsigned char )' ', 
        (unsigned char )243,      (unsigned char )172,      (unsigned char )211,      (unsigned char )17, 
        (unsigned char )140,      (unsigned char )209,      (unsigned char )0,      (unsigned char )192, 
        (unsigned char )79,      (unsigned char )142,      (unsigned char )219,      (unsigned char )138};
#line 97 "/root/libsndfile/src/w64.c"
static unsigned char fact_MARKER16[16]  = 
#line 97
  {      (unsigned char )'f',      (unsigned char )'a',      (unsigned char )'c',      (unsigned char )'t', 
        (unsigned char )243,      (unsigned char )172,      (unsigned char )211,      (unsigned char )17, 
        (unsigned char )140,      (unsigned char )209,      (unsigned char )0,      (unsigned char )192, 
        (unsigned char )79,      (unsigned char )142,      (unsigned char )219,      (unsigned char )138};
#line 100 "/root/libsndfile/src/w64.c"
static unsigned char data_MARKER16[16]  = 
#line 100
  {      (unsigned char )'d',      (unsigned char )'a',      (unsigned char )'t',      (unsigned char )'a', 
        (unsigned char )243,      (unsigned char )172,      (unsigned char )211,      (unsigned char )17, 
        (unsigned char )140,      (unsigned char )209,      (unsigned char )0,      (unsigned char )192, 
        (unsigned char )79,      (unsigned char )142,      (unsigned char )219,      (unsigned char )138};
#line 115
static int w64_read_header(SF_PRIVATE *psf , int *blockalign , int *framesperblock ) ;
#line 116
static int w64_write_header(SF_PRIVATE *psf , int calc_length ) ;
#line 117
static int w64_close(SF_PRIVATE *psf ) ;
#line 124 "/root/libsndfile/src/w64.c"
int w64_open(SF_PRIVATE *psf ) 
{ 
  WAV_PRIVATE *wpriv ;
  int subformat ;
  int error ;
  int blockalign ;
  int framesperblock ;
  void *__cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  sf_count_t tmp ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;

  {
#line 126
  blockalign = 0;
  {
#line 126
  framesperblock = 0;
#line 128
  wpriv = (WAV_PRIVATE *)calloc((unsigned long )1, sizeof(WAV_PRIVATE ));
  }
#line 128
  if (wpriv == (void *)0) {
#line 129
    return (16);
  }
#line 130
  psf->container_data = wpriv;
#line 132
  if (psf->mode == 16) {
    _L: /* CIL Label */ 
    {
#line 133
    error = w64_read_header(psf, & blockalign, & framesperblock);
    }
#line 133
    if (error) {
#line 134
      return (error);
    }
  } else
#line 132
  if (psf->mode == 48) {
#line 132
    if (psf->filelength > 0L) {
#line 132
      goto _L;
    }
  }

#line 137
  if ((psf->sf.format & 268369920) != 720896) {
#line 138
    return (1);
  }
#line 140
  subformat = psf->sf.format & 65535;
#line 142
  if (psf->mode == 32) {
    _L___20: /* CIL Label */ 
#line 143
    if (psf->is_pipe) {
#line 144
      return (28);
    }
#line 146
    psf->endian = 268435456;
#line 148
    psf->blockwidth = psf->bytewidth * psf->sf.channels;
#line 150
    if (subformat == 18) {
      _L___19: /* CIL Label */ 
      {
#line 151
      blockalign = wav_w64_srate2blocksize(psf->sf.samplerate * psf->sf.channels);
#line 152
      framesperblock = - 1;
#line 155
      psf->filelength = (sf_count_t )-1LL;
#line 156
      psf->datalength = psf->filelength;
      }
#line 157
      if (psf->sf.frames <= 0L) {
#line 158
        if (psf->blockwidth) {
#line 158
          tmp = psf->filelength / (long )psf->blockwidth;
        } else {
#line 158
          tmp = psf->filelength;
        }
#line 158
        psf->sf.frames = tmp;
      }
    } else
#line 150
    if (subformat == 19) {
#line 150
      goto _L___19;
    }
    {
#line 162
    error = w64_write_header(psf, 0);
    }
#line 162
    if (error) {
#line 163
      return (error);
    }
#line 165
    psf->write_header = & w64_write_header;
  } else
#line 142
  if (psf->mode == 48) {
#line 142
    goto _L___20;
  }
#line 168
  psf->container_close = & w64_close;
  {
#line 171
  if (subformat == 5) {
#line 171
    goto case_5;
  }
#line 177
  if (subformat == 4) {
#line 177
    goto case_4;
  }
#line 177
  if (subformat == 3) {
#line 177
    goto case_4;
  }
#line 177
  if (subformat == 2) {
#line 177
    goto case_4;
  }
#line 181
  if (subformat == 16) {
#line 181
    goto case_16;
  }
#line 185
  if (subformat == 17) {
#line 185
    goto case_17;
  }
#line 190
  if (subformat == 6) {
#line 190
    goto case_6;
  }
#line 194
  if (subformat == 7) {
#line 194
    goto case_7;
  }
#line 198
  if (subformat == 18) {
#line 198
    goto case_18;
  }
#line 202
  if (subformat == 19) {
#line 202
    goto case_19;
  }
#line 207
  if (subformat == 32) {
#line 207
    goto case_32;
  }
#line 211
  goto switch_default;
  case_5: /* CIL Label */ 
  {
#line 172
  error = pcm_init(psf);
  }
#line 173
  goto switch_break;
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 178
  error = pcm_init(psf);
  }
#line 179
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 182
  error = ulaw_init(psf);
  }
#line 183
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 186
  error = alaw_init(psf);
  }
#line 187
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 191
  error = float32_init(psf);
  }
#line 192
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 195
  error = double64_init(psf);
  }
#line 196
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 199
  error = wav_w64_ima_init(psf, blockalign, framesperblock);
  }
#line 200
  goto switch_break;
  case_19: /* CIL Label */ 
  {
#line 203
  error = wav_w64_msadpcm_init(psf, blockalign, framesperblock);
  }
#line 204
  goto switch_break;
  case_32: /* CIL Label */ 
  {
#line 208
  error = gsm610_init(psf);
  }
#line 209
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 211
  return (17);
  switch_break: /* CIL Label */ ;
  }

#line 214
  return (error);
}
}
#line 222 "/root/libsndfile/src/w64.c"
static int w64_read_header(SF_PRIVATE *psf , int *blockalign , int *framesperblock ) 
{ 
  WAV_PRIVATE *wpriv ;
  WAV_FMT *wav_fmt ;
  int dword ;
  int marker ;
  int format ;
  sf_count_t chunk_size ;
  sf_count_t bytesread ;
  int parsestage ;
  int error ;
  int done ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  sf_count_t frames ;
  sf_count_t __cil_tmp19 ;
  sf_count_t __cil_tmp20 ;
  sf_count_t __cil_tmp21 ;
  int __cil_tmp22 ;
  int tmp ;

  {
#line 225
  dword = 0;
#line 225
  format = 0;
#line 226
  bytesread = (sf_count_t )0;
#line 227
  parsestage = 0;
#line 227
  done = 0;
#line 229
  wpriv = psf->container_data;
#line 229
  if (wpriv == (void *)0) {
#line 230
    return (29);
  }
  {
#line 231
  wav_fmt = & wpriv->wav_fmt;
#line 234
  psf_binheader_readf(psf, "p", 0);
  }
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
#line 236
    if (! (! done)) {
#line 236
      goto while_break;
    }
#line 238
    if (psf->headindex & 7) {
      {
#line 239
      psf_binheader_readf(psf, "j", 8 - (psf->headindex & 7));
      }
    }
    {
#line 242
    __cil_tmp14 = psf_binheader_readf(psf, "h", & marker);
    }
#line 242
    bytesread += (long )__cil_tmp14;
#line 243
    chunk_size = (sf_count_t )0;
    {
#line 246
    if (marker == (((((((((((((114 ^ (105 << 1)) ^ (102 << 2)) ^ (102 << 3)) ^ (46 << 4)) ^ (145 << 5)) ^ (207 << 6)) ^ (17 << 7)) ^ (165 << 8)) ^ (214 << 9)) ^ (40 << 10)) ^ (219 << 11)) ^ (4 << 12)) ^ (193 << 13))) {
#line 246
      goto case_exp;
    }
#line 260
    if (marker == (((((((((((((((109 ^ (7 << 1)) ^ (28 << 2)) ^ (234 << 3)) ^ (163 << 4)) ^ (239 << 5)) ^ (120 << 6)) ^ (76 << 7)) ^ (144 << 8)) ^ (87 << 9)) ^ (127 << 10)) ^ (121 << 11)) ^ (238 << 12)) ^ (37 << 13)) ^ (42 << 14)) ^ (174 << 15))) {
#line 260
      goto case_exp___0;
    }
#line 264
    if (marker == ((((((((((((((119 ^ (97 << 1)) ^ (118 << 2)) ^ (101 << 3)) ^ (243 << 4)) ^ (172 << 5)) ^ (211 << 6)) ^ (17 << 7)) ^ (140 << 8)) ^ (209 << 9)) ^ (192 << 11)) ^ (79 << 12)) ^ (142 << 13)) ^ (219 << 14)) ^ (138 << 15))) {
#line 264
      goto case_exp___1;
    }
#line 271
    if (marker == ((((((((((((((102 ^ (109 << 1)) ^ (116 << 2)) ^ (32 << 3)) ^ (243 << 4)) ^ (172 << 5)) ^ (211 << 6)) ^ (17 << 7)) ^ (140 << 8)) ^ (209 << 9)) ^ (192 << 11)) ^ (79 << 12)) ^ (142 << 13)) ^ (219 << 14)) ^ (138 << 15))) {
#line 271
      goto case_exp___2;
    }
#line 291
    if (marker == ((((((((((((((102 ^ (97 << 1)) ^ (99 << 2)) ^ (116 << 3)) ^ (243 << 4)) ^ (172 << 5)) ^ (211 << 6)) ^ (17 << 7)) ^ (140 << 8)) ^ (209 << 9)) ^ (192 << 11)) ^ (79 << 12)) ^ (142 << 13)) ^ (219 << 14)) ^ (138 << 15))) {
#line 291
      goto case_exp___3;
    }
#line 301
    if (marker == ((((((((((((((100 ^ (97 << 1)) ^ (116 << 2)) ^ (97 << 3)) ^ (243 << 4)) ^ (172 << 5)) ^ (211 << 6)) ^ (17 << 7)) ^ (140 << 8)) ^ (209 << 9)) ^ (192 << 11)) ^ (79 << 12)) ^ (142 << 13)) ^ (219 << 14)) ^ (138 << 15))) {
#line 301
      goto case_exp___4;
    }
#line 325
    if (marker == ((((((((((((((108 ^ (101 << 1)) ^ (118 << 2)) ^ (108 << 3)) ^ (243 << 4)) ^ (172 << 5)) ^ (211 << 6)) ^ (17 << 7)) ^ (209 << 8)) ^ (140 << 9)) ^ (192 << 11)) ^ (79 << 12)) ^ (142 << 13)) ^ (219 << 14)) ^ (138 << 15))) {
#line 325
      goto case_exp___5;
    }
#line 332
    if (marker == (((((((((((((108 ^ (105 << 1)) ^ (115 << 2)) ^ (116 << 3)) ^ (47 << 4)) ^ (145 << 5)) ^ (207 << 6)) ^ (17 << 7)) ^ (165 << 8)) ^ (214 << 9)) ^ (40 << 10)) ^ (219 << 11)) ^ (4 << 12)) ^ (193 << 13))) {
#line 332
      goto case_exp___6;
    }
#line 339
    if (marker == ((((((((((((((106 ^ (117 << 1)) ^ (110 << 2)) ^ (107 << 3)) ^ (243 << 4)) ^ (172 << 5)) ^ (211 << 6)) ^ (17 << 7)) ^ (140 << 8)) ^ (209 << 9)) ^ (192 << 11)) ^ (79 << 12)) ^ (142 << 13)) ^ (219 << 14)) ^ (138 << 15))) {
#line 339
      goto case_exp___7;
    }
#line 346
    if (marker == ((((((((((((((98 ^ (101 << 1)) ^ (120 << 2)) ^ (116 << 3)) ^ (243 << 4)) ^ (172 << 5)) ^ (211 << 6)) ^ (170 << 7)) ^ (209 << 8)) ^ (140 << 9)) ^ (192 << 11)) ^ (79 << 12)) ^ (142 << 13)) ^ (219 << 14)) ^ (138 << 15))) {
#line 346
      goto case_exp___8;
    }
#line 353
    if (marker == ((((((((((((((86 ^ (98 << 1)) ^ (247 << 2)) ^ (171 << 3)) ^ (45 << 4)) ^ (57 << 5)) ^ (210 << 6)) ^ (17 << 7)) ^ (134 << 8)) ^ (199 << 9)) ^ (192 << 11)) ^ (79 << 12)) ^ (142 << 13)) ^ (219 << 14)) ^ (138 << 15))) {
#line 353
      goto case_exp___9;
    }
#line 360
    if (marker == ((((((((((((((188 ^ (148 << 1)) ^ (95 << 2)) ^ (146 << 3)) ^ (90 << 4)) ^ (82 << 5)) ^ (210 << 6)) ^ (17 << 7)) ^ (134 << 8)) ^ (220 << 9)) ^ (192 << 11)) ^ (79 << 12)) ^ (142 << 13)) ^ (219 << 14)) ^ (138 << 15))) {
#line 360
      goto case_exp___10;
    }
#line 367
    goto switch_default;
    case_exp: /* CIL Label */ 
#line 247
    if (parsestage) {
#line 248
      return (118);
    }
    {
#line 250
    __cil_tmp15 = psf_binheader_readf(psf, "e8;\373\036V", & chunk_size);
    }
#line 250
    bytesread += (long )__cil_tmp15;
#line 252
    if (psf->filelength != chunk_size) {
      {
#line 253
      psf_log_printf(psf, "riff : %D (should be %D)\n", chunk_size, psf->filelength);
      }
    } else {
      {
#line 255
      psf_log_printf(psf, "riff : %D\n;\373\036V", chunk_size);
      }
    }
#line 257
    parsestage |= 1;
#line 258
    goto switch_break;
    case_exp___0: /* CIL Label */ 
    {
#line 261
    psf_log_printf(psf, "Looks like an ACID file. Exiting.\n");
    }
#line 262
    return (17);
    case_exp___1: /* CIL Label */ 
#line 265
    if ((parsestage & 1) != 1) {
#line 266
      return (119);
    }
    {
#line 267
    psf_log_printf(psf, "wave\n");
#line 268
    parsestage |= 2;
    }
#line 269
    goto switch_break;
    case_exp___2: /* CIL Label */ 
#line 272
    if ((parsestage & 3) != 3) {
#line 273
      return (59);
    }
    {
#line 275
    __cil_tmp16 = psf_binheader_readf(psf, "e8", & chunk_size);
    }
    {
#line 275
    bytesread += (long )__cil_tmp16;
#line 276
    psf_log_printf(psf, " fmt : %D\n:\373\036V", chunk_size);
#line 279
    chunk_size -= (long )24;
#line 281
    error = wav_w64_read_fmt_chunk(psf, (int )chunk_size);
    }
#line 281
    if (error) {
#line 282
      return (error);
    }
#line 284
    if (chunk_size % 8L) {
      {
#line 285
      psf_binheader_readf(psf, "j", 8L - chunk_size % 8L);
      }
    }
#line 287
    format = (int )wav_fmt->format;
#line 288
    parsestage |= 4;
#line 289
    goto switch_break;
    case_exp___3: /* CIL Label */ 
    {
#line 294
    psf_binheader_readf(psf, "e88", & chunk_size, & frames);
#line 295
    psf_log_printf(psf, "   fact : %D\n     frames : %D\n", chunk_size, frames);
    }

#line 298
    goto switch_break;
    case_exp___4: /* CIL Label */ 
#line 302
    if ((parsestage & 7) != 7) {
#line 303
      return (120);
    }
    {
#line 305
    psf_binheader_readf(psf, "e8", & chunk_size);
#line 307
    psf->dataoffset = psf_ftell(psf);
#line 309
    psf->datalength = chunk_size - 24L;
    }
#line 311
    if (chunk_size % 8L) {
#line 312
      chunk_size += 8L - chunk_size % 8L;
    }
    {
#line 314
    psf_log_printf(psf, "data : %D\n", chunk_size);
#line 316
    parsestage |= 32;
    }
#line 318
    if (! psf->sf.seekable) {
#line 319
      goto switch_break;
    }
    {
#line 322
    psf_fseek(psf, chunk_size, 1);
    }
#line 323
    goto switch_break;
    case_exp___5: /* CIL Label */ 
    {
#line 326
    psf_binheader_readf(psf, "e8", & chunk_size);
    }
    {
#line 327
    psf_log_printf(psf, "levl : %D\n", chunk_size);
#line 328
    dword = (int )chunk_size;
#line 329
    psf_binheader_readf(psf, "j", dword - 24);
    }
#line 330
    goto switch_break;
    case_exp___6: /* CIL Label */ 
    {
#line 333
    psf_binheader_readf(psf, "e8", & chunk_size);
    }
    {
#line 334
    psf_log_printf(psf, "list : %D\n", chunk_size);
#line 335
    dword = (int )chunk_size;
#line 336
    psf_binheader_readf(psf, "j", dword - 24);
    }
#line 337
    goto switch_break;
    case_exp___7: /* CIL Label */ 
    {
#line 340
    psf_binheader_readf(psf, "e8", & chunk_size);
    }
    {
#line 341
    psf_log_printf(psf, "junk : %D\n", chunk_size);
#line 342
    dword = (int )chunk_size;
#line 343
    psf_binheader_readf(psf, "j", dword - 24);
    }
#line 344
    goto switch_break;
    case_exp___8: /* CIL Label */ 
    {
#line 347
    psf_binheader_readf(psf, "e8", & chunk_size);
    }
    {
#line 348
    psf_log_printf(psf, "bext : %D\n", chunk_size);
#line 349
    dword = (int )chunk_size;
#line 350
    psf_binheader_readf(psf, "j", dword - 24);
    }
#line 351
    goto switch_break;
    case_exp___9: /* CIL Label */ 
    {
#line 354
    psf_binheader_readf(psf, "e8", & chunk_size);
    }
    {
#line 355
    psf_log_printf(psf, "marker : %D\n", chunk_size);
#line 356
    dword = (int )chunk_size;
#line 357
    psf_binheader_readf(psf, "j", dword - 24);
    }
#line 358
    goto switch_break;
    case_exp___10: /* CIL Label */ 
    {
#line 361
    psf_binheader_readf(psf, "e8", & chunk_size);
    }
    {
#line 362
    psf_log_printf(psf, "summary list : %D\n", chunk_size);
#line 363
    dword = (int )chunk_size;
#line 364
    psf_binheader_readf(psf, "j", dword - 24);
    }
#line 365
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 368
    psf_log_printf(psf, "*** Unknown chunk marker : %X. Exiting parser.\n", marker);
    }
#line 369
    done = 1;
#line 370
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }

#line 373
    if (psf->sf.seekable == 0) {
#line 373
      if (parsestage & 32) {
#line 374
        goto while_break;
      }
    }
    {
#line 376
    __cil_tmp20 = psf_ftell(psf);
    }
#line 376
    if (__cil_tmp20 >= psf->filelength - (long )(2 * (int )sizeof(dword))) {
#line 377
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 380
  if (psf->dataoffset <= 0L) {
#line 381
    return (120);
  }
  {
#line 383
  psf->endian = 268435456;
#line 385
  __cil_tmp21 = psf_ftell(psf);
  }
#line 385
  if (__cil_tmp21 != psf->dataoffset) {
    {
#line 386
    psf_fseek(psf, psf->dataoffset, 0);
    }
  }
#line 388
  if (psf->blockwidth) {
#line 389
    if (psf->filelength - psf->dataoffset < psf->datalength) {
#line 390
      psf->sf.frames = (psf->filelength - psf->dataoffset) / (long )psf->blockwidth;
    } else {
#line 392
      psf->sf.frames = psf->datalength / (long )psf->blockwidth;
    }
  }

  {
#line 397
  if (format == 65534) {
#line 397
    goto case_65534;
  }
#line 397
  if (format == 1) {
#line 397
    goto case_65534;
  }
#line 402
  if (format == 7) {
#line 402
    goto case_7;
  }
#line 406
  if (format == 6) {
#line 406
    goto case_6;
  }
#line 410
  if (format == 2) {
#line 410
    goto case_2;
  }
#line 416
  if (format == 17) {
#line 416
    goto case_17;
  }
#line 422
  if (format == 49) {
#line 422
    goto case_49;
  }
#line 426
  if (format == 3) {
#line 426
    goto case_3;
  }
#line 431
  goto switch_default___0;
  case_65534: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 399
  __cil_tmp22 = u_bitwidth_to_subformat(psf->bytewidth * 8);
#line 399
  psf->sf.format = 720896 | __cil_tmp22;
  }
#line 400
  goto switch_break___0;
  case_7: /* CIL Label */ 
#line 403
  psf->sf.format = 720912;
#line 404
  goto switch_break___0;
  case_6: /* CIL Label */ 
#line 407
  psf->sf.format = 720913;
#line 408
  goto switch_break___0;
  case_2: /* CIL Label */ 
#line 411
  psf->sf.format = 720915;
#line 412
  *blockalign = (int )wav_fmt->msadpcm.blockalign;
#line 413
  *framesperblock = (int )wav_fmt->msadpcm.samplesperblock;
#line 414
  goto switch_break___0;
  case_17: /* CIL Label */ 
#line 417
  psf->sf.format = 720914;
#line 418
  *blockalign = (int )wav_fmt->ima.blockalign;
#line 419
  *framesperblock = (int )wav_fmt->ima.samplesperblock;
#line 420
  goto switch_break___0;
  case_49: /* CIL Label */ 
#line 423
  psf->sf.format = 720928;
#line 424
  goto switch_break___0;
  case_3: /* CIL Label */ 
#line 427
  psf->sf.format = 720896;
#line 428
  if (psf->bytewidth == 8) {
#line 428
    tmp = 7;
  } else {
#line 428
    tmp = 6;
  }
#line 428
  psf->sf.format |= tmp;
#line 429
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 431
  return (17);
  switch_break___0: /* CIL Label */ ;
  }

#line 434
  return (0);
}
}
#line 438 "/root/libsndfile/src/w64.c"
static int w64_write_header(SF_PRIVATE *psf , int calc_length ) 
{ 
  sf_count_t fmt_size ;
  sf_count_t current ;
  size_t fmt_pad ;
  int subformat ;
  int add_fact_chunk ;
  sf_count_t __cil_tmp8 ;
  sf_count_t __cil_tmp9 ;
  int blockalign ;
  int framesperblock ;
  int bytespersec ;
  int __cil_tmp13 ;
  int blockalign___0 ;
  int framesperblock___0 ;
  int bytespersec___0 ;
  int extrabytes ;
  int __cil_tmp18 ;
  int bytespersec___1 ;

  {
  {
#line 440
  fmt_pad = (size_t )0;
#line 441
  add_fact_chunk = 0;
#line 443
  current = psf_ftell(psf);
  }
#line 445
  if (calc_length) {
    {
#line 446
    psf->filelength = psf_get_filelen(psf);
#line 448
    psf->datalength = psf->filelength - psf->dataoffset;
    }
#line 449
    if (psf->dataend) {
#line 450
      psf->datalength -= psf->filelength - psf->dataend;
    }
#line 452
    if (psf->bytewidth) {
#line 453
      psf->sf.frames = psf->datalength / (long )(psf->bytewidth * psf->sf.channels);
    }
  }
  {
#line 457
  psf->header[0] = (unsigned char )0;
#line 458
  psf->headindex = 0;
#line 459
  psf_fseek(psf, (sf_count_t )0, 0);
#line 462
  psf_binheader_writef(psf, "eh8hh", (unsigned char *)riff_MARKER16, psf->filelength,
                       (unsigned char *)wave_MARKER16, (unsigned char *)fmt_MARKER16);
#line 464
  subformat = psf->sf.format & 65535;
  }
  {
#line 470
  if (subformat == 4) {
#line 470
    goto case_4;
  }
#line 470
  if (subformat == 3) {
#line 470
    goto case_4;
  }
#line 470
  if (subformat == 2) {
#line 470
    goto case_4;
  }
#line 470
  if (subformat == 5) {
#line 470
    goto case_4;
  }
#line 484
  if (subformat == 7) {
#line 484
    goto case_7;
  }
#line 484
  if (subformat == 6) {
#line 484
    goto case_7;
  }
#line 499
  if (subformat == 16) {
#line 499
    goto case_16;
  }
#line 514
  if (subformat == 17) {
#line 514
    goto case_17;
  }
#line 530
  if (subformat == 18) {
#line 530
    goto case_18;
  }
#line 555
  if (subformat == 19) {
#line 555
    goto case_19;
  }
#line 584
  if (subformat == 32) {
#line 584
    goto case_32;
  }
#line 607
  goto switch_default;
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 471
  fmt_size = (sf_count_t )40;
  {
#line 472
  fmt_pad = (size_t )(8L - (fmt_size & 7L));
#line 473
  fmt_size += fmt_pad;
#line 476
  psf_binheader_writef(psf, "e8224", fmt_size, 1, psf->sf.channels, psf->sf.samplerate);
#line 478
  psf_binheader_writef(psf, "e4<\373\036V", (psf->sf.samplerate * psf->bytewidth) * psf->sf.channels);
#line 480
  psf_binheader_writef(psf, "e22\373\036V", psf->bytewidth * psf->sf.channels, psf->bytewidth * 8);
  }
#line 481
  goto switch_break;
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
#line 485
  fmt_size = (sf_count_t )40;
  {
#line 486
  fmt_pad = (size_t )(8L - (fmt_size & 7L));
#line 487
  fmt_size += fmt_pad;
#line 490
  psf_binheader_writef(psf, "e8224", fmt_size, 3, psf->sf.channels, psf->sf.samplerate);
#line 492
  psf_binheader_writef(psf, "e4", (psf->sf.samplerate * psf->bytewidth) * psf->sf.channels);
#line 494
  psf_binheader_writef(psf, "e22", psf->bytewidth * psf->sf.channels, psf->bytewidth * 8);
#line 496
  add_fact_chunk = 1;
  }
#line 497
  goto switch_break;
  case_16: /* CIL Label */ 
#line 500
  fmt_size = (sf_count_t )40;
  {
#line 501
  fmt_pad = (size_t )(8L - (fmt_size & 7L));
#line 502
  fmt_size += fmt_pad;
#line 505
  psf_binheader_writef(psf, "e8224", fmt_size, 7, psf->sf.channels, psf->sf.samplerate);
#line 507
  psf_binheader_writef(psf, "e4", (psf->sf.samplerate * psf->bytewidth) * psf->sf.channels);
#line 509
  psf_binheader_writef(psf, "e22", psf->bytewidth * psf->sf.channels, 8);
#line 511
  add_fact_chunk = 1;
  }
#line 512
  goto switch_break;
  case_17: /* CIL Label */ 
#line 515
  fmt_size = (sf_count_t )40;
  {
#line 516
  fmt_pad = (size_t )(8L - (fmt_size & 7L));
#line 517
  fmt_size += fmt_pad;
#line 520
  psf_binheader_writef(psf, "e8224", fmt_size, 6, psf->sf.channels, psf->sf.samplerate);
#line 522
  psf_binheader_writef(psf, "e4", (psf->sf.samplerate * psf->bytewidth) * psf->sf.channels);
#line 524
  psf_binheader_writef(psf, "e22", psf->bytewidth * psf->sf.channels, 8);
#line 526
  add_fact_chunk = 1;
  }
#line 527
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 533
  blockalign = wav_w64_srate2blocksize(psf->sf.samplerate * psf->sf.channels);
#line 534
  framesperblock = (2 * (blockalign - 4 * psf->sf.channels)) / psf->sf.channels + 1;
#line 535
  bytespersec = (psf->sf.samplerate * blockalign) / framesperblock;
#line 538
  fmt_size = (sf_count_t )44;
#line 539
  fmt_pad = (size_t )(8L - (fmt_size & 7L));
#line 540
  fmt_size += fmt_pad;
#line 543
  psf_binheader_writef(psf, "e822\036V", fmt_size, 17, psf->sf.channels);
#line 546
  psf_binheader_writef(psf, "e44\373\036V", psf->sf.samplerate, bytespersec);
#line 549
  psf_binheader_writef(psf, "e2222", blockalign, 4, 2, framesperblock);
  }
#line 552
  add_fact_chunk = 1;
#line 553
  goto switch_break;
  case_19: /* CIL Label */ 
  {
#line 558
  blockalign___0 = wav_w64_srate2blocksize(psf->sf.samplerate * psf->sf.channels);
#line 559
  framesperblock___0 = 2 + (2 * (blockalign___0 - 7 * psf->sf.channels)) / psf->sf.channels;
#line 560
  bytespersec___0 = (psf->sf.samplerate * blockalign___0) / framesperblock___0;
#line 563
  extrabytes = 32;
#line 564
  fmt_size = (sf_count_t )(42 + extrabytes);
#line 565
  fmt_pad = (size_t )(8L - (fmt_size & 7L));
#line 566
  fmt_size += fmt_pad;
#line 569
  psf_binheader_writef(psf, "e822\036V", fmt_size, 2, psf->sf.channels);
#line 572
  psf_binheader_writef(psf, "e44", psf->sf.samplerate, bytespersec___0);
#line 575
  psf_binheader_writef(psf, "e22222", blockalign___0, 4, extrabytes, framesperblock___0,
                       7);
#line 577
  msadpcm_write_adapt_coeffs(psf);
  }
#line 580
  add_fact_chunk = 1;
#line 581
  goto switch_break;
  case_32: /* CIL Label */ 
  {
#line 587
  bytespersec___1 = (psf->sf.samplerate * 65) / 320;
#line 590
  fmt_size = (sf_count_t )44;
#line 591
  fmt_pad = (size_t )(8L - (fmt_size & 7L));
#line 592
  fmt_size += fmt_pad;
#line 595
  psf_binheader_writef(psf, "e822", fmt_size, 49, psf->sf.channels);
#line 598
  psf_binheader_writef(psf, "e44", psf->sf.samplerate, bytespersec___1);
#line 601
  psf_binheader_writef(psf, "e2222", 65, 0, 2, 320);
  }
#line 604
  add_fact_chunk = 1;
#line 605
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 607
  return (17);
  switch_break: /* CIL Label */ ;
  }

#line 611
  if (fmt_pad > 0UL) {
    {
#line 612
    psf_binheader_writef(psf, "z\353<\373\036V", fmt_pad);
    }
  }
#line 614
  if (add_fact_chunk) {
    {
#line 615
    psf_binheader_writef(psf, "eh88\036V", (unsigned char *)fact_MARKER16, (sf_count_t )32,
                         psf->sf.frames);
    }
  }
  {
#line 617
  psf_binheader_writef(psf, "eh8\373\036V", (unsigned char *)data_MARKER16, psf->datalength + 24L);
#line 618
  psf_fwrite((unsigned char *)psf->header, (sf_count_t )psf->headindex, (sf_count_t )1,
             psf);
  }
#line 620
  if (psf->error) {
#line 621
    return (psf->error);
  }
#line 623
  psf->dataoffset = (sf_count_t )psf->headindex;
#line 625
  if (current > 0L) {
    {
#line 626
    psf_fseek(psf, current, 0);
    }
  }
#line 628
  return (psf->error);
}
}
#line 632 "/root/libsndfile/src/w64.c"
static int w64_close(SF_PRIVATE *psf ) 
{ 


  {
#line 634
  if (psf->mode == 32) {
    {
    {
#line 635
    w64_write_header(psf, 1);
    }
    }
  } else
#line 634
  if (psf->mode == 48) {
    {
    {
#line 635
    w64_write_header(psf, 1);
    }
    }
  }
#line 637
  return (0);
}
}
#line 46 "/root/libsndfile/src/wve.c"
static int wve_read_header(SF_PRIVATE *psf ) ;
#line 47
static int wve_write_header(SF_PRIVATE *psf , int calc_length ) ;
#line 48
static int wve_close(SF_PRIVATE *psf ) ;
#line 55 "/root/libsndfile/src/wve.c"
int wve_open(SF_PRIVATE *psf ) 
{ 
  int error ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
#line 56
  error = 0;
#line 58
  if (psf->is_pipe) {
#line 59
    return (154);
  }
#line 61
  if (psf->mode == 16) {
    _L: /* CIL Label */ 
    {
#line 62
    error = wve_read_header(psf);
    }
#line 62
    if (error) {
#line 63
      return (error);
    }
  } else
#line 61
  if (psf->mode == 48) {
#line 61
    if (psf->filelength > 0L) {
#line 61
      goto _L;
    }
  }

#line 66
  if (psf->mode == 32) {
    _L___21: /* CIL Label */ 
#line 67
    if ((psf->sf.format & 268369920) != 1638400) {
#line 68
      return (1);
    }
    {
#line 70
    psf->endian = 536870912;
#line 72
    error = wve_write_header(psf, 0);
    }
#line 72
    if (error) {
#line 73
      return (error);
    }
#line 75
    psf->write_header = & wve_write_header;
  } else
#line 66
  if (psf->mode == 48) {
#line 66
    goto _L___21;
  }
  {
#line 78
  psf->blockwidth = psf->bytewidth * psf->sf.channels;
#line 80
  psf->container_close = & wve_close;
#line 82
  error = alaw_init(psf);
  }
#line 84
  return (error);
}
}
#line 91 "/root/libsndfile/src/wve.c"
static int wve_read_header(SF_PRIVATE *psf ) 
{ 
  int marker ;
  unsigned short version ;
  unsigned short padding ;
  unsigned short repeats ;
  unsigned short trash ;
  unsigned int datalength ;

  {
  {
#line 97
  psf_binheader_readf(psf, "pm\006<\377\177", 0, & marker);
  }
#line 98
  if (marker != (((65 | (76 << 8)) | (97 << 16)) | (119 << 24))) {
    {
#line 99
    psf_log_printf(psf, "Could not find \'%M\'\n", ((65 | (76 << 8)) | (97 << 16)) | (119 << 24));
    }
#line 100
    return (153);
  }
  {
#line 103
  psf_binheader_readf(psf, "m", & marker);
  }
#line 104
  if (marker != (((83 | (111 << 8)) | (117 << 16)) | (110 << 24))) {
    {
#line 105
    psf_log_printf(psf, "Could not find \'%M\'\n", ((83 | (111 << 8)) | (117 << 16)) | (110 << 24));
    }
#line 106
    return (153);
  }
  {
#line 109
  psf_binheader_readf(psf, "m\213R\373\036V", & marker);
  }
#line 110
  if (marker != (((100 | (70 << 8)) | (105 << 16)) | (108 << 24))) {
    {
#line 111
    psf_log_printf(psf, "Could not find \'%M\'\n", ((100 | (70 << 8)) | (105 << 16)) | (108 << 24));
    }
#line 112
    return (153);
  }
  {
#line 115
  psf_binheader_readf(psf, "m\272R\373\036V", & marker);
  }
#line 116
  if (marker != ((101 | (42 << 8)) | (42 << 16))) {
    {
#line 117
    psf_log_printf(psf, "Could not find \'%M\'\n", (101 | (42 << 8)) | (42 << 16));
    }
#line 118
    return (153);
  }
  {
#line 121
  psf_binheader_readf(psf, "E2", & version);
#line 123
  psf_log_printf(psf, "Psion Palmtop Alaw (.wve)\n  Sample Rate : 8000\n  Channels    : 1\n  Encoding    : A-law\n\373\036V");
  }
#line 128
  if ((int )version != 3856) {
    {
#line 129
    psf_log_printf(psf, "Psion version %d should be %d\n", (int )version, (int )((unsigned short )3856));
    }
  }
  {
#line 131
  psf_binheader_readf(psf, "E4", & datalength);
#line 132
  psf->dataoffset = (sf_count_t )32;
  }
#line 133
  if ((long )datalength != psf->filelength - psf->dataoffset) {
    {
#line 134
    psf->datalength = psf->filelength - psf->dataoffset;
#line 135
    psf_log_printf(psf, "Data length %d should be %D\n", datalength, psf->datalength);
    }
  } else {
#line 138
    psf->datalength = (sf_count_t )datalength;
  }
  {
#line 140
  psf_binheader_readf(psf, "E22222", & padding, & repeats, & trash, & trash, & trash);
#line 142
  psf->sf.format = 1638417;
#line 143
  psf->sf.samplerate = 8000;
#line 144
  psf->sf.frames = psf->datalength;
#line 145
  psf->sf.channels = 1;
  }
#line 147
  return (0);
}
}
#line 154 "/root/libsndfile/src/wve.c"
static int wve_write_header(SF_PRIVATE *psf , int calc_length ) 
{ 
  sf_count_t current ;
  unsigned int datalen ;
  sf_count_t __cil_tmp5 ;
  sf_count_t __cil_tmp6 ;

  {
  {
#line 158
  current = psf_ftell(psf);
  }
#line 160
  if (calc_length) {
    {
#line 161
    psf->filelength = psf_get_filelen(psf);
#line 163
    psf->datalength = psf->filelength - psf->dataoffset;
    }
#line 164
    if (psf->dataend) {
#line 165
      psf->datalength -= psf->filelength - psf->dataend;
    }
#line 167
    psf->sf.frames = psf->datalength / (long )(psf->bytewidth * psf->sf.channels);
  }
  {
#line 171
  psf->header[0] = (unsigned char )0;
#line 172
  psf->headindex = 0;
#line 173
  psf_fseek(psf, (sf_count_t )0, 0);
#line 176
  datalen = (unsigned int )psf->datalength;
#line 177
  psf_binheader_writef(psf, "Emmmm", ((65 | (76 << 8)) | (97 << 16)) | (119 << 24),
                       ((83 | (111 << 8)) | (117 << 16)) | (110 << 24), ((100 | (70 << 8)) | (105 << 16)) | (108 << 24),
                       (101 | (42 << 8)) | (42 << 16));
#line 178
  psf_binheader_writef(psf, "E2422222\251", (int )((unsigned short )3856), datalen,
                       0, 0, 0, 0, 0);
#line 179
  psf_fwrite((unsigned char *)psf->header, (sf_count_t )psf->headindex, (sf_count_t )1,
             psf);
  }
#line 181
  if (psf->sf.channels != 1) {
#line 182
    return (33);
  }
#line 184
  if (psf->error) {
#line 185
    return (psf->error);
  }
#line 187
  psf->dataoffset = (sf_count_t )psf->headindex;
#line 189
  if (current > 0L) {
    {
#line 190
    psf_fseek(psf, current, 0);
    }
  }
#line 192
  return (psf->error);
}
}
#line 199 "/root/libsndfile/src/wve.c"
static int wve_close(SF_PRIVATE *psf ) 
{ 


  {
#line 201
  if (psf->mode == 32) {
    {
    {
#line 205
    wve_write_header(psf, 1);
    }
    }
  } else
#line 201
  if (psf->mode == 48) {
    {
    {
#line 205
    wve_write_header(psf, 1);
    }
    }
  }

#line 208
  return (0);
}
}
#line 72 "/root/libsndfile/src/voc.c"
static int voc_close(SF_PRIVATE *psf ) ;
#line 73
static int voc_write_header(SF_PRIVATE *psf , int calc_length ) ;
#line 74
static int voc_read_header(SF_PRIVATE *psf ) ;
#line 76
static char const   *voc_encoding2str(int encoding ) ;
#line 104 "/root/libsndfile/src/voc.c"
int voc_open(SF_PRIVATE *psf ) 
{ 
  int subformat ;
  int error ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
#line 105
  error = 0;
#line 107
  if (psf->is_pipe) {
#line 108
    return (113);
  }
#line 110
  if (psf->mode == 16) {
    _L: /* CIL Label */ 
    {
#line 111
    error = voc_read_header(psf);
    }
#line 111
    if (error) {
#line 112
      return (error);
    }
  } else
#line 110
  if (psf->mode == 48) {
#line 110
    if (psf->filelength > 0L) {
#line 110
      goto _L;
    }
  }
#line 115
  subformat = psf->sf.format & 65535;
#line 117
  if (psf->mode == 32) {
    _L___22: /* CIL Label */ 
#line 118
    if ((psf->sf.format & 268369920) != 524288) {
#line 119
      return (1);
    }
    {
#line 121
    psf->endian = 268435456;
#line 123
    error = voc_write_header(psf, 0);
    }
#line 123
    if (error) {
#line 124
      return (error);
    }
#line 126
    psf->write_header = & voc_write_header;
  } else
#line 117
  if (psf->mode == 48) {
#line 117
    goto _L___22;
  }
#line 129
  psf->blockwidth = psf->bytewidth * psf->sf.channels;
#line 131
  psf->container_close = & voc_close;
  {
#line 135
  if (subformat == 2) {
#line 135
    goto case_2;
  }
#line 135
  if (subformat == 5) {
#line 135
    goto case_2;
  }
#line 139
  if (subformat == 17) {
#line 139
    goto case_17;
  }
#line 143
  if (subformat == 16) {
#line 143
    goto case_16;
  }
#line 147
  goto switch_default;
  case_2: /* CIL Label */ 
  case_5: /* CIL Label */ 
  {
#line 136
  error = pcm_init(psf);
  }
#line 137
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 140
  error = alaw_init(psf);
  }
#line 141
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 144
  error = ulaw_init(psf);
  }
#line 145
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 147
  return (17);
  switch_break: /* CIL Label */ ;
  }

#line 150
  return (error);
}
}
#line 157 "/root/libsndfile/src/voc.c"
static int voc_read_header(SF_PRIVATE *psf ) 
{ 
  VOC_DATA *pvoc ;
  char creative[20] ;
  unsigned char block_type ;
  unsigned char rate_byte ;
  short version ;
  short checksum ;
  short encoding ;
  short dataoffset ;
  int offset ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  void *__cil_tmp14 ;
  unsigned int size ;
  short count ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  unsigned char compression ;
  int size___0 ;
  int __cil_tmp24 ;
  unsigned char pack ;
  unsigned char stereo ;
  unsigned char compression___0 ;
  unsigned short rate_short ;
  int size___1 ;
  int __cil_tmp30 ;
  char const   *tmp ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  unsigned char bitwidth ;
  unsigned char channels ;
  int size___2 ;
  int fourbytes ;
  int __cil_tmp38 ;
  int temp_size ;
  char const   *__cil_tmp40 ;

  {
  {
#line 165
  offset = psf_binheader_readf(psf, "pb", 0, (char *)creative, (int )sizeof(creative));
  }
#line 167
  if ((int )creative[sizeof(creative) - 1UL] != 26) {
#line 168
    return (104);
  }
  {
#line 171
  creative[sizeof(creative) - 1UL] = (char )0;
#line 173
  __cil_tmp12 = strcmp("Creative Voice File", (char const   *)((char *)creative));
  }
#line 173
  if (__cil_tmp12) {
#line 174
    return (104);
  }
  {
#line 176
  psf_log_printf(psf, "%s\n\373\036V", (char *)creative);
#line 178
  __cil_tmp13 = psf_binheader_readf(psf, "e222", & dataoffset, & version, & checksum);
  }
  {
#line 178
  offset += __cil_tmp13;
#line 180
  psf->dataoffset = (sf_count_t )dataoffset;
#line 182
  psf_log_printf(psf, "dataoffset : %d\nversion    : 0x%X\nchecksum   : 0x%X\n\036V",
                 psf->dataoffset, (int )version, (int )checksum);
  }
#line 186
  if ((int )version != 266) {
#line 186
    if ((int )version != 276) {
#line 187
      return (106);
    }
  }
  {
#line 189
  psf->codec_data = malloc(sizeof(VOC_DATA ));
  }
#line 189
  if (! psf->codec_data) {
#line 190
    return (16);
  }
  {
#line 192
  pvoc = (VOC_DATA *)psf->codec_data;
#line 194
  memset(pvoc, 0, sizeof(VOC_DATA ));
#line 197
  psf->sf.format = 524288;
#line 198
  encoding = (short )5;
#line 199
  psf->endian = 268435456;
  }
  {
#line 201
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 205
    block_type = (unsigned char )0;
#line 206
    __cil_tmp17 = psf_binheader_readf(psf, "1\277g\373\036V", & block_type);
    }
#line 206
    offset += __cil_tmp17;
    {
#line 209
    if ((int )block_type == 5) {
#line 209
      goto case_5;
    }
#line 224
    if ((int )block_type == 6) {
#line 224
      goto case_6;
    }
#line 231
    if ((int )block_type == 9) {
#line 231
      goto case_9;
    }
#line 231
    if ((int )block_type == 8) {
#line 231
      goto case_9;
    }
#line 231
    if ((int )block_type == 1) {
#line 231
      goto case_9;
    }
#line 234
    goto switch_default;
    case_5: /* CIL Label */ 
    {
#line 210
    __cil_tmp18 = psf_binheader_readf(psf, "e3", & size);
    }
    {
#line 210
    offset += __cil_tmp18;
#line 212
    psf_log_printf(psf, " ASCII : %d\n\036V", size);
    }
#line 214
    if ((unsigned long )size < sizeof(psf->header) - 1UL) {
      {
#line 215
      __cil_tmp19 = psf_binheader_readf(psf, "b\270g\373\036V", (unsigned char *)psf->header,
                                        size);
      }
      {
#line 215
      offset += __cil_tmp19;
#line 216
      psf->header[size] = (unsigned char )0;
#line 217
      psf_log_printf(psf, "  text : %s\n\036V", (unsigned char *)psf->header);
      }
#line 218
      goto while_continue;
    }
    {
#line 221
    __cil_tmp20 = psf_binheader_readf(psf, "j\363g\373\036V", size);
    }
#line 221
    offset += __cil_tmp20;
#line 222
    goto while_continue;
    case_6: /* CIL Label */ 
    {
#line 225
    __cil_tmp21 = psf_binheader_readf(psf, "e32\373\036V", & size, & count);
    }
    {
#line 225
    offset += __cil_tmp21;
#line 226
    psf_log_printf(psf, " Repeat : %d\n", (int )count);
    }
#line 227
    goto while_continue;
    case_9: /* CIL Label */ 
    case_8: /* CIL Label */ 
    case_1: /* CIL Label */ 
#line 232
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 234
    psf_log_printf(psf, "*** Weird block marker (%d)\n\036V", (int )block_type);
    }
    switch_break: /* CIL Label */ ;
    }

#line 237
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }

#line 240
  if ((int )block_type == 1) {
    {
#line 244
    __cil_tmp24 = psf_binheader_readf(psf, "e311", & size___0, & rate_byte, & compression);
    }
    {
#line 244
    offset += __cil_tmp24;
#line 246
    psf->sf.samplerate = 1000000 / (256 - ((int )rate_byte & 255));
#line 248
    psf_log_printf(psf, " Sound Data : %d\n  sr   : %d => %dHz\n  comp : %d\n", size___0,
                   (int )rate_byte, psf->sf.samplerate, (int )compression);
    }
#line 251
    if ((long )((offset + size___0) - 1) > psf->filelength) {
      {
#line 252
      psf_log_printf(psf, "Seems to be a truncated file.\n");
#line 253
      psf_log_printf(psf, "offset: %d    size: %d    sum: %d    filelength: %D\n",
                     offset, size___0, offset + size___0, psf->filelength);
      }
#line 254
      return (108);
    } else
#line 256
    if ((psf->filelength - (long )offset) - (long )size___0 > 4L) {
      {
#line 257
      psf_log_printf(psf, "Seems to be a multi-segment file (#1).\n");
#line 258
      psf_log_printf(psf, "offset: %d    size: %d    sum: %d    filelength: %D\n",
                     offset, size___0, offset + size___0, psf->filelength);
      }
#line 259
      return (108);
    }
#line 262
    psf->dataoffset = (sf_count_t )offset;
#line 263
    psf->dataend = psf->filelength - 1L;
#line 265
    psf->sf.channels = 1;
#line 266
    psf->bytewidth = 1;
#line 268
    psf->sf.format = 524293;
#line 270
    return (0);
  }

#line 273
  if ((int )block_type == 8) {
    {
#line 278
    __cil_tmp30 = psf_binheader_readf(psf, "e3211", & size___1, & rate_short, & pack,
                                      & stereo);
    }
    {
#line 278
    offset += __cil_tmp30;
#line 280
    psf_log_printf(psf, " Extended : %d\n", size___1);
    }
#line 281
    if (size___1 == 4) {
      {
#line 282
      psf_log_printf(psf, "  size   : 4\n");
      }
    } else {
      {
#line 284
      psf_log_printf(psf, "  size   : %d (should be 4)\n", size___1);
      }
    }
#line 286
    if ((int )stereo) {
#line 286
      tmp = "yes";
    } else {
#line 286
      tmp = "no";
    }
    {
#line 286
    psf_log_printf(psf, "  pack   : %d\n  stereo : %s\n\230\001", (int )pack, tmp);
    }
#line 289
    if (stereo) {
#line 290
      psf->sf.channels = 2;
#line 291
      psf->sf.samplerate = 128000000 / (65536 - (int )rate_short);
    } else {
#line 294
      psf->sf.channels = 1;
#line 295
      psf->sf.samplerate = 256000000 / (65536 - (int )rate_short);
    }
    {
#line 298
    psf_log_printf(psf, "  sr     : %d => %dHz\n", (int )rate_short & 65535, psf->sf.samplerate);
#line 300
    __cil_tmp32 = psf_binheader_readf(psf, "1", & block_type);
    }
#line 300
    offset += __cil_tmp32;
#line 302
    if ((int )block_type != 1) {
      {
#line 303
      psf_log_printf(psf, "*** Expecting VOC_SOUND_DATA section.\n");
      }
#line 304
      return (105);
    }
    {
#line 307
    __cil_tmp33 = psf_binheader_readf(psf, "e311", & size___1, & rate_byte, & compression___0);
    }
    {
#line 307
    offset += __cil_tmp33;
#line 309
    psf_log_printf(psf, " Sound Data : %d\n  sr     : %d\n  comp   : %d\n", size___1,
                   (int )rate_byte, (int )compression___0);
    }
#line 314
    if ((long )((offset + size___1) - 1) > psf->filelength) {
      {
#line 315
      psf_log_printf(psf, "Seems to be a truncated file.\n");
#line 316
      psf_log_printf(psf, "offset: %d    size: %d    sum: %d    filelength: %D\n",
                     offset, size___1, offset + size___1, psf->filelength);
      }
#line 317
      return (108);
    } else
#line 319
    if ((long )((offset + size___1) - 1) < psf->filelength) {
      {
#line 320
      psf_log_printf(psf, "Seems to be a multi-segment file (#2).\n");
#line 321
      psf_log_printf(psf, "offset: %d    size: %d    sum: %d    filelength: %D\n",
                     offset, size___1, offset + size___1, psf->filelength);
      }
#line 322
      return (108);
    }
#line 325
    psf->dataoffset = (sf_count_t )offset;
#line 326
    psf->dataend = psf->filelength - 1L;
#line 328
    psf->bytewidth = 1;
#line 330
    psf->sf.format = 524293;
#line 332
    return (0);
  }
#line 335
  if ((int )block_type == 9) {
    {
#line 339
    __cil_tmp38 = psf_binheader_readf(psf, "e341124", & size___2, & psf->sf.samplerate,
                                      & bitwidth, & channels, & encoding, & fourbytes);
    }
#line 339
    offset += __cil_tmp38;
#line 342
    if ((long )(size___2 * 2) == psf->filelength - 39L) {
      {
#line 343
      temp_size = (int )(psf->filelength - 31L);
#line 345
      psf_log_printf(psf, " Extended II : %d (SoX bug: should be %d)\n", size___2,
                     temp_size);
#line 346
      size___2 = temp_size;
      }
    } else {
      {
#line 349
      psf_log_printf(psf, " Extended II : %d\n", size___2);
      }
    }
    {
#line 351
    psf_log_printf(psf, "  sample rate : %d\n  bit width   : %d\n  channels    : %d\n",
                   psf->sf.samplerate, (int )bitwidth, (int )channels);
    }
#line 355
    if ((int )bitwidth == 16) {
#line 355
      if ((int )encoding == 0) {
        {
#line 356
        encoding = (short )4;
#line 357
        psf_log_printf(psf, "  encoding    : 0 (SoX bug: should be 4 for 16 bit signed PCM)\n");
        }
      } else {
        {
        {
#line 360
        __cil_tmp40 = voc_encoding2str((int )encoding);
        }
        {
#line 360
        psf_log_printf(psf, "  encoding    : %d => %s\n", (int )encoding, __cil_tmp40);
        }
        }
      }
    } else {
      {
      {
#line 360
      __cil_tmp40 = voc_encoding2str((int )encoding);
      }
      {
#line 360
      psf_log_printf(psf, "  encoding    : %d => %s\n", (int )encoding, __cil_tmp40);
      }
      }
    }
    {
#line 363
    psf_log_printf(psf, "  fourbytes   : %X\n", fourbytes);
#line 365
    psf->sf.channels = (int )channels;
#line 367
    psf->dataoffset = (sf_count_t )offset;
#line 368
    psf->dataend = psf->filelength - 1L;
    }
#line 370
    if ((long )(size___2 + 31) == psf->filelength + 1L) {
      {
#line 374
      psf_log_printf(psf, "Missing zero byte at end of file.\n");
#line 375
      size___2 = (int )(psf->filelength - 30L);
#line 376
      psf->dataend = (sf_count_t )0;
      }
    } else
#line 378
    if ((long )(size___2 + 31) > psf->filelength) {
      {
#line 379
      psf_log_printf(psf, "Seems to be a truncated file.\n");
#line 380
      size___2 = (int )(psf->filelength - 31L);
      }
    } else
#line 382
    if ((long )(size___2 + 31) < psf->filelength) {
      {
#line 383
      psf_log_printf(psf, "Seems to be a multi-segment file (#3).\n");
      }
    }
    {
#line 386
    if ((int )encoding == 0) {
#line 386
      goto case_0;
    }
#line 391
    if ((int )encoding == 4) {
#line 391
      goto case_4;
    }
#line 396
    if ((int )encoding == 6) {
#line 396
      goto case_6___0;
    }
#line 401
    if ((int )encoding == 7) {
#line 401
      goto case_7;
    }
#line 406
    goto switch_default___0;
    case_0: /* CIL Label */ 
#line 387
    psf->sf.format = 524293;
#line 388
    psf->bytewidth = 1;
#line 389
    goto switch_break___0;
    case_4: /* CIL Label */ 
#line 392
    psf->sf.format = 524290;
#line 393
    psf->bytewidth = 2;
#line 394
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
#line 397
    psf->sf.format = 524305;
#line 398
    psf->bytewidth = 1;
#line 399
    goto switch_break___0;
    case_7: /* CIL Label */ 
#line 402
    psf->sf.format = 524304;
#line 403
    psf->bytewidth = 1;
#line 404
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 407
    return (20);
#line 408
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }

  }

#line 413
  return (0);
}
}
#line 420 "/root/libsndfile/src/voc.c"
static int voc_write_header(SF_PRIVATE *psf , int calc_length ) 
{ 
  sf_count_t current ;
  int rate_const ;
  int subformat ;
  sf_count_t __cil_tmp6 ;
  sf_count_t __cil_tmp7 ;
  size_t __cil_tmp8 ;
  int length ;

  {
  {
#line 424
  current = psf_ftell(psf);
  }
#line 426
  if (calc_length) {
    {
#line 427
    psf->filelength = psf_get_filelen(psf);
#line 429
    psf->datalength = psf->filelength - psf->dataoffset;
    }
#line 430
    if (psf->dataend) {
#line 431
      psf->datalength -= psf->filelength - psf->dataend;
    }
#line 433
    psf->sf.frames = psf->datalength / (long )(psf->bytewidth * psf->sf.channels);
  }
  {
#line 436
  subformat = psf->sf.format & 65535;
#line 438
  psf->header[0] = (unsigned char )0;
#line 439
  psf->headindex = 0;
#line 440
  psf_fseek(psf, (sf_count_t )0, 0);
#line 443
  __cil_tmp8 = make_size_t(19);
#line 443
  psf_binheader_writef(psf, "eb1", "Creative Voice File", __cil_tmp8, 26);
#line 446
  psf_binheader_writef(psf, "e222", 26, 276, 4383);
  }
#line 454
  if (subformat == 5) {
#line 454
    if (psf->sf.channels == 1) {
      {
#line 456
      rate_const = 256 - 1000000 / psf->sf.samplerate;
#line 459
      psf_binheader_writef(psf, "e1311", 1, (int )(psf->datalength + 1L), rate_const,
                           0);
      }
    } else {
#line 454
      goto _L___23;
    }
  } else
  _L___23: /* CIL Label */ 
#line 461
  if (subformat == 5) {
#line 461
    if (psf->sf.channels == 2) {
      {
#line 463
      rate_const = 65536 - 128000000 / psf->sf.samplerate;
#line 468
      psf_binheader_writef(psf, "e13211", 8, 4, rate_const, 0, 1);
#line 471
      rate_const = 256 - 1000000 / psf->sf.samplerate;
#line 476
      psf_binheader_writef(psf, "e1311", 1, (int )(psf->datalength + 1L), rate_const,
                           0);
      }
    } else {
#line 461
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 481
    if (psf->sf.channels < 1) {
#line 482
      return (33);
    } else
#line 481
    if (psf->sf.channels > 2) {
#line 482
      return (33);
    }
    {
#line 485
    if (subformat == 5) {
#line 485
      goto case_5;
    }
#line 492
    if (subformat == 2) {
#line 492
      goto case_2;
    }
#line 499
    if (subformat == 17) {
#line 499
      goto case_17;
    }
#line 505
    if (subformat == 16) {
#line 505
      goto case_16;
    }
#line 511
    goto switch_default;
    case_5: /* CIL Label */ 
#line 486
    psf->bytewidth = 1;
    {
#line 487
    length = (int )((psf->sf.frames * (long )psf->sf.channels) * (long )psf->bytewidth + 12L);
#line 489
    psf_binheader_writef(psf, "e1341124\230", 9, length, psf->sf.samplerate, 16, psf->sf.channels,
                         4, 0);
    }
#line 490
    goto switch_break;
    case_2: /* CIL Label */ 
#line 493
    psf->bytewidth = 2;
    {
#line 494
    length = (int )((psf->sf.frames * (long )psf->sf.channels) * (long )psf->bytewidth + 12L);
#line 496
    psf_binheader_writef(psf, "e1341124\230", 9, length, psf->sf.samplerate, 16, psf->sf.channels,
                         4, 0);
    }
#line 497
    goto switch_break;
    case_17: /* CIL Label */ 
#line 500
    psf->bytewidth = 1;
    {
#line 501
    length = (int )((psf->sf.frames * (long )psf->sf.channels) * (long )psf->bytewidth + 12L);
#line 502
    psf_binheader_writef(psf, "e1341124\230", 9, length, psf->sf.samplerate, 8, psf->sf.channels,
                         6, 0);
    }
#line 503
    goto switch_break;
    case_16: /* CIL Label */ 
#line 506
    psf->bytewidth = 1;
    {
#line 507
    length = (int )((psf->sf.frames * (long )psf->sf.channels) * (long )psf->bytewidth + 12L);
#line 508
    psf_binheader_writef(psf, "e1341124\230", 9, length, psf->sf.samplerate, 8, psf->sf.channels,
                         7, 0);
    }
#line 509
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 511
    return (17);
    switch_break: /* CIL Label */ ;
    }

  }
  {
#line 515
  psf_fwrite((unsigned char *)psf->header, (sf_count_t )psf->headindex, (sf_count_t )1,
             psf);
  }
#line 517
  if (psf->error) {
#line 518
    return (psf->error);
  }
#line 520
  psf->dataoffset = (sf_count_t )psf->headindex;
#line 522
  if (current > 0L) {
    {
#line 523
    psf_fseek(psf, current, 0);
    }
  }
#line 525
  return (psf->error);
}
}
#line 529 "/root/libsndfile/src/voc.c"
static int voc_close(SF_PRIVATE *psf ) 
{ 
  unsigned int byte ;

  {
#line 531
  if (psf->mode == 32) {
    {
#line 535
    byte = (unsigned int )0;
    {
#line 538
    psf_fseek(psf, (sf_count_t )0, 2);
    }
    {
#line 541
    psf_fwrite(& byte, (sf_count_t )1, (sf_count_t )1, psf);
    }
    {
#line 543
    voc_write_header(psf, 1);
    }
    }
  } else
#line 531
  if (psf->mode == 48) {
    {
#line 535
    byte = (unsigned int )0;
    {
#line 538
    psf_fseek(psf, (sf_count_t )0, 2);
    }
    {
#line 541
    psf_fwrite(& byte, (sf_count_t )1, (sf_count_t )1, psf);
    }
    {
#line 543
    voc_write_header(psf, 1);
    }
    }
  }

#line 546
  return (0);
}
}
#line 550 "/root/libsndfile/src/voc.c"
static char const   *voc_encoding2str(int encoding ) 
{ 


  {
  {
#line 553
  if (encoding == 0) {
#line 553
    goto case_0;
  }
#line 554
  if (encoding == 4) {
#line 554
    goto case_4;
  }
#line 555
  if (encoding == 6) {
#line 555
    goto case_6;
  }
#line 556
  if (encoding == 7) {
#line 556
    goto case_7;
  }
#line 557
  goto switch_default;
  case_0: /* CIL Label */ 
#line 553
  return ("8 bit unsigned PCMh\373\036V");
  case_4: /* CIL Label */ 
#line 554
  return ("16 bit signed PCMMh\373\036V");
  case_6: /* CIL Label */ 
#line 555
  return ("A-lawV");
  case_7: /* CIL Label */ 
#line 556
  return ("u-lawV");
  switch_default: /* CIL Label */ 
#line 557
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 559
  return ("*** Unknown ***");
}
}
#line 40 "/root/libsndfile/src/txw.c"
int txw_open(SF_PRIVATE *psf ) 
{ 


  {
#line 41
  if (psf) {
#line 42
    return (17);
  }
#line 43
  return (0);
}
}
#line 73 "/root/libsndfile/src/svx.c"
static int svx_close(SF_PRIVATE *psf ) ;
#line 74
static int svx_write_header(SF_PRIVATE *psf , int calc_length ) ;
#line 75
static int svx_read_header(SF_PRIVATE *psf ) ;
#line 82 "/root/libsndfile/src/svx.c"
int svx_open(SF_PRIVATE *psf ) 
{ 
  int error ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
#line 85
  if (psf->mode == 16) {
    _L: /* CIL Label */ 
    {
#line 86
    error = svx_read_header(psf);
    }
#line 86
    if (error) {
#line 87
      return (error);
    }
#line 89
    psf->endian = 536870912;
#line 91
    psf->blockwidth = psf->sf.channels * psf->bytewidth;
#line 92
    if (psf->blockwidth) {
#line 93
      psf->sf.frames = psf->datalength / (long )psf->blockwidth;
    }
    {
#line 95
    psf_fseek(psf, psf->dataoffset, 0);
    }
  } else
#line 85
  if (psf->mode == 48) {
#line 85
    if (psf->filelength > 0L) {
#line 85
      goto _L;
    }
  }

#line 98
  if (psf->mode == 32) {
    _L___24: /* CIL Label */ 
#line 99
    if (psf->is_pipe) {
#line 100
      return (28);
    }
#line 102
    if ((psf->sf.format & 268369920) != 393216) {
#line 103
      return (1);
    }
#line 105
    psf->endian = psf->sf.format & 805306368;
#line 107
    if (psf->endian == 268435456) {
#line 108
      return (31);
    } else
#line 107
    if (psf->endian == 805306368) {
#line 108
      return (31);
    }
    {
#line 110
    psf->endian = 536870912;
#line 112
    error = svx_write_header(psf, 0);
    }
#line 113
    if (error) {
#line 114
      return (error);
    }
#line 116
    psf->write_header = & svx_write_header;
  } else
#line 98
  if (psf->mode == 48) {
#line 98
    goto _L___24;
  }
  {
#line 119
  psf->container_close = & svx_close;
#line 121
  error = pcm_init(psf);
  }
#line 121
  if (error) {
#line 122
    return (error);
  }
#line 124
  return (0);
}
}
#line 131 "/root/libsndfile/src/svx.c"
static int svx_read_header(SF_PRIVATE *psf ) 
{ 
  VHDR_CHUNK vhdr ;
  unsigned int FORMsize ;
  unsigned int vhdrsize ;
  unsigned int dword ;
  unsigned int marker ;
  int filetype ;
  int parsestage ;
  int done ;
  int bytecount ;
  int channels ;
  sf_count_t __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  int __cil_tmp14 ;
  unsigned short const   **__cil_tmp15 ;
  unsigned short const   **__cil_tmp16 ;
  unsigned short const   **__cil_tmp17 ;
  unsigned short const   **__cil_tmp18 ;
  sf_count_t __cil_tmp19 ;
  sf_count_t __cil_tmp20 ;

  {
#line 134
  filetype = 0;
#line 134
  parsestage = 0;
#line 134
  done = 0;
#line 135
  bytecount = 0;
#line 137
  if (psf->filelength > 4294967295L) {
    {
#line 138
    psf_log_printf(psf, "Warning : filelength > 0xffffffff. This is bad!!!!\n");
    }
  }
  {
#line 140
  memset(& vhdr, 0, sizeof(vhdr));
#line 141
  psf_binheader_readf(psf, "p", 0);
#line 144
  psf->sf.channels = 1;
#line 146
  psf->sf.format = 393216;
  }
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
#line 148
    if (! (! done)) {
#line 148
      goto while_break;
    }
    {
#line 149
    psf_binheader_readf(psf, "m", & marker);
    }
    {
#line 151
    if (marker == (unsigned int )(((70 | (79 << 8)) | (82 << 16)) | (77 << 24))) {
#line 151
      goto case_exp;
    }
#line 168
    if (marker == (unsigned int )(((49 | (54 << 8)) | (83 << 16)) | (86 << 24))) {
#line 168
      goto case_exp___0;
    }
#line 168
    if (marker == (unsigned int )(((56 | (83 << 8)) | (86 << 16)) | (88 << 24))) {
#line 168
      goto case_exp___0;
    }
#line 176
    if (marker == (unsigned int )(((86 | (72 << 8)) | (68 << 16)) | (82 << 24))) {
#line 176
      goto case_exp___2;
    }
#line 197
    if (marker == 0) {
#line 197
      goto case_0;
    }
#line 199
    if (marker == 1) {
#line 199
      goto case_1;
    }
#line 201
    if (marker == 2) {
#line 201
      goto case_2;
    }
#line 221
    if (marker == (unsigned int )(((66 | (79 << 8)) | (68 << 16)) | (89 << 24))) {
#line 221
      goto case_exp___3;
    }
#line 247
    if (marker == (unsigned int )(((78 | (65 << 8)) | (77 << 16)) | (69 << 24))) {
#line 247
      goto case_exp___4;
    }
#line 266
    if (marker == (unsigned int )(((65 | (78 << 8)) | (78 << 16)) | (79 << 24))) {
#line 266
      goto case_exp___5;
    }
#line 277
    if (marker == (unsigned int )(((67 | (72 << 8)) | (65 << 16)) | (78 << 24))) {
#line 277
      goto case_exp___6;
    }
#line 295
    if (marker == (unsigned int )(((40 | (99 << 8)) | (41 << 16)) | (32 << 24))) {
#line 295
      goto case_exp___7;
    }
#line 295
    if (marker == (unsigned int )(((65 | (85 << 8)) | (84 << 16)) | (72 << 24))) {
#line 295
      goto case_exp___7;
    }
#line 306
    goto switch_default;
    case_exp: /* CIL Label */ 
#line 152
    if (parsestage) {
#line 153
      return (96);
    }
    {
#line 155
    psf_binheader_readf(psf, "E4", & FORMsize);
    }
#line 157
    if ((unsigned long )FORMsize != (unsigned long )psf->filelength - 2UL * sizeof(dword)) {
      {
#line 158
      dword = (unsigned int )((unsigned long )psf->filelength - 2UL * sizeof(dword));
#line 159
      psf_log_printf(psf, "FORM : %d (should be %d)\n", FORMsize, dword);
#line 160
      FORMsize = dword;
      }
    } else {
      {
#line 163
      psf_log_printf(psf, "FORM : %d\n", FORMsize);
      }
    }
#line 164
    parsestage |= 1;
#line 165
    goto switch_break;
    case_exp___0: /* CIL Label */ 
    case_exp___1: /* CIL Label */ 
#line 169
    if (! (parsestage & 1)) {
#line 170
      return (96);
    }
    {
#line 171
    filetype = (int )marker;
#line 172
    psf_log_printf(psf, " %M\n\036V", marker);
#line 173
    parsestage |= 2;
    }
#line 174
    goto switch_break;
    case_exp___2: /* CIL Label */ 
#line 177
    if (! (parsestage & 3)) {
#line 178
      return (96);
    }
    {
#line 180
    psf_binheader_readf(psf, "E4", & vhdrsize);
#line 182
    psf_log_printf(psf, " VHDR : %d\n", vhdrsize);
#line 184
    psf_binheader_readf(psf, "E4442114\230\001", & vhdr.oneShotHiSamples, & vhdr.repeatHiSamples,
                        & vhdr.samplesPerHiCycle, & vhdr.samplesPerSec, & vhdr.octave,
                        & vhdr.compression, & vhdr.volume);
#line 188
    psf_log_printf(psf, "  OneShotHiSamples  : %d\n", vhdr.oneShotHiSamples);
#line 189
    psf_log_printf(psf, "  RepeatHiSamples   : %d\n", vhdr.repeatHiSamples);
#line 190
    psf_log_printf(psf, "  samplesPerHiCycle : %d\n", vhdr.samplesPerHiCycle);
#line 191
    psf_log_printf(psf, "  Sample Rate       : %d\n", (int )vhdr.samplesPerSec);
#line 192
    psf_log_printf(psf, "  Octave            : %d\n", (int )vhdr.octave);
#line 194
    psf_log_printf(psf, "  Compression       : %d => ", (int )vhdr.compression);
    }
    {
#line 197
    if ((int )vhdr.compression == 0) {
#line 197
      goto case_0;
    }
#line 199
    if ((int )vhdr.compression == 1) {
#line 199
      goto case_1;
    }
#line 201
    if ((int )vhdr.compression == 2) {
#line 201
      goto case_2;
    }
#line 196
    goto switch_break___0;
    case_0: /* CIL Label */ 
    {
#line 197
    psf_log_printf(psf, "None.\n");
    }
#line 198
    goto switch_break___0;
    case_1: /* CIL Label */ 
    {
#line 199
    psf_log_printf(psf, "Fibonacci delta\n\220");
    }
#line 200
    goto switch_break___0;
    case_2: /* CIL Label */ 
    {
#line 201
    psf_log_printf(psf, "Exponential delta\n");
    }
#line 202
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 205
    psf_log_printf(psf, "  Volume            : %d\n", vhdr.volume);
#line 207
    psf->sf.samplerate = (int )vhdr.samplesPerSec;
    }
#line 209
    if (filetype == (((56 | (83 << 8)) | (86 << 16)) | (88 << 24))) {
#line 210
      psf->sf.format |= 1;
#line 211
      psf->bytewidth = 1;
    } else
#line 213
    if (filetype == (((49 | (54 << 8)) | (83 << 16)) | (86 << 24))) {
#line 214
      psf->sf.format |= 2;
#line 215
      psf->bytewidth = 2;
    }
#line 218
    parsestage |= 4;
#line 219
    goto switch_break;
    case_exp___3: /* CIL Label */ 
#line 222
    if (! (parsestage & 4)) {
#line 223
      return (97);
    }
    {
#line 225
    psf_binheader_readf(psf, "E4", & dword);
#line 226
    psf->datalength = (sf_count_t )dword;
#line 228
    psf->dataoffset = psf_ftell(psf);
    }
#line 229
    if (psf->dataoffset < 0L) {
#line 230
      return (97);
    }
#line 232
    if (psf->datalength > psf->filelength - psf->dataoffset) {
      {
#line 233
      psf_log_printf(psf, " BODY : %D (should be %D)\n", psf->datalength, psf->filelength - psf->dataoffset);
#line 234
      psf->datalength = psf->filelength - psf->dataoffset;
      }
    } else {
      {
#line 237
      psf_log_printf(psf, " BODY : %D\n", psf->datalength);
      }
    }
#line 239
    parsestage |= 8;
#line 241
    if (! psf->sf.seekable) {
#line 242
      goto switch_break;
    }
    {
#line 244
    psf_fseek(psf, psf->datalength, 1);
    }
#line 245
    goto switch_break;
    case_exp___4: /* CIL Label */ 
#line 248
    if (! (parsestage & 2)) {
#line 249
      return (96);
    }
    {
#line 251
    psf_binheader_readf(psf, "E4", & dword);
#line 253
    psf_log_printf(psf, " %M : %d\n", marker, dword);
#line 255
    __cil_tmp13 = strlen((char const   *)((char *)psf->filename));
    }
#line 255
    if (__cil_tmp13 != (unsigned long )dword) {
#line 256
      if ((unsigned long )dword > sizeof(psf->filename) - 1UL) {
#line 257
        return (100);
      }
      {
#line 259
      psf_binheader_readf(psf, "b", (char *)psf->filename, dword);
#line 260
      psf->filename[dword] = (char )0;
      }
    } else {
      {
#line 263
      psf_binheader_readf(psf, "j", dword);
      }
    }
#line 264
    goto switch_break;
    case_exp___5: /* CIL Label */ 
#line 267
    if (! (parsestage & 2)) {
#line 268
      return (96);
    }
    {
#line 270
    psf_binheader_readf(psf, "E4", & dword);
#line 272
    psf_log_printf(psf, " %M : %d\n", marker, dword);
#line 274
    psf_binheader_readf(psf, "j", dword);
    }
#line 275
    goto switch_break;
    case_exp___6: /* CIL Label */ 
#line 278
    if (! (parsestage & 2)) {
#line 279
      return (96);
    }
    {
#line 281
    psf_binheader_readf(psf, "E4", & dword);
#line 283
    psf_log_printf(psf, " %M : %d\n", marker, dword);
#line 285
    __cil_tmp14 = psf_binheader_readf(psf, "E4", & channels);
    }
    {
#line 285
    bytecount += __cil_tmp14;
#line 286
    psf->sf.channels = channels;
#line 288
    psf_log_printf(psf, "  Channels : %d\n\230\001", channels);
#line 290
    psf_binheader_readf(psf, "j", dword - (unsigned int )bytecount);
    }
#line 291
    goto switch_break;
    case_exp___7: /* CIL Label */ 
    case_exp___8: /* CIL Label */ 
#line 296
    if (! (parsestage & 2)) {
#line 297
      return (96);
    }
    {
#line 299
    psf_binheader_readf(psf, "E4", & dword);
#line 301
    psf_log_printf(psf, " %M : %d\n", marker, dword);
#line 303
    psf_binheader_readf(psf, "j", dword);
    }
#line 304
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 307
    __cil_tmp18 = __ctype_b_loc();
    }
    {
#line 307
    __cil_tmp17 = __ctype_b_loc();
    }
    {
#line 307
    __cil_tmp16 = __ctype_b_loc();
    }
    {
#line 307
    __cil_tmp15 = __ctype_b_loc();
    }
#line 307
    if ((int )*(*__cil_tmp15 + (int )((marker >> 24) & 255U)) & 16384) {
#line 307
      if ((int )*(*__cil_tmp16 + (int )((marker >> 16) & 255U)) & 16384) {
#line 307
        if ((int )*(*__cil_tmp17 + (int )((marker >> 8) & 255U)) & 16384) {
#line 307
          if ((int )*(*__cil_tmp18 + (int )(marker & 255U)) & 16384) {
            {
#line 309
            psf_binheader_readf(psf, "E4", & dword);
#line 311
            psf_log_printf(psf, "%M : %d (unknown marker)\n", marker, dword);
#line 313
            psf_binheader_readf(psf, "j", dword);
            }
#line 314
            goto switch_break;
          }
        }
      }
    }
    {
#line 316
    __cil_tmp19 = psf_ftell(psf);
#line 316
    dword = (unsigned int )__cil_tmp19;
    }
#line 316
    if (dword & 3U) {
      {
#line 317
      psf_log_printf(psf, "  Unknown chunk marker at position %d. Resynching.\n",
                     dword - 4U);
#line 319
      psf_binheader_readf(psf, "j", - 3);
      }
#line 320
      goto switch_break;
    }
    {
#line 322
    psf_log_printf(psf, "*** Unknown chunk marker : %X. Exiting parser.\n", marker);
#line 323
    done = 1;
    }
    switch_break: /* CIL Label */ ;
    }

#line 326
    if (! psf->sf.seekable) {
#line 326
      if (parsestage & 8) {
#line 327
        goto while_break;
      }
    }
    {
#line 329
    __cil_tmp20 = psf_ftell(psf);
    }
#line 329
    if (__cil_tmp20 >= psf->filelength - (long )((int )sizeof(dword))) {
#line 330
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 333
  if (vhdr.compression) {
#line 334
    return (99);
  }
#line 336
  if (psf->dataoffset <= 0L) {
#line 337
    return (98);
  }
#line 339
  return (0);
}
}
#line 343 "/root/libsndfile/src/svx.c"
static int svx_close(SF_PRIVATE *psf ) 
{ 


  {
#line 345
  if (psf->mode == 32) {
    {
    {
#line 346
    svx_write_header(psf, 1);
    }
    }
  } else
#line 345
  if (psf->mode == 48) {
    {
    {
#line 346
    svx_write_header(psf, 1);
    }
    }
  }
#line 348
  return (0);
}
}
#line 352 "/root/libsndfile/src/svx.c"
static int svx_write_header(SF_PRIVATE *psf , int calc_length ) 
{ 
  static char annotation[37] ;
  sf_count_t current ;
  sf_count_t __cil_tmp5 ;
  sf_count_t __cil_tmp6 ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
#line 353
  annotation = "libsndfile by Erik de Castro Lopo";
#line 356
  current = psf_ftell(psf);
  }
#line 358
  if (calc_length) {
    {
#line 359
    psf->filelength = psf_get_filelen(psf);
#line 361
    psf->datalength = psf->filelength - psf->dataoffset;
    }
#line 363
    if (psf->dataend) {
#line 364
      psf->datalength -= psf->filelength - psf->dataend;
    }
#line 366
    psf->sf.frames = psf->datalength / (long )(psf->bytewidth * psf->sf.channels);
  }
  {
#line 369
  psf->header[0] = (unsigned char )0;
#line 370
  psf->headindex = 0;
#line 371
  psf_fseek(psf, (sf_count_t )0, 0);
  }
#line 374
  if (psf->filelength < 8L) {
#line 374
    tmp = 0L;
  } else {
#line 374
    tmp = psf->filelength - 8L;
  }
  {
#line 374
  psf_binheader_writef(psf, "Etm8", ((70 | (79 << 8)) | (82 << 16)) | (77 << 24),
                       tmp);
  }
#line 377
  if (psf->bytewidth == 1) {
#line 377
    tmp___0 = ((56 | (83 << 8)) | (86 << 16)) | (88 << 24);
  } else {
#line 377
    tmp___0 = ((49 | (54 << 8)) | (83 << 16)) | (86 << 24);
  }
  {
#line 377
  psf_binheader_writef(psf, "m", tmp___0);
#line 380
  psf_binheader_writef(psf, "Em4", ((86 | (72 << 8)) | (68 << 16)) | (82 << 24), sizeof(VHDR_CHUNK ));
#line 382
  psf_binheader_writef(psf, "E444", psf->sf.frames, 0, 0);
#line 384
  psf_binheader_writef(psf, "E211", psf->sf.samplerate, 1, 0);
  }
#line 386
  if (psf->bytewidth == 1) {
#line 386
    tmp___1 = 255;
  } else {
#line 386
    tmp___1 = 65535;
  }
  {
#line 386
  psf_binheader_writef(psf, "E4", tmp___1);
#line 389
  psf_binheader_writef(psf, "EmsmsV", ((78 | (65 << 8)) | (77 << 16)) | (69 << 24),
                       (char *)psf->filename, ((65 | (78 << 8)) | (78 << 16)) | (79 << 24),
                       (char *)annotation);
  }
#line 392
  if (psf->datalength < 0L) {
#line 392
    tmp___2 = 0L;
  } else {
#line 392
    tmp___2 = psf->datalength;
  }
  {
#line 392
  psf_binheader_writef(psf, "Etm8\036V", ((66 | (79 << 8)) | (68 << 16)) | (89 << 24),
                       tmp___2);
#line 395
  psf_fwrite((unsigned char *)psf->header, (sf_count_t )psf->headindex, (sf_count_t )1,
             psf);
  }
#line 397
  if (psf->error) {
#line 398
    return (psf->error);
  }
#line 400
  psf->dataoffset = (sf_count_t )psf->headindex;
#line 402
  if (current > 0L) {
    {
#line 403
    psf_fseek(psf, current, 0);
    }
  }
#line 405
  return (psf->error);
}
}
#line 67 "/root/libsndfile/src/sds.c"
static int sds_close(SF_PRIVATE *psf ) ;
#line 69
static int sds_write_header(SF_PRIVATE *psf , int calc_length ) ;
#line 70
static int sds_read_header(SF_PRIVATE *psf , SDS_PRIVATE *psds ) ;
#line 72
static int sds_init(SF_PRIVATE *psf , SDS_PRIVATE *psds ) ;
#line 74
static sf_count_t sds_read_s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 75
static sf_count_t sds_read_i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 76
static sf_count_t sds_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 77
static sf_count_t sds_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 79
static sf_count_t sds_write_s(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 80
static sf_count_t sds_write_i(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 81
static sf_count_t sds_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 82
static sf_count_t sds_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 84
static sf_count_t sds_seek(SF_PRIVATE *psf , int mode , sf_count_t seek_from_start ) ;
#line 86
static int sds_2byte_read(SF_PRIVATE *psf , SDS_PRIVATE *psds ) ;
#line 87
static int sds_3byte_read(SF_PRIVATE *psf , SDS_PRIVATE *psds ) ;
#line 88
static int sds_4byte_read(SF_PRIVATE *psf , SDS_PRIVATE *psds ) ;
#line 90
static int sds_read(SF_PRIVATE *psf , SDS_PRIVATE *psds , int *ptr , int len ) ;
#line 92
static int sds_2byte_write(SF_PRIVATE *psf , SDS_PRIVATE *psds ) ;
#line 93
static int sds_3byte_write(SF_PRIVATE *psf , SDS_PRIVATE *psds ) ;
#line 94
static int sds_4byte_write(SF_PRIVATE *psf , SDS_PRIVATE *psds ) ;
#line 96
static int sds_write(SF_PRIVATE *psf , SDS_PRIVATE *psds , int const   *ptr , int len ) ;
#line 103 "/root/libsndfile/src/sds.c"
int sds_open(SF_PRIVATE *psf ) 
{ 
  SDS_PRIVATE *psds ;
  int error ;
  void *__cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 105
  error = 0;
#line 108
  psf->sf.frames = (sf_count_t )0;
#line 110
  psds = (SDS_PRIVATE *)calloc((unsigned long )1, sizeof(SDS_PRIVATE ));
  }
#line 110
  if (! psds) {
#line 111
    return (16);
  }
#line 112
  psf->codec_data = psds;
#line 114
  if (psf->mode == 16) {
    _L: /* CIL Label */ 
    {
#line 115
    error = sds_read_header(psf, psds);
    }
#line 115
    if (error) {
#line 116
      return (error);
    }
  } else
#line 114
  if (psf->mode == 48) {
#line 114
    if (psf->filelength > 0L) {
#line 114
      goto _L;
    }
  }

#line 119
  if ((psf->sf.format & 268369920) != 1114112) {
#line 120
    return (1);
  }
#line 122
  if (psf->mode == 32) {
    _L___25: /* CIL Label */ 
    {
#line 123
    __cil_tmp6 = sds_write_header(psf, 0);
    }
#line 123
    if (__cil_tmp6) {
#line 124
      return (psf->error);
    }
    {
#line 126
    psf->write_header = & sds_write_header;
#line 128
    psf_fseek(psf, (sf_count_t )21, 0);
    }
  } else
#line 122
  if (psf->mode == 48) {
#line 122
    goto _L___25;
  }
  {
#line 131
  error = sds_init(psf, psds);
  }
#line 131
  if (error != 0) {
#line 132
    return (error);
  }
#line 134
  psf->seek = & sds_seek;
#line 135
  psf->container_close = & sds_close;
#line 137
  psf->blockwidth = 0;
#line 139
  return (error);
}
}
#line 146 "/root/libsndfile/src/sds.c"
static int sds_close(SF_PRIVATE *psf ) 
{ 
  SDS_PRIVATE *psds ;

  {
#line 148
  if (psf->mode == 32) {
    _L: /* CIL Label */ 
#line 151
    psds = (SDS_PRIVATE *)psf->codec_data;
#line 151
    if (psds == (void *)0) {
      {
#line 152
      psf_log_printf(psf, "*** Bad psf->codec_data ptr.\n");
      }
#line 153
      return (29);
    }

#line 156
    if (psds->write_count > 0) {
      {
#line 157
      memset(& psds->write_data[psds->write_count], 0, (unsigned long )(psds->samplesperblock - psds->write_count) * sizeof(int ));
#line 158
      (*(psds->writer))(psf, psds);
      }
    }
    {
#line 161
    sds_write_header(psf, 1);
    }
  } else
#line 148
  if (psf->mode == 48) {
#line 148
    goto _L;
  }

#line 164
  return (0);
}
}
#line 168 "/root/libsndfile/src/sds.c"
static int sds_init(SF_PRIVATE *psf , SDS_PRIVATE *psds ) 
{ 


  {
#line 170
  if (psds->bitwidth < 8) {
#line 171
    psf->error = 139;
#line 171
    return (psf->error);
  } else
#line 170
  if (psds->bitwidth > 28) {
#line 171
    psf->error = 139;
#line 171
    return (psf->error);
  }
#line 173
  if (psds->bitwidth < 14) {
#line 174
    psds->reader = & sds_2byte_read;
#line 175
    psds->writer = & sds_2byte_write;
#line 176
    psds->samplesperblock = 60;
  } else
#line 178
  if (psds->bitwidth < 21) {
#line 179
    psds->reader = & sds_3byte_read;
#line 180
    psds->writer = & sds_3byte_write;
#line 181
    psds->samplesperblock = 40;
  } else {
#line 184
    psds->reader = & sds_4byte_read;
#line 185
    psds->writer = & sds_4byte_write;
#line 186
    psds->samplesperblock = 30;
  }

#line 189
  if (psf->mode == 16) {
    {
#line 190
    psf->read_short = & sds_read_s;
#line 191
    psf->read_int = & sds_read_i;
#line 192
    psf->read_float = & sds_read_f;
#line 193
    psf->read_double = & sds_read_d;
    {
#line 196
    (*(psds->reader))(psf, psds);
    }
    }
  } else
#line 189
  if (psf->mode == 48) {
    {
#line 190
    psf->read_short = & sds_read_s;
#line 191
    psf->read_int = & sds_read_i;
#line 192
    psf->read_float = & sds_read_f;
#line 193
    psf->read_double = & sds_read_d;
    {
#line 196
    (*(psds->reader))(psf, psds);
    }
    }
  }

#line 199
  if (psf->mode == 32) {
#line 200
    psf->write_short = & sds_write_s;
#line 201
    psf->write_int = & sds_write_i;
#line 202
    psf->write_float = & sds_write_f;
#line 203
    psf->write_double = & sds_write_d;
  } else
#line 199
  if (psf->mode == 48) {
#line 200
    psf->write_short = & sds_write_s;
#line 201
    psf->write_int = & sds_write_i;
#line 202
    psf->write_float = & sds_write_f;
#line 203
    psf->write_double = & sds_write_d;
  }

#line 206
  return (0);
}
}
#line 210 "/root/libsndfile/src/sds.c"
static int sds_read_header(SF_PRIVATE *psf , SDS_PRIVATE *psds ) 
{ 
  unsigned char channel ;
  unsigned char bitwidth ;
  unsigned char loop_type ;
  unsigned char byte ;
  unsigned short sample_no ;
  unsigned short marker ;
  unsigned int samp_period ;
  unsigned int data_length ;
  unsigned int sustain_loop_start ;
  unsigned int sustain_loop_end ;
  int bytesread ;
  int blockcount ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  sf_count_t __cil_tmp19 ;
  int __cil_tmp20 ;

  {
  {
#line 217
  bytesread = psf_binheader_readf(psf, "pE211V", 0, & marker, & channel, & byte);
  }
#line 219
  if ((int )marker != 61566) {
#line 220
    return (138);
  } else
#line 219
  if ((int )byte != 1) {
#line 220
    return (138);
  }
  {
#line 222
  psf_log_printf(psf, "Midi Sample Dump Standard (.sds)\nF07E\n Midi Channel  : %d\n",
                 (int )channel);
#line 224
  __cil_tmp16 = psf_binheader_readf(psf, "e213", & sample_no, & bitwidth, & samp_period);
  }
  {
#line 224
  bytesread += __cil_tmp16;
#line 226
  sample_no = (unsigned short )((((int )sample_no & 127) | (((int )sample_no & 32512) >> 1)) | (((int )sample_no & 8323072) >> 2));
#line 227
  samp_period = ((samp_period & 127U) | ((samp_period & 32512U) >> 1)) | ((samp_period & 8323072U) >> 2);
#line 229
  psds->bitwidth = (int )bitwidth;
#line 231
  psf->sf.samplerate = (int )(1000000000U / samp_period);
#line 233
  psf_log_printf(psf, " Sample Number : %d\n Bit Width     : %d\n Sample Rate   : %d\n",
                 (int )sample_no, psds->bitwidth, psf->sf.samplerate);
#line 238
  __cil_tmp17 = psf_binheader_readf(psf, "e3331V", & data_length, & sustain_loop_start,
                                    & sustain_loop_end, & loop_type);
  }
  {
#line 238
  bytesread += __cil_tmp17;
#line 240
  data_length = ((data_length & 127U) | ((data_length & 32512U) >> 1)) | ((data_length & 8323072U) >> 2);
#line 242
  sustain_loop_start = ((sustain_loop_start & 127U) | ((sustain_loop_start & 32512U) >> 1)) | ((sustain_loop_start & 8323072U) >> 2);
#line 243
  sustain_loop_end = ((sustain_loop_end & 127U) | ((sustain_loop_end & 32512U) >> 1)) | ((sustain_loop_end & 8323072U) >> 2);
#line 245
  psf_log_printf(psf, " Sustain Loop\n     Start     : %d\n     End       : %d\n     Loop Type : %d\n",
                 sustain_loop_start, sustain_loop_end, (int )loop_type);
#line 251
  psf->dataoffset = (sf_count_t )21;
#line 252
  psf->datalength = psf->filelength - psf->dataoffset;
  }
#line 254
  if ((long )data_length != psf->filelength - psf->dataoffset) {
    {
#line 255
    psf_log_printf(psf, " Datalength     : %d (truncated data??? %d)\n", data_length,
                   psf->filelength - psf->dataoffset);
#line 256
    data_length = (unsigned int )(psf->filelength - psf->dataoffset);
    }
  } else {
    {
#line 259
    psf_log_printf(psf, " Datalength     : %d\n", data_length);
    }
  }
  {
#line 261
  __cil_tmp18 = psf_binheader_readf(psf, "1", & byte);
  }
#line 261
  bytesread += __cil_tmp18;
#line 262
  if ((int )byte != 247) {
    {
#line 263
    psf_log_printf(psf, "bad end : %X\n", (int )byte & 255);
    }
  }
#line 265
  blockcount = 0;
  {
#line 265
  while (1) {
    while_continue: /* CIL Label */ ;
#line 265
    if (! ((long )bytesread < psf->filelength)) {
#line 265
      goto while_break;
    }
    {
#line 267
    __cil_tmp19 = psf_fread(& marker, (sf_count_t )1, (sf_count_t )2, psf);
    }
#line 267
    bytesread += __cil_tmp19;
#line 269
    if ((int )marker == 0) {
#line 270
      goto while_break;
    }
    {
#line 272
    psf_fseek(psf, (sf_count_t )125, 1);
#line 273
    bytesread += 125;
    }
#line 265
    blockcount ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 276
  psf_log_printf(psf, "\nBlocks         : %d\n", blockcount);
#line 277
  psds->total_blocks = blockcount;
#line 279
  psds->samplesperblock = 120 / ((psds->bitwidth + 6) / 7);
#line 280
  psf_log_printf(psf, "Samples/Block  : %d\n", psds->samplesperblock);
#line 282
  psf_log_printf(psf, "Frames         : %d\n", blockcount * psds->samplesperblock);
#line 284
  psf->sf.frames = (sf_count_t )(blockcount * psds->samplesperblock);
#line 285
  psds->frames = blockcount * psds->samplesperblock;
#line 288
  psf->sf.channels = 1;
#line 289
  psf->sf.sections = 1;
  }
  {
#line 296
  if ((psds->bitwidth + 7) / 8 == 1) {
#line 296
    goto case_1;
  }
#line 300
  if ((psds->bitwidth + 7) / 8 == 2) {
#line 300
    goto case_2;
  }
#line 304
  if ((psds->bitwidth + 7) / 8 == 3) {
#line 304
    goto case_3;
  }
#line 308
  if ((psds->bitwidth + 7) / 8 == 4) {
#line 308
    goto case_4;
  }
#line 312
  goto switch_default;
  case_1: /* CIL Label */ 
#line 297
  psf->sf.format = 1114113;
#line 298
  goto switch_break;
  case_2: /* CIL Label */ 
#line 301
  psf->sf.format = 1114114;
#line 302
  goto switch_break;
  case_3: /* CIL Label */ 
#line 305
  psf->sf.format = 1114115;
#line 306
  goto switch_break;
  case_4: /* CIL Label */ 
#line 309
  psf->sf.format = 1114116;
#line 310
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 313
  psf_log_printf(psf, "*** Weird byte width (%d)\n", (psds->bitwidth + 7) / 8);
  }
#line 314
  return (139);
  switch_break: /* CIL Label */ ;
  }
  {
#line 317
  psf_fseek(psf, (sf_count_t )21, 0);
  }
#line 319
  return (0);
}
}
#line 323 "/root/libsndfile/src/sds.c"
static int sds_write_header(SF_PRIVATE *psf , int calc_length ) 
{ 
  SDS_PRIVATE *psds ;
  sf_count_t current ;
  int samp_period ;
  int data_length ;
  int sustain_loop_start ;
  int sustain_loop_end ;
  unsigned char loop_type ;
  sf_count_t __cil_tmp10 ;
  int current_count ;
  int current_block ;

  {
#line 327
  loop_type = (unsigned char )0;
#line 329
  psds = (SDS_PRIVATE *)psf->codec_data;
#line 329
  if (psds == (void *)0) {
    {
#line 330
    psf_log_printf(psf, "*** Bad psf->codec_data ptr.\nV");
    }
#line 331
    return (29);
  }

#line 334
  if (psf->pipeoffset > 0L) {
#line 335
    return (0);
  }
  {
#line 337
  current = psf_ftell(psf);
  }
#line 339
  if (calc_length) {
#line 340
    psf->sf.frames = (sf_count_t )(psds->total_blocks * psds->samplesperblock + psds->write_count);
  }
#line 342
  if (psds->write_count > 0) {
    {
#line 343
    current_count = psds->write_count;
#line 344
    current_block = psds->write_block;
#line 346
    (*(psds->writer))(psf, psds);
#line 348
    psf_fseek(psf, (sf_count_t )-127, 1);
#line 350
    psds->write_count = current_count;
#line 351
    psds->write_block = current_block;
    }
  }
#line 355
  psf->header[0] = (unsigned char )0;
#line 356
  psf->headindex = 0;
#line 358
  if (psf->is_pipe == 0) {
    {
#line 359
    psf_fseek(psf, (sf_count_t )0, 0);
    }
  }
  {
#line 361
  psf_binheader_writef(psf, "E211\036V", 61566, 0, 1);
  }
  {
#line 364
  if ((psf->sf.format & 65535) == 1) {
#line 364
    goto case_1;
  }
#line 367
  if ((psf->sf.format & 65535) == 2) {
#line 367
    goto case_2;
  }
#line 370
  if ((psf->sf.format & 65535) == 3) {
#line 370
    goto case_3;
  }
#line 373
  goto switch_default;
  case_1: /* CIL Label */ 
#line 365
  psds->bitwidth = 8;
#line 366
  goto switch_break;
  case_2: /* CIL Label */ 
#line 368
  psds->bitwidth = 16;
#line 369
  goto switch_break;
  case_3: /* CIL Label */ 
#line 371
  psds->bitwidth = 24;
#line 372
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 374
  return (139);
  switch_break: /* CIL Label */ ;
  }
  {
#line 377
  samp_period = ((1000000000 / psf->sf.samplerate & 127) | ((1000000000 / psf->sf.samplerate << 1) & 32512)) | ((1000000000 / psf->sf.samplerate << 2) & 8323072);
#line 379
  psf_binheader_writef(psf, "e213", 0, psds->bitwidth, samp_period);
#line 381
  data_length = ((psds->total_blocks * 127 & 127) | ((psds->total_blocks * 127 << 1) & 32512)) | ((psds->total_blocks * 127 << 2) & 8323072);
#line 382
  sustain_loop_start = 0;
#line 383
  sustain_loop_end = (int )(((psf->sf.frames & 127L) | ((psf->sf.frames << 1) & 32512L)) | ((psf->sf.frames << 2) & 8323072L));
#line 385
  psf_binheader_writef(psf, "e33311", data_length, sustain_loop_start, sustain_loop_end,
                       (int )loop_type, 247);
#line 388
  psf_fwrite((unsigned char *)psf->header, (sf_count_t )psf->headindex, (sf_count_t )1,
             psf);
  }
#line 390
  if (psf->error) {
#line 391
    return (psf->error);
  }
#line 393
  psf->dataoffset = (sf_count_t )psf->headindex;
#line 394
  psf->datalength = (sf_count_t )(psds->write_block * 127);
#line 396
  if (current > 0L) {
    {
#line 397
    psf_fseek(psf, current, 0);
    }
  }
#line 399
  return (psf->error);
}
}
#line 407 "/root/libsndfile/src/sds.c"
static int sds_2byte_read(SF_PRIVATE *psf , SDS_PRIVATE *psds ) 
{ 
  unsigned char *ucptr ;
  unsigned char checksum ;
  unsigned int sample ;
  int k ;
  int __cil_tmp7 ;
  sf_count_t __cil_tmp8 ;
  int __cil_tmp9 ;

  {
#line 412
  (psds->read_block) ++;
#line 413
  psds->read_count = 0;
#line 415
  if (psds->read_block * psds->samplesperblock > psds->frames) {
    {
#line 416
    memset((int *)psds->read_samples, 0, (unsigned long )psds->samplesperblock * sizeof(int ));
    }
#line 417
    return (1);
  }
  {
#line 420
  __cil_tmp8 = psf_fread((unsigned char *)psds->read_data, (sf_count_t )1, (sf_count_t )127,
                         psf);
#line 420
  k = (int )__cil_tmp8;
  }
#line 420
  if (k != 127) {
    {
#line 421
    psf_log_printf(psf, "*** Warning : short read (%d != %d).\n", k, 127);
    }
  }
#line 423
  if ((int )psds->read_data[0] != 240) {
    {
#line 424
    printf("Error A : %02X\n", (int )psds->read_data[0] & 255);
    }
  }
#line 427
  checksum = psds->read_data[1];
#line 428
  if ((int )checksum != 126) {
    {
#line 429
    printf("Error 1 : %02X\n", (int )checksum & 255);
    }
  }
#line 432
  k = 2;
  {
#line 432
  while (1) {
    while_continue: /* CIL Label */ ;
#line 432
    if (! (k < 124)) {
#line 432
      goto while_break;
    }
#line 433
    checksum ^= (int )psds->read_data[k];
#line 432
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 435
  checksum &= 127;
#line 437
  if ((int )checksum != (int )psds->read_data[125]) {
    {
#line 438
    psf_log_printf(psf, "Block %d : checksum is %02X should be %02X\n", (int )psds->read_data[4],
                   (int )checksum, (int )psds->read_data[125]);
    }
  }
#line 441
  ucptr = (unsigned char *)psds->read_data + 5;
#line 442
  k = 0;
  {
#line 442
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 442
    if (! (k < 120)) {
#line 442
      goto while_break___0;
    }
#line 443
    sample = (unsigned int )(((int )*(ucptr + k) << 25) + ((int )*(ucptr + (k + 1)) << 18));
#line 444
    psds->read_samples[k / 2] = (int )(sample - 2147483648U);
#line 442
    k += 2;
  }
  while_break___0: /* CIL Label */ ;
  }

#line 447
  return (1);
}
}
#line 451 "/root/libsndfile/src/sds.c"
static int sds_3byte_read(SF_PRIVATE *psf , SDS_PRIVATE *psds ) 
{ 
  unsigned char *ucptr ;
  unsigned char checksum ;
  unsigned int sample ;
  int k ;
  int __cil_tmp7 ;
  sf_count_t __cil_tmp8 ;
  int __cil_tmp9 ;

  {
#line 456
  (psds->read_block) ++;
#line 457
  psds->read_count = 0;
#line 459
  if (psds->read_block * psds->samplesperblock > psds->frames) {
    {
#line 460
    memset((int *)psds->read_samples, 0, (unsigned long )psds->samplesperblock * sizeof(int ));
    }
#line 461
    return (1);
  }
  {
#line 464
  __cil_tmp8 = psf_fread((unsigned char *)psds->read_data, (sf_count_t )1, (sf_count_t )127,
                         psf);
#line 464
  k = (int )__cil_tmp8;
  }
#line 464
  if (k != 127) {
    {
#line 465
    psf_log_printf(psf, "*** Warning : short read (%d != %d).\nV", k, 127);
    }
  }
#line 467
  if ((int )psds->read_data[0] != 240) {
    {
#line 468
    printf("Error A : %02X\n", (int )psds->read_data[0] & 255);
    }
  }
#line 471
  checksum = psds->read_data[1];
#line 472
  if ((int )checksum != 126) {
    {
#line 473
    printf("Error 1 : %02X\n", (int )checksum & 255);
    }
  }
#line 476
  k = 2;
  {
#line 476
  while (1) {
    while_continue: /* CIL Label */ ;
#line 476
    if (! (k < 124)) {
#line 476
      goto while_break;
    }
#line 477
    checksum ^= (int )psds->read_data[k];
#line 476
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 479
  checksum &= 127;
#line 481
  if ((int )checksum != (int )psds->read_data[125]) {
    {
#line 482
    psf_log_printf(psf, "Block %d : checksum is %02X should be %02X\n\373\036V", (int )psds->read_data[4],
                   (int )checksum, (int )psds->read_data[125]);
    }
  }
#line 485
  ucptr = (unsigned char *)psds->read_data + 5;
#line 486
  k = 0;
  {
#line 486
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 486
    if (! (k < 120)) {
#line 486
      goto while_break___0;
    }
#line 487
    sample = (unsigned int )((((int )*(ucptr + k) << 25) + ((int )*(ucptr + (k + 1)) << 18)) + ((int )*(ucptr + (k + 2)) << 11));
#line 488
    psds->read_samples[k / 3] = (int )(sample - 2147483648U);
#line 486
    k += 3;
  }
  while_break___0: /* CIL Label */ ;
  }

#line 491
  return (1);
}
}
#line 495 "/root/libsndfile/src/sds.c"
static int sds_4byte_read(SF_PRIVATE *psf , SDS_PRIVATE *psds ) 
{ 
  unsigned char *ucptr ;
  unsigned char checksum ;
  unsigned int sample ;
  int k ;
  int __cil_tmp7 ;
  sf_count_t __cil_tmp8 ;
  int __cil_tmp9 ;

  {
#line 500
  (psds->read_block) ++;
#line 501
  psds->read_count = 0;
#line 503
  if (psds->read_block * psds->samplesperblock > psds->frames) {
    {
#line 504
    memset((int *)psds->read_samples, 0, (unsigned long )psds->samplesperblock * sizeof(int ));
    }
#line 505
    return (1);
  }
  {
#line 508
  __cil_tmp8 = psf_fread((unsigned char *)psds->read_data, (sf_count_t )1, (sf_count_t )127,
                         psf);
#line 508
  k = (int )__cil_tmp8;
  }
#line 508
  if (k != 127) {
    {
#line 509
    psf_log_printf(psf, "*** Warning : short read (%d != %d).\nV", k, 127);
    }
  }
#line 511
  if ((int )psds->read_data[0] != 240) {
    {
#line 512
    printf("Error A : %02X\n", (int )psds->read_data[0] & 255);
    }
  }
#line 515
  checksum = psds->read_data[1];
#line 516
  if ((int )checksum != 126) {
    {
#line 517
    printf("Error 1 : %02X\n", (int )checksum & 255);
    }
  }
#line 520
  k = 2;
  {
#line 520
  while (1) {
    while_continue: /* CIL Label */ ;
#line 520
    if (! (k < 124)) {
#line 520
      goto while_break;
    }
#line 521
    checksum ^= (int )psds->read_data[k];
#line 520
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 523
  checksum &= 127;
#line 525
  if ((int )checksum != (int )psds->read_data[125]) {
    {
#line 526
    psf_log_printf(psf, "Block %d : checksum is %02X should be %02X\n\373\036V", (int )psds->read_data[4],
                   (int )checksum, (int )psds->read_data[125]);
    }
  }
#line 529
  ucptr = (unsigned char *)psds->read_data + 5;
#line 530
  k = 0;
  {
#line 530
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 530
    if (! (k < 120)) {
#line 530
      goto while_break___0;
    }
#line 531
    sample = (unsigned int )(((((int )*(ucptr + k) << 25) + ((int )*(ucptr + (k + 1)) << 18)) + ((int )*(ucptr + (k + 2)) << 11)) + ((int )*(ucptr + (k + 3)) << 4));
#line 532
    psds->read_samples[k / 4] = (int )(sample - 2147483648U);
#line 530
    k += 4;
  }
  while_break___0: /* CIL Label */ ;
  }

#line 535
  return (1);
}
}
#line 540 "/root/libsndfile/src/sds.c"
static sf_count_t sds_read_s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  SDS_PRIVATE *psds ;
  int *iptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count ;
  sf_count_t total ;
  long tmp ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;

  {
#line 544
  total = (sf_count_t )0;
#line 546
  if (psf->codec_data == (void *)0) {
#line 547
    return ((sf_count_t )0);
  }
#line 548
  psds = (SDS_PRIVATE *)psf->codec_data;
#line 550
  iptr = (int *)psf->u.ibuf;
#line 551
  bufferlen = (int )(sizeof(psf->u.ibuf) / sizeof(psf->u.ibuf[0]));
  {
#line 552
  while (1) {
    while_continue: /* CIL Label */ ;
#line 552
    if (! (len > 0L)) {
#line 552
      goto while_break;
    }
#line 553
    if (len >= (long )bufferlen) {
#line 553
      tmp = (long )bufferlen;
    } else {
#line 553
      tmp = len;
    }
    {
#line 553
    readcount = (int )tmp;
#line 554
    count = sds_read(psf, psds, iptr, readcount);
#line 555
    k = 0;
    }
    {
#line 555
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 555
      if (! (k < readcount)) {
#line 555
        goto while_break___0;
      }
#line 556
      *(ptr + (total + (long )k)) = (short )(*(iptr + k) >> 16);
#line 555
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 557
    total += (long )count;
#line 558
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 561
  return (total);
}
}
#line 565 "/root/libsndfile/src/sds.c"
static sf_count_t sds_read_i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  SDS_PRIVATE *psds ;
  int total ;
  int __cil_tmp6 ;

  {
#line 569
  if (psf->codec_data == (void *)0) {
#line 570
    return ((sf_count_t )0);
  }
  {
#line 571
  psds = (SDS_PRIVATE *)psf->codec_data;
#line 573
  total = sds_read(psf, psds, ptr, (int )len);
  }
#line 575
  return ((sf_count_t )total);
}
}
#line 579 "/root/libsndfile/src/sds.c"
static sf_count_t sds_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  SDS_PRIVATE *psds ;
  int *iptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count ;
  sf_count_t total ;
  float normfact ;
  long tmp ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;

  {
#line 583
  total = (sf_count_t )0;
#line 586
  if (psf->codec_data == (void *)0) {
#line 587
    return ((sf_count_t )0);
  }
#line 588
  psds = (SDS_PRIVATE *)psf->codec_data;
#line 590
  if (psf->norm_float == 1) {
#line 591
    normfact = (float )(1. / (double )2147483648U);
  } else {
#line 593
    normfact = (float )(1. / (double )(1 << psds->bitwidth));
  }
#line 595
  iptr = (int *)psf->u.ibuf;
#line 596
  bufferlen = (int )(sizeof(psf->u.ibuf) / sizeof(psf->u.ibuf[0]));
  {
#line 597
  while (1) {
    while_continue: /* CIL Label */ ;
#line 597
    if (! (len > 0L)) {
#line 597
      goto while_break;
    }
#line 598
    if (len >= (long )bufferlen) {
#line 598
      tmp = (long )bufferlen;
    } else {
#line 598
      tmp = len;
    }
    {
#line 598
    readcount = (int )tmp;
#line 599
    count = sds_read(psf, psds, iptr, readcount);
#line 600
    k = 0;
    }
    {
#line 600
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 600
      if (! (k < readcount)) {
#line 600
        goto while_break___0;
      }
#line 601
      *(ptr + (total + (long )k)) = normfact * (float )*(iptr + k);
#line 600
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 602
    total += (long )count;
#line 603
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 606
  return (total);
}
}
#line 610 "/root/libsndfile/src/sds.c"
static sf_count_t sds_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  SDS_PRIVATE *psds ;
  int *iptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count ;
  sf_count_t total ;
  double normfact ;
  long tmp ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;

  {
#line 614
  total = (sf_count_t )0;
#line 617
  if (psf->codec_data == (void *)0) {
#line 618
    return ((sf_count_t )0);
  }
#line 619
  psds = (SDS_PRIVATE *)psf->codec_data;
#line 621
  if (psf->norm_double == 1) {
#line 622
    normfact = 1. / (double )2147483648U;
  } else {
#line 624
    normfact = 1. / (double )(1 << psds->bitwidth);
  }
#line 626
  iptr = (int *)psf->u.ibuf;
#line 627
  bufferlen = (int )(sizeof(psf->u.ibuf) / sizeof(psf->u.ibuf[0]));
  {
#line 628
  while (1) {
    while_continue: /* CIL Label */ ;
#line 628
    if (! (len > 0L)) {
#line 628
      goto while_break;
    }
#line 629
    if (len >= (long )bufferlen) {
#line 629
      tmp = (long )bufferlen;
    } else {
#line 629
      tmp = len;
    }
    {
#line 629
    readcount = (int )tmp;
#line 630
    count = sds_read(psf, psds, iptr, readcount);
#line 631
    k = 0;
    }
    {
#line 631
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 631
      if (! (k < readcount)) {
#line 631
        goto while_break___0;
      }
#line 632
      *(ptr + (total + (long )k)) = normfact * (double )*(iptr + k);
#line 631
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 633
    total += (long )count;
#line 634
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 637
  return (total);
}
}
#line 641 "/root/libsndfile/src/sds.c"
static int sds_read(SF_PRIVATE *psf , SDS_PRIVATE *psds , int *ptr , int len ) 
{ 
  int count ;
  int total ;
  int tmp ;

  {
#line 642
  total = 0;
  {
#line 644
  while (1) {
    while_continue: /* CIL Label */ ;
#line 644
    if (! (total < len)) {
#line 644
      goto while_break;
    }
#line 645
    if (psds->read_block * psds->samplesperblock >= psds->frames) {
      {
#line 646
      memset(ptr + total, 0, (unsigned long )(len - total) * sizeof(int ));
      }
#line 647
      return (total);
    }

#line 650
    if (psds->read_count >= psds->samplesperblock) {
      {
#line 651
      (*(psds->reader))(psf, psds);
      }
    }
#line 653
    count = psds->samplesperblock - psds->read_count;
#line 654
    if (len - total > count) {
#line 654
      tmp = count;
    } else {
#line 654
      tmp = len - total;
    }
    {
#line 654
    count = tmp;
#line 656
    memcpy(ptr + total, & psds->read_samples[psds->read_count], (unsigned long )count * sizeof(int ));
#line 657
    total += count;
#line 658
    psds->read_count += count;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 661
  return (total);
}
}
#line 668 "/root/libsndfile/src/sds.c"
static sf_count_t sds_seek(SF_PRIVATE *psf , int mode , sf_count_t seek_from_start ) 
{ 
  SDS_PRIVATE *psds ;
  sf_count_t file_offset ;
  int newblock ;
  int newsample ;
  sf_count_t __cil_tmp8 ;
  sf_count_t __cil_tmp9 ;

  {
#line 673
  psds = psf->codec_data;
#line 673
  if (psds == (void *)0) {
#line 674
    psf->error = 29;
#line 675
    return ((sf_count_t )(- 1));
  }

#line 678
  if (psf->datalength < 0L) {
#line 679
    psf->error = 38;
#line 680
    return ((sf_count_t )(- 1));
  } else
#line 678
  if (psf->dataoffset < 0L) {
#line 679
    psf->error = 38;
#line 680
    return ((sf_count_t )(- 1));
  }

#line 683
  if (seek_from_start < 0L) {
#line 684
    psf->error = 38;
#line 685
    return ((sf_count_t )(- 1));
  } else
#line 683
  if (seek_from_start > psf->sf.frames) {
#line 684
    psf->error = 38;
#line 685
    return ((sf_count_t )(- 1));
  }

#line 688
  if (mode == 16) {
#line 688
    if (psds->write_count > 0) {
      {
#line 689
      (*(psds->writer))(psf, psds);
      }
    }
  }
#line 691
  newblock = (int )(seek_from_start / (long )psds->samplesperblock);
#line 692
  newsample = (int )(seek_from_start % (long )psds->samplesperblock);
  {
#line 695
  if (mode == 16) {
#line 695
    goto case_16;
  }
#line 713
  if (mode == 32) {
#line 713
    goto case_32;
  }
#line 731
  goto switch_default;
  case_16: /* CIL Label */ 
#line 696
  if (newblock > psds->total_blocks) {
#line 697
    psf->error = 38;
#line 698
    return ((sf_count_t )(- 1));
  }
  {
#line 701
  file_offset = psf->dataoffset + (long )(newblock * 127);
#line 703
  __cil_tmp8 = psf_fseek(psf, file_offset, 0);
  }
#line 703
  if (__cil_tmp8 != file_offset) {
#line 704
    psf->error = 42;
#line 705
    return ((sf_count_t )(- 1));
  }
  {
#line 708
  psds->read_block = newblock;
#line 709
  (*(psds->reader))(psf, psds);
#line 710
  psds->read_count = newsample;
  }
#line 711
  goto switch_break;
  case_32: /* CIL Label */ 
#line 714
  if (newblock > psds->total_blocks) {
#line 715
    psf->error = 38;
#line 716
    return ((sf_count_t )(- 1));
  }
  {
#line 719
  file_offset = psf->dataoffset + (long )(newblock * 127);
#line 721
  __cil_tmp9 = psf_fseek(psf, file_offset, 0);
  }
#line 721
  if (__cil_tmp9 != file_offset) {
#line 722
    psf->error = 42;
#line 723
    return ((sf_count_t )(- 1));
  }
  {
#line 726
  psds->write_block = newblock;
#line 727
  (*(psds->reader))(psf, psds);
#line 728
  psds->write_count = newsample;
  }
#line 729
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 732
  psf->error = 38;
#line 733
  return ((sf_count_t )(- 1));
#line 734
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }

#line 737
  return (seek_from_start);
}
}
#line 744 "/root/libsndfile/src/sds.c"
static int sds_2byte_write(SF_PRIVATE *psf , SDS_PRIVATE *psds ) 
{ 
  unsigned char *ucptr ;
  unsigned char checksum ;
  unsigned int sample ;
  int k ;
  int __cil_tmp7 ;
  sf_count_t __cil_tmp8 ;
  int __cil_tmp9 ;

  {
#line 749
  psds->write_data[0] = (unsigned char )240;
#line 750
  psds->write_data[1] = (unsigned char )126;
#line 751
  psds->write_data[2] = (unsigned char )0;
#line 752
  psds->write_data[3] = (unsigned char )(psds->write_block & 127);
#line 754
  ucptr = (unsigned char *)psds->write_data + 5;
#line 755
  k = 0;
  {
#line 755
  while (1) {
    while_continue: /* CIL Label */ ;
#line 755
    if (! (k < 120)) {
#line 755
      goto while_break;
    }
#line 756
    sample = (unsigned int )psds->write_samples[k / 2];
#line 757
    sample += 2147483648U;
#line 758
    *(ucptr + k) = (unsigned char )((sample >> 25) & 127U);
#line 759
    *(ucptr + (k + 1)) = (unsigned char )((sample >> 18) & 127U);
#line 755
    k += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 762
  checksum = psds->write_data[1];
#line 763
  k = 2;
  {
#line 763
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 763
    if (! (k < 124)) {
#line 763
      goto while_break___0;
    }
#line 764
    checksum ^= (int )psds->write_data[k];
#line 763
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 765
  checksum &= 127;
#line 767
  psds->write_data[125] = checksum;
#line 768
  psds->write_data[126] = (unsigned char )247;
#line 770
  __cil_tmp8 = psf_fwrite((unsigned char *)psds->write_data, (sf_count_t )1, (sf_count_t )127,
                          psf);
#line 770
  k = (int )__cil_tmp8;
  }
#line 770
  if (k != 127) {
    {
#line 771
    psf_log_printf(psf, "*** Warning : psf_fwrite (%d != %d).\nV", k, 127);
    }
  }
#line 773
  (psds->write_block) ++;
#line 774
  psds->write_count = 0;
#line 776
  if (psds->write_block > psds->total_blocks) {
#line 777
    psds->total_blocks = psds->write_block;
  }
#line 778
  psds->frames = psds->total_blocks * psds->samplesperblock;
#line 780
  return (1);
}
}
#line 784 "/root/libsndfile/src/sds.c"
static int sds_3byte_write(SF_PRIVATE *psf , SDS_PRIVATE *psds ) 
{ 
  unsigned char *ucptr ;
  unsigned char checksum ;
  unsigned int sample ;
  int k ;
  int __cil_tmp7 ;
  sf_count_t __cil_tmp8 ;
  int __cil_tmp9 ;

  {
#line 789
  psds->write_data[0] = (unsigned char )240;
#line 790
  psds->write_data[1] = (unsigned char )126;
#line 791
  psds->write_data[2] = (unsigned char )0;
#line 792
  psds->write_data[3] = (unsigned char )(psds->write_block & 127);
#line 794
  ucptr = (unsigned char *)psds->write_data + 5;
#line 795
  k = 0;
  {
#line 795
  while (1) {
    while_continue: /* CIL Label */ ;
#line 795
    if (! (k < 120)) {
#line 795
      goto while_break;
    }
#line 796
    sample = (unsigned int )psds->write_samples[k / 3];
#line 797
    sample += 2147483648U;
#line 798
    *(ucptr + k) = (unsigned char )((sample >> 25) & 127U);
#line 799
    *(ucptr + (k + 1)) = (unsigned char )((sample >> 18) & 127U);
#line 800
    *(ucptr + (k + 2)) = (unsigned char )((sample >> 11) & 127U);
#line 795
    k += 3;
  }
  while_break: /* CIL Label */ ;
  }
#line 803
  checksum = psds->write_data[1];
#line 804
  k = 2;
  {
#line 804
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 804
    if (! (k < 124)) {
#line 804
      goto while_break___0;
    }
#line 805
    checksum ^= (int )psds->write_data[k];
#line 804
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 806
  checksum &= 127;
#line 808
  psds->write_data[125] = checksum;
#line 809
  psds->write_data[126] = (unsigned char )247;
#line 811
  __cil_tmp8 = psf_fwrite((unsigned char *)psds->write_data, (sf_count_t )1, (sf_count_t )127,
                          psf);
#line 811
  k = (int )__cil_tmp8;
  }
#line 811
  if (k != 127) {
    {
#line 812
    psf_log_printf(psf, "*** Warning : psf_fwrite (%d != %d).\nV", k, 127);
    }
  }
#line 814
  (psds->write_block) ++;
#line 815
  psds->write_count = 0;
#line 817
  if (psds->write_block > psds->total_blocks) {
#line 818
    psds->total_blocks = psds->write_block;
  }
#line 819
  psds->frames = psds->total_blocks * psds->samplesperblock;
#line 821
  return (1);
}
}
#line 825 "/root/libsndfile/src/sds.c"
static int sds_4byte_write(SF_PRIVATE *psf , SDS_PRIVATE *psds ) 
{ 
  unsigned char *ucptr ;
  unsigned char checksum ;
  unsigned int sample ;
  int k ;
  int __cil_tmp7 ;
  sf_count_t __cil_tmp8 ;
  int __cil_tmp9 ;

  {
#line 830
  psds->write_data[0] = (unsigned char )240;
#line 831
  psds->write_data[1] = (unsigned char )126;
#line 832
  psds->write_data[2] = (unsigned char )0;
#line 833
  psds->write_data[3] = (unsigned char )(psds->write_block & 127);
#line 835
  ucptr = (unsigned char *)psds->write_data + 5;
#line 836
  k = 0;
  {
#line 836
  while (1) {
    while_continue: /* CIL Label */ ;
#line 836
    if (! (k < 120)) {
#line 836
      goto while_break;
    }
#line 837
    sample = (unsigned int )psds->write_samples[k / 4];
#line 838
    sample += 2147483648U;
#line 839
    *(ucptr + k) = (unsigned char )((sample >> 25) & 127U);
#line 840
    *(ucptr + (k + 1)) = (unsigned char )((sample >> 18) & 127U);
#line 841
    *(ucptr + (k + 2)) = (unsigned char )((sample >> 11) & 127U);
#line 842
    *(ucptr + (k + 3)) = (unsigned char )((sample >> 4) & 127U);
#line 836
    k += 4;
  }
  while_break: /* CIL Label */ ;
  }
#line 845
  checksum = psds->write_data[1];
#line 846
  k = 2;
  {
#line 846
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 846
    if (! (k < 124)) {
#line 846
      goto while_break___0;
    }
#line 847
    checksum ^= (int )psds->write_data[k];
#line 846
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 848
  checksum &= 127;
#line 850
  psds->write_data[125] = checksum;
#line 851
  psds->write_data[126] = (unsigned char )247;
#line 853
  __cil_tmp8 = psf_fwrite((unsigned char *)psds->write_data, (sf_count_t )1, (sf_count_t )127,
                          psf);
#line 853
  k = (int )__cil_tmp8;
  }
#line 853
  if (k != 127) {
    {
#line 854
    psf_log_printf(psf, "*** Warning : psf_fwrite (%d != %d).\nV", k, 127);
    }
  }
#line 856
  (psds->write_block) ++;
#line 857
  psds->write_count = 0;
#line 859
  if (psds->write_block > psds->total_blocks) {
#line 860
    psds->total_blocks = psds->write_block;
  }
#line 861
  psds->frames = psds->total_blocks * psds->samplesperblock;
#line 863
  return (1);
}
}
#line 867 "/root/libsndfile/src/sds.c"
static sf_count_t sds_write_s(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  SDS_PRIVATE *psds ;
  int *iptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count ;
  sf_count_t total ;
  long tmp ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;

  {
#line 871
  total = (sf_count_t )0;
#line 873
  if (psf->codec_data == (void *)0) {
#line 874
    return ((sf_count_t )0);
  }
#line 875
  psds = (SDS_PRIVATE *)psf->codec_data;
#line 877
  iptr = (int *)psf->u.ibuf;
#line 878
  bufferlen = (int )(sizeof(psf->u.ibuf) / sizeof(psf->u.ibuf[0]));
  {
#line 879
  while (1) {
    while_continue: /* CIL Label */ ;
#line 879
    if (! (len > 0L)) {
#line 879
      goto while_break;
    }
#line 880
    if (len >= (long )bufferlen) {
#line 880
      tmp = (long )bufferlen;
    } else {
#line 880
      tmp = len;
    }
#line 880
    writecount = (int )tmp;
#line 881
    k = 0;
    {
#line 881
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 881
      if (! (k < writecount)) {
#line 881
        goto while_break___0;
      }
#line 882
      *(iptr + k) = (int )*(ptr + (total + (long )k)) << 16;
#line 881
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 883
    count = sds_write(psf, psds, (int const   *)iptr, writecount);
#line 884
    total += (long )count;
#line 885
    len -= (long )writecount;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 888
  return (total);
}
}
#line 892 "/root/libsndfile/src/sds.c"
static sf_count_t sds_write_i(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  SDS_PRIVATE *psds ;
  int total ;
  int __cil_tmp6 ;

  {
#line 896
  if (psf->codec_data == (void *)0) {
#line 897
    return ((sf_count_t )0);
  }
  {
#line 898
  psds = (SDS_PRIVATE *)psf->codec_data;
#line 900
  total = sds_write(psf, psds, ptr, (int )len);
  }
#line 902
  return ((sf_count_t )total);
}
}
#line 906 "/root/libsndfile/src/sds.c"
static sf_count_t sds_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  SDS_PRIVATE *psds ;
  int *iptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count ;
  sf_count_t total ;
  float normfact ;
  long tmp ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;

  {
#line 910
  total = (sf_count_t )0;
#line 913
  if (psf->codec_data == (void *)0) {
#line 914
    return ((sf_count_t )0);
  }
#line 915
  psds = (SDS_PRIVATE *)psf->codec_data;
#line 917
  if (psf->norm_float == 1) {
#line 918
    normfact = (float )(1. * (double )2147483648U);
  } else {
#line 920
    normfact = (float )(1. * (double )(1 << psds->bitwidth));
  }
#line 922
  iptr = (int *)psf->u.ibuf;
#line 923
  bufferlen = (int )(sizeof(psf->u.ibuf) / sizeof(psf->u.ibuf[0]));
  {
#line 924
  while (1) {
    while_continue: /* CIL Label */ ;
#line 924
    if (! (len > 0L)) {
#line 924
      goto while_break;
    }
#line 925
    if (len >= (long )bufferlen) {
#line 925
      tmp = (long )bufferlen;
    } else {
#line 925
      tmp = len;
    }
#line 925
    writecount = (int )tmp;
#line 926
    k = 0;
    {
#line 926
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 926
      if (! (k < writecount)) {
#line 926
        goto while_break___0;
      }
#line 927
      *(iptr + k) = (int )(normfact * *(ptr + (total + (long )k)));
#line 926
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 928
    count = sds_write(psf, psds, (int const   *)iptr, writecount);
#line 929
    total += (long )count;
#line 930
    len -= (long )writecount;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 933
  return (total);
}
}
#line 937 "/root/libsndfile/src/sds.c"
static sf_count_t sds_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  SDS_PRIVATE *psds ;
  int *iptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count ;
  sf_count_t total ;
  double normfact ;
  long tmp ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;

  {
#line 941
  total = (sf_count_t )0;
#line 944
  if (psf->codec_data == (void *)0) {
#line 945
    return ((sf_count_t )0);
  }
#line 946
  psds = (SDS_PRIVATE *)psf->codec_data;
#line 948
  if (psf->norm_double == 1) {
#line 949
    normfact = 1. * (double )2147483648U;
  } else {
#line 951
    normfact = 1. * (double )(1 << psds->bitwidth);
  }
#line 953
  iptr = (int *)psf->u.ibuf;
#line 954
  bufferlen = (int )(sizeof(psf->u.ibuf) / sizeof(psf->u.ibuf[0]));
  {
#line 955
  while (1) {
    while_continue: /* CIL Label */ ;
#line 955
    if (! (len > 0L)) {
#line 955
      goto while_break;
    }
#line 956
    if (len >= (long )bufferlen) {
#line 956
      tmp = (long )bufferlen;
    } else {
#line 956
      tmp = len;
    }
#line 956
    writecount = (int )tmp;
#line 957
    k = 0;
    {
#line 957
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 957
      if (! (k < writecount)) {
#line 957
        goto while_break___0;
      }
#line 958
      *(iptr + k) = (int )(normfact * *(ptr + (total + (long )k)));
#line 957
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 959
    count = sds_write(psf, psds, (int const   *)iptr, writecount);
#line 960
    total += (long )count;
#line 961
    len -= (long )writecount;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 964
  return (total);
}
}
#line 968 "/root/libsndfile/src/sds.c"
static int sds_write(SF_PRIVATE *psf , SDS_PRIVATE *psds , int const   *ptr , int len ) 
{ 
  int count ;
  int total ;

  {
#line 969
  total = 0;
  {
#line 971
  while (1) {
    while_continue: /* CIL Label */ ;
#line 971
    if (! (total < len)) {
#line 971
      goto while_break;
    }
#line 972
    count = psds->samplesperblock - psds->write_count;
#line 973
    if (count > len - total) {
#line 974
      count = len - total;
    }
    {
#line 976
    memcpy(& psds->write_samples[psds->write_count], ptr + total, (unsigned long )count * sizeof(int ));
#line 977
    total += count;
#line 978
    psds->write_count += count;
    }
#line 980
    if (psds->write_count >= psds->samplesperblock) {
      {
#line 981
      (*(psds->writer))(psf, psds);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 984
  return (total);
}
}
#line 89 "/root/libsndfile/src/sd2.c"
static int sd2_close(SF_PRIVATE *psf ) ;
#line 91
static int sd2_parse_rsrc_fork(SF_PRIVATE *psf ) ;
#line 92
static int parse_str_rsrc(SF_PRIVATE *psf , SD2_RSRC *rsrc ) ;
#line 94
static int sd2_write_rsrc_fork(SF_PRIVATE *psf , int UNUSED_calc_length ) ;
#line 101 "/root/libsndfile/src/sd2.c"
int sd2_open(SF_PRIVATE *psf ) 
{ 
  int subformat ;
  int error ;
  int valid ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
#line 102
  error = 0;
#line 105
  psf->endian = 536870912;
#line 107
  if (psf->mode == 16) {
    _L: /* CIL Label */ 
    {
#line 108
    psf_use_rsrc(psf, 1);
#line 109
    valid = psf_file_valid(psf);
#line 110
    psf_use_rsrc(psf, 0);
    }
#line 111
    if (! valid) {
      {
#line 112
      psf_log_printf(psf, "sd2_open : psf->rsrcdes < 0\n");
      }
#line 113
      return (145);
    }
    {
#line 116
    error = sd2_parse_rsrc_fork(psf);
    }
#line 118
    if (error) {
#line 119
      goto error_cleanup;
    }
  } else
#line 107
  if (psf->mode == 48) {
#line 107
    if (psf->rsrclength > 0L) {
#line 107
      goto _L;
    }
  }

#line 122
  if ((psf->sf.format & 268369920) != 1441792) {
#line 123
    error = 1;
#line 124
    goto error_cleanup;
  }
#line 127
  subformat = psf->sf.format & 65535;
#line 128
  psf->dataoffset = (sf_count_t )0;
#line 131
  if (psf->mode == 32) {
    _L___26: /* CIL Label */ 
    {
#line 132
    psf_open_rsrc(psf, psf->mode);
#line 134
    error = sd2_write_rsrc_fork(psf, 0);
    }
#line 136
    if (error) {
#line 137
      goto error_cleanup;
    }
#line 140
    psf->write_header = (int (*)(struct sf_private_tag * , int  ))((void *)0);
  } else
#line 131
  if (psf->mode == 48) {
#line 131
    if (psf->rsrclength == 0L) {
#line 131
      goto _L___26;
    }
  }
#line 143
  psf->container_close = & sd2_close;
#line 145
  psf->blockwidth = psf->bytewidth * psf->sf.channels;
  {
#line 150
  if (subformat == 3) {
#line 150
    goto case_3;
  }
#line 150
  if (subformat == 2) {
#line 150
    goto case_3;
  }
#line 150
  if (subformat == 1) {
#line 150
    goto case_3;
  }
#line 154
  goto switch_default;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 151
  error = pcm_init(psf);
  }
#line 152
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 155
  error = 17;
#line 156
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 159
  psf_fseek(psf, psf->dataoffset, 0);
  }
  error_cleanup: 
  {
#line 164
  psf_close_rsrc(psf);
  }
#line 166
  return (error);
}
}
#line 173 "/root/libsndfile/src/sd2.c"
static int sd2_close(SF_PRIVATE *psf ) 
{ 


  {
#line 175
  if (psf->mode == 32) {

  }

#line 182
  return (0);
}
}
#line 189 "/root/libsndfile/src/sd2.c"
__inline static void write_char(unsigned char *data___0 , int offset , char value ) 
{ 


  {
#line 190
  *(data___0 + offset) = (unsigned char )value;
  return;
}
}
#line 194 "/root/libsndfile/src/sd2.c"
__inline static void write_short(unsigned char *data___0 , int offset , short value ) 
{ 


  {
#line 195
  *(data___0 + offset) = (unsigned char )((int )value >> 8);
#line 196
  *(data___0 + (offset + 1)) = (unsigned char )value;
  return;
}
}
#line 200 "/root/libsndfile/src/sd2.c"
__inline static void write_int(unsigned char *data___0 , int offset , int value ) 
{ 


  {
#line 201
  *(data___0 + offset) = (unsigned char )(value >> 24);
#line 202
  *(data___0 + (offset + 1)) = (unsigned char )(value >> 16);
#line 203
  *(data___0 + (offset + 2)) = (unsigned char )(value >> 8);
#line 204
  *(data___0 + (offset + 3)) = (unsigned char )value;
  return;
}
}
#line 208 "/root/libsndfile/src/sd2.c"
__inline static void write_marker(unsigned char *data___0 , int offset , int value ) 
{ 


  {
#line 210
  if (0) {
#line 211
    *(data___0 + offset) = (unsigned char )(value >> 24);
#line 212
    *(data___0 + (offset + 1)) = (unsigned char )(value >> 16);
#line 213
    *(data___0 + (offset + 2)) = (unsigned char )(value >> 8);
#line 214
    *(data___0 + (offset + 3)) = (unsigned char )value;
  } else {
#line 217
    *(data___0 + offset) = (unsigned char )value;
#line 218
    *(data___0 + (offset + 1)) = (unsigned char )(value >> 8);
#line 219
    *(data___0 + (offset + 2)) = (unsigned char )(value >> 16);
#line 220
    *(data___0 + (offset + 3)) = (unsigned char )(value >> 24);
  }

  return;
}
}
#line 225 "/root/libsndfile/src/sd2.c"
static void write_str(unsigned char *data___0 , int offset , char *buffer , int buffer_len ) 
{ 


  {
  {
#line 226
  memcpy(data___0 + offset, buffer, (unsigned long )buffer_len);
  }
  return;
}
}
#line 230 "/root/libsndfile/src/sd2.c"
static int sd2_write_rsrc_fork(SF_PRIVATE *psf , int UNUSED_calc_length ) 
{ 
  SD2_RSRC rsrc ;
  STR_RSRC str_rsrc[4] ;
  unsigned int tmp ;
  unsigned int tmp___27 ;
  unsigned int tmp___28 ;
  unsigned int tmp___29 ;
  int k ;
  int str_offset ;
  int data_offset ;
  int next_str ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  int __cil_tmp22 ;

  {
#line 232
  str_rsrc[0].type = 111;
#line 232
  str_rsrc[0].id = 1000;
#line 232
  str_rsrc[0].name[0] = (char )"_sample-size";
#line 232
  str_rsrc[0].name[1] = (char )"\251";
#line 232
  str_rsrc[0].name[2] = (char )0;
#line 232
  tmp = (unsigned int )3;
  {
#line 232
  while (1) {
    while_continue: /* CIL Label */ ;
#line 232
    if (tmp >= 32) {
#line 232
      goto while_break;
    }
#line 232
    str_rsrc[0].name[tmp] = 0;
#line 232
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 232
  str_rsrc[0].value[0] = (char )0;
#line 232
  str_rsrc[0].value[1] = (char )0;
#line 232
  str_rsrc[0].value[2] = (char )0;
#line 232
  str_rsrc[0].value[3] = (char )0;
#line 232
  str_rsrc[0].value[4] = (char )0;
#line 232
  str_rsrc[0].value[5] = (char )0;
#line 232
  str_rsrc[0].value[6] = (char )0;
#line 232
  str_rsrc[0].value[7] = (char )0;
#line 232
  str_rsrc[0].value[8] = (char )0;
#line 232
  str_rsrc[0].value[9] = (char )0;
#line 232
  str_rsrc[0].value[10] = (char )0;
#line 232
  str_rsrc[0].value[11] = (char )0;
#line 232
  str_rsrc[0].value[12] = (char )0;
#line 232
  str_rsrc[0].value[13] = (char )0;
#line 232
  str_rsrc[0].value[14] = (char )0;
#line 232
  str_rsrc[0].value[15] = (char )0;
#line 232
  str_rsrc[0].value[16] = (char )0;
#line 232
  str_rsrc[0].value[17] = (char )0;
#line 232
  str_rsrc[0].value[18] = (char )0;
#line 232
  str_rsrc[0].value[19] = (char )0;
#line 232
  str_rsrc[0].value[20] = (char )0;
#line 232
  str_rsrc[0].value[21] = (char )0;
#line 232
  str_rsrc[0].value[22] = (char )0;
#line 232
  str_rsrc[0].value[23] = (char )0;
#line 232
  str_rsrc[0].value[24] = (char )0;
#line 232
  str_rsrc[0].value[25] = (char )0;
#line 232
  str_rsrc[0].value[26] = (char )0;
#line 232
  str_rsrc[0].value[27] = (char )0;
#line 232
  str_rsrc[0].value[28] = (char )0;
#line 232
  str_rsrc[0].value[29] = (char )0;
#line 232
  str_rsrc[0].value[30] = (char )0;
#line 232
  str_rsrc[0].value[31] = (char )0;
#line 232
  str_rsrc[0].value_len = 0;
#line 232
  str_rsrc[1].type = 111;
#line 232
  str_rsrc[1].id = 1001;
#line 232
  str_rsrc[1].name[0] = (char )"_sample-rate";
#line 232
  str_rsrc[1].name[1] = (char )"\251";
#line 232
  str_rsrc[1].name[2] = (char )0;
#line 232
  tmp___27 = (unsigned int )3;
  {
#line 232
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 232
    if (tmp___27 >= 32) {
#line 232
      goto while_break___0;
    }
#line 232
    str_rsrc[1].name[tmp___27] = 0;
#line 232
    tmp___27 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 232
  str_rsrc[1].value[0] = (char )0;
#line 232
  str_rsrc[1].value[1] = (char )0;
#line 232
  str_rsrc[1].value[2] = (char )0;
#line 232
  str_rsrc[1].value[3] = (char )0;
#line 232
  str_rsrc[1].value[4] = (char )0;
#line 232
  str_rsrc[1].value[5] = (char )0;
#line 232
  str_rsrc[1].value[6] = (char )0;
#line 232
  str_rsrc[1].value[7] = (char )0;
#line 232
  str_rsrc[1].value[8] = (char )0;
#line 232
  str_rsrc[1].value[9] = (char )0;
#line 232
  str_rsrc[1].value[10] = (char )0;
#line 232
  str_rsrc[1].value[11] = (char )0;
#line 232
  str_rsrc[1].value[12] = (char )0;
#line 232
  str_rsrc[1].value[13] = (char )0;
#line 232
  str_rsrc[1].value[14] = (char )0;
#line 232
  str_rsrc[1].value[15] = (char )0;
#line 232
  str_rsrc[1].value[16] = (char )0;
#line 232
  str_rsrc[1].value[17] = (char )0;
#line 232
  str_rsrc[1].value[18] = (char )0;
#line 232
  str_rsrc[1].value[19] = (char )0;
#line 232
  str_rsrc[1].value[20] = (char )0;
#line 232
  str_rsrc[1].value[21] = (char )0;
#line 232
  str_rsrc[1].value[22] = (char )0;
#line 232
  str_rsrc[1].value[23] = (char )0;
#line 232
  str_rsrc[1].value[24] = (char )0;
#line 232
  str_rsrc[1].value[25] = (char )0;
#line 232
  str_rsrc[1].value[26] = (char )0;
#line 232
  str_rsrc[1].value[27] = (char )0;
#line 232
  str_rsrc[1].value[28] = (char )0;
#line 232
  str_rsrc[1].value[29] = (char )0;
#line 232
  str_rsrc[1].value[30] = (char )0;
#line 232
  str_rsrc[1].value[31] = (char )0;
#line 232
  str_rsrc[1].value_len = 0;
#line 232
  str_rsrc[2].type = 111;
#line 232
  str_rsrc[2].id = 1002;
#line 232
  str_rsrc[2].name[0] = (char )"_channels\224\314\373\036V";
#line 232
  str_rsrc[2].name[1] = (char )"\251";
#line 232
  str_rsrc[2].name[2] = (char )0;
#line 232
  tmp___28 = (unsigned int )3;
  {
#line 232
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 232
    if (tmp___28 >= 32) {
#line 232
      goto while_break___1;
    }
#line 232
    str_rsrc[2].name[tmp___28] = 0;
#line 232
    tmp___28 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 232
  str_rsrc[2].value[0] = (char )0;
#line 232
  str_rsrc[2].value[1] = (char )0;
#line 232
  str_rsrc[2].value[2] = (char )0;
#line 232
  str_rsrc[2].value[3] = (char )0;
#line 232
  str_rsrc[2].value[4] = (char )0;
#line 232
  str_rsrc[2].value[5] = (char )0;
#line 232
  str_rsrc[2].value[6] = (char )0;
#line 232
  str_rsrc[2].value[7] = (char )0;
#line 232
  str_rsrc[2].value[8] = (char )0;
#line 232
  str_rsrc[2].value[9] = (char )0;
#line 232
  str_rsrc[2].value[10] = (char )0;
#line 232
  str_rsrc[2].value[11] = (char )0;
#line 232
  str_rsrc[2].value[12] = (char )0;
#line 232
  str_rsrc[2].value[13] = (char )0;
#line 232
  str_rsrc[2].value[14] = (char )0;
#line 232
  str_rsrc[2].value[15] = (char )0;
#line 232
  str_rsrc[2].value[16] = (char )0;
#line 232
  str_rsrc[2].value[17] = (char )0;
#line 232
  str_rsrc[2].value[18] = (char )0;
#line 232
  str_rsrc[2].value[19] = (char )0;
#line 232
  str_rsrc[2].value[20] = (char )0;
#line 232
  str_rsrc[2].value[21] = (char )0;
#line 232
  str_rsrc[2].value[22] = (char )0;
#line 232
  str_rsrc[2].value[23] = (char )0;
#line 232
  str_rsrc[2].value[24] = (char )0;
#line 232
  str_rsrc[2].value[25] = (char )0;
#line 232
  str_rsrc[2].value[26] = (char )0;
#line 232
  str_rsrc[2].value[27] = (char )0;
#line 232
  str_rsrc[2].value[28] = (char )0;
#line 232
  str_rsrc[2].value[29] = (char )0;
#line 232
  str_rsrc[2].value[30] = (char )0;
#line 232
  str_rsrc[2].value[31] = (char )0;
#line 232
  str_rsrc[2].value_len = 0;
#line 232
  str_rsrc[3].type = 112;
#line 232
  str_rsrc[3].id = 1000;
#line 232
  str_rsrc[3].name[0] = (char )"_Markers\323";
#line 232
  str_rsrc[3].name[1] = (char )"\251";
#line 232
  str_rsrc[3].name[2] = (char )8;
#line 232
  tmp___29 = (unsigned int )3;
  {
#line 232
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 232
    if (tmp___29 >= 32) {
#line 232
      goto while_break___2;
    }
#line 232
    str_rsrc[3].name[tmp___29] = 0;
#line 232
    tmp___29 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 232
  str_rsrc[3].value[0] = (char )0;
#line 232
  str_rsrc[3].value[1] = (char )0;
#line 232
  str_rsrc[3].value[2] = (char )0;
#line 232
  str_rsrc[3].value[3] = (char )0;
#line 232
  str_rsrc[3].value[4] = (char )0;
#line 232
  str_rsrc[3].value[5] = (char )0;
#line 232
  str_rsrc[3].value[6] = (char )0;
#line 232
  str_rsrc[3].value[7] = (char )0;
#line 232
  str_rsrc[3].value[8] = (char )0;
#line 232
  str_rsrc[3].value[9] = (char )0;
#line 232
  str_rsrc[3].value[10] = (char )0;
#line 232
  str_rsrc[3].value[11] = (char )0;
#line 232
  str_rsrc[3].value[12] = (char )0;
#line 232
  str_rsrc[3].value[13] = (char )0;
#line 232
  str_rsrc[3].value[14] = (char )0;
#line 232
  str_rsrc[3].value[15] = (char )0;
#line 232
  str_rsrc[3].value[16] = (char )0;
#line 232
  str_rsrc[3].value[17] = (char )0;
#line 232
  str_rsrc[3].value[18] = (char )0;
#line 232
  str_rsrc[3].value[19] = (char )0;
#line 232
  str_rsrc[3].value[20] = (char )0;
#line 232
  str_rsrc[3].value[21] = (char )0;
#line 232
  str_rsrc[3].value[22] = (char )0;
#line 232
  str_rsrc[3].value[23] = (char )0;
#line 232
  str_rsrc[3].value[24] = (char )0;
#line 232
  str_rsrc[3].value[25] = (char )0;
#line 232
  str_rsrc[3].value[26] = (char )0;
#line 232
  str_rsrc[3].value[27] = (char )0;
#line 232
  str_rsrc[3].value[28] = (char )0;
#line 232
  str_rsrc[3].value[29] = (char )0;
#line 232
  str_rsrc[3].value[30] = (char )0;
#line 232
  str_rsrc[3].value[31] = (char )0;
  {
#line 232
  str_rsrc[3].value_len = 0;
#line 241
  psf_use_rsrc(psf, 1);
#line 243
  memset(& rsrc, 0, sizeof(rsrc));
#line 245
  rsrc.sample_rate = psf->sf.samplerate;
#line 246
  rsrc.sample_size = psf->bytewidth;
#line 247
  rsrc.channels = psf->sf.channels;
#line 249
  rsrc.rsrc_data = (unsigned char *)psf->header;
#line 250
  rsrc.rsrc_len = (int )sizeof(psf->header);
#line 251
  memset(rsrc.rsrc_data, 234, (unsigned long )rsrc.rsrc_len);
#line 253
  snprintf((char *)str_rsrc[0].value, sizeof(str_rsrc[0].value), "_%d", rsrc.sample_size);
#line 254
  snprintf((char *)str_rsrc[1].value, sizeof(str_rsrc[1].value), "_%d.000000", rsrc.sample_rate);
#line 255
  snprintf((char *)str_rsrc[2].value, sizeof(str_rsrc[2].value), "_%d", rsrc.channels);
#line 257
  k = 0;
  }
  {
#line 257
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 257
    if (! (k < (int )(sizeof(str_rsrc) / sizeof(str_rsrc[0])))) {
#line 257
      goto while_break___3;
    }
#line 258
    if (str_rsrc[k].value_len == 0) {
      {
#line 259
      __cil_tmp13 = strlen((char const   *)((char *)str_rsrc[k].value));
#line 259
      str_rsrc[k].value_len = (int )__cil_tmp13;
#line 260
      str_rsrc[k].value[0] = (char )(str_rsrc[k].value_len - 1);
      }
    }
    {
#line 264
    __cil_tmp14 = strlen((char const   *)((char *)str_rsrc[k].name));
#line 264
    str_rsrc[k].name[0] = (char )(__cil_tmp14 - 1UL);
    }
#line 257
    k ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 267
  rsrc.data_offset = 256;
#line 273
  rsrc.data_length = 0;
#line 274
  k = 0;
  {
#line 274
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 274
    if (! (k < (int )(sizeof(str_rsrc) / sizeof(str_rsrc[0])))) {
#line 274
      goto while_break___4;
    }
#line 275
    rsrc.data_length += str_rsrc[k].value_len + 4;
#line 274
    k ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 277
  rsrc.map_offset = rsrc.data_offset + rsrc.data_length;
#line 280
  write_int(rsrc.rsrc_data, 0, rsrc.data_offset);
#line 281
  write_int(rsrc.rsrc_data, 4, rsrc.map_offset);
#line 282
  write_int(rsrc.rsrc_data, 8, rsrc.data_length);
#line 284
  __cil_tmp17 = strlen((char const   *)((char *)psf->filename));
#line 284
  write_char(rsrc.rsrc_data, 48, (char )__cil_tmp17);
#line 285
  __cil_tmp18 = strlen((char const   *)((char *)psf->filename));
#line 285
  write_str(rsrc.rsrc_data, 49, (char *)psf->filename, (int )__cil_tmp18);
#line 287
  write_short(rsrc.rsrc_data, 80, (short )0);
#line 288
  write_marker(rsrc.rsrc_data, 82, ((83 | (100 << 8)) | (50 << 16)) | (102 << 24));
#line 289
  write_marker(rsrc.rsrc_data, 86, ((108 | (115 << 8)) | (102 << 16)) | (49 << 24));
#line 292
  write_int(rsrc.rsrc_data, rsrc.map_offset, rsrc.data_offset);
#line 293
  write_int(rsrc.rsrc_data, rsrc.map_offset + 4, rsrc.map_offset);
#line 294
  write_int(rsrc.rsrc_data, rsrc.map_offset + 8, rsrc.data_length);
  }
#line 297
  if (1) {
    {
#line 298
    write_char(rsrc.rsrc_data, rsrc.map_offset + 16, (char )1);
#line 300
    write_int(rsrc.rsrc_data, rsrc.map_offset + 17, 305419896);
#line 302
    write_short(rsrc.rsrc_data, rsrc.map_offset + 21, (short )43981);
#line 304
    write_short(rsrc.rsrc_data, rsrc.map_offset + 23, (short )0);
    }
  }
  {
#line 308
  rsrc.type_offset = rsrc.map_offset + 30;
#line 309
  write_short(rsrc.rsrc_data, rsrc.map_offset + 24, (short )((rsrc.type_offset - rsrc.map_offset) - 2));
#line 312
  rsrc.type_count = 2;
#line 313
  write_short(rsrc.rsrc_data, rsrc.map_offset + 28, (short )(rsrc.type_count - 1));
#line 315
  rsrc.item_offset = rsrc.type_offset + rsrc.type_count * 8;
#line 317
  rsrc.str_count = (int )(sizeof(str_rsrc) / sizeof(str_rsrc[0]));
#line 318
  rsrc.string_offset = (rsrc.item_offset + (rsrc.str_count + 1) * 12) - rsrc.map_offset;
#line 319
  write_short(rsrc.rsrc_data, rsrc.map_offset + 26, (short )rsrc.string_offset);
#line 322
  rsrc.str_count = 3;
#line 323
  write_marker(rsrc.rsrc_data, rsrc.type_offset, ((83 | (84 << 8)) | (82 << 16)) | (32 << 24));
#line 324
  write_short(rsrc.rsrc_data, rsrc.type_offset + 4, (short )(rsrc.str_count - 1));
#line 325
  write_short(rsrc.rsrc_data, rsrc.type_offset + 6, (short )18);
#line 328
  write_marker(rsrc.rsrc_data, rsrc.type_offset + 8, ((115 | (100 << 8)) | (77 << 16)) | (76 << 24));
#line 329
  write_short(rsrc.rsrc_data, rsrc.type_offset + 12, (short )0);
#line 330
  write_short(rsrc.rsrc_data, rsrc.type_offset + 14, (short )54);
#line 332
  str_offset = rsrc.map_offset + rsrc.string_offset;
#line 333
  next_str = 0;
#line 334
  data_offset = rsrc.data_offset;
#line 335
  k = 0;
  }
  {
#line 335
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 335
    if (! (k < (int )(sizeof(str_rsrc) / sizeof(str_rsrc[0])))) {
#line 335
      goto while_break___5;
    }
    {
#line 336
    __cil_tmp19 = strlen((char const   *)((char *)str_rsrc[k].name));
#line 336
    write_str(rsrc.rsrc_data, str_offset, (char *)str_rsrc[k].name, (int )__cil_tmp19);
#line 338
    write_short(rsrc.rsrc_data, rsrc.item_offset + k * 12, (short )str_rsrc[k].id);
#line 339
    write_short(rsrc.rsrc_data, (rsrc.item_offset + k * 12) + 2, (short )next_str);
#line 341
    __cil_tmp20 = strlen((char const   *)((char *)str_rsrc[k].name));
    }
    {
#line 341
    str_offset += __cil_tmp20;
#line 342
    __cil_tmp21 = strlen((char const   *)((char *)str_rsrc[k].name));
    }
    {
#line 342
    next_str += __cil_tmp21;
#line 344
    write_int(rsrc.rsrc_data, (rsrc.item_offset + k * 12) + 4, data_offset - rsrc.data_offset);
#line 346
    write_int(rsrc.rsrc_data, data_offset, str_rsrc[k].value_len);
#line 347
    write_str(rsrc.rsrc_data, data_offset + 4, (char *)str_rsrc[k].value, str_rsrc[k].value_len);
#line 348
    data_offset += 4 + str_rsrc[k].value_len;
    }
#line 335
    k ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 352
  rsrc.map_length = str_offset - rsrc.map_offset;
#line 353
  write_int(rsrc.rsrc_data, 12, rsrc.map_length);
#line 354
  write_int(rsrc.rsrc_data, rsrc.map_offset + 12, rsrc.map_length);
#line 356
  rsrc.rsrc_len = rsrc.map_offset + rsrc.map_length;
#line 358
  psf_fwrite(rsrc.rsrc_data, (sf_count_t )rsrc.rsrc_len, (sf_count_t )1, psf);
#line 360
  psf_use_rsrc(psf, 0);
  }
#line 362
  if (psf->error) {
#line 363
    return (psf->error);
  }
#line 365
  return (0);
}
}
#line 372 "/root/libsndfile/src/sd2.c"
__inline static int read_char(unsigned char const   *data___0 , int offset ) 
{ 


  {
#line 373
  return ((int )*(data___0 + offset));
}
}
#line 377 "/root/libsndfile/src/sd2.c"
__inline static int read_short(unsigned char const   *data___0 , int offset ) 
{ 


  {
#line 378
  return (((int )*(data___0 + offset) << 8) + (int )*(data___0 + (offset + 1)));
}
}
#line 382 "/root/libsndfile/src/sd2.c"
__inline static int read_int(unsigned char const   *data___0 , int offset ) 
{ 


  {
#line 383
  return (((((int )*(data___0 + offset) << 24) + ((int )*(data___0 + (offset + 1)) << 16)) + ((int )*(data___0 + (offset + 2)) << 8)) + (int )*(data___0 + (offset + 3)));
}
}
#line 387 "/root/libsndfile/src/sd2.c"
__inline static int read_marker(unsigned char const   *data___0 , int offset ) 
{ 


  {
#line 389
  if (0) {
#line 390
    return (((((int )*(data___0 + offset) << 24) + ((int )*(data___0 + (offset + 1)) << 16)) + ((int )*(data___0 + (offset + 2)) << 8)) + (int )*(data___0 + (offset + 3)));
  } else
#line 391
  if (1) {
#line 392
    return ((((int )*(data___0 + offset) + ((int )*(data___0 + (offset + 1)) << 8)) + ((int )*(data___0 + (offset + 2)) << 16)) + ((int )*(data___0 + (offset + 3)) << 24));
  } else {
#line 394
    return (1638);
  }
}
}
#line 398 "/root/libsndfile/src/sd2.c"
static void read_str(unsigned char const   *data___0 , int offset , char *buffer ,
                     int buffer_len ) 
{ 
  int k ;
  unsigned short const   **__cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 401
  memset(buffer, 0, (unsigned long )buffer_len);
#line 403
  k = 0;
  }
  {
#line 403
  while (1) {
    while_continue: /* CIL Label */ ;
#line 403
    if (! (k < buffer_len - 1)) {
#line 403
      goto while_break;
    }
    {
#line 404
    __cil_tmp6 = __ctype_b_loc();
    }
#line 404
    if (((int )*(*__cil_tmp6 + (int )*(data___0 + (offset + k))) & 16384) == 0) {
#line 405
      return;
    }
#line 406
    *(buffer + k) = (char )*(data___0 + (offset + k));
#line 403
    k ++;
  }
  while_break: /* CIL Label */ ;
  }

#line 408
  return;
}
}
#line 412 "/root/libsndfile/src/sd2.c"
static int sd2_parse_rsrc_fork(SF_PRIVATE *psf ) 
{ 
  SD2_RSRC rsrc ;
  int k ;
  int marker ;
  int error ;
  sf_count_t __cil_tmp6 ;
  void *__cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;

  {
  {
#line 414
  error = 0;
#line 416
  psf_use_rsrc(psf, 1);
#line 418
  memset(& rsrc, 0, sizeof(rsrc));
#line 420
  __cil_tmp6 = psf_get_filelen(psf);
#line 420
  rsrc.rsrc_len = (int )__cil_tmp6;
#line 421
  psf_log_printf(psf, "Resource length : %d (0x%04X)\n", rsrc.rsrc_len, rsrc.rsrc_len);
  }
#line 423
  if (rsrc.rsrc_len > (int )sizeof(psf->header)) {
    {
#line 424
    rsrc.rsrc_data = (unsigned char *)calloc((unsigned long )1, (unsigned long )rsrc.rsrc_len);
#line 425
    rsrc.need_to_free_rsrc_data = 1;
    }
  } else {
#line 428
    rsrc.rsrc_data = (unsigned char *)psf->header;
  }
  {
#line 431
  psf_fread(rsrc.rsrc_data, (sf_count_t )rsrc.rsrc_len, (sf_count_t )1, psf);
#line 434
  psf->headend = rsrc.rsrc_len;
#line 434
  psf->headindex = psf->headend;
#line 436
  rsrc.data_offset = read_int((unsigned char const   *)rsrc.rsrc_data, 0);
#line 437
  rsrc.map_offset = read_int((unsigned char const   *)rsrc.rsrc_data, 4);
#line 438
  rsrc.data_length = read_int((unsigned char const   *)rsrc.rsrc_data, 8);
#line 439
  rsrc.map_length = read_int((unsigned char const   *)rsrc.rsrc_data, 12);
  }
#line 441
  if (rsrc.data_offset == 333319) {
#line 441
    if (rsrc.map_offset == 131072) {
      {
#line 442
      psf_log_printf(psf, "Trying offset of 0x52 bytes.\n");
#line 443
      __cil_tmp12 = read_int((unsigned char const   *)rsrc.rsrc_data, 82);
#line 443
      rsrc.data_offset = __cil_tmp12 + 82;
#line 444
      __cil_tmp13 = read_int((unsigned char const   *)rsrc.rsrc_data, 86);
#line 444
      rsrc.map_offset = __cil_tmp13 + 82;
#line 445
      rsrc.data_length = read_int((unsigned char const   *)rsrc.rsrc_data, 90);
#line 446
      rsrc.map_length = read_int((unsigned char const   *)rsrc.rsrc_data, 94);
      }
    }
  }
  {
#line 449
  psf_log_printf(psf, "  data offset : 0x%04X\n  map  offset : 0x%04X\n  data length : 0x%04X\n  map  length : 0x%04X\n\230\001",
                 rsrc.data_offset, rsrc.map_offset, rsrc.data_length, rsrc.map_length);
  }
#line 453
  if (rsrc.data_offset > rsrc.rsrc_len) {
    {
#line 454
    psf_log_printf(psf, "Error : rsrc.data_offset (%d, 0x%x) > len\n", rsrc.data_offset,
                   rsrc.data_offset);
#line 455
    error = 141;
    }
#line 456
    goto parse_rsrc_fork_cleanup;
  }

#line 459
  if (rsrc.map_offset > rsrc.rsrc_len) {
    {
#line 460
    psf_log_printf(psf, "Error : rsrc.map_offset > len\n");
#line 461
    error = 142;
    }
#line 462
    goto parse_rsrc_fork_cleanup;
  }

#line 465
  if (rsrc.data_length > rsrc.rsrc_len) {
    {
#line 466
    psf_log_printf(psf, "Error : rsrc.data_length > len\n");
#line 467
    error = 143;
    }
#line 468
    goto parse_rsrc_fork_cleanup;
  }

#line 471
  if (rsrc.map_length > rsrc.rsrc_len) {
    {
#line 472
    psf_log_printf(psf, "Error : rsrc.map_length > len\n");
#line 473
    error = 144;
    }
#line 474
    goto parse_rsrc_fork_cleanup;
  }

#line 477
  if (rsrc.data_offset + rsrc.data_length != rsrc.map_offset) {
    {
    {
#line 478
    psf_log_printf(psf, "Error : This does not look like a MacOSX resource fork.\n\220");
    }
#line 479
    error = 145;
    }
#line 480
    goto parse_rsrc_fork_cleanup;
  } else
#line 477
  if (rsrc.map_offset + rsrc.map_length != rsrc.rsrc_len) {
    {
    {
#line 478
    psf_log_printf(psf, "Error : This does not look like a MacOSX resource fork.\n\220");
    }
#line 479
    error = 145;
    }
#line 480
    goto parse_rsrc_fork_cleanup;
  }

#line 483
  if (rsrc.map_offset + 28 >= rsrc.rsrc_len) {
    {
#line 484
    psf_log_printf(psf, "Bad map offset (%d + 28 > %d).\n", rsrc.map_offset, rsrc.rsrc_len);
#line 485
    error = 145;
    }
#line 486
    goto parse_rsrc_fork_cleanup;
  }
  {
#line 489
  __cil_tmp16 = read_short((unsigned char const   *)rsrc.rsrc_data, rsrc.map_offset + 26);
#line 489
  rsrc.string_offset = rsrc.map_offset + __cil_tmp16;
  }
#line 490
  if (rsrc.string_offset > rsrc.rsrc_len) {
    {
#line 491
    psf_log_printf(psf, "Bad string offset (%d).\n\230\001", rsrc.string_offset);
#line 492
    error = 145;
    }
#line 493
    goto parse_rsrc_fork_cleanup;
  }
  {
#line 496
  rsrc.type_offset = rsrc.map_offset + 30;
#line 498
  __cil_tmp17 = read_short((unsigned char const   *)rsrc.rsrc_data, rsrc.map_offset + 28);
#line 498
  rsrc.type_count = __cil_tmp17 + 1;
  }
#line 499
  if (rsrc.type_count < 1) {
    {
#line 500
    psf_log_printf(psf, "Bad type count.\n\220");
#line 501
    error = 145;
    }
#line 502
    goto parse_rsrc_fork_cleanup;
  }
#line 505
  rsrc.item_offset = rsrc.type_offset + rsrc.type_count * 8;
#line 506
  if (rsrc.item_offset < 0) {
    {
    {
#line 507
    psf_log_printf(psf, "Bad item offset (%d).\n", rsrc.item_offset);
    }
#line 508
    error = 145;
    }
#line 509
    goto parse_rsrc_fork_cleanup;
  } else
#line 506
  if (rsrc.item_offset > rsrc.rsrc_len) {
    {
    {
#line 507
    psf_log_printf(psf, "Bad item offset (%d).\n", rsrc.item_offset);
    }
#line 508
    error = 145;
    }
#line 509
    goto parse_rsrc_fork_cleanup;
  }
#line 512
  rsrc.str_index = - 1;
#line 513
  k = 0;
  {
#line 513
  while (1) {
    while_continue: /* CIL Label */ ;
#line 513
    if (! (k < rsrc.type_count)) {
#line 513
      goto while_break;
    }
    {
#line 514
    marker = read_marker((unsigned char const   *)rsrc.rsrc_data, rsrc.type_offset + k * 8);
    }
#line 516
    if (marker == (((83 | (84 << 8)) | (82 << 16)) | (32 << 24))) {
      {
#line 517
      rsrc.str_index = k;
#line 518
      __cil_tmp19 = read_short((unsigned char const   *)rsrc.rsrc_data, (rsrc.type_offset + k * 8) + 4);
#line 518
      rsrc.str_count = __cil_tmp19 + 1;
#line 519
      error = parse_str_rsrc(psf, & rsrc);
      }
#line 520
      goto parse_rsrc_fork_cleanup;
    }

#line 513
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 524
  psf_log_printf(psf, "No \'STR \' resource.\n");
#line 525
  error = 145;
  }
  parse_rsrc_fork_cleanup: 
  {
#line 529
  psf_use_rsrc(psf, 0);
  }
#line 531
  if (rsrc.need_to_free_rsrc_data) {
    {
#line 532
    free(rsrc.rsrc_data);
    }
  }
#line 534
  return (error);
}
}
#line 538 "/root/libsndfile/src/sd2.c"
static int parse_str_rsrc(SF_PRIVATE *psf , SD2_RSRC *rsrc ) 
{ 
  char name[32] ;
  char value[32] ;
  int k ;
  int str_offset ;
  int rsrc_id ;
  int data_offset ;
  int data_len ;
  int slen ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  long __cil_tmp16 ;
  long __cil_tmp17 ;
  long __cil_tmp18 ;
  int __cil_tmp19 ;
  int temp ;

  {
#line 540
  data_offset = 0;
  {
#line 540
  data_len = 0;
#line 542
  psf_log_printf(psf, "Finding parameters :\nV");
#line 544
  str_offset = rsrc->string_offset;
#line 545
  psf_log_printf(psf, "  Offset    RsrcId    dlen    slen    Value\n\036V");
#line 547
  k = 0;
  }
  {
#line 547
  while (1) {
    while_continue: /* CIL Label */ ;
#line 547
    if (! (data_offset + data_len < rsrc->rsrc_len)) {
#line 547
      goto while_break;
    }
    {
#line 550
    slen = read_char((unsigned char const   *)rsrc->rsrc_data, str_offset);
#line 551
    read_str((unsigned char const   *)rsrc->rsrc_data, str_offset + 1, (char *)name,
             0);
#line 552
    str_offset += slen + 1;
#line 554
    rsrc_id = read_short((unsigned char const   *)rsrc->rsrc_data, rsrc->item_offset + k * 12);
#line 556
    __cil_tmp13 = read_int((unsigned char const   *)rsrc->rsrc_data, (rsrc->item_offset + k * 12) + 4);
#line 556
    data_offset = rsrc->data_offset + __cil_tmp13;
    }
#line 557
    if (data_offset < 0) {
      {
      {
#line 558
      psf_log_printf(psf, "Exiting parser on data offset of %d.\nV", data_offset);
      }
      }
#line 559
      goto while_break;
    } else
#line 557
    if (data_offset > rsrc->rsrc_len) {
      {
      {
#line 558
      psf_log_printf(psf, "Exiting parser on data offset of %d.\nV", data_offset);
      }
      }
#line 559
      goto while_break;
    }
    {
#line 562
    data_len = read_int((unsigned char const   *)rsrc->rsrc_data, data_offset);
    }
#line 563
    if (data_len < 0) {
      {
      {
#line 564
      psf_log_printf(psf, "Exiting parser on data length of %d.\n", data_len);
      }
      }
#line 565
      goto while_break;
    } else
#line 563
    if (data_len > rsrc->rsrc_len) {
      {
      {
#line 564
      psf_log_printf(psf, "Exiting parser on data length of %d.\n", data_len);
      }
      }
#line 565
      goto while_break;
    }
    {
#line 568
    slen = read_char((unsigned char const   *)rsrc->rsrc_data, data_offset + 4);
#line 569
    read_str((unsigned char const   *)rsrc->rsrc_data, data_offset + 5, (char *)value,
             0);
#line 571
    psf_log_printf(psf, "  0x%04x     %4d     %4d     %3d    \'%s\'\n", data_offset,
                   rsrc_id, data_len, slen, (char *)value);
    }
#line 573
    if (rsrc_id == 1000) {
#line 573
      if (rsrc->sample_size == 0) {
        {
#line 574
        __cil_tmp16 = strtol((char const   *)((char *)value), (char **)((void *)0),
                             10);
#line 574
        rsrc->sample_size = (int )__cil_tmp16;
        }
      } else {
#line 573
        goto _L___30;
      }
    } else
    _L___30: /* CIL Label */ 
#line 575
    if (rsrc_id == 1001) {
#line 575
      if (rsrc->sample_rate == 0) {
        {
#line 576
        __cil_tmp17 = strtol((char const   *)((char *)value), (char **)((void *)0),
                             10);
#line 576
        rsrc->sample_rate = (int )__cil_tmp17;
        }
      } else {
#line 575
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 577
    if (rsrc_id == 1002) {
#line 577
      if (rsrc->channels == 0) {
        {
#line 578
        __cil_tmp18 = strtol((char const   *)((char *)value), (char **)((void *)0),
                             10);
#line 578
        rsrc->channels = (int )__cil_tmp18;
        }
      }
    }
#line 547
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 581
  psf_log_printf(psf, "Found Parameters :\n");
#line 582
  psf_log_printf(psf, "  sample-size : %d\n", rsrc->sample_size);
#line 583
  psf_log_printf(psf, "  sample-rate : %d\n", rsrc->sample_rate);
#line 584
  psf_log_printf(psf, "  channels    : %d\n\373\036V", rsrc->channels);
  }
#line 586
  if (rsrc->sample_rate <= 4) {
#line 586
    if (rsrc->sample_size > 4) {
      {
#line 589
      psf_log_printf(psf, "Geez!! Looks like sample rate and sample size got switched.\nCorrecting this screw up.\n");
#line 590
      temp = rsrc->sample_rate;
#line 591
      rsrc->sample_rate = rsrc->sample_size;
#line 592
      rsrc->sample_size = temp;
      }
    }
  }

#line 595
  if (rsrc->sample_rate < 0) {
    {
#line 596
    psf_log_printf(psf, "Bad sample rate (%d)\n", rsrc->sample_rate);
    }
#line 597
    return (145);
  }

#line 600
  if (rsrc->channels < 0) {
    {
#line 601
    psf_log_printf(psf, "Bad channel count (%d)\n", rsrc->channels);
    }
#line 602
    return (145);
  }
#line 605
  psf->sf.samplerate = rsrc->sample_rate;
#line 606
  psf->sf.channels = rsrc->channels;
#line 607
  psf->bytewidth = rsrc->sample_size;
  {
#line 610
  if (rsrc->sample_size == 1) {
#line 610
    goto case_1;
  }
#line 614
  if (rsrc->sample_size == 2) {
#line 614
    goto case_2;
  }
#line 618
  if (rsrc->sample_size == 3) {
#line 618
    goto case_3;
  }
#line 622
  goto switch_default;
  case_1: /* CIL Label */ 
#line 611
  psf->sf.format = 1441793;
#line 612
  goto switch_break;
  case_2: /* CIL Label */ 
#line 615
  psf->sf.format = 1441794;
#line 616
  goto switch_break;
  case_3: /* CIL Label */ 
#line 619
  psf->sf.format = 1441795;
#line 620
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 623
  psf_log_printf(psf, "Bad sample size (%d)\n", rsrc->sample_size);
  }
#line 624
  return (146);
  switch_break: /* CIL Label */ ;
  }
  {
#line 627
  psf_log_printf(psf, "ok\n\373\036V");
  }
#line 629
  return (0);
}
}
#line 33 "/root/libsndfile/src/rx2.c"
int rx2_open(SF_PRIVATE *psf ) 
{ 


  {
#line 34
  if (psf) {
#line 35
    return (17);
  }
#line 36
  return (0);
}
}
#line 31 "/root/libsndfile/src/raw.c"
int raw_open(SF_PRIVATE *psf ) 
{ 
  int subformat ;
  int error ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;

  {
#line 32
  error = 0;
#line 34
  subformat = psf->sf.format & 65535;
#line 36
  psf->endian = psf->sf.format & 805306368;
#line 38
  if (0) {
#line 39
    psf->endian = 536870912;
  } else
#line 40
  if (psf->endian == 0) {
#line 41
    psf->endian = 268435456;
  } else
#line 40
  if (psf->endian == 805306368) {
#line 41
    psf->endian = 268435456;
  }
#line 43
  psf->blockwidth = psf->bytewidth * psf->sf.channels;
#line 44
  psf->dataoffset = (sf_count_t )0;
#line 45
  psf->datalength = psf->filelength;
  {
#line 48
  if (subformat == 1) {
#line 48
    goto case_1;
  }
#line 52
  if (subformat == 5) {
#line 52
    goto case_5;
  }
#line 58
  if (subformat == 4) {
#line 58
    goto case_4;
  }
#line 58
  if (subformat == 3) {
#line 58
    goto case_4;
  }
#line 58
  if (subformat == 2) {
#line 58
    goto case_4;
  }
#line 62
  if (subformat == 16) {
#line 62
    goto case_16;
  }
#line 66
  if (subformat == 17) {
#line 66
    goto case_17;
  }
#line 70
  if (subformat == 32) {
#line 70
    goto case_32;
  }
#line 75
  if (subformat == 6) {
#line 75
    goto case_6;
  }
#line 79
  if (subformat == 7) {
#line 79
    goto case_7;
  }
#line 83
  if (subformat == 64) {
#line 83
    goto case_64;
  }
#line 87
  if (subformat == 65) {
#line 87
    goto case_65;
  }
#line 91
  if (subformat == 66) {
#line 91
    goto case_66;
  }
#line 95
  if (subformat == 33) {
#line 95
    goto case_33;
  }
#line 100
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 49
  error = pcm_init(psf);
  }
#line 50
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 53
  error = pcm_init(psf);
  }
#line 54
  goto switch_break;
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 59
  error = pcm_init(psf);
  }
#line 60
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 63
  error = ulaw_init(psf);
  }
#line 64
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 67
  error = alaw_init(psf);
  }
#line 68
  goto switch_break;
  case_32: /* CIL Label */ 
  {
#line 71
  error = gsm610_init(psf);
  }
#line 72
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 76
  error = float32_init(psf);
  }
#line 77
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 80
  error = double64_init(psf);
  }
#line 81
  goto switch_break;
  case_64: /* CIL Label */ 
  {
#line 84
  error = dwvw_init(psf, 12);
  }
#line 85
  goto switch_break;
  case_65: /* CIL Label */ 
  {
#line 88
  error = dwvw_init(psf, 16);
  }
#line 89
  goto switch_break;
  case_66: /* CIL Label */ 
  {
#line 92
  error = dwvw_init(psf, 24);
  }
#line 93
  goto switch_break;
  case_33: /* CIL Label */ 
  {
#line 96
  error = vox_adpcm_init(psf);
  }
#line 97
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 100
  return (1);
  switch_break: /* CIL Label */ ;
  }

#line 103
  return (error);
}
}
#line 40 "/root/libsndfile/src/pvf.c"
static int pvf_close(SF_PRIVATE *UNUSED_psf ) ;
#line 42
static int pvf_write_header(SF_PRIVATE *psf , int UNUSED_calc_length ) ;
#line 43
static int pvf_read_header(SF_PRIVATE *psf ) ;
#line 50 "/root/libsndfile/src/pvf.c"
int pvf_open(SF_PRIVATE *psf ) 
{ 
  int subformat ;
  int error ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 52
  error = 0;
#line 54
  if (psf->mode == 16) {
    _L: /* CIL Label */ 
    {
#line 55
    error = pvf_read_header(psf);
    }
#line 55
    if (error) {
#line 56
      return (error);
    }
  } else
#line 54
  if (psf->mode == 48) {
#line 54
    if (psf->filelength > 0L) {
#line 54
      goto _L;
    }
  }
#line 59
  subformat = psf->sf.format & 65535;
#line 61
  if (psf->mode == 32) {
    _L___31: /* CIL Label */ 
#line 62
    if ((psf->sf.format & 268369920) != 917504) {
#line 63
      return (1);
    }
    {
#line 65
    psf->endian = 536870912;
#line 67
    __cil_tmp5 = pvf_write_header(psf, 0);
    }
#line 67
    if (__cil_tmp5) {
#line 68
      return (psf->error);
    }
#line 70
    psf->write_header = & pvf_write_header;
  } else
#line 61
  if (psf->mode == 48) {
#line 61
    goto _L___31;
  }
#line 73
  psf->container_close = & pvf_close;
#line 75
  psf->blockwidth = psf->bytewidth * psf->sf.channels;
  {
#line 80
  if (subformat == 4) {
#line 80
    goto case_4;
  }
#line 80
  if (subformat == 2) {
#line 80
    goto case_4;
  }
#line 80
  if (subformat == 1) {
#line 80
    goto case_4;
  }
#line 84
  goto switch_default;
  case_4: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 81
  error = pcm_init(psf);
  }
#line 82
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 84
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }

#line 87
  return (error);
}
}
#line 94 "/root/libsndfile/src/pvf.c"
static int pvf_close(SF_PRIVATE *UNUSED_psf ) 
{ 


  {
#line 96
  return (0);
}
}
#line 100 "/root/libsndfile/src/pvf.c"
static int pvf_write_header(SF_PRIVATE *psf , int UNUSED_calc_length ) 
{ 
  sf_count_t current ;
  sf_count_t __cil_tmp4 ;
  unsigned long __cil_tmp5 ;

  {
#line 103
  if (psf->pipeoffset > 0L) {
#line 104
    return (0);
  }
  {
#line 106
  current = psf_ftell(psf);
#line 109
  psf->header[0] = (unsigned char )0;
#line 110
  psf->headindex = 0;
  }
#line 112
  if (psf->is_pipe == 0) {
    {
#line 113
    psf_fseek(psf, (sf_count_t )0, 0);
    }
  }
  {
#line 115
  snprintf((char *)((unsigned char *)psf->header), sizeof(psf->header), "PVF1\n%d %d %d\n",
           psf->sf.channels, psf->sf.samplerate, psf->bytewidth * 8);
#line 118
  __cil_tmp5 = strlen((char const   *)((char *)((unsigned char *)psf->header)));
#line 118
  psf->headindex = (int )__cil_tmp5;
#line 121
  psf_fwrite((unsigned char *)psf->header, (sf_count_t )psf->headindex, (sf_count_t )1,
             psf);
  }
#line 123
  if (psf->error) {
#line 124
    return (psf->error);
  }
#line 126
  psf->dataoffset = (sf_count_t )psf->headindex;
#line 128
  if (current > 0L) {
    {
#line 129
    psf_fseek(psf, current, 0);
    }
  }
#line 131
  return (psf->error);
}
}
#line 135 "/root/libsndfile/src/pvf.c"
static int pvf_read_header(SF_PRIVATE *psf ) 
{ 
  char buffer[32] ;
  int marker ;
  int channels ;
  int samplerate ;
  int bitwidth ;
  int __cil_tmp7 ;
  sf_count_t __cil_tmp8 ;

  {
  {
#line 139
  psf_binheader_readf(psf, "pmj\374\036V", 0, & marker, 1);
#line 140
  psf_log_printf(psf, "%M\n\374\036V", marker);
  }
#line 142
  if (marker != (((80 | (86 << 8)) | (70 << 16)) | (49 << 24))) {
#line 143
    return (129);
  }
  {
#line 146
  psf_binheader_readf(psf, "G\314\017\374\036V", (char *)buffer, sizeof(buffer));
#line 148
  __cil_tmp7 = sscanf((char const   *)((char *)buffer), "%d %d %d\230\001", & channels,
                      & samplerate, & bitwidth);
  }
#line 148
  if (__cil_tmp7 != 3) {
#line 149
    return (130);
  }
  {
#line 151
  psf_log_printf(psf, " Channels    : %d\n Sample rate : %d\n Bit width   : %d\n",
                 channels, samplerate, bitwidth);
#line 154
  psf->sf.channels = channels;
#line 155
  psf->sf.samplerate = samplerate;
  }
  {
#line 158
  if (bitwidth == 8) {
#line 158
    goto case_8;
  }
#line 163
  if (bitwidth == 16) {
#line 163
    goto case_16;
  }
#line 167
  if (bitwidth == 32) {
#line 167
    goto case_32;
  }
#line 172
  goto switch_default;
  case_8: /* CIL Label */ 
#line 159
  psf->sf.format = 917505;
#line 160
  psf->bytewidth = 1;
#line 161
  goto switch_break;
  case_16: /* CIL Label */ 
#line 164
  psf->sf.format = 917506;
#line 165
  psf->bytewidth = 2;
#line 166
  goto switch_break;
  case_32: /* CIL Label */ 
#line 168
  psf->sf.format = 917508;
#line 169
  psf->bytewidth = 4;
#line 170
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 173
  return (131);
  switch_break: /* CIL Label */ ;
  }
  {
#line 176
  psf->dataoffset = psf_ftell(psf);
#line 177
  psf_log_printf(psf, " Data Offset : %D\n\017\374\036V", psf->dataoffset);
#line 179
  psf->endian = 536870912;
#line 181
  psf->datalength = psf->filelength - psf->dataoffset;
#line 182
  psf->blockwidth = psf->sf.channels * psf->bytewidth;
  }
#line 184
  if (! psf->sf.frames) {
#line 184
    if (psf->blockwidth) {
#line 185
      psf->sf.frames = (psf->filelength - psf->dataoffset) / (long )psf->blockwidth;
    }
  }
#line 187
  return (0);
}
}
#line 78 "/root/libsndfile/src/paf.c"
static int paf24_init(SF_PRIVATE *psf ) ;
#line 80
static int paf_read_header(SF_PRIVATE *psf ) ;
#line 81
static int paf_write_header(SF_PRIVATE *psf , int UNUSED_calc_length ) ;
#line 83
static sf_count_t paf24_read_s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 84
static sf_count_t paf24_read_i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 85
static sf_count_t paf24_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 86
static sf_count_t paf24_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 88
static sf_count_t paf24_write_s(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 89
static sf_count_t paf24_write_i(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 90
static sf_count_t paf24_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 91
static sf_count_t paf24_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 93
static sf_count_t paf24_seek(SF_PRIVATE *psf , int mode , sf_count_t offset ) ;
#line 106 "/root/libsndfile/src/paf.c"
int paf_open(SF_PRIVATE *psf ) 
{ 
  int subformat ;
  int error ;
  int endian ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
#line 109
  psf->dataoffset = (sf_count_t )2048;
#line 111
  if (psf->mode == 16) {
    _L: /* CIL Label */ 
    {
#line 112
    error = paf_read_header(psf);
    }
#line 112
    if (error) {
#line 113
      return (error);
    }
  } else
#line 111
  if (psf->mode == 48) {
#line 111
    if (psf->filelength > 0L) {
#line 111
      goto _L;
    }
  }
#line 116
  subformat = psf->sf.format & 65535;
#line 118
  if (psf->mode == 32) {
    _L___32: /* CIL Label */ 
#line 119
    if ((psf->sf.format & 268369920) != 327680) {
#line 120
      return (1);
    }
#line 122
    endian = psf->sf.format & 805306368;
#line 125
    psf->endian = 536870912;
#line 127
    if (endian == 268435456) {
#line 128
      psf->endian = 268435456;
    } else
#line 127
    if (endian == 805306368) {
#line 128
      psf->endian = 268435456;
    }
    {
#line 130
    error = paf_write_header(psf, 0);
    }
#line 130
    if (error) {
#line 131
      return (error);
    }
#line 133
    psf->write_header = & paf_write_header;
  } else
#line 118
  if (psf->mode == 48) {
#line 118
    goto _L___32;
  }

  {
#line 137
  if (subformat == 1) {
#line 137
    goto case_1;
  }
#line 142
  if (subformat == 2) {
#line 142
    goto case_2;
  }
#line 147
  if (subformat == 3) {
#line 147
    goto case_3;
  }
#line 152
  goto switch_default;
  case_1: /* CIL Label */ 
#line 138
  psf->bytewidth = 1;
  {
#line 139
  error = pcm_init(psf);
  }
#line 140
  goto switch_break;
  case_2: /* CIL Label */ 
#line 143
  psf->bytewidth = 2;
  {
#line 144
  error = pcm_init(psf);
  }
#line 145
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 149
  error = paf24_init(psf);
  }
#line 150
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 152
  return (94);
  switch_break: /* CIL Label */ ;
  }

#line 155
  return (error);
}
}
#line 162 "/root/libsndfile/src/paf.c"
static int paf_read_header(SF_PRIVATE *psf ) 
{ 
  PAF_FMT paf_fmt ;
  int marker ;
  int tmp ;

  {
  {
#line 166
  memset(& paf_fmt, 0, sizeof(paf_fmt));
#line 167
  psf_binheader_readf(psf, "pm", 0, & marker);
#line 169
  psf_log_printf(psf, "Signature   : \'%M\'\n", marker);
  }
#line 171
  if (marker == (((32 | (112 << 8)) | (97 << 16)) | (102 << 24))) {
    {
#line 172
    psf_binheader_readf(psf, "E444444", & paf_fmt.version, & paf_fmt.endianness, & paf_fmt.samplerate,
                        & paf_fmt.format, & paf_fmt.channels, & paf_fmt.source);
    }
  } else
#line 175
  if (marker == (((102 | (97 << 8)) | (112 << 16)) | (32 << 24))) {
    {
#line 176
    psf_binheader_readf(psf, "e444444", & paf_fmt.version, & paf_fmt.endianness, & paf_fmt.samplerate,
                        & paf_fmt.format, & paf_fmt.channels, & paf_fmt.source);
    }
  } else {
#line 180
    return (92);
  }
  {
#line 182
  psf_log_printf(psf, "Version     : %d\nR,\374\036V", paf_fmt.version);
  }
#line 184
  if (paf_fmt.version != 0) {
    {
#line 185
    psf_log_printf(psf, "*** Bad version number. should be zero.\n\220");
    }
#line 186
    return (93);
  }
  {
#line 189
  psf_log_printf(psf, "Sample Rate : %d\n", paf_fmt.samplerate);
#line 190
  psf_log_printf(psf, "Channels    : %d\n", paf_fmt.channels);
#line 192
  psf_log_printf(psf, "Endianness  : %d => ", paf_fmt.endianness);
  }
#line 193
  if (paf_fmt.endianness) {
    {
#line 194
    psf_log_printf(psf, "Little\n", paf_fmt.endianness);
#line 195
    psf->endian = 268435456;
    }
  } else {
    {
#line 198
    psf_log_printf(psf, "Big\n", paf_fmt.endianness);
#line 199
    psf->endian = 536870912;
    }
  }

#line 202
  if (psf->filelength < 2048L) {
#line 203
    return (95);
  }
  {
#line 205
  psf->datalength = psf->filelength - psf->dataoffset;
#line 207
  psf_binheader_readf(psf, "p", (int )psf->dataoffset);
#line 209
  psf->sf.samplerate = paf_fmt.samplerate;
#line 210
  psf->sf.channels = paf_fmt.channels;
#line 213
  psf->sf.format = 327680;
#line 215
  psf_log_printf(psf, "Format      : %d => ", paf_fmt.format);
  }
#line 218
  if (paf_fmt.endianness) {
#line 218
    tmp = 268435456;
  } else {
#line 218
    tmp = 536870912;
  }
#line 218
  psf->sf.format |= tmp;
  {
#line 221
  if (paf_fmt.format == 2) {
#line 221
    goto case_2;
  }
#line 231
  if (paf_fmt.format == 0) {
#line 231
    goto case_0;
  }
#line 241
  if (paf_fmt.format == 1) {
#line 241
    goto case_1;
  }
#line 252
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 222
  psf_log_printf(psf, "8 bit linear PCM\n");
  }
#line 223
  psf->bytewidth = 1;
#line 225
  psf->sf.format |= 1;
#line 227
  psf->blockwidth = psf->bytewidth * psf->sf.channels;
#line 228
  psf->sf.frames = psf->datalength / (long )psf->blockwidth;
#line 229
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 232
  psf_log_printf(psf, "16 bit linear PCM\n");
  }
#line 233
  psf->bytewidth = 2;
#line 235
  psf->sf.format |= 2;
#line 237
  psf->blockwidth = psf->bytewidth * psf->sf.channels;
#line 238
  psf->sf.frames = psf->datalength / (long )psf->blockwidth;
#line 239
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 242
  psf_log_printf(psf, "24 bit linear PCM\n");
  }
#line 243
  psf->bytewidth = 3;
#line 245
  psf->sf.format |= 3;
#line 247
  psf->blockwidth = 0;
#line 248
  psf->sf.frames = (10L * psf->datalength) / (long )(32 * psf->sf.channels);
#line 250
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 252
  psf_log_printf(psf, "Unknown\n\220");
  }
#line 253
  return (94);
#line 254
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 257
  psf_log_printf(psf, "Source      : %d => ", paf_fmt.source);
  }
  {
#line 260
  if (paf_fmt.source == 1) {
#line 260
    goto case_1___0;
  }
#line 262
  if (paf_fmt.source == 2) {
#line 262
    goto case_2___0;
  }
#line 264
  if (paf_fmt.source == 3) {
#line 264
    goto case_3;
  }
#line 266
  if (paf_fmt.source == 5) {
#line 266
    goto case_5;
  }
#line 268
  goto switch_default___0;
  case_1___0: /* CIL Label */ 
  {
#line 260
  psf_log_printf(psf, "Analog Recording\n");
  }
#line 261
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
  {
#line 262
  psf_log_printf(psf, "Digital Transfer\n");
  }
#line 263
  goto switch_break___0;
  case_3: /* CIL Label */ 
  {
#line 264
  psf_log_printf(psf, "Multi-track Mixdown\n");
  }
#line 265
  goto switch_break___0;
  case_5: /* CIL Label */ 
  {
#line 266
  psf_log_printf(psf, "Audio Resulting From DSP Processing\n");
  }
#line 267
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 268
  psf_log_printf(psf, "Unknown\n\220");
  }
#line 269
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }

#line 272
  return (0);
}
}
#line 276 "/root/libsndfile/src/paf.c"
static int paf_write_header(SF_PRIVATE *psf , int UNUSED_calc_length ) 
{ 
  int paf_format ;
  sf_count_t __cil_tmp4 ;

  {
  {
#line 280
  __cil_tmp4 = psf_ftell(psf);
  }
#line 280
  if (__cil_tmp4 >= 2048L) {
#line 281
    return (0);
  }
#line 283
  psf->dataoffset = (sf_count_t )2048;
  {
#line 286
  if ((psf->sf.format & 65535) == 1) {
#line 286
    goto case_1;
  }
#line 290
  if ((psf->sf.format & 65535) == 2) {
#line 290
    goto case_2;
  }
#line 294
  if ((psf->sf.format & 65535) == 3) {
#line 294
    goto case_3;
  }
#line 298
  goto switch_default;
  case_1: /* CIL Label */ 
#line 287
  paf_format = 2;
#line 288
  goto switch_break;
  case_2: /* CIL Label */ 
#line 291
  paf_format = 0;
#line 292
  goto switch_break;
  case_3: /* CIL Label */ 
#line 295
  paf_format = 1;
#line 296
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 298
  return (94);
  switch_break: /* CIL Label */ ;
  }
#line 302
  psf->header[0] = (unsigned char )0;
#line 303
  psf->headindex = 0;
#line 305
  if (psf->endian == 536870912) {
    {
#line 307
    psf_binheader_writef(psf, "Em444", ((32 | (112 << 8)) | (97 << 16)) | (102 << 24),
                         0, 0, psf->sf.samplerate);
#line 309
    psf_binheader_writef(psf, "E444", paf_format, psf->sf.channels, 0);
    }
  } else
#line 311
  if (psf->endian == 268435456) {
    {
#line 313
    psf_binheader_writef(psf, "em444V", ((102 | (97 << 8)) | (112 << 16)) | (32 << 24),
                         0, 1, psf->sf.samplerate);
#line 315
    psf_binheader_writef(psf, "e444\036V", paf_format, psf->sf.channels, 0);
    }
  }
  {
#line 319
  psf_binheader_writef(psf, "z\232,\374\036V", (size_t )(psf->dataoffset - (long )psf->headindex));
#line 321
  psf_fwrite((unsigned char *)psf->header, (sf_count_t )psf->headindex, (sf_count_t )1,
             psf);
  }
#line 323
  return (psf->error);
}
}
#line 340
static int paf24_read_block(SF_PRIVATE *psf , PAF24_PRIVATE *ppaf24 ) ;
#line 341
static int paf24_write_block(SF_PRIVATE *psf , PAF24_PRIVATE *ppaf24 ) ;
#line 342
static int paf24_close(SF_PRIVATE *psf ) ;
#line 346 "/root/libsndfile/src/paf.c"
static int paf24_init(SF_PRIVATE *psf ) 
{ 
  PAF24_PRIVATE *ppaf24 ;
  int paf24size ;
  void *__cil_tmp4 ;
  sf_count_t __cil_tmp5 ;

  {
  {
#line 350
  paf24size = (int )(sizeof(PAF24_PRIVATE ) + (unsigned long )psf->sf.channels * (32UL + 10UL * sizeof(int )));
#line 357
  psf->last_op = 0;
#line 359
  psf->codec_data = malloc((unsigned long )paf24size);
  }
#line 359
  if (! psf->codec_data) {
#line 360
    return (16);
  }
  {
#line 362
  ppaf24 = (PAF24_PRIVATE *)psf->codec_data;
#line 363
  memset(ppaf24, 0, (unsigned long )paf24size);
#line 365
  ppaf24->channels = psf->sf.channels;
#line 366
  ppaf24->samples = (int *)ppaf24->data;
#line 367
  ppaf24->block = (unsigned char *)((int *)ppaf24->data + 10 * ppaf24->channels);
#line 369
  ppaf24->blocksize = 32 * ppaf24->channels;
#line 370
  ppaf24->samplesperblock = 10;
  }
#line 372
  if (psf->mode == 16) {
    {
    {
#line 373
    paf24_read_block(psf, ppaf24);
    }
#line 375
    psf->read_short = & paf24_read_s;
#line 376
    psf->read_int = & paf24_read_i;
#line 377
    psf->read_float = & paf24_read_f;
#line 378
    psf->read_double = & paf24_read_d;
    }
  } else
#line 372
  if (psf->mode == 48) {
    {
    {
#line 373
    paf24_read_block(psf, ppaf24);
    }
#line 375
    psf->read_short = & paf24_read_s;
#line 376
    psf->read_int = & paf24_read_i;
#line 377
    psf->read_float = & paf24_read_f;
#line 378
    psf->read_double = & paf24_read_d;
    }
  }

#line 381
  if (psf->mode == 32) {
#line 382
    psf->write_short = & paf24_write_s;
#line 383
    psf->write_int = & paf24_write_i;
#line 384
    psf->write_float = & paf24_write_f;
#line 385
    psf->write_double = & paf24_write_d;
  } else
#line 381
  if (psf->mode == 48) {
#line 382
    psf->write_short = & paf24_write_s;
#line 383
    psf->write_int = & paf24_write_i;
#line 384
    psf->write_float = & paf24_write_f;
#line 385
    psf->write_double = & paf24_write_d;
  }
  {
#line 388
  psf->seek = & paf24_seek;
#line 389
  psf->container_close = & paf24_close;
#line 391
  psf->filelength = psf_get_filelen(psf);
#line 392
  psf->datalength = psf->filelength - psf->dataoffset;
  }
#line 394
  if (psf->datalength % 32L) {
#line 395
    if (psf->mode == 16) {
      {
#line 396
      psf_log_printf(psf, "*** Warning : file seems to be truncated.\n");
      }
    }
#line 397
    ppaf24->max_blocks = (int )(psf->datalength / (long )ppaf24->blocksize + 1L);
  } else {
#line 400
    ppaf24->max_blocks = (int )(psf->datalength / (long )ppaf24->blocksize);
  }
#line 402
  ppaf24->read_block = 0;
#line 403
  if (psf->mode == 48) {
#line 404
    ppaf24->write_block = ppaf24->max_blocks;
  } else {
#line 406
    ppaf24->write_block = 0;
  }
#line 408
  psf->sf.frames = (sf_count_t )(ppaf24->samplesperblock * ppaf24->max_blocks);
#line 409
  ppaf24->sample_count = psf->sf.frames;
#line 411
  return (0);
}
}
#line 415 "/root/libsndfile/src/paf.c"
static sf_count_t paf24_seek(SF_PRIVATE *psf , int mode , sf_count_t offset ) 
{ 
  PAF24_PRIVATE *ppaf24 ;
  int newblock ;
  int newsample ;

  {
#line 419
  if (psf->codec_data == (void *)0) {
#line 420
    psf->error = 29;
#line 421
    return ((sf_count_t )(- 1));
  }
#line 424
  ppaf24 = (PAF24_PRIVATE *)psf->codec_data;
#line 426
  if (mode == 16) {
#line 426
    if (ppaf24->write_count > 0) {
      {
#line 427
      paf24_write_block(psf, ppaf24);
      }
    }
  }
#line 429
  newblock = (int )(offset / (long )ppaf24->samplesperblock);
#line 430
  newsample = (int )(offset % (long )ppaf24->samplesperblock);
  {
#line 433
  if (mode == 16) {
#line 433
    goto case_16;
  }
#line 443
  if (mode == 32) {
#line 443
    goto case_32;
  }
#line 458
  goto switch_default;
  case_16: /* CIL Label */ 
#line 434
  if (psf->last_op == 32) {
#line 434
    if (ppaf24->write_count) {
      {
#line 435
      paf24_write_block(psf, ppaf24);
      }
    }
  }
  {
#line 437
  psf_fseek(psf, psf->dataoffset + (long )(newblock * ppaf24->blocksize), 0);
#line 438
  ppaf24->read_block = newblock;
#line 439
  paf24_read_block(psf, ppaf24);
#line 440
  ppaf24->read_count = newsample;
  }
#line 441
  goto switch_break;
  case_32: /* CIL Label */ 
#line 444
  if (offset > ppaf24->sample_count) {
#line 445
    psf->error = 38;
#line 446
    return ((sf_count_t )(- 1));
  }

#line 449
  if (psf->last_op == 32) {
#line 449
    if (ppaf24->write_count) {
      {
#line 450
      paf24_write_block(psf, ppaf24);
      }
    }
  }
  {
#line 452
  psf_fseek(psf, psf->dataoffset + (long )(newblock * ppaf24->blocksize), 0);
#line 453
  ppaf24->write_block = newblock;
#line 454
  paf24_read_block(psf, ppaf24);
#line 455
  ppaf24->write_count = newsample;
  }
#line 456
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 459
  psf->error = 38;
#line 460
  return ((sf_count_t )(- 1));
  switch_break: /* CIL Label */ ;
  }

#line 463
  return ((sf_count_t )(newblock * ppaf24->samplesperblock + newsample));
}
}
#line 467 "/root/libsndfile/src/paf.c"
static int paf24_close(SF_PRIVATE *psf ) 
{ 
  PAF24_PRIVATE *ppaf24 ;

  {
#line 470
  if (psf->codec_data == (void *)0) {
#line 471
    return (0);
  }
#line 473
  ppaf24 = (PAF24_PRIVATE *)psf->codec_data;
#line 475
  if (psf->mode == 32) {
    _L: /* CIL Label */ 
#line 476
    if (ppaf24->write_count > 0) {
      {
#line 477
      paf24_write_block(psf, ppaf24);
      }
    }
  } else
#line 475
  if (psf->mode == 48) {
#line 475
    goto _L;
  }

#line 480
  return (0);
}
}
#line 486 "/root/libsndfile/src/paf.c"
static int paf24_read_block(SF_PRIVATE *psf , PAF24_PRIVATE *ppaf24 ) 
{ 
  int k ;
  int channel ;
  unsigned char *cptr ;
  int __cil_tmp6 ;
  sf_count_t __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
#line 490
  (ppaf24->read_block) ++;
#line 491
  ppaf24->read_count = 0;
#line 493
  if ((long )(ppaf24->read_block * ppaf24->samplesperblock) > ppaf24->sample_count) {
    {
#line 494
    memset(ppaf24->samples, 0, (unsigned long )(ppaf24->samplesperblock * ppaf24->channels));
    }
#line 495
    return (1);
  }
  {
#line 499
  __cil_tmp7 = psf_fread(ppaf24->block, (sf_count_t )1, (sf_count_t )ppaf24->blocksize,
                         psf);
#line 499
  k = (int )__cil_tmp7;
  }
#line 499
  if (k != ppaf24->blocksize) {
    {
#line 500
    psf_log_printf(psf, "*** Warning : short read (%d != %d).\nV", k, ppaf24->blocksize);
    }
  }
#line 503
  if (1) {
#line 505
    if (psf->endian == 536870912) {
      {
#line 506
      endswap_int_array((int *)ppaf24->data, 8 * ppaf24->channels);
      }
    }
#line 509
    k = 0;
    {
#line 509
    while (1) {
      while_continue: /* CIL Label */ ;
#line 509
      if (! (k < 10 * ppaf24->channels)) {
#line 509
        goto while_break;
      }
#line 510
      channel = k % ppaf24->channels;
#line 511
      cptr = (ppaf24->block + 32 * channel) + 3 * (k / ppaf24->channels);
#line 512
      *(ppaf24->samples + k) = (((int )*(cptr + 0) << 8) | ((int )*(cptr + 1) << 16)) | ((int )*(cptr + 2) << 24);
#line 509
      k ++;
    }
    while_break: /* CIL Label */ ;
    }

  } else {
#line 517
    if (psf->endian == 536870912) {
      {
#line 518
      endswap_int_array((int *)ppaf24->data, 8 * ppaf24->channels);
      }
    }
#line 521
    k = 0;
    {
#line 521
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 521
      if (! (k < 10 * ppaf24->channels)) {
#line 521
        goto while_break___0;
      }
#line 522
      channel = k % ppaf24->channels;
#line 523
      cptr = (ppaf24->block + 32 * channel) + 3 * (k / ppaf24->channels);
#line 524
      *(ppaf24->samples + k) = (((int )*(cptr + 0) << 8) | ((int )*(cptr + 1) << 16)) | ((int )*(cptr + 2) << 24);
#line 521
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }

  }

#line 528
  return (1);
}
}
#line 532 "/root/libsndfile/src/paf.c"
static int paf24_read(SF_PRIVATE *psf , PAF24_PRIVATE *ppaf24 , int *ptr , int len ) 
{ 
  int count ;
  int total ;
  int tmp ;

  {
#line 533
  total = 0;
  {
#line 535
  while (1) {
    while_continue: /* CIL Label */ ;
#line 535
    if (! (total < len)) {
#line 535
      goto while_break;
    }
#line 536
    if ((long )(ppaf24->read_block * ppaf24->samplesperblock) >= ppaf24->sample_count) {
      {
#line 537
      memset(ptr + total, 0, (unsigned long )(len - total) * sizeof(int ));
      }
#line 538
      return (total);
    }

#line 541
    if (ppaf24->read_count >= ppaf24->samplesperblock) {
      {
#line 542
      paf24_read_block(psf, ppaf24);
      }
    }
#line 544
    count = (ppaf24->samplesperblock - ppaf24->read_count) * ppaf24->channels;
#line 545
    if (len - total > count) {
#line 545
      tmp = count;
    } else {
#line 545
      tmp = len - total;
    }
    {
#line 545
    count = tmp;
#line 547
    memcpy(ptr + total, ppaf24->samples + ppaf24->read_count * ppaf24->channels, (unsigned long )count * sizeof(int ));
#line 548
    total += count;
#line 549
    ppaf24->read_count += count / ppaf24->channels;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 552
  return (total);
}
}
#line 556 "/root/libsndfile/src/paf.c"
static sf_count_t paf24_read_s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  PAF24_PRIVATE *ppaf24 ;
  int *iptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count ;
  sf_count_t total ;
  long tmp ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;

  {
#line 560
  total = (sf_count_t )0;
#line 562
  if (psf->codec_data == (void *)0) {
#line 563
    return ((sf_count_t )0);
  }
#line 564
  ppaf24 = (PAF24_PRIVATE *)psf->codec_data;
#line 566
  iptr = (int *)psf->u.ibuf;
#line 567
  bufferlen = (int )(sizeof(psf->u.ibuf) / sizeof(psf->u.ibuf[0]));
  {
#line 568
  while (1) {
    while_continue: /* CIL Label */ ;
#line 568
    if (! (len > 0L)) {
#line 568
      goto while_break;
    }
#line 569
    if (len >= (long )bufferlen) {
#line 569
      tmp = (long )bufferlen;
    } else {
#line 569
      tmp = len;
    }
    {
#line 569
    readcount = (int )tmp;
#line 570
    count = paf24_read(psf, ppaf24, iptr, readcount);
#line 571
    k = 0;
    }
    {
#line 571
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 571
      if (! (k < readcount)) {
#line 571
        goto while_break___0;
      }
#line 572
      *(ptr + (total + (long )k)) = (short )(*(iptr + k) >> 16);
#line 571
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 573
    total += (long )count;
#line 574
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 576
  return (total);
}
}
#line 580 "/root/libsndfile/src/paf.c"
static sf_count_t paf24_read_i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  PAF24_PRIVATE *ppaf24 ;
  int total ;
  int __cil_tmp6 ;

  {
#line 584
  if (psf->codec_data == (void *)0) {
#line 585
    return ((sf_count_t )0);
  }
  {
#line 586
  ppaf24 = (PAF24_PRIVATE *)psf->codec_data;
#line 588
  total = paf24_read(psf, ppaf24, ptr, (int )len);
  }
#line 590
  return ((sf_count_t )total);
}
}
#line 594 "/root/libsndfile/src/paf.c"
static sf_count_t paf24_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  PAF24_PRIVATE *ppaf24 ;
  int *iptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  long tmp___0 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;

  {
#line 598
  total = (sf_count_t )0;
#line 601
  if (psf->codec_data == (void *)0) {
#line 602
    return ((sf_count_t )0);
  }
#line 603
  ppaf24 = (PAF24_PRIVATE *)psf->codec_data;
#line 605
  if (psf->norm_float == 1) {
#line 605
    tmp = 1. / (double )2147483648U;
  } else {
#line 605
    tmp = 1. / (double )256;
  }
#line 605
  normfact = (float )tmp;
#line 607
  iptr = (int *)psf->u.ibuf;
#line 608
  bufferlen = (int )(sizeof(psf->u.ibuf) / sizeof(psf->u.ibuf[0]));
  {
#line 609
  while (1) {
    while_continue: /* CIL Label */ ;
#line 609
    if (! (len > 0L)) {
#line 609
      goto while_break;
    }
#line 610
    if (len >= (long )bufferlen) {
#line 610
      tmp___0 = (long )bufferlen;
    } else {
#line 610
      tmp___0 = len;
    }
    {
#line 610
    readcount = (int )tmp___0;
#line 611
    count = paf24_read(psf, ppaf24, iptr, readcount);
#line 612
    k = 0;
    }
    {
#line 612
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 612
      if (! (k < readcount)) {
#line 612
        goto while_break___0;
      }
#line 613
      *(ptr + (total + (long )k)) = normfact * (float )*(iptr + k);
#line 612
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 614
    total += (long )count;
#line 615
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 617
  return (total);
}
}
#line 621 "/root/libsndfile/src/paf.c"
static sf_count_t paf24_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  PAF24_PRIVATE *ppaf24 ;
  int *iptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  long tmp___0 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;

  {
#line 625
  total = (sf_count_t )0;
#line 628
  if (psf->codec_data == (void *)0) {
#line 629
    return ((sf_count_t )0);
  }
#line 630
  ppaf24 = (PAF24_PRIVATE *)psf->codec_data;
#line 632
  if (psf->norm_double == 1) {
#line 632
    tmp = 1. / (double )2147483648U;
  } else {
#line 632
    tmp = 1. / (double )256;
  }
#line 632
  normfact = tmp;
#line 634
  iptr = (int *)psf->u.ibuf;
#line 635
  bufferlen = (int )(sizeof(psf->u.ibuf) / sizeof(psf->u.ibuf[0]));
  {
#line 636
  while (1) {
    while_continue: /* CIL Label */ ;
#line 636
    if (! (len > 0L)) {
#line 636
      goto while_break;
    }
#line 637
    if (len >= (long )bufferlen) {
#line 637
      tmp___0 = (long )bufferlen;
    } else {
#line 637
      tmp___0 = len;
    }
    {
#line 637
    readcount = (int )tmp___0;
#line 638
    count = paf24_read(psf, ppaf24, iptr, readcount);
#line 639
    k = 0;
    }
    {
#line 639
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 639
      if (! (k < readcount)) {
#line 639
        goto while_break___0;
      }
#line 640
      *(ptr + (total + (long )k)) = normfact * (double )*(iptr + k);
#line 639
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 641
    total += (long )count;
#line 642
    len -= (long )readcount;
  }
  while_break: /* CIL Label */ ;
  }

#line 644
  return (total);
}
}
#line 651 "/root/libsndfile/src/paf.c"
static int paf24_write_block(SF_PRIVATE *psf , PAF24_PRIVATE *ppaf24 ) 
{ 
  int k ;
  int nextsample ;
  int channel ;
  unsigned char *cptr ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  sf_count_t __cil_tmp9 ;
  int __cil_tmp10 ;

  {
#line 657
  if (1) {
#line 658
    k = 0;
    {
#line 658
    while (1) {
      while_continue: /* CIL Label */ ;
#line 658
      if (! (k < 10 * ppaf24->channels)) {
#line 658
        goto while_break;
      }
#line 659
      channel = k % ppaf24->channels;
#line 660
      cptr = (ppaf24->block + 32 * channel) + 3 * (k / ppaf24->channels);
#line 661
      nextsample = *(ppaf24->samples + k) >> 8;
#line 662
      *(cptr + 0) = (unsigned char )nextsample;
#line 663
      *(cptr + 1) = (unsigned char )(nextsample >> 8);
#line 664
      *(cptr + 2) = (unsigned char )(nextsample >> 16);
#line 658
      k ++;
    }
    while_break: /* CIL Label */ ;
    }

#line 668
    if (psf->endian == 536870912) {
      {
#line 669
      endswap_int_array((int *)ppaf24->data, 8 * ppaf24->channels);
      }
    }
  } else
#line 671
  if (0) {
#line 673
    k = 0;
    {
#line 673
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 673
      if (! (k < 10 * ppaf24->channels)) {
#line 673
        goto while_break___0;
      }
#line 674
      channel = k % ppaf24->channels;
#line 675
      cptr = (ppaf24->block + 32 * channel) + 3 * (k / ppaf24->channels);
#line 676
      nextsample = *(ppaf24->samples + k) >> 8;
#line 677
      *(cptr + 0) = (unsigned char )nextsample;
#line 678
      *(cptr + 1) = (unsigned char )(nextsample >> 8);
#line 679
      *(cptr + 2) = (unsigned char )(nextsample >> 16);
#line 673
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }

#line 681
    if (psf->endian == 536870912) {
      {
#line 682
      endswap_int_array((int *)ppaf24->data, 8 * ppaf24->channels);
      }
    }
  }
  {
#line 686
  __cil_tmp9 = psf_fwrite(ppaf24->block, (sf_count_t )1, (sf_count_t )ppaf24->blocksize,
                          psf);
#line 686
  k = (int )__cil_tmp9;
  }
#line 686
  if (k != ppaf24->blocksize) {
    {
#line 687
    psf_log_printf(psf, "*** Warning : short write (%d != %d).\n", k, ppaf24->blocksize);
    }
  }
#line 689
  if (ppaf24->sample_count < (long )(ppaf24->write_block * ppaf24->samplesperblock + ppaf24->write_count)) {
#line 690
    ppaf24->sample_count = (sf_count_t )(ppaf24->write_block * ppaf24->samplesperblock + ppaf24->write_count);
  }
#line 692
  if (ppaf24->write_count == ppaf24->samplesperblock) {
#line 693
    (ppaf24->write_block) ++;
#line 694
    ppaf24->write_count = 0;
  }

#line 697
  return (1);
}
}
#line 701 "/root/libsndfile/src/paf.c"
static int paf24_write(SF_PRIVATE *psf , PAF24_PRIVATE *ppaf24 , int const   *ptr ,
                       int len ) 
{ 
  int count ;
  int total ;

  {
#line 702
  total = 0;
  {
#line 704
  while (1) {
    while_continue: /* CIL Label */ ;
#line 704
    if (! (total < len)) {
#line 704
      goto while_break;
    }
#line 705
    count = (ppaf24->samplesperblock - ppaf24->write_count) * ppaf24->channels;
#line 707
    if (count > len - total) {
#line 708
      count = len - total;
    }
    {
#line 710
    memcpy(ppaf24->samples + ppaf24->write_count * ppaf24->channels, ptr + total,
           (unsigned long )count * sizeof(int ));
#line 711
    total += count;
#line 712
    ppaf24->write_count += count / ppaf24->channels;
    }
#line 714
    if (ppaf24->write_count >= ppaf24->samplesperblock) {
      {
#line 715
      paf24_write_block(psf, ppaf24);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 718
  return (total);
}
}
#line 722 "/root/libsndfile/src/paf.c"
static sf_count_t paf24_write_s(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  PAF24_PRIVATE *ppaf24 ;
  int *iptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count ;
  sf_count_t total ;
  long tmp ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;

  {
#line 725
  writecount = 0;
#line 726
  total = (sf_count_t )0;
#line 728
  if (psf->codec_data == (void *)0) {
#line 729
    return ((sf_count_t )0);
  }
#line 730
  ppaf24 = (PAF24_PRIVATE *)psf->codec_data;
#line 732
  iptr = (int *)psf->u.ibuf;
#line 733
  bufferlen = (int )(sizeof(psf->u.ibuf) / sizeof(psf->u.ibuf[0]));
  {
#line 734
  while (1) {
    while_continue: /* CIL Label */ ;
#line 734
    if (! (len > 0L)) {
#line 734
      goto while_break;
    }
#line 735
    if (len >= (long )bufferlen) {
#line 735
      tmp = (long )bufferlen;
    } else {
#line 735
      tmp = len;
    }
#line 735
    writecount = (int )tmp;
#line 736
    k = 0;
    {
#line 736
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 736
      if (! (k < writecount)) {
#line 736
        goto while_break___0;
      }
#line 737
      *(iptr + k) = (int )*(ptr + (total + (long )k)) << 16;
#line 736
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 738
    count = paf24_write(psf, ppaf24, (int const   *)iptr, writecount);
#line 739
    total += (long )count;
#line 740
    len -= (long )writecount;
    }
#line 741
    if (count != writecount) {
#line 742
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 744
  return (total);
}
}
#line 748 "/root/libsndfile/src/paf.c"
static sf_count_t paf24_write_i(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  PAF24_PRIVATE *ppaf24 ;
  int writecount ;
  int count ;
  sf_count_t total ;
  int tmp ;
  int __cil_tmp9 ;

  {
#line 751
  total = (sf_count_t )0;
#line 753
  if (psf->codec_data == (void *)0) {
#line 754
    return ((sf_count_t )0);
  }
#line 755
  ppaf24 = (PAF24_PRIVATE *)psf->codec_data;
  {
#line 757
  while (1) {
    while_continue: /* CIL Label */ ;
#line 757
    if (! (len > 0L)) {
#line 757
      goto while_break;
    }
#line 758
    if (len > 268435456L) {
#line 758
      tmp = 268435456;
    } else {
#line 758
      tmp = (int )len;
    }
    {
#line 758
    writecount = tmp;
#line 760
    count = paf24_write(psf, ppaf24, ptr, writecount);
#line 762
    total += (long )count;
#line 763
    len -= (long )count;
    }
#line 764
    if (count != writecount) {
#line 765
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 768
  return (total);
}
}
#line 772 "/root/libsndfile/src/paf.c"
static sf_count_t paf24_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  PAF24_PRIVATE *ppaf24 ;
  int *iptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  long tmp___0 ;
  long __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;

  {
#line 775
  writecount = 0;
#line 776
  total = (sf_count_t )0;
#line 779
  if (psf->codec_data == (void *)0) {
#line 780
    return ((sf_count_t )0);
  }
#line 781
  ppaf24 = (PAF24_PRIVATE *)psf->codec_data;
#line 783
  if (psf->norm_float == 1) {
#line 783
    tmp = 1. * (double )2147483647;
  } else {
#line 783
    tmp = 1. / (double )256;
  }
#line 783
  normfact = (float )tmp;
#line 785
  iptr = (int *)psf->u.ibuf;
#line 786
  bufferlen = (int )(sizeof(psf->u.ibuf) / sizeof(psf->u.ibuf[0]));
  {
#line 787
  while (1) {
    while_continue: /* CIL Label */ ;
#line 787
    if (! (len > 0L)) {
#line 787
      goto while_break;
    }
#line 788
    if (len >= (long )bufferlen) {
#line 788
      tmp___0 = (long )bufferlen;
    } else {
#line 788
      tmp___0 = len;
    }
#line 788
    writecount = (int )tmp___0;
#line 789
    k = 0;
    {
#line 789
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 789
      if (! (k < writecount)) {
#line 789
        goto while_break___0;
      }
      {
#line 790
      __cil_tmp14 = lrintf(normfact * *(ptr + (total + (long )k)));
#line 790
      *(iptr + k) = (int )__cil_tmp14;
      }
#line 789
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 791
    count = paf24_write(psf, ppaf24, (int const   *)iptr, writecount);
#line 792
    total += (long )count;
#line 793
    len -= (long )writecount;
    }
#line 794
    if (count != writecount) {
#line 795
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 798
  return (total);
}
}
#line 802 "/root/libsndfile/src/paf.c"
static sf_count_t paf24_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  PAF24_PRIVATE *ppaf24 ;
  int *iptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  long tmp___0 ;
  long __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;

  {
#line 805
  writecount = 0;
#line 806
  total = (sf_count_t )0;
#line 809
  if (psf->codec_data == (void *)0) {
#line 810
    return ((sf_count_t )0);
  }
#line 811
  ppaf24 = (PAF24_PRIVATE *)psf->codec_data;
#line 813
  if (psf->norm_double == 1) {
#line 813
    tmp = 1. * (double )2147483647;
  } else {
#line 813
    tmp = 1. / (double )256;
  }
#line 813
  normfact = tmp;
#line 815
  iptr = (int *)psf->u.ibuf;
#line 816
  bufferlen = (int )(sizeof(psf->u.ibuf) / sizeof(psf->u.ibuf[0]));
  {
#line 817
  while (1) {
    while_continue: /* CIL Label */ ;
#line 817
    if (! (len > 0L)) {
#line 817
      goto while_break;
    }
#line 818
    if (len >= (long )bufferlen) {
#line 818
      tmp___0 = (long )bufferlen;
    } else {
#line 818
      tmp___0 = len;
    }
#line 818
    writecount = (int )tmp___0;
#line 819
    k = 0;
    {
#line 819
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 819
      if (! (k < writecount)) {
#line 819
        goto while_break___0;
      }
      {
#line 820
      __cil_tmp14 = lrint(normfact * *(ptr + (total + (long )k)));
#line 820
      *(iptr + k) = (int )__cil_tmp14;
      }
#line 819
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 821
    count = paf24_write(psf, ppaf24, (int const   *)iptr, writecount);
#line 822
    total += (long )count;
#line 823
    len -= (long )writecount;
    }
#line 824
    if (count != writecount) {
#line 825
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 828
  return (total);
}
}
#line 290 "/usr/include/inttypes.h"
extern  __attribute__((__nothrow__)) intmax_t imaxabs(intmax_t __n ) ;
#line 293
extern  __attribute__((__nothrow__)) imaxdiv_t imaxdiv(intmax_t __numer , intmax_t __denom ) ;
#line 297
__inline extern  __attribute__((__nothrow__)) intmax_t strtoimax(char const   *nptr ,
                                                                 char **endptr , int base )  __attribute__((__gnu_inline__)) ;
#line 301
__inline extern  __attribute__((__nothrow__)) uintmax_t strtoumax(char const   *nptr ,
                                                                  char **endptr ,
                                                                  int base )  __attribute__((__gnu_inline__)) ;
#line 305
__inline extern  __attribute__((__nothrow__)) intmax_t wcstoimax(__gwchar_t *nptr ,
                                                                 __gwchar_t **endptr ,
                                                                 int base )  __attribute__((__gnu_inline__)) ;
#line 310
__inline extern  __attribute__((__nothrow__)) uintmax_t wcstoumax(__gwchar_t *nptr ,
                                                                  __gwchar_t **endptr ,
                                                                  int base )  __attribute__((__gnu_inline__)) ;
#line 318
extern  __attribute__((__nothrow__)) long __strtol_internal(char const   *__nptr ,
                                                            char **__endptr , int __base ,
                                                            int __group ) ;
#line 324
__inline extern  __attribute__((__nothrow__)) intmax_t strtoimax(char const   *nptr ,
                                                                 char **endptr , int base )  __attribute__((__gnu_inline__)) ;
#line 324 "/usr/include/inttypes.h"
__inline extern intmax_t strtoimax(char const   *nptr , char **endptr , int base ) 
{ 
  long __cil_tmp4 ;

  {
  {
#line 327
  __cil_tmp4 = __strtol_internal(nptr, endptr, base, 0);
  }
#line 327
  return (__cil_tmp4);
}
}
#line 330
extern  __attribute__((__nothrow__)) unsigned long __strtoul_internal(char const   *__nptr ,
                                                                      char **__endptr ,
                                                                      int __base ,
                                                                      int __group ) ;
#line 336
__inline extern  __attribute__((__nothrow__)) uintmax_t strtoumax(char const   *nptr ,
                                                                  char **endptr ,
                                                                  int base )  __attribute__((__gnu_inline__)) ;
#line 336 "/usr/include/inttypes.h"
__inline extern uintmax_t strtoumax(char const   *nptr , char **endptr , int base ) 
{ 
  unsigned long __cil_tmp4 ;

  {
  {
#line 339
  __cil_tmp4 = __strtoul_internal(nptr, endptr, base, 0);
  }
#line 339
  return (__cil_tmp4);
}
}
#line 342
extern  __attribute__((__nothrow__)) long __wcstol_internal(__gwchar_t *__nptr , __gwchar_t **__endptr ,
                                                            int __base , int __group ) ;
#line 348
__inline extern  __attribute__((__nothrow__)) intmax_t wcstoimax(__gwchar_t *nptr ,
                                                                 __gwchar_t **endptr ,
                                                                 int base )  __attribute__((__gnu_inline__)) ;
#line 348 "/usr/include/inttypes.h"
__inline extern intmax_t wcstoimax(__gwchar_t *nptr , __gwchar_t **endptr , int base ) 
{ 
  long __cil_tmp4 ;

  {
  {
#line 351
  __cil_tmp4 = __wcstol_internal(nptr, endptr, base, 0);
  }
#line 351
  return (__cil_tmp4);
}
}
#line 354
extern  __attribute__((__nothrow__)) unsigned long __wcstoul_internal(__gwchar_t *__nptr ,
                                                                      __gwchar_t **__endptr ,
                                                                      int __base ,
                                                                      int __group ) ;
#line 362
__inline extern  __attribute__((__nothrow__)) uintmax_t wcstoumax(__gwchar_t *nptr ,
                                                                  __gwchar_t **endptr ,
                                                                  int base )  __attribute__((__gnu_inline__)) ;
#line 362 "/usr/include/inttypes.h"
__inline extern uintmax_t wcstoumax(__gwchar_t *nptr , __gwchar_t **endptr , int base ) 
{ 
  unsigned long __cil_tmp4 ;

  {
  {
#line 365
  __cil_tmp4 = __wcstoul_internal(nptr, endptr, base, 0);
  }
#line 365
  return (__cil_tmp4);
}
}
#line 117 "/usr/include/ogg/ogg.h"
extern void oggpack_writeinit(oggpack_buffer *b ) ;
#line 118
extern int oggpack_writecheck(oggpack_buffer *b ) ;
#line 119
extern void oggpack_writetrunc(oggpack_buffer *b , long bits ) ;
#line 120
extern void oggpack_writealign(oggpack_buffer *b ) ;
#line 121
extern void oggpack_writecopy(oggpack_buffer *b , void *source , long bits ) ;
#line 122
extern void oggpack_reset(oggpack_buffer *b ) ;
#line 123
extern void oggpack_writeclear(oggpack_buffer *b ) ;
#line 124
extern void oggpack_readinit(oggpack_buffer *b , unsigned char *buf , int bytes ) ;
#line 125
extern void oggpack_write(oggpack_buffer *b , unsigned long value , int bits ) ;
#line 126
extern long oggpack_look(oggpack_buffer *b , int bits ) ;
#line 127
extern long oggpack_look1(oggpack_buffer *b ) ;
#line 128
extern void oggpack_adv(oggpack_buffer *b , int bits ) ;
#line 129
extern void oggpack_adv1(oggpack_buffer *b ) ;
#line 130
extern long oggpack_read(oggpack_buffer *b , int bits ) ;
#line 131
extern long oggpack_read1(oggpack_buffer *b ) ;
#line 132
extern long oggpack_bytes(oggpack_buffer *b ) ;
#line 133
extern long oggpack_bits(oggpack_buffer *b ) ;
#line 134
extern unsigned char *oggpack_get_buffer(oggpack_buffer *b ) ;
#line 136
extern void oggpackB_writeinit(oggpack_buffer *b ) ;
#line 137
extern int oggpackB_writecheck(oggpack_buffer *b ) ;
#line 138
extern void oggpackB_writetrunc(oggpack_buffer *b , long bits ) ;
#line 139
extern void oggpackB_writealign(oggpack_buffer *b ) ;
#line 140
extern void oggpackB_writecopy(oggpack_buffer *b , void *source , long bits ) ;
#line 141
extern void oggpackB_reset(oggpack_buffer *b ) ;
#line 142
extern void oggpackB_writeclear(oggpack_buffer *b ) ;
#line 143
extern void oggpackB_readinit(oggpack_buffer *b , unsigned char *buf , int bytes ) ;
#line 144
extern void oggpackB_write(oggpack_buffer *b , unsigned long value , int bits ) ;
#line 145
extern long oggpackB_look(oggpack_buffer *b , int bits ) ;
#line 146
extern long oggpackB_look1(oggpack_buffer *b ) ;
#line 147
extern void oggpackB_adv(oggpack_buffer *b , int bits ) ;
#line 148
extern void oggpackB_adv1(oggpack_buffer *b ) ;
#line 149
extern long oggpackB_read(oggpack_buffer *b , int bits ) ;
#line 150
extern long oggpackB_read1(oggpack_buffer *b ) ;
#line 151
extern long oggpackB_bytes(oggpack_buffer *b ) ;
#line 152
extern long oggpackB_bits(oggpack_buffer *b ) ;
#line 153
extern unsigned char *oggpackB_get_buffer(oggpack_buffer *b ) ;
#line 157
extern int ogg_stream_packetin(ogg_stream_state *os , ogg_packet *op ) ;
#line 158
extern int ogg_stream_iovecin(ogg_stream_state *os , ogg_iovec_t *iov , int count ,
                              long e_o_s , ogg_int64_t granulepos ) ;
#line 160
extern int ogg_stream_pageout(ogg_stream_state *os , ogg_page *og ) ;
#line 161
extern int ogg_stream_pageout_fill(ogg_stream_state *os , ogg_page *og , int nfill ) ;
#line 162
extern int ogg_stream_flush(ogg_stream_state *os , ogg_page *og ) ;
#line 163
extern int ogg_stream_flush_fill(ogg_stream_state *os , ogg_page *og , int nfill ) ;
#line 167
extern int ogg_sync_init(ogg_sync_state *oy ) ;
#line 168
extern int ogg_sync_clear(ogg_sync_state *oy ) ;
#line 169
extern int ogg_sync_reset(ogg_sync_state *oy ) ;
#line 170
extern int ogg_sync_destroy(ogg_sync_state *oy ) ;
#line 171
extern int ogg_sync_check(ogg_sync_state *oy ) ;
#line 173
extern char *ogg_sync_buffer(ogg_sync_state *oy , long size ) ;
#line 174
extern int ogg_sync_wrote(ogg_sync_state *oy , long bytes ) ;
#line 175
extern long ogg_sync_pageseek(ogg_sync_state *oy , ogg_page *og ) ;
#line 176
extern int ogg_sync_pageout(ogg_sync_state *oy , ogg_page *og ) ;
#line 177
extern int ogg_stream_pagein(ogg_stream_state *os , ogg_page *og ) ;
#line 178
extern int ogg_stream_packetout(ogg_stream_state *os , ogg_packet *op ) ;
#line 179
extern int ogg_stream_packetpeek(ogg_stream_state *os , ogg_packet *op ) ;
#line 183
extern int ogg_stream_init(ogg_stream_state *os , int serialno ) ;
#line 184
extern int ogg_stream_clear(ogg_stream_state *os ) ;
#line 185
extern int ogg_stream_reset(ogg_stream_state *os ) ;
#line 186
extern int ogg_stream_reset_serialno(ogg_stream_state *os , int serialno ) ;
#line 187
extern int ogg_stream_destroy(ogg_stream_state *os ) ;
#line 188
extern int ogg_stream_check(ogg_stream_state *os ) ;
#line 189
extern int ogg_stream_eos(ogg_stream_state *os ) ;
#line 191
extern void ogg_page_checksum_set(ogg_page *og ) ;
#line 193
extern int ogg_page_version(ogg_page *og ) ;
#line 194
extern int ogg_page_continued(ogg_page *og ) ;
#line 195
extern int ogg_page_bos(ogg_page *og ) ;
#line 196
extern int ogg_page_eos(ogg_page *og ) ;
#line 197
extern ogg_int64_t ogg_page_granulepos(ogg_page *og ) ;
#line 198
extern int ogg_page_serialno(ogg_page *og ) ;
#line 199
extern long ogg_page_pageno(ogg_page *og ) ;
#line 200
extern int ogg_page_packets(ogg_page *og ) ;
#line 202
extern void ogg_packet_clear(ogg_packet *op ) ;
#line 164 "/usr/include/vorbis/codec.h"
extern void vorbis_info_init(vorbis_info *vi ) ;
#line 165
extern void vorbis_info_clear(vorbis_info *vi ) ;
#line 166
extern int vorbis_info_blocksize(vorbis_info *vi , int zo ) ;
#line 167
extern void vorbis_comment_init(vorbis_comment *vc ) ;
#line 168
extern void vorbis_comment_add(vorbis_comment *vc , char const   *comment ) ;
#line 169
extern void vorbis_comment_add_tag(vorbis_comment *vc , char const   *tag , char const   *contents ) ;
#line 171
extern char *vorbis_comment_query(vorbis_comment *vc , char const   *tag , int count ) ;
#line 172
extern int vorbis_comment_query_count(vorbis_comment *vc , char const   *tag ) ;
#line 173
extern void vorbis_comment_clear(vorbis_comment *vc ) ;
#line 175
extern int vorbis_block_init(vorbis_dsp_state *v , vorbis_block *vb ) ;
#line 176
extern int vorbis_block_clear(vorbis_block *vb ) ;
#line 177
extern void vorbis_dsp_clear(vorbis_dsp_state *v ) ;
#line 178
extern double vorbis_granule_time(vorbis_dsp_state *v , ogg_int64_t granulepos ) ;
#line 181
extern char const   *vorbis_version_string(void) ;
#line 185
extern int vorbis_analysis_init(vorbis_dsp_state *v , vorbis_info *vi ) ;
#line 186
extern int vorbis_commentheader_out(vorbis_comment *vc , ogg_packet *op ) ;
#line 187
extern int vorbis_analysis_headerout(vorbis_dsp_state *v , vorbis_comment *vc , ogg_packet *op ,
                                     ogg_packet *op_comm , ogg_packet *op_code ) ;
#line 192
extern float **vorbis_analysis_buffer(vorbis_dsp_state *v , int vals ) ;
#line 193
extern int vorbis_analysis_wrote(vorbis_dsp_state *v , int vals ) ;
#line 194
extern int vorbis_analysis_blockout(vorbis_dsp_state *v , vorbis_block *vb ) ;
#line 195
extern int vorbis_analysis(vorbis_block *vb , ogg_packet *op ) ;
#line 197
extern int vorbis_bitrate_addblock(vorbis_block *vb ) ;
#line 198
extern int vorbis_bitrate_flushpacket(vorbis_dsp_state *vd , ogg_packet *op ) ;
#line 202
extern int vorbis_synthesis_idheader(ogg_packet *op ) ;
#line 203
extern int vorbis_synthesis_headerin(vorbis_info *vi , vorbis_comment *vc , ogg_packet *op ) ;
#line 206
extern int vorbis_synthesis_init(vorbis_dsp_state *v , vorbis_info *vi ) ;
#line 207
extern int vorbis_synthesis_restart(vorbis_dsp_state *v ) ;
#line 208
extern int vorbis_synthesis(vorbis_block *vb , ogg_packet *op ) ;
#line 209
extern int vorbis_synthesis_trackonly(vorbis_block *vb , ogg_packet *op ) ;
#line 210
extern int vorbis_synthesis_blockin(vorbis_dsp_state *v , vorbis_block *vb ) ;
#line 211
extern int vorbis_synthesis_pcmout(vorbis_dsp_state *v , float ***pcm ) ;
#line 212
extern int vorbis_synthesis_lapout(vorbis_dsp_state *v , float ***pcm ) ;
#line 213
extern int vorbis_synthesis_read(vorbis_dsp_state *v , int samples ) ;
#line 214
extern long vorbis_packet_blocksize(vorbis_info *vi , ogg_packet *op ) ;
#line 216
extern int vorbis_synthesis_halfrate(vorbis_info *v , int flag ) ;
#line 217
extern int vorbis_synthesis_halfrate_p(vorbis_info *v ) ;
#line 59 "/usr/include/vorbis/vorbisenc.h"
extern int vorbis_encode_init(vorbis_info *vi , long channels , long rate , long max_bitrate ,
                              long nominal_bitrate , long min_bitrate ) ;
#line 96
extern int vorbis_encode_setup_managed(vorbis_info *vi , long channels , long rate ,
                                       long max_bitrate , long nominal_bitrate , long min_bitrate ) ;
#line 128
extern int vorbis_encode_setup_vbr(vorbis_info *vi , long channels , long rate , float quality ) ;
#line 157
extern int vorbis_encode_init_vbr(vorbis_info *vi , long channels , long rate , float base_quality ) ;
#line 191
extern int vorbis_encode_setup_init(vorbis_info *vi ) ;
#line 219
extern int vorbis_encode_ctl(vorbis_info *vi , int number , void *arg ) ;
#line 77 "/root/libsndfile/src/ogg.c"
static int ogg_read_header(SF_PRIVATE *psf , int log_data ) ;
#line 78
static int ogg_write_header(SF_PRIVATE *psf , int UNUSED_calc_length ) ;
#line 79
static int ogg_close(SF_PRIVATE *psf ) ;
#line 80
static int ogg_command(SF_PRIVATE *psf , int command , void *data___0 , int datasize ) ;
#line 81
static sf_count_t ogg_seek(SF_PRIVATE *psf , int UNUSED_mode , sf_count_t offset ) ;
#line 82
static sf_count_t ogg_read_s(SF_PRIVATE *psf , short *ptr , sf_count_t lens ) ;
#line 83
static sf_count_t ogg_read_i(SF_PRIVATE *psf , int *ptr , sf_count_t lens ) ;
#line 84
static sf_count_t ogg_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t lens ) ;
#line 85
static sf_count_t ogg_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t lens ) ;
#line 86
static sf_count_t ogg_write_s(SF_PRIVATE *psf , short const   *ptr , sf_count_t lens ) ;
#line 87
static sf_count_t ogg_write_i(SF_PRIVATE *psf , int const   *ptr , sf_count_t lens ) ;
#line 88
static sf_count_t ogg_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t lens ) ;
#line 89
static sf_count_t ogg_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t lens ) ;
#line 90
static sf_count_t ogg_read_sample(SF_PRIVATE *psf , void *ptr , sf_count_t lens ,
                                  convert_func *transfn ) ;
#line 91
static sf_count_t ogg_length(SF_PRIVATE *psf ) ;
#line 98 "/root/libsndfile/src/ogg.c"
static STR_PAIRS vorbis_metatypes[8]  = 
#line 98
  {      {1, "Title"}, 
        {2, "Copyright"}, 
        {3, "Software\250"}, 
        {4, "Artist"}, 
        {5, "Comment"}, 
        {6, "Date"}, 
        {7, "Album"}, 
        {8, "License"}};
#line 138 "/root/libsndfile/src/ogg.c"
static int ogg_read_header(SF_PRIVATE *psf , int log_data ) 
{ 
  OGG_PRIVATE *odata ;
  VORBIS_PRIVATE *vdata ;
  char *buffer ;
  int bytes ;
  int i ;
  int nn ;
  char *__cil_tmp9 ;
  sf_count_t __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int k ;
  char *dd ;
  char *__cil_tmp18 ;
  int __cil_tmp19 ;
  int result ;
  int __cil_tmp21 ;
  char *__cil_tmp22 ;
  sf_count_t __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int printed_metadata_msg ;
  int k___0 ;
  char *dd___0 ;
  char *__cil_tmp31 ;
  int __cil_tmp32 ;

  {
  {
#line 140
  odata = (OGG_PRIVATE *)psf->container_data;
#line 141
  vdata = (VORBIS_PRIVATE *)psf->codec_data;
#line 146
  odata->eos = 0;
#line 149
  ogg_stream_reset(& odata->os);
#line 150
  ogg_sync_reset(& odata->oy);
#line 160
  buffer = ogg_sync_buffer(& odata->oy, 4096L);
#line 163
  memcpy(buffer, (unsigned char *)psf->header, (unsigned long )psf->headindex);
#line 164
  bytes = psf->headindex;
#line 167
  __cil_tmp10 = psf_fread(buffer + psf->headindex, (sf_count_t )1, (sf_count_t )(4096 - psf->headindex),
                          psf);
  }
  {
#line 167
  bytes += __cil_tmp10;
#line 168
  ogg_sync_wrote(& odata->oy, (long )bytes);
#line 171
  nn = ogg_sync_pageout(& odata->oy, & odata->og);
  }
#line 171
  if (nn != 1) {
#line 174
    if (bytes < 4096) {
#line 175
      return (0);
    }
    {
#line 178
    psf_log_printf(psf, "Input does not appear to be an Ogg bitstream.\n");
    }
#line 179
    return (3);
  }
  {
#line 186
  ogg_stream_clear(& odata->os);
#line 187
  __cil_tmp12 = ogg_page_serialno(& odata->og);
#line 187
  ogg_stream_init(& odata->os, __cil_tmp12);
#line 194
  vorbis_block_clear(& vdata->vb);
#line 195
  vorbis_dsp_clear(& vdata->vd);
#line 196
  vorbis_comment_clear(& vdata->vc);
#line 197
  vorbis_info_clear(& vdata->vi);
#line 208
  vorbis_info_init(& vdata->vi);
#line 209
  vorbis_comment_init(& vdata->vc);
#line 211
  __cil_tmp13 = ogg_stream_pagein(& odata->os, & odata->og);
  }
#line 211
  if (__cil_tmp13 < 0) {
    {
#line 213
    psf_log_printf(psf, "Error reading first page of Ogg bitstream data\n");
    }
#line 214
    return (3);
  }
  {
#line 217
  __cil_tmp14 = ogg_stream_packetout(& odata->os, & odata->op);
  }
#line 217
  if (__cil_tmp14 != 1) {
    {
#line 219
    psf_log_printf(psf, "Error reading initial header packet.\n");
    }
#line 220
    return (3);
  }
  {
#line 223
  __cil_tmp15 = vorbis_synthesis_headerin(& vdata->vi, & vdata->vc, & odata->op);
  }
#line 223
  if (__cil_tmp15 < 0) {
    {
#line 225
    psf_log_printf(psf, "This Ogg bitstream does not contain Vorbis audio data.\n");
    }
#line 226
    return (3);
  }

#line 235
  if (log_data) {
#line 238
    k = 0;
    {
#line 238
    while (1) {
      while_continue: /* CIL Label */ ;
#line 238
      if (! (k < (int )(sizeof(vorbis_metatypes) / sizeof(vorbis_metatypes[0])))) {
#line 238
        goto while_break;
      }
      {
#line 241
      dd = vorbis_comment_query(& vdata->vc, vorbis_metatypes[k].name, 0);
      }
#line 242
      if (dd == (void *)0) {
#line 243
        goto while_continue;
      }
      {
#line 244
      psf_store_string(psf, vorbis_metatypes[k].id, (char const   *)dd);
      }
#line 238
      k ++;
    }
    while_break: /* CIL Label */ ;
    }

  }
#line 260
  i = 0;
  {
#line 261
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 261
    if (! (i < 2)) {
#line 261
      goto while_break___0;
    }
    {
#line 262
    __cil_tmp21 = ogg_sync_pageout(& odata->oy, & odata->og);
#line 262
    result = __cil_tmp21;
    }
#line 263
    if (result == 0) {
      {
#line 265
      buffer = ogg_sync_buffer(& odata->oy, (long )4096);
#line 266
      __cil_tmp23 = psf_fread(buffer, (sf_count_t )1, (sf_count_t )4096, psf);
#line 266
      bytes = (int )__cil_tmp23;
      }
#line 268
      if (bytes == 0) {
#line 268
        if (i < 2) {
          {
#line 269
          psf_log_printf(psf, "End of file before finding all Vorbis headers!\n");
          }
#line 270
          return (3);
        }
      }
      {
#line 272
      nn = ogg_sync_wrote(& odata->oy, (long )bytes);
      }
    } else
#line 274
    if (result == 1) {
      {
#line 282
      nn = ogg_stream_pagein(& odata->os, & odata->og);
      }
      {
#line 283
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 283
        if (! (i < 2)) {
#line 283
          goto while_break___1;
        }
        {
#line 284
        result = ogg_stream_packetout(& odata->os, & odata->op);
        }
#line 285
        if (result == 0) {
#line 286
          goto while_break___1;
        }
#line 287
        if (result < 0) {
          {
#line 290
          psf_log_printf(psf, "Corrupt secondary header.\tExiting.\n");
          }
#line 291
          return (3);
        }
        {
#line 294
        vorbis_synthesis_headerin(& vdata->vi, & vdata->vc, & odata->op);
#line 295
        i ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }

    }

  }
  while_break___0: /* CIL Label */ ;
  }

#line 300
  if (log_data) {
    {
#line 301
    printed_metadata_msg = 0;
#line 304
    psf_log_printf(psf, "\nBitstream is %d channel, %D Hz\n\230\001", vdata->vi.channels,
                   vdata->vi.rate);
#line 305
    psf_log_printf(psf, "Encoded by: %s\n", vdata->vc.vendor);
#line 308
    k___0 = 0;
    }
    {
#line 308
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 308
      if (! (k___0 < (int )(sizeof(vorbis_metatypes) / sizeof(vorbis_metatypes[0])))) {
#line 308
        goto while_break___2;
      }
      {
#line 311
      dd___0 = vorbis_comment_query(& vdata->vc, vorbis_metatypes[k___0].name, 0);
      }
#line 312
      if (dd___0 == (void *)0) {
#line 313
        goto while_continue___2;
      }
#line 315
      if (printed_metadata_msg == 0) {
        {
#line 316
        psf_log_printf(psf, "Metadata :\n");
#line 317
        printed_metadata_msg = 1;
        }
      }
      {
#line 320
      psf_store_string(psf, vorbis_metatypes[k___0].id, (char const   *)dd___0);
#line 321
      psf_log_printf(psf, "  %-10s : %s\n", vorbis_metatypes[k___0].name, dd___0);
      }
#line 308
      k___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 324
    psf_log_printf(psf, "End\n");
    }
  }
  {
#line 327
  psf->sf.samplerate = (int )vdata->vi.rate;
#line 328
  psf->sf.channels = vdata->vi.channels;
#line 329
  psf->sf.format = 2097248;
#line 334
  vorbis_synthesis_init(& vdata->vd, & vdata->vi);
#line 339
  vorbis_block_init(& vdata->vd, & vdata->vb);
#line 341
  vdata->loc = (sf_count_t )0;
  }
#line 343
  return (0);
}
}
#line 347 "/root/libsndfile/src/ogg.c"
static int ogg_write_header(SF_PRIVATE *psf , int UNUSED_calc_length ) 
{ 
  OGG_PRIVATE *odata ;
  VORBIS_PRIVATE *vdata ;
  int k ;
  int ret ;
  int __cil_tmp7 ;
  char const   *name ;
  int __cil_tmp9 ;
  int32_t __cil_tmp10 ;
  ogg_packet header ;
  ogg_packet header_comm ;
  ogg_packet header_code ;
  int result ;
  int __cil_tmp15 ;

  {
  {
#line 349
  odata = (OGG_PRIVATE *)psf->container_data;
#line 350
  vdata = (VORBIS_PRIVATE *)psf->codec_data;
#line 353
  vorbis_info_init(& vdata->vi);
#line 356
  ret = vorbis_encode_init_vbr(& vdata->vi, (long )psf->sf.channels, (long )psf->sf.samplerate,
                               (float )vdata->quality);
  }
#line 365
  if (ret) {
#line 366
    return (1);
  }
  {
#line 368
  vdata->loc = (sf_count_t )0;
#line 371
  vorbis_comment_init(& vdata->vc);
#line 373
  vorbis_comment_add_tag(& vdata->vc, "ENCODER", "libsndfile");
#line 374
  k = 0;
  }
  {
#line 374
  while (1) {
    while_continue: /* CIL Label */ ;
#line 374
    if (! (k < 32)) {
#line 374
      goto while_break;
    }
#line 377
    if (psf->strings[k].type == 0) {
#line 378
      goto while_break;
    }
    {
#line 381
    if (psf->strings[k].type == 1) {
#line 381
      goto case_1;
    }
#line 382
    if (psf->strings[k].type == 2) {
#line 382
      goto case_2;
    }
#line 383
    if (psf->strings[k].type == 3) {
#line 383
      goto case_3;
    }
#line 384
    if (psf->strings[k].type == 4) {
#line 384
      goto case_4;
    }
#line 385
    if (psf->strings[k].type == 5) {
#line 385
      goto case_5;
    }
#line 386
    if (psf->strings[k].type == 6) {
#line 386
      goto case_6;
    }
#line 387
    if (psf->strings[k].type == 7) {
#line 387
      goto case_7;
    }
#line 388
    if (psf->strings[k].type == 8) {
#line 388
      goto case_8;
    }
#line 389
    goto switch_default;
    case_1: /* CIL Label */ 
#line 381
    name = "TITLE";
#line 381
    goto switch_break;
    case_2: /* CIL Label */ 
#line 382
    name = "COPYRIGHT";
#line 382
    goto switch_break;
    case_3: /* CIL Label */ 
#line 383
    name = "SOFTWARE\220";
#line 383
    goto switch_break;
    case_4: /* CIL Label */ 
#line 384
    name = "ARTIST";
#line 384
    goto switch_break;
    case_5: /* CIL Label */ 
#line 385
    name = "COMMENT";
#line 385
    goto switch_break;
    case_6: /* CIL Label */ 
#line 386
    name = "DATE";
#line 386
    goto switch_break;
    case_7: /* CIL Label */ 
#line 387
    name = "ALBUM";
#line 387
    goto switch_break;
    case_8: /* CIL Label */ 
#line 388
    name = "LICENSE";
#line 388
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 389
    goto while_continue;
    switch_break: /* CIL Label */ ;
    }
    {
#line 392
    vorbis_comment_add_tag(& vdata->vc, name, (char const   *)psf->strings[k].str);
    }
#line 374
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 396
  vorbis_analysis_init(& vdata->vd, & vdata->vi);
#line 397
  vorbis_block_init(& vdata->vd, & vdata->vb);
#line 405
  __cil_tmp10 = psf_rand_int32();
#line 405
  ogg_stream_init(& odata->os, __cil_tmp10);
#line 419
  vorbis_analysis_headerout(& vdata->vd, & vdata->vc, & header, & header_comm, & header_code);
#line 420
  ogg_stream_packetin(& odata->os, & header);
#line 421
  ogg_stream_packetin(& odata->os, & header_comm);
#line 422
  ogg_stream_packetin(& odata->os, & header_code);
  }
  {
#line 427
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 427
    result = ogg_stream_flush(& odata->os, & odata->og);
    }
#line 427
    if (! (result != 0)) {
#line 427
      goto while_break___0;
    }
    {
#line 428
    psf_fwrite(odata->og.header, (sf_count_t )1, odata->og.header_len, psf);
#line 429
    psf_fwrite(odata->og.body, (sf_count_t )1, odata->og.body_len, psf);
    }
  }
  while_break___0: /* CIL Label */ ;
  }

#line 433
  return (0);
}
}
#line 437 "/root/libsndfile/src/ogg.c"
static int ogg_close(SF_PRIVATE *psf ) 
{ 
  OGG_PRIVATE *odata ;
  VORBIS_PRIVATE *vdata ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int result ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
#line 439
  odata = (OGG_PRIVATE *)psf->container_data;
#line 440
  vdata = (VORBIS_PRIVATE *)psf->codec_data;
#line 442
  if (odata == (void *)0) {
#line 443
    return (0);
  } else
#line 442
  if (vdata == (void *)0) {
#line 443
    return (0);
  }
#line 448
  if (psf->mode == 32) {
#line 450
    if (psf->write_current <= 0L) {
      {
#line 451
      ogg_write_header(psf, 0);
      }
    }
    {
#line 453
    vorbis_analysis_wrote(& vdata->vd, 0);
    }
    {
#line 454
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 454
      __cil_tmp4 = vorbis_analysis_blockout(& vdata->vd, & vdata->vb);
      }
#line 454
      if (! (__cil_tmp4 == 1)) {
#line 454
        goto while_break;
      }
      {
#line 458
      vorbis_analysis(& vdata->vb, (ogg_packet *)((void *)0));
#line 459
      vorbis_bitrate_addblock(& vdata->vb);
      }
      {
#line 461
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 461
        __cil_tmp5 = vorbis_bitrate_flushpacket(& vdata->vd, & odata->op);
        }
#line 461
        if (! __cil_tmp5) {
#line 461
          goto while_break___0;
        }
        {
#line 463
        ogg_stream_packetin(& odata->os, & odata->op);
        }
        {
#line 466
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 466
          if (! (! odata->eos)) {
#line 466
            goto while_break___1;
          }
          {
#line 467
          __cil_tmp7 = ogg_stream_pageout(& odata->os, & odata->og);
#line 467
          result = __cil_tmp7;
          }
#line 468
          if (result == 0) {
#line 468
            goto while_break___1;
          }
          {
#line 469
          psf_fwrite(odata->og.header, (sf_count_t )1, odata->og.header_len, psf);
#line 470
          psf_fwrite(odata->og.body, (sf_count_t )1, odata->og.body_len, psf);
#line 475
          __cil_tmp8 = ogg_page_eos(& odata->og);
          }
#line 475
          if (__cil_tmp8) {
#line 475
            odata->eos = 1;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 484
  vorbis_block_clear(& vdata->vb);
#line 485
  vorbis_dsp_clear(& vdata->vd);
#line 486
  vorbis_comment_clear(& vdata->vc);
#line 487
  vorbis_info_clear(& vdata->vi);
#line 491
  ogg_sync_clear(& odata->oy);
#line 492
  ogg_stream_clear(& odata->os);
  }
#line 494
  return (0);
}
}
#line 498 "/root/libsndfile/src/ogg.c"
int ogg_open(SF_PRIVATE *psf ) 
{ 
  OGG_PRIVATE *odata ;
  void *__cil_tmp3 ;
  VORBIS_PRIVATE *vdata ;
  void *__cil_tmp5 ;
  int error ;
  char const   *__cil_tmp7 ;
  int __cil_tmp8 ;
  sf_count_t __cil_tmp9 ;

  {
  {
#line 499
  __cil_tmp3 = calloc((unsigned long )1, sizeof(OGG_PRIVATE ));
#line 499
  odata = __cil_tmp3;
#line 500
  __cil_tmp5 = calloc((unsigned long )1, sizeof(VORBIS_PRIVATE ));
#line 500
  vdata = __cil_tmp5;
#line 501
  error = 0;
#line 503
  psf->container_data = odata;
#line 504
  psf->codec_data = vdata;
  }
#line 506
  if (psf->mode == 48) {
#line 507
    return (23);
  }
  {
#line 510
  __cil_tmp7 = vorbis_version_string();
#line 510
  psf_log_printf(psf, "Vorbis library version : %s\n\036V", __cil_tmp7);
  }
#line 513
  if (psf->mode == 16) {
    {
#line 515
    ogg_sync_init(& odata->oy);
#line 517
    error = ogg_read_header(psf, 1);
    }
#line 517
    if (error) {
#line 518
      return (error);
    }
    {
#line 520
    psf->read_short = & ogg_read_s;
#line 521
    psf->read_int = & ogg_read_i;
#line 522
    psf->read_float = & ogg_read_f;
#line 523
    psf->read_double = & ogg_read_d;
#line 524
    psf->sf.frames = ogg_length(psf);
    }
  }
#line 527
  psf->container_close = & ogg_close;
#line 528
  if (psf->mode == 32) {
#line 531
    vdata->quality = 0.400000000001;
#line 533
    psf->write_header = & ogg_write_header;
#line 534
    psf->write_short = & ogg_write_s;
#line 535
    psf->write_int = & ogg_write_i;
#line 536
    psf->write_float = & ogg_write_f;
#line 537
    psf->write_double = & ogg_write_d;
#line 539
    psf->sf.frames = (sf_count_t )-1LL;
#line 540
    psf->str_flags = 256;
  }
#line 543
  psf->bytewidth = 1;
#line 544
  psf->blockwidth = psf->bytewidth * psf->sf.channels;
#line 546
  psf->seek = & ogg_seek;
#line 547
  psf->command = & ogg_command;
#line 550
  psf->sf.format = 2097248;
#line 551
  psf->sf.sections = 1;
#line 553
  psf->datalength = (sf_count_t )1;
#line 554
  psf->dataoffset = (sf_count_t )0;
#line 557
  return (error);
}
}
#line 561 "/root/libsndfile/src/ogg.c"
static int ogg_command(SF_PRIVATE *psf , int command , void *data___0 , int datasize ) 
{ 
  VORBIS_PRIVATE *vdata ;

  {
#line 562
  vdata = (VORBIS_PRIVATE *)psf->codec_data;
  {
#line 565
  if (command == 4864) {
#line 565
    goto case_4864;
  }
#line 580
  goto switch_default;
  case_4864: /* CIL Label */ 
#line 566
  if (data___0 == (void *)0) {
#line 567
    return (1);
  } else
#line 566
  if ((unsigned long )datasize != sizeof(double )) {
#line 567
    return (1);
  }
#line 569
  if (psf->have_written) {
#line 570
    return (1);
  }
  {
#line 572
  vdata->quality = *((double *)data___0);
#line 575
  vdata->quality = 0;
#line 577
  psf_log_printf(psf, "%s : Setting SFC_SET_VBR_ENCODING_QUALITY to %f.\n\260P\374\036V",
                 "ogg_command", vdata->quality);
  }
#line 578
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 581
  return (0);
  switch_break: /* CIL Label */ ;
  }

#line 584
  return (0);
}
}
#line 588 "/root/libsndfile/src/ogg.c"
static int ogg_rnull(int samples , void *UNUSED_vptr , int UNUSED_off , int channels ,
                     float **UNUSED_pcm ) 
{ 


  {
#line 590
  return (samples * channels);
}
}
#line 594 "/root/libsndfile/src/ogg.c"
static int ogg_rshort(int samples , void *vptr , int off , int channels , float **pcm ) 
{ 
  short *ptr ;
  int i ;
  int j ;
  int n ;
  int __cil_tmp10 ;
  long __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;

  {
#line 596
  ptr = (short *)vptr + off;
#line 597
  i = 0;
#line 598
  j = 0;
  {
#line 598
  while (1) {
    while_continue: /* CIL Label */ ;
#line 598
    if (! (j < samples)) {
#line 598
      goto while_break;
    }
#line 599
    n = 0;
    {
#line 599
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 599
      if (! (n < channels)) {
#line 599
        goto while_break___0;
      }
      {
#line 600
      __cil_tmp11 = lrintf(*(*(pcm + n) + j) * 32767.f);
      }
#line 600
      __cil_tmp10 = i;
#line 600
      i ++;
#line 600
      *(ptr + __cil_tmp10) = (short )__cil_tmp11;
#line 599
      n ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 598
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 601
  return (i);
}
}
#line 605 "/root/libsndfile/src/ogg.c"
static int ogg_rint(int samples , void *vptr , int off , int channels , float **pcm ) 
{ 
  int *ptr ;
  int i ;
  int j ;
  int n ;
  int __cil_tmp10 ;
  long __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;

  {
#line 607
  ptr = (int *)vptr + off;
#line 608
  i = 0;
#line 610
  j = 0;
  {
#line 610
  while (1) {
    while_continue: /* CIL Label */ ;
#line 610
    if (! (j < samples)) {
#line 610
      goto while_break;
    }
#line 611
    n = 0;
    {
#line 611
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 611
      if (! (n < channels)) {
#line 611
        goto while_break___0;
      }
      {
#line 612
      __cil_tmp11 = lrintf(*(*(pcm + n) + j) * 2147483648.f);
      }
#line 612
      __cil_tmp10 = i;
#line 612
      i ++;
#line 612
      *(ptr + __cil_tmp10) = (int )__cil_tmp11;
#line 611
      n ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 610
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 613
  return (i);
}
}
#line 617 "/root/libsndfile/src/ogg.c"
static int ogg_rfloat(int samples , void *vptr , int off , int channels , float **pcm ) 
{ 
  float *ptr ;
  int i ;
  int j ;
  int n ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;

  {
#line 619
  ptr = (float *)vptr + off;
#line 620
  i = 0;
#line 621
  j = 0;
  {
#line 621
  while (1) {
    while_continue: /* CIL Label */ ;
#line 621
    if (! (j < samples)) {
#line 621
      goto while_break;
    }
#line 622
    n = 0;
    {
#line 622
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 622
      if (! (n < channels)) {
#line 622
        goto while_break___0;
      }
#line 623
      __cil_tmp10 = i;
#line 623
      i ++;
#line 623
      *(ptr + __cil_tmp10) = *(*(pcm + n) + j);
#line 622
      n ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 621
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 624
  return (i);
}
}
#line 628 "/root/libsndfile/src/ogg.c"
static int ogg_rdouble(int samples , void *vptr , int off , int channels , float **pcm ) 
{ 
  double *ptr ;
  int i ;
  int j ;
  int n ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;

  {
#line 630
  ptr = (double *)vptr + off;
#line 631
  i = 0;
#line 632
  j = 0;
  {
#line 632
  while (1) {
    while_continue: /* CIL Label */ ;
#line 632
    if (! (j < samples)) {
#line 632
      goto while_break;
    }
#line 633
    n = 0;
    {
#line 633
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 633
      if (! (n < channels)) {
#line 633
        goto while_break___0;
      }
#line 634
      __cil_tmp10 = i;
#line 634
      i ++;
#line 634
      *(ptr + __cil_tmp10) = (double )*(*(pcm + n) + j);
#line 633
      n ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 632
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 635
  return (i);
}
}
#line 640 "/root/libsndfile/src/ogg.c"
static sf_count_t ogg_read_sample(SF_PRIVATE *psf , void *ptr , sf_count_t lens ,
                                  convert_func *transfn ) 
{ 
  VORBIS_PRIVATE *vdata ;
  OGG_PRIVATE *odata ;
  int len ;
  int samples ;
  int i ;
  float **pcm ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int result ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  char *buffer ;
  int bytes ;
  char *__cil_tmp22 ;
  sf_count_t __cil_tmp23 ;

  {
#line 642
  vdata = psf->codec_data;
#line 643
  odata = psf->container_data;
#line 644
  i = 0;
#line 647
  len = (int )(lens / (long )psf->sf.channels);
  {
#line 649
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 649
    samples = vorbis_synthesis_pcmout(& vdata->vd, & pcm);
    }
#line 649
    if (! (samples > 0)) {
#line 649
      goto while_break;
    }
#line 650
    if (samples > len) {
#line 650
      samples = len;
    }
    {
#line 651
    __cil_tmp12 = (*transfn)(samples, ptr, i, psf->sf.channels, pcm);
    }
    {
#line 651
    i += __cil_tmp12;
#line 652
    len -= samples;
#line 654
    vorbis_synthesis_read(& vdata->vd, samples);
#line 655
    vdata->loc += (long )samples;
    }
#line 656
    if (len == 0) {
#line 657
      return ((sf_count_t )i);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 659
  goto start0;
  {
#line 660
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 660
    if (! (len > 0 && ! odata->eos)) {
#line 660
      goto while_break___0;
    }
    {
#line 662
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 662
      if (! (len > 0 && ! odata->eos)) {
#line 662
        goto while_break___1;
      }
      {
#line 663
      __cil_tmp14 = ogg_sync_pageout(& odata->oy, & odata->og);
#line 663
      result = __cil_tmp14;
      }
#line 664
      if (result == 0) {
#line 664
        goto while_break___1;
      }
#line 665
      if (result < 0) {
        {
#line 667
        psf_log_printf(psf, "Corrupt or missing data in bitstream ; continuing...\n");
        }
      } else {
        {
#line 671
        ogg_stream_pagein(& odata->os, & odata->og);
        }
        start0: 
        {
#line 673
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 674
          result = ogg_stream_packetout(& odata->os, & odata->op);
          }
#line 675
          if (result == 0) {
#line 676
            goto while_break___2;
          }
#line 677
          if (! (result < 0)) {
            {
#line 683
            __cil_tmp16 = vorbis_synthesis(& vdata->vb, & odata->op);
            }
#line 683
            if (__cil_tmp16 == 0) {
              {
#line 684
              vorbis_synthesis_blockin(& vdata->vd, & vdata->vb);
              }
            }
            {
#line 691
            while (1) {
              while_continue___3: /* CIL Label */ ;
              {
#line 691
              samples = vorbis_synthesis_pcmout(& vdata->vd, & pcm);
              }
#line 691
              if (! (samples > 0)) {
#line 691
                goto while_break___3;
              }
#line 692
              if (samples > len) {
#line 692
                samples = len;
              }
              {
#line 693
              __cil_tmp18 = (*transfn)(samples, ptr, i, psf->sf.channels, pcm);
              }
              {
#line 693
              i += __cil_tmp18;
#line 694
              len -= samples;
#line 696
              vorbis_synthesis_read(& vdata->vd, samples);
#line 697
              vdata->loc += (long )samples;
              }
#line 698
              if (len == 0) {
#line 699
                return ((sf_count_t )i);
              }
            }
            while_break___3: /* CIL Label */ ;
            }

          }
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 703
        __cil_tmp19 = ogg_page_eos(& odata->og);
        }
#line 703
        if (__cil_tmp19) {
#line 703
          odata->eos = 1;
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 706
    if (! odata->eos) {
      {
#line 709
      buffer = ogg_sync_buffer(& odata->oy, (long )4096);
#line 710
      __cil_tmp23 = psf_fread(buffer, (sf_count_t )1, (sf_count_t )4096, psf);
#line 710
      bytes = (int )__cil_tmp23;
#line 711
      ogg_sync_wrote(& odata->oy, (long )bytes);
      }
#line 712
      if (bytes == 0) {
#line 712
        odata->eos = 1;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 715
  return ((sf_count_t )i);
}
}
#line 719 "/root/libsndfile/src/ogg.c"
static sf_count_t ogg_read_s(SF_PRIVATE *psf , short *ptr , sf_count_t lens ) 
{ 
  sf_count_t __cil_tmp4 ;

  {
  {
#line 720
  __cil_tmp4 = ogg_read_sample(psf, (void *)ptr, lens, & ogg_rshort);
  }
#line 720
  return (__cil_tmp4);
}
}
#line 724 "/root/libsndfile/src/ogg.c"
static sf_count_t ogg_read_i(SF_PRIVATE *psf , int *ptr , sf_count_t lens ) 
{ 
  sf_count_t __cil_tmp4 ;

  {
  {
#line 725
  __cil_tmp4 = ogg_read_sample(psf, (void *)ptr, lens, & ogg_rint);
  }
#line 725
  return (__cil_tmp4);
}
}
#line 729 "/root/libsndfile/src/ogg.c"
static sf_count_t ogg_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t lens ) 
{ 
  sf_count_t __cil_tmp4 ;

  {
  {
#line 730
  __cil_tmp4 = ogg_read_sample(psf, (void *)ptr, lens, & ogg_rfloat);
  }
#line 730
  return (__cil_tmp4);
}
}
#line 734 "/root/libsndfile/src/ogg.c"
static sf_count_t ogg_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t lens ) 
{ 
  sf_count_t __cil_tmp4 ;

  {
  {
#line 735
  __cil_tmp4 = ogg_read_sample(psf, (void *)ptr, lens, & ogg_rdouble);
  }
#line 735
  return (__cil_tmp4);
}
}
#line 742 "/root/libsndfile/src/ogg.c"
static void ogg_write_samples(SF_PRIVATE *psf , OGG_PRIVATE *odata , VORBIS_PRIVATE *vdata ,
                              int in_frames ) 
{ 
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int result ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 744
  vorbis_analysis_wrote(& vdata->vd, in_frames);
  }
  {
#line 751
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 751
    __cil_tmp5 = vorbis_analysis_blockout(& vdata->vd, & vdata->vb);
    }
#line 751
    if (! (__cil_tmp5 == 1)) {
#line 751
      goto while_break;
    }
    {
#line 754
    vorbis_analysis(& vdata->vb, (ogg_packet *)((void *)0));
#line 755
    vorbis_bitrate_addblock(& vdata->vb);
    }
    {
#line 757
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 757
      __cil_tmp6 = vorbis_bitrate_flushpacket(& vdata->vd, & odata->op);
      }
#line 757
      if (! __cil_tmp6) {
#line 757
        goto while_break___0;
      }
      {
#line 760
      ogg_stream_packetin(& odata->os, & odata->op);
      }
      {
#line 763
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 763
        if (! (! odata->eos)) {
#line 763
          goto while_break___1;
        }
        {
#line 764
        __cil_tmp8 = ogg_stream_pageout(& odata->os, & odata->og);
#line 764
        result = __cil_tmp8;
        }
#line 765
        if (result == 0) {
#line 766
          goto while_break___1;
        }
        {
#line 767
        psf_fwrite(odata->og.header, (sf_count_t )1, odata->og.header_len, psf);
#line 768
        psf_fwrite(odata->og.body, (sf_count_t )1, odata->og.body_len, psf);
#line 772
        __cil_tmp9 = ogg_page_eos(& odata->og);
        }
#line 772
        if (__cil_tmp9) {
#line 773
          odata->eos = 1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }

    }
    while_break___0: /* CIL Label */ ;
    }

  }
  while_break: /* CIL Label */ ;
  }
#line 778
  vdata->loc += (long )in_frames;
  return;
}
}
#line 783 "/root/libsndfile/src/ogg.c"
static sf_count_t ogg_write_s(SF_PRIVATE *psf , short const   *ptr , sf_count_t lens ) 
{ 
  int i ;
  int m ;
  int j ;
  OGG_PRIVATE *odata ;
  VORBIS_PRIVATE *vdata ;
  int in_frames ;
  float **buffer ;
  float **__cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;

  {
  {
#line 785
  j = 0;
#line 786
  odata = (OGG_PRIVATE *)psf->container_data;
#line 787
  vdata = (VORBIS_PRIVATE *)psf->codec_data;
#line 788
  in_frames = (int )(lens / (long )psf->sf.channels);
#line 789
  __cil_tmp11 = vorbis_analysis_buffer(& vdata->vd, in_frames);
#line 789
  buffer = __cil_tmp11;
#line 790
  i = 0;
  }
  {
#line 790
  while (1) {
    while_continue: /* CIL Label */ ;
#line 790
    if (! (i < in_frames)) {
#line 790
      goto while_break;
    }
#line 791
    m = 0;
    {
#line 791
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 791
      if (! (m < psf->sf.channels)) {
#line 791
        goto while_break___0;
      }
#line 792
      __cil_tmp12 = j;
#line 792
      j ++;
#line 792
      *(*(buffer + m) + i) = (float )*(ptr + __cil_tmp12) / 32767.f;
#line 791
      m ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 790
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 794
  ogg_write_samples(psf, odata, vdata, in_frames);
  }
#line 796
  return (lens);
}
}
#line 800 "/root/libsndfile/src/ogg.c"
static sf_count_t ogg_write_i(SF_PRIVATE *psf , int const   *ptr , sf_count_t lens ) 
{ 
  int i ;
  int m ;
  int j ;
  OGG_PRIVATE *odata ;
  VORBIS_PRIVATE *vdata ;
  int in_frames ;
  float **buffer ;
  float **__cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;

  {
  {
#line 801
  j = 0;
#line 802
  odata = (OGG_PRIVATE *)psf->container_data;
#line 803
  vdata = (VORBIS_PRIVATE *)psf->codec_data;
#line 804
  in_frames = (int )(lens / (long )psf->sf.channels);
#line 805
  __cil_tmp11 = vorbis_analysis_buffer(& vdata->vd, in_frames);
#line 805
  buffer = __cil_tmp11;
#line 806
  i = 0;
  }
  {
#line 806
  while (1) {
    while_continue: /* CIL Label */ ;
#line 806
    if (! (i < in_frames)) {
#line 806
      goto while_break;
    }
#line 807
    m = 0;
    {
#line 807
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 807
      if (! (m < psf->sf.channels)) {
#line 807
        goto while_break___0;
      }
#line 808
      __cil_tmp12 = j;
#line 808
      j ++;
#line 808
      *(*(buffer + m) + i) = (float )*(ptr + __cil_tmp12) / 2147483648.f;
#line 807
      m ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 806
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 810
  ogg_write_samples(psf, odata, vdata, in_frames);
  }
#line 812
  return (lens);
}
}
#line 816 "/root/libsndfile/src/ogg.c"
static sf_count_t ogg_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t lens ) 
{ 
  int i ;
  int m ;
  int j ;
  OGG_PRIVATE *odata ;
  VORBIS_PRIVATE *vdata ;
  int in_frames ;
  float **buffer ;
  float **__cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;

  {
  {
#line 817
  j = 0;
#line 818
  odata = (OGG_PRIVATE *)psf->container_data;
#line 819
  vdata = (VORBIS_PRIVATE *)psf->codec_data;
#line 820
  in_frames = (int )(lens / (long )psf->sf.channels);
#line 821
  __cil_tmp11 = vorbis_analysis_buffer(& vdata->vd, in_frames);
#line 821
  buffer = __cil_tmp11;
#line 822
  i = 0;
  }
  {
#line 822
  while (1) {
    while_continue: /* CIL Label */ ;
#line 822
    if (! (i < in_frames)) {
#line 822
      goto while_break;
    }
#line 823
    m = 0;
    {
#line 823
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 823
      if (! (m < psf->sf.channels)) {
#line 823
        goto while_break___0;
      }
#line 824
      __cil_tmp12 = j;
#line 824
      j ++;
#line 824
      *(*(buffer + m) + i) = *(ptr + __cil_tmp12);
#line 823
      m ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 822
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 826
  ogg_write_samples(psf, odata, vdata, in_frames);
  }
#line 828
  return (lens);
}
}
#line 832 "/root/libsndfile/src/ogg.c"
static sf_count_t ogg_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t lens ) 
{ 
  int i ;
  int m ;
  int j ;
  OGG_PRIVATE *odata ;
  VORBIS_PRIVATE *vdata ;
  int in_frames ;
  float **buffer ;
  float **__cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;

  {
  {
#line 833
  j = 0;
#line 834
  odata = (OGG_PRIVATE *)psf->container_data;
#line 835
  vdata = (VORBIS_PRIVATE *)psf->codec_data;
#line 836
  in_frames = (int )(lens / (long )psf->sf.channels);
#line 837
  __cil_tmp11 = vorbis_analysis_buffer(& vdata->vd, in_frames);
#line 837
  buffer = __cil_tmp11;
#line 838
  i = 0;
  }
  {
#line 838
  while (1) {
    while_continue: /* CIL Label */ ;
#line 838
    if (! (i < in_frames)) {
#line 838
      goto while_break;
    }
#line 839
    m = 0;
    {
#line 839
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 839
      if (! (m < psf->sf.channels)) {
#line 839
        goto while_break___0;
      }
#line 840
      __cil_tmp12 = j;
#line 840
      j ++;
#line 840
      *(*(buffer + m) + i) = (float )*(ptr + __cil_tmp12);
#line 839
      m ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 838
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 842
  ogg_write_samples(psf, odata, vdata, in_frames);
  }
#line 844
  return (lens);
}
}
#line 848 "/root/libsndfile/src/ogg.c"
static sf_count_t ogg_seek(SF_PRIVATE *psf , int UNUSED_mode , sf_count_t offset ) 
{ 
  OGG_PRIVATE *odata ;
  VORBIS_PRIVATE *vdata ;
  sf_count_t target ;
  sf_count_t m ;
  long tmp ;

  {
#line 850
  odata = (OGG_PRIVATE *)psf->container_data;
#line 851
  vdata = (VORBIS_PRIVATE *)psf->codec_data;
#line 853
  if (odata == (void *)0) {
#line 854
    return ((sf_count_t )0);
  } else
#line 853
  if (vdata == (void *)0) {
#line 854
    return ((sf_count_t )0);
  }
#line 856
  if (offset < 0L) {
#line 857
    psf->error = 38;
#line 858
    return ((sf_count_t )(- 1));
  }

#line 861
  if (psf->mode == 16) {
#line 862
    target = offset - vdata->loc;
#line 864
    if (target < 0L) {
      {
#line 866
      psf_fseek(psf, (sf_count_t )12, 0);
#line 867
      ogg_read_header(psf, 0);
#line 868
      target = offset;
      }
    }

    {
#line 871
    while (1) {
      while_continue: /* CIL Label */ ;
#line 871
      if (! (target > 0L)) {
#line 871
        goto while_break;
      }
#line 872
      if (target > 4096L) {
#line 872
        tmp = (long )4096;
      } else {
#line 872
        tmp = target;
      }
      {
#line 872
      m = tmp;
#line 879
      ogg_read_sample(psf, (void *)((void *)0), m * (long )psf->sf.channels, & ogg_rnull);
#line 881
      target -= m;
      }
    }
    while_break: /* CIL Label */ ;
    }

#line 884
    return (vdata->loc);
  }

#line 887
  return ((sf_count_t )0);
}
}
#line 922 "/root/libsndfile/src/ogg.c"
static stream_set *create_stream_set(void) 
{ 
  stream_set *set ;
  void *__cil_tmp2 ;
  void *__cil_tmp3 ;

  {
  {
#line 923
  __cil_tmp2 = calloc((unsigned long )1, sizeof(stream_set ));
#line 923
  set = __cil_tmp2;
#line 925
  set->streams = (stream_processor *)calloc((unsigned long )5, sizeof(stream_processor ));
#line 926
  set->allocated = 5;
#line 927
  set->used = 0;
  }
#line 929
  return (set);
}
}
#line 933 "/root/libsndfile/src/ogg.c"
static void vorbis_end(stream_processor *stream , sf_count_t *len ) 
{ 


  {
  {
#line 934
  *len += stream->lastgranulepos;
#line 935
  vorbis_comment_clear(& stream->vc);
#line 936
  vorbis_info_clear(& stream->vi);
  }
  return;
}
}
#line 940 "/root/libsndfile/src/ogg.c"
static void free_stream_set(stream_set *set , sf_count_t *len ) 
{ 
  int i ;
  int __cil_tmp4 ;

  {
#line 943
  i = 0;
  {
#line 943
  while (1) {
    while_continue: /* CIL Label */ ;
#line 943
    if (! (i < set->used)) {
#line 943
      goto while_break;
    }
#line 944
    if (! (set->streams + i)->end) {
      {
#line 945
      vorbis_end(set->streams + i, len);
      }
    }
    {
#line 946
    ogg_stream_clear(& (set->streams + i)->os);
    }
#line 943
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 949
  free(set->streams);
#line 950
  free(set);
  }
  return;
}
}
#line 954 "/root/libsndfile/src/ogg.c"
static int streams_open(stream_set *set ) 
{ 
  int i ;
  int res ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
#line 955
  res = 0;
#line 957
  i = 0;
  {
#line 957
  while (1) {
    while_continue: /* CIL Label */ ;
#line 957
    if (! (i < set->used)) {
#line 957
      goto while_break;
    }
#line 958
    if (! (set->streams + i)->end) {
#line 959
      res ++;
    }
#line 957
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 960
  return (res);
}
}
#line 964 "/root/libsndfile/src/ogg.c"
static stream_processor *find_stream_processor(stream_set *set , ogg_page *page ) 
{ 
  uint32_t serial ;
  int __cil_tmp4 ;
  int i ;
  int found ;
  int invalid ;
  stream_processor *stream ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  void *__cil_tmp12 ;
  int __cil_tmp13 ;
  int res ;
  ogg_packet packet ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;

  {
  {
#line 965
  __cil_tmp4 = ogg_page_serialno(page);
#line 965
  serial = (uint32_t )__cil_tmp4;
#line 966
  found = 0;
#line 967
  invalid = 0;
#line 971
  i = 0;
  }
  {
#line 971
  while (1) {
    while_continue: /* CIL Label */ ;
#line 971
    if (! (i < set->used)) {
#line 971
      goto while_break;
    }
#line 973
    if (serial == (set->streams + i)->serial) {
#line 975
      found = 1;
#line 976
      stream = set->streams + i;
#line 978
      set->in_headers = 0;
#line 980
      if (stream->end) {
#line 981
        stream->isillegal = 1;
#line 982
        return (stream);
      }
      {
#line 985
      stream->isnew = 0;
#line 986
      stream->end = ogg_page_eos(page);
#line 987
      stream->serial = serial;
      }
#line 988
      return (stream);
    }

#line 971
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 997
  __cil_tmp11 = streams_open(set);
  }
#line 997
  if (__cil_tmp11) {
#line 997
    if (! set->in_headers) {
#line 998
      invalid = 1;
    }
  }
#line 1000
  set->in_headers = 1;
#line 1002
  if (set->allocated < set->used) {
#line 1003
    stream = set->streams + set->used;
  } else {
    {
#line 1005
    set->allocated += 5;
#line 1006
    set->streams = (stream_processor *)realloc(set->streams, sizeof(stream_processor ) * (unsigned long )set->allocated);
#line 1007
    stream = set->streams + set->used;
    }
  }
  {
#line 1010
  (set->used) ++;
#line 1012
  stream->isnew = 1;
#line 1013
  stream->isillegal = invalid;
#line 1020
  ogg_stream_init(& stream->os, (int )serial);
#line 1021
  ogg_stream_pagein(& stream->os, page);
#line 1022
  res = ogg_stream_packetout(& stream->os, & packet);
  }
#line 1023
  if (res <= 0) {
#line 1024
    return ((stream_processor *)((void *)0));
  } else {
    {
#line 1025
    __cil_tmp17 = memcmp(packet.packet, "\001vorbis", (unsigned long )7);
    }
#line 1025
    if (packet.bytes >= 7L) {
#line 1025
      if (__cil_tmp17 == 0) {
        {
#line 1027
        stream->lastgranulepos = (sf_count_t )0;
#line 1028
        vorbis_comment_init(& stream->vc);
#line 1029
        vorbis_info_init(& stream->vi);
        }
      }
    }
  }
  {
#line 1032
  res = ogg_stream_packetout(& stream->os, & packet);
#line 1035
  ogg_stream_clear(& stream->os);
#line 1036
  ogg_stream_init(& stream->os, (int )serial);
#line 1039
  stream->end = ogg_page_eos(page);
#line 1040
  stream->serial = serial;
  }
#line 1042
  return (stream);
}
}
#line 1046 "/root/libsndfile/src/ogg.c"
static int ogg_length_get_next_page(SF_PRIVATE *psf , ogg_sync_state *osync , ogg_page *page ) 
{ 
  static int CHUNK_SIZE ;
  int __cil_tmp5 ;
  char *buffer ;
  char *__cil_tmp7 ;
  int bytes ;
  sf_count_t __cil_tmp9 ;

  {
#line 1047
  CHUNK_SIZE = 4500;
  {
#line 1049
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1049
    __cil_tmp5 = ogg_sync_pageout(osync, page);
    }
#line 1049
    if (! (__cil_tmp5 <= 0)) {
#line 1049
      goto while_break;
    }
    {
#line 1050
    __cil_tmp7 = ogg_sync_buffer(osync, (long )CHUNK_SIZE);
#line 1050
    buffer = __cil_tmp7;
#line 1051
    __cil_tmp9 = psf_fread(buffer, (sf_count_t )1, (sf_count_t )4096, psf);
#line 1051
    bytes = (int )__cil_tmp9;
    }
#line 1053
    if (bytes <= 0) {
      {
#line 1054
      ogg_sync_wrote(osync, (long )0);
      }
#line 1055
      return (0);
    }
    {
#line 1058
    ogg_sync_wrote(osync, (long )bytes);
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 1061
  return (1);
}
}
#line 1065 "/root/libsndfile/src/ogg.c"
static sf_count_t ogg_length_aux(SF_PRIVATE *psf ) 
{ 
  ogg_sync_state osync ;
  ogg_page page ;
  int gotpage ;
  sf_count_t len ;
  stream_set *processors ;
  stream_set *__cil_tmp7 ;
  int __cil_tmp8 ;
  stream_processor *p ;
  stream_processor *__cil_tmp10 ;
  ogg_packet packet ;
  int header ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  sf_count_t gp ;
  ogg_int64_t __cil_tmp17 ;

  {
  {
#line 1069
  gotpage = 0;
#line 1070
  len = (sf_count_t )0;
#line 1073
  processors = create_stream_set();
  }
#line 1074
  if (processors == (void *)0) {
#line 1075
    return ((sf_count_t )0);
  }
  {
#line 1077
  ogg_sync_init(& osync);
  }
  {
#line 1079
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1079
    __cil_tmp8 = ogg_length_get_next_page(psf, & osync, & page);
    }
#line 1079
    if (! __cil_tmp8) {
#line 1079
      goto while_break;
    }
    {
#line 1081
    __cil_tmp10 = find_stream_processor(processors, & page);
#line 1081
    p = __cil_tmp10;
#line 1082
    gotpage = 1;
    }
#line 1084
    if (! p) {
#line 1085
      len = (sf_count_t )0;
#line 1086
      goto while_break;
    }

#line 1089
    if (p->isillegal) {
#line 1089
      if (! p->shownillegal) {
#line 1091
        p->shownillegal = 1;
#line 1095
        if (! p->isnew) {
#line 1095
          goto while_continue;
        }
      }
    }

#line 1098
    if (! p->isillegal) {
      {
#line 1100
      header = 0;
#line 1102
      ogg_stream_pagein(& p->os, & page);
      }
#line 1103
      if (p->doneheaders < 3) {
#line 1104
        header = 1;
      }
      {
#line 1106
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 1106
        __cil_tmp13 = ogg_stream_packetout(& p->os, & packet);
        }
#line 1106
        if (! (__cil_tmp13 > 0)) {
#line 1106
          goto while_break___0;
        }
#line 1108
        if (p->doneheaders < 3) {
          {
#line 1109
          __cil_tmp14 = vorbis_synthesis_headerin(& p->vi, & p->vc, & packet);
          }
#line 1109
          if (__cil_tmp14 < 0) {
#line 1110
            goto while_continue___0;
          }
#line 1111
          (p->doneheaders) ++;
        }

      }
      while_break___0: /* CIL Label */ ;
      }

#line 1114
      if (! header) {
        {
#line 1115
        __cil_tmp17 = ogg_page_granulepos(& page);
#line 1115
        gp = __cil_tmp17;
        }
#line 1116
        if (gp > 0L) {
#line 1116
          p->lastgranulepos = gp;
        }
      }

#line 1118
      if (p->end) {
        {
#line 1119
        vorbis_end(p, & len);
#line 1120
        p->isillegal = 1;
        }
      }

    }

  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1125
  ogg_sync_clear(& osync);
#line 1126
  free_stream_set(processors, & len);
  }
#line 1128
  return (len);
}
}
#line 1132 "/root/libsndfile/src/ogg.c"
static sf_count_t ogg_length(SF_PRIVATE *psf ) 
{ 
  sf_count_t length ;
  int error ;
  sf_count_t __cil_tmp4 ;
  int __cil_tmp5 ;

  {
#line 1136
  if (psf->sf.seekable == 0) {
#line 1137
    return ((sf_count_t )-1LL);
  }
  {
#line 1139
  psf_fseek(psf, (sf_count_t )0, 0);
#line 1140
  length = ogg_length_aux(psf);
#line 1142
  psf_fseek(psf, (sf_count_t )12, 0);
#line 1143
  error = ogg_read_header(psf, 0);
  }
#line 1143
  if (error != 0) {
#line 1144
    psf->error = error;
  }
#line 1146
  return (length);
}
}
#line 46 "/root/libsndfile/src/nist.c"
static int nist_close(SF_PRIVATE *psf ) ;
#line 47
static int nist_write_header(SF_PRIVATE *psf , int calc_length ) ;
#line 48
static int nist_read_header(SF_PRIVATE *psf ) ;
#line 54 "/root/libsndfile/src/nist.c"
int nist_open(SF_PRIVATE *psf ) 
{ 
  int error ;
  int __cil_tmp3 ;
  int tmp ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
#line 57
  if (psf->mode == 16) {
    _L: /* CIL Label */ 
    {
#line 58
    error = nist_read_header(psf);
    }
#line 58
    if (error) {
#line 59
      return (error);
    }
  } else
#line 57
  if (psf->mode == 48) {
#line 57
    if (psf->filelength > 0L) {
#line 57
      goto _L;
    }
  }

#line 62
  if (psf->mode == 32) {
    _L___33: /* CIL Label */ 
#line 63
    if (psf->is_pipe) {
#line 64
      return (28);
    }
#line 66
    if ((psf->sf.format & 268369920) != 458752) {
#line 67
      return (1);
    }
#line 69
    psf->endian = psf->sf.format & 805306368;
#line 70
    if (psf->endian == 0) {
#line 71
      tmp = 268435456;
#line 71
      psf->endian = tmp;
    } else
#line 70
    if (psf->endian == 805306368) {
#line 71
      tmp = 268435456;
#line 71
      psf->endian = tmp;
    }
    {
#line 73
    psf->blockwidth = psf->bytewidth * psf->sf.channels;
#line 74
    psf->sf.frames = (sf_count_t )0;
#line 76
    error = nist_write_header(psf, 0);
    }
#line 76
    if (error) {
#line 77
      return (error);
    }
#line 79
    psf->write_header = & nist_write_header;
  } else
#line 62
  if (psf->mode == 48) {
#line 62
    goto _L___33;
  }
#line 82
  psf->container_close = & nist_close;
  {
#line 85
  if ((psf->sf.format & 65535) == 1) {
#line 85
    goto case_1;
  }
#line 91
  if ((psf->sf.format & 65535) == 4) {
#line 91
    goto case_4;
  }
#line 91
  if ((psf->sf.format & 65535) == 3) {
#line 91
    goto case_4;
  }
#line 91
  if ((psf->sf.format & 65535) == 2) {
#line 91
    goto case_4;
  }
#line 95
  if ((psf->sf.format & 65535) == 16) {
#line 95
    goto case_16;
  }
#line 99
  if ((psf->sf.format & 65535) == 17) {
#line 99
    goto case_17;
  }
#line 103
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 86
  error = pcm_init(psf);
  }
#line 87
  goto switch_break;
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 92
  error = pcm_init(psf);
  }
#line 93
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 96
  error = ulaw_init(psf);
  }
#line 97
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 100
  error = alaw_init(psf);
  }
#line 101
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 103
  error = 17;
#line 104
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }

#line 107
  return (error);
}
}
#line 113 "/root/libsndfile/src/nist.c"
static char bad_header[19]  = 
#line 113
  {      (char )'N',      (char )'I',      (char )'S',      (char )'T', 
        (char )'_',      (char )'1',      (char )'A',      (char )13, 
        (char )10,      (char )' ',      (char )' ',      (char )' ', 
        (char )'1',      (char )'0',      (char )'2',      (char )'4', 
        (char )13,      (char )10,      (char )0};
#line 120 "/root/libsndfile/src/nist.c"
static int nist_read_header(SF_PRIVATE *psf ) 
{ 
  char *psf_header ;
  int bitwidth ;
  int bytes ;
  int count ;
  int encoding ;
  char str[64] ;
  char *cptr ;
  long samples ;
  char *__cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  int __cil_tmp14 ;
  char *__cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  int tmp ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
#line 122
  bitwidth = 0;
#line 122
  bytes = 0;
#line 126
  psf->sf.format = 458752;
#line 128
  psf_header = (char *)psf->u.cbuf;
#line 130
  if (sizeof(psf->header) <= 1024UL) {
#line 131
    return (29);
  }
  {
#line 134
  psf_binheader_readf(psf, "pb", 0, psf_header, 1024);
#line 137
  *(psf_header + 1024) = (char )0;
#line 140
  cptr = strstr((char const   *)psf_header, "end_head\220");
  }
#line 140
  if (cptr) {
    {
#line 141
    __cil_tmp11 = strlen("end_head\220");
    }
#line 141
    cptr += __cil_tmp11 + 1UL;
#line 142
    *(cptr + 0) = (char )0;
  }
  {
#line 145
  __cil_tmp12 = strstr((char const   *)psf_header, (char const   *)((char *)bad_header));
  }
#line 145
  if (__cil_tmp12 == psf_header) {
#line 146
    return (102);
  }
  {
#line 149
  __cil_tmp13 = strstr((char const   *)psf_header, "NIST_1A\n\220");
  }
#line 149
  if (__cil_tmp13 != psf_header) {
    {
#line 150
    psf_log_printf(psf, "Not a NIST file.\n%l\374\036V");
    }
#line 151
    return (101);
  }
  {
#line 154
  __cil_tmp14 = sscanf((char const   *)psf_header, "NIST_1A\n%d\n\374\036V", & count);
  }
#line 154
  if (__cil_tmp14 == 1) {
#line 155
    psf->dataoffset = (sf_count_t )count;
  } else {
    {
#line 157
    psf_log_printf(psf, "*** Suspicious header length.\n");
#line 158
    psf->dataoffset = (sf_count_t )1024;
    }
  }
  {
#line 162
  encoding = 5;
#line 163
  cptr = strstr((char const   *)psf_header, "sample_coding -s\220");
  }
#line 163
  if (cptr) {
    {
#line 164
    sscanf((char const   *)cptr, "sample_coding -s%d %63s", & count, (char *)str);
#line 166
    __cil_tmp16 = strcmp((char const   *)((char *)str), "pcm\374\036V");
    }
#line 166
    if (__cil_tmp16 == 0) {
#line 167
      encoding = 5;
    } else {
      {
#line 168
      __cil_tmp17 = strcmp((char const   *)((char *)str), "alaw");
      }
#line 168
      if (__cil_tmp17 == 0) {
#line 169
        encoding = 17;
      } else {
        {
#line 170
        __cil_tmp19 = strcmp((char const   *)((char *)str), "mu-law");
        }
        {
#line 170
        __cil_tmp18 = strcmp((char const   *)((char *)str), "ulaw");
        }
#line 170
        if (__cil_tmp18 == 0) {
#line 171
          encoding = 16;
        } else
#line 170
        if (__cil_tmp19 == 0) {
#line 171
          encoding = 16;
        } else {
          {
#line 173
          psf_log_printf(psf, "*** Unknown encoding : %s\n", (char *)str);
#line 174
          encoding = 0;
          }
        }
      }
    }

  }
  {
#line 178
  cptr = strstr((char const   *)psf_header, "channel_count -i ");
  }
#line 178
  if (cptr != (void *)0) {
    {
#line 179
    sscanf((char const   *)cptr, "channel_count -i %d", & psf->sf.channels);
    }
  }
  {
#line 181
  cptr = strstr((char const   *)psf_header, "sample_rate -i ");
  }
#line 181
  if (cptr != (void *)0) {
    {
#line 182
    sscanf((char const   *)cptr, "sample_rate -i %d", & psf->sf.samplerate);
    }
  }
  {
#line 184
  cptr = strstr((char const   *)psf_header, "sample_count -i \220");
  }
#line 184
  if (cptr != (void *)0) {
    {
#line 185
    sscanf((char const   *)cptr, "sample_count -i %ld", & samples);
#line 186
    psf->sf.frames = samples;
    }
  }
  {
#line 189
  cptr = strstr((char const   *)psf_header, "sample_n_bytes -i ");
  }
#line 189
  if (cptr != (void *)0) {
    {
#line 190
    sscanf((char const   *)cptr, "sample_n_bytes -i %d", & psf->bytewidth);
    }
  }
  {
#line 193
  tmp = 268435456;
#line 193
  psf->endian = tmp;
#line 196
  cptr = strstr((char const   *)psf_header, "sample_byte_format -s");
  }
#line 196
  if (cptr) {
    {
#line 197
    sscanf((char const   *)cptr, "sample_byte_format -s%d %8s", & bytes, (char *)str);
    }
#line 198
    if (bytes > 1) {
#line 199
      if (psf->bytewidth == 0) {
#line 200
        psf->bytewidth = bytes;
      } else
#line 201
      if (psf->bytewidth != bytes) {
        {
#line 202
        psf_log_printf(psf, "psf->bytewidth (%d) != bytes (%d)\n", psf->bytewidth,
                       bytes);
        }
#line 203
        return (103);
      }
      {
#line 206
      __cil_tmp26 = strstr((char const   *)((char *)str), "01");
      }
#line 206
      if (__cil_tmp26 == (char *)str) {
#line 207
        psf->endian = 268435456;
      } else {
        {
#line 208
        __cil_tmp27 = strstr((char const   *)((char *)str), "10");
        }
#line 208
        if (__cil_tmp27) {
#line 209
          psf->endian = 536870912;
        } else {
          {
#line 211
          psf_log_printf(psf, "Weird endian-ness : %s\n", (char *)str);
          }
#line 212
          return (103);
        }
      }

    }
#line 216
    psf->sf.format |= psf->endian;
  }
  {
#line 219
  cptr = strstr((char const   *)psf_header, "sample_sig_bits -i ");
  }
#line 219
  if (cptr) {
    {
#line 220
    sscanf((char const   *)cptr, "sample_sig_bits -i %d", & bitwidth);
    }
  }
  {
#line 222
  __cil_tmp29 = strstr((char const   *)psf_header, "channels_interleaved -s5 FALSE");
  }
#line 222
  if (__cil_tmp29) {
    {
#line 223
    psf_log_printf(psf, "Non-interleaved data unsupported.\n", (char *)str);
    }
#line 224
    return (103);
  }
  {
#line 227
  psf->blockwidth = psf->sf.channels * psf->bytewidth;
#line 228
  psf->datalength = psf->filelength - psf->dataoffset;
#line 230
  psf_fseek(psf, psf->dataoffset, 0);
  }
#line 232
  if (encoding == 5) {
    {
#line 234
    if (psf->bytewidth == 1) {
#line 234
      goto case_1;
    }
#line 238
    if (psf->bytewidth == 2) {
#line 238
      goto case_2;
    }
#line 242
    if (psf->bytewidth == 3) {
#line 242
      goto case_3;
    }
#line 246
    if (psf->bytewidth == 4) {
#line 246
      goto case_4;
    }
#line 250
    goto switch_default;
    case_1: /* CIL Label */ 
#line 235
    psf->sf.format |= 1;
#line 236
    goto switch_break;
    case_2: /* CIL Label */ 
#line 239
    psf->sf.format |= 2;
#line 240
    goto switch_break;
    case_3: /* CIL Label */ 
#line 243
    psf->sf.format |= 3;
#line 244
    goto switch_break;
    case_4: /* CIL Label */ 
#line 247
    psf->sf.format |= 4;
#line 248
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 250
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }

  } else
#line 253
  if (encoding != 0) {
#line 254
    psf->sf.format |= encoding;
  } else {
#line 256
    return (17);
  }
#line 258
  return (0);
}
}
#line 262 "/root/libsndfile/src/nist.c"
static int nist_close(SF_PRIVATE *psf ) 
{ 


  {
#line 264
  if (psf->mode == 32) {
    {
    {
#line 265
    nist_write_header(psf, 1);
    }
    }
  } else
#line 264
  if (psf->mode == 48) {
    {
    {
#line 265
    nist_write_header(psf, 1);
    }
    }
  }
#line 267
  return (0);
}
}
#line 274 "/root/libsndfile/src/nist.c"
static int nist_write_header(SF_PRIVATE *psf , int calc_length ) 
{ 
  char const   *end_str ;
  long samples ;
  sf_count_t current ;
  sf_count_t __cil_tmp6 ;
  sf_count_t __cil_tmp7 ;

  {
  {
#line 279
  current = psf_ftell(psf);
  }
#line 281
  if (calc_length) {
    {
#line 282
    psf->filelength = psf_get_filelen(psf);
#line 284
    psf->datalength = psf->filelength - psf->dataoffset;
    }
#line 286
    if (psf->dataend) {
#line 287
      psf->datalength -= psf->filelength - psf->dataend;
    }
#line 289
    if (psf->bytewidth > 0) {
#line 290
      psf->sf.frames = psf->datalength / (long )(psf->bytewidth * psf->sf.channels);
    }
  }

#line 293
  if (psf->endian == 536870912) {
#line 294
    end_str = "10";
  } else
#line 295
  if (psf->endian == 268435456) {
#line 296
    end_str = "01";
  } else {
#line 298
    end_str = "error";
  }
  {
#line 301
  memset((unsigned char *)psf->header, 0, sizeof(psf->header));
#line 302
  psf->headindex = 0;
#line 304
  psf_fseek(psf, (sf_count_t )0, 0);
#line 306
  psf_asciiheader_printf(psf, "NIST_1A\n   1024\n\220");
#line 307
  psf_asciiheader_printf(psf, "channel_count -i %d\n", psf->sf.channels);
#line 308
  psf_asciiheader_printf(psf, "sample_rate -i %d\n", psf->sf.samplerate);
  }
  {
#line 311
  if ((psf->sf.format & 65535) == 1) {
#line 311
    goto case_1;
  }
#line 319
  if ((psf->sf.format & 65535) == 4) {
#line 319
    goto case_4;
  }
#line 319
  if ((psf->sf.format & 65535) == 3) {
#line 319
    goto case_4;
  }
#line 319
  if ((psf->sf.format & 65535) == 2) {
#line 319
    goto case_4;
  }
#line 326
  if ((psf->sf.format & 65535) == 17) {
#line 326
    goto case_17;
  }
#line 331
  if ((psf->sf.format & 65535) == 16) {
#line 331
    goto case_16;
  }
#line 336
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 312
  psf_asciiheader_printf(psf, "sample_coding -s3 pcm\n");
  }
  {
#line 313
  psf_asciiheader_printf(psf, "sample_n_bytes -i 1\nsample_sig_bits -i 8\nV");
  }
#line 315
  goto switch_break;
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 320
  psf_asciiheader_printf(psf, "sample_n_bytes -i %d\nV", psf->bytewidth);
  }
  {
#line 321
  psf_asciiheader_printf(psf, "sample_sig_bits -i %d\n", psf->bytewidth * 8);
#line 322
  psf_asciiheader_printf(psf, "sample_coding -s3 pcm\nsample_byte_format -s%d %s\nV",
                         psf->bytewidth, end_str);
  }
#line 324
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 327
  psf_asciiheader_printf(psf, "sample_coding -s4 alaw\n");
  }
  {
#line 328
  psf_asciiheader_printf(psf, "sample_n_bytes -s1 1\nV");
  }
#line 329
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 332
  psf_asciiheader_printf(psf, "sample_coding -s4 ulaw\n");
  }
  {
#line 333
  psf_asciiheader_printf(psf, "sample_n_bytes -s1 1\n");
  }
#line 334
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 336
  return (17);
  switch_break: /* CIL Label */ ;
  }
  {
#line 339
  psf->dataoffset = (sf_count_t )1024;
#line 342
  samples = psf->sf.frames;
#line 343
  psf_asciiheader_printf(psf, "sample_count -i %ld\n\036V", samples);
#line 344
  psf_asciiheader_printf(psf, "end_head\n\246l\374\036V");
#line 347
  psf_binheader_writef(psf, "z", (size_t )(1024 - psf->headindex));
#line 349
  psf_fwrite((unsigned char *)psf->header, (sf_count_t )psf->headindex, (sf_count_t )1,
             psf);
  }
#line 351
  if (psf->error) {
#line 352
    return (psf->error);
  }
#line 354
  if (current > 0L) {
    {
#line 355
    psf_fseek(psf, current, 0);
    }
  }
#line 357
  return (psf->error);
}
}
#line 76 "/root/libsndfile/src/mat5.c"
static int mat5_close(SF_PRIVATE *psf ) ;
#line 78
static int mat5_write_header(SF_PRIVATE *psf , int calc_length ) ;
#line 79
static int mat5_read_header(SF_PRIVATE *psf ) ;
#line 86 "/root/libsndfile/src/mat5.c"
int mat5_open(SF_PRIVATE *psf ) 
{ 
  int subformat ;
  int error ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
#line 87
  error = 0;
#line 89
  if (psf->mode == 16) {
    _L: /* CIL Label */ 
    {
#line 90
    error = mat5_read_header(psf);
    }
#line 90
    if (error) {
#line 91
      return (error);
    }
  } else
#line 89
  if (psf->mode == 48) {
#line 89
    if (psf->filelength > 0L) {
#line 89
      goto _L;
    }
  }

#line 94
  if ((psf->sf.format & 268369920) != 851968) {
#line 95
    return (1);
  }
#line 97
  subformat = psf->sf.format & 65535;
#line 99
  if (psf->mode == 32) {
    _L___34: /* CIL Label */ 
#line 100
    if (psf->is_pipe) {
#line 101
      return (28);
    }
#line 103
    psf->endian = psf->sf.format & 805306368;
#line 104
    if (psf->endian == 805306368) {
#line 105
      psf->endian = 268435456;
    } else
#line 104
    if (psf->endian == 0) {
#line 105
      psf->endian = 268435456;
    } else
#line 106
    if (0) {
#line 107
      psf->endian = 536870912;
    }
    {
#line 109
    error = mat5_write_header(psf, 0);
    }
#line 109
    if (error) {
#line 110
      return (error);
    }
#line 112
    psf->write_header = & mat5_write_header;
  } else
#line 99
  if (psf->mode == 48) {
#line 99
    goto _L___34;
  }
#line 115
  psf->container_close = & mat5_close;
#line 117
  psf->blockwidth = psf->bytewidth * psf->sf.channels;
  {
#line 122
  if (subformat == 4) {
#line 122
    goto case_4;
  }
#line 122
  if (subformat == 2) {
#line 122
    goto case_4;
  }
#line 122
  if (subformat == 5) {
#line 122
    goto case_4;
  }
#line 126
  if (subformat == 6) {
#line 126
    goto case_6;
  }
#line 130
  if (subformat == 7) {
#line 130
    goto case_7;
  }
#line 134
  goto switch_default;
  case_4: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_5: /* CIL Label */ 
  {
#line 123
  error = pcm_init(psf);
  }
#line 124
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 127
  error = float32_init(psf);
  }
#line 128
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 131
  error = double64_init(psf);
  }
#line 132
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 134
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }

#line 137
  return (error);
}
}
#line 144 "/root/libsndfile/src/mat5.c"
static int mat5_close(SF_PRIVATE *psf ) 
{ 


  {
#line 146
  if (psf->mode == 32) {
    {
    {
#line 147
    mat5_write_header(psf, 1);
    }
    }
  } else
#line 146
  if (psf->mode == 48) {
    {
    {
#line 147
    mat5_write_header(psf, 1);
    }
    }
  }
#line 149
  return (0);
}
}
#line 156 "/root/libsndfile/src/mat5.c"
static int mat5_write_header(SF_PRIVATE *psf , int calc_length ) 
{ 
  static char const   *filename ;
  static char const   *sr_name ;
  static char const   *wd_name ;
  sf_count_t current ;
  sf_count_t datasize ;
  int encoding ;
  sf_count_t __cil_tmp9 ;
  sf_count_t __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  size_t __cil_tmp13 ;
  size_t __cil_tmp14 ;
  size_t __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  size_t __cil_tmp17 ;
  unsigned short samplerate ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;

  {
  {
#line 157
  filename = "MATLAB 5.0 MAT-file, written by libsndfile-1.0.21pre1, ";
#line 158
  sr_name = "samplerate";
#line 159
  wd_name = "wavedata";
#line 163
  current = psf_ftell(psf);
  }
#line 165
  if (calc_length) {
    {
#line 166
    psf_fseek(psf, (sf_count_t )0, 2);
#line 167
    psf->filelength = psf_ftell(psf);
#line 168
    psf_fseek(psf, (sf_count_t )0, 0);
#line 170
    psf->datalength = psf->filelength - psf->dataoffset;
    }
#line 171
    if (psf->dataend) {
#line 172
      psf->datalength -= psf->filelength - psf->dataend;
    }
#line 174
    psf->sf.frames = psf->datalength / (long )(psf->bytewidth * psf->sf.channels);
  }

  {
#line 178
  if ((psf->sf.format & 65535) == 5) {
#line 178
    goto case_5;
  }
#line 182
  if ((psf->sf.format & 65535) == 2) {
#line 182
    goto case_2;
  }
#line 186
  if ((psf->sf.format & 65535) == 4) {
#line 186
    goto case_4;
  }
#line 190
  if ((psf->sf.format & 65535) == 6) {
#line 190
    goto case_6;
  }
#line 194
  if ((psf->sf.format & 65535) == 7) {
#line 194
    goto case_7;
  }
#line 198
  goto switch_default;
  case_5: /* CIL Label */ 
#line 179
  encoding = 2;
#line 180
  goto switch_break;
  case_2: /* CIL Label */ 
#line 183
  encoding = 3;
#line 184
  goto switch_break;
  case_4: /* CIL Label */ 
#line 187
  encoding = 5;
#line 188
  goto switch_break;
  case_6: /* CIL Label */ 
#line 191
  encoding = 7;
#line 192
  goto switch_break;
  case_7: /* CIL Label */ 
#line 195
  encoding = 9;
#line 196
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 199
  return (1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 203
  psf->header[0] = (unsigned char )0;
#line 204
  psf->headindex = 0;
#line 205
  psf_fseek(psf, (sf_count_t )0, 0);
#line 207
  psf_get_date_str((char *)psf->u.cbuf, (int )sizeof(psf->u.scbuf));
#line 208
  __cil_tmp11 = strlen(filename);
  }
  {
#line 208
  __cil_tmp12 = strlen((char const   *)((char *)psf->u.cbuf));
#line 208
  psf_binheader_writef(psf, "bb", filename, __cil_tmp11, (char *)psf->u.cbuf, __cil_tmp12 + 1UL);
#line 210
  memset((signed char *)psf->u.scbuf, ' ', (unsigned long )(124 - psf->headindex));
#line 211
  __cil_tmp13 = make_size_t(124 - psf->headindex);
#line 211
  psf_binheader_writef(psf, "bA\214\374\036V", (signed char *)psf->u.scbuf, __cil_tmp13);
#line 213
  psf->rwf_endian = psf->endian;
  }
#line 215
  if (psf->rwf_endian == 536870912) {
    {
#line 216
    __cil_tmp14 = make_size_t(2);
#line 216
    psf_binheader_writef(psf, "2b\214\374\036V", 256, "MI", __cil_tmp14);
    }
  } else {
    {
#line 218
    __cil_tmp15 = make_size_t(2);
#line 218
    psf_binheader_writef(psf, "2b", 256, "IM", __cil_tmp15);
    }
  }
  {
#line 220
  psf_binheader_writef(psf, "444444", 14, 64, 6, 8, 6, 0);
#line 221
  psf_binheader_writef(psf, "4444\036V", 5, 8, 1, 1);
#line 222
  __cil_tmp16 = strlen(sr_name);
  }
  {
#line 222
  __cil_tmp17 = make_size_t(16);
#line 222
  psf_binheader_writef(psf, "44b", 1, __cil_tmp16, sr_name, __cil_tmp17);
  }
#line 224
  if (psf->sf.samplerate > 65535) {
    {
#line 225
    psf_binheader_writef(psf, "44", 262150, psf->sf.samplerate);
    }
  } else {
    {
#line 227
    samplerate = (unsigned short )psf->sf.samplerate;
#line 229
    psf_binheader_writef(psf, "422\374\036V", 131076, (int )samplerate, 0);
    }
  }
  {
#line 232
  datasize = (psf->sf.frames * (long )psf->sf.channels) * (long )psf->bytewidth;
#line 234
  psf_binheader_writef(psf, "t484444", 14, datasize + 64L, 6, 8, 6, 0);
#line 235
  psf_binheader_writef(psf, "t4448", 5, 8, psf->sf.channels, psf->sf.frames);
#line 236
  __cil_tmp19 = strlen(wd_name);
  }
  {
#line 236
  __cil_tmp20 = strlen(wd_name);
#line 236
  psf_binheader_writef(psf, "44b", 1, __cil_tmp19, wd_name, __cil_tmp20);
#line 238
  datasize = (psf->sf.frames * (long )psf->sf.channels) * (long )psf->bytewidth;
  }
#line 239
  if (datasize > 2147483647L) {
#line 240
    datasize = (sf_count_t )2147483647;
  }
  {
#line 242
  psf_binheader_writef(psf, "t48", encoding, datasize);
#line 245
  psf_fwrite((unsigned char *)psf->header, (sf_count_t )psf->headindex, (sf_count_t )1,
             psf);
  }
#line 247
  if (psf->error) {
#line 248
    return (psf->error);
  }
#line 250
  psf->dataoffset = (sf_count_t )psf->headindex;
#line 252
  if (current > 0L) {
    {
#line 253
    psf_fseek(psf, current, 0);
    }
  }
#line 255
  return (psf->error);
}
}
#line 259 "/root/libsndfile/src/mat5.c"
static int mat5_read_header(SF_PRIVATE *psf ) 
{ 
  char name[32] ;
  short version ;
  short endian ;
  int type ;
  int flags1 ;
  int flags2 ;
  int rows ;
  int cols ;
  unsigned int size ;
  unsigned long __cil_tmp11 ;
  char *__cil_tmp12 ;
  __uint16_t __cil_tmp13 ;
  __uint16_t __cil_tmp14 ;
  __uint16_t __cil_tmp15 ;
  char const   *tmp ;
  double samplerate ;
  long __cil_tmp18 ;
  unsigned short samplerate___0 ;
  sf_count_t __cil_tmp20 ;

  {
  {
#line 265
  psf_binheader_readf(psf, "pb", 0, (char *)psf->u.cbuf, 124);
#line 267
  psf->u.scbuf[125] = (signed char )0;
#line 269
  __cil_tmp11 = strlen((char const   *)((char *)psf->u.cbuf));
  }
#line 269
  if (__cil_tmp11 >= 124UL) {
#line 270
    return (17);
  }
  {
#line 272
  __cil_tmp12 = strstr((char const   *)((char *)psf->u.cbuf), "MATLAB 5.0 MAT-file");
  }
#line 272
  if (__cil_tmp12 == (char *)psf->u.cbuf) {
    {
#line 273
    psf_log_printf(psf, "%s\n", (signed char *)psf->u.scbuf);
    }
  }
  {
#line 276
  psf_binheader_readf(psf, "E22", & version, & endian);
  }
#line 278
  if ((int )endian == (77 << 8) + 73) {
#line 279
    psf->rwf_endian = 536870912;
#line 279
    psf->endian = psf->rwf_endian;
#line 280
    if (1) {
      {
#line 280
      __cil_tmp13 = __bswap_16((__uint16_t )version);
#line 280
      version = (short )__cil_tmp13;
      }
    }
  } else
#line 282
  if ((int )endian == (73 << 8) + 77) {
#line 283
    psf->rwf_endian = 268435456;
#line 283
    psf->endian = psf->rwf_endian;
#line 284
    if (0) {
      {
#line 284
      __cil_tmp14 = __bswap_16((__uint16_t )version);
#line 284
      version = (short )__cil_tmp14;
      }
    }
  } else {
#line 287
    return (126);
  }
#line 289
  if ((int )endian == (73 << 8) + 77) {
    {
#line 291
    __cil_tmp15 = __bswap_16((__uint16_t )version);
#line 291
    version = (short )__cil_tmp15;
    }
  }
  {
#line 293
  psf_log_printf(psf, "Version : 0x%04X\n", (int )version);
  }
#line 294
  if (psf->endian == 268435456) {
#line 294
    tmp = "Little";
  } else {
#line 294
    tmp = "Big\374\036V";
  }
  {
#line 294
  psf_log_printf(psf, "Endian  : 0x%04X => %s\n", (int )endian, tmp);
#line 298
  psf_binheader_readf(psf, "44", & type, & size);
#line 299
  psf_log_printf(psf, "Block\n Type : %X    Size : %d\n", type, size);
  }
#line 301
  if (type != 14) {
#line 302
    return (127);
  }
  {
#line 304
  psf_binheader_readf(psf, "44p\374\036V", & type, & size);
#line 305
  psf_log_printf(psf, "    Type : %X    Size : %d\n", type, size);
  }
#line 307
  if (type != 6) {
#line 308
    return (127);
  }
  {
#line 310
  psf_binheader_readf(psf, "44\214\374\036V", & flags1, & flags2);
#line 311
  psf_log_printf(psf, "    Flg1 : %X    Flg2 : %d\n", flags1, flags2);
#line 313
  psf_binheader_readf(psf, "44", & type, & size);
#line 314
  psf_log_printf(psf, "    Type : %X    Size : %d\n\374\036V", type, size);
  }
#line 316
  if (type != 5) {
#line 317
    return (127);
  }
  {
#line 319
  psf_binheader_readf(psf, "44", & rows, & cols);
#line 320
  psf_log_printf(psf, "    Rows : %X    Cols : %d\n\374\036V", rows, cols);
  }
#line 322
  if (rows != 1) {
#line 323
    return (128);
  } else
#line 322
  if (cols != 1) {
#line 323
    return (128);
  }
  {
#line 325
  psf_binheader_readf(psf, "4", & type);
  }
#line 327
  if (type == 1) {
    {
#line 328
    psf_binheader_readf(psf, "4", & size);
#line 329
    psf_log_printf(psf, "    Type : %X    Size : %d\n", type, size);
    }
#line 330
    if (size > (unsigned int )((int )sizeof(name) - 1)) {
      {
#line 331
      psf_log_printf(psf, "Error : Bad name length.\n");
      }
#line 332
      return (127);
    }
    {
#line 335
    psf_binheader_readf(psf, "bj", (char *)name, size, (8U - size % 8U) % 8U);
#line 336
    name[size] = (char )0;
    }
  } else
#line 338
  if ((type & 65535) == 1) {
#line 339
    size = (unsigned int )(type >> 16);
#line 340
    if (size > 4U) {
      {
#line 341
      psf_log_printf(psf, "Error : Bad name length.\n");
      }
#line 342
      return (127);
    }
    {
#line 345
    psf_log_printf(psf, "    Type : %X\n", type);
#line 346
    psf_binheader_readf(psf, "4", & name);
#line 347
    name[size] = (char )0;
    }
  } else {
#line 350
    return (127);
  }
  {
#line 352
  psf_log_printf(psf, "    Name : %s\n", (char *)name);
#line 356
  psf_binheader_readf(psf, "44\214\374\036V", & type, & size);
  }
  {
#line 359
  if (type == 9) {
#line 359
    goto case_9;
  }
#line 370
  if (type == 131076) {
#line 370
    goto case_131076;
  }
#line 379
  if (type == 262150) {
#line 379
    goto case_262150;
  }
#line 384
  goto switch_default;
  case_9: /* CIL Label */ 
  {
#line 362
  psf_binheader_readf(psf, "dC\214\374\036V", & samplerate);
#line 363
  snprintf((char *)name, sizeof(name), "%f\n\374\036V", samplerate);
#line 364
  psf_log_printf(psf, "    Val  : %s\n", (char *)name);
#line 366
  __cil_tmp18 = lrint(samplerate);
#line 366
  psf->sf.samplerate = (int )__cil_tmp18;
  }

#line 368
  goto switch_break;
  case_131076: /* CIL Label */ 
  {
#line 373
  psf_binheader_readf(psf, "j2j", - 4, & samplerate___0, 2);
#line 374
  psf_log_printf(psf, "    Val  : %u\n", (int )samplerate___0);
#line 375
  psf->sf.samplerate = (int )samplerate___0;
  }
#line 377
  goto switch_break;
  case_262150: /* CIL Label */ 
  {
#line 380
  psf_log_printf(psf, "    Val  : %u\n", size);
  }
#line 381
  psf->sf.samplerate = (int )size;
#line 382
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 385
  psf_log_printf(psf, "    Type : %X    Size : %d  ***\n\230\001", type, size);
  }
#line 386
  return (128);
  switch_break: /* CIL Label */ ;
  }
  {
#line 392
  psf_binheader_readf(psf, "44\214\374\036V", & type, & size);
#line 393
  psf_log_printf(psf, " Type : %X    Size : %d\n\230\001", type, size);
  }
#line 395
  if (type != 14) {
#line 396
    return (127);
  }
  {
#line 398
  psf_binheader_readf(psf, "44\214\374\036V", & type, & size);
#line 399
  psf_log_printf(psf, "    Type : %X    Size : %d\n\374\036V", type, size);
  }
#line 401
  if (type != 6) {
#line 402
    return (127);
  }
  {
#line 404
  psf_binheader_readf(psf, "44\214\374\036V", & flags1, & flags2);
#line 405
  psf_log_printf(psf, "    Flg1 : %X    Flg2 : %d\n\374\036V", flags1, flags2);
#line 407
  psf_binheader_readf(psf, "44\214\374\036V", & type, & size);
#line 408
  psf_log_printf(psf, "    Type : %X    Size : %d\n\374\036V", type, size);
  }
#line 410
  if (type != 5) {
#line 411
    return (127);
  }
  {
#line 413
  psf_binheader_readf(psf, "44\214\374\036V", & rows, & cols);
#line 414
  psf_log_printf(psf, "    Rows : %X    Cols : %d\n\374\036V", rows, cols);
#line 416
  psf_binheader_readf(psf, "4\337\214\374\036V", & type);
  }
#line 418
  if (type == 1) {
    {
#line 419
    psf_binheader_readf(psf, "4", & size);
#line 420
    psf_log_printf(psf, "    Type : %X    Size : %d\n\374\036V", type, size);
    }
#line 421
    if (size > (unsigned int )((int )sizeof(name) - 1)) {
      {
#line 422
      psf_log_printf(psf, "Error : Bad name length.\n");
      }
#line 423
      return (127);
    }
    {
#line 426
    psf_binheader_readf(psf, "bj", (char *)name, size, (8U - size % 8U) % 8U);
#line 427
    name[size] = (char )0;
    }
  } else
#line 429
  if ((type & 65535) == 1) {
#line 430
    size = (unsigned int )(type >> 16);
#line 431
    if (size > 4U) {
      {
#line 432
      psf_log_printf(psf, "Error : Bad name length.\n");
      }
#line 433
      return (127);
    }
    {
#line 436
    psf_log_printf(psf, "    Type : %X\n", type);
#line 437
    psf_binheader_readf(psf, "4", & name);
#line 438
    name[size] = (char )0;
    }
  } else {
#line 441
    return (127);
  }
  {
#line 443
  psf_log_printf(psf, "    Name : %s\n", (char *)name);
#line 445
  psf_binheader_readf(psf, "44\214\374\036V", & type, & size);
#line 446
  psf_log_printf(psf, "    Type : %X    Size : %d\n", type, size);
  }
#line 450
  if (rows == 0) {
#line 450
    if (cols == 0) {
      {
#line 451
      psf_log_printf(psf, "*** Error : zero channel count.\n\220");
      }
#line 452
      return (32);
    }
  }
#line 455
  psf->sf.channels = rows;
#line 456
  psf->sf.frames = (sf_count_t )cols;
#line 458
  psf->sf.format = psf->endian | 851968;
  {
#line 461
  if (type == 9) {
#line 461
    goto case_9___0;
  }
#line 467
  if (type == 7) {
#line 467
    goto case_7;
  }
#line 473
  if (type == 5) {
#line 473
    goto case_5;
  }
#line 479
  if (type == 3) {
#line 479
    goto case_3;
  }
#line 485
  if (type == 2) {
#line 485
    goto case_2;
  }
#line 491
  goto switch_default___0;
  case_9___0: /* CIL Label */ 
  {
#line 462
  psf_log_printf(psf, "Data type : double\n");
  }
#line 463
  psf->sf.format |= 7;
#line 464
  psf->bytewidth = 8;
#line 465
  goto switch_break___0;
  case_7: /* CIL Label */ 
  {
#line 468
  psf_log_printf(psf, "Data type : float\n");
  }
#line 469
  psf->sf.format |= 6;
#line 470
  psf->bytewidth = 4;
#line 471
  goto switch_break___0;
  case_5: /* CIL Label */ 
  {
#line 474
  psf_log_printf(psf, "Data type : 32 bit PCM\n");
  }
#line 475
  psf->sf.format |= 4;
#line 476
  psf->bytewidth = 4;
#line 477
  goto switch_break___0;
  case_3: /* CIL Label */ 
  {
#line 480
  psf_log_printf(psf, "Data type : 16 bit PCM\n");
  }
#line 481
  psf->sf.format |= 2;
#line 482
  psf->bytewidth = 2;
#line 483
  goto switch_break___0;
  case_2: /* CIL Label */ 
  {
#line 486
  psf_log_printf(psf, "Data type : unsigned 8 bit PCM\n");
  }
#line 487
  psf->sf.format |= 5;
#line 488
  psf->bytewidth = 1;
#line 489
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 492
  psf_log_printf(psf, "*** Error : Bad marker %08X\n", type);
  }
#line 493
  return (17);
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 496
  psf->dataoffset = psf_ftell(psf);
#line 497
  psf->datalength = psf->filelength - psf->dataoffset;
  }
#line 499
  return (0);
}
}
#line 62 "/root/libsndfile/src/mat4.c"
static int mat4_close(SF_PRIVATE *psf ) ;
#line 64
static int mat4_format_to_encoding(int format , int endian ) ;
#line 66
static int mat4_write_header(SF_PRIVATE *psf , int calc_length ) ;
#line 67
static int mat4_read_header(SF_PRIVATE *psf ) ;
#line 69
static char const   *mat4_marker_to_str(int marker ) ;
#line 76 "/root/libsndfile/src/mat4.c"
int mat4_open(SF_PRIVATE *psf ) 
{ 
  int subformat ;
  int error ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
#line 77
  error = 0;
#line 79
  if (psf->mode == 16) {
    _L: /* CIL Label */ 
    {
#line 80
    error = mat4_read_header(psf);
    }
#line 80
    if (error) {
#line 81
      return (error);
    }
  } else
#line 79
  if (psf->mode == 48) {
#line 79
    if (psf->filelength > 0L) {
#line 79
      goto _L;
    }
  }

#line 84
  if ((psf->sf.format & 268369920) != 786432) {
#line 85
    return (1);
  }
#line 87
  subformat = psf->sf.format & 65535;
#line 89
  if (psf->mode == 32) {
    _L___35: /* CIL Label */ 
#line 90
    if (psf->is_pipe) {
#line 91
      return (28);
    }
#line 93
    psf->endian = psf->sf.format & 805306368;
#line 94
    if (psf->endian == 805306368) {
#line 95
      psf->endian = 268435456;
    } else
#line 94
    if (psf->endian == 0) {
#line 95
      psf->endian = 268435456;
    } else
#line 96
    if (0) {
#line 97
      psf->endian = 536870912;
    }
    {
#line 99
    error = mat4_write_header(psf, 0);
    }
#line 99
    if (error) {
#line 100
      return (error);
    }
#line 102
    psf->write_header = & mat4_write_header;
  } else
#line 89
  if (psf->mode == 48) {
#line 89
    goto _L___35;
  }
#line 105
  psf->container_close = & mat4_close;
#line 107
  psf->blockwidth = psf->bytewidth * psf->sf.channels;
  {
#line 111
  if (subformat == 4) {
#line 111
    goto case_4;
  }
#line 111
  if (subformat == 2) {
#line 111
    goto case_4;
  }
#line 115
  if (subformat == 6) {
#line 115
    goto case_6;
  }
#line 119
  if (subformat == 7) {
#line 119
    goto case_7;
  }
#line 123
  goto switch_default;
  case_4: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 112
  error = pcm_init(psf);
  }
#line 113
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 116
  error = float32_init(psf);
  }
#line 117
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 120
  error = double64_init(psf);
  }
#line 121
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 123
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }

#line 126
  if (error) {
#line 127
    return (error);
  }
#line 129
  return (error);
}
}
#line 136 "/root/libsndfile/src/mat4.c"
static int mat4_close(SF_PRIVATE *psf ) 
{ 


  {
#line 138
  if (psf->mode == 32) {
    {
    {
#line 139
    mat4_write_header(psf, 1);
    }
    }
  } else
#line 138
  if (psf->mode == 48) {
    {
    {
#line 139
    mat4_write_header(psf, 1);
    }
    }
  }
#line 141
  return (0);
}
}
#line 148 "/root/libsndfile/src/mat4.c"
static int mat4_write_header(SF_PRIVATE *psf , int calc_length ) 
{ 
  sf_count_t current ;
  int encoding ;
  double samplerate ;
  sf_count_t __cil_tmp6 ;
  sf_count_t __cil_tmp7 ;
  int __cil_tmp8 ;
  size_t __cil_tmp9 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;
  size_t __cil_tmp12 ;

  {
  {
#line 153
  current = psf_ftell(psf);
  }
#line 155
  if (calc_length) {
    {
#line 156
    psf->filelength = psf_get_filelen(psf);
#line 158
    psf->datalength = psf->filelength - psf->dataoffset;
    }
#line 159
    if (psf->dataend) {
#line 160
      psf->datalength -= psf->filelength - psf->dataend;
    }
#line 162
    psf->sf.frames = psf->datalength / (long )(psf->bytewidth * psf->sf.channels);
  }
  {
#line 165
  encoding = mat4_format_to_encoding(psf->sf.format & 65535, psf->endian);
  }
#line 167
  if (encoding == -1) {
#line 168
    return (1);
  }
  {
#line 171
  psf->header[0] = (unsigned char )0;
#line 172
  psf->headindex = 0;
#line 173
  psf_fseek(psf, (sf_count_t )0, 0);
#line 176
  samplerate = (double )psf->sf.samplerate;
  }
#line 178
  if (psf->endian == 536870912) {
    {
#line 179
    psf_binheader_writef(psf, "Em444", (3 << 16) | (232 << 24), 1, 1, 0);
#line 180
    __cil_tmp9 = make_size_t(11);
#line 180
    psf_binheader_writef(psf, "E4bd", 11, "samplerate\254\374\036V", __cil_tmp9, samplerate);
#line 181
    psf_binheader_writef(psf, "tEm484", encoding, psf->sf.channels, psf->sf.frames,
                         0);
#line 182
    __cil_tmp10 = make_size_t(9);
#line 182
    psf_binheader_writef(psf, "E4b\374\036V", 9, "wavedata\230", __cil_tmp10);
    }
  } else
#line 184
  if (psf->endian == 268435456) {
    {
#line 185
    psf_binheader_writef(psf, "em444", 0, 1, 1, 0);
#line 186
    __cil_tmp11 = make_size_t(11);
#line 186
    psf_binheader_writef(psf, "e4bd\036V", 11, "samplerate\254\374\036V", __cil_tmp11,
                         samplerate);
#line 187
    psf_binheader_writef(psf, "tem484", encoding, psf->sf.channels, psf->sf.frames,
                         0);
#line 188
    __cil_tmp12 = make_size_t(9);
#line 188
    psf_binheader_writef(psf, "e4b", 9, "wavedata\230", __cil_tmp12);
    }
  } else {
#line 191
    return (1);
  }
  {
#line 194
  psf_fwrite((unsigned char *)psf->header, (sf_count_t )psf->headindex, (sf_count_t )1,
             psf);
  }
#line 196
  if (psf->error) {
#line 197
    return (psf->error);
  }
#line 199
  psf->dataoffset = (sf_count_t )psf->headindex;
#line 201
  if (current > 0L) {
    {
#line 202
    psf_fseek(psf, current, 0);
    }
  }
#line 204
  return (psf->error);
}
}
#line 208 "/root/libsndfile/src/mat4.c"
static int mat4_read_header(SF_PRIVATE *psf ) 
{ 
  int marker ;
  int rows ;
  int cols ;
  int imag ;
  unsigned int namesize ;
  double value ;
  char const   *marker_str ;
  char name[64] ;
  char const   *tmp ;
  long __cil_tmp11 ;
  char const   *__cil_tmp12 ;
  char const   *tmp___0 ;
  sf_count_t __cil_tmp14 ;

  {
  {
#line 215
  psf_binheader_readf(psf, "pm\254\374\036V", 0, & marker);
  }
#line 218
  if (marker == ((3 << 16) | (232 << 24))) {
#line 219
    psf->rwf_endian = 536870912;
#line 219
    psf->endian = psf->rwf_endian;
#line 220
    marker_str = "big endian doubleD\254\374\036V";
  } else
#line 222
  if (marker == 0) {
#line 223
    psf->rwf_endian = 268435456;
#line 223
    psf->endian = psf->rwf_endian;
#line 224
    marker_str = "little endian double";
  } else {
#line 227
    return (17);
  }
  {
#line 229
  psf_log_printf(psf, "GNU Octave 2.0 / MATLAB v4.2 format\nMarker : %s\n\230\001",
                 marker_str);
#line 231
  psf_binheader_readf(psf, "444\374\036V", & rows, & cols, & imag);
  }
#line 233
  if (imag) {
#line 233
    tmp = "True";
  } else {
#line 233
    tmp = "False";
  }
  {
#line 233
  psf_log_printf(psf, " Rows  : %d\n Cols  : %d\n Imag  : %s\n", rows, cols, tmp);
#line 235
  psf_binheader_readf(psf, "4(\254\374\036V", & namesize);
  }
#line 237
  if (namesize >= (unsigned int )((int )sizeof(name))) {
#line 238
    return (124);
  }
  {
#line 240
  psf_binheader_readf(psf, "b\'\254\374\036V", (char *)name, namesize);
#line 241
  name[namesize] = (char )0;
#line 243
  psf_log_printf(psf, " Name  : %s\n", (char *)name);
#line 245
  psf_binheader_readf(psf, "d", & value);
#line 247
  snprintf((char *)psf->u.cbuf, sizeof(psf->u.cbuf), " Value : %f\n\036V", value);
#line 248
  psf_log_printf(psf, (char const   *)((char *)psf->u.cbuf));
  }
#line 250
  if (rows != 1) {
#line 251
    return (125);
  } else
#line 250
  if (cols != 1) {
#line 251
    return (125);
  }
  {
#line 253
  __cil_tmp11 = lrint(value);
#line 253
  psf->sf.samplerate = (int )__cil_tmp11;
#line 257
  psf_binheader_readf(psf, "m", & marker);
#line 259
  __cil_tmp12 = mat4_marker_to_str(marker);
#line 259
  psf_log_printf(psf, "Marker : %s\n", __cil_tmp12);
#line 261
  psf_binheader_readf(psf, "444", & rows, & cols, & imag);
  }
#line 263
  if (imag) {
#line 263
    tmp___0 = "True";
  } else {
#line 263
    tmp___0 = "False";
  }
  {
#line 263
  psf_log_printf(psf, " Rows  : %d\n Cols  : %d\n Imag  : %s\n", rows, cols, tmp___0);
#line 265
  psf_binheader_readf(psf, "4", & namesize);
  }
#line 267
  if (namesize >= (unsigned int )((int )sizeof(name))) {
#line 268
    return (124);
  }
  {
#line 270
  psf_binheader_readf(psf, "b", (char *)name, namesize);
#line 271
  name[namesize] = (char )0;
#line 273
  psf_log_printf(psf, " Name  : %s\n", (char *)name);
#line 275
  psf->dataoffset = psf_ftell(psf);
  }
#line 277
  if (rows == 0) {
#line 277
    if (cols == 0) {
      {
#line 278
      psf_log_printf(psf, "*** Error : zero channel count.\n\220");
      }
#line 279
      return (32);
    }
  }
#line 282
  psf->sf.channels = rows;
#line 283
  psf->sf.frames = (sf_count_t )cols;
#line 285
  psf->sf.format = psf->endian | 786432;
  {
#line 288
  if (marker == 0) {
#line 288
    goto case_0;
  }
#line 288
  if (marker == ((3 << 16) | (232 << 24))) {
#line 288
    goto case_0;
  }
#line 294
  if (marker == 10) {
#line 294
    goto case_10;
  }
#line 294
  if (marker == ((3 << 16) | (242 << 24))) {
#line 294
    goto case_10;
  }
#line 300
  if (marker == 20) {
#line 300
    goto case_20;
  }
#line 300
  if (marker == ((3 << 16) | (252 << 24))) {
#line 300
    goto case_20;
  }
#line 306
  if (marker == 30) {
#line 306
    goto case_30;
  }
#line 306
  if (marker == ((4 << 16) | (6 << 24))) {
#line 306
    goto case_30;
  }
#line 311
  goto switch_default;
  case_0: /* CIL Label */ 
  case_exp: /* CIL Label */ 
#line 289
  psf->sf.format |= 7;
#line 290
  psf->bytewidth = 8;
#line 291
  goto switch_break;
  case_10: /* CIL Label */ 
  case_exp___0: /* CIL Label */ 
#line 295
  psf->sf.format |= 6;
#line 296
  psf->bytewidth = 4;
#line 297
  goto switch_break;
  case_20: /* CIL Label */ 
  case_exp___1: /* CIL Label */ 
#line 301
  psf->sf.format |= 4;
#line 302
  psf->bytewidth = 4;
#line 303
  goto switch_break;
  case_30: /* CIL Label */ 
  case_exp___2: /* CIL Label */ 
#line 307
  psf->sf.format |= 2;
#line 308
  psf->bytewidth = 2;
#line 309
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 312
  psf_log_printf(psf, "*** Error : Bad marker %08X\n", marker);
  }
#line 313
  return (17);
  switch_break: /* CIL Label */ ;
  }

#line 316
  if (psf->filelength - psf->dataoffset < ((long )psf->sf.channels * psf->sf.frames) * (long )psf->bytewidth) {
    {
#line 317
    psf_log_printf(psf, "*** File seems to be truncated. %D <--> %D\n", psf->filelength - psf->dataoffset,
                   ((long )psf->sf.channels * psf->sf.frames) * (long )psf->bytewidth);
    }
  } else
#line 320
  if (psf->filelength - psf->dataoffset > ((long )psf->sf.channels * psf->sf.frames) * (long )psf->bytewidth) {
#line 321
    psf->dataend = psf->dataoffset + (long )((rows * cols) * psf->bytewidth);
  }
#line 323
  psf->datalength = (psf->filelength - psf->dataoffset) - psf->dataend;
#line 325
  psf->sf.sections = 1;
#line 327
  return (0);
}
}
#line 331 "/root/libsndfile/src/mat4.c"
static int mat4_format_to_encoding(int format , int endian ) 
{ 


  {
  {
#line 334
  if ((format | endian) == 536870914) {
#line 334
    goto case_536870914;
  }
#line 337
  if ((format | endian) == 268435458) {
#line 337
    goto case_268435458;
  }
#line 340
  if ((format | endian) == 536870916) {
#line 340
    goto case_536870916;
  }
#line 343
  if ((format | endian) == 268435460) {
#line 343
    goto case_268435460;
  }
#line 346
  if ((format | endian) == 536870918) {
#line 346
    goto case_536870918;
  }
#line 349
  if ((format | endian) == 268435462) {
#line 349
    goto case_268435462;
  }
#line 352
  if ((format | endian) == 536870919) {
#line 352
    goto case_536870919;
  }
#line 355
  if ((format | endian) == 268435463) {
#line 355
    goto case_268435463;
  }
#line 358
  goto switch_default;
  case_536870914: /* CIL Label */ 
#line 335
  return ((4 << 16) | (6 << 24));
  case_268435458: /* CIL Label */ 
#line 338
  return (30);
  case_536870916: /* CIL Label */ 
#line 341
  return ((3 << 16) | (252 << 24));
  case_268435460: /* CIL Label */ 
#line 344
  return (20);
  case_536870918: /* CIL Label */ 
#line 347
  return ((3 << 16) | (242 << 24));
  case_268435462: /* CIL Label */ 
#line 350
  return (10);
  case_536870919: /* CIL Label */ 
#line 353
  return ((3 << 16) | (232 << 24));
  case_268435463: /* CIL Label */ 
#line 356
  return (0);
  switch_default: /* CIL Label */ 
#line 358
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }

#line 361
  return (- 1);
}
}
#line 365 "/root/libsndfile/src/mat4.c"
static char const   *mat4_marker_to_str(int marker ) 
{ 
  static char str[32] ;

  {
  {
#line 370
  if (marker == ((4 << 16) | (6 << 24))) {
#line 370
    goto case_exp;
  }
#line 371
  if (marker == 30) {
#line 371
    goto case_30;
  }
#line 373
  if (marker == ((3 << 16) | (252 << 24))) {
#line 373
    goto case_exp___0;
  }
#line 374
  if (marker == 20) {
#line 374
    goto case_20;
  }
#line 377
  if (marker == ((3 << 16) | (242 << 24))) {
#line 377
    goto case_exp___1;
  }
#line 378
  if (marker == 10) {
#line 378
    goto case_10;
  }
#line 380
  if (marker == ((3 << 16) | (232 << 24))) {
#line 380
    goto case_exp___2;
  }
#line 381
  if (marker == 0) {
#line 381
    goto case_0;
  }
#line 368
  goto switch_break;
  case_exp: /* CIL Label */ 
#line 370
  return ("big endian 16 bit PCMV");
  case_30: /* CIL Label */ 
#line 371
  return ("little endian 16 bit PCM\220");
  case_exp___0: /* CIL Label */ 
#line 373
  return ("big endian 32 bit PCMV");
  case_20: /* CIL Label */ 
#line 374
  return ("little endian 32 bit PCM\220");
  case_exp___1: /* CIL Label */ 
#line 377
  return ("big endian float\220");
  case_10: /* CIL Label */ 
#line 378
  return ("big endian float\220");
  case_exp___2: /* CIL Label */ 
#line 380
  return ("big endian double\315\254\374\036V");
  case_0: /* CIL Label */ 
#line 381
  return ("little endian double\036V");
  switch_break: /* CIL Label */ ;
  }
  {
#line 385
  str[sizeof(str) - 1UL] = (char )0;
#line 386
  snprintf((char *)str, sizeof(str) - 1UL, "%08X\036V", marker);
  }
#line 387
  return ((char const   *)((char *)str));
}
}
#line 32 "/root/libsndfile/src/macos.c"
int macos_guess_file_type(SF_PRIVATE *psf , char const   *filename ) 
{ 
  static char rsrc_name[1024] ;
  struct stat statbuf ;
  int __cil_tmp5 ;

  {
  {
#line 36
  snprintf((char *)rsrc_name, sizeof(rsrc_name), "%s/rsrc", filename);
#line 39
  __cil_tmp5 = stat((char const   *)((char *)rsrc_name), & statbuf);
  }
#line 39
  if (__cil_tmp5 != 0) {
    {
#line 40
    psf_log_printf(psf, "No resource fork.\n");
    }
#line 41
    return (0);
  }

#line 44
  if (statbuf.st_size == 0L) {
    {
#line 45
    psf_log_printf(psf, "Have zero size resource fork.\n");
    }
#line 46
    return (0);
  }

#line 49
  return (0);
}
}
#line 39 "/root/libsndfile/src/macbinary3.c"
int macbinary3_open(SF_PRIVATE *UNUSED_psf ) 
{ 


  {
#line 41
  return (0);
}
}
#line 66 "/root/libsndfile/src/ircam.c"
static int ircam_close(SF_PRIVATE *psf ) ;
#line 67
static int ircam_write_header(SF_PRIVATE *psf , int UNUSED_calc_length ) ;
#line 68
static int ircam_read_header(SF_PRIVATE *psf ) ;
#line 70
static int get_encoding(int subformat ) ;
#line 72
static char const   *get_encoding_str(int encoding ) ;
#line 79 "/root/libsndfile/src/ircam.c"
int ircam_open(SF_PRIVATE *psf ) 
{ 
  int subformat ;
  int error ;
  int __cil_tmp4 ;
  int tmp ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
#line 81
  error = 0;
#line 83
  if (psf->mode == 16) {
    _L: /* CIL Label */ 
    {
#line 84
    error = ircam_read_header(psf);
    }
#line 84
    if (error) {
#line 85
      return (error);
    }
  } else
#line 83
  if (psf->mode == 48) {
#line 83
    if (psf->filelength > 0L) {
#line 83
      goto _L;
    }
  }
#line 88
  subformat = psf->sf.format & 65535;
#line 90
  if (psf->mode == 32) {
    _L___36: /* CIL Label */ 
#line 91
    if ((psf->sf.format & 268369920) != 655360) {
#line 92
      return (1);
    }
#line 94
    psf->endian = psf->sf.format & 805306368;
#line 95
    if (psf->endian == 0) {
#line 96
      tmp = 268435456;
#line 96
      psf->endian = tmp;
    } else
#line 95
    if (psf->endian == 805306368) {
#line 96
      tmp = 268435456;
#line 96
      psf->endian = tmp;
    }
    {
#line 98
    psf->dataoffset = (sf_count_t )1024;
#line 100
    error = ircam_write_header(psf, 0);
    }
#line 100
    if (error) {
#line 101
      return (error);
    }
#line 103
    psf->write_header = & ircam_write_header;
  } else
#line 90
  if (psf->mode == 48) {
#line 90
    goto _L___36;
  }
#line 106
  psf->container_close = & ircam_close;
  {
#line 109
  if (subformat == 16) {
#line 109
    goto case_16;
  }
#line 113
  if (subformat == 17) {
#line 113
    goto case_17;
  }
#line 118
  if (subformat == 4) {
#line 118
    goto case_4;
  }
#line 118
  if (subformat == 2) {
#line 118
    goto case_4;
  }
#line 122
  if (subformat == 6) {
#line 122
    goto case_6;
  }
#line 126
  goto switch_default;
  case_16: /* CIL Label */ 
  {
#line 110
  error = ulaw_init(psf);
  }
#line 111
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 114
  error = alaw_init(psf);
  }
#line 115
  goto switch_break;
  case_4: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 119
  error = pcm_init(psf);
  }
#line 120
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 123
  error = float32_init(psf);
  }
#line 124
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 126
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }

#line 129
  return (error);
}
}
#line 136 "/root/libsndfile/src/ircam.c"
static int ircam_read_header(SF_PRIVATE *psf ) 
{ 
  unsigned int marker ;
  unsigned int encoding ;
  float samplerate ;
  int error ;
  char const   *__cil_tmp6 ;

  {
  {
#line 139
  error = 0;
#line 141
  psf_binheader_readf(psf, "epmf44", 0, & marker, & samplerate, & psf->sf.channels,
                      & encoding);
  }
#line 143
  if ((marker & (unsigned int )((255 | (255 << 8)) | (255 << 24))) != (unsigned int )(100 | (163 << 8))) {
#line 143
    if ((marker & (unsigned int )((255 | (255 << 16)) | (255 << 24))) != (unsigned int )((163 << 16) | (100 << 24))) {
      {
#line 144
      psf_log_printf(psf, "marker: 0x%X\n", marker);
      }
#line 145
      return (114);
    }
  }
#line 148
  psf->endian = 268435456;
#line 150
  if (psf->sf.channels > 256) {
    {
#line 151
    psf_binheader_readf(psf, "Epmf44", 0, & marker, & samplerate, & psf->sf.channels,
                        & encoding);
    }
#line 154
    if (psf->sf.channels > 256) {
      {
#line 155
      psf_log_printf(psf, "marker: 0x%X\n", marker);
      }
#line 156
      return (115);
    }
#line 159
    psf->endian = 536870912;
  }
  {
#line 162
  psf_log_printf(psf, "marker: 0x%X\nV", marker);
#line 164
  psf->sf.samplerate = (int )samplerate;
#line 166
  __cil_tmp6 = get_encoding_str((int )encoding);
#line 166
  psf_log_printf(psf, "  Sample Rate : %d\n  Channels    : %d\n  Encoding    : %X => %s\n",
                 psf->sf.samplerate, psf->sf.channels, encoding, __cil_tmp6);
  }
  {
#line 171
  if (encoding == (unsigned int )2) {
#line 171
    goto case_2;
  }
#line 178
  if (encoding == (unsigned int )262148) {
#line 178
    goto case_262148;
  }
#line 185
  if (encoding == (unsigned int )4) {
#line 185
    goto case_4;
  }
#line 192
  if (encoding == (unsigned int )65537) {
#line 192
    goto case_65537;
  }
#line 199
  if (encoding == (unsigned int )131073) {
#line 199
    goto case_131073;
  }
#line 206
  goto switch_default;
  case_2: /* CIL Label */ 
#line 172
  psf->bytewidth = 2;
#line 173
  psf->blockwidth = psf->sf.channels * psf->bytewidth;
#line 175
  psf->sf.format = 655362;
#line 176
  goto switch_break;
  case_262148: /* CIL Label */ 
#line 179
  psf->bytewidth = 4;
#line 180
  psf->blockwidth = psf->sf.channels * psf->bytewidth;
#line 182
  psf->sf.format = 655364;
#line 183
  goto switch_break;
  case_4: /* CIL Label */ 
#line 186
  psf->bytewidth = 4;
#line 187
  psf->blockwidth = psf->sf.channels * psf->bytewidth;
#line 189
  psf->sf.format = 655366;
#line 190
  goto switch_break;
  case_65537: /* CIL Label */ 
#line 193
  psf->bytewidth = 1;
#line 194
  psf->blockwidth = psf->sf.channels * psf->bytewidth;
#line 196
  psf->sf.format = 655377;
#line 197
  goto switch_break;
  case_131073: /* CIL Label */ 
#line 200
  psf->bytewidth = 1;
#line 201
  psf->blockwidth = psf->sf.channels * psf->bytewidth;
#line 203
  psf->sf.format = 655376;
#line 204
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 207
  error = 116;
#line 208
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }

#line 211
  if (psf->endian == 536870912) {
#line 212
    psf->sf.format |= 536870912;
  } else {
#line 214
    psf->sf.format |= 268435456;
  }
#line 216
  if (error) {
#line 217
    return (error);
  }
#line 219
  psf->dataoffset = (sf_count_t )1024;
#line 220
  psf->datalength = psf->filelength - psf->dataoffset;
#line 222
  if (psf->sf.frames == 0L) {
#line 222
    if (psf->blockwidth) {
#line 223
      psf->sf.frames = psf->datalength / (long )psf->blockwidth;
    }
  }
  {
#line 225
  psf_log_printf(psf, "  Samples     : %d\n", psf->sf.frames);
#line 227
  psf_binheader_readf(psf, "p", 1024);
  }
#line 229
  return (0);
}
}
#line 233 "/root/libsndfile/src/ircam.c"
static int ircam_close(SF_PRIVATE *psf ) 
{ 


  {
  {
#line 235
  psf_log_printf(psf, "close\n");
  }
#line 237
  return (0);
}
}
#line 241 "/root/libsndfile/src/ircam.c"
static int ircam_write_header(SF_PRIVATE *psf , int UNUSED_calc_length ) 
{ 
  int encoding ;
  float samplerate ;
  sf_count_t current ;
  sf_count_t __cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 246
  if (psf->pipeoffset > 0L) {
#line 247
    return (0);
  }
  {
#line 249
  current = psf_ftell(psf);
#line 252
  encoding = get_encoding(psf->sf.format & 65535);
  }
#line 254
  if (encoding == 0) {
#line 255
    return (1);
  }
#line 258
  psf->header[0] = (unsigned char )0;
#line 259
  psf->headindex = 0;
#line 261
  if (psf->is_pipe == 0) {
    {
#line 262
    psf_fseek(psf, (sf_count_t )0, 0);
    }
  }
#line 264
  samplerate = (float )psf->sf.samplerate;
  {
#line 267
  if (psf->endian == 536870912) {
#line 267
    goto case_536870912;
  }
#line 272
  if (psf->endian == 268435456) {
#line 272
    goto case_268435456;
  }
#line 277
  goto switch_default;
  case_536870912: /* CIL Label */ 
  {
#line 268
  psf_binheader_writef(psf, "Emf", (100 | (163 << 8)) | (2 << 16), (double )samplerate);
  }
  {
#line 269
  psf_binheader_writef(psf, "E44", psf->sf.channels, encoding);
  }
#line 270
  goto switch_break;
  case_268435456: /* CIL Label */ 
  {
#line 273
  psf_binheader_writef(psf, "emf\374\036V", (100 | (163 << 8)) | (3 << 16), (double )samplerate);
  }
  {
#line 274
  psf_binheader_writef(psf, "e44\374\036V", psf->sf.channels, encoding);
  }
#line 275
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 277
  return (1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 280
  psf_binheader_writef(psf, "z", (size_t )(1024 - psf->headindex));
#line 283
  psf_fwrite((unsigned char *)psf->header, (sf_count_t )psf->headindex, (sf_count_t )1,
             psf);
  }
#line 285
  if (psf->error) {
#line 286
    return (psf->error);
  }
#line 288
  if (current > 0L) {
    {
#line 289
    psf_fseek(psf, current, 0);
    }
  }
#line 291
  return (psf->error);
}
}
#line 295 "/root/libsndfile/src/ircam.c"
static int get_encoding(int subformat ) 
{ 


  {
  {
#line 297
  if (subformat == 2) {
#line 297
    goto case_2;
  }
#line 298
  if (subformat == 4) {
#line 298
    goto case_4;
  }
#line 300
  if (subformat == 6) {
#line 300
    goto case_6;
  }
#line 302
  if (subformat == 16) {
#line 302
    goto case_16;
  }
#line 303
  if (subformat == 17) {
#line 303
    goto case_17;
  }
#line 305
  goto switch_default;
  case_2: /* CIL Label */ 
#line 297
  return (2);
  case_4: /* CIL Label */ 
#line 298
  return (262148);
  case_6: /* CIL Label */ 
#line 300
  return (4);
  case_16: /* CIL Label */ 
#line 302
  return (131073);
  case_17: /* CIL Label */ 
#line 303
  return (65537);
  switch_default: /* CIL Label */ 
#line 305
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }

#line 308
  return (0);
}
}
#line 312 "/root/libsndfile/src/ircam.c"
static char const   *get_encoding_str(int encoding ) 
{ 


  {
  {
#line 314
  if (encoding == 2) {
#line 314
    goto case_2;
  }
#line 315
  if (encoding == 4) {
#line 315
    goto case_4;
  }
#line 316
  if (encoding == 65537) {
#line 316
    goto case_65537;
  }
#line 317
  if (encoding == 131073) {
#line 317
    goto case_131073;
  }
#line 318
  if (encoding == 262148) {
#line 318
    goto case_262148;
  }
#line 313
  goto switch_break;
  case_2: /* CIL Label */ 
#line 314
  return ("16 bit PCM");
  case_4: /* CIL Label */ 
#line 315
  return ("32 bit float");
  case_65537: /* CIL Label */ 
#line 316
  return ("A law");
  case_131073: /* CIL Label */ 
#line 317
  return ("u law");
  case_262148: /* CIL Label */ 
#line 318
  return ("32 bit PCM\365\374\036V");
  switch_break: /* CIL Label */ ;
  }

#line 320
  return ("Unknown encoding\220");
}
}
#line 41 "/root/libsndfile/src/htk.c"
static int htk_close(SF_PRIVATE *psf ) ;
#line 43
static int htk_write_header(SF_PRIVATE *psf , int calc_length ) ;
#line 44
static int htk_read_header(SF_PRIVATE *psf ) ;
#line 51 "/root/libsndfile/src/htk.c"
int htk_open(SF_PRIVATE *psf ) 
{ 
  int subformat ;
  int error ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 53
  error = 0;
#line 55
  if (psf->is_pipe) {
#line 56
    return (137);
  }
#line 58
  if (psf->mode == 16) {
    _L: /* CIL Label */ 
    {
#line 59
    error = htk_read_header(psf);
    }
#line 59
    if (error) {
#line 60
      return (error);
    }
  } else
#line 58
  if (psf->mode == 48) {
#line 58
    if (psf->filelength > 0L) {
#line 58
      goto _L;
    }
  }
#line 63
  subformat = psf->sf.format & 65535;
#line 65
  if (psf->mode == 32) {
    _L___37: /* CIL Label */ 
#line 66
    if ((psf->sf.format & 268369920) != 1048576) {
#line 67
      return (1);
    }
    {
#line 69
    psf->endian = 536870912;
#line 71
    __cil_tmp5 = htk_write_header(psf, 0);
    }
#line 71
    if (__cil_tmp5) {
#line 72
      return (psf->error);
    }
#line 74
    psf->write_header = & htk_write_header;
  } else
#line 65
  if (psf->mode == 48) {
#line 65
    goto _L___37;
  }
#line 77
  psf->container_close = & htk_close;
#line 79
  psf->blockwidth = psf->bytewidth * psf->sf.channels;
  {
#line 82
  if (subformat == 2) {
#line 82
    goto case_2;
  }
#line 86
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 83
  error = pcm_init(psf);
  }
#line 84
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 86
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }

#line 89
  return (error);
}
}
#line 96 "/root/libsndfile/src/htk.c"
static int htk_close(SF_PRIVATE *psf ) 
{ 


  {
#line 98
  if (psf->mode == 32) {
    {
    {
#line 99
    htk_write_header(psf, 1);
    }
    }
  } else
#line 98
  if (psf->mode == 48) {
    {
    {
#line 99
    htk_write_header(psf, 1);
    }
    }
  }
#line 101
  return (0);
}
}
#line 105 "/root/libsndfile/src/htk.c"
static int htk_write_header(SF_PRIVATE *psf , int calc_length ) 
{ 
  sf_count_t current ;
  int sample_count ;
  int sample_period ;
  sf_count_t __cil_tmp6 ;
  sf_count_t __cil_tmp7 ;

  {
  {
#line 109
  current = psf_ftell(psf);
  }
#line 111
  if (calc_length) {
    {
#line 112
    psf->filelength = psf_get_filelen(psf);
    }
  }
  {
#line 115
  psf->header[0] = (unsigned char )0;
#line 116
  psf->headindex = 0;
#line 117
  psf_fseek(psf, (sf_count_t )0, 0);
  }
#line 119
  if (psf->filelength > 12L) {
#line 120
    sample_count = (int )((psf->filelength - 12L) / 2L);
  } else {
#line 122
    sample_count = 0;
  }
  {
#line 124
  sample_period = 10000000 / psf->sf.samplerate;
#line 126
  psf_binheader_writef(psf, "E444\036V", sample_count, sample_period, 131072);
#line 129
  psf_fwrite((unsigned char *)psf->header, (sf_count_t )psf->headindex, (sf_count_t )1,
             psf);
  }
#line 131
  if (psf->error) {
#line 132
    return (psf->error);
  }
#line 134
  psf->dataoffset = (sf_count_t )psf->headindex;
#line 136
  if (current > 0L) {
    {
#line 137
    psf_fseek(psf, current, 0);
    }
  }
#line 139
  return (psf->error);
}
}
#line 186 "/root/libsndfile/src/htk.c"
static int htk_read_header(SF_PRIVATE *psf ) 
{ 
  int sample_count ;
  int sample_period ;
  int marker ;

  {
  {
#line 189
  psf_binheader_readf(psf, "pE444V", 0, & sample_count, & sample_period, & marker);
  }
#line 191
  if ((long )(2 * sample_count + 12) != psf->filelength) {
#line 192
    return (1666);
  }
#line 194
  if (marker != 131072) {
#line 195
    return (1667);
  }
  {
#line 197
  psf->sf.channels = 1;
#line 198
  psf->sf.samplerate = 10000000 / sample_period;
#line 200
  psf_log_printf(psf, "HTK Waveform file\n  Sample Count  : %d\n  Sample Period : %d => %d Hz\nV",
                 sample_count, sample_period, psf->sf.samplerate);
#line 203
  psf->sf.format = 1048578;
#line 204
  psf->bytewidth = 2;
#line 207
  psf->dataoffset = (sf_count_t )12;
#line 208
  psf->endian = 536870912;
#line 210
  psf->datalength = psf->filelength - psf->dataoffset;
#line 212
  psf->blockwidth = psf->sf.channels * psf->bytewidth;
  }
#line 214
  if (! psf->sf.frames) {
#line 214
    if (psf->blockwidth) {
#line 215
      psf->sf.frames = (psf->filelength - psf->dataoffset) / (long )psf->blockwidth;
    }
  }
#line 217
  return (0);
}
}
#line 68 "/root/libsndfile/src/G72x/g72x.h"
struct g72x_state *g72x_reader_init(int codec , int *blocksize , int *samplesperblock ) ;
#line 69
struct g72x_state *g72x_writer_init(int codec , int *blocksize , int *samplesperblock ) ;
#line 75
int g72x_decode_block(struct g72x_state *pstate , unsigned char const   *block , short *samples ) ;
#line 83
int g72x_encode_block(struct g72x_state *pstate , short *samples , unsigned char *block ) ;
#line 48 "/root/libsndfile/src/g72x.c"
static int psf_g72x_decode_block(SF_PRIVATE *psf , G72x_PRIVATE *pg72x ) ;
#line 49
static int psf_g72x_encode_block(SF_PRIVATE *psf , G72x_PRIVATE *pg72x ) ;
#line 51
static sf_count_t g72x_read_s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 52
static sf_count_t g72x_read_i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 53
static sf_count_t g72x_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 54
static sf_count_t g72x_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 56
static sf_count_t g72x_write_s(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 57
static sf_count_t g72x_write_i(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 58
static sf_count_t g72x_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 59
static sf_count_t g72x_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 61
static sf_count_t g72x_seek(SF_PRIVATE *psf , int UNUSED_mode , sf_count_t UNUSED_offset ) ;
#line 63
static int g72x_close(SF_PRIVATE *psf ) ;
#line 71 "/root/libsndfile/src/g72x.c"
int g72x_init(SF_PRIVATE *psf ) 
{ 
  G72x_PRIVATE *pg72x ;
  int bitspersample ;
  int bytesperblock ;
  int codec ;
  void *__cil_tmp6 ;
  sf_count_t __cil_tmp7 ;
  struct g72x_state *__cil_tmp8 ;
  struct g72x_state *__cil_tmp9 ;

  {
#line 75
  if (psf->codec_data != (void *)0) {
    {
#line 76
    psf_log_printf(psf, "*** psf->codec_data is not NULL.\n");
    }
#line 77
    return (29);
  }
#line 80
  psf->sf.seekable = 0;
#line 82
  if (psf->sf.channels != 1) {
#line 83
    return (133);
  }
  {
#line 85
  pg72x = (G72x_PRIVATE *)calloc((unsigned long )1, sizeof(G72x_PRIVATE ));
  }
#line 85
  if (pg72x == (void *)0) {
#line 86
    return (16);
  }
#line 88
  psf->codec_data = (void *)pg72x;
#line 90
  pg72x->block_curr = 0;
#line 91
  pg72x->sample_curr = 0;
  {
#line 94
  if ((psf->sf.format & 65535) == 48) {
#line 94
    goto case_48;
  }
#line 100
  if ((psf->sf.format & 65535) == 49) {
#line 100
    goto case_49;
  }
#line 106
  if ((psf->sf.format & 65535) == 50) {
#line 106
    goto case_50;
  }
#line 112
  goto switch_default;
  case_48: /* CIL Label */ 
#line 95
  codec = 4;
#line 96
  bytesperblock = 60;
#line 97
  bitspersample = 4;
#line 98
  goto switch_break;
  case_49: /* CIL Label */ 
#line 101
  codec = 3;
#line 102
  bytesperblock = 45;
#line 103
  bitspersample = 3;
#line 104
  goto switch_break;
  case_50: /* CIL Label */ 
#line 107
  codec = 5;
#line 108
  bytesperblock = 75;
#line 109
  bitspersample = 5;
#line 110
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 112
  return (17);
  switch_break: /* CIL Label */ ;
  }
  {
#line 115
  psf->bytewidth = 1;
#line 115
  psf->blockwidth = psf->bytewidth;
#line 117
  psf->filelength = psf_get_filelen(psf);
  }
#line 118
  if (psf->filelength < psf->dataoffset) {
#line 119
    psf->filelength = psf->dataoffset;
  }
#line 121
  psf->datalength = psf->filelength - psf->dataoffset;
#line 122
  if (psf->dataend > 0L) {
#line 123
    psf->datalength -= psf->filelength - psf->dataend;
  }
#line 125
  if (psf->mode == 16) {
    {
#line 126
    pg72x->private = g72x_reader_init(codec, & pg72x->blocksize, & pg72x->samplesperblock);
    }
#line 127
    if (pg72x->private == (void *)0) {
#line 128
      return (16);
    }
#line 130
    pg72x->bytesperblock = bytesperblock;
#line 132
    psf->read_short = & g72x_read_s;
#line 133
    psf->read_int = & g72x_read_i;
#line 134
    psf->read_float = & g72x_read_f;
#line 135
    psf->read_double = & g72x_read_d;
#line 137
    psf->seek = & g72x_seek;
#line 139
    if (psf->datalength % (long )pg72x->blocksize) {
      {
#line 140
      psf_log_printf(psf, "*** Odd psf->datalength (%D) should be a multiple of %d\n\230\001",
                     psf->datalength, pg72x->blocksize);
#line 141
      pg72x->blocks_total = (int )(psf->datalength / (long )pg72x->blocksize + 1L);
      }
    } else {
#line 144
      pg72x->blocks_total = (int )(psf->datalength / (long )pg72x->blocksize);
    }
    {
#line 146
    psf->sf.frames = (sf_count_t )(pg72x->blocks_total * pg72x->samplesperblock);
#line 148
    psf_g72x_decode_block(psf, pg72x);
    }
  } else
#line 150
  if (psf->mode == 32) {
    {
#line 151
    pg72x->private = g72x_writer_init(codec, & pg72x->blocksize, & pg72x->samplesperblock);
    }
#line 152
    if (pg72x->private == (void *)0) {
#line 153
      return (16);
    }
#line 155
    pg72x->bytesperblock = bytesperblock;
#line 157
    psf->write_short = & g72x_write_s;
#line 158
    psf->write_int = & g72x_write_i;
#line 159
    psf->write_float = & g72x_write_f;
#line 160
    psf->write_double = & g72x_write_d;
#line 162
    if (psf->datalength % (long )pg72x->blocksize) {
#line 163
      pg72x->blocks_total = (int )(psf->datalength / (long )pg72x->blocksize + 1L);
    } else {
#line 165
      pg72x->blocks_total = (int )(psf->datalength / (long )pg72x->blocksize);
    }
#line 167
    if (psf->datalength > 0L) {
#line 168
      psf->sf.frames = (8L * psf->datalength) / (long )bitspersample;
    }
#line 170
    if ((psf->sf.frames * (long )bitspersample) / 8L != psf->datalength) {
      {
#line 171
      psf_log_printf(psf, "*** Warning : weird psf->datalength.\n");
      }
    }
  }
#line 174
  psf->codec_close = & g72x_close;
#line 176
  return (0);
}
}
#line 184 "/root/libsndfile/src/g72x.c"
static int psf_g72x_decode_block(SF_PRIVATE *psf , G72x_PRIVATE *pg72x ) 
{ 
  int k ;
  int __cil_tmp4 ;
  sf_count_t __cil_tmp5 ;

  {
#line 187
  (pg72x->block_curr) ++;
#line 188
  pg72x->sample_curr = 0;
#line 190
  if (pg72x->block_curr > pg72x->blocks_total) {
    {
#line 191
    memset((short *)pg72x->samples, 0, 120UL * sizeof(short ));
    }
#line 192
    return (1);
  }
  {
#line 195
  __cil_tmp5 = psf_fread((unsigned char *)pg72x->block, (sf_count_t )1, (sf_count_t )pg72x->bytesperblock,
                         psf);
#line 195
  k = (int )__cil_tmp5;
  }
#line 195
  if (k != pg72x->bytesperblock) {
    {
#line 196
    psf_log_printf(psf, "*** Warning : short read (%d != %d).\nV", k, pg72x->bytesperblock);
    }
  }
  {
#line 198
  pg72x->blocksize = k;
#line 199
  g72x_decode_block(pg72x->private, (unsigned char const   *)((unsigned char *)pg72x->block),
                    (short *)pg72x->samples);
  }
#line 201
  return (1);
}
}
#line 205 "/root/libsndfile/src/g72x.c"
static int g72x_read_block(SF_PRIVATE *psf , G72x_PRIVATE *pg72x , short *ptr , int len ) 
{ 
  int count ;
  int total ;
  int indx ;
  int tmp ;

  {
#line 206
  total = 0;
#line 206
  indx = 0;
  {
#line 208
  while (1) {
    while_continue: /* CIL Label */ ;
#line 208
    if (! (indx < len)) {
#line 208
      goto while_break;
    }
#line 209
    if (pg72x->block_curr > pg72x->blocks_total) {
      {
#line 210
      memset(ptr + indx, 0, (unsigned long )(len - indx) * sizeof(short ));
      }
#line 211
      return (total);
    }

#line 214
    if (pg72x->sample_curr >= pg72x->samplesperblock) {
      {
#line 215
      psf_g72x_decode_block(psf, pg72x);
      }
    }
#line 217
    count = pg72x->samplesperblock - pg72x->sample_curr;
#line 218
    if (len - indx > count) {
#line 218
      tmp = count;
    } else {
#line 218
      tmp = len - indx;
    }
    {
#line 218
    count = tmp;
#line 220
    memcpy(ptr + indx, & pg72x->samples[pg72x->sample_curr], (unsigned long )count * sizeof(short ));
#line 221
    indx += count;
#line 222
    pg72x->sample_curr += count;
#line 223
    total = indx;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 226
  return (total);
}
}
#line 230 "/root/libsndfile/src/g72x.c"
static sf_count_t g72x_read_s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  G72x_PRIVATE *pg72x ;
  int readcount ;
  int count ;
  sf_count_t total ;
  int tmp ;
  int __cil_tmp9 ;

  {
#line 233
  total = (sf_count_t )0;
#line 235
  if (psf->codec_data == (void *)0) {
#line 236
    return ((sf_count_t )0);
  }
#line 237
  pg72x = (G72x_PRIVATE *)psf->codec_data;
  {
#line 239
  while (1) {
    while_continue: /* CIL Label */ ;
#line 239
    if (! (len > 0L)) {
#line 239
      goto while_break;
    }
#line 240
    if (len > 268435456L) {
#line 240
      tmp = 268435456;
    } else {
#line 240
      tmp = (int )len;
    }
    {
#line 240
    readcount = tmp;
#line 242
    count = g72x_read_block(psf, pg72x, ptr, readcount);
#line 244
    total += (long )count;
#line 245
    len -= (long )count;
    }
#line 247
    if (count != readcount) {
#line 248
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 251
  return (total);
}
}
#line 255 "/root/libsndfile/src/g72x.c"
static sf_count_t g72x_read_i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  G72x_PRIVATE *pg72x ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count ;
  sf_count_t total ;
  long tmp ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;

  {
#line 258
  readcount = 0;
#line 259
  total = (sf_count_t )0;
#line 261
  if (psf->codec_data == (void *)0) {
#line 262
    return ((sf_count_t )0);
  }
#line 263
  pg72x = (G72x_PRIVATE *)psf->codec_data;
#line 265
  sptr = (short *)psf->u.sbuf;
#line 266
  bufferlen = (int )(16384UL / sizeof(short ));
  {
#line 267
  while (1) {
    while_continue: /* CIL Label */ ;
#line 267
    if (! (len > 0L)) {
#line 267
      goto while_break;
    }
#line 268
    if (len >= (long )bufferlen) {
#line 268
      tmp = (long )bufferlen;
    } else {
#line 268
      tmp = len;
    }
    {
#line 268
    readcount = (int )tmp;
#line 269
    count = g72x_read_block(psf, pg72x, sptr, readcount);
#line 271
    k = 0;
    }
    {
#line 271
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 271
      if (! (k < readcount)) {
#line 271
        goto while_break___0;
      }
#line 272
      *(ptr + (total + (long )k)) = (int )*(sptr + k) << 16;
#line 271
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 274
    total += (long )count;
#line 275
    len -= (long )readcount;
#line 276
    if (count != readcount) {
#line 277
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 280
  return (total);
}
}
#line 284 "/root/libsndfile/src/g72x.c"
static sf_count_t g72x_read_f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  G72x_PRIVATE *pg72x ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  long tmp___0 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;

  {
#line 287
  readcount = 0;
#line 288
  total = (sf_count_t )0;
#line 291
  if (psf->codec_data == (void *)0) {
#line 292
    return ((sf_count_t )0);
  }
#line 293
  pg72x = (G72x_PRIVATE *)psf->codec_data;
#line 295
  if (psf->norm_float == 1) {
#line 295
    tmp = 1. / (double )((float )32768);
  } else {
#line 295
    tmp = 1.;
  }
#line 295
  normfact = (float )tmp;
#line 297
  sptr = (short *)psf->u.sbuf;
#line 298
  bufferlen = (int )(16384UL / sizeof(short ));
  {
#line 299
  while (1) {
    while_continue: /* CIL Label */ ;
#line 299
    if (! (len > 0L)) {
#line 299
      goto while_break;
    }
#line 300
    if (len >= (long )bufferlen) {
#line 300
      tmp___0 = (long )bufferlen;
    } else {
#line 300
      tmp___0 = len;
    }
    {
#line 300
    readcount = (int )tmp___0;
#line 301
    count = g72x_read_block(psf, pg72x, sptr, readcount);
#line 302
    k = 0;
    }
    {
#line 302
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 302
      if (! (k < readcount)) {
#line 302
        goto while_break___0;
      }
#line 303
      *(ptr + (total + (long )k)) = normfact * (float )((int )*(sptr + k));
#line 302
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 305
    total += (long )count;
#line 306
    len -= (long )readcount;
#line 307
    if (count != readcount) {
#line 308
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 311
  return (total);
}
}
#line 315 "/root/libsndfile/src/g72x.c"
static sf_count_t g72x_read_d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  G72x_PRIVATE *pg72x ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int readcount ;
  int count ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  long tmp___0 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;

  {
#line 318
  readcount = 0;
#line 319
  total = (sf_count_t )0;
#line 322
  if (psf->codec_data == (void *)0) {
#line 323
    return ((sf_count_t )0);
  }
#line 324
  pg72x = (G72x_PRIVATE *)psf->codec_data;
#line 326
  if (psf->norm_double == 1) {
#line 326
    tmp = 1. / (double )32768;
  } else {
#line 326
    tmp = 1.;
  }
#line 326
  normfact = tmp;
#line 328
  sptr = (short *)psf->u.sbuf;
#line 329
  bufferlen = (int )(16384UL / sizeof(short ));
  {
#line 330
  while (1) {
    while_continue: /* CIL Label */ ;
#line 330
    if (! (len > 0L)) {
#line 330
      goto while_break;
    }
#line 331
    if (len >= (long )bufferlen) {
#line 331
      tmp___0 = (long )bufferlen;
    } else {
#line 331
      tmp___0 = len;
    }
    {
#line 331
    readcount = (int )tmp___0;
#line 332
    count = g72x_read_block(psf, pg72x, sptr, readcount);
#line 333
    k = 0;
    }
    {
#line 333
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 333
      if (! (k < readcount)) {
#line 333
        goto while_break___0;
      }
#line 334
      *(ptr + (total + (long )k)) = normfact * (double )*(sptr + k);
#line 333
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 336
    total += (long )count;
#line 337
    len -= (long )readcount;
#line 338
    if (count != readcount) {
#line 339
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 342
  return (total);
}
}
#line 346 "/root/libsndfile/src/g72x.c"
static sf_count_t g72x_seek(SF_PRIVATE *psf , int UNUSED_mode , sf_count_t UNUSED_offset ) 
{ 


  {
  {
#line 348
  psf_log_printf(psf, "seek unsupported\n");
  }
#line 354
  return ((sf_count_t )0);
}
}
#line 427 "/root/libsndfile/src/g72x.c"
static int psf_g72x_encode_block(SF_PRIVATE *psf , G72x_PRIVATE *pg72x ) 
{ 
  int k ;
  sf_count_t __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 431
  g72x_encode_block(pg72x->private, (short *)pg72x->samples, (unsigned char *)pg72x->block);
#line 434
  __cil_tmp4 = psf_fwrite((unsigned char *)pg72x->block, (sf_count_t )1, (sf_count_t )pg72x->blocksize,
                          psf);
#line 434
  k = (int )__cil_tmp4;
  }
#line 434
  if (k != pg72x->blocksize) {
    {
#line 435
    psf_log_printf(psf, "*** Warning : short write (%d != %d).\n", k, pg72x->blocksize);
    }
  }
  {
#line 437
  pg72x->sample_curr = 0;
#line 438
  (pg72x->block_curr) ++;
#line 441
  memset((short *)pg72x->samples, 0, 120UL * sizeof(short ));
  }
#line 443
  return (1);
}
}
#line 447 "/root/libsndfile/src/g72x.c"
static int g72x_write_block(SF_PRIVATE *psf , G72x_PRIVATE *pg72x , short const   *ptr ,
                            int len ) 
{ 
  int count ;
  int total ;
  int indx ;

  {
#line 448
  total = 0;
#line 448
  indx = 0;
  {
#line 450
  while (1) {
    while_continue: /* CIL Label */ ;
#line 450
    if (! (indx < len)) {
#line 450
      goto while_break;
    }
#line 451
    count = pg72x->samplesperblock - pg72x->sample_curr;
#line 453
    if (count > len - indx) {
#line 454
      count = len - indx;
    }
    {
#line 456
    memcpy(& pg72x->samples[pg72x->sample_curr], ptr + indx, (unsigned long )count * sizeof(short ));
#line 457
    indx += count;
#line 458
    pg72x->sample_curr += count;
#line 459
    total = indx;
    }
#line 461
    if (pg72x->sample_curr >= pg72x->samplesperblock) {
      {
#line 462
      psf_g72x_encode_block(psf, pg72x);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 465
  return (total);
}
}
#line 469 "/root/libsndfile/src/g72x.c"
static sf_count_t g72x_write_s(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  G72x_PRIVATE *pg72x ;
  int writecount ;
  int count ;
  sf_count_t total ;
  int tmp ;
  int __cil_tmp9 ;

  {
#line 472
  total = (sf_count_t )0;
#line 474
  if (psf->codec_data == (void *)0) {
#line 475
    return ((sf_count_t )0);
  }
#line 476
  pg72x = (G72x_PRIVATE *)psf->codec_data;
  {
#line 478
  while (1) {
    while_continue: /* CIL Label */ ;
#line 478
    if (! (len > 0L)) {
#line 478
      goto while_break;
    }
#line 479
    if (len > 268435456L) {
#line 479
      tmp = 268435456;
    } else {
#line 479
      tmp = (int )len;
    }
    {
#line 479
    writecount = tmp;
#line 481
    count = g72x_write_block(psf, pg72x, ptr, writecount);
#line 483
    total += (long )count;
#line 484
    len -= (long )count;
    }
#line 485
    if (count != writecount) {
#line 486
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 489
  return (total);
}
}
#line 493 "/root/libsndfile/src/g72x.c"
static sf_count_t g72x_write_i(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  G72x_PRIVATE *pg72x ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count ;
  sf_count_t total ;
  long tmp ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;

  {
#line 496
  writecount = 0;
#line 497
  total = (sf_count_t )0;
#line 499
  if (psf->codec_data == (void *)0) {
#line 500
    return ((sf_count_t )0);
  }
#line 501
  pg72x = (G72x_PRIVATE *)psf->codec_data;
#line 503
  sptr = (short *)psf->u.sbuf;
#line 504
  bufferlen = (int )((unsigned long )((16384 / psf->blockwidth) * psf->blockwidth) / sizeof(short ));
  {
#line 505
  while (1) {
    while_continue: /* CIL Label */ ;
#line 505
    if (! (len > 0L)) {
#line 505
      goto while_break;
    }
#line 506
    if (len >= (long )bufferlen) {
#line 506
      tmp = (long )bufferlen;
    } else {
#line 506
      tmp = len;
    }
#line 506
    writecount = (int )tmp;
#line 507
    k = 0;
    {
#line 507
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 507
      if (! (k < writecount)) {
#line 507
        goto while_break___0;
      }
#line 508
      *(sptr + k) = (short )(*(ptr + (total + (long )k)) >> 16);
#line 507
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 509
    count = g72x_write_block(psf, pg72x, (short const   *)sptr, writecount);
#line 511
    total += (long )count;
#line 512
    len -= (long )writecount;
    }
#line 513
    if (count != writecount) {
#line 514
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 516
  return (total);
}
}
#line 520 "/root/libsndfile/src/g72x.c"
static sf_count_t g72x_write_f(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  G72x_PRIVATE *pg72x ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count ;
  sf_count_t total ;
  float normfact ;
  double tmp ;
  long tmp___0 ;
  long __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;

  {
#line 523
  writecount = 0;
#line 524
  total = (sf_count_t )0;
#line 527
  if (psf->codec_data == (void *)0) {
#line 528
    return ((sf_count_t )0);
  }
#line 529
  pg72x = (G72x_PRIVATE *)psf->codec_data;
#line 531
  if (psf->norm_float == 1) {
#line 531
    tmp = 1. * (double )32768;
  } else {
#line 531
    tmp = 1.;
  }
#line 531
  normfact = (float )tmp;
#line 533
  sptr = (short *)psf->u.sbuf;
#line 534
  bufferlen = (int )((unsigned long )((16384 / psf->blockwidth) * psf->blockwidth) / sizeof(short ));
  {
#line 535
  while (1) {
    while_continue: /* CIL Label */ ;
#line 535
    if (! (len > 0L)) {
#line 535
      goto while_break;
    }
#line 536
    if (len >= (long )bufferlen) {
#line 536
      tmp___0 = (long )bufferlen;
    } else {
#line 536
      tmp___0 = len;
    }
#line 536
    writecount = (int )tmp___0;
#line 537
    k = 0;
    {
#line 537
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 537
      if (! (k < writecount)) {
#line 537
        goto while_break___0;
      }
      {
#line 538
      __cil_tmp14 = lrintf(normfact * *(ptr + (total + (long )k)));
#line 538
      *(sptr + k) = (short )__cil_tmp14;
      }
#line 537
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 539
    count = g72x_write_block(psf, pg72x, (short const   *)sptr, writecount);
#line 541
    total += (long )count;
#line 542
    len -= (long )writecount;
    }
#line 543
    if (count != writecount) {
#line 544
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 547
  return (total);
}
}
#line 551 "/root/libsndfile/src/g72x.c"
static sf_count_t g72x_write_d(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  G72x_PRIVATE *pg72x ;
  short *sptr ;
  int k ;
  int bufferlen ;
  int writecount ;
  int count ;
  sf_count_t total ;
  double normfact ;
  double tmp ;
  long tmp___0 ;
  long __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;

  {
#line 554
  writecount = 0;
#line 555
  total = (sf_count_t )0;
#line 558
  if (psf->codec_data == (void *)0) {
#line 559
    return ((sf_count_t )0);
  }
#line 560
  pg72x = (G72x_PRIVATE *)psf->codec_data;
#line 562
  if (psf->norm_double == 1) {
#line 562
    tmp = 1. * (double )32768;
  } else {
#line 562
    tmp = 1.;
  }
#line 562
  normfact = tmp;
#line 564
  sptr = (short *)psf->u.sbuf;
#line 565
  bufferlen = (int )((unsigned long )((16384 / psf->blockwidth) * psf->blockwidth) / sizeof(short ));
  {
#line 566
  while (1) {
    while_continue: /* CIL Label */ ;
#line 566
    if (! (len > 0L)) {
#line 566
      goto while_break;
    }
#line 567
    if (len >= (long )bufferlen) {
#line 567
      tmp___0 = (long )bufferlen;
    } else {
#line 567
      tmp___0 = len;
    }
#line 567
    writecount = (int )tmp___0;
#line 568
    k = 0;
    {
#line 568
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 568
      if (! (k < writecount)) {
#line 568
        goto while_break___0;
      }
      {
#line 569
      __cil_tmp14 = lrint(normfact * *(ptr + (total + (long )k)));
#line 569
      *(sptr + k) = (short )__cil_tmp14;
      }
#line 568
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 570
    count = g72x_write_block(psf, pg72x, (short const   *)sptr, writecount);
#line 572
    total += (long )count;
#line 573
    len -= (long )writecount;
    }
#line 574
    if (count != writecount) {
#line 575
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 578
  return (total);
}
}
#line 582 "/root/libsndfile/src/g72x.c"
static int g72x_close(SF_PRIVATE *psf ) 
{ 
  G72x_PRIVATE *pg72x ;

  {
#line 585
  pg72x = (G72x_PRIVATE *)psf->codec_data;
#line 587
  if (psf->mode == 32) {
#line 592
    if (pg72x->sample_curr) {
#line 592
      if (pg72x->sample_curr < 120) {
        {
#line 593
        psf_g72x_encode_block(psf, pg72x);
        }
      }
    }
#line 595
    if (psf->write_header) {
      {
#line 596
      (*(psf->write_header))(psf, 0);
      }
    }
  }
  {
#line 600
  free(pg72x->private);
  }
#line 602
  return (0);
}
}
#line 89 "/usr/include/FLAC/export.h"
extern int FLAC_API_SUPPORTS_OGG_FLAC ;
#line 162 "/usr/include/FLAC/format.h"
extern char const   *FLAC__VERSION_STRING ;
#line 168
extern char const   *FLAC__VENDOR_STRING ;
#line 171
extern FLAC__byte FLAC__STREAM_SYNC_STRING[4] ;
#line 176
extern uint32_t FLAC__STREAM_SYNC ;
#line 179
extern uint32_t FLAC__STREAM_SYNC_LEN ;
#line 209
extern char const   * const  FLAC__EntropyCodingMethodTypeString[] ;
#line 243
extern uint32_t FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_ORDER_LEN ;
#line 244
extern uint32_t FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_PARAMETER_LEN ;
#line 245
extern uint32_t FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2_PARAMETER_LEN ;
#line 246
extern uint32_t FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_RAW_LEN ;
#line 248
extern uint32_t FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_ESCAPE_PARAMETER ;
#line 250
extern uint32_t FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2_ESCAPE_PARAMETER ;
#line 262
extern uint32_t FLAC__ENTROPY_CODING_METHOD_TYPE_LEN ;
#line 279
extern char const   * const  FLAC__SubframeTypeString[] ;
#line 338
extern uint32_t FLAC__SUBFRAME_LPC_QLP_COEFF_PRECISION_LEN ;
#line 339
extern uint32_t FLAC__SUBFRAME_LPC_QLP_SHIFT_LEN ;
#line 362
extern uint32_t FLAC__SUBFRAME_ZERO_PAD_LEN ;
#line 363
extern uint32_t FLAC__SUBFRAME_TYPE_LEN ;
#line 364
extern uint32_t FLAC__SUBFRAME_WASTED_BITS_FLAG_LEN ;
#line 366
extern uint32_t FLAC__SUBFRAME_TYPE_CONSTANT_BYTE_ALIGNED_MASK ;
#line 367
extern uint32_t FLAC__SUBFRAME_TYPE_VERBATIM_BYTE_ALIGNED_MASK ;
#line 368
extern uint32_t FLAC__SUBFRAME_TYPE_FIXED_BYTE_ALIGNED_MASK ;
#line 369
extern uint32_t FLAC__SUBFRAME_TYPE_LPC_BYTE_ALIGNED_MASK ;
#line 393
extern char const   * const  FLAC__ChannelAssignmentString[] ;
#line 406
extern char const   * const  FLAC__FrameNumberTypeString[] ;
#line 446
extern uint32_t FLAC__FRAME_HEADER_SYNC ;
#line 447
extern uint32_t FLAC__FRAME_HEADER_SYNC_LEN ;
#line 448
extern uint32_t FLAC__FRAME_HEADER_RESERVED_LEN ;
#line 449
extern uint32_t FLAC__FRAME_HEADER_BLOCKING_STRATEGY_LEN ;
#line 450
extern uint32_t FLAC__FRAME_HEADER_BLOCK_SIZE_LEN ;
#line 451
extern uint32_t FLAC__FRAME_HEADER_SAMPLE_RATE_LEN ;
#line 452
extern uint32_t FLAC__FRAME_HEADER_CHANNEL_ASSIGNMENT_LEN ;
#line 453
extern uint32_t FLAC__FRAME_HEADER_BITS_PER_SAMPLE_LEN ;
#line 454
extern uint32_t FLAC__FRAME_HEADER_ZERO_PAD_LEN ;
#line 455
extern uint32_t FLAC__FRAME_HEADER_CRC_LEN ;
#line 468
extern uint32_t FLAC__FRAME_FOOTER_CRC_LEN ;
#line 524
extern char const   * const  FLAC__MetadataTypeString[] ;
#line 539
extern uint32_t FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN ;
#line 540
extern uint32_t FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN ;
#line 541
extern uint32_t FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN ;
#line 542
extern uint32_t FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN ;
#line 543
extern uint32_t FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN ;
#line 544
extern uint32_t FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN ;
#line 545
extern uint32_t FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN ;
#line 546
extern uint32_t FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN ;
#line 547
extern uint32_t FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN ;
#line 570
extern uint32_t FLAC__STREAM_METADATA_APPLICATION_ID_LEN ;
#line 586
extern uint32_t FLAC__STREAM_METADATA_SEEKPOINT_SAMPLE_NUMBER_LEN ;
#line 587
extern uint32_t FLAC__STREAM_METADATA_SEEKPOINT_STREAM_OFFSET_LEN ;
#line 588
extern uint32_t FLAC__STREAM_METADATA_SEEKPOINT_FRAME_SAMPLES_LEN ;
#line 597
extern FLAC__uint64 FLAC__STREAM_METADATA_SEEKPOINT_PLACEHOLDER ;
#line 629
extern uint32_t FLAC__STREAM_METADATA_VORBIS_COMMENT_ENTRY_LENGTH_LEN ;
#line 640
extern uint32_t FLAC__STREAM_METADATA_VORBIS_COMMENT_NUM_COMMENTS_LEN ;
#line 657
extern uint32_t FLAC__STREAM_METADATA_CUESHEET_INDEX_OFFSET_LEN ;
#line 658
extern uint32_t FLAC__STREAM_METADATA_CUESHEET_INDEX_NUMBER_LEN ;
#line 659
extern uint32_t FLAC__STREAM_METADATA_CUESHEET_INDEX_RESERVED_LEN ;
#line 690
extern uint32_t FLAC__STREAM_METADATA_CUESHEET_TRACK_OFFSET_LEN ;
#line 691
extern uint32_t FLAC__STREAM_METADATA_CUESHEET_TRACK_NUMBER_LEN ;
#line 692
extern uint32_t FLAC__STREAM_METADATA_CUESHEET_TRACK_ISRC_LEN ;
#line 693
extern uint32_t FLAC__STREAM_METADATA_CUESHEET_TRACK_TYPE_LEN ;
#line 694
extern uint32_t FLAC__STREAM_METADATA_CUESHEET_TRACK_PRE_EMPHASIS_LEN ;
#line 695
extern uint32_t FLAC__STREAM_METADATA_CUESHEET_TRACK_RESERVED_LEN ;
#line 696
extern uint32_t FLAC__STREAM_METADATA_CUESHEET_TRACK_NUM_INDICES_LEN ;
#line 724
extern uint32_t FLAC__STREAM_METADATA_CUESHEET_MEDIA_CATALOG_NUMBER_LEN ;
#line 725
extern uint32_t FLAC__STREAM_METADATA_CUESHEET_LEAD_IN_LEN ;
#line 726
extern uint32_t FLAC__STREAM_METADATA_CUESHEET_IS_CD_LEN ;
#line 727
extern uint32_t FLAC__STREAM_METADATA_CUESHEET_RESERVED_LEN ;
#line 728
extern uint32_t FLAC__STREAM_METADATA_CUESHEET_NUM_TRACKS_LEN ;
#line 763
extern char const   * const  FLAC__StreamMetadata_Picture_TypeString[] ;
#line 813
extern uint32_t FLAC__STREAM_METADATA_PICTURE_TYPE_LEN ;
#line 814
extern uint32_t FLAC__STREAM_METADATA_PICTURE_MIME_TYPE_LENGTH_LEN ;
#line 815
extern uint32_t FLAC__STREAM_METADATA_PICTURE_DESCRIPTION_LENGTH_LEN ;
#line 816
extern uint32_t FLAC__STREAM_METADATA_PICTURE_WIDTH_LEN ;
#line 817
extern uint32_t FLAC__STREAM_METADATA_PICTURE_HEIGHT_LEN ;
#line 818
extern uint32_t FLAC__STREAM_METADATA_PICTURE_DEPTH_LEN ;
#line 819
extern uint32_t FLAC__STREAM_METADATA_PICTURE_COLORS_LEN ;
#line 820
extern uint32_t FLAC__STREAM_METADATA_PICTURE_DATA_LENGTH_LEN ;
#line 860
extern uint32_t FLAC__STREAM_METADATA_IS_LAST_LEN ;
#line 861
extern uint32_t FLAC__STREAM_METADATA_TYPE_LEN ;
#line 862
extern uint32_t FLAC__STREAM_METADATA_LENGTH_LEN ;
#line 883
FLAC__bool FLAC__format_sample_rate_is_valid(uint32_t sample_rate ) ;
#line 895
FLAC__bool FLAC__format_blocksize_is_subset(uint32_t blocksize , uint32_t sample_rate ) ;
#line 906
FLAC__bool FLAC__format_sample_rate_is_subset(uint32_t sample_rate ) ;
#line 920
FLAC__bool FLAC__format_vorbiscomment_entry_name_is_legal(char const   *name ) ;
#line 936
FLAC__bool FLAC__format_vorbiscomment_entry_value_is_legal(FLAC__byte *value , uint32_t length ) ;
#line 953
FLAC__bool FLAC__format_vorbiscomment_entry_is_legal(FLAC__byte *entry , uint32_t length ) ;
#line 965
FLAC__bool FLAC__format_seektable_is_legal(FLAC__StreamMetadata_SeekTable *seek_table ) ;
#line 979
uint32_t FLAC__format_seektable_sort(FLAC__StreamMetadata_SeekTable *seek_table ) ;
#line 999
FLAC__bool FLAC__format_cuesheet_is_legal(FLAC__StreamMetadata_CueSheet *cue_sheet ,
                                          FLAC__bool check_cd_da_subset , char const   **violation ) ;
#line 1017
FLAC__bool FLAC__format_picture_is_legal(FLAC__StreamMetadata_Picture *picture , char const   **violation ) ;
#line 251 "/usr/include/FLAC/stream_decoder.h"
extern char const   * const  FLAC__StreamDecoderStateString[] ;
#line 289
extern char const   * const  FLAC__StreamDecoderInitStatusString[] ;
#line 320
extern char const   * const  FLAC__StreamDecoderReadStatusString[] ;
#line 343
extern char const   * const  FLAC__StreamDecoderSeekStatusString[] ;
#line 366
extern char const   * const  FLAC__StreamDecoderTellStatusString[] ;
#line 389
extern char const   * const  FLAC__StreamDecoderLengthStatusString[] ;
#line 409
extern char const   * const  FLAC__StreamDecoderWriteStatusString[] ;
#line 448
extern char const   * const  FLAC__StreamDecoderErrorStatusString[] ;
#line 743
FLAC__StreamDecoder *FLAC__stream_decoder_new(void) ;
#line 751
void FLAC__stream_decoder_delete(FLAC__StreamDecoder *decoder ) ;
#line 776
FLAC__bool FLAC__stream_decoder_set_ogg_serial_number(FLAC__StreamDecoder *decoder ,
                                                      long serial_number ) ;
#line 798
FLAC__bool FLAC__stream_decoder_set_md5_checking(FLAC__StreamDecoder *decoder , FLAC__bool value ) ;
#line 812
FLAC__bool FLAC__stream_decoder_set_metadata_respond(FLAC__StreamDecoder *decoder ,
                                                     FLAC__MetadataType type ) ;
#line 827
FLAC__bool FLAC__stream_decoder_set_metadata_respond_application(FLAC__StreamDecoder *decoder ,
                                                                 FLAC__byte id[4] ) ;
#line 839
FLAC__bool FLAC__stream_decoder_set_metadata_respond_all(FLAC__StreamDecoder *decoder ) ;
#line 853
FLAC__bool FLAC__stream_decoder_set_metadata_ignore(FLAC__StreamDecoder *decoder ,
                                                    FLAC__MetadataType type ) ;
#line 868
FLAC__bool FLAC__stream_decoder_set_metadata_ignore_application(FLAC__StreamDecoder *decoder ,
                                                                FLAC__byte id[4] ) ;
#line 880
FLAC__bool FLAC__stream_decoder_set_metadata_ignore_all(FLAC__StreamDecoder *decoder ) ;
#line 890
FLAC__StreamDecoderState FLAC__stream_decoder_get_state(FLAC__StreamDecoder *decoder ) ;
#line 900
char const   *FLAC__stream_decoder_get_resolved_state_string(FLAC__StreamDecoder *decoder ) ;
#line 914
FLAC__bool FLAC__stream_decoder_get_md5_checking(FLAC__StreamDecoder *decoder ) ;
#line 926
FLAC__uint64 FLAC__stream_decoder_get_total_samples(FLAC__StreamDecoder *decoder ) ;
#line 938
uint32_t FLAC__stream_decoder_get_channels(FLAC__StreamDecoder *decoder ) ;
#line 950
FLAC__ChannelAssignment FLAC__stream_decoder_get_channel_assignment(FLAC__StreamDecoder *decoder ) ;
#line 962
uint32_t FLAC__stream_decoder_get_bits_per_sample(FLAC__StreamDecoder *decoder ) ;
#line 974
uint32_t FLAC__stream_decoder_get_sample_rate(FLAC__StreamDecoder *decoder ) ;
#line 986
uint32_t FLAC__stream_decoder_get_blocksize(FLAC__StreamDecoder *decoder ) ;
#line 1007
FLAC__bool FLAC__stream_decoder_get_decode_position(FLAC__StreamDecoder *decoder ,
                                                    FLAC__uint64 *position ) ;
#line 1073
FLAC__StreamDecoderInitStatus FLAC__stream_decoder_init_stream(FLAC__StreamDecoder *decoder ,
                                                               FLAC__StreamDecoderReadCallback read_callback ,
                                                               FLAC__StreamDecoderSeekCallback seek_callback ,
                                                               FLAC__StreamDecoderTellCallback tell_callback ,
                                                               FLAC__StreamDecoderLengthCallback length_callback ,
                                                               FLAC__StreamDecoderEofCallback eof_callback ,
                                                               FLAC__StreamDecoderWriteCallback write_callback ,
                                                               FLAC__StreamDecoderMetadataCallback metadata_callback ,
                                                               FLAC__StreamDecoderErrorCallback error_callback ,
                                                               void *client_data ) ;
#line 1154
FLAC__StreamDecoderInitStatus FLAC__stream_decoder_init_ogg_stream(FLAC__StreamDecoder *decoder ,
                                                                   FLAC__StreamDecoderReadCallback read_callback ,
                                                                   FLAC__StreamDecoderSeekCallback seek_callback ,
                                                                   FLAC__StreamDecoderTellCallback tell_callback ,
                                                                   FLAC__StreamDecoderLengthCallback length_callback ,
                                                                   FLAC__StreamDecoderEofCallback eof_callback ,
                                                                   FLAC__StreamDecoderWriteCallback write_callback ,
                                                                   FLAC__StreamDecoderMetadataCallback metadata_callback ,
                                                                   FLAC__StreamDecoderErrorCallback error_callback ,
                                                                   void *client_data ) ;
#line 1204
FLAC__StreamDecoderInitStatus FLAC__stream_decoder_init_FILE(FLAC__StreamDecoder *decoder ,
                                                             FILE *file , FLAC__StreamDecoderWriteCallback write_callback ,
                                                             FLAC__StreamDecoderMetadataCallback metadata_callback ,
                                                             FLAC__StreamDecoderErrorCallback error_callback ,
                                                             void *client_data ) ;
#line 1254
FLAC__StreamDecoderInitStatus FLAC__stream_decoder_init_ogg_FILE(FLAC__StreamDecoder *decoder ,
                                                                 FILE *file , FLAC__StreamDecoderWriteCallback write_callback ,
                                                                 FLAC__StreamDecoderMetadataCallback metadata_callback ,
                                                                 FLAC__StreamDecoderErrorCallback error_callback ,
                                                                 void *client_data ) ;
#line 1296
FLAC__StreamDecoderInitStatus FLAC__stream_decoder_init_file(FLAC__StreamDecoder *decoder ,
                                                             char const   *filename ,
                                                             FLAC__StreamDecoderWriteCallback write_callback ,
                                                             FLAC__StreamDecoderMetadataCallback metadata_callback ,
                                                             FLAC__StreamDecoderErrorCallback error_callback ,
                                                             void *client_data ) ;
#line 1342
FLAC__StreamDecoderInitStatus FLAC__stream_decoder_init_ogg_file(FLAC__StreamDecoder *decoder ,
                                                                 char const   *filename ,
                                                                 FLAC__StreamDecoderWriteCallback write_callback ,
                                                                 FLAC__StreamDecoderMetadataCallback metadata_callback ,
                                                                 FLAC__StreamDecoderErrorCallback error_callback ,
                                                                 void *client_data ) ;
#line 1370
FLAC__bool FLAC__stream_decoder_finish(FLAC__StreamDecoder *decoder ) ;
#line 1385
FLAC__bool FLAC__stream_decoder_flush(FLAC__StreamDecoder *decoder ) ;
#line 1417
FLAC__bool FLAC__stream_decoder_reset(FLAC__StreamDecoder *decoder ) ;
#line 1450
FLAC__bool FLAC__stream_decoder_process_single(FLAC__StreamDecoder *decoder ) ;
#line 1471
FLAC__bool FLAC__stream_decoder_process_until_end_of_metadata(FLAC__StreamDecoder *decoder ) ;
#line 1492
FLAC__bool FLAC__stream_decoder_process_until_end_of_stream(FLAC__StreamDecoder *decoder ) ;
#line 1533
FLAC__bool FLAC__stream_decoder_skip_single_frame(FLAC__StreamDecoder *decoder ) ;
#line 1551
FLAC__bool FLAC__stream_decoder_seek_absolute(FLAC__StreamDecoder *decoder , FLAC__uint64 sample ) ;
#line 288 "/usr/include/FLAC/stream_encoder.h"
extern char const   * const  FLAC__StreamEncoderStateString[] ;
#line 358
extern char const   * const  FLAC__StreamEncoderInitStatusString[] ;
#line 384
extern char const   * const  FLAC__StreamEncoderReadStatusString[] ;
#line 404
extern char const   * const  FLAC__StreamEncoderWriteStatusString[] ;
#line 427
extern char const   * const  FLAC__StreamEncoderSeekStatusString[] ;
#line 450
extern char const   * const  FLAC__StreamEncoderTellStatusString[] ;
#line 694
FLAC__StreamEncoder *FLAC__stream_encoder_new(void) ;
#line 702
void FLAC__stream_encoder_delete(FLAC__StreamEncoder *encoder ) ;
#line 728
FLAC__bool FLAC__stream_encoder_set_ogg_serial_number(FLAC__StreamEncoder *encoder ,
                                                      long serial_number ) ;
#line 744
FLAC__bool FLAC__stream_encoder_set_verify(FLAC__StreamEncoder *encoder , FLAC__bool value ) ;
#line 762
FLAC__bool FLAC__stream_encoder_set_streamable_subset(FLAC__StreamEncoder *encoder ,
                                                      FLAC__bool value ) ;
#line 774
FLAC__bool FLAC__stream_encoder_set_channels(FLAC__StreamEncoder *encoder , uint32_t value ) ;
#line 790
FLAC__bool FLAC__stream_encoder_set_bits_per_sample(FLAC__StreamEncoder *encoder ,
                                                    uint32_t value ) ;
#line 802
FLAC__bool FLAC__stream_encoder_set_sample_rate(FLAC__StreamEncoder *encoder , uint32_t value ) ;
#line 865
FLAC__bool FLAC__stream_encoder_set_compression_level(FLAC__StreamEncoder *encoder ,
                                                      uint32_t value ) ;
#line 880
FLAC__bool FLAC__stream_encoder_set_blocksize(FLAC__StreamEncoder *encoder , uint32_t value ) ;
#line 894
FLAC__bool FLAC__stream_encoder_set_do_mid_side_stereo(FLAC__StreamEncoder *encoder ,
                                                       FLAC__bool value ) ;
#line 910
FLAC__bool FLAC__stream_encoder_set_loose_mid_side_stereo(FLAC__StreamEncoder *encoder ,
                                                          FLAC__bool value ) ;
#line 976
FLAC__bool FLAC__stream_encoder_set_apodization(FLAC__StreamEncoder *encoder , char const   *specification ) ;
#line 988
FLAC__bool FLAC__stream_encoder_set_max_lpc_order(FLAC__StreamEncoder *encoder , uint32_t value ) ;
#line 1006
FLAC__bool FLAC__stream_encoder_set_qlp_coeff_precision(FLAC__StreamEncoder *encoder ,
                                                        uint32_t value ) ;
#line 1020
FLAC__bool FLAC__stream_encoder_set_do_qlp_coeff_prec_search(FLAC__StreamEncoder *encoder ,
                                                             FLAC__bool value ) ;
#line 1032
FLAC__bool FLAC__stream_encoder_set_do_escape_coding(FLAC__StreamEncoder *encoder ,
                                                     FLAC__bool value ) ;
#line 1046
FLAC__bool FLAC__stream_encoder_set_do_exhaustive_model_search(FLAC__StreamEncoder *encoder ,
                                                               FLAC__bool value ) ;
#line 1069
FLAC__bool FLAC__stream_encoder_set_min_residual_partition_order(FLAC__StreamEncoder *encoder ,
                                                                 uint32_t value ) ;
#line 1092
FLAC__bool FLAC__stream_encoder_set_max_residual_partition_order(FLAC__StreamEncoder *encoder ,
                                                                 uint32_t value ) ;
#line 1104
FLAC__bool FLAC__stream_encoder_set_rice_parameter_search_dist(FLAC__StreamEncoder *encoder ,
                                                               uint32_t value ) ;
#line 1120
FLAC__bool FLAC__stream_encoder_set_total_samples_estimate(FLAC__StreamEncoder *encoder ,
                                                           FLAC__uint64 value ) ;
#line 1203
FLAC__bool FLAC__stream_encoder_set_metadata(FLAC__StreamEncoder *encoder , FLAC__StreamMetadata **metadata ,
                                             uint32_t num_blocks ) ;
#line 1213
FLAC__StreamEncoderState FLAC__stream_encoder_get_state(FLAC__StreamEncoder *encoder ) ;
#line 1225
FLAC__StreamDecoderState FLAC__stream_encoder_get_verify_decoder_state(FLAC__StreamEncoder *encoder ) ;
#line 1238
char const   *FLAC__stream_encoder_get_resolved_state_string(FLAC__StreamEncoder *encoder ) ;
#line 1257
void FLAC__stream_encoder_get_verify_decoder_error_stats(FLAC__StreamEncoder *encoder ,
                                                         FLAC__uint64 *absolute_sample ,
                                                         uint32_t *frame_number ,
                                                         uint32_t *channel , uint32_t *sample ,
                                                         FLAC__int32 *expected , FLAC__int32 *got ) ;
#line 1267
FLAC__bool FLAC__stream_encoder_get_verify(FLAC__StreamEncoder *encoder ) ;
#line 1277
FLAC__bool FLAC__stream_encoder_get_streamable_subset(FLAC__StreamEncoder *encoder ) ;
#line 1287
uint32_t FLAC__stream_encoder_get_channels(FLAC__StreamEncoder *encoder ) ;
#line 1297
uint32_t FLAC__stream_encoder_get_bits_per_sample(FLAC__StreamEncoder *encoder ) ;
#line 1307
uint32_t FLAC__stream_encoder_get_sample_rate(FLAC__StreamEncoder *encoder ) ;
#line 1317
uint32_t FLAC__stream_encoder_get_blocksize(FLAC__StreamEncoder *encoder ) ;
#line 1327
FLAC__bool FLAC__stream_encoder_get_do_mid_side_stereo(FLAC__StreamEncoder *encoder ) ;
#line 1337
FLAC__bool FLAC__stream_encoder_get_loose_mid_side_stereo(FLAC__StreamEncoder *encoder ) ;
#line 1347
uint32_t FLAC__stream_encoder_get_max_lpc_order(FLAC__StreamEncoder *encoder ) ;
#line 1357
uint32_t FLAC__stream_encoder_get_qlp_coeff_precision(FLAC__StreamEncoder *encoder ) ;
#line 1367
FLAC__bool FLAC__stream_encoder_get_do_qlp_coeff_prec_search(FLAC__StreamEncoder *encoder ) ;
#line 1377
FLAC__bool FLAC__stream_encoder_get_do_escape_coding(FLAC__StreamEncoder *encoder ) ;
#line 1387
FLAC__bool FLAC__stream_encoder_get_do_exhaustive_model_search(FLAC__StreamEncoder *encoder ) ;
#line 1397
uint32_t FLAC__stream_encoder_get_min_residual_partition_order(FLAC__StreamEncoder *encoder ) ;
#line 1407
uint32_t FLAC__stream_encoder_get_max_residual_partition_order(FLAC__StreamEncoder *encoder ) ;
#line 1417
uint32_t FLAC__stream_encoder_get_rice_parameter_search_dist(FLAC__StreamEncoder *encoder ) ;
#line 1430
FLAC__uint64 FLAC__stream_encoder_get_total_samples_estimate(FLAC__StreamEncoder *encoder ) ;
#line 1493
FLAC__StreamEncoderInitStatus FLAC__stream_encoder_init_stream(FLAC__StreamEncoder *encoder ,
                                                               FLAC__StreamEncoderWriteCallback write_callback ,
                                                               FLAC__StreamEncoderSeekCallback seek_callback ,
                                                               FLAC__StreamEncoderTellCallback tell_callback ,
                                                               FLAC__StreamEncoderMetadataCallback metadata_callback ,
                                                               void *client_data ) ;
#line 1561
FLAC__StreamEncoderInitStatus FLAC__stream_encoder_init_ogg_stream(FLAC__StreamEncoder *encoder ,
                                                                   FLAC__StreamEncoderReadCallback read_callback ,
                                                                   FLAC__StreamEncoderWriteCallback write_callback ,
                                                                   FLAC__StreamEncoderSeekCallback seek_callback ,
                                                                   FLAC__StreamEncoderTellCallback tell_callback ,
                                                                   FLAC__StreamEncoderMetadataCallback metadata_callback ,
                                                                   void *client_data ) ;
#line 1596
FLAC__StreamEncoderInitStatus FLAC__stream_encoder_init_FILE(FLAC__StreamEncoder *encoder ,
                                                             FILE *file , FLAC__StreamEncoderProgressCallback progress_callback ,
                                                             void *client_data ) ;
#line 1631
FLAC__StreamEncoderInitStatus FLAC__stream_encoder_init_ogg_FILE(FLAC__StreamEncoder *encoder ,
                                                                 FILE *file , FLAC__StreamEncoderProgressCallback progress_callback ,
                                                                 void *client_data ) ;
#line 1663
FLAC__StreamEncoderInitStatus FLAC__stream_encoder_init_file(FLAC__StreamEncoder *encoder ,
                                                             char const   *filename ,
                                                             FLAC__StreamEncoderProgressCallback progress_callback ,
                                                             void *client_data ) ;
#line 1695
FLAC__StreamEncoderInitStatus FLAC__stream_encoder_init_ogg_file(FLAC__StreamEncoder *encoder ,
                                                                 char const   *filename ,
                                                                 FLAC__StreamEncoderProgressCallback progress_callback ,
                                                                 void *client_data ) ;
#line 1723
FLAC__bool FLAC__stream_encoder_finish(FLAC__StreamEncoder *encoder ) ;
#line 1750
FLAC__bool FLAC__stream_encoder_process(FLAC__StreamEncoder *encoder , FLAC__int32 * const  buffer[] ,
                                        uint32_t samples ) ;
#line 1782
FLAC__bool FLAC__stream_encoder_process_interleaved(FLAC__StreamEncoder *encoder ,
                                                    FLAC__int32 buffer[] , uint32_t samples ) ;
#line 159 "/usr/include/FLAC/metadata.h"
FLAC__bool FLAC__metadata_get_streaminfo(char const   *filename , FLAC__StreamMetadata *streaminfo ) ;
#line 178
FLAC__bool FLAC__metadata_get_tags(char const   *filename , FLAC__StreamMetadata **tags ) ;
#line 197
FLAC__bool FLAC__metadata_get_cuesheet(char const   *filename , FLAC__StreamMetadata **cuesheet ) ;
#line 237
FLAC__bool FLAC__metadata_get_picture(char const   *filename , FLAC__StreamMetadata **picture ,
                                      FLAC__StreamMetadata_Picture_Type type , char const   *mime_type ,
                                      FLAC__byte *description , uint32_t max_width ,
                                      uint32_t max_height , uint32_t max_depth , uint32_t max_colors ) ;
#line 357
extern char const   * const  FLAC__Metadata_SimpleIteratorStatusString[] ;
#line 365
FLAC__Metadata_SimpleIterator *FLAC__metadata_simple_iterator_new(void) ;
#line 373
void FLAC__metadata_simple_iterator_delete(FLAC__Metadata_SimpleIterator *iterator ) ;
#line 385
FLAC__Metadata_SimpleIteratorStatus FLAC__metadata_simple_iterator_status(FLAC__Metadata_SimpleIterator *iterator ) ;
#line 406
FLAC__bool FLAC__metadata_simple_iterator_init(FLAC__Metadata_SimpleIterator *iterator ,
                                               char const   *filename , FLAC__bool read_only ,
                                               FLAC__bool preserve_file_stats ) ;
#line 418
FLAC__bool FLAC__metadata_simple_iterator_is_writable(FLAC__Metadata_SimpleIterator *iterator ) ;
#line 432
FLAC__bool FLAC__metadata_simple_iterator_next(FLAC__Metadata_SimpleIterator *iterator ) ;
#line 446
FLAC__bool FLAC__metadata_simple_iterator_prev(FLAC__Metadata_SimpleIterator *iterator ) ;
#line 459
FLAC__bool FLAC__metadata_simple_iterator_is_last(FLAC__Metadata_SimpleIterator *iterator ) ;
#line 475
__off_t FLAC__metadata_simple_iterator_get_block_offset(FLAC__Metadata_SimpleIterator *iterator ) ;
#line 489
FLAC__MetadataType FLAC__metadata_simple_iterator_get_block_type(FLAC__Metadata_SimpleIterator *iterator ) ;
#line 506
uint32_t FLAC__metadata_simple_iterator_get_block_length(FLAC__Metadata_SimpleIterator *iterator ) ;
#line 531
FLAC__bool FLAC__metadata_simple_iterator_get_application_id(FLAC__Metadata_SimpleIterator *iterator ,
                                                             FLAC__byte *id ) ;
#line 549
FLAC__StreamMetadata *FLAC__metadata_simple_iterator_get_block(FLAC__Metadata_SimpleIterator *iterator ) ;
#line 605
FLAC__bool FLAC__metadata_simple_iterator_set_block(FLAC__Metadata_SimpleIterator *iterator ,
                                                    FLAC__StreamMetadata *block ,
                                                    FLAC__bool use_padding ) ;
#line 630
FLAC__bool FLAC__metadata_simple_iterator_insert_block_after(FLAC__Metadata_SimpleIterator *iterator ,
                                                             FLAC__StreamMetadata *block ,
                                                             FLAC__bool use_padding ) ;
#line 649
FLAC__bool FLAC__metadata_simple_iterator_delete_block(FLAC__Metadata_SimpleIterator *iterator ,
                                                       FLAC__bool use_padding ) ;
#line 790
extern char const   * const  FLAC__Metadata_ChainStatusString[] ;
#line 799
FLAC__Metadata_Chain *FLAC__metadata_chain_new(void) ;
#line 807
void FLAC__metadata_chain_delete(FLAC__Metadata_Chain *chain ) ;
#line 819
FLAC__Metadata_ChainStatus FLAC__metadata_chain_status(FLAC__Metadata_Chain *chain ) ;
#line 833
FLAC__bool FLAC__metadata_chain_read(FLAC__Metadata_Chain *chain , char const   *filename ) ;
#line 850
FLAC__bool FLAC__metadata_chain_read_ogg(FLAC__Metadata_Chain *chain , char const   *filename ) ;
#line 872
FLAC__bool FLAC__metadata_chain_read_with_callbacks(FLAC__Metadata_Chain *chain ,
                                                    FLAC__IOHandle handle , FLAC__IOCallbacks callbacks ) ;
#line 897
FLAC__bool FLAC__metadata_chain_read_ogg_with_callbacks(FLAC__Metadata_Chain *chain ,
                                                        FLAC__IOHandle handle , FLAC__IOCallbacks callbacks ) ;
#line 925
FLAC__bool FLAC__metadata_chain_check_if_tempfile_needed(FLAC__Metadata_Chain *chain ,
                                                         FLAC__bool use_padding ) ;
#line 971
FLAC__bool FLAC__metadata_chain_write(FLAC__Metadata_Chain *chain , FLAC__bool use_padding ,
                                      FLAC__bool preserve_file_stats ) ;
#line 1001
FLAC__bool FLAC__metadata_chain_write_with_callbacks(FLAC__Metadata_Chain *chain ,
                                                     FLAC__bool use_padding , FLAC__IOHandle handle ,
                                                     FLAC__IOCallbacks callbacks ) ;
#line 1052
FLAC__bool FLAC__metadata_chain_write_with_callbacks_and_tempfile(FLAC__Metadata_Chain *chain ,
                                                                  FLAC__bool use_padding ,
                                                                  FLAC__IOHandle handle ,
                                                                  FLAC__IOCallbacks callbacks ,
                                                                  FLAC__IOHandle temp_handle ,
                                                                  FLAC__IOCallbacks temp_callbacks ) ;
#line 1066
void FLAC__metadata_chain_merge_padding(FLAC__Metadata_Chain *chain ) ;
#line 1081
void FLAC__metadata_chain_sort_padding(FLAC__Metadata_Chain *chain ) ;
#line 1091
FLAC__Metadata_Iterator *FLAC__metadata_iterator_new(void) ;
#line 1099
void FLAC__metadata_iterator_delete(FLAC__Metadata_Iterator *iterator ) ;
#line 1110
void FLAC__metadata_iterator_init(FLAC__Metadata_Iterator *iterator , FLAC__Metadata_Chain *chain ) ;
#line 1124
FLAC__bool FLAC__metadata_iterator_next(FLAC__Metadata_Iterator *iterator ) ;
#line 1138
FLAC__bool FLAC__metadata_iterator_prev(FLAC__Metadata_Iterator *iterator ) ;
#line 1150
FLAC__MetadataType FLAC__metadata_iterator_get_block_type(FLAC__Metadata_Iterator *iterator ) ;
#line 1171
FLAC__StreamMetadata *FLAC__metadata_iterator_get_block(FLAC__Metadata_Iterator *iterator ) ;
#line 1188
FLAC__bool FLAC__metadata_iterator_set_block(FLAC__Metadata_Iterator *iterator , FLAC__StreamMetadata *block ) ;
#line 1206
FLAC__bool FLAC__metadata_iterator_delete_block(FLAC__Metadata_Iterator *iterator ,
                                                FLAC__bool replace_with_padding ) ;
#line 1225
FLAC__bool FLAC__metadata_iterator_insert_block_before(FLAC__Metadata_Iterator *iterator ,
                                                       FLAC__StreamMetadata *block ) ;
#line 1243
FLAC__bool FLAC__metadata_iterator_insert_block_after(FLAC__Metadata_Iterator *iterator ,
                                                      FLAC__StreamMetadata *block ) ;
#line 1313
FLAC__StreamMetadata *FLAC__metadata_object_new(FLAC__MetadataType type ) ;
#line 1327
FLAC__StreamMetadata *FLAC__metadata_object_clone(FLAC__StreamMetadata *object ) ;
#line 1338
void FLAC__metadata_object_delete(FLAC__StreamMetadata *object ) ;
#line 1353
FLAC__bool FLAC__metadata_object_is_equal(FLAC__StreamMetadata *block1 , FLAC__StreamMetadata *block2 ) ;
#line 1376
FLAC__bool FLAC__metadata_object_application_set_data(FLAC__StreamMetadata *object ,
                                                      FLAC__byte *data , uint32_t length ,
                                                      FLAC__bool copy ) ;
#line 1393
FLAC__bool FLAC__metadata_object_seektable_resize_points(FLAC__StreamMetadata *object ,
                                                         uint32_t new_num_points ) ;
#line 1405
void FLAC__metadata_object_seektable_set_point(FLAC__StreamMetadata *object , uint32_t point_num ,
                                               FLAC__StreamMetadata_SeekPoint point ) ;
#line 1419
FLAC__bool FLAC__metadata_object_seektable_insert_point(FLAC__StreamMetadata *object ,
                                                        uint32_t point_num , FLAC__StreamMetadata_SeekPoint point ) ;
#line 1432
FLAC__bool FLAC__metadata_object_seektable_delete_point(FLAC__StreamMetadata *object ,
                                                        uint32_t point_num ) ;
#line 1445
FLAC__bool FLAC__metadata_object_seektable_is_legal(FLAC__StreamMetadata *object ) ;
#line 1462
FLAC__bool FLAC__metadata_object_seektable_template_append_placeholders(FLAC__StreamMetadata *object ,
                                                                        uint32_t num ) ;
#line 1479
FLAC__bool FLAC__metadata_object_seektable_template_append_point(FLAC__StreamMetadata *object ,
                                                                 FLAC__uint64 sample_number ) ;
#line 1497
FLAC__bool FLAC__metadata_object_seektable_template_append_points(FLAC__StreamMetadata *object ,
                                                                  FLAC__uint64 sample_numbers[] ,
                                                                  uint32_t num ) ;
#line 1519
FLAC__bool FLAC__metadata_object_seektable_template_append_spaced_points(FLAC__StreamMetadata *object ,
                                                                         uint32_t num ,
                                                                         FLAC__uint64 total_samples ) ;
#line 1547
FLAC__bool FLAC__metadata_object_seektable_template_append_spaced_points_by_samples(FLAC__StreamMetadata *object ,
                                                                                    uint32_t samples ,
                                                                                    FLAC__uint64 total_samples ) ;
#line 1564
FLAC__bool FLAC__metadata_object_seektable_template_sort(FLAC__StreamMetadata *object ,
                                                         FLAC__bool compact ) ;
#line 1589
FLAC__bool FLAC__metadata_object_vorbiscomment_set_vendor_string(FLAC__StreamMetadata *object ,
                                                                 FLAC__StreamMetadata_VorbisComment_Entry entry ,
                                                                 FLAC__bool copy ) ;
#line 1606
FLAC__bool FLAC__metadata_object_vorbiscomment_resize_comments(FLAC__StreamMetadata *object ,
                                                               uint32_t new_num_comments ) ;
#line 1633
FLAC__bool FLAC__metadata_object_vorbiscomment_set_comment(FLAC__StreamMetadata *object ,
                                                           uint32_t comment_num ,
                                                           FLAC__StreamMetadata_VorbisComment_Entry entry ,
                                                           FLAC__bool copy ) ;
#line 1663
FLAC__bool FLAC__metadata_object_vorbiscomment_insert_comment(FLAC__StreamMetadata *object ,
                                                              uint32_t comment_num ,
                                                              FLAC__StreamMetadata_VorbisComment_Entry entry ,
                                                              FLAC__bool copy ) ;
#line 1688
FLAC__bool FLAC__metadata_object_vorbiscomment_append_comment(FLAC__StreamMetadata *object ,
                                                              FLAC__StreamMetadata_VorbisComment_Entry entry ,
                                                              FLAC__bool copy ) ;
#line 1723
FLAC__bool FLAC__metadata_object_vorbiscomment_replace_comment(FLAC__StreamMetadata *object ,
                                                               FLAC__StreamMetadata_VorbisComment_Entry entry ,
                                                               FLAC__bool all , FLAC__bool copy ) ;
#line 1736
FLAC__bool FLAC__metadata_object_vorbiscomment_delete_comment(FLAC__StreamMetadata *object ,
                                                              uint32_t comment_num ) ;
#line 1757
FLAC__bool FLAC__metadata_object_vorbiscomment_entry_from_name_value_pair(FLAC__StreamMetadata_VorbisComment_Entry *entry ,
                                                                          char const   *field_name ,
                                                                          char const   *field_value ) ;
#line 1778
FLAC__bool FLAC__metadata_object_vorbiscomment_entry_to_name_value_pair(FLAC__StreamMetadata_VorbisComment_Entry entry ,
                                                                        char **field_name ,
                                                                        char **field_value ) ;
#line 1792
FLAC__bool FLAC__metadata_object_vorbiscomment_entry_matches(FLAC__StreamMetadata_VorbisComment_Entry entry ,
                                                             char const   *field_name ,
                                                             uint32_t field_name_length ) ;
#line 1811
int FLAC__metadata_object_vorbiscomment_find_entry_from(FLAC__StreamMetadata *object ,
                                                        uint32_t offset , char const   *field_name ) ;
#line 1824
int FLAC__metadata_object_vorbiscomment_remove_entry_matching(FLAC__StreamMetadata *object ,
                                                              char const   *field_name ) ;
#line 1837
int FLAC__metadata_object_vorbiscomment_remove_entries_matching(FLAC__StreamMetadata *object ,
                                                                char const   *field_name ) ;
#line 1846
FLAC__StreamMetadata_CueSheet_Track *FLAC__metadata_object_cuesheet_track_new(void) ;
#line 1861
FLAC__StreamMetadata_CueSheet_Track *FLAC__metadata_object_cuesheet_track_clone(FLAC__StreamMetadata_CueSheet_Track *object ) ;
#line 1869
void FLAC__metadata_object_cuesheet_track_delete(FLAC__StreamMetadata_CueSheet_Track *object ) ;
#line 1889
FLAC__bool FLAC__metadata_object_cuesheet_track_resize_indices(FLAC__StreamMetadata *object ,
                                                               uint32_t track_num ,
                                                               uint32_t new_num_indices ) ;
#line 1912
FLAC__bool FLAC__metadata_object_cuesheet_track_insert_index(FLAC__StreamMetadata *object ,
                                                             uint32_t track_num ,
                                                             uint32_t index_num ,
                                                             FLAC__StreamMetadata_CueSheet_Index index ) ;
#line 1936
FLAC__bool FLAC__metadata_object_cuesheet_track_insert_blank_index(FLAC__StreamMetadata *object ,
                                                                   uint32_t track_num ,
                                                                   uint32_t index_num ) ;
#line 1955
FLAC__bool FLAC__metadata_object_cuesheet_track_delete_index(FLAC__StreamMetadata *object ,
                                                             uint32_t track_num ,
                                                             uint32_t index_num ) ;
#line 1972
FLAC__bool FLAC__metadata_object_cuesheet_resize_tracks(FLAC__StreamMetadata *object ,
                                                        uint32_t new_num_tracks ) ;
#line 1994
FLAC__bool FLAC__metadata_object_cuesheet_set_track(FLAC__StreamMetadata *object ,
                                                    uint32_t track_num , FLAC__StreamMetadata_CueSheet_Track *track ,
                                                    FLAC__bool copy ) ;
#line 2017
FLAC__bool FLAC__metadata_object_cuesheet_insert_track(FLAC__StreamMetadata *object ,
                                                       uint32_t track_num , FLAC__StreamMetadata_CueSheet_Track *track ,
                                                       FLAC__bool copy ) ;
#line 2036
FLAC__bool FLAC__metadata_object_cuesheet_insert_blank_track(FLAC__StreamMetadata *object ,
                                                             uint32_t track_num ) ;
#line 2051
FLAC__bool FLAC__metadata_object_cuesheet_delete_track(FLAC__StreamMetadata *object ,
                                                       uint32_t track_num ) ;
#line 2072
FLAC__bool FLAC__metadata_object_cuesheet_is_legal(FLAC__StreamMetadata *object ,
                                                   FLAC__bool check_cd_da_subset ,
                                                   char const   **violation ) ;
#line 2085
FLAC__uint32 FLAC__metadata_object_cuesheet_calculate_cddb_id(FLAC__StreamMetadata *object ) ;
#line 2108
FLAC__bool FLAC__metadata_object_picture_set_mime_type(FLAC__StreamMetadata *object ,
                                                       char *mime_type , FLAC__bool copy ) ;
#line 2130
FLAC__bool FLAC__metadata_object_picture_set_description(FLAC__StreamMetadata *object ,
                                                         FLAC__byte *description ,
                                                         FLAC__bool copy ) ;
#line 2155
FLAC__bool FLAC__metadata_object_picture_set_data(FLAC__StreamMetadata *object , FLAC__byte *data ,
                                                  FLAC__uint32 length , FLAC__bool copy ) ;
#line 2174
FLAC__bool FLAC__metadata_object_picture_is_legal(FLAC__StreamMetadata *object , char const   **violation ) ;
#line 77 "/root/libsndfile/src/flac.c"
static sf_count_t flac_seek(SF_PRIVATE *psf , int UNUSED_mode , sf_count_t offset ) ;
#line 78
static int flac_close(SF_PRIVATE *psf ) ;
#line 80
static int flac_enc_init(SF_PRIVATE *psf ) ;
#line 81
static int flac_read_header(SF_PRIVATE *psf ) ;
#line 83
static sf_count_t flac_read_flac2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) ;
#line 84
static sf_count_t flac_read_flac2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) ;
#line 85
static sf_count_t flac_read_flac2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) ;
#line 86
static sf_count_t flac_read_flac2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) ;
#line 88
static sf_count_t flac_write_s2flac(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) ;
#line 89
static sf_count_t flac_write_i2flac(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) ;
#line 90
static sf_count_t flac_write_f2flac(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) ;
#line 91
static sf_count_t flac_write_d2flac(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) ;
#line 93
static void f2flac8_array(float const   *src , FLAC__int32 *dest , int count , int normalize ) ;
#line 94
static void f2flac16_array(float const   *src , FLAC__int32 *dest , int count , int normalize ) ;
#line 95
static void f2flac24_array(float const   *src , FLAC__int32 *dest , int count , int normalize ) ;
#line 96
static void f2flac8_clip_array(float const   *src , FLAC__int32 *dest , int count ,
                               int normalize ) ;
#line 97
static void f2flac16_clip_array(float const   *src , FLAC__int32 *dest , int count ,
                                int normalize ) ;
#line 98
static void f2flac24_clip_array(float const   *src , FLAC__int32 *dest , int count ,
                                int normalize ) ;
#line 99
static void d2flac8_array(double const   *src , FLAC__int32 *dest , int count , int normalize ) ;
#line 100
static void d2flac16_array(double const   *src , FLAC__int32 *dest , int count , int normalize ) ;
#line 101
static void d2flac24_array(double const   *src , FLAC__int32 *dest , int count , int normalize ) ;
#line 102
static void d2flac8_clip_array(double const   *src , FLAC__int32 *dest , int count ,
                               int normalize ) ;
#line 103
static void d2flac16_clip_array(double const   *src , FLAC__int32 *dest , int count ,
                                int normalize ) ;
#line 104
static void d2flac24_clip_array(double const   *src , FLAC__int32 *dest , int count ,
                                int normalize ) ;
#line 106
static int flac_command(SF_PRIVATE *UNUSED_psf , int UNUSED_command , void *UNUSED_data ,
                        int UNUSED_datasize ) ;
#line 109
static FLAC__StreamDecoderReadStatus sf_flac_read_callback(FLAC__StreamDecoder *UNUSED_decoder ,
                                                           FLAC__byte buffer[] , size_t *bytes ,
                                                           void *client_data ) ;
#line 110
static FLAC__StreamDecoderSeekStatus sf_flac_seek_callback(FLAC__StreamDecoder *UNUSED_decoder ,
                                                           FLAC__uint64 absolute_byte_offset ,
                                                           void *client_data ) ;
#line 111
static FLAC__StreamDecoderTellStatus sf_flac_tell_callback(FLAC__StreamDecoder *UNUSED_decoder ,
                                                           FLAC__uint64 *absolute_byte_offset ,
                                                           void *client_data ) ;
#line 112
static FLAC__StreamDecoderLengthStatus sf_flac_length_callback(FLAC__StreamDecoder *UNUSED_decoder ,
                                                               FLAC__uint64 *stream_length ,
                                                               void *client_data ) ;
#line 113
static FLAC__bool sf_flac_eof_callback(FLAC__StreamDecoder *UNUSED_decoder , void *client_data ) ;
#line 114
static FLAC__StreamDecoderWriteStatus sf_flac_write_callback(FLAC__StreamDecoder *UNUSED_decoder ,
                                                             FLAC__Frame *frame ,
                                                             FLAC__int32 * const  buffer[] ,
                                                             void *client_data ) ;
#line 115
static void sf_flac_meta_callback(FLAC__StreamDecoder *UNUSED_decoder , FLAC__StreamMetadata *metadata ,
                                  void *client_data ) ;
#line 116
static void sf_flac_error_callback(FLAC__StreamDecoder *UNUSED_decoder , FLAC__StreamDecoderErrorStatus status ,
                                   void *client_data ) ;
#line 119
static FLAC__StreamEncoderSeekStatus sf_flac_enc_seek_callback(FLAC__StreamEncoder *UNUSED_encoder ,
                                                               FLAC__uint64 absolute_byte_offset ,
                                                               void *client_data ) ;
#line 120
static FLAC__StreamEncoderTellStatus sf_flac_enc_tell_callback(FLAC__StreamEncoder *UNUSED_encoder ,
                                                               FLAC__uint64 *absolute_byte_offset ,
                                                               void *client_data ) ;
#line 121
static FLAC__StreamEncoderWriteStatus sf_flac_enc_write_callback(FLAC__StreamEncoder *UNUSED_encoder ,
                                                                 FLAC__byte buffer[] ,
                                                                 size_t bytes , unsigned int UNUSED_samples ,
                                                                 unsigned int UNUSED_current_frame ,
                                                                 void *client_data ) ;
#line 123 "/root/libsndfile/src/flac.c"
static int const   legal_sample_rates[8]  = 
#line 123
  {      8000,      16000,      22050,      24000, 
        32000,      44100,      48000,      96000};
#line 128 "/root/libsndfile/src/flac.c"
static void s2flac8_array(short const   *src , FLAC__int32 *dest , int count ) 
{ 


  {
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
#line 129
    count --;
#line 129
    if (! (count >= 0)) {
#line 129
      goto while_break;
    }
#line 130
    *(dest + count) = (int )*(src + count) >> 8;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 134 "/root/libsndfile/src/flac.c"
static void s2flac16_array(short const   *src , FLAC__int32 *dest , int count ) 
{ 


  {
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    count --;
#line 135
    if (! (count >= 0)) {
#line 135
      goto while_break;
    }
#line 136
    *(dest + count) = (FLAC__int32 )*(src + count);
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 140 "/root/libsndfile/src/flac.c"
static void s2flac24_array(short const   *src , FLAC__int32 *dest , int count ) 
{ 


  {
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 141
    count --;
#line 141
    if (! (count >= 0)) {
#line 141
      goto while_break;
    }
#line 142
    *(dest + count) = (int )*(src + count) << 8;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 146 "/root/libsndfile/src/flac.c"
static void i2flac8_array(int const   *src , FLAC__int32 *dest , int count ) 
{ 


  {
  {
#line 147
  while (1) {
    while_continue: /* CIL Label */ ;
#line 147
    count --;
#line 147
    if (! (count >= 0)) {
#line 147
      goto while_break;
    }
#line 148
    *(dest + count) = *(src + count) >> 24;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 152 "/root/libsndfile/src/flac.c"
static void i2flac16_array(int const   *src , FLAC__int32 *dest , int count ) 
{ 


  {
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    count --;
#line 154
    if (! (count >= 0)) {
#line 154
      goto while_break;
    }
#line 155
    *(dest + count) = *(src + count) >> 16;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 159 "/root/libsndfile/src/flac.c"
static void i2flac24_array(int const   *src , FLAC__int32 *dest , int count ) 
{ 


  {
  {
#line 160
  while (1) {
    while_continue: /* CIL Label */ ;
#line 160
    count --;
#line 160
    if (! (count >= 0)) {
#line 160
      goto while_break;
    }
#line 161
    *(dest + count) = *(src + count) >> 8;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 165 "/root/libsndfile/src/flac.c"
static sf_count_t flac_buffer_copy(SF_PRIVATE *psf ) 
{ 
  FLAC_PRIVATE *pflac ;
  FLAC__Frame *frame ;
  FLAC__int32 * const  *buffer ;
  unsigned int i ;
  unsigned int j ;
  unsigned int offset ;
  void *__cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  short *retpcm ;
  int shift ;
  int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  unsigned int __cil_tmp14 ;
  unsigned int __cil_tmp15 ;
  unsigned int __cil_tmp16 ;
  unsigned int __cil_tmp17 ;
  unsigned int __cil_tmp18 ;
  int *retpcm___0 ;
  int shift___0 ;
  unsigned int __cil_tmp21 ;
  unsigned int __cil_tmp22 ;
  unsigned int __cil_tmp23 ;
  float *retpcm___1 ;
  float norm ;
  double tmp ;
  unsigned int __cil_tmp27 ;
  unsigned int __cil_tmp28 ;
  unsigned int __cil_tmp29 ;
  double *retpcm___2 ;
  double norm___0 ;
  double tmp___0 ;
  unsigned int __cil_tmp33 ;
  unsigned int __cil_tmp34 ;
  unsigned int __cil_tmp35 ;

  {
#line 166
  pflac = (FLAC_PRIVATE *)psf->codec_data;
#line 167
  frame = pflac->frame;
#line 168
  buffer = pflac->wbuffer;
#line 169
  i = (unsigned int )0;
#line 176
  if (frame->header.blocksize > 65535U) {
    {
#line 177
    psf_log_printf(psf, "Ooops : frame->header.blocksize (%d) > FLAC__MAX_BLOCK_SIZE (%d)\n",
                   "flac_buffer_copy\312\001@", 177, frame->header.blocksize, 65535U);
#line 178
    psf->error = 29;
    }
#line 179
    return ((sf_count_t )0);
  }

#line 182
  if (pflac->ptr == (void *)0) {
#line 187
    pflac->bufferbackup = 1;
#line 188
    i = (unsigned int )0;
    {
#line 188
    while (1) {
      while_continue: /* CIL Label */ ;
#line 188
      if (! (i < frame->header.channels)) {
#line 188
        goto while_break;
      }
#line 190
      if (pflac->rbuffer[i] == (void *)0) {
        {
#line 191
        pflac->rbuffer[i] = (FLAC__int32 *)calloc((unsigned long )65535U, sizeof(FLAC__int32 ));
        }
      }
      {
#line 193
      memcpy(pflac->rbuffer[i], *(buffer + i), (unsigned long )frame->header.blocksize * sizeof(FLAC__int32 ));
      }
#line 188
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 195
    pflac->wbuffer = (FLAC__int32 * const  *)((FLAC__int32 **)pflac->rbuffer);
#line 197
    return ((sf_count_t )0);
  }

  {
#line 201
  if ((unsigned int )pflac->pcmtype == (unsigned int )50) {
#line 201
    goto case_50;
  }
#line 235
  if ((unsigned int )pflac->pcmtype == (unsigned int )51) {
#line 235
    goto case_51;
  }
#line 252
  if ((unsigned int )pflac->pcmtype == (unsigned int )52) {
#line 252
    goto case_52;
  }
#line 270
  if ((unsigned int )pflac->pcmtype == (unsigned int )53) {
#line 270
    goto case_53;
  }
#line 288
  goto switch_default;
  case_50: /* CIL Label */ 
#line 202
  retpcm = (short *)pflac->ptr;
#line 203
  shift = (int )(16U - frame->header.bits_per_sample);
#line 204
  if (shift < 0) {
    {
#line 205
    shift = abs(shift);
#line 206
    i = (unsigned int )0;
    }
    {
#line 206
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 206
      if (! (i < frame->header.blocksize && pflac->remain > 0U)) {
#line 206
        goto while_break___0;
      }
#line 207
      offset = pflac->pos + i * frame->header.channels;
#line 209
      if (pflac->bufferpos >= frame->header.blocksize) {
#line 210
        goto while_break___0;
      }
#line 212
      j = (unsigned int )0;
      {
#line 212
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 212
        if (! (j < frame->header.channels)) {
#line 212
          goto while_break___1;
        }
#line 213
        *(retpcm + (offset + j)) = (short )(*(*(buffer + j) + pflac->bufferpos) >> shift);
#line 212
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 214
      pflac->remain -= frame->header.channels;
#line 215
      (pflac->bufferpos) ++;
#line 206
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 219
    i = (unsigned int )0;
    {
#line 219
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 219
      if (! (i < frame->header.blocksize && pflac->remain > 0U)) {
#line 219
        goto while_break___2;
      }
#line 220
      offset = pflac->pos + i * frame->header.channels;
#line 222
      if (pflac->bufferpos >= frame->header.blocksize) {
#line 223
        goto while_break___2;
      }
#line 225
      j = (unsigned int )0;
      {
#line 225
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 225
        if (! (j < frame->header.channels)) {
#line 225
          goto while_break___3;
        }
#line 226
        *(retpcm + (offset + j)) = (short )(*(*(buffer + j) + pflac->bufferpos) << shift);
#line 225
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 228
      pflac->remain -= frame->header.channels;
#line 229
      (pflac->bufferpos) ++;
#line 219
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }

  }

#line 233
  goto switch_break;
  case_51: /* CIL Label */ 
#line 236
  retpcm___0 = (int *)pflac->ptr;
#line 237
  shift___0 = (int )(32U - frame->header.bits_per_sample);
#line 238
  i = (unsigned int )0;
  {
#line 238
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 238
    if (! (i < frame->header.blocksize && pflac->remain > 0U)) {
#line 238
      goto while_break___4;
    }
#line 239
    offset = pflac->pos + i * frame->header.channels;
#line 241
    if (pflac->bufferpos >= frame->header.blocksize) {
#line 242
      goto while_break___4;
    }
#line 244
    j = (unsigned int )0;
    {
#line 244
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 244
      if (! (j < frame->header.channels)) {
#line 244
        goto while_break___5;
      }
#line 245
      *(retpcm___0 + (offset + j)) = *(*(buffer + j) + pflac->bufferpos) << shift___0;
#line 244
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 246
    pflac->remain -= frame->header.channels;
#line 247
    (pflac->bufferpos) ++;
#line 238
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }

#line 250
  goto switch_break;
  case_52: /* CIL Label */ 
#line 253
  retpcm___1 = (float *)pflac->ptr;
#line 254
  if (psf->norm_float == 1) {
#line 254
    tmp = 1. / (double )(1 << (frame->header.bits_per_sample - 1U));
  } else {
#line 254
    tmp = 1.;
  }
#line 254
  norm = (float )tmp;
#line 256
  i = (unsigned int )0;
  {
#line 256
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 256
    if (! (i < frame->header.blocksize && pflac->remain > 0U)) {
#line 256
      goto while_break___6;
    }
#line 257
    offset = pflac->pos + i * frame->header.channels;
#line 259
    if (pflac->bufferpos >= frame->header.blocksize) {
#line 260
      goto while_break___6;
    }
#line 262
    j = (unsigned int )0;
    {
#line 262
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 262
      if (! (j < frame->header.channels)) {
#line 262
        goto while_break___7;
      }
#line 263
      *(retpcm___1 + (offset + j)) = (float )*(*(buffer + j) + pflac->bufferpos) * norm;
#line 262
      j ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 264
    pflac->remain -= frame->header.channels;
#line 265
    (pflac->bufferpos) ++;
#line 256
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }

#line 268
  goto switch_break;
  case_53: /* CIL Label */ 
#line 271
  retpcm___2 = (double *)pflac->ptr;
#line 272
  if (psf->norm_double == 1) {
#line 272
    tmp___0 = 1. / (double )(1 << (frame->header.bits_per_sample - 1U));
  } else {
#line 272
    tmp___0 = 1.;
  }
#line 272
  norm___0 = tmp___0;
#line 274
  i = (unsigned int )0;
  {
#line 274
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 274
    if (! (i < frame->header.blocksize && pflac->remain > 0U)) {
#line 274
      goto while_break___8;
    }
#line 275
    offset = pflac->pos + i * frame->header.channels;
#line 277
    if (pflac->bufferpos >= frame->header.blocksize) {
#line 278
      goto while_break___8;
    }
#line 280
    j = (unsigned int )0;
    {
#line 280
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 280
      if (! (j < frame->header.channels)) {
#line 280
        goto while_break___9;
      }
#line 281
      *(retpcm___2 + (offset + j)) = (double )*(*(buffer + j) + pflac->bufferpos) * norm___0;
#line 280
      j ++;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 282
    pflac->remain -= frame->header.channels;
#line 283
    (pflac->bufferpos) ++;
#line 274
    i ++;
  }
  while_break___8: /* CIL Label */ ;
  }

#line 286
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 289
  return ((sf_count_t )0);
  switch_break: /* CIL Label */ ;
  }
#line 292
  offset = i * frame->header.channels;
#line 293
  pflac->pos += i * frame->header.channels;
#line 295
  return ((sf_count_t )offset);
}
}
#line 300 "/root/libsndfile/src/flac.c"
static FLAC__StreamDecoderReadStatus sf_flac_read_callback(FLAC__StreamDecoder *UNUSED_decoder ,
                                                           FLAC__byte buffer[] , size_t *bytes ,
                                                           void *client_data ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t __cil_tmp6 ;

  {
  {
#line 301
  psf = (SF_PRIVATE *)client_data;
#line 303
  __cil_tmp6 = psf_fread(buffer, (sf_count_t )1, (sf_count_t )*bytes, psf);
#line 303
  *bytes = (size_t )__cil_tmp6;
  }
#line 304
  if (*bytes > 0UL) {
#line 304
    if (psf->error == 0) {
#line 305
      return ((FLAC__StreamDecoderReadStatus )0);
    }
  }
#line 307
  return ((FLAC__StreamDecoderReadStatus )2);
}
}
#line 311 "/root/libsndfile/src/flac.c"
static FLAC__StreamDecoderSeekStatus sf_flac_seek_callback(FLAC__StreamDecoder *UNUSED_decoder ,
                                                           FLAC__uint64 absolute_byte_offset ,
                                                           void *client_data ) 
{ 
  SF_PRIVATE *psf ;

  {
  {
#line 312
  psf = (SF_PRIVATE *)client_data;
#line 314
  psf_fseek(psf, (sf_count_t )absolute_byte_offset, 0);
  }
#line 315
  if (psf->error) {
#line 316
    return ((FLAC__StreamDecoderSeekStatus )1);
  }
#line 318
  return ((FLAC__StreamDecoderSeekStatus )0);
}
}
#line 322 "/root/libsndfile/src/flac.c"
static FLAC__StreamDecoderTellStatus sf_flac_tell_callback(FLAC__StreamDecoder *UNUSED_decoder ,
                                                           FLAC__uint64 *absolute_byte_offset ,
                                                           void *client_data ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t __cil_tmp5 ;

  {
  {
#line 323
  psf = (SF_PRIVATE *)client_data;
#line 325
  __cil_tmp5 = psf_ftell(psf);
#line 325
  *absolute_byte_offset = (FLAC__uint64 )__cil_tmp5;
  }
#line 326
  if (psf->error) {
#line 327
    return ((FLAC__StreamDecoderTellStatus )1);
  }
#line 329
  return ((FLAC__StreamDecoderTellStatus )0);
}
}
#line 333 "/root/libsndfile/src/flac.c"
static FLAC__StreamDecoderLengthStatus sf_flac_length_callback(FLAC__StreamDecoder *UNUSED_decoder ,
                                                               FLAC__uint64 *stream_length ,
                                                               void *client_data ) 
{ 
  SF_PRIVATE *psf ;

  {
#line 334
  psf = (SF_PRIVATE *)client_data;
#line 336
  *stream_length = (FLAC__uint64 )psf->filelength;
#line 336
  if (*stream_length == 0UL) {
#line 337
    return ((FLAC__StreamDecoderLengthStatus )1);
  }
#line 339
  return ((FLAC__StreamDecoderLengthStatus )0);
}
}
#line 343 "/root/libsndfile/src/flac.c"
static FLAC__bool sf_flac_eof_callback(FLAC__StreamDecoder *UNUSED_decoder , void *client_data ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t __cil_tmp4 ;

  {
  {
#line 344
  psf = (SF_PRIVATE *)client_data;
#line 346
  __cil_tmp4 = psf_ftell(psf);
  }
#line 346
  if (__cil_tmp4 == psf->filelength) {
#line 347
    return (1);
  }
#line 349
  return (0);
}
}
#line 353 "/root/libsndfile/src/flac.c"
static FLAC__StreamDecoderWriteStatus sf_flac_write_callback(FLAC__StreamDecoder *UNUSED_decoder ,
                                                             FLAC__Frame *frame ,
                                                             FLAC__int32 * const  buffer[] ,
                                                             void *client_data ) 
{ 
  SF_PRIVATE *psf ;
  FLAC_PRIVATE *pflac ;

  {
  {
#line 354
  psf = (SF_PRIVATE *)client_data;
#line 355
  pflac = (FLAC_PRIVATE *)psf->codec_data;
#line 357
  pflac->frame = frame;
#line 358
  pflac->bufferpos = (unsigned int )0;
#line 360
  pflac->bufferbackup = 0;
#line 361
  pflac->wbuffer = buffer;
#line 363
  flac_buffer_copy(psf);
  }
#line 365
  return ((FLAC__StreamDecoderWriteStatus )0);
}
}
#line 369 "/root/libsndfile/src/flac.c"
static void sf_flac_meta_get_vorbiscomments(SF_PRIVATE *psf , FLAC__StreamMetadata *metadata ) 
{ 
  FLAC_TAG tags[8] ;
  char const   *value ;
  char const   *cptr ;
  int k ;
  int tag_num ;
  int __cil_tmp8 ;
  char *__cil_tmp9 ;
  int __cil_tmp10 ;

  {
#line 370
  tags[0].tag = "title";
#line 370
  tags[0].type = 1;
#line 370
  tags[1].tag = "copyright3R\375\036V";
#line 370
  tags[1].type = 2;
#line 370
  tags[2].tag = "software\230";
#line 370
  tags[2].type = 3;
#line 370
  tags[3].tag = "artist";
#line 370
  tags[3].type = 4;
#line 370
  tags[4].tag = "comment";
#line 370
  tags[4].type = 5;
#line 370
  tags[5].tag = "date\036V";
#line 370
  tags[5].type = 6;
#line 370
  tags[6].tag = "album";
#line 370
  tags[6].type = 7;
#line 370
  tags[7].tag = "license";
#line 370
  tags[7].type = 8;
#line 384
  k = 0;
  {
#line 384
  while (1) {
    while_continue: /* CIL Label */ ;
#line 384
    if (! (k < (int )(sizeof(tags) / sizeof(tags[0])))) {
#line 384
      goto while_break;
    }
    {
#line 385
    tag_num = FLAC__metadata_object_vorbiscomment_find_entry_from(metadata, (uint32_t )0,
                                                                  tags[k].tag);
    }
#line 387
    if (tag_num < 0) {
#line 388
      goto while_continue;
    }
    {
#line 390
    value = (char const   *)(metadata->data.vorbis_comment.comments + tag_num)->entry;
#line 391
    __cil_tmp9 = strchr(value, '=');
#line 391
    cptr = (char const   *)__cil_tmp9;
    }
#line 391
    if (cptr != (void *)0) {
#line 392
      value = cptr + 1;
    }
    {
#line 394
    psf_log_printf(psf, "  %-10s : %s\nV", tags[k].tag, value);
#line 395
    psf_store_string(psf, tags[k].type, value);
    }
#line 384
    k ++;
  }
  while_break: /* CIL Label */ ;
  }

#line 398
  return;
}
}
#line 402 "/root/libsndfile/src/flac.c"
static void sf_flac_meta_callback(FLAC__StreamDecoder *UNUSED_decoder , FLAC__StreamMetadata *metadata ,
                                  void *client_data ) 
{ 
  SF_PRIVATE *psf ;
  int bitwidth ;

  {
#line 403
  psf = (SF_PRIVATE *)client_data;
#line 404
  bitwidth = 0;
  {
#line 407
  if ((unsigned int )metadata->type == (unsigned int )0) {
#line 407
    goto case_0;
  }
#line 415
  if ((unsigned int )metadata->type == (uint32_t )8) {
#line 415
    goto case_8;
  }
#line 419
  if ((unsigned int )metadata->type == (uint32_t )16) {
#line 419
    goto case_16;
  }
#line 423
  if ((unsigned int )metadata->type == (uint32_t )24) {
#line 423
    goto case_24;
  }
#line 436
  if ((unsigned int )metadata->type == (unsigned int )4) {
#line 436
    goto case_4;
  }
#line 441
  if ((unsigned int )metadata->type == (unsigned int )1) {
#line 441
    goto case_1;
  }
#line 445
  if ((unsigned int )metadata->type == (unsigned int )2) {
#line 445
    goto case_2;
  }
#line 449
  if ((unsigned int )metadata->type == (unsigned int )3) {
#line 449
    goto case_3;
  }
#line 453
  if ((unsigned int )metadata->type == (unsigned int )5) {
#line 453
    goto case_5;
  }
#line 457
  if ((unsigned int )metadata->type == (unsigned int )6) {
#line 457
    goto case_6;
  }
#line 461
  if ((unsigned int )metadata->type == (unsigned int )7) {
#line 461
    goto case_7;
  }
#line 465
  goto switch_default___0;
  case_0: /* CIL Label */ 
#line 408
  psf->sf.channels = (int )metadata->data.stream_info.channels;
  {
#line 409
  psf->sf.samplerate = (int )metadata->data.stream_info.sample_rate;
#line 410
  psf->sf.frames = (sf_count_t )metadata->data.stream_info.total_samples;
#line 412
  psf_log_printf(psf, "FLAC Stream Metadata\n  Channels    : %d\n  Sample rate : %d\n  Frames      : %D\n",
                 psf->sf.channels, psf->sf.samplerate, psf->sf.frames);
  }
  {
#line 415
  if (metadata->data.stream_info.bits_per_sample == (uint32_t )8) {
#line 415
    goto case_8;
  }
#line 419
  if (metadata->data.stream_info.bits_per_sample == (uint32_t )16) {
#line 419
    goto case_16;
  }
#line 423
  if (metadata->data.stream_info.bits_per_sample == (uint32_t )24) {
#line 423
    goto case_24;
  }
#line 427
  goto switch_default;
  case_8: /* CIL Label */ 
#line 416
  psf->sf.format |= 1;
#line 417
  bitwidth = 8;
#line 418
  goto switch_break___0;
  case_16: /* CIL Label */ 
#line 420
  psf->sf.format |= 2;
#line 421
  bitwidth = 16;
#line 422
  goto switch_break___0;
  case_24: /* CIL Label */ 
#line 424
  psf->sf.format |= 3;
#line 425
  bitwidth = 24;
#line 426
  goto switch_break___0;
  switch_default: /* CIL Label */ 
  {
#line 428
  psf_log_printf(psf, "sf_flac_meta_callback : bits_per_sample %d not yet implemented.\n\230\001",
                 metadata->data.stream_info.bits_per_sample);
  }
#line 429
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }

#line 432
  if (bitwidth > 0) {
    {
#line 433
    psf_log_printf(psf, "  Bit width   : %d\n\375\036V", bitwidth);
    }
  }
#line 434
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 437
  psf_log_printf(psf, "Vorbis Comment Metadata\n\220");
  }
  {
#line 438
  sf_flac_meta_get_vorbiscomments(psf, metadata);
  }
#line 439
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 442
  psf_log_printf(psf, "Padding Metadata\n");
  }
#line 443
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 446
  psf_log_printf(psf, "Application Metadata\n");
  }
#line 447
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 450
  psf_log_printf(psf, "Seektable Metadata\n");
  }
#line 451
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 454
  psf_log_printf(psf, "Cuesheet Metadata\n");
  }
#line 455
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 458
  psf_log_printf(psf, "Picture Metadata\n");
  }
#line 459
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 462
  psf_log_printf(psf, "Undefined Metadata\n");
  }
#line 463
  goto switch_break;
  switch_default___0: /* CIL Label */ 
  {
#line 466
  psf_log_printf(psf, "sf_flac_meta_callback : metadata-type %d not yet implemented.\n",
                 (unsigned int )metadata->type);
  }
#line 467
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }

#line 470
  return;
}
}
#line 474 "/root/libsndfile/src/flac.c"
static void sf_flac_error_callback(FLAC__StreamDecoder *UNUSED_decoder , FLAC__StreamDecoderErrorStatus status ,
                                   void *client_data ) 
{ 
  SF_PRIVATE *psf ;

  {
  {
#line 475
  psf = (SF_PRIVATE *)client_data;
#line 477
  psf_log_printf(psf, "ERROR : %s\n", FLAC__StreamDecoderErrorStatusString[status]);
  }
  {
#line 480
  if ((unsigned int )status == (unsigned int )0) {
#line 480
    goto case_0;
  }
#line 483
  if ((unsigned int )status == (unsigned int )1) {
#line 483
    goto case_1;
  }
#line 486
  goto switch_default;
  case_0: /* CIL Label */ 
#line 481
  psf->error = 150;
#line 482
  goto switch_break;
  case_1: /* CIL Label */ 
#line 484
  psf->error = 147;
#line 485
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 487
  psf->error = 152;
#line 488
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }

#line 491
  return;
}
}
#line 495 "/root/libsndfile/src/flac.c"
static FLAC__StreamEncoderSeekStatus sf_flac_enc_seek_callback(FLAC__StreamEncoder *UNUSED_encoder ,
                                                               FLAC__uint64 absolute_byte_offset ,
                                                               void *client_data ) 
{ 
  SF_PRIVATE *psf ;

  {
  {
#line 496
  psf = (SF_PRIVATE *)client_data;
#line 498
  psf_fseek(psf, (sf_count_t )absolute_byte_offset, 0);
  }
#line 499
  if (psf->error) {
#line 500
    return ((FLAC__StreamEncoderSeekStatus )1);
  }
#line 502
  return ((FLAC__StreamEncoderSeekStatus )0);
}
}
#line 506 "/root/libsndfile/src/flac.c"
static FLAC__StreamEncoderTellStatus sf_flac_enc_tell_callback(FLAC__StreamEncoder *UNUSED_encoder ,
                                                               FLAC__uint64 *absolute_byte_offset ,
                                                               void *client_data ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t __cil_tmp5 ;

  {
  {
#line 507
  psf = (SF_PRIVATE *)client_data;
#line 509
  __cil_tmp5 = psf_ftell(psf);
#line 509
  *absolute_byte_offset = (FLAC__uint64 )__cil_tmp5;
  }
#line 510
  if (psf->error) {
#line 511
    return ((FLAC__StreamEncoderTellStatus )1);
  }
#line 513
  return ((FLAC__StreamEncoderTellStatus )0);
}
}
#line 517 "/root/libsndfile/src/flac.c"
static FLAC__StreamEncoderWriteStatus sf_flac_enc_write_callback(FLAC__StreamEncoder *UNUSED_encoder ,
                                                                 FLAC__byte buffer[] ,
                                                                 size_t bytes , unsigned int UNUSED_samples ,
                                                                 unsigned int UNUSED_current_frame ,
                                                                 void *client_data ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t __cil_tmp8 ;

  {
  {
#line 518
  psf = (SF_PRIVATE *)client_data;
#line 520
  __cil_tmp8 = psf_fwrite(buffer, (sf_count_t )1, (sf_count_t )bytes, psf);
  }
#line 520
  if (__cil_tmp8 == (sf_count_t )bytes) {
#line 520
    if (psf->error == 0) {
#line 521
      return ((FLAC__StreamEncoderWriteStatus )0);
    }
  }
#line 523
  return ((FLAC__StreamEncoderWriteStatus )1);
}
}
#line 527 "/root/libsndfile/src/flac.c"
static void flac_write_strings(SF_PRIVATE *psf , FLAC_PRIVATE *pflac ) 
{ 
  FLAC__StreamMetadata_VorbisComment_Entry entry ;
  int k ;
  int string_count ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  FLAC__StreamMetadata *__cil_tmp8 ;
  char const   *key ;
  char const   *value ;
  int __cil_tmp11 ;
  FLAC__bool __cil_tmp12 ;

  {
#line 529
  string_count = 0;
#line 531
  k = 0;
  {
#line 531
  while (1) {
    while_continue: /* CIL Label */ ;
#line 531
    if (! (k < 32)) {
#line 531
      goto while_break;
    }
#line 532
    if (psf->strings[k].type != 0) {
#line 533
      string_count ++;
    }
#line 531
    k ++;
  }
  while_break: /* CIL Label */ ;
  }

#line 536
  if (string_count == 0) {
#line 537
    return;
  }
  {
#line 539
  pflac->metadata = FLAC__metadata_object_new((FLAC__MetadataType )4);
  }
#line 539
  if (pflac->metadata == (void *)0) {
#line 539
    if (pflac->metadata == (void *)0) {
      {
#line 540
      psf_log_printf(psf, "FLAC__metadata_object_new returned NULL\n\220");
      }
#line 541
      return;
    }
  }
#line 544
  k = 0;
  {
#line 544
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 544
    if (! (k < 32 && psf->strings[k].type != 0)) {
#line 544
      goto while_break___0;
    }
    {
#line 548
    if (psf->strings[k].type == 3) {
#line 548
      goto case_3;
    }
#line 551
    if (psf->strings[k].type == 1) {
#line 551
      goto case_1;
    }
#line 554
    if (psf->strings[k].type == 2) {
#line 554
      goto case_2;
    }
#line 557
    if (psf->strings[k].type == 4) {
#line 557
      goto case_4;
    }
#line 560
    if (psf->strings[k].type == 5) {
#line 560
      goto case_5;
    }
#line 563
    if (psf->strings[k].type == 6) {
#line 563
      goto case_6;
    }
#line 566
    if (psf->strings[k].type == 7) {
#line 566
      goto case_7;
    }
#line 569
    if (psf->strings[k].type == 8) {
#line 569
      goto case_8;
    }
#line 572
    goto switch_default;
    case_3: /* CIL Label */ 
#line 549
    key = "software\220";
#line 550
    goto switch_break;
    case_1: /* CIL Label */ 
#line 552
    key = "title";
#line 553
    goto switch_break;
    case_2: /* CIL Label */ 
#line 555
    key = "copyright";
#line 556
    goto switch_break;
    case_4: /* CIL Label */ 
#line 558
    key = "artist";
#line 559
    goto switch_break;
    case_5: /* CIL Label */ 
#line 561
    key = "comment";
#line 562
    goto switch_break;
    case_6: /* CIL Label */ 
#line 564
    key = "date";
#line 565
    goto switch_break;
    case_7: /* CIL Label */ 
#line 567
    key = "album";
#line 568
    goto switch_break;
    case_8: /* CIL Label */ 
#line 570
    key = "license";
#line 571
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 573
    goto while_continue___0;
    switch_break: /* CIL Label */ ;
    }
    {
#line 576
    value = (char const   *)psf->strings[k].str;
#line 578
    FLAC__metadata_object_vorbiscomment_entry_from_name_value_pair(& entry, key, value);
#line 579
    FLAC__metadata_object_vorbiscomment_append_comment(pflac->metadata, entry, 0);
    }
#line 544
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 582
  __cil_tmp12 = FLAC__stream_encoder_set_metadata(pflac->fse, & pflac->metadata, (uint32_t )1);
  }
#line 582
  if (! __cil_tmp12) {
    {
#line 583
    printf("%s %d : fail\n", "flac_write_strings", 583);
    }
#line 584
    return;
  }

#line 587
  return;
}
}
#line 591 "/root/libsndfile/src/flac.c"
static int flac_write_header(SF_PRIVATE *psf , int UNUSED_calc_length ) 
{ 
  FLAC_PRIVATE *pflac ;
  int err ;
  FLAC__StreamEncoderInitStatus __cil_tmp5 ;
  sf_count_t __cil_tmp6 ;
  void *__cil_tmp7 ;

  {
  {
#line 592
  pflac = (FLAC_PRIVATE *)psf->codec_data;
#line 595
  flac_write_strings(psf, pflac);
#line 597
  __cil_tmp5 = FLAC__stream_encoder_init_stream(pflac->fse, & sf_flac_enc_write_callback,
                                                & sf_flac_enc_seek_callback, & sf_flac_enc_tell_callback,
                                                (FLAC__StreamEncoderMetadataCallback )((void *)0),
                                                psf);
#line 597
  err = (int )__cil_tmp5;
  }
#line 597
  if (err != 0) {
    {
#line 598
    psf_log_printf(psf, "Error : FLAC encoder init returned error : %s\n", FLAC__StreamEncoderInitStatusString[err]);
    }
#line 599
    return (149);
  }

#line 602
  if (psf->error == 0) {
    {
#line 603
    psf->dataoffset = psf_ftell(psf);
    }
  }
  {
#line 604
  pflac->encbuffer = (FLAC__int32 *)calloc((unsigned long )8192, sizeof(FLAC__int32 ));
  }
#line 606
  return (psf->error);
}
}
#line 614 "/root/libsndfile/src/flac.c"
int flac_open(SF_PRIVATE *psf ) 
{ 
  int subformat ;
  int error ;
  FLAC_PRIVATE *pflac ;
  void *__cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
  {
#line 616
  error = 0;
#line 618
  __cil_tmp5 = calloc((unsigned long )1, sizeof(FLAC_PRIVATE ));
#line 618
  pflac = __cil_tmp5;
#line 619
  psf->codec_data = pflac;
  }
#line 621
  if (psf->mode == 48) {
#line 622
    return (23);
  }
#line 624
  if (psf->mode == 16) {
    {
#line 625
    error = flac_read_header(psf);
    }
#line 625
    if (error) {
#line 626
      return (error);
    }
  }
#line 629
  subformat = psf->sf.format & 65535;
#line 631
  if (psf->mode == 32) {
#line 632
    if ((psf->sf.format & 268369920) != 1507328) {
#line 633
      return (1);
    }
    {
#line 635
    psf->endian = 536870912;
#line 636
    psf->sf.seekable = 0;
#line 638
    psf->str_flags = 256;
#line 640
    error = flac_enc_init(psf);
    }
#line 640
    if (error) {
#line 641
      return (error);
    }
#line 643
    psf->write_header = & flac_write_header;
  }
#line 646
  psf->datalength = psf->filelength;
#line 647
  psf->dataoffset = (sf_count_t )0;
#line 648
  psf->blockwidth = 0;
#line 649
  psf->bytewidth = 1;
#line 651
  psf->container_close = & flac_close;
#line 652
  psf->seek = & flac_seek;
#line 653
  psf->command = & flac_command;
#line 655
  psf->blockwidth = psf->bytewidth * psf->sf.channels;
  {
#line 660
  if (subformat == 3) {
#line 660
    goto case_3;
  }
#line 660
  if (subformat == 2) {
#line 660
    goto case_3;
  }
#line 660
  if (subformat == 1) {
#line 660
    goto case_3;
  }
#line 664
  goto switch_default;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 661
  error = flac_init(psf);
  }
#line 662
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 664
  return (17);
  switch_break: /* CIL Label */ ;
  }

#line 667
  return (error);
}
}
#line 674 "/root/libsndfile/src/flac.c"
static int flac_close(SF_PRIVATE *psf ) 
{ 
  FLAC_PRIVATE *pflac ;
  int k ;
  int __cil_tmp4 ;

  {
#line 678
  pflac = (FLAC_PRIVATE *)psf->codec_data;
#line 678
  if (pflac == (void *)0) {
#line 679
    return (0);
  }
#line 681
  if (pflac->metadata != (void *)0) {
    {
#line 682
    FLAC__metadata_object_delete(pflac->metadata);
    }
  }
#line 684
  if (psf->mode == 32) {
    {
#line 685
    FLAC__stream_encoder_finish(pflac->fse);
#line 686
    FLAC__stream_encoder_delete(pflac->fse);
    }
#line 688
    if (pflac->encbuffer) {
      {
#line 689
      free(pflac->encbuffer);
      }
    }
  }

#line 692
  if (psf->mode == 16) {
    {
#line 693
    FLAC__stream_decoder_finish(pflac->fsd);
#line 694
    FLAC__stream_decoder_delete(pflac->fsd);
    }
  }
#line 697
  k = 0;
  {
#line 697
  while (1) {
    while_continue: /* CIL Label */ ;
#line 697
    if (! (k < (int )(sizeof(pflac->rbuffer) / sizeof(pflac->rbuffer[0])))) {
#line 697
      goto while_break;
    }
    {
#line 698
    free(pflac->rbuffer[k]);
    }
#line 697
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 700
  free(pflac);
#line 701
  psf->codec_data = (void *)0;
  }
#line 703
  return (0);
}
}
#line 707 "/root/libsndfile/src/flac.c"
static int flac_enc_init(SF_PRIVATE *psf ) 
{ 
  FLAC_PRIVATE *pflac ;
  unsigned int bps ;
  int k ;
  int found ;
  int __cil_tmp6 ;
  FLAC__StreamEncoder *__cil_tmp7 ;
  FLAC__bool __cil_tmp8 ;
  FLAC__bool __cil_tmp9 ;
  FLAC__bool __cil_tmp10 ;

  {
#line 708
  pflac = (FLAC_PRIVATE *)psf->codec_data;
#line 712
  found = 0;
#line 713
  k = 0;
  {
#line 713
  while (1) {
    while_continue: /* CIL Label */ ;
#line 713
    if (! (k < (int )(sizeof(legal_sample_rates) / sizeof(legal_sample_rates[0])))) {
#line 713
      goto while_break;
    }
#line 714
    if (psf->sf.samplerate == legal_sample_rates[k]) {
#line 715
      found = 1;
#line 716
      goto while_break;
    }
#line 713
    k ++;
  }
  while_break: /* CIL Label */ ;
  }

#line 719
  if (found == 0) {
#line 720
    return (151);
  }
  {
#line 722
  psf_fseek(psf, (sf_count_t )0, 0);
  }
  {
#line 725
  if ((psf->sf.format & 65535) == 1) {
#line 725
    goto case_1;
  }
#line 728
  if ((psf->sf.format & 65535) == 2) {
#line 728
    goto case_2;
  }
#line 731
  if ((psf->sf.format & 65535) == 3) {
#line 731
    goto case_3;
  }
#line 735
  goto switch_default;
  case_1: /* CIL Label */ 
#line 726
  bps = (unsigned int )8;
#line 727
  goto switch_break;
  case_2: /* CIL Label */ 
#line 729
  bps = (unsigned int )16;
#line 730
  goto switch_break;
  case_3: /* CIL Label */ 
#line 732
  bps = (unsigned int )24;
#line 733
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 736
  bps = (unsigned int )0;
#line 737
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 740
  pflac->fse = FLAC__stream_encoder_new();
  }
#line 740
  if (pflac->fse == (void *)0) {
#line 741
    return (148);
  }
  {
#line 743
  __cil_tmp8 = FLAC__stream_encoder_set_channels(pflac->fse, (uint32_t )psf->sf.channels);
  }
#line 743
  if (! __cil_tmp8) {
    {
#line 744
    psf_log_printf(psf, "FLAC__stream_encoder_set_channels (%d) return false.\n",
                   psf->sf.channels);
    }
#line 745
    return (149);
  }
  {
#line 748
  __cil_tmp9 = FLAC__stream_encoder_set_sample_rate(pflac->fse, (uint32_t )psf->sf.samplerate);
  }
#line 748
  if (! __cil_tmp9) {
    {
#line 749
    psf_log_printf(psf, "FLAC__stream_encoder_set_sample_rate (%d) returned false.\n",
                   psf->sf.samplerate);
    }
#line 750
    return (151);
  }
  {
#line 753
  __cil_tmp10 = FLAC__stream_encoder_set_bits_per_sample(pflac->fse, bps);
  }
#line 753
  if (! __cil_tmp10) {
    {
#line 754
    psf_log_printf(psf, "FLAC__stream_encoder_set_bits_per_sample (%d) return false.\n\036V",
                   bps);
    }
#line 755
    return (149);
  }

#line 758
  return (0);
}
}
#line 762 "/root/libsndfile/src/flac.c"
static int flac_read_header(SF_PRIVATE *psf ) 
{ 
  FLAC_PRIVATE *pflac ;
  FLAC__StreamDecoder *__cil_tmp3 ;
  FLAC__StreamDecoderInitStatus __cil_tmp4 ;
  FLAC__uint64 position ;

  {
  {
#line 763
  pflac = (FLAC_PRIVATE *)psf->codec_data;
#line 765
  psf_fseek(psf, (sf_count_t )0, 0);
#line 766
  pflac->fsd = FLAC__stream_decoder_new();
  }
#line 766
  if (pflac->fsd == (void *)0) {
#line 767
    return (148);
  }
  {
#line 769
  FLAC__stream_decoder_set_metadata_respond_all(pflac->fsd);
#line 771
  __cil_tmp4 = FLAC__stream_decoder_init_stream(pflac->fsd, & sf_flac_read_callback,
                                                & sf_flac_seek_callback, & sf_flac_tell_callback,
                                                & sf_flac_length_callback, & sf_flac_eof_callback,
                                                & sf_flac_write_callback, & sf_flac_meta_callback,
                                                & sf_flac_error_callback, psf);
  }
#line 771
  if ((unsigned int )__cil_tmp4 != 0U) {
#line 772
    return (149);
  }
  {
#line 774
  FLAC__stream_decoder_process_until_end_of_metadata(pflac->fsd);
#line 776
  psf_log_printf(psf, "End\n");
  }
#line 778
  if (psf->error == 0) {
    {
#line 781
    FLAC__stream_decoder_get_decode_position(pflac->fsd, & position);
#line 782
    psf->dataoffset = (sf_count_t )position;
    }
  }

#line 785
  return (psf->error);
}
}
#line 789 "/root/libsndfile/src/flac.c"
static int flac_command(SF_PRIVATE *UNUSED_psf , int UNUSED_command , void *UNUSED_data ,
                        int UNUSED_datasize ) 
{ 


  {
#line 791
  return (0);
}
}
#line 795 "/root/libsndfile/src/flac.c"
int flac_init(SF_PRIVATE *psf ) 
{ 
  sf_count_t tmp ;

  {
#line 797
  if (psf->mode == 48) {
#line 798
    return (23);
  }
#line 800
  if (psf->mode == 16) {
#line 801
    psf->read_short = & flac_read_flac2s;
#line 802
    psf->read_int = & flac_read_flac2i;
#line 803
    psf->read_float = & flac_read_flac2f;
#line 804
    psf->read_double = & flac_read_flac2d;
  }

#line 807
  if (psf->mode == 32) {
#line 808
    psf->write_short = & flac_write_s2flac;
#line 809
    psf->write_int = & flac_write_i2flac;
#line 810
    psf->write_float = & flac_write_f2flac;
#line 811
    psf->write_double = & flac_write_d2flac;
  }
#line 814
  psf->bytewidth = 1;
#line 815
  psf->blockwidth = psf->sf.channels;
#line 817
  if (psf->filelength > psf->dataoffset) {
#line 818
    if (psf->dataend) {
#line 818
      tmp = psf->dataend - psf->dataoffset;
    } else {
#line 818
      tmp = psf->filelength - psf->dataoffset;
    }
#line 818
    psf->datalength = tmp;
  } else {
#line 820
    psf->datalength = (sf_count_t )0;
  }
#line 822
  return (0);
}
}
#line 826 "/root/libsndfile/src/flac.c"
static unsigned int flac_read_loop(SF_PRIVATE *psf , unsigned int len ) 
{ 
  FLAC_PRIVATE *pflac ;
  FLAC__bool __cil_tmp4 ;
  FLAC__StreamDecoderState __cil_tmp5 ;

  {
#line 827
  pflac = (FLAC_PRIVATE *)psf->codec_data;
#line 829
  pflac->pos = (unsigned int )0;
#line 830
  pflac->len = len;
#line 831
  pflac->remain = len;
#line 832
  if (pflac->frame != (void *)0) {
#line 832
    if (pflac->bufferpos < (pflac->frame)->header.blocksize) {
      {
#line 833
      flac_buffer_copy(psf);
      }
    }
  }
  {
#line 835
  while (1) {
    while_continue: /* CIL Label */ ;
#line 835
    if (! (pflac->pos < pflac->len)) {
#line 835
      goto while_break;
    }
    {
#line 836
    __cil_tmp4 = FLAC__stream_decoder_process_single(pflac->fsd);
    }
#line 836
    if (__cil_tmp4 == 0) {
#line 837
      goto while_break;
    }
    {
#line 838
    __cil_tmp5 = FLAC__stream_decoder_get_state(pflac->fsd);
    }
#line 838
    if ((unsigned int )__cil_tmp5 >= 4U) {
#line 839
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 842
  pflac->ptr = (void *)0;
#line 844
  return (pflac->pos);
}
}
#line 848 "/root/libsndfile/src/flac.c"
static sf_count_t flac_read_flac2s(SF_PRIVATE *psf , short *ptr , sf_count_t len ) 
{ 
  FLAC_PRIVATE *pflac ;
  sf_count_t total ;
  sf_count_t current ;
  unsigned int readlen ;
  unsigned int tmp ;
  unsigned int __cil_tmp9 ;

  {
#line 849
  pflac = (FLAC_PRIVATE *)psf->codec_data;
#line 850
  total = (sf_count_t )0;
#line 853
  pflac->pcmtype = (PFLAC_PCM )50;
  {
#line 855
  while (1) {
    while_continue: /* CIL Label */ ;
#line 855
    if (! (total < len)) {
#line 855
      goto while_break;
    }
#line 856
    pflac->ptr = ptr + total;
#line 857
    if (len - total > 16777216L) {
#line 857
      tmp = (unsigned int )16777216;
    } else {
#line 857
      tmp = (unsigned int )(len - total);
    }
    {
#line 857
    readlen = tmp;
#line 858
    __cil_tmp9 = flac_read_loop(psf, readlen);
#line 858
    current = (sf_count_t )__cil_tmp9;
    }
#line 859
    if (current == 0L) {
#line 860
      goto while_break;
    }
#line 861
    total += current;
  }
  while_break: /* CIL Label */ ;
  }

#line 864
  return (total);
}
}
#line 868 "/root/libsndfile/src/flac.c"
static sf_count_t flac_read_flac2i(SF_PRIVATE *psf , int *ptr , sf_count_t len ) 
{ 
  FLAC_PRIVATE *pflac ;
  sf_count_t total ;
  sf_count_t current ;
  unsigned int readlen ;
  unsigned int tmp ;
  unsigned int __cil_tmp9 ;

  {
#line 869
  pflac = (FLAC_PRIVATE *)psf->codec_data;
#line 870
  total = (sf_count_t )0;
#line 873
  pflac->pcmtype = (PFLAC_PCM )51;
  {
#line 875
  while (1) {
    while_continue: /* CIL Label */ ;
#line 875
    if (! (total < len)) {
#line 875
      goto while_break;
    }
#line 876
    pflac->ptr = ptr + total;
#line 877
    if (len - total > 16777216L) {
#line 877
      tmp = (unsigned int )16777216;
    } else {
#line 877
      tmp = (unsigned int )(len - total);
    }
    {
#line 877
    readlen = tmp;
#line 878
    __cil_tmp9 = flac_read_loop(psf, readlen);
#line 878
    current = (sf_count_t )__cil_tmp9;
    }
#line 879
    if (current == 0L) {
#line 880
      goto while_break;
    }
#line 881
    total += current;
  }
  while_break: /* CIL Label */ ;
  }

#line 884
  return (total);
}
}
#line 888 "/root/libsndfile/src/flac.c"
static sf_count_t flac_read_flac2f(SF_PRIVATE *psf , float *ptr , sf_count_t len ) 
{ 
  FLAC_PRIVATE *pflac ;
  sf_count_t total ;
  sf_count_t current ;
  unsigned int readlen ;
  unsigned int tmp ;
  unsigned int __cil_tmp9 ;

  {
#line 889
  pflac = (FLAC_PRIVATE *)psf->codec_data;
#line 890
  total = (sf_count_t )0;
#line 893
  pflac->pcmtype = (PFLAC_PCM )52;
  {
#line 895
  while (1) {
    while_continue: /* CIL Label */ ;
#line 895
    if (! (total < len)) {
#line 895
      goto while_break;
    }
#line 896
    pflac->ptr = ptr + total;
#line 897
    if (len - total > 16777216L) {
#line 897
      tmp = (unsigned int )16777216;
    } else {
#line 897
      tmp = (unsigned int )(len - total);
    }
    {
#line 897
    readlen = tmp;
#line 898
    __cil_tmp9 = flac_read_loop(psf, readlen);
#line 898
    current = (sf_count_t )__cil_tmp9;
    }
#line 899
    if (current == 0L) {
#line 900
      goto while_break;
    }
#line 901
    total += current;
  }
  while_break: /* CIL Label */ ;
  }

#line 904
  return (total);
}
}
#line 908 "/root/libsndfile/src/flac.c"
static sf_count_t flac_read_flac2d(SF_PRIVATE *psf , double *ptr , sf_count_t len ) 
{ 
  FLAC_PRIVATE *pflac ;
  sf_count_t total ;
  sf_count_t current ;
  unsigned int readlen ;
  unsigned int tmp ;
  unsigned int __cil_tmp9 ;

  {
#line 909
  pflac = (FLAC_PRIVATE *)psf->codec_data;
#line 910
  total = (sf_count_t )0;
#line 913
  pflac->pcmtype = (PFLAC_PCM )53;
  {
#line 915
  while (1) {
    while_continue: /* CIL Label */ ;
#line 915
    if (! (total < len)) {
#line 915
      goto while_break;
    }
#line 916
    pflac->ptr = ptr + total;
#line 917
    if (len - total > 16777216L) {
#line 917
      tmp = (unsigned int )16777216;
    } else {
#line 917
      tmp = (unsigned int )(len - total);
    }
    {
#line 917
    readlen = tmp;
#line 918
    __cil_tmp9 = flac_read_loop(psf, readlen);
#line 918
    current = (sf_count_t )__cil_tmp9;
    }
#line 919
    if (current == 0L) {
#line 920
      goto while_break;
    }
#line 921
    total += current;
  }
  while_break: /* CIL Label */ ;
  }

#line 924
  return (total);
}
}
#line 928 "/root/libsndfile/src/flac.c"
static sf_count_t flac_write_s2flac(SF_PRIVATE *psf , short const   *ptr , sf_count_t len ) 
{ 
  FLAC_PRIVATE *pflac ;
  void (*convert)(short const   * , FLAC__int32 * , int  ) ;
  int bufferlen ;
  int writecount ;
  int thiswrite ;
  sf_count_t total ;
  FLAC__int32 *buffer ;
  int tmp ;
  FLAC__bool __cil_tmp12 ;

  {
#line 929
  pflac = (FLAC_PRIVATE *)psf->codec_data;
#line 932
  total = (sf_count_t )0;
#line 933
  buffer = pflac->encbuffer;
  {
#line 936
  if ((psf->sf.format & 65535) == 1) {
#line 936
    goto case_1;
  }
#line 939
  if ((psf->sf.format & 65535) == 2) {
#line 939
    goto case_2;
  }
#line 942
  if ((psf->sf.format & 65535) == 3) {
#line 942
    goto case_3;
  }
#line 945
  goto switch_default;
  case_1: /* CIL Label */ 
#line 937
  convert = & s2flac8_array;
#line 938
  goto switch_break;
  case_2: /* CIL Label */ 
#line 940
  convert = & s2flac16_array;
#line 941
  goto switch_break;
  case_3: /* CIL Label */ 
#line 943
  convert = & s2flac24_array;
#line 944
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 946
  return ((sf_count_t )(- 1));
  switch_break: /* CIL Label */ ;
  }
#line 949
  bufferlen = (int )(8192UL / (sizeof(FLAC__int32 ) * (unsigned long )psf->sf.channels));
#line 950
  bufferlen *= psf->sf.channels;
  {
#line 952
  while (1) {
    while_continue: /* CIL Label */ ;
#line 952
    if (! (len > 0L)) {
#line 952
      goto while_break;
    }
#line 953
    if (len >= (long )bufferlen) {
#line 953
      tmp = bufferlen;
    } else {
#line 953
      tmp = (int )len;
    }
    {
#line 953
    writecount = tmp;
#line 954
    (*convert)(ptr + total, buffer, writecount);
#line 955
    __cil_tmp12 = FLAC__stream_encoder_process_interleaved(pflac->fse, (FLAC__int32 [])buffer,
                                                           (uint32_t )(writecount / psf->sf.channels));
    }
#line 955
    if (__cil_tmp12) {
#line 956
      thiswrite = writecount;
    } else {
#line 958
      goto while_break;
    }
#line 959
    total += (long )thiswrite;
#line 960
    if (thiswrite < writecount) {
#line 961
      goto while_break;
    }
#line 963
    len -= (long )thiswrite;
  }
  while_break: /* CIL Label */ ;
  }

#line 966
  return (total);
}
}
#line 970 "/root/libsndfile/src/flac.c"
static sf_count_t flac_write_i2flac(SF_PRIVATE *psf , int const   *ptr , sf_count_t len ) 
{ 
  FLAC_PRIVATE *pflac ;
  void (*convert)(int const   * , FLAC__int32 * , int  ) ;
  int bufferlen ;
  int writecount ;
  int thiswrite ;
  sf_count_t total ;
  FLAC__int32 *buffer ;
  int tmp ;
  FLAC__bool __cil_tmp12 ;

  {
#line 971
  pflac = (FLAC_PRIVATE *)psf->codec_data;
#line 974
  total = (sf_count_t )0;
#line 975
  buffer = pflac->encbuffer;
  {
#line 978
  if ((psf->sf.format & 65535) == 1) {
#line 978
    goto case_1;
  }
#line 981
  if ((psf->sf.format & 65535) == 2) {
#line 981
    goto case_2;
  }
#line 984
  if ((psf->sf.format & 65535) == 3) {
#line 984
    goto case_3;
  }
#line 987
  goto switch_default;
  case_1: /* CIL Label */ 
#line 979
  convert = & i2flac8_array;
#line 980
  goto switch_break;
  case_2: /* CIL Label */ 
#line 982
  convert = & i2flac16_array;
#line 983
  goto switch_break;
  case_3: /* CIL Label */ 
#line 985
  convert = & i2flac24_array;
#line 986
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 988
  return ((sf_count_t )(- 1));
  switch_break: /* CIL Label */ ;
  }
#line 991
  bufferlen = (int )(8192UL / (sizeof(FLAC__int32 ) * (unsigned long )psf->sf.channels));
#line 992
  bufferlen *= psf->sf.channels;
  {
#line 994
  while (1) {
    while_continue: /* CIL Label */ ;
#line 994
    if (! (len > 0L)) {
#line 994
      goto while_break;
    }
#line 995
    if (len >= (long )bufferlen) {
#line 995
      tmp = bufferlen;
    } else {
#line 995
      tmp = (int )len;
    }
    {
#line 995
    writecount = tmp;
#line 996
    (*convert)(ptr + total, buffer, writecount);
#line 997
    __cil_tmp12 = FLAC__stream_encoder_process_interleaved(pflac->fse, (FLAC__int32 [])buffer,
                                                           (uint32_t )(writecount / psf->sf.channels));
    }
#line 997
    if (__cil_tmp12) {
#line 998
      thiswrite = writecount;
    } else {
#line 1000
      goto while_break;
    }
#line 1001
    total += (long )thiswrite;
#line 1002
    if (thiswrite < writecount) {
#line 1003
      goto while_break;
    }
#line 1005
    len -= (long )thiswrite;
  }
  while_break: /* CIL Label */ ;
  }

#line 1008
  return (total);
}
}
#line 1012 "/root/libsndfile/src/flac.c"
static sf_count_t flac_write_f2flac(SF_PRIVATE *psf , float const   *ptr , sf_count_t len ) 
{ 
  FLAC_PRIVATE *pflac ;
  void (*convert)(float const   * , FLAC__int32 * , int  , int  ) ;
  int bufferlen ;
  int writecount ;
  int thiswrite ;
  sf_count_t total ;
  FLAC__int32 *buffer ;
  void (*tmp)(float const   *src , FLAC__int32 *dest , int count , int normalize ) ;
  void (*tmp___0)(float const   *src , FLAC__int32 *dest , int count , int normalize ) ;
  void (*tmp___1)(float const   *src , FLAC__int32 *dest , int count , int normalize ) ;
  int tmp___2 ;
  FLAC__bool __cil_tmp15 ;

  {
#line 1013
  pflac = (FLAC_PRIVATE *)psf->codec_data;
#line 1016
  total = (sf_count_t )0;
#line 1017
  buffer = pflac->encbuffer;
  {
#line 1020
  if ((psf->sf.format & 65535) == 1) {
#line 1020
    goto case_1;
  }
#line 1023
  if ((psf->sf.format & 65535) == 2) {
#line 1023
    goto case_2;
  }
#line 1026
  if ((psf->sf.format & 65535) == 3) {
#line 1026
    goto case_3;
  }
#line 1029
  goto switch_default;
  case_1: /* CIL Label */ 
#line 1021
  if (psf->add_clipping) {
#line 1021
    tmp = & f2flac8_clip_array;
  } else {
#line 1021
    tmp = & f2flac8_array;
  }
#line 1021
  convert = tmp;
#line 1022
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1024
  if (psf->add_clipping) {
#line 1024
    tmp___0 = & f2flac16_clip_array;
  } else {
#line 1024
    tmp___0 = & f2flac16_array;
  }
#line 1024
  convert = tmp___0;
#line 1025
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1027
  if (psf->add_clipping) {
#line 1027
    tmp___1 = & f2flac24_clip_array;
  } else {
#line 1027
    tmp___1 = & f2flac24_array;
  }
#line 1027
  convert = tmp___1;
#line 1028
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1030
  return ((sf_count_t )(- 1));
  switch_break: /* CIL Label */ ;
  }
#line 1033
  bufferlen = (int )(8192UL / (sizeof(FLAC__int32 ) * (unsigned long )psf->sf.channels));
#line 1034
  bufferlen *= psf->sf.channels;
  {
#line 1036
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1036
    if (! (len > 0L)) {
#line 1036
      goto while_break;
    }
#line 1037
    if (len >= (long )bufferlen) {
#line 1037
      tmp___2 = bufferlen;
    } else {
#line 1037
      tmp___2 = (int )len;
    }
    {
#line 1037
    writecount = tmp___2;
#line 1038
    (*convert)(ptr + total, buffer, writecount, psf->norm_float);
#line 1039
    __cil_tmp15 = FLAC__stream_encoder_process_interleaved(pflac->fse, (FLAC__int32 [])buffer,
                                                           (uint32_t )(writecount / psf->sf.channels));
    }
#line 1039
    if (__cil_tmp15) {
#line 1040
      thiswrite = writecount;
    } else {
#line 1042
      goto while_break;
    }
#line 1043
    total += (long )thiswrite;
#line 1044
    if (thiswrite < writecount) {
#line 1045
      goto while_break;
    }
#line 1047
    len -= (long )thiswrite;
  }
  while_break: /* CIL Label */ ;
  }

#line 1050
  return (total);
}
}
#line 1054 "/root/libsndfile/src/flac.c"
static void f2flac8_clip_array(float const   *src , FLAC__int32 *dest , int count ,
                               int normalize ) 
{ 
  float normfact ;
  float scaled_value ;
  double tmp ;
  long __cil_tmp8 ;

  {
#line 1057
  if (normalize) {
#line 1057
    tmp = 8. * (double )16;
  } else {
#line 1057
    tmp = 1.;
  }
#line 1057
  normfact = (float )tmp;
  {
#line 1059
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1059
    count --;
#line 1059
    if (! (count >= 0)) {
#line 1059
      goto while_break;
    }
#line 1060
    scaled_value = *(src + count) * normfact;
#line 1061
    if ((double )scaled_value >= 1. * (double )127) {
#line 1062
      *(dest + count) = 127;
#line 1063
      goto while_continue;
    }

#line 1065
    if ((double )scaled_value <= - 8. * (double )16) {
#line 1066
      *(dest + count) = 128;
#line 1067
      goto while_continue;
    }
    {
#line 1069
    __cil_tmp8 = lrintf(scaled_value);
#line 1069
    *(dest + count) = (FLAC__int32 )__cil_tmp8;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 1072
  return;
}
}
#line 1076 "/root/libsndfile/src/flac.c"
static void f2flac16_clip_array(float const   *src , FLAC__int32 *dest , int count ,
                                int normalize ) 
{ 
  float normfact ;
  float scaled_value ;
  double tmp ;
  long __cil_tmp8 ;

  {
#line 1080
  if (normalize) {
#line 1080
    tmp = 8. * (double )4096;
  } else {
#line 1080
    tmp = 1.;
  }
#line 1080
  normfact = (float )tmp;
  {
#line 1082
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1082
    count --;
#line 1082
    if (! (count >= 0)) {
#line 1082
      goto while_break;
    }
#line 1083
    scaled_value = *(src + count) * normfact;
#line 1084
    if ((double )scaled_value >= 1. * (double )32767) {
#line 1085
      *(dest + count) = 32767;
#line 1086
      goto while_continue;
    }
#line 1088
    if ((double )scaled_value <= - 8. * (double )4096) {
#line 1089
      *(dest + count) = 32768;
#line 1090
      goto while_continue;
    }
    {
#line 1092
    __cil_tmp8 = lrintf(scaled_value);
#line 1092
    *(dest + count) = (FLAC__int32 )__cil_tmp8;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1097 "/root/libsndfile/src/flac.c"
static void f2flac24_clip_array(float const   *src , FLAC__int32 *dest , int count ,
                                int normalize ) 
{ 
  float normfact ;
  float scaled_value ;
  double tmp ;
  long __cil_tmp8 ;

  {
#line 1100
  if (normalize) {
#line 1100
    tmp = 8. * (double )1048576;
  } else {
#line 1100
    tmp = 1.;
  }
#line 1100
  normfact = (float )tmp;
  {
#line 1102
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1102
    count --;
#line 1102
    if (! (count >= 0)) {
#line 1102
      goto while_break;
    }
#line 1103
    scaled_value = *(src + count) * normfact;
#line 1104
    if ((double )scaled_value >= 1. * (double )8388607) {
#line 1105
      *(dest + count) = 8388607;
#line 1106
      goto while_continue;
    }

#line 1109
    if ((double )scaled_value <= - 8. * (double )1048576) {
#line 1110
      *(dest + count) = 8388608;
#line 1111
      goto while_continue;
    }
    {
#line 1113
    __cil_tmp8 = lrintf(scaled_value);
#line 1113
    *(dest + count) = (FLAC__int32 )__cil_tmp8;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 1116
  return;
}
}
#line 1120 "/root/libsndfile/src/flac.c"
static void f2flac8_array(float const   *src , FLAC__int32 *dest , int count , int normalize ) 
{ 
  float normfact ;
  double tmp ;
  long __cil_tmp7 ;

  {
#line 1121
  if (normalize) {
#line 1121
    tmp = 1. * (double )127;
  } else {
#line 1121
    tmp = 1.;
  }
#line 1121
  normfact = (float )tmp;
  {
#line 1123
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1123
    count --;
#line 1123
    if (! (count >= 0)) {
#line 1123
      goto while_break;
    }
    {
#line 1124
    __cil_tmp7 = lrintf(*(src + count) * normfact);
#line 1124
    *(dest + count) = (FLAC__int32 )__cil_tmp7;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1128 "/root/libsndfile/src/flac.c"
static void f2flac16_array(float const   *src , FLAC__int32 *dest , int count , int normalize ) 
{ 
  float normfact ;
  double tmp ;
  long __cil_tmp7 ;

  {
#line 1129
  if (normalize) {
#line 1129
    tmp = 1. * (double )32767;
  } else {
#line 1129
    tmp = 1.;
  }
#line 1129
  normfact = (float )tmp;
  {
#line 1131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1131
    count --;
#line 1131
    if (! (count >= 0)) {
#line 1131
      goto while_break;
    }
    {
#line 1132
    __cil_tmp7 = lrintf(*(src + count) * normfact);
#line 1132
    *(dest + count) = (FLAC__int32 )__cil_tmp7;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1136 "/root/libsndfile/src/flac.c"
static void f2flac24_array(float const   *src , FLAC__int32 *dest , int count , int normalize ) 
{ 
  float normfact ;
  double tmp ;
  long __cil_tmp7 ;

  {
#line 1137
  if (normalize) {
#line 1137
    tmp = 1. * (double )8388607;
  } else {
#line 1137
    tmp = 1.;
  }
#line 1137
  normfact = (float )tmp;
  {
#line 1139
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1139
    count --;
#line 1139
    if (! (count >= 0)) {
#line 1139
      goto while_break;
    }
    {
#line 1140
    __cil_tmp7 = lrintf(*(src + count) * normfact);
#line 1140
    *(dest + count) = (FLAC__int32 )__cil_tmp7;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1144 "/root/libsndfile/src/flac.c"
static sf_count_t flac_write_d2flac(SF_PRIVATE *psf , double const   *ptr , sf_count_t len ) 
{ 
  FLAC_PRIVATE *pflac ;
  void (*convert)(double const   * , FLAC__int32 * , int  , int  ) ;
  int bufferlen ;
  int writecount ;
  int thiswrite ;
  sf_count_t total ;
  FLAC__int32 *buffer ;
  void (*tmp)(double const   *src , FLAC__int32 *dest , int count , int normalize ) ;
  void (*tmp___0)(double const   *src , FLAC__int32 *dest , int count , int normalize ) ;
  void (*tmp___1)(double const   *src , FLAC__int32 *dest , int count , int normalize ) ;
  int tmp___2 ;
  FLAC__bool __cil_tmp15 ;

  {
#line 1145
  pflac = (FLAC_PRIVATE *)psf->codec_data;
#line 1148
  total = (sf_count_t )0;
#line 1149
  buffer = pflac->encbuffer;
  {
#line 1152
  if ((psf->sf.format & 65535) == 1) {
#line 1152
    goto case_1;
  }
#line 1155
  if ((psf->sf.format & 65535) == 2) {
#line 1155
    goto case_2;
  }
#line 1158
  if ((psf->sf.format & 65535) == 3) {
#line 1158
    goto case_3;
  }
#line 1161
  goto switch_default;
  case_1: /* CIL Label */ 
#line 1153
  if (psf->add_clipping) {
#line 1153
    tmp = & d2flac8_clip_array;
  } else {
#line 1153
    tmp = & d2flac8_array;
  }
#line 1153
  convert = tmp;
#line 1154
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1156
  if (psf->add_clipping) {
#line 1156
    tmp___0 = & d2flac16_clip_array;
  } else {
#line 1156
    tmp___0 = & d2flac16_array;
  }
#line 1156
  convert = tmp___0;
#line 1157
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1159
  if (psf->add_clipping) {
#line 1159
    tmp___1 = & d2flac24_clip_array;
  } else {
#line 1159
    tmp___1 = & d2flac24_array;
  }
#line 1159
  convert = tmp___1;
#line 1160
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1162
  return ((sf_count_t )(- 1));
  switch_break: /* CIL Label */ ;
  }
#line 1165
  bufferlen = (int )(8192UL / (sizeof(FLAC__int32 ) * (unsigned long )psf->sf.channels));
#line 1166
  bufferlen *= psf->sf.channels;
  {
#line 1168
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1168
    if (! (len > 0L)) {
#line 1168
      goto while_break;
    }
#line 1169
    if (len >= (long )bufferlen) {
#line 1169
      tmp___2 = bufferlen;
    } else {
#line 1169
      tmp___2 = (int )len;
    }
    {
#line 1169
    writecount = tmp___2;
#line 1170
    (*convert)(ptr + total, buffer, writecount, psf->norm_double);
#line 1171
    __cil_tmp15 = FLAC__stream_encoder_process_interleaved(pflac->fse, (FLAC__int32 [])buffer,
                                                           (uint32_t )(writecount / psf->sf.channels));
    }
#line 1171
    if (__cil_tmp15) {
#line 1172
      thiswrite = writecount;
    } else {
#line 1174
      goto while_break;
    }
#line 1175
    total += (long )thiswrite;
#line 1176
    if (thiswrite < writecount) {
#line 1177
      goto while_break;
    }
#line 1179
    len -= (long )thiswrite;
  }
  while_break: /* CIL Label */ ;
  }

#line 1182
  return (total);
}
}
#line 1186 "/root/libsndfile/src/flac.c"
static void d2flac8_clip_array(double const   *src , FLAC__int32 *dest , int count ,
                               int normalize ) 
{ 
  double normfact ;
  double scaled_value ;
  double tmp ;
  long __cil_tmp8 ;

  {
#line 1189
  if (normalize) {
#line 1189
    tmp = 8. * (double )16;
  } else {
#line 1189
    tmp = 1.;
  }
#line 1189
  normfact = tmp;
  {
#line 1191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1191
    count --;
#line 1191
    if (! (count >= 0)) {
#line 1191
      goto while_break;
    }
#line 1192
    scaled_value = *(src + count) * normfact;
#line 1193
    if (scaled_value >= 1. * (double )127) {
#line 1194
      *(dest + count) = 127;
#line 1195
      goto while_continue;
    }

#line 1197
    if (scaled_value <= - 8. * (double )16) {
#line 1198
      *(dest + count) = 128;
#line 1199
      goto while_continue;
    }
    {
#line 1201
    __cil_tmp8 = lrint(scaled_value);
#line 1201
    *(dest + count) = (FLAC__int32 )__cil_tmp8;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 1204
  return;
}
}
#line 1208 "/root/libsndfile/src/flac.c"
static void d2flac16_clip_array(double const   *src , FLAC__int32 *dest , int count ,
                                int normalize ) 
{ 
  double normfact ;
  double scaled_value ;
  double tmp ;
  long __cil_tmp8 ;

  {
#line 1211
  if (normalize) {
#line 1211
    tmp = 8. * (double )4096;
  } else {
#line 1211
    tmp = 1.;
  }
#line 1211
  normfact = tmp;
  {
#line 1213
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1213
    count --;
#line 1213
    if (! (count >= 0)) {
#line 1213
      goto while_break;
    }
#line 1214
    scaled_value = *(src + count) * normfact;
#line 1215
    if (scaled_value >= 1. * (double )32767) {
#line 1216
      *(dest + count) = 32767;
#line 1217
      goto while_continue;
    }

#line 1219
    if (scaled_value <= - 8. * (double )4096) {
#line 1220
      *(dest + count) = 32768;
#line 1221
      goto while_continue;
    }
    {
#line 1223
    __cil_tmp8 = lrint(scaled_value);
#line 1223
    *(dest + count) = (FLAC__int32 )__cil_tmp8;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 1226
  return;
}
}
#line 1230 "/root/libsndfile/src/flac.c"
static void d2flac24_clip_array(double const   *src , FLAC__int32 *dest , int count ,
                                int normalize ) 
{ 
  double normfact ;
  double scaled_value ;
  double tmp ;
  long __cil_tmp8 ;

  {
#line 1233
  if (normalize) {
#line 1233
    tmp = 8. * (double )1048576;
  } else {
#line 1233
    tmp = 1.;
  }
#line 1233
  normfact = tmp;
  {
#line 1235
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1235
    count --;
#line 1235
    if (! (count >= 0)) {
#line 1235
      goto while_break;
    }
#line 1236
    scaled_value = *(src + count) * normfact;
#line 1237
    if (scaled_value >= 1. * (double )8388607) {
#line 1238
      *(dest + count) = 8388607;
#line 1239
      goto while_continue;
    }

#line 1241
    if (scaled_value <= - 8. * (double )1048576) {
#line 1242
      *(dest + count) = 8388608;
#line 1243
      goto while_continue;
    }
    {
#line 1245
    __cil_tmp8 = lrint(scaled_value);
#line 1245
    *(dest + count) = (FLAC__int32 )__cil_tmp8;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 1248
  return;
}
}
#line 1252 "/root/libsndfile/src/flac.c"
static void d2flac8_array(double const   *src , FLAC__int32 *dest , int count , int normalize ) 
{ 
  double normfact ;
  double tmp ;
  long __cil_tmp7 ;

  {
#line 1253
  if (normalize) {
#line 1253
    tmp = 1. * (double )127;
  } else {
#line 1253
    tmp = 1.;
  }
#line 1253
  normfact = tmp;
  {
#line 1255
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1255
    count --;
#line 1255
    if (! (count >= 0)) {
#line 1255
      goto while_break;
    }
    {
#line 1256
    __cil_tmp7 = lrint(*(src + count) * normfact);
#line 1256
    *(dest + count) = (FLAC__int32 )__cil_tmp7;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1260 "/root/libsndfile/src/flac.c"
static void d2flac16_array(double const   *src , FLAC__int32 *dest , int count , int normalize ) 
{ 
  double normfact ;
  double tmp ;
  long __cil_tmp7 ;

  {
#line 1261
  if (normalize) {
#line 1261
    tmp = 1. * (double )32767;
  } else {
#line 1261
    tmp = 1.;
  }
#line 1261
  normfact = tmp;
  {
#line 1263
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1263
    count --;
#line 1263
    if (! (count >= 0)) {
#line 1263
      goto while_break;
    }
    {
#line 1264
    __cil_tmp7 = lrint(*(src + count) * normfact);
#line 1264
    *(dest + count) = (FLAC__int32 )__cil_tmp7;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1268 "/root/libsndfile/src/flac.c"
static void d2flac24_array(double const   *src , FLAC__int32 *dest , int count , int normalize ) 
{ 
  double normfact ;
  double tmp ;
  long __cil_tmp7 ;

  {
#line 1269
  if (normalize) {
#line 1269
    tmp = 1. * (double )8388607;
  } else {
#line 1269
    tmp = 1.;
  }
#line 1269
  normfact = tmp;
  {
#line 1271
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1271
    count --;
#line 1271
    if (! (count >= 0)) {
#line 1271
      goto while_break;
    }
    {
#line 1272
    __cil_tmp7 = lrint(*(src + count) * normfact);
#line 1272
    *(dest + count) = (FLAC__int32 )__cil_tmp7;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1276 "/root/libsndfile/src/flac.c"
static sf_count_t flac_seek(SF_PRIVATE *psf , int UNUSED_mode , sf_count_t offset ) 
{ 
  FLAC_PRIVATE *pflac ;
  FLAC__uint64 position ;
  FLAC__bool __cil_tmp6 ;

  {
#line 1277
  pflac = (FLAC_PRIVATE *)psf->codec_data;
#line 1279
  if (pflac == (void *)0) {
#line 1280
    return ((sf_count_t )0);
  }
#line 1282
  if (psf->dataoffset < 0L) {
#line 1283
    psf->error = 38;
#line 1284
    return ((sf_count_t )(- 1));
  }
#line 1287
  pflac->frame = (FLAC__Frame *)((void *)0);
#line 1289
  if (psf->mode == 16) {
    {
#line 1291
    __cil_tmp6 = FLAC__stream_decoder_seek_absolute(pflac->fsd, (FLAC__uint64 )offset);
    }
#line 1291
    if (__cil_tmp6) {
      {
#line 1292
      FLAC__stream_decoder_get_decode_position(pflac->fsd, & position);
      }
#line 1293
      return (offset);
    }

#line 1296
    return ((sf_count_t )(- 1));
  }
#line 1300
  psf->error = 38;
#line 1302
  return ((sf_count_t )(- 1));
}
}
#line 33 "/root/libsndfile/src/dwd.c"
int dwd_open(SF_PRIVATE *psf ) 
{ 


  {
#line 34
  if (psf) {
#line 35
    return (17);
  }
#line 36
  return (0);
}
}
#line 89 "/root/libsndfile/src/caf.c"
static int caf_close(SF_PRIVATE *psf ) ;
#line 90
static int caf_read_header(SF_PRIVATE *psf ) ;
#line 91
static int caf_write_header(SF_PRIVATE *psf , int calc_length ) ;
#line 98 "/root/libsndfile/src/caf.c"
int caf_open(SF_PRIVATE *psf ) 
{ 
  int subformat ;
  int format ;
  int error ;
  int __cil_tmp5 ;
  PEAK_INFO *__cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;

  {
#line 99
  error = 0;
#line 101
  if (psf->mode == 16) {
    _L: /* CIL Label */ 
    {
#line 102
    error = caf_read_header(psf);
    }
#line 102
    if (error) {
#line 103
      return (error);
    }
  } else
#line 101
  if (psf->mode == 48) {
#line 101
    if (psf->filelength > 0L) {
#line 101
      goto _L;
    }
  }
#line 106
  subformat = psf->sf.format & 65535;
#line 108
  if (psf->mode == 32) {
    _L___39: /* CIL Label */ 
#line 109
    if (psf->is_pipe) {
#line 110
      return (28);
    }
#line 112
    format = psf->sf.format & 268369920;
#line 113
    if (format != 1572864) {
#line 114
      return (1);
    }
#line 116
    psf->blockwidth = psf->bytewidth * psf->sf.channels;
#line 118
    if (psf->mode != 48) {
#line 119
      psf->filelength = (sf_count_t )0;
#line 120
      psf->datalength = (sf_count_t )0;
#line 121
      psf->dataoffset = (sf_count_t )0;
#line 122
      psf->sf.frames = (sf_count_t )0;
    } else
#line 118
    if (psf->filelength < 44L) {
#line 119
      psf->filelength = (sf_count_t )0;
#line 120
      psf->datalength = (sf_count_t )0;
#line 121
      psf->dataoffset = (sf_count_t )0;
#line 122
      psf->sf.frames = (sf_count_t )0;
    }
#line 125
    psf->str_flags = 256;
#line 131
    if (psf->mode == 32) {
#line 131
      if (subformat == 6) {
        _L___38: /* CIL Label */ 
        {
#line 132
        psf->peak_info = peak_info_calloc(psf->sf.channels);
        }
#line 132
        if (psf->peak_info == (void *)0) {
#line 133
          return (16);
        }
#line 134
        (psf->peak_info)->peak_loc = 42;
      } else
#line 131
      if (subformat == 7) {
#line 131
        goto _L___38;
      }
    }
    {
#line 137
    error = caf_write_header(psf, 0);
    }
#line 137
    if (error != 0) {
#line 138
      return (error);
    }
#line 140
    psf->write_header = & caf_write_header;
  } else
#line 108
  if (psf->mode == 48) {
#line 108
    goto _L___39;
  }
#line 143
  psf->container_close = & caf_close;
  {
#line 150
  if (subformat == 4) {
#line 150
    goto case_4;
  }
#line 150
  if (subformat == 3) {
#line 150
    goto case_4;
  }
#line 150
  if (subformat == 2) {
#line 150
    goto case_4;
  }
#line 150
  if (subformat == 1) {
#line 150
    goto case_4;
  }
#line 154
  if (subformat == 16) {
#line 154
    goto case_16;
  }
#line 158
  if (subformat == 17) {
#line 158
    goto case_17;
  }
#line 163
  if (subformat == 6) {
#line 163
    goto case_6;
  }
#line 167
  if (subformat == 7) {
#line 167
    goto case_7;
  }
#line 172
  goto switch_default;
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 151
  error = pcm_init(psf);
  }
#line 152
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 155
  error = ulaw_init(psf);
  }
#line 156
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 159
  error = alaw_init(psf);
  }
#line 160
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 164
  error = float32_init(psf);
  }
#line 165
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 168
  error = double64_init(psf);
  }
#line 169
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 173
  return (4);
  switch_break: /* CIL Label */ ;
  }

#line 176
  return (error);
}
}
#line 180 "/root/libsndfile/src/caf.c"
static int caf_close(SF_PRIVATE *psf ) 
{ 


  {
#line 182
  if (psf->mode == 32) {
    {
    {
#line 183
    caf_write_header(psf, 1);
    }
    }
  } else
#line 182
  if (psf->mode == 48) {
    {
    {
#line 183
    caf_write_header(psf, 1);
    }
    }
  }
#line 185
  return (0);
}
}
#line 192 "/root/libsndfile/src/caf.c"
static int decode_desc_chunk(SF_PRIVATE *psf , DESC_CHUNK *desc ) 
{ 
  int format ;
  int tmp ;

  {
#line 195
  psf->sf.channels = (int )desc->channels_per_frame;
#line 197
  if (psf->endian == 268435456) {
#line 197
    tmp = 268435456;
  } else {
#line 197
    tmp = 0;
  }
#line 197
  format = 1572864 | tmp;
#line 199
  if (desc->fmt_id == (unsigned int )(((108 | (112 << 8)) | (99 << 16)) | (109 << 24))) {
#line 199
    if (desc->fmt_flags & 1U) {
#line 201
      if (desc->bits_per_chan == 32U) {
#line 201
        if (desc->pkt_bytes == 4U * desc->channels_per_frame) {
#line 202
          psf->bytewidth = 4;
#line 203
          return (format | 6);
        }
      }

#line 205
      if (desc->bits_per_chan == 64U) {
#line 205
        if (desc->pkt_bytes == 8U * desc->channels_per_frame) {
#line 206
          psf->bytewidth = 8;
#line 207
          return (format | 7);
        }
      }

    }
  }

#line 211
  if ((desc->fmt_flags & 1U) != 0U) {
    {
#line 212
    psf_log_printf(psf, "**** Ooops, \'desc\' chunk suggests float data, but other info invalid.\n");
    }
#line 213
    return (0);
  }

#line 216
  if (desc->fmt_id == (unsigned int )(((108 | (112 << 8)) | (99 << 16)) | (109 << 24))) {
#line 218
    if (desc->bits_per_chan == 32U) {
#line 218
      if (desc->pkt_bytes == 4U * desc->channels_per_frame) {
#line 219
        psf->bytewidth = 4;
#line 220
        return (format | 4);
      }
    }

#line 222
    if (desc->bits_per_chan == 24U) {
#line 222
      if (desc->pkt_bytes == 3U * desc->channels_per_frame) {
#line 223
        psf->bytewidth = 3;
#line 224
        return (format | 3);
      }
    }

#line 226
    if (desc->bits_per_chan == 16U) {
#line 226
      if (desc->pkt_bytes == 2U * desc->channels_per_frame) {
#line 227
        psf->bytewidth = 2;
#line 228
        return (format | 2);
      }
    }

#line 230
    if (desc->bits_per_chan == 8U) {
#line 230
      if (desc->pkt_bytes == desc->channels_per_frame) {
#line 231
        psf->bytewidth = 1;
#line 232
        return (format | 1);
      }
    }

  }

#line 236
  if (desc->fmt_id == (unsigned int )(((97 | (108 << 8)) | (97 << 16)) | (119 << 24))) {
#line 236
    if (desc->bits_per_chan == 8U) {
#line 237
      psf->bytewidth = 1;
#line 238
      return (format | 17);
    }
  }

#line 241
  if (desc->fmt_id == (unsigned int )(((117 | (108 << 8)) | (97 << 16)) | (119 << 24))) {
#line 241
    if (desc->bits_per_chan == 8U) {
#line 242
      psf->bytewidth = 1;
#line 243
      return (format | 16);
    }
  }

#line 246
  return (0);
}
}
#line 250 "/root/libsndfile/src/caf.c"
static int caf_read_header(SF_PRIVATE *psf ) 
{ 
  DESC_CHUNK desc ;
  sf_count_t chunk_size ;
  double srate ;
  short version ;
  short flags ;
  int marker ;
  int k ;
  int have_data ;
  double __cil_tmp10 ;
  long __cil_tmp11 ;
  sf_count_t __cil_tmp12 ;
  PEAK_INFO *__cil_tmp13 ;
  sf_count_t position ;
  float value ;
  int __cil_tmp16 ;
  sf_count_t __cil_tmp17 ;
  int tmp ;
  int __cil_tmp19 ;

  {
  {
#line 255
  have_data = 0;
#line 257
  memset(& desc, 0, sizeof(desc));
#line 260
  psf_binheader_readf(psf, "pmE2E2", 0, & marker, & version, & flags);
#line 261
  psf_log_printf(psf, "%M\n  Version : %d\n  Flags   : %x\n", marker, (int )version,
                 (int )flags);
  }
#line 262
  if (marker != (((99 | (97 << 8)) | (102 << 16)) | (102 << 24))) {
#line 263
    return (666);
  }
  {
#line 265
  psf_binheader_readf(psf, "mE8b\036V", & marker, & chunk_size, (unsigned char *)psf->u.ucbuf,
                      8);
#line 266
  srate = double64_be_read((unsigned char *)psf->u.ucbuf);
#line 267
  snprintf((char *)psf->u.cbuf, sizeof(psf->u.cbuf), "%5.3fV", srate);
#line 268
  psf_log_printf(psf, "%M : %D\n  Sample rate  : %s\n\036V", marker, chunk_size, (char *)psf->u.cbuf);
  }
#line 269
  if (marker != (((100 | (101 << 8)) | (115 << 16)) | (99 << 24))) {
#line 270
    return (667);
  }
#line 272
  if (chunk_size < (long )((int )sizeof(DESC_CHUNK ))) {
    {
#line 273
    psf_log_printf(psf, "**** Chunk size too small. Should be > 32 bytes.\nV\215\375\036V");
    }
#line 274
    return (3);
  }
  {
#line 277
  __cil_tmp11 = lrint(srate);
#line 277
  psf->sf.samplerate = (int )__cil_tmp11;
#line 279
  psf_binheader_readf(psf, "mE44444", & desc.fmt_id, & desc.fmt_flags, & desc.pkt_bytes,
                      & desc.pkt_frames, & desc.channels_per_frame, & desc.bits_per_chan);
#line 281
  psf_log_printf(psf, "  Format id    : %M\n  Format flags : %x\n  Bytes / packet   : %u\n  Frames / packet  : %u\n  Channels / frame : %u\n  Bits / channel   : %u\n\036V",
                 desc.fmt_id, desc.fmt_flags, desc.pkt_bytes, desc.pkt_frames, desc.channels_per_frame,
                 desc.bits_per_chan);
  }
#line 285
  if (desc.channels_per_frame > 256U) {
    {
#line 286
    psf_log_printf(psf, "**** Bad channels per frame value %u.\n", desc.channels_per_frame);
    }
#line 287
    return (3);
  }

#line 290
  if (chunk_size > (long )((int )sizeof(DESC_CHUNK ))) {
    {
#line 291
    psf_binheader_readf(psf, "jd\215\375\036V", (int )((unsigned long )chunk_size - sizeof(DESC_CHUNK )));
    }
  }
#line 293
  psf->sf.channels = (int )desc.channels_per_frame;
  {
#line 295
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 295
    __cil_tmp12 = psf_ftell(psf);
    }
#line 295
    if (! (have_data == 0 && __cil_tmp12 < psf->filelength - (long )((int )sizeof(marker)))) {
#line 295
      goto while_break;
    }
    {
#line 296
    psf_binheader_readf(psf, "mE8\375\036V", & marker, & chunk_size);
    }
    {
#line 299
    if (marker == (((112 | (101 << 8)) | (97 << 16)) | (107 << 24))) {
#line 299
      goto case_exp;
    }
#line 330
    if (marker == (((102 | (114 << 8)) | (101 << 16)) | (101 << 24))) {
#line 330
      goto case_exp___0;
    }
#line 335
    if (marker == (((100 | (97 << 8)) | (116 << 16)) | (97 << 24))) {
#line 335
      goto case_exp___1;
    }
#line 342
    goto switch_default;
    case_exp: /* CIL Label */ 
    {
#line 300
    psf_log_printf(psf, "%M : %D\n\230\001", marker, chunk_size);
    }
#line 301
    if (chunk_size != (long )((int )(sizeof(int ) + (unsigned long )psf->sf.channels * (sizeof(float ) + 8UL)))) {
      {
#line 302
      psf_binheader_readf(psf, "j\017\215\375\036V", (int )chunk_size);
#line 303
      psf_log_printf(psf, "*** File PEAK chunk %D should be %d.\n", chunk_size, (int )(sizeof(int ) + (unsigned long )psf->sf.channels * (sizeof(float ) + 8UL)));
      }
#line 304
      return (668);
    }
    {
#line 307
    psf->peak_info = peak_info_calloc(psf->sf.channels);
    }
#line 307
    if (psf->peak_info == (void *)0) {
#line 308
      return (16);
    }
    {
#line 311
    psf_binheader_readf(psf, "E4\215\375\036V", & (psf->peak_info)->edit_number);
#line 312
    psf_log_printf(psf, "  edit count : %d\n", (psf->peak_info)->edit_number);
#line 314
    psf_log_printf(psf, "     Ch   Position      Value\n");
#line 315
    k = 0;
    }
    {
#line 315
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 315
      if (! (k < psf->sf.channels)) {
#line 315
        goto while_break___0;
      }
      {
#line 319
      psf_binheader_readf(psf, "Ef8\375\036V", & value, & position);
#line 320
      (psf->peak_info)->peaks[k].value = (double )value;
#line 321
      (psf->peak_info)->peaks[k].position = position;
#line 323
      snprintf((char *)psf->u.cbuf, sizeof(psf->u.cbuf), "    %2d   %-12ld   %g\n",
               k, (long )position, (double )value);
#line 324
      psf_log_printf(psf, (char const   *)((char *)psf->u.cbuf));
      }
#line 315
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 327
    (psf->peak_info)->peak_loc = 42;
#line 328
    goto switch_break;
    case_exp___0: /* CIL Label */ 
    {
#line 331
    psf_log_printf(psf, "%M : %D\n\230\001", marker, chunk_size);
    }
    {
#line 332
    psf_binheader_readf(psf, "j", (int )chunk_size);
    }
#line 333
    goto switch_break;
    case_exp___1: /* CIL Label */ 
    {
#line 336
    psf_log_printf(psf, "%M : %D\n\230\001", marker, chunk_size);
    }
    {
#line 337
    psf_binheader_readf(psf, "E4", & k);
#line 338
    psf_log_printf(psf, "  edit : %u\n", k);
#line 339
    have_data = 1;
    }
#line 340
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 343
    psf_log_printf(psf, " %M : %D (skipped)\n", marker, chunk_size);
    }
    {
#line 344
    psf_binheader_readf(psf, "j", (int )chunk_size);
    }
#line 345
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }

  }
  while_break: /* CIL Label */ ;
  }

#line 349
  if (have_data == 0) {
    {
#line 350
    psf_log_printf(psf, "**** Error, could not find \'data\' chunk.\n");
    }
#line 351
    return (3);
  }
  {
#line 354
  psf_log_printf(psf, "End\n");
#line 356
  psf->dataoffset = psf_ftell(psf);
#line 357
  psf->datalength = psf->filelength - psf->dataoffset;
  }
#line 358
  if (desc.fmt_flags & 2U) {
#line 358
    tmp = 268435456;
  } else {
#line 358
    tmp = 536870912;
  }
  {
#line 358
  psf->endian = tmp;
#line 360
  psf->sf.format = decode_desc_chunk(psf, & desc);
  }
#line 360
  if (psf->sf.format == 0) {
#line 361
    return (4);
  }
#line 363
  if (psf->bytewidth > 0) {
#line 364
    psf->sf.frames = psf->datalength / (long )psf->bytewidth;
  }
#line 366
  return (0);
}
}
#line 373 "/root/libsndfile/src/caf.c"
static int caf_write_header(SF_PRIVATE *psf , int calc_length ) 
{ 
  DESC_CHUNK desc ;
  sf_count_t current ;
  sf_count_t free_len ;
  int subformat ;
  sf_count_t __cil_tmp7 ;
  sf_count_t __cil_tmp8 ;
  size_t __cil_tmp9 ;
  int k ;
  int __cil_tmp11 ;

  {
  {
#line 378
  memset(& desc, 0, sizeof(desc));
#line 380
  current = psf_ftell(psf);
  }
#line 382
  if (calc_length) {
    {
#line 383
    psf->filelength = psf_get_filelen(psf);
#line 385
    psf->datalength = psf->filelength - psf->dataoffset;
    }
#line 387
    if (psf->dataend) {
#line 388
      psf->datalength -= psf->filelength - psf->dataend;
    }
#line 390
    if (psf->bytewidth > 0) {
#line 391
      psf->sf.frames = psf->datalength / (long )(psf->bytewidth * psf->sf.channels);
    }
  }
  {
#line 395
  psf->header[0] = (unsigned char )0;
#line 396
  psf->headindex = 0;
#line 397
  psf_fseek(psf, (sf_count_t )0, 0);
#line 400
  psf_binheader_writef(psf, "Em22\036V", ((99 | (97 << 8)) | (102 << 16)) | (102 << 24),
                       1, 0);
#line 403
  psf_binheader_writef(psf, "Em8", ((100 | (101 << 8)) | (115 << 16)) | (99 << 24),
                       (sf_count_t )sizeof(DESC_CHUNK ));
#line 405
  double64_be_write(1. * (double )psf->sf.samplerate, (unsigned char *)psf->u.ucbuf);
#line 406
  __cil_tmp9 = make_size_t(8);
#line 406
  psf_binheader_writef(psf, "b\313\215\375\036V", (unsigned char *)psf->u.ucbuf, __cil_tmp9);
#line 408
  subformat = psf->sf.format & 65535;
#line 410
  psf->endian = psf->sf.format & 805306368;
  }
#line 412
  if (0) {
#line 413
    psf->endian = 536870912;
  } else
#line 414
  if (psf->endian == 268435456) {
#line 415
    psf->endian = 268435456;
  } else
#line 414
  if (psf->endian == 805306368) {
#line 415
    psf->endian = 268435456;
  }
#line 417
  if (psf->endian == 268435456) {
#line 418
    desc.fmt_flags = (unsigned int )2;
  } else {
#line 420
    psf->endian = 536870912;
  }
  {
#line 424
  if (subformat == 1) {
#line 424
    goto case_1;
  }
#line 433
  if (subformat == 2) {
#line 433
    goto case_2;
  }
#line 442
  if (subformat == 3) {
#line 442
    goto case_3;
  }
#line 451
  if (subformat == 4) {
#line 451
    goto case_4;
  }
#line 460
  if (subformat == 6) {
#line 460
    goto case_6;
  }
#line 470
  if (subformat == 7) {
#line 470
    goto case_7;
  }
#line 480
  if (subformat == 17) {
#line 480
    goto case_17;
  }
#line 489
  if (subformat == 16) {
#line 489
    goto case_16;
  }
#line 498
  goto switch_default;
  case_1: /* CIL Label */ 
#line 425
  desc.fmt_id = (unsigned int )(((108 | (112 << 8)) | (99 << 16)) | (109 << 24));
#line 426
  psf->bytewidth = 1;
#line 427
  desc.pkt_bytes = (unsigned int )(psf->bytewidth * psf->sf.channels);
#line 428
  desc.pkt_frames = (unsigned int )1;
#line 429
  desc.channels_per_frame = (unsigned int )psf->sf.channels;
#line 430
  desc.bits_per_chan = (unsigned int )8;
#line 431
  goto switch_break;
  case_2: /* CIL Label */ 
#line 434
  desc.fmt_id = (unsigned int )(((108 | (112 << 8)) | (99 << 16)) | (109 << 24));
#line 435
  psf->bytewidth = 2;
#line 436
  desc.pkt_bytes = (unsigned int )(psf->bytewidth * psf->sf.channels);
#line 437
  desc.pkt_frames = (unsigned int )1;
#line 438
  desc.channels_per_frame = (unsigned int )psf->sf.channels;
#line 439
  desc.bits_per_chan = (unsigned int )16;
#line 440
  goto switch_break;
  case_3: /* CIL Label */ 
#line 443
  psf->bytewidth = 3;
#line 444
  desc.pkt_bytes = (unsigned int )(psf->bytewidth * psf->sf.channels);
#line 445
  desc.pkt_frames = (unsigned int )1;
#line 446
  desc.channels_per_frame = (unsigned int )psf->sf.channels;
#line 447
  desc.bits_per_chan = (unsigned int )24;
#line 448
  desc.fmt_id = (unsigned int )(((108 | (112 << 8)) | (99 << 16)) | (109 << 24));
#line 449
  goto switch_break;
  case_4: /* CIL Label */ 
#line 452
  desc.fmt_id = (unsigned int )(((108 | (112 << 8)) | (99 << 16)) | (109 << 24));
#line 453
  psf->bytewidth = 4;
#line 454
  desc.pkt_bytes = (unsigned int )(psf->bytewidth * psf->sf.channels);
#line 455
  desc.pkt_frames = (unsigned int )1;
#line 456
  desc.channels_per_frame = (unsigned int )psf->sf.channels;
#line 457
  desc.bits_per_chan = (unsigned int )32;
#line 458
  goto switch_break;
  case_6: /* CIL Label */ 
#line 461
  desc.fmt_id = (unsigned int )(((108 | (112 << 8)) | (99 << 16)) | (109 << 24));
#line 462
  desc.fmt_flags |= (unsigned int )1;
#line 463
  psf->bytewidth = 4;
#line 464
  desc.pkt_bytes = (unsigned int )(psf->bytewidth * psf->sf.channels);
#line 465
  desc.pkt_frames = (unsigned int )1;
#line 466
  desc.channels_per_frame = (unsigned int )psf->sf.channels;
#line 467
  desc.bits_per_chan = (unsigned int )32;
#line 468
  goto switch_break;
  case_7: /* CIL Label */ 
#line 471
  desc.fmt_id = (unsigned int )(((108 | (112 << 8)) | (99 << 16)) | (109 << 24));
#line 472
  desc.fmt_flags |= (unsigned int )1;
#line 473
  psf->bytewidth = 8;
#line 474
  desc.pkt_bytes = (unsigned int )(psf->bytewidth * psf->sf.channels);
#line 475
  desc.pkt_frames = (unsigned int )1;
#line 476
  desc.channels_per_frame = (unsigned int )psf->sf.channels;
#line 477
  desc.bits_per_chan = (unsigned int )64;
#line 478
  goto switch_break;
  case_17: /* CIL Label */ 
#line 481
  desc.fmt_id = (unsigned int )(((97 | (108 << 8)) | (97 << 16)) | (119 << 24));
#line 482
  psf->bytewidth = 1;
#line 483
  desc.pkt_bytes = (unsigned int )(psf->bytewidth * psf->sf.channels);
#line 484
  desc.pkt_frames = (unsigned int )1;
#line 485
  desc.channels_per_frame = (unsigned int )psf->sf.channels;
#line 486
  desc.bits_per_chan = (unsigned int )8;
#line 487
  goto switch_break;
  case_16: /* CIL Label */ 
#line 490
  desc.fmt_id = (unsigned int )(((117 | (108 << 8)) | (97 << 16)) | (119 << 24));
#line 491
  psf->bytewidth = 1;
#line 492
  desc.pkt_bytes = (unsigned int )(psf->bytewidth * psf->sf.channels);
#line 493
  desc.pkt_frames = (unsigned int )1;
#line 494
  desc.channels_per_frame = (unsigned int )psf->sf.channels;
#line 495
  desc.bits_per_chan = (unsigned int )8;
#line 496
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 499
  return (17);
  switch_break: /* CIL Label */ ;
  }
  {
#line 502
  psf_binheader_writef(psf, "mE44444", desc.fmt_id, desc.fmt_flags, desc.pkt_bytes,
                       desc.pkt_frames, desc.channels_per_frame, desc.bits_per_chan);
  }
#line 509
  if (psf->peak_info != (void *)0) {
    {
#line 511
    psf_binheader_writef(psf, "Em84", ((112 | (101 << 8)) | (97 << 16)) | (107 << 24),
                         (sf_count_t )((int )(sizeof(int ) + (unsigned long )psf->sf.channels * (sizeof(float ) + 8UL))),
                         (psf->peak_info)->edit_number);
#line 512
    k = 0;
    }
    {
#line 512
    while (1) {
      while_continue: /* CIL Label */ ;
#line 512
      if (! (k < psf->sf.channels)) {
#line 512
        goto while_break;
      }
      {
#line 513
      psf_binheader_writef(psf, "Ef8", (double )((float )(psf->peak_info)->peaks[k].value),
                           (psf->peak_info)->peaks[k].position);
      }
#line 512
      k ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 517
  free_len = (sf_count_t )(((4096 - psf->headindex) - 16) - 12);
  {
#line 518
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 518
    if (! (free_len < 0L)) {
#line 518
      goto while_break___0;
    }
#line 519
    free_len += (long )4096;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 520
  psf_binheader_writef(psf, "Em8z", ((102 | (114 << 8)) | (101 << 16)) | (101 << 24),
                       free_len, (int )free_len);
#line 522
  psf_binheader_writef(psf, "Em84", ((100 | (97 << 8)) | (116 << 16)) | (97 << 24),
                       psf->datalength, 0);
#line 524
  psf_fwrite((unsigned char *)psf->header, (sf_count_t )psf->headindex, (sf_count_t )1,
             psf);
  }
#line 525
  if (psf->error) {
#line 526
    return (psf->error);
  }
#line 528
  psf->dataoffset = (sf_count_t )psf->headindex;
#line 529
  if (current < psf->dataoffset) {
    {
#line 530
    psf_fseek(psf, psf->dataoffset, 0);
    }
  } else
#line 531
  if (current > 0L) {
    {
#line 532
    psf_fseek(psf, current, 0);
    }
  }
#line 534
  return (psf->error);
}
}
#line 70 "/root/libsndfile/src/avr.c"
static int avr_close(SF_PRIVATE *psf ) ;
#line 72
static int avr_read_header(SF_PRIVATE *psf ) ;
#line 73
static int avr_write_header(SF_PRIVATE *psf , int calc_length ) ;
#line 80 "/root/libsndfile/src/avr.c"
int avr_open(SF_PRIVATE *psf ) 
{ 
  int error ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
#line 81
  error = 0;
#line 83
  if (psf->mode == 16) {
    _L: /* CIL Label */ 
    {
#line 84
    error = avr_read_header(psf);
    }
#line 84
    if (error) {
#line 85
      return (error);
    }
  } else
#line 83
  if (psf->mode == 48) {
#line 83
    if (psf->filelength > 0L) {
#line 83
      goto _L;
    }
  }

#line 88
  if ((psf->sf.format & 268369920) != 1179648) {
#line 89
    return (1);
  }
#line 91
  if (psf->mode == 32) {
    _L___40: /* CIL Label */ 
    {
#line 92
    psf->endian = psf->sf.format & 805306368;
#line 93
    psf->endian = 536870912;
#line 95
    __cil_tmp4 = avr_write_header(psf, 0);
    }
#line 95
    if (__cil_tmp4) {
#line 96
      return (psf->error);
    }
#line 98
    psf->write_header = & avr_write_header;
  } else
#line 91
  if (psf->mode == 48) {
#line 91
    goto _L___40;
  }
  {
#line 101
  psf->container_close = & avr_close;
#line 103
  psf->blockwidth = psf->bytewidth * psf->sf.channels;
#line 105
  error = pcm_init(psf);
  }
#line 107
  return (error);
}
}
#line 111 "/root/libsndfile/src/avr.c"
static int avr_read_header(SF_PRIVATE *psf ) 
{ 
  AVR_HEADER hdr ;
  char const   *tmp ;
  sf_count_t __cil_tmp4 ;
  sf_count_t __cil_tmp5 ;

  {
  {
#line 114
  memset(& hdr, 0, sizeof(hdr));
#line 116
  psf_binheader_readf(psf, "pmb", 0, & hdr.marker, & hdr.name, sizeof(hdr.name));
#line 117
  psf_log_printf(psf, "%M\n", hdr.marker);
  }
#line 119
  if (hdr.marker != (((50 | (66 << 8)) | (73 << 16)) | (84 << 24))) {
#line 120
    return (666);
  }
  {
#line 122
  psf_log_printf(psf, "  Name        : %s\n", (char *)hdr.name);
#line 124
  psf_binheader_readf(psf, "E22222", & hdr.mono, & hdr.rez, & hdr.sign, & hdr.loop,
                      & hdr.midi);
#line 126
  psf->sf.channels = ((int )hdr.mono & 1) + 1;
  }
#line 128
  if ((int )hdr.sign) {
#line 128
    tmp = "yes";
  } else {
#line 128
    tmp = "no\246\375\036V";
  }
  {
#line 128
  psf_log_printf(psf, "  Channels    : %d\n  Bit width   : %d\n  Signed      : %s\n",
                 ((int )hdr.mono & 1) + 1, (int )hdr.rez, tmp);
  }
  {
#line 132
  if (((int )hdr.rez << 16) + ((int )hdr.sign & 1) == 8 << 16) {
#line 132
    goto case_exp;
  }
#line 137
  if (((int )hdr.rez << 16) + ((int )hdr.sign & 1) == (8 << 16) + 1) {
#line 137
    goto case_exp___0;
  }
#line 142
  if (((int )hdr.rez << 16) + ((int )hdr.sign & 1) == (16 << 16) + 1) {
#line 142
    goto case_exp___1;
  }
#line 147
  goto switch_default;
  case_exp: /* CIL Label */ 
#line 133
  psf->sf.format = 1179653;
#line 134
  psf->bytewidth = 1;
#line 135
  goto switch_break;
  case_exp___0: /* CIL Label */ 
#line 138
  psf->sf.format = 1179649;
#line 139
  psf->bytewidth = 1;
#line 140
  goto switch_break;
  case_exp___1: /* CIL Label */ 
#line 143
  psf->sf.format = 1179650;
#line 144
  psf->bytewidth = 2;
#line 145
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 148
  psf_log_printf(psf, "Error : bad rez/sign combination.\n\246\375\036V");
  }
#line 149
  return (666);
  switch_break: /* CIL Label */ ;
  }
  {
#line 152
  psf_binheader_readf(psf, "E4444", & hdr.srate, & hdr.frames, & hdr.lbeg, & hdr.lend);
#line 154
  psf->sf.frames = (sf_count_t )hdr.frames;
#line 155
  psf->sf.samplerate = hdr.srate;
#line 157
  psf_log_printf(psf, "  Frames      : %D\n\375\036V", psf->sf.frames);
#line 158
  psf_log_printf(psf, "  Sample rate : %d\n\375\036V", psf->sf.samplerate);
#line 160
  psf_binheader_readf(psf, "E222\036V", & hdr.res1, & hdr.res2, & hdr.res3);
#line 161
  psf_binheader_readf(psf, "bb\245\375\036V", (char *)hdr.ext, sizeof(hdr.ext), (char *)hdr.user,
                      sizeof(hdr.user));
#line 163
  psf_log_printf(psf, "  Ext         : %s\n  User        : %s\n", (char *)hdr.ext,
                 (char *)hdr.user);
#line 165
  psf->endian = 536870912;
#line 167
  psf->dataoffset = (sf_count_t )128;
#line 168
  psf->datalength = (sf_count_t )(hdr.frames * ((int )hdr.rez / 8));
  }
#line 170
  if (psf->fileoffset > 0L) {
#line 171
    psf->filelength = 128L + psf->datalength;
  }
  {
#line 173
  __cil_tmp4 = psf_ftell(psf);
  }
#line 173
  if (__cil_tmp4 != psf->dataoffset) {
    {
#line 174
    __cil_tmp5 = psf_ftell(psf);
#line 174
    psf_binheader_readf(psf, "j", psf->dataoffset - __cil_tmp5);
    }
  }
#line 176
  psf->blockwidth = psf->sf.channels * psf->bytewidth;
#line 178
  if (psf->sf.frames == 0L) {
#line 178
    if (psf->blockwidth) {
#line 179
      psf->sf.frames = (psf->filelength - psf->dataoffset) / (long )psf->blockwidth;
    }
  }
#line 181
  return (0);
}
}
#line 185 "/root/libsndfile/src/avr.c"
static int avr_write_header(SF_PRIVATE *psf , int calc_length ) 
{ 
  sf_count_t current ;
  int sign ;
  sf_count_t __cil_tmp5 ;
  sf_count_t __cil_tmp6 ;
  size_t __cil_tmp7 ;
  int tmp ;
  int tmp___0 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;

  {
#line 189
  if (psf->pipeoffset > 0L) {
#line 190
    return (0);
  }
  {
#line 192
  current = psf_ftell(psf);
  }
#line 194
  if (calc_length) {
    {
#line 195
    psf->filelength = psf_get_filelen(psf);
#line 197
    psf->datalength = psf->filelength - psf->dataoffset;
    }
#line 198
    if (psf->dataend) {
#line 199
      psf->datalength -= psf->filelength - psf->dataend;
    }
#line 201
    psf->sf.frames = psf->datalength / (long )(psf->bytewidth * psf->sf.channels);
  }
#line 205
  psf->header[0] = (unsigned char )0;
#line 206
  psf->headindex = 0;
#line 212
  if (psf->is_pipe == 0) {
    {
#line 213
    psf_fseek(psf, (sf_count_t )0, 0);
    }
  }
  {
#line 215
  __cil_tmp7 = make_size_t(8);
  }
#line 215
  if (psf->sf.channels == 2) {
#line 215
    tmp = 65535;
  } else {
#line 215
    tmp = 0;
  }
  {
#line 215
  psf_binheader_writef(psf, "Emz22V", ((50 | (66 << 8)) | (73 << 16)) | (84 << 24),
                       __cil_tmp7, tmp, psf->bytewidth * 8);
  }
#line 218
  if ((psf->sf.format & 65535) == 5) {
#line 218
    tmp___0 = 0;
  } else {
#line 218
    tmp___0 = 65535;
  }
  {
#line 218
  sign = tmp___0;
#line 220
  psf_binheader_writef(psf, "E222", sign, 0, 65535);
#line 221
  psf_binheader_writef(psf, "E4444V", psf->sf.samplerate, psf->sf.frames, 0, 0);
#line 223
  __cil_tmp10 = make_size_t(20);
  }
  {
#line 223
  __cil_tmp11 = make_size_t(64);
#line 223
  psf_binheader_writef(psf, "E222zz", 0, 0, 0, __cil_tmp10, __cil_tmp11);
#line 226
  psf_fwrite((unsigned char *)psf->header, (sf_count_t )psf->headindex, (sf_count_t )1,
             psf);
  }
#line 228
  if (psf->error) {
#line 229
    return (psf->error);
  }
#line 231
  psf->dataoffset = (sf_count_t )psf->headindex;
#line 233
  if (current > 0L) {
    {
#line 234
    psf_fseek(psf, current, 0);
    }
  }
#line 236
  return (psf->error);
}
}
#line 240 "/root/libsndfile/src/avr.c"
static int avr_close(SF_PRIVATE *psf ) 
{ 


  {
#line 242
  if (psf->mode == 32) {
    {
    {
#line 243
    avr_write_header(psf, 1);
    }
    }
  } else
#line 242
  if (psf->mode == 48) {
    {
    {
#line 243
    avr_write_header(psf, 1);
    }
    }
  }
#line 245
  return (0);
}
}
#line 93 "/root/libsndfile/src/au.c"
static int au_close(SF_PRIVATE *psf ) ;
#line 95
static int au_format_to_encoding(int format ) ;
#line 97
static int au_write_header(SF_PRIVATE *psf , int calc_length ) ;
#line 98
static int au_read_header(SF_PRIVATE *psf ) ;
#line 105 "/root/libsndfile/src/au.c"
int au_open(SF_PRIVATE *psf ) 
{ 
  int subformat ;
  int error ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;

  {
#line 107
  error = 0;
#line 109
  if (psf->mode == 16) {
    _L: /* CIL Label */ 
    {
#line 110
    error = au_read_header(psf);
    }
#line 110
    if (error) {
#line 111
      return (error);
    }
  } else
#line 109
  if (psf->mode == 48) {
#line 109
    if (psf->filelength > 0L) {
#line 109
      goto _L;
    }
  }

#line 114
  if ((psf->sf.format & 268369920) != 196608) {
#line 115
    return (1);
  }
#line 117
  subformat = psf->sf.format & 65535;
#line 119
  if (psf->mode == 32) {
    _L___41: /* CIL Label */ 
#line 120
    psf->endian = psf->sf.format & 805306368;
#line 121
    if (psf->endian == 805306368) {
#line 122
      psf->endian = 268435456;
    } else
#line 123
    if (psf->endian != 268435456) {
#line 124
      psf->endian = 536870912;
    }
    {
#line 126
    __cil_tmp5 = au_write_header(psf, 0);
    }
#line 126
    if (__cil_tmp5) {
#line 127
      return (psf->error);
    }
#line 129
    psf->write_header = & au_write_header;
  } else
#line 119
  if (psf->mode == 48) {
#line 119
    goto _L___41;
  }
#line 132
  psf->container_close = & au_close;
#line 134
  psf->blockwidth = psf->bytewidth * psf->sf.channels;
  {
#line 137
  if (subformat == 16) {
#line 137
    goto case_16;
  }
#line 141
  if (subformat == 1) {
#line 141
    goto case_1;
  }
#line 147
  if (subformat == 4) {
#line 147
    goto case_4;
  }
#line 147
  if (subformat == 3) {
#line 147
    goto case_4;
  }
#line 147
  if (subformat == 2) {
#line 147
    goto case_4;
  }
#line 151
  if (subformat == 17) {
#line 151
    goto case_17;
  }
#line 156
  if (subformat == 6) {
#line 156
    goto case_6;
  }
#line 160
  if (subformat == 7) {
#line 160
    goto case_7;
  }
#line 164
  if (subformat == 48) {
#line 164
    goto case_48;
  }
#line 169
  if (subformat == 49) {
#line 169
    goto case_49;
  }
#line 174
  if (subformat == 50) {
#line 174
    goto case_50;
  }
#line 180
  goto switch_default;
  case_16: /* CIL Label */ 
  {
#line 138
  ulaw_init(psf);
  }
#line 139
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 142
  error = pcm_init(psf);
  }
#line 143
  goto switch_break;
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 148
  error = pcm_init(psf);
  }
#line 149
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 152
  alaw_init(psf);
  }
#line 153
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 157
  error = float32_init(psf);
  }
#line 158
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 161
  error = double64_init(psf);
  }
#line 162
  goto switch_break;
  case_48: /* CIL Label */ 
  {
#line 165
  error = g72x_init(psf);
  }
#line 166
  psf->sf.seekable = 0;
#line 167
  goto switch_break;
  case_49: /* CIL Label */ 
  {
#line 170
  error = g72x_init(psf);
  }
#line 171
  psf->sf.seekable = 0;
#line 172
  goto switch_break;
  case_50: /* CIL Label */ 
  {
#line 175
  error = g72x_init(psf);
  }
#line 176
  psf->sf.seekable = 0;
#line 177
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 180
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }

#line 183
  return (error);
}
}
#line 190 "/root/libsndfile/src/au.c"
static int au_close(SF_PRIVATE *psf ) 
{ 


  {
#line 192
  if (psf->mode == 32) {
    {
    {
#line 193
    au_write_header(psf, 1);
    }
    }
  } else
#line 192
  if (psf->mode == 48) {
    {
    {
#line 193
    au_write_header(psf, 1);
    }
    }
  }
#line 195
  return (0);
}
}
#line 199 "/root/libsndfile/src/au.c"
static int au_write_header(SF_PRIVATE *psf , int calc_length ) 
{ 
  sf_count_t current ;
  int encoding ;
  int datalength ;
  sf_count_t __cil_tmp6 ;
  sf_count_t __cil_tmp7 ;
  int __cil_tmp8 ;

  {
#line 203
  if (psf->pipeoffset > 0L) {
#line 204
    return (0);
  }
  {
#line 206
  current = psf_ftell(psf);
  }
#line 208
  if (calc_length) {
    {
#line 209
    psf->filelength = psf_get_filelen(psf);
#line 211
    psf->datalength = psf->filelength - psf->dataoffset;
    }
#line 212
    if (psf->dataend) {
#line 213
      psf->datalength -= psf->filelength - psf->dataend;
    }
#line 215
    psf->sf.frames = psf->datalength / (long )(psf->bytewidth * psf->sf.channels);
  }
  {
#line 218
  encoding = au_format_to_encoding(psf->sf.format & 65535);
  }
#line 219
  if (! encoding) {
#line 220
    psf->error = 1;
#line 220
    return (psf->error);
  }
#line 223
  psf->header[0] = (unsigned char )0;
#line 224
  psf->headindex = 0;
#line 230
  if (psf->is_pipe == 0) {
    {
#line 231
    psf_fseek(psf, (sf_count_t )0, 0);
    }
  }
#line 238
  if (psf->datalength < 0L) {
#line 239
    datalength = - 1;
  } else
#line 238
  if (psf->datalength > 2147483647L) {
#line 239
    datalength = - 1;
  } else {
#line 241
    datalength = (int )(psf->datalength & 2147483647L);
  }
#line 243
  if (psf->endian == 536870912) {
    {
#line 244
    psf_binheader_writef(psf, "Em4", ((46 | (115 << 8)) | (110 << 16)) | (100 << 24),
                         24);
#line 245
    psf_binheader_writef(psf, "E4444", datalength, encoding, psf->sf.samplerate, psf->sf.channels);
    }
  } else
#line 247
  if (psf->endian == 268435456) {
    {
#line 248
    psf_binheader_writef(psf, "em4", ((100 | (110 << 8)) | (115 << 16)) | (46 << 24),
                         24);
#line 249
    psf_binheader_writef(psf, "e4444V", datalength, encoding, psf->sf.samplerate,
                         psf->sf.channels);
    }
  } else {
#line 252
    psf->error = 1;
#line 252
    return (psf->error);
  }
  {
#line 255
  psf_fwrite((unsigned char *)psf->header, (sf_count_t )psf->headindex, (sf_count_t )1,
             psf);
  }
#line 257
  if (psf->error) {
#line 258
    return (psf->error);
  }
#line 260
  psf->dataoffset = (sf_count_t )psf->headindex;
#line 262
  if (current > 0L) {
    {
#line 263
    psf_fseek(psf, current, 0);
    }
  }
#line 265
  return (psf->error);
}
}
#line 269 "/root/libsndfile/src/au.c"
static int au_format_to_encoding(int format ) 
{ 


  {
  {
#line 272
  if (format == 1) {
#line 272
    goto case_1;
  }
#line 273
  if (format == 2) {
#line 273
    goto case_2;
  }
#line 274
  if (format == 3) {
#line 274
    goto case_3;
  }
#line 275
  if (format == 4) {
#line 275
    goto case_4;
  }
#line 277
  if (format == 6) {
#line 277
    goto case_6;
  }
#line 278
  if (format == 7) {
#line 278
    goto case_7;
  }
#line 280
  if (format == 16) {
#line 280
    goto case_16;
  }
#line 281
  if (format == 17) {
#line 281
    goto case_17;
  }
#line 283
  if (format == 48) {
#line 283
    goto case_48;
  }
#line 284
  if (format == 49) {
#line 284
    goto case_49;
  }
#line 285
  if (format == 50) {
#line 285
    goto case_50;
  }
#line 287
  goto switch_default;
  case_1: /* CIL Label */ 
#line 272
  return (2);
  case_2: /* CIL Label */ 
#line 273
  return (3);
  case_3: /* CIL Label */ 
#line 274
  return (4);
  case_4: /* CIL Label */ 
#line 275
  return (5);
  case_6: /* CIL Label */ 
#line 277
  return (6);
  case_7: /* CIL Label */ 
#line 278
  return (7);
  case_16: /* CIL Label */ 
#line 280
  return (1);
  case_17: /* CIL Label */ 
#line 281
  return (27);
  case_48: /* CIL Label */ 
#line 283
  return (23);
  case_49: /* CIL Label */ 
#line 284
  return (25);
  case_50: /* CIL Label */ 
#line 285
  return (26);
  switch_default: /* CIL Label */ 
#line 287
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }

#line 289
  return (0);
}
}
#line 293 "/root/libsndfile/src/au.c"
static int au_read_header(SF_PRIVATE *psf ) 
{ 
  AU_FMT au_fmt ;
  int marker ;
  int dword ;
  sf_count_t __cil_tmp5 ;
  sf_count_t __cil_tmp6 ;

  {
  {
#line 297
  memset(& au_fmt, 0, sizeof(au_fmt));
#line 298
  psf_binheader_readf(psf, "pm", 0, & marker);
#line 299
  psf_log_printf(psf, "%M\n", marker);
  }
#line 301
  if (marker == (((46 | (115 << 8)) | (110 << 16)) | (100 << 24))) {
    {
#line 302
    psf->endian = 536870912;
#line 304
    psf_binheader_readf(psf, "E44444", & au_fmt.dataoffset, & au_fmt.datasize, & au_fmt.encoding,
                        & au_fmt.samplerate, & au_fmt.channels);
    }
  } else
#line 307
  if (marker == (((100 | (110 << 8)) | (115 << 16)) | (46 << 24))) {
    {
#line 308
    psf->endian = 268435456;
#line 309
    psf_binheader_readf(psf, "e44444", & au_fmt.dataoffset, & au_fmt.datasize, & au_fmt.encoding,
                        & au_fmt.samplerate, & au_fmt.channels);
    }
  } else {
#line 313
    return (87);
  }
  {
#line 315
  psf_log_printf(psf, "  Data Offset : %d\n", au_fmt.dataoffset);
  }
#line 317
  if (psf->fileoffset > 0L) {
#line 317
    if (au_fmt.datasize == -1) {
      {
#line 318
      psf_log_printf(psf, "  Data Size   : -1\n");
      }
#line 319
      return (88);
    }
  }

#line 322
  if (psf->fileoffset > 0L) {
    {
#line 323
    psf->filelength = (sf_count_t )(au_fmt.dataoffset + au_fmt.datasize);
#line 324
    psf_log_printf(psf, "  Data Size   : %d\n", au_fmt.datasize);
    }
  } else
#line 326
  if (au_fmt.datasize == -1) {
    {
    {
#line 327
    psf_log_printf(psf, "  Data Size   : %d\n\375\036V", au_fmt.datasize);
    }
    }
  } else
#line 326
  if ((long )(au_fmt.dataoffset + au_fmt.datasize) == psf->filelength) {
    {
    {
#line 327
    psf_log_printf(psf, "  Data Size   : %d\n\375\036V", au_fmt.datasize);
    }
    }
  } else
#line 328
  if ((long )(au_fmt.dataoffset + au_fmt.datasize) < psf->filelength) {
    {
#line 329
    psf->filelength = (sf_count_t )(au_fmt.dataoffset + au_fmt.datasize);
#line 330
    psf_log_printf(psf, "  Data Size   : %d\n\375\036V", au_fmt.datasize);
    }
  } else {
    {
#line 333
    dword = (int )(psf->filelength - (long )au_fmt.dataoffset);
#line 334
    psf_log_printf(psf, "  Data Size   : %d (should be %d)\n", au_fmt.datasize, dword);
#line 335
    au_fmt.datasize = dword;
    }
  }
  {
#line 338
  psf->dataoffset = (sf_count_t )au_fmt.dataoffset;
#line 339
  psf->datalength = psf->filelength - psf->dataoffset;
#line 341
  __cil_tmp5 = psf_ftell(psf);
  }
#line 341
  if (__cil_tmp5 < psf->dataoffset) {
    {
#line 342
    __cil_tmp6 = psf_ftell(psf);
#line 342
    psf_binheader_readf(psf, "j!\300\375\036V", psf->dataoffset - __cil_tmp6);
    }
  }
#line 344
  psf->sf.samplerate = au_fmt.samplerate;
#line 345
  psf->sf.channels = au_fmt.channels;
#line 348
  if (psf->endian == 536870912) {
#line 349
    psf->sf.format = 196608;
  } else
#line 350
  if (psf->endian == 268435456) {
#line 351
    psf->sf.format = 268632064;
  }
  {
#line 353
  psf_log_printf(psf, "  Encoding    : %d => ", au_fmt.encoding);
#line 355
  psf->sf.format &= 805306368;
  }
  {
#line 358
  if (au_fmt.encoding == 1) {
#line 358
    goto case_1;
  }
#line 364
  if (au_fmt.encoding == 2) {
#line 364
    goto case_2;
  }
#line 370
  if (au_fmt.encoding == 3) {
#line 370
    goto case_3;
  }
#line 376
  if (au_fmt.encoding == 4) {
#line 376
    goto case_4;
  }
#line 382
  if (au_fmt.encoding == 5) {
#line 382
    goto case_5;
  }
#line 388
  if (au_fmt.encoding == 6) {
#line 388
    goto case_6;
  }
#line 394
  if (au_fmt.encoding == 7) {
#line 394
    goto case_7;
  }
#line 400
  if (au_fmt.encoding == 27) {
#line 400
    goto case_27;
  }
#line 406
  if (au_fmt.encoding == 23) {
#line 406
    goto case_23;
  }
#line 412
  if (au_fmt.encoding == 25) {
#line 412
    goto case_25;
  }
#line 418
  if (au_fmt.encoding == 26) {
#line 418
    goto case_26;
  }
#line 424
  if (au_fmt.encoding == 24) {
#line 424
    goto case_24;
  }
#line 428
  if (au_fmt.encoding == 19) {
#line 428
    goto case_19;
  }
#line 432
  goto switch_default;
  case_1: /* CIL Label */ 
#line 359
  psf->sf.format |= 196624;
  {
#line 360
  psf->bytewidth = 1;
#line 361
  psf_log_printf(psf, "8-bit ISDN u-law\n");
  }
#line 362
  goto switch_break;
  case_2: /* CIL Label */ 
#line 365
  psf->sf.format |= 196609;
  {
#line 366
  psf->bytewidth = 1;
#line 367
  psf_log_printf(psf, "8-bit linear PCM\n");
  }
#line 368
  goto switch_break;
  case_3: /* CIL Label */ 
#line 371
  psf->sf.format |= 196610;
  {
#line 372
  psf->bytewidth = 2;
#line 373
  psf_log_printf(psf, "16-bit linear PCM\n");
  }
#line 374
  goto switch_break;
  case_4: /* CIL Label */ 
#line 377
  psf->sf.format |= 196611;
  {
#line 378
  psf->bytewidth = 3;
#line 379
  psf_log_printf(psf, "24-bit linear PCM\n");
  }
#line 380
  goto switch_break;
  case_5: /* CIL Label */ 
#line 383
  psf->sf.format |= 196612;
  {
#line 384
  psf->bytewidth = 4;
#line 385
  psf_log_printf(psf, "32-bit linear PCM\n");
  }
#line 386
  goto switch_break;
  case_6: /* CIL Label */ 
#line 389
  psf->sf.format |= 196614;
  {
#line 390
  psf->bytewidth = 4;
#line 391
  psf_log_printf(psf, "32-bit float\n");
  }
#line 392
  goto switch_break;
  case_7: /* CIL Label */ 
#line 395
  psf->sf.format |= 196615;
  {
#line 396
  psf->bytewidth = 8;
#line 397
  psf_log_printf(psf, "64-bit double precision float\n");
  }
#line 398
  goto switch_break;
  case_27: /* CIL Label */ 
#line 401
  psf->sf.format |= 196625;
  {
#line 402
  psf->bytewidth = 1;
#line 403
  psf_log_printf(psf, "8-bit ISDN A-law\n");
  }
#line 404
  goto switch_break;
  case_23: /* CIL Label */ 
#line 407
  psf->sf.format |= 196656;
  {
#line 408
  psf->bytewidth = 0;
#line 409
  psf_log_printf(psf, "G721 32kbs ADPCM\n");
  }
#line 410
  goto switch_break;
  case_25: /* CIL Label */ 
#line 413
  psf->sf.format |= 196657;
  {
#line 414
  psf->bytewidth = 0;
#line 415
  psf_log_printf(psf, "G723 24kbs ADPCM\n");
  }
#line 416
  goto switch_break;
  case_26: /* CIL Label */ 
#line 419
  psf->sf.format |= 196658;
  {
#line 420
  psf->bytewidth = 0;
#line 421
  psf_log_printf(psf, "G723 40kbs ADPCM\n");
  }
#line 422
  goto switch_break;
  case_24: /* CIL Label */ 
  {
#line 425
  psf_log_printf(psf, "G722 64 kbs ADPCM (unsupported)\n\220");
  }
#line 426
  goto switch_break;
  case_19: /* CIL Label */ 
  {
#line 429
  psf_log_printf(psf, "Weird NeXT encoding format (unsupported)\n");
  }
#line 430
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 433
  psf_log_printf(psf, "Unknown!!\n");
  }
#line 434
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 437
  psf_log_printf(psf, "  Sample Rate : %d\n", au_fmt.samplerate);
  }
#line 438
  if (au_fmt.channels < 1) {
    {
#line 439
    psf_log_printf(psf, "  Channels    : %d  **** should be >= 1\n\230\001", au_fmt.channels);
    }
#line 440
    return (32);
  } else {
    {
#line 443
    psf_log_printf(psf, "  Channels    : %d\n", au_fmt.channels);
    }
  }
#line 445
  psf->blockwidth = psf->sf.channels * psf->bytewidth;
#line 447
  if (! psf->sf.frames) {
#line 447
    if (psf->blockwidth) {
#line 448
      psf->sf.frames = (psf->filelength - psf->dataoffset) / (long )psf->blockwidth;
    }
  }
#line 450
  return (0);
}
}
#line 197 "/root/libsndfile/src/aiff.c"
static int aiff_close(SF_PRIVATE *psf ) ;
#line 199
static int tenbytefloat2int(unsigned char *bytes ) ;
#line 200
static void uint2tenbytefloat(unsigned int num , unsigned char *bytes ) ;
#line 202
static int aiff_read_comm_chunk(SF_PRIVATE *psf , COMM_CHUNK *comm_fmt ) ;
#line 204
static int aiff_read_header(SF_PRIVATE *psf , COMM_CHUNK *comm_fmt ) ;
#line 206
static int aiff_write_header(SF_PRIVATE *psf , int calc_length ) ;
#line 207
static int aiff_write_tailer(SF_PRIVATE *psf ) ;
#line 208
static void aiff_write_strings(SF_PRIVATE *psf , int location ) ;
#line 210
static int aiff_command(SF_PRIVATE *UNUSED_psf , int UNUSED_command , void *UNUSED_data ,
                        int UNUSED_datasize ) ;
#line 212
static char const   *get_loop_mode_str(short mode ) ;
#line 214
static short get_loop_mode(short mode ) ;
#line 216
static int aiff_read_basc_chunk(SF_PRIVATE *psf , int datasize ) ;
#line 218
static unsigned int marker_to_position(MARK_ID_POS *m , unsigned short n , int marksize ) ;
#line 225 "/root/libsndfile/src/aiff.c"
int aiff_open(SF_PRIVATE *psf ) 
{ 
  COMM_CHUNK comm_fmt ;
  int error ;
  int subformat ;
  void *__cil_tmp5 ;
  int __cil_tmp6 ;
  PEAK_INFO *__cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;

  {
  {
#line 229
  memset(& comm_fmt, 0, sizeof(comm_fmt));
#line 231
  subformat = psf->sf.format & 65535;
#line 233
  psf->container_data = calloc((unsigned long )1, sizeof(AIFF_PRIVATE ));
  }
#line 233
  if (psf->container_data == (void *)0) {
#line 234
    return (16);
  }
#line 236
  if (psf->mode == 16) {
    _L: /* CIL Label */ 
    {
#line 237
    error = aiff_read_header(psf, & comm_fmt);
    }
#line 237
    if (error) {
#line 238
      return (error);
    }
    {
#line 239
    psf_fseek(psf, psf->dataoffset, 0);
    }
  } else
#line 236
  if (psf->mode == 48) {
#line 236
    if (psf->filelength > 0L) {
#line 236
      goto _L;
    }
  }

#line 242
  if (psf->mode == 32) {
    _L___43: /* CIL Label */ 
#line 243
    if (psf->is_pipe) {
#line 244
      return (28);
    }
#line 246
    if ((psf->sf.format & 268369920) != 131072) {
#line 247
      return (1);
    }
#line 249
    if (psf->mode == 32) {
#line 249
      if (subformat == 6) {
        _L___42: /* CIL Label */ 
        {
#line 250
        psf->peak_info = peak_info_calloc(psf->sf.channels);
        }
#line 250
        if (psf->peak_info == (void *)0) {
#line 251
          return (16);
        }
#line 252
        (psf->peak_info)->peak_loc = 42;
      } else
#line 249
      if (subformat == 7) {
#line 249
        goto _L___42;
      }
    }

#line 255
    if (psf->mode != 48) {
#line 256
      psf->filelength = (sf_count_t )0;
#line 257
      psf->datalength = (sf_count_t )0;
#line 258
      psf->dataoffset = (sf_count_t )0;
#line 259
      psf->sf.frames = (sf_count_t )0;
    } else
#line 255
    if (psf->filelength < 40L) {
#line 256
      psf->filelength = (sf_count_t )0;
#line 257
      psf->datalength = (sf_count_t )0;
#line 258
      psf->dataoffset = (sf_count_t )0;
#line 259
      psf->sf.frames = (sf_count_t )0;
    }
    {
#line 262
    psf->str_flags = 768;
#line 264
    error = aiff_write_header(psf, 0);
    }
#line 264
    if (error) {
#line 265
      return (error);
    }
#line 267
    psf->write_header = & aiff_write_header;
  } else
#line 242
  if (psf->mode == 48) {
#line 242
    goto _L___43;
  }
#line 270
  psf->container_close = & aiff_close;
#line 271
  psf->command = & aiff_command;
  {
#line 274
  if ((psf->sf.format & 65535) == 5) {
#line 274
    goto case_5;
  }
#line 278
  if ((psf->sf.format & 65535) == 1) {
#line 278
    goto case_1;
  }
#line 284
  if ((psf->sf.format & 65535) == 4) {
#line 284
    goto case_4;
  }
#line 284
  if ((psf->sf.format & 65535) == 3) {
#line 284
    goto case_4;
  }
#line 284
  if ((psf->sf.format & 65535) == 2) {
#line 284
    goto case_4;
  }
#line 288
  if ((psf->sf.format & 65535) == 16) {
#line 288
    goto case_16;
  }
#line 292
  if ((psf->sf.format & 65535) == 17) {
#line 292
    goto case_17;
  }
#line 297
  if ((psf->sf.format & 65535) == 6) {
#line 297
    goto case_6;
  }
#line 301
  if ((psf->sf.format & 65535) == 7) {
#line 301
    goto case_7;
  }
#line 305
  if ((psf->sf.format & 65535) == 64) {
#line 305
    goto case_64;
  }
#line 309
  if ((psf->sf.format & 65535) == 65) {
#line 309
    goto case_65;
  }
#line 313
  if ((psf->sf.format & 65535) == 66) {
#line 313
    goto case_66;
  }
#line 317
  if ((psf->sf.format & 65535) == 67) {
#line 317
    goto case_67;
  }
#line 331
  if ((psf->sf.format & 65535) == 18) {
#line 331
    goto case_18;
  }
#line 340
  if ((psf->sf.format & 65535) == 32) {
#line 340
    goto case_32;
  }
#line 344
  goto switch_default;
  case_5: /* CIL Label */ 
  {
#line 275
  error = pcm_init(psf);
  }
#line 276
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 279
  error = pcm_init(psf);
  }
#line 280
  goto switch_break;
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 285
  error = pcm_init(psf);
  }
#line 286
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 289
  error = ulaw_init(psf);
  }
#line 290
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 293
  error = alaw_init(psf);
  }
#line 294
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 298
  error = float32_init(psf);
  }
#line 299
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 302
  error = double64_init(psf);
  }
#line 303
  goto switch_break;
  case_64: /* CIL Label */ 
  {
#line 306
  error = dwvw_init(psf, 12);
  }
#line 307
  goto switch_break;
  case_65: /* CIL Label */ 
  {
#line 310
  error = dwvw_init(psf, 16);
  }
#line 311
  goto switch_break;
  case_66: /* CIL Label */ 
  {
#line 314
  error = dwvw_init(psf, 24);
  }
#line 315
  goto switch_break;
  case_67: /* CIL Label */ 
#line 318
  if (psf->mode != 16) {
#line 319
    error = 132;
#line 320
    goto switch_break;
  }

#line 322
  if ((int )comm_fmt.sampleSize >= 8) {
#line 322
    if ((int )comm_fmt.sampleSize < 24) {
      {
#line 323
      error = dwvw_init(psf, (int )comm_fmt.sampleSize);
#line 324
      psf->sf.frames = (sf_count_t )comm_fmt.numSampleFrames;
      }
#line 325
      goto switch_break;
    }
  }
  {
#line 327
  psf_log_printf(psf, "AIFC/DWVW : Bad bitwidth %d\n", (int )comm_fmt.sampleSize);
#line 328
  error = 132;
  }
#line 329
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 336
  error = aiff_ima_init(psf, 34, 64);
  }
#line 337
  goto switch_break;
  case_32: /* CIL Label */ 
  {
#line 341
  error = gsm610_init(psf);
  }
#line 342
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 344
  return (17);
  switch_break: /* CIL Label */ ;
  }

#line 348
  return (error);
}
}
#line 357 "/root/libsndfile/src/aiff.c"
static unsigned int marker_to_position(MARK_ID_POS *m , unsigned short n , int marksize ) 
{ 
  int i ;
  int __cil_tmp5 ;

  {
#line 360
  i = 0;
  {
#line 360
  while (1) {
    while_continue: /* CIL Label */ ;
#line 360
    if (! (i < marksize)) {
#line 360
      goto while_break;
    }
#line 361
    if ((int )(m + i)->markerID == (int )n) {
#line 362
      return ((m + i)->position);
    }
#line 360
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 363
  return ((unsigned int )0);
}
}
#line 367 "/root/libsndfile/src/aiff.c"
static int aiff_read_header(SF_PRIVATE *psf , COMM_CHUNK *comm_fmt ) 
{ 
  SSND_CHUNK ssnd_fmt ;
  AIFF_PRIVATE *paiff ;
  unsigned int marker ;
  unsigned int dword ;
  unsigned int FORMsize ;
  unsigned int SSNDsize ;
  unsigned int bytesread ;
  int k ;
  int found_chunk ;
  int done ;
  int error ;
  char *cptr ;
  char byte ;
  int instr_found ;
  int mark_found ;
  int mark_count ;
  int tmp ;
  sf_count_t __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  PEAK_INFO *__cil_tmp23 ;
  float value ;
  unsigned int position ;
  unsigned int __cil_tmp26 ;
  int tmp___0 ;
  sf_count_t __cil_tmp28 ;
  sf_count_t __cil_tmp29 ;
  sf_count_t __cil_tmp30 ;
  sf_count_t __cil_tmp31 ;
  unsigned short count ;
  unsigned short id ;
  unsigned short len ;
  unsigned int timestamp ;
  sf_count_t __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  unsigned int appl_marker ;
  sf_count_t __cil_tmp41 ;
  unsigned short const   **__cil_tmp42 ;
  int __cil_tmp43 ;
  sf_count_t __cil_tmp44 ;
  sf_count_t __cil_tmp45 ;
  sf_count_t __cil_tmp46 ;
  unsigned char bytes[6] ;
  short gain ;
  SF_INSTRUMENT *__cil_tmp49 ;
  short mode ;
  char const   *loop_mode ;
  unsigned short begin ;
  unsigned short end ;
  char const   *__cil_tmp54 ;
  short __cil_tmp55 ;
  char const   *__cil_tmp56 ;
  short __cil_tmp57 ;
  int __cil_tmp58 ;
  sf_count_t __cil_tmp59 ;
  int __cil_tmp60 ;
  sf_count_t __cil_tmp61 ;
  unsigned short mark_id ;
  unsigned short n ;
  unsigned int position___0 ;
  int __cil_tmp65 ;
  void *__cil_tmp66 ;
  unsigned int pstr_len ;
  unsigned char ch ;
  int __cil_tmp69 ;
  int tmp___1 ;
  int __cil_tmp71 ;
  unsigned int read_len ;
  int __cil_tmp73 ;
  unsigned short __cil_tmp74 ;
  int __cil_tmp75 ;
  sf_count_t __cil_tmp76 ;
  unsigned short const   **__cil_tmp77 ;
  unsigned short const   **__cil_tmp78 ;
  unsigned short const   **__cil_tmp79 ;
  unsigned short const   **__cil_tmp80 ;
  sf_count_t __cil_tmp81 ;
  sf_count_t __cil_tmp82 ;
  sf_count_t __cil_tmp83 ;
  int j ;
  unsigned int __cil_tmp85 ;
  unsigned int __cil_tmp86 ;
  int __cil_tmp87 ;

  {
#line 371
  found_chunk = 0;
#line 371
  done = 0;
#line 371
  error = 0;
#line 373
  instr_found = 0;
#line 373
  mark_found = 0;
#line 373
  mark_count = 0;
#line 375
  if (psf->filelength > 4294967295L) {
    {
#line 376
    psf_log_printf(psf, "Warning : filelength > 0xffffffff. This is bad!!!!\n");
    }
  }
#line 378
  paiff = psf->container_data;
#line 378
  if (paiff == (void *)0) {
#line 379
    return (29);
  }
  {
#line 381
  paiff->comm_offset = (sf_count_t )0;
#line 382
  paiff->ssnd_offset = (sf_count_t )0;
#line 385
  psf_binheader_readf(psf, "p", 0);
#line 387
  memset(comm_fmt, 0, sizeof(COMM_CHUNK ));
#line 390
  psf->endian = 536870912;
  }
  {
#line 396
  while (1) {
    while_continue: /* CIL Label */ ;
#line 396
    if (! (! done)) {
#line 396
      goto while_break;
    }
    {
#line 397
    psf_binheader_readf(psf, "m", & marker);
    }
#line 399
    if (psf->mode == 48) {
#line 399
      if (found_chunk & 32) {
#line 400
        return (85);
      }
    }
    {
#line 403
    if (marker == (unsigned int )(((70 | (79 << 8)) | (82 << 16)) | (77 << 24))) {
#line 403
      goto case_exp;
    }
#line 426
    if (marker == (unsigned int )(((65 | (73 << 8)) | (70 << 16)) | (70 << 24))) {
#line 426
      goto case_exp___0;
    }
#line 426
    if (marker == (unsigned int )(((65 | (73 << 8)) | (70 << 16)) | (67 << 24))) {
#line 426
      goto case_exp___0;
    }
#line 433
    if (marker == (unsigned int )(((67 | (79 << 8)) | (77 << 16)) | (77 << 24))) {
#line 433
      goto case_exp___2;
    }
#line 450
    if (marker == (unsigned int )(((80 | (69 << 8)) | (65 << 16)) | (75 << 24))) {
#line 450
      goto case_exp___3;
    }
#line 497
    if (marker == (unsigned int )(((83 | (83 << 8)) | (78 << 16)) | (68 << 24))) {
#line 497
      goto case_exp___4;
    }
#line 540
    if (marker == (unsigned int )(((40 | (99 << 8)) | (41 << 16)) | (32 << 24))) {
#line 540
      goto case_exp___5;
    }
#line 560
    if (marker == (unsigned int )(((65 | (85 << 8)) | (84 << 16)) | (72 << 24))) {
#line 560
      goto case_exp___6;
    }
#line 577
    if (marker == (unsigned int )(((67 | (79 << 8)) | (77 << 16)) | (84 << 24))) {
#line 577
      goto case_exp___7;
    }
#line 609
    if (marker == (unsigned int )(((65 | (80 << 8)) | (80 << 16)) | (76 << 24))) {
#line 609
      goto case_exp___8;
    }
#line 643
    if (marker == (unsigned int )(((78 | (65 << 8)) | (77 << 16)) | (69 << 24))) {
#line 643
      goto case_exp___9;
    }
#line 660
    if (marker == (unsigned int )(((65 | (78 << 8)) | (78 << 16)) | (79 << 24))) {
#line 660
      goto case_exp___10;
    }
#line 677
    if (marker == (unsigned int )(((73 | (78 << 8)) | (83 << 16)) | (84 << 24))) {
#line 677
      goto case_exp___11;
    }
#line 745
    if (marker == (unsigned int )(((98 | (97 << 8)) | (115 << 16)) | (99 << 24))) {
#line 745
      goto case_exp___12;
    }
#line 754
    if (marker == (unsigned int )(((77 | (65 << 8)) | (82 << 16)) | (75 << 24))) {
#line 754
      goto case_exp___13;
    }
#line 807
    if (marker == (unsigned int )(((70 | (86 << 8)) | (69 << 16)) | (82 << 24))) {
#line 807
      goto case_exp___14;
    }
#line 811
    if (marker == (unsigned int )(((83 | (70 << 8)) | (88 << 16)) | (33 << 24))) {
#line 811
      goto case_exp___15;
    }
#line 819
    if (marker == (unsigned int )(((78 | (79 << 8)) | (78 << 16)) | (69 << 24))) {
#line 819
      goto case_exp___16;
    }
#line 826
    goto switch_default;
    case_exp: /* CIL Label */ 
#line 404
    if (found_chunk) {
#line 405
      return (74);
    }
    {
#line 407
    psf_binheader_readf(psf, "E4\332\375\036V", & FORMsize);
#line 408
    pchk4_store(& paiff->chunk4, (int )marker, (sf_count_t )(psf->headindex - 8),
                (sf_count_t )FORMsize);
    }
#line 410
    if (psf->fileoffset > 0L) {
#line 410
      if (psf->filelength > (long )(FORMsize + 8U)) {
        {
#line 412
        psf->filelength = (sf_count_t )(FORMsize + 8U);
#line 413
        psf_log_printf(psf, "FORM : %u\n\332\375\036V", FORMsize);
        }
      } else {
#line 410
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 415
    if ((long )FORMsize != psf->filelength - (long )(2 * (int )sizeof(dword))) {
      {
#line 416
      dword = (unsigned int )((unsigned long )psf->filelength - 2UL * sizeof(dword));
#line 417
      psf_log_printf(psf, "FORM : %u (should be %u)\n", FORMsize, dword);
#line 418
      FORMsize = dword;
      }
    } else {
      {
#line 421
      psf_log_printf(psf, "FORM : %u\n", FORMsize);
      }
    }
#line 422
    found_chunk |= 1;
#line 423
    goto switch_break;
    case_exp___0: /* CIL Label */ 
    case_exp___1: /* CIL Label */ 
#line 427
    if ((found_chunk & 1) == 0) {
#line 428
      return (75);
    }
    {
#line 429
    psf_log_printf(psf, " %M\n\036V", marker);
    }
#line 430
    if (marker == (unsigned int )(((65 | (73 << 8)) | (70 << 16)) | (67 << 24))) {
#line 430
      tmp = 6;
    } else {
#line 430
      tmp = 2;
    }
#line 430
    found_chunk |= tmp;
#line 431
    goto switch_break;
    case_exp___2: /* CIL Label */ 
    {
#line 434
    __cil_tmp20 = psf_ftell(psf);
#line 434
    paiff->comm_offset = __cil_tmp20 - 4L;
    }
    {
#line 435
    error = aiff_read_comm_chunk(psf, comm_fmt);
#line 436
    pchk4_store(& paiff->chunk4, (int )marker, paiff->comm_offset, (sf_count_t )comm_fmt->size);
#line 439
    psf->sf.samplerate = tenbytefloat2int((unsigned char *)comm_fmt->sampleRate);
#line 440
    psf->sf.frames = (sf_count_t )comm_fmt->numSampleFrames;
#line 441
    psf->sf.channels = (int )comm_fmt->numChannels;
#line 442
    psf->bytewidth = ((int )comm_fmt->sampleSize + 7) / 8;
    }
#line 444
    if (error) {
#line 445
      return (error);
    }
#line 447
    found_chunk |= 16;
#line 448
    goto switch_break;
    case_exp___3: /* CIL Label */ 
#line 452
    if ((found_chunk & 19) != 19) {
#line 453
      return (81);
    }
    {
#line 455
    psf_binheader_readf(psf, "E4", & dword);
#line 456
    pchk4_store(& paiff->chunk4, (int )marker, (sf_count_t )(psf->headindex - 8),
                (sf_count_t )dword);
#line 458
    psf_log_printf(psf, "%M : %d\n\230\001", marker, dword);
    }
#line 459
    if ((unsigned long )dword != 2UL * sizeof(int ) + (unsigned long )psf->sf.channels * (sizeof(float ) + sizeof(int ))) {
      {
#line 460
      psf_binheader_readf(psf, "j\020", dword);
#line 461
      psf_log_printf(psf, "*** File PEAK chunk too big.\nV");
      }
#line 462
      return (63);
    }
    {
#line 465
    psf->peak_info = peak_info_calloc(psf->sf.channels);
    }
#line 465
    if (psf->peak_info == (void *)0) {
#line 466
      return (16);
    }
    {
#line 469
    psf_binheader_readf(psf, "E44", & (psf->peak_info)->version, & (psf->peak_info)->timestamp);
    }
#line 471
    if ((psf->peak_info)->version != 1U) {
      {
#line 472
      psf_log_printf(psf, "  version    : %d *** (should be version 1)\n\036V", (psf->peak_info)->version);
      }
    } else {
      {
#line 474
      psf_log_printf(psf, "  version    : %d\n", (psf->peak_info)->version);
      }
    }
    {
#line 476
    psf_log_printf(psf, "  time stamp : %d\n\331\375\036V", (psf->peak_info)->timestamp);
#line 477
    psf_log_printf(psf, "    Ch   Position       Value\n");
#line 479
    cptr = (char *)psf->u.cbuf;
#line 480
    dword = (unsigned int )0;
    }
    {
#line 480
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 480
      if (! (dword < (unsigned int )psf->sf.channels)) {
#line 480
        goto while_break___0;
      }
      {
#line 484
      psf_binheader_readf(psf, "Ef4", & value, & position);
#line 485
      (psf->peak_info)->peaks[dword].value = (double )value;
#line 486
      (psf->peak_info)->peaks[dword].position = (sf_count_t )position;
#line 488
      snprintf(cptr, sizeof(psf->u.scbuf), "    %2d   %-12ld   %g\n", dword, (long )(psf->peak_info)->peaks[dword].position,
               (psf->peak_info)->peaks[dword].value);
#line 490
      *(cptr + (sizeof(psf->u.scbuf) - 1UL)) = (char )0;
#line 491
      psf_log_printf(psf, (char const   *)cptr);
      }
#line 480
      dword ++;
    }
    while_break___0: /* CIL Label */ ;
    }

#line 494
    if ((found_chunk & 32) == 0) {
#line 494
      tmp___0 = 42;
    } else {
#line 494
      tmp___0 = 43;
    }
#line 494
    (psf->peak_info)->peak_loc = tmp___0;
#line 495
    goto switch_break;
    case_exp___4: /* CIL Label */ 
#line 498
    if (found_chunk & 4) {
#line 498
      if ((found_chunk & 8) == 0) {
        {
#line 499
        psf_log_printf(psf, "*** Valid AIFC files should have an FVER chunk.\n\220");
        }
      }
    }
    {
#line 501
    __cil_tmp28 = psf_ftell(psf);
#line 501
    paiff->ssnd_offset = __cil_tmp28 - 4L;
#line 502
    psf_binheader_readf(psf, "E444", & SSNDsize, & ssnd_fmt.offset, & ssnd_fmt.blocksize);
#line 503
    pchk4_store(& paiff->chunk4, (int )marker, paiff->ssnd_offset, (sf_count_t )SSNDsize);
#line 505
    psf->datalength = (sf_count_t )((unsigned long )SSNDsize - sizeof(ssnd_fmt));
#line 506
    psf->dataoffset = psf_ftell(psf);
    }
#line 508
    if (psf->datalength > psf->filelength - psf->dataoffset) {
      {
      {
#line 509
      psf_log_printf(psf, " SSND : %u (should be %D)\n", SSNDsize, (unsigned long )(psf->filelength - psf->dataoffset) + sizeof(SSND_CHUNK ));
      }
#line 510
      psf->datalength = psf->filelength - psf->dataoffset;
      }
    } else
#line 508
    if (psf->datalength < 0L) {
      {
      {
#line 509
      psf_log_printf(psf, " SSND : %u (should be %D)\n", SSNDsize, (unsigned long )(psf->filelength - psf->dataoffset) + sizeof(SSND_CHUNK ));
      }
#line 510
      psf->datalength = psf->filelength - psf->dataoffset;
      }
    } else {
      {
#line 513
      psf_log_printf(psf, " SSND : %u\n", SSNDsize);
      }
    }
#line 515
    if (ssnd_fmt.offset == 0U) {
      {
      {
#line 516
      psf_log_printf(psf, "  Offset     : %u\n", ssnd_fmt.offset);
      }
      {
#line 517
      psf_log_printf(psf, "  Block Size : %u\n", ssnd_fmt.blocksize);
      }
#line 519
      psf->dataoffset += (long )ssnd_fmt.offset;
#line 520
      psf->datalength -= (long )ssnd_fmt.offset;
      }
    } else
#line 515
    if (psf->dataoffset + (long )ssnd_fmt.offset == (long )ssnd_fmt.blocksize) {
      {
      {
#line 516
      psf_log_printf(psf, "  Offset     : %u\n", ssnd_fmt.offset);
      }
      {
#line 517
      psf_log_printf(psf, "  Block Size : %u\n", ssnd_fmt.blocksize);
      }
#line 519
      psf->dataoffset += (long )ssnd_fmt.offset;
#line 520
      psf->datalength -= (long )ssnd_fmt.offset;
      }
    } else {
      {
#line 523
      psf_log_printf(psf, "  Offset     : %u (Should be zero)\n", ssnd_fmt.offset);
#line 524
      psf_log_printf(psf, "  Block Size : %u ???\n", ssnd_fmt.blocksize);
      }
    }

#line 528
    if (psf->datalength + psf->dataoffset < psf->filelength) {
#line 529
      psf->dataend = psf->datalength + psf->dataoffset;
    }
#line 531
    found_chunk |= 32;
#line 533
    if (! psf->sf.seekable) {
#line 534
      goto switch_break;
    }
    {
#line 537
    psf_fseek(psf, (psf->dataoffset + psf->datalength) + (long )(SSNDsize & 1U), 0);
    }
#line 538
    goto switch_break;
    case_exp___5: /* CIL Label */ 
    {
#line 541
    psf_binheader_readf(psf, "E4", & dword);
    }
    {
#line 542
    __cil_tmp30 = psf_ftell(psf);
#line 542
    pchk4_store(& paiff->chunk4, (int )marker, __cil_tmp30 - 8L, (sf_count_t )dword);
    }
#line 543
    if (dword == 0U) {
#line 544
      goto switch_break;
    }
#line 545
    if (dword >= (unsigned int )((int )sizeof(psf->u.scbuf))) {
      {
#line 546
      psf_log_printf(psf, " %M : %d (too big)\n", marker, dword);
      }
#line 547
      return (29);
    }
    {
#line 550
    cptr = (char *)psf->u.cbuf;
#line 551
    psf_binheader_readf(psf, "b", cptr, dword + (dword & 1U));
#line 552
    *(cptr + dword) = (char )0;
#line 554
    psf_sanitize_string(cptr, (int )dword);
#line 556
    psf_log_printf(psf, " %M : %s\n", marker, cptr);
#line 557
    psf_store_string(psf, 2, (char const   *)cptr);
    }
#line 558
    goto switch_break;
    case_exp___6: /* CIL Label */ 
    {
#line 561
    psf_binheader_readf(psf, "E4", & dword);
    }
    {
#line 562
    __cil_tmp31 = psf_ftell(psf);
#line 562
    pchk4_store(& paiff->chunk4, (int )marker, __cil_tmp31 - 8L, (sf_count_t )dword);
    }
#line 563
    if (dword == 0U) {
#line 564
      goto switch_break;
    }
#line 565
    if (dword >= (unsigned int )((int )sizeof(psf->u.scbuf) - 1)) {
      {
#line 566
      psf_log_printf(psf, " %M : %d (too big)\n", marker, dword);
      }
#line 567
      return (29);
    }
    {
#line 570
    cptr = (char *)psf->u.cbuf;
#line 571
    psf_binheader_readf(psf, "b", cptr, dword + (dword & 1U));
#line 572
    *(cptr + dword) = (char )0;
#line 573
    psf_log_printf(psf, " %M : %s\n", marker, cptr);
#line 574
    psf_store_string(psf, 4, (char const   *)cptr);
    }
#line 575
    goto switch_break;
    case_exp___7: /* CIL Label */ 
    {
#line 581
    psf_binheader_readf(psf, "E42", & dword, & count);
#line 582
    __cil_tmp36 = psf_ftell(psf);
#line 582
    pchk4_store(& paiff->chunk4, (int )marker, __cil_tmp36 - 8L, (sf_count_t )dword);
#line 583
    psf_log_printf(psf, " %M : %d\n  count  : %d\n", marker, dword, (int )count);
#line 584
    dword += dword & 1U;
    }
#line 585
    if (dword == 0U) {
#line 586
      goto switch_break;
    }
#line 587
    dword -= (unsigned int )2;
#line 589
    k = 0;
    {
#line 589
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 589
      if (! (k < (int )count)) {
#line 589
        goto while_break___1;
      }
      {
#line 590
      __cil_tmp37 = psf_binheader_readf(psf, "E422", & timestamp, & id, & len);
      }
      {
#line 590
      dword -= (unsigned int )__cil_tmp37;
#line 591
      psf_log_printf(psf, "   time   : 0x%x\n   marker : %x\n   length : %d\n", timestamp,
                     (int )id, (int )len);
      }
#line 593
      if ((int )len + 1 > (int )sizeof(psf->u.scbuf)) {
        {
#line 594
        psf_log_printf(psf, "\nError : string length (%d) too big.\n", (int )len);
        }
#line 595
        return (29);
      }
      {
#line 598
      cptr = (char *)psf->u.cbuf;
#line 599
      __cil_tmp38 = psf_binheader_readf(psf, "b", cptr, (int )len);
      }
      {
#line 599
      dword -= (unsigned int )__cil_tmp38;
#line 600
      *(cptr + len) = (char )0;
#line 601
      psf_log_printf(psf, "   string : %s\n", cptr);
      }
#line 589
      k ++;
    }
    while_break___1: /* CIL Label */ ;
    }

#line 604
    if (dword > 0U) {
      {
#line 605
      psf_binheader_readf(psf, "j", dword);
      }
    }

#line 607
    goto switch_break;
    case_exp___8: /* CIL Label */ 
    {
#line 612
    psf_binheader_readf(psf, "E4", & dword);
#line 613
    __cil_tmp41 = psf_ftell(psf);
#line 613
    pchk4_store(& paiff->chunk4, (int )marker, __cil_tmp41 - 8L, (sf_count_t )dword);
    }
#line 614
    if (dword == 0U) {
#line 615
      goto switch_break;
    }
#line 616
    if (dword >= (unsigned int )((int )sizeof(psf->u.scbuf) - 1)) {
      {
#line 617
      psf_log_printf(psf, " %M : %d (too big, skipping)\n", marker, dword);
#line 618
      psf_binheader_readf(psf, "j", dword + (dword & 1U));
      }
#line 619
      goto switch_break;
    }

#line 622
    if (dword < 4U) {
      {
#line 623
      psf_log_printf(psf, " %M : %d (too small, skipping)\n", marker, dword);
#line 624
      psf_binheader_readf(psf, "j", dword + (dword & 1U));
      }
#line 625
      goto switch_break;
    }
    {
#line 628
    cptr = (char *)psf->u.cbuf;
#line 629
    psf_binheader_readf(psf, "mb", & appl_marker, cptr, (dword + (dword & 1U)) - 4U);
#line 630
    *(cptr + dword) = (char )0;
#line 632
    k = 0;
    }
    {
#line 632
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 632
      if (! (k < (int )dword)) {
#line 632
        goto while_break___2;
      }
      {
#line 633
      __cil_tmp42 = __ctype_b_loc();
      }
#line 633
      if (! ((int )*(*__cil_tmp42 + (int )*(cptr + k)) & 16384)) {
#line 634
        *(cptr + k) = (char )0;
#line 635
        goto while_break___2;
      }
#line 632
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 638
    psf_log_printf(psf, " %M : %d\n  AppSig : %M\n  Name   : %s\n", marker, dword,
                   appl_marker, cptr);
#line 639
    psf_store_string(psf, 3, (char const   *)cptr);
    }
#line 641
    goto switch_break;
    case_exp___9: /* CIL Label */ 
    {
#line 644
    psf_binheader_readf(psf, "E4", & dword);
    }
    {
#line 645
    __cil_tmp44 = psf_ftell(psf);
#line 645
    pchk4_store(& paiff->chunk4, (int )marker, __cil_tmp44 - 8L, (sf_count_t )dword);
    }
#line 646
    if (dword == 0U) {
#line 647
      goto switch_break;
    }
#line 648
    if (dword >= (unsigned int )((int )sizeof(psf->u.scbuf) - 2)) {
      {
#line 649
      psf_log_printf(psf, " %M : %d (too big)\n", marker, dword);
      }
#line 650
      return (29);
    }
    {
#line 653
    cptr = (char *)psf->u.cbuf;
#line 654
    psf_binheader_readf(psf, "b", cptr, dword + (dword & 1U));
#line 655
    *(cptr + dword) = (char )0;
#line 656
    psf_log_printf(psf, " %M : %s\n", marker, cptr);
#line 657
    psf_store_string(psf, 1, (char const   *)cptr);
    }
#line 658
    goto switch_break;
    case_exp___10: /* CIL Label */ 
    {
#line 661
    psf_binheader_readf(psf, "E4", & dword);
    }
    {
#line 662
    __cil_tmp45 = psf_ftell(psf);
#line 662
    pchk4_store(& paiff->chunk4, (int )marker, __cil_tmp45 - 8L, (sf_count_t )dword);
    }
#line 663
    if (dword == 0U) {
#line 664
      goto switch_break;
    }
#line 665
    if (dword >= (unsigned int )((int )sizeof(psf->u.scbuf) - 2)) {
      {
#line 666
      psf_log_printf(psf, " %M : %d (too big)\n", marker, dword);
      }
#line 667
      return (29);
    }
    {
#line 670
    cptr = (char *)psf->u.cbuf;
#line 671
    psf_binheader_readf(psf, "b", cptr, dword + (dword & 1U));
#line 672
    *(cptr + dword) = (char )0;
#line 673
    psf_log_printf(psf, " %M : %s\n", marker, cptr);
#line 674
    psf_store_string(psf, 5, (char const   *)cptr);
    }
#line 675
    goto switch_break;
    case_exp___11: /* CIL Label */ 
    {
#line 678
    psf_binheader_readf(psf, "E4", & dword);
    }
    {
#line 679
    __cil_tmp46 = psf_ftell(psf);
#line 679
    pchk4_store(& paiff->chunk4, (int )marker, __cil_tmp46 - 8L, (sf_count_t )dword);
    }
#line 680
    if (dword != 20U) {
      {
#line 681
      psf_log_printf(psf, " %M : %d (should be %d)\n\230\001", marker, dword, 20);
#line 682
      psf_binheader_readf(psf, "j", dword);
      }
#line 683
      goto switch_break;
    }
    {
#line 685
    psf_log_printf(psf, " %M : %d\n", marker, dword);
#line 689
    psf->instrument = psf_instrument_alloc();
    }
#line 689
    if (psf->instrument == (void *)0) {
#line 689
      if (psf->instrument == (void *)0) {
#line 690
        return (16);
      }
    }
    {
#line 692
    psf_binheader_readf(psf, "b", (unsigned char *)bytes, 6);
#line 693
    psf_log_printf(psf, "  Base Note : %u\n  Detune    : %u\n  Low  Note : %u\n  High Note : %u\n  Low  Vel. : %u\n  High Vel. : %u\n",
                   (int )bytes[0], (int )bytes[1], (int )bytes[2], (int )bytes[3],
                   (int )bytes[4], (int )bytes[5]);
#line 697
    (psf->instrument)->basenote = (char )bytes[0];
#line 698
    (psf->instrument)->detune = (char )bytes[1];
#line 699
    (psf->instrument)->key_lo = (char )bytes[2];
#line 700
    (psf->instrument)->key_hi = (char )bytes[3];
#line 701
    (psf->instrument)->velocity_lo = (char )bytes[4];
#line 702
    (psf->instrument)->velocity_hi = (char )bytes[5];
#line 703
    psf_binheader_readf(psf, "E2", & gain);
#line 704
    (psf->instrument)->gain = (int )gain;
#line 705
    psf_log_printf(psf, "  Gain (dB) : %d\n", (int )gain);
#line 711
    psf_binheader_readf(psf, "E222", & mode, & begin, & end);
#line 712
    loop_mode = get_loop_mode_str(mode);
#line 713
    mode = get_loop_mode(mode);
    }
#line 714
    if ((int )mode == 800) {
#line 715
      (psf->instrument)->loop_count = 0;
#line 716
      (psf->instrument)->loops[0].mode = 800;
    } else {
#line 719
      (psf->instrument)->loop_count = 1;
#line 720
      (psf->instrument)->loops[0].mode = 801;
#line 721
      (psf->instrument)->loops[0].start = (unsigned int )begin;
#line 722
      (psf->instrument)->loops[0].end = (unsigned int )end;
#line 723
      (psf->instrument)->loops[0].count = (unsigned int )0;
    }
    {
#line 725
    psf_log_printf(psf, "  Sustain\n   mode  : %d => %s\n   begin : %u\n   end   : %u\n",
                   (int )mode, loop_mode, (int )begin, (int )end);
#line 727
    psf_binheader_readf(psf, "E222", & mode, & begin, & end);
#line 728
    loop_mode = get_loop_mode_str(mode);
#line 729
    mode = get_loop_mode(mode);
    }
#line 730
    if ((int )mode == 800) {
#line 731
      (psf->instrument)->loops[1].mode = 800;
    } else {
#line 733
      ((psf->instrument)->loop_count) ++;
#line 734
      (psf->instrument)->loops[1].mode = 801;
#line 735
      (psf->instrument)->loops[1].start = (unsigned int )begin;
#line 736
      (psf->instrument)->loops[1].end = (unsigned int )end;
#line 737
      (psf->instrument)->loops[1].count = (unsigned int )0;
    }
    {
#line 739
    psf_log_printf(psf, "  Release\n   mode  : %d => %s\n   begin : %u\n   end   : %u\n",
                   (int )mode, loop_mode, (int )begin, (int )end);
#line 742
    instr_found ++;
    }
#line 743
    goto switch_break;
    case_exp___12: /* CIL Label */ 
    {
#line 746
    psf_binheader_readf(psf, "E4", & dword);
    }
    {
#line 747
    __cil_tmp59 = psf_ftell(psf);
#line 747
    pchk4_store(& paiff->chunk4, (int )marker, __cil_tmp59 - 8L, (sf_count_t )dword);
#line 748
    psf_log_printf(psf, " basc : %u\n", dword);
#line 750
    error = aiff_read_basc_chunk(psf, (int )dword);
    }
#line 750
    if (error) {
#line 751
      return (error);
    }
#line 752
    goto switch_break;
    case_exp___13: /* CIL Label */ 
    {
#line 755
    psf_binheader_readf(psf, "E4", & dword);
    }
    {
#line 756
    __cil_tmp61 = psf_ftell(psf);
#line 756
    pchk4_store(& paiff->chunk4, (int )marker, __cil_tmp61 - 8L, (sf_count_t )dword);
#line 757
    psf_log_printf(psf, " %M : %d\n", marker, dword);
#line 758
    n = (unsigned short )0;
#line 761
    __cil_tmp65 = psf_binheader_readf(psf, "E2", & n);
#line 761
    bytesread = (unsigned int )__cil_tmp65;
#line 762
    mark_count = (int )n;
#line 763
    psf_log_printf(psf, "  Count : %d\n", mark_count);
    }
#line 764
    if (paiff->markstr != (void *)0) {
      {
#line 765
      psf_log_printf(psf, "*** Second MARK chunk found. Throwing away the first.\n");
#line 766
      free(paiff->markstr);
      }
    }
    {
#line 768
    paiff->markstr = (MARK_ID_POS *)calloc((unsigned long )mark_count, sizeof(MARK_ID_POS ));
    }
#line 769
    if (paiff->markstr == (void *)0) {
#line 770
      return (16);
    }
#line 772
    n = (unsigned short )0;
    {
#line 772
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 772
      if (! ((int )n < mark_count && bytesread < dword)) {
#line 772
        goto while_break___3;
      }
      {
#line 776
      __cil_tmp69 = psf_binheader_readf(psf, "E241", & mark_id, & position___0, & ch);
      }
      {
#line 776
      bytesread += (unsigned int )__cil_tmp69;
#line 777
      psf_log_printf(psf, "   Mark ID  : %u\n   Position : %u\n", (int )mark_id, position___0);
      }
#line 779
      if ((int )ch & 1) {
#line 779
        tmp___1 = (int )ch;
      } else {
#line 779
        tmp___1 = (int )ch + 1;
      }
#line 779
      pstr_len = (unsigned int )tmp___1;
#line 781
      if ((unsigned long )pstr_len < sizeof(psf->u.scbuf) - 1UL) {
        {
#line 782
        __cil_tmp71 = psf_binheader_readf(psf, "b", (signed char *)psf->u.scbuf, pstr_len);
        }
#line 782
        bytesread += (unsigned int )__cil_tmp71;
#line 783
        psf->u.scbuf[pstr_len] = (signed char )0;
      } else {
        {
#line 786
        read_len = (unsigned int )((unsigned long )pstr_len - (sizeof(psf->u.scbuf) - 1UL));
#line 787
        __cil_tmp73 = psf_binheader_readf(psf, "bj", (signed char *)psf->u.scbuf,
                                          read_len, pstr_len - read_len);
        }
#line 787
        bytesread += (unsigned int )__cil_tmp73;
#line 788
        psf->u.scbuf[sizeof(psf->u.scbuf) - 1UL] = (signed char )0;
      }
      {
#line 791
      psf_log_printf(psf, "   Name     : %s\n", (signed char *)psf->u.scbuf);
#line 793
      (paiff->markstr + n)->markerID = mark_id;
#line 794
      (paiff->markstr + n)->position = position___0;
      }
#line 772
      n ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 803
    mark_found ++;
#line 804
    psf_binheader_readf(psf, "j", dword - bytesread);
    }
#line 805
    goto switch_break;
    case_exp___14: /* CIL Label */ 
#line 808
    found_chunk |= 8;
    case_exp___15: /* CIL Label */ 
    {
#line 812
    psf_binheader_readf(psf, "E4", & dword);
    }
    {
#line 813
    __cil_tmp76 = psf_ftell(psf);
#line 813
    pchk4_store(& paiff->chunk4, (int )marker, __cil_tmp76 - 8L, (sf_count_t )dword);
#line 814
    psf_log_printf(psf, " %M : %d\n", marker, dword);
#line 816
    psf_binheader_readf(psf, "j", dword);
    }
#line 817
    goto switch_break;
    case_exp___16: /* CIL Label */ 
    {
#line 821
    psf_binheader_readf(psf, "1", & byte);
    }
    {
#line 822
    dword = (unsigned int )byte;
#line 823
    psf_binheader_readf(psf, "j", dword);
    }
#line 824
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 827
    __cil_tmp80 = __ctype_b_loc();
    }
    {
#line 827
    __cil_tmp79 = __ctype_b_loc();
    }
    {
#line 827
    __cil_tmp78 = __ctype_b_loc();
    }
    {
#line 827
    __cil_tmp77 = __ctype_b_loc();
    }
#line 827
    if ((int )*(*__cil_tmp77 + (int )((marker >> 24) & 255U)) & 16384) {
#line 827
      if ((int )*(*__cil_tmp78 + (int )((marker >> 16) & 255U)) & 16384) {
#line 827
        if ((int )*(*__cil_tmp79 + (int )((marker >> 8) & 255U)) & 16384) {
#line 827
          if ((int )*(*__cil_tmp80 + (int )(marker & 255U)) & 16384) {
            {
#line 829
            psf_binheader_readf(psf, "E4", & dword);
#line 830
            psf_log_printf(psf, " %M : %d (unknown marker)\n", marker, dword);
#line 832
            psf_binheader_readf(psf, "j", dword);
            }
#line 833
            goto switch_break;
          }
        }
      }
    }
    {
#line 835
    __cil_tmp81 = psf_ftell(psf);
#line 835
    dword = (unsigned int )__cil_tmp81;
    }
#line 835
    if (dword & 3U) {
      {
#line 836
      psf_log_printf(psf, "  Unknown chunk marker %X at position %d. Resyncing.\n",
                     marker, dword - 4U);
#line 838
      psf_binheader_readf(psf, "j", - 3);
      }
#line 839
      goto switch_break;
    }
    {
#line 841
    __cil_tmp82 = psf_ftell(psf);
#line 841
    psf_log_printf(psf, "*** Unknown chunk marker %X at position %D. Exiting parser.\n",
                   marker, __cil_tmp82);
#line 842
    done = 1;
    }
#line 843
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }

#line 846
    if (! psf->sf.seekable) {
#line 846
      if (found_chunk & 32) {
#line 847
        goto while_break;
      }
    }
    {
#line 849
    __cil_tmp83 = psf_ftell(psf);
    }
#line 849
    if (__cil_tmp83 >= psf->filelength - (long )(2 * (int )sizeof(dword))) {
#line 850
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 853
  if (instr_found) {
#line 853
    if (mark_found) {
#line 856
      j = 0;
      {
#line 856
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 856
        if (! (j < (psf->instrument)->loop_count)) {
#line 856
          goto while_break___4;
        }
#line 857
        if (j < (int )(sizeof((psf->instrument)->loops) / sizeof((psf->instrument)->loops[0]))) {
          {
#line 858
          (psf->instrument)->loops[j].start = marker_to_position(paiff->markstr, (unsigned short )(psf->instrument)->loops[j].start,
                                                                 mark_count);
#line 859
          (psf->instrument)->loops[j].end = marker_to_position(paiff->markstr, (unsigned short )(psf->instrument)->loops[j].end,
                                                               mark_count);
#line 860
          (psf->instrument)->loops[j].mode = 801;
          }
        }

#line 856
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }

    }
  }

#line 865
  if (! (found_chunk & 1)) {
#line 866
    return (74);
  }
#line 868
  if (! (found_chunk & 2)) {
#line 869
    return (76);
  }
#line 871
  if (! (found_chunk & 16)) {
#line 872
    return (77);
  }
#line 874
  if (! psf->dataoffset) {
#line 875
    return (84);
  }
#line 877
  return (0);
}
}
#line 881 "/root/libsndfile/src/aiff.c"
static int aiff_close(SF_PRIVATE *psf ) 
{ 
  AIFF_PRIVATE *paiff ;

  {
#line 882
  paiff = psf->container_data;
#line 884
  if (paiff != (void *)0) {
#line 884
    if (paiff->markstr != (void *)0) {
      {
#line 885
      free(paiff->markstr);
#line 886
      paiff->markstr = (MARK_ID_POS *)((void *)0);
      }
    }
  }

#line 889
  if (psf->mode == 32) {
    {
    {
#line 890
    aiff_write_tailer(psf);
    }
    {
#line 891
    aiff_write_header(psf, 1);
    }
    }
  } else
#line 889
  if (psf->mode == 48) {
    {
    {
#line 890
    aiff_write_tailer(psf);
    }
    {
#line 891
    aiff_write_header(psf, 1);
    }
    }
  }

#line 894
  return (0);
}
}
#line 898 "/root/libsndfile/src/aiff.c"
static int aiff_read_comm_chunk(SF_PRIVATE *psf , COMM_CHUNK *comm_fmt ) 
{ 
  int error ;
  int bytesread ;
  int subformat ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  __uint32_t __cil_tmp8 ;
  int __cil_tmp9 ;
  unsigned char encoding_len ;
  unsigned int read_len ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  char const   *tmp ;
  int __cil_tmp16 ;

  {
  {
#line 899
  error = 0;
#line 901
  psf->u.scbuf[0] = (signed char )0;
#line 903
  bytesread = psf_binheader_readf(psf, "E4", & comm_fmt->size);
#line 909
  comm_fmt->size += comm_fmt->size & 1U;
#line 911
  __cil_tmp7 = psf_binheader_readf(psf, "E242bV", & comm_fmt->numChannels, & comm_fmt->numSampleFrames,
                                   & comm_fmt->sampleSize, & comm_fmt->sampleRate,
                                   (int )sizeof(comm_fmt->sampleRate));
  }
#line 911
  bytesread += __cil_tmp7;
#line 915
  if (comm_fmt->size > 65536U) {
#line 915
    if ((comm_fmt->size & 65535U) == 0U) {
      {
#line 916
      psf_log_printf(psf, " COMM : %d (0x%x) *** should be \230\001", comm_fmt->size,
                     comm_fmt->size);
#line 917
      __cil_tmp8 = __bswap_32(comm_fmt->size);
#line 917
      comm_fmt->size = (unsigned int )((int )__cil_tmp8);
#line 918
      psf_log_printf(psf, "%d (0x%x)\n", comm_fmt->size, comm_fmt->size);
      }
    } else {
      {
      {
#line 921
      psf_log_printf(psf, " COMM : %d\n\375\036V", comm_fmt->size);
      }
      }
    }
  } else {
    {
    {
#line 921
    psf_log_printf(psf, " COMM : %d\n\375\036V", comm_fmt->size);
    }
    }
  }
#line 923
  if (comm_fmt->size == 18U) {
#line 924
    comm_fmt->encoding = (unsigned int )(((78 | (79 << 8)) | (78 << 16)) | (69 << 24));
  } else
#line 925
  if (comm_fmt->size == 22U) {
    {
#line 926
    __cil_tmp9 = psf_binheader_readf(psf, "Em\334\375\036V", & comm_fmt->encoding);
    }
#line 926
    bytesread += __cil_tmp9;
  } else
#line 927
  if (comm_fmt->size >= 24U) {
    {
#line 931
    __cil_tmp12 = psf_binheader_readf(psf, "Em1\375\036V", & comm_fmt->encoding, & encoding_len);
    }
    {
#line 931
    bytesread += __cil_tmp12;
#line 933
    comm_fmt->size = (unsigned int )0;
#line 934
    memset((signed char *)psf->u.scbuf, 0, (unsigned long )comm_fmt->size);
#line 935
    read_len = (comm_fmt->size - 24U) + 1U;
#line 936
    __cil_tmp13 = psf_binheader_readf(psf, "b", (signed char *)psf->u.scbuf, read_len);
    }
#line 936
    bytesread += __cil_tmp13;
#line 937
    psf->u.scbuf[read_len + 1U] = (signed char )0;
  }
  {
#line 940
  __cil_tmp14 = tenbytefloat2int((unsigned char *)comm_fmt->sampleRate);
#line 940
  psf_log_printf(psf, "  Sample Rate : %d\n", __cil_tmp14);
  }
#line 941
  if (comm_fmt->numSampleFrames == 0U && psf->filelength > 104L) {
#line 941
    tmp = " (Should not be 0)";
  } else {
#line 941
    tmp = "\220";
  }
  {
#line 941
  psf_log_printf(psf, "  Frames      : %u%s\nV", comm_fmt->numSampleFrames, tmp);
#line 942
  psf_log_printf(psf, "  Channels    : %d\n", (int )comm_fmt->numChannels);
  }
#line 945
  if (comm_fmt->encoding == (unsigned int )(((102 | (108 << 8)) | (51 << 16)) | (50 << 24))) {
    _L___45: /* CIL Label */ 
#line 945
    if ((int )comm_fmt->sampleSize != 32) {
      {
#line 946
      psf_log_printf(psf, "  Sample Size : %d (should be 32)\n", (int )comm_fmt->sampleSize);
#line 947
      comm_fmt->sampleSize = (short )32;
      }
    } else {
#line 945
      goto _L___44;
    }
  } else
#line 945
  if (comm_fmt->encoding == (unsigned int )(((70 | (76 << 8)) | (51 << 16)) | (50 << 24))) {
#line 945
    goto _L___45;
  } else
  _L___44: /* CIL Label */ 
#line 949
  if (comm_fmt->encoding == (unsigned int )(((102 | (108 << 8)) | (54 << 16)) | (52 << 24))) {
    _L: /* CIL Label */ 
#line 949
    if ((int )comm_fmt->sampleSize != 64) {
      {
#line 950
      psf_log_printf(psf, "  Sample Size : %d (should be 64)\n\334\375\036V", (int )comm_fmt->sampleSize);
#line 951
      comm_fmt->sampleSize = (short )64;
      }
    } else {
      {
      {
#line 954
      psf_log_printf(psf, "  Sample Size : %d\n\375\036V", (int )comm_fmt->sampleSize);
      }
      }
    }
  } else
#line 949
  if (comm_fmt->encoding == (unsigned int )(((70 | (76 << 8)) | (54 << 16)) | (52 << 24))) {
#line 949
    goto _L;
  } else {
    {
    {
#line 954
    psf_log_printf(psf, "  Sample Size : %d\n\375\036V", (int )comm_fmt->sampleSize);
    }
    }
  }
  {
#line 956
  subformat = s_bitwidth_to_subformat((int )comm_fmt->sampleSize);
#line 958
  psf->endian = 536870912;
  }
  {
#line 961
  if (comm_fmt->encoding == (unsigned int )(((78 | (79 << 8)) | (78 << 16)) | (69 << 24))) {
#line 961
    goto case_exp;
  }
#line 967
  if (comm_fmt->encoding == (unsigned int )(((105 | (110 << 8)) | (51 << 16)) | (50 << 24))) {
#line 967
    goto case_exp___0;
  }
#line 967
  if (comm_fmt->encoding == (unsigned int )(((105 | (110 << 8)) | (50 << 16)) | (52 << 24))) {
#line 967
    goto case_exp___0;
  }
#line 967
  if (comm_fmt->encoding == (unsigned int )(((116 | (119 << 8)) | (111 << 16)) | (115 << 24))) {
#line 967
    goto case_exp___0;
  }
#line 973
  if (comm_fmt->encoding == (unsigned int )(((50 | (51 << 8)) | (110 << 16)) | (105 << 24))) {
#line 973
    goto case_exp___3;
  }
#line 973
  if (comm_fmt->encoding == (unsigned int )(((52 | (50 << 8)) | (110 << 16)) | (49 << 24))) {
#line 973
    goto case_exp___3;
  }
#line 973
  if (comm_fmt->encoding == (unsigned int )(((115 | (111 << 8)) | (119 << 16)) | (116 << 24))) {
#line 973
    goto case_exp___3;
  }
#line 979
  if (comm_fmt->encoding == (unsigned int )(((70 | (76 << 8)) | (51 << 16)) | (50 << 24))) {
#line 979
    goto case_exp___6;
  }
#line 979
  if (comm_fmt->encoding == (unsigned int )(((102 | (108 << 8)) | (51 << 16)) | (50 << 24))) {
#line 979
    goto case_exp___6;
  }
#line 984
  if (comm_fmt->encoding == (unsigned int )(((85 | (76 << 8)) | (65 << 16)) | (87 << 24))) {
#line 984
    goto case_exp___8;
  }
#line 984
  if (comm_fmt->encoding == (unsigned int )(((117 | (108 << 8)) | (97 << 16)) | (119 << 24))) {
#line 984
    goto case_exp___8;
  }
#line 989
  if (comm_fmt->encoding == (unsigned int )(((65 | (76 << 8)) | (65 << 16)) | (87 << 24))) {
#line 989
    goto case_exp___10;
  }
#line 989
  if (comm_fmt->encoding == (unsigned int )(((97 | (108 << 8)) | (97 << 16)) | (119 << 24))) {
#line 989
    goto case_exp___10;
  }
#line 994
  if (comm_fmt->encoding == (unsigned int )(((70 | (76 << 8)) | (54 << 16)) | (52 << 24))) {
#line 994
    goto case_exp___12;
  }
#line 994
  if (comm_fmt->encoding == (unsigned int )(((102 | (108 << 8)) | (54 << 16)) | (52 << 24))) {
#line 994
    goto case_exp___12;
  }
#line 998
  if (comm_fmt->encoding == (unsigned int )(((114 | (97 << 8)) | (119 << 16)) | (32 << 24))) {
#line 998
    goto case_exp___14;
  }
#line 1002
  if (comm_fmt->encoding == (unsigned int )(((68 | (87 << 8)) | (86 << 16)) | (87 << 24))) {
#line 1002
    goto case_exp___15;
  }
#line 1005
  if (comm_fmt->encoding == 12) {
#line 1005
    goto case_12;
  }
#line 1008
  if (comm_fmt->encoding == 16) {
#line 1008
    goto case_16;
  }
#line 1011
  if (comm_fmt->encoding == 24) {
#line 1011
    goto case_24;
  }
#line 1021
  if (comm_fmt->encoding == (unsigned int )(((71 | (83 << 8)) | (77 << 16)) | (32 << 24))) {
#line 1021
    goto case_exp___16;
  }
#line 1027
  if (comm_fmt->encoding == (unsigned int )(((105 | (109 << 8)) | (97 << 16)) | (52 << 24))) {
#line 1027
    goto case_exp___17;
  }
#line 1032
  goto switch_default___0;
  case_exp: /* CIL Label */ 
#line 962
  psf->sf.format = 131072 | subformat;
#line 963
  goto switch_break;
  case_exp___0: /* CIL Label */ 
  case_exp___1: /* CIL Label */ 
  case_exp___2: /* CIL Label */ 
#line 968
  psf->sf.format = 537001984 | subformat;
#line 969
  goto switch_break;
  case_exp___3: /* CIL Label */ 
  case_exp___4: /* CIL Label */ 
  case_exp___5: /* CIL Label */ 
#line 974
  psf->endian = 268435456;
#line 975
  psf->sf.format = 268566528 | subformat;
#line 976
  goto switch_break;
  case_exp___6: /* CIL Label */ 
  case_exp___7: /* CIL Label */ 
#line 980
  psf->sf.format = 131078;
#line 981
  goto switch_break;
  case_exp___8: /* CIL Label */ 
  case_exp___9: /* CIL Label */ 
#line 985
  psf->sf.format = 131088;
#line 986
  goto switch_break;
  case_exp___10: /* CIL Label */ 
  case_exp___11: /* CIL Label */ 
#line 990
  psf->sf.format = 131089;
#line 991
  goto switch_break;
  case_exp___12: /* CIL Label */ 
  case_exp___13: /* CIL Label */ 
#line 995
  psf->sf.format = 131079;
#line 996
  goto switch_break;
  case_exp___14: /* CIL Label */ 
#line 999
  psf->sf.format = 131077;
#line 1000
  goto switch_break;
  case_exp___15: /* CIL Label */ 
#line 1003
  psf->sf.format = 131072;
  {
#line 1005
  if ((int )comm_fmt->sampleSize == 12) {
#line 1005
    goto case_12;
  }
#line 1008
  if ((int )comm_fmt->sampleSize == 16) {
#line 1008
    goto case_16;
  }
#line 1011
  if ((int )comm_fmt->sampleSize == 24) {
#line 1011
    goto case_24;
  }
#line 1015
  goto switch_default;
  case_12: /* CIL Label */ 
#line 1006
  psf->sf.format |= 64;
#line 1007
  goto switch_break___0;
  case_16: /* CIL Label */ 
#line 1009
  psf->sf.format |= 65;
#line 1010
  goto switch_break___0;
  case_24: /* CIL Label */ 
#line 1012
  psf->sf.format |= 66;
#line 1013
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 1016
  psf->sf.format |= 67;
#line 1017
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }

#line 1019
  goto switch_break;
  case_exp___16: /* CIL Label */ 
#line 1022
  psf->sf.format = 131072;
#line 1023
  psf->sf.format = 131104;
#line 1024
  goto switch_break;
  case_exp___17: /* CIL Label */ 
#line 1028
  psf->endian = 536870912;
#line 1029
  psf->sf.format = 131090;
#line 1030
  goto switch_break;
  switch_default___0: /* CIL Label */ 
  {
#line 1033
  psf_log_printf(psf, "AIFC : Unimplemented format : %M\nw\333\375\036V", comm_fmt->encoding);
  }
#line 1034
  error = 17;
  switch_break: /* CIL Label */ ;
  }

#line 1037
  if (! psf->u.scbuf[0]) {
    {
#line 1038
    psf_log_printf(psf, "  Encoding    : %M\n", comm_fmt->encoding);
    }
  } else {
    {
#line 1040
    psf_log_printf(psf, "  Encoding    : %M => %s\no\333\375\036V", comm_fmt->encoding,
                   (signed char *)psf->u.scbuf);
    }
  }
#line 1042
  return (error);
}
}
#line 1050 "/root/libsndfile/src/aiff.c"
static int aiff_rewrite_header(SF_PRIVATE *psf , AIFF_PRIVATE *paiff ) 
{ 
  int k ;
  int ch ;
  int comm_size ;
  int comm_frames ;
  time_t __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 1060
  psf_fseek(psf, (sf_count_t )0, 0);
#line 1061
  psf_fread((unsigned char *)psf->header, psf->dataoffset, (sf_count_t )1, psf);
#line 1063
  psf->headindex = 0;
#line 1065
  k = 0;
  }
  {
#line 1065
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1065
    if (! (k < paiff->chunk4.count)) {
#line 1065
      goto while_break;
    }
    {
#line 1067
    if (paiff->chunk4.l[k].chunk == (((70 | (79 << 8)) | (82 << 16)) | (77 << 24))) {
#line 1067
      goto case_exp;
    }
#line 1071
    if (paiff->chunk4.l[k].chunk == (((67 | (79 << 8)) | (77 << 16)) | (77 << 24))) {
#line 1071
      goto case_exp___0;
    }
#line 1078
    if (paiff->chunk4.l[k].chunk == (((83 | (83 << 8)) | (78 << 16)) | (68 << 24))) {
#line 1078
      goto case_exp___1;
    }
#line 1083
    if (paiff->chunk4.l[k].chunk == (((80 | (69 << 8)) | (65 << 16)) | (75 << 24))) {
#line 1083
      goto case_exp___2;
    }
#line 1091
    goto switch_default;
    case_exp: /* CIL Label */ 
    {
#line 1068
    psf_binheader_writef(psf, "Etm8", ((70 | (79 << 8)) | (82 << 16)) | (77 << 24),
                         psf->filelength - 8L);
    }
#line 1069
    goto switch_break;
    case_exp___0: /* CIL Label */ 
#line 1072
    psf->headindex = (int )paiff->chunk4.l[k].offset;
    {
#line 1073
    comm_frames = (int )psf->sf.frames;
#line 1074
    comm_size = (int )paiff->chunk4.l[k].len;
#line 1075
    psf_binheader_writef(psf, "Em42t4", ((67 | (79 << 8)) | (77 << 16)) | (77 << 24),
                         comm_size, psf->sf.channels, comm_frames);
    }
#line 1076
    goto switch_break;
    case_exp___1: /* CIL Label */ 
#line 1079
    psf->headindex = (int )paiff->chunk4.l[k].offset;
    {
#line 1080
    psf_binheader_writef(psf, "Etm8\036V", ((83 | (83 << 8)) | (78 << 16)) | (68 << 24),
                         psf->datalength + 8L);
    }
#line 1081
    goto switch_break;
    case_exp___2: /* CIL Label */ 
#line 1084
    psf->headindex = (int )paiff->chunk4.l[k].offset;
    {
#line 1085
    psf_binheader_writef(psf, "Em4", ((80 | (69 << 8)) | (65 << 16)) | (75 << 24),
                         2UL * sizeof(int ) + (unsigned long )psf->sf.channels * (sizeof(float ) + sizeof(int )));
#line 1086
    __cil_tmp7 = time((time_t *)((void *)0));
#line 1086
    psf_binheader_writef(psf, "E44\375\036V", 1, __cil_tmp7);
#line 1087
    ch = 0;
    }
    {
#line 1087
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1087
      if (! (ch < psf->sf.channels)) {
#line 1087
        goto while_break___0;
      }
      {
#line 1088
      psf_binheader_writef(psf, "Eft8", (double )((float )(psf->peak_info)->peaks[ch].value),
                           (psf->peak_info)->peaks[ch].position);
      }
#line 1087
      ch ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1089
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1093
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }

#line 1065
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1098
  psf_fseek(psf, (sf_count_t )0, 0);
#line 1099
  psf_fwrite((unsigned char *)psf->header, (sf_count_t )psf->headindex, (sf_count_t )1,
             psf);
  }
#line 1101
  return (0);
}
}
#line 1105 "/root/libsndfile/src/aiff.c"
static int aiff_write_header(SF_PRIVATE *psf , int calc_length ) 
{ 
  sf_count_t current ;
  AIFF_PRIVATE *paiff ;
  unsigned char comm_sample_rate[10] ;
  unsigned char comm_zero_bytes[2] ;
  unsigned int comm_type ;
  unsigned int comm_size ;
  unsigned int comm_encoding ;
  unsigned int comm_frames ;
  int k ;
  int endian ;
  int has_data ;
  short bit_width ;
  sf_count_t __cil_tmp15 ;
  sf_count_t __cil_tmp16 ;
  int err ;
  int __cil_tmp18 ;
  long tmp ;
  MARK_ID_POS m[4] ;
  INST_CHUNK ch ;
  unsigned short ct ;
  unsigned short __cil_tmp23 ;
  unsigned short __cil_tmp24 ;
  unsigned short __cil_tmp25 ;
  unsigned short __cil_tmp26 ;
  size_t __cil_tmp27 ;
  size_t __cil_tmp28 ;
  size_t __cil_tmp29 ;
  size_t __cil_tmp30 ;
  size_t __cil_tmp31 ;
  size_t __cil_tmp32 ;
  time_t __cil_tmp33 ;
  int __cil_tmp34 ;

  {
#line 1108
  comm_zero_bytes[0] = (unsigned char )0;
#line 1108
  comm_zero_bytes[1] = (unsigned char )0;
#line 1109
  comm_frames = (unsigned int )0;
#line 1110
  has_data = 0;
#line 1113
  paiff = psf->container_data;
#line 1113
  if (paiff == (void *)0) {
#line 1114
    return (29);
  }
  {
#line 1116
  current = psf_ftell(psf);
  }
#line 1118
  if (current > psf->dataoffset) {
#line 1119
    has_data = 1;
  }
#line 1121
  if (calc_length) {
    {
#line 1122
    psf->filelength = psf_get_filelen(psf);
#line 1124
    psf->datalength = psf->filelength - psf->dataoffset;
    }
#line 1125
    if (psf->dataend) {
#line 1126
      psf->datalength -= psf->filelength - psf->dataend;
    }
#line 1128
    if (psf->bytewidth > 0) {
#line 1129
      psf->sf.frames = psf->datalength / (long )(psf->bytewidth * psf->sf.channels);
    }
  }

#line 1132
  if (psf->mode == 48) {
#line 1132
    if (psf->dataoffset > 0L) {
#line 1132
      if (paiff->chunk4.count > 0) {
        {
#line 1133
        __cil_tmp18 = aiff_rewrite_header(psf, paiff);
#line 1133
        err = __cil_tmp18;
        }
#line 1134
        if (current > 0L) {
          {
#line 1135
          psf_fseek(psf, current, 0);
          }
        }
#line 1136
        return (err);
      }
    }
  }
#line 1139
  endian = psf->sf.format & 805306368;
#line 1140
  if (endian == 805306368) {
#line 1141
    endian = 268435456;
  }
#line 1144
  bit_width = (short )(psf->bytewidth * 8);
#line 1145
  if (psf->sf.frames > 4294967295L) {
#line 1145
    tmp = (long )4294967295U;
  } else {
#line 1145
    tmp = psf->sf.frames;
  }
#line 1145
  comm_frames = (unsigned int )tmp;
  {
#line 1151
  if ((psf->sf.format & 65535) == 4) {
#line 1151
    goto case_4;
  }
#line 1151
  if ((psf->sf.format & 65535) == 3) {
#line 1151
    goto case_4;
  }
#line 1151
  if ((psf->sf.format & 65535) == 2) {
#line 1151
    goto case_4;
  }
#line 1151
  if ((psf->sf.format & 65535) == 1) {
#line 1151
    goto case_4;
  }
#line 1153
  if ((psf->sf.format & 65535) == 536870912) {
#line 1153
    goto case_536870912;
  }
#line 1160
  if ((psf->sf.format & 65535) == 268435456) {
#line 1160
    goto case_268435456;
  }
#line 1176
  if ((psf->sf.format & 65535) == 6) {
#line 1176
    goto case_6;
  }
#line 1183
  if ((psf->sf.format & 65535) == 7) {
#line 1183
    goto case_7;
  }
#line 1190
  if ((psf->sf.format & 65535) == 16) {
#line 1190
    goto case_16;
  }
#line 1197
  if ((psf->sf.format & 65535) == 17) {
#line 1197
    goto case_17;
  }
#line 1204
  if ((psf->sf.format & 65535) == 5) {
#line 1204
    goto case_5;
  }
#line 1211
  if ((psf->sf.format & 65535) == 64) {
#line 1211
    goto case_64;
  }
#line 1221
  if ((psf->sf.format & 65535) == 65) {
#line 1221
    goto case_65;
  }
#line 1231
  if ((psf->sf.format & 65535) == 66) {
#line 1231
    goto case_66;
  }
#line 1241
  if ((psf->sf.format & 65535) == 32) {
#line 1241
    goto case_32;
  }
#line 1251
  if ((psf->sf.format & 65535) == 18) {
#line 1251
    goto case_18;
  }
#line 1262
  goto switch_default___0;
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 1153
  if (endian == 536870912) {
#line 1153
    goto case_536870912;
  }
#line 1160
  if (endian == 268435456) {
#line 1160
    goto case_268435456;
  }
#line 1167
  goto switch_default;
  case_536870912: /* CIL Label */ 
#line 1154
  psf->endian = 536870912;
#line 1155
  comm_type = (unsigned int )(((65 | (73 << 8)) | (70 << 16)) | (67 << 24));
#line 1156
  comm_size = (unsigned int )24;
#line 1157
  comm_encoding = (unsigned int )(((116 | (119 << 8)) | (111 << 16)) | (115 << 24));
#line 1158
  goto switch_break___0;
  case_268435456: /* CIL Label */ 
#line 1161
  psf->endian = 268435456;
#line 1162
  comm_type = (unsigned int )(((65 | (73 << 8)) | (70 << 16)) | (67 << 24));
#line 1163
  comm_size = (unsigned int )24;
#line 1164
  comm_encoding = (unsigned int )(((115 | (111 << 8)) | (119 << 16)) | (116 << 24));
#line 1165
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 1168
  psf->endian = 536870912;
#line 1169
  comm_type = (unsigned int )(((65 | (73 << 8)) | (70 << 16)) | (70 << 24));
#line 1170
  comm_size = (unsigned int )18;
#line 1171
  comm_encoding = (unsigned int )0;
#line 1172
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }

#line 1174
  goto switch_break;
  case_6: /* CIL Label */ 
#line 1177
  psf->endian = 536870912;
#line 1178
  comm_type = (unsigned int )(((65 | (73 << 8)) | (70 << 16)) | (67 << 24));
#line 1179
  comm_size = (unsigned int )24;
#line 1180
  comm_encoding = (unsigned int )(((70 | (76 << 8)) | (51 << 16)) | (50 << 24));
#line 1181
  goto switch_break;
  case_7: /* CIL Label */ 
#line 1184
  psf->endian = 536870912;
#line 1185
  comm_type = (unsigned int )(((65 | (73 << 8)) | (70 << 16)) | (67 << 24));
#line 1186
  comm_size = (unsigned int )24;
#line 1187
  comm_encoding = (unsigned int )(((70 | (76 << 8)) | (54 << 16)) | (52 << 24));
#line 1188
  goto switch_break;
  case_16: /* CIL Label */ 
#line 1191
  psf->endian = 536870912;
#line 1192
  comm_type = (unsigned int )(((65 | (73 << 8)) | (70 << 16)) | (67 << 24));
#line 1193
  comm_size = (unsigned int )24;
#line 1194
  comm_encoding = (unsigned int )(((117 | (108 << 8)) | (97 << 16)) | (119 << 24));
#line 1195
  goto switch_break;
  case_17: /* CIL Label */ 
#line 1198
  psf->endian = 536870912;
#line 1199
  comm_type = (unsigned int )(((65 | (73 << 8)) | (70 << 16)) | (67 << 24));
#line 1200
  comm_size = (unsigned int )24;
#line 1201
  comm_encoding = (unsigned int )(((97 | (108 << 8)) | (97 << 16)) | (119 << 24));
#line 1202
  goto switch_break;
  case_5: /* CIL Label */ 
#line 1205
  psf->endian = 536870912;
#line 1206
  comm_type = (unsigned int )(((65 | (73 << 8)) | (70 << 16)) | (67 << 24));
#line 1207
  comm_size = (unsigned int )24;
#line 1208
  comm_encoding = (unsigned int )(((114 | (97 << 8)) | (119 << 16)) | (32 << 24));
#line 1209
  goto switch_break;
  case_64: /* CIL Label */ 
#line 1212
  psf->endian = 536870912;
#line 1213
  comm_type = (unsigned int )(((65 | (73 << 8)) | (70 << 16)) | (67 << 24));
#line 1214
  comm_size = (unsigned int )24;
#line 1215
  comm_encoding = (unsigned int )(((68 | (87 << 8)) | (86 << 16)) | (87 << 24));
#line 1218
  bit_width = (short )12;
#line 1219
  goto switch_break;
  case_65: /* CIL Label */ 
#line 1222
  psf->endian = 536870912;
#line 1223
  comm_type = (unsigned int )(((65 | (73 << 8)) | (70 << 16)) | (67 << 24));
#line 1224
  comm_size = (unsigned int )24;
#line 1225
  comm_encoding = (unsigned int )(((68 | (87 << 8)) | (86 << 16)) | (87 << 24));
#line 1228
  bit_width = (short )16;
#line 1229
  goto switch_break;
  case_66: /* CIL Label */ 
#line 1232
  psf->endian = 536870912;
#line 1233
  comm_type = (unsigned int )(((65 | (73 << 8)) | (70 << 16)) | (67 << 24));
#line 1234
  comm_size = (unsigned int )24;
#line 1235
  comm_encoding = (unsigned int )(((68 | (87 << 8)) | (86 << 16)) | (87 << 24));
#line 1238
  bit_width = (short )24;
#line 1239
  goto switch_break;
  case_32: /* CIL Label */ 
#line 1242
  psf->endian = 536870912;
#line 1243
  comm_type = (unsigned int )(((65 | (73 << 8)) | (70 << 16)) | (67 << 24));
#line 1244
  comm_size = (unsigned int )24;
#line 1245
  comm_encoding = (unsigned int )(((71 | (83 << 8)) | (77 << 16)) | (32 << 24));
#line 1248
  bit_width = (short )16;
#line 1249
  goto switch_break;
  case_18: /* CIL Label */ 
#line 1252
  psf->endian = 536870912;
#line 1253
  comm_type = (unsigned int )(((65 | (73 << 8)) | (70 << 16)) | (67 << 24));
#line 1254
  comm_size = (unsigned int )24;
#line 1255
  comm_encoding = (unsigned int )(((105 | (109 << 8)) | (97 << 16)) | (52 << 24));
#line 1258
  bit_width = (short )16;
#line 1259
  comm_frames = (unsigned int )(psf->sf.frames / 64L);
#line 1260
  goto switch_break;
  switch_default___0: /* CIL Label */ 
#line 1262
  return (1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 1266
  psf->header[0] = (unsigned char )0;
#line 1267
  psf->headindex = 0;
#line 1268
  psf_fseek(psf, (sf_count_t )0, 0);
#line 1270
  psf_binheader_writef(psf, "Etm8", ((70 | (79 << 8)) | (82 << 16)) | (77 << 24),
                       psf->filelength - 8L);
  }
#line 1273
  if (comm_type == (unsigned int )(((65 | (73 << 8)) | (70 << 16)) | (67 << 24))) {
    {
#line 1275
    psf_binheader_writef(psf, "Emm44V", comm_type, ((70 | (86 << 8)) | (69 << 16)) | (82 << 24),
                         4, 2726318400U);
    }
  } else {
    {
#line 1277
    psf_binheader_writef(psf, "Em\332\375\036V", comm_type);
    }
  }
  {
#line 1279
  paiff->comm_offset = (sf_count_t )(psf->headindex - 8);
#line 1281
  memset((unsigned char *)comm_sample_rate, 0, sizeof(comm_sample_rate));
#line 1282
  uint2tenbytefloat((unsigned int )psf->sf.samplerate, (unsigned char *)comm_sample_rate);
#line 1284
  psf_binheader_writef(psf, "Em42t42", ((67 | (79 << 8)) | (77 << 16)) | (77 << 24),
                       comm_size, psf->sf.channels, comm_frames, (int )bit_width);
#line 1285
  psf_binheader_writef(psf, "b\370\303\375\036V", (unsigned char *)comm_sample_rate,
                       sizeof(comm_sample_rate));
  }
#line 1288
  if (comm_type == (unsigned int )(((65 | (73 << 8)) | (70 << 16)) | (67 << 24))) {
    {
#line 1289
    psf_binheader_writef(psf, "mb", comm_encoding, (unsigned char *)comm_zero_bytes,
                         sizeof(comm_zero_bytes));
    }
  }
#line 1291
  if (psf->instrument != (void *)0) {
    {
#line 1294
    ct = (unsigned short )0;
#line 1296
    memset((MARK_ID_POS *)m, 0, sizeof(m));
#line 1297
    memset(& ch, 0, sizeof(ch));
#line 1299
    ch.baseNote = (psf->instrument)->basenote;
#line 1300
    ch.detune = (psf->instrument)->detune;
#line 1301
    ch.lowNote = (psf->instrument)->key_lo;
#line 1302
    ch.highNote = (psf->instrument)->key_hi;
#line 1303
    ch.lowVelocity = (psf->instrument)->velocity_lo;
#line 1304
    ch.highVelocity = (psf->instrument)->velocity_hi;
#line 1305
    ch.gain = (short )(psf->instrument)->gain;
    }
#line 1306
    if ((psf->instrument)->loops[0].mode != 800) {
#line 1307
      ch.sustain_loop.playMode = (short )1;
#line 1308
      ch.sustain_loop.beginLoop = ct;
#line 1309
      __cil_tmp23 = ct;
#line 1309
      ct ++;
#line 1309
      m[0].markerID = __cil_tmp23;
#line 1310
      m[0].position = (psf->instrument)->loops[0].start;
#line 1311
      ch.sustain_loop.endLoop = ct;
#line 1312
      __cil_tmp24 = ct;
#line 1312
      ct ++;
#line 1312
      m[1].markerID = __cil_tmp24;
#line 1313
      m[1].position = (psf->instrument)->loops[0].end;
    }

#line 1315
    if ((psf->instrument)->loops[1].mode != 800) {
#line 1316
      ch.release_loop.playMode = (short )1;
#line 1317
      ch.release_loop.beginLoop = ct;
#line 1318
      __cil_tmp25 = ct;
#line 1318
      ct ++;
#line 1318
      m[2].markerID = __cil_tmp25;
#line 1319
      m[2].position = (psf->instrument)->loops[1].start;
#line 1320
      ch.release_loop.endLoop = ct;
#line 1321
      __cil_tmp26 = ct;
#line 1321
      ct ++;
#line 1321
      m[3].markerID = __cil_tmp26;
#line 1322
      m[3].position = (psf->instrument)->loops[1].end;
    } else {
#line 1325
      ch.release_loop.playMode = (short )0;
#line 1326
      ch.release_loop.beginLoop = (unsigned short )0;
#line 1327
      ch.release_loop.endLoop = (unsigned short )0;
    }
    {
#line 1330
    psf_binheader_writef(psf, "Em4111111y\332\375\036V", ((73 | (78 << 8)) | (83 << 16)) | (84 << 24),
                         20, (int )ch.baseNote, (int )ch.detune, (int )ch.lowNote,
                         (int )ch.highNote, (int )ch.lowVelocity, (int )ch.highVelocity);
#line 1332
    psf_binheader_writef(psf, "2222222", (int )ch.gain, (int )ch.sustain_loop.playMode,
                         (int )ch.sustain_loop.beginLoop, (int )ch.sustain_loop.endLoop,
                         (int )ch.release_loop.playMode, (int )ch.release_loop.beginLoop,
                         (int )ch.release_loop.endLoop);
    }
#line 1336
    if ((int )ct == 2) {
      {
#line 1337
      __cil_tmp27 = make_size_t(9);
      }
      {
#line 1337
      __cil_tmp28 = make_size_t(9);
#line 1337
      psf_binheader_writef(psf, "Em42241b241b", ((77 | (65 << 8)) | (82 << 16)) | (75 << 24),
                           34, 2, (int )m[0].markerID, m[0].position, 8, "beg loop\230",
                           __cil_tmp27, (int )m[1].markerID, m[1].position, 8, "end loop\230",
                           __cil_tmp28);
      }
    } else
#line 1341
    if ((int )ct == 4) {
      {
#line 1342
      __cil_tmp29 = make_size_t(9);
      }
      {
#line 1342
      __cil_tmp30 = make_size_t(9);
      }
      {
#line 1342
      __cil_tmp31 = make_size_t(9);
      }
      {
#line 1342
      __cil_tmp32 = make_size_t(9);
#line 1342
      psf_binheader_writef(psf, "Em42 241b 241b 241b 241b\221", ((77 | (65 << 8)) | (82 << 16)) | (75 << 24),
                           66, 4, (int )m[0].markerID, m[0].position, 8, "beg loop\230",
                           __cil_tmp29, (int )m[1].markerID, m[1].position, 8, "end loop\230",
                           __cil_tmp30, (int )m[2].markerID, m[2].position, 8, "beg loop\230",
                           __cil_tmp31, (int )m[3].markerID, m[3].position, 8, "end loop\230",
                           __cil_tmp32);
      }
    }
  }

#line 1350
  if (psf->str_flags & 1024) {
    {
#line 1351
    aiff_write_strings(psf, 1024);
    }
  }
#line 1353
  if (psf->peak_info != (void *)0) {
#line 1353
    if ((psf->peak_info)->peak_loc == 42) {
      {
#line 1354
      psf_binheader_writef(psf, "Em4\375\036V", ((80 | (69 << 8)) | (65 << 16)) | (75 << 24),
                           2UL * sizeof(int ) + (unsigned long )psf->sf.channels * (sizeof(float ) + sizeof(int )));
#line 1355
      __cil_tmp33 = time((time_t *)((void *)0));
#line 1355
      psf_binheader_writef(psf, "E44", 1, __cil_tmp33);
#line 1356
      k = 0;
      }
      {
#line 1356
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1356
        if (! (k < psf->sf.channels)) {
#line 1356
          goto while_break;
        }
        {
#line 1357
        psf_binheader_writef(psf, "Eft8", (double )((float )(psf->peak_info)->peaks[k].value),
                             (psf->peak_info)->peaks[k].position);
        }
#line 1356
        k ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 1361
  paiff->ssnd_offset = (sf_count_t )psf->headindex;
#line 1362
  psf_binheader_writef(psf, "Etm844", ((83 | (83 << 8)) | (78 << 16)) | (68 << 24),
                       psf->datalength + 8L, 0, 0);
#line 1365
  psf_fwrite((unsigned char *)psf->header, (sf_count_t )psf->headindex, (sf_count_t )1,
             psf);
  }
#line 1367
  if (psf->error) {
#line 1368
    return (psf->error);
  }
#line 1370
  if (has_data) {
#line 1370
    if (psf->dataoffset != (long )psf->headindex) {
#line 1371
      psf->error = 29;
#line 1371
      return (psf->error);
    }
  }
#line 1373
  psf->dataoffset = (sf_count_t )psf->headindex;
#line 1375
  if (! has_data) {
    {
#line 1376
    psf_fseek(psf, psf->dataoffset, 0);
    }
  } else
#line 1377
  if (current > 0L) {
    {
#line 1378
    psf_fseek(psf, current, 0);
    }
  }
#line 1380
  return (psf->error);
}
}
#line 1384 "/root/libsndfile/src/aiff.c"
static int aiff_write_tailer(SF_PRIVATE *psf ) 
{ 
  int k ;
  sf_count_t __cil_tmp3 ;
  sf_count_t __cil_tmp4 ;
  time_t __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 1388
  psf->header[0] = (unsigned char )0;
#line 1389
  psf->headindex = 0;
#line 1391
  psf->dataend = psf_fseek(psf, (sf_count_t )0, 2);
  }
#line 1394
  if (psf->dataend % 2L == 1L) {
    {
#line 1395
    psf_fwrite((unsigned char *)psf->header, (sf_count_t )1, (sf_count_t )1, psf);
#line 1396
    (psf->dataend) ++;
    }
  }

#line 1399
  if (psf->peak_info != (void *)0) {
#line 1399
    if ((psf->peak_info)->peak_loc == 43) {
      {
#line 1400
      psf_binheader_writef(psf, "Em4\375\036V", ((80 | (69 << 8)) | (65 << 16)) | (75 << 24),
                           2UL * sizeof(int ) + (unsigned long )psf->sf.channels * (sizeof(float ) + sizeof(int )));
#line 1401
      __cil_tmp5 = time((time_t *)((void *)0));
#line 1401
      psf_binheader_writef(psf, "E44\375\036V", 1, __cil_tmp5);
#line 1402
      k = 0;
      }
      {
#line 1402
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1402
        if (! (k < psf->sf.channels)) {
#line 1402
          goto while_break;
        }
        {
#line 1403
        psf_binheader_writef(psf, "Eft8\036V", (double )((float )(psf->peak_info)->peaks[k].value),
                             (psf->peak_info)->peaks[k].position);
        }
#line 1402
        k ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }

#line 1406
  if (psf->str_flags & 2048) {
    {
#line 1407
    aiff_write_strings(psf, 2048);
    }
  }
#line 1410
  if (psf->headindex > 0) {
    {
#line 1411
    psf_fwrite((unsigned char *)psf->header, (sf_count_t )psf->headindex, (sf_count_t )1,
               psf);
    }
  }
#line 1413
  return (0);
}
}
#line 1417 "/root/libsndfile/src/aiff.c"
static void aiff_write_strings(SF_PRIVATE *psf , int location ) 
{ 
  int k ;
  int slen ;
  unsigned long __cil_tmp5 ;
  size_t __cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 1420
  k = 0;
  {
#line 1420
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1420
    if (! (k < 32)) {
#line 1420
      goto while_break;
    }
#line 1421
    if (psf->strings[k].type == 0) {
#line 1422
      goto while_break;
    }
#line 1424
    if (psf->strings[k].flags != location) {
#line 1425
      goto while_continue;
    }
    {
#line 1428
    if (psf->strings[k].type == 3) {
#line 1428
      goto case_3;
    }
#line 1433
    if (psf->strings[k].type == 1) {
#line 1433
      goto case_1;
    }
#line 1437
    if (psf->strings[k].type == 2) {
#line 1437
      goto case_2;
    }
#line 1441
    if (psf->strings[k].type == 4) {
#line 1441
      goto case_4;
    }
#line 1445
    if (psf->strings[k].type == 5) {
#line 1445
      goto case_5;
    }
#line 1427
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 1429
    __cil_tmp5 = strlen((char const   *)psf->strings[k].str);
#line 1429
    slen = (int )__cil_tmp5;
    }
    {
#line 1430
    __cil_tmp6 = make_size_t(slen + (slen & 1));
#line 1430
    psf_binheader_writef(psf, "Em4mbV", ((65 | (80 << 8)) | (80 << 16)) | (76 << 24),
                         slen + 4, ((109 | (51 << 8)) | (103 << 16)) | (97 << 24),
                         psf->strings[k].str, __cil_tmp6);
    }
#line 1431
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 1434
    psf_binheader_writef(psf, "EmS\375\036V", ((78 | (65 << 8)) | (77 << 16)) | (69 << 24),
                         psf->strings[k].str);
    }
#line 1435
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 1438
    psf_binheader_writef(psf, "EmS\375\036V", ((40 | (99 << 8)) | (41 << 16)) | (32 << 24),
                         psf->strings[k].str);
    }
#line 1439
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 1442
    psf_binheader_writef(psf, "EmS\375\036V", ((65 | (85 << 8)) | (84 << 16)) | (72 << 24),
                         psf->strings[k].str);
    }
#line 1443
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 1446
    psf_binheader_writef(psf, "EmS\375\036V", ((65 | (78 << 8)) | (78 << 16)) | (79 << 24),
                         psf->strings[k].str);
    }
#line 1447
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }

#line 1420
    k ++;
  }
  while_break: /* CIL Label */ ;
  }

#line 1457
  return;
}
}
#line 1461 "/root/libsndfile/src/aiff.c"
static int aiff_command(SF_PRIVATE *UNUSED_psf , int UNUSED_command , void *UNUSED_data ,
                        int UNUSED_datasize ) 
{ 


  {
#line 1463
  return (0);
}
}
#line 1467 "/root/libsndfile/src/aiff.c"
static char const   *get_loop_mode_str(short mode ) 
{ 


  {
  {
#line 1469
  if ((int )mode == 0) {
#line 1469
    goto case_0;
  }
#line 1470
  if ((int )mode == 1) {
#line 1470
    goto case_1;
  }
#line 1471
  if ((int )mode == 2) {
#line 1471
    goto case_2;
  }
#line 1468
  goto switch_break;
  case_0: /* CIL Label */ 
#line 1469
  return ("none");
  case_1: /* CIL Label */ 
#line 1470
  return ("forward");
  case_2: /* CIL Label */ 
#line 1471
  return ("backward\220");
  switch_break: /* CIL Label */ ;
  }

#line 1474
  return ("*** unknown\375\036V");
}
}
#line 1478 "/root/libsndfile/src/aiff.c"
static short get_loop_mode(short mode ) 
{ 


  {
  {
#line 1480
  if ((int )mode == 0) {
#line 1480
    goto case_0;
  }
#line 1481
  if ((int )mode == 1) {
#line 1481
    goto case_1;
  }
#line 1482
  if ((int )mode == 2) {
#line 1482
    goto case_2;
  }
#line 1479
  goto switch_break;
  case_0: /* CIL Label */ 
#line 1480
  return ((short )800);
  case_1: /* CIL Label */ 
#line 1481
  return ((short )801);
  case_2: /* CIL Label */ 
#line 1482
  return ((short )802);
  switch_break: /* CIL Label */ ;
  }

#line 1485
  return ((short )800);
}
}
#line 1498 "/root/libsndfile/src/aiff.c"
static int tenbytefloat2int(unsigned char *bytes ) 
{ 
  int val ;

  {
#line 1499
  val = 3;
#line 1501
  if ((int )*(bytes + 0) & 128) {
#line 1502
    return (0);
  }
#line 1504
  if ((int )*(bytes + 0) <= 63) {
#line 1505
    return (1);
  }
#line 1507
  if ((int )*(bytes + 0) > 64) {
#line 1508
    return (67108864);
  }
#line 1510
  if ((int )*(bytes + 0) == 64) {
#line 1510
    if ((int )*(bytes + 1) > 28) {
#line 1511
      return (800000000);
    }
  }
#line 1515
  val = ((((int )*(bytes + 2) << 23) | ((int )*(bytes + 3) << 15)) | ((int )*(bytes + 4) << 7)) | ((int )*(bytes + 5) >> 1);
#line 1517
  val >>= 29 - (int )*(bytes + 1);
#line 1519
  return (val);
}
}
#line 1523 "/root/libsndfile/src/aiff.c"
static void uint2tenbytefloat(unsigned int num , unsigned char *bytes ) 
{ 
  unsigned int mask ;
  int count ;
  int __cil_tmp5 ;

  {
#line 1524
  mask = (unsigned int )1073741824;
#line 1527
  if (num <= 1U) {
#line 1528
    *(bytes + 0) = (unsigned char )63;
#line 1529
    *(bytes + 1) = (unsigned char )255;
#line 1530
    *(bytes + 2) = (unsigned char )128;
#line 1531
    return;
  }
#line 1534
  *(bytes + 0) = (unsigned char )64;
#line 1536
  if (num >= mask) {
#line 1537
    *(bytes + 1) = (unsigned char )29;
#line 1538
    return;
  }
#line 1541
  count = 0;
  {
#line 1541
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1541
    if (! (count <= 32)) {
#line 1541
      goto while_break;
    }
#line 1542
    if (num & mask) {
#line 1543
      goto while_break;
    }
#line 1544
    mask >>= 1;
#line 1541
    count ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1547
  num <<= count + 1;
#line 1548
  *(bytes + 1) = (unsigned char )(29 - count);
#line 1549
  *(bytes + 2) = (unsigned char )((num >> 24) & 255U);
#line 1550
  *(bytes + 3) = (unsigned char )((num >> 16) & 255U);
#line 1551
  *(bytes + 4) = (unsigned char )((num >> 8) & 255U);
#line 1552
  *(bytes + 5) = (unsigned char )(num & 255U);
  return;
}
}
#line 1557 "/root/libsndfile/src/aiff.c"
static int aiff_read_basc_chunk(SF_PRIVATE *psf , int datasize ) 
{ 
  char const   *type_str ;
  basc_CHUNK bc ;
  int count ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  void *__cil_tmp9 ;
  int tmp ;

  {
  {
#line 1562
  count = psf_binheader_readf(psf, "E442\036V", & bc.version, & bc.numBeats, & bc.rootNote);
#line 1563
  __cil_tmp7 = psf_binheader_readf(psf, "E222", & bc.scaleType, & bc.sigNumerator,
                                   & bc.sigDenominator);
  }
  {
#line 1563
  count += __cil_tmp7;
#line 1564
  __cil_tmp8 = psf_binheader_readf(psf, "E2j", & bc.loopType, (unsigned long )datasize - sizeof(bc));
  }
  {
#line 1564
  count += __cil_tmp8;
#line 1566
  psf_log_printf(psf, "  Version ? : %u\n  Num Beats : %u\n  Root Note : 0x%x\n",
                 bc.version, bc.numBeats, (int )bc.rootNote);
  }
  {
#line 1570
  if ((int )bc.scaleType == 1) {
#line 1570
    goto case_1;
  }
#line 1573
  if ((int )bc.scaleType == 2) {
#line 1573
    goto case_2;
  }
#line 1576
  if ((int )bc.scaleType == 3) {
#line 1576
    goto case_3;
  }
#line 1579
  if ((int )bc.scaleType == 4) {
#line 1579
    goto case_4;
  }
#line 1582
  goto switch_default;
  case_1: /* CIL Label */ 
#line 1571
  type_str = "MINOR";
#line 1572
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1574
  type_str = "MAJORV";
#line 1575
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1577
  type_str = "NEITHER";
#line 1578
  goto switch_break;
  case_4: /* CIL Label */ 
#line 1580
  type_str = "BOTH";
#line 1581
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1583
  type_str = "!!WRONG!!";
#line 1584
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1587
  psf_log_printf(psf, "  ScaleType : 0x%x (%s)\n\230\001", (int )bc.scaleType, type_str);
#line 1588
  psf_log_printf(psf, "  Time Sig  : %d/%d\n\036V", (int )bc.sigNumerator, (int )bc.sigDenominator);
  }
  {
#line 1591
  if ((int )bc.loopType == 1) {
#line 1591
    goto case_1___0;
  }
#line 1594
  if ((int )bc.loopType == 0) {
#line 1594
    goto case_0;
  }
#line 1597
  goto switch_default___0;
  case_1___0: /* CIL Label */ 
#line 1592
  type_str = "One Shot\220";
#line 1593
  goto switch_break___0;
  case_0: /* CIL Label */ 
#line 1595
  type_str = "Loop";
#line 1596
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 1598
  type_str = "!!WRONG!!\032\337\375\036V";
#line 1599
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 1602
  psf_log_printf(psf, "  Loop Type : 0x%x (%s)\n\230\001", (int )bc.loopType, type_str);
#line 1604
  psf->loop_info = (SF_LOOP_INFO *)calloc((unsigned long )1, sizeof(SF_LOOP_INFO ));
  }
#line 1604
  if (psf->loop_info == (void *)0) {
#line 1605
    return (16);
  }
#line 1607
  (psf->loop_info)->time_sig_num = (short )bc.sigNumerator;
#line 1608
  (psf->loop_info)->time_sig_den = (short )bc.sigDenominator;
#line 1609
  if ((int )bc.loopType == 1) {
#line 1609
    tmp = 800;
  } else {
#line 1609
    tmp = 801;
  }
#line 1609
  (psf->loop_info)->loop_mode = tmp;
#line 1610
  (psf->loop_info)->num_beats = (int )bc.numBeats;
#line 1613
  (psf->loop_info)->bpm = (float )((((1. / (double )psf->sf.frames) * (double )psf->sf.samplerate) * (((double )bc.numBeats * 4.) / (double )((int )bc.sigDenominator))) * 60.);
#line 1615
  (psf->loop_info)->root_key = (int )bc.rootNote;
#line 1617
  if (count < datasize) {
    {
#line 1618
    psf_binheader_readf(psf, "j", datasize - count);
    }
  }
#line 1620
  return (0);
}
}
#line 56 "/root/libsndfile/src/sndfile.c"
static ErrorStruct SndfileErrors[159]  = 
#line 56 "/root/libsndfile/src/sndfile.c"
  {      {0, "No Error."}, 
        {1, "File opened for read. Format not recognised."}, 
        {2, "System error."}, 
        {3, "Supported file format but file is malformed.\036V"}, 
        {4, "Supported file format but unsupported encoding."}, 
        {5, "Error : major format is 0."}, 
        {6, "Error : major format is 0."}, 
        {7, "File does not exist or is not a regular file (possibly a pipe?).\250"}, 
        {8, "File exists but no data could be read."}, 
        {9, "Could not open file."}, 
        {10, "Not a valid SNDFILE* pointer."}, 
        {11, "NULL SF_INFO pointer passed to libsndfile."}, 
        {12, "SF_PRIVATE struct incomplete and end of header parsing."}, 
        {13, "Bad FILE pointer."}, 
        {14, "Internal error, Bad pointer."}, 
        {15, "Error : software was misconfigured at compile time (sizeof statbuf.st_size)."}, 
        {16,
      "Internal malloc () failed."}, 
        {17, "File contains data in an unimplemented format."}, 
        {18, "Attempt to read a non-integer number of channels."}, 
        {19, "Attempt to write a non-integer number of channels."}, 
        {20, "File contains data in an unknown format.\250"}, 
        {21, "Read attempted on file currently open for write.\250"}, 
        {22, "Write attempted on file currently open for read.\250"}, 
        {23, "Error : This file format does not support read/write mode."}, 
        {24, "Internal error : SF_INFO struct incomplete."}, 
        {25, "Error : supplied offset beyond end of file."}, 
        {26, "Error : embedding not supported for this file format."}, 
        {27, "Error : cannot open embedded file read/write."}, 
        {28, "Error : this file format does not support pipe write."}, 
        {34, "Error : bad pointer on SF_VIRTUAL_IO struct."}, 
        {48, "Error : badd SF_BROADCAST_INFO_SIZE."}, 
        {35, "Attempt to write to file with non-interleaved data."}, 
        {36, "Bad karma in seek during interleave read operation."}, 
        {37, "Bad karma in read during interleave read operation."}, 
        {29, "Unspecified internal error."}, 
        {30, "Bad parameter passed to function sf_command."}, 
        {31, "Bad endian-ness. Try default endian-ness\250"}, 
        {32, "Channel count is zero."}, 
        {33, "Too many channels specified."}, 
        {38, "Internal psf_fseek() failed."}, 
        {39, "Seek attempted on unseekable file type."}, 
        {40, "Error : combination of file open mode and seek command is ambiguous."}, 
        {41,
      "Error : invalid seek parameters.\250"}, 
        {42, "Error : parameters OK, but psf_seek() failed."}, 
        {43, "Error : bad mode parameter for file open."}, 
        {44, "Error : attempt toopen a pipe in read/write mode."}, 
        {45, "Error on RDWR position (cryptic)."}, 
        {46, "Error : Cannot open file in read/write mode due to string data in header."}, 
        {47,
      "Error : Command fails because file already has audio data."}, 
        {49, "Error : File type does not support string data."}, 
        {50, "Error : Trying to set a string when file is not in write mode."}, 
        {51, "Error : Maximum string data storage reached."}, 
        {52, "Error : Maximum string data count reached."}, 
        {53, "Error : Bad string data type."}, 
        {54, "Error : file type does not support strings added at end of file.\250"}, 
        {55,
      "Error : bad string."}, 
        {56, "Error : Weird string error."}, 
        {57, "Error in WAV file. No \'RIFF\' chunk marker."}, 
        {58, "Error in WAV file. No \'WAVE\' chunk marker."}, 
        {59, "Error in WAV/W64/RF64 file. No \'fmt \' chunk marker."}, 
        {60, "Error in WAV/W64/RF64 file. Malformed \'fmt \' chunk."}, 
        {61, "Error in WAV/W64/RF64 file. Short \'fmt \' chunk."}, 
        {62, "Error in WAV file. \'fact\' chunk out of place."}, 
        {63, "Error in WAV file. Bad \'PEAK\' chunk."}, 
        {64, "Error in WAV file. \'PEAK\' chunk found before \'fmt \' chunk."}, 
        {65, "Error in WAV file. Errors in \'fmt \' chunk."}, 
        {66, "Error in WAV file. Block alignment in \'fmt \' chunk is incorrect.\250"}, 
        {67,
      "Error in WAV file. No \'data\' chunk marker."}, 
        {68, "Error in WAV file. Malformed LIST chunk.\250"}, 
        {72, "Error in WAV file. File contains an unknown chunk marker."}, 
        {73, "Error in WAV file. Data is in WAVPACK format.\177"}, 
        {69, "Error in ADPCM WAV file. Invalid bit width."}, 
        {70, "Error in ADPCM WAV file. Invalid number of channels."}, 
        {71, "Error in GSM610 WAV file. Invalid format chunk."}, 
        {74, "Error in AIFF file, bad \'FORM\' marker."}, 
        {75, "Error in AIFF file, \'AIFF\' marker without \'FORM\'."}, 
        {76, "Error in AIFF file, \'COMM\' marker without \'FORM\'."}, 
        {77, "Error in AIFF file, \'SSND\' marker without \'COMM\'."}, 
        {78, "Error in AIFF file, unknown chunk."}, 
        {79, "Error in AIFF file, bad \'COMM\' chunk size."}, 
        {80, "Error in AIFF file, bad \'COMM\' chunk."}, 
        {81, "Error in AIFF file. \'PEAK\' chunk found before \'COMM\' chunk."}, 
        {82, "Error in AIFF file. Bad \'PEAK\' chunk."}, 
        {83, "Error in AIFF file, bad \'SSND\' chunk."}, 
        {84, "Error in AIFF file, no sound data."}, 
        {85, "Error in AIFF file, RDWR only possible if SSND chunk at end of file.\004"}, 
        {86,
      "Error in AU file, unknown format."}, 
        {87, "Error in AU file, missing \'.snd\' or \'dns.\' marker."}, 
        {88, "Embedded AU file with unknown length."}, 
        {89, "Error while opening RAW file for read. Must specify format and channels.\nPossibly trying to open unsupported format.\250"}, 
        {90,
      "Error. RAW file bitwidth must be a multiple of 8."}, 
        {91, "Error. Bad format field in SF_INFO struct when openning a RAW file for read."}, 
        {92,
      "Error in PAF file, no marker.\177"}, 
        {93, "Error in PAF file, bad version."}, 
        {94, "Error in PAF file, unknown format."}, 
        {95, "Error in PAF file. File shorter than minimal header."}, 
        {96, "Error in 8SVX / 16SV file, no \'FORM\' marker."}, 
        {97, "Error in 8SVX / 16SV file, no \'BODY\' marker."}, 
        {98, "Error in 8SVX / 16SV file, no sound data."}, 
        {99, "Error in 8SVX / 16SV file, unsupported compression format."}, 
        {100, "Error in 8SVX / 16SV file, NAME chunk too long."}, 
        {101, "Error in NIST file, bad header."}, 
        {102, "Error : NIST file damaged by Windows CR -> CRLF conversion process."}, 
        {103,
      "Error in NIST file, unsupported compression format."}, 
        {104, "Error in VOC file, no \'Creative Voice File\' marker."}, 
        {105, "Error in VOC file, bad format."}, 
        {106, "Error in VOC file, bad version number."}, 
        {107, "Error in VOC file, bad marker in file."}, 
        {108, "Error in VOC file, incompatible VOC sections."}, 
        {109, "Error in VOC file, more than one sample rate defined."}, 
        {110, "Unimplemented VOC file feature, file contains multiple sound sections."}, 
        {111,
      "Error in VOC file, file contains multiple bit or channel widths.\250"}, 
        {112, "Error in VOC file, too many sections."}, 
        {113, "Error : not able to operate on VOC files over a pipe."}, 
        {114, "Error in IRCAM file, bad IRCAM marker."}, 
        {115, "Error in IRCAM file, bad channel count."}, 
        {116, "Error in IRCAM file, unknow encoding format."}, 
        {117, "Error in W64 file, file contains 64 bit offset."}, 
        {118, "Error in W64 file. No \'riff\' chunk marker."}, 
        {119, "Error in W64 file. No \'wave\' chunk marker."}, 
        {120, "Error in W64 file. No \'data\' chunk marker."}, 
        {121, "Error in ADPCM W64 file. Invalid bit width."}, 
        {122, "Error in ADPCM W64 file. Invalid number of channels."}, 
        {123, "Error in GSM610 W64 file. Invalid format chunk."}, 
        {124, "Error in MAT4 file. No variable name."}, 
        {125, "Error in MAT4 file. No sample rate."}, 
        {126, "Error in MAT5 file. Not able to determine endian-ness."}, 
        {127, "Error in MAT5 file. Bad block structure.\250"}, 
        {128, "Error in MAT5 file. Not able to determine sample rate."}, 
        {129, "Error in PVF file. No PVF1 marker."}, 
        {130, "Error in PVF file. Bad header."}, 
        {131, "Error in PVF file. Bad bit width."}, 
        {134, "Error in XI file. Bad header."}, 
        {135, "Error in XI file. Excess samples in file."}, 
        {136, "Error : not able to operate on XI files over a pipe."}, 
        {137, "Error : not able to operate on HTK files over a pipe."}, 
        {138, "Error : not an SDS file.\250"}, 
        {139, "Error : bad bit width for SDS file."}, 
        {140, "Error : cannot open SD2 file without a file name."}, 
        {141, "Error : bad data offset.\250"}, 
        {142, "Error : bad map offset."}, 
        {143, "Error : bad data length.\250"}, 
        {144, "Error : bad map length."}, 
        {145, "Error : bad resource fork."}, 
        {146, "Error : bad sample size.\250"}, 
        {147, "Error : bad flac header.\250"}, 
        {148, "Error : problem while creating flac decoder."}, 
        {149, "Error : problem while initialization of the flac decoder."}, 
        {150, "Error : flac decoder lost sync."}, 
        {151, "Error : flac does not support this sample rate."}, 
        {152, "Error : unkown error in flac decoder."}, 
        {153, "Error : not a WVE file."}, 
        {154, "Error : not able to operate on WVE files over a pipe."}, 
        {132, "Error : Bad bit width for DWVW encoding. Must be 12, 16 or 24."}, 
        {133, "Error : G72x encoding does not support more than 1 channel."}, 
        {155, "Error : Sample rate chosen is known to trigger a Vorbis encoder bug on this CPU.\250"}, 
        {156,
      "Error : Not an RF64 file."}, 
        {157, "Maximum error number."}, 
        {158, (char const   *)((void *)0)}};
#line 259
static int format_from_extension(SF_PRIVATE *psf ) ;
#line 260
static int guess_file_type(SF_PRIVATE *psf ) ;
#line 261
static int validate_sfinfo(SF_INFO *sfinfo ) ;
#line 262
static int validate_psf(SF_PRIVATE *psf ) ;
#line 263
static void save_header_info(SF_PRIVATE *psf ) ;
#line 264
static void copy_filename(SF_PRIVATE *psf , char const   *path ) ;
#line 265
static int psf_close(SF_PRIVATE *psf ) ;
#line 266
static SNDFILE *psf_open_file(SF_PRIVATE *psf , int mode , SF_INFO *sfinfo ) ;
#line 268
static int try_resource_fork(SF_PRIVATE *psf , int mode ) ;
#line 274 "/root/libsndfile/src/sndfile.c"
static int sf_errno  =    0;
#line 275 "/root/libsndfile/src/sndfile.c"
static char sf_logbuffer[16384]  = {      (char )0};
#line 276 "/root/libsndfile/src/sndfile.c"
static char sf_syserr[256]  = {      (char )0};
#line 304 "/root/libsndfile/src/sndfile.c"
SNDFILE *sf_open(char const   *path , int mode , SF_INFO *sfinfo ) 
{ 
  SF_PRIVATE *psf ;
  void *__cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  SNDFILE *__cil_tmp9 ;

  {
  {
#line 307
  psf = (SF_PRIVATE *)calloc((unsigned long )1, sizeof(SF_PRIVATE ));
  }
#line 307
  if (psf == (void *)0) {
#line 308
    sf_errno = 16;
#line 309
    return ((SNDFILE *)((void *)0));
  }
  {
#line 312
  memset(psf, 0, sizeof(SF_PRIVATE ));
#line 313
  psf_init_files(psf);
#line 315
  psf_log_printf(psf, "File : %s\n", path);
#line 317
  copy_filename(psf, path);
#line 319
  __cil_tmp6 = strcmp(path, "-");
  }
#line 319
  if (__cil_tmp6 == 0) {
    {
#line 320
    psf->error = psf_set_stdio(psf, mode);
    }
  } else {
    {
#line 322
    psf->error = psf_fopen(psf, path, mode);
    }
  }
  {
#line 324
  __cil_tmp9 = psf_open_file(psf, mode, sfinfo);
  }
#line 324
  return (__cil_tmp9);
}
}
#line 328 "/root/libsndfile/src/sndfile.c"
SNDFILE *sf_open_fd(int fd , int mode , SF_INFO *sfinfo , int close_desc ) 
{ 
  SF_PRIVATE *psf ;
  void *__cil_tmp6 ;
  int __cil_tmp7 ;
  sf_count_t __cil_tmp8 ;
  SNDFILE *__cil_tmp9 ;

  {
#line 331
  if ((sfinfo->format & 268369920) == 1441792) {
#line 332
    sf_errno = 140;
#line 333
    return ((SNDFILE *)((void *)0));
  }
  {
#line 336
  psf = (SF_PRIVATE *)calloc((unsigned long )1, sizeof(SF_PRIVATE ));
  }
#line 336
  if (psf == (void *)0) {
#line 337
    sf_errno = 16;
#line 338
    return ((SNDFILE *)((void *)0));
  }
  {
#line 341
  psf_init_files(psf);
#line 343
  psf_set_file(psf, fd);
#line 344
  psf->is_pipe = psf_is_pipe(psf);
#line 345
  psf->fileoffset = psf_ftell(psf);
  }
#line 347
  if (! close_desc) {
#line 348
    psf->do_not_close_descriptor = 1;
  }
  {
#line 350
  __cil_tmp9 = psf_open_file(psf, mode, sfinfo);
  }
#line 350
  return (__cil_tmp9);
}
}
#line 354 "/root/libsndfile/src/sndfile.c"
SNDFILE *sf_open_virtual(SF_VIRTUAL_IO *sfvirtual , int mode , SF_INFO *sfinfo , void *user_data ) 
{ 
  SF_PRIVATE *psf ;
  void *__cil_tmp6 ;
  SNDFILE *__cil_tmp7 ;

  {
#line 358
  if (sfvirtual->get_filelen == (void *)0) {
    {
#line 359
    sf_errno = 34;
    {
    {
#line 360
    snprintf((char *)sf_logbuffer, sizeof(sf_logbuffer), "Bad vio_get_filelen / vio_seek / vio_tell in SF_VIRTUAL_IO struct.\n");
    }
    }
    }
#line 361
    return ((SNDFILE *)((void *)0));
  } else
#line 358
  if (sfvirtual->seek == (void *)0) {
    {
#line 359
    sf_errno = 34;
    {
    {
#line 360
    snprintf((char *)sf_logbuffer, sizeof(sf_logbuffer), "Bad vio_get_filelen / vio_seek / vio_tell in SF_VIRTUAL_IO struct.\n");
    }
    }
    }
#line 361
    return ((SNDFILE *)((void *)0));
  } else
#line 358
  if (sfvirtual->tell == (void *)0) {
    {
#line 359
    sf_errno = 34;
    {
    {
#line 360
    snprintf((char *)sf_logbuffer, sizeof(sf_logbuffer), "Bad vio_get_filelen / vio_seek / vio_tell in SF_VIRTUAL_IO struct.\n");
    }
    }
    }
#line 361
    return ((SNDFILE *)((void *)0));
  }

#line 364
  if (sfvirtual->read == (void *)0) {
#line 364
    if (mode == 16) {
      {
#line 365
      sf_errno = 34;
      {
#line 366
      snprintf((char *)sf_logbuffer, sizeof(sf_logbuffer), "Bad vio_read in SF_VIRTUAL_IO struct.\n");
      }
      }
#line 367
      return ((SNDFILE *)((void *)0));
    } else
#line 364
    if (mode == 48) {
      {
#line 365
      sf_errno = 34;
      {
#line 366
      snprintf((char *)sf_logbuffer, sizeof(sf_logbuffer), "Bad vio_read in SF_VIRTUAL_IO struct.\n");
      }
      }
#line 367
      return ((SNDFILE *)((void *)0));
    }
  }

#line 370
  if (sfvirtual->write == (void *)0) {
#line 370
    if (mode == 32) {
      {
#line 371
      sf_errno = 34;
      {
#line 372
      snprintf((char *)sf_logbuffer, sizeof(sf_logbuffer), "Bad vio_write in SF_VIRTUAL_IO struct.\n");
      }
      }
#line 373
      return ((SNDFILE *)((void *)0));
    } else
#line 370
    if (mode == 48) {
      {
#line 371
      sf_errno = 34;
      {
#line 372
      snprintf((char *)sf_logbuffer, sizeof(sf_logbuffer), "Bad vio_write in SF_VIRTUAL_IO struct.\n");
      }
      }
#line 373
      return ((SNDFILE *)((void *)0));
    }
  }
  {
#line 376
  psf = (SF_PRIVATE *)calloc((unsigned long )1, sizeof(SF_PRIVATE ));
  }
#line 376
  if (psf == (void *)0) {
#line 377
    sf_errno = 16;
#line 378
    return ((SNDFILE *)((void *)0));
  }
  {
#line 381
  psf_init_files(psf);
#line 383
  psf->virtual_io = 1;
#line 384
  psf->vio = *sfvirtual;
#line 385
  psf->vio_user_data = user_data;
#line 387
  psf->mode = mode;
#line 389
  __cil_tmp7 = psf_open_file(psf, mode, sfinfo);
  }
#line 389
  return (__cil_tmp7);
}
}
#line 393 "/root/libsndfile/src/sndfile.c"
int sf_close(SNDFILE *sndfile ) 
{ 
  SF_PRIVATE *psf ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
#line 396
  if (sndfile == (void *)0) {
#line 396
    sf_errno = 10;
#line 396
    return (0);
  }
  {
#line 396
  psf = (SF_PRIVATE *)sndfile;
#line 396
  __cil_tmp3 = psf_file_valid(psf);
  }
#line 396
  if (psf->virtual_io == 0) {
#line 396
    if (__cil_tmp3 == 0) {
#line 396
      psf->error = 13;
#line 396
      return (0);
    }
  }

#line 396
  if (psf->Magick != 305447134) {
#line 396
    psf->error = 10;
#line 396
    return (0);
  }

#line 396
  if (1) {
#line 396
    psf->error = 0;
  }
  {
#line 398
  __cil_tmp4 = psf_close(psf);
  }
#line 398
  return (__cil_tmp4);
}
}
#line 402 "/root/libsndfile/src/sndfile.c"
void sf_write_sync(SNDFILE *sndfile ) 
{ 
  SF_PRIVATE *psf ;

  {
#line 405
  psf = (SF_PRIVATE *)sndfile;
#line 405
  if (psf == (void *)0) {
#line 406
    return;
  }
  {
#line 408
  psf_fsync(psf);
  }
#line 410
  return;
}
}
#line 417 "/root/libsndfile/src/sndfile.c"
char const   *sf_error_number(int errnum ) 
{ 
  static char const   *bad_errnum ;
  int k ;
  int __cil_tmp4 ;

  {
#line 418
  bad_errnum = "No error defined for this error number. This is a bug in libsndfile.\036V";
#line 422
  if (errnum == 157) {
#line 423
    return (SndfileErrors[0].str);
  }
#line 425
  if (errnum < 0) {
    {
    {
#line 427
    printf("Not a valid error number (%d).\n", errnum);
    }
    }
#line 428
    return (bad_errnum);
  } else
#line 425
  if (errnum > 157) {
    {
    {
#line 427
    printf("Not a valid error number (%d).\n", errnum);
    }
    }
#line 428
    return (bad_errnum);
  }
#line 431
  k = 0;
  {
#line 431
  while (1) {
    while_continue: /* CIL Label */ ;
#line 431
    if (! SndfileErrors[k].str) {
#line 431
      goto while_break;
    }
#line 432
    if (errnum == SndfileErrors[k].error) {
#line 433
      return (SndfileErrors[k].str);
    }
#line 431
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 435
  return (bad_errnum);
}
}
#line 439 "/root/libsndfile/src/sndfile.c"
char const   *sf_strerror(SNDFILE *sndfile ) 
{ 
  SF_PRIVATE *psf ;
  int errnum ;
  char const   *__cil_tmp4 ;

  {
#line 440
  psf = (SF_PRIVATE *)((void *)0);
#line 443
  if (sndfile == (void *)0) {
#line 444
    errnum = sf_errno;
#line 445
    if (errnum == 2) {
#line 445
      if ((int )sf_syserr[0]) {
#line 446
        return ((char const   *)((char *)sf_syserr));
      }
    }
  } else {
#line 449
    psf = (SF_PRIVATE *)sndfile;
#line 451
    if (psf->Magick != 305447134) {
#line 452
      return ("sf_strerror : Bad magic number.");
    }
#line 454
    errnum = psf->error;
#line 456
    if (errnum == 2) {
#line 456
      if ((int )psf->syserr[0]) {
#line 457
        return ((char const   *)((char *)psf->syserr));
      }
    }
  }
  {
#line 460
  __cil_tmp4 = sf_error_number(errnum);
  }
#line 460
  return (__cil_tmp4);
}
}
#line 467 "/root/libsndfile/src/sndfile.c"
int sf_error(SNDFILE *sndfile ) 
{ 
  SF_PRIVATE *psf ;
  int __cil_tmp3 ;

  {
#line 470
  if (sndfile == (void *)0) {
#line 471
    return (sf_errno);
  }
#line 473
  if (sndfile == (void *)0) {
#line 473
    sf_errno = 10;
#line 473
    return (0);
  }
  {
#line 473
  psf = (SF_PRIVATE *)sndfile;
#line 473
  __cil_tmp3 = psf_file_valid(psf);
  }
#line 473
  if (psf->virtual_io == 0) {
#line 473
    if (__cil_tmp3 == 0) {
#line 473
      psf->error = 13;
#line 473
      return (0);
    }
  }

#line 473
  if (psf->Magick != 305447134) {
#line 473
    psf->error = 10;
#line 473
    return (0);
  }

#line 473
  if (0) {
#line 473
    psf->error = 0;
  }

#line 475
  if (psf->error) {
#line 476
    return (psf->error);
  }
#line 478
  return (0);
}
}
#line 485 "/root/libsndfile/src/sndfile.c"
int sf_perror(SNDFILE *sndfile ) 
{ 
  SF_PRIVATE *psf ;
  int errnum ;
  int __cil_tmp4 ;
  char const   *__cil_tmp5 ;

  {
#line 489
  if (sndfile == (void *)0) {
#line 490
    errnum = sf_errno;
  } else {
#line 493
    if (sndfile == (void *)0) {
#line 493
      sf_errno = 10;
#line 493
      return (0);
    }
    {
#line 493
    psf = (SF_PRIVATE *)sndfile;
#line 493
    __cil_tmp4 = psf_file_valid(psf);
    }
#line 493
    if (psf->virtual_io == 0) {
#line 493
      if (__cil_tmp4 == 0) {
#line 493
        psf->error = 13;
#line 493
        return (0);
      }
    }

#line 493
    if (psf->Magick != 305447134) {
#line 493
      psf->error = 10;
#line 493
      return (0);
    }

#line 493
    if (0) {
#line 493
      psf->error = 0;
    }
#line 494
    errnum = psf->error;
  }
  {
#line 497
  __cil_tmp5 = sf_error_number(errnum);
#line 497
  fprintf(stderr, "%s\n", __cil_tmp5);
  }
#line 498
  return (0);
}
}
#line 506 "/root/libsndfile/src/sndfile.c"
int sf_error_str(SNDFILE *sndfile , char *str , size_t maxlen ) 
{ 
  SF_PRIVATE *psf ;
  int errnum ;
  int __cil_tmp6 ;
  char const   *__cil_tmp7 ;

  {
#line 510
  if (str == (void *)0) {
#line 511
    return (29);
  }
#line 513
  if (sndfile == (void *)0) {
#line 514
    errnum = sf_errno;
  } else {
#line 516
    if (sndfile == (void *)0) {
#line 516
      sf_errno = 10;
#line 516
      return (0);
    }
    {
#line 516
    psf = (SF_PRIVATE *)sndfile;
#line 516
    __cil_tmp6 = psf_file_valid(psf);
    }
#line 516
    if (psf->virtual_io == 0) {
#line 516
      if (__cil_tmp6 == 0) {
#line 516
        psf->error = 13;
#line 516
        return (0);
      }
    }

#line 516
    if (psf->Magick != 305447134) {
#line 516
      psf->error = 10;
#line 516
      return (0);
    }

#line 516
    if (0) {
#line 516
      psf->error = 0;
    }
#line 517
    errnum = psf->error;
  }
  {
#line 520
  __cil_tmp7 = sf_error_number(errnum);
#line 520
  snprintf(str, maxlen, "%s\371\375\036V", __cil_tmp7);
  }
#line 522
  return (0);
}
}
#line 529 "/root/libsndfile/src/sndfile.c"
int sf_format_check(SF_INFO *info ) 
{ 
  int subformat ;
  int endian ;

  {
#line 532
  subformat = info->format & 65535;
#line 533
  endian = info->format & 805306368;
#line 540
  if (info->channels < 1) {
#line 541
    return (0);
  } else
#line 540
  if (info->channels > 256) {
#line 541
    return (0);
  }
#line 543
  if (info->samplerate < 0) {
#line 544
    return (0);
  }
  {
#line 548
  if ((info->format & 268369920) == 1245184) {
#line 548
    goto case_1245184;
  }
#line 548
  if ((info->format & 268369920) == 65536) {
#line 548
    goto case_1245184;
  }
#line 566
  if ((info->format & 268369920) == 131072) {
#line 566
    goto case_131072;
  }
#line 588
  if ((info->format & 268369920) == 196608) {
#line 588
    goto case_196608;
  }
#line 605
  if ((info->format & 268369920) == 1572864) {
#line 605
    goto case_1572864;
  }
#line 616
  if ((info->format & 268369920) == 262144) {
#line 616
    goto case_262144;
  }
#line 634
  if ((info->format & 268369920) == 327680) {
#line 634
    goto case_327680;
  }
#line 641
  if ((info->format & 268369920) == 393216) {
#line 641
    goto case_393216;
  }
#line 655
  if ((info->format & 268369920) == 458752) {
#line 655
    goto case_458752;
  }
#line 664
  if ((info->format & 268369920) == 655360) {
#line 664
    goto case_655360;
  }
#line 671
  if ((info->format & 268369920) == 524288) {
#line 671
    goto case_524288;
  }
#line 681
  if ((info->format & 268369920) == 720896) {
#line 681
    goto case_720896;
  }
#line 699
  if ((info->format & 268369920) == 786432) {
#line 699
    goto case_786432;
  }
#line 706
  if ((info->format & 268369920) == 851968) {
#line 706
    goto case_851968;
  }
#line 713
  if ((info->format & 268369920) == 917504) {
#line 713
    goto case_917504;
  }
#line 718
  if ((info->format & 268369920) == 983040) {
#line 718
    goto case_983040;
  }
#line 725
  if ((info->format & 268369920) == 1048576) {
#line 725
    goto case_1048576;
  }
#line 735
  if ((info->format & 268369920) == 1114112) {
#line 735
    goto case_1114112;
  }
#line 745
  if ((info->format & 268369920) == 1179648) {
#line 745
    goto case_1179648;
  }
#line 755
  if ((info->format & 268369920) == 1507328) {
#line 755
    goto case_1507328;
  }
#line 763
  if ((info->format & 268369920) == 1441792) {
#line 763
    goto case_1441792;
  }
#line 771
  if ((info->format & 268369920) == 1638400) {
#line 771
    goto case_1638400;
  }
#line 781
  if ((info->format & 268369920) == 2097152) {
#line 781
    goto case_2097152;
  }
#line 786
  if ((info->format & 268369920) == 2162688) {
#line 786
    goto case_2162688;
  }
#line 796
  if ((info->format & 268369920) == 2228224) {
#line 796
    goto case_2228224;
  }
#line 808
  goto switch_default;
  case_1245184: /* CIL Label */ 
  case_65536: /* CIL Label */ 
#line 550
  if (subformat == 5) {
#line 551
    return (1);
  } else
#line 550
  if (subformat == 2) {
#line 551
    return (1);
  }
#line 552
  if (subformat == 3) {
#line 553
    return (1);
  } else
#line 552
  if (subformat == 4) {
#line 553
    return (1);
  }
#line 554
  if (subformat == 18) {
    _L: /* CIL Label */ 
#line 554
    if (info->channels <= 2) {
#line 555
      return (1);
    }
  } else
#line 554
  if (subformat == 19) {
#line 554
    goto _L;
  }
#line 556
  if (subformat == 32) {
#line 556
    if (info->channels == 1) {
#line 557
      return (1);
    }
  }
#line 558
  if (subformat == 48) {
#line 558
    if (info->channels == 1) {
#line 559
      return (1);
    }
  }
#line 560
  if (subformat == 16) {
#line 561
    return (1);
  } else
#line 560
  if (subformat == 17) {
#line 561
    return (1);
  }
#line 562
  if (subformat == 6) {
#line 563
    return (1);
  } else
#line 562
  if (subformat == 7) {
#line 563
    return (1);
  }
#line 564
  goto switch_break;
  case_131072: /* CIL Label */ 
#line 568
  if (subformat == 2) {
#line 569
    return (1);
  } else
#line 568
  if (subformat == 3) {
#line 569
    return (1);
  } else
#line 568
  if (subformat == 4) {
#line 569
    return (1);
  }
#line 571
  if (endian == 268435456) {
#line 572
    return (0);
  } else
#line 571
  if (endian == 805306368) {
#line 572
    return (0);
  }
#line 573
  if (subformat == 5) {
#line 574
    return (1);
  } else
#line 573
  if (subformat == 1) {
#line 574
    return (1);
  }
#line 575
  if (subformat == 6) {
#line 576
    return (1);
  } else
#line 575
  if (subformat == 7) {
#line 576
    return (1);
  }
#line 577
  if (subformat == 16) {
#line 578
    return (1);
  } else
#line 577
  if (subformat == 17) {
#line 578
    return (1);
  }
#line 579
  if (subformat == 64) {
    _L___46: /* CIL Label */ 
    _L___47: /* CIL Label */ 
#line 579
    if (info->channels == 1) {
#line 581
      return (1);
    }
  } else
#line 579
  if (subformat == 65) {
#line 579
    goto _L___46;
  } else
#line 579
  if (subformat == 66) {
#line 579
    goto _L___46;
  }
#line 582
  if (subformat == 32) {
#line 582
    if (info->channels == 1) {
#line 583
      return (1);
    }
  }
#line 584
  if (subformat == 18) {
#line 584
    if (info->channels == 1) {
#line 585
      return (1);
    } else
#line 584
    if (info->channels == 2) {
#line 585
      return (1);
    }
  }
#line 586
  goto switch_break;
  case_196608: /* CIL Label */ 
#line 589
  if (subformat == 1) {
#line 590
    return (1);
  } else
#line 589
  if (subformat == 2) {
#line 590
    return (1);
  }
#line 591
  if (subformat == 3) {
#line 592
    return (1);
  } else
#line 591
  if (subformat == 4) {
#line 592
    return (1);
  }
#line 593
  if (subformat == 16) {
#line 594
    return (1);
  } else
#line 593
  if (subformat == 17) {
#line 594
    return (1);
  }
#line 595
  if (subformat == 6) {
#line 596
    return (1);
  } else
#line 595
  if (subformat == 7) {
#line 596
    return (1);
  }
#line 597
  if (subformat == 48) {
#line 597
    if (info->channels == 1) {
#line 598
      return (1);
    }
  }
#line 599
  if (subformat == 49) {
#line 599
    if (info->channels == 1) {
#line 600
      return (1);
    }
  }
#line 601
  if (subformat == 50) {
#line 601
    if (info->channels == 1) {
#line 602
      return (1);
    }
  }
#line 603
  goto switch_break;
  case_1572864: /* CIL Label */ 
#line 606
  if (subformat == 1) {
#line 607
    return (1);
  } else
#line 606
  if (subformat == 2) {
#line 607
    return (1);
  }
#line 608
  if (subformat == 3) {
#line 609
    return (1);
  } else
#line 608
  if (subformat == 4) {
#line 609
    return (1);
  }
#line 610
  if (subformat == 16) {
#line 611
    return (1);
  } else
#line 610
  if (subformat == 17) {
#line 611
    return (1);
  }
#line 612
  if (subformat == 6) {
#line 613
    return (1);
  } else
#line 612
  if (subformat == 7) {
#line 613
    return (1);
  }
#line 614
  goto switch_break;
  case_262144: /* CIL Label */ 
#line 617
  if (subformat == 5) {
#line 618
    return (1);
  } else
#line 617
  if (subformat == 1) {
#line 618
    return (1);
  } else
#line 617
  if (subformat == 2) {
#line 618
    return (1);
  }
#line 619
  if (subformat == 3) {
#line 620
    return (1);
  } else
#line 619
  if (subformat == 4) {
#line 620
    return (1);
  }
#line 621
  if (subformat == 6) {
#line 622
    return (1);
  } else
#line 621
  if (subformat == 7) {
#line 622
    return (1);
  }
#line 623
  if (subformat == 17) {
#line 624
    return (1);
  } else
#line 623
  if (subformat == 16) {
#line 624
    return (1);
  }
#line 625
  if (subformat == 64) {
    _L___48: /* CIL Label */ 
    _L___49: /* CIL Label */ 
#line 625
    if (info->channels == 1) {
#line 627
      return (1);
    }
  } else
#line 625
  if (subformat == 65) {
#line 625
    goto _L___48;
  } else
#line 625
  if (subformat == 66) {
#line 625
    goto _L___48;
  }
#line 628
  if (subformat == 32) {
#line 628
    if (info->channels == 1) {
#line 629
      return (1);
    }
  }
#line 630
  if (subformat == 33) {
#line 630
    if (info->channels == 1) {
#line 631
      return (1);
    }
  }
#line 632
  goto switch_break;
  case_327680: /* CIL Label */ 
#line 635
  if (subformat == 1) {
#line 636
    return (1);
  } else
#line 635
  if (subformat == 2) {
#line 636
    return (1);
  }
#line 637
  if (subformat == 3) {
#line 638
    return (1);
  } else
#line 637
  if (subformat == 4) {
#line 638
    return (1);
  }
#line 639
  goto switch_break;
  case_393216: /* CIL Label */ 
#line 645
  if (info->channels != 1) {
#line 646
    return (0);
  }
#line 648
  if (endian == 268435456) {
#line 649
    return (0);
  } else
#line 648
  if (endian == 805306368) {
#line 649
    return (0);
  }
#line 651
  if (subformat == 1) {
    _L___50: /* CIL Label */ 
#line 651
    if (info->channels == 1) {
#line 652
      return (1);
    }
  } else
#line 651
  if (subformat == 2) {
#line 651
    goto _L___50;
  }
#line 653
  goto switch_break;
  case_458752: /* CIL Label */ 
#line 656
  if (subformat == 1) {
#line 657
    return (1);
  } else
#line 656
  if (subformat == 2) {
#line 657
    return (1);
  }
#line 658
  if (subformat == 3) {
#line 659
    return (1);
  } else
#line 658
  if (subformat == 4) {
#line 659
    return (1);
  }
#line 660
  if (subformat == 16) {
#line 661
    return (1);
  } else
#line 660
  if (subformat == 17) {
#line 661
    return (1);
  }
#line 662
  goto switch_break;
  case_655360: /* CIL Label */ 
#line 665
  if (subformat == 2) {
#line 666
    return (1);
  } else
#line 665
  if (subformat == 3) {
#line 666
    return (1);
  } else
#line 665
  if (subformat == 4) {
#line 666
    return (1);
  }
#line 667
  if (subformat == 16) {
#line 668
    return (1);
  } else
#line 667
  if (subformat == 17) {
#line 668
    return (1);
  } else
#line 667
  if (subformat == 6) {
#line 668
    return (1);
  }
#line 669
  goto switch_break;
  case_524288: /* CIL Label */ 
#line 673
  if (endian == 536870912) {
#line 674
    return (0);
  } else
#line 673
  if (endian == 805306368) {
#line 674
    return (0);
  }
#line 675
  if (subformat == 5) {
#line 676
    return (1);
  } else
#line 675
  if (subformat == 2) {
#line 676
    return (1);
  }
#line 677
  if (subformat == 16) {
#line 678
    return (1);
  } else
#line 677
  if (subformat == 17) {
#line 678
    return (1);
  }
#line 679
  goto switch_break;
  case_720896: /* CIL Label */ 
#line 683
  if (endian == 536870912) {
#line 684
    return (0);
  } else
#line 683
  if (endian == 805306368) {
#line 684
    return (0);
  }
#line 685
  if (subformat == 5) {
#line 686
    return (1);
  } else
#line 685
  if (subformat == 2) {
#line 686
    return (1);
  }
#line 687
  if (subformat == 3) {
#line 688
    return (1);
  } else
#line 687
  if (subformat == 4) {
#line 688
    return (1);
  }
#line 689
  if (subformat == 18) {
    _L___51: /* CIL Label */ 
#line 689
    if (info->channels <= 2) {
#line 690
      return (1);
    }
  } else
#line 689
  if (subformat == 19) {
#line 689
    goto _L___51;
  }
#line 691
  if (subformat == 32) {
#line 691
    if (info->channels == 1) {
#line 692
      return (1);
    }
  }
#line 693
  if (subformat == 16) {
#line 694
    return (1);
  } else
#line 693
  if (subformat == 17) {
#line 694
    return (1);
  }
#line 695
  if (subformat == 6) {
#line 696
    return (1);
  } else
#line 695
  if (subformat == 7) {
#line 696
    return (1);
  }
#line 697
  goto switch_break;
  case_786432: /* CIL Label */ 
#line 700
  if (subformat == 2) {
#line 701
    return (1);
  } else
#line 700
  if (subformat == 4) {
#line 701
    return (1);
  }
#line 702
  if (subformat == 6) {
#line 703
    return (1);
  } else
#line 702
  if (subformat == 7) {
#line 703
    return (1);
  }
#line 704
  goto switch_break;
  case_851968: /* CIL Label */ 
#line 707
  if (subformat == 5) {
#line 708
    return (1);
  } else
#line 707
  if (subformat == 2) {
#line 708
    return (1);
  } else
#line 707
  if (subformat == 4) {
#line 708
    return (1);
  }
#line 709
  if (subformat == 6) {
#line 710
    return (1);
  } else
#line 709
  if (subformat == 7) {
#line 710
    return (1);
  }
#line 711
  goto switch_break;
  case_917504: /* CIL Label */ 
#line 714
  if (subformat == 1) {
#line 715
    return (1);
  } else
#line 714
  if (subformat == 2) {
#line 715
    return (1);
  } else
#line 714
  if (subformat == 4) {
#line 715
    return (1);
  }
#line 716
  goto switch_break;
  case_983040: /* CIL Label */ 
#line 719
  if (info->channels != 1) {
#line 720
    return (0);
  }
#line 721
  if (subformat == 80) {
#line 722
    return (1);
  } else
#line 721
  if (subformat == 81) {
#line 722
    return (1);
  }
#line 723
  goto switch_break;
  case_1048576: /* CIL Label */ 
#line 727
  if (endian == 268435456) {
#line 728
    return (0);
  } else
#line 727
  if (endian == 805306368) {
#line 728
    return (0);
  }
#line 729
  if (info->channels != 1) {
#line 730
    return (0);
  }
#line 731
  if (subformat == 2) {
#line 732
    return (1);
  }
#line 733
  goto switch_break;
  case_1114112: /* CIL Label */ 
#line 737
  if (endian == 268435456) {
#line 738
    return (0);
  } else
#line 737
  if (endian == 805306368) {
#line 738
    return (0);
  }
#line 739
  if (info->channels != 1) {
#line 740
    return (0);
  }
#line 741
  if (subformat == 1) {
#line 742
    return (1);
  } else
#line 741
  if (subformat == 2) {
#line 742
    return (1);
  } else
#line 741
  if (subformat == 3) {
#line 742
    return (1);
  }
#line 743
  goto switch_break;
  case_1179648: /* CIL Label */ 
#line 747
  if (endian == 268435456) {
#line 748
    return (0);
  } else
#line 747
  if (endian == 805306368) {
#line 748
    return (0);
  }
#line 749
  if (info->channels > 2) {
#line 750
    return (0);
  }
#line 751
  if (subformat == 5) {
#line 752
    return (1);
  } else
#line 751
  if (subformat == 1) {
#line 752
    return (1);
  } else
#line 751
  if (subformat == 2) {
#line 752
    return (1);
  }
#line 753
  goto switch_break;
  case_1507328: /* CIL Label */ 
#line 757
  if (info->channels > 8) {
#line 758
    return (0);
  }
#line 759
  if (subformat == 1) {
#line 760
    return (1);
  } else
#line 759
  if (subformat == 2) {
#line 760
    return (1);
  } else
#line 759
  if (subformat == 3) {
#line 760
    return (1);
  }
#line 761
  goto switch_break;
  case_1441792: /* CIL Label */ 
#line 765
  if (endian == 268435456) {
#line 766
    return (0);
  } else
#line 765
  if (endian == 805306368) {
#line 766
    return (0);
  }
#line 767
  if (subformat == 1) {
#line 768
    return (1);
  } else
#line 767
  if (subformat == 2) {
#line 768
    return (1);
  } else
#line 767
  if (subformat == 3) {
#line 768
    return (1);
  }
#line 769
  goto switch_break;
  case_1638400: /* CIL Label */ 
#line 773
  if (endian == 536870912) {
#line 774
    return (0);
  } else
#line 773
  if (endian == 805306368) {
#line 774
    return (0);
  }
#line 775
  if (info->channels > 1) {
#line 776
    return (0);
  }
#line 777
  if (subformat == 17) {
#line 778
    return (1);
  }
#line 779
  goto switch_break;
  case_2097152: /* CIL Label */ 
#line 782
  if (subformat == 96) {
#line 783
    return (1);
  }
#line 784
  goto switch_break;
  case_2162688: /* CIL Label */ 
#line 788
  if (endian == 536870912) {
#line 789
    return (0);
  } else
#line 788
  if (endian == 805306368) {
#line 789
    return (0);
  }
#line 790
  if (info->channels > 2) {
#line 791
    return (0);
  }
#line 792
  if (subformat == 2) {
#line 793
    return (1);
  }
#line 794
  goto switch_break;
  case_2228224: /* CIL Label */ 
#line 797
  if (endian == 536870912) {
#line 798
    return (0);
  } else
#line 797
  if (endian == 805306368) {
#line 798
    return (0);
  }
#line 799
  if (subformat == 5) {
#line 800
    return (1);
  } else
#line 799
  if (subformat == 2) {
#line 800
    return (1);
  }
#line 801
  if (subformat == 3) {
#line 802
    return (1);
  } else
#line 801
  if (subformat == 4) {
#line 802
    return (1);
  }
#line 803
  if (subformat == 16) {
#line 804
    return (1);
  } else
#line 803
  if (subformat == 17) {
#line 804
    return (1);
  }
#line 805
  if (subformat == 6) {
#line 806
    return (1);
  } else
#line 805
  if (subformat == 7) {
#line 806
    return (1);
  }
#line 807
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 808
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }

#line 811
  return (0);
}
}
#line 818 "/root/libsndfile/src/sndfile.c"
char const   *sf_version_string(void) 
{ 


  {
#line 823
  return ("libsndfile-1.0.21pre1");
}
}
#line 832 "/root/libsndfile/src/sndfile.c"
int sf_command(SNDFILE *sndfile , int command , void *data___0 , int datasize ) 
{ 
  SF_PRIVATE *psf ;
  int old_value ;
  char const   *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  int __cil_tmp17 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  double __cil_tmp21 ;
  int tmp___2 ;
  int format ;
  PEAK_INFO *__cil_tmp24 ;
  double __cil_tmp25 ;
  double __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int tmp___3 ;
  sf_count_t position ;
  sf_count_t __cil_tmp33 ;
  sf_count_t __cil_tmp34 ;
  int __cil_tmp35 ;
  int tmp___4 ;
  int tmp___5 ;
  int format___0 ;
  int __cil_tmp39 ;
  SF_INSTRUMENT *__cil_tmp40 ;
  int __cil_tmp41 ;

  {
#line 833
  psf = (SF_PRIVATE *)sndfile;
  {
#line 838
  if (command == 4096) {
#line 838
    goto case_4096;
  }
#line 847
  if (command == 4128) {
#line 847
    goto case_4128;
  }
#line 853
  if (command == 4129) {
#line 853
    goto case_4129;
  }
#line 858
  if (command == 4144) {
#line 858
    goto case_4144;
  }
#line 864
  if (command == 4145) {
#line 864
    goto case_4145;
  }
#line 869
  if (command == 4146) {
#line 869
    goto case_4146;
  }
#line 875
  if (command == 4147) {
#line 875
    goto case_4147;
  }
#line 880
  if (command == 4136) {
#line 880
    goto case_4136;
  }
#line 837
  goto switch_break;
  case_4096: /* CIL Label */ 
#line 839
  if (data___0 == (void *)0) {
#line 840
    if (psf) {
#line 841
      psf->error = 30;
    }
#line 842
    return (30);
  }
  {
#line 844
  __cil_tmp7 = sf_version_string();
#line 844
  snprintf(data___0, (unsigned long )datasize, "%s", __cil_tmp7);
#line 845
  __cil_tmp8 = strlen(data___0);
  }
#line 845
  return ((int )__cil_tmp8);
  case_4128: /* CIL Label */ 
#line 848
  if (data___0 == (void *)0) {
#line 849
    sf_errno = 30;
#line 849
    return (sf_errno);
  } else
#line 848
  if (datasize != (int )sizeof(int )) {
#line 849
    sf_errno = 30;
#line 849
    return (sf_errno);
  }
  {
#line 850
  *((int *)data___0) = psf_get_format_simple_count();
  }
#line 851
  return (0);
  case_4129: /* CIL Label */ 
#line 854
  if (data___0 == (void *)0) {
#line 855
    sf_errno = 30;
#line 855
    return (sf_errno);
  } else
#line 854
  if (datasize != (int )sizeof(SF_FORMAT_INFO )) {
#line 855
    sf_errno = 30;
#line 855
    return (sf_errno);
  }
  {
#line 856
  __cil_tmp10 = psf_get_format_simple(data___0);
  }
#line 856
  return (__cil_tmp10);
  case_4144: /* CIL Label */ 
#line 859
  if (data___0 == (void *)0) {
#line 860
    sf_errno = 30;
#line 860
    return (sf_errno);
  } else
#line 859
  if (datasize != (int )sizeof(int )) {
#line 860
    sf_errno = 30;
#line 860
    return (sf_errno);
  }
  {
#line 861
  *((int *)data___0) = psf_get_format_major_count();
  }
#line 862
  return (0);
  case_4145: /* CIL Label */ 
#line 865
  if (data___0 == (void *)0) {
#line 866
    sf_errno = 30;
#line 866
    return (sf_errno);
  } else
#line 865
  if (datasize != (int )sizeof(SF_FORMAT_INFO )) {
#line 866
    sf_errno = 30;
#line 866
    return (sf_errno);
  }
  {
#line 867
  __cil_tmp12 = psf_get_format_major(data___0);
  }
#line 867
  return (__cil_tmp12);
  case_4146: /* CIL Label */ 
#line 870
  if (data___0 == (void *)0) {
#line 871
    sf_errno = 30;
#line 871
    return (sf_errno);
  } else
#line 870
  if (datasize != (int )sizeof(int )) {
#line 871
    sf_errno = 30;
#line 871
    return (sf_errno);
  }
  {
#line 872
  *((int *)data___0) = psf_get_format_subtype_count();
  }
#line 873
  return (0);
  case_4147: /* CIL Label */ 
#line 876
  if (data___0 == (void *)0) {
#line 877
    sf_errno = 30;
#line 877
    return (sf_errno);
  } else
#line 876
  if (datasize != (int )sizeof(SF_FORMAT_INFO )) {
#line 877
    sf_errno = 30;
#line 877
    return (sf_errno);
  }
  {
#line 878
  __cil_tmp14 = psf_get_format_subtype(data___0);
  }
#line 878
  return (__cil_tmp14);
  case_4136: /* CIL Label */ 
#line 881
  if (data___0 == (void *)0) {
#line 882
    sf_errno = 30;
#line 882
    return (sf_errno);
  } else
#line 881
  if (datasize != (int )sizeof(SF_FORMAT_INFO )) {
#line 882
    sf_errno = 30;
#line 882
    return (sf_errno);
  }
  {
#line 883
  __cil_tmp15 = psf_get_format_info(data___0);
  }
#line 883
  return (__cil_tmp15);
  switch_break: /* CIL Label */ ;
  }

#line 886
  if (sndfile == (void *)0) {
#line 886
    if (command == 4097) {
#line 887
      if (data___0 == (void *)0) {
#line 888
        psf->error = 30;
#line 888
        return (psf->error);
      }
      {
#line 889
      snprintf(data___0, (unsigned long )datasize, "%s", (char *)sf_logbuffer);
#line 890
      __cil_tmp16 = strlen(data___0);
      }
#line 890
      return ((int )__cil_tmp16);
    }
  }

#line 893
  if (sndfile == (void *)0) {
#line 893
    sf_errno = 10;
#line 893
    return (0);
  }
  {
#line 893
  psf = (SF_PRIVATE *)sndfile;
#line 893
  __cil_tmp17 = psf_file_valid(psf);
  }
#line 893
  if (psf->virtual_io == 0) {
#line 893
    if (__cil_tmp17 == 0) {
#line 893
      psf->error = 13;
#line 893
      return (0);
    }
  }

#line 893
  if (psf->Magick != 305447134) {
#line 893
    psf->error = 10;
#line 893
    return (0);
  }

#line 893
  if (1) {
#line 893
    psf->error = 0;
  }

  {
#line 896
  if (command == 4115) {
#line 896
    goto case_4115;
  }
#line 901
  if (command == 4098) {
#line 901
    goto case_4098;
  }
#line 907
  if (command == 4114) {
#line 907
    goto case_4114;
  }
#line 912
  if (command == 4113) {
#line 912
    goto case_4113;
  }
#line 915
  if (command == 4112) {
#line 915
    goto case_4112;
  }
#line 918
  if (command == 4116) {
#line 918
    goto case_4116;
  }
#line 926
  if (command == 4117) {
#line 926
    goto case_4117;
  }
#line 931
  if (command == 4176) {
#line 931
    goto case_4176;
  }
#line 968
  if (command == 4177) {
#line 968
    goto case_4177;
  }
#line 971
  if (command == 4097) {
#line 971
    goto case_4097;
  }
#line 977
  if (command == 4160) {
#line 977
    goto case_4160;
  }
#line 983
  if (command == 4161) {
#line 983
    goto case_4161;
  }
#line 989
  if (command == 4162) {
#line 989
    goto case_4162;
  }
#line 994
  if (command == 4163) {
#line 994
    goto case_4163;
  }
#line 999
  if (command == 4164) {
#line 999
    goto case_4164;
  }
#line 1006
  if (command == 4165) {
#line 1006
    goto case_4165;
  }
#line 1013
  if (command == 4192) {
#line 1013
    goto case_4192;
  }
#line 1018
  if (command == 4193) {
#line 1018
    goto case_4193;
  }
#line 1024
  if (command == 4209) {
#line 1024
    goto case_4209;
  }
#line 1024
  if (command == 4208) {
#line 1024
    goto case_4209;
  }
#line 1032
  if (command == 4256) {
#line 1032
    goto case_4256;
  }
#line 1040
  if (command == 4257) {
#line 1040
    goto case_4257;
  }
#line 1048
  if (command == 4224) {
#line 1048
    goto case_4224;
  }
#line 1068
  if (command == 4240) {
#line 1068
    goto case_4240;
  }
#line 1079
  if (command == 4272) {
#line 1079
    goto case_4272;
  }
#line 1088
  if (command == 24577) {
#line 1088
    goto case_24577;
  }
#line 1099
  if (command == 4288) {
#line 1099
    goto case_4288;
  }
#line 1103
  if (command == 4289) {
#line 1103
    goto case_4289;
  }
#line 1106
  if (command == 4320) {
#line 1106
    goto case_4320;
  }
#line 1116
  if (command == 4337) {
#line 1116
    goto case_4337;
  }
#line 1147
  if (command == 4336) {
#line 1147
    goto case_4336;
  }
#line 1160
  if (command == 4304) {
#line 1160
    goto case_4304;
  }
#line 1170
  if (command == 4305) {
#line 1170
    goto case_4305;
  }
#line 1188
  if (command == 4368) {
#line 1188
    goto case_4368;
  }
#line 1191
  goto switch_default;
  case_4115: /* CIL Label */ 
#line 897
  old_value = psf->norm_float;
#line 898
  if (datasize) {
#line 898
    tmp = 1;
  } else {
#line 898
    tmp = 0;
  }
#line 898
  psf->norm_float = tmp;
#line 899
  return (old_value);
  case_4098: /* CIL Label */ 
#line 902
  if (data___0 == (void *)0) {
#line 903
    sf_errno = 30;
#line 903
    return (sf_errno);
  } else
#line 902
  if (datasize != (int )sizeof(SF_INFO )) {
#line 903
    sf_errno = 30;
#line 903
    return (sf_errno);
  }
  {
#line 904
  memcpy(data___0, & psf->sf, sizeof(SF_INFO ));
  }
#line 905
  goto switch_break___0;
  case_4114: /* CIL Label */ 
#line 908
  old_value = psf->norm_double;
#line 909
  if (datasize) {
#line 909
    tmp___0 = 1;
  } else {
#line 909
    tmp___0 = 0;
  }
#line 909
  psf->norm_double = tmp___0;
#line 910
  return (old_value);
  case_4113: /* CIL Label */ 
#line 913
  return (psf->norm_float);
  case_4112: /* CIL Label */ 
#line 916
  return (psf->norm_double);
  case_4116: /* CIL Label */ 
#line 919
  old_value = psf->float_int_mult;
#line 921
  if (datasize != 0) {
#line 921
    tmp___1 = 1;
  } else {
#line 921
    tmp___1 = 0;
  }
#line 921
  psf->float_int_mult = tmp___1;
#line 922
  if (psf->float_int_mult) {
#line 922
    if ((double )psf->float_max < 0.) {
      {
#line 923
      __cil_tmp21 = psf_calc_signal_max(psf, 0);
#line 923
      psf->float_max = (float )__cil_tmp21;
      }
    }
  }
#line 924
  return (old_value);
  case_4117: /* CIL Label */ 
#line 927
  old_value = psf->scale_int_float;
#line 928
  if (datasize != 0) {
#line 928
    tmp___2 = 1;
  } else {
#line 928
    tmp___2 = 0;
  }
#line 928
  psf->scale_int_float = tmp___2;
#line 929
  return (old_value);
  case_4176: /* CIL Label */ 
#line 932
  format = psf->sf.format & 268369920;
#line 935
  if (format != 65536) {
#line 935
    if (format != 1245184) {
#line 935
      if (format != 131072) {
#line 936
        return (0);
      }
    }
  }
#line 938
  format = psf->sf.format & 65535;
#line 941
  if (format != 6) {
#line 941
    if (format != 7) {
#line 942
      return (0);
    }
  }

#line 946
  if (psf->mode != 32) {
#line 946
    if (psf->mode != 48) {
#line 947
      return (0);
    }
  }
#line 949
  if (psf->have_written) {
#line 950
    psf->error = 47;
#line 951
    return (0);
  }

#line 954
  if (psf->peak_info != (void *)0) {
#line 954
    if (datasize == 0) {
      {
#line 955
      free(psf->peak_info);
#line 956
      psf->peak_info = (PEAK_INFO *)((void *)0);
      }
    } else {
#line 954
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 958
  if (psf->peak_info == (void *)0) {
    {
#line 959
    psf->peak_info = peak_info_calloc(psf->sf.channels);
    }
#line 960
    if (psf->peak_info != (void *)0) {
#line 961
      (psf->peak_info)->peak_loc = 42;
    }
  }

#line 964
  if (psf->write_header) {
    {
#line 965
    (*(psf->write_header))(psf, 1);
    }
  }
#line 966
  return (datasize);
  case_4177: /* CIL Label */ 
#line 969
  return (0);
  case_4097: /* CIL Label */ 
#line 972
  if (data___0 == (void *)0) {
#line 973
    return (30);
  }
  {
#line 974
  snprintf(data___0, (unsigned long )datasize, "%s\372\375\036V", (char *)psf->logbuffer);
  }
#line 975
  goto switch_break___0;
  case_4160: /* CIL Label */ 
#line 978
  if (data___0 == (void *)0) {
#line 979
    psf->error = 30;
#line 979
    return (psf->error);
  } else
#line 978
  if ((unsigned long )datasize != sizeof(double )) {
#line 979
    psf->error = 30;
#line 979
    return (psf->error);
  }
  {
#line 980
  *((double *)data___0) = psf_calc_signal_max(psf, 0);
  }
#line 981
  goto switch_break___0;
  case_4161: /* CIL Label */ 
#line 984
  if (data___0 == (void *)0) {
#line 985
    psf->error = 30;
#line 985
    return (psf->error);
  } else
#line 984
  if ((unsigned long )datasize != sizeof(double )) {
#line 985
    psf->error = 30;
#line 985
    return (psf->error);
  }
  {
#line 986
  *((double *)data___0) = psf_calc_signal_max(psf, 1);
  }
#line 987
  goto switch_break___0;
  case_4162: /* CIL Label */ 
#line 990
  if (data___0 == (void *)0) {
#line 991
    psf->error = 30;
#line 991
    return (psf->error);
  } else
#line 990
  if (datasize != (int )sizeof(double ) * psf->sf.channels) {
#line 991
    psf->error = 30;
#line 991
    return (psf->error);
  }
  {
#line 992
  __cil_tmp27 = psf_calc_max_all_channels(psf, (double *)data___0, 0);
  }
#line 992
  return (__cil_tmp27);
  case_4163: /* CIL Label */ 
#line 995
  if (data___0 == (void *)0) {
#line 996
    psf->error = 30;
#line 996
    return (psf->error);
  } else
#line 995
  if (datasize != (int )sizeof(double ) * psf->sf.channels) {
#line 996
    psf->error = 30;
#line 996
    return (psf->error);
  }
  {
#line 997
  __cil_tmp28 = psf_calc_max_all_channels(psf, (double *)data___0, 1);
  }
#line 997
  return (__cil_tmp28);
  case_4164: /* CIL Label */ 
#line 1000
  if (data___0 == (void *)0) {
#line 1001
    psf->error = 30;
#line 1002
    return (0);
  } else
#line 1000
  if ((unsigned long )datasize != sizeof(double )) {
#line 1001
    psf->error = 30;
#line 1002
    return (0);
  }
  {
#line 1004
  __cil_tmp29 = psf_get_signal_max(psf, (double *)data___0);
  }
#line 1004
  return (__cil_tmp29);
  case_4165: /* CIL Label */ 
#line 1007
  if (data___0 == (void *)0) {
#line 1008
    psf->error = 30;
#line 1009
    return (0);
  } else
#line 1007
  if (datasize != (int )sizeof(double ) * psf->sf.channels) {
#line 1008
    psf->error = 30;
#line 1009
    return (0);
  }
  {
#line 1011
  __cil_tmp30 = psf_get_max_all_channels(psf, (double *)data___0);
  }
#line 1011
  return (__cil_tmp30);
  case_4192: /* CIL Label */ 
#line 1014
  if (psf->write_header) {
    {
#line 1015
    (*(psf->write_header))(psf, 1);
    }
  }
#line 1016
  goto switch_break___0;
  case_4193: /* CIL Label */ 
#line 1019
  if (datasize) {
#line 1019
    tmp___3 = 1;
  } else {
#line 1019
    tmp___3 = 0;
  }
#line 1019
  psf->auto_header = tmp___3;
#line 1020
  return (psf->auto_header);
#line 1021
  goto switch_break___0;
  case_4209: /* CIL Label */ 
  case_4208: /* CIL Label */ 
#line 1030
  goto switch_break___0;
  case_4256: /* CIL Label */ 
#line 1033
  if (data___0 == (void *)0) {
#line 1034
    psf->error = 30;
#line 1034
    return (psf->error);
  } else
#line 1033
  if (datasize != (int )sizeof(SF_DITHER_INFO )) {
#line 1034
    psf->error = 30;
#line 1034
    return (psf->error);
  }
  {
#line 1035
  memcpy(& psf->write_dither, data___0, sizeof(psf->write_dither));
  }
#line 1036
  if (psf->mode == 32) {
    {
    {
#line 1037
    dither_init(psf, 32);
    }
    }
  } else
#line 1036
  if (psf->mode == 48) {
    {
    {
#line 1037
    dither_init(psf, 32);
    }
    }
  }
#line 1038
  goto switch_break___0;
  case_4257: /* CIL Label */ 
#line 1041
  if (data___0 == (void *)0) {
#line 1042
    psf->error = 30;
#line 1042
    return (psf->error);
  } else
#line 1041
  if (datasize != (int )sizeof(SF_DITHER_INFO )) {
#line 1042
    psf->error = 30;
#line 1042
    return (psf->error);
  }
  {
#line 1043
  memcpy(& psf->read_dither, data___0, sizeof(psf->read_dither));
  }
#line 1044
  if (psf->mode == 16) {
    {
    {
#line 1045
    dither_init(psf, 16);
    }
    }
  } else
#line 1044
  if (psf->mode == 48) {
    {
    {
#line 1045
    dither_init(psf, 16);
    }
    }
  }
#line 1046
  goto switch_break___0;
  case_4224: /* CIL Label */ 
#line 1049
  if (psf->mode != 32) {
#line 1049
    if (psf->mode != 48) {
#line 1050
      return (1);
    }
  }
#line 1051
  if ((unsigned long )datasize != sizeof(sf_count_t )) {
#line 1052
    return (1);
  }
  {
#line 1055
  position = *((sf_count_t *)data___0);
#line 1057
  __cil_tmp33 = sf_seek(sndfile, position, 0);
  }
#line 1057
  if (__cil_tmp33 != position) {
#line 1058
    return (1);
  }
  {
#line 1060
  psf->sf.frames = position;
#line 1062
  position = psf_fseek(psf, (sf_count_t )0, 1);
#line 1064
  __cil_tmp35 = psf_ftruncate(psf, position);
  }
#line 1064
  return (__cil_tmp35);

#line 1066
  goto switch_break___0;
  case_4240: /* CIL Label */ 
#line 1069
  if (data___0 == (void *)0) {
#line 1070
    psf->error = 30;
#line 1070
    return (psf->error);
  } else
#line 1069
  if ((unsigned long )datasize != sizeof(sf_count_t )) {
#line 1070
    psf->error = 30;
#line 1070
    return (psf->error);
  }
#line 1072
  if ((psf->sf.format & 268369920) != 262144) {
#line 1073
    psf->error = 30;
#line 1073
    return (psf->error);
  }
  {
#line 1075
  psf->dataoffset = *((sf_count_t *)data___0);
#line 1076
  sf_seek(sndfile, (sf_count_t )0, 1);
  }
#line 1077
  goto switch_break___0;
  case_4272: /* CIL Label */ 
#line 1080
  if (data___0 == (void *)0) {
#line 1081
    psf->error = 30;
#line 1081
    return (psf->error);
  } else
#line 1080
  if ((unsigned long )datasize != sizeof(SF_EMBED_FILE_INFO )) {
#line 1081
    psf->error = 30;
#line 1081
    return (psf->error);
  }
#line 1083
  ((SF_EMBED_FILE_INFO *)data___0)->offset = psf->fileoffset;
#line 1084
  ((SF_EMBED_FILE_INFO *)data___0)->length = psf->filelength;
#line 1085
  goto switch_break___0;
  case_24577: /* CIL Label */ 
#line 1089
  if (datasize) {
#line 1089
    tmp___4 = 1;
  } else {
#line 1089
    tmp___4 = 0;
  }
#line 1089
  psf->ieee_replace = tmp___4;
#line 1090
  if ((psf->sf.format & 65535) == 6) {
    {
#line 1091
    float32_init(psf);
    }
  } else
#line 1092
  if ((psf->sf.format & 65535) == 7) {
    {
#line 1093
    double64_init(psf);
    }
  } else {
#line 1095
    psf->error = 30;
#line 1095
    return (psf->error);
  }
#line 1096
  goto switch_break___0;
  case_4288: /* CIL Label */ 
#line 1100
  if (datasize) {
#line 1100
    tmp___5 = 1;
  } else {
#line 1100
    tmp___5 = 0;
  }
#line 1100
  psf->add_clipping = tmp___5;
#line 1101
  return (psf->add_clipping);
  case_4289: /* CIL Label */ 
#line 1104
  return (psf->add_clipping);
  case_4320: /* CIL Label */ 
#line 1107
  if (data___0 == (void *)0) {
#line 1108
    psf->error = 30;
#line 1109
    return (0);
  } else
#line 1107
  if ((unsigned long )datasize != sizeof(SF_LOOP_INFO )) {
#line 1108
    psf->error = 30;
#line 1109
    return (0);
  }

#line 1111
  if (psf->loop_info == (void *)0) {
#line 1112
    return (0);
  }
  {
#line 1113
  memcpy(data___0, psf->loop_info, sizeof(SF_LOOP_INFO ));
  }
#line 1114
  return (1);
  case_4337: /* CIL Label */ 
#line 1117
  format___0 = psf->sf.format & 268369920;
#line 1120
  if (format___0 != 65536) {
#line 1120
    if (format___0 != 1245184) {
#line 1121
      return (0);
    }
  }

#line 1125
  if (psf->mode != 32) {
#line 1125
    if (psf->mode != 48) {
#line 1126
      return (0);
    }
  }
#line 1128
  if (psf->broadcast_var == (void *)0) {
#line 1128
    if (psf->have_written) {
#line 1129
      psf->error = 47;
#line 1130
      return (0);
    }
  }
  {
#line 1140
  broadcast_var_set(psf, data___0, (size_t )datasize);
  }
#line 1143
  if (psf->write_header) {
    {
#line 1144
    (*(psf->write_header))(psf, 1);
    }
  }
#line 1145
  return (1);
  case_4336: /* CIL Label */ 
#line 1148
  if (data___0 == (void *)0) {
#line 1149
    psf->error = 30;
#line 1150
    return (0);
  }
  {
#line 1157
  __cil_tmp39 = broadcast_var_get(psf, data___0, (size_t )datasize);
  }
#line 1157
  return (__cil_tmp39);
  case_4304: /* CIL Label */ 
#line 1161
  if (data___0 == (void *)0) {
#line 1162
    psf->error = 30;
#line 1163
    return (0);
  } else
#line 1161
  if ((unsigned long )datasize != sizeof(SF_INSTRUMENT )) {
#line 1162
    psf->error = 30;
#line 1163
    return (0);
  }

#line 1165
  if (psf->instrument == (void *)0) {
#line 1166
    return (0);
  }
  {
#line 1167
  memcpy(data___0, psf->instrument, sizeof(SF_INSTRUMENT ));
  }
#line 1168
  return (1);
  case_4305: /* CIL Label */ 
#line 1172
  if (psf->have_written) {
#line 1173
    psf->error = 47;
#line 1174
    return (0);
  }

#line 1176
  if (data___0 == (void *)0) {
#line 1177
    psf->error = 30;
#line 1178
    return (0);
  } else
#line 1176
  if ((unsigned long )datasize != sizeof(SF_INSTRUMENT )) {
#line 1177
    psf->error = 30;
#line 1178
    return (0);
  }
  {
#line 1181
  psf->instrument = psf_instrument_alloc();
  }
#line 1181
  if (psf->instrument == (void *)0) {
#line 1181
    if (psf->instrument == (void *)0) {
#line 1182
      psf->error = 16;
#line 1183
      return (0);
    }
  }
  {
#line 1185
  memcpy(psf->instrument, data___0, sizeof(SF_INSTRUMENT ));
  }
#line 1186
  return (1);
  case_4368: /* CIL Label */ 
#line 1189
  return (psf->data_endswap);
  switch_default: /* CIL Label */ 
#line 1193
  if (psf->command) {
    {
#line 1194
    __cil_tmp41 = (*(psf->command))(psf, command, data___0, datasize);
    }
#line 1194
    return (__cil_tmp41);
  }
  {
#line 1196
  psf_log_printf(psf, "*** sf_command : cmd = 0x%X\n", command);
#line 1197
  psf->error = 30;
  }
#line 1197
  return (psf->error);
  switch_break___0: /* CIL Label */ ;
  }

#line 1200
  return (0);
}
}
#line 1207 "/root/libsndfile/src/sndfile.c"
sf_count_t sf_seek(SNDFILE *sndfile , sf_count_t offset , int whence ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t seek_from_start ;
  sf_count_t retval ;
  int __cil_tmp7 ;
  int new_mode ;
  int tmp ;
  sf_count_t __cil_tmp10 ;

  {
#line 1209
  seek_from_start = (sf_count_t )0;
#line 1211
  if (sndfile == (void *)0) {
#line 1211
    sf_errno = 10;
#line 1211
    return ((sf_count_t )0);
  }
  {
#line 1211
  psf = (SF_PRIVATE *)sndfile;
#line 1211
  __cil_tmp7 = psf_file_valid(psf);
  }
#line 1211
  if (psf->virtual_io == 0) {
#line 1211
    if (__cil_tmp7 == 0) {
#line 1211
      psf->error = 13;
#line 1211
      return ((sf_count_t )0);
    }
  }

#line 1211
  if (psf->Magick != 305447134) {
#line 1211
    psf->error = 10;
#line 1211
    return ((sf_count_t )0);
  }

#line 1211
  if (1) {
#line 1211
    psf->error = 0;
  }

#line 1213
  if (! psf->sf.seekable) {
#line 1214
    psf->error = 39;
#line 1215
    return ((sf_count_t )(- 1));
  }

#line 1221
  if ((whence & 48) == 32) {
#line 1221
    if (psf->mode == 16) {
#line 1223
      psf->error = 41;
#line 1224
      return ((sf_count_t )(- 1));
    } else {
#line 1221
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1221
  if ((whence & 48) == 16) {
#line 1221
    if (psf->mode == 32) {
#line 1223
      psf->error = 41;
#line 1224
      return ((sf_count_t )(- 1));
    }
  }

  {
#line 1235
  if (whence == 48) {
#line 1235
    goto case_48;
  }
#line 1235
  if (whence == 32) {
#line 1235
    goto case_48;
  }
#line 1235
  if (whence == 16) {
#line 1235
    goto case_48;
  }
#line 1235
  if (whence == 0) {
#line 1235
    goto case_48;
  }
#line 1240
  if (whence == 1) {
#line 1240
    goto case_1;
  }
#line 1255
  if (whence == 17) {
#line 1255
    goto case_17;
  }
#line 1261
  if (whence == 33) {
#line 1261
    goto case_33;
  }
#line 1270
  if (whence == 34) {
#line 1270
    goto case_34;
  }
#line 1270
  if (whence == 18) {
#line 1270
    goto case_34;
  }
#line 1270
  if (whence == 2) {
#line 1270
    goto case_34;
  }
#line 1274
  goto switch_default;
  case_48: /* CIL Label */ 
  case_32: /* CIL Label */ 
  case_16: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 1236
  seek_from_start = offset;
#line 1237
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1241
  if (offset == 0L) {
#line 1242
    if (psf->mode == 16) {
#line 1243
      return (psf->read_current);
    }
#line 1244
    if (psf->mode == 32) {
#line 1245
      return (psf->write_current);
    }
  }

#line 1247
  if (psf->mode == 16) {
#line 1248
    seek_from_start = psf->read_current + offset;
  } else
#line 1249
  if (psf->mode == 32) {
#line 1250
    seek_from_start = psf->write_current + offset;
  } else
#line 1249
  if (psf->mode == 48) {
#line 1250
    seek_from_start = psf->write_current + offset;
  } else {
#line 1252
    psf->error = 40;
  }
#line 1253
  goto switch_break;
  case_17: /* CIL Label */ 
#line 1256
  if (offset == 0L) {
#line 1257
    return (psf->read_current);
  }
#line 1258
  seek_from_start = psf->read_current + offset;
#line 1259
  goto switch_break;
  case_33: /* CIL Label */ 
#line 1262
  if (offset == 0L) {
#line 1263
    return (psf->write_current);
  }
#line 1264
  seek_from_start = psf->write_current + offset;
#line 1265
  goto switch_break;
  case_34: /* CIL Label */ 
  case_18: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 1271
  seek_from_start = psf->sf.frames + offset;
#line 1272
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1275
  psf->error = 38;
#line 1276
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }

#line 1279
  if (psf->error) {
#line 1280
    return ((sf_count_t )(- 1));
  }
#line 1282
  if (psf->mode == 48) {
    _L___52: /* CIL Label */ 
#line 1283
    if (seek_from_start < 0L) {
#line 1284
      psf->error = 38;
#line 1285
      return ((sf_count_t )(- 1));
    }

  } else
#line 1282
  if (psf->mode == 32) {
#line 1282
    goto _L___52;
  } else
#line 1288
  if (seek_from_start < 0L) {
#line 1289
    psf->error = 38;
#line 1290
    return ((sf_count_t )(- 1));
  } else
#line 1288
  if (seek_from_start > psf->sf.frames) {
#line 1289
    psf->error = 38;
#line 1290
    return ((sf_count_t )(- 1));
  }

#line 1293
  if (psf->seek) {
#line 1294
    if (whence & 48) {
#line 1294
      tmp = whence & 48;
    } else {
#line 1294
      tmp = psf->mode;
    }
    {
#line 1294
    new_mode = tmp;
#line 1296
    retval = (*(psf->seek))(psf, new_mode, seek_from_start);
    }
    {
#line 1299
    if (new_mode == 16) {
#line 1299
      goto case_16___0;
    }
#line 1302
    if (new_mode == 32) {
#line 1302
      goto case_32___0;
    }
#line 1305
    if (new_mode == 48) {
#line 1305
      goto case_48___0;
    }
#line 1298
    goto switch_break___0;
    case_16___0: /* CIL Label */ 
#line 1300
    psf->read_current = retval;
#line 1301
    goto switch_break___0;
    case_32___0: /* CIL Label */ 
#line 1303
    psf->write_current = retval;
#line 1304
    goto switch_break___0;
    case_48___0: /* CIL Label */ 
#line 1306
    psf->read_current = retval;
#line 1307
    psf->write_current = retval;
#line 1308
    new_mode = 16;
#line 1309
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 1312
    psf->last_op = new_mode;
#line 1314
    return (retval);
  }
#line 1317
  psf->error = 40;
#line 1318
  return ((sf_count_t )(- 1));
}
}
#line 1325 "/root/libsndfile/src/sndfile.c"
char const   *sf_get_string(SNDFILE *sndfile , int str_type ) 
{ 
  SF_PRIVATE *psf ;
  char const   *__cil_tmp4 ;

  {
#line 1328
  psf = (SF_PRIVATE *)sndfile;
#line 1328
  if (psf == (void *)0) {
#line 1329
    return ((char const   *)((void *)0));
  }
#line 1330
  if (psf->Magick != 305447134) {
#line 1331
    return ((char const   *)((void *)0));
  }
  {
#line 1333
  __cil_tmp4 = psf_get_string(psf, str_type);
  }
#line 1333
  return (__cil_tmp4);
}
}
#line 1337 "/root/libsndfile/src/sndfile.c"
int sf_set_string(SNDFILE *sndfile , int str_type , char const   *str ) 
{ 
  SF_PRIVATE *psf ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 1340
  if (sndfile == (void *)0) {
#line 1340
    sf_errno = 10;
#line 1340
    return (0);
  }
  {
#line 1340
  psf = (SF_PRIVATE *)sndfile;
#line 1340
  __cil_tmp5 = psf_file_valid(psf);
  }
#line 1340
  if (psf->virtual_io == 0) {
#line 1340
    if (__cil_tmp5 == 0) {
#line 1340
      psf->error = 13;
#line 1340
      return (0);
    }
  }

#line 1340
  if (psf->Magick != 305447134) {
#line 1340
    psf->error = 10;
#line 1340
    return (0);
  }

#line 1340
  if (1) {
#line 1340
    psf->error = 0;
  }
  {
#line 1342
  __cil_tmp6 = psf_set_string(psf, str_type, str);
  }
#line 1342
  return (__cil_tmp6);
}
}
#line 1349 "/root/libsndfile/src/sndfile.c"
sf_count_t sf_read_raw(SNDFILE *sndfile , void *ptr , sf_count_t bytes ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t count ;
  sf_count_t extra ;
  int bytewidth ;
  int blockwidth ;
  int __cil_tmp9 ;
  int tmp ;
  int tmp___0 ;
  sf_count_t __cil_tmp12 ;

  {
#line 1354
  if (sndfile == (void *)0) {
#line 1354
    sf_errno = 10;
#line 1354
    return ((sf_count_t )0);
  }
  {
#line 1354
  psf = (SF_PRIVATE *)sndfile;
#line 1354
  __cil_tmp9 = psf_file_valid(psf);
  }
#line 1354
  if (psf->virtual_io == 0) {
#line 1354
    if (__cil_tmp9 == 0) {
#line 1354
      psf->error = 13;
#line 1354
      return ((sf_count_t )0);
    }
  }

#line 1354
  if (psf->Magick != 305447134) {
#line 1354
    psf->error = 10;
#line 1354
    return ((sf_count_t )0);
  }

#line 1354
  if (1) {
#line 1354
    psf->error = 0;
  }

#line 1356
  if (psf->bytewidth > 0) {
#line 1356
    tmp = psf->bytewidth;
  } else {
#line 1356
    tmp = 1;
  }
#line 1356
  bytewidth = tmp;
#line 1357
  if (psf->blockwidth > 0) {
#line 1357
    tmp___0 = psf->blockwidth;
  } else {
#line 1357
    tmp___0 = 1;
  }
#line 1357
  blockwidth = tmp___0;
#line 1359
  if (psf->mode == 32) {
#line 1360
    psf->error = 21;
#line 1361
    return ((sf_count_t )0);
  }

#line 1364
  if (bytes < 0L) {
    {
    {
#line 1365
    psf_memset(ptr, 0, bytes);
    }
    }
#line 1366
    return ((sf_count_t )0);
  } else
#line 1364
  if (psf->read_current >= psf->datalength) {
    {
    {
#line 1365
    psf_memset(ptr, 0, bytes);
    }
    }
#line 1366
    return ((sf_count_t )0);
  }

#line 1369
  if (bytes % (long )(psf->sf.channels * bytewidth)) {
#line 1370
    psf->error = 18;
#line 1371
    return ((sf_count_t )0);
  }
  {
#line 1374
  count = psf_fread(ptr, (sf_count_t )1, bytes, psf);
  }
#line 1376
  if (psf->read_current + count / (long )blockwidth <= psf->sf.frames) {
#line 1377
    psf->read_current += count / (long )blockwidth;
  } else {
    {
#line 1379
    count = (psf->sf.frames - psf->read_current) * (long )blockwidth;
#line 1380
    extra = bytes - count;
#line 1381
    psf_memset((char *)ptr + count, 0, extra);
#line 1382
    psf->read_current = psf->sf.frames;
    }
  }
#line 1385
  psf->last_op = 16;
#line 1387
  return (count);
}
}
#line 1394 "/root/libsndfile/src/sndfile.c"
sf_count_t sf_read_short(SNDFILE *sndfile , short *ptr , sf_count_t len ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t count ;
  sf_count_t extra ;
  int __cil_tmp7 ;
  sf_count_t __cil_tmp8 ;
  sf_count_t __cil_tmp9 ;

  {
#line 1398
  if (sndfile == (void *)0) {
#line 1398
    sf_errno = 10;
#line 1398
    return ((sf_count_t )0);
  }
  {
#line 1398
  psf = (SF_PRIVATE *)sndfile;
#line 1398
  __cil_tmp7 = psf_file_valid(psf);
  }
#line 1398
  if (psf->virtual_io == 0) {
#line 1398
    if (__cil_tmp7 == 0) {
#line 1398
      psf->error = 13;
#line 1398
      return ((sf_count_t )0);
    }
  }

#line 1398
  if (psf->Magick != 305447134) {
#line 1398
    psf->error = 10;
#line 1398
    return ((sf_count_t )0);
  }

#line 1398
  if (1) {
#line 1398
    psf->error = 0;
  }

#line 1400
  if (psf->mode == 32) {
#line 1401
    psf->error = 21;
#line 1402
    return ((sf_count_t )0);
  }

#line 1405
  if (len % (long )psf->sf.channels) {
#line 1406
    psf->error = 18;
#line 1407
    return ((sf_count_t )0);
  }

#line 1410
  if (len <= 0L) {
    {
    {
#line 1411
    psf_memset(ptr, 0, (sf_count_t )((unsigned long )len * sizeof(short )));
    }
    }
#line 1412
    return ((sf_count_t )0);
  } else
#line 1410
  if (psf->read_current >= psf->sf.frames) {
    {
    {
#line 1411
    psf_memset(ptr, 0, (sf_count_t )((unsigned long )len * sizeof(short )));
    }
    }
#line 1412
    return ((sf_count_t )0);
  }

#line 1415
  if (psf->read_short == (void *)0) {
#line 1416
    psf->error = 17;
#line 1417
    return ((sf_count_t )0);
  } else
#line 1415
  if (psf->seek == (void *)0) {
#line 1416
    psf->error = 17;
#line 1417
    return ((sf_count_t )0);
  }

#line 1420
  if (psf->last_op != 16) {
    {
#line 1421
    __cil_tmp8 = (*(psf->seek))(psf, 16, psf->read_current);
    }
#line 1421
    if (__cil_tmp8 < 0L) {
#line 1422
      return ((sf_count_t )0);
    }
  }
  {
#line 1424
  count = (*(psf->read_short))(psf, ptr, len);
  }
#line 1426
  if (psf->read_current + count / (long )psf->sf.channels <= psf->sf.frames) {
#line 1427
    psf->read_current += count / (long )psf->sf.channels;
  } else {
    {
#line 1429
    count = (psf->sf.frames - psf->read_current) * (long )psf->sf.channels;
#line 1430
    extra = len - count;
#line 1431
    psf_memset(ptr + count, 0, (sf_count_t )((unsigned long )extra * sizeof(short )));
#line 1432
    psf->read_current = psf->sf.frames;
    }
  }
#line 1435
  psf->last_op = 16;
#line 1437
  return (count);
}
}
#line 1441 "/root/libsndfile/src/sndfile.c"
sf_count_t sf_readf_short(SNDFILE *sndfile , short *ptr , sf_count_t frames ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t count ;
  sf_count_t extra ;
  int __cil_tmp7 ;
  sf_count_t __cil_tmp8 ;
  sf_count_t __cil_tmp9 ;

  {
#line 1445
  if (sndfile == (void *)0) {
#line 1445
    sf_errno = 10;
#line 1445
    return ((sf_count_t )0);
  }
  {
#line 1445
  psf = (SF_PRIVATE *)sndfile;
#line 1445
  __cil_tmp7 = psf_file_valid(psf);
  }
#line 1445
  if (psf->virtual_io == 0) {
#line 1445
    if (__cil_tmp7 == 0) {
#line 1445
      psf->error = 13;
#line 1445
      return ((sf_count_t )0);
    }
  }

#line 1445
  if (psf->Magick != 305447134) {
#line 1445
    psf->error = 10;
#line 1445
    return ((sf_count_t )0);
  }

#line 1445
  if (1) {
#line 1445
    psf->error = 0;
  }

#line 1447
  if (psf->mode == 32) {
#line 1448
    psf->error = 21;
#line 1449
    return ((sf_count_t )0);
  }

#line 1452
  if (frames <= 0L) {
    {
    {
#line 1453
    psf_memset(ptr, 0, (sf_count_t )((unsigned long )(frames * (long )psf->sf.channels) * sizeof(short )));
    }
    }
#line 1454
    return ((sf_count_t )0);
  } else
#line 1452
  if (psf->read_current >= psf->sf.frames) {
    {
    {
#line 1453
    psf_memset(ptr, 0, (sf_count_t )((unsigned long )(frames * (long )psf->sf.channels) * sizeof(short )));
    }
    }
#line 1454
    return ((sf_count_t )0);
  }

#line 1457
  if (psf->read_short == (void *)0) {
#line 1458
    psf->error = 17;
#line 1459
    return ((sf_count_t )0);
  } else
#line 1457
  if (psf->seek == (void *)0) {
#line 1458
    psf->error = 17;
#line 1459
    return ((sf_count_t )0);
  }

#line 1462
  if (psf->last_op != 16) {
    {
#line 1463
    __cil_tmp8 = (*(psf->seek))(psf, 16, psf->read_current);
    }
#line 1463
    if (__cil_tmp8 < 0L) {
#line 1464
      return ((sf_count_t )0);
    }
  }
  {
#line 1466
  count = (*(psf->read_short))(psf, ptr, frames * (long )psf->sf.channels);
  }
#line 1468
  if (psf->read_current + count / (long )psf->sf.channels <= psf->sf.frames) {
#line 1469
    psf->read_current += count / (long )psf->sf.channels;
  } else {
    {
#line 1471
    count = (psf->sf.frames - psf->read_current) * (long )psf->sf.channels;
#line 1472
    extra = frames * (long )psf->sf.channels - count;
#line 1473
    psf_memset(ptr + count, 0, (sf_count_t )((unsigned long )extra * sizeof(short )));
#line 1474
    psf->read_current = psf->sf.frames;
    }
  }
#line 1477
  psf->last_op = 16;
#line 1479
  return (count / (long )psf->sf.channels);
}
}
#line 1486 "/root/libsndfile/src/sndfile.c"
sf_count_t sf_read_int(SNDFILE *sndfile , int *ptr , sf_count_t len ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t count ;
  sf_count_t extra ;
  int __cil_tmp7 ;
  sf_count_t __cil_tmp8 ;
  sf_count_t __cil_tmp9 ;

  {
#line 1490
  if (sndfile == (void *)0) {
#line 1490
    sf_errno = 10;
#line 1490
    return ((sf_count_t )0);
  }
  {
#line 1490
  psf = (SF_PRIVATE *)sndfile;
#line 1490
  __cil_tmp7 = psf_file_valid(psf);
  }
#line 1490
  if (psf->virtual_io == 0) {
#line 1490
    if (__cil_tmp7 == 0) {
#line 1490
      psf->error = 13;
#line 1490
      return ((sf_count_t )0);
    }
  }

#line 1490
  if (psf->Magick != 305447134) {
#line 1490
    psf->error = 10;
#line 1490
    return ((sf_count_t )0);
  }

#line 1490
  if (1) {
#line 1490
    psf->error = 0;
  }

#line 1492
  if (psf->mode == 32) {
#line 1493
    psf->error = 21;
#line 1494
    return ((sf_count_t )0);
  }

#line 1497
  if (len % (long )psf->sf.channels) {
#line 1498
    psf->error = 18;
#line 1499
    return ((sf_count_t )0);
  }

#line 1502
  if (len <= 0L) {
    {
    {
#line 1503
    psf_memset(ptr, 0, (sf_count_t )((unsigned long )len * sizeof(int )));
    }
    }
#line 1504
    return ((sf_count_t )0);
  } else
#line 1502
  if (psf->read_current >= psf->sf.frames) {
    {
    {
#line 1503
    psf_memset(ptr, 0, (sf_count_t )((unsigned long )len * sizeof(int )));
    }
    }
#line 1504
    return ((sf_count_t )0);
  }

#line 1507
  if (psf->read_int == (void *)0) {
#line 1508
    psf->error = 17;
#line 1509
    return ((sf_count_t )0);
  } else
#line 1507
  if (psf->seek == (void *)0) {
#line 1508
    psf->error = 17;
#line 1509
    return ((sf_count_t )0);
  }

#line 1512
  if (psf->last_op != 16) {
    {
#line 1513
    __cil_tmp8 = (*(psf->seek))(psf, 16, psf->read_current);
    }
#line 1513
    if (__cil_tmp8 < 0L) {
#line 1514
      return ((sf_count_t )0);
    }
  }
  {
#line 1516
  count = (*(psf->read_int))(psf, ptr, len);
  }
#line 1518
  if (psf->read_current + count / (long )psf->sf.channels <= psf->sf.frames) {
#line 1519
    psf->read_current += count / (long )psf->sf.channels;
  } else {
    {
#line 1521
    count = (psf->sf.frames - psf->read_current) * (long )psf->sf.channels;
#line 1522
    extra = len - count;
#line 1523
    psf_memset(ptr + count, 0, (sf_count_t )((unsigned long )extra * sizeof(int )));
#line 1524
    psf->read_current = psf->sf.frames;
    }
  }
#line 1527
  psf->last_op = 16;
#line 1529
  return (count);
}
}
#line 1533 "/root/libsndfile/src/sndfile.c"
sf_count_t sf_readf_int(SNDFILE *sndfile , int *ptr , sf_count_t frames ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t count ;
  sf_count_t extra ;
  int __cil_tmp7 ;
  sf_count_t __cil_tmp8 ;
  sf_count_t __cil_tmp9 ;

  {
#line 1537
  if (sndfile == (void *)0) {
#line 1537
    sf_errno = 10;
#line 1537
    return ((sf_count_t )0);
  }
  {
#line 1537
  psf = (SF_PRIVATE *)sndfile;
#line 1537
  __cil_tmp7 = psf_file_valid(psf);
  }
#line 1537
  if (psf->virtual_io == 0) {
#line 1537
    if (__cil_tmp7 == 0) {
#line 1537
      psf->error = 13;
#line 1537
      return ((sf_count_t )0);
    }
  }

#line 1537
  if (psf->Magick != 305447134) {
#line 1537
    psf->error = 10;
#line 1537
    return ((sf_count_t )0);
  }

#line 1537
  if (1) {
#line 1537
    psf->error = 0;
  }

#line 1539
  if (psf->mode == 32) {
#line 1540
    psf->error = 21;
#line 1541
    return ((sf_count_t )0);
  }

#line 1544
  if (frames <= 0L) {
    {
    {
#line 1545
    psf_memset(ptr, 0, (sf_count_t )((unsigned long )(frames * (long )psf->sf.channels) * sizeof(int )));
    }
    }
#line 1546
    return ((sf_count_t )0);
  } else
#line 1544
  if (psf->read_current >= psf->sf.frames) {
    {
    {
#line 1545
    psf_memset(ptr, 0, (sf_count_t )((unsigned long )(frames * (long )psf->sf.channels) * sizeof(int )));
    }
    }
#line 1546
    return ((sf_count_t )0);
  }

#line 1549
  if (psf->read_int == (void *)0) {
#line 1550
    psf->error = 17;
#line 1551
    return ((sf_count_t )0);
  } else
#line 1549
  if (psf->seek == (void *)0) {
#line 1550
    psf->error = 17;
#line 1551
    return ((sf_count_t )0);
  }

#line 1554
  if (psf->last_op != 16) {
    {
#line 1555
    __cil_tmp8 = (*(psf->seek))(psf, 16, psf->read_current);
    }
#line 1555
    if (__cil_tmp8 < 0L) {
#line 1556
      return ((sf_count_t )0);
    }
  }
  {
#line 1558
  count = (*(psf->read_int))(psf, ptr, frames * (long )psf->sf.channels);
  }
#line 1560
  if (psf->read_current + count / (long )psf->sf.channels <= psf->sf.frames) {
#line 1561
    psf->read_current += count / (long )psf->sf.channels;
  } else {
    {
#line 1563
    count = (psf->sf.frames - psf->read_current) * (long )psf->sf.channels;
#line 1564
    extra = frames * (long )psf->sf.channels - count;
#line 1565
    psf_memset(ptr + count, 0, (sf_count_t )((unsigned long )extra * sizeof(int )));
#line 1566
    psf->read_current = psf->sf.frames;
    }
  }
#line 1569
  psf->last_op = 16;
#line 1571
  return (count / (long )psf->sf.channels);
}
}
#line 1578 "/root/libsndfile/src/sndfile.c"
sf_count_t sf_read_float(SNDFILE *sndfile , float *ptr , sf_count_t len ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t count ;
  sf_count_t extra ;
  int __cil_tmp7 ;
  sf_count_t __cil_tmp8 ;
  sf_count_t __cil_tmp9 ;

  {
#line 1582
  if (sndfile == (void *)0) {
#line 1582
    sf_errno = 10;
#line 1582
    return ((sf_count_t )0);
  }
  {
#line 1582
  psf = (SF_PRIVATE *)sndfile;
#line 1582
  __cil_tmp7 = psf_file_valid(psf);
  }
#line 1582
  if (psf->virtual_io == 0) {
#line 1582
    if (__cil_tmp7 == 0) {
#line 1582
      psf->error = 13;
#line 1582
      return ((sf_count_t )0);
    }
  }

#line 1582
  if (psf->Magick != 305447134) {
#line 1582
    psf->error = 10;
#line 1582
    return ((sf_count_t )0);
  }

#line 1582
  if (1) {
#line 1582
    psf->error = 0;
  }

#line 1584
  if (psf->mode == 32) {
#line 1585
    psf->error = 21;
#line 1586
    return ((sf_count_t )0);
  }

#line 1589
  if (len % (long )psf->sf.channels) {
#line 1590
    psf->error = 18;
#line 1591
    return ((sf_count_t )0);
  }

#line 1594
  if (len <= 0L) {
    {
    {
#line 1595
    psf_memset(ptr, 0, (sf_count_t )((unsigned long )len * sizeof(float )));
    }
    }
#line 1596
    return ((sf_count_t )0);
  } else
#line 1594
  if (psf->read_current >= psf->sf.frames) {
    {
    {
#line 1595
    psf_memset(ptr, 0, (sf_count_t )((unsigned long )len * sizeof(float )));
    }
    }
#line 1596
    return ((sf_count_t )0);
  }

#line 1599
  if (psf->read_float == (void *)0) {
#line 1600
    psf->error = 17;
#line 1601
    return ((sf_count_t )0);
  } else
#line 1599
  if (psf->seek == (void *)0) {
#line 1600
    psf->error = 17;
#line 1601
    return ((sf_count_t )0);
  }

#line 1604
  if (psf->last_op != 16) {
    {
#line 1605
    __cil_tmp8 = (*(psf->seek))(psf, 16, psf->read_current);
    }
#line 1605
    if (__cil_tmp8 < 0L) {
#line 1606
      return ((sf_count_t )0);
    }
  }
  {
#line 1608
  count = (*(psf->read_float))(psf, ptr, len);
  }
#line 1610
  if (psf->read_current + count / (long )psf->sf.channels <= psf->sf.frames) {
#line 1611
    psf->read_current += count / (long )psf->sf.channels;
  } else {
    {
#line 1613
    count = (psf->sf.frames - psf->read_current) * (long )psf->sf.channels;
#line 1614
    extra = len - count;
#line 1615
    psf_memset(ptr + count, 0, (sf_count_t )((unsigned long )extra * sizeof(float )));
#line 1616
    psf->read_current = psf->sf.frames;
    }
  }
#line 1619
  psf->last_op = 16;
#line 1621
  return (count);
}
}
#line 1625 "/root/libsndfile/src/sndfile.c"
sf_count_t sf_readf_float(SNDFILE *sndfile , float *ptr , sf_count_t frames ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t count ;
  sf_count_t extra ;
  int __cil_tmp7 ;
  sf_count_t __cil_tmp8 ;
  sf_count_t __cil_tmp9 ;

  {
#line 1629
  if (sndfile == (void *)0) {
#line 1629
    sf_errno = 10;
#line 1629
    return ((sf_count_t )0);
  }
  {
#line 1629
  psf = (SF_PRIVATE *)sndfile;
#line 1629
  __cil_tmp7 = psf_file_valid(psf);
  }
#line 1629
  if (psf->virtual_io == 0) {
#line 1629
    if (__cil_tmp7 == 0) {
#line 1629
      psf->error = 13;
#line 1629
      return ((sf_count_t )0);
    }
  }

#line 1629
  if (psf->Magick != 305447134) {
#line 1629
    psf->error = 10;
#line 1629
    return ((sf_count_t )0);
  }

#line 1629
  if (1) {
#line 1629
    psf->error = 0;
  }

#line 1631
  if (psf->mode == 32) {
#line 1632
    psf->error = 21;
#line 1633
    return ((sf_count_t )0);
  }

#line 1636
  if (frames <= 0L) {
    {
    {
#line 1637
    psf_memset(ptr, 0, (sf_count_t )((unsigned long )(frames * (long )psf->sf.channels) * sizeof(float )));
    }
    }
#line 1638
    return ((sf_count_t )0);
  } else
#line 1636
  if (psf->read_current >= psf->sf.frames) {
    {
    {
#line 1637
    psf_memset(ptr, 0, (sf_count_t )((unsigned long )(frames * (long )psf->sf.channels) * sizeof(float )));
    }
    }
#line 1638
    return ((sf_count_t )0);
  }

#line 1641
  if (psf->read_float == (void *)0) {
#line 1642
    psf->error = 17;
#line 1643
    return ((sf_count_t )0);
  } else
#line 1641
  if (psf->seek == (void *)0) {
#line 1642
    psf->error = 17;
#line 1643
    return ((sf_count_t )0);
  }

#line 1646
  if (psf->last_op != 16) {
    {
#line 1647
    __cil_tmp8 = (*(psf->seek))(psf, 16, psf->read_current);
    }
#line 1647
    if (__cil_tmp8 < 0L) {
#line 1648
      return ((sf_count_t )0);
    }
  }
  {
#line 1650
  count = (*(psf->read_float))(psf, ptr, frames * (long )psf->sf.channels);
  }
#line 1652
  if (psf->read_current + count / (long )psf->sf.channels <= psf->sf.frames) {
#line 1653
    psf->read_current += count / (long )psf->sf.channels;
  } else {
    {
#line 1655
    count = (psf->sf.frames - psf->read_current) * (long )psf->sf.channels;
#line 1656
    extra = frames * (long )psf->sf.channels - count;
#line 1657
    psf_memset(ptr + count, 0, (sf_count_t )((unsigned long )extra * sizeof(float )));
#line 1658
    psf->read_current = psf->sf.frames;
    }
  }
#line 1661
  psf->last_op = 16;
#line 1663
  return (count / (long )psf->sf.channels);
}
}
#line 1670 "/root/libsndfile/src/sndfile.c"
sf_count_t sf_read_double(SNDFILE *sndfile , double *ptr , sf_count_t len ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t count ;
  sf_count_t extra ;
  int __cil_tmp7 ;
  sf_count_t __cil_tmp8 ;
  sf_count_t __cil_tmp9 ;

  {
#line 1674
  if (sndfile == (void *)0) {
#line 1674
    sf_errno = 10;
#line 1674
    return ((sf_count_t )0);
  }
  {
#line 1674
  psf = (SF_PRIVATE *)sndfile;
#line 1674
  __cil_tmp7 = psf_file_valid(psf);
  }
#line 1674
  if (psf->virtual_io == 0) {
#line 1674
    if (__cil_tmp7 == 0) {
#line 1674
      psf->error = 13;
#line 1674
      return ((sf_count_t )0);
    }
  }

#line 1674
  if (psf->Magick != 305447134) {
#line 1674
    psf->error = 10;
#line 1674
    return ((sf_count_t )0);
  }

#line 1674
  if (1) {
#line 1674
    psf->error = 0;
  }

#line 1676
  if (psf->mode == 32) {
#line 1677
    psf->error = 21;
#line 1678
    return ((sf_count_t )0);
  }

#line 1681
  if (len % (long )psf->sf.channels) {
#line 1682
    psf->error = 18;
#line 1683
    return ((sf_count_t )0);
  }

#line 1686
  if (len <= 0L) {
    {
    {
#line 1687
    psf_memset(ptr, 0, (sf_count_t )((unsigned long )len * sizeof(double )));
    }
    }
#line 1688
    return ((sf_count_t )0);
  } else
#line 1686
  if (psf->read_current >= psf->sf.frames) {
    {
    {
#line 1687
    psf_memset(ptr, 0, (sf_count_t )((unsigned long )len * sizeof(double )));
    }
    }
#line 1688
    return ((sf_count_t )0);
  }

#line 1691
  if (psf->read_double == (void *)0) {
#line 1692
    psf->error = 17;
#line 1693
    return ((sf_count_t )0);
  } else
#line 1691
  if (psf->seek == (void *)0) {
#line 1692
    psf->error = 17;
#line 1693
    return ((sf_count_t )0);
  }

#line 1696
  if (psf->last_op != 16) {
    {
#line 1697
    __cil_tmp8 = (*(psf->seek))(psf, 16, psf->read_current);
    }
#line 1697
    if (__cil_tmp8 < 0L) {
#line 1698
      return ((sf_count_t )0);
    }
  }
  {
#line 1700
  count = (*(psf->read_double))(psf, ptr, len);
  }
#line 1702
  if (psf->read_current + count / (long )psf->sf.channels <= psf->sf.frames) {
#line 1703
    psf->read_current += count / (long )psf->sf.channels;
  } else {
    {
#line 1705
    count = (psf->sf.frames - psf->read_current) * (long )psf->sf.channels;
#line 1706
    extra = len - count;
#line 1707
    psf_memset(ptr + count, 0, (sf_count_t )((unsigned long )extra * sizeof(double )));
#line 1708
    psf->read_current = psf->sf.frames;
    }
  }
#line 1711
  psf->last_op = 16;
#line 1713
  return (count);
}
}
#line 1717 "/root/libsndfile/src/sndfile.c"
sf_count_t sf_readf_double(SNDFILE *sndfile , double *ptr , sf_count_t frames ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t count ;
  sf_count_t extra ;
  int __cil_tmp7 ;
  sf_count_t __cil_tmp8 ;
  sf_count_t __cil_tmp9 ;

  {
#line 1721
  if (sndfile == (void *)0) {
#line 1721
    sf_errno = 10;
#line 1721
    return ((sf_count_t )0);
  }
  {
#line 1721
  psf = (SF_PRIVATE *)sndfile;
#line 1721
  __cil_tmp7 = psf_file_valid(psf);
  }
#line 1721
  if (psf->virtual_io == 0) {
#line 1721
    if (__cil_tmp7 == 0) {
#line 1721
      psf->error = 13;
#line 1721
      return ((sf_count_t )0);
    }
  }

#line 1721
  if (psf->Magick != 305447134) {
#line 1721
    psf->error = 10;
#line 1721
    return ((sf_count_t )0);
  }

#line 1721
  if (1) {
#line 1721
    psf->error = 0;
  }

#line 1723
  if (psf->mode == 32) {
#line 1724
    psf->error = 21;
#line 1725
    return ((sf_count_t )0);
  }

#line 1728
  if (frames <= 0L) {
    {
    {
#line 1729
    psf_memset(ptr, 0, (sf_count_t )((unsigned long )(frames * (long )psf->sf.channels) * sizeof(double )));
    }
    }
#line 1730
    return ((sf_count_t )0);
  } else
#line 1728
  if (psf->read_current >= psf->sf.frames) {
    {
    {
#line 1729
    psf_memset(ptr, 0, (sf_count_t )((unsigned long )(frames * (long )psf->sf.channels) * sizeof(double )));
    }
    }
#line 1730
    return ((sf_count_t )0);
  }

#line 1733
  if (psf->read_double == (void *)0) {
#line 1734
    psf->error = 17;
#line 1735
    return ((sf_count_t )0);
  } else
#line 1733
  if (psf->seek == (void *)0) {
#line 1734
    psf->error = 17;
#line 1735
    return ((sf_count_t )0);
  }

#line 1738
  if (psf->last_op != 16) {
    {
#line 1739
    __cil_tmp8 = (*(psf->seek))(psf, 16, psf->read_current);
    }
#line 1739
    if (__cil_tmp8 < 0L) {
#line 1740
      return ((sf_count_t )0);
    }
  }
  {
#line 1742
  count = (*(psf->read_double))(psf, ptr, frames * (long )psf->sf.channels);
  }
#line 1744
  if (psf->read_current + count / (long )psf->sf.channels <= psf->sf.frames) {
#line 1745
    psf->read_current += count / (long )psf->sf.channels;
  } else {
    {
#line 1747
    count = (psf->sf.frames - psf->read_current) * (long )psf->sf.channels;
#line 1748
    extra = frames * (long )psf->sf.channels - count;
#line 1749
    psf_memset(ptr + count, 0, (sf_count_t )((unsigned long )extra * sizeof(double )));
#line 1750
    psf->read_current = psf->sf.frames;
    }
  }
#line 1753
  psf->last_op = 16;
#line 1755
  return (count / (long )psf->sf.channels);
}
}
#line 1762 "/root/libsndfile/src/sndfile.c"
sf_count_t sf_write_raw(SNDFILE *sndfile , void const   *ptr , sf_count_t len ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t count ;
  int bytewidth ;
  int blockwidth ;
  int __cil_tmp8 ;
  int tmp ;
  int tmp___0 ;
  sf_count_t __cil_tmp11 ;

  {
#line 1767
  if (sndfile == (void *)0) {
#line 1767
    sf_errno = 10;
#line 1767
    return ((sf_count_t )0);
  }
  {
#line 1767
  psf = (SF_PRIVATE *)sndfile;
#line 1767
  __cil_tmp8 = psf_file_valid(psf);
  }
#line 1767
  if (psf->virtual_io == 0) {
#line 1767
    if (__cil_tmp8 == 0) {
#line 1767
      psf->error = 13;
#line 1767
      return ((sf_count_t )0);
    }
  }

#line 1767
  if (psf->Magick != 305447134) {
#line 1767
    psf->error = 10;
#line 1767
    return ((sf_count_t )0);
  }

#line 1767
  if (1) {
#line 1767
    psf->error = 0;
  }

#line 1769
  if (psf->bytewidth > 0) {
#line 1769
    tmp = psf->bytewidth;
  } else {
#line 1769
    tmp = 1;
  }
#line 1769
  bytewidth = tmp;
#line 1770
  if (psf->blockwidth > 0) {
#line 1770
    tmp___0 = psf->blockwidth;
  } else {
#line 1770
    tmp___0 = 1;
  }
#line 1770
  blockwidth = tmp___0;
#line 1772
  if (psf->mode == 16) {
#line 1773
    psf->error = 22;
#line 1774
    return ((sf_count_t )0);
  }

#line 1777
  if (len % (long )(psf->sf.channels * bytewidth)) {
#line 1778
    psf->error = 19;
#line 1779
    return ((sf_count_t )0);
  }

#line 1782
  if (psf->write_header != (void *)0) {
#line 1782
    if (psf->have_written == 0) {
      {
#line 1783
      (*(psf->write_header))(psf, 0);
      }
    }
  }
  {
#line 1784
  psf->have_written = 1;
#line 1786
  count = psf_fwrite(ptr, (sf_count_t )1, len, psf);
#line 1788
  psf->write_current += count / (long )blockwidth;
  }
#line 1790
  if (psf->write_current > psf->sf.frames) {
#line 1791
    psf->sf.frames = psf->write_current;
  }
#line 1793
  psf->last_op = 32;
#line 1795
  return (count);
}
}
#line 1802 "/root/libsndfile/src/sndfile.c"
sf_count_t sf_write_short(SNDFILE *sndfile , short const   *ptr , sf_count_t len ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t count ;
  int __cil_tmp6 ;
  sf_count_t __cil_tmp7 ;
  sf_count_t __cil_tmp8 ;

  {
#line 1806
  if (sndfile == (void *)0) {
#line 1806
    sf_errno = 10;
#line 1806
    return ((sf_count_t )0);
  }
  {
#line 1806
  psf = (SF_PRIVATE *)sndfile;
#line 1806
  __cil_tmp6 = psf_file_valid(psf);
  }
#line 1806
  if (psf->virtual_io == 0) {
#line 1806
    if (__cil_tmp6 == 0) {
#line 1806
      psf->error = 13;
#line 1806
      return ((sf_count_t )0);
    }
  }

#line 1806
  if (psf->Magick != 305447134) {
#line 1806
    psf->error = 10;
#line 1806
    return ((sf_count_t )0);
  }

#line 1806
  if (1) {
#line 1806
    psf->error = 0;
  }

#line 1808
  if (psf->mode == 16) {
#line 1809
    psf->error = 22;
#line 1810
    return ((sf_count_t )0);
  }

#line 1813
  if (len % (long )psf->sf.channels) {
#line 1814
    psf->error = 19;
#line 1815
    return ((sf_count_t )0);
  }

#line 1818
  if (psf->write_short == (void *)0) {
#line 1819
    psf->error = 17;
#line 1820
    return ((sf_count_t )0);
  } else
#line 1818
  if (psf->seek == (void *)0) {
#line 1819
    psf->error = 17;
#line 1820
    return ((sf_count_t )0);
  }

#line 1823
  if (psf->last_op != 32) {
    {
#line 1824
    __cil_tmp7 = (*(psf->seek))(psf, 32, psf->write_current);
    }
#line 1824
    if (__cil_tmp7 < 0L) {
#line 1825
      return ((sf_count_t )0);
    }
  }
#line 1827
  if (psf->write_header != (void *)0) {
#line 1827
    if (psf->have_written == 0) {
      {
#line 1828
      (*(psf->write_header))(psf, 0);
      }
    }
  }
  {
#line 1829
  psf->have_written = 1;
#line 1831
  count = (*(psf->write_short))(psf, ptr, len);
#line 1833
  psf->write_current += count / (long )psf->sf.channels;
#line 1835
  psf->last_op = 32;
  }
#line 1837
  if (psf->write_header != (void *)0) {
#line 1837
    if (psf->auto_header) {
      {
#line 1838
      (*(psf->write_header))(psf, 1);
      }
    }
  }
#line 1840
  if (psf->write_current > psf->sf.frames) {
#line 1841
    psf->sf.frames = psf->write_current;
  }
#line 1843
  return (count);
}
}
#line 1847 "/root/libsndfile/src/sndfile.c"
sf_count_t sf_writef_short(SNDFILE *sndfile , short const   *ptr , sf_count_t frames ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t count ;
  int __cil_tmp6 ;
  sf_count_t __cil_tmp7 ;
  sf_count_t __cil_tmp8 ;

  {
#line 1851
  if (sndfile == (void *)0) {
#line 1851
    sf_errno = 10;
#line 1851
    return ((sf_count_t )0);
  }
  {
#line 1851
  psf = (SF_PRIVATE *)sndfile;
#line 1851
  __cil_tmp6 = psf_file_valid(psf);
  }
#line 1851
  if (psf->virtual_io == 0) {
#line 1851
    if (__cil_tmp6 == 0) {
#line 1851
      psf->error = 13;
#line 1851
      return ((sf_count_t )0);
    }
  }

#line 1851
  if (psf->Magick != 305447134) {
#line 1851
    psf->error = 10;
#line 1851
    return ((sf_count_t )0);
  }

#line 1851
  if (1) {
#line 1851
    psf->error = 0;
  }

#line 1853
  if (psf->mode == 16) {
#line 1854
    psf->error = 22;
#line 1855
    return ((sf_count_t )0);
  }

#line 1858
  if (psf->write_short == (void *)0) {
#line 1859
    psf->error = 17;
#line 1860
    return ((sf_count_t )0);
  } else
#line 1858
  if (psf->seek == (void *)0) {
#line 1859
    psf->error = 17;
#line 1860
    return ((sf_count_t )0);
  }

#line 1863
  if (psf->last_op != 32) {
    {
#line 1864
    __cil_tmp7 = (*(psf->seek))(psf, 32, psf->write_current);
    }
#line 1864
    if (__cil_tmp7 < 0L) {
#line 1865
      return ((sf_count_t )0);
    }
  }
#line 1867
  if (psf->write_header != (void *)0) {
#line 1867
    if (psf->have_written == 0) {
      {
#line 1868
      (*(psf->write_header))(psf, 0);
      }
    }
  }
  {
#line 1869
  psf->have_written = 1;
#line 1871
  count = (*(psf->write_short))(psf, ptr, frames * (long )psf->sf.channels);
#line 1873
  psf->write_current += count / (long )psf->sf.channels;
#line 1875
  psf->last_op = 32;
  }
#line 1877
  if (psf->write_header != (void *)0) {
#line 1877
    if (psf->auto_header) {
      {
#line 1878
      (*(psf->write_header))(psf, 1);
      }
    }
  }
#line 1880
  if (psf->write_current > psf->sf.frames) {
#line 1881
    psf->sf.frames = psf->write_current;
  }
#line 1883
  return (count / (long )psf->sf.channels);
}
}
#line 1890 "/root/libsndfile/src/sndfile.c"
sf_count_t sf_write_int(SNDFILE *sndfile , int const   *ptr , sf_count_t len ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t count ;
  int __cil_tmp6 ;
  sf_count_t __cil_tmp7 ;
  sf_count_t __cil_tmp8 ;

  {
#line 1894
  if (sndfile == (void *)0) {
#line 1894
    sf_errno = 10;
#line 1894
    return ((sf_count_t )0);
  }
  {
#line 1894
  psf = (SF_PRIVATE *)sndfile;
#line 1894
  __cil_tmp6 = psf_file_valid(psf);
  }
#line 1894
  if (psf->virtual_io == 0) {
#line 1894
    if (__cil_tmp6 == 0) {
#line 1894
      psf->error = 13;
#line 1894
      return ((sf_count_t )0);
    }
  }

#line 1894
  if (psf->Magick != 305447134) {
#line 1894
    psf->error = 10;
#line 1894
    return ((sf_count_t )0);
  }

#line 1894
  if (1) {
#line 1894
    psf->error = 0;
  }

#line 1896
  if (psf->mode == 16) {
#line 1897
    psf->error = 22;
#line 1898
    return ((sf_count_t )0);
  }

#line 1901
  if (len % (long )psf->sf.channels) {
#line 1902
    psf->error = 19;
#line 1903
    return ((sf_count_t )0);
  }

#line 1906
  if (psf->write_int == (void *)0) {
#line 1907
    psf->error = 17;
#line 1908
    return ((sf_count_t )0);
  } else
#line 1906
  if (psf->seek == (void *)0) {
#line 1907
    psf->error = 17;
#line 1908
    return ((sf_count_t )0);
  }

#line 1911
  if (psf->last_op != 32) {
    {
#line 1912
    __cil_tmp7 = (*(psf->seek))(psf, 32, psf->write_current);
    }
#line 1912
    if (__cil_tmp7 < 0L) {
#line 1913
      return ((sf_count_t )0);
    }
  }
#line 1915
  if (psf->write_header != (void *)0) {
#line 1915
    if (psf->have_written == 0) {
      {
#line 1916
      (*(psf->write_header))(psf, 0);
      }
    }
  }
  {
#line 1917
  psf->have_written = 1;
#line 1919
  count = (*(psf->write_int))(psf, ptr, len);
#line 1921
  psf->write_current += count / (long )psf->sf.channels;
#line 1923
  psf->last_op = 32;
  }
#line 1925
  if (psf->write_header != (void *)0) {
#line 1925
    if (psf->auto_header) {
      {
#line 1926
      (*(psf->write_header))(psf, 1);
      }
    }
  }
#line 1928
  if (psf->write_current > psf->sf.frames) {
#line 1929
    psf->sf.frames = psf->write_current;
  }
#line 1931
  return (count);
}
}
#line 1935 "/root/libsndfile/src/sndfile.c"
sf_count_t sf_writef_int(SNDFILE *sndfile , int const   *ptr , sf_count_t frames ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t count ;
  int __cil_tmp6 ;
  sf_count_t __cil_tmp7 ;
  sf_count_t __cil_tmp8 ;

  {
#line 1939
  if (sndfile == (void *)0) {
#line 1939
    sf_errno = 10;
#line 1939
    return ((sf_count_t )0);
  }
  {
#line 1939
  psf = (SF_PRIVATE *)sndfile;
#line 1939
  __cil_tmp6 = psf_file_valid(psf);
  }
#line 1939
  if (psf->virtual_io == 0) {
#line 1939
    if (__cil_tmp6 == 0) {
#line 1939
      psf->error = 13;
#line 1939
      return ((sf_count_t )0);
    }
  }

#line 1939
  if (psf->Magick != 305447134) {
#line 1939
    psf->error = 10;
#line 1939
    return ((sf_count_t )0);
  }

#line 1939
  if (1) {
#line 1939
    psf->error = 0;
  }

#line 1941
  if (psf->mode == 16) {
#line 1942
    psf->error = 22;
#line 1943
    return ((sf_count_t )0);
  }

#line 1946
  if (psf->write_int == (void *)0) {
#line 1947
    psf->error = 17;
#line 1948
    return ((sf_count_t )0);
  } else
#line 1946
  if (psf->seek == (void *)0) {
#line 1947
    psf->error = 17;
#line 1948
    return ((sf_count_t )0);
  }

#line 1951
  if (psf->last_op != 32) {
    {
#line 1952
    __cil_tmp7 = (*(psf->seek))(psf, 32, psf->write_current);
    }
#line 1952
    if (__cil_tmp7 < 0L) {
#line 1953
      return ((sf_count_t )0);
    }
  }
#line 1955
  if (psf->write_header != (void *)0) {
#line 1955
    if (psf->have_written == 0) {
      {
#line 1956
      (*(psf->write_header))(psf, 0);
      }
    }
  }
  {
#line 1957
  psf->have_written = 1;
#line 1959
  count = (*(psf->write_int))(psf, ptr, frames * (long )psf->sf.channels);
#line 1961
  psf->write_current += count / (long )psf->sf.channels;
#line 1963
  psf->last_op = 32;
  }
#line 1965
  if (psf->write_header != (void *)0) {
#line 1965
    if (psf->auto_header) {
      {
#line 1966
      (*(psf->write_header))(psf, 1);
      }
    }
  }
#line 1968
  if (psf->write_current > psf->sf.frames) {
#line 1969
    psf->sf.frames = psf->write_current;
  }
#line 1971
  return (count / (long )psf->sf.channels);
}
}
#line 1978 "/root/libsndfile/src/sndfile.c"
sf_count_t sf_write_float(SNDFILE *sndfile , float const   *ptr , sf_count_t len ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t count ;
  int __cil_tmp6 ;
  sf_count_t __cil_tmp7 ;
  sf_count_t __cil_tmp8 ;

  {
#line 1982
  if (sndfile == (void *)0) {
#line 1982
    sf_errno = 10;
#line 1982
    return ((sf_count_t )0);
  }
  {
#line 1982
  psf = (SF_PRIVATE *)sndfile;
#line 1982
  __cil_tmp6 = psf_file_valid(psf);
  }
#line 1982
  if (psf->virtual_io == 0) {
#line 1982
    if (__cil_tmp6 == 0) {
#line 1982
      psf->error = 13;
#line 1982
      return ((sf_count_t )0);
    }
  }

#line 1982
  if (psf->Magick != 305447134) {
#line 1982
    psf->error = 10;
#line 1982
    return ((sf_count_t )0);
  }

#line 1982
  if (1) {
#line 1982
    psf->error = 0;
  }

#line 1984
  if (psf->mode == 16) {
#line 1985
    psf->error = 22;
#line 1986
    return ((sf_count_t )0);
  }

#line 1989
  if (len % (long )psf->sf.channels) {
#line 1990
    psf->error = 19;
#line 1991
    return ((sf_count_t )0);
  }

#line 1994
  if (psf->write_float == (void *)0) {
#line 1995
    psf->error = 17;
#line 1996
    return ((sf_count_t )0);
  } else
#line 1994
  if (psf->seek == (void *)0) {
#line 1995
    psf->error = 17;
#line 1996
    return ((sf_count_t )0);
  }

#line 1999
  if (psf->last_op != 32) {
    {
#line 2000
    __cil_tmp7 = (*(psf->seek))(psf, 32, psf->write_current);
    }
#line 2000
    if (__cil_tmp7 < 0L) {
#line 2001
      return ((sf_count_t )0);
    }
  }
#line 2003
  if (psf->write_header != (void *)0) {
#line 2003
    if (psf->have_written == 0) {
      {
#line 2004
      (*(psf->write_header))(psf, 0);
      }
    }
  }
  {
#line 2005
  psf->have_written = 1;
#line 2007
  count = (*(psf->write_float))(psf, ptr, len);
#line 2009
  psf->write_current += count / (long )psf->sf.channels;
#line 2011
  psf->last_op = 32;
  }
#line 2013
  if (psf->write_header != (void *)0) {
#line 2013
    if (psf->auto_header) {
      {
#line 2014
      (*(psf->write_header))(psf, 1);
      }
    }
  }
#line 2016
  if (psf->write_current > psf->sf.frames) {
#line 2017
    psf->sf.frames = psf->write_current;
  }
#line 2019
  return (count);
}
}
#line 2023 "/root/libsndfile/src/sndfile.c"
sf_count_t sf_writef_float(SNDFILE *sndfile , float const   *ptr , sf_count_t frames ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t count ;
  int __cil_tmp6 ;
  sf_count_t __cil_tmp7 ;
  sf_count_t __cil_tmp8 ;

  {
#line 2027
  if (sndfile == (void *)0) {
#line 2027
    sf_errno = 10;
#line 2027
    return ((sf_count_t )0);
  }
  {
#line 2027
  psf = (SF_PRIVATE *)sndfile;
#line 2027
  __cil_tmp6 = psf_file_valid(psf);
  }
#line 2027
  if (psf->virtual_io == 0) {
#line 2027
    if (__cil_tmp6 == 0) {
#line 2027
      psf->error = 13;
#line 2027
      return ((sf_count_t )0);
    }
  }

#line 2027
  if (psf->Magick != 305447134) {
#line 2027
    psf->error = 10;
#line 2027
    return ((sf_count_t )0);
  }

#line 2027
  if (1) {
#line 2027
    psf->error = 0;
  }

#line 2029
  if (psf->mode == 16) {
#line 2030
    psf->error = 22;
#line 2031
    return ((sf_count_t )0);
  }

#line 2034
  if (psf->write_float == (void *)0) {
#line 2035
    psf->error = 17;
#line 2036
    return ((sf_count_t )0);
  } else
#line 2034
  if (psf->seek == (void *)0) {
#line 2035
    psf->error = 17;
#line 2036
    return ((sf_count_t )0);
  }

#line 2039
  if (psf->last_op != 32) {
    {
#line 2040
    __cil_tmp7 = (*(psf->seek))(psf, 32, psf->write_current);
    }
#line 2040
    if (__cil_tmp7 < 0L) {
#line 2041
      return ((sf_count_t )0);
    }
  }
#line 2043
  if (psf->write_header != (void *)0) {
#line 2043
    if (psf->have_written == 0) {
      {
#line 2044
      (*(psf->write_header))(psf, 0);
      }
    }
  }
  {
#line 2045
  psf->have_written = 1;
#line 2047
  count = (*(psf->write_float))(psf, ptr, frames * (long )psf->sf.channels);
#line 2049
  psf->write_current += count / (long )psf->sf.channels;
#line 2051
  psf->last_op = 32;
  }
#line 2053
  if (psf->write_header != (void *)0) {
#line 2053
    if (psf->auto_header) {
      {
#line 2054
      (*(psf->write_header))(psf, 1);
      }
    }
  }
#line 2056
  if (psf->write_current > psf->sf.frames) {
#line 2057
    psf->sf.frames = psf->write_current;
  }
#line 2059
  return (count / (long )psf->sf.channels);
}
}
#line 2066 "/root/libsndfile/src/sndfile.c"
sf_count_t sf_write_double(SNDFILE *sndfile , double const   *ptr , sf_count_t len ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t count ;
  int __cil_tmp6 ;
  sf_count_t __cil_tmp7 ;
  sf_count_t __cil_tmp8 ;

  {
#line 2070
  if (sndfile == (void *)0) {
#line 2070
    sf_errno = 10;
#line 2070
    return ((sf_count_t )0);
  }
  {
#line 2070
  psf = (SF_PRIVATE *)sndfile;
#line 2070
  __cil_tmp6 = psf_file_valid(psf);
  }
#line 2070
  if (psf->virtual_io == 0) {
#line 2070
    if (__cil_tmp6 == 0) {
#line 2070
      psf->error = 13;
#line 2070
      return ((sf_count_t )0);
    }
  }

#line 2070
  if (psf->Magick != 305447134) {
#line 2070
    psf->error = 10;
#line 2070
    return ((sf_count_t )0);
  }

#line 2070
  if (1) {
#line 2070
    psf->error = 0;
  }

#line 2072
  if (psf->mode == 16) {
#line 2073
    psf->error = 22;
#line 2074
    return ((sf_count_t )0);
  }

#line 2077
  if (len % (long )psf->sf.channels) {
#line 2078
    psf->error = 19;
#line 2079
    return ((sf_count_t )0);
  }

#line 2082
  if (psf->write_double == (void *)0) {
#line 2083
    psf->error = 17;
#line 2084
    return ((sf_count_t )0);
  } else
#line 2082
  if (psf->seek == (void *)0) {
#line 2083
    psf->error = 17;
#line 2084
    return ((sf_count_t )0);
  }

#line 2087
  if (psf->last_op != 32) {
    {
#line 2088
    __cil_tmp7 = (*(psf->seek))(psf, 32, psf->write_current);
    }
#line 2088
    if (__cil_tmp7 < 0L) {
#line 2089
      return ((sf_count_t )0);
    }
  }
#line 2091
  if (psf->write_header != (void *)0) {
#line 2091
    if (psf->have_written == 0) {
      {
#line 2092
      (*(psf->write_header))(psf, 0);
      }
    }
  }
  {
#line 2093
  psf->have_written = 1;
#line 2095
  count = (*(psf->write_double))(psf, ptr, len);
#line 2097
  psf->write_current += count / (long )psf->sf.channels;
#line 2099
  psf->last_op = 32;
  }
#line 2101
  if (psf->write_header != (void *)0) {
#line 2101
    if (psf->auto_header) {
      {
#line 2102
      (*(psf->write_header))(psf, 1);
      }
    }
  }
#line 2104
  if (psf->write_current > psf->sf.frames) {
#line 2105
    psf->sf.frames = psf->write_current;
  }
#line 2107
  return (count);
}
}
#line 2111 "/root/libsndfile/src/sndfile.c"
sf_count_t sf_writef_double(SNDFILE *sndfile , double const   *ptr , sf_count_t frames ) 
{ 
  SF_PRIVATE *psf ;
  sf_count_t count ;
  int __cil_tmp6 ;
  sf_count_t __cil_tmp7 ;
  sf_count_t __cil_tmp8 ;

  {
#line 2115
  if (sndfile == (void *)0) {
#line 2115
    sf_errno = 10;
#line 2115
    return ((sf_count_t )0);
  }
  {
#line 2115
  psf = (SF_PRIVATE *)sndfile;
#line 2115
  __cil_tmp6 = psf_file_valid(psf);
  }
#line 2115
  if (psf->virtual_io == 0) {
#line 2115
    if (__cil_tmp6 == 0) {
#line 2115
      psf->error = 13;
#line 2115
      return ((sf_count_t )0);
    }
  }

#line 2115
  if (psf->Magick != 305447134) {
#line 2115
    psf->error = 10;
#line 2115
    return ((sf_count_t )0);
  }

#line 2115
  if (1) {
#line 2115
    psf->error = 0;
  }

#line 2117
  if (psf->mode == 16) {
#line 2118
    psf->error = 22;
#line 2119
    return ((sf_count_t )0);
  }

#line 2122
  if (psf->write_double == (void *)0) {
#line 2123
    psf->error = 17;
#line 2124
    return ((sf_count_t )0);
  } else
#line 2122
  if (psf->seek == (void *)0) {
#line 2123
    psf->error = 17;
#line 2124
    return ((sf_count_t )0);
  }

#line 2127
  if (psf->last_op != 32) {
    {
#line 2128
    __cil_tmp7 = (*(psf->seek))(psf, 32, psf->write_current);
    }
#line 2128
    if (__cil_tmp7 < 0L) {
#line 2129
      return ((sf_count_t )0);
    }
  }
#line 2131
  if (psf->write_header != (void *)0) {
#line 2131
    if (psf->have_written == 0) {
      {
#line 2132
      (*(psf->write_header))(psf, 0);
      }
    }
  }
  {
#line 2133
  psf->have_written = 1;
#line 2135
  count = (*(psf->write_double))(psf, ptr, frames * (long )psf->sf.channels);
#line 2137
  psf->write_current += count / (long )psf->sf.channels;
#line 2139
  psf->last_op = 32;
  }
#line 2141
  if (psf->write_header != (void *)0) {
#line 2141
    if (psf->auto_header) {
      {
#line 2142
      (*(psf->write_header))(psf, 1);
      }
    }
  }
#line 2144
  if (psf->write_current > psf->sf.frames) {
#line 2145
    psf->sf.frames = psf->write_current;
  }
#line 2147
  return (count / (long )psf->sf.channels);
}
}
#line 2155 "/root/libsndfile/src/sndfile.c"
static int try_resource_fork(SF_PRIVATE *psf , int mode ) 
{ 
  int old_error ;
  int __cil_tmp4 ;

  {
  {
#line 2156
  old_error = psf->error;
#line 2158
  __cil_tmp4 = psf_open_rsrc(psf, mode);
  }
#line 2158
  if (__cil_tmp4 != 0) {
#line 2159
    psf->error = old_error;
#line 2160
    return (0);
  }
  {
#line 2164
  psf_log_printf(psf, "Resource fork : %s\n", (char *)psf->rsrcpath);
  }
#line 2166
  return (1441792);
}
}
#line 2170 "/root/libsndfile/src/sndfile.c"
static int format_from_extension(SF_PRIVATE *psf ) 
{ 
  char *cptr ;
  char buffer[16] ;
  int format ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  char *__cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;

  {
  {
#line 2173
  format = 0;
#line 2175
  cptr = strrchr((char const   *)((char *)psf->filename), '.');
  }
#line 2175
  if (cptr == (void *)0) {
#line 2176
    return (0);
  }
  {
#line 2178
  cptr ++;
#line 2179
  __cil_tmp7 = strlen((char const   *)cptr);
  }
#line 2179
  if (__cil_tmp7 > sizeof(buffer) - 1UL) {
#line 2180
    return (0);
  }
  {
#line 2182
  strncpy((char *)buffer, (char const   *)cptr, sizeof(buffer));
#line 2183
  buffer[sizeof(buffer) - 1UL] = (char )0;
#line 2186
  cptr = (char *)buffer;
  }
  {
#line 2187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2187
    if (! *cptr) {
#line 2187
      goto while_break;
    }
#line 2188
    *cptr = (char )0;
#line 2189
    cptr ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2192
  cptr = (char *)buffer;
#line 2194
  __cil_tmp9 = strcmp((char const   *)cptr, "au\376\375\036V");
  }
#line 2194
  if (__cil_tmp9 == 0) {
#line 2195
    psf->sf.channels = 1;
#line 2196
    psf->sf.samplerate = 8000;
#line 2197
    format = 262160;
  } else {
    {
#line 2199
    __cil_tmp10 = strcmp((char const   *)cptr, "snd");
    }
#line 2199
    if (__cil_tmp10 == 0) {
#line 2200
      psf->sf.channels = 1;
#line 2201
      psf->sf.samplerate = 8000;
#line 2202
      format = 262160;
    } else {
      {
#line 2205
      __cil_tmp12 = strcmp((char const   *)cptr, "vox8\036V");
      }
      {
#line 2205
      __cil_tmp11 = strcmp((char const   *)cptr, "vox\375\036V");
      }
#line 2205
      if (__cil_tmp11 == 0) {
#line 2206
        psf->sf.channels = 1;
#line 2207
        psf->sf.samplerate = 8000;
#line 2208
        format = 262177;
      } else
#line 2205
      if (__cil_tmp12 == 0) {
#line 2206
        psf->sf.channels = 1;
#line 2207
        psf->sf.samplerate = 8000;
#line 2208
        format = 262177;
      } else {
        {
#line 2210
        __cil_tmp13 = strcmp((char const   *)cptr, "vox6");
        }
#line 2210
        if (__cil_tmp13 == 0) {
#line 2211
          psf->sf.channels = 1;
#line 2212
          psf->sf.samplerate = 6000;
#line 2213
          format = 262177;
        } else {
          {
#line 2215
          __cil_tmp14 = strcmp((char const   *)cptr, "gsm");
          }
#line 2215
          if (__cil_tmp14 == 0) {
#line 2216
            psf->sf.channels = 1;
#line 2217
            psf->sf.samplerate = 8000;
#line 2218
            format = 262176;
          }
        }
      }
    }
  }
#line 2222
  if ((format & 268369920) == 262144) {
#line 2223
    psf->dataoffset = (sf_count_t )0;
  }
#line 2225
  return (format);
}
}
#line 2229 "/root/libsndfile/src/sndfile.c"
static int guess_file_type(SF_PRIVATE *psf ) 
{ 
  int buffer[3] ;
  int format ;
  int __cil_tmp4 ;
  __uint32_t __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 2232
  __cil_tmp4 = psf_binheader_readf(psf, "b", & buffer, (int )sizeof(buffer));
  }
#line 2232
  if (__cil_tmp4 != (int )sizeof(buffer)) {
#line 2233
    psf->error = 8;
#line 2234
    return (0);
  }

#line 2237
  if (buffer[0] == (((82 | (73 << 8)) | (70 << 16)) | (70 << 24))) {
    _L: /* CIL Label */ 
#line 2237
    if (buffer[2] == (((87 | (65 << 8)) | (86 << 16)) | (69 << 24))) {
#line 2239
      return (65536);
    }
  } else
#line 2237
  if (buffer[0] == (((82 | (73 << 8)) | (70 << 16)) | (88 << 24))) {
#line 2237
    goto _L;
  }
#line 2241
  if (buffer[0] == (((70 | (79 << 8)) | (82 << 16)) | (77 << 24))) {
#line 2242
    if (buffer[2] == (((65 | (73 << 8)) | (70 << 16)) | (70 << 24))) {
#line 2243
      return (131072);
    } else
#line 2242
    if (buffer[2] == (((65 | (73 << 8)) | (70 << 16)) | (67 << 24))) {
#line 2243
      return (131072);
    }
#line 2244
    if (buffer[2] == (((56 | (83 << 8)) | (86 << 16)) | (88 << 24))) {
#line 2245
      return (393216);
    } else
#line 2244
    if (buffer[2] == (((49 | (54 << 8)) | (83 << 16)) | (86 << 24))) {
#line 2245
      return (393216);
    }
#line 2246
    return (0);
  }

#line 2249
  if (buffer[0] == (((46 | (115 << 8)) | (110 << 16)) | (100 << 24))) {
#line 2250
    return (196608);
  } else
#line 2249
  if (buffer[0] == (((100 | (110 << 8)) | (115 << 16)) | (46 << 24))) {
#line 2250
    return (196608);
  }
#line 2252
  if (buffer[0] == (((102 | (97 << 8)) | (112 << 16)) | (32 << 24))) {
#line 2253
    return (327680);
  } else
#line 2252
  if (buffer[0] == (((32 | (112 << 8)) | (97 << 16)) | (102 << 24))) {
#line 2253
    return (327680);
  }
#line 2255
  if (buffer[0] == (((78 | (73 << 8)) | (83 << 16)) | (84 << 24))) {
#line 2256
    return (458752);
  }
#line 2258
  if (buffer[0] == (((67 | (114 << 8)) | (101 << 16)) | (97 << 24))) {
#line 2258
    if (buffer[1] == (((116 | (105 << 8)) | (118 << 16)) | (101 << 24))) {
#line 2259
      return (524288);
    }
  }
#line 2261
  if ((buffer[0] & (((255 | (255 << 8)) | (248 << 16)) | (255 << 24))) == (100 | (163 << 8))) {
#line 2263
    return (655360);
  } else
#line 2261
  if ((buffer[0] & (((255 | (248 << 8)) | (255 << 16)) | (255 << 24))) == ((163 << 16) | (100 << 24))) {
#line 2263
    return (655360);
  }
#line 2265
  if (buffer[0] == (((114 | (105 << 8)) | (102 << 16)) | (102 << 24))) {
#line 2266
    return (720896);
  }
#line 2268
  if (buffer[0] == ((3 << 16) | (232 << 24))) {
#line 2268
    if (buffer[1] == 1 << 24) {
#line 2268
      if (buffer[2] == 1 << 24) {
#line 2270
        return (786432);
      }
    }
  }
#line 2272
  if (buffer[0] == 0) {
#line 2272
    if (buffer[1] == 1) {
#line 2272
      if (buffer[2] == 1) {
#line 2274
        return (786432);
      }
    }
  }
#line 2276
  if (buffer[0] == (((77 | (65 << 8)) | (84 << 16)) | (76 << 24))) {
#line 2276
    if (buffer[1] == (((65 | (66 << 8)) | (32 << 16)) | (53 << 24))) {
#line 2277
      return (851968);
    }
  }
#line 2279
  if (buffer[0] == (((80 | (86 << 8)) | (70 << 16)) | (49 << 24))) {
#line 2280
    return (917504);
  }
#line 2282
  if (buffer[0] == (((69 | (120 << 8)) | (116 << 16)) | (101 << 24))) {
#line 2282
    if (buffer[1] == (((110 | (100 << 8)) | (101 << 16)) | (100 << 24))) {
#line 2282
      if (buffer[2] == (((32 | (73 << 8)) | (110 << 16)) | (115 << 24))) {
#line 2284
        return (983040);
      }
    }
  }
#line 2286
  if (buffer[0] == (((99 | (97 << 8)) | (102 << 16)) | (102 << 24))) {
#line 2286
    if (buffer[2] == (((100 | (101 << 8)) | (115 << 16)) | (99 << 24))) {
#line 2287
      return (1572864);
    }
  }
#line 2289
  if (buffer[0] == (((79 | (103 << 8)) | (103 << 16)) | (83 << 24))) {
#line 2290
    return (2097152);
  }
#line 2292
  if (buffer[0] == (((65 | (76 << 8)) | (97 << 16)) | (119 << 24))) {
#line 2292
    if (buffer[1] == (((83 | (111 << 8)) | (117 << 16)) | (110 << 24))) {
#line 2292
      if (buffer[2] == (((100 | (70 << 8)) | (105 << 16)) | (108 << 24))) {
#line 2294
        return (1638400);
      }
    }
  }
#line 2296
  if (buffer[0] == (((68 | (105 << 8)) | (97 << 16)) | (109 << 24))) {
#line 2296
    if (buffer[1] == (((111 | (110 << 8)) | (100 << 16)) | (87 << 24))) {
#line 2296
      if (buffer[2] == (((97 | (114 << 8)) | (101 << 16)) | (32 << 24))) {
#line 2298
        return (67371008);
      }
    }
  }
#line 2300
  if (buffer[0] == (((76 | (77 << 8)) | (56 << 16)) | (57 << 24))) {
#line 2301
    return (67305472);
  } else
#line 2300
  if (buffer[0] == (53 | (51 << 8))) {
#line 2301
    return (67305472);
  }
#line 2303
  if ((buffer[0] & (((255 | (255 << 8)) | (128 << 16)) | (255 << 24))) == ((240 | (126 << 8)) | (1 << 24))) {
#line 2304
    return (1114112);
  }
#line 2306
  if ((buffer[0] & (255 | (255 << 8))) == (1 | (4 << 8))) {
#line 2307
    return (2162688);
  }
#line 2309
  if (buffer[0] == (((67 | (65 << 8)) | (84 << 16)) | (32 << 24))) {
#line 2309
    if (buffer[2] == (((82 | (69 << 8)) | (88 << 16)) | (50 << 24))) {
#line 2310
      return (67960832);
    }
  }
#line 2312
  if (buffer[0] == (((48 | (38 << 8)) | (178 << 16)) | (117 << 24))) {
#line 2312
    if (buffer[1] == (((142 | (102 << 8)) | (207 << 16)) | (17 << 24))) {
#line 2313
      return (0);
    }
  }
  {
#line 2316
  __cil_tmp5 = __bswap_32((__uint32_t )buffer[0]);
  }
#line 2316
  if ((long )(2 * (int )__cil_tmp5 + 12) == psf->filelength) {
#line 2316
    if (buffer[2] == 2 << 8) {
#line 2317
      return (1048576);
    }
  }
#line 2319
  if (buffer[0] == (((102 | (76 << 8)) | (97 << 16)) | (67 << 24))) {
#line 2320
    return (1507328);
  }
#line 2323
  if (buffer[0] == (((83 | (79 << 8)) | (85 << 16)) | (78 << 24))) {
#line 2323
    if (buffer[1] == (((68 | (32 << 8)) | (83 << 16)) | (65 << 24))) {
#line 2324
      return (0);
    }
  }
#line 2326
  if (buffer[0] == (((83 | (89 << 8)) | (56 << 16)) | (48 << 24))) {
#line 2327
    return (0);
  } else
#line 2326
  if (buffer[0] == (((83 | (89 << 8)) | (56 << 16)) | (53 << 24))) {
#line 2327
    return (0);
  }
#line 2329
  if (buffer[0] == (((97 | (106 << 8)) | (107 << 16)) | (103 << 24))) {
#line 2330
    return (0);
  }
#line 2332
  if (buffer[0] == (((50 | (66 << 8)) | (73 << 16)) | (84 << 24))) {
#line 2333
    return (1179648);
  }
#line 2335
  if (buffer[0] == (((82 | (70 << 8)) | (54 << 16)) | (52 << 24))) {
#line 2335
    if (buffer[2] == (((87 | (65 << 8)) | (86 << 16)) | (69 << 24))) {
#line 2336
      return (2228224);
    }
  }
  {
#line 2339
  format = try_resource_fork(psf, 16);
  }
#line 2339
  if (psf->filelength > 0L) {
#line 2339
    if (format != 0) {
#line 2340
      return (format);
    }
  }
#line 2342
  return (0);
}
}
#line 2347 "/root/libsndfile/src/sndfile.c"
static int validate_sfinfo(SF_INFO *sfinfo ) 
{ 


  {
#line 2348
  if (sfinfo->samplerate < 1) {
#line 2349
    return (0);
  }
#line 2350
  if (sfinfo->frames < 0L) {
#line 2351
    return (0);
  }
#line 2352
  if (sfinfo->channels < 1) {
#line 2353
    return (0);
  }
#line 2354
  if ((sfinfo->format & 268369920) == 0) {
#line 2355
    return (0);
  }
#line 2356
  if ((sfinfo->format & 65535) == 0) {
#line 2357
    return (0);
  }
#line 2358
  if (sfinfo->sections < 1) {
#line 2359
    return (0);
  }
#line 2360
  return (1);
}
}
#line 2364 "/root/libsndfile/src/sndfile.c"
static int validate_psf(SF_PRIVATE *psf ) 
{ 


  {
#line 2366
  if (psf->datalength < 0L) {
    {
#line 2367
    psf_log_printf(psf, "Invalid SF_PRIVATE field : datalength == %D.\n", psf->datalength);
    }
#line 2368
    return (0);
  }

#line 2370
  if (psf->dataoffset < 0L) {
    {
#line 2371
    psf_log_printf(psf, "Invalid SF_PRIVATE field : dataoffset == %D.\n", psf->dataoffset);
    }
#line 2372
    return (0);
  }

#line 2374
  if (psf->blockwidth) {
#line 2374
    if (psf->blockwidth != psf->sf.channels * psf->bytewidth) {
      {
#line 2375
      psf_log_printf(psf, "Invalid SF_PRIVATE field : channels * bytewidth == %d.\n",
                     psf->sf.channels * psf->bytewidth);
      }
#line 2377
      return (0);
    }
  }

#line 2379
  return (1);
}
}
#line 2383 "/root/libsndfile/src/sndfile.c"
static void save_header_info(SF_PRIVATE *psf ) 
{ 


  {
  {
#line 2384
  snprintf((char *)sf_logbuffer, sizeof(sf_logbuffer), "%s", (char *)psf->logbuffer);
  }
  return;
}
}
#line 2388 "/root/libsndfile/src/sndfile.c"
static void copy_filename(SF_PRIVATE *psf , char const   *path ) 
{ 
  char const   *ccptr ;
  char *cptr ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char const   *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 2392
  snprintf((char *)psf->filepath, sizeof(psf->filepath), "%s", path);
#line 2393
  __cil_tmp6 = strrchr(path, '\\');
#line 2393
  ccptr = (char const   *)__cil_tmp6;
  }
  {
#line 2393
  __cil_tmp5 = strrchr(path, '/');
#line 2393
  ccptr = (char const   *)__cil_tmp5;
  }
#line 2393
  if (ccptr) {
#line 2394
    ccptr ++;
  } else
#line 2393
  if (ccptr) {
#line 2394
    ccptr ++;
  } else {
#line 2396
    ccptr = path;
  }
  {
#line 2398
  snprintf((char *)psf->filename, sizeof(psf->filename), "%s", ccptr);
#line 2401
  snprintf((char *)psf->directory, sizeof(psf->directory), "%s", path);
#line 2402
  cptr = strrchr((char const   *)((char *)psf->directory), '\\');
  }
  {
#line 2402
  cptr = strrchr((char const   *)((char *)psf->directory), '/');
  }
#line 2402
  if (cptr) {
#line 2403
    *(cptr + 1) = (char )0;
  } else
#line 2402
  if (cptr) {
#line 2403
    *(cptr + 1) = (char )0;
  } else {
#line 2405
    psf->directory[0] = (char )0;
  }
#line 2407
  return;
}
}
#line 2414 "/root/libsndfile/src/sndfile.c"
static int psf_close(SF_PRIVATE *psf ) 
{ 
  int error ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
#line 2415
  error = 0;
#line 2417
  if (psf->codec_close) {
    {
#line 2418
    error = (*(psf->codec_close))(psf);
    }
  }
#line 2419
  if (psf->container_close) {
    {
#line 2420
    error = (*(psf->container_close))(psf);
    }
  }
  {
#line 2422
  error = psf_fclose(psf);
#line 2423
  psf_close_rsrc(psf);
  }
#line 2425
  if (psf->container_data) {
    {
#line 2426
    free(psf->container_data);
    }
  }
#line 2428
  if (psf->codec_data) {
    {
#line 2429
    free(psf->codec_data);
    }
  }
#line 2431
  if (psf->interleave) {
    {
#line 2432
    free(psf->interleave);
    }
  }
#line 2434
  if (psf->dither) {
    {
#line 2435
    free(psf->dither);
    }
  }
#line 2437
  if (psf->peak_info) {
    {
#line 2438
    free(psf->peak_info);
    }
  }
#line 2440
  if (psf->broadcast_var) {
    {
#line 2441
    free(psf->broadcast_var);
    }
  }
#line 2443
  if (psf->loop_info) {
    {
#line 2444
    free(psf->loop_info);
    }
  }
#line 2446
  if (psf->instrument) {
    {
#line 2447
    free(psf->instrument);
    }
  }
#line 2449
  if (psf->channel_map) {
    {
#line 2450
    free(psf->channel_map);
    }
  }
#line 2452
  if (psf->format_desc) {
    {
#line 2453
    *(psf->format_desc + 0) = (char )0;
#line 2454
    free(psf->format_desc);
    }
  }
  {
#line 2457
  memset(psf, 0, sizeof(SF_PRIVATE ));
#line 2458
  free(psf);
  }
#line 2460
  return (error);
}
}
#line 2464 "/root/libsndfile/src/sndfile.c"
static SNDFILE *psf_open_file(SF_PRIVATE *psf , int mode , SF_INFO *sfinfo ) 
{ 
  int error ;
  int format ;
  int __cil_tmp6 ;
  int32_t __cil_tmp7 ;
  int __cil_tmp8 ;
  sf_count_t __cil_tmp9 ;
  sf_count_t __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  int tmp ;
  char const   *__cil_tmp45 ;

  {
#line 2467
  error = 0;
#line 2467
  sf_errno = error;
#line 2468
  sf_logbuffer[0] = (char )0;
#line 2470
  if (psf->error) {
#line 2471
    error = psf->error;
#line 2472
    goto error_exit;
  }

#line 2475
  if (mode != 16) {
#line 2475
    if (mode != 32) {
#line 2475
      if (mode != 48) {
#line 2476
        error = 43;
#line 2477
        goto error_exit;
      }
    }
  }

#line 2480
  if (sfinfo == (void *)0) {
#line 2481
    error = 11;
#line 2482
    goto error_exit;
  }
#line 2486
  sfinfo->frames = (sf_count_t )0;
#line 2487
  sfinfo->sections = 0;
#line 2488
  sfinfo->seekable = 0;
#line 2490
  if (mode == 16) {
#line 2491
    if ((sfinfo->format & 268369920) == 262144) {
      {
#line 2492
      __cil_tmp6 = sf_format_check(sfinfo);
      }
#line 2492
      if (__cil_tmp6 == 0) {
#line 2493
        error = 91;
#line 2494
        goto error_exit;
      }

    } else {
      {
#line 2498
      memset(sfinfo, 0, sizeof(SF_INFO ));
      }
    }
  }
  {
#line 2501
  memcpy(& psf->sf, sfinfo, sizeof(SF_INFO ));
#line 2503
  psf->Magick = 305447134;
#line 2504
  psf->norm_float = 1;
#line 2505
  psf->norm_double = 1;
#line 2506
  psf->mode = mode;
#line 2507
  psf->dataoffset = (sf_count_t )(- 1);
#line 2508
  psf->datalength = (sf_count_t )(- 1);
#line 2509
  psf->read_current = (sf_count_t )(- 1);
#line 2510
  psf->write_current = (sf_count_t )(- 1);
#line 2511
  psf->auto_header = 0;
#line 2512
  psf->rwf_endian = 268435456;
#line 2513
  psf->seek = & psf_default_seek;
#line 2514
  psf->float_int_mult = 0;
#line 2515
  psf->float_max = (float )(- 1.);
#line 2518
  __cil_tmp7 = psf_rand_int32();
#line 2518
  psf->unique_id = (unsigned int )__cil_tmp7;
#line 2520
  psf->sf.sections = 1;
#line 2522
  psf->is_pipe = psf_is_pipe(psf);
  }
#line 2524
  if (psf->is_pipe) {
#line 2525
    psf->sf.seekable = 0;
#line 2526
    psf->filelength = (sf_count_t )-1LL;
  } else {
    {
#line 2529
    psf->sf.seekable = 1;
#line 2532
    psf->filelength = psf_get_filelen(psf);
    }
  }

#line 2535
  if (psf->fileoffset > 0L) {
    {
#line 2537
    if (psf->mode == 16) {
#line 2537
      goto case_16;
    }
#line 2545
    if (psf->mode == 32) {
#line 2545
      goto case_32;
    }
#line 2551
    if (psf->mode == 48) {
#line 2551
      goto case_48;
    }
#line 2536
    goto switch_break;
    case_16: /* CIL Label */ 
#line 2538
    if (psf->filelength < 44L) {
      {
#line 2539
      psf_log_printf(psf, "Short filelength: %D (fileoffset: %D)\n", psf->filelength,
                     psf->fileoffset);
#line 2540
      error = 25;
      }
#line 2541
      goto error_exit;
    }

#line 2543
    goto switch_break;
    case_32: /* CIL Label */ 
#line 2546
    psf->fileoffset = (sf_count_t )0;
    {
#line 2547
    psf_fseek(psf, (sf_count_t )0, 2);
#line 2548
    psf->fileoffset = psf_ftell(psf);
    }
#line 2549
    goto switch_break;
    case_48: /* CIL Label */ 
#line 2552
    error = 27;
#line 2553
    goto error_exit;
    switch_break: /* CIL Label */ ;
    }
    {
#line 2556
    psf_log_printf(psf, "Embedded file offset : %D\n", psf->fileoffset);
    }
  }

#line 2559
  if ((long long )psf->filelength == -1LL) {
    {
#line 2560
    psf_log_printf(psf, "Length : unknown\n\364\377\375\036V");
    }
  } else {
    {
#line 2562
    psf_log_printf(psf, "Length : %D\n\036V", psf->filelength);
    }
  }
#line 2564
  if (mode == 32) {
    _L: /* CIL Label */ 
#line 2568
    if ((psf->sf.format & 268369920) == 0) {
#line 2569
      error = 5;
#line 2570
      goto error_exit;
    }

#line 2572
    if ((psf->sf.format & 268369920) == 0) {
#line 2573
      error = 6;
#line 2574
      goto error_exit;
    }
    {
#line 2577
    __cil_tmp11 = sf_format_check(& psf->sf);
    }
#line 2577
    if (__cil_tmp11 == 0) {
#line 2578
      error = 1;
#line 2579
      goto error_exit;
    }

  } else
#line 2564
  if (mode == 48) {
#line 2564
    if (psf->filelength == 0L) {
#line 2564
      goto _L;
    } else {
#line 2564
      goto _L___53;
    }
  } else
  _L___53: /* CIL Label */ 
#line 2582
  if ((psf->sf.format & 268369920) != 262144) {
    {
#line 2584
    psf->sf.format = guess_file_type(psf);
    }
#line 2586
    if (psf->sf.format == 0) {
      {
#line 2587
      psf->sf.format = format_from_extension(psf);
      }
    }
  }
#line 2591
  psf->last_op = psf->mode;
  {
#line 2599
  if ((psf->sf.format & 65535) == 80) {
#line 2599
    goto case_80;
  }
#line 2599
  if ((psf->sf.format & 65535) == 17) {
#line 2599
    goto case_80;
  }
#line 2599
  if ((psf->sf.format & 65535) == 16) {
#line 2599
    goto case_80;
  }
#line 2599
  if ((psf->sf.format & 65535) == 5) {
#line 2599
    goto case_80;
  }
#line 2599
  if ((psf->sf.format & 65535) == 1) {
#line 2599
    goto case_80;
  }
#line 2604
  if ((psf->sf.format & 65535) == 81) {
#line 2604
    goto case_81;
  }
#line 2604
  if ((psf->sf.format & 65535) == 2) {
#line 2604
    goto case_81;
  }
#line 2608
  if ((psf->sf.format & 65535) == 3) {
#line 2608
    goto case_3;
  }
#line 2613
  if ((psf->sf.format & 65535) == 6) {
#line 2613
    goto case_6;
  }
#line 2613
  if ((psf->sf.format & 65535) == 4) {
#line 2613
    goto case_6;
  }
#line 2617
  if ((psf->sf.format & 65535) == 7) {
#line 2617
    goto case_7;
  }
#line 2594
  goto switch_break___0;
  case_80: /* CIL Label */ 
  case_17: /* CIL Label */ 
  case_16___0: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 2600
  psf->bytewidth = 1;
#line 2601
  goto switch_break___0;
  case_81: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 2605
  psf->bytewidth = 2;
#line 2606
  goto switch_break___0;
  case_3: /* CIL Label */ 
#line 2609
  psf->bytewidth = 3;
#line 2610
  goto switch_break___0;
  case_6: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 2614
  psf->bytewidth = 4;
#line 2615
  goto switch_break___0;
  case_7: /* CIL Label */ 
#line 2618
  psf->bytewidth = 8;
#line 2619
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }

  {
#line 2625
  if ((psf->sf.format & 268369920) == 1245184) {
#line 2625
    goto case_1245184;
  }
#line 2625
  if ((psf->sf.format & 268369920) == 65536) {
#line 2625
    goto case_1245184;
  }
#line 2629
  if ((psf->sf.format & 268369920) == 131072) {
#line 2629
    goto case_131072;
  }
#line 2633
  if ((psf->sf.format & 268369920) == 196608) {
#line 2633
    goto case_196608;
  }
#line 2637
  if ((psf->sf.format & 268369920) == 262144) {
#line 2637
    goto case_262144;
  }
#line 2641
  if ((psf->sf.format & 268369920) == 720896) {
#line 2641
    goto case_720896;
  }
#line 2645
  if ((psf->sf.format & 268369920) == 2228224) {
#line 2645
    goto case_2228224;
  }
#line 2650
  if ((psf->sf.format & 268369920) == 327680) {
#line 2650
    goto case_327680;
  }
#line 2654
  if ((psf->sf.format & 268369920) == 393216) {
#line 2654
    goto case_393216;
  }
#line 2658
  if ((psf->sf.format & 268369920) == 458752) {
#line 2658
    goto case_458752;
  }
#line 2662
  if ((psf->sf.format & 268369920) == 655360) {
#line 2662
    goto case_655360;
  }
#line 2666
  if ((psf->sf.format & 268369920) == 524288) {
#line 2666
    goto case_524288;
  }
#line 2670
  if ((psf->sf.format & 268369920) == 1114112) {
#line 2670
    goto case_1114112;
  }
#line 2674
  if ((psf->sf.format & 268369920) == 2097152) {
#line 2674
    goto case_2097152;
  }
#line 2678
  if ((psf->sf.format & 268369920) == 67305472) {
#line 2678
    goto case_67305472;
  }
#line 2682
  if ((psf->sf.format & 268369920) == 1638400) {
#line 2682
    goto case_1638400;
  }
#line 2686
  if ((psf->sf.format & 268369920) == 67371008) {
#line 2686
    goto case_67371008;
  }
#line 2690
  if ((psf->sf.format & 268369920) == 786432) {
#line 2690
    goto case_786432;
  }
#line 2694
  if ((psf->sf.format & 268369920) == 851968) {
#line 2694
    goto case_851968;
  }
#line 2698
  if ((psf->sf.format & 268369920) == 917504) {
#line 2698
    goto case_917504;
  }
#line 2702
  if ((psf->sf.format & 268369920) == 983040) {
#line 2702
    goto case_983040;
  }
#line 2706
  if ((psf->sf.format & 268369920) == 1048576) {
#line 2706
    goto case_1048576;
  }
#line 2710
  if ((psf->sf.format & 268369920) == 1441792) {
#line 2710
    goto case_1441792;
  }
#line 2714
  if ((psf->sf.format & 268369920) == 67960832) {
#line 2714
    goto case_67960832;
  }
#line 2718
  if ((psf->sf.format & 268369920) == 1179648) {
#line 2718
    goto case_1179648;
  }
#line 2722
  if ((psf->sf.format & 268369920) == 1507328) {
#line 2722
    goto case_1507328;
  }
#line 2726
  if ((psf->sf.format & 268369920) == 1572864) {
#line 2726
    goto case_1572864;
  }
#line 2730
  if ((psf->sf.format & 268369920) == 2162688) {
#line 2730
    goto case_2162688;
  }
#line 2736
  goto switch_default;
  case_1245184: /* CIL Label */ 
  case_65536: /* CIL Label */ 
  {
#line 2626
  error = wav_open(psf);
  }
#line 2627
  goto switch_break___1;
  case_131072: /* CIL Label */ 
  {
#line 2630
  error = aiff_open(psf);
  }
#line 2631
  goto switch_break___1;
  case_196608: /* CIL Label */ 
  {
#line 2634
  error = au_open(psf);
  }
#line 2635
  goto switch_break___1;
  case_262144: /* CIL Label */ 
  {
#line 2638
  error = raw_open(psf);
  }
#line 2639
  goto switch_break___1;
  case_720896: /* CIL Label */ 
  {
#line 2642
  error = w64_open(psf);
  }
#line 2643
  goto switch_break___1;
  case_2228224: /* CIL Label */ 
  {
#line 2646
  error = rf64_open(psf);
  }
#line 2647
  goto switch_break___1;
  case_327680: /* CIL Label */ 
  {
#line 2651
  error = paf_open(psf);
  }
#line 2652
  goto switch_break___1;
  case_393216: /* CIL Label */ 
  {
#line 2655
  error = svx_open(psf);
  }
#line 2656
  goto switch_break___1;
  case_458752: /* CIL Label */ 
  {
#line 2659
  error = nist_open(psf);
  }
#line 2660
  goto switch_break___1;
  case_655360: /* CIL Label */ 
  {
#line 2663
  error = ircam_open(psf);
  }
#line 2664
  goto switch_break___1;
  case_524288: /* CIL Label */ 
  {
#line 2667
  error = voc_open(psf);
  }
#line 2668
  goto switch_break___1;
  case_1114112: /* CIL Label */ 
  {
#line 2671
  error = sds_open(psf);
  }
#line 2672
  goto switch_break___1;
  case_2097152: /* CIL Label */ 
  {
#line 2675
  error = ogg_open(psf);
  }
#line 2676
  goto switch_break___1;
  case_67305472: /* CIL Label */ 
  {
#line 2679
  error = txw_open(psf);
  }
#line 2680
  goto switch_break___1;
  case_1638400: /* CIL Label */ 
  {
#line 2683
  error = wve_open(psf);
  }
#line 2684
  goto switch_break___1;
  case_67371008: /* CIL Label */ 
  {
#line 2687
  error = dwd_open(psf);
  }
#line 2688
  goto switch_break___1;
  case_786432: /* CIL Label */ 
  {
#line 2691
  error = mat4_open(psf);
  }
#line 2692
  goto switch_break___1;
  case_851968: /* CIL Label */ 
  {
#line 2695
  error = mat5_open(psf);
  }
#line 2696
  goto switch_break___1;
  case_917504: /* CIL Label */ 
  {
#line 2699
  error = pvf_open(psf);
  }
#line 2700
  goto switch_break___1;
  case_983040: /* CIL Label */ 
  {
#line 2703
  error = xi_open(psf);
  }
#line 2704
  goto switch_break___1;
  case_1048576: /* CIL Label */ 
  {
#line 2707
  error = htk_open(psf);
  }
#line 2708
  goto switch_break___1;
  case_1441792: /* CIL Label */ 
  {
#line 2711
  error = sd2_open(psf);
  }
#line 2712
  goto switch_break___1;
  case_67960832: /* CIL Label */ 
  {
#line 2715
  error = rx2_open(psf);
  }
#line 2716
  goto switch_break___1;
  case_1179648: /* CIL Label */ 
  {
#line 2719
  error = avr_open(psf);
  }
#line 2720
  goto switch_break___1;
  case_1507328: /* CIL Label */ 
  {
#line 2723
  error = flac_open(psf);
  }
#line 2724
  goto switch_break___1;
  case_1572864: /* CIL Label */ 
  {
#line 2727
  error = caf_open(psf);
  }
#line 2728
  goto switch_break___1;
  case_2162688: /* CIL Label */ 
  {
#line 2731
  error = mpc2k_open(psf);
  }
#line 2732
  goto switch_break___1;
  switch_default: /* CIL Label */ 
#line 2737
  error = 20;
  switch_break___1: /* CIL Label */ ;
  }

#line 2740
  if (error) {
#line 2741
    goto error_exit;
  }
#line 2744
  format = psf->sf.format & 268369920;
#line 2745
  if (psf->fileoffset > 0L) {
#line 2745
    if (format != 65536) {
#line 2745
      if (format != 1245184) {
#line 2745
        if (format != 131072) {
#line 2745
          if (format != 196608) {
#line 2749
            error = 26;
#line 2750
            goto error_exit;
          }
        }
      }
    }
  }

#line 2753
  if (psf->fileoffset > 0L) {
    {
#line 2754
    psf_log_printf(psf, "Embedded file length : %D\n\377\375\036V", psf->filelength);
    }
  }
  {
#line 2756
  __cil_tmp41 = sf_format_check(& psf->sf);
  }
#line 2756
  if (mode == 48) {
#line 2756
    if (__cil_tmp41 == 0) {
#line 2757
      error = 23;
#line 2758
      goto error_exit;
    }
  }
  {
#line 2761
  __cil_tmp42 = validate_sfinfo(& psf->sf);
  }
#line 2761
  if (__cil_tmp42 == 0) {
    {
#line 2762
    psf_log_SF_INFO(psf);
#line 2763
    save_header_info(psf);
#line 2764
    error = 24;
    }
#line 2765
    goto error_exit;
  }
  {
#line 2768
  __cil_tmp43 = validate_psf(psf);
  }
#line 2768
  if (__cil_tmp43 == 0) {
    {
#line 2769
    save_header_info(psf);
#line 2770
    error = 29;
    }
#line 2771
    goto error_exit;
  }
#line 2774
  psf->read_current = (sf_count_t )0;
#line 2775
  psf->write_current = (sf_count_t )0;
#line 2776
  if (psf->mode == 48) {
#line 2777
    psf->write_current = psf->sf.frames;
#line 2778
    if (psf->sf.frames > 0L) {
#line 2778
      tmp = 1;
    } else {
#line 2778
      tmp = 0;
    }
#line 2778
    psf->have_written = tmp;
  }
  {
#line 2781
  memcpy(sfinfo, & psf->sf, sizeof(SF_INFO ));
#line 2783
  memcpy(sfinfo, & psf->sf, sizeof(SF_INFO ));
  }
#line 2785
  return ((SNDFILE *)psf);
  error_exit: 
#line 2788
  sf_errno = error;
#line 2790
  if (error == 2) {
    {
#line 2791
    snprintf((char *)sf_syserr, sizeof(sf_syserr), "%s", (char *)psf->syserr);
    }
  }
  {
#line 2792
  snprintf((char *)sf_logbuffer, sizeof(sf_logbuffer), "%s", (char *)psf->logbuffer);
  }
  {
#line 2797
  if (error == 17) {
#line 2797
    goto case_17___0;
  }
#line 2797
  if (error == 4) {
#line 2797
    goto case_17___0;
  }
#line 2797
  if (error == 2) {
#line 2797
    goto case_17___0;
  }
#line 2800
  if (error == 91) {
#line 2800
    goto case_91;
  }
#line 2803
  goto switch_default___0;
  case_17___0: /* CIL Label */ 
  case_4___0: /* CIL Label */ 
  case_2___0: /* CIL Label */ 
#line 2798
  goto switch_break___2;
  case_91: /* CIL Label */ 
#line 2801
  goto switch_break___2;
  switch_default___0: /* CIL Label */ 
#line 2804
  if (psf->mode == 16) {
    {
#line 2805
    __cil_tmp45 = sf_error_number(error);
#line 2805
    psf_log_printf(psf, "Parse error : %s\n", __cil_tmp45);
#line 2806
    error = 3;
    }
  }

  switch_break___2: /* CIL Label */ ;
  }
  {
#line 2810
  psf_close(psf);
  }
#line 2811
  return ((SNDFILE *)((void *)0));
}
}
#line 60 "/root/libsndfile/programs/common.h"
void sfe_apply_metadata_changes(char const   *filenames[2] , METADATA_INFO *info ) ;
#line 62
void sfe_copy_data_fp(SNDFILE *outfile , SNDFILE *infile , int channels ) ;
#line 64
void sfe_copy_data_int(SNDFILE *outfile , SNDFILE *infile , int channels ) ;
#line 51 "/root/libsndfile/programs/sndfile-info.c"
static void print_version(void) ;
#line 52
static void print_usage(char const   *progname ) ;
#line 54
static void info_dump(char const   *filename ) ;
#line 55
static int instrument_dump(char const   *filename ) ;
#line 56
static int broadcast_dump(char const   *filename ) ;
#line 57
static void total_dump(void) ;
#line 59 "/root/libsndfile/programs/sndfile-info.c"
static double total_seconds  =    0.;
#line 62 "/root/libsndfile/programs/sndfile-info.c"
int main(int argc , char *argv[] ) 
{ 
  int k ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  char *progname ;
  char *__cil_tmp7 ;
  char *tmp ;
  int __cil_tmp9 ;
  int error ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int error___0 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;

  {
  {
#line 65
  print_version();
#line 67
  __cil_tmp5 = strcmp((char const   *)argv[1], "-h");
  }
  {
#line 67
  __cil_tmp4 = strcmp((char const   *)argv[1], "--help");
  }
#line 67
  if (argc < 2) {
    _L: /* CIL Label */ 
    _L___54: /* CIL Label */ 
    {
#line 70
    progname = strrchr((char const   *)argv[0], '/');
    }
#line 71
    if (progname) {
#line 71
      tmp = progname + 1;
    } else {
#line 71
      tmp = argv[0];
    }
    {
#line 71
    progname = tmp;
#line 73
    print_usage((char const   *)progname);
    }
#line 74
    return (1);
  } else
#line 67
  if (__cil_tmp4 == 0) {
#line 67
    goto _L;
  } else
#line 67
  if (__cil_tmp5 == 0) {
#line 67
    goto _L;
  }
  {
#line 77
  __cil_tmp9 = strcmp((char const   *)argv[1], "-i");
  }
#line 77
  if (__cil_tmp9 == 0) {
#line 78
    error = 0;
#line 80
    k = 2;
    {
#line 80
    while (1) {
      while_continue: /* CIL Label */ ;
#line 80
      if (! (k < argc)) {
#line 80
        goto while_break;
      }
      {
#line 81
      __cil_tmp11 = instrument_dump((char const   *)argv[k]);
      }
#line 81
      error += __cil_tmp11;
#line 80
      k ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 82
    return (error);
  }
  {
#line 85
  __cil_tmp13 = strcmp((char const   *)argv[1], "-b");
  }
#line 85
  if (__cil_tmp13 == 0) {
#line 86
    error___0 = 0;
#line 88
    k = 2;
    {
#line 88
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 88
      if (! (k < argc)) {
#line 88
        goto while_break___0;
      }
      {
#line 89
      __cil_tmp15 = broadcast_dump((char const   *)argv[k]);
      }
#line 89
      error___0 += __cil_tmp15;
#line 88
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 90
    return (error___0);
  }
#line 93
  k = 1;
  {
#line 93
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 93
    if (! (k < argc)) {
#line 93
      goto while_break___1;
    }
    {
#line 94
    info_dump((char const   *)argv[k]);
    }
#line 93
    k ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 96
  if (argc > 2) {
    {
#line 97
    total_dump();
    }
  }
#line 99
  return (0);
}
}
#line 106
static double data[65536] ;
#line 109 "/root/libsndfile/programs/sndfile-info.c"
static void print_version(void) 
{ 
  char buffer[256] ;

  {
  {
#line 112
  sf_command((SNDFILE *)((void *)0), 4096, (char *)buffer, (int )sizeof(buffer));
#line 113
  printf("\nVersion : %s\n\n", (char *)buffer);
  }
  return;
}
}
#line 118 "/root/libsndfile/programs/sndfile-info.c"
static void print_usage(char const   *progname ) 
{ 


  {
  {
#line 119
  printf("Usage :\n  %s <file> ...\n\230\001", progname);
#line 120
  printf("    Prints out information about one or more sound files.\n\n");
#line 121
  printf("  %s -i <file>\n", progname);
#line 122
  printf("    Prints out the instrument data for the given file.\n\n\220");
#line 123
  printf("  %s -b <file>\n", progname);
#line 124
  printf("    Prints out the broadcast WAV info for the given file.\n\n");
  }
  return;
}
}
#line 147 "/root/libsndfile/programs/sndfile-info.c"
static double get_signal_max(SNDFILE *file ) 
{ 
  double max ;

  {
  {
#line 150
  sf_command(file, 4160, & max, (int )sizeof(max));
  }
#line 152
  return (max);
}
}
#line 156 "/root/libsndfile/programs/sndfile-info.c"
static double calc_decibels(SF_INFO *sfinfo , double max ) 
{ 
  double decibels ;
  double __cil_tmp4 ;

  {
  {
#line 161
  if ((sfinfo->format & 65535) == 1) {
#line 161
    goto case_1;
  }
#line 161
  if ((sfinfo->format & 65535) == 5) {
#line 161
    goto case_1;
  }
#line 165
  if ((sfinfo->format & 65535) == 2) {
#line 165
    goto case_2;
  }
#line 169
  if ((sfinfo->format & 65535) == 3) {
#line 169
    goto case_3;
  }
#line 173
  if ((sfinfo->format & 65535) == 4) {
#line 173
    goto case_4;
  }
#line 178
  if ((sfinfo->format & 65535) == 7) {
#line 178
    goto case_7;
  }
#line 178
  if ((sfinfo->format & 65535) == 6) {
#line 178
    goto case_7;
  }
#line 182
  goto switch_default;
  case_1: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 162
  decibels = max / (double )128;
#line 163
  goto switch_break;
  case_2: /* CIL Label */ 
#line 166
  decibels = max / (double )32768;
#line 167
  goto switch_break;
  case_3: /* CIL Label */ 
#line 170
  decibels = max / (double )8388608;
#line 171
  goto switch_break;
  case_4: /* CIL Label */ 
#line 174
  decibels = max / (double )2147483648U;
#line 175
  goto switch_break;
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
#line 179
  decibels = max / 1.;
#line 180
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 183
  decibels = max / (double )32768;
#line 184
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 187
  __cil_tmp4 = log10(decibels);
  }
#line 187
  return (20. * __cil_tmp4);
}
}
#line 191 "/root/libsndfile/programs/sndfile-info.c"
static char const   *format_duration_str(double seconds ) 
{ 
  static char str[128] ;
  int hrs ;
  int min ;
  double sec ;

  {
  {
#line 196
  memset((char *)str, 0, sizeof(str));
#line 198
  hrs = (int )(seconds / 3600.);
#line 199
  min = (int )((seconds - (double )hrs * 3600.) / 60.);
#line 200
  sec = (seconds - (double )hrs * 3600.) - (double )min * 60.;
#line 202
  snprintf((char *)str, sizeof(str) - 1UL, "%02d:%02d:%06.3f\230\001", hrs, min, sec);
  }
#line 204
  return ((char const   *)((char *)str));
}
}
#line 208 "/root/libsndfile/programs/sndfile-info.c"
static char const   *generate_duration_str(SF_INFO *sfinfo ) 
{ 
  double seconds ;
  char const   *__cil_tmp3 ;

  {
#line 212
  if (sfinfo->samplerate < 1) {
#line 213
    return ((char const   *)((void *)0));
  }
#line 215
  if (sfinfo->frames / (long )sfinfo->samplerate > 2147483647L) {
#line 216
    return ("unknown");
  }
  {
#line 218
  seconds = (1. * (double )sfinfo->frames) / (double )sfinfo->samplerate;
#line 221
  total_seconds += seconds;
#line 223
  __cil_tmp3 = format_duration_str(seconds);
  }
#line 223
  return (__cil_tmp3);
}
}
#line 227 "/root/libsndfile/programs/sndfile-info.c"
static void info_dump(char const   *filename ) 
{ 
  static char strbuffer[65536] ;
  SNDFILE *file ;
  SF_INFO sfinfo ;
  double signal_max ;
  double decibels ;
  SNDFILE *__cil_tmp7 ;
  char const   *__cil_tmp8 ;
  char const   *tmp ;
  char const   *__cil_tmp10 ;
  double __cil_tmp11 ;
  double __cil_tmp12 ;

  {
  {
#line 233
  memset(& sfinfo, 0, sizeof(sfinfo));
#line 235
  file = sf_open(filename, 16, & sfinfo);
  }
#line 235
  if (file == (void *)0) {
    {
#line 236
    printf("Error : Not able to open input file %s.\n\230\001", filename);
#line 237
    fflush(stdout);
#line 238
    memset((double *)data, 0, sizeof(data));
#line 239
    sf_command(file, 4097, (char *)strbuffer, 1 << 16);
#line 240
    puts((char const   *)((char *)strbuffer));
#line 241
    __cil_tmp8 = sf_strerror((SNDFILE *)((void *)0));
#line 241
    puts(__cil_tmp8);
    }
#line 242
    return;
  }
  {
#line 245
  printf("========================================\n");
#line 246
  sf_command(file, 4097, (char *)strbuffer, 1 << 16);
#line 247
  puts((char const   *)((char *)strbuffer));
#line 248
  printf("----------------------------------------\n");
#line 250
  printf("Sample Rate : %d\n", sfinfo.samplerate);
#line 251
  printf("Frames      : %ld\n", sfinfo.frames);
#line 252
  printf("Channels    : %d\n", sfinfo.channels);
#line 253
  printf("Format      : 0x%08X\n", sfinfo.format);
#line 254
  printf("Sections    : %d\n", sfinfo.sections);
  }
#line 255
  if (sfinfo.seekable) {
#line 255
    tmp = "TRUE";
  } else {
#line 255
    tmp = "FALSE";
  }
  {
#line 255
  printf("Seekable    : %s\n", tmp);
#line 256
  __cil_tmp10 = generate_duration_str(& sfinfo);
#line 256
  printf("Duration    : %s\n", __cil_tmp10);
  }
#line 258
  if (sfinfo.frames < 104857600L) {
    {
#line 260
    signal_max = get_signal_max(file);
#line 261
    decibels = calc_decibels(& sfinfo, signal_max);
#line 262
    printf("Signal Max  : %g (%4.2f dB)\n", signal_max, decibels);
    }
  }
  {
#line 264
  putchar('\n');
#line 266
  sf_close(file);
  }
  return;
}
}
#line 275 "/root/libsndfile/programs/sndfile-info.c"
static char const   *str_of_type(int mode ) 
{ 


  {
  {
#line 277
  if (mode == 800) {
#line 277
    goto case_800;
  }
#line 278
  if (mode == 801) {
#line 278
    goto case_801;
  }
#line 279
  if (mode == 802) {
#line 279
    goto case_802;
  }
#line 280
  if (mode == 803) {
#line 280
    goto case_803;
  }
#line 281
  goto switch_default;
  case_800: /* CIL Label */ 
#line 277
  return ("none");
  case_801: /* CIL Label */ 
#line 278
  return ("fwd ");
  case_802: /* CIL Label */ 
#line 279
  return ("back");
  case_803: /* CIL Label */ 
#line 280
  return ("alt ");
  switch_default: /* CIL Label */ 
#line 281
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }

#line 284
  return ("????");
}
}
#line 288 "/root/libsndfile/programs/sndfile-info.c"
static int instrument_dump(char const   *filename ) 
{ 
  SNDFILE *file ;
  SF_INFO sfinfo ;
  SF_INSTRUMENT inst ;
  int got_inst ;
  int k ;
  SNDFILE *__cil_tmp7 ;
  char const   *__cil_tmp8 ;
  int __cil_tmp9 ;
  char const   *__cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 294
  memset(& sfinfo, 0, sizeof(sfinfo));
#line 296
  file = sf_open(filename, 16, & sfinfo);
  }
#line 296
  if (file == (void *)0) {
    {
#line 297
    printf("Error : Not able to open input file %s.\n\230\001", filename);
#line 298
    fflush(stdout);
#line 299
    memset((double *)data, 0, sizeof(data));
#line 300
    __cil_tmp8 = sf_strerror((SNDFILE *)((void *)0));
#line 300
    puts(__cil_tmp8);
    }
#line 301
    return (1);
  }
  {
#line 304
  got_inst = sf_command(file, 4304, & inst, (int )sizeof(inst));
#line 305
  sf_close(file);
  }
#line 307
  if (got_inst == 0) {
    {
#line 308
    printf("Error : File \'%s\' does not contain instrument data.\n\n", filename);
    }
#line 309
    return (1);
  }
  {
#line 312
  printf("Instrument : %s\n\n", filename);
#line 313
  printf("  Gain        : %d\n", inst.gain);
#line 314
  printf("  Base note   : %d\n", (int )inst.basenote);
#line 315
  printf("  Velocity    : %d - %d\n\230\001", (int )inst.velocity_lo, (int )inst.velocity_hi);
#line 316
  printf("  Key         : %d - %d\n\230\001", (int )inst.key_lo, (int )inst.key_hi);
#line 317
  printf("  Loop points : %d\n\376\036V", inst.loop_count);
#line 319
  k = 0;
  }
  {
#line 319
  while (1) {
    while_continue: /* CIL Label */ ;
#line 319
    if (! (k < inst.loop_count)) {
#line 319
      goto while_break;
    }
    {
#line 320
    __cil_tmp10 = str_of_type(inst.loops[k].mode);
#line 320
    printf("  %-2d    Mode : %s    Start : %6d   End : %6d   Count : %6d\n", k, __cil_tmp10,
           inst.loops[k].start, inst.loops[k].end, inst.loops[k].count);
    }
#line 319
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 322
  putchar('\n');
  }
#line 323
  return (0);
}
}
#line 327 "/root/libsndfile/programs/sndfile-info.c"
static int broadcast_dump(char const   *filename ) 
{ 
  SNDFILE *file ;
  SF_INFO sfinfo ;
  SF_BROADCAST_INFO_2K bext ;
  double time_ref_sec ;
  int got_bext ;
  SNDFILE *__cil_tmp7 ;
  char const   *__cil_tmp8 ;
  int __cil_tmp9 ;
  double __cil_tmp10 ;

  {
  {
#line 334
  memset(& sfinfo, 0, sizeof(sfinfo));
#line 336
  file = sf_open(filename, 16, & sfinfo);
  }
#line 336
  if (file == (void *)0) {
    {
#line 337
    printf("Error : Not able to open input file %s.\n\230\001", filename);
#line 338
    fflush(stdout);
#line 339
    memset((double *)data, 0, sizeof(data));
#line 340
    __cil_tmp8 = sf_strerror((SNDFILE *)((void *)0));
#line 340
    puts(__cil_tmp8);
    }
#line 341
    return (1);
  }
  {
#line 344
  memset(& bext, 0, sizeof(SF_BROADCAST_INFO_2K ));
#line 346
  got_bext = sf_command(file, 4336, & bext, (int )sizeof(bext));
#line 347
  sf_close(file);
  }
#line 349
  if (got_bext == 0) {
    {
#line 350
    printf("Error : File \'%s\' does not contain broadcast information.\n\n\376\036V",
           filename);
    }
#line 351
    return (1);
  }
  {
#line 362
  __cil_tmp10 = pow(2., (double )32);
#line 362
  time_ref_sec = (__cil_tmp10 * (double )bext.time_reference_high + 1. * (double )bext.time_reference_low) / (double )sfinfo.samplerate;
#line 364
  printf("Description      : %.*s\n\230\001\200\376\025Z\002", (int )sizeof(bext.description),
         (char *)bext.description);
#line 365
  printf("Originator       : %.*s\n\230\001\200\376pZ\002", (int )sizeof(bext.originator),
         (char *)bext.originator);
#line 366
  printf("Origination ref  : %.*s\n\230\001\200", (int )sizeof(bext.originator_reference),
         (char *)bext.originator_reference);
#line 367
  printf("Origination date : %.*s\n\230\001\200", (int )sizeof(bext.origination_date),
         (char *)bext.origination_date);
#line 368
  printf("Origination time : %.*s\n\230\001\200", (int )sizeof(bext.origination_time),
         (char *)bext.origination_time);
  }
#line 370
  if (bext.time_reference_high == 0U) {
#line 370
    if (bext.time_reference_low == 0U) {
      {
#line 371
      printf("Time ref         : 0\nV");
      }
    } else {
      {
      {
#line 373
      printf("Time ref         : 0x%x%08x (%.6f seconds)\n\376\036V", bext.time_reference_high,
             bext.time_reference_low, time_ref_sec);
      }
      }
    }
  } else {
    {
    {
#line 373
    printf("Time ref         : 0x%x%08x (%.6f seconds)\n\376\036V", bext.time_reference_high,
           bext.time_reference_low, time_ref_sec);
    }
    }
  }
  {
#line 375
  printf("BWF version      : %d\n", (int )bext.version);
#line 376
  printf("UMID             : %.*s\n\230\001\200", (int )sizeof(bext.umid), (char *)bext.umid);
#line 377
  printf("Coding history   : %.*s\n\230\001", bext.coding_history_size, (char *)bext.coding_history);
  }
#line 379
  return (0);
}
}
#line 383 "/root/libsndfile/programs/sndfile-info.c"
static void total_dump(void) 
{ 
  char const   *__cil_tmp1 ;

  {
  {
#line 384
  printf("========================================\n");
#line 385
  __cil_tmp1 = format_duration_str(total_seconds);
#line 385
  printf("Total Duration : %s\n", __cil_tmp1);
  }
  return;
}
}
